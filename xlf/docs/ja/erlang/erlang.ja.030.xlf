<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="383d8ab46c4dd3dcb7dacf32d96619c30112c096" translate="yes" xml:space="preserve">
          <source>Note that RFC 6733 requires that End-to-End Identifiers remain unique for a period of at least 4 minutes and that this and the call rate places a lower bound on appropriate values of &lt;code&gt;N&lt;/code&gt;: at a rate of &lt;code&gt;R&lt;/code&gt; requests per second, an &lt;code&gt;N&lt;/code&gt;-bit counter traverses all of its values in &lt;code&gt;(1 bsl N) div (R*60)&lt;/code&gt; minutes, so the bound is &lt;code&gt;4*R*60 =&amp;lt; 1 bsl N&lt;/code&gt;.</source>
          <target state="translated">RFC 6733では、エンドツーエンド識別子が少なくとも4分間は一意である必要があり、これとコールレートが &lt;code&gt;N&lt;/code&gt; の適切な値に下限を設定することに注意してください &lt;code&gt;R&lt;/code&gt; リクエスト/秒のレートで、 &lt;code&gt;N&lt;/code&gt; ビットカウンターはその値のすべてを &lt;code&gt;(1 bsl N) div (R*60)&lt;/code&gt; 分でトラバースするため、境界は &lt;code&gt;4*R*60 =&amp;lt; 1 bsl N&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="ab161900c8191797fce6b824ca72c3fe1be8d39b" translate="yes" xml:space="preserve">
          <source>Note that TLS-1.3 and TLS-1.2 cipher suites are not overlapping sets of cipher suites so to support both these versions cipher suites from both versions need to be included. If supporting TLS-1.3 versions prior to TLS-1.2 can not be supported.</source>
          <target state="translated">TLS-1.3 と TLS-1.2 の暗号スイートは重複する暗号スイートではないので、これらのバージョンの両方をサポートするためには、両方のバージョンの暗号スイートを含める必要があることに注意してください。TLS-1.2 より前のバージョンの TLS-1.3 をサポートすることはできません。</target>
        </trans-unit>
        <trans-unit id="d954d0938e64e5c37a1b11f9fbf14279ee90b30d" translate="yes" xml:space="preserve">
          <source>Note that \0dd is always an octal code, and that \8 and \9 are the literal characters &quot;8&quot; and &quot;9&quot;.</source>
          <target state="translated">なお、「\0dd」は常に8進数であり、「\8」と「\9」はリテラル文字の「8」と「9」であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="fa00a5e7155faa8238baf7626fd63ae2adafb209" translate="yes" xml:space="preserve">
          <source>Note that a &lt;strong&gt;state enter call&lt;/strong&gt;&lt;strong&gt;will&lt;/strong&gt; be done right before entering the initial state even though this actually is not a &lt;strong&gt;state change&lt;/strong&gt;. In this case &lt;code&gt;OldState =:= State&lt;/code&gt;, which cannot happen for a subsequent state change, but will happen when repeating the &lt;strong&gt;state enter call&lt;/strong&gt;.</source>
          <target state="translated">これは実際には&lt;strong&gt;状態変更で&lt;/strong&gt;はありませんが、&lt;strong&gt;状態入力呼び出し&lt;/strong&gt;&lt;strong&gt;は&lt;/strong&gt;初期状態に入る直前に行わ&lt;strong&gt;れる&lt;/strong&gt;ことに注意してください。この場合、 &lt;code&gt;OldState =:= State&lt;/code&gt; 。これは、後続の状態変更では発生しませんが、state entercallを繰り返すと発生し&lt;strong&gt;ます&lt;/strong&gt;。&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dd8f4a584e7baae9c7b73d493c112b4faac49187" translate="yes" xml:space="preserve">
          <source>Note that a dictionary module should have a unique name so as not collide with existing modules in the system.</source>
          <target state="translated">システム内の既存のモジュールと衝突しないように、辞書モジュールは一意の名前を持つべきであることに注意してください。</target>
        </trans-unit>
        <trans-unit id="7d48dfa81ed35ed91309a0c63bf84e4d12b8db94" translate="yes" xml:space="preserve">
          <source>Note that a dictionary's &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#name&quot;&gt;@name&lt;/a&gt;&lt;/code&gt;&lt;/code&gt;, together with the &lt;code&gt;outdir&lt;/code&gt; option, determine the output paths when the &lt;code&gt;return&lt;/code&gt; option is not specified. The &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#name&quot;&gt;@name&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; of a literal input dictionary defaults to &lt;code&gt;dictionary&lt;/code&gt;.</source>
          <target state="translated">辞書の &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#name&quot;&gt;@name&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; は、 &lt;code&gt;outdir&lt;/code&gt; オプションとともに、 &lt;code&gt;return&lt;/code&gt; オプションが指定されていない場合の出力パスを決定することに注意してください。リテラル入力辞書の &lt;code&gt;&lt;code&gt;&lt;a href=&quot;diameter_dict#name&quot;&gt;@name&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; は、デフォルトで &lt;code&gt;dictionary&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="592ecd079ddc2c5dbec2876bde4efe18192a7501" translate="yes" xml:space="preserve">
          <source>Note that a distributed node will fail to start if epmd is not running.</source>
          <target state="translated">epmd が実行されていない場合、分散ノードの起動に失敗することに注意してください。</target>
        </trans-unit>
        <trans-unit id="210dee4c712f6038124cea11c85e7ab317eb49aa" translate="yes" xml:space="preserve">
          <source>Note that a single &lt;code&gt;up&lt;/code&gt; or &lt;code&gt;down&lt;/code&gt; event for a given peer corresponds to multiple &lt;code&gt;peer_up/3&lt;/code&gt; or &lt;code&gt;peer_down/3&lt;/code&gt; callbacks, one for each of the Diameter applications negotiated during capabilities exchange. That is, the event communicates connectivity with the peer as a whole while the callbacks communicate connectivity with respect to individual Diameter applications.</source>
          <target state="translated">特定のピアの単一の &lt;code&gt;up&lt;/code&gt; または &lt;code&gt;down&lt;/code&gt; イベントは、機能交換中にネゴシエートされた各Diameterアプリケーションに1つずつ、複数の &lt;code&gt;peer_up/3&lt;/code&gt; または &lt;code&gt;peer_down/3&lt;/code&gt; コールバックに対応することに注意してください。つまり、イベントは全体としてピアとの接続を通信し、コールバックは個々のDiameterアプリケーションに関する接続を通信します。</target>
        </trans-unit>
        <trans-unit id="87238ebabfbb3a6373dc0cd859835703ac206a8a" translate="yes" xml:space="preserve">
          <source>Note that a state enter call &lt;strong&gt;will&lt;/strong&gt; be done right before entering the initial state even though this formally is not a state change. In this case &lt;code&gt;OldState&lt;/code&gt; will be the same as &lt;code&gt;State&lt;/code&gt;, which can not happen for a subsequent state change, but will happen when repeating the state enter call.</source>
          <target state="translated">これは正式には状態の変化ではありませんが、初期状態に入る直前に状態開始呼び出し&lt;strong&gt;が&lt;/strong&gt;行わ&lt;strong&gt;れる&lt;/strong&gt;ことに注意してください。この場合、 &lt;code&gt;OldState&lt;/code&gt; は &lt;code&gt;State&lt;/code&gt; と同じになります。これは、後続の状態変更では発生しませんが、state enter呼び出しを繰り返すと発生します。</target>
        </trans-unit>
        <trans-unit id="1a1ae5ee8fe086b1e864731f91a5db626649b898" translate="yes" xml:space="preserve">
          <source>Note that all other users are &lt;strong&gt;locked out&lt;/strong&gt; until the 'current user' has called the function (recv in this case).</source>
          <target state="translated">'現在のユーザー'が関数（この場合はrecv）を呼び出すまで、他のすべてのユーザーは&lt;strong&gt;ロックアウトされる&lt;/strong&gt;ことに注意してください。</target>
        </trans-unit>
        <trans-unit id="fb520f2054c75e0b1b39831bcf49afdb1c0b3e3f" translate="yes" xml:space="preserve">
          <source>Note that all other users are &lt;strong&gt;locked out&lt;/strong&gt; until the 'current user' has called the function (recv in this case). So either immediately call the function or &lt;code&gt;&lt;a href=&quot;socket#cancel-2&quot;&gt;cancel&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">'現在のユーザー'が関数（この場合はrecv）を呼び出すまで、他のすべてのユーザーは&lt;strong&gt;ロックアウトされる&lt;/strong&gt;ことに注意してください。したがって、すぐに関数を呼び出すか、 &lt;code&gt;&lt;a href=&quot;socket#cancel-2&quot;&gt;cancel&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cea408404d235688202589e612b275a8ce277c9d" translate="yes" xml:space="preserve">
          <source>Note that all processing is done in the context of the calling process. A transport module could call this function via one of the &lt;code&gt;spawn&lt;/code&gt; functions (e.g. &lt;code&gt;spawn_opt&lt;/code&gt;). See also &lt;code&gt;receive_message/4,5&lt;/code&gt;.</source>
          <target state="translated">すべての処理は呼び出しプロセスのコンテキストで行われることに注意してください。トランスポートモジュールは、 &lt;code&gt;spawn&lt;/code&gt; 関数の1つ（たとえば &lt;code&gt;spawn_opt&lt;/code&gt; ）を介してこの関数を呼び出すことができます。 &lt;code&gt;receive_message/4,5&lt;/code&gt; も参照してください。</target>
        </trans-unit>
        <trans-unit id="c3db41f10bff721f3ee02192c83ee3f08a54b12b" translate="yes" xml:space="preserve">
          <source>Note that although guard expressions should only yield boolean values, this function does not guarantee that &lt;code&gt;Term&lt;/code&gt; is either &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. Also note that only simple constructs like let-expressions are examined recursively; general constant folding is not performed.</source>
          <target state="translated">ガード式はブール値のみを生成する必要がありますが、この関数は &lt;code&gt;Term&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; または &lt;code&gt;false&lt;/code&gt; のいずれかであることを保証しないことに注意してください。また、let-expressionsのような単純な構成のみが再帰的に検査されることに注意してください。一般的な定数畳み込みは実行されません。</target>
        </trans-unit>
        <trans-unit id="f01d1482d475dcf2740463e55c6c430cd948d4e9" translate="yes" xml:space="preserve">
          <source>Note that an SMIv2 MIB can import an SMIv1 MIB and vice versa.</source>
          <target state="translated">SMIv2 MIBはSMIv1 MIBをインポートすることができ、その逆も可能であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="9b685cbc242545fbad15153c417da3182cac4fef" translate="yes" xml:space="preserve">
          <source>Note that an abstract atom may have several literal representations, and that the representation yielded by this function is not fixed; e.g., &lt;code&gt;atom_lit(c_atom(&quot;a\012b&quot;))&lt;/code&gt; could yield the string &lt;code&gt;&quot;\'a\\nb\'&quot;&lt;/code&gt;.</source>
          <target state="translated">抽象アトムにはいくつかのリテラル表現がある場合があり、この関数によって生成される表現は固定されていないことに注意してください。たとえば、 &lt;code&gt;atom_lit(c_atom(&quot;a\012b&quot;))&lt;/code&gt; は、文字列 &lt;code&gt;&quot;\'a\\nb\'&quot;&lt;/code&gt; 生成できます。</target>
        </trans-unit>
        <trans-unit id="85f6954c77f955dafa6a2e123d05e96d272275df" translate="yes" xml:space="preserve">
          <source>Note that an alias-name is only unique within the mib, so when loading several mib's into a manager, there might be several instances of the same aliasname.</source>
          <target state="translated">エイリアス名は mib 内でのみ一意なので、複数の mib をマネージャにロードすると、同じエイリアス名のインスタンスが複数存在する可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="ffe0be9b4d38daeed36a33562bc4da5606bc0b2f" translate="yes" xml:space="preserve">
          <source>Note that an event time-out does not work well when you have for example a status call as in section &lt;code&gt;&lt;a href=&quot;#All%20State%20Events&quot;&gt;All State Events&lt;/a&gt;&lt;/code&gt;, or handle unknown events, since all kinds of events will cancel the event time-out.</source>
          <target state="translated">たとえば、「 &lt;code&gt;&lt;a href=&quot;#All%20State%20Events&quot;&gt;All State Events&lt;/a&gt;&lt;/code&gt; 」セクションのようなステータスコールがある場合、または不明なイベントを処理する場合、すべての種類のイベントがイベントタイムアウトをキャンセルするため、イベントタイムアウトは適切に機能しないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="44d8f63bf6bc16034f55c5cb547506223b7f3f16" translate="yes" xml:space="preserve">
          <source>Note that an event time-out does not work well with when you have for example a status call as in &lt;code&gt;&lt;a href=&quot;#All%20State%20Events&quot;&gt;All State Events&lt;/a&gt;&lt;/code&gt;, or handle unknown events, since all kinds of events will cancel the event time-out.</source>
          <target state="translated">すべての種類のイベントがイベントのタイムアウトをキャンセルするため、イベントタイムアウトは、たとえば[ &lt;code&gt;&lt;a href=&quot;#All%20State%20Events&quot;&gt;All State Events&lt;/a&gt;&lt;/code&gt; ようにステータスコールがある場合や、不明なイベントを処理する場合にはうまく機能しないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="def0f5ad0a0ace41622689a594950eb3fe32da96" translate="yes" xml:space="preserve">
          <source>Note that an inherited AVP that sets the V flag takes its Vendor-Id from either &lt;code&gt;@avp_vendor_id&lt;/code&gt; in the inheriting dictionary or &lt;code&gt;@vendor&lt;/code&gt; in the inherited dictionary. In particular, &lt;code&gt;@avp_vendor_id&lt;/code&gt; in the inherited dictionary is ignored. Inheriting from a dictionary that specifies the required &lt;code&gt;@vendor&lt;/code&gt; is equivalent to using &lt;code&gt;@avp_vendor_id&lt;/code&gt; with a copy of the dictionary's definitions but the former makes for easier reuse.</source>
          <target state="translated">Vフラグを設定する継承されたAVP は、継承するディクショナリの &lt;code&gt;@vendor&lt;/code&gt; または継承されたディクショナリの &lt;code&gt;@avp_vendor_id&lt;/code&gt; からVendor-Idを取得することに注意してください。特に、継承されたディクショナリの &lt;code&gt;@avp_vendor_id&lt;/code&gt; は無視されます。必要な &lt;code&gt;@vendor&lt;/code&gt; を指定するディクショナリから継承することは、ディクショナリの定義のコピーで &lt;code&gt;@avp_vendor_id&lt;/code&gt; を使用することと同じですが、前者は再利用を容易にします。</target>
        </trans-unit>
        <trans-unit id="6d33800347145579293148a2f5b8e31e3a2764de" translate="yes" xml:space="preserve">
          <source>Note that arguments for macros cannot be complex expressions, because the arguments are split on &lt;code&gt;,&lt;/code&gt;. For example, the following would not work because &lt;strong&gt;beam_makeops&lt;/strong&gt; would split the expression into two arguments:</source>
          <target state="translated">引数がで分割されているので、マクロの引数は、複雑な式にすることはできません &lt;code&gt;,&lt;/code&gt; 。たとえば、&lt;strong&gt;beam_makeops&lt;/strong&gt;は式を2つの引数に分割するため、以下は機能しません。</target>
        </trans-unit>
        <trans-unit id="f5995dd05307d17cf1cf0275ae54c1c965044890" translate="yes" xml:space="preserve">
          <source>Note that both lists in &lt;code&gt;cipher&lt;/code&gt; has been changed to the provided value (&lt;code&gt;'aes128-ctr'&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;cipher&lt;/code&gt; 両方のリストが提供された値（ &lt;code&gt;'aes128-ctr'&lt;/code&gt; ）に変更されていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="a24670d7b6d01336c8695b5d4d57a391c44adcb2" translate="yes" xml:space="preserve">
          <source>Note that capabilities for an outgoing hello can be passed directly to &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">発信helloの機能は、 &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; に直接渡すことができることに注意してください。</target>
        </trans-unit>
        <trans-unit id="e251f553696cbbe8af62f9b6e14b96ffcbc62108" translate="yes" xml:space="preserve">
          <source>Note that clauses following a default action will be ignored.</source>
          <target state="translated">デフォルトのアクションに続く節は無視されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="0160a9b8ce02f625812816b1ccc97166a7bb4956" translate="yes" xml:space="preserve">
          <source>Note that client_random, server_random and master_secret are values that affect the security of connection. Meaningful atoms, not specified above, are the ssl option names.</source>
          <target state="translated">client_random、server_random、master_secret は接続のセキュリティに影響を与える値であることに注意してください。上記で指定されていない意味のあるアトムは、ssl オプション名です。</target>
        </trans-unit>
        <trans-unit id="f5dd2f74718152ce40902beac42e0c7a6f30ccfb" translate="yes" xml:space="preserve">
          <source>Note that client_random, server_random, master_secret and keylog are values that affect the security of connection. Meaningful atoms, not specified above, are the ssl option names.</source>
          <target state="translated">client_random、server_random、master_secret、keylogは接続のセキュリティに影響を与える値であることに注意してください。上記で指定されていない意味のあるアトムは、ssl オプション名です。</target>
        </trans-unit>
        <trans-unit id="67bf6b7b0630a07fa672109442d6b02fb72a8793" translate="yes" xml:space="preserve">
          <source>Note that doing the primary log level filtering through a filter and not through the level is quite a lot more expensive, so make sure to test that your system can handle the extra load before you enable it on a production node.</source>
          <target state="translated">プライマリ・ログ・レベルのフィルタリングをフィルタで行うと、レベルを通さずにフィルタリングを行うと、かなりのコストがかかることに注意してください。</target>
        </trans-unit>
        <trans-unit id="1fbc0b27f1c4b9334d7d0f187cdb9b5cc6eedece" translate="yes" xml:space="preserve">
          <source>Note that e.g. the result of &lt;code&gt;atom(&quot;x\ny&quot;)&lt;/code&gt; represents any and all of `x\ny'', `x\12y'', `x\012y'' and `x\^Jy\''; see &lt;code&gt;&lt;a href=&quot;#string-1&quot;&gt;string/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">たとえば、 &lt;code&gt;atom(&quot;x\ny&quot;)&lt;/code&gt; の結果は、「x \ ny」、「x \ 12y」、「x \ 012y」、「x \ ^ Jy \」のすべてを表します。 &lt;code&gt;&lt;a href=&quot;#string-1&quot;&gt;string/1&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="ba188de7ea4673245bb93e421ced2f5246f6549c" translate="yes" xml:space="preserve">
          <source>Note that each tuple communicates one or more AVP values. It is an error to specify duplicate tuples.</source>
          <target state="translated">各タプルは1つ以上のAVP値を通信することに注意してください。重複したタプルを指定するのはエラーです。</target>
        </trans-unit>
        <trans-unit id="edc604b194978efcbdba0cbc4b89b369a9c99a82" translate="yes" xml:space="preserve">
          <source>Note that ec_gf2m is not strictly a public key algorithm, but a restriction on what curves are supported with ecdsa and ecdh.</source>
          <target state="translated">ec_gf2m は厳密には公開鍵アルゴリズムではなく、 ecdsa と ecdh でサポートされる曲線の制限であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="29cd43d95778b2d115dbf308b03c62ae1c0160c0" translate="yes" xml:space="preserve">
          <source>Note that even if this function returns some &lt;code&gt;Tail&lt;/code&gt; that is not &lt;code&gt;none&lt;/code&gt;, the type of &lt;code&gt;Tail&lt;/code&gt; can be &lt;code&gt;nil&lt;/code&gt;, if the tail has been given explicitly, and the list skeleton has not been compacted (see &lt;code&gt;&lt;a href=&quot;#compact_list-1&quot;&gt;compact_list/1&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">この関数が &lt;code&gt;none&lt;/code&gt; ではない &lt;code&gt;Tail&lt;/code&gt; を返す場合でも、テールが明示的に指定されていて、リストのスケルトンが圧縮されていない場合は、 &lt;code&gt;Tail&lt;/code&gt; のタイプを &lt;code&gt;nil&lt;/code&gt; にすることができます（ &lt;code&gt;&lt;a href=&quot;#compact_list-1&quot;&gt;compact_list/1&lt;/a&gt;&lt;/code&gt; を参照）。</target>
        </trans-unit>
        <trans-unit id="192c5999ce9ab89a2a2dbe3ec7c900d7ee1db0a4" translate="yes" xml:space="preserve">
          <source>Note that file and line have to be added in the metadata by the caller of &lt;code&gt;&lt;a href=&quot;logger#log-3&quot;&gt;logger:log/3&lt;/a&gt;&lt;/code&gt; as otherwise Logger will not know from where it was called. The file and line number are automatically added if you use the &lt;code&gt;?LOG_ERROR&lt;/code&gt; macros in &lt;code&gt;kernel/include/logger.hrl&lt;/code&gt;.</source>
          <target state="translated">ファイルと行は、 &lt;code&gt;&lt;a href=&quot;logger#log-3&quot;&gt;logger:log/3&lt;/a&gt;&lt;/code&gt; の呼び出し元がメタデータに追加する必要があることに注意してください。そうしないと、Loggerはどこから呼び出されたかを認識できません。 &lt;code&gt;kernel/include/logger.hrl&lt;/code&gt; で &lt;code&gt;?LOG_ERROR&lt;/code&gt; マクロを使用すると、ファイルと行番号が自動的に追加されます。</target>
        </trans-unit>
        <trans-unit id="c389355e70f459658e087541ff06cacc40c70758" translate="yes" xml:space="preserve">
          <source>Note that for e.g. &lt;code&gt;protocol&lt;/code&gt; = &lt;code&gt;tcp&lt;/code&gt;, most implementations doing a close does not guarantee that any data sent is delivered to the recipient before the close is detected at the remote side.</source>
          <target state="translated">たとえば &lt;code&gt;protocol&lt;/code&gt; = &lt;code&gt;tcp&lt;/code&gt; の場合、クローズを実行するほとんどの実装は、リモート側でクローズが検出される前に、送信されたデータが受信者に配信されることを保証しないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="3b99d2d0f80623c57fbaf51f6886234e7e4b951d" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;EngineId&lt;/code&gt; has the value &lt;code&gt;discovery&lt;/code&gt;, the agent cannot send &lt;code&gt;inform&lt;/code&gt; messages to that manager until it has performed the &lt;strong&gt;discovery&lt;/strong&gt; process with that manager.</source>
          <target state="translated">場合ことを注意 &lt;code&gt;EngineId&lt;/code&gt; 値がある &lt;code&gt;discovery&lt;/code&gt; 、エージェントが送信することはできません &lt;code&gt;inform&lt;/code&gt; 、それが実行されるまで、そのマネージャにメッセージを&lt;strong&gt;発見&lt;/strong&gt;そのマネージャでプロセスを。</target>
        </trans-unit>
        <trans-unit id="55bac8de272758448fe7d117efd8941f423d23e9" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;udp&lt;/code&gt; is used, the same transport process could be used for several connections. This could make upgrading impossible.</source>
          <target state="translated">&lt;code&gt;udp&lt;/code&gt; を使用する場合、同じトランスポートプロセスを複数の接続に使用できることに注意してください。これはアップグレードを不可能にする可能性があります。</target>
        </trans-unit>
        <trans-unit id="18ab9ea99f0d2ed9aaa93df42d7129d992c9c108" translate="yes" xml:space="preserve">
          <source>Note that if a length (&lt;code&gt;&amp;gt; 0&lt;/code&gt;) is specified, and only part of that amount of data is available, the function will return with that data &lt;strong&gt;and&lt;/strong&gt; the &lt;code&gt;SelectInfo&lt;/code&gt; (if the caller don't want to wait for the remaining data, it must immediately call the &lt;code&gt;&lt;a href=&quot;#cancel-2&quot;&gt;cancel/2&lt;/a&gt;&lt;/code&gt; function.)</source>
          <target state="translated">場合は、長さが（という注 &lt;code&gt;&amp;gt; 0&lt;/code&gt; ）が指定され、データの量の一部のみが利用可能な、機能がそのデータに戻ります&lt;strong&gt;と&lt;/strong&gt; &lt;code&gt;SelectInfo&lt;/code&gt; 呼び出し側が、残りのデータを待機させたくない場合は、それがなければなりません（すぐに &lt;code&gt;&lt;a href=&quot;#cancel-2&quot;&gt;cancel/2&lt;/a&gt;&lt;/code&gt; 関数を呼び出します。）</target>
        </trans-unit>
        <trans-unit id="ed4a9e62154b96609da080c17aec27f4dd9246b0" translate="yes" xml:space="preserve">
          <source>Note that if no &lt;code&gt;port&lt;/code&gt; is given and if &lt;code&gt;taddress&lt;/code&gt; does not contain a port number, the default value is used.</source>
          <target state="translated">&lt;code&gt;port&lt;/code&gt; が指定されておらず、 &lt;code&gt;taddress&lt;/code&gt; にポート番号が含まれていない場合は、デフォルト値が使用されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="c6b057ff98ba4785947d02f48c8fb42e16a4c39b" translate="yes" xml:space="preserve">
          <source>Note that if no &lt;code&gt;tdomain&lt;/code&gt; is given, the default value, &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt;, is used.</source>
          <target state="translated">&lt;code&gt;tdomain&lt;/code&gt; が指定されていない場合、デフォルト値の &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; が使用されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="de8909d667626be185465024dfa8ebbd745359a8" translate="yes" xml:space="preserve">
          <source>Note that if not all the data was sent, the function will return with the remaining data &lt;strong&gt;and&lt;/strong&gt; the &lt;code&gt;SelectInfo&lt;/code&gt; (if the caller don't want to wait to be able to send the rest, it should immediately call the &lt;code&gt;&lt;a href=&quot;#cancel-2&quot;&gt;cancel/2&lt;/a&gt;&lt;/code&gt; function.)</source>
          <target state="translated">いないすべてのデータが送信された場合、関数は残りのデータを返すことを注意&lt;strong&gt;して&lt;/strong&gt; &lt;code&gt;SelectInfo&lt;/code&gt; （呼び出し側が残りを送信できるように待ちたくない場合は、それはすぐに呼び出す必要があります &lt;code&gt;&lt;a href=&quot;#cancel-2&quot;&gt;cancel/2&lt;/a&gt;&lt;/code&gt; 機能を。）</target>
        </trans-unit>
        <trans-unit id="c484d69e82a05974946be309952b5bc3d7f4c76d" translate="yes" xml:space="preserve">
          <source>Note that if the &lt;code&gt;gen_statem&lt;/code&gt; is started through &lt;code&gt;&lt;a href=&quot;proc_lib&quot;&gt;proc_lib&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#enter_loop-4&quot;&gt;enter_loop/4-6&lt;/a&gt;&lt;/code&gt;, this callback will never be called. Since this callback is not optional it can in that case be implemented as:</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;proc_lib&quot;&gt;proc_lib&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;#enter_loop-4&quot;&gt;enter_loop/4-6&lt;/a&gt;&lt;/code&gt; を介して開始された場合、このコールバックは呼び出されないことに注意してください。このコールバックはオプションではないため、その場合は次のように実装できます。</target>
        </trans-unit>
        <trans-unit id="9c87f385bbe639188084f38ba17c84501fe670ca" translate="yes" xml:space="preserve">
          <source>Note that if the Version argument is &lt;code&gt;dynamic&lt;/code&gt;, the decoder should try to figure out the actual version from the message itself and then use the proper decoder, e.g. version 1.</source>
          <target state="translated">Version引数が &lt;code&gt;dynamic&lt;/code&gt; の場合、デコーダーはメッセージ自体から実際のバージョンを把握し、バージョン1などの適切なデコーダーを使用する必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="12f48a08b82dbcdbabc6e426452d1ee74de3e1a7" translate="yes" xml:space="preserve">
          <source>Note that if the body is small all data may be delivered in only one chunk and then the callback will be called with {last, Data::binary(), undefined} without getting called with &lt;code&gt;{first, Data::binary()}&lt;/code&gt;.</source>
          <target state="translated">本文が小さい場合、すべてのデータは1つのチャンクでのみ配信され、コールバックは{last、Data :: binary（）、undefined}で呼び出され、 &lt;code&gt;{first, Data::binary()}&lt;/code&gt; 呼び出されることはありません。。</target>
        </trans-unit>
        <trans-unit id="edf8bcd8d88dd948c2709c3f285acd4c03e67af3" translate="yes" xml:space="preserve">
          <source>Note that if the fun returns &lt;code&gt;unknown&lt;/code&gt; for an extension marked as critical, validation will fail.</source>
          <target state="translated">重要とマークされた拡張に対してfunが &lt;code&gt;unknown&lt;/code&gt; を返す場合、検証は失敗することに注意してください。</target>
        </trans-unit>
        <trans-unit id="9d0a053447ab79088b7ef6197ebb840d173587a7" translate="yes" xml:space="preserve">
          <source>Note that if the option &lt;code&gt;warnings&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and the option &lt;code&gt;verbosity&lt;/code&gt; is &lt;code&gt;silence&lt;/code&gt;, warning messages will still be shown.</source>
          <target state="translated">オプションの &lt;code&gt;warnings&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; で、オプションの &lt;code&gt;verbosity&lt;/code&gt; が &lt;code&gt;silence&lt;/code&gt; の場合でも、警告メッセージが表示されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="5dec77651df10446f2452013b0e653832ee5a101" translate="yes" xml:space="preserve">
          <source>Note that if the reply is segmented (split into several smaller messages; segments), then some extra info, segment number and an indication if all segments of a reply has been received or not, is also included in the &lt;code&gt;UserReply&lt;/code&gt;.</source>
          <target state="translated">返信がセグメント化されている（複数の小さなメッセージに分割されている）場合、追加情報、セグメント番号、および返信のすべてのセグメントが受信されたかどうかの表示も &lt;code&gt;UserReply&lt;/code&gt; に含まれます。</target>
        </trans-unit>
        <trans-unit id="3e84fec2f22c7d49771617b7f4326149f8363362" translate="yes" xml:space="preserve">
          <source>Note that in Erlang, a receive-expression must have at least one clause if no timeout part is specified.</source>
          <target state="translated">Erlangでは、タイムアウトの部分が指定されていない場合、受信式は少なくとも1つの節を持たなければならないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="08a96fc716918fe5871d98094662c927e7804b46" translate="yes" xml:space="preserve">
          <source>Note that in case of an Erlang/OTP SSH server (daemon) as peer, that server must have been started with the option &lt;code&gt;&lt;a href=&quot;#type-tcpip_tunnel_in_daemon_option&quot;&gt;tcpip_tunnel_in&lt;/a&gt;&lt;/code&gt; to allow the connection.</source>
          <target state="translated">ピアとしてErlang / OTP SSHサーバー（デーモン）の場合、接続を許可するには、そのサーバーがオプション &lt;code&gt;&lt;a href=&quot;#type-tcpip_tunnel_in_daemon_option&quot;&gt;tcpip_tunnel_in&lt;/a&gt;&lt;/code&gt; で起動されている必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="629d6084a6f0543f14df18dbc3535aef38711dc0" translate="yes" xml:space="preserve">
          <source>Note that in case of an Erlang/OTP SSH server (daemon) as peer, that server must have been started with the option &lt;code&gt;&lt;a href=&quot;#type-tcpip_tunnel_out_daemon_option&quot;&gt;tcpip_tunnel_out&lt;/a&gt;&lt;/code&gt; to allow the connection.</source>
          <target state="translated">ピアとしてErlang / OTP SSHサーバー（デーモン）の場合、接続を許可するには、そのサーバーがオプション &lt;code&gt;&lt;a href=&quot;#type-tcpip_tunnel_out_daemon_option&quot;&gt;tcpip_tunnel_out&lt;/a&gt;&lt;/code&gt; で起動されている必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="8cef48befcd401dd112e3b47e9b84cfba29baac7" translate="yes" xml:space="preserve">
          <source>Note that in most implementations of TCP, doing a &lt;code&gt;close&lt;/code&gt; does not guarantee that any data sent is delivered to the recipient before the close is detected at the remote side. If you want to guarantee delivery of the data to the recipient there are two common ways to achieve this.</source>
          <target state="translated">TCPのほとんどの実装では、 &lt;code&gt;close&lt;/code&gt; しても、リモート側でクローズが検出される前に、送信されたデータが受信者に配信されるとは限りません。受信者へのデータの配信を保証したい場合、これを実現する一般的な方法が2つあります。</target>
        </trans-unit>
        <trans-unit id="b9a4adbac3d627161edb16842c38f7517677ffd5" translate="yes" xml:space="preserve">
          <source>Note that in order for reltool to sort application versions and thereby be able to select the latest, it is required that the version id for the application consits of integers and dots only, for example &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2.0&lt;/code&gt; or &lt;code&gt;3.17.1&lt;/code&gt;.</source>
          <target state="translated">注reltoolの最新のを選択することができ、それによってソートアプリケーションのバージョンへと順に、それが必要であることをその一例に過ぎないが整数とドットのアプリケーションconsits、のバージョンID &lt;code&gt;1&lt;/code&gt; 、 &lt;code&gt;2.0&lt;/code&gt; 又は &lt;code&gt;3.17.1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e044f396b1f21f65746f1535663887993d7e14da" translate="yes" xml:space="preserve">
          <source>Note that integers in the list always represent code points regardless of &lt;code&gt;InEncoding&lt;/code&gt; passed. If &lt;code&gt;InEncoding latin1&lt;/code&gt; is passed, only code points &amp;lt; 256 are allowed; otherwise, all valid unicode code points are allowed.</source>
          <target state="translated">リスト内の整数は、渡された &lt;code&gt;InEncoding&lt;/code&gt; に関係なく、常にコードポイントを表すことに注意してください。 &lt;code&gt;InEncoding latin1&lt;/code&gt; が渡される場合、256未満のコードポイントのみが許可されます。それ以外の場合は、すべての有効なUnicodeコードポイントが許可されます。</target>
        </trans-unit>
        <trans-unit id="6b71fac57eccdc841417bdc84d942c5ed4df483a" translate="yes" xml:space="preserve">
          <source>Note that it also blocks other operations than just &lt;code&gt;rpc:block_call()&lt;/code&gt; operations, so use it with care.</source>
          <target state="translated">また、 &lt;code&gt;rpc:block_call()&lt;/code&gt; 操作以外の操作もブロックするため、注意して使用してください。</target>
        </trans-unit>
        <trans-unit id="da41371a24cf2bfa4ed67187ea540808d0a4589a" translate="yes" xml:space="preserve">
          <source>Note that it is easiest to write this kind of recursive generator using a help function, like the &lt;code&gt;lazy_gen/1&lt;/code&gt; function above. It can also be written using a recursive fun, if you prefer to not clutter your function namespace and are comfortable with writing that kind of code.</source>
          <target state="translated">上記の &lt;code&gt;lazy_gen/1&lt;/code&gt; 関数のようなヘルプ関数を使用して、この種の再帰的ジェネレータを記述するのが最も簡単であることに注意してください。関数の名前空間を散らかしたくない場合や、その種のコードの記述に慣れている場合は、再帰的な楽しみを使用して記述することもできます。</target>
        </trans-unit>
        <trans-unit id="b32d52e1a01dca7a3f60f88baf54204f13cb5c4b" translate="yes" xml:space="preserve">
          <source>Note that it is not possible nor needed to cancel this time-out, as it is cancelled automatically by any other event.</source>
          <target state="translated">このタイムアウトは、他のイベントによって自動的にキャンセルされるため、キャンセルすることはできませんし、キャンセルする必要もありません。</target>
        </trans-unit>
        <trans-unit id="3d2bc208d4ef85523a8bb2be7f7fe6957054fa30" translate="yes" xml:space="preserve">
          <source>Note that it is possible for this function to filter out targets (but &lt;strong&gt;not&lt;/strong&gt; to add its own) by returning an updated &lt;code&gt;Targets&lt;/code&gt; list (&lt;code&gt;NewTargets&lt;/code&gt;).</source>
          <target state="translated">この関数は、更新された &lt;code&gt;Targets&lt;/code&gt; リスト（ &lt;code&gt;NewTargets&lt;/code&gt; ）を返すことで、ターゲットを除外することができます（ただし、ターゲットを追加することはでき&lt;strong&gt;ません&lt;/strong&gt;）。</target>
        </trans-unit>
        <trans-unit id="e68901639556f6e842921bc4c6aab5754c944701" translate="yes" xml:space="preserve">
          <source>Note that it is up to the user to ensure that correct code to execute via &lt;code&gt;erpc&lt;/code&gt; is available on the involved nodes.</source>
          <target state="translated">&lt;code&gt;erpc&lt;/code&gt; を介して実行する正しいコードが関連するノードで利用可能であることを確認するのはユーザーの責任であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="29e083fd2ab9cd6e5f1715c135b9ad0cd6133523" translate="yes" xml:space="preserve">
          <source>Note that it seldom needs to be started explicitly since it is automatically started by the functions that need a running server.</source>
          <target state="translated">実行中のサーバを必要とする機能によって自動的に起動されるので、明示的に起動する必要はほとんどないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="bf76532ed69f19d320e28943c7ea7794c8213294" translate="yes" xml:space="preserve">
          <source>Note that its implementation dependant (and also dependent on mib-storage is used) if a backup is possible.</source>
          <target state="translated">バックアップが可能かどうかは、その実装に依存することに注意してください (また、mib-storageが使用されているかどうかにも依存します)。</target>
        </trans-unit>
        <trans-unit id="1fddaac0c2eba362c90fcf63bcdd71ddcd1d0713" translate="yes" xml:space="preserve">
          <source>Note that just because we have a documented and described option, it does &lt;strong&gt;not&lt;/strong&gt; mean that the OS supports it. So its recommended that the user reads the platform specific documentation for the option used.</source>
          <target state="translated">文書化され説明されているオプションがあるからといって、OSがそれをサポートしているわけでは&lt;strong&gt;ない&lt;/strong&gt;ことに注意してください。したがって、使用するオプションのプラットフォーム固有のドキュメントを読むことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="fec78a15c5217c92c95a49b94462adac13df7646" translate="yes" xml:space="preserve">
          <source>Note that new types may be added in the future, so the caller must be prepared to handle unknown types.</source>
          <target state="translated">将来的に新しい型が追加される可能性があるので、呼び出し元は未知の型を扱う準備をしておく必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="1ef50791d64ed0c0b90d9621e25834b3006be609" translate="yes" xml:space="preserve">
          <source>Note that no checking is done whether &lt;code&gt;Name&lt;/code&gt; is a reserved attribute name such as &lt;code&gt;module&lt;/code&gt; or &lt;code&gt;export&lt;/code&gt;: it is assumed that the attribute is &quot;wild&quot;.</source>
          <target state="translated">&lt;code&gt;Name&lt;/code&gt; が &lt;code&gt;module&lt;/code&gt; や &lt;code&gt;export&lt;/code&gt; などの予約済みの属性名であるかどうかのチェックは行われないことに注意してください。属性は「ワイルド」であると想定されています。</target>
        </trans-unit>
        <trans-unit id="da792409efb1d957a763465a0f90eb01b22a65de" translate="yes" xml:space="preserve">
          <source>Note that no global trace patterns are affected by this function.</source>
          <target state="translated">グローバルトレースパターンはこの関数の影響を受けないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="c9dbd761e7b3ccf030e5d2634d121608a5fc566a" translate="yes" xml:space="preserve">
          <source>Note that not all individual &lt;code&gt;Option&lt;/code&gt;s are checked when the spawn request is sent. Some &lt;code&gt;Option&lt;/code&gt;s can only be checked on reception of the request. Therefore an invalid option does &lt;strong&gt;not&lt;/strong&gt; cause a &lt;code&gt;badarg&lt;/code&gt; exception, but will cause the spawn operation to fail with an error reason of &lt;code&gt;badopt&lt;/code&gt;.</source>
          <target state="translated">スポーンリクエストが送信されるときに、すべての個々の &lt;code&gt;Option&lt;/code&gt; がチェックされるわけではないことに注意してください。一部の &lt;code&gt;Option&lt;/code&gt; は、リクエストの受信時にのみチェックできます。したがって、無効なオプションがない&lt;strong&gt;ではない&lt;/strong&gt;原因 &lt;code&gt;badarg&lt;/code&gt; の例外を、しかし、卵操作はのエラー理由で失敗する原因になります &lt;code&gt;badopt&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dc1046cde1e5db61beca0efc3f9616a4641ffd20" translate="yes" xml:space="preserve">
          <source>Note that not every &lt;code&gt;gen_tcp:connect_option()&lt;/code&gt; is accepted. See &lt;code&gt;&lt;a href=&quot;ssh#set_sock_opts-2&quot;&gt;set_sock_opts/2&lt;/a&gt;&lt;/code&gt; for a list of prohibited options.</source>
          <target state="translated">すべての &lt;code&gt;gen_tcp:connect_option()&lt;/code&gt; が受け入れられるわけではないことに注意してください。禁止されているオプションのリストについては、 &lt;code&gt;&lt;a href=&quot;ssh#set_sock_opts-2&quot;&gt;set_sock_opts/2&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="da7f42298d81e647ec75e32ec8f0a6e4e85efbf7" translate="yes" xml:space="preserve">
          <source>Note that not every &lt;code&gt;gen_tcp:listen_option()&lt;/code&gt; is accepted. See &lt;code&gt;&lt;a href=&quot;ssh#set_sock_opts-2&quot;&gt;set_sock_opts/2&lt;/a&gt;&lt;/code&gt; for a list of prohibited options.</source>
          <target state="translated">すべての &lt;code&gt;gen_tcp:listen_option()&lt;/code&gt; が受け入れられるわけではないことに注意してください。禁止されているオプションのリストについては、 &lt;code&gt;&lt;a href=&quot;ssh#set_sock_opts-2&quot;&gt;set_sock_opts/2&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="beb7d234e889fecf34a0a8cc44508f7dd715d1f4" translate="yes" xml:space="preserve">
          <source>Note that only one transport per kind for each transport domain can be configured.</source>
          <target state="translated">各トランスポートドメインに対して、種類ごとに1つのトランスポートしか構成できないことに注意。</target>
        </trans-unit>
        <trans-unit id="2ef85014f2633aed4a8852aa3b53ebbaf3622c48" translate="yes" xml:space="preserve">
          <source>Note that only the exec channel is closed after the one-time execution. The connection is still up and can handle previously opened channels. It is also possible to open a new channel:</source>
          <target state="translated">一度だけ実行した後、execチャネルだけが閉じられていることに注意してください。接続はまだ立ち上がっており、以前に開かれたチャンネルを扱うことができます。また、新しいチャネルを開くことも可能です。</target>
        </trans-unit>
        <trans-unit id="1047c06dfd85c28e322de4ae968c83146c41303a" translate="yes" xml:space="preserve">
          <source>Note that processes that execute configuration functions or test cases are never included in &lt;code&gt;TestProcs&lt;/code&gt;. It is therefore safe to use post configuration hook functions (such as post_end_per_suite, post_end_per_group, post_end_per_testcase) to terminate all processes in &lt;code&gt;TestProcs&lt;/code&gt; that have the current group leader process as its group leader.</source>
          <target state="translated">構成関数またはテストケースを実行するプロセスが &lt;code&gt;TestProcs&lt;/code&gt; に含まれることはありません。したがって、構成後フック関数（post_end_per_suite、post_end_per_group、post_end_per_testcaseなど）を使用して、現在のグループリーダープロセスをグループリーダーとして持つ &lt;code&gt;TestProcs&lt;/code&gt; のすべてのプロセスを終了しても安全です。</target>
        </trans-unit>
        <trans-unit id="83100a56e14e247fd18ef628ef7f4b9f51213734" translate="yes" xml:space="preserve">
          <source>Note that raw filenames &lt;strong&gt;not&lt;/strong&gt; necessarily are encoded the same way as on the OS level.</source>
          <target state="translated">生のファイル名&lt;strong&gt;は&lt;/strong&gt;必ずしもOSレベルと同じ方法でエンコードされているわけでは&lt;strong&gt;ない&lt;/strong&gt;ことに注意してください。</target>
        </trans-unit>
        <trans-unit id="82914e4f408f26df4d5bb211a9e507c3fd9f2819" translate="yes" xml:space="preserve">
          <source>Note that some curves are disabled if FIPS is enabled.</source>
          <target state="translated">FIPSが有効な場合、一部のカーブは無効になっていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="dbb3e885aec0adb2e32b31326d16ceb9409b7c9f" translate="yes" xml:space="preserve">
          <source>Note that spaces are preserved and that no point (.) is needed at the end - that was required by the default evaluator.</source>
          <target state="translated">スペースが保存され、最後にポイント(.)が必要ないことに注意してください-これはデフォルトの評価器で必要とされていました。</target>
        </trans-unit>
        <trans-unit id="15df3770c93a08f3b7628f1b3671253fafbc1cf9" translate="yes" xml:space="preserve">
          <source>Note that special characters in the text (&amp;lt;, &amp;gt; and &amp;amp;) will be escaped by Common Test before the text is printed to the log file.</source>
          <target state="translated">テキスト内の特殊文字（&amp;lt;、&amp;gt;、＆）は、テキストがログファイルに出力される前に、Common Testによってエスケープされます。</target>
        </trans-unit>
        <trans-unit id="863f3323e07ccde5b57c1b225a8cb6abcf3f22bb" translate="yes" xml:space="preserve">
          <source>Note that the &quot;super&quot; in super alignment and the &quot;super&quot; in super carrier has nothing to do with each other. We could have choosen another naming to avoid confusion, such as &quot;meta&quot; carrier or &quot;giant&quot; aligment.</source>
          <target state="translated">スーパーアラインメントの「スーパー」とスーパーキャリアの「スーパー」は、お互いに何の関係もないことに注意してください。混乱を避けるために、&quot;メタ &quot;キャリアや &quot;ジャイアント &quot;アリグメントのような別のネーミングを選択することができました。</target>
        </trans-unit>
        <trans-unit id="b27bd01e0ed18a111b98018e635bbdb5be686872" translate="yes" xml:space="preserve">
          <source>Note that the (new) extended transport entries (including &lt;code&gt;Kind&lt;/code&gt; and &lt;code&gt;Opts&lt;/code&gt;) &lt;strong&gt;must&lt;/strong&gt; specify port-info as they ignore any value specified by &lt;code&gt;intAgentUDPPort&lt;/code&gt;.</source>
          <target state="translated">（を含む（新）拡張トランスポートエントリことを注意 &lt;code&gt;Kind&lt;/code&gt; と &lt;code&gt;Opts&lt;/code&gt; ）&lt;strong&gt;必要があり&lt;/strong&gt;、彼らがで指定された任意の値を無視としてポート情報を指定 &lt;code&gt;intAgentUDPPort&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="7563ce9bbb8cb2de2be12e2c300f540e095441b0" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;RecordName&lt;/code&gt; and &lt;code&gt;Fields&lt;/code&gt; arguments my not be used in all implementations (they are actually only needed for mnesia-based implementations).</source>
          <target state="translated">&lt;code&gt;RecordName&lt;/code&gt; 引数と &lt;code&gt;Fields&lt;/code&gt; 引数はすべての実装で使用できるわけではないことに注意してください（これらは実際にはmnesiaベースの実装でのみ必要です）。</target>
        </trans-unit>
        <trans-unit id="79647059410cdcc68796c813c0ea00f1df08febf" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;erl_parse&lt;/code&gt; representation is identical for &quot;&lt;code&gt;FunctionType&lt;/code&gt;&quot; and &quot;&lt;code&gt;fun(FunctionType)&lt;/code&gt;&quot;.</source>
          <target state="translated">&lt;code&gt;erl_parse&lt;/code&gt; 表現は、「 &lt;code&gt;FunctionType&lt;/code&gt; 」と「 &lt;code&gt;fun(FunctionType)&lt;/code&gt; 」で同じであることに注意してください。</target>
        </trans-unit>
        <trans-unit id="77e8b76dc02c9cee773231d4002d964ee921a983" translate="yes" xml:space="preserve">
          <source>Note that the &lt;strong&gt;sect&lt;/strong&gt; curves are GF2m (characteristic two) curves and are only supported if the underlying OpenSSL has support for them. See also &lt;code&gt;&lt;a href=&quot;#supports-0&quot;&gt;crypto:supports/0&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">注意&lt;strong&gt;宗派の&lt;/strong&gt;曲線はGF2m（特徴2）曲線であり、根本的なOpenSSLが彼らのためにサポートしている場合にのみサポートされています。 &lt;code&gt;&lt;a href=&quot;#supports-0&quot;&gt;crypto:supports/0&lt;/a&gt;&lt;/code&gt; も参照してください</target>
        </trans-unit>
        <trans-unit id="e846e6d7b0cd63a03e739f368b1e0f75bf3068da" translate="yes" xml:space="preserve">
          <source>Note that the AVP in question can be defined in an inherited dictionary in order to introduce additional values to an enumeration otherwise defined in another dictionary.</source>
          <target state="translated">問題のAVPは、別の辞書で定義された列挙に追加の値を導入するために、継承された辞書で定義することができることに注意してください。</target>
        </trans-unit>
        <trans-unit id="545f0e872a991ae7619c44fcd6c8013504712aeb" translate="yes" xml:space="preserve">
          <source>Note that the CCF of this AVP is not the same as in RFC 3588.</source>
          <target state="translated">この AVP の CCF は RFC 3588 と同じではないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="3839e34d035de6fcffb30bf27e41d5c5ddbeeb10" translate="yes" xml:space="preserve">
          <source>Note that the actual definition of (some of) these records depend on the megaco protocol version used. For instance, the &lt;code&gt;'TransactionReply'&lt;/code&gt; record has two more fields in version 3, so a simple erlang type definition cannot be made here.</source>
          <target state="translated">これらのレコード（の一部）の実際の定義は、使用されるmegacoプロトコルのバージョンに依存することに注意してください。たとえば、バージョン3では &lt;code&gt;'TransactionReply'&lt;/code&gt; レコードにさらに2つのフィールドがあるため、ここで単純なerlangタイプの定義を行うことはできません。</target>
        </trans-unit>
        <trans-unit id="bc8a5b787d8524598e83ff6424d17b88b62138a1" translate="yes" xml:space="preserve">
          <source>Note that the actual supported dss_digest_type depends on the underlying crypto library. In OpenSSL version &amp;gt;= 1.0.1 the listed digest are supported, while in 1.0.0 only sha, sha224 and sha256 are supported. In version 0.9.8 only sha is supported.</source>
          <target state="translated">実際にサポートされるdss_digest_typeは、基盤となる暗号ライブラリに依存することに注意してください。OpenSSLバージョン&amp;gt; = 1.0.1では、リストされているダイジェストがサポートされていますが、1.0.0では、sha、sha224およびsha256のみがサポートされています。バージョン0.9.8では、shaのみがサポートされています。</target>
        </trans-unit>
        <trans-unit id="3b70bc0ac9ae266a36a7ccaa90cb46529ab3a596" translate="yes" xml:space="preserve">
          <source>Note that the algorithms in the file &lt;code&gt;ex2.config&lt;/code&gt; is not yet applied. They will be when we start ssh:</source>
          <target state="translated">ファイル &lt;code&gt;ex2.config&lt;/code&gt; のアルゴリズムはまだ適用されていないことに注意してください。sshを開始すると次のようになります。</target>
        </trans-unit>
        <trans-unit id="3f7c24f4a4a2d3cbb7e5f46db8ca5bbd93271e2c" translate="yes" xml:space="preserve">
          <source>Note that the alternative, the old &lt;code&gt;Module:add_host_key/3&lt;/code&gt; is no longer supported by &lt;code&gt;ssh_file&lt;/code&gt;.</source>
          <target state="translated">別の方法である古い &lt;code&gt;Module:add_host_key/3&lt;/code&gt; は、 &lt;code&gt;ssh_file&lt;/code&gt; ではサポートされなくなったことに注意してください。</target>
        </trans-unit>
        <trans-unit id="9cdefbbcdb7a6e85db537e1b6266c9775e69d082" translate="yes" xml:space="preserve">
          <source>Note that the alternative, the old &lt;code&gt;Module:is_host_key/4&lt;/code&gt; is no longer supported by &lt;code&gt;ssh_file&lt;/code&gt;.</source>
          <target state="translated">別の方法として、古い &lt;code&gt;Module:is_host_key/4&lt;/code&gt; は &lt;code&gt;ssh_file&lt;/code&gt; でサポートされなくなったことに注意してください。</target>
        </trans-unit>
        <trans-unit id="4ca45c6542e0b81fb0f24e8247dda5f01d933e7b" translate="yes" xml:space="preserve">
          <source>Note that the appended algorithm is removed from its original place and then appended to the same list.</source>
          <target state="translated">追加されたアルゴリズムは、元の場所から削除され、同じリストに追加されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="3ccb116cfa36059b115c940833292db4f44f844b" translate="yes" xml:space="preserve">
          <source>Note that the buffer pointed to by the &lt;code&gt;outbuf&lt;/code&gt; argument must be large enough if a non &lt;code&gt;NULL&lt;/code&gt; value is passed as &lt;code&gt;outbuf&lt;/code&gt;. You typically want to call &lt;code&gt;ei_decode_iodata()&lt;/code&gt; twice. First with a non &lt;code&gt;NULL&lt;/code&gt;&lt;code&gt;size&lt;/code&gt; argument and a &lt;code&gt;NULL&lt;/code&gt;&lt;code&gt;outbuf&lt;/code&gt; argument in order to determine the size of the buffer needed, and then once again in order to do the actual decoding. Note that the integer pointed to by &lt;code&gt;index&lt;/code&gt; will be updated by the call determining the size as well, so you need to reset it before the second call doing the actual decoding.</source>
          <target state="translated">&lt;code&gt;NULL&lt;/code&gt; 以外の値が &lt;code&gt;outbuf&lt;/code&gt; として渡される場合、 &lt;code&gt;outbuf&lt;/code&gt; 引数が指すバッファーは十分に大きくなければならないことに注意してください。通常、 &lt;code&gt;ei_decode_iodata()&lt;/code&gt; を2回呼び出します。必要なバッファのサイズを決定するために、最初に非 &lt;code&gt;NULL&lt;/code&gt; &lt;code&gt;size&lt;/code&gt; 引数と &lt;code&gt;NULL&lt;/code&gt; &lt;code&gt;outbuf&lt;/code&gt; 引数を使用し、次に実際のデコードを実行するためにもう一度使用します。 &lt;code&gt;index&lt;/code&gt; が指す整数は、サイズを決定する呼び出しによっても更新されるため、2番目の呼び出しが実際のデコードを行う前に整数をリセットする必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="2f612c010562004f09536ba4c9211c91bf97b929" translate="yes" xml:space="preserve">
          <source>Note that the category argument is not required in order to only specify the importance of a printout. Example:</source>
          <target state="translated">印刷物の重要度のみを指定するためには、カテゴリ引数は必須ではないことに注意してください。例を示します。</target>
        </trans-unit>
        <trans-unit id="4b7df81861af684495c97c5fff7559eaf0915d2f" translate="yes" xml:space="preserve">
          <source>Note that the client is free to use any order and to exclude methods.</source>
          <target state="translated">クライアントが任意の注文を使用し、メソッドを除外することは自由であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="468edd7f0dc67514b910bd2116ac92cf52f20c09" translate="yes" xml:space="preserve">
          <source>Note that the command specified with the &lt;code&gt;-rsh&lt;/code&gt; flag is treated as a file name which may contain spaces. It is thus not possible to include any command line options. The remote node will be launched as &lt;code&gt;&quot;$RSH&quot; &quot;$REMOTE_HOSTNAME&quot; erl -detached -noinput ...&lt;/code&gt;, so the &lt;code&gt;erl&lt;/code&gt; command must be found in the path on the remote host.</source>
          <target state="translated">&lt;code&gt;-rsh&lt;/code&gt; フラグで指定されたコマンドは、スペースを含む可能性のあるファイル名として扱われることに注意してください。したがって、コマンドラインオプションを含めることはできません。リモートノードは &lt;code&gt;&quot;$RSH&quot; &quot;$REMOTE_HOSTNAME&quot; erl -detached -noinput ...&lt;/code&gt; として起動されるため、 &lt;code&gt;erl&lt;/code&gt; コマンドはリモートホストのパスにある必要があります。</target>
        </trans-unit>
        <trans-unit id="035d18f56820efe86cdac35e4891682c6e3af7b9" translate="yes" xml:space="preserve">
          <source>Note that the compiler may optimize away atoms. For example, the compiler will rewrite &lt;code&gt;atom_to_list(some_atom)&lt;/code&gt; to &lt;code&gt;&quot;some_atom&quot;&lt;/code&gt;. If that expression is the only mention of the atom &lt;code&gt;some_atom&lt;/code&gt; in the containing module, the atom will not be created when the module is loaded, and a subsequent call to &lt;code&gt;binary_to_existing_atom(&amp;lt;&amp;lt;&quot;some_atom&quot;&amp;gt;&amp;gt;, utf8)&lt;/code&gt; will fail.</source>
          <target state="translated">コンパイラはアトムを最適化する場合があることに注意してください。たとえば、コンパイラは &lt;code&gt;atom_to_list(some_atom)&lt;/code&gt; を &lt;code&gt;&quot;some_atom&quot;&lt;/code&gt; に書き換えます。その式が包含モジュール内のアトム &lt;code&gt;some_atom&lt;/code&gt; の唯一の言及である場合、モジュールがロードされたときにアトムは作成されず、その後の &lt;code&gt;binary_to_existing_atom(&amp;lt;&amp;lt;&quot;some_atom&quot;&amp;gt;&amp;gt;, utf8)&lt;/code&gt; 呼び出しは失敗します。</target>
        </trans-unit>
        <trans-unit id="f826da285ddceeccbdbefeb9bfa7b16ed554783f" translate="yes" xml:space="preserve">
          <source>Note that the compiler may optimize away atoms. For example, the compiler will rewrite &lt;code&gt;atom_to_list(some_atom)&lt;/code&gt; to &lt;code&gt;&quot;some_atom&quot;&lt;/code&gt;. If that expression is the only mention of the atom &lt;code&gt;some_atom&lt;/code&gt; in the containing module, the atom will not be created when the module is loaded, and a subsequent call to &lt;code&gt;list_to_existing_atom(&quot;some_atom&quot;)&lt;/code&gt; will fail.</source>
          <target state="translated">コンパイラはアトムを最適化する場合があることに注意してください。たとえば、コンパイラは &lt;code&gt;atom_to_list(some_atom)&lt;/code&gt; を &lt;code&gt;&quot;some_atom&quot;&lt;/code&gt; に書き換えます。その式が、含まれているモジュール内のアトム &lt;code&gt;some_atom&lt;/code&gt; に関する唯一の言及である場合、モジュールがロードされるときにアトムは作成されず、その後の &lt;code&gt;list_to_existing_atom(&quot;some_atom&quot;)&lt;/code&gt; の呼び出しは失敗します。</target>
        </trans-unit>
        <trans-unit id="b82f239fea0a2dc9f48ac7fd1ebc1ab0b5051a56" translate="yes" xml:space="preserve">
          <source>Note that the data extracted from the imported (loaded) mibs are stored partly by the mib-server and partly by the symbolic-store server. See the default mib-server data module, &lt;code&gt;snmpa_mib_data_tttn&lt;/code&gt; for details.</source>
          <target state="translated">インポートされた（ロードされた）mibから抽出されたデータは、一部はmib-serverによって、一部はシンボリックストアサーバーによって格納されることに注意してください。詳細については、デフォルトのmib-serverデータモジュール &lt;code&gt;snmpa_mib_data_tttn&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="5bf74d56bb97406e9b99c3e9e52d5dbf134b453d" translate="yes" xml:space="preserve">
          <source>Note that the events &lt;code&gt;$s | $S&lt;/code&gt;, &lt;code&gt;l | $L&lt;/code&gt; and &lt;code&gt;$z | $Z&lt;/code&gt; has nothing to do with the timers using the same characters.</source>
          <target state="translated">イベント &lt;code&gt;$s | $S&lt;/code&gt; 、 &lt;code&gt;l | $L&lt;/code&gt; および &lt;code&gt;$z | $Z&lt;/code&gt; は、同じ文字を使用するタイマーとは関係ありません。</target>
        </trans-unit>
        <trans-unit id="42629d78e6fdce7f2ed90c950f63dbfb4e3b847a" translate="yes" xml:space="preserve">
          <source>Note that the existing &lt;code&gt;.beam&lt;/code&gt; file must contain &lt;strong&gt;abstract code&lt;/strong&gt;, i.e. it must have been compiled with the &lt;code&gt;debug_info&lt;/code&gt; option. If not, the error reason &lt;code&gt;{no_abstract_code,BeamFile}&lt;/code&gt; is returned. If the abstract code is encrypted, and no key is available for decrypting it, the error reason &lt;code&gt;{encrypted_abstract_code,BeamFile}&lt;/code&gt; is returned.</source>
          <target state="translated">既存の &lt;code&gt;.beam&lt;/code&gt; ファイルには&lt;strong&gt;抽象コード&lt;/strong&gt;が含まれている必要があることに注意してください。つまり、 &lt;code&gt;debug_info&lt;/code&gt; オプションでコンパイルされている必要があります。そうでない場合、エラー理由 &lt;code&gt;{no_abstract_code,BeamFile}&lt;/code&gt; が返されます。抽象コードが暗号化されていて、それを復号化するために使用できるキーがない場合、エラー理由 &lt;code&gt;{encrypted_abstract_code,BeamFile}&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="efa3ec631430748847eae6fa5201d4a2accae7a7" translate="yes" xml:space="preserve">
          <source>Note that the first two instruction have three fragments, while the other two only have two fragments. Here are the fragments:</source>
          <target state="translated">最初の2つの命令は3つのフラグメントを持っていますが、他の2つは2つのフラグメントしか持っていないことに注意してください。ここにフラグメントがあります。</target>
        </trans-unit>
        <trans-unit id="9a18b13a51422254edcdb84073c354c33a88853b" translate="yes" xml:space="preserve">
          <source>Note that the following will always be loaded:</source>
          <target state="translated">以下のものが常に読み込まれることに注意してください。</target>
        </trans-unit>
        <trans-unit id="d1a2e58d441f9e2f474d803ab6a32dc6712ae978" translate="yes" xml:space="preserve">
          <source>Note that the function does not check if this entry already exists.</source>
          <target state="translated">この関数は、このエントリが既に存在するかどうかをチェックしないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="279bdf4d0a207f6c87ecb0b4e0489436649191bf" translate="yes" xml:space="preserve">
          <source>Note that the generated certificates and keys does not provide a formally correct PKIX-trust-chain and they can not be used to achieve real security. This function is provided for testing purposes only.</source>
          <target state="translated">生成された証明書と鍵は、正式に正しい PKIX-trust-chain を提供するものではなく、実際のセキュリティを実現するために使用することはできないことに注意してください。この機能はテスト目的でのみ提供されます。</target>
        </trans-unit>
        <trans-unit id="078ffae6e673ee69ef0d8a166daaaedfa933f1dd" translate="yes" xml:space="preserve">
          <source>Note that the generated certificates and keys does not provide a formally correct PKIX-trust-chain and they cannot be used to achieve real security. This function is provided for testing purposes only.</source>
          <target state="translated">生成された証明書と鍵は、正式に正しい PKIX-trust-chain を提供するものではなく、実際のセキュリティを実現するために使用することはできないことに注意してください。この機能はテスト目的でのみ提供されます。</target>
        </trans-unit>
        <trans-unit id="6d6ba71f76cfedfe0e85aa82b7676692388cd2df" translate="yes" xml:space="preserve">
          <source>Note that the internal data that the &lt;code&gt;StateEnc&lt;/code&gt; and &lt;code&gt;StateDec&lt;/code&gt; references are destructivly updated by the calls to &lt;code&gt;&lt;a href=&quot;crypto#crypto_update-2&quot;&gt;crypto_update/2&lt;/a&gt;&lt;/code&gt;. This is to gain time in the calls of the nifs interfacing the cryptolib. In a loop where the state is saved in the loop's state, it also saves one update of the loop state per crypto operation.</source>
          <target state="translated">&lt;code&gt;StateEnc&lt;/code&gt; と &lt;code&gt;StateDec&lt;/code&gt; が参照する内部データは、 &lt;code&gt;&lt;a href=&quot;crypto#crypto_update-2&quot;&gt;crypto_update/2&lt;/a&gt;&lt;/code&gt; の呼び出しによって破壊的に更新されることに注意してください。これは、cryptolibとインターフェイスするnifsの呼び出しで時間を稼ぐためです。状態がループの状態で保存されるループでは、暗号化操作ごとにループ状態の更新も1つ保存されます。</target>
        </trans-unit>
        <trans-unit id="02818bfeb97510589873cb15d812dd13537919d3" translate="yes" xml:space="preserve">
          <source>Note that the internal database is (re-)initiated during the compilation, meaning any previously collected coverage data for the module will be lost.</source>
          <target state="translated">内部データベースはコンパイル中に(再)開始されるので、以前に収集したモジュールのカバレッジデータは失われることに注意してください。</target>
        </trans-unit>
        <trans-unit id="cd70be69f8094d7d21e00a3313e50198d0e46168" translate="yes" xml:space="preserve">
          <source>Note that the network interface filter is something which is used by the network interface implementation provided by the application (&lt;code&gt;snmpa_net_if&lt;/code&gt;). The default filter accepts all messages.</source>
          <target state="translated">ネットワーク・インターフェース・フィルターは、アプリケーション（ &lt;code&gt;snmpa_net_if&lt;/code&gt; ）によって提供されるネットワーク・インターフェース実装によって使用されるものであることに注意してください。デフォルトのフィルターはすべてのメッセージを受け入れます。</target>
        </trans-unit>
        <trans-unit id="ec89ab3b5094ea790ba1c908f83fb43e535fef72" translate="yes" xml:space="preserve">
          <source>Note that the network interface filter is something which is used by the network interface implementation provided by the application (&lt;code&gt;snmpm_net_if&lt;/code&gt; and &lt;code&gt;snmpm_net_if_mt&lt;/code&gt;). The default filter accepts all messages.</source>
          <target state="translated">ネットワーク・インターフェース・フィルターは、アプリケーション（ &lt;code&gt;snmpm_net_if&lt;/code&gt; および &lt;code&gt;snmpm_net_if_mt&lt;/code&gt; ）によって提供されるネットワーク・インターフェース実装によって使用されるものであることに注意してください。デフォルトのフィルターはすべてのメッセージを受け入れます。</target>
        </trans-unit>
        <trans-unit id="34cd017ef347f58960dd48f7604233f91388b9db" translate="yes" xml:space="preserve">
          <source>Note that the only way to actually start the agent in this way is to add the agent related config after starting the application (e.g it cannot be part of the normal application config; sys.config). This is done by calling: &lt;code&gt;application:set_env(snmp, agent, Conf)&lt;/code&gt;.</source>
          <target state="translated">この方法でエージェントを実際に開始する唯一の方法は、アプリケーションの開始後にエージェント関連の構成を追加することです（たとえば、通常のアプリケーション構成の一部にすることはできません。sys.config）。これは、 &lt;code&gt;application:set_env(snmp, agent, Conf)&lt;/code&gt; 呼び出すことによって行われます。</target>
        </trans-unit>
        <trans-unit id="81acf13e164a6ca93c0ecb3350e2a756f1a26bc4" translate="yes" xml:space="preserve">
          <source>Note that the only way to actually start the manager in this way is to add the manager related config after starting the application (e.g it cannot be part of the normal application config; sys.config). This is done by calling: &lt;code&gt;application:set_env(snmp, manager, Conf)&lt;/code&gt;.</source>
          <target state="translated">この方法でマネージャーを実際に起動する唯一の方法は、アプリケーションの起動後にマネージャー関連の構成を追加することです（たとえば、通常のアプリケーション構成の一部にすることはできません。sys.config）。これは、 &lt;code&gt;application:set_env(snmp, manager, Conf)&lt;/code&gt; 呼び出すことによって行われます。</target>
        </trans-unit>
        <trans-unit id="fe1baccf1828d7692350ac5f909a060eecbece59" translate="yes" xml:space="preserve">
          <source>Note that the order of the tuples in the resulting list is undefined and may change at any time.</source>
          <target state="translated">結果として得られるリストのタプルの順序は未定義であり、いつでも変更される可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="07cb3c0cb2baba7b63c67e88c6cd13cca1a7e679" translate="yes" xml:space="preserve">
          <source>Note that the order that things are printed have changed, and also I added a reverse-dns lookup of the IP address. This will not print as nicely when using a single line formatter, however you can also use a report_cb fun with 2 arguments where the second argument is the formatting options.</source>
          <target state="translated">印刷される順番が変わったことに注意してください。また、IPアドレスのDNS逆引きを追加しました。これは一行フォーマッタを使っている時にはきれいに印刷されませんが、2つの引数を持つreport_cb funを使って、2番目の引数にフォーマットオプションを指定することもできます。</target>
        </trans-unit>
        <trans-unit id="29a75f4183db30bfbd690aebb40a7591e31cfea3" translate="yes" xml:space="preserve">
          <source>Note that the ordering of the tuples in the lists didn't matter.</source>
          <target state="translated">リスト内のタプルの順序は問題ではないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="f94de51b2bccdc5fd6127e2ecc608b422d804fb9" translate="yes" xml:space="preserve">
          <source>Note that the process that calls this function &lt;strong&gt;must&lt;/strong&gt; be permanent. If it dies, the port(s) will exit and the driver unload.</source>
          <target state="translated">この関数を呼び出すプロセスは永続的で&lt;strong&gt;なければならない&lt;/strong&gt;ことに注意してください。終了すると、ポートが終了し、ドライバがアンロードされます。</target>
        </trans-unit>
        <trans-unit id="112c3dfc73e40a04304d2c8d43acbdb9eb33ab97" translate="yes" xml:space="preserve">
          <source>Note that the request specific parameters (such as &lt;code&gt;&lt;a href=&quot;#current_request_id&quot;&gt;current_request_id&lt;/a&gt;&lt;/code&gt;) are not accessible for the instrumentation functions if this function is used.</source>
          <target state="translated">この関数を使用する場合、インストルメンテーション関数はリクエスト固有のパラメーター（ &lt;code&gt;&lt;a href=&quot;#current_request_id&quot;&gt;current_request_id&lt;/a&gt;&lt;/code&gt; など）にアクセスできないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="290365691c0a5e60df1a89c122ce6576ebc4f890" translate="yes" xml:space="preserve">
          <source>Note that the request specific parameters (such as &lt;code&gt;snmpa:current_request_id/0&lt;/code&gt; are not accessible for the instrumentation functions if this function is used.</source>
          <target state="translated">この関数を使用する場合、インストルメンテーション関数はリクエスト固有のパラメーター（ &lt;code&gt;snmpa:current_request_id/0&lt;/code&gt; など）にアクセスできないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="becd11dbe64d3cd785c4bb1c3c28a2d4f227a406" translate="yes" xml:space="preserve">
          <source>Note that the segments are delivered to the user differently depending on which function is used to issue the original request. When issuing the request using the &lt;code&gt;&lt;a href=&quot;megaco#cast&quot;&gt;megaco:cast&lt;/a&gt;&lt;/code&gt; function, the segments are delivered to the user via the &lt;code&gt;&lt;a href=&quot;megaco_user#trans_reply&quot;&gt;handle_trans_reply&lt;/a&gt;&lt;/code&gt; callback function one at a time, as they arrive. But this obviously doe not work for the &lt;code&gt;&lt;a href=&quot;megaco#call&quot;&gt;megaco:call&lt;/a&gt;&lt;/code&gt; function. In this case, the segments are accumulated and then delivered all at once as the function returns.</source>
          <target state="translated">セグメントは、元の要求を発行するために使用される機能に応じて、異なる方法でユーザーに配信されます。使用して要求を発行するとき &lt;code&gt;&lt;a href=&quot;megaco#cast&quot;&gt;megaco:cast&lt;/a&gt;&lt;/code&gt; 関数を、セグメントは、を介してユーザに配信される &lt;code&gt;&lt;a href=&quot;megaco_user#trans_reply&quot;&gt;handle_trans_reply&lt;/a&gt;&lt;/code&gt; それらが到着すると、一度にコールバック関数1。しかし、これは明らかに &lt;code&gt;&lt;a href=&quot;megaco#call&quot;&gt;megaco:call&lt;/a&gt;&lt;/code&gt; 関数では機能しません。この場合、セグメントは累積され、関数が戻るときに一度に配信されます。</target>
        </trans-unit>
        <trans-unit id="e78277755ce3bad3e06f00c82c4d07b3b9286ed6" translate="yes" xml:space="preserve">
          <source>Note that the ssl application is required for TLS and must be started before configuring TLS capability on diameter transports.</source>
          <target state="translated">ssl アプリケーションは TLS に必要であり、直径トランスポートで TLS 機能を構成する前に起動する必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="2dee8e68f59d0a0eec57cc8147e1a5be661efd08" translate="yes" xml:space="preserve">
          <source>Note that the unmentioned lists (&lt;code&gt;public_key&lt;/code&gt;, &lt;code&gt;cipher&lt;/code&gt;, &lt;code&gt;mac&lt;/code&gt; and &lt;code&gt;compression&lt;/code&gt;) are un-changed.</source>
          <target state="translated">言及されていないリスト（ &lt;code&gt;public_key&lt;/code&gt; 、 &lt;code&gt;cipher&lt;/code&gt; 、 &lt;code&gt;mac&lt;/code&gt; および &lt;code&gt;compression&lt;/code&gt; ）は変更されていないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="d8989301ef700984d41bf0a2801b22ca08a2ce1f" translate="yes" xml:space="preserve">
          <source>Note that the use of the LocalEngineID argument is only intended for special cases, if the agent is to &quot;emulate&quot; multiple EngineIDs! By default, the agent uses the value of &lt;code&gt;SnmpEngineID&lt;/code&gt; (see SNMP-FRAMEWORK-MIB).</source>
          <target state="translated">LocalEngineID引数の使用は、エージェントが複数のEngineIDを「エミュレート」する場合の特別な場合のみを対象としています。デフォルトでは、エージェントは &lt;code&gt;SnmpEngineID&lt;/code&gt; の値を使用します（SNMP-FRAMEWORK-MIBを参照）。</target>
        </trans-unit>
        <trans-unit id="f2ec007dbfec9a50f3790ddfb78b2d7470067938" translate="yes" xml:space="preserve">
          <source>Note that the very first thing done is to fetch the address to the next instruction. The reason is that it usually improves performance.</source>
          <target state="translated">非常に最初に行われることは、次の命令にアドレスをフェッチすることであることに注意してください。これは、通常、パフォーマンスを向上させるためです。</target>
        </trans-unit>
        <trans-unit id="d56e76ea1af9a17fd56fb02b811e895206d51eb5" translate="yes" xml:space="preserve">
          <source>Note that there is a special case when the value of &lt;code&gt;ReqId&lt;/code&gt; has the value of the atom &lt;code&gt;netif&lt;/code&gt;. This means that the NetIF process has suffered a &quot;fatal&quot; error and been restarted. With possible loss of traffic!</source>
          <target state="translated">&lt;code&gt;ReqId&lt;/code&gt; の値がアトム &lt;code&gt;netif&lt;/code&gt; の値を持つ特別な場合があることに注意してください。これは、NetIFプロセスで「致命的な」エラーが発生し、再起動されたことを意味します。トラフィックが失われる可能性があります！</target>
        </trans-unit>
        <trans-unit id="b41a1b6fd82bf7a6c9a348c40309d8522ab51f73" translate="yes" xml:space="preserve">
          <source>Note that there may be multiple entries with the same &lt;code&gt;ref&lt;/code&gt;, in contrast to &lt;code&gt;transport&lt;/code&gt; info.</source>
          <target state="translated">&lt;code&gt;transport&lt;/code&gt; 情報とは対照的に、同じ &lt;code&gt;ref&lt;/code&gt; を持つ複数のエントリが存在する可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="8f8021919fad99cd5846d281ed37e3c831b466fa" translate="yes" xml:space="preserve">
          <source>Note that there need to be exactly one distribution controller per connection. A process or port can only be distribution controller for one connection. The registration as distribution controller cannot be undone. It will stick until the distribution controller terminates. The distribution controller should not ignore exit signals. It is allowed to trap exits, but it should then voluntarily terminate when an exit signal is received.</source>
          <target state="translated">ディストリビューションコントローラは、1つの接続につき正確に1つである必要があることに注意してください。プロセスやポートは、1つの接続に対してのみディストリビューションコントローラになることができます。ディストリビューションコントローラとしての登録は、元に戻すことができません。ディストリビューションコントローラが終了するまで登録は維持されます。ディストリビューションコントローラは、出口信号を無視してはいけません。出口をトラップすることは許されていますが、その後、出口信号を受信したときに自発的に終了すべきです。</target>
        </trans-unit>
        <trans-unit id="35ca0442324d4811fd6417d30d9643d51d667192" translate="yes" xml:space="preserve">
          <source>Note that these functions is intended to be called by the instrumentation functions and &lt;strong&gt;only&lt;/strong&gt; if they are executed in the context of the agent process (e.g. it does not work if called from a spawned process).</source>
          <target state="translated">これらの関数は、インストルメンテーション関数によって呼び出されることを意図しており、エージェントプロセスのコンテキストで実行される場合に&lt;strong&gt;のみ&lt;/strong&gt;注意してください（たとえば、生成されたプロセスから呼び出された場合は機能しません）。</target>
        </trans-unit>
        <trans-unit id="05534c73155b84674fad449b2de6066e6ecf290c" translate="yes" xml:space="preserve">
          <source>Note that this can cause the message queue to overflow causing for example the virtual machine to run out of memory and crash.</source>
          <target state="translated">これにより、メッセージキューがオーバーフローして、例えば仮想マシンがメモリを使い果たしてクラッシュしてしまう可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="2c6d3e9f0a111d997b09cc65e98dfb115cd9cb64" translate="yes" xml:space="preserve">
          <source>Note that this check use application versions that are loaded, or will be loaded when used. You might have application versions that satisfies all dependencies installed in the system, but if those are not loaded this check will fail. The system will of course also fail when used like this. This may happen when you have multiple &lt;code&gt;branched versions&lt;/code&gt; of the same application installed in the system, but you do not use a &lt;code&gt;boot script&lt;/code&gt; identifing the correct application version.</source>
          <target state="translated">このチェックは、ロードされている、または使用時にロードされるアプリケーションのバージョンを使用することに注意してください。システムにインストールされているすべての依存関係を満たすアプリケーションバージョンがある可能性がありますが、それらが読み込まれていない場合、このチェックは失敗します。もちろん、このように使用するとシステムも失敗します。これは、同じアプリケーションの複数の &lt;code&gt;branched versions&lt;/code&gt; がシステムにインストールされているが、正しいアプリケーションバージョンを識別する &lt;code&gt;boot script&lt;/code&gt; 使用していない場合に発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="99d2fbc3cc50eaf8d82652d3e7dfaf6a59e6d53e" translate="yes" xml:space="preserve">
          <source>Note that this does not effect the messages that are sent autonomously by the stack. They use the protocol_version of the connection info.</source>
          <target state="translated">これはスタックから自律的に送信されるメッセージには影響しないことに注意してください。これらのメッセージは接続情報の protocol_version を使用します。</target>
        </trans-unit>
        <trans-unit id="caecb85cc20edb5c5424262ff84251833ebf6fc6" translate="yes" xml:space="preserve">
          <source>Note that this function is executed in the context of the master-agent process.</source>
          <target state="translated">この関数はマスターエージェントプロセスのコンテキストで実行されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="8fa22c35292c8c077560ab97a691881383aaa404" translate="yes" xml:space="preserve">
          <source>Note that this function will only be called if the user has set the &lt;code&gt;&lt;a href=&quot;megaco#ui_resend_indication&quot;&gt;resend_indication&lt;/a&gt;&lt;/code&gt; config option to &lt;code&gt;true&lt;/code&gt;&lt;strong&gt;and&lt;/strong&gt; it is in fact a message resend. If not &lt;strong&gt;both&lt;/strong&gt; of these condition's are meet, &lt;code&gt;send_message&lt;/code&gt; will be called.</source>
          <target state="translated">この関数は、ユーザーが &lt;code&gt;&lt;a href=&quot;megaco#ui_resend_indication&quot;&gt;resend_indication&lt;/a&gt;&lt;/code&gt; 構成オプションを &lt;code&gt;true&lt;/code&gt; に設定&lt;strong&gt;し&lt;/strong&gt;ていて、実際にメッセージが再送信された場合にのみ呼び出されることに注意してください。これらの条件の&lt;strong&gt;両方&lt;/strong&gt;が満たされない場合、 &lt;code&gt;send_message&lt;/code&gt; が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="732f01521ba5984e435cb22a9ac9e6a45f29f1a3" translate="yes" xml:space="preserve">
          <source>Note that this has no effect on the actual sending of pending transactions. This is either implicit (e.g. when receiving a re-sent transaction request for a request which is being processed) or controlled by the pending_timer, see above.</source>
          <target state="translated">これは実際の保留中のトランザクションの送信には影響しないことに注意。これは暗黙のうちに(例えば、処理中のリクエストに対する再送されたトランザクションリクエストを受信したときなど)、あるいは上記を参照してpending_timerによって制御される。</target>
        </trans-unit>
        <trans-unit id="5991c7ab4d7c54b2c691ce4af01a35ebe0bdc5ec" translate="yes" xml:space="preserve">
          <source>Note that this has no effect on the application configuration as defined by configuration files, so a node restart will revert the config to whatever is in those files.</source>
          <target state="translated">これは設定ファイルで定義されているアプリケーションの設定には影響しないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="50e67d142a316144e7ab07bc77f835927707bee6" translate="yes" xml:space="preserve">
          <source>Note that this identifier occasionally has been called &quot;name&quot;. As far as possible, the terms &quot;identifier&quot; or &quot;id&quot; are now used but in order to keep backwards compatibility, some occurences of &quot;name&quot; can still be found, for example in error messages.</source>
          <target state="translated">この識別子が「名前」と呼ばれることがあることに注意してください。可能な限り、&quot;identifier &quot;または &quot;id &quot;という用語が使われるようになりましたが、下位互換性を保つために、エラーメッセージなどで &quot;name &quot;の出現が見られることがあります。</target>
        </trans-unit>
        <trans-unit id="4ccf4b0fd3e0f0b163b5d9f781f3e69fb98fcf9b" translate="yes" xml:space="preserve">
          <source>Note that this is also the maximum amount of data that can be received from a single recv call. If you are using higher than normal MTU consider setting buffer higher.</source>
          <target state="translated">これは、1 回の recv コールから受信できる最大データ量でもあることに注意してください。通常よりも高いMTUを使用している場合は、バッファを高く設定することを検討してください。</target>
        </trans-unit>
        <trans-unit id="8d6bbf6c0b04bfae62fc7c2e9271769120f7387b" translate="yes" xml:space="preserve">
          <source>Note that this is just a utility function, which does all the work of splitting the given string into words separated by whitespace and setting up a &lt;code&gt;&lt;a href=&quot;#par-2&quot;&gt;par&lt;/a&gt;&lt;/code&gt; with the proper indentation, containing a list of &lt;code&gt;&lt;a href=&quot;#text-1&quot;&gt;text&lt;/a&gt;&lt;/code&gt; elements.</source>
          <target state="translated">これは単なるユーティリティ関数であり、指定された文字列を空白で区切られた単語に分割し、 &lt;code&gt;&lt;a href=&quot;#text-1&quot;&gt;text&lt;/a&gt;&lt;/code&gt; 要素のリストを含む適切なインデントで &lt;code&gt;&lt;a href=&quot;#par-2&quot;&gt;par&lt;/a&gt;&lt;/code&gt; を設定するすべての作業を行うことに注意してください。</target>
        </trans-unit>
        <trans-unit id="3e4569ecffb57e143102668b7a6dd11b0264d4d3" translate="yes" xml:space="preserve">
          <source>Note that this list might be reduced if the underlying libcrypto does not support all of them.</source>
          <target state="translated">基礎となる libcrypto がすべてをサポートしていない場合、このリストは縮小される可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="392cc3c5602edaac365f69343bd3fabeabbfabb8" translate="yes" xml:space="preserve">
          <source>Note that this might be an incomplete list of files that need to be updated.</source>
          <target state="translated">これは更新が必要なファイルの不完全なリストである可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="7ccf435027f13cc4c4ea5f6a451c968311242f89" translate="yes" xml:space="preserve">
          <source>Note that this only works as specified if the &lt;code&gt;sent_pending_limit&lt;/code&gt; config option has been set to an integer value.</source>
          <target state="translated">これは、 &lt;code&gt;sent_pending_limit&lt;/code&gt; 構成オプションが整数値に設定されている場合にのみ、指定どおりに機能することに注意してください。</target>
        </trans-unit>
        <trans-unit id="14cde1c7fe3b7ab665fc387b99054848ce3fead5" translate="yes" xml:space="preserve">
          <source>Note that this whole module is experimental, and the representations used as well as the functionality is likely to change in the future.</source>
          <target state="translated">このモジュール全体が実験的なものであり、機能だけでなく使用される表現も今後変更される可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="6d0f64dc22706965239d477a1963f767ce3f8f64" translate="yes" xml:space="preserve">
          <source>Note that this will always be the default user that is called.</source>
          <target state="translated">これは常に呼び出されるデフォルトのユーザーになることに注意してください。</target>
        </trans-unit>
        <trans-unit id="2e15a72745c4b2259c54938521a47a61a3e00dfd" translate="yes" xml:space="preserve">
          <source>Note that to enable FIPS mode succesfully, OTP must be built with the configure option &lt;code&gt;--enable-fips&lt;/code&gt;, and the underlying libcrypto must also support FIPS.</source>
          <target state="translated">FIPSモードを正常に有効にするには、構成オプション &lt;code&gt;--enable-fips&lt;/code&gt; を使用してOTPを構築する必要があり、基盤となるlibcryptoもFIPSをサポートする必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="8ec3dbe2e4a9ded21164737c3e53b41c247a0435" translate="yes" xml:space="preserve">
          <source>Note that transaction id's are (currently) maintained on a per user basis so there is no way to be sure that the value returned will actually be used for a transaction sent on this connection (in case a user has several connections, which is not at all unlikely).</source>
          <target state="translated">トランザクションIDは(現在)ユーザごとに管理されているので、返された値がこの接続で送信されたトランザクションに実際に使用されるかどうかを確認する方法がないことに注意してください(ユーザが複数の接続を持っている場合、これは全く可能性がないわけではありません)。</target>
        </trans-unit>
        <trans-unit id="bfaf8929b2a813d73b67b54b1a840c42370aef06" translate="yes" xml:space="preserve">
          <source>Note that up until here it is not allowed to fragments the message. The entire atom cache and control message has to be part of the starting fragment. After the control message the payload of the message is sent using 128 bytes:</source>
          <target state="translated">ここまではメッセージを断片化することは許されていないことに注意してください。アトムキャッシュと制御メッセージ全体がフラグメントの一部になっていなければなりません。制御メッセージの後、メッセージのペイロードは128バイトで送信されます。</target>
        </trans-unit>
        <trans-unit id="74c2bdc163cd56fda0bc897570388a7d7819f96a" translate="yes" xml:space="preserve">
          <source>Note that user defined custom &lt;code&gt;verify_fun&lt;/code&gt; may alter original path validation error (e.g &lt;code&gt;selfsigned_peer&lt;/code&gt;). Use with caution.</source>
          <target state="translated">ユーザー定義のカスタム &lt;code&gt;verify_fun&lt;/code&gt; は、元のパス検証エラーを変更する可能性があることに注意してください（例： &lt;code&gt;selfsigned_peer&lt;/code&gt; ）。注意して使用してください。</target>
        </trans-unit>
        <trans-unit id="6cfc282f9f5a7f60dc04c61e35f9a1919be96f74" translate="yes" xml:space="preserve">
          <source>Note that using this action from &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#enter_loop-5&quot;&gt;enter_loop/5,6&lt;/a&gt;&lt;/code&gt; would be weird on the border of witchcraft since there has been no earlier call to a &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; in this server.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;#enter_loop-5&quot;&gt;enter_loop/5,6&lt;/a&gt;&lt;/code&gt; からこのアクションを使用すると、このサーバーで &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; が以前に呼び出されていないため、魔術の境界で奇妙になることに注意してください。</target>
        </trans-unit>
        <trans-unit id="8d60aba8258543e37473d13c94a9f81daa1cab90" translate="yes" xml:space="preserve">
          <source>Note that using this action from &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#enter_loop-5&quot;&gt;enter_loop/5,6&lt;/a&gt;&lt;/code&gt; would be weird on the border of witchcraft since there has been no earlier call to a &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; in this server.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;#enter_loop-5&quot;&gt;enter_loop/5,6&lt;/a&gt;&lt;/code&gt; からこのアクションを使用することは、このサーバーで以前に &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; への呼び出しがなかったため、魔術の境界で奇妙なことに注意してください。</target>
        </trans-unit>
        <trans-unit id="9f61aaf53fdf26271e4990884786f10164139b23" translate="yes" xml:space="preserve">
          <source>Note that when compiling a module &lt;strong&gt;all existing coverage data is removed&lt;/strong&gt;, including imported data. If a module is already compiled when data is imported, the imported data is &lt;strong&gt;added&lt;/strong&gt; to the existing coverage data.</source>
          <target state="translated">モジュールをコンパイルすると、インポートされたデータを含む&lt;strong&gt;すべての既存のカバレッジデータが削除される&lt;/strong&gt;ことに注意してください。データのインポート時にモジュールがすでにコンパイルされている場合、インポートされたデータは既存のカバレッジデータに&lt;strong&gt;追加さ&lt;/strong&gt;れます。</target>
        </trans-unit>
        <trans-unit id="df20ba18430e7a9839bde3720f0b99fc09d3133d" translate="yes" xml:space="preserve">
          <source>Note that when the value of the data to input is a string, it has to be quoted with &lt;code&gt;'&lt;/code&gt;. Example:</source>
          <target state="translated">入力するデータの値が文字列の場合は、 &lt;code&gt;'&lt;/code&gt; で引用する必要があることに注意してください。例：</target>
        </trans-unit>
        <trans-unit id="686eb963081bb17804ec4126760703b99e0e06a4" translate="yes" xml:space="preserve">
          <source>Note that whenever a document in &lt;code&gt;Docs&lt;/code&gt; contains a line break, it will be placed on a separate line. Thus, neither a layout such as</source>
          <target state="translated">&lt;code&gt;Docs&lt;/code&gt; に改行が含まれている場合は常に、別の行に配置されます。したがって、次のようなレイアウトも</target>
        </trans-unit>
        <trans-unit id="f445dc35aa8bfa91f3e834a45f7fca092ded7275" translate="yes" xml:space="preserve">
          <source>Note that while &lt;code&gt;TCP_NOPUSH&lt;/code&gt; socket option is available on OSX, its semantics is very different (e.g., unsetting it does not cause immediate send of accumulated data). Hence, &lt;code&gt;nopush&lt;/code&gt; option is intentionally ignored on OSX.</source>
          <target state="translated">&lt;code&gt;TCP_NOPUSH&lt;/code&gt; ソケットオプションはOSXで使用できますが、そのセマンティクスは大きく異なることに注意してください（たとえば、設定を解除しても、蓄積されたデータがすぐに送信されることはありません）。したがって、 &lt;code&gt;nopush&lt;/code&gt; オプションはOSXでは意図的に無視されます。</target>
        </trans-unit>
        <trans-unit id="51ce8067681e0ca58dded25b6ecd3a75afe5a9e0" translate="yes" xml:space="preserve">
          <source>Note that work executing on dirty I/O schedulers are expected to mainly wait for I/O. That is, when you get high scheduler utilization on dirty I/O schedulers, CPU utilization is &lt;strong&gt;not&lt;/strong&gt; expected to be high due to this work.</source>
          <target state="translated">ダーティI / Oスケジューラで実行される作業は、主にI / Oを待機することが期待されていることに注意してください。つまり、ダーティーI / Oスケジューラーでスケジューラー使用率が高い場合、この作業のためにCPU使用率が高くなること&lt;strong&gt;は&lt;/strong&gt;想定されて&lt;strong&gt;いません&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="523d72a03618b74e2aff0e449d66e6cc2c0c698a" translate="yes" xml:space="preserve">
          <source>Note that you cannot define arbitrary variables in a cross compilation configuration file. Only the ones listed below will be guaranteed to be visible throughout the whole execution of all &lt;code&gt;configure&lt;/code&gt; scripts. Other variables needs to be defined as arguments to &lt;code&gt;configure&lt;/code&gt; or exported in the environment.</source>
          <target state="translated">クロスコンパイル構成ファイルでは任意の変数を定義できないことに注意してください。以下にリストされているものだけが、すべての &lt;code&gt;configure&lt;/code&gt; スクリプトの実行全体を通して表示されることが保証されます。その他の変数は、環境で &lt;code&gt;configure&lt;/code&gt; またはエクスポートするための引数として定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="7bfec520257edb9cec974688079c41974b401d13" translate="yes" xml:space="preserve">
          <source>Note that you need to have run &lt;code&gt;(cd $ERL_TOP &amp;amp;&amp;amp; eval `./otp_build env_win32`)&lt;/code&gt; in the particular shell before building anything on Windows. After doing a make opt you can test your result by running &lt;code&gt;$ERL_TOP/bin/erl&lt;/code&gt;. If you want to copy the result to a release directory (say &lt;code&gt;/tmp/erl_release&lt;/code&gt;), you do this (still in &lt;code&gt;$ERL_TOP/erts/emulator&lt;/code&gt;)</source>
          <target state="translated">Windowsで何かをビルドする前に、特定のシェルで &lt;code&gt;(cd $ERL_TOP &amp;amp;&amp;amp; eval `./otp_build env_win32`)&lt;/code&gt; を実行する必要があることに注意してください。make optを実行した後、 &lt;code&gt;$ERL_TOP/bin/erl&lt;/code&gt; 実行して結果をテストできます。結果をリリースディレクトリ（たとえば &lt;code&gt;/tmp/erl_release&lt;/code&gt; ）にコピーする場合は、これを行います（まだ &lt;code&gt;$ERL_TOP/erts/emulator&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="4a5f7a43dea5055412cd813699aecbdd4537ff72" translate="yes" xml:space="preserve">
          <source>Note that you're expected to have a fresh Erlang in your path when doing this, preferably the plain 21 you have built in the previous steps. You could also add &lt;code&gt;$ERL_TOP/bootstrap/bin&lt;/code&gt; to your &lt;code&gt;PATH&lt;/code&gt; before rebuilding specific libraries. That would give you a good enough Erlang system to compile any OTP erlang code. Setting up the path correctly is a little bit tricky. You still need to have &lt;code&gt;$ERL_TOP/erts/etc/win32/cygwin_tools/vc&lt;/code&gt; and &lt;code&gt;$ERL_TOP/erts/etc/win32/cygwin_tools&lt;/code&gt;&lt;strong&gt;before&lt;/strong&gt; the actual emulator in the path. A typical setting of the path for using the bootstrap compiler would be:</source>
          <target state="translated">これを行うときは、パスに新しいErlang、できれば前のステップで作成したプレーン21が必要であることに注意してください。特定のライブラリを再構築する前に、 &lt;code&gt;PATH&lt;/code&gt; に &lt;code&gt;$ERL_TOP/bootstrap/bin&lt;/code&gt; を追加することもできます。これにより、OTP erlangコードをコンパイルするのに十分なErlangシステムが得られます。パスを正しく設定するのは少し難しいです。パスの実際のエミュレータの&lt;strong&gt;前に&lt;/strong&gt;、 &lt;code&gt;$ERL_TOP/erts/etc/win32/cygwin_tools/vc&lt;/code&gt; と &lt;code&gt;$ERL_TOP/erts/etc/win32/cygwin_tools&lt;/code&gt; がまだ必要です。ブートストラップコンパイラを使用するためのパスの一般的な設定は次のようになります。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0eb0b5bede55df32486ffb5e68143aaf83b271f3" translate="yes" xml:space="preserve">
          <source>Note that you're expected to have a fresh Erlang in your path when doing this, preferably the plain 23 you have built in the previous steps. You could also add &lt;code&gt;$ERL_TOP/bootstrap/bin&lt;/code&gt; to your &lt;code&gt;PATH&lt;/code&gt; before rebuilding specific libraries. That would give you a good enough Erlang system to compile any OTP erlang code. Setting up the path correctly is a little bit tricky. You still need to have &lt;code&gt;$ERL_TOP/erts/etc/win32/wsl_tools/vc&lt;/code&gt; and &lt;code&gt;$ERL_TOP/erts/etc/win32/wsl_tools&lt;/code&gt;&lt;strong&gt;before&lt;/strong&gt; the actual emulator in the path. A typical setting of the path for using the bootstrap compiler would be:</source>
          <target state="translated">これを行うときは、パスに新しいアーランが含まれていることが期待されることに注意してください。できれば、前の手順で作成したプレーン23を使用してください。特定のライブラリを再構築する前に、 &lt;code&gt;PATH&lt;/code&gt; に &lt;code&gt;$ERL_TOP/bootstrap/bin&lt;/code&gt; を追加することもできます。これにより、OTPerlangコードをコンパイルするのに十分なErlangシステムが得られます。パスを正しく設定するのは少し注意が必要です。あなたはまだ持っている必要があります &lt;code&gt;$ERL_TOP/erts/etc/win32/wsl_tools/vc&lt;/code&gt; および &lt;code&gt;$ERL_TOP/erts/etc/win32/wsl_tools&lt;/code&gt; &lt;strong&gt;前に&lt;/strong&gt;、パス内の実際のエミュレータ。ブートストラップコンパイラを使用するためのパスの一般的な設定は次のとおりです。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0f59844103d6ba8ed4dae0a9ab2a29d364c2a6a4" translate="yes" xml:space="preserve">
          <source>Note that, as a way to indicate the newest file, &lt;code&gt;run_erl&lt;/code&gt; will delete the oldest log file to maintain a &quot;hole&quot; in the file sequences. For example, if log files #1, #2, #4 and #5 exists, that means #2 is the latest and #4 is the oldest. You will therefore at most get one less log file than the value set by &lt;code&gt;RUN_ERL_LOG_GENERATIONS&lt;/code&gt;.</source>
          <target state="translated">最新のファイルを示す方法として、 &lt;code&gt;run_erl&lt;/code&gt; は最も古いログファイルを削除して、ファイルシーケンスの「穴」を維持することに注意してください。たとえば、ログファイル＃1、＃2、＃4、および＃5が存在する場合、それは＃2が最新で、＃4が最も古いことを意味します。したがって、取得するログファイルは、 &lt;code&gt;RUN_ERL_LOG_GENERATIONS&lt;/code&gt; によって設定された値よりも最大で1つ少なくなります。</target>
        </trans-unit>
        <trans-unit id="cc609e818cd60886eb0217d87244da60ff760651" translate="yes" xml:space="preserve">
          <source>Note the difference between &lt;code&gt;move c xy&lt;/code&gt; and &lt;code&gt;move c d&lt;/code&gt;. Note that &lt;code&gt;move c xy&lt;/code&gt; is equivalent to the following two definitions:</source>
          <target state="translated">違いに注意してください &lt;code&gt;move c xy&lt;/code&gt; と &lt;code&gt;move c d&lt;/code&gt; 。 &lt;code&gt;move c xy&lt;/code&gt; は、次の2つの定義と同等であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="d6c73dcf363499057947cccf47d8448b7dbaf012" translate="yes" xml:space="preserve">
          <source>Note the fact that you can use &lt;code&gt;throw&lt;/code&gt; to return the result, which can be useful. For example to bail out with &lt;code&gt;throw(keep_state_and_data)&lt;/code&gt; from deep within complex code that can not return &lt;code&gt;{next_state,State,Data}&lt;/code&gt; because &lt;code&gt;State&lt;/code&gt; or &lt;code&gt;Data&lt;/code&gt; is no longer in scope.</source>
          <target state="translated">&lt;code&gt;throw&lt;/code&gt; を使用して結果を返すことができるので、便利です。たとえば、 &lt;code&gt;State&lt;/code&gt; または &lt;code&gt;Data&lt;/code&gt; がスコープ内にないため &lt;code&gt;{next_state,State,Data}&lt;/code&gt; ない複雑なコード内の深い &lt;code&gt;throw(keep_state_and_data)&lt;/code&gt; からthrow（keep_state_and_data）を使用して救済します。</target>
        </trans-unit>
        <trans-unit id="7f3c2db9a65e908102a67487ed12c89a758f057f" translate="yes" xml:space="preserve">
          <source>Note the fact that you can use &lt;code&gt;throw&lt;/code&gt; to return the result, which can be useful. For example to bail out with &lt;code&gt;throw(keep_state_and_data)&lt;/code&gt; from deep within complex code that cannot return &lt;code&gt;{next_state,State,Data}&lt;/code&gt; because &lt;code&gt;State&lt;/code&gt; or &lt;code&gt;Data&lt;/code&gt; is no longer in scope.</source>
          <target state="translated">&lt;code&gt;throw&lt;/code&gt; を使用して結果を返すことができるという事実に注意してください。これは便利です。たとえば、 &lt;code&gt;State&lt;/code&gt; または &lt;code&gt;Data&lt;/code&gt; がスコープ内にないために &lt;code&gt;{next_state,State,Data}&lt;/code&gt; 返すことができない複雑なコードの奥深くから &lt;code&gt;throw(keep_state_and_data)&lt;/code&gt; でベイルアウトします。</target>
        </trans-unit>
        <trans-unit id="4317e03fcba152213e0ea0f2f44b86239f1e5599" translate="yes" xml:space="preserve">
          <source>Note this option is not needed in normal TLS usage and should not be used to implement new clients. But legacy clients that retries connections in the following manner</source>
          <target state="translated">このオプションは通常の TLS の使用法では必要なく、新しいクライアントを実装するために使用すべきではないことに注意してください。しかし、以下のような方法で接続を再試行するレガシークライアントは</target>
        </trans-unit>
        <trans-unit id="3157e5999d26e98c016dbd63bda9ac9a0dfb9593" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;Clause&lt;/code&gt; must have type &lt;code&gt;clause&lt;/code&gt;.</source>
          <target state="translated">注： &lt;code&gt;Clause&lt;/code&gt; はtype &lt;code&gt;clause&lt;/code&gt; 必要です。</target>
        </trans-unit>
        <trans-unit id="308285ef58a3193174b243e20988fef230082fab" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;arity_qualifier&lt;/code&gt; nodes are recognized. This is to follow The Erlang Parser when it comes to wild attributes: both {F, A} and F/A are recognized, which makes it possible to turn wild attributes into recognized attributes without at the same time making it impossible to compile files using the new syntax with the old version of the Erlang Compiler.</source>
          <target state="translated">注： &lt;code&gt;arity_qualifier&lt;/code&gt; ノードは認識されます。これは、ワイルド属性に関しては、Erlangパーサーに従います。{F、A}とF / Aの両方が認識されるため、同時に使用してファイルをコンパイルすることを不可能にせずに、ワイルド属性を認識された属性に変えることができます。古いバージョンのErlangコンパイラでの新しい構文。</target>
        </trans-unit>
        <trans-unit id="d81e2383b82cc4e91e2f04de6cf454f9653c7f46" translate="yes" xml:space="preserve">
          <source>Note: All instances of free variables will be given distinct labels.</source>
          <target state="translated">注意:自由変数のすべてのインスタンスには、明確なラベルが与えられます。</target>
        </trans-unit>
        <trans-unit id="8b61204a294edc11d57ba05c5e469df9123163d6" translate="yes" xml:space="preserve">
          <source>Note: Because &lt;code&gt;Node&lt;/code&gt; is a syntax tree, the actual run-time values corresponding to its subtrees may often be partially or completely unknown. Thus, if &lt;code&gt;Node&lt;/code&gt; represents e.g. &quot;&lt;code&gt;[... | Ns]&lt;/code&gt;&quot; (where &lt;code&gt;Ns&lt;/code&gt; is a variable), then the function will return &lt;code&gt;false&lt;/code&gt;, because it is not known whether &lt;code&gt;Ns&lt;/code&gt; will be bound to a list at run-time. If &lt;code&gt;Node&lt;/code&gt; instead represents e.g. &quot;&lt;code&gt;[1, 2, 3]&lt;/code&gt;&quot; or &quot;&lt;code&gt;[A | []]&lt;/code&gt;&quot;, then the function will return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">注： &lt;code&gt;Node&lt;/code&gt; は構文ツリーであるため、そのサブツリーに対応する実際の実行時の値は、部分的または完全に不明な場合があります。したがって、 &lt;code&gt;Node&lt;/code&gt; がたとえば &quot; &lt;code&gt;[... | Ns]&lt;/code&gt; &quot;（ &lt;code&gt;Ns&lt;/code&gt; は変数）を表す場合、実行時に &lt;code&gt;Ns&lt;/code&gt; がリストにバインドされるかどうかがわからないため、関数は &lt;code&gt;false&lt;/code&gt; を返します。場合 &lt;code&gt;Node&lt;/code&gt; 代わりに&quot;などを表し &lt;code&gt;[1, 2, 3]&lt;/code&gt; &quot;または&quot; &lt;code&gt;[A | []]&lt;/code&gt; &quot;、その関数は戻ります &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="adf9d511dcfa9aaf58ab7283975eec8497bcb0e4" translate="yes" xml:space="preserve">
          <source>Note: Binary-syntax patterns are never structurally matched against binary-syntax expressions by this function.</source>
          <target state="translated">注意:この関数では、バイナリ構文パターンがバイナリ構文式に対して構造的にマッチすることはありません。</target>
        </trans-unit>
        <trans-unit id="a0562ade2cea8acce9b76b0b4ab90737668e5d26" translate="yes" xml:space="preserve">
          <source>Note: Currently, the set of syntax trees which have a concrete representation is larger than the set of trees which can be built using the function &lt;code&gt;&lt;a href=&quot;#abstract-1&quot;&gt;abstract/1&lt;/a&gt;&lt;/code&gt;. An abstract character will be concretised as an integer, while &lt;code&gt;&lt;a href=&quot;#abstract-1&quot;&gt;abstract/1&lt;/a&gt;&lt;/code&gt; does not at present yield an abstract character for any input. (Use the &lt;code&gt;&lt;a href=&quot;#char-1&quot;&gt;char/1&lt;/a&gt;&lt;/code&gt; function to explicitly create an abstract character.)</source>
          <target state="translated">注：現在、具象表現を持つ構文ツリーのセットは、関数 &lt;code&gt;&lt;a href=&quot;#abstract-1&quot;&gt;abstract/1&lt;/a&gt;&lt;/code&gt; を使用して構築できるツリーのセットよりも大きくなっています。抽象文字は整数として具体化されますが、 &lt;code&gt;&lt;a href=&quot;#abstract-1&quot;&gt;abstract/1&lt;/a&gt;&lt;/code&gt; は現在のところ、どの入力に対しても抽象文字を生成しません。（ &lt;code&gt;&lt;a href=&quot;#char-1&quot;&gt;char/1&lt;/a&gt;&lt;/code&gt; 関数を使用して、抽象文字を明示的に作成します。）</target>
        </trans-unit>
        <trans-unit id="165ae8a32f7b6f64943274e92b98458ca7d19edd" translate="yes" xml:space="preserve">
          <source>Note: If some document in &lt;code&gt;Docs&lt;/code&gt; contains a line break, the vertical layout will always be selected.</source>
          <target state="translated">注：中にいくつかの文書場合 &lt;code&gt;Docs&lt;/code&gt; 改行が含まれている、垂直レイアウトが常に選択されます。</target>
        </trans-unit>
        <trans-unit id="3840eb20d7586de2203199630f1c366ff144d8c6" translate="yes" xml:space="preserve">
          <source>Note: If you get a &quot;syntax error&quot; message when trying to merge files (and you know those files to be correct), then try the &lt;code&gt;preprocess&lt;/code&gt; option. It typically means that your code contains too strange macros to be handled without actually performing the preprocessor expansions.</source>
          <target state="translated">注：ファイルをマージしようとしたときに「構文エラー」メッセージが表示された場合（およびそれらのファイルが正しいことがわかっている場合）、 &lt;code&gt;preprocess&lt;/code&gt; オプションを試してください。通常、コードに奇妙なマクロが含まれているため、実際にプリプロセッサの展開を行わないと処理できません。</target>
        </trans-unit>
        <trans-unit id="884eb65502e4a057112e64304a3aee60ecdc8306" translate="yes" xml:space="preserve">
          <source>Note: Since &lt;code&gt;Node&lt;/code&gt; is a syntax tree, the actual run-time values corresponding to its subtrees may often be partially or completely unknown. Thus, if &lt;code&gt;Node&lt;/code&gt; represents e.g. &quot;&lt;code&gt;[... | Ns]&lt;/code&gt;&quot; (where &lt;code&gt;Ns&lt;/code&gt; is a variable), then the function will return &lt;code&gt;false&lt;/code&gt;, because it is not known whether &lt;code&gt;Ns&lt;/code&gt; will be bound to a list at run-time. If &lt;code&gt;Node&lt;/code&gt; instead represents e.g. &quot;&lt;code&gt;[1, 2, 3]&lt;/code&gt;&quot; or &quot;&lt;code&gt;[A | []]&lt;/code&gt;&quot;, then the function will return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">注： &lt;code&gt;Node&lt;/code&gt; は構文ツリーであるため、そのサブツリーに対応する実際のランタイム値は、部分的または完全に不明であることがよくあります。したがって、 &lt;code&gt;Node&lt;/code&gt; が &quot; &lt;code&gt;[... | Ns]&lt;/code&gt; &quot;（ &lt;code&gt;Ns&lt;/code&gt; は変数）を表す場合、実行時に &lt;code&gt;Ns&lt;/code&gt; がリストにバインドされるかどうかは不明であるため、関数は &lt;code&gt;false&lt;/code&gt; を返します。場合 &lt;code&gt;Node&lt;/code&gt; 代わりに&quot;などを表し &lt;code&gt;[1, 2, 3]&lt;/code&gt; &quot;または&quot; &lt;code&gt;[A | []]&lt;/code&gt; &quot;、その関数は戻ります &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef01dc14c91674b058f1673b8d98cbd24605f910" translate="yes" xml:space="preserve">
          <source>Note: The Erlang language has distinct 1-tuples, i.e., &lt;code&gt;{X}&lt;/code&gt; is always distinct from &lt;code&gt;X&lt;/code&gt; itself.</source>
          <target state="translated">注：Erlang言語には1つのタプルがあります。つまり、 &lt;code&gt;{X}&lt;/code&gt; は常に &lt;code&gt;X&lt;/code&gt; 自体とは異なります。</target>
        </trans-unit>
        <trans-unit id="cbd9bd8a8c68fbfcb71e2f8c20f0bf3e55f2ea3f" translate="yes" xml:space="preserve">
          <source>Note: The distinction between &quot;static&quot; and &quot;safe&quot; modules is necessary in order not to break the semantics of dynamic code replacement. A &quot;static&quot; source module will not be replaced unless the target module also is. Now imagine a state machine implemented by placing the code for each state in a separate module, and suppose that we want to merge this into a single target module, marking all source modules as static. At each point in the original code where a call is made from one of the modules to another (i.e., the state transitions), code replacement is expected to be detected. Then, if we in the merged code do not check at these points if the &lt;strong&gt;target&lt;/strong&gt; module (the result of the merge) has been replaced, we can not be sure in general that we will be able to do code replacement of the merged state machine - it could run forever without detecting the code change. Therefore, all such calls must remain remote-calls (detecting code changes), but may call the target module directly.</source>
          <target state="translated">注：動的コード置換のセマンティクスを壊さないためには、「静的」モジュールと「安全」モジュールの区別が必要です。 「静的な」ソースモジュールは、ターゲットモジュールも置き換えられない限り置き換えられません。次に、各状態のコードを個別のモジュールに配置して実装された状態マシンを想像してください。これを単一のターゲットモジュールにマージし、すべてのソースモジュールを静的としてマークするとします。モジュールの1つから別のモジュールへの呼び出しが行われる元のコードの各ポイント（つまり、状態遷移）で、コード置換が検出されることが期待されます。次に、マージされたコードでこれらのポイントをチェックしない場合、&lt;strong&gt;ターゲットが&lt;/strong&gt;モジュール（マージの結果）は置き換えられました。一般に、マージされた状態マシンのコード置換を実行できるかどうかはわかりません。コードの変更を検出せずに永久に実行される可能性があります。したがって、そのような呼び出しはすべてリモート呼び出し（コード変更の検出）のままである必要がありますが、ターゲットモジュールを直接呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="8daa2d5e45d509f284f5f3a9bb9a8c05ad568947" translate="yes" xml:space="preserve">
          <source>Note: The distinction between &quot;static&quot; and &quot;safe&quot; modules is necessary in order not to break the semantics of dynamic code replacement. A &quot;static&quot; source module will not be replaced unless the target module also is. Now imagine a state machine implemented by placing the code for each state in a separate module, and suppose that we want to merge this into a single target module, marking all source modules as static. At each point in the original code where a call is made from one of the modules to another (i.e., the state transitions), code replacement is expected to be detected. Then, if we in the merged code do not check at these points if the &lt;strong&gt;target&lt;/strong&gt; module (the result of the merge) has been replaced, we cannot be sure in general that we will be able to do code replacement of the merged state machine - it could run forever without detecting the code change. Therefore, all such calls must remain remote-calls (detecting code changes), but may call the target module directly.</source>
          <target state="translated">注：動的コード置換のセマンティクスを壊さないために、「静的」モジュールと「安全」モジュールを区別する必要があります。 「静的」ソースモジュールは、ターゲットモジュールも交換されない限り交換されません。ここで、各状態のコードを個別のモジュールに配置することによって実装されたステートマシンを想像し、これを単一のターゲットモジュールにマージして、すべてのソースモジュールを静的としてマークするとします。モジュールの1つから別のモジュールへの呼び出しが行われる（つまり、状態遷移）元のコードの各ポイントで、コードの置換が検出されることが期待されます。次に、マージされたコードで、これらのポイントで&lt;strong&gt;ターゲット&lt;/strong&gt;かどうかをチェックしない場合&lt;strong&gt;&lt;/strong&gt;モジュール（マージの結果）が置き換えられたため、マージされたステートマシンのコード置換を実行できるかどうかは一般にわかりません。コードの変更を検出せずに永久に実行される可能性があります。したがって、このような呼び出しはすべてリモート呼び出し（コード変更の検出）のままである必要がありますが、ターゲットモジュールを直接呼び出す場合があります。</target>
        </trans-unit>
        <trans-unit id="9850cccf6fb6ccf68d12503d679738d939b63a6a" translate="yes" xml:space="preserve">
          <source>Note: The name of the primary constructor function for a node type is always the name of the type itself, prefixed by &quot;&lt;code&gt;c_&lt;/code&gt;&quot;; recognizer predicates are correspondingly prefixed by &quot;&lt;code&gt;is_c_&lt;/code&gt;&quot;. Furthermore, to simplify preservation of annotations (cf. &lt;code&gt;get_ann/1&lt;/code&gt;), there are analogous constructor functions prefixed by &quot;&lt;code&gt;ann_c_&lt;/code&gt;&quot; and &quot;&lt;code&gt;update_c_&lt;/code&gt;&quot;, for setting the annotation list of the new node to either a specific value or to the annotations of an existing node, respectively.</source>
          <target state="translated">注：ノードタイプのプライマリコンストラクター関数の名前は、常にタイプ自体の名前であり、接頭辞として「 &lt;code&gt;c_&lt;/code&gt; 」が付いています。 &lt;code&gt;is_c_&lt;/code&gt; 述語には、それに応じて「is_c_」という接頭辞が付きます。さらに、注釈の保存を簡素化するために（ &lt;code&gt;get_ann/1&lt;/code&gt; を参照）、新しいノードの注釈リストを特定の値またはの注釈に設定するために、接頭辞「 &lt;code&gt;ann_c_&lt;/code&gt; 」および「 &lt;code&gt;update_c_&lt;/code&gt; 」が付いた類似のコンストラクター関数があります。それぞれ既存のノード。</target>
        </trans-unit>
        <trans-unit id="2872d7972612ca53705b122b06de88412b65023e" translate="yes" xml:space="preserve">
          <source>Note: The preprocessor macro definition directive &quot;&lt;code&gt;-define(Name, Body).&lt;/code&gt;&quot; has relatively few requirements on the syntactical form of &lt;code&gt;Body&lt;/code&gt; (viewed as a sequence of tokens). The &lt;code&gt;text&lt;/code&gt; node type can be used for a &lt;code&gt;Body&lt;/code&gt; that is not a normal Erlang construct.</source>
          <target state="translated">注：プリプロセッサマクロ定義ディレクティブ &lt;code&gt;-define(Name, Body).&lt;/code&gt; 」の構文形式に比較的少数の要件を持っている &lt;code&gt;Body&lt;/code&gt; （トークンのシーケンスとして表示します）。 &lt;code&gt;text&lt;/code&gt; ノードタイプはのために使用することができる &lt;code&gt;Body&lt;/code&gt; 通常アーラン構築物ではありません。</target>
        </trans-unit>
        <trans-unit id="6a3d6a31994b23aff112f18cb8ed90847216cb94" translate="yes" xml:space="preserve">
          <source>Note: The primary constructor functions for a node type should always have the same name as the node type itself.</source>
          <target state="translated">注:ノード型のプライマリ・コンストラクタ関数は、常にノード型自体と同じ名前を持つ必要があります。</target>
        </trans-unit>
        <trans-unit id="8ca2fedd6ed2548e302789ae2e0c23407f15fd76" translate="yes" xml:space="preserve">
          <source>Note: This is a constant time operation.</source>
          <target state="translated">注:これは一定時間の操作です。</target>
        </trans-unit>
        <trans-unit id="a75af5c6559b7697b82cd55b9c2024ae62ccc77d" translate="yes" xml:space="preserve">
          <source>Note: This is equivalent to &lt;code&gt;(get_precomments(Node) == []) and (get_postcomments(Node) == [])&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">注：これは &lt;code&gt;(get_precomments(Node) == []) and (get_postcomments(Node) == [])&lt;/code&gt; と同等ですが、潜在的に効率的です。</target>
        </trans-unit>
        <trans-unit id="bb58e56411d72b2c5de64c07dff668396f493062" translate="yes" xml:space="preserve">
          <source>Note: This is equivalent to &lt;code&gt;add_postcomments(get_postcomments(Source), add_precomments(get_precomments(Source), Target))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">注：これは &lt;code&gt;add_postcomments(get_postcomments(Source), add_precomments(get_precomments(Source), Target))&lt;/code&gt; と同等ですが、潜在的に効率的です。</target>
        </trans-unit>
        <trans-unit id="961e68d5ec80ea10407155400f5248fb08c77ba7" translate="yes" xml:space="preserve">
          <source>Note: This is equivalent to &lt;code&gt;length(values_es(Node))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">注：これは &lt;code&gt;length(values_es(Node))&lt;/code&gt; と同等ですが、より効率的になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="f8cc9a8168087cf73aa91a1ca9a6fb283bef773c" translate="yes" xml:space="preserve">
          <source>Note: This is equivalent to &lt;code&gt;set_postcomments(Node, get_postcomments(Node) ++ Comments)&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">注：これは &lt;code&gt;set_postcomments(Node, get_postcomments(Node) ++ Comments)&lt;/code&gt; と同等ですが、潜在的に効率的です。</target>
        </trans-unit>
        <trans-unit id="d09be805d2731441552cb1761a72f29b924b8a7a" translate="yes" xml:space="preserve">
          <source>Note: This is equivalent to &lt;code&gt;set_postcomments(set_precomments(Target, get_precomments(Source)), get_postcomments(Source))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">注：これは &lt;code&gt;set_postcomments(set_precomments(Target, get_precomments(Source)), get_postcomments(Source))&lt;/code&gt; と同等ですが、潜在的にはより効率的です。</target>
        </trans-unit>
        <trans-unit id="698437d5693811f218a0125173a54360a31fae26" translate="yes" xml:space="preserve">
          <source>Note: This is equivalent to &lt;code&gt;set_precomments(Node, get_precomments(Node) ++ Comments)&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">注：これは &lt;code&gt;set_precomments(Node, get_precomments(Node) ++ Comments)&lt;/code&gt; と同等ですが、潜在的に効率的です。</target>
        </trans-unit>
        <trans-unit id="94f64f74f43a14a0fd5a71cca82d5190660bfa22" translate="yes" xml:space="preserve">
          <source>Note: This is equivalent to &lt;code&gt;set_precomments(set_postcomments(Node, []), [])&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">注：これは &lt;code&gt;set_precomments(set_postcomments(Node, []), [])&lt;/code&gt; と同等ですが、潜在的に効率的です。</target>
        </trans-unit>
        <trans-unit id="1c349a183f568e3a4f03fe936ebb15f7b0b8d9c0" translate="yes" xml:space="preserve">
          <source>Note: all literals (cf. &lt;code&gt;is_literal/1&lt;/code&gt;) are leaf nodes, even if they represent structured (constant) values such as &lt;code&gt;{foo, [bar, baz]}&lt;/code&gt;. Also note that variables are leaf nodes but not literals.</source>
          <target state="translated">注：すべてのリテラル（ &lt;code&gt;is_literal/1&lt;/code&gt; を参照）は、 &lt;code&gt;{foo, [bar, baz]}&lt;/code&gt; などの構造化された（定数）値を表す場合でも、リーフノードです。また、変数はリーフノードですが、リテラルではないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="f9ca5b0925ea2a2251f51d1eef2e90cac1124164" translate="yes" xml:space="preserve">
          <source>Note: catch-expressions can be rewritten as try-expressions, and will eventually be removed from Core Erlang.</source>
          <target state="translated">Note:catch-expressionはtry-expressionとして書き換えられ、最終的にはCore Erlangから削除されます。</target>
        </trans-unit>
        <trans-unit id="c2cbae916b385a433641891fb2f65cb175003a34" translate="yes" xml:space="preserve">
          <source>Note: changing this value (and passing the resulting context to a continuation function) does not affect the normal formatting, but may affect user-defined behaviour in hook functions.</source>
          <target state="translated">注意:この値を変更しても (結果として得られるコンテキストを継続関数に渡しても)通常の書式設定には影響しませんが、フック関数のユーザー定義の動作に影響を与える可能性があります。</target>
        </trans-unit>
        <trans-unit id="1e66a58313670e508e4d5829246111554fd79c2d" translate="yes" xml:space="preserve">
          <source>Note: each node in &lt;code&gt;Clauses&lt;/code&gt; must have type &lt;code&gt;clause&lt;/code&gt;.</source>
          <target state="translated">注：内の各ノード &lt;code&gt;Clauses&lt;/code&gt; 型持っている必要があります &lt;code&gt;clause&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c0e024adb668e3f8ad63658f3c7b61203ba9e048" translate="yes" xml:space="preserve">
          <source>Note: if &lt;code&gt;Node&lt;/code&gt; represents &quot;&lt;code&gt;M:F(...)&lt;/code&gt;&quot;, then the result is the subtree representing &quot;&lt;code&gt;M:F&lt;/code&gt;&quot;.</source>
          <target state="translated">注： &lt;code&gt;Node&lt;/code&gt; が「 &lt;code&gt;M:F(...)&lt;/code&gt; 」を表す場合、結果は「 &lt;code&gt;M:F&lt;/code&gt; 」を表すサブツリーになります。</target>
        </trans-unit>
        <trans-unit id="e950ce0b15b865ad70b6df0b8b6e16fd534c8751" translate="yes" xml:space="preserve">
          <source>Note: if &lt;code&gt;Node&lt;/code&gt; represents &quot;&lt;code&gt;fun N/A&lt;/code&gt;&quot; or &quot;&lt;code&gt;fun M:N/A&lt;/code&gt;&quot;, then the result is the subtree representing &quot;&lt;code&gt;N/A&lt;/code&gt;&quot; or &quot;&lt;code&gt;M:N/A&lt;/code&gt;&quot;, respectively.</source>
          <target state="translated">注： &lt;code&gt;Node&lt;/code&gt; が「 &lt;code&gt;fun N/A&lt;/code&gt; 」または「 &lt;code&gt;fun M:N/A&lt;/code&gt; 」を表す場合、結果はそれぞれ「 &lt;code&gt;N/A&lt;/code&gt; 」または「 &lt;code&gt;M:N/A&lt;/code&gt; 」を表すサブツリーになります。</target>
        </trans-unit>
        <trans-unit id="a650514ba11566a0849a47048d45d0a0ca77843f" translate="yes" xml:space="preserve">
          <source>Note: if &lt;code&gt;data_type(Node)&lt;/code&gt; is &lt;code&gt;cons&lt;/code&gt;, the number of subtrees is exactly two. If &lt;code&gt;data_type(Node)&lt;/code&gt; is &lt;code&gt;{atomic, Value}&lt;/code&gt;, the number of subtrees is zero.</source>
          <target state="translated">注： &lt;code&gt;data_type(Node)&lt;/code&gt; が &lt;code&gt;cons&lt;/code&gt; の場合、サブツリーの数は正確に2つです。場合 &lt;code&gt;data_type(Node)&lt;/code&gt; である &lt;code&gt;{atomic, Value}&lt;/code&gt; 、サブツリーの数はゼロです。</target>
        </trans-unit>
        <trans-unit id="024d798779fd03b9f02b44baf68e6e4bf1a905f4" translate="yes" xml:space="preserve">
          <source>Note: in &lt;code&gt;list(Elements, none)&lt;/code&gt;, the &quot;nil&quot; list terminator is implicit and has no associated information (see &lt;code&gt;&lt;a href=&quot;#get_attrs-1&quot;&gt;get_attrs/1&lt;/a&gt;&lt;/code&gt;), while in the seemingly equivalent &lt;code&gt;list(Elements, Tail)&lt;/code&gt; when &lt;code&gt;Tail&lt;/code&gt; has type &lt;code&gt;nil&lt;/code&gt;, the list terminator subtree &lt;code&gt;Tail&lt;/code&gt; may have attached attributes such as position, comments, and annotations, which will be preserved in the result.</source>
          <target state="translated">注： &lt;code&gt;list(Elements, none)&lt;/code&gt; では、「nil」リストターミネータは暗黙的であり、関連する情報はありませんが（ &lt;code&gt;&lt;a href=&quot;#get_attrs-1&quot;&gt;get_attrs/1&lt;/a&gt;&lt;/code&gt; を参照 &lt;code&gt;list(Elements, Tail)&lt;/code&gt; 、 &lt;code&gt;Tail&lt;/code&gt; のタイプが &lt;code&gt;nil&lt;/code&gt; である場合、リストターミネータは同等のlist（Elements、Tail）です。サブツリー &lt;code&gt;Tail&lt;/code&gt; は、位置、コメント、注釈などの属性が添付されている場合があり、これらは結果に保持されます。</target>
        </trans-unit>
        <trans-unit id="c912d0741e6afe02446fe862b8225b8a23da14f4" translate="yes" xml:space="preserve">
          <source>Note: no checking is done whether the character sequence represents a proper variable name, i.e., whether or not its first character is an uppercase Erlang character, or whether it does not contain control characters, whitespace, etc.</source>
          <target state="translated">注意:文字列が適切な変数名を表しているかどうか、つまり最初の文字が大文字のErlang文字であるかどうか、制御文字や空白などを含まないかどうかはチェックされません。</target>
        </trans-unit>
        <trans-unit id="0e16037ad2fddc6752207e81b2d23a2a536d6ff8" translate="yes" xml:space="preserve">
          <source>Note: not all literals are leaf nodes, and vice versa. E.g., tuples with nonzero arity and nonempty lists may be literals, but are not leaf nodes. Variables, on the other hand, are leaf nodes but not literals.</source>
          <target state="translated">注意:すべてのリテラルがリーフノードであるわけではありませんし、その逆もあります。例えば、アリティが0ではないタプルや空ではないリストはリテラルかもしれませんが、リーフノードではありません。一方、変数はリーフノードですが、リテラルではありません。</target>
        </trans-unit>
        <trans-unit id="3393ba242996126bd79b8530e4ba8690724e5617" translate="yes" xml:space="preserve">
          <source>Note: passing a string as argument to this function causes a corresponding atom to be created for the internal representation.</source>
          <target state="translated">注意:この関数の引数に文字列を渡すと、内部表現に対応するアトムが作成されます。</target>
        </trans-unit>
        <trans-unit id="e19a5f5e7535dfc22dce9d8f5ad97ff942d5f69e" translate="yes" xml:space="preserve">
          <source>Note: the literal corresponding to a particular character value is not uniquely defined. E.g., the character &quot;&lt;code&gt;a&lt;/code&gt;&quot; can be written both as &quot;&lt;code&gt;$a&lt;/code&gt;&quot; and &quot;&lt;code&gt;$\141&lt;/code&gt;&quot;, and a Tab character can be written as &quot;&lt;code&gt;$\11&lt;/code&gt;&quot;, &quot;&lt;code&gt;$\011&lt;/code&gt;&quot; or &quot;&lt;code&gt;$\t&lt;/code&gt;&quot;.</source>
          <target state="translated">注：特定の文字値に対応するリテラルは一意に定義されていません。たとえば、文字「 &lt;code&gt;a&lt;/code&gt; 」は「 &lt;code&gt;$a&lt;/code&gt; 」と「 &lt;code&gt;$\141&lt;/code&gt; 」の両方として記述でき、タブ文字は「 &lt;code&gt;$\11&lt;/code&gt; 」、「 &lt;code&gt;$\011&lt;/code&gt; 」、または「 &lt;code&gt;$\t&lt;/code&gt; 」と記述できます。</target>
        </trans-unit>
        <trans-unit id="6afc7eae3d94cce8a805b8208b70b9cbd6d1fee0" translate="yes" xml:space="preserve">
          <source>Note: the resulting list can contain more than one tuple &lt;code&gt;{ShortName, Name}&lt;/code&gt; for the same &lt;code&gt;ShortName&lt;/code&gt;, possibly with different values for &lt;code&gt;Name&lt;/code&gt;, depending on the given list.</source>
          <target state="translated">注：結果のリストには、同じ &lt;code&gt;ShortName&lt;/code&gt; の複数のタプル &lt;code&gt;{ShortName, Name}&lt;/code&gt; を含めることができます。指定されたリストによっては、 &lt;code&gt;Name&lt;/code&gt; の値が異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="e12fe9dbfa6c36c26ca8159eaa9cc67ee440fdd9" translate="yes" xml:space="preserve">
          <source>Note: the return value is &lt;code&gt;ok&lt;/code&gt; instead of &lt;code&gt;success&lt;/code&gt; unlike in other functions in this module. This is a fault that was introduced so long ago that any change would break a large number of existing software.</source>
          <target state="translated">注：このモジュールの他の関数とは異なり、戻り値は &lt;code&gt;success&lt;/code&gt; はなく &lt;code&gt;ok&lt;/code&gt; です。これは非常に前に導入された障害であり、変更を加えると既存のソフトウェアの多くが壊れます。</target>
        </trans-unit>
        <trans-unit id="17b17be20c7e8e9810e58ea4c73486c73bfc67e7" translate="yes" xml:space="preserve">
          <source>Note: the text returned by the formatting function will be split automatically into separate comment lines at each line break. No extra work is needed.</source>
          <target state="translated">注:書式設定関数で返されたテキストは、改行ごとに自動的に別々のコメント行に分割されます。余分な作業は必要ありません。</target>
        </trans-unit>
        <trans-unit id="41856edf3415d1e90c206e87cfe950bc7df0afeb" translate="yes" xml:space="preserve">
          <source>Note: these macros introduce a run-time dependency on the EUnit library code, if compiled with testing enabled.</source>
          <target state="translated">注意:テストを有効にしてコンパイルした場合、これらのマクロはEUnitライブラリコードにランタイム依存性を導入します。</target>
        </trans-unit>
        <trans-unit id="bd0d2709ddf8a0638d0aff92ed2e6f15b3be5f7b" translate="yes" xml:space="preserve">
          <source>Note: this is equivalent to &lt;code&gt;length(apply_args(Node))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">注：これは &lt;code&gt;length(apply_args(Node))&lt;/code&gt; と同等ですが、より効率的になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="ed1209b617e8d5cc3c5cfc6c1377fd43e5ce41cd" translate="yes" xml:space="preserve">
          <source>Note: this is equivalent to &lt;code&gt;length(call_args(Node))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">注：これは &lt;code&gt;length(call_args(Node))&lt;/code&gt; と同等ですが、より効率的である可能性があります。</target>
        </trans-unit>
        <trans-unit id="a6e53230502f03bb4733db74bc560eb0d865cde8" translate="yes" xml:space="preserve">
          <source>Note: this is equivalent to &lt;code&gt;length(clause_pats(Node))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">注：これは &lt;code&gt;length(clause_pats(Node))&lt;/code&gt; と同等ですが、より効率的である可能性があります。</target>
        </trans-unit>
        <trans-unit id="6dd282e7fb8db35030f176c6215fe03b5567042d" translate="yes" xml:space="preserve">
          <source>Note: this is equivalent to &lt;code&gt;length(fun_vars(Node))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">注：これは &lt;code&gt;length(fun_vars(Node))&lt;/code&gt; と同等ですが、より効率的になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="bca941f0b40db2f3695ecc15ccff4c8a24695250" translate="yes" xml:space="preserve">
          <source>Note: this is equivalent to &lt;code&gt;length(let_vars(Node))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">注：これは &lt;code&gt;length(let_vars(Node))&lt;/code&gt; と同等ですが、より効率的になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="58d78502c9d35d74b9f564b739de13ccb2a77f56" translate="yes" xml:space="preserve">
          <source>Note: this is equivalent to &lt;code&gt;length(list_elements(Node))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">注：これは &lt;code&gt;length(list_elements(Node))&lt;/code&gt; と同等ですが、潜在的にはより効率的です。</target>
        </trans-unit>
        <trans-unit id="ebcca9b6d7e57fd06c7e8bed4e5fd7e93be99484" translate="yes" xml:space="preserve">
          <source>Note: this is equivalent to &lt;code&gt;length(primop_args(Node))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">注：これは &lt;code&gt;length(primop_args(Node))&lt;/code&gt; と同等ですが、より効率的である可能性があります。</target>
        </trans-unit>
        <trans-unit id="97dc47a811817d58377be776d262e5b3c05f6cf1" translate="yes" xml:space="preserve">
          <source>Note: this is equivalent to &lt;code&gt;length(tuple_elements(Node))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">注：これは &lt;code&gt;length(tuple_elements(Node))&lt;/code&gt; と同等ですが、潜在的にはより効率的です。</target>
        </trans-unit>
        <trans-unit id="ec59e73e9bc821017665db80dbf6cf98689682f7" translate="yes" xml:space="preserve">
          <source>Note: this is equivalent to &lt;code&gt;length(tuple_es(Node))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">注：これは &lt;code&gt;length(tuple_es(Node))&lt;/code&gt; と同等ですが、より効率的になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="cea075dee9256e89d461acd90fcf6f51117060f2" translate="yes" xml:space="preserve">
          <source>Note: this is equivalent to &lt;code&gt;set_ann(Node, Annotations ++ get_ann(Node))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">注：これは &lt;code&gt;set_ann(Node, Annotations ++ get_ann(Node))&lt;/code&gt; と同等ですが、より効率的である可能性があります。</target>
        </trans-unit>
        <trans-unit id="4666d61b1ebe44a455ff212df8dfe43d5e4150ff" translate="yes" xml:space="preserve">
          <source>Note: this is equivalent to &lt;code&gt;set_ann(Node, [Annotation | get_ann(Node)])&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">注：これは &lt;code&gt;set_ann(Node, [Annotation | get_ann(Node)])&lt;/code&gt; と同等ですが、潜在的に効率的です。</target>
        </trans-unit>
        <trans-unit id="cdbc84877e38d50c218ad5207d2faecbe10b2060" translate="yes" xml:space="preserve">
          <source>Note: this is equivalent to &lt;code&gt;set_ann(Target, get_ann(Source))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">注：これは &lt;code&gt;set_ann(Target, get_ann(Source))&lt;/code&gt; と同等ですが、潜在的に効率的です。</target>
        </trans-unit>
        <trans-unit id="a5386e79b58eda950a5274a7a0af8b6cfc746999" translate="yes" xml:space="preserve">
          <source>Note: this is equivalent to &lt;code&gt;set_attrs(Target, get_attrs(Source))&lt;/code&gt;, but potentially more efficient.</source>
          <target state="translated">注：これは &lt;code&gt;set_attrs(Target, get_attrs(Source))&lt;/code&gt; と同等ですが、潜在的に効率的です。</target>
        </trans-unit>
        <trans-unit id="27b141a49bc96901cfd1d105a64d4c5f5a09eca3" translate="yes" xml:space="preserve">
          <source>Note: this is retained only for backwards compatibility with existing parsers and tools.</source>
          <target state="translated">注意:これは、既存のパーサやツールとの下位互換性のためだけに保持されます。</target>
        </trans-unit>
        <trans-unit id="9a585e3e15766522c8abd82fcb5ff8e1c6cca19e" translate="yes" xml:space="preserve">
          <source>Note: this is simply a way of grouping source code forms as a single syntax tree, usually in order to form an Erlang module definition.</source>
          <target state="translated">Note:これは単にソースコードのフォームを一つの構文ツリーとしてグループ化する方法で、通常はErlangモジュールの定義を形成するためのものです。</target>
        </trans-unit>
        <trans-unit id="7a43199c7c25f11800016e7472f3564571a0c7b8" translate="yes" xml:space="preserve">
          <source>Note: this is supported only for backwards compatibility with existing parsers and tools.</source>
          <target state="translated">注意:これは既存のパーサやツールとの下位互換性のためだけにサポートされています。</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="c32e67b1c4c65b813f5c5d3ba41235581ee4036f" translate="yes" xml:space="preserve">
          <source>Notes About MacOS X</source>
          <target state="translated">MacOS Xについての注意事項</target>
        </trans-unit>
        <trans-unit id="4d325fef3978cce9c3fe25199318432f2a2956f8" translate="yes" xml:space="preserve">
          <source>Notes and Implementation Details</source>
          <target state="translated">注意事項と実施内容</target>
        </trans-unit>
        <trans-unit id="9b98b21a7184296ef346762bd6728f411d329337" translate="yes" xml:space="preserve">
          <source>Notes concerning the Log Files</source>
          <target state="translated">ログファイルに関する注意事項</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="36d78a208c85e4ee9fbb30023fe1b73f1f6b5ac7" translate="yes" xml:space="preserve">
          <source>Notes: Floating documents appear to work well, but are currently less general than you might wish, losing effect when embedded in certain contexts. It is possible to nest floating-operators (even with different priorities), but the effects may be difficult to predict. In any case, note that the way the algorithm reorders floating documents amounts to a &quot;bubblesort&quot;, so don't expect it to be able to sort large sequences of floating documents quickly.</source>
          <target state="translated">注意事項。浮動小数点演算子はうまく動作するように見えますが、現在のところ思ったよりも一般的ではなく、特定のコンテキストに埋め込まれた場合には効果が失われます。浮動演算子を入れ子にすることは可能ですが(優先順位が異なる場合でも)、その効果を予測するのは難しいかもしれません。いずれにしても、アルゴリズムが浮動文書を並べ替える方法は「バブルソート」に相当するので、浮動文書の大規模なシーケンスを素早くソートできるとは期待しないでください。</target>
        </trans-unit>
        <trans-unit id="661b94995b5e8bdcfda9b5f651e69fddc51ef9bc" translate="yes" xml:space="preserve">
          <source>Notes: If a file contains too exotic definitions or uses of macros, it will not be possible to read it without preprocessing. Furthermore, Igor does not currently try to sort out multiple inclusions of the same file, or redefinitions of the same macro name. Therefore, when preprocessing is turned off, it may become necessary to edit the resulting source code, removing such re-inclusions and redefinitions.</source>
          <target state="translated">注意事項。ファイルにあまりにもエキゾチックな定義やマクロの使用法が含まれている場合、前処理を行わずに読み取ることはできません。さらに、Igor は現在のところ、同じファイルの複数の包含、または同じマクロ名の再定義を並べ替えようとはしません。そのため、前処理をオフにすると、そのような再包含や再定義を削除して、結果として得られるソースコードを編集する必要が出てくるかもしれません。</target>
        </trans-unit>
        <trans-unit id="15f88e626a7699794907797465138c59374fcbea" translate="yes" xml:space="preserve">
          <source>Notes: if &lt;code&gt;Arguments&lt;/code&gt; is the empty list, the result will thus represent &quot;&lt;code&gt;?Name()&lt;/code&gt;&quot;, including a pair of matching parentheses.</source>
          <target state="translated">注： &lt;code&gt;Arguments&lt;/code&gt; が空のリストの場合、結果は一致する括弧のペアを含め、「 &lt;code&gt;?Name()&lt;/code&gt; 」を表します。</target>
        </trans-unit>
        <trans-unit id="99a1f1cf872f6e0e707f9c22cb3a2c5254119532" translate="yes" xml:space="preserve">
          <source>Nothing is removed from the queue by this function, that must be done with &lt;code&gt;&lt;a href=&quot;#driver_deq&quot;&gt;driver_deq&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この関数によってキューから削除されるものはありません。これは &lt;code&gt;&lt;a href=&quot;#driver_deq&quot;&gt;driver_deq&lt;/a&gt;&lt;/code&gt; で行う必要があります。</target>
        </trans-unit>
        <trans-unit id="f4188a869e9e87b711a06e4a4b3f28fd00e2f8ef" translate="yes" xml:space="preserve">
          <source>Nothing is removed from the queue by this function, that must be done with &lt;code&gt;&lt;a href=&quot;#enif_ioq_deq&quot;&gt;enif_ioq_deq&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この関数によってキューから削除されるものはありません。これは、 &lt;code&gt;&lt;a href=&quot;#enif_ioq_deq&quot;&gt;enif_ioq_deq&lt;/a&gt;&lt;/code&gt; を使用して行う必要があります。</target>
        </trans-unit>
        <trans-unit id="65c645e6dc76f281bf44b4e98033d1a25ed3e13d" translate="yes" xml:space="preserve">
          <source>Notice also that &quot;&lt;code&gt;B=&amp;lt;&amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt;&quot; is interpreted as &quot;&lt;code&gt;B =&amp;lt;&amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt;&quot; which is a syntax error. The correct way is to write a space after '=': &quot;&lt;code&gt;B= &amp;lt;&amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">通知はまた、「 &lt;code&gt;B=&amp;lt;&amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt; 」「として解釈される &lt;code&gt;B =&amp;lt;&amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt; 構文エラーです」。正しい方法は、「=」の後にスペースを書き込むことです： &quot; &lt;code&gt;B= &amp;lt;&amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4e7821e854de5de8a4aacee0ff97239e9645aa44" translate="yes" xml:space="preserve">
          <source>Notice also that byte-oriented data is simplest sent using the ISO Latin-1 encoding.</source>
          <target state="translated">また、バイト指向のデータは、ISO Latin-1 エンコーディングを使用して送信されるのが最も単純であることにも注意してください。</target>
        </trans-unit>
        <trans-unit id="8a4c53d6a09620002b97e1f8172f87b851fbd7a6" translate="yes" xml:space="preserve">
          <source>Notice also that the transient type is of little practical use, because when a supervision tree terminates, the reason is set to &lt;code&gt;shutdown&lt;/code&gt;, not &lt;code&gt;normal&lt;/code&gt;.</source>
          <target state="translated">監視ツリーが終了すると、理由は &lt;code&gt;normal&lt;/code&gt; ではなく &lt;code&gt;shutdown&lt;/code&gt; に設定されるため、一時的なタイプはほとんど実用的ではないことにも注意してください。</target>
        </trans-unit>
        <trans-unit id="ed33ac880989d641a4eeb80431d2338e759148c9" translate="yes" xml:space="preserve">
          <source>Notice also that when testing the program from the shell, the input is spread over two lines as the line was too long.</source>
          <target state="translated">また、シェルからプログラムをテストする場合、行が長すぎたために入力が2行に渡って広がってしまうことにも注意してください。</target>
        </trans-unit>
        <trans-unit id="831cedf2104bac2a5f0cad0d085a43c104fcbad7" translate="yes" xml:space="preserve">
          <source>Notice also that ~p is used instead of ~w in &lt;code&gt;io:format&lt;/code&gt;. To quote the manual: &quot;~p Writes the data with standard syntax in the same way as ~w, but breaks terms whose printed representation is longer than one line into many lines and indents each line sensibly. It also tries to detect lists of printable characters and to output these as strings&quot;.</source>
          <target state="translated">&lt;code&gt;io:format&lt;/code&gt; では〜wの代わりに〜pが使用されていることにも注意してください。マニュアルを引用するには： &quot;〜pは、〜wと同じ方法で標準構文でデータを書き込みますが、印刷された表現が1行より長い用語を多くの行に分割し、各行を慎重にインデントします。また、印刷可能なリストを検出しようとします文字とこれらを文字列として出力します。</target>
        </trans-unit>
        <trans-unit id="c8bc316625e4c64bc96adbb50df0038f6cc5d2e3" translate="yes" xml:space="preserve">
          <source>Notice how the operator &quot;!&quot; is used to send messages. The syntax of &quot;!&quot; is:</source>
          <target state="translated">演算子 &quot;!&quot; がどのようにメッセージを送信するために使われているかに注目してください。&quot;!&quot; の構文は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="2981906ecbb99640904a52c6a3186e8def191ed9" translate="yes" xml:space="preserve">
          <source>Notice how to write the &lt;code&gt;server&lt;/code&gt; function so that it calls itself, through &lt;code&gt;server(User_List)&lt;/code&gt;, and thus creates a loop. The Erlang compiler is &quot;clever&quot; and optimizes the code so that this really is a sort of loop and not a proper function call. But this only works if there is no code after the call. Otherwise, the compiler expects the call to return and make a proper function call. This would result in the process getting bigger and bigger for every loop.</source>
          <target state="translated">&lt;code&gt;server(User_List)&lt;/code&gt; を介して自身を呼び出すように &lt;code&gt;server&lt;/code&gt; 関数を記述し、ループを作成する方法に注意してください。 Erlangコンパイラーは「賢い」ものであり、コードを最適化するため、これは一種のループであり、適切な関数呼び出しではありません。しかし、これは呼び出しの後にコードがない場合にのみ機能します。それ以外の場合、コンパイラーは呼び出しが戻り、適切な関数呼び出しを行うことを期待します。これにより、ループごとにプロセスがどんどん大きくなります。</target>
        </trans-unit>
        <trans-unit id="5b3e78ade17b6e0804c28534fc7f4b91db6f6042" translate="yes" xml:space="preserve">
          <source>Notice in the second example that the duplicate name only occurs once in the returned list, and that the list is in alphabetical order regardless of where the names are positioned in the regular expression. The order of the names is the same as the order of captured subexpressions if &lt;code&gt;{capture, all_names}&lt;/code&gt; is specified as an option to &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt;. You can therefore create a name-to-value mapping from the result of &lt;code&gt;run/3&lt;/code&gt; like this:</source>
          <target state="translated">2番目の例では、返されたリストで名前の重複が1回だけ発生し、名前が正規表現のどこに配置されているかに関係なく、リストがアルファベット順になっていることに注意してください。 &lt;code&gt;{capture, all_names}&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; のオプションとして指定されている場合、名前の順序は、キャプチャされた部分式の順序と同じです。したがって、次のように &lt;code&gt;run/3&lt;/code&gt; の結果から名前から値へのマッピングを作成できます。</target>
        </trans-unit>
        <trans-unit id="686ddcda1c61a1ea244a057dd0d0172fe3f99230" translate="yes" xml:space="preserve">
          <source>Notice on line 16 that 5 inches is converted to centimeters and back again and reassuringly get back to the original value. That is, the argument to a function can be the result of another function. Consider how line 16 (above) works. The argument given to the function &lt;code&gt;{inch,5}&lt;/code&gt; is first matched against the first head clause of &lt;code&gt;convert_length&lt;/code&gt;, that is, &lt;code&gt;convert_length({centimeter,X})&lt;/code&gt;. It can be seen that &lt;code&gt;{centimeter,X}&lt;/code&gt; does not match &lt;code&gt;{inch,5}&lt;/code&gt; (the head is the bit before the &quot;-&amp;gt;&quot;). This having failed, let us try the head of the next clause that is, &lt;code&gt;convert_length({inch,Y})&lt;/code&gt;. This matches, and &lt;code&gt;Y&lt;/code&gt; gets the value 5.</source>
          <target state="translated">16行目で、5インチがセンチメートルに変換されて再び元に戻り、元の値に確実に戻っていることに注意してください。つまり、関数の引数は別の関数の結果である可能性があります。 16行目（上記）の動作を考えてみましょう。関数 &lt;code&gt;{inch,5}&lt;/code&gt; 指定された引数は、最初に &lt;code&gt;convert_length&lt;/code&gt; の最初のヘッド句、つまり、 &lt;code&gt;convert_length({centimeter,X})&lt;/code&gt; と照合されます。それことがわかる &lt;code&gt;{centimeter,X}&lt;/code&gt; 一致しない &lt;code&gt;{inch,5}&lt;/code&gt; （「 - &amp;gt;」頭が少し前です）。これが失敗したので、次の節の先頭である &lt;code&gt;convert_length({inch,Y})&lt;/code&gt; 試してみましょう。これは一致し、 &lt;code&gt;Y&lt;/code&gt; は値5を取得します。</target>
        </trans-unit>
        <trans-unit id="faf1518cd916f83fdab368cf16163b784374daaa" translate="yes" xml:space="preserve">
          <source>Notice that &quot;&lt;code&gt;B=&amp;lt;&amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt;&quot; will be interpreted as &quot;&lt;code&gt;B =&amp;lt; &amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt;&quot;, which is a syntax error. The correct way to write the expression is: &lt;code&gt;B = &amp;lt;&amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">通知その&quot; &lt;code&gt;B=&amp;lt;&amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt; &quot; &quot;として解釈される &lt;code&gt;B =&amp;lt; &amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt; 構文エラーです&quot;。式を記述する正しい方法は、 &lt;code&gt;B = &amp;lt;&amp;lt;1&amp;gt;&amp;gt;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="4e48d2b215215558347b575f3ecbab79091a73b6" translate="yes" xml:space="preserve">
          <source>Notice that (*COMMIT) at the start of a pattern is not the same as an anchor, unless the PCRE start-of-match optimizations are turned off, as shown in the following example:</source>
          <target state="translated">以下の例のように、PCREのマッチ開始最適化がオフになっていない限り、パターンの開始時の(*COMMIT)はアンカーと同じではないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="7645c19f8cada682b7b2ac8e343c6026994bf018" translate="yes" xml:space="preserve">
          <source>Notice that (*SKIP:NAME) searches only for names set by (*MARK:NAME). It ignores names that are set by (*PRUNE:NAME) or (*THEN:NAME).</source>
          <target state="translated">(*SKIP:NAME)は、(*MARK:NAME)で設定された名前のみを検索することに注意してください。(*PRUNE:NAME)や(*THEN:NAME)で設定された名前は無視されます。</target>
        </trans-unit>
        <trans-unit id="ac772e9232c60fd05e436000b3d65e5ba73ff0bb" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt; file:read_link/1&lt;/code&gt; always returns an error if the link points to an invalid filename.</source>
          <target state="translated">リンクが無効なファイル名を指している場合、 &lt;code&gt; file:read_link/1&lt;/code&gt; は常にエラーを返すことに注意してください。</target>
        </trans-unit>
        <trans-unit id="3adcc07be0a21a37482a3bd3976227349972956b" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;-relaxed_command_check&lt;/code&gt; is specified when starting the daemon that is to accept killing when it has live nodes registered. When running &lt;code&gt;epmd&lt;/code&gt; interactively, &lt;code&gt;-relaxed_command_check&lt;/code&gt; has no effect. A daemon that is started without relaxed command checking must be killed using, for example, signals or some other OS-specific method if it has active clients registered.</source>
          <target state="translated">デーモンの起動時に &lt;code&gt;-relaxed_command_check&lt;/code&gt; が指定されていることに注意してください。デーモンは、ライブノードが登録されているときに強制終了を受け入れます。 &lt;code&gt;epmd&lt;/code&gt; を対話的に実行する場合、 &lt;code&gt;-relaxed_command_check&lt;/code&gt; は効果がありません。緩和されたコマンドチェックなしで起動されたデーモンは、アクティブなクライアントが登録されている場合は、シグナルやその他のOS固有の方法などを使用して強制終了する必要があります。</target>
        </trans-unit>
        <trans-unit id="70bfe90d5c883bf60d9637a901f3b97c4d3f704b" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;&lt;a href=&quot;erl_ext_dist#overall_format&quot;&gt;the version number is omitted from the terms that follow a distribution header &lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;erl_ext_dist#overall_format&quot;&gt;the version number is omitted from the terms that follow a distribution header &lt;/a&gt;&lt;/code&gt; 注意してください。</target>
        </trans-unit>
        <trans-unit id="147f5f00692828642c9cf73812c37af283058699" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;&lt;a href=&quot;erl_ext_dist#overall_format&quot;&gt;the version number is omitted from the terms that follow a distribution header&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;erl_ext_dist#overall_format&quot;&gt;the version number is omitted from the terms that follow a distribution header&lt;/a&gt;&lt;/code&gt; 注意してください。</target>
        </trans-unit>
        <trans-unit id="8218b491a4b3c0c5eb8370427f8e63bc8b619227" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;ActiveSuspendCount&lt;/code&gt; and &lt;code&gt;OutstandingSuspendCount&lt;/code&gt; are not the total suspend count on &lt;code&gt;Suspendee&lt;/code&gt;, only the parts contributed by &lt;code&gt;Pid&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ActiveSuspendCount&lt;/code&gt; と &lt;code&gt;OutstandingSuspendCount&lt;/code&gt; は &lt;code&gt;Suspendee&lt;/code&gt; の合計サスペンドカウントではなく、 &lt;code&gt;Pid&lt;/code&gt; によって提供された部分のみであることに注意してください。</target>
        </trans-unit>
        <trans-unit id="5cd2f7d7216ad16040d03dfe0cd8ffeaa41f5fc9" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;ErlNifBinary&lt;/code&gt; is a semi-opaque type and you are only allowed to read fields &lt;code&gt;size&lt;/code&gt; and &lt;code&gt;data&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ErlNifBinary&lt;/code&gt; は半透明のタイプであり、フィールドの &lt;code&gt;size&lt;/code&gt; と &lt;code&gt;data&lt;/code&gt; 読み取りのみが許可されていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="f6fa80e962aa12707d897541b088fcd511a7fff9" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;Filename&lt;/code&gt; can be either a list or a binary.</source>
          <target state="translated">&lt;code&gt;Filename&lt;/code&gt; はリストまたはバイナリのいずれかであることに注意してください。</target>
        </trans-unit>
        <trans-unit id="f14731d9c3c6fd3730587d810464f8a2d56ecc47" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;Tracee&lt;/code&gt; must refer to a process currently or previously existing on the same node as the caller of &lt;code&gt;erlang:trace_delivered(Tracee)&lt;/code&gt; resides on. The special &lt;code&gt;Tracee&lt;/code&gt; atom &lt;code&gt;all&lt;/code&gt; denotes all processes that currently are traced in the node.</source>
          <target state="translated">&lt;code&gt;Tracee&lt;/code&gt; は、 &lt;code&gt;erlang:trace_delivered(Tracee)&lt;/code&gt; の呼び出し元が存在するのと同じノードに現在または以前に存在するプロセスを参照する必要があることに注意してください。特殊な &lt;code&gt;Tracee&lt;/code&gt; アトム &lt;code&gt;all&lt;/code&gt; は、現在ノードでトレースされているすべてのプロセスを示します。</target>
        </trans-unit>
        <trans-unit id="e39772795b303f493c5e1f6ecf427eea0b844a7b" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;[$\r,$\n]&lt;/code&gt; is one grapheme cluster according to the Unicode Standard.</source>
          <target state="translated">&lt;code&gt;[$\r,$\n]&lt;/code&gt; は、Unicode規格による1つの書記素クラスターであることに注意してください。</target>
        </trans-unit>
        <trans-unit id="6aa2d6619dffc8bd3c3adb06ec4c9073939311ad" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;[$\r,$\n]&lt;/code&gt; is one grapheme cluster.</source>
          <target state="translated">&lt;code&gt;[$\r,$\n]&lt;/code&gt; は1つの書記素クラスターであることに注意してください。</target>
        </trans-unit>
        <trans-unit id="08897008ae2f97db9924c5cfdccc065044d13435" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;bind_address&lt;/code&gt; must be the IP address reported by function &lt;code&gt;info&lt;/code&gt; and cannot be the hostname that is allowed when putting in &lt;code&gt;bind_address&lt;/code&gt;.</source>
          <target state="translated">ことに注意してください &lt;code&gt;bind_address&lt;/code&gt; IPアドレスでなければなりませんが、関数によって報告された &lt;code&gt;info&lt;/code&gt; とを入れたときに許可されているホスト名にすることはできません &lt;code&gt;bind_address&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b0c830556293b9a7bbf702aa85452de5ebbaf366" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;catch&lt;/code&gt; has low precedence and catch subexpressions often needs to be enclosed in a block expression or in parentheses:</source>
          <target state="translated">&lt;code&gt;catch&lt;/code&gt; は優先順位が低く、catchの部分式は多くの場合、ブロック式または括弧で囲む必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="bb283657c8b33fada586a3cb80cefd9a6fce3dd1" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;enif_open_resource_type&lt;/code&gt; is only allowed to be called in the two callbacks &lt;code&gt;&lt;a href=&quot;#load&quot;&gt;load&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#upgrade&quot;&gt;upgrade&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;enif_open_resource_type&lt;/code&gt; は、2つのコールバック &lt;code&gt;&lt;a href=&quot;#load&quot;&gt;load&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;#upgrade&quot;&gt;upgrade&lt;/a&gt;&lt;/code&gt; でのみ呼び出すことができることに注意してください。</target>
        </trans-unit>
        <trans-unit id="1773f52a457c6794f4a7d066fbfe3f05c2a765e3" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;erlsrv&lt;/code&gt; is not a general service utility for Windows, but designed for embedded Erlang systems.</source>
          <target state="translated">&lt;code&gt;erlsrv&lt;/code&gt; はWindows用の一般的なサービスユーティリティではなく、組み込みErlangシステム用に設計されていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="6e432f3e9c9e76ab03e11cf1eee130a983560aaa" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;file:read_link/1&lt;/code&gt; always returns an error if the link points to an invalid filename.</source>
          <target state="translated">リンクが無効なファイル名を指している場合、 &lt;code&gt;file:read_link/1&lt;/code&gt; は常にエラーを返すことに注意してください。</target>
        </trans-unit>
        <trans-unit id="2b5eb19b7b6106c9b1640932097ed40e803eee2b" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;level&lt;/code&gt; and &lt;code&gt;filters&lt;/code&gt; are obeyed by Logger itself before forwarding the log events to each handler, while &lt;code&gt;formatter&lt;/code&gt; and all handler specific options are left to the handler implementation.</source>
          <target state="translated">お知らせその &lt;code&gt;level&lt;/code&gt; や &lt;code&gt;filters&lt;/code&gt; 一方で、各ハンドラにログイベントを転送する前に、ロガー自体によって守られ &lt;code&gt;formatter&lt;/code&gt; 、すべてのハンドラ固有のオプションは、ハンドラ実装に委ねられています。</target>
        </trans-unit>
        <trans-unit id="dd581a406752603573ad8774cbe10adf7b5ab0d3" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;n3&lt;/code&gt; and &lt;code&gt;creation&lt;/code&gt; are limited in precision, so only the low 18 and 2 bits of these numbers are used.</source>
          <target state="translated">&lt;code&gt;n3&lt;/code&gt; と &lt;code&gt;creation&lt;/code&gt; は精度に制限があるため、これらの数値の下位18ビットと2ビットのみが使用されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="5034ccb8d85a6d7fd7e77e33c704f31bb33968e9" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;creation&lt;/code&gt; are limited in precision, so only the low 18 and 2 bits of these numbers are used.</source>
          <target state="translated">&lt;code&gt;number&lt;/code&gt; と &lt;code&gt;creation&lt;/code&gt; 精度には制限があるため、これらの数の下位18ビットと2ビットのみが使用されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="8f334a2a965ad63c5f73db11176f314492958179" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;relative_product([R1],&amp;nbsp;R2)&lt;/code&gt; is different from &lt;code&gt;relative_product(R1,&amp;nbsp;R2)&lt;/code&gt;; the list of one element is not identified with the element itself.</source>
          <target state="translated">&lt;code&gt;relative_product([R1],&amp;nbsp;R2)&lt;/code&gt; は &lt;code&gt;relative_product(R1,&amp;nbsp;R2)&lt;/code&gt; とは異なることに注意してください。1つの要素のリストは、要素自体では識別されません。</target>
        </trans-unit>
        <trans-unit id="d6bd7c1e7434d1dad6aeb762e0751cad3313447c" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;safe_fixtable/2&lt;/code&gt; is not necessary for table type &lt;code&gt;ordered_set&lt;/code&gt; and for traversals done by a single ETS function call, like &lt;code&gt;&lt;a href=&quot;#select-2&quot;&gt;select/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;safe_fixtable/2&lt;/code&gt; は、テーブルタイプ &lt;code&gt;ordered_set&lt;/code&gt; や、 &lt;code&gt;&lt;a href=&quot;#select-2&quot;&gt;select/2&lt;/a&gt;&lt;/code&gt; のような単一のETS関数呼び出しによって実行されるトラバーサルには必要ないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="3688c0644193c1e6416001dafdd6919064e11078" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;stdin&lt;/code&gt; and &lt;code&gt;stdout&lt;/code&gt; are for buffered input/output and must &lt;strong&gt;not&lt;/strong&gt; be used for the communication with Erlang.</source>
          <target state="translated">ことを通知 &lt;code&gt;stdin&lt;/code&gt; および &lt;code&gt;stdout&lt;/code&gt; バッファされた入力/出力のためのものとする必要があり&lt;strong&gt;ません&lt;/strong&gt;アーランとの通信に使用されます。</target>
        </trans-unit>
        <trans-unit id="bc49c747fe59c837c18160b1da219cb9bb69f688" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;tut9:test_if(33,33)&lt;/code&gt; does not cause any condition to succeed. This leads to the run time error &lt;code&gt;if_clause&lt;/code&gt;, here nicely formatted by the shell. See &lt;code&gt;Guard Sequences&lt;/code&gt; for details of the many guard tests available.</source>
          <target state="translated">&lt;code&gt;tut9:test_if(33,33)&lt;/code&gt; は条件を成功させないことに注意してください。これにより、ランタイムエラー &lt;code&gt;if_clause&lt;/code&gt; が発生します。ここでは、シェルによって適切にフォーマットされています。参照 &lt;code&gt;Guard Sequences&lt;/code&gt; 利用可能な多くのガードのテストの詳細については。</target>
        </trans-unit>
        <trans-unit id="d4a0e079c5d305d9ddb09850abdc7996b675aca1" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;{active, true}&lt;/code&gt; mode provides no flow control; a fast sender can easily overflow the receiver with incoming messages. The same is true for &lt;code&gt;{active, N}&lt;/code&gt; mode, while the message count is greater than zero.</source>
          <target state="translated">&lt;code&gt;{active, true}&lt;/code&gt; モードはフロー制御を提供しないことに注意してください。高速送信者は、受信メッセージで受信者を簡単にオーバーフローさせることができます。 &lt;code&gt;{active, N}&lt;/code&gt; モードについても同じことが言えますが、メッセージ数はゼロより大きいです。</target>
        </trans-unit>
        <trans-unit id="3d5d39b6d9eb6afa53058c47c7cffc48273fdd29" translate="yes" xml:space="preserve">
          <source>Notice that Logger automatically inserts a timestamp in the meta data unless it already exists. This function is exported for the rare case when the timestamp must be taken at a different point in time than when the log event is issued.</source>
          <target state="translated">Logger は、既に存在しない限り、自動的にタイムスタンプをメタ データに挿入することに注意してください。この関数は、ログ イベントが発行された時とは異なる時点でタイムスタンプを取得しなければならない稀なケースのためにエクスポートされます。</target>
        </trans-unit>
        <trans-unit id="1da54ccbef9166436330bfc6fd162fc86bc65127" translate="yes" xml:space="preserve">
          <source>Notice that Mnesia can be connected to other nodes than those returned in &lt;code&gt;ReturnValue&lt;/code&gt;.</source>
          <target state="translated">Mnesiaは &lt;code&gt;ReturnValue&lt;/code&gt; で返されるノード以外のノードに接続できることに注意してください。</target>
        </trans-unit>
        <trans-unit id="ca1604ae3c36200717b82378dacc675667bae387" translate="yes" xml:space="preserve">
          <source>Notice that USM users are needed for SNMPv3 configuration and are not to be confused with users.</source>
          <target state="translated">USMユーザーはSNMPv3設定に必要であり、ユーザーと混同しないように注意してください。</target>
        </trans-unit>
        <trans-unit id="2103331cf1bc333f91a2382aff0f9f89c72945ce" translate="yes" xml:space="preserve">
          <source>Notice that UTF-8 is &lt;strong&gt;not&lt;/strong&gt; compatible with bytewise representation for code points from 128 through 255, so an ISO Latin-1 bytewise representation is generally incompatible with UTF-8.</source>
          <target state="translated">UTF-8は128から255までのコードポイントのバイト単位の表現と互換性が&lt;strong&gt;ない&lt;/strong&gt;ため、ISO Latin-1バイト単位の表現は一般にUTF-8と互換性が&lt;strong&gt;ない&lt;/strong&gt;ことに注意してください。</target>
        </trans-unit>
        <trans-unit id="4a6c1827f210e0e7a2b7f47b6b3a1bd1a9af4a39" translate="yes" xml:space="preserve">
          <source>Notice that \g{...} (Perl syntax) and \g&amp;lt;...&amp;gt; (Oniguruma syntax) are &lt;strong&gt;not&lt;/strong&gt; synonymous. The former is a back reference; the latter is a subroutine call.</source>
          <target state="translated">\ g {...}（Perl構文）と\ g &amp;lt;...&amp;gt;（オニグルマ構文）は同義では&lt;strong&gt;ない&lt;/strong&gt;ことに注意してください。前者は後方参照です。後者はサブルーチン呼び出しです。</target>
        </trans-unit>
        <trans-unit id="8de6476a9a9e34e743ca7bda411e9e36e779275d" translate="yes" xml:space="preserve">
          <source>Notice that a &lt;code&gt;gen_server&lt;/code&gt; process does not trap exit signals automatically, this must be explicitly initiated in the callback module.</source>
          <target state="translated">&lt;code&gt;gen_server&lt;/code&gt; プロセスは終了シグナルを自動的にトラップしないことに注意してください。これは、コールバックモジュールで明示的に開始する必要があります。</target>
        </trans-unit>
        <trans-unit id="c8c968975fc7502f69e3fa5a0ebf2c3346e29c96" translate="yes" xml:space="preserve">
          <source>Notice that a &lt;code&gt;gen_statem&lt;/code&gt; does not trap exit signals automatically, this must be explicitly initiated in the callback module (by calling &lt;code&gt;process_flag(trap_exit, true)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gen_statem&lt;/code&gt; は終了信号を自動的にトラップしないことに注意してください。これは、コールバックモジュールで明示的に開始する必要があります（ &lt;code&gt;process_flag(trap_exit, true)&lt;/code&gt; 呼び出すことにより）。</target>
        </trans-unit>
        <trans-unit id="755428447f434586578dae042ae0cabd4f3e660d" translate="yes" xml:space="preserve">
          <source>Notice that a conditional subpattern is not considered as having two alternatives, as only one is ever used. That is, the | character in a conditional subpattern has a different meaning. Ignoring whitespace, consider:</source>
          <target state="translated">条件付きサブパターンは二つの選択肢があるとは考えられないことに注意してください。つまり、条件付きサブパターンの「|」の文字は異なる意味を持っています。空白を無視して考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="88df944878b2dfd57638c11c5f3a67b0b37ab5eb" translate="yes" xml:space="preserve">
          <source>Notice that a driver binary has an internal reference counter. This means that calling &lt;code&gt;driver_free_binary&lt;/code&gt;, it may not actually dispose of it. If it is sent to the emulator, it can be referenced there.</source>
          <target state="translated">ドライバーバイナリには内部参照カウンターがあることに注意してください。つまり、 &lt;code&gt;driver_free_binary&lt;/code&gt; を呼び出しても、実際には破棄されない可能性があります。エミュレータに送信すると、そこで参照できます。</target>
        </trans-unit>
        <trans-unit id="e57d3be6f96e69f222e396adc45b370579e57d1d" translate="yes" xml:space="preserve">
          <source>Notice that a faked CPU topology that does not reflect how the real CPU topology looks like is likely to decrease the performance of the runtime system.</source>
          <target state="translated">実際のCPUトポロジーがどのように見えるかを反映していないフェイクされたCPUトポロジーは、ランタイムシステムの性能を低下させる可能性が高いことに注意してください。</target>
        </trans-unit>
        <trans-unit id="760aec758f8e9eb253ec969db2ad5ac99a17c5c4" translate="yes" xml:space="preserve">
          <source>Notice that a possessive quantifier can be used with an entire group, for example:</source>
          <target state="translated">所有格量詞は、例えば、グループ全体で使用できることに注意してください。</target>
        </trans-unit>
        <trans-unit id="1bc519a5e1193bcfddf9bfba3de07bc1233b4abf" translate="yes" xml:space="preserve">
          <source>Notice that a runtime system using decentralized counter groups benefits from &lt;code&gt;&lt;a href=&quot;#+sbt&quot;&gt;binding schedulers to logical processors&lt;/a&gt;&lt;/code&gt;, as the groups are distributed better between schedulers with this option.</source>
          <target state="translated">分散型カウンターグループを使用するランタイムシステムは、このオプションを使用すると、スケジューラー間でグループがより適切に分散されるため、 &lt;code&gt;&lt;a href=&quot;#+sbt&quot;&gt;binding schedulers to logical processors&lt;/a&gt;&lt;/code&gt; メリットが得られることに注意してください。</target>
        </trans-unit>
        <trans-unit id="dbbbc01405d36730105f83c66e9de97063c42e08" translate="yes" xml:space="preserve">
          <source>Notice that a runtime system using shared reader groups benefits from &lt;code&gt;&lt;a href=&quot;#+sbt&quot;&gt;binding schedulers to logical processors&lt;/a&gt;&lt;/code&gt;, as the reader groups are distributed better between schedulers.</source>
          <target state="translated">共有リーダーグループを使用するランタイムシステムでは、リーダーグループがスケジューラー間でより適切に分散されるため、 &lt;code&gt;&lt;a href=&quot;#+sbt&quot;&gt;binding schedulers to logical processors&lt;/a&gt;&lt;/code&gt; メリットが得られます。</target>
        </trans-unit>
        <trans-unit id="b74f7fd747ff5bbe77c7879d54040bcdfa2b336e" translate="yes" xml:space="preserve">
          <source>Notice that a scheduler can also be busy even if the OS has scheduled out the scheduler thread.</source>
          <target state="translated">OSがスケジューラのスレッドをスケジューリングしていても、スケジューラがビジー状態になることがあることに注意してください。</target>
        </trans-unit>
        <trans-unit id="1fb44615a33547638a4835f2bb25ba9f7f738524" translate="yes" xml:space="preserve">
          <source>Notice that all child processes implemented using the standard OTP behavior modules automatically adhere to the shutdown protocol.</source>
          <target state="translated">標準のOTPビヘイビアモジュールを使用して実装されたすべての子プロセスは、自動的にシャットダウンプロトコルを遵守することに注意してください。</target>
        </trans-unit>
        <trans-unit id="022007469674875a658f3171e3ee5f06bc52c5ff" translate="yes" xml:space="preserve">
          <source>Notice that all eight levels can occur in the heading, not only &lt;code&gt;ERROR&lt;/code&gt;, &lt;code&gt;WARNING&lt;/code&gt; or &lt;code&gt;INFO&lt;/code&gt; as &lt;code&gt;&lt;a href=&quot;error_logger&quot;&gt;error_logger&lt;/a&gt;&lt;/code&gt; produces. And microseconds are added at the end of the timestamp.</source>
          <target state="translated">すべての8つのレベルは、見出しだけでなく発生する可能性があることに注意してください &lt;code&gt;ERROR&lt;/code&gt; 、 &lt;code&gt;WARNING&lt;/code&gt; または &lt;code&gt;INFO&lt;/code&gt; を通り &lt;code&gt;&lt;a href=&quot;error_logger&quot;&gt;error_logger&lt;/a&gt;&lt;/code&gt; が生成されます。タイムスタンプの最後にマイクロ秒が追加されます。</target>
        </trans-unit>
        <trans-unit id="a99f104a56eef6a6e79ebf5f27128ede71470917" translate="yes" xml:space="preserve">
          <source>Notice that all records in the last fragment must be moved to another fragment, as the entire fragment is deleted.</source>
          <target state="translated">最後のフラグメント内のすべてのレコードは、フラグメント全体が削除されるため、別のフラグメントに移動しなければならないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="43d4ab77c71efe5ed63400db11c28f943feb8544" translate="yes" xml:space="preserve">
          <source>Notice that all the output is received on gollum. This is because the I/O system finds out where the process is spawned from and sends all output there.</source>
          <target state="translated">すべての出力が gollum 上で受信されていることに注目してください。これは、I/Oシステムがプロセスがどこからスポーンされたかを見つけ出し、そこにすべての出力を送るからです。</target>
        </trans-unit>
        <trans-unit id="b1caf8d4d97365e6e7817ea835b055cfc59c2108" translate="yes" xml:space="preserve">
          <source>Notice that although a user has requested schedulers to be bound, they can silently have failed to bind. To inspect the scheduler bindings, call &lt;code&gt;&lt;a href=&quot;#system_info_scheduler_bindings&quot;&gt; erlang:system_info(scheduler_bindings)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ユーザーがスケジューラーのバインドを要求したにもかかわらず、サイレントにバインドに失敗した可能性があることに注意してください。スケジューラーのバインディングを検査するには、 &lt;code&gt;&lt;a href=&quot;#system_info_scheduler_bindings&quot;&gt; erlang:system_info(scheduler_bindings)&lt;/a&gt;&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="afcf6c07d5d0261b9d60900ac2418148455d55af" translate="yes" xml:space="preserve">
          <source>Notice that although a user has requested schedulers to be bound, they can silently have failed to bind. To inspect the scheduler bindings, call &lt;code&gt;&lt;a href=&quot;#system_info_scheduler_bindings&quot;&gt;erlang:system_info(scheduler_bindings)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ユーザーがスケジューラをバインドするように要求しましたが、バインドに失敗した可能性があることに注意してください。スケジューラーのバインディングを検査するには、 &lt;code&gt;&lt;a href=&quot;#system_info_scheduler_bindings&quot;&gt;erlang:system_info(scheduler_bindings)&lt;/a&gt;&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="a5737b0ee42e7396b1279449506400af6d4d0399" translate="yes" xml:space="preserve">
          <source>Notice that although the keyword &lt;code&gt;catch&lt;/code&gt; is used in the &lt;code&gt;try&lt;/code&gt; expression, there is not a &lt;code&gt;catch&lt;/code&gt; expression within the &lt;code&gt;try&lt;/code&gt; expression.</source>
          <target state="translated">キーワード &lt;code&gt;catch&lt;/code&gt; は &lt;code&gt;try&lt;/code&gt; 式で使用されていますが、try式内には &lt;code&gt;catch&lt;/code&gt; 式がないことに注意して &lt;code&gt;try&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="994f867c355c6f90c5d005f5efe72e6205d3566f" translate="yes" xml:space="preserve">
          <source>Notice that an application can always be stopped explicitly by calling &lt;code&gt;stop/1&lt;/code&gt;. Regardless of the type of the application, no other applications are affected.</source>
          <target state="translated">&lt;code&gt;stop/1&lt;/code&gt; を呼び出すことにより、アプリケーションを常に明示的に停止できることに注意してください。アプリケーションのタイプに関係なく、他のアプリケーションは影響を受けません。</target>
        </trans-unit>
        <trans-unit id="da2ab21694a90b36239b6620bd78657b3c952a69" translate="yes" xml:space="preserve">
          <source>Notice that an event manager &lt;strong&gt;does&lt;/strong&gt; trap exit signals automatically.</source>
          <target state="translated">イベントマネージャ&lt;strong&gt;が&lt;/strong&gt;終了信号を自動的にトラップすることに注意してください。</target>
        </trans-unit>
        <trans-unit id="49dfb54eadef728066f7af6aab3f97cecf7b3fb1" translate="yes" xml:space="preserve">
          <source>Notice that an exiting port exists, but is not open.</source>
          <target state="translated">出口となるポートは存在するが、開いていないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="e9791862f66b81843f5294813c5a3786cc4d5cd0" translate="yes" xml:space="preserve">
          <source>Notice that an exiting process exists, but is not alive. That is, &lt;code&gt;is_process_alive/1&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt; for an exiting process, but its process identifier is part of the result returned from &lt;code&gt;processes/0&lt;/code&gt;.</source>
          <target state="translated">存在するプロセスは存在するが、生きていないことに注意してください。つまり、 &lt;code&gt;is_process_alive/1&lt;/code&gt; は既存のプロセスに対して &lt;code&gt;false&lt;/code&gt; を返しますが、そのプロセス識別子は &lt;code&gt;processes/0&lt;/code&gt; から返される結果の一部です。</target>
        </trans-unit>
        <trans-unit id="e30baa54b514ae9385a376058a73878724a1d09c" translate="yes" xml:space="preserve">
          <source>Notice that any modifying operations, that is, &lt;code&gt;mnesia:write&lt;/code&gt; or &lt;code&gt;mnesia:delete&lt;/code&gt;, that are done between the &lt;code&gt;mnesia:select/4&lt;/code&gt; and &lt;code&gt;mnesia:select/1&lt;/code&gt; calls are not visible in the result.</source>
          <target state="translated">&lt;code&gt;mnesia:select/4&lt;/code&gt; と &lt;code&gt;mnesia:select/1&lt;/code&gt; の呼び出しの間に行われた変更操作、つまり &lt;code&gt;mnesia:write&lt;/code&gt; または &lt;code&gt;mnesia:delete&lt;/code&gt; は結果に表示されないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="96c91a61c3b4aa6acc5afde73b1f0c373cd23ed1" translate="yes" xml:space="preserve">
          <source>Notice that any process can close a port using &lt;code&gt;Port ! {PortOwner, close}&lt;/code&gt; as if it itself was the port owner, but the reply always goes to the port owner.</source>
          <target state="translated">どのプロセスでも &lt;code&gt;Port ! {PortOwner, close}&lt;/code&gt; を使用してポートを閉じることができることに注意してください。{PortOwner、close}それ自体がポート所有者であるかのように動作しますが、応答は常にポート所有者に送信されます。</target>
        </trans-unit>
        <trans-unit id="d4cc8e9c5e1271318aa4ada63b47a96351832036" translate="yes" xml:space="preserve">
          <source>Notice that any process can send to a port using &lt;code&gt;Port ! {PortOwner, {command, Data}}&lt;/code&gt; as if it itself was the port owner.</source>
          <target state="translated">どのプロセスも &lt;code&gt;Port ! {PortOwner, {command, Data}}&lt;/code&gt; を使用してポートに送信できることに注意してください。{PortOwner、{command、Data}}それ自体がポート所有者であるかのように。</target>
        </trans-unit>
        <trans-unit id="1824595a1c80b7075f5376bc1cd1c936c8d424db" translate="yes" xml:space="preserve">
          <source>Notice that any process can set the port owner using &lt;code&gt;Port ! {PortOwner, {connect, Pid}}&lt;/code&gt; as if it itself was the port owner, but the reply always goes to the port owner.</source>
          <target state="translated">どのプロセスでも &lt;code&gt;Port ! {PortOwner, {connect, Pid}}&lt;/code&gt; を使用してポート所有者を設定できることに注意してください。{PortOwner、{connect、Pid}}それ自体がポート所有者であるかのように動作しますが、応答は常にポート所有者に送信されます。</target>
        </trans-unit>
        <trans-unit id="a98b3f3c42ef6f33bfe8a7e8fccfe1473542b5f7" translate="yes" xml:space="preserve">
          <source>Notice that any tuple stored in the table must have at least &lt;code&gt;Pos&lt;/code&gt; number of elements.</source>
          <target state="translated">テーブルに格納されているタプルには、少なくとも &lt;code&gt;Pos&lt;/code&gt; 個の要素が必要です。</target>
        </trans-unit>
        <trans-unit id="dd5de2485d7d394ae933d91e2e848ae72df0affa" translate="yes" xml:space="preserve">
          <source>Notice that as a driver binary is shared by the driver and the emulator. A binary received from the emulator or sent to the emulator must not be changed by the driver.</source>
          <target state="translated">ドライバとしてのバイナリは、ドライバとエミュレータで共有されていることに注意してください。エミュレータから受信したバイナリやエミュレータに送られたバイナリは、ドライバによって変更されてはいけません。</target>
        </trans-unit>
        <trans-unit id="f889fc9740aed7e3095d419001ad1fb0ce64b212" translate="yes" xml:space="preserve">
          <source>Notice that as this is &lt;code&gt;server_transfer/5&lt;/code&gt;, it is not the same as the previous function &lt;code&gt;server_transfer/4&lt;/code&gt;. Another &lt;code&gt;keysearch&lt;/code&gt; is done on &lt;code&gt;User_List&lt;/code&gt; to find the pid of the client corresponding to fred:</source>
          <target state="translated">これは &lt;code&gt;server_transfer/5&lt;/code&gt; であるため、前の関数 &lt;code&gt;server_transfer/4&lt;/code&gt; と同じではないことに注意してください。 &lt;code&gt;keysearch&lt;/code&gt; で別のキー検索を &lt;code&gt;User_List&lt;/code&gt; して、fredに対応するクライアントのpidを見つけます。</target>
        </trans-unit>
        <trans-unit id="8fe86ce5fa59a3562a829573aaf5b3dfd2379e17" translate="yes" xml:space="preserve">
          <source>Notice that bit string patterns cannot be nested.</source>
          <target state="translated">ビット文字列パターンは入れ子にできないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="aa80432fca6a469445d85d7dfaebe88b1a98b7f2" translate="yes" xml:space="preserve">
          <source>Notice that by passing the &lt;code&gt;positive&lt;/code&gt; modifier you will get heap allocated integers (bignums) quicker.</source>
          <target state="translated">&lt;code&gt;positive&lt;/code&gt; 修飾子を渡すことにより、ヒープに割り当てられた整数（bignum）をより速く取得できることに注意してください。</target>
        </trans-unit>
        <trans-unit id="6a919935e37a99f7e411ad64d7426c9cc07d3818" translate="yes" xml:space="preserve">
          <source>Notice that calling (nesting) &lt;code&gt;mnesia:[a]sync_dirty&lt;/code&gt; inside a transaction-context inherits the transaction semantics.</source>
          <target state="translated">トランザクションコンテキスト内で &lt;code&gt;mnesia:[a]sync_dirty&lt;/code&gt; を呼び出す（ネストする）と、トランザクションセマンティクスが継承されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="28de43964f8d0b0f5ebe0eeea1c37e096ff9f1e4" translate="yes" xml:space="preserve">
          <source>Notice that calling (nesting) a &lt;code&gt;mnesia:ets&lt;/code&gt; inside a transaction-context inherits the transaction semantics.</source>
          <target state="translated">トランザクションコンテキスト内で &lt;code&gt;mnesia:ets&lt;/code&gt; を呼び出す（入れ子にする）と、トランザクションセマンティクスが継承されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="ccdf30109e045224354b9a92051a3710e7da0269" translate="yes" xml:space="preserve">
          <source>Notice that calling &lt;code&gt;complex2:foo/1&lt;/code&gt; and &lt;code&gt;complex2:bar/1&lt;/code&gt; results in the tuple &lt;code&gt;{foo,X}&lt;/code&gt; or &lt;code&gt;{bar,Y}&lt;/code&gt; being sent to the &lt;code&gt;complex&lt;/code&gt; process, which codes them as binaries and sends them to the port. This means that the C program must be able to handle these two tuples.</source>
          <target state="translated">&lt;code&gt;complex2:foo/1&lt;/code&gt; および &lt;code&gt;complex2:bar/1&lt;/code&gt; を呼び出すと、タプル &lt;code&gt;{foo,X}&lt;/code&gt; または &lt;code&gt;{bar,Y}&lt;/code&gt; が &lt;code&gt;complex&lt;/code&gt; プロセスに送信され、バイナリとしてコード化してポートに送信することに注意してください。これは、Cプログラムがこれら2つのタプルを処理できる必要があることを意味します。</target>
        </trans-unit>
        <trans-unit id="76111f96a154ca2aa3dcd82c9fbe77397be7146e" translate="yes" xml:space="preserve">
          <source>Notice that calling this function when supervising many children under low memory conditions can cause an out of memory exception.</source>
          <target state="translated">低メモリ状態で多数の子プロセスを監督しているときにこの関数を呼び出すと、メモリ切れの例外が発生することに注意してください。</target>
        </trans-unit>
        <trans-unit id="f66f156315ef693448711da956208a1b9d370baa" translate="yes" xml:space="preserve">
          <source>Notice that calling this function when supervising many childrens under low memory conditions can cause an out of memory exception.</source>
          <target state="translated">メモリ不足の状態で多くの子供を監督しているときにこの関数を呼び出すと、メモリ切れの例外が発生することに注意してください。</target>
        </trans-unit>
        <trans-unit id="36d8020652ba123cb254176a43a2c994dabfe6c7" translate="yes" xml:space="preserve">
          <source>Notice that chunked encoding can add headers so that there are more headers in the &lt;code&gt;stream_end&lt;/code&gt; message than in &lt;code&gt;stream_start&lt;/code&gt;. When streaming to a file and the request is asynchronous, the message &lt;code&gt;{http, {RequestId, saved_to_file}}&lt;/code&gt; is sent.</source>
          <target state="translated">チャンクエンコーディングはヘッダーを追加できるため、 &lt;code&gt;stream_start&lt;/code&gt; メッセージよりも &lt;code&gt;stream_end&lt;/code&gt; メッセージに多くのヘッダーがあることに注意してください。ファイルにストリーミングし、リクエストが非同期の場合、メッセージ &lt;code&gt;{http, {RequestId, saved_to_file}}&lt;/code&gt; が送信されます。</target>
        </trans-unit>
        <trans-unit id="8eacfb231646f67a84dd48c38b3252b46ba678d6" translate="yes" xml:space="preserve">
          <source>Notice that currently &lt;code&gt;ordered_set&lt;/code&gt; is not supported for &lt;code&gt;disc_only_copies&lt;/code&gt; tables.</source>
          <target state="translated">現在、 &lt;code&gt;ordered_set&lt;/code&gt; は &lt;code&gt;disc_only_copies&lt;/code&gt; テーブルではサポートされていないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="b6f86d7c1e62cac7ff19af2ed505338d552e40c3" translate="yes" xml:space="preserve">
          <source>Notice that currently &lt;code&gt;ordered_set&lt;/code&gt; is not supported for &lt;code&gt;disc_only_copies&lt;/code&gt;.</source>
          <target state="translated">現在、 &lt;code&gt;ordered_set&lt;/code&gt; はdisc_only_copiesではサポートされていないことに注意して &lt;code&gt;disc_only_copies&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c1ba106fc749c03f0e8e929a856488e3fe0469ca" translate="yes" xml:space="preserve">
          <source>Notice that default option &lt;code&gt;{active, true}&lt;/code&gt; cannot be changed, for internal reasons.</source>
          <target state="translated">内部的な理由により、デフォルトのオプション &lt;code&gt;{active, true}&lt;/code&gt; は変更できないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="61f3baddeb0657db3f04655dfe751683be5006f5" translate="yes" xml:space="preserve">
          <source>Notice that deleted objects are not freed from a fixed table until it has been released. If a process fixes a table but never releases it, the memory used by the deleted objects is never freed. The performance of operations on the table also degrades significantly.</source>
          <target state="translated">削除されたオブジェクトは、固定されたテーブルが解放されるまで解放されないことに注意してください。プロセスがテーブルを固定しても解放されない場合、削除されたオブジェクトが使用するメモリは解放されません。テーブルに対する操作のパフォーマンスも大きく低下します。</target>
        </trans-unit>
        <trans-unit id="f9c5bb258ea4f52af5df09054ae473cf25538fc1" translate="yes" xml:space="preserve">
          <source>Notice that distribution sockets disable the use of &lt;code&gt;high_msgq_watermark&lt;/code&gt; and &lt;code&gt;low_msgq_watermark&lt;/code&gt;. Instead they use the &lt;code&gt;distribution buffer busy limit&lt;/code&gt;, which is a similar feature.</source>
          <target state="translated">配布ソケットは、 &lt;code&gt;high_msgq_watermark&lt;/code&gt; および &lt;code&gt;low_msgq_watermark&lt;/code&gt; の使用を無効にすることに注意してください。代わりに、同様の機能である &lt;code&gt;distribution buffer busy limit&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="8e359baa81f7be3463d30d7e81f74f0d6daa7f44" translate="yes" xml:space="preserve">
          <source>Notice that distribution sockets disable the use of &lt;code&gt;high_msgq_watermark&lt;/code&gt; and &lt;code&gt;low_msgq_watermark&lt;/code&gt;. Instead use the &lt;code&gt;distribution buffer busy limit&lt;/code&gt;, which is a similar feature.</source>
          <target state="translated">配布ソケットは、 &lt;code&gt;high_msgq_watermark&lt;/code&gt; および &lt;code&gt;low_msgq_watermark&lt;/code&gt; の使用を無効にすることに注意してください。代わりに、同様の機能である &lt;code&gt;distribution buffer busy limit&lt;/code&gt; 使用します。</target>
        </trans-unit>
        <trans-unit id="8d5e701c93b303b29d937ac4bace336c512ed95b" translate="yes" xml:space="preserve">
          <source>Notice that each of the assertions is applied independently at the same point in the subject string. First there is a check that the previous three characters are all digits, and then there is a check that the same three characters are not &quot;999&quot;. This pattern does &lt;strong&gt;not&lt;/strong&gt; match &quot;foo&quot; preceded by six characters, the first of which are digits and the last three of which are not &quot;999&quot;. For example, it does not match &quot;123abcfoo&quot;. A pattern to do that is the following:</source>
          <target state="translated">各アサーションは、サブジェクト文字列の同じポイントで個別に適用されることに注意してください。まず、前の3文字がすべて数字であるかどうかのチェックがあり、次に同じ3文字が「999」でないことをチェックします。このパターンは、先頭に6文字が続く「foo」と一致しませ&lt;strong&gt;ん。&lt;/strong&gt;最初の文字は数字で、最後の3文字は「999」ではありません。たとえば、「123abcfoo」とは一致しません。これを行うパターンは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="5779934da069d89a75c4be1d8cdff80ec5c00bf4" translate="yes" xml:space="preserve">
          <source>Notice that emptying the call stack means that any surrounding &lt;code&gt;catch&lt;/code&gt; is removed and must be re-inserted after hibernation. One effect of this is that processes started using &lt;code&gt;proc_lib&lt;/code&gt; (also indirectly, such as &lt;code&gt;gen_server&lt;/code&gt; processes), are to use &lt;code&gt; proc_lib:hibernate/3&lt;/code&gt; instead, to ensure that the exception handler continues to work when the process wakes up.</source>
          <target state="translated">コールスタックを空にすると、周囲の &lt;code&gt;catch&lt;/code&gt; が削除され、休止状態の後に再挿入する必要があることに注意してください。この効果の1つは、 &lt;code&gt;proc_lib&lt;/code&gt; の使用を開始したプロセス（ &lt;code&gt;gen_server&lt;/code&gt; プロセスなどの間接的なプロセス）が代わりに &lt;code&gt; proc_lib:hibernate/3&lt;/code&gt; を使用して、プロセスがウェイクアップしたときに例外ハンドラーが引き続き機能するようにすることです。</target>
        </trans-unit>
        <trans-unit id="c5c69517c533a13ffb06612150fd12d6557f1bab" translate="yes" xml:space="preserve">
          <source>Notice that emptying the call stack means that any surrounding &lt;code&gt;catch&lt;/code&gt; is removed and must be re-inserted after hibernation. One effect of this is that processes started using &lt;code&gt;proc_lib&lt;/code&gt; (also indirectly, such as &lt;code&gt;gen_server&lt;/code&gt; processes), are to use &lt;code&gt;proc_lib:hibernate/3&lt;/code&gt; instead, to ensure that the exception handler continues to work when the process wakes up.</source>
          <target state="translated">呼び出しスタックを空にすると、周囲の &lt;code&gt;catch&lt;/code&gt; がすべて削除され、休止後に再挿入する必要があることに注意してください。この1つの効果は、 &lt;code&gt;proc_lib&lt;/code&gt; を使用して開始されたプロセス（ &lt;code&gt;gen_server&lt;/code&gt; プロセスなど）が代わりに &lt;code&gt;proc_lib:hibernate/3&lt;/code&gt; を使用して、プロセスが起動したときに例外ハンドラーが引き続き機能することを保証することです。</target>
        </trans-unit>
        <trans-unit id="c5a1bb27af980314db81c1b30e32509a27fc50e5" translate="yes" xml:space="preserve">
          <source>Notice that error handling is omitted from the code:</source>
          <target state="translated">エラー処理が省略されていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="ac90f95ed355ecf5e134f5c94815fdaaf2216766" translate="yes" xml:space="preserve">
          <source>Notice that every guard test has the same source form as some expression, and is represented in the same way as the corresponding expression.</source>
          <target state="translated">すべてのガードテストは、いくつかの式と同じソースフォームを持ち、対応する式と同じ方法で表現されていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="12ac9f06be5d0c942954f11af7bd16a9c92f71af" translate="yes" xml:space="preserve">
          <source>Notice that every pattern has the same source form as some expression, and is represented in the same way as the corresponding expression.</source>
          <target state="translated">すべてのパターンは、いくつかの式と同じソース形式を持ち、対応する式と同じように表現されていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="1dafff17410c30a74873fbb0f049fd6b36e0dd69" translate="yes" xml:space="preserve">
          <source>Notice that for CTHs that are installed by means of the &lt;code&gt;&lt;a href=&quot;ct_suite#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt; function, &lt;code&gt;post_all/2&lt;/code&gt; is called before the &lt;code&gt;&lt;a href=&quot;#Module:init-2&quot;&gt;init/2&lt;/a&gt;&lt;/code&gt; hook function. However, for CTHs that are installed by means of the CT start flag, the &lt;code&gt;&lt;a href=&quot;#Module:init-2&quot;&gt;init/2&lt;/a&gt;&lt;/code&gt; function is called first.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ct_suite#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt; 関数を使用してインストールされた &lt;code&gt;post_all/2&lt;/code&gt; 場合、post_all / 2が &lt;code&gt;&lt;a href=&quot;#Module:init-2&quot;&gt;init/2&lt;/a&gt;&lt;/code&gt; フック関数の前に呼び出されることに注意してください。ただし、CT開始フラグを使用してインストールされたCTHの場合、 &lt;code&gt;&lt;a href=&quot;#Module:init-2&quot;&gt;init/2&lt;/a&gt;&lt;/code&gt; 関数が最初に呼び出されます。</target>
        </trans-unit>
        <trans-unit id="5d439f14c665f39e855a7716b502d1b790e81b7b" translate="yes" xml:space="preserve">
          <source>Notice that for CTHs that are installed by means of the &lt;code&gt;&lt;a href=&quot;ct_suite#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt; function, &lt;code&gt;post_groups/2&lt;/code&gt; is called before the &lt;code&gt;&lt;a href=&quot;#Module:init-2&quot;&gt;init/2&lt;/a&gt;&lt;/code&gt; hook function. However, for CTHs that are installed by means of the CT start flag, the &lt;code&gt;&lt;a href=&quot;#Module:init-2&quot;&gt;init/2&lt;/a&gt;&lt;/code&gt; function is called first.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ct_suite#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt; 関数を使用してインストールされた &lt;code&gt;post_groups/2&lt;/code&gt; 場合、post_groups / 2が &lt;code&gt;&lt;a href=&quot;#Module:init-2&quot;&gt;init/2&lt;/a&gt;&lt;/code&gt; フック関数の前に呼び出されることに注意してください。ただし、CT開始フラグを使用してインストールされたCTHの場合、 &lt;code&gt;&lt;a href=&quot;#Module:init-2&quot;&gt;init/2&lt;/a&gt;&lt;/code&gt; 関数が最初に呼び出されます。</target>
        </trans-unit>
        <trans-unit id="22d44122084b22fa6c5e4d72f866f1a0cdc53879" translate="yes" xml:space="preserve">
          <source>Notice that for SCTP sockets this function returns only one of the socket addresses. Function &lt;code&gt;&lt;a href=&quot;#socknames-1&quot;&gt;socknames/1,2&lt;/a&gt;&lt;/code&gt; returns all.</source>
          <target state="translated">SCTPソケットの場合、この関数は1つのソケットアドレスのみを返すことに注意してください。関数 &lt;code&gt;&lt;a href=&quot;#socknames-1&quot;&gt;socknames/1,2&lt;/a&gt;&lt;/code&gt; はすべてを返します。</target>
        </trans-unit>
        <trans-unit id="3eea76ec53bc50101ada93a2881a73a66d999f61" translate="yes" xml:space="preserve">
          <source>Notice that for SCTP sockets, this function returns only one of the peer addresses of the socket. Function &lt;code&gt;&lt;a href=&quot;#peernames-1&quot;&gt;peernames/1,2&lt;/a&gt;&lt;/code&gt; returns all.</source>
          <target state="translated">SCTPソケットの場合、この関数はソケットのピアアドレスの1つだけを返すことに注意してください。関数 &lt;code&gt;&lt;a href=&quot;#peernames-1&quot;&gt;peernames/1,2&lt;/a&gt;&lt;/code&gt; はすべてを返します。</target>
        </trans-unit>
        <trans-unit id="8b549a78c27b0039d4ff0cb9fa34e52e88f8ae6e" translate="yes" xml:space="preserve">
          <source>Notice that for any other reason than &lt;code&gt;normal&lt;/code&gt;, &lt;code&gt;shutdown&lt;/code&gt;, or &lt;code&gt;{shutdown,Term}&lt;/code&gt;, the &lt;code&gt;gen_server&lt;/code&gt; process is assumed to terminate because of an error and an error report is issued using &lt;code&gt;logger(3)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;normal&lt;/code&gt; 、 &lt;code&gt;shutdown&lt;/code&gt; 、または &lt;code&gt;{shutdown,Term}&lt;/code&gt; 以外の理由で、 &lt;code&gt;gen_server&lt;/code&gt; プロセスはエラーが原因で終了すると想定され、 &lt;code&gt;logger(3)&lt;/code&gt; を使用してエラーレポートが発行されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="0f2fde3695426d831d6f9a88359f21930dd08692" translate="yes" xml:space="preserve">
          <source>Notice that for any other reason than &lt;code&gt;normal&lt;/code&gt;, &lt;code&gt;shutdown&lt;/code&gt;, or &lt;code&gt;{shutdown,Term}&lt;/code&gt;, the &lt;code&gt;gen_statem&lt;/code&gt; is assumed to terminate because of an error and an error report is issued using &lt;code&gt;logger(3)&lt;/code&gt;.</source>
          <target state="translated">以外の理由という通知 &lt;code&gt;normal&lt;/code&gt; 、 &lt;code&gt;shutdown&lt;/code&gt; 、または &lt;code&gt;{shutdown,Term}&lt;/code&gt; 、 &lt;code&gt;gen_statem&lt;/code&gt; がエラーのために終了するものとすると、エラー報告を使用して発行された &lt;code&gt;logger(3)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d6c994ab42bf95f015c8131e40fece01289a1526" translate="yes" xml:space="preserve">
          <source>Notice that for best performance, &lt;code&gt;select&lt;/code&gt; is to be used before any modifying operations are done on that table in the same transaction. That is, do not use &lt;code&gt;mnesia:write&lt;/code&gt; or &lt;code&gt;mnesia:delete&lt;/code&gt; before a &lt;code&gt;mnesia:select&lt;/code&gt;. For efficiency, &lt;code&gt;NObjects&lt;/code&gt; is a recommendation only and the result can contain anything from an empty list to all available results.</source>
          <target state="translated">最良のパフォーマンスを得るには、同じトランザクションでそのテーブルに対して変更操作を行う前に、 &lt;code&gt;select&lt;/code&gt; を使用することに注意してください。つまり、 &lt;code&gt;mnesia:select&lt;/code&gt; の前に &lt;code&gt;mnesia:write&lt;/code&gt; または &lt;code&gt;mnesia:delete&lt;/code&gt; を使用しないでください。効率性のために、 &lt;code&gt;NObjects&lt;/code&gt; は推奨のみであり、結果には空のリストから使用可能なすべての結果までを含めることができます。</target>
        </trans-unit>
        <trans-unit id="575b65587388a5c28bf652744375022398c20ce2" translate="yes" xml:space="preserve">
          <source>Notice that for best performance, &lt;code&gt;select&lt;/code&gt; is to be used before any modifying operations are done on that table in the same transaction. That is, do not use &lt;code&gt;write&lt;/code&gt; or &lt;code&gt;delete&lt;/code&gt; before a &lt;code&gt;select&lt;/code&gt;.</source>
          <target state="translated">最良のパフォーマンスを得るには、同じトランザクションでそのテーブルに対して変更操作を行う前に、 &lt;code&gt;select&lt;/code&gt; を使用することに注意してください。つまり、 &lt;code&gt;select&lt;/code&gt; の前に &lt;code&gt;write&lt;/code&gt; または &lt;code&gt;delete&lt;/code&gt; を使用しないでください。</target>
        </trans-unit>
        <trans-unit id="a8e4ee50b8c86a9d97d28e810a76ef00e7ee22cf" translate="yes" xml:space="preserve">
          <source>Notice that for table type &lt;code&gt;ordered_set&lt;/code&gt;, &lt;code&gt;safe_fixtable/2&lt;/code&gt; is not necessary, as calls to &lt;code&gt;first/1&lt;/code&gt; and &lt;code&gt;next/2&lt;/code&gt; always succeed.</source>
          <target state="translated">テーブルタイプ &lt;code&gt;ordered_set&lt;/code&gt; の場合、 &lt;code&gt;first/1&lt;/code&gt; と &lt;code&gt;next/2&lt;/code&gt; への呼び出しは常に成功するため、 &lt;code&gt;safe_fixtable/2&lt;/code&gt; は不要です。</target>
        </trans-unit>
        <trans-unit id="fadf7fb473798e1c8fbe8d738e7d7fba94595b7d" translate="yes" xml:space="preserve">
          <source>Notice that for temporary children, the child specification is automatically deleted when the child terminates; thus, it is not possible to restart such children.</source>
          <target state="translated">一時的な子の場合、子の終了時に子の指定は自動的に削除されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="b8f8d69fc55404a3f5202b0589ebb12fa1fbadb2" translate="yes" xml:space="preserve">
          <source>Notice that function &lt;code&gt;&lt;a href=&quot;#casefold-1&quot;&gt;casefold/1&lt;/a&gt;&lt;/code&gt; should be used when converting a string to be tested for equality.</source>
          <target state="translated">等しいかどうかをテストする文字列を変換するときは、関数 &lt;code&gt;&lt;a href=&quot;#casefold-1&quot;&gt;casefold/1&lt;/a&gt;&lt;/code&gt; を使用する必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="405372cbb8689b7bb9d46fd60b33792430970cfc" translate="yes" xml:space="preserve">
          <source>Notice that function &lt;code&gt;&lt;a href=&quot;ttb#start_trace-4&quot;&gt;ttb:start_trace/4&lt;/a&gt;&lt;/code&gt; can be used as help as follows:</source>
          <target state="translated">関数 &lt;code&gt;&lt;a href=&quot;ttb#start_trace-4&quot;&gt;ttb:start_trace/4&lt;/a&gt;&lt;/code&gt; は、次のようにヘルプとして使用できることに注意してください。</target>
        </trans-unit>
        <trans-unit id="de0bcaa7532bb6bae36e73c3763ba087654d90d2" translate="yes" xml:space="preserve">
          <source>Notice that functions &lt;code&gt;chunk/2,3&lt;/code&gt;, &lt;code&gt;bchunk/2,3&lt;/code&gt;, and &lt;code&gt;chunk_step/3&lt;/code&gt; do not affect any value returned by &lt;code&gt;info/1&lt;/code&gt;.</source>
          <target state="translated">関数 &lt;code&gt;chunk/2,3&lt;/code&gt; 、 &lt;code&gt;bchunk/2,3&lt;/code&gt; 、および &lt;code&gt;chunk_step/3&lt;/code&gt; は、 &lt;code&gt;info/1&lt;/code&gt; によって返される値に影響を与えないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="da3a6b0a2ad8ae3b2ff383a08f0cdcfac8ef3282" translate="yes" xml:space="preserve">
          <source>Notice that if &lt;code&gt;init_per_suite&lt;/code&gt; and &lt;code&gt;end_per_suite&lt;/code&gt; do not exist in the suite, &lt;code&gt;Common Test&lt;/code&gt; calls dummy functions (with the same names) instead, so that output generated by hook functions can be saved to the log files for these dummies. For details, see &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#manipulating&quot;&gt;Common Test Hooks&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">お知らせ場合という &lt;code&gt;init_per_suite&lt;/code&gt; とは &lt;code&gt;end_per_suite&lt;/code&gt; スイートには存在しない、 &lt;code&gt;Common Test&lt;/code&gt; フック関数によって生成される出力はこれらのダミー用のログファイルに保存することができますので、代わりに（同じ名前の）ダミーの関数を呼び出します。詳細については、「 &lt;code&gt;&lt;a href=&quot;ct_hooks_chapter#manipulating&quot;&gt;Common Test Hooks&lt;/a&gt;&lt;/code&gt; 」を参照してください。</target>
        </trans-unit>
        <trans-unit id="aee52a26c1c7778ed0141e880006af8c079abe71" translate="yes" xml:space="preserve">
          <source>Notice that if &lt;code&gt;parallel_login&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, only one client at a time can be in the authentication phase.</source>
          <target state="translated">&lt;code&gt;parallel_login&lt;/code&gt; が &lt;code&gt;false&lt;/code&gt; の場合、一度に1つのクライアントのみが認証フェーズに入ることができることに注意してください。</target>
        </trans-unit>
        <trans-unit id="e2ae74861195afaaaecbb5004aa3195b54b0af5d" translate="yes" xml:space="preserve">
          <source>Notice that if a &quot;technically built in function&quot; (that is, a function not written in Erlang) is traced, the &lt;code&gt;caller&lt;/code&gt; function sometimes returns the atom &lt;code&gt;undefined&lt;/code&gt;. The calling Erlang function is not available during such calls.</source>
          <target state="translated">「技術的に組み込まれた関数」（つまり、Erlangで記述されていない関数）がトレースされると、 &lt;code&gt;caller&lt;/code&gt; 関数がアトム &lt;code&gt;undefined&lt;/code&gt; を返すことがあります。そのような呼び出しの間は、Erlang関数を呼び出すことはできません。</target>
        </trans-unit>
        <trans-unit id="f92e3c3fb0383592cf170b7659be5a996f925ab5" translate="yes" xml:space="preserve">
          <source>Notice that if changing the configuration of the handler in runtime, the &lt;code&gt;type&lt;/code&gt; parameter must not be modified.</source>
          <target state="translated">実行時にハンドラーの構成を変更する場合は、 &lt;code&gt;type&lt;/code&gt; パラメーターを変更しないでください。</target>
        </trans-unit>
        <trans-unit id="ce90066e3aad3459d75c1fb55cecaec28fe2794d" translate="yes" xml:space="preserve">
          <source>Notice that if changing the configuration of the handler in runtime, the &lt;code&gt;type&lt;/code&gt;, &lt;code&gt;file&lt;/code&gt;, or &lt;code&gt;modes&lt;/code&gt; parameters must not be modified.</source>
          <target state="translated">実行時にハンドラーの構成を変更する場合は、 &lt;code&gt;type&lt;/code&gt; 、 &lt;code&gt;file&lt;/code&gt; 、または &lt;code&gt;modes&lt;/code&gt; パラメーターを変更してはならないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="08ce68141a0a8640f5e5838bc1d59c39e01b55c0" translate="yes" xml:space="preserve">
          <source>Notice that if option &lt;code&gt;delayed_write&lt;/code&gt; was used when opening the file, &lt;code&gt;close/1&lt;/code&gt; can return an old write error and not even try to close the file. See &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ファイルを開くときにオプション &lt;code&gt;delayed_write&lt;/code&gt; が使用された場合、 &lt;code&gt;close/1&lt;/code&gt; は古い書き込みエラーを返し、ファイルを閉じようとしないこともあります。 &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="f698c6b4cd9ababf8d72ba0d6e493d5ad2e7229c" translate="yes" xml:space="preserve">
          <source>Notice that if the files &lt;code&gt;syslog.conf.ORIG&lt;/code&gt; and &lt;code&gt;syslog.conf.OTP&lt;/code&gt; are not in directory &lt;code&gt;/etc&lt;/code&gt;, the file path in the second and third command must be modified.</source>
          <target state="translated">&lt;code&gt;syslog.conf.ORIG&lt;/code&gt; および &lt;code&gt;syslog.conf.OTP&lt;/code&gt; ファイルがディレクトリ &lt;code&gt;/etc&lt;/code&gt; にない場合、2番目と3番目のコマンドのファイルパスを変更する必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="245b52374d4b97b1ff0d2029d95aaa06dad4396b" translate="yes" xml:space="preserve">
          <source>Notice that if the original property term is to be preserved in the result when expanded, it must be included in the expansion list. The inserted terms are not expanded recursively. If &lt;code&gt;Expansions&lt;/code&gt; contains more than one property with the same key, only the first occurrence is used.</source>
          <target state="translated">元のプロパティ項を展開したときに結果に保持される場合は、展開リストに含める必要があることに注意してください。挿入された用語は再帰的に展開されません。 &lt;code&gt;Expansions&lt;/code&gt; に同じキーを持つ複数のプロパティが含まれている場合、最初のオカレンスのみが使用されます。</target>
        </trans-unit>
        <trans-unit id="bc08705bf71174fc6daf6d3117f962a241235e84" translate="yes" xml:space="preserve">
          <source>Notice that if you restore to a non-empty registry, objects in the table overwrite objects in the registry with the same keys. Also, the &lt;strong&gt;entire&lt;/strong&gt; contents of the registry is marked as unmodified after the restore, including any modified objects that were not overwritten by the restore operation. This may not be your intention.</source>
          <target state="translated">空でないレジストリに復元すると、テーブル内のオブジェクトが同じキーを持つレジストリ内のオブジェクトを上書きすることに注意してください。また、復元操作によって上書きされなかった変更されたオブジェクトを含む、レジストリの内容&lt;strong&gt;全体&lt;/strong&gt;が復元後に変更されていないものとしてマークされます。これはあなたの意図ではないかもしれません。</target>
        </trans-unit>
        <trans-unit id="aef1c34d22b7f466e6132c1e85ef582f650007b8" translate="yes" xml:space="preserve">
          <source>Notice that if you store binary objects that are context-dependent (for example, containing pointers or open file descriptors), they lose their meaning if they are backed up to a &lt;code&gt;Mnesia&lt;/code&gt; table and later restored in a different context.</source>
          <target state="translated">コンテキスト依存のバイナリオブジェクト（たとえば、ポインタや開いているファイル記述子を含む）を格納する場合、それらが &lt;code&gt;Mnesia&lt;/code&gt; テーブルにバックアップされ、後で別のコンテキストで復元されると、意味が失われます。</target>
        </trans-unit>
        <trans-unit id="c04eebf0253a2b09b02af48ec92f831c4ed73813" translate="yes" xml:space="preserve">
          <source>Notice that ignoring the return value from this function would result in an &lt;strong&gt;unreliable&lt;/strong&gt; message passing, which is contradictory to the Erlang programming model. The message is &lt;strong&gt;not&lt;/strong&gt; sent if this function returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">この関数からの戻り値を無視すると、メッセージの受け渡しが&lt;strong&gt;不安定に&lt;/strong&gt;なり、Erlangプログラミングモデルとは矛盾することに注意してください。この関数が &lt;code&gt;false&lt;/code&gt; を返す場合、メッセージは送信され&lt;strong&gt;ません&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="8e0a7d0fec338c74c62f26d54f900722acf0e30d" translate="yes" xml:space="preserve">
          <source>Notice that in &lt;code&gt;ordered_set&lt;/code&gt; tables, the records are ordered per fragment, and the order is undefined in results returned by &lt;code&gt;select&lt;/code&gt; and &lt;code&gt;match_object&lt;/code&gt;, as well as &lt;code&gt;first&lt;/code&gt;, &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;prev&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ordered_set&lt;/code&gt; テーブルでは、レコードはフラグメントごとに並べられており、 &lt;code&gt;select&lt;/code&gt; と &lt;code&gt;match_object&lt;/code&gt; 、 &lt;code&gt;first&lt;/code&gt; 、 &lt;code&gt;next&lt;/code&gt; 、 &lt;code&gt;prev&lt;/code&gt; 、および &lt;code&gt;last&lt;/code&gt; によって返される結果では順序が定義されていないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="e87353c4be156a71ce7f89688b213b459834c505" translate="yes" xml:space="preserve">
          <source>Notice that in some cases, standard output of a command when called from another program (for example, &lt;code&gt;os:cmd/1&lt;/code&gt;) can differ, compared with the standard output of the command when called directly from an OS command shell.</source>
          <target state="translated">OSコマンドシェルから直接呼び出されたときのコマンドの標準出力と比較して、別のプログラム（ &lt;code&gt;os:cmd/1&lt;/code&gt; など）から呼び出されたときのコマンドの標準出力が異なる場合があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="3295423e0e8171c99eb1e9345ef25427a5a63801" translate="yes" xml:space="preserve">
          <source>Notice that in this unanchored example, the mark is retained from the match attempt that started at letter &quot;X&quot; in the subject. Subsequent match attempts starting at &quot;P&quot; and then with an empty string do not get as far as the (*MARK) item, nevertheless do not reset it.</source>
          <target state="translated">このアンカーなしの例では、件名の文字 &quot;X&quot; で始まったマッチ試行からマークが保持されていることに注意してください。P&quot; で始まり、空の文字列で始まるそれ以降の一致試行では、(*MARK)項目までは到達しませんが、それにもかかわらず、それはリセットされません。</target>
        </trans-unit>
        <trans-unit id="9cc48f18a5b25966f4b54af3d4aabec2ba6f3d99" translate="yes" xml:space="preserve">
          <source>Notice that it did not write &quot;hello&quot; three times and then &quot;goodbye&quot; three times. Instead, the first process wrote a &quot;hello&quot;, the second a &quot;goodbye&quot;, the first another &quot;hello&quot; and so forth. But where did the &amp;lt;0.63.0&amp;gt; come from? The return value of a function is the return value of the last &quot;thing&quot; in the function. The last thing in the function &lt;code&gt;start&lt;/code&gt; is</source>
          <target state="translated">「こんにちは」を3回書いておらず、「さようなら」を3回書いていないことに注意してください。代わりに、最初のプロセスは「hello」、2番目のプロセスは「さようなら」、最初のプロセスは「hello」などと書きました。しかし、&amp;lt;0.63.0&amp;gt;はどこから来たのですか？関数の戻り値は、関数の最後の「もの」の戻り値です。関数 &lt;code&gt;start&lt;/code&gt; の最後のものは</target>
        </trans-unit>
        <trans-unit id="cf4175703ac6e9fdbe15e5acca7f10693ec63c07" translate="yes" xml:space="preserve">
          <source>Notice that it is also required to expand the &lt;code&gt;-export&lt;/code&gt; line with the information that there is another function &lt;code&gt;mult&lt;/code&gt; with two arguments.</source>
          <target state="translated">&lt;code&gt;-export&lt;/code&gt; 行を拡張して、2つの引数を持つ別の関数 &lt;code&gt;mult&lt;/code&gt; があるという情報も必要になることに注意してください。</target>
        </trans-unit>
        <trans-unit id="a1a5ba2084c75a9789fb8664c66476603427348b" translate="yes" xml:space="preserve">
          <source>Notice that it is always the &lt;code&gt;merge_tests&lt;/code&gt; setting in the source specification that is used when joined with other specifications. Say, for example, that a source specification A, with tests TA1 and TA2, has &lt;code&gt;{merge_tests,false}&lt;/code&gt; set, and that it includes another specification, B, with tests TB1 and TB2, that has &lt;code&gt;{merge_tests,true}&lt;/code&gt; set. The result is that the test series &lt;code&gt;TA1,TA2,merge(TB1,TB2)&lt;/code&gt; is executed. The opposite &lt;code&gt;merge_tests&lt;/code&gt; settings would result in the test series &lt;code&gt;merge(merge(TA1,TA2),TB1,TB2)&lt;/code&gt;.</source>
          <target state="translated">他の仕様と結合するときに使用されるのは、常にソース仕様の &lt;code&gt;merge_tests&lt;/code&gt; 設定であることに注意してください。たとえば、テスト仕様TA1およびTA2を持つソース仕様Aに &lt;code&gt;{merge_tests,false}&lt;/code&gt; 設定されており、テスト仕様TB1およびTB2を持つ &lt;code&gt;{merge_tests,true}&lt;/code&gt; 設定された仕様Bが含まれているとします。その結果、一連のテスト &lt;code&gt;TA1,TA2,merge(TB1,TB2)&lt;/code&gt; が実行されます。逆の &lt;code&gt;merge_tests&lt;/code&gt; 設定は、テストシリーズ &lt;code&gt;merge(merge(TA1,TA2),TB1,TB2)&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="24bcac8813bad82252a8da44008063c6a9939ca8" translate="yes" xml:space="preserve">
          <source>Notice that it is more than ten times more efficient to read records dirty than within a transaction.</source>
          <target state="translated">トランザクション内よりも、汚れたレコードを読む方が10倍以上効率的であることに注目してください。</target>
        </trans-unit>
        <trans-unit id="5fc580601d400a238482271cf80a8768aa43f791" translate="yes" xml:space="preserve">
          <source>Notice that it is normally the set of auto-imported BIFs that are referred to when talking about 'BIFs'.</source>
          <target state="translated">BIFs」について話すときに参照されるのは、通常は自動インポートされたBIFのセットであることに注意してください。</target>
        </trans-unit>
        <trans-unit id="f48367941ecb417ce39721c36cb2f46ca431113b" translate="yes" xml:space="preserve">
          <source>Notice that it is up to the runtime system to determine if and how to use this information. Implementations on some platforms can use other means to determine consumed CPU time. Lengthy NIFs should regardless of this frequently call &lt;code&gt;enif_consume_timeslice&lt;/code&gt; to determine if it is allowed to continue execution.</source>
          <target state="translated">この情報を使用するかどうか、および使用する方法を決定するのはランタイムシステム次第であることに注意してください。一部のプラットフォームの実装では、他の手段を使用して、消費されたCPU時間を判別できます。長いNIFは、これに関係なく、 &lt;code&gt;enif_consume_timeslice&lt;/code&gt; を頻繁に呼び出して、実行の継続が許可されているかどうかを判断します。</target>
        </trans-unit>
        <trans-unit id="ab3955ab8e83d7f2bb7bc498f1bd619814955ca0" translate="yes" xml:space="preserve">
          <source>Notice that it is up to the runtime system to determine if and how to use this information. Implementations on some platforms can use other means to determine the consumed fraction of the time-slice. Lengthy driver callbacks should, regardless of this, frequently call this function to determine if it is allowed to continue execution or not.</source>
          <target state="translated">この情報を使用するかどうか、どのように使用するかはランタイムシステム次第であることに注意してください。いくつかのプラットフォーム上の実装では、タイムスライスの消費された分数を決定するために他の手段を使用することができます。長いドライバのコールバックは、これに関係なく、頻繁にこの関数を呼び出して実行の継続が許可されているかどうかを判断しなければなりません。</target>
        </trans-unit>
        <trans-unit id="0e2ef46263bde688553324aea18d9c6d620ba48f" translate="yes" xml:space="preserve">
          <source>Notice that lists are encoded as strings if they consist entirely of integers in the range 0..255. This function do not decode such strings, use &lt;code&gt;ei_decode_string()&lt;/code&gt; instead.</source>
          <target state="translated">リストが完全に0..255の範囲の整数で構成されている場合、リストは文字列としてエンコードされることに注意してください。この関数はそのような文字列をデコードしません。代わりに &lt;code&gt;ei_decode_string()&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="c29a9c8eeda96edcc7c5ce99dcb3efa7b2a52727" translate="yes" xml:space="preserve">
          <source>Notice that message &lt;code&gt;trace_delivered&lt;/code&gt; does &lt;strong&gt;not&lt;/strong&gt; imply that trace messages have been delivered. Instead it implies that all trace messages that &lt;strong&gt;are to be delivered&lt;/strong&gt; have been delivered. It is not an error if &lt;code&gt;Tracee&lt;/code&gt; is not, and has not been traced by someone, but if this is the case, &lt;strong&gt;no&lt;/strong&gt; trace messages have been delivered when the &lt;code&gt;trace_delivered&lt;/code&gt; message arrives.</source>
          <target state="translated">メッセージ &lt;code&gt;trace_delivered&lt;/code&gt; は、トレースメッセージが配信されたことを意味し&lt;strong&gt;ない&lt;/strong&gt;ことに注意してください。代わりに、&lt;strong&gt;配信される&lt;/strong&gt;すべてのトレースメッセージ&lt;strong&gt;が配信された&lt;/strong&gt;ことを意味します。 &lt;code&gt;Tracee&lt;/code&gt; がトレースされておらず、トレースされていない場合はエラーではありませんが、この場合、 &lt;code&gt;trace_delivered&lt;/code&gt; メッセージが到着したときにトレースメッセージが配信されてい&lt;strong&gt;ません&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="013198e22f586360fbbdabe6dcc8ff964ca7ded8" translate="yes" xml:space="preserve">
          <source>Notice that most type test BIFs have older equivalents, without the &lt;code&gt;is_&lt;/code&gt; prefix. These old BIFs are retained for backwards compatibility only and are not to be used in new code. They are also only allowed at top level. For example, they are not allowed in Boolean expressions in guards.</source>
          <target state="translated">ほとんどの型テスト &lt;code&gt;is_&lt;/code&gt; は、is_接頭辞なしの同等の古いバージョンがあることに注意してください。これらの古いBIFは、下位互換性のためにのみ保持されており、新しいコードでは使用されません。また、トップレベルでのみ許可されています。たとえば、ガードのブール式では使用できません。</target>
        </trans-unit>
        <trans-unit id="d8a03c035117d8088ab8da75706b1955d4613585" translate="yes" xml:space="preserve">
          <source>Notice that multiple &quot;*&quot; characters are allowed (as in Unix wildcards, but opposed to Windows/DOS wildcards).</source>
          <target state="translated">複数の &quot;*&quot; 文字が許されていることに注意してください (Unix ワイルドカードのように、Windows/DOS ワイルドカードとは対照的です)。</target>
        </trans-unit>
        <trans-unit id="54221071699f0442ffc1867adb1c29b6517f290f" translate="yes" xml:space="preserve">
          <source>Notice that negative integer and float literals do not occur as such; they are parsed as an application of the unary negation operator.</source>
          <target state="translated">負の整数リテラルや浮動小数点リテラルはそのようには発生しないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="f22111bba803b0601fab83f0c4714a0a75aa87f8" translate="yes" xml:space="preserve">
          <source>Notice that no bounds checking is done on the buffer. It is the caller's responsibility to ensure that the buffer is large enough to hold the encoded terms. You can either use a static buffer that is large enough to hold the terms you expect to need in your program, or use &lt;code&gt;erl_term_len()&lt;/code&gt; to determine the exact requirements for a given term.</source>
          <target state="translated">境界チェックはバッファで行われないことに注意してください。バッファーがエンコードされた用語を保持するのに十分な大きさであることを確認するのは呼び出し側の責任です。プログラムで必要になると &lt;code&gt;erl_term_len()&lt;/code&gt; れる用語を保持するのに十分な大きさの静的バッファーを使用するか、またはerl_term_len（）を使用して特定の用語の正確な要件を判別できます。</target>
        </trans-unit>
        <trans-unit id="68f6c800f695bdd5313479dc773780ed9ac1eaba" translate="yes" xml:space="preserve">
          <source>Notice that no deleted objects are removed from a fixed table until it has been released. If a process fixes a table but never releases it, the memory used by the deleted objects is never freed. The performance of operations on the table also degrades significantly.</source>
          <target state="translated">固定されたテーブルが解放されるまで、削除されたオブジェクトは削除されないことに注意してください。プロセスがテーブルを固定しても解放しない場合、削除されたオブジェクトが使用していたメモリは解放されません。テーブルに対する操作のパフォーマンスも大きく低下します。</target>
        </trans-unit>
        <trans-unit id="27077c84801a08f27f5df1e48d210573f24a2d7b" translate="yes" xml:space="preserve">
          <source>Notice that no disc operations are performed when a program executes write operations to these replicas. However, if permanent RAM replicas are required, the following alternatives are available:</source>
          <target state="translated">プログラムがこれらのレプリカへの書き込み操作を実行しても、ディスク操作は行われないことに注意してください。ただし、恒久的な RAM レプリカが必要な場合は、以下の選択肢があります。</target>
        </trans-unit>
        <trans-unit id="0a597a819e1aa34d827c71c03375ea201eae9bbe" translate="yes" xml:space="preserve">
          <source>Notice that not all implementations support all these &lt;code&gt;Item&lt;/code&gt;s.</source>
          <target state="translated">すべての実装がこれらのすべての &lt;code&gt;Item&lt;/code&gt; をサポートしているわけではないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="4b0bf74963177cf020fa41c6b9891ab9f9dfa55b" translate="yes" xml:space="preserve">
          <source>Notice that octal values &amp;gt;= 100 that are specified using this syntax must not be introduced by a leading zero, as no more than three octal digits are ever read.</source>
          <target state="translated">この構文を使用して指定された100以上の8進値は、3桁以下の8進数字が読み取られるため、先頭にゼロを付けないでください。</target>
        </trans-unit>
        <trans-unit id="52b3caa006e96a4c992643ceef9a790dd9eaf91b" translate="yes" xml:space="preserve">
          <source>Notice that offsets are counted in bytes, not in characters. If the file is opened using some other &lt;code&gt;encoding&lt;/code&gt; than &lt;code&gt;latin1&lt;/code&gt;, one byte does not correspond to one character. Positioning in such a file can only be done to known character boundaries. That is, to a position earlier retrieved by getting a current position, to the beginning/end of the file or to some other position &lt;strong&gt;known&lt;/strong&gt; to be on a correct character boundary by some other means (typically beyond a byte order mark in the file, which has a known byte-size).</source>
          <target state="translated">オフセットは文字ではなくバイトでカウントされることに注意してください。ファイルは、他のいくつかの使用して開かれている場合 &lt;code&gt;encoding&lt;/code&gt; より &lt;code&gt;latin1&lt;/code&gt; 、1つのバイトが1つの文字に対応していません。そのようなファイルでの位置付けは、既知の文字境界に対してのみ実行できます。つまり、現在の位置を取得することで以前に取得した位置、ファイルの先頭/末尾、または他の方法で正しい文字境界にあることが&lt;strong&gt;わかっ&lt;/strong&gt;ている他の位置（通常、ファイル内のバイトオーダーマークを超える）既知のバイトサイズがあります）。</target>
        </trans-unit>
        <trans-unit id="bf27ace1c7a3c2d0e720b1879eb1095858231ab1" translate="yes" xml:space="preserve">
          <source>Notice that on Windows, this flag is only applicable for &lt;code&gt;werl&lt;/code&gt;, not &lt;code&gt;erl&lt;/code&gt; (&lt;code&gt;oldshell&lt;/code&gt;). Notice also that &lt;code&gt;Ctrl-Break&lt;/code&gt; is used instead of &lt;code&gt;Ctrl-C&lt;/code&gt; on Windows.</source>
          <target state="translated">Windowsでは、このフラグは &lt;code&gt;werl&lt;/code&gt; にのみ適用され、 &lt;code&gt;erl&lt;/code&gt; （ &lt;code&gt;oldshell&lt;/code&gt; ）には適用されないことに注意してください。Windowsでは &lt;code&gt;Ctrl-C&lt;/code&gt; の代わりに &lt;code&gt;Ctrl-Break&lt;/code&gt; が使用されることにも注意してください。</target>
        </trans-unit>
        <trans-unit id="b312389a960b6c4523a134c6d69a5e6dbd847cda" translate="yes" xml:space="preserve">
          <source>Notice that on some systems (such as VxWorks), a failed node is not detected by this mechanism, as the operating system does not automatically close descriptors that were left open when the node failed. If a node has failed in this way, &lt;code&gt;epmd&lt;/code&gt; prevents you from registering a new node with the old name, as it thinks that the old name is still in use. In this case, you must close the port explicitly</source>
          <target state="translated">一部のシステム（VxWorksなど）では、ノードに障害が発生したときに開いたままになっていた記述子がオペレーティングシステムによって自動的に閉じられないため、このメカニズムでは障害が発生したノードが検出されないことに注意してください。この方法でノードに &lt;code&gt;epmd&lt;/code&gt; が発生した場合、epmdは、古い名前がまだ使用されていると見なすため、古い名前で新しいノードを登録することを防ぎます。この場合、ポートを明示的に閉じる必要があります</target>
        </trans-unit>
        <trans-unit id="32a6701d594a7f27b24d59d66fe69bc778606ca3" translate="yes" xml:space="preserve">
          <source>Notice that on some systems (such as VxWorks), a failed node is not detected by this mechanism, as the operating system does not automatically close descriptors that were left open when the node failed. If a node has failed in this way, &lt;code&gt;epmd&lt;/code&gt; prevents you from registering a new node with the old name, as it thinks that the old name is still in use. In this case, you must unregister the name explicitly:</source>
          <target state="translated">一部のシステム（VxWorksなど）では、ノードに障害が発生したときにオペレーティングシステムが開いたままの記述子を自動的に閉じないため、障害が発生したノードはこのメカニズムによって検出されません。この方法でノードに &lt;code&gt;epmd&lt;/code&gt; が発生した場合、古い名前がまだ使用されていると見なされるため、epmdは古い名前で新しいノードを登録できないようにします。この場合、名前を明示的に登録解除する必要があります。</target>
        </trans-unit>
        <trans-unit id="43e1e5b7dc6da1a31388b14df1d6f6d64c3c0721" translate="yes" xml:space="preserve">
          <source>Notice that once &lt;code&gt;enif_make_resource&lt;/code&gt; creates the term to return to Erlang, the code can choose to either keep its own native pointer to the allocated struct and release it later, or release it immediately and rely only on the garbage collector to deallocate the resource object eventually when it collects the term.</source>
          <target state="translated">一度ことをお知らせ &lt;code&gt;enif_make_resource&lt;/code&gt; はアーランに戻るには用語を作成し、最終的に、コードはどちらかに選択することができます割り当てられた構造体に独自のネイティブポインタを保持し、後でそれを解放、またはすぐにそれを解放し、リソースオブジェクトを解放する唯一のガベージコレクタに依存しています用語を集めます。</target>
        </trans-unit>
        <trans-unit id="c711aa1c3890b7bd6065da8da6bc10f65058ad93" translate="yes" xml:space="preserve">
          <source>Notice that only nodes with disc are to be included in &lt;code&gt;DiscNodes&lt;/code&gt;. Disc-less nodes, that is, nodes where all tables including the schema only resides in RAM, must not be included.</source>
          <target state="translated">&lt;code&gt;DiscNodes&lt;/code&gt; には、ディスクを持つノードのみが含まれることに注意してください。ディスクなしのノード、つまりスキーマを含むすべてのテーブルがRAMにのみ存在するノードは含めないでください。</target>
        </trans-unit>
        <trans-unit id="67651cee75d5ac445a33e918dbfa7e4e883f716f" translate="yes" xml:space="preserve">
          <source>Notice that only one timer exists on each driver instance; setting a new timer replaces an older one.</source>
          <target state="translated">各ドライバインスタンスには 1 つのタイマしか存在しないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="29d795d009d1ea7a8a290d1e73a04d2744f2a646" translate="yes" xml:space="preserve">
          <source>Notice that only schedulers online can be bound to logical processors.</source>
          <target state="translated">論理プロセッサにバインドできるのはオンラインのスケジューラだけであることに注意してください。</target>
        </trans-unit>
        <trans-unit id="f799abe642c8ae36124dcf7f5ee9ae1710bfa1f7" translate="yes" xml:space="preserve">
          <source>Notice that only tables of a certain format can be restored, that is, those that have been created and backed up to with &lt;code&gt;ei_reg_dump()&lt;/code&gt;. If the registry was not empty before the operation, the contents of the table are added to the contents of the registry. If the table contains objects with the same keys as those already in the registry, the registry objects are overwritten with the new values. If the registry contains objects that were not in the table, they are unchanged by this operation.</source>
          <target state="translated">特定の形式のテーブル、つまり &lt;code&gt;ei_reg_dump()&lt;/code&gt; で作成およびバックアップされたテーブルのみを復元できることに注意してください。操作の前にレジストリが空でなかった場合、テーブルの内容がレジストリの内容に追加されます。テーブルに、既にレジストリにあるものと同じキーを持つオブジェクトが含まれている場合、レジストリオブジェクトは新しい値で上書きされます。レジストリにテーブルになかったオブジェクトが含まれている場合、それらはこの操作によって変更されません。</target>
        </trans-unit>
        <trans-unit id="23b04cc5100e31a53261bbb900a051cd16d9ea99" translate="yes" xml:space="preserve">
          <source>Notice that only the channel is closed. The connection is still up and can handle other channels:</source>
          <target state="translated">チャンネルだけが閉じられていることに注意してください。接続はまだ立ち上がっており、他のチャンネルを扱うことができます。</target>
        </trans-unit>
        <trans-unit id="b15082a81f1a1a6e64b2d55298a12d9faa42eee1" translate="yes" xml:space="preserve">
          <source>Notice that only the lexicographical SNMP ordering is implemented in Mnesia, not the actual SNMP monitoring.</source>
          <target state="translated">Mnesiaでは、辞書的SNMPの順序付けのみが実装されており、実際のSNMP監視は行われていないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="a5838dc3537f85f38eb4149ebbfa4d4cafe73f75" translate="yes" xml:space="preserve">
          <source>Notice that parameter &lt;code&gt;Assoc&lt;/code&gt; is by the &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;SCTP Sockets API Extensions&lt;/a&gt;&lt;/code&gt; defined to be ignored for one-to-one style sockets. For one-to-many style sockets, the special value &lt;code&gt;0&lt;/code&gt; is defined to mean that the returned addresses must be without any particular association. How different SCTP implementations interpret this varies somewhat.</source>
          <target state="translated">パラメータ &lt;code&gt;Assoc&lt;/code&gt; は、1対1スタイルのソケットでは無視されるように定義された &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;SCTP Sockets API Extensions&lt;/a&gt;&lt;/code&gt; によるものであることに注意してください。1対多スタイルのソケットの場合、特別な値 &lt;code&gt;0&lt;/code&gt; が定義されており、返されるアドレスには特定の関連付けがない必要があります。さまざまなSCTP実装がこれを解釈する方法は多少異なります。</target>
        </trans-unit>
        <trans-unit id="d0d1f865bec9fd2105dd8d15020f4e5d9157f2b3" translate="yes" xml:space="preserve">
          <source>Notice that parameter &lt;code&gt;Assoc&lt;/code&gt; is by the &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;SCTP Sockets API Extensions&lt;/a&gt;&lt;/code&gt; defined to be ignored for one-to-one style sockets. What the special value &lt;code&gt;0&lt;/code&gt; means, hence its behavior for one-to-many style sockets, is unfortunately undefined.</source>
          <target state="translated">パラメータ &lt;code&gt;Assoc&lt;/code&gt; は、1対1スタイルのソケットでは無視されるように定義された &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;SCTP Sockets API Extensions&lt;/a&gt;&lt;/code&gt; によるものであることに注意してください。特別な値 &lt;code&gt;0&lt;/code&gt; の意味、つまり、1対多スタイルのソケットの動作は、残念ながら未定義です。</target>
        </trans-unit>
        <trans-unit id="4ced3b5e4f7be44b8431fee61dd5559644b2a227" translate="yes" xml:space="preserve">
          <source>Notice that postponing buttons from the &lt;code&gt;open&lt;/code&gt; state to the &lt;code&gt;locked&lt;/code&gt; state feels like a strange thing to do for a code lock, but it at least illustrates event postponing.</source>
          <target state="translated">&lt;code&gt;open&lt;/code&gt; 状態から &lt;code&gt;locked&lt;/code&gt; 状態にボタンを延期することは、コードロックに対して行うのは奇妙なことのように思えますが、少なくともイベントの延期を示していることに注意してください。</target>
        </trans-unit>
        <trans-unit id="1c4f96f83f897de68ba3692f859901f16bc8520d" translate="yes" xml:space="preserve">
          <source>Notice that purging the code means that any processes lingering in old code for the module are killed without warning. For more information, see &lt;code&gt;code/3&lt;/code&gt;.</source>
          <target state="translated">コードをパージすると、モジュールの古いコードに残っているプロセスは警告なしに強制終了されることに注意してください。詳細については、 &lt;code&gt;code/3&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="c423ca269e9c8da0681587c3e65b43e4f6fcac32" translate="yes" xml:space="preserve">
          <source>Notice that relaxed command checking must enabled for the &lt;code&gt;epmd&lt;/code&gt; daemon contacted. When running &lt;code&gt;epmd&lt;/code&gt; interactively, &lt;code&gt;-relaxed_command_check&lt;/code&gt; has no effect.</source>
          <target state="translated">接続された &lt;code&gt;epmd&lt;/code&gt; デーモンに対して、緩和されたコマンドチェックを有効にする必要があることに注意してください。 &lt;code&gt;epmd&lt;/code&gt; を対話的に実行する場合、 &lt;code&gt;-relaxed_command_check&lt;/code&gt; は効果がありません。</target>
        </trans-unit>
        <trans-unit id="c9c86576f8186edb080a192562941feff98f7212" translate="yes" xml:space="preserve">
          <source>Notice that request for multiple parts of a document report a size of zero to the log file.</source>
          <target state="translated">文書の複数の部分を要求すると、ログファイルにサイズがゼロであることを報告することに注意してください。</target>
        </trans-unit>
        <trans-unit id="e599e5f12a452819b319876058461d934b52f083" translate="yes" xml:space="preserve">
          <source>Notice that setting this value to &lt;code&gt;0&lt;/code&gt; does not turn of rotation. It only specifies that no archives are kept.</source>
          <target state="translated">この値を &lt;code&gt;0&lt;/code&gt; に設定しても、回転は回転しないことに注意してください。アーカイブが保持されないことを指定するだけです。</target>
        </trans-unit>
        <trans-unit id="4443c6286a90c15343a889185dfe1fff15bfc5fd" translate="yes" xml:space="preserve">
          <source>Notice that settings saved by Erlang/OTP R16B01 or later cannot be read by Erlang/OTP R16B or earlier.</source>
          <target state="translated">Erlang/OTP R16B01以降で保存された設定はErlang/OTP R16B以前では読み込めないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="649ed4989f050a560c2834e24c160ce1f14f0aab" translate="yes" xml:space="preserve">
          <source>Notice that since variables starting with an underscore are not anonymous, this matches:</source>
          <target state="translated">アンダースコアで始まる変数は匿名ではないので、これは一致することに注意してください。</target>
        </trans-unit>
        <trans-unit id="d7a8cf550209c24a879718ffa59fcc7fbdaebab0" translate="yes" xml:space="preserve">
          <source>Notice that some system-internal events can also be received. Therefore a catch-all clause last in the definition of the event handler callback function &lt;code&gt;Module:handle_event/2&lt;/code&gt; is necessary. This also applies for &lt;code&gt;Module:handle_info/2&lt;/code&gt;, as the event handler must also take care of some system-internal messages.</source>
          <target state="translated">一部のシステム内部イベントも受信できることに注意してください。したがって、イベントハンドラコールバック関数 &lt;code&gt;Module:handle_event/2&lt;/code&gt; の定義の最後にあるcatch-all句が必要です。これは &lt;code&gt;Module:handle_info/2&lt;/code&gt; にも適用されます。これは、イベントハンドラーが一部のシステム内部メッセージも処理する必要があるためです。</target>
        </trans-unit>
        <trans-unit id="4523f125f7da0a280c62ef57a22e6c4002553475" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;bin_opt_info&lt;/code&gt; is not meant to be a permanent option added to your &lt;code&gt;Makefile&lt;/code&gt;s, because all messages that it generates cannot be eliminated. Therefore, passing the option through the environment is in most cases the most practical approach.</source>
          <target state="translated">&lt;code&gt;bin_opt_info&lt;/code&gt; は、 &lt;code&gt;Makefile&lt;/code&gt; に追加される永続的なオプションではないことに注意してください。生成されるすべてのメッセージは削除できないためです。したがって、オプションを環境に渡すことは、ほとんどの場合、最も実用的なアプローチです。</target>
        </trans-unit>
        <trans-unit id="9f25de8ce6849112886fde44cc358ca27b801415" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;get_until&lt;/code&gt; request allows for a function with the data specified as always being a list. Also, the return value data from such a function can be of any type (as is indeed the case when an &lt;code&gt;io:fread/2,3&lt;/code&gt; request is sent to an I/O server). The client must be prepared for data received as answers to those requests to be in various forms. However, the I/O server is to convert the results to binaries whenever possible (that is, when the function supplied to &lt;code&gt;get_until&lt;/code&gt; returns a list). This is done in the example in section &lt;code&gt;&lt;a href=&quot;#example_io_server&quot;&gt;An Annotated and Working Example I/O Server&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;get_until&lt;/code&gt; リクエストでは、常にリストとして指定されたデータを持つ関数が許可されていることに注意してください。また、そのような関数からの戻り値データは任意のタイプにすることができます（実際に &lt;code&gt;io:fread/2,3&lt;/code&gt; 要求がI / Oサーバーに送信される場合はそうです）。クライアントは、これらの要求に対する応答として受信したデータがさまざまな形式になるように準備する必要があります。ただし、I / Oサーバーは可能な限り結果をバイナリに変換します（つまり、 &lt;code&gt;get_until&lt;/code&gt; に指定された関数がリストを返す場合）。これは、 &lt;code&gt;&lt;a href=&quot;#example_io_server&quot;&gt;An Annotated and Working Example I/O Server&lt;/a&gt;&lt;/code&gt; セクションの例で行われます。</target>
        </trans-unit>
        <trans-unit id="869fe53220efffa9f2648be8687be1af3cac2f73" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;pid()&lt;/code&gt; of the I/O server is not explicitly present in tuple &lt;code&gt;io_reply&lt;/code&gt;. The reply can be sent from any process, not necessarily the actual I/O server.</source>
          <target state="translated">I / Oサーバーの &lt;code&gt;pid()&lt;/code&gt; がタプル &lt;code&gt;io_reply&lt;/code&gt; に明示的に存在しないことに注意してください。応答は、必ずしも実際のI / Oサーバーではなく、任意のプロセスから送信できます。</target>
        </trans-unit>
        <trans-unit id="f9bf7bd1d2a63adf57d1dd61e3e2c636ef718d87" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;start_link&lt;/code&gt; functions of the different behavior modules fulfill the above requirements.</source>
          <target state="translated">さまざまな動作モジュールの &lt;code&gt;start_link&lt;/code&gt; 関数が上記の要件を満たしていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="438a7860299a64ed5669574b6efede437e192860" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;{'EXIT', Id, _}&lt;/code&gt; message can be the result of the link, but can also be the result of &lt;code&gt;Id&lt;/code&gt; calling &lt;code&gt;exit/2&lt;/code&gt;. Therefore, it &lt;strong&gt;can&lt;/strong&gt; be appropriate to clean up the message queue when trapping exits after the call to &lt;code&gt;unlink(Id)&lt;/code&gt;, as follows:</source>
          <target state="translated">通知することを &lt;code&gt;{'EXIT', Id, _}&lt;/code&gt; メッセージは、リンクの結果とすることができるだけでなく、の結果であり得る &lt;code&gt;Id&lt;/code&gt; が呼び出す &lt;code&gt;exit/2&lt;/code&gt; 。したがって、次のように、 &lt;code&gt;unlink(Id)&lt;/code&gt; の呼び出し後にトラップが終了するときに、メッセージキューをクリーンアップ&lt;strong&gt;するの&lt;/strong&gt;が適切な場合&lt;strong&gt;が&lt;/strong&gt;あります。</target>
        </trans-unit>
        <trans-unit id="e7d3b1ac2fe8c40d5c296cb9508ac5b63294a0ef" translate="yes" xml:space="preserve">
          <source>Notice that the BOM for UTF-8 is seldom used, and it is really not a &lt;strong&gt;byte order&lt;/strong&gt; mark. There are obviously no byte order issues with UTF-8, so the BOM is only there to differentiate UTF-8 encoding from other UTF formats.</source>
          <target state="translated">UTF-8のBOMはほとんど使用されず、実際には&lt;strong&gt;バイトオーダー&lt;/strong&gt;マークではないことに注意してください。UTF-8にはバイトオーダーの問題がないことは明らかなので、BOMはUTF-8エンコーディングを他のUTF形式と区別するためだけに存在します。</target>
        </trans-unit>
        <trans-unit id="60ba36aa64236926d8fc38d4a0caadafb0e955a8" translate="yes" xml:space="preserve">
          <source>Notice that the C program is in a &lt;code&gt;while&lt;/code&gt;-loop, checking for the return value of &lt;code&gt;read_cmd/1&lt;/code&gt;. This is because the C program must detect when the port closes and terminates.</source>
          <target state="translated">Cプログラムが &lt;code&gt;while&lt;/code&gt; ループにあり、 &lt;code&gt;read_cmd/1&lt;/code&gt; の戻り値をチェックしていることに注意してください。これは、Cプログラムがポートのクローズと終了を検出する必要があるためです。</target>
        </trans-unit>
        <trans-unit id="a63c691118a268393e4b6c047b61976f9f09e5f5" translate="yes" xml:space="preserve">
          <source>Notice that the Kernel variable &lt;code&gt;inetrc&lt;/code&gt; overrides this environment variable.</source>
          <target state="translated">カーネル変数 &lt;code&gt;inetrc&lt;/code&gt; がこの環境変数をオーバーライドすることに注意してください。</target>
        </trans-unit>
        <trans-unit id="998c3bd807afb787e85df818d68896568ab1dac7" translate="yes" xml:space="preserve">
          <source>Notice that the above handler does not have any overload protection, and all log events are printed directly from the client process.</source>
          <target state="translated">上記のハンドラには過負荷保護機能がなく、すべてのログイベントはクライアントプロセスから直接出力されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="5b06b14e5057923df74530d889d86c130c4599fb" translate="yes" xml:space="preserve">
          <source>Notice that the above specification does not restrict the input and output type in any way. These types can be constrained by guard-like subtype constraints and provide bounded quantification:</source>
          <target state="translated">上記の仕様では、入力型と出力型は何ら制限されていないことに注意してください。これらの型は、ガード的なサブタイプ制約によって制約され、制限された定量化を提供することができます。</target>
        </trans-unit>
        <trans-unit id="ffeb1c6cbb53bd413a17d7e4afa253b27c7a4334" translate="yes" xml:space="preserve">
          <source>Notice that the apparently similar pattern</source>
          <target state="translated">明らかに似たようなパターンであることに注目してください。</target>
        </trans-unit>
        <trans-unit id="1865e3416dbeb17876187856aa08e4b5f4f9fd78" translate="yes" xml:space="preserve">
          <source>Notice that the application version specifies a source code version. One more, indirect, requirement is that the installed binary application of the specified version is built so that it is compatible with the rest of the system.</source>
          <target state="translated">アプリケーションのバージョンがソースコードのバージョンを指定していることに注意してください。もう一つの間接的な要件は、指定されたバージョンのインストールされたバイナリアプリケーションがシステムの残りの部分と互換性があるように構築されていることです。</target>
        </trans-unit>
        <trans-unit id="12430644918a731bc0331cb307bf4502fd57f823" translate="yes" xml:space="preserve">
          <source>Notice that the argument is a list with exactly one, two, or three arguments. &lt;code&gt;NameType&lt;/code&gt; defaults to &lt;code&gt;longnames&lt;/code&gt; and &lt;code&gt;Ticktime&lt;/code&gt; to &lt;code&gt;15000&lt;/code&gt;.</source>
          <target state="translated">引数が1つ、2つ、または3つの引数のリストであることに注意してください。 &lt;code&gt;NameType&lt;/code&gt; のデフォルトは &lt;code&gt;longnames&lt;/code&gt; 、 &lt;code&gt;Ticktime&lt;/code&gt; は &lt;code&gt;15000&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="4e51fbbc05a639063fcd094a483d069e3e71d424" translate="yes" xml:space="preserve">
          <source>Notice that the behavior of this function for an SCTP one-to-many style socket is not defined by the &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;SCTP Sockets API Extensions&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">SCTP 1対多スタイルのソケットに対するこの関数の動作は、 &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;SCTP Sockets API Extensions&lt;/a&gt;&lt;/code&gt; は定義されていないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="2695495d90a21bfbc215e48f946c97c1557c57eb" translate="yes" xml:space="preserve">
          <source>Notice that the compiler does not generate encode/decode functions for parameterized types, only for the instances of the parameterized types. Therefore, if a file contains the types &lt;code&gt;General{}&lt;/code&gt;, &lt;code&gt;T1&lt;/code&gt;, and &lt;code&gt;T2&lt;/code&gt; as in the previous example, encode/decode functions are only generated for &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt;.</source>
          <target state="translated">コンパイラーは、パラメーター化された型のインスタンスに対してのみ、パラメーター化された型のエンコード/デコード関数を生成しないことに注意してください。したがって、前の例のように、ファイルに &lt;code&gt;General{}&lt;/code&gt; 、 &lt;code&gt;T1&lt;/code&gt; 、および &lt;code&gt;T2&lt;/code&gt; のタイプが含まれている場合、エンコード/デコード関数は &lt;code&gt;T1&lt;/code&gt; および &lt;code&gt;T2&lt;/code&gt; に対してのみ生成されます。</target>
        </trans-unit>
        <trans-unit id="f4bdb273ffa02e13186dc2814d4167dbf9f7eac3" translate="yes" xml:space="preserve">
          <source>Notice that the current key is stored in the driver, and can be invalid (for example, if the key has been removed).</source>
          <target state="translated">現在のキーはドライバに保存されており、無効になる可能性があることに注意してください(キーが削除されている場合など)。</target>
        </trans-unit>
        <trans-unit id="3425e12704f1ae2e3dac5bdc4405aa18192ba618" translate="yes" xml:space="preserve">
          <source>Notice that the default options for TCP/IP sockets can be changed with the Kernel configuration parameters mentioned in the beginning of this manual page.</source>
          <target state="translated">TCP/IP ソケットのデフォルトオプションは、このマニュアルページの最初に記載されているカーネル構成パラメータで変更できます。</target>
        </trans-unit>
        <trans-unit id="8735534cfeef989ea973a36967fd6073321a2a23" translate="yes" xml:space="preserve">
          <source>Notice that the definition of type &lt;code&gt;SET OF&lt;/code&gt; implies that the order of the components is undefined, but in practice there is no difference between &lt;code&gt;SET OF&lt;/code&gt; and &lt;code&gt;SEQUENCE OF&lt;/code&gt;. The ASN.1 compiler for Erlang does not randomize the order of the &lt;code&gt;SET OF&lt;/code&gt; components before encoding.</source>
          <target state="translated">タイプ &lt;code&gt;SET OF&lt;/code&gt; の定義は、コンポーネントの順序が未定義であることを意味しますが、実際には、 &lt;code&gt;SET OF&lt;/code&gt; と &lt;code&gt;SEQUENCE OF&lt;/code&gt; の間に違いはありません。ErlangのASN.1コンパイラーは、エンコードの前に &lt;code&gt;SET OF&lt;/code&gt; コンポーネントの順序をランダム化しません。</target>
        </trans-unit>
        <trans-unit id="85ee2b1beef42dfc51c38d1bdc5c48413f6418d8" translate="yes" xml:space="preserve">
          <source>Notice that the end of this type of comment is a literal newline sequence in the pattern; escape sequences that happen to represent a newline do not count. For example, consider the following pattern when &lt;code&gt;extended&lt;/code&gt; is set, and the default newline convention is in force:</source>
          <target state="translated">このタイプのコメントの終わりは、パターン内のリテラルの改行シーケンスであることに注意してください。たまたま改行を表すエスケープシーケンスはカウントされません。たとえば、 &lt;code&gt;extended&lt;/code&gt; が設定されており、デフォルトの改行規則が有効になっている場合は、次のパターンを検討してください。</target>
        </trans-unit>
        <trans-unit id="59c9761a4423dc8ba33d258174c0d7deb92180da" translate="yes" xml:space="preserve">
          <source>Notice that the file encoding options specified when opening a file has nothing to do with the filename encoding convention. You can very well open files containing data encoded in UTF-8, but having filenames in bytewise (&lt;code&gt;latin1&lt;/code&gt;) encoding or conversely.</source>
          <target state="translated">ファイルを開くときに指定されるファイルエンコーディングオプションは、ファイル名のエンコーディング規則とは関係がないことに注意してください。UTF-8でエンコードされたデータを含むファイルを非常に適切に開くことができますが、ファイル名はバイト単位（ &lt;code&gt;latin1&lt;/code&gt; ）エンコードまたはその逆です。</target>
        </trans-unit>
        <trans-unit id="54b730627c759c2237c6a38f6ac21fcf1d73b83e" translate="yes" xml:space="preserve">
          <source>Notice that the filesystem containing the virtual machine executable (&lt;code&gt;beam.smp&lt;/code&gt; in the example) must be local, mounted without flag &lt;code&gt;nosetuid&lt;/code&gt;, support extended attributes, and the kernel must support file capabilities. All this runs out of the box on at least Ubuntu 12.04 LTS, except that SCTP sockets appear to not support network namespaces.</source>
          <target state="translated">仮想マシン実行可能ファイル（例では、 &lt;code&gt;beam.smp&lt;/code&gt; ）を含むファイルシステムはローカルで、フラグ &lt;code&gt;nosetuid&lt;/code&gt; なしでマウントされ、拡張属性をサポートし、カーネルがファイル機能をサポートしている必要があります。SCTPソケットがネットワーク名前空間をサポートしていないように見えることを除いて、これはすべて、Ubuntu 12.04 LTSでそのまま実行できます。</target>
        </trans-unit>
        <trans-unit id="856dd98224a317941549fceec575ed693a862a3b" translate="yes" xml:space="preserve">
          <source>Notice that the function &lt;code&gt;add_frag/2&lt;/code&gt; is started one time for each of the other fragments (except number 1) as a part of the table creation procedure.</source>
          <target state="translated">テーブル作成手順の一部として、関数 &lt;code&gt;add_frag/2&lt;/code&gt; が他のフラグメント（番号1を除く）のそれぞれに対して1回開始されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="71fbea88394343530b7ae5da050f337473550603" translate="yes" xml:space="preserve">
          <source>Notice that the function can return &lt;code&gt;true&lt;/code&gt; for a module that in fact is not interpretable in the case where the module is marked as sticky or resides in a directory marked as sticky. The reason is that this is not discovered until the interpreter tries to load the module.</source>
          <target state="translated">モジュールがスティッキーとしてマークされている場合、またはスティッキーとしてマークされたディレクトリにある場合、実際には解釈できないモジュールに対して関数が &lt;code&gt;true&lt;/code&gt; を返す可能性があることに注意してください。これは、インタープリターがモジュールをロードしようとするまで、これが発見されないためです。</target>
        </trans-unit>
        <trans-unit id="fc5ff5fc0775ca18d960b27958c2c310603beba9" translate="yes" xml:space="preserve">
          <source>Notice that the functions below perform an RPC using an open file descriptor provided by the caller. This file descriptor must not be used for other traffic during the global operation, as the function can then receive unexpected data and fail.</source>
          <target state="translated">以下の関数は、呼び出し元によって提供されたオープンファイル記述子を使用して RPC を実行することに注意してください。このファイル記述子は、グローバル操作中に他のトラフィックに使用してはいけません。</target>
        </trans-unit>
        <trans-unit id="6344e9ae1d5d7f5e3378303250cff912dbc2282d" translate="yes" xml:space="preserve">
          <source>Notice that the history of the last trace is always available in file &lt;code&gt;ttb_last_config&lt;/code&gt;.</source>
          <target state="translated">最後のトレースの履歴は、ファイル &lt;code&gt;ttb_last_config&lt;/code&gt; で常に利用可能であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="9b4c212a61f0bb3f68fad2d68b59100bb913758e" translate="yes" xml:space="preserve">
          <source>Notice that the information returned is highly implementation-dependent and can be changed or removed at any time without prior notice. It was initially intended as a tool when developing new allocators, but as it can be of interest for others it has been briefly documented.</source>
          <target state="translated">返される情報は実装に大きく依存しており、事前の通知なしにいつでも変更や削除が可能であることに注意してください。これは当初、新しいアロケータを開発する際のツールとして意図されていましたが、他の人にも興味を持ってもらえるように、簡単に文書化されています。</target>
        </trans-unit>
        <trans-unit id="ed442d55f4c83cba3d99e636fc5b3b8fb144e267" translate="yes" xml:space="preserve">
          <source>Notice that the integer value is only used internally in Logger. In the API, you must always use the atom. To compare the severity of two log levels, use &lt;code&gt;&lt;a href=&quot;logger#compare_levels-2&quot;&gt; logger:compare_levels/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">整数値はLoggerの内部でのみ使用されることに注意してください。APIでは、常にアトムを使用する必要があります。2つのログレベルの重大度を比較するには、 &lt;code&gt;&lt;a href=&quot;logger#compare_levels-2&quot;&gt; logger:compare_levels/2&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="5eec770c656034420f67e24636825b21ba0fb080" translate="yes" xml:space="preserve">
          <source>Notice that the integer value is only used internally in Logger. In the API, you must always use the atom. To compare the severity of two log levels, use &lt;code&gt;&lt;a href=&quot;logger#compare_levels-2&quot;&gt;logger:compare_levels/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">整数値はロガーの内部でのみ使用されることに注意してください。APIでは、常にアトムを使用する必要があります。2つのログレベルの重大度を比較するには、 &lt;code&gt;&lt;a href=&quot;logger#compare_levels-2&quot;&gt;logger:compare_levels/2&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="913c6778d3ce72fc842456abadbdcd4a41900bd7" translate="yes" xml:space="preserve">
          <source>Notice that the last created atom is shown first.</source>
          <target state="translated">最後に作成された原子が最初に表示されていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="e6ee884138fcccc998b14a68323c7c49e44297a2" translate="yes" xml:space="preserve">
          <source>Notice that the last element in the &lt;code&gt;Request&lt;/code&gt; tuple (&lt;code&gt;[$\n]&lt;/code&gt;) is appended to the argument list when the function is called. The function is to be called like &lt;code&gt;apply(Module, Function, [ State, Data | ExtraArgs ])&lt;/code&gt; by the I/O server.</source>
          <target state="translated">関数が呼び出されると、 &lt;code&gt;Request&lt;/code&gt; タプルの最後の要素（ &lt;code&gt;[$\n]&lt;/code&gt; ）が引数リストに追加されることに注意してください。関数は、I / Oサーバーによって &lt;code&gt;apply(Module, Function, [ State, Data | ExtraArgs ])&lt;/code&gt; れます。</target>
        </trans-unit>
        <trans-unit id="65e13b0553b24c92ba77e668391c89bbfe7c5f62" translate="yes" xml:space="preserve">
          <source>Notice that the last part is &quot;ang&quot;, not &quot;an&quot;, as splitting was specified into two parts, and the splitting stops when enough parts are given, which is why the result differs from that of &lt;code&gt;trim&lt;/code&gt;.</source>
          <target state="translated">分割は2つの部分に指定されているため、最後の部分は「an」ではなく「ang」であり、十分な部分が指定されると分割が停止するため、結果が &lt;code&gt;trim&lt;/code&gt; の結果とは異なることに注意してください。</target>
        </trans-unit>
        <trans-unit id="0b0de072daf08ddb3bed5b003d16bec94ec3f838" translate="yes" xml:space="preserve">
          <source>Notice that the match context in &lt;code&gt;my_binary_to_list/1&lt;/code&gt; was discarded when the entire binary had been traversed. What happens if the iteration stops before it has reached the end of the binary? Will the optimization still work?</source>
          <target state="translated">バイナリ全体がトラバースされると、 &lt;code&gt;my_binary_to_list/1&lt;/code&gt; の一致コンテキストが破棄されたことに注意してください。バイナリの最後に達する前に反復が停止するとどうなりますか？最適化は引き続き機能しますか？</target>
        </trans-unit>
        <trans-unit id="2d19f8166370c4661429c3cee25b80ade4ba9fb7" translate="yes" xml:space="preserve">
          <source>Notice that the order of objects returned is unspecified. In particular, the order in which objects were inserted is not reflected.</source>
          <target state="translated">返されるオブジェクトの順番が不特定であることに注意してください。特に、オブジェクトが挿入された順番は反映されていません。</target>
        </trans-unit>
        <trans-unit id="90ee8d6704f5ea8a8da9ff5e648eb8db8d5bce43" translate="yes" xml:space="preserve">
          <source>Notice that the program resides in the emulator's &lt;code&gt;bin&lt;/code&gt; directory, not in the &lt;code&gt;bin&lt;/code&gt; directory directly under the Erlang root. The reasons for this are the subtle problem of upgrading the emulator on a running system, where a new version of the runtime system should not need to overwrite existing (and probably used) executables.</source>
          <target state="translated">お知らせエミュレータの中にプログラムが存在すること &lt;code&gt;bin&lt;/code&gt; ディレクトリではなく、中 &lt;code&gt;bin&lt;/code&gt; ディレクトリに直接Erlangのルートの下に。この理由は、実行中のシステムでエミュレータをアップグレードする際の微妙な問題です。ランタイムシステムの新しいバージョンでは、既存の（おそらく使用されている）実行可能ファイルを上書きする必要はありません。</target>
        </trans-unit>
        <trans-unit id="78b612195b425463060bd89b2b5fb48b2b6bc32f" translate="yes" xml:space="preserve">
          <source>Notice that the program runs slower if the data is located on a remote node.</source>
          <target state="translated">データがリモートノードにある場合、プログラムの動作が遅くなることに注意してください。</target>
        </trans-unit>
        <trans-unit id="7527eddb37622ef5514d8dac4dc37568ecec15bd" translate="yes" xml:space="preserve">
          <source>Notice that the range &lt;code&gt;0..Range-1&lt;/code&gt; is different from the range of &lt;code&gt;phash/2&lt;/code&gt;, which is &lt;code&gt;1..Range&lt;/code&gt;.</source>
          <target state="translated">範囲ことを通知 &lt;code&gt;0..Range-1&lt;/code&gt; の範囲とは異なる &lt;code&gt;phash/2&lt;/code&gt; である、 &lt;code&gt;1..Range&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7f5b1145658a0a3e84e5b5e128d226a353a792a5" translate="yes" xml:space="preserve">
          <source>Notice that the record name is the table name even when &lt;code&gt;record_name&lt;/code&gt; has another setting.</source>
          <target state="translated">&lt;code&gt;record_name&lt;/code&gt; に別の設定がある場合でも、レコード名はテーブル名であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="f556bad20e55c532b765ee625a5af6afc2bd2580" translate="yes" xml:space="preserve">
          <source>Notice that the regular expression must match the complete version string, so this example works for, for example, &lt;code&gt;2.1.1&lt;/code&gt;, but not for &lt;code&gt;2.1.1.1&lt;/code&gt;.</source>
          <target state="translated">正規表現は完全なバージョン文字列と一致する必要があるため、この例は、たとえば &lt;code&gt;2.1.1&lt;/code&gt; では機能しますが、 &lt;code&gt;2.1.1.1&lt;/code&gt; では機能しません。</target>
        </trans-unit>
        <trans-unit id="88bf6f27cbb64880bfd54716d99abab3e050207e" translate="yes" xml:space="preserve">
          <source>Notice that the risk of loosing log events grows when the &lt;code&gt;file_check&lt;/code&gt; value grows.</source>
          <target state="translated">&lt;code&gt;file_check&lt;/code&gt; 値が大きくなると、ログイベントが失われるリスクが高くなることに注意してください。</target>
        </trans-unit>
        <trans-unit id="3b783e1e390dc485584c1f74b3ed69a29fd778c4" translate="yes" xml:space="preserve">
          <source>Notice that the same caveats apply as for &lt;code&gt;&lt;a href=&quot;#garbage_collect-0&quot;&gt; garbage_collect/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#garbage_collect-0&quot;&gt; garbage_collect/0&lt;/a&gt;&lt;/code&gt; 場合と同じ警告が適用されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="4eea6a747947fcb8f655a220c818e740e96ba5d5" translate="yes" xml:space="preserve">
          <source>Notice that the same caveats apply as for &lt;code&gt;&lt;a href=&quot;#garbage_collect-0&quot;&gt;garbage_collect/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#garbage_collect-0&quot;&gt;garbage_collect/0&lt;/a&gt;&lt;/code&gt; と同じ警告が適用されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="fe10cacd28855d9196c579eb8146305f91e16641" translate="yes" xml:space="preserve">
          <source>Notice that the sequences \A, \Z, and \z can be used to match the start and end of the subject in both modes. If all branches of a pattern start with \A, it is always anchored, regardless if &lt;code&gt;multiline&lt;/code&gt; is set.</source>
          <target state="translated">シーケンス\ A、\ Z、および\ zを使用して、両方のモードで件名の開始と終了を一致させることができます。パターンのすべての分岐が\ Aで始まる場合、 &lt;code&gt;multiline&lt;/code&gt; が設定されているかどうかに関係なく、常にアンカーされます。</target>
        </trans-unit>
        <trans-unit id="6724f506b54877b36a23e88d5de227a00d37732a" translate="yes" xml:space="preserve">
          <source>Notice that the shorthand for &lt;code&gt;list()&lt;/code&gt;, that is, the list of elements of unknown type, is &lt;code&gt;[_]&lt;/code&gt; (or &lt;code&gt;[any()]&lt;/code&gt;), not &lt;code&gt;[]&lt;/code&gt;. The notation &lt;code&gt;[]&lt;/code&gt; specifies the singleton type for the empty list.</source>
          <target state="translated">&lt;code&gt;list()&lt;/code&gt; の省略形、つまり不明なタイプの要素のリストは、 &lt;code&gt;[]&lt;/code&gt; ではなく[ &lt;code&gt;[_]&lt;/code&gt; （または &lt;code&gt;[any()]&lt;/code&gt; ）であることに注意してください。表記 &lt;code&gt;[]&lt;/code&gt; は、空のリストのシングルトンタイプを指定します。</target>
        </trans-unit>
        <trans-unit id="73dac804c8d0ac669ce6f4344962d4b5c34961af" translate="yes" xml:space="preserve">
          <source>Notice that the space management data structures kept in RAM, the buddy system, is also written to the disk. This can take some time if the table is fragmented.</source>
          <target state="translated">バディシステムであるRAMに保持されているスペース管理データ構造もディスクに書き込まれていることに注意してください。これは、テーブルが断片化されている場合、時間がかかることがあります。</target>
        </trans-unit>
        <trans-unit id="2158fd0c30567923e783ca815a320fc6fd564c3e" translate="yes" xml:space="preserve">
          <source>Notice that the sum of these values is &lt;strong&gt;not&lt;/strong&gt; the total amount of memory allocated by the emulator. Some values are part of other values, and some memory areas are not part of the result. For information about the total amount of memory allocated by the emulator, see &lt;code&gt;&lt;a href=&quot;#memory-0&quot;&gt; erlang:memory/0,1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">これらの値の合計は、エミュレーターによって割り当てられたメモリーの合計量では&lt;strong&gt;ない&lt;/strong&gt;ことに注意してください。一部の値は他の値の一部であり、一部のメモリ領域は結果の一部ではありません。エミュレータによって割り当てられたメモリの合計量については、 &lt;code&gt;&lt;a href=&quot;#memory-0&quot;&gt; erlang:memory/0,1&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="30f0e9479e312465b9ff5d6f711d535a3e0101b4" translate="yes" xml:space="preserve">
          <source>Notice that the sum of these values is &lt;strong&gt;not&lt;/strong&gt; the total amount of memory allocated by the emulator. Some values are part of other values, and some memory areas are not part of the result. For information about the total amount of memory allocated by the emulator, see &lt;code&gt;&lt;a href=&quot;#memory-0&quot;&gt;erlang:memory/0,1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">これらの値の合計は、エミュレータによって割り当てられたメモリの総量では&lt;strong&gt;ない&lt;/strong&gt;ことに注意してください。一部の値は他の値の一部であり、一部のメモリ領域は結果の一部ではありません。エミュレーターによって割り当てられるメモリーの総量については、 &lt;code&gt;&lt;a href=&quot;#memory-0&quot;&gt;erlang:memory/0,1&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="b5abbe6d966c5fc1edc96d1f28f1436c4958c4e8" translate="yes" xml:space="preserve">
          <source>Notice that the syntactic representation of &lt;code&gt;map()&lt;/code&gt; is &lt;code&gt;#{any() =&amp;gt; any()}&lt;/code&gt; (or &lt;code&gt;#{_ =&amp;gt; _}&lt;/code&gt;), not &lt;code&gt;#{}&lt;/code&gt;. The notation &lt;code&gt;#{}&lt;/code&gt; specifies the singleton type for the empty map.</source>
          <target state="translated">通知の構文表現 &lt;code&gt;map()&lt;/code&gt; である &lt;code&gt;#{any() =&amp;gt; any()}&lt;/code&gt; （または &lt;code&gt;#{_ =&amp;gt; _}&lt;/code&gt; ）ではない &lt;code&gt;#{}&lt;/code&gt; 。表記 &lt;code&gt;#{}&lt;/code&gt; は、空のマップのシングルトンタイプを指定します。</target>
        </trans-unit>
        <trans-unit id="d2c453c4a61a93e0e17811bf7efe3b048abd12f0" translate="yes" xml:space="preserve">
          <source>Notice that the template is here the same as for &lt;code&gt;single_line=false&lt;/code&gt;, but the resulting log entry differs in that there is only one line after the heading:</source>
          <target state="translated">ここではテンプレートは &lt;code&gt;single_line=false&lt;/code&gt; と同じですが、結果のログエントリは、見出しの後に1行しかないという点で異なります。</target>
        </trans-unit>
        <trans-unit id="1a0dfecdaad1fda603fa4229f911e862d71765b6" translate="yes" xml:space="preserve">
          <source>Notice that the time order of object insertions is preserved; the first object inserted with the specified key is the first in the resulting list, and so on.</source>
          <target state="translated">指定したキーで挿入された最初のオブジェクトが結果のリストの最初になります。</target>
        </trans-unit>
        <trans-unit id="6f7067f925d0363a33444938455ac91fcd09edfb" translate="yes" xml:space="preserve">
          <source>Notice that the use of an &lt;code&gt;.inetrc&lt;/code&gt; file, which was supported in earlier Erlang/OTP versions, is now obsolete.</source>
          <target state="translated">以前のErlang / OTPバージョンでサポートされていた &lt;code&gt;.inetrc&lt;/code&gt; ファイルの使用は廃止されました。</target>
        </trans-unit>
        <trans-unit id="b338a89eefab229871069c1f47956c10a1d50274" translate="yes" xml:space="preserve">
          <source>Notice that the value fed into the selective decode functions must be a binary.</source>
          <target state="translated">選択的デコード関数に供給される値はバイナリでなければならないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="787fd319d83681555c07f1a96ca590fc08523120" translate="yes" xml:space="preserve">
          <source>Notice that there is no &quot;;&quot; before &lt;code&gt;end&lt;/code&gt;. Conditions do the same as guards, that is, tests that succeed or fail. Erlang starts at the top and tests until it finds a condition that succeeds. Then it evaluates (performs) the action following the condition and ignores all other conditions and actions before the &lt;code&gt;end&lt;/code&gt;. If no condition matches, a run-time failure occurs. A condition that always succeeds is the atom &lt;code&gt;true&lt;/code&gt;. This is often used last in an &lt;code&gt;if&lt;/code&gt;, meaning, do the action following the &lt;code&gt;true&lt;/code&gt; if all other conditions have failed.</source>
          <target state="translated">「;」がないことに注意してください。 &lt;code&gt;end&lt;/code&gt; する前。条件はガードと同じように機能します。つまり、テストは成功または失敗します。Erlangは先頭から開始して、成功する条件が見つかるまでテストします。次に、条件に続くアクションを評価（実行）し、 &lt;code&gt;end&lt;/code&gt; 前に他のすべての条件とアクションを無視します。一致する条件がない場合、実行時エラーが発生します。常に成功する条件は、アトム &lt;code&gt;true&lt;/code&gt; です。これは多くの &lt;code&gt;if&lt;/code&gt; 、ifの最後に使用され &lt;code&gt;true&lt;/code&gt; つまり、他のすべての条件が失敗した場合に、trueの後にアクションを実行します。</target>
        </trans-unit>
        <trans-unit id="c7902b9db4b62c4e9204bea0b7582aa107cd80a6" translate="yes" xml:space="preserve">
          <source>Notice that there is no &quot;condition variable wait with time-out&quot; in the Erlang driver thread API. This because of issues with &lt;code&gt;pthread_cond_timedwait&lt;/code&gt;. When the system clock suddenly is changed, it is not always guaranteed that you will wake up from the call as expected. An Erlang runtime system must be able to cope with sudden changes of the system clock. Therefore, we have omitted it from the Erlang driver thread API. In the Erlang driver case, time-outs can and are to be handled with the timer functionality of the Erlang driver API.</source>
          <target state="translated">ErlangドライバースレッドAPIには「タイムアウト付きの条件変数待機」がないことに注意してください。これは、 &lt;code&gt;pthread_cond_timedwait&lt;/code&gt; の問題が原因です。システムクロックが突然変更された場合、期待どおりにコールからウェイクアップするとは限りません。 Erlangランタイムシステムは、システムクロックの突然の変化に対応できなければなりません。したがって、ErlangドライバースレッドAPIからは省略しています。 Erlangドライバーの場合、タイムアウトはErlangドライバーAPIのタイマー機能で処理できます。</target>
        </trans-unit>
        <trans-unit id="bceb9f4f6a6abdf1446e121be361b43261feb62c" translate="yes" xml:space="preserve">
          <source>Notice that there is no automatic garbage collection for tables. Even if there are no references to a table from any process, it is not automatically destroyed unless the owner process terminates. To destroy a table explicitly, use function &lt;code&gt;&lt;a href=&quot;#delete-1&quot;&gt;delete/1&lt;/a&gt;&lt;/code&gt;. The default owner is the process that created the table. To transfer table ownership at process termination, use option &lt;code&gt;&lt;a href=&quot;#heir&quot;&gt;heir&lt;/a&gt;&lt;/code&gt; or call &lt;code&gt;&lt;a href=&quot;#give_away-3&quot;&gt;give_away/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">テーブルには自動ガベージコレクションがないことに注意してください。どのプロセスからもテーブルへの参照がない場合でも、所有者プロセスが終了しない限り、テーブルは自動的に破棄されません。テーブルを明示的に破棄するには、関数 &lt;code&gt;&lt;a href=&quot;#delete-1&quot;&gt;delete/1&lt;/a&gt;&lt;/code&gt; を使用します。デフォルトの所有者は、テーブルを作成したプロセスです。プロセスの終了時にテーブルの所有権を転送するには、オプション &lt;code&gt;&lt;a href=&quot;#heir&quot;&gt;heir&lt;/a&gt;&lt;/code&gt; を使用するか、 &lt;code&gt;&lt;a href=&quot;#give_away-3&quot;&gt;give_away/3&lt;/a&gt;&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="8bab5c018b3dd7779861d18a2de3b850779eed22" translate="yes" xml:space="preserve">
          <source>Notice that these results are highly implementation-specific and can change in a future release.</source>
          <target state="translated">これらの結果は非常に実装に特化しており、将来のリリースで変更される可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="869e22e1f3c3acbe1295f4e3f5e543c0967d43d9" translate="yes" xml:space="preserve">
          <source>Notice that these values are not guaranteed to be the exact time spent in each state. This is because of various optimisation done to keep the overhead as small as possible.</source>
          <target state="translated">これらの値は、各状態で費やされた時間を正確に保証するものではないことに注意してください。これは、オーバーヘッドを可能な限り小さくするために様々な最適化が行われているためです。</target>
        </trans-unit>
        <trans-unit id="1b2a4c91cbe5e730d179e66ad334733cf9b2f315" translate="yes" xml:space="preserve">
          <source>Notice that this can cause the message queue to overflow, as there is no way to throttle the sender in this case (no flow control).</source>
          <target state="translated">この場合、送信者をスロットルする方法がないので、これはメッセージキューがオーバーフローする原因となることに注意してください (フローコントロールはありません)。</target>
        </trans-unit>
        <trans-unit id="65c845a0c39116c9a8667488291653cb120ecdb8" translate="yes" xml:space="preserve">
          <source>Notice that this code never uses &lt;code&gt;ets:match/2&lt;/code&gt; but instead uses the &lt;code&gt;ets:lookup/2&lt;/code&gt; call. The &lt;code&gt;lists:map/2&lt;/code&gt; call is only used to traverse the &lt;code&gt;idno&lt;/code&gt;s matching the name &quot;Bryan&quot; in the table; thus the number of lookups in the master table is minimized.</source>
          <target state="translated">このコードは &lt;code&gt;ets:match/2&lt;/code&gt; を使用せず、代わりに &lt;code&gt;ets:lookup/2&lt;/code&gt; 呼び出しを使用していることに注意してください。 &lt;code&gt;lists:map/2&lt;/code&gt; コールだけトラバースするために使用される &lt;code&gt;idno&lt;/code&gt; テーブル内の名前に一致する「ブライアンを」; したがって、マスターテーブルでのルックアップの数は最小限に抑えられます。</target>
        </trans-unit>
        <trans-unit id="642ed222441e7d274dce20239475afe796aa6f92" translate="yes" xml:space="preserve">
          <source>Notice that this does not in any way tell how characters are to be put on the I/O device or handled by the I/O server. Different I/O servers can handle the characters however they want, this only tells the I/O server which format the data is expected to have. In the &lt;code&gt;Module&lt;/code&gt;/&lt;code&gt;Function&lt;/code&gt;/&lt;code&gt;Args&lt;/code&gt; case, &lt;code&gt;Encoding&lt;/code&gt; tells which format the designated function produces.</source>
          <target state="translated">これは、文字がどのようにI / Oデバイスに置かれるか、I / Oサーバーによって処理されるかを示すものではないことに注意してください。さまざまなI / Oサーバーが必要に応じて文字を処理できます。これは、I / Oサーバーにデータが予期する形式を通知するだけです。で &lt;code&gt;Module&lt;/code&gt; / &lt;code&gt;Function&lt;/code&gt; / &lt;code&gt;Args&lt;/code&gt; の場合、 &lt;code&gt;Encoding&lt;/code&gt; 指定された機能が生成するフォーマット指示します。</target>
        </trans-unit>
        <trans-unit id="349cea6fe5b002efa6f13c8a0b6d61002518bac7" translate="yes" xml:space="preserve">
          <source>Notice that this function can also be called as a part of a code upgrade procedure. Therefore, the function is not to have any side effects. For more information about code upgrade of supervisors, see section &lt;code&gt;Changing a Supervisor&lt;/code&gt; in OTP Design Principles.</source>
          <target state="translated">この関数は、コードアップグレード手順の一部として呼び出すこともできます。したがって、この関数には副作用がありません。スーパーバイザのコードアップグレードの詳細については、「OTP設計原則での &lt;code&gt;Changing a Supervisor&lt;/code&gt; 」を参照してください。</target>
        </trans-unit>
        <trans-unit id="d5a602977aaafafa43a23557b7310cdf92b1e9ad" translate="yes" xml:space="preserve">
          <source>Notice that this function does not affect option &lt;code&gt;&lt;a href=&quot;#heir&quot;&gt;heir&lt;/a&gt;&lt;/code&gt; of the table. A table owner can, for example, set &lt;code&gt;heir&lt;/code&gt; to itself, give the table away, and then get it back if the receiver terminates.</source>
          <target state="translated">この関数はテーブルのオプション &lt;code&gt;&lt;a href=&quot;#heir&quot;&gt;heir&lt;/a&gt;&lt;/code&gt; には影響しないことに注意してください。たとえば、テーブルの所有者は、 &lt;code&gt;heir&lt;/code&gt; を自分自身に設定し、テーブルを渡してから、レシーバが終了した場合にそれを取り戻すことができます。</target>
        </trans-unit>
        <trans-unit id="0cb54426795679095e8a29fd043a79047773a14e" translate="yes" xml:space="preserve">
          <source>Notice that this function does not manipulate the Logger configuration directly, meaning that if the default Logger handler is already logging to a file, this function can potentially cause logging to a second file.</source>
          <target state="translated">この関数はロガー設定を直接操作しないことに注意してください。つまり、デフォルトのロガー ハンドラーがすでにファイルにロギングしている場合、この関数は潜在的に 2 番目のファイルにロギングする可能性があることを意味します。</target>
        </trans-unit>
        <trans-unit id="8b7b1e720e05da028ebe3dc53213402e40544038" translate="yes" xml:space="preserve">
          <source>Notice that this function is &lt;strong&gt;not&lt;/strong&gt; thread-safe, not even when the emulator with SMP support is used.</source>
          <target state="translated">この関数は、SMPをサポートするエミュレーターが使用されている場合でも、スレッドセーフでは&lt;strong&gt;ない&lt;/strong&gt;ことに注意してください。</target>
        </trans-unit>
        <trans-unit id="8447f5b25cdb8a2cfab1f25034c52ae944a2138b" translate="yes" xml:space="preserve">
          <source>Notice that this function is located in the &lt;code&gt;Erl_Interface&lt;/code&gt; library.</source>
          <target state="translated">この関数は &lt;code&gt;Erl_Interface&lt;/code&gt; ライブラリにあることに注意してください。</target>
        </trans-unit>
        <trans-unit id="47ba6495ef0d28a812199229a1ffda8befe21e10" translate="yes" xml:space="preserve">
          <source>Notice that this function must only be used to connect to newly started RAM nodes (N.D.R.S.N.) with an empty schema. If, for example, this function is used after the network has been partitioned, it can lead to inconsistent tables.</source>
          <target state="translated">この関数は、空のスキーマで新たに起動されたRAMノード(N.D.R.S.N.)に接続するためにのみ使用する必要があることに注意してください。例えば、ネットワークが分割された後にこの関数を使用すると、テーブルの整合性が取れなくなる可能性があります。</target>
        </trans-unit>
        <trans-unit id="2a0080e2dd941529f19011486ca16886c12b3f0d" translate="yes" xml:space="preserve">
          <source>Notice that this identifier on occations has been called &quot;name&quot;. As far as possible, the terms &quot;identifier&quot; or &quot;id&quot; are now used but to keep backward compatibility, some occurences of &quot;name&quot; can still be found, for example in error messages.</source>
          <target state="translated">この識別子が &quot;name &quot;と呼ばれることがあることに注意してください。可能な限り、現在では &quot;identifier &quot;または &quot;id &quot;という用語が使われていますが、 後方互換性を保つために、エラーメッセージなどで &quot;name &quot;が使われていることがあります。</target>
        </trans-unit>
        <trans-unit id="d730d26eb5bc6c258ec3f4a85decab69ff65e557" translate="yes" xml:space="preserve">
          <source>Notice that this is &lt;strong&gt;not&lt;/strong&gt; equivalent to reversing the result list of a &lt;code&gt;select/3&lt;/code&gt; call, as the result list is not only reversed, but also contains the last &lt;code&gt;Limit&lt;/code&gt; matching objects in the table, not the first.</source>
          <target state="translated">これは、 &lt;code&gt;select/3&lt;/code&gt; 呼び出しの結果リストを元に戻すのと同じでは&lt;strong&gt;ない&lt;/strong&gt;ことに注意してください。結果リストは元に戻されるだけでなく、最初のテーブルではなく最後の &lt;code&gt;Limit&lt;/code&gt; 一致オブジェクトも含まれているためです。</target>
        </trans-unit>
        <trans-unit id="70914725ae02a1a2e612f1b985dfda4ff43284f0" translate="yes" xml:space="preserve">
          <source>Notice that this is &lt;strong&gt;not&lt;/strong&gt; guaranteed for Kernel versions before 2.11.4.</source>
          <target state="translated">これは、2.11.4より前のカーネルバージョンで&lt;strong&gt;は&lt;/strong&gt;保証され&lt;strong&gt;ない&lt;/strong&gt;ことに注意してください。</target>
        </trans-unit>
        <trans-unit id="7dcda89d0c9ebc603749979d693cfd0901ccfd8f" translate="yes" xml:space="preserve">
          <source>Notice that this is &lt;strong&gt;not&lt;/strong&gt; guaranteed for Kernel versions before 2.13.</source>
          <target state="translated">これは2.13より前のカーネルバージョンで&lt;strong&gt;は&lt;/strong&gt;保証されて&lt;strong&gt;いない&lt;/strong&gt;ことに注意してください。</target>
        </trans-unit>
        <trans-unit id="ebcfa6b14e436143f912db1c4d94b897ad5c396b" translate="yes" xml:space="preserve">
          <source>Notice that this is a snapshot of what the entries are exactly when the crash dump is starting to be generated. Therefore they are most likely different (and more telling) than the entries for the same processes found in the &lt;strong&gt;=proc&lt;/strong&gt; section. If there is no currently running process, only the &lt;strong&gt;Current Process&lt;/strong&gt; entry is shown.</source>
          <target state="translated">これは、クラッシュダンプが生成され始めたときのエントリのスナップショットであることに注意してください。したがって、これらは、&lt;strong&gt;= proc&lt;/strong&gt;セクションにある同じプロセスのエントリとは異なる可能性が高く（わかりやすく）ます。現在実行中のプロセスがない場合は、&lt;strong&gt;現在のプロセスの&lt;/strong&gt;エントリのみが表示されます。</target>
        </trans-unit>
        <trans-unit id="6b5fe898d5908bd62ba390154dbda59785193315" translate="yes" xml:space="preserve">
          <source>Notice that this list was so long that it did not fit on one line. This does not matter, Erlang allows line breaks at all &quot;sensible places&quot; but not, for example, in the middle of atoms, integers, and others.</source>
          <target state="translated">このリストはとても長くて1行に収まらないことに注意してください。これは問題ではありません。Erlangではすべての &quot;センスのある場所 &quot;での改行は可能ですが、例えば原子や整数などの途中での改行はできません。</target>
        </trans-unit>
        <trans-unit id="bed5f26c2d951298be832ad680fbfcde5f6d0366" translate="yes" xml:space="preserve">
          <source>Notice that this only affects &lt;strong&gt;heuristic&lt;/strong&gt; interpretation of lists and binaries on output. For example, the &lt;code&gt;~ts&lt;/code&gt; format sequence always outputs a valid list of characters, regardless of the &lt;code&gt;+pc&lt;/code&gt; setting, as the programmer has explicitly requested string output.</source>
          <target state="translated">これは、出力のリストとバイナリの&lt;strong&gt;ヒューリスティック&lt;/strong&gt;解釈にのみ影響することに注意してください。たとえば、プログラマが明示的に文字列出力を要求したため、 &lt;code&gt;+pc&lt;/code&gt; &lt;code&gt;~ts&lt;/code&gt; 設定シーケンスは、+ pc設定に関係なく、常に有効な文字のリストを出力します。</target>
        </trans-unit>
        <trans-unit id="06bbb7eb9157769ac232caf919df5223a21c5714" translate="yes" xml:space="preserve">
          <source>Notice that this option does not change any guarantees about &lt;code&gt;&lt;a href=&quot;#concurrency&quot;&gt;atomicity and isolation&lt;/a&gt;&lt;/code&gt;. Functions that makes such promises over many objects (like &lt;code&gt;&lt;a href=&quot;#insert-2&quot;&gt;insert/2&lt;/a&gt;&lt;/code&gt;) gain less (or nothing) from this option.</source>
          <target state="translated">このオプションは、 &lt;code&gt;&lt;a href=&quot;#concurrency&quot;&gt;atomicity and isolation&lt;/a&gt;&lt;/code&gt; に関する保証を変更しないことに注意してください。多くのオブジェクト（ &lt;code&gt;&lt;a href=&quot;#insert-2&quot;&gt;insert/2&lt;/a&gt;&lt;/code&gt; など）に対してこのようなプロミスを行う関数は、このオプションから得られる効果が少ない（または何もない）。</target>
        </trans-unit>
        <trans-unit id="621939df6e7634c47047d2e081590d78eaf11831" translate="yes" xml:space="preserve">
          <source>Notice that this part ends with a &quot;.&quot; saying that there are no more parts of this function.</source>
          <target state="translated">この部分は「.&quot;」で終わっていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="e6c419f8334737f0ba7bd3fd865a876302c62640" translate="yes" xml:space="preserve">
          <source>Notice that this part ends with a semicolon &quot;;&quot; that indicates that there is more of the function &lt;code&gt;fac&amp;gt;&lt;/code&gt; to come.</source>
          <target state="translated">この部分はセミコロン「;」で終わることに注意してください。これは、来るべき関数 &lt;code&gt;fac&amp;gt;&lt;/code&gt; がもっとあることを示しています。</target>
        </trans-unit>
        <trans-unit id="846082f1f38f9d35784642322c9bebfb5b6dff1c" translate="yes" xml:space="preserve">
          <source>Notice that this state diagram does not specify how to handle a button event in the state &lt;code&gt;open&lt;/code&gt;. So, you need to read in some side notes, that is, here: that unspecified events shall be postponed (handled in some later state). Also, the state diagram does not show that the &lt;code&gt;code_length/0&lt;/code&gt; call must be handled in every state.</source>
          <target state="translated">この状態図は、状態 &lt;code&gt;open&lt;/code&gt; でボタンイベントを処理する方法を指定していないことに注意してください。したがって、いくつかのサイドノートを読む必要があります。つまり、ここでは、指定されていないイベントは延期されることになります（後の状態で処理されます）。また、状態図には、 &lt;code&gt;code_length/0&lt;/code&gt; 呼び出しをすべての状態で処理する必要があることが示されていません。</target>
        </trans-unit>
        <trans-unit id="6d7cfe9a38358e1080d2e905013781b2b4b7296d" translate="yes" xml:space="preserve">
          <source>Notice that type &lt;code&gt;ordered_set&lt;/code&gt; in Ets is not yet provided by Dets, neither is the limited support for concurrent updates that makes a sequence of &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;next&lt;/code&gt; calls safe to use on fixed ETS tables. Both these features may be provided by Dets in a future release of Erlang/OTP. Until then, the Mnesia application (or some user-implemented method for locking) must be used to implement safe concurrency. Currently, no Erlang/OTP library has support for ordered disk-based term storage.</source>
          <target state="translated">Etsのタイプ &lt;code&gt;ordered_set&lt;/code&gt; はDetsによってまだ提供されていないことに注意してください。また、一連の &lt;code&gt;first&lt;/code&gt; と &lt;code&gt;next&lt;/code&gt; 呼び出しを固定ETSテーブルで安全に使用できるようにする同時更新の制限付きサポートもありません。これらの機能は両方とも、Erlang / OTPの将来のリリースでDetsによって提供される可能性があります。それまでは、安全な同時実行性を実装するために、Mnesiaアプリケーション（またはユーザーが実装したロックのメソッド）を使用する必要があります。現在、Erlang / OTPライブラリは、注文されたディスクベースの用語ストレージをサポートしていません。</target>
        </trans-unit>
        <trans-unit id="49a7a915aea8e9d41179a8ea113e08f2ef1a2887" translate="yes" xml:space="preserve">
          <source>Notice that we only return data (with &lt;code&gt;driver_output&lt;/code&gt;) if there is an error here, otherwise we wait for the connection to be completed, in which case our &lt;code&gt;ready_io&lt;/code&gt; function is called.</source>
          <target state="translated">ここでエラーが発生した場合にのみ（ &lt;code&gt;driver_output&lt;/code&gt; を使用して）データを返すことに注意してください。それ以外の場合は、接続が完了するのを待ちます。この場合、 &lt;code&gt;ready_io&lt;/code&gt; 関数が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="ecb8672fadbd7174fe3603f747f5dd084a5c8a1f" translate="yes" xml:space="preserve">
          <source>Notice that when calling a local function, there is a difference between using the implicitly or fully qualified function name. The latter always refers to the latest version of the module. See &lt;code&gt;&lt;a href=&quot;code_loading&quot;&gt;Compilation and Code Loading &lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions#eval&quot;&gt; Function Evaluation&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ローカル関数を呼び出す場合、暗黙的または完全修飾関数名を使用することには違いがあることに注意してください。後者は常にモジュールの最新バージョンを指します。 &lt;code&gt;&lt;a href=&quot;code_loading&quot;&gt;Compilation and Code Loading &lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;functions#eval&quot;&gt; Function Evaluation&lt;/a&gt;&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="f51f3b121bba411146620bcda978e5f491550a29" translate="yes" xml:space="preserve">
          <source>Notice that when calling a local function, there is a difference between using the implicitly or fully qualified function name. The latter always refers to the latest version of the module. See &lt;code&gt;&lt;a href=&quot;code_loading&quot;&gt;Compilation and Code Loading&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions#eval&quot;&gt;Function Evaluation&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ローカル関数を呼び出すときは、暗黙的または完全修飾の関数名を使用することに違いがあることに注意してください。後者は常にモジュールの最新バージョンを指します。 &lt;code&gt;&lt;a href=&quot;code_loading&quot;&gt;Compilation and Code Loading&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;functions#eval&quot;&gt;Function Evaluation&lt;/a&gt;&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="5f8b34f22954b45969704565ba857ede0360296a" translate="yes" xml:space="preserve">
          <source>Notice that when changing the configuration of the handler in runtime, the disk_log options (&lt;code&gt;file&lt;/code&gt;, &lt;code&gt;type&lt;/code&gt;, &lt;code&gt;max_no_files&lt;/code&gt;, &lt;code&gt;max_no_bytes&lt;/code&gt;) must not be modified.</source>
          <target state="translated">実行時にハンドラーの構成を変更するときは、disk_logオプション（ &lt;code&gt;file&lt;/code&gt; 、 &lt;code&gt;type&lt;/code&gt; 、 &lt;code&gt;max_no_files&lt;/code&gt; 、 &lt;code&gt;max_no_bytes&lt;/code&gt; ）を変更しないでください。</target>
        </trans-unit>
        <trans-unit id="290de7804d4ece9b07b182bd6263d67e874d7ab3" translate="yes" xml:space="preserve">
          <source>Notice that when manipulating the PLT, no warnings are emitted. To turn on warnings during (re)analysis of the PLT, use option &lt;code&gt;--get_warnings&lt;/code&gt;.</source>
          <target state="translated">PLTを操作するとき、警告は出されないことに注意してください。PLTの（再）分析中に警告をオンにするには、オプション &lt;code&gt;--get_warnings&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="45a6c9cf395e353cb2306cbfdb89cfe2d26435a1" translate="yes" xml:space="preserve">
          <source>Notice that when multiple event handlers are invoked, it is sufficient that one single event handler returns a &lt;code&gt;hibernate&lt;/code&gt; request for the whole event manager to go into hibernation.</source>
          <target state="translated">複数のイベントハンドラーが呼び出された場合、1つの単一のイベントハンドラーが &lt;code&gt;hibernate&lt;/code&gt; イベントマネージャー全体が休止状態になるための休止状態要求を。</target>
        </trans-unit>
        <trans-unit id="f33a5a292b9691e53af0ea35251a90bd5b70c0ab" translate="yes" xml:space="preserve">
          <source>Notice that when the restart strategy is &lt;code&gt;simple_one_for_one&lt;/code&gt;, the list of child specifications must be a list with one child specification only. (The child specification identifier is ignored.) No child process is then started during the initialization phase, but all children are assumed to be started dynamically using &lt;code&gt;&lt;a href=&quot;#start_child-2&quot;&gt;start_child/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">再起動戦略が &lt;code&gt;simple_one_for_one&lt;/code&gt; の場合、子仕様のリストは、1つの子仕様のみのリストでなければならないことに注意してください。 （子仕様識別子は無視されます。）その後、初期化フェーズ中に子プロセスは開始されませんが、すべての子は &lt;code&gt;&lt;a href=&quot;#start_child-2&quot;&gt;start_child/2&lt;/a&gt;&lt;/code&gt; を使用して動的に開始されると想定されます。</target>
        </trans-unit>
        <trans-unit id="9634bd19d38caf45acf63a0abbac721e5ae1181a" translate="yes" xml:space="preserve">
          <source>Notice that you do not have to worry about the order you assign values to the various parts of the records when you create it. The advantage of using records is that by placing their definitions in header files you can conveniently define interfaces that are easy to change. For example, if you want to add a new field to the record, you only have to change the code where the new field is used and not at every place the record is referred to. If you leave out a field when creating a record, it gets the value of the atom &lt;code&gt;undefined&lt;/code&gt;. (*manual*)</source>
          <target state="translated">レコードを作成するときに、レコードのさまざまな部分に値を割り当てる順序を気にする必要がないことに注意してください。レコードを使用する利点は、その定義をヘッダーファイルに配置することで、変更が簡単なインターフェイスを簡単に定義できることです。たとえば、新しいフィールドをレコードに追加する場合は、レコードが参照されるすべての場所ではなく、新しいフィールドが使用されるコードを変更するだけで済みます。レコードを作成するときにフィールドを省略すると、アトム &lt;code&gt;undefined&lt;/code&gt; の値が取得されます。（*マニュアル*）</target>
        </trans-unit>
        <trans-unit id="11459bdda73f31f4f445b7c1dd521d4fd85a0493" translate="yes" xml:space="preserve">
          <source>Notice that, as shown in this example, two or more adjacent separator characters in &lt;code&gt;String&lt;/code&gt; are treated as one. That is, there are no empty strings in the resulting list of tokens.</source>
          <target state="translated">この例に示すように、 &lt;code&gt;String&lt;/code&gt; 内の隣接する2つ以上の区切り文字は1つとして扱われることに注意してください。つまり、結果のトークンのリストに空の文字列はありません。</target>
        </trans-unit>
        <trans-unit id="e5f78a295d4a14f6cc590b49dc6f1d0455cd3aab" translate="yes" xml:space="preserve">
          <source>Notice that, as shown in this example, two or more adjacent separator graphemes clusters in &lt;code&gt;String&lt;/code&gt; are treated as one. That is, there are no empty strings in the resulting list of lexemes. See also &lt;code&gt;&lt;a href=&quot;#split-3&quot;&gt;split/3&lt;/a&gt;&lt;/code&gt; which returns empty strings.</source>
          <target state="translated">この例に示すように、 &lt;code&gt;String&lt;/code&gt; 内の隣接する2つ以上のセパレータグラフェンクラスタは1つとして扱われることに注意してください。つまり、結果の語彙素のリストに空の文字列はありません。こちらもご覧ください &lt;code&gt;&lt;a href=&quot;#split-3&quot;&gt;split/3&lt;/a&gt;&lt;/code&gt; 空の文字列を返す split / 3。</target>
        </trans-unit>
        <trans-unit id="400b0bdc7183dd864f7a333eda26b469890b40f9" translate="yes" xml:space="preserve">
          <source>Notice that, for example, using a string literal as in &lt;code&gt;&amp;lt;&amp;lt;&quot;abc&quot;&amp;gt;&amp;gt;&lt;/code&gt; is syntactic sugar for &lt;code&gt;&amp;lt;&amp;lt;$a,$b,$c&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">たとえば、 &lt;code&gt;&amp;lt;&amp;lt;&quot;abc&quot;&amp;gt;&amp;gt;&lt;/code&gt; ように文字列リテラルを使用すると、 &lt;code&gt;&amp;lt;&amp;lt;$a,$b,$c&amp;gt;&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="87029cbee6aaa0d9b300e7ad0b9486370e279d2c" translate="yes" xml:space="preserve">
          <source>Notice that, using the binary syntax in Erlang, the driver application can match the header directly from the binary, so the header can be put in the binary, and &lt;code&gt;hlen&lt;/code&gt; can be set to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Erlangのバイナリ構文を使用すると、ドライバーアプリケーションはヘッダーをバイナリーから直接照合できるため、ヘッダーをバイナリーに入れることができ、 &lt;code&gt;hlen&lt;/code&gt; ことができを &lt;code&gt;0&lt;/code&gt; に設定できます。</target>
        </trans-unit>
        <trans-unit id="7da0c41f09ad9eda092e8aa0b243d52520a156af" translate="yes" xml:space="preserve">
          <source>Notice the &lt;code&gt;--&lt;/code&gt; delimiter in the second case.</source>
          <target state="translated">に注意してください &lt;code&gt;--&lt;/code&gt; 2番目のケースの-区切り文字に。</target>
        </trans-unit>
        <trans-unit id="0a1c8d08a9994e288f56b821c9bf285da6f45d73" translate="yes" xml:space="preserve">
          <source>Notice the following:</source>
          <target state="translated">以下のようなことをお知らせします。</target>
        </trans-unit>
        <trans-unit id="d17e22e8a0b70553ac1713fc5aa1e39228341be7" translate="yes" xml:space="preserve">
          <source>Notice the introduction of decimals (floating point numbers) without any explanation. Hopefully you can cope with that.</source>
          <target state="translated">何の説明もなく小数(浮動小数点数)が導入されていることに注目してください。うまくいけば、それに対処できるでしょう。</target>
        </trans-unit>
        <trans-unit id="b434bf92c1158275f129698bacaf4280054d4c1a" translate="yes" xml:space="preserve">
          <source>Notice the order, the &lt;code&gt;&lt;a href=&quot;uri_string#normalize-2&quot;&gt;uri_string:normalize(URIMap, [return_map])&lt;/a&gt;&lt;/code&gt; that we used many times in this user guide is a shortcut in the normalization process returning the intermediate datastructure, and allowing us to inspect and apply further decoding on the remaining percent-encoded triplets.</source>
          <target state="translated">このユーザーガイドで何度も使用した &lt;code&gt;&lt;a href=&quot;uri_string#normalize-2&quot;&gt;uri_string:normalize(URIMap, [return_map])&lt;/a&gt;&lt;/code&gt; は、中間データ構造を返す正規化プロセスのショートカットであり、残りのパーセントを検査してさらにデコードを適用できるようにする順序に注意してください。エンコードされたトリプレット。</target>
        </trans-unit>
        <trans-unit id="b22b470f990ba70d08ad30ea4441dbab4491e4f1" translate="yes" xml:space="preserve">
          <source>Notice the subtle difference between &lt;strong&gt;matching&lt;/strong&gt; and &lt;strong&gt;comparing equal&lt;/strong&gt;, which is demonstrated by table types &lt;code&gt;set&lt;/code&gt; and &lt;code&gt;ordered_set&lt;/code&gt;:</source>
          <target state="translated">&lt;strong&gt;equalの&lt;/strong&gt;&lt;strong&gt;照合&lt;/strong&gt;と&lt;strong&gt;比較の&lt;/strong&gt;わずかな違いに注意してください。これは、テーブルタイプ &lt;code&gt;set&lt;/code&gt; によって示されます。と &lt;code&gt;ordered_set&lt;/code&gt; で。</target>
        </trans-unit>
        <trans-unit id="e087413bca56723a464e980cdc7148c95c96c9f5" translate="yes" xml:space="preserve">
          <source>Notice the tags &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt;, which are used in the cover specification file and in the call to &lt;code&gt;ct_cover:cross_cover_analyse/2&lt;/code&gt;. The purpose of these is only to map the modules specified in the cover specification to the log directory specified in the call to the analyze function. The tag name has no meaning beyond this.</source>
          <target state="translated">タグ &lt;code&gt;s1&lt;/code&gt; と &lt;code&gt;s2&lt;/code&gt; に注意してください。これらはカバー仕様ファイルと次の呼び出しで使用されています。 &lt;code&gt;ct_cover:cross_cover_analyse/2&lt;/code&gt; の。これらの目的は、カバー仕様で指定されたモジュールを、analyze関数の呼び出しで指定されたログディレクトリにマップすることだけです。タグ名はこれ以上の意味はありません。</target>
        </trans-unit>
        <trans-unit id="7bb5bf565c03d21576042d149b51f71aca7f2ad7" translate="yes" xml:space="preserve">
          <source>Notice the use of brackets, the multiplication operator &quot;*&quot;, and the division operator &quot;/&quot;, as in normal arithmetic (see &lt;code&gt;Expressions&lt;/code&gt;).</source>
          <target state="translated">通常の算術演算と同様に、括弧、乗算演算子「*」、および除算演算子「/」の使用に注意してください（ &lt;code&gt;Expressions&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="1979d8b27f27698155a9b9f97c8dffec78cf1316" translate="yes" xml:space="preserve">
          <source>Notice there is no &quot;;&quot; before the &lt;code&gt;end&lt;/code&gt;.</source>
          <target state="translated">「;」がないことに注意してください。の前に &lt;code&gt;end&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b65c33941f0cec9bcc2027c063047fa6bab510b7" translate="yes" xml:space="preserve">
          <source>Notice, however, that the PCRE interpretation of \G, as the start of the current match, is subtly different from Perl, which defines it as the end of the previous match. In Perl, these can be different when the previously matched string was empty. As PCRE does only one match at a time, it cannot reproduce this behavior.</source>
          <target state="translated">ただし、現在のマッチの開始点としての \G の PCRE の解釈は、前のマッチの終了点として定義する Perl とは微妙に異なっていることに注意してください。Perl では、前にマッチした文字列が空だった場合、これらの解釈が異なることがあります。PCRE は一度に 1 つのマッチしか行わないので、この動作を再現することはできません。</target>
        </trans-unit>
        <trans-unit id="741d95219191f3fd87708b3b502f3129d86f5b91" translate="yes" xml:space="preserve">
          <source>Notification Filters</source>
          <target state="translated">通知フィルタ</target>
        </trans-unit>
        <trans-unit id="0bc912e028896fb2120e68a26a7e2cec85b39064" translate="yes" xml:space="preserve">
          <source>Notification Sending</source>
          <target state="translated">通知送信</target>
        </trans-unit>
        <trans-unit id="37be39660f9e3a6ee200e243af96a9c97d0d2344" translate="yes" xml:space="preserve">
          <source>Notifications are defined in SMIv1 with the TRAP-TYPE macro in the definition of an MIB (see RFC1215). The corresponding macro in SMIv2 is NOTIFICATION-TYPE. When an application decides to send a notification, it calls one of the following functions:</source>
          <target state="translated">通知は、SMIv1ではMIBの定義(RFC1215参照)のTRAP-TYPEマクロで定義されている。SMIv2の対応するマクロはNOTIFICATION-TYPEである。アプリケーションが通知を送信することを決定したとき、アプリケーションは以下の関数のいずれかを呼び出す。</target>
        </trans-unit>
        <trans-unit id="ac878d4197ecf46f67e006f7c94c70eec1e149de" translate="yes" xml:space="preserve">
          <source>Notifications/traps from an agent is delivered to the user that did the registration.</source>
          <target state="translated">登録したユーザーにエージェントからの通知・トラップが配信されます。</target>
        </trans-unit>
        <trans-unit id="317ade20c16481c20d662a3475f005419790a5e3" translate="yes" xml:space="preserve">
          <source>Notifies when the driver is reloaded (or loaded if loading is underway). It only makes sense to monitor drivers that are in the process of being loaded or reloaded. A future driver name for loading cannot be monitored. That only results in a &lt;code&gt;DOWN&lt;/code&gt; message sent immediately. Monitoring for loading is therefore most useful when triggered by function &lt;code&gt;&lt;a href=&quot;#try_load-3&quot;&gt;try_load/3&lt;/a&gt;&lt;/code&gt;, where the monitor is created &lt;strong&gt;because&lt;/strong&gt; the driver is in such a pending state.</source>
          <target state="translated">ドライバーが再ロードされたとき（またはロードが進行中の場合はロードされたとき）に通知します。ロード中またはリロード中のドライバーを監視することは意味があります。ロードする将来のドライバー名は監視できません。その結果、 &lt;code&gt;DOWN&lt;/code&gt; メッセージがすぐに送信されます。したがって、ロードの監視は、ドライバーがそのような保留状態にある&lt;strong&gt;ために&lt;/strong&gt;モニターが作成される関数 &lt;code&gt;&lt;a href=&quot;#try_load-3&quot;&gt;try_load/3&lt;/a&gt;&lt;/code&gt; によってトリガーされた場合に最も役立ちます。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bb6282907337e9abaf6ab3833a675724d09d4658" translate="yes" xml:space="preserve">
          <source>Now &quot;Stack needed&quot; and &quot;Heap needed&quot; are in the same word.</source>
          <target state="translated">これで「スタックが必要」と「ヒープが必要」は同じ言葉になりました。</target>
        </trans-unit>
        <trans-unit id="819549857bd0aea6faaa47a0d86a011bee67d2a5" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;A&lt;/code&gt; has generated a digest and its own challenge. Those are sent together in a package to &lt;code&gt;B&lt;/code&gt;:</source>
          <target state="translated">これで、 &lt;code&gt;A&lt;/code&gt; はダイジェストと独自のチャレンジを生成しました。それらはパッケージで一緒に &lt;code&gt;B&lt;/code&gt; に送られます。</target>
        </trans-unit>
        <trans-unit id="70500b06f7a8c7563bdbdac912b202c3e8bf3468" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;complex1:foo/1&lt;/code&gt; and &lt;code&gt;complex1:bar/1&lt;/code&gt; can be implemented. Both send a message to the &lt;code&gt;complex&lt;/code&gt; process and receive the following replies:</source>
          <target state="translated">これで、 &lt;code&gt;complex1:foo/1&lt;/code&gt; および &lt;code&gt;complex1:bar/1&lt;/code&gt; を実装できます。両方にメッセージを送信します &lt;code&gt;complex&lt;/code&gt; プロセスに、次の応答を受け取ります。</target>
        </trans-unit>
        <trans-unit id="afe7e60fc725dac4a8db204c6383ede32658e8ba" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;complex5:foo/1&lt;/code&gt; and &lt;code&gt;complex5:bar/1&lt;/code&gt; can be implemented. Both send a message to the &lt;code&gt;complex&lt;/code&gt; process and receive the following reply:</source>
          <target state="translated">これで、 &lt;code&gt;complex5:foo/1&lt;/code&gt; および &lt;code&gt;complex5:bar/1&lt;/code&gt; を実装できます。どちらも &lt;code&gt;complex&lt;/code&gt; プロセスにメッセージを送信し、次の応答を受け取ります。</target>
        </trans-unit>
        <trans-unit id="1d972f3ac97809e6ef3b16135443e10b7f75eb60" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;format_temps(Rest)&lt;/code&gt; is called with the rest of the list as an argument. This way of doing things is similar to the loop constructs in other languages. (Yes, this is recursion, but do not let that worry you.) So the same &lt;code&gt;format_temps&lt;/code&gt; function is called again, this time &lt;code&gt;City&lt;/code&gt; gets the value &lt;code&gt;{cape_town,{f,70}}&lt;/code&gt; and the same procedure is repeated as before. This is done until the list becomes empty, that is [], which causes the first clause &lt;code&gt;format_temps([])&lt;/code&gt; to match. This simply returns (results in) the atom &lt;code&gt;ok&lt;/code&gt;, so the program ends.</source>
          <target state="translated">これで、 &lt;code&gt;format_temps(Rest)&lt;/code&gt; がリストの残りの部分を引数として呼び出されます。この方法は、他の言語のループ構造に似ています。（はい、これは再帰ですが心配する必要はありません。）したがって、同じ &lt;code&gt;format_temps&lt;/code&gt; 関数が再度呼び出され、今度は &lt;code&gt;City&lt;/code&gt; が値 &lt;code&gt;{cape_town,{f,70}}&lt;/code&gt; を取得し、同じ手順が以前と同じように繰り返されます。これは、リストが空になるまで、つまり[]になるまで行われます。これにより、最初の句 &lt;code&gt;format_temps([])&lt;/code&gt; が一致します。これは単にアトムを返す（結果） &lt;code&gt;ok&lt;/code&gt; をため、プログラムは終了します。</target>
        </trans-unit>
        <trans-unit id="f056c1e349914f861b0ec8d256143b66ef033fa2" translate="yes" xml:space="preserve">
          <source>Now Peter logs on at c1@bilbo:</source>
          <target state="translated">ピーターはc1@bilboでログインしています。</target>
        </trans-unit>
        <trans-unit id="3ad12f32c3c04aabc045c91300983e1a4fd664c4" translate="yes" xml:space="preserve">
          <source>Now Peter sends Fred a message:</source>
          <target state="translated">今、ピーターはフレッドにメッセージを送っています。</target>
        </trans-unit>
        <trans-unit id="229ad98b8db4a57370d88832d5c57bc6f3753fe1" translate="yes" xml:space="preserve">
          <source>Now a function has to be added to find the cities with the maximum and minimum temperatures. The following program is not the most efficient way of doing this as you walk through the list of cities four times. But it is better to first strive for clarity and correctness and to make programs efficient only if needed.</source>
          <target state="translated">これで、最高気温と最低気温の都市を見つける機能を追加しなければなりません。以下のプログラムは、都市のリストを4回歩くので、最も効率的な方法ではありません。しかし,まず明確さと正確さを追求し,必要な場合にのみ効率的なプログラムを作ることを心がけた方がよいでしょう.</target>
        </trans-unit>
        <trans-unit id="b4bcc5baaf2e6bf86762a62f818283a767c38c4d" translate="yes" xml:space="preserve">
          <source>Now an &lt;code&gt;ETERM&lt;/code&gt; struct that represents the integer result can be constructed using the function &lt;code&gt;erl_mk_int()&lt;/code&gt; from &lt;code&gt;erl_eterm&lt;/code&gt;. The function &lt;code&gt;erl_format()&lt;/code&gt; from the module &lt;code&gt;erl_format&lt;/code&gt; can also be used:</source>
          <target state="translated">今 &lt;code&gt;ETERM&lt;/code&gt; の整数結果を表す構造体は、関数用いて構築することができる &lt;code&gt;erl_mk_int()&lt;/code&gt; をから &lt;code&gt;erl_eterm&lt;/code&gt; 。モジュール &lt;code&gt;erl_format&lt;/code&gt; の関数 &lt;code&gt;erl_format()&lt;/code&gt; も使用できます。</target>
        </trans-unit>
        <trans-unit id="0d18575f2f97b95d7041b4a039a472881d09e334" translate="yes" xml:space="preserve">
          <source>Now an example of the ping pong example using links to terminate &quot;pong&quot;:</source>
          <target state="translated">では、「ポン」を終了させるためのリンクを使ったピンポンの例です。</target>
        </trans-unit>
        <trans-unit id="b5cee5cfc515b6296349cc8ee7e0cb8ec6901dca" translate="yes" xml:space="preserve">
          <source>Now an example of this when working with lists - reversing the order of a list:</source>
          <target state="translated">リストを扱うときの例として、リストの順序を逆にしてみましょう。</target>
        </trans-unit>
        <trans-unit id="df7fd43be1dfcb89d9363916c80f74e8a91feb79" translate="yes" xml:space="preserve">
          <source>Now assume that the interpretation of &lt;code&gt;Expression&lt;/code&gt; is a set of calls. If the named type is more general than the expression type, say &lt;code&gt;Mod&lt;/code&gt; and &lt;code&gt;Fun&lt;/code&gt; respectively, then the interpretation of the cast expression is the set of calls (M1, M2) such that the interpretation of the expression contains a call from some function of M1 to some function of M2. If the named type is more special than the expression type, say &lt;code&gt;Fun&lt;/code&gt; and &lt;code&gt;Mod&lt;/code&gt;, then the interpretation is the set of all function calls (F1, F2) such that the interpretation of the expression contains a call (M1, M2) and F1 is a function of M1 and F2 is a function of M2 (in &lt;code&gt;modules&lt;/code&gt; mode, there are no functions calls, so a cast to &lt;code&gt;Fun&lt;/code&gt; always yields an empty set). Again, the conversions to and from applications and releases work analogously.</source>
          <target state="translated">次に、 &lt;code&gt;Expression&lt;/code&gt; の解釈が一連の呼び出しであると仮定します。名前付きの型が式の型よりも一般的である場合（それぞれ &lt;code&gt;Mod&lt;/code&gt; と &lt;code&gt;Fun&lt;/code&gt; など）、キャスト式の解釈は一連の呼び出し（M1、M2）であり、式の解釈にはM1の関数からの呼び出しが含まれます。 M2のいくつかの機能に。名前付きの型が式の型よりも特別である場合（ &lt;code&gt;Fun&lt;/code&gt; や &lt;code&gt;Mod&lt;/code&gt; など）、解釈はすべての関数呼び出し（F1、F2）のセットであり、式の解釈には呼び出し（M1、M2）が含まれ、F1はM1とF2の関数はM2の関数です（ &lt;code&gt;modules&lt;/code&gt; モードでは、関数呼び出しがないため、 &lt;code&gt;Fun&lt;/code&gt; は常に空のセットを生成します）。繰り返しになりますが、アプリケーションやリリースとの間の変換は同様に機能します。</target>
        </trans-unit>
        <trans-unit id="d27e97cc64e73bbb29e8593d9319f121ee940fec" translate="yes" xml:space="preserve">
          <source>Now back to the ping pong example.</source>
          <target state="translated">さて、ピンポンの例に戻ります。</target>
        </trans-unit>
        <trans-unit id="e1c4d378028d5d21080c935ee35d85591b2310e0" translate="yes" xml:space="preserve">
          <source>Now change directory into the base directory and set the &lt;code&gt;$ERL_TOP&lt;/code&gt; variable.</source>
          <target state="translated">次に、ディレクトリをベースディレクトリに変更し、 &lt;code&gt;$ERL_TOP&lt;/code&gt; 変数を設定します。</target>
        </trans-unit>
        <trans-unit id="8740487b8c6e4f56dfebcaaf8cf6bd3325bab300" translate="yes" xml:space="preserve">
          <source>Now for a larger example to consolidate what you have learnt so far. Assume that you have a list of temperature readings from a number of cities in the world. Some of them are in Celsius and some in Fahrenheit (as in the previous list). First let us convert them all to Celsius, then let us print the data neatly.</source>
          <target state="translated">さて、これまでに学んだことをまとめるために、もっと大きな例を挙げてみましょう。世界のいくつかの都市の気温のリストを持っているとしましょう。その中のいくつかは摂氏であり、いくつかは華氏である(先ほどのリストのように)。まず,それらをすべて摂氏に変換してから,データをきれいに印刷してみましょう.</target>
        </trans-unit>
        <trans-unit id="960dcce598e07679e1563922d8c8ce1be7e2353e" translate="yes" xml:space="preserve">
          <source>Now for a larger example with a simple &quot;messenger&quot;. The messenger is a program that allows users to log in on different nodes and send simple messages to each other.</source>
          <target state="translated">では、簡単な「メッセンジャー」を使った大きな例を見てみましょう。メッセンジャーは、ユーザーが異なるノードにログインして、お互いに簡単なメッセージを送信できるようにするプログラムです。</target>
        </trans-unit>
        <trans-unit id="8f9a8082924a3a55b208b60dc3c2a35c271485ed" translate="yes" xml:space="preserve">
          <source>Now for a more complicated example, the factorial of a number. For example, the factorial of 4 is 4 * 3 * 2 * 1, which equals 24.</source>
          <target state="translated">さて、もっと複雑な例として、数の階乗を挙げてみましょう。例えば、4の倍数は4*3*2*1で、24に等しくなります。</target>
        </trans-unit>
        <trans-unit id="85b87f3295c00771011c50c29b24763361547f32" translate="yes" xml:space="preserve">
          <source>Now let us get back to the cities and temperatures, but take a more structured approach this time. First let us convert the whole list to Celsius as follows:</source>
          <target state="translated">さて、都市と気温の話に戻りますが、今回はもう少し構造的なアプローチをしてみましょう。まず、リスト全体を以下のように摂氏に変換してみましょう。</target>
        </trans-unit>
        <trans-unit id="f815262fb97682c5acd6fb931562748d09976dd2" translate="yes" xml:space="preserve">
          <source>Now let us get back to the first two lines of the code. Erlang programs are written in files. Each file contains an Erlang &lt;strong&gt;module&lt;/strong&gt;. The first line of code in the module is the module name (see &lt;code&gt;Modules&lt;/code&gt;):</source>
          <target state="translated">コードの最初の2行に戻りましょう。Erlangプログラムはファイルに書き込まれます。各ファイルにはErlang &lt;strong&gt;モジュール&lt;/strong&gt;が含まれてい&lt;strong&gt;ます&lt;/strong&gt;。モジュールのコードの最初の行はモジュール名です（ &lt;code&gt;Modules&lt;/code&gt; 参照）：</target>
        </trans-unit>
        <trans-unit id="0937bc21f5c355b7556a59cf5f4dbd1a5ec043f5" translate="yes" xml:space="preserve">
          <source>Now let us look at the process &quot;ping&quot;. Recall that it was started by executing:</source>
          <target state="translated">ここで、&quot;ping &quot;というプロセスを見てみましょう。実行することで起動したことを思い出してください。</target>
        </trans-unit>
        <trans-unit id="6eddc3d3ff799bf232cc855fb7b548b211ee7ca5" translate="yes" xml:space="preserve">
          <source>Now let's look at the implementation of &lt;code&gt;move_xx&lt;/code&gt;:</source>
          <target state="translated">それでは、 &lt;code&gt;move_xx&lt;/code&gt; の実装を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="73a7fa9dfcc333d467dd81b0a30c1df103da8ee8" translate="yes" xml:space="preserve">
          <source>Now let's look at the implementation of the &lt;code&gt;move&lt;/code&gt; instruction. There are multiple files containing implementations of instructions in the &lt;code&gt;erts/emulator/beam&lt;/code&gt; directory. The &lt;code&gt;move&lt;/code&gt; instruction is defined in &lt;code&gt;instrs.tab&lt;/code&gt;. It looks like this:</source>
          <target state="translated">次に、 &lt;code&gt;move&lt;/code&gt; 命令の実装を見てみましょう。 &lt;code&gt;erts/emulator/beam&lt;/code&gt; ディレクトリに命令の実装を含む複数のファイルがあります。 &lt;code&gt;move&lt;/code&gt; 命令がで定義されている &lt;code&gt;instrs.tab&lt;/code&gt; 。次のようになります。</target>
        </trans-unit>
        <trans-unit id="0930d4eadca76ecb3a8d6bfa6d074f842ec248fa" translate="yes" xml:space="preserve">
          <source>Now run the program:</source>
          <target state="translated">今すぐプログラムを実行してください。</target>
        </trans-unit>
        <trans-unit id="7e848956566e548f1d9ae0d0b8013c74e6d83d3a" translate="yes" xml:space="preserve">
          <source>Now that we have defined the fragments, we need to inform &lt;strong&gt;beam_makeops&lt;/strong&gt; how they should be connected:</source>
          <target state="translated">フラグメントを定義したので、&lt;strong&gt;beam_makeopsに&lt;/strong&gt;フラグメントの接続方法を通知する必要があります。</target>
        </trans-unit>
        <trans-unit id="55eb0e0626fb4ef4258288a934f71110a41abd31" translate="yes" xml:space="preserve">
          <source>Now the &quot;pong&quot; process on gollum is started:</source>
          <target state="translated">これでゴラムの「ポン」処理が開始されました。</target>
        </trans-unit>
        <trans-unit id="5f18e66183fccf43dd04a3319e9abe480c44266d" translate="yes" xml:space="preserve">
          <source>Now the &lt;code&gt;relup&lt;/code&gt; file can be generated:</source>
          <target state="translated">これで、 &lt;code&gt;relup&lt;/code&gt; ファイルを生成できます。</target>
        </trans-unit>
        <trans-unit id="419ad4c19e6962a17e264cf0565e8680fba59965" translate="yes" xml:space="preserve">
          <source>Now the &lt;code&gt;tut2&lt;/code&gt; program is hardly good programming style. Consider:</source>
          <target state="translated">現在、 &lt;code&gt;tut2&lt;/code&gt; プログラムはプログラミングスタイルとしてはあまり優れていません。考慮してください：</target>
        </trans-unit>
        <trans-unit id="034e7984504e96eaaa52341007b573729c1bfa18" translate="yes" xml:space="preserve">
          <source>Now the C node can be initiated. If short node names are used, this is done by calling &lt;code&gt;erl_connect_init()&lt;/code&gt;:</source>
          <target state="translated">これで、Cノードを開始できます。短いノード名が使用されている場合、これは &lt;code&gt;erl_connect_init()&lt;/code&gt; を呼び出すことによって行われます。</target>
        </trans-unit>
        <trans-unit id="cdf6ba8b610923726e867dc5eac6994fcbdfa5a4" translate="yes" xml:space="preserve">
          <source>Now the C node server can accept connections from Erlang nodes:</source>
          <target state="translated">これでCノードサーバはErlangノードからの接続を受け付けることができるようになりました。</target>
        </trans-unit>
        <trans-unit id="f57b2ed1c1f99cc47795c85e2110f62964631a09" translate="yes" xml:space="preserve">
          <source>Now we can publish the structure in the table by writing the the pointer to the process structure in the slot previously reserved in 3.</source>
          <target state="translated">これで、3で予約したスロットにプロセス構造体へのポインタを書き込むことで、テーブルに構造体を公開することができるようになりました。</target>
        </trans-unit>
        <trans-unit id="3630e70ae8e40d246b34002925292898bb67186e" translate="yes" xml:space="preserve">
          <source>Now we come to something more interesting:</source>
          <target state="translated">さて、もっと面白いものに行き着きました。</target>
        </trans-unit>
        <trans-unit id="790582ffcd379351fda4ad80a8805b29abc3d15b" translate="yes" xml:space="preserve">
          <source>Now we have a target system that can be started in various ways. We start it as a &lt;strong&gt;basic target system&lt;/strong&gt; by invoking:</source>
          <target state="translated">これで、さまざまな方法で起動できるターゲットシステムが完成しました。&lt;strong&gt;基本的な対象システム&lt;/strong&gt;としてスタート&lt;strong&gt;&lt;/strong&gt;呼び出すことで起動します。</target>
        </trans-unit>
        <trans-unit id="07e2005a0a6deb7487edffb7259d4bbae161649b" translate="yes" xml:space="preserve">
          <source>Now we look at another interesting pseudo function, &lt;code&gt;garbage_collect&lt;/code&gt;:</source>
          <target state="translated">次に、別の興味深い疑似関数 &lt;code&gt;garbage_collect&lt;/code&gt; を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="7baae9db7349907407d97b8497ef107b8eef0dbb" translate="yes" xml:space="preserve">
          <source>Now we want to read data from the table. Function &lt;code&gt;get_until/5&lt;/code&gt; reads data and applies the function until it says that it is done. The result is sent back to the client:</source>
          <target state="translated">次に、テーブルからデータを読み取ります。関数 &lt;code&gt;get_until/5&lt;/code&gt; はデータを読み取り、完了したと表示されるまで関数を適用します。結果はクライアントに送り返されます：</target>
        </trans-unit>
        <trans-unit id="841ad6881ed808c0b00a3ce8e4425eac2fdd57ad" translate="yes" xml:space="preserve">
          <source>Now when the list is converted, a function to print it is added:</source>
          <target state="translated">これでリストが変換されたときに、それを印刷する関数が追加されました。</target>
        </trans-unit>
        <trans-unit id="f946da2eb954f3f3431f7eaa1a17198b4a4bcad5" translate="yes" xml:space="preserve">
          <source>Now you are set up for some Unicode input and output. The simplest thing to do is to enter a string in the shell:</source>
          <target state="translated">これで、Unicodeの入力と出力ができるようになりました。一番簡単なのは、シェルに文字列を入力することです。</target>
        </trans-unit>
        <trans-unit id="4101ddb4b1ba4c623fe01975aae255730951fb95" translate="yes" xml:space="preserve">
          <source>Now you can check which erlc you have by writing &lt;code&gt;type erlc&lt;/code&gt; in your shell. It should reside in &lt;code&gt;$ERL_TOP/erts/etc/win32/cygwin_tools&lt;/code&gt; or &lt;code&gt;$ERL_TOP/erts/etc/win32/msys_tools&lt;/code&gt;.</source>
          <target state="translated">これで、シェルに &lt;code&gt;type erlc&lt;/code&gt; を書き込むことにより、使用しているerlcを確認できます。それは内に存在する必要があります &lt;code&gt;$ERL_TOP/erts/etc/win32/cygwin_tools&lt;/code&gt; または &lt;code&gt;$ERL_TOP/erts/etc/win32/msys_tools&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3bd9b4b08ad2850cc0852933844bf5bbc09109e4" translate="yes" xml:space="preserve">
          <source>Now you can check which erlc you have by writing &lt;code&gt;type erlc&lt;/code&gt; in your shell. It should reside in &lt;code&gt;$ERL_TOP/erts/etc/win32/wsl_tools&lt;/code&gt;.</source>
          <target state="translated">これで、シェルに &lt;code&gt;type erlc&lt;/code&gt; を書き込むことで、使用しているerlcを確認できます。それは内に存在する必要があります &lt;code&gt;$ERL_TOP/erts/etc/win32/wsl_tools&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a6fd06da4ec350e2c1cd2afa53dc7213e2209fc9" translate="yes" xml:space="preserve">
          <source>Now you will have a file called &lt;code&gt;otp_win32_21.exe&lt;/code&gt; or &lt;code&gt;otp_win64_21.exe&lt;/code&gt; in the &lt;code&gt;&amp;lt;installation directory&amp;gt;&lt;/code&gt;, i.e. &lt;code&gt;$ERL_TOP/release/win32&lt;/code&gt;.</source>
          <target state="translated">これで、 &lt;code&gt;&amp;lt;installation directory&amp;gt;&lt;/code&gt; に &lt;code&gt;otp_win32_21.exe&lt;/code&gt; または &lt;code&gt;otp_win64_21.exe&lt;/code&gt; というファイル、つまり &lt;code&gt;$ERL_TOP/release/win32&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="cf27925b0551dd76b6d0908cbb333e95a400dac2" translate="yes" xml:space="preserve">
          <source>Now you will have a file called &lt;code&gt;otp_win32_23.exe&lt;/code&gt; or &lt;code&gt;otp_win64_23.exe&lt;/code&gt; in the &lt;code&gt;&amp;lt;installation directory&amp;gt;&lt;/code&gt;, i.e. &lt;code&gt;$ERL_TOP/release/win32&lt;/code&gt;.</source>
          <target state="translated">これで、 &lt;code&gt;&amp;lt;installation directory&amp;gt;&lt;/code&gt; に &lt;code&gt;otp_win32_23.exe&lt;/code&gt; または &lt;code&gt;otp_win64_23.exe&lt;/code&gt; というファイル、つまり &lt;code&gt;$ERL_TOP/release/win32&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="716d0540851d08f95b750091b9b63ae2e0b978fa" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;fact(0)&lt;/code&gt; is called, and the function clauses are scanned sequentially again. First, the pattern &lt;code&gt;N&lt;/code&gt; is matched against 0. The matching succeeds, but the guard (&lt;code&gt;N&amp;gt;0&lt;/code&gt;) is false. Second, the pattern 0 is matched against 0. The matching succeeds and the body is evaluated:</source>
          <target state="translated">これで、 &lt;code&gt;fact(0)&lt;/code&gt; が呼び出され、関数句が再び順次スキャンされます。最初に、パターン &lt;code&gt;N&lt;/code&gt; は0と照合されます。照合は成功しますが、ガード（ &lt;code&gt;N&amp;gt;0&lt;/code&gt; ）は偽です。次に、パターン0が0と照合されます。照合は成功し、本体が評価されます。</target>
        </trans-unit>
        <trans-unit id="98445b1d7f9952b03aea3c602d6261fd2d8aa394" translate="yes" xml:space="preserve">
          <source>Now, back to the example where we wanted to make the output more arranged. With the template:</source>
          <target state="translated">さて、出力をもっとアレンジしたい例に戻りましょう。テンプレートを使って</target>
        </trans-unit>
        <trans-unit id="0ccacd93bad121d635d3ee2cf04a4a93d66d91bb" translate="yes" xml:space="preserve">
          <source>Now, imagine that as &lt;code&gt;m1&lt;/code&gt; is a library module, it is also often used by system &lt;code&gt;s2&lt;/code&gt;. Test run &lt;code&gt;s2&lt;/code&gt; does not specifically test &lt;code&gt;m1&lt;/code&gt;, but it can still be interesting to see which parts of &lt;code&gt;m1&lt;/code&gt; that are covered by the &lt;code&gt;s2&lt;/code&gt; tests. To do this, &lt;code&gt;m1&lt;/code&gt; can be included also in the cover specification of &lt;code&gt;s2&lt;/code&gt; as follows:</source>
          <target state="translated">ここで、 &lt;code&gt;m1&lt;/code&gt; はライブラリモジュールであるため、システム &lt;code&gt;s2&lt;/code&gt; でも使用されることが多いと想像してください。テスト実行 &lt;code&gt;s2&lt;/code&gt; は &lt;code&gt;m1&lt;/code&gt; を具体的にテストしませんが、 &lt;code&gt;s2&lt;/code&gt; テストでカバーされる &lt;code&gt;m1&lt;/code&gt; の部分を確認することは興味深いことです。これを行うには、 &lt;code&gt;m1&lt;/code&gt; を &lt;code&gt;s2&lt;/code&gt; のカバー仕様にも含めることができます。ます。</target>
        </trans-unit>
        <trans-unit id="33cc55d98c68e73ea0d743377235f62740c45f57" translate="yes" xml:space="preserve">
          <source>Now, such a call to &lt;code&gt;monitor&lt;/code&gt; will instead succeed and a monitor is created. But the monitor will only supervise the connection. That is, a &lt;code&gt;{'DOWN', _, process, _, noconnection}&lt;/code&gt; is the only message that may be received, as the primitive node have no way of reporting the status of the monitored process.</source>
          <target state="translated">現在、このような &lt;code&gt;monitor&lt;/code&gt; の呼び出しは成功し、モニターが作成されます。ただし、モニターは接続を監視するだけです。つまり、プリミティブノードには監視対象プロセスのステータスを報告する方法がないため、受信できるメッセージは &lt;code&gt;{'DOWN', _, process, _, noconnection}&lt;/code&gt; のみです。</target>
        </trans-unit>
        <trans-unit id="815213b4b20368b41071811d96af96cae0ecf6af" translate="yes" xml:space="preserve">
          <source>Now, the fold and the map can be done at the same time:</source>
          <target state="translated">これで、折り返しと地図が同時にできるようになりました。</target>
        </trans-unit>
        <trans-unit id="2bd172c2b14d17bdd3e0bc285216399b7bf359fd" translate="yes" xml:space="preserve">
          <source>Nowadays, the compiler rewrites list comprehensions into an ordinary recursive function. Using a tail-recursive function with a reverse at the end would be still faster. Or would it? That leads us to the myth that tail-recursive functions are faster than body-recursive functions.</source>
          <target state="translated">現在、コンパイラはリスト内包を通常の再帰関数に書き換えています。末尾再帰的な関数を使用して、最後に逆引きをした方がまだ速いでしょう。それともそうでしょうか?これは、末尾再帰関数はボディ再帰関数よりも速いという神話につながっています。</target>
        </trans-unit>
        <trans-unit id="b2b91a3dd3c62a3480c6550b4ca1758c4ca00cfd" translate="yes" xml:space="preserve">
          <source>Nullary callback function &lt;code&gt;PostFun&lt;/code&gt; is called once after the table was last read. The return value, which is caught, is ignored. If &lt;code&gt;PreFun&lt;/code&gt; has been called for a table, &lt;code&gt;PostFun&lt;/code&gt; is guaranteed to be called for that table, even if the evaluation of the query fails for some reason.</source>
          <target state="translated">Nullaryコールバック関数 &lt;code&gt;PostFun&lt;/code&gt; は、テーブルが最後に読み取られた後に一度呼び出されます。キャッチされた戻り値は無視されます。 &lt;code&gt;PreFun&lt;/code&gt; がテーブルに対して呼び出された場合、 &lt;code&gt;PostFun&lt;/code&gt; 、クエリの評価が何らかの理由で失敗しても、そのテーブルのために呼び出されることが保証されています。</target>
        </trans-unit>
        <trans-unit id="e386a6937b577f217d46833120530e874cdb7e8a" translate="yes" xml:space="preserve">
          <source>Nullsoft NSIS installer system (optional) You need this to build the self installing package.</source>
          <target state="translated">Nullsoft NSIS インストーラシステム (オプション)セルフインストールパッケージを構築するために必要です。</target>
        </trans-unit>
        <trans-unit id="f11c0821f05eac62af0f028d86dc3849bfa606ca" translate="yes" xml:space="preserve">
          <source>Nullsoft NSIS installer system. You need this to build the self installing package. It's a free open source installer that's much nicer to use than the commercial Wise and Install shield installers. This is the installer we use for commercial releases as well.</source>
          <target state="translated">Nullsoft NSIS インストーラシステム。セルフインストールパッケージを構築するにはこれが必要です。これはフリーのオープンソースインストーラで、商用のWiseやInstall shieldインストーラよりも使いやすいです。これは、私たちが商用リリースでも使用しているインストーラです。</target>
        </trans-unit>
        <trans-unit id="b7baa1d40c4ea29afc9098732bffee2a861a6c44" translate="yes" xml:space="preserve">
          <source>Number</source>
          <target state="translated">Number</target>
        </trans-unit>
        <trans-unit id="576c424c360acfd1497ea21294f140f3cec38c19" translate="yes" xml:space="preserve">
          <source>Number ::= - same as non-negative Erlang integers -</source>
          <target state="translated">数 ::=-非負のErlangの整数と同じ-数 ::=-非負のErlangの整数と同じ-数 ::=-非負のErlangの整数と同じ-数 ::=-非負のErlangの整数と同じ-数 ::=-非負のErlangの整数と同じ-数 ::=-非負のErlangの整数と同じ-数 ::=-非負のErlangの整数と同じ-数 ::=-非負のErlangの整数と同じ-数 ::=-非負のErlangの整数と同じ-数 ::=-非負のErlangの整数と同じ-数 ::=-非負のErlangの整数と同じ-数 ::=-非負のErlangの整数と同じ-数 ::=-非負のErlangの整数と同じ-数 ::=-非負のErlangの整数と同じ-数 ::=-非負のErlangの整数と同じ-数 ::=-非負のErlangの整数と同じ</target>
        </trans-unit>
        <trans-unit id="b120174b0ca1d364c35e309340c2699137e93cf3" translate="yes" xml:space="preserve">
          <source>Number of Atoms</source>
          <target state="translated">原子数</target>
        </trans-unit>
        <trans-unit id="436ff201e33fbebe2f89621894a2abd1c168a9b3" translate="yes" xml:space="preserve">
          <source>Number of acquisitions of this lock.</source>
          <target state="translated">このロックの取得数。</target>
        </trans-unit>
        <trans-unit id="156e52de6b6c52ca3695d88a4c555445a9d76e09" translate="yes" xml:space="preserve">
          <source>Number of arguments to a function or fun</source>
          <target state="translated">関数や関数の引数の数</target>
        </trans-unit>
        <trans-unit id="5f360155f999f4bc86536b7ac3f8776370a01909" translate="yes" xml:space="preserve">
          <source>Number of bits may be divisible by 8, which means a binary decodable by &lt;code&gt;ei_decode_binary&lt;/code&gt; is also decodable by &lt;code&gt;ei_decode_bitstring&lt;/code&gt;.</source>
          <target state="translated">ビット数は8で割り切れる可能性があります。つまり、 &lt;code&gt;ei_decode_binary&lt;/code&gt; でデコード可能なバイナリはei_decode_bitstringでもデコード可能 &lt;code&gt;ei_decode_bitstring&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ed917e86d9f18f03dbcccf6e65ab949d58ed88b7" translate="yes" xml:space="preserve">
          <source>Number of bytes received by the socket.</source>
          <target state="translated">ソケットが受信したバイト数。</target>
        </trans-unit>
        <trans-unit id="42046ff77420f4d17e7571e95bf522b706d2b214" translate="yes" xml:space="preserve">
          <source>Number of bytes sent from the socket.</source>
          <target state="translated">ソケットから送信されたバイト数。</target>
        </trans-unit>
        <trans-unit id="2f05c7528a7c09c8ca7b40c3010abfa2c48aee95" translate="yes" xml:space="preserve">
          <source>Number of bytes waiting to be sent by the socket.</source>
          <target state="translated">ソケットからの送信待ちのバイト数。</target>
        </trans-unit>
        <trans-unit id="abaddc1ab230437389138952dc901cca420ce997" translate="yes" xml:space="preserve">
          <source>Number of calls from exported functions.</source>
          <target state="translated">エクスポートされた関数からの呼び出し回数。</target>
        </trans-unit>
        <trans-unit id="b6dc3a193a64eb663d8300e32005cd15708c2213" translate="yes" xml:space="preserve">
          <source>Number of collisions when a thread tried to acquire this lock. This is when a trylock is EBUSY, a write try on read held rw_lock, a try read on write held rw_lock, a thread tries to lock an already locked lock. (Internal states supervises this).</source>
          <target state="translated">スレッドがこのロックを取得しようとしたときの衝突回数。これは、trylockがEBUSYである場合、read heldされたrw_lockに対するwrite try、write heldされたrw_lockに対するread try、スレッドが既にロックされているロックをロックしようとした場合です。内部状態がこれを監視しています)。</target>
        </trans-unit>
        <trans-unit id="b5befc3bf1ef58e74135162c0668ade7be2434a8" translate="yes" xml:space="preserve">
          <source>Number of data chunks pending receipt</source>
          <target state="translated">受信待ちのデータチャンク数</target>
        </trans-unit>
        <trans-unit id="1788092af3b8a586296aa9df2406a866bfcd033f" translate="yes" xml:space="preserve">
          <source>Number of inbound streams</source>
          <target state="translated">インバウンドストリームの数</target>
        </trans-unit>
        <trans-unit id="0d39785385699f304d2bb821ff68b08bc05cf178" translate="yes" xml:space="preserve">
          <source>Number of lines (processes) to display.</source>
          <target state="translated">表示する行数(プロセス)。</target>
        </trans-unit>
        <trans-unit id="c7246b6b50502576f0a38d8a27451c68c1a94bf1" translate="yes" xml:space="preserve">
          <source>Number of links to the file (this is always 1 for file systems that have no concept of links).</source>
          <target state="translated">ファイルへのリンク数(リンクの概念がないファイルシステムでは常に1)。</target>
        </trans-unit>
        <trans-unit id="86b7d74929b08d37a5d6bbdc6ce558fa981b1e22" translate="yes" xml:space="preserve">
          <source>Number of milliseconds after which a transport connection is terminated following an incoming DPR if the peer does not close the connection.</source>
          <target state="translated">ピアが接続を閉じなかった場合、着信DPRに続いてトランスポート接続が終了するまでのミリ秒数。</target>
        </trans-unit>
        <trans-unit id="ad84b78a0ee803a8e44abc5c45068c551a8be685" translate="yes" xml:space="preserve">
          <source>Number of milliseconds after which a transport connection is terminated following an outgoing DPR if DPA is not received.</source>
          <target state="translated">DPA を受信しなかった場合、発信 DPR に続いてトランスポート接続が終了するまでのミリ秒数。</target>
        </trans-unit>
        <trans-unit id="d143428966dbf2e9b35f53fde260f63542ea0ceb" translate="yes" xml:space="preserve">
          <source>Number of milliseconds after which a transport process having an established transport connection will be terminated if the expected capabilities exchange message (CER or CEA) is not received from the peer. For a connecting transport, the timing of connection attempts is governed by &lt;code&gt;&lt;a href=&quot;#connect_timer&quot;&gt;connect_timer&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#watchdog_timer&quot;&gt;watchdog_timer&lt;/a&gt;&lt;/code&gt; expiry. For a listening transport, the peer determines the timing.</source>
          <target state="translated">期待される機能交換メッセージ（CERまたはCEA）がピアから受信されない場合に、確立されたトランスポート接続を持つトランスポートプロセスが終了するまでのミリ秒数。接続トランスポートの場合、接続試行のタイミングは、 &lt;code&gt;&lt;a href=&quot;#connect_timer&quot;&gt;connect_timer&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;#watchdog_timer&quot;&gt;watchdog_timer&lt;/a&gt;&lt;/code&gt; expiry によって制御されます。リスニングトランスポートの場合、ピアがタイミングを決定します。</target>
        </trans-unit>
        <trans-unit id="2a4f3d8f10ea95abb768e6ff37dcd2d263075314" translate="yes" xml:space="preserve">
          <source>Number of milliseconds after which the request should timeout. Defaults to 5000.</source>
          <target state="translated">リクエストがタイムアウトするまでのミリ秒数。デフォルトは 5000 です。</target>
        </trans-unit>
        <trans-unit id="4d5f53d55e482f8b255f961e8335b47ecc984cf9" translate="yes" xml:space="preserve">
          <source>Number of milliseconds after which the transport process is terminated if DPA has not been received. Defaults to the value of &lt;code&gt;&lt;a href=&quot;#dpa_timeout&quot;&gt;dpa_timeout&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">DPAが受信されなかった場合にトランスポートプロセスが終了するまでのミリ秒数。デフォルトは &lt;code&gt;&lt;a href=&quot;#dpa_timeout&quot;&gt;dpa_timeout&lt;/a&gt;&lt;/code&gt; の値です。</target>
        </trans-unit>
        <trans-unit id="8b185f82b1b5bfaa8854d705b869060e9935cb3a" translate="yes" xml:space="preserve">
          <source>Number of milliseconds left until the message would have been sent.</source>
          <target state="translated">メッセージが送信されるまでに残されたミリ秒数。</target>
        </trans-unit>
        <trans-unit id="1d3a9ba15cb753485b84a2ad953f8633c6b1bd33" translate="yes" xml:space="preserve">
          <source>Number of outbound streams</source>
          <target state="translated">アウトバウンドストリームの数</target>
        </trans-unit>
        <trans-unit id="7cc577409a125b78cfe2310bff5b33c90e99d779" translate="yes" xml:space="preserve">
          <source>Number of packets received by the socket.</source>
          <target state="translated">ソケットが受信したパケット数。</target>
        </trans-unit>
        <trans-unit id="6cc46ab9febecbfd1c32816e8e1c042fb0b2037b" translate="yes" xml:space="preserve">
          <source>Number of packets sent from the socket.</source>
          <target state="translated">ソケットから送信されたパケット数。</target>
        </trans-unit>
        <trans-unit id="0b905814d3355622795966fbb7336f35dc784aab" translate="yes" xml:space="preserve">
          <source>Number of transport processes to start. For a listening transport, determines the size of the pool of accepting transport processes, a larger number being desirable for processing multiple concurrent peer connection attempts. For a connecting transport, determines the number of connections to the peer in question that will be attempted to be establshed: the &lt;code&gt;&lt;a href=&quot;#service_opt&quot;&gt;service_opt()&lt;/a&gt;&lt;/code&gt;: &lt;code&gt;restrict_connections&lt;/code&gt; should also be configured on the service in question to allow multiple connections to the same peer.</source>
          <target state="translated">開始するトランスポートプロセスの数。リスニングトランスポートの場合、受け入れトランスポートプロセスのプールのサイズを決定します。複数の同時ピア接続試行を処理するには、より大きい数が望ましいです。接続するトランスポートの場合、確立しようとする問題のピアへの接続数を決定します。同じピアへの複数の接続を許可するには、問題のサービスで &lt;code&gt;&lt;a href=&quot;#service_opt&quot;&gt;service_opt()&lt;/a&gt;&lt;/code&gt; ： &lt;code&gt;restrict_connections&lt;/code&gt; も構成する必要があります。</target>
        </trans-unit>
        <trans-unit id="66bc96661d8742ae05329a683dcb3f84683507cc" translate="yes" xml:space="preserve">
          <source>Number of unacked data chunks</source>
          <target state="translated">アンバックされていないデータチャンクの数</target>
        </trans-unit>
        <trans-unit id="0b1af9772e5bb4a2a3309eeb320fd315552f0cb5" translate="yes" xml:space="preserve">
          <source>NumberOfAtomCacheRefs/2+1 | 0</source>
          <target state="translated">NumberOfAtomCacheRefs/2+1 | 0</target>
        </trans-unit>
        <trans-unit id="8e1b0dd3b8942a6f418c72794efaf599fa638602" translate="yes" xml:space="preserve">
          <source>Numbers are generated in batches and cached for speed reasons. The cache size can be changed from its default value using the &lt;code&gt; crypto app's &lt;/code&gt; configuration parameter &lt;code&gt;rand_cache_size&lt;/code&gt;.</source>
          <target state="translated">数値はバッチで生成され、速度上の理由からキャッシュされます。キャッシュサイズは、 &lt;code&gt; crypto app's &lt;/code&gt; 構成パラメーター &lt;code&gt;rand_cache_size&lt;/code&gt; を使用してデフォルト値から変更できます。</target>
        </trans-unit>
        <trans-unit id="742119a1b0ee0bffbdb7123efbae98b4d4cf4508" translate="yes" xml:space="preserve">
          <source>ODBC Data Type</source>
          <target state="translated">ODBCデータ型</target>
        </trans-unit>
        <trans-unit id="a10c3f25c81a857c7ec7c54210e6931745d9810e" translate="yes" xml:space="preserve">
          <source>OPTIONAL</source>
          <target state="translated">OPTIONAL</target>
        </trans-unit>
        <trans-unit id="7025579510c04aa01d4607a0e0aca5cbec9f5502" translate="yes" xml:space="preserve">
          <source>OPTIONAL; if this function is defined, then &lt;code&gt;&lt;a href=&quot;#Module:end_per_group-2&quot;&gt;Module:end_per_group/2&lt;/a&gt;&lt;/code&gt; must also be defined.</source>
          <target state="translated">オプション; この関数を定義する場合は、 &lt;code&gt;&lt;a href=&quot;#Module:end_per_group-2&quot;&gt;Module:end_per_group/2&lt;/a&gt;&lt;/code&gt; も定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="fe255781a97feef0174934e6b7b818e19746a2b3" translate="yes" xml:space="preserve">
          <source>OPTIONAL; if this function is defined, then &lt;code&gt;&lt;a href=&quot;#Module:end_per_group-2&quot;&gt;end_per_group/2&lt;/a&gt;&lt;/code&gt; must also be defined.</source>
          <target state="translated">オプション; この関数を定義する場合は、 &lt;code&gt;&lt;a href=&quot;#Module:end_per_group-2&quot;&gt;end_per_group/2&lt;/a&gt;&lt;/code&gt; も定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="6aa8960d1405b5237c6590a23f7510a292a61f98" translate="yes" xml:space="preserve">
          <source>OPTIONAL; if this function is defined, then &lt;code&gt;&lt;a href=&quot;#Module:end_per_suite-1&quot;&gt;Module:end_per_suite/1&lt;/a&gt;&lt;/code&gt; must also be defined.</source>
          <target state="translated">オプション; この関数を定義する場合は、 &lt;code&gt;&lt;a href=&quot;#Module:end_per_suite-1&quot;&gt;Module:end_per_suite/1&lt;/a&gt;&lt;/code&gt; も定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="f7020f99e2ebb79e7dec7703e4dde7e6f7d3ab62" translate="yes" xml:space="preserve">
          <source>OPTIONAL; if this function is defined, then &lt;code&gt;&lt;a href=&quot;#Module:end_per_suite-1&quot;&gt;end_per_suite/1&lt;/a&gt;&lt;/code&gt; must also be defined.</source>
          <target state="translated">オプション; この関数が定義されている場合、 &lt;code&gt;&lt;a href=&quot;#Module:end_per_suite-1&quot;&gt;end_per_suite/1&lt;/a&gt;&lt;/code&gt; も定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="178a184607add52e5bb5d680a1449c26c616fc56" translate="yes" xml:space="preserve">
          <source>OPTIONAL; if this function is defined, then &lt;code&gt;&lt;a href=&quot;#Module:end_per_testcase-2&quot;&gt; Module:end_per_testcase/2&lt;/a&gt;&lt;/code&gt; must also be defined.</source>
          <target state="translated">オプション; この関数を定義する場合は、 &lt;code&gt;&lt;a href=&quot;#Module:end_per_testcase-2&quot;&gt; Module:end_per_testcase/2&lt;/a&gt;&lt;/code&gt; も定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="cb2b3bf247d98944fbe75b41c4379902fac4c0ed" translate="yes" xml:space="preserve">
          <source>OPTIONAL; if this function is defined, then &lt;code&gt;&lt;a href=&quot;#Module:end_per_testcase-2&quot;&gt;end_per_testcase/2&lt;/a&gt;&lt;/code&gt; must also be defined.</source>
          <target state="translated">オプション; この関数を定義する場合は、 &lt;code&gt;&lt;a href=&quot;#Module:end_per_testcase-2&quot;&gt;end_per_testcase/2&lt;/a&gt;&lt;/code&gt; も定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="01588880c00f5e2abc030e7f6d3e755195174bd7" translate="yes" xml:space="preserve">
          <source>OPTIONAL; if this function is defined, then &lt;code&gt;&lt;a href=&quot;#Module:init_per_group-2&quot;&gt;Module:init_per_group/2&lt;/a&gt;&lt;/code&gt; must also be defined.</source>
          <target state="translated">オプション; この関数を定義する場合は、 &lt;code&gt;&lt;a href=&quot;#Module:init_per_group-2&quot;&gt;Module:init_per_group/2&lt;/a&gt;&lt;/code&gt; も定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="811daf24de9dd5fef2b06f207387f6fa44818576" translate="yes" xml:space="preserve">
          <source>OPTIONAL; if this function is defined, then &lt;code&gt;&lt;a href=&quot;#Module:init_per_group-2&quot;&gt;init_per_group/2&lt;/a&gt;&lt;/code&gt; must also be defined.</source>
          <target state="translated">オプション; この関数を定義する場合は、 &lt;code&gt;&lt;a href=&quot;#Module:init_per_group-2&quot;&gt;init_per_group/2&lt;/a&gt;&lt;/code&gt; も定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="7438774d77f88e98fd2822354fa0458e5289e97d" translate="yes" xml:space="preserve">
          <source>OPTIONAL; if this function is defined, then &lt;code&gt;&lt;a href=&quot;#Module:init_per_suite-1&quot;&gt;Module:init_per_suite/1&lt;/a&gt;&lt;/code&gt; must also be defined.</source>
          <target state="translated">オプション; この関数を定義する場合は、 &lt;code&gt;&lt;a href=&quot;#Module:init_per_suite-1&quot;&gt;Module:init_per_suite/1&lt;/a&gt;&lt;/code&gt; も定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="09f3a1ee83f65c6b4212698c759ac143edb39e85" translate="yes" xml:space="preserve">
          <source>OPTIONAL; if this function is defined, then &lt;code&gt;&lt;a href=&quot;#Module:init_per_suite-1&quot;&gt;init_per_suite/1&lt;/a&gt;&lt;/code&gt; must also be defined.</source>
          <target state="translated">オプション; この関数を定義する場合は、 &lt;code&gt;&lt;a href=&quot;#Module:init_per_suite-1&quot;&gt;init_per_suite/1&lt;/a&gt;&lt;/code&gt; も定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="0552e661b2ea6fc224f8f95384fb27a6c1bfc0f7" translate="yes" xml:space="preserve">
          <source>OPTIONAL; if this function is defined, then &lt;code&gt;&lt;a href=&quot;#Module:init_per_testcase-2&quot;&gt; Module:init_per_testcase/2&lt;/a&gt;&lt;/code&gt; must also be defined.</source>
          <target state="translated">オプション;この関数を定義する場合は、 &lt;code&gt;&lt;a href=&quot;#Module:init_per_testcase-2&quot;&gt; Module:init_per_testcase/2&lt;/a&gt;&lt;/code&gt; も定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="da40ab1589249e13637d8f194c28172da2bf88bf" translate="yes" xml:space="preserve">
          <source>OPTIONAL; if this function is defined, then &lt;code&gt;&lt;a href=&quot;#Module:init_per_testcase-2&quot;&gt;init_per_testcase/2&lt;/a&gt;&lt;/code&gt; must also be defined.</source>
          <target state="translated">オプション; この関数を定義する場合は、 &lt;code&gt;&lt;a href=&quot;#Module:init_per_testcase-2&quot;&gt;init_per_testcase/2&lt;/a&gt;&lt;/code&gt; も定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="00ff70d59339a0ed84894894c61d1c1f2ef4d4e9" translate="yes" xml:space="preserve">
          <source>OS Monotonic Time</source>
          <target state="translated">OS単調時間</target>
        </trans-unit>
        <trans-unit id="b6942daa3866fbe3e050507e50fbe84fe8347bcc" translate="yes" xml:space="preserve">
          <source>OS System Time</source>
          <target state="translated">OSシステム時間</target>
        </trans-unit>
        <trans-unit id="34d5721686b9afbeb78f01e3fc667ce57e89931f" translate="yes" xml:space="preserve">
          <source>OS X (Darwin)</source>
          <target state="translated">オーエスエックス(ダーウィン</target>
        </trans-unit>
        <trans-unit id="70a99f3723b01cca80b99d24bb0c2a412b59bf1d" translate="yes" xml:space="preserve">
          <source>OS X 10.6.x / Snow Leopard, OS X 10.7.x / Lion and probably newer versions.</source>
          <target state="translated">OS X 10.6.x/Snow Leopard、OS X 10.7.x/Lionとおそらく新しいバージョン。</target>
        </trans-unit>
        <trans-unit id="337dc1124caacdd89c2450e56842d52c3f0e6fad" translate="yes" xml:space="preserve">
          <source>OS X/Darwin: Darwin 9.8.0 in 32-bit mode should work.</source>
          <target state="translated">OS X/Darwinです。32ビットモードのDarwin 9.8.0は動作するはずです。</target>
        </trans-unit>
        <trans-unit id="164a0c0837ae1b007b5e17a0056a34ade5f8ce3b" translate="yes" xml:space="preserve">
          <source>OS messages are formatted as a tuple &lt;code&gt;{Time, Category, Facility, Severity, Message}&lt;/code&gt;:</source>
          <target state="translated">OSメッセージはタプル &lt;code&gt;{Time, Category, Facility, Severity, Message}&lt;/code&gt; としてフォーマットされます：</target>
        </trans-unit>
        <trans-unit id="a67749980ef635fc8a670abb9e6fe74b4789978f" translate="yes" xml:space="preserve">
          <source>OS standard client and Erlang daemon (server)</source>
          <target state="translated">OS 標準クライアントと Erlang デーモン (サーバ)</target>
        </trans-unit>
        <trans-unit id="1d1d16f43b9dc83cb0dfdf26c6b908a0323be7d3" translate="yes" xml:space="preserve">
          <source>OS system time can also be retreived by &lt;code&gt;&lt;a href=&quot;#system_time-0&quot;&gt;system_time/0&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#system_time-1&quot;&gt;system_time/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">OSシステム時間は、 &lt;code&gt;&lt;a href=&quot;#system_time-0&quot;&gt;system_time/0&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;#system_time-1&quot;&gt;system_time/1&lt;/a&gt;&lt;/code&gt; でも取得できます。</target>
        </trans-unit>
        <trans-unit id="253b34ed7414f8bd95bdcad3ec3b4eb61f4c6738" translate="yes" xml:space="preserve">
          <source>OS system time must be correct when the user finalizes the time offset.</source>
          <target state="translated">ユーザーが時間オフセットを確定する際には、OSシステムの時刻が正しくなければなりません。</target>
        </trans-unit>
        <trans-unit id="6a1aec662bcb7daef4aac0bdc11df31e66bf2d12" translate="yes" xml:space="preserve">
          <source>OTP 17.0</source>
          <target state="translated">OTP 17.</target>
        </trans-unit>
        <trans-unit id="de82a1d6e138a112b2ca58f2dba4eb38c8d2b810" translate="yes" xml:space="preserve">
          <source>OTP 17.1</source>
          <target state="translated">OTP 17.</target>
        </trans-unit>
        <trans-unit id="b37bb2cd4f43310f6b07a381a40baa26e515175a" translate="yes" xml:space="preserve">
          <source>OTP 17.1.2</source>
          <target state="translated">OTP 17.</target>
        </trans-unit>
        <trans-unit id="7e91f185f69a2ee4d0fbc84adbe27a2af2afdba2" translate="yes" xml:space="preserve">
          <source>OTP 17.3</source>
          <target state="translated">OTP 17.3</target>
        </trans-unit>
        <trans-unit id="5349cafd1d20ce8426e0b816e9c62b481bf800e1" translate="yes" xml:space="preserve">
          <source>OTP 17.4</source>
          <target state="translated">OTP 17.4</target>
        </trans-unit>
        <trans-unit id="b7470cc6ea6636b34aed5c1b324e72d549188877" translate="yes" xml:space="preserve">
          <source>OTP 17.5</source>
          <target state="translated">OTP 17.</target>
        </trans-unit>
        <trans-unit id="303ea13a1fd386fe9f485b047ad9fbdd6c02040e" translate="yes" xml:space="preserve">
          <source>OTP 17.5.3</source>
          <target state="translated">OTP 17.</target>
        </trans-unit>
        <trans-unit id="43fb89bd5f06bbf79eb565ca69b6861d91f7db23" translate="yes" xml:space="preserve">
          <source>OTP 17.5.6</source>
          <target state="translated">OTP 17.</target>
        </trans-unit>
        <trans-unit id="a80c6f60adc5b870c25fb7c1013052f9d969c1e6" translate="yes" xml:space="preserve">
          <source>OTP 18.0</source>
          <target state="translated">OTP 18.</target>
        </trans-unit>
        <trans-unit id="5fb7af0c267d730fc45b68514cdc898b04ecd498" translate="yes" xml:space="preserve">
          <source>OTP 18.1</source>
          <target state="translated">OTP 18.</target>
        </trans-unit>
        <trans-unit id="17bc05cb3765c17f769bcb5b7fb96b731b1c3725" translate="yes" xml:space="preserve">
          <source>OTP 18.1.1</source>
          <target state="translated">OTP 18.</target>
        </trans-unit>
        <trans-unit id="3dd3b841b2d92c0b1abf38595d7acccf3845a2fa" translate="yes" xml:space="preserve">
          <source>OTP 18.2</source>
          <target state="translated">OTP 18.2</target>
        </trans-unit>
        <trans-unit id="bcc6e46df551f13559fc03eedfe953522eb1359b" translate="yes" xml:space="preserve">
          <source>OTP 18.3</source>
          <target state="translated">OTP 18.3</target>
        </trans-unit>
        <trans-unit id="f79c51896e23a1d1a678491db0ebaac921c06655" translate="yes" xml:space="preserve">
          <source>OTP 18.3.3</source>
          <target state="translated">OTP 18.3.3</target>
        </trans-unit>
        <trans-unit id="fda7846ff22cbff28cabbc39495e00ce1b7a18c2" translate="yes" xml:space="preserve">
          <source>OTP 19.0</source>
          <target state="translated">OTP 19.0</target>
        </trans-unit>
        <trans-unit id="932d95768670e0cd5fdbc1095ed0d1b993a8b2d9" translate="yes" xml:space="preserve">
          <source>OTP 19.1</source>
          <target state="translated">OTP 19.1</target>
        </trans-unit>
        <trans-unit id="05083dc18d014647306ef002a92e31b47deb28fc" translate="yes" xml:space="preserve">
          <source>OTP 19.2</source>
          <target state="translated">OTP 19.2</target>
        </trans-unit>
        <trans-unit id="ae471f5364f5af28f7619f0b3d347819f821f34c" translate="yes" xml:space="preserve">
          <source>OTP 19.3</source>
          <target state="translated">OTP 19.3</target>
        </trans-unit>
        <trans-unit id="2dfa396d52da21e038d97a4ee414f99969525781" translate="yes" xml:space="preserve">
          <source>OTP 20.0</source>
          <target state="translated">OTP 20.</target>
        </trans-unit>
        <trans-unit id="3c37e3f1567db3d2ab061a53dad37370ec3d4a22" translate="yes" xml:space="preserve">
          <source>OTP 20.1</source>
          <target state="translated">OTP 20.</target>
        </trans-unit>
        <trans-unit id="85f3a32e48ff7a1dda6db9c262b2f8cbf4924dab" translate="yes" xml:space="preserve">
          <source>OTP 20.1.3</source>
          <target state="translated">OTP 20.1.3</target>
        </trans-unit>
        <trans-unit id="3d1ec79e85f251b1426541568df1755b478c8f13" translate="yes" xml:space="preserve">
          <source>OTP 20.2</source>
          <target state="translated">OTP 20.2</target>
        </trans-unit>
        <trans-unit id="571eb6245a94eb851a6d7f90f3a8e74e0ae0d599" translate="yes" xml:space="preserve">
          <source>OTP 20.2.3</source>
          <target state="translated">OTP 20.2.3</target>
        </trans-unit>
        <trans-unit id="e7e47bfe8e3a87617385f6f0d76f42d53dc879d6" translate="yes" xml:space="preserve">
          <source>OTP 20.3</source>
          <target state="translated">OTP 20.3</target>
        </trans-unit>
        <trans-unit id="c00961db21191f2944a9b797a6cdbf961bf46d33" translate="yes" xml:space="preserve">
          <source>OTP 21.0</source>
          <target state="translated">OTP 21.</target>
        </trans-unit>
        <trans-unit id="cb5be130ed3c502555d8f25e673de0b9efaa0941" translate="yes" xml:space="preserve">
          <source>OTP 21.0.6</source>
          <target state="translated">OTP 21.</target>
        </trans-unit>
        <trans-unit id="6021644865848073f992bae8b9c943c4afc7f8d3" translate="yes" xml:space="preserve">
          <source>OTP 21.1</source>
          <target state="translated">OTP 21.</target>
        </trans-unit>
        <trans-unit id="89bbe1165ae35f17f43e710bfcffbe55c6ef69a2" translate="yes" xml:space="preserve">
          <source>OTP 21.2</source>
          <target state="translated">OTP 21.2</target>
        </trans-unit>
        <trans-unit id="c2e689e6310bfe6136b48d902e26821ce9f123a9" translate="yes" xml:space="preserve">
          <source>OTP 21.3</source>
          <target state="translated">OTP 21.3</target>
        </trans-unit>
        <trans-unit id="1028e9221844cfd633f1eb008eaabcd781d51f96" translate="yes" xml:space="preserve">
          <source>OTP 21.3.8</source>
          <target state="translated">OTP 21.3.8</target>
        </trans-unit>
        <trans-unit id="c232413f3213891452a5c261023c072ccd809791" translate="yes" xml:space="preserve">
          <source>OTP 22.0</source>
          <target state="translated">OTP 22.</target>
        </trans-unit>
        <trans-unit id="f48773e8bb6bc4865bc681e3589d114b4e76b24a" translate="yes" xml:space="preserve">
          <source>OTP 22.1</source>
          <target state="translated">OTP 22.</target>
        </trans-unit>
        <trans-unit id="91df35b0c49a83fd12aa5367b8122925620295d9" translate="yes" xml:space="preserve">
          <source>OTP 22.3</source>
          <target state="translated">OTP 22.3</target>
        </trans-unit>
        <trans-unit id="d2e767c5320fed5f340e4813fb7b81851515b9db" translate="yes" xml:space="preserve">
          <source>OTP 23.0</source>
          <target state="translated">OTP 23.0</target>
        </trans-unit>
        <trans-unit id="645ad46075735cc44ee0b79de93dee14343f8e64" translate="yes" xml:space="preserve">
          <source>OTP 23.1</source>
          <target state="translated">OTP 23.1</target>
        </trans-unit>
        <trans-unit id="2c7aca3e13ec5787bed988186babbcbbb08e4d83" translate="yes" xml:space="preserve">
          <source>OTP 23.2</source>
          <target state="translated">OTP 23.2</target>
        </trans-unit>
        <trans-unit id="5c5cb3c43764b6e3642d0cc6e9870ab0a059e023" translate="yes" xml:space="preserve">
          <source>OTP R13B04</source>
          <target state="translated">OTP R13B04</target>
        </trans-unit>
        <trans-unit id="12c6138485cd68240ee15c2a9a5be15cfec50775" translate="yes" xml:space="preserve">
          <source>OTP R14B</source>
          <target state="translated">OTP R14B</target>
        </trans-unit>
        <trans-unit id="5b1b5b8bc61568f039950359e0853f2bf506f077" translate="yes" xml:space="preserve">
          <source>OTP R14B01</source>
          <target state="translated">OTP R14B01</target>
        </trans-unit>
        <trans-unit id="d2068218ce2ddac80161a50fcee5791fada3771a" translate="yes" xml:space="preserve">
          <source>OTP R14B02</source>
          <target state="translated">OTP R14B02</target>
        </trans-unit>
        <trans-unit id="3f9beac3fef36e94cdbe62f62d9631b02ce56c0c" translate="yes" xml:space="preserve">
          <source>OTP R14B03</source>
          <target state="translated">OTP R14B03</target>
        </trans-unit>
        <trans-unit id="da2cafa05f322e10fce6e2a71d88c24e3384148b" translate="yes" xml:space="preserve">
          <source>OTP R14B04</source>
          <target state="translated">OTP R14B04</target>
        </trans-unit>
        <trans-unit id="8c661581e56206ae5fffaf6b280a8cebf6df8545" translate="yes" xml:space="preserve">
          <source>OTP R15B</source>
          <target state="translated">OTP R15B</target>
        </trans-unit>
        <trans-unit id="9de524763778e0a0702eb821d76e1813ba58749a" translate="yes" xml:space="preserve">
          <source>OTP R15B01</source>
          <target state="translated">OTP R15B01</target>
        </trans-unit>
        <trans-unit id="af10a49ebba90d9d20eaf701836dad0d8942390f" translate="yes" xml:space="preserve">
          <source>OTP R15B02</source>
          <target state="translated">OTP R15B02</target>
        </trans-unit>
        <trans-unit id="927bd5757ada2536880868ac83237b0ba7d7267a" translate="yes" xml:space="preserve">
          <source>OTP R15B03</source>
          <target state="translated">OTP R15B03</target>
        </trans-unit>
        <trans-unit id="42d49d7f1b267727894067d4e17bd61989d7f900" translate="yes" xml:space="preserve">
          <source>OTP R16B</source>
          <target state="translated">OTP R16B</target>
        </trans-unit>
        <trans-unit id="5cf5721a7a707f5795c8ede7966ac925475590f0" translate="yes" xml:space="preserve">
          <source>OTP R16B01</source>
          <target state="translated">OTP R16B01</target>
        </trans-unit>
        <trans-unit id="99a6f83de13304461ed514ae1410a25c30bef92f" translate="yes" xml:space="preserve">
          <source>OTP R16B02</source>
          <target state="translated">OTP R16B02</target>
        </trans-unit>
        <trans-unit id="72498ce41f5658d95091b6ea2350ae21b5605581" translate="yes" xml:space="preserve">
          <source>OTP R16B03</source>
          <target state="translated">OTP R16B03</target>
        </trans-unit>
        <trans-unit id="8d85f4d55d00adcbdf0c015b765c1dbf0415d274" translate="yes" xml:space="preserve">
          <source>OTP Versions Table</source>
          <target state="translated">OTPバージョン表</target>
        </trans-unit>
        <trans-unit id="eb8e226d4cd37fd7c5b423ed6b5c26f687955027" translate="yes" xml:space="preserve">
          <source>OTP also supports changing the internal state of behaviour processes, see &lt;code&gt;&lt;a href=&quot;#int_state&quot;&gt;Changing Internal State&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">OTPは、動作プロセスの内部状態の変更もサポートしています。内部状態の &lt;code&gt;&lt;a href=&quot;#int_state&quot;&gt;Changing Internal State&lt;/a&gt;&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="4d6221b6a86032737a577d124bf2adb0a2907b66" translate="yes" xml:space="preserve">
          <source>OTP and (in consequence) the Mnesia database.</source>
          <target state="translated">OTPと(結果的に)Mnesiaデータベース。</target>
        </trans-unit>
        <trans-unit id="a850f204ff4cd54ef41e013bea894026258c1347" translate="yes" xml:space="preserve">
          <source>OTP application Config</source>
          <target state="translated">OTPアプリケーションの設定</target>
        </trans-unit>
        <trans-unit id="8f1f0506b65365d10c75cb9d39c0d18910b4731c" translate="yes" xml:space="preserve">
          <source>OTP of a specific version is a set of applications of specific versions. The application versions identified by an OTP version corresponds to application versions that have been tested together by the Erlang/OTP team at Ericsson AB. An OTP system can, however, be put together with applications from different OTP versions. Such a combination of application versions has not been tested by the Erlang/OTP team. It is therefore &lt;strong&gt;always preferred to use OTP applications from one single OTP version&lt;/strong&gt;.</source>
          <target state="translated">特定のバージョンのOTPは、特定のバージョンの一連のアプリケーションです。OTPバージョンによって識別されるアプリケーションバージョンは、Ericsson ABのErlang / OTPチームによって一緒にテストされたアプリケーションバージョンに対応します。ただし、OTPシステムは、異なるOTPバージョンのアプリケーションと組み合わせることができます。このようなアプリケーションバージョンの組み合わせは、Erlang / OTPチームによってテストされていません。したがって、&lt;strong&gt;単一のOTPバージョンからOTPアプリケーションを使用する&lt;/strong&gt;ことが&lt;strong&gt;常に推奨されます&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="2611693947bb5144c4c4a537a229fe14dfc567db" translate="yes" xml:space="preserve">
          <source>OTP start script example for Unix.</source>
          <target state="translated">Unix用のOTP開始スクリプトの例。</target>
        </trans-unit>
        <trans-unit id="44ed97d7d2bc021f13ae4421351ee910df8ab6f2" translate="yes" xml:space="preserve">
          <source>OTP supports a set of &lt;strong&gt;release handling instructions&lt;/strong&gt; that are used when creating &lt;code&gt;.appup&lt;/code&gt; files. The release handler understands a subset of these, the &lt;strong&gt;low-level&lt;/strong&gt; instructions. To make it easier for the user, there are also a number of &lt;strong&gt;high-level&lt;/strong&gt; instructions, which are translated to low-level instructions by &lt;code&gt;systools:make_relup&lt;/code&gt;.</source>
          <target state="translated">OTPは、 &lt;code&gt;.appup&lt;/code&gt; ファイルの作成時に使用される一連の&lt;strong&gt;リリース処理命令&lt;/strong&gt;をサポートしています。リリースハンドラは、これらのサブセットである&lt;strong&gt;低レベルの&lt;/strong&gt;命令を理解します。ユーザーにとってより簡単にするために、 &lt;code&gt;systools:make_relup&lt;/code&gt; によって低レベルの命令に変換される多数の&lt;strong&gt;高レベルの&lt;/strong&gt;命令もあります。&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9ab311b5a61d5450520dde937fd634cbc9976caf" translate="yes" xml:space="preserve">
          <source>OTP thus provides no support for changing residence modules except in the case of &lt;code&gt;&lt;a href=&quot;#spec&quot;&gt;special processes&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">したがって、OTPは、 &lt;code&gt;&lt;a href=&quot;#spec&quot;&gt;special processes&lt;/a&gt;&lt;/code&gt; 場合を除いて、レジデンスモジュールの変更をサポートしません。</target>
        </trans-unit>
        <trans-unit id="ad15f1b38f41249c946792c972d910fa729db9d3" translate="yes" xml:space="preserve">
          <source>OTP-22 introduces support for TLS 1.3. The current implementation supports a selective set of cryptographic algorithms:</source>
          <target state="translated">OTP-22 は TLS 1.3 のサポートを導入しています。現在の実装では、暗号化アルゴリズムの選択的なセットをサポートしています。</target>
        </trans-unit>
        <trans-unit id="d96fc983a2c3eaec3d8d2f2620f536bca0494a75" translate="yes" xml:space="preserve">
          <source>OTP-22.0</source>
          <target state="translated">OTP-22.0</target>
        </trans-unit>
        <trans-unit id="e91f35ba89b72bce378114917c30a606df1775f6" translate="yes" xml:space="preserve">
          <source>OTP-23</source>
          <target state="translated">OTP-23</target>
        </trans-unit>
        <trans-unit id="7a931e0d87dd0cc978b0822251977a0aacd4fc45" translate="yes" xml:space="preserve">
          <source>OTP-SNMPEA-MIB</source>
          <target state="translated">OTP-SNMPEA-MIB</target>
        </trans-unit>
        <trans-unit id="15c4e1f1a4334a82cc1247671dd99e92e6bbd166" translate="yes" xml:space="preserve">
          <source>OTP/Crypto requires that the user provides two or three items of information about the key. The application used by the user is usually on a higher level, for example in &lt;code&gt;SSL&lt;/code&gt;. If using the crypto application directly, it is required that:</source>
          <target state="translated">OTP / Cryptoでは、ユーザーがキーに関する2つまたは3つの情報項目を提供する必要があります。ユーザーが使用するアプリケーションは通常、 &lt;code&gt;SSL&lt;/code&gt; などの上位レベルにあります。暗号アプリケーションを直接使用する場合は、次のことが必要です。</target>
        </trans-unit>
        <trans-unit id="e00f6c999c0a17c02e9b5c79025ff5ac5261cb4a" translate="yes" xml:space="preserve">
          <source>Object identifier, a tuple of integers as generated by the &lt;code&gt;ASN.1&lt;/code&gt; compiler.</source>
          <target state="translated">オブジェクト識別子 &lt;code&gt;ASN.1&lt;/code&gt; コンパイラによって生成される整数のタプル。</target>
        </trans-unit>
        <trans-unit id="d389e1fd4f8140b1a2e4262dca91df97551e6b3f" translate="yes" xml:space="preserve">
          <source>Object-based programming with &lt;code&gt;Mnesia&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; によるオブジェクトベースのプログラミング</target>
        </trans-unit>
        <trans-unit id="e9756e31b402ef2beef3722149ad80b87a0cb1c1" translate="yes" xml:space="preserve">
          <source>Objects are stored and retrieved through set and get functions. The following example shows how to store integers, floats, strings, and arbitrary binary objects:</source>
          <target state="translated">オブジェクトは、set関数とget関数を介して格納および取得されます。次の例では、整数、浮動小数点、文字列、任意のバイナリオブジェクトを格納する方法を示しています。</target>
        </trans-unit>
        <trans-unit id="13dfd2b8ca88ce5b44fe927b518926c1e0325e95" translate="yes" xml:space="preserve">
          <source>Objects can be removed from the registry:</source>
          <target state="translated">オブジェクトをレジストリから削除することができます。</target>
        </trans-unit>
        <trans-unit id="c5b9dd639a75a9d87bd4d53f043c544fbedd0e4c" translate="yes" xml:space="preserve">
          <source>Observe that E2 may differ from E if for instance there are default values defined in &lt;code&gt;my_XML_Schema.xsd&lt;/code&gt;.</source>
          <target state="translated">たとえば &lt;code&gt;my_XML_Schema.xsd&lt;/code&gt; にデフォルト値が定義されている場合、E2がEと異なる場合があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="fb56c5f19fbe9c5d32b08c312c11052dd5b634b7" translate="yes" xml:space="preserve">
          <source>Observe that the 'TerminationId' record is not used in the internal form. It has been replaced with a megaco_term_id record (defined in &quot;megaco/include/megaco.hrl&quot;).</source>
          <target state="translated">TerminationId' レコードは、内部フォームでは使用されていないことに注意してください。これは、megaco_term_idレコード(&quot;megaco/include/megaco.hrl &quot;で定義されている)で置き換えられています。</target>
        </trans-unit>
        <trans-unit id="0bd7b307bc7f8afe70fed7a42de3d9fbb7b82fbb" translate="yes" xml:space="preserve">
          <source>Observe that white space: each space, tab or line feed, between mark-up results in an xmlText record.</source>
          <target state="translated">ホワイトスペース:マークアップの間のスペース、タブ、改行は xmlText レコードになることを確認してください。</target>
        </trans-unit>
        <trans-unit id="ab7e64c97fc5b12d3a53c3eaa9ee4e2f13560916" translate="yes" xml:space="preserve">
          <source>Observer</source>
          <target state="translated">Observer</target>
        </trans-unit>
        <trans-unit id="92d3bdde80720a307b847a6b8a1080bcd444b6aa" translate="yes" xml:space="preserve">
          <source>Observer is a graphical tool for observing the characteristics of Erlang systems. Observer displays system information, application supervisor trees, process information, ETS tables, Mnesia tables and contains a front end for Erlang tracing.</source>
          <target state="translated">ObserverはErlangシステムの特性を観察するためのグラフィカルなツールです。Observerはシステム情報、アプリケーションスーパバイザツリー、プロセス情報、ETSテーブル、Mnesiaテーブルを表示し、Erlangトレース用のフロントエンドを含みます。</target>
        </trans-unit>
        <trans-unit id="28cd1180f301b3154359b73583ee4c15ce0124d5" translate="yes" xml:space="preserve">
          <source>Observer is a graphical tool for observing the characteristics of Erlang systems. The tool Observer displays system information, application supervisor trees, process information, ETS tables, Mnesia tables, and contains a front end for Erlang tracing with module &lt;code&gt;&lt;a href=&quot;ttb&quot;&gt;ttb&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Observerは、Erlangシステムの特性を観察するためのグラフィカルツールです。ツールObserverは、システム情報、アプリケーションスーパーバイザツリー、プロセス情報、ETSテーブル、Mnesiaテーブルを表示し、モジュール &lt;code&gt;&lt;a href=&quot;ttb&quot;&gt;ttb&lt;/a&gt;&lt;/code&gt; による Erlangトレースのフロントエンドを含みます。</target>
        </trans-unit>
        <trans-unit id="8160323258aa98f01ffae3a9b4dd4732b06a4950" translate="yes" xml:space="preserve">
          <source>Obsolete API functions</source>
          <target state="translated">廃止されたAPI機能</target>
        </trans-unit>
        <trans-unit id="828b44c38dbd9a16becde3e71362fe411c4b2d3c" translate="yes" xml:space="preserve">
          <source>Obsolete flag without any effect and common misspelling for &lt;code&gt;-setcookie&lt;/code&gt;. Use &lt;code&gt;-setcookie&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;-setcookie&lt;/code&gt; の効果と一般的なスペルミスのない古いフラグ。代わりに &lt;code&gt;-setcookie&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="c8219545b990a3e898482be1f33bdc7f5472c0ab" translate="yes" xml:space="preserve">
          <source>Obviously, PCRE cannot support the interpolation of Perl code. Instead, it supports special syntax for recursion of the entire pattern, and for individual subpattern recursion. After its introduction in PCRE and Python, this kind of recursion was later introduced into Perl at release 5.10.</source>
          <target state="translated">明らかに、PCREはPerlコードの補間をサポートしていません。その代わりに、パターン全体の再帰や個々のサブパターンの再帰のための特別な構文をサポートしています。PCREとPythonで導入された後、この種の再帰は後にリリース5.10でPerlに導入されました。</target>
        </trans-unit>
        <trans-unit id="b15614a1ab393e5aeea9a1c392c3fa0e2e84f379" translate="yes" xml:space="preserve">
          <source>Obviously, that code does not work if the original order of the list is important. If the order of the list must be preserved, do as follows:</source>
          <target state="translated">明らかに、リストの元の順序が重要な場合、このコードは動作しません。リストの順序を保持しなければならない場合は、次のようにします。</target>
        </trans-unit>
        <trans-unit id="8e8dc61a9436adab84db0adcc2c88c413a482fca" translate="yes" xml:space="preserve">
          <source>Of ECDSA keys, only the Normally an RSA, DSA or ECDSA public key, but handling of other public keys can be added.</source>
          <target state="translated">ECDSA 鍵のうち、通常は RSA,DSA,ECDSA 公開鍵のみですが、その他の公開鍵の取り扱いを追加することができます。</target>
        </trans-unit>
        <trans-unit id="cf5975c0e8398e81740d7e6c9235666c7fc797c5" translate="yes" xml:space="preserve">
          <source>Off: Normal black and white display.</source>
          <target state="translated">オフ:通常の白黒表示。</target>
        </trans-unit>
        <trans-unit id="5e3b98e05dad157bd1a4bd5b9b0d226314cec835" translate="yes" xml:space="preserve">
          <source>Offline support - &lt;code&gt;systools&lt;/code&gt; for generating scripts and building release packages</source>
          <target state="translated">オフラインサポート- スクリプトの生成とリリースパッケージの &lt;code&gt;systools&lt;/code&gt; ためのsystools</target>
        </trans-unit>
        <trans-unit id="f14b6c908a17fd970288025ad39d8151e0e31dda" translate="yes" xml:space="preserve">
          <source>Offset from the current position.</source>
          <target state="translated">現在位置からのオフセット。</target>
        </trans-unit>
        <trans-unit id="48274bc06ce68fdb7834b5006c17db38cfd5bca3" translate="yes" xml:space="preserve">
          <source>Offset from the end of file.</source>
          <target state="translated">ファイルの末尾からのオフセット。</target>
        </trans-unit>
        <trans-unit id="74f0c027755f3a641da0ac7fb4fdc91ca752be19" translate="yes" xml:space="preserve">
          <source>Offset to the next byte to write which also equals the amount of bytes currently written.</source>
          <target state="translated">現在書き込まれているバイト数に等しい次の書き込みバイトへのオフセット。</target>
        </trans-unit>
        <trans-unit id="c21c3314a2e6470603bd3c8f84047cb484b50ba5" translate="yes" xml:space="preserve">
          <source>Ogham</source>
          <target state="translated">Ogham</target>
        </trans-unit>
        <trans-unit id="b9c65c4bca9e4ad28b61b07b9af83fd8c0fb84c8" translate="yes" xml:space="preserve">
          <source>Ogham space mark</source>
          <target state="translated">オガムスペースマーク</target>
        </trans-unit>
        <trans-unit id="80a20b8493b41152418b7eebcae86cbcce091a38" translate="yes" xml:space="preserve">
          <source>Okasaki API</source>
          <target state="translated">岡崎API</target>
        </trans-unit>
        <trans-unit id="5f8e3c9a997d8c6ac6d8e0cee37f365cfccbf2c1" translate="yes" xml:space="preserve">
          <source>Ol_Chiki</source>
          <target state="translated">Ol_Chiki</target>
        </trans-unit>
        <trans-unit id="5d9e0077e7780f989a1ceec9b3ec38c49f01d731" translate="yes" xml:space="preserve">
          <source>Old API</source>
          <target state="translated">旧API</target>
        </trans-unit>
        <trans-unit id="3e62dbf3fb5370db410bc5b62d0381b5e3d16213" translate="yes" xml:space="preserve">
          <source>Old Crypto API</source>
          <target state="translated">旧Crypto API</target>
        </trans-unit>
        <trans-unit id="b6ffd367297aa558fd23448e1c93eab612c4b2b7" translate="yes" xml:space="preserve">
          <source>Old URI utility module, use uri_string instead</source>
          <target state="translated">古い URI ユーティリティモジュール、代わりに uri_string を使用</target>
        </trans-unit>
        <trans-unit id="b178b6946982a11f1126a949ec15c4d708664fde" translate="yes" xml:space="preserve">
          <source>Old drivers (compiled with an &lt;code&gt;erl_driver.h&lt;/code&gt; from an ERTS version earlier than 5.9) must be updated and have to use the extended interface (with &lt;code&gt;&lt;a href=&quot;erl_driver#version_management&quot;&gt;version management &lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">古いドライバー（5.9より前のERTSバージョンの &lt;code&gt;erl_driver.h&lt;/code&gt; でコンパイル）を更新する必要があり、拡張インターフェイス（ &lt;code&gt;&lt;a href=&quot;erl_driver#version_management&quot;&gt;version management &lt;/a&gt;&lt;/code&gt; ）を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="9ae910bfed0c2daf647c1a19f49b4a126bc16739" translate="yes" xml:space="preserve">
          <source>Old drivers (compiled with an &lt;code&gt;erl_driver.h&lt;/code&gt; from an ERTS version earlier than 5.9) must be updated and have to use the extended interface (with &lt;code&gt;&lt;a href=&quot;erl_driver#version_management&quot;&gt;version management&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">古いドライバー（5.9より前のERTSバージョンの &lt;code&gt;erl_driver.h&lt;/code&gt; でコンパイル）は更新する必要があり、（ &lt;code&gt;&lt;a href=&quot;erl_driver#version_management&quot;&gt;version management&lt;/a&gt;&lt;/code&gt; ）拡張インターフェースを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="13302e0d3a7dec730ee4bc597d731b5ec3f28913" translate="yes" xml:space="preserve">
          <source>Old-style exec specification that are kept for compatibility, but should not be used in new programs</source>
          <target state="translated">互換性のために保存されているが、新しいプログラムでは使用してはいけない旧式の exec 仕様</target>
        </trans-unit>
        <trans-unit id="157d75488b894d1cda756fa16127123d4d8b2331" translate="yes" xml:space="preserve">
          <source>OldBindType</source>
          <target state="translated">OldBindType</target>
        </trans-unit>
        <trans-unit id="7f70150bb048b630bda877379e329b1cba4ccf5d" translate="yes" xml:space="preserve">
          <source>OldBlockState</source>
          <target state="translated">OldBlockState</target>
        </trans-unit>
        <trans-unit id="dc265f2b8ca2bd1379067a84bcb36eee5f10c186" translate="yes" xml:space="preserve">
          <source>OldBoolean</source>
          <target state="translated">OldBoolean</target>
        </trans-unit>
        <trans-unit id="787f17ec93244a470977d9765b05c214ad524302" translate="yes" xml:space="preserve">
          <source>OldCpuTopology</source>
          <target state="translated">OldCpuTopology</target>
        </trans-unit>
        <trans-unit id="05284679f579d778eb76c6cb35f0adb51c1143c0" translate="yes" xml:space="preserve">
          <source>OldDirtyCPUSchedulersOnline</source>
          <target state="translated">OldDirtyCPUSchedulersOnline</target>
        </trans-unit>
        <trans-unit id="d3e43fe6cc5ed7e93ad3fb3737bbd4c693602579" translate="yes" xml:space="preserve">
          <source>OldLevel :: &lt;code&gt;&lt;a href=&quot;#type-debug_level&quot;&gt;debug_level()&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">OldLevel :: &lt;code&gt;&lt;a href=&quot;#type-debug_level&quot;&gt;debug_level()&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a1967122f5b0089c8c148736f325420c2e6e602a" translate="yes" xml:space="preserve">
          <source>OldMaxHeapSize</source>
          <target state="translated">OldMaxHeapSize</target>
        </trans-unit>
        <trans-unit id="44bb9d52af1c27b72d85ec222d49edbefed7f191" translate="yes" xml:space="preserve">
          <source>OldMinBinVHeapSize</source>
          <target state="translated">OldMinBinVHeapSize</target>
        </trans-unit>
        <trans-unit id="f03c39aabd48a51861a01442c2abd764c60f8791" translate="yes" xml:space="preserve">
          <source>OldMinHeapSize</source>
          <target state="translated">OldMinHeapSize</target>
        </trans-unit>
        <trans-unit id="a2eedd11d2145f39f33a241d59529adc2aae480c" translate="yes" xml:space="preserve">
          <source>OldSchedulersOnline</source>
          <target state="translated">OldSchedulersOnline</target>
        </trans-unit>
        <trans-unit id="145ae46273aca133d92d9931894007faba8a6122" translate="yes" xml:space="preserve">
          <source>OldState</source>
          <target state="translated">OldState</target>
        </trans-unit>
        <trans-unit id="47ef70f9915b940884f76385b871fac7afb63176" translate="yes" xml:space="preserve">
          <source>OldValue</source>
          <target state="translated">OldValue</target>
        </trans-unit>
        <trans-unit id="d31721795f21dfce26688a7f8239a17ca4259705" translate="yes" xml:space="preserve">
          <source>Old_Italic</source>
          <target state="translated">Old_Italic</target>
        </trans-unit>
        <trans-unit id="2c0a6c802c2e969dfccf2fc785162a6f2b61c2bf" translate="yes" xml:space="preserve">
          <source>Old_North_Arabian</source>
          <target state="translated">Old_North_Arabian</target>
        </trans-unit>
        <trans-unit id="18fae1f67a0f3b95f77e39e31f33b8e9c0d5f5cb" translate="yes" xml:space="preserve">
          <source>Old_Permic</source>
          <target state="translated">Old_Permic</target>
        </trans-unit>
        <trans-unit id="40f6b23336b20230fad65810979b94941509719d" translate="yes" xml:space="preserve">
          <source>Old_Persian</source>
          <target state="translated">Old_Persian</target>
        </trans-unit>
        <trans-unit id="338432c6b8828a6dc79884aa878e0a2867c42479" translate="yes" xml:space="preserve">
          <source>Old_South_Arabian</source>
          <target state="translated">Old_South_Arabian</target>
        </trans-unit>
        <trans-unit id="3641abb7a588932eef54e644e9d1dff8f948abbf" translate="yes" xml:space="preserve">
          <source>Old_Turkic</source>
          <target state="translated">Old_Turkic</target>
        </trans-unit>
        <trans-unit id="ba2f4398b4a78c8c3781b266ce8f8b6790397950" translate="yes" xml:space="preserve">
          <source>Omit the &lt;code&gt;options&lt;/code&gt; and &lt;code&gt;source&lt;/code&gt; tuples in the list returned by &lt;code&gt;Module:module_info(compile)&lt;/code&gt;, and reduce the paths in stack traces to the module name alone. This option will make it easier to achieve reproducible builds.</source>
          <target state="translated">&lt;code&gt;Module:module_info(compile)&lt;/code&gt; によって返されるリストの &lt;code&gt;options&lt;/code&gt; と &lt;code&gt;source&lt;/code&gt; タプルを省略し、スタックトレースのパスをモジュール名のみに減らします。このオプションを使用すると、再現性のあるビルドを簡単に実現できます。</target>
        </trans-unit>
        <trans-unit id="3c4dff48e0bc069d363085bc649284833fa87dbe" translate="yes" xml:space="preserve">
          <source>Omit the &lt;code&gt;options&lt;/code&gt; and &lt;code&gt;source&lt;/code&gt; tuples in the list returned by &lt;code&gt;Module:module_info(compile)&lt;/code&gt;. This option will make it easier to achieve reproducible builds.</source>
          <target state="translated">&lt;code&gt;Module:module_info(compile)&lt;/code&gt; が返すリストの &lt;code&gt;options&lt;/code&gt; と &lt;code&gt;source&lt;/code&gt; タプルを省略します。このオプションを使用すると、再現可能なビルドを簡単に実現できます。</target>
        </trans-unit>
        <trans-unit id="d1489713bac73f4571aa2114bb6a0e8bece846ba" translate="yes" xml:space="preserve">
          <source>Omits line number information to produce a slightly smaller output file.</source>
          <target state="translated">行番号情報を省略して、少し小さめの出力ファイルを作成します。</target>
        </trans-unit>
        <trans-unit id="ece5ff7a95f46bc465af7ccdd8565b862f2ad117" translate="yes" xml:space="preserve">
          <source>Omitted fields then get the value of evaluating &lt;code&gt;ExprL&lt;/code&gt; instead of their default values. This feature is primarily intended to be used to create patterns for ETS and Mnesia match functions.</source>
          <target state="translated">省略されたフィールドは、デフォルト値の代わりに &lt;code&gt;ExprL&lt;/code&gt; を評価する値を取得します。この機能は主に、ETSおよびMnesiaの照合機能のパターンを作成するために使用することを目的としています。</target>
        </trans-unit>
        <trans-unit id="2b4336bcea263f419ca09551f44528b242f15a01" translate="yes" xml:space="preserve">
          <source>On 32 bit systems, there is not enough virtual memory space to allocate 1 GB for just literals, so instead small 256 KB sized literal regions are created on demand and a card mark bit-array of the entire 32 bit memory space is then used to determine if a term is a literal or not. Since the total memory space is only 32 bits, the card mark bit-array is only 256 words large. On a 64 bit system the same bit-array would have to be 1 tera words large, so this technique is only viable on 32 bit systems. Doing &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-19.0/erts/emulator/beam/erl_alloc.h#L316-L319&quot;&gt;lookups in the array&lt;/a&gt;&lt;/code&gt; is a little more expensive then just doing the pointer checks that can be done in 64 bit systems, but not extremely so.</source>
          <target state="translated">32ビットシステムでは、リテラルだけに1 GBを割り当てるのに十分な仮想メモリスペースがないため、代わりに256 KBサイズの小さなリテラル領域がオンデマンドで作成され、32ビットメモリスペース全体のカードマークビット配列が使用されます。用語がリテラルであるかどうかを判別します。合計メモリスペースはわずか32ビットであるため、カードマークのビット配列はわずか256ワードの大きさです。 64ビットシステムでは、同じビット配列は1テラワードの大きさである必要があるため、この手法は32ビットシステムでのみ実行可能です。こう &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-19.0/erts/emulator/beam/erl_alloc.h#L316-L319&quot;&gt;lookups in the array&lt;/a&gt;&lt;/code&gt; ほとんどないが、より高価なそしてちょうどではなく、非常にそう、64ビットシステムで行うことができ、ポインタのチェックを行っています。</target>
        </trans-unit>
        <trans-unit id="837ccb981f94461d47fadaa07a7f5c5a91558bf2" translate="yes" xml:space="preserve">
          <source>On 32-bit architectures: -134217729 &amp;lt; i &amp;lt; 134217728 (28 bits).</source>
          <target state="translated">32ビットアーキテクチャの場合：-134217729 &amp;lt;i &amp;lt;134217728（28ビット）。</target>
        </trans-unit>
        <trans-unit id="07aa96ddf4a255f77698c1f72e8dbbc6f7d0ac40" translate="yes" xml:space="preserve">
          <source>On 32-bit architectures: 4 words.</source>
          <target state="translated">32ビットアーキテクチャで。4つの単語。</target>
        </trans-unit>
        <trans-unit id="0aaea3805ba5a1657f963cc5531935c14dbff051" translate="yes" xml:space="preserve">
          <source>On 32-bit architectures: 5 words for a reference from the current local node + 7 words for a reference from another node.</source>
          <target state="translated">32 ビ ッ ト アーキテ ク チ ャ の場合。現在のローカル・ノードからの参照には5ワード、別のノードからの参照には7ワード。</target>
        </trans-unit>
        <trans-unit id="d729d6c56ff45c63b971639d2a3f12703da39867" translate="yes" xml:space="preserve">
          <source>On 64 bit systems that allow mapping of unreserved virtual memory areas (most operating systems except Windows), an area of size 1 GB (by default) is mapped and then all literals are placed within that area. Then all that has to be done to determine if something is a literal or not is &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-19.0/erts/emulator/beam/erl_alloc.h#L322-L324&quot;&gt;two quick pointer checks&lt;/a&gt;&lt;/code&gt;. This system relies on the fact that a memory page that has not been touched yet does not take any actual space. So even if 1 GB of virtual memory is mapped, only the memory which is actually needed for literals is allocated in ram. The size of the literal area is configurable through the +MIscs erts_alloc option.</source>
          <target state="translated">予約されていない仮想メモリ領域のマッピングを許可する64ビットシステム（Windowsを除くほとんどのオペレーティングシステム）では、サイズ1 GB（デフォルト）の領域がマップされ、すべてのリテラルがその領域内に配置されます。次に、何かがリテラルであるかどうかを判断するために実行する必要があるのは、 &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-19.0/erts/emulator/beam/erl_alloc.h#L322-L324&quot;&gt;two quick pointer checks&lt;/a&gt;&lt;/code&gt; です。このシステムは、まだタッチされていないメモリページが実際のスペースを占有しないという事実に依存しています。したがって、1 GBの仮想メモリがマップされている場合でも、リテラルに実際に必要なメモリのみがRAMに割り当てられます。リテラル領域のサイズは、+ MIscserts_allocオプションを使用して構成できます。</target>
        </trans-unit>
        <trans-unit id="4ee722acfea1218e0e9779b8fb79277f2b70e2b3" translate="yes" xml:space="preserve">
          <source>On 64 bit windows, on which erts_alloc cannot do unreserved virtual memory mappings, a &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-19.0/erts/emulator/beam/erl_term.h#L59&quot;&gt;special tag&lt;/a&gt;&lt;/code&gt; within the Erlang term object is used to determine if something &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-19.0/erts/emulator/beam/erl_term.h#L248-L252&quot;&gt;is a literal or not&lt;/a&gt;&lt;/code&gt;. This is very cheap, however, the tag is only available on 64 bit machines, and it is possible to do a great deal of other nice optimizations with this tag in the future (like for instance a more compact list implementation) so it is not used on operating systems where it is not needed.</source>
          <target state="translated">erts_allocが予約されていない仮想メモリマッピングを実行できない64ビットウィンドウでは、Erlang用語オブジェクト内の &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-19.0/erts/emulator/beam/erl_term.h#L59&quot;&gt;special tag&lt;/a&gt;&lt;/code&gt; 使用して、何か &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-19.0/erts/emulator/beam/erl_term.h#L248-L252&quot;&gt;is a literal or not&lt;/a&gt;&lt;/code&gt; どうかを判断します。これは非常に安価ですが、タグは64ビットマシンでのみ使用可能であり、将来的にはこのタグを使用して他の多くの優れた最適化を行うことができるため（たとえば、よりコンパクトなリストの実装など）、そうではありません。不要なオペレーティングシステムで使用されます。</target>
        </trans-unit>
        <trans-unit id="7773ad37cb673ee9b7860d0d4b67f31e39b62273" translate="yes" xml:space="preserve">
          <source>On 64-bit architectures: -576460752303423489 &amp;lt; i &amp;lt; 576460752303423488 (60 bits).</source>
          <target state="translated">64ビットアーキテクチャの場合：-576460752303423489 &amp;lt;i &amp;lt;576460752303423488（60ビット）。</target>
        </trans-unit>
        <trans-unit id="ccffdbcaffb960350b1f03947273d32a77218dd0" translate="yes" xml:space="preserve">
          <source>On 64-bit architectures: 3 words.</source>
          <target state="translated">64ビットアーキテクチャで。3つの単語。</target>
        </trans-unit>
        <trans-unit id="f4432adb4e3eddcf803da55fd62c8256f8c01dca" translate="yes" xml:space="preserve">
          <source>On 64-bit architectures: 4 words for a reference from the current local node + 6 words for a reference from another node.</source>
          <target state="translated">64 ビット・アーキテクチャの場合。現在のローカル・ノードからの参照には4ワード、別のノードからの参照には6ワード。</target>
        </trans-unit>
        <trans-unit id="883c639f7255c347e035338f052f0ec88dae56ed" translate="yes" xml:space="preserve">
          <source>On C-nodes, &lt;code&gt;erl_interface&lt;/code&gt; has support for registry tables. These tables reside in RAM on the C-node, but can also be dumped into Mnesia tables. By default, the dumping of registry tables through &lt;code&gt;erl_interface&lt;/code&gt; causes a corresponding Mnesia table to be created with &lt;code&gt;mnesia_registry:create_table/1&lt;/code&gt;, if necessary.</source>
          <target state="translated">Cノードでは、 &lt;code&gt;erl_interface&lt;/code&gt; はレジストリテーブルをサポートしています。これらのテーブルはCノードのRAMにありますが、Mnesiaテーブルにダンプすることもできます。デフォルトでは、 &lt;code&gt;erl_interface&lt;/code&gt; を介してレジストリテーブルをダンプすると、必要に応じて、対応するMnesiaテーブルが &lt;code&gt;mnesia_registry:create_table/1&lt;/code&gt; で作成されます。</target>
        </trans-unit>
        <trans-unit id="53c351034515d0f74abb562de89183321dc3361d" translate="yes" xml:space="preserve">
          <source>On Darwin:</source>
          <target state="translated">ダーウィンについて</target>
        </trans-unit>
        <trans-unit id="452d25bd3843cd164bb696cf08ee12ab9733accf" translate="yes" xml:space="preserve">
          <source>On Linux or UNIX you can safely ignore this and simply create a file called &lt;code&gt;.erlang.cookie&lt;/code&gt; in the directory you get to after executing the command &lt;code&gt;cd&lt;/code&gt; without any argument.</source>
          <target state="translated">LinuxまたはUNIXでは、これを安全に無視して、引数なしで &lt;code&gt;cd&lt;/code&gt; コマンドを実行した後、 &lt;code&gt;.erlang.cookie&lt;/code&gt; するディレクトリに.erlang.cookieというファイルを作成するだけで済みます。</target>
        </trans-unit>
        <trans-unit id="1abae7c719ffd5227ee01660d1ddd20cb3841aa3" translate="yes" xml:space="preserve">
          <source>On Linux systems the following changes will be made:</source>
          <target state="translated">Linux システムでは、以下の変更が行われます。</target>
        </trans-unit>
        <trans-unit id="64ddff816a143447a28cf2b2f9c5227d387e78f6" translate="yes" xml:space="preserve">
          <source>On Linux the memory available to the emulator is &lt;code&gt;cached_memory&lt;/code&gt; and &lt;code&gt;buffered_memory&lt;/code&gt; in addition to &lt;code&gt;free_memory&lt;/code&gt;.</source>
          <target state="translated">Linuxでは、エミュレーターで使用可能なメモリーは、 &lt;code&gt;cached_memory&lt;/code&gt; に加えて &lt;code&gt;free_memory&lt;/code&gt; と &lt;code&gt;buffered_memory&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="07b320892e617ecd19e1d9117dbdaedf7a5983f2" translate="yes" xml:space="preserve">
          <source>On Linux: Respects the os environment variable &lt;code&gt;XDG_CACHE_HOME&lt;/code&gt;.</source>
          <target state="translated">Linuxの場合：os環境変数 &lt;code&gt;XDG_CACHE_HOME&lt;/code&gt; を尊重します。</target>
        </trans-unit>
        <trans-unit id="6c57c64ae3b58fcb5970a5f623f9d3c0f6952789" translate="yes" xml:space="preserve">
          <source>On Linux: Respects the os environment variable &lt;code&gt;XDG_CONFIG_DIRS&lt;/code&gt;.</source>
          <target state="translated">Linuxの場合：os環境変数 &lt;code&gt;XDG_CONFIG_DIRS&lt;/code&gt; を尊重します。</target>
        </trans-unit>
        <trans-unit id="99ba5d0f7bf487770a0030a3221eab9acf0e29cb" translate="yes" xml:space="preserve">
          <source>On Linux: Respects the os environment variable &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt;.</source>
          <target state="translated">Linuxの場合：os環境変数 &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt; を尊重します。</target>
        </trans-unit>
        <trans-unit id="53587ca09ddf330890e10222f1f28d673e022a4f" translate="yes" xml:space="preserve">
          <source>On Linux: Respects the os environment variable &lt;code&gt;XDG_DATA_DIRS&lt;/code&gt;.</source>
          <target state="translated">Linuxの場合：os環境変数 &lt;code&gt;XDG_DATA_DIRS&lt;/code&gt; を尊重します。</target>
        </trans-unit>
        <trans-unit id="d2fc503485c3bbe6875742c0c55de66f8b01c934" translate="yes" xml:space="preserve">
          <source>On Linux: Respects the os environment variable &lt;code&gt;XDG_DATA_HOME&lt;/code&gt;.</source>
          <target state="translated">Linuxの場合：os環境変数 &lt;code&gt;XDG_DATA_HOME&lt;/code&gt; を尊重します。</target>
        </trans-unit>
        <trans-unit id="0127285f8943bba8fbcf06e2c56b836011b620f8" translate="yes" xml:space="preserve">
          <source>On UNIX, the release handler tells the &lt;code&gt;heart&lt;/code&gt; program which command to use to reboot the system. The environment variable &lt;code&gt;HEART_COMMAND&lt;/code&gt;, normally used by the &lt;code&gt;heart&lt;/code&gt; program, is ignored in this case. The command instead defaults to &lt;code&gt;$ROOT/bin/start&lt;/code&gt;. Another command can be set by using the SASL configuration parameter &lt;code&gt;start_prg&lt;/code&gt;, see the &lt;code&gt;sasl(6)&lt;/code&gt; manual page.</source>
          <target state="translated">UNIXでは、リリースハンドラーは、システムの再起動に使用するコマンドを &lt;code&gt;heart&lt;/code&gt; プログラムに指示します。この場合、通常は &lt;code&gt;heart&lt;/code&gt; プログラムによって使用される環境変数 &lt;code&gt;HEART_COMMAND&lt;/code&gt; は無視されます。代わりに、コマンドのデフォルトは &lt;code&gt;$ROOT/bin/start&lt;/code&gt; です。別のコマンドは、コンフィギュレーションパラメータSASLを使用して設定することができ &lt;code&gt;start_prg&lt;/code&gt; 参照、 &lt;code&gt;sasl(6)&lt;/code&gt; マニュアルページを。</target>
        </trans-unit>
        <trans-unit id="9712a16713ddd036d7484cde8377ae9fea3bea13" translate="yes" xml:space="preserve">
          <source>On Ubuntu this can be installed via &lt;code&gt;aptitude&lt;/code&gt;:</source>
          <target state="translated">Ubuntuでは、これは &lt;code&gt;aptitude&lt;/code&gt; 経由でインストールできます：</target>
        </trans-unit>
        <trans-unit id="945f7eb32fc020ed4cd606f8c4ad2c5835f8ead0" translate="yes" xml:space="preserve">
          <source>On Unix platforms, other bits than those listed above may be set.</source>
          <target state="translated">Unixプラットフォームでは、上記以外のビットが設定されている場合があります。</target>
        </trans-unit>
        <trans-unit id="bbea9d064da3b38737aba3e1e6b3c867dfe36620" translate="yes" xml:space="preserve">
          <source>On Unix platforms, the environment is set using UTF-8 encoding if Unicode filename translation is in effect. On Windows, the environment is set using wide character interfaces.</source>
          <target state="translated">Unixプラットフォームでは、Unicodeファイル名変換が有効な場合、環境はUTF-8エンコーディングを使用して設定されます。Windows では、環境はワイドキャラクタインタフェースを使用して設定されます。</target>
        </trans-unit>
        <trans-unit id="864179103393e4079015a89879456910e0840ba4" translate="yes" xml:space="preserve">
          <source>On Unix systems, the Erlang runtime will interpret two types of signals.</source>
          <target state="translated">Unixシステムでは、Erlangランタイムは2種類のシグナルを解釈します。</target>
        </trans-unit>
        <trans-unit id="42f4a0b9ff2bf60e97136e578acd75fee6a21d57" translate="yes" xml:space="preserve">
          <source>On Unix the &lt;code&gt;event&lt;/code&gt; is a pipe or socket handle (or something that the &lt;code&gt;select&lt;/code&gt; system call understands).</source>
          <target state="translated">Unixでは、 &lt;code&gt;event&lt;/code&gt; はパイプまたはソケットハンドル（または &lt;code&gt;select&lt;/code&gt; システムコールが理解するもの）です。</target>
        </trans-unit>
        <trans-unit id="89488e0941b289b30ca17db0724ef6eb3f8cddfc" translate="yes" xml:space="preserve">
          <source>On Unix, &lt;code&gt;Osname&lt;/code&gt; has the same value as &lt;code&gt;uname -s&lt;/code&gt; returns, but in lower case. For example, on Solaris 1 and 2, it is &lt;code&gt;sunos&lt;/code&gt;.</source>
          <target state="translated">Unixでは、 &lt;code&gt;Osname&lt;/code&gt; は &lt;code&gt;uname -s&lt;/code&gt; と同じ値を返しますが、小文字です。たとえば、Solaris 1および2では、 &lt;code&gt;sunos&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="6f9abb41d788d59d3b3b9428af793da0ceb8018a" translate="yes" xml:space="preserve">
          <source>On Unix, any value specified for this field is ignored (the &quot;ctime&quot; for the file is set to the current time). On Windows, this field is the new creation time to set for the file.</source>
          <target state="translated">Unixでは、このフィールドに指定された値は無視される(ファイルの「ctime」は現在の時刻に設定される)。Windowsでは、このフィールドはファイルに設定する新規作成時刻である。</target>
        </trans-unit>
        <trans-unit id="2f21108f8f59c58399736174f45da9282d8305fe" translate="yes" xml:space="preserve">
          <source>On Unix-like operating systems, parameters are expected to be UTF-8 without translation if Unicode filenames are enabled.</source>
          <target state="translated">Unix 系のオペレーティングシステムでは、Unicode ファイル名を有効にしている場合、パラメータは翻訳なしで UTF-8 であることが予想されます。</target>
        </trans-unit>
        <trans-unit id="624724bf76a78b8d09ce52016c5a6eefce217dcc" translate="yes" xml:space="preserve">
          <source>On Unix-like operating systems, the terminal is to be able to handle UTF-8 on input and output (this is done by, for example, modern versions of XTerm, KDE Konsole, and the Gnome terminal) and your locale settings must be proper. As an example, a &lt;code&gt;LANG&lt;/code&gt; environment variable can be set as follows:</source>
          <target state="translated">Unixライクなオペレーティングシステムでは、ターミナルは入力と出力でUTF-8を処理できます（これは、たとえば、最新バージョンのXTerm、KDE ​​Konsole、およびGnomeターミナルによって行われます）。ロケール設定は適切。例として、 &lt;code&gt;LANG&lt;/code&gt; 環境変数は次のように設定できます。</target>
        </trans-unit>
        <trans-unit id="3343aa00325e17effeba793420c23aae68f68a75" translate="yes" xml:space="preserve">
          <source>On Windows XP, select &lt;strong&gt;Control Panel&lt;/strong&gt; &amp;gt; &lt;strong&gt;Regional and Language Options&lt;/strong&gt;, select tab &lt;strong&gt;Language&lt;/strong&gt;, and click button &lt;strong&gt;Details...&lt;/strong&gt; in the square named &lt;strong&gt;Text Services and Input Languages&lt;/strong&gt;.</source>
          <target state="translated">Windows XPでは、[ &lt;strong&gt;コントロールパネル]&lt;/strong&gt; &amp;gt; [ &lt;strong&gt;地域と言語のオプション&lt;/strong&gt; ]を選択し、[ &lt;strong&gt;言語&lt;/strong&gt; ]タブを選択して、[ &lt;strong&gt;テキストサービスと入力言語]&lt;/strong&gt;という名前の四角形の[ &lt;strong&gt;詳細...&lt;/strong&gt; ]ボタンをクリックします。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7bdd9c7b68e080175354bdf3fad784b9f495039c" translate="yes" xml:space="preserve">
          <source>On Windows platforms, Erlang searches the system registry rather than looks for configuration files when started in long name distributed mode.</source>
          <target state="translated">Windowsプラットフォームでは、Erlangは長い名前の分散モードで起動すると、設定ファイルを探すのではなくシステムレジストリを検索します。</target>
        </trans-unit>
        <trans-unit id="e26d25aabbde72aeec251ac7d6d7e8b7d5ff65e1" translate="yes" xml:space="preserve">
          <source>On Windows systems the home directory is the directory pointed out by the environment variable $HOME - you may need to set this.</source>
          <target state="translated">Windows システムでは、ホームディレクトリは環境変数 $HOME で指定されたディレクトリになります-これを設定する必要があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="5c1eb5371b5194cdf64f66156f192b541e886e24" translate="yes" xml:space="preserve">
          <source>On Windows the &lt;code&gt;event&lt;/code&gt; is an &lt;code&gt;Event&lt;/code&gt; or &lt;code&gt;Semaphore&lt;/code&gt; (or something that the &lt;code&gt;WaitForMultipleObjects&lt;/code&gt; API function understands). (Some trickery in the emulator allows more than the built-in limit of 64 &lt;code&gt;Events&lt;/code&gt; to be used.)</source>
          <target state="translated">Windowsでは、 &lt;code&gt;event&lt;/code&gt; は &lt;code&gt;Event&lt;/code&gt; または &lt;code&gt;Semaphore&lt;/code&gt; （または &lt;code&gt;WaitForMultipleObjects&lt;/code&gt; API関数が理解するもの）です。（エミュレーターの一部のトリックでは、組み込みの64 &lt;code&gt;Events&lt;/code&gt; 制限を超えて使用できます。）</target>
        </trans-unit>
        <trans-unit id="07f408912d4e25cbe3e69c344bbf252be7275718" translate="yes" xml:space="preserve">
          <source>On Windows the default value is set to &lt;code&gt;8196&lt;/code&gt; because the normal OS limitations are set higher than most machines can handle.</source>
          <target state="translated">Windowsでは、通常のOSの制限がほとんどのマシンで処理できるよりも高く設定されているため、デフォルト値は &lt;code&gt;8196&lt;/code&gt; に設定されています。</target>
        </trans-unit>
        <trans-unit id="d4b05412a62bc9a89fb50987de22114d258a3cec" translate="yes" xml:space="preserve">
          <source>On Windows the maximum number of nodes allowed in one epmd instance is 60. This is because of limitations in the current implementation. If you need more nodes, you should look into using and erlang based epmd implementation such as &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/epmd&quot;&gt;Erlang EPMD&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Windowsでは、1つのepmdインスタンスで許可されるノードの最大数は60です。これは、現在の実装の制限によるものです。あなたがより多くのノードが必要な場合は、次のようなベースのEPMD実装を使用してアーランになるはず &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/epmd&quot;&gt;Erlang EPMD&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="818c5818d712a93bb76a90d8f6ce9237479e8047" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;code&gt;Osname&lt;/code&gt; is &lt;code&gt;nt&lt;/code&gt;.</source>
          <target state="translated">Windowsでは、 &lt;code&gt;Osname&lt;/code&gt; は &lt;code&gt;nt&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="08a45149384450c4928eab3da298a998b5209ee6" translate="yes" xml:space="preserve">
          <source>On Windows, proper operation requires that a suitable font is installed and selected for the Erlang application to use. If no suitable font is available on your system, try installing the &lt;code&gt;&lt;a href=&quot;http://dejavu-fonts.org&quot;&gt;DejaVu fonts&lt;/a&gt;&lt;/code&gt;, which are freely available, and then select that font in the Erlang shell application.</source>
          <target state="translated">Windowsでは、適切な操作には、適切なフォントがインストールされ、Erlangアプリケーションが使用するために選択されている必要があります。システムに適切なフォントがない場合は、無料で入手できる &lt;code&gt;&lt;a href=&quot;http://dejavu-fonts.org&quot;&gt;DejaVu fonts&lt;/a&gt;&lt;/code&gt; インストールしてから、Erlangシェルアプリケーションでそのフォントを選択します。</target>
        </trans-unit>
        <trans-unit id="73a6c028854ad01eefd9a69b170bcc32b5780e1c" translate="yes" xml:space="preserve">
          <source>On Windows, the data is fetched from different OS API functions, so the &lt;code&gt;Netmask&lt;/code&gt; and &lt;code&gt;Broadaddr&lt;/code&gt; values can be calculated, just as some &lt;code&gt;Flag&lt;/code&gt; values. Report flagrant bugs.</source>
          <target state="translated">Windowsでは、データはさまざまなOS API関数からフェッチされるため、一部の &lt;code&gt;Flag&lt;/code&gt; 値と &lt;code&gt;Broadaddr&lt;/code&gt; 、 &lt;code&gt;Netmask&lt;/code&gt; とBroadaddrの値を計算できます。重大なバグを報告してください。</target>
        </trans-unit>
        <trans-unit id="47575c57c43d9b6b182dce9d049d1942967994c2" translate="yes" xml:space="preserve">
          <source>On Windows, the data is fetched from different OS API functions, so the &lt;code&gt;Netmask&lt;/code&gt; and &lt;code&gt;Broadaddr&lt;/code&gt; values may be calculated, just as some &lt;code&gt;Flags&lt;/code&gt; values.</source>
          <target state="translated">Windowsでは、データはさまざまなOS API関数からフェッチされるため、一部の &lt;code&gt;Flags&lt;/code&gt; 値と &lt;code&gt;Broadaddr&lt;/code&gt; 、 &lt;code&gt;Netmask&lt;/code&gt; 値とBroadaddr値を計算できます。</target>
        </trans-unit>
        <trans-unit id="0e5200c5fc7e9186939f4793a54da361f708e107" translate="yes" xml:space="preserve">
          <source>On Windows, the preferred way to start the Erlang system for interactive use is as follows:</source>
          <target state="translated">Windowsでは、対話的にErlangシステムを起動するには次のようにします。</target>
        </trans-unit>
        <trans-unit id="e3c787c6250b0d27168a0579a029fe138a257fab" translate="yes" xml:space="preserve">
          <source>On Windows, use semi-colon as separator.</source>
          <target state="translated">Windowsではセミコロンを区切り文字として使用します。</target>
        </trans-unit>
        <trans-unit id="55b56364276b5f7e47e7f031287b139fc5b947d5" translate="yes" xml:space="preserve">
          <source>On Windows:</source>
          <target state="translated">Windowsで。</target>
        </trans-unit>
        <trans-unit id="91de63a646561418f6b7e070668224cb4764e75e" translate="yes" xml:space="preserve">
          <source>On a Unix system you can view the manual pages from the command line using</source>
          <target state="translated">Unix システムでは、コマンドラインから以下のようにしてマニュアルページを見ることができます。</target>
        </trans-unit>
        <trans-unit id="3c1e7fbc1efc10479b9f342b1427cfdbfeabd446" translate="yes" xml:space="preserve">
          <source>On a Unix-like system, &lt;code&gt;ERL_LIBS&lt;/code&gt; can be set to the following</source>
          <target state="translated">Unixライクなシステムでは、 &lt;code&gt;ERL_LIBS&lt;/code&gt; を次のように設定できます。</target>
        </trans-unit>
        <trans-unit id="a74d3fb56059df82993a50e11000b4ec43a6e044" translate="yes" xml:space="preserve">
          <source>On a conceptual level starting a database connection using the Erlang ODBC API is a basic client server application. The client process uses the API to start and communicate with the server process that manages the connection. The strategy of the Erlang ODBC application is that programming faults in the application itself will cause the connection process to terminate abnormally.(When a process terminates abnormally its supervisor will log relevant error reports.) Calls to API functions during or after termination of the connection process, will return &lt;code&gt;{error, connection_closed}&lt;/code&gt;. Contextual errors on the other hand will not terminate the connection it will only return &lt;code&gt;{error, Reason}&lt;/code&gt; to the client, where &lt;code&gt;Reason&lt;/code&gt; may be any erlang term.</source>
          <target state="translated">概念的なレベルでは、Erlang ODBC APIを使用してデータベース接続を開始することは、基本的なクライアントサーバーアプリケーションです。クライアントプロセスは、APIを使用して、接続を管理するサーバープロセスを開始して通信します。 Erlang ODBCアプリケーションの戦略は、アプリケーション自体のプログラミング障害により接続プロセスが異常終了することです（プロセスが異常終了すると、そのスーパーバイザーは関連するエラーレポートをログに記録します）。接続の終了中または終了後のAPI関数の呼び出しプロセスは &lt;code&gt;{error, connection_closed}&lt;/code&gt; を返します。一方、コンテキストエラーは接続を終了せず、クライアントに &lt;code&gt;{error, Reason}&lt;/code&gt; を返すだけです。この場合、 &lt;code&gt;Reason&lt;/code&gt; は任意のerlang用語である可能性があります。</target>
        </trans-unit>
        <trans-unit id="8d392ddbe029a1a10ad20de9a806356a9c906b21" translate="yes" xml:space="preserve">
          <source>On a file, a term is represented by a header and a binary. Two options define the format of terms on files:</source>
          <target state="translated">ファイル上では、用語はヘッダとバイナリで表現されます。2つのオプションは、ファイル上の用語の形式を定義します。</target>
        </trans-unit>
        <trans-unit id="0a1100e7bfb6397c36a4da859d5dfb1b68d51802" translate="yes" xml:space="preserve">
          <source>On a single core system or if it's a non-reentrant scanner, a single port is created. On a multi-core system with a reentrant scanner, several ports will be created (one for each scheduler).</source>
          <target state="translated">シングルコアシステムでは、またはリエントラントではないスキャナの場合、1つのポートが作成されます。リエントラントスキャナのあるマルチコアシステムでは、複数のポートが作成されます(各スケジューラに1つ)。</target>
        </trans-unit>
        <trans-unit id="b61c13a696c2951dde75411aaee46764defe2d53" translate="yes" xml:space="preserve">
          <source>On a system where release handling is used, this is always to be set to &lt;code&gt;ignore&lt;/code&gt;. Use &lt;code&gt;heart&lt;/code&gt; to restart the service on failure instead.</source>
          <target state="translated">リリース処理が使用されるシステムでは、これは常に &lt;code&gt;ignore&lt;/code&gt; に設定されます。代わりに &lt;code&gt;heart&lt;/code&gt; を使用して、障害時にサービスを再起動します。</target>
        </trans-unit>
        <trans-unit id="ca5dabff07309a8980fe16e2ce2d9b17947978e9" translate="yes" xml:space="preserve">
          <source>On a system without OS monotonic time, Erlang monotonic time guarantees monotonicity, but cannot give other guarantees. The frequency adjustments made to Erlang monotonic time depend on the time warp mode used.</source>
          <target state="translated">OSのモノトニックタイムがないシステムでは、Erlangのモノトニックタイムはモノトニック性を保証しますが、他の保証はできません。Erlangのモノトニックタイムの周波数調整はタイムワープモードに依存します。</target>
        </trans-unit>
        <trans-unit id="78bd91cdbb8d95fdca3d6cb73e168bf34bd8e3ca" translate="yes" xml:space="preserve">
          <source>On all platforms that we provide atomic memory operations, this is just a &lt;code&gt;volatile&lt;/code&gt; read, preventing the compiler to use values in registers, forcing the a read from memory.</source>
          <target state="translated">アトミックメモリ操作を提供するすべてのプラットフォームで、これは単なる &lt;code&gt;volatile&lt;/code&gt; 読み取りであり、コンパイラがレジスタ内の値を使用するのを防ぎ、メモリからの読み取りを強制します。</target>
        </trans-unit>
        <trans-unit id="c10079e3d3b4af33197f73508809dcf8be943c1b" translate="yes" xml:space="preserve">
          <source>On an embedded system it is not uncommon that the system has no power supply, not even a battery, when it is shut off. The system clock on such a system is typically way off when the system boots. If &lt;code&gt;&lt;a href=&quot;#No_Time_Warp_Mode&quot;&gt;no time warp mode&lt;/a&gt;&lt;/code&gt; is used, and the Erlang runtime system is started before OS system time has been corrected, Erlang system time can be wrong for a long time, centuries or even longer.</source>
          <target state="translated">組み込みシステムでは、システムがシャットダウンされているとき、システムに電源がなく、バッテリーさえないことは珍しくありません。このようなシステムのシステムクロックは、通常、システムの起動時にかなりずれています。場合 &lt;code&gt;&lt;a href=&quot;#No_Time_Warp_Mode&quot;&gt;no time warp mode&lt;/a&gt;&lt;/code&gt; 使用されず、OSのシステム時刻が修正される前のErlangランタイムシステムが起動され、Erlangのシステム時間がさらに長い長い時間、何世紀かのために間違っている可能性があります。</target>
        </trans-unit>
        <trans-unit id="94848f950b79b2c5a62062642414a0d81b6809e5" translate="yes" xml:space="preserve">
          <source>On an embedded system, the &lt;code&gt;erlsrv&lt;/code&gt; module is to be used to install the Erlang process as a Windows system service. This service can start after Windows NT has booted.</source>
          <target state="translated">組み込みシステムでは、 &lt;code&gt;erlsrv&lt;/code&gt; モジュールを使用して、ErlangプロセスをWindowsシステムサービスとしてインストールします。このサービスは、Windows NTの起動後に開始できます。</target>
        </trans-unit>
        <trans-unit id="d6e74b9f0f9fc530f5a5a031fbc8a47d65641b3d" translate="yes" xml:space="preserve">
          <source>On application (&lt;code&gt;app&lt;/code&gt;) level, the following options are supported:</source>
          <target state="translated">アプリケーション（ &lt;code&gt;app&lt;/code&gt; ）レベルでは、次のオプションがサポートされています。</target>
        </trans-unit>
        <trans-unit id="8c2c100f87c410005b9664bcf1790490ce2930c4" translate="yes" xml:space="preserve">
          <source>On application (&lt;code&gt;escript&lt;/code&gt;) level, the following options are supported:</source>
          <target state="translated">アプリケーション（ &lt;code&gt;escript&lt;/code&gt; ）レベルでは、次のオプションがサポートされています。</target>
        </trans-unit>
        <trans-unit id="1f2ca7be500feda1d827cc1f5458cea971c16dda" translate="yes" xml:space="preserve">
          <source>On builds without &lt;code&gt;crypto&lt;/code&gt;, &lt;code&gt;ssl&lt;/code&gt; and &lt;code&gt;ssh&lt;/code&gt; there is a failed test case for undefined functions. Verify that the failed test case log only shows calls to skipped applications.</source>
          <target state="translated">&lt;code&gt;crypto&lt;/code&gt; 、 &lt;code&gt;ssl&lt;/code&gt; 、および &lt;code&gt;ssh&lt;/code&gt; なしのビルドでは、未定義の関数のテストケースが失敗します。失敗したテストケースログに、スキップされたアプリケーションへの呼び出しのみが表示されることを確認します。</target>
        </trans-unit>
        <trans-unit id="7b33a0aa47e36eff9a9acf946284dbd48855b743" translate="yes" xml:space="preserve">
          <source>On each Erlang node, a process can be set as the &lt;strong&gt;system tracer&lt;/strong&gt;. This process will receive trace messages each time a message with a trace token is sent or received (if the trace token flag &lt;code&gt;send&lt;/code&gt; or &lt;code&gt;'receive'&lt;/code&gt; is set). The system tracer can then print each trace event, write it to a file, or whatever suitable.</source>
          <target state="translated">各Erlangノードでは、プロセスを&lt;strong&gt;システムトレーサー&lt;/strong&gt;として設定できます。このプロセスは、トレーストークンを含むメッセージが送信または受信されるたびにトレースメッセージを受信します（トレーストークンフラグ &lt;code&gt;send&lt;/code&gt; または &lt;code&gt;'receive'&lt;/code&gt; が設定されている場合）。システムトレーサは、各トレースイベントを出力したり、ファイルに書き込んだり、適切なものを作成できます。</target>
        </trans-unit>
        <trans-unit id="91f3ac52e30283e286d347e915ad6557b2459808" translate="yes" xml:space="preserve">
          <source>On each Erlang node, a process can be set as the &lt;strong&gt;system tracer&lt;/strong&gt;. This process will receive trace messages each time information with a trace token is sent or received (if the trace token flag &lt;code&gt;send&lt;/code&gt; or &lt;code&gt;'receive'&lt;/code&gt; is set). The system tracer can then print each trace event, write it to a file, or whatever suitable.</source>
          <target state="translated">各Erlangノードで、プロセスを&lt;strong&gt;システムトレーサー&lt;/strong&gt;として設定できます。このプロセスは、トレーストークンを含む情報が送信または受信されるたびにトレースメッセージを受信します（トレーストークンフラグの &lt;code&gt;send&lt;/code&gt; または &lt;code&gt;'receive'&lt;/code&gt; が設定されている場合）。システムトレーサーは、各トレースイベントを印刷したり、ファイルに書き込んだりすることができます。</target>
        </trans-unit>
        <trans-unit id="5aa1503e3bb1ca6d6b1d5db02a4ead78c2138817" translate="yes" xml:space="preserve">
          <source>On encode, an OctetString() IPv4 address is parsed in the usual x.x.x.x format while an IPv6 address is parsed in any of the formats specified by section 2.2 of RFC 2373, &quot;Text Representation of Addresses&quot;. An IPv4 tuple() has length 4 and contains values of type 0..255. An IPv6 tuple() has length 8 and contains values of type 0..65535. The tuple representation is used on decode.</source>
          <target state="translated">エンコード時に、OctetString()IPv4アドレスは通常のx.x.x.x.x形式で解析され、IPv6アドレスはRFC2373のセクション2.2「アドレスのテキスト表現」で指定された形式のいずれかで解析される。IPv4タプル()は長さ4で、タイプ0~255の値を含む。IPv6タプル()は長さ8で、タイプ0.65535の値を含む。タプル表現はデコード時に使用されます。</target>
        </trans-unit>
        <trans-unit id="5d15ad498425526235871ebf68fcb9399fdea277" translate="yes" xml:space="preserve">
          <source>On encode, an OctetString() can be specified as an iolist(), excessively large floats (in absolute value) are equivalent to &lt;code&gt;infinity&lt;/code&gt; or &lt;code&gt;'-infinity'&lt;/code&gt; and excessively large integers result in encode failure. The records for grouped AVPs are as discussed in the previous section.</source>
          <target state="translated">エンコードでは、OctetString（）をiolist（）として指定できます。（絶対値で）過度に大きな浮動小数点数は、 &lt;code&gt;infinity&lt;/code&gt; または &lt;code&gt;'-infinity'&lt;/code&gt; と同等であり、過度に大きな整数はエンコードエラーを引き起こします。グループ化されたAVPのレコードは、前のセクションで説明したとおりです。</target>
        </trans-unit>
        <trans-unit id="c7844a2c02e87c5568f9be53b564891e2298588d" translate="yes" xml:space="preserve">
          <source>On encode, fields port, transport and protocol default to 3868, sctp and diameter respectively. The grammar of an OctetString-valued DiameterURI() is as specified in section 4.3 of RFC 6733. The record representation is used on decode.</source>
          <target state="translated">エンコード時のフィールド port、transport、および protocol のデフォルトは、それぞれ 3868、sctp、および diameter である。OctetString値を持つDiameterURI()の文法は、RFC 6733のセクション4.3で規定されている。レコード表現は、デコード時に使用される。</target>
        </trans-unit>
        <trans-unit id="d66c2d9ea2e818fe35630d0324d41a67f4905d83" translate="yes" xml:space="preserve">
          <source>On encode, values can be specified using the macros defined in a dictionary's hrl file.</source>
          <target state="translated">エンコード時には、辞書の hrl ファイルで定義されているマクロを使用して値を指定することができます。</target>
        </trans-unit>
        <trans-unit id="731614e2c441caf07c5c36a9a260f1d7987a91b7" translate="yes" xml:space="preserve">
          <source>On encountering character #, &lt;code&gt;pcre_compile()&lt;/code&gt; skips along, looking for a newline in the pattern. The sequence \n is still literal at this stage, so it does not terminate the comment. Only a character with code value 0x0a (the default newline) does so.</source>
          <target state="translated">文字＃に遭遇すると、 &lt;code&gt;pcre_compile()&lt;/code&gt; はスキップして、パターン内の改行を探します。シーケンス\ nはこの段階ではまだリテラルであるため、コメントは終了しません。コード値0x0a（デフォルトの改行）を持つ文字のみがこれを行います。</target>
        </trans-unit>
        <trans-unit id="6046ea4ed169ee86943dd8f909d8a57065f20fd4" translate="yes" xml:space="preserve">
          <source>On failure, that is, no such environment variable was found, a value &amp;lt; &lt;code&gt;0&lt;/code&gt; is returned. When the size of the &lt;code&gt;value&lt;/code&gt; buffer is too small, a value &amp;gt; &lt;code&gt;0&lt;/code&gt; is returned and &lt;code&gt;*value_size&lt;/code&gt; has been set to the buffer size needed.</source>
          <target state="translated">失敗した場合、つまり、そのような環境変数が見つからなかった場合は、値&amp;lt; &lt;code&gt;0&lt;/code&gt; が返されます。 &lt;code&gt;value&lt;/code&gt; バッファのサイズが小さすぎる場合、 &lt;code&gt;0&lt;/code&gt; より大きい値が返され、 &lt;code&gt;*value_size&lt;/code&gt; は必要なバッファサイズに設定されています。</target>
        </trans-unit>
        <trans-unit id="e7d6dfc6c6549f9a2bde9d0b09efa932ae04ee7b" translate="yes" xml:space="preserve">
          <source>On gollum:</source>
          <target state="translated">ゴラムに</target>
        </trans-unit>
        <trans-unit id="2fb361775fa49f574bf571176cefd50d9c38320a" translate="yes" xml:space="preserve">
          <source>On kosken (on a Linux/UNIX system):</source>
          <target state="translated">kosken上(Linux/UNIXシステム上)。</target>
        </trans-unit>
        <trans-unit id="254bbc8618baf4df2c0d1ded28631159588b541c" translate="yes" xml:space="preserve">
          <source>On line 1-10 the OS headers needed for the driver are included. As this driver is written for Solaris, we know that the header &lt;code&gt;uio.h&lt;/code&gt; exists. So the preprocessor variable &lt;code&gt;HAVE_UIO_H&lt;/code&gt; can be defined before &lt;code&gt;erl_driver.h&lt;/code&gt; is included on line 12. The definition of &lt;code&gt;HAVE_UIO_H&lt;/code&gt; will make the I/O vectors used in Erlang's driver queues to correspond to the operating systems ditto, which is very convenient.</source>
          <target state="translated">1-10行目に、ドライバーに必要なOSヘッダーが含まれています。このドライバーはSolaris用に作成されているため、ヘッダー &lt;code&gt;uio.h&lt;/code&gt; が存在することがわかります。プリプロセッサ変数のよう &lt;code&gt;HAVE_UIO_H&lt;/code&gt; が前に定義することができ &lt;code&gt;erl_driver.h&lt;/code&gt; の定義ライン12に含まれている &lt;code&gt;HAVE_UIO_H&lt;/code&gt; は非常に便利であるオペレーティング・システム同上、に対応するようにアーランのドライバキューで使用されるI / Oベクトルを行います。</target>
        </trans-unit>
        <trans-unit id="233d0459679e240e1a43d6003a0eed16b1b6db16" translate="yes" xml:space="preserve">
          <source>On line 16-23 the different callback functions are declared (&quot;forward declarations&quot;).</source>
          <target state="translated">16-23行目では、異なるコールバック関数が宣言されています(「前方宣言」)。</target>
        </trans-unit>
        <trans-unit id="1829525dba56c919f35e7fe241f7a7f27d37779d" translate="yes" xml:space="preserve">
          <source>On line 4-8 is handled the case where the port is in &lt;code&gt;data&lt;/code&gt; mode or &lt;code&gt;intermediate&lt;/code&gt; mode and the remaining routine handles the different commands. The routine uses the &lt;code&gt;driver_failure_posix()&lt;/code&gt; routine to report errors (see, for example, line 15). Notice that the failure routines make a call to the &lt;code&gt;uds_stop&lt;/code&gt; routine, which will remove the internal port data. The handle (and the casted handle &lt;code&gt;ud&lt;/code&gt;) is therefore &lt;strong&gt;invalid pointers&lt;/strong&gt; after a &lt;code&gt;driver_failure&lt;/code&gt; call and we should &lt;strong&gt;return immediately&lt;/strong&gt;. The runtime system will send exit signals to all linked processes.</source>
          <target state="translated">4-8行目では、ポートが &lt;code&gt;data&lt;/code&gt; モードまたは &lt;code&gt;intermediate&lt;/code&gt; モードであり、残りのルーチンがさまざまなコマンドを処理する場合を処理します。このルーチンは、 &lt;code&gt;driver_failure_posix()&lt;/code&gt; ルーチンを使用してエラーを報告します（たとえば、15行目を参照）。失敗ルーチンが &lt;code&gt;uds_stop&lt;/code&gt; ルーチンを呼び出すことに注意してください。これにより、内部ポートデータが削除されます。したがって、ハンドル（およびキャストされたハンドル &lt;code&gt;ud&lt;/code&gt; ）は、 &lt;code&gt;driver_failure&lt;/code&gt; 呼び出しの後の&lt;strong&gt;無効なポインター&lt;/strong&gt;であり、&lt;strong&gt;すぐに戻る&lt;/strong&gt;必要があり&lt;strong&gt;ます&lt;/strong&gt;。ランタイムシステムは、リンクされているすべてのプロセスに終了信号を送信します。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0784da7963dd222dfcf8b747a5d57b72650b03dc" translate="yes" xml:space="preserve">
          <source>On linux the memory available to the emulator is &lt;code&gt;cached_memory&lt;/code&gt; and &lt;code&gt;buffered_memory&lt;/code&gt; in addition to &lt;code&gt;free_memory&lt;/code&gt;.</source>
          <target state="translated">Linuxでは、エミュレータで使用できるメモリは、 &lt;code&gt;cached_memory&lt;/code&gt; に加えて &lt;code&gt;free_memory&lt;/code&gt; および &lt;code&gt;buffered_memory&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="9d908b49426b880b5a485931417759cde36bd6fa" translate="yes" xml:space="preserve">
          <source>On many platforms, the OS supports only status codes 0-255. A too large status code is truncated by clearing the high bits.</source>
          <target state="translated">多くのプラットフォームでは、OSはステータスコード0~255のみをサポートしています。大きすぎるステータスコードは、上位ビットをクリアすることで切り捨てられます。</target>
        </trans-unit>
        <trans-unit id="01e5aeaef327e8644ba3de200b1361c56477bc67" translate="yes" xml:space="preserve">
          <source>On module (&lt;code&gt;mod&lt;/code&gt;) level, the following options are supported:</source>
          <target state="translated">モジュール（ &lt;code&gt;mod&lt;/code&gt; ）レベルでは、次のオプションがサポートされています。</target>
        </trans-unit>
        <trans-unit id="625fa204254a0a02e9def2bcc01ac2eefa5a78a4" translate="yes" xml:space="preserve">
          <source>On most platforms this option must be set on the socket before associating it to an address. It is therefore only reasonable to specify it when creating the socket and not to use it when calling function (&lt;code&gt;&lt;a href=&quot;#setopts-2&quot;&gt;setopts/2&lt;/a&gt;&lt;/code&gt;) containing this description.</source>
          <target state="translated">ほとんどのプラットフォームでは、このオプションをソケットに設定してから、アドレスに関連付ける必要があります。したがって、ソケットを作成するときにそれを指定し、この説明を含む関数（ &lt;code&gt;&lt;a href=&quot;#setopts-2&quot;&gt;setopts/2&lt;/a&gt;&lt;/code&gt; ）を呼び出すときにそれを使用しないことが合理的です。</target>
        </trans-unit>
        <trans-unit id="83547004e7613d3d63f0a97fcec4dde6aca4cb59" translate="yes" xml:space="preserve">
          <source>On one of the two nodes:</source>
          <target state="translated">2つのノードのうちの1つに</target>
        </trans-unit>
        <trans-unit id="cc0bc87e9803dd29ab16d01f2771141460043748" translate="yes" xml:space="preserve">
          <source>On operating systems with mandatory Unicode filenames, this means that you more easily conform to the filenames of other (non-Erlang) applications. You can also process filenames that, at least on Windows, were inaccessible (because of having names that could not be represented in ISO Latin-1). Also, you avoid creating incomprehensible filenames on MacOS X, as the &lt;code&gt;vfs&lt;/code&gt; layer of the operating system accepts all your filenames as UTF-8 does not rewrite them.</source>
          <target state="translated">必須のUnicodeファイル名を持つオペレーティングシステムでは、これは他の（Erlang以外の）アプリケーションのファイル名に容易に準拠できることを意味します。また、少なくともWindowsではアクセスできなかったファイル名を処理することもできます（ISO Latin-1で表現できない名前があったため）。また、オペレーティングシステムの &lt;code&gt;vfs&lt;/code&gt; レイヤーがすべてのファイル名を受け入れるため、MacOS Xでは理解できないファイル名を作成しないでください。UTF-8はファイル名を書き換えません。</target>
        </trans-unit>
        <trans-unit id="c01b078903bea1781dc2ed9488460d3b352c3b71" translate="yes" xml:space="preserve">
          <source>On operating systems with transparent naming (for example, all Unix systems except MacOS X), default is &lt;code&gt;utf8&lt;/code&gt; if the terminal supports UTF-8, otherwise &lt;code&gt;latin1&lt;/code&gt;. The default can be overridden using &lt;code&gt;+fnl&lt;/code&gt; (to force &lt;code&gt;latin1&lt;/code&gt; mode) or &lt;code&gt;+fnu&lt;/code&gt; (to force &lt;code&gt;utf8&lt;/code&gt; mode) when starting &lt;code&gt;erl&lt;/code&gt;.</source>
          <target state="translated">透過的なネーミングのオペレーティングシステム（たとえば、MacOS Xを除くすべてのUnixシステム）では、端末がUTF-8をサポートしている場合、デフォルトは &lt;code&gt;utf8&lt;/code&gt; です。それ以外の場合は、 &lt;code&gt;latin1&lt;/code&gt; です。デフォルトでは、使用してオーバーライドすることができる &lt;code&gt;+fnl&lt;/code&gt; （強制的に &lt;code&gt;latin1&lt;/code&gt; モード）または &lt;code&gt;+fnu&lt;/code&gt; （力に &lt;code&gt;utf8&lt;/code&gt; 起動時モード） &lt;code&gt;erl&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6bd025a43addf4cf8a811c722598b09ff48bc9cb" translate="yes" xml:space="preserve">
          <source>On operating systems with transparent naming, files can be inconsistently named, for example, some files are encoded in UTF-8 while others are encoded in ISO Latin-1. The concept of &lt;strong&gt;raw filenames&lt;/strong&gt; is introduced to handle file systems with inconsistent naming when running in &lt;code&gt;utf8&lt;/code&gt; mode.</source>
          <target state="translated">透過的な命名のあるオペレーティングシステムでは、ファイルの名前に一貫性がない場合があります。たとえば、一部のファイルはUTF-8でエンコードされ、他のファイルはISO Latin-1でエンコードされます。&lt;strong&gt;生のファイル名&lt;/strong&gt;の概念は、 &lt;code&gt;utf8&lt;/code&gt; モードで実行するときに一貫性のない名前のファイルシステムを処理するために導入されました。</target>
        </trans-unit>
        <trans-unit id="e0eed5fde65bb7a382758dcc51496a31ac264639" translate="yes" xml:space="preserve">
          <source>On other supported systems, see &lt;code&gt;&lt;a href=&quot;#Advanced-configuration-and-build-of-ErlangOTP_Configuring&quot;&gt;Advanced Configure&lt;/a&gt;&lt;/code&gt; on how to enable HiPE.</source>
          <target state="translated">その他のサポートされているシステムでは、HiPEを有効にする方法について、 &lt;code&gt;&lt;a href=&quot;#Advanced-configuration-and-build-of-ErlangOTP_Configuring&quot;&gt;Advanced Configure&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="553a2be33582dd908d9294011101091577e2f096" translate="yes" xml:space="preserve">
          <source>On platforms supporting it, enables the POSIX &lt;code&gt;O_SYNC&lt;/code&gt; synchronous I/O flag or its platform-dependent equivalent (for example, &lt;code&gt;FILE_FLAG_WRITE_THROUGH&lt;/code&gt; on Windows) so that writes to the file block until the data is physically written to disk. However, be aware that the exact semantics of this flag differ from platform to platform. For example, none of Linux or Windows guarantees that all file metadata are also written before the call returns. For precise semantics, check the details of your platform documentation. On platforms with no support for POSIX &lt;code&gt;O_SYNC&lt;/code&gt; or equivalent, use of the &lt;code&gt;sync&lt;/code&gt; flag causes &lt;code&gt;open&lt;/code&gt; to return &lt;code&gt;{error, enotsup}&lt;/code&gt;.</source>
          <target state="translated">これをサポートするプラットフォームでは、POSIX &lt;code&gt;O_SYNC&lt;/code&gt; 同期I / Oフラグまたはそれに対応するプラットフォーム依存のフラグ（Windowsの &lt;code&gt;FILE_FLAG_WRITE_THROUGH&lt;/code&gt; など）を有効にして、データがディスクに物理的に書き込まれるまでファイルブロックに書き込みます。ただし、このフラグの正確なセマンティクスはプラットフォームごとに異なることに注意してください。たとえば、LinuxまたはWindowsでは、呼び出しが戻る前にすべてのファイルメタデータも書き込まれることを保証していません。正確なセマンティクスについては、プラットフォームのドキュメントの詳細を確認してください。 POSIX &lt;code&gt;O_SYNC&lt;/code&gt; または同等の機能がサポートされていないプラットフォームでは、 &lt;code&gt;sync&lt;/code&gt; フラグを使用すると、 &lt;code&gt;open&lt;/code&gt; は &lt;code&gt;{error, enotsup}&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="d150b84d58ca2e7d5f356e3aff31a3d84da95bdf" translate="yes" xml:space="preserve">
          <source>On some operating systems &lt;strong&gt;syslog&lt;/strong&gt; will be used for error reporting when &lt;code&gt;epmd&lt;/code&gt; runs as a daemon. To enable the error logging, you must edit the /etc/syslog.conf file and add an entry:</source>
          <target state="translated">一部のオペレーティングシステムでは、 &lt;code&gt;epmd&lt;/code&gt; がデーモンとして実行されている場合、エラー報告に&lt;strong&gt;syslog&lt;/strong&gt;が使用されます。エラーログを有効にするには、/ etc / syslog.confファイルを編集してエントリを追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="47544928855d61173caf643cd7bfa90a251b1e29" translate="yes" xml:space="preserve">
          <source>On some platforms Perl may behave strangely if certain locales are set. If you get errors when building, try setting the LANG variable:</source>
          <target state="translated">プラットフォームによっては、特定のロケールが設定されていると Perl の動作がおかしくなることがあります。ビルド時にエラーが出る場合は、LANG変数を設定してみてください。</target>
        </trans-unit>
        <trans-unit id="c557f429b8f8be575f4e9231e0c0e909cbf4d560" translate="yes" xml:space="preserve">
          <source>On some platforms its &lt;strong&gt;necessary&lt;/strong&gt; to provide the &lt;code&gt;protocol&lt;/code&gt; as its impossible to retrieve it.</source>
          <target state="translated">一部のプラットフォームでは、 &lt;code&gt;protocol&lt;/code&gt; を取得することが不可能であるため、プロトコルを提供する&lt;strong&gt;必要&lt;/strong&gt;があります。</target>
        </trans-unit>
        <trans-unit id="4a78afab7d6e8dd2e7a981b5139d692992694b9a" translate="yes" xml:space="preserve">
          <source>On some platforms, the only allowed value for this option is &lt;code&gt;true&lt;/code&gt;, for example, OpenBSD and Windows. Trying to set this option to &lt;code&gt;false&lt;/code&gt;, when creating the socket, fails in this case.</source>
          <target state="translated">一部のプラットフォームでは、このオプションに許可される値は &lt;code&gt;true&lt;/code&gt; のみです（OpenBSDやWindowsなど）。このオプションを &lt;code&gt;false&lt;/code&gt; に設定しようとすると、ソケットの作成時に失敗します。</target>
        </trans-unit>
        <trans-unit id="36908e6d72c2b03311eb938d2432a12b5ab335ef" translate="yes" xml:space="preserve">
          <source>On some platforms, this function might have no effect.</source>
          <target state="translated">プラットフォームによっては、この機能は効果がない場合があります。</target>
        </trans-unit>
        <trans-unit id="4e64396927ca10116aa5e806980b90b12fcdc017" translate="yes" xml:space="preserve">
          <source>On some systems it can be necessary to link with some more libraries (for example, &lt;code&gt;libnsl.a&lt;/code&gt; and &lt;code&gt;libsocket.a&lt;/code&gt; on Solaris, or &lt;code&gt;wsock32.lib&lt;/code&gt; on Windows) to use the communication facilities of &lt;code&gt;Erl_Interface&lt;/code&gt;.</source>
          <target state="translated">一部のシステムでは、 &lt;code&gt;libnsl.a&lt;/code&gt; の通信機能を使用するために、さらにいくつかのライブラリー（例えば、Solarisではlibnsl.aおよび &lt;code&gt;libsocket.a&lt;/code&gt; 、Windowsでは &lt;code&gt;wsock32.lib&lt;/code&gt; ）とリンクする必要がある場合があり &lt;code&gt;Erl_Interface&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d0471b1a417f337e7d9ebce0c70ef9a7679a721c" translate="yes" xml:space="preserve">
          <source>On success a pointer to the process identifier is returned. On failure &lt;code&gt;NULL&lt;/code&gt; is returned and &lt;code&gt;erl_errno&lt;/code&gt; is set.</source>
          <target state="translated">成功すると、プロセス識別子へのポインタが返されます。失敗すると &lt;code&gt;NULL&lt;/code&gt; が返され、 &lt;code&gt;erl_errno&lt;/code&gt; が設定されます。</target>
        </trans-unit>
        <trans-unit id="7cd76559ef60de76711ee9a78bc983a284264cd1" translate="yes" xml:space="preserve">
          <source>On success it should set &lt;code&gt;*ctx&lt;/code&gt; to point to a context for the created socket. This context will be passed to all other socket callbacks. This function will be passed the same &lt;code&gt;setup_context&lt;/code&gt; as passed to the preceeding &lt;code&gt;&lt;a href=&quot;#ei_connect_init&quot;&gt;ei_connect_init_ussi()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#ei_connect_init&quot;&gt;ei_connect_xinit_ussi()&lt;/a&gt;&lt;/code&gt; call.</source>
          <target state="translated">成功すると、作成されたソケットのコンテキストを指すように &lt;code&gt;*ctx&lt;/code&gt; を設定する必要があります。このコンテキストは、他のすべてのソケットコールバックに渡されます。この関数には、前の &lt;code&gt;&lt;a href=&quot;#ei_connect_init&quot;&gt;ei_connect_init_ussi()&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;#ei_connect_init&quot;&gt;ei_connect_xinit_ussi()&lt;/a&gt;&lt;/code&gt; 呼び出しに渡されたものと同じ &lt;code&gt;setup_context&lt;/code&gt; が渡されます。</target>
        </trans-unit>
        <trans-unit id="cd81851a39ee097fec934afda86c40e9cc8f6b19" translate="yes" xml:space="preserve">
          <source>On success zero is returned. On failure a posix error code is returned.</source>
          <target state="translated">成功するとゼロを返します。失敗した場合は posix エラーコードが返されます。</target>
        </trans-unit>
        <trans-unit id="09e61d475574f0ccdd55488d9e0d991962394b15" translate="yes" xml:space="preserve">
          <source>On success, &lt;code&gt;*sz&lt;/code&gt; should be set to the handshake packet header size to use. Valid values are &lt;code&gt;2&lt;/code&gt; and &lt;code&gt;4&lt;/code&gt;. Erlang TCP distribution use a handshake packet size of &lt;code&gt;2&lt;/code&gt; and Erlang TLS distribution use a handshake packet size of &lt;code&gt;4&lt;/code&gt;.</source>
          <target state="translated">成功したら、 &lt;code&gt;*sz&lt;/code&gt; を使用するハンドシェイクパケットヘッダーサイズに設定する必要があります。有効な値は &lt;code&gt;2&lt;/code&gt; と &lt;code&gt;4&lt;/code&gt; です。Erlang TCPディストリビューションはハンドシェイクパケットサイズ &lt;code&gt;2&lt;/code&gt; を使用し、ErlangTLSディストリビューションはハンドシェイクパケットサイズ &lt;code&gt;4&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="bb868b4886e090c126e2950aab6d84ed7dcb16dc" translate="yes" xml:space="preserve">
          <source>On success, &lt;code&gt;0&lt;/code&gt; is returned and &lt;code&gt;obuf&lt;/code&gt; is initialized to contain table statistics, otherwise &lt;code&gt;-1&lt;/code&gt; is returned.</source>
          <target state="translated">成功すると &lt;code&gt;0&lt;/code&gt; が返され、 &lt;code&gt;obuf&lt;/code&gt; はテーブル統計を含むように初期化されます。それ以外の場合は &lt;code&gt;-1&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="b55c599082e06de776c0bd626fd828b706a34179" translate="yes" xml:space="preserve">
          <source>On success, &lt;code&gt;0&lt;/code&gt; is returned, the value of the environment variable has been written to the &lt;code&gt;value&lt;/code&gt; buffer, and &lt;code&gt;*value_size&lt;/code&gt; contains the string length (excluding the terminating &lt;code&gt;NULL&lt;/code&gt; character) of the value written to the &lt;code&gt;value&lt;/code&gt; buffer.</source>
          <target state="translated">成功すると、 &lt;code&gt;0&lt;/code&gt; は、環境変数の値が書き込まれている、返された &lt;code&gt;value&lt;/code&gt; バッファ、および &lt;code&gt;*value_size&lt;/code&gt; は（終端を除く文字列の長さ含まれている &lt;code&gt;NULL&lt;/code&gt; のに書き込まれた値の文字） &lt;code&gt;value&lt;/code&gt; バッファを。</target>
        </trans-unit>
        <trans-unit id="eddebcdb76f9fab8ab2298752db267fa58432d28" translate="yes" xml:space="preserve">
          <source>On success, &lt;code&gt;conp&lt;/code&gt; is filled in with the address and node name of the connecting client and a file descriptor is returned. On failure, &lt;code&gt;ERL_ERROR&lt;/code&gt; is returned and &lt;code&gt;erl_errno&lt;/code&gt; is set to &lt;code&gt;EIO&lt;/code&gt;.</source>
          <target state="translated">成功すると、 &lt;code&gt;conp&lt;/code&gt; には接続しているクライアントのアドレスとノード名が入力され、ファイル記述子が返されます。失敗すると、 &lt;code&gt;ERL_ERROR&lt;/code&gt; が返され、 &lt;code&gt;erl_errno&lt;/code&gt; が &lt;code&gt;EIO&lt;/code&gt; に設定されます。</target>
        </trans-unit>
        <trans-unit id="0bc86d5b291cc284bbc0ca0e72d47d0adc2e32d6" translate="yes" xml:space="preserve">
          <source>On success, &lt;code&gt;v&lt;/code&gt; (and &lt;code&gt;size&lt;/code&gt; if the object is binary) is initialized with the value associated with &lt;code&gt;key&lt;/code&gt;, and the function returns &lt;code&gt;EI_INT&lt;/code&gt;, &lt;code&gt;EI_FLT&lt;/code&gt;, &lt;code&gt;EI_STR&lt;/code&gt;, or &lt;code&gt;EI_BIN&lt;/code&gt;, indicating the type of object. On failure, &lt;code&gt;-1&lt;/code&gt; is returned and the arguments are not updated.</source>
          <target state="translated">成功すると、 &lt;code&gt;v&lt;/code&gt; （およびオブジェクトがバイナリの場合は &lt;code&gt;size&lt;/code&gt; ）が &lt;code&gt;key&lt;/code&gt; に関連付けられた値で初期化され、関数は &lt;code&gt;EI_INT&lt;/code&gt; 、 &lt;code&gt;EI_FLT&lt;/code&gt; 、 &lt;code&gt;EI_STR&lt;/code&gt; 、または &lt;code&gt;EI_BIN&lt;/code&gt; を返し、オブジェクトのタイプを示します。失敗すると &lt;code&gt;-1&lt;/code&gt; が返され、引数は更新されません。</target>
        </trans-unit>
        <trans-unit id="969e908d49a7fbc3a7e280f38ab4f55f6067faf3" translate="yes" xml:space="preserve">
          <source>On success, a descriptor connecting the calling process to EPMD is returned. On failure, &lt;code&gt;-1&lt;/code&gt; is returned and &lt;code&gt;erl_errno&lt;/code&gt; is set to:</source>
          <target state="translated">成功すると、呼び出しプロセスをEPMDに接続する記述子が返されます。失敗すると &lt;code&gt;-1&lt;/code&gt; が返され、 &lt;code&gt;erl_errno&lt;/code&gt; が次のように設定されます。</target>
        </trans-unit>
        <trans-unit id="c0dc3f3e2f8d8457d666d03550d6d2ac2fec8095" translate="yes" xml:space="preserve">
          <source>On success, a file descriptor is returned which can be used in a call to &lt;code&gt;ei_accept()&lt;/code&gt;. On failure, &lt;code&gt;ERL_ERROR&lt;/code&gt; is returned and &lt;code&gt;erl_errno&lt;/code&gt; is set to &lt;code&gt;EIO&lt;/code&gt;.</source>
          <target state="translated">成功すると、 &lt;code&gt;ei_accept()&lt;/code&gt; の呼び出しで使用できるファイル記述子が返されます。失敗すると、 &lt;code&gt;ERL_ERROR&lt;/code&gt; が返され、 &lt;code&gt;erl_errno&lt;/code&gt; が &lt;code&gt;EIO&lt;/code&gt; に設定されます。</target>
        </trans-unit>
        <trans-unit id="2aec08e035ff2227fedf237e8aaf81890b198c99" translate="yes" xml:space="preserve">
          <source>On success, sets &lt;code&gt;*key&lt;/code&gt; and &lt;code&gt;*value&lt;/code&gt; and returns &lt;code&gt;true&lt;/code&gt;. Returns &lt;code&gt;false&lt;/code&gt; if the iterator is positioned at head (before first entry) or tail (beyond last entry).</source>
          <target state="translated">成功すると &lt;code&gt;*key&lt;/code&gt; と &lt;code&gt;*value&lt;/code&gt; を設定し、 &lt;code&gt;true&lt;/code&gt; を返します。イテレータが先頭（最初のエントリの前）または末尾（最後のエントリの後ろ）に配置されている場合は &lt;code&gt;false&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="7ef0a43f7b72b72b522ca36cd55aa1e746822b9f" translate="yes" xml:space="preserve">
          <source>On success, sets &lt;code&gt;*pid&lt;/code&gt; to the local process registered with &lt;code&gt;name&lt;/code&gt; and returns &lt;code&gt;true&lt;/code&gt;. If &lt;code&gt;name&lt;/code&gt; is not a registered process, or is not an atom, &lt;code&gt;false&lt;/code&gt; is returned and &lt;code&gt;*pid&lt;/code&gt; is unchanged.</source>
          <target state="translated">成功した場合、 &lt;code&gt;*pid&lt;/code&gt; を &lt;code&gt;name&lt;/code&gt; で登録されたローカルプロセスに設定し、 &lt;code&gt;true&lt;/code&gt; を返します。 &lt;code&gt;name&lt;/code&gt; が登録済みプロセスでない場合、またはアトムでない場合、 &lt;code&gt;false&lt;/code&gt; が返され、 &lt;code&gt;*pid&lt;/code&gt; は変更されません。</target>
        </trans-unit>
        <trans-unit id="073e4acf139e5d3ba364bb27e432c64851509f50" translate="yes" xml:space="preserve">
          <source>On success, sets &lt;code&gt;*port&lt;/code&gt; to the port registered with &lt;code&gt;name&lt;/code&gt; and returns &lt;code&gt;true&lt;/code&gt;. If &lt;code&gt;name&lt;/code&gt; is not a registered port, or is not an atom, &lt;code&gt;false&lt;/code&gt; is returned and &lt;code&gt;*port&lt;/code&gt; is unchanged.</source>
          <target state="translated">成功した場合、 &lt;code&gt;*port&lt;/code&gt; を &lt;code&gt;name&lt;/code&gt; で登録されたポートに設定し、 &lt;code&gt;true&lt;/code&gt; を返します。 &lt;code&gt;name&lt;/code&gt; が登録済みのポートでない場合、またはアトムでない場合、 &lt;code&gt;false&lt;/code&gt; が返され、 &lt;code&gt;*port&lt;/code&gt; は変更されません。</target>
        </trans-unit>
        <trans-unit id="939344767976749cae972a1349799f2c2eaf12ef" translate="yes" xml:space="preserve">
          <source>On success, stores the resulting term at &lt;code&gt;*term&lt;/code&gt; and returns the number of bytes read. Returns &lt;code&gt;0&lt;/code&gt; if decoding fails or if &lt;code&gt;opts&lt;/code&gt; is invalid.</source>
          <target state="translated">成功した場合、結果の項を &lt;code&gt;*term&lt;/code&gt; に格納し、読み取られたバイト数を返します。デコードが失敗した場合、または &lt;code&gt;opts&lt;/code&gt; が無効な場合は &lt;code&gt;0&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="2e2b683cb27a455b0e37378b692f0fae65bff5e5" translate="yes" xml:space="preserve">
          <source>On success, the function returns 0, updates the &lt;code&gt;erlang_pid&lt;/code&gt; pointed to by the pid parameter, and the &lt;code&gt;node&lt;/code&gt; parameter is initialized to the node name where &lt;code&gt;name&lt;/code&gt; is found. On failure, a negative number is returned.</source>
          <target state="translated">成功すると、関数は0を返し、pidパラメーターが指す &lt;code&gt;erlang_pid&lt;/code&gt; を更新し、 &lt;code&gt;node&lt;/code&gt; パラメーターは &lt;code&gt;name&lt;/code&gt; が見つかったノード名に初期化されます。失敗すると、負の数が返されます。</target>
        </trans-unit>
        <trans-unit id="c4c049046abd946d86db876a1e3d6ab44c243545" translate="yes" xml:space="preserve">
          <source>On success, the function returns &lt;code&gt;ERL_MSG&lt;/code&gt; and the &lt;code&gt;Emsg&lt;/code&gt; struct is initialized as described above, or &lt;code&gt;ERL_TICK&lt;/code&gt;, in which case no message is returned. On failure, the function returns &lt;code&gt;ERL_ERROR&lt;/code&gt; and sets &lt;code&gt;erl_errno&lt;/code&gt; to one of:</source>
          <target state="translated">成功した場合に、関数戻り &lt;code&gt;ERL_MSG&lt;/code&gt; と &lt;code&gt;Emsg&lt;/code&gt; の構造体は、上述のように初期化されるか、または &lt;code&gt;ERL_TICK&lt;/code&gt; ないメッセージが返された場合には、。失敗すると、関数は &lt;code&gt;ERL_ERROR&lt;/code&gt; を返し、 &lt;code&gt;erl_errno&lt;/code&gt; を次のいずれかに設定します。</target>
        </trans-unit>
        <trans-unit id="629b14be4c544ff9f65dc57b340e61cbbb39aafa" translate="yes" xml:space="preserve">
          <source>On success, the function returns &lt;code&gt;ok&lt;/code&gt;. On failure, the function returns an opaque error, except the &lt;code&gt;pending_process&lt;/code&gt; error described earlier. The opaque errors are to be translated into human readable form by function &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">成功すると、関数は &lt;code&gt;ok&lt;/code&gt; を返します。失敗すると、関数は前述の &lt;code&gt;pending_process&lt;/code&gt; エラーを除き、不透明なエラーを返します。不透明なエラーは、関数 &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt; によって人間が読める形式に変換されます。</target>
        </trans-unit>
        <trans-unit id="c5f40438c31e5fae2d92b0ab21e0ba8037f1d866" translate="yes" xml:space="preserve">
          <source>On success, the function returns &lt;code&gt;ok&lt;/code&gt;. On failure, the return value is &lt;code&gt;{error,ErrorDesc}&lt;/code&gt;, where &lt;code&gt;ErrorDesc&lt;/code&gt; is an opaque term to be translated into human readable form by function &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">成功すると、関数は &lt;code&gt;ok&lt;/code&gt; を返します。失敗した場合、戻り値は &lt;code&gt;{error,ErrorDesc}&lt;/code&gt; 、 &lt;code&gt;ErrorDesc&lt;/code&gt; は、関数によって人間が読める形式に変換する不透明な用語である &lt;code&gt;&lt;a href=&quot;#format_error-1&quot;&gt;format_error/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9434e82ca19ea4e7015799cf03a1286d4e4d6516" translate="yes" xml:space="preserve">
          <source>On success, the function returns a descriptor connecting the calling process to EPMD. On failure, &lt;code&gt;-1&lt;/code&gt; is returned and &lt;code&gt;erl_errno&lt;/code&gt; is set to &lt;code&gt;EIO&lt;/code&gt;.</source>
          <target state="translated">成功すると、関数は呼び出しプロセスをEPMDに接続する記述子を返します。失敗すると &lt;code&gt;-1&lt;/code&gt; が返され、 &lt;code&gt;erl_errno&lt;/code&gt; が &lt;code&gt;EIO&lt;/code&gt; に設定されます。</target>
        </trans-unit>
        <trans-unit id="a4a5876f3c7f9a8dde05d398be614c4d3bae58d6" translate="yes" xml:space="preserve">
          <source>On success, the function returns a pointer to the resource type and &lt;code&gt;*tried&lt;/code&gt; is set to either &lt;code&gt;ERL_NIF_RT_CREATE&lt;/code&gt; or &lt;code&gt;ERL_NIF_RT_TAKEOVER&lt;/code&gt; to indicate what was done. On failure, returns &lt;code&gt;NULL&lt;/code&gt; and sets &lt;code&gt;*tried&lt;/code&gt; to &lt;code&gt;flags&lt;/code&gt;. It is allowed to set &lt;code&gt;tried&lt;/code&gt; to &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">成功すると、関数はリソースタイプへのポインタを返し、 &lt;code&gt;*tried&lt;/code&gt; は &lt;code&gt;ERL_NIF_RT_CREATE&lt;/code&gt; または &lt;code&gt;ERL_NIF_RT_TAKEOVER&lt;/code&gt; に設定され、何が行われたかを示します。失敗すると &lt;code&gt;NULL&lt;/code&gt; を返し、 &lt;code&gt;*tried&lt;/code&gt; を &lt;code&gt;flags&lt;/code&gt; に設定します。 &lt;code&gt;tried&lt;/code&gt; を &lt;code&gt;NULL&lt;/code&gt; に設定できます。</target>
        </trans-unit>
        <trans-unit id="9fed20a53218971de1395aaff5c9c60036d53fb8" translate="yes" xml:space="preserve">
          <source>On success, the function returns an Erlang pid containing the address of the specified name, and the node is initialized to the node name where &lt;code&gt;name&lt;/code&gt; is found. On failure, &lt;code&gt;NULL&lt;/code&gt; is returned and &lt;code&gt;node&lt;/code&gt; is not modified.</source>
          <target state="translated">成功すると、関数は指定された名前のアドレスを含むErlang pidを返し、ノードは &lt;code&gt;name&lt;/code&gt; が見つかったノード名に初期化されます。失敗すると &lt;code&gt;NULL&lt;/code&gt; が返され、 &lt;code&gt;node&lt;/code&gt; は変更されません。</target>
        </trans-unit>
        <trans-unit id="337efc03ad89d708d3afb77816250b7b6e5ac95d" translate="yes" xml:space="preserve">
          <source>On success, the function returns an array of strings, each containing a single registered name, and sets &lt;code&gt;count&lt;/code&gt; to the number of names found. The array is terminated by a single &lt;code&gt;NULL&lt;/code&gt; pointer. On failure, the function returns &lt;code&gt;NULL&lt;/code&gt; and &lt;code&gt;count&lt;/code&gt; is not modified.</source>
          <target state="translated">成功すると、関数は文字列の配列を返します。各文字列には単一の登録名が含まれており、 &lt;code&gt;count&lt;/code&gt; には見つかった名前の数が設定されます。配列は単一の &lt;code&gt;NULL&lt;/code&gt; ポインターで終了します。失敗すると、関数は &lt;code&gt;NULL&lt;/code&gt; を返し、 &lt;code&gt;count&lt;/code&gt; は変更されません。</target>
        </trans-unit>
        <trans-unit id="b4272e6f5e6ca873a7a08ed89c16a8a80ef49afd" translate="yes" xml:space="preserve">
          <source>On success, the function returns the value associated with &lt;code&gt;key&lt;/code&gt; and indicates its length in &lt;code&gt;size&lt;/code&gt;. If the object is not found or if it is not a binary object, &lt;code&gt;NULL&lt;/code&gt; is returned. To avoid problems with in-band error reporting (that is, if you cannot distinguish between &lt;code&gt;NULL&lt;/code&gt; and a valid result), use the more general function &lt;code&gt;ei_reg_getval()&lt;/code&gt; instead.</source>
          <target state="translated">成功すると、関数は &lt;code&gt;key&lt;/code&gt; に関連付けられた値を返し、その長さを &lt;code&gt;size&lt;/code&gt; で示します。オブジェクトが見つからない場合、またはバイナリオブジェクトでない場合は、 &lt;code&gt;NULL&lt;/code&gt; が返されます。インバンドエラーレポートの問題（つまり、 &lt;code&gt;NULL&lt;/code&gt; と有効な結果を区別できない場合）を回避するには、代わりに、より一般的な関数 &lt;code&gt;ei_reg_getval()&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="05d5be1ae587938fb787490f4e22f1def9a340ce" translate="yes" xml:space="preserve">
          <source>On success, the function returns the value associated with &lt;code&gt;key&lt;/code&gt;. If the object is not found or if it is not a floating point object, &lt;code&gt;-1.0&lt;/code&gt; is returned. To avoid problems with in-band error reporting (that is, if you cannot distinguish between &lt;code&gt;-1.0&lt;/code&gt; and a valid result), use the more general function &lt;code&gt;ei_reg_getval()&lt;/code&gt; instead.</source>
          <target state="translated">成功すると、関数は &lt;code&gt;key&lt;/code&gt; に関連付けられた値を返します。オブジェクトが見つからない場合、または浮動小数点オブジェクトでない場合は、 &lt;code&gt;-1.0&lt;/code&gt; が返されます。インバンドエラーレポートの問題を回避するには（つまり、 &lt;code&gt;-1.0&lt;/code&gt; と有効な結果を区別できない場合）、代わりに、より一般的な関数 &lt;code&gt;ei_reg_getval()&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="b3820a5ea0fe718970e9f3bbe04885da2999ec49" translate="yes" xml:space="preserve">
          <source>On success, the function returns the value associated with &lt;code&gt;key&lt;/code&gt;. If the object is not found or if it is not a string, &lt;code&gt;NULL&lt;/code&gt; is returned. To avoid problems with in-band error reporting (that is, if you cannot distinguish between &lt;code&gt;NULL&lt;/code&gt; and a valid result), use the more general function &lt;code&gt;ei_reg_getval()&lt;/code&gt; instead.</source>
          <target state="translated">成功すると、関数は &lt;code&gt;key&lt;/code&gt; に関連付けられた値を返します。オブジェクトが見つからない場合、または文字列でない場合は、 &lt;code&gt;NULL&lt;/code&gt; が返されます。インバンドエラーレポートの問題（つまり、 &lt;code&gt;NULL&lt;/code&gt; と有効な結果を区別できない場合）を回避するには、代わりに、より一般的な関数 &lt;code&gt;ei_reg_getval()&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="f63666e52d190298b2a061e3c8a1ed17bebbd73f" translate="yes" xml:space="preserve">
          <source>On success, the function returns the value associated with &lt;code&gt;key&lt;/code&gt;. If the object is not found or if it is not an integer object, &lt;code&gt;-1&lt;/code&gt; is returned. To avoid problems with in-band error reporting (that is, if you cannot distinguish between &lt;code&gt;-1&lt;/code&gt; and a valid result), use the more general function &lt;code&gt;ei_reg_getval()&lt;/code&gt; instead.</source>
          <target state="translated">成功すると、関数は &lt;code&gt;key&lt;/code&gt; に関連付けられた値を返します。オブジェクトが見つからない場合、または整数オブジェクトでない場合は、 &lt;code&gt;-1&lt;/code&gt; が返されます。帯域内エラー報告に関する問題（つまり、 &lt;code&gt;-1&lt;/code&gt; と有効な結果を区別できない場合）を回避するには、代わりに、より一般的な関数 &lt;code&gt;ei_reg_getval()&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="1519b2c5db86ccdb596ec05a28c63cbcfef77f9b" translate="yes" xml:space="preserve">
          <source>On success, the functions return &lt;code&gt;ERL_MSG&lt;/code&gt; and the &lt;code&gt;&lt;a href=&quot;#erlang_msg&quot;&gt;msg&lt;/a&gt;&lt;/code&gt; struct is initialized.</source>
          <target state="translated">成功すると、関数は &lt;code&gt;ERL_MSG&lt;/code&gt; を返し、 &lt;code&gt;&lt;a href=&quot;#erlang_msg&quot;&gt;msg&lt;/a&gt;&lt;/code&gt; 構造体が初期化されます。</target>
        </trans-unit>
        <trans-unit id="826f3f3c68edb8d6a8417ffe459589634fbc1144" translate="yes" xml:space="preserve">
          <source>On success, the functions return &lt;code&gt;ERL_MSG&lt;/code&gt; and the &lt;code&gt;msg&lt;/code&gt; struct is initialized. &lt;code&gt;erlang_msg&lt;/code&gt; is defined as follows:</source>
          <target state="translated">成功すると、関数は &lt;code&gt;ERL_MSG&lt;/code&gt; を返し、 &lt;code&gt;msg&lt;/code&gt; 構造体が初期化されます。 &lt;code&gt;erlang_msg&lt;/code&gt; は次のように定義されます。</target>
        </trans-unit>
        <trans-unit id="2e36d3c841193235e57c861682cf6d25481358db" translate="yes" xml:space="preserve">
          <source>On success, the message is placed in the specified buffer and the function returns the number of bytes actually read. On failure, the function returns &lt;code&gt;ERL_ERROR&lt;/code&gt; and sets &lt;code&gt;erl_errno&lt;/code&gt; to one of the following:</source>
          <target state="translated">成功すると、メッセージは指定されたバッファーに入れられ、関数は実際に読み取られたバイト数を返します。失敗した場合は、関数が戻っ &lt;code&gt;ERL_ERROR&lt;/code&gt; とのセットは &lt;code&gt;erl_errno&lt;/code&gt; 、次のいずれかに：</target>
        </trans-unit>
        <trans-unit id="5b25bb3efb4ee6e26cac0f259c10a630574681e4" translate="yes" xml:space="preserve">
          <source>On success, the message is placed in the specified buffer and the function returns the number of bytes actually read. On failure, the function returns a negative value and sets &lt;code&gt;erl_errno&lt;/code&gt; to one of:</source>
          <target state="translated">成功すると、メッセージは指定されたバッファーに入れられ、関数は実際に読み取られたバイト数を返します。失敗すると、関数は負の値を返し、 &lt;code&gt;erl_errno&lt;/code&gt; を次のいずれかに設定します。</target>
        </trans-unit>
        <trans-unit id="772f9d0d6c197237442ca0a6e490f7b7f2ebb396" translate="yes" xml:space="preserve">
          <source>On success, the registry is resized, all contents rehashed, and &lt;code&gt;0&lt;/code&gt; is returned. On failure, the registry is left unchanged and &lt;code&gt;-1&lt;/code&gt; is returned.</source>
          <target state="translated">成功すると、レジストリのサイズが変更され、すべてのコンテンツが再ハッシュされ、 &lt;code&gt;0&lt;/code&gt; が返されます。失敗すると、レジストリは変更されずに残り、 &lt;code&gt;-1&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="b55ff64c65276715f5cf5ac620e52f2b4c69380a" translate="yes" xml:space="preserve">
          <source>On systems that support OS signals, it is also possible to stop the runtime system and generate a crash dump by sending the &lt;code&gt;SIGUSR1&lt;/code&gt; signal.</source>
          <target state="translated">OSシグナルをサポートするシステムでは、 &lt;code&gt;SIGUSR1&lt;/code&gt; シグナルを送信して、ランタイムシステムを停止し、クラッシュダンプを生成することもできます。</target>
        </trans-unit>
        <trans-unit id="8295dab59d105fcadee920c83d7a0087818d1ff8" translate="yes" xml:space="preserve">
          <source>On tab &lt;strong&gt;Internal Tables&lt;/strong&gt; you can from the left-hand menu select &lt;strong&gt;Hash Tables&lt;/strong&gt;, &lt;strong&gt;Index Tables&lt;/strong&gt;, or &lt;strong&gt;Internal ETS Tables&lt;/strong&gt;.</source>
          <target state="translated">タブで&lt;strong&gt;内部テーブルの&lt;/strong&gt;選択左側のメニューから、次のことができ&lt;strong&gt;ハッシュテーブル&lt;/strong&gt;、&lt;strong&gt;インデックステーブル&lt;/strong&gt;、または&lt;strong&gt;内部ETSテーブル&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="c2fcf0646802d9dc8e8b2dc7ce9d29177a614ac1" translate="yes" xml:space="preserve">
          <source>On the &lt;code&gt;Code&lt;/code&gt; page the Erlang source code is displayed. It is possible to search forwards and backwards for text in the module. Enter a regular expression in the &lt;code&gt;Find&lt;/code&gt; field and press enter. It is also possible to go to a certain line in the module. The &lt;code&gt;Back&lt;/code&gt; button can be used to go back to the previous position.</source>
          <target state="translated">[ &lt;code&gt;Code&lt;/code&gt; ページに、Erlangソースコードが表示されます。モジュール内のテキストを前方および後方に検索できます。[ &lt;code&gt;Find&lt;/code&gt; フィールドに正規表現を入力して、Enterキーを押します。モジュールの特定の行に移動することもできます。 &lt;code&gt;Back&lt;/code&gt; ボタンは、前の位置に戻るために使用することができます。</target>
        </trans-unit>
        <trans-unit id="6f72d7009505c0a635de5a33f1a164f62ac37178" translate="yes" xml:space="preserve">
          <source>On the &lt;code&gt;erl&lt;/code&gt; command line you can specify options that the SSL/TLS distribution adds when creating a socket.</source>
          <target state="translated">上の &lt;code&gt;erl&lt;/code&gt; コマンドラインあなたは、ソケットを作成するときにSSL / TLSの分布が追加するオプションを指定することができます。</target>
        </trans-unit>
        <trans-unit id="6a9c767404e4bacdf3f831aff6d5d541c2d1a85f" translate="yes" xml:space="preserve">
          <source>On the &lt;code&gt;erl&lt;/code&gt; command line you can specify options that the TLS distribution adds when creating a socket.</source>
          <target state="translated">上の &lt;code&gt;erl&lt;/code&gt; コマンドラインあなたは、ソケットを作成するときにTLSの分布は、追加オプションを指定することができます。</target>
        </trans-unit>
        <trans-unit id="58dd19bfb0b41f363c09999a6e4ad4b9c8bdfec9" translate="yes" xml:space="preserve">
          <source>On the C side, it is necessary to write functions for receiving and sending data with 2 byte length indicators from/to Erlang. By default, the C program is to read from standard input (file descriptor 0) and write to standard output (file descriptor 1). Examples of such functions, &lt;code&gt;read_cmd/1&lt;/code&gt; and &lt;code&gt;write_cmd/2&lt;/code&gt;, follows:</source>
          <target state="translated">C側では、Erlangとの間で2バイト長のインジケーターを使用してデータを送受信するための関数を作成する必要があります。デフォルトでは、Cプログラムは標準入力（ファイル記述子0）から読み取り、標準出力（ファイル記述子1）に書き込みます。そのような関数の例である &lt;code&gt;read_cmd/1&lt;/code&gt; および &lt;code&gt;write_cmd/2&lt;/code&gt; は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="b1adca5c0bfea4b4b3f2870a27e174b7d50075f9" translate="yes" xml:space="preserve">
          <source>On the client side the ssl application will save session data to try to automate session reuse on behalf of the client processes on the Erlang node. Note that only verified sessions will be saved for security reasons, that is session resumption relies on the certificate validation to have been run in the original handshake. To minimize memory consumption only unique sessions will be saved unless the special &lt;code&gt;save&lt;/code&gt; value is specified for the following option &lt;code&gt;{reuse_sessions, boolean() | save}&lt;/code&gt; in which case a full handhake will be performed and that specific session will have been saved before the handshake returns. The session id and even an opaque binary containing the session data can be retrieved using &lt;code&gt;ssl:connection_information/1&lt;/code&gt; function. A saved session (guaranteed by the save option) can be explicitly reused using &lt;code&gt;{reuse_session, SessionId}&lt;/code&gt;. Also it is possible for the client to reuse a session that is not saved by the ssl application using &lt;code&gt;{reuse_session, {SessionId, SessionData}}&lt;/code&gt;.</source>
          <target state="translated">クライアント側では、SSLアプリケーションがセッションデータを保存して、Erlangノードのクライアントプロセスに代わってセッションの再利用を自動化しようとします。セキュリティ上の理由から、検証済みのセッションのみが保存されることに注意してください。つまり、セッションの再開は、元のハンドシェイクで実行された証明書の検証に依存します。メモリ消費を最小限に抑えるために、次のオプションに特別な &lt;code&gt;save&lt;/code&gt; 値が指定されていない限り、一意のセッションのみが保存されます &lt;code&gt;{reuse_sessions, boolean() | save}&lt;/code&gt; 、その場合には、完全なhandhakeが実行され、その特定のセッションは、ハンドシェークが戻る前に保存されています。セッションIDと、セッションデータを含む不透明なバイナリでさえ、 &lt;code&gt;ssl:connection_information/1&lt;/code&gt; を使用して取得できます。関数。保存されたセッション（保存オプションによって保証されます）は &lt;code&gt;{reuse_session, SessionId}&lt;/code&gt; を使用して明示的に再利用できます。また、クライアントは &lt;code&gt;{reuse_session, {SessionId, SessionData}}&lt;/code&gt; を使用して、SSLアプリケーションによって保存されていないセッションを再利用することができます。</target>
        </trans-unit>
        <trans-unit id="b62b54f6f16d351431e8df23105f4a3d3614069f" translate="yes" xml:space="preserve">
          <source>On the client side, function &lt;code&gt;&lt;a href=&quot;tftp#read_file-3&quot;&gt;read_file/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;tftp#write_file-3&quot;&gt;write_file/3&lt;/a&gt;&lt;/code&gt; spawn a temporary client process establishing contact with a TFTP daemon and perform the file transfer.</source>
          <target state="translated">クライアント側では、関数 &lt;code&gt;&lt;a href=&quot;tftp#read_file-3&quot;&gt;read_file/3&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;tftp#write_file-3&quot;&gt;write_file/3&lt;/a&gt;&lt;/code&gt; が、TFTPデーモンとの接続を確立する一時的なクライアントプロセスを生成し、ファイル転送を実行します。</target>
        </trans-unit>
        <trans-unit id="de8d284e24c9173448479649ca3673e3b9453805" translate="yes" xml:space="preserve">
          <source>On the client side, the callback interaction is the same, but it starts and ends a bit differently. It starts with a call to &lt;code&gt;prepare/5&lt;/code&gt; with the same arguments as &lt;code&gt;open/5&lt;/code&gt; takes. &lt;code&gt;prepare/5&lt;/code&gt; is expected to validate the TFTP options suggested by the user and to return the subset of them that it accepts. Then the options are sent to the server, which performs the same TFTP option negotiation procedure. The options that are accepted by the server are forwarded to function &lt;code&gt;open/5&lt;/code&gt; on the client side. On the client side, function &lt;code&gt;open/5&lt;/code&gt; must accept all option as-is or reject the transfer. Then the callback interaction follows the same pattern as described for the server side. When the last block is encountered in &lt;code&gt;read/1&lt;/code&gt; or &lt;code&gt;write/2&lt;/code&gt;, the returned state is forwarded to the user and returned from &lt;code&gt;read_file&lt;/code&gt;/3 or &lt;code&gt;write_file/3&lt;/code&gt;.</source>
          <target state="translated">クライアント側では、コールバックの相互作用は同じですが、開始と終了が少し異なります。まず、 &lt;code&gt;open/5&lt;/code&gt; と同じ引数で &lt;code&gt;prepare/5&lt;/code&gt; を呼び出します。 &lt;code&gt;prepare/5&lt;/code&gt; は、ユーザーが提案したTFTPオプションを検証し、受け入れたオプションのサブセットを返すことが期待されています。次に、オプションがサーバーに送信され、サーバーは同じTFTPオプションネゴシエーション手順を実行します。サーバーによって受け入れられたオプションは、クライアント側の &lt;code&gt;open/5&lt;/code&gt; 機能に転送されます。クライアント側では、関数 &lt;code&gt;open/5&lt;/code&gt; はすべてのオプションをそのまま受け入れるか、転送を拒否する必要があります。その後、コールバックの相互作用は、サーバー側で説明したのと同じパターンに従います。最後のブロックに遭遇したとき &lt;code&gt;read/1&lt;/code&gt; または &lt;code&gt;write/2&lt;/code&gt; の場合、返された状態はユーザーに転送され、 &lt;code&gt;read_file&lt;/code&gt; / 3または &lt;code&gt;write_file/3&lt;/code&gt; から返されます。</target>
        </trans-unit>
        <trans-unit id="5fb24826c266fe2b7d30c2585ff68e6ee2e2233f" translate="yes" xml:space="preserve">
          <source>On the client side, where the &lt;code&gt;open/5&lt;/code&gt; call has been preceded by a call to &lt;code&gt;prepare/5&lt;/code&gt;, all options must be accepted or rejected.</source>
          <target state="translated">クライアント側では、 &lt;code&gt;open/5&lt;/code&gt; 呼び出しの前に &lt;code&gt;prepare/5&lt;/code&gt; への呼び出しが行われているため、すべてのオプションを受け入れるか拒否する必要があります。</target>
        </trans-unit>
        <trans-unit id="30bc1d9225132fab91da41cb1dc8196b10d81a6f" translate="yes" xml:space="preserve">
          <source>On the destination side the transport service waits for messages. Each message is forwarded to the Megaco application via the megaco:receive_message/4 callback function. The transport service may or may not provide means for blocking and unblocking the reception of the incoming messages.</source>
          <target state="translated">宛先側では、トランスポートサービスはメッセージを待ちます。各メッセージは、megaco:receive_message/4コールバック関数を介してMegacoアプリケーションに転送されます。トランスポートサービスは、着信メッセージの受信をブロックしたり、ブロックを解除したりする手段を提供してもよいし、提供しなくてもよい。</target>
        </trans-unit>
        <trans-unit id="8a6a0caacfe77936a01171aa4a2af7bcafb1d066" translate="yes" xml:space="preserve">
          <source>On the heap tuples require a word size for each of its elements as well as for the header. Cons cells always require two words. Adding these things together, we get seven words for the tuples and 26 words for the cons cells. The string &lt;code&gt;&quot;hello world!&quot;&lt;/code&gt; is a list of cons cells and thus requires 24 words. The atom &lt;code&gt;tag&lt;/code&gt; and the integer &lt;code&gt;42&lt;/code&gt; do not require any additional heap memory since it is an &lt;strong&gt;immediate&lt;/strong&gt;. Adding all the terms together, the heap space required in this example should be 33 words.</source>
          <target state="translated">ヒープタプルでは、​​各要素とヘッダーにワードサイズが必要です。短所セルには常に2つの単語が必要です。これらを合計すると、タプルの場合は7ワード、コンスセルの場合は26ワードになります。文字列 &lt;code&gt;&quot;hello world!&quot;&lt;/code&gt; は短所セルのリストであるため、24語が必要です。原子 &lt;code&gt;tag&lt;/code&gt; と整数 &lt;code&gt;42&lt;/code&gt; は、それがあるので、任意の追加のヒープ・メモリを必要としない&lt;strong&gt;即時&lt;/strong&gt;。すべての用語を合計すると、この例で必要なヒープスペースは33ワードになります。</target>
        </trans-unit>
        <trans-unit id="8d08ce8dca231cb0c413cc427e0f7b3615dc40e4" translate="yes" xml:space="preserve">
          <source>On the library page it is possible to control which sources the tool will use. The page is organized as a tree which can be expanded and collapsed by clicking on the little symbol in the beginning of the expandable/collapsible lines.</source>
          <target state="translated">ライブラリページでは、ツールが使用するソースを制御することができます。ページはツリーとして構成されており、展開・折りたたみ可能な行の先頭にある小さなシンボルをクリックすることで、展開・折りたたみが可能です。</target>
        </trans-unit>
        <trans-unit id="359fa7aa2c051b4488b5e4f004a78d6117f975d2" translate="yes" xml:space="preserve">
          <source>On the node &lt;code&gt;a@gin&lt;/code&gt;:</source>
          <target state="translated">ノード &lt;code&gt;a@gin&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="4dcf5e92ec7cf6d33837ea0dba4f2cf9a86307f9" translate="yes" xml:space="preserve">
          <source>On the node &lt;code&gt;b@skeppet&lt;/code&gt;:</source>
          <target state="translated">ノード &lt;code&gt;b@skeppet&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="504dd890d20c855491af2a80a9207cca701308e3" translate="yes" xml:space="preserve">
          <source>On the node &lt;code&gt;stack&lt;/code&gt; there's an Erlang node &lt;code&gt;ant@stack&lt;/code&gt;, in the shell, type the following:</source>
          <target state="translated">ノード &lt;code&gt;stack&lt;/code&gt; にはErlangノード &lt;code&gt;ant@stack&lt;/code&gt; があり、シェルで次のように入力します。</target>
        </trans-unit>
        <trans-unit id="72075800ddf3add147be6be68bd87c4adad1f4d0" translate="yes" xml:space="preserve">
          <source>On the node where the application is started, there is a transaction coordinator process. If the transaction is distributed, there is also a transaction participant process on all the other nodes where commit-work needs to be performed.</source>
          <target state="translated">アプリケーションが起動されたノードには、トランザクションコーディネータプロセスがあります。トランザクションが分散されている場合、コミット作業を実行する必要がある他のすべてのノードにもトランザクション参加者プロセスが存在します。</target>
        </trans-unit>
        <trans-unit id="30fba55f8fe9ca566a03374554f0601d38f82b56" translate="yes" xml:space="preserve">
          <source>On the other hand it worth mentioning that at least all cipher suites that would rely on non-validated algorithms are automatically disabled in FIPS mode.</source>
          <target state="translated">一方で、少なくとも非検証アルゴリズムに依存するすべての暗号スイートは、FIPS モードでは自動的に無効化されていることは言及する価値があります。</target>
        </trans-unit>
        <trans-unit id="3d6f6cddc5dd538a25571ab6dae15764b54f7d33" translate="yes" xml:space="preserve">
          <source>On the other hand,</source>
          <target state="translated">その一方で</target>
        </trans-unit>
        <trans-unit id="048ff061e68af3024276eb158992cafe58ebd7ac" translate="yes" xml:space="preserve">
          <source>On the other hand, &lt;code&gt;move c d&lt;/code&gt; is a single instruction. At runtime, the &lt;code&gt;d&lt;/code&gt; operand will be tested to see whether it refers to an X register or a Y register, and a pointer to the register will be set up.</source>
          <target state="translated">一方、 &lt;code&gt;move c d&lt;/code&gt; は単一の命令です。実行時に、 &lt;code&gt;d&lt;/code&gt; オペランドがテストされ、XレジスタまたはYレジスタのどちらを参照しているかが確認され、レジスタへのポインタが設定されます。</target>
        </trans-unit>
        <trans-unit id="79d5245ba64d69949e15fc6366d11aa934acec96" translate="yes" xml:space="preserve">
          <source>On the receiving side the transport module receives the message and forwards it to the protocol engine, which decodes it and invokes user callback functions for each transaction. When a user has handled its action requests, it simply returns a list of action replies (or a message error) and the protocol engine uses the encoding module and transport module to compose and forward the message to the originating user.</source>
          <target state="translated">受信側では、トランスポートモジュールがメッセージを受信してプロトコルエンジンに転送し、プロトコルエンジンはそれをデコードして、各トランザクションのためにユーザーコールバック関数を呼び出す。ユーザーがアクションリクエストを処理した場合、アクション応答のリスト(またはメッセージエラー)を返し、プロトコルエンジンはエンコーディングモジュールとトランスポートモジュールを使用してメッセージを構成し、発信元のユーザーに転送します。</target>
        </trans-unit>
        <trans-unit id="823b2c02cd0160bf197b81f01b9301ddf6d5a739" translate="yes" xml:space="preserve">
          <source>On the server side the the &lt;code&gt;{reuse_sessions, boolean()}&lt;/code&gt; option determines if the server will save session data and allow session reuse or not. This can be further customized by the option &lt;code&gt;{reuse_session, fun()}&lt;/code&gt; that may introduce a local policy for session reuse.</source>
          <target state="translated">サーバー側では、 &lt;code&gt;{reuse_sessions, boolean()}&lt;/code&gt; オプションは、サーバーがセッションデータを保存し、セッションの再利用を許可するかどうかを決定します。これは、セッションの再利用のためのローカルポリシーを導入する可能性のあるオプション &lt;code&gt;{reuse_session, fun()}&lt;/code&gt; によってさらにカスタマイズできます。</target>
        </trans-unit>
        <trans-unit id="eb2efe7a16721a2ea4eaaca280d15198cd82819c" translate="yes" xml:space="preserve">
          <source>On the server side, the callback interaction starts with a call to &lt;code&gt;open/5&lt;/code&gt; with the registered initial callback state. &lt;code&gt;open/5&lt;/code&gt; is expected to open the (virtual) file. Then either function &lt;code&gt;read/1&lt;/code&gt; or &lt;code&gt;write/2&lt;/code&gt; is invoked repeatedly, once per transferred block. At each function call, the state returned from the previous call is obtained. When the last block is encountered, function &lt;code&gt;read/1&lt;/code&gt; or &lt;code&gt;write/2&lt;/code&gt; is expected to close the (virtual) file and return its last state. Function &lt;code&gt;abort/3&lt;/code&gt; is only used in error situations. Function &lt;code&gt;prepare/5&lt;/code&gt; is not used on the server side.</source>
          <target state="translated">サーバー側では、コールバックの対話は、登録された初期コールバック状態での &lt;code&gt;open/5&lt;/code&gt; の呼び出しから始まります。 &lt;code&gt;open/5&lt;/code&gt; は（仮想）ファイルを開くことが期待されています。次に、関数 &lt;code&gt;read/1&lt;/code&gt; または &lt;code&gt;write/2&lt;/code&gt; が、転送されたブロックごとに1回繰り返し呼び出されます。各関数呼び出しでは、前の呼び出しから返された状態が取得されます。最後のブロックが検出されると、関数 &lt;code&gt;read/1&lt;/code&gt; または &lt;code&gt;write/2&lt;/code&gt; が（仮想）ファイルを閉じ、最後の状態を返すことが期待されます。関数 &lt;code&gt;abort/3&lt;/code&gt; はエラー状況でのみ使用されます。関数 &lt;code&gt;prepare/5&lt;/code&gt; はサーバー側では使用されません。</target>
        </trans-unit>
        <trans-unit id="7f688e5da429c0dc3dd18d9eb9bf400ae2b1e54a" translate="yes" xml:space="preserve">
          <source>On the server side, where there is no preceding &lt;code&gt;prepare/5&lt;/code&gt; call, no new options can be added, but those present in &lt;code&gt;SuggestedOptions&lt;/code&gt; can be omitted or replaced with new values in &lt;code&gt;AcceptedOptions&lt;/code&gt;.</source>
          <target state="translated">サーバー側では、前の &lt;code&gt;prepare/5&lt;/code&gt; 呼び出しがないため、新しいオプションを追加することはできませんが、 &lt;code&gt;SuggestedOptions&lt;/code&gt; にあるオプションを省略したり、 &lt;code&gt;AcceptedOptions&lt;/code&gt; の新しい値で置き換えたりすることができます。</target>
        </trans-unit>
        <trans-unit id="7d544406993542a47ac30874abf36e8f76938251" translate="yes" xml:space="preserve">
          <source>On the system settings page it is possible to control some global settings that are used as defaults for all applications. Set the &lt;code&gt;Application inclusion policy&lt;/code&gt; to &lt;code&gt;include&lt;/code&gt; to include all applications that are not explicitly excluded. See &lt;code&gt;incl_cond&lt;/code&gt; (application inclusion) and &lt;code&gt;mod_cond&lt;/code&gt; (module inclusion) in the reference manual for the module &lt;code&gt;reltool&lt;/code&gt; for more info.</source>
          <target state="translated">システム設定ページでは、すべてのアプリケーションのデフォルトとして使用されるいくつかのグローバル設定を制御できます。明示的に除外されていないすべてのアプリケーションを &lt;code&gt;include&lt;/code&gt; には、 &lt;code&gt;Application inclusion policy&lt;/code&gt; を設定します。参照 &lt;code&gt;incl_cond&lt;/code&gt; （アプリケーション包含）と &lt;code&gt;mod_cond&lt;/code&gt; モジュールのリファレンスマニュアルで（モジュール包含） &lt;code&gt;reltool&lt;/code&gt; 詳細は。</target>
        </trans-unit>
        <trans-unit id="200db783be88f8550d4a8913f57876ec9c489e2e" translate="yes" xml:space="preserve">
          <source>On the third line (or second line depending on the presence of the Emacs directive), arguments can be specified to the emulator, for example:</source>
          <target state="translated">3行目(Emacsディレクティブの存在によっては2行目)では、例えばエミュレータに引数を指定することができます。</target>
        </trans-unit>
        <trans-unit id="919203571b510b75243e5425885ce5fd82bf64cd" translate="yes" xml:space="preserve">
          <source>On time-out, the test run is aborted when the current test job is finished. If &lt;code&gt;skip_rest&lt;/code&gt; is provided, the remaining test cases in the current test job are skipped (described later).</source>
          <target state="translated">タイムアウトになると、現在のテストジョブが終了すると、テストの実行が中止されます。場合 &lt;code&gt;skip_rest&lt;/code&gt; が設けられている、現在のテストジョブの残りのテストケースがスキップされ（後述）。</target>
        </trans-unit>
        <trans-unit id="94d0fdbeb40f8b7248647cabbfc52c99b7c568d4" translate="yes" xml:space="preserve">
          <source>On unix you can view the manual pages in emacs. In order to find the manual pages, the variable `erlang-root-dir' should be bound to the name of the directory containing the Erlang installation. The name should not include the final slash. Practically, you should add a line on the following form to your ~/.emacs,</source>
          <target state="translated">Unixではemacsでマニュアルページを見ることができます。マニュアルページを見つけるためには、変数 `erlang-root-dir' をErlangのインストール先のディレクトリ名にバインドしなければなりません。この名前には最後のスラッシュを含めてはいけません。実際には、次のようなフォームの行を ~/.emacs に追加してください。</target>
        </trans-unit>
        <trans-unit id="f23caa93086babb9143d00576ee2b68575ed59f9" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;demonitor(MonitorRef)&lt;/code&gt; has returned, it is guaranteed that no &lt;code&gt;{'DOWN', MonitorRef, _, _, _}&lt;/code&gt; message, because of the monitor, will be placed in the caller message queue in the future. However, a &lt;code&gt;{'DOWN', MonitorRef, _, _, _}&lt;/code&gt; message can have been placed in the caller message queue before the call. It is therefore usually advisable to remove such a &lt;code&gt;'DOWN'&lt;/code&gt; message from the message queue after monitoring has been stopped. &lt;code&gt;&lt;a href=&quot;#demonitor-2&quot;&gt; demonitor(MonitorRef, [flush])&lt;/a&gt;&lt;/code&gt; can be used instead of &lt;code&gt;demonitor(MonitorRef)&lt;/code&gt; if this cleanup is wanted.</source>
          <target state="translated">一旦 &lt;code&gt;demonitor(MonitorRef)&lt;/code&gt; が復帰したことがないことが保証され、 &lt;code&gt;{'DOWN', MonitorRef, _, _, _}&lt;/code&gt; メッセージ、なぜならモニタ、将来的に発信者のメッセージキューに配置されます。ただし、 &lt;code&gt;{'DOWN', MonitorRef, _, _, _}&lt;/code&gt; メッセージは、呼び出しの前に呼び出し元のメッセージキューに配置されている可能性があります。したがって、通常、監視を停止した後、このような &lt;code&gt;'DOWN'&lt;/code&gt; メッセージをメッセージキューから削除することをお勧めします。このクリーンアップが必要な場合は、 &lt;code&gt;demonitor(MonitorRef)&lt;/code&gt; の代わりに &lt;code&gt;&lt;a href=&quot;#demonitor-2&quot;&gt; demonitor(MonitorRef, [flush])&lt;/a&gt;&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="730b25cb05ff67e83ca2df0e26ea964cf618b32a" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;demonitor(MonitorRef)&lt;/code&gt; has returned, it is guaranteed that no &lt;code&gt;{'DOWN', MonitorRef, _, _, _}&lt;/code&gt; message, because of the monitor, will be placed in the caller message queue in the future. However, a &lt;code&gt;{'DOWN', MonitorRef, _, _, _}&lt;/code&gt; message can have been placed in the caller message queue before the call. It is therefore usually advisable to remove such a &lt;code&gt;'DOWN'&lt;/code&gt; message from the message queue after monitoring has been stopped. &lt;code&gt;&lt;a href=&quot;#demonitor-2&quot;&gt;demonitor(MonitorRef, [flush])&lt;/a&gt;&lt;/code&gt; can be used instead of &lt;code&gt;demonitor(MonitorRef)&lt;/code&gt; if this cleanup is wanted.</source>
          <target state="translated">一旦 &lt;code&gt;demonitor(MonitorRef)&lt;/code&gt; が復帰したことがないことが保証され、 &lt;code&gt;{'DOWN', MonitorRef, _, _, _}&lt;/code&gt; メッセージ、なぜならモニタ、将来的に発信者のメッセージキューに配置されます。ただし、 &lt;code&gt;{'DOWN', MonitorRef, _, _, _}&lt;/code&gt; メッセージは、呼び出しの前に呼び出し元のメッセージキューに入れることができます。したがって、通常は、監視が停止した後に、このような &lt;code&gt;'DOWN'&lt;/code&gt; メッセージをメッセージキューから削除することをお勧めします。このクリーンアップが必要な場合は、 &lt;code&gt;demonitor(MonitorRef)&lt;/code&gt; の代わりに &lt;code&gt;&lt;a href=&quot;#demonitor-2&quot;&gt;demonitor(MonitorRef, [flush])&lt;/a&gt;&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="8eb33ed8277cd53945b8bd1336967ae012eaa432" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;unlink(Id)&lt;/code&gt; has returned, it is guaranteed that the link between the caller and the entity referred to by &lt;code&gt;Id&lt;/code&gt; has no effect on the caller in the future (unless the link is setup again). If the caller is trapping exits, an &lt;code&gt;{'EXIT', Id, _}&lt;/code&gt; message from the link can have been placed in the caller's message queue before the call.</source>
          <target state="translated">いったん &lt;code&gt;unlink(Id)&lt;/code&gt; 戻ってきた、呼び出し元と、エンティティによって参照されるとの間のリンクが保証されて &lt;code&gt;Id&lt;/code&gt; は（リンクが再び設定されていない限り）将来的には、発信者には影響を与えません。呼び出し元が出口をトラップしている場合、リンクからの &lt;code&gt;{'EXIT', Id, _}&lt;/code&gt; メッセージが呼び出しの前に呼び出し元のメッセージキューに置かれている可能性があります。</target>
        </trans-unit>
        <trans-unit id="c2da2fd243f88b2358a1e72df5b1691b330413f0" translate="yes" xml:space="preserve">
          <source>Once a port data lock has been created, it must be locked during all operations on the driver queue of the &lt;code&gt;port&lt;/code&gt;.</source>
          <target state="translated">ポートデータロックを作成したら、ポートのドライバーキューでのすべての操作中にロックする必要があり &lt;code&gt;port&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="472161e0880a728a8d14ba236e81c941cac5bdc2" translate="yes" xml:space="preserve">
          <source>Once loaded, a NIF library is persistent. It will not be unloaded until the module code version that it belongs to is purged.</source>
          <target state="translated">一度ロードされると、NIF ライブラリは永続的に存在します。それが属するモジュールコードのバージョンがパージされるまでアンロードされることはありません。</target>
        </trans-unit>
        <trans-unit id="6ae5090c73eef20a1901a4262fb628566dc03086" translate="yes" xml:space="preserve">
          <source>Once read, this file produces the same configuration variables as the following text file:</source>
          <target state="translated">読み込まれると、このファイルは以下のテキストファイルと同じ設定変数を生成します。</target>
        </trans-unit>
        <trans-unit id="2874f79a41ab6a4167b9cad282ba54a8323fe29c" translate="yes" xml:space="preserve">
          <source>Once the CTH is installed into a certain test run it remains there until its scope is expired. The scope of a CTH depends on when it is installed, see the following table. Function &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:init-2&quot;&gt;init/2&lt;/a&gt;&lt;/code&gt; is called at the beginning of the scope and function &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:terminate-1&quot;&gt;terminate/1&lt;/a&gt;&lt;/code&gt; is called when the scope ends.</source>
          <target state="translated">CTHが特定のテスト実行にインストールされると、そのスコープが期限切れになるまでCTHが残ります。CTHの範囲は、いつインストールされるかによって異なります。次の表を参照してください。関数 &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:init-2&quot;&gt;init/2&lt;/a&gt;&lt;/code&gt; はスコープの最初に呼び出され、関数 &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:terminate-1&quot;&gt;terminate/1&lt;/a&gt;&lt;/code&gt; はスコープの終了時に呼び出されます。</target>
        </trans-unit>
        <trans-unit id="f3e0d89fa4414f90c8258d08a4cc02467fbf1279" translate="yes" xml:space="preserve">
          <source>Once the appropriate modules are interpreted, breakpoints can be set at relevant locations in the source code. Breakpoints are specified on a line basis. When a process reaches a breakpoint, it stops and waits for commands (&lt;strong&gt;Step&lt;/strong&gt;, &lt;strong&gt;Skip&lt;/strong&gt;, &lt;strong&gt;Continue&lt;/strong&gt; ...) from the user.</source>
          <target state="translated">適切なモジュールが解釈されると、ブレークポイントをソースコードの関連する場所に設定できます。ブレークポイントは行ごとに指定されます。プロセスがブレークポイントに到達すると、プロセスは停止し、ユーザーからのコマンド（&lt;strong&gt;ステップ&lt;/strong&gt;、&lt;strong&gt;スキップ&lt;/strong&gt;、&lt;strong&gt;続行&lt;/strong&gt; ...）を待ちます。</target>
        </trans-unit>
        <trans-unit id="706354aec2cc6d6f0642591cdb86cf2c478e223c" translate="yes" xml:space="preserve">
          <source>Once the data is collected to the server it can be filtered, sorted and printed in many different ways.</source>
          <target state="translated">データがサーバーに収集されると、様々な方法でフィルタリング、ソート、印刷することができます。</target>
        </trans-unit>
        <trans-unit id="55fa9be76565d3bf8388ee77c4576ca0c50c0cab" translate="yes" xml:space="preserve">
          <source>Once the port data lock has been created, every access to data associated with the port data lock must be done while the port data lock is locked. The port data lock is locked and unlocked by &lt;code&gt;&lt;a href=&quot;#driver_pdl_lock&quot;&gt; driver_pdl_lock&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#driver_pdl_unlock&quot;&gt; driver_pdl_unlock&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="translated">ポートデータロックが作成されると、ポートデータロックに関連付けられたデータへのすべてのアクセスは、ポートデータロックがロックされている間に実行する必要があります。ポートデータロックは、 &lt;code&gt;&lt;a href=&quot;#driver_pdl_lock&quot;&gt; driver_pdl_lock&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;#driver_pdl_unlock&quot;&gt; driver_pdl_unlock&lt;/a&gt;&lt;/code&gt; によってそれぞれロックおよびロック解除されます。</target>
        </trans-unit>
        <trans-unit id="ac354611c2ceba110708f663296284723c689ebb" translate="yes" xml:space="preserve">
          <source>Once the port data lock has been created, every access to data associated with the port data lock must be done while the port data lock is locked. The port data lock is locked and unlocked by &lt;code&gt;&lt;a href=&quot;#driver_pdl_lock&quot;&gt;driver_pdl_lock&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#driver_pdl_unlock&quot;&gt;driver_pdl_unlock&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="translated">ポートデータロックが作成されたら、ポートデータロックがロックされている間、ポートデータロックに関連付けられているデータへのすべてのアクセスを実行する必要があります。ポートデータロックがでロックされ、ロックが解除され &lt;code&gt;&lt;a href=&quot;#driver_pdl_lock&quot;&gt;driver_pdl_lock&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;#driver_pdl_unlock&quot;&gt;driver_pdl_unlock&lt;/a&gt;&lt;/code&gt; それぞれ。</target>
        </trans-unit>
        <trans-unit id="d4566776ad00ac441fb67a63e43838839e8da21d" translate="yes" xml:space="preserve">
          <source>Once the system is built, you might want to change it. Having a test release in some nice directory might be useful, but you can also run Erlang from within the source tree. The target &lt;code&gt;local_setup&lt;/code&gt;, makes the program &lt;code&gt;$ERL_TOP/bin/erl.exe&lt;/code&gt; usable and it also uses all the OTP libraries in the source tree.</source>
          <target state="translated">システムが構築されたら、それを変更することができます。素敵なディレクトリにテストリリースがあると便利かもしれませんが、ソースツリー内からErlangを実行することもできます。ターゲットの &lt;code&gt;local_setup&lt;/code&gt; は、プログラム &lt;code&gt;$ERL_TOP/bin/erl.exe&lt;/code&gt; 使用可能にし、ソースツリー内のすべてのOTPライブラリも使用します。</target>
        </trans-unit>
        <trans-unit id="ad8f7b7317e234e5165d7fda5e02abbb7d93475a" translate="yes" xml:space="preserve">
          <source>Once you have a lock counting enabled VM the module &lt;code&gt;lcnt&lt;/code&gt; can be used. The module is intended to be used from the current running nodes shell. To access remote nodes use &lt;code&gt;lcnt:clear(Node)&lt;/code&gt; and &lt;code&gt;lcnt:collect(Node)&lt;/code&gt;.</source>
          <target state="translated">ロックカウントが有効なVMを &lt;code&gt;lcnt&lt;/code&gt; 、モジュールlcntを使用できます。このモジュールは、現在実行中のノードシェルから使用するためのものです。リモートノードにアクセスするには、 &lt;code&gt;lcnt:clear(Node)&lt;/code&gt; および &lt;code&gt;lcnt:collect(Node)&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="fe6fa81042f05838c7c931d240a87fc23ec1e33e" translate="yes" xml:space="preserve">
          <source>Once you have chosen the modules or directories you want to analyze, click the &lt;strong&gt;Run&lt;/strong&gt; button to start the analysis. If you for some reason want to stop the analysis while it is running, click the &lt;strong&gt;Stop&lt;/strong&gt; button.</source>
          <target state="translated">分析するモジュールまたはディレクトリを選択したら、[ &lt;strong&gt;実行&lt;/strong&gt; ]ボタンをクリックして分析を開始します。何らかの理由で実行中に分析を停止したい場合は、[ &lt;strong&gt;停止&lt;/strong&gt; ]ボタンをクリックします。</target>
        </trans-unit>
        <trans-unit id="f1866013abe7a3a8a91c1626525b2105bdb78c26" translate="yes" xml:space="preserve">
          <source>One MIB can communicate with many applications.</source>
          <target state="translated">1つのMIBは、多くのアプリケーションと通信することができます。</target>
        </trans-unit>
        <trans-unit id="ae6ac6f5e1f4c553d516e35fd92ef8609ef86d4a" translate="yes" xml:space="preserve">
          <source>One can get an approximation of the &lt;code&gt;native&lt;/code&gt; time unit by calling &lt;code&gt;&lt;a href=&quot;#convert_time_unit-3&quot;&gt; erlang:convert_time_unit(1, second, native)&lt;/a&gt;&lt;/code&gt;. The result equals the number of whole &lt;code&gt;native&lt;/code&gt; time units per second. If the number of &lt;code&gt;native&lt;/code&gt; time units per second does not add up to a whole number, the result is rounded downwards.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#convert_time_unit-3&quot;&gt; erlang:convert_time_unit(1, second, native)&lt;/a&gt;&lt;/code&gt; 呼び出すことにより、 &lt;code&gt;native&lt;/code&gt; 時間単位の概算を取得できます。結果は、1秒あたりの &lt;code&gt;native&lt;/code&gt; 時間単位全体の数に等しくなります。1秒あたりの &lt;code&gt;native&lt;/code&gt; 時間単位の数が整数にならない場合、結果は切り捨てられます。</target>
        </trans-unit>
        <trans-unit id="7314739d088633c38ec313d94ecdc0d77f14a5ba" translate="yes" xml:space="preserve">
          <source>One can get an approximation of the &lt;code&gt;native&lt;/code&gt; time unit by calling &lt;code&gt;erlang:convert_time_unit(1, second, native)&lt;/code&gt;. The result equals the number of whole &lt;code&gt;native&lt;/code&gt; time units per second. If the number of &lt;code&gt;native&lt;/code&gt; time units per second does not add up to a whole number, the result is rounded downwards.</source>
          <target state="translated">&lt;code&gt;erlang:convert_time_unit(1, second, native)&lt;/code&gt; 呼び出すことにより、 &lt;code&gt;native&lt;/code&gt; 時間単位の概算を取得できます。結果は、1秒あたりの &lt;code&gt;native&lt;/code&gt; 時間単位全体の数と等しくなります。1秒あたりの &lt;code&gt;native&lt;/code&gt; 時間単位の数が整数にならない場合、結果は切り捨てられます。</target>
        </trans-unit>
        <trans-unit id="ef10c93f15b1c52938ec7e181160a865ba85041c" translate="yes" xml:space="preserve">
          <source>One critical issue to note here is that any term on the young heap can reference terms on the old heap but &lt;strong&gt;no&lt;/strong&gt; term on the old heap may refer to a term on the young heap. This is due to the nature of the copy algorithm. Anything referenced by an old heap term is not included in the reference tree, root-set and its followers, and hence is not copied. If it was, the data would be lost, fire and brimstone would rise to cover the earth. Fortunately, this comes naturally for Erlang because the terms are immutable and thus there can be no pointers modified on the old heap to point to the young heap.</source>
          <target state="translated">ここで注意すべき重要な問題の1つは、若いヒープの用語は古いヒープの用語を参照できますが、古いヒープの用語は若いヒープの用語を参照でき&lt;strong&gt;ない&lt;/strong&gt;ということです。これは、コピーアルゴリズムの性質によるものです。古いヒープ用語によって参照されるものはすべて、参照ツリー、ルートセット、およびそのフォロワーに含まれないため、コピーされません。もしそうなら、データは失われ、火と硫黄が地球を覆うように上昇するでしょう。幸いなことに、これはErlangにとって当然のことです。なぜなら、用語は不変であり、したがって、若いヒープを指すように古いヒープに変更されたポインターがないためです。</target>
        </trans-unit>
        <trans-unit id="0c004d9fe4418301daaece7534ddb42246eb9542" translate="yes" xml:space="preserve">
          <source>One entry per allocator. See &lt;code&gt;Allocator&lt;/code&gt; in section &quot;How to Interpret the Erlang Crash Dumps&quot; in ERTS.</source>
          <target state="translated">アロケータごとに1つのエントリ。参照 &lt;code&gt;Allocator&lt;/code&gt; ERTSで「アーランクラッシュダンプを解釈する方法」のセクションで。</target>
        </trans-unit>
        <trans-unit id="a5ae873b8dbf85d90619c54d5534f4bb29cc5b20" translate="yes" xml:space="preserve">
          <source>One example for this is to pre-process incoming data, for example decrypting chunks or collecting characters up to a line break.</source>
          <target state="translated">例えば、チャンクを復号化したり、改行までの文字を収集したりするなど、受信データの前処理を行うことができます。</target>
        </trans-unit>
        <trans-unit id="a14d428a902184f6d393d8bd6140890e2ae77f4b" translate="yes" xml:space="preserve">
          <source>One exception is pattern matching of binaries. The compiler does not rearrange clauses that match binaries. Placing the clause that matches against the empty binary &lt;strong&gt;last&lt;/strong&gt; is usually slightly faster than placing it &lt;strong&gt;first&lt;/strong&gt;.</source>
          <target state="translated">1つの例外は、バイナリのパターンマッチングです。コンパイラーは、バイナリーに一致する文節を再配置しません。空のバイナリと一致する句を&lt;strong&gt;最後に&lt;/strong&gt;配置すると、通常、&lt;strong&gt;最初に&lt;/strong&gt;配置するよりもわずかに速くなります。</target>
        </trans-unit>
        <trans-unit id="7d94c70dc04626571d8ea05626b35349d3398b38" translate="yes" xml:space="preserve">
          <source>One for finite-state machines (&lt;code&gt;&lt;a href=&quot;gen_fsm&quot;&gt;gen_fsm&lt;/a&gt;&lt;/code&gt; like), which requires the state to be an atom and uses that state as the name of the current callback function</source>
          <target state="translated">有限状態マシン用の1つ（ &lt;code&gt;&lt;a href=&quot;gen_fsm&quot;&gt;gen_fsm&lt;/a&gt;&lt;/code&gt; のような）。これは、状態をアトムにする必要があり、その状態を現在のコールバック関数の名前として使用します</target>
        </trans-unit>
        <trans-unit id="3f8d27506d8e90d0a22e543f80e99c7ae08237b4" translate="yes" xml:space="preserve">
          <source>One for finite-state machines (&lt;code&gt;&lt;a href=&quot;gen_fsm&quot;&gt;gen_fsm&lt;/a&gt;&lt;/code&gt; like), which requires the state to be an atom and uses that state as the name of the current callback function.</source>
          <target state="translated">1つは有限状態マシン（ &lt;code&gt;&lt;a href=&quot;gen_fsm&quot;&gt;gen_fsm&lt;/a&gt;&lt;/code&gt; のような）用で、状態がアトムである必要があり、その状態を現在のコールバック関数の名前として使用します。</target>
        </trans-unit>
        <trans-unit id="3770c544733aa5fb6e0292ae22987354af0a4e69" translate="yes" xml:space="preserve">
          <source>One group that &lt;code&gt;Common Test&lt;/code&gt; is to ignore and pass on directly to the emulator (those following &lt;code&gt;-erl_args&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;Common Test&lt;/code&gt; が無視する1つのグループは、エミュレーターに直接渡します（ &lt;code&gt;-erl_args&lt;/code&gt; に続くグループ）。</target>
        </trans-unit>
        <trans-unit id="d6a260162de88ba81cc22f21bd78e10fba85db33" translate="yes" xml:space="preserve">
          <source>One group that &lt;code&gt;Common Test&lt;/code&gt; is to process (those preceding &lt;code&gt;-erl_args&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;Common Test&lt;/code&gt; が処理する1つのグループ（ &lt;code&gt;-erl_args&lt;/code&gt; の前のグループ）。</target>
        </trans-unit>
        <trans-unit id="614890ec6bea0b6110430c451657204a01ec779e" translate="yes" xml:space="preserve">
          <source>One line from the file is returned, including the trailing LF, but with CRLF sequences replaced by a single LF (see above).</source>
          <target state="translated">ファイルからの1行が、末尾のLFを含めて返されますが、CRLF配列は1つのLFに置き換えられています(上記参照)。</target>
        </trans-unit>
        <trans-unit id="cdb5ea69a08925e346c04bb8f306808dfae21189" translate="yes" xml:space="preserve">
          <source>One log file, &lt;code&gt;run_erl.log&lt;/code&gt;, which logs progress and warnings from the &lt;code&gt;run_erl&lt;/code&gt; program itself.</source>
          <target state="translated">&lt;code&gt;run_erl&lt;/code&gt; プログラム自体からの進行状況と警告を記録する1つのログファイル &lt;code&gt;run_erl.log&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="19cc7e16964b3af0e44bb854d9aa8967052724d4" translate="yes" xml:space="preserve">
          <source>One may also convert arbitrary data to XML. So it for instance is easy to make it readable by humans. In this case you first create xmerl data structures out of your data, then transform it to XML.</source>
          <target state="translated">また、任意のデータをXMLに変換することもできます。そのため、例えば人間が読めるようにするのは簡単です。この場合、まずデータからxmerlデータ構造を作成し、それをXMLに変換します。</target>
        </trans-unit>
        <trans-unit id="ed6a90e414ee1584a7c5f1f7c5472363c8f0e272" translate="yes" xml:space="preserve">
          <source>One must be careful not to create infinite loops. For example, if we for some reason would want to reverse the operand order for the &lt;code&gt;move&lt;/code&gt; instruction, we must not do like this:</source>
          <target state="translated">無限ループを作成しないように注意する必要があります。たとえば、何らかの理由で &lt;code&gt;move&lt;/code&gt; 命令のオペランドの順序を逆にしたい場合は、次のようにしないでください。</target>
        </trans-unit>
        <trans-unit id="d6d6f92b8658a1866e9d8146c603570466b38bb9" translate="yes" xml:space="preserve">
          <source>One network RPC (two messages) to acquire the write lock</source>
          <target state="translated">書き込みロックを取得するための1つのネットワークRPC(2つのメッセージ)</target>
        </trans-unit>
        <trans-unit id="00a56ba397ce141f9962051dd004c70978ba6dd8" translate="yes" xml:space="preserve">
          <source>One nice thing with the &lt;code&gt;trace_pattern&lt;/code&gt; is that it provides a very simple way of minimizing the amount of generated trace data by allowing you to explicitly control the detail level of the tracing. As you may have seen the &lt;code&gt;et_viewer&lt;/code&gt; have a slider called &lt;code&gt;&quot;Detail Level&quot;&lt;/code&gt; that allows you to control the detail level of the trace &lt;code&gt;Events&lt;/code&gt; displayed in the &lt;code&gt;Viewer&lt;/code&gt;. On the other hand if you set a low detail level in the &lt;code&gt;trace_pattern&lt;/code&gt;, lots of the trace data will never be generated and thus not sent over the socket to the trace client and stored in the &lt;code&gt;Collector&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;trace_pattern&lt;/code&gt; の優れた点の1つは、トレースの詳細レベルを明示的に制御できるようにすることで、生成されるトレースデータの量を最小限に抑える非常に簡単な方法を提供することです。 &lt;code&gt;et_viewer&lt;/code&gt; ように、et_viewerには &lt;code&gt;&quot;Detail Level&quot;&lt;/code&gt; と呼ばれるスライダーがあり、 &lt;code&gt;Viewer&lt;/code&gt; 表示されるトレース &lt;code&gt;Events&lt;/code&gt; 詳細レベルを制御できます。一方、 &lt;code&gt;trace_pattern&lt;/code&gt; で詳細レベルを低く設定すると、大量のトレースデータが生成されないため、ソケットを介してトレースクライアントに送信されず、 &lt;code&gt;Collector&lt;/code&gt; 格納されません。</target>
        </trans-unit>
        <trans-unit id="4529738d7c5d95ab24a59e21df7882f76ad41b01" translate="yes" xml:space="preserve">
          <source>One of &lt;code&gt;&quot;Error&quot;&lt;/code&gt;, &lt;code&gt;&quot;Warning&quot;&lt;/code&gt;, &lt;code&gt;&quot;Informational&quot;&lt;/code&gt;, &lt;code&gt;&quot;Audit_Success&quot;&lt;/code&gt;, &lt;code&gt;&quot;Audit_Faulure&quot;&lt;/code&gt; or, in case of a currently unknown Windows NT version &lt;code&gt;&quot;Severity_Unknown&quot;&lt;/code&gt;.</source>
          <target state="translated">一つ &lt;code&gt;&quot;Error&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;Warning&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;Informational&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;Audit_Success&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;Audit_Faulure&quot;&lt;/code&gt; や、現在不明のWindows NT版の場合は &lt;code&gt;&quot;Severity_Unknown&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b8715b5dac001f8acd8e786d5f72ce95270b48d8" translate="yes" xml:space="preserve">
          <source>One of &lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt; sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; is invoked to get the &lt;code&gt;gen_event&lt;/code&gt; status. &lt;code&gt;Opt&lt;/code&gt; is set to the atom &lt;code&gt;normal&lt;/code&gt; for this case.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt; sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; の1つが呼び出され、 &lt;code&gt;gen_event&lt;/code&gt; ステータスが取得されます。この場合、 &lt;code&gt;Opt&lt;/code&gt; は &lt;code&gt;normal&lt;/code&gt; の原子に設定されます。</target>
        </trans-unit>
        <trans-unit id="e4ea7befab7a1376dc38a902be4e17f510f6d524" translate="yes" xml:space="preserve">
          <source>One of &lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt; sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; is invoked to get the &lt;code&gt;gen_server&lt;/code&gt; status. &lt;code&gt;Opt&lt;/code&gt; is set to the atom &lt;code&gt;normal&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt; sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; の1つが呼び出され、 &lt;code&gt;gen_server&lt;/code&gt; ステータスが取得されます。 &lt;code&gt;Opt&lt;/code&gt; は原子 &lt;code&gt;normal&lt;/code&gt; 設定されます。</target>
        </trans-unit>
        <trans-unit id="b1a6b0b2d35c017b6e03a9c4a65c9d58e6870f08" translate="yes" xml:space="preserve">
          <source>One of &lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt;sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; is invoked to get the &lt;code&gt;gen_event&lt;/code&gt; status. &lt;code&gt;Opt&lt;/code&gt; is set to the atom &lt;code&gt;normal&lt;/code&gt; for this case.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt;sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; の 1つが呼び出され、 &lt;code&gt;gen_event&lt;/code&gt; ステータスが取得されます。この場合、 &lt;code&gt;Opt&lt;/code&gt; は &lt;code&gt;normal&lt;/code&gt; のアトムに設定されます。</target>
        </trans-unit>
        <trans-unit id="7da5bbc0da1569bb676eb4407e53fc819a024b48" translate="yes" xml:space="preserve">
          <source>One of &lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt;sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; is invoked to get the &lt;code&gt;gen_server&lt;/code&gt; status. &lt;code&gt;Opt&lt;/code&gt; is set to the atom &lt;code&gt;normal&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt;sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; の 1つが呼び出され、 &lt;code&gt;gen_server&lt;/code&gt; ステータスを取得します。 &lt;code&gt;Opt&lt;/code&gt; はアトム &lt;code&gt;normal&lt;/code&gt; 設定されます。</target>
        </trans-unit>
        <trans-unit id="eb296f4b0ca5c3593de75916329b44424ed9130b" translate="yes" xml:space="preserve">
          <source>One of &lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt;sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; is invoked to get the &lt;code&gt;gen_statem&lt;/code&gt; status. &lt;code&gt;Opt&lt;/code&gt; is set to the atom &lt;code&gt;normal&lt;/code&gt; for this case.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;sys#get_status-1&quot;&gt;sys:get_status/1,2&lt;/a&gt;&lt;/code&gt; の 1つが呼び出され、 &lt;code&gt;gen_statem&lt;/code&gt; ステータスが取得されます。この場合、 &lt;code&gt;Opt&lt;/code&gt; は &lt;code&gt;normal&lt;/code&gt; のアトムに設定されます。</target>
        </trans-unit>
        <trans-unit id="fdb44fc1b32a8df8e66016b4df34ca5e01e3c2a5" translate="yes" xml:space="preserve">
          <source>One of the &lt;code&gt;&lt;a href=&quot;#options&quot;&gt;SCTP Socket Options&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#options&quot;&gt;SCTP Socket Options&lt;/a&gt;&lt;/code&gt; 1つ。</target>
        </trans-unit>
        <trans-unit id="4929df166f7d8de83e743d85b22e80a274c8fcf4" translate="yes" xml:space="preserve">
          <source>One of the &lt;code&gt;Host&lt;/code&gt; and &lt;code&gt;Service&lt;/code&gt; may be &lt;code&gt;undefined&lt;/code&gt; but &lt;strong&gt;not&lt;/strong&gt; both.</source>
          <target state="translated">&lt;code&gt;Host&lt;/code&gt; と &lt;code&gt;Service&lt;/code&gt; 一方が &lt;code&gt;undefined&lt;/code&gt; 可能性がありますが&lt;strong&gt;、&lt;/strong&gt;両方は定義されてい&lt;strong&gt;ません&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="56827b36a41cbbd74b980c5f475d1ddd1caffbc8" translate="yes" xml:space="preserve">
          <source>One of the UTF-encodings, which is specified as parameter &lt;code&gt;InEncoding&lt;/code&gt;.</source>
          <target state="translated">パラメータ &lt;code&gt;InEncoding&lt;/code&gt; として指定されているUTFエンコーディングの1つ。</target>
        </trans-unit>
        <trans-unit id="2585f7fa5d9239f75ea13c3267959aa775292560" translate="yes" xml:space="preserve">
          <source>One of the cornerstones of security in SSH is cryptography. The development in crypto analysis is fast, and yesterday's secure algorithms are unsafe today. Therefore some algorithms are no longer enabled by default and that group grows with time. See the &lt;code&gt;SSH (App)&lt;/code&gt; for a list of supported and of disabled algorithms. In the User's Guide the chapter &lt;code&gt;&lt;a href=&quot;configure_algos&quot;&gt;Configuring algorithms in SSH&lt;/a&gt;&lt;/code&gt; describes the options for enabling or disabling algorithms - &lt;code&gt;&lt;a href=&quot;ssh#type-preferred_algorithms_common_option&quot;&gt;preferred_algorithms&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ssh#type-modify_algorithms_common_option&quot;&gt;modify_algorithms&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">SSHのセキュリティの基礎の1つは、暗号化です。暗号分析の開発は速く、昨日の安全なアルゴリズムは今日では安全ではありません。したがって、一部のアルゴリズムはデフォルトで有効ではなくなり、そのグループは時間とともに大きくなります。サポートされているアルゴリズムと無効になっているアルゴリズムのリストについては、 &lt;code&gt;SSH (App)&lt;/code&gt; を参照してください。ユーザーガイドの「 &lt;code&gt;&lt;a href=&quot;configure_algos&quot;&gt;Configuring algorithms in SSH&lt;/a&gt;&lt;/code&gt; 」の章では、アルゴリズムを有効または無効にするためのオプション（ &lt;code&gt;&lt;a href=&quot;ssh#type-preferred_algorithms_common_option&quot;&gt;preferred_algorithms&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;ssh#type-modify_algorithms_common_option&quot;&gt;modify_algorithms&lt;/a&gt;&lt;/code&gt; )について説明しています。</target>
        </trans-unit>
        <trans-unit id="bf5094e20e8e0457a5a8f2279ba88b4ba2472732" translate="yes" xml:space="preserve">
          <source>One of the kernel processes could not start. This is probably because of faulty arguments (like errors in a &lt;code&gt;-config&lt;/code&gt; argument) or faulty configuration files. Check that all files are in their correct location and that the configuration files (if any) are not damaged. Usually messages are also written to the controlling terminal and/or the error log explaining what is wrong.</source>
          <target state="translated">カーネルプロセスの1つを開始できませんでした。これはおそらく、引数（ &lt;code&gt;-config&lt;/code&gt; 引数のエラーなど）または設定ファイルの誤りが原因です。すべてのファイルが正しい場所にあり、構成ファイル（存在する場合）が損傷していないことを確認してください。通常、メッセージは制御端末やエラーログにも書き込まれ、何が問題かを説明します。</target>
        </trans-unit>
        <trans-unit id="0841995ee62550fe5206c50f4fb1982a4e801b20" translate="yes" xml:space="preserve">
          <source>One of the main reasons for using Erlang instead of other functional languages is Erlang's ability to handle concurrency and distributed programming. By concurrency is meant programs that can handle several threads of execution at the same time. For example, modern operating systems allow you to use a word processor, a spreadsheet, a mail client, and a print job all running at the same time. Each processor (CPU) in the system is probably only handling one thread (or job) at a time, but it swaps between the jobs at such a rate that it gives the illusion of running them all at the same time. It is easy to create parallel threads of execution in an Erlang program and to allow these threads to communicate with each other. In Erlang, each thread of execution is called a &lt;strong&gt;process&lt;/strong&gt;.</source>
          <target state="translated">他の関数型言語の代わりにErlangを使用する主な理由の1つは、並行性と分散プログラミングを処理するErlangの機能です。並行性とは、複数の実行スレッドを同時に処理できるプログラムを意味します。たとえば、最新のオペレーティングシステムでは、ワープロ、スプレッドシート、メールクライアント、印刷ジョブをすべて同時に実行することができます。システム内の各プロセッサ（CPU）は、一度に1つのスレッド（またはジョブ）のみを処理しますが、ジョブを同時に実行しているように見える速度でジョブ間をスワップします。 Erlangプログラムで実行の並列スレッドを作成し、これらのスレッドが互いに通信できるようにするのは簡単です。 Erlangでは、実行の各スレッドは&lt;strong&gt;プロセス&lt;/strong&gt;と呼ばれ&lt;strong&gt;ます&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="9c3a03a73b3fd84a50282a6c958644d8dd3d3c26" translate="yes" xml:space="preserve">
          <source>One of the possible &lt;strong&gt;transition actions&lt;/strong&gt; is to postpone the current event. Then it is not retried in the current state. The &lt;code&gt;gen_statem&lt;/code&gt; engine keeps a queue of events divided into the postponed events and the events still to process. After a &lt;strong&gt;state change&lt;/strong&gt; the queue restarts with the postponed events.</source>
          <target state="translated">可能な&lt;strong&gt;移行アクションの&lt;/strong&gt;1つは、現在のイベントを延期することです。その後、現在の状態では再試行されません。 &lt;code&gt;gen_statem&lt;/code&gt; のエンジンは、プロセスにまだ延期のイベントやイベントに分けたイベントのキューを保持します。&lt;strong&gt;状態の変更&lt;/strong&gt;後、キューは延期されたイベントで再開します。</target>
        </trans-unit>
        <trans-unit id="f9c1395f01aa6569ad6f5518bd05795ed28e86fb" translate="yes" xml:space="preserve">
          <source>One of the things you can specify is where Erlang/OTP should be installed. By default Erlang/OTP will be installed in &lt;code&gt;/usr/local/{bin,lib/erlang}&lt;/code&gt;. To keep the same structure but install in a different place, &lt;code&gt;&amp;lt;Dir&amp;gt;&lt;/code&gt; say, use the &lt;code&gt;--prefix&lt;/code&gt; argument like this: &lt;code&gt;./configure --prefix=&amp;lt;Dir&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">指定できることの1つは、Erlang / OTPをインストールする場所です。デフォルトでは、Erlang / OTPは &lt;code&gt;/usr/local/{bin,lib/erlang}&lt;/code&gt; インストールされます。同じ構造を維持しながら別の場所にインストールする場合は、 &lt;code&gt;&amp;lt;Dir&amp;gt;&lt;/code&gt; のように、-- &lt;code&gt;--prefix&lt;/code&gt; 引数を &lt;code&gt;./configure --prefix=&amp;lt;Dir&amp;gt;&lt;/code&gt; のように使用します。</target>
        </trans-unit>
        <trans-unit id="1eeb7842fcafd703c9e0619139450ba12ea61a05" translate="yes" xml:space="preserve">
          <source>One of the tuples is &lt;code&gt;{timeout, GcTime}&lt;/code&gt;, where &lt;code&gt;GcTime&lt;/code&gt; is the time for the garbage collection in milliseconds. The other tuples are tagged with &lt;code&gt;heap_size&lt;/code&gt;, &lt;code&gt;heap_block_size&lt;/code&gt;, &lt;code&gt;stack_size&lt;/code&gt;, &lt;code&gt;mbuf_size&lt;/code&gt;, &lt;code&gt;old_heap_size&lt;/code&gt;, and &lt;code&gt;old_heap_block_size&lt;/code&gt;. These tuples are explained in the description of trace message &lt;code&gt;&lt;a href=&quot;#gc_minor_start&quot;&gt;gc_minor_start&lt;/a&gt;&lt;/code&gt; (see &lt;code&gt;&lt;a href=&quot;#trace-3&quot;&gt;erlang:trace/3&lt;/a&gt;&lt;/code&gt;). New tuples can be added, and the order of the tuples in the &lt;code&gt;Info&lt;/code&gt; list can be changed at any time without prior notice.</source>
          <target state="translated">タプルの1つは &lt;code&gt;{timeout, GcTime}&lt;/code&gt; で、 &lt;code&gt;GcTime&lt;/code&gt; はガベージコレクションの時間（ミリ秒）です。その他のタプルには、 &lt;code&gt;heap_size&lt;/code&gt; 、 &lt;code&gt;heap_block_size&lt;/code&gt; 、 &lt;code&gt;stack_size&lt;/code&gt; 、 &lt;code&gt;mbuf_size&lt;/code&gt; 、 &lt;code&gt;old_heap_size&lt;/code&gt; 、および &lt;code&gt;old_heap_block_size&lt;/code&gt; のタグが付けられています。これらのタプルについては、トレースメッセージ &lt;code&gt;&lt;a href=&quot;#gc_minor_start&quot;&gt;gc_minor_start&lt;/a&gt;&lt;/code&gt; の説明で説明されています（ &lt;code&gt;&lt;a href=&quot;#trace-3&quot;&gt;erlang:trace/3&lt;/a&gt;&lt;/code&gt; を参照）。新しいタプルを追加することができ、 &lt;code&gt;Info&lt;/code&gt; リスト内のタプルの順序は、事前の通知なしにいつでも変更できます。</target>
        </trans-unit>
        <trans-unit id="69a9014859b12f37b0519806ad1834d826c6c31a" translate="yes" xml:space="preserve">
          <source>One of these MIBs is always loaded. If only SNMPv1 is used, STANDARD-MIB is loaded, otherwise SNMPv2-MIB is loaded.</source>
          <target state="translated">これらのMIBのいずれかが常にロードされます。SNMPv1のみを使用する場合はSTANDARD-MIBがロードされ、そうでない場合はSNMPv2-MIBがロードされます。</target>
        </trans-unit>
        <trans-unit id="7e580959901caa525ce54698db0283f68f4a7825" translate="yes" xml:space="preserve">
          <source>One option is available:</source>
          <target state="translated">選択肢は1つです。</target>
        </trans-unit>
        <trans-unit id="6ff4f2ec7cb45924fc22a9581c0d12e7c6a17439" translate="yes" xml:space="preserve">
          <source>One or more records have possibly been deleted. All records with the key &lt;code&gt;Key&lt;/code&gt; in the table &lt;code&gt;Tab&lt;/code&gt; have been deleted.</source>
          <target state="translated">1つ以上のレコードが削除された可能性があります。テーブル &lt;code&gt;Tab&lt;/code&gt; にキー &lt;code&gt;Key&lt;/code&gt; を持つすべてのレコードが削除されました。</target>
        </trans-unit>
        <trans-unit id="6fa66ab663063997cdb9c048f7104f3433cd5c89" translate="yes" xml:space="preserve">
          <source>One or more selective decode functions can be described in a configuration file. Use the following notation:</source>
          <target state="translated">つ以上の選択的デコード機能は、構成ファイルに記述することができる。以下の表記を使用してください。</target>
        </trans-unit>
        <trans-unit id="2e8538d4b29bcc1590b46f99d089134dbfb209ae" translate="yes" xml:space="preserve">
          <source>One possible use of this function is to compute a fixed layout for a document, which can then be included as part of a larger document. For example:</source>
          <target state="translated">この関数を利用して、ある文書の固定レイアウトを計算し、それをより大きな文書の一部として含めることができます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="f814b315540a519172775a3b2360fd1f8b22e518" translate="yes" xml:space="preserve">
          <source>One process can block multi-scheduling and normal multi-scheduling multiple times. If a process has blocked multiple times, it must unblock exactly as many times as it has blocked before it has released its multi-scheduling block. If a process that has blocked multi-scheduling or normal multi-scheduling exits, it automatically releases its blocking of multi-scheduling and normal multi-scheduling.</source>
          <target state="translated">1つのプロセスは、マルチスケジューリングと通常のマルチスケジューリングを複数回ブロックすることができます。あるプロセスが複数回ブロックした場合、マルチスケジューリングのブロックを解除する前に、ブロックした回数と同じだけブロックを解除しなければなりません。マルチスケジューリングや通常のマルチスケジューリングをブロックしたプロセスが終了すると、自動的にマルチスケジューリングや通常のマルチスケジューリングのブロックを解除します。</target>
        </trans-unit>
        <trans-unit id="4e1d0d9b681492f79f0f0d77d94d063833656c4e" translate="yes" xml:space="preserve">
          <source>One reason to use this is when you have a state item that when changed should cancel the &lt;code&gt;&lt;a href=&quot;#State%20Time-Outs&quot;&gt;State Time-Out&lt;/a&gt;&lt;/code&gt;, or one that affects the event handling in combination with postponing events. We will go for the latter and complicate the previous example by introducing a configurable lock button (this is the state item in question), which in the &lt;code&gt;open&lt;/code&gt; state immediately locks the door, and an API function &lt;code&gt;set_lock_button/1&lt;/code&gt; to set the lock button.</source>
          <target state="translated">これを使用する理由の1つは、変更時に &lt;code&gt;&lt;a href=&quot;#State%20Time-Outs&quot;&gt;State Time-Out&lt;/a&gt;&lt;/code&gt; をキャンセルする必要がある状態アイテムがある場合、またはイベントの延期と組み合わせてイベント処理に影響を与えるものです。後者に進み、構成可能なロックボタン（これは問題の状態項目です）を導入して前の例を複雑にします。これは &lt;code&gt;open&lt;/code&gt; 状態ですぐにドアをロックし、API関数 &lt;code&gt;set_lock_button/1&lt;/code&gt; がロックボタンを設定します。</target>
        </trans-unit>
        <trans-unit id="f23d4aa95b25f50a19f9b6b4374f1b88dac66685" translate="yes" xml:space="preserve">
          <source>One reason to use this is when you have a state item that when changed should cancel the &lt;code&gt;&lt;a href=&quot;#State%20Time-Outs&quot;&gt;state time-out&lt;/a&gt;&lt;/code&gt;, or one that affects the event handling in combination with postponing events. We will go for the latter and complicate the previous example by introducing a configurable lock button (this is the state item in question), which in the &lt;code&gt;open&lt;/code&gt; state immediately locks the door, and an API function &lt;code&gt;set_lock_button/1&lt;/code&gt; to set the lock button.</source>
          <target state="translated">これを使用する理由の1つは、変更されたときに &lt;code&gt;&lt;a href=&quot;#State%20Time-Outs&quot;&gt;state time-out&lt;/a&gt;&lt;/code&gt; をキャンセルする必要がある状態アイテムがある場合、またはイベントの延期と組み合わせてイベント処理に影響を与える場合です。後者を選択し、 &lt;code&gt;open&lt;/code&gt; 状態ですぐにドアをロックする構成可能なロックボタン（これは問題の状態アイテムです）と、ロックボタンを設定するAPI関数 &lt;code&gt;set_lock_button/1&lt;/code&gt; を導入することにより、前の例を複雑にします。</target>
        </trans-unit>
        <trans-unit id="c6a0ffbab932f1acb483f5ff3812f8940806157e" translate="yes" xml:space="preserve">
          <source>One slight difference is that &lt;code&gt;length(L)&lt;/code&gt; fails if &lt;code&gt;L&lt;/code&gt; is an improper list, while the pattern in the second code fragment accepts an improper list.</source>
          <target state="translated">わずかな違いの1つは、 &lt;code&gt;L&lt;/code&gt; が不適切なリストである場合、 &lt;code&gt;length(L)&lt;/code&gt; が失敗するのに対し、2番目のコードフラグメントのパターンは不適切なリストを受け入れることです。</target>
        </trans-unit>
        <trans-unit id="131ac9dcf4813fc8eef42652b85941c718619c49" translate="yes" xml:space="preserve">
          <source>One solution to this problem is to make the snmp application a distributed Erlang application, and that means, the agent may be configured to run on one of several nodes. If the node where it runs goes down, another node restarts the agent. This is called &lt;strong&gt;failover&lt;/strong&gt;. When the node starts again, it may &lt;strong&gt;takeover&lt;/strong&gt; the application. This solution to the problem adds another problem. Generally, the new node has another IP address than the first one, which may cause problems in the communication between the SNMP managers and the agent.</source>
          <target state="translated">この問題の1つの解決策は、snmpアプリケーションを分散Erlangアプリケーションにすることです。つまり、エージェントは、いくつかのノードの1つで実行するように構成できます。実行されているノードがダウンした場合、別のノードがエージェントを再起動します。これは&lt;strong&gt;フェイルオーバー&lt;/strong&gt;と呼ばれ&lt;strong&gt;ます&lt;/strong&gt;。ノードが再起動すると、アプリケーションを&lt;strong&gt;引き継ぐ&lt;/strong&gt;場合があります。この問題に対するこの解決策は、別の問題を追加します。通常、新しいノードには最初のノードとは別のIPアドレスが割り当てられているため、SNMPマネージャーとエージェント間の通信で問題が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="4512e5220c29e6a7833a429e6e4b986d799dd593" translate="yes" xml:space="preserve">
          <source>One such debug functionality is the &lt;strong&gt;lock checker&lt;/strong&gt;, which can detect locking order violations and thereby potential deadlock bugs. For the lock checker to work the &lt;code&gt;name&lt;/code&gt; should be on the format &lt;code&gt;&quot;App.Type&quot;&lt;/code&gt; or &lt;code&gt;&quot;App.Type[Instance]&quot;&lt;/code&gt;, where App is the name of the application, Type is the name of the lock type and Instance is optional information about each lock instance. &quot;App.Type&quot; should be a unique name for the lock checker to detect lock order violations between locks of different types. The Instance information is currently ignored.</source>
          <target state="translated">そのようなデバッグ機能の1つが&lt;strong&gt;ロックチェッカーです&lt;/strong&gt;。これは、ロック順序違反を検出して、潜在的なデッドロックバグを検出できます。ロックチェッカーが機能するには、 &lt;code&gt;name&lt;/code&gt; が &lt;code&gt;&quot;App.Type&quot;&lt;/code&gt; または &lt;code&gt;&quot;App.Type[Instance]&quot;&lt;/code&gt; の形式である必要があります。ここで、Appはアプリケーションの名前、Typeはロックタイプの名前、Instanceはオプションの情報です。各ロックインスタンスについて。 「App.Type」は、異なるタイプのロック間のロック順序違反を検出するためのロックチェッカーの一意の名前である必要があります。インスタンス情報は現在無視されています。</target>
        </trans-unit>
        <trans-unit id="6de0b12460a91c3f5fd94e39bda2873b3f5b7b16" translate="yes" xml:space="preserve">
          <source>One that allows the state to be any term and that uses one callback function for all states.</source>
          <target state="translated">状態を任意の項にすることができ、すべての状態に対して1つのコールバック関数を使用するもの。</target>
        </trans-unit>
        <trans-unit id="2ae865e27e4e371daac0c98d141254785bdec512" translate="yes" xml:space="preserve">
          <source>One use for this function is to return compact alternative state representations to avoid having large state terms printed in log files. Another use is to hide sensitive data from being written to the error log.</source>
          <target state="translated">この関数の1つの用途は、ログファイルに大きな状態項が印刷されるのを避けるために、コンパクトな代替状態表現を返すことです。もう一つの用途は、エラーログに書き込まれる機密データを隠すことです。</target>
        </trans-unit>
        <trans-unit id="2344ac8a5a53008ccbf114aa5bb4b2144babab77" translate="yes" xml:space="preserve">
          <source>One use for this function is to return compact alternative state representations to avoid that large state terms are printed in log files.</source>
          <target state="translated">この関数の1つの用途は、ログファイルに大きな状態項が印刷されるのを避けるために、コンパクトな代替状態表現を返すことです。</target>
        </trans-unit>
        <trans-unit id="ecf62d4adfa3a80a6880d79089f74bc1229726c5" translate="yes" xml:space="preserve">
          <source>One valid &lt;code&gt;Item&lt;/code&gt; for events exists:</source>
          <target state="translated">イベントに有効な &lt;code&gt;Item&lt;/code&gt; が1つ存在します：</target>
        </trans-unit>
        <trans-unit id="a1de3f4f0701ff8998dbe849ff16761b4287d4cb" translate="yes" xml:space="preserve">
          <source>One way to handle this is to use the &lt;code&gt;&lt;a href=&quot;#shutdown-2&quot;&gt;shutdown&lt;/a&gt;&lt;/code&gt; function (&lt;code&gt;socket:shutdown(Socket, write)&lt;/code&gt;) to signal that no more data is to be sent and then wait for the read side of the socket to be closed.</source>
          <target state="translated">これを処理する1つの方法は、 &lt;code&gt;&lt;a href=&quot;#shutdown-2&quot;&gt;shutdown&lt;/a&gt;&lt;/code&gt; 関数（ &lt;code&gt;socket:shutdown(Socket, write)&lt;/code&gt; ）を使用して、これ以上データを送信しないことを通知し、ソケットの読み取り側が閉じられるのを待つことです。</target>
        </trans-unit>
        <trans-unit id="78dac560fa843dd6f0f972d52ed8040ce20cb74d" translate="yes" xml:space="preserve">
          <source>One way to reduce the risk of intrusion is to not convey which software and which version the intruder is connected to. This limits the risk of an intruder exploiting known faults or peculiarities learned by reading the public code.</source>
          <target state="translated">侵入のリスクを減らす方法の一つは、侵入者がどのソフトウェアとどのバージョンに接続されているかを伝えないことです。これにより、侵入者が公開コードを読むことで学習した既知の障害や特殊性を悪用するリスクを抑えることができます。</target>
        </trans-unit>
        <trans-unit id="0530e4915fd69c53963bcd7d20091d18ef6b916a" translate="yes" xml:space="preserve">
          <source>One without restriction on the state data type that uses one callback function for all states</source>
          <target state="translated">すべての状態に対して1つのコールバック関数を使用する状態データ型に制限のないもの</target>
        </trans-unit>
        <trans-unit id="125ef9e0e55df17c031033b5d420b053905b830e" translate="yes" xml:space="preserve">
          <source>Online Help</source>
          <target state="translated">オンラインヘルプ</target>
        </trans-unit>
        <trans-unit id="6fbd38dfe616170f1b6def311df7bb7a510f025b" translate="yes" xml:space="preserve">
          <source>Online support - &lt;code&gt;release_handler&lt;/code&gt; for unpacking and installing release packages</source>
          <target state="translated">オンラインサポート- リリースパッケージを解凍してインストールするための &lt;code&gt;release_handler&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ae87ac2b337c683a338363cdb6dd6e6e3a876d81" translate="yes" xml:space="preserve">
          <source>Only a subset is valid.</source>
          <target state="translated">サブセットのみが有効です。</target>
        </trans-unit>
        <trans-unit id="85e8ca2afe642fa985ec03b77e6580554e8210e3" translate="yes" xml:space="preserve">
          <source>Only a subset of all &lt;code&gt;erts_alloc&lt;/code&gt; flags can be changed at run time. This subset is currently only the flag &lt;code&gt;sbct&lt;/code&gt;.</source>
          <target state="translated">実行時に変更できるのは、すべての &lt;code&gt;erts_alloc&lt;/code&gt; フラグのサブセットのみです。このサブセットは現在、フラグ &lt;code&gt;sbct&lt;/code&gt; のみです。</target>
        </trans-unit>
        <trans-unit id="8fc50435c4f101d7fcbdd1178cc4fb637fb7e775" translate="yes" xml:space="preserve">
          <source>Only a subset of the function clauses are show above. The full set of valid combinations of input parameters is as follows:</source>
          <target state="translated">関数節のサブセットのみを上記に示す。入力パラメータの有効な組み合わせの完全なセットは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="a71b05d84131dd4964afd0db7b460b38e844ff2b" translate="yes" xml:space="preserve">
          <source>Only actual parameters with other than default values are returned, for example not directives that specify other sources for configuration parameters nor directives that clear parameters.</source>
          <target state="translated">デフォルト値以外の実際のパラメータのみが返され、例えば設定パラメータの他のソースを指定するディレクティブや、パラメータをクリアするディレクティブは返されません。</target>
        </trans-unit>
        <trans-unit id="143811c603bbe64ab0e87b64c4ca39d3733d06c3" translate="yes" xml:space="preserve">
          <source>Only allowed after an &lt;code&gt;if&lt;/code&gt; or another &lt;code&gt;elif&lt;/code&gt; directive. If the preceding &lt;code&gt;if&lt;/code&gt; or &lt;code&gt;elif&lt;/code&gt; directives do not evaluate to true, and the &lt;code&gt;Condition&lt;/code&gt; evaluates to true, the lines following the &lt;code&gt;elif&lt;/code&gt; are evaluated instead.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; または別の &lt;code&gt;elif&lt;/code&gt; ディレクティブの後にのみ許可されます。上記の &lt;code&gt;if&lt;/code&gt; または &lt;code&gt;elif&lt;/code&gt; ディレクティブがtrueに評価されず、 &lt;code&gt;Condition&lt;/code&gt; がtrueに評価される場合、 &lt;code&gt;elif&lt;/code&gt; に続く行が代わりに評価されます。</target>
        </trans-unit>
        <trans-unit id="6e65766f3d400fa0c4ec2ec7f3b23a8557087a78" translate="yes" xml:space="preserve">
          <source>Only allowed after an &lt;code&gt;ifdef&lt;/code&gt; or &lt;code&gt;ifndef&lt;/code&gt; directive. If that condition is false, the lines following &lt;code&gt;else&lt;/code&gt; are evaluated instead.</source>
          <target state="translated">&lt;code&gt;ifdef&lt;/code&gt; または &lt;code&gt;ifndef&lt;/code&gt; ディレクティブの後にのみ許可されます。その条件が偽の場合、 &lt;code&gt;else&lt;/code&gt; に続く行が代わりに評価されます。</target>
        </trans-unit>
        <trans-unit id="03727b1fe9878a4627e85a8cbe80d475296b011b" translate="yes" xml:space="preserve">
          <source>Only allowed for connection-oriented sockets.</source>
          <target state="translated">接続指向のソケットでのみ許可されます。</target>
        </trans-unit>
        <trans-unit id="b872c6846f1badf545548103fe27329f7bb9d68b" translate="yes" xml:space="preserve">
          <source>Only binaries and allocations made by NIFs and drivers are tagged by default, but this can be configured an a per-allocator basis with the &lt;code&gt;+M&amp;lt;S&amp;gt;atags &lt;/code&gt; emulator option.</source>
          <target state="translated">デフォルトでは、NIFとドライバーによって作成されたバイナリと割り当てのみがタグ付けされますが、これは &lt;code&gt;+M&amp;lt;S&amp;gt;atags &lt;/code&gt; エミュレーターオプションを使用してアロケーターごとに構成できます。</target>
        </trans-unit>
        <trans-unit id="1a32ac3b85acdfc340d76cd1ade965319d5c1792" translate="yes" xml:space="preserve">
          <source>Only binaries and allocations made by NIFs and drivers are tagged by default, but this can be configured an a per-allocator basis with the &lt;code&gt;+M&amp;lt;S&amp;gt;atags&lt;/code&gt; emulator option.</source>
          <target state="translated">NIFとドライバーによって作成されたバイナリと割り当てのみがデフォルトでタグ付けされますが、これは &lt;code&gt;+M&amp;lt;S&amp;gt;atags&lt;/code&gt; エミュレーターオプションを使用してアロケーターごとに構成できます。</target>
        </trans-unit>
        <trans-unit id="3f8fcfa18b8b4298ae4d967d6d04b8aabbe6553a" translate="yes" xml:space="preserve">
          <source>Only exceptions occurring during the evaluation of &lt;code&gt;Exprs&lt;/code&gt; can be caught by the &lt;code&gt;catch&lt;/code&gt; section. Exceptions occurring in a &lt;code&gt;Body&lt;/code&gt; or due to a failed match are not caught.</source>
          <target state="translated">&lt;code&gt;Exprs&lt;/code&gt; の評価中に発生した例外のみが、 &lt;code&gt;catch&lt;/code&gt; セクションでキャッチできます。 &lt;code&gt;Body&lt;/code&gt; 発生した例外、または一致の失敗が原因で発生した例外はキャッチされません。</target>
        </trans-unit>
        <trans-unit id="d5ee0b816fb973da72fef21bb99316a4666d0fe2" translate="yes" xml:space="preserve">
          <source>Only explicit connection set-ups are used.</source>
          <target state="translated">明示的な接続設定のみが使用されます。</target>
        </trans-unit>
        <trans-unit id="965fd205ec4a5be006cc4bdca91e080bb904b491" translate="yes" xml:space="preserve">
          <source>Only files with exactly these extensions are compressed.</source>
          <target state="translated">まさにこれらの拡張子を持つファイルのみが圧縮されます。</target>
        </trans-unit>
        <trans-unit id="d800e233c81231deb85380be879f6765bb0a09d1" translate="yes" xml:space="preserve">
          <source>Only if a shell script or &lt;code&gt;.bat&lt;/code&gt; file is executed, the appropriate command interpreter is invoked implicitly, but there is still no command-argument expansion or implicit &lt;code&gt;PATH&lt;/code&gt; search.</source>
          <target state="translated">シェルスクリプトまたは &lt;code&gt;.bat&lt;/code&gt; ファイルが実行された場合のみ、適切なコマンドインタープリターが暗黙的に呼び出されますが、コマンド引数の拡張や暗黙的な &lt;code&gt;PATH&lt;/code&gt; 検索はまだ行われません。</target>
        </trans-unit>
        <trans-unit id="6e308954fb7661938a56cab2015555144c20f290" translate="yes" xml:space="preserve">
          <source>Only if a string contains code points &amp;lt; 256, can it be directly converted to a binary by using, for example, &lt;code&gt;erlang:iolist_to_binary/1&lt;/code&gt; or can be sent directly to a port. If the string contains Unicode characters &amp;gt; 255, an encoding must be decided upon and the string is to be converted to a binary in the preferred encoding using &lt;code&gt;unicode:characters_to_binary/1,2,3&lt;/code&gt;. Strings are not generally lists of bytes, as they were before Erlang/OTP R13, they are lists of characters. Characters are not generally bytes, they are Unicode code points.</source>
          <target state="translated">文字列に256未満のコードポイントが含まれている場合のみ、たとえば &lt;code&gt;erlang:iolist_to_binary/1&lt;/code&gt; を使用して文字列をバイナリに直接変換したり、ポートに直接送信したりできます。文字列に255を超えるUnicode文字が含まれている場合、エンコーディングを決定する必要があり、文字列は &lt;code&gt;unicode:characters_to_binary/1,2,3&lt;/code&gt; を使用して優先エンコーディングでバイナリに変換されます。文字列は通常Erlang / OTP R13より前のようにバイトのリストではなく、文字のリストです。文字は通常バイトではなく、Unicodeコードポイントです。</target>
        </trans-unit>
        <trans-unit id="660019367304634239f33b92fdff61cb41611c83" translate="yes" xml:space="preserve">
          <source>Only if the server is in the confirmed commit phase, the configuration is restored to its state before entering the confirmed commit phase. Otherwise, no configuration rollback is performed.</source>
          <target state="translated">サーバが確認済みコミットフェーズにある場合にのみ、確認済みコミットフェーズに入る前の状態に構成が復元されます。それ以外の場合は、構成のロールバックは行われません。</target>
        </trans-unit>
        <trans-unit id="cbd2fd09cd558a21021b0e71892ab5c5ffaa9a70" translate="yes" xml:space="preserve">
          <source>Only matters for matching and when the type is &lt;code&gt;integer&lt;/code&gt;. The default is &lt;code&gt;unsigned&lt;/code&gt;.</source>
          <target state="translated">マッチングと型が &lt;code&gt;integer&lt;/code&gt; 場合のみ重要です。デフォルトは &lt;code&gt;unsigned&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="2ac47075244f080582d68564475ba1c72e44655e" translate="yes" xml:space="preserve">
          <source>Only modules compiled with option &lt;code&gt;debug_info&lt;/code&gt; set can be interpreted. Non-interpretable modules are displayed within parenthesis in the Interpret Modules window.</source>
          <target state="translated">オプション &lt;code&gt;debug_info&lt;/code&gt; を設定してコンパイルされたモジュールのみが解釈できます。解釈不可能なモジュールは、[モジュールの解釈]ウィンドウの括弧内に表示されます。</target>
        </trans-unit>
        <trans-unit id="2d63c1fd79def5aea280eb8e5551a9a4f8acf4ef" translate="yes" xml:space="preserve">
          <source>Only on 64-bit halfword emulator. The total amount of memory allocated in low memory areas that are restricted to &amp;lt; 4 GB, although the system can have more memory.</source>
          <target state="translated">64ビットハーフワードエミュレータのみ。システムはより多くのメモリを搭載できますが、4 GB未満に制限されている低メモリ領域に割り当てられたメモリの総量。</target>
        </trans-unit>
        <trans-unit id="f8b4dc2954832ab8284b54f1deee60e8ee9f12e3" translate="yes" xml:space="preserve">
          <source>Only one &lt;code&gt;MonitorOption&lt;/code&gt; can be specified. It is one of the following:</source>
          <target state="translated">指定できる &lt;code&gt;MonitorOption&lt;/code&gt; は1つだけです。次のいずれかです。</target>
        </trans-unit>
        <trans-unit id="16b381e1eb19d06546da0fffa061890639f875ed" translate="yes" xml:space="preserve">
          <source>Only one byte long and only two bits are significant, the rest must be 0.</source>
          <target state="translated">長さは1バイトのみで、2ビットのみが有効で、残りは0でなければなりません。</target>
        </trans-unit>
        <trans-unit id="e1021bb495145f4a605a8bf15b6c7510ce41d42c" translate="yes" xml:space="preserve">
          <source>Only one copy of T exists on the heap and during the garbage collection only the first time T is encountered will it be copied.</source>
          <target state="translated">T のコピーはヒープ上に 1 つだけ存在し、ガベージコレクションの間、T が最初に遭遇した時だけコピーされます。</target>
        </trans-unit>
        <trans-unit id="d1d25510eb44623309c6a466f80982b971e3a79b" translate="yes" xml:space="preserve">
          <source>Only one entry of this type is allowed.</source>
          <target state="translated">このタイプのエントリは1つだけ許可されています。</target>
        </trans-unit>
        <trans-unit id="2f8db1c5a163c86ad59a6d1922863061872c37b3" translate="yes" xml:space="preserve">
          <source>Only one table is loaded by &lt;code&gt;&lt;a href=&quot;mnesia#force_load_table-1&quot;&gt;mnesia:force_load_table(Tab)&lt;/a&gt;&lt;/code&gt;. Since committed transactions can have caused updates in several tables, the tables can become inconsistent because of the forced load.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mnesia#force_load_table-1&quot;&gt;mnesia:force_load_table(Tab)&lt;/a&gt;&lt;/code&gt; によって読み込まれるテーブルは1つだけです。コミットされたトランザクションはいくつかのテーブルで更新を引き起こす可能性があるため、強制ロードのためにテーブルが不整合になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="203a271e69e1e6f8cf93e61cb78904664002dc4b" translate="yes" xml:space="preserve">
          <source>Only some default values have been presented here. For information about the currently used settings and the current status of the allocators, see &lt;code&gt; erlang:system_info(allocator)&lt;/code&gt; and &lt;code&gt; erlang:system_info({allocator, Alloc})&lt;/code&gt;.</source>
          <target state="translated">ここでは、一部のデフォルト値のみを示しています。現在使用されている設定とアロケーターの現在のステータスについては、 &lt;code&gt; erlang:system_info(allocator)&lt;/code&gt; および &lt;code&gt; erlang:system_info({allocator, Alloc})&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e92ee7eb3618038b399f136fb76be40e18e1bc01" translate="yes" xml:space="preserve">
          <source>Only some default values have been presented here. For information about the currently used settings and the current status of the allocators, see &lt;code&gt;erlang:system_info(allocator)&lt;/code&gt; and &lt;code&gt;erlang:system_info({allocator, Alloc})&lt;/code&gt;.</source>
          <target state="translated">ここでは、いくつかのデフォルト値のみが示されています。現在使用されている設定とアロケータの現在のステータスについては、 &lt;code&gt;erlang:system_info(allocator)&lt;/code&gt; および &lt;code&gt;erlang:system_info({allocator, Alloc})&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="17e89dc2513b107dcc6a0275a1a3c98d68b4387b" translate="yes" xml:space="preserve">
          <source>Only support running Cover on the local node. This function must be called before any modules have been compiled or any nodes added. When running in this mode, modules will be Cover compiled in a more efficient way, but the resulting code will only work on the same node they were compiled on.</source>
          <target state="translated">ローカルノードでの Cover の実行のみをサポートします。この関数は、モジュールがコンパイルされたりノードが追加されたりする前に呼び出す必要があります。このモードで実行すると、モジュールはより効率的な方法で Cover がコンパイルされますが、結果として得られるコードはコンパイルされたのと同じノード上でのみ動作します。</target>
        </trans-unit>
        <trans-unit id="39e55a508bb5366d1ba41f1b8cc19d785d5f6e26" translate="yes" xml:space="preserve">
          <source>Only supported if ERTS was compiled with zlib &amp;gt;= 1.2.8.</source>
          <target state="translated">ERTSがzlib&amp;gt; = 1.2.8でコンパイルされている場合にのみサポートされます。</target>
        </trans-unit>
        <trans-unit id="e0c3b6c96d4a056b1891213af8fe63652b6f147a" translate="yes" xml:space="preserve">
          <source>Only supported when the &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#DFLAG_SPAWN&quot;&gt;DFLAG_SPAWN&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;erl_dist_protocol#dflags&quot;&gt;distribution flag&lt;/a&gt;&lt;/code&gt; has been passed.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;erl_dist_protocol#DFLAG_SPAWN&quot;&gt;DFLAG_SPAWN&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#dflags&quot;&gt;distribution flag&lt;/a&gt;&lt;/code&gt; が渡された場合にのみサポートされます。</target>
        </trans-unit>
        <trans-unit id="1405eb7cb56be68779595f26b14d02a57896c6d6" translate="yes" xml:space="preserve">
          <source>Only the DEFLATE (zlib-compression) and the STORE (uncompressed data) zip methods are supported.</source>
          <target state="translated">DEFLATE (zlib-compression)と STORE (非圧縮データ)の zip メソッドのみがサポートされています。</target>
        </trans-unit>
        <trans-unit id="be533a124805e79fe90a76852bcb557c73fc2e89" translate="yes" xml:space="preserve">
          <source>Only the Erlang process that opened the file can use it.</source>
          <target state="translated">ファイルを開いたErlangプロセスだけがそれを使うことができます。</target>
        </trans-unit>
        <trans-unit id="eff26c5132f4e18c3af8859f76e7ae06eef0123a" translate="yes" xml:space="preserve">
          <source>Only the currently connected job can 'talk' to the shell.</source>
          <target state="translated">現在接続されているジョブだけがシェルと「対話」することができます。</target>
        </trans-unit>
        <trans-unit id="a03597ea953bd3b370af7ca4b5066ffbc33977b3" translate="yes" xml:space="preserve">
          <source>Only the first captured subpattern, which is always the complete matching part of the subject. All explicitly captured subpatterns are discarded.</source>
          <target state="translated">最初にキャプチャされたサブパターンのみが対象であり、それは常に対象の完全一致部分である。明示的にキャプチャされたサブパターンはすべて破棄されます。</target>
        </trans-unit>
        <trans-unit id="b70de51c32ae79e58749256bc1925f2b5088935f" translate="yes" xml:space="preserve">
          <source>Only the following metacharacters are recognized in character classes:</source>
          <target state="translated">文字クラスでは、以下のメタキャラクタのみが認識されます。</target>
        </trans-unit>
        <trans-unit id="f8c7ec7f774783186ec033a3872a8ed95ec657d5" translate="yes" xml:space="preserve">
          <source>Only the owner process can read or write to the table.</source>
          <target state="translated">オーナープロセスのみがテーブルの読み書きを行うことができます。</target>
        </trans-unit>
        <trans-unit id="ae72d9870b541f6e2a7d88226bfd5d4e90663a8e" translate="yes" xml:space="preserve">
          <source>Only the process registered as distribution controller for the distribution channel identified by &lt;code&gt;DHandle&lt;/code&gt; is allowed to call this function unless an alternate input handler process has been registered using &lt;code&gt;&lt;a href=&quot;erlang#dist_ctrl_input_handler-2&quot;&gt;erlang:dist_ctrl_input_handler(DHandle, InputHandler)&lt;/a&gt;&lt;/code&gt;. If an alternate input handler has been registered, only the registered input handler process is allowed to call this function.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;erlang#dist_ctrl_input_handler-2&quot;&gt;erlang:dist_ctrl_input_handler(DHandle, InputHandler)&lt;/a&gt;&lt;/code&gt; を使用して代替入力ハンドラプロセスが登録されていない限り、 &lt;code&gt;DHandle&lt;/code&gt; によって識別される配布チャネルの配布コントローラとして登録されているプロセスのみがこの関数を呼び出すことができます。代替入力ハンドラーが登録されている場合、登録された入力ハンドラープロセスのみがこの関数を呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="0120f9c54ff86c06696b34a4219af2378345acdb" translate="yes" xml:space="preserve">
          <source>Only the process registered as distribution controller for the distribution channel identified by &lt;code&gt;DHandle&lt;/code&gt; is allowed to call this function.</source>
          <target state="translated">&lt;code&gt;DHandle&lt;/code&gt; によって識別される配布チャネルの配布コントローラーとして登録されているプロセスのみが、この関数を呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="97a2d2b2787c40ce488cca6bc1ab1989c6ad75b7" translate="yes" xml:space="preserve">
          <source>Only the process that created the digraph is allowed to update it.</source>
          <target state="translated">ディグラフを作成したプロセスのみが更新を許可されます。</target>
        </trans-unit>
        <trans-unit id="ff7ef46b3f7713cb10f8c8f5e86db36f63612540" translate="yes" xml:space="preserve">
          <source>Only the specified part is searched. Return values still have offsets from the beginning of &lt;code&gt;Subject&lt;/code&gt;. A negative &lt;code&gt;Length&lt;/code&gt; is allowed as described in section Data Types in this manual.</source>
          <target state="translated">指定された部分のみを検索します。戻り値には、引き続き &lt;code&gt;Subject&lt;/code&gt; の先頭からのオフセットがあります。このマニュアルのセクションデータ型で説明されているように、負の &lt;code&gt;Length&lt;/code&gt; は許可されます。</target>
        </trans-unit>
        <trans-unit id="92b1c560a3c609b6630ba6369a93d7159051e3e5" translate="yes" xml:space="preserve">
          <source>Only these exact character sequences are recognized. A sequence such as [a[:&amp;lt;:]b] provokes error for an unrecognized POSIX class name. This support is not compatible with Perl. It is provided to help migrations from other environments, and is best not used in any new patterns. Note that \b matches at the start and the end of a word (see &quot;Simple assertions&quot; above), and in a Perl-style pattern the preceding or following character normally shows which is wanted, without the need for the assertions that are used above in order to give exactly the POSIX behaviour.</source>
          <target state="translated">これらの正確な文字シーケンスのみが認識されます。[a [：&amp;lt;：] b]などのシーケンスは、認識されないPOSIXクラス名に対してエラーを引き起こします。このサポートはPerlと互換性がありません。他の環境からの移行を支援するために提供されており、新しいパターンでは使用しないことをお勧めします。\ bは単語の最初と最後に一致し（上記の「単純なアサーション」を参照）、Perlスタイルのパターンでは、前または後ろの文字は通常、使用するアサーションの必要なしに、必要なものを示します。上記は、POSIXの動作を正確に示すためです。</target>
        </trans-unit>
        <trans-unit id="17d1fba9658ded214a434ab7601d513e4c6c5aaf" translate="yes" xml:space="preserve">
          <source>Only total</source>
          <target state="translated">合計のみ</target>
        </trans-unit>
        <trans-unit id="b466165e837dbf10eadb47e4bc9b893d7bb50387" translate="yes" xml:space="preserve">
          <source>Only trace messages from a specific process &lt;code&gt;Pid&lt;/code&gt;:</source>
          <target state="translated">特定のプロセスからのメッセージのみをトレースします &lt;code&gt;Pid&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e5bfc32b55921a00a28f4c0d1a74dc4ff5f9f2ba" translate="yes" xml:space="preserve">
          <source>Only trace messages from other nodes:</source>
          <target state="translated">他のノードからのメッセージのみをトレースします。</target>
        </trans-unit>
        <trans-unit id="78247ecb104811399c3277cdd7d4c731768a72b0" translate="yes" xml:space="preserve">
          <source>Only trace messages matching &lt;code&gt;{reply, _}&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;{reply, _}&lt;/code&gt; 一致するメッセージのみをトレースします。</target>
        </trans-unit>
        <trans-unit id="7666550505039a9e83e909935389e4f3ca8ed6d8" translate="yes" xml:space="preserve">
          <source>Only trace messages sent to other nodes:</source>
          <target state="translated">他のノードに送信されたメッセージのみをトレースします。</target>
        </trans-unit>
        <trans-unit id="550dd65f9f1635f5b26d39adb415360c2a92434a" translate="yes" xml:space="preserve">
          <source>Only trace messages sent to the sender itself:</source>
          <target state="translated">送信者自身に送信されたメッセージのみをトレースします。</target>
        </trans-unit>
        <trans-unit id="2500bda55ee606fa893cbad9220ec886375e6705" translate="yes" xml:space="preserve">
          <source>Only trace messages to a specific process &lt;code&gt;Pid&lt;/code&gt;:</source>
          <target state="translated">特定のプロセス &lt;code&gt;Pid&lt;/code&gt; へのメッセージのみをトレースします。</target>
        </trans-unit>
        <trans-unit id="42b574e1ef29bfa437b36acb9027769673eb223a" translate="yes" xml:space="preserve">
          <source>Only two arguments, of which one must be &lt;code&gt;true&lt;/code&gt; and the other &lt;code&gt;false&lt;/code&gt; to return &lt;code&gt;true&lt;/code&gt;; otherwise &lt;code&gt;'xor'&lt;/code&gt; returns false.</source>
          <target state="translated">2つだけの引数、1がでなければならないの &lt;code&gt;true&lt;/code&gt; 及びその他の &lt;code&gt;false&lt;/code&gt; を返すように &lt;code&gt;true&lt;/code&gt; 。それ以外の場合、 &lt;code&gt;'xor'&lt;/code&gt; はfalseを返します。</target>
        </trans-unit>
        <trans-unit id="a84b39b2c86b869fad86343fd9fef89839964e4b" translate="yes" xml:space="preserve">
          <source>Only use these flags if you are sure what you are doing. Unsuitable settings can cause serious performance degradation and even a system crash at any time during operation.</source>
          <target state="translated">これらのフラグは、何をしているのか確信がある場合にのみ使用してください。不適切な設定は、操作中にいつでも深刻なパフォーマンス低下やシステムクラッシュを引き起こす可能性があります。</target>
        </trans-unit>
        <trans-unit id="4d7818114df4175719fb624ea7ed7fe90002e953" translate="yes" xml:space="preserve">
          <source>Only used during handshake phase.</source>
          <target state="translated">握手の段階でのみ使用されます。</target>
        </trans-unit>
        <trans-unit id="63f8061fc22c121f41217cd28e783b48e49934d5" translate="yes" xml:space="preserve">
          <source>Only valid for &lt;code&gt;{spawn, Command}&lt;/code&gt; and &lt;code&gt;{spawn_executable, FileName}&lt;/code&gt;. It allows the standard input and output (file descriptors 0 and 1) of the spawned (Unix) process for communication with Erlang.</source>
          <target state="translated">&lt;code&gt;{spawn, Command}&lt;/code&gt; および &lt;code&gt;{spawn_executable, FileName}&lt;/code&gt; に対してのみ有効です。これは、Erlangとの通信のために生成された（Unix）プロセスの標準入出力（ファイル記述子0および1）を許可します。</target>
        </trans-unit>
        <trans-unit id="18c2212e127b0c910798dbbf1d59d9d69e12fd4b" translate="yes" xml:space="preserve">
          <source>Only valid for &lt;code&gt;{spawn, Command}&lt;/code&gt; and &lt;code&gt;{spawn_executable, FileName}&lt;/code&gt;. The external program starts using &lt;code&gt;Dir&lt;/code&gt; as its working directory. &lt;code&gt;Dir&lt;/code&gt; must be a string.</source>
          <target state="translated">&lt;code&gt;{spawn, Command}&lt;/code&gt; および &lt;code&gt;{spawn_executable, FileName}&lt;/code&gt; に対してのみ有効です。外部プログラムは、 &lt;code&gt;Dir&lt;/code&gt; を作業ディレクトリとして使用し始めます。 &lt;code&gt;Dir&lt;/code&gt; は文字列でなければなりません。</target>
        </trans-unit>
        <trans-unit id="65484a01cf9bd6e1a83ae6b606310e1c69ff32cf" translate="yes" xml:space="preserve">
          <source>Only valid for &lt;code&gt;{spawn, Command}&lt;/code&gt;, and &lt;code&gt;{spawn_executable, FileName}&lt;/code&gt;. The environment of the started process is extended using the environment specifications in &lt;code&gt;Env&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{spawn, Command}&lt;/code&gt; 、および &lt;code&gt;{spawn_executable, FileName}&lt;/code&gt; に対してのみ有効です。開始されたプロセスの環境は、 &lt;code&gt;Env&lt;/code&gt; の環境仕様を使用して拡張されます。</target>
        </trans-unit>
        <trans-unit id="bfc9b2e1dea6a04ba983a9e94d3b648b00ca026f" translate="yes" xml:space="preserve">
          <source>Only valid for &lt;code&gt;{spawn, Command}&lt;/code&gt;, where &lt;code&gt;Command&lt;/code&gt; refers to an external program, and for &lt;code&gt;{spawn_executable, FileName}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{spawn, Command}&lt;/code&gt; 場合にのみ有効です。ここで、 &lt;code&gt;Command&lt;/code&gt; は外部プログラムを指し、 &lt;code&gt;{spawn_executable, FileName}&lt;/code&gt; 場合に有効です。</target>
        </trans-unit>
        <trans-unit id="ec0538decd2a683ac3d4fc85b7551d506a0ba696" translate="yes" xml:space="preserve">
          <source>Only valid for &lt;code&gt;{spawn_executable, FileName}&lt;/code&gt; and explicitly specifies the program name argument when running an executable. This can in some circumstances, on some OSs, be desirable. How the program responds to this is highly system-dependent and no specific effect is guaranteed.</source>
          <target state="translated">&lt;code&gt;{spawn_executable, FileName}&lt;/code&gt; に対してのみ有効であり、実行可能ファイルの実行時にプログラム名引数を明示的に指定します。これは、状況によっては、OSによっては望ましい場合があります。プログラムがこれにどのように応答するかはシステムに大きく依存し、特定の効果は保証されません。</target>
        </trans-unit>
        <trans-unit id="94d77dba770e4fddcd3e5b235704abc55a41a06f" translate="yes" xml:space="preserve">
          <source>Only valid for &lt;code&gt;{spawn_executable, FileName}&lt;/code&gt; and specifies arguments to the executable. Each argument is specified as a separate string and (on Unix) eventually ends up as one element each in the argument vector. On other platforms, a similar behavior is mimicked.</source>
          <target state="translated">&lt;code&gt;{spawn_executable, FileName}&lt;/code&gt; に対してのみ有効であり、実行可能ファイルへの引数を指定します。各引数は個別の文字列として指定され、（Unixでは）最終的には引数ベクトルのそれぞれ1つの要素になります。他のプラットフォームでは、同様の動作が模倣されます。</target>
        </trans-unit>
        <trans-unit id="0a16a27763d86648c52acb4eb9a028a14f39f822" translate="yes" xml:space="preserve">
          <source>Only valid for character devices on Unix. In all other cases, this field is zero.</source>
          <target state="translated">Unix上の文字デバイスでのみ有効です。それ以外のすべての場合、このフィールドはゼロです。</target>
        </trans-unit>
        <trans-unit id="7fc2cb0a3d19c899c55c3af5cabac685a4c4024f" translate="yes" xml:space="preserve">
          <source>Opaque continuation used by &lt;code&gt;&lt;a href=&quot;#bchunk-2&quot;&gt; bchunk/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#bchunk-2&quot;&gt; bchunk/2&lt;/a&gt;&lt;/code&gt; で使用される不透明な継続。</target>
        </trans-unit>
        <trans-unit id="ecb3f031c9ac0eb9d790e14595d3fd9dd2d8d7c2" translate="yes" xml:space="preserve">
          <source>Opaque continuation used by &lt;code&gt;&lt;a href=&quot;#bchunk-2&quot;&gt;bchunk/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#bchunk-2&quot;&gt;bchunk/2&lt;/a&gt;&lt;/code&gt; で使用される不透明な継続。</target>
        </trans-unit>
        <trans-unit id="44042d084e920dd3dc985ac504cefdc2ed892dbe" translate="yes" xml:space="preserve">
          <source>Opaque continuation used by &lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt; match/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#match-3&quot;&gt; match/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt; match/1&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;#match-3&quot;&gt; match/3&lt;/a&gt;&lt;/code&gt; で使用される不透明な継続。</target>
        </trans-unit>
        <trans-unit id="58a550d32afdec41a5ce24c62d98873272eb328a" translate="yes" xml:space="preserve">
          <source>Opaque continuation used by &lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt;match/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#match-3&quot;&gt;match/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt;match/1&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;#match-3&quot;&gt;match/3&lt;/a&gt;&lt;/code&gt; で使用される不透明な継続。</target>
        </trans-unit>
        <trans-unit id="2e13e6d3aa42a811de64c1e467938899f3dce98a" translate="yes" xml:space="preserve">
          <source>Opaque continuation used by &lt;code&gt;&lt;a href=&quot;#match_object-1&quot;&gt; match_object/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#match_object-3&quot;&gt;match_object/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#match_object-1&quot;&gt; match_object/1&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;#match_object-3&quot;&gt;match_object/3&lt;/a&gt;&lt;/code&gt; で使用される不透明な継続。</target>
        </trans-unit>
        <trans-unit id="296b6181394c8bc2ef4aa069b7cdea56b08954fb" translate="yes" xml:space="preserve">
          <source>Opaque continuation used by &lt;code&gt;&lt;a href=&quot;#match_object-1&quot;&gt;match_object/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#match_object-3&quot;&gt;match_object/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#match_object-1&quot;&gt;match_object/1&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;#match_object-3&quot;&gt;match_object/3&lt;/a&gt;&lt;/code&gt; によって使用される不透明な継続。</target>
        </trans-unit>
        <trans-unit id="9a762205d0a7ee19acfd273d7e78b6398592b6bb" translate="yes" xml:space="preserve">
          <source>Opaque continuation used by &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt; select/1,3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#select_reverse-1&quot;&gt; select_reverse/1,3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt; match/1,3&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#match_object-1&quot;&gt; match_object/1,3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt; select/1,3&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;#select_reverse-1&quot;&gt; select_reverse/1,3&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt; match/1,3&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;#match_object-1&quot;&gt; match_object/1,3&lt;/a&gt;&lt;/code&gt; によって使用される不透明な継続。</target>
        </trans-unit>
        <trans-unit id="d97c71bb917f1db11558c4c9a89e12c4b7ed4b54" translate="yes" xml:space="preserve">
          <source>Opaque continuation used by &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt; select/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#select-3&quot;&gt; select/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt; select/1&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;#select-3&quot;&gt; select/3&lt;/a&gt;&lt;/code&gt; で使用される不透明な継続。</target>
        </trans-unit>
        <trans-unit id="2dfa868a6d8928ac7bb58be05cada3f714825ced" translate="yes" xml:space="preserve">
          <source>Opaque continuation used by &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1,3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#select_reverse-1&quot;&gt;select_reverse/1,3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt;match/1,3&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#match_object-1&quot;&gt;match_object/1,3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1,3&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;#select_reverse-1&quot;&gt;select_reverse/1,3&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;#match-1&quot;&gt;match/1,3&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;#match_object-1&quot;&gt;match_object/1,3&lt;/a&gt;&lt;/code&gt; によって使用される不透明な継続。</target>
        </trans-unit>
        <trans-unit id="403f4b382799774e589923264bc2680b24377bd7" translate="yes" xml:space="preserve">
          <source>Opaque continuation used by &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#select-3&quot;&gt;select/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;#select-3&quot;&gt;select/3&lt;/a&gt;&lt;/code&gt; で使用される不透明な継続。</target>
        </trans-unit>
        <trans-unit id="0fd3a4cc67ebb2e2dcfc37bc089269155adc35e9" translate="yes" xml:space="preserve">
          <source>Opaque data type containing a compiled regular expression. &lt;code&gt;mp()&lt;/code&gt; is guaranteed to be a tuple() having the atom &lt;code&gt;re_pattern&lt;/code&gt; as its first element, to allow for matching in guards. The arity of the tuple or the content of the other fields can change in future Erlang/OTP releases.</source>
          <target state="translated">コンパイルされた正規表現を含む不透明なデータ型。 &lt;code&gt;mp()&lt;/code&gt; は、最初の要素としてアトム &lt;code&gt;re_pattern&lt;/code&gt; を持つtuple（）であることが保証されており、ガードでのマッチングを可能にします。タプルのアリティまたは他のフィールドの内容は、将来のErlang / OTPリリースで変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="3073e10d40e31139c377d2037ae18a50d90f1eba" translate="yes" xml:space="preserve">
          <source>Opaque data type representing a C-node. A &lt;code&gt;ei_cnode&lt;/code&gt; structure is initialized by calling &lt;code&gt;&lt;a href=&quot;#ei_connect_init&quot;&gt;ei_connect_init()&lt;/a&gt;&lt;/code&gt; or friends.</source>
          <target state="translated">Cノードを表す不透明（OPAQUE）データ型。 &lt;code&gt;ei_cnode&lt;/code&gt; の構造を呼び出すことによって初期化され &lt;code&gt;&lt;a href=&quot;#ei_connect_init&quot;&gt;ei_connect_init()&lt;/a&gt;&lt;/code&gt; や友人を。</target>
        </trans-unit>
        <trans-unit id="23206d19a217e18d8ba3621938088efa39a69154" translate="yes" xml:space="preserve">
          <source>Opaque data type representing a channel inside a connection.</source>
          <target state="translated">接続内のチャネルを表す不透明なデータ型。</target>
        </trans-unit>
        <trans-unit id="10ef7cb1f64bbdc10f27d8dc1ce5e8006717e4e1" translate="yes" xml:space="preserve">
          <source>Opaque data type representing a compiled search pattern. Guaranteed to be a &lt;code&gt;tuple()&lt;/code&gt; to allow programs to distinguish it from non-precompiled search patterns.</source>
          <target state="translated">コンパイルされた検索パターンを表す不透明なデータ型。プログラムが &lt;code&gt;tuple()&lt;/code&gt; であることを保証し、プログラムがプリコンパイルされていない検索パターンと区別できるようにします。</target>
        </trans-unit>
        <trans-unit id="11a89fac909edd47d58426bf26b171a05bcc5425" translate="yes" xml:space="preserve">
          <source>Opaque data type representing a connection between a client and a server (daemon).</source>
          <target state="translated">クライアントとサーバ(デーモン)間の接続を表す不透明なデータ型。</target>
        </trans-unit>
        <trans-unit id="620b0b7f87aa05da3ff0439d717021eb8fe8e602" translate="yes" xml:space="preserve">
          <source>Opaque data type representing a daemon.</source>
          <target state="translated">デーモンを表す不透明なデータ型。</target>
        </trans-unit>
        <trans-unit id="782b9c52a05275a07fdb0325126b76a41e598067" translate="yes" xml:space="preserve">
          <source>Opaque data type representing an Erlang fun.</source>
          <target state="translated">Erlang funを表す不透明なデータ型。</target>
        </trans-unit>
        <trans-unit id="4927f104d4050e4e82f5e9b926c4785a9a6cd617" translate="yes" xml:space="preserve">
          <source>Opaque data type representing an Erlang port identifier.</source>
          <target state="translated">Erlangのポート識別子を表す不透明なデータ型。</target>
        </trans-unit>
        <trans-unit id="b351d1987076f1dc291eddcbafd24ab67c9d0ca9" translate="yes" xml:space="preserve">
          <source>Opaque data type representing an Erlang process identifier.</source>
          <target state="translated">Erlangのプロセス識別子を表す不透明なデータ型。</target>
        </trans-unit>
        <trans-unit id="6eb071ca2ae242d99f495914ddf8221680ce181d" translate="yes" xml:space="preserve">
          <source>Opaque data type representing an Erlang reference.</source>
          <target state="translated">Erlangの参照を表す不透明なデータ型。</target>
        </trans-unit>
        <trans-unit id="70e1f3ab4b5c65c16968a9846c8960065afe6262" translate="yes" xml:space="preserve">
          <source>Opaque data type representing an Erlang sequential trace token.</source>
          <target state="translated">Erlangのシーケンシャルトレーストークンを表す不透明なデータ型。</target>
        </trans-unit>
        <trans-unit id="3857ec812333e693713ca05fedf452c8c2760e48" translate="yes" xml:space="preserve">
          <source>Opaque reference for a connection to a NETCONF server or a NETCONF session.</source>
          <target state="translated">NETCONF サーバーまたは NETCONF セッションへの接続の不透明な参照。</target>
        </trans-unit>
        <trans-unit id="1ad02c5216bfba2278b495045671c8cc585c4d19" translate="yes" xml:space="preserve">
          <source>Opaque send handle whose contents is internal for the send module. May be any term.</source>
          <target state="translated">不透明な送信ハンドルで、その内容は送信モジュールの内部にあります。任意の項を指定することができます。</target>
        </trans-unit>
        <trans-unit id="107ba6e41ccc6092a0776c13b1c83f0f2e14171a" translate="yes" xml:space="preserve">
          <source>Opaque types that define experimental options that are not to be used in products.</source>
          <target state="translated">製品に使用しない実験的なオプションを定義する不透明タイプ。</target>
        </trans-unit>
        <trans-unit id="7587b20d7be0af5fefb7a8ee2c09b36a8bb78350" translate="yes" xml:space="preserve">
          <source>Opaque value returned by &lt;code&gt;&lt;a href=&quot;#async_call-4&quot;&gt;async_call/4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#async_call-4&quot;&gt;async_call/4&lt;/a&gt;&lt;/code&gt; によって返される不透明な値。</target>
        </trans-unit>
        <trans-unit id="3550457d3cea02f68e91830d6b92589beceb0ac2" translate="yes" xml:space="preserve">
          <source>Open Database Connectivity (ODBC) is a Microsoft standard for accessing relational databases that has become widely used. The ODBC standard provides a c-level application programming interface (API) for database access. It uses Structured Query Language (SQL) as its database access language.</source>
          <target state="translated">Open Database Connectivity(ODBC)は、リレーショナルデータベースにアクセスするためのMicrosoftの標準規格であり、広く利用されるようになった。ODBC標準は、データベースアクセスのためのcレベルのアプリケーションプログラミングインターフェース(API)を提供します。データベースアクセス言語として構造化クエリ言語 (SQL)を使用しています。</target>
        </trans-unit>
        <trans-unit id="8082c8186bf5acfdb929e31ffd3d59546e0c666b" translate="yes" xml:space="preserve">
          <source>Open an SSH connection to a named NETCONF server.</source>
          <target state="translated">名前のついたNETCONFサーバにSSH接続を開きます。</target>
        </trans-unit>
        <trans-unit id="ee2771cae64f2d66b96c7d0fdeb3a995d3b00a84" translate="yes" xml:space="preserve">
          <source>Open files and sockets</source>
          <target state="translated">ファイルとソケットを開く</target>
        </trans-unit>
        <trans-unit id="c2f3ad251a3411a0d3096b7d62ceb15282d3c92b" translate="yes" xml:space="preserve">
          <source>Open ports</source>
          <target state="translated">オープンポート</target>
        </trans-unit>
        <trans-unit id="d5d9049df9a69941f4ebda406f0f9058d7b67428" translate="yes" xml:space="preserve">
          <source>Open punctuation</source>
          <target state="translated">開いた句読点</target>
        </trans-unit>
        <trans-unit id="01b42cf5dcb6fdd0a783f67c992975adaac86c1d" translate="yes" xml:space="preserve">
          <source>OpenSSH Public-Key Format</source>
          <target state="translated">OpenSSH 公開鍵形式</target>
        </trans-unit>
        <trans-unit id="0f83435c5ff89a01a4392cfcdc0fce03d20e7bcf" translate="yes" xml:space="preserve">
          <source>OpenSSH public-key format looks as follows:</source>
          <target state="translated">OpenSSH の公開鍵の形式は以下のようになります。</target>
        </trans-unit>
        <trans-unit id="3962fc8d7cfd8504f9f8a80c8b447972c82afbc5" translate="yes" xml:space="preserve">
          <source>OpenSSL (optional) You need this to build crypto, ssh and ssl libs.</source>
          <target state="translated">OpenSSL (オプション)crypto,ssh,ssl の libs を構築するために必要です。</target>
        </trans-unit>
        <trans-unit id="78a8e32789179af6e9a1ec19eccc362f6f09476e" translate="yes" xml:space="preserve">
          <source>OpenSSL -- The opensource toolkit for Secure Socket Layer and Transport Layer Security. Required for building the application &lt;code&gt;crypto&lt;/code&gt;. Further, &lt;code&gt;ssl&lt;/code&gt; and &lt;code&gt;ssh&lt;/code&gt; require a working crypto application and will also be skipped if OpenSSL is missing. The &lt;code&gt;public_key&lt;/code&gt; application is available without &lt;code&gt;crypto&lt;/code&gt;, but the functionality will be very limited.</source>
          <target state="translated">OpenSSL-Secure Socket LayerおよびTransport Layer Security用のオープンソースツールキット。アプリケーション &lt;code&gt;crypto&lt;/code&gt; を構築するために必要です。さらに、 &lt;code&gt;ssl&lt;/code&gt; と &lt;code&gt;ssh&lt;/code&gt; には有効な暗号アプリケーションが必要であり、OpenSSLがない場合もスキップされます。 &lt;code&gt;public_key&lt;/code&gt; アプリケーションはせずに利用され &lt;code&gt;crypto&lt;/code&gt; が、機能は非常に制限されます。</target>
        </trans-unit>
        <trans-unit id="f9ba88f6151c1d4c39311034d5740f6813c1bb3d" translate="yes" xml:space="preserve">
          <source>OpenSSL can be built to provide FIPS 140-2 validated cryptographic services. It is not the OpenSSL application that is validated, but a special software component called the OpenSSL FIPS Object Module. However applications do not use this Object Module directly, but through the regular API of the OpenSSL library.</source>
          <target state="translated">OpenSSL は、FIPS 140-2 で検証された暗号化サービスを提供するために構築することができます。検証されるのは OpenSSL アプリケーションではなく、OpenSSL FIPS オブジェクトモジュールと呼ばれる特別なソフトウェアコンポーネントです。ただし、アプリケーションはこのオブジェクトモジュールを直接使用するのではなく、OpenSSL ライブラリの通常の API を介して使用します。</target>
        </trans-unit>
        <trans-unit id="ec75c958bae528f688b7acd8013d185972516f61" translate="yes" xml:space="preserve">
          <source>OpenSSL exposes an Engine API, which makes it possible to plug in alternative implementations for some or all of the cryptographic operations implemented by OpenSSL. When configured appropriately, OpenSSL calls the engine's implementation of these operations instead of its own.</source>
          <target state="translated">OpenSSL はエンジン API を公開しており、OpenSSL によって実装されている暗号化処理の一部または全部を代替の実装としてプラグインすることが可能です。適切に設定されている場合、OpenSSL はこれらの操作の代わりにエンジンの実装を呼び出します。</target>
        </trans-unit>
        <trans-unit id="23dcb6e17a0724721b52791ead27b1179856c026" translate="yes" xml:space="preserve">
          <source>OpenSSL handles these corner cases in FIPS mode, however the Erlang crypto and ssl applications are not prepared for them and therefore you are limited to TLS 1.2 in FIPS mode.</source>
          <target state="translated">OpenSSLはFIPSモードでこれらのコーナーケースを処理しますが、Erlangの暗号化とsslアプリケーションはこれらのケースに対応していないので、FIPSモードではTLS 1.2に制限されています。</target>
        </trans-unit>
        <trans-unit id="3a24b8124364457504f3d77d3e37c9aa2f092c8b" translate="yes" xml:space="preserve">
          <source>OpenSSL. This is if you want the SSL and crypto applications to compile (and run). There are prebuilt binaries, which you can just download and install, available here:</source>
          <target state="translated">OpenSSLです。これは、SSL と暗号化アプリケーションをコンパイル (と実行)したい場合に使用します。ここからダウンロードしてインストールすることができます。</target>
        </trans-unit>
        <trans-unit id="fc37c058118702102358b15e5a9279ede7fb88f0" translate="yes" xml:space="preserve">
          <source>OpenSource users can ask questions and share experiences on the &lt;a href=&quot;http://www.erlang.org/static/doc/mailinglist.html&quot;&gt; Erlang questions mailing list&lt;/a&gt;.</source>
          <target state="translated">オープンソースユーザーは、&lt;a href=&quot;http://www.erlang.org/static/doc/mailinglist.html&quot;&gt;Erlang質問メーリングリストで&lt;/a&gt;質問したり、経験を共有したりできます。</target>
        </trans-unit>
        <trans-unit id="9f59aad599af06a50017bc066f13ce93de0675e4" translate="yes" xml:space="preserve">
          <source>Opening a connection to the SUT</source>
          <target state="translated">SUTへの接続を開く</target>
        </trans-unit>
        <trans-unit id="16d19c8e7f51506cd01c5e4f542d05b716cdf852" translate="yes" xml:space="preserve">
          <source>Opening files with option &lt;code&gt;encoding&lt;/code&gt; is convenient when writing or reading text files in a known encoding.</source>
          <target state="translated">オプションの &lt;code&gt;encoding&lt;/code&gt; ファイルを開くと、既知のエンコーディングでテキストファイルを読み書きするときに便利です。</target>
        </trans-unit>
        <trans-unit id="67011158e86d9fe5da95333d965bcbbe99127074" translate="yes" xml:space="preserve">
          <source>Opening parentheses are counted from left to right (starting from 1) to obtain numbers for the capturing subpatterns. For example, if the string &quot;the red king&quot; is matched against the following pattern, the captured substrings are &quot;red king&quot;, &quot;red&quot;, and &quot;king&quot;, and are numbered 1, 2, and 3, respectively:</source>
          <target state="translated">開いている括弧は、左から右へ(1から始まる)カウントされ、キャプチャされた部分パターンの番号が得られる。例えば、&quot;the red king &quot;という文字列が以下のパターンにマッチした場合、捕捉される部分文字列は &quot;red king&quot;、&quot;red&quot;、&quot;king &quot;であり、それぞれ1、2、3の番号が付けられている。</target>
        </trans-unit>
        <trans-unit id="75588bb57f0a2ad5ebe6ca42cc40d8c3b6d3dc26" translate="yes" xml:space="preserve">
          <source>Opening square bracket (only when it can be interpreted as introducing a Posix class name, or for a special compatibility feature; see the next two sections)</source>
          <target state="translated">開いている大括弧(Posixクラス名を導入していると解釈できる場合、または特別な互換性機能のために解釈できる場合のみ。</target>
        </trans-unit>
        <trans-unit id="0a4914a57f284d13929c087c4e60d213c9577e76" translate="yes" xml:space="preserve">
          <source>Opens (creates) a registry, which initially is empty. To close the registry later, use &lt;code&gt;ei_reg_close()&lt;/code&gt;.</source>
          <target state="translated">最初は空のレジストリを開きます（作成します）。後でレジストリを閉じるには、 &lt;code&gt;ei_reg_close()&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="3b46d26782974b469a2ae782f58aa207429f253c" translate="yes" xml:space="preserve">
          <source>Opens a &lt;code&gt;&lt;a href=&quot;#view&quot;&gt;View Module window&lt;/a&gt;&lt;/code&gt;, displaying the contents of the selected module.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#view&quot;&gt;View Module window&lt;/a&gt;&lt;/code&gt; の表示]ウィンドウを開き、選択したモジュールの内容を表示します。</target>
        </trans-unit>
        <trans-unit id="22a4c7bdc761516d54977e6e3c2f08e31666a769" translate="yes" xml:space="preserve">
          <source>Opens a NETCONF session and exchanges &lt;code&gt;hello&lt;/code&gt; messages.</source>
          <target state="translated">NETCONFセッションを開き、 &lt;code&gt;hello&lt;/code&gt; メッセージを交換します。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
