<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="13185c544644b7f2a243ef918a03957be326a36d" translate="yes" xml:space="preserve">
          <source>Argument:</source>
          <target state="translated">Argument:</target>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="565865945dd4be2b94783c9b5e4f90518f12be80" translate="yes" xml:space="preserve">
          <source>Arguments &lt;code&gt;Format&lt;/code&gt; and &lt;code&gt;Args&lt;/code&gt; are used in a call to &lt;code&gt;io_lib:format/2&lt;/code&gt; to create the comment string. The behavior of &lt;code&gt;comment/2&lt;/code&gt; is otherwise the same as function &lt;code&gt;&lt;a href=&quot;#comment-1&quot;&gt;ct:comment/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">引数の &lt;code&gt;Format&lt;/code&gt; と &lt;code&gt;Args&lt;/code&gt; のはへの呼び出しで使用されている &lt;code&gt;io_lib:format/2&lt;/code&gt; コメント文字列を作成します。それ以外の場合、 &lt;code&gt;comment/2&lt;/code&gt; の動作は関数 &lt;code&gt;&lt;a href=&quot;#comment-1&quot;&gt;ct:comment/1&lt;/a&gt;&lt;/code&gt; と同じです。</target>
        </trans-unit>
        <trans-unit id="a0478ca5f4c068ca3ac12f9474f6a15865ce9053" translate="yes" xml:space="preserve">
          <source>Arguments:</source>
          <target state="translated">Arguments:</target>
        </trans-unit>
        <trans-unit id="a853cd0dac3624d36b7ac915686a7bf9b68613c0" translate="yes" xml:space="preserve">
          <source>Arithmetic bitshift left</source>
          <target state="translated">算術ビットシフト左</target>
        </trans-unit>
        <trans-unit id="09257e94fa407278a59602ea81c51ef19d845892" translate="yes" xml:space="preserve">
          <source>Arithmetic bitwise XOR</source>
          <target state="translated">算術ビットごとのXOR</target>
        </trans-unit>
        <trans-unit id="206db889fe395b01fcd9ea9b88e2747a6dbb4f32" translate="yes" xml:space="preserve">
          <source>Arithmetic expressions</source>
          <target state="translated">算術式</target>
        </trans-unit>
        <trans-unit id="296f27747464dfd4585fc68aca14b6147fb87a9b" translate="yes" xml:space="preserve">
          <source>Arithmetics: &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;div&lt;/code&gt;, &lt;code&gt;rem&lt;/code&gt;</source>
          <target state="translated">算術： &lt;code&gt;+&lt;/code&gt; 、 &lt;code&gt;-&lt;/code&gt; 、 &lt;code&gt;*&lt;/code&gt; 、 &lt;code&gt;div&lt;/code&gt; 、 &lt;code&gt;rem&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fdadcc41e499fbe0cbed3e778cd50052fc53c2be" translate="yes" xml:space="preserve">
          <source>Arity ::= Number | &lt;code&gt;-1&lt;/code&gt;</source>
          <target state="translated">アリティ:: =番号| &lt;code&gt;-1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1a0d21145500640fd3f6136eeba595bfe934d364" translate="yes" xml:space="preserve">
          <source>Armenian</source>
          <target state="translated">Armenian</target>
        </trans-unit>
        <trans-unit id="6c4709af989db804327c6ea436d6589b124f8253" translate="yes" xml:space="preserve">
          <source>Arranges documents horizontally or vertically, separated by whitespace. Returns a document representing two alternative layouts of the (nonempty) sequence &lt;code&gt;Docs&lt;/code&gt; of documents, such that either all elements in &lt;code&gt;Docs&lt;/code&gt; are concatenated horizontally, and separated by a space character, or all elements are concatenated vertically (without extra separation).</source>
          <target state="translated">ドキュメントを空白で区切って水平または垂直に配置します。（空でない）シーケンス &lt;code&gt;Docs&lt;/code&gt; 2つの代替レイアウトを表すドキュメントを返します内のすべての要素のいずれかのように、ドキュメントの、 &lt;code&gt;Docs&lt;/code&gt; 水平に連結し、空白文字で区切られた、またはすべての要素が（余分分離することなく）垂直方向に連結されています。</target>
        </trans-unit>
        <trans-unit id="cb6e8bc43bfadc15174aa7c7533ec25e49f627de" translate="yes" xml:space="preserve">
          <source>Arranges documents in a paragraph-like layout. Returns a document representing all possible left-aligned paragraph-like layouts of the (nonempty) sequence &lt;code&gt;Docs&lt;/code&gt; of documents. Elements in &lt;code&gt;Docs&lt;/code&gt; are separated horizontally by a single space character and vertically with a single line break. All lines following the first (if any) are indented to the same left column, whose indentation is specified by the optional &lt;code&gt;Offset&lt;/code&gt; parameter relative to the position of the first element in &lt;code&gt;Docs&lt;/code&gt;. For example, with an offset of -4, the following layout can be produced, for a list of documents representing the numbers 0 to 15:</source>
          <target state="translated">ドキュメントを段落のようなレイアウトで配置します。ドキュメントの（空でない）シーケンス &lt;code&gt;Docs&lt;/code&gt; のすべての可能な左揃えの段落のようなレイアウトを表すドキュメントを返します。 &lt;code&gt;Docs&lt;/code&gt; 要素は、1つのスペース文字で水平方向に区切られ、1つの改行で垂直方向に区切られます。最初の行（ある場合）に続くすべての行は、同じ左の列にインデントされます。そのインデントは、オプションの &lt;code&gt;Offset&lt;/code&gt; パラメーターによって、最初の要素の位置を基準に指定されます。 &lt;code&gt;Docs&lt;/code&gt; の。たとえば、オフセットが-4の場合、0から15までの数値を表すドキュメントのリストに対して、次のレイアウトを作成できます。</target>
        </trans-unit>
        <trans-unit id="2b0401c5dcd8acaf55fb3e4a1e292be99ca524e1" translate="yes" xml:space="preserve">
          <source>Arrays uses &lt;strong&gt;zero&lt;/strong&gt;-based indexing. This is a deliberate design choice and differs from other Erlang data structures, for example, tuples.</source>
          <target state="translated">配列の使用 &lt;strong&gt;ゼロ&lt;/strong&gt;ベースのインデックスを&lt;strong&gt;ます&lt;/strong&gt;。これは意図的な設計の選択であり、タプルなどの他のErlangデータ構造とは異なります。</target>
        </trans-unit>
        <trans-unit id="8daa60e38c87072a49c49928224bef6c12c7e054" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;#+sbwt&quot;&gt;+sbwt&lt;/a&gt;&lt;/code&gt; but affects dirty CPU schedulers. Defaults to &lt;code&gt;short&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#+sbwt&quot;&gt;+sbwt&lt;/a&gt;&lt;/code&gt; と同様ですが、ダーティーCPUスケジューラーに影響します。デフォルトは &lt;code&gt;short&lt;/code&gt; ですです。</target>
        </trans-unit>
        <trans-unit id="309dd2054ffb824320663f138850770c829b8b4e" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;#+sbwt&quot;&gt;+sbwt&lt;/a&gt;&lt;/code&gt; but affects dirty IO schedulers. Defaults to &lt;code&gt;short&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#+sbwt&quot;&gt;+sbwt&lt;/a&gt;&lt;/code&gt; と同様ですが、ダーティーIOスケジューラーに影響します。デフォルトは &lt;code&gt;short&lt;/code&gt; ですです。</target>
        </trans-unit>
        <trans-unit id="5b3946f390b5828658a54092e42e5c1aeb3b35f2" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;#+swt&quot;&gt;+swt&lt;/a&gt;&lt;/code&gt; but affects dirty CPU schedulers. Defaults to &lt;code&gt;medium&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#+swt&quot;&gt;+swt&lt;/a&gt;&lt;/code&gt; と同様ですが、ダーティCPUスケジューラに影響します。デフォルトは &lt;code&gt;medium&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="3e2e5d1e1ed3c38e858012a446291d2ee5eda343" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;#+swt&quot;&gt;+swt&lt;/a&gt;&lt;/code&gt; but affects dirty IO schedulers. Defaults to &lt;code&gt;medium&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#+swt&quot;&gt;+swt&lt;/a&gt;&lt;/code&gt; と同様ですが、ダーティーIOスケジューラーに影響します。デフォルトは &lt;code&gt;medium&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="cc32ea3f593b79a1f69eaba316d39f23e652807c" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;#binary_to_atom-2&quot;&gt;binary_to_atom/2&lt;/a&gt;&lt;/code&gt;, but the atom must exist.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#binary_to_atom-2&quot;&gt;binary_to_atom/2&lt;/a&gt;&lt;/code&gt; と同じですが、アトムが存在する必要があります。</target>
        </trans-unit>
        <trans-unit id="ca2f4a2b2d5f93cadaa314fdad3b64d75313bbcf" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;#crypto_one_time-5&quot;&gt;crypto_one_time/5&lt;/a&gt;&lt;/code&gt; but for ciphers without IVs.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#crypto_one_time-5&quot;&gt;crypto_one_time/5&lt;/a&gt;&lt;/code&gt; と同じですが、IVのない暗号用です。</target>
        </trans-unit>
        <trans-unit id="434cd7266c5993b7f305995750735748f31955d2" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;#match-2&quot;&gt;match/2&lt;/a&gt;&lt;/code&gt;, but &lt;code&gt;Subject&lt;/code&gt; is searched until exhausted and a list of all non-overlapping parts matching &lt;code&gt;Pattern&lt;/code&gt; is returned (in order).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#match-2&quot;&gt;match/2&lt;/a&gt;&lt;/code&gt; と同じですが、 &lt;code&gt;Subject&lt;/code&gt; は使い果たされるまで検索され、重複しないすべてのパーツのリストが一致します &lt;code&gt;Pattern&lt;/code&gt; （順番に）戻されます。</target>
        </trans-unit>
        <trans-unit id="62392802bcfff15af67682cfdf06f0083a7bb98e" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1&lt;/a&gt;&lt;/code&gt;, but does not send a &lt;code&gt;hello&lt;/code&gt; message.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1&lt;/a&gt;&lt;/code&gt; と同じですが、 &lt;code&gt;hello&lt;/code&gt; を送信しませんメッセージを。</target>
        </trans-unit>
        <trans-unit id="cb9ffdb93aadccde648214772c8fec53159cd3ed" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt;, but does not send a &lt;code&gt;hello&lt;/code&gt; message.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; と同じですが、 &lt;code&gt;hello&lt;/code&gt; 送信しませんメッセージを。</target>
        </trans-unit>
        <trans-unit id="4fa21b36059529486327fb112773587da1a9d73d" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;S'&lt;/code&gt; depend only on &lt;code&gt;S&lt;/code&gt; and &lt;code&gt;E&lt;/code&gt;, the kind of state machine described here is a Mealy machine (see, for example, the Wikipedia article &quot;Mealy machine&quot;).</source>
          <target state="translated">同様に &lt;code&gt;A&lt;/code&gt; と &lt;code&gt;S'&lt;/code&gt; のみに依存 &lt;code&gt;S&lt;/code&gt; と &lt;code&gt;E&lt;/code&gt; 、ステートマシンの種類は、ここで説明する（例えば、Wikipediaの記事『ミーリ・マシン』を参照）ミーリ・マシンです。</target>
        </trans-unit>
        <trans-unit id="b7f0ebcdeb2935048365b1b7688d80f3aa697b38" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;Common Test&lt;/code&gt; always finishes at least the current test case, the time specified with &lt;code&gt;duration&lt;/code&gt; or &lt;code&gt;until&lt;/code&gt; is never definitive.</source>
          <target state="translated">&lt;code&gt;Common Test&lt;/code&gt; 常に少なくとも現在のテストケースを終了し、時間で指定された &lt;code&gt;duration&lt;/code&gt; または &lt;code&gt;until&lt;/code&gt; 決定的なことはありません。</target>
        </trans-unit>
        <trans-unit id="36e279355dc9b13486eb359a6a271e352bb9ca92" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;binary_to_list/1&lt;/code&gt;, but returns a list of integers corresponding to the bytes from position &lt;code&gt;Start&lt;/code&gt; to position &lt;code&gt;Stop&lt;/code&gt; in &lt;code&gt;Binary&lt;/code&gt;. The positions in the binary are numbered starting from 1.</source>
          <target state="translated">&lt;code&gt;binary_to_list/1&lt;/code&gt; と同じですが、 &lt;code&gt;Binary&lt;/code&gt; の &lt;code&gt;Start&lt;/code&gt; 位置から &lt;code&gt;Stop&lt;/code&gt; 位置までのバイトに対応する整数のリストを返します。バイナリの位置には、1から番号が付けられます。</target>
        </trans-unit>
        <trans-unit id="356a2faa4b1e013f3d85b59d1af52dcdb569daaf" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;binary_to_term/1&lt;/code&gt;, but takes these options:</source>
          <target state="translated">&lt;code&gt;binary_to_term/1&lt;/code&gt; と同じですが、次のオプションを取ります：</target>
        </trans-unit>
        <trans-unit id="4a20cd1597bfd4ebe1b9bc83959a610632302a2c" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;init_per_testcase&lt;/code&gt; and &lt;code&gt;end_per_testcase&lt;/code&gt; execute on the same Erlang process as the test case, printouts from these configuration functions are included in the test case log file.</source>
          <target state="translated">&lt;code&gt;init_per_testcase&lt;/code&gt; と &lt;code&gt;end_per_testcase&lt;/code&gt; テストケースと同じErlangのプロセス上で実行される、これらの構成機能からのプリントアウトは、テスト・ケース・ログ・ファイルに含まれています。</target>
        </trans-unit>
        <trans-unit id="077937866e1c72c70b5a0b14cb6e8cc697f67ab6" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;reload/2&lt;/code&gt; waits for the reloading to occur, a misbehaving process keeping open ports to the driver (or keeping the driver loaded) can cause infinite waiting for reload. Time-outs must be provided outside of the process demanding the reload or by using the low-level interface &lt;code&gt;&lt;a href=&quot;#try_load-3&quot;&gt;try_load/3&lt;/a&gt;&lt;/code&gt; in combination with driver monitors.</source>
          <target state="translated">ように &lt;code&gt;reload/2&lt;/code&gt; 発生するリロードを待つ、運転者に開いているポートを維持する（またはロードされたドライバを保つ）不正動作するプロセスは、リロードの無限待機を引き起こす可能性があります。タイムアウトは、リロードを要求するプロセスの外部で、または低レベルのインターフェース &lt;code&gt;&lt;a href=&quot;#try_load-3&quot;&gt;try_load/3&lt;/a&gt;&lt;/code&gt; を使用して提供する必要がありますをドライバーモニターと組み合わせて。</target>
        </trans-unit>
        <trans-unit id="35dd6ddae6107d33b10d598d29bb9b8cf8efce75" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;{Unused,Binary}&lt;/code&gt; where &lt;code&gt;Unused&lt;/code&gt; denotes how many trailing zero-bits 0-7 that are unused in the least significant byte in &lt;code&gt;Binary&lt;/code&gt;. This format is accepted as input to the encode functions, and a &lt;code&gt;BIT STRING&lt;/code&gt; is decoded to this format if &lt;code&gt;compact_bit_string&lt;/code&gt; has been given.</source>
          <target state="translated">&lt;code&gt;{Unused,Binary}&lt;/code&gt; &lt;code&gt;Unused&lt;/code&gt; 示しどのように多くの後続ゼロのビット0-7の最下位バイトに使用されていない &lt;code&gt;Binary&lt;/code&gt; 。このフォーマットはエンコード関数への入力として受け入れられ、 &lt;code&gt;compact_bit_string&lt;/code&gt; が指定されている場合、 &lt;code&gt;BIT STRING&lt;/code&gt; 文字列はこのフォーマットにデコードされます。</target>
        </trans-unit>
        <trans-unit id="40263cdf47a643660bd823252e4e54341b4e8e99" translate="yes" xml:space="preserve">
          <source>As Erl_Interface operates on the Erlang external term format, the port must be set to use binaries.</source>
          <target state="translated">Erl_InterfaceはErlangの外部項フォーマットで動作するので、ポートはバイナリを使うように設定しなければなりません。</target>
        </trans-unit>
        <trans-unit id="bf5866c25e866f9c6f9b119f63b598360bcc9ad6" translate="yes" xml:space="preserve">
          <source>As Erlang has a fixed number of types, there is no need for a programmer to define a specification for the external format used within some application. All Erlang terms have an external representation and the interpretation of the different terms is application-specific.</source>
          <target state="translated">Erlangには決まった数の型があるので、プログラマがアプリケーション内で使われる外部フォーマットの仕様を定義する必要はありません。すべてのErlangの用語は外部表現を持っていて、異なる用語の解釈はアプリケーション固有のものです。</target>
        </trans-unit>
        <trans-unit id="c7e5143ee8610dc021b9a09e083dc533d485e207" translate="yes" xml:space="preserve">
          <source>As a &lt;code&gt;simple_one_for_one&lt;/code&gt; supervisor can have many children, it shuts them all down asynchronously. This means that the children do their cleanup in parallel, and therefore the order in which they are stopped is not defined.</source>
          <target state="translated">&lt;code&gt;simple_one_for_one&lt;/code&gt; としてスーパーバイザは多くの子を持つことができるそれらをすべて非同期でシャットダウンします。つまり、子は並行してクリーンアップを行うため、停止される順序は定義されていません。</target>
        </trans-unit>
        <trans-unit id="c2fd4a4764c6e535778fe8db9cbb1523710b87e3" translate="yes" xml:space="preserve">
          <source>As a NIF library is dynamically linked into the emulator process, this is the fastest way of calling C-code from Erlang (alongside port drivers). Calling NIFs requires no context switches. But it is also the least safe, because a crash in a NIF brings the emulator down too.</source>
          <target state="translated">NIFライブラリはエミュレータプロセスに動的にリンクされているので、これがErlangからCコードを呼び出す最速の方法です(ポートドライバと一緒に)。NIFを呼び出すにはコンテキストスイッチが必要ありません。しかし、これは最も安全ではない方法でもあります。</target>
        </trans-unit>
        <trans-unit id="58e7b3f109198992ba59bec647e67726857b68a0" translate="yes" xml:space="preserve">
          <source>As a complement to the &lt;code&gt;set&lt;/code&gt; operation, it is possible to specify a test function. This function has the same syntax as the set operation above, except that the first argument is &lt;code&gt;is_set_ok&lt;/code&gt; instead of &lt;code&gt;set&lt;/code&gt;. This function is called before the variable is set. Its purpose is to ensure that it is permissible to set the variable to the new value.</source>
          <target state="translated">&lt;code&gt;set&lt;/code&gt; 演算の補足として、テスト関数を指定することができます。この関数は、最初の引数であることを除いて、上記セット動作と同じシンタックスを有する &lt;code&gt;is_set_ok&lt;/code&gt; 代わり &lt;code&gt;set&lt;/code&gt; 。この関数は、変数が設定される前に呼び出されます。その目的は、変数を新しい値に設定できることを確認することです。</target>
        </trans-unit>
        <trans-unit id="2948bceb43ecea497f0a445923a501687c512364" translate="yes" xml:space="preserve">
          <source>As a convenient shorthand, if any option settings are required at the start of a non-capturing subpattern, the option letters can appear between &quot;?&quot; and &quot;:&quot;. Thus, the following two patterns match the same set of strings:</source>
          <target state="translated">便利な速記法として、キャプチャしないサブパターンの開始時にオプション設定が必要な場合、オプション文字は「?」と「:」の間に現れることができます。したがって、以下の2つのパターンは、同じ文字列のセットにマッチします。</target>
        </trans-unit>
        <trans-unit id="f6848c0bdaadb93a4b8d51c18e19a86434987f9a" translate="yes" xml:space="preserve">
          <source>As a convention, all I/O servers handle both &lt;code&gt;{setopts, [binary]}&lt;/code&gt;, &lt;code&gt;{setopts, [list]}&lt;/code&gt;, and &lt;code&gt;{setopts,[{binary, boolean()}]}&lt;/code&gt;, hence the trick with &lt;code&gt;proplists:substitute_negations/2&lt;/code&gt; and &lt;code&gt;proplists:unfold/1&lt;/code&gt;. If invalid options are sent to us, we send &lt;code&gt;{error, enotsup}&lt;/code&gt; back to the client.</source>
          <target state="translated">慣例として、すべてのI / Oサーバーは &lt;code&gt;{setopts, [binary]}&lt;/code&gt; 、 &lt;code&gt;{setopts, [list]}&lt;/code&gt; 、および &lt;code&gt;{setopts,[{binary, boolean()}]}&lt;/code&gt; &lt;code&gt;proplists:substitute_negations/2&lt;/code&gt; を処理するため、proplists：substitute_negations / 2と &lt;code&gt;proplists:unfold/1&lt;/code&gt; 。無効なオプションが送信された場合は、 &lt;code&gt;{error, enotsup}&lt;/code&gt; をクライアントに送信します。</target>
        </trans-unit>
        <trans-unit id="2a763e7b020b36d9979aba8bffd33d0107367482" translate="yes" xml:space="preserve">
          <source>As a convention, the macro arguments in the head all start with an uppercase letter. In the body, the macro arguments can be expanded by preceding them with &lt;code&gt;$&lt;/code&gt;.</source>
          <target state="translated">慣例として、先頭のマクロ引数はすべて大文字で始まります。本文では、マクロ引数の前に &lt;code&gt;$&lt;/code&gt; を付けることで展開できます。</target>
        </trans-unit>
        <trans-unit id="493adbb575cc27e47dde3943edacdea5778a9cf8" translate="yes" xml:space="preserve">
          <source>As a final example we demonstrate the use of &lt;code&gt;driver_async&lt;/code&gt;. We also use the driver term interface. The driver is written in C++. This enables us to use an algorithm from STL. We use the &lt;code&gt;next_permutation&lt;/code&gt; algorithm to get the next permutation of a list of integers. For large lists (&amp;gt; 100,000 elements), this takes some time, so we perform this as an asynchronous task.</source>
          <target state="translated">最後の例として、 &lt;code&gt;driver_async&lt;/code&gt; の使用法を示します。ドライバー用語インターフェイスも使用します。ドライバーはC ++で書かれています。これにより、STLのアルゴリズムを使用できます。 &lt;code&gt;next_permutation&lt;/code&gt; アルゴリズムを使用して、整数のリストの次の順列を取得します。大きなリスト（&amp;gt; 100,000要素）の場合、これには時間がかかるため、これを非同期タスクとして実行します。</target>
        </trans-unit>
        <trans-unit id="a1f3df7ed28f00795df09b73036126e4e8c30a4d" translate="yes" xml:space="preserve">
          <source>As a hexadecimal number (or an integer). Avoid this as it is easy to misinterpret a &lt;code&gt;BIT STRING&lt;/code&gt; value in this format.</source>
          <target state="translated">16進数（または整数）として。この形式の &lt;code&gt;BIT STRING&lt;/code&gt; 値は誤って解釈される可能性があるため、これは避けてください。</target>
        </trans-unit>
        <trans-unit id="7085268ee258ef21d5f659dd9a334d1661d8596c" translate="yes" xml:space="preserve">
          <source>As a last resort, the implementation solely based on the &lt;code&gt;gcc&lt;/code&gt;&lt;code&gt;__sync_*&lt;/code&gt; builtins. This will however cause lots of expensive and unnecessary memory barrier instructions to be issued. That is, performance will suffer. The &lt;code&gt;configure&lt;/code&gt; script will warn at the end of its execution if it cannot find any other alternative than this.</source>
          <target state="translated">最後の手段として、 &lt;code&gt;gcc&lt;/code&gt; &lt;code&gt;__sync_*&lt;/code&gt; ビルトインのみに基づく実装。ただし、これにより、高価で不要なメモリバリア命令が大量に発行されます。つまり、パフォーマンスが低下します。 &lt;code&gt;configure&lt;/code&gt; これより、他の選択肢を見つけることができない場合、スクリプトはその実行の終了時に警告が表示されます。</target>
        </trans-unit>
        <trans-unit id="ebe4b26b3285c31b7e66a15f34435eba521d186d" translate="yes" xml:space="preserve">
          <source>As a match specification can turn on sequential tracing, the combination of &lt;code&gt;dbg&lt;/code&gt; and &lt;code&gt;seq_trace&lt;/code&gt; can be quite powerful. This brief example shows a session where sequential tracing is used:</source>
          <target state="translated">一致指定により順次トレースを &lt;code&gt;seq_trace&lt;/code&gt; できるため、 &lt;code&gt;dbg&lt;/code&gt; とseq_traceの組み合わせは非常に強力です。この簡単な例は、順次トレースが使用されているセッションを示しています。</target>
        </trans-unit>
        <trans-unit id="57ca2c648144ecb05c83959a4bb6906fc7dba92e" translate="yes" xml:space="preserve">
          <source>As a part of the &lt;code&gt;add_frag&lt;/code&gt; procedure, Mnesia iterates over all fragments corresponding to the &lt;code&gt;IterFrags&lt;/code&gt; numbers and starts &lt;code&gt;key_to_frag_number(NewState,RecordKey)&lt;/code&gt; for each record. If the new fragment differs from the old fragment, the record is moved to the new fragment.</source>
          <target state="translated">&lt;code&gt;add_frag&lt;/code&gt; プロシージャの一部として、Mnesiaは &lt;code&gt;IterFrags&lt;/code&gt; 番号に対応するすべてのフラグメントを反復処理し、各レコードに対して &lt;code&gt;key_to_frag_number(NewState,RecordKey)&lt;/code&gt; を開始します。新しいフラグメントが古いフラグメントと異なる場合、レコードは新しいフラグメントに移動されます。</target>
        </trans-unit>
        <trans-unit id="afa5aac0272b889e29ab3d3e2445e190b23afd3b" translate="yes" xml:space="preserve">
          <source>As a part of the &lt;code&gt;del_frag&lt;/code&gt; procedure, Mnesia iterates over all fragments corresponding to the &lt;code&gt;IterFrags&lt;/code&gt; numbers and starts &lt;code&gt;key_to_frag_number(NewState,RecordKey)&lt;/code&gt; for each record. If the new fragment differs from the old fragment, the record is moved to the new fragment.</source>
          <target state="translated">&lt;code&gt;del_frag&lt;/code&gt; プロシージャの一部として、Mnesiaは &lt;code&gt;IterFrags&lt;/code&gt; 番号に対応するすべてのフラグメントを反復処理し、各レコードに対して &lt;code&gt;key_to_frag_number(NewState,RecordKey)&lt;/code&gt; を開始します。新しいフラグメントが古いフラグメントと異なる場合、レコードは新しいフラグメントに移動されます。</target>
        </trans-unit>
        <trans-unit id="e1a32b7616ffad81dc2a3990b12ee743d67d1150" translate="yes" xml:space="preserve">
          <source>As a port driver is dynamically linked into the emulator process, this is the fastest way of calling C-code from Erlang. Calling functions in the port driver requires no context switches. But it is also the least safe way, because a crash in the port driver brings the emulator down too.</source>
          <target state="translated">ポートドライバはエミュレータプロセスに動的にリンクされているので、これはErlangからCコードを呼び出す最速の方法です。ポートドライバで関数を呼び出すにはコンテキストスイッチが必要ありません。しかし、ポートドライバがクラッシュするとエミュレータもダウンしてしまうので、最も安全ではない方法でもあります。</target>
        </trans-unit>
        <trans-unit id="67c16b741f04ea5b7b054409fb35ff1c48cb01da" translate="yes" xml:space="preserve">
          <source>As a side effect, the function prints the name of each module it tries to compile. If compilation fails for a module, the make procedure stops and &lt;code&gt;error&lt;/code&gt; is returned.</source>
          <target state="translated">副作用として、関数はコンパイルしようとする各モジュールの名前を出力します。モジュールのコンパイルが失敗すると、makeプロシージャが停止し、 &lt;code&gt;error&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="bef2be0aff2e7e47dd8199f96ca616049e6fbecf" translate="yes" xml:space="preserve">
          <source>As a special case, &lt;code&gt;{message, false}&lt;/code&gt; disables sending of trace messages ('call' and 'return_to') for this function call, just like if the match specification had not matched. This can be useful if only the side effects of the &lt;code&gt;MatchBody&lt;/code&gt; part are desired.</source>
          <target state="translated">特殊なケースとして、 &lt;code&gt;{message, false}&lt;/code&gt; は、一致指定が一致しなかった場合と同様に、この関数呼び出しのトレースメッセージ（ 'call'および 'return_to'）の送信を無効にします。これは、 &lt;code&gt;MatchBody&lt;/code&gt; パーツの副作用のみが必要な場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="dc75067c89eb230d3aeaa930304e48d7ffc6b8ce" translate="yes" xml:space="preserve">
          <source>As a special case, drivers can be unloaded from processes that have done no corresponding call to &lt;code&gt;try_load/3&lt;/code&gt; if, and only if, there are &lt;strong&gt;no users of the driver at all&lt;/strong&gt;, which can occur if the process containing the last user dies.</source>
          <target state="translated">特別な場合として、 &lt;code&gt;try_load/3&lt;/code&gt; への対応する呼び出しを行わなかったプロセスからドライバーをアンロードできます。これは、最後のユーザーを含むプロセスが終了した場合に発生する可能性のある&lt;strong&gt;、ドライバーのユーザー&lt;/strong&gt;が&lt;strong&gt;まったくいない&lt;/strong&gt;場合に限ります。</target>
        </trans-unit>
        <trans-unit id="b5a63aa06a92181b3a5ed95aec64c64b4bdd7c17" translate="yes" xml:space="preserve">
          <source>As a special case, the following apply in the &lt;code&gt;MatchCondition/MatchBody&lt;/code&gt; parts:</source>
          <target state="translated">特殊なケースとして、 &lt;code&gt;MatchCondition/MatchBody&lt;/code&gt; パーツでは次のことが適用されます。</target>
        </trans-unit>
        <trans-unit id="03b85735e71929e52331dbf92e7f4188f735f3c7" translate="yes" xml:space="preserve">
          <source>As a test suite runs, all information (including output to &lt;code&gt;stdout&lt;/code&gt;) is recorded in many different log files. A minimum of information is displayed in the user console (only start and stop information, plus a note for each failed test case).</source>
          <target state="translated">テストスイートを実行すると、すべての情報（ &lt;code&gt;stdout&lt;/code&gt; への出力を含む）が多くの異なるログファイルに記録されます。最小限の情報がユーザーコンソールに表示されます（開始および停止情報と、失敗した各テストケースのメモのみ）。</target>
        </trans-unit>
        <trans-unit id="579b2213688012ed19e294f3d42e5b38c477a26a" translate="yes" xml:space="preserve">
          <source>As above but with a descriptive string. The string is currently unused by &lt;code&gt;xref&lt;/code&gt; but other tools can make use of it.</source>
          <target state="translated">上記と同じですが、説明的な文字列を使用します。文字列は現在 &lt;code&gt;xref&lt;/code&gt; 使用されていませんが、他のツールで使用できます。</target>
        </trans-unit>
        <trans-unit id="af27c23232c9332dfe458eed56f4e4ca1c250964" translate="yes" xml:space="preserve">
          <source>As all operations performed by Dets are disk operations, it is important to realize that a single look-up operation involves a series of disk seek and read operations. The Dets functions are therefore much slower than the corresponding &lt;code&gt;&lt;a href=&quot;ets&quot;&gt;ets(3)&lt;/a&gt;&lt;/code&gt; functions, although Dets exports a similar interface.</source>
          <target state="translated">Detsによって実行されるすべての操作はディスク操作であるため、1つのルックアップ操作には一連のディスクシーク操作と読み取り操作が含まれることを理解することが重要です。したがって、Detsは同様のインターフェースをエクスポートしますが、Dets関数は対応する &lt;code&gt;&lt;a href=&quot;ets&quot;&gt;ets(3)&lt;/a&gt;&lt;/code&gt; 関数よりもはるかに低速です。</target>
        </trans-unit>
        <trans-unit id="eb95848bc99a15bbb0e15871e436bb30c7e336fc" translate="yes" xml:space="preserve">
          <source>As alternative branches are tried from left to right, and options are not reset until the end of the subpattern is reached, an option setting in one branch does affect subsequent branches, so the above patterns match both &quot;SUNDAY&quot; and &quot;Saturday&quot;.</source>
          <target state="translated">左から右へと代替のブランチが試行され、サブパターンが終了するまでオプションはリセットされないため、1つのブランチでのオプション設定は後続のブランチに影響を与えるため、上記のパターンは「SUNDAY」と「Saturday」の両方にマッチします。</target>
        </trans-unit>
        <trans-unit id="3c01043c234b4ec0c86a33f6ba721a734f751f6e" translate="yes" xml:space="preserve">
          <source>As an alternative to &lt;code&gt;-pa&lt;/code&gt;, if several directories are to be prepended to the code path and the directories have a common parent directory, that parent directory can be specified in environment variable &lt;code&gt;ERL_LIBS&lt;/code&gt;; see &lt;code&gt;code(3)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;-pa&lt;/code&gt; の代わりに、コードパスの前に複数のディレクトリを追加し、それらのディレクトリに共通の親ディレクトリがある場合、その親ディレクトリを環境変数 &lt;code&gt;ERL_LIBS&lt;/code&gt; で指定できます。 &lt;code&gt;code(3)&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="88dc064e87e4d93064611ba4390a686486fbcb39" translate="yes" xml:space="preserve">
          <source>As an alternative to building a bootscript, you can explicitly add the path to the SSL &lt;code&gt;ebin&lt;/code&gt; directory on the command line. This is done with command-line option &lt;code&gt;-pa&lt;/code&gt;. This works as the SSL application does not need to be started for the distribution to come up, as a clone of the SSL application is hooked into the Kernel application. So, as long as the SSL application code can be reached, the distribution starts. The &lt;code&gt;-pa&lt;/code&gt; method is only recommended for testing purposes.</source>
          <target state="translated">ブートスクリプトを作成する代わりに、コマンドラインでSSL &lt;code&gt;ebin&lt;/code&gt; ディレクトリへのパスを明示的に追加できます。これは、コマンドラインオプション &lt;code&gt;-pa&lt;/code&gt; を使用して行います。これは、SSLアプリケーションのクローンがカーネルアプリケーションにフックされるため、配布を開始するためにSSLアプリケーションを起動する必要がないため、機能します。したがって、SSLアプリケーションコードに到達できる限り、配布が開始されます。 &lt;code&gt;-pa&lt;/code&gt; の方法は、テストの目的だけに使用が推奨されます。</target>
        </trans-unit>
        <trans-unit id="99c43706bedf3f37ba2bc1f77eaef7f141bffa35" translate="yes" xml:space="preserve">
          <source>As an alternative to sorting files, a function of one argument can be specified as input. When called with argument &lt;code&gt;read&lt;/code&gt;, the function is assumed to return either of the following:</source>
          <target state="translated">ファイルをソートする代わりに、1つの引数の関数を入力として指定できます。引数 &lt;code&gt;read&lt;/code&gt; で呼び出されると、関数は次のいずれかを返すと想定されます。</target>
        </trans-unit>
        <trans-unit id="aa2f69a7cd9917454bfd5b22b175f310f6d2bfae" translate="yes" xml:space="preserve">
          <source>As an alternative to the &lt;code&gt;-callback&lt;/code&gt; and &lt;code&gt;-optional_callbacks&lt;/code&gt; attributes you may directly implement and export &lt;code&gt;behaviour_info()&lt;/code&gt;:</source>
          <target state="translated">代わるものとして &lt;code&gt;-callback&lt;/code&gt; と &lt;code&gt;-optional_callbacks&lt;/code&gt; あなたが直接実装し、輸出も属性 &lt;code&gt;behaviour_info()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c35ac71302602496215802d2ceb07a268d8ab46b" translate="yes" xml:space="preserve">
          <source>As an alternative, an already open TCP socket could be passed to the function in &lt;code&gt;TcpSocket&lt;/code&gt;. The SSH initiation and negotiation will be initiated on that one and finaly a shell will be started on the host at the other end of the TCP socket.</source>
          <target state="translated">別の方法として、すでに開いているTCPソケットを &lt;code&gt;TcpSocket&lt;/code&gt; の関数に渡すことができます。SSHの開始とネゴシエーションがその1つで開始され、最後に、TCPソケットの反対側のホストでシェルが開始されます。</target>
        </trans-unit>
        <trans-unit id="310627ae72667d56b80e90bfe9262f70c174ac28" translate="yes" xml:space="preserve">
          <source>As an alternative, an already open TCP socket could be passed to the function in &lt;code&gt;TcpSocket&lt;/code&gt;. The SSH initiation and negotiation will be initiated on that one when an SSH starts at the other end of the TCP socket.</source>
          <target state="translated">別の方法として、すでに開いているTCPソケットを &lt;code&gt;TcpSocket&lt;/code&gt; の関数に渡すことができます。SSHの開始とネゴシエーションは、SSHがTCPソケットのもう一方の端で開始されるときに、その1つで開始されます。</target>
        </trans-unit>
        <trans-unit id="273b6d8022e0a14e661c5ebb9acfcaf89acecfbc" translate="yes" xml:space="preserve">
          <source>As an alternative, an already open TCP socket could be passed to the function in &lt;code&gt;TcpSocket&lt;/code&gt;. The SSH initiation and negotiation will be initiated on that one with the SSH that should be at the other end.</source>
          <target state="translated">別の方法として、すでに開いているTCPソケットを &lt;code&gt;TcpSocket&lt;/code&gt; の関数に渡すことができます。SSHの開始とネゴシエーションは、もう一方の側にあるはずのSSHを使用して開始されます。</target>
        </trans-unit>
        <trans-unit id="b0d2d299871acdd7ed8b13c9605799bbdca8d746" translate="yes" xml:space="preserve">
          <source>As an example let's add the Diffie-Hellman Group1 first in the kex list. It is supported according to &lt;code&gt;Supported algoritms&lt;/code&gt;.</source>
          <target state="translated">例として、kiffリストの最初にDiffie-Hellman Group1を追加してみましょう。サポートされて &lt;code&gt;Supported algoritms&lt;/code&gt; に従ってサポートされています。</target>
        </trans-unit>
        <trans-unit id="9fed952b378ed463bdf14ff665fe8061e73af37b" translate="yes" xml:space="preserve">
          <source>As an example of analyzing indirect calls, the following Erlang function tries to answer the question: if we want to know which modules are used indirectly by some module(s), is it worth while using the &lt;code&gt;&lt;a href=&quot;xref#call_graph&quot;&gt;function graph&lt;/a&gt;&lt;/code&gt; rather than the module graph? Recall that a module M1 is said to call a module M2 if there is some function in M1 that calls some function in M2. It would be nice if we could use the much smaller module graph, since it is available also in the light weight &lt;code&gt;modules&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;xref#mode&quot;&gt;mode&lt;/a&gt;&lt;/code&gt; of Xref servers.</source>
          <target state="translated">間接呼び出しを分析する例として、次のErlang関数は質問に答えようとします。モジュールによって間接的に使用されているモジュールを知りたい場合、モジュールグラフではなく &lt;code&gt;&lt;a href=&quot;xref#call_graph&quot;&gt;function graph&lt;/a&gt;&lt;/code&gt; を使用する価値はありますか？ M2にある関数を呼び出すM1にある関数がある場合、モジュールM1はモジュールM2を呼び出すと言われることを思い出してください。Xrefサーバーの軽量 &lt;code&gt;modules&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;xref#mode&quot;&gt;mode&lt;/a&gt;&lt;/code&gt; でも使用できるため、はるかに小さいモジュールグラフを使用できると便利です。</target>
        </trans-unit>
        <trans-unit id="c9dcf4f61625ae0867c30f6f2ec1a54ebcaa12ae" translate="yes" xml:space="preserve">
          <source>As an example of how the function can be used, we create an interpreted escript that uses &lt;code&gt;emu_args&lt;/code&gt; to set some emulator flag. In this case, it happens to disable the &lt;code&gt;smp_support&lt;/code&gt;. We also extract the different sections from the newly created script:</source>
          <target state="translated">関数の使用方法の例として、 &lt;code&gt;emu_args&lt;/code&gt; を使用してエミュレーターフラグを設定するインタープリターescriptを作成します。この場合、たまたま &lt;code&gt;smp_support&lt;/code&gt; が無効になります。また、新しく作成したスクリプトからさまざまなセクションを抽出します。</target>
        </trans-unit>
        <trans-unit id="93e8253d4bef52c01714100b16613baca9f2eb65" translate="yes" xml:space="preserve">
          <source>As an example of how to use function &lt;code&gt;&lt;a href=&quot;#table-2&quot;&gt;table/2&lt;/a&gt;&lt;/code&gt;, the implementation of a QLC table for the &lt;code&gt;&lt;a href=&quot;gb_trees&quot;&gt;gb_trees&lt;/a&gt;&lt;/code&gt; module is given:</source>
          <target state="translated">関数 &lt;code&gt;&lt;a href=&quot;#table-2&quot;&gt;table/2&lt;/a&gt;&lt;/code&gt; の使用例として、 &lt;code&gt;&lt;a href=&quot;gb_trees&quot;&gt;gb_trees&lt;/a&gt;&lt;/code&gt; モジュールのQLCテーブルの実装を示します。</target>
        </trans-unit>
        <trans-unit id="d7686e8d3cae0d8b83f082414847869122b1c718" translate="yes" xml:space="preserve">
          <source>As an example of the default behavior, the following call returns, as first and only captured string, the matching part of the subject (&quot;abcd&quot; in the middle) as an index pair &lt;code&gt;{3,4}&lt;/code&gt;, where character positions are zero-based, just as in offsets:</source>
          <target state="translated">デフォルトの動作の一例、インデックス対として最初で唯一の文字列をキャプチャし、被写体の照合部（中央に「ABCD」）として、次の呼び出しが戻る、などの &lt;code&gt;{3,4}&lt;/code&gt; の文字位置はゼロであり、オフセットと同様に、</target>
        </trans-unit>
        <trans-unit id="1363c4916ced9b1c12e495d959e392b062a979b7" translate="yes" xml:space="preserve">
          <source>As an example of these rules, suppose you want to write the function &lt;code&gt;select&lt;/code&gt;, which selects certain elements from a list of tuples. Suppose you write &lt;code&gt;select(X, L) -&amp;gt; [Y || {X, Y} &amp;lt;- L].&lt;/code&gt; with the intention of extracting all tuples from &lt;code&gt;L&lt;/code&gt;, where the first item is &lt;code&gt;X&lt;/code&gt;.</source>
          <target state="translated">これらのルールの例として、タプルのリストから特定の要素を選択する関数 &lt;code&gt;select&lt;/code&gt; を作成するとします。 &lt;code&gt;select(X, L) -&amp;gt; [Y || {X, Y} &amp;lt;- L].&lt;/code&gt; と書いたとします。{X、Y} &amp;lt;-L]。最初の項目が &lt;code&gt;X&lt;/code&gt; である &lt;code&gt;L&lt;/code&gt; からすべてのタプルを抽出する目的で。</target>
        </trans-unit>
        <trans-unit id="2d77fac41d8f6ac13e4c80ca8e1c35a37d97d30a" translate="yes" xml:space="preserve">
          <source>As an example, assume that the old maximum number of files is 10 and that the new maximum number of files is 6. If the current file number is not greater than the new maximum number of files, files 7-10 are removed when file 6 is full and the log starts to write to file number 1 again. Otherwise, the files greater than the current file are removed when the current file is full (for example, if the current file is 8, files 9 and 10 are removed). The files between the new maximum number of files and the current file (that is, files 7 and 8) are removed the next time file 6 is full.</source>
          <target state="translated">例として、古い最大ファイル数が10で、新しい最大ファイル数が6だとすると、現在のファイル番号が新しい最大ファイル数よりも大きくない場合、ファイル6が一杯になった時点でファイル7~10が削除され、ログは再びファイル番号1への書き込みを開始します。それ以外の場合は、現在のファイルが一杯になったときに、現在のファイルより大きいファイルが削除されます(例えば、現在のファイルが8の場合は、ファイル9と10が削除されます)。新しい最大ファイル数と現在のファイルとの間のファイル(つまり、ファイル7と8)は、次にファイル6が一杯になったときに削除される。</target>
        </trans-unit>
        <trans-unit id="6df1dd563dff5d559d5237ab7b1799899d2a4427" translate="yes" xml:space="preserve">
          <source>As an example, consider sorting the terms on a disk log file. A function that reads chunks from the disk log and returns a list of binaries is used as input. The results are collected in a list of terms.</source>
          <target state="translated">例として、ディスクログファイルの用語をソートすることを考えてみましょう。ディスクログからチャンクを読み込み、バイナリのリストを返す関数を入力として使用します。結果は用語のリストに集められます。</target>
        </trans-unit>
        <trans-unit id="9ef05760a87925d5316892398ba7e6735c0cc668" translate="yes" xml:space="preserve">
          <source>As an example, consider the following record definition:</source>
          <target state="translated">例として、次のようなレコード定義を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="0bace29d40d7981ee102e27dfe23de3fe372b080" translate="yes" xml:space="preserve">
          <source>As an example, contemplate the issue of converting between upper and lower case letters. Reading the standard makes you realize that there is not a simple one to one mapping in all scripts, for example:</source>
          <target state="translated">例として、大文字と小文字の変換の問題を考えてみましょう。標準を読むと、例えば、すべてのスクリプトに単純な1対1のマッピングがあるわけではないことに気づかされます。</target>
        </trans-unit>
        <trans-unit id="625ee0980ab37e0cc8ded0c3288fcfb1cdf01127" translate="yes" xml:space="preserve">
          <source>As an example, let say that we want to send &lt;code&gt;{call, &amp;lt;0.245.2&amp;gt;, {set_get_state, &amp;lt;&amp;lt;0:1024&amp;gt;&amp;gt;}}&lt;/code&gt; to registered process &lt;code&gt;reg&lt;/code&gt; using a fragment size of 128. To send this message we need a distribution header, atom cache updates, the control message (which would be &lt;code&gt;{6, &amp;lt;0.245.2&amp;gt;, [], reg}&lt;/code&gt; in this case) and finally the actual message. This would all be encoded into:</source>
          <target state="translated">例として、128のフラグメントサイズを使用して、登録済みのプロセス &lt;code&gt;reg&lt;/code&gt; に &lt;code&gt;{call, &amp;lt;0.245.2&amp;gt;, {set_get_state, &amp;lt;&amp;lt;0:1024&amp;gt;&amp;gt;}}&lt;/code&gt; を送信するとします。このメッセージを送信するには、配布ヘッダー、アトムキャッシュの更新、制御メッセージ（この場合 &lt;code&gt;{6, &amp;lt;0.245.2&amp;gt;, [], reg}&lt;/code&gt; ）、そして最後に実際のメッセージ。これはすべて次のようにエンコードされます。</target>
        </trans-unit>
        <trans-unit id="0e81b4992cba2b699d381459f734b8216213b6b3" translate="yes" xml:space="preserve">
          <source>As an example, list comprehensions can be used to simplify some of the functions in &lt;code&gt;lists.erl&lt;/code&gt;:</source>
          <target state="translated">例として、リスト内包表記を使用して、 &lt;code&gt;lists.erl&lt;/code&gt; の一部の関数を簡略化できます。</target>
        </trans-unit>
        <trans-unit id="c1e3067854a4c9b6a2c74afda818dcdb334e651b" translate="yes" xml:space="preserve">
          <source>As an example, one can insert an object with &lt;code&gt;integer()&lt;/code&gt;&lt;code&gt;1&lt;/code&gt; as a key in an &lt;code&gt;ordered_set&lt;/code&gt; and get the object returned as a result of doing a &lt;code&gt;lookup/2&lt;/code&gt; with &lt;code&gt;float()&lt;/code&gt;&lt;code&gt;1.0&lt;/code&gt; as the key to search for.</source>
          <target state="translated">例として、 &lt;code&gt;integer()&lt;/code&gt; でオブジェクトを挿入できます &lt;code&gt;1&lt;/code&gt; をキーとして &lt;code&gt;ordered_set&lt;/code&gt; に検索するキーとして &lt;code&gt;float()&lt;/code&gt; &lt;code&gt;1.0&lt;/code&gt; を使用して &lt;code&gt;lookup/2&lt;/code&gt; を実行した結果として返されるオブジェクトを取得できます。</target>
        </trans-unit>
        <trans-unit id="66fc66c449548ea231626daea7c93210ea8cbc49" translate="yes" xml:space="preserve">
          <source>As an example, one can let trace messages be sent over the network to another Erlang node (preferably &lt;strong&gt;not&lt;/strong&gt; distributed), where the formatting occurs:</source>
          <target state="translated">例として、フォーマットが発生する別のErlangノード（できれ&lt;strong&gt;ば&lt;/strong&gt;分散し&lt;strong&gt;ない&lt;/strong&gt;）にネットワーク経由でトレースメッセージを送信させることができます。</target>
        </trans-unit>
        <trans-unit id="e7c1111ab56bf671a69f40fa390abccb417d88d6" translate="yes" xml:space="preserve">
          <source>As an example, suppose that you want to start a slave node at host &lt;code&gt;H&lt;/code&gt; with node name &lt;code&gt;Name@H&lt;/code&gt; and want the slave node to have the following properties:</source>
          <target state="translated">例として、ホスト &lt;code&gt;H&lt;/code&gt; でノード名 &lt;code&gt;Name@H&lt;/code&gt; スレーブノードを起動し、スレーブノードに次のプロパティを設定するとします。</target>
        </trans-unit>
        <trans-unit id="8f6e43ba50d78085627070b9be2ee7833e58261c" translate="yes" xml:space="preserve">
          <source>As an example, the I/O server for the interactive shell (in &lt;code&gt;group.erl&lt;/code&gt;) understands the following options:</source>
          <target state="translated">例として、対話型シェル（ &lt;code&gt;group.erl&lt;/code&gt; 内）のI / Oサーバーは、次のオプションを理解します。</target>
        </trans-unit>
        <trans-unit id="c349ed36989168b087d0841f096ffe34418c5158" translate="yes" xml:space="preserve">
          <source>As an example, the following specific instructions cannot be implemented as a combined instruction:</source>
          <target state="translated">一例として、以下のような具体的な命令は結合命令として実装することができない。</target>
        </trans-unit>
        <trans-unit id="d726847c4d6dbe66ba80230721adc5bfacc18e04" translate="yes" xml:space="preserve">
          <source>As an example, we will use the following function, that you may recognise as a slightly modified benchmark function from the manpage file(3):</source>
          <target state="translated">例として、次のような関数を使用します。</target>
        </trans-unit>
        <trans-unit id="45ffebfcdac0f9d22d4c43b470257bc4c6356264" translate="yes" xml:space="preserve">
          <source>As an optimization this function may also return the port and version of the remote node. If port and version are returned &lt;code&gt;&lt;a href=&quot;#port_please-3&quot;&gt; port_please/3&lt;/a&gt;&lt;/code&gt; will not be called.</source>
          <target state="translated">最適化として、この関数はリモートノードのポートとバージョンも返す場合があります。ポートとバージョンが返された場合、 &lt;code&gt;&lt;a href=&quot;#port_please-3&quot;&gt; port_please/3&lt;/a&gt;&lt;/code&gt; は呼び出されません。</target>
        </trans-unit>
        <trans-unit id="67171017e640943dfb29d4cbec09fb767fa51114" translate="yes" xml:space="preserve">
          <source>As an snmp adaption usually keeps the index for the whole of the systems lifetime, this is rarely a problem.</source>
          <target state="translated">snmp適応は通常、システムの寿命の全期間にわたってインデックスを保持するので、これが問題になることはほとんどありません。</target>
        </trans-unit>
        <trans-unit id="319bb3abd29884b1375ba09774a3c06c1a190a13" translate="yes" xml:space="preserve">
          <source>As another example, consider concatenating the answers to two queries &lt;code&gt;QH1&lt;/code&gt; and &lt;code&gt;QH2&lt;/code&gt; while removing all duplicates. This is accomplished by using option &lt;code&gt;unique&lt;/code&gt;:</source>
          <target state="translated">別の例として、2つのクエリ &lt;code&gt;QH1&lt;/code&gt; に対する回答を連結することを検討してください。と &lt;code&gt;QH2&lt;/code&gt; ながら、すべての重複を削除すること。これは、オプション &lt;code&gt;unique&lt;/code&gt; を使用して実現されます。</target>
        </trans-unit>
        <trans-unit id="002e4414e669ace8432711f4ee7463efc45a9f68" translate="yes" xml:space="preserve">
          <source>As any other type of scripts, Erlang scripts do not work on Unix platforms if the execution bit for the script file is not set. (To turn on the execution bit, use &lt;code&gt;chmod +x script-name&lt;/code&gt;.)</source>
          <target state="translated">他のタイプのスクリプトと同様に、Erlangスクリプトは、スクリプトファイルの実行ビットが設定されていない場合、Unixプラットフォームでは機能しません。（実行ビットをオンにするには、 &lt;code&gt;chmod +x script-name&lt;/code&gt; ます。）</target>
        </trans-unit>
        <trans-unit id="66b2e146ed4ec9e49f678bedfee3350f88534599" translate="yes" xml:space="preserve">
          <source>As any variable that occurs in the head of a fun is considered a new variable, it is equally valid to write as follows:</source>
          <target state="translated">funの先頭に発生した変数はすべて新しい変数とみなされるので、以下のように書いても同じように有効です。</target>
        </trans-unit>
        <trans-unit id="90f853228a72190e3c182428d8aa021055665aa1" translate="yes" xml:space="preserve">
          <source>As can be noted above, the parameter list can be matched against a single &lt;code&gt;MatchVariable&lt;/code&gt; or an &lt;code&gt;'_'&lt;/code&gt;. To replace the whole parameter list with a single variable is a special case. In all other cases the &lt;code&gt;MatchHead&lt;/code&gt; must be a &lt;strong&gt;proper&lt;/strong&gt; list.</source>
          <target state="translated">上記のように、パラメーターリストは単一の &lt;code&gt;MatchVariable&lt;/code&gt; または &lt;code&gt;'_'&lt;/code&gt; と照合できます。パラメータリスト全体を単一の変数に置き換えることは、特殊なケースです。その他の場合はすべて &lt;code&gt;MatchHead&lt;/code&gt; が&lt;strong&gt;適切な&lt;/strong&gt;リストである必要があり&lt;strong&gt;ます&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="f45447aff436963dfcba66b79f762faf452d90b1" translate="yes" xml:space="preserve">
          <source>As can be seen from the figures above there is no real difference between a non-reentrant and an reentrant flex scanner when it comes to the decode times of an individual message.</source>
          <target state="translated">上の図からわかるように、個々のメッセージのデコード時間に関しては、ノンリエントラントとリエントラント・フレックス・スキャナの間に実際の違いはありません。</target>
        </trans-unit>
        <trans-unit id="5f43e75c9b3fbee4477b49b641a7fb630b3c13f5" translate="yes" xml:space="preserve">
          <source>As can be seen, the fun used with &lt;code&gt;dbg:fun2ms/1&lt;/code&gt; takes a single list as parameter instead of a single tuple. The list matches a list of the parameters to the traced function. A single variable can also be used. The body of the fun expresses, in a more imperative way, actions to be taken if the fun head (and the guards) matches. &lt;code&gt;true&lt;/code&gt; is returned here, only because the body of a fun cannot be empty. The return value is discarded.</source>
          <target state="translated">&lt;code&gt;dbg:fun2ms/1&lt;/code&gt; 、dbg：fun2ms / 1で使用される楽しみは、単一のタプルの代わりに単一のリストをパラメーターとして受け取ります。リストは、トレースされた関数のパラメーターのリストと一致します。単一の変数も使用できます。楽しみの本体は、より重要な方法で、楽しみの頭（およびガード）が一致した場合に実行するアクションを表現します。ここでは &lt;code&gt;true&lt;/code&gt; が返されます。これは、ファンの本文を空にすることができないためです。戻り値は破棄されます。</target>
        </trans-unit>
        <trans-unit id="606f60b3cba3318c2eecb57b2a49a6b6b1a39eb6" translate="yes" xml:space="preserve">
          <source>As can be seen, the functions above are just the type of functions that are to be provided in &lt;code&gt;get_until&lt;/code&gt; requests.</source>
          <target state="translated">ご覧のように、上記の関数は、提供される関数のタイプにすぎません &lt;code&gt;get_until&lt;/code&gt; リクエスト。</target>
        </trans-unit>
        <trans-unit id="191e8e1e5a9e73a6798b23edb476be7abc2c9de8" translate="yes" xml:space="preserve">
          <source>As default result sets are returned as a lists of tuples. The &lt;code&gt;TupleMode&lt;/code&gt; option still exists to keep some degree of backwards compatibility. If the option is set to off, result sets will be returned as a lists of lists instead of a lists of tuples.</source>
          <target state="translated">デフォルトでは、結果セットはタプルのリストとして返されます。の &lt;code&gt;TupleMode&lt;/code&gt; のオプションはまだ後方互換性をある程度維持するために存在しています。このオプションがオフに設定されている場合、結果セットはタプルのリストではなくリストのリストとして返されます。</target>
        </trans-unit>
        <trans-unit id="17700b7b2c5191dc7a064a620902163dd840f68f" translate="yes" xml:space="preserve">
          <source>As described in Robert's paper, I/O servers and clients communicate using &lt;code&gt;io_request&lt;/code&gt;/&lt;code&gt;io_reply&lt;/code&gt; tuples as follows:</source>
          <target state="translated">Robertの論文で説明されているように、I / Oサーバーとクライアントは &lt;code&gt;io_request&lt;/code&gt; / &lt;code&gt;io_reply&lt;/code&gt; を使用して通信しますタプルて次のようにます。</target>
        </trans-unit>
        <trans-unit id="d5e4f17183134fe62fa988455bb38a208a7f52d2" translate="yes" xml:space="preserve">
          <source>As documented, the election assumes knowledge of a peer's DiameterIdentity when initiating a connection, which diameter doesn't require. Connections will be accepted if configuration allows multiple connections per peer to be established or there is no existing connection. Note that the election process is only applicable when multiple connections per peer is disallowed.</source>
          <target state="translated">文書化されているように、接続を開始する際には、直径が必要としないピアの DiameterIdentity を知っていることを前提としています。接続は、ピアごとに複数の接続を確立できるように設定されている場合、または既存の接続が存在しない場合に受け入れられます。選挙処理は、ピアごとの複数の接続が許可されていない場合にのみ適用されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="5435f11ff35ae6054509834ff9cbbd3dacb50a82" translate="yes" xml:space="preserve">
          <source>As each event handler is one callback module, an event manager has many callback modules that are added and deleted dynamically. &lt;code&gt;gen_event&lt;/code&gt; is therefore more tolerant of callback module errors than the other behaviors. If a callback function for an installed event handler fails with &lt;code&gt;Reason&lt;/code&gt;, or returns a bad value &lt;code&gt;Term&lt;/code&gt;, the event manager does not fail. It deletes the event handler by calling callback function &lt;code&gt;&lt;a href=&quot;#Module:terminate-2&quot;&gt;Module:terminate/2&lt;/a&gt;&lt;/code&gt;, giving as argument &lt;code&gt;{error,{'EXIT',Reason}}&lt;/code&gt; or &lt;code&gt;{error,Term}&lt;/code&gt;, respectively. No other event handler is affected.</source>
          <target state="translated">各イベントハンドラーは1つのコールバックモジュールであるため、イベントマネージャーには動的に追加および削除される多くのコールバックモジュールがあります。したがって、 &lt;code&gt;gen_event&lt;/code&gt; は、他の動作よりもコールバックモジュールエラーに対して寛容です。インストールされたイベントハンドラーのコールバック関数が &lt;code&gt;Reason&lt;/code&gt; で失敗した場合、または不正な値 &lt;code&gt;Term&lt;/code&gt; を返した場合、イベントマネージャーは失敗しません。コールバック関数 &lt;code&gt;&lt;a href=&quot;#Module:terminate-2&quot;&gt;Module:terminate/2&lt;/a&gt;&lt;/code&gt; を呼び出してイベントハンドラーを削除し、引数として &lt;code&gt;{error,{'EXIT',Reason}}&lt;/code&gt; または &lt;code&gt;{error,Term}&lt;/code&gt; を指定します。他のイベントハンドラーは影響を受けません。</target>
        </trans-unit>
        <trans-unit id="cf9e38f9c03cb4cfe6ebeed4a9cd9c1754bcff3e" translate="yes" xml:space="preserve">
          <source>As evaluating this function causes the process to terminate, it has no return value unless the arguments are invalid, in which case the function &lt;strong&gt;returns the error reason&lt;/strong&gt;&lt;code&gt;badarg&lt;/code&gt;. If you want to be sure not to return, you can call &lt;code&gt;error(erlang:raise(Class, Reason, Stacktrace))&lt;/code&gt; and hope to distinguish exceptions later.</source>
          <target state="translated">この関数を評価するとプロセスが終了するため、引数が無効でない限り、戻り値はありません。その場合、関数&lt;strong&gt;はエラー理由&lt;/strong&gt; &lt;code&gt;badarg&lt;/code&gt; を&lt;strong&gt;返します&lt;/strong&gt;。確実に戻りたくない場合は、 &lt;code&gt;error(erlang:raise(Class, Reason, Stacktrace))&lt;/code&gt; 呼び出すことができます。を後で例外を区別することができます。</target>
        </trans-unit>
        <trans-unit id="2842aa39be48bf38b0c0560d59180375acac20be" translate="yes" xml:space="preserve">
          <source>As everyone trying to use &lt;code&gt;&lt;a href=&quot;ets#select-1&quot;&gt;ets:select/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;dbg&lt;/code&gt; seems to end up reading this manual page, this description is an introduction to the concept of match specifications.</source>
          <target state="translated">みんなが &lt;code&gt;&lt;a href=&quot;ets#select-1&quot;&gt;ets:select/2&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;dbg&lt;/code&gt; を使おうとしているのでこのマニュアルページを読むようになるため、この説明は一致仕様の概念の紹介です。</target>
        </trans-unit>
        <trans-unit id="91ed2cd090a035beba9495ca5c354901e71094c0" translate="yes" xml:space="preserve">
          <source>As expected, double of 10 is 20.</source>
          <target state="translated">さすがに10の倍は20。</target>
        </trans-unit>
        <trans-unit id="4e58a012dddf03e3db23dd481662a4b03cf78027" translate="yes" xml:space="preserve">
          <source>As far as we know by the time of writing, it is infeasible to break &lt;code&gt;des3_cbc&lt;/code&gt; encryption without any knowledge of the key. Therefore, as long as the key is kept safe and is unguessable, the encrypted debug information &lt;strong&gt;should&lt;/strong&gt; be safe from intruders.</source>
          <target state="translated">執筆時点でわかっている限り、鍵の知識なしに &lt;code&gt;des3_cbc&lt;/code&gt; 暗号化を解読することは不可能です。したがって、キーが安全に保たれ、推測できない限り、暗号化されたデバッグ情報&lt;strong&gt;は&lt;/strong&gt;侵入者から安全でなりん。</target>
        </trans-unit>
        <trans-unit id="9f24794a82149383ffae0568581aa4a52378ab67" translate="yes" xml:space="preserve">
          <source>As file times are stored in POSIX time on most OS, it is faster to query file information with option &lt;code&gt;posix&lt;/code&gt;.</source>
          <target state="translated">ほとんどのOSではファイル時間がPOSIX時間で保存されるため、オプション &lt;code&gt;posix&lt;/code&gt; を使用してファイル情報をクエリする方が高速です。</target>
        </trans-unit>
        <trans-unit id="61df7f84fe1d4826c5be72f8b4bc768821e8d381" translate="yes" xml:space="preserve">
          <source>As for &lt;code&gt;i/1&lt;/code&gt; and &lt;code&gt;ni/1&lt;/code&gt;, a module can be specified by its module name or filename.</source>
          <target state="translated">&lt;code&gt;i/1&lt;/code&gt; および &lt;code&gt;ni/1&lt;/code&gt; 、モジュールは、モジュール名またはファイル名で指定することができます。</target>
        </trans-unit>
        <trans-unit id="3a8f23a48e1867cb7be6b7e031f9615ed3dd2a0d" translate="yes" xml:space="preserve">
          <source>As for &lt;code&gt;select&lt;/code&gt;, the table is traversed by calling &lt;code&gt;&lt;a href=&quot;#select-3&quot;&gt;select/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt;. The difference is that the match specification is explicitly specified. This is how to state match specifications that cannot easily be expressed within the syntax provided by QLC.</source>
          <target state="translated">&lt;code&gt;select&lt;/code&gt; 、テーブルを呼び出すことによってトラバースされる &lt;code&gt;&lt;a href=&quot;#select-3&quot;&gt;select/3&lt;/a&gt;&lt;/code&gt; 及び &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt; 。違いは、一致指定が明示的に指定されていることです。これは、QLCが提供する構文内では簡単に表現できない仕様を一致させる方法です。</target>
        </trans-unit>
        <trans-unit id="f0387e8c16bce6477d55e9ca9b7e7cb6c002c7dd" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.10 all signals from processes to ports are truly asynchronously delivered.</source>
          <target state="translated">ERTS 5.10からは、プロセスからポートへのすべての信号は、真に非同期的に配信されます。</target>
        </trans-unit>
        <trans-unit id="54e61b5a72122095dbbd0cebf9a23eab4a8e63ab" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.5 (Erlang/OTP R11B), this value does not include reductions performed in current time slices of currently scheduled processes. If an exact value is wanted, use &lt;code&gt;&lt;a href=&quot;#statistics_exact_reductions&quot;&gt; statistics(exact_reductions)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ERTS 5.5（Erlang / OTP R11B）以降、この値には、現在スケジュールされているプロセスの現在のタイムスライスで実行された削減は含まれていません。正確な値が必要な場合は、 &lt;code&gt;&lt;a href=&quot;#statistics_exact_reductions&quot;&gt; statistics(exact_reductions)&lt;/a&gt;&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="e9113f3079af7b202922889fc7baf1985e8c3b0f" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.5 (Erlang/OTP R11B), this value does not include reductions performed in current time slices of currently scheduled processes. If an exact value is wanted, use &lt;code&gt;&lt;a href=&quot;#statistics_exact_reductions&quot;&gt;statistics(exact_reductions)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ERTS 5.5（Erlang / OTP R11B）以降、この値には、現在スケジュールされているプロセスの現在のタイムスライスで実行された削減は含まれていません。正確な値が必要な場合は、 &lt;code&gt;&lt;a href=&quot;#statistics_exact_reductions&quot;&gt;statistics(exact_reductions)&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="c9466fb03b2f8f448def70765eb14302f05b1d4a" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.5.2 exit signals to processes are truly asynchronously delivered.</source>
          <target state="translated">ERTS 5.5.2 以降、プロセスへの終了信号は真に非同期的に配信される。</target>
        </trans-unit>
        <trans-unit id="29adb187efe70ae7ea9eb1516c814ba1bd886f73" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.5.3 the driver interface has been extended (see &lt;code&gt;&lt;a href=&quot;driver_entry#extended_marker&quot;&gt; extended marker&lt;/a&gt;&lt;/code&gt;). The extended interface introduces &lt;code&gt;&lt;a href=&quot;#version_management&quot;&gt;version management&lt;/a&gt;&lt;/code&gt;, the possibility to pass capability flags (see &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt; driver_flags&lt;/a&gt;&lt;/code&gt;) to the runtime system at driver initialization, and some new driver API functions.</source>
          <target state="translated">ERTS 5.5.3以降、ドライバーインターフェイスが拡張されました（ &lt;code&gt;&lt;a href=&quot;driver_entry#extended_marker&quot;&gt; extended marker&lt;/a&gt;&lt;/code&gt; 参照）。拡張インターフェースでは、 &lt;code&gt;&lt;a href=&quot;#version_management&quot;&gt;version management&lt;/a&gt;&lt;/code&gt; 、ドライバーの初期化時に機能フラグ（ &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt; driver_flags&lt;/a&gt;&lt;/code&gt; を参照）をランタイムシステムに渡す可能性、およびいくつかの新しいドライバーAPI関数が導入されています。</target>
        </trans-unit>
        <trans-unit id="0d8b23980173959043ec4b6b8e4640034ae1c36c" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.5.3 the driver interface has been extended (see &lt;code&gt;&lt;a href=&quot;driver_entry#extended_marker&quot;&gt;extended marker&lt;/a&gt;&lt;/code&gt;). The extended interface introduces &lt;code&gt;&lt;a href=&quot;#version_management&quot;&gt;version management&lt;/a&gt;&lt;/code&gt;, the possibility to pass capability flags (see &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;driver_flags&lt;/a&gt;&lt;/code&gt;) to the runtime system at driver initialization, and some new driver API functions.</source>
          <target state="translated">ERTS 5.5.3以降、ドライバーインターフェイスが拡張されました（ &lt;code&gt;&lt;a href=&quot;driver_entry#extended_marker&quot;&gt;extended marker&lt;/a&gt;&lt;/code&gt; 参照）。拡張インターフェースは、 &lt;code&gt;&lt;a href=&quot;#version_management&quot;&gt;version management&lt;/a&gt;&lt;/code&gt; 、ドライバーの初期化時にランタイムシステムに機能フラグ（ &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;driver_flags&lt;/a&gt;&lt;/code&gt; を参照）を渡す可能性、およびいくつかの新しいドライバーAPI関数を導入します。</target>
        </trans-unit>
        <trans-unit id="cc982ada8a0ef67bfd186892ad9105718b94c2a0" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.5.3 the driver interface was extended with version control and the possibility to pass capability information. Capability flags are present on line 48. As from ERTS 5.7.4 flag &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt; ERL_DRV_FLAG_SOFT_BUSY&lt;/a&gt;&lt;/code&gt; is required for drivers that are to be used by the distribution. The soft busy flag implies that the driver can handle calls to the &lt;code&gt;output&lt;/code&gt; and &lt;code&gt;outputv&lt;/code&gt; callbacks although it has marked itself as busy. This has always been a requirement on drivers used by the distribution, but no capability information has been available about this previously. For more information. see &lt;code&gt;&lt;a href=&quot;erl_driver#set_busy_port&quot;&gt; erl_driver:set_busy_port()&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">ERTS 5.5.3以降、ドライバーインターフェイスはバージョン管理と機能情報を渡す可能性で拡張されました。機能フラグは48行目にあります &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt; ERL_DRV_FLAG_SOFT_BUSY&lt;/a&gt;&lt;/code&gt; 、ディストリビューションで使用されるドライバーにはERL_DRV_FLAG_SOFT_BUSYが必要です。ソフトビジーフラグは、ドライバーがビジーとしてマークされていても、 &lt;code&gt;output&lt;/code&gt; および &lt;code&gt;outputv&lt;/code&gt; コールバックへの呼び出しを処理できることを意味します。これは、ディストリビューションで使用されるドライバーの要件でしたが、これまで機能情報はありませんでした。詳細については。 &lt;code&gt;&lt;a href=&quot;erl_driver#set_busy_port&quot;&gt; erl_driver:set_busy_port()&lt;/a&gt;&lt;/code&gt; を参照してください）。</target>
        </trans-unit>
        <trans-unit id="19ca09aeee3e5a4978501284aa2a30557b389ea8" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.5.3 the driver interface was extended with version control and the possibility to pass capability information. Capability flags are present on line 48. As from ERTS 5.7.4 flag &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;ERL_DRV_FLAG_SOFT_BUSY&lt;/a&gt;&lt;/code&gt; is required for drivers that are to be used by the distribution. The soft busy flag implies that the driver can handle calls to the &lt;code&gt;output&lt;/code&gt; and &lt;code&gt;outputv&lt;/code&gt; callbacks although it has marked itself as busy. This has always been a requirement on drivers used by the distribution, but no capability information has been available about this previously. For more information. see &lt;code&gt;&lt;a href=&quot;erl_driver#set_busy_port&quot;&gt;erl_driver:set_busy_port()&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">ERTS 5.5.3以降、ドライバーインターフェイスはバージョン管理と機能情報を渡す可能性で拡張されました。能力フラグはERTS 5.7.4フラグから、ライン48上に存在する &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;ERL_DRV_FLAG_SOFT_BUSY&lt;/a&gt;&lt;/code&gt; を配布で使用されるドライバのために必要とされます。ソフトビジーフラグは、ドライバーがビジーとしてマークされていても、ドライバーが &lt;code&gt;output&lt;/code&gt; および &lt;code&gt;outputv&lt;/code&gt; コールバックへの呼び出しを処理できることを意味します。これは常にディストリビューションで使用されるドライバーの要件でしたが、これに関する以前の機能情報はありませんでした。詳細については。 &lt;code&gt;&lt;a href=&quot;erl_driver#set_busy_port&quot;&gt;erl_driver:set_busy_port()&lt;/a&gt;&lt;/code&gt; を参照してください）。</target>
        </trans-unit>
        <trans-unit id="9a78fa09b1376522e4bce196c1fb535907b82e7d" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.5.4.3 the default stack size for threads in the async-thread pool is 16 kilowords, that is, 64 kilobyte on 32-bit architectures. This small default size has been chosen because the amount of async-threads can be quite large. The default stack size is enough for drivers delivered with Erlang/OTP, but is possibly not sufficiently large for other dynamically linked-in drivers that use the &lt;code&gt;driver_async&lt;/code&gt; functionality. A suggested stack size for threads in the async-thread pool can be configured through command-line argument &lt;code&gt;&lt;a href=&quot;erl#async_thread_stack_size&quot;&gt;+a&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ERTS 5.5.4.3以降、非同期スレッドプール内のスレッドのデフォルトのスタックサイズは16キロワード、つまり32ビットアーキテクチャでは64キロバイトです。非同期スレッドの量が非常に大きくなる可能性があるため、この小さなデフォルトサイズが選択されています。デフォルトのスタックサイズは、Erlang / OTPで提供されるドライバーには十分ですが、 &lt;code&gt;driver_async&lt;/code&gt; 機能を使用する他の動的にリンクされたドライバーには十分でない可能性があります。非同期スレッドプール内のスレッドの推奨スタックサイズ &lt;code&gt;&lt;a href=&quot;erl#async_thread_stack_size&quot;&gt;+a&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt; のコマンドライン引数+ aで構成できます。</target>
        </trans-unit>
        <trans-unit id="a6e9cd2bd7de01214fb3ff560ba3219fdc3a33fd" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.6.1 the emulator refuses to use this strategy on other allocators than &lt;code&gt;temp_alloc&lt;/code&gt;. This because it only causes problems for other allocators.</source>
          <target state="translated">ERTS 5.6.1以降、エミュレータは &lt;code&gt;temp_alloc&lt;/code&gt; 以外のアロケータでこの戦略を使用することを拒否しています。これは、他のアロケータに対してのみ問題が発生するためです。</target>
        </trans-unit>
        <trans-unit id="c9cdb7d3c60a1b802e1be9fa56092fa96daa0110" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.6.4, &lt;code&gt;erlang:memory/0&lt;/code&gt; requires that all &lt;code&gt;erts_alloc(3)&lt;/code&gt; allocators are enabled (default behavior).</source>
          <target state="translated">ERTS 5.6.4以降、 &lt;code&gt;erlang:memory/0&lt;/code&gt; では、すべての &lt;code&gt;erts_alloc(3)&lt;/code&gt; アロケーターが有効になっている必要があります（デフォルトの動作）。</target>
        </trans-unit>
        <trans-unit id="0648017001664f8866e87e3887eab6500d7d8d5c" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.6.4, &lt;code&gt;erlang:memory/1&lt;/code&gt; requires that all &lt;code&gt;&lt;a href=&quot;erts_alloc&quot;&gt;erts_alloc(3)&lt;/a&gt;&lt;/code&gt; allocators are enabled (default behavior).</source>
          <target state="translated">ERTS 5.6.4以降、 &lt;code&gt;erlang:memory/1&lt;/code&gt; では、すべての &lt;code&gt;&lt;a href=&quot;erts_alloc&quot;&gt;erts_alloc(3)&lt;/a&gt;&lt;/code&gt; アロケーターが有効になっている必要があります（デフォルトの動作）。</target>
        </trans-unit>
        <trans-unit id="03c3044d6f35884274a0ea9ce93bcb4a6dd2e7b8" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.7.2 the old atom cache protocol was dropped and a new one was introduced. This protocol introduced the distribution header. Nodes with an ERTS version earlier than 5.7.2 can still communicate with new nodes, but no distribution header and no atom cache are used.</source>
          <target state="translated">ERTS 5.7.2から、古いアトムキャッシュプロトコルは廃止され、新しいプロトコルが導入されました。このプロトコルではディストリビューションヘッダが導入された。5.7.2より前のERTSバージョンを持つノードは、新しいノードとの通信は可能ですが、ディストリビューションヘッダやアトムキャッシュは使用されません。</target>
        </trans-unit>
        <trans-unit id="d0bf3fb747dbb4638699932cce5b52da0fd8c732" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.7.2 the runtime system passes a distribution flag in the handshake stage that enables the use of a &lt;code&gt;&lt;a href=&quot;erl_ext_dist#distribution_header&quot;&gt;distribution header&lt;/a&gt;&lt;/code&gt; on all messages passed. Messages passed between nodes have in this case the following format:</source>
          <target state="translated">ERTS 5.7.2以降、ランタイムシステムはハンドシェイクステージで配布フラグを渡し、渡されたすべてのメッセージで &lt;code&gt;&lt;a href=&quot;erl_ext_dist#distribution_header&quot;&gt;distribution header&lt;/a&gt;&lt;/code&gt; を使用できるようにします。この場合、ノード間で渡されるメッセージの形式は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="1259b645a71eafd28a440edcc0bee42c289d29ad" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.9 (Erlang/OTP R15B) the driver interface has been changed with larger types for the callbacks &lt;code&gt;&lt;a href=&quot;#output&quot;&gt;output&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#control&quot;&gt;control&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#call&quot;&gt;call&lt;/a&gt;&lt;/code&gt;. See driver &lt;code&gt;&lt;a href=&quot;erl_driver#version_management&quot;&gt; version management&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;erl_driver&quot;&gt;erl_driver&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ERTS 5.9（Erlang / OTP R15B）以降、ドライバーインターフェイスが変更され、コールバックの &lt;code&gt;&lt;a href=&quot;#output&quot;&gt;output&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;#control&quot;&gt;control&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;#call&quot;&gt;call&lt;/a&gt;&lt;/code&gt; タイプが大きくなりました。 &lt;code&gt;&lt;a href=&quot;erl_driver&quot;&gt;erl_driver&lt;/a&gt;&lt;/code&gt; のドライバー &lt;code&gt;&lt;a href=&quot;erl_driver#version_management&quot;&gt; version management&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="32ca42b8d63db763c29dc94fc4d01b222bd06006" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.9 (Erlang/OTP R15B) the driver interface has been changed with larger types for the callbacks &lt;code&gt;&lt;a href=&quot;#output&quot;&gt;output&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#control&quot;&gt;control&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#call&quot;&gt;call&lt;/a&gt;&lt;/code&gt;. See driver &lt;code&gt;&lt;a href=&quot;erl_driver#version_management&quot;&gt;version management&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;erl_driver&quot;&gt;erl_driver&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ERTS 5.9（Erlang / OTP R15B）以降、コールバックの &lt;code&gt;&lt;a href=&quot;#output&quot;&gt;output&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;#control&quot;&gt;control&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;#call&quot;&gt;call&lt;/a&gt;&lt;/code&gt; のドライバーインターフェイスがより大きなタイプに変更されました。 &lt;code&gt;&lt;a href=&quot;erl_driver&quot;&gt;erl_driver&lt;/a&gt;&lt;/code&gt; のドライバー &lt;code&gt;&lt;a href=&quot;erl_driver#version_management&quot;&gt;version management&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="ed0ea6cc1d812d63e5d244adc339b28e36e76666" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.9 (Erlang/OTP R15B) the runtime system does by default &lt;strong&gt;not&lt;/strong&gt; bind schedulers to logical processors. For more information, see system flag &lt;code&gt;&lt;a href=&quot;#+sbt&quot;&gt;+sbt&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ERTS 5.9（Erlang / OTP R15B）以降、ランタイムシステムはデフォルトでスケジューラーを論理プロセッサーにバインドし&lt;strong&gt;ません&lt;/strong&gt;。詳細については、システムフラグ &lt;code&gt;&lt;a href=&quot;#+sbt&quot;&gt;+sbt&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="8eaab9a3708d0c05a100d946be7959ae31e3845a" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.9 old drivers must be recompiled and use the extended interface. They must also be adjusted to the &lt;code&gt;&lt;a href=&quot;#rewrites_for_64_bits&quot;&gt; 64-bit capable driver interface&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ERTS 5.9以降、古いドライバーを再コンパイルして、拡張インターフェイスを使用する必要があります。また、 &lt;code&gt;&lt;a href=&quot;#rewrites_for_64_bits&quot;&gt; 64-bit capable driver interface&lt;/a&gt;&lt;/code&gt; 調整する必要があります。</target>
        </trans-unit>
        <trans-unit id="90a69eabde7b774111db809b2a3f8cd2e6d93bb9" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.9 old drivers must be recompiled and use the extended interface. They must also be adjusted to the &lt;code&gt;&lt;a href=&quot;#rewrites_for_64_bits&quot;&gt;64-bit capable driver interface&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ERTS 5.9以降、古いドライバーを再コンパイルして、拡張インターフェースを使用する必要があります。また、 &lt;code&gt;&lt;a href=&quot;#rewrites_for_64_bits&quot;&gt;64-bit capable driver interface&lt;/a&gt;&lt;/code&gt; 合わせて調整する必要があります。</target>
        </trans-unit>
        <trans-unit id="d18bc1c72ccf3f56d64803c503d7a9ae14a8c4e0" translate="yes" xml:space="preserve">
          <source>As from ERTS 8.0 (Erlang/OTP 19), any lingering processes that still execute the old code is killed by this function. In earlier versions, such incorrect use could cause much more fatal failures, like emulator crash.</source>
          <target state="translated">ERTS 8.0 (Erlang/OTP 19)から、古いコードをまだ実行しているプロセスはこの関数によって殺されます。以前のバージョンでは、このような間違った使い方をすると、エミュレータのクラッシュのような致命的な失敗を引き起こす可能性がありました。</target>
        </trans-unit>
        <trans-unit id="eaa0884ce96d8d06eafbfe246ea264efc463f164" translate="yes" xml:space="preserve">
          <source>As from ERTS 9.0 (OTP 20), atoms may contain any Unicode characters and are always encoded using the UTF-8 external formats &lt;code&gt;&lt;a href=&quot;#ATOM_UTF8_EXT&quot;&gt;ATOM_UTF8_EXT&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#SMALL_ATOM_UTF8_EXT&quot;&gt;SMALL_ATOM_UTF8_EXT&lt;/a&gt;&lt;/code&gt;. The old Latin-1 formats &lt;code&gt;&lt;a href=&quot;#ATOM_EXT&quot;&gt;ATOM_EXT&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#SMALL_ATOM_EXT&quot;&gt;SMALL_ATOM_EXT&lt;/a&gt;&lt;/code&gt; are deprecated and are only kept for backward compatibility when decoding terms encoded by older nodes.</source>
          <target state="translated">ERTS 9.0（OTP 20）以降、アトムは任意のUnicode文字を含むことができ、常にUTF-8外部フォーマット &lt;code&gt;&lt;a href=&quot;#ATOM_UTF8_EXT&quot;&gt;ATOM_UTF8_EXT&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;#SMALL_ATOM_UTF8_EXT&quot;&gt;SMALL_ATOM_UTF8_EXT&lt;/a&gt;&lt;/code&gt; を使用してエンコードされます。古いLatin-1形式の &lt;code&gt;&lt;a href=&quot;#ATOM_EXT&quot;&gt;ATOM_EXT&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;#SMALL_ATOM_EXT&quot;&gt;SMALL_ATOM_EXT&lt;/a&gt;&lt;/code&gt; は非推奨であり、古いノードによってエンコードされた用語をデコードするときの下位互換性のためにのみ保持されます。</target>
        </trans-unit>
        <trans-unit id="c56c4f98abd4a60cd0f47b8e3c9a0926a671f166" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP 17, the OTP release number corresponds to the major OTP version number. No &lt;code&gt;erlang:system_info()&lt;/code&gt; argument gives the exact OTP version. This is because the exact OTP version in the general case is difficult to determine. For more information, see the description of versions in &lt;code&gt; System principles&lt;/code&gt; in System Documentation.</source>
          <target state="translated">Erlang / OTP 17以降、OTPリリース番号はメジャーOTPバージョン番号に対応しています。 &lt;code&gt;erlang:system_info()&lt;/code&gt; 引数は正確なOTPバージョンを提供しません。これは、一般的な場合の正確なOTPバージョンを判別するのが難しいためです。詳細については、システムドキュメントの &lt;code&gt; System principles&lt;/code&gt; のバージョンの説明を参照してください。</target>
        </trans-unit>
        <trans-unit id="432b2e5b8c0948df031dfa90355327eda74cb917" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP 17, the OTP release number corresponds to the major OTP version number. No &lt;code&gt;erlang:system_info()&lt;/code&gt; argument gives the exact OTP version. This is because the exact OTP version in the general case is difficult to determine. For more information, see the description of versions in &lt;code&gt;System principles&lt;/code&gt; in System Documentation.</source>
          <target state="translated">Erlang / OTP 17以降、OTPリリース番号はメジャーOTPバージョン番号に対応しています。 &lt;code&gt;erlang:system_info()&lt;/code&gt; 引数は、正確なOTPバージョンを示しません。これは、一般的な場合の正確なOTPバージョンを判別することが難しいためです。詳細については、システムドキュメントの &lt;code&gt;System principles&lt;/code&gt; のバージョンの説明を参照してください。</target>
        </trans-unit>
        <trans-unit id="a73c626964af738d0bf5772ed44b01c65f1937d2" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP 18 (ERTS 7.0) the time functionality has been extended. This includes a &lt;code&gt;&lt;a href=&quot;#The_New_Time_API&quot;&gt;new API&lt;/a&gt;&lt;/code&gt; for time and &lt;code&gt;&lt;a href=&quot;#Time_Warp_Modes&quot;&gt;time warp modes&lt;/a&gt;&lt;/code&gt; that change the system behavior when system time changes.</source>
          <target state="translated">Erlang / OTP 18（ERTS 7.0）以降、時間機能が拡張されました。これには、システム時間が変更されたときにシステムの動作を変更する時間および &lt;code&gt;&lt;a href=&quot;#Time_Warp_Modes&quot;&gt;time warp modes&lt;/a&gt;&lt;/code&gt; 用の &lt;code&gt;&lt;a href=&quot;#The_New_Time_API&quot;&gt;new API&lt;/a&gt;&lt;/code&gt; 含まれます。</target>
        </trans-unit>
        <trans-unit id="ecb4c90c54fe542574fe5a3d1dc6ac0bee28192e" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP 20, &lt;code&gt;String&lt;/code&gt; may contain any Unicode character. Earlier versions allowed only ISO-latin-1 characters as the implementation did not allow Unicode characters above 255. For more information on Unicode support in atoms, see &lt;code&gt;&lt;a href=&quot;erl_ext_dist#utf8_atoms&quot;&gt;note on UTF-8 encoded atoms&lt;/a&gt;&lt;/code&gt; in section &quot;External Term Format&quot; in the User's Guide.</source>
          <target state="translated">Erlang / OTP 20以降、 &lt;code&gt;String&lt;/code&gt; は任意のUnicode文字を含めることができます。以前のバージョンでは、実装が255を超えるUnicode文字を許可していなかったため、ISO-latin-1文字しか使用できませんでした。アトムでのUnicodeサポートの詳細については、ユーザーズガイドの「外部用語形式」セクションの &lt;code&gt;&lt;a href=&quot;erl_ext_dist#utf8_atoms&quot;&gt;note on UTF-8 encoded atoms&lt;/a&gt;&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="a96169a26804822b5af1efdb6e68b574110fb9b3" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP 20, &lt;code&gt;binary_to_atom(Binary, utf8)&lt;/code&gt; is capable of encoding any Unicode character. Earlier versions would fail if the binary contained Unicode characters &amp;gt; 255. For more information about Unicode support in atoms, see the &lt;code&gt;&lt;a href=&quot;erl_ext_dist#utf8_atoms&quot;&gt;note on UTF-8 encoded atoms&lt;/a&gt;&lt;/code&gt; in section &quot;External Term Format&quot; in the User's Guide.</source>
          <target state="translated">Erlang / OTP 20以降、 &lt;code&gt;binary_to_atom(Binary, utf8)&lt;/code&gt; は任意のUnicode文字をエンコードできます。バイナリに255を超えるUnicode文字が含まれている場合、以前のバージョンは失敗します。アトムでのUnicodeサポートの詳細については、ユーザーズガイドの「外部用語形式」セクションの &lt;code&gt;&lt;a href=&quot;erl_ext_dist#utf8_atoms&quot;&gt;note on UTF-8 encoded atoms&lt;/a&gt;&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="880a395a4cc835daf564a6c2cb8b779237ad447e" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP 20, atoms can contain any Unicode character and &lt;code&gt;atom_to_binary(Atom, latin1)&lt;/code&gt; may fail if the text representation for &lt;code&gt;Atom&lt;/code&gt; contains a Unicode character &amp;gt; 255.</source>
          <target state="translated">Erlang / OTP 20以降、 &lt;code&gt;atom_to_binary(Atom, latin1)&lt;/code&gt; は任意のUnicode文字を含めることができ、 &lt;code&gt;Atom&lt;/code&gt; のテキスト表現にUnicode文字&amp;gt; 255が含まれている場合、atom_to_binary（Atom、latin1）は失敗する可能性があります。</target>
        </trans-unit>
        <trans-unit id="05e99f10299c611eb38d2e60ef290380c488aab4" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP 21.0, a field width of value &lt;code&gt;0&lt;/code&gt; can be used for specifying that a line is infinitely long, which means that no line breaks are inserted. For example:</source>
          <target state="translated">Erlang / OTP 21.0以降では、値 &lt;code&gt;0&lt;/code&gt; のフィールド幅を使用して、行が無限に長いことを指定できます。つまり、改行は挿入されません。例えば：</target>
        </trans-unit>
        <trans-unit id="634c1d87386aa4426d0d529b4d45ffef570a789c" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP R13A, data supplied to function &lt;code&gt;&lt;a href=&quot;#put_chars-2&quot;&gt;put_chars/2&lt;/a&gt;&lt;/code&gt; is to be in the &lt;code&gt;&lt;a href=&quot;unicode#type-chardata&quot;&gt; unicode:chardata()&lt;/a&gt;&lt;/code&gt; format. This means that programs supplying binaries to this function must convert them to UTF-8 before trying to output the data on an I/O device.</source>
          <target state="translated">Erlang / OTP R13Aと同様に、関数 &lt;code&gt;&lt;a href=&quot;#put_chars-2&quot;&gt;put_chars/2&lt;/a&gt;&lt;/code&gt; に提供されるデータは、 &lt;code&gt;&lt;a href=&quot;unicode#type-chardata&quot;&gt; unicode:chardata()&lt;/a&gt;&lt;/code&gt; 形式になります。つまり、この関数にバイナリを提供するプログラムは、I / Oデバイスにデータを出力する前に、それらをUTF-8に変換する必要があります。</target>
        </trans-unit>
        <trans-unit id="201cedcfe08f8b8dd67e3f18b939fb9656e57837" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP R13A, data supplied to function &lt;code&gt;&lt;a href=&quot;#put_chars-2&quot;&gt;put_chars/2&lt;/a&gt;&lt;/code&gt; is to be in the &lt;code&gt;&lt;a href=&quot;unicode#type-chardata&quot;&gt;unicode:chardata()&lt;/a&gt;&lt;/code&gt; format. This means that programs supplying binaries to this function must convert them to UTF-8 before trying to output the data on an I/O device.</source>
          <target state="translated">Erlang / OTP R13Aと同様に、関数 &lt;code&gt;&lt;a href=&quot;#put_chars-2&quot;&gt;put_chars/2&lt;/a&gt;&lt;/code&gt; に提供されるデータは &lt;code&gt;&lt;a href=&quot;unicode#type-chardata&quot;&gt;unicode:chardata()&lt;/a&gt;&lt;/code&gt; 形式になります。つまり、この関数にバイナリを提供するプログラムは、I / Oデバイスにデータを出力する前に、それらをUTF-8に変換する必要があります。</target>
        </trans-unit>
        <trans-unit id="d33e90079df692505b294a1290c3639aac4d952d" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP R16, &lt;code&gt;Port ! {PortOwner, close}&lt;/code&gt; is truly asynchronous. Notice that this operation has always been documented as an asynchronous operation, while the underlying implementation has been synchronous. &lt;code&gt;port_close/1&lt;/code&gt; is however still fully synchronous because of its error behavior.</source>
          <target state="translated">Erlang / OTP R16から、 &lt;code&gt;Port ! {PortOwner, close}&lt;/code&gt; は完全に非同期です。この操作は常に非同期操作として文書化されているが、基礎となる実装は同期的であることに注意してください。ただし、 &lt;code&gt;port_close/1&lt;/code&gt; は、エラー動作のため、完全に同期しています。</target>
        </trans-unit>
        <trans-unit id="847e19f07a1da0af86460018529c6ed10c09d277" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP R16, &lt;code&gt;Port ! {PortOwner, {command, Data}}&lt;/code&gt; is truly asynchronous. Notice that this operation has always been documented as an asynchronous operation, while the underlying implementation has been synchronous. &lt;code&gt;port_command/2&lt;/code&gt; is however still fully synchronous because of its error behavior.</source>
          <target state="translated">Erlang / OTP R16から、 &lt;code&gt;Port ! {PortOwner, {command, Data}}&lt;/code&gt; は完全に非同期です。この操作は常に非同期操作として文書化されているが、基礎となる実装は同期的であることに注意してください。ただし、 &lt;code&gt;port_command/2&lt;/code&gt; は、エラー動作のため、完全に同期しています。</target>
        </trans-unit>
        <trans-unit id="5ca95bf5c29d60d3f435edb308337e14ca27dfa7" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP R16, &lt;code&gt;Port ! {PortOwner, {connect, Pid}}&lt;/code&gt; is truly asynchronous. Notice that this operation has always been documented as an asynchronous operation, while the underlying implementation has been synchronous. &lt;code&gt;port_connect/2&lt;/code&gt; is however still fully synchronous because of its error behavior.</source>
          <target state="translated">Erlang / OTP R16から、 &lt;code&gt;Port ! {PortOwner, {connect, Pid}}&lt;/code&gt; は完全に非同期です。この操作は常に非同期操作として文書化されているが、基礎となる実装は同期的であることに注意してください。ただし、 &lt;code&gt;port_connect/2&lt;/code&gt; は、エラー動作のため、完全に同期しています。</target>
        </trans-unit>
        <trans-unit id="72f6bdc7a49b76220d72f254a24c40ac2103b81f" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP R16, Erlang source files can be written in UTF-8 or bytewise (&lt;code id=&quot;unicode_in_erlang&quot;&gt;latin1&lt;/code&gt;) encoding. For information about how to state the encoding of an Erlang source file, see the &lt;code&gt;epp(3)&lt;/code&gt; module. As from Erlang/OTP R16, strings and comments can be written using Unicode. As from Erlang/OTP 20, also atoms and functions can be written using Unicode. Modules, applications, and nodes must still be named using characters from the ISO Latin-1 character set. (These restrictions in the language are independent of the encoding of the source file.)</source>
          <target state="translated">Erlang / OTP R16以降、ErlangソースファイルはUTF-8またはバイト単位（ &lt;code id=&quot;unicode_in_erlang&quot;&gt;latin1&lt;/code&gt; ）エンコーディングで記述できます。 Erlangソースファイルのエンコーディングの &lt;code&gt;epp(3)&lt;/code&gt; については、epp（3）モジュールを参照してください。 Erlang / OTP R16以降、文字列とコメントはUnicodeを使用して記述できます。 Erlang / OTP 20以降、アトムと関数もUnicodeを使用して記述できます。モジュール、アプリケーション、およびノー​​ドは、ISO Latin-1文字セットの文字を使用して名前を付ける必要があります。 （言語におけるこれらの制限は、ソースファイルのエンコーディングとは無関係です。）</target>
        </trans-unit>
        <trans-unit id="7886b46a773db0e50442aecaebbaf32b222b9fd4" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP R16B you can select the ISO Latin-1 range or the whole Unicode range by supplying startup flag &lt;code&gt;+pc latin1&lt;/code&gt; or &lt;code&gt;+pc unicode&lt;/code&gt;, respectively. For backward compatibility, &lt;code&gt;latin1&lt;/code&gt; is default. This only controls how heuristic string detection is done. More ranges are expected to be added in the future, enabling tailoring of the heuristics to the language and region relevant to the user.</source>
          <target state="translated">Erlang / OTP R16B以降では、起動フラグ &lt;code&gt;+pc latin1&lt;/code&gt; または &lt;code&gt;+pc unicode&lt;/code&gt; をそれぞれ指定することにより、ISO Latin-1範囲またはUnicode範囲全体を選択できます。下位互換性のために、 &lt;code&gt;latin1&lt;/code&gt; がデフォルトです。これは、ヒューリスティックな文字列検出が行われる方法を制御するだけです。今後、さらに範囲が追加され、ユーザーに関連する言語と地域に合わせてヒューリスティックを調整できるようになる予定です。</target>
        </trans-unit>
        <trans-unit id="716bfb66439cef7ad7bad31829606da528f05b26" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP R9C, the &lt;code&gt;abstract_code&lt;/code&gt; chunk contains &lt;code&gt;{raw_abstract_v1,AbstractCode}&lt;/code&gt;, where &lt;code&gt;AbstractCode&lt;/code&gt; is the abstract code as described in this section.</source>
          <target state="translated">アーラン/ OTP R9Cからように、 &lt;code&gt;abstract_code&lt;/code&gt; のチャンクが含ま &lt;code&gt;{raw_abstract_v1,AbstractCode}&lt;/code&gt; 、 &lt;code&gt;AbstractCode&lt;/code&gt; は、このセクションで説明したように抽象コードです。</target>
        </trans-unit>
        <trans-unit id="79439af412211da1e82f500e663913d9e02afa8d" translate="yes" xml:space="preserve">
          <source>As from Kernel version 2.11.4, and ERTS version 5.5.4, the following is guaranteed:</source>
          <target state="translated">Kernelバージョン2.11.4、ERTSバージョン5.5.4からは、以下のことが保証されています。</target>
        </trans-unit>
        <trans-unit id="e6086f606b9a19f3992ba56f0349c22f46bc841b" translate="yes" xml:space="preserve">
          <source>As from Kernel version 2.11.4, subscriptions can also be made before the &lt;code&gt;net_kernel&lt;/code&gt; server is started, that is, &lt;code&gt;net_kernel:monitor_nodes/[1,2]&lt;/code&gt; does not return &lt;code&gt;ignored&lt;/code&gt;.</source>
          <target state="translated">前のカーネルのバージョン2.11.4からとして、サブスクリプションを行うこともできる &lt;code&gt;net_kernel&lt;/code&gt; のサーバーが開始された、あること、 &lt;code&gt;net_kernel:monitor_nodes/[1,2]&lt;/code&gt; は戻りません &lt;code&gt;ignored&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a12edcd68388680c33d418efadc851c1c0e7b367" translate="yes" xml:space="preserve">
          <source>As from Kernel version 2.13, and ERTS version 5.7, the following is guaranteed:</source>
          <target state="translated">カーネルバージョン2.13、ERTSバージョン5.7からは、以下を保証しています。</target>
        </trans-unit>
        <trans-unit id="2c683a693696d1ac1e9f3a076bd2cf07e0602bc8" translate="yes" xml:space="preserve">
          <source>As from R14A and forward, the compiler resolves calls without module prefix to local or imported functions before trying with auto-imported BIFs. If the BIF is to be called, use the &lt;code&gt;erlang&lt;/code&gt; module prefix in the call, not &lt;code&gt;{no_auto_import,[{F,A}, ...]}&lt;/code&gt;.</source>
          <target state="translated">R14A以降では、自動インポートされたBIFを試す前に、コンパイラーはモジュール接頭辞のない呼び出しをローカル関数またはインポートされた関数に解決します。BIFを呼び出す場合は、呼び出しで &lt;code&gt;{no_auto_import,[{F,A}, ...]}&lt;/code&gt; ではなく、 &lt;code&gt;erlang&lt;/code&gt; モジュールのプレフィックスを使用します。</target>
        </trans-unit>
        <trans-unit id="23bc1a56d40682c98cebd327d476b5499f2bfa45" translate="yes" xml:space="preserve">
          <source>As from beginning with R14A, the compiler no longer calls the auto-imported BIF if the name clashes with a local or explicitly imported function, and a call without explicit module name is issued. Instead, the local or imported function is called. Still accepting &lt;code&gt;nowarn_bif_clash&lt;/code&gt; would make a module calling functions clashing with auto-imported BIFs compile with both the old and new compilers, but with completely different semantics. This is why the option is removed.</source>
          <target state="translated">R14A以降、名前がローカル関数または明示的にインポートされた関数と競合し、明示的なモジュール名のない呼び出しが発行された場合、コンパイラーは自動インポートされたBIFを呼び出さなくなりました。代わりに、ローカル関数またはインポートされた関数が呼び出されます。 &lt;code&gt;nowarn_bif_clash&lt;/code&gt; を引き続き受け入れると、自動インポートされたBIFと競合するモジュール呼び出し関数は、古いコンパイラと新しいコンパイラの両方でコンパイルされますが、セマンティクスはまったく異なります。これが、オプションが削除された理由です。</target>
        </trans-unit>
        <trans-unit id="8624ad0f786ca708e353d31a82300424a2da173c" translate="yes" xml:space="preserve">
          <source>As functions are relations, the definitions of the last item (domain, range, and so on) apply to functions as well.</source>
          <target state="translated">関数は関係なので、最後の項目の定義(ドメイン、範囲など)は関数にも適用されます。</target>
        </trans-unit>
        <trans-unit id="07695f74f1c383a64bbc45b6016faa64c5986911" translate="yes" xml:space="preserve">
          <source>As illustrated, properties can be combined. If, for example, &lt;code&gt;shuffle&lt;/code&gt;, &lt;code&gt;repeat_until_any_fail&lt;/code&gt;, and &lt;code&gt;sequence&lt;/code&gt; are all specified, the test cases in the group are executed repeatedly, and in random order, until a test case fails. Then execution is immediately stopped and the remaining cases are skipped.</source>
          <target state="translated">示されているように、プロパティを組み合わせることができます。たとえば、 &lt;code&gt;shuffle&lt;/code&gt; 、 &lt;code&gt;repeat_until_any_fail&lt;/code&gt; 、および &lt;code&gt;sequence&lt;/code&gt; がすべて指定されている場合、テストケースが失敗するまで、グループ内のテストケースがランダムな順序で繰り返し実行されます。その後、実行はすぐに停止され、残りのケースはスキップされます。</target>
        </trans-unit>
        <trans-unit id="68fe7148f0f6ccc13bf1a24fdc690584b0a600f5" translate="yes" xml:space="preserve">
          <source>As illustrated, the two directories reside on different nodes, because &lt;code&gt;/ldisc/scratch&lt;/code&gt; (the &quot;local&quot; disc) exists on the two different nodes.</source>
          <target state="translated">図示のように、 &lt;code&gt;/ldisc/scratch&lt;/code&gt; （「ローカル」ディスク）が2つの異なるノードに存在するため、2つのディレクトリは異なるノードに存在します。</target>
        </trans-unit>
        <trans-unit id="b2998e8a048230bd280f5294610d17bc1bd53ffb" translate="yes" xml:space="preserve">
          <source>As in &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt;, an &lt;code&gt;mp()&lt;/code&gt; compiled with option &lt;code&gt;unicode&lt;/code&gt; requires &lt;code&gt;Subject&lt;/code&gt; to be a Unicode &lt;code&gt;charlist()&lt;/code&gt;. If compilation is done implicitly and the &lt;code&gt;unicode&lt;/code&gt; compilation option is specified to this function, both the regular expression and &lt;code&gt;Subject&lt;/code&gt; are to be specified as valid Unicode &lt;code&gt;charlist()&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; と同様に、オプション &lt;code&gt;unicode&lt;/code&gt; でコンパイルされた &lt;code&gt;mp()&lt;/code&gt; では、 &lt;code&gt;Subject&lt;/code&gt; がUnicode &lt;code&gt;charlist()&lt;/code&gt; である必要があります。コンパイルが暗黙的に行われ、 &lt;code&gt;unicode&lt;/code&gt; コンパイルオプションがこの関数に指定されている場合、正規表現と &lt;code&gt;Subject&lt;/code&gt; の両方が有効なUnicode &lt;code&gt;charlist()&lt;/code&gt; として指定されます。</target>
        </trans-unit>
        <trans-unit id="466e0ad8d0c7cbd5f38b33d59e9622626664550d" translate="yes" xml:space="preserve">
          <source>As in Erlang, messages can be sent to a pid or to a registered name. It is easier to send a message to a registered name, as it avoids the problem of finding a suitable pid.</source>
          <target state="translated">Erlangと同じように、メッセージはpidか登録された名前に送ることができます。登録された名前にメッセージを送る方が簡単です。</target>
        </trans-unit>
        <trans-unit id="a4d88e181201a03cc3fb7ded4e3d176b1c280bd5" translate="yes" xml:space="preserve">
          <source>As in construction, the order in which the key and value expressions are evaluated is not defined. The syntactic order of the key-value pairs in the update is of no relevance, except in the case where two keys match. In that case, the latter value is used.</source>
          <target state="translated">構築の場合と同様に、キー式と値式が評価される順序は定義されていません。2つのキーが一致する場合を除いて、更新におけるキーと値のペアの構文的な順序は関係ありません。その場合、後者の値が使用されます。</target>
        </trans-unit>
        <trans-unit id="bc2ecf4ab7dc9e0eae158ae04299a70b115b03c8" translate="yes" xml:space="preserve">
          <source>As in function &lt;code&gt;run/3&lt;/code&gt;, an &lt;code&gt;mp()&lt;/code&gt; compiled with option &lt;code&gt;unicode&lt;/code&gt; requires &lt;code&gt;Subject&lt;/code&gt; to be a Unicode &lt;code&gt;charlist()&lt;/code&gt;. If compilation is done implicitly and the &lt;code&gt;unicode&lt;/code&gt; compilation option is specified to this function, both the regular expression and &lt;code&gt;Subject&lt;/code&gt; are to specified as valid Unicode &lt;code&gt;charlist()&lt;/code&gt;s.</source>
          <target state="translated">関数 &lt;code&gt;run/3&lt;/code&gt; と同様に、オプション &lt;code&gt;unicode&lt;/code&gt; でコンパイルされた &lt;code&gt;mp()&lt;/code&gt; では、 &lt;code&gt;Subject&lt;/code&gt; がUnicode &lt;code&gt;charlist()&lt;/code&gt; である必要があります。コンパイルが暗黙的に行われ、 &lt;code&gt;unicode&lt;/code&gt; コンパイルオプションがこの関数に指定されている場合、正規表現と &lt;code&gt;Subject&lt;/code&gt; 両方が有効なUnicode &lt;code&gt;charlist()&lt;/code&gt; として指定されます。</target>
        </trans-unit>
        <trans-unit id="64b4b80939944294d71727cd908b06dbe0c67247" translate="yes" xml:space="preserve">
          <source>As in ordinary Erlang matching, you can bind a variable to the whole matched object using a &quot;match inside the match&quot;, that is, a &lt;code&gt;=&lt;/code&gt;. Unfortunately in funs translated to match specifications, it is allowed only at the &quot;top-level&quot;, that is, matching the &lt;strong&gt;whole&lt;/strong&gt; object arriving to be matched into a separate variable. If you are used to writing match specifications by hand, we mention that variable A is simply translated into '$_'. Alternatively, pseudo function &lt;code&gt;object/0&lt;/code&gt; also returns the whole matched object, see section &lt;code&gt;&lt;a href=&quot;#warnings_and_restrictions&quot;&gt; Warnings and Restrictions&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">通常のErlangマッチングと同様に、「マッチ内のマッチ」、つまりa &lt;code&gt;=&lt;/code&gt; を使用して、マッチしたオブジェクト全体に変数をバインドできます。残念ながら、仕様に一致するように変換されたファンでは、「トップレベル」でのみ許可されます。つまり、到着したオブジェクト&lt;strong&gt;全体を&lt;/strong&gt;一致させて、別の変数に一致させることができます。手作業で一致仕様を作成することに慣れている場合は、変数Aが単に「$ _」に変換されることに注意してください。または、疑似関数 &lt;code&gt;object/0&lt;/code&gt; も一致したオブジェクト全体を返します。「 &lt;code&gt;&lt;a href=&quot;#warnings_and_restrictions&quot;&gt; Warnings and Restrictions&lt;/a&gt;&lt;/code&gt; 」のセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="3af4e7ec9b32aca75bcf09376c862c57bf6062d9" translate="yes" xml:space="preserve">
          <source>As in ordinary Erlang matching, you can bind a variable to the whole matched object using a &quot;match inside the match&quot;, that is, a &lt;code&gt;=&lt;/code&gt;. Unfortunately in funs translated to match specifications, it is allowed only at the &quot;top-level&quot;, that is, matching the &lt;strong&gt;whole&lt;/strong&gt; object arriving to be matched into a separate variable. If you are used to writing match specifications by hand, we mention that variable A is simply translated into '$_'. Alternatively, pseudo function &lt;code&gt;object/0&lt;/code&gt; also returns the whole matched object, see section &lt;code&gt;&lt;a href=&quot;#warnings_and_restrictions&quot;&gt;Warnings and Restrictions&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">通常のErlangマッチングと同様に、「マッチ内のマッチ」、つまり &lt;code&gt;=&lt;/code&gt; を使用して、マッチしたオブジェクト全体に変数をバインドできます。残念ながら、仕様に一致するように変換されたfunでは、「トップレベル」、つまり、到着したオブジェクト&lt;strong&gt;全体を&lt;/strong&gt;別の変数に一致させることのみが許可されます。マッチ仕様を手動で作成することに慣れている場合、変数Aは単に「$ _」に変換されることを説明します。あるいは、疑似関数 &lt;code&gt;object/0&lt;/code&gt; も一致したオブジェクト全体を返します。「 &lt;code&gt;&lt;a href=&quot;#warnings_and_restrictions&quot;&gt;Warnings and Restrictions&lt;/a&gt;&lt;/code&gt; 」セクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="a73b3d59b95737cd7fcd0d996094833b0e3aa133" translate="yes" xml:space="preserve">
          <source>As in the previous examples, it is your responsibility to free the memory allocated for Erlang terms. In this example, &lt;code&gt;ei_x_free()&lt;/code&gt; ensures that the data pointed to by &lt;code&gt;buf&lt;/code&gt; is released.</source>
          <target state="translated">前の例のように、Erlang用語に割り当てられたメモリを解放するのはあなたの責任です。この例では、 &lt;code&gt;ei_x_free()&lt;/code&gt; は、 &lt;code&gt;buf&lt;/code&gt; が指すデータが解放されることを保証します。</target>
        </trans-unit>
        <trans-unit id="c43013c670a4d6155374f58258fab04f5fbbc072" translate="yes" xml:space="preserve">
          <source>As in the previous examples, it is your responsibility to free the memory allocated for Erlang terms. In this example, &lt;code&gt;erl_free_compound()&lt;/code&gt; ensures that the complete term pointed to by &lt;code&gt;ep&lt;/code&gt; is released. This is necessary because the pointer from the second call to &lt;code&gt;erl_format&lt;/code&gt; is lost.</source>
          <target state="translated">前の例と同様に、Erlang用語に割り当てられたメモリを解放するのはユーザーの責任です。この例では、 &lt;code&gt;erl_free_compound()&lt;/code&gt; は、 &lt;code&gt;ep&lt;/code&gt; が指す完全な用語が確実に解放されるようにします。これは、2回目の呼び出しから &lt;code&gt;erl_format&lt;/code&gt; へのポインターが失われるために必要です。</target>
        </trans-unit>
        <trans-unit id="d26ac3436bd27f40dd7ea34e33f65a20575923b6" translate="yes" xml:space="preserve">
          <source>As in the previous section the PEM file &lt;code&gt;&quot;/home/me/ssl/erlserver.pem&quot;&lt;/code&gt; contains both the server certificate and its private key.</source>
          <target state="translated">前のセクションと同様に、PEMファイル &lt;code&gt;&quot;/home/me/ssl/erlserver.pem&quot;&lt;/code&gt; にはサーバー証明書とその秘密鍵の両方が含まれています。</target>
        </trans-unit>
        <trans-unit id="debb8560047fb0b42a46cc59f3c825a91b4209ba" translate="yes" xml:space="preserve">
          <source>As indicated by the name, emulator flags control the behavior of the emulator.</source>
          <target state="translated">名前が示すように、エミュレータフラグはエミュレータの動作を制御します。</target>
        </trans-unit>
        <trans-unit id="6f49bed7fb11b494819d4e36cc0258b2b542e095" translate="yes" xml:space="preserve">
          <source>As long as all character sets were limited to 256 characters, each character could be stored in one single byte, so there was more or less only one practical encoding for the characters. Encoding each character in one byte was so common that the encoding was not even named. With the Unicode system there are much more than 256 characters, so a common way is needed to represent these. The common ways of representing the code points are the encodings. This means a whole new concept to the programmer, the concept of character representation, which was a non-issue earlier.</source>
          <target state="translated">すべての文字セットが256文字に制限されている限り、各文字を1バイトに格納することができるので、多かれ少なかれ実用的なエンコードは1つしかありませんでした。1バイトで各文字をエンコードすることは非常に一般的で、エンコードに名前が付けられることすらありませんでした。Unicodeシステムでは、256文字よりもはるかに多くの文字があるので、これらを表現するための共通の方法が必要です。コードポイントを表現する共通の方法がエンコーディングです。これはプログラマーにとっては全く新しい概念であり、以前は問題にならなかった文字表現の概念を意味します。</target>
        </trans-unit>
        <trans-unit id="9b7153107281cf1e02599d91bf8553499b75800f" translate="yes" xml:space="preserve">
          <source>As long as real identifiers are correct, it is OK to pass a CPU topology that is not a correct description of the CPU topology. When used with care this can be very useful. This to trick the emulator to bind its schedulers as you want. For example, if you want to run multiple Erlang runtime systems on the same machine, you want to reduce the number of schedulers used and manipulate the CPU topology so that they bind to different logical CPUs. An example, with two Erlang runtime systems on a quad core machine:</source>
          <target state="translated">実在の識別子が正しいものであれば、CPUトポロジーの記述が正しくないものを渡しても構いません。注意して使えば、これは非常に便利です。これは、エミュレータを騙してスケジューラを思い通りにバインドさせるためのものです。例えば、複数のErlangランタイムシステムを同じマシン上で実行したい場合、使用するスケジューラの数を減らして、CPUトポロジーを操作して、異なる論理CPUにバインドするようにしたいとします。例として、2つのErlangランタイムシステムをクアッドコアのマシン上で実行してみましょう。</target>
        </trans-unit>
        <trans-unit id="3a4531be2cf765e3ef8b54b63b05d246b380ee1c" translate="yes" xml:space="preserve">
          <source>As long as the &lt;code&gt;ftp&lt;/code&gt; application is operational, the FTP sessions are supervised and can be soft code upgraded.</source>
          <target state="translated">&lt;code&gt;ftp&lt;/code&gt; アプリケーションが動作している限り、FTPセッションは監視され、ソフトコードをアップグレードできます。</target>
        </trans-unit>
        <trans-unit id="b05ddb8fa8f81edfa35269196a6d393612d35a2a" translate="yes" xml:space="preserve">
          <source>As long as the data is always lists, modifier &lt;code&gt;t&lt;/code&gt; can be used for any string, but when binary data is involved, care must be taken to make the correct choice of formatting characters. A bytewise-encoded binary is also interpreted as a string, and printed even when using &lt;code&gt;~ts&lt;/code&gt;, but it can be mistaken for a valid UTF-8 string. Avoid therefore using the &lt;code&gt;~ts&lt;/code&gt; control if the binary contains bytewise-encoded characters and not UTF-8.</source>
          <target state="translated">データが常にリストである限り、任意の文字列に修飾子 &lt;code&gt;t&lt;/code&gt; を使用できますが、バイナリデータが関係する場合は、フォーマット文字を正しく選択するように注意する必要があります。バイト単位でエンコードされたバイナリも文字列として解釈され、 &lt;code&gt;~ts&lt;/code&gt; を使用しても出力されますが、有効なUTF-8文字列と間違われる可能性があります。したがって、バイナリにUTF-8ではなくバイト単位でエンコードされた文字が含まれている場合は、 &lt;code&gt;~ts&lt;/code&gt; コントロールを使用しないでください。</target>
        </trans-unit>
        <trans-unit id="38beb3decd97936c9d002a776141659553006a04" translate="yes" xml:space="preserve">
          <source>As long as the length of the message queue is lower than this value, all log events are handled asynchronously. This means that the client process sending the log event, by calling a log function in the &lt;code&gt;&lt;a href=&quot;logger_chapter#logger_api&quot;&gt;Logger API&lt;/a&gt;&lt;/code&gt;, does not wait for a response from the handler but continues executing immediately after the event is sent. It is not affected by the time it takes the handler to print the event to the log device. If the message queue grows larger than this value, the handler starts handling log events synchronously instead, meaning that the client process sending the event must wait for a response. When the handler reduces the message queue to a level below the &lt;code&gt;sync_mode_qlen&lt;/code&gt; threshold, asynchronous operation is resumed. The switch from asynchronous to synchronous mode can slow down the logging tempo of one, or a few, busy senders, but cannot protect the handler sufficiently in a situation of many busy concurrent senders.</source>
          <target state="translated">メッセージキューの長さがこの値より短い限り、すべてのログイベントは非同期で処理されます。つまり、 &lt;code&gt;&lt;a href=&quot;logger_chapter#logger_api&quot;&gt;Logger API&lt;/a&gt;&lt;/code&gt; ログ関数を呼び出してログイベントを送信するクライアントプロセスは、ハンドラーからの応答を待たずに、イベントが送信された直後に実行を継続します。ハンドラがイベントをログデバイスに出力するのにかかる時間には影響されません。メッセージキューがこの値より大きくなると、ハンドラは代わりにログイベントの処理を同期的に開始します。つまり、イベントを送信するクライアントプロセスは応答を待つ必要があります。ハンドラーがメッセージキューを &lt;code&gt;sync_mode_qlen&lt;/code&gt; 未満のレベルに減らすとしきい値、非同期操作が再開されます。非同期モードから同期モードに切り替えると、1つまたは少数のビジーな送信者のロギングテンポが遅くなる可能性がありますが、ビジーな同時送信者が多い状況ではハンドラを十分に保護できません。</target>
        </trans-unit>
        <trans-unit id="cb54073b5c596b75c4d1032a2bc0e471288f7302" translate="yes" xml:space="preserve">
          <source>As long as there are no more than 16 schedulers, there will never be any lock contention on the port lock for the driver.</source>
          <target state="translated">スケジューラが16個以下である限り、ドライバのポートロックにロック競合が発生することはありません。</target>
        </trans-unit>
        <trans-unit id="e4b29322baa56d4c7a0700a6dec611b4da2d64c8" translate="yes" xml:space="preserve">
          <source>As many options are silently discarded by the stack if they are specified out of range; it can be a good idea to check that a raw option is accepted. The following code places the value in variable &lt;code&gt;TcpLinger2:&lt;/code&gt;</source>
          <target state="translated">多くのオプションは、範囲外で指定された場合、スタックによって暗黙的に破棄されます。生のオプションが受け入れられることを確認することは良い考えです。次のコードでは、変数に値を置き &lt;code&gt;TcpLinger2:&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cde1dbb415595f7822eb3d191139162bdd23a109" translate="yes" xml:space="preserve">
          <source>As matching proceeds from left to right, PCRE looks for each &quot;a&quot; in the subject and then sees if what follows matches the remaining pattern. If the pattern is specified as</source>
          <target state="translated">PCREは、左から右へとマッチングが進むにつれて、対象の各「a」を探し、それに続くものが残りのパターンと一致するかどうかを確認します。パターンが</target>
        </trans-unit>
        <trans-unit id="6ca1c79babb9a0075f407b28d68680d2a199070e" translate="yes" xml:space="preserve">
          <source>As md5 is not available in FIPS mode it is only possible to use certificates that were signed using sha hashing. When validating an entire certificate chain all certificates (including the root CA's) must comply with this rule.</source>
          <target state="translated">md5 は FIPS モードでは使用できないので、sha ハッシュを使用して署名された証明書のみを使用することができます。証明書チェーン全体を検証する際には、すべての証明書 (ルート CA を含む)がこのルールに従わなければなりません。</target>
        </trans-unit>
        <trans-unit id="d5d8bb90e5a37caa06c5da65479a3526fd9c95dd" translate="yes" xml:space="preserve">
          <source>As mentioned above, the descriptors for the free segments are allocated in a separate area. This area has a constant configurable size (+MMscrfsd) that defaults to 65536 descriptors. This should be more than enough in most cases. If the descriptors area should fill up, new descriptor areas will be allocated first directly from the OS, and then from &lt;code&gt;sua&lt;/code&gt; and &lt;code&gt;sa&lt;/code&gt; in the super carrier, and lastly from the memory segment itself which is being deallocated. Allocating free descriptor areas from the super carrier is only a last resort, and should be avoided, as it creates fragmentation.</source>
          <target state="translated">上記のように、空きセグメントの記述子は別の領域に割り当てられます。この領域には、デフォルトで65536記述子に設定された一定の構成可能なサイズ（+ MMscrfsd）があります。ほとんどの場合、これで十分です。記述子領域がいっぱいになった場合、新しい記述子領域は最初にOSから直接割り当てられ、次にスーパーキャリアの &lt;code&gt;sua&lt;/code&gt; と &lt;code&gt;sa&lt;/code&gt; から割り当てられ、最後に割り当て解除されているメモリセグメント自体から割り当てられます。スーパーキャリアから無料の記述子領域を割り当てることは最後の手段にすぎず、断片化が発生するため、避ける必要があります。</target>
        </trans-unit>
        <trans-unit id="f7c08fa4650f0a0fe94395e21e9822cf60a9f2f7" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, a script can contains precompiled &lt;code&gt;beam&lt;/code&gt; code. In a precompiled script, the interpretation of the script header is the same as in a script containing source code. This means that you can make a &lt;code&gt;beam&lt;/code&gt; file executable by prepending the file with the lines starting with &lt;code&gt;#!&lt;/code&gt; and &lt;code&gt;%%!&lt;/code&gt; mentioned above. In a precompiled script, the &lt;code&gt;main/1&lt;/code&gt; function must be exported.</source>
          <target state="translated">前述のように、スクリプトにはプリコンパイルされた &lt;code&gt;beam&lt;/code&gt; コードを含めることができます。プリコンパイル済みスクリプトでは、スクリプトヘッダーの解釈は、ソースコードを含むスクリプトの場合と同じです。つまり、 &lt;code&gt;#!&lt;/code&gt; 始まる行をファイルの先頭に追加することで、 &lt;code&gt;beam&lt;/code&gt; ファイルを実行可能にすることができます。そして &lt;code&gt;%%!&lt;/code&gt; 上記の通り。プリコンパイル済みスクリプトでは、 &lt;code&gt;main/1&lt;/code&gt; 関数をエクスポートする必要があります。</target>
        </trans-unit>
        <trans-unit id="e705de13180c5ffe8b4a054da182ea6ce56490f8" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, queries are expressed in the list comprehension syntax as described in section &lt;code&gt;Expressions&lt;/code&gt; in Erlang Reference Manual. In the following, some familiarity with list comprehensions is assumed. The examples in section &lt;code&gt; List Comprehensions&lt;/code&gt; in Programming Examples can get you started. Notice that list comprehensions do not add any computational power to the language; anything that can be done with list comprehensions can also be done without them. But they add syntax for expressing simple search problems, which is compact and clear once you get used to it.</source>
          <target state="translated">前述のように、クエリは、Erlangリファレンスマニュアルの「 &lt;code&gt;Expressions&lt;/code&gt; 」のセクションで説明されているように、リスト内包表記構文で表現されます。以下では、リスト内包にある程度精通していることを前提としています。セクション「プログラミング例の &lt;code&gt; List Comprehensions&lt;/code&gt; 内包表記」の例から始めることができます。リスト内包表記は言語に計算能力を追加しないことに注意してください。リスト内包表記で実行できることはすべて、リスト内包表記なしでも実行できます。しかし、それらは単純な検索問題を表現するための構文を追加します。これは、慣れればコンパクトで明確です。</target>
        </trans-unit>
        <trans-unit id="64feb9f4a1acc565bd79ae07225ce3ec20e86066" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, queries are expressed in the list comprehension syntax as described in section &lt;code&gt;Expressions&lt;/code&gt; in Erlang Reference Manual. In the following, some familiarity with list comprehensions is assumed. The examples in section &lt;code&gt;List Comprehensions&lt;/code&gt; in Programming Examples can get you started. Notice that list comprehensions do not add any computational power to the language; anything that can be done with list comprehensions can also be done without them. But they add syntax for expressing simple search problems, which is compact and clear once you get used to it.</source>
          <target state="translated">前述のように、クエリは、Erlangリファレンスマニュアルの「 &lt;code&gt;Expressions&lt;/code&gt; 」セクションで説明されているように、リスト内包構文で表現されます。以下では、リスト内包表記についてある程度の知識があることを前提としています。 「プログラミングの例」の「 &lt;code&gt;List Comprehensions&lt;/code&gt; セクションの例から始めることができます。リスト内包表記は、言語に計算能力を追加しないことに注意してください。リスト内包表記で実行できることは、それなしでも実行できます。しかし、それらは単純な検索問題を表現するための構文を追加します。これは、慣れるとコンパクトで明確になります。</target>
        </trans-unit>
        <trans-unit id="dcc63d308b096795c5804a0be71fa661e287ba90" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, segments have the following general syntax:</source>
          <target state="translated">前述したように、セグメントには以下の一般的な構文があります。</target>
        </trans-unit>
        <trans-unit id="04e043f1d8167a2d58dbe4fb1d07663eacbf966c" translate="yes" xml:space="preserve">
          <source>As mentioned in the &lt;code id=&quot;lengthy_work&quot;&gt;&lt;a href=&quot;#WARNING&quot;&gt;warning&lt;/a&gt;&lt;/code&gt; text at the beginning of this section, it is of vital importance that a driver callback returns relatively fast. It is difficult to give an exact maximum amount of time that a driver callback is allowed to work, but usually a well-behaving driver callback is to return within 1 millisecond. This can be achieved using different approaches. If you have full control over the code to execute in the driver callback, the best approach is to divide the work into multiple chunks of work, and trigger multiple calls to the &lt;code&gt;&lt;a href=&quot;driver_entry#timeout&quot;&gt;time-out callback&lt;/a&gt;&lt;/code&gt; using zero time-outs. Function &lt;code&gt;&lt;a href=&quot;#erl_drv_consume_timeslice&quot;&gt; erl_drv_consume_timeslice&lt;/a&gt;&lt;/code&gt; can be useful to determine when to trigger such time-out callback calls. However, sometimes it cannot be implemented this way, for example when calling third-party libraries. In this case, you typically want to dispatch the work to another thread. Information about thread primitives is provided below.</source>
          <target state="translated">このセクションの冒頭の &lt;code id=&quot;lengthy_work&quot;&gt;&lt;a href=&quot;#WARNING&quot;&gt;warning&lt;/a&gt;&lt;/code&gt; テキストで述べたように、ドライバーのコールバックが比較的速く戻ることが非常に重要です。ドライバーのコールバックが機能できる正確な最大時間を指定することは困難ですが、通常、正常に動作するドライバーのコールバックは1ミリ秒以内に戻ることです。これは、さまざまなアプローチを使用して実現できます。ドライバーコールバックで実行するコードを完全に制御できる場合、最善のアプローチは、作業を複数の作業チャンクに分割し、ゼロタイムアウトを使用 &lt;code&gt;&lt;a href=&quot;driver_entry#timeout&quot;&gt;time-out callback&lt;/a&gt;&lt;/code&gt; への複数の呼び出しをトリガーすることです。関数 &lt;code&gt;&lt;a href=&quot;#erl_drv_consume_timeslice&quot;&gt; erl_drv_consume_timeslice&lt;/a&gt;&lt;/code&gt; このようなタイムアウトコールバック呼び出しをいつトリガーするかを決定するのに役立ちます。ただし、サードパーティのライブラリを呼び出す場合など、この方法で実装できない場合があります。この場合、通常、作業を別のスレッドにディスパッチする必要があります。スレッドプリミティブに関する情報を以下に示します。</target>
        </trans-unit>
        <trans-unit id="68d171b0ef9d17830114bdb2e45fbb538d0990d4" translate="yes" xml:space="preserve">
          <source>As mentioned in the &lt;code id=&quot;lengthy_work&quot;&gt;&lt;a href=&quot;#WARNING&quot;&gt;warning&lt;/a&gt;&lt;/code&gt; text at the beginning of this section, it is of vital importance that a driver callback returns relatively fast. It is difficult to give an exact maximum amount of time that a driver callback is allowed to work, but usually a well-behaving driver callback is to return within 1 millisecond. This can be achieved using different approaches. If you have full control over the code to execute in the driver callback, the best approach is to divide the work into multiple chunks of work, and trigger multiple calls to the &lt;code&gt;&lt;a href=&quot;driver_entry#timeout&quot;&gt;time-out callback&lt;/a&gt;&lt;/code&gt; using zero time-outs. Function &lt;code&gt;&lt;a href=&quot;#erl_drv_consume_timeslice&quot;&gt;erl_drv_consume_timeslice&lt;/a&gt;&lt;/code&gt; can be useful to determine when to trigger such time-out callback calls. However, sometimes it cannot be implemented this way, for example when calling third-party libraries. In this case, you typically want to dispatch the work to another thread. Information about thread primitives is provided below.</source>
          <target state="translated">このセクションの最初の &lt;code id=&quot;lengthy_work&quot;&gt;&lt;a href=&quot;#WARNING&quot;&gt;warning&lt;/a&gt;&lt;/code&gt; テキストで述べたように、ドライバーのコールバックが比較的速く戻ることは非常に重要です。ドライバーコールバックが機能するのに許可される正確な最大時間を与えることは困難ですが、通常、適切に動作するドライバーコールバックは1ミリ秒以内に戻ることです。これは、さまざまなアプローチを使用して実現できます。ドライバーコールバックで実行するコードを完全に制御できる場合、最良のアプローチは、作業を複数の作業のチャンクに分割し、タイムアウトなしでタイムアウト &lt;code&gt;&lt;a href=&quot;driver_entry#timeout&quot;&gt;time-out callback&lt;/a&gt;&lt;/code&gt; への複数の呼び出しをトリガーすることです。関数 &lt;code&gt;&lt;a href=&quot;#erl_drv_consume_timeslice&quot;&gt;erl_drv_consume_timeslice&lt;/a&gt;&lt;/code&gt; このようなタイムアウトコールバックコールをトリガーするタイミングを決定するのに役立ちます。ただし、サードパーティのライブラリを呼び出す場合など、この方法で実装できない場合があります。この場合、通常は作業を別のスレッドにディスパッチします。スレッドプリミティブに関する情報を以下に示します。</target>
        </trans-unit>
        <trans-unit id="870908039e217eddb9cd9dd34c7a2a0d9565d41f" translate="yes" xml:space="preserve">
          <source>As mentioned in the &lt;code&gt;&lt;a href=&quot;#WARNING&quot;&gt;warning&lt;/a&gt;&lt;/code&gt; text at the beginning of this manual page, it is of &lt;strong&gt;vital importance&lt;/strong&gt; that a native function returns relatively fast. It is difficult to give an exact maximum amount of time that a native function is allowed to work, but usually a well-behaving native function is to return to its caller within 1 millisecond. This can be achieved using different approaches. If you have full control over the code to execute in the native function, the best approach is to divide the work into multiple chunks of work and call the native function multiple times. This is, however, not always possible, for example when calling third-party libraries.</source>
          <target state="translated">このマニュアルページの最初の &lt;code&gt;&lt;a href=&quot;#WARNING&quot;&gt;warning&lt;/a&gt;&lt;/code&gt; テキストで述べたように、ネイティブ関数が比較的速く戻ることは&lt;strong&gt;非常に重要&lt;/strong&gt;です。ネイティブ関数が動作することを許可される正確な最大時間を与えることは困難ですが、通常、正常に動作するネイティブ関数は、1ミリ秒以内に呼び出し元に戻ることです。これは、さまざまなアプローチを使用して実現できます。ネイティブ関数で実行するコードを完全に制御できる場合、最善の方法は、作業を複数の作業のチャンクに分割し、ネイティブ関数を複数回呼び出すことです。ただし、これは常に可能であるとは限りません。たとえば、サードパーティのライブラリを呼び出す場合などです。</target>
        </trans-unit>
        <trans-unit id="d9a36e8e6187e92ea9445003806465beadc6eb3c" translate="yes" xml:space="preserve">
          <source>As mentioned in the Overview the size of the heap &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L247&quot;&gt;grows&lt;/a&gt;&lt;/code&gt; to accommodate more data. Heaps grow in two stages, first a &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L199-L208&quot;&gt;variation of the Fibonacci sequence&lt;/a&gt;&lt;/code&gt; is used starting at 233 words. Then at about 1 mega words the heap only &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L215-L227&quot;&gt;grows in 20% increments&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">概要で述べたように、ヒープのサイズが &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L247&quot;&gt;grows&lt;/a&gt;&lt;/code&gt; 、より多くのデータに対応するために。ヒープは2つの段階で成長します。最初に、233ワードから始まる &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L199-L208&quot;&gt;variation of the Fibonacci sequence&lt;/a&gt;&lt;/code&gt; が使用されます。次に、約1メガワードで、ヒープ &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L215-L227&quot;&gt;grows in 20% increments&lt;/a&gt;&lt;/code&gt; のみ増加します。</target>
        </trans-unit>
        <trans-unit id="41a0f4742d111106d49a722bae376fa32463cd1a" translate="yes" xml:space="preserve">
          <source>As mentioned in the introduction, the &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4254&quot;&gt;SSH Connection Protocol&lt;/a&gt;&lt;/code&gt; events are handled as messages. When writing a channel handling process without using the support by the &lt;code&gt;&lt;a href=&quot;ssh_client_channel&quot;&gt;ssh_client_channel&lt;/a&gt;&lt;/code&gt; behavior the process must handle thoose messages.</source>
          <target state="translated">はじめに述べたように、 &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4254&quot;&gt;SSH Connection Protocol&lt;/a&gt;&lt;/code&gt; イベントはメッセージとして処理されます。 &lt;code&gt;&lt;a href=&quot;ssh_client_channel&quot;&gt;ssh_client_channel&lt;/a&gt;&lt;/code&gt; 動作によるサポートを使用せずにチャネル処理プロセスを作成する場合、プロセスはこれらのメッセージを処理する必要があります。</target>
        </trans-unit>
        <trans-unit id="0d72cf22161ff39dc24cc56c84b763eb1ee94488" translate="yes" xml:space="preserve">
          <source>As of &lt;code&gt;Inets&lt;/code&gt; 5.0 the HTTP server is an easy to start/stop and customize web server providing the most basic web server functionality. Inets is designed for embedded systems and if you want a full-fledged web server there are exists other erlang open source alternatives.</source>
          <target state="translated">以下のよう &lt;code&gt;Inets&lt;/code&gt; 5.0 HTTPサーバーは、最も基本的なWebサーバー機能を提供する簡単起動する/停止およびカスタマイズWebサーバーです。 Inetsは組み込みシステム用に設計されており、本格的なWebサーバーが必要な場合は、他のerlangオープンソースの代替手段が存在します。</target>
        </trans-unit>
        <trans-unit id="04f3b139a6a6595cb20185db3ca083fba34bbe19" translate="yes" xml:space="preserve">
          <source>As of &lt;code&gt;Inets&lt;/code&gt; 5.0 the HTTP server is an easy to start/stop and customize web server providing the most basic web server functionality. Inets is designed for embedded systems and if you want a full-fledged web server there are other erlang open source alternatives.</source>
          <target state="translated">以下のよう &lt;code&gt;Inets&lt;/code&gt; 5.0 HTTPサーバーは、最も基本的なWebサーバー機能を提供する簡単起動する/停止およびカスタマイズWebサーバーです。Inetsは組み込みシステム向けに設計されており、本格的なWebサーバーが必要な場合は、他のerlangオープンソースの代替手段があります。</target>
        </trans-unit>
        <trans-unit id="e33b6ffe68a9875e88f7c894ca5fdbb2187c6d41" translate="yes" xml:space="preserve">
          <source>As of ERTS version 10.0 support for distribution controller processes has been introduced. That is, the traffic over a distribution channel can be managed by a process instead of only by a port. This makes it possible to implement large parts of the logic in Erlang code, and you perhaps do not even need a new driver for the protocol. One example could be Erlang distribution over UDP using &lt;code&gt;gen_udp&lt;/code&gt; (your Erlang code will of course have to take care of retransmissions, etc in this example). That is, depending on what you want to do you perhaps do not need to implement a driver at all and can then skip the driver related sections below. The &lt;code&gt;gen_tcp_dist&lt;/code&gt; example described in the &lt;code&gt;&lt;a href=&quot;#distribution_module&quot;&gt;Distribution Module&lt;/a&gt;&lt;/code&gt; section utilize distribution controller processes and can be worth having a look at if you want to use distribution controller processes.</source>
          <target state="translated">ERTSバージョン10.0以降、ディストリビューションコントローラープロセスのサポートが導入されました。つまり、流通チャネル上のトラフィックは、ポートだけでなくプロセスによって管理できます。これにより、ロジックの大部分をErlangコードで実装することが可能になり、プロトコル用の新しいドライバーも必要ないかもしれません。 1つの例として、 &lt;code&gt;gen_udp&lt;/code&gt; を使用したUDPを介したアーラン分布があります（この例では、もちろん、アーランコードで再送信などを処理する必要があります）。つまり、実行する内容によっては、ドライバーを実装する必要がまったくない場合があり、以下のドライバー関連のセクションをスキップできます。 &lt;code&gt;gen_tcp_dist&lt;/code&gt; で説明した例 &lt;code&gt;&lt;a href=&quot;#distribution_module&quot;&gt;Distribution Module&lt;/a&gt;&lt;/code&gt; セクションでは、ディストリビューションコントローラープロセスを利用します。ディストリビューションコントローラープロセスを使用する場合は、一見の価値があります。</target>
        </trans-unit>
        <trans-unit id="0209ca89965504887d9fa6f1d52589a2103d8bad" translate="yes" xml:space="preserve">
          <source>As of ERTS version 10.0 support for distribution controller processes has been introduced. That is, the traffic over a distribution channel can be managed by a process instead of only by a port. This makes it possible to implement large parts of the logic in Erlang code, and you perhaps do not even need a new driver for the protocol. One example could be Erlang distribution over UDP using &lt;code&gt;gen_udp&lt;/code&gt; (your Erlang code will of course have to take care of retranspissions, etc in this example). That is, depending on what you want to do you perhaps do not need to implement a driver at all and can then skip the driver related sections below. The &lt;code&gt;gen_tcp_dist&lt;/code&gt; example described in the &lt;code&gt;&lt;a href=&quot;#distribution_module&quot;&gt;Distribution Module&lt;/a&gt;&lt;/code&gt; section utilize distribution controller processes and can be worth having a look at if you want to use distribution controller processes.</source>
          <target state="translated">ERTSバージョン10.0以降、ディストリビューションコントローラープロセスのサポートが導入されました。つまり、配布チャネル上のトラフィックは、ポートだけでなくプロセスによって管理できます。これにより、Erlangコードでロジックの大部分を実装することが可能になり、おそらくプロトコル用の新しいドライバーも必要ありません。 1つの例は、 &lt;code&gt;gen_udp&lt;/code&gt; を使用したUDPを介した Erlangディストリビューションです（もちろん、この例では、Erlangコードが再トランスミッションなどを処理する必要があります）。つまり、何をしたいかに応じて、ドライバーをまったく実装する必要がなく、以下のドライバー関連のセクションをスキップできます。 &lt;code&gt;gen_tcp_dist&lt;/code&gt; で説明した例 &lt;code&gt;&lt;a href=&quot;#distribution_module&quot;&gt;Distribution Module&lt;/a&gt;&lt;/code&gt; セクションでは、ディストリビューションコントローラープロセスを利用しており、ディストリビューションコントローラープロセスを使用する場合は、一見の価値があります。</target>
        </trans-unit>
        <trans-unit id="c85a6ebe0161eb5757b5cd028db5ba4081c57741" translate="yes" xml:space="preserve">
          <source>As of ERTS version 9.0, a process is only considered to be lingering in the code if it has direct references to the code. For more information see documentation of &lt;code&gt;erlang:check_process_code/3&lt;/code&gt;, which is used in order to determine this.</source>
          <target state="translated">ERTSバージョン9.0以降、プロセスは、コードへの直接参照がある場合にのみ、コード内に残っていると見なされます。詳細については、これを決定するために使用される &lt;code&gt;erlang:check_process_code/3&lt;/code&gt; のドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="6e7c328c76bb8c7c656e5de8a5de979edf715c89" translate="yes" xml:space="preserve">
          <source>As of ERTS version 9.0, also dirty CPU schedulers will be included in the result. That is, all scheduler threads that are expected to handle CPU bound work. If you also want information about dirty I/O schedulers, use &lt;code&gt;&lt;a href=&quot;#statistics_scheduler_wall_time_all&quot;&gt; statistics(scheduler_wall_time_all)&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">ERTSバージョン9.0以降、ダーティCPUスケジューラーも結果に含まれます。つまり、CPUバウンド作業を処理することが期待されるすべてのスケジューラスレッド。ダーティI / Oスケジューラに関する情報も必要な場合は、代わりに &lt;code&gt;&lt;a href=&quot;#statistics_scheduler_wall_time_all&quot;&gt; statistics(scheduler_wall_time_all)&lt;/a&gt;&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="990b2f43003907f6ffa2fd600f8b8c5f6d4c0c81" translate="yes" xml:space="preserve">
          <source>As of ERTS version 9.0, also dirty CPU schedulers will be included in the result. That is, all scheduler threads that are expected to handle CPU bound work. If you also want information about dirty I/O schedulers, use &lt;code&gt;&lt;a href=&quot;#statistics_scheduler_wall_time_all&quot;&gt;statistics(scheduler_wall_time_all)&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">ERTSバージョン9.0以降、ダーティCPUスケジューラも結果に含まれます。つまり、CPUにバインドされた作業を処理することが期待されるすべてのスケジューラスレッドです。ダーティーI / Oスケジューラーに関する情報も必要な場合は、代わりに &lt;code&gt;&lt;a href=&quot;#statistics_scheduler_wall_time_all&quot;&gt;statistics(scheduler_wall_time_all)&lt;/a&gt;&lt;/code&gt; 使用してください。</target>
        </trans-unit>
        <trans-unit id="924b8134638ed9edf16b9abf6ee2f7cc8660dc0a" translate="yes" xml:space="preserve">
          <source>As of ERTS version 9.0, the Erlang runtime system will as default have more schedulers than logical processors. This due to the dirty schedulers.</source>
          <target state="translated">ERTSバージョン9.0では、Erlangランタイムシステムはデフォルトで論理プロセッサよりも多くのスケジューラを持つようになりました。これはダーティスケジューラのせいです。</target>
        </trans-unit>
        <trans-unit id="cf90680c064454d2c96d45dd08744df7108b0b29" translate="yes" xml:space="preserve">
          <source>As of ERTS version 9.0, the check process code operation only checks for direct references to the code. Indirect references via &lt;code&gt;fun&lt;/code&gt;s will be ignored. If such &lt;code&gt;fun&lt;/code&gt;s exist and are used after a purge of the old code, an exception will be raised upon usage (same as the case when the &lt;code&gt;fun&lt;/code&gt; is received by the process after the purge). Literals will be taken care of (copied) at a later stage. This behavior can as of ERTS version 8.1 be enabled when &lt;code&gt;building OTP&lt;/code&gt;, and will automatically be enabled if dirty scheduler support is enabled.</source>
          <target state="translated">ERTSバージョン9.0以降、チェックプロセスのコード操作では、コードへの直接参照のみがチェックされます。 &lt;code&gt;fun&lt;/code&gt; を介した間接参照は無視されます。そのような &lt;code&gt;fun&lt;/code&gt; が存在し、古いコードのパージ後に使用された場合、使用時に例外が発生します（パージ後にプロセスが &lt;code&gt;fun&lt;/code&gt; を受け取った場合と同じ）。リテラルは後の段階で処理（コピー）されます。この動作は、ERTSバージョン8.1以降で &lt;code&gt;building OTP&lt;/code&gt; 時に有効にでき、ダーティスケジューラのサポートが有効になっている場合は自動的に有効になります。</target>
        </trans-unit>
        <trans-unit id="f4e1d3eb137cab5087aa6346ca40170ec41e8ce0" translate="yes" xml:space="preserve">
          <source>As of Erlang/OTP 17, most applications deliver a valid application upgrade file (&lt;code&gt;appup&lt;/code&gt;). In earlier releases, a majority of the applications in Erlang/OTP did not support upgrade. Many of the applications use the &lt;code&gt;restart_application&lt;/code&gt; instruction. These are applications for which it is not crucial to support real soft upgrade, for example, tools and library applications. The &lt;code&gt;restart_application&lt;/code&gt; instruction ensures that all modules in the application are reloaded and thereby running the new code.</source>
          <target state="translated">Erlang / OTP 17以降、ほとんどのアプリケーションは有効なアプリケーションアップグレードファイル（ &lt;code&gt;appup&lt;/code&gt; ）を提供します。以前のリリースでは、Erlang / OTPのアプリケーションの大部分はアップグレードをサポートしていませんでした。アプリケーションの多くは、 &lt;code&gt;restart_application&lt;/code&gt; 命令を使用します。これらは、ツールやライブラリアプリケーションなど、実際のソフトアップグレードをサポートすることが重要ではないアプリケーションです。 &lt;code&gt;restart_application&lt;/code&gt; の命令は、アプリケーション内のすべてのモジュールがリロードされ、それによって新たなコードを実行していることを確実にします。</target>
        </trans-unit>
        <trans-unit id="3896e9860076cb6efc826bd1af4282cf215a66b2" translate="yes" xml:space="preserve">
          <source>As of Erlang/OTP 21.0, the concept of SASL reports is removed, meaning that the default behaviour is as follows:</source>
          <target state="translated">Erlang/OTP 21.0では、SASLレポートの概念は削除され、デフォルトの動作は以下のようになりました。</target>
        </trans-unit>
        <trans-unit id="5156993619ca489fb8cfd9ed4a3335d7b4428f29" translate="yes" xml:space="preserve">
          <source>As of Erlang/OTP R16, messages sent to ports are delivered truly asynchronously. The underlying implementation previously delivered messages to ports synchronously. Message passing has however always been documented as an asynchronous operation. Hence, this is not to be an issue for an Erlang program communicating with ports, unless false assumptions about ports have been made.</source>
          <target state="translated">Erlang/OTP R16では、ポートに送られたメッセージは本当に非同期に配信されるようになりました。以前の実装では、ポートへのメッセージの配信は同期的に行われていました。しかし、メッセージの受け渡しは常に非同期の操作としてドキュメント化されています。したがって、ポートと通信するErlangプログラムにとっては、ポートについて間違った仮定がなされていない限り、これは問題ではありません。</target>
        </trans-unit>
        <trans-unit id="db7deccbe166e540f0b707dd76ed8fd8300520de" translate="yes" xml:space="preserve">
          <source>As of OTP 17.0 application versions use the same &lt;code&gt;&lt;a href=&quot;#version_scheme&quot;&gt;version scheme&lt;/a&gt;&lt;/code&gt; as the OTP version. Application versions part of a release candidate will however not have an &lt;code&gt;-rc&amp;lt;N&amp;gt;&lt;/code&gt; suffix as the OTP version. Also note that a major increment in an application version does not necessarily imply a major increment of the OTP version. This depends on whether the major change in the application is considered as a major change for OTP as a whole or not.</source>
          <target state="translated">OTP 17.0以降、アプリケーションバージョンはOTPバージョンと同じ &lt;code&gt;&lt;a href=&quot;#version_scheme&quot;&gt;version scheme&lt;/a&gt;&lt;/code&gt; を使用します。ただし、リリース候補の一部であるアプリケーションバージョンには、OTPバージョンのように &lt;code&gt;-rc&amp;lt;N&amp;gt;&lt;/code&gt; サフィックスはありません。また、アプリケーションバージョンの大幅な増加は、OTPバージョンの大幅な増加を意味するわけではないことにも注意してください。これは、アプリケーションの大きな変更がOTP全体の大きな変更と見なされるかどうかによって異なります。</target>
        </trans-unit>
        <trans-unit id="f41a33ea3422f58a2c592a14e6ca2fd364ded6e8" translate="yes" xml:space="preserve">
          <source>As of OTP 22 the run-time complexity is &quot;n log n&quot; and the operation will complete quickly even when both lists are very long. In fact, it is faster and uses less memory than the commonly used workaround to convert both lists to ordered sets before subtracting them with &lt;code&gt;ordsets:subtract/2&lt;/code&gt;.</source>
          <target state="translated">OTP 22の時点では、実行時の複雑さは「n log n」であり、両方のリストが非常に長い場合でも、操作は迅速に完了します。実際、 &lt;code&gt;ordsets:subtract/2&lt;/code&gt; で減算する前に、両方のリストを順序付きセットに変換するために一般的に使用される回避策よりも高速で、使用するメモリも少なくて済みます。</target>
        </trans-unit>
        <trans-unit id="0a5518801a50c6a71ee3e8981653964ac2b6dbf8" translate="yes" xml:space="preserve">
          <source>As of OTP 23, a new process group implementation &lt;code&gt;pg&lt;/code&gt; is introduced. &lt;code&gt;pg&lt;/code&gt; is similar to &lt;code&gt;pg2&lt;/code&gt;, but with much better scalability properties. However, the API and behavior are not compatible.</source>
          <target state="translated">OTP 23の時点で、新しいプロセスグループ実装 &lt;code&gt;pg&lt;/code&gt; が導入されています。 &lt;code&gt;pg&lt;/code&gt; は &lt;code&gt;pg2&lt;/code&gt; に似ていますが、スケーラビリティのプロパティがはるかに優れています。ただし、APIと動作には互換性がありません。</target>
        </trans-unit>
        <trans-unit id="dd17f9053cdf5289c0081b64f5ede62361aa0f24" translate="yes" xml:space="preserve">
          <source>As of OTP 23, the &lt;code&gt;registry&lt;/code&gt; functionality part of &lt;code&gt;erl_interface&lt;/code&gt; has been deprecated and it has also been &lt;code&gt;&lt;a href=&quot;scheduled_for_removal#otp-24&quot;&gt;scheduled for removal&lt;/a&gt;&lt;/code&gt; in OTP 24.</source>
          <target state="translated">OTP 23の時点で、 &lt;code&gt;erl_interface&lt;/code&gt; の &lt;code&gt;registry&lt;/code&gt; 機能部分は非推奨になり、OTP24でも &lt;code&gt;&lt;a href=&quot;scheduled_for_removal#otp-24&quot;&gt;scheduled for removal&lt;/a&gt;&lt;/code&gt; される予定です。</target>
        </trans-unit>
        <trans-unit id="d305318f18afb878956cbef1be26210771c5dcfd" translate="yes" xml:space="preserve">
          <source>As of OTP 23, the distributed &lt;code&gt;disk_log&lt;/code&gt; feature has been deprecated and it has also been &lt;code&gt;&lt;a href=&quot;scheduled_for_removal#otp-24&quot;&gt;scheduled for removal&lt;/a&gt;&lt;/code&gt; in OTP 24.</source>
          <target state="translated">OTP 23の時点で、分散 &lt;code&gt;disk_log&lt;/code&gt; 機能は非推奨になり、OTP24でも &lt;code&gt;&lt;a href=&quot;scheduled_for_removal#otp-24&quot;&gt;scheduled for removal&lt;/a&gt;&lt;/code&gt; される予定です。</target>
        </trans-unit>
        <trans-unit id="a4a95f7bae08ccde7df39187dbb3cd7db985f457" translate="yes" xml:space="preserve">
          <source>As of OTP 24 &lt;code&gt;memsup_improved_system_memory_data&lt;/code&gt; configuration parameter will be removed and &lt;code&gt;get_system_memory_data()&lt;/code&gt; will begin behaving as it does now when the configuration parameter has been set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">OTP 24 &lt;code&gt;memsup_improved_system_memory_data&lt;/code&gt; 構成パラメーターが削除され、構成パラメーターが &lt;code&gt;true&lt;/code&gt; に設定されている場合と &lt;code&gt;get_system_memory_data()&lt;/code&gt; が動作を開始します。</target>
        </trans-unit>
        <trans-unit id="fe1a516e25f41f502502c2e85a3b2d0123bd4daa" translate="yes" xml:space="preserve">
          <source>As of OTP 24, the Erlang compiler will refuse to compile source files encoded in Latin-1 but without a &lt;code&gt;%% coding: latin-1&lt;/code&gt; comment at the beginning of the file.</source>
          <target state="translated">OTP 24の時点で、ErlangコンパイラはLatin-1でエンコードされたソースファイルのコンパイルを拒否しますが、ファイルの先頭に &lt;code&gt;%% coding: latin-1&lt;/code&gt; コメントはありません。</target>
        </trans-unit>
        <trans-unit id="a9aac901e7e27d750caa95cb4832b3614a3f6a5b" translate="yes" xml:space="preserve">
          <source>As of OTP 24, the pre-release version 3 encoding configs; &lt;code&gt;prev3a&lt;/code&gt;, &lt;code&gt;prev3b&lt;/code&gt; and &lt;code&gt;prev3c&lt;/code&gt; will be removed. Use the full version instead.</source>
          <target state="translated">OTP 24の時点で、プレリリースバージョン3のエンコーディング構成。 &lt;code&gt;prev3a&lt;/code&gt; 、 &lt;code&gt;prev3b&lt;/code&gt; 、 &lt;code&gt;prev3c&lt;/code&gt; は削除されます。代わりにフルバージョンを使用してください。</target>
        </trans-unit>
        <trans-unit id="e6a68f9772c180bbf4b9650571adc55b4582fbcd" translate="yes" xml:space="preserve">
          <source>As of OTP release 17, the OTP release number corresponds to the major part of the OTP version. The OTP version as a concept was introduced in OTP 17. The version scheme used is described in detail in &lt;code&gt;&lt;a href=&quot;#version_scheme&quot;&gt;Version Scheme&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">OTPリリース17以降、OTPリリース番号はOTPバージョンの主要部分に対応しています。概念としてのOTPバージョンはOTP 17で導入されました。使用される &lt;code&gt;&lt;a href=&quot;#version_scheme&quot;&gt;Version Scheme&lt;/a&gt;&lt;/code&gt; については、バージョンスキームで詳しく説明しています。</target>
        </trans-unit>
        <trans-unit id="aa2be4113be53a8f180a26c5c4f8137c8f0b13cc" translate="yes" xml:space="preserve">
          <source>As of R15B01, the dynamic trace code is included in the OTP source distribution, although it's considered experimental. The main development of the dtrace code still happens outside of Ericsson, but there is no need to fetch a patched version of the OTP source to get the basic functionality.</source>
          <target state="translated">R15B01 の時点では、動的トレースコードは実験的なものとみなされていますが、OTP ソース ディストリビューションに含まれています。dtrace コードの主な開発はまだ Ericsson の外で行われていますが、基本的な機能を得るために OTP ソースのパッチ版を取得する必要はありません。</target>
        </trans-unit>
        <trans-unit id="3175e151baddb9462eaca8a3103721b845c4be90" translate="yes" xml:space="preserve">
          <source>As of version 4.4 the format of the info has been changed. This function is used to convert to the old (pre-4.4) info format.</source>
          <target state="translated">バージョン4.4から情報のフォーマットが変更されました。この関数は、古い(4.4以前の)情報フォーマットに変換するために使用します。</target>
        </trans-unit>
        <trans-unit id="bc18a1e131252e89f07716dc1f6c84f4f113e552" translate="yes" xml:space="preserve">
          <source>As of version 4.4 the format of the info has been changed. To convert the info to the old format, call the &lt;code&gt;&lt;a href=&quot;#old_info_format&quot;&gt;old_info_format&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">バージョン4.4以降、情報の形式が変更されました。情報を古い形式に変換するには、 &lt;code&gt;&lt;a href=&quot;#old_info_format&quot;&gt;old_info_format&lt;/a&gt;&lt;/code&gt; 関数を呼び出します。</target>
        </trans-unit>
        <trans-unit id="9906087c5fedcbfdab5bd69f8a1d9d0466df42d7" translate="yes" xml:space="preserve">
          <source>As one process can only be sending one fragmented message at once, it can be convenient to use the local PID as the sequence id.</source>
          <target state="translated">1つのプロセスが一度に1つの断片化されたメッセージしか送信できないので、ローカルPIDをシーケンスIDとして使用するのが便利です。</target>
        </trans-unit>
        <trans-unit id="a0806b3a57271c3368eb538cbf78e42f66a7befe" translate="yes" xml:space="preserve">
          <source>As operators are not terms in their own right, when operators are mentioned below, the representation of an operator is to be taken to be the atom with a printname consisting of the same characters as the operator.</source>
          <target state="translated">演算子はそれ自体が用語ではないので、以下に演算子について述べる場合、演算子の表現は演算子と同じ文字からなるprintnameを持つアトムとする。</target>
        </trans-unit>
        <trans-unit id="27aa2715207bd314b837c8f9f949d9e43e3fe153" translate="yes" xml:space="preserve">
          <source>As option &lt;code&gt;-M&lt;/code&gt;, except that the Makefile is written to &lt;code&gt;Makefile&lt;/code&gt;. No object file is produced.</source>
          <target state="translated">オプションとして &lt;code&gt;-M&lt;/code&gt; 、Makefileのが書き込まれることを除いて &lt;code&gt;Makefile&lt;/code&gt; 。オブジェクトファイルは作成されません。</target>
        </trans-unit>
        <trans-unit id="3d10554b44799b09a5d688a7590a7e6f973d1129" translate="yes" xml:space="preserve">
          <source>As option &lt;code&gt;-MT&lt;/code&gt;, except that characters special to &lt;code&gt;make/1&lt;/code&gt; are quoted.</source>
          <target state="translated">オプション &lt;code&gt;-MT&lt;/code&gt; と同じですが、 &lt;code&gt;make/1&lt;/code&gt; に特別な文字が引用されます。</target>
        </trans-unit>
        <trans-unit id="b8f789d4c76adaa6e3ad489f09dfb73a7ef05683" translate="yes" xml:space="preserve">
          <source>As parameter &lt;code&gt;Config&lt;/code&gt; is a list of key-value tuples, that is, a data type called a property list, it can be handled by the &lt;code&gt;proplists&lt;/code&gt; module. A value can, for example, be searched for and returned with function &lt;code&gt;proplists:get_value/2&lt;/code&gt;. Also, or alternatively, the general &lt;code&gt;lists&lt;/code&gt; module contains useful functions. Normally, the only operations performed on &lt;code&gt;Config&lt;/code&gt; is insert (adding a tuple to the head of the list) and lookup. &lt;code&gt;Common Test&lt;/code&gt; provides a simple macro named &lt;code&gt;?config&lt;/code&gt;, which returns a value of an item in &lt;code&gt;Config&lt;/code&gt; given the key (exactly like &lt;code&gt;proplists:get_value&lt;/code&gt;). Example: &lt;code&gt;PrivDir = ?config(priv_dir, Config)&lt;/code&gt;.</source>
          <target state="translated">パラメータ &lt;code&gt;Config&lt;/code&gt; はキーと値のタプルのリスト、つまりプロパティリストと呼ばれるデータ型であるため、 &lt;code&gt;proplists&lt;/code&gt; モジュールで処理できます。たとえば、値は関数 &lt;code&gt;proplists:get_value/2&lt;/code&gt; で検索して返すことができます。また、または代わりに、一般 &lt;code&gt;lists&lt;/code&gt; モジュールには便利な関数が含まれています。通常、 &lt;code&gt;Config&lt;/code&gt; で実行される操作は、挿入（タプルをリストの先頭に追加）とルックアップのみです。 &lt;code&gt;Common Test&lt;/code&gt; は、 &lt;code&gt;?config&lt;/code&gt; という名前の単純なマクロを提供します。これは、キーを指定すると、 &lt;code&gt;Config&lt;/code&gt; 内の項目の値を返します（ &lt;code&gt;proplists:get_value&lt;/code&gt; とまったく同じです）。例： &lt;code&gt;PrivDir = ?config(priv_dir, Config)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="df954ec42f95212c23047d3734e01ef2d3ae2ca4" translate="yes" xml:space="preserve">
          <source>As previously described, a Functional Object (Fun) performing table access operations, as listed here, can be passed on as arguments to the function &lt;code&gt;&lt;a href=&quot;mnesia#transaction-1&quot;&gt;mnesia:transaction/1,2,3&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">前に説明したように、ここにリストされているように、テーブルアクセス操作を実行する関数オブジェクト（Fun）は、関数 &lt;code&gt;&lt;a href=&quot;mnesia#transaction-1&quot;&gt;mnesia:transaction/1,2,3&lt;/a&gt;&lt;/code&gt; ：への引数として渡すことができます。</target>
        </trans-unit>
        <trans-unit id="1e768910eb46b5bf1b56cc0b04701d6e5fb8dd7f" translate="yes" xml:space="preserve">
          <source>As previously described, a Functional Object (Fun) performing table access operations, as listed here, can be passed on as arguments to the function &lt;code&gt;&lt;a href=&quot;mnesia#transaction-2&quot;&gt;mnesia:transaction/1,2,3&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">前述のように、ここにリストされているように、テーブルアクセス操作を実行する機能オブジェクト（Fun）は、引数として関数 &lt;code&gt;&lt;a href=&quot;mnesia#transaction-2&quot;&gt;mnesia:transaction/1,2,3&lt;/a&gt;&lt;/code&gt; に渡すことができます。</target>
        </trans-unit>
        <trans-unit id="697d56b55fb0573091be8112b03dc468b6978a3a" translate="yes" xml:space="preserve">
          <source>As previously explained, this specification can also be provided by an entry like the following in a configuration file:</source>
          <target state="translated">先に説明したように、この仕様は設定ファイルの以下のようなエントリでも提供することができます。</target>
        </trans-unit>
        <trans-unit id="5b4c831da626efb451c44f834caf79dfb78dcdf6" translate="yes" xml:space="preserve">
          <source>As previously stated, the locking strategy used by &lt;code&gt;Mnesia&lt;/code&gt; is to lock one record when reading a record, and lock all replicas of a record when writing a record. However, some applications use &lt;code&gt;Mnesia&lt;/code&gt; mainly for its fault-tolerant qualities. These applications can be configured with one node doing all the heavy work, and a standby node that is ready to take over if the main node fails. Such applications can benefit from using sticky locks instead of the normal locking scheme.</source>
          <target state="translated">前述のように、 &lt;code&gt;Mnesia&lt;/code&gt; で使用されているロック戦略は、レコードを読み取るときに1つのレコードをロックし、レコードを書き込むときにレコードのすべてのレプリカをロックすることです。ただし、一部のアプリケーションでは、主にフォールトトレラントな品質のために &lt;code&gt;Mnesia&lt;/code&gt; を使用しています。これらのアプリケーションは、すべての重い作業を実行する1つのノードと、メインノードに障害が発生した場合に引き継ぐ準備ができているスタンバイノードで構成できます。このようなアプリケーションでは、通常のロック方式の代わりにスティッキーロックを使用することでメリットが得られます。</target>
        </trans-unit>
        <trans-unit id="f370e8c40b9c4aba3e02b9314c912aaa28fee118" translate="yes" xml:space="preserve">
          <source>As producing and consuming standard URIs can get quite complex, Erlang/OTP provides a module, &lt;code&gt;uri_string&lt;/code&gt;, to handle all the most difficult operations such as parsing, recomposing, normalizing and resolving URIs against a base URI.</source>
          <target state="translated">標準URIの生成と消費は非常に複雑になる可能性があるため、Erlang / OTPは、ベースURIに対するURIの解析、再構成、正規化、解決など、最も難しい操作をすべて処理するモジュール &lt;code&gt;uri_string&lt;/code&gt; を提供します。</target>
        </trans-unit>
        <trans-unit id="9d595490ab4714d8a9871d8a09a973dfea9d0d3d" translate="yes" xml:space="preserve">
          <source>As received in the &lt;code&gt;stream_start message&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;stream_start message&lt;/code&gt; 受け取ったとおり</target>
        </trans-unit>
        <trans-unit id="fd5870133105312565312c6b2ab7ff3fd841d30a" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;#accept-1&quot;&gt;accept/1,2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#connect-3&quot;&gt;connect/3,4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#accept-1&quot;&gt;accept/1,2&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;#connect-3&quot;&gt;connect/3,4&lt;/a&gt;&lt;/code&gt; によって返されます。</target>
        </trans-unit>
        <trans-unit id="b46cebaae7c70180ee044bb55a1784247c2f3b67" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;#async_call-4&quot;&gt;async_call/4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#async_call-4&quot;&gt;async_call/4&lt;/a&gt;&lt;/code&gt; によって返されます。</target>
        </trans-unit>
        <trans-unit id="6563f22087e6266633a8cc2568e501f807ea6a94" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;#new-0&quot;&gt;new/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#new-0&quot;&gt;new/0&lt;/a&gt;&lt;/code&gt; によって返されます。</target>
        </trans-unit>
        <trans-unit id="f4cda5fd62bef4cb2abdbf95c2aa051fe7320a88" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1,2,3,4&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#accept-1&quot;&gt;accept/1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1,2,3,4&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;#accept-1&quot;&gt;accept/1,2&lt;/a&gt;&lt;/code&gt; によって返されます。</target>
        </trans-unit>
        <trans-unit id="613b92ac4a60557f480687125ac1a95cb659b564" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1,2&lt;/a&gt;&lt;/code&gt; によって返されます。</target>
        </trans-unit>
        <trans-unit id="d5ba5543136150606738a5ee102fcd04508cc21b" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1&lt;/a&gt;&lt;/code&gt; によって返されるように。</target>
        </trans-unit>
        <trans-unit id="863aff4e4c6e39a97f1c4df4bc54ef46a778c1ae" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt;; &lt;code&gt;pid()&lt;/code&gt; is a process handling I/O-protocols.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; が返すように; &lt;code&gt;pid()&lt;/code&gt; は、I / Oプロトコルを処理するプロセスです。</target>
        </trans-unit>
        <trans-unit id="b4c95d43e70076905f6c54f0f92a6860693a2f6a" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;#start_link-4&quot;&gt;start_link/4&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#start_link-4&quot;&gt;start_link/4&lt;/a&gt;&lt;/code&gt; によって返される</target>
        </trans-unit>
        <trans-unit id="90363fa78582864ae9fe09932744a0fa77aa02f7" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;#zip_open-2&quot;&gt;zip_open/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#zip_open-2&quot;&gt;zip_open/2&lt;/a&gt;&lt;/code&gt; によって返されます。</target>
        </trans-unit>
        <trans-unit id="ff99780124925e73d20d6ffc6b9d429009c7ddfb" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;erl_parse#parse_exprs-1&quot;&gt; erl_parse:parse_exprs/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;io#parse_erl_exprs-2&quot;&gt; io:parse_erl_exprs/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;erl_parse#parse_exprs-1&quot;&gt; erl_parse:parse_exprs/1&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;io#parse_erl_exprs-2&quot;&gt; io:parse_erl_exprs/2&lt;/a&gt;&lt;/code&gt; によって返されます。</target>
        </trans-unit>
        <trans-unit id="9a102b38b674404b91761c097130f2c6e8ca2119" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;erl_parse#parse_exprs-1&quot;&gt;erl_parse:parse_exprs/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;io#parse_erl_exprs-2&quot;&gt;io:parse_erl_exprs/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;erl_parse#parse_exprs-1&quot;&gt;erl_parse:parse_exprs/1&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;io#parse_erl_exprs-2&quot;&gt;io:parse_erl_exprs/2&lt;/a&gt;&lt;/code&gt; によって返されます。</target>
        </trans-unit>
        <trans-unit id="822165ce6b0feadb4e6119638d0ca82bfef5ff78" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;ssh#connect-3&quot;&gt;ssh:connect/3&lt;/a&gt;&lt;/code&gt;   As returned by &lt;code&gt;&lt;a href=&quot;ssh_connection#session_channel-2&quot;&gt; ssh_connection:session_channel/[2,4]&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">返される &lt;code&gt;&lt;a href=&quot;ssh#connect-3&quot;&gt;ssh:connect/3&lt;/a&gt;&lt;/code&gt; で返される &lt;code&gt;&lt;a href=&quot;ssh_connection#session_channel-2&quot;&gt; ssh_connection:session_channel/[2,4]&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d84d9f434fd43a7bcd5371be1f74578362aa6337" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;ssh#connect-3&quot;&gt;ssh:connect/3&lt;/a&gt;&lt;/code&gt;   As returned by &lt;code&gt;&lt;a href=&quot;ssh_connection#session_channel-2&quot;&gt;ssh_connection:session_channel/[2,4]&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">返される &lt;code&gt;&lt;a href=&quot;ssh#connect-3&quot;&gt;ssh:connect/3&lt;/a&gt;&lt;/code&gt; で返される &lt;code&gt;&lt;a href=&quot;ssh_connection#session_channel-2&quot;&gt;ssh_connection:session_channel/[2,4]&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1972d70c337d0516468a049aa6934a58903d2c1e" translate="yes" xml:space="preserve">
          <source>As returned by init/0</source>
          <target state="translated">init/0で返される</target>
        </trans-unit>
        <trans-unit id="66acc65c2b1802196c6e3511e7c37cac12a600c6" translate="yes" xml:space="preserve">
          <source>As seen in the help text -- unless you have not upgraded your Emacs yet (well, what are you waiting around here for? Off you go and upgrade!) -- &lt;code&gt;etags&lt;/code&gt; associate the file extensions &lt;code&gt;.erl&lt;/code&gt; and &lt;code&gt;.hrl&lt;/code&gt; with Erlang.</source>
          <target state="translated">ヘルプテキストにあるように &lt;code&gt;.hrl&lt;/code&gt; をまだアップグレードしていない場合（まあ、ここで何を待っているのですか？すぐにアップグレードしてください！）- &lt;code&gt;etags&lt;/code&gt; は、ファイル拡張子 &lt;code&gt;.erl&lt;/code&gt; および.hrlをErlangに関連付けます。</target>
        </trans-unit>
        <trans-unit id="5f01e0b8a20288a5e48191d860785e7700a74b5b" translate="yes" xml:space="preserve">
          <source>As seen, the basic syntax of a type is an atom followed by closed parentheses. New types are declared using &lt;code&gt;-type&lt;/code&gt; and &lt;code&gt;-opaque&lt;/code&gt; attributes as in the following:</source>
          <target state="translated">ご覧のように、型の基本的な構文は、アトムとそれに続く閉じ括弧です。新しいタイプは、次のように &lt;code&gt;-type&lt;/code&gt; 属性と &lt;code&gt;-opaque&lt;/code&gt; 属性を使用して宣言されます。</target>
        </trans-unit>
        <trans-unit id="a3fd03dc2b283a58adbff3d43946bbc1c68e036d" translate="yes" xml:space="preserve">
          <source>As shown above, some files have extension &lt;code&gt;.hrl&lt;/code&gt;. These are header files that are included in the &lt;code&gt;.erl&lt;/code&gt; files by:</source>
          <target state="translated">上記のように、一部のファイルには拡張子 &lt;code&gt;.hrl&lt;/code&gt; が付いています。これらは、 &lt;code&gt;.erl&lt;/code&gt; ファイルに含まれるヘッダーファイルです。</target>
        </trans-unit>
        <trans-unit id="644b5188f948ac22e42edad7ffd5f78d4eae0359" translate="yes" xml:space="preserve">
          <source>As shown by the example, the function can be called from the shell also. The fun must be literally in the call when used from the shell as well.</source>
          <target state="translated">例にあるように、シェルからも関数を呼び出すことができます。シェルから使用する場合も同様に、文字通り呼び出しの中に fun が含まれている必要があります。</target>
        </trans-unit>
        <trans-unit id="81045d7eeb4cf703574814aab4af0c68ba1e701f" translate="yes" xml:space="preserve">
          <source>As shown in section &lt;code&gt;&lt;a href=&quot;basics_chapter#External_Interfaces&quot;&gt;Common Test Basics&lt;/a&gt;&lt;/code&gt;, the test suite module implements &lt;code&gt;&lt;a href=&quot;common_test&quot;&gt;callback functions&lt;/a&gt;&lt;/code&gt; (mandatory or optional) for various purposes, for example:</source>
          <target state="translated">「 &lt;code&gt;&lt;a href=&quot;basics_chapter#External_Interfaces&quot;&gt;Common Test Basics&lt;/a&gt;&lt;/code&gt; 」セクションに示すように、テストスイートモジュールは、たとえば次のようなさまざまな目的で &lt;code&gt;&lt;a href=&quot;common_test&quot;&gt;callback functions&lt;/a&gt;&lt;/code&gt; （必須またはオプション）を実装します。</target>
        </trans-unit>
        <trans-unit id="030eefb3aa3439bedecb7d423ba21572f508483d" translate="yes" xml:space="preserve">
          <source>As shown, first it is checked if a year is leap. If a year is divisible by 400, it is a leap year. To determine this, first divide the year by 400 and use the BIF &lt;code&gt;trunc&lt;/code&gt; (more about this later) to cut off any decimals. Then multiply by 400 again and see if the same value is returned again. For example, year 2004:</source>
          <target state="translated">示されているように、最初に年がうるうかどうかがチェックされます。1年が400で割り切れる場合は、うるう年です。これを決定するには、まず年を400で割り、BIF &lt;code&gt;trunc&lt;/code&gt; （これについては後で詳しく説明します）を使用して小数を切り捨てます。次に、もう一度400を掛けて、同じ値が再び返されるかどうかを確認します。たとえば、2004年：</target>
        </trans-unit>
        <trans-unit id="732c6e940059e650b01cb8f7c64bf6533a984dc1" translate="yes" xml:space="preserve">
          <source>As shown, the Erlang shell numbers the lines that can be entered, (as 1&amp;gt; 2&amp;gt;) and that it correctly says that 2 + 5 is 7. If you make writing mistakes in the shell, you can delete with the backspace key, as in most shells. There are many more editing commands in the shell (see &lt;code&gt;tty - A command line interface&lt;/code&gt; in ERTS User's Guide).</source>
          <target state="translated">示されているように、Erlangシェルは入力可能な行に番号を付け（1&amp;gt; 2&amp;gt;として）、2 + 5は7であると正しく示しています。シェルで書き込みミスをした場合は、バックスペースキーで削除できます。ほとんどのシェルのように。シェルにはさらに多くの編集コマンドがあります（ERTSユーザーガイドのtty- &lt;code&gt;tty - A command line interface&lt;/code&gt; を参照）。</target>
        </trans-unit>
        <trans-unit id="e71ec6804a29b4599e20b3e464961470ccc68635" translate="yes" xml:space="preserve">
          <source>As shown, the function &lt;code&gt;say_something&lt;/code&gt; writes its first argument the number of times specified by second argument. The function &lt;code&gt;start&lt;/code&gt; starts two Erlang processes, one that writes &quot;hello&quot; three times and one that writes &quot;goodbye&quot; three times. Both processes use the function &lt;code&gt;say_something&lt;/code&gt;. Notice that a function used in this way by &lt;code&gt;spawn&lt;/code&gt;, to start a process, must be exported from the module (that is, in the &lt;code&gt;-export&lt;/code&gt; at the start of the module).</source>
          <target state="translated">示されているように、関数 &lt;code&gt;say_something&lt;/code&gt; は、2番目の引数で指定された回数だけ最初の引数を書き込みます。関数 &lt;code&gt;start&lt;/code&gt; は2つのErlangプロセスを開始します。1つは「hello」を3回書き込み、もう1つは「さようなら」を3回書き込みます。どちらのプロセスも関数 &lt;code&gt;say_something&lt;/code&gt; を使用します。このように &lt;code&gt;spawn&lt;/code&gt; がプロセスを開始するために使用する関数は、モジュールからエクスポートする必要があります（つまり、モジュールの先頭にある &lt;code&gt;-export&lt;/code&gt; で）。</target>
        </trans-unit>
        <trans-unit id="b8dddde7bbb47337791588e9c259e08ddee9bc47" translate="yes" xml:space="preserve">
          <source>As shown, the ping pong program has run. On the &quot;pong&quot; side:</source>
          <target state="translated">表示されているように、ピンポンプログラムが実行されました。ピンポン」側では</target>
        </trans-unit>
        <trans-unit id="ad4c171e5c21c103c918431cb469ba42140798d7" translate="yes" xml:space="preserve">
          <source>As stated earlier, changing child specifications does not affect existing child processes. New child specifications are automatically added, but not deleted. Child processes are not automatically started or terminated, this must be done using &lt;code&gt;apply&lt;/code&gt; instructions.</source>
          <target state="translated">前述のように、子の仕様を変更しても、既存の子プロセスには影響しません。新しい子仕様は自動的に追加されますが、削除はされません。子プロセスは自動的に開始または終了されません。これは、 &lt;code&gt;apply&lt;/code&gt; 手順を使用して実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="bab58f9f01e2ec9b0aff4a10808faf716038fb5e" translate="yes" xml:space="preserve">
          <source>As stated earlier, instruction &lt;code&gt;restart_new_emulator&lt;/code&gt; causes the emulator to be restarted with new versions of ERTS&amp;gt;, Kernel, STDLIB, and SASL. However, all other applications do at startup run their old versions in this new emulator. This is usually no problem, but every now and then incompatible changes occur to the core applications, which can cause trouble in this setting. Such incompatible changes (when functions are removed) are normally preceded by a deprecation over two major releases. To ensure that your application is not crashed by an incompatible change, always remove any call to deprecated functions as soon as possible.</source>
          <target state="translated">先に述べたように、命令 &lt;code&gt;restart_new_emulator&lt;/code&gt; はエミュレータ&amp;gt;は、カーネル、STDLIB、およびSASL ERTSの新しいバージョンを使用して再起動されます。ただし、他のすべてのアプリケーションは、起動時にこの新しいエミュレータで古いバージョンを実行します。これは通常は問題ありませんが、コアアプリケーションに互換性のない変更が時々発生し、この設定で問題が発生する可能性があります。このような互換性のない変更（機能が削除された場合）の前には、通常、2つのメジャーリリースが廃止されます。互換性のない変更によってアプリケーションがクラッシュしないようにするには、非推奨の関数への呼び出しをできるだけ早く削除してください。</target>
        </trans-unit>
        <trans-unit id="d2f8b1ba1c67fb67671d7cb5d1f4c6ff846076c9" translate="yes" xml:space="preserve">
          <source>As stated earlier, the order of the instructions is important. When upgrading, &lt;code&gt;m1&lt;/code&gt; must be loaded, and the supervisor child specification changed, before the new child process can be started. When downgrading, the child process must be terminated before the child specification is changed and the module is deleted.</source>
          <target state="translated">前述のように、指示の順序は重要です。アップグレード時には、新しい子プロセスを開始する前に、 &lt;code&gt;m1&lt;/code&gt; をロードし、スーパーバイザーの子仕様を変更する必要があります。ダウングレードする場合、子の仕様を変更してモジュールを削除する前に、子プロセスを終了する必要があります。</target>
        </trans-unit>
        <trans-unit id="b7ff2d94dd69653efaa6f0e2b153be55d281f264" translate="yes" xml:space="preserve">
          <source>As such a client cannot read a new &lt;code&gt;start_erl.data&lt;/code&gt; file (the file cannot be changed dynamically). The boot and config files are always fetched from the same place (but with new contents if a new release has been installed).</source>
          <target state="translated">そのため、クライアントは新しい &lt;code&gt;start_erl.data&lt;/code&gt; ファイルを読み取ることができません（ファイルを動的に変更することはできません）。ブートファイルと構成ファイルは常に同じ場所からフェッチされます（ただし、新しいリリースがインストールされている場合は新しいコンテンツが含まれます）。</target>
        </trans-unit>
        <trans-unit id="1714bc6ebf672752fb654342a2c562571522eab2" translate="yes" xml:space="preserve">
          <source>As the &lt;code&gt;++&lt;/code&gt; operator copies its left operand, the result is copied repeatedly, leading to quadratic complexity.</source>
          <target state="translated">&lt;code&gt;++&lt;/code&gt; オペレータコピーその左オペランド、結果は次の複雑さにつながる、繰り返しコピーされます。</target>
        </trans-unit>
        <trans-unit id="2e226d4cd051311bceb315b8997b69c3409b32fc" translate="yes" xml:space="preserve">
          <source>As the &lt;code&gt;add_frag&lt;/code&gt; procedure is a part of a schema transaction, Mnesia acquires write locks on the affected tables. That is, both the fragments corresponding to &lt;code&gt;IterFrags&lt;/code&gt; and those corresponding to &lt;code&gt;AdditionalLockFrags&lt;/code&gt;.</source>
          <target state="translated">以下のよう &lt;code&gt;add_frag&lt;/code&gt; の手順は、スキーマのトランザクションの一部である、Mnesiaは、影響を受ける表に書き込みロックを取得します。つまり、両方の断片は、対応する &lt;code&gt;IterFrags&lt;/code&gt; 、それらに対応する &lt;code&gt;AdditionalLockFrags&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f8afd221610cfbc0c004b3e80d9cc06e7451e3b4" translate="yes" xml:space="preserve">
          <source>As the &lt;code&gt;address&lt;/code&gt; field was omitted, its default value is used.</source>
          <target state="translated">&lt;code&gt;address&lt;/code&gt; フィールドが省略された、そのデフォルト値が使用されます。</target>
        </trans-unit>
        <trans-unit id="13444681318a2f85bf718682f9be9c04d867f14f" translate="yes" xml:space="preserve">
          <source>As the &lt;code&gt;del_frag&lt;/code&gt; procedure is a part of a schema transaction, Mnesia acquires write locks on the affected tables. That is, both the fragments corresponding to &lt;code&gt;IterFrags&lt;/code&gt; and those corresponding to &lt;code&gt;AdditionalLockFrags&lt;/code&gt;.</source>
          <target state="translated">以下のよう &lt;code&gt;del_frag&lt;/code&gt; の手順は、スキーマのトランザクションの一部である、Mnesiaは、影響を受ける表に書き込みロックを取得します。つまり、両方の断片は、対応する &lt;code&gt;IterFrags&lt;/code&gt; 、それらに対応する &lt;code&gt;AdditionalLockFrags&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="996b8c87675fcbf684c10ebd80b9cfdfdf3cae34" translate="yes" xml:space="preserve">
          <source>As the &lt;code&gt;total&lt;/code&gt; value is the sum of &lt;code&gt;processes&lt;/code&gt; and &lt;code&gt;system&lt;/code&gt;, the error in &lt;code&gt;system&lt;/code&gt; propagates to the &lt;code&gt;total&lt;/code&gt; value.</source>
          <target state="translated">&lt;code&gt;total&lt;/code&gt; 値の和である &lt;code&gt;processes&lt;/code&gt; 及び &lt;code&gt;system&lt;/code&gt; 、におけるエラー &lt;code&gt;system&lt;/code&gt; に伝播 &lt;code&gt;total&lt;/code&gt; 値。</target>
        </trans-unit>
        <trans-unit id="4195fa76015f84a5df8be91ff120efd14a713307" translate="yes" xml:space="preserve">
          <source>As the Erlang ODBC application is dependent on third party products there are a few administrative things that needs to be done before you can get things up and running.</source>
          <target state="translated">Erlang ODBCアプリケーションはサードパーティ製品に依存しているので、立ち上げて実行する前にいくつかの管理的なことを行う必要があります。</target>
        </trans-unit>
        <trans-unit id="20c8404a5de3c59614d50e29989cfead97f57ced" translate="yes" xml:space="preserve">
          <source>As the Erlang ODBC application relies on third party products and communicates with a database that probably runs on another computer in the network there are plenty of things that might go wrong. To fully understand the things that might happen it facilitate to know the design of the Erlang ODBC application, hence here follows a short description of the current design.</source>
          <target state="translated">Erlang ODBCアプリケーションはサードパーティ製品に依存していて、ネットワーク上の別のコンピュータ上で動作するデータベースと通信しているので、うまくいかないことがたくさんあります。何が起こるかを完全に理解するためにはErlang ODBCアプリケーションのデザインを知っておくと便利です。</target>
        </trans-unit>
        <trans-unit id="3558041c42459c9de0de1dcf3a8814d6434e5a6c" translate="yes" xml:space="preserve">
          <source>As the UTF-8 encoding is widely spread and provides some backward compatibility in the 7-bit ASCII range, it is selected as the standard encoding for Unicode characters in binaries for Erlang.</source>
          <target state="translated">UTF-8エンコーディングは広く普及しており、7ビットASCIIの範囲で下位互換性があるので、ErlangのバイナリではUnicode文字の標準エンコーディングとして選択されています。</target>
        </trans-unit>
        <trans-unit id="bdb9f25861a28ac570dd99575f72b2d8ad54d3fa" translate="yes" xml:space="preserve">
          <source>As the driver is a shared module, not a program, no main function is present. All function pointers are not used in this example, and the corresponding fields in the &lt;code&gt;driver_entry&lt;/code&gt; structure are set to NULL.</source>
          <target state="translated">ドライバはプログラムではなく共有モジュールであるため、主な機能はありません。この例ではすべての関数ポインターが使用されているわけではなく、 &lt;code&gt;driver_entry&lt;/code&gt; 構造体の対応するフィールドはNULLに設定されています。</target>
        </trans-unit>
        <trans-unit id="8406821028c9ff87cf4b1f089c352e4449600154" translate="yes" xml:space="preserve">
          <source>As the execution and structure of the match specifications are like that of a fun, it is more straightforward to write it using the familiar fun syntax and to have that translated into a match specification automatically. A real fun is clearly more powerful than the match specifications allow, but bearing the match specifications in mind, and what they can do, it is still more convenient to write it all as a fun. This module contains the code that translates the fun syntax into match specification terms.</source>
          <target state="translated">マッチ仕様の実行と構造はファンのそれに似ているので、おなじみのファンの構文を使って書いて、それを自動的にマッチ仕様に翻訳してもらう方が簡単です。本当の fun は、明らかに match 仕様よりも強力ですが、 match 仕様とそれができることを念頭に置いて、すべてを fun として書いた方が便利です。このモジュールには、fun構文をマッチ仕様に変換するコードが含まれています。</target>
        </trans-unit>
        <trans-unit id="500258296a887dd562c74c1baf7dab1768136ec5" translate="yes" xml:space="preserve">
          <source>As the execution of the test suites proceed, events are logged in the following four different ways:</source>
          <target state="translated">テストスイートの実行が進むにつれて、イベントは以下の4つの異なる方法で記録されます。</target>
        </trans-unit>
        <trans-unit id="d51e39f06d97806b242fd21b87f9a687999b2271" translate="yes" xml:space="preserve">
          <source>As the high bit of the first two atoms in the cache are not set we know that they are already in the cache, so they do not have to be sent again (this is the node name of the receiving and sending node). Then follows the atoms that have to be sent, together with their segment ids.</source>
          <target state="translated">キャッシュ内の最初の 2 つの原子のハイビットが設定されていないので、それらは既にキャッシュ内にあることがわかります。次に送信されなければならないアトムとそのセグメント ID を示します。</target>
        </trans-unit>
        <trans-unit id="2b99f096c11009199607e528c1ab4fde76715836" translate="yes" xml:space="preserve">
          <source>As the message is an &lt;code&gt;ETERM&lt;/code&gt; struct, Erl_Interface functions can be used to manipulate it. In this case, the message becomes a 3-tuple, because that is how the Erlang code is written. The second element will be the pid of the caller and the third element will be the tuple &lt;code&gt;{Function,Arg}&lt;/code&gt; determining which function to call, and with which argument. The result of calling the function is made into an &lt;code&gt;ETERM&lt;/code&gt; struct as well and sent back to Erlang using &lt;code&gt;erl_send()&lt;/code&gt;, which takes the open file descriptor, a pid, and a term as arguments:</source>
          <target state="translated">メッセージは &lt;code&gt;ETERM&lt;/code&gt; 構造体なので、Erl_Interface関数を使用して操作できます。この場合、メッセージは3タプルになります。これは、Erlangコードが記述される方法だからです。 2番目の要素は呼び出し元のpidで、3番目の要素は、呼び出す関数と引数を決定するタプル &lt;code&gt;{Function,Arg}&lt;/code&gt; です。関数を呼び出した結果も &lt;code&gt;ETERM&lt;/code&gt; 構造体になり、 &lt;code&gt;erl_send()&lt;/code&gt; を使用してErlangに送り返されます。これは、開いているファイル記述子、pid、および用語を引数として受け取ります。</target>
        </trans-unit>
        <trans-unit id="7146c7ac731941ac40a19a992206ba27e74fa230" translate="yes" xml:space="preserve">
          <source>As the position is specified as a byte-offset, take special caution when working with files where &lt;code&gt;encoding&lt;/code&gt; is set to something else than &lt;code&gt;latin1&lt;/code&gt;, as not every byte position is a valid character boundary on such a file.</source>
          <target state="translated">位置はバイトオフセットとして指定されるため、すべてのバイト位置がそのようなファイルで有効な文字境界であるとは限らないため、 &lt;code&gt;encoding&lt;/code&gt; が &lt;code&gt;latin1&lt;/code&gt; 以外に設定されているファイルを操作する場合は特に注意してください。</target>
        </trans-unit>
        <trans-unit id="f76a9267a5d5f392fb58b458fb3bf07880270ba9" translate="yes" xml:space="preserve">
          <source>As the runtime system handles the optimization (instead of the compiler), there are very few circumstances in which the optimization does not work.</source>
          <target state="translated">ランタイムシステムが(コンパイラの代わりに)最適化を処理するため、最適化が機能しない状況はほとんどありません。</target>
        </trans-unit>
        <trans-unit id="b697dde1f8ec4fdc0c53e1bd6391f4323555d01f" translate="yes" xml:space="preserve">
          <source>As the source code is distributed, it can easily be modified to accept other options. The program must still accept option &lt;code&gt;-data&lt;/code&gt; with the semantics described above for the release handler to work correctly.</source>
          <target state="translated">ソースコードは配布されているため、他のオプションを受け入れるように簡単に変更できます。プログラムは、リリースハンドラが正しく機能するために、上記のセマンティクスを持つオプション &lt;code&gt;-data&lt;/code&gt; を受け入れる必要があります。</target>
        </trans-unit>
        <trans-unit id="8795a3307568900a68fbd017733b56af3116954b" translate="yes" xml:space="preserve">
          <source>As the time offset is not allowed to change, time correction must adjust the frequency of the Erlang monotonic clock to align Erlang system time with OS system time smoothly. A significant downside of this approach is that we on purpose will use a faulty frequency on the Erlang monotonic clock if adjustments are needed. This error can be as large as 1%. This error will show up in all time measurements in the runtime system.</source>
          <target state="translated">時間オフセットは変更できないので、時間補正はErlangのモノトニッククロックの周波数を調整して、Erlangシステムの時間をOSシステムの時間にスムーズに合わせる必要があります。このアプローチの重大な欠点は、調整が必要な場合、わざとErlangモノトニッククロックの周波数に欠陥があるものを使ってしまうことです。このエラーは1%にもなります。この誤差はランタイムシステムのすべての時間計測に現れます。</target>
        </trans-unit>
        <trans-unit id="c394e9d8956e53ffa12dda34b51f038d61fe77cf" translate="yes" xml:space="preserve">
          <source>As the two alternatives are inside a &lt;code&gt;(?|&lt;/code&gt; group, both sets of capturing parentheses are numbered one. Thus, when the pattern matches, you can look at captured substring number one, whichever alternative matched. This construct is useful when you want to capture a part, but not all, of one of many alternatives. Inside a &lt;code&gt;(?|&lt;/code&gt; group, parentheses are numbered as usual, but the number is reset at the start of each branch. The numbers of any capturing parentheses that follow the subpattern start after the highest number used in any branch. The following example is from the Perl documentation; the numbers underneath show in which buffer the captured content is stored:</source>
          <target state="translated">2つの選択肢は &lt;code&gt;(?|&lt;/code&gt; グループ内にあるため、キャプチャする括弧の両方のセットには1の番号が付けられます。したがって、パターンが一致する場合、キャプチャされた部分文字列1を確認できます。どちらの選択肢も一致します。すべてではなく一部の多くの選択肢の一部です。 &lt;code&gt;(?|&lt;/code&gt; グループ内では、括弧は通常どおりに番号付けされますが、番号は各ブランチの開始時にリセットされます。サブパターンに続くキャプチャ括弧の番号は、すべてのブランチで使用される最大の番号次の例はPerlのドキュメントからのものであり、下の番号はキャプチャされたコンテンツが格納されているバッファを示しています。</target>
        </trans-unit>
        <trans-unit id="6b1ff2bd85ad93af178cdc629f19b070b543117b" translate="yes" xml:space="preserve">
          <source>As there can be many capturing parentheses in a pattern, all digits following the backslash are taken as part of a potential back reference number. If the pattern continues with a digit character, some delimiter must be used to terminate the back reference. If option &lt;code&gt;extended&lt;/code&gt; is set, this can be whitespace. Otherwise an empty comment (see section &lt;code&gt;&lt;a href=&quot;#sect19&quot;&gt;Comments&lt;/a&gt;&lt;/code&gt;) can be used.</source>
          <target state="translated">パターンには多くの括弧が含まれる可能性があるため、バックスラッシュに続くすべての数字は、潜在的な後方参照番号の一部として扱われます。パターンに数字が続く場合、後方参照を終了するためにいくつかの区切り文字を使用する必要があります。 &lt;code&gt;extended&lt;/code&gt; オプションが設定されている場合、これは空白にすることができます。それ以外の場合は、空のコメント（セクション &lt;code&gt;&lt;a href=&quot;#sect19&quot;&gt;Comments&lt;/a&gt;&lt;/code&gt; 参照）を使用できます。</target>
        </trans-unit>
        <trans-unit id="a74c4cf2304eafd1772e4800b2c34ab0218b1011" translate="yes" xml:space="preserve">
          <source>As there is no matching subexpression for the last part in the example (the &quot;g&quot;), nothing is inserted after that. To make the group of strings and the parts matching the subexpressions more obvious, one can use option &lt;code&gt;group&lt;/code&gt;, which groups together the part of the subject string with the parts matching the subexpressions when the string was split:</source>
          <target state="translated">例の最後の部分（ &quot;g&quot;）には一致する部分式がないため、その後には何も挿入されません。文字列のグループと部分式に一致する部分をより明確にするには、オプション &lt;code&gt;group&lt;/code&gt; を使用できます。これは、文字列が分割されたときに、対象文字列の部分と部分式に一致する部分をグループ化します。</target>
        </trans-unit>
        <trans-unit id="9e2c8ed56878a9d0ce4d6f8c64f1107a4ec68580" translate="yes" xml:space="preserve">
          <source>As these are the C library, the same limitations apply.</source>
          <target state="translated">これらはC言語のライブラリなので、同じ制限が適用されます。</target>
        </trans-unit>
        <trans-unit id="c163dd9740f51616c09627b0819df111304b0a64" translate="yes" xml:space="preserve">
          <source>As this interface implies that ports are killed when the last user disappears, the function does not hang waiting for ports to get closed.</source>
          <target state="translated">このインターフェイスは、最後のユーザがいなくなったときにポートが殺されることを暗示しているので、この関数はポートが閉じられるのを待ってハングアップすることはありません。</target>
        </trans-unit>
        <trans-unit id="e0d70780a73e5bd4165a4b0dfafa2579d2f5f128" translate="yes" xml:space="preserve">
          <source>As this module is of interest only to the maintainers of the compiler, and to avoid the same description in two places, the elements of &lt;code&gt;Options&lt;/code&gt; that control the warnings are only described in the &lt;code&gt; compile(3)&lt;/code&gt; module.</source>
          <target state="translated">このモジュールはコンパイラのメンテナだけが関心を持ち、2つの場所で同じ説明を避けるために、警告を制御する &lt;code&gt;Options&lt;/code&gt; の要素は &lt;code&gt; compile(3)&lt;/code&gt; モジュールでのみ説明されています。</target>
        </trans-unit>
        <trans-unit id="269a4f9e2c4144f24e95fc48fbc36000ea30889f" translate="yes" xml:space="preserve">
          <source>As this module is of interest only to the maintainers of the compiler, and to avoid the same description in two places, the elements of &lt;code&gt;Options&lt;/code&gt; that control the warnings are only described in the &lt;code&gt;compile(3)&lt;/code&gt; module.</source>
          <target state="translated">このモジュールはコンパイラーのメンテナーのみが対象であり、2か所で同じ説明を避けるため、警告を制御する &lt;code&gt;Options&lt;/code&gt; の要素は &lt;code&gt;compile(3)&lt;/code&gt; モジュールでのみ説明されています。</target>
        </trans-unit>
        <trans-unit id="4808daf64c94ffd2d15ac09bfa7bb9ffab8a8096" translate="yes" xml:space="preserve">
          <source>As was mentioned before, the graph analyses operate on the &lt;code&gt;digraph&lt;/code&gt; representation of graphs. By default, the &lt;code&gt;digraph&lt;/code&gt; representation is created when needed (and deleted when no longer used), but it can also be created explicitly by use of the &lt;code&gt;closure&lt;/code&gt; operator:</source>
          <target state="translated">前に述べたように、グラフ分析はグラフの &lt;code&gt;digraph&lt;/code&gt; 表現に作用します。デフォルトでは、 &lt;code&gt;digraph&lt;/code&gt; 表現は必要に応じて作成されます（使用されなくなると削除されます）が、 &lt;code&gt;closure&lt;/code&gt; 演算子を使用して明示的に作成することもできます。</target>
        </trans-unit>
        <trans-unit id="08da2b535fd9c3da81a12df0eca527a12e4f65fc" translate="yes" xml:space="preserve">
          <source>As was mentioned in the previous section, &lt;code&gt;start_erl&lt;/code&gt; requires a &lt;code&gt;sys.config&lt;/code&gt; in the release version directory (&lt;code&gt;&quot;releases/FIRST/sys.config&quot;&lt;/code&gt;). If there is no such file, the system start fails. Such a file must therefore also be added.</source>
          <target state="translated">前のセクションで述べたように、 &lt;code&gt;sys.config&lt;/code&gt; にはリリースバージョンディレクトリ（ &lt;code&gt;&quot;releases/FIRST/sys.config&quot;&lt;/code&gt; ）に &lt;code&gt;start_erl&lt;/code&gt; が必要です。そのようなファイルがない場合、システムの起動は失敗します。したがって、このようなファイルも追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="ec4d55429ba417e5335bd49e46c6d6d7ae28aa98" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;&lt;a href=&quot;#enif_make_resource&quot;&gt; enif_make_resource&lt;/a&gt;&lt;/code&gt;, no ownership transfer is done. The resource still needs to be released with &lt;code&gt;&lt;a href=&quot;#enif_release_resource&quot;&gt; enif_release_resource&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#enif_make_resource&quot;&gt; enif_make_resource&lt;/a&gt;&lt;/code&gt; と同様に、所有権の譲渡は行われません。リソースは、 &lt;code&gt;&lt;a href=&quot;#enif_release_resource&quot;&gt; enif_release_resource&lt;/a&gt;&lt;/code&gt; を使用して解放する必要があります。</target>
        </trans-unit>
        <trans-unit id="9f5cac0dfe306d70277c63b5386d001ed67533ac" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;&lt;a href=&quot;#enif_make_resource&quot;&gt;enif_make_resource&lt;/a&gt;&lt;/code&gt;, no ownership transfer is done. The resource still needs to be released with &lt;code&gt;&lt;a href=&quot;#enif_release_resource&quot;&gt;enif_release_resource&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#enif_make_resource&quot;&gt;enif_make_resource&lt;/a&gt;&lt;/code&gt; と同様に、所有権の譲渡は行われません。リソースは引き続き &lt;code&gt;&lt;a href=&quot;#enif_release_resource&quot;&gt;enif_release_resource&lt;/a&gt;&lt;/code&gt; で解放する必要があります。</target>
        </trans-unit>
        <trans-unit id="86dd8791c9b5f5dca561254006fe497e2d3994c7" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;erlang:send_nosuspend/2,3&lt;/code&gt;: use with extreme care.</source>
          <target state="translated">&lt;code&gt;erlang:send_nosuspend/2,3&lt;/code&gt; と同様に、細心の注意を払って使用してください。</target>
        </trans-unit>
        <trans-unit id="efe69f566993703e5412e0783db54d43802e91bd" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;run/3&lt;/code&gt;, compilation errors raise the &lt;code&gt;badarg&lt;/code&gt; exception. &lt;code&gt;&lt;a href=&quot;#compile-2&quot;&gt;compile/2&lt;/a&gt;&lt;/code&gt; can be used to get more information about the error.</source>
          <target state="translated">&lt;code&gt;run/3&lt;/code&gt; と同様に、コンパイルエラーは &lt;code&gt;badarg&lt;/code&gt; 例外を発生させます。 &lt;code&gt;&lt;a href=&quot;#compile-2&quot;&gt;compile/2&lt;/a&gt;&lt;/code&gt; を使用して、エラーに関する詳細情報を取得できます。</target>
        </trans-unit>
        <trans-unit id="65ddbc78ec2288effbfbc27dc2887832b0da7683" translate="yes" xml:space="preserve">
          <source>As with all other functions starting with &lt;code&gt;ei_&lt;/code&gt;, you are &lt;strong&gt;not&lt;/strong&gt; expected to put the socket in non-blocking mode yourself in the program. Every use of non-blocking mode is embedded inside the time-out functions. The socket will always be back in blocking mode after the operations are completed (regardless of the result). To avoid problems, leave the socket options alone. &lt;code&gt;ei&lt;/code&gt; handles any socket options that need modification.</source>
          <target state="translated">&lt;code&gt;ei_&lt;/code&gt; で始まる他のすべての関数と同様に、プログラムで自分でソケットを非ブロッキングモードにすることは想定されて&lt;strong&gt;いません&lt;/strong&gt;。非ブロッキングモードのすべての使用は、タイムアウト関数内に組み込まれています。操作が完了すると、ソケットは常にブロッキングモードに戻ります（結果に関係なく）。問題を回避するには、ソケットオプションをそのままにします。 &lt;code&gt;ei&lt;/code&gt; は、変更が必要なソケットオプションを処理します。</target>
        </trans-unit>
        <trans-unit id="9f18e260b234899264f52d7e455efafe8a0b767f" translate="yes" xml:space="preserve">
          <source>As with dynamically added child processes, the effects of deleting a static child process are lost if the supervisor itself restarts.</source>
          <target state="translated">動的に追加された子プロセスと同様に、スーパバイザ自身が再起動した場合、静的な子プロセスを削除する効果は失われます。</target>
        </trans-unit>
        <trans-unit id="c3c8339b0d633ff7f739e39a8bb36a1648a7db29" translate="yes" xml:space="preserve">
          <source>As with dynamically added child processes, the effects of deleting a static child process is lost if the supervisor itself restarts.</source>
          <target state="translated">動的に追加された子プロセスと同様に、スーパバイザ自身が再起動した場合、静的な子プロセスを削除する効果は失われます。</target>
        </trans-unit>
        <trans-unit id="ec50db8f3e13bb5768f12bc8a6a3b1ddcd9124a9" translate="yes" xml:space="preserve">
          <source>As with normal tree structures, lookup (membership testing), insertion, and deletion have logarithmic complexity.</source>
          <target state="translated">通常の木構造と同様に、ルックアップ(メンバーシップ・テスト)、挿入、削除は対数的な複雑さを持っています。</target>
        </trans-unit>
        <trans-unit id="96a345435dd16a7fc2f73434205466252ddf7e39" translate="yes" xml:space="preserve">
          <source>As with process monitors, each driver monitor set only generates &lt;strong&gt;one single message&lt;/strong&gt;. The monitor is &quot;destroyed&quot; after the message is sent, so it is then not needed to call &lt;code&gt;&lt;a href=&quot;#demonitor-1&quot;&gt;demonitor/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">プロセスモニターと同様に、各ドライバーモニターセットは&lt;strong&gt;1つのメッセージ&lt;/strong&gt;のみを生成し&lt;strong&gt;ます&lt;/strong&gt;。メッセージの送信後、モニターは「破棄」されるため、 &lt;code&gt;&lt;a href=&quot;#demonitor-1&quot;&gt;demonitor/1&lt;/a&gt;&lt;/code&gt; を呼び出す必要はありません。</target>
        </trans-unit>
        <trans-unit id="7211803cb34fb7ce9f0ec3a041a6c83ef73def40" translate="yes" xml:space="preserve">
          <source>As with processes we wanted to be able to do the most fundamental operations without having to acquire a lock on it. The most important being able to determine if we should enqueue a process in a specific run queue or not. This involves being able to read actual load, and load balancing information.</source>
          <target state="translated">プロセスと同様に、ロックを取得することなく最も基本的な操作ができるようにしたいと考えていました。最も重要なのは、特定のランキューにプロセスをエンキューすべきかどうかを判断できることです。これには、実際の負荷やロードバランシング情報を読み取れることが含まれます。</target>
        </trans-unit>
        <trans-unit id="b2467dbec656f95127f4a0e7d30ecc8a6ad6234f" translate="yes" xml:space="preserve">
          <source>As you can see by the example, the function can be called from the shell too. The &lt;code&gt;fun()&lt;/code&gt; needs to be literally in the call when used from the shell as well. Other means than the parse_transform are used in the shell case, but more or less the same restrictions apply (the exception being records, as they are not handled by the shell).</source>
          <target state="translated">例からわかるように、関数はシェルからも呼び出すことができます。 &lt;code&gt;fun()&lt;/code&gt; だけでなく、シェルから使用されたときのコールで、文字通りにする必要があります。parse_transform以外の手段がシェルの場合に使用されますが、多かれ少なかれ同じ制限が適用されます（レコードは例外であり、シェルによって処理されないため）。</target>
        </trans-unit>
        <trans-unit id="2b8232bbed24ef8f629ce1816536b7c03bfad7c6" translate="yes" xml:space="preserve">
          <source>As you can understand from the illustration, &lt;code&gt;Common Test&lt;/code&gt; requires a test case to generate a runtime error to indicate failure (for example, by causing a bad match error or by calling &lt;code&gt;exit/1&lt;/code&gt;, preferably through the help function &lt;code&gt;&lt;a href=&quot;ct#fail-1&quot;&gt;ct:fail/1,2&lt;/a&gt;&lt;/code&gt;). A successful execution is indicated by a normal return from the test case function.</source>
          <target state="translated">図から理解できるように、 &lt;code&gt;Common Test&lt;/code&gt; は、失敗を示すランタイムエラーを生成するためのテストケースを必要とします（たとえば、不適切な一致エラーを引き起こすか、 &lt;code&gt;exit/1&lt;/code&gt; を呼び出して、できればヘルプ関数 &lt;code&gt;&lt;a href=&quot;ct#fail-1&quot;&gt;ct:fail/1,2&lt;/a&gt;&lt;/code&gt; 介して）。 2）。成功した実行は、テストケース関数からの通常の戻りによって示されます。</target>
        </trans-unit>
        <trans-unit id="1d0f02291e9385ef819c0f808420bd9d22f20f88" translate="yes" xml:space="preserve">
          <source>As you have seen in the previous chapter, a standard URI can only contain a strict subset of the US ASCII character set, moreover the allowed set of characters is not the same in the different URI components. Percent-encoding is a mechanism to represent a data octet in a component when that octet's corresponding character is outside of the allowed set or is being used as a delimiter. This is what you see when &lt;code&gt;&quot;&amp;ouml;&quot;&lt;/code&gt; is encoded as &lt;code&gt;%C3%B6&lt;/code&gt; and &lt;code&gt;space&lt;/code&gt; as &lt;code&gt;%20&lt;/code&gt;. Most of the API functions are expecting UTF-8 encoding when handling percent-encoded triplets. The UTF-8 encoding of the &lt;code&gt;&lt;a href=&quot;unicode_usage#what-unicode-is&quot;&gt;Unicode&lt;/a&gt;&lt;/code&gt; character &lt;code&gt;&quot;&amp;ouml;&quot;&lt;/code&gt; is two octets: &lt;code&gt;OxC3 0xB6&lt;/code&gt;. The character &lt;code&gt;space&lt;/code&gt; is in the first 128 characters of &lt;code&gt;&lt;a href=&quot;unicode_usage#what-unicode-is&quot;&gt;Unicode&lt;/a&gt;&lt;/code&gt; and it is encoded using a single octet &lt;code&gt;0x20&lt;/code&gt;.</source>
          <target state="translated">前の章で見たように、標準URIには、US ASCII文字セットの厳密なサブセットのみを含めることができます。さらに、許可される文字セットは、異なるURIコンポーネントで同じではありません。パーセントエンコードは、コンポーネント内のデータオクテットを表すメカニズムであり、そのオクテットの対応する文字が許可されたセットの範囲外であるか、区切り文字として使用されています。これは、 &lt;code&gt;&quot;&amp;ouml;&quot;&lt;/code&gt; が &lt;code&gt;%C3%B6&lt;/code&gt; としてエンコードされ、 &lt;code&gt;space&lt;/code&gt; が &lt;code&gt;%20&lt;/code&gt; としてエンコードされたときに表示されるものです。ほとんどのAPI関数は、パーセントエンコードされたトリプレットを処理するときにUTF-8エンコードを想定しています。 &lt;code&gt;&lt;a href=&quot;unicode_usage#what-unicode-is&quot;&gt;Unicode&lt;/a&gt;&lt;/code&gt; 文字 &lt;code&gt;&quot;&amp;ouml;&quot;&lt;/code&gt; のUTF-8エンコーディングは2オクテットです： &lt;code&gt;OxC3 0xB6&lt;/code&gt; 。文字 &lt;code&gt;space&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;unicode_usage#what-unicode-is&quot;&gt;Unicode&lt;/a&gt;&lt;/code&gt; の最初の128文字であり、単一のオクテット &lt;code&gt;0x20&lt;/code&gt; を使用してエンコードされます。</target>
        </trans-unit>
        <trans-unit id="9b635d527fabae96e027fa225db3c0e9bac328ef" translate="yes" xml:space="preserve">
          <source>As you have seen, it is possible to use the &lt;code&gt;et_collector:report_event/5,6&lt;/code&gt; functions explicitly. By using those functions you can write your own trace client that reads trace data from any source stored in any format and just feed the &lt;code&gt;Collector&lt;/code&gt; with it. You may replace the default &lt;code&gt;Collector Filter&lt;/code&gt; with a filter that converts new exciting trace data formats to &lt;code&gt;Event Records&lt;/code&gt; or you may convert it to an &lt;code&gt;Event Record&lt;/code&gt; before you invoke &lt;code&gt;et_collector:report/2&lt;/code&gt; and then rely on the default &lt;code&gt;Collector Filter&lt;/code&gt; to handle the new format.</source>
          <target state="translated">&lt;code&gt;et_collector:report_event/5,6&lt;/code&gt; 、et_collector：report_event / 5,6関数を明示的に使用することができます。これらの関数を使用することにより、任意の形式で保存された任意のソースからトレースデータを読み取り、 &lt;code&gt;Collector&lt;/code&gt; にそれを供給するだけの独自のトレースクライアントを作成できます。デフォルトの &lt;code&gt;Collector Filter&lt;/code&gt; を、新しいエキサイティングなトレースデータ形式を &lt;code&gt;Event Records&lt;/code&gt; 変換するフィルターに置き換えるか、 &lt;code&gt;et_collector:report/2&lt;/code&gt; を呼び出す前に &lt;code&gt;Event Record&lt;/code&gt; に変換してから、デフォルトの &lt;code&gt;Collector Filter&lt;/code&gt; を使用して新しい形式を処理することができます。 。</target>
        </trans-unit>
        <trans-unit id="d261c2679b68d55f3f5768006262a218d859a604" translate="yes" xml:space="preserve">
          <source>Ask them to transform the internal state format and switch to the new version of the module.</source>
          <target state="translated">内部状態のフォーマットを変換して、新しいバージョンのモジュールに切り替えるように指示してください。</target>
        </trans-unit>
        <trans-unit id="7ccd30300261a4eca3d0f1af0fcf77d29e731e3c" translate="yes" xml:space="preserve">
          <source>Asking for and inspecting raw socket options require low-level information about the current operating system and TCP stack.</source>
          <target state="translated">生のソケットオプションを要求したり検査したりするには、現在のオペレーティングシステムとTCPスタックに関する低レベルの情報が必要です。</target>
        </trans-unit>
        <trans-unit id="f8fa830a1c76cc3d9b64640309d56c10ee2a5f9a" translate="yes" xml:space="preserve">
          <source>Asks the remote server of &lt;code&gt;ConnectionRef&lt;/code&gt; to listen to &lt;code&gt;ListenHost:ListenPort&lt;/code&gt;. When someone connects that address, the connection is forwarded in an encrypted channel from the server to the client. The client (that is, at the node that calls this function) then connects to &lt;code&gt;ConnectToHost:ConnectToPort&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ConnectionRef&lt;/code&gt; のリモートサーバーに &lt;code&gt;ListenHost:ListenPort&lt;/code&gt; をリッスンするように要求します。誰かがそのアドレスに接続すると、接続は暗号化されたチャネルでサーバーからクライアントに転送されます。次に、クライアント（つまり、この関数を呼び出すノード）が &lt;code&gt;ConnectToHost:ConnectToPort&lt;/code&gt; に接続します。</target>
        </trans-unit>
        <trans-unit id="0599d793007329beb80221bb5065e2bf255ef6e5" translate="yes" xml:space="preserve">
          <source>Assert end of string (or line, in multiline mode)</source>
          <target state="translated">文字列(または行、複数行モードの場合)の終了をアサートします。</target>
        </trans-unit>
        <trans-unit id="cf59339e55d5c656acd77a3516f63cf3ff15de3e" translate="yes" xml:space="preserve">
          <source>Assert start of string (or line, in multiline mode)</source>
          <target state="translated">文字列(または行、複数行モードの場合)の開始をアサートします。</target>
        </trans-unit>
        <trans-unit id="18d329141ee34e40c36d7b169bb7a159eb5aeb08" translate="yes" xml:space="preserve">
          <source>Assertion subpatterns are not capturing subpatterns. If such an assertion contains capturing subpatterns within it, these are counted for the purposes of numbering the capturing subpatterns in the whole pattern. However, substring capturing is done only for positive assertions. (Perl sometimes, but not always, performs capturing in negative assertions.)</source>
          <target state="translated">アサーション・サブパターンは、キャプチャ・サブパターンではありません。そのようなアサーションの中に捕捉サブパターンが含まれている場合、パターン全体の捕捉サブパターンに番号を付ける目的で、これらのサブパターンがカウントされます。しかし、部分文字列の捕捉は正のアサーションに対してのみ行われます。(Perl は負のアサーションでキャプチャを実行することもありますが、常にではありません)。</target>
        </trans-unit>
        <trans-unit id="dc3e91b0be656a68c41466178566755f49840e06" translate="yes" xml:space="preserve">
          <source>Assertions can be nested in any combination. For example, the following matches an occurrence of &quot;baz&quot; that is preceded by &quot;bar&quot;, which in turn is not preceded by &quot;foo&quot;:</source>
          <target state="translated">アサーションは、任意の組み合わせで入れ子にすることができます。例えば、以下の例では、&quot;bar&quot; の前に &quot;baz&quot; があり、&quot;foo&quot; の前には &quot;foo&quot; がない場合にマッチします。</target>
        </trans-unit>
        <trans-unit id="8383a156cd04a5d92aafffd1ec55eeaa8e37c727" translate="yes" xml:space="preserve">
          <source>Assigning a value to type &lt;code&gt;Operational&lt;/code&gt; in Erlang is possible by using the following Erlang code:</source>
          <target state="translated">Erlangでタイプ &lt;code&gt;Operational&lt;/code&gt; に値を割り当てるには、次のErlangコードを使用します。</target>
        </trans-unit>
        <trans-unit id="4ad8afb43e64d75a730687d995308551590810c9" translate="yes" xml:space="preserve">
          <source>Assignment ::= Variable &lt;code&gt;:=&lt;/code&gt; Expression | Variable &lt;code&gt;=&lt;/code&gt; Expression</source>
          <target state="translated">割り当て:: =変数 &lt;code&gt;:=&lt;/code&gt; 式| 変数 &lt;code&gt;=&lt;/code&gt; 式</target>
        </trans-unit>
        <trans-unit id="7585e904a125702314b9a3cc974072554cd19dc1" translate="yes" xml:space="preserve">
          <source>Assigns a new controlling process &lt;code&gt;Pid&lt;/code&gt; to &lt;code&gt;Socket&lt;/code&gt;. Same implementation as &lt;code&gt;&lt;a href=&quot;gen_udp#controlling_process-2&quot;&gt;gen_udp:controlling_process/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">新しい制御プロセス &lt;code&gt;Pid&lt;/code&gt; を &lt;code&gt;Socket&lt;/code&gt; に割り当てます。 &lt;code&gt;&lt;a href=&quot;gen_udp#controlling_process-2&quot;&gt;gen_udp:controlling_process/2&lt;/a&gt;&lt;/code&gt; と同じ実装。</target>
        </trans-unit>
        <trans-unit id="31732955b5b879b8595ccb4012494c26bfc62323" translate="yes" xml:space="preserve">
          <source>Assigns a new controlling process &lt;code&gt;Pid&lt;/code&gt; to &lt;code&gt;Socket&lt;/code&gt;. Same implementation as &lt;code&gt;gen_udp:controlling_process/2&lt;/code&gt;.</source>
          <target state="translated">新しい制御プロセス &lt;code&gt;Pid&lt;/code&gt; を &lt;code&gt;Socket&lt;/code&gt; に割り当てます。 &lt;code&gt;gen_udp:controlling_process/2&lt;/code&gt; と同じ実装。</target>
        </trans-unit>
        <trans-unit id="750263088fcf3a705a426666d4ba4253060235cc" translate="yes" xml:space="preserve">
          <source>Assigns a new controlling process &lt;code&gt;Pid&lt;/code&gt; to &lt;code&gt;Socket&lt;/code&gt;. The controlling process is the process that receives messages from the socket. If called by any other process than the current controlling process, &lt;code&gt;{error, not_owner}&lt;/code&gt; is returned. If the process identified by &lt;code&gt;Pid&lt;/code&gt; is not an existing local pid, &lt;code&gt;{error, badarg}&lt;/code&gt; is returned. &lt;code&gt;{error, badarg}&lt;/code&gt; may also be returned in some cases when &lt;code&gt;Socket&lt;/code&gt; is closed during the execution of this function.</source>
          <target state="translated">新しい制御プロセス &lt;code&gt;Pid&lt;/code&gt; を &lt;code&gt;Socket&lt;/code&gt; に割り当てます。制御プロセスは、ソケットからメッセージを受信するプロセスです。現在の制御プロセス以外のプロセスによって呼び出された場合、 &lt;code&gt;{error, not_owner}&lt;/code&gt; が返されます。 &lt;code&gt;Pid&lt;/code&gt; で識別されるプロセスが既存のローカルpidでない場合、 &lt;code&gt;{error, badarg}&lt;/code&gt; が返されます。 &lt;code&gt;{error, badarg}&lt;/code&gt; は、この関数の実行中に &lt;code&gt;Socket&lt;/code&gt; が閉じられた場合にも返されることがあります。</target>
        </trans-unit>
        <trans-unit id="83e6ee60d090046ec0df21d8f20b308779b0123e" translate="yes" xml:space="preserve">
          <source>Assigns a new controlling process to the SSL socket. A controlling process is the owner of an SSL socket, and receives all messages from the socket.</source>
          <target state="translated">新しい制御プロセスをSSLソケットに割り当てます。制御プロセスはSSLソケットのオーナーであり、ソケットからのすべてのメッセージを受信します。</target>
        </trans-unit>
        <trans-unit id="e2015efa67c45a84e357363963f8ef7cc19116af" translate="yes" xml:space="preserve">
          <source>Associate a result set containing the whole table &lt;code&gt;EMPLOYEE&lt;/code&gt; to the connection. The number of rows in the result set is returned.</source>
          <target state="translated">テーブル &lt;code&gt;EMPLOYEE&lt;/code&gt; 全体を含む結果セットを接続に関連付けます。結果セットの行数が返されます。</target>
        </trans-unit>
        <trans-unit id="c01c817bd8220a9e426732586a19782a2ec8dae2" translate="yes" xml:space="preserve">
          <source>Associate a result set that contains the fields &lt;code&gt;FIRSTNAME&lt;/code&gt; and &lt;code&gt;NR&lt;/code&gt; for all female employees to the connection. The number of rows in the result set is returned.</source>
          <target state="translated">すべての女性従業員のフィールド &lt;code&gt;FIRSTNAME&lt;/code&gt; および &lt;code&gt;NR&lt;/code&gt; を含む結果セットを接続に関連付けます。結果セットの行数が返されます。</target>
        </trans-unit>
        <trans-unit id="e682a3847cd3fad46ea3e5c2bf3acec87c695369" translate="yes" xml:space="preserve">
          <source>Associates &lt;code&gt;Key&lt;/code&gt; with value &lt;code&gt;Value&lt;/code&gt; and inserts the association into map &lt;code&gt;Map2&lt;/code&gt;. If key &lt;code&gt;Key&lt;/code&gt; already exists in map &lt;code&gt;Map1&lt;/code&gt;, the old associated value is replaced by value &lt;code&gt;Value&lt;/code&gt;. The function returns a new map &lt;code&gt;Map2&lt;/code&gt; containing the new association and the old associations in &lt;code&gt;Map1&lt;/code&gt;.</source>
          <target state="translated">アソシエイツ &lt;code&gt;Key&lt;/code&gt; 値の &lt;code&gt;Value&lt;/code&gt; と挿入マップに関連 &lt;code&gt;Map2&lt;/code&gt; 。キー &lt;code&gt;Key&lt;/code&gt; がマップ &lt;code&gt;Map1&lt;/code&gt; にすでに存在する場合、古い関連値は値 &lt;code&gt;Value&lt;/code&gt; に置き換えられます。この関数は、新しい関連付けと &lt;code&gt;Map1&lt;/code&gt; の古い関連付けを含む新しいマップ &lt;code&gt;Map2&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="fe25fda4b17970a0ef529403d3f726c24aae538c" translate="yes" xml:space="preserve">
          <source>Associates a UDP port number (&lt;code&gt;Port&lt;/code&gt;) with the calling process.</source>
          <target state="translated">UDPポート番号（ &lt;code&gt;Port&lt;/code&gt; ）を呼び出しプロセスに関連付けます。</target>
        </trans-unit>
        <trans-unit id="f1f8648a03de87c0a9794d9b8e650c32fee361c7" translate="yes" xml:space="preserve">
          <source>Associates the name &lt;code&gt;Name&lt;/code&gt;, an atom, with the process &lt;code&gt;Pid&lt;/code&gt;.</source>
          <target state="translated">名前 &lt;code&gt;Name&lt;/code&gt; 、アトムをプロセス &lt;code&gt;Pid&lt;/code&gt; に関連付けます。</target>
        </trans-unit>
        <trans-unit id="adba476945469569c82884884c1c62b87ee5beca" translate="yes" xml:space="preserve">
          <source>Associates the name &lt;code&gt;RegName&lt;/code&gt; with a process identifier (pid) or a port identifier. &lt;code&gt;RegName&lt;/code&gt;, which must be an atom, can be used instead of the pid or port identifier in send operator (&lt;code&gt;RegName ! Message&lt;/code&gt;). Example:</source>
          <target state="translated">&lt;code&gt;RegName&lt;/code&gt; という名前をプロセス識別子（pid）またはポート識別子に関連付けます。 &lt;code&gt;RegName&lt;/code&gt; はアトムである必要がありますが、送信演算子（ &lt;code&gt;RegName ! Message&lt;/code&gt; ）でpidまたはポート識別子の代わりに使用できます。例：</target>
        </trans-unit>
        <trans-unit id="41bb0af24396833201992ca15a0ccfba7ee7f093" translate="yes" xml:space="preserve">
          <source>Associates the test run with a name that gets printed in the overview HTML log files.</source>
          <target state="translated">テスト実行を、概要のHTMLログファイルに表示される名前に関連付けます。</target>
        </trans-unit>
        <trans-unit id="98d38dc74b49e5a78d0c258ce1027deadc489dd0" translate="yes" xml:space="preserve">
          <source>Association File</source>
          <target state="translated">アソシエーションファイル</target>
        </trans-unit>
        <trans-unit id="437c9a7c9031d1af11bb4c9c4f2d1cfe844e612f" translate="yes" xml:space="preserve">
          <source>Association Types</source>
          <target state="translated">アソシエーションの種類</target>
        </trans-unit>
        <trans-unit id="a929bb502012d59c211ba29e792fdfc1bcec65b6" translate="yes" xml:space="preserve">
          <source>Association is successfully established. This indicates a successful completion of &lt;code&gt;connect&lt;/code&gt;.</source>
          <target state="translated">協会が設立されました。これは、 &lt;code&gt;connect&lt;/code&gt; 正常に完了したことを示します。</target>
        </trans-unit>
        <trans-unit id="134d6b41e63f8d58f043111b94e89dcdbcc5edb8" translate="yes" xml:space="preserve">
          <source>Associations</source>
          <target state="translated">Associations</target>
        </trans-unit>
        <trans-unit id="9517f720a79af71f615e7adc80ef320ce8b35b80" translate="yes" xml:space="preserve">
          <source>Assume a test that generates some parallel stateful commands, and runs 300 tests:</source>
          <target state="translated">いくつかの並列ステートフルコマンドを生成し、300のテストを実行するテストを想定します。</target>
        </trans-unit>
        <trans-unit id="cd321e5d28d57fcf199c5a0fe6ae644a0f00e982" translate="yes" xml:space="preserve">
          <source>Assume that a module is extended by adding an interface function, as in the example in &lt;code&gt;&lt;a href=&quot;release_handling#appup&quot;&gt;Release Handling&lt;/a&gt;&lt;/code&gt;, where a function &lt;code&gt;available/0&lt;/code&gt; is added to &lt;code&gt;ch3&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;release_handling#appup&quot;&gt;Release Handling&lt;/a&gt;&lt;/code&gt; の例のように、関数 &lt;code&gt;available/0&lt;/code&gt; が &lt;code&gt;ch3&lt;/code&gt; に追加されるように、インターフェース関数を追加することによってモジュールが拡張されると想定します。</target>
        </trans-unit>
        <trans-unit id="81e67a14a83897861024d39ef25a7c52fdc905a0" translate="yes" xml:space="preserve">
          <source>Assume that a test case for the following program should be verified:</source>
          <target state="translated">以下のプログラムのテストケースを検証するとします。</target>
        </trans-unit>
        <trans-unit id="71a8953ab141a80996cc4c7f627c6481c2d38dca" translate="yes" xml:space="preserve">
          <source>Assume that a user does not want Erlang to use the native lookup method, but wants Erlang to read all information necessary from start and use that for resolving names and addresses. If lookup fails, Erlang is to request the data from a nameserver (using the Erlang DNS client, set to use EDNS allowing larger responses). The resolver configuration is updated when its configuration file changes. Also, DNS records are never to be cached. The user configuration file (in this example named &lt;code&gt;erl_inetrc&lt;/code&gt;, stored in directory &lt;code&gt;./cfg_files&lt;/code&gt;) can then look as follows (Unix):</source>
          <target state="translated">ユーザーがErlangにネイティブルックアップメソッドを使用させたくないが、Erlangに最初から必要なすべての情報を読み取って、名前とアドレスを解決するためにそれを使用させたいと仮定します。ルックアップが失敗した場合、Erlangはネームサーバーにデータを要求します（Erlang DNSクライアントを使用して、より大きな応答を許可するEDNSを使用するように設定します）。リゾルバー構成は、構成ファイルが変更されると更新されます。また、DNSレコードはキャッシュされません。ユーザー構成ファイル（この例では、ディレクトリ &lt;code&gt;./cfg_files&lt;/code&gt; に格納されている &lt;code&gt;erl_inetrc&lt;/code&gt; という名前）は、次のようになります（UNIX）。</target>
        </trans-unit>
        <trans-unit id="2d48df2f1a8f0fd07793d2b425e8df418ef5bfad" translate="yes" xml:space="preserve">
          <source>Assume that nothing happens when tracing in this way. The function is never called with these parameters. We conclude that someone else (some other module) is doing it and realize that we must trace on &lt;code&gt;ets:insert/2&lt;/code&gt; and want to see the calling function. The calling function can be retrieved using the match specification function &lt;code&gt;caller&lt;/code&gt;. To get it into the trace message, the match specification function &lt;code&gt;message&lt;/code&gt; must be used. The filter call looks like this (looking for calls to &lt;code&gt;ets:insert/2&lt;/code&gt;):</source>
          <target state="translated">このようにトレースしても何も起こらないとします。これらのパラメーターを指定して関数が呼び出されることはありません。他の誰か（他のモジュール）がそれを実行していると結論付け、 &lt;code&gt;ets:insert/2&lt;/code&gt; をたどって、呼び出し元の関数を確認する必要があることを認識します。呼び出し関数は、一致指定関数 &lt;code&gt;caller&lt;/code&gt; を使用して取得できます。トレースメッセージに含めるには、一致指定機能 &lt;code&gt;message&lt;/code&gt; 使用する必要があります。フィルターの呼び出しは次のようになります（ &lt;code&gt;ets:insert/2&lt;/code&gt; の呼び出しを探します）。</target>
        </trans-unit>
        <trans-unit id="997882ed021f898e3c4711038cfd690fedaa8231" translate="yes" xml:space="preserve">
          <source>Assume that the module now passes all testing and goes into the system. After a while, it is found that table &lt;code&gt;toy_table&lt;/code&gt; grows while the system is running and that there are many elements with atoms as keys. We expected only integer keys and so does the rest of the system, but clearly not the entire system. We turn on call tracing and try to see calls to the module with an atom as the key:</source>
          <target state="translated">モジュールがすべてのテストに合格し、システムに入ると仮定します。しばらくすると、システムの実行中にテーブル &lt;code&gt;toy_table&lt;/code&gt; が大きくなり、アトムをキーとして持つ要素が多数あることがわかります。整数キーだけを期待し、システムの残りの部分もそうでしたが、システム全体ではありませんでした。呼び出しトレースをオンにして、アトムをキーとしてモジュールへの呼び出しを確認します。</target>
        </trans-unit>
        <trans-unit id="f89a940266dfec94c78b06cb601b527f92f04417" translate="yes" xml:space="preserve">
          <source>Assume that the suite contains the test case &lt;code&gt;get_resource_status&lt;/code&gt; that is independent of the other two cases, then function &lt;code&gt;all&lt;/code&gt; can look as follows:</source>
          <target state="translated">スイートに他の2つのケースから独立したテストケース &lt;code&gt;get_resource_status&lt;/code&gt; が含まれているとすると、関数は &lt;code&gt;all&lt;/code&gt; 次のようになります。</target>
        </trans-unit>
        <trans-unit id="d831964edca879d5d90599f59a999703ad024ad1" translate="yes" xml:space="preserve">
          <source>Assume that there are two systems, &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt;, that are tested in separate test runs. System &lt;code&gt;s1&lt;/code&gt; contains a library module &lt;code&gt;m1&lt;/code&gt; tested by test run &lt;code&gt;s1&lt;/code&gt; and is included in the cover specification of &lt;code&gt;s1&lt;/code&gt; as follows:</source>
          <target state="translated">別々のテスト実行でテストされる2つのシステム &lt;code&gt;s1&lt;/code&gt; と &lt;code&gt;s2&lt;/code&gt; があると仮定します。システム &lt;code&gt;s1&lt;/code&gt; には、テスト実行 &lt;code&gt;s1&lt;/code&gt; によってテストされたライブラリモジュール &lt;code&gt;m1&lt;/code&gt; が含まれており、次のように &lt;code&gt;s1&lt;/code&gt; のカバー仕様に含まれています。</target>
        </trans-unit>
        <trans-unit id="0a42279cd9be030fbaa5a2fcc34c767220fae2bb" translate="yes" xml:space="preserve">
          <source>Assume that there is a network application that receives instances of the ASN.1 defined type &lt;code&gt;Person&lt;/code&gt;, modifies, and sends them back again:</source>
          <target state="translated">ASN.1で定義されたタイプ &lt;code&gt;Person&lt;/code&gt; のインスタンスを受信し、変更して、それらを再度送信するネットワークアプリケーションがあるとします。</target>
        </trans-unit>
        <trans-unit id="33069b991dada2eb5da77ef53b4f64ef6b97abaa" translate="yes" xml:space="preserve">
          <source>Assume that there is an index on position &lt;code&gt;Pos&lt;/code&gt; for a certain record type. This function can be used to read the records without knowing the actual key for the record. For example, with an index in position 1 of table &lt;code&gt;person&lt;/code&gt;, the call &lt;code&gt;mnesia:index_read(person, 36, #person.age)&lt;/code&gt; returns a list of all persons with age 36. &lt;code&gt;Pos&lt;/code&gt; can also be an attribute name (atom), but if the notation &lt;code&gt;mnesia:index_read(person, 36, age)&lt;/code&gt; is used, the field position is searched for in runtime, for each call.</source>
          <target state="translated">特定のレコードタイプの位置 &lt;code&gt;Pos&lt;/code&gt; にインデックスがあると仮定します。この関数を使用して、レコードの実際のキーを知らなくてもレコードを読み取ることができます。例えば、テーブルの位置1のインデックスと &lt;code&gt;person&lt;/code&gt; 、コール &lt;code&gt;mnesia:index_read(person, 36, #person.age)&lt;/code&gt; 年齢36ですべての人のリストを返し &lt;code&gt;Pos&lt;/code&gt; 、また、属性名（アトム）ことができますが、表記 &lt;code&gt;mnesia:index_read(person, 36, age)&lt;/code&gt; が使用されている場合、フィールドの位置は実行時に呼び出しごとに検索されます。</target>
        </trans-unit>
        <trans-unit id="829ce164f6e9881978858a93ac53473e3de7a2fe" translate="yes" xml:space="preserve">
          <source>Assume that we have not found the problem yet, and want to see what &lt;code&gt;ets:new/2&lt;/code&gt; returns. We use a slightly different trace pattern:</source>
          <target state="translated">問題をまだ見つけておらず、 &lt;code&gt;ets:new/2&lt;/code&gt; が何を返すかを確認したいとします。少し異なるトレースパターンを使用します。</target>
        </trans-unit>
        <trans-unit id="58d7492d43f93e533d2fc8b2893194dfb95c91d5" translate="yes" xml:space="preserve">
          <source>Assume that we want the whole object matching instead of only one element. One alternative is to assign a variable to every part of the record and build it up once again in the body of the fun, but the following is easier:</source>
          <target state="translated">1つの要素だけではなく、オブジェクト全体をマッチングさせたいと仮定します。1つの選択肢として、レコードの各部分に変数を代入して、それをお楽しみの本文でもう一度構築するという方法もありますが、以下の方が簡単です。</target>
        </trans-unit>
        <trans-unit id="d1bf62160b9303fd32fdad0cd34b9da4d1aef481" translate="yes" xml:space="preserve">
          <source>Assume that we want to get all the employee numbers of employees hired before year 2000. Using &lt;code&gt;ets:match/2&lt;/code&gt; is not an alternative here, as relational operators cannot be expressed there. Once again, &lt;code&gt;ets:foldr/3&lt;/code&gt; can do it (slowly, but correct):</source>
          <target state="translated">2000年より前に雇用された従業員のすべての従業員数を取得するとします。関係演算子はそこで表現できないため、 &lt;code&gt;ets:match/2&lt;/code&gt; を使用することはここでは代替手段ではありません。もう一度、 &lt;code&gt;ets:foldr/3&lt;/code&gt; はそれを行うことができます（ゆっくりですが正しい）：</target>
        </trans-unit>
        <trans-unit id="35f82a62b9c069adc233b8d62c83260928f4ae7a" translate="yes" xml:space="preserve">
          <source>Assume that we want to test the lists:sort/1 function.</source>
          <target state="translated">lists:sort/1関数をテストしたいとします。</target>
        </trans-unit>
        <trans-unit id="1ba39d9d328d97a989e24d8ac3124b4d21b0636f" translate="yes" xml:space="preserve">
          <source>Assume that you have an initiating process with &lt;code&gt;Pid == &amp;lt;0.30.0&amp;gt;&lt;/code&gt; like this:</source>
          <target state="translated">次のような &lt;code&gt;Pid == &amp;lt;0.30.0&amp;gt;&lt;/code&gt; 開始プロセスがあるとします。</target>
        </trans-unit>
        <trans-unit id="59beb2deb0d2bf3ac19ece9f2db7b475398662e6" translate="yes" xml:space="preserve">
          <source>Assume that you want to calculate the factorial for 1:</source>
          <target state="translated">1の階乗を計算したいと仮定します。</target>
        </trans-unit>
        <trans-unit id="81e6855c42a523802dad6f1c6e5e336c4662d743" translate="yes" xml:space="preserve">
          <source>Assume that you want to transform the &lt;code&gt;&lt;a href=&quot;#motorcyclesxml&quot;&gt;motorcycles.xml&lt;/a&gt;&lt;/code&gt; document to HTML. If you want the same structure and tags of the resulting HTML document as of the XML document then you can use the &lt;code&gt;xmerl:export/2&lt;/code&gt; function. The following:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#motorcyclesxml&quot;&gt;motorcycles.xml&lt;/a&gt;&lt;/code&gt; ドキュメントをHTML に変換するとします。結果のHTMLドキュメントとXMLドキュメントとで同じ構造とタグが必要な場合は、 &lt;code&gt;xmerl:export/2&lt;/code&gt; 関数を使用できます。以下：</target>
        </trans-unit>
        <trans-unit id="42a5d8a52feabf03d2cc601350c97037810f3131" translate="yes" xml:space="preserve">
          <source>Assume the following:</source>
          <target state="translated">以下のように想定してください。</target>
        </trans-unit>
        <trans-unit id="b4dd172e924a451d443d3ebe731fdc5eb7eae97d" translate="yes" xml:space="preserve">
          <source>Assume we want to check the following module:</source>
          <target state="translated">以下のモジュールを確認したいとします。</target>
        </trans-unit>
        <trans-unit id="a1917e9bb4b3ba3244f0149508301240f3ef84a5" translate="yes" xml:space="preserve">
          <source>Assumes that &lt;code&gt;Term&lt;/code&gt; is a term with the same structure as a &lt;code&gt;erl_parse&lt;/code&gt; tree, but with &lt;code&gt;&lt;a href=&quot;erl_anno#type-location&quot;&gt;locations&lt;/a&gt;&lt;/code&gt; where a &lt;code&gt;erl_parse&lt;/code&gt; tree has collections of annotations. Returns a &lt;code&gt;erl_parse&lt;/code&gt; tree where each location &lt;code&gt;L&lt;/code&gt; is replaced by the value returned by &lt;code&gt;&lt;a href=&quot;erl_anno#new-1&quot;&gt;erl_anno:new(L)&lt;/a&gt;&lt;/code&gt;. The term &lt;code&gt;Term&lt;/code&gt; is traversed in a depth-first, left-to-right fashion.</source>
          <target state="translated">ことを前提としてい &lt;code&gt;Term&lt;/code&gt; 同じ構造を持つ用語である &lt;code&gt;erl_parse&lt;/code&gt; 木、しかしと &lt;code&gt;&lt;a href=&quot;erl_anno#type-location&quot;&gt;locations&lt;/a&gt;&lt;/code&gt; &lt;code&gt;erl_parse&lt;/code&gt; のツリーが注釈の集合を有しています。各位置 &lt;code&gt;L&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;erl_anno#new-1&quot;&gt;erl_anno:new(L)&lt;/a&gt;&lt;/code&gt; によって返された値で置き換えられた &lt;code&gt;erl_parse&lt;/code&gt; ツリーを返します。用語という &lt;code&gt;Term&lt;/code&gt; は、深さ優先、左から右の方法でトラバースされます。</target>
        </trans-unit>
        <trans-unit id="d66afe8dfdd48d923747ad2c5c5b06df8c1510d8" translate="yes" xml:space="preserve">
          <source>Assumes that &lt;code&gt;Term&lt;/code&gt; is a term with the same structure as a &lt;code&gt;erl_parse&lt;/code&gt; tree, but with terms, say &lt;code&gt;T&lt;/code&gt;, where a &lt;code&gt;erl_parse&lt;/code&gt; tree has collections of annotations. Returns a &lt;code&gt;erl_parse&lt;/code&gt; tree where each term &lt;code&gt;T&lt;/code&gt; is replaced by the value returned by &lt;code&gt;&lt;a href=&quot;erl_anno#from_term-1&quot;&gt; erl_anno:from_term(T)&lt;/a&gt;&lt;/code&gt;. The term &lt;code&gt;Term&lt;/code&gt; is traversed in a depth-first, left-to-right fashion.</source>
          <target state="translated">ことを前提としてい &lt;code&gt;Term&lt;/code&gt; 同じ構造を持つ用語である &lt;code&gt;erl_parse&lt;/code&gt; ツリーが、用語と、言う &lt;code&gt;T&lt;/code&gt; 、 &lt;code&gt;erl_parse&lt;/code&gt; の木は、注釈のコレクションを持っています。各項 &lt;code&gt;T&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;erl_anno#from_term-1&quot;&gt; erl_anno:from_term(T)&lt;/a&gt;&lt;/code&gt; によって返される値に置き換えられた &lt;code&gt;erl_parse&lt;/code&gt; ツリーを返します。用語の &lt;code&gt;Term&lt;/code&gt; 深さ優先、左から右へ様式でトラバースされます。</target>
        </trans-unit>
        <trans-unit id="b7cafb7be7f1db85e6934ccfbc9df1141dff9353" translate="yes" xml:space="preserve">
          <source>Assumes that &lt;code&gt;Term&lt;/code&gt; is a term with the same structure as a &lt;code&gt;erl_parse&lt;/code&gt; tree, but with terms, say &lt;code&gt;T&lt;/code&gt;, where a &lt;code&gt;erl_parse&lt;/code&gt; tree has collections of annotations. Returns a &lt;code&gt;erl_parse&lt;/code&gt; tree where each term &lt;code&gt;T&lt;/code&gt; is replaced by the value returned by &lt;code&gt;&lt;a href=&quot;erl_anno#from_term-1&quot;&gt;erl_anno:from_term(T)&lt;/a&gt;&lt;/code&gt;. The term &lt;code&gt;Term&lt;/code&gt; is traversed in a depth-first, left-to-right fashion.</source>
          <target state="translated">ことを前提としてい &lt;code&gt;Term&lt;/code&gt; 同じ構造を持つ用語である &lt;code&gt;erl_parse&lt;/code&gt; ツリーが、用語と、言う &lt;code&gt;T&lt;/code&gt; 、 &lt;code&gt;erl_parse&lt;/code&gt; の木は、注釈のコレクションを持っています。各項 &lt;code&gt;T&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;erl_anno#from_term-1&quot;&gt;erl_anno:from_term(T)&lt;/a&gt;&lt;/code&gt; によって返された値で置き換えられた &lt;code&gt;erl_parse&lt;/code&gt; ツリーを返します。用語という &lt;code&gt;Term&lt;/code&gt; は、深さ優先、左から右の方法でトラバースされます。</target>
        </trans-unit>
        <trans-unit id="0867c9c6c98bb1857eef83b5370df89b6931896a" translate="yes" xml:space="preserve">
          <source>Assuming &lt;code&gt;Forms&lt;/code&gt; represents a program (or any sequence of &quot;program forms&quot;), any comments whose first lines are not directly associated with a specific program form will become standalone comments inserted between the neighbouring program forms. Furthermore, comments whose column position is less than or equal to one will not be attached to a program form that begins at a conflicting line number (this can happen with preprocessor-generated &lt;code&gt;line&lt;/code&gt;-attributes).</source>
          <target state="translated">&lt;code&gt;Forms&lt;/code&gt; がプログラム（または「プログラムフォーム」のシーケンス）を表すとすると、最初の行が特定のプログラムフォームに直接関連付けられていないコメントは、隣接するプログラムフォームの間に挿入されるスタンドアロンコメントになります。さらに、列位置が1以下のコメントは、競合する行番号で始まるプログラムフォームには添付されません（これは、プリプロセッサで生成された &lt;code&gt;line&lt;/code&gt; 属性で発生する可能性があります）。</target>
        </trans-unit>
        <trans-unit id="85756eb2ccf84d68d4412ebf0e79850cfd5d276b" translate="yes" xml:space="preserve">
          <source>Assuming an Erlang system called ping (but not the &quot;ping&quot; process) has already been started on kosken, then on gollum this is done:</source>
          <target state="translated">kosken上でpingというErlangシステム(ただし &quot;ping &quot;プロセスではない)がすでに起動されていると仮定すると、gollum上ではこれが行われます。</target>
        </trans-unit>
        <trans-unit id="10a82aabb0e61cdb059228faa6975a490d22e3b9" translate="yes" xml:space="preserve">
          <source>Assuming an Ets table that uses &lt;code&gt;idno&lt;/code&gt; as key and contains the following:</source>
          <target state="translated">&lt;code&gt;idno&lt;/code&gt; をキーとして使用し、以下を含むEtsテーブルを想定します。</target>
        </trans-unit>
        <trans-unit id="18d8e312811328614a25350d0eb0a85b61ed61f9" translate="yes" xml:space="preserve">
          <source>Assuming that both the arguments and the results from the C functions are less than 256, a simple encoding/decoding scheme is employed. In this scheme, &lt;code&gt;foo&lt;/code&gt; is represented by byte 1, &lt;code&gt;bar&lt;/code&gt; is represented by 2, and the argument/result is represented by a single byte as well:</source>
          <target state="translated">引数とC関数の結果の両方が256未満であると仮定すると、単純なエンコード/デコード方式が採用されます。このスキームでは、 &lt;code&gt;foo&lt;/code&gt; はバイト1で表され、 &lt;code&gt;bar&lt;/code&gt; は2で表され、引数/結果も1バイトで表されます。</target>
        </trans-unit>
        <trans-unit id="a66845ce6e93230866ff8e0772d20b4798a32003" translate="yes" xml:space="preserve">
          <source>Assuming that environment variables has been correctly set, a strings containing valid characters on the specific OS for environment variable names and values using &lt;code&gt;&lt;a href=&quot;file#native_name_encoding-0&quot;&gt;file:native_name_encoding()&lt;/a&gt;&lt;/code&gt; encoding. The first &lt;code&gt;$=&lt;/code&gt; characters appearing in the string separates environment variable name (on the left) from environment variable value (on the right).</source>
          <target state="translated">環境変数が正しく設定されていると仮定すると、 &lt;code&gt;&lt;a href=&quot;file#native_name_encoding-0&quot;&gt;file:native_name_encoding()&lt;/a&gt;&lt;/code&gt; エンコーディングを使用して、環境変数の名前と値に特定のOSで有効な文字を含む文字列。文字列に現れる最初の &lt;code&gt;$=&lt;/code&gt; 文字は、環境変数名（左側）と環境変数値（右側）を区切ります。</target>
        </trans-unit>
        <trans-unit id="0a6f58980048155b748b7c9405f322e65c5a9184" translate="yes" xml:space="preserve">
          <source>Assuming that the call to &lt;code&gt;&lt;a href=&quot;mnesia#start-0&quot;&gt;mnesia:start/0&lt;/a&gt;&lt;/code&gt; does not find any schema to read on the disc, &lt;code&gt;Mnesia&lt;/code&gt; starts as a disc-less node, and then change it to a node that use the disc to store the schema locally.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mnesia#start-0&quot;&gt;mnesia:start/0&lt;/a&gt;&lt;/code&gt; の呼び出しでディスク上に読み取るスキーマが見つからないと仮定すると、 &lt;code&gt;Mnesia&lt;/code&gt; はディスクなしのノードとして起動し、ディスクを使用してスキーマをローカルに保存するノードに変更します。</target>
        </trans-unit>
        <trans-unit id="d6872420cefd05df68dce4eed3bc63d15db4f598" translate="yes" xml:space="preserve">
          <source>Assuming that the node has been started as follows:</source>
          <target state="translated">以下のようにノードが起動したと仮定します。</target>
        </trans-unit>
        <trans-unit id="51630ab3cd71a8b020a5db0bc163d0f23a13638c" translate="yes" xml:space="preserve">
          <source>Assuming that the thread progress functionality is efficient, a lot of algorithms can both be simplified and made more efficient than using the first approach that comes to mind. A couple of examples follows.</source>
          <target state="translated">スレッドプログレス機能が効率的であると仮定すると、多くのアルゴリズムは単純化され、最初のアプローチを使用するよりも効率的になることができます。いくつかの例を以下に示します。</target>
        </trans-unit>
        <trans-unit id="8499608ce735317421447e4bbbb5e480084db254" translate="yes" xml:space="preserve">
          <source>Assuming that these requirements are fulfilled, time correction is enabled, and OS system time is adjusted using a time adjustment protocol such as NTP, only small adjustments of Erlang monotonic time are needed to keep system times aligned after finalization. As long as the system is not suspended, the largest adjustments needed are for inserted (or deleted) leap seconds.</source>
          <target state="translated">これらの要件が満たされ、時刻補正が有効になり、NTPのような時刻調整プロトコルを使ってOSシステムの時刻が調整されていると仮定すると、Erlangのモノトニックタイムを少し調整するだけで、確定後にシステムの時刻を合わせることができます。システムがサスペンドされていない限り、必要とされる最大の調整は閏秒の挿入(または削除)です。</target>
        </trans-unit>
        <trans-unit id="03367feb887591c7e80f18fd1145673d7dcffe3e" translate="yes" xml:space="preserve">
          <source>Assuming that these types are exported from module &lt;code&gt;'mod'&lt;/code&gt;, you can refer to them from other modules using remote type expressions like the following:</source>
          <target state="translated">これらの型がモジュール &lt;code&gt;'mod'&lt;/code&gt; からエクスポートされると仮定すると、次のようなリモート型式を使用して他のモジュールから参照できます。</target>
        </trans-unit>
        <trans-unit id="13fa45ba7f2afed612bcb3c59e68416368c08493" translate="yes" xml:space="preserve">
          <source>Assuming that we spawn fewer processes than the maximum amount of unique process identifiers in the system, one has always been able to determine the order of process creation just by comparing process identifiers. If PidX is larger than PidY, then PidX was created after PidY assuming both identifiers originates from the same node. However, since we have a quite limited amount of unique identifiers today (2^28), this property cannot be relied upon if we create large amount of processes. But never the less, this is a property the system always have had.</source>
          <target state="translated">システム内のユニークなプロセス識別子の最大量よりも少ない数のプロセスを生成すると仮定すると、プロセス識別子を比較するだけで常にプロセスの生成順序を決定することができます。もし PidX が PidY よりも大きければ、PidX は PidY の後に作成されたことになります。しかし、今日では一意な識別子の数が非常に限られているため (2^28)、大量のプロセスを作成する場合には、この性質は頼りになりません。しかし、これはシステムが常に持っていた性質です。</target>
        </trans-unit>
        <trans-unit id="26267ff052ff06ed2dce21d69453c5f440474929" translate="yes" xml:space="preserve">
          <source>Assuming that we want the employee numbers of everyone in the sales department, there are several ways.</source>
          <target state="translated">営業部門の全員の従業員数が欲しいと仮定すると、いくつかの方法があります。</target>
        </trans-unit>
        <trans-unit id="266f66badd0d0b518b2e5df463ab8847e52c02bb" translate="yes" xml:space="preserve">
          <source>Assuming the &lt;code&gt;.rel file&lt;/code&gt; is stored in a file &lt;code&gt;start_ssl.rel&lt;/code&gt; in the current directory, a boot script can be built as follows:</source>
          <target state="translated">&lt;code&gt;.rel file&lt;/code&gt; が現在のディレクトリのファイル &lt;code&gt;start_ssl.rel&lt;/code&gt; に格納されているとすると、ブートスクリプトは次のように構築できます。</target>
        </trans-unit>
        <trans-unit id="6fce84ccb66529fc8ed6e1c0f38776816b583ca0" translate="yes" xml:space="preserve">
          <source>Assuming the same &lt;code&gt;CLIENTDIR&lt;/code&gt; as above, the last line is to look like:</source>
          <target state="translated">上記と同じ &lt;code&gt;CLIENTDIR&lt;/code&gt; を想定すると、最後の行は次のようになります。</target>
        </trans-unit>
        <trans-unit id="3a0c79afff9d3483a1ae5e8cbc8205664dba4b83" translate="yes" xml:space="preserve">
          <source>Assuming there is an operational target system with installation root directory &lt;code&gt;$ROOT&lt;/code&gt;, the release package with the new version of the release is to be copied to &lt;code&gt;$ROOT/releases&lt;/code&gt;.</source>
          <target state="translated">インストールルートディレクトリが &lt;code&gt;$ROOT&lt;/code&gt; 操作可能なターゲットシステムがあると想定して、新しいバージョンのリリースを含むリリースパッケージを &lt;code&gt;$ROOT/releases&lt;/code&gt; コピーします。</target>
        </trans-unit>
        <trans-unit id="d7c30a0e4666f7264a0489fe55f811dceafac52d" translate="yes" xml:space="preserve">
          <source>Assuming these definitions:</source>
          <target state="translated">これらの定義を仮定して</target>
        </trans-unit>
        <trans-unit id="c8b26ebcc3e9bf5dbba85fc702138c186d9e4f8c" translate="yes" xml:space="preserve">
          <source>Assures that literals have a compact representation. This is occasionally useful if &lt;code&gt;c_cons_skel/2&lt;/code&gt;, &lt;code&gt;c_tuple_skel/1&lt;/code&gt; or &lt;code&gt;unfold_literal/1&lt;/code&gt; were used in the construction of &lt;code&gt;Node&lt;/code&gt;, and you want to revert to the normal &quot;folded&quot; representation of literals. If &lt;code&gt;Node&lt;/code&gt; represents a tuple or list constructor, its elements are rewritten recursively, and the node is reconstructed using &lt;code&gt;c_cons/2&lt;/code&gt; or &lt;code&gt;c_tuple/1&lt;/code&gt;, respectively; otherwise, &lt;code&gt;Node&lt;/code&gt; is not changed.</source>
          <target state="translated">リテラルがコンパクトに表現されていることを保証します。これは、 &lt;code&gt;c_cons_skel/2&lt;/code&gt; 、 &lt;code&gt;c_tuple_skel/1&lt;/code&gt; 、または &lt;code&gt;unfold_literal/1&lt;/code&gt; が &lt;code&gt;Node&lt;/code&gt; の構築に使用され、リテラルの通常の「折りたたまれた」表現に戻したい場合に役立つことがあります。 &lt;code&gt;Node&lt;/code&gt; がタプルまたはリストコンストラクターを表す場合、その要素は再帰的に書き換えられ、ノードはそれぞれ &lt;code&gt;c_cons/2&lt;/code&gt; または &lt;code&gt;c_tuple/1&lt;/code&gt; を使用して再構築されます。それ以外の場合、 &lt;code&gt;Node&lt;/code&gt; は変更されません。</target>
        </trans-unit>
        <trans-unit id="aaa99efafd6c95c8611da8fa8895116da74ab832" translate="yes" xml:space="preserve">
          <source>Assures that literals have a fully expanded representation. If &lt;code&gt;Node&lt;/code&gt; represents a literal tuple or list constructor, its elements are rewritten recursively, and the node is reconstructed using &lt;code&gt;c_cons_skel/2&lt;/code&gt; or &lt;code&gt;c_tuple_skel/1&lt;/code&gt;, respectively; otherwise, &lt;code&gt;Node&lt;/code&gt; is not changed. The &lt;code&gt;&lt;a href=&quot;#fold_literal-1&quot;&gt;fold_literal/1&lt;/a&gt;&lt;/code&gt; can be used to revert to the normal compact representation.</source>
          <target state="translated">リテラルが完全に拡張された表現を持つことを保証します。 &lt;code&gt;Node&lt;/code&gt; がリテラルタプルまたはリストコンストラクターを表す場合、その要素は再帰的に書き換えられ、ノードはそれぞれ &lt;code&gt;c_cons_skel/2&lt;/code&gt; または &lt;code&gt;c_tuple_skel/1&lt;/code&gt; を使用して再構築されます。それ以外の場合、 &lt;code&gt;Node&lt;/code&gt; は変更されません。 &lt;code&gt;&lt;a href=&quot;#fold_literal-1&quot;&gt;fold_literal/1&lt;/a&gt;&lt;/code&gt; は、通常コンパクトな表現に戻すために使用することができます。</target>
        </trans-unit>
        <trans-unit id="f4b10ac30756395c83923e7cf3c7d80acae92175" translate="yes" xml:space="preserve">
          <source>Async queue length is not defined for &lt;code&gt;put&lt;/code&gt; operations.</source>
          <target state="translated">非同期キューの長さは、のために定義されていない &lt;code&gt;put&lt;/code&gt; 操作。</target>
        </trans-unit>
        <trans-unit id="3988dd15a01716f5457aa8c6239f3feeb9605755" translate="yes" xml:space="preserve">
          <source>Async threads are used by various linked-in drivers (mainly the file drivers) do offload non-CPU intensive work. See &lt;code&gt;erl +A&lt;/code&gt; for more details.</source>
          <target state="translated">非同期スレッドは、さまざまなリンクされたドライバー（主にファイルドライバー）によって使用され、CPUを使用しない集中的な作業をオフロードします。詳細については、 &lt;code&gt;erl +A&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="1f2ff86b0c85c68964cf97af02073f12b82e6dee" translate="yes" xml:space="preserve">
          <source>Asynchronous &lt;code&gt;get-bulk-request&lt;/code&gt; (See RFC1905).</source>
          <target state="translated">非同期の &lt;code&gt;get-bulk-request&lt;/code&gt; （RFC1905を参照）。</target>
        </trans-unit>
        <trans-unit id="3284d2626e5dc0e20ecd8465f9256541f56870e5" translate="yes" xml:space="preserve">
          <source>Asynchronous &lt;code&gt;get-next-request&lt;/code&gt;.</source>
          <target state="translated">非同期の &lt;code&gt;get-next-request&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ce12675017eba1aad96dc4af8158e8ade8a6e141" translate="yes" xml:space="preserve">
          <source>Asynchronous &lt;code&gt;get-request&lt;/code&gt;.</source>
          <target state="translated">非同期の &lt;code&gt;get-request&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="07690d2c187b7cfafc60389b63d0ee62b7cd3c1c" translate="yes" xml:space="preserve">
          <source>Asynchronous &lt;code&gt;set-request&lt;/code&gt;.</source>
          <target state="translated">非同期 &lt;code&gt;set-request&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5c7ffbaa8ef4ef8420694da665321a4afef34039" translate="yes" xml:space="preserve">
          <source>Asynchronous calls</source>
          <target state="translated">非同期呼び出し</target>
        </trans-unit>
        <trans-unit id="9c4f45c7554c3415b2762a3d8f5669acc6525702" translate="yes" xml:space="preserve">
          <source>Asynchronous request cleanup time. For every requests, some info is stored internally, in order to be able to deliver the reply (when it arrives) to the proper destination. If the reply arrives, this info will be deleted. But if there is no reply (in time), the info has to be deleted after the &lt;strong&gt;best before&lt;/strong&gt; time has been passed. This cleanup will be performed at regular intervals, defined by the &lt;code&gt;server_timeout()&lt;/code&gt; time. The information will have a &lt;strong&gt;best before&lt;/strong&gt; time, defined by the &lt;code&gt;Expire&lt;/code&gt; time given when calling the request function (see &lt;code&gt;&lt;a href=&quot;snmpm#async_get&quot;&gt;async_get&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;snmpm#async_get_next&quot;&gt;async_get_next&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;snmpm#async_set&quot;&gt;async_set&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">非同期リクエストのクリーンアップ時間。リクエストごとに、返信が（到着時に）適切な宛先に配信できるように、一部の情報が内部に保存されます。返信が届いた場合、この情報は削除されます。 （時間的に）返信がない場合でも、情報が後に削除する必要があります&lt;strong&gt;前に、最高の&lt;/strong&gt;時間が経過しました。このクリーンアップは、 &lt;code&gt;server_timeout()&lt;/code&gt; 時間で定義された定期的な間隔で実行されます。情報があります&lt;strong&gt;前に、最高の&lt;/strong&gt;時間によって定義された &lt;code&gt;Expire&lt;/code&gt; （参照要求機能を呼び出すときに与えられた時間 &lt;code&gt;&lt;a href=&quot;snmpm#async_get&quot;&gt;async_get&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;snmpm#async_get_next&quot;&gt;async_get_next&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;snmpm#async_set&quot;&gt;async_set&lt;/a&gt;&lt;/code&gt; を）。</target>
        </trans-unit>
        <trans-unit id="56364b7086d1002ef3358c7012d8995780475b16" translate="yes" xml:space="preserve">
          <source>Asynchronous request cleanup time. For every requests, some info is stored internally, in order to be able to deliver the reply (when it arrives) to the proper destination. If the reply arrives, this info will be deleted. But if there is no reply (in time), the info has to be deleted after the &lt;strong&gt;best before&lt;/strong&gt; time has been passed. This cleanup will be performed at regular intervals, defined by the &lt;code&gt;server_timeout()&lt;/code&gt; time. The information will have a &lt;strong&gt;best before&lt;/strong&gt; time, defined by the &lt;code&gt;Expire&lt;/code&gt; time given when calling the request function (see &lt;code&gt;&lt;a href=&quot;snmpm#async_get2&quot;&gt;async_get&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;snmpm#async_get_next2&quot;&gt;async_get_next&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;snmpm#async_set2&quot;&gt;async_set&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">非同期リクエストのクリーンアップ時間。リクエストごとに、適切な宛先に（到着したときに）応答を配信できるようにするために、一部の情報が内部に保存されます。返信が届くと、この情報は削除されます。しかし、（時間内に）返信がない場合は、時間が経過する&lt;strong&gt;前&lt;/strong&gt;に、情報を削除する必要があります。このクリーンアップは、 &lt;code&gt;server_timeout()&lt;/code&gt; 時間で定義された定期的な間隔で実行されます。情報には、リクエスト関数を呼び出すときに指定された &lt;code&gt;Expire&lt;/code&gt; によって定義される&lt;strong&gt;ベスト&lt;/strong&gt; &lt;code&gt;&lt;a href=&quot;snmpm#async_get2&quot;&gt;async_get&lt;/a&gt;&lt;/code&gt; ます（async_get、 &lt;code&gt;&lt;a href=&quot;snmpm#async_get_next2&quot;&gt;async_get_next&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;snmpm#async_set2&quot;&gt;async_set&lt;/a&gt;&lt;/code&gt; を参照）。</target>
        </trans-unit>
        <trans-unit id="8f4ef40b42e8c28e77390dcc6fa14ba97907a734" translate="yes" xml:space="preserve">
          <source>Asynchronous request for cancellation. &lt;code&gt;Async&lt;/code&gt; defaults to &lt;code&gt;false&lt;/code&gt;, which causes the cancellation to be performed synchronously. When &lt;code&gt;Async&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, the cancel operation is performed asynchronously. That is, &lt;code&gt;cancel_timer()&lt;/code&gt; sends an asynchronous request for cancellation to the timer service that manages the timer, and then returns &lt;code&gt;ok&lt;/code&gt;.</source>
          <target state="translated">キャンセルの非同期リクエスト。 &lt;code&gt;Async&lt;/code&gt; のデフォルトは &lt;code&gt;false&lt;/code&gt; で、キャンセルは同期的に実行されます。ときに &lt;code&gt;Async&lt;/code&gt; に設定されている &lt;code&gt;true&lt;/code&gt; 、キャンセル操作を非同期で実行されます。つまり、 &lt;code&gt;cancel_timer()&lt;/code&gt; は、タイマーを管理するタイマーサービスにキャンセルの非同期リクエストを送信してから、 &lt;code&gt;ok&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="95fd03b1444c479be3c52aee359cb2dfca32c856" translate="yes" xml:space="preserve">
          <source>Asynchronous request for state information. &lt;code&gt;Async&lt;/code&gt; defaults to &lt;code&gt;false&lt;/code&gt;, which causes the operation to be performed synchronously. In this case, the &lt;code&gt;Result&lt;/code&gt; is returned by &lt;code&gt;erlang:read_timer&lt;/code&gt;. When &lt;code&gt;Async&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;erlang:read_timer&lt;/code&gt; sends an asynchronous request for the state information to the timer service that manages the timer, and then returns &lt;code&gt;ok&lt;/code&gt;. A message on the format &lt;code&gt;{read_timer, TimerRef, Result}&lt;/code&gt; is sent to the caller of &lt;code&gt;erlang:read_timer&lt;/code&gt; when the operation has been processed.</source>
          <target state="translated">状態情報の非同期リクエスト。 &lt;code&gt;Async&lt;/code&gt; のデフォルトは &lt;code&gt;false&lt;/code&gt; で、操作が同期的に実行されます。この場合、 &lt;code&gt;Result&lt;/code&gt; は &lt;code&gt;erlang:read_timer&lt;/code&gt; によって返されます。ときに &lt;code&gt;Async&lt;/code&gt; ある &lt;code&gt;true&lt;/code&gt; 、 &lt;code&gt;erlang:read_timer&lt;/code&gt; タイマーを管理タイマーサービスに状態情報の非同期要求を送信し、次に返し &lt;code&gt;ok&lt;/code&gt; 。操作が処理されると &lt;code&gt;{read_timer, TimerRef, Result}&lt;/code&gt; 形式のメッセージが &lt;code&gt;erlang:read_timer&lt;/code&gt; の呼び出し元に送信されます。</target>
        </trans-unit>
        <trans-unit id="6ca776a5d287d8b2a7dc6071e248dbb73c2d391b" translate="yes" xml:space="preserve">
          <source>Asynchronously append a list of items to a disk log. &lt;code&gt;alog_terms/2&lt;/code&gt; is used for internally formatted logs and &lt;code&gt;balog_terms/2&lt;/code&gt; for externally formatted logs. &lt;code&gt;balog_terms/2&lt;/code&gt; can also be used for internally formatted logs if the binaries are constructed with calls to &lt;code&gt;term_to_binary/1&lt;/code&gt;.</source>
          <target state="translated">アイテムのリストをディスクログに非同期的に追加します。 &lt;code&gt;alog_terms/2&lt;/code&gt; は内部的にフォーマットされたログに使用され、 &lt;code&gt;balog_terms/2&lt;/code&gt; は外部的にフォーマットされたログに使用されます。バイナリが &lt;code&gt;term_to_binary/1&lt;/code&gt; への呼び出しで構築される場合、 &lt;code&gt;balog_terms/2&lt;/code&gt; は内部的にフォーマットされたログにも使用できます。</target>
        </trans-unit>
        <trans-unit id="cb5375e7ef1ea5eaaf79230eafedb013e5c6183e" translate="yes" xml:space="preserve">
          <source>Asynchronously append an item to a disk log. &lt;code&gt;alog/2&lt;/code&gt; is used for internally formatted logs and &lt;code&gt;balog/2&lt;/code&gt; for externally formatted logs. &lt;code&gt;balog/2&lt;/code&gt; can also be used for internally formatted logs if the binary is constructed with a call to &lt;code&gt;term_to_binary/1&lt;/code&gt;.</source>
          <target state="translated">非同期でアイテムをディスクログに追加します。 &lt;code&gt;alog/2&lt;/code&gt; は内部的にフォーマットされたログに使用され、 &lt;code&gt;balog/2&lt;/code&gt; は外部的にフォーマットされたログに使用されます。 &lt;code&gt;balog/2&lt;/code&gt; は、バイナリが &lt;code&gt;term_to_binary/1&lt;/code&gt; への呼び出しで構築されている場合、内部的にフォーマットされたログにも使用できます。</target>
        </trans-unit>
        <trans-unit id="073b543723ae65bc813de7052a4d54e6f69f1707" translate="yes" xml:space="preserve">
          <source>Asynchronously send a spawn request. Returns a request identifier &lt;code&gt;ReqId&lt;/code&gt;.</source>
          <target state="translated">スポーンリクエストを非同期に送信します。リクエスト識別子 &lt;code&gt;ReqId&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="d4919029fc256c29ef79f5f904616a2c8e94c3f2" translate="yes" xml:space="preserve">
          <source>At &quot;top-level&quot;, all these recursion test conditions are false. The syntax for recursive patterns is described below.</source>
          <target state="translated">トップレベル」では、これらの再帰テスト条件はすべて偽です。再帰パターンの構文は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="f43d3dd154d77c634c392d671f75757f296a087e" translate="yes" xml:space="preserve">
          <source>At &lt;code&gt;success()&lt;/code&gt;, the &lt;code&gt;UserReply&lt;/code&gt; contains a list of 'ActionReply' records possibly containing error indications.</source>
          <target state="translated">で &lt;code&gt;success()&lt;/code&gt; 、 &lt;code&gt;UserReply&lt;/code&gt; はおそらくエラー表示を含む「ActionReply」レコードのリストが含まれています。</target>
        </trans-unit>
        <trans-unit id="3d45243ad2c3b8770cad6640db0cb04483b46411" translate="yes" xml:space="preserve">
          <source>At &lt;code&gt;success()&lt;/code&gt;, the &lt;code&gt;UserReply&lt;/code&gt; either contains:</source>
          <target state="translated">で &lt;code&gt;success()&lt;/code&gt; 、 &lt;code&gt;UserReply&lt;/code&gt; はどちらか含まれています。</target>
        </trans-unit>
        <trans-unit id="a23e179a407d51751e1caa4f70ab6a111682bb8b" translate="yes" xml:space="preserve">
          <source>At any time, the current Erlang Top display can be dumped to a text file with function &lt;code&gt;&lt;a href=&quot;etop#dump-1&quot;&gt;etop:dump/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">いつでも、現在のErlang Top表示は、関数 &lt;code&gt;&lt;a href=&quot;etop#dump-1&quot;&gt;etop:dump/1&lt;/a&gt;&lt;/code&gt; を使用してテキストファイルにダンプできます。</target>
        </trans-unit>
        <trans-unit id="4f1d3d95e4cd84ec49bb6d5fe0b90a58ea62ba48" translate="yes" xml:space="preserve">
          <source>At any time, to get the current status of the test nodes, call function &lt;code&gt;&lt;a href=&quot;ct_master#progress-0&quot;&gt;ct_master:progress()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">いつでも、テストノードの現在のステータスを取得するには、関数 &lt;code&gt;&lt;a href=&quot;ct_master#progress-0&quot;&gt;ct_master:progress()&lt;/a&gt;&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="654554d0e9934eea080ddb2f39b539e93c3b2e5f" translate="yes" xml:space="preserve">
          <source>At carrier deallocation, we want to coalesce with any adjacent free segments, to form one large free segment. To do that, all free segments are also organized in a tree sorted in address order (&lt;code&gt;atree&lt;/code&gt;).</source>
          <target state="translated">キャリアの割り当て解除では、隣接するフリーセグメントと合体して、1つの大きなフリーセグメントを形成します。これを行うために、すべての空きセグメントもアドレス順にソートされたツリー（ &lt;code&gt;atree&lt;/code&gt; ）に編成されます。</target>
        </trans-unit>
        <trans-unit id="bd91a4b48e4394db081304cf8a7e752960166fb5" translate="yes" xml:space="preserve">
          <source>At each iteration of the subpattern, the back reference matches the character string corresponding to the previous iteration. In order for this to work, the pattern must be such that the first iteration does not need to match the back reference. This can be done using alternation, as in the example above, or by a quantifier with a minimum of zero.</source>
          <target state="translated">サブパターンの各反復では、バックリファレンスは前の反復に対応する文字列と一致します。これが機能するためには、パターンは、最初の反復が後方参照と一致する必要がないようなものでなければなりません。これは、上の例のように交互変換を使ったり、最小のゼロを持つ量詞を使ったりして行うことができます。</target>
        </trans-unit>
        <trans-unit id="b373a9f8122a8a2b8c68bd7132b1ca7c2848e49f" translate="yes" xml:space="preserve">
          <source>At each record access, &lt;code&gt;mnesia_frag&lt;/code&gt; first computes a hash value from the record key. Second, the name of the table fragment is determined from the hash value. Finally the actual table access is performed by the same functions as for non-fragmented tables. When the key is not known beforehand, all fragments are searched for matching records.</source>
          <target state="translated">各レコードアクセスで、 &lt;code&gt;mnesia_frag&lt;/code&gt; は最初にレコードキーからハッシュ値を計算します。次に、テーブルフラグメントの名前がハッシュ値から決定されます。最後に、実際のテーブルアクセスは、断片化されていないテーブルと同じ関数によって実行されます。キーが事前にわからない場合は、すべてのフラグメントで一致するレコードが検索されます。</target>
        </trans-unit>
        <trans-unit id="4fa74bb3403235c6895e68dc73b513ddac9e1482" translate="yes" xml:space="preserve">
          <source>At least one host key must be defined. The default value of SYSDIR is &lt;code id=&quot;#/etc/ssh&quot;&gt;/etc/ssh&lt;/code&gt;.</source>
          <target state="translated">少なくとも1つのホストキーを定義する必要があります。SYSDIRのデフォルト値は &lt;code id=&quot;#/etc/ssh&quot;&gt;/etc/ssh&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="e791bb91b86137f009adcbd36f18e163d6c841d5" translate="yes" xml:space="preserve">
          <source>At least one other identifier type besides &lt;code&gt;&amp;lt;LogicalIds&amp;gt;&lt;/code&gt; must also have a list of identifiers.</source>
          <target state="translated">&lt;code&gt;&amp;lt;LogicalIds&amp;gt;&lt;/code&gt; 以外の少なくとも1つの他の識別子タイプにも識別子のリストが必要です。</target>
        </trans-unit>
        <trans-unit id="f6e34fe0dc564614befa189e8748c8b5b71f49e4" translate="yes" xml:space="preserve">
          <source>At present only the default module is provided with the agent, &lt;code&gt;snmpa_mib_data_tttn&lt;/code&gt;.</source>
          <target state="translated">現在、デフォルトのモジュールのみがエージェント &lt;code&gt;snmpa_mib_data_tttn&lt;/code&gt; で提供されています。</target>
        </trans-unit>
        <trans-unit id="52b6928d79b0ae8a32944a5857ee7a65e4d13aa4" translate="yes" xml:space="preserve">
          <source>At start-up, a node has a random atom assigned as its magic cookie and the cookie of other nodes is assumed to be &lt;code&gt;nocookie&lt;/code&gt;. The first action of the Erlang network authentication server (&lt;code&gt;auth&lt;/code&gt;) is then to read a file named &lt;code&gt;$HOME/.erlang.cookie&lt;/code&gt;. If the file does not exist, it is created. The UNIX permissions mode of the file is set to octal 400 (read-only by user) and its contents are a random string. An atom &lt;code&gt;Cookie&lt;/code&gt; is created from the contents of the file and the cookie of the local node is set to this using &lt;code&gt;erlang:set_cookie(node(), Cookie)&lt;/code&gt;. This also makes the local node assume that all other nodes have the same cookie &lt;code&gt;Cookie&lt;/code&gt;.</source>
          <target state="translated">起動時、ノードにはランダムなアトムがその魔法のcookieとして割り当てられ、他のノードのcookieは &lt;code&gt;nocookie&lt;/code&gt; であると想定されます。 Erlangネットワーク認証サーバー（ &lt;code&gt;auth&lt;/code&gt; ）の最初のアクションは、 &lt;code&gt;$HOME/.erlang.cookie&lt;/code&gt; という名前のファイルを読み取ることです。ファイルが存在しない場合は作成されます。ファイルのUNIX許可モードは8進数の400（ユーザーによる読み取り専用）に設定されており、その内容はランダムな文字列です。アトム &lt;code&gt;Cookie&lt;/code&gt; はファイルのコンテンツから作成され、ローカルノードのCookieは &lt;code&gt;erlang:set_cookie(node(), Cookie)&lt;/code&gt; を使用してこれに設定されます。これにより、ローカルノードは他のすべてのノードが同じCookie &lt;code&gt;Cookie&lt;/code&gt; を持っていると想定します。</target>
        </trans-unit>
        <trans-unit id="518744e98c40235fc6bb7d9cc4f9e7b8cd708382" translate="yes" xml:space="preserve">
          <source>At startup, &lt;code&gt;Mnesia&lt;/code&gt; assumes that its local replica is the most recent version and loads the table from disc if either of the following situations is detected:</source>
          <target state="translated">起動時に、 &lt;code&gt;Mnesia&lt;/code&gt; はローカルレプリカが最新バージョンであると想定し、次のいずれかの状況が検出された場合にディスクからテーブルをロードします。</target>
        </trans-unit>
        <trans-unit id="e5838a6fe5958edaad5f512813e7c830bd8af3cc" translate="yes" xml:space="preserve">
          <source>At startup, &lt;code&gt;Mnesia&lt;/code&gt; connects different nodes to each other, then they exchange table definitions with each other, and the table definitions are merged. During the merge procedure, &lt;code&gt;Mnesia&lt;/code&gt; performs a sanity test to ensure that the table definitions are compatible with each other. If a table exists on several nodes, the cookie must be the same, otherwise &lt;code&gt;Mnesia&lt;/code&gt; shut down one of the nodes. This unfortunate situation occurs if a table has been created on two nodes independently of each other while they were disconnected. To solve this, one of the tables must be deleted (as the cookies differ, it is regarded to be two different tables even if they have the same name).</source>
          <target state="translated">起動時に、 &lt;code&gt;Mnesia&lt;/code&gt; は異なるノードを相互に接続し、それらが相互にテーブル定義を交換し、テーブル定義がマージされます。マージ手順中に、 &lt;code&gt;Mnesia&lt;/code&gt; は健全性テストを実行して、テーブル定義が互いに互換性があることを確認します。テーブルが複数のノードに存在する場合、Cookieは同じでなければなりません。それ以外の場合、 &lt;code&gt;Mnesia&lt;/code&gt; はノードの1つをシャットダウンしました。この不幸な状況は、テーブルが切断されている間に2つのノードに互いに独立してテーブルが作成された場合に発生します。これを解決するには、テーブルの1つを削除する必要があります（Cookieが異なるため、同じ名前であっても2つの異なるテーブルと見なされます）。</target>
        </trans-unit>
        <trans-unit id="a627688b56cf27035c1a223f76b7c1a970186939" translate="yes" xml:space="preserve">
          <source>At startup, &lt;code&gt;Mnesia&lt;/code&gt; loads tables to make them accessible for its applications. Sometimes &lt;code&gt;Mnesia&lt;/code&gt; decides to load all tables that reside locally, and sometimes the tables are not accessible until &lt;code&gt;Mnesia&lt;/code&gt; brings a copy of the table from another node.</source>
          <target state="translated">起動時に、 &lt;code&gt;Mnesia&lt;/code&gt; はテーブルをロードして、アプリケーションからアクセスできるようにします。時には &lt;code&gt;Mnesia&lt;/code&gt; は、ローカルに存在するすべてのテーブルをロードすることを決定、およびまで時々テーブルにはアクセスできません &lt;code&gt;Mnesia&lt;/code&gt; は、他のノードからのテーブルのコピーをもたらします。</target>
        </trans-unit>
        <trans-unit id="d42e266b7e766640fca49bd15e785ddd09a12678" translate="yes" xml:space="preserve">
          <source>At startup, Mnesia always loads &lt;code&gt;read_only&lt;/code&gt; table locally regardless of when and if Mnesia is terminated on other nodes. This argument returns the access mode of the table. The access mode can be &lt;code&gt;read_only&lt;/code&gt; or &lt;code&gt;read_write&lt;/code&gt;.</source>
          <target state="translated">Mnesiaは、起動時に、Mnesiaが他のノードでいつ終了したかとは無関係に、常に &lt;code&gt;read_only&lt;/code&gt; テーブルをローカルにロードします。この引数は、テーブルのアクセスモードを返します。アクセスモードは &lt;code&gt;read_only&lt;/code&gt; または &lt;code&gt;read_write&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="cd3b6f4ef0dfb0e46121f11afdceab8754106c9b" translate="yes" xml:space="preserve">
          <source>At startup, notice that all tables residing on nodes without a &lt;code&gt;mnesia_down&lt;/code&gt; entry can have fresher replicas. Their replicas can have been updated after the termination of &lt;code&gt;Mnesia&lt;/code&gt; on the current node. To catch up with the latest updates, transfer a copy of the table from one of these other &quot;fresh&quot; nodes. If you are unlucky, other nodes can be down and you must wait for the table to be loaded on one of these nodes before receiving a fresh copy of the table.</source>
          <target state="translated">起動時に、 &lt;code&gt;mnesia_down&lt;/code&gt; エントリのないノードに存在するすべてのテーブルは、より新しいレプリカを持つことができます。それらのレプリカは、現在のノードで &lt;code&gt;Mnesia&lt;/code&gt; の終了後に更新されている可能性があります。最新の更新に追いつくには、これらの他の「新しい」ノードの1つからテーブルのコピーを転送します。運が悪い場合、他のノードがダウンしている可能性があり、テーブルの新しいコピーを受信する前に、これらのノードのいずれかにテーブルがロードされるのを待つ必要があります。</target>
        </trans-unit>
        <trans-unit id="cebd2da32e4452b268c6c9625fdcaae6da724209" translate="yes" xml:space="preserve">
          <source>At startup, the &lt;code&gt;Mnesia&lt;/code&gt; normal table load algorithm is bypassed and the table is loaded from one of the master nodes defined for the table, regardless of potential &lt;code&gt;mnesia_down&lt;/code&gt; entries in the log. &lt;code&gt;Nodes&lt;/code&gt; can only contain nodes where the table has a replica. If &lt;code&gt;Nodes&lt;/code&gt; is empty, the master node recovery mechanism for the particular table is reset and the normal load mechanism is used at the next restart.</source>
          <target state="translated">起動時に、 &lt;code&gt;Mnesia&lt;/code&gt; の通常のテーブルロードアルゴリズムはバイパスされ、テーブルは、ログの潜在的な &lt;code&gt;mnesia_down&lt;/code&gt; エントリに関係なく、テーブルに定義されたマスターノードの1つからロードされます。 &lt;code&gt;Nodes&lt;/code&gt; 含めることができるのは、テーブルにレプリカがあるノードのみです。 &lt;code&gt;Nodes&lt;/code&gt; が空の場合、特定のテーブルのマスターノード回復メカニズムがリセットされ、次の再起動時に通常のロードメカニズムが使用されます。</target>
        </trans-unit>
        <trans-unit id="a6322370642204a58e29b000b086020c58026493" translate="yes" xml:space="preserve">
          <source>At system start, Logger is configured through Kernel configuration parameters. The parameters that apply to Logger are described in section &lt;code&gt;&lt;a href=&quot;#kernel_config_params&quot;&gt;Kernel Configuration Parameters&lt;/a&gt;&lt;/code&gt;. Examples are found in section &lt;code&gt;&lt;a href=&quot;#config_examples&quot;&gt;Configuration Examples&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">システムの起動時に、ロガーはカーネル構成パラメーターを介して構成されます。ロガーに適用されるパラメーターについては、セクション「 &lt;code&gt;&lt;a href=&quot;#kernel_config_params&quot;&gt;Kernel Configuration Parameters&lt;/a&gt;&lt;/code&gt; 説明しています。例は、セクション「 &lt;code&gt;&lt;a href=&quot;#config_examples&quot;&gt;Configuration Examples&lt;/a&gt;&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="74d12c0011c249bb23aab720fbf3331a64e7f920" translate="yes" xml:space="preserve">
          <source>At the Media Gateway Controller (MGC) side it is possible to reject a connection request (and send a message error reply to the gateway) by returning &lt;code&gt;{error, ErrorDescr}&lt;/code&gt; or simply &lt;code&gt;error&lt;/code&gt; which generates an error descriptor with code 402 (unauthorized) and reason &quot;Connection refused by user&quot; (this is also the case for all unknown results, such as exit signals or throw).</source>
          <target state="translated">メディアゲートウェイコントローラー（MGC）側では &lt;code&gt;{error, ErrorDescr}&lt;/code&gt; またはコード402（無許可）のエラー記述子を生成する単純な &lt;code&gt;error&lt;/code&gt; を返すことで、接続要求を拒否（およびメッセージエラー応答をゲートウェイに送信）できます。理由「ユーザーによって接続が拒否されました」（これは、終了シグナルやスローなど、不明なすべての結果にも当てはまります）。</target>
        </trans-unit>
        <trans-unit id="082190436d06dd5d49208af168f795454a1d2c3e" translate="yes" xml:space="preserve">
          <source>At the end of a match, the values of capturing parentheses are those from the outermost level. If the pattern above is matched against</source>
          <target state="translated">マッチの最後には、捕獲括弧の値が最外段からの値となります。上記のパターンが</target>
        </trans-unit>
        <trans-unit id="a0bd3386c01848e616038cd3be0a42aca1ff92e4" translate="yes" xml:space="preserve">
          <source>At the end of phase one, the user defined &lt;code&gt;is_set_ok&lt;/code&gt; functions are called for each scalar variable, and for each group of table operations.</source>
          <target state="translated">フェーズ1の最後に、ユーザー定義の &lt;code&gt;is_set_ok&lt;/code&gt; 関数が、スカラー変数ごと、およびテーブル操作のグループごとに呼び出されます。</target>
        </trans-unit>
        <trans-unit id="e7141009a47e03284bdfb55bb6f57dbdb2f6af74" translate="yes" xml:space="preserve">
          <source>At the end of the file the following call is made to indicate the end of the transfer:</source>
          <target state="translated">ファイルの最後には、転送の終了を示すために次のような呼び出しが行われます。</target>
        </trans-unit>
        <trans-unit id="8f5e152a75003f4c0eecbf24783ff86692b5ac63" translate="yes" xml:space="preserve">
          <source>At the moment this is always an empty list as policies are not currently supported.</source>
          <target state="translated">現在のところ、ポリシーはサポートされていないため、これは常に空のリストになっています。</target>
        </trans-unit>
        <trans-unit id="ffb7455412e52bcc56b05d38e6e5253be2bc9d2d" translate="yes" xml:space="preserve">
          <source>At the other end, a server is listening on port 5678, accepts the connection, and receives the binary:</source>
          <target state="translated">もう一方の端では、サーバがポート5678で待機し、接続を受け入れ、バイナリを受信しています。</target>
        </trans-unit>
        <trans-unit id="6f9ff8879a1b69159c6bc968e733a435a351ea07" translate="yes" xml:space="preserve">
          <source>At the time of writing this document, in October 2020, there are two major standards concerning Universal Resource Identifiers and Universal Resource Locators:</source>
          <target state="translated">この文書の執筆時点では、2020年10月には、ユニバーサルリソース識別子とユニバーサルリソースロケータに関する2つの主要な基準があります。</target>
        </trans-unit>
        <trans-unit id="a2ee7dea7134049488781051edab25bd2f008623" translate="yes" xml:space="preserve">
          <source>At the top level, the first character is matched, but as it is not at the end of the string, the first alternative fails, the second alternative is taken, and the recursion kicks in. The recursive call to subpattern 1 successfully matches the next character (&quot;b&quot;). (Notice that the beginning and end of line tests are not part of the recursion.)</source>
          <target state="translated">トップレベルでは、最初の文字はマッチしますが、それは文字列の最後にないので、最初の代替案は失敗し、2番目の代替案が取られ、再帰が開始されます。サブパターン 1 への再帰呼び出しは、次の文字 (&quot;b&quot;)との一致に成功しています。(行頭と行末のテストは再帰の一部ではないことに注意してください)。</target>
        </trans-unit>
        <trans-unit id="ed2220b4de1fb3635d6a43309a72686050501dc1" translate="yes" xml:space="preserve">
          <source>At this point it would make sense to create a &lt;code&gt;&lt;a href=&quot;#sub_binary&quot;&gt;sub binary&lt;/a&gt;&lt;/code&gt;, but in this particular example the compiler sees that there will soon be a call to a function (in this case, to &lt;code&gt;my_binary_to_list/1&lt;/code&gt; itself) that immediately will create a new match context and discard the sub binary.</source>
          <target state="translated">この時点で &lt;code&gt;&lt;a href=&quot;#sub_binary&quot;&gt;sub binary&lt;/a&gt;&lt;/code&gt; を作成することは理にかなっていますが、この特定の例では、コンパイラはすぐに新しいマッチコンテキストを作成する関数（この場合は &lt;code&gt;my_binary_to_list/1&lt;/code&gt; 自体）の呼び出しがあることを認識していますそして、サブバイナリを破棄します。</target>
        </trans-unit>
        <trans-unit id="053fad4995ec80f53388ef89516e030604b7c2c8" translate="yes" xml:space="preserve">
          <source>At this point the client has stored the received session tickets and ready to use them when establishing new connections to the same server.</source>
          <target state="translated">この時点でクライアントは受信したセッションチケットを保存し、同じサーバーへの新しい接続を確立する際に使用する準備ができています。</target>
        </trans-unit>
        <trans-unit id="2a5d6ede3e3967bfd759ea91b6f59bd9213c0242" translate="yes" xml:space="preserve">
          <source>At this stage when we have a couple of &lt;code&gt;Events&lt;/code&gt;, it is time to show how it looks like in the graphical interface of &lt;code&gt;et_viewer&lt;/code&gt;:</source>
          <target state="translated">いくつかの &lt;code&gt;Events&lt;/code&gt; があるこの段階で、 &lt;code&gt;et_viewer&lt;/code&gt; のグラフィカルインターフェースでどのように見えるかを示します。</target>
        </trans-unit>
        <trans-unit id="41dded417052424bdcf3c39f6c8664147fae6806" translate="yes" xml:space="preserve">
          <source>Atom</source>
          <target state="translated">Atom</target>
        </trans-unit>
        <trans-unit id="c3c309f16bf4b6076b8eb93fd32be986ed93ed91" translate="yes" xml:space="preserve">
          <source>Atom ::= - same as Erlang atoms -</source>
          <target state="translated">Atom ::=-Erlangの原子と同じです。</target>
        </trans-unit>
        <trans-unit id="51343a15868219ae0470e742ba631bc7eec26597" translate="yes" xml:space="preserve">
          <source>Atom is another data type in Erlang. Atoms start with a small letter (see &lt;code&gt;Atom&lt;/code&gt;), for example, &lt;code&gt;charles&lt;/code&gt;, &lt;code&gt;centimeter&lt;/code&gt;, and &lt;code&gt;inch&lt;/code&gt;. Atoms are simply names, nothing else. They are not like variables, which can have a value.</source>
          <target state="translated">AtomはErlangのもう1つのデータ型です。原子は、 &lt;code&gt;charles&lt;/code&gt; 、 &lt;code&gt;centimeter&lt;/code&gt; 、 &lt;code&gt;inch&lt;/code&gt; などの小さな文字（ &lt;code&gt;Atom&lt;/code&gt; を参照）で始まります。原子は単に名前であり、他には何もありません。それらは値を持つことができる変数のようなものではありません。</target>
        </trans-unit>
        <trans-unit id="7195f879141a5a8ba030248689c692d5148b0ee2" translate="yes" xml:space="preserve">
          <source>AtomConst ::= Application | Module | Release</source>
          <target state="translated">AtomConst ::=アプリケーション|モジュール|リリース</target>
        </trans-unit>
        <trans-unit id="b2ee6dcaa3e3bc365b8aefab9465e716d6296685" translate="yes" xml:space="preserve">
          <source>Atomic Functions</source>
          <target state="translated">原子関数</target>
        </trans-unit>
        <trans-unit id="1c66839560fb43e9f121274907f35e59ef182189" translate="yes" xml:space="preserve">
          <source>Atomic Memory Operations and the VM</source>
          <target state="translated">アトミックメモリ操作とVM</target>
        </trans-unit>
        <trans-unit id="23f3697ab5a23225ef71292b3984b7a0da58971b" translate="yes" xml:space="preserve">
          <source>Atomic addition and return of the result.</source>
          <target state="translated">原子の足し算と結果の戻り値。</target>
        </trans-unit>
        <trans-unit id="285aeb96eeef706de92b804eae05d172e8e0a60b" translate="yes" xml:space="preserve">
          <source>Atomic grouping subpatterns are not capturing subpatterns. Simple cases such as the above example can be thought of as a maximizing repeat that must swallow everything it can. So, while both \d+ and \d+? are prepared to adjust the number of digits they match to make the remaining pattern match, &lt;code&gt;(?&amp;gt;\d+)&lt;/code&gt; can only match an entire sequence of digits.</source>
          <target state="translated">原子グループ化サブパターンはサブパターンをキャプチャしていません。上記の例のような単純なケースは、可能な限りすべてを飲み込む必要のある最大の繰り返しと考えることができます。したがって、\ d +と\ d +の両方が？一致する桁数を調整して残りのパターンを一致させるように準備されてい &lt;code&gt;(?&amp;gt;\d+)&lt;/code&gt; は、数字のシーケンス全体とのみ一致できます。</target>
        </trans-unit>
        <trans-unit id="70263cc27057f40aecb08445d5e4246aa30c686a" translate="yes" xml:space="preserve">
          <source>Atomic groups in general can contain any complicated subpatterns, and can be nested. However, when the subpattern for an atomic group is just a single repeated item, as in the example above, a simpler notation, called a &quot;possessive quantifier&quot; can be used. This consists of an extra + character following a quantifier. Using this notation, the previous example can be rewritten as</source>
          <target state="translated">一般に、原子群は複雑なサブパターンを含むことができ、入れ子にすることができます。しかし、上の例のように、原子群のサブパターンが単なる単一の繰り返し項目である場合には、&quot;所有的量詞 &quot;と呼ばれるより単純な表記法を使うことができます。これは、量詞に続く余分な+文字で構成されています。この表記法を使うと、先ほどの例は次のように書き換えることができます。</target>
        </trans-unit>
        <trans-unit id="982546c2c1a7dfe452b41223e0b9ac156cdae924" translate="yes" xml:space="preserve">
          <source>Atomic subtraction and return of the result.</source>
          <target state="translated">原子の引き算と結果の返却。</target>
        </trans-unit>
        <trans-unit id="3d74d1749d4da9ae8e4ba38276cc8935928009a4" translate="yes" xml:space="preserve">
          <source>Atomic transactions. A series of table manipulation operations can be grouped into a single atomic transaction.</source>
          <target state="translated">アトミック トランザクション。一連のテーブル操作を1つのアトミックトランザクションにまとめることができます。</target>
        </trans-unit>
        <trans-unit id="e24ad40d30afa103adc1e00c3958d38ebb6700ca" translate="yes" xml:space="preserve">
          <source>Atomically changes the registered name &lt;code&gt;Name&lt;/code&gt; on all nodes to refer to &lt;code&gt;Pid&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Pid&lt;/code&gt; を参照するように、すべてのノードの登録名 &lt;code&gt;Name&lt;/code&gt; を原子的に変更します。</target>
        </trans-unit>
        <trans-unit id="2493472ac358dd449dd5c5363f10400e17b2f569" translate="yes" xml:space="preserve">
          <source>Atomically compares the atomic with &lt;code&gt;Expected&lt;/code&gt;, and if those are equal, set atomic to &lt;code&gt;Desired&lt;/code&gt;. Returns &lt;code&gt;ok&lt;/code&gt; if &lt;code&gt;Desired&lt;/code&gt; was written. Returns the actual atomic value if not equal to &lt;code&gt;Expected&lt;/code&gt;.</source>
          <target state="translated">アトミックを &lt;code&gt;Expected&lt;/code&gt; とアトミックに比較し、それらが等しい場合は、atomicを &lt;code&gt;Desired&lt;/code&gt; に設定します。 &lt;code&gt;Desired&lt;/code&gt; が書き込まれた場合は &lt;code&gt;ok&lt;/code&gt; を返します。 &lt;code&gt;Expected&lt;/code&gt; 値と等しくない場合は、実際のアトミック値を返します。</target>
        </trans-unit>
        <trans-unit id="9d81a1603d3a7688828359e353ff047ffd9ff583" translate="yes" xml:space="preserve">
          <source>Atomically replaces the value of the atomic with &lt;code&gt;Desired&lt;/code&gt; and returns the value it held previously.</source>
          <target state="translated">アトミックの値を &lt;code&gt;Desired&lt;/code&gt; にアトミックに置き換え、以前に保持していた値を返します。</target>
        </trans-unit>
        <trans-unit id="7dfdf2c7a48eb8aa0595b9fdbbeea1555b65d328" translate="yes" xml:space="preserve">
          <source>Atomicity</source>
          <target state="translated">Atomicity</target>
        </trans-unit>
        <trans-unit id="ee048f7e55224c5c36ed6495f528ec9c74109599" translate="yes" xml:space="preserve">
          <source>Atomicity is important when it is needed to write atomically more than one record in the same transaction. The function &lt;code&gt;raise/2&lt;/code&gt;, shown in the previous example, writes one record only. The function &lt;code&gt;insert_emp/3&lt;/code&gt;, shown in the program listing in &lt;code&gt;&lt;a href=&quot;mnesia_chap2#getting_started&quot;&gt;Getting Started&lt;/a&gt;&lt;/code&gt;, writes the record &lt;code&gt;employee&lt;/code&gt; as well as employee relations, such as &lt;code&gt;at_dep&lt;/code&gt; and &lt;code&gt;in_proj&lt;/code&gt;, into the database. If this latter code is run inside a transaction, the transaction handler ensures that the transaction either succeeds completely, or not at all.</source>
          <target state="translated">同じトランザクションで複数のレコードをアトミ​​ックに書き込む必要がある場合、原子性は重要です。前の例に示す関数 &lt;code&gt;raise/2&lt;/code&gt; は、1つのレコードのみを書き込みます。 &lt;code&gt;&lt;a href=&quot;mnesia_chap2#getting_started&quot;&gt;Getting Started&lt;/a&gt;&lt;/code&gt; のプログラムリストに示されている関数 &lt;code&gt;insert_emp/3&lt;/code&gt; は、レコードの &lt;code&gt;employee&lt;/code&gt; 員と、従業員関係（ &lt;code&gt;at_dep&lt;/code&gt; や &lt;code&gt;in_proj&lt;/code&gt; など）をデータベースに書き込みます。この後者のコードがトランザクション内で実行される場合、トランザクションハンドラーは、トランザクションが完全に成功するか、まったく成功しないようにします。</target>
        </trans-unit>
        <trans-unit id="9e7bf26b3574db121c0f9c2d5135066a290bba9b" translate="yes" xml:space="preserve">
          <source>Atomicity means that database changes that are executed by a transaction take effect on all nodes involved, or on none of the nodes. That is, the transaction either succeeds entirely, or it fails entirely.</source>
          <target state="translated">アトミック性とは、トランザクションによって実行されたデータベースの変更は、関係するすべてのノードで有効になるか、またはどのノードでも有効にならないことを意味します。つまり、トランザクションは完全に成功するか、完全に失敗するかのどちらかです。</target>
        </trans-unit>
        <trans-unit id="9fd0fef61eacad14e3b6ee3330650b0b6285e00f" translate="yes" xml:space="preserve">
          <source>Atomics are 64 bit integers.</source>
          <target state="translated">アトミックは64ビットの整数です。</target>
        </trans-unit>
        <trans-unit id="668e283c28347d455368391a2021ca18daf0d65e" translate="yes" xml:space="preserve">
          <source>Atomics are not tied to the current process and are automatically garbage collected when they are no longer referenced.</source>
          <target state="translated">アトミックは現在のプロセスに縛られておらず、参照されなくなると自動的にゴミとして収集されます。</target>
        </trans-unit>
        <trans-unit id="e85a2063ae4b966a0609e0b05bc24c3b00cbb202" translate="yes" xml:space="preserve">
          <source>Atomics can be represented as either signed or unsigned.</source>
          <target state="translated">アトミックは符号付きまたは符号なしで表現できます。</target>
        </trans-unit>
        <trans-unit id="cd729319f6838749442998b087a916cd07e23c32" translate="yes" xml:space="preserve">
          <source>Atomics wrap around at overflow and underflow operations.</source>
          <target state="translated">アトミックは、オーバーフローやアンダーフローの操作で包み込むようにしています。</target>
        </trans-unit>
        <trans-unit id="f53a98286f82798d588f67a7f0db19f7aebc839e" translate="yes" xml:space="preserve">
          <source>Atoms</source>
          <target state="translated">Atoms</target>
        </trans-unit>
        <trans-unit id="8b4ce0020874da6c44e911622f2debe1461e0f0d" translate="yes" xml:space="preserve">
          <source>Atoms and variables can use all Latin-1 letters.</source>
          <target state="translated">アトムと変数はすべてのLatin-1文字を使用することができます。</target>
        </trans-unit>
        <trans-unit id="cad694cf01aa8c5551f1401deeab34aabdb5d17c" translate="yes" xml:space="preserve">
          <source>Atoms are compared using their string value, codepoint by codepoint.</source>
          <target state="translated">アトムは文字列の値を使って、コードポイントごとに比較されます。</target>
        </trans-unit>
        <trans-unit id="8e89bc7b897d5b27ce2d498db94d099bf846c461" translate="yes" xml:space="preserve">
          <source>Atoms are not garbage-collected. Once an atom is created, it is never removed. The emulator terminates if the limit for the number of atoms (1,048,576 by default) is reached.</source>
          <target state="translated">アトムはゴミ箱に回収されません。一度作成されたアトムが削除されることはありません。アトムの数の上限(デフォルトでは1,048,576)に達するとエミュレータは終了します。</target>
        </trans-unit>
        <trans-unit id="53953ef0095a671ea4007a14634a7ef6dcdd0975" translate="yes" xml:space="preserve">
          <source>Atoms starting with &lt;code&gt;@&lt;/code&gt;, for example &lt;code&gt;'@foo'&lt;/code&gt; or &lt;code&gt;'@Foo'&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;@&lt;/code&gt; で始まる原子（例： &lt;code&gt;'@foo'&lt;/code&gt; または &lt;code&gt;'@Foo'&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="cf1f2e1b1dd67aa033d9dce573a905b7f9461d62" translate="yes" xml:space="preserve">
          <source>Attaches comments to a syntax tree. The result is a pair &lt;code&gt;{NewTree, Remainder}&lt;/code&gt; where &lt;code&gt;NewTree&lt;/code&gt; is the given &lt;code&gt;Tree&lt;/code&gt; where comments from the list &lt;code&gt;Comments&lt;/code&gt; have been attached at the proper places. &lt;code&gt;Remainder&lt;/code&gt; is the list of entries in &lt;code&gt;Comments&lt;/code&gt; which have not been inserted, because their line numbers are greater than those of any node in the tree. The entries in &lt;code&gt;Comments&lt;/code&gt; are inserted in order; if two comments become attached to the same node, they will appear in the same order in the program text.</source>
          <target state="translated">構文ツリーにコメントを添付します。結果はペア &lt;code&gt;{NewTree, Remainder}&lt;/code&gt; ここで、 &lt;code&gt;NewTree&lt;/code&gt; は指定された &lt;code&gt;Tree&lt;/code&gt; で、リストの &lt;code&gt;Comments&lt;/code&gt; は適切な場所に添付されています。 &lt;code&gt;Remainder&lt;/code&gt; は、行番号がツリー内のノードの行番号より大きいため、挿入されていない &lt;code&gt;Comments&lt;/code&gt; のエントリのリストです。 &lt;code&gt;Comments&lt;/code&gt; のエントリは順番に挿入されます。 2つのコメントが同じノードに添付されると、それらはプログラムテキスト内で同じ順序で表示されます。</target>
        </trans-unit>
        <trans-unit id="d2ceee4cae7cbba986c24f620add3c4dd9b79139" translate="yes" xml:space="preserve">
          <source>Attaches comments to the syntax tree/trees representing a program. The given &lt;code&gt;Forms&lt;/code&gt; should be a single syntax tree of type &lt;code&gt;form_list&lt;/code&gt;, or a list of syntax trees representing &quot;program forms&quot;. The syntax trees must contain valid position information (for details, see &lt;code&gt;recomment_tree/2&lt;/code&gt;). The result is a corresponding syntax tree of type &lt;code&gt;form_list&lt;/code&gt; in which all comments in the list &lt;code&gt;Comments&lt;/code&gt; have been attached at the proper places.</source>
          <target state="translated">プログラムを表す構文ツリーにコメントを添付します。指定する &lt;code&gt;Forms&lt;/code&gt; は、 &lt;code&gt;form_list&lt;/code&gt; タイプの単一の構文ツリーか、「プログラムフォーム」を表す構文ツリーのリストである必要があります。構文ツリーには有効な位置情報が含まれている必要があります（詳細については、 &lt;code&gt;recomment_tree/2&lt;/code&gt; を参照してください）。結果は、型の対応する構文木である &lt;code&gt;form_list&lt;/code&gt; リスト内のすべてのコメントをした &lt;code&gt;Comments&lt;/code&gt; 、適切な場所に取り付けられています。</target>
        </trans-unit>
        <trans-unit id="08f3c18f1ef82b85d187f359be8053ba60fcff3a" translate="yes" xml:space="preserve">
          <source>Attaches to the debugged process &lt;code&gt;Pid&lt;/code&gt;. An Attach Process window is opened for the process.</source>
          <target state="translated">デバッグされたプロセス &lt;code&gt;Pid&lt;/code&gt; にアタッチします。プロセスの「プロセスの接続」ウィンドウが開きます。</target>
        </trans-unit>
        <trans-unit id="e858ba60db5ffa465fde04178472518163ea425c" translate="yes" xml:space="preserve">
          <source>Attaches to the debugged process &lt;code&gt;Pid&lt;/code&gt;. The interpreter calls &lt;code&gt;spawn(Module, Name, [Pid])&lt;/code&gt; (and ignores the result).</source>
          <target state="translated">デバッグされたプロセス &lt;code&gt;Pid&lt;/code&gt; にアタッチします。インタプリタは、 &lt;code&gt;spawn(Module, Name, [Pid])&lt;/code&gt; 呼び出します（結果を無視します）。</target>
        </trans-unit>
        <trans-unit id="dc33862cfcafa306527c136f22aeb55fbb46ae26" translate="yes" xml:space="preserve">
          <source>Attaches to the process and open an &lt;code&gt;&lt;a href=&quot;#attach&quot;&gt;Attach Process window&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#attach&quot;&gt;Attach Process window&lt;/a&gt;&lt;/code&gt; し、「プロセスの接続」ウィンドウを開きます。</target>
        </trans-unit>
        <trans-unit id="a27b2860df5ad784c2a072eec792bd3ddbfbbcf2" translate="yes" xml:space="preserve">
          <source>Attempt to delete the current directory. On some platforms, &lt;code&gt;eacces&lt;/code&gt; is returned instead.</source>
          <target state="translated">現在のディレクトリを削除しようとしました。一部のプラットフォームでは、代わりに &lt;code&gt;eacces&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="4dd873defa6a2d59737d4e84f136645c52891193" translate="yes" xml:space="preserve">
          <source>Attribute &lt;code&gt;-dialyzer()&lt;/code&gt; can also be used for turning on warnings. For example, if a module has been fixed regarding unmatched returns, adding the following line can help in assuring that no new unmatched return warnings are introduced:</source>
          <target state="translated">属性 &lt;code&gt;-dialyzer()&lt;/code&gt; は警告をオンにするためにも使用できます。たとえば、一致しないリターンに関するモジュールが修正されている場合、次の行を追加すると、新しい一致しないリターンの警告が発生しないことを確認できます。</target>
        </trans-unit>
        <trans-unit id="94a2d033077fb7d4c11be4d28e975e8f7fa67d5d" translate="yes" xml:space="preserve">
          <source>Attribute &lt;code&gt;-dialyzer()&lt;/code&gt; can be used for turning off warnings in a module by specifying functions or warning options. For example, to turn off all warnings for the function &lt;code&gt;f/0&lt;/code&gt;, include the following line:</source>
          <target state="translated">属性 &lt;code&gt;-dialyzer()&lt;/code&gt; は、関数または警告オプションを指定して、モジュールの警告をオフにするために使用できます。たとえば、関数 &lt;code&gt;f/0&lt;/code&gt; のすべての警告をオフにするには、次の行を含めます。</target>
        </trans-unit>
        <trans-unit id="3bb46baccc6ddbcfec9893a911a5598494b5fa7f" translate="yes" xml:space="preserve">
          <source>Attribute &lt;code&gt;-dialyzer()&lt;/code&gt; is allowed after function declarations. Lists of warning options or functions are allowed:</source>
          <target state="translated">属性 &lt;code&gt;-dialyzer()&lt;/code&gt; は、関数宣言の後に使用できます。警告オプションまたは警告機能のリストを使用できます：</target>
        </trans-unit>
        <trans-unit id="20497f389e60747b76a9f4c282fe115ff9e65b81" translate="yes" xml:space="preserve">
          <source>Attribute = {atom(), term()}</source>
          <target state="translated">属性={atom(),term()}</target>
        </trans-unit>
        <trans-unit id="56cec620065c043a2c53d113a84f30cf04a24bfc" translate="yes" xml:space="preserve">
          <source>Attributes = [{Name, Value}| #xmlAttribute{}]</source>
          <target state="translated">属性=[{名前、値}| #xmlAttribute{}]</target>
        </trans-unit>
        <trans-unit id="8196898f60a411611bff755ce53bcb927eed9bf5" translate="yes" xml:space="preserve">
          <source>Audit Trail Logging</source>
          <target state="translated">監査トレイルロギング</target>
        </trans-unit>
        <trans-unit id="e7a0dac799c2ac1aee5c36d21a89de6463f1070c" translate="yes" xml:space="preserve">
          <source>Auth-Application-Id AVP</source>
          <target state="translated">認証申請ID AVP</target>
        </trans-unit>
        <trans-unit id="6f57677bc7cc52df8c3d26defd5359054852e0c9" translate="yes" xml:space="preserve">
          <source>Auth-Grace-Period AVP</source>
          <target state="translated">認証-グレース-ペリオド AVP</target>
        </trans-unit>
        <trans-unit id="ffad30279d0dbdebdba0995b72cf095104751ce5" translate="yes" xml:space="preserve">
          <source>Auth-Request-Type AVP</source>
          <target state="translated">認証要求型AVP</target>
        </trans-unit>
        <trans-unit id="bab9dd08fa19bdf6f1b4cf6e9f78668ae505c80e" translate="yes" xml:space="preserve">
          <source>Auth-Request-Type AVP Values</source>
          <target state="translated">認証要求タイプ AVP 値</target>
        </trans-unit>
        <trans-unit id="d8ff104e64da7ae152dbd68cb8bb5ac85c8606c8" translate="yes" xml:space="preserve">
          <source>Auth-Session-State AVP</source>
          <target state="translated">認証セッション状態 AVP</target>
        </trans-unit>
        <trans-unit id="52aa2478028e9ddcf53894d8996729bb4145d0b1" translate="yes" xml:space="preserve">
          <source>Auth-Session-State AVP Values</source>
          <target state="translated">認証セッション状態 AVP 値</target>
        </trans-unit>
        <trans-unit id="b01542a7f0aa1f0864e6a230526030dbd833afdd" translate="yes" xml:space="preserve">
          <source>Authenticate the connection using simple authentication.</source>
          <target state="translated">簡易認証を使用して接続を認証します。</target>
        </trans-unit>
        <trans-unit id="35d60aabf722ed742565d9c00b64a125d7839912" translate="yes" xml:space="preserve">
          <source>Authenticated Encryption with Associated Data</source>
          <target state="translated">関連データを用いた認証済み暗号化</target>
        </trans-unit>
        <trans-unit id="efdb86330764c8fbe68da0d4b6819ef23c162680" translate="yes" xml:space="preserve">
          <source>Authenticating the integrity of the handshake messages.</source>
          <target state="translated">握手メッセージの整合性を認証します。</target>
        </trans-unit>
        <trans-unit id="efa60b3797f87eb6c6f0da41e22b02554c4d0aa2" translate="yes" xml:space="preserve">
          <source>Authentication (done by &lt;code&gt; net_kernel(3)&lt;/code&gt;) (3)</source>
          <target state="translated">認証（ &lt;code&gt; net_kernel(3)&lt;/code&gt; によって実行）（3）</target>
        </trans-unit>
        <trans-unit id="7a30fd25c7a3f93a7b30740a0a98229a0638bb08" translate="yes" xml:space="preserve">
          <source>Authentication (done by &lt;code&gt;net_kernel(3)&lt;/code&gt;) (3)</source>
          <target state="translated">認証（ &lt;code&gt;net_kernel(3)&lt;/code&gt; によって行われます）（3）</target>
        </trans-unit>
        <trans-unit id="2ff2f3c3923c0921f88e897f48c0cfff1d679d6c" translate="yes" xml:space="preserve">
          <source>Authentication Protocol</source>
          <target state="translated">認証プロトコル</target>
        </trans-unit>
        <trans-unit id="dc6b01190c75db5a643cf18f6685ef326b9bb4bb" translate="yes" xml:space="preserve">
          <source>Authentication determines which nodes are allowed to communicate with each other. In a network of different Erlang nodes, it is built into the system at the lowest possible level. Each node has its own &lt;strong&gt;magic cookie&lt;/strong&gt;, which is an Erlang atom.</source>
          <target state="translated">認証は、どのノードが相互に通信できるかを決定します。異なるErlangノードのネットワークでは、可能な限り低いレベルでシステムに組み込まれています。各ノードには、Erlangアトムである独自の&lt;strong&gt;魔法のcookie&lt;/strong&gt;があります。</target>
        </trans-unit>
        <trans-unit id="b69c9c9364edcba7a03ffefeefa382cf82287356" translate="yes" xml:space="preserve">
          <source>Authentication of the peer is done by public key path validation as defined in RFC 3280. This means basically the following:</source>
          <target state="translated">ピアの認証は、RFC 3280で定義されている公開鍵パスの検証によって行われます。これは、基本的には以下のことを意味します。</target>
        </trans-unit>
        <trans-unit id="65b45c1a860b3348b9833c0a96364a1acd14c2b7" translate="yes" xml:space="preserve">
          <source>Authentication/access checks.</source>
          <target state="translated">認証/アクセスチェック。</target>
        </trans-unit>
        <trans-unit id="1ba9c0e85dda9702580d19335be06fa7a8c504cb" translate="yes" xml:space="preserve">
          <source>Authorization Session State Machine</source>
          <target state="translated">認証セッション状態機械</target>
        </trans-unit>
        <trans-unit id="cd708bd6499f399dc5b86474d073a1c2f25376ad" translate="yes" xml:space="preserve">
          <source>Authorization and accounting AVPs are defined in provided dictionaries. Their proper use is the responsibility of the user.</source>
          <target state="translated">認可とアカウンティング AVP は、提供された辞書で定義されています。それらの適切な使用はユーザーの責任です。</target>
        </trans-unit>
        <trans-unit id="f163341ede12f9adebdea0335c91c64ca9f864cb" translate="yes" xml:space="preserve">
          <source>Authorization is the responsibility of the user.</source>
          <target state="translated">認証はユーザーの責任で行ってください。</target>
        </trans-unit>
        <trans-unit id="50b27cabe4dbb1d4ad17bfe9e56741a4affc2eea" translate="yes" xml:space="preserve">
          <source>Authorization is the responsibility of the user: diameter does not implement this state machine.</source>
          <target state="translated">認可はユーザの責任である:diameterはこのステートマシンを実装していない。</target>
        </trans-unit>
        <trans-unit id="30ed2a3e728e1f003c2a2c8e103841be8b0ec854" translate="yes" xml:space="preserve">
          <source>Authorization-Lifetime AVP</source>
          <target state="translated">認可-生涯AVP</target>
        </trans-unit>
        <trans-unit id="11627de117205b8d3e5249886b3c5fcffd98fb20" translate="yes" xml:space="preserve">
          <source>Authorized Keys - OpenSSH Format</source>
          <target state="translated">認可された鍵-OpenSSH 形式</target>
        </trans-unit>
        <trans-unit id="edd7b5046b035f96ef22223b25da57cd6e60a20a" translate="yes" xml:space="preserve">
          <source>Authorized keys - OpenSSH format looks as follows:</source>
          <target state="translated">認可された鍵-OpenSSH の形式は以下のようになります。</target>
        </trans-unit>
        <trans-unit id="a574cde3f8131fcb2c5ef5b3ac87763f839e4628" translate="yes" xml:space="preserve">
          <source>Auto-imported BIFs are listed without module prefix. BIFs listed with module prefix are not auto-imported.</source>
          <target state="translated">自動インポートされたBIFは、モジュール接頭辞なしでリストアップされています。モジュール接頭辞を付けてリストアップされたBIFは自動インポートされません。</target>
        </trans-unit>
        <trans-unit id="c5883a7e0cca29e11fe6124ccc75bacf71f8b9f1" translate="yes" xml:space="preserve">
          <source>Automated execution of test suites (sets of test cases)</source>
          <target state="translated">テストスイート(テストケースのセット)の自動実行</target>
        </trans-unit>
        <trans-unit id="d436c113d37a4bf9ab8a69c9c589f736a5417312" translate="yes" xml:space="preserve">
          <source>Automatic compilation of test suites (and help modules)</source>
          <target state="translated">テストスイート(およびヘルプモジュール)の自動コンパイル</target>
        </trans-unit>
        <trans-unit id="fccc42c97a2ffc422d0e26337a4e4d5dff20a9b3" translate="yes" xml:space="preserve">
          <source>Automatic send transaction ack when the transaction reply has been received (see &lt;code&gt;trans_ack&lt;/code&gt; below).</source>
          <target state="translated">トランザクション応答が受信されたときの自動送信トランザクション確認（以下の &lt;code&gt;trans_ack&lt;/code&gt; を参照）。</target>
        </trans-unit>
        <trans-unit id="ca478c0ab639849e3541da90cb17a860b5490d08" translate="yes" xml:space="preserve">
          <source>Automatic send transaction pending if the timer expires before a transaction reply has been sent. This timer is also called provisional response timer.</source>
          <target state="translated">トランザクション返信が送信される前にタイマーが切れた場合、自動送信トランザクション保留。このタイマーは仮応答タイマーとも呼ばれる。</target>
        </trans-unit>
        <trans-unit id="93da85ea44d26c2624d1e105b7f890bc46bd09ba" translate="yes" xml:space="preserve">
          <source>Automatic state enter calls</source>
          <target state="translated">自動状態はコールを入力します。</target>
        </trans-unit>
        <trans-unit id="2a89768431c505706353574d66358c32a869dccc" translate="yes" xml:space="preserve">
          <source>Automatic type-casting probably makes these changes necessary only for a driver that encounters sizes &amp;gt; 32 bits.</source>
          <target state="translated">自動型キャストにより、これらの変更は、32ビットを超えるサイズに遭遇するドライバーに対してのみ必要になります。</target>
        </trans-unit>
        <trans-unit id="3ef94894ba2f4eb73cf0fd7bdecec218163555bf" translate="yes" xml:space="preserve">
          <source>Automatically inserted by Logger. The value is the same as the &lt;code&gt;HandlerId&lt;/code&gt; specified when adding the handler, and it cannot be changed.</source>
          <target state="translated">ロガーによって自動的に挿入されます。この値は、ハンドラーの追加時に指定した &lt;code&gt;HandlerId&lt;/code&gt; と同じであり、変更できません。</target>
        </trans-unit>
        <trans-unit id="77c6bd373dea25df6392c697b76ebb783fd68b3e" translate="yes" xml:space="preserve">
          <source>Automatically inserted by Logger. The value is the same as the &lt;code&gt;Module&lt;/code&gt; specified when adding the handler, and it cannot be changed.</source>
          <target state="translated">ロガーによって自動的に挿入されます。この値は、ハンドラーの追加時に指定した &lt;code&gt;Module&lt;/code&gt; と同じであり、変更できません。</target>
        </trans-unit>
        <trans-unit id="32d8c661feaa1a96e94bb053c82356a83532060b" translate="yes" xml:space="preserve">
          <source>Automatically send pending if the timer expires before a transaction reply has been sent. This timer is also called provisional response timer.</source>
          <target state="translated">トランザクションの応答が送信される前にタイマーの期限が切れた場合、自動的に保留を送信します。このタイマーは暫定応答タイマーとも呼ばれます。</target>
        </trans-unit>
        <trans-unit id="18da0ae80b2a3d06e9335371a77bc11e953c941d" translate="yes" xml:space="preserve">
          <source>Autoresume</source>
          <target state="translated">Autoresume</target>
        </trans-unit>
        <trans-unit id="51349a6371eec8fabecdb286d36f04bc3ea24184" translate="yes" xml:space="preserve">
          <source>Available in all OpenSSL compatible with Erlang CRYPTO if not disabled by configuration.</source>
          <target state="translated">設定で無効にしていなければ、Erlang CRYPTOと互換性のあるすべてのOpenSSLで利用できます。</target>
        </trans-unit>
        <trans-unit id="440311567fa2e46e6495460ee5e7f6ca1160021b" translate="yes" xml:space="preserve">
          <source>Available only in some POSIX systems, this call results in a call to &lt;code&gt;fsync()&lt;/code&gt;, or has no effect in systems not providing the &lt;code&gt;fdatasync()&lt;/code&gt; syscall.</source>
          <target state="translated">一部のPOSIXシステムでのみ使用可能なこの呼び出しは、 &lt;code&gt;fsync()&lt;/code&gt; への呼び出しになるか、 &lt;code&gt;fdatasync()&lt;/code&gt; syscallを提供しないシステムでは効果がありません。</target>
        </trans-unit>
        <trans-unit id="a5325c58f3190f03981f3d4b6e263a0fcae8b5bc" translate="yes" xml:space="preserve">
          <source>Available options are:</source>
          <target state="translated">利用可能なオプションは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="057b4b33c8569c09b413019743ff85bf2e11c330" translate="yes" xml:space="preserve">
          <source>Available options:</source>
          <target state="translated">利用可能なオプション。</target>
        </trans-unit>
        <trans-unit id="4e9d1b7f151f31fb76e5b9ef9857c7c1cae6dcf2" translate="yes" xml:space="preserve">
          <source>Available properties are the same as the start options of the server, but the properties &lt;code&gt;bind_address&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt; cannot be changed.</source>
          <target state="translated">使用可能なプロパティはサーバーの起動オプションと同じですが、 &lt;code&gt;bind_address&lt;/code&gt; および &lt;code&gt;port&lt;/code&gt; プロパティは変更できません。</target>
        </trans-unit>
        <trans-unit id="ef104ec434506c3596f5487f13a01379d4ba6bd2" translate="yes" xml:space="preserve">
          <source>Available through &lt;code&gt;erlang:trace/3&lt;/code&gt; with trace flag &lt;code&gt;'receive'&lt;/code&gt; and &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; as tracer module.</source>
          <target state="translated">&lt;code&gt;erlang:trace/3&lt;/code&gt; を通じて、トレースフラグ &lt;code&gt;'receive'&lt;/code&gt; および &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; をトレーサーモジュールとして使用できます。</target>
        </trans-unit>
        <trans-unit id="27f7db47a04206f9b18980fb6fca2934f7e7d231" translate="yes" xml:space="preserve">
          <source>Available through &lt;code&gt;erlang:trace/3&lt;/code&gt; with trace flag &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; as tracer module.</source>
          <target state="translated">&lt;code&gt;erlang:trace/3&lt;/code&gt; を通じて、トレースフラグの &lt;code&gt;call&lt;/code&gt; とトレーサーモジュールとしての &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; を使用して利用できます。</target>
        </trans-unit>
        <trans-unit id="ec9c72570d3ed2f9817e1e27636799b0c17600b7" translate="yes" xml:space="preserve">
          <source>Available through &lt;code&gt;erlang:trace/3&lt;/code&gt; with trace flag &lt;code&gt;call&lt;/code&gt; or &lt;code&gt;return_to&lt;/code&gt; and &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; as tracer module.</source>
          <target state="translated">&lt;code&gt;erlang:trace/3&lt;/code&gt; を通じて、トレースフラグの &lt;code&gt;call&lt;/code&gt; または &lt;code&gt;return_to&lt;/code&gt; および &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; をトレーサーモジュールとして使用できます。</target>
        </trans-unit>
        <trans-unit id="19369e2b69d2d29bcf7d2b110bd632c0497eadc1" translate="yes" xml:space="preserve">
          <source>Available through &lt;code&gt;erlang:trace/3&lt;/code&gt; with trace flag &lt;code&gt;garbage_collection&lt;/code&gt; and &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; as tracer module.</source>
          <target state="translated">&lt;code&gt;erlang:trace/3&lt;/code&gt; を通じて、トレースフラグ &lt;code&gt;garbage_collection&lt;/code&gt; と &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; をトレーサーモジュールとして使用できます。</target>
        </trans-unit>
        <trans-unit id="0b14892085d0235611acf16621043bf554272c4b" translate="yes" xml:space="preserve">
          <source>Available through &lt;code&gt;erlang:trace/3&lt;/code&gt; with trace flag &lt;code&gt;ports&lt;/code&gt; and &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; as tracer module.</source>
          <target state="translated">&lt;code&gt;erlang:trace/3&lt;/code&gt; を通じて、トレースフラグ &lt;code&gt;ports&lt;/code&gt; と &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; をトレーサーモジュールとして利用できます。</target>
        </trans-unit>
        <trans-unit id="98fc651851a4575e9edd1b04d22bca4d2ff1533e" translate="yes" xml:space="preserve">
          <source>Available through &lt;code&gt;erlang:trace/3&lt;/code&gt; with trace flag &lt;code&gt;procs&lt;/code&gt; and &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; as tracer module.</source>
          <target state="translated">&lt;code&gt;erlang:trace/3&lt;/code&gt; を通じて、トレースフラグ &lt;code&gt;procs&lt;/code&gt; と &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; をトレーサーモジュールとして使用できます。</target>
        </trans-unit>
        <trans-unit id="3f46a50dcc99ab759ab69e8cdf416560bd6713f8" translate="yes" xml:space="preserve">
          <source>Available through &lt;code&gt;erlang:trace/3&lt;/code&gt; with trace flag &lt;code&gt;running&lt;/code&gt; and &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; as tracer module.</source>
          <target state="translated">&lt;code&gt;erlang:trace/3&lt;/code&gt; を通じて、トレースフラグを &lt;code&gt;running&lt;/code&gt; 、 &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; をトレーサーモジュールとして使用できます。</target>
        </trans-unit>
        <trans-unit id="04747a5c4337891e1a74cc42657f396a199e1343" translate="yes" xml:space="preserve">
          <source>Available through &lt;code&gt;erlang:trace/3&lt;/code&gt; with trace flag &lt;code&gt;send&lt;/code&gt; and &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; as tracer module.</source>
          <target state="translated">&lt;code&gt;erlang:trace/3&lt;/code&gt; を通じて、トレースフラグ &lt;code&gt;send&lt;/code&gt; および &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; をトレーサーモジュールとして使用できます。</target>
        </trans-unit>
        <trans-unit id="0979e25ae12ecf75e6954405c51afc218144f433" translate="yes" xml:space="preserve">
          <source>Average packet size deviation, in bytes, received by the socket.</source>
          <target state="translated">ソケットが受信したパケットサイズの平均偏差(バイト単位)。</target>
        </trans-unit>
        <trans-unit id="24a6380cb9d560f221f5bab0ac3ac216888c3989" translate="yes" xml:space="preserve">
          <source>Average packet size deviation, in bytes, sent from the socket.</source>
          <target state="translated">ソケットから送信されるパケットサイズの平均偏差(バイト単位)。</target>
        </trans-unit>
        <trans-unit id="ba5da32502768a08b71f47f54787f1a18d984da2" translate="yes" xml:space="preserve">
          <source>Average size of packets, in bytes, received by the socket.</source>
          <target state="translated">ソケットが受信したパケットの平均サイズをバイト単位で指定します。</target>
        </trans-unit>
        <trans-unit id="a548c980c935b270267b69573bc6d8a367a0ccd7" translate="yes" xml:space="preserve">
          <source>Average size of packets, in bytes, sent from the socket.</source>
          <target state="translated">ソケットから送信されるパケットの平均サイズをバイト単位で指定します。</target>
        </trans-unit>
        <trans-unit id="9310b13917c5edfa2bbc94f7c936299d95178f26" translate="yes" xml:space="preserve">
          <source>Avestan</source>
          <target state="translated">Avestan</target>
        </trans-unit>
        <trans-unit id="7666ec90c7fb3e6a7737d1ce78d04e16a63f834f" translate="yes" xml:space="preserve">
          <source>Avoid calling this on the root keys, as it can be slow.</source>
          <target state="translated">ルートキーでの呼び出しは遅いので避けましょう。</target>
        </trans-unit>
        <trans-unit id="9ecc5c52604408ca037f4b32a55f99303082c7df" translate="yes" xml:space="preserve">
          <source>Avoid md5 for hashing</source>
          <target state="translated">ハッシュのために md5 を避ける</target>
        </trans-unit>
        <trans-unit id="8eebcbcc17ab43565fe594806f1d03745ee4ec86" translate="yes" xml:space="preserve">
          <source>Avoid mixing multiple &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; with driver reload requests.</source>
          <target state="translated">複数の &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; とドライバーのリロード要求を混在させないでください。</target>
        </trans-unit>
        <trans-unit id="64e751996a0cede9d2045cdc8ba23d1357661337" translate="yes" xml:space="preserve">
          <source>Avoid storing a retrieved persistent term in a process if that persistent term could be deleted or updated in the future. If a process holds a reference to a persistent term when the term is deleted, the process will be garbage collected and the term copied to process.</source>
          <target state="translated">取得した永続的な用語が将来削除されたり更新されたりする可能性がある場合は、取得した永続的な用語をプロセスに格納しないようにしてください。タームが削除されたときにプロセスが永続タームへの参照を保持している場合、プロセスはガベージコレクションされ、タームはプロセスにコピーされます。</target>
        </trans-unit>
        <trans-unit id="98289f5c4b0096f8495ef524df96672c88d3f383" translate="yes" xml:space="preserve">
          <source>Avoid the following values of &lt;code&gt;ResourceId&lt;/code&gt;, otherwise Erlang/OTP does not work properly:</source>
          <target state="translated">&lt;code&gt;ResourceId&lt;/code&gt; の次の値は避けてください。そうしないと、Erlang / OTPが正しく機能しません。</target>
        </trans-unit>
        <trans-unit id="69f8c47d6443544fd8368765fa26d69b3ce0d361" translate="yes" xml:space="preserve">
          <source>Avoid updating or deleting more than one persistent term at a time. Each deleted term will trigger its own global GC. That means that deleting N terms will make the system less responsive N times longer than deleting a single persistent term. Therefore, terms that are to be updated at the same time should be collected into a larger term, for example, a map or a tuple.</source>
          <target state="translated">一度に複数の永続的なタームを更新または削除しないでください。削除された各タームは、それ自身のグローバルGCをトリガします。つまり、N 個のタームを削除すると、1 つの永続的タームを削除するよりも N 倍長くシステムの応答性が低下することを意味します。したがって、同時に更新される用語は、マップやタプルなど、より大きな用語に収集する必要があります。</target>
        </trans-unit>
        <trans-unit id="0fd4af0dc21ec9248c3098d7f5fe046b4b61faff" translate="yes" xml:space="preserve">
          <source>Avoid using &lt;code&gt;IP_ADJUSTMENT&lt;/code&gt; directly. Use &lt;code&gt;SET_I_REL()&lt;/code&gt; or one of the macros that invoke such as &lt;code&gt;FAIL()&lt;/code&gt; or &lt;code&gt;JUMP()&lt;/code&gt; defined in &lt;code&gt;macros.tab&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;IP_ADJUSTMENT&lt;/code&gt; を直接使用することは避けてください。使用 &lt;code&gt;SET_I_REL()&lt;/code&gt; または等たinvokeことマクロの一つ &lt;code&gt;FAIL()&lt;/code&gt; または &lt;code&gt;JUMP()&lt;/code&gt; で定義され &lt;code&gt;macros.tab&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2ebd07d23bcd301e7132f885cb8e225fce4de1c1" translate="yes" xml:space="preserve">
          <source>Avoiding common mistakes:</source>
          <target state="translated">よくある失敗を避けること。</target>
        </trans-unit>
        <trans-unit id="8677c671e8bfb9480004f697032e107bf2d89ade" translate="yes" xml:space="preserve">
          <source>B/SFR</source>
          <target state="translated">B/SFR</target>
        </trans-unit>
        <trans-unit id="d6a2b7b76ae3b1331d97630c6fbdfda1e2e20faf" translate="yes" xml:space="preserve">
          <source>BEAM is a register-based virtual machine. It has 1024 virtual registers that are used for holding temporary values and for passing arguments when calling functions. Variables that need to survive a function call are saved to the stack.</source>
          <target state="translated">BEAMはレジスタベースの仮想マシンです。1024個の仮想レジスタを持ち、一時的な値を保持したり、関数を呼び出す際に引数を渡したりするために使用します。関数の呼び出しに耐えなければならない変数はスタックに保存されます。</target>
        </trans-unit>
        <trans-unit id="4e374de82335c7a8d86c8e4d74077c948da138e0" translate="yes" xml:space="preserve">
          <source>BEAM is a threaded-code interpreter. Each instruction is word pointing directly to executable C-code, making instruction dispatching very fast.</source>
          <target state="translated">BEAMはスレッドコードインタプリタです。各命令は実行可能なCコードに直接ワードポイントされるため、命令のディスパッチが非常に速くなります。</target>
        </trans-unit>
        <trans-unit id="afd33b1e8c4969947e4dc49baade4763f8ff8b20" translate="yes" xml:space="preserve">
          <source>BEAM_FORMAT_NUMBER</source>
          <target state="translated">BEAM_FORMAT_NUMBER</target>
        </trans-unit>
        <trans-unit id="7efce4656362191b2f6893e9594afff40994fed8" translate="yes" xml:space="preserve">
          <source>BIFs are functions that for some reason are built-in to the Erlang virtual machine. BIFs often implement functionality that is impossible or is too inefficient to implement in Erlang. Some BIFs can be called using the function name only but they are by default belonging to the &lt;code&gt;erlang&lt;/code&gt; module. For example, the call to the BIF &lt;code&gt;trunc&lt;/code&gt; below is equivalent to a call to &lt;code&gt;erlang:trunc&lt;/code&gt;.</source>
          <target state="translated">BIFは、何らかの理由でErlang仮想マシンに組み込まれている関数です。BIFは多くの場合、Erlangに実装するのが不可能または非効率的な機能を実装しています。一部のBIFは関数名のみを使用して呼び出すことができますが、デフォルトでは &lt;code&gt;erlang&lt;/code&gt; モジュールに属しています。たとえば、以下のBIF &lt;code&gt;trunc&lt;/code&gt; の呼び出しは &lt;code&gt;erlang:trunc&lt;/code&gt; の呼び出しと同等です。</target>
        </trans-unit>
        <trans-unit id="890c2ec47feac80bf8654b893be74f130c02facf" translate="yes" xml:space="preserve">
          <source>BIFs are implemented in C code in the runtime system. BIFs do things that are difficult or impossible to implement in Erlang. Most of the BIFs belong to the module &lt;code&gt;erlang&lt;/code&gt; but there are also BIFs belonging to a few other modules, for example &lt;code&gt;lists&lt;/code&gt; and &lt;code&gt;ets&lt;/code&gt;.</source>
          <target state="translated">BIFは、ランタイムシステムのCコードで実装されます。BIFは、Erlangでの実装が困難または不可能なことを行います。ほとんどのBIFはモジュール &lt;code&gt;erlang&lt;/code&gt; に属していますが、 &lt;code&gt;lists&lt;/code&gt; や &lt;code&gt;ets&lt;/code&gt; など、他のいくつかのモジュールに属しているBIFもあります。</target>
        </trans-unit>
        <trans-unit id="42278b69b892fd26dcff3099719503a85d2ed515" translate="yes" xml:space="preserve">
          <source>BIFs can fail for various reasons. All BIFs fail with reason &lt;code&gt;badarg&lt;/code&gt; if they are called with arguments of an incorrect type. The other reasons are described in the description of each individual BIF.</source>
          <target state="translated">BIFはさまざまな理由で失敗する可能性があります。不正な型の引数で呼び出された場合、すべての &lt;code&gt;badarg&lt;/code&gt; は理由badargで失敗します。その他の理由は、各BIFの説明に記載されています。</target>
        </trans-unit>
        <trans-unit id="0971b2037c9ec621fb794e414dbe4e3e6e9ea234" translate="yes" xml:space="preserve">
          <source>Back at the top level, the next character (&quot;c&quot;) is compared with what subpattern 2 matched, which was &quot;a&quot;. This fails. As the recursion is treated as an atomic group, there are now no backtracking points, and so the entire match fails. (Perl can now re-enter the recursion and try the second alternative.) However, if the pattern is written with the alternatives in the other order, things are different:</source>
          <target state="translated">トップレベルに戻って、次の文字(&quot;c&quot;)をサブパターン2がマッチしたもの(&quot;a&quot;)と比較します。これは失敗です。再帰はアトミックグループとして扱われるため、バックトラックポイントが存在しないため、マッチ全体が失敗します。(Perlは再帰を再入力して2番目の代替案を試すことができるようになりました。)しかし、パターンが他の順番で書かれている場合、状況は異なります。</target>
        </trans-unit>
        <trans-unit id="48a05ca6fa60802ff208e26ea9e34464ac28a529" translate="yes" xml:space="preserve">
          <source>Back references of this type cause the group that they reference to be treated as an atomic group. Once the whole group has been matched, a subsequent matching failure cannot cause backtracking into the middle of the group.</source>
          <target state="translated">このタイプの後方参照では、参照したグループがアトミック・グループとして扱われます。グループ全体が一度マッチしてしまうと、その後のマッチ失敗でグループの途中までバックトラックすることはできません。</target>
        </trans-unit>
        <trans-unit id="ab429c0e231fa759e013662e3a14521ce2c5b79b" translate="yes" xml:space="preserve">
          <source>Backend functions used by &lt;code&gt;inet:gethostbyaddr/1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;inet:gethostbyaddr/1&lt;/code&gt; によって使用されるバックエンド関数。</target>
        </trans-unit>
        <trans-unit id="4aa3add341382a466d659f858fca56aef2ce0f58" translate="yes" xml:space="preserve">
          <source>Backend functions used by &lt;code&gt;inet:gethostbyname/1,2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;inet:gethostbyname/1,2&lt;/code&gt; によって使用されるバックエンド関数。</target>
        </trans-unit>
        <trans-unit id="64dd60fe1a049fe6db3eb1369dec2e42bf428e21" translate="yes" xml:space="preserve">
          <source>Background</source>
          <target state="translated">Background</target>
        </trans-unit>
        <trans-unit id="5563f67965aa081b7f33678be0a71475fa96ccb8" translate="yes" xml:space="preserve">
          <source>Backing Up the Registry to Mnesia</source>
          <target state="translated">レジストリをMnesiaにバックアップする</target>
        </trans-unit>
        <trans-unit id="a826c283ce6a52f2d32eb19de6510cb9098ad99b" translate="yes" xml:space="preserve">
          <source>Backslash</source>
          <target state="translated">Backslash</target>
        </trans-unit>
        <trans-unit id="88d130a66de8e5db01660642d9f23e1f0eef97dd" translate="yes" xml:space="preserve">
          <source>Backspace</source>
          <target state="translated">Backspace</target>
        </trans-unit>
        <trans-unit id="84e3bb9dd16cb2ba0f02d7245545feda5e3cabcb" translate="yes" xml:space="preserve">
          <source>Backspace.</source>
          <target state="translated">Backspace.</target>
        </trans-unit>
        <trans-unit id="dd96994d01e723dd6f9b0bdb6119722dbeb9faf0" translate="yes" xml:space="preserve">
          <source>Backup</source>
          <target state="translated">Backup</target>
        </trans-unit>
        <trans-unit id="7fc5d71b3eae328beb908064e6dec5ed2151041f" translate="yes" xml:space="preserve">
          <source>Backup and restore of C node state to and from &lt;code&gt;Mnesia&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; ノードとの間のCノード状態のバックアップと復元</target>
        </trans-unit>
        <trans-unit id="643aeb5ad5e07a8a0aedfaec9f291b8b2d8eb1e8" translate="yes" xml:space="preserve">
          <source>Backup operation are performed with the following functions:</source>
          <target state="translated">バックアップ操作は以下の機能で行います。</target>
        </trans-unit>
        <trans-unit id="a1b1261f879477741073cc5643737c50cece295a" translate="yes" xml:space="preserve">
          <source>Backup persistent data handled by the manager.</source>
          <target state="translated">管理者が扱う永続的なデータをバックアップします。</target>
        </trans-unit>
        <trans-unit id="48159fb2ea43e7a90492b5cc62df25d733040b1d" translate="yes" xml:space="preserve">
          <source>Backup persistent/permanent data handled by the agent (such as local-db, mib-data and vacm).</source>
          <target state="translated">エージェントが扱う永続/永続データ(local-db、mib-data、vacmなど)をバックアップします。</target>
        </trans-unit>
        <trans-unit id="76b2ca97753e81a47e64d73e23600b3684a357e4" translate="yes" xml:space="preserve">
          <source>Backup, restore, fallback, and disaster recovery</source>
          <target state="translated">バックアップ、リストア、フォールバック、ディザスタリカバリ</target>
        </trans-unit>
        <trans-unit id="8afb5bf327667dc553b8e9a32ac34a080d815b3b" translate="yes" xml:space="preserve">
          <source>BackupDir cannot be identical to DbDir.</source>
          <target state="translated">BackupDirはDbDirと同一であることはできません。</target>
        </trans-unit>
        <trans-unit id="f132fe31e8d713406288c3f7dcb9dbc8378cfdf5" translate="yes" xml:space="preserve">
          <source>Backward character</source>
          <target state="translated">後方文字</target>
        </trans-unit>
        <trans-unit id="82c36d6a4f52a2dc6589f184f22fdf4b95e97b1c" translate="yes" xml:space="preserve">
          <source>Backward kill line</source>
          <target state="translated">後方キルライン</target>
        </trans-unit>
        <trans-unit id="5be769b9776675c14c24d6f30ed3fba3e401a997" translate="yes" xml:space="preserve">
          <source>Backward kill word</source>
          <target state="translated">後ろ向きな殺伐とした言葉</target>
        </trans-unit>
        <trans-unit id="c0b7a7d6f9015db486c407e9f3cba9dc8dea0ff8" translate="yes" xml:space="preserve">
          <source>Backward word</source>
          <target state="translated">後ろ向きの言葉</target>
        </trans-unit>
        <trans-unit id="1161e058ccd842cdd5e5fe2efd102fbd9ed43bbd" translate="yes" xml:space="preserve">
          <source>Bad argument in an arithmetic expression.</source>
          <target state="translated">算術式の引数が悪い。</target>
        </trans-unit>
        <trans-unit id="af4ade1fd757cc8bcb7e76a2f6d37f1ec5bbb7b5" translate="yes" xml:space="preserve">
          <source>Bad argument.</source>
          <target state="translated">議論が悪い。</target>
        </trans-unit>
        <trans-unit id="c4cf9343231b13c7b7056a157910cd49cc8ff14e" translate="yes" xml:space="preserve">
          <source>Bad argument. The argument is of wrong data type, or is otherwise badly formed.</source>
          <target state="translated">悪い引数。引数のデータ型が間違っているか、その他の形が悪い。</target>
        </trans-unit>
        <trans-unit id="3401e9b8481ac17e3759a0b06770cb6fc7bbc79c" translate="yes" xml:space="preserve">
          <source>Bad input arguments to &lt;code&gt;open_port&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;open_port&lt;/code&gt; への不正な入力引数。</target>
        </trans-unit>
        <trans-unit id="c79c6d51e7687de96c195245b69faaf4a624b33e" translate="yes" xml:space="preserve">
          <source>Balinese</source>
          <target state="translated">Balinese</target>
        </trans-unit>
        <trans-unit id="00a38285d256e3839414c33b846ee83469fa016a" translate="yes" xml:space="preserve">
          <source>Bamum</source>
          <target state="translated">Bamum</target>
        </trans-unit>
        <trans-unit id="26e5990472188146a21fbe9216d5e35fd4688af2" translate="yes" xml:space="preserve">
          <source>Base Protocol Command AVP Table</source>
          <target state="translated">基本プロトコルコマンド AVP テーブル</target>
        </trans-unit>
        <trans-unit id="d9e2287d49a0defabf83f04683cfd099fe9d2461" translate="yes" xml:space="preserve">
          <source>Based on this feature, the OTP application SASL provides a framework for upgrading and downgrading between different versions of an entire release in runtime. This is called &lt;strong&gt;release handling&lt;/strong&gt;.</source>
          <target state="translated">この機能に基づいて、OTPアプリケーションSASLは、実行時にリリース全体の異なるバージョン間でアップグレードおよびダウングレードするためのフレームワークを提供します。これは&lt;strong&gt;リリース処理&lt;/strong&gt;と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="37e7613ad8170257c16610a53d06cfb1a6379742" translate="yes" xml:space="preserve">
          <source>Basic AVP Data Formats</source>
          <target state="translated">基本的なAVPデータ形式</target>
        </trans-unit>
        <trans-unit id="6b9ebfc825400dcd8efd5ccd3ed7166c57bc3280" translate="yes" xml:space="preserve">
          <source>Basic Encoding Rules (BER)</source>
          <target state="translated">基本符号化規則(BER)</target>
        </trans-unit>
        <trans-unit id="20b19d89ef0aed3f2d4f1afed1d3f801c6b85aa5" translate="yes" xml:space="preserve">
          <source>Basic example</source>
          <target state="translated">基本的な例</target>
        </trans-unit>
        <trans-unit id="67d805a220598736617f1f5898d5984c11a47e33" translate="yes" xml:space="preserve">
          <source>Basic functions on Core Erlang abstract syntax trees.</source>
          <target state="translated">Core Erlangの抽象構文木の基本的な関数です。</target>
        </trans-unit>
        <trans-unit id="60289c0d7f3cdae9e1d8eee79fef52de4c163a03" translate="yes" xml:space="preserve">
          <source>Basic knowledge of Emacs and Erlang/OTP.</source>
          <target state="translated">Emacs、Erlang/OTPの基礎知識。</target>
        </trans-unit>
        <trans-unit id="d3e42820dfcf4a655372ec7f0d0863e80c0b502a" translate="yes" xml:space="preserve">
          <source>Basic knowledge of property based testing is assumed in the following. It is also assumed that at least one of the following property based testing tools is installed and available in the library path:</source>
          <target state="translated">以下では、プロパティベースのテストの基礎知識を前提としています。また、以下のプロパティベースのテストツールのうち少なくとも1つがインストールされており、ライブラリパスで利用可能であることを前提としています。</target>
        </trans-unit>
        <trans-unit id="9dd9d44759000b74a8ffb28eb7a9b5d4bda605bf" translate="yes" xml:space="preserve">
          <source>Basic usage consists of creating a representation of a locally implemented Diameter node and its capabilities with &lt;code&gt;&lt;a href=&quot;#start_service-2&quot;&gt;start_service/2&lt;/a&gt;&lt;/code&gt;, adding transport capability using &lt;code&gt;&lt;a href=&quot;#add_transport-2&quot;&gt;add_transport/2&lt;/a&gt;&lt;/code&gt; and sending Diameter requests and receiving Diameter answers with &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt;. Incoming Diameter requests are communicated as callbacks to a &lt;code&gt;diameter_app(3)&lt;/code&gt; callback modules as specified in the service configuration.</source>
          <target state="translated">基本的な使い方は、ローカルに実装されたDiameterノードとその機能の表現を &lt;code&gt;&lt;a href=&quot;#start_service-2&quot;&gt;start_service/2&lt;/a&gt;&lt;/code&gt; で作成し、 &lt;code&gt;&lt;a href=&quot;#add_transport-2&quot;&gt;add_transport/2&lt;/a&gt;&lt;/code&gt; を使用して転送機能を追加し、Diameterリクエストを送信し、 &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt; で Diameter応答を受信することです。着信Diameter要求は、サービス構成で指定されているとおり、 &lt;code&gt;diameter_app(3)&lt;/code&gt; コールバックモジュールへのコールバックとして伝達されます。</target>
        </trans-unit>
        <trans-unit id="d03e3070f8930ea991974fa59117d8692bbcffdd" translate="yes" xml:space="preserve">
          <source>Basically the same as UTF-32, but without some Unicode semantics, defined by IEEE, and has little use as a separate encoding standard. For all normal (and possibly abnormal) use, UTF-32 and UCS-4 are interchangeable.</source>
          <target state="translated">基本的には UTF-32 と同じですが、IEEE で定義された Unicode のセマンティクスを持たず、別個のエンコーディング規格としての用途はほとんどありません。すべての通常の(そしておそらく異常な)使用のために、UTF-32 と UCS-4 は互換性があります。</target>
        </trans-unit>
        <trans-unit id="7299a57060c9f81f94931f5581972334cd31d5c2" translate="yes" xml:space="preserve">
          <source>Basically, the &lt;code&gt;etags&lt;/code&gt; utility is ran using the following form:</source>
          <target state="translated">基本的に、 &lt;code&gt;etags&lt;/code&gt; ユーティリティは次の形式を使用して実行されます。</target>
        </trans-unit>
        <trans-unit id="38c83af4610a697d6724ff3bf3f45adb4124041d" translate="yes" xml:space="preserve">
          <source>Basically, the procedure is as follows:</source>
          <target state="translated">基本的には以下のような手順になります。</target>
        </trans-unit>
        <trans-unit id="0912c94afdbb67bfe98617e8b201d30776d260bb" translate="yes" xml:space="preserve">
          <source>Basics of the ssh protocol's algorithms handling</source>
          <target state="translated">ssh プロトコルのアルゴリズム処理の基本</target>
        </trans-unit>
        <trans-unit id="9c6f5bb2c23fc72e02ed4fe91c08eb86ab7eb097" translate="yes" xml:space="preserve">
          <source>Basics on how computers are programmed</source>
          <target state="translated">コンピュータがどのようにプログラムされているかの基礎</target>
        </trans-unit>
        <trans-unit id="075b61c3bd00c5372d9b40a37e76d0e216819b8e" translate="yes" xml:space="preserve">
          <source>Bassa_Vah</source>
          <target state="translated">Bassa_Vah</target>
        </trans-unit>
        <trans-unit id="8c4b76d47cc4be674049d954ba4923101a8b3e4d" translate="yes" xml:space="preserve">
          <source>Batak</source>
          <target state="translated">Batak</target>
        </trans-unit>
        <trans-unit id="61a2382405e7fcf34f5d81f378bf0ae437ec6326" translate="yes" xml:space="preserve">
          <source>Be Less Aggressive</source>
          <target state="translated">積極的にならない</target>
        </trans-unit>
        <trans-unit id="58c655b2cd5d86487b8917d2d93a7efbac26efff" translate="yes" xml:space="preserve">
          <source>Be aware that &lt;code&gt;enif_schedule_nif&lt;/code&gt;, as its name implies, only schedules the NIF for future execution. The calling NIF does not block waiting for the scheduled NIF to execute and return. This means that the calling NIF cannot expect to receive the scheduled NIF return value and use it for further operations.</source>
          <target state="translated">&lt;code&gt;enif_schedule_nif&lt;/code&gt; は、その名前が示すように、将来の実行のためにNIFのみをスケジュールすることに注意してください。呼び出し側のNIFは、スケジュールされたNIFが実行されて戻るのをブロックしません。つまり、呼び出し側のNIFは、スケジュールされたNIFの戻り値を受け取り、それを以降の操作に使用することはできません。</target>
        </trans-unit>
        <trans-unit id="1bb1d4b8960f0882b546a0b46a0612e449641efb" translate="yes" xml:space="preserve">
          <source>Be careful when setting the shutdown time to &lt;code&gt;infinity&lt;/code&gt; when the child process is a worker. Because, in this situation, the termination of the supervision tree depends on the child process, it must be implemented in a safe way and its cleanup procedure must always return.</source>
          <target state="translated">子プロセスがワーカーの場合、シャットダウン時間を &lt;code&gt;infinity&lt;/code&gt; に設定するときは注意してください。この状況では、監視ツリーの終了は子プロセスに依存するため、安全な方法で実装し、そのクリーンアップ手順を常に返す必要があります。</target>
        </trans-unit>
        <trans-unit id="ffb65a64fc348102ef56127a672718177ad2a7ab" translate="yes" xml:space="preserve">
          <source>Be careful when setting the shutdown time to &lt;code&gt;infinity&lt;/code&gt; when the child process is a worker. Because, in this situation, the termination of the supervision tree depends on the child process; it must be implemented in a safe way and its cleanup procedure must always return.</source>
          <target state="translated">子プロセスがワーカーの場合、シャットダウン時間を &lt;code&gt;infinity&lt;/code&gt; に設定するときは注意してください。この状況では、監視ツリーの終了は子プロセスに依存するためです。安全な方法で実装する必要があり、クリーンアップ手順は常に戻る必要があります。</target>
        </trans-unit>
        <trans-unit id="2fd62499ab8def7b8b69fee274c4b8917538a4e1" translate="yes" xml:space="preserve">
          <source>Be careful with the version header, use &lt;code&gt;ei_x_new_with_version()&lt;/code&gt; when appropriate.</source>
          <target state="translated">バージョンヘッダーに注意して、必要に応じて &lt;code&gt;ei_x_new_with_version()&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="7301ce2a6e0b85e60f35ab88d520e5d9725285df" translate="yes" xml:space="preserve">
          <source>Be started in a way that makes the process fit into a supervision tree</source>
          <target state="translated">監督の木にプロセスをフィットさせる方法で開始される</target>
        </trans-unit>
        <trans-unit id="105320a56b534ace4c0d31c6412a7c5d4168a815" translate="yes" xml:space="preserve">
          <source>Be sure &lt;strong&gt;not&lt;/strong&gt; no name the directory containing the measurement binaries starting with 'megaco-', e.g. megaco-meas. This will confuse the erlang application loader (erlang applications are named, e.g. megaco-1.0.2).</source>
          <target state="translated">megaco-measのように、「megaco-」で始まる測定バイナリを含むディレクトリに名前を付け&lt;strong&gt;ないで&lt;/strong&gt;ください。これはerlangアプリケーションローダーを混乱させます（erlangアプリケーションはmegaco-1.0.2などと命名されます）。</target>
        </trans-unit>
        <trans-unit id="00d0130a026229dfaa52123c4c578740ea2d109c" translate="yes" xml:space="preserve">
          <source>Be sure to read about &lt;code&gt;Long-running NIFs&lt;/code&gt; before writing a NIF.</source>
          <target state="translated">&lt;code&gt;Long-running NIFs&lt;/code&gt; を作成する前に、長期実行NIFについて必ずお読みください。</target>
        </trans-unit>
        <trans-unit id="88f10cc94f264a9568d393b9037d05b81b7daf69" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;-dist_auto_connect&lt;/code&gt; is set to &lt;code&gt;never&lt;/code&gt;, the system will have to manually call &lt;code&gt; net_kernel:connect_node/1&lt;/code&gt; in order to start the distribution. If the distribution channel is closed, when a node uses a dynamic node name, the node will stop the distribution and a new call to &lt;code&gt; net_kernel:connect_node/1&lt;/code&gt; has to be made. Note that the node name may change if the distribution is dropped and then set up again.</source>
          <target state="translated">&lt;code&gt;-dist_auto_connect&lt;/code&gt; が &lt;code&gt;never&lt;/code&gt; に設定されているため、システムは配布を開始するために手動で &lt;code&gt; net_kernel:connect_node/1&lt;/code&gt; を呼び出す必要があります。配布チャネルが閉じている場合、ノードが動的ノード名を使用すると、ノードは配布を停止し、 &lt;code&gt; net_kernel:connect_node/1&lt;/code&gt; への新しい呼び出しを行う必要があります。ディストリビューションを削除してから再設定すると、ノード名が変わる可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="d2edff3a35b65adb5039205d11c2d7f121323a42" translate="yes" xml:space="preserve">
          <source>Because a &lt;code&gt;simple_one_for_one&lt;/code&gt; supervisor can have many children, it shuts them all down asynchronously. This means that the children will do their cleanup in parallel and therefore the order in which they are stopped is not defined.</source>
          <target state="translated">&lt;code&gt;simple_one_for_one&lt;/code&gt; スーパーバイザは多くの子を持つことができるため、それらをすべて非同期でシャットダウンします。これは、子が並行してクリーンアップを行うため、停止される順序が定義されていないことを意味します。</target>
        </trans-unit>
        <trans-unit id="abef4f4009e13039f29fcccf0a57474c315686c1" translate="yes" xml:space="preserve">
          <source>Because lists are commonly used, they have shorthand type notations. The types &lt;code&gt;list(T)&lt;/code&gt; and &lt;code&gt;nonempty_list(T)&lt;/code&gt; have the shorthands &lt;code&gt;[T]&lt;/code&gt; and &lt;code&gt;[T,...]&lt;/code&gt;, respectively. The only difference between the two shorthands is that &lt;code&gt;[T]&lt;/code&gt; can be an empty list but &lt;code&gt;[T,...]&lt;/code&gt; cannot.</source>
          <target state="translated">リストは一般的に使用されるため、短縮形の表記法があります。タイプ &lt;code&gt;list(T)&lt;/code&gt; および &lt;code&gt;nonempty_list(T)&lt;/code&gt; には、それぞれ省略形 &lt;code&gt;[T]&lt;/code&gt; および &lt;code&gt;[T,...]&lt;/code&gt; あります。2つの省略表現の唯一の違いは、 &lt;code&gt;[T]&lt;/code&gt; は空のリストにできるが、 &lt;code&gt;[T,...]&lt;/code&gt; は空にできないことです。</target>
        </trans-unit>
        <trans-unit id="5b3a7dd1ee18a1a87ef5bd7ed89f7551e8ad10ce" translate="yes" xml:space="preserve">
          <source>Because of network and processing delays, the period of tracing is approximate.</source>
          <target state="translated">ネットワークや処理の遅延があるため、トレースの期間はおおよその目安となります。</target>
        </trans-unit>
        <trans-unit id="d37fd4abb225a06f4a6768bb951238ff22bfe669" translate="yes" xml:space="preserve">
          <source>Because of peculiarities in the dynamic loading interfaces on different platforms, the returned string is only guaranteed to describe the correct error &lt;strong&gt;if format_error/1 is called in the same instance of the Erlang virtual machine as the error appeared in&lt;/strong&gt; (meaning the same operating system process).</source>
          <target state="translated">異なるプラットフォームの動的読み込みインターフェイスの特殊性のため&lt;strong&gt;、エラーが発生し&lt;/strong&gt;たのと同じオペレーティングシステムプロセスを意味する&lt;strong&gt;Erlang仮想マシンの同じインスタンスでformat_error / 1が呼び出された場合に&lt;/strong&gt;のみ、返される文字列は正しいエラーを説明することが保証されています）。</target>
        </trans-unit>
        <trans-unit id="2937aec3114f354420a4dc65f7919f8480931c3a" translate="yes" xml:space="preserve">
          <source>Because of subtype relations that exist between types, types form a lattice where the top-most element, &lt;code&gt;any()&lt;/code&gt;, denotes the set of all Erlang terms and the bottom-most element, &lt;code&gt;none()&lt;/code&gt;, denotes the empty set of terms.</source>
          <target state="translated">タイプ間に存在するサブタイプの関係により、タイプはラティスを形成し、最上部の要素 &lt;code&gt;any()&lt;/code&gt; はすべてのErlang用語のセットを示し、最下部の要素 &lt;code&gt;none()&lt;/code&gt; は空の用語セットを示します。</target>
        </trans-unit>
        <trans-unit id="022a498b7c46fc56b49452af050953c22bfbf306" translate="yes" xml:space="preserve">
          <source>Because of the limited length of atoms, it is recommended to use &lt;code&gt;-run&lt;/code&gt; instead.</source>
          <target state="translated">アトムの長さに制限があるため、代わりに &lt;code&gt;-run&lt;/code&gt; を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="1384b995beb9b21c8a759c386f9768bb6e9bf48f" translate="yes" xml:space="preserve">
          <source>Becomes &lt;strong&gt;\h&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;\ hに&lt;/strong&gt;なる&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="299f84debe52036e59ae03120fd4f1dabe601f72" translate="yes" xml:space="preserve">
          <source>Becomes &lt;strong&gt;\p{Ll}&lt;/strong&gt;</source>
          <target state="translated">なる&lt;strong&gt;\ P {}のL1&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4d91b3caacd37fdde510b95d27795a9af6bf8136" translate="yes" xml:space="preserve">
          <source>Becomes &lt;strong&gt;\p{Lu}&lt;/strong&gt;</source>
          <target state="translated">なる&lt;strong&gt;\ P {}のLu&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1c0abdb743817968c55df2e58d08673027964564" translate="yes" xml:space="preserve">
          <source>Becomes &lt;strong&gt;\p{L}&lt;/strong&gt;</source>
          <target state="translated">なる&lt;strong&gt;\ P {L}&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="730c516db3536d87659465b8430f3c06b9b28d02" translate="yes" xml:space="preserve">
          <source>Becomes &lt;strong&gt;\p{Nd}&lt;/strong&gt;</source>
          <target state="translated">なる&lt;strong&gt;\ P {}のNd&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="af6446ff6bb33935f80c0e27353d8c85c94660f6" translate="yes" xml:space="preserve">
          <source>Becomes &lt;strong&gt;\p{Xan}&lt;/strong&gt;</source>
          <target state="translated">なる&lt;strong&gt;\ P {} XAN&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="990d22b3bf8b56b82387696e9e8f32390beb8e0c" translate="yes" xml:space="preserve">
          <source>Becomes &lt;strong&gt;\p{Xps}&lt;/strong&gt;</source>
          <target state="translated">なる&lt;strong&gt;\ P {} XPS&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="89fc848e28a9b477f8a3b6e31d45687e11d42e23" translate="yes" xml:space="preserve">
          <source>Becomes &lt;strong&gt;\p{Xwd}&lt;/strong&gt;</source>
          <target state="translated">なる&lt;strong&gt;\ P {} XWD&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0ebae434cd88ef2302f9bbb202778d21d2e46d19" translate="yes" xml:space="preserve">
          <source>Before ERTS 10.0 (OTP 21.0), monitoring a process could fail with &lt;code&gt;badarg&lt;/code&gt; if the monitored process resided on a primitive node (such as erl_interface or jinterface), where remote process monitoring is not implemented.</source>
          <target state="translated">ERTS 10.0（OTP 21.0）より前のバージョンでは、リモートプロセス監視が実装されていないプリミティブノード（erl_interfaceやjinterfaceなど）に監視対象プロセスが存在すると、プロセスの監視が &lt;code&gt;badarg&lt;/code&gt; で失敗することがありました。</target>
        </trans-unit>
        <trans-unit id="c2170fbb9997cb7343b013f87d0b07f06679bee2" translate="yes" xml:space="preserve">
          <source>Before ERTS 5.9 it was possible to configure a smaller number of thread-specific instances than schedulers. This is, however, not possible anymore.</source>
          <target state="translated">ERTS 5.9以前は、スケジューラよりも少ない数のスレッド固有のインスタンスを設定することが可能でした。しかし、これはもうできません。</target>
        </trans-unit>
        <trans-unit id="60f2fe367a59604d77c1ee7cdc5c0f81f65eda6e" translate="yes" xml:space="preserve">
          <source>Before ERTS 7.0 (Erlang/OTP 18), the return value from &lt;code&gt;enif_make_badarg&lt;/code&gt; had to be returned from the NIF. This requirement is now lifted as the return value from the NIF is ignored if &lt;code&gt;enif_make_badarg&lt;/code&gt; has been invoked.</source>
          <target state="translated">ERTS 7.0（Erlang / OTP 18）より &lt;code&gt;enif_make_badarg&lt;/code&gt; は、enif_make_badargからの戻り値をNIF から返す必要がありました。 &lt;code&gt;enif_make_badarg&lt;/code&gt; が呼び出された場合にNIFからの戻り値が無視されるため、この要件は解除されました。</target>
        </trans-unit>
        <trans-unit id="d8ec3341c03352c2dcbc8cc1ae6efea67d454637" translate="yes" xml:space="preserve">
          <source>Before ERTS 9.0 (OTP-20.0), all resource terms did compare equal to each other and to empty binaries (&lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt;). If serialized, they would be recreated as plain empty binaries.</source>
          <target state="translated">ERTS 9.0（OTP-20.0）より前のバージョンでは、すべてのリソース条件は互いに等しく、空のバイナリ（ &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; ）と同等でした。シリアル化すると、プレーンな空のバイナリとして再作成されます。</target>
        </trans-unit>
        <trans-unit id="f16cc2c8df0cf217a1b01164cd474f9be586865b" translate="yes" xml:space="preserve">
          <source>Before ERTS 9.1 (OTP-20.1) only code points in the range 0-255 was accepted in the string. Now any unicode string is valid.</source>
          <target state="translated">ERTS 9.1 (OTP-20.1)以前は、0-255の範囲のコードポイントのみが文字列として受け入れられていました。現在では、どのようなユニコード文字列も有効です。</target>
        </trans-unit>
        <trans-unit id="b8815a40e2ba0160069e9df632d708ff9fef831a" translate="yes" xml:space="preserve">
          <source>Before Erlang/OTP 17.1, if your test run consisted of multiple tests, cover would be started and stopped for each test within the test run. Separate logs would be available through the &quot;Coverage log&quot; link on the test suite result pages. These links are still available, but now they all point to the same page as the button on the top-level index page. The log contains the accumulated results for the complete test run. For details about this change, see the release notes.</source>
          <target state="translated">Erlang/OTP 17.1以前では、テストランが複数のテストで構成されている場合、テストラン内の各テストごとにカバレッジが開始されたり停止されたりしていました。別々のログはテストスイートの結果ページの &quot;Coverage log &quot;リンクから見ることができます。これらのリンクはまだ利用可能ですが、現在では、トップレベルのインデックスページのボタンと同じページを指しています。ログには、テスト実行全体の累積結果が含まれています。この変更の詳細については、リリースノートを参照してください。</target>
        </trans-unit>
        <trans-unit id="173b9788d3472306f8bca6acb906380d15ebb018" translate="yes" xml:space="preserve">
          <source>Before Erlang/OTP 19, for fields without initial values, the singleton type &lt;code&gt;'undefined'&lt;/code&gt; was added to all declared types. In other words, the following two record declarations had identical effects:</source>
          <target state="translated">Erlang / OTP 19より前は、初期値のないフィールドの場合、シングルトンタイプ &lt;code&gt;'undefined'&lt;/code&gt; がすべての宣言されたタイプに追加されました。つまり、次の2つのレコード宣言は同じ効果がありました。</target>
        </trans-unit>
        <trans-unit id="1ebd17eea52effdc10d3b387a5f97c65de3d711a" translate="yes" xml:space="preserve">
          <source>Before Erlang/OTP R11B (ERTS 5.5) &lt;code&gt;demonitor/1&lt;/code&gt; behaved completely asynchronously, that is, the monitor was active until the &quot;demonitor signal&quot; reached the monitored entity. This had one undesirable effect. You could never know when you were guaranteed &lt;strong&gt;not&lt;/strong&gt; to receive a &lt;code&gt;DOWN&lt;/code&gt; message because of the monitor.</source>
          <target state="translated">Erlang / OTP R11B（ERTS 5.5）より前は、 &lt;code&gt;demonitor/1&lt;/code&gt; は完全に非同期で動作していました。つまり、「demonitor信号」が監視対象エンティティに到達するまで、モニターはアクティブでした。これには、1つの望ましくない影響がありました。モニターが原因で &lt;code&gt;DOWN&lt;/code&gt; メッセージを受信し&lt;strong&gt;ない&lt;/strong&gt;ことが保証されている場合は、決してわかり&lt;strong&gt;ません&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="c04cf745a3c4adfcd300b132adf03ceaef66e4c6" translate="yes" xml:space="preserve">
          <source>Before Erlang/OTP R11B (ERTS 5.5) &lt;code&gt;unlink/1&lt;/code&gt; behaved completely asynchronously, that is, the link was active until the &quot;unlink signal&quot; reached the linked entity. This had an undesirable effect, as you could never know when you were guaranteed &lt;strong&gt;not&lt;/strong&gt; to be effected by the link.</source>
          <target state="translated">Erlang / OTP R11B（ERTS 5.5）より前は、 &lt;code&gt;unlink/1&lt;/code&gt; は完全に非同期で動作していました。つまり、「リンク解除信号」がリンクされたエンティティに到達するまでリンクはアクティブでした。リンクの影響を受け&lt;strong&gt;ない&lt;/strong&gt;ことが保証されている時期を知ることができなかったため、これには望ましくない影響がありました。</target>
        </trans-unit>
        <trans-unit id="14149394b7877b033496395cfd6e420c1de55bda" translate="yes" xml:space="preserve">
          <source>Before Erlang/OTP R16, the port ID could be used as a key with proper casting, but after the rewrite of the port subsystem, this is no longer the case. With this function, you can achieve the same distribution based on port IDs as before Erlang/OTP R16.</source>
          <target state="translated">Erlang/OTP R16以前はポートIDを適切なキャストでキーとして使うことができましたが、ポートサブシステムが書き換えられてからはそうではなくなりました。この機能を使えば、Erlang/OTP R16以前と同じようにポートIDに基づいたディストリビューションを実現できます。</target>
        </trans-unit>
        <trans-unit id="055828a24a30444b0c0047933c2db837ba4b5188" translate="yes" xml:space="preserve">
          <source>Before Linux 3.8, this socket option could be set, but could not retrieved with &lt;code&gt;&lt;a href=&quot;#getopts-2&quot;&gt;getopts/2&lt;/a&gt;&lt;/code&gt;. Since Linux 3.8, it is readable.</source>
          <target state="translated">Linux 3.8より前のバージョンでは、このソケットオプションを設定できましたが、 &lt;code&gt;&lt;a href=&quot;#getopts-2&quot;&gt;getopts/2&lt;/a&gt;&lt;/code&gt; では取得できませんでした。Linux 3.8以降では、読みやすいです。</target>
        </trans-unit>
        <trans-unit id="6730ee065030a00d88c78657469d331d9b0d4526" translate="yes" xml:space="preserve">
          <source>Before Linux 3.8, this socket option could be set, but not get. Only works for some socket types (e.g. &lt;code&gt;inet&lt;/code&gt;). If empty value is set, the binding is removed.</source>
          <target state="translated">Linux 3.8より前では、このソケットオプションは設定できましたが、取得できませんでした。一部のソケットタイプ（ &lt;code&gt;inet&lt;/code&gt; など）でのみ機能します。空の値が設定されている場合、バインディングは削除されます。</target>
        </trans-unit>
        <trans-unit id="de814773d3f4ef3f2f57f8421829e0616b1e21de" translate="yes" xml:space="preserve">
          <source>Before OTP 19, if the &lt;code&gt;on_load&lt;/code&gt; function failed, any previously current code would become old, essentially leaving the system without any working and reachable instance of the module. That problem has been eliminated in OTP 19.</source>
          <target state="translated">OTP 19より前は、 &lt;code&gt;on_load&lt;/code&gt; 関数が失敗した場合、以前の現在のコードは古くなり、本質的には、モジュールの機能している、到達可能なモジュールのないシステムが残ります。この問題はOTP 19で解消されました。</target>
        </trans-unit>
        <trans-unit id="4a26f53b8fd124a2195afd74e62b113f37b0fb17" translate="yes" xml:space="preserve">
          <source>Before OTP 22, the option &lt;code&gt;{nowarn_deprecated_function, MFAs}&lt;/code&gt; was only recognized when given in the file with attribute &lt;code&gt;-compile()&lt;/code&gt;. (The option &lt;code&gt;{nowarn_unused_function,FAs}&lt;/code&gt; was incorrectly documented to only work in a file, but it also worked when given in the option list.) Starting from OTP 22, all options that can be given in the file can also be given in the option list.</source>
          <target state="translated">OTP 22より前は、オプション &lt;code&gt;{nowarn_deprecated_function, MFAs}&lt;/code&gt; は、属性 &lt;code&gt;-compile()&lt;/code&gt; を持つファイルで指定された場合にのみ認識されていました。（オプション &lt;code&gt;{nowarn_unused_function,FAs}&lt;/code&gt; は、ファイルでのみ機能するように誤って文書化されていましたが、オプションリストで指定された場合にも機能しました。）OTP 22以降、ファイルで指定できるすべてのオプションは、オプションリスト。</target>
        </trans-unit>
        <trans-unit id="ac6280bf5d40e1ad7fd5221aeb6433bc3d21c56c" translate="yes" xml:space="preserve">
          <source>Before OTP 23, &lt;code&gt;Size&lt;/code&gt; was restricted to be an integer or a variable bound to an integer.</source>
          <target state="translated">OTP 23より前は、 &lt;code&gt;Size&lt;/code&gt; は整数または整数にバインドされた変数に制限されていました。</target>
        </trans-unit>
        <trans-unit id="f89094b9481b9b8c9439e6748d4ddfcd926381b9" translate="yes" xml:space="preserve">
          <source>Before OTP 23, the expression defining the key &lt;code&gt;K&lt;/code&gt; was restricted to be either a single variable or a literal.</source>
          <target state="translated">OTP 23より前は、キー &lt;code&gt;K&lt;/code&gt; を定義する式は、単一の変数またはリテラルのいずれかに制限されていました。</target>
        </trans-unit>
        <trans-unit id="0463b80fdbddc48ab1e8bca76239196573ee534f" translate="yes" xml:space="preserve">
          <source>Before OTP R14A (ERTS version 5.8), an implicitly qualified function call to a function having the same name as an auto-imported BIF always resulted in the BIF being called. In newer versions of the compiler, the local function is called instead. This is to avoid that future additions to the set of auto-imported BIFs do not silently change the behavior of old code.</source>
          <target state="translated">OTP R14A (ERTS バージョン 5.8)より前のバージョンでは、自動インポートされた BIF と同じ名前の関数を暗黙的に修飾して呼び出すと、常に BIF が呼び出されます。新しいバージョンのコンパイラでは、代わりにローカル関数が呼び出されます。これは、将来的に自動インポートされたBIFのセットに追加されても、古いコードの動作が黙って変更されないようにするためです。</target>
        </trans-unit>
        <trans-unit id="e9407c86312dec72e66a3d1afa8b0f111f642f45" translate="yes" xml:space="preserve">
          <source>Before OTP R16 when an Erlang code module was loaded, all other execution in the VM were halted while the load operation was carried out in single threaded mode. This might not be a big problem for initial loading of modules during VM boot, but it can be a severe problem for availability when upgrading modules or adding new code on a VM with running payload. This problem grows with the number of cores as both the time it takes to wait for all schedulers to stop increases as well as the potential amount of halted ongoing work.</source>
          <target state="translated">OTP R16より前のバージョンでは、Erlangコードモジュールがロードされると、VM内の他のすべての実行が停止し、ロード操作はシングルスレッドモードで行われていました。これはVMの起動時にモジュールを最初にロードするときには大きな問題ではないかもしれませんが、モジュールをアップグレードしたり、ペイロードを実行しているVMに新しいコードを追加したりするときには、可用性の面で深刻な問題になることがあります。この問題は、すべてのスケジューラが停止するのを待つ時間が長くなるだけでなく、進行中の作業が中断される可能性もあるため、コア数が増えるにつれて大きくなっていきます。</target>
        </trans-unit>
        <trans-unit id="4e13a53367593b9c5d185550d151836210a12440" translate="yes" xml:space="preserve">
          <source>Before OTP R16 when trace settings were changed by &lt;code&gt;erlang:trace_pattern&lt;/code&gt;, all other execution in the VM were halted while the trace operation was carried out in single threaded mode. Similar to code loading, this can impose a severe problem for availability that grows with the number of cores.</source>
          <target state="translated">トレース設定が &lt;code&gt;erlang:trace_pattern&lt;/code&gt; によって変更されたOTP R16より前は、トレース操作がシングルスレッドモードで実行されている間、VM内の他のすべての実行が停止されていました。コードの読み込みと同様に、これはコアの数とともに増大する可用性に深刻な問題を課す可能性があります。</target>
        </trans-unit>
        <trans-unit id="83f7f3432428a2eb46f419c68c366cf2370764d0" translate="yes" xml:space="preserve">
          <source>Before OTP-17.4 the search algorithm had a problem as the search always started at the same position in the pool, the sentinel. This could lead to contention from concurrent searching processes. But even worse, it could lead to a &quot;bad&quot; state when searches fail with a high rate leading to new carriers instead being allocated. These new carriers may later be inserted into the pool due to bad utilization. If the frequency of insertions into the pool is higher than successful fetching from the pool, memory will eventually get exhausted.</source>
          <target state="translated">OTP-17.4以前の検索アルゴリズムには、プール内の同じ位置(センチネル)から検索を開始するという問題がありました。これは、同時進行の検索プロセスによる競合につながる可能性がありました。しかし、さらに悪いことに、検索が高い確率で失敗し、代わりに新しいキャリアが割り当てられるという「悪い」状態になる可能性があります。これらの新しいキャリアは、利用率が悪いために、後でプールに挿入される可能性があります。プールへの挿入の頻度が、プールからのフェッチに成功した頻度よりも高い場合、メモリは最終的に枯渇してしまいます。</target>
        </trans-unit>
        <trans-unit id="a6244bef3fa35080f6be664c665752e7ae747946" translate="yes" xml:space="preserve">
          <source>Before OTP-23 the user &lt;strong&gt;needed&lt;/strong&gt; to supply a valid &lt;code&gt;-sname&lt;/code&gt; or &lt;code&gt;-name&lt;/code&gt; for &lt;code&gt;-remsh&lt;/code&gt; to work. This is still the case if the target node is not running OTP-23 or later.</source>
          <target state="translated">OTP-23の前にユーザー&lt;strong&gt;に必要な&lt;/strong&gt;有効供給する &lt;code&gt;-sname&lt;/code&gt; または &lt;code&gt;-name&lt;/code&gt; ため &lt;code&gt;-remsh&lt;/code&gt; を仕事に。これは、ターゲットノードがOTP-23以降を実行していない場合でも当てはまります。</target>
        </trans-unit>
        <trans-unit id="b947a51569cc1cfaeef7b7ff4bf48e678a02c245" translate="yes" xml:space="preserve">
          <source>Before R14, parentheses were needed as follows:</source>
          <target state="translated">R14以前は以下のようにカッコが必要でした。</target>
        </trans-unit>
        <trans-unit id="2556eabbc9f968558043782e1fcdc348f5df35c3" translate="yes" xml:space="preserve">
          <source>Before STDLIB 3.4 (OTP 20.0) compiled match specifications did not have an external representation. If passed through &lt;code&gt;binary_to_term(term_to_binary(CMS))&lt;/code&gt; or sent to another node and back, the result was always an empty binary &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">STDLIB 3.4（OTP 20.0）より前は、コンパイルされた一致仕様には外部表現がありませんでした。 &lt;code&gt;binary_to_term(term_to_binary(CMS))&lt;/code&gt; を通過するか、別のノードに送信されて返される場合、結果は常に空のバイナリ &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; でした。</target>
        </trans-unit>
        <trans-unit id="787dfaa6bed7bb38d94c61fd72dc85362aa99313" translate="yes" xml:space="preserve">
          <source>Before a driver can be called from Erlang, it must be loaded and opened. Loading is done using the &lt;code&gt;erl_ddll&lt;/code&gt; module (the &lt;code&gt;erl_ddll&lt;/code&gt; driver that loads dynamic driver is actually a driver itself). If loading is successful, the port can be opened with &lt;code&gt;open_port/2&lt;/code&gt;. The port name must match the name of the shared library and the name in the driver entry structure.</source>
          <target state="translated">Erlangからドライバーを呼び出す前に、ドライバーをロードして開く必要があります。ロードは &lt;code&gt;erl_ddll&lt;/code&gt; モジュールを使用して行われます（動的ドライバーをロードする &lt;code&gt;erl_ddll&lt;/code&gt; ドライバーは実際にはドライバー自体です）。ロードが成功した場合、ポートは &lt;code&gt;open_port/2&lt;/code&gt; で開くことができます。ポート名は、共有ライブラリの名前およびドライバエントリ構造の名前と一致する必要があります。</target>
        </trans-unit>
        <trans-unit id="777f496c9fcf95c8a759b97ce9f5b072f83c3c75" translate="yes" xml:space="preserve">
          <source>Before a driver can be called from Erlang, it must be loaded and opened. Loading is done using the &lt;code&gt;erl_ddll&lt;/code&gt; module (the &lt;code&gt;erl_ddll&lt;/code&gt; driver that loads dynamic driver is actually a driver itself). If loading is successfull, the port can be opened with &lt;code&gt;open_port/2&lt;/code&gt;. The port name must match the name of the shared library and the name in the driver entry structure.</source>
          <target state="translated">Erlangからドライバーを呼び出す前に、ドライバーをロードして開く必要があります。ロードは、 &lt;code&gt;erl_ddll&lt;/code&gt; モジュールを使用して行われます（動的ドライバーをロードする &lt;code&gt;erl_ddll&lt;/code&gt; ドライバーは、実際にはドライバー自体です）。ロードが成功した場合、ポートは &lt;code&gt;open_port/2&lt;/code&gt; で開くことができます。ポート名は、共有ライブラリの名前およびドライバエントリ構造の名前と一致する必要があります。</target>
        </trans-unit>
        <trans-unit id="20019fdf1abe6fd7869945f2f7dac92f9f72ebdc" translate="yes" xml:space="preserve">
          <source>Before a file is transferred, the following call is made to indicate the start of the file transfer and how large the file is. The return value of the callback function is to be a new value for the &lt;code&gt;UserProgressTerm&lt;/code&gt; that will be used as input the next time the callback function is called.</source>
          <target state="translated">ファイルが転送される前に、次の呼び出しが行われ、ファイル転送の開始とファイルのサイズが示されます。コールバック関数の戻り値は、次にコールバック関数が呼び出されるときに入力として使用される &lt;code&gt;UserProgressTerm&lt;/code&gt; の新しい値になります。</target>
        </trans-unit>
        <trans-unit id="159e2277de857354c36db29ad08f2c463be464e2" translate="yes" xml:space="preserve">
          <source>Before an application can be started, it must be &lt;strong&gt;loaded&lt;/strong&gt;. The application controller reads and stores the information from the &lt;code&gt;.app&lt;/code&gt; file:</source>
          <target state="translated">アプリケーションを開始する前に、&lt;strong&gt;ロード&lt;/strong&gt;する必要があります。アプリケーションコントローラーは、 &lt;code&gt;.app&lt;/code&gt; ファイルから情報を読み取り、保存します。</target>
        </trans-unit>
        <trans-unit id="afd284c8bc9adc5dd4975944173af35c38112da6" translate="yes" xml:space="preserve">
          <source>Before an application makes its first access to a table, &lt;code&gt;&lt;a href=&quot;mnesia#wait_for_tables-2&quot;&gt;mnesia:wait_for_tables(TabList, Timeout)&lt;/a&gt;&lt;/code&gt; is to be executed to ensure that the table is accessible from the local node. If the function times out, the application can choose to force a load of the local replica with &lt;code&gt;&lt;a href=&quot;mnesia#force_load_table-1&quot;&gt;mnesia:force_load_table(Tab)&lt;/a&gt;&lt;/code&gt; and deliberately lose all updates that can have been performed on the other nodes while the local node was down. If &lt;code&gt;Mnesia&lt;/code&gt; has loaded the table on another node already, or intends to do so, copy the table from that node to avoid unnecessary inconsistency.</source>
          <target state="translated">アプリケーションがテーブルに最初にアクセスする前に、 &lt;code&gt;&lt;a href=&quot;mnesia#wait_for_tables-2&quot;&gt;mnesia:wait_for_tables(TabList, Timeout)&lt;/a&gt;&lt;/code&gt; を実行して、ローカルノードからテーブルにアクセスできることを確認します。関数がタイムアウトした場合、アプリケーションは &lt;code&gt;&lt;a href=&quot;mnesia#force_load_table-1&quot;&gt;mnesia:force_load_table(Tab)&lt;/a&gt;&lt;/code&gt; を使用してローカルレプリカを強制的にロードすることを選択でき、ローカルノードがダウンしている間に他のノードで実行された可能性があるすべての更新を故意に失います。 &lt;code&gt;Mnesia&lt;/code&gt; がすでに別のノードにテーブルをロードしている場合、またはロードする予定がある場合は、そのノードからテーブルをコピーして、不必要な不整合を回避します。</target>
        </trans-unit>
        <trans-unit id="75a2137a0d589f3ac4ee86651537916f812a4998" translate="yes" xml:space="preserve">
          <source>Before any analysis can take place, module data must be &lt;strong&gt;set up&lt;/strong&gt;. For instance, the cross reference and the unknown functions are computed when all module data are known. The functions that need complete data (&lt;code&gt;analyze&lt;/code&gt;, &lt;code&gt;q&lt;/code&gt;, &lt;code&gt;variables&lt;/code&gt;) take care of setting up data automatically. Module data need to be set up (again) after calls to any of the &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;replace&lt;/code&gt;, &lt;code&gt;remove&lt;/code&gt;, &lt;code&gt;set_library_path&lt;/code&gt; or &lt;code&gt;update&lt;/code&gt; functions.</source>
          <target state="translated">分析を行う前に、モジュールデータを&lt;strong&gt;設定する&lt;/strong&gt;必要があります。たとえば、すべてのモジュールデータが既知の場合、相互参照と未知の関数が計算されます。完全なデータを必要とする関数（ &lt;code&gt;analyze&lt;/code&gt; 、 &lt;code&gt;q&lt;/code&gt; 、 &lt;code&gt;variables&lt;/code&gt; ）は、データを自動的に設定します。 &lt;code&gt;add&lt;/code&gt; 、 &lt;code&gt;replace&lt;/code&gt; 、 &lt;code&gt;remove&lt;/code&gt; 、 &lt;code&gt;set_library_path&lt;/code&gt; 、または &lt;code&gt;update&lt;/code&gt; 関数のいずれかを呼び出した後、モジュールデータを（再度）設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="ca67bda82873ef4332d857192e18635d990609ed" translate="yes" xml:space="preserve">
          <source>Before any analysis can take place, the involved modules must be &lt;strong&gt;Cover compiled&lt;/strong&gt;. This means that some extra information is added to the module before it is compiled into a binary which then is &lt;code&gt;&lt;a href=&quot;#loading&quot;&gt;loaded&lt;/a&gt;&lt;/code&gt;. The source file of the module is not affected and no &lt;code&gt;.beam&lt;/code&gt; file is created.</source>
          <target state="translated">分析を行う前に、関連するモジュールを&lt;strong&gt;カバーコンパイルする&lt;/strong&gt;必要があります。これは、モジュールがバイナリにコンパイルされて &lt;code&gt;&lt;a href=&quot;#loading&quot;&gt;loaded&lt;/a&gt;&lt;/code&gt; される前に、モジュールに追加情報が追加されることを意味します。モジュールのソースファイルは影響を受けず、 &lt;code&gt;.beam&lt;/code&gt; ファイルは作成されません。</target>
        </trans-unit>
        <trans-unit id="258fe4cd782832c98fba1da0a69f9a8b68aa3908" translate="yes" xml:space="preserve">
          <source>Before any analysis can take place, the involved modules must be &lt;strong&gt;Cover compiled&lt;/strong&gt;. This means that some extra information is added to the module before it is compiled into a binary which then is loaded. The source file of the module is not affected and no &lt;code&gt;.beam&lt;/code&gt; file is created.</source>
          <target state="translated">分析を行う前に、関連するモジュールを&lt;strong&gt;カバーコンパイルする&lt;/strong&gt;必要があります。これは、モジュールがバイナリにコンパイルされてロードされる前に、モジュールに追加情報が追加されることを意味します。モジュールのソースファイルは影響を受けず、 &lt;code&gt;.beam&lt;/code&gt; ファイルは作成されません。</target>
        </trans-unit>
        <trans-unit id="451eac2b19829254921c8ba2920439b2b92145f5" translate="yes" xml:space="preserve">
          <source>Before applying a patch you need to do a &lt;strong&gt;full&lt;/strong&gt; build of OTP in the source directory.</source>
          <target state="translated">パッチを適用する前に、あなたが行う必要があり&lt;strong&gt;、完全な&lt;/strong&gt;ソースディレクトリにOTPのビルドを。</target>
        </trans-unit>
        <trans-unit id="0af32825676162dfe9c05e6f703b3efa51985180" translate="yes" xml:space="preserve">
          <source>Before asking a question you can browse the &lt;a href=&quot;http://www.erlang.org/pipermail/erlang-questions/&quot;&gt; mailing list archive&lt;/a&gt; and read the &lt;a href=&quot;http://www.erlang.org/faq/faq.html&quot;&gt;Frequently Asked Questions&lt;/a&gt;.</source>
          <target state="translated">質問する前に、&lt;a href=&quot;http://www.erlang.org/pipermail/erlang-questions/&quot;&gt;メーリングリストのアーカイブ&lt;/a&gt;を閲覧して、&lt;a href=&quot;http://www.erlang.org/faq/faq.html&quot;&gt;よくある質問&lt;/a&gt;を読むことができます。</target>
        </trans-unit>
        <trans-unit id="cda5c6edb9898f9347103f74f622c57ddde1c654" translate="yes" xml:space="preserve">
          <source>Before calling any of the other &lt;code&gt;Erl_Interface&lt;/code&gt; functions, call &lt;code&gt;erl_init()&lt;/code&gt; exactly once to initialize the library. &lt;code&gt;erl_init()&lt;/code&gt; takes two arguments. However, the arguments are no longer used by &lt;code&gt;Erl_Interface&lt;/code&gt; and are therefore to be specified as &lt;code&gt;erl_init(NULL,0)&lt;/code&gt;.</source>
          <target state="translated">他の &lt;code&gt;Erl_Interface&lt;/code&gt; 関数を呼び出す &lt;code&gt;erl_init()&lt;/code&gt; 、erl_init（）を 1回だけ呼び出してライブラリを初期化します。 &lt;code&gt;erl_init()&lt;/code&gt; は2つの引数を取ります。ただし、引数は &lt;code&gt;Erl_Interface&lt;/code&gt; で使用されなくなったため、 &lt;code&gt;erl_init(NULL,0)&lt;/code&gt; として指定されます。</target>
        </trans-unit>
        <trans-unit id="258c449a5777b1e0308a8597c71acd1f65986e67" translate="yes" xml:space="preserve">
          <source>Before calling any of the other functions in the library, initialize it by calling &lt;code&gt;ei_init()&lt;/code&gt; exactly once.</source>
          <target state="translated">ライブラリ内の他の関数を呼び出す前に、 &lt;code&gt;ei_init()&lt;/code&gt; を1回だけ呼び出して初期化します。</target>
        </trans-unit>
        <trans-unit id="5913933d73f661127a755638c745adee88554860" translate="yes" xml:space="preserve">
          <source>Before calling any other function in Erl_Interface, the memory handling must be initiated:</source>
          <target state="translated">Erl_Interface の他の関数を呼び出す前に、メモリ処理を開始しなければなりません。</target>
        </trans-unit>
        <trans-unit id="c91078fc982ffe0902391841ac4ff114e2a4c572" translate="yes" xml:space="preserve">
          <source>Before execution of a group begins, the configuration function &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_group-2&quot;&gt;init_per_group(GroupName, Config)&lt;/a&gt;&lt;/code&gt; is called. The list of tuples returned from this function is passed to the test cases in the usual manner by argument &lt;code&gt;Config&lt;/code&gt;. &lt;code&gt;init_per_group/2&lt;/code&gt; is meant to be used for initializations common for the test cases in the group. After execution of the group is finished, function &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_group-2&quot;&gt;end_per_group(GroupName, Config)&lt;/a&gt;&lt;/code&gt; is called. This function is meant to be used for cleaning up after &lt;code&gt;init_per_group/2&lt;/code&gt;. If the init function is defined, so must the end function be.</source>
          <target state="translated">グループの実行が始まる前に、構成関数 &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_group-2&quot;&gt;init_per_group(GroupName, Config)&lt;/a&gt;&lt;/code&gt; が呼び出されます。この関数から返されるタプルのリストは、引数 &lt;code&gt;Config&lt;/code&gt; によって通常の方法でテストケースに渡されます。 &lt;code&gt;init_per_group/2&lt;/code&gt; は、グループ内のテストケースに共通する初期化に使用するためのものです。グループの実行が終了すると、関数 &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_group-2&quot;&gt;end_per_group(GroupName, Config)&lt;/a&gt;&lt;/code&gt; が呼び出されます。この関数は、 &lt;code&gt;init_per_group/2&lt;/code&gt; の後のクリーンアップに使用するためのものです。 init関数が定義されている場合、end関数も定義されている必要があります。</target>
        </trans-unit>
        <trans-unit id="742d99c38a98962fb67614d643aed1075c662a8f" translate="yes" xml:space="preserve">
          <source>Before execution of a group begins, the configuration function &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_group-2&quot;&gt;init_per_group(GroupName, Config)&lt;/a&gt;&lt;/code&gt; is called. The list of tuples returned from this function is passed to the test cases in the usual manner by argument &lt;code&gt;Config&lt;/code&gt;. &lt;code&gt;init_per_group/2&lt;/code&gt; is meant to be used for initializations common for the test cases in the group. After execution of the group is finished, function &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_group-2&quot;&gt;end_per_group(GroupName, Config)&lt;/a&gt;&lt;/code&gt; is called. This function is meant to be used for cleaning up after &lt;code&gt;init_per_group/2&lt;/code&gt;. If the init function is defined, so must the end function be.</source>
          <target state="translated">グループの実行が開始される前に、構成関数 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_group-2&quot;&gt;init_per_group(GroupName, Config)&lt;/a&gt;&lt;/code&gt; が呼び出されます。この関数から返されるタプルのリストは、引数 &lt;code&gt;Config&lt;/code&gt; によって通常の方法でテストケースに渡されます。 &lt;code&gt;init_per_group/2&lt;/code&gt; は、グループ内のテストケースに共通の初期化に使用することを目的としています。グループの実行が終了すると、関数 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_group-2&quot;&gt;end_per_group(GroupName, Config)&lt;/a&gt;&lt;/code&gt; が呼び出されます。この関数は、 &lt;code&gt;init_per_group/2&lt;/code&gt; の後のクリーンアップに使用することを目的としています。init関数が定義されている場合は、end関数も定義されている必要があります。</target>
        </trans-unit>
        <trans-unit id="dfe638852bde7e76a1e9584d5c09fb0ca66d3651" translate="yes" xml:space="preserve">
          <source>Before execution of the timetrap function (which is performed on a parallel, dedicated timetrap process), &lt;code&gt;Common Test&lt;/code&gt; cancels any previously set timer for the test case or configuration function. When the timetrap function returns, the time-out is triggered, &lt;strong&gt;unless&lt;/strong&gt; the return value is a valid timetrap time, such as an integer, or a &lt;code&gt;{SecMinOrHourTag,Time}&lt;/code&gt; tuple (for details, see module &lt;code&gt;&lt;a href=&quot;common_test&quot;&gt;common_test&lt;/a&gt;&lt;/code&gt;). If a time value is returned, a new timetrap is started to generate a time-out after the specified time.</source>
          <target state="translated">タイムトラップ機能（並列の専用タイムトラッププロセスで実行される）を実行する前に、 &lt;code&gt;Common Test&lt;/code&gt; は、テストケースまたは構成機能に対して以前に設定されたタイマーをキャンセルします。タイムトラップ関数が戻ると、戻り値が整数などの有効なタイムトラップ時間または &lt;code&gt;{SecMinOrHourTag,Time}&lt;/code&gt; タプル（詳細については、モジュール &lt;code&gt;&lt;a href=&quot;common_test&quot;&gt;common_test&lt;/a&gt;&lt;/code&gt; を参照）で&lt;strong&gt;ない限り&lt;/strong&gt;、タイムアウトがトリガーされます。時間値が返されると、新しいタイムトラップが開始され、指定された時間後にタイムアウトが生成されます。</target>
        </trans-unit>
        <trans-unit id="08b1254c8bec1bc486b54b5a55646cb74814353f" translate="yes" xml:space="preserve">
          <source>Before going into details of the supervision and error handling in an Erlang system, let us see how Erlang processes terminate, or in Erlang terminology, &lt;strong&gt;exit&lt;/strong&gt;.</source>
          <target state="translated">Erlangシステムでの監視とエラー処理の詳細に入る前に、Erlangプロセスがどのように終了するか、またはErlangの用語で&lt;strong&gt;exitを&lt;/strong&gt;見てみましょう。</target>
        </trans-unit>
        <trans-unit id="158d175d6b77bf980038361a2e334b0ed9a4b8fc" translate="yes" xml:space="preserve">
          <source>Before improving the messenger program, let us look at some general principles, using the ping pong program as an example. Recall that when &quot;ping&quot; finishes, it tells &quot;pong&quot; that it has done so by sending the atom &lt;code&gt;finished&lt;/code&gt; as a message to &quot;pong&quot; so that &quot;pong&quot; can also finish. Another way to let &quot;pong&quot; finish is to make &quot;pong&quot; exit if it does not receive a message from ping within a certain time. This can be done by adding a &lt;strong&gt;time-out&lt;/strong&gt; to &lt;code&gt;pong&lt;/code&gt; as shown in the following example:</source>
          <target state="translated">メッセンジャープログラムを改善する前に、ピンポンプログラムを例にして、いくつかの一般的な原則を見てみましょう。 「ping」が終了すると、「pong」にもメッセージが表示され、「pong」も終了できるように、 &lt;code&gt;finished&lt;/code&gt; したアトムを「pong」に送信することで「ping」が終了したことを思い出してください。 「ポン」を終了させる別の方法は、一定の時間内にpingからメッセージを受信しない場合に「ポン」を終了させることです。これは、次の例に示すように、&lt;strong&gt;タイムアウト&lt;/strong&gt;を &lt;code&gt;pong&lt;/code&gt; 追加することで実行できます。</target>
        </trans-unit>
        <trans-unit id="5d0240a960734bd032bfb25f877be3ed95c27ca3" translate="yes" xml:space="preserve">
          <source>Before installation you should test whether your build is working properly by running our smoke test. The smoke test is a subset of the complete Erlang/OTP test suites. First you will need to build and release the test suites.</source>
          <target state="translated">インストールする前に、あなたのビルドが正しく動作するかどうかをスモークテストを実行してテストしてください。スモークテストは完全なErlang/OTPテストスイートのサブセットです。最初にテストスイートをビルドしてリリースする必要があります。</target>
        </trans-unit>
        <trans-unit id="f9b6bb02452d70c4cea213f1df9be77d0db03bc1" translate="yes" xml:space="preserve">
          <source>Before looking at how this program works, notice that a few comments are added to the code. A comment starts with a %-character and goes on to the end of the line. Notice also that the &lt;code&gt;-export([format_temps/1]).&lt;/code&gt; line only includes the function &lt;code&gt;format_temps/1&lt;/code&gt;. The other functions are &lt;strong&gt;local&lt;/strong&gt; functions, that is, they are not visible from outside the module &lt;code&gt;tut5&lt;/code&gt;.</source>
          <target state="translated">このプログラムの動作を確認する前に、いくつかのコメントがコードに追加されていることに注意してください。コメントは％文字で始まり、行の終わりまで続きます。 &lt;code&gt;-export([format_temps/1]).&lt;/code&gt; も注意してください。行には、関数 &lt;code&gt;format_temps/1&lt;/code&gt; のみが含まれています。その他の関数は&lt;strong&gt;ローカル&lt;/strong&gt;関数 &lt;code&gt;tut5&lt;/code&gt; 。つまり、モジュールtut5の外部からは見えません。</target>
        </trans-unit>
        <trans-unit id="12bcc79844186de606633bdd333ae924acec0daf" translate="yes" xml:space="preserve">
          <source>Before registering a name, you should already have registered your port number with &lt;code&gt;epmd&lt;/code&gt;. This is not strictly necessary, but if you neglect to do so, then other nodes wishing to communicate with your service cannot find or connect to your process.</source>
          <target state="translated">名前を登録する前に、ポート番号を &lt;code&gt;epmd&lt;/code&gt; に登録しておく必要があります。これは厳密には必要ありませんが、これを怠ると、サービスとの通信を希望する他のノードがプロセスを検出または接続できなくなります。</target>
        </trans-unit>
        <trans-unit id="26cb26b93d1388560e328aa535c6bbe4b5f0b51c" translate="yes" xml:space="preserve">
          <source>Before registering with &lt;code&gt;epmd&lt;/code&gt;, you must first create a listen socket and bind it to a port. Then:</source>
          <target state="translated">&lt;code&gt;epmd&lt;/code&gt; に登録する前に、まず待機ソケットを作成し、それをポートにバインドする必要があります。次に：</target>
        </trans-unit>
        <trans-unit id="9c7e0e1b9fcac24580ab6b3d03b6e4b55f4c8972" translate="yes" xml:space="preserve">
          <source>Before starting &lt;code&gt;Mnesia&lt;/code&gt;, the following must be done:</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; を開始する前に、次のことを行う必要があります。</target>
        </trans-unit>
        <trans-unit id="7a519a0020d8de31b673de93ded06a0618f853d2" translate="yes" xml:space="preserve">
          <source>Before starting, notice the following:</source>
          <target state="translated">始める前に、次のことに気づく。</target>
        </trans-unit>
        <trans-unit id="7011eaabfad589a3868b28c469ad42e5d05beb89" translate="yes" xml:space="preserve">
          <source>Before the call of &lt;code&gt;deflateParams&lt;/code&gt;, the stream state must be set as for a call of &lt;code&gt;deflate/3&lt;/code&gt;, as the currently available input may have to be compressed and flushed.</source>
          <target state="translated">現在使用可能な入力を圧縮してフラッシュする必要がある場合があるため、 &lt;code&gt;deflateParams&lt;/code&gt; を呼び出す前に、 &lt;code&gt;deflate/3&lt;/code&gt; の呼び出しと同様にストリームの状態を設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="78fa7e00043ebdf38881948abf63f1275524f7cf" translate="yes" xml:space="preserve">
          <source>Before the first call to &lt;code&gt;allow/1&lt;/code&gt;, any node with the correct cookie can be connected. When &lt;code&gt;allow/1&lt;/code&gt; is called, a list of allowed nodes is established. Any access attempts made from (or to) nodes not in that list will be rejected.</source>
          <target state="translated">&lt;code&gt;allow/1&lt;/code&gt; への最初の呼び出しの前に、正しいCookieを持つ任意のノードを接続できます。ときに &lt;code&gt;allow/1&lt;/code&gt; 呼ばれ、許可されたノードのリストが確立されています。そのリストにないノードからの（またはノードへの）アクセス試行はすべて拒否されます。</target>
        </trans-unit>
        <trans-unit id="dc3113c94757b2848bc9b3cfac6670102a406895" translate="yes" xml:space="preserve">
          <source>Before the log is dumped, the file &lt;code&gt;LATEST.LOG&lt;/code&gt; is renamed to &lt;code&gt;PREVIOUS.LOG&lt;/code&gt;, and a new &lt;code&gt;LATEST.LOG&lt;/code&gt; file is created. Once the log has been successfully dumped, the file &lt;code&gt;PREVIOUS.LOG&lt;/code&gt; is deleted.</source>
          <target state="translated">ログをダンプする前に、ファイル &lt;code&gt;LATEST.LOG&lt;/code&gt; が名前に変更され &lt;code&gt;PREVIOUS.LOG&lt;/code&gt; 、そして新しい &lt;code&gt;LATEST.LOG&lt;/code&gt; ファイルが作成されます。ログが正常にダンプされると、ファイル &lt;code&gt;PREVIOUS.LOG&lt;/code&gt; が削除されます。</target>
        </trans-unit>
        <trans-unit id="db255d80fd5fbd19169beeb79eff7051fb467716" translate="yes" xml:space="preserve">
          <source>Before the port is created, the driver must be loaded. This is done with the function &lt;code&gt;erl_dll:load_driver/1&lt;/code&gt;, with the name of the shared library as argument.</source>
          <target state="translated">ポートを作成する前に、ドライバーをロードする必要があります。これは、関数 &lt;code&gt;erl_dll:load_driver/1&lt;/code&gt; で、共有ライブラリの名前を引数として使用して行われます。</target>
        </trans-unit>
        <trans-unit id="46a334a8ddbc15c984030c1582dd4508b5f21665" translate="yes" xml:space="preserve">
          <source>Before the traversal starts, the source backup media is opened with &lt;code&gt;SourceMod:open_read(Source)&lt;/code&gt;, and the target backup media is opened with &lt;code&gt;TargetMod:open_write(Target)&lt;/code&gt;. The arguments are as follows:</source>
          <target state="translated">トラバーサルが開始する前に、ソースバックアップメディアが &lt;code&gt;SourceMod:open_read(Source)&lt;/code&gt; で開かれ、ターゲットバックアップメディアが &lt;code&gt;TargetMod:open_write(Target)&lt;/code&gt; で開かれます。引数は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="a1da9ec4f3c9fc4eb1c3cfeb7777f44d15e8f2fe" translate="yes" xml:space="preserve">
          <source>Before this instruction occurs, &lt;code&gt;Mod&lt;/code&gt; must have been loaded using &lt;code&gt;load_object_code&lt;/code&gt;. This instruction loads the module. &lt;code&gt;PrePurge&lt;/code&gt; is ignored. For a description of &lt;code&gt;PostPurge&lt;/code&gt;, see the high-level instruction &lt;code&gt;update&lt;/code&gt; earlier.</source>
          <target state="translated">この命令が発生する前に、 &lt;code&gt;Mod&lt;/code&gt; は &lt;code&gt;load_object_code&lt;/code&gt; を使用してロードされている必要があります。この命令はモジュールをロードします。 &lt;code&gt;PrePurge&lt;/code&gt; は無視されます。 &lt;code&gt;PostPurge&lt;/code&gt; の説明については、前述の高レベルの命令の &lt;code&gt;update&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="352876a2381c0951748f4964cadc93f74da158b5" translate="yes" xml:space="preserve">
          <source>Begin the scope of a prefix-URI Namespace mapping. Note that start/endPrefixMapping events are not guaranteed to be properly nested relative to each other: all startPrefixMapping events will occur immediately before the corresponding startElement event, and all endPrefixMapping events will occur immediately after the corresponding endElement event, but their order is not otherwise guaranteed. There will not be start/endPrefixMapping events for the &quot;xml&quot; prefix, since it is predeclared and immutable.</source>
          <target state="translated">prefix-URI名前空間マッピングのスコープを開始します。start/endPrefixMappingイベントは、すべてのstartPrefixMappingイベントは対応するstartElementイベントの直前に、endPrefixMappingイベントは対応するendElementイベントの直後に発生しますが、その順番は保証されません。プレフィックス「xml」は、事前に宣言されており、不変であるため、 start/endPrefixMappingイベントは発生しない。</target>
        </trans-unit>
        <trans-unit id="ef3ba8079ba496eafefddd167fd69849d3349c1c" translate="yes" xml:space="preserve">
          <source>Beginning of line</source>
          <target state="translated">行の先頭</target>
        </trans-unit>
        <trans-unit id="a0541a24650d9da6d38c74c8da4b43cac73179f4" translate="yes" xml:space="preserve">
          <source>Beginning with Erlang/OTP R14, parentheses when accessing or updating nested records can be omitted. Assume the following record definitions:</source>
          <target state="translated">Erlang/OTP R14以降では、入れ子になったレコードにアクセスしたり更新したりするときの括弧は省略できます。以下のレコード定義を想定してください。</target>
        </trans-unit>
        <trans-unit id="04a97d065ff4fbd74684b1f948daab7f3b7943dc" translate="yes" xml:space="preserve">
          <source>Behaves as &lt;code&gt;&lt;a href=&quot;#characters_to_list-2&quot;&gt; characters_to_list/2&lt;/a&gt;&lt;/code&gt;, but produces a binary instead of a Unicode list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#characters_to_list-2&quot;&gt; characters_to_list/2&lt;/a&gt;&lt;/code&gt; _to_list / 2として動作しますが、Unicodeリストの代わりにバイナリを生成します。</target>
        </trans-unit>
        <trans-unit id="dbe51e0d3cf7fe095d04d74ded17ede0a93150c5" translate="yes" xml:space="preserve">
          <source>Behaves as &lt;code&gt;&lt;a href=&quot;#characters_to_list-2&quot;&gt;characters_to_list/2&lt;/a&gt;&lt;/code&gt;, but produces a binary instead of a Unicode list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#characters_to_list-2&quot;&gt;characters_to_list/2&lt;/a&gt;&lt;/code&gt; として動作しますが、Unicodeリストではなくバイナリを生成します。</target>
        </trans-unit>
        <trans-unit id="89ade40ae04b2b1a7cb87dcb6495bdb4cd27f4c3" translate="yes" xml:space="preserve">
          <source>Behaves as &lt;code&gt;&lt;a href=&quot;#monitor_node-2&quot;&gt;monitor_node/2&lt;/a&gt;&lt;/code&gt; except that it allows an extra option to be specified, namely &lt;code&gt;allow_passive_connect&lt;/code&gt;. This option allows the BIF to wait the normal network connection time-out for the &lt;strong&gt;monitored node&lt;/strong&gt; to connect itself, even if it cannot be actively connected from this node (that is, it is blocked). The state where this can be useful can only be achieved by using the Kernel option &lt;code&gt;dist_auto_connect once&lt;/code&gt;. If that option is not used, option &lt;code&gt;allow_passive_connect&lt;/code&gt; has no effect.</source>
          <target state="translated">追加のオプション、つまり &lt;code&gt;allow_passive_connect&lt;/code&gt; を指定できることを除いて、 &lt;code&gt;&lt;a href=&quot;#monitor_node-2&quot;&gt;monitor_node/2&lt;/a&gt;&lt;/code&gt; として動作します。このオプションにより、BIFは、&lt;strong&gt;監視対象ノード&lt;/strong&gt;がこのノードからアクティブに接続できない（つまり、ブロックされている）場合でも、&lt;strong&gt;監視対象ノード&lt;/strong&gt;が接続するまで通常のネットワーク接続タイムアウトを待機できます。これが役立つ状態は、カーネルオプション &lt;code&gt;dist_auto_connect once&lt;/code&gt; 使用することによってのみ達成できます。このオプションを使用しない場合、オプション &lt;code&gt;allow_passive_connect&lt;/code&gt; は無効です。</target>
        </trans-unit>
        <trans-unit id="58884446ca5852c4e8961c8c91d6b677aceaea96" translate="yes" xml:space="preserve">
          <source>Behavior describing the API for public key handling of an SSH client. By implementing the callbacks defined in this behavior, the public key handling of an SSH client can be customized. By default the &lt;code&gt;ssh&lt;/code&gt; application implements this behavior with help of the standard OpenSSH files, see the &lt;code&gt; ssh(6)&lt;/code&gt; application manual.</source>
          <target state="translated">SSHクライアントの公開鍵処理用のAPIを説明する動作。この動作で定義されたコールバックを実装することにより、SSHクライアントの公開鍵処理をカスタマイズできます。デフォルトでは、 &lt;code&gt;ssh&lt;/code&gt; アプリケーションは標準のOpenSSHファイルを使用してこの動作を実装し &lt;code&gt; ssh(6)&lt;/code&gt; アプリケーションのマニュアルを参照してください。</target>
        </trans-unit>
        <trans-unit id="64aaa639db43c0fb66ead8ebf5d3670fe4ea4ff0" translate="yes" xml:space="preserve">
          <source>Behavior describing the API for public key handling of an SSH client. By implementing the callbacks defined in this behavior, the public key handling of an SSH client can be customized. By default the &lt;code&gt;ssh&lt;/code&gt; application implements this behavior with help of the standard OpenSSH files, see the &lt;code&gt;ssh(6)&lt;/code&gt; application manual.</source>
          <target state="translated">SSHクライアントの公開鍵処理用のAPIを記述する動作。この動作で定義されたコールバックを実装することにより、SSHクライアントの公開鍵の処理をカスタマイズできます。デフォルトでは、 &lt;code&gt;ssh&lt;/code&gt; アプリケーションは標準のOpenSSHファイルを使用してこの動作を実装し &lt;code&gt;ssh(6)&lt;/code&gt; アプリケーションのマニュアルを参照してください。</target>
        </trans-unit>
        <trans-unit id="6c2cfec7cf1dcce3dafc9cae66013644e8eff42f" translate="yes" xml:space="preserve">
          <source>Behaviour Module Attribute</source>
          <target state="translated">行動モジュール属性</target>
        </trans-unit>
        <trans-unit id="6505f096bd0cf99b3b2b5bc3d911574d1d3ac320" translate="yes" xml:space="preserve">
          <source>Behaviour describing the API for public key handling of an SSH server. By implementing the callbacks defined in this behavior, the public key handling of an SSH server can be customized. By default the SSH application implements this behavior with help of the standard OpenSSH files, see the &lt;code&gt; ssh(6)&lt;/code&gt; application manual.</source>
          <target state="translated">SSHサーバーの公開鍵処理用のAPIを説明する動作。この動作で定義されたコールバックを実装することにより、SSHサーバーの公開鍵処理をカスタマイズできます。デフォルトでは、SSHアプリケーションは標準のOpenSSHファイルを使用してこの動作を実装し &lt;code&gt; ssh(6)&lt;/code&gt; アプリケーションのマニュアルを参照してください。</target>
        </trans-unit>
        <trans-unit id="f16faae4208d9a96f7fb1bb23ef9cd7087ccfdeb" translate="yes" xml:space="preserve">
          <source>Behaviour describing the API for public key handling of an SSH server. By implementing the callbacks defined in this behavior, the public key handling of an SSH server can be customized. By default the SSH application implements this behavior with help of the standard OpenSSH files, see the &lt;code&gt;ssh(6)&lt;/code&gt; application manual.</source>
          <target state="translated">SSHサーバーの公開鍵処理用のAPIを記述する動作。この動作で定義されたコールバックを実装することにより、SSHサーバーの公開鍵の処理をカスタマイズできます。デフォルトでは、SSHアプリケーションは標準のOpenSSHファイルを使用してこの動作を実装し &lt;code&gt;ssh(6)&lt;/code&gt; アプリケーションのマニュアルを参照してください。</target>
        </trans-unit>
        <trans-unit id="f0d4ec155f7430eef8a27415e38c4ad6595b98c0" translate="yes" xml:space="preserve">
          <source>Behaviour module for reporting SNMP agent errors</source>
          <target state="translated">SNMPエージェントのエラーを報告するための動作モジュール</target>
        </trans-unit>
        <trans-unit id="2d41c7e7235b92d9c78165f5ea1a1214538b7ae8" translate="yes" xml:space="preserve">
          <source>Behaviour module for the SNMP agent discovery handler.</source>
          <target state="translated">SNMPエージェントディスカバリーハンドラの動作モジュール。</target>
        </trans-unit>
        <trans-unit id="4d88eee718b5f101a30d4bf7abe96e2a4af445a2" translate="yes" xml:space="preserve">
          <source>Behaviour module for the SNMP agent mib storage.</source>
          <target state="translated">SNMPエージェントmibストレージ用の動作モジュール。</target>
        </trans-unit>
        <trans-unit id="213836ecbce5c62ee5c70a707ff8f6efbfddb7e0" translate="yes" xml:space="preserve">
          <source>Behaviour module for the SNMP agent mib-server data module.</source>
          <target state="translated">SNMPエージェントmib-serverデータモジュールの動作モジュール。</target>
        </trans-unit>
        <trans-unit id="9b9ea5bbfad06ea1fc316484f53361a36304e0df" translate="yes" xml:space="preserve">
          <source>Behaviour module for the SNMP agent network interface.</source>
          <target state="translated">SNMPエージェントネットワークインターフェースの動作モジュール。</target>
        </trans-unit>
        <trans-unit id="b7490591e615b37731085e0dc791786738305c7b" translate="yes" xml:space="preserve">
          <source>Behaviour module for the SNMP agent network-interface filter.</source>
          <target state="translated">SNMPエージェントネットワークインターフェースフィルタの動作モジュール。</target>
        </trans-unit>
        <trans-unit id="2d2c6aaaa587ce80e3a95c5e764e760aa91d874b" translate="yes" xml:space="preserve">
          <source>Behaviour module for the SNMP agent notification delivery information receiver.</source>
          <target state="translated">SNMPエージェント通知配信情報受信機の動作モジュール。</target>
        </trans-unit>
        <trans-unit id="625c1c9de2b712103668af5814be0412885b49e5" translate="yes" xml:space="preserve">
          <source>Behaviour module for the SNMP agent notification filters.</source>
          <target state="translated">SNMPエージェント通知フィルタの動作モジュール。</target>
        </trans-unit>
        <trans-unit id="de9d0d8b19209222093743579cc0da909bbbb028" translate="yes" xml:space="preserve">
          <source>Behaviour module for the SNMP manager network interface.</source>
          <target state="translated">SNMPマネージャネットワークインターフェースの動作モジュール。</target>
        </trans-unit>
        <trans-unit id="2f41f4d43078504e98d5de4dc916e14eb8a85ba6" translate="yes" xml:space="preserve">
          <source>Behaviour module for the SNMP manager network-interface filter.</source>
          <target state="translated">SNMPマネージャネットワークインタフェースフィルタの動作モジュール。</target>
        </trans-unit>
        <trans-unit id="eb1e7ed7fa32a13f652cc9e9bf36d2ab93e52c2b" translate="yes" xml:space="preserve">
          <source>Behaviour module for the SNMP manager user.</source>
          <target state="translated">SNMPマネージャユーザの動作モジュール。</target>
        </trans-unit>
        <trans-unit id="77b3fcb503c107fdcf78ea27b16f4310e4bd176a" translate="yes" xml:space="preserve">
          <source>Behaviour with optional callbacks to customize the inets HTTP server.</source>
          <target state="translated">inets HTTP サーバをカスタマイズするためのオプションのコールバックを含む動作。</target>
        </trans-unit>
        <trans-unit id="e0f283a40056570ec143d350395380c52fd1c5b2" translate="yes" xml:space="preserve">
          <source>Below is a complete example of what should be added to a user's &lt;code&gt;.emacs&lt;/code&gt; provided that OTP is installed in the directory &lt;code&gt;/usr/local/otp&lt;/code&gt;:</source>
          <target state="translated">以下は、OTPがディレクトリ &lt;code&gt;/usr/local/otp&lt;/code&gt; にインストールされている場合に、ユーザーの &lt;code&gt;.emacs&lt;/code&gt; に追加する必要があるものの完全な例です。</target>
        </trans-unit>
        <trans-unit id="1fad7bb629bd2e9041c6abf5bc0a920316f854b0" translate="yes" xml:space="preserve">
          <source>Below is a complete example of what should be added to a user's &lt;code&gt;.emacs&lt;/code&gt; provided that OTP is installed in the directory &lt;code&gt;C:\Program Files\erl&amp;lt;Ver&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">以下は、OTPがディレクトリ &lt;code&gt;C:\Program Files\erl&amp;lt;Ver&amp;gt;&lt;/code&gt; インストールされている場合に、ユーザーの &lt;code&gt;.emacs&lt;/code&gt; に追加する必要のあるものの完全な例です。</target>
        </trans-unit>
        <trans-unit id="40217191ef85c64b525b787ccb400689f06f21a9" translate="yes" xml:space="preserve">
          <source>Below is an example of the grammar above with structure building code added:</source>
          <target state="translated">以下は、上記の文法に構造物の建築コードを追加した例です。</target>
        </trans-unit>
        <trans-unit id="5d5970fcf1e0337426fd2a5c1de2fd3082f3b1fe" translate="yes" xml:space="preserve">
          <source>Benchmarks can measure wall-clock time or CPU time.</source>
          <target state="translated">ベンチマークは、ウォールクロックの時間やCPUの時間を測定することができます。</target>
        </trans-unit>
        <trans-unit id="bfb8b17cc74805621ef756d36abfea020e22ec89" translate="yes" xml:space="preserve">
          <source>Benchmarks that appear to be concurrent are often sequential. The estone benchmark, for example, is entirely sequential. So is the most common implementation of the &quot;ring benchmark&quot;; usually one process is active, while the others wait in a &lt;code&gt;receive&lt;/code&gt; statement.</source>
          <target state="translated">多くの場合、並行しているように見えるベンチマークは連続的です。たとえば、estoneベンチマークは完全にシーケンシャルです。「リングベンチマーク」の最も一般的な実装も同様です。通常、1つのプロセスがアクティブで、他のプロセスは &lt;code&gt;receive&lt;/code&gt; ステートメントで待機します。</target>
        </trans-unit>
        <trans-unit id="198e9c0851a2cebe3440bd1cafd71b98e2d83392" translate="yes" xml:space="preserve">
          <source>Bengali</source>
          <target state="translated">Bengali</target>
        </trans-unit>
        <trans-unit id="c274af2a723078651a0cf0e2bdc4b8cb3f48d70d" translate="yes" xml:space="preserve">
          <source>Besides &lt;code&gt;qlc:table/2&lt;/code&gt;, other functions return query handles. They are used more seldom than tables, but are sometimes useful. &lt;code&gt;&lt;a href=&quot;#append-1&quot;&gt;qlc:append/1,2&lt;/a&gt;&lt;/code&gt; traverses objects from many tables or lists after each other. If, for example, you want to traverse all answers to a query &lt;code&gt;QH&lt;/code&gt; and then finish off by a term &lt;code&gt;{finished}&lt;/code&gt;, you can do that by calling &lt;code&gt;qlc:append(QH, [{finished}])&lt;/code&gt;. &lt;code&gt;append/2&lt;/code&gt; first returns all objects of &lt;code&gt;QH&lt;/code&gt;, then &lt;code&gt;{finished}&lt;/code&gt;. If a tuple &lt;code&gt;{finished}&lt;/code&gt; exists among the answers to &lt;code&gt;QH&lt;/code&gt;, it is returned twice from &lt;code&gt;append/2&lt;/code&gt;.</source>
          <target state="translated">ほか &lt;code&gt;qlc:table/2&lt;/code&gt; 、その他の機能は、クエリのハンドルを返します。テーブルよりも使用頻度は低いですが、役立つ場合があります。 &lt;code&gt;&lt;a href=&quot;#append-1&quot;&gt;qlc:append/1,2&lt;/a&gt;&lt;/code&gt; は、多くのテーブルまたはリストからオブジェクトを順番にトラバースします。たとえば、クエリ &lt;code&gt;QH&lt;/code&gt; へのすべての回答をトラバースし、用語 &lt;code&gt;{finished}&lt;/code&gt; で終了する場合は、 &lt;code&gt;qlc:append(QH, [{finished}])&lt;/code&gt; 呼び出すことで実行できます。 &lt;code&gt;append/2&lt;/code&gt; は、最初に &lt;code&gt;QH&lt;/code&gt; のすべてのオブジェクトを返し、次に &lt;code&gt;{finished}&lt;/code&gt; を返します。 &lt;code&gt;QH&lt;/code&gt; に対する回答の中に &lt;code&gt;{finished}&lt;/code&gt; というタプルが存在する場合、それは &lt;code&gt;append/2&lt;/code&gt; から2回返されます。</target>
        </trans-unit>
        <trans-unit id="c6260580b5bc11052e617d5d44b018db15e9a982" translate="yes" xml:space="preserve">
          <source>Besides addressing a process by using its pid, there are also BIFs for registering a process under a name. The name must be an atom and is automatically unregistered if the process terminates:</source>
          <target state="translated">プロセスのpidを使ったアドレス指定の他に、プロセスを名前で登録するためのBIFもあります。名前はアトムでなければならず、プロセスが終了すると自動的に登録が解除されます。</target>
        </trans-unit>
        <trans-unit id="453d7ac3df855ff457e6e90c9784d798c45f0f44" translate="yes" xml:space="preserve">
          <source>Besides implementing the functionality enabling the scheduling, preparation of signal data without port lock, etc, each operation sending signals to ports had to be quite extensively re-written. This in order to move all sub-operations that can be done without the lock to a place before we have acquired the lock, and also since signals now sometimes are executed immediately and sometimes scheduled for execution at a later time which put different requirements on the data to pass along with the signal.</source>
          <target state="translated">ポートロックなしでスケジューリングや信号データの準備ができる機能を実装したことに加えて、ポートに信号を送る各操作を大幅に書き換えなければなりませんでした。これは、ロックなしでできるすべてのサブオペレーションをロックを取得する前の場所に移動させるためであり、また、信号がすぐに実行されることもあれば、後で実行するようにスケジューリングされることもあり、信号と一緒に通過するデータに異なる要件を与えるためです。</target>
        </trans-unit>
        <trans-unit id="a4fc21da73002de65cd31f4246dde118952a0ef0" translate="yes" xml:space="preserve">
          <source>Besides passing carrier pool name as value to the parameter, you can also pass &lt;code&gt;:&lt;/code&gt;. By passing &lt;code&gt;:&lt;/code&gt; instead of carrier pool name, the allocator will use the carrier pool associated with itself. By passing the command line argument &quot;&lt;code&gt;+Mucg :&lt;/code&gt;&quot;, all allocators that have an associated carrier pool will use the carrier pool associated with themselves.</source>
          <target state="translated">キャリアプール名を値としてパラメータに渡す以外に、 &lt;code&gt;:&lt;/code&gt; を渡すこともできます。キャリアプール名の代わりに &lt;code&gt;:&lt;/code&gt; を渡すことにより、アロケータはそれ自体に関連付けられたキャリアプールを使用します。コマンドライン引数「 &lt;code&gt;+Mucg :&lt;/code&gt; 」を渡すことにより、キャリアプールが関連付けられているすべてのアロケータは、自分自身に関連付けられているキャリアプールを使用します。</target>
        </trans-unit>
        <trans-unit id="f5348075792306c67e1b0814d6ba0ff860d6cb22" translate="yes" xml:space="preserve">
          <source>Besides reporting time, &lt;code&gt;erlang:now/0&lt;/code&gt; also produces unique and strictly monotonically increasing values. To detach this functionality from time measurements, we have introduced &lt;code&gt;&lt;a href=&quot;erlang#unique_integer-1&quot;&gt; erlang:unique_integer()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;erlang:now/0&lt;/code&gt; は、時間を報告するだけでなく、一意で厳密に単調に増加する値も生成します。この機能を時間測定から切り離すために、 &lt;code&gt;&lt;a href=&quot;erlang#unique_integer-1&quot;&gt; erlang:unique_integer()&lt;/a&gt;&lt;/code&gt; を導入しました。</target>
        </trans-unit>
        <trans-unit id="b15bc3f2eceb04129fd4516b3b370516eb00424d" translate="yes" xml:space="preserve">
          <source>Besides reporting time, &lt;code&gt;erlang:now/0&lt;/code&gt; also produces unique and strictly monotonically increasing values. To detach this functionality from time measurements, we have introduced &lt;code&gt;&lt;a href=&quot;erlang#unique_integer-1&quot;&gt;erlang:unique_integer()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;erlang:now/0&lt;/code&gt; は、時間の報告に加えて、一意で厳密に単調に増加する値も生成します。この機能を時間測定から切り離すために、 &lt;code&gt;&lt;a href=&quot;erlang#unique_integer-1&quot;&gt;erlang:unique_integer()&lt;/a&gt;&lt;/code&gt; を導入しました。</target>
        </trans-unit>
        <trans-unit id="9a52810e66627e5a80808e690811322ee8adf786" translate="yes" xml:space="preserve">
          <source>Besides test cases and groups, the test suite can also contain configuration functions. These functions are meant to be used for setting up (and verifying) environment and state in the SUT (and/or the &lt;code&gt;Common Test&lt;/code&gt; host node), required for the tests to execute correctly. Examples of operations are: Opening a connection to the SUT, initializing a database, running an installation script, and so on. Configuration can be performed per suite, per test case group, and per individual test case.</source>
          <target state="translated">テストケースには、テストケースとグループの他に、構成機能も含めることができます。これらの関数は、テストを正しく実行するために必要な、SUT（および/または &lt;code&gt;Common Test&lt;/code&gt; ホストノード）で環境と状態を設定（および検証）するために使用することを目的としています。操作の例は、SUTへの接続のオープン、データベースの初期化、インストールスクリプトの実行などです。構成は、スイートごと、テストケースグループごと、および個々のテストケースごとに実行できます。</target>
        </trans-unit>
        <trans-unit id="007ac80b876d6b31b51d4c189993df4c58d1fc5a" translate="yes" xml:space="preserve">
          <source>Besides the already mentioned source parameters &lt;code&gt;root_dir&lt;/code&gt; and &lt;code&gt;lib_dirs&lt;/code&gt;, the following system (&lt;code&gt;sys&lt;/code&gt;) level options are supported:</source>
          <target state="translated">すでに述べたソースパラメータ &lt;code&gt;root_dir&lt;/code&gt; および &lt;code&gt;lib_dirs&lt;/code&gt; に加えて、次のシステム（ &lt;code&gt;sys&lt;/code&gt; ）レベルのオプションがサポートされています。</target>
        </trans-unit>
        <trans-unit id="e7b2c0c382d27b288446a0bacbb0c94ce486cb4f" translate="yes" xml:space="preserve">
          <source>Best Practices for Using Persistent Terms</source>
          <target state="translated">永続的な用語を使用するためのベストプラクティス</target>
        </trans-unit>
        <trans-unit id="d77fc5043db349a36fcc2530a0223317a9d51ded" translate="yes" xml:space="preserve">
          <source>Between modules</source>
          <target state="translated">モジュール間</target>
        </trans-unit>
        <trans-unit id="7e04d97ca7154dfa6468b97d3b9c42d0c616a358" translate="yes" xml:space="preserve">
          <source>Between nodes</source>
          <target state="translated">ノード間</target>
        </trans-unit>
        <trans-unit id="3430043cce88789d3bd382a0b2a1bc3c39a24538" translate="yes" xml:space="preserve">
          <source>Between processes</source>
          <target state="translated">プロセス間</target>
        </trans-unit>
        <trans-unit id="f6202bc62a181da8db026f3b5d7d396e4ee251e7" translate="yes" xml:space="preserve">
          <source>Between step 6 and 8, runninng processes might execute the written &lt;code&gt;op_i_generic_breakpoint&lt;/code&gt; instruction. They will get the breakpoint structure written in step 3, read &lt;code&gt;erts_active_bp_index&lt;/code&gt; and execute the corresponding part of the breakpoint. Before the switch in step 8 becomes visible they will however execute the disabled part of the breakpoint structure and do nothing other than executing the saved original instruction.</source>
          <target state="translated">ステップ6と8の間に、実行中のプロセスが記述された &lt;code&gt;op_i_generic_breakpoint&lt;/code&gt; 命令を実行する場合があります。手順3で記述したブレークポイント構造を取得し、 &lt;code&gt;erts_active_bp_index&lt;/code&gt; を読み取り、ブレークポイントの対応する部分を実行します。ただし、ステップ8のスイッチが表示される前に、ブレークポイント構造の無効な部分を実行し、保存された元の命令を実行する以外に何もしません。</target>
        </trans-unit>
        <trans-unit id="3f0ece311d270b7fe14ea09dcb08057562506122" translate="yes" xml:space="preserve">
          <source>Beware</source>
          <target state="translated">Beware</target>
        </trans-unit>
        <trans-unit id="f647ae7d5e7143915c4692eef6551f34333f508c" translate="yes" xml:space="preserve">
          <source>Beware of confusing mandatory in the sense of the M-bit with mandatory in the sense of the command grammar. The former is a semantic requirement: that the receiver understand the semantics of the AVP in the context in question. The latter is a syntactic requirement: whether or not the AVP must occur in the message in question.</source>
          <target state="translated">M ビットの意味での mandatory とコマンド文法の意味での mandatory を混同しないように注意してください。前者は意味論的な要件であり、受信者は問題の文脈における AVP の意味論を理解している必要があります。後者は構文的な要件である:AVP が問題のメッセージで発生しなければならないかどうかである。</target>
        </trans-unit>
        <trans-unit id="5a3b08c5bdc112934a46e49f93c6566926eb949f" translate="yes" xml:space="preserve">
          <source>Beware of trailing space in &lt;code&gt;Replacement&lt;/code&gt; to be used. If you must have a space in &lt;code&gt;Re&lt;/code&gt;, use, for example, the character encoding &lt;code&gt;\040&lt;/code&gt;, see &lt;code&gt;re(3)&lt;/code&gt;.</source>
          <target state="translated">使用する &lt;code&gt;Replacement&lt;/code&gt; の末尾のスペースに注意してください。 &lt;code&gt;Re&lt;/code&gt; にスペースが必要な場合は、たとえば、文字エンコーディング &lt;code&gt;\040&lt;/code&gt; を使用してください &lt;code&gt;re(3)&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="99e106abb61082912f0a96161c0ad22a4eea32f3" translate="yes" xml:space="preserve">
          <source>Beware of using fun expressions of the form &lt;code&gt;fun Name/Arity&lt;/code&gt; in situations in which the fun is not short-lived and code is to be upgraded at runtime since any processes retaining such a fun will have a reference to old code. In particular, such a value is typically inappropriate in configuration passed to &lt;code&gt;&lt;a href=&quot;#start_service-2&quot;&gt;start_service/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#add_transport-2&quot;&gt;add_transport/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">funが短命ではなく、実行時にコードがアップグレードされる状況では、 &lt;code&gt;fun Name/Arity&lt;/code&gt; という形式のfun式を使用することに注意してください。このようなfunを保持するプロセスは古いコードを参照するためです。特に、このような値は通常、 &lt;code&gt;&lt;a href=&quot;#start_service-2&quot;&gt;start_service/2&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;#add_transport-2&quot;&gt;add_transport/2&lt;/a&gt;&lt;/code&gt; に渡される構成では不適切です。</target>
        </trans-unit>
        <trans-unit id="9f04d9d4432e8383e468152a41bfa09dcf4f742e" translate="yes" xml:space="preserve">
          <source>Beware that RFC 6733 changed the DiameterURI transport/port defaults specified in RFC3588. Relying on the defaults can result in interoperability problems.</source>
          <target state="translated">RFC6733では、RFC3588で指定されているDiameterURIトランスポート/ポートのデフォルトが変更されているので注意が必要です。デフォルトに依存すると、相互運用性の問題が生じる可能性がある。</target>
        </trans-unit>
        <trans-unit id="37789191d916ab6f4adfabdff7e05307d5bbf9ba" translate="yes" xml:space="preserve">
          <source>Beware the difference between &lt;strong&gt;diameter&lt;/strong&gt; (not capitalized) and &lt;strong&gt;Diameter&lt;/strong&gt; (capitalized). The former refers to the Erlang application named diameter whose main api is defined here, the latter to Diameter protocol in the sense of RFC 6733.</source>
          <target state="translated">差注意&lt;strong&gt;直径&lt;/strong&gt;（大文字ではない）と&lt;strong&gt;直径&lt;/strong&gt;（大文字）を。前者は、diameterという名前のErlangアプリケーションを指し、そのメインAPIはここで定義され、後者はRFC 6733の意味でのDiameterプロトコルを指します。</target>
        </trans-unit>
        <trans-unit id="7e27c93748471a211ccbeda730113ee702b30a76" translate="yes" xml:space="preserve">
          <source>Bignums are stored in unary form with a &lt;code&gt;Sign&lt;/code&gt; byte, that is, 0 if the bignum is positive and 1 if it is negative. The digits are stored with the least significant byte stored first. To calculate the integer, the following formula can be used:</source>
          <target state="translated">Bignumは、 &lt;code&gt;Sign&lt;/code&gt; バイトを使用して1進形式で格納されます。つまり、bignumが正の場合は0、負の場合は1です。桁は最下位バイトが最初に格納されて格納されます。整数を計算するには、次の式を使用できます。</target>
        </trans-unit>
        <trans-unit id="5b68a0f135268fc97357fa1f2e8bec70aa5933a7" translate="yes" xml:space="preserve">
          <source>Bignums are stored in unary form with a &lt;code&gt;Sign&lt;/code&gt; byte, that is, 0 if the binum is positive and 1 if it is negative. The digits are stored with the least significant byte stored first. To calculate the integer, the following formula can be used:</source>
          <target state="translated">Bignumは、 &lt;code&gt;Sign&lt;/code&gt; バイト付きの単項形式で格納されます。つまり、バイナムが正の場合は0、負の場合は1です。数字は、最下位バイトが最初に格納されて格納されます。整数を計算するには、次の式を使用できます。</target>
        </trans-unit>
        <trans-unit id="915f680c2bd74e3a951cc35061c83bda7c9d3906" translate="yes" xml:space="preserve">
          <source>Binaries are generated with bit syntax expression or with &lt;code&gt; erlang:list_to_binary/1&lt;/code&gt;, &lt;code&gt; erlang:term_to_binary/1&lt;/code&gt;, or as input from binary ports. The &lt;code&gt;Len&lt;/code&gt; length field is an unsigned 4 byte integer (big-endian).</source>
          <target state="translated">バイナリは、ビット構文式または &lt;code&gt; erlang:list_to_binary/1&lt;/code&gt; 、 &lt;code&gt; erlang:term_to_binary/1&lt;/code&gt; 、またはバイナリポートからの入力として生成されます。 &lt;code&gt;Len&lt;/code&gt; 長さフィールドは、符号なしの4バイト整数（ビッグエンディアン）です。</target>
        </trans-unit>
        <trans-unit id="b0c51379d746d689abb0d4163480ae980cc1ea4f" translate="yes" xml:space="preserve">
          <source>Binaries are generated with bit syntax expression or with &lt;code&gt;erlang:list_to_binary/1&lt;/code&gt;, &lt;code&gt;erlang:term_to_binary/1&lt;/code&gt;, or as input from binary ports. The &lt;code&gt;Len&lt;/code&gt; length field is an unsigned 4 byte integer (big-endian).</source>
          <target state="translated">バイナリーは、ビット構文式、または &lt;code&gt;erlang:list_to_binary/1&lt;/code&gt; 、 &lt;code&gt;erlang:term_to_binary/1&lt;/code&gt; を使用して、またはバイナリー・ポートからの入力として生成されます。 &lt;code&gt;Len&lt;/code&gt; 長さフィールドは、符号なしの4バイト整数（ビッグエンディアン）です。</target>
        </trans-unit>
        <trans-unit id="afb16785a033cecba113ba879f8a7ad266f9f880" translate="yes" xml:space="preserve">
          <source>Binaries are more troublesome. For performance reasons, programs often store textual data in binaries instead of lists, mainly because they are more compact (one byte per character instead of two words per character, as is the case with lists). Using &lt;code&gt;erlang:list_to_binary/1&lt;/code&gt;, an ISO Latin-1 Erlang string can be converted into a binary, effectively using bytewise encoding: one byte per character. This was convenient for those limited Erlang strings, but cannot be done for arbitrary Unicode lists.</source>
          <target state="translated">バイナリはより面倒です。パフォーマンス上の理由から、プログラムはテキストデータをリストではなくバイナリに格納することがよくあります。これは主に、テキストデータがよりコンパクトだからです（リストの場合のように、文字ごとに2ワードではなく、文字ごとに1バイト）。 &lt;code&gt;erlang:list_to_binary/1&lt;/code&gt; を使用すると、ISO Latin-1 Erlangストリングをバイナリーに変換できます。これは、バイト単位のエンコードを効果的に使用して、文字ごとに1バイトです。これは、制限されたErlang文字列には便利でしたが、任意のUnicodeリストには実行できません。</target>
        </trans-unit>
        <trans-unit id="9777da829501809520a535ef9e6d08ff6a5dcba9" translate="yes" xml:space="preserve">
          <source>Binaries are sequences of whole bytes. Bitstrings with an arbitrary bit length have no support yet.</source>
          <target state="translated">バイナリはバイト全体のシーケンスです。任意のビット長のビット列はまだサポートされていません。</target>
        </trans-unit>
        <trans-unit id="ddb0d785eee554ca3ad9cce85a18ca8630f56b8c" translate="yes" xml:space="preserve">
          <source>Binaries can be efficiently built in the following way:</source>
          <target state="translated">バイナリは以下のような方法で効率的に構築することができます。</target>
        </trans-unit>
        <trans-unit id="0d0d3b67132c6fcaa92c679366fed8db13d485e2" translate="yes" xml:space="preserve">
          <source>Binaries can be efficiently matched like this:</source>
          <target state="translated">バイナリーはこのように効率よくマッチングさせることができます。</target>
        </trans-unit>
        <trans-unit id="66639f7d455dd71faa9147f5d69e5ce885d8bebd" translate="yes" xml:space="preserve">
          <source>Binary</source>
          <target state="translated">Binary</target>
        </trans-unit>
        <trans-unit id="892dde55806e241693a0b3bdfdd1efae250f381f" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;Bin&lt;/code&gt; contains the same information as the output from &lt;code&gt;erlang:process_display(Pid, backtrace)&lt;/code&gt;. Use &lt;code&gt;binary_to_list/1&lt;/code&gt; to obtain the string of characters from the binary.</source>
          <target state="translated">Binary &lt;code&gt;Bin&lt;/code&gt; には、 &lt;code&gt;erlang:process_display(Pid, backtrace)&lt;/code&gt; からの出力と同じ情報が含まれています。 &lt;code&gt;binary_to_list/1&lt;/code&gt; を使用して、バイナリから文字列を取得します。</target>
        </trans-unit>
        <trans-unit id="ebbd4d9948de9c87d6e53af4cc41250b5709a590" translate="yes" xml:space="preserve">
          <source>Binary boot script</source>
          <target state="translated">バイナリブートスクリプト</target>
        </trans-unit>
        <trans-unit id="6ca5ef63e7a423ed4f0c902eb2201ec5aa53e26f" translate="yes" xml:space="preserve">
          <source>Binary callback function &lt;code id=&quot;lookup_fun&quot;&gt;LookupFun&lt;/code&gt; is used for looking up objects in the table. The first argument &lt;code&gt;Position&lt;/code&gt; is the key position or an indexed position and the second argument &lt;code&gt;Keys&lt;/code&gt; is a sorted list of unique values. The return value is to be a list of all objects (tuples), such that the element at &lt;code&gt;Position&lt;/code&gt; is a member of &lt;code&gt;Keys&lt;/code&gt;. Any other return value is immediately returned as value of the query evaluation. &lt;code&gt;LookupFun&lt;/code&gt; is called instead of traversing the table if the parse transform at compile time can determine that the filters match and compare the element at &lt;code&gt;Position&lt;/code&gt; in such a way that only &lt;code&gt;Keys&lt;/code&gt; need to be looked up to find all potential answers.</source>
          <target state="translated">バイナリコールバック関数 &lt;code id=&quot;lookup_fun&quot;&gt;LookupFun&lt;/code&gt; は、テーブル内のオブジェクトを検索するために使用されます。最初の引数 &lt;code&gt;Position&lt;/code&gt; はキーの位置またはインデックス付きの位置であり、2番目の引数 &lt;code&gt;Keys&lt;/code&gt; は一意の値のソートされたリストです。戻り値は、 &lt;code&gt;Position&lt;/code&gt; の要素が &lt;code&gt;Keys&lt;/code&gt; のメンバーであるような、すべてのオブジェクト（タプル）のリストになります。その他の戻り値は、クエリ評価の値としてすぐに返されます。 &lt;code&gt;LookupFun&lt;/code&gt; は解析がフィルタが一致することを決定し、ある要素を比較することができ、コンパイル時に変換する場合の代わりにテーブルを移動すると呼ばれる &lt;code&gt;Position&lt;/code&gt; ような方法でのみ &lt;code&gt;Keys&lt;/code&gt; すべての潜在的な答えを見つけるために調べる必要があります。</target>
        </trans-unit>
        <trans-unit id="91649b24f930abce26bedbe83f0148ebb05baa18" translate="yes" xml:space="preserve">
          <source>Binary codecs</source>
          <target state="translated">バイナリコーデック</target>
        </trans-unit>
        <trans-unit id="bfbd337015a6a1e9c7fe45e7f4ee5d33b7a0cc06" translate="yes" xml:space="preserve">
          <source>Binary data is shared among processes. If another process still references the larger binary, copying the part this process uses only consumes more memory and does not free up the larger binary for garbage collection. Use this kind of intrusive functions with extreme care and only if a real problem is detected.</source>
          <target state="translated">バイナリデータはプロセス間で共有されます。別のプロセスがまだより大きなバイナリを参照している場合、このプロセスが使用している部分をコピーしても、より多くのメモリを消費するだけで、ガベージコレクションのためにより大きなバイナリを解放することはありません。この種の侵入的な関数は細心の注意を払って使用し、実際の問題が検出された場合にのみ使用してください。</target>
        </trans-unit>
        <trans-unit id="e0b461eb903baadd26c515cd4ef53be30f07dc47" translate="yes" xml:space="preserve">
          <source>Binary handling was significantly improved in R12B. Because code that was efficient in R11B might not be efficient in R12B, and vice versa, earlier revisions of this Efficiency Guide contained some information about binary handling in R11B.</source>
          <target state="translated">バイナリ処理は R12B で大幅に改善されました。R11B で効率的だったコードが R12B で効率的でない場合があり、またその逆もあるため、この効率化ガイドの以前のリビジョンには、R11B でのバイナリ処理に関する情報が含まれていました。</target>
        </trans-unit>
        <trans-unit id="3435ca67f0f051a1fea228cdb0770bf8e8bb3d65" translate="yes" xml:space="preserve">
          <source>Binary sharing occurs whenever binaries are taken apart. This is the fundamental reason why binaries are fast, decomposition can always be done with O(1) complexity. In rare circumstances this data sharing is however undesirable, why this function together with &lt;code&gt;copy/1&lt;/code&gt; can be useful when optimizing for memory use.</source>
          <target state="translated">バイナリ共有は、バイナリが分解されるたびに発生します。これが、バイナリが高速である根本的な理由であり、分解は常にO（1）の複雑度で実行できます。ただし、まれにこのデータ共有が望ましくない場合があります。メモリ使用を最適化するときに、 &lt;code&gt;copy/1&lt;/code&gt; と一緒にこの関数が役立つのはなぜですか。</target>
        </trans-unit>
        <trans-unit id="444f4f33b9d5b0002c23fd9ec1a4edab1ded0af6" translate="yes" xml:space="preserve">
          <source>Binary with characters encoded in UTF-8 or UTF-16.</source>
          <target state="translated">UTF-8 または UTF-16 でエンコードされた文字を持つバイナリ。</target>
        </trans-unit>
        <trans-unit id="c065024f1e88a0e634a5d724af341ce692e22147" translate="yes" xml:space="preserve">
          <source>Binary with characters encoded in iso-latin-1.</source>
          <target state="translated">iso-latin-1でエンコードされた文字を持つバイナリ。</target>
        </trans-unit>
        <trans-unit id="89f902f1a369dce968f46c3953a9e68e0d99f72f" translate="yes" xml:space="preserve">
          <source>BinaryGraphOp ::= &lt;code&gt;of&lt;/code&gt;</source>
          <target state="translated">BinaryGraphOp :: = &lt;code&gt;of&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7513e46be3c5ca02f1cd91f8479bcae815aa2cca" translate="yes" xml:space="preserve">
          <source>BinarySetOp ::= &lt;code&gt;+&lt;/code&gt; | &lt;code&gt;*&lt;/code&gt; | &lt;code&gt;-&lt;/code&gt;</source>
          <target state="translated">BinarySetOp :: = &lt;code&gt;+&lt;/code&gt; | &lt;code&gt;*&lt;/code&gt; | &lt;code&gt;-&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1eb97ea1779ca334fa82951915ccbbf0c411af8d" translate="yes" xml:space="preserve">
          <source>Bind a name to a socket.</source>
          <target state="translated">ソケットに名前をバインドします。</target>
        </trans-unit>
        <trans-unit id="a13da3886205091801df2d6f1afb4618b1d0ec53" translate="yes" xml:space="preserve">
          <source>Bind the socket identified by &lt;code&gt;ctx&lt;/code&gt; to a local interface and then listen on it.</source>
          <target state="translated">&lt;code&gt;ctx&lt;/code&gt; で識別されるソケットをローカルインターフェイスにバインドし、それをリッスンします。</target>
        </trans-unit>
        <trans-unit id="4666da54d73c3984e4c044ae18083dcbc9b65311" translate="yes" xml:space="preserve">
          <source>Binding and Using a Size Variable</source>
          <target state="translated">サイズ変数のバインドと使用</target>
        </trans-unit>
        <trans-unit id="8264338650782cc58de94b15794c38a796b18c92" translate="yes" xml:space="preserve">
          <source>Binding of schedulers is not supported on the specific platform.</source>
          <target state="translated">スケジューラのバインドは特定のプラットフォームではサポートされていません。</target>
        </trans-unit>
        <trans-unit id="65e949b92a71c14d4ea442682069d67c76442e70" translate="yes" xml:space="preserve">
          <source>Binding of schedulers is only supported on newer Linux, Solaris, FreeBSD, and Windows systems.</source>
          <target state="translated">スケジューラのバインディングは、新しい Linux、Solaris、FreeBSD、Windows システムでのみサポートされています。</target>
        </trans-unit>
        <trans-unit id="1e29acb46257f51cfc0f132df9d70d5a8cf45608" translate="yes" xml:space="preserve">
          <source>Bindings,</source>
          <target state="translated">Bindings,</target>
        </trans-unit>
        <trans-unit id="a255a9d3a4009bbdfcc5e9d159b353b687a30da6" translate="yes" xml:space="preserve">
          <source>Binds a socket to a specific network interface. This option must be used in a function call that creates a socket, that is, &lt;code&gt;&lt;a href=&quot;gen_tcp#connect-3&quot;&gt;gen_tcp:connect/3,4&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;gen_tcp#listen-2&quot;&gt;gen_tcp:listen/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;gen_udp#open-1&quot;&gt;gen_udp:open/1,2&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;gen_sctp#open-0&quot;&gt;gen_sctp:open/0,1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ソケットを特定のネットワークインターフェイスにバインドします。このオプションは、ソケットを作成する関数呼び出しで使用する必要があります。つまり、 &lt;code&gt;&lt;a href=&quot;gen_tcp#connect-3&quot;&gt;gen_tcp:connect/3,4&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;gen_tcp#listen-2&quot;&gt;gen_tcp:listen/2&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;gen_udp#open-1&quot;&gt;gen_udp:open/1,2&lt;/a&gt;&lt;/code&gt; 、または &lt;code&gt;&lt;a href=&quot;gen_sctp#open-0&quot;&gt;gen_sctp:open/0,1,2&lt;/a&gt;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="63d9eb9271114848197174178defd97f77fc4e24" translate="yes" xml:space="preserve">
          <source>Bit Syntax</source>
          <target state="translated">ビット構文</target>
        </trans-unit>
        <trans-unit id="360cda316649dfca67f2603c94b136a74b6c648a" translate="yes" xml:space="preserve">
          <source>Bit string comprehensions are analogous to List Comprehensions. They are used to generate bit strings efficiently and succinctly.</source>
          <target state="translated">ビット文字列内包は、リスト内包に似ています。これらは、効率的かつ簡潔にビット文字列を生成するために使用されます。</target>
        </trans-unit>
        <trans-unit id="f9ef7ef37c0e6417fc396a660a24f1538c5ef671" translate="yes" xml:space="preserve">
          <source>Bit string comprehensions are written with the following syntax:</source>
          <target state="translated">ビット文字列内包は、以下の構文で記述されます。</target>
        </trans-unit>
        <trans-unit id="5d2f7999e57c41f3eb88a4f59c1cc481292645c5" translate="yes" xml:space="preserve">
          <source>Bit strings are compared bit by bit. If one bit string is a prefix of the other, the shorter bit string is considered smaller.</source>
          <target state="translated">ビット文字列はビットごとに比較されます。一方のビット文字列が他方のビット文字列の接頭辞である場合、短いビット文字列の方が小さいとみなされます。</target>
        </trans-unit>
        <trans-unit id="fe2441919ecc33eba0d15c91c6774d8e118b27fa" translate="yes" xml:space="preserve">
          <source>Bit strings are expressed using the &lt;code&gt;&lt;a href=&quot;expressions#bit_syntax&quot;&gt;bit syntax&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ビット文字列は、 &lt;code&gt;&lt;a href=&quot;expressions#bit_syntax&quot;&gt;bit syntax&lt;/a&gt;&lt;/code&gt; を使用して表現されます。</target>
        </trans-unit>
        <trans-unit id="ef4786f28896f4e7ec27947fbbc93a25189b57f1" translate="yes" xml:space="preserve">
          <source>Bit strings that consist of a number of bits that are evenly divisible by eight, are called &lt;strong&gt;binaries&lt;/strong&gt;</source>
          <target state="translated">8で割り切れるビット数で構成されるビット文字列は、&lt;strong&gt;バイナリ&lt;/strong&gt;と呼ばれます&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="71ef7d1974a07fcaa17eb97f44c3fb4fcef331ed" translate="yes" xml:space="preserve">
          <source>Bitshift right</source>
          <target state="translated">ビットシフト右</target>
        </trans-unit>
        <trans-unit id="a8a268a3b89f5db9e48e02038fd78e154fb41041" translate="yes" xml:space="preserve">
          <source>Bitstring Element Type Specifiers</source>
          <target state="translated">ビット文字列要素型指定子</target>
        </trans-unit>
        <trans-unit id="17e80e5f71e9b85954b350f117d4dfeb3c5cf70a" translate="yes" xml:space="preserve">
          <source>Bitwise AND</source>
          <target state="translated">ビットごとのAND</target>
        </trans-unit>
        <trans-unit id="f4be0adcfa81c37e1e7bbf2e23630f30974d164f" translate="yes" xml:space="preserve">
          <source>Bitwise OR</source>
          <target state="translated">ビットごとのOR</target>
        </trans-unit>
        <trans-unit id="567f521d0a70021d35df0a7429cd3579c200a9d3" translate="yes" xml:space="preserve">
          <source>Bitwise operators: &lt;code&gt;band&lt;/code&gt;, &lt;code&gt;bor&lt;/code&gt;, &lt;code&gt;bxor&lt;/code&gt;, &lt;code&gt;bnot&lt;/code&gt;, &lt;code&gt;bsl&lt;/code&gt;, &lt;code&gt;bsr&lt;/code&gt;</source>
          <target state="translated">ビット演算子： &lt;code&gt;band&lt;/code&gt; 、 &lt;code&gt;bor&lt;/code&gt; 、 &lt;code&gt;bxor&lt;/code&gt; 、 &lt;code&gt;bnot&lt;/code&gt; 、 &lt;code&gt;bsl&lt;/code&gt; 、 &lt;code&gt;bsr&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ae104d5e9f670270b20927f74417d76623f8773a" translate="yes" xml:space="preserve">
          <source>Black-box testing of target systems of any type (that is, not necessarily implemented in Erlang). This is performed through standard O&amp;amp;M interfaces (such as SNMP, HTTP, CORBA, and Telnet) and, if necessary, through user-specific interfaces (often called test ports).</source>
          <target state="translated">あらゆるタイプのターゲットシステムのブラックボックステスト（つまり、必ずしもErlangで実装されているわけではありません）。これは、標準のO＆Mインターフェイス（SNMP、HTTP、CORBA、Telnetなど）を介して実行され、必要に応じてユーザー固有のインターフェイス（テストポートと呼ばれることも多い）を介して実行されます。</target>
        </trans-unit>
        <trans-unit id="9a8a1cf314b7d5a93ed2c3c8500ce8e82ea060d8" translate="yes" xml:space="preserve">
          <source>Block ciphers -  DES and AES in Block Cipher Modes - &lt;code&gt;&lt;a href=&quot;http://csrc.nist.gov/groups/ST/toolkit/BCM/index.html&quot;&gt; ECB, CBC, CFB, OFB, CTR and GCM &lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">ブロック暗号-ブロック暗号モードのDESおよびAES- &lt;code&gt;&lt;a href=&quot;http://csrc.nist.gov/groups/ST/toolkit/BCM/index.html&quot;&gt; ECB, CBC, CFB, OFB, CTR and GCM &lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fc11d63974d38781fdb2ea32c8ba8e895421285c" translate="yes" xml:space="preserve">
          <source>Block expressions provide a way to group a sequence of expressions, similar to a clause body. The return value is the value of the last expression &lt;code&gt;ExprN&lt;/code&gt;.</source>
          <target state="translated">ブロック式は、句本体と同様に、式のシーケンスをグループ化する方法を提供します。戻り値は、最後の式 &lt;code&gt;ExprN&lt;/code&gt; の値です。</target>
        </trans-unit>
        <trans-unit id="a11c7845b57dd764a4e0b6dfeac45510d039cbd4" translate="yes" xml:space="preserve">
          <source>Blocking of multi-scheduling and normal multi-scheduling is normally not needed. If you feel that you need to use these features, consider it a few more times again. Blocking multi-scheduling is only to be used as a last resort, as it is most likely a &lt;strong&gt;very inefficient&lt;/strong&gt; way to solve the problem.</source>
          <target state="translated">通常、マルチスケジューリングと通常のマルチスケジューリングのブロックは必要ありません。これらの機能を使用する必要があると思われる場合は、もう一度何回か検討してください。マルチスケジューリングのブロックは、問題を解決するための&lt;strong&gt;非常に非効率的な&lt;/strong&gt;方法である可能性が高いため、最後の手段としてのみ使用されます。</target>
        </trans-unit>
        <trans-unit id="f88bcddd0731f8535aab4cf6c4aea9771da5b592" translate="yes" xml:space="preserve">
          <source>Blocks that are larger than the value of the singleblock carrier threshold (&lt;code&gt;&lt;a href=&quot;#M_sbct&quot;&gt;sbct&lt;/a&gt;&lt;/code&gt;) parameter are placed in singleblock carriers.</source>
          <target state="translated">シングルブロックキャリアしきい値（ &lt;code&gt;&lt;a href=&quot;#M_sbct&quot;&gt;sbct&lt;/a&gt;&lt;/code&gt; ）パラメーターの値より大きいブロックは、シングルブロックキャリアに配置されます。</target>
        </trans-unit>
        <trans-unit id="19edd385ea6503e1211246f52fb3bd015a6b72b6" translate="yes" xml:space="preserve">
          <source>Blocks that are smaller than the value of parameter &lt;code&gt;sbct&lt;/code&gt; are placed in multiblock carriers.</source>
          <target state="translated">パラメータ &lt;code&gt;sbct&lt;/code&gt; の値より小さいブロックは、マルチブロックキャリアに配置されます。</target>
        </trans-unit>
        <trans-unit id="4206776cd5ab32e70519cb42f90bc1cb4373333a" translate="yes" xml:space="preserve">
          <source>BoolFunction ::= &lt;code&gt;is_atom&lt;/code&gt; | &lt;code&gt;is_float&lt;/code&gt; | &lt;code&gt;is_integer&lt;/code&gt; | &lt;code&gt;is_list&lt;/code&gt; | &lt;code&gt;is_number&lt;/code&gt; | &lt;code&gt;is_pid&lt;/code&gt; | &lt;code&gt;is_port&lt;/code&gt; | &lt;code&gt;is_reference&lt;/code&gt; | &lt;code&gt;is_tuple&lt;/code&gt; | &lt;code&gt;is_map&lt;/code&gt; | &lt;code&gt;is_map_key&lt;/code&gt; | &lt;code&gt;is_binary&lt;/code&gt; | &lt;code&gt;is_function&lt;/code&gt; | &lt;code&gt;is_record&lt;/code&gt; | &lt;code&gt;is_seq_trace&lt;/code&gt; | &lt;code&gt;'and'&lt;/code&gt; | &lt;code&gt;'or'&lt;/code&gt; | &lt;code&gt;'not'&lt;/code&gt; | &lt;code&gt;'xor'&lt;/code&gt; | &lt;code&gt;'andalso'&lt;/code&gt; | &lt;code&gt;'orelse'&lt;/code&gt;</source>
          <target state="translated">BoolFunction :: = &lt;code&gt;is_atom&lt;/code&gt; | &lt;code&gt;is_float&lt;/code&gt; | &lt;code&gt;is_integer&lt;/code&gt; | &lt;code&gt;is_list&lt;/code&gt; | &lt;code&gt;is_number&lt;/code&gt; | &lt;code&gt;is_pid&lt;/code&gt; | &lt;code&gt;is_port&lt;/code&gt; | &lt;code&gt;is_reference&lt;/code&gt; | &lt;code&gt;is_tuple&lt;/code&gt; | &lt;code&gt;is_map&lt;/code&gt; | &lt;code&gt;is_map_key&lt;/code&gt; | &lt;code&gt;is_binary&lt;/code&gt; | &lt;code&gt;is_function&lt;/code&gt; | &lt;code&gt;is_record&lt;/code&gt; | &lt;code&gt;is_seq_trace&lt;/code&gt; | &lt;code&gt;'and'&lt;/code&gt; | &lt;code&gt;'or'&lt;/code&gt; | &lt;code&gt;'not'&lt;/code&gt; | &lt;code&gt;'xor'&lt;/code&gt; | &lt;code&gt;'andalso'&lt;/code&gt; | &lt;code&gt;'orelse'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e3cde099dd0c2860dfd30f6b0378f3f056b13cc7" translate="yes" xml:space="preserve">
          <source>BoolFunction ::= &lt;code&gt;is_atom&lt;/code&gt; | &lt;code&gt;is_float&lt;/code&gt; | &lt;code&gt;is_integer&lt;/code&gt; | &lt;code&gt;is_list&lt;/code&gt; | &lt;code&gt;is_number&lt;/code&gt; | &lt;code&gt;is_pid&lt;/code&gt; | &lt;code&gt;is_port&lt;/code&gt; | &lt;code&gt;is_reference&lt;/code&gt; | &lt;code&gt;is_tuple&lt;/code&gt; | &lt;code&gt;is_map&lt;/code&gt; | &lt;code&gt;map_is_key&lt;/code&gt; | &lt;code&gt;is_binary&lt;/code&gt; | &lt;code&gt;is_function&lt;/code&gt; | &lt;code&gt;is_record&lt;/code&gt; | &lt;code&gt;'and'&lt;/code&gt; | &lt;code&gt;'or'&lt;/code&gt; | &lt;code&gt;'not'&lt;/code&gt; | &lt;code&gt;'xor'&lt;/code&gt; | &lt;code&gt;'andalso'&lt;/code&gt; | &lt;code&gt;'orelse'&lt;/code&gt;</source>
          <target state="translated">BoolFunction :: = &lt;code&gt;is_atom&lt;/code&gt; | &lt;code&gt;is_float&lt;/code&gt; | &lt;code&gt;is_integer&lt;/code&gt; | &lt;code&gt;is_list&lt;/code&gt; | &lt;code&gt;is_number&lt;/code&gt; | &lt;code&gt;is_pid&lt;/code&gt; | &lt;code&gt;is_port&lt;/code&gt; | &lt;code&gt;is_reference&lt;/code&gt; | &lt;code&gt;is_tuple&lt;/code&gt; | &lt;code&gt;is_map&lt;/code&gt; | &lt;code&gt;map_is_key&lt;/code&gt; | &lt;code&gt;is_binary&lt;/code&gt; | &lt;code&gt;is_function&lt;/code&gt; | &lt;code&gt;is_record&lt;/code&gt; | &lt;code&gt;'and'&lt;/code&gt; | &lt;code&gt;'or'&lt;/code&gt; | &lt;code&gt;'not'&lt;/code&gt; | &lt;code&gt;'xor'&lt;/code&gt; | &lt;code&gt;'andalso'&lt;/code&gt; | &lt;code&gt;'orelse'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b76ff4906f33c2dd97ddd929b9662ba8cac6174c" translate="yes" xml:space="preserve">
          <source>Boolean</source>
          <target state="translated">Boolean</target>
        </trans-unit>
        <trans-unit id="60192723d1692fc0b5f8fc179416c38b9c58ae23" translate="yes" xml:space="preserve">
          <source>Boolean expressions</source>
          <target state="translated">ブール式</target>
        </trans-unit>
        <trans-unit id="66182d005e228ccf7ad8ca7af48f43e62e8288b3" translate="yes" xml:space="preserve">
          <source>Boolean operators: &lt;code&gt;not&lt;/code&gt;, &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt;, &lt;code&gt;andalso&lt;/code&gt;, &lt;code&gt;orelse&lt;/code&gt;</source>
          <target state="translated">ブール演算子： &lt;code&gt;not&lt;/code&gt; 、 &lt;code&gt;and&lt;/code&gt; 、 &lt;code&gt;or&lt;/code&gt; 、 &lt;code&gt;andalso&lt;/code&gt; 、 &lt;code&gt;orelse&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ff2372b936c678678613bf8145deb94c379766ad" translate="yes" xml:space="preserve">
          <source>Booleans in ASN.1 express values that can be either &lt;code&gt;TRUE&lt;/code&gt; or &lt;code&gt;FALSE&lt;/code&gt;. The meanings assigned to &lt;code&gt;TRUE&lt;/code&gt; and &lt;code&gt;FALSE&lt;/code&gt; are outside the scope of this text.</source>
          <target state="translated">ASN.1のブール値は、 &lt;code&gt;TRUE&lt;/code&gt; または &lt;code&gt;FALSE&lt;/code&gt; のいずれかの値を表します。 &lt;code&gt;TRUE&lt;/code&gt; および &lt;code&gt;FALSE&lt;/code&gt; に割り当てられた意味は、このテキストの範囲外です。</target>
        </trans-unit>
        <trans-unit id="57f87135d0b5c7204e5e725d7f6d51c65d0e1da6" translate="yes" xml:space="preserve">
          <source>Boot script</source>
          <target state="translated">ブートスクリプト</target>
        </trans-unit>
        <trans-unit id="55cc3a7f7d6ae5f5575682107980e3293f644b52" translate="yes" xml:space="preserve">
          <source>Boot scripts are built using the &lt;code&gt;systools&lt;/code&gt; utility in the SASL application. For more information on &lt;code&gt;systools&lt;/code&gt;, see the SASL documentation. This is only an example of what can be done.</source>
          <target state="translated">ブートスクリプトは、SASLアプリケーションの &lt;code&gt;systools&lt;/code&gt; ユーティリティを使用して構築されます。詳細については &lt;code&gt;systools&lt;/code&gt; 、SASLのマニュアルを参照してください。これは、実行できることのほんの一例です。</target>
        </trans-unit>
        <trans-unit id="a3d4144d275cc7e2f7cb03eca0c38a1d2569fa5e" translate="yes" xml:space="preserve">
          <source>Boot server for other Erlang machines.</source>
          <target state="translated">他のErlangマシン用のブートサーバ。</target>
        </trans-unit>
        <trans-unit id="516f821cffde24557819cc9db18117f3a7da6530" translate="yes" xml:space="preserve">
          <source>Bopomofo</source>
          <target state="translated">Bopomofo</target>
        </trans-unit>
        <trans-unit id="aeca55061b1a7fcf42d399adecf44466466ea1f5" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;GetInfo&lt;/code&gt; and &lt;code&gt;GetBin&lt;/code&gt; must be called within the &lt;code&gt;Fun&lt;/code&gt;. Their behavior is undefined if they are called outside the context of &lt;code&gt;Fun&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;GetInfo&lt;/code&gt; と &lt;code&gt;GetBin&lt;/code&gt; の両方を &lt;code&gt;Fun&lt;/code&gt; 内で呼び出す必要があります。 &lt;code&gt;Fun&lt;/code&gt; のコンテキスト外で呼び出された場合の動作は定義されていません。</target>
        </trans-unit>
        <trans-unit id="088b2c8092f1e119c8753dea210acbd5446d7101" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;WarningList&lt;/code&gt; and &lt;code&gt;ErrorList&lt;/code&gt; have the following format:</source>
          <target state="translated">&lt;code&gt;WarningList&lt;/code&gt; と &lt;code&gt;ErrorList&lt;/code&gt; の両方の形式は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="17f701bc8b6f6001358219750664486c85b21b5d" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;case&lt;/code&gt; and &lt;code&gt;if&lt;/code&gt; have &lt;strong&gt;return values&lt;/strong&gt;, that is, in the above example &lt;code&gt;case&lt;/code&gt; returned either &lt;code&gt;{inch,X/2.54}&lt;/code&gt; or &lt;code&gt;{centimeter,Y*2.54}&lt;/code&gt;. The behaviour of &lt;code&gt;case&lt;/code&gt; can also be modified by using guards. The following example clarifies this. It tells us the length of a month, given the year. The year must be known, since February has 29 days in a leap year.</source>
          <target state="translated">両方の &lt;code&gt;case&lt;/code&gt; と &lt;code&gt;if&lt;/code&gt; 持って&lt;strong&gt;戻り値を&lt;/strong&gt;上記の例において、ある &lt;code&gt;case&lt;/code&gt; いずれか返さ &lt;code&gt;{inch,X/2.54}&lt;/code&gt; 又は &lt;code&gt;{centimeter,Y*2.54}&lt;/code&gt; 。 &lt;code&gt;case&lt;/code&gt; の動作は、ガードを使用して変更することもできます。次の例でこれを明らかにします。年を指定すると、月の長さがわかります。2月のうるう年は29日なので、その年は既知でなければなりません。</target>
        </trans-unit>
        <trans-unit id="28509f91486de7be6923a1aa53ee47118e6db5bf" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;sys&lt;/code&gt; and &lt;code&gt;proc_lib&lt;/code&gt; belong to the STDLIB application.</source>
          <target state="translated">&lt;code&gt;sys&lt;/code&gt; と &lt;code&gt;proc_lib&lt;/code&gt; はどちらもSTDLIBアプリケーションに属しています。</target>
        </trans-unit>
        <trans-unit id="da40d11cd13d54f5078c0119cec66e0ccfe5dfdd" translate="yes" xml:space="preserve">
          <source>Both building with dynamic trace probes and using them is experimental and unsupported by Erlang/OTP. It is included as an option for the developer to trace and debug performance issues in their systems.</source>
          <target state="translated">ダイナミックトレースプローブを使ってビルドすることも、それを使うことも実験的であり、Erlang/OTPではサポートされていません。これは開発者がシステムのパフォーマンス問題をトレースしたりデバッグしたりするためのオプションとして含まれています。</target>
        </trans-unit>
        <trans-unit id="272b41459c2a4ad1e5b3d0281a8c236f1fbb8ef5" translate="yes" xml:space="preserve">
          <source>Both clients and daemons accepts options that controls the exact behaviour. Some options are common to both. The three sets are called &lt;code&gt;&lt;a href=&quot;#type-client_options&quot;&gt;Client Options&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#type-daemon_options&quot;&gt;Daemon Options&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#type-common_options&quot;&gt;Common Options&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">クライアントとデーモンの両方が、正確な動作を制御するオプションを受け入れます。一部のオプションは両方に共通です。3つのセットは、 &lt;code&gt;&lt;a href=&quot;#type-client_options&quot;&gt;Client Options&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;#type-daemon_options&quot;&gt;Daemon Options&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;#type-common_options&quot;&gt;Common Options&lt;/a&gt;&lt;/code&gt; と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="43500df87c9d667061a043ba9cd51b43abef2516" translate="yes" xml:space="preserve">
          <source>Both functions are described in the following.</source>
          <target state="translated">両機能については、以下に説明します。</target>
        </trans-unit>
        <trans-unit id="8393123b8c640d62b0cc06dc60be2e57645d7426" translate="yes" xml:space="preserve">
          <source>Both increasing and decreasing &lt;code&gt;&amp;lt;IdRange&amp;gt;&lt;/code&gt;s are allowed.</source>
          <target state="translated">&lt;code&gt;&amp;lt;IdRange&amp;gt;&lt;/code&gt; の増加と減少の両方が許可されます。</target>
        </trans-unit>
        <trans-unit id="84d91e83adcd109e53d7f1d1718f4d0e6a80ae0d" translate="yes" xml:space="preserve">
          <source>Both mechanisms have the same theoretical time and memory complexity, while the selective receive language construct has smaller constant factors.</source>
          <target state="translated">どちらのメカニズムも理論的には同じ時間とメモリの複雑さを持っていますが、選択的な受信言語構成はより小さな定数要因を持っています。</target>
        </trans-unit>
        <trans-unit id="c1196a55702bdb5abaf2deea06cedc05c7a896fe" translate="yes" xml:space="preserve">
          <source>Both of them can be empty, but not at the same time. If &lt;code&gt;&amp;lt;ChangedAppVersions&amp;gt;&lt;/code&gt; is empty, no changes have been made that change the build result of any application. This could, for example, be a pure bug fix of the build system. The order of lines is undefined. All white-space characters in this file are either space (character 32) or line-break (character 10).</source>
          <target state="translated">両方を空にすることはできますが、同時にはできません。場合 &lt;code&gt;&amp;lt;ChangedAppVersions&amp;gt;&lt;/code&gt; が空で、変更はその変化の任意のアプリケーションのビルド結果なされていません。これは、たとえば、ビルドシステムの純粋なバグ修正である可能性があります。行の順序は定義されていません。このファイルのすべての空白文字は、スペース（文字32）または改行（文字10）のいずれかです。</target>
        </trans-unit>
        <trans-unit id="3442514fe2989d64511fbe704d87cbeac484a561" translate="yes" xml:space="preserve">
          <source>Both old and current code for a module are valid, and can even be evaluated concurrently. The difference is that exported functions in old code are unavailable. Hence, a global call cannot be made to an exported function in old code, but old code can still be evaluated because of processes lingering in it.</source>
          <target state="translated">モジュールの古いコードと現在のコードの両方が有効で、同時に評価することもできます。違いは、古いコードのエクスポートされた関数が利用できないことです。そのため、古いコード内のエクスポートされた関数に対してグローバルコールを行うことはできませんが、古いコード内にプロセスが残っているため、古いコードを評価することはできます。</target>
        </trans-unit>
        <trans-unit id="0a81666107cfaaf40864441b74f9792a8cc7fb8a" translate="yes" xml:space="preserve">
          <source>Both old and current code is valid, and can be evaluated concurrently. Fully qualified function calls always refer to current code. Old code can still be evaluated because of processes lingering in the old code.</source>
          <target state="translated">古いコードと現在のコードの両方が有効で、同時に評価することができます。完全修飾された関数呼び出しは常に現在のコードを参照します。古いコードは、古いコードの中にプロセスが残っているため、まだ評価できます。</target>
        </trans-unit>
        <trans-unit id="19893bb20867dad51e674f2c8283aa35e37963b9" translate="yes" xml:space="preserve">
          <source>Both options give the same effect, the input string is interpreted as UTF-8. Notice that with these instructions, the automatic conversion of lists to UTF-8 is not performed by the &lt;code&gt;re&lt;/code&gt; functions. Therefore, using these sequences is not recommended. Add option &lt;code&gt;unicode&lt;/code&gt; when running &lt;code&gt;&lt;a href=&quot;#compile-2&quot;&gt;compile/2&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">どちらのオプションでも同じ効果が得られ、入力文字列はUTF-8として解釈されます。これらの指示では、リストのUTF-8への自動変換は &lt;code&gt;re&lt;/code&gt; 関数によって実行されないことに注意してください。したがって、これらのシーケンスの使用はお勧めできません。代わりに &lt;code&gt;&lt;a href=&quot;#compile-2&quot;&gt;compile/2&lt;/a&gt;&lt;/code&gt; を実行するときにオプション &lt;code&gt;unicode&lt;/code&gt; を追加します。</target>
        </trans-unit>
        <trans-unit id="04f750b6f7ecf467d03fd155880c2c08a8e8637a" translate="yes" xml:space="preserve">
          <source>Both server and event manager are registered processes which can be expected to be always accessible. Thus they are specified to be &lt;code&gt;permanent&lt;/code&gt;.</source>
          <target state="translated">サーバーとイベントマネージャの両方が登録されたプロセスであり、常にアクセス可能であることが期待できます。したがって、それらは &lt;code&gt;permanent&lt;/code&gt; あると指定されています。</target>
        </trans-unit>
        <trans-unit id="57dd8748ee1441894d656dd738cdc13c745b3ff2" translate="yes" xml:space="preserve">
          <source>Both source code and object code for the module is found.</source>
          <target state="translated">モジュールのソースコードとオブジェクトコードの両方が見つかりました。</target>
        </trans-unit>
        <trans-unit id="e0ebc6ec0ff8694d627315dcce4507da48f45e45" translate="yes" xml:space="preserve">
          <source>Both the agent and the manager can be configured to log incoming and outgoing messages. It uses the Erlang standard log mechanism &lt;code&gt;disk_log&lt;/code&gt; for logging. The size and location of the log files are configurable. A wrap log is used, which means that when the log has grown to a maximum size, it starts from the beginning of the log, overwriting existing log records.</source>
          <target state="translated">エージェントとマネージャーの両方を構成して、着信メッセージと発信メッセージをログに記録することができます。ロギングには、Erlangの標準ログメカニズム &lt;code&gt;disk_log&lt;/code&gt; を使用します。ログファイルのサイズと場所は設定可能です。ラップログが使用されます。つまり、ログが最大サイズに達すると、ログの先頭から開始され、既存のログレコードが上書きされます。</target>
        </trans-unit>
        <trans-unit id="31ef6ae37976246cbbb8302e6168cf2ddacebc06" translate="yes" xml:space="preserve">
          <source>Both the module declaration and the export declaration of the &lt;code&gt;main/1&lt;/code&gt; function are optional.</source>
          <target state="translated">&lt;code&gt;main/1&lt;/code&gt; 関数のモジュール宣言とエクスポート宣言はオプションです。</target>
        </trans-unit>
        <trans-unit id="19b296fa85d6e817ce8e73a30a0d4e4ab33ce24a" translate="yes" xml:space="preserve">
          <source>Both the old and new versions of the &lt;code&gt;.app&lt;/code&gt; and &lt;code&gt;.rel&lt;/code&gt; files must be in the code path, as well as the &lt;code&gt;.appup&lt;/code&gt; and (new) &lt;code&gt;.beam&lt;/code&gt; files. The code path can be extended by using the option &lt;code&gt;path&lt;/code&gt;:</source>
          <target state="translated">古いバージョンと新しいバージョンの両方 &lt;code&gt;.app&lt;/code&gt; と &lt;code&gt;.rel&lt;/code&gt; ファイルは、コードパス、などでなければなりません &lt;code&gt;.appup&lt;/code&gt; と（新） &lt;code&gt;.beam&lt;/code&gt; のファイル。コードパスは、オプション &lt;code&gt;path&lt;/code&gt; を使用して拡張できます。</target>
        </trans-unit>
        <trans-unit id="b2a0efd65a8f4b932941a27e1ed06208576cd1ee" translate="yes" xml:space="preserve">
          <source>Both the registration and lock services are atomic. All nodes involved in these actions have the same view of the information.</source>
          <target state="translated">登録サービスとロックサービスはどちらもアトミックです。これらのアクションに関与するすべてのノードは、情報を同じように見ることができます。</target>
        </trans-unit>
        <trans-unit id="a1ccfade4aa63d420f2f18a1184490432f9a36ed" translate="yes" xml:space="preserve">
          <source>Both these tools use the message package (time_test.msgs) provided with the tool(s), although it can run on any message package as long as it has the same structure.</source>
          <target state="translated">これらのツールはどちらもツールに付属のメッセージパッケージ(time_test.msgs)を使用しますが、同じ構造を持っている限り、どのメッセージパッケージでも実行できます。</target>
        </trans-unit>
        <trans-unit id="127d494892f18e1ed814ec5250b9730b0af20bb3" translate="yes" xml:space="preserve">
          <source>Both times are in milli seconds.</source>
          <target state="translated">いずれもミリ秒単位です。</target>
        </trans-unit>
        <trans-unit id="1ccbfe9c0e689e8b9dc53b4b4ec4a1a3a8c73326" translate="yes" xml:space="preserve">
          <source>Both transport security at connection establishment and negotiated via an Inband-Security AVP are supported.</source>
          <target state="translated">接続確立時のトランスポート・セキュリティと、インバンド・セキュリティ AVP を介してネゴシエートされたトランスポート・セキュリティの両方がサポートされています。</target>
        </trans-unit>
        <trans-unit id="6c92949313aaa03bcf35ffa7934493789f21f7cd" translate="yes" xml:space="preserve">
          <source>Both when the client establishes a connection with ssh:connect or other functions, or a daemon is started with ssh:daemon, the option lists in the function calls are also used.</source>
          <target state="translated">クライアントが ssh:connect などの関数で接続を確立するときも、ssh:daemon でデーモンを起動するときも、関数呼び出しのオプションリストが使用されます。</target>
        </trans-unit>
        <trans-unit id="0c0eaabc27903558b46afc5c85515d4a1d0fc689" translate="yes" xml:space="preserve">
          <source>Bound on the expected size of incoming Diameter messages. Messages larger than the specified number of bytes are discarded.</source>
          <target state="translated">受信するDiameterメッセージの予想サイズに制限があります。指定されたバイト数よりも大きいメッセージは破棄されます。</target>
        </trans-unit>
        <trans-unit id="0021328dee4879f40d348f1597841de3b466cc17" translate="yes" xml:space="preserve">
          <source>Bound parts (Erlang terms)</source>
          <target state="translated">境界部分 (Erlang用語)</target>
        </trans-unit>
        <trans-unit id="24afa8c574a58ec588a649b2ee14b50d33a8ca50" translate="yes" xml:space="preserve">
          <source>Braille</source>
          <target state="translated">Braille</target>
        </trans-unit>
        <trans-unit id="5ff74b881495206c989aabf9a3102e44cc4e4f4e" translate="yes" xml:space="preserve">
          <source>Branch to &lt;code&gt;$Fail&lt;/code&gt;. Suppresses generation of dispatch of the next instruction (&lt;code&gt;-no_next&lt;/code&gt;). Typical use:</source>
          <target state="translated">&lt;code&gt;$Fail&lt;/code&gt; 分岐します。次の命令（ &lt;code&gt;-no_next&lt;/code&gt; ）のディスパッチの生成を抑制します。典型的な使用法：</target>
        </trans-unit>
        <trans-unit id="29ee5bc7776fe10e3fd6ef23bda664af1a74f8a6" translate="yes" xml:space="preserve">
          <source>Branch to &lt;code&gt;$Fail&lt;/code&gt;. Will suppress prefetch (&lt;code&gt;-no_prefetch&lt;/code&gt;). Typical use:</source>
          <target state="translated">&lt;code&gt;$Fail&lt;/code&gt; 分岐します。プリフェッチを抑制します（ &lt;code&gt;-no_prefetch&lt;/code&gt; ）。典型的な使用法：</target>
        </trans-unit>
        <trans-unit id="acd5609c99b4261f4b2a9f0f2cd2cd2a63fc35c8" translate="yes" xml:space="preserve">
          <source>Branches off an existing association &lt;code&gt;Assoc&lt;/code&gt; in a socket &lt;code&gt;Socket&lt;/code&gt; of type &lt;code&gt;seqpacket&lt;/code&gt; (one-to-many style) into a new socket &lt;code&gt;NewSocket&lt;/code&gt; of type &lt;code&gt;stream&lt;/code&gt; (one-to-one style).</source>
          <target state="translated">タイプ &lt;code&gt;seqpacket&lt;/code&gt; （1対多スタイル）のソケット &lt;code&gt;Socket&lt;/code&gt; の既存の関連付け &lt;code&gt;Assoc&lt;/code&gt; を、タイプ &lt;code&gt;stream&lt;/code&gt; （1対1スタイル）の新しいソケット &lt;code&gt;NewSocket&lt;/code&gt; に分岐します。</target>
        </trans-unit>
        <trans-unit id="7fb13ed24388f546ddc4203cc04ff019ad463378" translate="yes" xml:space="preserve">
          <source>Branches that match different length strings are permitted only at the top-level of a lookbehind assertion. This is an extension compared with Perl, which requires all branches to match the same length of string. An assertion such as the following is not permitted, as its single top-level branch can match two different lengths:</source>
          <target state="translated">異なる長さの文字列にマッチするブランチは、lookbehind アサーションのトップレベルでのみ許可されます。これは、すべてのブランチが同じ長さの文字列にマッチしなければならない Perl と比較して拡張されたものです。以下のようなアサーションは許可されていません。</target>
        </trans-unit>
        <trans-unit id="2e74a43e735ca8cd77a918952d725756f6ea7331" translate="yes" xml:space="preserve">
          <source>Break Menu</source>
          <target state="translated">ブレイクメニュー</target>
        </trans-unit>
        <trans-unit id="d1151e1739c46421831435065fa64d3a4378e7dc" translate="yes" xml:space="preserve">
          <source>Break, Windows, and Help Menus</source>
          <target state="translated">ブレーク、ウィンドウ、ヘルプメニュー</target>
        </trans-unit>
        <trans-unit id="e5a0f50acb3dd75574af8408fef3b88b8ceb46b5" translate="yes" xml:space="preserve">
          <source>Breaking up a long-running function in this manner enables the VM to regain control between calls to the NIFs.</source>
          <target state="translated">このようにしてロングラン関数をブレークアップすることで、VMはNIFへの呼び出しの間に制御を取り戻すことができます。</target>
        </trans-unit>
        <trans-unit id="8bdcc7199154fffd9f8d9a9848283a3809fc361e" translate="yes" xml:space="preserve">
          <source>Breakpoints are created and deleted using the &lt;strong&gt;Break&lt;/strong&gt; menu of either the Monitor window, View Module window, or Attach Process window.</source>
          <target state="translated">ブレークポイントは、[モニター]ウィンドウ、[モジュールの表示]ウィンドウ、または[プロセスのアタッチ]ウィンドウの[ &lt;strong&gt;ブレーク&lt;/strong&gt; ]メニューを使用して作成および削除されます。</target>
        </trans-unit>
        <trans-unit id="7a8d8f460f3a399bfb04e89862d06e9b316c1004" translate="yes" xml:space="preserve">
          <source>Breakpoints are marked with a stop symbol.</source>
          <target state="translated">ブレークポイントにはストップマークが付いています。</target>
        </trans-unit>
        <trans-unit id="e0fac70209382c8083fb51c23797738064b31d35" translate="yes" xml:space="preserve">
          <source>Breakpoints are specified on a line basis. When a process executing code in an interpreted module reaches a breakpoint, it stops. This means that a breakpoint must be set at an executable line, that is, a code line containing an executable expression.</source>
          <target state="translated">ブレークポイントは行単位で指定します。インタプリタモジュール内のコードを実行しているプロセスがブレークポイントに到達すると停止します。つまり、ブレークポイントは実行可能な行、つまり実行可能な式を含むコード行に設定しなければなりません。</target>
        </trans-unit>
        <trans-unit id="fbbe2bd05741e651732db1439c4df7101add2a7e" translate="yes" xml:space="preserve">
          <source>Briefly on Solaris 10</source>
          <target state="translated">Solaris 10 について簡単に説明します。</target>
        </trans-unit>
        <trans-unit id="2c54c32cef81a294e27f0b55c17e9d3989656be7" translate="yes" xml:space="preserve">
          <source>Broadcasts on a condition variable. That is, if other threads are waiting on the condition variable being broadcast on, &lt;strong&gt;all&lt;/strong&gt; of them are woken.</source>
          <target state="translated">条件変数でブロードキャストします。つまり、ブロードキャストされている条件変数で他のスレッドが待機している場合、それら&lt;strong&gt;すべて&lt;/strong&gt;が起こされます。</target>
        </trans-unit>
        <trans-unit id="298841afbb7ef24f7711e916938def078c174299" translate="yes" xml:space="preserve">
          <source>Broadcasts the message &lt;code&gt;Msg&lt;/code&gt; asynchronously to the registered process &lt;code&gt;Name&lt;/code&gt; on the specified nodes.</source>
          <target state="translated">メッセージ &lt;code&gt;Msg&lt;/code&gt; を指定したノードの登録済みプロセス &lt;code&gt;Name&lt;/code&gt; に非同期でブロードキャストします。</target>
        </trans-unit>
        <trans-unit id="0e9067bfac6a20153ac4defbe476694c9b168a4a" translate="yes" xml:space="preserve">
          <source>Broadcasts the message &lt;code&gt;Msg&lt;/code&gt; synchronously to the registered process &lt;code&gt;Name&lt;/code&gt; on the specified nodes.</source>
          <target state="translated">メッセージ &lt;code&gt;Msg&lt;/code&gt; を指定したノードの登録済みプロセス &lt;code&gt;Name&lt;/code&gt; に同期してブロードキャストします。</target>
        </trans-unit>
        <trans-unit id="e87af70cba1f1e451d37824609594b2a73b9bafc" translate="yes" xml:space="preserve">
          <source>Browse the application configuration file (do &lt;strong&gt;not&lt;/strong&gt; edit it). The full name of the application configuration file is derived from the position of the &lt;code&gt;os_mon&lt;/code&gt; application in the file system by adding &lt;code&gt;/ebin/os_mon.app&lt;/code&gt;.</source>
          <target state="translated">アプリケーション構成ファイルを参照します（編集し&lt;strong&gt;ない&lt;/strong&gt;でください）。アプリケーション構成ファイルの完全な名前は、 &lt;code&gt;/ebin/os_mon.app&lt;/code&gt; を追加することにより、ファイルシステム内の &lt;code&gt;os_mon&lt;/code&gt; アプリケーションの位置から取得されます。</target>
        </trans-unit>
        <trans-unit id="8d698cd7b5307da0633f70f00f726e5dbe00ea1a" translate="yes" xml:space="preserve">
          <source>Browses table &lt;code&gt;Tab&lt;/code&gt; on a terminal.</source>
          <target state="translated">端末のテーブル &lt;code&gt;Tab&lt;/code&gt; を参照します。</target>
        </trans-unit>
        <trans-unit id="f47b617427a681f5cc68845744e7adc91ae07ed8" translate="yes" xml:space="preserve">
          <source>Browsing the html pages by loading the page &lt;code&gt;/usr/local/lib/erlang/doc/erlang/index.html&lt;/code&gt; or &lt;code&gt;&amp;lt;BaseDir&amp;gt;/lib/erlang/doc/erlang/index.html&lt;/code&gt; if the prefix option has been used.</source>
          <target state="translated">ページ &lt;code&gt;/usr/local/lib/erlang/doc/erlang/index.html&lt;/code&gt; または &lt;code&gt;&amp;lt;BaseDir&amp;gt;/lib/erlang/doc/erlang/index.html&lt;/code&gt; (prefixオプションが使用されている場合）をロードして、htmlページを参照します。</target>
        </trans-unit>
        <trans-unit id="792fdd1cd5fd403216843c6560d9bf75c37a3a2e" translate="yes" xml:space="preserve">
          <source>Buf is initialized to contain object attributes.</source>
          <target state="translated">Bufはオブジェクト属性を格納するために初期化されます。</target>
        </trans-unit>
        <trans-unit id="3caca7ca1e839168f274364c9d0c4a80119c3d3a" translate="yes" xml:space="preserve">
          <source>Buffer is too small.</source>
          <target state="translated">バッファが小さすぎます。</target>
        </trans-unit>
        <trans-unit id="c32cae74e192e8ea56db8683dfa3876fd9fa316b" translate="yes" xml:space="preserve">
          <source>Buginese</source>
          <target state="translated">Buginese</target>
        </trans-unit>
        <trans-unit id="c8eea1b80ba437eb2c7d9d8e4a7a1c0c36ddce4e" translate="yes" xml:space="preserve">
          <source>Bugs</source>
          <target state="translated">Bugs</target>
        </trans-unit>
        <trans-unit id="f55777a6f9cd8a9c1199724cddc2f176cde4e922" translate="yes" xml:space="preserve">
          <source>Buhid</source>
          <target state="translated">Buhid</target>
        </trans-unit>
        <trans-unit id="5e39e7697b21824bcc7130368908ca3db3109308" translate="yes" xml:space="preserve">
          <source>Build Erlang/OTP</source>
          <target state="translated">Erlang/OTPを構築する</target>
        </trans-unit>
        <trans-unit id="da71556c2060cac2828b51ce118c10a5f1cb07b2" translate="yes" xml:space="preserve">
          <source>Build Issues</source>
          <target state="translated">ビルドの問題</target>
        </trans-unit>
        <trans-unit id="9bd5d4eae87e4cb4572c4356e658e62097907c06" translate="yes" xml:space="preserve">
          <source>Build Your Own Tool</source>
          <target state="translated">独自のツールを構築する</target>
        </trans-unit>
        <trans-unit id="82de423db4cc623ec5f04ba52bfec4b055f722a1" translate="yes" xml:space="preserve">
          <source>Build or install the FIPS Object Module and a FIPS enabled OpenSSL library.</source>
          <target state="translated">FIPS オブジェクトモジュールと FIPS 対応 OpenSSL ライブラリをビルドまたはインストールします。</target>
        </trans-unit>
        <trans-unit id="0ca44d234eb0f2b9b591c5ee4decd555e8ce199c" translate="yes" xml:space="preserve">
          <source>Build the Erlang/OTP release.</source>
          <target state="translated">Erlang/OTPリリースをビルドする。</target>
        </trans-unit>
        <trans-unit id="07f491f3b5c090f34f2ee3e97cafbb3c5f5f8099" translate="yes" xml:space="preserve">
          <source>Build the boot script.</source>
          <target state="translated">ブートスクリプトをビルドします。</target>
        </trans-unit>
        <trans-unit id="77d5d2f2a5f4a3ffbde6ae0d3e363ac721059f26" translate="yes" xml:space="preserve">
          <source>Build the documentation.</source>
          <target state="translated">ドキュメントを構築します。</target>
        </trans-unit>
        <trans-unit id="a24b09d07965fb944dc46c1d07ebc9828be50298" translate="yes" xml:space="preserve">
          <source>Build with:</source>
          <target state="translated">で構築します。</target>
        </trans-unit>
        <trans-unit id="55d9080383317c03f360d21bbd25b0561e946784" translate="yes" xml:space="preserve">
          <source>Building Erlang/OTP can be done either by using the &lt;code&gt;$ERL_TOP/otp_build&lt;/code&gt; script, or by invoking &lt;code&gt;$ERL_TOP/configure&lt;/code&gt; and &lt;code&gt;make&lt;/code&gt; directly. Building using &lt;code&gt;otp_build&lt;/code&gt; is easier since it involves fewer steps, but the &lt;code&gt;otp_build&lt;/code&gt; build procedure is not as flexible as the &lt;code&gt;configure&lt;/code&gt;/&lt;code&gt;make&lt;/code&gt; build procedure. Note that &lt;code&gt;otp_build configure&lt;/code&gt; will produce a default configuration that differs from what &lt;code&gt;configure&lt;/code&gt; will produce by default. For example, currently &lt;code&gt;--disable-dynamic-ssl-lib&lt;/code&gt; is added to the &lt;code&gt;configure&lt;/code&gt; command line arguments unless &lt;code&gt;--enable-dynamic-ssl-lib&lt;/code&gt; has been explicitly passed. The binary releases that we deliver are built using &lt;code&gt;otp_build&lt;/code&gt;. The defaults used by &lt;code&gt;otp_build configure&lt;/code&gt; may change at any time without prior notice.</source>
          <target state="translated">ビルのErlang / OTPを使用してのいずれかで行うことができる &lt;code&gt;$ERL_TOP/otp_build&lt;/code&gt; 、スクリプトを呼び出すことによって、または &lt;code&gt;$ERL_TOP/configure&lt;/code&gt; して &lt;code&gt;make&lt;/code&gt; 直接。 &lt;code&gt;otp_build&lt;/code&gt; を使用したビルドは、手順が少ないので簡単ですが、 &lt;code&gt;otp_build&lt;/code&gt; ビルド手順は、 &lt;code&gt;configure&lt;/code&gt; / &lt;code&gt;make&lt;/code&gt; ビルド手順ほど柔軟ではありません。注こと &lt;code&gt;otp_build configure&lt;/code&gt; はデフォルトの設定を生成することが何より異なり &lt;code&gt;configure&lt;/code&gt; はデフォルトで生成されます。たとえば、現在 &lt;code&gt;--enable-dynamic-ssl-lib&lt;/code&gt; でない限り、現在 &lt;code&gt;--disable-dynamic-ssl-lib&lt;/code&gt; が &lt;code&gt;configure&lt;/code&gt; コマンドライン引数に追加されています。明示的に渡されました。提供するバイナリリリースは、 &lt;code&gt;otp_build&lt;/code&gt; を使用してビルドされています。 &lt;code&gt;otp_build configure&lt;/code&gt; で使用されるデフォルトは、事前の通知なしにいつでも変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="0288be29544ae6b8e621446c1d716ba731ebd705" translate="yes" xml:space="preserve">
          <source>Building Erlang/OTP can be done either by using the &lt;code&gt;$ERL_TOP/otp_build&lt;/code&gt; script, or by invoking &lt;code&gt;$ERL_TOP/configure&lt;/code&gt; and &lt;code&gt;make&lt;/code&gt; directly. Building using &lt;code&gt;otp_build&lt;/code&gt; is easier since it involves fewer steps, but the &lt;code&gt;otp_build&lt;/code&gt; build procedure is not as flexible as the &lt;code&gt;configure&lt;/code&gt;/&lt;code&gt;make&lt;/code&gt; build procedure. The binary releases for Windows that we deliver are built using &lt;code&gt;otp_build&lt;/code&gt;.</source>
          <target state="translated">ビルのErlang / OTPを使用してのいずれかで行うことができる &lt;code&gt;$ERL_TOP/otp_build&lt;/code&gt; 、スクリプトを呼び出すことによって、または &lt;code&gt;$ERL_TOP/configure&lt;/code&gt; して &lt;code&gt;make&lt;/code&gt; 直接。 &lt;code&gt;otp_build&lt;/code&gt; を使用したビルドは、手順が少ないので簡単ですが、 &lt;code&gt;otp_build&lt;/code&gt; ビルド手順は、 &lt;code&gt;configure&lt;/code&gt; / &lt;code&gt;make&lt;/code&gt; ビルド手順ほど柔軟ではありません。提供するWindowsのバイナリリリースは、 &lt;code&gt;otp_build&lt;/code&gt; を使用してビルドされています。</target>
        </trans-unit>
        <trans-unit id="f9a1d72262f0ba28560224e8b5f84f82d3a37931" translate="yes" xml:space="preserve">
          <source>Building Erlang/OTP on a relatively fast computer takes approximately 5 minutes. To speed it up, you can utilize parallel make with the &lt;code&gt;-j&amp;lt;num_jobs&amp;gt;&lt;/code&gt; option.</source>
          <target state="translated">比較的高速なコンピューターでErlang / OTPをビルドするには、約5分かかります。高速化するには、 &lt;code&gt;-j&amp;lt;num_jobs&amp;gt;&lt;/code&gt; オプションを指定して並列makeを利用できます。</target>
        </trans-unit>
        <trans-unit id="9ef5793998a525a29078ba78dcc6651a8e69241f" translate="yes" xml:space="preserve">
          <source>Building a Bootstrap System</source>
          <target state="translated">ブートストラップシステムの構築</target>
        </trans-unit>
        <trans-unit id="6fcd9e84832d8fc06ff9412088752b9ac40d1d27" translate="yes" xml:space="preserve">
          <source>Building in Git</source>
          <target state="translated">Gitでの構築</target>
        </trans-unit>
        <trans-unit id="6e610827003738b99e768b26958b3f36694ff33c" translate="yes" xml:space="preserve">
          <source>Building is easiest using the &lt;code&gt;otp_build&lt;/code&gt; script:</source>
          <target state="translated">ビルドは、 &lt;code&gt;otp_build&lt;/code&gt; スクリプトを使用するのが最も簡単です。</target>
        </trans-unit>
        <trans-unit id="840f8d32dc79d0e6d7906ca187022ffdcd65d433" translate="yes" xml:space="preserve">
          <source>Building on OS X</source>
          <target state="translated">OS X上でのビルド</target>
        </trans-unit>
        <trans-unit id="0919d6c99c47efcb70329ed0ebdeb92cd58e964c" translate="yes" xml:space="preserve">
          <source>Building terms and patterns</source>
          <target state="translated">建築用語とパターン</target>
        </trans-unit>
        <trans-unit id="d7b4eea65f50794546e0a9cd2e50530baa9d4e3f" translate="yes" xml:space="preserve">
          <source>Building with wxErlang</source>
          <target state="translated">wxErlangを使ったビルド</target>
        </trans-unit>
        <trans-unit id="03d9659d4e51ca391a6e1291a5a6e5195ec7e16f" translate="yes" xml:space="preserve">
          <source>Building with wxWidgets. Download wxWidgets-3.0.3 or higher.</source>
          <target state="translated">wxWidgetsを使ったビルド。wxWidgets-3.0.3以上をダウンロードしてください。</target>
        </trans-unit>
        <trans-unit id="5a48efe1163ff4f604b0e75b0f8069e848d42294" translate="yes" xml:space="preserve">
          <source>Builds a BEAM module (as a binary) from a list of chunks.</source>
          <target state="translated">チャンクのリストから(バイナリとして)BEAMモジュールを構築します。</target>
        </trans-unit>
        <trans-unit id="04266b7610bbe7204641a5a18f1b641cc5a4ad92" translate="yes" xml:space="preserve">
          <source>Builds an internal structure representing a compilation of a search pattern, later to be used in functions &lt;code&gt;&lt;a href=&quot;#match-3&quot;&gt;match/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#matches-3&quot;&gt;matches/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#split-3&quot;&gt;split/3&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#replace-4&quot;&gt;replace/4&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;cp()&lt;/code&gt; returned is guaranteed to be a &lt;code&gt;tuple()&lt;/code&gt; to allow programs to distinguish it from non-precompiled search patterns.</source>
          <target state="translated">検索パターンのコンパイルを表す内部構造を構築し、後で関数 &lt;code&gt;&lt;a href=&quot;#match-3&quot;&gt;match/3&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;#matches-3&quot;&gt;matches/3&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;#split-3&quot;&gt;split/3&lt;/a&gt;&lt;/code&gt; 、または &lt;code&gt;&lt;a href=&quot;#replace-4&quot;&gt;replace/4&lt;/a&gt;&lt;/code&gt; で使用します。 &lt;code&gt;cp()&lt;/code&gt; 返されることが保証されている &lt;code&gt;tuple()&lt;/code&gt; プログラムは、非プリコンパイルされた検索パターンと区別できるようにします。</target>
        </trans-unit>
        <trans-unit id="20f409cc87c744070ec80e942947a590f8db80d1" translate="yes" xml:space="preserve">
          <source>Built-in</source>
          <target state="translated">Built-in</target>
        </trans-unit>
        <trans-unit id="3685c8c87d2a5725cbc54a94228a1a89d1d88a57" translate="yes" xml:space="preserve">
          <source>Built-in term storage.</source>
          <target state="translated">ビルトイン式のタームストレージ。</target>
        </trans-unit>
        <trans-unit id="0bb738fd2329e288e2fef0e51024a5ca1fdbc3e0" translate="yes" xml:space="preserve">
          <source>Busy Port Queue</source>
          <target state="translated">ビジーポートキュー</target>
        </trans-unit>
        <trans-unit id="6c5c53caa503fd2d5724e0037aba0a5ac29a1adc" translate="yes" xml:space="preserve">
          <source>But &lt;code&gt;'ssh-dss'&lt;/code&gt; is selected although the call inserted &lt;strong&gt;only&lt;/strong&gt;&lt;code&gt;'ecdsa-sha2-nistp256'&lt;/code&gt; as acceptable.</source>
          <target state="translated">ただし、 &lt;code&gt;'ssh-dss'&lt;/code&gt; が選択されていますが、呼び出し&lt;strong&gt;は&lt;/strong&gt; &lt;code&gt;'ecdsa-sha2-nistp256'&lt;/code&gt; のみを受け入れ可能として挿入しました。</target>
        </trans-unit>
        <trans-unit id="298adb411a18178593c4d780e03d5a00362414a8" translate="yes" xml:space="preserve">
          <source>But before all name servers are tried again, there is a (user configurable) timeout, &lt;code&gt;servfail_retry_timeout&lt;/code&gt;. The point of this is to prevent the new query to be handled by to the servfail cache (a client that is to eager will actually only get what is in the servfail cache).</source>
          <target state="translated">ただし、すべてのネームサーバーが再試行される前に、（ユーザーが構成可能な）タイムアウト &lt;code&gt;servfail_retry_timeout&lt;/code&gt; があります。これのポイントは、servfailキャッシュに対して新しいクエリが処理されないようにすることです（熱心なクライアントは、実際にはservfailキャッシュにあるものだけを取得します）。</target>
        </trans-unit>
        <trans-unit id="cb37192b82c7544aec29ebacff8270ec18c0cbee" translate="yes" xml:space="preserve">
          <source>But how can the client know that the host</source>
          <target state="translated">しかし、クライアントはホストが</target>
        </trans-unit>
        <trans-unit id="5849712291c78b1a99987a87b4b4819b9538fc4d" translate="yes" xml:space="preserve">
          <source>But if a constant is sent to another process (or stored in an Ets table), it is &lt;strong&gt;copied&lt;/strong&gt;. The reason is that the runtime system must be able to keep track of all references to constants to unload code containing constants properly. (When the code is unloaded, the constants are copied to the heap of the processes that refer to them.) The copying of constants might be eliminated in a future Erlang/OTP release.</source>
          <target state="translated">ただし、定数が別のプロセスに送信される（またはEtsテーブルに格納される）場合、その定数は&lt;strong&gt;コピーされ&lt;/strong&gt;ます。その理由は、ランタイムシステムは、定数を含むコードを適切にアンロードするために、定数へのすべての参照を追跡できなければならないからです。（コードがアンロードされると、定数はそれらを参照するプロセスのヒープにコピーされます。）定数のコピーは、将来のErlang / OTPリリースで削除される可能性があります。</target>
        </trans-unit>
        <trans-unit id="12383ec381d6eef21e12692f3a3beac567f979cb" translate="yes" xml:space="preserve">
          <source>But in more complicated code, how can one know whether the optimization is applied or not?</source>
          <target state="translated">しかし、より複雑なコードでは、最適化が適用されているかどうかをどうやって知ることができるのでしょうか?</target>
        </trans-unit>
        <trans-unit id="13e80088d58b6e2e78ae703a190df34ce17a3ab1" translate="yes" xml:space="preserve">
          <source>But it will generate code that builds a sub binary in the first clause:</source>
          <target state="translated">しかし、それは最初の節でサブバイナリをビルドするコードを生成します。</target>
        </trans-unit>
        <trans-unit id="a0a27a5b2ec989d8d33e3ef99ff2c029f3ccadb0" translate="yes" xml:space="preserve">
          <source>But that is history. Funs was given its own data type in R6B and was further optimized in R7B. Now the cost for a fun call falls roughly between the cost for a call to a local function and &lt;code&gt;apply/3&lt;/code&gt;.</source>
          <target state="translated">しかし、それは歴史です。FunsはR6Bで独自のデータ型を与えられ、R7Bでさらに最適化されました。これで、fun呼び出しのコストは、ローカル関数の呼び出しのコストと &lt;code&gt;apply/3&lt;/code&gt; のほぼ中間になります。</target>
        </trans-unit>
        <trans-unit id="ff87650cc86869f3f95aa712bb2012bf312a0ec1" translate="yes" xml:space="preserve">
          <source>But they &lt;strong&gt;cannot&lt;/strong&gt; be combined with intAgentTransports.</source>
          <target state="translated">ただし、intAgentTransportsと組み合わせる&lt;strong&gt;ことはできません&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="9edeffd1c02cedcbcf042627c2b5c0c907cde008" translate="yes" xml:space="preserve">
          <source>But this fails as Fred has already logged off.</source>
          <target state="translated">しかし、フレッドはすでにログオフしているので、これは失敗です。</target>
        </trans-unit>
        <trans-unit id="3c55fef2a765c8d16ab4eacfbd4c2a04ae1406db" translate="yes" xml:space="preserve">
          <source>But this fails:</source>
          <target state="translated">しかし、これは失敗する。</target>
        </trans-unit>
        <trans-unit id="ae29bf624e4dd4338883041af300ffb73e4829e9" translate="yes" xml:space="preserve">
          <source>But this is not enough. There is also a set of &lt;strong&gt;mandatory&lt;/strong&gt; messages which the network interface entity must be able to receive and be able to send. This is described in chapter &lt;code&gt;&lt;a href=&quot;snmp_agent_netif&quot;&gt;snmp_agent_netif&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">しかし、これでは十分ではありません。また、ネットワークインターフェースエンティティが受信および送信できる必要がある一連の&lt;strong&gt;必須&lt;/strong&gt;メッセージもあります。これについては、 &lt;code&gt;&lt;a href=&quot;snmp_agent_netif&quot;&gt;snmp_agent_netif&lt;/a&gt;&lt;/code&gt; の章で説明しています。</target>
        </trans-unit>
        <trans-unit id="45778b54cb8ef168c982efffe69e2d8b502fce93" translate="yes" xml:space="preserve">
          <source>But using &lt;code&gt;++&lt;/code&gt; as follows is not bad:</source>
          <target state="translated">しかし、次のように &lt;code&gt;++&lt;/code&gt; を使用することは悪くありません。</target>
        </trans-unit>
        <trans-unit id="521274df22007097293748284fe185141e772a3c" translate="yes" xml:space="preserve">
          <source>But you realize that it is unnecessary to have the Erlang compiler in this one:</source>
          <target state="translated">しかし、この中にErlangコンパイラが入っているのは不要だと気づくのですね。</target>
        </trans-unit>
        <trans-unit id="94852e93461c3ce16031709d1ba53f77338d1422" translate="yes" xml:space="preserve">
          <source>But, if we nevertheless &lt;strong&gt;do&lt;/strong&gt; dig down we find the call to the linked in driver that does the file operations towards the host operating system:</source>
          <target state="translated">しかし、我々はそれにもかかわらず、場合&lt;strong&gt;行う&lt;/strong&gt;我々はへの呼び出しを見つける掘り下げるホスト・オペレーティング・システムに向けてファイル操作を行うドライバーにリンク：</target>
        </trans-unit>
        <trans-unit id="aaa9717eecd88e22102280721e33d90c4f0a390a" translate="yes" xml:space="preserve">
          <source>By &lt;strong&gt;attaching to&lt;/strong&gt; a process executing interpreted code, it is possible to examine variable bindings and order stepwise execution. This is done by sending and receiving information to/from the process through a third process, called the meta process. You can implement your own attached process. See &lt;code&gt;int.erl&lt;/code&gt; for available functions and &lt;code&gt;dbg_wx_trace.erl&lt;/code&gt; for possible messages.</source>
          <target state="translated">解釈されたコードを実行するプロセスに&lt;strong&gt;アタッチする&lt;/strong&gt;ことにより、変数バインディングを調べて段階的な実行を順序付けることができます。これは、メタプロセスと呼ばれる3番目のプロセスを介してプロセスとの間で情報を送受信することによって行われます。独自の添付プロセスを実装できます。参照してください &lt;code&gt;int.erl&lt;/code&gt; 利用可能な機能とするために &lt;code&gt;dbg_wx_trace.erl&lt;/code&gt; 可能なメッセージのために。</target>
        </trans-unit>
        <trans-unit id="5e25689214717ab6f387eff1ce87fefe79882799" translate="yes" xml:space="preserve">
          <source>By SASL reports we mean supervisor reports, crash reports and progress reports.</source>
          <target state="translated">SASLレポートでは、スーパーバイザーレポート、クラッシュレポート、進捗レポートを意味します。</target>
        </trans-unit>
        <trans-unit id="df385cba3294f848291c72e2a88cfe1519f5944b" translate="yes" xml:space="preserve">
          <source>By being able to determine when the first event above has occurred we can easily know when all managed threads have completed accesses to a data structure. This can be determined the following way. We have an implementation of some functionality &lt;code&gt;F&lt;/code&gt; using a data structure &lt;code&gt;D&lt;/code&gt;. The reference to &lt;code&gt;D&lt;/code&gt; is always looked up before &lt;code&gt;D&lt;/code&gt; is being accessed, and the references to &lt;code&gt;D&lt;/code&gt; is always dropped before we leave the code implementing &lt;code&gt;F&lt;/code&gt;. If we remove the possibility to look up &lt;code&gt;D&lt;/code&gt; and then wait until the first event has occurred in all managed threads, no managed threads can have any references to the data structure &lt;code&gt;D&lt;/code&gt;. This could for example have been achieved by using reference counting, but the cache line containing the reference counter would in this case be ping ponged between all processors accessing &lt;code&gt;D&lt;/code&gt; at every access.</source>
          <target state="translated">上記の最初のイベントがいつ発生したかを判別できることにより、すべての管理対象スレッドがデータ構造へのアクセスを完了したことを簡単に知ることができます。これは次の方法で決定できます。データ構造 &lt;code&gt;D&lt;/code&gt; を使用していくつかの機能 &lt;code&gt;F&lt;/code&gt; を実装しています。参照 &lt;code&gt;D&lt;/code&gt; は前に必ず調べている &lt;code&gt;D&lt;/code&gt; がアクセスされている、およびへの参照 &lt;code&gt;D&lt;/code&gt; は、我々が実装するコード去る前に必ず落とされる &lt;code&gt;F&lt;/code&gt; を。 &lt;code&gt;D&lt;/code&gt; を検索する可能性を排除し、すべての管理対象スレッドで最初のイベントが発生するまで待機すると、管理対象スレッドはデータ構造 &lt;code&gt;D&lt;/code&gt; への参照を持つことができなくなります。。これは、たとえば参照カウントを使用することで実現できますが、この場合、参照カウンターを含むキャッシュラインは、すべてのアクセスで &lt;code&gt;D&lt;/code&gt; にアクセスするすべてのプロセッサ間でピンポンされます。</target>
        </trans-unit>
        <trans-unit id="524b3185d88f75bd50294ceb9e69a53458ed7610" translate="yes" xml:space="preserve">
          <source>By being able to determine when the second event has occurred it is quite easy to do complex modifications of memory that needs to be seen consistently by other threads without having to resort to locking. By doing the modifications, then issuing a full memory barrier, then wait until the second event has occurred in all managed threads, and then publish the modifications, we know that all managed threads reading this memory will get a consistent view of the modifications. Managed threads reading this will not have to issue any extra memory barriers at all.</source>
          <target state="translated">2 番目のイベントがいつ発生したかを判断できるようにすることで、ロックに頼ることなく、他のスレッドから一貫して見られるようにする必要がある複雑なメモリの修正を非常に簡単に行うことができます。修正を行った後、フルメモリバリアを発行し、すべての管理されたスレッドで2番目のイベントが発生するまで待ってから修正内容を公開することで、このメモリを読んでいるすべての管理されたスレッドが修正内容を一貫して見ることができることがわかっています。これを読んでいるマネージドスレッドは、余分なメモリバリアを発行する必要は全くありません。</target>
        </trans-unit>
        <trans-unit id="61329f5b77a1e8f4de56300ae6baa6480eff0a5f" translate="yes" xml:space="preserve">
          <source>By calling &lt;code&gt;blend/2&lt;/code&gt; on any color term created by &lt;code&gt;new/4&lt;/code&gt;, the resulting color can be calculated as determined by the two map terms.</source>
          <target state="translated">&lt;code&gt;new/4&lt;/code&gt; によって作成された任意のカラー項で &lt;code&gt;blend/2&lt;/code&gt; を呼び出すことにより、2つのマップ項によって決定された結果の色を計算できます。</target>
        </trans-unit>
        <trans-unit id="6e21b8bafe38feea973da163115371fd334e57e8" translate="yes" xml:space="preserve">
          <source>By calling function &lt;code&gt;info/0&lt;/code&gt; in a generated module, you get information about which compiler options were used.</source>
          <target state="translated">生成されたモジュールで関数 &lt;code&gt;info/0&lt;/code&gt; を呼び出すことにより、使用されたコンパイラオプションに関する情報を取得します。</target>
        </trans-unit>
        <trans-unit id="817528d15c927d91ed8c4901f6bd96f0b70a6a47" translate="yes" xml:space="preserve">
          <source>By clicking the name in the column header of any table (for example, &quot;Ok&quot;, &quot;Case&quot;, &quot;Time&quot;, and so on), the table rows are sorted in whatever order makes sense for the type of value (for example, numerical for &quot;Ok&quot; or &quot;Time&quot;, and alphabetical for &quot;Case&quot;). The sorting is performed through JavaScript code, automatically inserted into the HTML log files. &lt;code&gt;Common Test&lt;/code&gt; uses the &lt;code&gt;&lt;a href=&quot;http://jquery.com&quot;&gt;jQuery&lt;/a&gt;&lt;/code&gt; library and the &lt;code&gt;&lt;a href=&quot;http://tablesorter.com&quot;&gt;tablesorter&lt;/a&gt;&lt;/code&gt; plugin, with customized sorting functions, for this implementation.</source>
          <target state="translated">テーブルの列ヘッダーの名前（たとえば、「OK」、「ケース」、「時間」など）をクリックすると、テーブルの行が値のタイプに適した順序で並べ替えられます（たとえば、「OK」または「時間」は数値、「ケース」はアルファベット順）。ソートはJavaScriptコードを介して実行され、HTMLログファイルに自動的に挿入されます。 &lt;code&gt;Common Test&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;http://jquery.com&quot;&gt;jQuery&lt;/a&gt;&lt;/code&gt; ライブラリと、カスタマイズされたソート機能を備えた &lt;code&gt;&lt;a href=&quot;http://tablesorter.com&quot;&gt;tablesorter&lt;/a&gt;&lt;/code&gt; プラグインをこの実装に使用します。</target>
        </trans-unit>
        <trans-unit id="6ea0e955d25fd75ff5b4bf677527caab934dbed9" translate="yes" xml:space="preserve">
          <source>By combining the modifications of the process state management and the run queue management, we can do large parts of the work involved when managing processes with regards to scheduling and migration without having any locks locked at all. In these situations we previously had to have multiple locks locked. This of course caused a lot of rewrites across large parts of the runtime system, but the rewrite both simplified code and eliminated locking at a number of places. The major benefit is, of course, reduced contention.</source>
          <target state="translated">プロセス状態管理とランキュー管理の変更を組み合わせることで、スケジューリングやマイグレーションに関するプロセス管理の大部分の作業を、ロックを一切かけずに行うことができるようになりました。このような状況では、以前は複数のロックをかけなければなりませんでした。これはもちろん、ランタイムシステムの大部分に渡って多くの書き換えが発生しましたが、書き換えによってコードが簡素化され、多くの場所でロックを排除することができました。主な利点は、もちろん競合が減ったことです。</target>
        </trans-unit>
        <trans-unit id="3e3f09bd43c71064511228990649461289b5c148" translate="yes" xml:space="preserve">
          <source>By configuration, you can also modify or disable the default handler, replace it by a custom handler, and install additional handlers.</source>
          <target state="translated">設定によって、デフォルトのハンドラを変更したり無効にしたり、カスタムハンドラで置き換えたり、追加のハンドラをインストールしたりすることもできます。</target>
        </trans-unit>
        <trans-unit id="65dc91babe6148c48d235004a31fddc4c1120398" translate="yes" xml:space="preserve">
          <source>By convention, most Built-In Functions (BIFs) are included in this module. Some of the BIFs are viewed more or less as part of the Erlang programming language and are &lt;strong&gt;auto-imported&lt;/strong&gt;. Thus, it is not necessary to specify the module name. For example, the calls &lt;code&gt;atom_to_list(erlang)&lt;/code&gt; and &lt;code&gt;erlang:atom_to_list(erlang)&lt;/code&gt; are identical.</source>
          <target state="translated">慣例として、ほとんどの組み込み関数（BIF）はこのモジュールに含まれています。一部のBIFは、多かれ少なかれ、Erlangプログラミング言語の一部と見なされ、&lt;strong&gt;自動インポートされ&lt;/strong&gt;ます。したがって、モジュール名を指定する必要はありません。たとえば、 &lt;code&gt;atom_to_list(erlang)&lt;/code&gt; と &lt;code&gt;erlang:atom_to_list(erlang)&lt;/code&gt; の呼び出しは同じです。</target>
        </trans-unit>
        <trans-unit id="082c66d79fe52cb570696433b4792152063b55b2" translate="yes" xml:space="preserve">
          <source>By convention, the name of a tar file is to end in &quot;&lt;code&gt;.tar&lt;/code&gt;&quot;. To abide to the convention, add &quot;&lt;code&gt;.tar&lt;/code&gt;&quot; to the name.</source>
          <target state="translated">慣例により、tarファイルの名前は「 &lt;code&gt;.tar&lt;/code&gt; 」で終了します。規約に &lt;code&gt;.tar&lt;/code&gt; するには、名前に「.tar」を追加します。</target>
        </trans-unit>
        <trans-unit id="e51e93220df3f4bd5dc8a32795232ab13e7f0c15" translate="yes" xml:space="preserve">
          <source>By convention, the name of a zip file is to end with &lt;code&gt;.zip&lt;/code&gt;. To abide to the convention, add &lt;code&gt;.zip&lt;/code&gt; to the filename.</source>
          <target state="translated">慣例により、zipファイルの名前は &lt;code&gt;.zip&lt;/code&gt; で終わります。規則に従うには、ファイル名に &lt;code&gt;.zip&lt;/code&gt; を追加します。</target>
        </trans-unit>
        <trans-unit id="458ef8621b4f7c4ee2bf42d5b9e1f263171a21fb" translate="yes" xml:space="preserve">
          <source>By default 16 files are merged at a time. This option is rarely needed.</source>
          <target state="translated">デフォルトでは、一度に16個のファイルがマージされます。このオプションはほとんど必要ありません。</target>
        </trans-unit>
        <trans-unit id="f916c5ec73659e63b033b011cdae7b63d48ef9e3" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;Mnesia&lt;/code&gt; either dumps the log whenever 100 records have been written in the log or when three minutes have passed. This is controlled by the two application parameters &lt;code&gt;-mnesia dump_log_write_threshold WriteOperations&lt;/code&gt; and &lt;code&gt;-mnesia dump_log_time_threshold MilliSecs&lt;/code&gt;.</source>
          <target state="translated">デフォルトでは、 &lt;code&gt;Mnesia&lt;/code&gt; は100レコードがログに書き込まれたとき、または3分が経過したときにログをダンプします。これは、2つのアプリケーションパラメータ &lt;code&gt;-mnesia dump_log_write_threshold WriteOperations&lt;/code&gt; と &lt;code&gt;-mnesia dump_log_time_threshold MilliSecs&lt;/code&gt; によって制御されます。</target>
        </trans-unit>
        <trans-unit id="f74ee3ee744473dfcdc8d613d9c22514ab7711d7" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;Mnesia&lt;/code&gt; either dumps the log whenever 1000 records have been written in the log or when three minutes have passed. This is controlled by the two application parameters &lt;code&gt;-mnesia dump_log_write_threshold WriteOperations&lt;/code&gt; and &lt;code&gt;-mnesia dump_log_time_threshold MilliSecs&lt;/code&gt;.</source>
          <target state="translated">デフォルトでは、 &lt;code&gt;Mnesia&lt;/code&gt; は、1000レコードがログに書き込まれるか、3分が経過すると、ログをダンプします。これは、2つのアプリケーションパラメータ &lt;code&gt;-mnesia dump_log_write_threshold WriteOperations&lt;/code&gt; と &lt;code&gt;-mnesia dump_log_time_threshold MilliSecs&lt;/code&gt; によって制御されます。</target>
        </trans-unit>
        <trans-unit id="e1b4d9f0f830cdbeba0bff6368aca7f38a671867" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;ei&lt;/code&gt; supplies a TCP/IPv4 socket interface that is used when communicating. The user can however plug in his/her own IPv4 socket implementation. This, for example, in order to communicate over TLS. A user supplied socket implementation is plugged in by passing a &lt;code&gt;&lt;a href=&quot;#ei_socket_callbacks&quot;&gt;callback structure&lt;/a&gt;&lt;/code&gt; to either &lt;code&gt;&lt;a href=&quot;#ei_connect_init&quot;&gt;ei_connect_init_ussi()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#ei_connect_init&quot;&gt;ei_connect_xinit_ussi()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">デフォルトでは、 &lt;code&gt;ei&lt;/code&gt; は通信時に使用されるTCP / IPv4ソケットインターフェイスを提供します。ただし、ユーザーは自分のIPv4ソケット実装をプラグインできます。これは、たとえば、TLSを介して通信するためです。ユーザー提供のソケット実装は、 &lt;code&gt;&lt;a href=&quot;#ei_socket_callbacks&quot;&gt;callback structure&lt;/a&gt;&lt;/code&gt; を &lt;code&gt;&lt;a href=&quot;#ei_connect_init&quot;&gt;ei_connect_init_ussi()&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;#ei_connect_init&quot;&gt;ei_connect_xinit_ussi()&lt;/a&gt;&lt;/code&gt; のいずれかに渡すことによってプラグインされます。</target>
        </trans-unit>
        <trans-unit id="e33f74e5fe8c2a189ae75982a8ae0619e585aa16" translate="yes" xml:space="preserve">
          <source>By default SSL/TLS is run over the TCP/IP protocol even though you can plug in any other reliable transport protocol with the same Application Programming Interface (API) as the &lt;code&gt;gen_tcp&lt;/code&gt; module in Kernel. DTLS is by default run over UDP/IP, which means that application data has no delivery guarentees. Other transports, such as SCTP, may be supported in future releases.</source>
          <target state="translated">カーネルの &lt;code&gt;gen_tcp&lt;/code&gt; モジュールと同じアプリケーションプログラミングインターフェース（API）で他の信頼できるトランスポートプロトコルをプラグインできる場合でも、デフォルトではSSL / TLSはTCP / IPプロトコルで実行されます。DTLSはデフォルトでUDP / IP上で実行されます。つまり、アプリケーションデータには配信保証がありません。SCTPなどの他のトランスポートは、将来のリリースでサポートされる可能性があります。</target>
        </trans-unit>
        <trans-unit id="eabed6d7dfce1497434c059489829d94c31442b4" translate="yes" xml:space="preserve">
          <source>By default TLS is run over the TCP/IP protocol even though you can plug in any other reliable transport protocol with the same Application Programming Interface (API) as the &lt;code&gt;gen_tcp&lt;/code&gt; module in Kernel. DTLS is by default run over UDP/IP, which means that application data has no delivery guarentees. Other transports, such as SCTP, may be supported in future releases.</source>
          <target state="translated">デフォルトでは、カーネルの &lt;code&gt;gen_tcp&lt;/code&gt; モジュールと同じアプリケーションプログラミングインターフェイス（API）を使用して他の信頼できるトランスポートプロトコルをプラグインできますが、TLSはTCP / IPプロトコルを介して実行されます。DTLSはデフォルトでUDP / IPを介して実行されます。つまり、アプリケーションデータには配信保証がありません。SCTPなどの他のトランスポートは、将来のリリースでサポートされる可能性があります。</target>
        </trans-unit>
        <trans-unit id="55b91f316a10114e643a738ef56cbce119a92d15" translate="yes" xml:space="preserve">
          <source>By default about 512*1024 bytes read from files are sorted internally. This option is rarely needed.</source>
          <target state="translated">デフォルトでは、ファイルから読み込んだ約512*1024バイトが内部的にソートされます。このオプションはほとんど必要ありません。</target>
        </trans-unit>
        <trans-unit id="1e8fa96214b81833eb829752ba3cb11f2aac75f4" translate="yes" xml:space="preserve">
          <source>By default in OTP 17, the representation of the &lt;code&gt;BIT STRING&lt;/code&gt; and &lt;code&gt;OCTET STRING&lt;/code&gt; types as Erlang terms were changed. &lt;code&gt;BIT STRING&lt;/code&gt; values are now Erlang bit strings and &lt;code&gt;OCTET STRING&lt;/code&gt; values are binaries. Also, an undecoded open type is now wrapped in an &lt;code&gt;asn1_OPENTYPE&lt;/code&gt; tuple. For details, see &lt;code&gt;&lt;a href=&quot;asn1_getting_started#BIT%20STRING&quot;&gt;BIT STRING&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;asn1_getting_started#OCTET%20STRING&quot;&gt;OCTET STRING&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;asn1_getting_started#Information%20Object&quot;&gt;ASN.1 Information Objects&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">OTP 17のデフォルトでは、Erlang用語としての &lt;code&gt;BIT STRING&lt;/code&gt; および &lt;code&gt;OCTET STRING&lt;/code&gt; タイプの表現が変更されました。 &lt;code&gt;BIT STRING&lt;/code&gt; 値はErlangビット文字列になり、 &lt;code&gt;OCTET STRING&lt;/code&gt; 値はバイナリになりました。また、デコードされていないオープンタイプは、 &lt;code&gt;asn1_OPENTYPE&lt;/code&gt; タプルにラップされるようになりました。詳細については、ユーザーズガイドの &lt;code&gt;&lt;a href=&quot;asn1_getting_started#BIT%20STRING&quot;&gt;BIT STRING&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;asn1_getting_started#OCTET%20STRING&quot;&gt;OCTET STRING&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;asn1_getting_started#Information%20Object&quot;&gt;ASN.1 Information Objects&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="9dc86d1dada42ddb164640d0be1c9cd268646f6a" translate="yes" xml:space="preserve">
          <source>By default it is not included, but if this option is present it will be.</source>
          <target state="translated">デフォルトでは含まれませんが、このオプションがある場合は含まれます。</target>
        </trans-unit>
        <trans-unit id="c97804b0eee285b037a2d076e7ba516d0e16e389" translate="yes" xml:space="preserve">
          <source>By default it is not included, but if this option is present it will be. The reference text will be placed in the allocList field of the mib-entry record (#me{}) for the table.</source>
          <target state="translated">デフォルトでは含まれませんが、このオプションがある場合は含まれます。参照テキストは、テーブルのmib-entryレコード(#me{})のallocListフィールドに配置されます。</target>
        </trans-unit>
        <trans-unit id="a4cb7bdb00bc5f4f34ca644e957ab5ac212ab81d" translate="yes" xml:space="preserve">
          <source>By default on such systems, Erlang starts in &lt;code&gt;utf8&lt;/code&gt; filename mode if the terminal supports UTF-8, otherwise in &lt;code&gt;latin1&lt;/code&gt; mode.</source>
          <target state="translated">そのようなシステムでは、端末がUTF-8をサポートする場合、Erlangはデフォルトで &lt;code&gt;utf8&lt;/code&gt; ファイル名モードで起動します。それ以外の場合は、 &lt;code&gt;latin1&lt;/code&gt; モードで起動します。</target>
        </trans-unit>
        <trans-unit id="66001038963df69c701cdea04de30818e23ced2f" translate="yes" xml:space="preserve">
          <source>By default only the running target is available, unless the server includes &lt;code&gt;:candidate&lt;/code&gt; or &lt;code&gt;:startup&lt;/code&gt; in its list of capabilities.</source>
          <target state="translated">サーバーが機能のリストに &lt;code&gt;:candidate&lt;/code&gt; または &lt;code&gt;:startup&lt;/code&gt; を含まない限り、デフォルトでは実行中のターゲットのみが使用可能です。</target>
        </trans-unit>
        <trans-unit id="b1f41b809750734c802dac0f55be66baad734531" translate="yes" xml:space="preserve">
          <source>By default the &lt;code&gt;Application inclusion policy&lt;/code&gt; on system level is used for all applications. Set the value to &lt;code&gt;include&lt;/code&gt; if you want to explicitly include one particular application. Set it to &lt;code&gt;exclude&lt;/code&gt; if you want to exclude the application despite that it is used by another (explicitly or implicitly) included application. &lt;code&gt;derived&lt;/code&gt; means that the application automatically will be included if some other (explicitly or implicitly) included application uses it.</source>
          <target state="translated">デフォルトでは、システムレベルの &lt;code&gt;Application inclusion policy&lt;/code&gt; がすべてのアプリケーションに使用されます。特定の1つのアプリケーションを明示的に &lt;code&gt;include&lt;/code&gt; 場合は、includeする値を設定します。別の（明示的または暗黙的に）組み込まれたアプリケーションによって使用されているにもかかわらず、アプリケーションを &lt;code&gt;exclude&lt;/code&gt; 場合は、excludeに設定します。 &lt;code&gt;derived&lt;/code&gt; とは、他の（明示的または暗黙的に）含まれているアプリケーションが使用する場合、アプリケーションが自動的に含まれることを意味します。</target>
        </trans-unit>
        <trans-unit id="3bb33b9d4c2d5314003279505372f2bd591c4469" translate="yes" xml:space="preserve">
          <source>By default the &lt;code&gt;Module inclusion policy&lt;/code&gt; on system level is used for all applications. Set it to &lt;code&gt;derived&lt;/code&gt; if you only want actually used modules to be included. Set it to &lt;code&gt;app&lt;/code&gt; if you, besides derived modules, also want the modules listed in the app file to be included. Set it to &lt;code&gt;ebin&lt;/code&gt; if you, besides derived modules, also want the modules that exist as beam files in the ebin directory to be included. Set it to &lt;code&gt;all&lt;/code&gt; if you want all modules to be included, that is the union of modules found in the ebin directory and listed in the app file.</source>
          <target state="translated">デフォルトでは、システムレベルの &lt;code&gt;Module inclusion policy&lt;/code&gt; がすべてのアプリケーションに使用されます。実際に使用するモジュールのみを含める場合は、それを &lt;code&gt;derived&lt;/code&gt; 設定します。派生モジュールの他に、appファイルにリストされているモジュールも含めたい場合は、それを &lt;code&gt;app&lt;/code&gt; に設定します。派生モジュールの他に、ebinディレクトリにビームファイルとして存在するモジュールも含めたい場合は、 &lt;code&gt;ebin&lt;/code&gt; に設定します。すべてのモジュールを含める場合は、これを &lt;code&gt;all&lt;/code&gt; 設定します。これは、ebinディレクトリにあり、appファイルにリストされているモジュールの結合です。</target>
        </trans-unit>
        <trans-unit id="81c493b42c1c2d3836dadd1b1f65d1b4066bbbb2" translate="yes" xml:space="preserve">
          <source>By default the EPMD listens on port 4369.</source>
          <target state="translated">デフォルトでは、EPMDはポート4369をリッスンします。</target>
        </trans-unit>
        <trans-unit id="60c9fed0b81fb4b980269d86433bdb1dec183e3e" translate="yes" xml:space="preserve">
          <source>By default the TLS/DTLS clients try to reuse an available session and by default the TLS/DTLS servers agree to reuse sessions when clients ask for it.</source>
          <target state="translated">デフォルトでは、TLS/DTLS クライアントは利用可能なセッションを再利用しようとし、デフォルトでは、TLS/DTLS サーバはクライアントがそれを要求したときにセッションを再利用することに同意します。</target>
        </trans-unit>
        <trans-unit id="81d8c9fb8831024a08c4d93b4cdac4bc82433614" translate="yes" xml:space="preserve">
          <source>By default the TLS/DTLS clients try to reuse an available session and by default the TLS/DTLS servers agree to reuse sessions when clients ask for it. See also &lt;code&gt; Session Reuse Pre TLS-1.3 &lt;/code&gt;</source>
          <target state="translated">デフォルトでは、TLS / DTLSクライアントは利用可能なセッションを再利用しようとし、デフォルトでは、TLS / DTLSサーバーはクライアントが要求したときにセッションを再利用することに同意します。 &lt;code&gt; Session Reuse Pre TLS-1.3 &lt;/code&gt; も参照してください。</target>
        </trans-unit>
        <trans-unit id="40a1d269c0b2f20066064de554ea4fe767edbe1b" translate="yes" xml:space="preserve">
          <source>By default the currently stored events (existing) are written to a brand new file (write) and the events are kept (keep) after they have been written to the file.</source>
          <target state="translated">デフォルトでは、現在保存されているイベント(既存のもの)は真新しいファイルに書き込まれ(write)、イベントはファイルに書き込まれた後も保持されます(keep)。</target>
        </trans-unit>
        <trans-unit id="b301155fe91b7f29a76df23651c02320368fef48" translate="yes" xml:space="preserve">
          <source>By default the flex scanner reports line-number of an error. But it can be built without line-number reporting. Instead token number is used. This will speed up the scanning some 5-10%. Use &lt;code&gt;--disable-megaco-flex-scanner-lineno&lt;/code&gt; when configuring the application.</source>
          <target state="translated">デフォルトでは、フレックススキャナーはエラーの行番号を報告します。ただし、行番号のレポートなしで構築できます。代わりにトークン番号が使用されます。これにより、スキャンが5〜10％高速化されます。使用 &lt;code&gt;--disable-megaco-flex-scanner-lineno&lt;/code&gt; アプリケーションを設定するとき。</target>
        </trans-unit>
        <trans-unit id="c20eaae0e3f3676678ff09602bb8cee954cea155" translate="yes" xml:space="preserve">
          <source>By default the socket options set by function &lt;code&gt;&lt;a href=&quot;#set_options-1&quot;&gt;set_options/[1,2]&lt;/a&gt;&lt;/code&gt; are used when establishing a connection.</source>
          <target state="translated">デフォルトでは、関数 &lt;code&gt;&lt;a href=&quot;#set_options-1&quot;&gt;set_options/[1,2]&lt;/a&gt;&lt;/code&gt; で設定されたソケットオプションが、接続の確立時に使用されます。</target>
        </trans-unit>
        <trans-unit id="c911090b3724ca04bd13ed3fc1bce3d52a0723e3" translate="yes" xml:space="preserve">
          <source>By default time correction is enabled if support for it exists on the specific platform. Support for it includes both OS monotonic time, provided by the OS, and an implementation in the Erlang runtime system using OS monotonic time. To check if your system has support for OS monotonic time, call &lt;code&gt;&lt;a href=&quot;erlang#system_info_os_monotonic_time_source&quot;&gt; erlang:system_info(os_monotonic_time_source)&lt;/a&gt;&lt;/code&gt;. To check if time correction is enabled on your system, call &lt;code&gt;&lt;a href=&quot;erlang#system_info_time_correction&quot;&gt; erlang:system_info(time_correction)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">特定のプラットフォームでサポートが存在する場合、デフォルトで時間修正が有効になっています。これには、OSによって提供されるOS単調時間と、OS単調時間を使用したErlangランタイムシステムでの実装の両方が含まれます。システムがOS単調時間をサポートしているかどうかを確認するには、 &lt;code&gt;&lt;a href=&quot;erlang#system_info_os_monotonic_time_source&quot;&gt; erlang:system_info(os_monotonic_time_source)&lt;/a&gt;&lt;/code&gt; を呼び出します。システムで時間補正が有効になっているかどうかを確認するには、 &lt;code&gt;&lt;a href=&quot;erlang#system_info_time_correction&quot;&gt; erlang:system_info(time_correction)&lt;/a&gt;&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="ec72fa4eac79a3cc871f1f0e43828e92af1bb91b" translate="yes" xml:space="preserve">
          <source>By default time correction is enabled if support for it exists on the specific platform. Support for it includes both OS monotonic time, provided by the OS, and an implementation in the Erlang runtime system using OS monotonic time. To check if your system has support for OS monotonic time, call &lt;code&gt;&lt;a href=&quot;erlang#system_info_os_monotonic_time_source&quot;&gt;erlang:system_info(os_monotonic_time_source)&lt;/a&gt;&lt;/code&gt;. To check if time correction is enabled on your system, call &lt;code&gt;&lt;a href=&quot;erlang#system_info_time_correction&quot;&gt;erlang:system_info(time_correction)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">特定のプラットフォームでサポートされている場合、デフォルトで時刻修正が有効になっています。これのサポートには、OSによって提供されるOS単調時間と、OS単調時間を使用するErlangランタイムシステムでの実装の両方が含まれます。システムがOSの単調時間をサポートしているかどうかを確認するには、 &lt;code&gt;&lt;a href=&quot;erlang#system_info_os_monotonic_time_source&quot;&gt;erlang:system_info(os_monotonic_time_source)&lt;/a&gt;&lt;/code&gt; を呼び出します。システムで時刻修正が有効になっているかどうかを確認するには、 &lt;code&gt;&lt;a href=&quot;erlang#system_info_time_correction&quot;&gt;erlang:system_info(time_correction)&lt;/a&gt;&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="7ceb9ebe7b981aea32343aa2ebada87a65d18c16" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;&lt;a href=&quot;ttb#stop-1&quot;&gt;ttb:stop/1&lt;/a&gt;&lt;/code&gt; fetches trace logs and trace information files from all nodes. The logs are stored in a new directory named &lt;code&gt;ttb_upload-Filename-Timestamp&lt;/code&gt; under the working directory of the trace control node. Fetching can be disabled by providing option &lt;code&gt;nofetch&lt;/code&gt; to &lt;code&gt;ttb:stop/1&lt;/code&gt;. The user can specify a fetch directory by passing option &lt;code&gt;{fetch_dir, Dir}&lt;/code&gt;.</source>
          <target state="translated">デフォルトでは、 &lt;code&gt;&lt;a href=&quot;ttb#stop-1&quot;&gt;ttb:stop/1&lt;/a&gt;&lt;/code&gt; はすべてのノードからトレースログとトレース情報ファイルをフェッチします。ログは、トレースコントロールノードの作業ディレクトリの下にある &lt;code&gt;ttb_upload-Filename-Timestamp&lt;/code&gt; という名前の新しいディレクトリに保存されます。フェッチは、オプション &lt;code&gt;nofetch&lt;/code&gt; を &lt;code&gt;ttb:stop/1&lt;/code&gt; に提供することで無効にできます。ユーザーはオプション &lt;code&gt;{fetch_dir, Dir}&lt;/code&gt; を渡すことでフェッチディレクトリを指定できます。</target>
        </trans-unit>
        <trans-unit id="e28d91aead7c4c840b960191290c3223a7f6126a" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;Char&lt;/code&gt; is &lt;code&gt;$\s&lt;/code&gt; and &lt;code&gt;Dir&lt;/code&gt; is &lt;code&gt;trailing&lt;/code&gt;.</source>
          <target state="translated">デフォルトでは、 &lt;code&gt;Char&lt;/code&gt; は &lt;code&gt;$\s&lt;/code&gt; 、 &lt;code&gt;Dir&lt;/code&gt; は &lt;code&gt;trailing&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="071766231ebcbb0e6dd0a89742db95d7cd2d08e3" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;Common Test&lt;/code&gt; creates one central private directory per test run, shared by all test cases. This is not always suitable. Especially if the same test cases are executed multiple times during a test run (that is, if they belong to a test case group with property &lt;code&gt;repeat&lt;/code&gt;) and there is a risk that files in the private directory get overwritten. Under these circumstances, &lt;code&gt;Common Test&lt;/code&gt; can be configured to create one dedicated private directory per test case and execution instead. This is accomplished with the flag/option &lt;code&gt;create_priv_dir&lt;/code&gt; (to be used with the &lt;code&gt;&lt;a href=&quot;ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt; program, the &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt; function, or as test specification term). There are three possible values for this option as follows:</source>
          <target state="translated">デフォルトでは、 &lt;code&gt;Common Test&lt;/code&gt; は、テスト実行ごとに1つの中央プライベートディレクトリを作成し、すべてのテストケースで共有します。これは常に適切であるとは限りません。特に、テスト実行中に同じテストケースが複数回実行される場合（つまり、プロパティが &lt;code&gt;repeat&lt;/code&gt; のテストケースグループに属している場合）、プライベートディレクトリのファイルが上書きされるリスクがあります。このような状況では、 &lt;code&gt;Common Test&lt;/code&gt; を構成して、テストケースごとに1つの専用プライベートディレクトリを作成し、代わりに実行することができます。これは、フラグ/オプション &lt;code&gt;create_priv_dir&lt;/code&gt; （ &lt;code&gt;&lt;a href=&quot;ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt; プログラムで使用される &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt; 機能、またはテスト仕様用語として）。このオプションには、次の3つの値があります。</target>
        </trans-unit>
        <trans-unit id="bc3169458b9c52d0cd7a98448830679fb2a8731a" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;Dir&lt;/code&gt; is &lt;code&gt;leading&lt;/code&gt;.</source>
          <target state="translated">デフォルトでは、 &lt;code&gt;Dir&lt;/code&gt; が &lt;code&gt;leading&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="28f74729db7b0c3b278863ef6db06bd5bab6afe7" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;ERTS&lt;/code&gt; is only guaranteed to be compatible with other Erlang/OTP components from the same release as &lt;code&gt;ERTS&lt;/code&gt; itself.</source>
          <target state="translated">デフォルトでは、 &lt;code&gt;ERTS&lt;/code&gt; は、 &lt;code&gt;ERTS&lt;/code&gt; 自体と同じリリースの他のErlang / OTPコンポーネントとの互換性のみが保証されています。</target>
        </trans-unit>
        <trans-unit id="4d10644009649e0b88125d8c14d6cdb3379fe167" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;IgnoreCase&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;Norm&lt;/code&gt; is &lt;code&gt;none&lt;/code&gt;.</source>
          <target state="translated">デフォルトでは、 &lt;code&gt;IgnoreCase&lt;/code&gt; は &lt;code&gt;false&lt;/code&gt; で、 &lt;code&gt;Norm&lt;/code&gt; は &lt;code&gt;none&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="e9d6341953fcce030f785b04ed13be99fb6431b5" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;Length&lt;/code&gt; is &lt;code&gt;infinity&lt;/code&gt;.</source>
          <target state="translated">デフォルトでは、 &lt;code&gt;Length&lt;/code&gt; は &lt;code&gt;infinity&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="737dbf79ae1fa944f9b53b6e9f296655a6f7aa71" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;relup&lt;/code&gt; file is located in the current working directory. If option &lt;code&gt;{outdir,Dir}&lt;/code&gt; is specified, the &lt;code&gt;relup&lt;/code&gt; file is located in &lt;code&gt;Dir&lt;/code&gt; instead.</source>
          <target state="translated">デフォルトでは、 &lt;code&gt;relup&lt;/code&gt; ファイルは現在の作業ディレクトリにあります。オプション &lt;code&gt;{outdir,Dir}&lt;/code&gt; が指定されている場合、 &lt;code&gt;relup&lt;/code&gt; ファイルは代わりに &lt;code&gt;Dir&lt;/code&gt; に配置されます。</target>
        </trans-unit>
        <trans-unit id="8e5740833bc9a00277b2eef37e4a06e9efa51635" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;{proc_lib,init_p,5}&lt;/code&gt; is returned if no information about the initial call can be found. It is assumed that the caller knows that the process has been spawned with the &lt;code&gt;proc_lib&lt;/code&gt; module.</source>
          <target state="translated">デフォルトでは、最初の呼び出しに関する情報が見つからない場合、 &lt;code&gt;{proc_lib,init_p,5}&lt;/code&gt; が返されます。呼び出し元は、プロセスが &lt;code&gt;proc_lib&lt;/code&gt; モジュールで生成されたことを知っていると想定されます。</target>
        </trans-unit>
        <trans-unit id="1a09da640fbd6b16e4c97f30cbf385b23a15ab05" translate="yes" xml:space="preserve">
          <source>By default, Debugger only saves information about recursive function calls, that is, function calls that have not yet returned a value (option &lt;strong&gt;Stack On, No Tail&lt;/strong&gt;).</source>
          <target state="translated">デフォルトでは、デバッガーは再帰的な関数呼び出し、つまりまだ値を返していない関数呼び出し（オプション&lt;strong&gt;Stack On、No Tail&lt;/strong&gt;）に関する情報のみを保存します。</target>
        </trans-unit>
        <trans-unit id="cb83760fc1df1215ce919183bfc30967f2391d71" translate="yes" xml:space="preserve">
          <source>By default, Dialyzer caches the results of native compilation in directory &lt;code&gt;$XDG_CACHE_HOME/erlang/dialyzer_hipe_cache&lt;/code&gt;. &lt;code&gt;XDG_CACHE_HOME&lt;/code&gt; defaults to &lt;code&gt;$HOME/.cache&lt;/code&gt;. Use this option to disable caching.</source>
          <target state="translated">デフォルトでは、Dialyzerはネイティブコンパイルの結果をディレクトリ &lt;code&gt;$XDG_CACHE_HOME/erlang/dialyzer_hipe_cache&lt;/code&gt; dialyzer_hipe_cacheにキャッシュします。 &lt;code&gt;XDG_CACHE_HOME&lt;/code&gt; のデフォルトは &lt;code&gt;$HOME/.cache&lt;/code&gt; です。このオプションを使用して、キャッシュを無効にします。</target>
        </trans-unit>
        <trans-unit id="ca501566661fba6186a204103ba54062fe33920b" translate="yes" xml:space="preserve">
          <source>By default, Erlang is started so that only the &lt;code&gt;latin1&lt;/code&gt; range of characters indicate that a list of integers is a string.</source>
          <target state="translated">デフォルトでは、Erlangは開始され、 &lt;code&gt;latin1&lt;/code&gt; の範囲の文字のみが整数のリストが文字列であることを示します。</target>
        </trans-unit>
        <trans-unit id="600a9af71026fcfac59ffff3d502bc67475337e3" translate="yes" xml:space="preserve">
          <source>By default, Erlang only detects lists of characters in the Latin-1 range as strings, but the &lt;code&gt;+pc unicode&lt;/code&gt; flag can be used to change this (see &lt;code&gt;&lt;a href=&quot;#printable_range-0&quot;&gt; printable_range/0&lt;/a&gt;&lt;/code&gt; for details). For example:</source>
          <target state="translated">デフォルトでは、ErlangはLatin-1範囲の文字のリストのみを文字列として検出しますが、 &lt;code&gt;+pc unicode&lt;/code&gt; フラグを使用してこれを変更できます（詳細については、 &lt;code&gt;&lt;a href=&quot;#printable_range-0&quot;&gt; printable_range/0&lt;/a&gt;&lt;/code&gt; を参照してください）。例えば：</target>
        </trans-unit>
        <trans-unit id="8a82754162a45a0d73de414ecadee9a7ddca8c1b" translate="yes" xml:space="preserve">
          <source>By default, Erlang only detects lists of characters in the Latin-1 range as strings, but the &lt;code&gt;+pc unicode&lt;/code&gt; flag can be used to change this (see &lt;code&gt;&lt;a href=&quot;#printable_range-0&quot;&gt;printable_range/0&lt;/a&gt;&lt;/code&gt; for details). For example:</source>
          <target state="translated">デフォルトでは、ErlangはLatin-1範囲の文字のリストのみを文字列として検出しますが、 &lt;code&gt;+pc unicode&lt;/code&gt; フラグを使用してこれを変更できます（詳細については、 &lt;code&gt;&lt;a href=&quot;#printable_range-0&quot;&gt;printable_range/0&lt;/a&gt;&lt;/code&gt; を参照してください）。例えば：</target>
        </trans-unit>
        <trans-unit id="ddfb5846cc6e75b4d26cdc33d2870cc55885837f" translate="yes" xml:space="preserve">
          <source>By default, Erlang/OTP release will be installed in &lt;code&gt;/usr/local/{bin,lib/erlang}&lt;/code&gt;. If you for instance don't have the permission to install in the standard location, you can install Erlang/OTP somewhere else. For example, to install in &lt;code&gt;/opt/erlang/21.0/{bin,lib/erlang}&lt;/code&gt;, use the &lt;code&gt;--prefix=/opt/erlang/21.0&lt;/code&gt; option.</source>
          <target state="translated">デフォルトでは、Erlang / OTPリリースは &lt;code&gt;/usr/local/{bin,lib/erlang}&lt;/code&gt; インストールされます。たとえば、標準の場所にインストールする権限がない場合は、Erlang / OTPを別の場所にインストールできます。例えば、にインストールする &lt;code&gt;/opt/erlang/21.0/{bin,lib/erlang}&lt;/code&gt; 、使用 &lt;code&gt;--prefix=/opt/erlang/21.0&lt;/code&gt; オプション。</target>
        </trans-unit>
        <trans-unit id="97faf8e4ee820690a95a2f9c0c26ec78fc837744" translate="yes" xml:space="preserve">
          <source>By default, Erlang/OTP release will be installed in &lt;code&gt;/usr/local/{bin,lib/erlang}&lt;/code&gt;. If you for instance don't have the permission to install in the standard location, you can install Erlang/OTP somewhere else. For example, to install in &lt;code&gt;/opt/erlang/23.2/{bin,lib/erlang}&lt;/code&gt;, use the &lt;code&gt;--prefix=/opt/erlang/23.2&lt;/code&gt; option.</source>
          <target state="translated">デフォルトでは、Erlang / OTPリリースは &lt;code&gt;/usr/local/{bin,lib/erlang}&lt;/code&gt; インストールされます。たとえば、標準の場所にインストールする権限がない場合は、Erlang / OTPを別の場所にインストールできます。例えば、にインストールする &lt;code&gt;/opt/erlang/23.2/{bin,lib/erlang}&lt;/code&gt; 、使用 &lt;code&gt;--prefix=/opt/erlang/23.2&lt;/code&gt; オプション。</target>
        </trans-unit>
        <trans-unit id="449ac9961843b5846b7c02a09a67a56c7a856de8" translate="yes" xml:space="preserve">
          <source>By default, PCRE treats the subject string as consisting of a single line of characters (even if it contains newlines). The &quot;start of line&quot; metacharacter (&lt;code&gt;^&lt;/code&gt;) matches only at the start of the string, while the &quot;end of line&quot; metacharacter (&lt;code&gt;$&lt;/code&gt;) matches only at the end of the string, or before a terminating newline (unless option &lt;code&gt;dollar_endonly&lt;/code&gt; is specified). This is the same as in Perl.</source>
          <target state="translated">デフォルトでは、PCREは対象の文字列を（改行が含まれている場合でも）1行の文字で構成されるものとして扱います。「行の先頭」のメタ文字（ &lt;code&gt;^&lt;/code&gt; ）は文字列の先頭でのみ一致し、「行の終わり」のメタ文字（ &lt;code&gt;$&lt;/code&gt; ）は文字列の末尾または終了改行の前でのみ一致します（オプション &lt;code&gt;dollar_endonly&lt;/code&gt; が指定されていない場合））。これはPerlと同じです。</target>
        </trans-unit>
        <trans-unit id="c5979203f447d5bf52653ed357687aa3ce1b0b5f" translate="yes" xml:space="preserve">
          <source>By default, a breakpoint is active, has trigger action &lt;code&gt;enable&lt;/code&gt;, and has no associated condition. For details about breakpoints, see the User's Guide.</source>
          <target state="translated">デフォルトでは、ブレークポイントはアクティブで、トリガーアクションは &lt;code&gt;enable&lt;/code&gt; であり、関連する条件はありません。ブレークポイントの詳細については、ユーザーズガイドを参照してください。</target>
        </trans-unit>
        <trans-unit id="e107c7882dfb4fe6b976132714721e9f7743401c" translate="yes" xml:space="preserve">
          <source>By default, a filter with the content: &lt;code&gt;#{family =&amp;gt; default, flags =&amp;gt; any}&lt;/code&gt; is used. This will return all interfaces with adresses in the &lt;code&gt;inet&lt;/code&gt; and &lt;code&gt;inet6&lt;/code&gt; families.</source>
          <target state="translated">デフォルトでは、次の内容のフィルターが使用され &lt;code&gt;#{family =&amp;gt; default, flags =&amp;gt; any}&lt;/code&gt; ：＃{family =&amp;gt; default、flags =&amp;gt; any}。これにより、 &lt;code&gt;inet&lt;/code&gt; および &lt;code&gt;inet6&lt;/code&gt; ファミリのアドレスを持つすべてのインターフェイスが返されます。</target>
        </trans-unit>
        <trans-unit id="2ce5b679d831561af8a791cf34b427a861410973" translate="yes" xml:space="preserve">
          <source>By default, a name must be unique within a pattern, but this constraint can be relaxed by setting option &lt;code&gt;dupnames&lt;/code&gt; at compile time. (Duplicate names are also always permitted for subpatterns with the same number, set up as described in the previous section.) Duplicate names can be useful for patterns where only one instance of the named parentheses can match. Suppose that you want to match the name of a weekday, either as a 3-letter abbreviation or as the full name, and in both cases you want to extract the abbreviation. The following pattern (ignoring the line breaks) does the job:</source>
          <target state="translated">デフォルトでは、名前はパターン内で一意である必要がありますが、この制約はコンパイル時にオプション &lt;code&gt;dupnames&lt;/code&gt; を設定することで緩和できます。（前のセクションで説明したように設定された同じ番号のサブパターンでも、重複した名前は常に許可されます。）重複した名前は、名前付き括弧のインスタンスが1つだけ一致するパターンに役立ちます。曜日の名前を3文字の略語またはフルネームとして照合し、どちらの場合も略語を抽出するとします。次のパターン（改行を無視する）がこの仕事をします：</target>
        </trans-unit>
        <trans-unit id="c874b6a01a35c20ad7535dd46729e15bd7a18206" translate="yes" xml:space="preserve">
          <source>By default, after \x that is not followed by {, from zero to two hexadecimal digits are read (letters can be in upper or lower case). Any number of hexadecimal digits may appear between \x{ and }. If a character other than a hexadecimal digit appears between \x{ and }, or if there is no terminating }, an error occurs.</source>
          <target state="translated">デフォルトでは、{の後に続かない\xの後に、0から2桁の16進数が読み込まれます(文字は大文字でも小文字でもかまいません)。と}の間には、任意の数の 16 進数が出現する可能性があります。との間に16進数以外の文字が入った場合、または、終端がない場合はエラーとなります。</target>
        </trans-unit>
        <trans-unit id="1911d23f55521707a73b458b73f12a15fc75306a" translate="yes" xml:space="preserve">
          <source>By default, all I/O devices in OTP are set in &lt;code&gt;list&lt;/code&gt; mode. However, the I/O functions can handle any of these modes and so should other, user-written, modules behaving as clients to I/O servers.</source>
          <target state="translated">デフォルトでは、OTPのすべてのI / Oデバイスは &lt;code&gt;list&lt;/code&gt; モードに設定されています。ただし、I / O関数はこれらのモードのいずれでも処理できるため、I / Oサーバーへのクライアントとして動作する他のユーザー作成のモジュールも処理できます。</target>
        </trans-unit>
        <trans-unit id="6b2f7942ad86f7d74769554cdd60a7505d483c06" translate="yes" xml:space="preserve">
          <source>By default, all NETCONF traffic is logged in one single log file. However, different connections can be logged in separate files. To do this, use hook option &lt;code&gt;hosts&lt;/code&gt; and list the names of the servers/connections to be used in the suite. The connections must be named for this to work, that is, they must be opened with &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">デフォルトでは、すべてのNETCONFトラフィックが1つのログファイルに記録されます。ただし、異なる接続は別々のファイルに記録できます。これを行うには、フックオプションの &lt;code&gt;hosts&lt;/code&gt; を使用し、スイートで使用するサーバー/接続の名前をリストします。これを機能させるには、接続に名前を付ける必要があります。つまり、 &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; で開く必要があります。</target>
        </trans-unit>
        <trans-unit id="d82598d7e978ba992edaa523f47e7a8ba20e371c" translate="yes" xml:space="preserve">
          <source>By default, all applications are loaded with permission &lt;code&gt;true&lt;/code&gt; on all nodes. The permission can be configured using the Kernel configuration parameter &lt;code&gt;permissions&lt;/code&gt;.</source>
          <target state="translated">デフォルトでは、すべてのアプリケーションは、すべてのノードで許可 &lt;code&gt;true&lt;/code&gt; でロードされます。許可は、カーネル構成パラメーターの &lt;code&gt;permissions&lt;/code&gt; を使用して構成できます。</target>
        </trans-unit>
        <trans-unit id="5f0f346db1a0fb06831da54e7c60fe03cdae297d" translate="yes" xml:space="preserve">
          <source>By default, all code is compiled in a separate process which is terminated at the end of compilation. However, some tools, like Dialyzer or compilers for other BEAM languages, may already manage their own worker processes and spawning an extra process may slow the compilation down. In such scenarios, you can pass this option to stop the compiler from spawning an additional process.</source>
          <target state="translated">デフォルトでは、すべてのコードはコンパイル終了時に終了する別のプロセスでコンパイルされます。しかし、Dialyzerや他のBEAM言語用のコンパイラのように、いくつかのツールでは、すでに独自のワーカープロセスを管理している場合があり、余分なプロセスを生成するとコンパイルが遅くなることがあります。そのような場合には、このオプションを渡すことでコンパイラが追加プロセスを生成しないようにすることができます。</target>
        </trans-unit>
        <trans-unit id="97ad4d1175f0f089a0071483175aa615b421ee54" translate="yes" xml:space="preserve">
          <source>By default, all existing files with the same name as files in the tar file are overwritten. With this option, existing files are not overwriten.</source>
          <target state="translated">デフォルトでは、tar ファイル内のファイルと同じ名前の既存のファイルはすべて上書きされます。このオプションを使用すると、既存のファイルは上書きされません。</target>
        </trans-unit>
        <trans-unit id="7e40750937dae4fae3bc5f70b97a3f2528fbb80b" translate="yes" xml:space="preserve">
          <source>By default, all files are extracted from the tar file. With this option, only those files are extracted whose names are included in &lt;code&gt;FileList&lt;/code&gt;.</source>
          <target state="translated">デフォルトでは、すべてのファイルがtarファイルから抽出されます。このオプションを使用すると、 &lt;code&gt;FileList&lt;/code&gt; に名前が含まれているファイルのみが抽出されます。</target>
        </trans-unit>
        <trans-unit id="88e8684fe917ca09c774ce03048bec7c20dc7976" translate="yes" xml:space="preserve">
          <source>By default, all files are extracted from the zip archive. With option &lt;code&gt;{file_list, FileList}&lt;/code&gt;, function &lt;code&gt;unzip/2&lt;/code&gt; only extracts the files whose names are included in &lt;code&gt;FileList&lt;/code&gt;. The full paths, including the names of all subdirectories within the zip archive, must be specified.</source>
          <target state="translated">デフォルトでは、すべてのファイルがzipアーカイブから抽出されます。オプション &lt;code&gt;{file_list, FileList}&lt;/code&gt; 、関数 &lt;code&gt;unzip/2&lt;/code&gt; は &lt;code&gt;FileList&lt;/code&gt; に名前が含まれているファイルのみを抽出します。zipアーカイブ内のすべてのサブディレクトリの名前を含む完全なパスを指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="8373c854a1dcafc057dbfa5df0f447eef64bc1ef" translate="yes" xml:space="preserve">
          <source>By default, all files with the same name as files in the zip archive are overwritten. With option &lt;code&gt;keep_old_files&lt;/code&gt; set, function &lt;code&gt;unzip/2&lt;/code&gt; does not overwrite existing files. Notice that even with option &lt;code&gt;memory&lt;/code&gt; specified, which means that no files are overwritten, existing files are excluded from the result.</source>
          <target state="translated">デフォルトでは、zipアーカイブ内のファイルと同じ名前のすべてのファイルが上書きされます。オプション &lt;code&gt;keep_old_files&lt;/code&gt; を設定すると、関数 &lt;code&gt;unzip/2&lt;/code&gt; は既存のファイルを上書きしません。オプション &lt;code&gt;memory&lt;/code&gt; 指定されている場合でも、つまりファイルが上書きされない場合でも、既存のファイルは結果から除外されます。</target>
        </trans-unit>
        <trans-unit id="6de29fd7730a88164d057863c9dcf72fa1cb3f6c" translate="yes" xml:space="preserve">
          <source>By default, all log events originating from within OTP, except the former so called &quot;SASL reports&quot;, look the same as before.</source>
          <target state="translated">デフォルトでは、前者のいわゆる「SASLレポート」を除いて、OTP内で発生したすべてのログイベントは、以前と同じように見えます。</target>
        </trans-unit>
        <trans-unit id="2882c6abbebff5ea0f043573bc5ce53ddfde39c3" translate="yes" xml:space="preserve">
          <source>By default, all parts of the string, including the empty strings, are returned from the function, for example:</source>
          <target state="translated">デフォルトでは、例えば空の文字列を含む文字列のすべての部分が関数から返されます。</target>
        </trans-unit>
        <trans-unit id="74b4b269097f50b433c9602d13038dfa07527232" translate="yes" xml:space="preserve">
          <source>By default, an &lt;code&gt;OCTET STRING&lt;/code&gt; is always represented as an Erlang binary. If the specification has been compiled with option &lt;code&gt;legacy_erlang_types&lt;/code&gt;, the encode functions accept both lists and binaries, and the decode functions decode an &lt;code&gt;OCTET STRING&lt;/code&gt; to a list.</source>
          <target state="translated">デフォルトでは、 &lt;code&gt;OCTET STRING&lt;/code&gt; は常にErlangバイナリとして表されます。仕様がオプション &lt;code&gt;legacy_erlang_types&lt;/code&gt; でコンパイルされている場合、エンコード関数はリストとバイナリの両方を受け入れ、デコード関数は &lt;code&gt;OCTET STRING&lt;/code&gt; をリストにデコードします。</target>
        </trans-unit>
        <trans-unit id="0bac80eb92816a5a88bf3b52b9fd2aacd857eeb1" translate="yes" xml:space="preserve">
          <source>By default, autostart information is stored in a file named &lt;code&gt;ttb_autostart.bin&lt;/code&gt; on each node. If this is not desired (for example, on diskless nodes), a custom module handling autostart information storage and retrieval can be provided by specifying environment variable &lt;code&gt;ttb_autostart_module&lt;/code&gt; for the application Runtime_Tools. The module must respond to the following API:</source>
          <target state="translated">デフォルトでは、自動起動情報は各ノードの &lt;code&gt;ttb_autostart.bin&lt;/code&gt; という名前のファイルに格納されています。これが望ましくない場合（ディスクレスノードなど）、アプリケーションのRuntime_Toolsに環境変数 &lt;code&gt;ttb_autostart_module&lt;/code&gt; を指定することで、自動起動情報の格納と取得を処理するカスタムモジュールを提供できます。モジュールは次のAPIに応答する必要があります。</target>
        </trans-unit>
        <trans-unit id="ad25aa21de1694492059b0bfb35caab2d579e0fb" translate="yes" xml:space="preserve">
          <source>By default, characters with values &amp;gt; 255 do not match any of the Posix character classes. However, if option &lt;code&gt;PCRE_UCP&lt;/code&gt; is passed to &lt;code&gt;pcre_compile()&lt;/code&gt;, some of the classes are changed so that Unicode character properties are used. This is achieved by replacing certain Posix classes by other sequences, as follows:</source>
          <target state="translated">デフォルトでは、255より大きい値の文字は、どのPosix文字クラスとも一致しません。ただし、オプション &lt;code&gt;PCRE_UCP&lt;/code&gt; が &lt;code&gt;pcre_compile()&lt;/code&gt; に渡されると、一部のクラスが変更され、Unicode文字プロパティが使用されます。これは、次のように、特定のPosixクラスを他のシーケンスで置き換えることによって実現されます。</target>
        </trans-unit>
        <trans-unit id="053346f97801947e69ed842b8b3fec738287fe79" translate="yes" xml:space="preserve">
          <source>By default, data for all Telnet connections is logged in one common file (named &lt;code&gt;default&lt;/code&gt;), which can get messy, for example, if multiple Telnet sessions are running in parallel. Therefore a separate log file can be created for each connection. To configure this, use hook option &lt;code&gt;hosts&lt;/code&gt; and list the names of the servers/connections to be used in the suite. The connections must be named for this to work (see &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;ct_telnet:open/1,2,3,4&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">デフォルトでは、すべてのTelnet接続のデータは1つの共通ファイル（ &lt;code&gt;default&lt;/code&gt; という名前）に記録されます。たとえば、複数のTelnetセッションが並行して実行されている場合、ファイルが煩雑になる可能性があります。したがって、接続ごとに個別のログファイルを作成できます。これを構成するには、フックオプション &lt;code&gt;hosts&lt;/code&gt; を使用し、スイートで使用するサーバー/接続の名前をリストします。これを機能させるには、接続に名前を &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;ct_telnet:open/1,2,3,4&lt;/a&gt;&lt;/code&gt; 必要があります（ct_telnet：open / 1,2,3,4を参照）。</target>
        </trans-unit>
        <trans-unit id="776bbd51980a39359333108981da5fd37cece1a7" translate="yes" xml:space="preserve">
          <source>By default, each CTH installed is executed in the order that they are installed for init calls, and then reversed for end calls. This is not always desired, so &lt;code&gt;Common Test&lt;/code&gt; allows the user to specify a priority for each hook. The priority can either be specified in the CTH function &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:init-2&quot;&gt;init/2&lt;/a&gt;&lt;/code&gt; or when installing the hook. The priority specified at installation overrides the priority returned by the CTH.</source>
          <target state="translated">デフォルトでは、インストールされた各CTHは、initコール用にインストールされた順に実行され、次に終了コール用に逆にされます。これは常に望ましいわけではないため、 &lt;code&gt;Common Test&lt;/code&gt; を使用すると、ユーザーは各フックの優先度を指定できます。優先度は、CTH関数 &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:init-2&quot;&gt;init/2&lt;/a&gt;&lt;/code&gt; で指定するか、フックをインストールするときに指定できます。インストール時に指定された優先順位は、CTHによって返される優先順位をオーバーライドします。</target>
        </trans-unit>
        <trans-unit id="462e7da9c97e5f027114d96a2306c993c035da8a" translate="yes" xml:space="preserve">
          <source>By default, each installation of a CTH causes a new instance of it to be activated. This can cause problems if you want to override CTHs in test specifications while still having them in the suite information function. The &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:id-1&quot;&gt;id/1&lt;/a&gt;&lt;/code&gt; callback exists to address this problem. By returning the same &lt;code&gt;id&lt;/code&gt; in both places, &lt;code&gt;Common Test&lt;/code&gt; knows that this CTH is already installed and does not try to install it again.</source>
          <target state="translated">デフォルトでは、CTHをインストールするたびに、CTHの新しいインスタンスがアクティブになります。これは、スイート情報関数にCTHを残したまま、テスト仕様のCTHをオーバーライドしたい場合に問題を引き起こす可能性があります。この問題に対処するために、 &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:id-1&quot;&gt;id/1&lt;/a&gt;&lt;/code&gt; コールバックが存在します。両方の場所で同じ &lt;code&gt;id&lt;/code&gt; を返すことにより、 &lt;code&gt;Common Test&lt;/code&gt; はこのCTHがすでにインストールされていることを認識し、再度インストールを試みません。</target>
        </trans-unit>
        <trans-unit id="46480571329f9b5765128d1e4d2b38b49550c0a0" translate="yes" xml:space="preserve">
          <source>By default, errors and warnings are printed to tty and the function returns &lt;code&gt;ok&lt;/code&gt; or &lt;code&gt;error&lt;/code&gt;. If option &lt;code&gt;silent&lt;/code&gt; is specified, the function instead either returns &lt;code&gt;{ok,Relup,Module,Warnings}&lt;/code&gt;, where &lt;code&gt;Relup&lt;/code&gt; is the release upgrade file, or &lt;code&gt;{error,Module,Error}&lt;/code&gt;. Warnings and errors can be converted to strings by calling &lt;code&gt;Module:format_warning(Warnings)&lt;/code&gt; or &lt;code&gt;Module:format_error(Error)&lt;/code&gt;.</source>
          <target state="translated">デフォルトでは、エラーと警告はttyに出力され、関数は &lt;code&gt;ok&lt;/code&gt; または &lt;code&gt;error&lt;/code&gt; を返します。オプション &lt;code&gt;silent&lt;/code&gt; が指定されている場合、関数は代わりに &lt;code&gt;{ok,Relup,Module,Warnings}&lt;/code&gt; （ &lt;code&gt;Relup&lt;/code&gt; はリリースアップグレードファイル）または &lt;code&gt;{error,Module,Error}&lt;/code&gt; 返します。警告とエラーは、 &lt;code&gt;Module:format_warning(Warnings)&lt;/code&gt; または &lt;code&gt;Module:format_error(Error)&lt;/code&gt; を呼び出すことで文字列に変換できます。</target>
        </trans-unit>
        <trans-unit id="294052fb58119cdee244d014d8cb85f8f3d4b24a" translate="yes" xml:space="preserve">
          <source>By default, errors and warnings are printed to tty and the function returns &lt;code&gt;ok&lt;/code&gt; or &lt;code&gt;error&lt;/code&gt;. If option &lt;code&gt;silent&lt;/code&gt; is specified, the function instead returns &lt;code&gt;{ok,Module,Warnings}&lt;/code&gt; or &lt;code&gt;{error,Module,Error}&lt;/code&gt;. Warnings and errors can be converted to strings by calling &lt;code&gt;Module:format_warning(Warnings)&lt;/code&gt; or &lt;code&gt;Module:format_error(Error)&lt;/code&gt;.</source>
          <target state="translated">デフォルトでは、エラーと警告はttyに出力され、関数は &lt;code&gt;ok&lt;/code&gt; または &lt;code&gt;error&lt;/code&gt; を返します。オプション &lt;code&gt;silent&lt;/code&gt; が指定されている場合、関数は代わりに &lt;code&gt;{ok,Module,Warnings}&lt;/code&gt; または &lt;code&gt;{error,Module,Error}&lt;/code&gt; 返します。警告とエラーは、 &lt;code&gt;Module:format_warning(Warnings)&lt;/code&gt; または &lt;code&gt;Module:format_error(Error)&lt;/code&gt; を呼び出すことで文字列に変換できます。</target>
        </trans-unit>
        <trans-unit id="4b92da4aa5277f398cb7d427508ed2a69567e18a" translate="yes" xml:space="preserve">
          <source>By default, errors and warnings are printed to tty and the function returns &lt;code&gt;ok&lt;/code&gt; or &lt;code&gt;error&lt;/code&gt;. If option &lt;code&gt;{ok,Module,Warnings}&lt;/code&gt; or &lt;code&gt;{error,Module,Error}&lt;/code&gt;. &lt;code&gt;silent&lt;/code&gt; is specified, the function instead returns Warnings and errors can be converted to strings by calling &lt;code&gt;Module:format_warning(Warnings)&lt;/code&gt; or &lt;code&gt;Module:format_error(Error)&lt;/code&gt;.</source>
          <target state="translated">デフォルトでは、エラーと警告はttyに出力され、関数は &lt;code&gt;ok&lt;/code&gt; または &lt;code&gt;error&lt;/code&gt; を返します。オプション &lt;code&gt;{ok,Module,Warnings}&lt;/code&gt; または &lt;code&gt;{error,Module,Error}&lt;/code&gt; 。 &lt;code&gt;silent&lt;/code&gt; が指定されている場合、関数は代わりに警告を返し、 &lt;code&gt;Module:format_warning(Warnings)&lt;/code&gt; または &lt;code&gt;Module:format_error(Error)&lt;/code&gt; を呼び出すことでエラーを文字列に変換できます。</target>
        </trans-unit>
        <trans-unit id="ee3c67a77746a67e2bb8398f5d758b0ceca821c3" translate="yes" xml:space="preserve">
          <source>By default, function &lt;code&gt;open/2&lt;/code&gt; function opens the tar file in &lt;code&gt;raw&lt;/code&gt; mode, which is faster but does not allow a remote (Erlang) file server to be used. Adding &lt;code&gt;cooked&lt;/code&gt; to the mode list overrides the default and opens the tar file without option &lt;code&gt;raw&lt;/code&gt;.</source>
          <target state="translated">デフォルトでは、関数 &lt;code&gt;open/2&lt;/code&gt; 関数はtarファイルを &lt;code&gt;raw&lt;/code&gt; モードで開きます。これはより高速ですが、リモート（Erlang）ファイルサーバーの使用を許可しません。モードリストに &lt;code&gt;cooked&lt;/code&gt; を追加すると、デフォルトが上書きされ、オプション &lt;code&gt;raw&lt;/code&gt; なしでtarファイルが開きます。</target>
        </trans-unit>
        <trans-unit id="c31b08201db8e452376ac550216866c4f0213c87" translate="yes" xml:space="preserve">
          <source>By default, function &lt;code&gt;open/2&lt;/code&gt; opens the tar file in &lt;code&gt;raw&lt;/code&gt; mode, which is faster but does not allow a remote (Erlang) file server to be used. Adding &lt;code&gt;cooked&lt;/code&gt; to the mode list overrides the default and opens the tar file without option &lt;code&gt;raw&lt;/code&gt;.</source>
          <target state="translated">デフォルトでは、関数 &lt;code&gt;open/2&lt;/code&gt; はtarファイルを &lt;code&gt;raw&lt;/code&gt; モードで開きます。これはより高速ですが、リモート（Erlang）ファイルサーバーの使用を許可しません。モードリストに &lt;code&gt;cooked&lt;/code&gt; を追加すると、デフォルトが上書きされ、オプション &lt;code&gt;raw&lt;/code&gt; なしでtarファイルが開きます。</target>
        </trans-unit>
        <trans-unit id="4c4fa6e3241b3f16b2494ba76c92a8e6751097f9" translate="yes" xml:space="preserve">
          <source>By default, if any requested chunk is missing in &lt;code&gt;Beam&lt;/code&gt;, an &lt;code&gt;error&lt;/code&gt; tuple is returned. However, if option &lt;code&gt;allow_missing_chunks&lt;/code&gt; is specified, a result is returned even if chunks are missing. In the result list, any missing chunks are represented as &lt;code&gt;{ChunkRef,missing_chunk}&lt;/code&gt;. Notice however that if chunk &lt;code&gt;&quot;Atom&quot;&lt;/code&gt; is missing, that is considered a fatal error and the return value is an &lt;code&gt;error&lt;/code&gt; tuple.</source>
          <target state="translated">デフォルトでは、要求されたチャンクが &lt;code&gt;Beam&lt;/code&gt; で欠落している場合、 &lt;code&gt;error&lt;/code&gt; タプルが返されます。ただし、オプション &lt;code&gt;allow_missing_chunks&lt;/code&gt; が指定されている場合、チャンクが欠落している場合でも結果が返されます。結果リストでは、欠落しているチャンクは &lt;code&gt;{ChunkRef,missing_chunk}&lt;/code&gt; として表されます。ただし、チャンク &lt;code&gt;&quot;Atom&quot;&lt;/code&gt; が欠落している場合、これは致命的なエラーと見なされ、戻り値は &lt;code&gt;error&lt;/code&gt; タプルであることに注意してください。</target>
        </trans-unit>
        <trans-unit id="6f53b57e48d13ba35bc616bbd211c0e3f61e0177" translate="yes" xml:space="preserve">
          <source>By default, in &lt;code&gt;unicode&lt;/code&gt; mode, characters with values &amp;gt; 255, that is, all characters outside the ISO Latin-1 character set, never match \d, \s, or \w, and always match \D, \S, and \W. These sequences retain their original meanings from before UTF support was available, mainly for efficiency reasons. However, if option &lt;code&gt;ucp&lt;/code&gt; is set, the behavior is changed so that Unicode properties are used to determine character types, as follows:</source>
          <target state="translated">デフォルトでは、 &lt;code&gt;unicode&lt;/code&gt; モードでは、値が255を超える文字、つまりISO Latin-1文字セット外のすべての文字は、\ d、\ s、または\ wとは一致せず、常に\ D、\ S、および\と一致します。 W これらのシーケンスは、主に効率上の理由から、UTFサポートが利用可能になる前の元の意味を保持しています。ただし、オプション &lt;code&gt;ucp&lt;/code&gt; が設定されている場合は、次のように動作が変更され、Unicodeプロパティを使用して文字タイプが決定されます。</target>
        </trans-unit>
        <trans-unit id="8dce2b9977241b689bc8a7cc79ba1876582a372f" translate="yes" xml:space="preserve">
          <source>By default, symbolic links are stored as symbolic links in the tar file. To override the default and store the file that the symbolic link points to into the tar file, use option &lt;code&gt;dereference&lt;/code&gt;.</source>
          <target state="translated">デフォルトでは、シンボリックリンクはシンボリックリンクとしてtarファイルに保存されます。デフォルトを上書きして、シンボリックリンクが指すファイルをtarファイルに保存するには、オプション &lt;code&gt;dereference&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="307631df678df3363024a8553c6845aa25ac4dbc" translate="yes" xml:space="preserve">
          <source>By default, that lock is at the driver level, that is, if several ports have been opened to the same driver, only code for one port at the same time can be running.</source>
          <target state="translated">デフォルトでは、そのロックはドライバレベルで、つまり、複数のポートが同じドライバにオープンされている場合、同時に1つのポートのためのコードのみが実行されます。</target>
        </trans-unit>
        <trans-unit id="59ef4e65d1c06e09a6d712a392cd376d76f7e30c" translate="yes" xml:space="preserve">
          <source>By default, the &lt;code&gt;Erl_Interface&lt;/code&gt; libraries are only guaranteed to be compatible with other Erlang/OTP components from the same release as the libraries themselves. For information about how to communicate with Erlang/OTP components from earlier releases, see function &lt;code&gt;&lt;a href=&quot;ei#ei_set_compat_rel&quot;&gt;ei:ei_set_compat_rel&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;erl_eterm#erl_set_compat_rel&quot;&gt;erl_eterm:erl_set_compat_rel&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">デフォルトでは、 &lt;code&gt;Erl_Interface&lt;/code&gt; ライブラリは、ライブラリ自体と同じリリースの他のErlang / OTPコンポーネントとの互換性のみが保証されています。以前のリリースのErlang / OTPコンポーネントと通信する方法については、関数 &lt;code&gt;&lt;a href=&quot;ei#ei_set_compat_rel&quot;&gt;ei:ei_set_compat_rel&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;erl_eterm#erl_set_compat_rel&quot;&gt;erl_eterm:erl_set_compat_rel&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="de70cb5ed283df211d9a60f565e19a6787b411b0" translate="yes" xml:space="preserve">
          <source>By default, the &lt;code&gt;Erl_Interface&lt;/code&gt; library is only guaranteed to be compatible with other Erlang/OTP components from the same release as the &lt;code&gt;Erl_Interface&lt;/code&gt; library itself. For example, &lt;code&gt;Erl_Interface&lt;/code&gt; from Erlang/OTP R10 is not compatible with an Erlang emulator from Erlang/OTP R9 by default.</source>
          <target state="translated">デフォルトでは、 &lt;code&gt;Erl_Interface&lt;/code&gt; ライブラリは、 &lt;code&gt;Erl_Interface&lt;/code&gt; ライブラリ自体と同じリリースの他のErlang / OTPコンポーネントとの互換性のみが保証されています。たとえば、Erlang / OTP R10の &lt;code&gt;Erl_Interface&lt;/code&gt; は、デフォルトではErlang / OTP R9のErlangエミュレーターと互換性がありません。</target>
        </trans-unit>
        <trans-unit id="f1410ec7350e5013f18865c794a36ebbd177c8c8" translate="yes" xml:space="preserve">
          <source>By default, the &lt;code&gt;Erl_Interface&lt;/code&gt; library is only guaranteed to be compatible with other Erlang/OTP components from the same release as the libraries themselves. For information about how to communicate with Erlang/OTP components from earlier releases, see function &lt;code&gt;&lt;a href=&quot;ei#ei_set_compat_rel&quot;&gt; ei_set_compat_rel&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">デフォルトでは、 &lt;code&gt;Erl_Interface&lt;/code&gt; ライブラリは、ライブラリ自体と同じリリースの他のErlang / OTPコンポーネントとの互換性のみが保証されています。以前のリリースのErlang / OTPコンポーネントと通信する方法については、関数 &lt;code&gt;&lt;a href=&quot;ei#ei_set_compat_rel&quot;&gt; ei_set_compat_rel&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="5408a0e73229b9b5e967fe902da2634b16e6868a" translate="yes" xml:space="preserve">
          <source>By default, the &lt;code&gt;ei&lt;/code&gt; library is only guaranteed to be compatible with other Erlang/OTP components from the same release as the &lt;code&gt;ei&lt;/code&gt; library itself. For example, &lt;code&gt;ei&lt;/code&gt; from Erlang/OTP R10 is not compatible with an Erlang emulator from Erlang/OTP R9 by default.</source>
          <target state="translated">デフォルトでは、 &lt;code&gt;ei&lt;/code&gt; ライブラリは、 &lt;code&gt;ei&lt;/code&gt; ライブラリ自体と同じリリースの他のErlang / OTPコンポーネントとの互換性のみが保証されています。たとえば、Erlang / OTP R10の &lt;code&gt;ei&lt;/code&gt; は、デフォルトではErlang / OTP R9のErlangエミュレーターと互換性がありません。</target>
        </trans-unit>
        <trans-unit id="cc7855f5354d795a3773624d2090708d90c447ea" translate="yes" xml:space="preserve">
          <source>By default, the &lt;strong&gt;default user&lt;/strong&gt; is set to the &lt;code&gt;snmpm_user_default&lt;/code&gt; module, which simply sends an info message to the error_logger. It is however highly recommended that this module be replaced by another that does something useful (see &lt;code&gt;&lt;a href=&quot;snmp_config#configuration_params&quot;&gt;configuration params&lt;/a&gt;&lt;/code&gt; for more info).</source>
          <target state="translated">デフォルトでは、&lt;strong&gt;デフォルトのユーザー&lt;/strong&gt;は &lt;code&gt;snmpm_user_default&lt;/code&gt; モジュールに設定されています。このモジュールは単に情報メッセージをerror_loggerに送信します。ただし、このモジュールは、何か有用な別のモジュールに置き換えることを強くお勧めします（詳細については、 &lt;code&gt;&lt;a href=&quot;snmp_config#configuration_params&quot;&gt;configuration params&lt;/a&gt;&lt;/code&gt; を参照してください）。</target>
        </trans-unit>
        <trans-unit id="8754a9737ab7ee6fe2f3b847124e99177bf4ce53" translate="yes" xml:space="preserve">
          <source>By default, the Cover tool is automatically stopped when the tests are completed. This causes the original (non-cover compiled) modules to be loaded back into the test node. If a process at this point still runs old code of any of the modules that are cover compiled, meaning that it has not done any fully qualified function call after the cover compilation, the process is killed. To avoid this, set the value of option &lt;code&gt;cover_stop&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;. This means that the modules stay cover compiled. Therefore, this is only recommended if the Erlang nodes under test are terminated after the test is completed, or if cover can be manually stopped.</source>
          <target state="translated">デフォルトでは、テストが完了すると、カバーツールは自動的に停止します。これにより、元の（カバーコンパイルされていない）モジュールがテストノードに再度読み込まれます。この時点でプロセスがカバーコンパイルされたモジュールの古いコードをまだ実行している場合、つまりカバーコンパイル後に完全修飾関数呼び出しを実行していない場合、プロセスは強制終了されます。これを回避するには、オプション &lt;code&gt;cover_stop&lt;/code&gt; の値を &lt;code&gt;false&lt;/code&gt; に設定します。つまり、モジュールはカバーコンパイルされたままです。したがって、これは、テストが終了した後にテスト対象のErlangノードが終了した場合、またはカバーを手動で停止できる場合にのみ推奨されます。</target>
        </trans-unit>
        <trans-unit id="9bc1af126fb19b5493bbbaf63937647ea51683fa" translate="yes" xml:space="preserve">
          <source>By default, the Kernel application installs one log handler at system start. This handler is named &lt;code&gt;default&lt;/code&gt;. It receives and processes standard log events produced by the Erlang runtime system, standard behaviours and different Erlang/OTP applications. The log events are by default printed to the terminal.</source>
          <target state="translated">デフォルトでは、カーネルアプリケーションはシステムの起動時に1つのログハンドラーをインストールします。このハンドラーの名前は &lt;code&gt;default&lt;/code&gt; です。これは、Erlangランタイムシステム、標準の動作、およびさまざまなErlang / OTPアプリケーションによって生成された標準のログイベントを受信して​​処理します。ログイベントはデフォルトで端末に出力されます。</target>
        </trans-unit>
        <trans-unit id="44204f5230679d2fef96d8949b078f4f3e6c9083" translate="yes" xml:space="preserve">
          <source>By default, the Kernel application installs one log handler at system start. This handler is named &lt;code&gt;default&lt;/code&gt;. It receives and processes standard log events produced by the Erlang runtime system, standard behaviours and different Erlang/OTP applications. The log events are by default written to the terminal.</source>
          <target state="translated">デフォルトでは、カーネルアプリケーションはシステムの起動時に1つのログハンドラーをインストールします。このハンドラーの名前は &lt;code&gt;default&lt;/code&gt; です。これは、Erlangランタイムシステム、標準の動作、およびさまざまなErlang / OTPアプリケーションによって生成された標準のログイベントを受信して​​処理します。ログイベントはデフォルトで端末に書き込まれます。</target>
        </trans-unit>
        <trans-unit id="05263651b062c95772f413d54c47f0b67ec3f917" translate="yes" xml:space="preserve">
          <source>By default, the actual access to the backup media is performed through module &lt;code&gt;mnesia_backup&lt;/code&gt; for both read and write. Currently &lt;code&gt;mnesia_backup&lt;/code&gt; is implemented with the standard library module &lt;code&gt;disc_log&lt;/code&gt;. However, you can write your own module with the same interface as &lt;code&gt;mnesia_backup&lt;/code&gt; and configure &lt;code&gt;Mnesia&lt;/code&gt; so that the alternative module performs the actual accesses to the backup media. The user can therefore put the backup on a media that &lt;code&gt;Mnesia&lt;/code&gt; does not know about, possibly on hosts where Erlang is not running. Use configuration parameter &lt;code&gt;-mnesia backup_module &amp;lt;module&amp;gt;&lt;/code&gt; for this purpose.</source>
          <target state="translated">デフォルトでは、バックアップメディアへの実際のアクセスは、読み取りと書き込みの両方でモジュール &lt;code&gt;mnesia_backup&lt;/code&gt; を介して実行されます。現在 &lt;code&gt;mnesia_backup&lt;/code&gt; は標準ライブラリモジュール &lt;code&gt;disc_log&lt;/code&gt; で実装されています。しかし、あなたが同じインターフェイスを使用して独自のモジュールを書くことができ &lt;code&gt;mnesia_backup&lt;/code&gt; とのconfigure &lt;code&gt;Mnesia&lt;/code&gt; バックアップメディアの代替モジュールが行い、実際のアクセスをするように。したがって、ユーザーは &lt;code&gt;Mnesia&lt;/code&gt; が認識していないメディア、おそらくErlangが実行されていないホストにバックアップを置くことができます。このためには、構成パラメーター &lt;code&gt;-mnesia backup_module &amp;lt;module&amp;gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="f1afaf0fcbb8ede75fea0c65c21d25a0925f3450" translate="yes" xml:space="preserve">
          <source>By default, the agent has no knowledge of any other contexts than the default context, &lt;code&gt;&quot;&quot;&lt;/code&gt;. If it is to support more contexts, these must be explicitly added, by using an appropriate configuration file &lt;code&gt;&lt;a href=&quot;snmp_agent_config_files&quot;&gt;Agent Configuration Files&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">デフォルトでは、エージェントはデフォルトのコンテキスト &lt;code&gt;&quot;&quot;&lt;/code&gt; 以外のコンテキストを認識していません。より多くのコンテキストをサポートする場合は、適切な構成ファイル &lt;code&gt;&lt;a href=&quot;snmp_agent_config_files&quot;&gt;Agent Configuration Files&lt;/a&gt;&lt;/code&gt; を使用して、これらを明示的に追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="90e34246dd8429aefe6c7b588f2a3b0f064042d2" translate="yes" xml:space="preserve">
          <source>By default, the boot script and boot file are located in the same directory as &lt;code&gt;Name.rel&lt;/code&gt;. That is, in the current working directory unless &lt;code&gt;Name&lt;/code&gt; contains a path. If option &lt;code&gt;{outdir,Dir}&lt;/code&gt; is specified, they are located in &lt;code&gt;Dir&lt;/code&gt; instead.</source>
          <target state="translated">デフォルトでは、ブートスクリプトとブートファイルは &lt;code&gt;Name.rel&lt;/code&gt; と同じディレクトリにあります。つまり、 &lt;code&gt;Name&lt;/code&gt; にパスが含まれていない限り、現在の作業ディレクトリです。オプション &lt;code&gt;{outdir,Dir}&lt;/code&gt; が指定されている場合、それらは代わりに &lt;code&gt;Dir&lt;/code&gt; に配置されます。</target>
        </trans-unit>
        <trans-unit id="12131639ccba633c1e0c7ee60e1e122164ffcb95" translate="yes" xml:space="preserve">
          <source>By default, the compile server is not used. It can be enabled by giving &lt;code&gt;erlc&lt;/code&gt; the option &lt;code&gt;-server&lt;/code&gt; or by setting the environment variable &lt;code&gt;ERLC_USE_SERVER&lt;/code&gt; to &lt;code&gt;yes&lt;/code&gt; or &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">デフォルトでは、コンパイルサーバーは使用されません。 &lt;code&gt;erlc&lt;/code&gt; にオプション &lt;code&gt;-server&lt;/code&gt; を指定するか、環境変数 &lt;code&gt;ERLC_USE_SERVER&lt;/code&gt; を &lt;code&gt;yes&lt;/code&gt; または &lt;code&gt;true&lt;/code&gt; に設定することで有効にできます。</target>
        </trans-unit>
        <trans-unit id="4d3804b66310d736d0a24d21cca9ed0959844c03" translate="yes" xml:space="preserve">
          <source>By default, the generated code for operation &lt;code&gt;Record#record_tag.field&lt;/code&gt; verifies that the tuple &lt;code&gt;Record&lt;/code&gt; has the correct size for the record, and that the first element is the tag &lt;code&gt;record_tag&lt;/code&gt;. Use this option to omit the verification code.</source>
          <target state="translated">デフォルトでは、操作 &lt;code&gt;Record#record_tag.field&lt;/code&gt; に対して生成されたコードは、タプル &lt;code&gt;Record&lt;/code&gt; がレコードに適切なサイズであり、最初の要素がタグ &lt;code&gt;record_tag&lt;/code&gt; であることを確認します。このオプションを使用して、確認コードを省略します。</target>
        </trans-unit>
        <trans-unit id="92ed03811630a1034411365747a68f1b027d08b7" translate="yes" xml:space="preserve">
          <source>By default, the maximum number of atoms is 1,048,576. This limit can be raised or lowered using the &lt;code&gt;+t&lt;/code&gt; option.</source>
          <target state="translated">デフォルトでは、アトムの最大数は1,048,576です。この制限は、 &lt;code&gt;+t&lt;/code&gt; オプションを使用して増減できます。</target>
        </trans-unit>
        <trans-unit id="c86aae6b772372c0ae40b88282e56c074aa7a5f1" translate="yes" xml:space="preserve">
          <source>By default, the parser that was generated will not print out error messages to the screen. The user will have to do this either by printing the returned error messages, or by inserting tests and print instructions in the Erlang code associated with the syntax rules of the grammar file.</source>
          <target state="translated">デフォルトでは、生成されたパーサはエラーメッセージを画面に出力しません。ユーザーは返されたエラーメッセージを印刷するか、文法ファイルの構文ルールに関連付けられたErlangコードにテストと印刷命令を挿入するかのどちらかをしなければなりません。</target>
        </trans-unit>
        <trans-unit id="e241a1115343866b033984b2e0f3224cbedbb8d1" translate="yes" xml:space="preserve">
          <source>By default, the quantifiers are &quot;greedy&quot;, that is, they match as much as possible (up to the maximum number of permitted times), without causing the remaining pattern to fail. The classic example of where this gives problems is in trying to match comments in C programs. These appear between /* and */. Within the comment, individual * and / characters can appear. An attempt to match C comments by applying the pattern</source>
          <target state="translated">デフォルトでは、量詞は &quot;貪欲 &quot;で、残りのパターンを失敗させることなく、可能な限り(許可される最大回数まで)マッチします。これが問題となる典型的な例は、C言語のプログラムでコメントをマッチさせようとする場合です。これらのコメントは /*と */の間に現れます。コメントの中には、個々の*や/が現れることがあります。パターンを適用してC言語のコメントにマッチさせようとすると、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="3c85bc6c43eb52272e65af88f8cd9d253d828366" translate="yes" xml:space="preserve">
          <source>By default, the release package contains the directories &lt;code&gt;lib/App-Vsn/ebin&lt;/code&gt; and &lt;code&gt;lib/App-Vsn/priv&lt;/code&gt; for each included application. If more directories are to be included, option &lt;code&gt;dirs&lt;/code&gt; is specified, for example, &lt;code&gt;{dirs,[src,examples]}&lt;/code&gt;.</source>
          <target state="translated">デフォルトでは、リリースパッケージには、含まれる各アプリケーションのディレクトリ &lt;code&gt;lib/App-Vsn/ebin&lt;/code&gt; および &lt;code&gt;lib/App-Vsn/priv&lt;/code&gt; が含まれています。さらにディレクトリを含める場合は、オプション &lt;code&gt;dirs&lt;/code&gt; を指定します（例： &lt;code&gt;{dirs,[src,examples]}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f48b56c162fe6bc8e83c9024713b2063795276f9" translate="yes" xml:space="preserve">
          <source>By default, the release package file is located in the same directory as &lt;code&gt;Name.rel&lt;/code&gt;. That is, in the current working directory unless &lt;code&gt;Name&lt;/code&gt; contains a path. If option &lt;code&gt;{outdir,Dir}&lt;/code&gt; is specified, it is located in &lt;code&gt;Dir&lt;/code&gt; instead.</source>
          <target state="translated">デフォルトでは、リリースパッケージファイルは &lt;code&gt;Name.rel&lt;/code&gt; と同じディレクトリにあります。つまり、 &lt;code&gt;Name&lt;/code&gt; にパスが含まれていない限り、現在の作業ディレクトリです。オプション &lt;code&gt;{outdir,Dir}&lt;/code&gt; が指定されている場合は、代わりに &lt;code&gt;Dir&lt;/code&gt; に配置されます。</target>
        </trans-unit>
        <trans-unit id="cd67be193ef985280c7869e02ad1eaa76d02cee6" translate="yes" xml:space="preserve">
          <source>By default, the script will be interpreted. You can force it to be compiled by including the following line somewhere in the script file:</source>
          <target state="translated">デフォルトでは、スクリプトは解釈されます。スクリプトファイルのどこかに以下の行を含めることで、強制的にコンパイルさせることができます。</target>
        </trans-unit>
        <trans-unit id="b2a64b819e1641df3c5bc639a09bb56418f80b28" translate="yes" xml:space="preserve">
          <source>By default, the tar file is opened in &lt;code&gt;raw&lt;/code&gt; mode, which is faster but does not allow a remote (Erlang) file server to be used. Adding &lt;code&gt;cooked&lt;/code&gt; to the mode list overrides the default and opens the tar file without option &lt;code&gt;raw&lt;/code&gt;.</source>
          <target state="translated">デフォルトでは、tarファイルは &lt;code&gt;raw&lt;/code&gt; モードで開かれます。これはより高速ですが、リモート（Erlang）ファイルサーバーを使用できません。モードリストに &lt;code&gt;cooked&lt;/code&gt; を追加すると、デフォルトが上書きされ、オプション &lt;code&gt;raw&lt;/code&gt; なしでtarファイルが開きます。</target>
        </trans-unit>
        <trans-unit id="968238200f11724a49fdbda317cbe260c831d025" translate="yes" xml:space="preserve">
          <source>By default, the value is as before, that is, &lt;code&gt;minimal&lt;/code&gt;.</source>
          <target state="translated">デフォルトでは、値は以前と同じ、つまり &lt;code&gt;minimal&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="76563b7abdc9fe4d5e61b108b45efa4f79168faa" translate="yes" xml:space="preserve">
          <source>By default, this function adds &quot;\n&quot; to the end of the specified command. If this is not desired, option &lt;code&gt;{newline,false}&lt;/code&gt; can be used. This is necessary, for example, when sending Telnet command sequences prefixed with character Interpret As Command (IAC). Option &lt;code&gt;{newline,string()}&lt;/code&gt; can also be used if a different line end than &quot;\n&quot; is required, for instance &lt;code&gt;{newline,&quot;\r\n&quot;}&lt;/code&gt;, to add both carriage return and newline characters.</source>
          <target state="translated">デフォルトでは、この関数は指定されたコマンドの最後に「\ n」を追加します。これが望ましくない場合は、オプション &lt;code&gt;{newline,false}&lt;/code&gt; を使用できます。これは、たとえば、文字Interpret As Command（IAC）で始まるTelnetコマンドシーケンスを送信する場合に必要です。オプション &lt;code&gt;{newline,string()}&lt;/code&gt; は、 &quot;\ n&quot;とは異なる行末が必要な場合、たとえば &lt;code&gt;{newline,&quot;\r\n&quot;}&lt;/code&gt; を使用して、キャリッジリターンと改行文字の両方を追加することもできます。</target>
        </trans-unit>
        <trans-unit id="853ca12d28a4ac6514c7cb70a17bec30cd8f3e6f" translate="yes" xml:space="preserve">
          <source>By default, this function adds &quot;\n&quot; to the end of the specified command. If this is not desired, use option &lt;code&gt;{newline,false}&lt;/code&gt;. This is necessary, for example, when sending Telnet command sequences prefixed with character Interpret As Command (IAC). Option &lt;code&gt;{newline,string()}&lt;/code&gt; can also be used if a different line end than &quot;\n&quot; is required, for instance &lt;code&gt;{newline,&quot;\r\n&quot;}&lt;/code&gt;, to add both carriage return and newline characters.</source>
          <target state="translated">デフォルトでは、この関数は指定されたコマンドの最後に「\ n」を追加します。これが望ましくない場合は、オプション &lt;code&gt;{newline,false}&lt;/code&gt; 。これは、たとえば、文字Interpret As Command（IAC）で始まるTelnetコマンドシーケンスを送信する場合に必要です。オプション &lt;code&gt;{newline,string()}&lt;/code&gt; は、 &quot;\ n&quot;とは異なる行末が必要な場合、たとえば &lt;code&gt;{newline,&quot;\r\n&quot;}&lt;/code&gt; を使用して、キャリッジリターンと改行文字の両方を追加することもできます。</target>
        </trans-unit>
        <trans-unit id="e69fa5b82743edee630d33a79817b045aafc5d81" translate="yes" xml:space="preserve">
          <source>By default, this function adds a new line to the end of the specified command. If this is not desired, use option &lt;code&gt;{newline,false}&lt;/code&gt;. This is necessary, for example, when sending Telnet command sequences prefixed with character Interprete As Command (IAC).</source>
          <target state="translated">デフォルトでは、この関数は指定されたコマンドの最後に新しい行を追加します。これが望ましくない場合は、オプション &lt;code&gt;{newline,false}&lt;/code&gt; 。これは、たとえば、Interprete As Command（IAC）という文字が前に付いたTelnetコマンドシーケンスを送信する場合に必要です。</target>
        </trans-unit>
        <trans-unit id="d49eba4b9253b8356ed12159ecfe231995c2f898" translate="yes" xml:space="preserve">
          <source>By default, this function adds a newline to the end of the specified command. If this is not desired, option &lt;code&gt;{newline,false}&lt;/code&gt; can be used. This is necessary, for example, when sending Telnet command sequences prefixed with character Interprete As Command (IAC).</source>
          <target state="translated">デフォルトでは、この関数は指定されたコマンドの最後に改行を追加します。これが望ましくない場合は、オプション &lt;code&gt;{newline,false}&lt;/code&gt; を使用できます。これは、たとえば、Interprete As Command（IAC）という文字が前に付いたTelnetコマンドシーケンスを送信する場合に必要です。</target>
        </trans-unit>
        <trans-unit id="a9e7714f2d506552215115a4ebf113d003a0acf0" translate="yes" xml:space="preserve">
          <source>By default, this function opens the zip file in &lt;code&gt;raw&lt;/code&gt; mode, which is faster but does not allow a remote (Erlang) file server to be used. Adding &lt;code&gt;cooked&lt;/code&gt; to the mode list overrides the default and opens the zip file without option &lt;code&gt;raw&lt;/code&gt;.</source>
          <target state="translated">デフォルトでは、この関数はzipファイルを &lt;code&gt;raw&lt;/code&gt; モードで開きます。これはより高速ですが、リモート（Erlang）ファイルサーバーを使用できません。モードリストにクックドを追加すると、デフォルトが上書き &lt;code&gt;cooked&lt;/code&gt; れ、オプション &lt;code&gt;raw&lt;/code&gt; なしでzipファイルが開きます。</target>
        </trans-unit>
        <trans-unit id="d14a17c6143d2f118a5dcf4b9f9f2f606d6beef7" translate="yes" xml:space="preserve">
          <source>By default, this function opens the zip file in &lt;code&gt;raw&lt;/code&gt; mode, which is faster but does not allow a remote (Erlang) file server to be used. Adding &lt;code&gt;cooked&lt;/code&gt; to the mode list overrides the default and opens the zip file without option &lt;code&gt;raw&lt;/code&gt;. The same applies for the files extracted.</source>
          <target state="translated">デフォルトでは、この関数はzipファイルを &lt;code&gt;raw&lt;/code&gt; モードで開きます。これはより高速ですが、リモート（Erlang）ファイルサーバーを使用できません。モードリストにクックドを追加すると、デフォルトが上書き &lt;code&gt;cooked&lt;/code&gt; れ、オプション &lt;code&gt;raw&lt;/code&gt; なしでzipファイルが開きます。抽出されたファイルについても同様です。</target>
        </trans-unit>
        <trans-unit id="7a8f2bce9d4e28310f04f71c37d623d77632500e" translate="yes" xml:space="preserve">
          <source>By default, this function opens the zip file in mode &lt;code&gt;raw&lt;/code&gt;, which is faster but does not allow a remote (Erlang) file server to be used. Adding &lt;code&gt;cooked&lt;/code&gt; to the mode list overrides the default and opens the zip file without the &lt;code&gt;raw&lt;/code&gt; option. The same applies for the files added.</source>
          <target state="translated">デフォルトでは、この関数はzipファイルを &lt;code&gt;raw&lt;/code&gt; モードで開きます。これはより高速ですが、リモート（Erlang）ファイルサーバーを使用できません。モードリストに &lt;code&gt;cooked&lt;/code&gt; を追加すると、デフォルトが上書きされ、 &lt;code&gt;raw&lt;/code&gt; オプションなしでzipファイルが開きます。同じことが追加されたファイルにも当てはまります。</target>
        </trans-unit>
        <trans-unit id="679e4d02c8183bf697056897c283fb7c9fe1a240" translate="yes" xml:space="preserve">
          <source>By default, this option is not set. This means that the number is not limited.</source>
          <target state="translated">デフォルトでは、このオプションは設定されていません。つまり、数を制限しないということです。</target>
        </trans-unit>
        <trans-unit id="6486abd515b1ceb341dd61657f6cfe722ef188e0" translate="yes" xml:space="preserve">
          <source>By default, this rule is written to &lt;code&gt;&amp;lt;File&amp;gt;.Pbeam&lt;/code&gt;. However, if option &lt;code&gt;binary&lt;/code&gt; is set, nothing is written and the rule is returned in &lt;code&gt;Binary&lt;/code&gt;.</source>
          <target state="translated">デフォルトでは、このルールは &lt;code&gt;&amp;lt;File&amp;gt;.Pbeam&lt;/code&gt; に書き込まれます。ただし、オプション &lt;code&gt;binary&lt;/code&gt; が設定されている場合、何も書き込まれず、ルールは &lt;code&gt;Binary&lt;/code&gt; で返されます。</target>
        </trans-unit>
        <trans-unit id="3dc5c5c502173feaca81300d649a4642ade965d9" translate="yes" xml:space="preserve">
          <source>By default, this will &lt;strong&gt;not&lt;/strong&gt; be used.</source>
          <target state="translated">デフォルトでは、これは使用され&lt;strong&gt;ませ&lt;/strong&gt;ん。</target>
        </trans-unit>
        <trans-unit id="9e77c5d7a27dc1e5cf909f3bf8e3e3ad53b629c2" translate="yes" xml:space="preserve">
          <source>By default, warnings are emitted for unused variables, except for variables beginning with an underscore (&quot;Prolog style warnings&quot;). Use this option to turn off this kind of warnings.</source>
          <target state="translated">デフォルトでは、アンダースコアで始まる変数(&quot;Prologスタイルの警告&quot;)を除いて、使用されていない変数に対して警告が発せられます。この種の警告をオフにするには、このオプションを使用します。</target>
        </trans-unit>
        <trans-unit id="25048d6dfb90d946e1d4080a2f5aec1215e6a89c" translate="yes" xml:space="preserve">
          <source>By default, warnings are emitted when inlining is enabled in a module that may load NIFs, as the compiler may inline NIF fallbacks by accident. Use this option to turn off this kind of warnings.</source>
          <target state="translated">デフォルトでは、コンパイラが誤って NIF フォールバックをインライン化する可能性があるため、NIF をロードする可能性のあるモジュールでインライン化が有効になっている場合に警告が表示されます。このオプションを使用して、この種の警告をオフにします。</target>
        </trans-unit>
        <trans-unit id="20ba07e398dad932a7a5314c1ee7e53c53da657a" translate="yes" xml:space="preserve">
          <source>By default, when &lt;code&gt;[]&lt;/code&gt; is passed as &lt;code&gt;ModifierList&lt;/code&gt;, both negative and positive integers can be returned. This to use the range of integers that do not need heap memory allocation as much as possible. By default the returned integers are also only guaranteed to be unique, that is, any returned integer can be smaller or larger than previously returned integers.</source>
          <target state="translated">デフォルトでは、 &lt;code&gt;[]&lt;/code&gt; が &lt;code&gt;ModifierList&lt;/code&gt; として渡されると、負の整数と正の整数の両方を返すことができます。これは、ヒープメモリの割り当てをできるだけ必要としない整数の範囲を使用するためです。デフォルトでは、返される整数も一意であることが保証されています。つまり、返される整数は、以前に返された整数よりも小さい場合や大きい場合があります。</target>
        </trans-unit>
        <trans-unit id="11b69da7024ea541c3dc95c3ee7904796b05dd49" translate="yes" xml:space="preserve">
          <source>By definition, it is not possible to send objects with ACCESS &lt;code&gt;not-accessible&lt;/code&gt; in notifications. However, historically this is often done and for this reason we allow it in notification sending. If a variable has ACCESS &lt;code&gt;not-accessible&lt;/code&gt;, the user must provide a value for the variable in the &lt;code&gt;Varbinds&lt;/code&gt; list. It is not possible for the agent to perform a get-operation to retrieve this value.</source>
          <target state="translated">定義上、通知で &lt;code&gt;not-accessible&lt;/code&gt; ACCESSを持つオブジェクトを送信することはできません。ただし、これは歴史的に行われることが多いため、通知の送信で許可されています。変数にACCESS &lt;code&gt;not-accessible&lt;/code&gt; がある場合、ユーザーは &lt;code&gt;Varbinds&lt;/code&gt; リストで変数の値を指定する必要があります。エージェントがget操作を実行してこの値を取得することはできません。</target>
        </trans-unit>
        <trans-unit id="1fe4bf7551fb0bca40b8408258d2d9b38f061a30" translate="yes" xml:space="preserve">
          <source>By deliberately copying a single binary to avoid referencing a larger binary, one can, instead of freeing up the larger binary for later garbage collection, create much more binary data than needed. Sharing binary data is usually good. Only in special cases, when small parts reference large binaries and the large binaries are no longer used in any process, deliberate copying can be a good idea.</source>
          <target state="translated">より大きなバイナリを参照しないように単一のバイナリを意図的にコピーすることで、後のガベージコレクションのために大きなバイナリを解放する代わりに、必要以上に多くのバイナリデータを作成することができます。バイナリデータを共有することは、通常は良いことです。小さな部分が大きなバイナリを参照していて、大きなバイナリがどのプロセスでも使用されなくなった場合など、特別な場合にのみ、意図的にコピーすることは良いアイデアです。</target>
        </trans-unit>
        <trans-unit id="3a1bde088e58ddc2e236cd1237348e4ca2d354a9" translate="yes" xml:space="preserve">
          <source>By executing these commands, two Erlang nodes are configured to run the &lt;code&gt;Company&lt;/code&gt; database, and therefore, initialize the database. This is required only once when setting up. The next time the system is started, &lt;code&gt;&lt;a href=&quot;mnesia#start-0&quot;&gt;mnesia:start()&lt;/a&gt;&lt;/code&gt; is called on both nodes, to initialize the system from disc.</source>
          <target state="translated">これらのコマンドを実行すると、2つのErlangノードが &lt;code&gt;Company&lt;/code&gt; データベースを実行するように構成され、データベースを初期化します。これはセットアップ時に一度だけ必要です。次にシステムが起動したときに、両方のノードで &lt;code&gt;&lt;a href=&quot;mnesia#start-0&quot;&gt;mnesia:start()&lt;/a&gt;&lt;/code&gt; が呼び出され、システムをディスクから初期化します。</target>
        </trans-unit>
        <trans-unit id="d4cbb518f731cd8bac9f82803da816e494e6c084" translate="yes" xml:space="preserve">
          <source>By far the most common situation where this occurs, is when you get lists of UTF-8 instead of proper Unicode strings, and then convert them to UTF-8 in a binary or on a file:</source>
          <target state="translated">これが発生する最も一般的な状況は、適切な Unicode 文字列の代わりに UTF-8 のリストを取得し、それをバイナリまたはファイル上で UTF-8 に変換する場合です。</target>
        </trans-unit>
        <trans-unit id="e536308fb486e25402a1208f98bf1f7153e3c15e" translate="yes" xml:space="preserve">
          <source>By focusing on getting the code to pass the tests, the programmer can become more productive, not overspecify or get lost in premature optimizations, and create code that is correct from the very beginning (so-called &lt;strong&gt;test-driven development&lt;/strong&gt;; see &lt;code&gt;&lt;a href=&quot;#Terminology&quot;&gt;Terminology&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">コードがテストに合格することに集中することで、プログラマーは生産性を高め、仕様​​を過度に指定したり、時期尚早な最適化に没頭したりせず、最初から正しいコードを作成できます（いわゆる&lt;strong&gt;テスト駆動型開発&lt;/strong&gt;。 &lt;code&gt;&lt;a href=&quot;#Terminology&quot;&gt;Terminology&lt;/a&gt;&lt;/code&gt; 参照）。</target>
        </trans-unit>
        <trans-unit id="1be6092d2f04d5672bbcc552b76ea03252377f9a" translate="yes" xml:space="preserve">
          <source>By giving the format handler &lt;code&gt;&lt;a href=&quot;ttb#get_et_handler-0&quot;&gt;ttb:get_et_handler()&lt;/a&gt;&lt;/code&gt;, you can have the trace log presented graphically with &lt;code&gt;et_viewer&lt;/code&gt; in the ET application (see section &lt;code&gt;&lt;a href=&quot;#et_viewer&quot;&gt;Presenting Trace Logs with Event Tracer&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">フォーマットハンドラー &lt;code&gt;&lt;a href=&quot;ttb#get_et_handler-0&quot;&gt;ttb:get_et_handler()&lt;/a&gt;&lt;/code&gt; を &lt;code&gt;et_viewer&lt;/code&gt; すると、ETアプリケーションのet_viewerでトレースログをグラフィカルに表示できます（「 &lt;code&gt;&lt;a href=&quot;#et_viewer&quot;&gt;Presenting Trace Logs with Event Tracer&lt;/a&gt;&lt;/code&gt; 表示」セクションを参照）。</target>
        </trans-unit>
        <trans-unit id="4d1f348639ff071f4f3a637874209a8d2a2be427" translate="yes" xml:space="preserve">
          <source>By giving the format handler &lt;code&gt;&lt;a href=&quot;ttb#get_et_handler-0&quot;&gt;ttb:get_et_handler()&lt;/a&gt;&lt;/code&gt;, you can have the trace log presented graphically with &lt;code&gt;et_viewer&lt;/code&gt; in the ET application. &lt;code&gt;ttb&lt;/code&gt; provides filters that can be selected from the menu &lt;strong&gt;Filter&lt;/strong&gt; in the &lt;code&gt;et_viewer&lt;/code&gt; window. The filters are names according to the type of actors they present (that is, what each vertical line in the sequence diagram represents). Interaction between actors is shown as red arrows between two vertical lines, and activities within an actor are shown as blue text to the right of the actors line.</source>
          <target state="translated">書式ハンドラ &lt;code&gt;&lt;a href=&quot;ttb#get_et_handler-0&quot;&gt;ttb:get_et_handler()&lt;/a&gt;&lt;/code&gt; を指定することにより、ETアプリケーションで &lt;code&gt;et_viewer&lt;/code&gt; を使用してトレースログをグラフィカルに表示できます。 &lt;code&gt;ttb&lt;/code&gt; は、 &lt;code&gt;et_viewer&lt;/code&gt; ウィンドウのメニュー&lt;strong&gt;フィルター&lt;/strong&gt;から選択できるフィルターを提供します。フィルターは、それらが存在するアクターのタイプ（つまり、シーケンス図の各縦線が表すもの）に応じた名前です。アクター間の相互作用は、2本の垂直線の間の赤い矢印として示され、アクター内のアクティビティは、アクター線の右側に青いテキストとして示されます。</target>
        </trans-unit>
        <trans-unit id="67f7db44464541266f3f0704ea1cb52a5cffad39" translate="yes" xml:space="preserve">
          <source>By going different directions when inserting and fetching, we avoid contention between threads inserting and threads fetching as much as possible. By skipping one element when we begin searching, we preserve the sentinel unmodified as much as possible. This is beneficial since all search operations need to read the content of the sentinel. If we were to modify the sentinel, the cache line containing the sentinel would unnecessarily be bounced between processors.</source>
          <target state="translated">挿入と取得の方向を変えることで、挿入するスレッドと取得するスレッドの競合を可能な限り回避します。検索を開始するときに1つの要素をスキップすることで、可能な限り変更されていないセンチネルを保存します。これは、すべての検索操作がセンチネルの内容を読み込む必要があるため、有益です。もしセンチネルを変更してしまうと、センチネルを含むキャッシュラインがプロセッサ間で不必要にバウンドしてしまいます。</target>
        </trans-unit>
        <trans-unit id="8645150b63184ee0f8a1f1a7796ff9caeac2c2be" translate="yes" xml:space="preserve">
          <source>By increasing the size of identifiers, at least on 64-bit machines (which isn't as easy as it first might seem) we get further room for improvement. Besides the obvious improvement of not reusing identifiers as fast as we currently do, it makes it possible to further avoid contention when inserting elements in the table. At least if we drop this ordering property, which isn't that useful anyway.</source>
          <target state="translated">識別子のサイズを大きくすることで、少なくとも 64 ビットマシンでは (最初はそう簡単にはいかないかもしれませんが)更なる改善の余地が生まれます。現在のように識別子を高速に再利用しなくて済むという明らかな改善に加えて、テーブルに要素を挿入する際の競合をさらに回避することが可能になります。少なくとも、この順序付けのプロパティを削除すれば、それはそれほど有用なものではありません。</target>
        </trans-unit>
        <trans-unit id="1c38dcce4fbbcbaa49db2c494d622ac31a93af9e" translate="yes" xml:space="preserve">
          <source>By inspecting the headers or writing a small C program, it is found that &lt;code&gt;IPPROTO_TCP&lt;/code&gt; is 6, &lt;code&gt;TCP_INFO&lt;/code&gt; is 11, the structure size is 92 (bytes), the offset of &lt;code&gt;tcpi_sacked&lt;/code&gt; is 28 bytes, and the value is a 32-bit integer. The following code can be used to retrieve the value:</source>
          <target state="translated">ヘッダーを検査するか、小さなCプログラムを作成すると、 &lt;code&gt;IPPROTO_TCP&lt;/code&gt; が6、 &lt;code&gt;TCP_INFO&lt;/code&gt; が11、構造体サイズが92（バイト）、 &lt;code&gt;tcpi_sacked&lt;/code&gt; のオフセットが28バイト、値が32ビット整数であることがわかります。次のコードを使用して値を取得できます。</target>
        </trans-unit>
        <trans-unit id="018fc7c90872dc5bcc3ecc8ce71bc58db7e38b60" translate="yes" xml:space="preserve">
          <source>By inspecting the implementation, you might notice that some specific signal gives a stricter guarantee than described above. It is of vital importance that such knowledge about the implementation is &lt;strong&gt;not&lt;/strong&gt; used by Erlang code, as the implementation can change at any time without prior notice.</source>
          <target state="translated">実装を調べると、特定の信号が上記よりも厳密な保証を与えることに気付く場合があります。実装は事前の予告なしにいつでも変更される可能性がある&lt;strong&gt;ため&lt;/strong&gt;、実装に関するそのような知識がErlangコードによって使用され&lt;strong&gt;ない&lt;/strong&gt;ことが非常に重要です。</target>
        </trans-unit>
        <trans-unit id="0d5d59f9d063b86f9130d5f5210753452085dc85" translate="yes" xml:space="preserve">
          <source>By introduction of this new busy state we still can provide the flow control. Old driver do not even have to be changed. The limits can, however, be configured and even disabled by the port. By default the high limit is 8 KB and the low limit is 4 KB.</source>
          <target state="translated">この新しいビジー状態を導入することで、今まで通りのフロー制御が可能になります。古いドライバも変更する必要はありません。しかし、制限はポートによって設定したり、無効にしたりすることができます。デフォルトでは、上限は8KB、下限は4KBとなっています。</target>
        </trans-unit>
        <trans-unit id="27a61522ba19814181bc4db8e5c44cbf812700d2" translate="yes" xml:space="preserve">
          <source>By keeping this part when reverting back to a locked implementation, we could remove a pointer field in each process structure, and avoid unnecessary operations on the process and the queue which might cause contention.</source>
          <target state="translated">ロックされた実装に戻す際にこの部分を保持することで、各プロセス構造体のポインタフィールドを削除することができ、競合を引き起こす可能性のあるプロセスやキューに対する不必要な操作を避けることができます。</target>
        </trans-unit>
        <trans-unit id="e8b879e7731e558078b8cea840f1fb4c1f690b4a" translate="yes" xml:space="preserve">
          <source>By looking at the results from the analyses, it can be deducted that the test case does not cover the case when all channels are allocated and &lt;code&gt;test.erl&lt;/code&gt; should be extended accordingly.</source>
          <target state="translated">分析の結果を見ると、すべてのチャネルが割り当てられ、それに応じて &lt;code&gt;test.erl&lt;/code&gt; を拡張する必要がある場合、テストケースがケースをカバーしていないことが推測できます。</target>
        </trans-unit>
        <trans-unit id="0adc0a428da4933a5c912fbd894ed220b7168db5" translate="yes" xml:space="preserve">
          <source>By parsing an XML document you will get a record, displaying the structure of the document, as return value. The record also holds the data of the document. xmerl is convenient to use in for instance the following scenarios:</source>
          <target state="translated">XMLドキュメントを解析すると、ドキュメントの構造を表示するレコードが返り値として得られます。レコードにはドキュメントのデータも含まれています。</target>
        </trans-unit>
        <trans-unit id="805a7a9a8ddfb1ba7400cf31f92187edc3ff9a77" translate="yes" xml:space="preserve">
          <source>By passing a pointer to an integer variable containing the value &lt;code&gt;ERL_DRV_BUSY_MSGQ_READ_ONLY&lt;/code&gt;, the currently used limit is read and written back to the integer variable. A new limit can be set by passing a pointer to an integer variable containing a valid limit. The passed value is written to the internal limit. The internal limit is then adjusted. After this the adjusted limit is written back to the integer variable from which the new value was read. Values are in bytes.</source>
          <target state="translated">値 &lt;code&gt;ERL_DRV_BUSY_MSGQ_READ_ONLY&lt;/code&gt; を含む整数変数へのポインターを渡すことにより、現在使用されている制限が読み取られ、整数変数に書き戻されます。有効な制限を含む整数変数へのポインタを渡すことにより、新しい制限を設定できます。渡された値は内部制限に書き込まれます。その後、内部制限が調整されます。この後、調整された制限は、新しい値が読み取られた整数変数に書き戻されます。値はバイト単位です。</target>
        </trans-unit>
        <trans-unit id="5fab0b335aad4687a0efd2b2918fb0d4d20a2d30" translate="yes" xml:space="preserve">
          <source>By passing the same &quot;fun&quot; as an argument to the function &lt;code&gt;&lt;a href=&quot;mnesia#sync_dirty-1&quot;&gt;mnesia:sync_dirty(Fun [, Args])&lt;/a&gt;&lt;/code&gt;, it is performed in almost the same context as the function &lt;code&gt;&lt;a href=&quot;mnesia#async_dirty-1&quot;&gt;mnesia:async_dirty/1,2&lt;/a&gt;&lt;/code&gt;. The difference is that the operations are performed synchronously. The caller waits for the updates to be performed on all active replicas. Using &lt;code&gt;mnesia:sync_dirty/1,2&lt;/code&gt; is useful in the following cases:</source>
          <target state="translated">関数 &lt;code&gt;&lt;a href=&quot;mnesia#sync_dirty-1&quot;&gt;mnesia:sync_dirty(Fun [, Args])&lt;/a&gt;&lt;/code&gt; に引数として同じ「fun」を渡すことにより、関数 &lt;code&gt;&lt;a href=&quot;mnesia#async_dirty-1&quot;&gt;mnesia:async_dirty/1,2&lt;/a&gt;&lt;/code&gt; とほぼ同じコンテキストで実行されます。違いは、操作が同期的に実行されることです。呼び出し元は、アクティブなすべてのレプリカで更新が実行されるのを待ちます。使用 &lt;code&gt;mnesia:sync_dirty/1,2&lt;/code&gt; は、次のような場合に便利です。</target>
        </trans-unit>
        <trans-unit id="75da6c1f2ebad0633762bf86ba622c3a4f5ba6cd" translate="yes" xml:space="preserve">
          <source>By passing the same &quot;fun&quot; as an argument to the function &lt;code&gt;&lt;a href=&quot;mnesia#sync_dirty-2&quot;&gt;mnesia:sync_dirty(Fun [, Args])&lt;/a&gt;&lt;/code&gt;, it is performed in almost the same context as the function &lt;code&gt;&lt;a href=&quot;mnesia#async_dirty-2&quot;&gt;mnesia:async_dirty/1,2&lt;/a&gt;&lt;/code&gt;. The difference is that the operations are performed synchronously. The caller waits for the updates to be performed on all active replicas. Using &lt;code&gt;mnesia:sync_dirty/1,2&lt;/code&gt; is useful in the following cases:</source>
          <target state="translated">関数 &lt;code&gt;&lt;a href=&quot;mnesia#sync_dirty-2&quot;&gt;mnesia:sync_dirty(Fun [, Args])&lt;/a&gt;&lt;/code&gt; に引数として同じ &quot;fun&quot;を渡すことにより、関数 &lt;code&gt;&lt;a href=&quot;mnesia#async_dirty-2&quot;&gt;mnesia:async_dirty/1,2&lt;/a&gt;&lt;/code&gt; とほぼ同じコンテキストで実行されます。違いは、操作が同期して実行されることです。呼び出し元は、すべてのアクティブなレプリカで更新が実行されるのを待ちます。使用 &lt;code&gt;mnesia:sync_dirty/1,2&lt;/code&gt; は、次のような場合に便利です。</target>
        </trans-unit>
        <trans-unit id="07cd49a0634099807d33616dd0caa93e4fb6d9a9" translate="yes" xml:space="preserve">
          <source>By passing the same &quot;fun&quot; as argument to the function &lt;code&gt;&lt;a href=&quot;mnesia#async_dirty-1&quot;&gt;mnesia:async_dirty(Fun [, Args])&lt;/a&gt;&lt;/code&gt;, it is performed in dirty context. The function calls are mapped to the corresponding dirty functions. This still involves logging, replication, and subscriptions but no locking, local transaction storage, or commit protocols are involved. Checkpoint retainers are updated but updated &quot;dirty&quot;. Thus, they are updated asynchronously. The functions wait for the operation to be performed on one node but not the others. If the table resides locally, no waiting occurs.</source>
          <target state="translated">関数 &lt;code&gt;&lt;a href=&quot;mnesia#async_dirty-1&quot;&gt;mnesia:async_dirty(Fun [, Args])&lt;/a&gt;&lt;/code&gt; に引数と同じ「fun」を渡すことにより、ダーティコンテキストで実行されます。関数呼び出しは、対応するダーティ関数にマップされます。これには、ロギング、レプリケーション、およびサブスクリプションが含まれますが、ロック、ローカルトランザクションストレージ、またはコミットプロトコルは含まれません。チェックポイントリテーナは更新されますが、「ダーティ」に更新されます。したがって、それらは非同期的に更新されます。関数は、操作が1つのノードで実行されるのを待ちますが、他のノードでは実行されません。テーブルがローカルに存在する場合、待機は発生しません。</target>
        </trans-unit>
        <trans-unit id="808cd51c3638fb04adece47349170a09569ccf1c" translate="yes" xml:space="preserve">
          <source>By passing the same &quot;fun&quot; as argument to the function &lt;code&gt;&lt;a href=&quot;mnesia#async_dirty-2&quot;&gt;mnesia:async_dirty(Fun [, Args])&lt;/a&gt;&lt;/code&gt;, it is performed in dirty context. The function calls are mapped to the corresponding dirty functions. This still involves logging, replication, and subscriptions but no locking, local transaction storage, or commit protocols are involved. Checkpoint retainers are updated but updated &quot;dirty&quot;. Thus, they are updated asynchronously. The functions wait for the operation to be performed on one node but not the others. If the table resides locally, no waiting occurs.</source>
          <target state="translated">関数 &lt;code&gt;&lt;a href=&quot;mnesia#async_dirty-2&quot;&gt;mnesia:async_dirty(Fun [, Args])&lt;/a&gt;&lt;/code&gt; 引数として同じ &quot;fun&quot;を渡すことにより、ダーティコンテキストで実行されます。関数呼び出しは、対応するダーティー関数にマップされます。これには、ロギング、レプリケーション、サブスクリプションが含まれますが、ロック、ローカルトランザクションストレージ、またはコミットプロトコルは含まれません。チェックポイント保持機能は更新されていますが、「ダーティ」が更新されています。したがって、それらは非同期に更新されます。関数は、あるノードで操作が実行されるのを待機しますが、他のノードでは実行されません。テーブルがローカルにある場合、待機は発生しません。</target>
        </trans-unit>
        <trans-unit id="e0b3ed9cf7bda275ce89d365e3ae0df2fa60e975" translate="yes" xml:space="preserve">
          <source>By passing the same &quot;fun&quot; as argument to the function &lt;code&gt;&lt;a href=&quot;mnesia#sync_transaction-1&quot;&gt;mnesia:sync_transaction(Fun [, Args])&lt;/a&gt;&lt;/code&gt; it is performed in synced transaction context. Synced transactions wait until all active replicas has committed the transaction (to disc) before returning from the &lt;code&gt;mnesia:sync_transaction&lt;/code&gt; call. Using &lt;code&gt;sync_transaction&lt;/code&gt; is useful in the following cases:</source>
          <target state="translated">関数 &lt;code&gt;&lt;a href=&quot;mnesia#sync_transaction-1&quot;&gt;mnesia:sync_transaction(Fun [, Args])&lt;/a&gt;&lt;/code&gt; に引数と同じ「fun」を渡すことにより、同期されたトランザクションコンテキストで実行されます。同期されたトランザクションは、すべてのアクティブなレプリカがトランザクションを（ディスクに）コミットするまで待機してから、 &lt;code&gt;mnesia:sync_transaction&lt;/code&gt; 呼び出しから戻ります。 &lt;code&gt;sync_transaction&lt;/code&gt; の使用は、次の場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="5fe18782111712f87288c23d1c8fb50a83e580df" translate="yes" xml:space="preserve">
          <source>By passing the same &quot;fun&quot; as argument to the function &lt;code&gt;&lt;a href=&quot;mnesia#sync_transaction-3&quot;&gt;mnesia:sync_transaction(Fun [, Args])&lt;/a&gt;&lt;/code&gt; it is performed in synced transaction context. Synced transactions wait until all active replicas has committed the transaction (to disc) before returning from the &lt;code&gt;mnesia:sync_transaction&lt;/code&gt; call. Using &lt;code&gt;sync_transaction&lt;/code&gt; is useful in the following cases:</source>
          <target state="translated">関数 &lt;code&gt;&lt;a href=&quot;mnesia#sync_transaction-3&quot;&gt;mnesia:sync_transaction(Fun [, Args])&lt;/a&gt;&lt;/code&gt; に引数として同じ &quot;fun&quot;を渡すことにより、同期されたトランザクションコンテキストで実行されます。同期トランザクションは、 &lt;code&gt;mnesia:sync_transaction&lt;/code&gt; 呼び出しから戻る前に、すべてのアクティブなレプリカがトランザクションを（ディスクに）コミットするまで待機します。 &lt;code&gt;sync_transaction&lt;/code&gt; の使用は、次の場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="8d8e68091d4403f0e83bd114c70649e6a566d00b" translate="yes" xml:space="preserve">
          <source>By preference, these functions can be included in module &lt;code&gt;shell_default&lt;/code&gt;. By default, they are included in that module.</source>
          <target state="translated">好みにより、これらの関数は &lt;code&gt;shell_default&lt;/code&gt; モジュールに含めることができます。デフォルトでは、それらはそのモジュールに含まれています。</target>
        </trans-unit>
        <trans-unit id="7f254d4f66995179ccfd6ad20889ce3083eb5612" translate="yes" xml:space="preserve">
          <source>By setting &lt;code&gt;SourceMod&lt;/code&gt; and &lt;code&gt;TargetMod&lt;/code&gt; to different modules, a backup can be copied from one backup media to another.</source>
          <target state="translated">&lt;code&gt;SourceMod&lt;/code&gt; と &lt;code&gt;TargetMod&lt;/code&gt; を異なるモジュールに設定することで、バックアップを1つのバックアップメディアから別のバックアップメディアにコピーできます。</target>
        </trans-unit>
        <trans-unit id="d49dba3e2b5c5cceb098125c642fa912b7e82445" translate="yes" xml:space="preserve">
          <source>By testing in a bottom-up fashion, beginning with the smallest program units and creating a confidence in that they work as they should, it becomes easier to test that a higher-level component, consisting of several such units, also behaves according to specification (known as &lt;strong&gt;integration testing&lt;/strong&gt;; see &lt;code&gt;&lt;a href=&quot;#Terminology&quot;&gt;Terminology&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">ボトムアップ方式でテストし、最小のプログラムユニットから始めて、それらが正常に機能するという信頼を作成することにより、複数のそのようなユニットで構成される上位レベルのコンポーネントも仕様に従って動作することをテストしやすくなります。 （&lt;strong&gt;統合テスト&lt;/strong&gt;として知られてい&lt;strong&gt;ます&lt;/strong&gt;。 &lt;code&gt;&lt;a href=&quot;#Terminology&quot;&gt;Terminology&lt;/a&gt;&lt;/code&gt; 参照してください）。</target>
        </trans-unit>
        <trans-unit id="ff05bbe6b9df494deffc0d26f620950719c544d4" translate="yes" xml:space="preserve">
          <source>By this means, options can be made to have different settings in different parts of the pattern. Any changes made in one alternative do carry on into subsequent branches within the same subpattern. For example:</source>
          <target state="translated">これにより、選択肢はパターンの異なる部分で異なる設定を持つようにすることができます。1つの代替案で行われた変更は、同じサブパターン内の後続のブランチにも引き継がれます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="35ec349917181f956c0a4c9c0f4a81caa7003c00" translate="yes" xml:space="preserve">
          <source>By using &lt;code&gt;&lt;a href=&quot;debugger#start-1&quot;&gt;debugger:start/1&lt;/a&gt;&lt;/code&gt;, you can specify if Debugger is to be started in local or global mode:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;debugger#start-1&quot;&gt;debugger:start/1&lt;/a&gt;&lt;/code&gt; を使用して、デバッガーをローカルモードで開始するか、グローバルモードで開始するかを指定できます。</target>
        </trans-unit>
        <trans-unit id="99adfb49899ce85d907d066e2103689e06c7ae25" translate="yes" xml:space="preserve">
          <source>By using one data structure of free blocks in each carrier and an allocator instance-wide data structure of carriers managed by the allocator instance, the work needed in order to remove and add carriers can be kept to a minimum. When migration of carriers is enabled on a specific allocator type, we require that an allocation strategy with such an implementation is used. Currently we've implemented this for three different allocation strategies. All of these strategies use a search tree of carriers sorted so that we can find the carrier with the lowest address that can satisfy the request. Internally in carriers we use yet another search tree that either implement address order first fit, address order best fit, or best fit. The abbreviations used for these different allocation strategies are &lt;code&gt;aoff&lt;/code&gt;, and &lt;code&gt;aoffcaobf&lt;/code&gt;, &lt;code&gt;aoffcbf&lt;/code&gt;.</source>
          <target state="translated">各キャリアの空きブロックの1つのデータ構造と、アロケータインスタンスによって管理されるキャリアのアロケータインスタンス全体のデータ構造を使用することにより、キャリアの削除と追加に必要な作業を最小限に抑えることができます。特定のアロケータタイプでキャリアの移行が有効になっている場合は、そのような実装の割り当て戦略を使用する必要があります。現在、これを3つの異なる割り当て戦略に実装しています。これらの戦略はすべて、要求を満たすことができる最小のアドレスを持つキャリアを見つけることができるようにソートされたキャリアの検索ツリーを使用します。キャリアの内部では、住所順ファーストフィット、住所順ベストフィット、またはベストフィットのいずれかを実装するさらに別の検索ツリーを使用しています。これらのさまざまな割り当て戦略に使用される略語は &lt;code&gt;aoff&lt;/code&gt; であり、 &lt;code&gt;aoffcaobf&lt;/code&gt; 、 &lt;code&gt;aoffcbf&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6da8978f9ea68a7c6f48f6d3c9e527498ef08964" translate="yes" xml:space="preserve">
          <source>By using option &lt;code&gt;handler&lt;/code&gt; when starting the tracer, the information about how to format the file is stored in the trace information file (&lt;code&gt;.ti&lt;/code&gt;). This is not necessary, as it can be specified when formatting instead. However, It can be useful if you, for example, want to format trace logs automatically using option &lt;code&gt;format&lt;/code&gt; in &lt;code&gt;ttb:stop/1&lt;/code&gt;. Also, you do not need any knowledge of the content of a binary log to format it the way it is intended. If option &lt;code&gt;handler&lt;/code&gt; is specified both when starting the tracer and when formatting, the one specified when formatting is used.</source>
          <target state="translated">トレーサの &lt;code&gt;handler&lt;/code&gt; 時にオプションハンドラを使用することにより、ファイルのフォーマット方法に関する情報がトレース情報ファイル（ &lt;code&gt;.ti&lt;/code&gt; ）に格納されます。代わりにフォーマット時に指定できるため、これは必要ありません。ただし、たとえば、 &lt;code&gt;ttb:stop/1&lt;/code&gt; のオプション &lt;code&gt;format&lt;/code&gt; を使用してトレースログを自動的にフォーマットする場合に役立ちます。また、バイナリログを意図したとおりにフォーマットするために、バイナリログの内容に関する知識は必要ありません。トレーサの起動時とフォーマット時の両方にオプション &lt;code&gt;handler&lt;/code&gt; を指定した場合は、フォーマット時に指定したハンドラが使用されます。</target>
        </trans-unit>
        <trans-unit id="02d1325592a3ef565e5e7f405f91fc17bcd0d42f" translate="yes" xml:space="preserve">
          <source>By using ordinary UNIX tools like &lt;code&gt;sed&lt;/code&gt; and &lt;code&gt;grep&lt;/code&gt; one can easily find answers to various questions like:</source>
          <target state="translated">&lt;code&gt;sed&lt;/code&gt; や &lt;code&gt;grep&lt;/code&gt; などの通常のUNIXツールを使用すると、次のようなさまざまな質問に対する答えを簡単に見つけることができます。</target>
        </trans-unit>
        <trans-unit id="a2d275dd09349865f8c3284b6c4fd5293841ad62" translate="yes" xml:space="preserve">
          <source>By using the new API, you automatically get scalability and performance improvements. This also enables you to use the &lt;code&gt;&lt;a href=&quot;#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; that improves accuracy and precision of time measurements.</source>
          <target state="translated">新しいAPIを使用すると、スケーラビリティとパフォーマンスが自動的に向上します。これにより、時間測定の精度と精度を向上させる &lt;code&gt;&lt;a href=&quot;#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; を使用することもできます。</target>
        </trans-unit>
        <trans-unit id="77c257b7be9bfb86770597be303f8b67e4aa586a" translate="yes" xml:space="preserve">
          <source>By wrapping the API with functions that fall back on &lt;code&gt;erlang:now/0&lt;/code&gt; when the new API is unavailable, and using these wrappers instead of using the API directly, the problem is solved. These wrappers can, for example, be implemented as in &lt;code&gt;$ERL_TOP/erts/example/time_compat.erl&lt;/code&gt;.</source>
          <target state="translated">新しいAPIが利用できないときに &lt;code&gt;erlang:now/0&lt;/code&gt; にフォールバックする関数でAPIをラップし、APIを直接使用する代わりにこれらのラッパーを使用することにより、問題は解決されます。これらのラッパーは、たとえば、 &lt;code&gt;$ERL_TOP/erts/example/time_compat.erl&lt;/code&gt; ように実装できます。</target>
        </trans-unit>
        <trans-unit id="00bf079d821f3a0145d168bfcf76ce42b727b9c4" translate="yes" xml:space="preserve">
          <source>Bypass all messages to the receiving process.</source>
          <target state="translated">受信処理へのメッセージをすべてバイパスします。</target>
        </trans-unit>
        <trans-unit id="0cfa66375624ff2bee2fec17b2715898b2615b30" translate="yes" xml:space="preserve">
          <source>Bypass the native code compilation of some key files that Dialyzer heuristically performs when dialyzing many files. This avoids the compilation time, but can result in (much) longer analysis time.</source>
          <target state="translated">多くのファイルをダイアライザーでダイアライズする際に、ダイアライザーがヒューリスティックに実行するいくつかのキーファイルのネイティブコードのコンパイルをバイパスします。これにより、コンパイル時間は回避されますが、解析時間が(はるかに)長くなる可能性があります。</target>
        </trans-unit>
        <trans-unit id="ed612f8fe61f0988ef76386aa7006b8a480853b5" translate="yes" xml:space="preserve">
          <source>Byte Order Marks</source>
          <target state="translated">バイトオーダーマーク</target>
        </trans-unit>
        <trans-unit id="eed4df1a2c0521e891f717551aca2cc2df95a04a" translate="yes" xml:space="preserve">
          <source>Bytes that are out of the range 0x2A, 0x2D, 0x2E, 0x30 to 0x39, 0x41 to 0x5A, 0x5F, 0x61 to 0x7A, are percent-encoded (U+0025 PERCENT SIGN character (%) followed by uppercase ASCII hex digits representing the hexadecimal value of the byte).</source>
          <target state="translated">0x2A、0x2D、0x2E、0x30~0x39、0x41~0x5A、0x5F、0x61~0x7Aの範囲外のバイトはパーセンテージ・エンコードされています(U+0025 PERCENT SIGN文字(%)の後にバイトの16進数を表す大文字のASCII 16進数が続きます)。</target>
        </trans-unit>
        <trans-unit id="0ca15868aa5caba5cda8401a4c79d41061a3d6a4" translate="yes" xml:space="preserve">
          <source>Bytes written to the file by any means are translated to UTF-8 encoding before being stored on the disk file.</source>
          <target state="translated">何らかの手段でファイルに書き込まれたバイトは、ディスクファイルに格納される前にUTF-8エンコーディングに変換されます。</target>
        </trans-unit>
        <trans-unit id="32096c2e0eff33d844ee6d675407ace18289357d" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>
        </trans-unit>
        <trans-unit id="b723b73b1800e21096c057fb6a01f5938c1a20f5" translate="yes" xml:space="preserve">
          <source>C Library</source>
          <target state="translated">C ライブラリ</target>
        </trans-unit>
        <trans-unit id="ccf32b3ba375bfb965d1f8f4ebf787e42c9dc1ea" translate="yes" xml:space="preserve">
          <source>C Nodes</source>
          <target state="translated">Cノード</target>
        </trans-unit>
        <trans-unit id="e48d8a1314ac59090c047f1cace030d6174ffe04" translate="yes" xml:space="preserve">
          <source>C nodes can also register themselves with &lt;code&gt;epmd&lt;/code&gt; if they want other nodes in the system to be able to find and connect to them.</source>
          <target state="translated">Cノードは、システム内の他のノードがそれらを見つけて接続できるようにしたい場合は、それら自体を &lt;code&gt;epmd&lt;/code&gt; に登録することもできます。</target>
        </trans-unit>
        <trans-unit id="7aaca542e8937ae72090fdd955fe659422678461" translate="yes" xml:space="preserve">
          <source>C-Left</source>
          <target state="translated">C-Left</target>
        </trans-unit>
        <trans-unit id="e2bb854461c349ecc3ae2bfb00ac6727ba113ad8" translate="yes" xml:space="preserve">
          <source>C-Right</source>
          <target state="translated">C-Right</target>
        </trans-unit>
        <trans-unit id="015b01935f205cea280aafb1b1c1757c49bc1bf4" translate="yes" xml:space="preserve">
          <source>C-]</source>
          <target state="translated">C-]</target>
        </trans-unit>
        <trans-unit id="3bff8fb1aa290267671b1c50e3b32db24f00b295" translate="yes" xml:space="preserve">
          <source>C-a</source>
          <target state="translated">C-a</target>
        </trans-unit>
        <trans-unit id="c204a76fc3c1123c96b13dd7ec922d02d4b00e91" translate="yes" xml:space="preserve">
          <source>C-b</source>
          <target state="translated">C-b</target>
        </trans-unit>
        <trans-unit id="1d8e75405de8be939b05db3eef9ab4daa516674d" translate="yes" xml:space="preserve">
          <source>C-d</source>
          <target state="translated">C-d</target>
        </trans-unit>
        <trans-unit id="a7ef1e89e28b60bd53a0a5ab746fbcd131fdf224" translate="yes" xml:space="preserve">
          <source>C-e</source>
          <target state="translated">C-e</target>
        </trans-unit>
        <trans-unit id="dd71d43937255c2ba419c077fa824865f8267186" translate="yes" xml:space="preserve">
          <source>C-f</source>
          <target state="translated">C-f</target>
        </trans-unit>
        <trans-unit id="a6d13ed5d2d00101157246b7ae1e91a19d7d7406" translate="yes" xml:space="preserve">
          <source>C-g</source>
          <target state="translated">C-g</target>
        </trans-unit>
        <trans-unit id="d5eeac2f32301e2b964f421e02a44c5afa000881" translate="yes" xml:space="preserve">
          <source>C-k</source>
          <target state="translated">C-k</target>
        </trans-unit>
        <trans-unit id="2fef5b5a274737535a312ecc5d6b8de717c1cb77" translate="yes" xml:space="preserve">
          <source>C-l</source>
          <target state="translated">C-l</target>
        </trans-unit>
        <trans-unit id="aa3408adf600065cf33c17971e8cdd9f76e5d785" translate="yes" xml:space="preserve">
          <source>C-n</source>
          <target state="translated">C-n</target>
        </trans-unit>
        <trans-unit id="332268c029d8126391ff9151361238bdf44870d8" translate="yes" xml:space="preserve">
          <source>C-p</source>
          <target state="translated">C-p</target>
        </trans-unit>
        <trans-unit id="68b4cf03a08cd7bf7acc0d39d68cca6ef0f409f3" translate="yes" xml:space="preserve">
          <source>C-t</source>
          <target state="translated">C-t</target>
        </trans-unit>
        <trans-unit id="ac7de9aff7d0daffb3ae53140a783f411f89c587" translate="yes" xml:space="preserve">
          <source>C-u</source>
          <target state="translated">C-u</target>
        </trans-unit>
        <trans-unit id="8e0be97e2cc76979d93e15014888863a6e79a7af" translate="yes" xml:space="preserve">
          <source>C-w</source>
          <target state="translated">C-w</target>
        </trans-unit>
        <trans-unit id="f286461016d3e4db77e8a575a1f55b2d71886961" translate="yes" xml:space="preserve">
          <source>C-y</source>
          <target state="translated">C-y</target>
        </trans-unit>
        <trans-unit id="8bcd80750450915a11400a818b9b66c894b79ce2" translate="yes" xml:space="preserve">
          <source>C. J. Cheney. A nonrecursive list compacting algorithm. Commun. ACM, 13(11):677&amp;ndash;678, Nov. 1970.</source>
          <target state="translated">CJチェイニー。非再帰的なリスト圧縮アルゴリズム。コミュン。ACM、13（11）：677&amp;ndash;678、1970年11月。</target>
        </trans-unit>
        <trans-unit id="27ae2e5d9b51df18972eb310bdefaba625476830" translate="yes" xml:space="preserve">
          <source>CEA is sent and received by diameter.</source>
          <target state="translated">CEAは直径で送受信します。</target>
        </trans-unit>
        <trans-unit id="ff534b0e9ae18ae782f79e9fe262a000f3c6ff49" translate="yes" xml:space="preserve">
          <source>CER is sent and received by diameter.</source>
          <target state="translated">CERは直径で送受信されます。</target>
        </trans-unit>
        <trans-unit id="dc47309cd47139b3a06fa2c74bdb7d228d8051f1" translate="yes" xml:space="preserve">
          <source>CGI Version 1.1, RFC 3875</source>
          <target state="translated">CGI バージョン 1.1、RFC 3875</target>
        </trans-unit>
        <trans-unit id="112d72d949c9bbe40789456cde8492d907b63e28" translate="yes" xml:space="preserve">
          <source>CHARACTER (size), CHAR (size)</source>
          <target state="translated">CHARACTER (サイズ)、CHAR (サイズ)</target>
        </trans-unit>
        <trans-unit id="24ecce9e5657a884a70aea047867075f09d39ad6" translate="yes" xml:space="preserve">
          <source>CHARACTER VARYING(size), CHAR VARYING(size)</source>
          <target state="translated">CHARACTER VARYING(size)、CHAR VARYING(size)</target>
        </trans-unit>
        <trans-unit id="c58d76589eba57b4dea4b621e7f3e9e5e0856e8f" translate="yes" xml:space="preserve">
          <source>CMAC</source>
          <target state="translated">CMAC</target>
        </trans-unit>
        <trans-unit id="af34028d9d3b30dd0a7cd2e8ede32a3c41ceeef2" translate="yes" xml:space="preserve">
          <source>CMAC with the following ciphers are available with OpenSSL 1.0.1 or later if not disabled by configuration.</source>
          <target state="translated">OpenSSL 1.0.1以降では、設定で無効化されていない場合、以下の暗号を使用したCMACが利用可能です。</target>
        </trans-unit>
        <trans-unit id="4a4f0e1b5b9cde6b772cb89e0e6bdb0a6ab6de56" translate="yes" xml:space="preserve">
          <source>CR, LF, or CRLF only</source>
          <target state="translated">CR、LF、CRLFのみ</target>
        </trans-unit>
        <trans-unit id="d5ab3cb5603f8a4df9b9b5741bc8bf57061a02e7" translate="yes" xml:space="preserve">
          <source>CRL cache</source>
          <target state="translated">シーアールエルキャッシュ</target>
        </trans-unit>
        <trans-unit id="8e2fa37cd7a6f667709e92e12f402a4fd5543726" translate="yes" xml:space="preserve">
          <source>CRL validation is supported.</source>
          <target state="translated">CRLの検証がサポートされています。</target>
        </trans-unit>
        <trans-unit id="022add99e35c24f3ac862da0a40f1d2f32554546" translate="yes" xml:space="preserve">
          <source>CRLstatus</source>
          <target state="translated">CRLstatus</target>
        </trans-unit>
        <trans-unit id="3d8d83bcad675694b718b08da5328dd4f850b82a" translate="yes" xml:space="preserve">
          <source>CTH Execution Order</source>
          <target state="translated">CTH約定注文</target>
        </trans-unit>
        <trans-unit id="0be6f7027968e8a0c958298b44e28e9e66535873" translate="yes" xml:space="preserve">
          <source>CTH Processes and Tables</source>
          <target state="translated">CTHのプロセスとテーブル</target>
        </trans-unit>
        <trans-unit id="ff86d60418e1cef1253cf01c43b18051224fcb54" translate="yes" xml:space="preserve">
          <source>CTHs are run with the same process scoping as normal test suites, that is, a different process executes the &lt;code&gt;init_per_suite&lt;/code&gt; hooks then the &lt;code&gt;init_per_group&lt;/code&gt; or &lt;code&gt;per_testcase&lt;/code&gt; hooks. So if you want to spawn a process in the CTH, you cannot link with the CTH process, as it exits after the post hook ends. Also, if you for some reason need an ETS table with your CTH, you must spawn a process that handles it.</source>
          <target state="translated">CTHは、通常のテストスイートと同じスコープのプロセスで実行されます。つまり、異なるプロセスが &lt;code&gt;init_per_suite&lt;/code&gt; フックを実行し、次に &lt;code&gt;init_per_group&lt;/code&gt; または &lt;code&gt;per_testcase&lt;/code&gt; フックを実行します。したがって、CTHでプロセスを生成したい場合は、CTHプロセスとリンクできません。CTHプロセスはpostフックの終了後に終了するためです。また、何らかの理由でCTHを含むETSテーブルが必要な場合は、それを処理するプロセスを生成する必要があります。</target>
        </trans-unit>
        <trans-unit id="7e6e1792db904ba826af372ccec45b6e25fb5024" translate="yes" xml:space="preserve">
          <source>CTHs can also be added within a test suite. This is done by returning &lt;code&gt;{ct_hooks,[CTH]}&lt;/code&gt; in the configuration list from &lt;code&gt;&lt;a href=&quot;common_test#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_suite-1&quot;&gt;init_per_suite/1&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_group-2&quot;&gt;init_per_group/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">CTHは、テストスイート内に追加することもできます。これは、 &lt;code&gt;&lt;a href=&quot;common_test#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_suite-1&quot;&gt;init_per_suite/1&lt;/a&gt;&lt;/code&gt; 、または &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_group-2&quot;&gt;init_per_group/2&lt;/a&gt;&lt;/code&gt; から構成リストで &lt;code&gt;{ct_hooks,[CTH]}&lt;/code&gt; を返すことによって行われます。</target>
        </trans-unit>
        <trans-unit id="fd9865647296ea1525fdd1865f581111a13d82e1" translate="yes" xml:space="preserve">
          <source>CTHs can also be added within a test suite. This is done by returning &lt;code&gt;{ct_hooks,[CTH]}&lt;/code&gt; in the configuration list from &lt;code&gt;&lt;a href=&quot;ct_suite#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_suite-1&quot;&gt; init_per_suite/1&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_group-2&quot;&gt; init_per_group/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">CTHは、テストスイート内に追加することもできます。これは、 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_suite-1&quot;&gt; init_per_suite/1&lt;/a&gt;&lt;/code&gt; 、または &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_group-2&quot;&gt; init_per_group/2&lt;/a&gt;&lt;/code&gt; から構成リストの &lt;code&gt;{ct_hooks,[CTH]}&lt;/code&gt; を返すことによって行われます。</target>
        </trans-unit>
        <trans-unit id="cebcaf761552337b6a6de3a9db00451f69633f4b" translate="yes" xml:space="preserve">
          <source>CTHs can be used to synchronize test runs with external user applications. The init function can, for example, start and/or communicate with an application that has the purpose of preparing the SUT for an upcoming test run, or initialize a database for saving test data to during the test run. The terminate function can similarly order such an application to reset the SUT after the test run, and/or tell the application to finish active sessions and terminate. Any system error- or progress reports generated during the init- or termination stage are saved in the &lt;code&gt;&lt;a href=&quot;run_test_chapter#pre_post_test_io_log&quot;&gt;Pre- and Post Test I/O Log&lt;/a&gt;&lt;/code&gt;. (This is also true for any printouts made with &lt;code&gt;ct:log/2&lt;/code&gt; and &lt;code&gt;ct:pal/2&lt;/code&gt;).</source>
          <target state="translated">CTHを使用して、テスト実行を外部ユーザーアプリケーションと同期させることができます。 init関数は、たとえば、次のテスト実行のためにSUTを準備する目的でアプリケーションを開始または通信したり、テスト実行中にテストデータを保存するためにデータベースを初期化したりできます。終了機能は、同様に、そのようなアプリケーションに、テスト実行後にSUTをリセットするように命令したり、アクティブセッションを終了して終了するようにアプリケーションに指示したりできます。初期化または終了段階で生成されたシステムエラーまたは進行状況レポートは、 &lt;code&gt;&lt;a href=&quot;run_test_chapter#pre_post_test_io_log&quot;&gt;Pre- and Post Test I/O Log&lt;/a&gt;&lt;/code&gt; 保存されます。 （これは、 &lt;code&gt;ct:log/2&lt;/code&gt; および &lt;code&gt;ct:pal/2&lt;/code&gt; で作成されたすべての印刷出力にも当てはまります）。</target>
        </trans-unit>
        <trans-unit id="1413152f77878171b8b1aa5bd33bfea4b91b1e35" translate="yes" xml:space="preserve">
          <source>CTHs cannot be added here right now. That feature may be added in a later release, but it would right now break backwards compatibility.</source>
          <target state="translated">CTHは今はここには追加できません。この機能は後のリリースで追加されるかもしれませんが、今は下位互換性を壊すことになります。</target>
        </trans-unit>
        <trans-unit id="27930480546a406089acbe7e97d210e59cf3f0a5" translate="yes" xml:space="preserve">
          <source>Caches a new session or updates an already cached one. Is only called from the cache handling process.</source>
          <target state="translated">新しいセッションをキャッシュするか、すでにキャッシュされているセッションを更新します。キャッシュ処理プロセスからのみ呼び出されます。</target>
        </trans-unit>
        <trans-unit id="a61c27140fecb8e4a22ce80c81760b45147855bd" translate="yes" xml:space="preserve">
          <source>Calculate scheduler utilizations for the time interval from when &lt;code&gt;Sample&lt;/code&gt; was taken and &quot;now&quot;. The same as calling &lt;code&gt;scheduler:utilization(Sample, scheduler:sample_all())&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Sample&lt;/code&gt; が取得されてから「今」までの時間間隔のスケジューラ使用率を計算します。 &lt;code&gt;scheduler:utilization(Sample, scheduler:sample_all())&lt;/code&gt; を呼び出すのと同じです。</target>
        </trans-unit>
        <trans-unit id="3159ceb44a5156030b65aa273f276c3747dcacc9" translate="yes" xml:space="preserve">
          <source>Calculates a key for later use in &lt;code&gt;&lt;a href=&quot;#driver_async&quot;&gt;driver_async&lt;/a&gt;&lt;/code&gt;. The keys are evenly distributed so that a fair mapping between port IDs and async thread IDs is achieved.</source>
          <target state="translated">後で &lt;code&gt;&lt;a href=&quot;#driver_async&quot;&gt;driver_async&lt;/a&gt;&lt;/code&gt; で使用するためのキーを計算します。キーは均等に分散されるため、ポートIDと非同期スレッドIDの間の公平なマッピングが実現されます。</target>
        </trans-unit>
        <trans-unit id="97a16654177af632fa24a3c60a60a85917da19f0" translate="yes" xml:space="preserve">
          <source>Calculates a ssh fingerprint from a public host key as openssh does.</source>
          <target state="translated">openssh と同様に公開ホスト鍵から ssh のフィンガープリントを計算します。</target>
        </trans-unit>
        <trans-unit id="96b67c5752326af1f998bcfc9d0641aa609cb938" translate="yes" xml:space="preserve">
          <source>Calculates an MD5 redundancy check for the code of the module (compilation date and other attributes are not included).</source>
          <target state="translated">モジュールのコードのMD5冗長性チェックを計算します(コンパイル日やその他の属性は含まれません)。</target>
        </trans-unit>
        <trans-unit id="49556b91adcf0245cb3d710749c75861fa022a4f" translate="yes" xml:space="preserve">
          <source>Calculates and returns the length of queue &lt;code&gt;Q&lt;/code&gt;.</source>
          <target state="translated">キュー &lt;code&gt;Q&lt;/code&gt; の長さを計算して返します。</target>
        </trans-unit>
        <trans-unit id="2e81ece084c83acdfbcc583fdce8e53ba5b901b1" translate="yes" xml:space="preserve">
          <source>Calculates scheduler utilizations for the time interval between the two samples obtained from calling &lt;code&gt;&lt;a href=&quot;#sample-0&quot;&gt;sample/0&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#sample_all-0&quot;&gt;sample_all/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#sample-0&quot;&gt;sample/0&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;#sample_all-0&quot;&gt;sample_all/0&lt;/a&gt;&lt;/code&gt; の呼び出しから取得された2つのサンプル間の時間間隔のスケジューラ使用率を計算します。</target>
        </trans-unit>
        <trans-unit id="227b790ced77d840153cd69f4b9d2467f87af6d9" translate="yes" xml:space="preserve">
          <source>Calculates the Adler-32 checksum for &lt;code&gt;Data&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Data&lt;/code&gt; の Adler-32チェックサムを計算します。</target>
        </trans-unit>
        <trans-unit id="f486ba07e5a51271bcf5c7397d6baef999b087f1" translate="yes" xml:space="preserve">
          <source>Calculates the CRC checksum for &lt;code&gt;Data&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Data&lt;/code&gt; のCRCチェックサムを計算します。</target>
        </trans-unit>
        <trans-unit id="59cabfc35187ea21aad19caf8aed979cfcc7efbb" translate="yes" xml:space="preserve">
          <source>Calculates the time difference &lt;code&gt;Tdiff = T2 - T1&lt;/code&gt; in &lt;strong&gt;microseconds&lt;/strong&gt;, where &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; are time-stamp tuples on the same format as returned from &lt;code&gt; erlang:timestamp/0&lt;/code&gt; or &lt;code&gt; os:timestamp/0&lt;/code&gt;.</source>
          <target state="translated">時間差 &lt;code&gt;Tdiff = T2 - T1&lt;/code&gt; を&lt;strong&gt;マイクロ秒&lt;/strong&gt;単位で計算し&lt;strong&gt;ます&lt;/strong&gt;。ここで、 &lt;code&gt;T1&lt;/code&gt; と &lt;code&gt;T2&lt;/code&gt; は、 &lt;code&gt; erlang:timestamp/0&lt;/code&gt; または &lt;code&gt; os:timestamp/0&lt;/code&gt; から返されるのと同じ形式のタイムスタンプタプルです。</target>
        </trans-unit>
        <trans-unit id="7a8a87c52d80ef29c6c7f4e720f1eb69b8f5e769" translate="yes" xml:space="preserve">
          <source>Calculates the time difference &lt;code&gt;Tdiff = T2 - T1&lt;/code&gt; in &lt;strong&gt;microseconds&lt;/strong&gt;, where &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; are time-stamp tuples on the same format as returned from &lt;code&gt;erlang:timestamp/0&lt;/code&gt; or &lt;code&gt;os:timestamp/0&lt;/code&gt;.</source>
          <target state="translated">計算した時間差 &lt;code&gt;Tdiff = T2 - T1&lt;/code&gt; における&lt;strong&gt;マイクロ秒&lt;/strong&gt;、 &lt;code&gt;T1&lt;/code&gt; 及び &lt;code&gt;T2&lt;/code&gt; は、から返される同じフォーマットのタイムスタンプのタプルである &lt;code&gt;erlang:timestamp/0&lt;/code&gt; 又は &lt;code&gt;os:timestamp/0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="31e631ed71da6b22331e1ba2c1ab40350acc8c94" translate="yes" xml:space="preserve">
          <source>Calculates, without doing the encoding, the maximum byte size for a term encoded in the Erlang external term format. The following condition applies always:</source>
          <target state="translated">エンコーディングを行わずに、Erlangの外部タームフォーマットでエンコードされたタームの最大バイトサイズを計算します。以下の条件が常に適用されます。</target>
        </trans-unit>
        <trans-unit id="d9a2b0161d342ba687bae1cf3bd6fc16726fc85e" translate="yes" xml:space="preserve">
          <source>Call ::= FunSpec &lt;code&gt;-&amp;gt;&lt;/code&gt; FunSpec | &lt;code&gt;{&lt;/code&gt;MFA&lt;code&gt;,&lt;/code&gt; MFA&lt;code&gt;}&lt;/code&gt; | AtomConst &lt;code&gt;-&amp;gt;&lt;/code&gt; AtomConst | &lt;code&gt;{&lt;/code&gt;AtomConst&lt;code&gt;,&lt;/code&gt; AtomConst&lt;code&gt;}&lt;/code&gt;</source>
          <target state="translated">:: = FunSpecを呼び出す &lt;code&gt;-&amp;gt;&lt;/code&gt; FunSpec | &lt;code&gt;{&lt;/code&gt; MFA &lt;code&gt;,&lt;/code&gt; MFA &lt;code&gt;}&lt;/code&gt; | AtomConst- &lt;code&gt;-&amp;gt;&lt;/code&gt; AtomConst | &lt;code&gt;{&lt;/code&gt; AtomConst &lt;code&gt;,&lt;/code&gt; AtomConst &lt;code&gt;}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ecdbacce8a3993e206cefb1a9385869bf9d9f72a" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;&lt;a href=&quot;#connect-1&quot;&gt;connect/1,2&lt;/a&gt;&lt;/code&gt; to establish a connection to a server, then pass the returned handle to &lt;code&gt;&lt;a href=&quot;#session-1&quot;&gt;session/1-3&lt;/a&gt;&lt;/code&gt; to establish a NETCONF session on a new SSH channel. Each call to &lt;code&gt;&lt;a href=&quot;#session-1&quot;&gt;session/1-3&lt;/a&gt;&lt;/code&gt; establishes a new session on the same connection, and results in a hello message to the server.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#connect-1&quot;&gt;connect/1,2&lt;/a&gt;&lt;/code&gt; を呼び出してサーバーへの接続を確立してから、返されたハンドルを &lt;code&gt;&lt;a href=&quot;#session-1&quot;&gt;session/1-3&lt;/a&gt;&lt;/code&gt; に渡して、新しいSSHチャネルでNETCONFセッションを確立します。 &lt;code&gt;&lt;a href=&quot;#session-1&quot;&gt;session/1-3&lt;/a&gt;&lt;/code&gt; を呼び出すたびに、同じ接続で新しいセッションが確立され、サーバーにhelloメッセージが送信されます。</target>
        </trans-unit>
        <trans-unit id="ff341ca2509327aaf0ceb26b489066bc294ca073" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;&lt;a href=&quot;#enif_schedule_nif&quot;&gt; enif_schedule_nif&lt;/a&gt;&lt;/code&gt;, pass to it a pointer to the dirty NIF to be executed, and indicate with argument &lt;code&gt;flags&lt;/code&gt; whether it expects the operation to be CPU-bound or I/O-bound.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#enif_schedule_nif&quot;&gt; enif_schedule_nif&lt;/a&gt;&lt;/code&gt; を呼び出し、実行されるダーティNIFへのポインターを渡し、操作がCPUバウンドであるかI / Oバウンドであるかを引数 &lt;code&gt;flags&lt;/code&gt; 示します。</target>
        </trans-unit>
        <trans-unit id="e87defee9508517c6c10659d4e0fee5236449ad6" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;&lt;a href=&quot;#enif_schedule_nif&quot;&gt;enif_schedule_nif&lt;/a&gt;&lt;/code&gt;, pass to it a pointer to the dirty NIF to be executed, and indicate with argument &lt;code&gt;flags&lt;/code&gt; whether it expects the operation to be CPU-bound or I/O-bound.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#enif_schedule_nif&quot;&gt;enif_schedule_nif&lt;/a&gt;&lt;/code&gt; を呼び出し、実行するダーティNIFへのポインターを渡し、操作がCPUにバインドされているかI / Oにバインドされているかを引数 &lt;code&gt;flags&lt;/code&gt; 示します。</target>
        </trans-unit>
        <trans-unit id="69bfcf4495124cb65edd6183c66a7288de41dd51" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;analyze&lt;/code&gt; with &lt;code&gt;total&lt;/code&gt; option when profiling has been stopped to display the results per function call, that is in which function calls the time has been spent.</source>
          <target state="translated">関数呼び出しごとの結果を表示するためにプロファイリングが停止している場合、つまり、関数呼び出しに費やされた時間が経過したときに、 &lt;code&gt;total&lt;/code&gt; オプションを指定して &lt;code&gt;analyze&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="166bcff3bd03bad3b22be129a767e953b92bb7c5" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;info&lt;/code&gt;:</source>
          <target state="translated">電話 &lt;code&gt;info&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="9b32de2da67e0b479c6558da688c298d2c8d61df" translate="yes" xml:space="preserve">
          <source>Call Graph Edges (*).</source>
          <target state="translated">グラフエッジ(*)を呼び出します。</target>
        </trans-unit>
        <trans-unit id="ee61800f5d1b4760400245c96aa2f8c30730dd00" translate="yes" xml:space="preserve">
          <source>Call Graph Vertices (*).</source>
          <target state="translated">グラフの頂点(*)を呼び出します。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
