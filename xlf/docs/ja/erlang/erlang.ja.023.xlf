<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="200407071e2ee196988d7a1889800e7d1509e085" translate="yes" xml:space="preserve">
          <source>In case of a match operation between a ReferenceID and a CN value from the &lt;code&gt;Subject&lt;/code&gt; field, the first argument to the fun is the extracted hostname from the ReferenceID, and the second argument is the tuple &lt;code&gt;{cn, string()}&lt;/code&gt; taken from the &lt;code&gt;Subject&lt;/code&gt; field. That makes it possible to have separate matching rules for Presented IDs from the &lt;code&gt;Subject&lt;/code&gt; field and from the &lt;code&gt;Subject Alternate Name&lt;/code&gt; field.</source>
          <target state="translated">ReferenceIDと &lt;code&gt;Subject&lt;/code&gt; フィールドのCN値の間の一致操作の場合、funへの最初の引数はReferenceIDから抽出されたホスト名で、2番目の引数は &lt;code&gt;Subject&lt;/code&gt; から取得されたタプル &lt;code&gt;{cn, string()}&lt;/code&gt; フィールド。これにより、[ &lt;code&gt;Subject&lt;/code&gt; フィールドと[ &lt;code&gt;Subject Alternate Name&lt;/code&gt; フィールドから、提示されたIDに個別の一致ルールを設定できます。</target>
        </trans-unit>
        <trans-unit id="d57c67c502f00b82712590fc8169173e11b61f4a" translate="yes" xml:space="preserve">
          <source>In case of an error (for example, &lt;code&gt;addr_unreachable&lt;/code&gt;), field &lt;code&gt;error&lt;/code&gt; provides more diagnostics. In such cases, event &lt;code&gt;#sctp_paddr_change{}&lt;/code&gt; is automatically converted into an &lt;code&gt;error&lt;/code&gt; term returned by &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;error&lt;/code&gt; field value can be converted into a string using &lt;code&gt;&lt;a href=&quot;#error_string-1&quot;&gt;error_string/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">エラー（たとえば、 &lt;code&gt;addr_unreachable&lt;/code&gt; ）の場合、フィールド &lt;code&gt;error&lt;/code&gt; はより多くの診断を提供します。そのような場合、イベント &lt;code&gt;#sctp_paddr_change{}&lt;/code&gt; は自動的に &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv&lt;/a&gt;&lt;/code&gt; によって返される &lt;code&gt;error&lt;/code&gt; 項に変換されます。 &lt;code&gt;error&lt;/code&gt; フィールド値を使用して文字列に変換することができる &lt;code&gt;&lt;a href=&quot;#error_string-1&quot;&gt;error_string/1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e587acfb74f322fbcfbbb116173319a489ae29e8" translate="yes" xml:space="preserve">
          <source>In case of an error, all instrumentation functions may return either an SNMPv1 or an SNMPv2 error code. If it returns an SNMPv2 code, it is converted into an SNMPv1 code before it is sent to a SNMPv1 manager. It is recommended to use the SNMPv2 error codes for all instrumentation functions, as these provide more details. See &lt;code&gt;&lt;a href=&quot;snmp_app_a&quot;&gt;Appendix A&lt;/a&gt;&lt;/code&gt; for a description of error code conversions.</source>
          <target state="translated">エラーが発生した場合、すべての計測機能がSNMPv1またはSNMPv2エラーコードを返す場合があります。SNMPv2コードを返す場合は、SNMPv1マネージャに送信される前にSNMPv1コードに変換されます。すべての計測機能にSNMPv2エラーコードを使用することをお勧めします。これにより、詳細が提供されます。エラーコード変換の説明については、 &lt;code&gt;&lt;a href=&quot;snmp_app_a&quot;&gt;Appendix A&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="7ca8c5900d9e5d4e81eb7db9c8c5e95ada47eae8" translate="yes" xml:space="preserve">
          <source>In case of lists there is only percent-encoding. In binaries, however, both binary encoding and percent-encoding shall be considered. &lt;code&gt;transcode/2&lt;/code&gt; provides the means to convert between the supported encodings, it takes a &lt;code&gt;uri_string()&lt;/code&gt; and a list of options specifying inbound and outbound encodings.</source>
          <target state="translated">リストの場合は、パーセントエンコーディングしかありません。ただし、バイナリでは、バイナリエンコーディングとパーセントエンコーディングの両方が考慮されます。 &lt;code&gt;transcode/2&lt;/code&gt; はサポートされているエンコーディング間で変換する手段を提供します。それは &lt;code&gt;uri_string()&lt;/code&gt; とインバウンドとアウトバウンドのエンコーディングを指定するオプションのリストを取ります。</target>
        </trans-unit>
        <trans-unit id="808f4c12856e1f075895b6b1b300374926fab373" translate="yes" xml:space="preserve">
          <source>In case of loading, monitoring can &lt;strong&gt;not&lt;/strong&gt; only get triggered by using option &lt;code&gt;{reload, ReloadOption}&lt;/code&gt;, but also in special cases where the load error is transient. Thus, &lt;code&gt;{monitor, pending_driver}&lt;/code&gt; is to be used under basically &lt;strong&gt;all&lt;/strong&gt; real world circumstances.</source>
          <target state="translated">ローディングの場合には、できモニタリング&lt;strong&gt;しない&lt;/strong&gt;唯一のオプション使用によってトリガー取得 &lt;code&gt;{reload, ReloadOption}&lt;/code&gt; だけでなく、ロードエラーが一時的である特別な場合には、。したがって、 &lt;code&gt;{monitor, pending_driver}&lt;/code&gt; は、基本的に&lt;strong&gt;すべての&lt;/strong&gt;現実の環境で使用されます。</target>
        </trans-unit>
        <trans-unit id="977b39c15ba3f7569c95130949a0911293fdf7e5" translate="yes" xml:space="preserve">
          <source>In case where the Presented IDs are fetched from the &lt;code&gt;Subject&lt;/code&gt; certificate field, the names may contain wildcard characters. The function handles this as defined in &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6125#section-6.4.3&quot;&gt;chapter 6.4.3 in RFC 6125&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">提示されたIDが &lt;code&gt;Subject&lt;/code&gt; 証明書フィールドからフェッチされる場合、名前にワイルドカード文字が含まれている可能性があります。関数は &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6125#section-6.4.3&quot;&gt;chapter 6.4.3 in RFC 6125&lt;/a&gt;&lt;/code&gt; 定義されているようにこれを処理します。</target>
        </trans-unit>
        <trans-unit id="6c2392e0d50603f0a73106c4fc2922254ed71b25" translate="yes" xml:space="preserve">
          <source>In cases in which there is a choice between string() and binary() types for OctetString() and derived types, the representation is determined by the value of &lt;code&gt;&lt;a href=&quot;diameter#service_opt&quot;&gt;diameter:service_opt()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;diameter#string_decode&quot;&gt;string_decode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">OctetString（）のstring（）型とbinary（）型と派生型の間で選択がある場合、表現は、 &lt;code&gt;&lt;a href=&quot;diameter#service_opt&quot;&gt;diameter:service_opt()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;diameter#string_decode&quot;&gt;string_decode&lt;/a&gt;&lt;/code&gt; の値によって決定されます。</target>
        </trans-unit>
        <trans-unit id="ef42ed541c5fd6f99645f29530b756b01b921460" translate="yes" xml:space="preserve">
          <source>In cases where it is known that the subject string contains no newlines, it is worth setting &lt;code&gt;dotall&lt;/code&gt; to obtain this optimization, or alternatively using ^ to indicate anchoring explicitly.</source>
          <target state="translated">対象の文字列に改行が含まれていないことがわかっている場合は、 &lt;code&gt;dotall&lt;/code&gt; を設定してこの最適化を行うか、^を使用してアンカーを明示的に示すことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="a1b58942bdfb61fbfab275afba5031d1b18f39aa" translate="yes" xml:space="preserve">
          <source>In cases where you want to redirect standard input and/or standard output or use Erlang in a pipeline, &lt;code&gt;werl&lt;/code&gt; is not suitable, and the &lt;code&gt;erl&lt;/code&gt; program is to be used instead.</source>
          <target state="translated">標準入力または標準出力、あるいはその両方をリダイレクトする場合、またはパイプラインでErlangを使用する場合は、 &lt;code&gt;werl&lt;/code&gt; は適切ではなく、代わりに &lt;code&gt;erl&lt;/code&gt; プログラムが使用されます。</target>
        </trans-unit>
        <trans-unit id="43f3712fe1600a053e4d1e45bcba55920060bee0" translate="yes" xml:space="preserve">
          <source>In certain output functions and in the output of return values in the shell, Erlang tries to detect string data in lists and binaries heuristically. Typically you will see heuristic detection in a situation like this:</source>
          <target state="translated">ある種の出力関数やシェルの戻り値の出力では、Erlangはリストやバイナリの中の文字列データをヒューリスティックに検出しようとします。典型的には、以下のような状況でヒューリスティックな検出を見ることができます。</target>
        </trans-unit>
        <trans-unit id="2913f30605a1fdbcd933f0b8e8b6036a00ba77d8" translate="yes" xml:space="preserve">
          <source>In certain situations, especially when the standard output is redirected, access to an I/O server specific for error messages can be convenient. The I/O device &lt;code&gt;standard_error&lt;/code&gt; can be used to direct output to whatever the current operating system considers a suitable I/O device for error output. Example on a Unix-like operating system:</source>
          <target state="translated">特定の状況では、特に標準出力がリダイレクトされる場合、エラーメッセージに固有のI / Oサーバーへのアクセスが便利です。I / Oデバイス &lt;code&gt;standard_error&lt;/code&gt; を使用して、現在のオペレーティングシステムがエラー出力に適したI / Oデバイスと見なしているものに出力を送ることができます。Unixライクなオペレーティングシステムの例：</target>
        </trans-unit>
        <trans-unit id="3962d4a09e381d0a5b5f8e864d0585d6a5883982" translate="yes" xml:space="preserve">
          <source>In combination with &lt;code&gt;{locations, true}&lt;/code&gt; this option prints the lock operations source file and line number entry-points along with statistics for each entry.</source>
          <target state="translated">このオプションは &lt;code&gt;{locations, true}&lt;/code&gt; と組み合わせて、ロック操作のソースファイルと行番号のエントリポイントを各エントリの統計とともに出力します。</target>
        </trans-unit>
        <trans-unit id="d0663aa5a3512196f700ca9db937eddad06a6262" translate="yes" xml:space="preserve">
          <source>In conjunction with option &lt;code&gt;-M&lt;/code&gt; or &lt;code&gt;-MF&lt;/code&gt;, adds a phony target for each dependency.</source>
          <target state="translated">オプション &lt;code&gt;-M&lt;/code&gt; または &lt;code&gt;-MF&lt;/code&gt; と組み合わせて、各依存関係に偽のターゲットを追加します。</target>
        </trans-unit>
        <trans-unit id="71822bd1bd6d5c17ee53e249eaeb9feb7f740847" translate="yes" xml:space="preserve">
          <source>In conjunction with option &lt;code&gt;-M&lt;/code&gt; or &lt;code&gt;-MF&lt;/code&gt;, changes the name of the rule emitted to &lt;code&gt;Target&lt;/code&gt;.</source>
          <target state="translated">オプション &lt;code&gt;-M&lt;/code&gt; または &lt;code&gt;-MF&lt;/code&gt; と組み合わせて、 &lt;code&gt;Target&lt;/code&gt; 発行されたルールの名前を変更します。</target>
        </trans-unit>
        <trans-unit id="799eab09c6f865f28e612e123d49d644e3a08fdd" translate="yes" xml:space="preserve">
          <source>In conjunction with option &lt;code&gt;-M&lt;/code&gt; or &lt;code&gt;-MF&lt;/code&gt;, considers missing headers as generated files and adds them to the dependencies.</source>
          <target state="translated">オプション &lt;code&gt;-M&lt;/code&gt; または &lt;code&gt;-MF&lt;/code&gt; と組み合わせて、欠落しているヘッダーを生成されたファイルと見なし、依存関係に追加します。</target>
        </trans-unit>
        <trans-unit id="d32124678089e39bfca82cfddf077b823139344c" translate="yes" xml:space="preserve">
          <source>In contrast to an RPC, a multicall is an RPC that is sent concurrently from one client to multiple servers. This is useful for collecting information from a set of nodes, or for calling a function on a set of nodes to achieve some side effects. It is semantically the same as iteratively making a series of RPCs on all the nodes, but the multicall is faster, as all the requests are sent at the same time and are collected one by one as they come back.</source>
          <target state="translated">RPCとは対照的に、マルチコールは、1つのクライアントから複数のサーバに同時に送信されるRPCです。これは、あるノードのセットから情報を収集したり、あるノードのセットで関数を呼び出して何らかの副次的効果を達成したりするのに便利です。意味的には、すべてのノードで一連のRPCを反復的に行うのと同じですが、すべてのリクエストが同時に送信され、戻ってきたときに1つずつ収集されるので、マルチコールの方が高速です。</target>
        </trans-unit>
        <trans-unit id="e6c250fb90561ab264baf4cf8dabd48e1c97e8c8" translate="yes" xml:space="preserve">
          <source>In contrast to most of the other callback functions, &lt;code&gt;stop_select&lt;/code&gt; is called independent of any port. No &lt;code&gt;ErlDrvData&lt;/code&gt; argument is passed to the function. No driver lock or port lock is guaranteed to be held. The port that called &lt;code&gt;driver_select&lt;/code&gt; can even be closed at the time &lt;code&gt;stop_select&lt;/code&gt; is called. But it can also be the case that &lt;code&gt;stop_select&lt;/code&gt; is called directly by &lt;code&gt;erl_driver:driver_select&lt;/code&gt;.</source>
          <target state="translated">他のほとんどのコールバック関数とは対照的に、 &lt;code&gt;stop_select&lt;/code&gt; はどのポートからも独立して呼び出されます。 &lt;code&gt;ErlDrvData&lt;/code&gt; 引数は関数に渡されません。ドライバーロックまたはポートロックの保持は保証されていません。 &lt;code&gt;driver_select&lt;/code&gt; を呼び出したポートは、 &lt;code&gt;stop_select&lt;/code&gt; が呼び出されたときに閉じることもできます。しかし、また、ある場合することができ &lt;code&gt;stop_select&lt;/code&gt; がで直接呼び出され &lt;code&gt;erl_driver:driver_select&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="72bf39173d9a61b211eba3bd517308261f47677f" translate="yes" xml:space="preserve">
          <source>In contrast, a subroutine call to a numbered subpattern always refers to the first one in the pattern with the given number. The following pattern matches &quot;abcabc&quot; or &quot;defabc&quot;:</source>
          <target state="translated">対照的に、番号付きのサブパターンへのサブルーチン呼び出しは、常に与えられた番号を持つパターンの最初のものを参照します。次のパターンは「abcabc」または「defabc」と一致します。</target>
        </trans-unit>
        <trans-unit id="2b1893e8c44648aaa4d2220a6408b6c74957584a" translate="yes" xml:space="preserve">
          <source>In crash dumps, the stack, messages, and the process dictionary are omitted.</source>
          <target state="translated">クラッシュダンプでは、スタック、メッセージ、プロセス辞書は省略されます。</target>
        </trans-unit>
        <trans-unit id="009dc66d33d0ffea38b40e283770f175ec84745e" translate="yes" xml:space="preserve">
          <source>In dirty context, that is, &lt;code&gt;sync_dirty&lt;/code&gt; or &lt;code&gt;async_dirty&lt;/code&gt;, the modified records are not stored in a local copy; instead, each record is updated separately. This generates much network traffic if the table has a replica on another node and has all the other drawbacks that dirty operations have. Especially for commands &lt;code&gt;&lt;a href=&quot;mnesia#first-1&quot;&gt;mnesia:first/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;mnesia#next-2&quot;&gt;mnesia:next/2&lt;/a&gt;&lt;/code&gt;, the same drawbacks as described previously for &lt;code&gt;&lt;a href=&quot;mnesia#dirty_first-1&quot;&gt;mnesia:dirty_first/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;mnesia#dirty_next-2&quot;&gt;mnesia:dirty_next/2&lt;/a&gt;&lt;/code&gt; applies, that is, no writing to the table is to be done during iteration.</source>
          <target state="translated">ダーティーコンテキスト、つまり &lt;code&gt;sync_dirty&lt;/code&gt; または &lt;code&gt;async_dirty&lt;/code&gt; では、変更されたレコードはローカルコピーに保存されません。代わりに、各レコードは個別に更新されます。これにより、テーブルに別のノードにレプリカがあり、ダーティオペレーションにある他のすべての欠点がある場合、多くのネットワークトラフィックが生成されます。特にコマンド &lt;code&gt;&lt;a href=&quot;mnesia#first-1&quot;&gt;mnesia:first/1&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;mnesia#next-2&quot;&gt;mnesia:next/2&lt;/a&gt;&lt;/code&gt; の場合、以前に &lt;code&gt;&lt;a href=&quot;mnesia#dirty_first-1&quot;&gt;mnesia:dirty_first/1&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;mnesia#dirty_next-2&quot;&gt;mnesia:dirty_next/2&lt;/a&gt;&lt;/code&gt; について説明したのと同じ欠点が適用されます。つまり、反復中にテーブルへの書き込みは行われません。</target>
        </trans-unit>
        <trans-unit id="1a0a0d4d35649ef6ee46c466316008c66431587a" translate="yes" xml:space="preserve">
          <source>In each &lt;code&gt;Viewer&lt;/code&gt; there is only one filter that is active and all trace &lt;code&gt;Events&lt;/code&gt; that the &lt;code&gt;Viewer&lt;/code&gt; gets from the &lt;code&gt;Collector&lt;/code&gt; will pass thru that filter. By writing clever filters it is possible to customize how the &lt;code&gt;Events&lt;/code&gt; looks like in the viewer. The following filter in &lt;code&gt;et/examples/et_demo.erl&lt;/code&gt; replaces the actor names &lt;code&gt;mnesia_tm&lt;/code&gt; and &lt;code&gt;mnesia_locker&lt;/code&gt; and leaves everything else in the record as it was:</source>
          <target state="translated">各 &lt;code&gt;Viewer&lt;/code&gt; にはアクティブなフィルタが1つだけあり、 &lt;code&gt;Viewer&lt;/code&gt; が &lt;code&gt;Collector&lt;/code&gt; から取得するすべてのトレース &lt;code&gt;Events&lt;/code&gt; はそのフィルタを通過します。巧妙なフィルターを作成することで、 &lt;code&gt;Events&lt;/code&gt; がビューアーでどのように表示されるかをカスタマイズできます。 &lt;code&gt;et/examples/et_demo.erl&lt;/code&gt; の次のフィルタは、 &lt;code&gt;mnesia_tm&lt;/code&gt; と &lt;code&gt;mnesia_locker&lt;/code&gt; というアクター名を置き換え、他のすべてをそのままにします。</target>
        </trans-unit>
        <trans-unit id="7207b6cf9942a41d2732aa49d03bc019b9c6508d" translate="yes" xml:space="preserve">
          <source>In each iteration, the first 8 bits in the binary will be skipped, not matched out.</source>
          <target state="translated">各イテレーションでは、バイナリの最初の8ビットはスキップされ、マッチアウトされません。</target>
        </trans-unit>
        <trans-unit id="eb6692c5b77a86308b6ebf869c484cc1ff8e5ede" translate="yes" xml:space="preserve">
          <source>In earlier Erlang/OTP releases, operations on too large binaries in general either fail or give incorrect results. In future releases, other operations that create binaries (such as &lt;code&gt;list_to_binary/1&lt;/code&gt;) will probably also enforce the same limit.</source>
          <target state="translated">以前のErlang / OTPリリースでは、一般的に大きすぎるバイナリでの操作は失敗するか、正しくない結果をもたらします。将来のリリースでは、バイナリを作成する他の操作（ &lt;code&gt;list_to_binary/1&lt;/code&gt; など）でも、おそらく同じ制限が適用されます。</target>
        </trans-unit>
        <trans-unit id="a79ea28e01a94d82c32763fb4b89f0d00a82f9b8" translate="yes" xml:space="preserve">
          <source>In either case, the agent will do nothing, but return the retrieved ManagerEngineID (see &lt;code&gt;&lt;a href=&quot;snmpa#discovery&quot;&gt;discovery&lt;/a&gt;&lt;/code&gt; for more info) and possible continue with stage 2 of the discovery process.</source>
          <target state="translated">どちらの場合も、エージェントは何もしませんが、取得したManagerEngineID（詳細は &lt;code&gt;&lt;a href=&quot;snmpa#discovery&quot;&gt;discovery&lt;/a&gt;&lt;/code&gt; を参照）を返し、ディスカバリープロセスのステージ2を続行できます。</target>
        </trans-unit>
        <trans-unit id="6791868ca84c6905bfaf1ddbc9f4f687833d3165" translate="yes" xml:space="preserve">
          <source>In embedded mode, all code is loaded during system startup according to the boot script. (Code can also be loaded later by explicitly ordering the code server to do so.)</source>
          <target state="translated">組み込みモードでは、すべてのコードはブートスクリプトに従ってシステム起動時にロードされます。(コードサーバに明示的に命令することで、後でコードをロードすることもできます)。</target>
        </trans-unit>
        <trans-unit id="b50f303eb6355438df5780a62638469b2bf7dcf5" translate="yes" xml:space="preserve">
          <source>In embedded mode, first all modules are loaded. Then all &lt;code&gt;on_load&lt;/code&gt; functions are called. The system is terminated unless all of the &lt;code&gt;on_load&lt;/code&gt; functions return &lt;code&gt;ok&lt;/code&gt;.</source>
          <target state="translated">組み込みモードでは、最初にすべてのモジュールがロードされます。次に、すべての &lt;code&gt;on_load&lt;/code&gt; 関数が呼び出されます。すべての &lt;code&gt;on_load&lt;/code&gt; 関数が &lt;code&gt;ok&lt;/code&gt; を返さない限り、システムは終了します。</target>
        </trans-unit>
        <trans-unit id="f2dd392efb3ccbc428fed625f643db9c1a171840" translate="yes" xml:space="preserve">
          <source>In embedded mode, modules are not auto loaded. Trying to use a module that has not been loaded results in an error. This mode is recommended when the boot script loads all modules, as it is typically done in OTP releases. (Code can still be loaded later by explicitly ordering the code server to do so).</source>
          <target state="translated">組み込みモードでは、モジュールは自動ロードされません。ロードされていないモジュールを使おうとするとエラーになります。このモードは、ブートスクリプトがすべてのモジュールをロードするときに推奨されます。(コードサーバに明示的に命令することで、後でコードをロードすることができます)。</target>
        </trans-unit>
        <trans-unit id="fc60ce46c151028d30005b444c453c26498c7146" translate="yes" xml:space="preserve">
          <source>In embedded systems with a limited amount of RAM and no virtual memory, you might want to preserve memory by setting &lt;code&gt;Number&lt;/code&gt; to zero. (The value can be set globally, see &lt;code&gt;&lt;a href=&quot;#system_flag-2&quot;&gt;erlang:system_flag/2&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">RAMが限られていて仮想メモリがない組み込みシステムでは、 &lt;code&gt;Number&lt;/code&gt; をゼロに設定してメモリを保持したい場合があります。（値はグローバルに設定できます &lt;code&gt;&lt;a href=&quot;#system_flag-2&quot;&gt;erlang:system_flag/2&lt;/a&gt;&lt;/code&gt; 参照してください。）</target>
        </trans-unit>
        <trans-unit id="a83f38724964e749e7fb12c41663c8a1d17b6a70" translate="yes" xml:space="preserve">
          <source>In essence, the function performs the same operation as &lt;code&gt;ei_xreceive_msg&lt;/code&gt;, but instead of using an &lt;code&gt;ei_x_buff&lt;/code&gt;, the function expects a pointer to a character pointer (&lt;code&gt;mbufp&lt;/code&gt;), where the character pointer is to point to a memory area allocated by &lt;code&gt;malloc&lt;/code&gt;. Argument &lt;code&gt;bufsz&lt;/code&gt; is to be a pointer to an integer containing the exact size (in bytes) of the memory area. The function may reallocate the memory area and will in such cases put the new size in &lt;code&gt;*bufsz&lt;/code&gt; and update &lt;code&gt;*mbufp&lt;/code&gt;.</source>
          <target state="translated">本質的には、機能は同じ動作実行 &lt;code&gt;ei_xreceive_msg&lt;/code&gt; を、代わりに使用する &lt;code&gt;ei_x_buff&lt;/code&gt; を、関数は、文字ポインタ（へのポインタ期待 &lt;code&gt;mbufp&lt;/code&gt; 文字ポインタによって割り当てられたメモリ領域へのポイントである）、 &lt;code&gt;malloc&lt;/code&gt; 関数を。引数 &lt;code&gt;bufsz&lt;/code&gt; は、メモリ領域の正確なサイズ（バイト単位）を含む整数へのポインターです。関数はメモリ領域を再割り当てする可能性があり、そのような場合、新しいサイズを &lt;code&gt;*bufsz&lt;/code&gt; に入れ、* mbufpを更新し &lt;code&gt;*mbufp&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0a0eed82352e329b2edf4d4c83a697e586f41d04" translate="yes" xml:space="preserve">
          <source>In every directory under &lt;code&gt;DocumentRoot&lt;/code&gt; or under an &lt;code&gt;Alias&lt;/code&gt; a user can place an access file. An access file is a plain text file that specifies the restrictions to consider before the web server answers to a request. If there are more than one access file in the path to the requested asset, the directives in the access file in the directory nearest the asset is used.</source>
          <target state="translated">&lt;code&gt;DocumentRoot&lt;/code&gt; または &lt;code&gt;Alias&lt;/code&gt; の下のすべてのディレクトリに、ユーザーはアクセスファイルを配置できます。アクセスファイルは、Webサーバーが要求に応答する前に考慮する制限を指定するプレーンテキストファイルです。リクエストされたアセットへのパスに複数のアクセスファイルがある場合、アセットに最も近いディレクトリにあるアクセスファイルのディレクティブが使用されます。</target>
        </trans-unit>
        <trans-unit id="6115207717e886104fd373d8df969be5b6da13f2" translate="yes" xml:space="preserve">
          <source>In fact since random data is cached some numbers may get reproduced if you try, but this is unpredictable.</source>
          <target state="translated">実際にはランダムデータがキャッシュされているので、試してみるといくつかの数字が再現されるかもしれませんが、これは予測できません。</target>
        </trans-unit>
        <trans-unit id="b8c42f9c0fe05f000ea096a90949e9096c2f9d28" translate="yes" xml:space="preserve">
          <source>In fortunate cases, the inconsistency is only visible in tables belonging to a specific application. However, if a schema transaction is inconsistently recovered because of the enforced transaction recovery decision, the effects of the inconsistency can be fatal. However, if the higher priority is availability rather than consistency, it can be worth the risk.</source>
          <target state="translated">幸いなことに、不整合は、特定のアプリケーションに属するテーブルにしか見えない。しかし、強行されたトランザクション回復決定のためにスキーマトランザクションが矛盾して回復された場合、矛盾の影響は致命的なものになる可能性があります。しかし、一貫性よりも可用性の方が優先度が高い場合は、そのリスクに見合うだけの価値があります。</target>
        </trans-unit>
        <trans-unit id="711417732b3b7abd2d21d3e6c58e046cc718902b" translate="yes" xml:space="preserve">
          <source>In general, bugs are only fixed on the latest &lt;code&gt;&lt;a href=&quot;versions#releases_and_patches&quot;&gt;release&lt;/a&gt;&lt;/code&gt;, and new features are introduced in the upcoming release that is under development. However, when we, due to internal reasons, fix bugs on older releases, these will be available and announced as well.</source>
          <target state="translated">一般に、バグは最新 &lt;code&gt;&lt;a href=&quot;versions#releases_and_patches&quot;&gt;release&lt;/a&gt;&lt;/code&gt; でのみ修正され、新機能は開発中の次のリリースで導入されます。ただし、内部的な理由により、以前のリリースのバグを修正した場合、それらも利用可能になり、発表されます。</target>
        </trans-unit>
        <trans-unit id="8591b3b2816e58b50758f8b5b1d4a64b54ea4bb8" translate="yes" xml:space="preserve">
          <source>In general, subpatterns that were not assigned a value in the match are returned as the tuple &lt;code&gt;{-1,0}&lt;/code&gt; when &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;index&lt;/code&gt;. Unassigned subpatterns are returned as the empty binary or list, respectively, for other return types. Consider the following regular expression:</source>
          <target state="translated">一般に、 &lt;code&gt;type&lt;/code&gt; が &lt;code&gt;index&lt;/code&gt; の場合、一致で値が割り当てられなかったサブパターンは、タプル &lt;code&gt;{-1,0}&lt;/code&gt; として返されます。割り当てられていないサブパターンは、他の戻り型の場合、それぞれ空のバイナリまたはリストとして返されます。次の正規表現について考えてみます。</target>
        </trans-unit>
        <trans-unit id="7b4248b8374fe10eea98b0157468a4afeb3bbaff" translate="yes" xml:space="preserve">
          <source>In general, there are better ways than using time-outs to supervise parts of a distributed Erlang system. Time-outs are usually appropriate to supervise external events, for example, if you have expected a message from some external system within a specified time. For example, a time-out can be used to log a user out of the messenger system if they have not accessed it for, say, ten minutes.</source>
          <target state="translated">一般的に、分散Erlangシステムの一部を監視するためにタイムアウトを使うよりも良い方法があります。例えば、指定した時間内に外部システムからのメッセージを期待している場合などです。例えば、タイムアウトはメッセンジャーシステムに10分間アクセスしていないユーザをログアウトさせるのに使えます。</target>
        </trans-unit>
        <trans-unit id="1f8e5e60557a33a0b1e1b193f222fccaafdbdfe2" translate="yes" xml:space="preserve">
          <source>In general, tuples are used where &quot;records&quot; or &quot;structs&quot; are used in other languages. Also, lists are used when representing things with varying sizes, that is, where linked lists are used in other languages.</source>
          <target state="translated">一般に、他の言語では「レコード」や「構造体」が使われている場合、タプルが使われます。また、大きさの異なるものを表現する場合にはリストが使われ、他の言語ではリンクされたリストが使われています。</target>
        </trans-unit>
        <trans-unit id="1094cd272fde4947e952467ed139509ff51ffbba" translate="yes" xml:space="preserve">
          <source>In general, versions can have more than three parts. The versions are then only partially ordered. Such versions are only used in exceptional cases. When an extra part (out of the normal three parts) is added to a version number, a new branch of versions is made. The new branch has a linear order against the base version. However, versions on different branches have no order, and therefore one can only conclude that they all include what is included in their closest common ancestor. When branching multiple times from the same base version, &lt;code&gt;0&lt;/code&gt; parts are added between the base version and the least significant &lt;code&gt;1&lt;/code&gt; part until a unique version is found. Versions that have an order can be compared as described in the previous paragraph.</source>
          <target state="translated">一般に、バージョンには4つ以上の部分があります。その後、バージョンは部分的にのみ注文されます。このようなバージョンは、例外的な場合にのみ使用されます。 （通常の3つのパーツのうち）追加のパーツがバージョン番号に追加されると、バージョンの新しいブランチが作成されます。新しいブランチは、基本バージョンに対して線形の順序を持​​っています。ただし、異なるブランチのバージョンには順序がないため、最も近い共通の祖先に含まれているものがすべて含まれていると結論付けることができます。同じ基本バージョンから複数回分岐する場合、一意のバージョンが見つかるまで、基本バージョンと最下位 &lt;code&gt;1&lt;/code&gt; パーツの間に &lt;code&gt;0&lt;/code&gt; パーツが追加されます。前の段落で説明したように、順序のあるバージョンを比較できます。</target>
        </trans-unit>
        <trans-unit id="687a73013b2ef41da5625c9f94315c9a3c6f0e31" translate="yes" xml:space="preserve">
          <source>In global trace mode, the collector will automatically start tracing on all connected Erlang nodes. When a node connects, a port tracer will be started on that node and a corresponding trace client on the collector node.</source>
          <target state="translated">グローバルトレースモードでは、コレクタは自動的に接続されたすべての Erlang ノードのトレースを開始します。ノードが接続されると、そのノード上でポートトレーサが開始され、コレクタノード上で対応するトレースクライアントが開始されます。</target>
        </trans-unit>
        <trans-unit id="581aa3bc4711cf7334b4a74e7f3a343e5b4ccbeb" translate="yes" xml:space="preserve">
          <source>In interactive mode, the code is dynamically loaded when first referenced. When a call to a function in a module is made, and the module is not loaded, the code server searches the code path and loads the module into the system.</source>
          <target state="translated">インタラクティブ・モードでは、最初に参照されたときにコードが動的にロードされます。モジュール内の関数への呼び出しが行われ、モジュールがロードされていない場合、コードサーバはコードパスを検索し、モジュールをシステムにロードします。</target>
        </trans-unit>
        <trans-unit id="e0d2190b345450b7396978e3dbbae9980e03e388" translate="yes" xml:space="preserve">
          <source>In interactive mode, the code server maintains a search path, usually called the &lt;strong&gt;code path&lt;/strong&gt;, consisting of a list of directories, which it searches sequentially when trying to load a module.</source>
          <target state="translated">インタラクティブモードでは、コードサーバーは、ディレクトリのリストで構成される、通常は&lt;strong&gt;コードパス&lt;/strong&gt;と呼ばれる検索パスを維持します。このリストは、モジュールをロードするときに順次検索されます。</target>
        </trans-unit>
        <trans-unit id="1430b49bd146817f97ef7d06df225a493f066b2a" translate="yes" xml:space="preserve">
          <source>In interactive mode, which is default, only some code is loaded during system startup, basically the modules needed by the runtime system. Other code is dynamically loaded when first referenced. When a call to a function in a certain module is made, and the module is not loaded, the code server searches for and tries to load the module.</source>
          <target state="translated">デフォルトの対話型モードでは、システム起動時に一部のコードのみがロードされ、基本的にはランタイムシステムが必要とするモジュールがロードされます。その他のコードは、最初に参照されたときに動的にロードされます。特定のモジュール内の関数への呼び出しが行われ、そのモジュールがロードされない場合、コードサーバはそのモジュールを検索してロードしようとします。</target>
        </trans-unit>
        <trans-unit id="1a03bca7ddee9e30128d1091183803f61a0b8991" translate="yes" xml:space="preserve">
          <source>In its simplest forms, the &lt;code&gt;match_spec&lt;/code&gt; look as follows:</source>
          <target state="translated">最も単純な形式では、 &lt;code&gt;match_spec&lt;/code&gt; は次のようになります。</target>
        </trans-unit>
        <trans-unit id="7ce538d7f4c53ffc660905f0d2354601ebec0177" translate="yes" xml:space="preserve">
          <source>In local mode, code is interpreted only at the current node. In global mode, code is interpreted at all known nodes. Processes at other nodes executing interpreted code are automatically displayed in the Monitor window and can be attached to like any other debugged process.</source>
          <target state="translated">ローカルモードでは、コードは現在のノードでのみ解釈されます。グローバルモードでは、既知のすべてのノードでコードが解釈されます。解釈されたコードを実行している他のノードのプロセスは、自動的に Monitor ウィンドウに表示され、他のデバッグされたプロセスと同様にアタッチすることができます。</target>
        </trans-unit>
        <trans-unit id="67bf06325d8975b88277745da18879c2a83cda5c" translate="yes" xml:space="preserve">
          <source>In low-memory systems (especially without virtual memory), setting the value to &lt;code&gt;0&lt;/code&gt; can help to conserve memory.</source>
          <target state="translated">メモリが少ないシステム（特に仮想メモリがないシステム）では、値を &lt;code&gt;0&lt;/code&gt; に設定するとメモリを節約できます。</target>
        </trans-unit>
        <trans-unit id="aff1ae241ba5a53367c964ba35e7d8b8a0df1b6b" translate="yes" xml:space="preserve">
          <source>In many applications, the overhead of processing a transaction can result in a loss of performance. Dirty operation are short cuts that bypass much of the processing and increase the speed of the transaction.</source>
          <target state="translated">多くのアプリケーションでは、トランザクション処理のオーバーヘッドにより、パフォーマンスが低下することがあります。ダーティオペレーションとは、処理の多くをバイパスしてトランザクションの速度を向上させるショートカットです。</target>
        </trans-unit>
        <trans-unit id="dd0e2f590c5adecb73ed1090aefb1bdd2efeb4bf" translate="yes" xml:space="preserve">
          <source>In many systems, transient states of overloaded queues are normal. Although this function returns &lt;code&gt;false&lt;/code&gt; does not mean that the other node is guaranteed to be non-responsive, it could be a temporary overload. Also, a return value of &lt;code&gt;true&lt;/code&gt; does only mean that the message can be sent on the (TCP) channel without blocking; the message is not guaranteed to arrive at the remote node. For a disconnected non-responsive node, the return value is &lt;code&gt;true&lt;/code&gt; (mimics the behavior of operator &lt;code&gt;!&lt;/code&gt;). The expected behavior and the actions to take when the function returns &lt;code&gt;false&lt;/code&gt; are application- and hardware-specific.</source>
          <target state="translated">多くのシステムでは、過負荷のキューの一時的な状態は正常です。この関数が &lt;code&gt;false&lt;/code&gt; を返すことは、他のノードが応答しないことが保証されていることを意味するものではありませんが、一時的な過負荷である可能性があります。また、 &lt;code&gt;true&lt;/code&gt; の戻り値は、メッセージをブロックせずに（TCP）チャネルで送信できることを意味するだけです。メッセージがリモートノードに到着することは保証されていません。切断された非応答ノードの場合、戻り値は &lt;code&gt;true&lt;/code&gt; です（演算子 &lt;code&gt;!&lt;/code&gt; の動作を模倣しています）。期待される動作と、関数が &lt;code&gt;false&lt;/code&gt; を返したときに実行するアクションは、アプリケーションおよびハードウェアによって異なります。</target>
        </trans-unit>
        <trans-unit id="e52c3f887ab093e6f06a26dfc4388cf3cf2eeed6" translate="yes" xml:space="preserve">
          <source>In matching, this default value is only valid for the last element. All other bit string or binary elements in the matching must have a size specification.</source>
          <target state="translated">マッチングでは、このデフォルト値は最後の要素に対してのみ有効です。マッチングの他のすべてのビット文字列またはバイナリ要素は、サイズ指定が必要です。</target>
        </trans-unit>
        <trans-unit id="0ea9b87be6bd6a217fdf52f85ea3b695fde92834" translate="yes" xml:space="preserve">
          <source>In microseconds</source>
          <target state="translated">マイクロ秒で</target>
        </trans-unit>
        <trans-unit id="e9f9c5ec8a0a2225edde7d56a03b4792532c31fc" translate="yes" xml:space="preserve">
          <source>In mode &lt;code&gt;verify_none&lt;/code&gt; the default behavior is to allow all x509-path validation errors. See also option &lt;code&gt;verify_fun&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;verify_none&lt;/code&gt; モードでは、デフォルトの動作は、すべてのx509パス検証エラーを許可することです。オプション &lt;code&gt;verify_fun&lt;/code&gt; も参照してください。</target>
        </trans-unit>
        <trans-unit id="adc9bd54e329d8564e9dd0fe90f0559b96ad7e59" translate="yes" xml:space="preserve">
          <source>In more technical terms, &lt;code&gt;erlang:hibernate/3&lt;/code&gt; discards the call stack for the process, and then garbage collects the process. After this, all live data is in one continuous heap. The heap is then shrunken to the exact same size as the live data that it holds (even if that size is less than the minimum heap size for the process).</source>
          <target state="translated">より専門的な用語では、 &lt;code&gt;erlang:hibernate/3&lt;/code&gt; はプロセスのコールスタックを破棄し、その後、ガベージコレクションによってプロセスを収集します。この後、すべてのライブデータは1つの連続したヒープに格納されます。ヒープは、保持しているライブデータとまったく同じサイズに縮小されます（そのサイズがプロセスの最小ヒープサイズよりも小さい場合でも）。</target>
        </trans-unit>
        <trans-unit id="7eeb2170c3262e24c6e629309332632b0551f1eb" translate="yes" xml:space="preserve">
          <source>In most API functions where you can use this address family the port number must be &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">このアドレスファミリを使用できるほとんどのAPI関数では、ポート番号は &lt;code&gt;0&lt;/code&gt; でなければなりません。</target>
        </trans-unit>
        <trans-unit id="96533e214a0da4a7dc13f9539128fcec0a90372f" translate="yes" xml:space="preserve">
          <source>In most cases, the &lt;code&gt;RootDir&lt;/code&gt; parameter should be set to the same as the &lt;code&gt;root_dir&lt;/code&gt; configuration parameter used in the call to &lt;code&gt;reltool:get_target_spec/1&lt;/code&gt; (or &lt;code&gt;code:root_dir()&lt;/code&gt; if the configuration parameter is not set). In some cases it might be useful to evaluate the same target specification towards different root directories. This should, however, be used with great care as it requires equivalent file structures under all roots.</source>
          <target state="translated">ほとんどの場合、 &lt;code&gt;RootDir&lt;/code&gt; パラメーターは、 &lt;code&gt;reltool:get_target_spec/1&lt;/code&gt; （または設定パラメーターが設定されていない場合は &lt;code&gt;code:root_dir()&lt;/code&gt; )の呼び出しで使用される &lt;code&gt;root_dir&lt;/code&gt; 設定パラメーターと同じに設定する必要があります。場合によっては、同じターゲット仕様を異なるルートディレクトリに対して評価することが役立つことがあります。ただし、すべてのルートで同等のファイル構造が必要になるため、注意して使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="e5e6c46f0b948281f508f56232b244f2c0be68d3" translate="yes" xml:space="preserve">
          <source>In normal mode keystrokes from the user are collected and interpreted by &lt;code&gt;tty&lt;/code&gt;. Most of the &lt;strong&gt;Emacs&lt;/strong&gt; line-editing commands are supported. The following is a complete list of the supported line-editing commands.</source>
          <target state="translated">通常モードでは、ユーザーからのキーストロークが収集され、 &lt;code&gt;tty&lt;/code&gt; によって解釈されます。ほとんどの&lt;strong&gt;Emacs&lt;/strong&gt;行編集コマンドがサポートされています。以下は、サポートされている行編集コマンドの完全なリストです。</target>
        </trans-unit>
        <trans-unit id="1b91ce563204e764cc3b634a1e770a9c50a8ab66" translate="yes" xml:space="preserve">
          <source>In normal operation, the &lt;code&gt;et:trace_me/4,5&lt;/code&gt; calls are almost for free. When tracing is needed, you can either activate tracing on these functions explicitly. Or you can combine the usage of &lt;code&gt;trace_global&lt;/code&gt; with the usage of &lt;code&gt;trace_pattern&lt;/code&gt;. When set, the &lt;code&gt;trace_pattern&lt;/code&gt; will automatically be activated on all connected nodes.</source>
          <target state="translated">通常の操作では、 &lt;code&gt;et:trace_me/4,5&lt;/code&gt; の呼び出しはほぼ無料です。トレースが必要な場合は、これらの関数のトレースを明示的にアクティブにすることができます。それともの使い方組み合わせることができ &lt;code&gt;trace_global&lt;/code&gt; をの使用に &lt;code&gt;trace_pattern&lt;/code&gt; 。設定すると、接続されているすべてのノードで &lt;code&gt;trace_pattern&lt;/code&gt; が自動的にアクティブになります。</target>
        </trans-unit>
        <trans-unit id="01f7caa16342ff7be996c443808331cb189b3fd2" translate="yes" xml:space="preserve">
          <source>In order for an implementation to make full use of the enhanced SNMPv2 error codes, it is essential that the instrumentation functions always return SNMPv2 error codes, in case of error. These are translated into the corresponding SNMPv1 error codes by the agent, if necessary.</source>
          <target state="translated">強化されたSNMPv2エラーコードをフルに活用するためには、エラーが発生した場合、計測機能が常にSNMPv2エラーコードを返すことが不可欠です。これらのエラーコードは、必要に応じてエージェントによって対応するSNMPv1エラーコードに変換されます。</target>
        </trans-unit>
        <trans-unit id="5554904f6399d518ff690b91bb8e000b4bc410eb" translate="yes" xml:space="preserve">
          <source>In order for the Erlang driver thread API to function, thread support must be enabled in the runtime system. An Erlang driver can check if thread support is enabled by use of &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt;driver_system_info&lt;/a&gt;&lt;/code&gt;. Notice that some functions in the Erlang driver API are thread-safe only when the runtime system has SMP support, also this information can be retrieved through &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt;driver_system_info&lt;/a&gt;&lt;/code&gt;. Also notice that many functions in the Erlang driver API are &lt;strong&gt;not&lt;/strong&gt; thread-safe, regardless of whether SMP support is enabled or not. If a function is not documented as thread-safe, it is &lt;strong&gt;not&lt;/strong&gt; thread-safe.</source>
          <target state="translated">ErlangドライバーのスレッドAPIを機能させるには、ランタイムシステムでスレッドサポートを有効にする必要があります。 Erlangドライバーは、 &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt;driver_system_info&lt;/a&gt;&lt;/code&gt; を使用してスレッドサポートが有効になっているかどうかを確認できます。 ErlangドライバーAPIの一部の関数は、ランタイムシステムがSMPをサポートしている場合にのみスレッドセーフになることに注意して &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt;driver_system_info&lt;/a&gt;&lt;/code&gt; 。また、この情報はdriver_system_infoを介して取得できます。また、SMPサポートが有効になっているかどうかに関係なく、ErlangドライバAPIの多くの関数&lt;strong&gt;は&lt;/strong&gt;スレッドセーフでは&lt;strong&gt;ない&lt;/strong&gt;ことに注意してください。関数がスレッドセーフとして文書化されていない場合、その関数はスレッドセーフではあり&lt;strong&gt;ません&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="652d6f0f7f2fd0f26e6c7835ec2944249c814b15" translate="yes" xml:space="preserve">
          <source>In order for the break/continue functionality to work, &lt;code&gt;Common Test&lt;/code&gt; must release the shell process controlling &lt;code&gt;stdin&lt;/code&gt;. This is done by setting start option &lt;code&gt;release_shell&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;. For details, see section &lt;code&gt;&lt;a href=&quot;run_test_chapter#erlang_shell_or_program&quot;&gt;Running Tests from the Erlang Shell or from an Erlang Program&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">ブレーク/継続機能が機能するためには、 &lt;code&gt;Common Test&lt;/code&gt; が &lt;code&gt;stdin&lt;/code&gt; を制御するシェルプロセスを解放する必要があります。これは、起動オプション &lt;code&gt;release_shell&lt;/code&gt; を &lt;code&gt;true&lt;/code&gt; に設定することによって行われます。詳細については、ユーザーガイドの「 &lt;code&gt;&lt;a href=&quot;run_test_chapter#erlang_shell_or_program&quot;&gt;Running Tests from the Erlang Shell or from an Erlang Program&lt;/a&gt;&lt;/code&gt; 」を参照してください。</target>
        </trans-unit>
        <trans-unit id="78380f5cb098afa599c64e0ffb0ba494ac35ede5" translate="yes" xml:space="preserve">
          <source>In order for the runtime system to be able to bind schedulers, the CPU topology must be known. If the runtime system fails to detect the CPU topology automatically, it can be defined. For more information on how to define the CPU topology, see command-line flag &lt;code&gt;+sct&lt;/code&gt; in &lt;code&gt;erl(1)&lt;/code&gt;.</source>
          <target state="translated">ランタイムシステムがスケジューラをバインドできるようにするには、CPUトポロジがわかっている必要があります。ランタイムシステムがCPUトポロジを自動的に検出できない場合は、それを定義できます。CPUトポロジを定義する方法の詳細については、 &lt;code&gt;erl(1)&lt;/code&gt; のコマンドラインフラグ &lt;code&gt;+sct&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="dca7b006090165b7c3c9be08fcb7f845ac2dfef6" translate="yes" xml:space="preserve">
          <source>In order for this to work properly, the user must ensure that the following two requirements are satisfied:</source>
          <target state="translated">これを正常に動作させるためには、以下の2つの要件を満たしていることを確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="cc5fcbbc4da3a883acc2844e1722d4a3096e07d7" translate="yes" xml:space="preserve">
          <source>In order to append this data to the end of the motorcycles.xml document you have to parse the file and add Data to the end of the root element content.</source>
          <target state="translated">このデータをmotorcycles.xmlドキュメントの最後に追加するには、ファイルを解析し、ルート要素のコンテンツの最後にDataを追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="e98a8e7d2e52da6dad36a29e2bdfa8a3172fe51b" translate="yes" xml:space="preserve">
          <source>In order to compile Erlang code, a small Erlang bootstrap system has to be built, or an Erlang/OTP system of the same release as the one being built has to be provided in the &lt;code&gt;$PATH&lt;/code&gt;. The Erlang/OTP for the target system will be built using this Erlang system, together with the cross compilation tools provided.</source>
          <target state="translated">Erlangコードをコンパイルするには、小さなErlangブートストラップシステムを構築するか、構築中のリリースと同じリリースのErlang / OTPシステムを &lt;code&gt;$PATH&lt;/code&gt; 提供する必要があります。ターゲットシステムのErlang / OTPは、このErlangシステムと、提供されているクロスコンパイルツールを使用して構築されます。</target>
        </trans-unit>
        <trans-unit id="15ce32715d8736617da44b2f7221256f14487b54" translate="yes" xml:space="preserve">
          <source>In order to fully understand the internal form you must get hold on a ASN.1 specification for the Megaco/H.248 protocol, and apply the rules above. Please, see the documentation of the ASN.1 compiler in Erlang/OTP for more details of the semantics in mapping between ASN.1 and the corresponding internal form.</source>
          <target state="translated">内部フォームを完全に理解するためには、Megaco/H.248プロトコルのASN.1仕様を手に入れて、上記のルールを適用する必要があります。ASN.1と対応する内部形式のマッピングのセマンティクスの詳細については、Erlang/OTPのASN.1コンパイラのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="ea6d5c582d5491e2165d48386242957c6fe3d344" translate="yes" xml:space="preserve">
          <source>In order to further simplify the tracing, you can make use of the &lt;code&gt;et:trace_me/4,5&lt;/code&gt; functions. These functions are intended to be invoked from other applications when there are interesting &lt;code&gt;Events&lt;/code&gt;, in your application that needs to be highlighted. The functions are extremely light weight as they do nothing besides returning an atom. These functions are specifically designed to be traced for. As the caller explicitly provides the values for the &lt;code&gt;Event Record&lt;/code&gt; fields, the default &lt;code&gt;Collector Filter&lt;/code&gt; is able to automatically provide a customized &lt;code&gt;Event Record&lt;/code&gt; without any user defined filter functions.</source>
          <target state="translated">トレースをさらに簡略化するために、 &lt;code&gt;et:trace_me/4,5&lt;/code&gt; 関数を使用できます。これらの関数は、アプリケーションで強調表示する必要のある興味深い &lt;code&gt;Events&lt;/code&gt; があるときに、他のアプリケーションから呼び出されることを目的としています。これらの関数は、アトムを返す以外に何もしないため、非常に軽量です。これらの関数は、トレースするように特別に設計されています。呼び出し元が &lt;code&gt;Event Record&lt;/code&gt; フィールドの値を明示的に提供するため、デフォルトの &lt;code&gt;Collector Filter&lt;/code&gt; は、ユーザー定義のフィルター関数なしで、カスタマイズされた &lt;code&gt;Event Record&lt;/code&gt; を自動的に提供できます。</target>
        </trans-unit>
        <trans-unit id="d79e2feac48e88d730a559bbb82e697ebe900339" translate="yes" xml:space="preserve">
          <source>In order to make Xref easy to use, there are predefined analyses that perform some common tasks. Typically, a module or a release can be checked for calls to undefined functions. For the somewhat more advanced user there is a small, but rather flexible, language that can be used for selecting parts of the analyzed system and for doing some simple graph analyses on selected calls.</source>
          <target state="translated">Xrefを使いやすくするために、いくつかの一般的なタスクを実行する定義済みの解析があります。一般的に、モジュールやリリースは未定義の関数の呼び出しをチェックすることができます。やや上級者向けには、分析されたシステムの一部を選択したり、選択された呼び出しに対して簡単なグラフ分析を行うために使用できる、小さな、しかし柔軟性のある言語があります。</target>
        </trans-unit>
        <trans-unit id="28832355c97c24952004ab393607d4cf79bc0d06" translate="yes" xml:space="preserve">
          <source>In order to prepare the MG for the sending of the initial message, hopefully a Service Change Request, the following needs to be done:</source>
          <target state="translated">初期メッセージ(できればサービス変更要求)の送信に備えてMGを準備するためには、以下のことを行う必要があります。</target>
        </trans-unit>
        <trans-unit id="420729e1fc23e88c8dd82e270ff2157af4611c2e" translate="yes" xml:space="preserve">
          <source>In order to prepare the MGC for the reception of the initial message, hopefully a Service Change Request, the following needs to be done:</source>
          <target state="translated">最初のメッセージ(できればサービス変更要求)を受信できるように準備するためには、以下のことを行う必要があります。</target>
        </trans-unit>
        <trans-unit id="07f515d2f2923cfaf0efd016e9309bd6ce7894d3" translate="yes" xml:space="preserve">
          <source>In order to provide a solution for scalable implementations of MG's and MGC's, a user may be distributed over several Erlang nodes. One of the Erlang nodes is connected to the physical network interface, but messages may be sent from other nodes and the replies are automatically forwarded back to the originating node.</source>
          <target state="translated">MGとMGCのスケーラブルな実装のためのソリューションを提供するために、ユーザは複数のErlangノードに分散されているかもしれません。Erlangノードの1つは物理ネットワークインターフェースに接続されていますが、他のノードからメッセージが送信され、返信は自動的に送信元のノードに転送されます。</target>
        </trans-unit>
        <trans-unit id="9731fa13e74c2eca121fa5f3f64dcc4b8aa04753" translate="yes" xml:space="preserve">
          <source>In order to see the nitty gritty details of an &lt;code&gt;Event&lt;/code&gt; you may click on the &lt;code&gt;Event&lt;/code&gt; in order to start a &lt;code&gt;Contents Viewer&lt;/code&gt; for that &lt;code&gt;Event&lt;/code&gt;. In the &lt;code&gt;Contents Viewer&lt;/code&gt; there also is a filter menu that enables inspection of the &lt;code&gt;Event&lt;/code&gt; from other views than the one selected in the viewer. A click on the &lt;code&gt;new_tid&lt;/code&gt;&lt;code&gt;Event&lt;/code&gt; will cause a &lt;code&gt;Contents Viewer&lt;/code&gt; window to pop up, showing the &lt;code&gt;Event&lt;/code&gt; in the &lt;code&gt;mgr_actors&lt;/code&gt; view:</source>
          <target state="translated">核心の詳細を参照するために &lt;code&gt;Event&lt;/code&gt; あなたはをクリックして &lt;code&gt;Event&lt;/code&gt; 開始するために &lt;code&gt;Contents Viewer&lt;/code&gt; そのための &lt;code&gt;Event&lt;/code&gt; 。では &lt;code&gt;Contents Viewer&lt;/code&gt; そこも検査可能フィルタ]メニューで &lt;code&gt;Event&lt;/code&gt; ビューアで選択されたもの以外のビューから。 &lt;code&gt;new_tid&lt;/code&gt; &lt;code&gt;Event&lt;/code&gt; をクリックすると、 &lt;code&gt;Contents Viewer&lt;/code&gt; ウィンドウがポップアップし、 &lt;code&gt;mgr_actors&lt;/code&gt; ビューに &lt;code&gt;Event&lt;/code&gt; が表示されます。</target>
        </trans-unit>
        <trans-unit id="89bee7955a9d3e10a16eb24de0ff7542bf8f388b" translate="yes" xml:space="preserve">
          <source>In order to use the Tags system a file named &lt;code&gt;TAGS&lt;/code&gt; must be created. The file can be seen as a database over all functions, records, and macros in all files in the project. The &lt;code&gt;TAGS&lt;/code&gt; file can be created using two different methods for Erlang. The first is the standard Emacs utility &quot;etags&quot;, the second is by using the Erlang module &lt;code&gt;tags&lt;/code&gt;.</source>
          <target state="translated">タグシステムを使用するには、 &lt;code&gt;TAGS&lt;/code&gt; という名前のファイルを作成する必要があります。ファイルは、プロジェクト内のすべてのファイルのすべての関数、レコード、およびマクロのデータベースとして見ることができます。 &lt;code&gt;TAGS&lt;/code&gt; のファイルには、Erlangのための2つの異なる方法を使用して作成することができます。1つ目は標準のEmacsユーティリティ「etags」で、2つ目はErlangモジュール &lt;code&gt;tags&lt;/code&gt; を使用する方法です。</target>
        </trans-unit>
        <trans-unit id="87d5585c6ba89972afd1216748dd8d8d098d28d5" translate="yes" xml:space="preserve">
          <source>In our measurements we have seen that there are no significant differences in message sizes between ASN.1 BER and the compact text format. Some care should be taken when using the pretty text style (which is used in all the examples included in the protocol specification and preferred during debugging sessions) since the messages can then be quite large. If the message size really is a serious issue, our per encoder should be used, as the ASN.1 PER format is much more compact than all the other alternatives. Its major drawback is that it is has not been approved as a valid Megaco/H.248 message encoding.</source>
          <target state="translated">我々の測定では、ASN.1 BERとコンパクトテキスト形式の間でメッセージサイズに有意な差はないことがわかりました。メッセージが非常に大きくなる可能性があるので、きれいなテキストスタイル(プロトコル仕様に含まれるすべての例で使用されており、デバッグセッションで好まれています)を使用する際には、いくつかの注意を払う必要があります。メッセージサイズが本当に深刻な問題であれば、ASN.1 PER フォーマットは他のすべての選択肢よりもはるかにコンパクトなので、エンコーダごとのフォーマットを使用するべきです。最大の欠点は、有効な Megaco/H.248 メッセージ・エンコーディングとして承認されていないことです。</target>
        </trans-unit>
        <trans-unit id="65532138e2b3ba308191e4f5508353fb9debf75b" translate="yes" xml:space="preserve">
          <source>In practice, object sets are usually declared to be extensible so that more objects can be added to the set later. Extensibility is indicated as follows:</source>
          <target state="translated">実際には、オブジェクトセットは通常、拡張可能であると宣言されているので、後からより多くのオブジェクトをセットに追加することができます。拡張性は以下のように示されます。</target>
        </trans-unit>
        <trans-unit id="ce95e8a49f6cc63c7488544f7b729b9f298807b1" translate="yes" xml:space="preserve">
          <source>In previous versions of &lt;code&gt;file&lt;/code&gt;, modes were specified as one of the atoms &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt;, or &lt;code&gt;read_write&lt;/code&gt; instead of a list. This is still allowed for reasons of backwards compatibility, but is not to be used for new code. Also note that &lt;code&gt;read_write&lt;/code&gt; is not allowed in a mode list.</source>
          <target state="translated">以前のバージョンの &lt;code&gt;file&lt;/code&gt; では、モードはリストではなく、アトム &lt;code&gt;read&lt;/code&gt; 、 &lt;code&gt;write&lt;/code&gt; 、または &lt;code&gt;read_write&lt;/code&gt; の 1つとして指定されていました。これは、下位互換性の理由で引き続き許可されていますが、新しいコードには使用できません。また、 &lt;code&gt;read_write&lt;/code&gt; はモードリストでは使用できないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="f79c7cf33fb3cea437947f151dd1585b263646aa" translate="yes" xml:space="preserve">
          <source>In principle, this function calls the &lt;code&gt;process_received_message/4&lt;/code&gt; function via a &lt;code&gt;spawn&lt;/code&gt; to perform the actual processing.</source>
          <target state="translated">原則として、この関数は &lt;code&gt;spawn&lt;/code&gt; を介して &lt;code&gt;process_received_message/4&lt;/code&gt; 関数を呼び出し、実際の処理を実行します。</target>
        </trans-unit>
        <trans-unit id="c1b13e4d52a1141022b35db2e3080247aecc4f96" translate="yes" xml:space="preserve">
          <source>In protocols that support client-initiated renegotiation, the cost of resources of such an operation is higher for the server than the client. This can act as a vector for denial of service attacks. The SSL application already takes measures to counter-act such attempts, but client-initiated renegotiation can be strictly disabled by setting this option to &lt;code&gt;false&lt;/code&gt;. The default value is &lt;code&gt;true&lt;/code&gt;. Note that disabling renegotiation can result in long-lived connections becoming unusable due to limits on the number of messages the underlying cipher suite can encipher.</source>
          <target state="translated">クライアントが開始する再ネゴシエーションをサポートするプロトコルでは、そのような操作のリソースのコストはクライアントよりサーバーの方が高くなります。これは、サービス拒否攻撃のベクターとして機能する可能性があります。SSLアプリケーションはそのような試みに対抗するための対策をすでに講じていますが、このオプションを &lt;code&gt;false&lt;/code&gt; に設定することにより、クライアントが開始した再ネゴシエーションを厳密に無効にすることができます。デフォルト値は &lt;code&gt;true&lt;/code&gt; です。再ネゴシエーションを無効にすると、基盤となる暗号スイートが暗号化できるメッセージの数が制限されるため、長期間の接続が使用できなくなる可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="6c5be2b3b8e809c554958bbec452d00bc9526f02" translate="yes" xml:space="preserve">
          <source>In rare circumstances, this function can fail on Unix. It can occur if read permission does not exist for the parent directories of the current directory.</source>
          <target state="translated">まれな状況では、この関数はUnix上で失敗することがあります。これは、カレントディレクトリの親ディレクトリの読み込み権限が存在しない場合に発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="03d64f33ab45a7b9facd9b7d6fdfa4c86a07dd26" translate="yes" xml:space="preserve">
          <source>In reality, data models are seldom fully normalized. A realistic alternative to a normalized database model would be a data model that is not even in first normal form. &lt;code&gt;Mnesia&lt;/code&gt; is suitable for applications such as telecommunications, because it is easy to organize data in a flexible manner. A &lt;code&gt;Mnesia&lt;/code&gt; database is always organized as a set of tables. Each table is filled with rows, objects, and records. What sets &lt;code&gt;Mnesia&lt;/code&gt; apart is that individual fields in a record can contain any type of compound data structures. An individual field in a record can contain lists, tuples, functions, and even record code.</source>
          <target state="translated">実際には、データモデルが完全に正規化されることはほとんどありません。正規化されたデータベースモデルの現実的な代替案は、第1正規形でさえないデータモデルです。 &lt;code&gt;Mnesia&lt;/code&gt; は、柔軟な方法でデータを整理することが容易であるため、テレコミュニケーションなどのアプリケーションに適しています。 &lt;code&gt;Mnesia&lt;/code&gt; のデータベースは常にテーブルのセットとして編成されています。各テーブルは、行、オブジェクト、およびレコードで埋められます。どのような設定 &lt;code&gt;Mnesia&lt;/code&gt; を離れては、レコードの個々のフィールドは、化合物のデータ構造のいずれかのタイプを含めることができるということです。レコードの個々のフィールドには、リスト、タプル、関数、さらにはレコードコードを含めることができます。</target>
        </trans-unit>
        <trans-unit id="6b66f371cbc8ed94f2c343e8c1182f27560a8689" translate="yes" xml:space="preserve">
          <source>In scenario 1, the test case process terminates normally after &lt;code&gt;case A&lt;/code&gt; has finished executing its test code without detecting any errors. The test case function returns a value and &lt;code&gt;Common Test&lt;/code&gt; logs the test case as successful.</source>
          <target state="translated">シナリオ1では、 &lt;code&gt;case A&lt;/code&gt; がエラーを検出せずにテストコードの実行を終了すると、テストケースプロセスは正常に終了します。テストケース関数は値を返し、 &lt;code&gt;Common Test&lt;/code&gt; はテストケースを成功としてログに記録します。</target>
        </trans-unit>
        <trans-unit id="9c8810dc35fa4f97c050123bbb12b1701dd4c349" translate="yes" xml:space="preserve">
          <source>In scenario 2, an error is detected during test &lt;code&gt;case B&lt;/code&gt; execution. This causes the test &lt;code&gt;case B&lt;/code&gt; function to generate an exception and, as a result, the test case process exits with reason other than normal. &lt;code&gt;Common Test&lt;/code&gt; logs this as an unsuccessful (Failed) test case.</source>
          <target state="translated">シナリオ2では、テスト &lt;code&gt;case B&lt;/code&gt; 実行中にエラーが検出されます。これにより、テスト &lt;code&gt;case B&lt;/code&gt; 関数が例外を生成し、その結果、テストケースプロセスが通常以外の理由で終了します。 &lt;code&gt;Common Test&lt;/code&gt; は、これを失敗した（失敗した）テストケースとして記録します。</target>
        </trans-unit>
        <trans-unit id="2b01a41bac5f590a4587dab197accc292b0c3e3d" translate="yes" xml:space="preserve">
          <source>In section about myths, the following myth was exposed: &lt;code&gt;&lt;a href=&quot;myths#tail_recursive&quot;&gt;Tail-Recursive Functions are Much Faster Than Recursive Functions&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">神話に関するセクションでは、次の神話が公開されました。 &lt;code&gt;&lt;a href=&quot;myths#tail_recursive&quot;&gt;Tail-Recursive Functions are Much Faster Than Recursive Functions&lt;/a&gt;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="b130fa00d240c9e2022bf6895671a7967856f662" translate="yes" xml:space="preserve">
          <source>In short, the &lt;code&gt;DebugType&lt;/code&gt; is intended for debugging only. Logs during production are better produced with the standard Erlang logging facilities.</source>
          <target state="translated">つまり、 &lt;code&gt;DebugType&lt;/code&gt; はデバッグのみを目的としています。生産中のログは、標準のErlangロギング機能でより適切に作成されます。</target>
        </trans-unit>
        <trans-unit id="71afdcc8f1caaa6350eb14b1d2094d34265774c1" translate="yes" xml:space="preserve">
          <source>In some applications, it can be unacceptable that replies from individual logs are ignored. An alternative in such situations is to use many local disk logs instead of one distributed disk log, and implement the distribution without use of the &lt;code&gt;disk_log&lt;/code&gt; module.</source>
          <target state="translated">一部のアプリケーションでは、個々のログからの応答が無視されることは許容できない場合があります。そのような状況での代替策は、1つの分散ディスクログの代わりに多くのローカルディスクログを使用し、 &lt;code&gt;disk_log&lt;/code&gt; モジュールを使用せずに配布を実装することです。</target>
        </trans-unit>
        <trans-unit id="3864ea2cdbd0987d0b4fb5eb5813e04593cf37fa" translate="yes" xml:space="preserve">
          <source>In some aspects the Erlang MIB compiler does not follow or implement the SMI fully. Here are the differences:</source>
          <target state="translated">Erlang MIBコンパイラはSMIを完全には実装していません。ここに違いがあります。</target>
        </trans-unit>
        <trans-unit id="c9e14d58e80ba98377364e8269565a9b4e7f56ca" translate="yes" xml:space="preserve">
          <source>In some aspects the agent does not implement SNMP fully. Here are the differences:</source>
          <target state="translated">エージェントがSNMPを完全に実装していない面もあります。ここに違いがあります。</target>
        </trans-unit>
        <trans-unit id="397a384c819c2af0e32f82dcacb93ab35d42b161" translate="yes" xml:space="preserve">
          <source>In some cases, the Erlang syntax rules make it impossible to place a metavariable directly where you would like it. For example, you cannot write:</source>
          <target state="translated">いくつかのケースでは、Erlangの構文ルールによってメタ変数を直接好きな場所に置くことができないことがあります。例えば、以下のように書くことはできません。</target>
        </trans-unit>
        <trans-unit id="c076f1de5baca283848280a649a2179b83e38d01" translate="yes" xml:space="preserve">
          <source>In some circumstances, the select/match operations do not need to scan the complete table. For example, if part of the key is bound when searching an &lt;code&gt;ordered_set&lt;/code&gt; table, or if it is a Mnesia table and there is a secondary index on the field that is selected/matched. If the key is fully bound, there is no point in doing a select/match, unless you have a bag table and are only interested in a subset of the elements with the specific key.</source>
          <target state="translated">状況によっては、選択/一致操作でテーブル全体をスキャンする必要はありません。たとえば、 &lt;code&gt;ordered_set&lt;/code&gt; テーブルの検索時にキーの一部がバインドされている場合、またはMnesiaテーブルであり、選択または一致するフィールドにセカンダリインデックスがある場合などです。キーが完全にバインドされている場合、バッグテーブルがあり、特定のキーを持つ要素のサブセットのみに関心がある場合を除いて、選択/一致を実行しても意味がありません。</target>
        </trans-unit>
        <trans-unit id="f29229d853517e42e24b621374f22a9695122f0f" translate="yes" xml:space="preserve">
          <source>In some contexts, only a string or an integer is allowed. For example, the directive &lt;code&gt;-file(Name, Line)&lt;/code&gt; requires that &lt;code&gt;Name&lt;/code&gt; is a string literal and &lt;code&gt;Line&lt;/code&gt; an integer literal:</source>
          <target state="translated">一部のコンテキストでは、文字列または整数のみが許可されています。たとえば、ディレクティブ &lt;code&gt;-file(Name, Line)&lt;/code&gt; では、 &lt;code&gt;Name&lt;/code&gt; が文字列リテラルで、 &lt;code&gt;Line&lt;/code&gt; が整数リテラルである必要があります。</target>
        </trans-unit>
        <trans-unit id="5a6b075e8a7cbcdea6adcceaf8693e0b814b7a53" translate="yes" xml:space="preserve">
          <source>In state &lt;code&gt;locked&lt;/code&gt;, when a button is pressed, it is collected with the last pressed buttons up to the length of the correct code, and compared with the correct code. Depending on the result, the door is either unlocked and the &lt;code&gt;gen_statem&lt;/code&gt; goes to state &lt;code&gt;open&lt;/code&gt;, or the door remains in state &lt;code&gt;locked&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;locked&lt;/code&gt; 状態では、ボタンが押されると、最後に押されたボタンが正しいコードの長さまで収集され、正しいコードと比較されます。結果に応じて、ドアのロックが解除され、 &lt;code&gt;gen_statem&lt;/code&gt; が &lt;code&gt;open&lt;/code&gt; た状態になるか、ドアが &lt;code&gt;locked&lt;/code&gt; れた状態のままになります。</target>
        </trans-unit>
        <trans-unit id="d9b6767bf0caff1be872c1139fc4118f63dc8ef9" translate="yes" xml:space="preserve">
          <source>In state &lt;code&gt;open&lt;/code&gt;, a button event is ignored by staying in the same state. This can also be done by returning &lt;code&gt;{keep_state, Data}&lt;/code&gt; or in this case since &lt;code&gt;Data&lt;/code&gt; unchanged even by returning &lt;code&gt;keep_state_and_data&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;open&lt;/code&gt; 状態では、ボタンイベントは同じ状態に留まることで無視されます。これは &lt;code&gt;{keep_state, Data}&lt;/code&gt; 返すことによっても行うことができます。この場合、 &lt;code&gt;keep_state_and_data&lt;/code&gt; を返しても &lt;code&gt;Data&lt;/code&gt; は変更されないためです。</target>
        </trans-unit>
        <trans-unit id="1bdfbdd981c77f7212c651d17f2cefab1fd90c79" translate="yes" xml:space="preserve">
          <source>In systems with many processes, computation tasks that run for a short time can be spawned off into a new process with a higher minimum heap size. When the process is done, it sends the result of the computation to another process and terminates. If the minimum heap size is calculated properly, the process might not have to do any garbage collections at all. &lt;strong&gt;This optimization is not to be attempted without proper measurements.&lt;/strong&gt;</source>
          <target state="translated">多くのプロセスがあるシステムでは、短時間実行される計算タスクは、最小ヒープサイズが大きい新しいプロセスに生成されます。プロセスが完了すると、計算結果を別のプロセスに送信して終了します。最小ヒープサイズが適切に計算されている場合、プロセスはガベージコレクションをまったく行う必要がない場合があります。&lt;strong&gt;この最適化は、適切な測定なしに行われるべきではありません。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5746b70053e6262729b091cf67ef85a9f8ac776b" translate="yes" xml:space="preserve">
          <source>In telecommunications applications, there are different needs from the features provided by traditional DBMSs. The applications now implemented in Erlang need a mixture of a broad range of features, which generally are not satisfied by traditional DBMSs. Mnesia is designed with requirements like the following in mind:</source>
          <target state="translated">通信アプリケーションでは、従来のDBMSが提供する機能とは異なるニーズがあります。現在Erlangで実装されているアプリケーションは、一般的に従来のDBMSでは満たされていない幅広い機能を必要としています。Mnesiaは以下のような要件を念頭に置いて設計されています。</target>
        </trans-unit>
        <trans-unit id="63011c7dfba9e10fc95124eaa2d33e3e8a0fca83" translate="yes" xml:space="preserve">
          <source>In the 32-bit implementation of Erlang, 536,870,911 bytes is the largest binary that can be constructed or matched using the bit syntax. In the 64-bit implementation, the maximum size is 2,305,843,009,213,693,951 bytes. If the limit is exceeded, bit syntax construction fails with a &lt;code&gt;system_limit&lt;/code&gt; exception, while any attempt to match a binary that is too large fails. This limit is enforced starting in R11B-4.</source>
          <target state="translated">Erlangの32ビット実装では、536,870,911バイトが、ビット構文を使用して構築または照合できる最大のバイナリです。64ビット実装では、最大サイズは2,305,843,009,213,693,951バイトです。制限を超えた場合、ビット構文の構築は &lt;code&gt;system_limit&lt;/code&gt; 例外で失敗しますが、大きすぎるバイナリを照合しようとすると失敗します。この制限はR11B-4から適用されます。</target>
        </trans-unit>
        <trans-unit id="3b10f4238d4a411f4fac664bc42d174316e288c7" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;MatchBody&lt;/code&gt; and &lt;code&gt;MatchCondition&lt;/code&gt; parts, only variables bound previously can be used.</source>
          <target state="translated">で &lt;code&gt;MatchBody&lt;/code&gt; と &lt;code&gt;MatchCondition&lt;/code&gt; 部品、以前にバインド変数のみを使用することができます。</target>
        </trans-unit>
        <trans-unit id="99f811cb87197b615b54046fe0178bf192579602" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;MatchCondition/MatchBody&lt;/code&gt; parts, no unbound variables are allowed, so &lt;code&gt;'_'&lt;/code&gt; is interpreted as itself (an atom). Variables can only be bound in the &lt;code&gt;MatchHead&lt;/code&gt; part.</source>
          <target state="translated">&lt;code&gt;MatchCondition/MatchBody&lt;/code&gt; の部品、全く結合していない変数がので、許可されない &lt;code&gt;'_'&lt;/code&gt; 自体（原子）として解釈されます。変数は、 &lt;code&gt;MatchHead&lt;/code&gt; パーツでのみバインドできます。</target>
        </trans-unit>
        <trans-unit id="41acf373b0923e27303ed2d9e613e3b6bc78210e" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;MatchCondition/MatchBody&lt;/code&gt; parts, the interpretation is in some ways different. Literals in these parts can either be written &quot;as is&quot;, which works for all literals except tuples, or by using the special form &lt;code&gt;{const, T}&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is any Erlang term.</source>
          <target state="translated">で &lt;code&gt;MatchCondition/MatchBody&lt;/code&gt; の部品、解釈はいくつかの点で異なっています。タプルを除くすべてのリテラルのために働く、これらの部品にリテラル「そのまま」のいずれかで記述することができ、または特別な形用いて &lt;code&gt;{const, T}&lt;/code&gt; 、 &lt;code&gt;T&lt;/code&gt; は任意Erlangの用語であるが。</target>
        </trans-unit>
        <trans-unit id="eb2046d2d5da3268f8e80e9b5760d8733ac6af46" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;MatchHead&lt;/code&gt; part, all literals (except the variables above) are interpreted &quot;as is&quot;.</source>
          <target state="translated">で &lt;code&gt;MatchHead&lt;/code&gt; の「そのまま」の部分（上記の変数を除く）すべてのリテラルは、解釈されます。</target>
        </trans-unit>
        <trans-unit id="ed8257c1305383c9e32994b91f6e1b51ce6d911e" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;do_perm&lt;/code&gt; we do the work, operating on the structure that was allocated in &lt;code&gt;output&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;do_perm&lt;/code&gt; では、 &lt;code&gt;output&lt;/code&gt; に割り当てられた構造を操作して作業を行います。</target>
        </trans-unit>
        <trans-unit id="6e01e7a071ebc59bede92c3c9744f0cd30d2569a" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;ets:fun2ms/1&lt;/code&gt; example above, it is needed to include &lt;code&gt;ms_transform.hrl&lt;/code&gt; in the source code, as this is what triggers the parse transformation of the &lt;code&gt;ets:fun2ms/1&lt;/code&gt; call to a valid match specification. This also implies that the transformation is done at compile time (except when called from the shell) and therefore takes no resources in runtime. That is, although you use the more intuitive fun syntax, it gets as efficient in runtime as writing match specifications by hand.</source>
          <target state="translated">上記の &lt;code&gt;ets:fun2ms/1&lt;/code&gt; の例では、有効な一致指定への &lt;code&gt;ets:fun2ms/1&lt;/code&gt; 呼び出しの解析変換をトリガーするものであるため、ソースコードに &lt;code&gt;ms_transform.hrl&lt;/code&gt; を含める必要があります。これは、変換がコンパイル時に行われ（シェルから呼び出された場合を除く）、実行時にリソースを消費しないことも意味します。つまり、より直感的な楽しい構文を使用しますが、ランタイムでマッチ仕様を手動で作成するのと同じくらい効率的になります。</target>
        </trans-unit>
        <trans-unit id="11d9a975fdf9d1a5bae2119da6072d890e6e6ea9" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;main&lt;/code&gt; function, the C program is to listen for a message from Erlang and, according to the selected encoding/decoding scheme, use the first byte to determine which function to call and the second byte as argument to the function. The result of calling the function is then to be sent back to Erlang:</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; 関数、Cプログラムはアーランからのメッセージをリッスンし、選択された符号化/復号化スキームによれば、関数の引数として呼び出すために機能するかを決定するための最初のバイトと第二のバイトを使用することです。次に、関数を呼び出した結果がErlangに送り返されます。</target>
        </trans-unit>
        <trans-unit id="925920f982694555a077da19c74dabd56f931884" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;ready_async&lt;/code&gt; function the output is sent back to the emulator. We use the driver term format instead of &lt;code&gt;ei&lt;/code&gt;. This is the only way to send Erlang terms directly to a driver, without having the Erlang code to call &lt;code&gt;binary_to_term/1&lt;/code&gt;. In the simple example this works well, and we do not need to use &lt;code&gt;ei&lt;/code&gt; to handle the binary term format.</source>
          <target state="translated">で &lt;code&gt;ready_async&lt;/code&gt; 機能出力は、エミュレータに送り返されます。 &lt;code&gt;ei&lt;/code&gt; の代わりにドライバー用語形式を使用します。これは、Erlangコードが &lt;code&gt;binary_to_term/1&lt;/code&gt; を呼び出すことなく、Erlang用語をドライバーに直接送信する唯一の方法です。簡単な例ではこれはうまく機能し、バイナリ用語形式を処理するために &lt;code&gt;ei&lt;/code&gt; を使用する必要はありません。</target>
        </trans-unit>
        <trans-unit id="b368b60ecb50d01986bb37bad72bc40dc4e4d86a" translate="yes" xml:space="preserve">
          <source>In the API of Megaco, a user may explicitly send action requests, but generation of transaction identifiers, the encoding and actual transport of the message to the remote user is handled automatically by the protocol engine according to the actual connection configuration. Megaco messages are not exposed in the API.</source>
          <target state="translated">MegacoのAPIでは、ユーザが明示的にアクションリクエストを送信することができますが、トランザクション識別子の生成やエンコード、リモートユーザへのメッセージの転送は、実際の接続設定に応じてプロトコルエンジンが自動的に処理します。なお、MegacoのメッセージはAPIでは公開されていません。</target>
        </trans-unit>
        <trans-unit id="298b6692a18a71c353c5cf532d8e68a0d659e314" translate="yes" xml:space="preserve">
          <source>In the Erlang Run-time System entities are only run in parallel when there are multiple schedulers. Therefore &lt;code&gt;lcnt&lt;/code&gt; will show more contention points (and thus be more useful) on systems using many schedulers on many cores.</source>
          <target state="translated">Erlangランタイムシステムのエンティティは、複数のスケジューラがある場合にのみ並列で実行されます。したがって、 &lt;code&gt;lcnt&lt;/code&gt; は、多くのコアで多くのスケジューラーを使用するシステムで、より多くの競合ポイントを表示します（したがってより有用です）。</target>
        </trans-unit>
        <trans-unit id="23d80f2c0541f925401a28d1d9dadf53dc345fcf" translate="yes" xml:space="preserve">
          <source>In the Kernel application:</source>
          <target state="translated">カーネルアプリケーションでは</target>
        </trans-unit>
        <trans-unit id="b82356bcf2624a74da6a8c951ecd46a6c4f7a6d9" translate="yes" xml:space="preserve">
          <source>In the Mnesia tables, the two key columns are stored as a tuple with two elements. Therefore, the arity of the table is 3.</source>
          <target state="translated">ムネシアのテーブルでは、2つのキーカラムは2つの要素を持つタプルとして格納されています。したがって、テーブルのアリティは3となります。</target>
        </trans-unit>
        <trans-unit id="ebfbe0fc7007783959fb235364ad702572537213" translate="yes" xml:space="preserve">
          <source>In the POSIX.2 compliant library that was included in 4.4BSD Unix, the ugly syntax [[:&amp;lt;:]] and [[:&amp;gt;:]] is used for matching &quot;start of word&quot; and &quot;end of word&quot;. PCRE treats these items as follows:</source>
          <target state="translated">4.4BSD Unixに含まれていたPOSIX.2準拠のライブラリでは、醜い構文[[：&amp;lt;：]]と[[：&amp;gt;：]]が「単語の始まり」と「単語の終わり」のマッチングに使用されます。PCREはこれらの項目を次のように扱います。</target>
        </trans-unit>
        <trans-unit id="989093a9ff881dd98b2952b19cfa00d3c661d058" translate="yes" xml:space="preserve">
          <source>In the PRF (pseud-random function) to generate keying materials in cipher suites not using PFS.</source>
          <target state="translated">PFSを使用していない暗号スイートの鍵材料を生成するためのPRF(疑似ランダム関数)において</target>
        </trans-unit>
        <trans-unit id="a4c5b7bf87ece22cd2bc2e60bd8ae9d3bd13b0c4" translate="yes" xml:space="preserve">
          <source>In the SSL application, an extra distribution module, &lt;code&gt;inet_tls_dist&lt;/code&gt;, can be used as an alternative. All distribution connections will use TLS and all participating Erlang nodes in a distributed system must use this distribution module.</source>
          <target state="translated">SSLアプリケーションでは、追加の配布モジュール &lt;code&gt;inet_tls_dist&lt;/code&gt; を代替として使用できます。すべての配布接続はTLSを使用し、分散システムに参加するすべてのErlangノードはこの配布モジュールを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="84201f881a1979b920fa1a6166421647fdc90516" translate="yes" xml:space="preserve">
          <source>In the STDLIB application:</source>
          <target state="translated">STDLIBアプリケーションでは</target>
        </trans-unit>
        <trans-unit id="52bac5408693eade80ce363b1a7a4df7f8aaf59f" translate="yes" xml:space="preserve">
          <source>In the above example, &quot;pong&quot; was first created to be able to give the identity of &quot;pong&quot; when &quot;ping&quot; was started. That is, in some way &quot;ping&quot; must be able to know the identity of &quot;pong&quot; to be able to send a message to it. Sometimes processes which need to know each other's identities are started independently of each other. Erlang thus provides a mechanism for processes to be given names so that these names can be used as identities instead of pids. This is done by using the &lt;code&gt;register&lt;/code&gt; BIF:</source>
          <target state="translated">上記の例では、「ping」が開始されたときに「pong」のアイデンティティを提供できるように「pong」が最初に作成されました。つまり、何らかの方法で &quot;ping&quot;は、メッセージを送信できるようにするために &quot;pong&quot;の身元を知っている必要があります。互いのアイデンティティを知る必要があるプロセスは、互いに独立して開始される場合があります。したがって、Erlangはプロセスに名前を付けるためのメカニズムを提供し、これらの名前をPIDの代わりにIDとして使用できるようにします。これは、 &lt;code&gt;register&lt;/code&gt; BIF を使用して行われます。</target>
        </trans-unit>
        <trans-unit id="57dd227aa1b46ca58edc64f34bfe2c72905f27d3" translate="yes" xml:space="preserve">
          <source>In the basic scenario, each user loads the driver before starting to use it and unloads the driver when done. The reference counting keeps track of processes and the number of loads by each process. This way the driver is only unloaded when no one wants it (it has no user). The driver also keeps track of ports that are opened to it. This enables delay of unloading until all ports are closed, or killing of all ports that use the driver when it is unloaded.</source>
          <target state="translated">基本シナリオでは、使用開始前に各ユーザがドライバをロードし、終了後にドライバをアンロードします。参照カウントは、プロセスと各プロセスによるロード数を追跡します。このようにして、ドライバは誰も必要としないとき(ユーザがいないとき)にのみアンロードされます。ドライバは、それに対して開かれているポートも追跡します。これにより、すべてのポートが閉じるまでアンロードを遅らせたり、ドライバがアンロードされたときにドライバを使用するすべてのポートを停止させたりすることができます。</target>
        </trans-unit>
        <trans-unit id="df529efdc563ccb1cce8f88844c159e25b52362e" translate="yes" xml:space="preserve">
          <source>In the case above the file is fetched from the same directory as all the other files in the messenger example. (*manual*).</source>
          <target state="translated">上記の場合、メッセンジャーの例では、他のすべてのファイルと同じディレクトリからファイルがフェッチされます。(*manual*)となります。</target>
        </trans-unit>
        <trans-unit id="90e65d7cbc556bc107498d3f0738eba580fff797" translate="yes" xml:space="preserve">
          <source>In the case of an upgrade, &lt;code&gt;OldVsn&lt;/code&gt; is &lt;code&gt;Vsn&lt;/code&gt;, and in the case of a downgrade, &lt;code&gt;OldVsn&lt;/code&gt; is &lt;code&gt;{down,Vsn}&lt;/code&gt;. &lt;code&gt;Vsn&lt;/code&gt; is defined by the &lt;code&gt;vsn&lt;/code&gt; attribute(s) of the old version of the callback module &lt;code&gt;Module&lt;/code&gt;. If no such attribute is defined, the version is the checksum of the BEAM file.</source>
          <target state="translated">アップグレードの場合、 &lt;code&gt;OldVsn&lt;/code&gt; は &lt;code&gt;Vsn&lt;/code&gt; であり、ダウングレードの場合、 &lt;code&gt;OldVsn&lt;/code&gt; は &lt;code&gt;{down,Vsn}&lt;/code&gt; です。 &lt;code&gt;Vsn&lt;/code&gt; は、古いバージョンのコールバックモジュール &lt;code&gt;Module&lt;/code&gt; の &lt;code&gt;vsn&lt;/code&gt; 属性によって定義されます。そのような属性が定義されていない場合、バージョンはBEAMファイルのチェックサムです。</target>
        </trans-unit>
        <trans-unit id="7d0cc696cff1dc6d55003eac20e57212616d1c53" translate="yes" xml:space="preserve">
          <source>In the case of reply, megaco will cancel the reply and information of this will be returned to the user via a call to the callback function &lt;code&gt;&lt;a href=&quot;megaco_user#trans_ack&quot;&gt;handle_trans_ack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">返信の場合、megacoは返信をキャンセルし、この情報はコールバック関数 &lt;code&gt;&lt;a href=&quot;megaco_user#trans_ack&quot;&gt;handle_trans_ack&lt;/a&gt;&lt;/code&gt; の呼び出しを介してユーザーに返されます。</target>
        </trans-unit>
        <trans-unit id="a023129e0eddda980464097d8136ae978852b44a" translate="yes" xml:space="preserve">
          <source>In the case of requests, megaco will cancel the message in much the same way as if &lt;code&gt;megaco:cancel&lt;/code&gt; had been called (after a successfull send). The information will be propagated back to the user differently depending on how the request(s) where issued: For requests issued using &lt;code&gt;&lt;a href=&quot;megaco#call&quot;&gt;megaco:call&lt;/a&gt;&lt;/code&gt;, the info will be delivered in the return value. For requests issued using &lt;code&gt;megaco:cast&lt;/code&gt; the info will be delivered via a call to the callback function &lt;code&gt;&lt;a href=&quot;megaco_user#trans_reply&quot;&gt;handle_trans_reply&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">リクエストの場合、megacoは、 &lt;code&gt;megaco:cancel&lt;/code&gt; が呼び出された場合（送信が成功した後）とほぼ同じ方法でメッセージをキャンセルします。情報は、要求が発行された方法に応じて、異なる方法でユーザーに伝播されます &lt;code&gt;&lt;a href=&quot;megaco#call&quot;&gt;megaco:call&lt;/a&gt;&lt;/code&gt; を使用して発行された要求の場合、情報は戻り値で配信されます。使用して発行された要求について &lt;code&gt;megaco:cast&lt;/code&gt; 情報は、コールバック関数の呼び出しを介して配信されます &lt;code&gt;&lt;a href=&quot;megaco_user#trans_reply&quot;&gt;handle_trans_reply&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="21b9a12bb9f423b38a3470e9cb22b9a9da365cf3" translate="yes" xml:space="preserve">
          <source>In the case when &lt;code&gt;Destination&lt;/code&gt; is &lt;code&gt;File&lt;/code&gt;, the printable megaco trace events will be printed to the file &lt;code&gt;File&lt;/code&gt; using plain &lt;code&gt;io:format/2&lt;/code&gt;.</source>
          <target state="translated">場合には &lt;code&gt;Destination&lt;/code&gt; ある &lt;code&gt;File&lt;/code&gt; 、印刷可能なMEGACOのトレースイベントをファイルに出力されます &lt;code&gt;File&lt;/code&gt; 無地使用して &lt;code&gt;io:format/2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c8cfb3597ea67b1de6cbbe1cc8f574a9fb6b0be7" translate="yes" xml:space="preserve">
          <source>In the case when &lt;code&gt;Destination&lt;/code&gt; is &lt;code&gt;io&lt;/code&gt;, the printable megaco trace events will be printed on stdout using plain &lt;code&gt;io:format/2&lt;/code&gt;.</source>
          <target state="translated">場合とき &lt;code&gt;Destination&lt;/code&gt; である &lt;code&gt;io&lt;/code&gt; 印刷可能なMEGACOトレースイベントが普通使用STDOUTに印刷され、 &lt;code&gt;io:format/2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="54c8b3e1fd01d3f8565818024d0b3a52c9cf2017" translate="yes" xml:space="preserve">
          <source>In the case when the pdu type is &lt;code&gt;report&lt;/code&gt;, &lt;code&gt;MsgData&lt;/code&gt; is either &lt;code&gt;ok&lt;/code&gt; or &lt;code&gt;{error, ReqId, Reason}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;MsgData&lt;/code&gt; タイプが &lt;code&gt;report&lt;/code&gt; の場合、MsgDataは &lt;code&gt;ok&lt;/code&gt; または &lt;code&gt;{error, ReqId, Reason}&lt;/code&gt; いずれかです。</target>
        </trans-unit>
        <trans-unit id="0ee63650ddd58f0ca509c96964f035623c7960f3" translate="yes" xml:space="preserve">
          <source>In the code fragment in the beginning of this section, appending to &lt;code&gt;Bin&lt;/code&gt; will be cheap, while appending to &lt;code&gt;Bin0&lt;/code&gt; will force the creation of a new binary and copying of the contents of &lt;code&gt;Bin0&lt;/code&gt;.</source>
          <target state="translated">このセクションの最初のコードの断片では、への追加 &lt;code&gt;Bin&lt;/code&gt; に追加しているときは、安くなります &lt;code&gt;Bin0&lt;/code&gt; 新しいバイナリの作成を強制しての内容をコピーします &lt;code&gt;Bin0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="70fe2afb28a7f768680b296f55f18eec13083414" translate="yes" xml:space="preserve">
          <source>In the cover specification file you can also specify your required level of the code coverage analysis; &lt;code&gt;details&lt;/code&gt; or &lt;code&gt;overview&lt;/code&gt;. In detailed mode, you get a coverage overview page, showing per module and total coverage percentages. You also get an HTML file printed for each module included in the analysis showing exactly what parts of the code have been executed during the test. In overview mode, only the code coverage overview page is printed.</source>
          <target state="translated">カバー仕様ファイルでは、コードカバレッジ分析の必要なレベルを指定することもできます。 &lt;code&gt;details&lt;/code&gt; または &lt;code&gt;overview&lt;/code&gt; 。詳細モードでは、カバレッジ概要ページが表示され、モジュールごとおよびカバレッジの合計パーセンテージが表示されます。また、分析に含まれる各モジュールのHTMLファイルが印刷され、テスト中にコードのどの部分が実行されたかを正確に示します。概要モードでは、コードカバレッジの概要ページのみが印刷されます。</target>
        </trans-unit>
        <trans-unit id="efa59b939ca7fccac1b4966896f1376a9f0ecc3d" translate="yes" xml:space="preserve">
          <source>In the current &lt;code&gt;Common Test&lt;/code&gt; version, the &lt;code&gt;silent_connections&lt;/code&gt; feature only works for Telnet and SSH connections. Support for other connection types can be added in future &lt;code&gt;Common Test&lt;/code&gt; versions.</source>
          <target state="translated">現在の &lt;code&gt;Common Test&lt;/code&gt; バージョンでは、 &lt;code&gt;silent_connections&lt;/code&gt; 機能はTelnetおよびSSH接続でのみ機能します。他の接続タイプのサポートは、将来の &lt;code&gt;Common Test&lt;/code&gt; バージョンで追加される可能性があります。</target>
        </trans-unit>
        <trans-unit id="3f73dc5c892d68a89b94a3b2e5ccad17a219943e" translate="yes" xml:space="preserve">
          <source>In the current implementation of the Erlang/SCTP binding, this event is internally converted into an &lt;code&gt;error&lt;/code&gt; term returned by &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv/*&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Erlang / SCTPバインディングの現在の実装では、このイベントは内部的に &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv/*&lt;/a&gt;&lt;/code&gt; によって返される &lt;code&gt;error&lt;/code&gt; 項に変換されます。</target>
        </trans-unit>
        <trans-unit id="15e2dc3213e7a3c0466f5bd2cdaed33bfcb2675a" translate="yes" xml:space="preserve">
          <source>In the current implementation, every object insert and look-up operation results in a copy of the object.</source>
          <target state="translated">現在の実装では、すべてのオブジェクトの挿入とルックアップ操作は、オブジェクトのコピーになります。</target>
        </trans-unit>
        <trans-unit id="791527ae8adb388933b027054a83b83e825d6a65" translate="yes" xml:space="preserve">
          <source>In the current version &lt;code&gt;CurVsn&lt;/code&gt; of a release, the application directory of &lt;code&gt;myapp&lt;/code&gt; is &lt;code&gt;$ROOT/lib/myapp-1.0&lt;/code&gt;. A new version &lt;code&gt;NewVsn&lt;/code&gt; is unpacked outside the release handler and the release handler is informed about this with a call as follows:</source>
          <target state="translated">リリースの現在のバージョンの &lt;code&gt;CurVsn&lt;/code&gt; では、 &lt;code&gt;myapp&lt;/code&gt; のアプリケーションディレクトリは &lt;code&gt;$ROOT/lib/myapp-1.0&lt;/code&gt; です。新しいバージョン &lt;code&gt;NewVsn&lt;/code&gt; はリリースハンドラーの外でアンパックされ、リリースハンドラーはこれを次のように呼び出して通知されます。</target>
        </trans-unit>
        <trans-unit id="126027e83a4fcabb438ac0508be585805261c9aa" translate="yes" xml:space="preserve">
          <source>In the data directory, &lt;code&gt;data_dir&lt;/code&gt;, the test module has its own files needed for the testing. The name of &lt;code&gt;data_dir&lt;/code&gt; is the the name of the test suite followed by &lt;code&gt;&quot;_data&quot;&lt;/code&gt;. For example, &lt;code&gt;&quot;some_path/foo_SUITE.beam&quot;&lt;/code&gt; has the data directory &lt;code&gt;&quot;some_path/foo_SUITE_data/&quot;&lt;/code&gt;. Use this directory for portability, that is, to avoid hardcoding directory names in your suite. As the data directory is stored in the same directory as your test suite, you can rely on its existence at runtime, even if the path to your test suite directory has changed between test suite implementation and execution.</source>
          <target state="translated">データディレクトリ &lt;code&gt;data_dir&lt;/code&gt; には、テストモジュールにテストに必要な独自のファイルがあります。名前 &lt;code&gt;data_dir&lt;/code&gt; 続くテストスイートの名前である &lt;code&gt;&quot;_data&quot;&lt;/code&gt; 。たとえば、 &lt;code&gt;&quot;some_path/foo_SUITE.beam&quot;&lt;/code&gt; にはデータディレクトリ &lt;code&gt;&quot;some_path/foo_SUITE_data/&quot;&lt;/code&gt; ます。移植性のために、つまりスイートでディレクトリ名をハードコーディングすることを避けるために、このディレクトリを使用してください。データディレクトリはテストスイートと同じディレクトリに格納されるため、テストスイートの実装と実行の間でテストスイートディレクトリへのパスが変更された場合でも、実行時にその存在に依存できます。</target>
        </trans-unit>
        <trans-unit id="1c079a4d60468994ef72384e15125e8d93afdf37" translate="yes" xml:space="preserve">
          <source>In the descriptions that follow, the form that is used to change the default value are listed.</source>
          <target state="translated">以降の説明では、デフォルト値を変更する際に使用するフォームを記載しています。</target>
        </trans-unit>
        <trans-unit id="4e06544c66c34c090ef2dd2b38c431c2b495f098" translate="yes" xml:space="preserve">
          <source>In the detailed information window for a node, any existing links and monitors between processes on the originating node and the connected node are displayed. &lt;strong&gt;Extra Info&lt;/strong&gt; can contain debug information (that is, special information written if the emulator is debug-compiled) or error information.</source>
          <target state="translated">ノードの詳細情報ウィンドウには、元のノードと接続されたノードのプロセス間の既存のリンクとモニターが表示されます。&lt;strong&gt;追加情報に&lt;/strong&gt;は、デバッグ情報（つまり、エミュレータがデバッグコンパイルされた場合に書き込まれる特別な情報）またはエラー情報を含めることができます。</target>
        </trans-unit>
        <trans-unit id="4da5bd1aa9e79875ba613d02238e60ec877667a6" translate="yes" xml:space="preserve">
          <source>In the event manager, zero, one, or many &lt;strong&gt;event handlers&lt;/strong&gt; are installed. When the event manager is notified about an event, the event is processed by all the installed event handlers. For example, an event manager for handling errors can by default have a handler installed, which writes error messages to the terminal. If the error messages during a certain period is to be saved to a file as well, the user adds another event handler that does this. When logging to the file is no longer necessary, this event handler is deleted.</source>
          <target state="translated">イベントマネージャには、0個、1個、または多数の&lt;strong&gt;イベントハンドラ&lt;/strong&gt;がインストールされています。イベントマネージャにイベントが通知されると、インストールされているすべてのイベントハンドラによってイベントが処理されます。たとえば、エラーを処理するためのイベントマネージャには、デフォルトで、エラーメッセージを端末に書き込むハンドラをインストールできます。特定の期間のエラーメッセージもファイルに保存する場合、ユーザーはこれを行う別のイベントハンドラーを追加します。ファイルへのログ記録が不要になると、このイベントハンドラーは削除されます。</target>
        </trans-unit>
        <trans-unit id="053d93ad21874bd7646e0f9e5ec91996c0b105b7" translate="yes" xml:space="preserve">
          <source>In the example above, valid &lt;code&gt;keys&lt;/code&gt; could be &lt;code&gt;{&quot;hi&quot;, &quot;mom&quot;}&lt;/code&gt; and &lt;code&gt;{&quot;no&quot;, &quot;thanks&quot;}&lt;/code&gt;, whereas &lt;code&gt;&quot;hi&quot;&lt;/code&gt;, &lt;code&gt;{&quot;hi&quot;, 42}&lt;/code&gt; and &lt;code&gt;{&quot;hello&quot;, &quot;there&quot;}&lt;/code&gt; would be invalid.</source>
          <target state="translated">上記の例では、有効な &lt;code&gt;keys&lt;/code&gt; は &lt;code&gt;{&quot;hi&quot;, &quot;mom&quot;}&lt;/code&gt; および &lt;code&gt;{&quot;no&quot;, &quot;thanks&quot;}&lt;/code&gt; が、 &lt;code&gt;&quot;hi&quot;&lt;/code&gt; 、 &lt;code&gt;{&quot;hi&quot;, 42}&lt;/code&gt; および &lt;code&gt;{&quot;hello&quot;, &quot;there&quot;}&lt;/code&gt; は無効になります。</target>
        </trans-unit>
        <trans-unit id="2fc7b559b47ea8932c9a1025d16c15176231ffae" translate="yes" xml:space="preserve">
          <source>In the example below, lines number 2,4,6,8 and 11 are executable lines:</source>
          <target state="translated">以下の例では、2,4,6,8,11行目が実行可能な行となっています。</target>
        </trans-unit>
        <trans-unit id="194d855c8237df6928638ceec954bb4deb7ecf5b" translate="yes" xml:space="preserve">
          <source>In the example in the previous section, &lt;code&gt;gen_server&lt;/code&gt; is started by calling &lt;code&gt;ch3:start_link()&lt;/code&gt;:</source>
          <target state="translated">前のセクションの例では、 &lt;code&gt;gen_server&lt;/code&gt; は &lt;code&gt;ch3:start_link()&lt;/code&gt; を呼び出すことによって開始されます。</target>
        </trans-unit>
        <trans-unit id="b9a0b9dbd81dc16f4bbd6ea7b8db17b1ce28ef5b" translate="yes" xml:space="preserve">
          <source>In the example in the previous section, &lt;code&gt;gen_statem&lt;/code&gt; is started by calling &lt;code&gt;code_lock:start_link(Code)&lt;/code&gt;:</source>
          <target state="translated">前のセクションの例では、 &lt;code&gt;gen_statem&lt;/code&gt; は &lt;code&gt;code_lock:start_link(Code)&lt;/code&gt; を呼び出すことによって開始されます。</target>
        </trans-unit>
        <trans-unit id="4b4a36b06eda88b8723feb14b4b4c62ed1f4fdaf" translate="yes" xml:space="preserve">
          <source>In the example the Presented IDs are &lt;code&gt;example.com&lt;/code&gt; as well as hostnames matching &lt;code&gt;*.example.com&lt;/code&gt;. For example &lt;code&gt;foo.example.com&lt;/code&gt; and &lt;code&gt;bar.example.com&lt;/code&gt; both matches but not &lt;code&gt;foo.bar.example.com&lt;/code&gt;. The name &lt;code&gt;erlang.org&lt;/code&gt; matches neither since it is not a CN.</source>
          <target state="translated">この例では、提示されたIDは &lt;code&gt;example.com&lt;/code&gt; であり、ホスト名は &lt;code&gt;*.example.com&lt;/code&gt; に一致しています。たとえば、 &lt;code&gt;foo.example.com&lt;/code&gt; と &lt;code&gt;bar.example.com&lt;/code&gt; はどちらも一致しますが、foo.bar.example.comは一致しませ &lt;code&gt;foo.bar.example.com&lt;/code&gt; 。 &lt;code&gt;erlang.org&lt;/code&gt; という名前はCNではないため、どちらにも一致しません。</target>
        </trans-unit>
        <trans-unit id="7bfbaeffabf4dcd6ae7bae0878c51517112f0368" translate="yes" xml:space="preserve">
          <source>In the example, &lt;code&gt;handle_debug&lt;/code&gt; is called for each incoming and outgoing message. The format function &lt;code&gt;Func&lt;/code&gt; is the function &lt;code&gt;ch4:write_debug/3&lt;/code&gt;, which prints the message using &lt;code&gt;io:format/3&lt;/code&gt;.</source>
          <target state="translated">この例では、着信メッセージと発信メッセージごとに &lt;code&gt;handle_debug&lt;/code&gt; が呼び出されます。フォーマット関数 &lt;code&gt;Func&lt;/code&gt; は、関数 &lt;code&gt;ch4:write_debug/3&lt;/code&gt; であり、 &lt;code&gt;io:format/3&lt;/code&gt; を使用してメッセージを出力します。</target>
        </trans-unit>
        <trans-unit id="ac68bd607f8264f012241fcc414c2e661fd6689b" translate="yes" xml:space="preserve">
          <source>In the example, component &lt;code&gt;number&lt;/code&gt; of the first of the encoded elements in the &lt;code&gt;SEQUENCE OF&lt;/code&gt;&lt;code&gt;buttonList&lt;/code&gt; is selected. This applies on the ASN.1 specification in Section &lt;code&gt;&lt;a href=&quot;#Asn1spec&quot;&gt;Writing an Exclusive Decode Instruction&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">この例では、 &lt;code&gt;SEQUENCE OF&lt;/code&gt; &lt;code&gt;buttonList&lt;/code&gt; の最初のエンコードされた要素のコンポーネント &lt;code&gt;number&lt;/code&gt; が選択されています。これは、セクション &lt;code&gt;&lt;a href=&quot;#Asn1spec&quot;&gt;Writing an Exclusive Decode Instruction&lt;/a&gt;&lt;/code&gt; の記述」のASN.1仕様に適用されます。</target>
        </trans-unit>
        <trans-unit id="5530f78486b7d29f24a47eae49f0d8075dda6924" translate="yes" xml:space="preserve">
          <source>In the example, operator &lt;code&gt;==/2&lt;/code&gt; has been handled exactly as &lt;code&gt;=:=/2&lt;/code&gt; would have been handled. However, if it cannot be determined at compile time that some constant is free of integers, and the table uses &lt;code&gt;=:=/2&lt;/code&gt; when comparing keys for equality (see option &lt;code&gt;&lt;a href=&quot;#key_equality&quot;&gt;key_equality&lt;/a&gt;&lt;/code&gt;), then the &lt;code&gt;qlc&lt;/code&gt; module does not try to look up the constant. The reason is that there is in the general case no upper limit on the number of key values that can compare equal to such a constant; every combination of integers and floats must be looked up:</source>
          <target state="translated">この例では、演算子 &lt;code&gt;==/2&lt;/code&gt; は、 &lt;code&gt;=:=/2&lt;/code&gt; と同じように処理されています。ただし、一部の定数に整数がないとコンパイル時に判別できず、テーブルがキーの等価性を比較するときに &lt;code&gt;=:=/2&lt;/code&gt; を使用する場合（オプション &lt;code&gt;&lt;a href=&quot;#key_equality&quot;&gt;key_equality&lt;/a&gt;&lt;/code&gt; を参照）、 &lt;code&gt;qlc&lt;/code&gt; モジュールは定数の検索を試みません。その理由は、一般に、そのような定数と同等に比較できるキー値の数に上限がないためです。整数と浮動小数点数のすべての組み合わせを検索する必要があります。</target>
        </trans-unit>
        <trans-unit id="5d4ade845da9cf61c7c17decc1f4b425ce968a4b" translate="yes" xml:space="preserve">
          <source>In the example, synchronous start is used. The process starts by calling &lt;code&gt;ch4:start_link()&lt;/code&gt;:</source>
          <target state="translated">この例では、同期起動を使用しています。プロセスは &lt;code&gt;ch4:start_link()&lt;/code&gt; を呼び出すことで開始します。</target>
        </trans-unit>
        <trans-unit id="4bd7e62d6b3c0db60fe6d59696b8717a4d0ca575" translate="yes" xml:space="preserve">
          <source>In the example, the plain node name is &lt;code&gt;c1&lt;/code&gt;.</source>
          <target state="translated">この例では、プレーンノード名は &lt;code&gt;c1&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="6c6e7a22eaacfa776abf6442cc14a2f231bbabc9" translate="yes" xml:space="preserve">
          <source>In the example:</source>
          <target state="translated">例の中では</target>
        </trans-unit>
        <trans-unit id="c137f104119ba8c9533a7a6a7d789c35c273096b" translate="yes" xml:space="preserve">
          <source>In the examples, you can see that the default Erlang shell interprets only characters from the ISO Latin1 range as printable and only detects lists or binaries with those &quot;printable&quot; characters as containing string data. The valid UTF-8 binary containing the Russian word &quot;Юникод&quot;, is not printed as a string. When started with all Unicode characters printable (&lt;code&gt;+pc unicode&lt;/code&gt;), the shell outputs anything containing printable Unicode data (in binaries, either UTF-8 or bytewise encoded) as string data.</source>
          <target state="translated">例では、デフォルトのErlangシェルがISO Latin1範囲の文字のみを印刷可能として解釈し、それらの「印刷可能」文字を含むリストまたはバイナリのみを文字列データを含むものとして検出することがわかります。ロシア語の「Юникод」を含む有効なUTF-8バイナリは、文字列として出力されません。印刷可能なすべてのUnicode文字（ &lt;code&gt;+pc unicode&lt;/code&gt; ）で開始すると、シェルは印刷可能なUnicodeデータ（バイナリ、UTF-8またはバイト単位でエンコードされたもの）を含むすべてを文字列データとして出力します。</target>
        </trans-unit>
        <trans-unit id="357a42f4e90c9f66d20838b1568c32edad86596f" translate="yes" xml:space="preserve">
          <source>In the exchange of DH parameters in cipher suites providing non-anonymous PFS (perfect forward secrecy).</source>
          <target state="translated">非匿名のPFS(完全な前方秘匿)を提供する暗号スイートにおけるDHパラメータの交換において。</target>
        </trans-unit>
        <trans-unit id="43ef791e4bc1073452a5e9418b88d2ae576f87d3" translate="yes" xml:space="preserve">
          <source>In the first form of function calls, &lt;code&gt;ExprM:ExprF(Expr1,...,ExprN)&lt;/code&gt;, each of &lt;code&gt;ExprM&lt;/code&gt; and &lt;code&gt;ExprF&lt;/code&gt; must be an atom or an expression that evaluates to an atom. The function is said to be called by using the &lt;strong&gt;fully qualified function name&lt;/strong&gt;. This is often referred to as a &lt;strong&gt;remote&lt;/strong&gt; or &lt;strong&gt;external function call&lt;/strong&gt;.</source>
          <target state="translated">関数呼び出しの最初の形式である &lt;code&gt;ExprM:ExprF(Expr1,...,ExprN)&lt;/code&gt; では、 &lt;code&gt;ExprM&lt;/code&gt; と &lt;code&gt;ExprF&lt;/code&gt; はそれぞれアトムまたはアトムに評価される式でなければなりません。関数は、&lt;strong&gt;完全修飾関数名&lt;/strong&gt;を使用して呼び出されると言われています。これは、しばしば&lt;strong&gt;リモート&lt;/strong&gt;または&lt;strong&gt;外部関数呼び出しと呼ばれます&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="0855a6f8ea31ce47315705d1ba7c199b9582a1fd" translate="yes" xml:space="preserve">
          <source>In the first section &lt;code&gt;&lt;a href=&quot;#Event-Driven%20State%20Machines&quot;&gt;Event-Driven State Machines&lt;/a&gt;&lt;/code&gt; actions were mentioned as a part of the general state machine model. These general actions are implemented with the code that callback module &lt;code&gt;gen_statem&lt;/code&gt; executes in an event-handling callback function before returning to the &lt;code&gt;gen_statem&lt;/code&gt; engine.</source>
          <target state="translated">最初のセクションでは、 &lt;code&gt;&lt;a href=&quot;#Event-Driven%20State%20Machines&quot;&gt;Event-Driven State Machines&lt;/a&gt;&lt;/code&gt; アクションについて、一般的なステートマシンモデルの一部として説明しました。これらの一般的なアクションは、コールバックモジュール &lt;code&gt;gen_statem&lt;/code&gt; が &lt;code&gt;gen_statem&lt;/code&gt; エンジンに戻る前にイベント処理コールバック関数で実行するコードで実装されます。</target>
        </trans-unit>
        <trans-unit id="66f43d3184fba6cdf7fdff11b421851146670c0d" translate="yes" xml:space="preserve">
          <source>In the first word (4 bytes) of &lt;code&gt;ID&lt;/code&gt;, only 18 bits are significant, the rest are to be 0. In &lt;code&gt;Creation&lt;/code&gt;, only two bits are significant, the rest are to be 0.</source>
          <target state="translated">&lt;code&gt;ID&lt;/code&gt; の最初のワード（4バイト）では、18ビットのみが有効で、残りは0です。 &lt;code&gt;Creation&lt;/code&gt; 、2ビットのみが有効で、残りは0です。</target>
        </trans-unit>
        <trans-unit id="5a896f5f2e336921d68f534c573e7c4a11187dc7" translate="yes" xml:space="preserve">
          <source>In the following descriptions the use of the word &lt;strong&gt;Point&lt;/strong&gt; means: &quot;Point can be seen as the position of the cursor. More precisely, the point is the position between two characters while the cursor is drawn over the character following the point&quot;.</source>
          <target state="translated">以下の説明では、&lt;strong&gt;ポイント&lt;/strong&gt;という用語の使用は、「ポイントはカーソルの位置と見なすことができます。より正確には、ポイントは、カーソルがポイントに続く文字の上に描画されているときの2つの文字間の位置です。」</target>
        </trans-unit>
        <trans-unit id="58edff9fe9daaff2e76b914cd8a32390c2924ba9" translate="yes" xml:space="preserve">
          <source>In the following descriptions, a &lt;strong&gt;group node&lt;/strong&gt; is a node belonging to the same global group as the local node.</source>
          <target state="translated">以下の説明では、&lt;strong&gt;グループノード&lt;/strong&gt;は、ローカルノードと同じグローバルグループに属するノードです。</target>
        </trans-unit>
        <trans-unit id="e55f234f9ae533df0bfe915b6749a10bc4217ff2" translate="yes" xml:space="preserve">
          <source>In the following descriptions, all functions fail with reason &lt;code&gt;badarg&lt;/code&gt; if &lt;code&gt;heart&lt;/code&gt; is not started.</source>
          <target state="translated">以下の説明では、 &lt;code&gt;heart&lt;/code&gt; が開始されていない場合、すべての関数が &lt;code&gt;badarg&lt;/code&gt; の理由で失敗します。</target>
        </trans-unit>
        <trans-unit id="68f124a8843620b9753fc32d51bbb85f7300a1d2" translate="yes" xml:space="preserve">
          <source>In the following example QLC &lt;code&gt;V2&lt;/code&gt; has been inserted to show the joined generators and the join method chosen. A convention is used for lookup join: the first generator (&lt;code&gt;G2&lt;/code&gt;) is the one traversed, the second (&lt;code&gt;G1&lt;/code&gt;) is the table where constants are looked up.</source>
          <target state="translated">次の例では、QLC &lt;code&gt;V2&lt;/code&gt; が挿入され、結合されたジェネレーターと選択された結合方法が示されています。規則はルックアップ結合に使用されます。最初のジェネレータ（ &lt;code&gt;G2&lt;/code&gt; ）はトラバースされるもので、2番目（ &lt;code&gt;G1&lt;/code&gt; ）は定数がルックアップされるテーブルです。</target>
        </trans-unit>
        <trans-unit id="2d50c8a2eb999244e04ab8a6f262c9e2e6443db3" translate="yes" xml:space="preserve">
          <source>In the following example the cached results of the merge join are traversed for each value of &lt;code&gt;A&lt;/code&gt;. Notice that without option &lt;code&gt;cache&lt;/code&gt; the join would have been carried out three times, once for each value of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">次の例では、マージ結合のキャッシュされた結果が &lt;code&gt;A&lt;/code&gt; の値ごとにトラバースされます。オプション &lt;code&gt;cache&lt;/code&gt; がない場合、結合は &lt;code&gt;A&lt;/code&gt; の各値に対して1回ずつ、3回実行されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="260a8dfa6e31c2145458e7a7056ce3363d755407" translate="yes" xml:space="preserve">
          <source>In the following example two processes are created and they send messages to each other a number of times.</source>
          <target state="translated">次の例では、2 つのプロセスが作成され、互いに何度もメッセージを送信します。</target>
        </trans-unit>
        <trans-unit id="486ff704c9f58f71f4584cc309e9153505629a15" translate="yes" xml:space="preserve">
          <source>In the following example two simple QLCs are inserted only to hold option &lt;code&gt;{unique,&amp;nbsp;true}&lt;/code&gt;:</source>
          <target state="translated">次の例では &lt;code&gt;{unique,&amp;nbsp;true}&lt;/code&gt; オプション{unique、true}を保持するためだけに2つの単純なQLCが挿入されています。</target>
        </trans-unit>
        <trans-unit id="069932958b3334f12d9e43060017f62f9f5a1fe0" translate="yes" xml:space="preserve">
          <source>In the following example using this program, nodes are started on four different computers. If you do not have that many machines available on your network, you can start several nodes on the same machine.</source>
          <target state="translated">このプログラムを使用した次の例では、4 台の異なるコンピュータでノードが起動されています。ネットワーク上にそれほど多くのマシンがない場合は、同じマシン上で複数のノードを起動することができます。</target>
        </trans-unit>
        <trans-unit id="02724734c231edad2b6c90b6ad85a686c74a1bd4" translate="yes" xml:space="preserve">
          <source>In the following example, &lt;code&gt;Common Test&lt;/code&gt; finds and executes two tests, one for the path from &lt;code&gt;top2&lt;/code&gt; to &lt;code&gt;sub2X2&lt;/code&gt; through &lt;code&gt;sub21&lt;/code&gt;, and one from &lt;code&gt;top2&lt;/code&gt; to &lt;code&gt;sub2X2&lt;/code&gt; through &lt;code&gt;sub22&lt;/code&gt;:</source>
          <target state="translated">次の例では、 &lt;code&gt;Common Test&lt;/code&gt; 検索し実行する二つの試験からのパスのための1つの &lt;code&gt;top2&lt;/code&gt; に &lt;code&gt;sub2X2&lt;/code&gt; スルー &lt;code&gt;sub21&lt;/code&gt; 、およびから1 &lt;code&gt;top2&lt;/code&gt; に &lt;code&gt;sub2X2&lt;/code&gt; スルー &lt;code&gt;sub22&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2f8fe7428e9b6fba7b913b17290b372522a768bd" translate="yes" xml:space="preserve">
          <source>In the following example, &lt;code&gt;{Pid, hello_world}&lt;/code&gt; is sent to a registered process &lt;code&gt;my_server&lt;/code&gt;. The message is encoded by &lt;code&gt;erl_send()&lt;/code&gt;:</source>
          <target state="translated">次の例では、 &lt;code&gt;{Pid, hello_world}&lt;/code&gt; が登録済みのプロセス &lt;code&gt;my_server&lt;/code&gt; に送信されます。メッセージは &lt;code&gt;erl_send()&lt;/code&gt; によってエンコードされます。</target>
        </trans-unit>
        <trans-unit id="e87829810ad78056f565335e48937b1227a1b55a" translate="yes" xml:space="preserve">
          <source>In the following example, by specifying the unique path &lt;code&gt;top2 -&amp;gt; sub21 -&amp;gt; sub2X2&lt;/code&gt;, only one test is executed. The second possible path, from &lt;code&gt;top2&lt;/code&gt; to &lt;code&gt;sub2X2&lt;/code&gt; (from the former example) is discarded:</source>
          <target state="translated">次の例では、一意のパス &lt;code&gt;top2 -&amp;gt; sub21 -&amp;gt; sub2X2&lt;/code&gt; 指定することにより、1つのテストのみが実行されます。第二の可能な経路、 &lt;code&gt;top2&lt;/code&gt; に &lt;code&gt;sub2X2&lt;/code&gt; （前者の例から）が廃棄されます。</target>
        </trans-unit>
        <trans-unit id="d0cef84143c9c72b0e2d6136f433352bbf267b98" translate="yes" xml:space="preserve">
          <source>In the following example, function &lt;code&gt;dbg:get_tracer/0&lt;/code&gt; is used as trigger for sequential tracing:</source>
          <target state="translated">次の例では、関数 &lt;code&gt;dbg:get_tracer/0&lt;/code&gt; が順次トレースのトリガーとして使用されています。</target>
        </trans-unit>
        <trans-unit id="e10f21b2e3aef85bbfe3ce9d0d87c1a9e3d0bb5a" translate="yes" xml:space="preserve">
          <source>In the following example, lines 2, 4, 6, 8, and 11 are executable lines:</source>
          <target state="translated">以下の例では、2行目、4行目、6行目、8行目、11行目が実行可能な行となっています。</target>
        </trans-unit>
        <trans-unit id="ec7e7bea0a8acebe642deb025a0a656aa8b0599d" translate="yes" xml:space="preserve">
          <source>In the following example, modules &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; are used:</source>
          <target state="translated">次の例では、モジュール &lt;code&gt;foo&lt;/code&gt; および &lt;code&gt;bar&lt;/code&gt; が使用されています。</target>
        </trans-unit>
        <trans-unit id="b174caeefec04ac55e06d8f3b6476035f46aeb21" translate="yes" xml:space="preserve">
          <source>In the following example, the BIF &lt;code&gt;self()&lt;/code&gt; returns the pid of the calling process:</source>
          <target state="translated">次の例では、BIF &lt;code&gt;self()&lt;/code&gt; は呼び出しプロセスのpidを返します。</target>
        </trans-unit>
        <trans-unit id="6ce80e1521f6fcf4a9ffbad8c36f531e99dceb7f" translate="yes" xml:space="preserve">
          <source>In the following example, the Erlang shell is the client process that receives the channel replies.</source>
          <target state="translated">次の例では、Erlangシェルがチャンネルの返信を受け取るクライアントプロセスです。</target>
        </trans-unit>
        <trans-unit id="cfc2a057978208f3e231a6ca3795b61b50bf66e8" translate="yes" xml:space="preserve">
          <source>In the following example, this ASN.1 specification is used:</source>
          <target state="translated">以下の例では、このASN.</target>
        </trans-unit>
        <trans-unit id="f502d38db7db19f5a8116d52d78b40fbb3f26ca6" translate="yes" xml:space="preserve">
          <source>In the following example, two event handlers for the &lt;code&gt;my_SUITE&lt;/code&gt; test are installed:</source>
          <target state="translated">次の例では、 &lt;code&gt;my_SUITE&lt;/code&gt; テスト用の2つのイベントハンドラーがインストールされています。</target>
        </trans-unit>
        <trans-unit id="c99802972b16068431483b2dc762f303df3c8e55" translate="yes" xml:space="preserve">
          <source>In the following example, using the &lt;code&gt;gb_table&lt;/code&gt; module from section &lt;code&gt;&lt;a href=&quot;#implementing_a_qlc_table&quot;&gt;Implementing a QLC Table&lt;/a&gt;&lt;/code&gt;, there are six keys to look up: &lt;code&gt;{1,a}&lt;/code&gt;, &lt;code&gt;{1,b}&lt;/code&gt;, &lt;code&gt;{1,c}&lt;/code&gt;, &lt;code&gt;{2,a}&lt;/code&gt;, &lt;code&gt;{2,b}&lt;/code&gt;, and &lt;code&gt;{2,c}&lt;/code&gt;. The reason is that the two elements of key &lt;code&gt;{X,&amp;nbsp;Y}&lt;/code&gt; are compared separately.</source>
          <target state="translated">次の例では、「 &lt;code&gt;gb_table&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#implementing_a_qlc_table&quot;&gt;Implementing a QLC Table&lt;/a&gt;&lt;/code&gt; セクションのgb_tableモジュールを使用して、検索するキーが6つあります。 &lt;code&gt;{1,a}&lt;/code&gt; 、 &lt;code&gt;{1,b}&lt;/code&gt; 、 &lt;code&gt;{1,c}&lt;/code&gt; 、 &lt;code&gt;{2,a}&lt;/code&gt; 、 &lt;code&gt;{2,b}&lt;/code&gt; 、および &lt;code&gt;{2,c}&lt;/code&gt; 。その理由は、キー &lt;code&gt;{X,&amp;nbsp;Y}&lt;/code&gt; の2つの要素が別々に比較されるためです。</target>
        </trans-unit>
        <trans-unit id="d124bbc7f859ed1a5ddec67afc96d8bbbbad9429" translate="yes" xml:space="preserve">
          <source>In the following examples we use the XML file &quot;motorcycles.xml&quot; and the corresponding DTD &quot;motorcycles.dtd&quot;. motorcycles.xml looks like:</source>
          <target state="translated">以下の例では、XMLファイル「motorcycles.xml」と対応するDTD「motorcycles.dtd」を使用します。</target>
        </trans-unit>
        <trans-unit id="54c1ac0436f87ef143bfc77676125c65125284d3" translate="yes" xml:space="preserve">
          <source>In the following figure, only the marked element is decoded by &lt;code&gt;selected_decode_Window2&lt;/code&gt;:</source>
          <target state="translated">次の図では、マークされた要素のみが &lt;code&gt;selected_decode_Window2&lt;/code&gt; によってデコードされます。</target>
        </trans-unit>
        <trans-unit id="0c1dae61c9ea7eeeb091e362a88deed9b63e97d4" translate="yes" xml:space="preserve">
          <source>In the following figure, square boxes represents supervisors and circles represent workers:</source>
          <target state="translated">次の図では、四角い箱がスーパーバイザー、円が労働者を表しています。</target>
        </trans-unit>
        <trans-unit id="209a1f0310434ec6333f0a98add95c288369e4f6" translate="yes" xml:space="preserve">
          <source>In the following list, init flags are marked &quot;(init flag)&quot;. Unless otherwise specified, all other flags are user flags, for which the values can be retrieved by calling &lt;code&gt;init:get_argument/1&lt;/code&gt;. Notice that the list of user flags is not exhaustive, there can be more application-specific flags that instead are described in the corresponding application documentation.</source>
          <target state="translated">次のリストでは、initフラグは「（init flag）」とマークされています。特に指定がない限り、他のすべてのフラグはユーザーフラグであり、その値は &lt;code&gt;init:get_argument/1&lt;/code&gt; を呼び出すことで取得できます。ユーザーフラグのリストがすべてではないことに注意してください。代わりに、対応するアプリケーションのドキュメントで説明されているアプリケーション固有のフラグが存在する場合があります。</target>
        </trans-unit>
        <trans-unit id="f8c81236f8fbf95dbe539a4a6fcdb86c4472d944" translate="yes" xml:space="preserve">
          <source>In the following sections, these topics are described:</source>
          <target state="translated">以下では、これらのトピックについて説明する。</target>
        </trans-unit>
        <trans-unit id="43ab0d842bde8340d1582f777849f8b8cfc4d0b4" translate="yes" xml:space="preserve">
          <source>In the following sections, we've described as much as we could about the installation of the tools needed. Once the tools are installed, building is quite easy. We have also tried to make these instructions understandable for people with limited Unix experience. Cygwin/MSYS/MSYS2 is a whole new environment to some Windows users, why careful explanation of environment variables etc seemed to be in place.</source>
          <target state="translated">以下では、必要なツールのインストールについて、できる限り説明してきました。ツールがインストールされれば、ビルドはとても簡単です。また、これらの説明は、Unix の経験が浅い人にも理解できるようにしています。Cygwin/MSYS/MSYS2はWindowsユーザーにとっては全く新しい環境であるため、環境変数などの説明が丁寧に行われているようです。</target>
        </trans-unit>
        <trans-unit id="a18adb25fa4d203ef4dc10b4df54df585b5037d2" translate="yes" xml:space="preserve">
          <source>In the following situations, you can easily avoid calling &lt;code&gt;lists:flatten/1&lt;/code&gt;:</source>
          <target state="translated">次の状況では、 &lt;code&gt;lists:flatten/1&lt;/code&gt; の呼び出しを簡単に回避できます。</target>
        </trans-unit>
        <trans-unit id="95df25c253f6cf034d9de8bd86d0112fd600064e" translate="yes" xml:space="preserve">
          <source>In the following tables of examples, &lt;code&gt;Data&lt;/code&gt; must be an I/O list. An I/O list is a binary or a (possibly deep) list of binaries or integers in the range 0..255:</source>
          <target state="translated">次の例の表では、 &lt;code&gt;Data&lt;/code&gt; はI / Oリストでなければなりません。I / Oリストは、バイナリまたは0〜255の範囲のバイナリまたは整数の（おそらく深い）リストです。</target>
        </trans-unit>
        <trans-unit id="969dff5637554c154992258cc999ceb5dbf066be" translate="yes" xml:space="preserve">
          <source>In the functions defined below, the following types are used:</source>
          <target state="translated">以下に定義する関数では、以下のタイプを使用します。</target>
        </trans-unit>
        <trans-unit id="eb8417214d7ef7c1c16243855a2cbc54cd750318" translate="yes" xml:space="preserve">
          <source>In the future, debug functionality will probably be integrated with the Erlang driver thread API. All functions that create entities take a &lt;code&gt;name&lt;/code&gt; argument. Currently the &lt;code&gt;name&lt;/code&gt; argument is unused, but it will be used when the debug functionality is implemented. If you name all entities created well, the debug functionality will be able to give you better error reports.</source>
          <target state="translated">将来的には、デバッグ機能はおそらくErlangドライバースレッドAPIと統合されるでしょう。エンティティを作成するすべての関数は、 &lt;code&gt;name&lt;/code&gt; 引数を取ります。現在、 &lt;code&gt;name&lt;/code&gt; 引数は使用されていませんが、デバッグ機能が実装されるときに使用されます。作成したすべてのエンティティに適切な名前を付けると、デバッグ機能により、より適切なエラーレポートを提供できるようになります。</target>
        </trans-unit>
        <trans-unit id="60a72bba166a7e938efa7cb1218d2bae46312c9d" translate="yes" xml:space="preserve">
          <source>In the generated boot script all application directories are structured as &lt;code&gt;App-Vsn/ebin&lt;/code&gt;. They are assumed to be located in &lt;code&gt;$ROOT/lib&lt;/code&gt;, where &lt;code&gt;$ROOT&lt;/code&gt; is the root directory of the installed release. If option &lt;code&gt;local&lt;/code&gt; is specified, the actual directories where the applications were found are used instead. This is a useful way to test a generated boot script locally.</source>
          <target state="translated">生成されたブートスクリプトでは、すべてのアプリケーションディレクトリが &lt;code&gt;App-Vsn/ebin&lt;/code&gt; として構造化されています。これらは &lt;code&gt;$ROOT/lib&lt;/code&gt; あると想定されています。 &lt;code&gt;$ROOT&lt;/code&gt; はインストールされたリリースのルートディレクトリです。オプション &lt;code&gt;local&lt;/code&gt; が指定されている場合、アプリケーションが見つかった実際のディレクトリが代わりに使用されます。これは、生成されたブートスクリプトをローカルでテストするのに便利な方法です。</target>
        </trans-unit>
        <trans-unit id="8357564b87a53bc03f3e072c2affa02b3f338254" translate="yes" xml:space="preserve">
          <source>In the last example the module to analyze was given as an argument to &lt;code&gt;m/1&lt;/code&gt;, and the code path was (implicitly) used as &lt;code&gt;&lt;a href=&quot;xref#library_path&quot;&gt;library path&lt;/a&gt;&lt;/code&gt;. In this example an &lt;code&gt;&lt;a href=&quot;xref#xref_server&quot;&gt;xref server&lt;/a&gt;&lt;/code&gt; will be used, which makes it possible to analyze applications and releases, and also to select the library path explicitly.</source>
          <target state="translated">最後の例では、分析するモジュールが &lt;code&gt;m/1&lt;/code&gt; への引数として与えられ、コードパスが（暗黙的に） &lt;code&gt;&lt;a href=&quot;xref#library_path&quot;&gt;library path&lt;/a&gt;&lt;/code&gt; として使用されました。この例では、 &lt;code&gt;&lt;a href=&quot;xref#xref_server&quot;&gt;xref server&lt;/a&gt;&lt;/code&gt; が使用されます。これにより、アプリケーションとリリースを分析し、ライブラリパスを明示的に選択することもできます。</target>
        </trans-unit>
        <trans-unit id="53bf7f90f102c21f6ff33e9b95147ea6befa4500" translate="yes" xml:space="preserve">
          <source>In the last line, notice that the tuple {256,10,-2} is the real number 2.56 in a special notation, which encodes faster than simply stating the number as &lt;code&gt;&quot;2.56&quot;&lt;/code&gt;. The arity three tuple is &lt;code&gt;{Mantissa,Base,Exponent}&lt;/code&gt;, that is, Mantissa * Base^Exponent.</source>
          <target state="translated">最後の行で、タプル{256,10、-2}が特別な表記の実数2.56であることに注意してください。これは、数値を単に &lt;code&gt;&quot;2.56&quot;&lt;/code&gt; と述べるよりも高速にエンコードします。アリティ3のタプルは &lt;code&gt;{Mantissa,Base,Exponent}&lt;/code&gt; 。つまり、Mantissa * Base ^ Exponentです。</target>
        </trans-unit>
        <trans-unit id="f93bba552275aa89bdb5e765c9d14d6ea2d7aaa2" translate="yes" xml:space="preserve">
          <source>In the lists that are divided in two for the two directions (c.f &lt;code&gt;cipher&lt;/code&gt;) it is possible to change both directions at once:</source>
          <target state="translated">2つの方向に2つに分割されているリスト（ &lt;code&gt;cipher&lt;/code&gt; 参照）では、両方の方向を一度に変更できます。</target>
        </trans-unit>
        <trans-unit id="00675dbb48a26b0a91eca4f2bc6b8535be7bd247" translate="yes" xml:space="preserve">
          <source>In the lists that are divided in two for the two directions (c.f &lt;code&gt;cipher&lt;/code&gt;) it is possible to change only one of the directions:</source>
          <target state="translated">2つの方向に2つに分割されたリスト（ &lt;code&gt;cipher&lt;/code&gt; 参照）では、方向の1つのみを変更できます。</target>
        </trans-unit>
        <trans-unit id="9467c0d9e7e0679d7e286a3e84f7825f450479dd" translate="yes" xml:space="preserve">
          <source>In the loop where requests are handled, send time-outs can now be detected:</source>
          <target state="translated">リクエストを処理するループで、送信のタイムアウトを検出できるようになりました。</target>
        </trans-unit>
        <trans-unit id="9da6cdcd2464f9aa69d41b9520dcbcf709d10ca9" translate="yes" xml:space="preserve">
          <source>In the messenger example, no assumptions have been made about what the message being sent is. It can be any valid Erlang term.</source>
          <target state="translated">メッセンジャーの例では、送信されるメッセージが何であるかについては何も仮定していません。これは有効なErlang用語です。</target>
        </trans-unit>
        <trans-unit id="bb3b53f608800b09e4b113953e980be25982bcf7" translate="yes" xml:space="preserve">
          <source>In the monitor message &lt;code&gt;MonitorRef&lt;/code&gt; and &lt;code&gt;Type&lt;/code&gt; are the same as described earlier, and:</source>
          <target state="translated">モニターメッセージの &lt;code&gt;MonitorRef&lt;/code&gt; と &lt;code&gt;Type&lt;/code&gt; は、前に説明したものと同じです。</target>
        </trans-unit>
        <trans-unit id="440342ee163fa2a69d1ae77fbeb319e6027a604d" translate="yes" xml:space="preserve">
          <source>In the normal case, a version is constructed as &lt;code&gt;&amp;lt;Major&amp;gt;.&amp;lt;Minor&amp;gt;.&amp;lt;Patch&amp;gt;&lt;/code&gt;, where &lt;code&gt;&amp;lt;Major&amp;gt;&lt;/code&gt; is the most significant part.</source>
          <target state="translated">通常の場合、バージョンは &lt;code&gt;&amp;lt;Major&amp;gt;.&amp;lt;Minor&amp;gt;.&amp;lt;Patch&amp;gt;&lt;/code&gt; として構築されます。ここで、 &lt;code&gt;&amp;lt;Major&amp;gt;&lt;/code&gt; は最も重要な部分です。</target>
        </trans-unit>
        <trans-unit id="eef10fd45d5bc3efdc8a361eb2983aa877e3b993" translate="yes" xml:space="preserve">
          <source>In the presence of initial values for fields, the type must be declared after the initialization, as follows:</source>
          <target state="translated">フィールドの初期値がある場合は、以下のように初期化後に型を宣言する必要があります。</target>
        </trans-unit>
        <trans-unit id="85f68555c1cd1c300b04b62bde8ff2ba3511a30a" translate="yes" xml:space="preserve">
          <source>In the previous example there is no indication of which protocols are expected. So a client has no indication of whether it is a web server, an ldap server or maybe a sip server it is connected to. There are fields in the certificate that can indicate this. To be more exact, the rfc introduces the usage of the &lt;code&gt;X509v3 Subject Alternative Name&lt;/code&gt; in the &lt;code&gt;X509v3 extensions&lt;/code&gt; field:</source>
          <target state="translated">前の例では、どのプロトコルが予期されるかを示していません。したがって、クライアントには、それがWebサーバーであるか、LDAPサーバーであるか、接続されているsipサーバーであるかが示されていません。これを示すことができる証明書のフィールドがあります。より正確に言うと、rfc は &lt;code&gt;X509v3 extensions&lt;/code&gt; フィールドで &lt;code&gt;X509v3 Subject Alternative Name&lt;/code&gt; の別名の使用を導入しています。</target>
        </trans-unit>
        <trans-unit id="540597900320cac0101d153b777e3c96ce5dbf16" translate="yes" xml:space="preserve">
          <source>In the previous example, &quot;ping&quot; and &quot;pong&quot; were started from the shells of two separate Erlang nodes. &lt;code&gt;spawn&lt;/code&gt; can also be used to start processes in other nodes.</source>
          <target state="translated">前の例では、「ping」と「pong」は2つの別々のErlangノードのシェルから開始されました。 &lt;code&gt;spawn&lt;/code&gt; は、他のノードでプロセスを開始するためにも使用できます。</target>
        </trans-unit>
        <trans-unit id="b18cd2f860e67d545dd4ad1005cc630df953632b" translate="yes" xml:space="preserve">
          <source>In the previous example, if &lt;code&gt;all/0&lt;/code&gt; returns group name references in the order &lt;code&gt;[{group,group1},{group,group3}]&lt;/code&gt;, the order of the configuration functions and test cases becomes the following (notice that &lt;code&gt;init_per_testcase/2&lt;/code&gt; and &lt;code&gt;end_per_testcase/2:&lt;/code&gt; are also always called, but not included in this example for simplification):</source>
          <target state="translated">前の例では、 &lt;code&gt;all/0&lt;/code&gt; が &lt;code&gt;[{group,group1},{group,group3}]&lt;/code&gt; の順序でグループ名参照を返す場合、構成関数とテストケースの順序は次のようになります（ &lt;code&gt;init_per_testcase/2&lt;/code&gt; と &lt;code&gt;end_per_testcase/2:&lt;/code&gt; 常に呼び出されますが、簡略化のためにこの例には含まれていません）：</target>
        </trans-unit>
        <trans-unit id="d05bdeaa2197b362b108ffe823ac50e3ee94a479" translate="yes" xml:space="preserve">
          <source>In the previous example, the supervisor is started by calling &lt;code&gt;ch_sup:start_link()&lt;/code&gt;:</source>
          <target state="translated">上記の例では、スーパーバイザーは &lt;code&gt;ch_sup:start_link()&lt;/code&gt; を呼び出すことによって開始されます。</target>
        </trans-unit>
        <trans-unit id="05d2378639fa9498426915ef27016e468d81ee73" translate="yes" xml:space="preserve">
          <source>In the previous examples, new variable names are used, instead of reusing the old ones: &lt;code&gt;First&lt;/code&gt;, &lt;code&gt;TheRest&lt;/code&gt;, &lt;code&gt;E1&lt;/code&gt;, &lt;code&gt;E2&lt;/code&gt;, &lt;code&gt;R&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, and &lt;code&gt;C&lt;/code&gt;. The reason for this is that a variable can only be given a value once in its context (scope). More about this later.</source>
          <target state="translated">前の例では、古い変数を再利用する代わりに、新しい変数名 &lt;code&gt;First&lt;/code&gt; 、 &lt;code&gt;TheRest&lt;/code&gt; 、 &lt;code&gt;E1&lt;/code&gt; 、 &lt;code&gt;E2&lt;/code&gt; 、 &lt;code&gt;R&lt;/code&gt; 、 &lt;code&gt;A&lt;/code&gt; 、 &lt;code&gt;B&lt;/code&gt; 、 &lt;code&gt;C&lt;/code&gt; が使用されています。この理由は、変数にはそのコンテキスト（スコープ）で一度しか値を指定できないためです。これについては後で詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="9db752d6e6f2fd68cc464e93f5288f571d158e54" translate="yes" xml:space="preserve">
          <source>In the runtime system with SMP support, drivers are locked either on driver level or port level (driver instance level). By default driver level locking will be used, that is, only one emulator thread will execute code in the driver at a time. If port level locking is used, multiple emulator threads can execute code in the driver at the same time. Only one thread at a time will call driver callbacks corresponding to the same port, though. To enable port level locking, set the &lt;code id=&quot;smp_support&quot;&gt;ERL_DRV_FLAG_USE_PORT_LOCKING&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;driver flag&lt;/a&gt;&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; used by the driver. When port level locking is used, the driver writer is responsible for synchronizing all accesses to data shared by the ports (driver instances).</source>
          <target state="translated">SMPをサポートするランタイムシステムでは、ドライバーはドライバーレベルまたはポートレベル（ドライバーインスタンスレベル）でロックされます。デフォルトでは、ドライバレベルのロックが使用されます。つまり、一度に1つのエミュレータスレッドだけがドライバのコードを実行します。ポートレベルのロックが使用されている場合、複数のエミュレータスレッドがドライバのコードを同時に実行できます。ただし、一度に1つのスレッドのみが同じポートに対応するドライバーコールバックを呼び出します。ポートレベルのロックを有効にするために、設定 &lt;code id=&quot;smp_support&quot;&gt;ERL_DRV_FLAG_USE_PORT_LOCKING&lt;/code&gt; の &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;driver flag&lt;/a&gt;&lt;/code&gt; に &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; ドライバによって使用されます。ポートレベルのロックを使用する場合、ドライバー作成者は、ポート（ドライバーインスタンス）によって共有されるデータへのすべてのアクセスを同期する必要があります。</target>
        </trans-unit>
        <trans-unit id="45c47bc5d9c1563d221339ce4f4f3726200c6a90" translate="yes" xml:space="preserve">
          <source>In the second example we use the default trace handler function. This handler prints to tty by sending IO requests to the &lt;code&gt;user&lt;/code&gt; process. When Erlang is started in oldshell mode, the shell process will have &lt;code&gt;user&lt;/code&gt; as its group leader and so will the tracer process in this example. Since &lt;code&gt;user&lt;/code&gt; calls functions in &lt;code&gt;lists&lt;/code&gt; we end up in a deadlock as soon as the first IO request is sent.</source>
          <target state="translated">2番目の例では、デフォルトのトレースハンドラー関数を使用します。このハンドラは、IO要求を &lt;code&gt;user&lt;/code&gt; プロセスに送信することによってttyに出力します。Erlangがoldshellモードで開始されると、シェルプロセスはグループリーダーとして &lt;code&gt;user&lt;/code&gt; を持ち、この例ではトレーサープロセスもそうです。 &lt;code&gt;user&lt;/code&gt; が &lt;code&gt;lists&lt;/code&gt; 内の関数を呼び出すため、最初のIO要求が送信されるとすぐにデッドロックが発生します。</target>
        </trans-unit>
        <trans-unit id="c04391cfdd5ab08da1a538b9e9e445cf468e3b94" translate="yes" xml:space="preserve">
          <source>In the second form of function calls, &lt;code&gt;ExprF(Expr1,...,ExprN)&lt;/code&gt;, &lt;code&gt;ExprF&lt;/code&gt; must be an atom or evaluate to a fun.</source>
          <target state="translated">関数呼び出しの2番目の形式である &lt;code&gt;ExprF(Expr1,...,ExprN)&lt;/code&gt; では、 &lt;code&gt;ExprF&lt;/code&gt; はアトムであるか、funに評価される必要があります。</target>
        </trans-unit>
        <trans-unit id="739f1313c2f241e229ecba15f499a06fac9e9ec7" translate="yes" xml:space="preserve">
          <source>In the sequence chart, the actors (which symbolically has performed the &lt;code&gt;Event&lt;/code&gt;) are shown as named vertical bars. The order of the actors may be altered by dragging (hold mouse button 1 pressed during the operation) the name tag of an actor and drop it elsewhere:</source>
          <target state="translated">シーケンスチャートでは、アクター（象徴的に &lt;code&gt;Event&lt;/code&gt; を実行した）が名前付きの縦棒として表示されます。アクターの順序は、アクターの名前タグをドラッグ（操作中にマウスボタン1を押したまま）して別の場所にドロップすることで変更できます。</target>
        </trans-unit>
        <trans-unit id="2624ef8dfa305150cd47498ba182bfff4991d99a" translate="yes" xml:space="preserve">
          <source>In the shell, if using a Unicode input device, or in source code stored in UTF-8, &lt;code&gt;$&lt;/code&gt; can be followed directly by a Unicode character producing an integer. In the following example, the code point of a Cyrillic &lt;code&gt;с&lt;/code&gt; is output:</source>
          <target state="translated">シェルでは、Unicode入力デバイスを使用する場合、またはUTF-8で保存されたソースコードの場合、 &lt;code&gt;$&lt;/code&gt; の後に整数を生成するUnicode文字を直接続けることができます。次の例では、キリル文字 &lt;code&gt;с&lt;/code&gt; のコードポイントが出力されます。</target>
        </trans-unit>
        <trans-unit id="a13f065991e8e14b6a7d0e85181fc27a2c686176" translate="yes" xml:space="preserve">
          <source>In the situation where a node has lost its connections to other nodes in its global group, but has connections to nodes in other global groups, a request from another global group can produce an incorrect or misleading result. For example, the isolated node can have inaccurate information about registered names in its global group.</source>
          <target state="translated">ノードがグローバルグループ内の他のノードとの接続を失ったが、他のグローバルグループ内のノードとの接続を持っているという状況では、他のグローバルグループからのリクエストにより、不正確な結果や誤解を招く結果が生じる可能性があります。例えば、孤立したノードは、そのグローバルグループに登録された名前に関する不正確な情報を持つことができます。</target>
        </trans-unit>
        <trans-unit id="f1acddb6beb61278fbb0d6fbae558f662971ab57" translate="yes" xml:space="preserve">
          <source>In the target directory reads the file &lt;code&gt;releases/start_erl.data&lt;/code&gt; to find the Erlang runtime system version (&quot;5.10.4&quot;).</source>
          <target state="translated">ターゲットディレクトリで、 &lt;code&gt;releases/start_erl.data&lt;/code&gt; ファイルを読み取り、Erlangランタイムシステムのバージョン（ &quot;5.10.4&quot;）を見つけます。</target>
        </trans-unit>
        <trans-unit id="8519783e0474dbe47084ba06a2c57f937aceddd6" translate="yes" xml:space="preserve">
          <source>In the text encoding, implementors have the choice of using a mix of short and long keywords. It is also possible to add white spaces to improve readability. We use the term compact for text messages with the shortest possible keywords and no optional white spaces, and the term pretty for a well indented text format using long keywords and an indentation style like the text examples in the Megaco/H.248 specification).</source>
          <target state="translated">テキストエンコーディングでは、実装者は短いキーワードと長いキーワードを混在させて使用する選択肢があります。また、可読性を向上させるためにホワイトスペースを追加することも可能です。ここでは、可能な限り短いキーワードとオプションの空白を持たないテキストメッセージにはコンパクトという用語を用い、長いキーワードとMegaco/H.248仕様のテキスト例のようなインデントスタイルを用いた、十分にインデントされたテキストフォーマットにはプリティという用語を用いています)。</target>
        </trans-unit>
        <trans-unit id="4f97637d135e2db9b66d48ef02e3dc2bf1b27bf1" translate="yes" xml:space="preserve">
          <source>In the xmerl_xs functions you can provide a select(String) call, which is an &lt;code&gt;&lt;a href=&quot;http://www.w3.org/TR/xpath&quot;&gt;XPath&lt;/a&gt;&lt;/code&gt; functionality. For more details see the xmerl_xs &lt;code&gt;tutorial&lt;/code&gt;.</source>
          <target state="translated">xmerl_xs関数では、 &lt;code&gt;&lt;a href=&quot;http://www.w3.org/TR/xpath&quot;&gt;XPath&lt;/a&gt;&lt;/code&gt; 機能であるselect（String）呼び出しを提供できます。詳細については、xmerl_xs &lt;code&gt;tutorial&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="1dac4b7f84924719cb25f1773bfbe993e383c0c1" translate="yes" xml:space="preserve">
          <source>In these cases, the ProtocolVersion default version is obtained from the static connection configuration:</source>
          <target state="translated">これらの場合、ProtocolVersionのデフォルトバージョンは、静的接続構成から取得されます。</target>
        </trans-unit>
        <trans-unit id="d38f971f169182ffed875b881c3f302c1291f57c" translate="yes" xml:space="preserve">
          <source>In this agent system, there are two ways to dynamically install management information. The most common way is to load an MIB into an agent. The other way is to use a sub-agent, which is controlled by the application and is able to register and unregister itself. A sub-agent can register itself for managing a sub-tree (not to be mixed up with &lt;code&gt;erlang:register&lt;/code&gt;). The sub-tree is identified by an Object Identifier. When a sub-agent is registered, it receives all requests for this particular sub-tree and it is responsible for answering them. It should also be noted that a sub-agent can be started and stopped at any time.</source>
          <target state="translated">このエージェントシステムでは、管理情報を動的にインストールする方法が2つあります。最も一般的な方法は、MIBをエージェントにロードすることです。もう1つの方法は、アプリケーションによって制御され、それ自体を登録および登録解除できるサブエージェントを使用することです。サブエージェントは、サブツリーを管理するためにそれ自体を登録できます（ &lt;code&gt;erlang:register&lt;/code&gt; と混同しないでください）。サブツリーはオブジェクト識別子によって識別されます。サブエージェントが登録されると、サブエージェントはこの特定のサブツリーに対するすべての要求を受け取り、それらに応答する責任があります。サブエージェントはいつでも開始および停止できることに注意してください。</target>
        </trans-unit>
        <trans-unit id="539e0564531c6d44cbeae350dfc80c3176291ed6" translate="yes" xml:space="preserve">
          <source>In this call, &lt;code&gt;[1, 1]&lt;/code&gt; is the &lt;code&gt;RowIndex&lt;/code&gt;, where key 1 has value 1, and key 2 has value 1, and &lt;code&gt;[3, 5]&lt;/code&gt; is the list of requested columns. The function should now return the lexicographically next elements:</source>
          <target state="translated">この呼び出しでは、 &lt;code&gt;[1, 1]&lt;/code&gt; は &lt;code&gt;RowIndex&lt;/code&gt; です。キー1の値は1で、キー2の値は1で、 &lt;code&gt;[3, 5]&lt;/code&gt; は要求された列のリストです。関数は辞書順で次の要素を返すはずです。</target>
        </trans-unit>
        <trans-unit id="6f444892327372c0083d6cd41d371bb581f5034e" translate="yes" xml:space="preserve">
          <source>In this case it has got a new component &lt;code&gt;b&lt;/code&gt;. Thus, incoming messages that are decoded can have more or fever components than this one.</source>
          <target state="translated">この場合、新しいコンポーネント &lt;code&gt;b&lt;/code&gt; を取得しています。したがって、デコードされる着信メッセージには、これよりも多くの、または発熱するコンポーネントがあります。</target>
        </trans-unit>
        <trans-unit id="81909444a643000153b2965fd71e17cdec12149b" translate="yes" xml:space="preserve">
          <source>In this case the &lt;code&gt;ct_hooks&lt;/code&gt; statement in the test suite can look as follows:</source>
          <target state="translated">この場合、テストスイートの &lt;code&gt;ct_hooks&lt;/code&gt; ステートメントは次のようになります。</target>
        </trans-unit>
        <trans-unit id="4a51ade1b4e89205ca9bc9b111738c60e7a1c022" translate="yes" xml:space="preserve">
          <source>In this case the configuration file must at least contain:</source>
          <target state="translated">この場合、設定ファイルは少なくとも含まれていなければなりません。</target>
        </trans-unit>
        <trans-unit id="1d7088cf673c6d087bf2c25d65e3c008f7960123" translate="yes" xml:space="preserve">
          <source>In this case the filter is applied to every possible pair of answers to &lt;code&gt;QH1&lt;/code&gt; and &lt;code&gt;QH2&lt;/code&gt;, one at a time. If there are M answers to &lt;code&gt;QH1&lt;/code&gt; and N answers to &lt;code&gt;QH2&lt;/code&gt;, the filter is run M*N times.</source>
          <target state="translated">この場合、フィルターは &lt;code&gt;QH1&lt;/code&gt; と &lt;code&gt;QH2&lt;/code&gt; に対する可能なすべての回答のペアに一度に1つずつ適用されます。Mの答えがある場合 &lt;code&gt;QH1&lt;/code&gt; へとNの答え &lt;code&gt;QH2&lt;/code&gt; は、フィルタはM * N回実行されます。</target>
        </trans-unit>
        <trans-unit id="28983b21b0ad9b5b9935ebfc53758651c434ba12" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;CTH&lt;/code&gt; can either be only the module name of the CTH or a tuple with the module name and the initial arguments, and optionally the hook priority of the CTH. For example, one of the following:</source>
          <target state="translated">この場合、 &lt;code&gt;CTH&lt;/code&gt; は、CTHのモジュール名のみ、またはモジュール名と初期引数を持つタプル、およびオプションでCTHのフック優先度のいずれかになります。たとえば、次のいずれかです。</target>
        </trans-unit>
        <trans-unit id="2a423ae0801e37198bf3643c083306bae6ec09bd" translate="yes" xml:space="preserve">
          <source>In this case, Compiler option &lt;code&gt;encrypt_debug_info&lt;/code&gt; can be used, see &lt;code&gt;compile(3)&lt;/code&gt;.</source>
          <target state="translated">この場合、コンパイラオプション &lt;code&gt;encrypt_debug_info&lt;/code&gt; を使用できます。compile &lt;code&gt;compile(3)&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="5039f2c8ff05131bbbf56345b582c1ca63c2cd6b" translate="yes" xml:space="preserve">
          <source>In this case, all arguments but the first are ignored and the function simply returns the internal state again. This is enough if the code only has been extended. If instead the internal state is changed (similar to the example in &lt;code&gt;&lt;a href=&quot;#int_state&quot;&gt;Changing Internal State&lt;/a&gt;&lt;/code&gt;), this is done in this function and &lt;code&gt;{ok,Chs2}&lt;/code&gt; returned.</source>
          <target state="translated">この場合、最初の引数以外のすべての引数は無視され、関数は単に内部状態を再び返します。コードのみが拡張されている場合、これで十分です。代わりに、内部状態（の例と同様に変更された場合に &lt;code&gt;&lt;a href=&quot;#int_state&quot;&gt;Changing Internal State&lt;/a&gt;&lt;/code&gt; ）、これは、この機能で行われ、 &lt;code&gt;{ok,Chs2}&lt;/code&gt; 返されます。</target>
        </trans-unit>
        <trans-unit id="f725a21c435f46ea81fa484e58d3d41f8bd72bbc" translate="yes" xml:space="preserve">
          <source>In this case, one or more of &lt;code&gt;Expr1&lt;/code&gt;...&lt;code&gt;ExprK&lt;/code&gt; can be unbound variables.</source>
          <target state="translated">この場合、1つ以上の &lt;code&gt;Expr1&lt;/code&gt; ... &lt;code&gt;ExprK&lt;/code&gt; を非バインド変数にすることができます。</target>
        </trans-unit>
        <trans-unit id="bac5d4d9afdbed7a919ecd5845595a514ce50f9a" translate="yes" xml:space="preserve">
          <source>In this case, simple code replacement is not sufficient. The process must explicitly transform its state using the callback function &lt;code&gt;code_change&lt;/code&gt; before switching to the new version of the callback module. Thus, synchronized code replacement is used.</source>
          <target state="translated">この場合、単純なコード置換では不十分です。プロセスは、コールバックモジュールの新しいバージョンに切り替える前に、コールバック関数 &lt;code&gt;code_change&lt;/code&gt; を使用してその状態を明示的に変換する必要があります。したがって、同期コード置換が使用されます。</target>
        </trans-unit>
        <trans-unit id="4ec09095fe4b3a08fa08b2d3c7632c3ad498721e" translate="yes" xml:space="preserve">
          <source>In this case, simple code replacement is not sufficient. When a new version of a residence module for a special process is loaded, the process must make a fully qualified call to its loop function to switch to the new code. Thus, synchronized code replacement must be used.</source>
          <target state="translated">この場合、単純なコードの置き換えだけでは十分ではありません。特殊なプロセス用の新しいバージョンの居住モジュールがロードされたとき、プロセスは、新しいコードに切り替えるために、そのループ関数に完全修飾された呼び出しを行わなければなりません。したがって、同期化されたコード置換を使用しなければなりません。</target>
        </trans-unit>
        <trans-unit id="bbe74749660d0039c0abd21e49290ce19c250a20" translate="yes" xml:space="preserve">
          <source>In this case, the calling process is the shell, so the following result is received:</source>
          <target state="translated">この場合、呼び出し元のプロセスがシェルなので、以下のような結果になります。</target>
        </trans-unit>
        <trans-unit id="2cd85caaa1a6987f2340faefbd7babc9b4009f1f" translate="yes" xml:space="preserve">
          <source>In this case, the function must be exported from the module in question.</source>
          <target state="translated">この場合、関数は問題のモジュールからエクスポートされなければなりません。</target>
        </trans-unit>
        <trans-unit id="84ecff76d3518039bed69b56be3f5fe9f91bdb0c" translate="yes" xml:space="preserve">
          <source>In this case, the key &lt;code&gt;Key&lt;/code&gt; is returned, which can be used in a subsequent call to &lt;code&gt;&lt;a href=&quot;#yield-1&quot;&gt;yield/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#nb_yield-1&quot;&gt;nb_yield/1,2&lt;/a&gt;&lt;/code&gt; to retrieve the value of evaluating &lt;code&gt;apply(Module, Function, Args)&lt;/code&gt; on node &lt;code&gt;Node&lt;/code&gt;.</source>
          <target state="translated">この場合、キー &lt;code&gt;Key&lt;/code&gt; が返されます。これは、後続の &lt;code&gt;&lt;a href=&quot;#yield-1&quot;&gt;yield/1&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;#nb_yield-1&quot;&gt;nb_yield/1,2&lt;/a&gt;&lt;/code&gt; の呼び出しで使用して、ノード &lt;code&gt;Node&lt;/code&gt; で &lt;code&gt;apply(Module, Function, Args)&lt;/code&gt; を評価する値を取得できます。</target>
        </trans-unit>
        <trans-unit id="2ea0870da5814abd9a73cf1fe490942611b71d5e" translate="yes" xml:space="preserve">
          <source>In this case, the new state is the updated list of available channels &lt;code&gt;Chs2&lt;/code&gt;. The &lt;code&gt;gen_server&lt;/code&gt; is now ready for new requests.</source>
          <target state="translated">この場合、新しい状態は利用可能なチャネル &lt;code&gt;Chs2&lt;/code&gt; の更新されたリストです。これで、 &lt;code&gt;gen_server&lt;/code&gt; は新しい要求を受け入れる準備ができました。</target>
        </trans-unit>
        <trans-unit id="5aee58fc810702815e51808a51b2ab85c081aa01" translate="yes" xml:space="preserve">
          <source>In this case, the release handler framework with automatic packing and unpacking of release packages, automatic path updates, and so on, can be used without having to specify &lt;code&gt;.appup&lt;/code&gt; files.</source>
          <target state="translated">この場合、 &lt;code&gt;.appup&lt;/code&gt; ファイルを指定せずに、リリースパッケージの自動パックおよびアンパック、自動パス更新などを備えたリリースハンドラフレームワークを使用できます。</target>
        </trans-unit>
        <trans-unit id="a0046cd0df3cac4eb3b95dc96fc37ec106f64638" translate="yes" xml:space="preserve">
          <source>In this case, the reply is the allocated channel &lt;code&gt;Ch&lt;/code&gt; and the new state is the set of remaining available channels &lt;code&gt;Chs2&lt;/code&gt;.</source>
          <target state="translated">この場合、応答は割り当てられたチャネル &lt;code&gt;Ch&lt;/code&gt; であり、新しい状態は残りの使用可能なチャネル &lt;code&gt;Chs2&lt;/code&gt; のセットです。</target>
        </trans-unit>
        <trans-unit id="9574675a8f9e5418ebb839c426e998489f14ad76" translate="yes" xml:space="preserve">
          <source>In this case, the supervisor is not registered. Instead its pid must be used. A name can be specified by calling &lt;code&gt;supervisor:start_link({local, Name}, Module, Args)&lt;/code&gt; or &lt;code&gt;supervisor:start_link({global, Name}, Module, Args)&lt;/code&gt;.</source>
          <target state="translated">この場合、監督者は登録されていません。代わりに、そのpidを使用する必要があります。名前は、 &lt;code&gt;supervisor:start_link({local, Name}, Module, Args)&lt;/code&gt; &lt;code&gt;supervisor:start_link({global, Name}, Module, Args)&lt;/code&gt; ）またはsupervisor：start_link（{global、Name}、Module、Args ）を呼び出すことで指定できます。</target>
        </trans-unit>
        <trans-unit id="b6603f0a6951b192542ceb666e2c7f72b121f614" translate="yes" xml:space="preserve">
          <source>In this case, you free the two terms independently. The order in which you free the terms &lt;code&gt;ep&lt;/code&gt; and &lt;code&gt;ep2&lt;/code&gt; is not important, because the &lt;code&gt;Erl_Interface&lt;/code&gt; library uses reference counting to determine when it is safe to remove objects.</source>
          <target state="translated">この場合、2つの用語を個別に解放します。 &lt;code&gt;Erl_Interface&lt;/code&gt; ライブラリは参照カウントを使用してオブジェクトを安全に削除できる時期を判断するため、用語 &lt;code&gt;ep&lt;/code&gt; とep2を &lt;code&gt;ep2&lt;/code&gt; は重要ではありません。</target>
        </trans-unit>
        <trans-unit id="b0020e2468bc67c671f498f4e4e7457122f890ee" translate="yes" xml:space="preserve">
          <source>In this example consider the situation where you want to examine a particular data in the XML file. For instance, you want to check for how long each motorcycle have been recorded.</source>
          <target state="translated">この例では、XMLファイル内の特定のデータを調べたい場合を考えてみましょう。例えば、各バイクがどれくらいの時間記録されているかを調べたいとします。</target>
        </trans-unit>
        <trans-unit id="46a429a85cf2eee81ebe05e357ca0f926abafe9d" translate="yes" xml:space="preserve">
          <source>In this example the Pea application has been changed, and so are the applications ERTS, Kernel, STDLIB and SASL.</source>
          <target state="translated">この例では、Pea アプリケーションが変更され、ERTS、Kernel、STDLIB、SASL アプリケーションも変更されています。</target>
        </trans-unit>
        <trans-unit id="4298d6ba95bb1281780cd67a70e648391534cd1f" translate="yes" xml:space="preserve">
          <source>In this example the numbers are integers and the arguments in the functions in the code &lt;code&gt;N&lt;/code&gt;, &lt;code&gt;X&lt;/code&gt;, and &lt;code&gt;Y&lt;/code&gt; are called variables. Variables must start with a capital letter (see &lt;code&gt;Variables&lt;/code&gt;). Examples of variables are &lt;code&gt;Number&lt;/code&gt;, &lt;code&gt;ShoeSize&lt;/code&gt;, and &lt;code&gt;Age&lt;/code&gt;.</source>
          <target state="translated">この例では、数値は整数であり、コード &lt;code&gt;N&lt;/code&gt; 、 &lt;code&gt;X&lt;/code&gt; 、および &lt;code&gt;Y&lt;/code&gt; の関数の引数は変数と呼ばれます。変数は大文字で始める必要があります（ &lt;code&gt;Variables&lt;/code&gt; 参照）。変数の例は、 &lt;code&gt;Number&lt;/code&gt; 、 &lt;code&gt;ShoeSize&lt;/code&gt; 、および &lt;code&gt;Age&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="f86bfad372e7bf0f313f5d6b081512cd31ba5a67" translate="yes" xml:space="preserve">
          <source>In this example you walk through a list &quot;carrying&quot; a value, in this case &lt;code&gt;Result_so_far&lt;/code&gt;. &lt;code&gt;list_max/1&lt;/code&gt; simply assumes that the max value of the list is the head of the list and calls &lt;code&gt;list_max/2&lt;/code&gt; with the rest of the list and the value of the head of the list. In the above this would be &lt;code&gt;list_max([2,3,4,5,7,4,3,2,1],1)&lt;/code&gt;. If you tried to use &lt;code&gt;list_max/1&lt;/code&gt; with an empty list or tried to use it with something that is not a list at all, you would cause an error. Notice that the Erlang philosophy is not to handle errors of this type in the function they occur, but to do so elsewhere. More about this later.</source>
          <target state="translated">この例では、値を保持するリスト（この場合は &lt;code&gt;Result_so_far&lt;/code&gt; )をウォークスルーします。 &lt;code&gt;list_max/1&lt;/code&gt; は、リストの最大値がリストの先頭であると単純に想定し、リストの残りの部分とリストの先頭の値で &lt;code&gt;list_max/2&lt;/code&gt; を呼び出します。上記の場合、これは &lt;code&gt;list_max([2,3,4,5,7,4,3,2,1],1)&lt;/code&gt; ます。あなたが使用しようとした場合 &lt;code&gt;list_max/1&lt;/code&gt; を空のリスト、またはすべてのリストではありません何かでそれを使用しようとしました、あなたは、エラーが発生します。 Erlangの哲学は、発生する関数でこのタイプのエラーを処理することではなく、他の場所で処理することに注意してください。これについては後で詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="56448ac7090741dff16bd4c666efd111e9722e23" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;suite/0&lt;/code&gt; tells &lt;code&gt;Common Test&lt;/code&gt; to suppress printouts from Telnet and SSH connections. This is valid for all test cases. However, &lt;code&gt;my_testcase1/0&lt;/code&gt; specifies that for this test case, only SSH is to be silent. The result is that &lt;code&gt;my_testcase1&lt;/code&gt; gets Telnet information (if any) printed in the log, but not SSH information. &lt;code&gt;my_testcase2&lt;/code&gt; gets no information from either connection printed.</source>
          <target state="translated">この例では、 &lt;code&gt;suite/0&lt;/code&gt; はTelnetおよびSSH接続からの印刷を抑制するように &lt;code&gt;Common Test&lt;/code&gt; に指示しています。これはすべてのテストケースに有効です。ただし、 &lt;code&gt;my_testcase1/0&lt;/code&gt; は、このテストケースではSSHのみがサイレントになることを指定します。その結果、 &lt;code&gt;my_testcase1&lt;/code&gt; はTelnet情報（ある場合）をログに出力しますが、SSH情報は取得しません。 &lt;code&gt;my_testcase2&lt;/code&gt; は、どちらの接続からも情報を取得しません。</target>
        </trans-unit>
        <trans-unit id="9978d9c124f3a9ceaa1001295460a53442590274" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;{Pid, Something}&lt;/code&gt; is received. The received pid is then used to return &lt;code&gt;{goodbye,Pid}&lt;/code&gt;.</source>
          <target state="translated">この例では、 &lt;code&gt;{Pid, Something}&lt;/code&gt; が受信されます。次に、受け取ったpidを使用して &lt;code&gt;{goodbye,Pid}&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="b8cca447955be1a950232a8170dee175e96b1885" translate="yes" xml:space="preserve">
          <source>In this example, a series of bytes is received from an external source and the bytes are then decoded into a valid Erlang term. This was achieved with the call &lt;code&gt;'People':decode('Person',Bytes)&lt;/code&gt;, which returned an Erlang value of the ASN.1 type &lt;code&gt;Person&lt;/code&gt;. Then an answer was constructed and encoded using &lt;code&gt;'People':encode('Person',Answer)&lt;/code&gt;, which takes an instance of a defined ASN.1 type and transforms it to a binary according to the BER or PER encoding rules.</source>
          <target state="translated">この例では、一連のバイトが外部ソースから受信され、バイトは有効なErlang用語にデコードされます。これは、ASN.1タイプの &lt;code&gt;Person&lt;/code&gt; の Erlang値を返す呼び出し &lt;code&gt;'People':decode('Person',Bytes)&lt;/code&gt; で実現されました。次に、回答が作成され、 &lt;code&gt;'People':encode('Person',Answer)&lt;/code&gt; を使用してエンコードされます。これは、定義されたASN.1タイプのインスタンスを取得し、BERまたはPERエンコーディングルールに従ってバイナリに変換します。</target>
        </trans-unit>
        <trans-unit id="5e2e0fa61e63c35e50233a9616eb00e4ea0cac5e" translate="yes" xml:space="preserve">
          <source>In this example, a tracer module with a NIF back end sends a message for each &lt;code&gt;send&lt;/code&gt; trace tag containing only the sender and receiver. Using this tracer module, a much more lightweight message tracer is used, which only records who sent messages to who.</source>
          <target state="translated">この例では、NIFバックエンドを備えたトレーサーモジュールが、送信者と受信者のみを含む &lt;code&gt;send&lt;/code&gt; トレースタグごとにメッセージを送信します。このトレーサモジュールを使用すると、はるかに軽量なメッセージトレーサが使用され、誰が誰にメッセージを送信したかが記録されます。</target>
        </trans-unit>
        <trans-unit id="6d8dde7ce6106260a6067f905d420de2cd6f2ca5" translate="yes" xml:space="preserve">
          <source>In this example, an Erlang runtime system is started with environment variable &lt;code&gt;DISPLAY&lt;/code&gt; set to &lt;code&gt;gin:0&lt;/code&gt;.</source>
          <target state="translated">この例では、Erlangランタイムシステムは、環境変数 &lt;code&gt;DISPLAY&lt;/code&gt; を &lt;code&gt;gin:0&lt;/code&gt; に設定して起動されます。</target>
        </trans-unit>
        <trans-unit id="c3b7e2dc3ec86592b2c4fe3d4be281594efc1a2e" translate="yes" xml:space="preserve">
          <source>In this example, an attempt was made to output the single character 65 with the aid of the string formatting directive &lt;code&gt;&quot;~s&quot;&lt;/code&gt;.</source>
          <target state="translated">この例では、文字列フォーマットディレクティブ &lt;code&gt;&quot;~s&quot;&lt;/code&gt; 〜s &quot;を使用して、1文字65を出力しようとしました。</target>
        </trans-unit>
        <trans-unit id="43586affa45b8e696e51f04b01e7960b0c11c14b" translate="yes" xml:space="preserve">
          <source>In this example, any user tag set in the calling process will be spread to the I/O-server when the io:format call is done.</source>
          <target state="translated">この例では、呼び出しプロセスで設定されたユーザタグは、io:format呼び出しが完了するとI/O-serverに拡散されます。</target>
        </trans-unit>
        <trans-unit id="66bc53b66445d9e9e48935dda092b0ae0570b399" translate="yes" xml:space="preserve">
          <source>In this example, each runtime system have two schedulers each online, and all schedulers online will run on different cores. If we change to one scheduler online on one runtime system, and three schedulers online on the other, all schedulers online will still run on different cores.</source>
          <target state="translated">この例では、各ランタイムシステムは2つのスケジューラをオンラインにしており、オンラインのスケジューラはすべて異なるコアで実行されます。一方のランタイムシステムで1つのスケジューラをオンラインにし、もう一方のランタイムシステムで3つのスケジューラをオンラインにしても、オンラインのスケジューラはすべて異なるコア上で実行されます。</target>
        </trans-unit>
        <trans-unit id="7ecf9ae27bd24989b3021f8b4c4bfca0ad2ceaf5" translate="yes" xml:space="preserve">
          <source>In this example, function &lt;code&gt;terminate/3&lt;/code&gt; locks the door if it is open, so we do not accidentally leave the door open when the supervision tree terminates:</source>
          <target state="translated">この例では、関数 &lt;code&gt;terminate/3&lt;/code&gt; はドアが開いている場合にドアをロックします。そのため、監視ツリーの終了時にドアを誤って開いたままにしないでください。</target>
        </trans-unit>
        <trans-unit id="960ac5061c7b8584acad2089c9295c51aa2f8869" translate="yes" xml:space="preserve">
          <source>In this example, if the first element had been the key, it is much more efficient to match that key in the &lt;code&gt;MatchHead&lt;/code&gt; part than in the &lt;code&gt;MatchConditions&lt;/code&gt; part. The search space of the tables is restricted with regards to the &lt;code&gt;MatchHead&lt;/code&gt; so that only objects with the matching key are searched.</source>
          <target state="translated">最初の要素が鍵となっていた場合は、この例では、それはで、そのキーと一致するようにはるかに効率的である &lt;code&gt;MatchHead&lt;/code&gt; の中より一部 &lt;code&gt;MatchConditions&lt;/code&gt; 一部を。テーブルの検索スペースは &lt;code&gt;MatchHead&lt;/code&gt; に関して制限されているため、一致するキーを持つオブジェクトのみが検索されます。</target>
        </trans-unit>
        <trans-unit id="434bd6540f3c6df5778ba2e32f9a39db0be5e9d8" translate="yes" xml:space="preserve">
          <source>In this example, instead of ignoring button events while in the &lt;code&gt;open&lt;/code&gt; state, we can postpone them and they are queued and later handled in the &lt;code&gt;locked&lt;/code&gt; state:</source>
          <target state="translated">この例では、 &lt;code&gt;open&lt;/code&gt; 状態のときにボタンイベントを無視する代わりに、ボタンのイベントを延期してキューに入れ、後で &lt;code&gt;locked&lt;/code&gt; 状態で処理することができます。</target>
        </trans-unit>
        <trans-unit id="bf50f8222a786a9423d6bbc25bbbef0a7253d10d" translate="yes" xml:space="preserve">
          <source>In this example, the following actions are performed:</source>
          <target state="translated">この例では、以下の動作を行います。</target>
        </trans-unit>
        <trans-unit id="dfa0e603f6362ff9bd3405f39acb715fb921e826" translate="yes" xml:space="preserve">
          <source>In this example, the same ASN.1 specification as in Section &lt;code&gt;&lt;a href=&quot;#Asn1spec&quot;&gt;Writing an Exclusive Decode Instruction&lt;/a&gt;&lt;/code&gt; is used. The following is a valid selective decode instruction:</source>
          <target state="translated">この例では、セクション &lt;code&gt;&lt;a href=&quot;#Asn1spec&quot;&gt;Writing an Exclusive Decode Instruction&lt;/a&gt;&lt;/code&gt; と同じASN.1仕様が使用されています。以下は、有効な選択的デコード命令です。</target>
        </trans-unit>
        <trans-unit id="e3527cbb7e8c4dd557e4aee1d0751b68ffeeff64" translate="yes" xml:space="preserve">
          <source>In this example, the test terms defined in files &quot;b.spec&quot; and &quot;c.spec&quot; are joined with the terms in source specification &quot;a.spec&quot; (if any). The inclusion of specifications &quot;d.spec&quot; and &quot;e.spec&quot; results in two separate, and independent, test runs (one for each included specification).</source>
          <target state="translated">この例では、ファイル &quot;b.spec &quot;および &quot;c.spec &quot;で定義されたテスト用語は、ソース仕様 &quot;a.spec &quot;の用語と結合されています(もしあれば)。仕様「d.spec」と「e.spec」を含めると、2 つの独立したテスト実行が行われます(含まれる仕様ごとに 1 回ずつ)。</target>
        </trans-unit>
        <trans-unit id="591e558504b589362aa8ec521cf9d41254ba089c" translate="yes" xml:space="preserve">
          <source>In this example, we chose to copy the binary content before inserting it in &lt;code&gt;gb_sets:set()&lt;/code&gt; if it references a binary more than twice the data size we want to keep. Of course, different rules apply when copying to different programs.</source>
          <target state="translated">この例では、保持したいデータサイズの2倍を超えるバイナリを参照する場合、 &lt;code&gt;gb_sets:set()&lt;/code&gt; に挿入する前にバイナリコンテンツをコピーすることを選択しました。もちろん、異なるプログラムにコピーする場合、異なるルールが適用されます。</target>
        </trans-unit>
        <trans-unit id="dc86ae4cb1275e535c2e78420e2da7f468d13800" translate="yes" xml:space="preserve">
          <source>In this example, we in put the 'diffie-hellman-group1-sha1' first and also move the &lt;code&gt;'ecdh-sha2-nistp521'&lt;/code&gt; to the end in the kex list, that is, &lt;code&gt;append&lt;/code&gt; it.</source>
          <target state="translated">この例では、「diffie-hellman-group1-sha1」を最初に配置し、 &lt;code&gt;'ecdh-sha2-nistp521'&lt;/code&gt; をkexリストの末尾に移動、つまり &lt;code&gt;append&lt;/code&gt; します。</target>
        </trans-unit>
        <trans-unit id="0bbaf70ab3110bc7a5e89c28c21c815ba1de5783" translate="yes" xml:space="preserve">
          <source>In this example, we use both options (&lt;code&gt;preferred_algorithms&lt;/code&gt; and &lt;code&gt;modify_algorithms&lt;/code&gt;) and also try to prepend an unsupported algorithm. Any unsupported algorithm is quietly removed.</source>
          <target state="translated">この例では、両方のオプション（ &lt;code&gt;preferred_algorithms&lt;/code&gt; および &lt;code&gt;modify_algorithms&lt;/code&gt; ）を使用し、サポートされていないアルゴリズムを付加することも試みます。サポートされていないアルゴリズムは静かに削除されます。</target>
        </trans-unit>
        <trans-unit id="ee5453691e19483eb4be3db95d70cb64c5c4684a" translate="yes" xml:space="preserve">
          <source>In this examples, the definitions from the following ASN.1 specification are used:</source>
          <target state="translated">本例では、以下のASN.1仕様の定義を使用しています。</target>
        </trans-unit>
        <trans-unit id="3b6a8f84b986da01a683c86c723aa87e5db42995" translate="yes" xml:space="preserve">
          <source>In this following example, the password is &lt;code&gt;&quot;abcd1234&quot;&lt;/code&gt;:</source>
          <target state="translated">次の例では、パスワードは &lt;code&gt;&quot;abcd1234&quot;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="ef1f632c9246a97f789f4334b5d6c5e381fbdc5d" translate="yes" xml:space="preserve">
          <source>In this mode the following can be done:</source>
          <target state="translated">このモードでは、以下のようなことができます。</target>
        </trans-unit>
        <trans-unit id="994fd4fb79d55c888264214dbe057f79d04e488e" translate="yes" xml:space="preserve">
          <source>In this module, V is allowed to be empty. The so obtained unique digraph is called the &lt;strong id=&quot;empty_digraph&quot;&gt;empty digraph&lt;/strong&gt;. Both vertices and edges are represented by unique Erlang terms.</source>
          <target state="translated">このモジュールでは、Vを空にすることができます。このようにして得られた固有の有向グラフは、&lt;strong id=&quot;empty_digraph&quot;&gt;空の有向グラフ&lt;/strong&gt;と呼ばれます。頂点とエッジの両方が一意のErlang用語で表されます。</target>
        </trans-unit>
        <trans-unit id="712d363aaa0e39c08276d452dd321570bc580bff" translate="yes" xml:space="preserve">
          <source>In this module, the only families that are considered are families of subsets of some set X; in the following, the word &quot;family&quot; is used for such families of subsets.</source>
          <target state="translated">このモジュールでは、考慮されるのはある集合Xの部分集合の家族だけです。</target>
        </trans-unit>
        <trans-unit id="e66b7cabeee4a12f3d6c96b7b3841a688c3bd15c" translate="yes" xml:space="preserve">
          <source>In this particular case we do not need to cancel the timeout since the timeout event is the only possible reason to change the state from &lt;code&gt;open&lt;/code&gt; to &lt;code&gt;locked&lt;/code&gt;.</source>
          <target state="translated">この特定のケースでは、タイムアウトイベントが状態を &lt;code&gt;open&lt;/code&gt; から &lt;code&gt;locked&lt;/code&gt; に変更する唯一の理由であるため、タイムアウトをキャンセルする必要はありません。</target>
        </trans-unit>
        <trans-unit id="b6554cfbd72e76e1ac3cdf9960a6f08456669452" translate="yes" xml:space="preserve">
          <source>In this particular case, command &lt;code&gt;i&lt;/code&gt; (&quot;interrupt&quot;) terminates the looping program, and command &lt;code&gt;c&lt;/code&gt; connects to the shell again. As the process was running in the background before we killed it, more printouts occur before message &quot;&lt;code&gt;** exception exit: killed&lt;/code&gt;&quot; is shown.</source>
          <target state="translated">この特定のケースでは、コマンド &lt;code&gt;i&lt;/code&gt; （「割り込み」）はループプログラムを終了し、コマンド &lt;code&gt;c&lt;/code&gt; は再びシェルに接続します。プロセスを強制終了する前にプロセスがバックグラウンドで実行されていたため、メッセージ &quot; &lt;code&gt;** exception exit: killed&lt;/code&gt; &quot;が表示される前に、さらに多くの出力が行われます。</target>
        </trans-unit>
        <trans-unit id="a202e49451669337a36807112b38f9adf4744b69" translate="yes" xml:space="preserve">
          <source>In this scenario the lock that protects ets-table &lt;code&gt;mnesia_transient_decision&lt;/code&gt; has spent most of its waiting for. That is 1.8 seconds in a test that run for 60 seconds. The time is also spread on eight different scheduler threads.</source>
          <target state="translated">このシナリオでは、ets-table &lt;code&gt;mnesia_transient_decision&lt;/code&gt; を保護するロックが待機のほとんどを費やしています。これは、60秒間実行されるテストでは1.8秒です。時間は、8つの異なるスケジューラスレッドにも分散されます。</target>
        </trans-unit>
        <trans-unit id="861466576140ad1635f300aa485a4cde311c192e" translate="yes" xml:space="preserve">
          <source>In this section a &lt;code&gt;Domain&lt;/code&gt; field is the transport domain i.e one of &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; or &lt;code&gt;transportDomainUdpIpv6&lt;/code&gt;, and an &lt;code&gt;Addr&lt;/code&gt; field is an &lt;code&gt;{&lt;/code&gt;&lt;code&gt;IpAddr&lt;/code&gt;&lt;code&gt;,IpPort}&lt;/code&gt; tuple.</source>
          <target state="translated">このセクションでは、 &lt;code&gt;Domain&lt;/code&gt; フィールドはトランスポートドメイン、つまり、 &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; または &lt;code&gt;transportDomainUdpIpv6&lt;/code&gt; の 1つであり、 &lt;code&gt;Addr&lt;/code&gt; フィールドは &lt;code&gt;{&lt;/code&gt; &lt;code&gt;IpAddr&lt;/code&gt; &lt;code&gt;,IpPort}&lt;/code&gt; タプルです。</target>
        </trans-unit>
        <trans-unit id="8408871bf44d5f19fd252aea95c29bc2e768f170" translate="yes" xml:space="preserve">
          <source>In this section an &lt;code&gt;Address&lt;/code&gt; field is a &lt;code&gt;{Domain, Addr}&lt;/code&gt; tuple where &lt;code&gt;Domain&lt;/code&gt; is &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; or &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt;, and &lt;code&gt;Addr&lt;/code&gt; is an &lt;code&gt;{&lt;/code&gt;&lt;code&gt;IpAddr&lt;/code&gt;&lt;code&gt;,IpPort}&lt;/code&gt; tuple.</source>
          <target state="translated">このセクションでは、 &lt;code&gt;Address&lt;/code&gt; フィールドは &lt;code&gt;{Domain, Addr}&lt;/code&gt; タプルであり、 &lt;code&gt;Domain&lt;/code&gt; は &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; または &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; で、 &lt;code&gt;Addr&lt;/code&gt; は &lt;code&gt;{&lt;/code&gt; &lt;code&gt;IpAddr&lt;/code&gt; &lt;code&gt;,IpPort}&lt;/code&gt; タプルです。</target>
        </trans-unit>
        <trans-unit id="99f63d92bf0f7c0a3f35d120e4d7baace3952b21" translate="yes" xml:space="preserve">
          <source>In this section, all valid Erlang expressions are listed. When writing Erlang programs, it is also allowed to use macro- and record expressions. However, these expressions are expanded during compilation and are in that sense not true Erlang expressions. Macro- and record expressions are covered in separate sections:</source>
          <target state="translated">このセクションでは、すべての有効なErlang式をリストアップしています。Erlangプログラムを書くとき、マクロやレコード式を使うこともできます。しかし、これらの式はコンパイル時に展開されるので、真のErlang式ではありません。マクロ式とレコード式については別のセクションで説明します。</target>
        </trans-unit>
        <trans-unit id="7b4d3e5b6a78745c8c43082e99a7d0df32dc4509" translate="yes" xml:space="preserve">
          <source>In this section, it is assumed that the username is &lt;code&gt;otpuser&lt;/code&gt; and that the home directory of that user is:</source>
          <target state="translated">このセクションでは、ユーザー名は &lt;code&gt;otpuser&lt;/code&gt; であり、そのユーザーのホームディレクトリは次のとおりであると想定しています。</target>
        </trans-unit>
        <trans-unit id="d8badf52dbf4567555546e910013615a3db3a8dd" translate="yes" xml:space="preserve">
          <source>In this section, the following terminology is used:</source>
          <target state="translated">本項では、以下のような用語を使用しています。</target>
        </trans-unit>
        <trans-unit id="7a8d09dba986cc4a1cce2aa142a6efb735508b29" translate="yes" xml:space="preserve">
          <source>In this simple case, the former expression is probably preferable in terms of readability.</source>
          <target state="translated">この単純なケースでは、読みやすさの点で前者の表現の方が好ましいのではないでしょうか。</target>
        </trans-unit>
        <trans-unit id="26a9a0725bf356efe21e2e59d7c4c0fd0009aece" translate="yes" xml:space="preserve">
          <source>In this way you can connect all processes in a transaction together using links. If one of the processes exits abnormally, all the processes in the transaction are killed. As it is often wanted to create a process and link to it at the same time, there is a special BIF, &lt;code&gt;spawn_link&lt;/code&gt; that does the same as &lt;code&gt;spawn&lt;/code&gt;, but also creates a link to the spawned process.</source>
          <target state="translated">このようにして、リンクを使用してトランザクション内のすべてのプロセスを一緒に接続できます。プロセスの1つが異常終了すると、トランザクション内のすべてのプロセスが強制終了されます。多くの場合、同時にそれまでのプロセスとのリンクを作成するために望まれているとして、そこに特別なBIF、ある &lt;code&gt;spawn_link&lt;/code&gt; と同じこと &lt;code&gt;spawn&lt;/code&gt; 、だけでなく、生成されたプロセスへのリンクを作成します。</target>
        </trans-unit>
        <trans-unit id="101b35ccce64e2d00c7201dde3bdfc7472ddac0c" translate="yes" xml:space="preserve">
          <source>In traditional relational database terminology, this operation is called a selection, followed by a projection.</source>
          <target state="translated">伝統的なリレーショナルデータベースの用語では、この操作は選択と呼ばれ、その後に投影が続きます。</target>
        </trans-unit>
        <trans-unit id="1ec3c1eab704912540b1a90c690dfcb4bdf6cc6e" translate="yes" xml:space="preserve">
          <source>In type &lt;code&gt;StartMessage&lt;/code&gt;, the constraint following field &lt;code&gt;content&lt;/code&gt; tells that in a value of type &lt;code&gt;StartMessage&lt;/code&gt; the value in field &lt;code&gt;content&lt;/code&gt; must come from the same object that is chosen by field &lt;code&gt;msgId&lt;/code&gt;.</source>
          <target state="translated">タイプ &lt;code&gt;StartMessage&lt;/code&gt; では、フィールド &lt;code&gt;content&lt;/code&gt; に続く制約は、タイプ &lt;code&gt;StartMessage&lt;/code&gt; の値では、フィールド &lt;code&gt;content&lt;/code&gt; の値がフィールド &lt;code&gt;msgId&lt;/code&gt; で選択された同じオブジェクトから取得される必要があることを示します。</target>
        </trans-unit>
        <trans-unit id="3258ab5defec1c2d9288e54d368e065797c6dfc5" translate="yes" xml:space="preserve">
          <source>In version 3 of the megaco standard the Segmentation package was introduced. Simply, this package defines a procedure to segment megaco messages (transaction replies) when using a transport that does not automatically do this (e.g. UDP). See also &lt;code&gt;&lt;a href=&quot;megaco_encode#handling_versions&quot;&gt;version3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">megaco標準のバージョン3では、セグメンテーションパッケージが導入されました。簡単に言うと、このパッケージは、これを自動的に行わないトランスポート（UDPなど）を使用するときに、megacoメッセージ（トランザクション応答）をセグメント化する手順を定義します。 &lt;code&gt;&lt;a href=&quot;megaco_encode#handling_versions&quot;&gt;version3&lt;/a&gt;&lt;/code&gt; も参照してください。</target>
        </trans-unit>
        <trans-unit id="61a1a66fb7d34cc42d2ce16b8d6f94cde6e973d3" translate="yes" xml:space="preserve">
          <source>In which OTP version was &lt;code&gt;kernel-3.0&lt;/code&gt; introduced?</source>
          <target state="translated">&lt;code&gt;kernel-3.0&lt;/code&gt; はどのOTPバージョンで導入されましたか？</target>
        </trans-unit>
        <trans-unit id="8c5125d1b5f67d94423a5e620a14a0a6f8eab1be" translate="yes" xml:space="preserve">
          <source>In your own trace handler function, call &lt;code&gt;erlang:display/1&lt;/code&gt; instead of an &lt;code&gt;io&lt;/code&gt; function or, if &lt;code&gt;user&lt;/code&gt; is not used as group leader, print to &lt;code&gt;user&lt;/code&gt; instead of the default group leader. Example: &lt;code&gt;io:format(user,Str,Args)&lt;/code&gt;.</source>
          <target state="translated">独自のトレースハンドラー関数で、 &lt;code&gt;io&lt;/code&gt; 関数の代わりに &lt;code&gt;erlang:display/1&lt;/code&gt; を呼び出すか、 &lt;code&gt;user&lt;/code&gt; がグループリーダーとして使用されていない場合は、デフォルトのグループリーダーではなく &lt;code&gt;user&lt;/code&gt; に出力します。例： &lt;code&gt;io:format(user,Str,Args)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd3623c7af3873c7365b3e9ecec792ba6339bafc" translate="yes" xml:space="preserve">
          <source>Inband-Security-Id AVP</source>
          <target state="translated">インバンドセキュリティアイディーエーブイピー</target>
        </trans-unit>
        <trans-unit id="1fcccda86c3d18620423152a36c25cd6e0ea26b2" translate="yes" xml:space="preserve">
          <source>Inband-Security-Id AVP (code 299)</source>
          <target state="translated">インバンドセキュリティ ID AVP (コード 299)</target>
        </trans-unit>
        <trans-unit id="bc29841cf89dc194cd8a81695be51412c487f1e5" translate="yes" xml:space="preserve">
          <source>Inband-Security-Id defaults to the empty list, which is equivalent to a list containing only 0 (NO_INBAND_SECURITY). If 1 (TLS) is specified then TLS is selected if the CER/CEA received from the peer offers it.</source>
          <target state="translated">これは、0(NO_INBAND_SECURITY)のみを含むリストと同等である。1 (TLS)が指定された場合、ピアから受信した CER/CEA がそれを提供している場合、TLS が選択されます。</target>
        </trans-unit>
        <trans-unit id="68aefeb8f958a940e3df275c2e8ab565491e5d57" translate="yes" xml:space="preserve">
          <source>Inbound binary encoding in binaries</source>
          <target state="translated">バイナリでのインバウンドバイナリエンコーディング</target>
        </trans-unit>
        <trans-unit id="d56147eef88de9f893558ccd93afaeb646d97eb3" translate="yes" xml:space="preserve">
          <source>Inbound percent-encoding in lists and binaries</source>
          <target state="translated">リストとバイナリにおけるインバウンドのパーセンテージエンコーディング</target>
        </trans-unit>
        <trans-unit id="4299e563cfdb9c828cf33fe283405a0895b02723" translate="yes" xml:space="preserve">
          <source>Incidentally, when the test case is corrected a bug in &lt;code&gt;channel&lt;/code&gt; should indeed be discovered.</source>
          <target state="translated">ちなみに、テストケースを修正すると、 &lt;code&gt;channel&lt;/code&gt; バグが実際に発見されます。</target>
        </trans-unit>
        <trans-unit id="8d1177bed65615f7e3e96bb2bc20a45bf85a59a4" translate="yes" xml:space="preserve">
          <source>Include &lt;code&gt;dir&lt;/code&gt; in the path for Erlang. This is useful when analyzing files that have &lt;code&gt;-include_lib()&lt;/code&gt; directives.</source>
          <target state="translated">Erlangのパスに &lt;code&gt;dir&lt;/code&gt; を含めます。これは、 &lt;code&gt;-include_lib()&lt;/code&gt; ディレクティブを持つファイルを分析するときに役立ちます。</target>
        </trans-unit>
        <trans-unit id="0e9d42f8b8c943f9e74d7049cab7a4c9266e260a" translate="yes" xml:space="preserve">
          <source>Include directories can also be specified in test specifications, see &lt;code&gt;&lt;a href=&quot;#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ディレクトリも参照、テスト仕様書で指定することができます含める &lt;code&gt;&lt;a href=&quot;#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dc0da023e49fc7b9722125176291007176551c43" translate="yes" xml:space="preserve">
          <source>Include file</source>
          <target state="translated">インクルードファイル</target>
        </trans-unit>
        <trans-unit id="1be005482133f6ba0ad7a717822aee960ab1bc89" translate="yes" xml:space="preserve">
          <source>Include files are typically used for record and macro definitions that are shared by several modules. It is recommended to use the file name extension &lt;code&gt;.hrl&lt;/code&gt; for include files.</source>
          <target state="translated">インクルードファイルは通常、複数のモジュールで共有されるレコードとマクロの定義に使用されます。インクルードファイルには、ファイル名拡張子 &lt;code&gt;.hrl&lt;/code&gt; を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="44d2f9132c06fd784b8209fba5bb20aa3ee8c4fa" translate="yes" xml:space="preserve">
          <source>Include the token text in the token annotation. The text is the part of the input corresponding to the token.</source>
          <target state="translated">トークン注釈にトークンのテキストを含めます。テキストは、トークンに対応する入力の部分です。</target>
        </trans-unit>
        <trans-unit id="1318cfcd94087f09bec8c0a46a0ba00bc818ff6b" translate="yes" xml:space="preserve">
          <source>Include warnings for function calls that ignore a structured return value or do not match against one of many possible return value(s).</source>
          <target state="translated">構造化された戻り値を無視したり、多くの可能性のある戻り値のうちの1つと一致しない関数呼び出しに対する警告を含めました。</target>
        </trans-unit>
        <trans-unit id="787b1e3adc3eb7a1d5a6e75a6a8e36064a54f61d" translate="yes" xml:space="preserve">
          <source>Include warnings for functions that only return by an exception.</source>
          <target state="translated">例外によってのみ返される関数の警告を含めます。</target>
        </trans-unit>
        <trans-unit id="c9c702014dc9102936a21eccc903c8d6fd60705b" translate="yes" xml:space="preserve">
          <source>Include warnings for possible race conditions. Notice that the analysis that finds data races performs intra-procedural data flow analysis and can sometimes explode in time. Enable it at your own risk.</source>
          <target state="translated">レースが発生する可能性のある状態に対する警告を含めます。データの競合を検出する解析は、プロセス内でデータフロー解析を実行するため、時間的に爆発することがあることに注意してください。自己責任で有効にしてください。</target>
        </trans-unit>
        <trans-unit id="c2da810ae50606f552a617f96c162b1a8a5cbb8d" translate="yes" xml:space="preserve">
          <source>Included test messages</source>
          <target state="translated">含まれるテストメッセージ</target>
        </trans-unit>
        <trans-unit id="d01cc8205d9d2d88536ce346d12fc476f915ab3e" translate="yes" xml:space="preserve">
          <source>Includes a section containing call statistics for all calls regardless of process, in the analysis.</source>
          <target state="translated">分析には、プロセスに関係なくすべてのコールのコール統計を含むセクションが含まれています。</target>
        </trans-unit>
        <trans-unit id="529e9b923d0287eecd76a416e52d97fdc8ea0d45" translate="yes" xml:space="preserve">
          <source>Includes a time stamp in all trace messages. The time stamp (Ts) has the same form as returned by &lt;code&gt;erlang:now()&lt;/code&gt;.</source>
          <target state="translated">すべてのトレースメッセージにタイムスタンプを含めます。タイムスタンプ（Ts）は &lt;code&gt;erlang:now()&lt;/code&gt; によって返されるものと同じ形式です。</target>
        </trans-unit>
        <trans-unit id="21580f3961c21f1aceb751d4061a09b3a76955d6" translate="yes" xml:space="preserve">
          <source>Includes an &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; time stamp in all trace messages. The time stamp (Ts) has the same format and value as produced by &lt;code&gt;&lt;a href=&quot;#monotonic_time-1&quot;&gt;erlang:monotonic_time(nanosecond)&lt;/a&gt;&lt;/code&gt;. This flag overrides flag &lt;code&gt;cpu_timestamp&lt;/code&gt;.</source>
          <target state="translated">含ま &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; すべてのトレース・メッセージにタイムスタンプを。タイムスタンプ（Ts）の形式と値は、 &lt;code&gt;&lt;a href=&quot;#monotonic_time-1&quot;&gt;erlang:monotonic_time(nanosecond)&lt;/a&gt;&lt;/code&gt; によって生成されたものと同じです。このフラグはフラグ &lt;code&gt;cpu_timestamp&lt;/code&gt; をオーバーライドします。</target>
        </trans-unit>
        <trans-unit id="7123f161553e4dd460e1a837d1a70b743db16fa4" translate="yes" xml:space="preserve">
          <source>Includes an time stamp consisting of &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; and a monotonically increasing integer in all trace messages. The time stamp (Ts) has the same format and value as produced by &lt;code&gt;{&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#monotonic_time-1&quot;&gt;erlang:monotonic_time(nanosecond)&lt;/a&gt;&lt;/code&gt;&lt;code&gt;,&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#unique_integer-1&quot;&gt;erlang:unique_integer([monotonic])&lt;/a&gt;&lt;/code&gt;&lt;code&gt;}&lt;/code&gt;. This flag overrides flag &lt;code&gt;cpu_timestamp&lt;/code&gt;.</source>
          <target state="translated">すべてのトレースメッセージに、 &lt;code&gt;&lt;a href=&quot;time_correction#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; と単調に増加する整数で構成されるタイムスタンプが含まれます。タイムスタンプ（Ts）の形式と値は、 &lt;code&gt;{&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#monotonic_time-1&quot;&gt;erlang:monotonic_time(nanosecond)&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#unique_integer-1&quot;&gt;erlang:unique_integer([monotonic])&lt;/a&gt;&lt;/code&gt; ） &lt;code&gt;,&lt;/code&gt; erlang：unique_integer（[monotonic]） &lt;code&gt;}&lt;/code&gt; によって生成されるものと同じです。このフラグはフラグ &lt;code&gt;cpu_timestamp&lt;/code&gt; をオーバーライドします。</target>
        </trans-unit>
        <trans-unit id="59a53faa5ece992bf6eb22ad8651276afec5c122" translate="yes" xml:space="preserve">
          <source>Includes custom debug information in the form of a &lt;code&gt;Backend&lt;/code&gt; module with custom &lt;code&gt;Data&lt;/code&gt; in the compiled beam module. The given module must implement a &lt;code&gt;debug_info/4&lt;/code&gt; function and is responsible for generating different code representations, as described in the &lt;code&gt;debug_info&lt;/code&gt; under &lt;code&gt;beam_lib(3)&lt;/code&gt;.</source>
          <target state="translated">コンパイルされたビームモジュールにカスタム &lt;code&gt;Data&lt;/code&gt; を含む &lt;code&gt;Backend&lt;/code&gt; モジュールの形式でカスタムデバッグ情報を含めます。指定されたモジュールは &lt;code&gt;debug_info/4&lt;/code&gt; 関数を実装する必要があり、 &lt;code&gt;beam_lib(3)&lt;/code&gt; の &lt;code&gt;debug_info&lt;/code&gt; で説明されているように、さまざまなコード表現を生成する必要があります。</target>
        </trans-unit>
        <trans-unit id="b72745ef15f97e2eed8ddb85c88ed3745778131f" translate="yes" xml:space="preserve">
          <source>Includes debug information in the form of &lt;code&gt;Erlang Abstract Format&lt;/code&gt; in the &lt;code&gt;debug_info&lt;/code&gt; chunk of the compiled beam module. Tools such as Debugger, Xref, and Cover require the debug information to be included.</source>
          <target state="translated">コンパイルされたビームモジュールの &lt;code&gt;debug_info&lt;/code&gt; チャンクにデバッグ情報を &lt;code&gt;Erlang Abstract Format&lt;/code&gt; で含めます。Debugger、Xref、Coverなどのツールには、デバッグ情報を含める必要があります。</target>
        </trans-unit>
        <trans-unit id="50ee9bd2b0973e0a8782664b4e20754ea8733fba" translate="yes" xml:space="preserve">
          <source>Includes debug information, but encrypts it so that it cannot be accessed without supplying the key. (To give option &lt;code&gt;debug_info&lt;/code&gt; as well is allowed, but not necessary.) Using this option is a good way to always have the debug information available during testing, yet protecting the source code.</source>
          <target state="translated">デバッグ情報を含みますが、キーを提供しないとアクセスできないように暗号化します。（オプション &lt;code&gt;debug_info&lt;/code&gt; を指定することも可能ですが、必須ではありません。）このオプションを使用すると、テスト中にデバッグ情報を常に利用でき、しかもソースコードは保護されます。</target>
        </trans-unit>
        <trans-unit id="805a2af44ca1e2b71562d035c3b42720d4a88944" translate="yes" xml:space="preserve">
          <source>Includes property &lt;code&gt;{role, client | server}&lt;/code&gt;. Currently this is the only predefined property, there can also be user-defined properties. See also application environment variable &lt;code&gt;session_cb_init_args&lt;/code&gt;.</source>
          <target state="translated">プロパティ &lt;code&gt;{role, client | server}&lt;/code&gt; 。現在、これは唯一の事前定義されたプロパティですが、ユーザー定義のプロパティもあります。アプリケーション環境変数 &lt;code&gt;session_cb_init_args&lt;/code&gt; も参照してください。</target>
        </trans-unit>
        <trans-unit id="7705cf570e0db2364f0a8b0f968c2b052243e5be" translate="yes" xml:space="preserve">
          <source>Incoming Connections</source>
          <target state="translated">着信接続</target>
        </trans-unit>
        <trans-unit id="cfffe82b107254cee4127c092afe584c0200b55a" translate="yes" xml:space="preserve">
          <source>Incoming Diameter messages are decoded from binary() before being communicated to &lt;code&gt;diameter_app(3)&lt;/code&gt; callbacks. Similarly, outgoing Diameter messages are encoded into binary() before being passed to the appropriate &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt; module for transmission. The functions documented here implement the default encode/decode.</source>
          <target state="translated">着信Diameterメッセージは、 &lt;code&gt;diameter_app(3)&lt;/code&gt; コールバックに伝達される前に、binary（）からデコードされます。同様に、発信Diameterメッセージは、送信用の適切な &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt; モジュールに渡される前に、binary（）にエンコードされます。ここに記載されている関数は、デフォルトのエンコード/デコードを実装しています。</target>
        </trans-unit>
        <trans-unit id="c632222fe59d6393835f1d6b41daa8dcbb54dc28" translate="yes" xml:space="preserve">
          <source>Incoming messages is delivered by megaco:receive_message/4 and normally decoded successfully. But if the decoding failed this function is called in order to decide if the originator should get a reply message (reply) or if the reply silently should be discarded (no_reply).</source>
          <target state="translated">着信メッセージは megaco:receive_message/4 で配信され、通常は正常にデコードされます。しかし、デコードに失敗した場合、この関数が呼ばれ、発信者が返信メッセージを受け取るべきか (返信)、それとも無言で返信を破棄すべきか (no_reply)を判断するために呼び出されます。</target>
        </trans-unit>
        <trans-unit id="bbb9b00cfc07d6474962cea0fb79594d0c7f33f6" translate="yes" xml:space="preserve">
          <source>Incoming messages is delivered by megaco:receive_message/4 and successfully decoded. Normally a message contains a list of transactions and this function is invoked for each TransactionRequest in the message.</source>
          <target state="translated">受信したメッセージは、megaco:receive_message/4によって配信され、デコードに成功します。通常、メッセージにはトランザクションのリストが含まれており、この関数はメッセージ内の各トランザクションリクエストに対して呼び出されます。</target>
        </trans-unit>
        <trans-unit id="7d2155d7b153e6ddad7244575ab829476e447287" translate="yes" xml:space="preserve">
          <source>Incoming messages is delivered by megaco:receive_message/4 and successfully decoded. Normally a message contains a list of transactions, but it may instead contain an ErrorDescriptor on top level of the message.</source>
          <target state="translated">着信メッセージはmegaco:receive_message/4で配信され、デコードに成功しています。通常、メッセージにはトランザクションのリストが含まれていますが、その代わりにメッセージのトップレベルに ErrorDescriptor が含まれている場合があります。</target>
        </trans-unit>
        <trans-unit id="793c36e1e4e2e9196eba0419d11fe32cd2342b1a" translate="yes" xml:space="preserve">
          <source>Incompatible changes may occur between releases.</source>
          <target state="translated">リリース間で互換性のない変更が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="f5e211548a14ccbf061765bad659c7e963fece50" translate="yes" xml:space="preserve">
          <source>Inconsistent stream state.</source>
          <target state="translated">流れの状態が一貫していない。</target>
        </trans-unit>
        <trans-unit id="f91465c3f77f3d3269bf0de89bd0e5136eadf0ec" translate="yes" xml:space="preserve">
          <source>Incorrect UTF encoding.</source>
          <target state="translated">UTF エンコーディングが正しくありません。</target>
        </trans-unit>
        <trans-unit id="1d24ce4d50ea5331d982cda5d863bb706d720600" translate="yes" xml:space="preserve">
          <source>Increases the suspend count on the process identified by &lt;code&gt;Suspendee&lt;/code&gt; and puts it in the suspended state if it is not already in that state. A suspended process is not scheduled for execution until the process has been resumed.</source>
          <target state="translated">&lt;code&gt;Suspendee&lt;/code&gt; によって識別されたプロセスの中断カウントを増やし、まだその状態になっていない場合は、それを中断状態にします。中断されたプロセスは、プロセスが再開されるまで実行がスケジュールされません。</target>
        </trans-unit>
        <trans-unit id="c1ce75ee57dec21e5d02eb0055b76a4460422603" translate="yes" xml:space="preserve">
          <source>Incremented when NIF library incompatible changes are made to the Erlang runtime system. Normally it suffices to recompile the NIF library when the &lt;code&gt;ERL_NIF_MAJOR_VERSION&lt;/code&gt; has changed, but it can, under rare circumstances, mean that NIF libraries must be slightly modified. If so, this will of course be documented.</source>
          <target state="translated">ErlangランタイムシステムにNIFライブラリの互換性のない変更が加えられると増加します。通常、 &lt;code&gt;ERL_NIF_MAJOR_VERSION&lt;/code&gt; が変更された場合は、NIFライブラリを再コンパイルするだけで十分ですが、まれに、NIFライブラリを少し変更する必要がある場合があります。もしそうなら、これはもちろん文書化されます。</target>
        </trans-unit>
        <trans-unit id="84678a3e577756daefc285cd45b2bc2e297ad5ec" translate="yes" xml:space="preserve">
          <source>Incremented when new features are added. The runtime system uses the minor version to determine what features to use.</source>
          <target state="translated">新しい機能が追加されたときに増加します。ランタイムシステムは、どの機能を使用するかを決定するためにマイナーバージョンを使用します。</target>
        </trans-unit>
        <trans-unit id="57135dbc3bf5f91f10354efacc0f552c2d6e0f14" translate="yes" xml:space="preserve">
          <source>Increments a variable in the MIB with &lt;code&gt;N&lt;/code&gt;, or one if &lt;code&gt;N&lt;/code&gt; is not specified.</source>
          <target state="translated">MIBの変数を &lt;code&gt;N&lt;/code&gt; でインクリメントします &lt;code&gt;N&lt;/code&gt; が指定されていない場合は1 をインクリメントします。</target>
        </trans-unit>
        <trans-unit id="9c9e63796462f25fa87f2866f5f82ef633d51dee" translate="yes" xml:space="preserve">
          <source>Increments map iterator to point to the next key-value entry.</source>
          <target state="translated">次のキー値エントリを指すようにマップ・イテレータをインクリメントします。</target>
        </trans-unit>
        <trans-unit id="8f239c48f8608dfc7dad0cea2bfd35ef11b36366" translate="yes" xml:space="preserve">
          <source>Increments the reference count of the port data lock passed as argument (&lt;code&gt;pdl&lt;/code&gt;).</source>
          <target state="translated">引数（ &lt;code&gt;pdl&lt;/code&gt; ）として渡されたポートデータロックの参照カウントをインクリメントします。</target>
        </trans-unit>
        <trans-unit id="d877566e1bec90ff2d29720de068fd3d3fddd99b" translate="yes" xml:space="preserve">
          <source>Increments the reference count on &lt;code&gt;bin&lt;/code&gt; and returns the reference count reached after the increment.</source>
          <target state="translated">上のインクリメント参照カウント &lt;code&gt;bin&lt;/code&gt; とリターンは参照カウントがインクリメント後に到達しました。</target>
        </trans-unit>
        <trans-unit id="6885d93d080432a665a8c21adf295eb79d2e88f7" translate="yes" xml:space="preserve">
          <source>Increments the variable associated with a discarded pdu. This function can be used when the net_if process receives a &lt;code&gt;discarded_pdu&lt;/code&gt; message from the agent.</source>
          <target state="translated">破棄されたpduに関連付けられた変数をインクリメントします。この関数は、net_ifプロセスがエージェントから &lt;code&gt;discarded_pdu&lt;/code&gt; たpdu メッセージを受信したときに使用できます。</target>
        </trans-unit>
        <trans-unit id="a1dc8ae1f28e23fc7131a69f785c7a7e4f9ac70d" translate="yes" xml:space="preserve">
          <source>Indents a document a number of character positions to the right. Note that &lt;code&gt;N&lt;/code&gt; may be negative, shifting the text to the left, or zero, in which case &lt;code&gt;D&lt;/code&gt; is returned unchanged.</source>
          <target state="translated">文書をいくつかの文字位置で右にインデントします。 &lt;code&gt;N&lt;/code&gt; が負の場合、テキストを左にシフトするかゼロになる場合があることに注意してください。この場合、 &lt;code&gt;D&lt;/code&gt; は変更されずに返されます。</target>
        </trans-unit>
        <trans-unit id="b03e59c23d6f82c97ce8cf0f7790602979c8e4da" translate="yes" xml:space="preserve">
          <source>Indexes do not come for free. They occupy space that is proportional to the table size, and they cause insertions into the table to execute slightly slower.</source>
          <target state="translated">インデックスは無償では提供されません。インデックスはテーブルのサイズに比例したスペースを占有し、テーブルへの挿入の実行が若干遅くなります。</target>
        </trans-unit>
        <trans-unit id="66f3ae8a6cbff45c5e61fef46e620b30441f2993" translate="yes" xml:space="preserve">
          <source>Indexes in a table must be objects, not types (deviates from SMIv1 only).</source>
          <target state="translated">テーブル内のインデックスは、型ではなくオブジェクトでなければなりません(SMIv1のみから逸脱しています)。</target>
        </trans-unit>
        <trans-unit id="9951861c21df18489a5872209655d6f9039b5e2a" translate="yes" xml:space="preserve">
          <source>Indexing</source>
          <target state="translated">Indexing</target>
        </trans-unit>
        <trans-unit id="295bcf395f6ba1c793b51510dd315c49a1cd7e27" translate="yes" xml:space="preserve">
          <source>Indicates a broken link. &lt;code&gt;msg-&amp;gt;to&lt;/code&gt; and &lt;code&gt;msg-&amp;gt;from&lt;/code&gt; contain the pids of the linked processes.</source>
          <target state="translated">リンク切れを示します。 &lt;code&gt;msg-&amp;gt;to&lt;/code&gt; および &lt;code&gt;msg-&amp;gt;from&lt;/code&gt; には、リンクされたプロセスのPIDが含まれています。</target>
        </trans-unit>
        <trans-unit id="6278f3e704c53d6a2b0b2b9ee6bea9f7e00a82d7" translate="yes" xml:space="preserve">
          <source>Indicates a customized prologue file which the user may want to use instead of the default file &lt;code&gt;lib/parsetools/include/yeccpre.hrl&lt;/code&gt; which is otherwise included at the beginning of the resulting parser file. &lt;strong&gt;N.B.&lt;/strong&gt; The &lt;code&gt;Includefile&lt;/code&gt; is included 'as is' in the parser file, so it must not have a module declaration of its own, and it should not be compiled. It must, however, contain the necessary export declarations. The default is indicated by &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">結果のパーサーファイルの先頭に含まれるデフォルトファイル &lt;code&gt;lib/parsetools/include/yeccpre.hrl&lt;/code&gt; の代わりに、ユーザーが使用するカスタマイズされたプロローグファイルを示します。&lt;strong&gt;注&lt;/strong&gt;： &lt;code&gt;Includefile&lt;/code&gt; はパーサーファイルに「そのまま」インクルードされるため、独自のモジュール宣言を含めることはできません。また、コンパイルしないでください。ただし、必要な輸出申告が含まれている必要があります。デフォルトは &lt;code&gt;&quot;&quot;&lt;/code&gt; で示されます。</target>
        </trans-unit>
        <trans-unit id="7baca088d4a47e1b532691a75a666d58750c6872" translate="yes" xml:space="preserve">
          <source>Indicates change of the status of the IP address of the peer specified by &lt;code&gt;addr&lt;/code&gt; within association &lt;code&gt;assoc_id&lt;/code&gt;. Possible values of &lt;code&gt;state&lt;/code&gt; (mostly self-explanatory) include:</source>
          <target state="translated">関連 &lt;code&gt;assoc_id&lt;/code&gt; 内の &lt;code&gt;addr&lt;/code&gt; によって指定されたピアのIPアドレスのステータスの変更を示します。 &lt;code&gt;state&lt;/code&gt; 可能な値（主に説明不要）には、次のものがあります。</target>
        </trans-unit>
        <trans-unit id="c1e223ab1bee245ce8340356f73b51f2137316ba" translate="yes" xml:space="preserve">
          <source>Indicates character range</source>
          <target state="translated">文字範囲を示す</target>
        </trans-unit>
        <trans-unit id="ac69dafa8c067eb5122ac56c8384ac8f712d4875" translate="yes" xml:space="preserve">
          <source>Indicates if all application code paths are to be updated (&lt;code&gt;Bool==true&lt;/code&gt;) or if only code paths for modified applications are to be updated (&lt;code&gt;Bool==false&lt;/code&gt;, default). This option has only effect for other application directories than the default &lt;code&gt;$ROOT/lib/App-Vsn&lt;/code&gt;, that is, application directories specified in argument &lt;code&gt;AppDirs&lt;/code&gt; in a call to &lt;code&gt;&lt;a href=&quot;#create_RELEASES-4&quot;&gt;create_RELEASES/4&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#set_unpacked-2&quot;&gt;set_unpacked/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">すべてのアプリケーションコードパスを更新するか（ &lt;code&gt;Bool==true&lt;/code&gt; ）、変更したアプリケーションのコードパスのみを更新するか（ &lt;code&gt;Bool==false&lt;/code&gt; 、デフォルト）を示します。このオプションは、デフォルトの &lt;code&gt;$ROOT/lib/App-Vsn&lt;/code&gt; 以外のアプリケーションディレクトリ、つまり &lt;code&gt;&lt;a href=&quot;#create_RELEASES-4&quot;&gt;create_RELEASES/4&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;#set_unpacked-2&quot;&gt;set_unpacked/2&lt;/a&gt;&lt;/code&gt; の呼び出しで引数 &lt;code&gt;AppDirs&lt;/code&gt; に指定されたアプリケーションディレクトリにのみ影響します。</target>
        </trans-unit>
        <trans-unit id="5d1928864135bba9ca1e5db7c9ed5c9e48fe306d" translate="yes" xml:space="preserve">
          <source>Indicates if process information is to be collected. If &lt;code&gt;PI = true&lt;/code&gt; (which is default), each process identifier &lt;code&gt;Pid&lt;/code&gt; is replaced by a tuple &lt;code&gt;{Pid,ProcessInfo,Node}&lt;/code&gt;, where &lt;code&gt;ProcessInfo&lt;/code&gt; is the registered process name, its globally registered name, or its initial function. To turn off this functionality, set &lt;code&gt;PI = false&lt;/code&gt;.</source>
          <target state="translated">プロセス情報を収集するかどうかを示します。場合 &lt;code&gt;PI = true&lt;/code&gt; （デフォルト）、識別子各プロセス &lt;code&gt;Pid&lt;/code&gt; タプルに置き換えられ &lt;code&gt;{Pid,ProcessInfo,Node}&lt;/code&gt; 、 &lt;code&gt;ProcessInfo&lt;/code&gt; は、登録プロセス名、そのグローバルに登録された名前、またはその最初の関数です。この機能をオフにするには、 &lt;code&gt;PI = false&lt;/code&gt; に設定します。</target>
        </trans-unit>
        <trans-unit id="b164f888f879044385341ec2797d6c82e6c4e946" translate="yes" xml:space="preserve">
          <source>Indicates if the table is compressed.</source>
          <target state="translated">テーブルが圧縮されているかどうかを示します。</target>
        </trans-unit>
        <trans-unit id="04ae54ea063d09f2c3664e4b4c23adf6f54a8c52" translate="yes" xml:space="preserve">
          <source>Indicates if the table is fixed by any process.</source>
          <target state="translated">何らかの処理でテーブルが固定されているかどうかを示す。</target>
        </trans-unit>
        <trans-unit id="aa89b00792f2ce063403297cd8b1e138fe770604" translate="yes" xml:space="preserve">
          <source>Indicates if the table is named.</source>
          <target state="translated">テーブルに名前が付けられているかどうかを示します。</target>
        </trans-unit>
        <trans-unit id="cf35be555e3459fa6b5edfb9108dbeacc82f59eb" translate="yes" xml:space="preserve">
          <source>Indicates in which phase the child terminated from the supervisor's point of view. This can be &lt;code&gt;start_error&lt;/code&gt;, &lt;code&gt;child_terminated&lt;/code&gt;, or &lt;code&gt;shutdown_error&lt;/code&gt;.</source>
          <target state="translated">監督者の観点から、子がどのフェーズで終了したかを示します。これは、 &lt;code&gt;start_error&lt;/code&gt; 、 &lt;code&gt;child_terminated&lt;/code&gt; 、または &lt;code&gt;shutdown_error&lt;/code&gt; のいずれかです。</target>
        </trans-unit>
        <trans-unit id="fe81303e088259aab453750cd52960b57072562a" translate="yes" xml:space="preserve">
          <source>Indicates that all modules that &lt;strong&gt;must&lt;/strong&gt; be loaded &lt;strong&gt;before&lt;/strong&gt; any processes are started are loaded. In interactive mode, all &lt;code&gt;{primLoad,[Mod]}&lt;/code&gt; commands interpreted after this command are ignored, and these modules are loaded on demand. In embedded mode, &lt;code&gt;kernel_load_completed&lt;/code&gt; is ignored, and all modules are loaded during system start.</source>
          <target state="translated">プロセスが開始さ&lt;strong&gt;れる前&lt;/strong&gt;にロード&lt;strong&gt;する&lt;/strong&gt;&lt;strong&gt;必要&lt;/strong&gt;があるすべてのモジュールがロードさ&lt;strong&gt;れる&lt;/strong&gt;ことを示します。対話モードでは、このコマンドの後に解釈されるすべての &lt;code&gt;{primLoad,[Mod]}&lt;/code&gt; コマンドは無視され、これらのモジュールはオンデマンドでロードされます。組み込みモードでは、 &lt;code&gt;kernel_load_completed&lt;/code&gt; は無視され、システムの起動時にすべてのモジュールがロードされます。</target>
        </trans-unit>
        <trans-unit id="1f9048661a24ae25a077ce5abbcac108d3320208" translate="yes" xml:space="preserve">
          <source>Indicates that an ordinary send operation has occurred. &lt;code&gt;msg-&amp;gt;to&lt;/code&gt; contains the pid of the recipient (the C-node).</source>
          <target state="translated">通常の送信操作が発生したことを示します。 &lt;code&gt;msg-&amp;gt;to&lt;/code&gt; は受信者（Cノード）のPID を含みます。</target>
        </trans-unit>
        <trans-unit id="cbcba1ae27045d37f3db86e74369cc4a7aceb7a1" translate="yes" xml:space="preserve">
          <source>Indicates that no more data is to be sent.</source>
          <target state="translated">データを送信する必要がないことを示します。</target>
        </trans-unit>
        <trans-unit id="8bf849b9fec9e1760cea1c2d5389817b3c0bc05b" translate="yes" xml:space="preserve">
          <source>Indicates that the &lt;code&gt;ssh_client_channel&lt;/code&gt; started for the execution of the command has now been shut down.</source>
          <target state="translated">コマンドの実行のために開始された &lt;code&gt;ssh_client_channel&lt;/code&gt; がシャットダウンされたことを示します。</target>
        </trans-unit>
        <trans-unit id="a5828edbce1099ee1930a44aab4d8fd37ec11d89" translate="yes" xml:space="preserve">
          <source>Indicates that the client is to try to perform Next Protocol Negotiation.</source>
          <target state="translated">クライアントがネクストプロトコルネゴシエーションを実行しようとしていることを示す。</target>
        </trans-unit>
        <trans-unit id="1b5dd8bc7ce080d99125903fe8b90315e92ea02c" translate="yes" xml:space="preserve">
          <source>Indicates that the function must return if the Telnet client is idle (that is, if no data is received) for more than &lt;code&gt;IdleTimeout&lt;/code&gt; milliseconds. Default time-out is 10 seconds.</source>
          <target state="translated">Telnetクライアントが &lt;code&gt;IdleTimeout&lt;/code&gt; ミリ秒を超えてアイドル状態の場合（つまり、データが受信されない場合）に関数が戻る必要があることを示します。デフォルトのタイムアウトは10秒です。</target>
        </trans-unit>
        <trans-unit id="9e67f2121ae2256f3ebfae7320f2bc6126d35396" translate="yes" xml:space="preserve">
          <source>Indicates that the logs are not to be merged according to time-stamp, but processed one file after another (this can be a bit faster).</source>
          <target state="translated">ログがタイムスタンプに従ってマージされるのではなく、1つのファイルから順に処理されることを示しています(これは少し速くなる可能性があります)。</target>
        </trans-unit>
        <trans-unit id="b9a42fd50ec01a86c14c261f603beda5c60f5a57" translate="yes" xml:space="preserve">
          <source>Indicates that the other side sends no more data. This event is sent as a result of calling &lt;code&gt;&lt;a href=&quot;ssh_connection#send_eof-2&quot;&gt;ssh_connection:send_eof/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">反対側がこれ以上データを送信しないことを示します。このイベントは、 &lt;code&gt;&lt;a href=&quot;ssh_connection#send_eof-2&quot;&gt;ssh_connection:send_eof/2&lt;/a&gt;&lt;/code&gt; を呼び出した結果として送信されます。</target>
        </trans-unit>
        <trans-unit id="ed8b1ea4428cfedc7e1254d4ff25775923613c69" translate="yes" xml:space="preserve">
          <source>Indicates that the trace is to be automatically stopped after &lt;code&gt;MSec&lt;/code&gt; milliseconds. &lt;code&gt;StopOpts&lt;/code&gt; are passed to command &lt;code&gt;ttb:stop/2&lt;/code&gt; if specified (default is &lt;code&gt;[]&lt;/code&gt;). Notice that the timing is approximate, as delays related to network communication are always present. The timer starts after &lt;code&gt;ttb:p/2&lt;/code&gt; is issued, so you can set up your trace patterns before.</source>
          <target state="translated">&lt;code&gt;MSec&lt;/code&gt; ミリ秒後にトレースが自動的に停止することを示します。 &lt;code&gt;StopOpts&lt;/code&gt; は、指定されている場合（デフォルトは &lt;code&gt;[]&lt;/code&gt; ）、コマンド &lt;code&gt;ttb:stop/2&lt;/code&gt; に渡されます。ネットワーク通信に関連する遅延が常に存在するため、タイミングは概算です。タイマーは &lt;code&gt;ttb:p/2&lt;/code&gt; が発行された後に開始されるので、前にトレースパターンを設定できます。</target>
        </trans-unit>
        <trans-unit id="ad9cf951fb07996703ea5f15911991b7ead2c767" translate="yes" xml:space="preserve">
          <source>Indicates that there is sufficient input data to get a result. &lt;code&gt;Result&lt;/code&gt; is:</source>
          <target state="translated">結果を取得するのに十分な入力データがあることを示します。 &lt;code&gt;Result&lt;/code&gt; は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="ce31dc16108b768360d358241497a298269b4a82" translate="yes" xml:space="preserve">
          <source>Indicates that this call removed the last &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; from the driver, but there are still open ports using it. When all ports are closed and no new &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; have arrived, the driver is reloaded and the name and memory reclaimed.</source>
          <target state="translated">この呼び出しが最後の &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; をドライバーから削除しましたが、それを使用して開いているポートがまだあることを示します。すべてのポートが閉じられ、新しい &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; が到着しない場合、ドライバーが再ロードされ、名前とメモリが解放されます。</target>
        </trans-unit>
        <trans-unit id="9d25290abdf2e0ca7cc841bfb568813355a0802e" translate="yes" xml:space="preserve">
          <source>Indicates that trace logs are not to be collected after tracing is stopped.</source>
          <target state="translated">トレース停止後にトレースログを収集しないことを示します。</target>
        </trans-unit>
        <trans-unit id="a7ce5c93e6670b3ab25a70739bf3a2b64bf5289d" translate="yes" xml:space="preserve">
          <source>Indicates that trace messages are to be printed on the console as they are received by the tracing process. This implies trace client &lt;code&gt;{local, File}&lt;/code&gt;. If &lt;code&gt;ShellSpec&lt;/code&gt; is &lt;code&gt;only&lt;/code&gt; (instead of &lt;code&gt;true&lt;/code&gt;), no trace logs are stored.</source>
          <target state="translated">トレースプロセスがトレースメッセージを受信すると、トレースメッセージがコンソールに出力されることを示します。これは、トレースクライアント &lt;code&gt;{local, File}&lt;/code&gt; 意味します。 &lt;code&gt;ShellSpec&lt;/code&gt; が（ &lt;code&gt;true&lt;/code&gt; ではなく） &lt;code&gt;only&lt;/code&gt; 場合、トレースログは保存されません。</target>
        </trans-unit>
        <trans-unit id="ca4adbf68227389dc62c330e8e9bac1501e4b85b" translate="yes" xml:space="preserve">
          <source>Indicates the file owner. Ignored for non-Unix file systems.</source>
          <target state="translated">ファイルの所有者を示す。Unix以外のファイルシステムでは無視されます。</target>
        </trans-unit>
        <trans-unit id="6c68113f254ba2ea7ffc965f78681100985873d3" translate="yes" xml:space="preserve">
          <source>Indicates the inets version.</source>
          <target state="translated">イネットのバージョンを示します。</target>
        </trans-unit>
        <trans-unit id="224497035660eaa0bff9029bd6c2cd2438d9b394" translate="yes" xml:space="preserve">
          <source>Indicates the owner of the file. On non-Unix file systems, this field is zero.</source>
          <target state="translated">ファイルの所有者を示します。Unix以外のファイルシステムでは、このフィールドは0です。</target>
        </trans-unit>
        <trans-unit id="b47cb315e9dabaf8faae72ffb461cea7bba28766" translate="yes" xml:space="preserve">
          <source>Indicates the return value to be &lt;code&gt;{stopped, Dir}&lt;/code&gt; and not just &lt;code&gt;stopped&lt;/code&gt;. This implies &lt;code&gt;fetch&lt;/code&gt;.</source>
          <target state="translated">戻り値が単に &lt;code&gt;stopped&lt;/code&gt; ただけでなく &lt;code&gt;{stopped, Dir}&lt;/code&gt; ことを示します。これは &lt;code&gt;fetch&lt;/code&gt; 意味します。</target>
        </trans-unit>
        <trans-unit id="d35b2e4ff0ddad33a5641c5c7f2c271f941aca60" translate="yes" xml:space="preserve">
          <source>Indicates the server will try to perform Application-Layer Protocol Negotiation (ALPN).</source>
          <target state="translated">サーバーがアプリケーション層プロトコルネゴシエーション(ALPN)を実行しようとしていることを示します。</target>
        </trans-unit>
        <trans-unit id="f3f315fb532a3b7264bb002ee89acdb0f4afc9e0" translate="yes" xml:space="preserve">
          <source>Indicates the trace logs to be formatted after tracing is stopped. All logs in the fetch directory are merged.</source>
          <target state="translated">トレース停止後にフォーマットされるトレースログを示します。フェッチディレクトリ内のすべてのログがマージされます。</target>
        </trans-unit>
        <trans-unit id="3d7885720efb295da36f8958002ab554f813fd40" translate="yes" xml:space="preserve">
          <source>Indicates whether the table uses &lt;code&gt;read_concurrency&lt;/code&gt; or not.</source>
          <target state="translated">テーブルが &lt;code&gt;read_concurrency&lt;/code&gt; を使用するかどうかを示します。</target>
        </trans-unit>
        <trans-unit id="0f194418909ecb0776bfd3596100881c33eff9da" translate="yes" xml:space="preserve">
          <source>Indicates whether the table uses &lt;code&gt;write_concurrency&lt;/code&gt;.</source>
          <target state="translated">テーブルが &lt;code&gt;write_concurrency&lt;/code&gt; を使用するかどうかを示します。</target>
        </trans-unit>
        <trans-unit id="69bd50ab548b8102cd9a1fe6230c53d33f12b9be" translate="yes" xml:space="preserve">
          <source>Indication of whether or not capabilities exchange has selected inband security using TLS. &lt;code&gt;Ref&lt;/code&gt; is a reference() that must be included in the &lt;code&gt;{diameter, {tls, Ref}}&lt;/code&gt; reply message to the transport's parent process (see below). &lt;code&gt;Type&lt;/code&gt; is either &lt;code&gt;connect&lt;/code&gt; or &lt;code&gt;accept&lt;/code&gt; depending on whether the process has been started for a connecting or listening transport respectively. &lt;code&gt;Bool&lt;/code&gt; is a boolean() indicating whether or not the transport connection should be upgraded to TLS.</source>
          <target state="translated">機能交換でTLSを使用したインバンドセキュリティが選択されているかどうかを示します。 &lt;code&gt;Ref&lt;/code&gt; はreference（）であり、トランスポートの親プロセスへの &lt;code&gt;{diameter, {tls, Ref}}&lt;/code&gt; 応答メッセージに含める必要があります（以下を参照）。 &lt;code&gt;Type&lt;/code&gt; は、プロセスが接続トランスポートまたはリスニングトランスポートに対してそれぞれ開始されているかどうかに応じて、 &lt;code&gt;connect&lt;/code&gt; または &lt;code&gt;accept&lt;/code&gt; いずれかです。 &lt;code&gt;Bool&lt;/code&gt; は、トランスポート接続をTLSにアップグレードする必要があるかどうかを示すboolean（）です。</target>
        </trans-unit>
        <trans-unit id="05533a98ca1eac044b0fade678b3259891f47860" translate="yes" xml:space="preserve">
          <source>Individual patterns are represented as follows:</source>
          <target state="translated">個々のパターンは以下のように表されます。</target>
        </trans-unit>
        <trans-unit id="62fba71f7f99e1c8a7d2339ef9441f9378f3f692" translate="yes" xml:space="preserve">
          <source>Inferring Session Termination from Origin-State-Id</source>
          <target state="translated">Origin-State-Idからセッションの終了を推定する</target>
        </trans-unit>
        <trans-unit id="68f6c014d38a2a4ded13ed708fa02ce23813c010" translate="yes" xml:space="preserve">
          <source>Infinite loops can be constructed by following a subpattern that can match no characters with a quantifier that has no upper limit, for example:</source>
          <target state="translated">無限ループは、例えば、上限を持たない量詞と文字が一致しないサブパターンをたどることで構築することができます。</target>
        </trans-unit>
        <trans-unit id="3da4edd9211b1f0de62eb4b59bb0f4a07f35071f" translate="yes" xml:space="preserve">
          <source>Inform about delivery result.</source>
          <target state="translated">納品結果についてお知らせします。</target>
        </trans-unit>
        <trans-unit id="2957467750434af57077099e35ef2ac6165d01aa" translate="yes" xml:space="preserve">
          <source>Inform about target addresses.</source>
          <target state="translated">ターゲットアドレスをお知らせします。</target>
        </trans-unit>
        <trans-unit id="90049cac09e82499ae5c45699662d377e2e83121" translate="yes" xml:space="preserve">
          <source>Inform the parent that the transport process with &lt;code&gt;Type=accept&lt;/code&gt; has established a connection with the peer. Not sent if the transport process has &lt;code&gt;Type=connect&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Type=accept&lt;/code&gt; のトランスポートプロセスがピアとの接続を確立したことを親に通知します。トランスポートプロセスに &lt;code&gt;Type=connect&lt;/code&gt; がある場合は送信されません。</target>
        </trans-unit>
        <trans-unit id="b0a5e762b03951002c7550ea2ef3353a81e74fc7" translate="yes" xml:space="preserve">
          <source>Inform the parent that the transport process with &lt;code&gt;Type=connect&lt;/code&gt; has established a connection with a peer. Not sent if the transport process has &lt;code&gt;Type=accept&lt;/code&gt;. &lt;code&gt;Remote&lt;/code&gt; is an arbitrary term that uniquely identifies the remote endpoint to which the transport has connected. A &lt;code&gt;LocalAddr&lt;/code&gt; list has the same semantics as one returned from &lt;code&gt;&lt;a href=&quot;#Mod:start-3&quot;&gt;start/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Type=connect&lt;/code&gt; のトランスポートプロセスがピアとの接続を確立したことを親に通知します。トランスポートプロセスに &lt;code&gt;Type=accept&lt;/code&gt; がある場合は送信されません。 &lt;code&gt;Remote&lt;/code&gt; は、トランスポートが接続しているリモートエンドポイントを一意に識別する任意の用語です。 &lt;code&gt;LocalAddr&lt;/code&gt; はのリストから返されたものと同じ意味を持って &lt;code&gt;&lt;a href=&quot;#Mod:start-3&quot;&gt;start/3&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e2447fae055d21e07237d4cd9806f0d1e44fef23" translate="yes" xml:space="preserve">
          <source>Informally, an I/O list is a deep list of characters and binaries that can be sent to an Erlang port. In BNF, an I/O list is formally defined as follows:</source>
          <target state="translated">非公式には、I/OリストはErlangポートに送ることができる文字とバイナリの深いリストです。BNFでは、I/Oリストは正式には以下のように定義されています。</target>
        </trans-unit>
        <trans-unit id="625b4ee43825e1d7dccb243cb5097290a139ac08" translate="yes" xml:space="preserve">
          <source>Information Object Classes, Information Objects, and Information Object Sets (in the following called classes, objects, and object sets, respectively) are defined in the standard definition X.681. Only a brief explanation is given here.</source>
          <target state="translated">情報オブジェクトクラス、情報オブジェクト、情報オブジェクトセット(以下、それぞれクラス、オブジェクト、オブジェクトセットと呼ぶ)は、標準定義X.681で定義されている。ここでは簡単な説明のみを行う。</target>
        </trans-unit>
        <trans-unit id="a82aa8be7390c90d1ca31ddb9f26374aa32e3de7" translate="yes" xml:space="preserve">
          <source>Information about all debugged processes, that is, all processes that have been or are executing code in interpreted modules</source>
          <target state="translated">すべてのデバッグされたプロセス、つまり解釈されたモジュール内でコードを実行している、または実行中のすべてのプロセスに関する情報</target>
        </trans-unit>
        <trans-unit id="7b5fbcbe4f33b24be7f7dade0473f9e3fd15c849" translate="yes" xml:space="preserve">
          <source>Information about applications is fetched from the script when an upgrade or downgrade is performed.</source>
          <target state="translated">アップグレードやダウングレードが実行されると、アプリケーションに関する情報がスクリプトから取得されます。</target>
        </trans-unit>
        <trans-unit id="727a296b0edd7e6903cb4f17c45d2edcf89ed311" translate="yes" xml:space="preserve">
          <source>Information about implementation of Erlang can, for example, be found, in the following:</source>
          <target state="translated">Erlangの実装に関する情報は、例えば、以下のように見つけることができます。</target>
        </trans-unit>
        <trans-unit id="7c573cb4e686c6d4351b362e3e317ae0cec7f7b7" translate="yes" xml:space="preserve">
          <source>Information about processes that are linked to the crashing process and do not trap exits. These processes are the neighbours that terminate because of this process crash. The information gathered is the same as the information for Crasher, described in the previous item.</source>
          <target state="translated">クラッシュしたプロセスにリンクされていて、出口をトラップしないプロセスに関する情報。これらのプロセスは、このプロセスのクラッシュのために終了する近隣のプロセスです。収集される情報は、前項目で説明した Crasher の情報と同じです。</target>
        </trans-unit>
        <trans-unit id="3d412b1b20ea796db2817fa903c28c18a18ab90f" translate="yes" xml:space="preserve">
          <source>Information about the crashing process, such as initial function call, exit reason, and message queue.</source>
          <target state="translated">初期関数呼び出し、終了理由、メッセージキューなどのクラッシュ処理に関する情報。</target>
        </trans-unit>
        <trans-unit id="aed31395b72e3d4a3ffcf65b21d202b748042b7c" translate="yes" xml:space="preserve">
          <source>Information can be added to an existing PLT using option &lt;code&gt;--add_to_plt&lt;/code&gt;. If you also want to include the Erlang compiler in the PLT and place it in a new PLT, then use the following command:</source>
          <target state="translated">オプション &lt;code&gt;--add_to_plt&lt;/code&gt; を使用して、既存のPLTに情報を追加できます。 ErlangコンパイラもPLTに含めて、新しいPLTに配置する場合は、次のコマンドを使用します。</target>
        </trans-unit>
        <trans-unit id="badb50beadce8a2fedabb18c2c3e47e220d098c1" translate="yes" xml:space="preserve">
          <source>Information function that returns a list of test case properties. (Optional)</source>
          <target state="translated">テストケースのプロパティのリストを返す情報関数。(オプション)</target>
        </trans-unit>
        <trans-unit id="a3358e99a156706a4b02a438de13cfba6a39cfde" translate="yes" xml:space="preserve">
          <source>Information function used to return properties for a test case group. (Optional)</source>
          <target state="translated">テストケースグループのプロパティを返すために使用される情報関数です。(オプション)</target>
        </trans-unit>
        <trans-unit id="b7b69d6b9f543c0eaac78b09bddfd720500262fd" translate="yes" xml:space="preserve">
          <source>Information function used to return properties for the suite. (Optional)</source>
          <target state="translated">スイートのプロパティを返すために使用される情報関数。(オプション)</target>
        </trans-unit>
        <trans-unit id="275d164cb628d42311ae4ac3f05e29648d313888" translate="yes" xml:space="preserve">
          <source>Information functions can also be used for functions &lt;code&gt;init_per_suite&lt;/code&gt;, &lt;code&gt;end_per_suite&lt;/code&gt;, &lt;code&gt;init_per_group&lt;/code&gt;, and &lt;code&gt;end_per_group&lt;/code&gt;, and they work the same way as with the &lt;code&gt;&lt;a href=&quot;#info_function&quot;&gt;Test Case Information Function&lt;/a&gt;&lt;/code&gt;. This is useful, for example, for setting timetraps and requiring external configuration data relevant only for the configuration function in question (without affecting properties set for groups and test cases in the suite).</source>
          <target state="translated">情報関数は、関数 &lt;code&gt;init_per_suite&lt;/code&gt; 、 &lt;code&gt;end_per_suite&lt;/code&gt; 、 &lt;code&gt;init_per_group&lt;/code&gt; 、および &lt;code&gt;end_per_group&lt;/code&gt; にも使用でき、 &lt;code&gt;&lt;a href=&quot;#info_function&quot;&gt;Test Case Information Function&lt;/a&gt;&lt;/code&gt; と同じように機能します。これは、たとえば、タイムトラップを設定し、問題の構成機能にのみ関連する外部構成データを要求する場合に便利です（スイートのグループおよびテストケースに設定されたプロパティには影響しません）。</target>
        </trans-unit>
        <trans-unit id="a4cf2090c576759071b1e7653127fe15f6adfbf5" translate="yes" xml:space="preserve">
          <source>Information is delivered to the receiver through calls to the callback function &lt;code&gt;apply(Module, Function, [ReplyInfo | Args])&lt;/code&gt;.</source>
          <target state="translated">情報は、コールバック関数 &lt;code&gt;apply(Module, Function, [ReplyInfo | Args])&lt;/code&gt; 呼び出しを通じて受信者に配信されます。</target>
        </trans-unit>
        <trans-unit id="0dca988e4a05ad3fbc98691395293e6bd4182b54" translate="yes" xml:space="preserve">
          <source>Information is delivered to the receiver through calls to the provided fun &lt;code&gt;Receiver(ReplyInfo)&lt;/code&gt;.</source>
          <target state="translated">情報は、提供されたfun &lt;code&gt;Receiver(ReplyInfo)&lt;/code&gt; の呼び出しを通じて受信者に配信されます。</target>
        </trans-unit>
        <trans-unit id="cec5dea1f15eeea2c3e84d3e4ca8bca5a2733527" translate="yes" xml:space="preserve">
          <source>Information on the current primary peer address (see below for the format of &lt;code&gt;#sctp_paddrinfo{}&lt;/code&gt;)</source>
          <target state="translated">現在のプライマリピアアドレスに関する情報（ &lt;code&gt;#sctp_paddrinfo{}&lt;/code&gt; 形式については、以下を参照してください）</target>
        </trans-unit>
        <trans-unit id="943263da051924df889852b7d374aa63740830a1" translate="yes" xml:space="preserve">
          <source>Information passed as &lt;code&gt;Allowed&lt;/code&gt; to &lt;code&gt;accept_connection/5&lt;/code&gt;. This field is only mandatory when the remote node initiated the connection. That is, when the connection is set up via &lt;code&gt;&lt;a href=&quot;#accept_connection&quot;&gt;accept_connection/5&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">などの情報が渡された &lt;code&gt;Allowed&lt;/code&gt; に &lt;code&gt;accept_connection/5&lt;/code&gt; 。このフィールドは、リモートノードが接続を開始したときにのみ必須です。つまり、接続が &lt;code&gt;&lt;a href=&quot;#accept_connection&quot;&gt;accept_connection/5&lt;/a&gt;&lt;/code&gt; を介して設定されている場合です。</target>
        </trans-unit>
        <trans-unit id="ade170506ce24c2adf11de9da3bbb7eb70a58a29" translate="yes" xml:space="preserve">
          <source>Information to the trace information file by can be added by calling &lt;code&gt;&lt;a href=&quot;ttb#write_trace_info-2&quot;&gt;ttb:write_trace_info/2&lt;/a&gt;&lt;/code&gt;. Notice that &lt;code&gt;ValueList&lt;/code&gt; always is a list, and if you call &lt;code&gt;write_trace_info/2&lt;/code&gt; many times with the same &lt;code&gt;Key&lt;/code&gt;, the &lt;code&gt;ValueList&lt;/code&gt; is extended with a new value each time.</source>
          <target state="translated">トレース情報ファイルへの情報は、 &lt;code&gt;&lt;a href=&quot;ttb#write_trace_info-2&quot;&gt;ttb:write_trace_info/2&lt;/a&gt;&lt;/code&gt; を呼び出すことによって追加できます。 &lt;code&gt;ValueList&lt;/code&gt; は常にリストであり、同じ &lt;code&gt;Key&lt;/code&gt; で &lt;code&gt;write_trace_info/2&lt;/code&gt; を何度も呼び出す場合、 &lt;code&gt;ValueList&lt;/code&gt; は毎回新しい値で拡張されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="eeecc3d4ea7b1d20860b0092324c40322c7b585f" translate="yes" xml:space="preserve">
          <source>Informational</source>
          <target state="translated">Informational</target>
        </trans-unit>
        <trans-unit id="fde8a0e7f8bd0a412204912650f8bc070489e1ef" translate="yes" xml:space="preserve">
          <source>Informative References</source>
          <target state="translated">参考文献</target>
        </trans-unit>
        <trans-unit id="58823af05ebe1ba3ff034e5ec492dcbd5b2f86cc" translate="yes" xml:space="preserve">
          <source>Inherited</source>
          <target state="translated">Inherited</target>
        </trans-unit>
        <trans-unit id="e10de46302bedac991ba7ad1e088a618722e8fd6" translate="yes" xml:space="preserve">
          <source>Init/end configuration function for a test case</source>
          <target state="translated">テストケースのInit/End設定機能</target>
        </trans-unit>
        <trans-unit id="d015c9ace3c20434d0041ce0cff6ccab9781d84e" translate="yes" xml:space="preserve">
          <source>Init/end configuration function for a test case group</source>
          <target state="translated">テストケースグループのInit/End設定機能</target>
        </trans-unit>
        <trans-unit id="58ae4fa4e4c45a4042a21249a079524cbdf1fa72" translate="yes" xml:space="preserve">
          <source>Init/end configuration function for the test suite</source>
          <target state="translated">テストスイートのInit/End設定機能</target>
        </trans-unit>
        <trans-unit id="04b4f9e33823c16aab76a0d934f32d38d4e5908c" translate="yes" xml:space="preserve">
          <source>Initial actions can be started and performed automatically on test target nodes using test specification term &lt;code&gt;init&lt;/code&gt;.</source>
          <target state="translated">テスト仕様の用語 &lt;code&gt;init&lt;/code&gt; を使用して、初期アクションを開始し、テストターゲットノードで自動的に実行できます。</target>
        </trans-unit>
        <trans-unit id="d2e68d0686900d050b8e51048d38b591ec44cadd" translate="yes" xml:space="preserve">
          <source>Initial callback state. The prevailing state is passed to some &lt;code&gt;diameter_app(3)&lt;/code&gt; callbacks, which can then return a new state. Defaults to the value of the &lt;code&gt;alias&lt;/code&gt; option.</source>
          <target state="translated">初期コールバック状態。一般的な状態は、いくつかの &lt;code&gt;diameter_app(3)&lt;/code&gt; コールバックに渡されます。コールバックは、新しい状態を返すことができます。デフォルトは、 &lt;code&gt;alias&lt;/code&gt; オプションの値です。</target>
        </trans-unit>
        <trans-unit id="11127aa4503fb4c327cb52eefbc283b5b904478b" translate="yes" xml:space="preserve">
          <source>Initial configuration of a user</source>
          <target state="translated">ユーザーの初期設定</target>
        </trans-unit>
        <trans-unit id="f63e2a1458a3165eba761814a98cccd7a36796bc" translate="yes" xml:space="preserve">
          <source>Initial configuring of the benchmark is done. It is time to profile the actual benchmark and Mnesia</source>
          <target state="translated">ベンチマークの初期設定が完了しました。実際のベンチマークとMnesiaをプロファイルする時間です。</target>
        </trans-unit>
        <trans-unit id="fd67134d209d3929a18fd22b2bf93061d0a6fcc9" translate="yes" xml:space="preserve">
          <source>Initial punctuation</source>
          <target state="translated">最初の句読点</target>
        </trans-unit>
        <trans-unit id="7b1e85e5bbe04989425e3d15621533a5999e3cbf" translate="yes" xml:space="preserve">
          <source>Initialization structure read by &lt;code&gt;&lt;a href=&quot;#enif_open_resource_type_x&quot;&gt;enif_open_resource_type_x&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#enif_open_resource_type_x&quot;&gt;enif_open_resource_type_x&lt;/a&gt;&lt;/code&gt; によって読み取られる初期化構造。</target>
        </trans-unit>
        <trans-unit id="7f237c69a9e859db2237946c5d7c0d276ae06c1c" translate="yes" xml:space="preserve">
          <source>Initializes &lt;code&gt;Config&lt;/code&gt; for property testing.</source>
          <target state="translated">プロパティテスト用に &lt;code&gt;Config&lt;/code&gt; を初期化します。</target>
        </trans-unit>
        <trans-unit id="ab1eb197ba5ebd342dc2ee475284fc7e5bf38b6a" translate="yes" xml:space="preserve">
          <source>Initializes a decompression session on zlib stream.</source>
          <target state="translated">zlibストリームの解凍セッションを初期化します。</target>
        </trans-unit>
        <trans-unit id="71cf011a78329c432562646be985f8bd2d74719c" translate="yes" xml:space="preserve">
          <source>Initializes a zlib stream for compression.</source>
          <target state="translated">圧縮のために zlib ストリームを初期化します。</target>
        </trans-unit>
        <trans-unit id="3b0787c54b4aa93c99e4db7e0aa8440f3e95865c" translate="yes" xml:space="preserve">
          <source>Initializes a zlib stream for decompression.</source>
          <target state="translated">解凍用の zlib ストリームを初期化します。</target>
        </trans-unit>
        <trans-unit id="f2ef76634443e1b1606ba6eb2d97778abbd5fbc8" translate="yes" xml:space="preserve">
          <source>Initializes the &lt;code&gt;&lt;a href=&quot;#ErlNifPid&quot;&gt;ErlNifPid&lt;/a&gt;&lt;/code&gt; variable at &lt;code&gt;*pid&lt;/code&gt; to represent the calling process.</source>
          <target state="translated">&lt;code&gt;*pid&lt;/code&gt; で &lt;code&gt;&lt;a href=&quot;#ErlNifPid&quot;&gt;ErlNifPid&lt;/a&gt;&lt;/code&gt; 変数を初期化して、呼び出しプロセスを表します。</target>
        </trans-unit>
        <trans-unit id="3d111765b0e759f11aeb197d3230fefefbab898e" translate="yes" xml:space="preserve">
          <source>Initializes the &lt;code&gt;ec&lt;/code&gt; structure, to identify the node name and cookie of the server. One of them must be called before other functions that works on the &lt;code&gt;ei_cnode&lt;/code&gt; type or a file descriptor associated with a connection to another node is used.</source>
          <target state="translated">サーバーのノード名とCookieを識別するために、 &lt;code&gt;ec&lt;/code&gt; 構造を初期化します。それらの1つは、 &lt;code&gt;ei_cnode&lt;/code&gt; で機能する他の関数の前に呼び出す必要があります。タイプでまたは別のノードへの接続に関連付けられたファイル記述子が使用さ。</target>
        </trans-unit>
        <trans-unit id="27ee5ce539b908b2f9afc72b6ece61043b8b3a2b" translate="yes" xml:space="preserve">
          <source>Initializes the &lt;code&gt;erl_connect&lt;/code&gt; module. In particular, these functions are used to identify the name of the C-node from which they are called. One of these functions must be called before any of the other functions in the &lt;code&gt;erl_connect&lt;/code&gt; module are used.</source>
          <target state="translated">&lt;code&gt;erl_connect&lt;/code&gt; モジュールを初期化します。特に、これらの関数は、呼び出し元のCノードの名前を識別するために使用されます。これらの関数の1つは、 &lt;code&gt;erl_connect&lt;/code&gt; の他の関数の前に呼び出す必要があります。モジュールの使用。</target>
        </trans-unit>
        <trans-unit id="4fff4647fcca281983f6aa36bc54f3d489503d92" translate="yes" xml:space="preserve">
          <source>Initializes the compression dictionary from the specified byte sequence without producing any compressed output.</source>
          <target state="translated">圧縮出力を生成せずに、指定されたバイト列から圧縮辞書を初期化します。</target>
        </trans-unit>
        <trans-unit id="cecdcace992350d4b41d9351d096bb6f4340a901" translate="yes" xml:space="preserve">
          <source>Initializes the context for streaming HMAC operations. &lt;code&gt;Type&lt;/code&gt; determines which hash function to use in the HMAC operation. &lt;code&gt;Key&lt;/code&gt; is the authentication key. The key can be any length.</source>
          <target state="translated">ストリーミングHMAC操作のコンテキストを初期化します。 &lt;code&gt;Type&lt;/code&gt; は、HMAC操作で使用するハッシュ関数を決定します。 &lt;code&gt;Key&lt;/code&gt; は認証キーです。キーの長さは任意です。</target>
        </trans-unit>
        <trans-unit id="58ee8f0d598b1ace76a798b4bc4357923d380ca5" translate="yes" xml:space="preserve">
          <source>Initializes the context for streaming hash operations. &lt;code&gt;Type&lt;/code&gt; determines which digest to use. The returned context should be used as argument to &lt;code&gt;&lt;a href=&quot;#hash_update-2&quot;&gt;hash_update&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ストリーミングハッシュ操作のコンテキストを初期化します。 &lt;code&gt;Type&lt;/code&gt; 、使用するダイジェストを決定します。返されたコンテキストは、 &lt;code&gt;&lt;a href=&quot;#hash_update-2&quot;&gt;hash_update&lt;/a&gt;&lt;/code&gt; の引数として使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="25148288204f1c00d73668550121311425efb10f" translate="yes" xml:space="preserve">
          <source>Initializes the decompression dictionary from the specified uncompressed byte sequence. This function must be called as a response to an inflate operation (eg. &lt;code&gt;&lt;a href=&quot;#safeInflate-2&quot;&gt;safeInflate/2&lt;/a&gt;&lt;/code&gt;) returning &lt;code&gt;{need_dictionary,Adler,Output}&lt;/code&gt; or in the case of deprecated functions, throwing an &lt;code&gt;{'EXIT',{{need_dictionary,Adler},_StackTrace}}&lt;/code&gt; exception.</source>
          <target state="translated">指定された非圧縮バイトシーケンスから解凍ディクショナリを初期化します。この関数は &lt;code&gt;{need_dictionary,Adler,Output}&lt;/code&gt; 返す膨張操作（例： &lt;code&gt;&lt;a href=&quot;#safeInflate-2&quot;&gt;safeInflate/2&lt;/a&gt;&lt;/code&gt; ）への応答として呼び出すか、非推奨の関数の場合は、 &lt;code&gt;{'EXIT',{{need_dictionary,Adler},_StackTrace}}&lt;/code&gt; スローする必要があります。 }}例外。</target>
        </trans-unit>
        <trans-unit id="ac2bef434e9feaa5de169d2c6afbadd5a7c8908f" translate="yes" xml:space="preserve">
          <source>Initializes the state for use in RC4 stream encryption &lt;code&gt;&lt;a href=&quot;#stream_encrypt-2&quot;&gt;stream_encrypt&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#stream_decrypt-2&quot;&gt;stream_decrypt&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">RC4ストリーム暗号化 &lt;code&gt;&lt;a href=&quot;#stream_encrypt-2&quot;&gt;stream_encrypt&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;#stream_decrypt-2&quot;&gt;stream_decrypt&lt;/a&gt;&lt;/code&gt; で使用する状態を初期化します</target>
        </trans-unit>
        <trans-unit id="5663fa60784f6a9095ca4a82fdf76aac4aedd36a" translate="yes" xml:space="preserve">
          <source>Initializes the state for use in streaming AES encryption using Counter mode (CTR). &lt;code&gt;Key&lt;/code&gt; is the AES key and must be either 128, 192, or 256 bits long. &lt;code&gt;IVec&lt;/code&gt; is an arbitrary initializing vector of 128 bits (16 bytes). This state is for use with &lt;code&gt;&lt;a href=&quot;#stream_encrypt-2&quot;&gt;stream_encrypt&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#stream_decrypt-2&quot;&gt;stream_decrypt&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">カウンターモード（CTR）を使用してストリーミングAES暗号化で使用する状態を初期化します。 &lt;code&gt;Key&lt;/code&gt; はAESキーであり、128、192、または256ビットの長さである必要があります。 &lt;code&gt;IVec&lt;/code&gt; は、128ビット（16バイト）の任意の初期化ベクトルです。この状態は、 &lt;code&gt;&lt;a href=&quot;#stream_encrypt-2&quot;&gt;stream_encrypt&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;#stream_decrypt-2&quot;&gt;stream_decrypt&lt;/a&gt;&lt;/code&gt; で使用するためのものです。。</target>
        </trans-unit>
        <trans-unit id="a25db95ace1f2c927c73f5809d432ed6899752c5" translate="yes" xml:space="preserve">
          <source>Initializes the structure pointed to by &lt;code&gt;bin&lt;/code&gt; with a continuous buffer with the same byte content as &lt;code&gt;iolist&lt;/code&gt;. As with &lt;code&gt;inspect_binary&lt;/code&gt;, the data pointed to by &lt;code&gt;bin&lt;/code&gt; is transient and does not need to be released.</source>
          <target state="translated">&lt;code&gt;iolist&lt;/code&gt; と同じバイトコンテンツの連続バッファを使用して、 &lt;code&gt;bin&lt;/code&gt; が指す構造を初期化します。 &lt;code&gt;inspect_binary&lt;/code&gt; と同様に、 &lt;code&gt;bin&lt;/code&gt; が指すデータがは一時的なものであり、解放する必要はありません。</target>
        </trans-unit>
        <trans-unit id="53971700cd909eeea0c14864c58051e869c0d933" translate="yes" xml:space="preserve">
          <source>Initializes the structure pointed to by &lt;code&gt;bin&lt;/code&gt; with information about binary term &lt;code&gt;bin_term&lt;/code&gt;.</source>
          <target state="translated">バイナリ項 &lt;code&gt;bin_term&lt;/code&gt; に関する情報を使用して、 &lt;code&gt;bin&lt;/code&gt; が指す構造を初期化します。ます。</target>
        </trans-unit>
        <trans-unit id="6f1914215cd23f1ae665e3e4aa9c43e473915c1e" translate="yes" xml:space="preserve">
          <source>Initializing &lt;code&gt;Erl_Interface&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Erl_Interface&lt;/code&gt; の初期化</target>
        </trans-unit>
        <trans-unit id="095ce38697e0ac705466cb7422f064715a0a7be2" translate="yes" xml:space="preserve">
          <source>Initializing a database</source>
          <target state="translated">データベースの初期化</target>
        </trans-unit>
        <trans-unit id="142639d39cd6ad6faf1f4a1c6ffbfff03a3e72a6" translate="yes" xml:space="preserve">
          <source>Initializing a new database schema with an attribute that specifies on which node, or nodes, that database is to operate.</source>
          <target state="translated">新しいデータベーススキーマを、そのデータベースがどのノードで動作するかを指定する属性で初期化します。</target>
        </trans-unit>
        <trans-unit id="8af85a22a580244a2da7187be7bcbcb5ef240447" translate="yes" xml:space="preserve">
          <source>Initially 768 words + the size of each element (6 words + the size of Erlang data). The table grows when necessary.</source>
          <target state="translated">最初は768語+各要素のサイズ(6語+Erlangデータのサイズ)。テーブルは必要に応じて大きくなります。</target>
        </trans-unit>
        <trans-unit id="0c0e4c0739e6fa2df487aed1a38bae60d5b44dca" translate="yes" xml:space="preserve">
          <source>Initially, the code path consists of the current working directory and all Erlang object code directories under library directory &lt;code&gt;$OTPROOT/lib&lt;/code&gt;, where &lt;code&gt;$OTPROOT&lt;/code&gt; is the installation directory of Erlang/OTP, &lt;code&gt;code:root_dir()&lt;/code&gt;. Directories can be named &lt;code&gt;Name[-Vsn]&lt;/code&gt; and the code server, by default, chooses the directory with the highest version number among those having the same &lt;code&gt;Name&lt;/code&gt;. Suffix &lt;code&gt;-Vsn&lt;/code&gt; is optional. If an &lt;code&gt;ebin&lt;/code&gt; directory exists under &lt;code&gt;Name[-Vsn]&lt;/code&gt;, this directory is added to the code path.</source>
          <target state="translated">最初、コードパスは、現在の作業ディレクトリと、ライブラリディレクトリ &lt;code&gt;$OTPROOT/lib&lt;/code&gt; 下のすべてのErlangオブジェクトコードディレクトリで構成されます。ここで、 &lt;code&gt;$OTPROOT&lt;/code&gt; はErlang / OTPのインストールディレクトリ、 &lt;code&gt;code:root_dir()&lt;/code&gt; です。ディレクトリには &lt;code&gt;Name[-Vsn]&lt;/code&gt; という名前を付けることができ、コードサーバーでは、デフォルトで、同じ &lt;code&gt;Name&lt;/code&gt; を持つディレクトリの中で最もバージョン番号の高いディレクトリが選択されます。サフィックス &lt;code&gt;-Vsn&lt;/code&gt; はオプションです。 &lt;code&gt;Name[-Vsn]&lt;/code&gt; 下に &lt;code&gt;ebin&lt;/code&gt; ディレクトリが存在する場合、このディレクトリはコードパスに追加されます。</target>
        </trans-unit>
        <trans-unit id="1ef73203a7358f8c0665ad7be5a157f1e4b9f4a0" translate="yes" xml:space="preserve">
          <source>Initially, the code path consists of the current working directory and all object code directories under &lt;code&gt;ROOT/lib&lt;/code&gt;, where &lt;code&gt;ROOT&lt;/code&gt; is the installation directory of Erlang/OTP. Directories can be named &lt;code&gt;Name[-Vsn]&lt;/code&gt;. The code server, by default, chooses the directory with the highest version number among those which have the same &lt;code&gt;Name&lt;/code&gt;. The &lt;code&gt;-Vsn&lt;/code&gt; suffix is optional. If an &lt;code&gt;ebin&lt;/code&gt; directory exists under the &lt;code&gt;Name[-Vsn]&lt;/code&gt; directory, this directory is added to the code path.</source>
          <target state="translated">最初に、コードパスは、現在の作業ディレクトリと下のすべてのオブジェクトコードのディレクトリで構成されてい &lt;code&gt;ROOT/lib&lt;/code&gt; に、 &lt;code&gt;ROOT&lt;/code&gt; はアーラン/ OTPのインストールディレクトリです。ディレクトリには &lt;code&gt;Name[-Vsn]&lt;/code&gt; という名前を付けることができます。デフォルトでは、コードサーバーは、同じ &lt;code&gt;Name&lt;/code&gt; を持つバージョンのうち、バージョン番号が最も大きいディレクトリを選択します。 &lt;code&gt;-Vsn&lt;/code&gt; 接尾辞はオプションです。 &lt;code&gt;Name[-Vsn]&lt;/code&gt; ディレクトリの下に &lt;code&gt;ebin&lt;/code&gt; ディレクトリが存在する場合、このディレクトリはコードパスに追加されます。</target>
        </trans-unit>
        <trans-unit id="73e156d278bb294a1d36b0f1e8eeb76af35c2cea" translate="yes" xml:space="preserve">
          <source>Initiate the discovery process with the manager identified by &lt;code&gt;TargetName&lt;/code&gt; using the notification &lt;code&gt;Notification&lt;/code&gt;.</source>
          <target state="translated">通知 &lt;code&gt;Notification&lt;/code&gt; を使用して、 &lt;code&gt;TargetName&lt;/code&gt; で識別されるマネージャーで検出プロセスを開始します。</target>
        </trans-unit>
        <trans-unit id="9c7e89fc3067a91d9dc22af26a15ef53fe7faa29" translate="yes" xml:space="preserve">
          <source>Initiate the transport service and provide it with a receive handle obtained from megaco:user_info/2.</source>
          <target state="translated">トランスポートサービスを開始し、megaco:user_info/2から取得した受信ハンドルを提供する。</target>
        </trans-unit>
        <trans-unit id="d124310299080eb087672c20f460f474dd7a228b" translate="yes" xml:space="preserve">
          <source>Initiates a new association for socket &lt;code&gt;Socket&lt;/code&gt;, with the peer (SCTP server socket) specified by &lt;code&gt;Addr&lt;/code&gt; and &lt;code&gt;Port&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Addr&lt;/code&gt; および &lt;code&gt;Port&lt;/code&gt; で指定されたピア（SCTPサーバーソケット）を使用して、ソケット &lt;code&gt;Socket&lt;/code&gt; の新しい関連付けを開始します。。</target>
        </trans-unit>
        <trans-unit id="cbce06bee52bd534bac0f1fd879f556b081eb91b" translate="yes" xml:space="preserve">
          <source>Initiates a new handshake. A notable return value is &lt;code&gt;{error, renegotiation_rejected}&lt;/code&gt; indicating that the peer refused to go through with the renegotiation, but the connection is still active using the previously negotiated session.</source>
          <target state="translated">新しいハンドシェイクを開始します。注目すべき戻り値は &lt;code&gt;{error, renegotiation_rejected}&lt;/code&gt; で、ピアが再ネゴシエーションの実行を拒否したが、以前にネゴシエートされたセッションを使用して接続がまだアクティブであることを示しています。</target>
        </trans-unit>
        <trans-unit id="5c1ebc3443b604685c9bbd2239beafaabb442116" translate="yes" xml:space="preserve">
          <source>Initiates a zlib stream for compression.</source>
          <target state="translated">圧縮のために zlib ストリームを開始します。</target>
        </trans-unit>
        <trans-unit id="1829936800429f27b95a3900650dc47d80c4529b" translate="yes" xml:space="preserve">
          <source>Initiates heartbeat immediately</source>
          <target state="translated">すぐに心拍を開始します。</target>
        </trans-unit>
        <trans-unit id="a7b905a30abe8561cdf350ab8f4be5235485bbee" translate="yes" xml:space="preserve">
          <source>Initiates the event handler. Returns &lt;code&gt;Args&lt;/code&gt;, which is to be used in a call to &lt;code&gt;gen_event:add_handler(EventMgr, log_mf_h, Args)&lt;/code&gt;.</source>
          <target state="translated">イベントハンドラーを開始します。返し &lt;code&gt;Args&lt;/code&gt; の呼び出しで使用される、 &lt;code&gt;gen_event:add_handler(EventMgr, log_mf_h, Args)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cb3f35312b4615bd360925cee6cb1cda3648d9e7" translate="yes" xml:space="preserve">
          <source>Initiating discovery towards a manager is done by calling the &lt;code&gt;&lt;a href=&quot;snmpa#discovery&quot;&gt;discovery&lt;/a&gt;&lt;/code&gt; function. The &lt;code&gt;EngineId&lt;/code&gt; field of the target (manager) entry in the &lt;code&gt;&lt;a href=&quot;snmp_agent_config_files#target_addr&quot;&gt;target_addr.conf&lt;/a&gt;&lt;/code&gt; file has to have the value &lt;code&gt;discovery&lt;/code&gt;. Note that if the manager does not respond, the &lt;code&gt;Timeout&lt;/code&gt; and &lt;code&gt;RetryCount&lt;/code&gt; fields decide how long the function will hang before it returns.</source>
          <target state="translated">マネージャーへの発見を開始するには、 &lt;code&gt;&lt;a href=&quot;snmpa#discovery&quot;&gt;discovery&lt;/a&gt;&lt;/code&gt; 関数を呼び出します。 &lt;code&gt;&lt;a href=&quot;snmp_agent_config_files#target_addr&quot;&gt;target_addr.conf&lt;/a&gt;&lt;/code&gt; ファイルのターゲット（マネージャー）エントリーの &lt;code&gt;EngineId&lt;/code&gt; フィールドには、値 &lt;code&gt;discovery&lt;/code&gt; が必要です。マネージャーが応答しない場合、 &lt;code&gt;Timeout&lt;/code&gt; と &lt;code&gt;RetryCount&lt;/code&gt; フィールドは、関数が戻る前にハングする時間を決定することに。</target>
        </trans-unit>
        <trans-unit id="46e460ee323eec031b508ab0863b81f298c0e181" translate="yes" xml:space="preserve">
          <source>Initiation of the system tracer. This is automatically done when a trace port is started with &lt;code&gt;&lt;a href=&quot;ttb#tracer-0&quot;&gt;ttb:tracer/0,1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">システムトレーサーの開始。これは、トレースポートが &lt;code&gt;&lt;a href=&quot;ttb#tracer-0&quot;&gt;ttb:tracer/0,1,2&lt;/a&gt;&lt;/code&gt; で開始されたときに自動的に行われます。</target>
        </trans-unit>
        <trans-unit id="a1e4de183a1e55e20092fbfffb06a3ca6dabef2e" translate="yes" xml:space="preserve">
          <source>Inlining does not necessarily improve running time. For example, inlining can increase Beam stack use, which probably is detrimental to performance for recursive functions.</source>
          <target state="translated">インライン化は必ずしも実行時間を改善するわけではありません。例えば、インライン化はBeamスタックの使用量を増加させる可能性があり、再帰的な関数のパフォーマンスに悪影響を及ぼす可能性があります。</target>
        </trans-unit>
        <trans-unit id="b63d2fcb1c0298d4382222c2fee85ab11fe71d42" translate="yes" xml:space="preserve">
          <source>Inlining is never default. It must be explicitly enabled with a compiler option or a &lt;code&gt;-compile()&lt;/code&gt; attribute in the source module.</source>
          <target state="translated">インライン化はデフォルトではありません。コンパイラオプションまたは &lt;code&gt;-compile()&lt;/code&gt; で明示的に有効にする必要がありますソースモジュールの属性でます。</target>
        </trans-unit>
        <trans-unit id="9684f8c1b7785c7f3b7b0c7da13c9d237117432e" translate="yes" xml:space="preserve">
          <source>Input is the &lt;code&gt;modify_algs_list()&lt;/code&gt; and a set of algorithms &lt;code&gt;A&lt;/code&gt; obtained from the &lt;code&gt;preferred_algorithms&lt;/code&gt; option if existing, or else from the &lt;code&gt;&lt;a href=&quot;ssh#default_algorithms-0&quot;&gt;ssh:default_algorithms/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">入力は、 &lt;code&gt;modify_algs_list()&lt;/code&gt; および一連のアルゴリズム &lt;code&gt;A&lt;/code&gt; です。存在する場合は、 &lt;code&gt;preferred_algorithms&lt;/code&gt; オプションから取得するか、 &lt;code&gt;&lt;a href=&quot;ssh#default_algorithms-0&quot;&gt;ssh:default_algorithms/0&lt;/a&gt;&lt;/code&gt; から取得します。。</target>
        </trans-unit>
        <trans-unit id="7e7e7b17b20df161139e8ef284689d406182e357" translate="yes" xml:space="preserve">
          <source>Inscriptional_Pahlavi</source>
          <target state="translated">Inscriptional_Pahlavi</target>
        </trans-unit>
        <trans-unit id="c38bdc08ad33b7372f9f91847cd5f574862ccea5" translate="yes" xml:space="preserve">
          <source>Inscriptional_Parthian</source>
          <target state="translated">Inscriptional_Parthian</target>
        </trans-unit>
        <trans-unit id="23d75e61604fece9c7dbc8a44250dba16a34606c" translate="yes" xml:space="preserve">
          <source>Insert CRLs into the ssl applications local cache.</source>
          <target state="translated">CRL を ssl アプリケーションのローカルキャッシュに挿入します。</target>
        </trans-unit>
        <trans-unit id="cd5094189bd5cfd6365f179313ffd178fdf639f3" translate="yes" xml:space="preserve">
          <source>Insert a dictionary entry and send a {et, {dict_insert, Key, Val}} tuple to all registered subscribers.</source>
          <target state="translated">辞書エントリを挿入し、登録されているすべての加入者に{et,{dict_insert,Key,Val}}タプルを送信します。</target>
        </trans-unit>
        <trans-unit id="e4cd78fd267862c838a3ab52eeab4765922d4166" translate="yes" xml:space="preserve">
          <source>Insert and lookup times in tables of type &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;bag&lt;/code&gt;, and &lt;code&gt;duplicate_bag&lt;/code&gt; are constant, regardless of the table size. For the &lt;code&gt;ordered_set&lt;/code&gt; datatype, time is proportional to the (binary) logarithm of the number of objects.</source>
          <target state="translated">タイプ &lt;code&gt;set&lt;/code&gt; 、 &lt;code&gt;bag&lt;/code&gt; 、および &lt;code&gt;duplicate_bag&lt;/code&gt; のテーブルの挿入時間とルックアップ時間は、テーブルのサイズに関係なく一定です。ため &lt;code&gt;ordered_set&lt;/code&gt; のデータ型は、時間は、オブジェクトの数の（バイナリ）の対数に比例します。</target>
        </trans-unit>
        <trans-unit id="8d23e9df496d5b5f549fd584b36ee77d8c95cf96" translate="yes" xml:space="preserve">
          <source>Insert previously killed text</source>
          <target state="translated">以前に殺されたテキストを挿入する</target>
        </trans-unit>
        <trans-unit id="3bc9ebf4c62f530cbb1f2b55cfa61617e0d53ff4" translate="yes" xml:space="preserve">
          <source>Insert some data</source>
          <target state="translated">データを挿入する</target>
        </trans-unit>
        <trans-unit id="640a4aeeec0f1ba39ab23368bd04d29b5d8e1a0c" translate="yes" xml:space="preserve">
          <source>Inserting an event replaces the trick of calling your own state handling functions that you often would have to resort to in, for example, &lt;code&gt;&lt;a href=&quot;gen_fsm&quot;&gt;gen_fsm&lt;/a&gt;&lt;/code&gt; to force processing an inserted event before others.</source>
          <target state="translated">イベントを挿入することで、たとえば &lt;code&gt;&lt;a href=&quot;gen_fsm&quot;&gt;gen_fsm&lt;/a&gt;&lt;/code&gt; などで挿入されたイベントを他のイベントより先に処理するように強制する必要のある独自の状態処理関数を呼び出す手間が省かれます。</target>
        </trans-unit>
        <trans-unit id="fd8d30baff70186f2f7aad20b4678282d4900c5d" translate="yes" xml:space="preserve">
          <source>Inserting comments into abstract Erlang syntax trees</source>
          <target state="translated">抽象的なErlangの構文ツリーにコメントを挿入する</target>
        </trans-unit>
        <trans-unit id="341885c8dc77554a3ac76126d852595374756f74" translate="yes" xml:space="preserve">
          <source>Inserting comments into abstract Erlang syntax trees.</source>
          <target state="translated">抽象的なErlangの構文ツリーにコメントを挿入する。</target>
        </trans-unit>
        <trans-unit id="a3d2a2e2f845d7b7a7ee869ede57ddf6daa0a066" translate="yes" xml:space="preserve">
          <source>Insertions and deletions are inefficient for large tables.</source>
          <target state="translated">挿入や削除は、大きなテーブルでは効率が悪い。</target>
        </trans-unit>
        <trans-unit id="4bb765df879b9e1259d0b71afc9c95a90dee1bad" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;Item&lt;/code&gt; as the tail item of queue &lt;code&gt;Q1&lt;/code&gt;. Returns the new queue &lt;code&gt;Q2&lt;/code&gt;.</source>
          <target state="translated">キュー &lt;code&gt;Q1&lt;/code&gt; の最後の &lt;code&gt;Item&lt;/code&gt; としてアイテムを挿入します。新しいキュー &lt;code&gt;Q2&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="0cb0ec71eee2375facccac9dd350eb3632385a27" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;Item&lt;/code&gt; at the front of queue &lt;code&gt;Q1&lt;/code&gt;. Returns the resulting queue &lt;code&gt;Q2&lt;/code&gt;.</source>
          <target state="translated">キュー &lt;code&gt;Q1&lt;/code&gt; の前に &lt;code&gt;Item&lt;/code&gt; を挿入します。結果のキュー &lt;code&gt;Q2&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="bff09ae949ed6c5d82000889e64ff74881a86a81" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;Item&lt;/code&gt; at the head of queue &lt;code&gt;Q1&lt;/code&gt;. Returns the new queue &lt;code&gt;Q2&lt;/code&gt;.</source>
          <target state="translated">キュー &lt;code&gt;Q1&lt;/code&gt; の先頭に &lt;code&gt;Item&lt;/code&gt; を挿入します。新しいキュー &lt;code&gt;Q2&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="bb8be9c95d38e2c2c62d2277f37e3d777ea4428a" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;Item&lt;/code&gt; at the rear of queue &lt;code&gt;Q1&lt;/code&gt;. Returns the resulting queue &lt;code&gt;Q2&lt;/code&gt;.</source>
          <target state="translated">キュー &lt;code&gt;Q1&lt;/code&gt; の後ろに &lt;code&gt;Item&lt;/code&gt; を挿入します。結果のキュー &lt;code&gt;Q2&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="4f86a04b36f84c1791d73ad2f91028f7ab17de69" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;Key&lt;/code&gt; with value &lt;code&gt;Value&lt;/code&gt; into &lt;code&gt;Tree1&lt;/code&gt; and returns the new tree. Assumes that the key is not present in the tree, crashes otherwise.</source>
          <target state="translated">挿入 &lt;code&gt;Key&lt;/code&gt; 値を持つ &lt;code&gt;Value&lt;/code&gt; に &lt;code&gt;Tree1&lt;/code&gt; とは、新しいツリーを返します。キーがツリーに存在しないと想定し、それ以外の場合はクラッシュします。</target>
        </trans-unit>
        <trans-unit id="b0b72cb6b3b7b94bac6237d6384f911cba7c3b63" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;Key&lt;/code&gt; with value &lt;code&gt;Value&lt;/code&gt; into &lt;code&gt;Tree1&lt;/code&gt; if the key is not present in the tree, otherwise updates &lt;code&gt;Key&lt;/code&gt; to value &lt;code&gt;Value&lt;/code&gt; in &lt;code&gt;Tree1&lt;/code&gt;. Returns the new tree.</source>
          <target state="translated">挿入 &lt;code&gt;Key&lt;/code&gt; 値を持つ &lt;code&gt;Value&lt;/code&gt; に &lt;code&gt;Tree1&lt;/code&gt; キーがツリーに存在しない場合は、それ以外の更新 &lt;code&gt;Key&lt;/code&gt; 値に &lt;code&gt;Value&lt;/code&gt; で &lt;code&gt;Tree1&lt;/code&gt; 。新しいツリーを返します。</target>
        </trans-unit>
        <trans-unit id="8e70edfd3b0237725cfb5a40acf9c3b7b150a1b7" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;Sep&lt;/code&gt; between each element in &lt;code&gt;List1&lt;/code&gt;. Has no effect on the empty list and on a singleton list. For example:</source>
          <target state="translated">&lt;code&gt;List1&lt;/code&gt; の各要素の間に &lt;code&gt;Sep&lt;/code&gt; を挿入します。空のリストとシングルトンリストには影響しません。例えば：</target>
        </trans-unit>
        <trans-unit id="a325e6f446aeb80024c65275457065a8938c1716" translate="yes" xml:space="preserve">
          <source>Inserts a new key value tuple into the index structure. If an item with the same key already exists, the new &lt;code&gt;Value&lt;/code&gt; overwrites the old value.</source>
          <target state="translated">新しいキー値タプルをインデックス構造に挿入します。同じキーを持つアイテムがすでに存在する場合、新しい &lt;code&gt;Value&lt;/code&gt; によって古い値が上書きされます。</target>
        </trans-unit>
        <trans-unit id="dd7d42875749ae25962aac0a68ced0a0cdaac6c5" translate="yes" xml:space="preserve">
          <source>Inserts all data in the configuration files into the database and destroys all old data, including the rows with StorageType &lt;code&gt;nonVolatile&lt;/code&gt;. The rows created from the configuration file will have StorageType &lt;code&gt;nonVolatile&lt;/code&gt;.</source>
          <target state="translated">構成ファイル内のすべてのデータをデータベースに挿入し、StorageType &lt;code&gt;nonVolatile&lt;/code&gt; の行を含むすべての古いデータを破棄します。構成ファイルから作成された行には、StorageType &lt;code&gt;nonVolatile&lt;/code&gt; が含まれます。</target>
        </trans-unit>
        <trans-unit id="b2674f03b5ae49062060d17f947dd901cec545e2" translate="yes" xml:space="preserve">
          <source>Inserts all data in the configuration files into the database and destroys all old data.</source>
          <target state="translated">設定ファイル内のすべてのデータをデータベースに挿入し、古いデータをすべて破棄します。</target>
        </trans-unit>
        <trans-unit id="81d473e42a2389c80ba7b8bd8eaae2b9ad9818bb" translate="yes" xml:space="preserve">
          <source>Inserts all data in the configuration files into the database and destroys all old rows with StorageType &lt;code&gt;volatile&lt;/code&gt;. The rows created from the configuration file will have StorageType &lt;code&gt;nonVolatile&lt;/code&gt;.</source>
          <target state="translated">構成ファイル内のすべてのデータをデータベースに挿入し、StorageType &lt;code&gt;volatile&lt;/code&gt; を使用してすべての古い行を破棄します。構成ファイルから作成された行には、StorageType &lt;code&gt;nonVolatile&lt;/code&gt; が含まれます。</target>
        </trans-unit>
        <trans-unit id="8e4c6bfec305d402baf1f6154ff407e6c91aee57" translate="yes" xml:space="preserve">
          <source>Inserts one or more objects into table &lt;code&gt;Name&lt;/code&gt;. If there already exists some object with a key matching the key of any of the specified objects, the table is not updated and &lt;code&gt;false&lt;/code&gt; is returned. Otherwise the objects are inserted and &lt;code&gt;true&lt;/code&gt; returned.</source>
          <target state="translated">1つ以上のオブジェクトをテーブル &lt;code&gt;Name&lt;/code&gt; に挿入します。指定されたオブジェクトのいずれかのキーと一致するキーを持つオブジェクトがすでに存在する場合、テーブルは更新されず、 &lt;code&gt;false&lt;/code&gt; が返されます。それ以外の場合、オブジェクトが挿入され、 &lt;code&gt;true&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="1739eb862c4f44f0c8b8666aa94b12c3c5873c60" translate="yes" xml:space="preserve">
          <source>Inserts one or more objects into the table &lt;code&gt;Name&lt;/code&gt;. If there already exists an object with a key matching the key of some of the given objects and the table type is &lt;code&gt;set&lt;/code&gt;, the old object will be replaced.</source>
          <target state="translated">テーブル &lt;code&gt;Name&lt;/code&gt; に 1つ以上のオブジェクトを挿入します。指定されたオブジェクトのいくつかのキーと一致するキーを持つオブジェクトがすでに存在し、テーブルタイプが &lt;code&gt;set&lt;/code&gt; 場合、古いオブジェクトが置き換えられます。</target>
        </trans-unit>
        <trans-unit id="876fd5ef2edcb097ef23ce7a73b8560c457972a7" translate="yes" xml:space="preserve">
          <source>Inserts the object or all of the objects in list &lt;code&gt;ObjectOrObjects&lt;/code&gt; into table &lt;code&gt;Tab&lt;/code&gt;.</source>
          <target state="translated">リスト &lt;code&gt;ObjectOrObjects&lt;/code&gt; のオブジェクトまたはすべてのオブジェクトをテーブル &lt;code&gt;Tab&lt;/code&gt; に挿入します。</target>
        </trans-unit>
        <trans-unit id="ae27be6880fa3f4c4317e7fa32cf164938b23b5f" translate="yes" xml:space="preserve">
          <source>Inserts the objects of the Dets table &lt;code&gt;Name&lt;/code&gt; into the ETS table &lt;code&gt;EtsTab&lt;/code&gt;. The order in which the objects are inserted is not specified. The existing objects of the ETS table are kept unless overwritten.</source>
          <target state="translated">Detsテーブル &lt;code&gt;Name&lt;/code&gt; のオブジェクトをETSテーブル &lt;code&gt;EtsTab&lt;/code&gt; に挿入します。オブジェクトが挿入される順序は指定されていません。ETSテーブルの既存のオブジェクトは、上書きされない限り保持されます。</target>
        </trans-unit>
        <trans-unit id="b4bdee8f5d016433edb2959501b5ea73fcb10ffd" translate="yes" xml:space="preserve">
          <source>Inside a character class, \b has a different meaning; it matches the backspace character. If any other of these assertions appears in a character class, by default it matches the corresponding literal character (for example, \B matches the letter B).</source>
          <target state="translated">文字クラスの中では、 \b は異なる意味を持ちます。これらのアサーションのいずれか他のものが文字クラス内に現れた場合、デフォルトでは、対応するリテラル文字にマッチします (例えば、\B は文字 B にマッチします)。</target>
        </trans-unit>
        <trans-unit id="6629b1052ba09388c69c25e3887de5fe2387123b" translate="yes" xml:space="preserve">
          <source>Inside a character class, or if the decimal number following \ is &amp;gt; 7 and there have not been that many capturing subpatterns, PCRE handles \8 and \9 as the literal characters &quot;8&quot; and &quot;9&quot;, and otherwise re-reads up to three octal digits following the backslash, and using them to generate a data character. Any subsequent digits stand for themselves. For example:</source>
          <target state="translated">文字クラス内、または\に続く10進数が7より大きく、キャプチャサブパターンがそれほど多くない場合、PCREは\ 8と\ 9をリテラル文字 &quot;8&quot;と &quot;9&quot;として扱い、それ以外の場合は再読み取りします。バックスラッシュに続く3桁の8進数に変換し、それらを使用してデータ文字を生成します。後続の数字はそれ自体を表します。例えば：</target>
        </trans-unit>
        <trans-unit id="772561da756f5538f076f086e95fd9bb72f9c7ca" translate="yes" xml:space="preserve">
          <source>Inspection of options and the collection of information about tables. As a result, qualifiers are modified during the optimization phase.</source>
          <target state="translated">オプションの検査とテーブルの情報収集。その結果、最適化フェーズでは修飾子が修正されます。</target>
        </trans-unit>
        <trans-unit id="ed15bc5bc33649cbd97c75a190935b6fc664a985" translate="yes" xml:space="preserve">
          <source>Inspects the message queue of the process. The queue is displayed in the Evaluator area.</source>
          <target state="translated">プロセスのメッセージキューを検査します。キューは評価者領域に表示されます。</target>
        </trans-unit>
        <trans-unit id="c41908611056183491b965384931dc36fcce9650" translate="yes" xml:space="preserve">
          <source>Inspects the next function call on the stack, showing the location and variable bindings.</source>
          <target state="translated">スタック上の次の関数呼び出しを検査し、位置と変数のバインディングを表示します。</target>
        </trans-unit>
        <trans-unit id="99dd332d9a6b322e273f2bf083bbb69e0124148d" translate="yes" xml:space="preserve">
          <source>Inspects the previous function call on the stack, showing the location and variable bindings.</source>
          <target state="translated">スタック上の前の関数呼び出しを検査し、位置と変数のバインディングを表示します。</target>
        </trans-unit>
        <trans-unit id="e0e3ac66ea23824a0888a07102b587536d02e2eb" translate="yes" xml:space="preserve">
          <source>Install &lt;code&gt;Common Test Hooks&lt;/code&gt; (similar to &lt;code&gt;ct_run -ch_hooks&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;Common Test Hooks&lt;/code&gt; をインストールします（ &lt;code&gt;ct_run -ch_hooks&lt;/code&gt; と同様）。</target>
        </trans-unit>
        <trans-unit id="f5eb1e91b4143e0bbdfbeefb2ba46df0c77182c0" translate="yes" xml:space="preserve">
          <source>Install &lt;code&gt;event_handler&lt;/code&gt; plugins (similar to &lt;code&gt;ct_run -event_handler&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;event_handler&lt;/code&gt; プラグインをインストールします（ &lt;code&gt;ct_run -event_handler&lt;/code&gt; と同様）。</target>
        </trans-unit>
        <trans-unit id="15c10e0edbffd8d75bb304a5e91c935e1d915d30" translate="yes" xml:space="preserve">
          <source>Install Microsofts Windows SDK 8.1</source>
          <target state="translated">Microsofts Windows SDK 8.1 のインストール</target>
        </trans-unit>
        <trans-unit id="33d5b3ab81816b854714f8f217754d3d00d7f871" translate="yes" xml:space="preserve">
          <source>Install Visual Studio 12.0 (2013)</source>
          <target state="translated">Visual Studio 12.0 (2013)のインストール</target>
        </trans-unit>
        <trans-unit id="922606362e642350b80d6e7820e8b5540da61e4b" translate="yes" xml:space="preserve">
          <source>Install a created target system</source>
          <target state="translated">作成したターゲットシステムのインストール</target>
        </trans-unit>
        <trans-unit id="784778ecb391c0bb8180f39379167dc61078581c" translate="yes" xml:space="preserve">
          <source>Install or unpack it to the pgm folder: Cygwin: &lt;code&gt;DRIVE:/PATH/cygwin/opt/local/pgm&lt;/code&gt; MSYS: &lt;code&gt;DRIVE:/PATH/MinGW/msys/1.0/opt/local/pgm&lt;/code&gt; MSYS2: &lt;code&gt;DRIVE:/PATH/msys&amp;lt;32/64&amp;gt;/opt/local/pgm&lt;/code&gt;</source>
          <target state="translated">pgmフォルダーにインストールまたは解凍します：Cygwin： &lt;code&gt;DRIVE:/PATH/cygwin/opt/local/pgm&lt;/code&gt; MSYS： &lt;code&gt;DRIVE:/PATH/MinGW/msys/1.0/opt/local/pgm&lt;/code&gt; MSYS2： &lt;code&gt;DRIVE:/PATH/msys&amp;lt;32/64&amp;gt;/opt/local/pgm&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5895bd8f7070b66bf6ef0fbd6cb29198cf6422c6" translate="yes" xml:space="preserve">
          <source>Install the lot, especially the modern user interface components, as it's definitely needed. Put &lt;code&gt;makensis&lt;/code&gt; in your path, in my case:</source>
          <target state="translated">ロット、特に最新のユーザーインターフェイスコンポーネントは、絶対に必要なので、インストールしてください。私の場合、あなたのパスに &lt;code&gt;makensis&lt;/code&gt; を入れてください：</target>
        </trans-unit>
        <trans-unit id="dcb4dffdf7e0a85f3c664c1c7c53716ab6be43e4" translate="yes" xml:space="preserve">
          <source>Install using the &lt;code&gt;release&lt;/code&gt; target. Instead of doing &lt;code&gt;make install&lt;/code&gt; you can create the installation in whatever directory you like using the &lt;code&gt;release&lt;/code&gt; target and run the &lt;code&gt;Install&lt;/code&gt; script yourself. &lt;code&gt;RELEASE_ROOT&lt;/code&gt; is used for specifying the directory where the installation should be created. This is what by default ends up under &lt;code&gt;/usr/local/lib/erlang&lt;/code&gt; if you do the install using &lt;code&gt;make install&lt;/code&gt;. All installation paths provided in the &lt;code&gt;configure&lt;/code&gt; phase are ignored, as well as &lt;code&gt;DESTDIR&lt;/code&gt;, and &lt;code&gt;INSTALL_PREFIX&lt;/code&gt;. If you want links from a specific &lt;code&gt;bin&lt;/code&gt; directory to the installation you have to set those up yourself. An example where Erlang/OTP should be located at &lt;code&gt;/home/me/OTP&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;release&lt;/code&gt; ターゲットを使用してインストールします。 &lt;code&gt;make install&lt;/code&gt; を実行する代わりに、 &lt;code&gt;release&lt;/code&gt; ターゲットを使用して好きなディレクトリにインストールを作成し、 &lt;code&gt;Install&lt;/code&gt; スクリプトを自分で実行できます。 &lt;code&gt;RELEASE_ROOT&lt;/code&gt; は、インストールを作成するディレクトリを指定するために使用されます。 &lt;code&gt;make install&lt;/code&gt; を使用してインストールした場合、これはデフォルトで &lt;code&gt;/usr/local/lib/erlang&lt;/code&gt; の下にあります。 &lt;code&gt;configure&lt;/code&gt; フェーズで提供されるすべてのインストールパス、および &lt;code&gt;DESTDIR&lt;/code&gt; と &lt;code&gt;INSTALL_PREFIX&lt;/code&gt; は無視されます。特定の &lt;code&gt;bin&lt;/code&gt; からのリンクが必要な場合あなたがそれらを自分で設定する必要があるインストールへのディレクトリ。Erlang / OTPが &lt;code&gt;/home/me/OTP&lt;/code&gt; にある例：</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="e38432618ce4d39079fc324e614d4d92a2815160" translate="yes" xml:space="preserve">
          <source>Installing</source>
          <target state="translated">Installing</target>
        </trans-unit>
        <trans-unit id="ae2c551e6a734627f9bb26b99844fa20be2bf09e" translate="yes" xml:space="preserve">
          <source>Installing Manually</source>
          <target state="translated">手動でのインストール</target>
        </trans-unit>
        <trans-unit id="75e25ed448b223fc53dd0af23c71cf6acd70383c" translate="yes" xml:space="preserve">
          <source>Installing Using Paths Determined by configure</source>
          <target state="translated">configure で決定されたパスを使用してインストール</target>
        </trans-unit>
        <trans-unit id="37e8b615530d3eddfdf35ea03fe9f1d1df10701f" translate="yes" xml:space="preserve">
          <source>Installing a fallback is a distributed operation, which is &lt;strong&gt;only&lt;/strong&gt; performed on all &lt;code&gt;db_nodes&lt;/code&gt;. The fallback restores the database the next time the system is started. If a &lt;code&gt;Mnesia&lt;/code&gt; node with a fallback installed detects that &lt;code&gt;Mnesia&lt;/code&gt; on another node has died, it unconditionally terminates itself.</source>
          <target state="translated">フォールバックのインストールは、すべての &lt;code&gt;db_nodes&lt;/code&gt; で&lt;strong&gt;のみ&lt;/strong&gt;実行される分散操作です。フォールバックは、次にシステムが起動したときにデータベースを復元します。場合 &lt;code&gt;Mnesia&lt;/code&gt; のフォールバックを持つノードがいることを検出インストール &lt;code&gt;Mnesia&lt;/code&gt; 別のノードでは、死亡したが、それは無条件に自分自身を終了します。</target>
        </trans-unit>
        <trans-unit id="bf8d05868ee0f453c0775974d588edfe5e97fc4f" translate="yes" xml:space="preserve">
          <source>Installing a new release can be time consuming if there are many processes in the system. The reason is that each process must be checked for references to old code before a module can be purged. This check can lead to garbage collections and copying of data.</source>
          <target state="translated">新しいリリースのインストールは、システム内に多くのプロセスがある場合、時間がかかることがあります。モジュールをパージする前に、各プロセスが古いコードへの参照をチェックしなければならないからです。このチェックは、ガベージコレクションやデータのコピーにつながる可能性があります。</target>
        </trans-unit>
        <trans-unit id="65c9d6735d0aa5d00aafa4b2d57376ac26a57083" translate="yes" xml:space="preserve">
          <source>Installing an embedded system</source>
          <target state="translated">組込みシステムの導入</target>
        </trans-unit>
        <trans-unit id="f249b05e1f990b98f6f7c2fa7204014037a42f4b" translate="yes" xml:space="preserve">
          <source>Installing module os_sup in application os_mon</source>
          <target state="translated">アプリケーション os_mon に os_sup モジュールをインストールする</target>
        </trans-unit>
        <trans-unit id="0d6b51117865caef3500da1315942ae925f5b512" translate="yes" xml:space="preserve">
          <source>Installs a backup as fallback. The fallback is used to restore the database at the next startup. Installation of fallbacks requires Erlang to be operational on all the involved nodes, but it does not matter if Mnesia is running or not. The installation of the fallback fails if the local node is not one of the disc-resident nodes in the backup.</source>
          <target state="translated">フォールバックとしてバックアップをインストールします。フォールバックは次の起動時にデータベースをリストアするために使われます。フォールバックのインストールにはErlangが関係するすべてのノードで動作している必要がありますが、Mnesiaが動作しているかどうかは関係ありません。もしローカルノードがバックアップのディスク常駐ノードでない場合、フォールバックのインストールは失敗します。</target>
        </trans-unit>
        <trans-unit id="80bbef4d77254070ebc618b29a62e45e28b022f6" translate="yes" xml:space="preserve">
          <source>Installs a release-dependent file in the release structure. The release-dependent file must be in the release structure when a new release is installed: &lt;code&gt;start.boot&lt;/code&gt;, &lt;code&gt;relup&lt;/code&gt;, and &lt;code&gt;sys.config&lt;/code&gt;.</source>
          <target state="translated">リリース依存ファイルをリリース構造にインストールします。新しいリリースがインストールされるとき、リリース依存ファイルはリリース構造内にある必要があります： &lt;code&gt;start.boot&lt;/code&gt; 、 &lt;code&gt;relup&lt;/code&gt; 、および &lt;code&gt;sys.config&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9cc17758134c369293b8376cf241e90d4ab3c9cf" translate="yes" xml:space="preserve">
          <source>Installs configuration files and event handlers.</source>
          <target state="translated">設定ファイルとイベントハンドラをインストールします。</target>
        </trans-unit>
        <trans-unit id="cd266c6ba0dabab762b2f84c06c3f60e46cbc0a9" translate="yes" xml:space="preserve">
          <source>Installs the specified version &lt;code&gt;Vsn&lt;/code&gt; of the release. Looks first for a &lt;code&gt;relup&lt;/code&gt; file for &lt;code&gt;Vsn&lt;/code&gt; and a script &lt;code&gt;{UpFromVsn,Descr1,Instructions1}&lt;/code&gt; in this file for upgrading from the current version. If not found, the function looks for a &lt;code&gt;relup&lt;/code&gt; file for the current version and a script &lt;code&gt;{Vsn,Descr2,Instructions2}&lt;/code&gt; in this file for downgrading to &lt;code&gt;Vsn&lt;/code&gt;.</source>
          <target state="translated">リリースの指定されたバージョン &lt;code&gt;Vsn&lt;/code&gt; をインストールします。現在のバージョンからアップグレードするために、最初に &lt;code&gt;Vsn&lt;/code&gt; の &lt;code&gt;relup&lt;/code&gt; ファイルと、このファイル内のスクリプト &lt;code&gt;{UpFromVsn,Descr1,Instructions1}&lt;/code&gt; を探します。見つからない場合、関数は現在のバージョンの &lt;code&gt;relup&lt;/code&gt; ファイルと、このファイルで &lt;code&gt;Vsn&lt;/code&gt; にダウングレードするためのスクリプト &lt;code&gt;{Vsn,Descr2,Instructions2}&lt;/code&gt; を探します。</target>
        </trans-unit>
        <trans-unit id="894c05ee140b1e5c4a2d166f027270a4786a5715" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;ANY&lt;/code&gt; and &lt;code&gt;ANY DEFINED BY&lt;/code&gt;, it is recommended to use &lt;code&gt;information object class&lt;/code&gt;, &lt;code&gt;table constraints&lt;/code&gt;, and &lt;code&gt;parameterization&lt;/code&gt;. In particular the construct &lt;code&gt;TYPE-IDENTIFIER.@Type&lt;/code&gt; accomplish the same as the deprecated &lt;code&gt;ANY&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ANY&lt;/code&gt; および &lt;code&gt;ANY DEFINED BY&lt;/code&gt; の代わりに、 &lt;code&gt;information object class&lt;/code&gt; 、 &lt;code&gt;table constraints&lt;/code&gt; 、および &lt;code&gt;parameterization&lt;/code&gt; を使用することをお勧めします。特に、 &lt;code&gt;TYPE-IDENTIFIER.@Type&lt;/code&gt; 構文は、非推奨の &lt;code&gt;ANY&lt;/code&gt; と同じように機能します。</target>
        </trans-unit>
        <trans-unit id="fc7e20b59d61598b6e28276f64b45fa785f43095" translate="yes" xml:space="preserve">
          <source>Instead of bothering with when to cancel a time-out, a late time-out event can be handled by ignoring it if it arrives in a state where it is known to be late.</source>
          <target state="translated">タイムアウトをいつキャンセルするかを悩むのではなく、遅刻することがわかっている状態で到着した場合には無視することで処理することができます。</target>
        </trans-unit>
        <trans-unit id="1ac5e371533e8b9b9bddff06d20eea879128e69a" translate="yes" xml:space="preserve">
          <source>Instead of extracting to a directory, this option gives the result as a list of tuples &lt;code&gt;{Filename, Binary}&lt;/code&gt;, where &lt;code&gt;Binary&lt;/code&gt; is a binary containing the extracted data of the file named &lt;code&gt;Filename&lt;/code&gt; in the tar file.</source>
          <target state="translated">ディレクトリに抽出する代わりに、このオプションはタプルのリスト &lt;code&gt;{Filename, Binary}&lt;/code&gt; として結果を提供します。ここで、 &lt;code&gt;Binary&lt;/code&gt; はtarファイル内の &lt;code&gt;Filename&lt;/code&gt; という名前のファイルの抽出データを含むバイナリです。</target>
        </trans-unit>
        <trans-unit id="4784466e0218483e747807ddebabf7681aeccce8" translate="yes" xml:space="preserve">
          <source>Instead of extracting to the current directory, the result is given as a list of tuples &lt;code&gt;{Filename, Binary}&lt;/code&gt;, where &lt;code&gt;Binary&lt;/code&gt; is a binary containing the extracted data of file &lt;code&gt;Filename&lt;/code&gt; in the zip archive.</source>
          <target state="translated">代わりに、現在のディレクトリに抽出すること、結果はタプルのリストとして与えられる &lt;code&gt;{Filename, Binary}&lt;/code&gt; 、 &lt;code&gt;Binary&lt;/code&gt; ファイルの抽出されたデータを含むバイナリ &lt;code&gt;Filename&lt;/code&gt; zipアーカイブに。</target>
        </trans-unit>
        <trans-unit id="b7a7e21b3061206a522b83d82bc15d0c88d5c34c" translate="yes" xml:space="preserve">
          <source>Instead of inventing an encoding/decoding scheme, the &lt;code&gt;term_to_binary/1&lt;/code&gt; and &lt;code&gt;binary_to_term/1&lt;/code&gt; BIFs are to be used.</source>
          <target state="translated">エンコード/デコード方式を発明する代わりに、 &lt;code&gt;term_to_binary/1&lt;/code&gt; および &lt;code&gt;binary_to_term/1&lt;/code&gt; BIFが使用されます。</target>
        </trans-unit>
        <trans-unit id="957a44da07f45a291c340d2351a1716bd46e06c0" translate="yes" xml:space="preserve">
          <source>Instead of keeping the events after writing them to file, it is possible to remove all stored events after they have successfully written to file (clear).</source>
          <target state="translated">ファイルに書き込んだ後にイベントを保持するのではなく、ファイルに正常に書き込まれた後に、保存されているイベントをすべて削除することができます(clear)。</target>
        </trans-unit>
        <trans-unit id="d6b6ced692332e6827f1ab9c6981a8b233a0df36" translate="yes" xml:space="preserve">
          <source>Instead of making two &lt;strong&gt;complete decodes&lt;/strong&gt; (the normal case of decode), one in the server and one in the addressee, it is only necessary to make one &lt;strong&gt;specialized decode&lt;/strong&gt;(in the server) and another complete decode(in the addressee). This section describes the following two specialized decodes, which support to solve this and similar problems:</source>
          <target state="translated">1つはサーバーで、もう1つは宛先で、2つの&lt;strong&gt;完全なデコード&lt;/strong&gt;（通常のデコードの場合）を行う代わりに、1つの&lt;strong&gt;専用デコード&lt;/strong&gt;（サーバーで）と別の完全なデコード（宛先で）を行うだけで済みます。このセクションでは、次の2つの特殊なデコードについて説明します。これらは、この問題および同様の問題を解決するためにサポートされています。</target>
        </trans-unit>
        <trans-unit id="91c6a0b15ffa9e153241283e847138f73993d2de" translate="yes" xml:space="preserve">
          <source>Instead of passing data between test cases, it is recommended that the test cases read the state from the SUT and perform assertions (that is, let the test case run if the state is as expected, otherwise reset or fail). It is also recommended to use the state to set variables necessary for the test case to execute properly. Common actions can often be implemented as library functions for test cases to call to set the SUT in a required state. (Such common actions can also be separately tested, if necessary, to ensure that they work as expected). It is sometimes also possible, but not always desirable, to group tests together in one test case, that is, let a test case perform a &quot;scenario&quot; test (a test consisting of subtests).</source>
          <target state="translated">テストケース間でデータを渡すのではなく、テストケースがSUTから状態を読み取り、アサーション(状態が期待通りであればテストケースを実行させ、そうでなければリセットまたは失敗)を実行することをお勧めします。また、テストケースが適切に実行されるために必要な変数を設定するために状態を使用することも推奨されます。一般的なアクションは、必要な状態にSUTを設定するために呼び出すテストケースのためのライブラリ関数として実装されることが多いです。そのような共通アクションは、必要に応じて、期待通りに動作することを確認するために個別にテストすることもできる)。1つのテストケースにテストをまとめてグループ化することも可能な場合があるが、必ずしも望ましいとは限らない。</target>
        </trans-unit>
        <trans-unit id="12e2746f238f1ef6d97ef5382070198c881467b2" translate="yes" xml:space="preserve">
          <source>Instead of sending and receiving messages, there are also a number of BIFs that can be used:</source>
          <target state="translated">メッセージを送受信するのではなく、いくつかのBIFを利用することもできます。</target>
        </trans-unit>
        <trans-unit id="b7e7103489360f3cee70f09abebe4add0bd2f172" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;erlang:get_stacktrace/0&lt;/code&gt; to retrieve the call stack back-trace, use the following syntax:</source>
          <target state="translated">&lt;code&gt;erlang:get_stacktrace/0&lt;/code&gt; を使用して呼び出しスタックのバックトレースを取得する代わりに、次の構文を使用します。</target>
        </trans-unit>
        <trans-unit id="ee1209a66a0d33f9394aa6222d618b5c852bc2f2" translate="yes" xml:space="preserve">
          <source>Instead of writing (x, y) in F or x F y, we write F(x) = y when F is a function, and say that F maps x onto y, or that the value of F at x is y.</source>
          <target state="translated">Fに(x,y)を書いたり、x F yと書くのではなく、Fが関数であるときにF(x)=yと書き、Fがxをyに写像する、あるいはxのときのFの値をyとする、ということになります。</target>
        </trans-unit>
        <trans-unit id="a36e0c64e3f3fa49d084296cc4e8951b3a27ede3" translate="yes" xml:space="preserve">
          <source>Instead use the &lt;code&gt;ordsets&lt;/code&gt; module in STDLIB:</source>
          <target state="translated">代わりに、 &lt;code&gt;ordsets&lt;/code&gt; モジュールを使用します。</target>
        </trans-unit>
        <trans-unit id="8284bfaef1136f8c3023ca2dd6044b337e83ed3a" translate="yes" xml:space="preserve">
          <source>Instead, a correct &lt;code&gt;relup&lt;/code&gt; file can be created manually, either from scratch or by editing the generated version. The instructions for starting/stopping &lt;code&gt;ch_app&lt;/code&gt; are replaced by instructions for loading/unloading the application:</source>
          <target state="translated">代わりに、ゼロから、または生成されたバージョンを編集して、正しい &lt;code&gt;relup&lt;/code&gt; ファイルを手動で作成できます。 &lt;code&gt;ch_app&lt;/code&gt; を開始/停止する手順は、アプリケーションをロード/アンロードする手順に置き換えられます。</target>
        </trans-unit>
        <trans-unit id="ba07e35226d0f31a98d4cafeb0c6278cbf810675" translate="yes" xml:space="preserve">
          <source>Instead, write as follows:</source>
          <target state="translated">代わりに、以下のように書きます。</target>
        </trans-unit>
        <trans-unit id="10f4428424192063dd20e3361c36aa4d16de843c" translate="yes" xml:space="preserve">
          <source>Instead:</source>
          <target state="translated">Instead:</target>
        </trans-unit>
        <trans-unit id="9fc643b23198428cdd06035331b0190f9cb1cf31" translate="yes" xml:space="preserve">
          <source>Instruct the network interface process to send the response (acknowledgment) to an inform-request.</source>
          <target state="translated">ネットワーク・インターフェース・プロセスに、情報要求に対する応答(確認応答)を送信するように指示します。</target>
        </trans-unit>
        <trans-unit id="950c248b2e82115897c90fa4bea94141b0b4cd0f" translate="yes" xml:space="preserve">
          <source>Instructions for this are added to the &lt;code&gt;relup&lt;/code&gt; file in the above order. Instructions for upgrading or downgrading between application versions are fetched from the relevant application upgrade files &lt;code&gt;App.appup&lt;/code&gt;, sorted in the same order as when generating a boot script, see &lt;code&gt;&lt;a href=&quot;#make_script-1&quot;&gt;make_script/1,2&lt;/a&gt;&lt;/code&gt;. High-level instructions are translated into low-level instructions and the result is printed to the &lt;code&gt;relup&lt;/code&gt; file.</source>
          <target state="translated">この手順は、上記の順序で &lt;code&gt;relup&lt;/code&gt; ファイルに追加されます。アプリケーションバージョン間のアップグレードまたはダウングレードの手順は、関連するアプリケーションアップグレードファイル &lt;code&gt;App.appup&lt;/code&gt; からフェッチされ、ブートスクリプトの生成時と同じ順序でソートされます &lt;code&gt;&lt;a href=&quot;#make_script-1&quot;&gt;make_script/1,2&lt;/a&gt;&lt;/code&gt; 参照してください。高レベルの命令は低レベルの命令に変換され、結果は &lt;code&gt;relup&lt;/code&gt; ファイルに出力されます。</target>
        </trans-unit>
        <trans-unit id="15a574978b985fb36f19dcd27a57e275c9779736" translate="yes" xml:space="preserve">
          <source>Instructs the compiler to search for include files in the &lt;code&gt;Directory&lt;/code&gt;. When encountering an &lt;code&gt;-include&lt;/code&gt; or &lt;code&gt;-include_lib&lt;/code&gt; directive, the compiler searches for header files in the following directories:</source>
          <target state="translated">&lt;code&gt;Directory&lt;/code&gt; でインクルードファイルを検索するようコンパイラーに指示します。遭遇したとき &lt;code&gt;-include&lt;/code&gt; や &lt;code&gt;-include_lib&lt;/code&gt; ディレクティブ、次のディレクトリにあるヘッダファイルのコンパイラ検索を：</target>
        </trans-unit>
        <trans-unit id="090b6773e54bc64eab02dc4333eb95623d3030be" translate="yes" xml:space="preserve">
          <source>Instructs the server whether to use persistent connections when the client claims to be HTTP/1.1 compliant. Default is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">クライアントがHTTP / 1.1に準拠していると主張した場合に、永続的な接続を使用するかどうかをサーバーに指示します。デフォルトは &lt;code&gt;true&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="2e97bdfc8fc290d16010ddf7b419664bce4b9617" translate="yes" xml:space="preserve">
          <source>Instrumentation Flags</source>
          <target state="translated">計装フラグ</target>
        </trans-unit>
        <trans-unit id="7e107f318ea5b4287f70d2ec329ab60cf318fcd6" translate="yes" xml:space="preserve">
          <source>Instrumentation Functions for SNMP-COMMUNITY-MIB</source>
          <target state="translated">SNMP-COMMUNITY-MIB用計装機能</target>
        </trans-unit>
        <trans-unit id="b5ea15149e34607b8a589fb5bf1d1b743d875810" translate="yes" xml:space="preserve">
          <source>Instrumentation Functions for SNMP-FRAMEWORK-MIB</source>
          <target state="translated">SNMP-FRAMEWORK-MIB用計装機能</target>
        </trans-unit>
        <trans-unit id="6b4f14b977fdbe201544748c402fba9645dfd2c0" translate="yes" xml:space="preserve">
          <source>Instrumentation Functions for SNMP-NOTIFICATION-MIB</source>
          <target state="translated">SNMP-NOTIFICATION-MIB用計装機能</target>
        </trans-unit>
        <trans-unit id="6b69550b40cf6b05f4832bfe56c28495ecf7fe30" translate="yes" xml:space="preserve">
          <source>Instrumentation Functions for SNMP-TARGET-MIB</source>
          <target state="translated">SNMP-TARGET-MIB用計装機能</target>
        </trans-unit>
        <trans-unit id="f65fddfd52fcea283103e339d1c60b0f5ba6c122" translate="yes" xml:space="preserve">
          <source>Instrumentation Functions for SNMP-USER-BASED-SM-MIB</source>
          <target state="translated">SNMP-USER-BASED-SM-MIB用計装機能</target>
        </trans-unit>
        <trans-unit id="d49a7cc7da280cbfd346949bb2a603ee48e8fb05" translate="yes" xml:space="preserve">
          <source>Instrumentation Functions for SNMP-VIEW-BASED-ACM-MIB</source>
          <target state="translated">SNMP-VIEW-BASED-ACMIB用計装機能</target>
        </trans-unit>
        <trans-unit id="d7f6a4f444ab301e6d5e54f70415dd52f590fae1" translate="yes" xml:space="preserve">
          <source>Instrumentation Functions for STANDARD-MIB and SNMPv2-MIB</source>
          <target state="translated">STANDARD-MIBおよびSNMPv2-MIBの計装機能</target>
        </trans-unit>
        <trans-unit id="e47c5f3c57120b008bbaac0ca750237faa5971be" translate="yes" xml:space="preserve">
          <source>Instrumentation can use Distributed Erlang to communicate with an application.</source>
          <target state="translated">計測器はDistributed Erlangを使ってアプリケーションと通信することができます。</target>
        </trans-unit>
        <trans-unit id="d8e54e2e240bbb19f14b4c55bc3b487003ec8395" translate="yes" xml:space="preserve">
          <source>Instrumentation functions must be written for &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; for scalar variables and tables, and for &lt;code&gt;get-next&lt;/code&gt; for tables only. The &lt;code&gt;get-bulk&lt;/code&gt; operation is translated into a series of calls to &lt;code&gt;get-next&lt;/code&gt;.</source>
          <target state="translated">インストルメンテーション関数は、スカラー変数とテーブルの &lt;code&gt;get&lt;/code&gt; と &lt;code&gt;set&lt;/code&gt; 、およびテーブルのみの &lt;code&gt;get-next&lt;/code&gt; に対して作成する必要があります。 &lt;code&gt;get-bulk&lt;/code&gt; 操作はする一連の呼び出しに変換され &lt;code&gt;get-next&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4f47cc59656d4c025462d150f89cebf98c56ae3f" translate="yes" xml:space="preserve">
          <source>Insufficient storage space in system [452].</source>
          <target state="translated">システム内の記憶領域が不足している[452]。</target>
        </trans-unit>
        <trans-unit id="9edcffff4461c9083fbff857f8dcee0f0769cbd4" translate="yes" xml:space="preserve">
          <source>Integer</source>
          <target state="translated">Integer</target>
        </trans-unit>
        <trans-unit id="bab8970ab6c1e2445db3a30cda08c3f08c7ba8ce" translate="yes" xml:space="preserve">
          <source>Integer (24 bits unsigned). Used to limit the size of valid TLS handshake packets to avoid DoS attacks. Defaults to 256*1024.</source>
          <target state="translated">整数 (24 ビット符号なし)。DoS 攻撃を回避するために有効な TLS ハンドシェイクパケットのサイズを制限するために使用します。デフォルトは 256*1024 です。</target>
        </trans-unit>
        <trans-unit id="cd1200dfbc2522df40f5135712d5fcc5350dab3d" translate="yes" xml:space="preserve">
          <source>Integer &lt;code&gt;PreviousSerial&lt;/code&gt; denotes the serial counter passed in the last received message that carried a trace token. If the process is the first in a new sequential trace, &lt;code&gt;PreviousSerial&lt;/code&gt; is set to the value of the process internal &quot;trace clock&quot;.</source>
          <target state="translated">整数 &lt;code&gt;PreviousSerial&lt;/code&gt; は、トレーストークンを伝送した最後に受信したメッセージで渡されたシリアルカウンターを示します。プロセスが新しい順次トレースの最初の場合、 &lt;code&gt;PreviousSerial&lt;/code&gt; はプロセスの内部「トレースクロック」の値に設定されます。</target>
        </trans-unit>
        <trans-unit id="fd0e21bf741b765fbb25882622616e5016575de7" translate="yes" xml:space="preserve">
          <source>Integer &lt;code&gt;ThisSerial&lt;/code&gt; is the serial counter that a process sets on outgoing messages. It is based on the process internal &quot;trace clock&quot;, which is incremented by one before it is attached to the trace token in the message.</source>
          <target state="translated">整数 &lt;code&gt;ThisSerial&lt;/code&gt; は、プロセスが発信メッセージに設定するシリアルカウンターです。これは、プロセスの内部「トレースクロック」に基づいており、メッセージのトレーストークンに添付される前に1ずつ増加します。</target>
        </trans-unit>
        <trans-unit id="70d648e65d494f28a7240688bec60fdcef36d372" translate="yes" xml:space="preserve">
          <source>Integer division</source>
          <target state="translated">整数除算</target>
        </trans-unit>
        <trans-unit id="ae4df4a5ccd3fc7872ad572de0cb764f4a758558" translate="yes" xml:space="preserve">
          <source>Integer remainder of X/Y</source>
          <target state="translated">X/Yの整数残数</target>
        </trans-unit>
        <trans-unit id="d2bea1d11037eb2c7d3d25da5484514181294970" translate="yes" xml:space="preserve">
          <source>Integer representing valid unicode codepoint.</source>
          <target state="translated">有効な Unicode コードポイントを表す整数。</target>
        </trans-unit>
        <trans-unit id="845b1adfda3fcd43e837ece8fd1075b9fd016964" translate="yes" xml:space="preserve">
          <source>Integer values, for example in the &lt;code&gt;SIZE&lt;/code&gt; expression must be entered in decimal syntax, not in hex or bit syntax.</source>
          <target state="translated">たとえば、 &lt;code&gt;SIZE&lt;/code&gt; 式の整数値は、16進やビットの構文ではなく、10進の構文で入力する必要があります。</target>
        </trans-unit>
        <trans-unit id="a84d8938ca4e58573de3fba8872fd63ef8c7c19d" translate="yes" xml:space="preserve">
          <source>Integer with the base &lt;strong&gt;&lt;code&gt;base&lt;/code&gt;&lt;/strong&gt;, that must be an integer in the range 2..36.</source>
          <target state="translated">ベース&lt;strong&gt; &lt;code&gt;base&lt;/code&gt; を&lt;/strong&gt;持つ整数。これは2..36の範囲の整数でなければなりません。</target>
        </trans-unit>
        <trans-unit id="61e3decdf5d6115018a9e34ce42bf8006f9593cd" translate="yes" xml:space="preserve">
          <source>Integers must be in microseconds, meaning that the offset &lt;code&gt;7200000000&lt;/code&gt; is equivalent to &lt;code&gt;&quot;+02:00&quot;&lt;/code&gt;.</source>
          <target state="translated">整数はマイクロ秒でなければなりません。つまり、オフセット &lt;code&gt;7200000000&lt;/code&gt; は &lt;code&gt;&quot;+02:00&quot;&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="7c69ae2cd9192c2c796400efe2ac35c22e2e2ca5" translate="yes" xml:space="preserve">
          <source>Integers out of range.</source>
          <target state="translated">整数は範囲外です。</target>
        </trans-unit>
        <trans-unit id="07e05e6c552c53b1a227c82d017e7aac90837347" translate="yes" xml:space="preserve">
          <source>Integers starting with 909, for example &lt;code&gt;9091&lt;/code&gt; or &lt;code&gt;909123&lt;/code&gt;</source>
          <target state="translated">909で始まる整数（例： &lt;code&gt;9091&lt;/code&gt; または &lt;code&gt;909123&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="60073de1e4b76eca2577f27a28edb01f36540075" translate="yes" xml:space="preserve">
          <source>Intended to facilitate testing.</source>
          <target state="translated">テストを容易にすることを目的としています。</target>
        </trans-unit>
        <trans-unit id="9801faf88c32829ebf6c941dbb638428950801bd" translate="yes" xml:space="preserve">
          <source>Intended when ERTS, Kernel, STDLIB, or SASL is upgraded. It is automatically added when the &lt;code&gt;relup&lt;/code&gt; file is generated by &lt;code&gt;systools:make_relup/3,4&lt;/code&gt;. It is executed before all other upgrade instructions. For more information about this instruction, see restart_new_emulator (Low-Level) in &lt;code&gt;&lt;a href=&quot;release_handling#restart_new_emulator_instr&quot;&gt;Release Handling Instructions&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ERTS、カーネル、STDLIB、またはSASLがアップグレードされるときに意図されています。ときに自動的に追加され &lt;code&gt;relup&lt;/code&gt; のファイルによって生成される &lt;code&gt;systools:make_relup/3,4&lt;/code&gt; 。他のすべてのアップグレード手順の前に実行されます。この命令の詳細については、「 &lt;code&gt;&lt;a href=&quot;release_handling#restart_new_emulator_instr&quot;&gt;Release Handling Instructions&lt;/a&gt;&lt;/code&gt; 」の「restart_new_emulator（低レベル）」を参照してください。</target>
        </trans-unit>
        <trans-unit id="047073e3b4116ee04b74c0c1cc448bd79da99506" translate="yes" xml:space="preserve">
          <source>Intentionally left undocumented.</source>
          <target state="translated">意図的に未記載のままにしています。</target>
        </trans-unit>
        <trans-unit id="e997f694b62e9d0577171e2f7dc26f17597ee566" translate="yes" xml:space="preserve">
          <source>Inter Call Graph Edges (*).</source>
          <target state="translated">通話間グラフエッジ(*)。</target>
        </trans-unit>
        <trans-unit id="eddaa29b2e62f4b03003dfe22bc83c780028fc16" translate="yes" xml:space="preserve">
          <source>Interaction data enforces module dependencies and is to be avoided if possible. This means that the order of modules in the modules property is significant.</source>
          <target state="translated">相互作用データはモジュールの依存性を強制するので、可能であれば避けなければなりません。これは、modulesプロパティのモジュールの順序が重要であることを意味します。</target>
        </trans-unit>
        <trans-unit id="0a9935f358aacf056c71d573e766697caf72716e" translate="yes" xml:space="preserve">
          <source>Interface Functions for Secure Socket Layer</source>
          <target state="translated">セキュアソケットレイヤのインタフェース機能</target>
        </trans-unit>
        <trans-unit id="b75e70d6d70b916e116f37e9c717c016fbc0e51b" translate="yes" xml:space="preserve">
          <source>Interface Functions to the SNMP toolkit MIB compiler</source>
          <target state="translated">SNMPツールキットMIBコンパイラへのインターフェース機能</target>
        </trans-unit>
        <trans-unit id="6f6bbd90e92a57397bbeedbddd3fab27ffbb44a4" translate="yes" xml:space="preserve">
          <source>Interface Functions to the SNMP toolkit agent</source>
          <target state="translated">SNMPツールキットエージェントへのインターフェース機能</target>
        </trans-unit>
        <trans-unit id="8423a1ea8308683d2b47e96337afebc61ea2820a" translate="yes" xml:space="preserve">
          <source>Interface definitions between the client and the messenger</source>
          <target state="translated">クライアントとメッセンジャー間のインターフェース定義</target>
        </trans-unit>
        <trans-unit id="323c54cb50a9e3d1f4d686a59d1de38461683cb5" translate="yes" xml:space="preserve">
          <source>Interface functions to the SNMP toolkit</source>
          <target state="translated">SNMPツールキットへのインターフェース機能</target>
        </trans-unit>
        <trans-unit id="d20fd70153a1269fbf41940e196fc270f187a23c" translate="yes" xml:space="preserve">
          <source>Interface functions to the SNMP toolkit manager</source>
          <target state="translated">SNMPツールキットマネージャへのインターフェース機能</target>
        </trans-unit>
        <trans-unit id="ce6831520571e37fee954cd1b34f9e1abf7d82ff" translate="yes" xml:space="preserve">
          <source>Interface module for XML Schema validation.</source>
          <target state="translated">XML スキーマ検証用のインターフェイスモジュールです。</target>
        </trans-unit>
        <trans-unit id="050237493439e212d4bc538dddbf1f1eda8b5092" translate="yes" xml:space="preserve">
          <source>Interface module for XML Schema validation. It handles the W3.org &lt;code&gt;&lt;a href=&quot;http://www.w3.org/XML/Schema#dev&quot;&gt;specifications&lt;/a&gt;&lt;/code&gt; of XML Schema second edition 28 october 2004. For an introduction to XML Schema study &lt;code&gt;&lt;a href=&quot;http://www.w3.org/TR/xmlschema-0/&quot;&gt;part 0.&lt;/a&gt;&lt;/code&gt; An XML structure is validated by xmerl_xsd:validate/[2,3].</source>
          <target state="translated">XMLスキーマ検証用のインターフェイスモジュール。XMLスキーマ第2版のW3.org &lt;code&gt;&lt;a href=&quot;http://www.w3.org/XML/Schema#dev&quot;&gt;specifications&lt;/a&gt;&lt;/code&gt; を処理します。2004年10月28日。XMLスキーマ研究 &lt;code&gt;&lt;a href=&quot;http://www.w3.org/TR/xmlschema-0/&quot;&gt;part 0.&lt;/a&gt;&lt;/code&gt; の概要について。XML構造は、xmerl_xsd：validate / [2,3]によって検証されます。</target>
        </trans-unit>
        <trans-unit id="6e2ae4a4e371583e84ad62568aeaef5ba4469dae" translate="yes" xml:space="preserve">
          <source>Interface module for the &lt;code&gt;tftp&lt;/code&gt; application.</source>
          <target state="translated">&lt;code&gt;tftp&lt;/code&gt; アプリケーションのインターフェイスモジュール。</target>
        </trans-unit>
        <trans-unit id="ca876b1a699869a57f784174cba40d788c67ea64" translate="yes" xml:space="preserve">
          <source>Interface module for the Event Trace (ET) application</source>
          <target state="translated">イベントトレース(ET)アプリケーション用のインターフェースモジュール</target>
        </trans-unit>
        <trans-unit id="45f7c5e26612823c7e6731913f85b1300e9ae4ce" translate="yes" xml:space="preserve">
          <source>Interface module for the Megaco application</source>
          <target state="translated">Megacoアプリケーション用インターフェースモジュール</target>
        </trans-unit>
        <trans-unit id="c936eb6df938f4d258995b26947dcddb7458ae2b" translate="yes" xml:space="preserve">
          <source>Interface module to TPKT transport protocol for Megaco/H.248.</source>
          <target state="translated">Megaco/H.248用TPKTトランスポートプロトコルへのインターフェースモジュールです。</target>
        </trans-unit>
        <trans-unit id="27468964adda1f4dd990691916ff4a4d446a2e7d" translate="yes" xml:space="preserve">
          <source>Interface module to UDP transport protocol for Megaco/H.248.</source>
          <target state="translated">Megaco/H.248用UDPトランスポートプロトコルのインターフェースモジュールです。</target>
        </trans-unit>
        <trans-unit id="6d75c5c7c8f11fcc10b56585e807ce50cb617d4f" translate="yes" xml:space="preserve">
          <source>Interface module to the flex scanner linked in driver.</source>
          <target state="translated">ドライバにリンクされているフレックススキャナへのインターフェースモジュールです。</target>
        </trans-unit>
        <trans-unit id="aacb400767c682f7416831e0737ea9f733b0c6c0" translate="yes" xml:space="preserve">
          <source>Interface to OS System Messages</source>
          <target state="translated">OSシステムメッセージへのインタフェース</target>
        </trans-unit>
        <trans-unit id="2a76ee81e739df0dc00918ece6fa79aa9518edfe" translate="yes" xml:space="preserve">
          <source>Interface to TCP/IP sockets.</source>
          <target state="translated">TCP/IP ソケットへのインターフェース。</target>
        </trans-unit>
        <trans-unit id="cc16cc1cca26b8e2731cb9be496453c8f68c2df9" translate="yes" xml:space="preserve">
          <source>Interface to UDP sockets.</source>
          <target state="translated">UDP ソケットへのインターフェース。</target>
        </trans-unit>
        <trans-unit id="96f6013ec56594333c06a3834e9c2473d15a18de" translate="yes" xml:space="preserve">
          <source>Interface to Windows Event Log</source>
          <target state="translated">Windowsイベントログへのインターフェース</target>
        </trans-unit>
        <trans-unit id="d4457db8b0de1c4d4686f8d6b2a56e3e9ab8095b" translate="yes" xml:space="preserve">
          <source>Interface to dynamic tracing</source>
          <target state="translated">ダイナミックトレースへのインターフェース</target>
        </trans-unit>
        <trans-unit id="0716ba0b63e064bb3cb187f55a890a904447d9e9" translate="yes" xml:space="preserve">
          <source>Interface to standard Erlang I/O servers</source>
          <target state="translated">標準のErlang I/Oサーバへのインターフェース</target>
        </trans-unit>
        <trans-unit id="43768b10820f3bcc951b6981b78de3c2c85818c7" translate="yes" xml:space="preserve">
          <source>Interface to the Erlang built-in term storage BIFs</source>
          <target state="translated">Erlangの組み込みタームストレージBIFへのインターフェイス</target>
        </trans-unit>
        <trans-unit id="f672e9ac51285d0fd0e7e4843c6946df35242ba0" translate="yes" xml:space="preserve">
          <source>Internal Erlang definitions.</source>
          <target state="translated">Erlangの内部定義。</target>
        </trans-unit>
        <trans-unit id="c43136ea5f7b358debf82f26c7522eae622f4bc8" translate="yes" xml:space="preserve">
          <source>Internal id for set of locks, not always unique. This could be table name for ets tables (db_tab), port id for ports, integer identifiers for allocators, etc.</source>
          <target state="translated">ロックのセットの内部 ID、常に一意とは限りません。これは、ETS テーブル (db_tab)用のテーブル名、ポート用のポート ID、 アロケータ用の整数識別子などです。</target>
        </trans-unit>
        <trans-unit id="341fa1e0f35c53a05146fef56f0f0dcefb3384e9" translate="yes" xml:space="preserve">
          <source>Internal server errors are recorded in the error log file. The format of this file is a more unplanned format than the logs using Common Logfile Format, but conforms to the following syntax:</source>
          <target state="translated">内部サーバーのエラーは、エラーログファイルに記録されます。このファイルの形式は、Common Logfile Formatを使用したログよりも無計画な形式ですが、以下の構文に準拠しています。</target>
        </trans-unit>
        <trans-unit id="3d37510d25e4b581b66d9a9103bd0c6f31ee62ee" translate="yes" xml:space="preserve">
          <source>Internal state of the channel.</source>
          <target state="translated">チャンネルの内部状態。</target>
        </trans-unit>
        <trans-unit id="badfae6bbc42b495ad12bdff0f4b098f913dcb9a" translate="yes" xml:space="preserve">
          <source>Internally &lt;code&gt;Mnesia&lt;/code&gt; uses several commit protocols. The selected protocol depends on which table that has been updated in the transaction. If all the involved tables are symmetrically replicated (that is, they all have the same &lt;code&gt;ram_nodes&lt;/code&gt;, &lt;code&gt;disc_nodes&lt;/code&gt;, and &lt;code&gt;disc_only_nodes&lt;/code&gt; currently accessible from the coordinator node), a lightweight transaction commit protocol is used.</source>
          <target state="translated">内部的に &lt;code&gt;Mnesia&lt;/code&gt; はいくつかのコミットプロトコルを使用します。選択されるプロトコルは、トランザクションで更新されたテーブルによって異なります。関連するすべてのテーブルが対称的にレプリケートされる場合（つまり、すべてのコーディネータノードから現在アクセス可能な &lt;code&gt;ram_nodes&lt;/code&gt; 、 &lt;code&gt;disc_nodes&lt;/code&gt; 、および &lt;code&gt;disc_only_nodes&lt;/code&gt; がすべて同じである場合）、軽量トランザクションコミットプロトコルが使用されます。</target>
        </trans-unit>
        <trans-unit id="4be7390306e27edeab5e110ad71f96da0daba7a4" translate="yes" xml:space="preserve">
          <source>Internally a framework called &lt;code&gt;alloc_util&lt;/code&gt; is used for implementing allocators. &lt;code&gt;sys_alloc&lt;/code&gt; and &lt;code&gt;mseg_alloc&lt;/code&gt; do not use this framework, so the following does &lt;strong&gt;not&lt;/strong&gt; apply to them.</source>
          <target state="translated">内部的には、アロケーターの実装に &lt;code&gt;alloc_util&lt;/code&gt; と呼ばれるフレームワークが使用されます。 &lt;code&gt;sys_alloc&lt;/code&gt; および &lt;code&gt;mseg_alloc&lt;/code&gt; はこのフレームワークを使用しないため、以下は適用されませ&lt;strong&gt;ん&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="c426ea5b2618f0f6ae7be49919b9b54e05abea42" translate="yes" xml:space="preserve">
          <source>Internally in each priority level, processes are scheduled in a round robin fashion.</source>
          <target state="translated">各優先度レベルの内部では、プロセスはラウンドロビン方式でスケジュールされています。</target>
        </trans-unit>
        <trans-unit id="c41284ece411489ae5985686dd33bb0cf82727eb" translate="yes" xml:space="preserve">
          <source>Internally in the Erlang runtime system locks are used to protect resources from being updated from multiple threads in a fatal way. Locks are necessary to ensure that the runtime system works properly but it also introduces a couple of limitations. Lock contention and locking overhead.</source>
          <target state="translated">Erlangのランタイムシステムの内部では、ロックは致命的な方法で複数のスレッドからリソースが更新されないように保護するために使われています。ロックはランタイムシステムが正しく動作するために必要なものですが、いくつかの制限もあります。ロックの競合とロックのオーバーヘッドです。</target>
        </trans-unit>
        <trans-unit id="7d74971bacf5510c7ab75585168e740293be593d" translate="yes" xml:space="preserve">
          <source>Internally in the runtime system, Erlang monotonic time is the &quot;time engine&quot; that is used for more or less everything that has anything to do with time. All timers, regardless of it is a &lt;code&gt;receive ... after&lt;/code&gt; timer, BIF timer, or a timer in the &lt;code&gt;timer(3)&lt;/code&gt; module, are triggered relative Erlang monotonic time. Even &lt;code&gt;&lt;a href=&quot;#Erlang_System_Time&quot;&gt;Erlang system time&lt;/a&gt;&lt;/code&gt; is based on Erlang monotonic time. By adding current Erlang monotonic time with current time offset, you get current Erlang system time.</source>
          <target state="translated">ランタイムシステムの内部では、Erlangの単調時間は、時間に関係するあらゆるものに使用される「時間エンジン」です。すべてのタイマーは、それが &lt;code&gt;receive ... after&lt;/code&gt; であるかどうかに関係なく...タイマー、BIFタイマー、または &lt;code&gt;timer(3)&lt;/code&gt; モジュールのタイマーは、Erlangの単調な相対時間でトリガーされます。 &lt;code&gt;&lt;a href=&quot;#Erlang_System_Time&quot;&gt;Erlang system time&lt;/a&gt;&lt;/code&gt; さえ、Erlang単調時間に基づいています。現在のErlang単調時間と現在の時間オフセットを加算すると、現在のErlangシステム時間を取得できます。</target>
        </trans-unit>
        <trans-unit id="a059bcd00d503bcbdc0046cbcdb9ce42b54025ec" translate="yes" xml:space="preserve">
          <source>Internally, binaries and bitstrings are implemented in the same way. In this section, they are called &lt;strong&gt;binaries&lt;/strong&gt; because that is what they are called in the emulator source code.</source>
          <target state="translated">内部的には、バイナリとビット文字列は同じ方法で実装されています。このセクションでは、エミュレータのソースコードで&lt;strong&gt;バイナリ&lt;/strong&gt;と呼ばれているため、&lt;strong&gt;バイナリ&lt;/strong&gt;と呼びます。</target>
        </trans-unit>
        <trans-unit id="f6f3359a916a2a0d142f95745652bdd812cac3df" translate="yes" xml:space="preserve">
          <source>Internally, records are represented using tagged tuples:</source>
          <target state="translated">内部的には、レコードはタグ付きタプルを使って表現されます。</target>
        </trans-unit>
        <trans-unit id="dd2c83c9c4fac498df04ee4596255b013c52c14a" translate="yes" xml:space="preserve">
          <source>Internally, the supervisor also keeps track of the pid &lt;code&gt;Child&lt;/code&gt; of the child process, or &lt;code&gt;undefined&lt;/code&gt; if no pid exists.</source>
          <target state="translated">内部的には、スーパーバイザーは子プロセスのpid &lt;code&gt;Child&lt;/code&gt; も追跡します。pidが存在し &lt;code&gt;undefined&lt;/code&gt; 場合は未定義です。</target>
        </trans-unit>
        <trans-unit id="3623dcb4995df517dc1119f9c1eac79892d03149" translate="yes" xml:space="preserve">
          <source>Internationalized domain names are not supported.</source>
          <target state="translated">国際化されたドメイン名はサポートされていません。</target>
        </trans-unit>
        <trans-unit id="e68d66b86c5b372f203a16d7698b8bcac56dc8f3" translate="yes" xml:space="preserve">
          <source>Interpretable modules are modules for which a &lt;code&gt;.beam&lt;/code&gt; file, compiled with option &lt;code&gt;debug_info&lt;/code&gt; set, is located in the same directory as the source code, or in an &lt;code&gt;ebin&lt;/code&gt; directory next to it.</source>
          <target state="translated">解釈モジュールは、そのためのモジュールである &lt;code&gt;.beam&lt;/code&gt; のオプションを使用してコンパイルされたファイル、 &lt;code&gt;debug_info&lt;/code&gt; セットは、ソースコードと同じディレクトリに配置され、又はにおける &lt;code&gt;ebin&lt;/code&gt; の横にディレクトリ。</target>
        </trans-unit>
        <trans-unit id="11c3c6c74af70de4fbc0724c5fe96be415a45a08" translate="yes" xml:space="preserve">
          <source>Interpreter Interface.</source>
          <target state="translated">インタープリタインターフェイス。</target>
        </trans-unit>
        <trans-unit id="d0145d7b897252f435c3a2f9b80c340bcaeb2cbd" translate="yes" xml:space="preserve">
          <source>Interprets it as universal time.</source>
          <target state="translated">普遍的な時間として解釈する。</target>
        </trans-unit>
        <trans-unit id="ccdccf92f6f4b9eea51ade2820a3421f89b938c1" translate="yes" xml:space="preserve">
          <source>Interprets the escript regardless of the value of the mode attribute.</source>
          <target state="translated">mode属性の値に関係なく、escriptを解釈します。</target>
        </trans-unit>
        <trans-unit id="d062a6aaa1321b4fbe61ff2e8174819990ef6080" translate="yes" xml:space="preserve">
          <source>Interprets the specified module(s). &lt;code&gt;i/1&lt;/code&gt; interprets the module only at the current node. &lt;code&gt;ni/1&lt;/code&gt; interprets the module at all known nodes.</source>
          <target state="translated">指定されたモジュールを解釈します。 &lt;code&gt;i/1&lt;/code&gt; は、現在のノードでのみモジュールを解釈します。 &lt;code&gt;ni/1&lt;/code&gt; はすべての既知のノードでモジュールを解釈します。</target>
        </trans-unit>
        <trans-unit id="8f875d6a6ca694f0b14cea8f5848e9d0ba0a21ef" translate="yes" xml:space="preserve">
          <source>Interprets the specified module(s). &lt;code&gt;ii/1&lt;/code&gt; interprets the module(s) only at the current node, see &lt;code&gt;&lt;a href=&quot;int#i-1&quot;&gt;int:i/1&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ini/1&lt;/code&gt; interprets the module(s) at all known nodes, see &lt;code&gt;&lt;a href=&quot;int#ni-1&quot;&gt;int:ni/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">指定されたモジュールを解釈します。 &lt;code&gt;ii/1&lt;/code&gt; は、現在のノードでのみモジュールを解釈します &lt;code&gt;&lt;a href=&quot;int#i-1&quot;&gt;int:i/1&lt;/a&gt;&lt;/code&gt; 参照してください。 &lt;code&gt;ini/1&lt;/code&gt; は、既知のすべてのノードでモジュールを解釈します &lt;code&gt;&lt;a href=&quot;int#ni-1&quot;&gt;int:ni/1&lt;/a&gt;&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="3729c738460ce5f6a85bafb8d5ebc52b2170ffc7" translate="yes" xml:space="preserve">
          <source>Interprets the time set as local.</source>
          <target state="translated">設定された時間をローカルとして解釈します。</target>
        </trans-unit>
        <trans-unit id="a6a03664ff2ef589fe34431565963c09a8035a81" translate="yes" xml:space="preserve">
          <source>Intersecting an empty family exits the process with a &lt;code&gt;badarg&lt;/code&gt; message.</source>
          <target state="translated">空のファミリと交差すると、 &lt;code&gt;badarg&lt;/code&gt; メッセージでプロセスが終了します。</target>
        </trans-unit>
        <trans-unit id="7b56d0e04c45c4c2d5526cfbb776e3ab6ea16e89" translate="yes" xml:space="preserve">
          <source>Intersecting an empty set of sets exits the process with a &lt;code&gt;badarg&lt;/code&gt; message.</source>
          <target state="translated">空のセットのセットを交差すると、 &lt;code&gt;badarg&lt;/code&gt; メッセージでプロセスが終了します。</target>
        </trans-unit>
        <trans-unit id="e3aecd4f7ca9b10ba6eefdc3b3982ee51acbee86" translate="yes" xml:space="preserve">
          <source>Introduced in ERTS 8.1.2 (Erlang/OTP 19.2).</source>
          <target state="translated">ERTS 8.1.2 (Erlang/OTP 19.2)で導入されました。</target>
        </trans-unit>
        <trans-unit id="e4185202e789e006e8d46cab5bb0f1344a5a2825" translate="yes" xml:space="preserve">
          <source>Introduced in ERTS 8.3 (Erlang/OTP 19.3)</source>
          <target state="translated">ERTS 8.3で導入 (Erlang/OTP 19.3)</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="1e7228f13f302f91d97086fd99b6f4023b94b4ab" translate="yes" xml:space="preserve">
          <source>Invalid Subject Alternative Name extension.</source>
          <target state="translated">無効なサブジェクト代替名拡張子です。</target>
        </trans-unit>
        <trans-unit id="6dd22909406f536945b3651891eae0a11394eec6" translate="yes" xml:space="preserve">
          <source>Invalid Unicode codepoints are the range 0xd800 to 0xdfff (the so-called &quot;surrogate&quot; codepoints), and 0xffef.</source>
          <target state="translated">無効な Unicode コードポイントは、0xd800 から 0xdfff の範囲(いわゆる「サロゲート」コードポイント)と 0xffef です。</target>
        </trans-unit>
        <trans-unit id="970e02af50aef8057777e1e719234daf9ac3bd81" translate="yes" xml:space="preserve">
          <source>Invalid argument: &lt;code&gt;to&lt;/code&gt; is not a valid Erlang pid.</source>
          <target state="translated">無効な引数： &lt;code&gt;to&lt;/code&gt; は有効なErlang pidではありません。</target>
        </trans-unit>
        <trans-unit id="0cc909be0f2da4ba1a41bb22abd333ee5d822722" translate="yes" xml:space="preserve">
          <source>Invalid username or password.</source>
          <target state="translated">ユーザー名またはパスワードが無効です。</target>
        </trans-unit>
        <trans-unit id="e8f7b9edf2ca5bb757072a798bd0acfa87861234" translate="yes" xml:space="preserve">
          <source>Invalidate the mib server cache.</source>
          <target state="translated">mibサーバのキャッシュを無効にします。</target>
        </trans-unit>
        <trans-unit id="9759cc5e347da705fdd81203cf52cec5eb5adf6e" translate="yes" xml:space="preserve">
          <source>Inverts the &quot;greediness&quot; of the quantifiers so that they are not greedy by default, but become greedy if followed by &quot;?&quot;. It is not compatible with Perl. It can also be set by a &lt;code&gt;(?U)&lt;/code&gt; option setting within the pattern.</source>
          <target state="translated">量指定子の「貪欲さ」を反転して、デフォルトでは貪欲ではないが、「？」が後に続く場合は貪欲になるようにします。Perlとの互換性はありません。パターン内の &lt;code&gt;(?U)&lt;/code&gt; オプション設定で設定することもできます。</target>
        </trans-unit>
        <trans-unit id="6ce3b1ae867572c714bd282ce9e483e01b357834" translate="yes" xml:space="preserve">
          <source>Invoked for each transaction request</source>
          <target state="translated">トランザクション要求ごとに呼び出される</target>
        </trans-unit>
        <trans-unit id="3d01902a8b40974a69e9ea306fbe52a7b7185b83" translate="yes" xml:space="preserve">
          <source>Invoked when a connection is teared down</source>
          <target state="translated">接続が切断されたときに呼び出される</target>
        </trans-unit>
        <trans-unit id="39559513e0fdc0d1c43b0c8be77af3afaf11b089" translate="yes" xml:space="preserve">
          <source>Invoked when a new connection is established</source>
          <target state="translated">新しい接続が確立されたときに呼び出される</target>
        </trans-unit>
        <trans-unit id="aad6f32ab5334acc03c0b23cd1d9febffce28f41" translate="yes" xml:space="preserve">
          <source>Invoked when a received message had syntax errors</source>
          <target state="translated">受信したメッセージに構文エラーがあった場合に呼び出されます。</target>
        </trans-unit>
        <trans-unit id="d768e80023291d60266531cb13740e0ce1f447c2" translate="yes" xml:space="preserve">
          <source>Invoked when a received message just contains an error instead of a list of transactions.</source>
          <target state="translated">受信したメッセージにトランザクションのリストではなく、エラーだけが含まれている場合に呼び出されます。</target>
        </trans-unit>
        <trans-unit id="f77eaeba46fb85e4b28b68f94f4e359f9e2851ee" translate="yes" xml:space="preserve">
          <source>Invoked when a transaction request has been aborted</source>
          <target state="translated">トランザクション要求が中止された場合に呼び出されます。</target>
        </trans-unit>
        <trans-unit id="cc89cd28b56040ba5e6a38dfd9e4d4df5cc8c73b" translate="yes" xml:space="preserve">
          <source>Invoked when a unexpected message is received</source>
          <target state="translated">予期せぬメッセージを受信したときに呼び出される</target>
        </trans-unit>
        <trans-unit id="0af975defd697440d1ee7d6af73916790ab9bbc3" translate="yes" xml:space="preserve">
          <source>Invoked when the file transfer is aborted.</source>
          <target state="translated">ファイル転送が中止されたときに呼び出されます。</target>
        </trans-unit>
        <trans-unit id="0427692fb99ce605340c28aa25be48c6566c62f3" translate="yes" xml:space="preserve">
          <source>Invokes &lt;code&gt;et:trace_me/5&lt;/code&gt; with both &lt;code&gt;From&lt;/code&gt; and &lt;code&gt;To&lt;/code&gt; set to &lt;code&gt;FromTo&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;From&lt;/code&gt; と &lt;code&gt;To&lt;/code&gt; の両方を &lt;code&gt;FromTo&lt;/code&gt; に設定して &lt;code&gt;et:trace_me/5&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="d83df673697f3918f082f79e1172314cb5c6089b" translate="yes" xml:space="preserve">
          <source>Invokes a memory check and returns the resulting, system dependent, data as a list of tagged tuples, where &lt;code&gt;Tag&lt;/code&gt; can be one of the following:</source>
          <target state="translated">メモリチェックと戻り、その結果、システムに依存し、タグ付けされたタプルのリストとしてデータを呼び出し、 &lt;code&gt;Tag&lt;/code&gt; 、次のいずれかとすることができます。</target>
        </trans-unit>
        <trans-unit id="1100bbe70f71111dfc5fac73d1ff0bdf78d63a7b" translate="yes" xml:space="preserve">
          <source>Invokes the old Erlang shell from Erlang/OTP 3.3. The old shell can still be used.</source>
          <target state="translated">Erlang/OTP 3.3から古いErlangシェルを起動します。古いシェルはまだ使えます。</target>
        </trans-unit>
        <trans-unit id="36a3a3daec3816a0a8d74afe681df212e4a06b79" translate="yes" xml:space="preserve">
          <source>Invoking &lt;code&gt;make ERL_XCOMP_FORCE_DIFFERENT_OTP=yes&lt;/code&gt; might fail, silently produce suboptimal code, or silently produce erroneous code.</source>
          <target state="translated">&lt;code&gt;make ERL_XCOMP_FORCE_DIFFERENT_OTP=yes&lt;/code&gt; を呼び出すと、失敗するか、次善のコードがサイレントで生成されるか、誤ったコードがサイレントで生成されます。</target>
        </trans-unit>
        <trans-unit id="9b08f920d3a33d8317baaf4578d92c7eb8654fd5" translate="yes" xml:space="preserve">
          <source>IpFamily = &lt;code&gt;inet | inet6 | inet6fb4&lt;/code&gt;</source>
          <target state="translated">IpFamily = &lt;code&gt;inet | inet6 | inet6fb4&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="216b4a0c9222fc30988b436b2d5c7b661431663a" translate="yes" xml:space="preserve">
          <source>Irrelevant</source>
          <target state="translated">Irrelevant</target>
        </trans-unit>
        <trans-unit id="9d4e3fd7167bf46822004ff30d54f3257b464f0a" translate="yes" xml:space="preserve">
          <source>Is &lt;code&gt;0&lt;/code&gt; for a regular NIF (and so its value can be omitted for statically initialized &lt;code&gt;ErlNifFunc&lt;/code&gt; instances).</source>
          <target state="translated">通常のNIFの場合は &lt;code&gt;0&lt;/code&gt; です（そのため、静的に初期化された &lt;code&gt;ErlNifFunc&lt;/code&gt; インスタンスの場合、その値を省略できます）。</target>
        </trans-unit>
        <trans-unit id="5b115b1ae7fa7943e2604056f2ecd826dceada9e" translate="yes" xml:space="preserve">
          <source>Is a list of column numbers in the case of a &lt;code&gt;get&lt;/code&gt; operation, and a list of column numbers and values in the case of a &lt;code&gt;set&lt;/code&gt; operation.</source>
          <target state="translated">&lt;code&gt;get&lt;/code&gt; オペレーションの場合は列番号のリスト、 &lt;code&gt;set&lt;/code&gt; オペレーションの場合は列番号と値のリストです。</target>
        </trans-unit>
        <trans-unit id="58f4eb42bb30362fe7878dc6d1c4495841ad13d1" translate="yes" xml:space="preserve">
          <source>Is best run by modifying the meas.sh.skel skeleton script provided by the tool.</source>
          <target state="translated">ツールが提供する meas.sh.skel スケルトンスクリプトを修正して実行するのが最適です。</target>
        </trans-unit>
        <trans-unit id="c23fe05a88d02257549454dd15123c24fa32ea77" translate="yes" xml:space="preserve">
          <source>Is best run by modifying the mstone1.sh.skel skeleton script provided by the tool.</source>
          <target state="translated">ツールが提供する mstone1.sh.skel スケルトンスクリプトを修正して実行するのが最適です。</target>
        </trans-unit>
        <trans-unit id="87198e2f1c7806f1ad60ae76ac1d595598bf98a2" translate="yes" xml:space="preserve">
          <source>Is disregarded if &lt;code&gt;height&lt;/code&gt; is defined.</source>
          <target state="translated">&lt;code&gt;height&lt;/code&gt; が定義されている場合は無視されます。</target>
        </trans-unit>
        <trans-unit id="269a41e3fe559c0e05b304e7b6c27b5566c39389" translate="yes" xml:space="preserve">
          <source>Is disregarded if &lt;code&gt;width&lt;/code&gt; is defined.</source>
          <target state="translated">&lt;code&gt;width&lt;/code&gt; が定義されている場合は無視されます。</target>
        </trans-unit>
        <trans-unit id="ffe57a12bbaf259c034632c80ca23397143420b7" translate="yes" xml:space="preserve">
          <source>Is it possible to reduce the number of times the function is called?</source>
          <target state="translated">関数の呼び出し回数を減らすことは可能でしょうか?</target>
        </trans-unit>
        <trans-unit id="e288cb6c9e74155297a40b276058aa6236c59a1c" translate="yes" xml:space="preserve">
          <source>Is the actual protocol version. In most cases the protocol version is retrieved from the processed message, but there are exceptions:</source>
          <target state="translated">実際のプロトコルのバージョンです。ほとんどの場合、プロトコルのバージョンは処理されたメッセージから取得されますが、例外もあります。</target>
        </trans-unit>
        <trans-unit id="b0588901bedfe37cbeecafd41fb2d74795460658" translate="yes" xml:space="preserve">
          <source>Is the flex scanner reentrant or not.</source>
          <target state="translated">フレックススキャナーは再入庫するのか、しないのか。</target>
        </trans-unit>
        <trans-unit id="1e9df40deeb13aac31ab4026e6e08e1f63bbae21" translate="yes" xml:space="preserve">
          <source>Is the same as &lt;code&gt;file(File, [verbose,report_errors,report_warnings])&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;file(File, [verbose,report_errors,report_warnings])&lt;/code&gt; と同じです。</target>
        </trans-unit>
        <trans-unit id="119f8a66ca64a5694cc3478ae4de46bcaf1a9423" translate="yes" xml:space="preserve">
          <source>Is the same as &lt;code&gt;forms(Forms, [verbose,report_errors,report_warnings])&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;forms(Forms, [verbose,report_errors,report_warnings])&lt;/code&gt; と同じです。</target>
        </trans-unit>
        <trans-unit id="fa3bd9e6b2f2c505e7347d749868eb9820f223c7" translate="yes" xml:space="preserve">
          <source>Is to be called by a client channel process to request that the user default shell (typically defined in /etc/passwd in Unix systems) is executed at the server end.</source>
          <target state="translated">クライアントチャネルプロセスから呼び出され、ユーザのデフォルトシェル (通常 Unix システムでは /etc/passwd で定義されています)がサーバ側で実行されるように要求します。</target>
        </trans-unit>
        <trans-unit id="7ceeac9a5465ffa310db9af05a50178436138dfb" translate="yes" xml:space="preserve">
          <source>Is to be called by a client-channel process for requesting to execute a predefined subsystem on the server.</source>
          <target state="translated">サーバ上で事前に定義されたサブシステムの実行を要求するために、クライアン ト・チャネル・プロセスから呼び出されます。</target>
        </trans-unit>
        <trans-unit id="c26f3b86fc0054ade9e50cca18683944d8b10a73" translate="yes" xml:space="preserve">
          <source>Is to be called by a client-channel process to request that the server starts executing the given command. The result is several messages according to the following pattern. The last message is a channel close message, as the &lt;code&gt;exec&lt;/code&gt; request is a one-time execution that closes the channel when it is done.</source>
          <target state="translated">サーバーが指定されたコマンドの実行を開始することを要求するために、クライアントチャネルプロセスによって呼び出されます。結果は、次のパターンに従っていくつかのメッセージになります。最後のメッセージは、チャネルのクローズメッセージです。これは、 &lt;code&gt;exec&lt;/code&gt; 要求がチャネルのクローズ時に1回だけ実行されるためです。</target>
        </trans-unit>
        <trans-unit id="0f5f5d78eb634db530f821ffb8bb8f751e62bff8" translate="yes" xml:space="preserve">
          <source>Is to be called by a server-channel process to send the exit status of a command to the client.</source>
          <target state="translated">コマンドの終了ステータスをクライアントに送信するために、サーバチャネルプロセスから呼び出されます。</target>
        </trans-unit>
        <trans-unit id="d48b86257b47b5c4e3321d39134c0623cc1ea274" translate="yes" xml:space="preserve">
          <source>Is to be called by client- and server-channel processes to send data to each other.</source>
          <target state="translated">クライアントとサーバチャネルのプロセスがお互いにデータを送信するために呼び出されます。</target>
        </trans-unit>
        <trans-unit id="58c7c3af31214a2559fd6c1a8a5a15f560200d51" translate="yes" xml:space="preserve">
          <source>Is to be used as argument to &lt;code&gt;&lt;a href=&quot;#reply-2&quot;&gt;reply/2&lt;/a&gt;&lt;/code&gt;     Will be the return value of &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/[2,3]&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#reply-2&quot;&gt;reply/2&lt;/a&gt;&lt;/code&gt; の引数として使用されます &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/[2,3]&lt;/a&gt;&lt;/code&gt; 戻り値になります。</target>
        </trans-unit>
        <trans-unit id="797fbc2978e0717dd29a9c7b419f35b1add8ae5d" translate="yes" xml:space="preserve">
          <source>Is to be used together with &lt;code&gt;ssh:daemon/[1,2,3]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ssh:daemon/[1,2,3]&lt;/code&gt; と一緒に使用します</target>
        </trans-unit>
        <trans-unit id="cad8c95e87d4c8212862db03444550588eb9575a" translate="yes" xml:space="preserve">
          <source>Issues a synchronous SNMP &lt;code&gt;get next&lt;/code&gt; request.</source>
          <target state="translated">同期SNMP &lt;code&gt;get next&lt;/code&gt; 要求を発行します。</target>
        </trans-unit>
        <trans-unit id="341f83a51a550d204d993e9fdbc3e49fbf2fc850" translate="yes" xml:space="preserve">
          <source>Issues a synchronous SNMP &lt;code&gt;get&lt;/code&gt; request.</source>
          <target state="translated">同期SNMP &lt;code&gt;get&lt;/code&gt; 要求を発行します。</target>
        </trans-unit>
        <trans-unit id="8c7f616c91a41fcdcd984c210b1ad39f21a4abe5" translate="yes" xml:space="preserve">
          <source>Issues a synchronous SNMP &lt;code&gt;set&lt;/code&gt; request.</source>
          <target state="translated">同期SNMP &lt;code&gt;set&lt;/code&gt; 要求を発行します。</target>
        </trans-unit>
        <trans-unit id="0768892d2762d9ec323c2e61d80bb2d335f194dd" translate="yes" xml:space="preserve">
          <source>Issuing this command starts the timer for this trace if option &lt;code&gt;timer&lt;/code&gt; is specified with &lt;code&gt;tracer/2&lt;/code&gt;.</source>
          <target state="translated">オプション &lt;code&gt;timer&lt;/code&gt; が &lt;code&gt;tracer/2&lt;/code&gt; で指定されている場合、このコマンドを発行すると、このトレースのタイマーが開始されます。</target>
        </trans-unit>
        <trans-unit id="527b024e0f1be9518973bad0f8b1a28cfc553cd1" translate="yes" xml:space="preserve">
          <source>It F is a family, it holds that F is a subset of &lt;code&gt;digraph_to_family(family_to_digraph(F),&amp;nbsp;type(F))&lt;/code&gt;. Equality holds if &lt;code&gt;union_of_family(F)&lt;/code&gt; is a subset of &lt;code&gt;domain(F)&lt;/code&gt;.</source>
          <target state="translated">Fはファミリーであり、Fは &lt;code&gt;digraph_to_family(family_to_digraph(F),&amp;nbsp;type(F))&lt;/code&gt; サブセットであると考えられます。 &lt;code&gt;union_of_family(F)&lt;/code&gt; が &lt;code&gt;domain(F)&lt;/code&gt; のサブセットである場合、等式が成立します。</target>
        </trans-unit>
        <trans-unit id="348ecbd21ed63b96be9eb151353dced54f040940" translate="yes" xml:space="preserve">
          <source>It allows other tables to be replicated to this node.</source>
          <target state="translated">これにより、他のテーブルをこのノードにレプリケートすることができます。</target>
        </trans-unit>
        <trans-unit id="502cbb23b6da4d09ac652d118086581df05059bf" translate="yes" xml:space="preserve">
          <source>It also initializes some SNMP counters.</source>
          <target state="translated">また、いくつかのSNMPカウンタを初期化します。</target>
        </trans-unit>
        <trans-unit id="0d3f428d2936ea84cb0649cae0490ba763c4555f" translate="yes" xml:space="preserve">
          <source>It calls &lt;code&gt;run_erl&lt;/code&gt;, which sets up things so the operator can attach to the system.</source>
          <target state="translated">これは &lt;code&gt;run_erl&lt;/code&gt; を呼び出し、オペレーターがシステムに接続できるように設定します。</target>
        </trans-unit>
        <trans-unit id="6560322fa3ad293d5b242b322f5dac4de01df8c8" translate="yes" xml:space="preserve">
          <source>It calls &lt;code&gt;start_erl&lt;/code&gt;, which calls the correct version of &lt;code&gt;erlexec&lt;/code&gt; (which is located in &lt;code&gt;&amp;lt;ERL_INSTALL_DIR&amp;gt;/erts-EVsn/bin&lt;/code&gt;) with the correct &lt;code&gt;boot&lt;/code&gt; and &lt;code&gt;config&lt;/code&gt; files.</source>
          <target state="translated">これは、呼び出しを &lt;code&gt;start_erl&lt;/code&gt; の正しいバージョンを呼び出します、 &lt;code&gt;erlexec&lt;/code&gt; （に位置しています &lt;code&gt;&amp;lt;ERL_INSTALL_DIR&amp;gt;/erts-EVsn/bin&lt;/code&gt; 正しいと） &lt;code&gt;boot&lt;/code&gt; および &lt;code&gt;config&lt;/code&gt; ファイルを。</target>
        </trans-unit>
        <trans-unit id="3c0fc93fb15a2633f7d6c853cf154a0edd87bf6a" translate="yes" xml:space="preserve">
          <source>It can also be used from inside an Erlang program. If this ASN.1 code is defined in ASN.1 module &lt;code&gt;Values&lt;/code&gt;, the ASN.1 value &lt;code&gt;tt&lt;/code&gt; can be reached from Erlang as a function call to &lt;code&gt;'Values':tt()&lt;/code&gt; as in the following example:</source>
          <target state="translated">Erlangプログラム内からも使用できます。このASN.1コードがASN.1モジュールの &lt;code&gt;Values&lt;/code&gt; で定義されている場合、ASN.1値 &lt;code&gt;tt&lt;/code&gt; は、次の例のように、 &lt;code&gt;'Values':tt()&lt;/code&gt; への関数呼び出しとしてErlangから到達できます。</target>
        </trans-unit>
        <trans-unit id="cab601fee61bbc23a1da1dd5afb684daa2673400" translate="yes" xml:space="preserve">
          <source>It can be accessed as follows:</source>
          <target state="translated">以下のようにアクセスできます。</target>
        </trans-unit>
        <trans-unit id="c77546f4819cb51bf45faf9651c89e8f35e71626" translate="yes" xml:space="preserve">
          <source>It can be advantageous to create table replicas for a distributed application that reads data often, but writes data seldom, to achieve fast read operations on the local node. The major disadvantage with replication is the increased time to write data. If a table has two replicas, every write operation must access both table replicas. Since one of these write operations must be a network operation, it is considerably more expensive to perform a write operation to a replicated table than to a non-replicated table.</source>
          <target state="translated">データを頻繁に読み込み、データを滅多に書き込まない分散型アプリケーションのためにテーブルレプリカを作成して、ローカルノードでの高速な読み込み操作を実現することが有利になる場合があります。レプリケーションの大きな欠点は、データの書き込み時間が長くなることです。テーブルに2つのレプリカがある場合、すべての書き込み操作は両方のテーブルレプリカにアクセスしなければなりません。これらの書き込み操作のうちの1つはネットワーク操作でなければならないため、レプリケートされたテーブルへの書き込み操作を実行するのは、レプリケートされていないテーブルへの書き込み操作よりもかなり高価になります。</target>
        </trans-unit>
        <trans-unit id="3ecec720b0256b562180425a889c57f1514a840b" translate="yes" xml:space="preserve">
          <source>It can be appropriate to calculate the message digest before calling &lt;code&gt;sign&lt;/code&gt; or &lt;code&gt;verify&lt;/code&gt;, and then use &lt;code&gt;none&lt;/code&gt; as second argument:</source>
          <target state="translated">&lt;code&gt;sign&lt;/code&gt; または &lt;code&gt;verify&lt;/code&gt; を呼び出す前にメッセージダイジェストを計算し、2番目の引数として &lt;code&gt;none&lt;/code&gt; を使用するのが適切な場合があります。</target>
        </trans-unit>
        <trans-unit id="429a02b10011f23201ea705082a6734a13afe1dd" translate="yes" xml:space="preserve">
          <source>It can be required that your code must run on a variety of OTP installations of different OTP releases. If so, you cannot use the new API out of the box, as it will not be available on releases before OTP 18. The solution is &lt;strong&gt;not&lt;/strong&gt; to avoid using the new API, as your code would then not benefit from the scalability and accuracy improvements made. Instead, use the new API when available, and fall back on &lt;code&gt;erlang:now/0&lt;/code&gt; when the new API is unavailable.</source>
          <target state="translated">異なるOTPリリースのさまざまなOTPインストールでコードを実行する必要がある場合があります。その場合、OTP 18より前のリリースでは利用できないため、新しいAPIをそのまま使用することはできません。コードはスケーラビリティと精度の向上の恩恵を受けないため、解決策は新しいAPIの使用を避けることではあり&lt;strong&gt;ません。&lt;/strong&gt;製。代わりに、使用可能な場合は新しいAPIを使用し、新しいAPIが使用できない場合は &lt;code&gt;erlang:now/0&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="bfb69fb6c9632871f7941143462a0957b50d8dd0" translate="yes" xml:space="preserve">
          <source>It can be seen that the DBMS was initiated from a regular text file.</source>
          <target state="translated">通常のテキストファイルからDBMSが起動されたことがわかります。</target>
        </trans-unit>
        <trans-unit id="e75e6728c619228a8a187725396b17bac62286a9" translate="yes" xml:space="preserve">
          <source>It can be useful to find the maximum and minimum temperature in lists like this. Before extending the program to do this, let us look at functions for finding the maximum value of the elements in a list:</source>
          <target state="translated">このようなリストの最大値と最小値を求めるのに便利です。そのためのプログラムを拡張する前に、リスト内の要素の最大値を求める関数を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="a8817b3a522907eb1d028eaf50da33a71ee687b3" translate="yes" xml:space="preserve">
          <source>It can be verified that sharing will be lost if the data is inserted into an Ets table:</source>
          <target state="translated">Etsテーブルにデータを挿入すると共有が失われることが確認できます。</target>
        </trans-unit>
        <trans-unit id="27f936533cc1f942a4c17074d1665c908f8eec35" translate="yes" xml:space="preserve">
          <source>It can be:</source>
          <target state="translated">だろうな。</target>
        </trans-unit>
        <trans-unit id="16e18e41dba30df6f2a27da6db7356bd2d51bd66" translate="yes" xml:space="preserve">
          <source>It can optionally also export some, or all, of the following:</source>
          <target state="translated">オプションで、以下の一部または全部をエクスポートすることもできます。</target>
        </trans-unit>
        <trans-unit id="8d39574d1fe984a33b1d8417902ff2e4fa04c224" translate="yes" xml:space="preserve">
          <source>It can sometimes be beneficial to be able to generate events to your own state machine. This can be done with the &lt;code&gt;&lt;a href=&quot;#State%20Transition%20Actions&quot;&gt;State Transition Action&lt;/a&gt;&lt;/code&gt;&lt;code&gt;{next_event,EventType,EventContent}&lt;/code&gt;.</source>
          <target state="translated">独自のステートマシンにイベントを生成できると便利な場合があります。これは、 &lt;code&gt;&lt;a href=&quot;#State%20Transition%20Actions&quot;&gt;State Transition Action&lt;/a&gt;&lt;/code&gt; &lt;code&gt;{next_event,EventType,EventContent}&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="0df60d291abc2f1c1b6553af06070513493b119c" translate="yes" xml:space="preserve">
          <source>It can sometimes be helpful to enable trace for a specified period of time (for example, to monitor a system for 24 hours or half a second). This can be done with option &lt;code&gt;{timer, TimerSpec}&lt;/code&gt;. If &lt;code&gt;TimerSpec&lt;/code&gt; has the form of &lt;code&gt;MSec&lt;/code&gt;, the trace is stopped after &lt;code&gt;MSec&lt;/code&gt; milliseconds using &lt;code&gt;&lt;a href=&quot;ttb#stop-0&quot;&gt;ttb:stop/0&lt;/a&gt;&lt;/code&gt;. If more options are provided (&lt;code&gt;TimerSpec = {MSec, Opts}&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;ttb#stop-1&quot;&gt;ttb:stop/1&lt;/a&gt;&lt;/code&gt; is called instead with &lt;code&gt;Opts&lt;/code&gt; as argument.</source>
          <target state="translated">指定された期間トレースを有効にすると役立つ場合があります（たとえば、システムを24時間または0.5秒監視する）。これは、オプション &lt;code&gt;{timer, TimerSpec}&lt;/code&gt; できます。場合 &lt;code&gt;TimerSpec&lt;/code&gt; はの形式は &lt;code&gt;MSec&lt;/code&gt; 、トレースが停止した後 &lt;code&gt;MSec&lt;/code&gt; 使用（ミリ秒） &lt;code&gt;&lt;a href=&quot;ttb#stop-0&quot;&gt;ttb:stop/0&lt;/a&gt;&lt;/code&gt; 。さらにオプションが提供されている場合（ &lt;code&gt;TimerSpec = {MSec, Opts}&lt;/code&gt; ）、代わりに &lt;code&gt;Opts&lt;/code&gt; を引数として &lt;code&gt;&lt;a href=&quot;ttb#stop-1&quot;&gt;ttb:stop/1&lt;/a&gt;&lt;/code&gt; が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="1166234dedafbc9026660c1e71ce391bf682d71c" translate="yes" xml:space="preserve">
          <source>It can vary from case to case which combination of selective/complete decode or exclusive/part decode is the fastest.</source>
          <target state="translated">選択的/完全デコードと排他的/部分デコードのどちらの組み合わせが速いかは、ケースによって異なります。</target>
        </trans-unit>
        <trans-unit id="b21d9b21f8fd67733cf908cf5de319a682227acf" translate="yes" xml:space="preserve">
          <source>It cannot retrieve external entities on the Internet by a URL reference, only resources in the local file system.</source>
          <target state="translated">URL参照によるインターネット上の外部エンティティの取得はできず、ローカルファイルシステム内のリソースのみを取得します。</target>
        </trans-unit>
        <trans-unit id="16ad56b9e963d65cee1d6e784ab67ae9a7a2c796" translate="yes" xml:space="preserve">
          <source>It causes &lt;code&gt;Mnesia&lt;/code&gt; to try to contact the node at startup of disc-full nodes.</source>
          <target state="translated">これにより、 &lt;code&gt;Mnesia&lt;/code&gt; はディスクフルノードの起動時にノードに接続しようとします。</target>
        </trans-unit>
        <trans-unit id="f72ebd5459698111bb78002fb36494deb48145f4" translate="yes" xml:space="preserve">
          <source>It could also be a late reply to a synchronous request.</source>
          <target state="translated">また、同期リクエストへの返信が遅れている可能性もあります。</target>
        </trans-unit>
        <trans-unit id="c3698cc734ccb5f61d3ae21369086bfe0bd5a1e8" translate="yes" xml:space="preserve">
          <source>It does not really implement any management capabilities by itself. That is up to the &lt;strong&gt;user&lt;/strong&gt;.</source>
          <target state="translated">それ自体が実際に管理機能を実装することはありません。それは&lt;strong&gt;ユーザー&lt;/strong&gt;次第です。</target>
        </trans-unit>
        <trans-unit id="2f06f024f140f97af334f2f96d37458dba2e893a" translate="yes" xml:space="preserve">
          <source>It does not set any &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition_option()&lt;/a&gt;&lt;/code&gt; but instead replies to a caller waiting for a reply in &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/2&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;From&lt;/code&gt; must be the term from argument &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;{call,From}&lt;/a&gt;&lt;/code&gt; in a call to a &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">それは、 &lt;code&gt;&lt;a href=&quot;#type-transition_option&quot;&gt;transition_option()&lt;/a&gt;&lt;/code&gt; を設定しませんが、代わりに &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/2&lt;/a&gt;&lt;/code&gt; で応答を待っている呼び出し元に応答します。 &lt;code&gt;From&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; への &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;{call,From}&lt;/a&gt;&lt;/code&gt; 引数{call、From}からの用語でなければなりません。</target>
        </trans-unit>
        <trans-unit id="7017aa44c3506907262780fe0caea30cac852593" translate="yes" xml:space="preserve">
          <source>It has been implemented on top of the User Datagram protocol (UDP) so it may be used to move files between machines on different networks implementing UDP. It is designed to be small and easy to implement. Therefore, it lacks most of the features of a regular FTP. The only thing it can do is read and write files (or mail) from/to a remote server. It cannot list directories, and currently has no provisions for user authentication.</source>
          <target state="translated">ユーザーデータグラムプロトコル(UDP)の上に実装されているので、UDPを実装した異なるネットワーク上のマシン間でファイルを移動するために使用することができます。小さくて実装しやすいように設計されています。したがって、それは通常のFTPの機能のほとんどを欠いています。唯一できることは、リモートサーバとの間でファイル(またはメール)を読み書きすることです。ディレクトリをリストアップすることはできず、現在のところユーザ認証の規定はありません。</target>
        </trans-unit>
        <trans-unit id="3f8d75bfb90a8936251b79f719fa6e9b6f94c3d3" translate="yes" xml:space="preserve">
          <source>It has previously been shown that each table has a number of system attributes, such as &lt;code&gt;index&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">以前に、各テーブルには &lt;code&gt;index&lt;/code&gt; や &lt;code&gt;type&lt;/code&gt; などのシステム属性がいくつかあることが示されています。</target>
        </trans-unit>
        <trans-unit id="bbd5032f06df0ef2f2a99e589085d981c5bc3619" translate="yes" xml:space="preserve">
          <source>It is &lt;code&gt;true&lt;/code&gt; if the predicate applied to all elements in the list is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">リスト内のすべての要素に適用される述語が &lt;code&gt;true&lt;/code&gt; の場合は &lt;code&gt;true&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="0472f06f57f61fb910d5f2746c6db12d6bf0beef" translate="yes" xml:space="preserve">
          <source>It is a channel callback module that implements a shell and command execution. The shell's read-eval-print loop can be customized, using the option &lt;code&gt;&lt;a href=&quot;#type-shell_daemon_option&quot;&gt;shell&lt;/a&gt;&lt;/code&gt;. This means less work than implementing an own CLI channel. If &lt;code&gt;ssh_cli&lt;/code&gt; is set to &lt;code&gt;no_cli&lt;/code&gt;, the CLI channels like &lt;code&gt;&lt;a href=&quot;#type-shell_daemon_option&quot;&gt;shell&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#type-exec_daemon_option&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; are disabled and only subsystem channels are allowed.</source>
          <target state="translated">これは、シェルとコマンド実行を実装するチャネルコールバックモジュールです。シェルのread-eval-printループは、オプションの &lt;code&gt;&lt;a href=&quot;#type-shell_daemon_option&quot;&gt;shell&lt;/a&gt;&lt;/code&gt; を使用してカスタマイズできます。これは、独自のCLIチャネルを実装するよりも作業が少ないことを意味します。場合 &lt;code&gt;ssh_cli&lt;/code&gt; がに設定されている &lt;code&gt;no_cli&lt;/code&gt; 、などのCLIチャンネル &lt;code&gt;&lt;a href=&quot;#type-shell_daemon_option&quot;&gt;shell&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;#type-exec_daemon_option&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; が無効になっているとだけサブチャネルが許可されています。</target>
        </trans-unit>
        <trans-unit id="9cfea932baea2333d069d06996afd05ae69495a2" translate="yes" xml:space="preserve">
          <source>It is a dump from an old OTP release in which this item was not written.</source>
          <target state="translated">この項目が書かれていない古いOTPリリースからのダンプです。</target>
        </trans-unit>
        <trans-unit id="e3c2eb9542657da53e8c70e8a085ab3bd63983e1" translate="yes" xml:space="preserve">
          <source>It is advised for compilers to remove all non-deterministic information if the &lt;code&gt;deterministic&lt;/code&gt; option is supported and it was supplied by the user.</source>
          <target state="translated">&lt;code&gt;deterministic&lt;/code&gt; オプションがサポートされており、ユーザーによって提供された場合、コンパイラーはすべての非確定的情報を削除することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="bdc959811bb36191808503a6fa15bf4c4b73e490" translate="yes" xml:space="preserve">
          <source>It is allowed to omit &lt;code&gt;Class&lt;/code&gt; and &lt;code&gt;Stacktrace&lt;/code&gt;. An omitted &lt;code&gt;Class&lt;/code&gt; is shorthand for &lt;code&gt;throw&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Class&lt;/code&gt; と &lt;code&gt;Stacktrace&lt;/code&gt; は省略できます。省略された &lt;code&gt;Class&lt;/code&gt; は、 &lt;code&gt;throw&lt;/code&gt; の省略形です。</target>
        </trans-unit>
        <trans-unit id="abf6d7124954bad38d134fedee149371dc306be5" translate="yes" xml:space="preserve">
          <source>It is also assumed that in the home directory of &lt;code&gt;otpuser&lt;/code&gt;, there is a directory named &lt;code&gt;otp&lt;/code&gt;, the full path of which is:</source>
          <target state="translated">また、 &lt;code&gt;otpuser&lt;/code&gt; のホームディレクトリには、otpという名前のディレクトリが &lt;code&gt;otp&lt;/code&gt; 、そのフルパスは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="9c70f3b40e4a761a37740b02e2f452d7fdd283c0" translate="yes" xml:space="preserve">
          <source>It is also necessary to take care of the types &lt;code&gt;ERL_ERROR&lt;/code&gt; (an error occurred) and &lt;code&gt;ERL_TICK&lt;/code&gt; (alive check from other node, is to be ignored). Other possible types indicate process events such as link, unlink, and exit:</source>
          <target state="translated">また、タイプ &lt;code&gt;ERL_ERROR&lt;/code&gt; （エラーが発生しました）および &lt;code&gt;ERL_TICK&lt;/code&gt; （他のノードからのアライブチェックは無視されます）にも注意する必要があります。他の可能なタイプは、リンク、リンク解除、終了などのプロセスイベントを示します。</target>
        </trans-unit>
        <trans-unit id="c5a50cd1bdb197fcc39af462f4c2f62a0631dfb0" translate="yes" xml:space="preserve">
          <source>It is also of interest to know the relation is between a complete decode, an exclusive decode followed by &lt;code&gt;decode_part&lt;/code&gt; of the excluded parts, and a selective decode followed by a complete decode. Some situations can be compared to this simulation, for example, inspect a subvalue and later inspect the entire value. The following table shows figures from this test. The number of loops and the time unit are the same as in the previous test.</source>
          <target state="translated">また、完全なデコード、除外されたパーツの &lt;code&gt;decode_part&lt;/code&gt; が後に続く排他的デコード、および完全なデコードが後に続く選択的デコードの間の関係を知ることも重要です。一部の状況は、このシミュレーションと比較できます。たとえば、サブ値を検査し、後で値全体を検査します。次の表は、このテストの数値を示しています。ループ数と時間単位は、前のテストと同じです。</target>
        </trans-unit>
        <trans-unit id="430745d1b00721c91adf6b7795f4d85575fbbdfd" translate="yes" xml:space="preserve">
          <source>It is also possible to call &lt;code&gt;net_kernel:start([foobar])&lt;/code&gt; directly from the normal Erlang shell prompt:</source>
          <target state="translated">通常のErlangシェルプロンプトから直接 &lt;code&gt;net_kernel:start([foobar])&lt;/code&gt; を呼び出すこともできます：</target>
        </trans-unit>
        <trans-unit id="b17c759d73ecb8e47a8732d667bdc184b493889c" translate="yes" xml:space="preserve">
          <source>It is also possible to dig deeper and, for example, perform pattern matching on the various reasons for skipped or failed. Notice that &lt;code&gt;{'EXIT',Reason}&lt;/code&gt; tuples are translated into &lt;code&gt;{error,Reason}&lt;/code&gt;. Notice also that if a &lt;code&gt;{failed,{Suite,end_per_testcase,FailInfo}&lt;/code&gt; result is received, the test case was successful, but &lt;code&gt;end_per_testcase&lt;/code&gt; for the case failed.</source>
          <target state="translated">さらに深く掘り下げて、たとえば、スキップまたは失敗したさまざまな理由でパターンマッチングを実行することもできます。 &lt;code&gt;{'EXIT',Reason}&lt;/code&gt; タプルは &lt;code&gt;{error,Reason}&lt;/code&gt; 変換されることに注意してください。また、 &lt;code&gt;{failed,{Suite,end_per_testcase,FailInfo}&lt;/code&gt; 結果を受け取った場合、テストケースは成功しましたが、ケースの &lt;code&gt;end_per_testcase&lt;/code&gt; が失敗したことにも注意してください。</target>
        </trans-unit>
        <trans-unit id="f8151f1eae3c7a350004aaaa46abaeee77adbcc2" translate="yes" xml:space="preserve">
          <source>It is also possible to do further processing of parsed XML with xmerl. If you want to change format of the XML document to for instance HTML, text or other XML format you can transform it. There is support for such transformations in xmerl.</source>
          <target state="translated">また、xmerlを使ってパースされたXMLをさらに処理することも可能です。XMLドキュメントのフォーマットをHTMLやテキストなどのXMLフォーマットに変更したい場合は、変換することができます。xmerlにはこのような変換をサポートしています。</target>
        </trans-unit>
        <trans-unit id="14975a2ed99f645727531a93c1fa136da016d57c" translate="yes" xml:space="preserve">
          <source>It is also possible to import MIBs from OTP applications in an &lt;code&gt;&quot;include_lib&quot;&lt;/code&gt; like fashion with the &lt;code&gt;il&lt;/code&gt; option. Example:</source>
          <target state="translated">&lt;code&gt;il&lt;/code&gt; オプションを使用して、 &lt;code&gt;&quot;include_lib&quot;&lt;/code&gt; ような方法でOTPアプリケーションからMIBをインポートすることもできます。例：</target>
        </trans-unit>
        <trans-unit id="9aa704896d79235d85aad0da0fabd9cf784e3fd6" translate="yes" xml:space="preserve">
          <source>It is also possible to make the parser ask for more input tokens when needed if the following call format is used:</source>
          <target state="translated">また、以下の呼び出し形式を使用すれば、必要に応じてパーサにさらに入力トークンを要求させることができます。</target>
        </trans-unit>
        <trans-unit id="0c383d15045b8504152e045fd9c571fda9d5f908" translate="yes" xml:space="preserve">
          <source>It is also possible to perform live tracing of a running system by making use of the built-in trace support in the Erlang emulator. These Erlang traces can be directed to files or to ports. See the reference manual for &lt;code&gt;erlang:trace/4&lt;/code&gt;, &lt;code&gt;erlang:trace_pattern/3&lt;/code&gt;, &lt;code&gt;dbg&lt;/code&gt; and &lt;code&gt;ttb&lt;/code&gt; for more info.</source>
          <target state="translated">また、Erlangエミュレータの組み込みトレースサポートを利用して、実行中のシステムのライブトレースを実行することもできます。これらのErlangトレースは、ファイルまたはポートに送信できます。詳細については、 &lt;code&gt;erlang:trace/4&lt;/code&gt; 、 &lt;code&gt;erlang:trace_pattern/3&lt;/code&gt; 、 &lt;code&gt;dbg&lt;/code&gt; および &lt;code&gt;ttb&lt;/code&gt; のリファレンスマニュアルを参照してください。</target>
        </trans-unit>
        <trans-unit id="41ebfd44811c7419cd9574f7d7d60c6961c05cc8" translate="yes" xml:space="preserve">
          <source>It is also possible to push back characters into the input characters with the following returns:</source>
          <target state="translated">また、以下のようなリターンで入力文字に文字を押し戻すことも可能です。</target>
        </trans-unit>
        <trans-unit id="05fa2dcff8f4128cd8ba172c0c2e9803bd23c257" translate="yes" xml:space="preserve">
          <source>It is also possible to refer to a function defined in a different module, with the following syntax:</source>
          <target state="translated">また、以下の構文で、別のモジュールで定義された関数を参照することも可能です。</target>
        </trans-unit>
        <trans-unit id="20722acbae34522cf86f97ada05f47778507e40b" translate="yes" xml:space="preserve">
          <source>It is also possible to refer to later opened parentheses, by writing references such as (?+2). However, these cannot be recursive, as the reference is not inside the parentheses that are referenced. They are always non-recursive subroutine calls, as described in the next section.</source>
          <target state="translated">(?+2)のような参照を書くことで、後に開いた括弧を参照することも可能です。しかし、これらは参照先の括弧の中にはないので、再帰的に参照することはできません。次の節で説明するように、これらは常に再帰的ではないサブルーチン呼び出しです。</target>
        </trans-unit>
        <trans-unit id="1bc8e55a741fd982875922535be0a290d5e493ac" translate="yes" xml:space="preserve">
          <source>It is also possible to specify names and values for extra variables that should be sent in the notification, but were not defined in the notification specification.</source>
          <target state="translated">通知で送信されるべきだが、通知仕様では定義されていない余分な変数の名前と値を指定することも可能です。</target>
        </trans-unit>
        <trans-unit id="e96afe727ef3a6cdba9249f88e9858694c628d45" translate="yes" xml:space="preserve">
          <source>It is also possible to trace immediately into the profiling process that creates the raw profile data, that is to short circuit the tracing and profiling steps so that the filesystem is not used.</source>
          <target state="translated">また、生のプロファイルデータを作成するプロファイリングプロセスにすぐにトレースすることも可能で、トレースとプロファイリングのステップを短絡させてファイルシステムを使用しないようにします。</target>
        </trans-unit>
        <trans-unit id="38d9bdad443276567d85de0b3d4b695aa8af5458" translate="yes" xml:space="preserve">
          <source>It is also possible to write your own Net if process and this section describes how to do that.</source>
          <target state="translated">また、独自のNet ifプロセスを書くことも可能で、ここではその方法を説明します。</target>
        </trans-unit>
        <trans-unit id="0443424fb9ad4a6013fc87f7edd777ad9e3ed640" translate="yes" xml:space="preserve">
          <source>It is also possible to write your own Net if process. The default Net if process is implemented in the module &lt;code&gt;snmpa_net_if&lt;/code&gt; and it uses UDP as the transport protocol i.e the transport domains &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; and/or &lt;code&gt;transportDomainUdpIpv6&lt;/code&gt;.</source>
          <target state="translated">if処理で独自のネットを書くことも可能です。デフォルトのNet ifプロセスはモジュール &lt;code&gt;snmpa_net_if&lt;/code&gt; に実装され、トランスポートプロトコルとしてUDPを使用します。つまり、トランスポートドメイン &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; および/または &lt;code&gt;transportDomainUdpIpv6&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="38b9346e442ee7340bad67270cc18e9b0d13905f" translate="yes" xml:space="preserve">
          <source>It is also possible, in &lt;code&gt;end_per_group/2&lt;/code&gt;, to check the status of a subgroup (maybe to determine what status the current group is to return). This is as simple as illustrated in the previous example, only the group name is stored in a tuple &lt;code&gt;{group_result,GroupName}&lt;/code&gt;, which can be searched for in the status lists.</source>
          <target state="translated">&lt;code&gt;end_per_group/2&lt;/code&gt; で、サブグループのステータスを確認することもできます（おそらく、現在のグループが返すステータスを決定するため）。これは前の例で示したように単純です。グループ名のみがタプル &lt;code&gt;{group_result,GroupName}&lt;/code&gt; に格納され、ステータスリストで検索できます。</target>
        </trans-unit>
        <trans-unit id="ef03b90d92e28fc57662f95ab1cf5a610f370745" translate="yes" xml:space="preserve">
          <source>It is also recommended that the &lt;code&gt;ct.hrl&lt;/code&gt; header file is included in all test suite modules.</source>
          <target state="translated">また、 &lt;code&gt;ct.hrl&lt;/code&gt; ヘッダーファイルをすべてのテストスイートモジュールに含めることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="313a7e4451fc081efeaa2c6bb4fb1dfc6f14d0a1" translate="yes" xml:space="preserve">
          <source>It is also useful to update the database within a transaction if several processes concurrently update the same records. For example, the function &lt;code&gt;raise(Name, Amount)&lt;/code&gt;, which adds &lt;code&gt;Amount&lt;/code&gt; to the salary field of a person, is to be implemented as follows:</source>
          <target state="translated">複数のプロセスが同じレコードを同時に更新する場合、トランザクション内でデータベースを更新することも役立ちます。たとえば、個人の給与フィールドに &lt;code&gt;Amount&lt;/code&gt; を追加する関数 &lt;code&gt;raise(Name, Amount)&lt;/code&gt; 、次のように実装されます。</target>
        </trans-unit>
        <trans-unit id="4b6eccdabde840ecd1e02e1dfcae25d7936cafd7" translate="yes" xml:space="preserve">
          <source>It is also worth to keep in mind that programs with timers can behave differently when debugged. This is especially true when stopping the execution of a process (for example, at a breakpoint). Time-outs can then occur in other processes that continue execution as normal.</source>
          <target state="translated">また、タイマーを持つプログラムはデバッグ時に異なる動作をすることがあることを覚えておくとよいでしょう。これは特に、プロセスの実行を停止したとき(例えば、ブレークポイントで)に当てはまります。そして、通常通りに実行を続ける他のプロセスでもタイムアウトが発生することがあります。</target>
        </trans-unit>
        <trans-unit id="de21ba3a5d42796cea74d79d5a22659949031529" translate="yes" xml:space="preserve">
          <source>It is an error if not all of the characters in &lt;code&gt;String&lt;/code&gt; are consumed.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 内のすべての文字が消費されない場合はエラーになります。</target>
        </trans-unit>
        <trans-unit id="1169d92cb2cd8a5d121fb5cf87770320a1885975" translate="yes" xml:space="preserve">
          <source>It is assigned a value in Erlang as follows:</source>
          <target state="translated">Erlangでは以下のように値が割り当てられます。</target>
        </trans-unit>
        <trans-unit id="4b026425ce0c7a9d0f11df724a1d98610d0783ee" translate="yes" xml:space="preserve">
          <source>It is assumed that drivers do not access other drivers. If drivers access each other, they must provide their own mechanism for thread-safe synchronization. Such &quot;inter-driver communication&quot; is strongly discouraged.</source>
          <target state="translated">ドライバが他のドライバにアクセスしないことを前提としています。ドライバが互いにアクセスする場合は、スレッドセーフ同期のための独自のメカニズムを提供しなければなりません。このような &quot;ドライバ間通信 &quot;は強くお勧めしません。</target>
        </trans-unit>
        <trans-unit id="00523370ed1fef973a609af025d17f8d7fd78abb" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader has done some programming and is familiar with concepts such as data types and programming language syntax.</source>
          <target state="translated">読者は、ある程度のプログラミングを行い、データ型やプログラミング言語の構文などの概念に精通していることを前提としています。</target>
        </trans-unit>
        <trans-unit id="539ca4643ea98ae299a95a5eae96dbefe42276e2" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language and has a basic understanding of the concepts of using public-keys and digital certificates.</source>
          <target state="translated">読者はErlangプログラミング言語に精通しており、公開鍵とデジタル証明書の概念を基本的に理解していることを前提としています。</target>
        </trans-unit>
        <trans-unit id="a6052ded16f1143a2540c6e38a39ca5ce2ceee2c" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language, concepts of &lt;strong&gt;OTP&lt;/strong&gt;, and has a basic understanding of &lt;strong&gt;public keys&lt;/strong&gt;.</source>
          <target state="translated">読者は、Erlangプログラミング言語、&lt;strong&gt;OTPの&lt;/strong&gt;概念に精通しており、&lt;strong&gt;公開鍵&lt;/strong&gt;についての基本的な知識があることを前提としてい&lt;strong&gt;ます&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="243320d766e4df468a34184aedf16e004fb9c770" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language, concepts of OTP and has a basic knowledge of SNMP.</source>
          <target state="translated">読者はErlangプログラミング言語、OTPの概念、SNMPの基本的な知識に精通していることが前提となっています。</target>
        </trans-unit>
        <trans-unit id="367f5b39b966ad211fd31d9fe4e051b0012e6562" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language, concepts of OTP and has a basic understanding of relational databases and SQL.</source>
          <target state="translated">読者はErlangプログラミング言語、OTPの概念に精通し、リレーショナルデータベースとSQLの基本的な理解があることを前提としています。</target>
        </trans-unit>
        <trans-unit id="c531f58d242ffa0ef29281ed62ced9b43c4c5836" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language, concepts of OTP, and has a basic understanding of and HTTP protocol.</source>
          <target state="translated">これは、読者がErlangプログラミング言語、OTPの概念に精通していること、およびHTTPプロトコルの基本的な理解を持っていることを前提としています。</target>
        </trans-unit>
        <trans-unit id="226cdb7652f0e63605e771f89f0979cf6a181d4a" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language, concepts of OTP, and has a basic understanding of the FTP protocol.</source>
          <target state="translated">読者はErlangプログラミング言語、OTPの概念に精通し、FTPプロトコルの基本的な理解があることを前提としています。</target>
        </trans-unit>
        <trans-unit id="ffe91dc03e0f170b97f84ca7d684803118d71efd" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language, concepts of OTP, and has a basic understanding of the TFTP protocol.</source>
          <target state="translated">読者はErlangプログラミング言語、OTPの概念に精通しており、TFTPプロトコルの基本的な理解があることを前提としています。</target>
        </trans-unit>
        <trans-unit id="6ad11381560d09325d3341cb53cee49377ce9e91" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language, concepts of OTP, and is familiar with the ASN.1 notation. The ASN.1 notation is documented in the standard definition X.680, which is the primary text. It can also be helpful, but not necessary, to read the standard definitions X.681, X.682, X.683, X.690, and X.691.</source>
          <target state="translated">読者はErlangプログラミング言語、OTPの概念、ASN.1記法に精通していることを前提としています。ASN.1記法は標準定義X.680で文書化されています。また、標準定義X.681,X.682,X.683,X.690,X.691を読むのも便利ですが、必須ではありません。</target>
        </trans-unit>
        <trans-unit id="f994e3d36186bc56a3b0c41d4317147ad16d939f" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language, system development principles, and database management systems.</source>
          <target state="translated">読者はErlangプログラミング言語、システム開発の原理、データベース管理システムに精通していることが前提となります。</target>
        </trans-unit>
        <trans-unit id="c80c2b6f4e39beead5852bafd919144c58cd0f95" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language, the concepts of OTP, and has a basic understanding of SSL/TLS/DTLS.</source>
          <target state="translated">読者はErlangプログラミング言語、OTPの概念に精通しており、SSL/TLS/DTLSの基本的な理解があることを前提としています。</target>
        </trans-unit>
        <trans-unit id="196722391e42a0afccee28b3efb0c6e7a2974b84" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is familiar with the Erlang programming language.</source>
          <target state="translated">読者はErlangプログラミング言語に精通していることが前提です。</target>
        </trans-unit>
        <trans-unit id="b881451c83c7ede35a49713311b8b3c77d21da3f" translate="yes" xml:space="preserve">
          <source>It is assumed that tracing has already been enabled (see &lt;code&gt;enable_trace&lt;/code&gt; above).</source>
          <target state="translated">トレースがすでに有効になっていることが前提です（上記の &lt;code&gt;enable_trace&lt;/code&gt; を参照）。</target>
        </trans-unit>
        <trans-unit id="fbce7d0b5c1d3d362c2e0e3170d2a81ddcc3cae0" translate="yes" xml:space="preserve">
          <source>It is assumed that you are a skilled Erlang programmer, familiar with concepts such as Erlang data types, processes, messages, and error handling.</source>
          <target state="translated">あなたが熟練したErlangプログラマーで、Erlangのデータ型、プロセス、メッセージ、エラー処理などの概念に精通していることが前提となります。</target>
        </trans-unit>
        <trans-unit id="46d05879b990c1b42f80173e3ce33f9af16334ea" translate="yes" xml:space="preserve">
          <source>It is assumed that you are familiar with the Erlang programming language and the OTP concepts.</source>
          <target state="translated">Erlangプログラミング言語とOTPの概念に精通していることが前提です。</target>
        </trans-unit>
        <trans-unit id="c59fc60f5301a42fa897f9e86ad129262fbe9775" translate="yes" xml:space="preserve">
          <source>It is assumed that you have a good understanding of drivers.</source>
          <target state="translated">ドライバーのことをよく理解していることが前提です。</target>
        </trans-unit>
        <trans-unit id="57d587d7dcd33bf268c53e8c295b7bbd98dd5a25" translate="yes" xml:space="preserve">
          <source>It is assumed that you have a working Erlang/OTP system structured according to the OTP design principles.</source>
          <target state="translated">OTP設計の原則に沿って構成されたErlang/OTPシステムが動作していることを前提としています。</target>
        </trans-unit>
        <trans-unit id="65b8a74dc8b2985b7d8ff2f06c5800ab5b031e0b" translate="yes" xml:space="preserve">
          <source>It is called before scheme string gets converted into scheme atom and thus possible atom leak could be prevented</source>
          <target state="translated">スキーム文字列がスキームアトムに変換される前に呼び出され、アトムリークを防ぐことができます。</target>
        </trans-unit>
        <trans-unit id="9008c50a0a551cbb25d9ec24896b64ea9a564251" translate="yes" xml:space="preserve">
          <source>It is common that ASN.1 modules import defined types, values, and other entities from another ASN.1 module.</source>
          <target state="translated">ASN.1モジュールが定義された型、値、その他のエンティティを別のASN.1モジュールからインポートすることは一般的です。</target>
        </trans-unit>
        <trans-unit id="84117e18953c312000f68fd2f9a76688512ad635" translate="yes" xml:space="preserve">
          <source>It is easy to design applications that use SNMP to manipulate and control the system. &lt;code&gt;Mnesia&lt;/code&gt; provides a direct mapping between the logical tables that make up an SNMP control application and the physical data that makes up a &lt;code&gt;Mnesia&lt;/code&gt; table. The default value is &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">SNMPを使用してシステムを操作および制御するアプリケーションの設計は簡単です。 &lt;code&gt;Mnesia&lt;/code&gt; は、SNMP制御アプリケーションを構成する論理テーブルと &lt;code&gt;Mnesia&lt;/code&gt; テーブルを構成する物理データの間の直接マッピングを提供します。デフォルト値は &lt;code&gt;[]&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="cce76fb9ee4c72d8c84f9435e857ad958e3bb420" translate="yes" xml:space="preserve">
          <source>It is easy to make mistakes when registering sub-agents and this activity should be done carefully. For example, a strange behaviour would result from the following configuration:</source>
          <target state="translated">サブエージェントを登録する際に間違いを犯しやすいので、この作業は慎重に行う必要があります。例えば、以下のような設定をすると、奇妙な動作が発生します。</target>
        </trans-unit>
        <trans-unit id="b4c9710b1e208fb15c3da52130d4225c07e26a51" translate="yes" xml:space="preserve">
          <source>It is easy to show examples of code that executes faster if a non-normalized data model is used, instead of a normalized model. The main reason is that fewer tables are required. Therefore, data from different tables can more easily be combined in join operations. In the previous example, the function &lt;code&gt;get_emps/2&lt;/code&gt; is transformed from a join operation into a simple query, which consists of a selection and a projection on one single table.</source>
          <target state="translated">正規化されたモデルの代わりに、正規化されていないデータモデルが使用された場合、より速く実行されるコードの例を示すのは簡単です。主な理由は、必要なテーブルが少ないことです。したがって、異なるテーブルのデータを結合操作でより簡単に組み合わせることができます。前の例では、関数 &lt;code&gt;get_emps/2&lt;/code&gt; は、結合操作から単純なクエリに変換されます。これは、選択と1つの単一テーブルのプロジェクションで構成されています。</target>
        </trans-unit>
        <trans-unit id="da800d6ee148efa5e9b76c02de805a669c995873" translate="yes" xml:space="preserve">
          <source>It is encouraged to omit empty directories.</source>
          <target state="translated">空のディレクトリを省略することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="f598ee38e63f95f13ae4c91139c94c9acddbba8b" translate="yes" xml:space="preserve">
          <source>It is enough to initialize &lt;code&gt;myKey&lt;/code&gt; once for each driver instance.</source>
          <target state="translated">各ドライバーインスタンスに対して &lt;code&gt;myKey&lt;/code&gt; を 1回初期化するだけで十分です。</target>
        </trans-unit>
        <trans-unit id="09d13ede3ec03425733048bb49466428e4cde9a4" translate="yes" xml:space="preserve">
          <source>It is expected that the type language described in this section supersedes and replaces the purely comment-based &lt;code&gt;@type&lt;/code&gt; and &lt;code&gt;@spec&lt;/code&gt; declarations used by EDoc.</source>
          <target state="translated">このセクションで説明する型言語は、 &lt;code&gt;@spec&lt;/code&gt; 使用される純粋にコメントベースの &lt;code&gt;@type&lt;/code&gt; および@spec宣言に取って代わり、置き換えられることが期待されています。</target>
        </trans-unit>
        <trans-unit id="bd88b807c9b8b49f6a04c0814a09c4643a76b579" translate="yes" xml:space="preserve">
          <source>It is fairly easy to write a generator which, each time it is called, either produces an empty list if it is done, or otherwise produces a list containing a single test case plus a new generator which will produce the rest of the tests. This demonstrates the basic pattern:</source>
          <target state="translated">ジェネレータを書くのはかなり簡単で、それが呼ばれるたびに、それが完了した場合は空のリストを生成するか、そうでない場合は、1つのテストケースと残りのテストを生成する新しいジェネレータを含むリストを生成します。これは基本的なパターンを示しています。</target>
        </trans-unit>
        <trans-unit id="216d3558427ea98e53bf41b5f47e9b9d46bf1da8" translate="yes" xml:space="preserve">
          <source>It is good programming practice, but not mandatory, to ensure that a macro definition is a valid Erlang syntactic form.</source>
          <target state="translated">マクロの定義が有効なErlangの構文形式であることを確認することはプログラミングの良い習慣ですが、必須ではありません。</target>
        </trans-unit>
        <trans-unit id="658c926a7a3ff092c88e185ba8a44d03268b9b65" translate="yes" xml:space="preserve">
          <source>It is important that the table has a sufficient number of slots for the objects. If not, the hash list starts to grow when &lt;code&gt;init_table/2&lt;/code&gt; returns, which significantly slows down access to the table for a period of time. The minimum number of slots is set by the &lt;code&gt;open_file/2&lt;/code&gt; option &lt;code&gt;min_no_slots&lt;/code&gt; and returned by the &lt;code&gt;info/2&lt;/code&gt; item &lt;code&gt;no_slots&lt;/code&gt;. See also option &lt;code&gt;min_no_slots&lt;/code&gt; below.</source>
          <target state="translated">テーブルには、オブジェクト用の十分な数のスロットがあることが重要です。そうでない場合、 &lt;code&gt;init_table/2&lt;/code&gt; が戻るときにハッシュリストが大きくなり始め、一定期間テーブルへのアクセスが大幅に遅くなります。スロットの最小数は、 &lt;code&gt;open_file/2&lt;/code&gt; オプション &lt;code&gt;min_no_slots&lt;/code&gt; によって設定され、 &lt;code&gt;info/2&lt;/code&gt; アイテム &lt;code&gt;no_slots&lt;/code&gt; によって返されます。以下のオプション &lt;code&gt;min_no_slots&lt;/code&gt; も参照してください。</target>
        </trans-unit>
        <trans-unit id="cc58fdeef579f98fae78bf5fe0d5883ad2b7f7a5" translate="yes" xml:space="preserve">
          <source>It is important though that the returned data is of the correct type depending on the options set. We therefore convert the lists to binaries in the correct encoding &lt;strong&gt;if possible&lt;/strong&gt; before returning. The function supplied in the &lt;code&gt;get_until&lt;/code&gt; request tuple can, as its final result return anything, so only functions returning lists can get them converted to binaries. If the request contains encoding tag &lt;code&gt;unicode&lt;/code&gt;, the lists can contain all Unicode code points and the binaries are to be in UTF-8. If the encoding tag is &lt;code&gt;latin1&lt;/code&gt;, the client is only to get characters in the range &lt;code&gt;0..255&lt;/code&gt;. Function &lt;code&gt;check/2&lt;/code&gt; takes care of not returning arbitrary Unicode code points in lists if the encoding was specified as &lt;code&gt;latin1&lt;/code&gt;. If the function does not return a list, the check cannot be performed and the result is that of the supplied function untouched.</source>
          <target state="translated">ただし、オプションセットに応じて、返されるデータのタイプが正しいことは重要です。したがって、戻る前に&lt;strong&gt;、可能な場合&lt;/strong&gt;はリストを正しいエンコーディングのバイナリに変換します。 &lt;code&gt;get_until&lt;/code&gt; リクエストタプルで提供される関数は、最終結果として何でも返すことができるため、リストを返す関数のみがバイナリに変換できます。リクエストにエンコーディングタグ &lt;code&gt;unicode&lt;/code&gt; が含まれている場合、リストにはすべてのUnicodeコードポイントを含めることができ、バイナリはUTF-8である必要があります。エンコーディングタグが &lt;code&gt;latin1&lt;/code&gt; の場合、クライアントは &lt;code&gt;0..255&lt;/code&gt; の範囲の文字のみを取得します。機能 &lt;code&gt;check/2&lt;/code&gt; エンコーディングが &lt;code&gt;latin1&lt;/code&gt; として指定されている場合、リストで任意のUnicodeコードポイントを返さないようにします。関数がリストを返さない場合、チェックは実行できず、結果は提供された関数の影響を受けません。</target>
        </trans-unit>
        <trans-unit id="9f482f1f05e993d08f85fc64a1e60725affe0355" translate="yes" xml:space="preserve">
          <source>It is important to classify the dirty job correct. An I/O bound job should be classified as such, and a CPU bound job should be classified as such. If you should classify CPU bound jobs as I/O bound jobs, dirty I/O schedulers might starve ordinary schedulers. I/O bound jobs are expected to either block waiting for I/O, and/or spend a limited amount of time moving data.</source>
          <target state="translated">ダーティジョブを正しく分類することが重要です。I/OバウンドジョブはI/Oバウンドジョブに、CPUバウンドジョブはCPUバウンドジョブに分類します。CPUバインドジョブをI/Oバインドジョブに分類してしまうと、ダーティなI/Oスケジューラは一般のスケジューラを飢えさせてしまう可能性があります。I/Oバインドジョブは、I/O待ちをブロックするか、限られた時間でデータを移動することが期待されます。</target>
        </trans-unit>
        <trans-unit id="d9976dd4908ba58e6dd50ae2770854ad93d01862" translate="yes" xml:space="preserve">
          <source>It is important to understand that what is referred to as &quot;recursion&quot; when limiting matches is not recursion on the C stack of the Erlang machine or on the Erlang process stack. The PCRE version compiled into the Erlang VM uses machine &quot;heap&quot; memory to store values that must be kept over recursion in regular expression matches.</source>
          <target state="translated">マッチを制限するときに「再帰」と呼ばれるものは、ErlangマシンのCスタックやErlangプロセススタック上での再帰ではないことを理解することが重要です。Erlang VMにコンパイルされたPCREバージョンはマシンの &quot;ヒープ &quot;メモリを使って、正規表現マッチの再帰で保持しなければならない値を保存しています。</target>
        </trans-unit>
        <trans-unit id="5fc84b5054a683e27bd285de83b2269e24832caa" translate="yes" xml:space="preserve">
          <source>It is legal to use a &lt;code&gt;receive..after&lt;/code&gt; expression with no branches:</source>
          <target state="translated">ブランチなしで &lt;code&gt;receive..after&lt;/code&gt; 式を使用することは正当です。</target>
        </trans-unit>
        <trans-unit id="44e50f37a24e3efe1e7a14657ed0c069786f809c" translate="yes" xml:space="preserve">
          <source>It is more efficient to do a generalized search in a normalized database. Some operations are also easier to perform on a normalized data model. For example, one project can easily be removed, as the following example illustrates:</source>
          <target state="translated">正規化されたデータベースで一般化検索を行う方が効率的です。いくつかの操作は、正規化されたデータモデルで実行する方が簡単です。例えば、次の例のように、1つのプロジェクトを簡単に削除することができます。</target>
        </trans-unit>
        <trans-unit id="7a62a914f23c7f077c19bf0735e258c81935d769" translate="yes" xml:space="preserve">
          <source>It is more efficient to set a local lock than it is to set a networked lock. Sticky locks can therefore benefit an application that uses a replicated table and perform most of the work on only one of the nodes.</source>
          <target state="translated">ネットワークロックを設定するよりも、ローカルロックを設定する方が効率的です。スティッキーロックは、レプリケートされたテーブルを使用しているアプリケーションで、ほとんどの作業をノードの1つだけで行う場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="266a8a540d53489e054ee8e53285fcaa3022a860" translate="yes" xml:space="preserve">
          <source>It is much more efficient.</source>
          <target state="translated">その方がはるかに効率的です。</target>
        </trans-unit>
        <trans-unit id="f70ad1b7b9db40203db93fc2a60726affaeebaca" translate="yes" xml:space="preserve">
          <source>It is nice to be able to do formatted output in examples, so the next example shows a simple way to use the &lt;code&gt;io:format&lt;/code&gt; function. Like all other exported functions, you can test the &lt;code&gt;io:format&lt;/code&gt; function in the shell:</source>
          <target state="translated">例でフォーマットされた出力を実行できるのは良いことなので、次の例は &lt;code&gt;io:format&lt;/code&gt; 関数を使用する簡単な方法を示しています。他のすべてのエクスポートされた関数と同様に、シェルで &lt;code&gt;io:format&lt;/code&gt; 関数をテストできます。</target>
        </trans-unit>
        <trans-unit id="44d490184e49da4da8de81362df926c0ada310f4" translate="yes" xml:space="preserve">
          <source>It is not a good idea to use a global variable as the port driver can be spawned by multiple Erlang processes. This driver-structure is to be instantiated multiple times:</source>
          <target state="translated">ポートドライバは複数のErlangプロセスによってスポーンされる可能性があるので、グローバル変数を使うのは良い考えではありません。このドライバ構造体は複数回インスタンス化されることになります。</target>
        </trans-unit>
        <trans-unit id="6daf413f50e26bb393a9adb93de8ca6d96ea4c43" translate="yes" xml:space="preserve">
          <source>It is not allowed to call any functions in the &lt;code&gt;&lt;a href=&quot;erl_driver&quot;&gt;driver API&lt;/a&gt;&lt;/code&gt; from &lt;code&gt;stop_select&lt;/code&gt;. This strict limitation is because the volatile context that &lt;code&gt;stop_select&lt;/code&gt; can be called.</source>
          <target state="translated">&lt;code&gt;stop_select&lt;/code&gt; から &lt;code&gt;&lt;a href=&quot;erl_driver&quot;&gt;driver API&lt;/a&gt;&lt;/code&gt; 関数を呼び出すことはできません。この厳格な制限は、 &lt;code&gt;stop_select&lt;/code&gt; が呼び出される揮発性のコンテキストのためです。</target>
        </trans-unit>
        <trans-unit id="019cb18d2dc1083bf927207eb128dc99a14ce1cb" translate="yes" xml:space="preserve">
          <source>It is not allowed to change trace details (with &lt;code&gt;ttb:p&lt;/code&gt; and &lt;code&gt;ttb:tp/tpl...&lt;/code&gt;) once overload protection is activated in one of the traced nodes. This is to avoid trace setup being inconsistent between nodes.</source>
          <target state="translated">トレースされたノードの1つで過負荷保護がアクティブになると、トレースの詳細を（ &lt;code&gt;ttb:p&lt;/code&gt; および &lt;code&gt;ttb:tp/tpl...&lt;/code&gt; ）変更することはできません。これは、ノード間でのトレース設定の不整合を回避するためです。</target>
        </trans-unit>
        <trans-unit id="7e8776419aaae9b828a3d1b448f27e629b87f9db" translate="yes" xml:space="preserve">
          <source>It is not allowed to load multiple drivers with the same name but with different &lt;code&gt;Path&lt;/code&gt; parameters.</source>
          <target state="translated">同じ名前で &lt;code&gt;Path&lt;/code&gt; パラメータが異なる複数のドライバをロードすることはできません。</target>
        </trans-unit>
        <trans-unit id="267a6935a47a3d4aa60125e0028f69bd27f1ad69" translate="yes" xml:space="preserve">
          <source>It is not allowed to refer to types that are not declared as exported.</source>
          <target state="translated">エクスポートとして宣言されていない型を参照することはできません。</target>
        </trans-unit>
        <trans-unit id="52ca1d72ceed7a04c50a67b9f4c3b637fc684ff0" translate="yes" xml:space="preserve">
          <source>It is not allowed to use the atoms &lt;code&gt;asn1_VALUE&lt;/code&gt; and &lt;code&gt;asn1_DEFAULT&lt;/code&gt; with maps.</source>
          <target state="translated">マップでアトム &lt;code&gt;asn1_VALUE&lt;/code&gt; および &lt;code&gt;asn1_DEFAULT&lt;/code&gt; を使用することはできません。</target>
        </trans-unit>
        <trans-unit id="be6106b5316f8ae8651f28932170f500e7f32a70" translate="yes" xml:space="preserve">
          <source>It is not always helpful that plain parentheses fulfill two functions. Often a grouping subpattern is required without a capturing requirement. If an opening parenthesis is followed by a question mark and a colon, the subpattern does not do any capturing, and is not counted when computing the number of any subsequent capturing subpatterns. For example, if the string &quot;the white queen&quot; is matched against the following pattern, the captured substrings are &quot;white queen&quot; and &quot;queen&quot;, and are numbered 1 and 2:</source>
          <target state="translated">プレーンな括弧が2つの機能を果たすことは、必ずしも有用ではありません。しばしば、グループ化サブパターンは、キャプチャの要件がなくても要求されます。開き括弧の後にクエスチョンマークとコロンが続く場合、そのサブパターンは捕捉を行わず、その後の捕捉サブパターンの数を計算する際にはカウントされません。例えば、文字列 &quot;the white queen &quot;が以下のパターンにマッチした場合、捕捉される部分文字列は &quot;white queen &quot;と &quot;queen &quot;であり、1と2の番号が付けられる。</target>
        </trans-unit>
        <trans-unit id="172ef3e2b0d7516e4d00a976dfcc654e15ef5e2e" translate="yes" xml:space="preserve">
          <source>It is not an error to add a transport to a service that has not yet been configured: a service can be started after configuring its transports.</source>
          <target state="translated">まだ構成されていないサービスにトランスポートを追加するのはエラーではありません。</target>
        </trans-unit>
        <trans-unit id="714ec40d84015427dbe106f387df1a398ce13922" translate="yes" xml:space="preserve">
          <source>It is not an error to subscribe to events from a service that does not yet exist. Doing so before adding transports is required to guarantee the reception of all transport-related events.</source>
          <target state="translated">まだ存在しないサービスからイベントをサブスクライブすることはエラーではない。トランスポートを追加する前にそうすることは、すべてのトランスポート関連のイベントの受信を保証するために必要です。</target>
        </trans-unit>
        <trans-unit id="6506688cea3e9daf57ae35e48e1e48f518b6ed35" translate="yes" xml:space="preserve">
          <source>It is not checked that the forms conform to the abstract format indicated by &lt;code&gt;AbstVersion&lt;/code&gt;. &lt;code&gt;no_abstract_code&lt;/code&gt; means that chunk &lt;code&gt;&quot;Abst&quot;&lt;/code&gt; is present, but empty.</source>
          <target state="translated">フォームが &lt;code&gt;AbstVersion&lt;/code&gt; で示される抽象形式に準拠しているかどうかはチェックされません。 &lt;code&gt;no_abstract_code&lt;/code&gt; は、チャンク &lt;code&gt;&quot;Abst&quot;&lt;/code&gt; が存在するが空であることを意味します。</target>
        </trans-unit>
        <trans-unit id="adff89968dc05df945ea7914de5055f731976098" translate="yes" xml:space="preserve">
          <source>It is not designed to be called directly by an application but used through the i/o system where it can typically be called in an application by:</source>
          <target state="translated">これはアプリケーションから直接呼び出されるように設計されているのではなく、一般的にはアプリケーションから呼び出されることができるi/oシステムを介して使用されます。</target>
        </trans-unit>
        <trans-unit id="48dac80b8a2417f47d829c8b695667c7b727c326" translate="yes" xml:space="preserve">
          <source>It is not guaranteed that all log files of a distributed disk log contain the same log items. No attempt is made to synchronize the contents of the files. However, as long as at least one of the involved nodes is alive at each time, all items are logged. When logging items to a distributed log, or otherwise trying to change the log, the replies from individual logs are ignored. If all nodes are down, the disk log functions reply with a &lt;code&gt;nonode&lt;/code&gt; error.</source>
          <target state="translated">分散ディスクログのすべてのログファイルに同じログアイテムが含まれているとは限りません。ファイルの内容を同期する試みは行われません。ただし、関係するノードの少なくとも1つが常にアクティブである限り、すべてのアイテムがログに記録されます。アイテムを分散ログに記録するとき、またはログを変更しようとするとき、個々のログからの応答は無視されます。すべてのノードが停止している場合、ディスクログ機能は &lt;code&gt;nonode&lt;/code&gt; エラーで応答します。</target>
        </trans-unit>
        <trans-unit id="6c08a59c0ce53162ab6636309433afb0420a7157" translate="yes" xml:space="preserve">
          <source>It is not guaranteed that calls to &lt;code&gt;first/1&lt;/code&gt;, &lt;code&gt;next/2&lt;/code&gt;, or select and match functions work as expected even if the table is fixed; the limited support for concurrency provided by the &lt;code&gt;&lt;a href=&quot;ets&quot;&gt;ets(3)&lt;/a&gt;&lt;/code&gt; module is not yet provided by Dets. Fixing a table currently only disables resizing of the hash list of the table.</source>
          <target state="translated">テーブルが修正されていても、 &lt;code&gt;first/1&lt;/code&gt; 、 &lt;code&gt;next/2&lt;/code&gt; 、またはselectおよびmatch関数の呼び出しが期待どおりに機能することは保証されていません。 &lt;code&gt;&lt;a href=&quot;ets&quot;&gt;ets(3)&lt;/a&gt;&lt;/code&gt; モジュールによって提供される並行性の限定的なサポートは、Detsによってまだ提供されていません。現在、テーブルを修正すると、テーブルのハッシュリストのサイズ変更のみが無効になります。</target>
        </trans-unit>
        <trans-unit id="d1b5a702c4f1e3b1b3222bf3f6b4f026b94f149e" translate="yes" xml:space="preserve">
          <source>It is not hard to guess that this program doubles the value of numbers. The first two lines of the code are described later. Let us compile the program. This can be done in an Erlang shell as follows, where &lt;code&gt;c&lt;/code&gt; means compile:</source>
          <target state="translated">このプログラムが数値の値を2倍にすることは容易に想像できます。コードの最初の2行については後で説明します。プログラムをコンパイルしましょう。これは次のようにErlangシェルで実行できます &lt;code&gt;c&lt;/code&gt; はコンパイルを意味します。</target>
        </trans-unit>
        <trans-unit id="6599e0f052b83133353329a627f4fcc452a99c7e" translate="yes" xml:space="preserve">
          <source>It is not mandatory to implement a &lt;code&gt;Module:format_status/2&lt;/code&gt; function. If you do not, a default implementation is used that does the same as this example function without filtering the &lt;code&gt;Data&lt;/code&gt; term, that is, &lt;code&gt;StateData = {State,Data}&lt;/code&gt;, in this example containing sensitive information.</source>
          <target state="translated">&lt;code&gt;Module:format_status/2&lt;/code&gt; 関数の実装は必須ではありません。そうしない場合は、 &lt;code&gt;Data&lt;/code&gt; 用語をフィルタリングせずにこの例の関数と同じデフォルトの実装が使用されます。つまり、この例では、機密情報を含む &lt;code&gt;StateData = {State,Data}&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="b0b1f733cc068108abc1dfb8d6bfeb68f2238a31" translate="yes" xml:space="preserve">
          <source>It is not necessary to export the function. It is called in a freshly spawned process (which terminates as soon as the function returns).</source>
          <target state="translated">関数をエクスポートする必要はありません。この関数は、生成されたばかりのプロセスで呼び出されます(関数が戻ってくるとすぐに終了します)。</target>
        </trans-unit>
        <trans-unit id="93f0d950414352a5d4ade5d65e2ed5c99e6d63a5" translate="yes" xml:space="preserve">
          <source>It is not necessary to set header fields explicitly in outgoing messages as diameter itself will set appropriate values. Setting inappropriate values can be useful for test purposes.</source>
          <target state="translated">diameter自身が適切な値を設定するので、送信メッセージで明示的にヘッダーフィールドを設定する必要はありません。不適切な値を設定することは、テスト目的には有用です。</target>
        </trans-unit>
        <trans-unit id="a88f320b00286fede41d92ef08aebc45a1de0c25" translate="yes" xml:space="preserve">
          <source>It is not needed to link the start script to a standard directory like &lt;code&gt;/usr/local/bin&lt;/code&gt;.</source>
          <target state="translated">起動スクリプトを &lt;code&gt;/usr/local/bin&lt;/code&gt; のような標準ディレクトリにリンクする必要はありません。</target>
        </trans-unit>
        <trans-unit id="67e4d152ebcc05f491b81e0ec203229252d7a205" translate="yes" xml:space="preserve">
          <source>It is not possible to have a numerical &quot;forward back reference&quot; to a subpattern whose number is 10 or more using this syntax, as a sequence such as \50 is interpreted as a character defined in octal. For more details of the handling of digits following a backslash, see section &lt;code&gt;&lt;a href=&quot;#non_printing_characters&quot;&gt;Non-Printing Characters&lt;/a&gt;&lt;/code&gt; earlier. There is no such problem when named parentheses are used. A back reference to any subpattern is possible using named parentheses (see below).</source>
          <target state="translated">\ 50などのシーケンスは8進数で定義された文字として解釈されるため、この構文を使用して、番号が10以上のサブパターンに数値の「前方参照」を持つことはできません。バックスラッシュに続く数字の処理の詳細については、前述の「 &lt;code&gt;&lt;a href=&quot;#non_printing_characters&quot;&gt;Non-Printing Characters&lt;/a&gt;&lt;/code&gt; 」を参照してください。名前付き括弧を使用しても、このような問題はありません。名前付き括弧を使用して、任意のサブパターンへの後方参照が可能です（以下を参照）。</target>
        </trans-unit>
        <trans-unit id="c8c3861d369958e8f50d803ddee527f70da5bdd2" translate="yes" xml:space="preserve">
          <source>It is not possible to have hook functions for unknown forms at other places than expressions.</source>
          <target state="translated">式以外の場所に未知の形のためのフック関数を持つことはできません。</target>
        </trans-unit>
        <trans-unit id="bf5dc4b3da52b6319903eca1d8e499b4252bc392" translate="yes" xml:space="preserve">
          <source>It is not possible to prove that a program is correct by testing. On the contrary, it has been formally proven that it is impossible to prove programs in general by testing. Theoretical program proofs or plain examination of code can be viable options for those wishing to certify that a program is correct. The test server, as it is based on testing, cannot be used for certification. Its intended use is instead to (cost effectively) &lt;strong&gt;find bugs&lt;/strong&gt;. A successful test suite is one that reveals a bug. If a test suite results in OK, then we know very little that we did not know before.</source>
          <target state="translated">テストによってプログラムが正しいことを証明することはできません。それどころか、一般にプログラムをテストによって証明することは不可能であることが正式に証明されています。理論的なプログラムの証明またはコードの単純な検査は、プログラムが正しいことを証明したい人にとって実行可能なオプションになる可能性があります。テストサーバーはテストに基づいているため、認証には使用できません。その使用目的は、代わりに（費用効果の高い）&lt;strong&gt;バグを見つけること&lt;/strong&gt;です。成功したテストスイートは、バグを明らかにするものです。テストスイートの結果がOKの場合、以前は知らなかったことがほとんどわかりません。</target>
        </trans-unit>
        <trans-unit id="f090c83c0abe9549e98a789664a0923d4db3b914" translate="yes" xml:space="preserve">
          <source>It is not uncommon that a state diagram does not specify how to handle events that are not illustrated in a particular state in the diagram. Hopefully this is described in an associated text or from the context.</source>
          <target state="translated">状態図では、特定の状態で図示されていないイベントをどのように処理するかが指定されていないことは珍しくありません。うまくいけば、これは関連するテキストに記載されているか、あるいはコンテキストから説明されていることを願っています。</target>
        </trans-unit>
        <trans-unit id="1b4b52b46f007701d86e5cbc9fd97f24e3345085" translate="yes" xml:space="preserve">
          <source>It is not valid to specify start times that are later than the current time. If &lt;code&gt;StartTime&lt;/code&gt; is specified earlier than the log can support, the replay begins with the earliest available notification.</source>
          <target state="translated">現在の時刻より後の開始時刻を指定することはできません。 &lt;code&gt;StartTime&lt;/code&gt; がログでサポートできるよりも前に指定されている場合、再生は使用可能な最も早い通知から始まります。</target>
        </trans-unit>
        <trans-unit id="5d718859968289028b6154d936e134179997eaef" translate="yes" xml:space="preserve">
          <source>It is now easy to check the release for calls to undefined functions:</source>
          <target state="translated">未定義の関数を呼び出しているかどうかのリリースを簡単に確認できるようになりました。</target>
        </trans-unit>
        <trans-unit id="faf994c17800a7abaab6ecd7abe5ad72813bee4c" translate="yes" xml:space="preserve">
          <source>It is of course pointless to set this value to &lt;strong&gt;true&lt;/strong&gt; unless the &lt;code&gt;long_request_timer&lt;/code&gt; (see above) is also set to an incremental timer (&lt;code&gt;#megaco_incr_timer{}&lt;/code&gt;).</source>
          <target state="translated">もちろん、 &lt;code&gt;long_request_timer&lt;/code&gt; （上記を参照）が増分タイマー（ &lt;code&gt;#megaco_incr_timer{}&lt;/code&gt; ）にも設定されていない限り、この値を&lt;strong&gt;trueに&lt;/strong&gt;設定しても意味がありません。</target>
        </trans-unit>
        <trans-unit id="79ffc30d77639dd371cff25e8830713b8384b424" translate="yes" xml:space="preserve">
          <source>It is of course possible to change more than one list:</source>
          <target state="translated">もちろん複数のリストを変更することも可能です。</target>
        </trans-unit>
        <trans-unit id="8bfa4ac8d028ee74a965d7390ff456df5b066f34" translate="yes" xml:space="preserve">
          <source>It is of course questionable why anyone would like to use the both these options together, but it is possible if an unforeseen need should arise.</source>
          <target state="translated">もちろん、なぜ誰もがこれらの両方のオプションを一緒に使用したいと思うのかは疑問ですが、それは不測の必要性が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="bf27b2f7999b2a0f376e32c255c57172849d6995" translate="yes" xml:space="preserve">
          <source>It is of vital importance that this operation does not block the caller for a long time. This since it is called from the connection supervisor.</source>
          <target state="translated">この操作で長時間呼び出しをブロックしないことが非常に重要です。これは、接続スーパーバイザから呼び出されるためです。</target>
        </trans-unit>
        <trans-unit id="e5e8d870189d92edc558c16a26f0bf8ab0c4cb2b" translate="yes" xml:space="preserve">
          <source>It is often clarifying to mark the variables of a query in such a circle. This is illustrated in the picture below for some of the predefined analyses. Note that local functions used by local functions only are not marked in the &lt;code&gt;locals_not_used&lt;/code&gt; circle.</source>
          <target state="translated">このような円の中でクエリの変数をマークすることは、多くの場合明確になります。これは、事前定義された分析のいくつかについて、以下の図に示されています。ローカル関数のみが使用するローカル関数は、 &lt;code&gt;locals_not_used&lt;/code&gt; サークルでマークされていないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="7f00cf0fbfe0fde80503545d404b005925d1059f" translate="yes" xml:space="preserve">
          <source>It is often necessary to take some specific action when a table is modified. This is accomplished with an instrumentation function. It executes some specific code when the table is set, and passes all other requests down to the pre-defined function.</source>
          <target state="translated">テーブルが変更されたときに、何か特定のアクションを取る必要があることがよくあります。これはインストルメンテーション関数で実現されます。これはテーブルが設定されたときに特定のコードを実行し、他のすべてのリクエストを事前に定義された関数に渡します。</target>
        </trans-unit>
        <trans-unit id="669d240c984f988928dcb3d02f7640e88b19a775" translate="yes" xml:space="preserve">
          <source>It is often not desirable to use an Erlang/OTP system as is. A developer can create new Erlang/OTP-compliant applications for a particular purpose, and several original Erlang/OTP applications can be irrelevant for the purpose in question. Thus, there is a need to be able to create a new system based on a given Erlang/OTP system, where dispensable applications are removed and new applications are included. Documentation and source code is irrelevant and is therefore not included in the new system.</source>
          <target state="translated">Erlang/OTPシステムをそのまま使うのは好ましくないことがよくあります。開発者は特定の目的のために新しいErlang/OTP準拠のアプリケーションを作ることができますし、いくつかのオリジナルのErlang/OTPアプリケーションは問題の目的とは無関係であることがあります。このように、与えられたErlang/OTPシステムをベースにして新しいシステムを作ることができる必要があり、そこでは使い捨てのアプリケーションは削除され、新しいアプリケーションが含まれます。ドキュメントとソースコードは無関係なので新しいシステムには含まれません。</target>
        </trans-unit>
        <trans-unit id="9d21d755bf6ee35af46a7e0f26952debc88310ea" translate="yes" xml:space="preserve">
          <source>It is often very convenient to have a header in the escript, especially on Unix platforms. However, the header is optional, so you directly can &quot;execute&quot; an Erlang module, Beam file, or archive file without adding any header to them. But then you have to invoke the script as follows:</source>
          <target state="translated">特にUnixプラットフォームでは、escriptにヘッダがあるととても便利です。しかし、ヘッダはオプションなので、Erlangモジュール、Beamファイル、アーカイブファイルにヘッダを追加せずに直接 &quot;実行 &quot;することができます。しかし、以下のようにスクリプトを呼び出さなければなりません。</target>
        </trans-unit>
        <trans-unit id="4b82a26416eee8b8a22c361320edebe40a30f41c" translate="yes" xml:space="preserve">
          <source>It is only possible to use &lt;code&gt;usmHMACSHAAuthProtocol&lt;/code&gt; and &lt;code&gt;usmAesCfb128Protocol&lt;/code&gt; for authentication and privacy respectively in FIPS mode. The snmp application however won't restrict selecting disabled protocols in any way, and using them would result in run time crashes.</source>
          <target state="translated">FIPSモードでの認証とプライバシーには、それぞれ &lt;code&gt;usmHMACSHAAuthProtocol&lt;/code&gt; と &lt;code&gt;usmAesCfb128Protocol&lt;/code&gt; のみを使用できます。ただし、snmpアプリケーションは無効化されたプロトコルの選択を制限することはなく、それらを使用するとランタイムクラッシュが発生します。</target>
        </trans-unit>
        <trans-unit id="fd21c404d1e97d6cd83c5aba66d139ae4da23bac" translate="yes" xml:space="preserve">
          <source>It is ordered by the state transition action &lt;code&gt;{timeout,Time,EventContent}&lt;/code&gt;, or just an integer &lt;code&gt;Time&lt;/code&gt;, even without the enclosing actions list (the latter is a form inherited from &lt;code&gt;gen_fsm&lt;/code&gt;.</source>
          <target state="translated">それは、状態遷移アクション &lt;code&gt;{timeout,Time,EventContent}&lt;/code&gt; 、または整数の &lt;code&gt;Time&lt;/code&gt; によって順序付けられます。これは、囲んでいるアクションリストがなくても（後者は &lt;code&gt;gen_fsm&lt;/code&gt; から継承されたフォームです）。</target>
        </trans-unit>
        <trans-unit id="a4f5f5edc97bf67285e58ab928b4aa2d01b87a09" translate="yes" xml:space="preserve">
          <source>It is possible by this option to provide a state with process information from an earlier validation.</source>
          <target state="translated">このオプションにより、以前の検証で得られたプロセス情報をステートに提供することが可能です。</target>
        </trans-unit>
        <trans-unit id="3fc2da2a53482855bb7753488df5c4c401558486" translate="yes" xml:space="preserve">
          <source>It is possible for Emacs to use colors when displaying a buffer. By &quot;syntax highlighting&quot;, we mean that syntactic components, for example keywords and function names, will be colored.</source>
          <target state="translated">Emacsでは、バッファを表示する際に色を使用することができます。構文強調表示」とは、キーワードや関数名などの構文要素が色付けされることを意味します。</target>
        </trans-unit>
        <trans-unit id="983ca3396eb1c79021585a9487782ad0ed7b06d7" translate="yes" xml:space="preserve">
          <source>It is possible that a handler, even if it can successfully manage peaks of high load without crashing, can build up a large message queue, or use a large amount of memory. The overload protection mechanism includes an automatic termination and restart feature for the purpose of guaranteeing that a handler does not grow out of bounds. The feature is configured with the following parameters:</source>
          <target state="translated">ハンドラがクラッシュすることなく高負荷のピークをうまく管理できたとしても、大きなメッセージキューを構築したり、大量のメモリを使用したりする可能性があります。過負荷保護機構には、ハンドラが限界を超えないことを保証するための自動終了・再起動機能が含まれています。この機能は以下のパラメータで設定されます。</target>
        </trans-unit>
        <trans-unit id="89c49ffbfde542066361889dbf3e0036988b041f" translate="yes" xml:space="preserve">
          <source>It is possible to add &lt;strong&gt;notification filters&lt;/strong&gt; to an agent. These filters will be called when a notification is to be sent. Their purpose is to allow modification, suppression or other type of actions.</source>
          <target state="translated">&lt;strong&gt;通知フィルター&lt;/strong&gt;をエージェントに追加することができます。これらのフィルターは、通知が送信されるときに呼び出されます。それらの目的は、変更、抑制、またはその他のタイプのアクションを許可することです。</target>
        </trans-unit>
        <trans-unit id="611a47c1b5a7ffc5aabe01662e2b7fd7dc2dfd2f" translate="yes" xml:space="preserve">
          <source>It is possible to attach to interpreted processes by giving the corresponding process identity only. By default, an attachment window is displayed. Processes at other Erlang nodes can be attached manually or automatically.</source>
          <target state="translated">対応するプロセスIDのみを与えることで、解釈されたプロセスにアタッチすることができます。デフォルトでは、アタッチウィンドウが表示されます。他のErlangノードのプロセスは手動または自動でアタッチすることができます。</target>
        </trans-unit>
        <trans-unit id="68a33746b01c4222471af2ab90b1fda17ae37276" translate="yes" xml:space="preserve">
          <source>It is possible to bundle &lt;code&gt;escript&lt;/code&gt;(s) with an Erlang runtime system to make it self-sufficient and relocatable. In such a standalone system, the &lt;code&gt;escript&lt;/code&gt;(s) should be located in the top &lt;code&gt;bin&lt;/code&gt; directory of the standalone system and given &lt;code&gt;.escript&lt;/code&gt; as file extension. Further the (built-in) &lt;code&gt;escript&lt;/code&gt; program should be copied to the same directory and given the scripts original name (without the &lt;code&gt;.escript&lt;/code&gt; extension). This will enable use of the bundled Erlang runtime system.</source>
          <target state="translated">&lt;code&gt;escript&lt;/code&gt; を Erlangランタイムシステムにバンドルして、それを自給自足で再配置可能にすることができます。そのようなスタンドアロンシステムでは、 &lt;code&gt;escript&lt;/code&gt; （単数または複数）は上部に配置されるべき &lt;code&gt;bin&lt;/code&gt; スタンドアロン・システムのディレクトリ及び所与 &lt;code&gt;.escript&lt;/code&gt; をファイル拡張子として。さらに、（組み込み） &lt;code&gt;escript&lt;/code&gt; プログラムを同じディレクトリにコピーし、スクリプトに元の名前（拡張子 &lt;code&gt;.escript&lt;/code&gt; なし）を付ける必要があります。これにより、バンドルされているErlangランタイムシステムを使用できるようになります。</target>
        </trans-unit>
        <trans-unit id="1a74ec992e2736a1ad60efb4b66cf6169016243f" translate="yes" xml:space="preserve">
          <source>It is possible to cause the matching process to obey a subpattern conditionally or to choose between two alternative subpatterns, depending on the result of an assertion, or whether a specific capturing subpattern has already been matched. The following are the two possible forms of conditional subpattern:</source>
          <target state="translated">アサーションの結果に応じて、あるいは特定の捕捉サブパターンがすでにマッチしているかどうかに応じて、条件付きでサブパターンに従うように、あるいは2つの代替サブパターンの間で選択するように、マッチングプロセスを引き起こすことが可能である。以下に、条件付きサブパターンの2つの可能な形態を示す。</target>
        </trans-unit>
        <trans-unit id="ab76d6d5170404d3b2cda7f8cfb409928e7f4eef" translate="yes" xml:space="preserve">
          <source>It is possible to configure a 3588 dictionary in order to get 3588 semantics, where the differ from 6733.</source>
          <target state="translated">6733と異なる3588のセマンティクスを得るために、3588の辞書を構成することが可能である。</target>
        </trans-unit>
        <trans-unit id="9c37c6dc0aa07be6c37e5deaa81d5f4c9f52e7cd" translate="yes" xml:space="preserve">
          <source>It is possible to debug every (non-supervisor) process of the application (both agent and manager), possibly with the exception of the net_if module(s), which could be supplied by a user of the application). This is done by calling the &lt;code&gt;snmpa:verbosity/2&lt;/code&gt; and &lt;code&gt;snmpm:verbosity/2&lt;/code&gt; function(s) and/or using &lt;code&gt;&lt;a href=&quot;#configuration_params&quot;&gt;configuration parameters&lt;/a&gt;&lt;/code&gt;. The verbosity itself has several &lt;strong&gt;levels&lt;/strong&gt;: &lt;code&gt;silence | info | log | debug | trace&lt;/code&gt;. For the lowest verbosity &lt;code&gt;silence&lt;/code&gt;, nothing is printed. The higher the verbosity, the more is printed. Default value is always &lt;code&gt;silence&lt;/code&gt;.</source>
          <target state="translated">アプリケーション（エージェントとマネージャーの両方）のすべての（非スーパーバイザー）プ​​ロセスをデバッグできます。ただし、アプリケーションのユーザーが提供できるnet_ifモジュールは例外です。これは、 &lt;code&gt;snmpa:verbosity/2&lt;/code&gt; および &lt;code&gt;snmpm:verbosity/2&lt;/code&gt; 関数を呼び出すか、 &lt;code&gt;&lt;a href=&quot;#configuration_params&quot;&gt;configuration parameters&lt;/a&gt;&lt;/code&gt; を使用することによって行われます。冗長性自体はいくつか持っている&lt;strong&gt;レベル&lt;/strong&gt;： &lt;code&gt;silence | info | log | debug | trace&lt;/code&gt; 。冗長性が最も低い &lt;code&gt;silence&lt;/code&gt; 場合、何も出力されません。冗長性が高いほど、より多く印刷されます。デフォルト値は常に &lt;code&gt;silence&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="5d39bbc803211df1332cc5dc8dcf83a0f92e55b1" translate="yes" xml:space="preserve">
          <source>It is possible to generate an &lt;code&gt;.hrl&lt;/code&gt; file which contains definitions of Erlang constants from a compiled MIB file. This file can then be included in Erlang source code. The file will contain constants for:</source>
          <target state="translated">コンパイルされたMIBファイルからErlang定数の定義を含む &lt;code&gt;.hrl&lt;/code&gt; ファイルを生成することが可能です。その後、このファイルをErlangソースコードに含めることができます。ファイルには次の定数が含まれます。</target>
        </trans-unit>
        <trans-unit id="51fafe686c4a07e4e02f5d76d9dd1d3e7268cfbe" translate="yes" xml:space="preserve">
          <source>It is possible to have a replicated table of type &lt;code&gt;disc_copies&lt;/code&gt; on one node and another type on another node. Default is &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">1つのノードにタイプ &lt;code&gt;disc_copies&lt;/code&gt; のテーブルを複製し、別のノードに別のタイプを作成することができます。デフォルトは &lt;code&gt;[]&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="176cd0b1dd2d9962820987b7f9b12d3696c77d8c" translate="yes" xml:space="preserve">
          <source>It is possible to have a replicated table of type &lt;code&gt;disc_copies&lt;/code&gt; on one node, and the same table stored as a different type on another node. Default is &lt;code&gt;[]&lt;/code&gt;. This arrangement is desirable if the following operational characteristics are required:</source>
          <target state="translated">1つのノードにタイプ &lt;code&gt;disc_copies&lt;/code&gt; の複製テーブルを作成し、同じテーブルを別のノードに別のタイプとして保存することができます。デフォルトは &lt;code&gt;[]&lt;/code&gt; です。この配置は、次の操作特性が必要な場合に適しています。</target>
        </trans-unit>
        <trans-unit id="1fe6b795938737aa56b18e0286b7c12c53710c77" translate="yes" xml:space="preserve">
          <source>It is possible to have the following ASN.1 type definitions:</source>
          <target state="translated">以下のASN.1型定義を持つことができる。</target>
        </trans-unit>
        <trans-unit id="caeed91f5fcecb317cae9ea39c892cb575858fba" translate="yes" xml:space="preserve">
          <source>It is possible to load mibs into the manager, but this is not necessary for normal operation, and not recommended.</source>
          <target state="translated">管理者にミブをロードすることは可能ですが、通常の運用では必要ないのでお勧めできません。</target>
        </trans-unit>
        <trans-unit id="8ed112d6a70cb9d06cfb65b8258e9018e32dab8e" translate="yes" xml:space="preserve">
          <source>It is possible to modify the default behaviour of a process so that it does not get killed when it receives abnormal exit signals. Instead, all signals are turned into normal messages on the format &lt;code&gt;{'EXIT',FromPID,Reason}&lt;/code&gt; and added to the end of the receiving process' message queue. This behaviour is set by:</source>
          <target state="translated">プロセスのデフォルトの動作を変更して、異常な終了シグナルを受信したときにプロセスが強制終了されないようにすることができます。代わりに、すべてのシグナルが &lt;code&gt;{'EXIT',FromPID,Reason}&lt;/code&gt; という形式の通常のメッセージに変換され、受信プロセスのメッセージキューの最後に追加されます。この動作は次のように設定されます。</target>
        </trans-unit>
        <trans-unit id="2b2147478740459290ffe9c88424b73275de9908" translate="yes" xml:space="preserve">
          <source>It is possible to overload macros, except for predefined macros. An overloaded macro has more than one definition, each with a different number of arguments.</source>
          <target state="translated">定義済みのマクロを除いて、マクロをオーバーロードすることができます。オーバーロードされたマクロは複数の定義を持ち、それぞれが異なる数の引数を持ちます。</target>
        </trans-unit>
        <trans-unit id="2f1689c7a1afca7921fba43503d5e442362a2a71" translate="yes" xml:space="preserve">
          <source>It is possible to override the default behavior and control what types of files that are to be compressed by using options &lt;code&gt;{compress, What}&lt;/code&gt; and &lt;code&gt;{uncompress, What}&lt;/code&gt;. It is also possible to use many &lt;code&gt;compress&lt;/code&gt; and &lt;code&gt;uncompress&lt;/code&gt; options.</source>
          <target state="translated">オプション &lt;code&gt;{compress, What}&lt;/code&gt; および &lt;code&gt;{uncompress, What}&lt;/code&gt; を使用して、デフォルトの動作をオーバーライドし、圧縮するファイルのタイプを制御することができます。また、多くの &lt;code&gt;compress&lt;/code&gt; および &lt;code&gt;uncompress&lt;/code&gt; オプションを使用することもできます。</target>
        </trans-unit>
        <trans-unit id="7a56a8c28e6ccfea7e044e017bea02d64d0c26d0" translate="yes" xml:space="preserve">
          <source>It is possible to perform some limited manipulations of the graph. Nodes can be moved, selected, locked or deleted. Move a single node or the entire graph by moving the mouse while the left mouse button is pressed. A node can be locked into a fix position by holding down the shift button when the left mouse button is released. Select several nodes by moving the mouse while the control key and the left mouse button are pressed. Selected nodes can be locked, unlocked or deleted by clicking on a suitable button.</source>
          <target state="translated">グラフのいくつかの限定的な操作を行うことができます。ノードの移動、選択、ロック、削除が可能です。マウスの左ボタンを押したままマウスを動かすことで、単一のノードまたはグラフ全体を移動させることができます。マウスの左ボタンを離した状態でシフトボタンを押し続けると、ノードを固定位置にロックすることができます。コントロールキーとマウスの左ボタンを押しながらマウスを動かすと、複数のノードを選択することができます。選択したノードは、適切なボタンをクリックすることで、ロック、ロック解除、削除が可能です。</target>
        </trans-unit>
        <trans-unit id="2fed4e0762f6fb12f483f3a5c7bb640cb225b33e" translate="yes" xml:space="preserve">
          <source>It is possible to prevent run-time errors and other exceptions from causing the process to terminate by using &lt;code&gt;catch&lt;/code&gt; or &lt;code&gt;try&lt;/code&gt;, see &lt;code&gt;&lt;a href=&quot;expressions&quot;&gt;Expressions&lt;/a&gt;&lt;/code&gt; about &lt;code&gt;&lt;a href=&quot;expressions#catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;expressions#try&quot;&gt;try&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">使用して終了させるプロセスを引き起こしてから実行時エラーやその他の例外を防止することが可能である &lt;code&gt;catch&lt;/code&gt; か &lt;code&gt;try&lt;/code&gt; 、参照 &lt;code&gt;&lt;a href=&quot;expressions&quot;&gt;Expressions&lt;/a&gt;&lt;/code&gt; について &lt;code&gt;&lt;a href=&quot;expressions#catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; して &lt;code&gt;&lt;a href=&quot;expressions#try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3df4ebaf240f63cbe2516bd7eacc27e64f5b97f0" translate="yes" xml:space="preserve">
          <source>It is possible to print more specific types of statistics by first manipulating the &lt;code&gt;DataOrStats&lt;/code&gt; using &lt;code&gt;&lt;a href=&quot;#stats-2&quot;&gt;stats/2&lt;/a&gt;&lt;/code&gt;. For instance if you want to print the percentage of run-time for each thread you can do:</source>
          <target state="translated">最初に &lt;code&gt;&lt;a href=&quot;#stats-2&quot;&gt;stats/2&lt;/a&gt;&lt;/code&gt; を使用して &lt;code&gt;DataOrStats&lt;/code&gt; を操作することにより、より特定のタイプの統計を出力することが可能です。たとえば、各スレッドの実行時間のパーセンテージを出力したい場合は、次のようにできます。</target>
        </trans-unit>
        <trans-unit id="edfc81400b7354fb02a37d8d3cbdc6435db75f99" translate="yes" xml:space="preserve">
          <source>It is possible to specify that the module is the callback module for a &lt;strong&gt;behaviour&lt;/strong&gt;:</source>
          <target state="translated">モジュールが&lt;strong&gt;動作の&lt;/strong&gt;コールバックモジュールであることを指定できます。</target>
        </trans-unit>
        <trans-unit id="64a48f3eede047c4b7880e6db7738b3c1b6b35fc" translate="yes" xml:space="preserve">
          <source>It is possible to use SSL/TLS distribution over IPv6 instead of IPv4. To do this, pass the option &lt;code&gt;-proto_dist inet6_tls&lt;/code&gt; instead of &lt;code&gt;-proto_dist inet_tls&lt;/code&gt; when starting Erlang, either on the command line or in the &lt;code&gt;ERL_FLAGS&lt;/code&gt; environment variable.</source>
          <target state="translated">IPv4の代わりにIPv6でSSL / TLS配布を使用することが可能です。これを行うには、オプションで渡す &lt;code&gt;-proto_dist inet6_tls&lt;/code&gt; の代わり &lt;code&gt;-proto_dist inet_tls&lt;/code&gt; をアーランの起動時にコマンドラインまたはのいずれかで、 &lt;code&gt;ERL_FLAGS&lt;/code&gt; の環境変数。</target>
        </trans-unit>
        <trans-unit id="c2f7a787a6e395f6a23bb42d34f2d7a43e1c7c1a" translate="yes" xml:space="preserve">
          <source>It is possible to write a driver in C according to certain principles and dynamically link it to the Erlang runtime system. The linked-in driver looks like a port from the Erlang programmer's point of view and is called a &lt;strong&gt;port driver&lt;/strong&gt;.</source>
          <target state="translated">特定の原則に従ってCでドライバーを作成し、Erlangランタイムシステムに動的にリンクすることができます。リンクされたドライバーは、Erlangプログラマーから見るとポートのように見え、&lt;strong&gt;ポートドライバー&lt;/strong&gt;と呼ばれ&lt;strong&gt;ます&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="3235ff3a1f208b096772a81fe4cb496997e0cde6" translate="yes" xml:space="preserve">
          <source>It is possible, but definitely not recommended, to start Debugger in global mode on more than one node in a network, as the nodes interfere with each other, leading to inconsistent behavior.</source>
          <target state="translated">ネットワーク内の複数のノードでグローバルモードでデバッガを起動することは可能ですが、絶対にお勧めできません。</target>
        </trans-unit>
        <trans-unit id="4bd608e2122cf39b6241e7c0694b05508a158bb5" translate="yes" xml:space="preserve">
          <source>It is primarily intended to be used in &lt;code&gt;ets:match/2&lt;/code&gt; and &lt;code&gt;mnesia:match_object/3&lt;/code&gt;, to set record fields to the atom &lt;code&gt;'_'&lt;/code&gt;. (This is a wildcard in &lt;code&gt;ets:match/2&lt;/code&gt;.)</source>
          <target state="translated">これは主に &lt;code&gt;ets:match/2&lt;/code&gt; および &lt;code&gt;mnesia:match_object/3&lt;/code&gt; で使用され、レコードフィールドをアトム &lt;code&gt;'_'&lt;/code&gt; に設定することを目的としています。（これは &lt;code&gt;ets:match/2&lt;/code&gt; のワイルドカードです。）</target>
        </trans-unit>
        <trans-unit id="46e7fe56fdedc189f7070c8d58b82badd56c82e5" translate="yes" xml:space="preserve">
          <source>It is probably a good idea to do both wall-clock measurements and CPU time measurements.</source>
          <target state="translated">ウォールクロック測定とCPU時間測定の両方を行うのが良いかもしれません。</target>
        </trans-unit>
        <trans-unit id="5a14f6ab8271ce6a90e3ad46573c990914b8aa87" translate="yes" xml:space="preserve">
          <source>It is rather costly to hibernate a process; see &lt;code&gt;erlang:hibernate/3&lt;/code&gt;. It is not something you want to do after every event.</source>
          <target state="translated">プロセスを休止状態にすると、かなりコストがかかります。 &lt;code&gt;erlang:hibernate/3&lt;/code&gt; を参照してください。それはあなたがすべてのイベントの後にしたいことではありません。</target>
        </trans-unit>
        <trans-unit id="3e4b9ac2fc75211bbe9ad50f5e40bfade9c76213" translate="yes" xml:space="preserve">
          <source>It is recommended by the SSH Connection Protocol to send this message, but that is not always the case.</source>
          <target state="translated">このメッセージを送信することはSSH接続プロトコルで推奨されていますが、必ずしもそうとは限りません。</target>
        </trans-unit>
        <trans-unit id="3538339fde2ffca2f48c0ebf690413d3c9455c7f" translate="yes" xml:space="preserve">
          <source>It is recommended not to specify &lt;code&gt;LogFileOpts&lt;/code&gt; unless absolutely necessary. The default options used by the handler to open a file for logging are &lt;code&gt;raw&lt;/code&gt;, &lt;code&gt;append&lt;/code&gt;, and &lt;code&gt;delayed_write&lt;/code&gt;. Notice that the standard handler does not have support for circular logging. Use the disk_log handler, &lt;code&gt;&lt;a href=&quot;logger_disk_log_h&quot;&gt;logger_disk_log_h&lt;/a&gt;&lt;/code&gt;, for this.</source>
          <target state="translated">どうしても必要な場合 &lt;code&gt;LogFileOpts&lt;/code&gt; を指定しないことをお勧めします。ロギング用のファイルを開くためにハンドラーが使用するデフォルトのオプションは、 &lt;code&gt;raw&lt;/code&gt; 、 &lt;code&gt;append&lt;/code&gt; 、 &lt;code&gt;delayed_write&lt;/code&gt; です。標準ハンドラは循環ログをサポートしていないことに注意してください。disk_logハンドラ、使用 &lt;code&gt;&lt;a href=&quot;logger_disk_log_h&quot;&gt;logger_disk_log_h&lt;/a&gt;&lt;/code&gt; このために、。</target>
        </trans-unit>
        <trans-unit id="84dcefe80a30322b20b7d6bec52f8ca9cf6c5179" translate="yes" xml:space="preserve">
          <source>It is recommended that &lt;code&gt;Report&lt;/code&gt; follows the same structure as for &lt;code&gt;&lt;a href=&quot;#error_report-1&quot;&gt;error_report/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Report&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;#error_report-1&quot;&gt;error_report/1&lt;/a&gt;&lt;/code&gt; と同じ構造に従うことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="b386ae81313b705ebb70b487e37aefb55d196b01" translate="yes" xml:space="preserve">
          <source>It is recommended that &lt;code&gt;Report&lt;/code&gt; follows the same structure as for &lt;code&gt;&lt;a href=&quot;#info_report-1&quot;&gt;info_report/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Report&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;#info_report-1&quot;&gt;info_report/1&lt;/a&gt;&lt;/code&gt; と同じ構造に従うことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="ec7525c85fc1b0fc6b283c95390bdef2f3056b13" translate="yes" xml:space="preserve">
          <source>It is recommended that &lt;code&gt;Report&lt;/code&gt; follows the same structure as for &lt;code&gt;&lt;a href=&quot;#warning_report-1&quot;&gt;warning_report/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Report&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;#warning_report-1&quot;&gt;warning_report/1&lt;/a&gt;&lt;/code&gt; と同じ構造に従うことが推奨されます。</target>
        </trans-unit>
        <trans-unit id="783c04e3a082ab2be9d7c29f034cc09bfb7018db" translate="yes" xml:space="preserve">
          <source>It is recommended that application directories are named as the application, possibly followed by a dash and the version number. For example &lt;code&gt;myapp&lt;/code&gt; or &lt;code&gt;myapp-1.1&lt;/code&gt;.</source>
          <target state="translated">アプリケーションディレクトリには、アプリケーションとして名前を付け、その後にダッシュとバージョン番号を付けることをお勧めします。たとえば、 &lt;code&gt;myapp&lt;/code&gt; または &lt;code&gt;myapp-1.1&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="d33efddc769eac5ce590e1e5ad80c9fa01a0ec69" translate="yes" xml:space="preserve">
          <source>It is recommended that the data files are not tampered with while &lt;code&gt;Mnesia&lt;/code&gt; is running. While not prohibited, the behavior of &lt;code&gt;Mnesia&lt;/code&gt; is unpredictable.</source>
          <target state="translated">&lt;code&gt;Mnesia&lt;/code&gt; の実行中にデータファイルを改ざんしないことをお勧めします。禁止されていませんが、 &lt;code&gt;Mnesia&lt;/code&gt; の動作は予測できません。</target>
        </trans-unit>
        <trans-unit id="a92359abef578e025508dcaa89e3308762079839" translate="yes" xml:space="preserve">
          <source>It is recommended that the embedded environment is run by an ordinary user, that is, a user who does not have super user privileges.</source>
          <target state="translated">組込み環境は、一般ユーザ、つまりスーパーユーザ権限を持たないユーザが実行することを推奨します。</target>
        </trans-unit>
        <trans-unit id="762df308b5cada2cb63ce0582b14513833afec03" translate="yes" xml:space="preserve">
          <source>It is recommended to add these lines to avoid a clash. The clash can make it impossible to boot the system.</source>
          <target state="translated">衝突を避けるためにこれらの行を追加することをお勧めします。衝突するとシステムを起動できなくなる可能性があります。</target>
        </trans-unit>
        <trans-unit id="6fd8b3ea5927d76b7682f8c2f4ad291b5b58b77d" translate="yes" xml:space="preserve">
          <source>It is recommended to only use external encodings for communication with external entities where this is required. When working inside the Erlang/OTP environment, it is recommended to keep binaries in UTF-8 when representing Unicode characters. ISO Latin-1 encoding is supported both for backward compatibility and for communication with external entities not supporting Unicode character sets.</source>
          <target state="translated">外部エンティティとの通信には外部エンコーディングが必要な場合のみ外部エンコーディングを使うことをお勧めします。Erlang/OTP環境で作業する場合、バイナリをUTF-8にしておくことをお勧めします。ISO Latin-1エンコーディングは下位互換性と、Unicode文字セットをサポートしていない外部エンティティとの通信のためにサポートされています。</target>
        </trans-unit>
        <trans-unit id="a86763d26205898122a82befc3a8840b014abd3a" translate="yes" xml:space="preserve">
          <source>It is recommended to set this parameter to &lt;code&gt;false&lt;/code&gt; on systems with many concurrent processes, as each process memory check makes a traversal of the entire list of processes.</source>
          <target state="translated">各プロセスのメモリチェックはプロセスのリスト全体を走査するため、同時実行プロセスが多いシステムでは、このパラメータを &lt;code&gt;false&lt;/code&gt; に設定することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="24e3dbfb80fbfa8e8fdafd6d93a77c0b3d9621a5" translate="yes" xml:space="preserve">
          <source>It is recommended to use &lt;code&gt;ei_xreceive_msg&lt;/code&gt; instead when possible, for the sake of readability. However, the function will be retained in the interface for compatibility and will &lt;strong&gt;not&lt;/strong&gt; be removed in future releases without prior notice.</source>
          <target state="translated">読みやすさのために、可能であれば &lt;code&gt;ei_xreceive_msg&lt;/code&gt; を使用することをお勧めします。ただし、機能は互換性のためにインターフェースに保持され、将来のリリースで予告なしに削除されることはあり&lt;strong&gt;ません&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="68b150299a170408a969148f799267c01b2b3057" translate="yes" xml:space="preserve">
          <source>It is recommended to use the &lt;code&gt;.hrl&lt;/code&gt; files created by the Erlang/OTP MIB compiler to define the Object Identifiers (OIDs). For example, to get the Erlang node name from &lt;code&gt;erlNodeTable&lt;/code&gt; in the OTP-MIB:</source>
          <target state="translated">Erlang / OTP MIBコンパイラーによって作成された &lt;code&gt;.hrl&lt;/code&gt; ファイルを使用して、オブジェクトID（OID）を定義することをお勧めします。たとえば、OTP-MIBの &lt;code&gt;erlNodeTable&lt;/code&gt; からErlangノード名を取得するには：</target>
        </trans-unit>
        <trans-unit id="beb6f25876d5f5f2b17dc06907c6e940b602048d" translate="yes" xml:space="preserve">
          <source>It is recommended to use the &lt;code&gt;record_info/2&lt;/code&gt; notation, as it becomes easier to maintain the program and the program becomes more robust with regards to future record changes.</source>
          <target state="translated">プログラムの保守が容易になり、プログラムが将来のレコード変更に関してより堅牢になるため、 &lt;code&gt;record_info/2&lt;/code&gt; 表記を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="8b76629f18d77250860872328b4b08636aca42ee" translate="yes" xml:space="preserve">
          <source>It is sometimes useful or necessary to create a user-defined boot script. This is true especially when running Erlang in embedded mode, see &lt;code&gt;&lt;a href=&quot;#code_loading&quot;&gt;Code Loading Strategy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ユーザー定義のブートスクリプトを作成すると便利な場合があります。これは、Erlangを組み込みモードで実行する場合に特に当てはまります。 &lt;code&gt;&lt;a href=&quot;#code_loading&quot;&gt;Code Loading Strategy&lt;/a&gt;&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="4428a0f8ea035e8ff8c49bdbc215a36fc422f39f" translate="yes" xml:space="preserve">
          <source>It is strongly recommend to use this feature and avoid to indent lines in a nonstandard way. Some motivations are:</source>
          <target state="translated">この機能を使用して、非標準的な方法で行をインデントしないようにすることを強くお勧めします。いくつかの動機があります。</target>
        </trans-unit>
        <trans-unit id="dce8043b4ef69a730f0893b68fe47eb9a7d53719" translate="yes" xml:space="preserve">
          <source>It is the caller's responsibility to free the array afterwards. It has been allocated by the function with a single call to &lt;code&gt;malloc()&lt;/code&gt;, so a single &lt;code&gt;free()&lt;/code&gt; is all that is necessary.</source>
          <target state="translated">後で配列を解放するのは呼び出し側の責任です。 &lt;code&gt;malloc()&lt;/code&gt; への1回の呼び出しで関数によって割り当てられているため、必要なのは1回の &lt;code&gt;free()&lt;/code&gt; だけです。</target>
        </trans-unit>
        <trans-unit id="995f9fe18801008a7413cb59742eae29d2846eb4" translate="yes" xml:space="preserve">
          <source>It is the caller's responsibility to free the array. &lt;code&gt;erl_global_names&lt;/code&gt; allocates the array and all the strings using a single call to &lt;code&gt;malloc()&lt;/code&gt;, so &lt;code&gt;free(names)&lt;/code&gt; is all that is necessary.</source>
          <target state="translated">配列を解放するのは呼び出し側の責任です。 &lt;code&gt;erl_global_names&lt;/code&gt; は &lt;code&gt;malloc()&lt;/code&gt; への単一の呼び出しを使用して配列とすべての文字列を割り当てます。したがって、必要なのは &lt;code&gt;free(names)&lt;/code&gt; だけです。</target>
        </trans-unit>
        <trans-unit id="72318ea3ee2cb4c60a442793c66f568591fae3fc" translate="yes" xml:space="preserve">
          <source>It is the caller's responsibility to free the returned &lt;code&gt;ETERM&lt;/code&gt; structure and the memory pointed to by &lt;code&gt;emsg-&amp;gt;msg&lt;/code&gt; and &lt;code&gt;emsg-&amp;gt;to&lt;/code&gt;.</source>
          <target state="translated">返された &lt;code&gt;ETERM&lt;/code&gt; 構造と &lt;code&gt;emsg-&amp;gt;msg&lt;/code&gt; および &lt;code&gt;emsg-&amp;gt;to&lt;/code&gt; が指すメモリを解放するのは呼び出し側の責任です。</target>
        </trans-unit>
        <trans-unit id="e90281b55dfbea943300fc790e2a254ba4758b5f" translate="yes" xml:space="preserve">
          <source>It is the caller's responsibility to release the memory pointed to by &lt;code&gt;emsg-&amp;gt;msg&lt;/code&gt;, &lt;code&gt;emsg-&amp;gt;to&lt;/code&gt;, and &lt;code&gt;emsg-&amp;gt;from&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;emsg-&amp;gt;msg&lt;/code&gt; 、 &lt;code&gt;emsg-&amp;gt;to&lt;/code&gt; 、および &lt;code&gt;emsg-&amp;gt;from&lt;/code&gt; が指すメモリを解放するのは呼び出し側の責任です。</target>
        </trans-unit>
        <trans-unit id="ffcb8bff0a2bc31b48d23416b425fa41cd4102ea" translate="yes" xml:space="preserve">
          <source>It is then possible to assign values as follows:</source>
          <target state="translated">そして、以下のように値を割り当てることができます。</target>
        </trans-unit>
        <trans-unit id="32dd295574a144656b5cc3828c87c43e206ba562" translate="yes" xml:space="preserve">
          <source>It is therefore important that the code inside the Fun given to &lt;code&gt;&lt;a href=&quot;mnesia#transaction-2&quot;&gt;mnesia:transaction/1&lt;/a&gt;&lt;/code&gt; is pure. Some strange results can occur if, for example, messages are sent by the transaction Fun. The following example illustrates this situation:</source>
          <target state="translated">したがって、 &lt;code&gt;&lt;a href=&quot;mnesia#transaction-2&quot;&gt;mnesia:transaction/1&lt;/a&gt;&lt;/code&gt; に与えられるFun内のコードが純粋であることは重要です。たとえば、メッセージがトランザクションFunによって送信された場合、奇妙な結果が発生する可能性があります。次の例は、この状況を示しています。</target>
        </trans-unit>
        <trans-unit id="52f4a38196075ad4a5127fd5f3778f1a63bfca93" translate="yes" xml:space="preserve">
          <source>It is thus recommended that code is changed in as small steps as possible, and always kept backwards compatible.</source>
          <target state="translated">そのため、コードは可能な限り小刻みに変更し、常に下位互換性を保つことが推奨されています。</target>
        </trans-unit>
        <trans-unit id="d9ec68e380c2aeaf1e726fe77035c867ce201c19" translate="yes" xml:space="preserve">
          <source>It is to be (or result in) a call to any of the following:</source>
          <target state="translated">のいずれかを呼び出すこと(またはその結果)であること。</target>
        </trans-unit>
        <trans-unit id="2f56ccb8476fcf4652fb1a09b059f74067c2b7dc" translate="yes" xml:space="preserve">
          <source>It is usually more efficient to split a binary using matching instead of calling the &lt;code&gt;split_binary/2&lt;/code&gt; function. Furthermore, mixing bit syntax matching and &lt;code&gt;split_binary/2&lt;/code&gt; can prevent some optimizations of bit syntax matching.</source>
          <target state="translated">通常、 &lt;code&gt;split_binary/2&lt;/code&gt; 関数を呼び出す代わりに、マッチングを使用してバイナリを分割する方が効率的です。さらに、ビット構文マッチングと &lt;code&gt;split_binary/2&lt;/code&gt; を混在させると、ビット構文マッチングの一部の最適化が妨げられる可能性があります。</target>
        </trans-unit>
        <trans-unit id="d40f0e2b9bfde282c6fadde5330a44421ff3e0a0" translate="yes" xml:space="preserve">
          <source>It is very easy to build a working OpenSSL FIPS Object Module and library from the source. However it &lt;strong&gt;does not&lt;/strong&gt; qualify as FIPS 140-2 validated if the numerous restrictions in the Security Policy are not properly followed.</source>
          <target state="translated">ソースから動作するOpenSSL FIPSオブジェクトモジュールとライブラリを構築するのは非常に簡単です。ただし、セキュリティポリシーの多数の制限が適切に守られて&lt;strong&gt;いない&lt;/strong&gt;場合は、FIPS 140-2が検証したとは見なされ&lt;strong&gt;ません&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="62c48e1d02aa5042a563d9cdc46a5c1f705ab388" translate="yes" xml:space="preserve">
          <source>It is vital to understand the difference between encodings and Unicode characters. Unicode characters are code points according to the Unicode standard, while the encodings are ways to represent such code points. An encoding is only a standard for representation. UTF-8 can, for example, be used to represent a very limited part of the Unicode character set (for example ISO-Latin-1) or the full Unicode range. It is only an encoding format.</source>
          <target state="translated">エンコーディングと Unicode キ ャ ラ ク タ の違いを理解する こ と は非常に重要です。エンコーディングはそのようなコードポイントを表現する方法ですが、Unicode文字はUnicode標準に従ったコードポイントです。エンコーディングは表現のための標準でしかありません。UTF-8 は、 た と えば Unicode キ ャ ラ ク タ セ ッ ト (た と えば ISO-Latin-1)の非常に限られた部分を表現す る ために用い る こ と も で き ますし、 Unicode の全範囲を表現す る ために用い る こ と も で き ます。これはエンコーディング形式にすぎません。</target>
        </trans-unit>
        <trans-unit id="0b9d2d00c773da9822d8e2592e3080b84694726c" translate="yes" xml:space="preserve">
          <source>It localizes a set of alternatives. For example, the following pattern matches &quot;cataract&quot;, &quot;caterpillar&quot;, or &quot;cat&quot;:</source>
          <target state="translated">これは、選択肢のセットをローカライズします。例えば、以下のパターンは、「白内障」「毛虫」「猫」にマッチします。</target>
        </trans-unit>
        <trans-unit id="36ff8f13092a39bd2ba61c1ed0f713f6c5f51ed0" translate="yes" xml:space="preserve">
          <source>It makes debugging difficult (as a fault can be the result of a problem in a different test case than the one failing).</source>
          <target state="translated">これはデバッグを困難にします(失敗したテストケースとは異なるテストケースの問題の結果になる可能性があるため)。</target>
        </trans-unit>
        <trans-unit id="71e868c4d221d1f6e3b2db5cf4b3d7a681d61288" translate="yes" xml:space="preserve">
          <source>It makes it impossible to run test cases in a different order.</source>
          <target state="translated">そうすると、テストケースを別の順番で実行することができなくなってしまいます。</target>
        </trans-unit>
        <trans-unit id="607d901de681a7b70bb610e89380efa89701b1d6" translate="yes" xml:space="preserve">
          <source>It makes it impossible to run test cases individually.</source>
          <target state="translated">そのため、テストケースを個別に実行することができません。</target>
        </trans-unit>
        <trans-unit id="c4d9bde63bab462d455aa3cb421fb8522231409c" translate="yes" xml:space="preserve">
          <source>It matches &quot;ab&quot; in the subject &quot;aab&quot;. The use of the backtracking control verbs (*PRUNE) and (*SKIP) also disable this optimization.</source>
          <target state="translated">主語「aab」の「ab」と一致します。バックトラッキング制御動詞(*prune)と(*skip)の使用も、この最適化を無効にします。</target>
        </trans-unit>
        <trans-unit id="19d42ec8f2740a3cd0c2abd5afb5c44bd8a74c60" translate="yes" xml:space="preserve">
          <source>It may also throw the exception notsup in case there is no engine support in the underlying OpenSSL implementation.</source>
          <target state="translated">また、基礎となる OpenSSL の実装でエンジンがサポートされていない場合には、例外 notsup を投げることもあります。</target>
        </trans-unit>
        <trans-unit id="9ae8d33567c40fce809d17bd5e11afa0ce732fac" translate="yes" xml:space="preserve">
          <source>It may seem that there is no way to create a list without knowing the number of elements in advance. But indeed there is a way. Notice that the list &lt;code&gt;[a, b, c]&lt;/code&gt; can be written as &lt;code&gt;[a | [b | [c]]]&lt;/code&gt;. Using this, a list can be written as conses.</source>
          <target state="translated">要素の数を事前に知らなければ、リストを作成する方法はないように思えるかもしれません。しかし、確かに方法があります。リスト &lt;code&gt;[a, b, c]&lt;/code&gt; は &lt;code&gt;[a | [b | [c]]]&lt;/code&gt; 。これを使うと、リストをコンスとして書くことができます。</target>
        </trans-unit>
        <trans-unit id="5c879b18f150b020c56c6dce149540d933f7ca26" translate="yes" xml:space="preserve">
          <source>It might be necessary to introduce incompatible changes in order to solve a security issue. This kind of incompatibility might occur in a patch.</source>
          <target state="translated">セキュリティの問題を解決するために、互換性のない変更を導入する必要があるかもしれません。このような互換性のない変更は、パッチの中で発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="f6df38f1f74cd5ca73948bc650a636f7e7345d28" translate="yes" xml:space="preserve">
          <source>It might seem strange to do a two-step upgrade instead of just restarting the emulator with the new version of all applications. The reason for this design decision is to allow &lt;code&gt;code_change&lt;/code&gt; functions to have side effects, for example, changing data on disk. It also guarantees that the upgrade mechanism for non-core applications does not differ depending on whether or not core applications are changed at the same time.</source>
          <target state="translated">すべてのアプリケーションの新しいバージョンでエミュレータを再起動するだけではなく、2ステップのアップグレードを行うのは奇妙に思えるかもしれません。この設計決定の理由は、 &lt;code&gt;code_change&lt;/code&gt; 関数に副作用（ディスク上のデータの変更など）を許可するためです。また、コアアプリケーションが同時に変更されているかどうかによって、非コアアプリケーションのアップグレードメカニズムが異なることはありません。</target>
        </trans-unit>
        <trans-unit id="1c34c71fa77eb63943ded2490f8fbc60c0d144da" translate="yes" xml:space="preserve">
          <source>It no longer matters (from a performance point of view) whether you write:</source>
          <target state="translated">書いても書いても(パフォーマンス的には)どうでもよくなります。</target>
        </trans-unit>
        <trans-unit id="7c0489d666e1d6a42d00584a53dc773e8c02317f" translate="yes" xml:space="preserve">
          <source>It performs the following:</source>
          <target state="translated">以下のようなことを行います。</target>
        </trans-unit>
        <trans-unit id="4fc1e9aa2fcfb01c3fccf6fff85e215c7e86dd75" translate="yes" xml:space="preserve">
          <source>It requires the following entry in the configuration file:</source>
          <target state="translated">設定ファイルに以下のエントリが必要です。</target>
        </trans-unit>
        <trans-unit id="4aee747e0c3b08a2000058880942c33ddee8f0ee" translate="yes" xml:space="preserve">
          <source>It returns the list obtained by applying the function to every argument in the list.</source>
          <target state="translated">リスト内の各引数に関数を適用して得られたリストを返します。</target>
        </trans-unit>
        <trans-unit id="f32ea958d1b1b586fa5414a3a7ed52f8eb465554" translate="yes" xml:space="preserve">
          <source>It returns the value of &lt;code&gt;Exprs&lt;/code&gt; (a sequence of expressions &lt;code&gt;Expr1, ..., ExprN&lt;/code&gt;) unless an exception occurs during the evaluation. In that case the exception is caught and the patterns &lt;code&gt;ExceptionPattern&lt;/code&gt; with the right exception class &lt;code&gt;Class&lt;/code&gt; are sequentially matched against the caught exception. If a match succeeds and the optional guard sequence &lt;code&gt;ExceptionGuardSeq&lt;/code&gt; is true, the corresponding &lt;code&gt;ExceptionBody&lt;/code&gt; is evaluated to become the return value.</source>
          <target state="translated">これは、の値を返す &lt;code&gt;Exprs&lt;/code&gt; （表現のシーケンス &lt;code&gt;Expr1, ..., ExprN&lt;/code&gt; 例外が評価中に発生しない限り）を。その場合、例外がキャッチされ、正しい例外クラス &lt;code&gt;Class&lt;/code&gt; を持つパターン &lt;code&gt;ExceptionPattern&lt;/code&gt; が、キャッチされた例外に対して順番に照合されます。一致が成功し、オプションのガードシーケンス &lt;code&gt;ExceptionGuardSeq&lt;/code&gt; がtrueの場合、対応する &lt;code&gt;ExceptionBody&lt;/code&gt; が評価されて戻り値になります。</target>
        </trans-unit>
        <trans-unit id="f85990d4de42826fd89466e5ce7eebe1a15edc61" translate="yes" xml:space="preserve">
          <source>It sends the &lt;code&gt;io_reply&lt;/code&gt; tuple back to the client, providing element &lt;code&gt;ReplyAs&lt;/code&gt; received in the request along with the result of the request, as described earlier.</source>
          <target state="translated">これは、送信 &lt;code&gt;io_reply&lt;/code&gt; 素子の提供、クライアントのタプルバックを &lt;code&gt;ReplyAs&lt;/code&gt; 前述したように、要求の結果とともに要求で受信します。</target>
        </trans-unit>
        <trans-unit id="6b6a1da626faadda605a267c6b1500e6d3d0ae88" translate="yes" xml:space="preserve">
          <source>It sets up the subpattern as a capturing subpattern. That is, when the complete pattern matches, that portion of the subject string that matched the subpattern is passed back to the caller through the return value of &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">サブパターンをキャプチャサブパターンとして設定します。つまり、完全なパターンが一致すると、サブパターンと一致したサブジェクト文字列の部分が &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; の戻り値を通じて呼び出し元に返されます。</target>
        </trans-unit>
        <trans-unit id="49a082c6d89e819754d3f9153b8a7dfa0e39813e" translate="yes" xml:space="preserve">
          <source>It starts a tracer server and then sets the proper match spec (according to &lt;code&gt;Level&lt;/code&gt;).</source>
          <target state="translated">トレーササーバーを起動し、適切な一致仕様を設定します（ &lt;code&gt;Level&lt;/code&gt; に従って）。</target>
        </trans-unit>
        <trans-unit id="53405be9e406cd843e6767fd23eee426b478f794" translate="yes" xml:space="preserve">
          <source>It takes 32-bit salt values and generates hashes within &lt;code&gt;0..2^32-1&lt;/code&gt;.</source>
          <target state="translated">32ビットのソルト値を &lt;code&gt;0..2^32-1&lt;/code&gt; 内のハッシュを生成します。</target>
        </trans-unit>
        <trans-unit id="0b133d4d9bba6fcd143fa7778c2fc2dec25c3c1b" translate="yes" xml:space="preserve">
          <source>It uses only numeric or bitwise operators.</source>
          <target state="translated">数値演算子またはビット演算子のみを使用します。</target>
        </trans-unit>
        <trans-unit id="823797789dab9b16b0bc93679f0645c51a5106e7" translate="yes" xml:space="preserve">
          <source>It writes &quot;Ping received pong&quot; when this reply arrives, after which &quot;ping&quot; calls the &lt;code&gt;ping&lt;/code&gt; function again.</source>
          <target state="translated">この応答が到着すると、「Ping received pong」と書き込み、その後、「ping」が再度 &lt;code&gt;ping&lt;/code&gt; 関数を呼び出します。</target>
        </trans-unit>
        <trans-unit id="67225ea18531ad9a06624765739ff0f49809146c" translate="yes" xml:space="preserve">
          <source>It's assumed that the reader is familiar with &lt;code&gt;&lt;a href=&quot;install&quot;&gt;building and installing Erlang/OTP&lt;/a&gt;&lt;/code&gt;. To be able to patch an application, the following must exist:</source>
          <target state="translated">読者は &lt;code&gt;&lt;a href=&quot;install&quot;&gt;building and installing Erlang/OTP&lt;/a&gt;&lt;/code&gt; 精通していることを前提としています。アプリケーションにパッチを適用するには、次のものが必要です。</target>
        </trans-unit>
        <trans-unit id="c5929da3898f0513dfeb23acbd712fe856694c82" translate="yes" xml:space="preserve">
          <source>It, however, uses a native implementation that does not build garbage on the heap and with slightly better performance.</source>
          <target state="translated">しかし、ヒープ上にガベージを構築しないネイティブ実装を使用しており、パフォーマンスは若干向上しています。</target>
        </trans-unit>
        <trans-unit id="a06554ccb7c2d93d192c3296f349c54998105ca2" translate="yes" xml:space="preserve">
          <source>Item (?p{...}) interpolates Perl code at runtime, and in this case refers recursively to the pattern in which it appears.</source>
          <target state="translated">項目(?p{...})は実行時にPerlのコードを補間し、この場合はそれが出現するパターンを再帰的に参照します。</target>
        </trans-unit>
        <trans-unit id="f9de605e9ca977eaf604ed29c15fb02f2b60a6a8" translate="yes" xml:space="preserve">
          <source>Items can be logged &lt;strong&gt;synchronously&lt;/strong&gt; by using functions &lt;code&gt;&lt;a href=&quot;#log-2&quot;&gt;log/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#blog-2&quot;&gt;blog/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#log_terms-2&quot;&gt;log_terms/2&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#blog_terms-2&quot;&gt;blog_terms/2&lt;/a&gt;&lt;/code&gt;. For each of these functions, the caller is put on hold until the items are logged (but not necessarily written, use &lt;code&gt;sync/1&lt;/code&gt; to ensure that). By adding an &lt;code&gt;a&lt;/code&gt; to each of the mentioned function names, we get functions that log items &lt;strong&gt;asynchronously&lt;/strong&gt;. Asynchronous functions do not wait for the disk log process to write the items to the file, but return the control to the caller more or less immediately.</source>
          <target state="translated">関数 &lt;code&gt;&lt;a href=&quot;#log-2&quot;&gt;log/2&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;#blog-2&quot;&gt;blog/2&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;#log_terms-2&quot;&gt;log_terms/2&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;#blog_terms-2&quot;&gt;blog_terms/2&lt;/a&gt;&lt;/code&gt; を使用して、アイテムを&lt;strong&gt;同期&lt;/strong&gt;的にログに記録できます。これらの関数のそれぞれについて、項目がログに記録されるまで呼び出し元は保留されます（ただし、必ずしも書き込まれるとは限りません &lt;code&gt;sync/1&lt;/code&gt; を使用して確認してください）。上記の各関数名に &lt;code&gt;a&lt;/code&gt; を追加すると、アイテムを&lt;strong&gt;非同期&lt;/strong&gt;でログに記録する関数が得られ&lt;strong&gt;ます&lt;/strong&gt;。非同期関数は、ディスクログプロセスがアイテムをファイルに書き込むのを待たずに、ほぼ即座に制御を呼び出し元に返します。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="71d4607a768e8062fc1b15efd7c3e9e68a5b3118" translate="yes" xml:space="preserve">
          <source>Iterate over the currently stored events.</source>
          <target state="translated">現在保存されているイベントを繰り返し処理します。</target>
        </trans-unit>
        <trans-unit id="fcc26dcea46a8c4cabfbf0c36c28de8e261927eb" translate="yes" xml:space="preserve">
          <source>Iterates over a backup, either to transform it into a new backup, or read it. The arguments are explained briefly here. For details, see the User's Guide.</source>
          <target state="translated">バックアップを反復処理して、新しいバックアップに変換するか、バックアップを読み込むかを行います。ここでは引数について簡単に説明します。詳細については、ユーザーズガイドを参照してください。</target>
        </trans-unit>
        <trans-unit id="f75cc851edeeaf3491a906e7e439b3b971925d8d" translate="yes" xml:space="preserve">
          <source>Iterates over the currently stored events and applies a function for each event. The iteration may be performed forwards or backwards and may be limited to a maximum number of events (abs(Limit)).</source>
          <target state="translated">現在保存されているイベントを反復処理し、各イベントに対して関数を適用します。反復は前方または後方に実行され、イベントの最大数を制限することができます (abs(Limit))。</target>
        </trans-unit>
        <trans-unit id="a06d957ebec629d0f972194da6df852ad0d09740" translate="yes" xml:space="preserve">
          <source>Iterates over the table &lt;code&gt;Table&lt;/code&gt; and calls &lt;code&gt;Function(Record, NewAcc)&lt;/code&gt; for each &lt;code&gt;Record&lt;/code&gt; in the table. The term returned from &lt;code&gt;Function&lt;/code&gt; is used as the second argument in the next call to &lt;code&gt;Function&lt;/code&gt;.</source>
          <target state="translated">テーブル &lt;code&gt;Table&lt;/code&gt; を反復処理し、テーブル内の各 &lt;code&gt;Record&lt;/code&gt; に対して &lt;code&gt;Function(Record, NewAcc)&lt;/code&gt; を呼び出します。 &lt;code&gt;Function&lt;/code&gt; から返された用語は、次に &lt;code&gt;Function&lt;/code&gt; を呼び出すときに2番目の引数として使用されます。</target>
        </trans-unit>
        <trans-unit id="18905aab409cadb5b72681a650ec99001cb221e0" translate="yes" xml:space="preserve">
          <source>Iteration</source>
          <target state="translated">Iteration</target>
        </trans-unit>
        <trans-unit id="5786bb0f4dccffae9058c126884fe6758b70bd8a" translate="yes" xml:space="preserve">
          <source>Its syntax is as follows:</source>
          <target state="translated">その構文は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="0165af04c080f487130b22dea529e0f95b8d85ca" translate="yes" xml:space="preserve">
          <source>Its value can be evaluated to a constant when complied.</source>
          <target state="translated">その値は、準拠した場合に定数として評価することができます。</target>
        </trans-unit>
        <trans-unit id="56d1de825316e64de255f931e870a2d3e72a7f4f" translate="yes" xml:space="preserve">
          <source>James logs on at c2@kosken:</source>
          <target state="translated">James は c2@kosken でログオンしています。</target>
        </trans-unit>
        <trans-unit id="c42ecc8a80467df93a2c87a03b9343afff3e3487" translate="yes" xml:space="preserve">
          <source>James now tries to send a message to Fred:</source>
          <target state="translated">ジェームズはフレッドにメッセージを送ろうとします。</target>
        </trans-unit>
        <trans-unit id="4d3bb51ea74dbb54d8ffaf04425ff843127f10a5" translate="yes" xml:space="preserve">
          <source>Javanese</source>
          <target state="translated">Javanese</target>
        </trans-unit>
        <trans-unit id="985f31fc009e0eb1ee596f08399982c19f072dde" translate="yes" xml:space="preserve">
          <source>Jive - Removed from Erlang/OTP R7B.</source>
          <target state="translated">Jive-Erlang/OTP R7Bから削除。</target>
        </trans-unit>
        <trans-unit id="f404bac0df97acac197f63ffb414c0a51f6641b9" translate="yes" xml:space="preserve">
          <source>Jive provided a simple interface between an Erlang program and a Java program.</source>
          <target state="translated">Jiveは、ErlangプログラムとJavaプログラムの間にシンプルなインターフェースを提供しました。</target>
        </trans-unit>
        <trans-unit id="d4aaf0c42e0ce9df5b69e24e3360c3fccba4e12c" translate="yes" xml:space="preserve">
          <source>Job Control Mode, &lt;code&gt;JCL&lt;/code&gt;, in which jobs can be started, killed, detached, and connected</source>
          <target state="translated">ジョブ制御モード、 &lt;code&gt;JCL&lt;/code&gt; 。ジョブを開始、強制終了、切り離し、および接続できます。</target>
        </trans-unit>
        <trans-unit id="60fcc4fbeee80db53471e4e665b7867b155491ca" translate="yes" xml:space="preserve">
          <source>Joined specifications share common configuration settings, such as the list of &lt;code&gt;config&lt;/code&gt; files or &lt;code&gt;include&lt;/code&gt; directories. For configurations that cannot be combined, such as settings for &lt;code&gt;logdir&lt;/code&gt; or &lt;code&gt;verbosity&lt;/code&gt;, it is up to the user to ensure there are no clashes when the test specifications are joined. Specifications included with option &lt;code&gt;separate&lt;/code&gt; do not share configuration settings with the source specification. This is useful, for example, if there are clashing configuration settings in included specifications, making it them impossible to join.</source>
          <target state="translated">入社仕様は、このようなリストなどの一般的な構成設定、共有 &lt;code&gt;config&lt;/code&gt; ファイルをまたは &lt;code&gt;include&lt;/code&gt; ディレクトリを。 &lt;code&gt;logdir&lt;/code&gt; や &lt;code&gt;verbosity&lt;/code&gt; の設定など、組み合わせることができない構成の場合、テスト仕様を結合するときに衝突がないことを確認するのはユーザーの責任です。オプション &lt;code&gt;separate&lt;/code&gt; 含まれる仕様は、構成設定をソース仕様と共有しません。これは、たとえば、含まれている仕様に競合する構成設定があり、参加できないようにする場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="09836e547b774a1e0d6ccac306d02bc552ce1707" translate="yes" xml:space="preserve">
          <source>Joining a number of specifications, or running them separately, can also be accomplished with (and can be combined with) test specification file inclusion.</source>
          <target state="translated">複数の仕様書を結合したり、別々に実行したりすることも、テスト仕様書ファイルのインクルードで実現できます(また、結合することもできます)。</target>
        </trans-unit>
        <trans-unit id="bd8fa532a1f183308b75829983ef5286dd43f6ae" translate="yes" xml:space="preserve">
          <source>Joins a list of filename &lt;code&gt;Components&lt;/code&gt; with directory separators. If one of the elements of &lt;code&gt;Components&lt;/code&gt; includes an absolute path, such as &lt;code&gt;&quot;/xxx&quot;&lt;/code&gt;, the preceding elements, if any, are removed from the result.</source>
          <target state="translated">ファイル名 &lt;code&gt;Components&lt;/code&gt; リストをディレクトリ区切り文字で結合します。 &lt;code&gt;Components&lt;/code&gt; の要素の1つに &lt;code&gt;&quot;/xxx&quot;&lt;/code&gt; などの絶対パスが含まれている場合、先行する要素があれば、結果から削除されます。</target>
        </trans-unit>
        <trans-unit id="767d4fa36d9593f6ccc09a43de0901229900dc82" translate="yes" xml:space="preserve">
          <source>Joins a multicast group.</source>
          <target state="translated">マルチキャストグループに参加します。</target>
        </trans-unit>
        <trans-unit id="f18e485822fa69f055b28a9bb0d0a99a002c6e43" translate="yes" xml:space="preserve">
          <source>Joins an absolute directory with a relative filename. Similar to &lt;code&gt;&lt;a href=&quot;#join-2&quot;&gt;join/2&lt;/a&gt;&lt;/code&gt;, but on platforms with tight restrictions on raw filename length and no support for symbolic links (read: VxWorks), leading parent directory components in &lt;code&gt;Filename&lt;/code&gt; are matched against trailing directory components in &lt;code&gt;Dir&lt;/code&gt; so they can be removed from the result - minimizing its length.</source>
          <target state="translated">絶対ディレクトリを相対ファイル名で結合します。 &lt;code&gt;&lt;a href=&quot;#join-2&quot;&gt;join/2&lt;/a&gt;&lt;/code&gt; に似ていますが、未加工のファイル名の長さが厳しく制限されていて、シンボリックリンクがサポートされていないプラットフォーム（読み取り：VxWorks）では、 &lt;code&gt;Filename&lt;/code&gt; の先頭の親ディレクトリコンポーネントが &lt;code&gt;Dir&lt;/code&gt; の末尾のディレクトリコンポーネントと照合されるため、結果から削除できます。 -その長さを最小限に抑えます。</target>
        </trans-unit>
        <trans-unit id="b01e92d8e16fef4b631125f5e97915c826988378" translate="yes" xml:space="preserve">
          <source>Joins individual comment lines into multi-line comments. The input is a list of entries representing individual comment lines, &lt;strong&gt;in order of decreasing line-numbers&lt;/strong&gt;; see &lt;code&gt;&lt;a href=&quot;#scan_lines-1&quot;&gt;scan_lines/1&lt;/a&gt;&lt;/code&gt; for details. The result is a list of entries representing &lt;strong&gt;multi-line&lt;/strong&gt; comments, &lt;strong&gt;still listed in order of decreasing line-numbers&lt;/strong&gt;, but where for each entry, &lt;code&gt;Text&lt;/code&gt; is a list of consecutive comment lines in order of &lt;strong&gt;increasing&lt;/strong&gt; line-numbers (i.e., top-down).</source>
          <target state="translated">個々のコメント行を複数行コメントに結合します。入力は、個々のコメント行を表すエントリのリストで、&lt;strong&gt;行番号の降順&lt;/strong&gt;です。詳細については、 &lt;code&gt;&lt;a href=&quot;#scan_lines-1&quot;&gt;scan_lines/1&lt;/a&gt;&lt;/code&gt; を参照してください。結果は、&lt;strong&gt;複数行の&lt;/strong&gt;コメントを表すエントリのリストですが、&lt;strong&gt;行番号の降順でリストされて&lt;/strong&gt;いますが、各エントリについて、 &lt;code&gt;Text&lt;/code&gt; は連続するコメント行のリストで、行番号の&lt;strong&gt;昇順&lt;/strong&gt;（つまり、上から下）です。 ）。</target>
        </trans-unit>
        <trans-unit id="a0528c50bacb4e35cb285f0ed3e8896f71709c3e" translate="yes" xml:space="preserve">
          <source>Joins the calling thread with another thread, that is, the calling thread is blocked until the thread identified by &lt;code&gt;tid&lt;/code&gt; has terminated.</source>
          <target state="translated">呼び出しスレッドを別のスレッドと結合します。つまり、 &lt;code&gt;tid&lt;/code&gt; で識別されるスレッドが終了するまで、呼び出しスレッドはブロックされます。</target>
        </trans-unit>
        <trans-unit id="ed124b10c968f3ba56bc00750777640854ffbb45" translate="yes" xml:space="preserve">
          <source>Joins the process &lt;code&gt;Pid&lt;/code&gt; to the group &lt;code&gt;Name&lt;/code&gt;. A process can join a group many times and must then leave the group the same number of times.</source>
          <target state="translated">プロセス &lt;code&gt;Pid&lt;/code&gt; をグループ &lt;code&gt;Name&lt;/code&gt; に結合します。プロセスはグループに何度も参加でき、その後同じ回数グループを離れる必要があります。</target>
        </trans-unit>
        <trans-unit id="a725b3a9aec37eb16b991bfa7ac62728bda90c3f" translate="yes" xml:space="preserve">
          <source>Joins two filename components with directory separators. Equivalent to &lt;code&gt;join([Name1, Name2])&lt;/code&gt;.</source>
          <target state="translated">2つのファイル名コンポーネントをディレクトリ区切り文字で結合します。相当 &lt;code&gt;join([Name1, Name2])&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c4c209b4f5dd5eec8921277cc06b858d506fcc16" translate="yes" xml:space="preserve">
          <source>Jump function: equivalent to 2^512 calls</source>
          <target state="translated">ジャンプ関数:2^512コールに相当</target>
        </trans-unit>
        <trans-unit id="e9519676df51c9a760d29ebd09d2737821522add" translate="yes" xml:space="preserve">
          <source>Jump function: equivalent to 2^64 calls</source>
          <target state="translated">ジャンプ関数:2^64回の呼び出しに相当</target>
        </trans-unit>
        <trans-unit id="993f27123cfb967c548d6417f96dc64d01aeac7a" translate="yes" xml:space="preserve">
          <source>Just add the &lt;code&gt;--with-dynamic-trace=dtrace&lt;/code&gt; option to your command when you run the &lt;code&gt;configure&lt;/code&gt; script. If you are using systemtap, the configure option is &lt;code&gt;--with-dynamic-trace=systemtap&lt;/code&gt;</source>
          <target state="translated">ただ、追加 &lt;code&gt;--with-dynamic-trace=dtrace&lt;/code&gt; あなたが実行したときに、あなたのコマンドにオプションを &lt;code&gt;configure&lt;/code&gt; 、スクリプトを。systemtapを使用している場合、設定オプションは &lt;code&gt;--with-dynamic-trace=systemtap&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="954a229b3c7d24932c013089be8a60de0b28ba48" translate="yes" xml:space="preserve">
          <source>Just prints a marker showing the current file and line number. Note that this is an argument-less macro. The result is always &lt;code&gt;ok&lt;/code&gt;.</source>
          <target state="translated">現在のファイルと行番号を示すマーカーを印刷するだけです。これは引数なしのマクロであることに注意してください。結果は常に &lt;code&gt;ok&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="ae170b17bf57b2dd3f07fcd95b9f2bb7e3b26355" translate="yes" xml:space="preserve">
          <source>Kaithi</source>
          <target state="translated">Kaithi</target>
        </trans-unit>
        <trans-unit id="c3ed665577f91f82c451742a0c8875950d42b19f" translate="yes" xml:space="preserve">
          <source>Kannada</source>
          <target state="translated">Kannada</target>
        </trans-unit>
        <trans-unit id="6842e5a778887793f59acc2ef5454c8c1ea0e92d" translate="yes" xml:space="preserve">
          <source>Katakana</source>
          <target state="translated">Katakana</target>
        </trans-unit>
        <trans-unit id="75ee154fd513c399937f6b79a87ebbade8c7cadd" translate="yes" xml:space="preserve">
          <source>Kayah_Li</source>
          <target state="translated">Kayah_Li</target>
        </trans-unit>
        <trans-unit id="25abdae1d9ca507dc9eba57c2eaf4112edb57019" translate="yes" xml:space="preserve">
          <source>Keep alive (sends NOP to the server every 8 sec if connection is idle) = &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">キープアライブ（接続がアイドル状態の場合、8秒ごとにサーバーにNOPを送信）= &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7ddeccd73131648e86aeb841d4eb296569a6a514" translate="yes" xml:space="preserve">
          <source>Keep in mind that external commands are highly dependent on the operating system. You can use the standard library function &lt;code&gt;os:type()&lt;/code&gt; in test generator functions, to produce different sets of tests depending on the current operating system.</source>
          <target state="translated">外部コマンドはオペレーティングシステムに大きく依存していることに注意してください。テストジェネレーター関数で標準ライブラリ関数 &lt;code&gt;os:type()&lt;/code&gt; を使用して、現在のオペレーティングシステムに応じて異なるテストセットを生成できます。</target>
        </trans-unit>
        <trans-unit id="af2e28b7a1b7099319eee33d2a3b8c97b2e40baf" translate="yes" xml:space="preserve">
          <source>Keep the monitoring process neat and do not set the system monitor limits too tight.</source>
          <target state="translated">モニタリングプロセスをきれいに保ち、システムモニターのリミットを厳しく設定しすぎないようにしてください。</target>
        </trans-unit>
        <trans-unit id="500721d2cc2f16b61805dc2d3a9d1060f70c2830" translate="yes" xml:space="preserve">
          <source>Keeping an index table introduces some overhead when inserting records in the table. The number of operations gained from the table must therefore be compared against the number of operations inserting objects in the table. However, notice that the gain is significant when the key can be used to lookup elements.</source>
          <target state="translated">インデックステーブルを保持することは、テーブルにレコードを挿入する際にいくつかのオーバーヘッドを導入する。したがって、テーブルから得られる操作の数は、テーブルにオブジェクトを挿入する操作の数と比較しなければなりません。しかし、キーが要素のルックアップに使用できる場合には、得られる操作の数が大きいことに注意してください。</target>
        </trans-unit>
        <trans-unit id="77d353f60b778f61763e54fe995206afd07d38e7" translate="yes" xml:space="preserve">
          <source>Kernel - Functionality necessary to run Erlang</source>
          <target state="translated">カーネル-Erlangを実行するために必要な機能</target>
        </trans-unit>
        <trans-unit id="d94461d9eb74a4bd391db53e61a81a60c815b678" translate="yes" xml:space="preserve">
          <source>Key &lt;code&gt;mod&lt;/code&gt; is necessary for an application implemented as a supervision tree, otherwise the application controller does not know how to start it. &lt;code&gt;mod&lt;/code&gt; can be omitted for applications without processes, typically code libraries, for example, STDLIB.</source>
          <target state="translated">キー &lt;code&gt;mod&lt;/code&gt; は、監視ツリーとして実装されたアプリケーションに必要です。そうでない場合、アプリケーションコントローラーは開始方法を認識しません。 &lt;code&gt;mod&lt;/code&gt; は、プロセスのないアプリケーション（通常、STDLIBなどのコードライブラリ）では省略できます。</target>
        </trans-unit>
        <trans-unit id="ca5a9efe453be1a8fb90eb103db6529be3cedecc" translate="yes" xml:space="preserve">
          <source>Key exchange.</source>
          <target state="translated">鍵の交換です。</target>
        </trans-unit>
        <trans-unit id="ef9462cf7acc58f9332c44f3d35c8156471e2d59" translate="yes" xml:space="preserve">
          <source>Key length is 128, 192 or 256 bits</source>
          <target state="translated">鍵の長さは128、192または256ビット</target>
        </trans-unit>
        <trans-unit id="8e49238278cd15e4058ff109458f7ab64787d062" translate="yes" xml:space="preserve">
          <source>Key length is 64 bits (in CBC mode only 8 bits are used)</source>
          <target state="translated">鍵長は64ビット(CBCモードでは8ビットのみ使用</target>
        </trans-unit>
        <trans-unit id="a8eda14ae757b93056cfd42c03aa35572e0dfbf4" translate="yes" xml:space="preserve">
          <source>Key that thread-specific data can be associated with.</source>
          <target state="translated">スレッド固有のデータを関連付けられるキー。</target>
        </trans-unit>
        <trans-unit id="54bec160f0ff07cdaa698765d9e3b701a9206120" translate="yes" xml:space="preserve">
          <source>Key-value dictionary as ordered list.</source>
          <target state="translated">キー-値辞書を順序付きリストとして提供します。</target>
        </trans-unit>
        <trans-unit id="03548558e8e95e2c9e4473346b7862a221a3449a" translate="yes" xml:space="preserve">
          <source>Key-value dictionary.</source>
          <target state="translated">キー値辞書。</target>
        </trans-unit>
        <trans-unit id="64a1a6e2ae2f7e426d8c76fa00ed13e339774927" translate="yes" xml:space="preserve">
          <source>Keys and values are separated by the &lt;code&gt;=&amp;gt;&lt;/code&gt; arrow and associations are separated by a comma &lt;code&gt;,&lt;/code&gt;.</source>
          <target state="translated">キーと値は &lt;code&gt;=&amp;gt;&lt;/code&gt; 矢印で区切られ、関連付けはカンマ &lt;code&gt;,&lt;/code&gt; 区切られます。</target>
        </trans-unit>
        <trans-unit id="50ef25fb2e036bb0a08a44baf61c0ca27e1477ef" translate="yes" xml:space="preserve">
          <source>Keys are strings, that is, &lt;code&gt;NULL&lt;/code&gt;-terminated arrays of characters, and values are arbitrary objects. Although integers and floating point numbers are treated specially by the registry, you can store strings or binary objects of any type as pointers.</source>
          <target state="translated">キーは文字列、つまり &lt;code&gt;NULL&lt;/code&gt; で終了する文字の配列であり、値は任意のオブジェクトです。整数と浮動小数点数はレジストリによって特別に扱われますが、文字列または任意のタイプのバイナリオブジェクトをポインタとして格納できます。</target>
        </trans-unit>
        <trans-unit id="b6336831bbeb983ca82f9d4a77612af9bca7a91d" translate="yes" xml:space="preserve">
          <source>Kharoshthi</source>
          <target state="translated">Kharoshthi</target>
        </trans-unit>
        <trans-unit id="3db4bac2e32c1fd4c51c4ffc01f1ab523d35aa5f" translate="yes" xml:space="preserve">
          <source>Khmer</source>
          <target state="translated">Khmer</target>
        </trans-unit>
        <trans-unit id="ae06f314c491ae0e878d4c91501cd37217955650" translate="yes" xml:space="preserve">
          <source>Khojki</source>
          <target state="translated">Khojki</target>
        </trans-unit>
        <trans-unit id="0aff8b4bceea8e19c584f9aea3e91bc8fa365436" translate="yes" xml:space="preserve">
          <source>Khudawadi</source>
          <target state="translated">Khudawadi</target>
        </trans-unit>
        <trans-unit id="1d5d5869cb0eedafcc8a41f33ab897f070f4fb42" translate="yes" xml:space="preserve">
          <source>Kill line</source>
          <target state="translated">殺陣</target>
        </trans-unit>
        <trans-unit id="f454e1ed16b6541108a62b0e0fc74e1cd5b5843d" translate="yes" xml:space="preserve">
          <source>Kill or suspend the current shell</source>
          <target state="translated">現在のシェルを停止または中断する</target>
        </trans-unit>
        <trans-unit id="880f10ee37e48d0c630a2a5789a5d88a3169af1e" translate="yes" xml:space="preserve">
          <source>Kill the receiving process.</source>
          <target state="translated">受信処理を殺す。</target>
        </trans-unit>
        <trans-unit id="5bfcbaee6e0f4c10a8cefbf0071cff67b1bf2828" translate="yes" xml:space="preserve">
          <source>Killing the running &lt;code&gt;epmd&lt;/code&gt; is only allowed if &lt;code&gt;epmd -names&lt;/code&gt; shows an empty database or if &lt;code&gt;-relaxed_command_check&lt;/code&gt; was specified when the running instance of &lt;code&gt;epmd&lt;/code&gt; was started.</source>
          <target state="translated">ランニングキリング &lt;code&gt;epmd&lt;/code&gt; 場合にのみ許可されている &lt;code&gt;epmd -names&lt;/code&gt; 空のデータベースまたは場合ショー &lt;code&gt;-relaxed_command_check&lt;/code&gt; は、実行中のインスタンス時に指定された &lt;code&gt;epmd&lt;/code&gt; 開始されました。</target>
        </trans-unit>
        <trans-unit id="4b4606adf1d6fece03ee95344c970518fc47aef2" translate="yes" xml:space="preserve">
          <source>Kills job number &lt;code&gt;nn&lt;/code&gt; or the current job. All spawned processes in the job are killed, provided they have not evaluated the &lt;code&gt;group_leader/1&lt;/code&gt; BIF and are located on the local machine. Processes spawned on remote nodes are not killed.</source>
          <target state="translated">ジョブ番号 &lt;code&gt;nn&lt;/code&gt; または現在のジョブを強制終了します。ジョブで生成されたすべてのプロセスは、 &lt;code&gt;group_leader/1&lt;/code&gt; BIFを評価しておらず、ローカルマシン上にある場合、強制終了されます。リモートノードで生成されたプロセスは強制終了されません。</target>
        </trans-unit>
        <trans-unit id="cc10a5d2feb24085bc1cb119b2435586c453c952" translate="yes" xml:space="preserve">
          <source>Kills the currently running &lt;code&gt;epmd&lt;/code&gt;.</source>
          <target state="translated">現在実行中の &lt;code&gt;epmd&lt;/code&gt; を強制終了します。</target>
        </trans-unit>
        <trans-unit id="9d84b2a4d9545512a2d7f125ae79d81a8e5c0761" translate="yes" xml:space="preserve">
          <source>Known hosts - OpenSSH format looks as follows:</source>
          <target state="translated">既知のホスト-OpenSSH のフォーマットは以下のようになります。</target>
        </trans-unit>
        <trans-unit id="0a39eb519037dfb6d76d299ba4999c6ffc80181b" translate="yes" xml:space="preserve">
          <source>Known issue: When a node is restarted multiple times with the same node name, references created on a newer node can be mistaken for a reference created on an older node with the same node name.</source>
          <target state="translated">既知の問題。ノードが同じノード名で複数回再起動された場合、新しいノードに作成された参照が、同じノード名で古いノードに作成された参照と間違われることがある。</target>
        </trans-unit>
        <trans-unit id="cf67592c20c9144029824037c9c62ac2e394e9f6" translate="yes" xml:space="preserve">
          <source>Known nodes</source>
          <target state="translated">既知のノード</target>
        </trans-unit>
        <trans-unit id="ed13795fff22b6ce7eef6295ec8759f5887cc8c1" translate="yes" xml:space="preserve">
          <source>LALR-1 Parser Generator</source>
          <target state="translated">LALR-1 パーサジェネレータ</target>
        </trans-unit>
        <trans-unit id="8c1317978bcd30e222ba66c242f8123e43c7856b" translate="yes" xml:space="preserve">
          <source>LDAP Client</source>
          <target state="translated">LDAPクライアント</target>
        </trans-unit>
        <trans-unit id="51eb7d6d9c204fdf12fe469c25a3f66ed762d7c2" translate="yes" xml:space="preserve">
          <source>LTTng-UST: user space tracing library.</source>
          <target state="translated">LTTng-UST:ユーザ空間トレースライブラリ。</target>
        </trans-unit>
        <trans-unit id="1a3e364b61f5b7002da39483efb6f5c6e878f8ed" translate="yes" xml:space="preserve">
          <source>LTTng-tools: a command line interface to control tracing sessions.</source>
          <target state="translated">LTTng-tools:トレースセッションを制御するためのコマンドラインインターフェース。</target>
        </trans-unit>
        <trans-unit id="835d9d02d574ee591fe276efb1ca4a509eeac77d" translate="yes" xml:space="preserve">
          <source>Label (type) of the event.</source>
          <target state="translated">イベントのラベル(種類)。</target>
        </trans-unit>
        <trans-unit id="da8c0bd743f4d20bdd7803e99770281ada2c9a3c" translate="yes" xml:space="preserve">
          <source>Label intended to provide a brief event summary.</source>
          <target state="translated">イベントの簡単な概要を提供することを目的としたラベル。</target>
        </trans-unit>
        <trans-unit id="569411a8a6e7229622b5dc0e1261f3311e3e9ca4" translate="yes" xml:space="preserve">
          <source>Label the test run (similar to &lt;code&gt;ct_run -label&lt;/code&gt;).</source>
          <target state="translated">テスト実行にラベルを &lt;code&gt;ct_run -label&lt;/code&gt; ます（ct_run -labelと同様）。</target>
        </trans-unit>
        <trans-unit id="8a2ceed634c06e53fd54795bf2ad3a353a944142" translate="yes" xml:space="preserve">
          <source>Labels were restricted to small signed integers (28 bits) prior to OTP 21. The trace token will be silenty dropped if it crosses over to a node that does not support the label.</source>
          <target state="translated">OTP 21以前ではラベルは小さな符号付き整数(28ビット)に制限されていました。トレーストークンは、ラベルをサポートしていないノードにクロスオーバーした場合に silenty ドロップされます。</target>
        </trans-unit>
        <trans-unit id="8ca0beae5821435b0fbc549f128dd2d696efd3c9" translate="yes" xml:space="preserve">
          <source>Lack of support. Such as loading NIF library for a HiPE compiled module.</source>
          <target state="translated">サポートが不足している。HiPEでコンパイルしたモジュールにNIFライブラリをロードするなど。</target>
        </trans-unit>
        <trans-unit id="bf9167c4d0a9ea5934fd36027e2b85a918a6fffd" translate="yes" xml:space="preserve">
          <source>Language constructions such as &lt;code&gt;case&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, and &lt;code&gt;catch&lt;/code&gt; that are not present in match specifications are not allowed.</source>
          <target state="translated">一致指定に存在しない、 &lt;code&gt;case&lt;/code&gt; 、 &lt;code&gt;if&lt;/code&gt; 、および &lt;code&gt;catch&lt;/code&gt; などの言語構成は許可されません。</target>
        </trans-unit>
        <trans-unit id="074e87167a892ed75f793d4be4f6837d502c8b01" translate="yes" xml:space="preserve">
          <source>Language or locale specific handling of input is not considered in any function.</source>
          <target state="translated">入力の言語やロケールに依存した処理は、どの関数でも考慮されません。</target>
        </trans-unit>
        <trans-unit id="04eb4ab3dd59acb8c8766875365c70ae815f2eeb" translate="yes" xml:space="preserve">
          <source>Languages with no concept of upper case (or lower case).</source>
          <target state="translated">大文字(または小文字)の概念がない言語。</target>
        </trans-unit>
        <trans-unit id="c1439807deac3e6c9290cfd97415a4b15f4ba6c8" translate="yes" xml:space="preserve">
          <source>Lao</source>
          <target state="translated">Lao</target>
        </trans-unit>
        <trans-unit id="738fd1d2452fc31a236c5ad511bfcc46b324365e" translate="yes" xml:space="preserve">
          <source>Large</source>
          <target state="translated">Large</target>
        </trans-unit>
        <trans-unit id="21162f096b26204df6588bb5dc28d2f51868c501" translate="yes" xml:space="preserve">
          <source>Large File Support</source>
          <target state="translated">大容量ファイル対応</target>
        </trans-unit>
        <trans-unit id="a438bdcc6fdd98852d15b24d8295882a73c68552" translate="yes" xml:space="preserve">
          <source>Large Map (&amp;gt; 32 keys)</source>
          <target state="translated">大きな地図（32キー以上）</target>
        </trans-unit>
        <trans-unit id="09edce0ea90a1c7861091688fe21ce083d692315" translate="yes" xml:space="preserve">
          <source>Large bursts of log events - many events received by the handler under a short period of time - can potentially cause problems, such as:</source>
          <target state="translated">ログイベントの大規模なバースト-ハンドラが短時間の間に受信した多くのイベント-は、潜在的に次のような問題を引き起こす可能性があります。</target>
        </trans-unit>
        <trans-unit id="54100e7e3068c1ca218d4f103c9eb3344bef2359" translate="yes" xml:space="preserve">
          <source>Large integer</source>
          <target state="translated">大整数</target>
        </trans-unit>
        <trans-unit id="d84176d4d4e07b609ddf89b910ffa92d9b205afb" translate="yes" xml:space="preserve">
          <source>Large-scale automated testing requires running multiple independent test sessions in parallel. This is accomplished by running some &lt;code&gt;Common Test&lt;/code&gt; nodes on one or more hosts, testing different target systems. Configuring, starting, and controlling the test nodes independently can be a cumbersome operation. To aid this kind of automated large-scale testing, &lt;code&gt;Common Test&lt;/code&gt; offers a master test node component, &lt;code&gt;Common Test&lt;/code&gt; Master, which handles central configuration and control in a system of distributed &lt;code&gt;Common Test&lt;/code&gt; nodes.</source>
          <target state="translated">大規模な自動テストでは、複数の独立したテストセッションを並行して実行する必要があります。これは、1つ以上のホストでいくつかの &lt;code&gt;Common Test&lt;/code&gt; ノードを実行し、さまざまなターゲットシステムをテストすることで実現されます。テストノードを個別に構成、開始、および制御することは、面倒な操作になる可能性があります。この種の自動化された大規模なテストを支援するために、 &lt;code&gt;Common Test&lt;/code&gt; はマスターテストノードコンポーネントである &lt;code&gt;Common Test&lt;/code&gt; Masterを提供します。これは、分散型 &lt;code&gt;Common Test&lt;/code&gt; ノードのシステムで中央構成と制御を処理します。</target>
        </trans-unit>
        <trans-unit id="44df0948d1567d9036374aa410e4c8a2be0c9c10" translate="yes" xml:space="preserve">
          <source>Larger programs are usually written as a collection of files with a well-defined interface between the various parts.</source>
          <target state="translated">大規模なプログラムは、通常、様々な部分の間に明確に定義されたインターフェースを持つファイルの集合体として書かれます。</target>
        </trans-unit>
        <trans-unit id="693744ef4c03b347c7a1a709150a100f34f5dd75" translate="yes" xml:space="preserve">
          <source>Larger test cases make it harder to tell what went wrong if it fails. Also, large portions of test code risk being skipped when errors occur.</source>
          <target state="translated">テストケースが大きくなると、失敗した場合に何が悪かったのかがわかりにくくなります。また、テストコードの大部分は、エラーが発生したときにスキップされるリスクがあります。</target>
        </trans-unit>
        <trans-unit id="8908c45e62de1705042c387b70533568d70c9293" translate="yes" xml:space="preserve">
          <source>Largest (&lt;code&gt;mseg_alloc&lt;/code&gt;) multiblock carrier size (in kilobytes). See the description on how sizes for &lt;code&gt;mseg_alloc&lt;/code&gt; multiblock carriers are decided in section &lt;code&gt;&lt;a href=&quot;#mseg_mbc_sizes&quot;&gt;The alloc_util Framework&lt;/a&gt;&lt;/code&gt;. On 32-bit Unix style OS this limit cannot be set &amp;gt; 128 MB.</source>
          <target state="translated">最大（ &lt;code&gt;mseg_alloc&lt;/code&gt; ）マルチブロックキャリアサイズ（キロバイト単位）。 &lt;code&gt;mseg_alloc&lt;/code&gt; マルチブロックキャリアのサイズがセクション &lt;code&gt;&lt;a href=&quot;#mseg_mbc_sizes&quot;&gt;The alloc_util Framework&lt;/a&gt;&lt;/code&gt; 決定される方法の説明を参照してください。32ビットUnixスタイルのOSでは、この制限を128 MB以上に設定することはできません。</target>
        </trans-unit>
        <trans-unit id="7c3af79a814ee249e319b2aca0ff91587147fc1f" translate="yes" xml:space="preserve">
          <source>Last argument to &lt;code&gt;start_link/4&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;start_link/4&lt;/code&gt; の最後の引数。</target>
        </trans-unit>
        <trans-unit id="2ff3ac5eb04bb6845c35e02907378511f958744f" translate="yes" xml:space="preserve">
          <source>Last trans id.</source>
          <target state="translated">最後のトランジットID。</target>
        </trans-unit>
        <trans-unit id="92691b5a6cdf3c7e69cbf1e0e1a0775e6d6241e3" translate="yes" xml:space="preserve">
          <source>Last, the application master terminates. Notice that all processes with the application master as group leader, that is, processes spawned from a process belonging to the application, are also terminated.</source>
          <target state="translated">最後に、アプリケーションマスタが終了します。アプリケーションマスタをグループリーダとするすべてのプロセス、つまりアプリケーションに属するプロセスから生成されたプロセスも同様に終了することに注意してください。</target>
        </trans-unit>
        <trans-unit id="e67316d545772b35f3ccfda079c9a6451806f0ad" translate="yes" xml:space="preserve">
          <source>Later, when you have fixed a bug in your application my_app, you want to update the PLT so that it becomes fresh the next time you run Dialyzer. In this case, run the following command:</source>
          <target state="translated">後日、アプリケーションmy_appのバグを修正したときに、次にDialyzerを実行したときにPLTを更新して新鮮な状態にしたいとします。この場合、以下のコマンドを実行します。</target>
        </trans-unit>
        <trans-unit id="9bde795b72be44b343c829314d764282997de688" translate="yes" xml:space="preserve">
          <source>Latin</source>
          <target state="translated">Latin</target>
        </trans-unit>
        <trans-unit id="0870ce81860445392cddd5a3e67af112160f7b41" translate="yes" xml:space="preserve">
          <source>Leading slashes in tar member names will be removed before writing the file. That is, absolute paths will be turned into relative paths. There will be an info message written to the error logger when paths are changed in this way.</source>
          <target state="translated">tar のメンバー名の先頭のスラッシュは、ファイルを書き込む前に削除されます。つまり、絶対パスが相対パスに変わります。このようにパスが変更されると、エラーロガーに情報メッセージが書き込まれます。</target>
        </trans-unit>
        <trans-unit id="0eb1f77fb19c9a09977d5bd220a6012ba74f0842" translate="yes" xml:space="preserve">
          <source>Leaves a multicast group.</source>
          <target state="translated">マルチキャストグループを退出します。</target>
        </trans-unit>
        <trans-unit id="46ca3dd951cfb863abc35ba1a75861a27f06846b" translate="yes" xml:space="preserve">
          <source>Leaves it up to the user to read and interpret the logged data. The &lt;code&gt;disk_log&lt;/code&gt; module cannot repair externally formatted logs.</source>
          <target state="translated">ログに記録されたデータを読み取って解釈するのはユーザーに任せます。 &lt;code&gt;disk_log&lt;/code&gt; モジュールは、外部フォーマットされたログを修復することはできません。</target>
        </trans-unit>
        <trans-unit id="b3210120e1c6a9da2f06b35919f757a581401639" translate="yes" xml:space="preserve">
          <source>Leex will add the extension &lt;code&gt;.hrl&lt;/code&gt; to the &lt;code&gt;Includefile&lt;/code&gt; name and the extension &lt;code&gt;.erl&lt;/code&gt; to the &lt;code&gt;Scannerfile&lt;/code&gt; name, unless the extension is already there.</source>
          <target state="translated">Leexは、拡張を追加します &lt;code&gt;.hrl&lt;/code&gt; をする &lt;code&gt;Includefile&lt;/code&gt; の名前と拡張子 &lt;code&gt;.erl&lt;/code&gt; に &lt;code&gt;Scannerfile&lt;/code&gt; の拡張子がすでに存在していない限り、名前。</target>
        </trans-unit>
        <trans-unit id="1ac95874a8d20e24893ff29b459f57b2ffdf6541" translate="yes" xml:space="preserve">
          <source>Left associative</source>
          <target state="translated">左の連想</target>
        </trans-unit>
        <trans-unit id="8565991e36224ecb55a79ffde16fa430f01d691e" translate="yes" xml:space="preserve">
          <source>Legacy API function &lt;code&gt;process_msg/7&lt;/code&gt; that has got separate &lt;code&gt;IpAddr&lt;/code&gt; and &lt;code&gt;PortNumber&lt;/code&gt; arguments still works as before for backwards compatibility reasons.</source>
          <target state="translated">個別の &lt;code&gt;IpAddr&lt;/code&gt; 引数と &lt;code&gt;PortNumber&lt;/code&gt; 引数を持つレガシーAPI関数 &lt;code&gt;process_msg/7&lt;/code&gt; は、下位互換性の理由から以前と同様に機能します。</target>
        </trans-unit>
        <trans-unit id="0f4bbc3721d99d879f2d29eca510835d82ca11bd" translate="yes" xml:space="preserve">
          <source>Legacy API function &lt;code&gt;send_pdu/7&lt;/code&gt; that has got separate &lt;code&gt;IpAddr&lt;/code&gt; and &lt;code&gt;PortNumber&lt;/code&gt; arguments still works as before for backwards compatibility reasons.</source>
          <target state="translated">個別の &lt;code&gt;IpAddr&lt;/code&gt; 引数と &lt;code&gt;PortNumber&lt;/code&gt; 引数を持つレガシーAPI関数 &lt;code&gt;send_pdu/7&lt;/code&gt; は、下位互換性の理由から以前と同様に機能します。</target>
        </trans-unit>
        <trans-unit id="a868752c2e0e19bf0913ba9d30f9f18839603e09" translate="yes" xml:space="preserve">
          <source>Legacy API functions &lt;code&gt;add_addr/10&lt;/code&gt; that does not specify transport domain, and &lt;code&gt;add_addr/11&lt;/code&gt; that has got separate &lt;code&gt;IpAddr&lt;/code&gt; and &lt;code&gt;PortNumber&lt;/code&gt; arguments still work as before for backwards compatibility reasons.</source>
          <target state="translated">トランスポートドメインを指定しないレガシーAPI関数 &lt;code&gt;add_addr/10&lt;/code&gt; 、および個別の &lt;code&gt;IpAddr&lt;/code&gt; 引数と &lt;code&gt;PortNumber&lt;/code&gt; 引数を持つ &lt;code&gt;add_addr/11&lt;/code&gt; は、下位互換性の理由から以前と同様に機能します。</target>
        </trans-unit>
        <trans-unit id="4486c03db98a7fec674973adef6214fc73ffdd8c" translate="yes" xml:space="preserve">
          <source>Legacy configurations using tuples without &lt;code&gt;Domain&lt;/code&gt; element, as well as with all &lt;code&gt;TDomain&lt;/code&gt;, &lt;code&gt;Ip&lt;/code&gt; and &lt;code&gt;Port&lt;/code&gt; elements still work.</source>
          <target state="translated">&lt;code&gt;Domain&lt;/code&gt; 要素を含まないタプルと、すべての &lt;code&gt;TDomain&lt;/code&gt; 、 &lt;code&gt;Ip&lt;/code&gt; 、および &lt;code&gt;Port&lt;/code&gt; 要素を含む従来の構成は、引き続き機能します。</target>
        </trans-unit>
        <trans-unit id="71367be8ed058ebcc73246ba1f97385975bee2e8" translate="yes" xml:space="preserve">
          <source>Legacy network interface filter modules used arguments on the form &lt;code&gt;(IpAddr, PortNumber,...)&lt;/code&gt; instead of &lt;code&gt;(Domain, Addr, ...)&lt;/code&gt;, and if the SNMP agent is run without changing the configuration to use transport domains the network interface filter will still get the old arguments and work as before.</source>
          <target state="translated">レガシーネットワークインターフェースフィルターモジュールは &lt;code&gt;(Domain, Addr, ...)&lt;/code&gt; ではなく &lt;code&gt;(IpAddr, PortNumber,...)&lt;/code&gt; の形式で引数を使用し、トランスポートドメインを使用するように構成を変更せずにSNMPエージェントが実行された場合、ネットワークインターフェースフィルター古い引数を取得し、以前と同様に機能します。</target>
        </trans-unit>
        <trans-unit id="0c7683d8adcfcd8643203d0f2de9c1dd2d464605" translate="yes" xml:space="preserve">
          <source>Legacy network interface filter modules used arguments on the form &lt;code&gt;(IpAddr, PortNumber,...)&lt;/code&gt; instead of &lt;code&gt;(Domain, Addr, ...)&lt;/code&gt;, and if the SNMP manager is run without changing the configuration to use transport domains the network interface filter will still get the old arguments and work as before.</source>
          <target state="translated">レガシーネットワークインターフェースフィルターモジュールは、 &lt;code&gt;(Domain, Addr, ...)&lt;/code&gt; ではなく &lt;code&gt;(IpAddr, PortNumber,...)&lt;/code&gt; の形式で引数を使用し、トランスポートドメインを使用するように構成を変更せずにSNMPマネージャーを実行した場合、ネットワークインターフェースフィルター古い引数を取得し、以前と同様に機能します。</target>
        </trans-unit>
        <trans-unit id="e898fde08048c9f9f4cb5920c5ef464a7652e35b" translate="yes" xml:space="preserve">
          <source>Legacy notification delivery information receiver modules used a target argument on the form &lt;code&gt;{IpAddr, PortNumber}&lt;/code&gt; instead of &lt;code&gt;{Domain, Addr}&lt;/code&gt;, and if the SNMP Agent is run without changing the configuration to use transport domains the notification delivery information receiver will still get the old arguments and work as before.</source>
          <target state="translated">従来の通知配信情報受信モジュールは、 &lt;code&gt;{Domain, Addr}&lt;/code&gt; ではなく &lt;code&gt;{IpAddr, PortNumber}&lt;/code&gt; 形式でターゲット引数を使用していました。トランスポートドメインを使用するように構成を変更せずにSNMPエージェントを実行した場合、通知配信情報受信モジュールは引き続き古い引数と以前のように動作します。</target>
        </trans-unit>
        <trans-unit id="018b204a37dd2a9505f340e2927d8d648c29228b" translate="yes" xml:space="preserve">
          <source>Legacy solutions may eventually need to be removed. In such cases, they will be phased out on a long enough time period to give users the time to adapt. Before removal of functionality it will be deprecated at least during one release with an explicit announcement about the upcoming removal. A new deprecation will at least be announced in a release note and the documentation.</source>
          <target state="translated">レガシーなソリューションは、最終的には削除する必要があるかもしれません。そのような場合には、ユーザーに適応するための時間を与えるために、十分に長い期間をかけて段階的に廃止されます。機能が削除される前に、少なくとも一つのリリースの間は、今後の削除についての明示的なアナウンスとともに非推奨とされます。新しい廃止予定は、少なくともリリースノートとドキュメントで発表されます。</target>
        </trans-unit>
        <trans-unit id="1773bd5f1b30eddc0d699c8591ba090a7523c655" translate="yes" xml:space="preserve">
          <source>Legacy string used in CGI, just ignore.</source>
          <target state="translated">CGIで使われているレガシー文字列は無視してください。</target>
        </trans-unit>
        <trans-unit id="625b83df9b71ae174e6f9e5f483d636b4e85f3a9" translate="yes" xml:space="preserve">
          <source>Len</source>
          <target state="translated">Len</target>
        </trans-unit>
        <trans-unit id="3bade34ecbc5d996b2f301ebd4ba689e81c7c9ea" translate="yes" xml:space="preserve">
          <source>Length</source>
          <target state="translated">Length</target>
        </trans-unit>
        <trans-unit id="169c8a5cbd42e1499cc493ecd3316ae82374f224" translate="yes" xml:space="preserve">
          <source>Length of a node name</source>
          <target state="translated">ノード名の長さ</target>
        </trans-unit>
        <trans-unit id="2932c65a2b38d62eb561a2ad9e13e95ab6d5d8aa" translate="yes" xml:space="preserve">
          <source>Lepcha</source>
          <target state="translated">Lepcha</target>
        </trans-unit>
        <trans-unit id="1d3d412a0852cc56c28ad0c2a1153229aa365b43" translate="yes" xml:space="preserve">
          <source>Less than</source>
          <target state="translated">未満</target>
        </trans-unit>
        <trans-unit id="33331a5bba7154831ad991e3d73f2368d8a52f4d" translate="yes" xml:space="preserve">
          <source>Less than or equal to</source>
          <target state="translated">以下</target>
        </trans-unit>
        <trans-unit id="d39f560b8c87e0c4b3a30cf39bb72967048838d1" translate="yes" xml:space="preserve">
          <source>Let &lt;code&gt;SetOfSets&lt;/code&gt; be a set of sets and &lt;code&gt;BinRel&lt;/code&gt; a binary relation. The function that maps each element &lt;code&gt;Set&lt;/code&gt; of &lt;code&gt;SetOfSets&lt;/code&gt; onto the &lt;code&gt;&lt;a href=&quot;#image&quot;&gt;image&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;Set&lt;/code&gt; under &lt;code&gt;BinRel&lt;/code&gt; is returned by the following function:</source>
          <target state="translated">してみましょう &lt;code&gt;SetOfSets&lt;/code&gt; がセットとのセットで &lt;code&gt;BinRel&lt;/code&gt; 二項関係。各要素にマッピング機能 &lt;code&gt;Set&lt;/code&gt; の &lt;code&gt;SetOfSets&lt;/code&gt; を上に &lt;code&gt;&lt;a href=&quot;#image&quot;&gt;image&lt;/a&gt;&lt;/code&gt; の &lt;code&gt;Set&lt;/code&gt; 下 &lt;code&gt;BinRel&lt;/code&gt; は、次の関数によって返されます。</target>
        </trans-unit>
        <trans-unit id="aeac5d618aebeec528fc023b1fd7a175e4c5012b" translate="yes" xml:space="preserve">
          <source>Let each process have two counters, &lt;code&gt;prev_cnt&lt;/code&gt; and &lt;code&gt;curr_cnt&lt;/code&gt;, both are set to &lt;code&gt;0&lt;/code&gt; when a process is created. The counters are updated at the following occasions:</source>
          <target state="translated">各プロセスに2つのカウンター &lt;code&gt;prev_cnt&lt;/code&gt; と &lt;code&gt;curr_cnt&lt;/code&gt; があるとします。プロセスが作成されると、どちらも &lt;code&gt;0&lt;/code&gt; に設定されます。カウンターは次の場合に更新されます。</target>
        </trans-unit>
        <trans-unit id="d42e517ccaad48e6627d644a84fd1a33bb06509e" translate="yes" xml:space="preserve">
          <source>Let the Megaco stack start the flex scanner (load the driver).</source>
          <target state="translated">Megacoスタックでフレックススキャナを起動させます(ドライバをロードします)。</target>
        </trans-unit>
        <trans-unit id="604be9425d1bfef18f4166b2d117691ea3dd6d24" translate="yes" xml:space="preserve">
          <source>Let the serial of the trace token be &lt;code&gt;tprev&lt;/code&gt; and &lt;code&gt;tcurr&lt;/code&gt;.</source>
          <target state="translated">トレーストークンのシリアルを &lt;code&gt;tprev&lt;/code&gt; および &lt;code&gt;tcurr&lt;/code&gt; とします。</target>
        </trans-unit>
        <trans-unit id="666a11ac8c95c51bf7258a4bd007f2a9fa01440e" translate="yes" xml:space="preserve">
          <source>Let this process start the flex scanner by calling the &lt;code&gt;megaco_flex_scanner:start/0,1&lt;/code&gt; function.</source>
          <target state="translated">このプロセスで、 &lt;code&gt;megaco_flex_scanner:start/0,1&lt;/code&gt; 関数を呼び出してflexスキャナーを開始します。</target>
        </trans-unit>
        <trans-unit id="def84ff207439fffb76419aef627ce0d25f81d91" translate="yes" xml:space="preserve">
          <source>Let us (again) print the temperatures in a list of cities:</source>
          <target state="translated">都市の一覧で温度を印刷してみましょう(再度)。</target>
        </trans-unit>
        <trans-unit id="c56d0e103691130e00273549b1e131c9fced0666" translate="yes" xml:space="preserve">
          <source>Let us assume there are two computers called gollum and kosken. First a node is started on kosken, called ping, and then a node on gollum, called pong.</source>
          <target state="translated">gollumとkoskenという二つのコンピュータがあるとしましょう。まず、kosken上でpingと呼ばれるノードが起動され、次にgollum上でpingと呼ばれるノードが起動されます。</target>
        </trans-unit>
        <trans-unit id="d58ae25061d9ff7638fc2f52191b818f3f601803" translate="yes" xml:space="preserve">
          <source>Let us continue down the printout to find:</source>
          <target state="translated">プリントアウトして探してみましょう。</target>
        </trans-unit>
        <trans-unit id="3dcdf9690d199e15a9324121e54d91e81837cbbc" translate="yes" xml:space="preserve">
          <source>Let us find the &lt;code&gt;suspend&lt;/code&gt; entry:</source>
          <target state="translated">&lt;code&gt;suspend&lt;/code&gt; エントリを見つけましょう：</target>
        </trans-unit>
        <trans-unit id="433bff1804e5bc582b9ad4a588bc980044f6d5b1" translate="yes" xml:space="preserve">
          <source>Let us first see how it is not to be done:</source>
          <target state="translated">まずは、どのようにしていけばいいのかを見ていきましょう。</target>
        </trans-unit>
        <trans-unit id="03868b7cc3939225f08fe8a6f0bab813a22248bc" translate="yes" xml:space="preserve">
          <source>Let us have a look at the printout after running:</source>
          <target state="translated">実行後のプリントアウトを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="b4247fbb47d2025ec5fd1d6f1ed8b2a618036da1" translate="yes" xml:space="preserve">
          <source>Let us jump straight into the deep end with an example using some interesting features.</source>
          <target state="translated">興味深い機能を使った例を挙げて、ディープエンドに真っ直ぐ飛び込んでみましょう。</target>
        </trans-unit>
        <trans-unit id="9d72140b7996b3301a9ebd333821b758ccc810f1" translate="yes" xml:space="preserve">
          <source>Let us now call:</source>
          <target state="translated">今すぐ電話してみましょう。</target>
        </trans-unit>
        <trans-unit id="340ab2a12c84a5de30c58279a2989702bffad374" translate="yes" xml:space="preserve">
          <source>Let us now define a fun that can be used to go through a list of cities and temperatures and transform them all to Celsius.</source>
          <target state="translated">今、私たちは都市と温度のリストを通過し、それらすべてを摂氏に変換するために使用することができます楽しみを定義してみましょう。</target>
        </trans-unit>
        <trans-unit id="64e5a143553594b38ecae6c7e33437d3a26bcb5c" translate="yes" xml:space="preserve">
          <source>Let us now get back to the test code:</source>
          <target state="translated">では、テストコードに戻りましょう。</target>
        </trans-unit>
        <trans-unit id="20fe5b908a76e9dd39847042c3de63708340328e" translate="yes" xml:space="preserve">
          <source>Let us now rewrite the ping pong example using this and give the name &lt;code&gt;pong&lt;/code&gt; to the &quot;pong&quot; process:</source>
          <target state="translated">これを使用してping pongの例を書き直し、「pong」プロセスに名前 &lt;code&gt;pong&lt;/code&gt; を付けます。</target>
        </trans-unit>
        <trans-unit id="85102cda9dfe19553fd35b6be3f95a64812d0b22" translate="yes" xml:space="preserve">
          <source>Let us return to the messenger program and add changes to make it more robust:</source>
          <target state="translated">メッセンジャープログラムに戻り、より堅牢なものにするために変更を加えてみましょう。</target>
        </trans-unit>
        <trans-unit id="1c6ef58bef398273a5e57030e28034688fd26a8c" translate="yes" xml:space="preserve">
          <source>Let us revisit the example in the beginning of the previous section:</source>
          <target state="translated">前節の冒頭の例を再確認してみましょう。</target>
        </trans-unit>
        <trans-unit id="8f258f141fde08f96558f8c38c9f4c0b345debcf" translate="yes" xml:space="preserve">
          <source>Let us rewrite the ping pong program with &quot;ping&quot; and &quot;pong&quot; on different computers. First a few things are needed to set up to get this to work. The distributed Erlang implementation provides a very basic authentication mechanism to prevent unintentional access to an Erlang system on another computer. Erlang systems which talk to each other must have the same &lt;strong&gt;magic cookie&lt;/strong&gt;. The easiest way to achieve this is by having a file called &lt;code&gt;.erlang.cookie&lt;/code&gt; in your home directory on all machines on which you are going to run Erlang systems communicating with each other:</source>
          <target state="translated">別のコンピューターで &quot;ping&quot;と &quot;pong&quot;を使用してピンポンプログラムを書き換えましょう。これを機能させるには、最初にいくつかの設定が必要です。分散Erlang実装は、別のコンピューター上のErlangシステムへの意図しないアクセスを防ぐための非常に基本的な認証メカニズムを提供します。互いに通信するErlangシステムは同じ&lt;strong&gt;マジックcookieを&lt;/strong&gt;持っている必要があります。これを実現する最も簡単な方法は、互いに通信するErlangシステムを実行するすべてのマシンのホームディレクトリに &lt;code&gt;.erlang.cookie&lt;/code&gt; というファイルを置くことです。</target>
        </trans-unit>
        <trans-unit id="cb9d01b09a7ede47f5da9307c84cc0ef18e349a1" translate="yes" xml:space="preserve">
          <source>Let us see what happens if something other than &lt;code&gt;centimeter&lt;/code&gt; or &lt;code&gt;inch&lt;/code&gt; is entered in the &lt;code&gt;convert&lt;/code&gt; function:</source>
          <target state="translated">&lt;code&gt;centimeter&lt;/code&gt; または &lt;code&gt;inch&lt;/code&gt; 以外のものを &lt;code&gt;convert&lt;/code&gt; 関数に入力するとどうなるか見てみましょう。</target>
        </trans-unit>
        <trans-unit id="825a5c292a02028fb1b75a606eb848534357aed7" translate="yes" xml:space="preserve">
          <source>Let us use the example database &lt;code&gt;Company&lt;/code&gt;, described in &lt;code&gt;&lt;a href=&quot;mnesia_chap2#getting_started&quot;&gt;Getting Started&lt;/a&gt;&lt;/code&gt; to illustrate how to run a database on two separate nodes, called &lt;code&gt;a@gin&lt;/code&gt; and &lt;code&gt;b@skeppet&lt;/code&gt;. Each of these nodes must have a &lt;code&gt;Mnesia&lt;/code&gt; directory and an initialized schema before &lt;code&gt;Mnesia&lt;/code&gt; can be started. There are two ways to specify the &lt;code&gt;Mnesia&lt;/code&gt; directory to be used:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;mnesia_chap2#getting_started&quot;&gt;Getting Started&lt;/a&gt;&lt;/code&gt; で説明したサンプルデータベース &lt;code&gt;Company&lt;/code&gt; を使用して、 &lt;code&gt;b@skeppet&lt;/code&gt; &lt;code&gt;a@gin&lt;/code&gt; とb @ skeppetと呼ばれる2つの別々のノードでデータベースを実行する方法を示します。これらのノードのそれぞれには、持っている必要があります &lt;code&gt;Mnesia&lt;/code&gt; の前に、ディレクトリと初期化されたスキーマを &lt;code&gt;Mnesia&lt;/code&gt; を開始することができます。使用する &lt;code&gt;Mnesia&lt;/code&gt; ディレクトリーを指定するには、2つの方法があります。</target>
        </trans-unit>
        <trans-unit id="d2e8bd71594ad75aa0208dcced0f635100f9212f" translate="yes" xml:space="preserve">
          <source>Let warnings about unknown functions and types affect the exit status of the command-line version. The default is to ignore warnings about unknown functions and types when setting the exit status. When using Dialyzer from Erlang, warnings about unknown functions and types are returned; the default is not to return these warnings.</source>
          <target state="translated">未知の関数や型に関する警告をコマンドライン版の終了状態に影響させます。デフォルトでは、未知の関数や型に関する警告を無視して終了ステータスを設定します。ErlangからDialyzerを使うと、未知の関数や型に関する警告が返されます。</target>
        </trans-unit>
        <trans-unit id="220abf90cd3cccafcb4011dbe84fa8ca749e8bcc" translate="yes" xml:space="preserve">
          <source>Lets all processes created by the traced process inherit the trace flags of the traced process.</source>
          <target state="translated">トレースされたプロセスによって作成されたすべてのプロセスに、トレースされたプロセスのトレースフラグを継承させます。</target>
        </trans-unit>
        <trans-unit id="d1d1fb9c4122f3954940623a46a59b2d039be292" translate="yes" xml:space="preserve">
          <source>Lets another process, &lt;code&gt;P2&lt;/code&gt;, inherit the trace flags of the traced process whenever the traced process links to &lt;code&gt;P2&lt;/code&gt;.</source>
          <target state="translated">別のプロセス &lt;code&gt;P2&lt;/code&gt; に、トレースされたプロセスが &lt;code&gt;P2&lt;/code&gt; にリンクするときは常に、トレースされたプロセスのトレースフラグを継承させます。</target>
        </trans-unit>
        <trans-unit id="3e218df5f51ddbb889cff43b1c4f13125f2c057d" translate="yes" xml:space="preserve">
          <source>Lets get into more detail:</source>
          <target state="translated">詳細を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="186c274226920125ed827b7634dba82da7689d77" translate="yes" xml:space="preserve">
          <source>Lets go then! We&amp;rsquo;ll start with a short version of the setup procedure, followed by some FAQ, and then we&amp;rsquo;ll go into more details of the setup.</source>
          <target state="translated">じゃあ、行きましょう！セットアップ手順の短いバージョンから始め、次にいくつかのFAQから始めて、セットアップの詳細について説明します。</target>
        </trans-unit>
        <trans-unit id="342dcf4caa3515593e70e5d37c040a7631a835d2" translate="yes" xml:space="preserve">
          <source>Lets this instance of &lt;code&gt;epmd&lt;/code&gt; listen only on the comma-separated list of IP addresses and on the loopback address (which is implicitly added to the list if it has not been specified). This can also be set using environment variable &lt;code&gt;ERL_EPMD_ADDRESS&lt;/code&gt;; see section &lt;code&gt;&lt;a href=&quot;#environment_variables&quot;&gt;Environment Variables&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;epmd&lt;/code&gt; のこのインスタンスが、IPアドレスのコンマ区切りのリストとループバックアドレス（指定されていない場合はリストに暗黙的に追加される）でのみリッスンできるようにします。これは、環境変数 &lt;code&gt;ERL_EPMD_ADDRESS&lt;/code&gt; を使用して設定することもできます。セクション &lt;code&gt;&lt;a href=&quot;#environment_variables&quot;&gt;Environment Variables&lt;/a&gt;&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="fe550a3140cf30c4543bf73300c3aa1bcbc8deb8" translate="yes" xml:space="preserve">
          <source>Lets this instance of &lt;code&gt;epmd&lt;/code&gt; listen to another TCP port than default 4369. This can also be set using environment variable &lt;code&gt;ERL_EPMD_PORT&lt;/code&gt;; see section &lt;code&gt;&lt;a href=&quot;#environment_variables&quot;&gt;Environment Variables&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;epmd&lt;/code&gt; のこのインスタンスに、デフォルトの4369以外のTCPポートをリッスンさせます。これは、環境変数 &lt;code&gt;ERL_EPMD_PORT&lt;/code&gt; を使用して設定することもできます。セクション &lt;code&gt;&lt;a href=&quot;#environment_variables&quot;&gt;Environment Variables&lt;/a&gt;&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="ee14050617b7b58e17aabccd61c241ccdafc6379" translate="yes" xml:space="preserve">
          <source>Letter</source>
          <target state="translated">Letter</target>
        </trans-unit>
        <trans-unit id="da5c93dba30bae6a81789ea350754c7db18d45fd" translate="yes" xml:space="preserve">
          <source>Letter number</source>
          <target state="translated">文字数</target>
        </trans-unit>
        <trans-unit id="6a37a6819c4ca3f372deb6f18b6c9a7263df9d68" translate="yes" xml:space="preserve">
          <source>Letters</source>
          <target state="translated">Letters</target>
        </trans-unit>
        <trans-unit id="8478fe30056611129de10e1dcb67a3cb5751c687" translate="yes" xml:space="preserve">
          <source>Letters and digits</source>
          <target state="translated">文字と数字</target>
        </trans-unit>
        <trans-unit id="5baaea6842aeb9d7041a377fa41f4a3c4ca67e64" translate="yes" xml:space="preserve">
          <source>Letters in the pattern match both uppercase and lowercase letters. It is equivalent to Perl option &lt;code&gt;/i&lt;/code&gt; and can be changed within a pattern by a &lt;code&gt;(?i)&lt;/code&gt; option setting. Uppercase and lowercase letters are defined as in the ISO 8859-1 character set.</source>
          <target state="translated">パターン内の文字は大文字と小文字の両方に一致します。これはPerlオプション &lt;code&gt;/i&lt;/code&gt; と同等で、 &lt;code&gt;(?i)&lt;/code&gt; オプション設定によってパターン内で変更できます。大文字と小文字は、ISO 8859-1文字セットと同様に定義されます。</target>
        </trans-unit>
        <trans-unit id="9f098a06328a86780258bc88ff74fbf46806b289" translate="yes" xml:space="preserve">
          <source>Level 1: Function headers, reserved words, comments, strings, quoted atoms, and character constants will be colored.</source>
          <target state="translated">レベル 1:関数ヘッダ、予約語、コメント、文字列、引用符で囲まれたアトム、文字定数に色が付けられます。</target>
        </trans-unit>
        <trans-unit id="f28c43e4d336432c51e7d6f7ae8f272e7480311b" translate="yes" xml:space="preserve">
          <source>Level 2: The above, attributes, Erlang bif:s, guards, and words in comments enclosed in single quotes will be colored.</source>
          <target state="translated">レベル2:上記、属性、Erlangのbif:s、ガード、シングルクォートで囲まれたコメントの単語に色が付きます。</target>
        </trans-unit>
        <trans-unit id="765716d33c6ea85319738caae1b33005b2662242" translate="yes" xml:space="preserve">
          <source>Level 3: The above, variables, records, and macros will be colored. (This level is also known as the Christmas tree level.)</source>
          <target state="translated">レベル3:上記、変数、レコード、マクロに色が付きます。(このレベルはクリスマスツリーレベルとも呼ばれています)。</target>
        </trans-unit>
        <trans-unit id="2bf81bf1cb8b7d9b8d3236953ea28aa39a5a5e01" translate="yes" xml:space="preserve">
          <source>Lexical analyzer generator for Erlang</source>
          <target state="translated">Erlang用の語彙解析ジェネレータ</target>
        </trans-unit>
        <trans-unit id="27c968e6692b41bf6e1a241b870dc41ff1a51b17" translate="yes" xml:space="preserve">
          <source>Libraries</source>
          <target state="translated">Libraries</target>
        </trans-unit>
        <trans-unit id="b82b017d183339186ab0d2b0c5a5bfec8823103f" translate="yes" xml:space="preserve">
          <source>Library directories can be added, edited or deleted. This is done by selecting the line where the path to a library directory is displayed and clicking the right mouse button. Choose add, edit or delete in the menu that pops up. New library directories can also be added by selecting the line &lt;code&gt;Library directories&lt;/code&gt; and clicking the right mouse button. Choose add in the menu that pops up.</source>
          <target state="translated">ライブラリディレクトリは、追加、編集、または削除できます。これを行うには、ライブラリディレクトリへのパスが表示されている行を選択し、マウスの右ボタンをクリックします。ポップアップメニューで[追加]、[編集]、または[削除]を選択します。新しいライブラリディレクトリを追加するには、[ &lt;code&gt;Library directories&lt;/code&gt; ] 行を選択し、マウスの右ボタンをクリックします。ポップアップメニューで[追加]を選択します。</target>
        </trans-unit>
        <trans-unit id="2978f0a9a49c8c42789bf952364d24d1a5dbe46b" translate="yes" xml:space="preserve">
          <source>Library for handling binary data</source>
          <target state="translated">バイナリデータを扱うためのライブラリ</target>
        </trans-unit>
        <trans-unit id="52399314911c08c3e5bf65cd9f9343b51490ef6c" translate="yes" xml:space="preserve">
          <source>Library for handling binary data.</source>
          <target state="translated">バイナリデータを扱うためのライブラリ。</target>
        </trans-unit>
        <trans-unit id="89d3a3ca0e1508a43064d7c5bc51385a80966d5e" translate="yes" xml:space="preserve">
          <source>Library module - skeleton for a module that does not implement a process.</source>
          <target state="translated">ライブラリモジュール-プロセスを実装しないモジュールのスケルトン。</target>
        </trans-unit>
        <trans-unit id="ec793eb7fd1d6c9106d97e622f4fcbf89e666960" translate="yes" xml:space="preserve">
          <source>Licensed under the Apache License, Version 2.0.</source>
          <target state="translated">Apache License,Version 2.0の下でライセンスされています。</target>
        </trans-unit>
        <trans-unit id="63a3f94f87240d18e2608ac8e3fea63c89e207c2" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;#&lt;/code&gt;, but prints lowercase letters.</source>
          <target state="translated">&lt;code&gt;#&lt;/code&gt; に似ていますが、小文字を出力します。</target>
        </trans-unit>
        <trans-unit id="cc569b0959c426468676c9f9e2878439fb241769" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;#foldl-3&quot;&gt;foldl/3&lt;/a&gt;&lt;/code&gt;, but the list is traversed from right to left.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#foldl-3&quot;&gt;foldl/3&lt;/a&gt;&lt;/code&gt; と似ていますが、リストは右から左にトラバースされます。</target>
        </trans-unit>
        <trans-unit id="51f15f4f7ca9cb7875094377777336299eb89bba" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;#inflate-2&quot;&gt;inflate/2&lt;/a&gt;&lt;/code&gt;, but decompresses no more data than will fit in the buffer configured through &lt;code&gt;&lt;a href=&quot;#setBufSize-2&quot;&gt;setBufSize/2&lt;/a&gt;&lt;/code&gt;. Is is useful when decompressing a stream with a high compression ratio, such that a small amount of compressed input can expand up to 1000 times.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#inflate-2&quot;&gt;inflate/2&lt;/a&gt;&lt;/code&gt; と同様ですが、 &lt;code&gt;&lt;a href=&quot;#setBufSize-2&quot;&gt;setBufSize/2&lt;/a&gt;&lt;/code&gt; で構成されたバッファに収まるだけのデータを解凍します。これは、圧縮率が高いストリームを圧縮解除する場合に役立ちます。これにより、少量の圧縮入力が最大1000倍に拡張できます。</target>
        </trans-unit>
        <trans-unit id="72ba4cf8d1bc4075b239ef3e59d00ec710769e5d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;#inflate-2&quot;&gt;inflate/2&lt;/a&gt;&lt;/code&gt;, but returns once it has expanded beyond a small implementation-defined threshold. It's useful when decompressing untrusted input which could have been maliciously crafted to expand until the system runs out of memory.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#inflate-2&quot;&gt;inflate/2&lt;/a&gt;&lt;/code&gt; と似ていますが、実装で定義された小さなしきい値を超えて拡張すると戻ります。これは、システムがメモリ不足になるまで拡張するために悪意を持って作成された可能性がある信頼できない入力を解凍するときに役立ちます。</target>
        </trans-unit>
        <trans-unit id="daf13adcbfffff9ed7affc2828dc952bc760e47b" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;#recomment_forms-2&quot;&gt;recomment_forms/2&lt;/a&gt;&lt;/code&gt;, but only inserts top-level comments. Comments within function definitions or declarations (&quot;forms&quot;) are simply ignored.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#recomment_forms-2&quot;&gt;recomment_forms/2&lt;/a&gt;&lt;/code&gt; と似ていますが、トップレベルのコメントのみを挿入します。関数定義または宣言（「フォーム」）内のコメントは単に無視されます。</target>
        </trans-unit>
        <trans-unit id="ef3750efd41bd9e594039bac37ecfb9248994272" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;@custom_types&lt;/code&gt; but requires the specified module to export &lt;code&gt;Mod:Type(encode|decode, Name, Data, Opts)&lt;/code&gt; rather than &lt;code&gt;Mod:Name(encode|decode, Type, Data, Opts)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;@custom_types&lt;/code&gt; と同様ですが、 &lt;code&gt;Mod:Name(encode|decode, Type, Data, Opts)&lt;/code&gt; ではなく &lt;code&gt;Mod:Type(encode|decode, Name, Data, Opts)&lt;/code&gt; をエクスポートするために指定されたモジュールが必要です。</target>
        </trans-unit>
        <trans-unit id="bea99210fbf7c6bed65f860ca599cb796325b2c8" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;B&lt;/code&gt;, but prints lowercase letters.</source>
          <target state="translated">&lt;code&gt;B&lt;/code&gt; に似ていますが、小文字を出力します。</target>
        </trans-unit>
        <trans-unit id="86bbc734cf44d78a7649fa34a75e3f3c896f4e5d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;B&lt;/code&gt;, but prints the number with an Erlang style &lt;code&gt;#&lt;/code&gt;-separated base prefix. Example:</source>
          <target state="translated">&lt;code&gt;B&lt;/code&gt; と似ていますが、Erlangスタイルの &lt;code&gt;#&lt;/code&gt; で区切られたベースプレフィックスを付けて数値を出力します。例：</target>
        </trans-unit>
        <trans-unit id="f477e728585a752129db4fe6acfe44591222b305" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;B&lt;/code&gt;, but takes an extra argument that is a prefix to insert before the number, but after the leading dash, if any.</source>
          <target state="translated">&lt;code&gt;B&lt;/code&gt; と同様ですが、番号の前に挿入する接頭辞である追加の引数を取りますが、先頭のダッシュがある場合はその後ろに追加します。</target>
        </trans-unit>
        <trans-unit id="acd1912727bbe585b5be18af1470d511bb1bbc67" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;X&lt;/code&gt;, but prints lowercase letters.</source>
          <target state="translated">&lt;code&gt;X&lt;/code&gt; に似ていますが、小文字を出力します。</target>
        </trans-unit>
        <trans-unit id="966ec3b06ee878fd6f57e5784bed91178bcad7fe" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;any&lt;/code&gt;, but stops at the first filter for which there are matches, which can be much more efficient when there are many peers. For example, the following filter causes only peers best matching both the host and realm filters to be presented.</source>
          <target state="translated">同様に &lt;code&gt;any&lt;/code&gt; が、最初のフィルタで停止しているため、多くのピアが存在する場合にはるかに効率的にできる試合があります。たとえば、次のフィルターでは、ホストフィルターとレルムフィルターの両方に最も一致するピアのみが表示されます。</target>
        </trans-unit>
        <trans-unit id="d6e3635c0afce60dac176c677944b2628acbcc53" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;debugVal(Expr)&lt;/code&gt;, but prints terms truncated to the given depth.</source>
          <target state="translated">&lt;code&gt;debugVal(Expr)&lt;/code&gt; と同様ですが、指定された深さに切り捨てられた用語を出力します。</target>
        </trans-unit>
        <trans-unit id="63ad390555fcf8137ccbbb94972b3652ab59df2d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;lists:foldl/3&lt;/code&gt;, but over a list of lists.</source>
          <target state="translated">&lt;code&gt;lists:foldl/3&lt;/code&gt; と似ていますが、リストのリストに対してです。</target>
        </trans-unit>
        <trans-unit id="00d879ac0be1e80dff2fcb522c1f308589442773" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;lists:mapfoldl/3&lt;/code&gt;, but over a list of lists. The list of lists in the result has the same structure as the given list of lists.</source>
          <target state="translated">&lt;code&gt;lists:mapfoldl/3&lt;/code&gt; と似ていますが、リストのリストに対してです。結果のリストのリストは、指定されたリストのリストと同じ構造です。</target>
        </trans-unit>
        <trans-unit id="ab237642580896dc26c686d01f6e5d1e47eb40a7" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;new_variable_name/1&lt;/code&gt;, but generates a list of &lt;code&gt;N&lt;/code&gt; new names.</source>
          <target state="translated">&lt;code&gt;new_variable_name/1&lt;/code&gt; と似ていますが、 &lt;code&gt;N&lt;/code&gt; 個の新しい名前のリストを生成します。</target>
        </trans-unit>
        <trans-unit id="faf0ff6789ba28d95ff3dae1292daf1cffb72f1a" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;new_variable_name/2&lt;/code&gt;, but generates a list of &lt;code&gt;N&lt;/code&gt; new names.</source>
          <target state="translated">&lt;code&gt;new_variable_name/2&lt;/code&gt; と似ていますが、 &lt;code&gt;N&lt;/code&gt; 個の新しい名前のリストを生成します。</target>
        </trans-unit>
        <trans-unit id="2dd37c4c8489c1b03eaf8a9be802ae7519cf2c9e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;notempty&lt;/code&gt;, except that an empty string match that is not at the start of the subject is permitted. If the pattern is anchored, such a match can occur only if the pattern contains \K.</source>
          <target state="translated">&lt;code&gt;notempty&lt;/code&gt; と同様ですが、件名の先頭にない空の文字列の一致が許可されます。パターンがアンカーされている場合、そのような一致は、パターンに\ Kが含まれている場合にのみ発生します。</target>
        </trans-unit>
        <trans-unit id="ea19d16016f4ba065add2108a05c41562006761a" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;{inparallel, Tests}&lt;/code&gt;, but running no more than &lt;code&gt;N&lt;/code&gt; subtests simultaneously.</source>
          <target state="translated">&lt;code&gt;{inparallel, Tests}&lt;/code&gt; と同様ですが、同時に実行するサブテストは &lt;code&gt;N&lt;/code&gt; 以下です。</target>
        </trans-unit>
        <trans-unit id="86d23c0727a7f28841a9680a28cb323bba5bd6b1" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;{spawn, Tests}&lt;/code&gt;, but runs the specified tests on the given Erlang node.</source>
          <target state="translated">&lt;code&gt;{spawn, Tests}&lt;/code&gt; と同様ですが、指定されたErlangノードで指定されたテストを実行します。</target>
        </trans-unit>
        <trans-unit id="28c07f5f1815e2f3156834cae0b135871e7deefe" translate="yes" xml:space="preserve">
          <source>Like a port program, the port communicates with an Erlang process. All communication goes through one Erlang process that is the &lt;strong&gt;connected process&lt;/strong&gt; of the port driver. Terminating this process closes the port driver.</source>
          <target state="translated">ポートプログラムのように、ポートはErlangプロセスと通信します。すべての通信は、ポートドライバーの&lt;strong&gt;接続されたプロセス&lt;/strong&gt;である1つのErlangプロセスを経由します。このプロセスを終了すると、ポートドライバーが閉じます。</target>
        </trans-unit>
        <trans-unit id="fb6947e8ac5f224ed9054599317fddd5d554df94" translate="yes" xml:space="preserve">
          <source>Like most &lt;code&gt;gen_&lt;/code&gt; behaviors, &lt;code&gt;gen_statem&lt;/code&gt; keeps a server &lt;code&gt;Data&lt;/code&gt; besides the state. Because of this, and as there is no restriction on the number of states (assuming that there is enough virtual machine memory) or on the number of distinct input events, a state machine implemented with this behavior is in fact Turing complete. But it feels mostly like an Event-Driven Mealy machine.</source>
          <target state="translated">ほとんどの &lt;code&gt;gen_&lt;/code&gt; 動作と同様に、 &lt;code&gt;gen_statem&lt;/code&gt; は状態のほかにサーバー &lt;code&gt;Data&lt;/code&gt; 保持します。このため、状態の数（十分な仮想マシンメモリがあることを前提とする）または個別の入力イベントの数に制限がないため、この動作で実装された状態マシンは実際にはチューリング完了です。しかし、それは主にイベント駆動型のMealyマシンのように感じられます。</target>
        </trans-unit>
        <trans-unit id="2d2a1cf01f82cc870ddfbc6074784aafada5af53" translate="yes" xml:space="preserve">
          <source>Like subst/2, but does not convert the result from a template back to a tree. Useful if you want to do multiple separate substitutions.</source>
          <target state="translated">subst/2と似ていますが、結果をテンプレートからツリーに変換することはありません。複数の別々の置換を行いたい場合に便利です。</target>
        </trans-unit>
        <trans-unit id="9fb2ece1519e605cddcd4c31f14bfc8330a5db16" translate="yes" xml:space="preserve">
          <source>Like the &lt;code&gt;assertCmd(CommandString)&lt;/code&gt; macro, but generates an exception unless the returned status value is &lt;code&gt;N&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;assertCmd(CommandString)&lt;/code&gt; マクロと同様ですが、返されるステータス値が &lt;code&gt;N&lt;/code&gt; でない限り、例外を生成します。</target>
        </trans-unit>
        <trans-unit id="b09308bcf178ae8be921fdbc2b93c7b533bf2b3a" translate="yes" xml:space="preserve">
          <source>Like the above, if you must remain USTAR compatible, you must also ensure than paths for symbolic/hard links are no more than 100 bytes, otherwise PAX headers will be used.</source>
          <target state="translated">上記のように、もし USTAR との互換性を維持しなければならない場合は、シンボリック/ハードリンクのパスが 100 バイト以下であることを確認しなければなりません。</target>
        </trans-unit>
        <trans-unit id="b7ca39f6a507f719e0c2ad1d78b58767ce4db68c" translate="yes" xml:space="preserve">
          <source>Likewise, a registry can be restored from a &lt;code&gt;Mnesia&lt;/code&gt; table:</source>
          <target state="translated">同様に、レジストリは &lt;code&gt;Mnesia&lt;/code&gt; テーブルから復元できます。</target>
        </trans-unit>
        <trans-unit id="0be788e5cd03f159b54ca8ea573d4290d5478fb0" translate="yes" xml:space="preserve">
          <source>Limbu</source>
          <target state="translated">Limbu</target>
        </trans-unit>
        <trans-unit id="78dc3a4fccf65f244492a69b7620630ce0e9464d" translate="yes" xml:space="preserve">
          <source>Limitations: Command string &lt;code&gt;Cmd&lt;/code&gt; is sent to the &lt;code&gt;heart&lt;/code&gt; program as an ISO Latin-1 or UTF-8 encoded binary, depending on the filename encoding mode of the emulator (see &lt;code&gt;file:native_name_encoding/0&lt;/code&gt;). The size of the encoded binary must be less than 2047 bytes.</source>
          <target state="translated">制限：コマンド文字列 &lt;code&gt;Cmd&lt;/code&gt; は、エミュレータのファイル名エンコードモードに応じて、ISO Latin-1またはUTF-8エンコードバイナリとして &lt;code&gt;heart&lt;/code&gt; プログラムに送信されます（ &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; を参照）。エンコードされたバイナリのサイズは2047バイト未満でなければなりません。</target>
        </trans-unit>
        <trans-unit id="a5b6119a0e42de01e03b6e7576246105dd031f3e" translate="yes" xml:space="preserve">
          <source>Limits &lt;code&gt;run/3&lt;/code&gt; to matching at the first matching position. If a pattern was compiled with &lt;code&gt;anchored&lt;/code&gt;, or turned out to be anchored by virtue of its contents, it cannot be made unanchored at matching time, hence there is no &lt;code&gt;unanchored&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;run/3&lt;/code&gt; 制限/ 3を最初の一致位置での一致に。パターンがanchoredを使用 &lt;code&gt;anchored&lt;/code&gt; コンパイルされた場合、またはその内容によってアンカーされたことが判明した場合、一致時にアンカー解除することができないため、アンカー &lt;code&gt;unanchored&lt;/code&gt; オプションはありません。</target>
        </trans-unit>
        <trans-unit id="53fd0a56aa60d6229d9774fb5d18054514021f8a" translate="yes" xml:space="preserve">
          <source>Limits a syntax tree to a specified depth. Replaces all non-leaf subtrees in &lt;code&gt;Tree&lt;/code&gt; at the given &lt;code&gt;Depth&lt;/code&gt; by &lt;code&gt;Node&lt;/code&gt;. If &lt;code&gt;Depth&lt;/code&gt; is negative, the result is always &lt;code&gt;Node&lt;/code&gt;, even if &lt;code&gt;Tree&lt;/code&gt; has no subtrees.</source>
          <target state="translated">構文ツリーを指定した深さに制限します。指定 &lt;code&gt;Depth&lt;/code&gt; れた深度の &lt;code&gt;Node&lt;/code&gt; にある &lt;code&gt;Tree&lt;/code&gt; 内のすべての非リーフサブツリーを置き換えます。 &lt;code&gt;Depth&lt;/code&gt; 場合負の場合、結果は常にある &lt;code&gt;Node&lt;/code&gt; 場合でも、 &lt;code&gt;Tree&lt;/code&gt; 何のサブツリーを持っていません。</target>
        </trans-unit>
        <trans-unit id="0f3cee9699c8974707e0009cafd9488a7e87e54c" translate="yes" xml:space="preserve">
          <source>Limits the execution time and memory consumption of a match in an implementation-specific way, very similar to &lt;code&gt;match_limit&lt;/code&gt;. It is described as follows by the PCRE documentation:</source>
          <target state="translated">&lt;code&gt;match_limit&lt;/code&gt; とよく似た、実装固有の方法で一致の実行時間とメモリ消費を制限します。PCREのドキュメントでは次のように説明されています。</target>
        </trans-unit>
        <trans-unit id="57e9ccbfc052c9f575272edd40f6b4a2a0bc74b7" translate="yes" xml:space="preserve">
          <source>Limits the execution time of a match in an implementation-specific way. It is described as follows by the PCRE documentation:</source>
          <target state="translated">実装固有の方法でマッチの実行時間を制限します。PCREのドキュメントでは以下のように説明されています。</target>
        </trans-unit>
        <trans-unit id="ebcb72346cc3142860ab9dce9c83e330a9b27032" translate="yes" xml:space="preserve">
          <source>Limits the number of reader groups used by read/write locks optimized for read operations in the Erlang runtime system. By default the reader groups limit is 64.</source>
          <target state="translated">Erlangランタイムシステムの読み込み操作に最適化された読み込み/書き込みロックで使われるリーダーグループの数を制限します。デフォルトではリーダグループの数は64です。</target>
        </trans-unit>
        <trans-unit id="1aaddcb6d1d303241ab23ee03c9e955d5813903a" translate="yes" xml:space="preserve">
          <source>Limits the number of simultaneous requests that can be supported. Default is &lt;code&gt;150&lt;/code&gt;.</source>
          <target state="translated">サポートできる同時リクエストの数を制限します。デフォルトは &lt;code&gt;150&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="ac5a291f0f9cb7077ef57a417ad04c2cde809e26" translate="yes" xml:space="preserve">
          <source>Limits the size of the HTTP request URI. Default is no limit.</source>
          <target state="translated">HTTP リクエスト URI のサイズを制限します。デフォルトは制限なし。</target>
        </trans-unit>
        <trans-unit id="01a54436655ccd4292a34867e24b94c649a6a7ef" translate="yes" xml:space="preserve">
          <source>Limits the size of the message body of an HTTP request. Default is no limit.</source>
          <target state="translated">HTTP リクエストのメッセージボディのサイズを制限します。デフォルトは制限なしです。</target>
        </trans-unit>
        <trans-unit id="f796a3375835935727b47e015cbce66aad2dfb2d" translate="yes" xml:space="preserve">
          <source>Limits the size of the message header of an HTTP request. Default is &lt;code&gt;10240&lt;/code&gt;.</source>
          <target state="translated">HTTPリクエストのメッセージヘッダーのサイズを制限します。デフォルトは &lt;code&gt;10240&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="3e89b80d9719e747b2760364410364b02949de43" translate="yes" xml:space="preserve">
          <source>Limits what a client can ask for in diffie-hellman-group-exchange. The limits will be &lt;code&gt;{MaxUsed = min(MaxClient,Max), MinUsed = max(MinClient,Min)}&lt;/code&gt; where &lt;code&gt;MaxClient&lt;/code&gt; and &lt;code&gt;MinClient&lt;/code&gt; are the values proposed by a connecting client.</source>
          <target state="translated">クライアントがdiffie-hellman-group-exchangeで要求できるものを制限します。制限は &lt;code&gt;{MaxUsed = min(MaxClient,Max), MinUsed = max(MinClient,Min)}&lt;/code&gt; ここで、 &lt;code&gt;MaxClient&lt;/code&gt; と &lt;code&gt;MinClient&lt;/code&gt; が接続するクライアントによって提案された値です。</target>
        </trans-unit>
        <trans-unit id="d606cdf694a134035f6374a74898f3c5d7314e3c" translate="yes" xml:space="preserve">
          <source>Line 1 (marked with the &lt;code&gt;%% 1&lt;/code&gt; comment), assigns a &lt;code&gt;&lt;a href=&quot;#heap_binary&quot;&gt;heap binary&lt;/a&gt;&lt;/code&gt; to the &lt;code&gt;Bin0&lt;/code&gt; variable.</source>
          <target state="translated">1行目（ &lt;code&gt;%% 1&lt;/code&gt; コメントでマークされてい &lt;code&gt;&lt;a href=&quot;#heap_binary&quot;&gt;heap binary&lt;/a&gt;&lt;/code&gt; ）は、ヒープバイナリを &lt;code&gt;Bin0&lt;/code&gt; 変数にます。</target>
        </trans-unit>
        <trans-unit id="3a12079f3d22a373811b1791c48232229546d37f" translate="yes" xml:space="preserve">
          <source>Line 2 is an append operation. As &lt;code&gt;Bin0&lt;/code&gt; has not been involved in an append operation, a new &lt;code&gt;&lt;a href=&quot;#refc_binary&quot;&gt;refc binary&lt;/a&gt;&lt;/code&gt; is created and the contents of &lt;code&gt;Bin0&lt;/code&gt; is copied into it. The &lt;strong&gt;ProcBin&lt;/strong&gt; part of the refc binary has its size set to the size of the data stored in the binary, while the binary object has extra space allocated. The size of the binary object is either twice the size of &lt;code&gt;Bin1&lt;/code&gt; or 256, whichever is larger. In this case it is 256.</source>
          <target state="translated">2行目は追加操作です。以下のよう &lt;code&gt;Bin0&lt;/code&gt; アペンド操作に関与していない、新しい &lt;code&gt;&lt;a href=&quot;#refc_binary&quot;&gt;refc binary&lt;/a&gt;&lt;/code&gt; 作成され、内容 &lt;code&gt;Bin0&lt;/code&gt; それにコピーされます。refcバイナリの&lt;strong&gt;ProcBin&lt;/strong&gt;部分のサイズは、バイナリに格納されているデータのサイズに設定されていますが、バイナリオブジェクトには追加のスペースが割り当てられています。バイナリオブジェクトのサイズは、 &lt;code&gt;Bin1&lt;/code&gt; のサイズの2倍または256のいずれか大きい方です。この場合は256です。</target>
        </trans-unit>
        <trans-unit id="78a9183f7481a61745aa9568c7ccc4c6a4279b91" translate="yes" xml:space="preserve">
          <source>Line 3 is more interesting. &lt;code&gt;Bin1&lt;/code&gt;&lt;strong&gt;has&lt;/strong&gt; been used in an append operation, and it has 252 bytes of unused storage at the end, so the 3 new bytes are stored there.</source>
          <target state="translated">3行目はもっと面白いです。 &lt;code&gt;Bin1&lt;/code&gt; &lt;strong&gt;は&lt;/strong&gt;追加操作で使用され&lt;strong&gt;て&lt;/strong&gt;おり、最後に252バイトの未使用のストレージがあるため、新しい3バイトがそこに格納されます。</target>
        </trans-unit>
        <trans-unit id="606f836f0aef9364290324174a1660f8412d88a6" translate="yes" xml:space="preserve">
          <source>Line 4. The same applies here. There are 249 bytes left, so there is no problem storing another 3 bytes.</source>
          <target state="translated">4行目です。ここも同様です。249バイト残っているので、あと3バイト貯めても問題ありません。</target>
        </trans-unit>
        <trans-unit id="a181978e790a24533adac43665a7c3bfc9494742" translate="yes" xml:space="preserve">
          <source>Line 5. Here, something &lt;strong&gt;interesting&lt;/strong&gt; happens. Notice that the result is not appended to the previous result in &lt;code&gt;Bin3&lt;/code&gt;, but to &lt;code&gt;Bin1&lt;/code&gt;. It is expected that &lt;code&gt;Bin4&lt;/code&gt; will be assigned the value &lt;code&gt;&amp;lt;&amp;lt;0,1,2,3,17&amp;gt;&amp;gt;&lt;/code&gt;. It is also expected that &lt;code&gt;Bin3&lt;/code&gt; will retain its value (&lt;code&gt;&amp;lt;&amp;lt;0,1,2,3,4,5,6,7,8,9&amp;gt;&amp;gt;&lt;/code&gt;). Clearly, the runtime system cannot write byte &lt;code&gt;17&lt;/code&gt; into the binary, because that would change the value of &lt;code&gt;Bin3&lt;/code&gt; to &lt;code&gt;&amp;lt;&amp;lt;0,1,2,3,4,17,6,7,8,9&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">5行目。ここで&lt;strong&gt;興味深い&lt;/strong&gt;ことが起こります。結果が &lt;code&gt;Bin3&lt;/code&gt; の前の結果に追加されるのではなく、Bin1に追加されることに注意して &lt;code&gt;Bin1&lt;/code&gt; 。 &lt;code&gt;Bin4&lt;/code&gt; には値 &lt;code&gt;&amp;lt;&amp;lt;0,1,2,3,17&amp;gt;&amp;gt;&lt;/code&gt; が割り当てられることが期待されています。 &lt;code&gt;Bin3&lt;/code&gt; がその値を保持することも予想されます（ &lt;code&gt;&amp;lt;&amp;lt;0,1,2,3,4,5,6,7,8,9&amp;gt;&amp;gt;&lt;/code&gt; ）。明らかに、ランタイムシステムは &lt;code&gt;Bin3&lt;/code&gt; の値を &lt;code&gt;&amp;lt;&amp;lt;0,1,2,3,4,17,6,7,8,9&amp;gt;&amp;gt;&lt;/code&gt; 変更するため、バイナリにバイト &lt;code&gt;17&lt;/code&gt; を書き込むことができません。</target>
        </trans-unit>
        <trans-unit id="4f23e2d073d67acea8f123b42f84af035e27248d" translate="yes" xml:space="preserve">
          <source>Line feed</source>
          <target state="translated">ラインフィード</target>
        </trans-unit>
        <trans-unit id="d6baf0500add79d50ac3b7f3a8db7d105c624d52" translate="yes" xml:space="preserve">
          <source>Line feed (LF)</source>
          <target state="translated">ラインフィード(LF)</target>
        </trans-unit>
        <trans-unit id="6e6281f3f812eba8375c5e757b0a8cfcb28090b9" translate="yes" xml:space="preserve">
          <source>Line feed (hex 0A)</source>
          <target state="translated">ラインフィード(16進0A)</target>
        </trans-unit>
        <trans-unit id="815507f47a2606910a0fd0cc8b7e5b87462f8246" translate="yes" xml:space="preserve">
          <source>Line separator</source>
          <target state="translated">ラインセパレータ</target>
        </trans-unit>
        <trans-unit id="2af7c8c92e94fc7eb6a6c63fb1ff0bce5d9c019f" translate="yes" xml:space="preserve">
          <source>LineOp ::= &lt;code&gt;Lin&lt;/code&gt; | &lt;code&gt;ELin&lt;/code&gt; | &lt;code&gt;LLin&lt;/code&gt; | &lt;code&gt;XLin&lt;/code&gt;</source>
          <target state="translated">LineOp :: = &lt;code&gt;Lin&lt;/code&gt; | &lt;code&gt;ELin&lt;/code&gt; | &lt;code&gt;LLin&lt;/code&gt; | &lt;code&gt;XLin&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="96dcf318665fa36d70418026a3b6579ba1d37485" translate="yes" xml:space="preserve">
          <source>Linear_A</source>
          <target state="translated">Linear_A</target>
        </trans-unit>
        <trans-unit id="3835d6a4986ea73e86742e9a7f3ef9b58c7dcb04" translate="yes" xml:space="preserve">
          <source>Linear_B</source>
          <target state="translated">Linear_B</target>
        </trans-unit>
        <trans-unit id="d6c98026fbce4e93112774eec40362b0a7aed1ad" translate="yes" xml:space="preserve">
          <source>Lines containing comment are indented differently depending on the number of %-characters used:</source>
          <target state="translated">コメントを含む行は、使用する%文字数によってインデントが異なります。</target>
        </trans-unit>
        <trans-unit id="6020dbe4b85aaddb67863706a7bfa44b4279c255" translate="yes" xml:space="preserve">
          <source>Lines with one %-character is indented to the right of the code. The column is specified by the variable &lt;code&gt;comment-column&lt;/code&gt;, by default column 48 is used.</source>
          <target state="translated">％文字が1つある行は、コードの右側でインデントされます。列は変数 &lt;code&gt;comment-column&lt;/code&gt; で指定され、デフォルトでは48列目が使用されます。</target>
        </trans-unit>
        <trans-unit id="09bc4e361a8d125ebf0a75e49099df74d6c93932" translate="yes" xml:space="preserve">
          <source>Lines with three of more %-characters are indented to the left margin.</source>
          <target state="translated">3つ以上の%文字を含む行は、左マージンにインデントされます。</target>
        </trans-unit>
        <trans-unit id="23c934b9a137cdcf80996b7f149382ca3a18710d" translate="yes" xml:space="preserve">
          <source>Lines with two %-characters will be indented to the same depth as code would have been in the same situation.</source>
          <target state="translated">2つの%文字を含む行は、同じ状況でのコードと同じ深さにインデントされます。</target>
        </trans-unit>
        <trans-unit id="9e5bc846e2abf74c493c5775ca18f25f00253f12" translate="yes" xml:space="preserve">
          <source>Linked-in drivers involves writing certain call-back functions in C. This requires very good skills as the code is linked to the Erlang runtime system.</source>
          <target state="translated">リンクトインドライバでは、C言語で特定のコールバック関数を書くことになります。</target>
        </trans-unit>
        <trans-unit id="4767dee426c55691e7ec704688dd7011fdf6e6c1" translate="yes" xml:space="preserve">
          <source>Linking the code:</source>
          <target state="translated">コードをリンクします。</target>
        </trans-unit>
        <trans-unit id="c84c983e1eb5366ff7155483ba08d2cf18181d6f" translate="yes" xml:space="preserve">
          <source>Links are bidirectional and there can only be one link between two processes. Repeated calls to &lt;code&gt;link(Pid)&lt;/code&gt; have no effect.</source>
          <target state="translated">リンクは双方向であり、2つのプロセス間に存在できるリンクは1つだけです。 &lt;code&gt;link(Pid)&lt;/code&gt; を繰り返し呼び出しても効果はありません。</target>
        </trans-unit>
        <trans-unit id="536671c5d8157a4198a59e5ae3d1dd5548fd13ad" translate="yes" xml:space="preserve">
          <source>Links are used to monitor the behaviour of other processes, see &lt;code&gt;&lt;a href=&quot;#errors&quot;&gt;Error Handling&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">リンクは、他のプロセスの動作を監視するために使用されます。 &lt;code&gt;&lt;a href=&quot;#errors&quot;&gt;Error Handling&lt;/a&gt;&lt;/code&gt; 処理を参照してください。</target>
        </trans-unit>
        <trans-unit id="7503c78763ebecf671434c7b303123b1f56805aa" translate="yes" xml:space="preserve">
          <source>Linux (Aurora) is supported.</source>
          <target state="translated">Linux(Aurora)に対応しています。</target>
        </trans-unit>
        <trans-unit id="f49aab8507d2b62fb91db21f8494a181f98c1d79" translate="yes" xml:space="preserve">
          <source>Linux (Yellow Dog) and OS X 10.4 are supported.</source>
          <target state="translated">Linux(Yellow Dog)、OS X 10.4に対応しています。</target>
        </trans-unit>
        <trans-unit id="38b6fdccab18afaaac184982069e00fd7f3ffef8" translate="yes" xml:space="preserve">
          <source>Linux Fedora Core 5.0 (kernel 2.6.15-2054 or later is needed)</source>
          <target state="translated">Linux Fedora Core 5.0 (カーネル2.6.15-2054以降が必要)</target>
        </trans-unit>
        <trans-unit id="7271c5381dda56086abe9358b1d2d1ac80324586" translate="yes" xml:space="preserve">
          <source>Linux Kernel with UTRACE support</source>
          <target state="translated">UTRACE をサポートした Linux カーネル</target>
        </trans-unit>
        <trans-unit id="36cc9cbbe6cb1dce3453740ebc4bf86e8ca4eccd" translate="yes" xml:space="preserve">
          <source>Linux is supported.</source>
          <target state="translated">Linuxに対応しています。</target>
        </trans-unit>
        <trans-unit id="0b07d1c551ea1b1430dbe7348f1abb043df15a81" translate="yes" xml:space="preserve">
          <source>Linux via SystemTap compatibility. Please see &lt;code&gt;&lt;a href=&quot;systemtap&quot;&gt;$ERL_TOP/HOWTO/SYSTEMTAP.md&lt;/a&gt;&lt;/code&gt; for more details.</source>
          <target state="translated">LinuxとSystemTapの互換性。詳細については、 &lt;code&gt;&lt;a href=&quot;systemtap&quot;&gt;$ERL_TOP/HOWTO/SYSTEMTAP.md&lt;/a&gt;&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="bc9111a94c72d771e7a92b8e98a4dad72cd10a62" translate="yes" xml:space="preserve">
          <source>Linux: Fedora Core is supported. Both 32-bit and 64-bit modes are supported.</source>
          <target state="translated">Linuxに対応しています。Fedora Coreをサポートしています。32ビットと64ビットの両方のモードをサポートしています。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
