<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="git">
    <body>
      <group id="git">
        <trans-unit id="39555b916eeeec115f6735665b5426bf964f4e52" translate="yes" xml:space="preserve">
          <source>This setting can be overridden with the &lt;code&gt;GIT_NOTES_REWRITE_REF&lt;/code&gt; environment variable, which must be a colon separated list of refs or globs.</source>
          <target state="translated">この設定は、 &lt;code&gt;GIT_NOTES_REWRITE_REF&lt;/code&gt; 環境変数で上書きできます。これは、コロンで区切られた参照またはグロブのリストである必要があります。</target>
        </trans-unit>
        <trans-unit id="d17d74e5aa80b06bd416eb43f1c510767efc6dc8" translate="yes" xml:space="preserve">
          <source>This setting defaults to &quot;refs/notes/commits&quot;, and it can be overridden by the &lt;code&gt;GIT_NOTES_REF&lt;/code&gt; environment variable. See &lt;a href=&quot;git-notes&quot;&gt;git-notes[1]&lt;/a&gt;.</source>
          <target state="translated">この設定のデフォルトは「refs / notes / commits」で、 &lt;code&gt;GIT_NOTES_REF&lt;/code&gt; 環境変数によって上書きできます。&lt;a href=&quot;git-notes&quot;&gt;git-notes [1]を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="843f7e48b1e3c030c426060d83a399e29388c249" translate="yes" xml:space="preserve">
          <source>This setting forces Git to normalize line endings for this file on checkin and convert them to CRLF when the file is checked out.</source>
          <target state="translated">この設定では、チェックイン時にこのファイルの行末を正規化し、チェックアウト時にはCRLFに変換します。</target>
        </trans-unit>
        <trans-unit id="8c7bb001c250cfdf4247d252deb09b8b2c2a2839" translate="yes" xml:space="preserve">
          <source>This setting forces Git to normalize line endings to LF on checkin and prevents conversion to CRLF when the file is checked out.</source>
          <target state="translated">この設定では、チェックイン時にGitが行末をLFに正規化し、ファイルをチェックアウトした際にCRLFに変換されないようにします。</target>
        </trans-unit>
        <trans-unit id="886fc853da603148f91948f5793a0d1be70dc28a" translate="yes" xml:space="preserve">
          <source>This setting is automatically guessed by &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt; or &lt;a href=&quot;git-init&quot;&gt;git-init[1]&lt;/a&gt; when the repository was created. By default a repository that ends in &quot;/.git&quot; is assumed to be not bare (bare = false), while all other repositories are assumed to be bare (bare = true).</source>
          <target state="translated">この設定は、リポジトリの作成時に&lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt;または&lt;a href=&quot;git-init&quot;&gt;git-init [1]&lt;/a&gt;によって自動的に推測されます。デフォルトでは、「/。git」で終わるリポジトリはベアではないと見なされ（bare = false）、他のすべてのリポジトリはベアであると見なされます（bare = true）。</target>
        </trans-unit>
        <trans-unit id="a32da40367d476cb817ba2cfa99cb18bc04a7b3a" translate="yes" xml:space="preserve">
          <source>This setting overrides the default of the &lt;code&gt;--cleanup&lt;/code&gt; option in &lt;code&gt;git commit&lt;/code&gt;. See &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; for details. Changing the default can be useful when you always want to keep lines that begin with comment character &lt;code&gt;#&lt;/code&gt; in your log message, in which case you would do &lt;code&gt;git config commit.cleanup whitespace&lt;/code&gt; (note that you will have to remove the help lines that begin with &lt;code&gt;#&lt;/code&gt; in the commit log template yourself, if you do this).</source>
          <target state="translated">この設定は、 &lt;code&gt;git commit&lt;/code&gt; の &lt;code&gt;--cleanup&lt;/code&gt; オプションのデフォルトを上書きします。詳細については、&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt;を参照してください。デフォルトを変更すると、ログメッセージでコメント文字 &lt;code&gt;#&lt;/code&gt; で始まる行を常に保持したい場合に便利です。その場合、 &lt;code&gt;git config commit.cleanup whitespace&lt;/code&gt; を実行します（先頭のヘルプ行を削除する必要があることに注意してください） &lt;code&gt;#&lt;/code&gt; これを行う場合は、自分でコミットログテンプレートを使用してください。</target>
        </trans-unit>
        <trans-unit id="e85001143ab4f6109a8db79b80d46592a3792b5e" translate="yes" xml:space="preserve">
          <source>This setting should be set to a comma-separated list of color and date settings, starting and ending with a color, the dates should be set from oldest to newest. The metadata will be colored given the colors if the line was introduced before the given timestamp, overwriting older timestamped colors.</source>
          <target state="translated">この設定は、色と日付の設定をカンマで区切ったリストに設定し、色で始まり、色で終わるようにし、日付は古いものから新しいものまで設定する必要があります。指定されたタイムスタンプよりも前にその行が導入された場合、メタデータはその色で着色され、古いタイムスタンプの色を上書きします。</target>
        </trans-unit>
        <trans-unit id="1b39995bc064271da90ffd3401f4ace36766db6f" translate="yes" xml:space="preserve">
          <source>This setting writes a JSON-based format that is suited for machine interpretation. See &lt;code&gt;GIT_TRACE2&lt;/code&gt; for available trace output options and &lt;a href=&quot;api-trace2&quot;&gt;Trace2 documentation&lt;/a&gt; for full details.</source>
          <target state="translated">この設定は、機械の解釈に適したJSONベースの形式を書き込みます。使用可能なトレース出力オプションについては &lt;code&gt;GIT_TRACE2&lt;/code&gt; を、詳細については&lt;a href=&quot;api-trace2&quot;&gt;Trace2のドキュメント&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="d727921c238e28668ffb0dd7e4775077e3d6b368" translate="yes" xml:space="preserve">
          <source>This should be a colon-separated list of absolute paths. If set, it is a list of directories that Git should not chdir up into while looking for a repository directory (useful for excluding slow-loading network directories). It will not exclude the current working directory or a GIT_DIR set on the command line or in the environment. Normally, Git has to read the entries in this list and resolve any symlink that might be present in order to compare them with the current directory. However, if even this access is slow, you can add an empty entry to the list to tell Git that the subsequent entries are not symlinks and needn&amp;rsquo;t be resolved; e.g., &lt;code&gt;GIT_CEILING_DIRECTORIES=/maybe/symlink::/very/slow/non/symlink&lt;/code&gt;.</source>
          <target state="translated">これは、コロンで区切られた絶対パスのリストである必要があります。設定されている場合、これはリポジトリディレクトリを探すときにGitがchdirを実行してはならないディレクトリのリストです（読み込みの遅いネットワークディレクトリを除外するのに役立ちます）。コマンドラインまたは環境で設定されている現在の作業ディレクトリまたはGIT_DIRは除外されません。通常、Gitはこのリストのエントリを読み取り、現在のディレクトリと比較するために、存在する可能性のあるシンボリックリンクを解決する必要があります。ただし、このアクセスが遅い場合でも、リストに空のエントリを追加して、後続のエントリがシンボリックリンクではなく解決する必要がないことをGitに伝えることができます。例： &lt;code&gt;GIT_CEILING_DIRECTORIES=/maybe/symlink::/very/slow/non/symlink&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="02391ad98329bedcf2ddfbe7ebdef774e4e7cc67" translate="yes" xml:space="preserve">
          <source>This should help you to submit patches inline using KMail.</source>
          <target state="translated">これで、KMailを使ってパッチをインラインで送信することができるようになるはずです。</target>
        </trans-unit>
        <trans-unit id="dc65a8c75ec971d079e04ac05264e8ee2fb908c8" translate="yes" xml:space="preserve">
          <source>This should make &quot;--pretty=oneline&quot; a whole lot more readable for people using 80-column terminals.</source>
          <target state="translated">これにより、80カラムの端末を使っている人にとっては、&quot;--pretty=oneline &quot;がより読みやすくなるはずです。</target>
        </trans-unit>
        <trans-unit id="cda899a68420b48633046b1cef20e4960b467a9e" translate="yes" xml:space="preserve">
          <source>This should make it easy to look up svn log messages when svn users refer to -r/--revision numbers.</source>
          <target state="translated">これにより、svn のユーザーが -r/--修正番号を参照したときに svn のログメッセージを簡単に調べることができるようになるはずです。</target>
        </trans-unit>
        <trans-unit id="3fce0b9f9a8369808848ec3f066c1735323bb111" translate="yes" xml:space="preserve">
          <source>This should not be confused with the &lt;code&gt;ours&lt;/code&gt; merge strategy, which does not even look at what the other tree contains at all. It discards everything the other tree did, declaring &lt;code&gt;our&lt;/code&gt; history contains all that happened in it.</source>
          <target state="translated">これは、他のツリーに何が含まれているかをまったく確認しない、 &lt;code&gt;ours&lt;/code&gt; マージ戦略と混同しないでください。それは他のツリーが行ったすべてを破棄し、 &lt;code&gt;our&lt;/code&gt; 歴史はその中で起こったすべてを含んでいると宣言します。</target>
        </trans-unit>
        <trans-unit id="70d0ce2d7e7f48cdf303b28228ad271bde0b97ac" translate="yes" xml:space="preserve">
          <source>This shows that our resolved version deleted &quot;Hello world&quot; from the first parent, deleted &quot;Goodbye&quot; from the second parent, and added &quot;Goodbye world&quot;, which was previously absent from both.</source>
          <target state="translated">これは、私たちが解決したバージョンでは、最初の親から &quot;Hello world &quot;が削除され、2番目の親から &quot;Goodbye &quot;が削除され、両方の親にはなかった &quot;Goodbye world &quot;が追加されたことを示しています。</target>
        </trans-unit>
        <trans-unit id="e0fbc89a9eb1f686d88b41839c951cd18b86bf5e" translate="yes" xml:space="preserve">
          <source>This shows that you can do without a run script if you write the test on a single line.</source>
          <target state="translated">これは、テストを一行で書けばランスクリプトなしでもできることを示しています。</target>
        </trans-unit>
        <trans-unit id="f580a082428b40358ee35f346bb87b38bbd6e3f8" translate="yes" xml:space="preserve">
          <source>This shows the change between HEAD and index (i.e. what will be committed if you say &lt;code&gt;git commit&lt;/code&gt;), and between index and working tree files (i.e. what you could stage further before &lt;code&gt;git commit&lt;/code&gt; using &lt;code&gt;git add&lt;/code&gt;) for each path. A sample output looks like this:</source>
          <target state="translated">これは、各パスのHEADとインデックス（つまり、 &lt;code&gt;git commit&lt;/code&gt; と言うとコミットされるもの）と、インデックスと作業ツリーファイル（つまり、 &lt;code&gt;git add&lt;/code&gt; &lt;code&gt;git commit&lt;/code&gt; 使用してgit コミットする前にさらにステージングできるもの）との間の変更を示しています。出力例は次のようになります。</target>
        </trans-unit>
        <trans-unit id="cdedf9c4235065dcc3b6a065543c259879fefa6b" translate="yes" xml:space="preserve">
          <source>This shows the files and directories to be deleted and issues an &quot;Input ignore patterns&amp;gt;&amp;gt;&quot; prompt. You can input space-separated patterns to exclude files and directories from deletion. E.g. &quot;*.c *.h&quot; will excludes files end with &quot;.c&quot; and &quot;.h&quot; from deletion. When you are satisfied with the filtered result, press ENTER (empty) back to the main menu.</source>
          <target state="translated">削除するファイルとディレクトリが表示され、「入力無視パターン&amp;gt;&amp;gt;」プロンプトが表示されます。スペースで区切られたパターンを入力して、ファイルとディレクトリを削除から除外できます。たとえば、「*。c * .h」は、「。c」と「.h」で終わるファイルを削除から除外します。フィルター処理した結果に満足したら、Enter（空）を押してメインメニューに戻ります。</target>
        </trans-unit>
        <trans-unit id="d76da1518821bfa115def32fd19d8e8b1e73d979" translate="yes" xml:space="preserve">
          <source>This shows the files and directories to be deleted and issues an &quot;Select items to delete&amp;gt;&amp;gt;&quot; prompt. When the prompt ends with double &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; like this, you can make more than one selection, concatenated with whitespace or comma. Also you can say ranges. E.g. &quot;2-5 7,9&quot; to choose 2,3,4,5,7,9 from the list. If the second number in a range is omitted, all remaining items are selected. E.g. &quot;7-&quot; to choose 7,8,9 from the list. You can say &lt;code&gt;*&lt;/code&gt; to choose everything. Also when you are satisfied with the filtered result, press ENTER (empty) back to the main menu.</source>
          <target state="translated">削除するファイルとディレクトリが表示され、「削除するアイテムを選択&amp;gt;&amp;gt;」というプロンプトが表示されます。プロンプトがこのように二重 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; で終了する場合、空白またはコンマで連結された複数の選択を行うことができます。また、あなたは範囲を言うことができます。たとえば、「2-5 7,9」はリストから2、3、4、5、7、9を選択します。範囲の2番目の数値を省略すると、残りのすべての項目が選択されます。たとえば、「7-」はリストから7,8,9を選択します。 &lt;code&gt;*&lt;/code&gt; と言ってすべてを選択できます。また、フィルター処理した結果に満足したら、Enter（空）を押してメインメニューに戻ります。</target>
        </trans-unit>
        <trans-unit id="53f59db63b45945049b0fe262d831991c1cb4a8d" translate="yes" xml:space="preserve">
          <source>This shows the status information and issues an &quot;Update&amp;gt;&amp;gt;&quot; prompt. When the prompt ends with double &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, you can make more than one selection, concatenated with whitespace or comma. Also you can say ranges. E.g. &quot;2-5 7,9&quot; to choose 2,3,4,5,7,9 from the list. If the second number in a range is omitted, all remaining patches are taken. E.g. &quot;7-&quot; to choose 7,8,9 from the list. You can say &lt;code&gt;*&lt;/code&gt; to choose everything.</source>
          <target state="translated">ステータス情報が表示され、「Update &amp;gt;&amp;gt;」プロンプトが表示されます。プロンプトが二重 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; で終わる場合、空白またはコンマで連結された複数の選択を行うことができます。また、あなたは範囲を言うことができます。たとえば、「2-5 7,9」はリストから2、3、4、5、7、9を選択します。範囲の2番目の番号を省略すると、残りのすべてのパッチが取得されます。たとえば、 &quot;7-&quot;はリストから7,8,9を選択します。 &lt;code&gt;*&lt;/code&gt; と言ってすべてを選択できます。</target>
        </trans-unit>
        <trans-unit id="728eb7da1f0f1bff86889f4ac114a7967bd3817f" translate="yes" xml:space="preserve">
          <source>This snapshot is now stored in a temporary staging area which Git calls the &quot;index&quot;. You can permanently store the contents of the index in the repository with &lt;code&gt;git commit&lt;/code&gt;:</source>
          <target state="translated">このスナップショットは、Gitが「インデックス」と呼ぶ一時的なステージング領域に保存されます。 &lt;code&gt;git commit&lt;/code&gt; を使用して、インデックスのコンテンツをリポジトリに永続的に保存できます。</target>
        </trans-unit>
        <trans-unit id="dfa3a419f48a4609a0668c69a143f543612e713a" translate="yes" xml:space="preserve">
          <source>This solution is not 100% bulletproof, in the sense that if some project has a named ref (branch, tag) starting with &lt;code&gt;git/&lt;/code&gt;, then paths such as</source>
          <target state="translated">このソリューションは100％防弾ではありません。あるプロジェクトに &lt;code&gt;git/&lt;/code&gt; で始まる名前付きの参照（ブランチ、タグ）がある場合、次のようなパスになります。</target>
        </trans-unit>
        <trans-unit id="02da975953020f9ebbe3388889e8a8406f05d0c7" translate="yes" xml:space="preserve">
          <source>This step and the next one could be combined into a single step with &quot;checkout -b my2.6.14 v2.6.14&quot;.</source>
          <target state="translated">このステップと次のステップは、&quot;checkout -b my2.6.14 v2.6.14 &quot;で1つのステップにまとめることができます。</target>
        </trans-unit>
        <trans-unit id="9b0b980e437fd3274de63464aa9184e42833d899" translate="yes" xml:space="preserve">
          <source>This suffix is also accepted when spelled in uppercase, and means the same thing no matter the case.</source>
          <target state="translated">この接尾辞は大文字で綴った場合にも通用し、大文字と小文字に関係なく同じ意味になります。</target>
        </trans-unit>
        <trans-unit id="01f381d8f83cae139b7e7ff06573574ebdbc8086" translate="yes" xml:space="preserve">
          <source>This supersedes the &lt;a href=&quot;#post-update&quot;&gt;&lt;em&gt;post-update&lt;/em&gt;&lt;/a&gt; hook in that it gets both old and new values of all the refs in addition to their names.</source>
          <target state="translated">これは、名前に加えてすべての参照の古い値と新しい値の両方を取得するという点で、&lt;a href=&quot;#post-update&quot;&gt;&lt;em&gt;更新後の&lt;/em&gt;&lt;/a&gt;フックに取って代わります。</target>
        </trans-unit>
        <trans-unit id="6339f7da558022ed0ae10f566dd01f30bb047e19" translate="yes" xml:space="preserve">
          <source>This synchronizes your public repository to match the named branch head (i.e. &lt;code&gt;master&lt;/code&gt; in this case) and objects reachable from them in your current repository.</source>
          <target state="translated">これにより、パブリックリポジトリが同期され、名前付きブランチヘッド（この場合は &lt;code&gt;master&lt;/code&gt; ）と現在のリポジトリ内のそこから到達可能なオブジェクトが一致します。</target>
        </trans-unit>
        <trans-unit id="0012e2584fc653cc03e6dda35ea11cbdc9f6c1a2" translate="yes" xml:space="preserve">
          <source>This syntax is only recognized if there are no slashes before the first colon. This helps differentiate a local path that contains a colon. For example the local path &lt;code&gt;foo:bar&lt;/code&gt; could be specified as an absolute path or &lt;code&gt;./foo:bar&lt;/code&gt; to avoid being misinterpreted as an ssh url.</source>
          <target state="translated">この構文は、最初のコロンの前にスラッシュがない場合にのみ認識されます。これは、コロンを含むローカルパスを区別するのに役立ちます。たとえば、ローカルパス &lt;code&gt;foo:bar&lt;/code&gt; 、絶対パスまたはとして指定することができ &lt;code&gt;./foo:bar&lt;/code&gt; sshのURLと誤解されないように。</target>
        </trans-unit>
        <trans-unit id="9f5d9872e03f1e6dd55415fa2249d9c84ea6f738" translate="yes" xml:space="preserve">
          <source>This takes a text file each of whose lines is a shell glob pattern. Filepairs that match a glob pattern on an earlier line in the file are output before ones that match a later line, and filepairs that do not match any glob pattern are output last.</source>
          <target state="translated">これは、各行がシェル・グロブ・パターンであるテキスト・ファイルを取得します。ファイルの前の行でグロブ・パターンにマッチしたファイルペアは、後の行にマッチしたファイルペアの前に出力され、グロブ・パターンにマッチしないファイルペアは最後に出力されます。</target>
        </trans-unit>
        <trans-unit id="b169549655fddd825e67d14c1591493d6ac0be03" translate="yes" xml:space="preserve">
          <source>This target is intended to be more of a summary (like GIT_TRACE) and less detailed than the other targets. It ignores thread, region, and data messages, for example.</source>
          <target state="translated">このターゲットは (GIT_TRACE のように)より要約的で、他のターゲットよりも詳細ではないことを意図しています。例えば、スレッド、リージョン、データメッセージは無視されます。</target>
        </trans-unit>
        <trans-unit id="49bec15344e0cef74269dabec868d060f4c1b07d" translate="yes" xml:space="preserve">
          <source>This tells the bisect process that no commit after &lt;code&gt;v2.5&lt;/code&gt;, up to and including &lt;code&gt;v2.6&lt;/code&gt;, should be tested.</source>
          <target state="translated">これはbisectプロセスに、 &lt;code&gt;v2.5&lt;/code&gt; 以降（ &lt;code&gt;v2.6&lt;/code&gt; まで）のコミットはテストしないように指示します。</target>
        </trans-unit>
        <trans-unit id="1842bab1269e00a8bf77d06ee23570861225cc48" translate="yes" xml:space="preserve">
          <source>This tells the bisect process that the commits between &lt;code&gt;v2.5&lt;/code&gt; and &lt;code&gt;v2.6&lt;/code&gt; (inclusive) should be skipped.</source>
          <target state="translated">これは、 &lt;code&gt;v2.5&lt;/code&gt; と &lt;code&gt;v2.6&lt;/code&gt; （両端を含む）の間のコミットをスキップする必要があることをbisectプロセスに伝えます。</target>
        </trans-unit>
        <trans-unit id="fb42c5eea9f7afe3662a07fd6af3c3105ab04e8f" translate="yes" xml:space="preserve">
          <source>This tells you that the immediately following version of the file was &quot;newsha&quot;, and that the immediately preceding version was &quot;oldsha&quot;. You also know the commit messages that went with the change from oldsha to 4b9458b and with the change from 4b9458b to newsha.</source>
          <target state="translated">これは、ファイルの直後のバージョンが「newsha」であり、直前のバージョンが「oldsha」であったことを教えてくれます。oldsha から 4b9458b への変更と、4b9458b から newsha への変更に伴うコミットメッセージもわかります。</target>
        </trans-unit>
        <trans-unit id="8f1179423f3ea23a6c9e525ef159db41c1155b6a" translate="yes" xml:space="preserve">
          <source>This transformation is used to detect renames and copies, and is controlled by the -M option (to detect renames) and the -C option (to detect copies as well) to the &lt;code&gt;git diff-*&lt;/code&gt; commands. If the input contained these filepairs:</source>
          <target state="translated">この変換は、名前変更とコピーを検出するために使用され、 &lt;code&gt;git diff-*&lt;/code&gt; コマンドの-Mオプション（名前変更を検出する）と-Cオプション（コピーも検出する）によって制御されます。入力にこれらのファイルペアが含まれていた場合：</target>
        </trans-unit>
        <trans-unit id="573190bccf8f2a4ea6fc33eedd23b4b8fc3f90f8" translate="yes" xml:space="preserve">
          <source>This transformation is used to merge filepairs broken by diffcore-break, and not transformed into rename/copy by diffcore-rename, back into a single modification. This always runs when diffcore-break is used.</source>
          <target state="translated">この変換は、diffcode-break で壊れたファイルペアを、diffcode-rename で rename/copy に変換されなかったファイルペアにマージして、単一の変更に戻すために使われます。これは diffcore-break が使われているときに常に実行されます。</target>
        </trans-unit>
        <trans-unit id="448726c2164ad1aa28f4d84dcd657bc466764287" translate="yes" xml:space="preserve">
          <source>This transformation limits the set of filepairs to those that change specified strings between the preimage and the postimage in a certain way. -S&amp;lt;block of text&amp;gt; and -G&amp;lt;regular expression&amp;gt; options are used to specify different ways these strings are sought.</source>
          <target state="translated">この変換は、ファイルペアのセットを、特定の方法で前イメージと後イメージの間で指定された文字列を変更するペアに制限します。-S &amp;lt;テキストのブロック&amp;gt;および-G &amp;lt;正規表現&amp;gt;オプションは、これらの文字列が検索されるさまざまな方法を指定するために使用されます。</target>
        </trans-unit>
        <trans-unit id="eb01f7c28a2e42a179d9ca76727e0a7db6bb8dce" translate="yes" xml:space="preserve">
          <source>This transport can be used for both uploading and downloading, and requires you to have a log-in privilege over &lt;code&gt;ssh&lt;/code&gt; to the remote machine. It finds out the set of objects the other side lacks by exchanging the head commits both ends have and transfers (close to) minimum set of objects. It is by far the most efficient way to exchange Git objects between repositories.</source>
          <target state="translated">このトランスポートは、アップロードとダウンロードの両方に使用でき、リモートマシンへの &lt;code&gt;ssh&lt;/code&gt; 経由のログイン権限が必要です。両端のヘッドコミットを交換し、オブジェクトの最小セットを（近くに）転送することにより、反対側にないオブジェクトのセットを見つけます。これは、リポジトリ間でGitオブジェクトを交換するための最も効率的な方法です。</target>
        </trans-unit>
        <trans-unit id="1e93313475dc2966a9b364d25d3e63ddb92cd35d" translate="yes" xml:space="preserve">
          <source>This transport is the same as SSH transport but uses &lt;code&gt;sh&lt;/code&gt; to run both ends on the local machine instead of running other end on the remote machine via &lt;code&gt;ssh&lt;/code&gt;.</source>
          <target state="translated">このトランスポートはSSHトランスポートと同じですが、リモートマシンで &lt;code&gt;ssh&lt;/code&gt; を介して他のエンドを実行する代わりに、ローカルマシンで &lt;code&gt;sh&lt;/code&gt; を使用して両端を実行します。</target>
        </trans-unit>
        <trans-unit id="187c060b77919e40b0db07be6c4444d6bedf0f1f" translate="yes" xml:space="preserve">
          <source>This transport was designed for anonymous downloading. Like SSH transport, it finds out the set of objects the downstream side lacks and transfers (close to) minimum set of objects.</source>
          <target state="translated">このトランスポートは匿名ダウンロード用に設計されています。SSH トランスポートと同様に、下流側に不足しているオブジェクトのセットを見つけ出し、 最小限のオブジェクトのセットを(それに近い形で)転送します。</target>
        </trans-unit>
        <trans-unit id="a843c4941e9eb68216876c91a59842ae7d058faa" translate="yes" xml:space="preserve">
          <source>This tutorial explains how to import a new project into Git, make changes to it, and share changes with other developers.</source>
          <target state="translated">このチュートリアルでは、新しいプロジェクトを Git にインポートして変更を加え、他の開発者と共有する方法を説明します。</target>
        </trans-unit>
        <trans-unit id="586b98337ae35b657ccc9687b72106b49b3b174b" translate="yes" xml:space="preserve">
          <source>This tutorial explains how to use the &quot;core&quot; Git commands to set up and work with a Git repository.</source>
          <target state="translated">このチュートリアルでは、&quot;core&quot; Git コマンドを使って Git リポジトリを設定して作業する方法を説明します。</target>
        </trans-unit>
        <trans-unit id="4f3b7287fc4739a451de38537fb0637003a134c1" translate="yes" xml:space="preserve">
          <source>This tutorial should be enough to perform basic distributed revision control for your projects. However, to fully understand the depth and power of Git you need to understand two simple ideas on which it is based:</source>
          <target state="translated">このチュートリアルでは、プロジェクトの基本的な分散リビジョン管理を行うのに十分な内容となっています。しかし、Git の奥深さとパワーを完全に理解するには、Git のベースとなっている二つのシンプルな考え方を理解する必要があります。</target>
        </trans-unit>
        <trans-unit id="50b7797bad77b49520127714ff8a716873aad978" translate="yes" xml:space="preserve">
          <source>This updates (or creates, as necessary) branches &lt;code&gt;pu&lt;/code&gt; and &lt;code&gt;tmp&lt;/code&gt; in the local repository by fetching from the branches (respectively) &lt;code&gt;pu&lt;/code&gt; and &lt;code&gt;maint&lt;/code&gt; from the remote repository.</source>
          <target state="translated">これにより、リモートリポジトリから &lt;code&gt;pu&lt;/code&gt; および &lt;code&gt;maint&lt;/code&gt; ブランチを（それぞれ）フェッチすることにより、ローカルリポジトリの &lt;code&gt;pu&lt;/code&gt; および &lt;code&gt;tmp&lt;/code&gt; ブランチが更新（または必要に応じて作成）されます。</target>
        </trans-unit>
        <trans-unit id="3e7d31bbe83aa073e1058fe02ef8026a34345709" translate="yes" xml:space="preserve">
          <source>This updates (or creates, as necessary) branches &lt;code&gt;seen&lt;/code&gt; and &lt;code&gt;tmp&lt;/code&gt; in the local repository by fetching from the branches (respectively) &lt;code&gt;seen&lt;/code&gt; and &lt;code&gt;maint&lt;/code&gt; from the remote repository.</source>
          <target state="translated">この更新（または作成し、必要に応じて）分岐 &lt;code&gt;seen&lt;/code&gt; および &lt;code&gt;tmp&lt;/code&gt; 分岐からフェッチすることによって、ローカルリポジトリに（それぞれ）が &lt;code&gt;seen&lt;/code&gt; と &lt;code&gt;maint&lt;/code&gt; リモートリポジトリから。</target>
        </trans-unit>
        <trans-unit id="70ac0b727096d7231e8fdcdd112d1a04551c8ca8" translate="yes" xml:space="preserve">
          <source>This used to be the default, but not since Git 2.0 (&lt;code&gt;simple&lt;/code&gt; is the new default).</source>
          <target state="translated">これは以前はデフォルトでしたが、Git 2.0以降ではありません（ &lt;code&gt;simple&lt;/code&gt; が新しいデフォルトです）。</target>
        </trans-unit>
        <trans-unit id="fd75f35034e73b98112aaaf4198ee488b9e51804" translate="yes" xml:space="preserve">
          <source>This uses the &lt;code&gt;--interactive&lt;/code&gt; machinery internally, but combining it with the &lt;code&gt;--interactive&lt;/code&gt; option explicitly is generally not a good idea unless you know what you are doing (see BUGS below).</source>
          <target state="translated">これは内部的に &lt;code&gt;--interactive&lt;/code&gt; 機構を使用しますが、-- &lt;code&gt;--interactive&lt;/code&gt; オプションと明示的に組み合わせることは、何をしているのかを知らない限り、一般に良い考えではありません（以下のバグを参照）。</target>
        </trans-unit>
        <trans-unit id="665eaff82148d49a545a97a7903a8bf0d3754608" translate="yes" xml:space="preserve">
          <source>This uses the &lt;code&gt;--interactive&lt;/code&gt; machinery internally, but it can be run without an explicit &lt;code&gt;--interactive&lt;/code&gt;.</source>
          <target state="translated">これは内部で &lt;code&gt;--interactive&lt;/code&gt; 機構を使用しますが、明示的な &lt;code&gt;--interactive&lt;/code&gt; なしで実行できます。</target>
        </trans-unit>
        <trans-unit id="5a59444b879ae5151f30b1cffe08974240ac7bdc" translate="yes" xml:space="preserve">
          <source>This uses the same two-dot range notation we saw earlier with &lt;code&gt;git log&lt;/code&gt;.</source>
          <target state="translated">これは、前に &lt;code&gt;git log&lt;/code&gt; で見たのと同じ2つのドット範囲表記を使用します。</target>
        </trans-unit>
        <trans-unit id="94dc29f5a82c88ac8ea06389eebe7535e89a6fb1" translate="yes" xml:space="preserve">
          <source>This value is true by default in a repository that has a working directory associated with it, and false by default in a bare repository.</source>
          <target state="translated">この値は、作業ディレクトリが関連付けられているリポジトリではデフォルトでtrueになり、ベアリポジトリではデフォルトでfalseになります。</target>
        </trans-unit>
        <trans-unit id="73a34f84ecc165ae3643b28ecca4c6c41f197412" translate="yes" xml:space="preserve">
          <source>This variable can be used to restrict the permission bits of tar archive entries. The default is 0002, which turns off the world write bit. The special value &quot;user&quot; indicates that the archiving user&amp;rsquo;s umask will be used instead. See umask(2) and &lt;a href=&quot;git-archive&quot;&gt;git-archive[1]&lt;/a&gt;.</source>
          <target state="translated">この変数は、tarアーカイブエントリの許可ビットを制限するために使用できます。デフォルトは0002で、ワールドライトビットをオフにします。特別な値「user」は、代わ​​りにアーカイブユーザーのumaskが使用されることを示します。umask（2）および&lt;a href=&quot;git-archive&quot;&gt;git-archive [1]を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="63a384d932515032afb2060852ce18cd5598c9ca" translate="yes" xml:space="preserve">
          <source>This variable can be used to restrict the permission bits of tar archive entries. The default is 0002, which turns off the world write bit. The special value &quot;user&quot; indicates that the archiving user&amp;rsquo;s umask will be used instead. See umask(2) for details. If &lt;code&gt;--remote&lt;/code&gt; is used then only the configuration of the remote repository takes effect.</source>
          <target state="translated">この変数は、tarアーカイブエントリの許可ビットを制限するために使用できます。デフォルトは0002で、ワールドライトビットをオフにします。特別な値「user」は、代わ​​りにアーカイブユーザーのumaskが使用されることを示します。詳細については、umask（2）を参照してください。場合 &lt;code&gt;--remote&lt;/code&gt; が、その後使用されているリモートリポジトリの構成のみが有効になります。</target>
        </trans-unit>
        <trans-unit id="0afce327e7d4311118de1c5dc2faa8fa7a291053" translate="yes" xml:space="preserve">
          <source>This variable controls the event target destination. It may be overridden by the &lt;code&gt;GIT_TRACE2_EVENT&lt;/code&gt; environment variable. The following table shows possible values.</source>
          <target state="translated">この変数は、イベントのターゲット宛先を制御します。 &lt;code&gt;GIT_TRACE2_EVENT&lt;/code&gt; 環境変数によって上書きされる場合があります。次の表に、可能な値を示します。</target>
        </trans-unit>
        <trans-unit id="b3073c2a2c3930628fae47eb515e2fe5729910f0" translate="yes" xml:space="preserve">
          <source>This variable controls the normal target destination. It may be overridden by the &lt;code&gt;GIT_TRACE2&lt;/code&gt; environment variable. The following table shows possible values.</source>
          <target state="translated">この変数は、通常のターゲット宛先を制御します。 &lt;code&gt;GIT_TRACE2&lt;/code&gt; 環境変数によって上書きされる場合があります。次の表に、可能な値を示します。</target>
        </trans-unit>
        <trans-unit id="ab644894061fa15fc115b6d355d07c2965277303" translate="yes" xml:space="preserve">
          <source>This variable controls the performance target destination. It may be overridden by the &lt;code&gt;GIT_TRACE2_PERF&lt;/code&gt; environment variable. The following table shows possible values.</source>
          <target state="translated">この変数は、パフォーマンスターゲットの宛先を制御します。 &lt;code&gt;GIT_TRACE2_PERF&lt;/code&gt; 環境変数によってオーバーライドされる場合があります。次の表に、可能な値を示します。</target>
        </trans-unit>
        <trans-unit id="53008d90e6aae985c2e7839a77d7b54894ce429e" translate="yes" xml:space="preserve">
          <source>This variable controls the sort ordering of branches when displayed by &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt;. Without the &quot;--sort=&amp;lt;value&amp;gt;&quot; option provided, the value of this variable will be used as the default. See &lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref[1]&lt;/a&gt; field names for valid values.</source>
          <target state="translated">この変数は、&lt;a href=&quot;git-branch&quot;&gt;git-branch [1]&lt;/a&gt;によって表示されるときのブランチのソート順を制御します。「--sort = &amp;lt;value&amp;gt;」オプションを指定しない場合、この変数の値がデフォルトとして使用されます。有効な値については、&lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref [1]&lt;/a&gt;フィールド名をご覧ください。</target>
        </trans-unit>
        <trans-unit id="ea1c7eb75a360c1f9f69915dbc32e427ddfb7ced" translate="yes" xml:space="preserve">
          <source>This variable controls the sort ordering of tags when displayed by &lt;a href=&quot;git-tag&quot;&gt;git-tag[1]&lt;/a&gt;. Without the &quot;--sort=&amp;lt;value&amp;gt;&quot; option provided, the value of this variable will be used as the default.</source>
          <target state="translated">この変数は、&lt;a href=&quot;git-tag&quot;&gt;git-tag [1]&lt;/a&gt;によって表示されるときのタグのソート順を制御します。「--sort = &amp;lt;value&amp;gt;」オプションを指定しない場合、この変数の値がデフォルトとして使用されます。</target>
        </trans-unit>
        <trans-unit id="c2680b6925a4a160ca8f3fee892cc23ec9be5f4f" translate="yes" xml:space="preserve">
          <source>This variable determines the default value for variables such as &lt;code&gt;color.diff&lt;/code&gt; and &lt;code&gt;color.grep&lt;/code&gt; that control the use of color per command family. Its scope will expand as more commands learn configuration to set a default for the &lt;code&gt;--color&lt;/code&gt; option. Set it to &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;never&lt;/code&gt; if you prefer Git commands not to use color unless enabled explicitly with some other configuration or the &lt;code&gt;--color&lt;/code&gt; option. Set it to &lt;code&gt;always&lt;/code&gt; if you want all output not intended for machine consumption to use color, to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;auto&lt;/code&gt; (this is the default since Git 1.8.4) if you want such output to use color when written to the terminal.</source>
          <target state="translated">この変数は、コマンドファミリごとの色の使用を制御する &lt;code&gt;color.diff&lt;/code&gt; や &lt;code&gt;color.grep&lt;/code&gt; などの変数のデフォルト値を決定します。より多くのコマンドが &lt;code&gt;--color&lt;/code&gt; オプションのデフォルトを設定するための構成を学習するにつれて、その範囲は拡大します。設定してください &lt;code&gt;false&lt;/code&gt; か &lt;code&gt;never&lt;/code&gt; あなたには、いくつかの他の構成やで明示的に有効にしない限り、Gitは使用カラーにないコマンドを好む場合 &lt;code&gt;--color&lt;/code&gt; オプション。マシンの消費を目的としないすべての出力で色を使用する場合は、 &lt;code&gt;always&lt;/code&gt; 出力に設定します。ターミナルへの書き込み時に色を使用する場合は、 &lt;code&gt;true&lt;/code&gt; または &lt;code&gt;auto&lt;/code&gt; （Git 1.8.4以降のデフォルト）に設定します。</target>
        </trans-unit>
        <trans-unit id="2eb6f1e33d90fc7fb4373fa1793932292fbc650d" translate="yes" xml:space="preserve">
          <source>This variable is the same as &lt;code&gt;transfer.hideRefs&lt;/code&gt;, but applies only to &lt;code&gt;receive-pack&lt;/code&gt; (and so affects pushes, but not fetches). An attempt to update or delete a hidden ref by &lt;code&gt;git push&lt;/code&gt; is rejected.</source>
          <target state="translated">この変数は &lt;code&gt;transfer.hideRefs&lt;/code&gt; と同じですが、 &lt;code&gt;receive-pack&lt;/code&gt; のみ適用されます（したがって、プッシュには影響しますが、フェッチには影響しません）。 &lt;code&gt;git push&lt;/code&gt; によって非表示の参照を更新または削除する試みは拒否されます。</target>
        </trans-unit>
        <trans-unit id="763a368531eb9d8bc40e93c6334e049f21620c45" translate="yes" xml:space="preserve">
          <source>This variable is the same as &lt;code&gt;transfer.hideRefs&lt;/code&gt;, but applies only to &lt;code&gt;upload-pack&lt;/code&gt; (and so affects only fetches, not pushes). An attempt to fetch a hidden ref by &lt;code&gt;git fetch&lt;/code&gt; will fail. See also &lt;code&gt;uploadpack.allowTipSHA1InWant&lt;/code&gt;.</source>
          <target state="translated">この変数は &lt;code&gt;transfer.hideRefs&lt;/code&gt; と同じですが、 &lt;code&gt;upload-pack&lt;/code&gt; にのみ適用されます（したがって、プッシュではなくフェッチのみに影響します）。 &lt;code&gt;git fetch&lt;/code&gt; によって非表示の参照をフェッチしようとすると失敗します。 &lt;code&gt;uploadpack.allowTipSHA1InWant&lt;/code&gt; も参照してください。</target>
        </trans-unit>
        <trans-unit id="75aa35a44ffd767e8a239dc01347d150ce1e39ed" translate="yes" xml:space="preserve">
          <source>This variable matters only when using persistent web environments that serve multiple requests using single gitweb instance, like mod_perl, FastCGI or Plackup.</source>
          <target state="translated">この変数が重要になるのは、mod_perl や FastCGI、Plackup のように、単一の gitweb インスタンスを使用して複数のリクエストに対応する持続的なウェブ環境を使用している場合のみです。</target>
        </trans-unit>
        <trans-unit id="c0526214b5c55d639fefd6a92d93b97ec2455930" translate="yes" xml:space="preserve">
          <source>This variable specifies a shell command through which the tar output generated by &lt;code&gt;git archive&lt;/code&gt; should be piped. The command is executed using the shell with the generated tar file on its standard input, and should produce the final output on its standard output. Any compression-level options will be passed to the command (e.g., &quot;-9&quot;). An output file with the same extension as &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; will be use this format if no other format is given.</source>
          <target state="translated">この変数は、 &lt;code&gt;git archive&lt;/code&gt; によって生成されたtar出力をパイプするシェルコマンドを指定します。コマンドは、標準入力に生成されたtarファイルを含むシェルを使用して実行され、標準出力に最終出力を生成します。圧縮レベルのオプションはすべてコマンドに渡されます（例： &quot;-9&quot;）。 &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; と同じ拡張子を持つ出力ファイルは、他の形式が指定されていない場合、この形式を使用します。</target>
        </trans-unit>
        <trans-unit id="99ffcf0d1fc58b3934082bac9786637cf3a8cdad" translate="yes" xml:space="preserve">
          <source>This view is similar to &lt;code&gt;shortlog&lt;/code&gt; view.</source>
          <target state="translated">このビューは、 &lt;code&gt;shortlog&lt;/code&gt; ビューに似ています。</target>
        </trans-unit>
        <trans-unit id="16ae6576174eeb48325f0bfa3042bcb20d29d417" translate="yes" xml:space="preserve">
          <source>This was not the case in the initial release of this feature in v2.13.0, which only matched the realpath version. Configuration that wants to be compatible with the initial release of this feature needs to either specify only the realpath version, or both versions.</source>
          <target state="translated">この機能の初期リリースである v2.13.0 では、realpath のバージョンにしか対応していませんでした。この機能の初期リリースとの互換性を望む設定は、realpath のバージョンのみを指定するか、両方のバージョンを指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="7c8d457b197b5558b7abfe068bcd1974205f94ad" translate="yes" xml:space="preserve">
          <source>This was optional in prior versions of git, but now it is the default. You can use &lt;code&gt;--no-utf8&lt;/code&gt; to override this.</source>
          <target state="translated">これは以前のバージョンのgitではオプションでしたが、現在はデフォルトになっています。 &lt;code&gt;--no-utf8&lt;/code&gt; を使用してこれを上書きできます。</target>
        </trans-unit>
        <trans-unit id="314df942d006c94c85d3e8c8bfe0a0b8ef8308d1" translate="yes" xml:space="preserve">
          <source>This will again prompt you for a message describing the change, and then record a new version of the project.</source>
          <target state="translated">これにより、変更内容を説明するメッセージが再度表示され、プロジェクトの新しいバージョンが記録されます。</target>
        </trans-unit>
        <trans-unit id="53cca56aaa41c3093032e1d720cb620b22717e06" translate="yes" xml:space="preserve">
          <source>This will cache the result of running &quot;exif&quot; on each blob indefinitely. If you change the textconv config variable for a diff driver, Git will automatically invalidate the cache entries and re-run the textconv filter. If you want to invalidate the cache manually (e.g., because your version of &quot;exif&quot; was updated and now produces better output), you can remove the cache manually with &lt;code&gt;git update-ref -d refs/notes/textconv/jpg&lt;/code&gt; (where &quot;jpg&quot; is the name of the diff driver, as in the example above).</source>
          <target state="translated">これにより、各blobで「exif」を実行した結果が無期限にキャッシュされます。差分ドライバーのtextconv構成変数を変更すると、Gitは自動的にキャッシュエントリーを無効にし、textconvフィルターを再実行します。キャッシュを手動で無効にしたい場合（たとえば、「exif」のバージョンが更新され、出力が向上したため）、 &lt;code&gt;git update-ref -d refs/notes/textconv/jpg&lt;/code&gt; （where &quot; jpg &quot;は、上記の例のように、diffドライバーの名前です。</target>
        </trans-unit>
        <trans-unit id="3d17cc7dd2b4aac7e00ecd2628dbb99eefd074c7" translate="yes" xml:space="preserve">
          <source>This will cause Git to generate &lt;code&gt;Binary files differ&lt;/code&gt; (or a binary patch, if binary patches are enabled) instead of a regular diff.</source>
          <target state="translated">これにより、Git は通常の差分ではなく、 &lt;code&gt;Binary files differ&lt;/code&gt; （またはバイナリパッチが有効な場合はバイナリパッチ）を生成します。</target>
        </trans-unit>
        <trans-unit id="dac66330b2bd98fcf90352c4cbeba694c8f4feb3" translate="yes" xml:space="preserve">
          <source>This will check out the currently cached copy of &lt;code&gt;Makefile&lt;/code&gt; into the file &lt;code&gt;.merged-Makefile&lt;/code&gt;.</source>
          <target state="translated">これにより、現在キャッシュされている &lt;code&gt;Makefile&lt;/code&gt; のコピーがファイル &lt;code&gt;.merged-Makefile&lt;/code&gt; にチェックアウトされます。</target>
        </trans-unit>
        <trans-unit id="9acb73cd9d17d8ef0d5dfd6af35ea9d0a50c12ab" translate="yes" xml:space="preserve">
          <source>This will create a new commit which undoes the change in HEAD. You will be given a chance to edit the commit message for the new commit.</source>
          <target state="translated">これにより、HEADの変更を元に戻す新しいコミットが作成されます。新しいコミットのコミットメッセージを編集する機会が与えられます。</target>
        </trans-unit>
        <trans-unit id="85437cd96f5cff3dd194d542498fd954d1bf1e01" translate="yes" xml:space="preserve">
          <source>This will define a remote called &quot;origin&quot; in the resulting repository that lets you fetch and pull from the bundle. The $GIT_DIR/config file in R2 will have an entry like this:</source>
          <target state="translated">これにより、結果として得られるリポジトリに &quot;origin &quot;というリモートが定義され、バンドルをフェッチしたりプルしたりすることができるようになります。R2の$git_dir/configファイルには、このようなエントリがあります。</target>
        </trans-unit>
        <trans-unit id="2986121c6e711f05b2ed0ba772dedbd8c66503ff" translate="yes" xml:space="preserve">
          <source>This will error out if $REV is empty or not a valid revision.</source>
          <target state="translated">これは、$REVが空であるか、有効なリビジョンでない場合にエラーとなります。</target>
        </trans-unit>
        <trans-unit id="c8b7e8566771f37a03bc25eaec95675ffe82ba31" translate="yes" xml:space="preserve">
          <source>This will export the whole repository and import it into the existing empty repository. Except for reencoding commits that are not in UTF-8, it would be a one-to-one mirror.</source>
          <target state="translated">これはリポジトリ全体をエクスポートし、既存の空のリポジトリにインポートします。UTF-8 ではないコミットを再エンコードする以外は、1対1のミラーになります。</target>
        </trans-unit>
        <trans-unit id="5f851e29f67384fe2f487309701055635453a02c" translate="yes" xml:space="preserve">
          <source>This will list what commits you must have in order to extract from the bundle and will error out if you do not have them.</source>
          <target state="translated">これは、バンドルから抽出するために必要なコミットをリストアップし、それを持っていない場合はエラーになります。</target>
        </trans-unit>
        <trans-unit id="7ed8616207d4b6e51bdcbe1e7b524863a0139782" translate="yes" xml:space="preserve">
          <source>This will open your editor with a list of steps to be taken to perform your rebase.</source>
          <target state="translated">これにより、リベースを実行するためのステップのリストがエディタに表示されます。</target>
        </trans-unit>
        <trans-unit id="e9e68cbb3d1c11da9ad7575ebecc630d58996f10" translate="yes" xml:space="preserve">
          <source>This will prompt you for a commit message. You&amp;rsquo;ve now stored the first version of your project in Git.</source>
          <target state="translated">これにより、コミットメッセージの入力が求められます。これで、プロジェクトの最初のバージョンがGitに保存されました。</target>
        </trans-unit>
        <trans-unit id="9229da0c83ee0b71f5a22085b5f3b7e07e9ec55a" translate="yes" xml:space="preserve">
          <source>This will remove each of your commits from mywork, temporarily saving them as patches (in a directory named &lt;code&gt;.git/rebase-apply&lt;/code&gt;), update mywork to point at the latest version of origin, then apply each of the saved patches to the new mywork. The result will look like:</source>
          <target state="translated">これにより、各コミットがmyworkから削除され、一時的にパッチとして（ &lt;code&gt;.git/rebase-apply&lt;/code&gt; という名前のディレクトリに）保存され、myworkが最新バージョンのoriginを指すように更新され、保存された各パッチが新しいmyworkに適用されます。 。結果は次のようになります。</target>
        </trans-unit>
        <trans-unit id="1c98be5284d00528a6b74a33ba778d044a767668" translate="yes" xml:space="preserve">
          <source>This will result in only b (a and c are cleared).</source>
          <target state="translated">これではb(aとcがクリアされている)だけになってしまいます。</target>
        </trans-unit>
        <trans-unit id="0385ed25689cd3e1167020ff6e8ba549d1603871" translate="yes" xml:space="preserve">
          <source>This will set the property &lt;code&gt;svn:keywords&lt;/code&gt; to &lt;code&gt;FreeBSD=%H&lt;/code&gt; for the file &lt;code&gt;devel/py-tipper/Makefile&lt;/code&gt;.</source>
          <target state="translated">これにより、ファイル &lt;code&gt;devel/py-tipper/Makefile&lt;/code&gt; のプロパティ &lt;code&gt;svn:keywords&lt;/code&gt; が &lt;code&gt;FreeBSD=%H&lt;/code&gt; れます。</target>
        </trans-unit>
        <trans-unit id="61383e31770f578e5ee86310440dccd09a4e5008" translate="yes" xml:space="preserve">
          <source>This will show &quot;refs/heads/master&quot; but also &quot;refs/remote/other-repo/master&quot;, if such references exists.</source>
          <target state="translated">これは、&quot;refs/heads/master &quot;だけでなく、&quot;refs/remote/other-repo/master &quot;も表示されます。</target>
        </trans-unit>
        <trans-unit id="23dd2de32c54566f1df1adf9f6794600102b9c2b" translate="yes" xml:space="preserve">
          <source>This will start to clean, and you must confirm one by one in order to delete items. Please note that this action is not as efficient as the above two actions.</source>
          <target state="translated">これでクリーン化が始まりますので、項目を削除するには一つ一つ確認する必要があります。このアクションは上記2つのアクションに比べて効率が悪いので注意してください。</target>
        </trans-unit>
        <trans-unit id="9b7bbd24afc1c6a470a80ef47d5171b33809ea28" translate="yes" xml:space="preserve">
          <source>This works for any of the supported update procedures (&lt;code&gt;--checkout&lt;/code&gt;, &lt;code&gt;--rebase&lt;/code&gt;, etc.). The only change is the source of the target SHA-1. For example, &lt;code&gt;submodule update --remote --merge&lt;/code&gt; will merge upstream submodule changes into the submodules, while &lt;code&gt;submodule update
--merge&lt;/code&gt; will merge superproject gitlink changes into the submodules.</source>
          <target state="translated">これは、サポートされているすべての更新手順（ &lt;code&gt;--checkout&lt;/code&gt; 、-- &lt;code&gt;--rebase&lt;/code&gt; など）で機能します。唯一の変更は、ターゲットSHA-1のソースです。たとえば、 &lt;code&gt;submodule update --remote --merge&lt;/code&gt; はアップストリームサブモジュールの変更をサブモジュールにマージし、サブ &lt;code&gt;submodule update --merge&lt;/code&gt; はスーパープロジェクトのgitlink変更をサブモジュールにマージします。</target>
        </trans-unit>
        <trans-unit id="5a2ee7840b76b59e3aede30738fb578b292bc5f3" translate="yes" xml:space="preserve">
          <source>This works similarly to &lt;code&gt;svn update&lt;/code&gt; or &lt;code&gt;git pull&lt;/code&gt; except that it preserves linear history with &lt;code&gt;git rebase&lt;/code&gt; instead of &lt;code&gt;git merge&lt;/code&gt; for ease of dcommitting with &lt;code&gt;git svn&lt;/code&gt;.</source>
          <target state="translated">これは &lt;code&gt;svn update&lt;/code&gt; や &lt;code&gt;git pull&lt;/code&gt; と同様に機能しますが、 &lt;code&gt;git svn&lt;/code&gt; で簡単にコミットできるように &lt;code&gt;git merge&lt;/code&gt; ではなく &lt;code&gt;git rebase&lt;/code&gt; で線形履歴を保持します。</target>
        </trans-unit>
        <trans-unit id="5bc6c0e59c3e651570d66e12101e9a57040fd659" translate="yes" xml:space="preserve">
          <source>This would leave only one merge commit when your topic branch is finally ready and merged into the master branch. This merge would require you to resolve the conflict, introduced by the commits marked with &lt;code&gt;*&lt;/code&gt;. However, this conflict is often the same conflict you resolved when you created the test merge you blew away. &lt;code&gt;git rerere&lt;/code&gt; helps you resolve this final conflicted merge using the information from your earlier hand resolve.</source>
          <target state="translated">これにより、トピックブランチが最終的に準備され、マスターブランチにマージされるときに、マージコミットが1つだけ残ります。このマージでは、 &lt;code&gt;*&lt;/code&gt; でマークされたコミットによって引き起こされる競合を解決する必要があります。ただし、この競合は多くの場合、吹き飛ばしたテストマージを作成したときに解決したものと同じです。 &lt;code&gt;git rerere&lt;/code&gt; は、以前の手の解決からの情報を使用して、この最終的な競合するマージを解決するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="dcd6f908de988995d9fff4cafd75d14bc0785c1a" translate="yes" xml:space="preserve">
          <source>This would leave the merge result in &lt;code&gt;hello.c~2&lt;/code&gt; file, along with conflict markers if there are conflicts. After verifying the merge result makes sense, you can tell Git what the final merge result for this file is by:</source>
          <target state="translated">これにより、競合がある場合は競合マーカーとともに、マージ結果が &lt;code&gt;hello.c~2&lt;/code&gt; ファイルに残ります。マージ結果が正しいことを確認したら、次のようにして、このファイルの最終的なマージ結果をGitに通知できます。</target>
        </trans-unit>
        <trans-unit id="cf5b7c750a4b16617dfd7cff20be48990a9d7985" translate="yes" xml:space="preserve">
          <source>This:</source>
          <target state="translated">This:</target>
        </trans-unit>
        <trans-unit id="ee3cacca7314105556d3050112f523980e59f973" translate="yes" xml:space="preserve">
          <source>Those snapshots aren&amp;rsquo;t necessarily all arranged in a single line from oldest to newest; instead, work may simultaneously proceed along parallel lines of development, called &lt;a href=&quot;#def_branch&quot;&gt;branches&lt;/a&gt;, which may merge and diverge.</source>
          <target state="translated">これらのスナップショットは、必ずしもすべてが古いものから新しいものへと1行に配置されているとは限りません。代わりに、&lt;a href=&quot;#def_branch&quot;&gt;ブランチ&lt;/a&gt;と呼ばれる並行した開発ラインに沿って作業が同時に進行し、マージおよび分岐する場合があります。</target>
        </trans-unit>
        <trans-unit id="7a5a53a50d0fbac4f3a27d9d2d5853146557d940" translate="yes" xml:space="preserve">
          <source>Though not required, it&amp;rsquo;s a good idea to begin the commit message with a single short (less than 50 character) line summarizing the change, followed by a blank line and then a more thorough description. The text up to the first blank line in a commit message is treated as the commit title, and that title is used throughout Git. For example, &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt; turns a commit into email, and it uses the title on the Subject line and the rest of the commit in the body.</source>
          <target state="translated">必須ではありませんが、変更を要約した単一の短い（50文字未満）行でコミットメッセージを開始し、その後に空白行を入れてから、より詳細な説明を付けることをお勧めします。コミットメッセージの最初の空白行までのテキストはコミットタイトルとして扱われ、そのタイトルはGit全体で使用されます。たとえば、&lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]&lt;/a&gt;はコミットをメールに変換し、件名のタイトルと本文の残りのコミットを使用します。</target>
        </trans-unit>
        <trans-unit id="fdd6ea0498f5dbe48e6926bc8c91e77146fa2184" translate="yes" xml:space="preserve">
          <source>Though, according to Wikipedia &lt;a href=&quot;#3&quot;&gt;[3]&lt;/a&gt;:</source>
          <target state="translated">しかし、ウィキペディアによれば&lt;a href=&quot;#3&quot;&gt;[3]&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="18c9e3ce5bbbf77af11ba41f4d7a7d9b7a1aaa55" translate="yes" xml:space="preserve">
          <source>Thread Events</source>
          <target state="translated">スレッドイベント</target>
        </trans-unit>
        <trans-unit id="8850eee2783cf53d0af71d524467316d7d06a850" translate="yes" xml:space="preserve">
          <source>Thread messages added to a thread-proc.</source>
          <target state="translated">スレッドメッセージがスレッドプロックに追加されました。</target>
        </trans-unit>
        <trans-unit id="1501e9d814d273ed34cc6b50f1b5e25add4ac049" translate="yes" xml:space="preserve">
          <source>Three other shorthands exist, particularly useful for merge commits, for naming a set that is formed by a commit and its parent commits.</source>
          <target state="translated">他にも3つの短縮形があります。特にマージコミットでは、コミットとその親コミットで形成されるセットの名前を付けるのに便利です。</target>
        </trans-unit>
        <trans-unit id="8e23a87c8354d34eb4b513798d76048267e22ae4" translate="yes" xml:space="preserve">
          <source>Three steps:</source>
          <target state="translated">3つのステップ。</target>
        </trans-unit>
        <trans-unit id="cf3d01be00b3333c6ca36b4d1bb0a1a1c357a43f" translate="yes" xml:space="preserve">
          <source>Throw-away integration</source>
          <target state="translated">スローアウェイ統合</target>
        </trans-unit>
        <trans-unit id="c4780f4837eebde8ca1de31df251ef05e2361eb2" translate="yes" xml:space="preserve">
          <source>Thunderbird</source>
          <target state="translated">Thunderbird</target>
        </trans-unit>
        <trans-unit id="d5e84648e0355ba1080675ff57a3c64a03a76a7c" translate="yes" xml:space="preserve">
          <source>Thunderbird in particular is known to be problematic. Thunderbird users may wish to visit this web page for more information: &lt;a href=&quot;http://kb.mozillazine.org/Plain_text_e-mail_-_Thunderbird#Completely_plain_email&quot;&gt;http://kb.mozillazine.org/Plain_text_e-mail_-_Thunderbird#Completely_plain_email&lt;/a&gt;</source>
          <target state="translated">特にThunderbirdには問題があることが知られています。詳細については、ThunderbirdユーザーがこのWebページにアクセスすることをお&lt;a href=&quot;http://kb.mozillazine.org/Plain_text_e-mail_-_Thunderbird#Completely_plain_email&quot;&gt;勧めし&lt;/a&gt;ます。http：//kb.mozillazine.org/Plain_text_e-mail_-_Thunderbird#Completely_plain_email</target>
        </trans-unit>
        <trans-unit id="da473e9b687406079cfbc2672fddb50595865b5d" translate="yes" xml:space="preserve">
          <source>Thus we see that this tree has one file in it. The SHA-1 hash is a reference to that file&amp;rsquo;s data:</source>
          <target state="translated">したがって、このツリーには1つのファイルが含まれていることがわかります。SHA-1ハッシュは、そのファイルのデータへの参照です。</target>
        </trans-unit>
        <trans-unit id="309fb29079c2e5019b9d34cb235aee0452735a40" translate="yes" xml:space="preserve">
          <source>Thus you can, e.g., turn a library subdirectory into a repository of its own. Note the &lt;code&gt;--&lt;/code&gt; that separates &lt;code&gt;filter-branch&lt;/code&gt; options from revision options, and the &lt;code&gt;--all&lt;/code&gt; to rewrite all branches and tags.</source>
          <target state="translated">したがって、たとえば、ライブラリサブディレクトリを独自のリポジトリに変えることができます。 &lt;code&gt;filter-branch&lt;/code&gt; オプションとリビジョンオプションを区切る &lt;code&gt;--&lt;/code&gt; と、すべてのブランチとタグを書き換える &lt;code&gt;--all&lt;/code&gt; に注意してください。</target>
        </trans-unit>
        <trans-unit id="d35ca4f0ad7715e9f69a7f979c2424eb99273503" translate="yes" xml:space="preserve">
          <source>Thus, the following command:</source>
          <target state="translated">したがって、次のようなコマンドがあります。</target>
        </trans-unit>
        <trans-unit id="77cc1ec67e1af48d92e062ee397960be200bdf58" translate="yes" xml:space="preserve">
          <source>Thus, we can provide O(log N) lookup time for any number of packfiles.</source>
          <target state="translated">このようにして、我々は任意の数のpackfileに対してO(log N)のルックアップ時間を提供することができます。</target>
        </trans-unit>
        <trans-unit id="ae19d34e63a0724afdaaeabe3d0fe80af7f9e778" translate="yes" xml:space="preserve">
          <source>Time and date specified by the ISO 8601 standard, for example &lt;code&gt;2005-04-07T22:13:13&lt;/code&gt;. The parser accepts a space instead of the &lt;code&gt;T&lt;/code&gt; character as well.</source>
          <target state="translated">ISO 8601標準で指定された日時（例 &lt;code&gt;2005-04-07T22:13:13&lt;/code&gt; 。パーサーは、 &lt;code&gt;T&lt;/code&gt; 文字の代わりにスペースも受け入れます。</target>
        </trans-unit>
        <trans-unit id="3919d9be78625e6edbfd2764a9b0e03204c6c677" translate="yes" xml:space="preserve">
          <source>Time and date specified by the ISO 8601 standard, for example &lt;code&gt;2005-04-07T22:13:13&lt;/code&gt;. The parser accepts a space instead of the &lt;code&gt;T&lt;/code&gt; character as well. Fractional parts of a second will be ignored, for example &lt;code&gt;2005-04-07T22:13:13.019&lt;/code&gt; will be treated as &lt;code&gt;2005-04-07T22:13:13&lt;/code&gt;.</source>
          <target state="translated">ISO 8601規格で指定されている日時（例 &lt;code&gt;2005-04-07T22:13:13&lt;/code&gt; 。パーサーは、 &lt;code&gt;T&lt;/code&gt; 文字の代わりにスペースも受け入れます。秒の &lt;code&gt;2005-04-07T22:13:13.019&lt;/code&gt; 部分は無視されます。たとえば、2005-04-07T22：13：13.019は &lt;code&gt;2005-04-07T22:13:13&lt;/code&gt; として扱われます。</target>
        </trans-unit>
        <trans-unit id="0bac72478f018c225224e8417f521a2dad6209d3" translate="yes" xml:space="preserve">
          <source>Time zone values can be &quot;local&quot; (for local time zone that browser uses), &quot;utc&quot; (what gitweb uses when JavaScript or this feature is disabled), or numerical time zones in the form of &quot;+/-HHMM&quot;, such as &quot;+0200&quot;.</source>
          <target state="translated">タイムゾーンの値は、&quot;local&quot;(ブラウザが使用するローカルタイムゾーンの場合)、&quot;utc &quot;のいずれかになります。(JavaScript やこの機能が無効になっているときに gitweb が使用するもの)、あるいは &quot;+/HHMM&quot; のような形でタイムゾーンを数値化したもの、たとえば &quot;+0200&quot; のようなものです。</target>
        </trans-unit>
        <trans-unit id="396a560fd1658574279d941c34737eda5359f4fc" translate="yes" xml:space="preserve">
          <source>Timeout (in seconds) between the moment the connection is established and the client request is received (typically a rather low value, since that should be basically immediate).</source>
          <target state="translated">接続が確立されてからクライアントのリクエストを受信するまでのタイムアウト(秒単位)。</target>
        </trans-unit>
        <trans-unit id="0ae2f4dfeb0fa0aaf2833b3c271308d2190a4162" translate="yes" xml:space="preserve">
          <source>Timeout (in seconds) for specific client sub-requests. This includes the time it takes for the server to process the sub-request and the time spent waiting for the next client&amp;rsquo;s request.</source>
          <target state="translated">特定のクライアントサブリクエストのタイムアウト（秒単位）。これには、サーバーがサブリクエストを処理するのにかかる時間と、次のクライアントのリクエストを待つのに費やされる時間が含まれます。</target>
        </trans-unit>
        <trans-unit id="ad6b83abe0aada0e5e6aec8e7e7470429fd4ee37" translate="yes" xml:space="preserve">
          <source>Tips and tricks</source>
          <target state="translated">コツとコツ</target>
        </trans-unit>
        <trans-unit id="d7242682d2f91b131962f45ed3706e536d3cdcc6" translate="yes" xml:space="preserve">
          <source>To &lt;a href=&quot;#def_merge&quot;&gt;merge&lt;/a&gt; more than two &lt;a href=&quot;#def_branch&quot;&gt;branches&lt;/a&gt;.</source>
          <target state="translated">3 つ以上の&lt;a href=&quot;#def_branch&quot;&gt;ブランチ&lt;/a&gt;を&lt;a href=&quot;#def_merge&quot;&gt;マージ&lt;/a&gt;する。</target>
        </trans-unit>
        <trans-unit id="f7305ba472ceab96976009902e7b731f8e52f311" translate="yes" xml:space="preserve">
          <source>To access refs, it&amp;rsquo;s best not to look inside &lt;code&gt;$GIT_DIR&lt;/code&gt; directly. Instead use commands such as &lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse[1]&lt;/a&gt; or &lt;a href=&quot;git-update-ref&quot;&gt;git-update-ref[1]&lt;/a&gt; which will handle refs correctly.</source>
          <target state="translated">参照にアクセスするには、 &lt;code&gt;$GIT_DIR&lt;/code&gt; 内部を直接調べないことをお勧めします。代わりに、&lt;a href=&quot;git-update-ref&quot;&gt;参照を&lt;/a&gt;正しく処理&lt;a href=&quot;git-rev-parse&quot;&gt;するgit-rev-parse [1]&lt;/a&gt;やgit-update-ref [1]などのコマンドを使用してください。</target>
        </trans-unit>
        <trans-unit id="7c181af3380fe2a4df836df7796a5de6ef8d47c5" translate="yes" xml:space="preserve">
          <source>To access refs, it&amp;rsquo;s best not to look inside GIT_DIR directly. Instead use commands such as &lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse[1]&lt;/a&gt; or &lt;a href=&quot;git-update-ref&quot;&gt;git-update-ref[1]&lt;/a&gt; which will handle refs correctly.</source>
          <target state="translated">refにアクセスするには、GIT_DIRの内部を直接調べないことをお勧めします。代わりに、&lt;a href=&quot;git-update-ref&quot;&gt;リファレンスを&lt;/a&gt;正しく処理&lt;a href=&quot;git-rev-parse&quot;&gt;するgit-rev-parse [1]&lt;/a&gt;やgit-update-ref [1]などのコマンドを使用してください。</target>
        </trans-unit>
        <trans-unit id="bdc5ec95e827bdeffd1f9aab0bef5dd1e05d0443" translate="yes" xml:space="preserve">
          <source>To achieve this, try to split your work into small steps from the very beginning. It is always easier to squash a few commits together than to split one big commit into several. Don&amp;rsquo;t be afraid of making too small or imperfect steps along the way. You can always go back later and edit the commits with &lt;code&gt;git rebase --interactive&lt;/code&gt; before you publish them. You can use &lt;code&gt;git stash push --keep-index&lt;/code&gt; to run the test suite independent of other uncommitted changes; see the EXAMPLES section of &lt;a href=&quot;git-stash&quot;&gt;git-stash[1]&lt;/a&gt;.</source>
          <target state="translated">これを達成するには、最初から作業を小さなステップに分割してみてください。 1つの大きなコミットをいくつかに分割するよりも、いくつかのコミットをつぶす方が常に簡単です。途中で小さすぎる、または不完全なステップを作成することを恐れないでください。いつでも後で戻って、公開する前に &lt;code&gt;git rebase --interactive&lt;/code&gt; でコミットを編集できます。 &lt;code&gt;git stash push --keep-index&lt;/code&gt; を使用して、他のコミットされていない変更とは関係なくテストスイートを実行できます。&lt;a href=&quot;git-stash&quot;&gt;git-stash [1]の「使用&lt;/a&gt;例」セクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="0fad63887775e60c970096082173b077cbcda459" translate="yes" xml:space="preserve">
          <source>To actually match only values with an exclamation mark, you have to</source>
          <target state="translated">感嘆符のついた値だけを実際にマッチさせるには、次のようにしなければなりません。</target>
        </trans-unit>
        <trans-unit id="0fea0d3a69770ac7053eba17165f8f811c0d830f" translate="yes" xml:space="preserve">
          <source>To add a new proxy, without altering any of the existing ones, use</source>
          <target state="translated">既存のプロキシを変更せずに新しいプロキシを追加するには</target>
        </trans-unit>
        <trans-unit id="6a37f3f129452efb4608e170beca8c23ff8dc189" translate="yes" xml:space="preserve">
          <source>To aid in debugging frontends fast-import ignores any line that begins with &lt;code&gt;#&lt;/code&gt; (ASCII pound/hash) up to and including the line ending &lt;code&gt;LF&lt;/code&gt;. A comment line may contain any sequence of bytes that does not contain an LF and therefore may be used to include any detailed debugging information that might be specific to the frontend and useful when inspecting a fast-import data stream.</source>
          <target state="translated">フロントエンドのデバッグを支援するために、高速インポートは &lt;code&gt;#&lt;/code&gt; （ASCIIポンド/ハッシュ）で始まり &lt;code&gt;LF&lt;/code&gt; までの行を含むすべての行を無視します。コメント行には、LFを含まないバイトシーケンスを含めることができるため、フロントエンドに固有であり、高速インポートデータストリームを検査するときに役立つ詳細なデバッグ情報を含めるために使用できます。</target>
        </trans-unit>
        <trans-unit id="285359187a2aff04e4ea763b2f3e4bbaf641190b" translate="yes" xml:space="preserve">
          <source>To assist in this, Git also provides the tag object&amp;hellip;​</source>
          <target state="translated">これを支援するために、Gitはタグオブジェクトも提供しています&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="39ed0e01aa6b6521a62db21f8653937d0b5ccadd" translate="yes" xml:space="preserve">
          <source>To avoid common misconfiguration mistakes, &lt;a href=&quot;git-send-email&quot;&gt;git-send-email[1]&lt;/a&gt; will abort with a warning if any configuration options for &quot;sendmail&quot; exist. Set this variable to bypass the check.</source>
          <target state="translated">一般的な設定ミスを回避するために、「sendmail」の設定オプションが存在する場合、&lt;a href=&quot;git-send-email&quot;&gt;git-send-email [1]&lt;/a&gt;は警告とともに中止します。チェックをバイパスするには、この変数を設定します。</target>
        </trans-unit>
        <trans-unit id="b0021f1eb05e23f63eb7ccc2f58c52546ee61585" translate="yes" xml:space="preserve">
          <source>To avoid deadlock, such frontends must completely consume any pending output from &lt;code&gt;progress&lt;/code&gt;, &lt;code&gt;ls&lt;/code&gt;, &lt;code&gt;get-mark&lt;/code&gt;, and &lt;code&gt;cat-blob&lt;/code&gt; before performing writes to fast-import that might block.</source>
          <target state="translated">デッドロックを回避するために、このようなフロントエンドは、ブロックする可能性がある高速インポートへの書き込みを実行する前に、 &lt;code&gt;progress&lt;/code&gt; 、 &lt;code&gt;ls&lt;/code&gt; 、 &lt;code&gt;get-mark&lt;/code&gt; 、および &lt;code&gt;cat-blob&lt;/code&gt; からの保留中の出力を完全に消費する必要があります。</target>
        </trans-unit>
        <trans-unit id="75e1daad195d404dc835c71216234df4a4676d4e" translate="yes" xml:space="preserve">
          <source>To avoid deleting a shared index file that is still used, its modification time is updated to the current time every time a new split index based on the shared index file is either created or read from.</source>
          <target state="translated">まだ使用されている共有インデックスファイルを削除しないようにするために、共有インデックスファイルに基づく新しいスプリットインデックスが作成されるたびに、その変更時刻が現在の時刻に更新されます。</target>
        </trans-unit>
        <trans-unit id="0b95bb4f949904cf33707d2a81be23c345f8e5aa" translate="yes" xml:space="preserve">
          <source>To avoid false positives (e.g. when a patch has been removed, and an unrelated patch has been added between two iterations of the same patch series), the cost matrix is extended to allow for that, by adding fixed-cost entries for wholesale deletes/adds.</source>
          <target state="translated">誤検出(例えば、パッチが削除され、同じパッチシリーズの2回の繰り返しの間に関連のないパッチが追加された場合など)を避けるために、コストマトリックスは、ホールセール削除/追加のための固定コストエントリを追加することで、それを可能にするように拡張されています。</target>
        </trans-unit>
        <trans-unit id="0fd573776931ed5e5643654b60eb3896366ed973" translate="yes" xml:space="preserve">
          <source>To avoid interfering with other worktrees, it first enables the &lt;code&gt;extensions.worktreeConfig&lt;/code&gt; setting and makes sure to set the &lt;code&gt;core.sparseCheckout&lt;/code&gt; setting in the worktree-specific config file.</source>
          <target state="translated">他のワークツリーとの干渉を回避するために、最初に &lt;code&gt;extensions.worktreeConfig&lt;/code&gt; 設定を有効にし、ワークツリー固有の構成ファイルで &lt;code&gt;core.sparseCheckout&lt;/code&gt; 設定を必ず設定します。</target>
        </trans-unit>
        <trans-unit id="3c2082115575958e10a9c1afdaf9ab0c9127b12a" translate="yes" xml:space="preserve">
          <source>To avoid recording unrelated changes in the merge commit, &lt;code&gt;git pull&lt;/code&gt; and &lt;code&gt;git merge&lt;/code&gt; will also abort if there are any changes registered in the index relative to the &lt;code&gt;HEAD&lt;/code&gt; commit. (Special narrow exceptions to this rule may exist depending on which merge strategy is in use, but generally, the index must match HEAD.)</source>
          <target state="translated">マージコミットで無関係な変更が記録されないように、 &lt;code&gt;HEAD&lt;/code&gt; コミットに関連するインデックスに変更が登録されている場合、 &lt;code&gt;git pull&lt;/code&gt; と &lt;code&gt;git merge&lt;/code&gt; も中止されます。（使用しているマージ戦略によっては、このルールに対する特別な狭い例外が存在する場合がありますが、通常、インデックスはHEADと一致する必要があります。）</target>
        </trans-unit>
        <trans-unit id="3066556f3c40d15744968614a5fc8c1e23bf8a7b" translate="yes" xml:space="preserve">
          <source>To avoid typing long email addresses, point this to one or more email aliases files. You must also supply &lt;code&gt;sendemail.aliasFileType&lt;/code&gt;.</source>
          <target state="translated">長いメールアドレスを入力しないようにするには、これを1つ以上のメールエイリアスファイルにポイントします。 &lt;code&gt;sendemail.aliasFileType&lt;/code&gt; も指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="c4b87fbf313d264308ea989e0e3b9a4c3d776c25" translate="yes" xml:space="preserve">
          <source>To bootstrap the process, you can first create a bundle that does not have any basis. You can use a tag to remember up to what commit you last processed, in order to make it easy to later update the other repository with an incremental bundle:</source>
          <target state="translated">プロセスをブートストラップするには、まずベースを持たないバンドルを作成します。タグを使って最後に処理したコミットまで覚えておくことで、後からインクリメンタルバンドルで他のリポジトリを更新しやすくすることができます。</target>
        </trans-unit>
        <trans-unit id="9d8840568125195e79747db7654d577582e9ce27" translate="yes" xml:space="preserve">
          <source>To change which notes are shown by &lt;code&gt;git log&lt;/code&gt;, see the &quot;notes.displayRef&quot; configuration in &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;git log&lt;/code&gt; で表示されるメモを変更するには、&lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt;の「notes.displayRef」設定を参照してください。</target>
        </trans-unit>
        <trans-unit id="97883ec3271fcc02269394ee0880b3655a6f452f" translate="yes" xml:space="preserve">
          <source>To check out commit &lt;code&gt;HEAD~3&lt;/code&gt; for temporary inspection or experiment without creating a new branch:</source>
          <target state="translated">新しいブランチを作成せずに一時的な検査または実験のためにコミット &lt;code&gt;HEAD~3&lt;/code&gt; をチェックアウトするには：</target>
        </trans-unit>
        <trans-unit id="d144f3be27bf6711b21fc83fdbf3f1e8ff9fc321" translate="yes" xml:space="preserve">
          <source>To commit a tree you have instantiated with &lt;code&gt;git write-tree&lt;/code&gt;, you&amp;rsquo;d create a &quot;commit&quot; object that refers to that tree and the history behind it&amp;mdash;​most notably the &quot;parent&quot; commits that preceded it in history.</source>
          <target state="translated">&lt;code&gt;git write-tree&lt;/code&gt; でインスタンス化したツリーをコミットするには、そのツリーとその背後の履歴を参照する「コミット」オブジェクトを作成します。特に、履歴の前にある「親」コミットが顕著です。</target>
        </trans-unit>
        <trans-unit id="05e44c536d85ee3801aa2c0d698cefa8d09c4c33" translate="yes" xml:space="preserve">
          <source>To completely remove a submodule, manually delete &lt;code&gt;$GIT_DIR/modules/&amp;lt;name&amp;gt;/&lt;/code&gt;.</source>
          <target state="translated">サブモジュールを完全に削除するには、 &lt;code&gt;$GIT_DIR/modules/&amp;lt;name&amp;gt;/&lt;/code&gt; 手動で削除します。</target>
        </trans-unit>
        <trans-unit id="27c15a86c7e79c3805e163825e563ceb0da18b5a" translate="yes" xml:space="preserve">
          <source>To control which revisions to show, gitk supports most options applicable to the &lt;code&gt;git rev-list&lt;/code&gt; command. It also supports a few options applicable to the &lt;code&gt;git diff-*&lt;/code&gt; commands to control how the changes each commit introduces are shown. Finally, it supports some gitk-specific options.</source>
          <target state="translated">表示するリビジョンを制御するために、gitkは &lt;code&gt;git rev-list&lt;/code&gt; コマンドに適用できるほとんどのオプションをサポートしています。また、 &lt;code&gt;git diff-*&lt;/code&gt; コマンドに適用可能ないくつかのオプションをサポートし、各コミットがもたらす変更の表示方法を制御します。最後に、いくつかのgitk固有のオプションをサポートしています。</target>
        </trans-unit>
        <trans-unit id="777e371b82028c9765bc912013f44d79febb95a6" translate="yes" xml:space="preserve">
          <source>To cope with such a situation, after the inner &lt;code&gt;git bisect&lt;/code&gt; finds the next revision to test, the script can apply the patch before compiling, run the real test, and afterwards decide if the revision (possibly with the needed patch) passed the test and then rewind the tree to the pristine state. Finally the script should exit with the status of the real test to let the &lt;code&gt;git bisect run&lt;/code&gt; command loop determine the eventual outcome of the bisect session.</source>
          <target state="translated">このような状況に対処するため、内部 &lt;code&gt;git bisect&lt;/code&gt; がテストする次のリビジョンを見つけた後、スクリプトはコンパイルする前にパッチを適用し、実際のテストを実行し、その後、リビジョン（おそらく必要なパッチを含む）がテストに合格したかどうかを判断します。次に、ツリーを元の状態に戻します。最後に、スクリプトは実際のテストのステータスで終了し、 &lt;code&gt;git bisect run&lt;/code&gt; コマンドループがbisectセッションの最終的な結果を決定できるようにします。</target>
        </trans-unit>
        <trans-unit id="8674c1ca562e6ecc34e19d2429ea897e7602bd28" translate="yes" xml:space="preserve">
          <source>To create your own local live copy of such a &quot;raw&quot; Git repository, you&amp;rsquo;d first create your own subdirectory for the project, and then copy the raw repository contents into the &lt;code&gt;.git&lt;/code&gt; directory. For example, to create your own copy of the Git repository, you&amp;rsquo;d do the following</source>
          <target state="translated">そのような「生の」Gitリポジトリの独自のローカルライブコピーを作成するには、まずプロジェクト用に独自のサブディレクトリを作成し、次に生のリポジトリコンテンツを &lt;code&gt;.git&lt;/code&gt; ディレクトリにコピーします。たとえば、Gitリポジトリの独自のコピーを作成するには、次のようにします。</target>
        </trans-unit>
        <trans-unit id="495be7922d2a293092e6f366efd8045104e01478" translate="yes" xml:space="preserve">
          <source>To define a custom merge driver &lt;code&gt;filfre&lt;/code&gt;, add a section to your &lt;code&gt;$GIT_DIR/config&lt;/code&gt; file (or &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; file) like this:</source>
          <target state="translated">カスタムマージドライバー &lt;code&gt;filfre&lt;/code&gt; を定義するには、次のようにセクションを &lt;code&gt;$GIT_DIR/config&lt;/code&gt; ファイル（または &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; ファイル）に追加します。</target>
        </trans-unit>
        <trans-unit id="369d97c17e3edbb633e139fcbb4d6a1ea94c1201" translate="yes" xml:space="preserve">
          <source>To define an external diff driver &lt;code&gt;jcdiff&lt;/code&gt;, add a section to your &lt;code&gt;$GIT_DIR/config&lt;/code&gt; file (or &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; file) like this:</source>
          <target state="translated">外部差分ドライバー &lt;code&gt;jcdiff&lt;/code&gt; を定義するには、次のように &lt;code&gt;$GIT_DIR/config&lt;/code&gt; ファイル（または &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; ファイル）にセクションを追加します。</target>
        </trans-unit>
        <trans-unit id="302897a013466c7a33ee45af87c508a98422abd4" translate="yes" xml:space="preserve">
          <source>To delete the entry for renames, do</source>
          <target state="translated">リネームのエントリを削除するには、次のようにします。</target>
        </trans-unit>
        <trans-unit id="f31f6b0ae1c80bea942e287ae0ab318c31ede1f4" translate="yes" xml:space="preserve">
          <source>To determine the location of the repository on disk, &lt;code&gt;git http-backend&lt;/code&gt; concatenates the environment variables PATH_INFO, which is set automatically by the web server, and GIT_PROJECT_ROOT, which must be set manually in the web server configuration. If GIT_PROJECT_ROOT is not set, &lt;code&gt;git http-backend&lt;/code&gt; reads PATH_TRANSLATED, which is also set automatically by the web server.</source>
          <target state="translated">ディスク上のリポジトリの場所を特定するために、 &lt;code&gt;git http-backend&lt;/code&gt; は、Webサーバーによって自動的に設定される環境変数PATH_INFOと、Webサーバー構成で手動で設定する必要があるGIT_PROJECT_ROOTを連結します。GIT_PROJECT_ROOTが設定されていない場合、 &lt;code&gt;git http-backend&lt;/code&gt; はPATH_TRANSLATEDを読み取ります。これもWebサーバーによって自動的に設定されます。</target>
        </trans-unit>
        <trans-unit id="b99f7180a07f9dbb13dde063c76c98dd5e2d7887" translate="yes" xml:space="preserve">
          <source>To disable features that accept parameters (are configurable), you need to set this element to empty list i.e. &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">パラメーターを受け入れる（構成可能）機能を無効にするには、この要素を空のリスト、つまり &lt;code&gt;[]&lt;/code&gt; に設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="43f3c91605c9cb6d680c0ea9cf4c1bb2e77b4d9d" translate="yes" xml:space="preserve">
          <source>To disable interactive logins, displaying a greeting instead:</source>
          <target state="translated">インタラクティブログインを無効にするには、代わりに挨拶を表示します。</target>
        </trans-unit>
        <trans-unit id="2e78622c40c98dec97477af783b12ba20d12cc1a" translate="yes" xml:space="preserve">
          <source>To display the &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt; man page, use &lt;code&gt;git help git&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;git&quot;&gt;git [1]の&lt;/a&gt; manページを表示するには、 &lt;code&gt;git help git&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="fa4dddf358b16e56494c90923230fd025e6f958d" translate="yes" xml:space="preserve">
          <source>To do automatic tag object dereferencing, use the &quot;-d&quot; or &quot;--dereference&quot; flag, so you can do</source>
          <target state="translated">タグオブジェクトの自動参照を行うには、&quot;-d&quot; または &quot;--dereference&quot; フラグを使用します。</target>
        </trans-unit>
        <trans-unit id="dc05ce874d6baee1eae11d94d6fd56f1e0a6d0ed" translate="yes" xml:space="preserve">
          <source>To do the merge, do</source>
          <target state="translated">マージを行うには、次のようにします。</target>
        </trans-unit>
        <trans-unit id="45ed93b09b65e276ec2ef33a1d9d7c3e10d14bfe" translate="yes" xml:space="preserve">
          <source>To do this, the current maintenance branch is copied to another branch named with the previous release version number (e.g. maint-X.Y.(Z-1) where X.Y.Z is the current release).</source>
          <target state="translated">これを行うには、現在のメンテナンスブランチを、前のリリースのバージョン番号を持つ別のブランチにコピーします (例:maint-X.Y.(Z-1)X.Y.Z は現在のリリースです)。</target>
        </trans-unit>
        <trans-unit id="380aa6a091a04ad8bbf89399d1982760e370374e" translate="yes" xml:space="preserve">
          <source>To drop a commit, replace the command &quot;pick&quot; with &quot;drop&quot;, or just delete the matching line.</source>
          <target state="translated">コミットを削除するには、コマンド &quot;pick&quot; を &quot;drop&quot; に置き換えるか、一致する行を削除します。</target>
        </trans-unit>
        <trans-unit id="e05b8854f808624747710c5e1d641ee4dabaf30c" translate="yes" xml:space="preserve">
          <source>To elaborate, &quot;reading&quot; means checking for file existence, reading file attributes or file content. The working directory version may be present or absent. If present, its content may match against the index version or not. Writing is not affected by this bit, content safety is still first priority. Note that Git &lt;code&gt;can&lt;/code&gt; update working directory file, that is marked skip-worktree, if it is safe to do so (i.e. working directory version matches index version)</source>
          <target state="translated">詳しく説明すると、「読み取り」とは、ファイルの存在を確認すること、ファイル属性またはファイルの内容を読み取ることを意味します。作業ディレクトリのバージョンが存在する場合と存在しない場合があります。存在する場合、そのコンテンツはインデックスバージョンと一致するかどうかにかかわらず、一致しない場合があります。書き込みはこのビットの影響を受けません。コンテンツの安全性は依然として最優先事項です。Git は、安全に実行できる場合は、skip-worktreeとマークされている作業ディレクトリファイル &lt;code&gt;can&lt;/code&gt; 更新できることに注意してください（つまり、作業ディレクトリのバージョンはインデックスのバージョンと一致します）。</target>
        </trans-unit>
        <trans-unit id="64ecd7272d648bbcdba5e527a1a80e43cb0705c5" translate="yes" xml:space="preserve">
          <source>To enable &lt;code&gt;git archive --remote&lt;/code&gt; and disable &lt;code&gt;git fetch&lt;/code&gt; against a repository, have the following in the configuration file in the repository (that is the file &lt;code&gt;config&lt;/code&gt; next to &lt;code&gt;HEAD&lt;/code&gt;, &lt;code&gt;refs&lt;/code&gt; and &lt;code&gt;objects&lt;/code&gt;).</source>
          <target state="translated">有効にするには &lt;code&gt;git archive --remote&lt;/code&gt; し、無効に &lt;code&gt;git fetch&lt;/code&gt; （ファイルのあるリポジトリ内の構成ファイルに次のように持って、リポジトリに対して &lt;code&gt;config&lt;/code&gt; 次へ &lt;code&gt;HEAD&lt;/code&gt; 、 &lt;code&gt;refs&lt;/code&gt; および &lt;code&gt;objects&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="af7d8457fff28a2087e0f74bc51d0468026a9bff" translate="yes" xml:space="preserve">
          <source>To enable a target, set the corresponding environment variable or system or global config value to one of the following:</source>
          <target state="translated">ターゲットを有効にするには、対応する環境変数、システムまたはグローバル設定値を以下のいずれかに設定します。</target>
        </trans-unit>
        <trans-unit id="01e6eac26c3bbc386ab13c8cd6a9167801f24836" translate="yes" xml:space="preserve">
          <source>To enable anonymous read access but authenticated write access, require authorization for both the initial ref advertisement (which we detect as a push via the service parameter in the query string), and the receive-pack invocation itself:</source>
          <target state="translated">匿名の読み取りアクセスと認証された書き込みアクセスを可能にするには、最初の ref 広告 (クエリ文字列のサービス・パラメータを介したプッシュとして検出されます)と受信パックの呼び出し自体の両方に認証が必要です。</target>
        </trans-unit>
        <trans-unit id="9bda367b82f8881561a1128afb27f36988891c35" translate="yes" xml:space="preserve">
          <source>To enable anonymous read access but authenticated write access:</source>
          <target state="translated">匿名の読み取りアクセスを有効にするが、認証された書き込みアクセスを有効にする。</target>
        </trans-unit>
        <trans-unit id="050d5472dcd3f05f019f9a8129d0bb6d5e205df8" translate="yes" xml:space="preserve">
          <source>To enable blame, pickaxe search, and snapshot support (allowing &quot;tar.gz&quot; and &quot;zip&quot; snapshots), while allowing individual projects to turn them off, put the following in your GITWEB_CONFIG file:</source>
          <target state="translated">blame、pickaxe 検索、スナップショットのサポートを有効にし(&quot;tar.gz&quot; と &quot;zip&quot; スナップショットを許可)、個々のプロジェクトでそれらをオフにするには、GITWEB_CONFIG ファイルに以下のように記述します。</target>
        </trans-unit>
        <trans-unit id="fa7174e314ce7012972664ac5bcf82d4b390a6d5" translate="yes" xml:space="preserve">
          <source>To enable git-cvsserver access (which should generally have the &lt;code&gt;no-interactive-login&lt;/code&gt; example above as a prerequisite, as creating the git-shell-commands directory allows interactive logins):</source>
          <target state="translated">git-cvsserverアクセス​​を有効にするには（通常、git-shell-commandsディレクトリを作成するとインタラクティブなログインが可能になるため、上記の &lt;code&gt;no-interactive-login&lt;/code&gt; の例を前提条件とする必要があります）：</target>
        </trans-unit>
        <trans-unit id="69aa803d2928631745bb26ea6d720a34de175dd7" translate="yes" xml:space="preserve">
          <source>To enable that additional nice feature, when a bisection is started and when some good commits are not ancestors of the bad commit, we first compute the merge bases between the bad and the good commits and we chose these merge bases as the first commits that will be checked out and tested.</source>
          <target state="translated">この追加機能を有効にするために、二分法が開始され、いくつかの良いコミットが悪いコミットの祖先ではない場合には、まず悪いコミットと良いコミットのマージベースを計算し、これらのマージベースを最初にチェックアウトしてテストするコミットとして選択します。</target>
        </trans-unit>
        <trans-unit id="ba44f6ad0a0230b79b3149aabc029b57fd7f22d9" translate="yes" xml:space="preserve">
          <source>To enable the sparse-checkout feature, run &lt;code&gt;git sparse-checkout init&lt;/code&gt; to initialize a simple sparse-checkout file and enable the &lt;code&gt;core.sparseCheckout&lt;/code&gt; config setting. Then, run &lt;code&gt;git sparse-checkout set&lt;/code&gt; to modify the patterns in the sparse-checkout file.</source>
          <target state="translated">スパースチェックアウト機能を有効にするには、 &lt;code&gt;git sparse-checkout init&lt;/code&gt; を実行してシンプルなスパースチェックアウトファイルを初期化し、 &lt;code&gt;core.sparseCheckout&lt;/code&gt; 構成設定を有効にします。次に、 &lt;code&gt;git sparse-checkout set&lt;/code&gt; を実行して、sparse-checkoutファイルのパターンを変更します。</target>
        </trans-unit>
        <trans-unit id="1318b73efc503f41a06d5d140c646ee25cf7e427" translate="yes" xml:space="preserve">
          <source>To exclude commits reachable from a commit, a prefix &lt;code&gt;^&lt;/code&gt; notation is used. E.g. &lt;code&gt;^r1 r2&lt;/code&gt; means commits reachable from &lt;code&gt;r2&lt;/code&gt; but exclude the ones reachable from &lt;code&gt;r1&lt;/code&gt; (i.e. &lt;code&gt;r1&lt;/code&gt; and its ancestors).</source>
          <target state="translated">コミットから到達可能なコミットを除外するには、プレフィックス &lt;code&gt;^&lt;/code&gt; 表記を使用します。たとえば、 &lt;code&gt;^r1 r2&lt;/code&gt; は、 &lt;code&gt;r2&lt;/code&gt; から到達可能なコミットを意味しますが、 &lt;code&gt;r1&lt;/code&gt; から到達可能なコミット（つまり、 &lt;code&gt;r1&lt;/code&gt; とその祖先）を除外します。</target>
        </trans-unit>
        <trans-unit id="a12d809ea9b20c2b561957b059e3fe943cb6e440" translate="yes" xml:space="preserve">
          <source>To find out how the result can be used, just read on in &lt;code&gt;cmd_cat_file()&lt;/code&gt;:</source>
          <target state="translated">結果の使用方法を確認するには、 &lt;code&gt;cmd_cat_file()&lt;/code&gt; を読みます。</target>
        </trans-unit>
        <trans-unit id="338cdf0c3d82152dc96e1eae9cd9922bf736e76c" translate="yes" xml:space="preserve">
          <source>To get a checkout with the Eclipse CVS client:</source>
          <target state="translated">EclipseのCVSクライアントでチェックアウトを取得するには</target>
        </trans-unit>
        <trans-unit id="976f859125db1311d8f82bb8df703ef2ad537fd0" translate="yes" xml:space="preserve">
          <source>To get a reminder of the currently used terms, use</source>
          <target state="translated">現在使用されている用語のリマインダーを取得するには</target>
        </trans-unit>
        <trans-unit id="68b714c59ff5898ff58433a2938d52aeb27df43e" translate="yes" xml:space="preserve">
          <source>To get started with gitweb, run &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb[1]&lt;/a&gt; from a Git repository. This would configure and start your web server, and run web browser pointing to gitweb.</source>
          <target state="translated">gitwebを使い始めるには、Gitリポジトリから&lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb [1]を&lt;/a&gt;実行します。これにより、Webサーバーが構成されて起動し、gitwebを指すWebブラウザーが実行されます。</target>
        </trans-unit>
        <trans-unit id="bf62a03860b36b4b6a615592146052d88035a5f4" translate="yes" xml:space="preserve">
          <source>To get the &quot;base&quot; for the merge, look up the common parent of two commits:</source>
          <target state="translated">マージの &quot;ベース&quot; を取得するには、2 つのコミットの共通の親を調べます。</target>
        </trans-unit>
        <trans-unit id="ec1f343ca45777aa33e95b7222bfb7658aa36062" translate="yes" xml:space="preserve">
          <source>To get the feature/bugfix into an integration branch, simply merge it. If the topic has evolved further in the meantime, merge again. (Note that you do not necessarily have to merge it to the oldest integration branch first. For example, you can first merge a bugfix to &lt;code&gt;next&lt;/code&gt;, give it some testing time, and merge to &lt;code&gt;maint&lt;/code&gt; when you know it is stable.)</source>
          <target state="translated">機能/バグ修正を統合ブランチに入れるには、単にそれをマージします。その間にトピックがさらに進化した場合は、再度マージしてください。（必ずしも最も古い統合ブランチに最初にマージする必要はないことに注意してください。たとえば、最初にバグ修正を &lt;code&gt;next&lt;/code&gt; にマージし、テスト時間を与え、安定していることがわかったら &lt;code&gt;maint&lt;/code&gt; にマージできます。）</target>
        </trans-unit>
        <trans-unit id="60ae758b58fc83602f1720fb9cc2f0f4fb30b090" translate="yes" xml:space="preserve">
          <source>To give some hard figures, we used to have an average report-to-fix cycle of 142.6 hours (according to our somewhat weird bug-tracker which just measures wall-clock time). Since we moved to Git, we&amp;rsquo;ve lowered that to 16.2 hours. Primarily because we can stay on top of the bug fixing now, and because everyone&amp;rsquo;s jockeying to get to fix bugs (we&amp;rsquo;re quite proud of how lazy we are to let Git find the bugs for us). Each new release results in ~40% fewer bugs (almost certainly due to how we now feel about writing tests).</source>
          <target state="translated">いくつかの明確な数字を与えるために、私たちは142.6時間の平均レポートから修正までのサイクルを使用していました（壁時計の時間を測定するだけの奇妙なバグトラッカーによると）。 Gitに移行したので、これを16.2時間に減らしました。主な理由は、今はバグ修正の最上位にいることができるため、そしてバグを修正するためにみんながジョッキーしているためです（Gitにバグを見つけてもらうのがどれほど面倒かを私たちは非常に誇りに思っています）。新しいリリースごとに、バグが最大で40％減少します（ほとんどの場合、テストの作成についての感想が原因です）。</target>
        </trans-unit>
        <trans-unit id="cc855cb566c405d222e3a3236275bbad376833c3" translate="yes" xml:space="preserve">
          <source>To help with that, &lt;code&gt;range&lt;/code&gt; uses the &lt;code&gt;--dual-color&lt;/code&gt; mode by default. In this mode, the diff of diffs will retain the original diff colors, and prefix the lines with -/+ markers that have their &lt;strong&gt;background&lt;/strong&gt; red or green, to make it more obvious that they describe how the diff itself changed.</source>
          <target state="translated">これを支援するために、 &lt;code&gt;range&lt;/code&gt; はデフォルトで &lt;code&gt;--dual-color&lt;/code&gt; モードを使用します。このモードでは、diffのdiffは元のdiffの色を保持し、行の前に-/ +マーカーを付けて&lt;strong&gt;背景を&lt;/strong&gt;赤または緑にして、diff自体がどのように変更されたかを明確に示します。</target>
        </trans-unit>
        <trans-unit id="096c5d9029f3f58b2af501ec17fb5d42ac0f73fe" translate="yes" xml:space="preserve">
          <source>To illustrate the difference between &lt;code&gt;-S&amp;lt;regex&amp;gt; --pickaxe-regex&lt;/code&gt; and &lt;code&gt;-G&amp;lt;regex&amp;gt;&lt;/code&gt;, consider a commit with the following diff in the same file:</source>
          <target state="translated">&lt;code&gt;-S&amp;lt;regex&amp;gt; --pickaxe-regex&lt;/code&gt; と &lt;code&gt;-G&amp;lt;regex&amp;gt;&lt;/code&gt; の違いを説明するために、同じファイルで次のdiffを使用したコミットを検討してください。</target>
        </trans-unit>
        <trans-unit id="e67d6de21feaa90def83753eb253a23faea561fa" translate="yes" xml:space="preserve">
          <source>To illustrate, suppose you are in a situation where someone develops a &lt;code&gt;subsystem&lt;/code&gt; branch, and you are working on a &lt;code&gt;topic&lt;/code&gt; that is dependent on this &lt;code&gt;subsystem&lt;/code&gt;. You might end up with a history like the following:</source>
          <target state="translated">例として、誰かが &lt;code&gt;subsystem&lt;/code&gt; ブランチを開発し、この &lt;code&gt;subsystem&lt;/code&gt; 依存する &lt;code&gt;topic&lt;/code&gt; で作業している状況を想定します。次のような履歴になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="a98d25733140cb4450fff563f123b0d4cafeb9f9" translate="yes" xml:space="preserve">
          <source>To interrupt the rebase (just like an &quot;edit&quot; command would do, but without cherry-picking any commit first), use the &quot;break&quot; command.</source>
          <target state="translated">リベースを中断するには (「edit」コマンドと同じように、最初にコミットを選択しないように)、「break」コマンドを使ってください。</target>
        </trans-unit>
        <trans-unit id="f6408dba3913ebdb903fdfce1d68f1906d3e56f0" translate="yes" xml:space="preserve">
          <source>To look at only non-zero stages, use &lt;code&gt;--unmerged&lt;/code&gt; flag:</source>
          <target state="translated">ゼロ以外のステージのみを表示するには、 &lt;code&gt;--unmerged&lt;/code&gt; フラグを使用します。</target>
        </trans-unit>
        <trans-unit id="5b273f729e50c3bb1996889c896c925cce764cd8" translate="yes" xml:space="preserve">
          <source>To make it readable, we can tell &lt;code&gt;git diff-files&lt;/code&gt; to output the differences as a patch, using the &lt;code&gt;-p&lt;/code&gt; flag:</source>
          <target state="translated">読みやすくするために、 &lt;code&gt;-p&lt;/code&gt; フラグを使用して、違いをパッチとして出力するように &lt;code&gt;git diff-files&lt;/code&gt; に指示できます。</target>
        </trans-unit>
        <trans-unit id="9fa7b34f2837aaeca157590c3f1e04cfe3400ecb" translate="yes" xml:space="preserve">
          <source>To make referencing the final pathname simpler, you can map each path component; so if you also anonymize &lt;code&gt;subdir&lt;/code&gt; to &lt;code&gt;publicdir&lt;/code&gt;, then the final pathname would be &lt;code&gt;publicdir/bar.c&lt;/code&gt;.</source>
          <target state="translated">最終パス名の参照を簡単にするために、各パスコンポーネントをマップできます。あなたはまた、匿名ならば &lt;code&gt;subdir&lt;/code&gt; に &lt;code&gt;publicdir&lt;/code&gt; 、最終的なパス名は次のようになり &lt;code&gt;publicdir/bar.c&lt;/code&gt; に。</target>
        </trans-unit>
        <trans-unit id="5411ef1231b1da2dbabaf49f4348af685832f2f7" translate="yes" xml:space="preserve">
          <source>To move the whole tree into a subdirectory, or remove it from there:</source>
          <target state="translated">ツリー全体をサブディレクトリに移動したり、そこから削除したりするには、以下のようにします。</target>
        </trans-unit>
        <trans-unit id="9fef1883cb2bb53007927c93e3d8f7431145efad" translate="yes" xml:space="preserve">
          <source>To perform a three-way merge, you start with the two commits you want to merge, find their closest common parent (a third commit), and compare the trees corresponding to these three commits.</source>
          <target state="translated">三者間マージを実行するには、まずマージしたい二つのコミットから始め、その共通の親 (三番目のコミット)を見つけ、その三つのコミットに対応するツリーを比較します。</target>
        </trans-unit>
        <trans-unit id="a35f3e8a10774da4c0b0f3f87118660d7ef9889e" translate="yes" xml:space="preserve">
          <source>To place a higher stage entry to the index, the path should first be removed by feeding a mode=0 entry for the path, and then feeding necessary input lines in the third format.</source>
          <target state="translated">より高いステージのエントリをインデックスに配置するためには、まずパスに対してmode=0のエントリを与えてパスを削除し、次に第3のフォーマットで必要な入力行を与えるべきである。</target>
        </trans-unit>
        <trans-unit id="26b0cbf1bc1090821ae6f59cac15f02ec7f562f8" translate="yes" xml:space="preserve">
          <source>To prepare for working on &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt;, switch to it by updating the index and the files in the working tree, and by pointing &lt;code&gt;HEAD&lt;/code&gt; at the branch. Local modifications to the files in the working tree are kept, so that they can be committed to the &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; での作業の準備をするには、作業ツリー内のインデックスとファイルを更新し、ブランチに &lt;code&gt;HEAD&lt;/code&gt; をポイントして、それに切り替えます。作業ツリー内のファイルへのローカル変更は保持されるため、 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; にコミットできます。</target>
        </trans-unit>
        <trans-unit id="13739c43ac679e23fc4c2d09478ac31e5293cb15" translate="yes" xml:space="preserve">
          <source>To pretend you have a file at path with mode and sha1, say:</source>
          <target state="translated">パスにモードと sha1 を持つファイルがあると仮定します。</target>
        </trans-unit>
        <trans-unit id="6785e6ba620455f331d4a09eb8363e2600eabf25" translate="yes" xml:space="preserve">
          <source>To prevent a $GIT_DIR/worktrees entry from being pruned (which can be useful in some situations, such as when the entry&amp;rsquo;s working tree is stored on a portable device), use the &lt;code&gt;git worktree lock&lt;/code&gt; command, which adds a file named &lt;code&gt;locked&lt;/code&gt; to the entry&amp;rsquo;s directory. The file contains the reason in plain text. For example, if a linked working tree&amp;rsquo;s &lt;code&gt;.git&lt;/code&gt; file points to &lt;code&gt;/path/main/.git/worktrees/test-next&lt;/code&gt; then a file named &lt;code&gt;/path/main/.git/worktrees/test-next/locked&lt;/code&gt; will prevent the &lt;code&gt;test-next&lt;/code&gt; entry from being pruned. See &lt;a href=&quot;gitrepository-layout&quot;&gt;gitrepository-layout[5]&lt;/a&gt; for details.</source>
          <target state="translated">$ GIT_DIRを防ぐために/（そのようなエントリの作業ツリーをポータブルデバイスに保存されている場合など、いくつかの状況で便利です）剪定されてからのエントリ、使用worktrees &lt;code&gt;git worktree lock&lt;/code&gt; という名前のファイルを追加するコマンド、 &lt;code&gt;locked&lt;/code&gt; へのエントリのディレクトリ。ファイルには理由がプレーンテキストで含まれています。例えば、作業ツリーのリンク場合は &lt;code&gt;.git&lt;/code&gt; するために、ファイルのポイントを &lt;code&gt;/path/main/.git/worktrees/test-next&lt;/code&gt; その後、名前のファイル &lt;code&gt;/path/main/.git/worktrees/test-next/locked&lt;/code&gt; を防ぐことができます &lt;code&gt;test-next&lt;/code&gt; 剪定からの次のエントリー。詳細については、&lt;a href=&quot;gitrepository-layout&quot;&gt;gitrepository-layout [5]&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="af2e73e27abe3e4382121e1f7c2af8f2dfcf3321" translate="yes" xml:space="preserve">
          <source>To prevent a &lt;code&gt;$GIT_DIR/worktrees&lt;/code&gt; entry from being pruned (which can be useful in some situations, such as when the entry&amp;rsquo;s working tree is stored on a portable device), use the &lt;code&gt;git worktree lock&lt;/code&gt; command, which adds a file named &lt;code&gt;locked&lt;/code&gt; to the entry&amp;rsquo;s directory. The file contains the reason in plain text. For example, if a linked working tree&amp;rsquo;s &lt;code&gt;.git&lt;/code&gt; file points to &lt;code&gt;/path/main/.git/worktrees/test-next&lt;/code&gt; then a file named &lt;code&gt;/path/main/.git/worktrees/test-next/locked&lt;/code&gt; will prevent the &lt;code&gt;test-next&lt;/code&gt; entry from being pruned. See &lt;a href=&quot;gitrepository-layout&quot;&gt;gitrepository-layout[5]&lt;/a&gt; for details.</source>
          <target state="translated">防ぐには &lt;code&gt;$GIT_DIR/worktrees&lt;/code&gt; （そのようなエントリの作業ツリーをポータブルデバイスに保存されている場合など、いくつかの状況で便利です）剪定されてからのエントリ、使用 &lt;code&gt;git worktree lock&lt;/code&gt; という名前のファイルを追加するコマンド、 &lt;code&gt;locked&lt;/code&gt; へのエントリのディレクトリ。ファイルには、理由がプレーンテキストで含まれています。例えば、作業ツリーのリンク場合は &lt;code&gt;.git&lt;/code&gt; するために、ファイルのポイントを &lt;code&gt;/path/main/.git/worktrees/test-next&lt;/code&gt; その後、名前のファイル &lt;code&gt;/path/main/.git/worktrees/test-next/locked&lt;/code&gt; を防ぐことができます &lt;code&gt;test-next&lt;/code&gt; 剪定からの次のエントリ。詳細については、&lt;a href=&quot;gitrepository-layout&quot;&gt;gitrepository-layout [5]&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="46ac404b2baca4d3a659bb0594db0c41828389ed" translate="yes" xml:space="preserve">
          <source>To prevent these unnecessary merge conflicts, Git can be told to run a virtual check-out and check-in of all three stages of a file when resolving a three-way merge by setting the &lt;code&gt;merge.renormalize&lt;/code&gt; configuration variable. This prevents changes caused by check-in conversion from causing spurious merge conflicts when a converted file is merged with an unconverted file.</source>
          <target state="translated">これらの不要なマージの競合を防ぐために、 &lt;code&gt;merge.renormalize&lt;/code&gt; 構成変数を設定して、3者間マージを解決するときに、ファイルの3つのステージすべての仮想チェックアウトおよびチェックインを実行するようにGitに指示できます。これにより、変換されたファイルが未変換のファイルとマージされるときに、チェックイン変換によって引き起こされる変更が誤ったマージの競合を引き起こすのを防ぎます。</target>
        </trans-unit>
        <trans-unit id="91d260766aee213709a415223ac206b93100d7d5" translate="yes" xml:space="preserve">
          <source>To prune objects not used by your repository or another that borrows from your repository via its &lt;code&gt;.git/objects/info/alternates&lt;/code&gt;:</source>
          <target state="translated">リポジトリで使用されていないオブジェクト、または &lt;code&gt;.git/objects/info/alternates&lt;/code&gt; を介してリポジトリから借用したオブジェクトをプルーニングするには：</target>
        </trans-unit>
        <trans-unit id="2f63f42b98c259e7fd0384dd68939f7fc302c5eb" translate="yes" xml:space="preserve">
          <source>To prune references as part of your normal workflow without needing to remember to run that, set &lt;code&gt;fetch.prune&lt;/code&gt; globally, or &lt;code&gt;remote.&amp;lt;name&amp;gt;.prune&lt;/code&gt; per-remote in the config. See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">通常のワークフローの一部として、実行を覚えておく必要なく参照をプルーニングするには、 &lt;code&gt;fetch.prune&lt;/code&gt; をグローバルに設定するか、configでリモートごとに &lt;code&gt;remote.&amp;lt;name&amp;gt;.prune&lt;/code&gt; 設定します。&lt;a href=&quot;git-config&quot;&gt;git-config [1]を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="68bfae2792009c9d944a67bd77b4854e1c8c4d3e" translate="yes" xml:space="preserve">
          <source>To put the loose objects into a pack, just run git repack:</source>
          <target state="translated">ゆるいものをパックに入れるには git repack を実行するだけです。</target>
        </trans-unit>
        <trans-unit id="8344caf5b982f9b0d4dc99f7ff5aa708ff0b3592" translate="yes" xml:space="preserve">
          <source>To query the value for a given key, do</source>
          <target state="translated">指定したキーの値を問い合わせるには、次のようにします。</target>
        </trans-unit>
        <trans-unit id="6d7c1598e59e901d58d9b961c14fa449c82ef069" translate="yes" xml:space="preserve">
          <source>To reapply a series of changes from a &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt; to a different base, and reset the &lt;a href=&quot;#def_head&quot;&gt;head&lt;/a&gt; of that branch to the result.</source>
          <target state="translated">一連の変更を&lt;a href=&quot;#def_branch&quot;&gt;ブランチ&lt;/a&gt;から別のベースに再適用し、そのブランチの&lt;a href=&quot;#def_head&quot;&gt;ヘッド&lt;/a&gt;を結果にリセットします。</target>
        </trans-unit>
        <trans-unit id="25388a0bc929e9a0e4d2bb9d4d113e8444bb02a5" translate="yes" xml:space="preserve">
          <source>To remove a file from the index and from the working tree, use</source>
          <target state="translated">インデックスと作業ツリーからファイルを削除するには</target>
        </trans-unit>
        <trans-unit id="c7850646e909d85f101794190a2e6f7a699e3e90" translate="yes" xml:space="preserve">
          <source>To remove commits authored by &quot;Darl McBribe&quot; from the history:</source>
          <target state="translated">Darl McBribe &quot;が作成したコミットを履歴から削除します。</target>
        </trans-unit>
        <trans-unit id="65692943c43d72ea453917ea884fccf3994fb56e" translate="yes" xml:space="preserve">
          <source>To remove selection, prefix the input with &lt;code&gt;-&lt;/code&gt; like this:</source>
          <target state="translated">選択を削除するには、次のように入力の前に &lt;code&gt;-&lt;/code&gt; を付けます。</target>
        </trans-unit>
        <trans-unit id="9e91a512899aa79b93af123e6b1768a526248346" translate="yes" xml:space="preserve">
          <source>To repopulate the working directory with all files, use the &lt;code&gt;git sparse-checkout disable&lt;/code&gt; command.</source>
          <target state="translated">作業ディレクトリにすべてのファイルを再入力するには、 &lt;code&gt;git sparse-checkout disable&lt;/code&gt; コマンドを使用します。</target>
        </trans-unit>
        <trans-unit id="5c497720a7ab3ae3ef408305ef475289bc14a521" translate="yes" xml:space="preserve">
          <source>To reproduce the entire p4 history in Git, use the &lt;code&gt;@all&lt;/code&gt; modifier on the depot path:</source>
          <target state="translated">&lt;code&gt;@all&lt;/code&gt; でp4履歴全体を再現するには、デポパスで@all修飾子を使用します。</target>
        </trans-unit>
        <trans-unit id="d4609928d728916d052df2a3b481b65890e4b16e" translate="yes" xml:space="preserve">
          <source>To require authentication for both reads and writes, use a Location directive around the repository, or one of its parent directories:</source>
          <target state="translated">読み取りと書き込みの両方に認証を要求するには、リポジトリの周囲や親ディレクトリの一つに Location ディレクティブを使用します。</target>
        </trans-unit>
        <trans-unit id="10ebfb5ceb771c952eff2c39be3b852f1f654421" translate="yes" xml:space="preserve">
          <source>To require authentication for both reads and writes:</source>
          <target state="translated">読み取りと書き込みの両方に認証を要求する。</target>
        </trans-unit>
        <trans-unit id="847928f545abee25f9f8e4e2cc396a049af86735" translate="yes" xml:space="preserve">
          <source>To restore a file in the index to match the version in &lt;code&gt;HEAD&lt;/code&gt; (this is the same as using &lt;a href=&quot;git-reset&quot;&gt;git-reset[1]&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;HEAD&lt;/code&gt; のバージョンと一致するようにインデックス内のファイルを復元するには（これは&lt;a href=&quot;git-reset&quot;&gt;git-reset [1]&lt;/a&gt;を使用するのと同じです）</target>
        </trans-unit>
        <trans-unit id="21366b05c441f538e6886570018737e901640e49" translate="yes" xml:space="preserve">
          <source>To restore all files in the current directory</source>
          <target state="translated">カレントディレクトリ内のすべてのファイルを復元するには</target>
        </trans-unit>
        <trans-unit id="0ab7e14988a23edeb341648ca7b63377b3dd49d2" translate="yes" xml:space="preserve">
          <source>To restrict rewriting to only part of the history, specify a revision range in addition to the new branch name. The new branch name will point to the top-most revision that a &lt;code&gt;git rev-list&lt;/code&gt; of this range will print.</source>
          <target state="translated">書き換えを履歴の一部のみに制限するには、新しいブランチ名に加えてリビジョン範囲を指定します。新しいブランチ名は、この範囲の &lt;code&gt;git rev-list&lt;/code&gt; が出力する一番上のリビジョンを指します。</target>
        </trans-unit>
        <trans-unit id="4d880d7fd779c619b85e62692eb083b5f59e932e" translate="yes" xml:space="preserve">
          <source>To rewrite commits E,F,G,H, use one of these:</source>
          <target state="translated">E,F,G,H のコミットを書き換えるには、これらのいずれかを使用します。</target>
        </trans-unit>
        <trans-unit id="47b66273feb1f496168989ebee433bebb314fc85" translate="yes" xml:space="preserve">
          <source>To rewrite only commits D,E,F,G,H, but leave A, B and C alone, use:</source>
          <target state="translated">D,E,F,G,H のコミットだけを書き換え、A,B,C のコミットだけを残しておくには、以下のようにします。</target>
        </trans-unit>
        <trans-unit id="8c31d9c011b7c86062de888fb92cc01426b53584" translate="yes" xml:space="preserve">
          <source>To rewrite the repository to look as if &lt;code&gt;foodir/&lt;/code&gt; had been its project root, and discard all other history:</source>
          <target state="translated">リポジトリを書き直して、 &lt;code&gt;foodir/&lt;/code&gt; がそのプロジェクトルートであるかのように見せ、他のすべての履歴を破棄します。</target>
        </trans-unit>
        <trans-unit id="7c02b2b350476c8c24e25173b62f35a8ad0c0ae3" translate="yes" xml:space="preserve">
          <source>To see how submodule support works, create four example repositories that can be used later as a submodule:</source>
          <target state="translated">サブモジュールのサポートがどのように機能するかを確認するために、後からサブモジュールとして使用できる4つのリポジトリの例を作成します。</target>
        </trans-unit>
        <trans-unit id="700bc56e5656b835e5cd7fa2e5386957dfc66eac" translate="yes" xml:space="preserve">
          <source>To see the currently remaining suspects in &lt;code&gt;gitk&lt;/code&gt;, issue the following command during the bisection process (the subcommand &lt;code&gt;view&lt;/code&gt; can be used as an alternative to &lt;code&gt;visualize&lt;/code&gt;):</source>
          <target state="translated">&lt;code&gt;gitk&lt;/code&gt; に現在残っている容疑者を表示するには、二分割プロセス中に次のコマンドを発行します（サブコマンド &lt;code&gt;view&lt;/code&gt; は、 &lt;code&gt;visualize&lt;/code&gt; 代わりに使用できます）。</target>
        </trans-unit>
        <trans-unit id="faa509deef7fcd4d518cc2cd2e577046b7eb747b" translate="yes" xml:space="preserve">
          <source>To see whether it has already been merged into the test or release branches, use:</source>
          <target state="translated">すでにテストブランチやリリースブランチにマージされているかどうかを確認するには、次のようにします。</target>
        </trans-unit>
        <trans-unit id="1e15ca1368deb202f467e491af7bfdb38f930af4" translate="yes" xml:space="preserve">
          <source>To serve gitweb at the same url, use a ScriptAliasMatch to only those URLs that &lt;code&gt;git http-backend&lt;/code&gt; can handle, and forward the rest to gitweb:</source>
          <target state="translated">同じURLでgitwebを提供するには、githttp &lt;code&gt;git http-backend&lt;/code&gt; が処理できるURLのみにScriptAliasMatchを使用し、残りをgitwebに転送します。</target>
        </trans-unit>
        <trans-unit id="3b5c2b799f6b39d60aa882699fc88e3eb3a77175" translate="yes" xml:space="preserve">
          <source>To serve multiple repositories from different &lt;a href=&quot;gitnamespaces&quot;&gt;gitnamespaces[7]&lt;/a&gt; in a single repository:</source>
          <target state="translated">単一のリポジトリで異なる&lt;a href=&quot;gitnamespaces&quot;&gt;gitnamespaces [7]&lt;/a&gt;から複数のリポジトリを提供するには：</target>
        </trans-unit>
        <trans-unit id="59fa97f902b7761eca14600ff37aff1758dec6bd" translate="yes" xml:space="preserve">
          <source>To set a commit (which typically is at the tip of another history) to be the parent of the current initial commit, in order to paste the other history behind the current history:</source>
          <target state="translated">現在の履歴の後ろにある他の履歴を貼り付けるために、現在の最初のコミットの親となるコミット(通常は他の履歴の先端にある)を設定します。</target>
        </trans-unit>
        <trans-unit id="d091c25539483b5c5b3db274eae656a5f768704a" translate="yes" xml:space="preserve">
          <source>To set the date used in future tag objects, set the environment variable GIT_COMMITTER_DATE (see the later discussion of possible values; the most common form is &quot;YYYY-MM-DD HH:MM&quot;).</source>
          <target state="translated">将来のタグオブジェクトで使用される日付を設定するには、環境変数GIT_COMMITTER_DATEを設定します(可能な値については後述します;最も一般的な形式は &quot;YYYY-MM-DD HH:MM &quot;です)。</target>
        </trans-unit>
        <trans-unit id="0de4847876d8ab04ebb463613f39507d60c3b1a3" translate="yes" xml:space="preserve">
          <source>To set this up, first create your work tree by cloning Linus&amp;rsquo;s public tree:</source>
          <target state="translated">これを設定するには、まずLinusのパブリックツリーを複製してワークツリーを作成します。</target>
        </trans-unit>
        <trans-unit id="6fdb47a7575f286ad7a6b8b651d8470ef2c51c01" translate="yes" xml:space="preserve">
          <source>To set up &lt;code&gt;git daemon&lt;/code&gt; as a regular, non-inetd service that handles repositories for multiple virtual hosts based on their IP addresses, start the daemon like this:</source>
          <target state="translated">&lt;code&gt;git daemon&lt;/code&gt; を、IPアドレスに基づいて複数の仮想ホストのリポジトリを処理する通常の非inetdサービスとして設定するには、次のようにデーモンを起動します。</target>
        </trans-unit>
        <trans-unit id="cd4e85b93c0b5a71d973a240463742c429d6ce10" translate="yes" xml:space="preserve">
          <source>To set up &lt;code&gt;git daemon&lt;/code&gt; as an inetd service that handles any repository under the whitelisted set of directories, /pub/foo and /pub/bar, place an entry like the following into /etc/inetd all on one line:</source>
          <target state="translated">ホワイトリストに登録された一連のディレクトリ/ pub / fooおよび/ pub / barの下のリポジトリを処理するinetdサービスとして &lt;code&gt;git daemon&lt;/code&gt; を設定するには、次のようなエントリを/ etc / inetdにすべて1行で配置します。</target>
        </trans-unit>
        <trans-unit id="d85d4c6ac447e3ea7881a95ee3354b641502c913" translate="yes" xml:space="preserve">
          <source>To set up &lt;code&gt;git daemon&lt;/code&gt; as an inetd service that handles repositories for different virtual hosts, &lt;code&gt;www.example.com&lt;/code&gt; and &lt;code&gt;www.example.org&lt;/code&gt;, place an entry like the following into &lt;code&gt;/etc/inetd&lt;/code&gt; all on one line:</source>
          <target state="translated">&lt;code&gt;git daemon&lt;/code&gt; を、異なる仮想ホスト &lt;code&gt;www.example.com&lt;/code&gt; と &lt;code&gt;www.example.org&lt;/code&gt; のリポジトリを処理するinetdサービスとして設定するには、次のようなエントリを &lt;code&gt;/etc/inetd&lt;/code&gt; に1行で配置します。</target>
        </trans-unit>
        <trans-unit id="6d1dfa06a0b2e0253dac9a23d3e763ff2be4729c" translate="yes" xml:space="preserve">
          <source>To shelve changes instead of submitting, use &lt;code&gt;--shelve&lt;/code&gt; and &lt;code&gt;--update-shelve&lt;/code&gt;:</source>
          <target state="translated">送信せずに変更を &lt;code&gt;--shelve&lt;/code&gt; するには、 &lt;code&gt;--update-shelve&lt;/code&gt; shelveおよび--update- shelveを使用します。</target>
        </trans-unit>
        <trans-unit id="b19251adc869dd31b98316a2df3ca3e146f58f68" translate="yes" xml:space="preserve">
          <source>To show all references called &quot;master&quot;, whether tags or heads or anything else, and regardless of how deep in the reference naming hierarchy they are, use:</source>
          <target state="translated">タグでもヘッドでも他のものでも、また、それらが参照名付けの階層の中でどれだけ深い位置にあるかに関係なく、「マスター」と呼ばれるすべての参照を表示するには、使用します。</target>
        </trans-unit>
        <trans-unit id="51ec81ccf2337a76aefa897308cd08d96e515614" translate="yes" xml:space="preserve">
          <source>To show only tags, or only proper branch heads, use &quot;--tags&quot; and/or &quot;--heads&quot; respectively (using both means that it shows tags and heads, but not other random references under the refs/ subdirectory).</source>
          <target state="translated">タグのみを表示したり、適切なブランチの先頭のみを表示したりするには、それぞれ &quot;--tags&quot; や &quot;--heads&quot; を使用します (両方を使用すると、タグと先頭を表示しますが、refs/サブディレクトリの下にある他のランダムな参照は表示しません)。</target>
        </trans-unit>
        <trans-unit id="864f9f1ee17e37f4b3823291b8524eebd5879fc4" translate="yes" xml:space="preserve">
          <source>To show that as an example, let&amp;rsquo;s go back to the git-tutorial repository we used earlier, and create a branch in it. You do that by simply just saying that you want to check out a new branch:</source>
          <target state="translated">例としてそれを示すために、前に使用したgit-tutorialリポジトリに戻り、ブランチを作成します。新しいブランチをチェックアウトしたいというだけでそれを行います。</target>
        </trans-unit>
        <trans-unit id="acab411fa1b0a4e2f72e42b537e21a4bc08bf613" translate="yes" xml:space="preserve">
          <source>To simplify the discussion we will suppose that the untestable area is a simple string of commits and that it was created by a breakage introduced by one commit (let&amp;rsquo;s call it BBC for bisect breaking commit) and later fixed by another one (let&amp;rsquo;s call it BFC for bisect fixing commit).</source>
          <target state="translated">議論を簡単にするために、テスト不可能な領域はコミットの単純な文字列であり、1つのコミットによって導入された破損によって作成され（2分割ブレークコミットの場合はBBCとしましょう）、後で別のコミットによって修正される（BFCとしましょう）二等分修正コミット）。</target>
        </trans-unit>
        <trans-unit id="975e3a9279c8287bca9f664bbcc61fee7baa93ca" translate="yes" xml:space="preserve">
          <source>To specify a branch other than the current one, use:</source>
          <target state="translated">現在のブランチ以外のブランチを指定するには、以下のようにします。</target>
        </trans-unit>
        <trans-unit id="b6b6e95c2c1acd4004bc280690d73f7c9df3e3b0" translate="yes" xml:space="preserve">
          <source>To specify a namespace, set the &lt;code&gt;GIT_NAMESPACE&lt;/code&gt; environment variable to the namespace. For each ref namespace, Git stores the corresponding refs in a directory under &lt;code&gt;refs/namespaces/&lt;/code&gt;. For example, &lt;code&gt;GIT_NAMESPACE=foo&lt;/code&gt; will store refs under &lt;code&gt;refs/namespaces/foo/&lt;/code&gt;. You can also specify namespaces via the &lt;code&gt;--namespace&lt;/code&gt; option to &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt;.</source>
          <target state="translated">名前空間を指定するには、 &lt;code&gt;GIT_NAMESPACE&lt;/code&gt; 環境変数を名前空間に設定します。各refネームスペースについて、Gitは対応するrefを &lt;code&gt;refs/namespaces/&lt;/code&gt; 下のディレクトリに保存します。たとえば、 &lt;code&gt;GIT_NAMESPACE=foo&lt;/code&gt; は &lt;code&gt;refs/namespaces/foo/&lt;/code&gt; 下に参照を格納します。&lt;a href=&quot;git&quot;&gt;git [1]の&lt;/a&gt; &lt;code&gt;--namespace&lt;/code&gt; オプションを使用して名前空間を指定することもできます。</target>
        </trans-unit>
        <trans-unit id="8d8e0463dddb070b083bcb1d31f0cd304bcae1a2" translate="yes" xml:space="preserve">
          <source>To specify a single commit or a range of commits, use:</source>
          <target state="translated">単一のコミットまたはコミットの範囲を指定するには、次のようにします。</target>
        </trans-unit>
        <trans-unit id="b6bdd73c5af990a9c308cb3582e6683a673000a9" translate="yes" xml:space="preserve">
          <source>To stop tracking a file that is currently tracked, use &lt;code&gt;git rm --cached&lt;/code&gt;.</source>
          <target state="translated">現在追跡されているファイルの追跡を停止するには、 &lt;code&gt;git rm --cached&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="5aabd990937e7026d6c235ccca8da7a1bd54429f" translate="yes" xml:space="preserve">
          <source>To submit all changes that are in the current Git branch but not in the &lt;code&gt;p4/master&lt;/code&gt; branch, use:</source>
          <target state="translated">現在のGitブランチにあり、 &lt;code&gt;p4/master&lt;/code&gt; ブランチにはないすべての変更を送信するには、次のコマンドを使用します。</target>
        </trans-unit>
        <trans-unit id="4d37523ff8334f7ae27e64b17d4088a430f024d8" translate="yes" xml:space="preserve">
          <source>To submit patches using GMail&amp;rsquo;s IMAP interface, first, edit your ~/.gitconfig to specify your account settings:</source>
          <target state="translated">GMailのIMAPインターフェースを使用してパッチを送信するには、まず〜/ .gitconfigを編集してアカウント設定を指定します：</target>
        </trans-unit>
        <trans-unit id="3829362b0206f78fb7e35755e5364f47036b822a" translate="yes" xml:space="preserve">
          <source>To support virtual hosting, an interpolated path template can be used to dynamically construct alternate paths. The template supports %H for the target hostname as supplied by the client but converted to all lowercase, %CH for the canonical hostname, %IP for the server&amp;rsquo;s IP address, %P for the port number, and %D for the absolute path of the named repository. After interpolation, the path is validated against the directory whitelist.</source>
          <target state="translated">仮想ホスティングをサポートするために、補間パステンプレートを使用して、代替パスを動的に構築できます。テンプレートは、クライアントから提供されたターゲットホスト名の％Hをサポートしますが、すべて小文字に変換され、％CHは正規ホスト名、％IPはサーバーのIPアドレス、％Pはポート番号、％Dは絶対パスです。名前付きリポジトリ。補間後、パスはディレクトリのホワイトリストに対して検証されます。</target>
        </trans-unit>
        <trans-unit id="5c5bebcfb262219afa24ad57e1be9ff8017de145" translate="yes" xml:space="preserve">
          <source>To switch back to the previous branch before we switched to mytopic (i.e. &quot;master&quot; branch):</source>
          <target state="translated">mytopicに切り替える前のブランチ(つまり「master」ブランチ)に戻る。</target>
        </trans-unit>
        <trans-unit id="f604bfa9fc2a5e3a8b43aed4c26f0a58bfbd1e14" translate="yes" xml:space="preserve">
          <source>To tell Git that yes, you really do realize that certain files no longer exist, or that new files should be added, you should use the &lt;code&gt;--remove&lt;/code&gt; and &lt;code&gt;--add&lt;/code&gt; flags respectively.</source>
          <target state="translated">Gitに「はい」と伝えるには、特定のファイルが存在しないこと、または新しいファイルを追加する必要があることを実際に認識しているため、それぞれ &lt;code&gt;--remove&lt;/code&gt; フラグと &lt;code&gt;--add&lt;/code&gt; フラグを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="f3c508cb95e621506ae6e931b2fdadcaba14a047" translate="yes" xml:space="preserve">
          <source>To test the interaction of several topics, merge them into a throw-away branch. You must never base any work on such a branch!</source>
          <target state="translated">いくつかのトピックの相互作用をテストするには、それらを投げ出しブランチにマージします。このようなブランチをベースにした作業は絶対に行ってはいけません!</target>
        </trans-unit>
        <trans-unit id="ded44bb687bc8a448accbaa8cf09bc1b10b3ff71" translate="yes" xml:space="preserve">
          <source>To that end, it first finds pairs of commits from both commit ranges that correspond with each other. Two commits are said to correspond when the diff between their patches (i.e. the author information, the commit message and the commit diff) is reasonably small compared to the patches' size. See ``Algorithm`` below for details.</source>
          <target state="translated">そのために、まず、両方のコミット範囲から、互いに対応するコミットのペアを見つけます。2つのコミットのパッチ間の差分(すなわち、作者情報、コミットメッセージ、コミット差分)がパッチのサイズに比べて合理的に小さい場合、2つのコミットは対応していると言われます。詳細は以下の ``アルゴリズム`` を参照してください。</target>
        </trans-unit>
        <trans-unit id="28b9a65cbb97d3af18835efd06d4d171278e0508" translate="yes" xml:space="preserve">
          <source>To throw away part of the development, i.e. to assign the &lt;a href=&quot;#def_head&quot;&gt;head&lt;/a&gt; to an earlier &lt;a href=&quot;#def_revision&quot;&gt;revision&lt;/a&gt;.</source>
          <target state="translated">開発の一部を破棄する、つまり、&lt;a href=&quot;#def_head&quot;&gt;ヘッド&lt;/a&gt;を以前の&lt;a href=&quot;#def_revision&quot;&gt;リビジョン&lt;/a&gt;に割り当てる。</target>
        </trans-unit>
        <trans-unit id="f2857b34f71a88c7afeb725363e4097e2e44ff45" translate="yes" xml:space="preserve">
          <source>To top it all off, even when users finally find working commands, they naturally want to share them. But they may be unaware that their repo didn&amp;rsquo;t have some special cases that someone else&amp;rsquo;s does. So, when someone else with a different repository runs the same commands, they get hit by the problems above. Or, the user just runs commands that really were vetted for special cases, but they run it on a different OS where it doesn&amp;rsquo;t work, as noted above.</source>
          <target state="translated">さらに、ユーザーが最終的に機能するコマンドを見つけたときでも、当然それらを共有したいと思っています。しかし、彼らは自分たちのリポジトリが他の誰かがするような特別なケースを持っていなかったことに気付かないかもしれません。したがって、別のリポジトリを持つ他の誰かが同じコマンドを実行すると、上記の問題が発生します。または、ユーザーは、特別なケースで実際に吟味されたコマンドを実行するだけですが、上記のように、機能しない別のOSで実行します。</target>
        </trans-unit>
        <trans-unit id="c4d2ca21938c992db0b3b75cacfc935366e6629e" translate="yes" xml:space="preserve">
          <source>To update and refresh only the files already checked out</source>
          <target state="translated">既にチェックアウトされているファイルのみを更新・更新するには</target>
        </trans-unit>
        <trans-unit id="a8c26a487a2f6627cb1ef2fcc7d8934daa7b62d0" translate="yes" xml:space="preserve">
          <source>To update and refresh only the files already checked out:</source>
          <target state="translated">既にチェックアウトされているファイルだけを更新して更新する。</target>
        </trans-unit>
        <trans-unit id="ec65c1043e980aa5b1f1a444793e6e405a4b07fd" translate="yes" xml:space="preserve">
          <source>To update the index with the contents of a new or modified file, use</source>
          <target state="translated">新しいファイルや変更されたファイルの内容でインデックスを更新するには、次のようにします。</target>
        </trans-unit>
        <trans-unit id="693fe77a3dea0f3b3cf2c4a884d12237d7043db5" translate="yes" xml:space="preserve">
          <source>To update the resulting mine.git repository, you can fetch or pull after replacing the bundle stored at /home/me/tmp/file.bundle with incremental updates.</source>
          <target state="translated">結果の mine.git リポジトリを更新するには、/home/me/tmp/file.bundle に保存されている bundle をインクリメンタルアップデートで置き換えた後に fetch または pull を実行します。</target>
        </trans-unit>
        <trans-unit id="7804c7379482ba8df4ffa8604001ea71fae1937a" translate="yes" xml:space="preserve">
          <source>To use &quot;old&quot; and &quot;new&quot; instead of &quot;good&quot; and bad, you must run &lt;code&gt;git
bisect start&lt;/code&gt; without commits as argument and then run the following commands to add the commits:</source>
          <target state="translated">「良い」と「悪い」の代わりに「古い」と「新しい」を使用 &lt;code&gt;git bisect start&lt;/code&gt; には、引数としてgit bisect startをコミットなしで実行し、次のコマンドを実行してコミットを追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="288cf0a04f95ab8d9b3cedc9a80bcb75e1eb91a6" translate="yes" xml:space="preserve">
          <source>To use &lt;code&gt;git send-email&lt;/code&gt; to send your patches through the GMail SMTP server, edit ~/.gitconfig to specify your account settings:</source>
          <target state="translated">&lt;code&gt;git send-email&lt;/code&gt; を使用してGMail SMTPサーバー経由でパッチを送信するには、〜/ .gitconfigを編集してアカウント設定を指定します。</target>
        </trans-unit>
        <trans-unit id="b24b5140a04c50c5ab1f6a8bf4b67a65e4b08446" translate="yes" xml:space="preserve">
          <source>To use a helper, you must first select one to use. Git currently includes the following helpers:</source>
          <target state="translated">ヘルパーを使用するには、まず使用するヘルパーを選択しなければなりません。Git には現在、以下のヘルパーが含まれています。</target>
        </trans-unit>
        <trans-unit id="36cbbd22949ca6f21f378ad7a2a2aecbfc17d31c" translate="yes" xml:space="preserve">
          <source>To use the tool, &lt;code&gt;imap.folder&lt;/code&gt; and either &lt;code&gt;imap.tunnel&lt;/code&gt; or &lt;code&gt;imap.host&lt;/code&gt; must be set to appropriate values.</source>
          <target state="translated">このツールを使用するには、 &lt;code&gt;imap.folder&lt;/code&gt; と、 &lt;code&gt;imap.tunnel&lt;/code&gt; または &lt;code&gt;imap.host&lt;/code&gt; のいずれかを適切な値に設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="00e4f18d69f51ffe1eea42af728cb3d7bb0059ec" translate="yes" xml:space="preserve">
          <source>To use the tool, imap.folder and either imap.tunnel or imap.host must be set to appropriate values.</source>
          <target state="translated">このツールを使用するには、imap.folder と imap.tunnel または imap.host を適切な値に設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="8b51a494019812910be0a147154b59e9ef1b84fa" translate="yes" xml:space="preserve">
          <source>To use this mode effectively, you have to make sure &lt;code&gt;all&lt;/code&gt; the branches you would push out are ready to be pushed out before running &lt;code&gt;git push&lt;/code&gt;, as the whole point of this mode is to allow you to push all of the branches in one go. If you usually finish work on only one branch and push out the result, while other branches are unfinished, this mode is not for you. Also this mode is not suitable for pushing into a shared central repository, as other people may add new branches there, or update the tip of existing branches outside your control.</source>
          <target state="translated">このモードの全体的なポイントはすべてのブランチを一度にプッシュできるようにすることなので、このモードを効果的に使用するには、 &lt;code&gt;git push&lt;/code&gt; を実行する前に、プッシュする &lt;code&gt;all&lt;/code&gt; のブランチがプッシュされる準備ができていることを確認する必要があります。通常、1つのブランチのみで作業を完了して結果をプッシュし、他のブランチは未完了である場合、このモードは適していません。また、他の人がそこに新しいブランチを追加したり、コントロールの外にある既存のブランチのチップを更新したりする可能性があるため、このモードは共有の中央リポジトリにプッシュするのには適していません。</target>
        </trans-unit>
        <trans-unit id="0db2ead5af506998515a70d6693b9cc78c43968a" translate="yes" xml:space="preserve">
          <source>To verify that &lt;code&gt;master&lt;/code&gt; is indeed a superset of &lt;code&gt;maint&lt;/code&gt;, use git log:</source>
          <target state="translated">&lt;code&gt;master&lt;/code&gt; が本当に &lt;code&gt;maint&lt;/code&gt; のスーパーセットであることを確認するには、git logを使用します。</target>
        </trans-unit>
        <trans-unit id="25e07c07376edb7f994c3289d03610c1335d5288" translate="yes" xml:space="preserve">
          <source>Todo list</source>
          <target state="translated">全リスト</target>
        </trans-unit>
        <trans-unit id="feb6706843b17024c0f5d36ae4a2773f9f7a9d9e" translate="yes" xml:space="preserve">
          <source>Toggle the &quot;sparse&quot; algorithm to determine which objects to include in the pack, when combined with the &quot;--revs&quot; option. This algorithm only walks trees that appear in paths that introduce new objects. This can have significant performance benefits when computing a pack to send a small change. However, it is possible that extra objects are added to the pack-file if the included commits contain certain types of direct renames. If this option is not included, it defaults to the value of &lt;code&gt;pack.useSparse&lt;/code&gt;, which is true unless otherwise specified.</source>
          <target state="translated">「--revs」オプションと組み合わせた場合、「スパース」アルゴリズムを切り替えて、パックに含めるオブジェクトを決定します。このアルゴリズムは、新しいオブジェクトを導入するパスに表示されるツリーのみをウォークします。これは、小さな変更を送信するパックを計算するときに、パフォーマンスに大きなメリットをもたらす可能性があります。ただし、含まれているコミットに特定のタイプの直接名前変更が含まれている場合は、追加のオブジェクトがパックファイルに追加される可能性があります。このオプションが含まれていない場合、デフォルトで &lt;code&gt;pack.useSparse&lt;/code&gt; の値になります。これは、特に指定されていない限りtrueです。</target>
        </trans-unit>
        <trans-unit id="44e89f12173f1b11f3c33dfcf393dbeb53d74231" translate="yes" xml:space="preserve">
          <source>Toggle the pre-push hook (see &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;). The default is --verify, giving the hook a chance to prevent the push. With --no-verify, the hook is bypassed completely.</source>
          <target state="translated">プレプッシュフックを切り替えます（&lt;a href=&quot;githooks&quot;&gt;githooks [5]を&lt;/a&gt;参照）。デフォルトは--verifyで、フックにプッシュを防止する機会を与えます。 --no-verifyを使用すると、フックは完全にバイパスされます。</target>
        </trans-unit>
        <trans-unit id="e69b3ac557eee7192f98b057069c2f145301ef39" translate="yes" xml:space="preserve">
          <source>Topic branches</source>
          <target state="translated">トピックブランチ</target>
        </trans-unit>
        <trans-unit id="99011a3381da15bff0042576b0bb55bb6ae9ffd0" translate="yes" xml:space="preserve">
          <source>TortoiseCVS</source>
          <target state="translated">TortoiseCVS</target>
        </trans-unit>
        <trans-unit id="9732ce69da01051c0a62cf40cfeb5063ebcf5c22" translate="yes" xml:space="preserve">
          <source>Trace the evolution of the line range given by &quot;&amp;lt;start&amp;gt;,&amp;lt;end&amp;gt;&quot; (or the function name regex &amp;lt;funcname&amp;gt;) within the &amp;lt;file&amp;gt;. You may not give any pathspec limiters. This is currently limited to a walk starting from a single revision, i.e., you may only give zero or one positive revision arguments, and &amp;lt;start&amp;gt; and &amp;lt;end&amp;gt; (or &amp;lt;funcname&amp;gt;) must exist in the starting revision. You can specify this option more than once. Implies &lt;code&gt;--patch&lt;/code&gt;. Patch output can be suppressed using &lt;code&gt;--no-patch&lt;/code&gt;, but other diff formats (namely &lt;code&gt;--raw&lt;/code&gt;, &lt;code&gt;--numstat&lt;/code&gt;, &lt;code&gt;--shortstat&lt;/code&gt;, &lt;code&gt;--dirstat&lt;/code&gt;, &lt;code&gt;--summary&lt;/code&gt;, &lt;code&gt;--name-only&lt;/code&gt;, &lt;code&gt;--name-status&lt;/code&gt;, &lt;code&gt;--check&lt;/code&gt;) are not currently implemented.</source>
          <target state="translated">&amp;lt;file&amp;gt;内の &quot;&amp;lt;start&amp;gt;、&amp;lt;end&amp;gt;&quot;（または関数名regex &amp;lt;funcname&amp;gt;）によって指定された行範囲の変化を追跡します。パススペックリミッターを指定することはできません。これは現在、単一のリビジョンから始まるウォークに制限されています。つまり、ゼロまたは1つの正のリビジョン引数のみを指定でき、&amp;lt;start&amp;gt;および&amp;lt;end&amp;gt;（または&amp;lt;funcname&amp;gt;）は開始リビジョンに存在する必要があります。このオプションは複数回指定できます。意味 &lt;code&gt;--patch&lt;/code&gt; 。パッチ出力は &lt;code&gt;--no-patch&lt;/code&gt; を使用して抑制できますが、他の差分形式（つまり &lt;code&gt;--raw&lt;/code&gt; 、-- &lt;code&gt;--numstat&lt;/code&gt; 、-- &lt;code&gt;--shortstat&lt;/code&gt; 、-- &lt;code&gt;--dirstat&lt;/code&gt; 、-- &lt;code&gt;--summary&lt;/code&gt; 、 &lt;code&gt;--name-only&lt;/code&gt; name -only、-- name &lt;code&gt;--name-status&lt;/code&gt; 、 &lt;code&gt;--check&lt;/code&gt; ）は現在実装されていません。</target>
        </trans-unit>
        <trans-unit id="324f1031e6064bf946ba7ad7de400c92a706ee71" translate="yes" xml:space="preserve">
          <source>Trace2 api</source>
          <target state="translated">Trace2 api</target>
        </trans-unit>
        <trans-unit id="f39bab439a6977ac76a84295e79b079d44b7d908" translate="yes" xml:space="preserve">
          <source>Trace2 config settings are only read from the system and global config files; repository local and worktree config files and &lt;code&gt;-c&lt;/code&gt; command line arguments are not respected.</source>
          <target state="translated">Trace2構成設定は、システムおよびグローバル構成ファイルからのみ読み取られます。リポジトリローカルおよびワークツリー構成ファイルと &lt;code&gt;-c&lt;/code&gt; コマンドライン引数は考慮されません。</target>
        </trans-unit>
        <trans-unit id="34f4d5fb2d35b898a8c6180c70ae5079360dafe0" translate="yes" xml:space="preserve">
          <source>Trace2 defines the following set of Trace2 Targets. Format details are given in a later section.</source>
          <target state="translated">Trace2では、以下のようなTrace2 Targetsのセットを定義しています。フォーマットの詳細は後述します。</target>
        </trans-unit>
        <trans-unit id="9cffe01770c87380a0c500c2ba4c5fe9919c83ec" translate="yes" xml:space="preserve">
          <source>Trace2 instrumentation throughout the Git code base sends Trace2 messages to the enabled Trace2 Targets. Targets transform these messages content into purpose-specific formats and write events to their data streams. In this manner, the Trace2 API can drive many different types of analysis.</source>
          <target state="translated">Git コードベース全体の Trace2 インストルメンテーションは、有効になっている Trace2 Targets に Trace2 メッセージを送信します。Targets は、これらのメッセージの内容を目的に応じたフォーマットに変換し、イベントをデータストリームに書き込みます。このようにして、Trace2 API はさまざまなタイプの分析を行うことができます。</target>
        </trans-unit>
        <trans-unit id="78edf21cb8a1d6593bdb09f0d046c88dfeb5c5d1" translate="yes" xml:space="preserve">
          <source>Trace2 is controlled using &lt;code&gt;trace2.*&lt;/code&gt; config values in the system and global config files and &lt;code&gt;GIT_TRACE2*&lt;/code&gt; environment variables. Trace2 does not read from repo local or worktree config files or respect &lt;code&gt;-c&lt;/code&gt; command line config settings.</source>
          <target state="translated">Trace2は、システム内の &lt;code&gt;trace2.*&lt;/code&gt; 値、グローバル構成ファイル、および &lt;code&gt;GIT_TRACE2*&lt;/code&gt; 環境変数を使用して制御されます。Trace2は、リポジトリのローカルまたはワークツリーの設定ファイルから読み取ったり、 &lt;code&gt;-c&lt;/code&gt; コマンドラインの設定を尊重したりしません。</target>
        </trans-unit>
        <trans-unit id="952dc6d60a810a50f48d84409a5ca3162f18abfc" translate="yes" xml:space="preserve">
          <source>Trace2 is controlled using &lt;code&gt;trace2.&lt;/code&gt; config values in the system and global config files and &lt;code&gt;GIT_TRACE2&lt;/code&gt; environment variables. Trace2 does not read from repo local or worktree config files or respect &lt;code&gt;-c&lt;/code&gt; command line config settings.</source>
          <target state="translated">Trace2はtrace2を使用して制御され &lt;code&gt;trace2.&lt;/code&gt; システムおよびグローバル構成ファイルの構成値と &lt;code&gt;GIT_TRACE2&lt;/code&gt; 環境変数。Trace2は、リポジトリのローカルファイルまたはワークツリーの構成ファイルを読み取ったり、 &lt;code&gt;-c&lt;/code&gt; コマンドラインの構成設定を尊重したりしません。</target>
        </trans-unit>
        <trans-unit id="20f68aac372bbc56e3b5b3e96aea0079529bedb9" translate="yes" xml:space="preserve">
          <source>Trace2 regions are similar to the existing trace_performance_enter() and trace_performance_leave() routines, but are thread safe and maintain per-thread stacks of timers.</source>
          <target state="translated">Trace2 リージョンは、既存の trace_performance_enter()および trace_performance_leave()ルーチンに似ていますが、スレッドセーフで、スレッドごとのタイマースタックを維持します。</target>
        </trans-unit>
        <trans-unit id="8bded73626b8544423d59c1c5a0c1bfb684cb12e" translate="yes" xml:space="preserve">
          <source>Trace2 target formats</source>
          <target state="translated">Trace2 のターゲットフォーマット</target>
        </trans-unit>
        <trans-unit id="e4cb4d4e7e519744d1375eb303304baebc567ae9" translate="yes" xml:space="preserve">
          <source>Trace2 targets</source>
          <target state="translated">Trace2ターゲット</target>
        </trans-unit>
        <trans-unit id="a0cfb1f78b98054b282b0aab138d8ea25f2c82bd" translate="yes" xml:space="preserve">
          <source>Tracking and contributing to an entire Subversion-managed project (complete with a trunk, tags and branches):</source>
          <target state="translated">Subversion で管理されているプロジェクト全体(トランク、タグ、ブランチを含む)をトラッキングし、貢献することができます。</target>
        </trans-unit>
        <trans-unit id="847895b0cdb93b975e4c930f95d66dabeb1e64d2" translate="yes" xml:space="preserve">
          <source>Tracking and contributing to the trunk of a Subversion-managed project (ignoring tags and branches):</source>
          <target state="translated">Subversion で管理されているプロジェクトのトランクをトラッキングし、貢献する(タグやブランチは無視する)。</target>
        </trans-unit>
        <trans-unit id="667c19a45142471c0c20cc605b683a6a3152afb1" translate="yes" xml:space="preserve">
          <source>Traditionally, tips of branches and tags (collectively known as &lt;code&gt;refs&lt;/code&gt;) were stored one file per ref in a (sub)directory under &lt;code&gt;$GIT_DIR/refs&lt;/code&gt; directory. While many branch tips tend to be updated often, most tags and some branch tips are never updated. When a repository has hundreds or thousands of tags, this one-file-per-ref format both wastes storage and hurts performance.</source>
          <target state="translated">従来、ブランチとタグのヒント（まとめて &lt;code&gt;refs&lt;/code&gt; と呼ばれていました）は、 &lt;code&gt;$GIT_DIR/refs&lt;/code&gt; ディレクトリの下の（サブ）ディレクトリのrefごとに1つのファイルに格納されていました。多くのブランチヒントは頻繁に更新される傾向がありますが、ほとんどのタグと一部のブランチヒントは決して更新されません。リポジトリに数百または数千のタグがある場合、この1ファイル/参照形式はストレージを浪費し、パフォーマンスを低下させます。</target>
        </trans-unit>
        <trans-unit id="a5cf7db57e9cf074478d171148671cc677faf56a" translate="yes" xml:space="preserve">
          <source>Trailing spaces are ignored unless they are quoted with backslash (&quot;&lt;code&gt;\&lt;/code&gt;&quot;).</source>
          <target state="translated">末尾のスペースは、バックスラッシュ（ &quot; &lt;code&gt;\&lt;/code&gt; &quot;）で囲まれていない限り無視されます。</target>
        </trans-unit>
        <trans-unit id="18baa50eee1aac68104e16bd4ad94c661cde3869" translate="yes" xml:space="preserve">
          <source>Transfer size: In its current form Git requires the whole working tree present. It does not allow partial trees to be transferred in fetch or clone. If the project you work on consists of multiple repositories tied together as submodules in a superproject, you can avoid fetching the working trees of the repositories you are not interested in.</source>
          <target state="translated">転送サイズ。現在の形では、Git は作業ツリー全体を必要としています。部分的なツリーをフェッチやクローンで転送することはできません。作業しているプロジェクトが複数のリポジトリをスーパープロジェクトのサブモジュールとして結びつけている場合は、興味のないリポジトリの作業ツリーをフェッチしないようにすることができます。</target>
        </trans-unit>
        <trans-unit id="bdf6a912dffd18ed6042052fce8610d96ce56a71" translate="yes" xml:space="preserve">
          <source>Transform stdin by substituting all the 40-character SHA-1 hexes (say $hex) with &quot;$hex ($rev_name)&quot;. When used with --name-only, substitute with &quot;$rev_name&quot;, omitting $hex altogether. Intended for the scripter&amp;rsquo;s use.</source>
          <target state="translated">すべての40文字のSHA-1 hex（たとえば$ hex）を「$ hex（$ rev_name）」で置き換えることにより、stdinを変換します。--name-onlyと共に使用する場合は、「$ rev_name」に置き換えて、$ hexを完全に省略します。スクリプト作成者の使用を目的としています。</target>
        </trans-unit>
        <trans-unit id="fc873c381aea0c960eb3ebd47773defb66d7e124" translate="yes" xml:space="preserve">
          <source>Transmit &amp;lt;string&amp;gt; as a push option. As the push option must not contain LF or NUL characters, the string is not encoded.</source>
          <target state="translated">&amp;lt;string&amp;gt;をプッシュオプションとして送信します。プッシュオプションにLFまたはNUL文字を含めることはできないため、文字列はエンコードされません。</target>
        </trans-unit>
        <trans-unit id="32bd61986aca00f68612950bbcdb4915d3d0e846" translate="yes" xml:space="preserve">
          <source>Transmit the given string to the server when communicating using protocol version 2. The given string must not contain a NUL or LF character. The server&amp;rsquo;s handling of server options, including unknown ones, is server-specific. When multiple &lt;code&gt;--server-option=&amp;lt;option&amp;gt;&lt;/code&gt; are given, they are all sent to the other side in the order listed on the command line.</source>
          <target state="translated">プロトコルバージョン2を使用して通信するときに、指定された文字列をサーバーに送信します。指定された文字列には、NULまたはLF文字を含めることはできません。不明なオプションを含むサーバーオプションのサーバーの処理は、サーバー固有です。複数の &lt;code&gt;--server-option=&amp;lt;option&amp;gt;&lt;/code&gt; が指定されている場合、それらはすべてコマンドラインにリストされている順序で反対側に送信されます。</target>
        </trans-unit>
        <trans-unit id="39635a03df29b9789e505a1038590e24ea96c9e9" translate="yes" xml:space="preserve">
          <source>Transmit the given string to the server when communicating using protocol version 2. The given string must not contain a NUL or LF character. When multiple &lt;code&gt;--server-option=&amp;lt;option&amp;gt;&lt;/code&gt; are given, they are all sent to the other side in the order listed on the command line.</source>
          <target state="translated">プロトコルバージョン2を使用して通信するときに、指定された文字列をサーバーに送信します。指定された文字列には、NULまたはLF文字を含めることはできません。複数の &lt;code&gt;--server-option=&amp;lt;option&amp;gt;&lt;/code&gt; が指定されている場合、それらはすべてコマンドラインにリストされている順序で反対側に送信されます。</target>
        </trans-unit>
        <trans-unit id="2995fbcc2c84443582483713456b482a39b63e37" translate="yes" xml:space="preserve">
          <source>Transmit the given string to the server, which passes them to the pre-receive as well as the post-receive hook. The given string must not contain a NUL or LF character. When multiple &lt;code&gt;--push-option=&amp;lt;option&amp;gt;&lt;/code&gt; are given, they are all sent to the other side in the order listed on the command line. When no &lt;code&gt;--push-option=&amp;lt;option&amp;gt;&lt;/code&gt; is given from the command line, the values of configuration variable &lt;code&gt;push.pushOption&lt;/code&gt; are used instead.</source>
          <target state="translated">与えられた文字列をサーバーに送信します。サーバーはそれらをpre-receiveおよびpost-receiveフックに渡します。与えられた文字列はNULまたはLF文字を含んではいけません。複数の &lt;code&gt;--push-option=&amp;lt;option&amp;gt;&lt;/code&gt; が指定されている場合、それらはすべてコマンドラインにリストされている順序で反対側に送信されます。ない場合 &lt;code&gt;--push-option=&amp;lt;option&amp;gt;&lt;/code&gt; コマンドラインから与えられ、コンフィギュレーション変数の値 &lt;code&gt;push.pushOption&lt;/code&gt; が代わりに使用されています。</target>
        </trans-unit>
        <trans-unit id="9960fbc3363c91bebbbc4dae3127f4935a1a22d6" translate="yes" xml:space="preserve">
          <source>Treat all files as text.</source>
          <target state="translated">すべてのファイルをテキストとして扱います。</target>
        </trans-unit>
        <trans-unit id="a08e9c61e543dccc4a24afe7a10c95737cbb1ca7" translate="yes" xml:space="preserve">
          <source>Treat pathspecs literally (i.e. no globbing, no pathspec magic). This is equivalent to setting the &lt;code&gt;GIT_LITERAL_PATHSPECS&lt;/code&gt; environment variable to &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">パススペックを文字通りに扱います（つまり、グロビングなし、パススペックマジックなし）。これは、 &lt;code&gt;GIT_LITERAL_PATHSPECS&lt;/code&gt; 環境変数を &lt;code&gt;1&lt;/code&gt; に設定することと同じです。</target>
        </trans-unit>
        <trans-unit id="8024445062b4bb90b2e84a4da6e0bb207f37b5f4" translate="yes" xml:space="preserve">
          <source>Treat the &amp;lt;string&amp;gt; given to &lt;code&gt;-S&lt;/code&gt; as an extended POSIX regular expression to match.</source>
          <target state="translated">&lt;code&gt;-S&lt;/code&gt; に指定された&amp;lt;string&amp;gt; を、一致する拡張POSIX正規表現として扱います。</target>
        </trans-unit>
        <trans-unit id="72315ec1092243bb561e5b4697869abb3601099e" translate="yes" xml:space="preserve">
          <source>Treat the repository as a bare repository. If GIT_DIR environment is not set, it is set to the current working directory.</source>
          <target state="translated">リポジトリをベアリポジトリとして扱います。GIT_DIR環境が設定されていない場合は、現在の作業ディレクトリに設定されます。</target>
        </trans-unit>
        <trans-unit id="1dad3a3b77cbf00bf58d87ee853af6d3cddb344a" translate="yes" xml:space="preserve">
          <source>Treat the revision argument as a &amp;lt;revision range&amp;gt;, even if it is just a single commit (that would normally be treated as a &amp;lt;since&amp;gt;). Note that root commits included in the specified range are always formatted as creation patches, independently of this flag.</source>
          <target state="translated">単一のコミット（通常は&amp;lt;since&amp;gt;として扱われる）であっても、リビジョン引数を&amp;lt;リビジョン範囲&amp;gt;として扱います。指定された範囲に含まれるルートコミットは、このフラグとは関係なく、常に作成パッチとしてフォーマットされます。</target>
        </trans-unit>
        <trans-unit id="aa88eae97d6ad1936bc41000081122649aee8d74" translate="yes" xml:space="preserve">
          <source>Treats lines with the indicated type of whitespace change as unchanged for the sake of a three-way merge. Whitespace changes mixed with other changes to a line are not ignored. See also &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;&lt;code&gt;-b&lt;/code&gt;, &lt;code&gt;-w&lt;/code&gt;, &lt;code&gt;--ignore-space-at-eol&lt;/code&gt;, and &lt;code&gt;--ignore-cr-at-eol&lt;/code&gt;.</source>
          <target state="translated">3方向のマージのために、指定されたタイプの空白の変更がある行を変更されていないものとして扱います。行に対する他の変更と混合された空白の変更は無視されません。&lt;a href=&quot;git-diff&quot;&gt;git-diff [1] &lt;/a&gt; &lt;code&gt;-b&lt;/code&gt; 、 &lt;code&gt;-w&lt;/code&gt; 、-- &lt;code&gt;--ignore-space-at-eol&lt;/code&gt; 、-- &lt;code&gt;--ignore-cr-at-eol&lt;/code&gt; も参照してください。</target>
        </trans-unit>
        <trans-unit id="6ddd0e484558c1f8e50a8fe3c2dc7499225a9297" translate="yes" xml:space="preserve">
          <source>Tree Object</source>
          <target state="translated">ツリーオブジェクト</target>
        </trans-unit>
        <trans-unit id="bce93b7f9d4c3064a3f582b574710500d7e5efb5" translate="yes" xml:space="preserve">
          <source>Tree and blob objects outside of &lt;code&gt;refs/{tags,heads}/*&lt;/code&gt; will be treated the same way as if they were inside &lt;code&gt;refs/tags/*&lt;/code&gt;, any update of them will be rejected.</source>
          <target state="translated">&lt;code&gt;refs/{tags,heads}/*&lt;/code&gt; 外のツリーおよびblobオブジェクトは、 &lt;code&gt;refs/tags/*&lt;/code&gt; 内にある場合と同じように扱われ、それらの更新は拒否されます。</target>
        </trans-unit>
        <trans-unit id="faed43d5018a65bdda1021ea817b81efdd882a1f" translate="yes" xml:space="preserve">
          <source>Tree objects as well as tag objects not pointing at commits, cannot be described. When describing blobs, the lightweight tags pointing at blobs are ignored, but the blob is still described as &amp;lt;committ-ish&amp;gt;:&amp;lt;path&amp;gt; despite the lightweight tag being favorable.</source>
          <target state="translated">ツリーオブジェクトや、コミットを指さないタグオブジェクトは記述できません。blobを記述するとき、blobを指す軽量タグは無視されますが、軽量タグが好ましいにもかかわらず、blobは&amp;lt;committ-ish&amp;gt;：&amp;lt;path&amp;gt;として記述されます。</target>
        </trans-unit>
        <trans-unit id="d94a666a1561928de12071aa36f46464acd70f54" translate="yes" xml:space="preserve">
          <source>Tree to checkout from (when paths are given). If not specified, the index will be used.</source>
          <target state="translated">チェックアウトするツリー(パスが指定されている場合)。指定しない場合はインデックスが使用されます。</target>
        </trans-unit>
        <trans-unit id="fef8232d1c67b8b3403ba454c8ae3c965dc5fb72" translate="yes" xml:space="preserve">
          <source>Trees (aka directories) use just 12 bytes of memory on top of the memory required for their entries (see &amp;ldquo;per active file&amp;rdquo; below). The cost of a tree is virtually 0, as its overhead amortizes out over the individual file entries.</source>
          <target state="translated">ツリー（別名ディレクトリ）は、エントリに必要なメモリの上に12バイトのメモリを使用します（以下の「アクティブなファイルごと」を参照）。ツリーのコストは実質的に0です。これは、そのオーバーヘッドが個々のファイルエントリで償却されるためです。</target>
        </trans-unit>
        <trans-unit id="2bb80d7d00c0395ecaf93c5dc9cd657c191b576d" translate="yes" xml:space="preserve">
          <source>Tries to reinstate not only the working tree&amp;rsquo;s changes, but also the index&amp;rsquo;s ones. However, this can fail, when you have conflicts (which are stored in the index, where you therefore can no longer apply the changes as they were originally).</source>
          <target state="translated">作業ツリーの変更だけでなく、インデックスの変更も復元しようとします。ただし、競合がある場合（インデックスに格納されているため、元の変更を適用できなくなる）、これは失敗する可能性があります。</target>
        </trans-unit>
        <trans-unit id="8797468d6463e4f71332170d9f50ca7fd321cc3a" translate="yes" xml:space="preserve">
          <source>Trivial merges are done by &lt;code&gt;git read-tree&lt;/code&gt; itself. Only conflicting paths will be in unmerged state when &lt;code&gt;git read-tree&lt;/code&gt; returns.</source>
          <target state="translated">ささいなマージは &lt;code&gt;git read-tree&lt;/code&gt; 自体によって行われます。 &lt;code&gt;git read-tree&lt;/code&gt; が戻ると、競合するパスのみがマージされない状態になります。</target>
        </trans-unit>
        <trans-unit id="c14d8e783a9f521d30b73eb971eac8f82acc62a0" translate="yes" xml:space="preserve">
          <source>True merge</source>
          <target state="translated">真のマージ</target>
        </trans-unit>
        <trans-unit id="33a579ffc0dccbff15be01734ea4138ea4e7635c" translate="yes" xml:space="preserve">
          <source>Trust</source>
          <target state="translated">Trust</target>
        </trans-unit>
        <trans-unit id="df8a0e781552ee165e12d7086194c5f37262dc36" translate="yes" xml:space="preserve">
          <source>Try to speed up the traversal using the pack bitmap index (if one is available). Note that when traversing with &lt;code&gt;--objects&lt;/code&gt;, trees and blobs will not have their associated path printed.</source>
          <target state="translated">パックビットマップインデックス（使用可能な場合）を使用して、走査を高速化してください。 &lt;code&gt;--objects&lt;/code&gt; を使用してトラバースする場合、ツリーとブロブには関連するパスが印刷されないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="db494399fc91d335ea933090c261cf51f7615da6" translate="yes" xml:space="preserve">
          <source>Try to update from the upstream resulted in a lot of conflicts; you were not ready to spend a lot of time merging right now, so you decide to do that later.</source>
          <target state="translated">上流から更新しようとすると、多くの競合が発生しました。</target>
        </trans-unit>
        <trans-unit id="3a12d2b4901990f4e580a360ff850809fe3f67b9" translate="yes" xml:space="preserve">
          <source>Turn off any previous &lt;code&gt;--filter=&lt;/code&gt; argument.</source>
          <target state="translated">以前の &lt;code&gt;--filter=&lt;/code&gt; 引数をオフにします。</target>
        </trans-unit>
        <trans-unit id="34771065d121fc03fac8d38d540e254893826329" translate="yes" xml:space="preserve">
          <source>Turn off branch colors, even when the configuration file gives the default to color output. Same as &lt;code&gt;--color=never&lt;/code&gt;.</source>
          <target state="translated">設定ファイルでデフォルトのカラー出力が指定されている場合でも、ブランチのカラーをオフにします。 &lt;code&gt;--color=never&lt;/code&gt; と同じです。</target>
        </trans-unit>
        <trans-unit id="6d9cbb32ce6c68e264cdb30b91e954cf183958d3" translate="yes" xml:space="preserve">
          <source>Turn off colored diff. It is the same as &lt;code&gt;--color=never&lt;/code&gt;.</source>
          <target state="translated">色付きの差分をオフにします。 &lt;code&gt;--color=never&lt;/code&gt; と同じです。</target>
        </trans-unit>
        <trans-unit id="3d9b2354f095eeb41acddbf4f3d69d4ac5775813" translate="yes" xml:space="preserve">
          <source>Turn off colored diff. This can be used to override configuration settings. It is the same as &lt;code&gt;--color=never&lt;/code&gt;.</source>
          <target state="translated">色付きの差分をオフにします。これは、構成設定をオーバーライドするために使用できます。 &lt;code&gt;--color=never&lt;/code&gt; と同じです。</target>
        </trans-unit>
        <trans-unit id="8ad464ef4a6c59cdcb2319e829113b9b9a0202fe" translate="yes" xml:space="preserve">
          <source>Turn off colored output, even when the configuration file gives the default to color output. Same as &lt;code&gt;--color=never&lt;/code&gt;.</source>
          <target state="translated">構成ファイルがデフォルトでカラー出力を指定している場合でも、カラー出力をオフにします。 &lt;code&gt;--color=never&lt;/code&gt; と同じです。</target>
        </trans-unit>
        <trans-unit id="a3a997309d5fb6a6ca30f0f6201f278a284d8e1e" translate="yes" xml:space="preserve">
          <source>Turn off match highlighting, even when the configuration file gives the default to color output. Same as &lt;code&gt;--color=never&lt;/code&gt;.</source>
          <target state="translated">構成ファイルでデフォルトのカラー出力が指定されている場合でも、一致の強調表示をオフにします。 &lt;code&gt;--color=never&lt;/code&gt; と同じです。</target>
        </trans-unit>
        <trans-unit id="d4fab0f230de92fdcff08739247b39013a4dcf91" translate="yes" xml:space="preserve">
          <source>Turn off move detection. This can be used to override configuration settings. It is the same as &lt;code&gt;--color-moved=no&lt;/code&gt;.</source>
          <target state="translated">移動検出をオフにします。これは、構成設定をオーバーライドするために使用できます。 &lt;code&gt;--color-moved=no&lt;/code&gt; と同じです。</target>
        </trans-unit>
        <trans-unit id="b0eb0b106db412297afc722cb22850ad8fd89466" translate="yes" xml:space="preserve">
          <source>Turn off rename detection, even when the configuration file gives the default to do so.</source>
          <target state="translated">設定ファイルでデフォルトでリネーム検出を行うように設定されている場合でも、リネーム検出をオフにします。</target>
        </trans-unit>
        <trans-unit id="4e867193eda90e02a99d5e3b2d3aff016424ee32" translate="yes" xml:space="preserve">
          <source>Turn off rename detection. This overrides the &lt;code&gt;merge.renames&lt;/code&gt; configuration variable. See also &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;&lt;code&gt;--no-renames&lt;/code&gt;.</source>
          <target state="translated">名前の変更の検出をオフにします。これは、 &lt;code&gt;merge.renames&lt;/code&gt; 構成変数をオーバーライドします。&lt;a href=&quot;git-diff&quot;&gt;git-diff [1] &lt;/a&gt; &lt;code&gt;--no-renames&lt;/code&gt; も参照してください。</target>
        </trans-unit>
        <trans-unit id="29eb4a9a74bb1156273caaa264fc85825c0572ef" translate="yes" xml:space="preserve">
          <source>Turn on rename detection, optionally setting the similarity threshold. See also &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;&lt;code&gt;--find-renames&lt;/code&gt;.</source>
          <target state="translated">名前変更の検出をオンにし、オプションで類似性のしきい値を設定します。&lt;a href=&quot;git-diff&quot;&gt;git-diff [1] &lt;/a&gt; &lt;code&gt;--find-renames&lt;/code&gt; も参照してください。</target>
        </trans-unit>
        <trans-unit id="a279dbfc86c680add56c7a5993ef6023dec20637" translate="yes" xml:space="preserve">
          <source>Turn on rename detection, optionally setting the similarity threshold. This is the default. This overrides the &lt;code&gt;merge.renames&lt;/code&gt; configuration variable. See also &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;&lt;code&gt;--find-renames&lt;/code&gt;.</source>
          <target state="translated">名前変更の検出をオンにし、オプションで類似性のしきい値を設定します。これがデフォルトです。これは、 &lt;code&gt;merge.renames&lt;/code&gt; 構成変数をオーバーライドします。&lt;a href=&quot;git-diff&quot;&gt;git-diff [1] &lt;/a&gt; &lt;code&gt;--find-renames&lt;/code&gt; も参照してください。</target>
        </trans-unit>
        <trans-unit id="e9d077a66918e3017c929a4d5ef75e05f491a825" translate="yes" xml:space="preserve">
          <source>Turn on/off rename detection regardless of user configuration. See also &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;&lt;code&gt;--no-renames&lt;/code&gt;.</source>
          <target state="translated">ユーザー設定に関係なく、名前の変更の検出をオン/オフにします。&lt;a href=&quot;git-diff&quot;&gt;git-diff [1] &lt;/a&gt; &lt;code&gt;--no-renames&lt;/code&gt; も参照してください。</target>
        </trans-unit>
        <trans-unit id="ff597cb2e8f500da1bb43f369ea55f0017801fbc" translate="yes" xml:space="preserve">
          <source>Turn progress on/off explicitly. If neither is specified, progress is shown if standard error is connected to a terminal.</source>
          <target state="translated">プログレスのオン/オフを明示的に設定します。どちらも指定しない場合は、標準エラーが端末に接続されている場合にプログレスを表示します。</target>
        </trans-unit>
        <trans-unit id="b63e204e5b5bb236923126ba202fed353f8079ec" translate="yes" xml:space="preserve">
          <source>Turn progress on/off explicitly. If neither is specified, progress is shown if standard error is connected to a terminal. Note that not all merge strategies may support progress reporting.</source>
          <target state="translated">プログレスのオン/オフを明示的に設定します。どちらも指定しない場合は、標準エラーがターミナルに接続されている場合に進捗状況が表示されます。すべてのマージ戦略が進捗報告をサポートしているわけではないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="ae22b8d4ecb731b706e41a653df929373ee8e8e0" translate="yes" xml:space="preserve">
          <source>Turns off any previous &lt;code&gt;--filter=&lt;/code&gt; argument.</source>
          <target state="translated">以前の &lt;code&gt;--filter=&lt;/code&gt; 引数をオフにします。</target>
        </trans-unit>
        <trans-unit id="2701a94c0eb55cbd958a87dff3e959673ff1bf53" translate="yes" xml:space="preserve">
          <source>Tutorial</source>
          <target state="translated">Tutorial</target>
        </trans-unit>
        <trans-unit id="954e9a2594b4d5687b25c9c1a8357bca3253b18f" translate="yes" xml:space="preserve">
          <source>Tweaking diff output</source>
          <target state="translated">diff出力の微調整</target>
        </trans-unit>
        <trans-unit id="aef2d842e6b781b12f96bc62f4ab607c12e12218" translate="yes" xml:space="preserve">
          <source>Two Tree Merge</source>
          <target state="translated">2つの木のマージ</target>
        </trans-unit>
        <trans-unit id="6bda5442e87e811366b94ce6966009ecac6ac5dc" translate="yes" xml:space="preserve">
          <source>Two consecutive asterisks (&quot;&lt;code&gt;**&lt;/code&gt;&quot;) in patterns matched against full pathname may have special meaning:</source>
          <target state="translated">完全パス名と照合されるパターン内の2つの連続するアスタリスク（ &quot; &lt;code&gt;**&lt;/code&gt; &quot;）は、特別な意味を持つ場合があります。</target>
        </trans-unit>
        <trans-unit id="e187ca5222f2f1c9a298321896225faf75c5697a" translate="yes" xml:space="preserve">
          <source>Two consecutive asterisks (&amp;ldquo;**&amp;rdquo;) in patterns matched against full pathname may have special meaning:</source>
          <target state="translated">完全パス名と照合されるパターン内の2つの連続するアスタリスク（「**」）は、特別な意味を持つ場合があります。</target>
        </trans-unit>
        <trans-unit id="fce699584c34eaef39ec9c341ad51961e194a419" translate="yes" xml:space="preserve">
          <source>Two special values are supported: &lt;code&gt;off&lt;/code&gt; will simply close the corresponding standard handle, and if &lt;code&gt;GIT_REDIRECT_STDERR&lt;/code&gt; is &lt;code&gt;2&amp;gt;&amp;amp;1&lt;/code&gt;, standard error will be redirected to the same handle as standard output.</source>
          <target state="translated">：二つの特別な値がサポートされて &lt;code&gt;off&lt;/code&gt; 単に対応する標準ハンドルを閉じ、そして場合 &lt;code&gt;GIT_REDIRECT_STDERR&lt;/code&gt; がある &lt;code&gt;2&amp;gt;&amp;amp;1&lt;/code&gt; 、標準誤差は、標準出力と同じハンドルにリダイレクトされます。</target>
        </trans-unit>
        <trans-unit id="34a739d621f3038babff4f0f681d077135e77a75" translate="yes" xml:space="preserve">
          <source>Two things are interesting here:</source>
          <target state="translated">ここで気になるのは2つ。</target>
        </trans-unit>
        <trans-unit id="ced48512ad4d3cb13ca20b7cb1f2f8e4abd0bc9d" translate="yes" xml:space="preserve">
          <source>Tying it all together</source>
          <target state="translated">結び付け</target>
        </trans-unit>
        <trans-unit id="3a87a5a93967e0c0facb5bdbedab0a6936494920" translate="yes" xml:space="preserve">
          <source>Type 5 is reserved for future expansion. Type 0 is invalid.</source>
          <target state="translated">タイプ 5 は将来の拡張のために予約されています。タイプ0は無効です。</target>
        </trans-unit>
        <trans-unit id="e8e8d3184972cec12ef3bd94d7eec7947cbe4b53" translate="yes" xml:space="preserve">
          <source>Typical gitweb config files will only change starting (default) time zone, and leave other elements at their default values:</source>
          <target state="translated">典型的な gitweb の設定ファイルは、開始時刻 (デフォルト)のタイムゾーンを変更するだけで、他の要素はデフォルトのままにしておきます。</target>
        </trans-unit>
        <trans-unit id="3aa25a3911a2da2f000729dbc451ee040fee4a66" translate="yes" xml:space="preserve">
          <source>Typical usage is something like:</source>
          <target state="translated">典型的な使い方はこんな感じです。</target>
        </trans-unit>
        <trans-unit id="db1f5b1028dc570d4bb8caccd45a45601a38210c" translate="yes" xml:space="preserve">
          <source>Typical use of git credential</source>
          <target state="translated">git credential の典型的な使い方</target>
        </trans-unit>
        <trans-unit id="d63a8a509d39725ec5fc85189ba54ffbab2dd0bb" translate="yes" xml:space="preserve">
          <source>Typically it will be placed in a MUA&amp;rsquo;s drafts folder, edited to add timely commentary that should not go in the changelog after the three dashes, and then sent as a message whose body, in our example, starts with &quot;arch/arm config files were&amp;hellip;​&quot;. On the receiving end, readers can save interesting patches in a UNIX mailbox and apply them with &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt;.</source>
          <target state="translated">通常、それはMUAの下書きフォルダに配置され、3つのダッシュの後に変更ログに入れるべきではないタイムリーなコメントを追加するように編集され、この例では本文が「arch / arm config files was &amp;hellip;」。受信側では、読者は興味深いパッチをUNIXメールボックスに保存し、それらを&lt;a href=&quot;git-am&quot;&gt;git-am [1]で&lt;/a&gt;適用できます。</target>
        </trans-unit>
        <trans-unit id="3b51965ce078cc4b0d9ecb0a1b113a383a8700dc" translate="yes" xml:space="preserve">
          <source>Typically such a variable may look like this:</source>
          <target state="translated">通常、このような変数は次のようになります。</target>
        </trans-unit>
        <trans-unit id="9f47be9cc1e7fcec80fcc7e52dcbd486a27d2ee2" translate="yes" xml:space="preserve">
          <source>Typically this is run with a script calling Git&amp;rsquo;s imitation of the &lt;code&gt;merge&lt;/code&gt; command from the RCS package.</source>
          <target state="translated">通常、これはRCSパッケージからの &lt;code&gt;merge&lt;/code&gt; コマンドのGitの模倣を呼び出すスクリプトで実行されます。</target>
        </trans-unit>
        <trans-unit id="e4333d902cedfd0d4739277fdec621b3f9f09422" translate="yes" xml:space="preserve">
          <source>Typically this matches the real type of &amp;lt;object&amp;gt; but asking for a type that can trivially be dereferenced from the given &amp;lt;object&amp;gt; is also permitted. An example is to ask for a &quot;tree&quot; with &amp;lt;object&amp;gt; being a commit object that contains it, or to ask for a &quot;blob&quot; with &amp;lt;object&amp;gt; being a tag object that points at it.</source>
          <target state="translated">通常、これは&amp;lt;object&amp;gt;の実際のタイプと一致しますが、特定の&amp;lt;object&amp;gt;から簡単に逆参照できるタイプを要求することも許可されます。例としては、&amp;lt;object&amp;gt;が含まれる &quot;ツリー&quot;を含むコミットオブジェクト、または&amp;lt;object&amp;gt;がそれを指すタグオブジェクトである &quot;blob&quot;を要求する場合があります。</target>
        </trans-unit>
        <trans-unit id="6b016c5601edd059fd8dc12bb8d8426b6525fff2" translate="yes" xml:space="preserve">
          <source>Typically you would first remove all tracked files from the working tree using this command:</source>
          <target state="translated">通常は、まずこのコマンドを使って作業ツリーからすべての追跡されたファイルを削除します。</target>
        </trans-unit>
        <trans-unit id="3a2ee6ee14f11a86e1818d26c21e9493d38718f1" translate="yes" xml:space="preserve">
          <source>Typically, parallel recursive and multi-remote fetches will be faster. By default fetches are performed sequentially, not in parallel.</source>
          <target state="translated">一般的に、並列再帰的なフェッチや複数のリモートからのフェッチの方が高速です。デフォルトでは、フェッチは並列ではなく順次実行されます。</target>
        </trans-unit>
        <trans-unit id="94e92e77c127b9c8a314ec2c48c4916e008c6404" translate="yes" xml:space="preserve">
          <source>Typically, this is invoked as &lt;code&gt;git read-tree -m $H $M&lt;/code&gt;, where $H is the head commit of the current repository, and $M is the head of a foreign tree, which is simply ahead of $H (i.e. we are in a fast-forward situation).</source>
          <target state="translated">通常、これは &lt;code&gt;git read-tree -m $H $M&lt;/code&gt; として呼び出されます。ここで、$ Hは現在のリポジトリの先頭コミットであり、$ Mは外部ツリーの先頭であり、$ Hの前にあります（つまり、早送りの状況にあります）。</target>
        </trans-unit>
        <trans-unit id="0ada5827188094ef6e82c28e45e078ca96f54ca4" translate="yes" xml:space="preserve">
          <source>U: file is unmerged (you must complete the merge before it can be committed)</source>
          <target state="translated">U:ファイルがマージされていません (コミットする前にマージを完了する必要があります)</target>
        </trans-unit>
        <trans-unit id="1a7a0d0dd35212ae4c8c4c873315c6e7e9351f3b" translate="yes" xml:space="preserve">
          <source>URI and label (title) for the Git logo link (or your site logo, if you chose to use different logo image). By default, these both refer to Git homepage, &lt;a href=&quot;https://git-scm.com&quot;&gt;https://git-scm.com&lt;/a&gt;; in the past, they pointed to Git documentation at &lt;a href=&quot;https://www.kernel.org&quot;&gt;https://www.kernel.org&lt;/a&gt;.</source>
          <target state="translated">Gitロゴリンク（または別のロゴ画像を使用することを選択した場合はサイトのロゴ）のURIとラベル（タイトル）。デフォルトでは、どちらもGitホームページ&lt;a href=&quot;https://git-scm.com&quot;&gt;https://git-scm.comを&lt;/a&gt;参照しています。以前は、&lt;a href=&quot;https://www.kernel.org&quot;&gt;https：&lt;/a&gt; //www.kernel.orgにあるGitのドキュメントを参照していました。</target>
        </trans-unit>
        <trans-unit id="8561702ffd22bbb5ccd1a81c9c8d8cc77f16fa7e" translate="yes" xml:space="preserve">
          <source>Un-sets the previously set type specifier (if one was previously set). This option requests that &lt;code&gt;git config&lt;/code&gt; not canonicalize the retrieved variable. &lt;code&gt;--no-type&lt;/code&gt; has no effect without &lt;code&gt;--type=&amp;lt;type&amp;gt;&lt;/code&gt; or &lt;code&gt;--&amp;lt;type&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">以前に設定されたタイプ指定子の設定を解除します（以前に設定されていた場合）。このオプションは、 &lt;code&gt;git config&lt;/code&gt; が取得した変数を正規化しないことを要求します。 &lt;code&gt;--no-type&lt;/code&gt; は、 &lt;code&gt;--&amp;lt;type&amp;gt;&lt;/code&gt; &lt;code&gt;--type=&amp;lt;type&amp;gt;&lt;/code&gt; または-&amp;lt;type&amp;gt;なしでは効果がありません。</target>
        </trans-unit>
        <trans-unit id="911839695653d988872929c95814b8902e300040" translate="yes" xml:space="preserve">
          <source>Under &lt;code&gt;--pretty=oneline&lt;/code&gt;, the commit message is prefixed with this information on the same line. This option cannot be combined with &lt;code&gt;--reverse&lt;/code&gt;. See also &lt;a href=&quot;git-reflog&quot;&gt;git-reflog[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;--pretty=oneline&lt;/code&gt; の下では、コミットメッセージの同じ行にこの情報がプレフィックスされます。このオプションを &lt;code&gt;--reverse&lt;/code&gt; と組み合わせることはできません。&lt;a href=&quot;git-reflog&quot;&gt;git-reflog [1]&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="64ba59969ba5a36d002d9a189101c624fcf7d3cc" translate="yes" xml:space="preserve">
          <source>Under &lt;code&gt;--pretty=reference&lt;/code&gt;, this information will not be shown at all.</source>
          <target state="translated">&lt;code&gt;--pretty=reference&lt;/code&gt; の下では、この情報はまったく表示されません。</target>
        </trans-unit>
        <trans-unit id="c73a6e04cc57ad10ee4ae7284f559a5ae2a53d36" translate="yes" xml:space="preserve">
          <source>Under certain circumstances, some versions of &lt;code&gt;diff&lt;/code&gt; do not correctly detect a missing new-line at the end of the file. As a result, patches created by such &lt;code&gt;diff&lt;/code&gt; programs do not record incomplete lines correctly. This option adds support for applying such patches by working around this bug.</source>
          <target state="translated">特定の状況下では、 &lt;code&gt;diff&lt;/code&gt; の一部のバージョンでは、ファイルの最後にある欠落した改行が正しく検出されません。その結果、そのような &lt;code&gt;diff&lt;/code&gt; プログラムによって作成されたパッチは、不完全な行を正しく記録しません。このオプションは、このバグを回避することにより、そのようなパッチの適用のサポートを追加します。</target>
        </trans-unit>
        <trans-unit id="67a27dbf5548d05ac63e85bd8b4c875d8f48c102" translate="yes" xml:space="preserve">
          <source>Understanding History: Commits</source>
          <target state="translated">歴史を理解する。コミット</target>
        </trans-unit>
        <trans-unit id="9334dba95d5dfb2042093dd9adbddea5f77c5eb4" translate="yes" xml:space="preserve">
          <source>Understanding history: History diagrams</source>
          <target state="translated">歴史を理解する。歴史の図解</target>
        </trans-unit>
        <trans-unit id="85bd1a7ea75afef7e0417cd2bf9d9f3cf13e5e08" translate="yes" xml:space="preserve">
          <source>Understanding history: What is a branch?</source>
          <target state="translated">歴史を理解する。枝とは何か?</target>
        </trans-unit>
        <trans-unit id="6d61d96a492f996316f1e84e66cbfde933315e2c" translate="yes" xml:space="preserve">
          <source>Understanding history: commits, parents, and reachability</source>
          <target state="translated">歴史を理解する:コミット、親、到達可能性</target>
        </trans-unit>
        <trans-unit id="afa47a28efb9d6631a7be02ac359bed5256995ce" translate="yes" xml:space="preserve">
          <source>Undo a commit and redo</source>
          <target state="translated">コミットを取り消してやり直し</target>
        </trans-unit>
        <trans-unit id="61cb90c052dfcd0fda883c6029d1d0fc0a0f4685" translate="yes" xml:space="preserve">
          <source>Undo a commit, making it a topic branch</source>
          <target state="translated">コミットを元に戻してトピックブランチにする</target>
        </trans-unit>
        <trans-unit id="93d74feb000c815128d68a09c83733db43b69c15" translate="yes" xml:space="preserve">
          <source>Undo a merge or pull</source>
          <target state="translated">マージまたはプルを元に戻す</target>
        </trans-unit>
        <trans-unit id="4728c70cd06347b5f285fb3e7887387303b3968e" translate="yes" xml:space="preserve">
          <source>Undo a merge or pull inside a dirty working tree</source>
          <target state="translated">汚れた作業ツリー内でのマージやプルを元に戻す</target>
        </trans-unit>
        <trans-unit id="27b7abb5b90b7a2e8f00eaf74b6df8323ba7d926" translate="yes" xml:space="preserve">
          <source>Undo add</source>
          <target state="translated">追加を元に戻す</target>
        </trans-unit>
        <trans-unit id="ca677a11d37ffdca5231911a194cc2fcdffc5a26" translate="yes" xml:space="preserve">
          <source>Undo commits permanently</source>
          <target state="translated">コミットを恒久的に元に戻す</target>
        </trans-unit>
        <trans-unit id="4180759bca2f04cde0ec69611cb0e0ec1cfe7139" translate="yes" xml:space="preserve">
          <source>Undoes the effects of &lt;code&gt;fetch&lt;/code&gt; back to the specified revision. This allows you to re-&lt;code&gt;fetch&lt;/code&gt; an SVN revision. Normally the contents of an SVN revision should never change and &lt;code&gt;reset&lt;/code&gt; should not be necessary. However, if SVN permissions change, or if you alter your --ignore-paths option, a &lt;code&gt;fetch&lt;/code&gt; may fail with &quot;not found in commit&quot; (file not previously visible) or &quot;checksum mismatch&quot; (missed a modification). If the problem file cannot be ignored forever (with --ignore-paths) the only way to repair the repo is to use &lt;code&gt;reset&lt;/code&gt;.</source>
          <target state="translated">指定したリビジョンへの &lt;code&gt;fetch&lt;/code&gt; の影響を元に戻します。これにより、SVNリビジョンを再 &lt;code&gt;fetch&lt;/code&gt; できます。通常、SVNリビジョンの内容は決して変更 &lt;code&gt;reset&lt;/code&gt; ず、リセットは必要ありません。ただし、SVN権限が変更された場合、または--ignore-pathsオプションを変更した場合、「コミットで見つかりません」（以前に表示されなかったファイル）または「チェックサムの不一致」（変更が失われた）で &lt;code&gt;fetch&lt;/code&gt; が失敗する場合があります。問題のファイルを永久に無視できない場合（--ignore-pathsを使用）、リポジトリを修復する唯一の方法は、 &lt;code&gt;reset&lt;/code&gt; を使用することです。</target>
        </trans-unit>
        <trans-unit id="ac1f58f831611819b4114b80dd55e3ce540d5b23" translate="yes" xml:space="preserve">
          <source>Undoing a merge</source>
          <target state="translated">マージを元に戻す</target>
        </trans-unit>
        <trans-unit id="f552d5a5802e3df6273c784214def9840b82f594" translate="yes" xml:space="preserve">
          <source>Unfortunately this system becomes inefficient once a project has a lot of objects. Try this on an old project:</source>
          <target state="translated">残念ながら、このシステムはプロジェクトに多くのオブジェクトがあると効率が悪くなります。古いプロジェクトで試してみてください。</target>
        </trans-unit>
        <trans-unit id="c7deb06b3e42a38e2b00598939aa39f8d24897bd" translate="yes" xml:space="preserve">
          <source>Unfortunately, the desired effect of cleaning up text files with mixed line endings and the undesired effect of corrupting binary files cannot be distinguished. In both cases CRLFs are removed in an irreversible way. For text files this is the right thing to do because CRLFs are line endings, while for binary files converting CRLFs corrupts data.</source>
          <target state="translated">残念ながら、行末が混在するテキストファイルをクリーンアップするという望ましい効果と、バイナリファイルを破損させるという望ましくない効果を区別することはできません。どちらの場合も、CRLF は不可逆的な方法で削除されます。テキスト ファイルの場合は CRLF が行末であるため、これは正しいことですが、バイナリ ファイルの場合は CRLF を変換するとデータが破損します。</target>
        </trans-unit>
        <trans-unit id="6da1ce58d3a6c34c76807dc44593d7cd8c6563b6" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;--text&lt;/code&gt; is supplied patches of binary files without a textconv filter will be ignored.</source>
          <target state="translated">&lt;code&gt;--text&lt;/code&gt; が提供されない限り、textconvフィルターのないバイナリファイルのパッチは無視されます。</target>
        </trans-unit>
        <trans-unit id="54cbf98b314812a07f65f95ae77e8608ddf0b26f" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;-f&lt;/code&gt; is given, the &lt;code&gt;replace&lt;/code&gt; reference must not yet exist.</source>
          <target state="translated">&lt;code&gt;-f&lt;/code&gt; を指定しない限り、 &lt;code&gt;replace&lt;/code&gt; 参照はまだ存在していてはなりません。</target>
        </trans-unit>
        <trans-unit id="ec0a9816e3fe8947b4bfff6f5914c3288bed6fc9" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;-f&lt;/code&gt; is given, the named tag must not yet exist.</source>
          <target state="translated">&lt;code&gt;-f&lt;/code&gt; を指定しない限り、名前付きタグはまだ存在していてはなりません。</target>
        </trans-unit>
        <trans-unit id="7824ccb45f3d7be1fd07def25712792fbdf3f009" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;git blame&lt;/code&gt; and &lt;code&gt;git annotate&lt;/code&gt; in older versions of git, the extent of the annotation can be limited to both line ranges and revision ranges. The &lt;code&gt;-L&lt;/code&gt; option, which limits annotation to a range of lines, may be specified multiple times.</source>
          <target state="translated">古いバージョンのgitの &lt;code&gt;git blame&lt;/code&gt; や &lt;code&gt;git annotate&lt;/code&gt; とは異なり、注釈の範囲は行範囲とリビジョン範囲の両方に制限できます。 &lt;code&gt;-L&lt;/code&gt; 線の範囲に注釈を制限オプションは、複数回指定することができます。</target>
        </trans-unit>
        <trans-unit id="1fa5e3a4c28161d2ef67ee80d5624341cfa56be1" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;git diff-files&lt;/code&gt;, which showed the difference between the index file and the working tree, &lt;code&gt;git diff-index&lt;/code&gt; shows the differences between a committed &lt;strong&gt;tree&lt;/strong&gt; and either the index file or the working tree. In other words, &lt;code&gt;git diff-index&lt;/code&gt; wants a tree to be diffed against, and before we did the commit, we couldn&amp;rsquo;t do that, because we didn&amp;rsquo;t have anything to diff against.</source>
          <target state="translated">インデックスファイルと作業ツリーの違いを示した &lt;code&gt;git diff-files&lt;/code&gt; とは異なり、 &lt;code&gt;git diff-index&lt;/code&gt; はコミットされた&lt;strong&gt;ツリー&lt;/strong&gt;とインデックスファイルまたは作業ツリーのどちらかとの違いを示します。言い換えると、 &lt;code&gt;git diff-index&lt;/code&gt; はツリーを比較することを望んでいます。コミットを行う前は、比較するものがなかったため、それを行うことができませんでした。</target>
        </trans-unit>
        <trans-unit id="a75073ebd9356a7219cb30b4bb866c17ce8b906c" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;gitk&lt;/code&gt;, &lt;code&gt;git gui&lt;/code&gt; focuses on commit generation and single file annotation and does not show project history. It does however supply menu actions to start a &lt;code&gt;gitk&lt;/code&gt; session from within &lt;code&gt;git gui&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gitk&lt;/code&gt; とは異なり、 &lt;code&gt;git gui&lt;/code&gt; はコミットの生成と単一ファイルのアノテーションに焦点を当てており、プロジェクト履歴を表示しません。ただし、 &lt;code&gt;git gui&lt;/code&gt; 内から &lt;code&gt;gitk&lt;/code&gt; セッションを開始するためのメニューアクションを提供します。</target>
        </trans-unit>
        <trans-unit id="cd17281830ac5a9aa50c0d768481eabf04240182" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;code&gt;raw&lt;/code&gt; format above, the time zone/UTC offset information contained in an RFC 2822 date string is used to adjust the date value to UTC prior to storage. Therefore it is important that this information be as accurate as possible.</source>
          <target state="translated">上記の &lt;code&gt;raw&lt;/code&gt; 形式とは異なり、RFC 2822日付文字列に含まれるタイムゾーン/ UTCオフセット情報は、保存前に日付値をUTCに調整するために使用されます。したがって、この情報はできるだけ正確であることが重要です。</target>
        </trans-unit>
        <trans-unit id="b9ebe23208a4d3f51d6690b78b04b40646f8e2f1" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;code&gt;rfc2822&lt;/code&gt; format, this format is very strict. Any variation in formatting will cause fast-import to reject the value, and some sanity checks on the numeric values may also be performed.</source>
          <target state="translated">&lt;code&gt;rfc2822&lt;/code&gt; 形式とは異なり、この形式は非常に厳密です。フォーマットに変化があると、高速インポートで値が拒否され、数値のサニティチェックも実行される場合があります。</target>
        </trans-unit>
        <trans-unit id="422977ffd462a03a6cbce65db58b07001eb2214f" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;code&gt;rfc2822&lt;/code&gt; format, this format is very strict. Any variation in formatting will cause fast-import to reject the value.</source>
          <target state="translated">&lt;code&gt;rfc2822&lt;/code&gt; 形式とは異なり、この形式は非常に厳密です。書式設定にばらつきがあると、高速インポートで値が拒否されます。</target>
        </trans-unit>
        <trans-unit id="a5e8af576412d2facd9f39a0996da0da165c42ee" translate="yes" xml:space="preserve">
          <source>Unlike the Porcelain format, the filename information is always given and terminates the entry:</source>
          <target state="translated">Porcelain形式とは異なり、ファイル名の情報は常に与えられ、エントリは終了します。</target>
        </trans-unit>
        <trans-unit id="b603b31236d9df1a4442c23c62ea6317f2525837" translate="yes" xml:space="preserve">
          <source>Unlike the longhand form, when Alice fetches from Bob using a remote repository shorthand set up with &lt;code&gt;git remote&lt;/code&gt;, what was fetched is stored in a remote-tracking branch, in this case &lt;code&gt;bob/master&lt;/code&gt;. So after this:</source>
          <target state="translated">ロングハンドフォームとは異なり、アリスが &lt;code&gt;git remote&lt;/code&gt; で設定されたリモートリポジトリショートハンドを使用してボブからフェッチすると、フェッチされたものはリモート追跡ブランチ（この場合は &lt;code&gt;bob/master&lt;/code&gt; ）に格納されます。したがって、この後：</target>
        </trans-unit>
        <trans-unit id="cc8e9909209a90f3a790bc3005980e8527de79e5" translate="yes" xml:space="preserve">
          <source>Unlike the traditional &lt;code&gt;unified&lt;/code&gt; diff format, which shows two files A and B with a single column that has &lt;code&gt;-&lt;/code&gt; (minus &amp;mdash; appears in A but removed in B), &lt;code&gt;+&lt;/code&gt; (plus &amp;mdash; missing in A but added to B), or &lt;code&gt;&quot; &quot;&lt;/code&gt; (space &amp;mdash; unchanged) prefix, this format compares two or more files file1, file2,&amp;hellip;​ with one file X, and shows how X differs from each of fileN. One column for each of fileN is prepended to the output line to note how X&amp;rsquo;s line is different from it.</source>
          <target state="translated">伝統とは異なり、 &lt;code&gt;unified&lt;/code&gt; diff形式、ショー二つのファイルAと持っている単一の列とB &lt;code&gt;-&lt;/code&gt; （マイナス- Aに表示されますが、Bで削除）、 &lt;code&gt;+&lt;/code&gt; （プラス- Aに欠けているが、Bに加える）、または &lt;code&gt;&quot; &quot;&lt;/code&gt; （スペース-変更なし）接頭辞。このフォーマットは、2つ以上のファイルfile1、file2、&amp;hellip;を1つのファイルXと比較し、Xが各fileNとどのように異なるかを示します。 Xの行がどのように異なるかを示すために、fileNごとに1つの列が出力行の先頭に追加されます。</target>
        </trans-unit>
        <trans-unit id="71233552f2a4fc77054593fac1f6899dd0308229" translate="yes" xml:space="preserve">
          <source>Unlike variables like &lt;code&gt;color.ui&lt;/code&gt; and &lt;code&gt;core.editor&lt;/code&gt; the &lt;code&gt;receive.fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; and &lt;code&gt;fetch.fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; variables will not fall back on the &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; configuration if they aren&amp;rsquo;t set. To uniformly configure the same fsck settings in different circumstances all three of them they must all set to the same values.</source>
          <target state="translated">異なりのような変数 &lt;code&gt;color.ui&lt;/code&gt; と &lt;code&gt;core.editor&lt;/code&gt; &lt;code&gt;receive.fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; と &lt;code&gt;fetch.fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; 変数は、上で戻って落ちることはありません &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; コンフィギュレーションそうでない場合セットする。異なる状況で同じfsck設定を均一に構成するには、3つすべてを同じ値に設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="00ee5ed7b48c819f6f323dbe1b9a72aef5a0c864" translate="yes" xml:space="preserve">
          <source>Unlike variables like &lt;code&gt;color.ui&lt;/code&gt; and &lt;code&gt;core.editor&lt;/code&gt; the &lt;code&gt;receive.fsck.skipList&lt;/code&gt; and &lt;code&gt;fetch.fsck.skipList&lt;/code&gt; variables will not fall back on the &lt;code&gt;fsck.skipList&lt;/code&gt; configuration if they aren&amp;rsquo;t set. To uniformly configure the same fsck settings in different circumstances all three of them they must all set to the same values.</source>
          <target state="translated">以下のような変数とは異なり &lt;code&gt;color.ui&lt;/code&gt; と &lt;code&gt;core.editor&lt;/code&gt; &lt;code&gt;receive.fsck.skipList&lt;/code&gt; と &lt;code&gt;fetch.fsck.skipList&lt;/code&gt; 変数は、上で戻って落ちることはありません &lt;code&gt;fsck.skipList&lt;/code&gt; のそれらが設定されていない場合は、設定。異なる状況で同じfsck設定を均一に構成するには、3つすべてを同じ値に設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="8a3dffb4c65d7a1f27e907ef2a919885d1125ac9" translate="yes" xml:space="preserve">
          <source>Unlike when pushing with &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;, any updates outside of &lt;code&gt;refs/{tags,heads}/*&lt;/code&gt; will be accepted without &lt;code&gt;+&lt;/code&gt; in the refspec (or &lt;code&gt;--force&lt;/code&gt;), whether that&amp;rsquo;s swapping e.g. a tree object for a blob, or a commit for another commit that&amp;rsquo;s doesn&amp;rsquo;t have the previous commit as an ancestor etc.</source>
          <target state="translated">&lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt;でプッシュする場合とは異なり、refspec &lt;code&gt;refs/{tags,heads}/*&lt;/code&gt; 以外の更新は、refspec（または &lt;code&gt;--force&lt;/code&gt; ）に &lt;code&gt;+&lt;/code&gt; なしで受け入れられます。または、先祖としての以前のコミットを持たない別のコミットのコミットなど。</target>
        </trans-unit>
        <trans-unit id="2f2516ccb262ba2dda1eeb5218e911868837ce78" translate="yes" xml:space="preserve">
          <source>Unlike when pushing with &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;, there is no configuration which&amp;rsquo;ll amend these rules, and nothing like a &lt;code&gt;pre-fetch&lt;/code&gt; hook analogous to the &lt;code&gt;pre-receive&lt;/code&gt; hook.</source>
          <target state="translated">&lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt;でプッシュする場合とは異なり、これらのルールを修正する構成はなく、 &lt;code&gt;pre-receive&lt;/code&gt; フックに類似した事前 &lt;code&gt;pre-fetch&lt;/code&gt; フックのようなものはありません。</target>
        </trans-unit>
        <trans-unit id="fb79f423670171900d7e94880e8d45907e9f995c" translate="yes" xml:space="preserve">
          <source>Unlock a working tree, allowing it to be pruned, moved or deleted.</source>
          <target state="translated">作業木のロックを解除して、剪定、移動、削除を可能にします。</target>
        </trans-unit>
        <trans-unit id="b00eee8b49227caba98e5d68033660ff6076ebcc" translate="yes" xml:space="preserve">
          <source>Unmerged entries have the following format; the first character is a &quot;u&quot; to distinguish from ordinary changed entries.</source>
          <target state="translated">マージされていないエントリは以下の形式になります。最初の文字は、通常の変更されたエントリと区別するための「u」です。</target>
        </trans-unit>
        <trans-unit id="2c99cc569343579b221cd64026ecc62bb1c21d7b" translate="yes" xml:space="preserve">
          <source>Unpack objects from a packed archive</source>
          <target state="translated">パックされたアーカイブからオブジェクトを展開する</target>
        </trans-unit>
        <trans-unit id="42e2a268d032a6abb00d4cbd80feaa1ecd7a75d6" translate="yes" xml:space="preserve">
          <source>Unreachable tags, commits, and trees will also be accessed to find the tips of dangling segments of history. Use &lt;code&gt;--no-dangling&lt;/code&gt; if you don&amp;rsquo;t care about this output and want to speed it up further.</source>
          <target state="translated">到達できないタグ、コミット、ツリーにもアクセスして、履歴のぶら下がりセグメントのヒントを見つけます。この出力を気にせず、さらに高速化する場合は、 &lt;code&gt;--no-dangling&lt;/code&gt; 使用します。</target>
        </trans-unit>
        <trans-unit id="d8a4efd1d470fc3c5ede97084c82a35b9804122a" translate="yes" xml:space="preserve">
          <source>Unregister the given submodules, i.e. remove the whole &lt;code&gt;submodule.$name&lt;/code&gt; section from .git/config together with their work tree. Further calls to &lt;code&gt;git submodule update&lt;/code&gt;, &lt;code&gt;git submodule foreach&lt;/code&gt; and &lt;code&gt;git submodule sync&lt;/code&gt; will skip any unregistered submodules until they are initialized again, so use this command if you don&amp;rsquo;t want to have a local checkout of the submodule in your working tree anymore.</source>
          <target state="translated">指定されたサブモジュールの登録を解除し &lt;code&gt;submodule.$name&lt;/code&gt; つまり、サブモジュール全体を$ .nameセクションを.git / configから作業ツリーとともに削除します。 &lt;code&gt;git submodule update&lt;/code&gt; 、 &lt;code&gt;git submodule foreach&lt;/code&gt; 、 &lt;code&gt;git submodule sync&lt;/code&gt; をさらに呼び出すと、未登録のサブモジュールが再度初期化されるまでスキップされるため、作業ツリーでサブモジュールのローカルチェックアウトを行わない場合は、このコマンドを使用します。</target>
        </trans-unit>
        <trans-unit id="1431f68f359f8699975be39dca08302c67d68d9e" translate="yes" xml:space="preserve">
          <source>Unset</source>
          <target state="translated">Unset</target>
        </trans-unit>
        <trans-unit id="8ff954e80b42b18d3d0fcda602d94db1e46da2d4" translate="yes" xml:space="preserve">
          <source>Unsetting the &lt;code&gt;text&lt;/code&gt; attribute on a path tells Git not to attempt any end-of-line conversion upon checkin or checkout.</source>
          <target state="translated">パスの &lt;code&gt;text&lt;/code&gt; 属性を設定解除すると、チェックインまたはチェックアウト時にGitが行末変換を試行しないようになります。</target>
        </trans-unit>
        <trans-unit id="7f84947907454dd0cb412d2a8e5d5e3b9c2382f0" translate="yes" xml:space="preserve">
          <source>Unsetting the variable, or setting it to empty, &quot;0&quot; or &quot;false&quot; (case insensitive) disables trace messages.</source>
          <target state="translated">変数の設定を解除するか、空、&quot;0 &quot;または &quot;false&quot;(大文字小文字を区別しない)に設定すると、トレースメッセージが無効になります。</target>
        </trans-unit>
        <trans-unit id="c176eff9c64fa28a4b6af1aa296cc1394bbf7a80" translate="yes" xml:space="preserve">
          <source>Unshelve</source>
          <target state="translated">Unshelve</target>
        </trans-unit>
        <trans-unit id="9fde2b36ff30053ad23e6a695929873244cc0367" translate="yes" xml:space="preserve">
          <source>Unshelve options</source>
          <target state="translated">オプションを解除する</target>
        </trans-unit>
        <trans-unit id="004e593b6690fb3d48f4f5a86eac1cd13b5b2234" translate="yes" xml:space="preserve">
          <source>Unshelving will take a shelved P4 changelist, and produce the equivalent git commit in the branch refs/remotes/p4-unshelved/&amp;lt;changelist&amp;gt;.</source>
          <target state="translated">Unshelvingは保留されたP4チェンジリストを受け取り、ブランチrefs / remotes / p4-unshelved / &amp;lt;changelist&amp;gt;に同等のgit commitを生成します。</target>
        </trans-unit>
        <trans-unit id="a6e7eb706e115cdaf88206be37eb67b232d007bc" translate="yes" xml:space="preserve">
          <source>Unspecified</source>
          <target state="translated">Unspecified</target>
        </trans-unit>
        <trans-unit id="78f88266b367e8b6e086054e91f1ebc89e168d16" translate="yes" xml:space="preserve">
          <source>Until Git version 2.20, and unlike when pushing with &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;, any updates to &lt;code&gt;refs/tags/*&lt;/code&gt; would be accepted without &lt;code&gt;+&lt;/code&gt; in the refspec (or &lt;code&gt;--force&lt;/code&gt;). When fetching, we promiscuously considered all tag updates from a remote to be forced fetches. Since Git version 2.20, fetching to update &lt;code&gt;refs/tags/*&lt;/code&gt; works the same way as when pushing. I.e. any updates will be rejected without &lt;code&gt;+&lt;/code&gt; in the refspec (or &lt;code&gt;--force&lt;/code&gt;).</source>
          <target state="translated">Gitバージョン2.20まで、および&lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt;でプッシュする場合とは異なり、 &lt;code&gt;refs/tags/*&lt;/code&gt; への更新は、refspec（または &lt;code&gt;--force&lt;/code&gt; ）に &lt;code&gt;+&lt;/code&gt; なしで受け入れられます。フェッチするとき、リモートからのすべてのタグの更新が強制フェッチであると無差別に考慮しました。Gitバージョン2.20以降、 &lt;code&gt;refs/tags/*&lt;/code&gt; を更新するためのフェッチは、プッシュ時と同じように機能します。つまり、refspec（または &lt;code&gt;--force&lt;/code&gt; ）に &lt;code&gt;+&lt;/code&gt; がなければ、更新は拒否されます。</target>
        </trans-unit>
        <trans-unit id="9514c500d61430538679eec9081979b274172cf9" translate="yes" xml:space="preserve">
          <source>Untracked cache</source>
          <target state="translated">未踏キャッシュ</target>
        </trans-unit>
        <trans-unit id="614ce4ff1bf92552970ab54ff766006d0da693f9" translate="yes" xml:space="preserve">
          <source>Untracked items have the following format:</source>
          <target state="translated">トラックされていない項目は、以下のような形式になっています。</target>
        </trans-unit>
        <trans-unit id="1eade895e693b4111455eda06a87af1097cf4d6c" translate="yes" xml:space="preserve">
          <source>Untyped &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt;, e.g. the contents of a file.</source>
          <target state="translated">型なし&lt;a href=&quot;#def_object&quot;&gt;オブジェクト&lt;/a&gt;（例：ファイルの内容）。</target>
        </trans-unit>
        <trans-unit id="7b839a219907b09268c047c522a03961e96bd78b" translate="yes" xml:space="preserve">
          <source>Unused configuration variable. Used in Git versions 2.20 and 2.21 as an escape hatch to enable the legacy shellscript implementation of rebase. Now the built-in rewrite of it in C is always used. Setting this will emit a warning, to alert any remaining users that setting this now does nothing.</source>
          <target state="translated">未使用の設定変数です。Git バージョン 2.20 と 2.21 で、レガシーなシェルスクリプトの実装である rebase を有効にするためのエスケープハッチとして使用されました。現在は、C 言語での組み込みの書き換えが常に使用されています。これを設定すると警告が表示され、残っているユーザーには何もしないことを警告します。</target>
        </trans-unit>
        <trans-unit id="315fc3f07f41b1c3600ceb87f6a9f32b85f1da70" translate="yes" xml:space="preserve">
          <source>Unused configuration variable. Used in Git versions 2.22 to 2.26 as an escape hatch to enable the legacy shellscript implementation of stash. Now the built-in rewrite of it in C is always used. Setting this will emit a warning, to alert any remaining users that setting this now does nothing.</source>
          <target state="translated">未使用の設定変数です。Git のバージョン 2.22 から 2.26 で、レガシーなシェルスクリプトの実装である stash を有効にするためのエスケープハッチとして使用されています。現在は、C言語での組み込みの書き換えが常に使用されています。これを設定すると警告が表示され、これを設定しても何もしないことを警告します。</target>
        </trans-unit>
        <trans-unit id="ca31b4c795dcb03444e6d0c037dbcd47081c70a9" translate="yes" xml:space="preserve">
          <source>Update affected files from CVS repository before attempting export.</source>
          <target state="translated">エクスポートを試みる前に、CVS リポジトリから影響を受けるファイルを更新してください。</target>
        </trans-unit>
        <trans-unit id="82e59b151c004802a1fa23ba3e75a68d14df0e2a" translate="yes" xml:space="preserve">
          <source>Update an existing shelved changelist with this commit. Implies --shelve. Repeat for multiple shelved changelists.</source>
          <target state="translated">このコミットで既存の棚上げされた変更リストを更新します。-shelve を意味します。複数のシェル化された変更リストに対して繰り返してください。</target>
        </trans-unit>
        <trans-unit id="5433caf2e572561b5bb38ff5e69b0263d08b90aa" translate="yes" xml:space="preserve">
          <source>Update and examine branches from the repository you cloned from:</source>
          <target state="translated">クローンしたリポジトリからブランチを更新して調べます。</target>
        </trans-unit>
        <trans-unit id="381f15e94e347f076ef71f417ee29b782a6dcc4d" translate="yes" xml:space="preserve">
          <source>Update auxiliary info file to help dumb servers</source>
          <target state="translated">補助情報ファイルを更新して、ダムサーバーを支援する</target>
        </trans-unit>
        <trans-unit id="d94aecddb1a2d3c03afb4a7cf4e1bb3a0123c2c6" translate="yes" xml:space="preserve">
          <source>Update hook</source>
          <target state="translated">フックの更新</target>
        </trans-unit>
        <trans-unit id="e5f960e3f28d7d7ea59f8750682a356ae18535be" translate="yes" xml:space="preserve">
          <source>Update remote refs along with associated objects</source>
          <target state="translated">関連するオブジェクトと一緒にリモート参照を更新する</target>
        </trans-unit>
        <trans-unit id="ee3315ea0cbb49ab6105a89db0964480184c3ce9" translate="yes" xml:space="preserve">
          <source>Update the Git repository with recent changes from p4, rebasing your work on top:</source>
          <target state="translated">Git リポジトリを p4 からの最近の変更点で更新し、作業内容を上にリベースします。</target>
        </trans-unit>
        <trans-unit id="5937294218e2d7b95b7b77414b52c326239ca8d5" translate="yes" xml:space="preserve">
          <source>Update the index by adding new files that are unknown to the index and files modified in the working tree, but ignore files that have been removed from the working tree. This option is a no-op when no &amp;lt;pathspec&amp;gt; is used.</source>
          <target state="translated">インデックスに未知の新しいファイルと作業ツリーで変更されたファイルを追加して、インデックスを更新しますが、作業ツリーから削除されたファイルは無視します。&amp;lt;pathspec&amp;gt;が使用されていない場合、このオプションは何もしません。</target>
        </trans-unit>
        <trans-unit id="94df66721f1bfd4990972c3f5f4a0d6b61f59f9e" translate="yes" xml:space="preserve">
          <source>Update the index just where it already has an entry matching &amp;lt;pathspec&amp;gt;. This removes as well as modifies index entries to match the working tree, but adds no new files.</source>
          <target state="translated">&amp;lt;pathspec&amp;gt;に一致するエントリがすでにある場所でのみインデックスを更新します。これにより、作業ツリーと一致するようにインデックスエントリが削除および変更されますが、新しいファイルは追加されません。</target>
        </trans-unit>
        <trans-unit id="03d173e098621e3730258998672da85e88b347b1" translate="yes" xml:space="preserve">
          <source>Update the index not only where the working tree has a file matching &amp;lt;pathspec&amp;gt; but also where the index already has an entry. This adds, modifies, and removes index entries to match the working tree.</source>
          <target state="translated">作業ツリーに&amp;lt;pathspec&amp;gt;に一致するファイルがある場所だけでなく、インデックスにすでにエントリがある場所でもインデックスを更新します。これにより、作業ツリーと一致するようにインデックスエントリが追加、変更、および削除されます。</target>
        </trans-unit>
        <trans-unit id="1a6e291eaaa3e731de98429f7fb37fdac90f0a22" translate="yes" xml:space="preserve">
          <source>Update the object name stored in a ref safely</source>
          <target state="translated">refに格納されているオブジェクト名を安全に更新する</target>
        </trans-unit>
        <trans-unit id="00f0c8a1eac4ed2966a7d563ef87a6387d365dcf" translate="yes" xml:space="preserve">
          <source>Update the origin repository&amp;rsquo;s master branch with the dev branch, allowing non-fast-forward updates. &lt;strong&gt;This can leave unreferenced commits dangling in the origin repository.&lt;/strong&gt; Consider the following situation, where a fast-forward is not possible:</source>
          <target state="translated">オリジンリポジトリのマスターブランチをdevブランチで更新し、早送り以外の更新を可能にします。&lt;strong&gt;これにより、参照されていないコミットが元のリポジトリにぶら下がる可能性があります。&lt;/strong&gt;早送りが不可能な次の状況を考えます。</target>
        </trans-unit>
        <trans-unit id="b73d3968359117cfd051c2e81a709d1d9e1579b7" translate="yes" xml:space="preserve">
          <source>Update the reference to the value of the top reflog entry (i.e. &amp;lt;ref&amp;gt;@{0}) if the previous top entry was pruned. (This option is ignored for symbolic references.)</source>
          <target state="translated">前のトップエントリが整理されている場合は、リファレンスをトップのreflogエントリの値（つまり、&amp;lt;ref&amp;gt; @ {0}）に更新します。（このオプションは、シンボリック参照では無視されます。）</target>
        </trans-unit>
        <trans-unit id="d7c08d3ae4fbcbbf6a3dc89cdba309659a4395bc" translate="yes" xml:space="preserve">
          <source>Update the reflog for &amp;lt;name&amp;gt; with &amp;lt;reason&amp;gt;. This is valid only when creating or updating a symbolic ref.</source>
          <target state="translated">&amp;lt;name&amp;gt;のreflogを&amp;lt;reason&amp;gt;で更新します。これは、シンボリック参照を作成または更新する場合にのみ有効です。</target>
        </trans-unit>
        <trans-unit id="d053e75e709458eca9f01e5c8910658ea18a25cf" translate="yes" xml:space="preserve">
          <source>Update the registered submodules to match what the superproject expects by cloning missing submodules, fetching missing commits in submodules and updating the working tree of the submodules. The &quot;updating&quot; can be done in several ways depending on command line options and the value of &lt;code&gt;submodule.&amp;lt;name&amp;gt;.update&lt;/code&gt; configuration variable. The command line option takes precedence over the configuration variable. If neither is given, a &lt;code&gt;checkout&lt;/code&gt; is performed. The &lt;code&gt;update&lt;/code&gt; procedures supported both from the command line as well as through the &lt;code&gt;submodule.&amp;lt;name&amp;gt;.update&lt;/code&gt; configuration are:</source>
          <target state="translated">登録されているサブモジュールを更新して、欠落しているサブモジュールを複製し、欠落しているコミットをサブモジュールにフェッチし、サブモジュールの作業ツリーを更新することにより、スーパープロジェクトが期待するものと一致させます。 「更新」は、コマンドラインオプションと &lt;code&gt;submodule.&amp;lt;name&amp;gt;.update&lt;/code&gt; 構成変数の値に応じて、いくつかの方法で実行できます。コマンドラインオプションは、構成変数よりも優先されます。どちらも指定されていない場合、 &lt;code&gt;checkout&lt;/code&gt; が実行されます。 &lt;code&gt;update&lt;/code&gt; 手順は、コマンドラインから、ならびにを通して両方をサポート &lt;code&gt;submodule.&amp;lt;name&amp;gt;.update&lt;/code&gt; 構成は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="9a189cb9ecf6f808972788504f5218556d75488e" translate="yes" xml:space="preserve">
          <source>Update the remote-tracking branches for the repository you cloned from, then merge one of them into your current branch:</source>
          <target state="translated">クローンしたリポジトリのリモートトラッキングブランチを更新し、そのうちの一つを現在のブランチにマージします。</target>
        </trans-unit>
        <trans-unit id="b4a6a66956cae4a12a849cae6094fa1d9187d293" translate="yes" xml:space="preserve">
          <source>Update the remote-tracking branches:</source>
          <target state="translated">リモートトラッキングブランチを更新します。</target>
        </trans-unit>
        <trans-unit id="6d5daf3e771e4022d14d6727e49c69b93e7e63af" translate="yes" xml:space="preserve">
          <source>Update the sparse-checkout file to include additional patterns. By default, these patterns are read from the command-line arguments, but they can be read from stdin using the &lt;code&gt;--stdin&lt;/code&gt; option. When &lt;code&gt;core.sparseCheckoutCone&lt;/code&gt; is enabled, the given patterns are interpreted as directory names as in the &lt;code&gt;set&lt;/code&gt; subcommand.</source>
          <target state="translated">スパースチェックアウトファイルを更新して、追加のパターンを含めます。デフォルトでは、これらのパターンはコマンドライン引数から読み取られますが、 &lt;code&gt;--stdin&lt;/code&gt; オプションを使用してstdinから読み取ることができます。とき &lt;code&gt;core.sparseCheckoutCone&lt;/code&gt; が有効になっている、与えられたパターンは、のようにディレクトリ名として解釈され &lt;code&gt;set&lt;/code&gt; サブコマンド。</target>
        </trans-unit>
        <trans-unit id="f68dff1cbdca38d9a97763a1d9fd849e951b6a1b" translate="yes" xml:space="preserve">
          <source>Updates files in the working tree to match the version in the index or the specified tree. If no pathspec was given, &lt;code&gt;git checkout&lt;/code&gt; will also update &lt;code&gt;HEAD&lt;/code&gt; to set the specified branch as the current branch.</source>
          <target state="translated">作業ツリーのファイルを更新して、インデックスまたは指定されたツリーのバージョンと一致させます。pathspecが指定されていない場合、 &lt;code&gt;git checkout&lt;/code&gt; は &lt;code&gt;HEAD&lt;/code&gt; も更新して、指定されたブランチを現在のブランチとして設定します。</target>
        </trans-unit>
        <trans-unit id="091bf3e8c6fb28b8688a9117ac018615896df561" translate="yes" xml:space="preserve">
          <source>Updates remote refs using local refs, while sending objects necessary to complete the given refs.</source>
          <target state="translated">与えられた参照を完了させるために必要なオブジェクトを送信しながら、ローカル参照を使用してリモート参照を更新します。</target>
        </trans-unit>
        <trans-unit id="91ca9b60db53a2ebedea4c579e08371ec4025869" translate="yes" xml:space="preserve">
          <source>Updating A with the resulting merge commit will fast-forward and your push will be accepted.</source>
          <target state="translated">マージコミットの結果に応じて A を更新すると、早送りされ、あなたのプッシュが受け入れられます。</target>
        </trans-unit>
        <trans-unit id="b1b31935884de26d68d690781ac1ec814b3bc924" translate="yes" xml:space="preserve">
          <source>Updating a repository with git fetch</source>
          <target state="translated">git fetch でリポジトリを更新する</target>
        </trans-unit>
        <trans-unit id="c2ed1ab77aee7c3aaed70bc448641d662955a12f" translate="yes" xml:space="preserve">
          <source>Updating existing tests that assume GIT_TRACE format messages.</source>
          <target state="translated">GIT_TRACE 形式のメッセージを前提とした既存のテストを更新しました。</target>
        </trans-unit>
        <trans-unit id="c5ded60beb1b0eb17cab63a8e09a8acd2261286e" translate="yes" xml:space="preserve">
          <source>Updating the index did something else too: it created a &lt;code&gt;.git/index&lt;/code&gt; file. This is the index that describes your current working tree, and something you should be very aware of. Again, you normally never worry about the index file itself, but you should be aware of the fact that you have not actually really &quot;checked in&quot; your files into Git so far, you&amp;rsquo;ve only &lt;strong&gt;told&lt;/strong&gt; Git about them.</source>
          <target state="translated">インデックスを更新すると、別のことも行われました。これにより、 &lt;code&gt;.git/index&lt;/code&gt; ファイルが作成されました。これは、現在の作業ツリーを説明するインデックスであり、非常に注意する必要があります。ここでも、あなたは通常、インデックスファイル自体心配はありませんが、あなたは、あなたがいない実際には本当にGitリポジトリへのあなたのファイルはこれまでのところ、あなただけしました「で確認」しているという事実を認識しておく必要があり&lt;strong&gt;語っ&lt;/strong&gt;それらについてのGitを。</target>
        </trans-unit>
        <trans-unit id="583381e5edf6e3ab467919c38286667f0916979d" translate="yes" xml:space="preserve">
          <source>Upon completion, &amp;lt;branch&amp;gt; will be the current branch.</source>
          <target state="translated">完了すると、&amp;lt;branch&amp;gt;が現在のブランチになります。</target>
        </trans-unit>
        <trans-unit id="c956664b8da61af6d0e1bf33a6e1ff75cbe45ad1" translate="yes" xml:space="preserve">
          <source>Upon seeing an invalid object name in the input, pretend as if the bad input was not given.</source>
          <target state="translated">入力に無効なオブジェクト名があった場合は、不正な入力がなかったことにしてください。</target>
        </trans-unit>
        <trans-unit id="d725441fc805b8226e9417fb2c8cf53ac8d791d5" translate="yes" xml:space="preserve">
          <source>Upstream branch to compare against. May be any valid commit, not just an existing branch name. Defaults to the configured upstream for the current branch.</source>
          <target state="translated">比較対象となるアップストリームブランチ。既存のブランチ名だけでなく、有効なコミットであっても構いません。デフォルトは、現在のブランチのアップストリームで設定されているものです。</target>
        </trans-unit>
        <trans-unit id="f5808323e4ba717fc383cb75e63b6cf3a4e857e7" translate="yes" xml:space="preserve">
          <source>Upstream branch to search for equivalent commits. Defaults to the upstream branch of HEAD.</source>
          <target state="translated">同等のコミットを検索するアップストリームブランチ。デフォルトは HEAD のアップストリームブランチです。</target>
        </trans-unit>
        <trans-unit id="309bc26d3c4c2649258f95c7069216bb2a7ac5f4" translate="yes" xml:space="preserve">
          <source>Upstream location from which commits are identified to submit to p4. By default, this is the most recent p4 commit reachable from &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">p4に送信するコミットが識別される上流の場所。デフォルトでは、これは &lt;code&gt;HEAD&lt;/code&gt; から到達可能な最新のp4コミットです。</target>
        </trans-unit>
        <trans-unit id="df28f1403e8348eae4829434034d1a95e5fe659d" translate="yes" xml:space="preserve">
          <source>Url translation</source>
          <target state="translated">Url翻訳</target>
        </trans-unit>
        <trans-unit id="7ae770d8c2db91584c78e413662ced65719f53ca" translate="yes" xml:space="preserve">
          <source>Usage of this flag will probably be rare, since you can get rid of commits that start empty by just firing up an interactive rebase and removing the lines corresponding to the commits you don&amp;rsquo;t want. This flag exists as a convenient shortcut, such as for cases where external tools generate many empty commits and you want them all removed.</source>
          <target state="translated">インタラクティブなリベースを起動し、不要なコミットに対応する行を削除するだけで、空で始まるコミットを取り除くことができるため、このフラグの使用はおそらくまれです。このフラグは、外部ツールが多数の空のコミットを生成し、それらをすべて削除する場合など、便利なショートカットとして存在します。</target>
        </trans-unit>
        <trans-unit id="f51159e5f3b0adbeed98e188d040286280a5320b" translate="yes" xml:space="preserve">
          <source>Usage text</source>
          <target state="translated">使用テキスト</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="6039144c2dc6586b6f3f0cb7423bcc0b3de0d0c1" translate="yes" xml:space="preserve">
          <source>Use &quot;patience diff&quot; algorithm when generating patches.</source>
          <target state="translated">パッチを生成する際には、&quot;patient diff&quot; アルゴリズムを使用してください。</target>
        </trans-unit>
        <trans-unit id="1712fa1f1e6f89a27b7d3117ed39073a3258971d" translate="yes" xml:space="preserve">
          <source>Use &amp;lt;dir&amp;gt; to store the resulting files, instead of the current working directory.</source>
          <target state="translated">現在の作業ディレクトリではなく、&amp;lt;dir&amp;gt;を使用して、結果のファイルを保存します。</target>
        </trans-unit>
        <trans-unit id="89ed1ad2d65d4e1af42e685a9ee22c739e5d2c9b" translate="yes" xml:space="preserve">
          <source>Use &amp;lt;message&amp;gt; instead of the branch names for the first line of the log message. For use with &lt;code&gt;--log&lt;/code&gt;.</source>
          <target state="translated">ログメッセージの最初の行のブランチ名の代わりに&amp;lt;message&amp;gt;を使用します。 &lt;code&gt;--log&lt;/code&gt; とともに使用します。</target>
        </trans-unit>
        <trans-unit id="a8e6c324c4e7440184ef28eb2f6fc1fca5a4a325" translate="yes" xml:space="preserve">
          <source>Use &amp;lt;regex&amp;gt; to decide what a word is, instead of considering runs of non-whitespace to be a word. Also implies &lt;code&gt;--word-diff&lt;/code&gt; unless it was already enabled.</source>
          <target state="translated">空白ではない文字列を単語と見なす代わりに、&amp;lt;regex&amp;gt;を使用して単語を決定します。また、すでに有効になっていない限り、 &lt;code&gt;--word-diff&lt;/code&gt; を意味します。</target>
        </trans-unit>
        <trans-unit id="f70b8a97f949594b729b07efce2ca59a63023925" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;!&lt;/code&gt; to not make the corresponding negated long option available.</source>
          <target state="translated">使用してください &lt;code&gt;!&lt;/code&gt; 対応するnegated longオプションを使用可能にしない。</target>
        </trans-unit>
        <trans-unit id="f7924a219e6794d45a36b15b2c44738227b795ff" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; to set the symbolic-ref &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; explicitly. e.g., &quot;git remote set-head origin master&quot; will set the symbolic-ref &lt;code&gt;refs/remotes/origin/HEAD&lt;/code&gt; to &lt;code&gt;refs/remotes/origin/master&lt;/code&gt;. This will only work if &lt;code&gt;refs/remotes/origin/master&lt;/code&gt; already exists; if not it must be fetched first.</source>
          <target state="translated">&lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; を使用して、symbolic-ref &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; を明示的に設定します。たとえば、「git remote set-head origin master」は、symbolic-ref &lt;code&gt;refs/remotes/origin/HEAD&lt;/code&gt; を &lt;code&gt;refs/remotes/origin/master&lt;/code&gt; に設定します。これは、 &lt;code&gt;refs/remotes/origin/master&lt;/code&gt; がすでに存在する場合にのみ機能します。そうでない場合は、最初にフェッチする必要があります。</target>
        </trans-unit>
        <trans-unit id="e726751622c7eadb004a31b60b5fa1e9cc1fbf90" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; to set the symbolic-ref &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; explicitly. e.g., &lt;code&gt;git
remote set-head origin master&lt;/code&gt; will set the symbolic-ref &lt;code&gt;refs/remotes/origin/HEAD&lt;/code&gt; to &lt;code&gt;refs/remotes/origin/master&lt;/code&gt;. This will only work if &lt;code&gt;refs/remotes/origin/master&lt;/code&gt; already exists; if not it must be fetched first.</source>
          <target state="translated">&lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; を使用して、symbolic-ref &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; を明示的に設定します。たとえば、 &lt;code&gt;git remote set-head origin master&lt;/code&gt; は、symbolic-ref &lt;code&gt;refs/remotes/origin/HEAD&lt;/code&gt; を &lt;code&gt;refs/remotes/origin/master&lt;/code&gt; に設定します。これは、 &lt;code&gt;refs/remotes/origin/master&lt;/code&gt; がすでに存在する場合にのみ機能します。そうでない場合は、最初にフェッチする必要があります。</target>
        </trans-unit>
        <trans-unit id="d950943422ee3b93275d1e4b1e510463e5b432e0" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; to contact a running cache daemon (or start a new cache daemon if one is not started). Defaults to &lt;code&gt;$XDG_CACHE_HOME/git/credential/socket&lt;/code&gt; unless &lt;code&gt;~/.git-credential-cache/&lt;/code&gt; exists in which case &lt;code&gt;~/.git-credential-cache/socket&lt;/code&gt; is used instead. If your home directory is on a network-mounted filesystem, you may need to change this to a local filesystem. You must specify an absolute path.</source>
          <target state="translated">&lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 使用を、実行中のキャッシュデーモンに接続します（または、キャッシュデーモンが起動されていない場合は、新しいキャッシュデーモンを起動します）。 &lt;code&gt;~/.git-credential-cache/&lt;/code&gt; が存在しない限り、デフォルトは &lt;code&gt;$XDG_CACHE_HOME/git/credential/socket&lt;/code&gt; です。この場合、代わりに &lt;code&gt;~/.git-credential-cache/socket&lt;/code&gt; が使用されます。ホームディレクトリがネットワークマウントされたファイルシステム上にある場合、これをローカルファイルシステムに変更する必要があるかもしれません。絶対パスを指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="faabe60607ec900b5e4ad4f074b4870d8f9c10c6" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; to lookup and store credentials. The file will have its filesystem permissions set to prevent other users on the system from reading it, but will not be encrypted or otherwise protected. If not specified, credentials will be searched for from &lt;code&gt;~/.git-credentials&lt;/code&gt; and &lt;code&gt;$XDG_CONFIG_HOME/git/credentials&lt;/code&gt;, and credentials will be written to &lt;code&gt;~/.git-credentials&lt;/code&gt; if it exists, or &lt;code&gt;$XDG_CONFIG_HOME/git/credentials&lt;/code&gt; if it exists and the former does not. See also &lt;a href=&quot;#FILES&quot;&gt;FILES&lt;/a&gt;.</source>
          <target state="translated">資格情報を検索して保存するには、 &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; を使用します。ファイルには、システム上の他のユーザーがファイルを読み取れないようにファイルシステムのアクセス許可が設定されますが、暗号化または保護されません。指定しない場合、資格情報はから検索されます &lt;code&gt;~/.git-credentials&lt;/code&gt; および &lt;code&gt;$XDG_CONFIG_HOME/git/credentials&lt;/code&gt; 、および資格情報に書き込まれます &lt;code&gt;~/.git-credentials&lt;/code&gt; が存在する場合、または &lt;code&gt;$XDG_CONFIG_HOME/git/credentials&lt;/code&gt; が存在する場合前者はしません。&lt;a href=&quot;#FILES&quot;&gt;FILES&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="aadb92eae500ef695bbe6a445720ce25246dd04e" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;*&lt;/code&gt; to mean that this option should not be listed in the usage generated for the &lt;code&gt;-h&lt;/code&gt; argument. It&amp;rsquo;s shown for &lt;code&gt;--help-all&lt;/code&gt; as documented in &lt;a href=&quot;gitcli&quot;&gt;gitcli[7]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; を使用すると、このオプションは &lt;code&gt;-h&lt;/code&gt; 引数に対して生成される使用法にリストされません。&lt;a href=&quot;gitcli&quot;&gt;gitcli [7]に&lt;/a&gt;記載されているように、-- &lt;code&gt;--help-all&lt;/code&gt; に対して表示されます。</target>
        </trans-unit>
        <trans-unit id="3bbcee2a044e9c08185b38acb1e1c57ceea88054" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;--no-guess&lt;/code&gt; to disable this.</source>
          <target state="translated">使用 &lt;code&gt;--no-guess&lt;/code&gt; 、これを無効にします。</target>
        </trans-unit>
        <trans-unit id="6deefc2a8fa6667ca14a90dee15faf81b1f0546a" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;-o master&lt;/code&gt; for continuing an import that was initially done by the old cvs2git tool.</source>
          <target state="translated">古いcvs2gitツールによって最初に行われたインポートを続行するには、 &lt;code&gt;-o master&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="a4527eec708654a210ce88433047c8e573fb91f2" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;-r&lt;/code&gt; together with &lt;code&gt;-d&lt;/code&gt; to delete remote-tracking branches. Note, that it only makes sense to delete remote-tracking branches if they no longer exist in the remote repository or if &lt;code&gt;git fetch&lt;/code&gt; was configured not to fetch them again. See also the &lt;code&gt;prune&lt;/code&gt; subcommand of &lt;a href=&quot;git-remote&quot;&gt;git-remote[1]&lt;/a&gt; for a way to clean up all obsolete remote-tracking branches.</source>
          <target state="translated">&lt;code&gt;-r&lt;/code&gt; を &lt;code&gt;-d&lt;/code&gt; と一緒に使用して、リモート追跡ブランチを削除します。リモート追跡ブランチがリモートリポジトリに存在しない場合、または &lt;code&gt;git fetch&lt;/code&gt; がそれらを再度フェッチしないように構成されている場合にのみ、リモート追跡ブランチを削除しても意味があることに注意してください。廃止されたすべてのリモート追跡ブランチをクリーンアップする方法については、&lt;a href=&quot;git-remote&quot;&gt;git-remote [1]&lt;/a&gt;の &lt;code&gt;prune&lt;/code&gt; サブコマンドも参照してください。</target>
        </trans-unit>
        <trans-unit id="eb7d25cab29167524de808a8da669505756898ee" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;=&lt;/code&gt; if the option takes an argument.</source>
          <target state="translated">オプションが引数を取る場合は &lt;code&gt;=&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="d247642d4c8609f74c2030daa3d24c7c82d2e46d" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;?&lt;/code&gt; to mean that the option takes an optional argument. You probably want to use the &lt;code&gt;--stuck-long&lt;/code&gt; mode to be able to unambiguously parse the optional argument.</source>
          <target state="translated">使用し &lt;code&gt;?&lt;/code&gt; オプションがオプションの引数を取ることを意味します。おそらく &lt;code&gt;--stuck-long&lt;/code&gt; モードを使用して、オプションの引数を明確に解析できるようにする必要があります。</target>
        </trans-unit>
        <trans-unit id="7929eb6fd77d1ea35c9c481fc89518eafcc1cd45" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git bisect&lt;/code&gt; to get a short usage description, and &lt;code&gt;git bisect
help&lt;/code&gt; or &lt;code&gt;git bisect -h&lt;/code&gt; to get a long usage description.</source>
          <target state="translated">&lt;code&gt;git bisect&lt;/code&gt; を使用して短い使用法の説明を取得し、 &lt;code&gt;git bisect help&lt;/code&gt; または &lt;code&gt;git bisect -h&lt;/code&gt; を使用して長い使用法の説明を取得します。</target>
        </trans-unit>
        <trans-unit id="599c65a25784af23c9351ba6f4874c534a65a263" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git cherry origin&lt;/code&gt; to see which ones of your patches were accepted, and/or use &lt;code&gt;git rebase origin&lt;/code&gt; to port your unmerged changes forward to the updated upstream.</source>
          <target state="translated">&lt;code&gt;git cherry origin&lt;/code&gt; を使用して、受け入れられたパッチを確認するか、 &lt;code&gt;git rebase origin&lt;/code&gt; を使用して、マージされていない変更を更新されたアップストリームに移植します。</target>
        </trans-unit>
        <trans-unit id="f1986201248cbf297f2fb86d6f520b30d057ce7d" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git fetch &amp;lt;remote&amp;gt;&lt;/code&gt; or &lt;code&gt;git remote update&lt;/code&gt; to stay up to date.</source>
          <target state="translated">使用して、 &lt;code&gt;git fetch &amp;lt;remote&amp;gt;&lt;/code&gt; または &lt;code&gt;git remote update&lt;/code&gt; 最新の状態に滞在します。</target>
        </trans-unit>
        <trans-unit id="252ef42d37b56d31d5e5dc2525ae974052dfca91" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git format-patch origin&lt;/code&gt; to prepare patches for e-mail submission to your upstream and send it out. Go back to step 2. and continue.</source>
          <target state="translated">&lt;code&gt;git format-patch origin&lt;/code&gt; を使用して、アップストリームへの電子メール送信用のパッチを準備して送信します。手順2に戻り、続行します。</target>
        </trans-unit>
        <trans-unit id="cd30f3ed950161de3f8267d9a18953af3c02784f" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git mergetool&lt;/code&gt; to run one of several merge utilities to resolve merge conflicts. It is typically run after &lt;code&gt;git merge&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git mergetool&lt;/code&gt; を使用して、いくつかのマージユーティリティの1つを実行し、マージの競合を解決します。通常は &lt;code&gt;git merge&lt;/code&gt; の後に実行されます。</target>
        </trans-unit>
        <trans-unit id="6b298c06fc405635f29d06efdf0f42592d8075f2" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git rev-parse&lt;/code&gt; in option parsing mode (see PARSEOPT section below).</source>
          <target state="translated">オプション解析モードで &lt;code&gt;git rev-parse&lt;/code&gt; を使用します（下記のPARSEOPTセクションを参照）。</target>
        </trans-unit>
        <trans-unit id="7c9820d48befbd19730095f238fb8a15824823ad" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git rev-parse&lt;/code&gt; in shell quoting mode (see SQ-QUOTE section below). In contrast to the &lt;code&gt;--sq&lt;/code&gt; option below, this mode does only quoting. Nothing else is done to command input.</source>
          <target state="translated">シェルの引用モードで &lt;code&gt;git rev-parse&lt;/code&gt; を使用します（以下のSQ-QUOTEセクションを参照）。以下の &lt;code&gt;--sq&lt;/code&gt; オプションとは対照的に、このモードは引用のみを行います。コマンド入力に対して他に何も行われません。</target>
        </trans-unit>
        <trans-unit id="4c4d44083fa5e2a6971987cf935297be30994f4c" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git stash&lt;/code&gt; when you want to record the current state of the working directory and the index, but want to go back to a clean working directory. The command saves your local modifications away and reverts the working directory to match the &lt;code&gt;HEAD&lt;/code&gt; commit.</source>
          <target state="translated">作業ディレクトリとインデックスの現在の状態を記録したいが、クリーンな作業ディレクトリに戻りたい場合は、 &lt;code&gt;git stash&lt;/code&gt; を使用してください。このコマンドは、ローカルの変更を保存し、 &lt;code&gt;HEAD&lt;/code&gt; コミットに一致するように作業ディレクトリを元に戻します。</target>
        </trans-unit>
        <trans-unit id="41c11f9d8154a7d9c49ff48bc15e09cdeb4a9a5c" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git stripspace --strip-comments&lt;/code&gt; to obtain:</source>
          <target state="translated">取得するには、 &lt;code&gt;git stripspace --strip-comments&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="141b00818c5025cc15ff515d81283fc5705a8a4e" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git stripspace&lt;/code&gt; with no arguments to obtain:</source>
          <target state="translated">引数なしで &lt;code&gt;git stripspace&lt;/code&gt; を使用して取得します。</target>
        </trans-unit>
        <trans-unit id="ae0479a18945009a7ebac30bdfceaa72c61a99c4" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;ident&lt;/code&gt; in the &lt;code&gt;From:&lt;/code&gt; header of each commit email. If the author ident of the commit is not textually identical to the provided &lt;code&gt;ident&lt;/code&gt;, place a &lt;code&gt;From:&lt;/code&gt; header in the body of the message with the original author. If no &lt;code&gt;ident&lt;/code&gt; is given, use the committer ident.</source>
          <target state="translated">各コミットメールの &lt;code&gt;From:&lt;/code&gt; ヘッダーで &lt;code&gt;ident&lt;/code&gt; を使用します。コミットの著者IDENTはテキストで提供さと同一でない場合 &lt;code&gt;ident&lt;/code&gt; 、場所A &lt;code&gt;From:&lt;/code&gt; 原作者のメッセージの本体内のヘッダ。 &lt;code&gt;ident&lt;/code&gt; が指定されていない場合は、コミッターIDを使用します。</target>
        </trans-unit>
        <trans-unit id="8fb68f530aa46816206d7ea34908da4d297edef3" translate="yes" xml:space="preserve">
          <source>Use IPv4 addresses only, ignoring IPv6 addresses.</source>
          <target state="translated">IPv6アドレスは無視して、IPv4アドレスのみを使用してください。</target>
        </trans-unit>
        <trans-unit id="d89ac89f76f16a68a863b0d9f578ffd1a558d6b0" translate="yes" xml:space="preserve">
          <source>Use IPv6 addresses only, ignoring IPv4 addresses.</source>
          <target state="translated">IPv4アドレスは無視して、IPv6アドレスのみを使用してください。</target>
        </trans-unit>
        <trans-unit id="23206ddfb8d01b68973d7bd9cccf799f208e3657" translate="yes" xml:space="preserve">
          <source>Use Message &amp;rarr; Insert file&amp;hellip;​ and insert the patch.</source>
          <target state="translated">メッセージ&amp;rarr;ファイルの挿入&amp;hellip;を使用して、パッチを挿入します。</target>
        </trans-unit>
        <trans-unit id="1b7e380bb9ef947a64359e01f17ce54cd3bdece1" translate="yes" xml:space="preserve">
          <source>Use One Mark Per Commit</source>
          <target state="translated">コミットごとに1つのマークを使用する</target>
        </trans-unit>
        <trans-unit id="c24268aab2b43d4e294643c8fbcbd60d377e139b" translate="yes" xml:space="preserve">
          <source>Use POSIX extended/basic regexp for patterns. Default is to use basic regexp.</source>
          <target state="translated">パターンに POSIX 拡張/基本正規表現を使用します。デフォルトは基本正規表現を使用します。</target>
        </trans-unit>
        <trans-unit id="36e96e4a2fd002679f3b794b4968539810c5c2eb" translate="yes" xml:space="preserve">
          <source>Use Perl-compatible regular expressions for patterns.</source>
          <target state="translated">パターンにはPerl互換の正規表現を使用します。</target>
        </trans-unit>
        <trans-unit id="fd46ce4ee0de88bb1a4ebb0e0c6375d24c2fb065" translate="yes" xml:space="preserve">
          <source>Use SO_REUSEADDR when binding the listening socket. This allows the server to restart without waiting for old connections to time out.</source>
          <target state="translated">リスニングソケットをバインドする際にSO_REUSEADDRを使用します。これにより、古い接続がタイムアウトするのを待たずにサーバを再起動することができます。</target>
        </trans-unit>
        <trans-unit id="f351ffbdfc957393f82f6653e37778e19987b350" translate="yes" xml:space="preserve">
          <source>Use Tag Fixup Branches</source>
          <target state="translated">タグの修正ブランチを使用する</target>
        </trans-unit>
        <trans-unit id="41019858ddf6bd113a2b54361af9c75b6d741367" translate="yes" xml:space="preserve">
          <source>Use \0 as the delimiter for pathnames in the output, and print them verbatim. Without this option, pathnames with &quot;unusual&quot; characters are quoted as explained for the configuration variable core.quotePath (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">出力のパス名の区切り文字として\ 0を使用し、逐語的に出力します。このオプションがないと、構成変数core.quotePathで説明されているように「異常な」文字を含むパス名が引用符で囲まれます（&lt;a href=&quot;git-config&quot;&gt;git-config [1]を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="67640e675158aa473b8a69cc0cdb46fb8ed7283f" translate="yes" xml:space="preserve">
          <source>Use a &quot;stable&quot; sum of hashes as the patch ID. With this option:</source>
          <target state="translated">パッチ ID として「安定した」ハッシュの合計を使用します。このオプションを使うと</target>
        </trans-unit>
        <trans-unit id="0ec5feaf620cc0230519584645c952a1ae99d83c" translate="yes" xml:space="preserve">
          <source>Use a client spec to find the list of interesting files in p4. See the &quot;CLIENT SPEC&quot; section below.</source>
          <target state="translated">クライアントスペックを使って、p4の中の興味深いファイルのリストを探します。後述の「クライアントスペック」を参照してください。</target>
        </trans-unit>
        <trans-unit id="cf410607b4d646fae6b37dffcb3f37fcc481f52b" translate="yes" xml:space="preserve">
          <source>Use a mergetool. &lt;code&gt;git mergetool&lt;/code&gt; to launch a graphical mergetool which will work you through the merge.</source>
          <target state="translated">mergetoolを使用します。 &lt;code&gt;git mergetool&lt;/code&gt; を使用して、マージを実行するグ​​ラフィカルなマージツールを起動します。</target>
        </trans-unit>
        <trans-unit id="e7589df3d820308df2c8a838829de10cfbcf2077" translate="yes" xml:space="preserve">
          <source>Use a special line-based format intended for script consumption. Added/removed/unchanged runs are printed in the usual unified diff format, starting with a &lt;code&gt;+&lt;/code&gt;/&lt;code&gt;-&lt;/code&gt;/` ` character at the beginning of the line and extending to the end of the line. Newlines in the input are represented by a tilde &lt;code&gt;~&lt;/code&gt; on a line of its own.</source>
          <target state="translated">スクリプトの使用を目的とした特別な行ベースの形式を使用します。追加/削除/変更されていないランは、通常の統一されたdiff形式で印刷されます。行の先頭の &lt;code&gt;+&lt;/code&gt; / &lt;code&gt;-&lt;/code&gt; / ``文字で始まり、行の終わりまで続きます。入力の改行は、それ自体の行のチルダ &lt;code&gt;~&lt;/code&gt; で表されます。</target>
        </trans-unit>
        <trans-unit id="77b024aefcbc37a1627539595d18a928f0842816" translate="yes" xml:space="preserve">
          <source>Use a tarball as a starting point for a new repository.</source>
          <target state="translated">新しいリポジトリの出発点として tarball を使用します。</target>
        </trans-unit>
        <trans-unit id="afac3b09febbe243aa11caf12f594c7284e7bf23" translate="yes" xml:space="preserve">
          <source>Use an &quot;unstable&quot; hash as the patch ID. With this option, the result produced is compatible with the patch-id value produced by git 1.9 and older. Users with pre-existing databases storing patch-ids produced by git 1.9 and older (who do not deal with reordered patches) may want to use this option.</source>
          <target state="translated">パッチ ID として &quot;unstable&quot; ハッシュを使用します。このオプションを指定すると、生成される結果は git 1.9 以降で生成された patch-id と互換性があります。git 1.9 以降で作成されたパッチ ID を保存しているデータベースがすでにある場合 (再注文されたパッチを扱わない場合)は、このオプションを使用したほうがよいでしょう。</target>
        </trans-unit>
        <trans-unit id="ef4088fc09156b38070cb26da8281dc7bfd8c504" translate="yes" xml:space="preserve">
          <source>Use an atomic transaction for updating the refs. If any of the refs fails to update then the entire push will fail without changing any refs.</source>
          <target state="translated">参照の更新にはアトミックトランザクションを使用します。いずれかの refs が更新に失敗した場合は、refs を変更せずにプッシュ全体が失敗します。</target>
        </trans-unit>
        <trans-unit id="049c3e05f1b188c69413c7549059c67376f76ed1" translate="yes" xml:space="preserve">
          <source>Use an atomic transaction on the remote side if available. Either all refs are updated, or on error, no refs are updated. If the server does not support atomic pushes the push will fail.</source>
          <target state="translated">利用可能であれば、リモート側でアトミックトランザクションを使用します。すべての参照が更新されるか、エラーの場合は参照が更新されません。サーバがアトミックプッシュをサポートしていない場合、プッシュは失敗します。</target>
        </trans-unit>
        <trans-unit id="402b0ecf5212c8d413a7923b4b251cf4b803a260" translate="yes" xml:space="preserve">
          <source>Use applying strategies to rebase (calling &lt;code&gt;git-am&lt;/code&gt; internally). This option may become a no-op in the future once the merge backend handles everything the apply one does.</source>
          <target state="translated">適用戦略を使用してリベースします（内部で &lt;code&gt;git-am&lt;/code&gt; を呼び出します）。マージバックエンドが適用のすべてを処理すると、このオプションは将来的にノーオペレーションになる可能性があります。</target>
        </trans-unit>
        <trans-unit id="e55fb404106de44576d9bc731a7fb4baf9a6337c" translate="yes" xml:space="preserve">
          <source>Use binary search to find the commit that introduced a bug</source>
          <target state="translated">バイナリ検索を使ってバグが発生したコミットを見つける</target>
        </trans-unit>
        <trans-unit id="78ee9b127501691d305b39cc3fc13fc74a1d22a1" translate="yes" xml:space="preserve">
          <source>Use customized color for &lt;code&gt;git add --interactive&lt;/code&gt; and &lt;code&gt;git clean --interactive&lt;/code&gt; output. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; may be &lt;code&gt;prompt&lt;/code&gt;, &lt;code&gt;header&lt;/code&gt;, &lt;code&gt;help&lt;/code&gt; or &lt;code&gt;error&lt;/code&gt;, for four distinct types of normal output from interactive commands.</source>
          <target state="translated">&lt;code&gt;git add --interactive&lt;/code&gt; および &lt;code&gt;git clean --interactive&lt;/code&gt; 出力にカスタマイズされた色を使用します。 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; は、対話型コマンドからの4つの異なるタイプの通常の出力に対して、 &lt;code&gt;prompt&lt;/code&gt; 、 &lt;code&gt;header&lt;/code&gt; 、 &lt;code&gt;help&lt;/code&gt; または &lt;code&gt;error&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="bf3aeb7f00c3d69ade01b5cc321078d4f50948ae" translate="yes" xml:space="preserve">
          <source>Use customized color for &lt;code&gt;git log --decorate&lt;/code&gt; output. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; is one of &lt;code&gt;branch&lt;/code&gt;, &lt;code&gt;remoteBranch&lt;/code&gt;, &lt;code&gt;tag&lt;/code&gt;, &lt;code&gt;stash&lt;/code&gt; or &lt;code&gt;HEAD&lt;/code&gt; for local branches, remote-tracking branches, tags, stash and HEAD, respectively and &lt;code&gt;grafted&lt;/code&gt; for grafted commits.</source>
          <target state="translated">&lt;code&gt;git log --decorate&lt;/code&gt; 出力にカスタマイズされた色を使用します。 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; の一つである &lt;code&gt;branch&lt;/code&gt; 、 &lt;code&gt;remoteBranch&lt;/code&gt; 、 &lt;code&gt;tag&lt;/code&gt; 、 &lt;code&gt;stash&lt;/code&gt; 又は &lt;code&gt;HEAD&lt;/code&gt; それぞれ、ローカルブランチのリモート追跡ブランチ、タグ、スタッシュとHEADと &lt;code&gt;grafted&lt;/code&gt; グラフトコミットするため。</target>
        </trans-unit>
        <trans-unit id="29ecef38edab0e1998d46583be9558cf2a562eff" translate="yes" xml:space="preserve">
          <source>Use customized color for branch coloration. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; is one of &lt;code&gt;current&lt;/code&gt; (the current branch), &lt;code&gt;local&lt;/code&gt; (a local branch), &lt;code&gt;remote&lt;/code&gt; (a remote-tracking branch in refs/remotes/), &lt;code&gt;upstream&lt;/code&gt; (upstream tracking branch), &lt;code&gt;plain&lt;/code&gt; (other refs).</source>
          <target state="translated">ブランチの配色にはカスタマイズした色を使用します。 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; は、 &lt;code&gt;current&lt;/code&gt; （現在のブランチ）、 &lt;code&gt;local&lt;/code&gt; （ローカルブランチ）、 &lt;code&gt;remote&lt;/code&gt; （refs / remotes /のリモート追跡ブランチ）、 &lt;code&gt;upstream&lt;/code&gt; （上流の追跡ブランチ）、 &lt;code&gt;plain&lt;/code&gt; （その他の参照）のいずれかです。</target>
        </trans-unit>
        <trans-unit id="fcdeebdb47ef8466da45d806c0dccf091f4447a0" translate="yes" xml:space="preserve">
          <source>Use customized color for diff colorization. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; specifies which part of the patch to use the specified color, and is one of &lt;code&gt;context&lt;/code&gt; (context text - &lt;code&gt;plain&lt;/code&gt; is a historical synonym), &lt;code&gt;meta&lt;/code&gt; (metainformation), &lt;code&gt;frag&lt;/code&gt; (hunk header), &lt;code&gt;func&lt;/code&gt; (function in hunk header), &lt;code&gt;old&lt;/code&gt; (removed lines), &lt;code&gt;new&lt;/code&gt; (added lines), &lt;code&gt;commit&lt;/code&gt; (commit headers), &lt;code&gt;whitespace&lt;/code&gt; (highlighting whitespace errors), &lt;code&gt;oldMoved&lt;/code&gt; (deleted lines), &lt;code&gt;newMoved&lt;/code&gt; (added lines), &lt;code&gt;oldMovedDimmed&lt;/code&gt;, &lt;code&gt;oldMovedAlternative&lt;/code&gt;, &lt;code&gt;oldMovedAlternativeDimmed&lt;/code&gt;, &lt;code&gt;newMovedDimmed&lt;/code&gt;, &lt;code&gt;newMovedAlternative&lt;/code&gt;&lt;code&gt;newMovedAlternativeDimmed&lt;/code&gt; (See the &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; setting of &lt;code&gt;--color-moved&lt;/code&gt; in &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; for details), &lt;code&gt;contextDimmed&lt;/code&gt;, &lt;code&gt;oldDimmed&lt;/code&gt;, &lt;code&gt;newDimmed&lt;/code&gt;, &lt;code&gt;contextBold&lt;/code&gt;, &lt;code&gt;oldBold&lt;/code&gt;, and &lt;code&gt;newBold&lt;/code&gt; (see &lt;a href=&quot;git-range-diff&quot;&gt;git-range-diff[1]&lt;/a&gt; for details).</source>
          <target state="translated">カスタマイズされた色を使用して、差分色付け &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; は、指定した色を使用するパッチの部分を指定し、 &lt;code&gt;context&lt;/code&gt; （コンテキストテキスト- &lt;code&gt;plain&lt;/code&gt; は履歴の同義語です）、 &lt;code&gt;meta&lt;/code&gt; （メタ情報）、 &lt;code&gt;frag&lt;/code&gt; （ハンクヘッダー）、 &lt;code&gt;func&lt;/code&gt; （ハンクヘッダー内の関数）、 &lt;code&gt;old&lt;/code&gt; （削除された行）、 &lt;code&gt;new&lt;/code&gt; （追加された行）、 &lt;code&gt;commit&lt;/code&gt; （ヘッダーのコミット）、 &lt;code&gt;whitespace&lt;/code&gt; （空白エラーの強調表示）、 &lt;code&gt;oldMoved&lt;/code&gt; （削除された行）、 &lt;code&gt;newMoved&lt;/code&gt; （追加された行）、 &lt;code&gt;oldMovedDimmed&lt;/code&gt; 、 &lt;code&gt;oldMovedAlternative&lt;/code&gt; 、 &lt;code&gt;oldMovedAlternativeDimmed&lt;/code&gt; 、 &lt;code&gt;newMovedDimmed&lt;/code&gt; 、 &lt;code&gt;newMovedAlternative&lt;/code&gt; &lt;code&gt;newMovedAlternativeDimmed&lt;/code&gt; （詳細については、&lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt;の &lt;code&gt;--color-moved&lt;/code&gt; の &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 設定を参照）、 &lt;code&gt;contextDimmed&lt;/code&gt; 、 &lt;code&gt;oldDimmed&lt;/code&gt; 、 &lt;code&gt;newDimmed&lt;/code&gt; 、 &lt;code&gt;contextBold&lt;/code&gt; 、 &lt;code&gt;oldBold&lt;/code&gt; 、および &lt;code&gt;newBold&lt;/code&gt; （&lt;a href=&quot;git-range-diff&quot;&gt;git-rangeを&lt;/a&gt;参照）1]詳細については）。</target>
        </trans-unit>
        <trans-unit id="799532fe06b09693cab5782f0c7b74d1305d2cb1" translate="yes" xml:space="preserve">
          <source>Use customized color for each remote keyword. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; may be &lt;code&gt;hint&lt;/code&gt;, &lt;code&gt;warning&lt;/code&gt;, &lt;code&gt;success&lt;/code&gt; or &lt;code&gt;error&lt;/code&gt; which match the corresponding keyword.</source>
          <target state="translated">各リモートキーワードにカスタマイズされた色を使用します。 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; は、対応するキーワードに一致する &lt;code&gt;hint&lt;/code&gt; 、 &lt;code&gt;warning&lt;/code&gt; 、 &lt;code&gt;success&lt;/code&gt; または &lt;code&gt;error&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="e8363e3bb3b19269f1bec63465f050d08c7400a8" translate="yes" xml:space="preserve">
          <source>Use customized color for grep colorization. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; specifies which part of the line to use the specified color, and is one of</source>
          <target state="translated">grepの色付けにカスタマイズした色を使用します。 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; は、指定された色を使用する線の部分を指定します。</target>
        </trans-unit>
        <trans-unit id="3d940f7a54cc13b6b8a420b163ce2b7e4ccedf38" translate="yes" xml:space="preserve">
          <source>Use customized color for hints.</source>
          <target state="translated">ヒントにカスタマイズした色を使用します。</target>
        </trans-unit>
        <trans-unit id="a7bc0186c1d40a59aee910eedb6524484cbce3a0" translate="yes" xml:space="preserve">
          <source>Use customized color for push errors.</source>
          <target state="translated">プッシュエラーにカスタマイズされた色を使用します。</target>
        </trans-unit>
        <trans-unit id="efd1e4b094e6a540e69b42772ae161651f4648a2" translate="yes" xml:space="preserve">
          <source>Use customized color for status colorization. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; is one of &lt;code&gt;header&lt;/code&gt; (the header text of the status message), &lt;code&gt;added&lt;/code&gt; or &lt;code&gt;updated&lt;/code&gt; (files which are added but not committed), &lt;code&gt;changed&lt;/code&gt; (files which are changed but not added in the index), &lt;code&gt;untracked&lt;/code&gt; (files which are not tracked by Git), &lt;code&gt;branch&lt;/code&gt; (the current branch), &lt;code&gt;nobranch&lt;/code&gt; (the color the &lt;code&gt;no branch&lt;/code&gt; warning is shown in, defaulting to red), &lt;code&gt;localBranch&lt;/code&gt; or &lt;code&gt;remoteBranch&lt;/code&gt; (the local and remote branch names, respectively, when branch and tracking information is displayed in the status short-format), or &lt;code&gt;unmerged&lt;/code&gt; (files which have unmerged changes).</source>
          <target state="translated">ステータスの色付けにはカスタマイズされた色を使用します。 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; は、 &lt;code&gt;header&lt;/code&gt; （ステータスメッセージのヘッダーテキスト）、 &lt;code&gt;added&lt;/code&gt; または &lt;code&gt;updated&lt;/code&gt; （追加されたがコミットされていないファイル）、 &lt;code&gt;changed&lt;/code&gt; （変更されたがインデックスに追加されていないファイル）、 &lt;code&gt;untracked&lt;/code&gt; されていない（ファイル以外のファイル）Gitによって追跡されます）、 &lt;code&gt;branch&lt;/code&gt; （現在のブランチ）、 &lt;code&gt;nobranch&lt;/code&gt; （ &lt;code&gt;no branch&lt;/code&gt; 警告が表示される色、デフォルトは赤）、 &lt;code&gt;localBranch&lt;/code&gt; または &lt;code&gt;remoteBranch&lt;/code&gt; （ローカルおよびリモートのブランチ名、それぞれブランチおよび追跡情報が表示される場合）ステータスの短い形式）、または &lt;code&gt;unmerged&lt;/code&gt; （変更がマージされていないファイル）。</target>
        </trans-unit>
        <trans-unit id="42006ecfd08deb9b3ff0a3f1d7240d8f715710f3" translate="yes" xml:space="preserve">
          <source>Use customized color when a push was rejected.</source>
          <target state="translated">プッシュが拒否されたときにカスタマイズされた色を使用します。</target>
        </trans-unit>
        <trans-unit id="7714f2243f3ecb7a0c915a75f0d9677bee5cfddf" translate="yes" xml:space="preserve">
          <source>Use fixed strings for patterns (don&amp;rsquo;t interpret pattern as a regex).</source>
          <target state="translated">パターンには固定文字列を使用します（パターンを正規表現として解釈しないでください）。</target>
        </trans-unit>
        <trans-unit id="be83392780575c9c0f338875e4ab41fca7ad0580" translate="yes" xml:space="preserve">
          <source>Use given directory for the location of Git objects. We check &lt;code&gt;&amp;lt;dir&amp;gt;/packs/multi-pack-index&lt;/code&gt; for the current MIDX file, and &lt;code&gt;&amp;lt;dir&amp;gt;/packs&lt;/code&gt; for the pack-files to index.</source>
          <target state="translated">Gitオブジェクトの場所には、指定されたディレクトリを使用します。私たちは、チェック &lt;code&gt;&amp;lt;dir&amp;gt;/packs/multi-pack-index&lt;/code&gt; 現在のMIDXファイルのために、そして &lt;code&gt;&amp;lt;dir&amp;gt;/packs&lt;/code&gt; インデックスにパック・ファイルのために。</target>
        </trans-unit>
        <trans-unit id="58e0e6d68f2b1086e2f61cc3ccf9bb473fce2cb1" translate="yes" xml:space="preserve">
          <source>Use given directory for the location of packfiles and commit-graph file. This parameter exists to specify the location of an alternate that only has the objects directory, not a full &lt;code&gt;.git&lt;/code&gt; directory. The commit-graph file is expected to be in the &lt;code&gt;&amp;lt;dir&amp;gt;/info&lt;/code&gt; directory and the packfiles are expected to be in &lt;code&gt;&amp;lt;dir&amp;gt;/pack&lt;/code&gt;.</source>
          <target state="translated">packfilesとcommit-graphファイルの場所には、指定されたディレクトリを使用します。このパラメーターは、完全な &lt;code&gt;.git&lt;/code&gt; ディレクトリではなく、オブジェクトディレクトリのみを持つ代替の場所を指定するために存在します。commit-graphファイルは &lt;code&gt;&amp;lt;dir&amp;gt;/info&lt;/code&gt; ディレクトリにあり、packfilesは &lt;code&gt;&amp;lt;dir&amp;gt;/pack&lt;/code&gt; にあることが期待されています。</target>
        </trans-unit>
        <trans-unit id="034b8d3eb2bf376cba5a544572cc51a019ffd1af" translate="yes" xml:space="preserve">
          <source>Use given directory for the location of packfiles and commit-graph file. This parameter exists to specify the location of an alternate that only has the objects directory, not a full &lt;code&gt;.git&lt;/code&gt; directory. The commit-graph file is expected to be in the &lt;code&gt;&amp;lt;dir&amp;gt;/info&lt;/code&gt; directory and the packfiles are expected to be in &lt;code&gt;&amp;lt;dir&amp;gt;/pack&lt;/code&gt;. If the directory could not be made into an absolute path, or does not match any known object directory, &lt;code&gt;git commit-graph ...&lt;/code&gt; will exit with non-zero status.</source>
          <target state="translated">packfilesとcommit-graphファイルの場所に指定されたディレクトリを使用します。このパラメーターは、完全な &lt;code&gt;.git&lt;/code&gt; ディレクトリーではなく、objectsディレクトリーのみを持つ代替の場所を指定するために存在します。commit-graphファイルは &lt;code&gt;&amp;lt;dir&amp;gt;/info&lt;/code&gt; ディレクトリにあり、packfilesは &lt;code&gt;&amp;lt;dir&amp;gt;/pack&lt;/code&gt; にあると想定されています。ディレクトリを絶対パスにすることができなかった場合、または既知のオブジェクトディレクトリと一致しない場合、 &lt;code&gt;git commit-graph ...&lt;/code&gt; はゼロ以外のステータスで終了します。</target>
        </trans-unit>
        <trans-unit id="9e22ac3ec044552fceb6f971a8409c3fc735d918" translate="yes" xml:space="preserve">
          <source>Use gmail as the smtp server</source>
          <target state="translated">gmailをsmtpサーバーとして使用する</target>
        </trans-unit>
        <trans-unit id="243e0ec42451f8d223cf0a086b6e0d020fe017bc" translate="yes" xml:space="preserve">
          <source>Use hash &lt;code&gt;#&lt;/code&gt; for comments that are either on their own line, or after the email address.</source>
          <target state="translated">自分の行またはメールアドレスの後にあるコメントにはハッシュ &lt;code&gt;#&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="fe4290ca9cf2dcf165b3911c20fcc8115cf36b09" translate="yes" xml:space="preserve">
          <source>Use libcurl to communicate with the IMAP server, unless tunneling into it. Ignored if Git was built without the USE_CURL_FOR_IMAP_SEND option set.</source>
          <target state="translated">IMAP サーバーとの通信には libcurl を使用します。USE_CURL_FOR_IMAP_SEND オプションを設定せずに Git をビルドした場合は無視します。</target>
        </trans-unit>
        <trans-unit id="b43e2a7c9e04ff83908291bc454ceb95c66f26d2" translate="yes" xml:space="preserve">
          <source>Use mailmap file to map author and committer names and email addresses to canonical real names and email addresses. See &lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog[1]&lt;/a&gt;.</source>
          <target state="translated">mailmapファイルを使用して、作成者とコミッターの名前とメールアドレスを正規の実名とメールアドレスにマップします。&lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog [1]を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="869311b9e64386ec94c4224dbda98ca212bcb863" translate="yes" xml:space="preserve">
          <source>Use merging strategies to rebase. When the recursive (default) merge strategy is used, this allows rebase to be aware of renames on the upstream side.</source>
          <target state="translated">マージ戦略を使用してリベースを行います。再帰的な(デフォルトの)マージ戦略を使用した場合、これにより上流側でリベースがリネームを認識できるようになります。</target>
        </trans-unit>
        <trans-unit id="07cf71eed9a3b36f45bcc6fde8a3af9707bd0146" translate="yes" xml:space="preserve">
          <source>Use merging strategies to rebase. When the recursive (default) merge strategy is used, this allows rebase to be aware of renames on the upstream side. This is the default.</source>
          <target state="translated">マージ戦略を使用してリベースを行います。再帰的な(デフォルトの)マージ戦略を使用した場合、これにより上流側のリネームをリベースが認識できるようになります。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="504dd078aaf1ec972f6af826bbe142e1450759fa" translate="yes" xml:space="preserve">
          <source>Use of &quot;topic branches&quot; solves these problems. The name is pretty self explanatory, with a caveat that comes from the &quot;merge upwards&quot; rule above:</source>
          <target state="translated">トピックブランチ」を使用すると、これらの問題が解決されます。この名前は、上の &quot;上向きにマージ&quot; ルールに由来する注意点がありますが、かなり自己説明的なものです。</target>
        </trans-unit>
        <trans-unit id="2997460999cadfc1fcc5d52315d53b3d5efcd07d" translate="yes" xml:space="preserve">
          <source>Use of &lt;code&gt;dcommit&lt;/code&gt; is preferred to &lt;code&gt;set-tree&lt;/code&gt; (below).</source>
          <target state="translated">使用 &lt;code&gt;dcommit&lt;/code&gt; がより好まれる &lt;code&gt;set-tree&lt;/code&gt; （下記）。</target>
        </trans-unit>
        <trans-unit id="6b08c4843a60fcea417d6fa6b7562621b3124054" translate="yes" xml:space="preserve">
          <source>Use of this utility is encouraged in favor of directly accessing files under the &lt;code&gt;.git&lt;/code&gt; directory.</source>
          <target state="translated">このユーティリティの使用は、 &lt;code&gt;.git&lt;/code&gt; ディレクトリの下のファイルに直接アクセスすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="3a96544176d9c64bcdfe76616987380a83e4f896" translate="yes" xml:space="preserve">
          <source>Use permissions reported by umask(2). The default, when &lt;code&gt;--shared&lt;/code&gt; is not specified.</source>
          <target state="translated">umask（2）によって報告された許可を使用します。 &lt;code&gt;--shared&lt;/code&gt; が指定されていない場合のデフォルト。</target>
        </trans-unit>
        <trans-unit id="7b2e5a64a2bb1a5fbe6304abee401e1d3f35a8f4" translate="yes" xml:space="preserve">
          <source>Use reflog to find a better common ancestor between &amp;lt;upstream&amp;gt; and &amp;lt;branch&amp;gt; when calculating which commits have been introduced by &amp;lt;branch&amp;gt;.</source>
          <target state="translated">&amp;lt;branch&amp;gt;によって導入されたコミットを計算するときに、reflogを使用して、&amp;lt;upstream&amp;gt;と&amp;lt;branch&amp;gt;の間のより良い共通の祖先を見つけます。</target>
        </trans-unit>
        <trans-unit id="b40e39ff3f77007104d997879dd735023a9dca06" translate="yes" xml:space="preserve">
          <source>Use revisions from revs-file instead of calling &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list [1]&lt;/a&gt;を呼び出す代わりにrevs-fileのリビジョンを使用します。</target>
        </trans-unit>
        <trans-unit id="efb298546ca010c6e357a2c3cc79d1b86fb2f356" translate="yes" xml:space="preserve">
          <source>Use the &quot;sparse&quot; algorithm to determine which objects to include in the pack, when combined with the &quot;--revs&quot; option. This algorithm only walks trees that appear in paths that introduce new objects. This can have significant performance benefits when computing a pack to send a small change. However, it is possible that extra objects are added to the pack-file if the included commits contain certain types of direct renames.</source>
          <target state="translated">sparse&quot; アルゴリズムを使用して、どのオブジェクトをパックに含めるかを決定します。このアルゴリズムは、新しいオブジェクトを導入するパスの中に現れるツリーのみを歩きます。これは、小銭を送るためにパックを計算する際に、パフォーマンスを大きく向上させることができます。しかし、含まれるコミットに特定のタイプの直接リネームが含まれている場合、追加のオブジェクトがパックファイルに追加される可能性があります。</target>
        </trans-unit>
        <trans-unit id="0755f10a2fd51824d1737b45b49a4642d66873f8" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;--in-place&lt;/code&gt; option to edit a message file in place:</source>
          <target state="translated">使用 &lt;code&gt;--in-place&lt;/code&gt; 編集代わりに、メッセージ・ファイルにオプションを：</target>
        </trans-unit>
        <trans-unit id="55e7e1126d3aa0a5c8bf2360dfcd495bb1107882" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;working-tree-encoding&lt;/code&gt; attribute only if you cannot store a file in UTF-8 encoding and if you want Git to be able to process the content as text.</source>
          <target state="translated">ファイルをUTF-8エンコーディングで格納できない場合、およびGitでコンテンツをテキストとして処理できるようにする場合にのみ、 &lt;code&gt;working-tree-encoding&lt;/code&gt; 属性を使用します。</target>
        </trans-unit>
        <trans-unit id="b5ec705c3f1e9d70bd95302efbf5732684172042" translate="yes" xml:space="preserve">
          <source>Use the branch detection algorithm to find new paths in p4. It is documented below in &quot;BRANCH DETECTION&quot;.</source>
          <target state="translated">p4 で新しいパスを見つけるには、分岐検出アルゴリズムを使用します。これについては、以下の「分岐検出」で説明します。</target>
        </trans-unit>
        <trans-unit id="33ac56041ae34da6b3682a94d8a665913a47636a" translate="yes" xml:space="preserve">
          <source>Use the credential (e.g., access the URL with the username and password from step (2)), and see if it&amp;rsquo;s accepted.</source>
          <target state="translated">資格情報を使用して（たとえば、ステップ（2）のユーザー名とパスワードでURLにアクセスします）、それが受け入れられるかどうかを確認します。</target>
        </trans-unit>
        <trans-unit id="4cfefdd524d37cf0c1fedc168c903048fc636bbd" translate="yes" xml:space="preserve">
          <source>Use the customized color for the part of git-blame output that is repeated meta information per line (such as commit id, author name, date and timezone). Defaults to cyan.</source>
          <target state="translated">git-blame の出力のうち、1 行ごとにメタ情報 (コミット ID、著者名、日付、タイムゾーンなど)が繰り返される部分の色をカスタマイズします。デフォルトは cyan です。</target>
        </trans-unit>
        <trans-unit id="a024bae6c0f6ae8fa68e77c95e0c4f95100aa970" translate="yes" xml:space="preserve">
          <source>Use the diff tool specified by &amp;lt;tool&amp;gt;. Valid values include emerge, kompare, meld, and vimdiff. Run &lt;code&gt;git difftool --tool-help&lt;/code&gt; for the list of valid &amp;lt;tool&amp;gt; settings.</source>
          <target state="translated">&amp;lt;tool&amp;gt;で指定されたdiffツールを使用します。有効な値には、emerge、konpare、meld、vimdiffがあります。有効な&amp;lt;tool&amp;gt;設定のリストについては、 &lt;code&gt;git difftool --tool-help&lt;/code&gt; を実行してください。</target>
        </trans-unit>
        <trans-unit id="161588bc8b76efbad18d428ccf6e2f5e459908d1" translate="yes" xml:space="preserve">
          <source>Use the fast patchset import strategy. This can be significantly faster for large trees, but cannot handle directory renames or permissions changes. The default strategy is slow and safe.</source>
          <target state="translated">高速なパッチセットのインポート戦略を使用してください。これは大きなツリーに対してはかなり高速になりますが、ディレクトリのリネームやパーミッションの変更を扱うことはできません。デフォルトのストラテジーは低速で安全です。</target>
        </trans-unit>
        <trans-unit id="89541b63bc820ad5c76ea37101a62452ee62e61c" translate="yes" xml:space="preserve">
          <source>Use the following attributes if your &lt;code&gt;*.ps1&lt;/code&gt; files are UTF-16 little endian encoded without BOM and you want Git to use Windows line endings in the working directory (use &lt;code&gt;UTF-16LE-BOM&lt;/code&gt; instead of &lt;code&gt;UTF-16LE&lt;/code&gt; if you want UTF-16 little endian with BOM). Please note, it is highly recommended to explicitly define the line endings with &lt;code&gt;eol&lt;/code&gt; if the &lt;code&gt;working-tree-encoding&lt;/code&gt; attribute is used to avoid ambiguity.</source>
          <target state="translated">あなたの場合は、以下の属性を使用してください &lt;code&gt;*.ps1&lt;/code&gt; というファイルはBOMなしでエンコードされたUTF-16リトルエンディアンであり、あなたはGitが作業ディレクトリ（使用中のWindowsの行末を使用する &lt;code&gt;UTF-16LE-BOM&lt;/code&gt; の代わりに、 &lt;code&gt;UTF-16LE&lt;/code&gt; あなたはUTF-16をしたい場合BOMのリトルエンディアン）。あいまいさを避けるために &lt;code&gt;working-tree-encoding&lt;/code&gt; 属性を使用する場合は、行末を &lt;code&gt;eol&lt;/code&gt; で明示的に定義することを強くお勧めします。</target>
        </trans-unit>
        <trans-unit id="e5c2f58b6a6ebc713504e60181f4f0dd37da2d6d" translate="yes" xml:space="preserve">
          <source>Use the given &amp;lt;msg&amp;gt; as the commit message. If multiple &lt;code&gt;-m&lt;/code&gt; options are given, their values are concatenated as separate paragraphs.</source>
          <target state="translated">指定された&amp;lt;msg&amp;gt;をコミットメッセージとして使用します。複数の &lt;code&gt;-m&lt;/code&gt; オプションが指定されている場合、それらの値は別々の段落として連結されます。</target>
        </trans-unit>
        <trans-unit id="be3b9715415e0357d3d87d01aa8f812c871fb1e1" translate="yes" xml:space="preserve">
          <source>Use the given &lt;code&gt;msg&lt;/code&gt; as the commit message. This option disables the &lt;code&gt;--edit&lt;/code&gt; option.</source>
          <target state="translated">与えられた使用 &lt;code&gt;msg&lt;/code&gt; コミットメッセージとして。このオプションは &lt;code&gt;--edit&lt;/code&gt; オプションを無効にします。</target>
        </trans-unit>
        <trans-unit id="43103d879018fa15a44cefa9b3baec705e25165c" translate="yes" xml:space="preserve">
          <source>Use the given config file instead of the one specified by GIT_CONFIG.</source>
          <target state="translated">GIT_CONFIG で指定された設定ファイルの代わりに、指定された設定ファイルを使用してください。</target>
        </trans-unit>
        <trans-unit id="6d07104b51b424f44cb0346a9ac8f4116b0f06d7" translate="yes" xml:space="preserve">
          <source>Use the given exclude pattern in addition to the standard ignore rules (see &lt;a href=&quot;gitignore&quot;&gt;gitignore[5]&lt;/a&gt;).</source>
          <target state="translated">標準の無視ルールに加えて、指定された除外パターンを使用します（&lt;a href=&quot;gitignore&quot;&gt;gitignore [5]を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="9a12bbd112f0b48f03fdbbbb0b9c68268bedd960" translate="yes" xml:space="preserve">
          <source>Use the given merge strategy. If there is no &lt;code&gt;-s&lt;/code&gt; option &lt;code&gt;git merge-recursive&lt;/code&gt; is used instead. This implies --merge.</source>
          <target state="translated">指定されたマージ戦略を使用します。 &lt;code&gt;-s&lt;/code&gt; オプションがない場合は、代わりに &lt;code&gt;git merge-recursive&lt;/code&gt; が使用されます。これは--mergeを意味します。</target>
        </trans-unit>
        <trans-unit id="aad779cdebc63bc4b25eb19e46a7b214101b70ea" translate="yes" xml:space="preserve">
          <source>Use the given merge strategy. Should only be used once. See the MERGE STRATEGIES section in &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt; for details.</source>
          <target state="translated">指定されたマージ戦略を使用します。一度だけ使用してください。詳細については、&lt;a href=&quot;git-merge&quot;&gt;git-merge [1]&lt;/a&gt;のMERGE STRATEGIESセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="0d697cccd6049781089822f14d706ae91b43a781" translate="yes" xml:space="preserve">
          <source>Use the given merge strategy; can be supplied more than once to specify them in the order they should be tried. If there is no &lt;code&gt;-s&lt;/code&gt; option, a built-in list of strategies is used instead (&lt;code&gt;git merge-recursive&lt;/code&gt; when merging a single head, &lt;code&gt;git merge-octopus&lt;/code&gt; otherwise).</source>
          <target state="translated">指定されたマージ戦略を使用します。複数回指定して、試行する順序で指定できます。 &lt;code&gt;-s&lt;/code&gt; オプションがない場合は、代わりに組み込みの戦略リストが使用されます（単一のヘッドをマージする場合は &lt;code&gt;git merge-recursive&lt;/code&gt; 、それ以外の場合は &lt;code&gt;git merge-octopus&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e15a6801b533c61848133f0481a1499ec359e784" translate="yes" xml:space="preserve">
          <source>Use the given note message (instead of prompting). If multiple &lt;code&gt;-m&lt;/code&gt; options are given, their values are concatenated as separate paragraphs. Lines starting with &lt;code&gt;#&lt;/code&gt; and empty lines other than a single line between paragraphs will be stripped out.</source>
          <target state="translated">（プロンプトの代わりに）指定されたノートメッセージを使用します。複数の &lt;code&gt;-m&lt;/code&gt; オプションが指定されている場合、それらの値は別々の段落として連結されます。 &lt;code&gt;#&lt;/code&gt; で始まる行と、段落間の1行以外の空行は削除されます。</target>
        </trans-unit>
        <trans-unit id="2301e57be484e5bf3374c6061960726be52acd3f" translate="yes" xml:space="preserve">
          <source>Use the given tag message (instead of prompting). If multiple &lt;code&gt;-m&lt;/code&gt; options are given, their values are concatenated as separate paragraphs. Implies &lt;code&gt;-a&lt;/code&gt; if none of &lt;code&gt;-a&lt;/code&gt;, &lt;code&gt;-s&lt;/code&gt;, or &lt;code&gt;-u &amp;lt;keyid&amp;gt;&lt;/code&gt; is given.</source>
          <target state="translated">（プロンプトの代わりに）指定されたタグメッセージを使用します。複数の &lt;code&gt;-m&lt;/code&gt; オプションが指定されている場合、それらの値は別々の段落として連結されます。意味 &lt;code&gt;-a&lt;/code&gt; をのどれ場合 &lt;code&gt;-a&lt;/code&gt; 、 &lt;code&gt;-s&lt;/code&gt; 、または &lt;code&gt;-u &amp;lt;keyid&amp;gt;&lt;/code&gt; 与えられていません。</target>
        </trans-unit>
        <trans-unit id="52a6c166f490dbb0be0d25b65f46015f7e67e623" translate="yes" xml:space="preserve">
          <source>Use the interactive patch selection interface to chose which changes to commit. See &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; for details.</source>
          <target state="translated">インタラクティブなパッチ選択インターフェイスを使用して、コミットする変更を選択します。詳細は&lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="7db128e87ada4e1ec3f3340d8431acfc429f3677" translate="yes" xml:space="preserve">
          <source>Use the merge resolution program specified by &amp;lt;tool&amp;gt;. Valid values include emerge, gvimdiff, kdiff3, meld, vimdiff, and tortoisemerge. Run &lt;code&gt;git mergetool --tool-help&lt;/code&gt; for the list of valid &amp;lt;tool&amp;gt; settings.</source>
          <target state="translated">&amp;lt;tool&amp;gt;で指定されたマージ解決プログラムを使用します。有効な値は、emerge、gvimdiff、kdiff3、meld、vimdiff、tortoisemergeです。有効な&amp;lt;tool&amp;gt;設定のリストについては、 &lt;code&gt;git mergetool --tool-help&lt;/code&gt; を実行してください。</target>
        </trans-unit>
        <trans-unit id="047156e36b9d6e8b2155d32a029545b1b026f10e" translate="yes" xml:space="preserve">
          <source>Use the multi-pack-index file to track multiple packfiles using a single index. See &lt;a href=&quot;multi-pack-index&quot;&gt;the multi-pack-index design document&lt;/a&gt;.</source>
          <target state="translated">multi-pack-indexファイルを使用して、単一のインデックスを使用して複数のパックファイルを追跡します。&lt;a href=&quot;multi-pack-index&quot;&gt;multi-pack-indexデザインドキュメントを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="f14443aa07cf034aa00129ee21b4f7df2be49255" translate="yes" xml:space="preserve">
          <source>Use the partial clone feature and request that the server sends a subset of reachable objects according to a given object filter. When using &lt;code&gt;--filter&lt;/code&gt;, the supplied &lt;code&gt;&amp;lt;filter-spec&amp;gt;&lt;/code&gt; is used for the partial clone filter. For example, &lt;code&gt;--filter=blob:none&lt;/code&gt; will filter out all blobs (file contents) until needed by Git. Also, &lt;code&gt;--filter=blob:limit=&amp;lt;size&amp;gt;&lt;/code&gt; will filter out all blobs of size at least &lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;. For more details on filter specifications, see the &lt;code&gt;--filter&lt;/code&gt; option in &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt;.</source>
          <target state="translated">部分クローン機能を使用して、サーバーが特定のオブジェクトフィルターに従って到達可能なオブジェクトのサブセットを送信するように要求します。 &lt;code&gt;--filter&lt;/code&gt; を使用する場合、提供された &lt;code&gt;&amp;lt;filter-spec&amp;gt;&lt;/code&gt; が部分クローンフィルターに使用されます。たとえば、 &lt;code&gt;--filter=blob:none&lt;/code&gt; は、Gitで必要になるまで、すべてのBLOB（ファイルの内容）を除外します。また、 &lt;code&gt;--filter=blob:limit=&amp;lt;size&amp;gt;&lt;/code&gt; は、少なくとも &lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt; のサイズのすべてのblobを除外します。フィルタ仕様の詳細については、&lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list [1]&lt;/a&gt;の &lt;code&gt;--filter&lt;/code&gt; オプションを参照してください。</target>
        </trans-unit>
        <trans-unit id="6bac5b4ccbcc396e691c8ba8f2af89d4f60c9270" translate="yes" xml:space="preserve">
          <source>Use the same output mode as &lt;a href=&quot;git-annotate&quot;&gt;git-annotate[1]&lt;/a&gt; (Default: off).</source>
          <target state="translated">&lt;a href=&quot;git-annotate&quot;&gt;git-annotate [1]&lt;/a&gt;と同じ出力モードを使用します（デフォルト：オフ）。</target>
        </trans-unit>
        <trans-unit id="0ed67a2ecd3a9ee96ae4cd7dcb45f48a2cf84bf4" translate="yes" xml:space="preserve">
          <source>Use the selected commit message without launching an editor. For example, &lt;code&gt;git commit --amend --no-edit&lt;/code&gt; amends a commit without changing its commit message.</source>
          <target state="translated">エディターを起動せずに、選択したコミットメッセージを使用します。たとえば、 &lt;code&gt;git commit --amend --no-edit&lt;/code&gt; は、コミットメッセージを変更せずにコミットを修正します。</target>
        </trans-unit>
        <trans-unit id="8e65c034e7da87d64be153e02b39a8529bd16f67" translate="yes" xml:space="preserve">
          <source>Use the source ref that matches &lt;code&gt;master&lt;/code&gt; (e.g. &lt;code&gt;refs/heads/master&lt;/code&gt;) to update the ref that matches &lt;code&gt;satellite/master&lt;/code&gt; (most probably &lt;code&gt;refs/remotes/satellite/master&lt;/code&gt;) in the &lt;code&gt;mothership&lt;/code&gt; repository; do the same for &lt;code&gt;dev&lt;/code&gt; and &lt;code&gt;satellite/dev&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;master&lt;/code&gt; 一致するソース参照（例： &lt;code&gt;refs/heads/master&lt;/code&gt; ）を使用して、 &lt;code&gt;mothership&lt;/code&gt; リポジトリ内の &lt;code&gt;satellite/master&lt;/code&gt; （ほとんどの場合は &lt;code&gt;refs/remotes/satellite/master&lt;/code&gt; ）に一致する参照を更新します。 &lt;code&gt;dev&lt;/code&gt; と &lt;code&gt;satellite/dev&lt;/code&gt; についても同じようにします。</target>
        </trans-unit>
        <trans-unit id="82b93c6560af27195da14e70510e2b3d8651c3b7" translate="yes" xml:space="preserve">
          <source>Use the specified HTTP protocol version when communicating with a server. If you want to force the default. The available and default version depend on libcurl. Actually the possible values of this option are:</source>
          <target state="translated">サーバとの通信時に指定したHTTPプロトコルのバージョンを使用します。デフォルトを強制的に使用したい場合。利用可能なバージョンとデフォルトのバージョンは libcurl に依存します。実際には、このオプションの可能な値は</target>
        </trans-unit>
        <trans-unit id="85fede53ff0add46d3665dfda925d3c1db752a7f" translate="yes" xml:space="preserve">
          <source>Use the specified HTTP protocol version when communicating with a server. If you want to force the default. The available and default version depend on libcurl. Currently the possible values of this option are:</source>
          <target state="translated">サーバーと通信する際に、指定したHTTPプロトコルのバージョンを使用します。デフォルトを強制的に使用したい場合。利用可能なバージョンと既定のバージョンは libcurl に依存します。現在、このオプションの可能な値は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="becfdaabcf538340d904ac918eb155dd5d16c802" translate="yes" xml:space="preserve">
          <source>Use the specified URL to connect to the destination Subversion repository. This is useful in cases where the source SVN repository is read-only. This option overrides configuration property &lt;code&gt;commiturl&lt;/code&gt;.</source>
          <target state="translated">指定されたURLを使用して、宛先のSubversionリポジトリに接続します。これは、ソースSVNリポジトリが読み取り専用である場合に役立ちます。このオプションは、設定プロパティ &lt;code&gt;commiturl&lt;/code&gt; をオーバーライドします。</target>
        </trans-unit>
        <trans-unit id="eded6790141cbbb141d77bfcf5fc351397828538" translate="yes" xml:space="preserve">
          <source>Use the specified name for the initial branch in the newly created repository. If not specified, fall back to the default name: &lt;code&gt;master&lt;/code&gt;.</source>
          <target state="translated">新しく作成されたリポジトリの最初のブランチには、指定された名前を使用します。指定しない場合は、デフォルト名の &lt;code&gt;master&lt;/code&gt; にフォールバックします。</target>
        </trans-unit>
        <trans-unit id="9e057e9e47493412f91dea4102ac0984cb71bdeb" translate="yes" xml:space="preserve">
          <source>Use the value of the &lt;code&gt;core.whitespace&lt;/code&gt; configuration variable to decide what to notice as error.</source>
          <target state="translated">&lt;code&gt;core.whitespace&lt;/code&gt; 構成変数の値を使用して、エラーとして何を通知するかを決定します。</target>
        </trans-unit>
        <trans-unit id="810f8c03feb9550dd6740190f543dbb37624e241" translate="yes" xml:space="preserve">
          <source>Use this custom program instead of &quot;&lt;code&gt;gpg&lt;/code&gt;&quot; found on &lt;code&gt;$PATH&lt;/code&gt; when making or verifying a PGP signature. The program must support the same command-line interface as GPG, namely, to verify a detached signature, &quot;&lt;code&gt;gpg --verify $signature - &amp;lt;$file&lt;/code&gt;&quot; is run, and the program is expected to signal a good signature by exiting with code 0, and to generate an ASCII-armored detached signature, the standard input of &quot;&lt;code&gt;gpg -bsau $key&lt;/code&gt;&quot; is fed with the contents to be signed, and the program is expected to send the result to its standard output.</source>
          <target state="translated">PGP署名を作成または検証するときに、 &lt;code&gt;$PATH&lt;/code&gt; にある「 &lt;code&gt;gpg&lt;/code&gt; 」の代わりにこのカスタムプログラムを使用します。プログラムは、GPGと同じコマンドラインインターフェイスをサポートする必要があります。つまり、切り離された署名を確認するには、「 &lt;code&gt;gpg --verify $signature - &amp;lt;$file&lt;/code&gt; 」が実行され、プログラムはコードで終了することにより、適切な署名を通知します。 0、およびASCII装甲の分離署名を生成するには、「 &lt;code&gt;gpg -bsau $key&lt;/code&gt; 」の標準入力に署名する内容を入力し、プログラムは結果を標準出力に送信することが期待されます。</target>
        </trans-unit>
        <trans-unit id="a644dabd3c4c5e288aecaab3da05ddb8c7da086c" translate="yes" xml:space="preserve">
          <source>Use this for compatibility with old-style branch names used by earlier versions of &lt;code&gt;git archimport&lt;/code&gt;. Old-style branch names were category--branch, whereas new-style branch names are archive,category--branch--version. In both cases, names given on the command-line will override the automatically-generated ones.</source>
          <target state="translated">これは、以前のバージョンの &lt;code&gt;git archimport&lt;/code&gt; で使用されていた古いスタイルのブランチ名との互換性のために使用します。古いスタイルのブランチ名はcategory--branchでしたが、新しいスタイルのブランチ名はarchive、category--branch--versionです。どちらの場合も、コマンドラインで指定された名前は、自動生成された名前を上書きします。</target>
        </trans-unit>
        <trans-unit id="ad85fb495e355ea9ee99bf9caef60d6a5acc4df9" translate="yes" xml:space="preserve">
          <source>Use this for compatibility with old-style branch names used by earlier versions of &lt;code&gt;git archimport&lt;/code&gt;. Old-style branch names were category{litdd}branch, whereas new-style branch names are archive,category{litdd}branch{litdd}version. In both cases, names given on the command-line will override the automatically-generated ones.</source>
          <target state="translated">これは、以前のバージョンの &lt;code&gt;git archimport&lt;/code&gt; で使用されていた古いスタイルのブランチ名との互換性のために使用します。古いスタイルのブランチ名はカテゴリ{litdd}ブランチでしたが、新しいスタイルのブランチ名はアーカイブ、カテゴリ{litdd}ブランチ{litdd}バージョンです。どちらの場合も、コマンドラインで指定された名前は、自動生成された名前をオーバーライドします。</target>
        </trans-unit>
        <trans-unit id="f09efb8456c99114df5272977533145bfda3715e" translate="yes" xml:space="preserve">
          <source>Use this option to integrate changes from the upstream subproject with your submodule&amp;rsquo;s current HEAD. Alternatively, you can run &lt;code&gt;git pull&lt;/code&gt; from the submodule, which is equivalent except for the remote branch name: &lt;code&gt;update --remote&lt;/code&gt; uses the default upstream repository and &lt;code&gt;submodule.&amp;lt;name&amp;gt;.branch&lt;/code&gt;, while &lt;code&gt;git pull&lt;/code&gt; uses the submodule&amp;rsquo;s &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt;. Prefer &lt;code&gt;submodule.&amp;lt;name&amp;gt;.branch&lt;/code&gt; if you want to distribute the default upstream branch with the superproject and &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; if you want a more native feel while working in the submodule itself.</source>
          <target state="translated">このオプションを使用して、アップストリームサブプロジェクトからの変更をサブモジュールの現在のHEADと統合します。また、あなたが実行することができます &lt;code&gt;git pull&lt;/code&gt; リモートブランチ名を除いて同等であるサブモジュールから： &lt;code&gt;update --remote&lt;/code&gt; デフォルトの上流リポジトリと使用しています &lt;code&gt;submodule.&amp;lt;name&amp;gt;.branch&lt;/code&gt; 、一方で &lt;code&gt;git pull&lt;/code&gt; サブモジュールの使用しています &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; 。優先 &lt;code&gt;submodule.&amp;lt;name&amp;gt;.branch&lt;/code&gt; あなたが親プロジェクトとして、デフォルト上流分岐を配布する場合 &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; サブモジュール自体での作業中に、あなたがより多くのネイティブな感触をしたい場合。</target>
        </trans-unit>
        <trans-unit id="205f9bc458a5cacd665ee1af1eac8a989bc13811" translate="yes" xml:space="preserve">
          <source>Use this option to set the namespace where the original commits will be stored. The default value is &lt;code&gt;refs/original&lt;/code&gt;.</source>
          <target state="translated">このオプションを使用して、元のコミットが保存されるネームスペースを設定します。デフォルト値は &lt;code&gt;refs/original&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="978a87da673ee3d6baf57006a070d2ceaf2e0a29" translate="yes" xml:space="preserve">
          <source>Use this option to set the path to the temporary directory used for rewriting. When applying a tree filter, the command needs to temporarily check out the tree to some directory, which may consume considerable space in case of large projects. By default it does this in the &lt;code&gt;.git-rewrite/&lt;/code&gt; directory but you can override that choice by this parameter.</source>
          <target state="translated">このオプションを使用して、書き換えに使用する一時ディレクトリへのパスを設定します。ツリーフィルターを適用する場合、コマンドは一時的にツリーをいくつかのディレクトリにチェックアウトする必要があります。これは、大規模なプロジェクトの場合にかなりのスペースを消費する可能性があります。デフォルトでは、これは &lt;code&gt;.git-rewrite/&lt;/code&gt; ディレクトリーで行われますが、このパラメーターでその選択をオーバーライドできます。</target>
        </trans-unit>
        <trans-unit id="7dad6966beac366ffc5d985e757265d090b93f5a" translate="yes" xml:space="preserve">
          <source>Use this option to unstage and remove paths only from the index. Working tree files, whether modified or not, will be left alone.</source>
          <target state="translated">このオプションを使用すると、ステージを解除してインデックスからパスのみを削除することができます。作業ツリーファイルは、変更されているかどうかに関わらず、そのままにしておきます。</target>
        </trans-unit>
        <trans-unit id="22e3468b42fc7b02294ecbf3cdd521f378eedf7b" translate="yes" xml:space="preserve">
          <source>Use this to customize the program used for the signing format you chose. (see &lt;code&gt;gpg.program&lt;/code&gt; and &lt;code&gt;gpg.format&lt;/code&gt;) &lt;code&gt;gpg.program&lt;/code&gt; can still be used as a legacy synonym for &lt;code&gt;gpg.openpgp.program&lt;/code&gt;. The default value for &lt;code&gt;gpg.x509.program&lt;/code&gt; is &quot;gpgsm&quot;.</source>
          <target state="translated">これを使用して、選択した署名形式に使用されるプログラムをカスタマイズします。 （参照 &lt;code&gt;gpg.program&lt;/code&gt; と &lt;code&gt;gpg.format&lt;/code&gt; を） &lt;code&gt;gpg.program&lt;/code&gt; は依然としてため、従来の同義語として使用することができる &lt;code&gt;gpg.openpgp.program&lt;/code&gt; 。 &lt;code&gt;gpg.x509.program&lt;/code&gt; のデフォルト値は「gpgsm」です。</target>
        </trans-unit>
        <trans-unit id="2c0ec0febb1ffdfb71fd1faf1bdd4ef5cebdb7eb" translate="yes" xml:space="preserve">
          <source>Use this to specify the path to &lt;code&gt;git-upload-pack&lt;/code&gt; on the remote side, if is not found on your $PATH. Installations of sshd ignores the user&amp;rsquo;s environment setup scripts for login shells (e.g. .bash_profile) and your privately installed git may not be found on the system default $PATH. Another workaround suggested is to set up your $PATH in &quot;.bashrc&quot;, but this flag is for people who do not want to pay the overhead for non-interactive shells by having a lean .bashrc file (they set most of the things up in .bash_profile).</source>
          <target state="translated">$ PATHに見つからない場合、これを使用してリモート側の &lt;code&gt;git-upload-pack&lt;/code&gt; へのパスを指定します。 sshdのインストールでは、ログインシェルのユーザーの環境設定スクリプト（.bash_profileなど）が無視され、プライベートにインストールされたgitがシステムのデフォルトの$ PATHにない場合があります。推奨される別の回避策は、「。bashrc」に$ PATHを設定することですが、このフラグは、無駄のない.bashrcファイルを用意して非インタラクティブシェルのオーバーヘッドを負担したくない人のためのものです（ほとんどの設定は.bash_profile内）。</target>
        </trans-unit>
        <trans-unit id="1f3cdffd9311e81ebd0ee41b41de344f546bb6a2" translate="yes" xml:space="preserve">
          <source>Used DBI driver. You can specify any available driver for this here, but it might not work. cvsserver is tested with &lt;code&gt;DBD::SQLite&lt;/code&gt;, reported to work with &lt;code&gt;DBD::Pg&lt;/code&gt;, and reported &lt;strong&gt;not&lt;/strong&gt; to work with &lt;code&gt;DBD::mysql&lt;/code&gt;. Please regard this as an experimental feature. May not contain colons (&lt;code&gt;:&lt;/code&gt;). Default: &lt;code&gt;SQLite&lt;/code&gt;</source>
          <target state="translated">使用したDBIドライバー。ここで使用可能なドライバーを指定できますが、機能しない可能性があります。 cvsserverは &lt;code&gt;DBD::SQLite&lt;/code&gt; でテストされ、DBD :: &lt;code&gt;DBD::Pg&lt;/code&gt; で動作することが報告されており、 &lt;code&gt;DBD::mysql&lt;/code&gt; 動作し&lt;strong&gt;ない&lt;/strong&gt;ことが報告されて&lt;strong&gt;い&lt;/strong&gt;ます。これは実験的な機能と見なしてください。コロンを含めることはできません（ &lt;code&gt;:&lt;/code&gt; ）。デフォルト： &lt;code&gt;SQLite&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e96c8aa1d6db1322edc422d5cc1ffbd12e71daed" translate="yes" xml:space="preserve">
          <source>Used Perl DBI driver. You can specify any available driver for this here, but it might not work. git-cvsserver is tested with &lt;code&gt;DBD::SQLite&lt;/code&gt;, reported to work with &lt;code&gt;DBD::Pg&lt;/code&gt;, and reported &lt;strong&gt;not&lt;/strong&gt; to work with &lt;code&gt;DBD::mysql&lt;/code&gt;. Experimental feature. May not contain double colons (&lt;code&gt;:&lt;/code&gt;). Default: &lt;code&gt;SQLite&lt;/code&gt;. See &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver[1]&lt;/a&gt;.</source>
          <target state="translated">Perl DBIドライバーを使用。ここで使用可能なドライバーを指定できますが、機能しない可能性があります。 git-cvsserverは &lt;code&gt;DBD::SQLite&lt;/code&gt; でテストされ、DBD &lt;code&gt;DBD::Pg&lt;/code&gt; で動作することが報告されており、 &lt;code&gt;DBD::mysql&lt;/code&gt; 動作し&lt;strong&gt;ない&lt;/strong&gt;ことが報告されて&lt;strong&gt;い&lt;/strong&gt;ます。実験的機能。ダブルコロンを含めることはできません（ &lt;code&gt;:&lt;/code&gt; ）。デフォルト： &lt;code&gt;SQLite&lt;/code&gt; 。&lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver [1]を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="3dcc5e110a8886980641614ba00244bbf70eb3c6" translate="yes" xml:space="preserve">
          <source>Used as %(if)&amp;hellip;​%(then)&amp;hellip;​%(end) or %(if)&amp;hellip;​%(then)&amp;hellip;​%(else)&amp;hellip;​%(end). If there is an atom with value or string literal after the %(if) then everything after the %(then) is printed, else if the %(else) atom is used, then everything after %(else) is printed. We ignore space when evaluating the string before %(then), this is useful when we use the %(HEAD) atom which prints either &quot;*&quot; or &quot; &quot; and we want to apply the &lt;code&gt;if&lt;/code&gt; condition only on the &lt;code&gt;HEAD&lt;/code&gt; ref. Append &quot;:equals=&amp;lt;string&amp;gt;&quot; or &quot;:notequals=&amp;lt;string&amp;gt;&quot; to compare the value between the %(if:&amp;hellip;​) and %(then) atoms with the given string.</source>
          <target state="translated">％（if）&amp;hellip;％（then）&amp;hellip;％（end）または％（if）&amp;hellip;％（then）&amp;hellip;％（else）&amp;hellip;％（end）として使用されます。 ％（if）の後に値または文字列リテラルを持つアトムがある場合、％（then）の後のすべてが出力されます。それ以外の場合、％（else）アトムが使用される場合、％（else）の後のすべてが出力されます。 ％（then）の前の文字列を評価するときにスペースを無視します。これは、「*」または「」を出力する％（HEAD）アトムを使用し、 &lt;code&gt;HEAD&lt;/code&gt; 参照にのみ &lt;code&gt;if&lt;/code&gt; 条件を適用する場合に役立ちます。 「：equals = &amp;lt;string&amp;gt;」または「：notequals = &amp;lt;string&amp;gt;」を追加して、％（if：&amp;hellip;）および％（then）アトム間の値を指定された文字列と比較します。</target>
        </trans-unit>
        <trans-unit id="88972a7007de9e429d28d6bad7487052b23f9b65" translate="yes" xml:space="preserve">
          <source>Used to check that a bundle file is valid and will apply cleanly to the current repository. This includes checks on the bundle format itself as well as checking that the prerequisite commits exist and are fully linked in the current repository. &lt;code&gt;git bundle&lt;/code&gt; prints a list of missing commits, if any, and exits with a non-zero status.</source>
          <target state="translated">バンドルファイルが有効であり、現在のリポジトリにクリーンに適用されることを確認するために使用されます。これには、バンドル形式自体のチェック、および前提条件のコミットが存在し、現在のリポジトリに完全にリンクされていることのチェックが含まれます。 &lt;code&gt;git bundle&lt;/code&gt; は、不足しているコミットがある場合はそのリストを出力し、ゼロ以外のステータスで終了します。</target>
        </trans-unit>
        <trans-unit id="a81dfbb4b6756f63bb43c72d54c78dd02ef851d4" translate="yes" xml:space="preserve">
          <source>Used to create a bundle named &lt;code&gt;file&lt;/code&gt;. This requires the &lt;code&gt;&amp;lt;git-rev-list-args&amp;gt;&lt;/code&gt; arguments to define the bundle contents. &lt;code&gt;options&lt;/code&gt; contains the options specific to the &lt;code&gt;git bundle create&lt;/code&gt; subcommand.</source>
          <target state="translated">&lt;code&gt;file&lt;/code&gt; という名前のバンドルを作成するために使用されます。これには、バンドルの内容を定義する &lt;code&gt;&amp;lt;git-rev-list-args&amp;gt;&lt;/code&gt; 引数が必要です。 &lt;code&gt;options&lt;/code&gt; には、 &lt;code&gt;git bundle create&lt;/code&gt; サブコマンドに固有のオプションが含まれています。</target>
        </trans-unit>
        <trans-unit id="fe127bac2ab0b61ffb60c0284f3741224c9951e1" translate="yes" xml:space="preserve">
          <source>Used to enforce or disable certificate revocation checks in cURL when http.sslBackend is set to &quot;schannel&quot;. Defaults to &lt;code&gt;true&lt;/code&gt; if unset. Only necessary to disable this if Git consistently errors and the message is about checking the revocation status of a certificate. This option is ignored if cURL lacks support for setting the relevant SSL option at runtime.</source>
          <target state="translated">http.sslBackendが「schannel」に設定されている場合、cURLで証明書失効チェックを強制または無効にするために使用されます。設定されてい &lt;code&gt;true&lt;/code&gt; 場合、デフォルトはtrueです。 Gitが一貫してエラーになり、メッセージが証明書の失効ステータスの確認に関するものである場合にのみ、これを無効にする必要があります。実行時に関連するSSLオプションを設定するためのサポートがcURLにない場合、このオプションは無視されます。</target>
        </trans-unit>
        <trans-unit id="526891fe0801e3a16c20e50ecde492e75d4f6490" translate="yes" xml:space="preserve">
          <source>Used to set the maximum load that we will still respond to gitweb queries. If the server load exceeds this value then gitweb will return &quot;503 Service Unavailable&quot; error. The server load is taken to be 0 if gitweb cannot determine its value. Currently it works only on Linux, where it uses &lt;code&gt;/proc/loadavg&lt;/code&gt;; the load there is the number of active tasks on the system &amp;mdash; processes that are actually running &amp;mdash; averaged over the last minute.</source>
          <target state="translated">gitwebクエリに応答する最大負荷を設定するために使用されます。サーバーの負荷がこの値を超えると、gitwebは「503 Service Unavailable」エラーを返します。gitwebが値を判別できない場合、サーバーの負荷は0になります。現在、これは &lt;code&gt;/proc/loadavg&lt;/code&gt; を使用するLinuxでのみ機能します。負荷は、システム上でアクティブなタスクの数（実際に実行されているプロセス）の数で、直前の1分間の平均です。</target>
        </trans-unit>
        <trans-unit id="184dba4369820f49a823e624aa006f74d3fc96ef" translate="yes" xml:space="preserve">
          <source>Used with --remote to specify the path to the &lt;code&gt;git-upload-archive&lt;/code&gt; on the remote side.</source>
          <target state="translated">--remoteと共に使用して、リモート側の &lt;code&gt;git-upload-archive&lt;/code&gt; へのパスを指定します。</target>
        </trans-unit>
        <trans-unit id="a985abb59dca2d23760f5b7ff00e7d00f2d0f353" translate="yes" xml:space="preserve">
          <source>Used with &lt;code&gt;--range-diff&lt;/code&gt;, tweak the heuristic which matches up commits between the previous and current series of patches by adjusting the creation/deletion cost fudge factor. See &lt;a href=&quot;git-range-diff&quot;&gt;git-range-diff[1]&lt;/a&gt;) for details.</source>
          <target state="translated">&lt;code&gt;--range-diff&lt;/code&gt; とともに使用し、作成/削除のコストファッジファクターを調整することにより、以前のパッチと現在のパッチのコミットを一致させるヒューリスティックを調整します。詳細については、&lt;a href=&quot;git-range-diff&quot;&gt;git-range-diff [1]&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="9777df5e2d0f3ca27a559e53074b9f39896040e8" translate="yes" xml:space="preserve">
          <source>Used with the &lt;code&gt;fetch&lt;/code&gt; command.</source>
          <target state="translated">&lt;code&gt;fetch&lt;/code&gt; コマンドで使用されます。</target>
        </trans-unit>
        <trans-unit id="ea99fa3d480e34606197cb808cc4a18c1d6b1306" translate="yes" xml:space="preserve">
          <source>User Manual</source>
          <target state="translated">ユーザーマニュアル</target>
        </trans-unit>
        <trans-unit id="3d338fa6790366b9708dc60a5019a8d98f73c4b3" translate="yes" xml:space="preserve">
          <source>User configuration and preferences are stored at:</source>
          <target state="translated">ユーザーの設定や設定は、次の場所に保存されます。</target>
        </trans-unit>
        <trans-unit id="ba3e3bfcde6395de2671f768450f02d32f692aba" translate="yes" xml:space="preserve">
          <source>User name (e.g., &lt;code&gt;user&lt;/code&gt; in &lt;code&gt;https://user@example.com/repo.git&lt;/code&gt;). If the config key has a user name it must match the user name in the URL exactly. If the config key does not have a user name, that config key will match a URL with any user name (including none), but at a lower precedence than a config key with a user name.</source>
          <target state="translated">ユーザー名（例えば、 &lt;code&gt;user&lt;/code&gt; で &lt;code&gt;https://user@example.com/repo.git&lt;/code&gt; ）。構成キーにユーザー名がある場合は、URLのユーザー名と正確に一致する必要があります。構成キーにユーザー名が含まれていない場合、その構成キーは任意のユーザー名（なしを含む）とURLを照合しますが、ユーザー名の構成キーよりも優先順位が低くなります。</target>
        </trans-unit>
        <trans-unit id="9eabd3862d3bc88b6d20553afdc4c28a880bd15a" translate="yes" xml:space="preserve">
          <source>User specified as an option to all p4 commands, with &lt;code&gt;-u &amp;lt;user&amp;gt;&lt;/code&gt;. The environment variable &lt;code&gt;P4USER&lt;/code&gt; can be used instead.</source>
          <target state="translated">&lt;code&gt;-u &amp;lt;user&amp;gt;&lt;/code&gt; を使用して、すべてのp4コマンドのオプションとして指定されたユーザー。代わりに、環境変数 &lt;code&gt;P4USER&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="3129c28f60cb352aa378d9055c2dee4b71cd917d" translate="yes" xml:space="preserve">
          <source>User-specific configuration file. Also called &quot;global&quot; configuration file.</source>
          <target state="translated">ユーザー固有の設定ファイル。グローバル」設定ファイルとも呼ばれます。</target>
        </trans-unit>
        <trans-unit id="53b3f2b51348a1a5a4076e004425d0d150df3f8e" translate="yes" xml:space="preserve">
          <source>User-specific credentials file.</source>
          <target state="translated">ユーザー固有の資格情報ファイル。</target>
        </trans-unit>
        <trans-unit id="fbb3c5af6a1b800cb6bfa442ae5c6ae5ee1a4454" translate="yes" xml:space="preserve">
          <source>Username for SMTP-AUTH. Default is the value of &lt;code&gt;sendemail.smtpUser&lt;/code&gt;; if a username is not specified (with &lt;code&gt;--smtp-user&lt;/code&gt; or &lt;code&gt;sendemail.smtpUser&lt;/code&gt;), then authentication is not attempted.</source>
          <target state="translated">SMTP-AUTHのユーザー名。デフォルトは &lt;code&gt;sendemail.smtpUser&lt;/code&gt; の値です。ユーザー名が指定されていない場合（ &lt;code&gt;--smtp-user&lt;/code&gt; または &lt;code&gt;sendemail.smtpUser&lt;/code&gt; を使用）、認証は試行されません。</target>
        </trans-unit>
        <trans-unit id="dd5ba62269befa999225c8d360ebd4fd64f50001" translate="yes" xml:space="preserve">
          <source>Users may select an automated merge strategy from among the following using either -s/--strategy option or configuring notes.mergeStrategy accordingly:</source>
          <target state="translated">ユーザーは、-s/--strategy オプションを使用するか、または notes.mergeStrategy を設定することで、以下の中から自動化されたマージ戦略を選択することができます。</target>
        </trans-unit>
        <trans-unit id="312954bd3f459a8154fbfda7b5edb71c57c929c2" translate="yes" xml:space="preserve">
          <source>Users migrating from CVS may also want to read &lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration[7]&lt;/a&gt;.</source>
          <target state="translated">CVSから移行するユーザーは、&lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration [7]&lt;/a&gt;を読むこともできます。</target>
        </trans-unit>
        <trans-unit id="bdfc1b01541d0790675419ccbb86b2582c7e882c" translate="yes" xml:space="preserve">
          <source>Users often try to use the assume-unchanged and skip-worktree bits to tell Git to ignore changes to files that are tracked. This does not work as expected, since Git may still check working tree files against the index when performing certain operations. In general, Git does not provide a way to ignore changes to tracked files, so alternate solutions are recommended.</source>
          <target state="translated">ユーザーはしばしば、asprime-unchanged や skip-worktree ビットを使って、追跡されているファイルへの変更を無視するように Git に指示しようとします。これは期待通りにはいきません。なぜなら、Git は特定の操作を行う際に作業ツリーファイルをインデックスと照合してしまうからです。一般的に、Git は追跡されたファイルへの変更を無視する方法を提供していません。</target>
        </trans-unit>
        <trans-unit id="d2fd200f233551c846ddc52433b7473972ba45cd" translate="yes" xml:space="preserve">
          <source>Using &amp;ldquo;assume unchanged&amp;rdquo; bit</source>
          <target state="translated">「変更しない」ビットの使用</target>
        </trans-unit>
        <trans-unit id="db59534f65c86c428a7a540c110ff1130d39acfc" translate="yes" xml:space="preserve">
          <source>Using &amp;ldquo;git add -A&amp;rdquo;</source>
          <target state="translated">「git add -A」を使用する</target>
        </trans-unit>
        <trans-unit id="3f756864c1cac8254338a14f16b7888b4cd11774" translate="yes" xml:space="preserve">
          <source>Using &amp;ldquo;git commit -a&amp;rdquo;</source>
          <target state="translated">「git commit -a」を使用する</target>
        </trans-unit>
        <trans-unit id="1ad6e2bdca2ef33d6f60d1165c40af77488df73e" translate="yes" xml:space="preserve">
          <source>Using --cacheinfo or --info-only</source>
          <target state="translated">キャッシュ情報または --info-only を使用する</target>
        </trans-unit>
        <trans-unit id="63a49bc3316ec7fe7ab1c50a106ab3c187422a12" translate="yes" xml:space="preserve">
          <source>Using --index-info</source>
          <target state="translated">インデックス情報を使う</target>
        </trans-unit>
        <trans-unit id="9465002aca9e596e405478c595d6ec82ecf19f4d" translate="yes" xml:space="preserve">
          <source>Using --recurse-submodules can only fetch new commits in already checked out submodules right now. When e.g. upstream added a new submodule in the just fetched commits of the superproject the submodule itself cannot be fetched, making it impossible to check out that submodule later without having to do a fetch again. This is expected to be fixed in a future Git version.</source>
          <target state="translated">recurse-submodules を使うと、すでにチェックアウトされているサブモジュールの新しいコミットを今すぐに取得することができます。例えば、スーパープロジェクトのコミットを取得したところで上流側が新しいサブモジュールを追加した場合、そのサブモジュール自体を取得することはできません。これは将来の Git バージョンで修正される予定です。</target>
        </trans-unit>
        <trans-unit id="9ba2b3bf5dd0ae3395bffc9a6bf30c85dfb19a1b" translate="yes" xml:space="preserve">
          <source>Using --recurse-submodules will update the content of all active submodules according to the commit recorded in the superproject by calling read-tree recursively, also setting the submodules' HEAD to be detached at that commit.</source>
          <target state="translated">recurse-submodulesを使うと、read-treeを再帰的に呼び出すことで、スーパープロジェクトに記録されたコミットに応じて、すべてのアクティブなサブモジュールの内容が更新され、そのコミットでサブモジュールのHEADが切り離されるように設定されます。</target>
        </trans-unit>
        <trans-unit id="3b6c4766d3d128d670a5d5adf42fc526da676a66" translate="yes" xml:space="preserve">
          <source>Using --recurse-submodules will update the content of all initialized submodules according to the commit recorded in the superproject by calling read-tree recursively, also setting the submodules HEAD to be detached at that commit.</source>
          <target state="translated">recurse-submodulesを使うと、read-treeを再帰的に呼び出すことで、スーパープロジェクトに記録されたコミットに応じて、すべての初期化されたサブモジュールの内容が更新され、そのコミット時にサブモジュールのHEADが切り離されるように設定されます。</target>
        </trans-unit>
        <trans-unit id="8315f077dd8f5ad49468aff013d2df68acafcb5e" translate="yes" xml:space="preserve">
          <source>Using --refresh</source>
          <target state="translated">リフレッシュを使用する</target>
        </trans-unit>
        <trans-unit id="0565ce691b52b5953c2fb97dfb806a2f764f48e2" translate="yes" xml:space="preserve">
          <source>Using --temp or --stage=all</source>
          <target state="translated">temp または --stage=all を使う</target>
        </trans-unit>
        <trans-unit id="509888a40362653e71adbbdc6d4e59bc0d3d4ce4" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;--index-filter&lt;/code&gt; with &lt;code&gt;git rm&lt;/code&gt; yields a significantly faster version. Like with using &lt;code&gt;rm filename&lt;/code&gt;, &lt;code&gt;git rm --cached filename&lt;/code&gt; will fail if the file is absent from the tree of a commit. If you want to &quot;completely forget&quot; a file, it does not matter when it entered history, so we also add &lt;code&gt;--ignore-unmatch&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;git rm&lt;/code&gt; で &lt;code&gt;--index-filter&lt;/code&gt; を使用すると、非常に高速なバージョンが生成されます。 &lt;code&gt;rm filename&lt;/code&gt; を使用する場合と同様に、ファイルがコミットのツリーにない場合、 &lt;code&gt;git rm --cached filename&lt;/code&gt; は失敗します。ファイルを「完全に忘れる」場合は、いつ履歴に入ったかは関係ないため、 &lt;code&gt;--ignore-unmatch&lt;/code&gt; も追加します。</target>
        </trans-unit>
        <trans-unit id="802dbfe4495f98c59f087035f936edebe365e8d7" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;--recurse-submodules&lt;/code&gt; will update the content of all active submodules according to the commit recorded in the superproject. If local modifications in a submodule would be overwritten the checkout will fail unless &lt;code&gt;-f&lt;/code&gt; is used. If nothing (or &lt;code&gt;--no-recurse-submodules&lt;/code&gt;) is used, submodules working trees will not be updated. Just like &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt;, this will detach &lt;code&gt;HEAD&lt;/code&gt; of the submodule.</source>
          <target state="translated">&lt;code&gt;--recurse-submodules&lt;/code&gt; を使用すると、スーパープロジェクトに記録されたコミットに従って、すべてのアクティブなサブモジュールのコンテンツが更新されます。サブモジュールのローカル変更が上書きされる場合、 &lt;code&gt;-f&lt;/code&gt; を使用しない限り、チェックアウトは失敗します。何も使用されていない場合（または &lt;code&gt;--no-recurse-submodules&lt;/code&gt; ）、サブモジュールの作業ツリーは更新されません。同じよう&lt;a href=&quot;git-submodule&quot;&gt;にgit-サブモジュール[1] &lt;/a&gt;、これは切り離します &lt;code&gt;HEAD&lt;/code&gt; サブモジュールのを。</target>
        </trans-unit>
        <trans-unit id="bf5da0d2a32c5b7048069200ef431cff7653b1d4" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;--recurse-submodules&lt;/code&gt; will update the content of all active submodules according to the commit recorded in the superproject. If nothing (or &lt;code&gt;--no-recurse-submodules&lt;/code&gt;) is used, submodules working trees will not be updated. Just like &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt;, this will detach &lt;code&gt;HEAD&lt;/code&gt; of the submodules.</source>
          <target state="translated">&lt;code&gt;--recurse-submodules&lt;/code&gt; を使用すると、スーパープロジェクトに記録されたコミットに従って、すべてのアクティブなサブモジュールのコンテンツが更新されます。何も使用されていない場合（または &lt;code&gt;--no-recurse-submodules&lt;/code&gt; ）、サブモジュールの作業ツリーは更新されません。同じよう&lt;a href=&quot;git-submodule&quot;&gt;にgit-サブモジュール[1] &lt;/a&gt;、これは切り離します &lt;code&gt;HEAD&lt;/code&gt; サブモジュールのを。</target>
        </trans-unit>
        <trans-unit id="47e7ecf39552b28db7a0c771cb5239db7d4a81af" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;--recurse-submodules&lt;/code&gt; will update the content of all initialized submodules according to the commit recorded in the superproject. If local modifications in a submodule would be overwritten the checkout will fail unless &lt;code&gt;-f&lt;/code&gt; is used. If nothing (or &lt;code&gt;--no-recurse-submodules&lt;/code&gt;) is used, the work trees of submodules will not be updated. Just like &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt;, this will detach &lt;code&gt;HEAD&lt;/code&gt; of the submodule.</source>
          <target state="translated">&lt;code&gt;--recurse-submodules&lt;/code&gt; を使用すると、スーパープロジェクトに記録されたコミットに従って、初期化されたすべてのサブモジュールのコンテンツが更新されます。サブモジュールのローカル変更が上書きされる場合、 &lt;code&gt;-f&lt;/code&gt; を使用しないとチェックアウトは失敗します。何も使用しない場合（または &lt;code&gt;--no-recurse-submodules&lt;/code&gt; ）、サブモジュールの作業ツリーは更新されません。同じよう&lt;a href=&quot;git-submodule&quot;&gt;にgit-サブモジュール[1] &lt;/a&gt;、これは切り離します &lt;code&gt;HEAD&lt;/code&gt; サブモジュールのを。</target>
        </trans-unit>
        <trans-unit id="87e05fa35b92ebd2beac592a4000f99e52c8fa99" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;--recurse-submodules&lt;/code&gt; will update the content of all initialized submodules according to the commit recorded in the superproject. If nothing (or &lt;code&gt;--no-recurse-submodules&lt;/code&gt;) is used, the work trees of submodules will not be updated. Just like &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt;, this will detach &lt;code&gt;HEAD&lt;/code&gt; of the submodules.</source>
          <target state="translated">&lt;code&gt;--recurse-submodules&lt;/code&gt; を使用すると、スーパープロジェクトに記録されたコミットに従って、初期化されたすべてのサブモジュールのコンテンツが更新されます。何も使用しない場合（または &lt;code&gt;--no-recurse-submodules&lt;/code&gt; ）、サブモジュールの作業ツリーは更新されません。同じよう&lt;a href=&quot;git-submodule&quot;&gt;にgit-サブモジュール[1] &lt;/a&gt;、これは切り離します &lt;code&gt;HEAD&lt;/code&gt; サブモジュールのを。</target>
        </trans-unit>
        <trans-unit id="131907fc18369579f75831dbffd3a45262caaa68" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;-a&lt;/code&gt; would conflate &amp;lt;remote&amp;gt; with any local branches you happen to have been prefixed with the same &amp;lt;remote&amp;gt; pattern.</source>
          <target state="translated">&lt;code&gt;-a&lt;/code&gt; を使用すると、&amp;lt;remote&amp;gt;に、同じ&amp;lt;remote&amp;gt;パターンが前に付けられたローカルブランチが混同されます。</target>
        </trans-unit>
        <trans-unit id="bc196497d8f80228e3ec0969c92ba077224b9158" translate="yes" xml:space="preserve">
          <source>Using &lt;em&gt;git checkout-index&lt;/em&gt; to &quot;export an entire tree&quot;</source>
          <target state="translated">&lt;em&gt;git checkout-index&lt;/em&gt;を使用して「ツリー全体をエクスポートする」</target>
        </trans-unit>
        <trans-unit id="bb5a1594f36aa9f526f3a0391e9aecb18bcb1ed6" translate="yes" xml:space="preserve">
          <source>Using Gmail&amp;rsquo;s IMAP interface:</source>
          <target state="translated">GmailのIMAPインターフェースの使用：</target>
        </trans-unit>
        <trans-unit id="f145740948f023493614f8cb28fc352a33b08d80" translate="yes" xml:space="preserve">
          <source>Using a limit</source>
          <target state="translated">制限を使用する</target>
        </trans-unit>
        <trans-unit id="0d18e7415acaf5bf1693b96116e4340271619597" translate="yes" xml:space="preserve">
          <source>Using another project while maintaining independent history. Submodules allow you to contain the working tree of another project within your own working tree while keeping the history of both projects separate. Also, since submodules are fixed to an arbitrary version, the other project can be independently developed without affecting the superproject, allowing the superproject project to fix itself to new versions only when desired.</source>
          <target state="translated">独立した履歴を維持しながら別のプロジェクトを使う サブモジュールを使うことで、両方のプロジェクトの履歴を別々に保ちながら、別のプロジェクトの作業ツリーを自分の作業ツリーの中に入れることができます。また、サブモジュールは任意のバージョンに固定されるため、スーパープロジェクトに影響を与えずに他のプロジェクトを独立して開発することができ、スーパープロジェクトのプロジェクトは必要なときだけ新しいバージョンに固定することができます。</target>
        </trans-unit>
        <trans-unit id="03266ad998c58f3651e774794904a59499884e04" translate="yes" xml:space="preserve">
          <source>Using complex scripts</source>
          <target state="translated">複雑なスクリプトの使用</target>
        </trans-unit>
        <trans-unit id="9a4e17fa716627d801ba04248e7c13675c63f6bf" translate="yes" xml:space="preserve">
          <source>Using direct mode with SSL:</source>
          <target state="translated">SSLでダイレクトモードを使用しています。</target>
        </trans-unit>
        <trans-unit id="80be60b71aa62e009a5472e7b71ecca69fb605f2" translate="yes" xml:space="preserve">
          <source>Using direct mode:</source>
          <target state="translated">ダイレクトモードを使用しています。</target>
        </trans-unit>
        <trans-unit id="1c1bc19943239ea53498134ee5024657c6f7482f" translate="yes" xml:space="preserve">
          <source>Using git for collaboration</source>
          <target state="translated">git を使った共同作業</target>
        </trans-unit>
        <trans-unit id="e742dd237e897f0c09d1168ed38eeca1316d409b" translate="yes" xml:space="preserve">
          <source>Using interactive rebases</source>
          <target state="translated">インタラクティブなリベースの使用</target>
        </trans-unit>
        <trans-unit id="16c9cb76d4ea0981714eee54828fc3305174e2d5" translate="yes" xml:space="preserve">
          <source>Using macro attributes</source>
          <target state="translated">マクロ属性の使用</target>
        </trans-unit>
        <trans-unit id="0bcad514939a1a512d30defc1dd83a6988408bd1" translate="yes" xml:space="preserve">
          <source>Using more options generally further limits the output (e.g. &lt;code&gt;--since=&amp;lt;date1&amp;gt;&lt;/code&gt; limits to commits newer than &lt;code&gt;&amp;lt;date1&amp;gt;&lt;/code&gt;, and using it with &lt;code&gt;--grep=&amp;lt;pattern&amp;gt;&lt;/code&gt; further limits to commits whose log message has a line that matches &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt;), unless otherwise noted.</source>
          <target state="translated">より多くのオプションを一般的にさらなる制限を使用して出力（例えば &lt;code&gt;--since=&amp;lt;date1&amp;gt;&lt;/code&gt; より新しいコミットに制限 &lt;code&gt;&amp;lt;date1&amp;gt;&lt;/code&gt; ととそれを用いた &lt;code&gt;--grep=&amp;lt;pattern&amp;gt;&lt;/code&gt; ログメッセージコミットに対するさらなる制限が一致していることラインを有します &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; ）（特に明記しない限り）。</target>
        </trans-unit>
        <trans-unit id="aab9e25047cbd960c71a3d6743c695a0fbcee99d" translate="yes" xml:space="preserve">
          <source>Using refspecs explicitly:</source>
          <target state="translated">refspecsを明示的に使用する。</target>
        </trans-unit>
        <trans-unit id="e240eb205361a2a50754a2cbbad5230917e3c8f6" translate="yes" xml:space="preserve">
          <source>Using test suites and git bisect together</source>
          <target state="translated">テストスイートとgitを二分して使う</target>
        </trans-unit>
        <trans-unit id="8fdfb0e1e33426ffa586ab6e967bc34118a45d25" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;--submodule=log&lt;/code&gt; option with &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; will provide that information too.</source>
          <target state="translated">&lt;a href=&quot;git-diff&quot;&gt;git-diff [1]で&lt;/a&gt; &lt;code&gt;--submodule=log&lt;/code&gt; オプションを使用すると、その情報も提供されます。</target>
        </trans-unit>
        <trans-unit id="d42f8d8f39d5c1ce54e65e242137998175012054" translate="yes" xml:space="preserve">
          <source>Using these options, &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt; will act similar to the more specialized family of commit log tools: &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt;, and &lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged[1]&lt;/a&gt;</source>
          <target state="translated">これらのオプションを使用すると、&lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list [1]&lt;/a&gt;は、コミットログツールのより専門的なファミリである&lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt;、&lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt;、および&lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged [1]と同様に機能します。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a34d360db274a11502bc402ef7758f2bc5adf11b" translate="yes" xml:space="preserve">
          <source>Using this helper will store your passwords unencrypted on disk, protected only by filesystem permissions. If this is not an acceptable security tradeoff, try &lt;a href=&quot;git-credential-cache&quot;&gt;git-credential-cache[1]&lt;/a&gt;, or find a helper that integrates with secure storage provided by your operating system.</source>
          <target state="translated">このヘルパーを使用すると、パスワードが暗号化されずにディスクに保存され、ファイルシステムのアクセス許可によってのみ保護されます。これが許容できるセキュリティのトレードオフではない場合は、&lt;a href=&quot;git-credential-cache&quot;&gt;git-credential-cache [1]を&lt;/a&gt;試すか、オペレーティングシステムが提供する安全なストレージと統合するヘルパーを見つけてください。</target>
        </trans-unit>
        <trans-unit id="86d0ca06bdb5a3aacec696a9b10115a302a90ea4" translate="yes" xml:space="preserve">
          <source>Using this hook, it is easy to generate mails describing the updates to the repository. This example script sends one mail message per ref listing the commits pushed to the repository, and logs the push certificates of signed pushes with good signatures to a logger service:</source>
          <target state="translated">このフックを使えば、リポジトリへの更新を記述するメールを簡単に生成できます。このスクリプトの例では、リポジトリにプッシュされたコミットをリストアップしたメールメッセージを ref ごとに送信し、署名されたプッシュのプッシュ証明書をロガーサービスに記録しています。</target>
        </trans-unit>
        <trans-unit id="7ae98ad0643543d139a0ccded2d96be6c57e816c" translate="yes" xml:space="preserve">
          <source>Using this option for any other purpose (don&amp;rsquo;t ask) is very strongly discouraged.</source>
          <target state="translated">このオプションを他の目的で使用しないでください（質問しないでください）。</target>
        </trans-unit>
        <trans-unit id="ebe89d9e15d8a582f6b4a48c6c03d60cf9c673f1" translate="yes" xml:space="preserve">
          <source>Using tunnel mode:</source>
          <target state="translated">トンネルモードを使用しています。</target>
        </trans-unit>
        <trans-unit id="f17a1449e9ed80dcff59f550977b6693d42b10bf" translate="yes" xml:space="preserve">
          <source>Usual 3-way file level merge for text files. Conflicted regions are marked with conflict markers &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;=======&lt;/code&gt; and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;. The version from your branch appears before the &lt;code&gt;=======&lt;/code&gt; marker, and the version from the merged branch appears after the &lt;code&gt;=======&lt;/code&gt; marker.</source>
          <target state="translated">テキストファイルの通常の3方向ファイルレベルマージ。競合の領域が衝突マーカでマークされている &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; 、 &lt;code&gt;=======&lt;/code&gt; そして &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 。ブランチのバージョンは &lt;code&gt;=======&lt;/code&gt; マーカーの前に表示され、マージされたブランチのバージョンは &lt;code&gt;=======&lt;/code&gt; マーカーの後に表示されます。</target>
        </trans-unit>
        <trans-unit id="6cb51fab051882aaba81e0715d7acfa80e2ce09c" translate="yes" xml:space="preserve">
          <source>Usually &lt;code&gt;git gc&lt;/code&gt; runs very quickly while providing good disk space utilization and performance. This option will cause &lt;code&gt;git gc&lt;/code&gt; to more aggressively optimize the repository at the expense of taking much more time. The effects of this optimization are mostly persistent. See the &quot;AGGRESSIVE&quot; section below for details.</source>
          <target state="translated">通常、 &lt;code&gt;git gc&lt;/code&gt; は非常に高速に実行されますが、ディスク領域の使用率とパフォーマンスは良好です。このオプションを使用すると、 &lt;code&gt;git gc&lt;/code&gt; はリポジトリをより積極的に最適化しますが、はるかに時間がかかります。この最適化の効果はほとんど永続的です。詳細については、以下の「積極的」セクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="da9e2cbf852524ee1edb371514af799c05f82c93" translate="yes" xml:space="preserve">
          <source>Usually a merge requires the index file as well as the files in the working tree to be up to date with the current head commit, in order not to lose local changes. This flag disables the check with the working tree and is meant to be used when creating a merge of trees that are not directly related to the current working tree status into a temporary index file.</source>
          <target state="translated">通常、マージでは、ローカルでの変更を失わないようにするために、作業ツリー内のファイルだけでなくインデックスファイルも現在のヘッドコミットで最新の状態にしておく必要があります。このフラグは、作業ツリーのチェックを無効にし、現在の作業ツリーの状態に直接関係のないツリーを一時的なインデックスファイルにマージする際に使用します。</target>
        </trans-unit>
        <trans-unit id="27214bb5573e76f1f8a1f21396536681c10927d6" translate="yes" xml:space="preserve">
          <source>Usually a three-way merge by &lt;code&gt;git read-tree&lt;/code&gt; resolves the merge for really trivial cases and leaves other cases unresolved in the index, so that porcelains can implement different merge policies. This flag makes the command resolve a few more cases internally:</source>
          <target state="translated">通常、 &lt;code&gt;git read-tree&lt;/code&gt; による3者間マージは、ほんの些細なケースのマージを解決し、他のケースはインデックスに未解決のままにするため、磁器が異なるマージポリシーを実装できます。このフラグにより​​、コマンドは内部でさらにいくつかのケースを解決します。</target>
        </trans-unit>
        <trans-unit id="1a018c180f83561166ef04fc1c1b049dd7bef5e3" translate="yes" xml:space="preserve">
          <source>Usually given &quot;&amp;lt;feature&amp;gt;&quot; is configurable via the &lt;code&gt;gitweb.&amp;lt;feature&amp;gt;&lt;/code&gt; config variable in the per-repository Git configuration file.</source>
          <target state="translated">通常、「&amp;lt;feature&amp;gt;」を指定すると、リポジトリごとのGit構成ファイルの &lt;code&gt;gitweb.&amp;lt;feature&amp;gt;&lt;/code&gt; 構成変数を介して構成できます。</target>
        </trans-unit>
        <trans-unit id="06bd62b74600c2b58fc5390378d7102461c2b477" translate="yes" xml:space="preserve">
          <source>Usually it is easier to configure any desired options through your personal &lt;code&gt;.ssh/config&lt;/code&gt; file. Please consult your ssh documentation for further details.</source>
          <target state="translated">通常、個人の &lt;code&gt;.ssh/config&lt;/code&gt; ファイルを使用して、必要なオプションを構成する方が簡単です。詳細については、sshのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="e92c22e35ceb9b2c8da5295a992718e30d5c9f60" translate="yes" xml:space="preserve">
          <source>Usually recording a commit that has the exact same tree as its sole parent commit is a mistake, and the command prevents you from making such a commit. This option bypasses the safety, and is primarily for use by foreign SCM interface scripts.</source>
          <target state="translated">通常、唯一の親コミットと全く同じツリーを持つコミットを記録することは間違いであり、このコマンドはそのようなコミットを行わないようにします。このオプションは安全性をバイパスし、主に外国の SCM インタフェーススクリプトで使用します。</target>
        </trans-unit>
        <trans-unit id="8ce3f0d516dc2a9d67b8e4ba143055eaf7bab452" translate="yes" xml:space="preserve">
          <source>Usually the command automatically creates a sequence of commits. This flag applies the changes necessary to cherry-pick each named commit to your working tree and the index, without making any commit. In addition, when this option is used, your index does not have to match the HEAD commit. The cherry-pick is done against the beginning state of your index.</source>
          <target state="translated">通常、コマンドは自動的に一連のコミットを作成します。このフラグは、コミットを行わずに、作業ツリーとインデックスにそれぞれの名前のついたコミットをチェリーピックするために必要な変更を適用します。さらに、このオプションが使用された場合、インデックスは HEAD コミットと一致する必要はありません。チェリーピックはインデックスの先頭の状態に対して行われます。</target>
        </trans-unit>
        <trans-unit id="55875ee1e78ad1cfc5a25d1e098bc17781327203" translate="yes" xml:space="preserve">
          <source>Usually the command automatically creates some commits with commit log messages stating which commits were reverted. This flag applies the changes necessary to revert the named commits to your working tree and the index, but does not make the commits. In addition, when this option is used, your index does not have to match the HEAD commit. The revert is done against the beginning state of your index.</source>
          <target state="translated">通常、このコマンドは、どのコミットが元に戻されたかを示すコミットログメッセージとともに、いくつかのコミットを自動的に作成します。このフラグは、指定されたコミットを作業ツリーとインデックスに戻すために必要な変更を適用しますが、コミットは行いません。さらに、このオプションを使用した場合、インデックスは HEAD コミットと一致する必要はありません。復帰はインデックスの先頭の状態に対して行われます。</target>
        </trans-unit>
        <trans-unit id="51d5f6e8faedb5ef4d1204f14e2f7ab2d7b77eaf" translate="yes" xml:space="preserve">
          <source>Usually the command stops output upon showing the commit that is the common ancestor of all the branches. This flag tells the command to go &amp;lt;n&amp;gt; more common commits beyond that. When &amp;lt;n&amp;gt; is negative, display only the &amp;lt;reference&amp;gt;s given, without showing the commit ancestry tree.</source>
          <target state="translated">通常、コマンドは、すべてのブランチの共通の祖先であるコミットを表示すると出力を停止します。このフラグは、コマンドに&amp;lt;n&amp;gt;より多くの一般的なコミットを実行するように指示します。&amp;lt;n&amp;gt;が負の場合、指定された&amp;lt;reference&amp;gt;のみを表示し、コミットの祖先ツリーは表示しません。</target>
        </trans-unit>
        <trans-unit id="29097abe7ecd686605680556737a55dc5b7468af" translate="yes" xml:space="preserve">
          <source>Usually the object names are output in SHA-1 form (with possible &lt;code&gt;^&lt;/code&gt; prefix); this option makes them output in a form as close to the original input as possible.</source>
          <target state="translated">通常、オブジェクト名はSHA-1形式（可能な &lt;code&gt;^&lt;/code&gt; プレフィックス付き）で出力されます。このオプションは、可能な限り元の入力に近い形式で出力します。</target>
        </trans-unit>
        <trans-unit id="576f849692364345fa924f476c3413707294c315" translate="yes" xml:space="preserve">
          <source>Usually the output is made one line per flag and parameter. This option makes output a single line, properly quoted for consumption by shell. Useful when you expect your parameter to contain whitespaces and newlines (e.g. when using pickaxe &lt;code&gt;-S&lt;/code&gt; with &lt;code&gt;git diff-*&lt;/code&gt;). In contrast to the &lt;code&gt;--sq-quote&lt;/code&gt; option, the command input is still interpreted as usual.</source>
          <target state="translated">通常、出力はフラグとパラメータごとに1行になります。このオプションは、シェルによる消費のために適切に引用された出力を1行にします。パラメータに空白や改行が含まれることが予想される場合に便利です（たとえば、 &lt;code&gt;git diff-*&lt;/code&gt; で pickaxe &lt;code&gt;-S&lt;/code&gt; を使用する場合）。 &lt;code&gt;--sq-quote&lt;/code&gt; オプションとは対照的に、コマンド入力は通常どおり解釈されます。</target>
        </trans-unit>
        <trans-unit id="52303fe63fddea8a07d49fe1df917ff950ba6541" translate="yes" xml:space="preserve">
          <source>Usually the program removes email cruft from the Subject: header line to extract the title line for the commit log message. This option prevents this munging, and is most useful when used to read back &lt;code&gt;git format-patch -k&lt;/code&gt; output.</source>
          <target state="translated">通常、プログラムはSubject：ヘッダー行から電子メールの残骸を削除して、コミットログメッセージのタイトル行を抽出します。このオプションはこの変更を防ぎ、 &lt;code&gt;git format-patch -k&lt;/code&gt; の出力を読み取るために使用する場合に最も役立ちます。</target>
        </trans-unit>
        <trans-unit id="12904fba6e8c31d350b5463557502fba670802b3" translate="yes" xml:space="preserve">
          <source>Usually you cannot cherry-pick a merge because you do not know which side of the merge should be considered the mainline. This option specifies the parent number (starting from 1) of the mainline and allows cherry-pick to replay the change relative to the specified parent.</source>
          <target state="translated">マージのどちらをメインラインとみなすべきかがわからないので、通常はチェリーピックはできません。このオプションは、メインラインの親番号 (1 から始まる)を指定し、チェリーピックで指定した親からの相対的な変更を再生することができます。</target>
        </trans-unit>
        <trans-unit id="8ec09d5ac366ce3cd2a5e3c6c67d0b4fe311e4bf" translate="yes" xml:space="preserve">
          <source>Usually you cannot revert a merge because you do not know which side of the merge should be considered the mainline. This option specifies the parent number (starting from 1) of the mainline and allows revert to reverse the change relative to the specified parent.</source>
          <target state="translated">通常、マージのどちら側をメインラインと見なすべきかがわからないため、マージを元に戻すことはできません。このオプションは、メインラインの親番号 (1 から始まる)を指定し、指定した親からの相対的な変更を元に戻すことができます。</target>
        </trans-unit>
        <trans-unit id="6969d1a350dfc3fafb277e2e6995e5ac7a289ac5" translate="yes" xml:space="preserve">
          <source>Usually you should not need to change (adjust) any of configuration variables described below; they should be automatically set by gitweb to correct value.</source>
          <target state="translated">通常は、以下に説明する設定変数を変更 (調整)する必要はありません。</target>
        </trans-unit>
        <trans-unit id="b172c85defacdb686b541793ef9e8aeee0cdf60e" translate="yes" xml:space="preserve">
          <source>Usually you would want to use &lt;code&gt;git fetch&lt;/code&gt;, which is a higher level wrapper of this command, instead.</source>
          <target state="translated">通常は、代わりに、このコマンドの上位レベルのラッパーである &lt;code&gt;git fetch&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="bec645de31c299cb10f93b6253e1e1669a5f0a31" translate="yes" xml:space="preserve">
          <source>Usually you would want to use &lt;code&gt;git push&lt;/code&gt;, which is a higher-level wrapper of this command, instead. See &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;.</source>
          <target state="translated">通常、代わりに、このコマンドの上位レベルのラッパーである &lt;code&gt;git push&lt;/code&gt; を使用します。&lt;a href=&quot;git-push&quot;&gt;git-push [1]を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="5982263578e4f00875c00a40da810fe92911cebc" translate="yes" xml:space="preserve">
          <source>Usually, &quot;git push&quot; refuses to update a remote ref that is not an ancestor of the local ref used to overwrite it.</source>
          <target state="translated">通常、&quot;git push&quot; は、上書きに使用したローカル ref の祖先ではないリモート ref の更新を拒否します。</target>
        </trans-unit>
        <trans-unit id="f8497b6ab754b20f8d36f9efb8dfea581706bc5d" translate="yes" xml:space="preserve">
          <source>Usually, dangling blobs and trees aren&amp;rsquo;t very interesting. They&amp;rsquo;re almost always the result of either being a half-way mergebase (the blob will often even have the conflict markers from a merge in it, if you have had conflicting merges that you fixed up by hand), or simply because you interrupted a &lt;code&gt;git fetch&lt;/code&gt; with ^C or something like that, leaving &lt;code&gt;some&lt;/code&gt; of the new objects in the object database, but just dangling and useless.</source>
          <target state="translated">通常、ぶら下がっているブロブとツリーはあまり面白くありません。それらはほとんどの場合、途中のマージベースである（手動で修正した競合するマージがあった場合、ブロブにはマージからの競合マーカーが含まれることもある）か、単に中断したために発生します。 &lt;code&gt;git fetch&lt;/code&gt; 残し、^ Cまたはそのようなもので &lt;code&gt;some&lt;/code&gt; オブジェクトデータベースに新しいオブジェクトのを、ちょうどダングリングと役に立ちません。</target>
        </trans-unit>
        <trans-unit id="ebecb811fcb50ea2c9e80ad196b73df5b02ee5fc" translate="yes" xml:space="preserve">
          <source>Usually, the command refuses to update a remote ref that is not an ancestor of the local ref used to overwrite it. Also, when &lt;code&gt;--force-with-lease&lt;/code&gt; option is used, the command refuses to update a remote ref whose current value does not match what is expected.</source>
          <target state="translated">通常、コマンドは、それを上書きするために使用されたローカル参照の祖先ではないリモート参照の更新を拒否します。また、 &lt;code&gt;--force-with-lease&lt;/code&gt; オプションが使用されている場合、コマンドは、現在の値が予期されるものと一致しないリモート参照の更新を拒否します。</target>
        </trans-unit>
        <trans-unit id="1039e5d0aca0474d85bb0cc56a14c21769cd56ed" translate="yes" xml:space="preserve">
          <source>Usually, the command refuses to update a remote ref that is not an ancestor of the local ref used to overwrite it. This flag disables the check. What this means is that the remote repository can lose commits; use it with care.</source>
          <target state="translated">通常、コマンドは、上書きに使用されたローカル ref の祖先ではないリモート ref の更新を拒否します。このフラグはチェックを無効にします。これが意味するのは、リモートリポジトリがコミットを失う可能性があるということです;注意して使用してください。</target>
        </trans-unit>
        <trans-unit id="b573cab97a4c7ff4e65c78f089627a289eeb14b6" translate="yes" xml:space="preserve">
          <source>Valid &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt;'s include:</source>
          <target state="translated">有効な &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt; には以下が含まれます：</target>
        </trans-unit>
        <trans-unit id="2f441e23dc9e42a84676feea9743dbd62f2c9b12" translate="yes" xml:space="preserve">
          <source>Valid object types are:</source>
          <target state="translated">有効なオブジェクトタイプは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="9b5bd1c32c0119d43f13ecb3f634510bb032afd7" translate="yes" xml:space="preserve">
          <source>Validate packed Git archive files</source>
          <target state="translated">パックされた Git アーカイブファイルの検証</target>
        </trans-unit>
        <trans-unit id="c95efe4a20b3c90ba09bca423cb347dacda4f997" translate="yes" xml:space="preserve">
          <source>Validates the GPG signature created by &lt;code&gt;git commit -S&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git commit -S&lt;/code&gt; によって作成されたGPG署名を検証します。</target>
        </trans-unit>
        <trans-unit id="ee833db09826b15f6656c228fc09101a4d262c96" translate="yes" xml:space="preserve">
          <source>Validates the gpg signature created by &lt;code&gt;git tag&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git tag&lt;/code&gt; 作成されたgpg署名を検証します。</target>
        </trans-unit>
        <trans-unit id="b1564f6b1512cbfa3cfcebc9a5badb6b239954f1" translate="yes" xml:space="preserve">
          <source>Values</source>
          <target state="translated">Values</target>
        </trans-unit>
        <trans-unit id="38ecbfb58a1b4075db82e349628396bb680485d8" translate="yes" xml:space="preserve">
          <source>Values for other tools can be used if there is a corresponding &lt;code&gt;man.&amp;lt;tool&amp;gt;.cmd&lt;/code&gt; configuration entry (see below).</source>
          <target state="translated">対応する &lt;code&gt;man.&amp;lt;tool&amp;gt;.cmd&lt;/code&gt; 構成エントリがある場合は、他のツールの値を使用できます（以下を参照）。</target>
        </trans-unit>
        <trans-unit id="4590af9796b7774b94529a47844bbbd8cd70381f" translate="yes" xml:space="preserve">
          <source>Values obtained in later configuration files override values obtained earlier in the above sequence.</source>
          <target state="translated">後の設定ファイルで取得した値は、上記のシーケンスで以前に取得した値を上書きします。</target>
        </trans-unit>
        <trans-unit id="42a2c91c112ab20fb86d229e79049c16aac8f47b" translate="yes" xml:space="preserve">
          <source>Values of many variables are treated as a simple string, but there are variables that take values of specific types and there are rules as to how to spell them.</source>
          <target state="translated">多くの変数の値は単純な文字列として扱われますが、特定の型の値を取る変数があり、それをどのように綴るかというルールがあります。</target>
        </trans-unit>
        <trans-unit id="af6a117cf9cae5d8127a5c83e908e26e4094605c" translate="yes" xml:space="preserve">
          <source>Variable substitution</source>
          <target state="translated">変数の置換</target>
        </trans-unit>
        <trans-unit id="ac018db1f7b00972061adff843d37497d8ee153c" translate="yes" xml:space="preserve">
          <source>Variables</source>
          <target state="translated">Variables</target>
        </trans-unit>
        <trans-unit id="36ae09eeb0daa8ef3fa73e86b507f064c6f1150e" translate="yes" xml:space="preserve">
          <source>Various Git commands use the following environment variables:</source>
          <target state="translated">さまざまな Git コマンドでは、以下の環境変数を使用します。</target>
        </trans-unit>
        <trans-unit id="c808db304a88e67e4d99602bde96a3fd73a86c36" translate="yes" xml:space="preserve">
          <source>Various aspects of gitweb&amp;rsquo;s behavior can be controlled through the configuration file &lt;code&gt;gitweb_config.perl&lt;/code&gt; or &lt;code&gt;/etc/gitweb.conf&lt;/code&gt;. See the &lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf[5]&lt;/a&gt; for details.</source>
          <target state="translated">gitwebの動作のさまざまな側面は​​、構成ファイル &lt;code&gt;gitweb_config.perl&lt;/code&gt; または &lt;code&gt;/etc/gitweb.conf&lt;/code&gt; を使用して制御できます。詳細については、&lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf [5]&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="514c3adc237433a43f04caf698ef6f51638f8f03" translate="yes" xml:space="preserve">
          <source>Various commands read from the configuration file and adjust their operation accordingly. See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for a list and more details about the configuration mechanism.</source>
          <target state="translated">さまざまなコマンドが構成ファイルから読み取られ、それに応じて操作が調整されます。参照&lt;a href=&quot;git-config&quot;&gt;のgit-config設定[1]&lt;/a&gt;リストおよび設定メカニズムの詳細については。</target>
        </trans-unit>
        <trans-unit id="9d741cda072f8e825584f9d44fb913d01a1b3645" translate="yes" xml:space="preserve">
          <source>Various values from structured fields in referenced objects can be used to interpolate into the resulting output, or as sort keys.</source>
          <target state="translated">参照オブジェクト内の構造化されたフィールドからの様々な値を、結果の出力への補間や、ソートキーとして使用することができます。</target>
        </trans-unit>
        <trans-unit id="0e52597805b02b27bbf6fa8afb053d38cd1cf9a2" translate="yes" xml:space="preserve">
          <source>Various ways to check your working tree</source>
          <target state="translated">作業木のチェック方法いろいろ</target>
        </trans-unit>
        <trans-unit id="8a8830ff167eaa3505bc00fdd4111ea514743436" translate="yes" xml:space="preserve">
          <source>Verbose output.</source>
          <target state="translated">曖昧な出力。</target>
        </trans-unit>
        <trans-unit id="5e80e8afa8277ee05efe0825f2f72b290ab38b7f" translate="yes" xml:space="preserve">
          <source>Verbose.</source>
          <target state="translated">Verbose.</target>
        </trans-unit>
        <trans-unit id="1eee329978eae57e0140879a7cb5a19a8e448f4c" translate="yes" xml:space="preserve">
          <source>Verbosely display information about the searching strategy being employed to standard error. The tag name will still be printed to standard out.</source>
          <target state="translated">採用されている検索方法の情報を標準誤差になるように曖昧に表示します。タグ名は標準出力されます。</target>
        </trans-unit>
        <trans-unit id="17eca013b0d71c76732d4067f559197bffc5dc5a" translate="yes" xml:space="preserve">
          <source>Verbosity: let &lt;code&gt;cvsimport&lt;/code&gt; report what it is doing.</source>
          <target state="translated">冗長性： &lt;code&gt;cvsimport&lt;/code&gt; に実行内容を報告させます。</target>
        </trans-unit>
        <trans-unit id="43241483b8c2e2b351480246076bc9d9d3aeeb38" translate="yes" xml:space="preserve">
          <source>Verifies the connectivity and validity of the objects in the database</source>
          <target state="translated">データベース内のオブジェクトの接続性と有効性を検証します。</target>
        </trans-unit>
        <trans-unit id="083f6e6fa7581860cb22a12637eec790f2c234d9" translate="yes" xml:space="preserve">
          <source>Verifies the connectivity and validity of the objects in the database.</source>
          <target state="translated">データベース内のオブジェクトの接続性と有効性を検証します。</target>
        </trans-unit>
        <trans-unit id="6f20b572e11a287b2200fc3c18b3124b41ee5e40" translate="yes" xml:space="preserve">
          <source>Verify &amp;lt;ref&amp;gt; against &amp;lt;oldvalue&amp;gt; but do not change it. If &amp;lt;oldvalue&amp;gt; is zero or missing, the ref must not exist.</source>
          <target state="translated">&amp;lt;ref&amp;gt;を&amp;lt;oldvalue&amp;gt;と照合しますが、変更しないでください。&amp;lt;oldvalue&amp;gt;がゼロまたは欠落している場合、参照は存在してはなりません。</target>
        </trans-unit>
        <trans-unit id="121ce6e2fb35359b4c456b6cab91a3389a1154d2" translate="yes" xml:space="preserve">
          <source>Verify &amp;lt;ref&amp;gt; against &amp;lt;oldvalue&amp;gt; but do not change it. If &amp;lt;oldvalue&amp;gt; zero or missing, the ref must not exist.</source>
          <target state="translated">&amp;lt;oldvalue&amp;gt;に対して&amp;lt;ref&amp;gt;を確認しますが、変更しないでください。&amp;lt;oldvalue&amp;gt;がゼロまたは欠落している場合、参照は存在してはなりません。</target>
        </trans-unit>
        <trans-unit id="f2a6ea4dcf4e13700439c2c62eb9c887c3645654" translate="yes" xml:space="preserve">
          <source>Verify that everything reachable from target is fetched. Used after an earlier fetch is interrupted.</source>
          <target state="translated">ターゲットから到達可能なすべてのものがフェッチされていることを確認します。以前のフェッチが中断された後に使用されます。</target>
        </trans-unit>
        <trans-unit id="dc19dfe6277cd8889c0ce32fc30714a767c456fd" translate="yes" xml:space="preserve">
          <source>Verify that exactly one parameter is provided, and that it can be turned into a raw 20-byte SHA-1 that can be used to access the object database. If so, emit it to the standard output; otherwise, error out.</source>
          <target state="translated">正確に1つのパラメータが提供され、それがオブジェクト・データベースにアクセスするために使用できる生の20バイトSHA-1に変換できることを確認してください。そうであれば、それを標準出力に出力し、そうでなければエラーアウトします。</target>
        </trans-unit>
        <trans-unit id="e921c65f691e2b371e3e29dc398bb292612d2860" translate="yes" xml:space="preserve">
          <source>Verify that the tip commit of the side branch being merged is signed with a valid key, i.e. a key that has a valid uid: in the default trust model, this means the signing key has been signed by a trusted key. If the tip commit of the side branch is not signed with a valid key, the merge is aborted.</source>
          <target state="translated">マージするサイドブランチの tip commit が有効な鍵で署名されているかどうかを確認します。サイドブランチの tip コミットが有効な鍵で署名されていない場合は、マージは中止されます。</target>
        </trans-unit>
        <trans-unit id="baf3600caf9cbc675ef33fe6c51f69bd006b47ea" translate="yes" xml:space="preserve">
          <source>Verify the GPG signature of the given tag names.</source>
          <target state="translated">与えられたタグ名のGPG署名を検証します。</target>
        </trans-unit>
        <trans-unit id="2977304de3538ddff5d274481548280fa86926b6" translate="yes" xml:space="preserve">
          <source>Verify the MIDX file for the packfiles in the current .git folder.</source>
          <target state="translated">現在の .git フォルダにある packfiles の MIDX ファイルを確認します。</target>
        </trans-unit>
        <trans-unit id="593811a1bcc6cbc445bcfa7fdf52e4a760c41784" translate="yes" xml:space="preserve">
          <source>Verify the contents of the MIDX file.</source>
          <target state="translated">MIDXファイルの内容を確認します。</target>
        </trans-unit>
        <trans-unit id="63de76d12bfde7fe2c14402fe2f03160cc3a7318" translate="yes" xml:space="preserve">
          <source>Version 1 porcelain format is similar to the short format, but is guaranteed not to change in a backwards-incompatible way between Git versions or based on user configuration. This makes it ideal for parsing by scripts. The description of the short format above also describes the porcelain format, with a few exceptions:</source>
          <target state="translated">バージョン1の磁器フォーマットは短いフォーマットに似ていますが、Gitのバージョン間やユーザーの設定に基づいて後方互換性のない方法で変更されないことが保証されています。そのため、スクリプトによるパースに最適です。上記の short フォーマットの説明では、いくつかの例外を除いて porcelain フォーマットについても説明しています。</target>
        </trans-unit>
        <trans-unit id="1bb30898712789d3819631e4bb7ad8cf32d20671" translate="yes" xml:space="preserve">
          <source>Version 1 takes two arguments, a version (1) and the time in elapsed nanoseconds since midnight, January 1, 1970.</source>
          <target state="translated">バージョン1は2つの引数をとり、バージョン(1)と1970年1月1日の真夜中からの経過ナノ秒の時間を指定します。</target>
        </trans-unit>
        <trans-unit id="33e409adcd5a97d5085c0477fcb4b42dc9a034a9" translate="yes" xml:space="preserve">
          <source>Version 2 format adds more detailed information about the state of the worktree and changed items. Version 2 also defines an extensible set of easy to parse optional headers.</source>
          <target state="translated">バージョン2のフォーマットでは、ワークツリーの状態や変更された項目に関するより詳細な情報が追加されています。バージョン2では、解析しやすいオプションのヘッダの拡張可能なセットも定義されています。</target>
        </trans-unit>
        <trans-unit id="2b8063c91f48f5daba279d42a4965f292b8198dd" translate="yes" xml:space="preserve">
          <source>Version 2 pack-*.idx files support packs larger than 4 gib, and</source>
          <target state="translated">バージョン 2 の pack-*.idx ファイルは 4 gib 以上のパックをサポートしています。</target>
        </trans-unit>
        <trans-unit id="76b6cb1496a78fff149bd68b719a91ca0d69c9df" translate="yes" xml:space="preserve">
          <source>Version 2 takes two arguments, a version (2) and a token that is used for identifying changes since the token. For watchman this would be a clock id. This version must output to stdout the new token followed by a NUL before the list of files.</source>
          <target state="translated">バージョン2は、バージョン(2)とトークンの2つの引数を取り、トークン以降の変更を識別するために使用されます。watchmanの場合、これは時計のIDになります。このバージョンでは、新しいトークンの後にファイルのリストの前にNULを続けて標準出力に出力しなければなりません。</target>
        </trans-unit>
        <trans-unit id="5a28a75eceea6b3fb1730e69daff64901cead811" translate="yes" xml:space="preserve">
          <source>Version 4 performs a simple pathname compression that reduces index size by 30%-50% on large repositories, which results in faster load time. Version 4 is relatively young (first released in 1.8.0 in October 2012). Other Git implementations such as JGit and libgit2 may not support it yet.</source>
          <target state="translated">バージョン4では、単純なパス名圧縮を実行して、大規模なリポジトリでインデックスサイズを30%~50%削減し、ロード時間を短縮します。バージョン 4 は比較的新しいものです (最初にリリースされたのは 2012 年 10 月の 1.8.0 です)。JGit や libgit2 のような他の Git 実装はまだサポートしていないかもしれません。</target>
        </trans-unit>
        <trans-unit id="5b61ffa7c699cf77c98fcf76236048d42ca5d233" translate="yes" xml:space="preserve">
          <source>Version &lt;code&gt;0&lt;/code&gt;</source>
          <target state="translated">バージョン &lt;code&gt;0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7fc1164df4f366b4e06ce848f94e3799671648de" translate="yes" xml:space="preserve">
          <source>Version &lt;code&gt;1&lt;/code&gt;</source>
          <target state="translated">バージョン &lt;code&gt;1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="26980b77b1e7ef480646032aebce78732551db11" translate="yes" xml:space="preserve">
          <source>Versions of Git older than 1.7.7 don&amp;rsquo;t know about the &lt;code&gt;tar.gz&lt;/code&gt; format, you&amp;rsquo;ll need to use gzip explicitly:</source>
          <target state="translated">1.7.7より前のバージョンのGitは &lt;code&gt;tar.gz&lt;/code&gt; 形式を認識していません。明示的にgzipを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="48cda44638e8ce2f3c6e764951e4cd137e88bacc" translate="yes" xml:space="preserve">
          <source>Via the alternates mechanism, a &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt; can inherit part of its &lt;a href=&quot;#def_object_database&quot;&gt;object database&lt;/a&gt; from another object database, which is called an &quot;alternate&quot;.</source>
          <target state="translated">代替メカニズムを介して、&lt;a href=&quot;#def_repository&quot;&gt;リポジトリ&lt;/a&gt;は「代替」と呼ばれる別のオブジェクトデータベースから&lt;a href=&quot;#def_object_database&quot;&gt;オブジェクトデータベースの&lt;/a&gt;一部を継承できます。</target>
        </trans-unit>
        <trans-unit id="d75bfce3768015c62af9c4bd29fd7cad894764e0" translate="yes" xml:space="preserve">
          <source>Viewing everything that was changed in a revision, and step through revisions one at a time, viewing the history of the repository.</source>
          <target state="translated">リビジョンで変更されたものをすべて表示し、リポジトリの履歴を見ながら、リビジョンを1つずつステップアップしていきます。</target>
        </trans-unit>
        <trans-unit id="8e797001d4524362e7db8f18210266901eb28403" translate="yes" xml:space="preserve">
          <source>Viewing files in GUI tools</source>
          <target state="translated">GUIツールでのファイルの閲覧</target>
        </trans-unit>
        <trans-unit id="05c33ea7de1cccd62a72042e46bec3b3d340cf9f" translate="yes" xml:space="preserve">
          <source>Viewing multiple Git repositories with common root.</source>
          <target state="translated">複数の Git リポジトリを共通のルートで表示します。</target>
        </trans-unit>
        <trans-unit id="1439a80405107c5dd4ca129513bf97eb92ca8c3f" translate="yes" xml:space="preserve">
          <source>Viewing old file versions</source>
          <target state="translated">古いファイルのバージョンを表示する</target>
        </trans-unit>
        <trans-unit id="cba1ab24737b9af4081eae74baa579853869959f" translate="yes" xml:space="preserve">
          <source>Viewing project history</source>
          <target state="translated">プロジェクトの履歴を見る</target>
        </trans-unit>
        <trans-unit id="48e788f7b4905bc5801452134707bb74e1fddd3c" translate="yes" xml:space="preserve">
          <source>Viewing the blame/annotation details of any file (if enabled).</source>
          <target state="translated">任意のファイルの注釈/注釈の詳細を表示します(有効な場合)。</target>
        </trans-unit>
        <trans-unit id="afd57038f9956faea3beadae2f663a8f18e1dd6a" translate="yes" xml:space="preserve">
          <source>Viewing the contents of files in the repository at any revision.</source>
          <target state="translated">リポジトリ内のファイルの内容を任意のリビジョンで表示します。</target>
        </trans-unit>
        <trans-unit id="79e8c237bcc343324671ba4de89f13c4632b7437" translate="yes" xml:space="preserve">
          <source>Viewing the revision log of branches, history of files and directories, see what was changed when, by who.</source>
          <target state="translated">ブランチのリビジョンログ、ファイルやディレクトリの履歴を表示して、いつ、誰が、何を変更したかを確認します。</target>
        </trans-unit>
        <trans-unit id="5d3b4279714ad2970a30b9dfdfce1d9cde0d271d" translate="yes" xml:space="preserve">
          <source>Voila.</source>
          <target state="translated">Voila.</target>
        </trans-unit>
        <trans-unit id="f7dda342bfe7129409283096bf9eae6889a3617d" translate="yes" xml:space="preserve">
          <source>Waiting $&amp;lt;int&amp;gt; seconds before reconnecting to SMTP server. Used together with --batch-size option. Defaults to the &lt;code&gt;sendemail.smtpReloginDelay&lt;/code&gt; configuration variable.</source>
          <target state="translated">SMTPサーバーに再接続する前に$ &amp;lt;int&amp;gt;秒待機しています。--batch-sizeオプションと一緒に使用します。デフォルトは &lt;code&gt;sendemail.smtpReloginDelay&lt;/code&gt; 構成変数です。</target>
        </trans-unit>
        <trans-unit id="6abfc589b188840a4520edd8282e2221d54aed84" translate="yes" xml:space="preserve">
          <source>Walk history forward instead of backward. Instead of showing the revision in which a line appeared, this shows the last revision in which a line has existed. This requires a range of revision like START..END where the path to blame exists in START. &lt;code&gt;git blame --reverse START&lt;/code&gt; is taken as &lt;code&gt;git blame
--reverse START..HEAD&lt;/code&gt; for convenience.</source>
          <target state="translated">履歴を後方ではなく前方に移動します。行が表示されたリビジョンを表示する代わりに、行が存在した最後のリビジョンを表示します。これには、START..ENDのような一連のリビジョンが必要です。 &lt;code&gt;git blame --reverse START&lt;/code&gt; は、便宜上 &lt;code&gt;git blame --reverse START..HEAD&lt;/code&gt; れます。</target>
        </trans-unit>
        <trans-unit id="246770a4db6a59723366cd008c0806351012631a" translate="yes" xml:space="preserve">
          <source>Walk through the patches in the series and warn if we cannot find all of the necessary information to commit a patch. At the time of this writing only missing author information is warned about.</source>
          <target state="translated">シリーズのパッチをウォークスルーして、パッチをコミットするために必要な情報がすべて見つからない場合に警告します。この記事を書いている時点では、欠落している作者情報のみが警告されています。</target>
        </trans-unit>
        <trans-unit id="8741434725596a0a6dcba1ea6ce0540165fbeb38" translate="yes" xml:space="preserve">
          <source>Warn if changes introduce conflict markers or whitespace errors. What are considered whitespace errors is controlled by &lt;code&gt;core.whitespace&lt;/code&gt; configuration. By default, trailing whitespaces (including lines that consist solely of whitespaces) and a space character that is immediately followed by a tab character inside the initial indent of the line are considered whitespace errors. Exits with non-zero status if problems are found. Not compatible with --exit-code.</source>
          <target state="translated">変更によって競合マーカーまたは空白エラーが発生した場合に警告します。空白エラーと見なされるものは、 &lt;code&gt;core.whitespace&lt;/code&gt; 構成によって制御されます。デフォルトでは、末尾の空白（空白のみで構成される行を含む）および行の最初のインデント内の直後にタブ文字が続く空白文字は、空白エラーと見なされます。問題が見つかった場合、ゼロ以外のステータスで終了します。--exit-codeと互換性がありません。</target>
        </trans-unit>
        <trans-unit id="d0219dea42624b30174e17cfd1bb37d7d1a042a1" translate="yes" xml:space="preserve">
          <source>Warn of patches that contain lines longer than 998 characters unless a suitable transfer encoding (&lt;code&gt;auto&lt;/code&gt;, &lt;code&gt;base64&lt;/code&gt;, or &lt;code&gt;quoted-printable&lt;/code&gt;) is used; this is due to SMTP limits as described by &lt;a href=&quot;http://www.ietf.org/rfc/rfc5322.txt&quot;&gt;http://www.ietf.org/rfc/rfc5322.txt&lt;/a&gt;.</source>
          <target state="translated">適切な転送エンコーディング（ &lt;code&gt;auto&lt;/code&gt; 、 &lt;code&gt;base64&lt;/code&gt; 、または &lt;code&gt;quoted-printable&lt;/code&gt; ）が使用されていない限り、998文字より長い行を含むパッチの警告。これは、&lt;a href=&quot;http://www.ietf.org/rfc/rfc5322.txt&quot;&gt;http://www.ietf.org/rfc/rfc5322.txtで&lt;/a&gt;説明されているSMTPの制限によるものです。</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="d9a62a2598117c2be58c53a722de6576cd225a89" translate="yes" xml:space="preserve">
          <source>Warnings are printed on the standard error output for any explicitly unsupported constructs, and any other lines that are not recognized by the parser.</source>
          <target state="translated">明示的にサポートされていない構文や、パーサに認識されないその他の行については、標準エラー出力に警告が表示されます。</target>
        </trans-unit>
        <trans-unit id="54490e8680807566a4db5e14166b54af9ee18d68" translate="yes" xml:space="preserve">
          <source>We already saw in &lt;a href=&quot;#understanding-commits&quot;&gt;Understanding History: Commits&lt;/a&gt; that all commits are stored under a 40-digit &quot;object name&quot;. In fact, all the information needed to represent the history of a project is stored in objects with such names. In each case the name is calculated by taking the SHA-1 hash of the contents of the object. The SHA-1 hash is a cryptographic hash function. What that means to us is that it is impossible to find two different objects with the same name. This has a number of advantages; among others:</source>
          <target state="translated">&lt;a href=&quot;#understanding-commits&quot;&gt;「ヒストリーの理解：コミット」では&lt;/a&gt;、すべてのコミットが40桁の「オブジェクト名」で保存されることをすでに確認しました。実際、プロジェクトの履歴を表すために必要なすべての情報は、そのような名前のオブジェクトに格納されています。いずれの場合も、名前はオブジェクトの内容のSHA-1ハッシュを取ることによって計算されます。SHA-1ハッシュは、暗号化ハッシュ関数です。つまり、同じ名前の2つの異なるオブジェクトを見つけることは不可能です。これには多くの利点があります。特に：</target>
        </trans-unit>
        <trans-unit id="d6fd523936a98d1231393ad2931c9779a4d79b0e" translate="yes" xml:space="preserve">
          <source>We are looking for a &quot;best&quot; explanation of the new series in terms of the old one. We can represent an &quot;explanation&quot; as an edge in the graph:</source>
          <target state="translated">我々は新しい系列の「最良の」説明を古い系列の観点から探している.説明」をグラフの辺として表現することができる.</target>
        </trans-unit>
        <trans-unit id="9b940c15e60e8d5e30f8f0dd6fb317eefa03a3c7" translate="yes" xml:space="preserve">
          <source>We assume that GITWEB_CONFIG has its default Makefile value, namely &lt;code&gt;gitweb_config.perl&lt;/code&gt;. Put the following in &lt;code&gt;gitweb_make_index.perl&lt;/code&gt; file:</source>
          <target state="translated">GITWEB_CONFIGにはデフォルトのMakefile値、つまり &lt;code&gt;gitweb_config.perl&lt;/code&gt; があると想定しています。以下を &lt;code&gt;gitweb_make_index.perl&lt;/code&gt; ファイルに入れます：</target>
        </trans-unit>
        <trans-unit id="860f449f084465687d5f3065e9dcdf4471fe0c53" translate="yes" xml:space="preserve">
          <source>We assume the following in /etc/services</source>
          <target state="translated">etc/servicesでは以下のように仮定しています。</target>
        </trans-unit>
        <trans-unit id="e666201c4a3affd420bf339541f1e66f556269f5" translate="yes" xml:space="preserve">
          <source>We assume you have already created a Git repository for your project, possibly created from scratch or from a tarball (see &lt;a href=&quot;gittutorial&quot;&gt;gittutorial[7]&lt;/a&gt;), or imported from an already existing CVS repository (see the next section).</source>
          <target state="translated">プロジェクトのGitリポジトリがすでに作成されていると想定します。ゼロから作成するか、tarballから作成するか（&lt;a href=&quot;gittutorial&quot;&gt;gittutorial [7]を&lt;/a&gt;参照）、既存のCVSリポジトリからインポートする（次のセクションを参照）。</target>
        </trans-unit>
        <trans-unit id="a35a2d4ac8af99272cba8ca44431c44847ef0735" translate="yes" xml:space="preserve">
          <source>We can also create a tag to refer to a particular commit; after running</source>
          <target state="translated">特定のコミットを参照するためのタグを作成することもできます。</target>
        </trans-unit>
        <trans-unit id="ec584a188dcd2e25a99263b54f2feb909dc57e99" translate="yes" xml:space="preserve">
          <source>We can ask Git about this particular object with the &lt;code&gt;cat-file&lt;/code&gt; command. Don&amp;rsquo;t copy the 40 hex digits from this example but use those from your own version. Note that you can shorten it to only a few characters to save yourself typing all 40 hex digits:</source>
          <target state="translated">&lt;code&gt;cat-file&lt;/code&gt; コマンドを使用して、Gitにこの特定のオブジェクトについて尋ねることができます。この例の40桁の16進数はコピーせず、独自のバージョンのものを使用してください。40桁の16進数をすべて入力する手間を省くために、数文字に短縮できることに注意してください。</target>
        </trans-unit>
        <trans-unit id="3d0c7ad92eed63e4b86ed7fcdbe0a2af116dc20a" translate="yes" xml:space="preserve">
          <source>We can further investigate the time spent scanning for untracked files.</source>
          <target state="translated">追跡されていないファイルのスキャンに費やした時間をさらに調査することができます。</target>
        </trans-unit>
        <trans-unit id="14c5f91f2f30d67e424b3d8fa6177783e08a84fd" translate="yes" xml:space="preserve">
          <source>We can get just the branch-head names, and remove &lt;code&gt;master&lt;/code&gt;, with the help of the standard utilities cut and grep:</source>
          <target state="translated">標準のユーティリティであるcutとgrep を使用して、ブランチヘッド名だけを取得し、 &lt;code&gt;master&lt;/code&gt; を削除できます。</target>
        </trans-unit>
        <trans-unit id="a00f6027326a1e03d87c7714c37d6396c5fc0f07" translate="yes" xml:space="preserve">
          <source>We can get this using the following command:</source>
          <target state="translated">以下のコマンドで取得できます。</target>
        </trans-unit>
        <trans-unit id="308213d749ac73498be48acb36aa505b62d477c8" translate="yes" xml:space="preserve">
          <source>We can give this name to &lt;code&gt;git show&lt;/code&gt; to see the details about this commit.</source>
          <target state="translated">この名前を &lt;code&gt;git show&lt;/code&gt; に付けて、このコミットの詳細を確認できます。</target>
        </trans-unit>
        <trans-unit id="164a7b582707458e7c29a45bdd3cb932a29b3ca1" translate="yes" xml:space="preserve">
          <source>We can list all the heads in this repository with &lt;a href=&quot;git-show-ref&quot;&gt;git-show-ref[1]&lt;/a&gt;:</source>
          <target state="translated">このリポジトリのすべてのヘッドを&lt;a href=&quot;git-show-ref&quot;&gt;git-show-ref [1]で&lt;/a&gt;一覧表示できます。</target>
        </trans-unit>
        <trans-unit id="3342879e047ae36a38db13969064b38d54ccc902" translate="yes" xml:space="preserve">
          <source>We divide Git into high level (&quot;porcelain&quot;) commands and low level (&quot;plumbing&quot;) commands.</source>
          <target state="translated">Gitを高レベル(「磁器」)のコマンドと低レベル(「配管」)のコマンドに分けています。</target>
        </trans-unit>
        <trans-unit id="011f9d254149abd4e25f111f5f8f2bc847e7e4cc" translate="yes" xml:space="preserve">
          <source>We explain how to do this in the following sections.</source>
          <target state="translated">では、その方法を説明します。</target>
        </trans-unit>
        <trans-unit id="4822ab43c46db1b5802e2f53899245649e4398bd" translate="yes" xml:space="preserve">
          <source>We formulate a set of &lt;code&gt;rules&lt;/code&gt; for quick reference, while the prose tries to motivate each of them. Do not always take them literally; you should value good reasons for your actions higher than manpages such as this one.</source>
          <target state="translated">簡単な参照のために一連の &lt;code&gt;rules&lt;/code&gt; を作成し、散文はそれらのそれぞれに動機を与えようとします。それらを常に文字通りに受け取らないでください。このようなマンページよりもアクションの正当な理由を高く評価する必要があります。</target>
        </trans-unit>
        <trans-unit id="27af85d69b0e1da45afccff7b9c2331995331c55" translate="yes" xml:space="preserve">
          <source>We found that most commits on the graph may give quite a lot of information when they are tested. And the commits that will not on average give a lot of information are the one near the good and bad commits.</source>
          <target state="translated">私たちは、グラフ上のほとんどのコミットがテスト時にかなり多くの情報を提供することを発見しました。そして、平均して多くの情報を提供しないコミットは、良いコミットと悪いコミットの近くにあるコミットです。</target>
        </trans-unit>
        <trans-unit id="319c4fde5f53d3ebfff60d2ca81633ff5c5e7332" translate="yes" xml:space="preserve">
          <source>We have already seen &lt;a href=&quot;#Updating-a-repository-With-git-fetch&quot;&gt;how to keep remote-tracking branches up to date&lt;/a&gt; with &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;, and how to merge two branches. So you can merge in changes from the original repository&amp;rsquo;s master branch with:</source>
          <target state="translated">我々はすでに見てきた&lt;a href=&quot;#Updating-a-repository-With-git-fetch&quot;&gt;これまでのリモート追跡の枝を維持するためにどのよう&lt;/a&gt;に&lt;a href=&quot;git-fetch&quot;&gt;gitのフェッチ[1] &lt;/a&gt;、およびどのように二つのブランチをマージします。したがって、元のリポジトリのマスターブランチからの変更を次のようにマージできます。</target>
        </trans-unit>
        <trans-unit id="9313b2be3fe8f9ef5431fd57e740ed2c389d7c2c" translate="yes" xml:space="preserve">
          <source>We have already seen how branches work previously, with &quot;fun and work&quot; example using two branches. The idea is the same if there are more than two branches. Let&amp;rsquo;s say you started out from &quot;master&quot; head, and have some new code in the &quot;master&quot; branch, and two independent fixes in the &quot;commit-fix&quot; and &quot;diff-fix&quot; branches:</source>
          <target state="translated">2つのブランチを使用する &quot;fun and work&quot;の例を使用して、ブランチが以前にどのように機能するかについてはすでに見ました。ブランチが3つ以上ある場合も同じです。「マスター」の頭から始めて、「マスター」ブランチにいくつかの新しいコードがあり、「コミットコミット」および「差分フィックス」ブランチに2つの独立した修正があるとします。</target>
        </trans-unit>
        <trans-unit id="1170354586d8db2806a89632eb01397ff1d5b39a" translate="yes" xml:space="preserve">
          <source>We have seen several ways of naming commits already:</source>
          <target state="translated">コミットの命名方法はすでにいくつか見てきました。</target>
        </trans-unit>
        <trans-unit id="ea2d131015439270646c4d9deb94b3238eec4d65" translate="yes" xml:space="preserve">
          <source>We have seen that regressions are an important problem, and that &quot;git bisect&quot; has nice features that complement very well practices and other tools, especially test suites, that are generally used to fight regressions. But it might be needed to change some work-flows and (bad) habits to get the most out of it.</source>
          <target state="translated">リグレッションが重要な問題であること、そして &quot;git bisect&quot; には、リグレッションと戦うために一般的に使われているプラクティスや他のツール、特にテストスイートを非常によく補完する機能があることを見てきました。しかし、それを最大限に活用するためには、ワークフローや (悪い)習慣を変える必要があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="58d71328c844eab6bb246a8885f29a926cbaf29b" translate="yes" xml:space="preserve">
          <source>We have seen that test suites and git bisect are very powerful when used together. It can be even more powerful if you can combine them with other systems.</source>
          <target state="translated">テストスイートとgit bisectは併用すると非常に強力であることがわかりました。他のシステムと組み合わせることができれば、さらに強力になります。</target>
        </trans-unit>
        <trans-unit id="0dc1429b571e4014b12f464201faf90142f01343" translate="yes" xml:space="preserve">
          <source>We ignore all SVN properties except svn:executable. Any unhandled properties are logged to $GIT_DIR/svn/&amp;lt;refname&amp;gt;/unhandled.log</source>
          <target state="translated">svn：executableを除くすべてのSVNプロパティを無視します。未処理のプロパティはすべて$ GIT_DIR / svn / &amp;lt;refname&amp;gt; /unhandled.logに記録されます</target>
        </trans-unit>
        <trans-unit id="5e0e70c2a550cebe0f64341bc25aba4f82846837" translate="yes" xml:space="preserve">
          <source>We said this tutorial shows what plumbing does to help you cope with the porcelain that isn&amp;rsquo;t flushing, but we so far did not talk about how the merge really works. If you are following this tutorial the first time, I&amp;rsquo;d suggest to skip to &quot;Publishing your work&quot; section and come back here later.</source>
          <target state="translated">このチュートリアルでは、水を流していない磁器に対処するために配管が何をするかを説明しましたが、これまでのところ、マージが実際にどのように機能するかについては触れていません。このチュートリアルを初めて実行する場合は、「作品の公開」セクションにスキップして、後でここに戻ることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="038e0426e816e440e5c183b0ccfae9faca0c65b5" translate="yes" xml:space="preserve">
          <source>We saw above that &lt;code&gt;origin&lt;/code&gt; is just a shortcut to refer to the repository that you originally cloned from. This information is stored in Git configuration variables, which you can see using &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;:</source>
          <target state="translated">上記で見たように、 &lt;code&gt;origin&lt;/code&gt; は元のクローン元のリポジトリを参照するための単なるショートカットです。この情報はGit構成変数に格納され、&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;を使用して確認できます。</target>
        </trans-unit>
        <trans-unit id="789eeb5f51968bf21d9746b92623ca08838d8bcb" translate="yes" xml:space="preserve">
          <source>We saw earlier that &quot;git bisect skip&quot; is now using a PRNG to try to avoid areas in the commit graph where commits are untestable. The problem is that sometimes the first bad commit will be in an untestable area.</source>
          <target state="translated">先ほど、&quot;git bisect skip&quot; が PRNG を使ってコミットグラフの中でテスト不可能な領域を避けようとしていることを見ました。問題は、最初の悪いコミットがテスト不可能な領域にあることがあるということです。</target>
        </trans-unit>
        <trans-unit id="e6f53989efc34bb4d6e54dcd09f15943b6a8a36c" translate="yes" xml:space="preserve">
          <source>We saw in &lt;a href=&quot;#conflict-resolution&quot;&gt;Getting conflict-resolution help during a merge&lt;/a&gt; that during a merge the index can store multiple versions of a single file (called &quot;stages&quot;). The third column in the &lt;a href=&quot;git-ls-files&quot;&gt;git-ls-files[1]&lt;/a&gt; output above is the stage number, and will take on values other than 0 for files with merge conflicts.</source>
          <target state="translated">私たちは、で見た&lt;a href=&quot;#conflict-resolution&quot;&gt;マージ中に競合解決ヘルプの&lt;/a&gt;マージ中にインデックスが（「ステージ」と呼ばれる）単一のファイルの複数のバージョンを保存することが可能となります。上記の&lt;a href=&quot;git-ls-files&quot;&gt;git-ls-files [1]の&lt;/a&gt;出力の3番目の列はステージ番号であり、マージの競合があるファイルに対して0以外の値をとります。</target>
        </trans-unit>
        <trans-unit id="d5d682276e6a6d081a241de022b4ded4aef9c418" translate="yes" xml:space="preserve">
          <source>We saw in &lt;a href=&quot;#fixing-a-mistake-by-rewriting-history&quot;&gt;Fixing a mistake by rewriting history&lt;/a&gt; that you can replace the most recent commit using</source>
          <target state="translated">を使用して最新のコミットを置き換えることができるという&lt;a href=&quot;#fixing-a-mistake-by-rewriting-history&quot;&gt;履歴&lt;/a&gt;を書き換えることによる間違いの修正で見た</target>
        </trans-unit>
        <trans-unit id="aafdc07c8e0d9b297fcdd505608f380ef754ed45" translate="yes" xml:space="preserve">
          <source>We saw in part one of the tutorial that commits have names like this. It turns out that every object in the Git history is stored under a 40-digit hex name. That name is the SHA-1 hash of the object&amp;rsquo;s contents; among other things, this ensures that Git will never store the same data twice (since identical data is given an identical SHA-1 name), and that the contents of a Git object will never change (since that would change the object&amp;rsquo;s name as well). The 7 char hex strings here are simply the abbreviation of such 40 character long strings. Abbreviations can be used everywhere where the 40 character strings can be used, so long as they are unambiguous.</source>
          <target state="translated">チュートリアルの一部で、コミットに次のような名前が付いているのを見ました。 Git履歴のすべてのオブジェクトは、40桁の16進数の名前で保存されていることがわかります。その名前は、オブジェクトの内容のSHA-1ハッシュです。特に、これにより、Gitが同じデータを2回保存することはなく（同じデータには同じSHA-1名が付けられるため）、Gitオブジェクトの内容は決して変更されません（オブジェクトの名前も変更されるため） ）。ここで7文字の16進文字列は、そのような40文字の長い文字列の略語です。省略形は、40文字の文字列が使用できる場所であればどこでも使用できますが、あいまいでない場合に限ります。</target>
        </trans-unit>
        <trans-unit id="09c046487d09b436218fe11aa8c1087251442281" translate="yes" xml:space="preserve">
          <source>We separate the porcelain commands into the main commands and some ancillary user utilities.</source>
          <target state="translated">磁器のコマンドをメインコマンドと補助的なユーザーユーティリティに分けています。</target>
        </trans-unit>
        <trans-unit id="f2e875357a5ce85901234308b841a3138ebd851b" translate="yes" xml:space="preserve">
          <source>We should point out that &quot;habitually&quot; (regularly for no real reason) merging an integration branch into your topics &amp;mdash; and by extension, merging anything upstream into anything downstream on a regular basis &amp;mdash; is frowned upon:</source>
          <target state="translated">統合ブランチをトピックに（通常は本当の理由ではありませんが）マージすること、さらにはアップストリームにあるものとダウンストリームにあるものを定期的にマージすることは、不快なことです。</target>
        </trans-unit>
        <trans-unit id="3b0c2056ade966758c96efbd333ad03c787ca3ac" translate="yes" xml:space="preserve">
          <source>We start with one specialized tool that is useful for finding the commit that introduced a bug into a project.</source>
          <target state="translated">まずは、プロジェクトにバグを導入したコミットを見つけるのに便利な専用ツールから始めます。</target>
        </trans-unit>
        <trans-unit id="3bb7fbe62fd9b3fa1a7f67f6a431251fe7b02079" translate="yes" xml:space="preserve">
          <source>We start with the most important, the &lt;a href=&quot;#def_object_database&quot;&gt;object database&lt;/a&gt; and the &lt;a href=&quot;#def_index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">最も重要な&lt;a href=&quot;#def_object_database&quot;&gt;オブジェクトデータベース&lt;/a&gt;と&lt;a href=&quot;#def_index&quot;&gt;インデックス&lt;/a&gt;から始めます。</target>
        </trans-unit>
        <trans-unit id="fa1acdd625946113b786a5983b045431892f2e96" translate="yes" xml:space="preserve">
          <source>We supposed in the previous examples that the &quot;good&quot; commits were ancestors of the &quot;bad&quot; commit. But this is not a requirement of &quot;git bisect&quot;.</source>
          <target state="translated">これまでの例では、「良い」コミットは「悪い」コミットの先祖であると考えていました。しかし、これは &quot;git bisect&quot; の要件ではありません。</target>
        </trans-unit>
        <trans-unit id="09e675bfb62532c536d372645ebddf19b07c5684" translate="yes" xml:space="preserve">
          <source>We want to make &lt;code&gt;topic&lt;/code&gt; forked from branch &lt;code&gt;master&lt;/code&gt;; for example, because the functionality on which &lt;code&gt;topic&lt;/code&gt; depends was merged into the more stable &lt;code&gt;master&lt;/code&gt; branch. We want our tree to look like this:</source>
          <target state="translated">ブランチ &lt;code&gt;master&lt;/code&gt; から分岐した &lt;code&gt;topic&lt;/code&gt; を作成します。たとえば、 &lt;code&gt;topic&lt;/code&gt; 依存する機能がより安定した &lt;code&gt;master&lt;/code&gt; ブランチにマージされたためです。ツリーを次のようにしたいとします。</target>
        </trans-unit>
        <trans-unit id="0fa006b18282abd83f954d3423dfd83f70f68c0d" translate="yes" xml:space="preserve">
          <source>We will introduce some tools that can help you do this, explain how to use them, and then explain some of the problems that can arise because you are rewriting history.</source>
          <target state="translated">その際に役立つツールをいくつか紹介し、その使い方を説明した上で、歴史を書き換えているからこそ起こりうる問題点を解説していきます。</target>
        </trans-unit>
        <trans-unit id="e34d86d215639adac5ecaa74d7f70d803a2ef9de" translate="yes" xml:space="preserve">
          <source>We will sometimes represent Git history using diagrams like the one below. Commits are shown as &quot;o&quot;, and the links between them with lines drawn with - / and \. Time goes left to right:</source>
          <target state="translated">Git の履歴を、以下のような図を使って表現することがあります。コミットを「o」で表し、その間のリンクを「/」と「\」で線で表しています。時間は左から右に進みます。</target>
        </trans-unit>
        <trans-unit id="ab9fd84ced67b4e6059fb12091ba4144199c5397" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll assume that the problem is a single missing or corrupted blob, which is sometimes a solvable problem. (Recovering missing trees and especially commits is &lt;strong&gt;much&lt;/strong&gt; harder).</source>
          <target state="translated">問題は単一の欠落または破損したblobであると想定します。これは解決可能な問題になる場合があります。（欠落しているツリー、特にコミットの回復は&lt;strong&gt;はるかに&lt;/strong&gt;困難です）。</target>
        </trans-unit>
        <trans-unit id="2aa7b1ec194976812ce4b6b3f7e0ba34eba549a8" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll keep this simple and stupid, so we&amp;rsquo;ll start off with populating a few trivial files just to get a feel for it.</source>
          <target state="translated">私たちはこれをシンプルで愚かなままにしておくので、まずはそれを感じさせるために、いくつかの簡単なファイルを作成するところから始めます。</target>
        </trans-unit>
        <trans-unit id="2d4db37414a68811cd95f44af4830929ada62273" translate="yes" xml:space="preserve">
          <source>Webserver configuration</source>
          <target state="translated">ウェブサーバの設定</target>
        </trans-unit>
        <trans-unit id="c0f36d74c982d11ffbdfaa17b6ab39308ec52a2f" translate="yes" xml:space="preserve">
          <source>Webserver configuration with multiple projects' root</source>
          <target state="translated">複数のプロジェクトのルートを持つWebサーバの設定</target>
        </trans-unit>
        <trans-unit id="ef6d4f2b2672206d0b50ce512c5b9cc1369fe95f" translate="yes" xml:space="preserve">
          <source>What an alias file in each format looks like can be found in the documentation of the email program of the same name. The differences and limitations from the standard formats are described below:</source>
          <target state="translated">各フォーマットのエイリアスファイルがどのように見えるかは、同名のメールプログラムのドキュメントを参照してください。標準フォーマットとの違いや制限事項を以下に説明します。</target>
        </trans-unit>
        <trans-unit id="fa6325f935566c907b8b84855ddf6b390a1827e3" translate="yes" xml:space="preserve">
          <source>What are the 7 digits of hex that Git responded to the commit with?</source>
          <target state="translated">Git がコミットに反応した 7 桁の 16 進数は?</target>
        </trans-unit>
        <trans-unit id="5fb651419665147da76edfca56099f33ccd0e645" translate="yes" xml:space="preserve">
          <source>What does this mean?</source>
          <target state="translated">これは何を意味するのか?</target>
        </trans-unit>
        <trans-unit id="b77fdbd3385bc488b50aa891b5b4c124304a8f69" translate="yes" xml:space="preserve">
          <source>What is interesting too is that end users that are reporting bugs (or QA people that reproduced a bug) have access to the environment where the bug happens. So they can often more easily reproduce a regression. And if they can bisect, then more information will be extracted from the environment where the bug happens, which means that it will be easier to understand and then fix the bug.</source>
          <target state="translated">また、興味深いのは、バグを報告しているエンドユーザー(またはバグを再現したQAの人たち)は、バグが発生した環境にアクセスできるということです。そのため、彼らはより簡単にリグレッションを再現することができます。また、二分することができれば、バグが発生している環境からより多くの情報が抽出され、バグを理解して修正することが容易になります。</target>
        </trans-unit>
        <trans-unit id="549056214cd4b23720c4559829b5b36cc5cf6d0c" translate="yes" xml:space="preserve">
          <source>What next?</source>
          <target state="translated">次は何をするの?</target>
        </trans-unit>
        <trans-unit id="fe77441e9cc191fb4a5181d6f98e51e7bf6ce4ab" translate="yes" xml:space="preserve">
          <source>What people don&amp;rsquo;t get is that this is a situation where the &quot;end node principle&quot; applies. When you have limited resources (here: developers) you don&amp;rsquo;t push the bulk of the burden upon them. Instead you push things out to the resource you have a lot of, the end nodes (here: users), so that the situation actually scales.</source>
          <target state="translated">人々が得ていないのは、これが「エンドノードの原則」が適用される状況であるということです。リソースが限られている場合（ここでは：開発者）、リソースに大きな負担をかけません。その代わりに、多くのリソースであるエンドノード（ここではユーザー）に物事をプッシュし、状況を実際に拡大できるようにします。</target>
        </trans-unit>
        <trans-unit id="e4950cd435094a3f200db11a5c1b540d80d04769" translate="yes" xml:space="preserve">
          <source>What should you do when you tag a wrong commit and you would want to re-tag?</source>
          <target state="translated">間違ったコミットをタグ付けしてしまい、再タグ付けしたい場合はどうすればいいのでしょうか?</target>
        </trans-unit>
        <trans-unit id="049920ec0574fb80b08ccee259e5814b007cd44c" translate="yes" xml:space="preserve">
          <source>What the -p option produces is slightly different from the traditional diff format:</source>
          <target state="translated">p オプションが生成するものは、従来の diff 形式とは少し異なります。</target>
        </trans-unit>
        <trans-unit id="e27b60d4391d6c41de480e30a2d0df50a6723ae8" translate="yes" xml:space="preserve">
          <source>What to do when a push fails</source>
          <target state="translated">プッシュが失敗したときの対処法</target>
        </trans-unit>
        <trans-unit id="42a1dbf4390cedcf2f183fba444335bae8d5ae11" translate="yes" xml:space="preserve">
          <source>What you chose are then highlighted with &lt;code&gt;*&lt;/code&gt;, like this:</source>
          <target state="translated">次のように、選択したものが &lt;code&gt;*&lt;/code&gt; で強調表示されます。</target>
        </trans-unit>
        <trans-unit id="e11a716b5dc9d27d9966b39b2c63b32b4c67e627" translate="yes" xml:space="preserve">
          <source>When &amp;lt;rev&amp;gt; is not specified, the command annotates the changes starting backwards from the working tree copy. This flag makes the command pretend as if the working tree copy has the contents of the named file (specify &lt;code&gt;-&lt;/code&gt; to make the command read from the standard input).</source>
          <target state="translated">&amp;lt;rev&amp;gt;が指定されていない場合、コマンドは作業ツリーのコピーから逆方向に始まる変更に注釈を付けます。このフラグは、作業ツリーのコピーに指定されたファイルの内容があるかのようにコマンドを偽装させます（ &lt;code&gt;-&lt;/code&gt; を指定すると、コマンドは標準入力から読み取られます）。</target>
        </trans-unit>
        <trans-unit id="df8212af8d2323e7260f5fa3c4bc0bbc714643ff" translate="yes" xml:space="preserve">
          <source>When --fork-point is active, &lt;code&gt;fork_point&lt;/code&gt; will be used instead of &amp;lt;upstream&amp;gt; to calculate the set of commits to rebase, where &lt;code&gt;fork_point&lt;/code&gt; is the result of &lt;code&gt;git merge-base --fork-point &amp;lt;upstream&amp;gt;
&amp;lt;branch&amp;gt;&lt;/code&gt; command (see &lt;a href=&quot;git-merge-base&quot;&gt;git-merge-base[1]&lt;/a&gt;). If &lt;code&gt;fork_point&lt;/code&gt; ends up being empty, the &amp;lt;upstream&amp;gt; will be used as a fallback.</source>
          <target state="translated">--fork-pointがアクティブな場合、リベースするコミットのセットを計算するために、&amp;lt;upstream&amp;gt;の代わりに &lt;code&gt;fork_point&lt;/code&gt; が使用されます &lt;code&gt;fork_point&lt;/code&gt; は &lt;code&gt;git merge-base --fork-point &amp;lt;upstream&amp;gt; &amp;lt;branch&amp;gt;&lt;/code&gt; コマンドの結果です（&lt;a href=&quot;git-merge-base&quot;&gt;git-merge-base [1]を&lt;/a&gt;参照してください）。もし &lt;code&gt;fork_point&lt;/code&gt; 空になってしまう、&amp;lt;上流&amp;gt;フォールバックとして使用されます。</target>
        </trans-unit>
        <trans-unit id="0b903c4e9a3738f389f65549fe23dcd21fd8909d" translate="yes" xml:space="preserve">
          <source>When --graph is not used, all history branches are flattened which can make it hard to see that the two consecutive commits do not belong to a linear branch. This option puts a barrier in between them in that case. If &lt;code&gt;&amp;lt;barrier&amp;gt;&lt;/code&gt; is specified, it is the string that will be shown instead of the default one.</source>
          <target state="translated">--graphを使用しない場合、すべての履歴ブランチがフラット化されるため、2つの連続したコミットが線形ブランチに属していないことがわかりにくくなる可能性があります。その場合、このオプションはそれらの間に障壁を置きます。 &lt;code&gt;&amp;lt;barrier&amp;gt;&lt;/code&gt; が指定されている場合、デフォルトの文字列の代わりに表示される文字列です。</target>
        </trans-unit>
        <trans-unit id="24ff3c267435a7dcecd3166ed52f8210a7c7f0de" translate="yes" xml:space="preserve">
          <source>When --stdout is specified then progress report is displayed during the object count and compression phases but inhibited during the write-out phase. The reason is that in some cases the output stream is directly linked to another command which may wish to display progress status of its own as it processes incoming pack data. This flag is like --progress except that it forces progress report for the write-out phase as well even if --stdout is used.</source>
          <target state="translated">stdout が指定された場合、オブジェクトカウントと圧縮フェーズでは進捗状況のレポートが表示されますが、書き込みフェーズでは表示されません。これは、出力ストリームが別のコマンドに直接リンクされている場合があり、そのコマンドが入力されたパックデータを処理している間は、そのコマンド自身の進捗状況を表示したい場合があるためです。このフラグは--progressと同様で、--stdoutが使用されている場合でも、書き込みフェーズでも進捗状況の報告を強制することを除いては--progressと同じです。</target>
        </trans-unit>
        <trans-unit id="d3e80ca53bd7d57db503ac84208eff0dbe6d901f" translate="yes" xml:space="preserve">
          <source>When -k is not in effect, all leading strings bracketed with &lt;code&gt;[&lt;/code&gt; and &lt;code&gt;]&lt;/code&gt; pairs are stripped. This option limits the stripping to only the pairs whose bracketed string contains the word &quot;PATCH&quot;.</source>
          <target state="translated">-kが有効でない場合は、 &lt;code&gt;[&lt;/code&gt; と &lt;code&gt;]&lt;/code&gt; のペアで囲まれたすべての先行文字列が削除されます。このオプションは、ストリッピングを、括弧で囲まれた文字列に「PATCH」という単語が含まれるペアのみに制限します。</target>
        </trans-unit>
        <trans-unit id="882475218cb0a9fc17e76a3d4266386adec5dd71" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&quot;$@&quot;&lt;/code&gt; is &lt;code&gt;-h&lt;/code&gt; or &lt;code&gt;--help&lt;/code&gt; in the above example, the following usage text would be shown:</source>
          <target state="translated">ときに &lt;code&gt;&quot;$@&quot;&lt;/code&gt; で &lt;code&gt;-h&lt;/code&gt; または &lt;code&gt;--help&lt;/code&gt; 上記の例では、以下の使用テキストが表示されます：</target>
        </trans-unit>
        <trans-unit id="d78a0cbb0812363470a0c64a4a94d40dd1da90bb" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--batch-all-objects&lt;/code&gt; is in use, visit objects in an order which may be more efficient for accessing the object contents than hash order. The exact details of the order are unspecified, but if you do not require a specific order, this should generally result in faster output, especially with &lt;code&gt;--batch&lt;/code&gt;. Note that &lt;code&gt;cat-file&lt;/code&gt; will still show each object only once, even if it is stored multiple times in the repository.</source>
          <target state="translated">とき &lt;code&gt;--batch-all-objects&lt;/code&gt; 使用されている、訪問はハッシュ順序よりもオブジェクトの内容にアクセスするためのより効率的かもしれために、オブジェクト。順序の正確な詳細は指定されていませんが、特定の順序を必要としない場合は、特に &lt;code&gt;--batch&lt;/code&gt; を使用すると、一般的に出力が速くなります。 &lt;code&gt;cat-file&lt;/code&gt; は、リポジトリに複数回保存されている場合でも、各オブジェクトを1回だけ表示することに注意してください。</target>
        </trans-unit>
        <trans-unit id="95919047a579b82415a0ddd6c6f601bfbb7dc80f" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--check&lt;/code&gt; is in effect, or when applying the patch (which is the default when none of the options that disables it is in effect), make sure the patch is applicable to what the current index file records. If the file to be patched in the working tree is not up to date, it is flagged as an error. This flag also causes the index file to be updated.</source>
          <target state="translated">とき &lt;code&gt;--check&lt;/code&gt; が有効になっている、または（オプションのいずれも無効、それが有効でないことをするときのデフォルトです）パッチを適用する際に、必ずパッチはどのような現在のインデックスファイル・レコードに適用されます。作業ツリーでパッチを適用するファイルが最新でない場合、エラーとしてフラグが立てられます。このフラグにより​​、インデックスファイルも更新されます。</target>
        </trans-unit>
        <trans-unit id="526cf7ed548b3415806841ff6b0e065a944a8f5e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--compose&lt;/code&gt; is used, git send-email will use the From, Subject, and In-Reply-To headers specified in the message. If the body of the message (what you type after the headers and a blank line) only contains blank (or Git: prefixed) lines, the summary won&amp;rsquo;t be sent, but From, Subject, and In-Reply-To headers will be used unless they are removed.</source>
          <target state="translated">とき &lt;code&gt;--compose&lt;/code&gt; が使用され、gitのセンドメールから、件名、およびIn-返信先のメッセージで指定されたヘッダーを使用します。メッセージの本文（ヘッダーと空白行の後に入力したもの）に空白（またはGit：接頭辞付き）の行しか含まれていない場合、要約は送信されませんが、From、Subject、およびIn-Reply-Toヘッダーは送信されます削除されない限り使用できます。</target>
        </trans-unit>
        <trans-unit id="46dc43993fdd7156fca21e87a205fc0f333f2d9a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--cone&lt;/code&gt; is provided, the &lt;code&gt;core.sparseCheckoutCone&lt;/code&gt; setting is also set, allowing for better performance with a limited set of patterns (see &lt;code&gt;CONE PATTERN SET&lt;/code&gt; below).</source>
          <target state="translated">場合 &lt;code&gt;--cone&lt;/code&gt; が設けられ、 &lt;code&gt;core.sparseCheckoutCone&lt;/code&gt; の設定も（参照パターンの限定されたセットとのより良好な性能を可能にする、設定された &lt;code&gt;CONE PATTERN SET&lt;/code&gt; 下を）。</target>
        </trans-unit>
        <trans-unit id="ac6d168ca5e25a70ab78d5a850025a2ad07d998b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--exclude&lt;/code&gt; and &lt;code&gt;--include&lt;/code&gt; patterns are used, they are examined in the order they appear on the command line, and the first match determines if a patch to each path is used. A patch to a path that does not match any include/exclude pattern is used by default if there is no include pattern on the command line, and ignored if there is any include pattern.</source>
          <target state="translated">場合 &lt;code&gt;--exclude&lt;/code&gt; と &lt;code&gt;--include&lt;/code&gt; パターンが使用され、それらは、コマンドライン上に表示され、各パスのパッチが使用される場合、最初の一致が判断するために検査されます。include / excludeパターンに一致しないパスへのパッチは、コマンドラインにincludeパターンがない場合はデフォルトで使用され、includeパターンがある場合は無視されます。</target>
        </trans-unit>
        <trans-unit id="febfb7b902fc970c3396f3068a5c66e59c7ec8ea" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--notes&lt;/code&gt; is in effect, the message from the notes is matched as if it were part of the log message.</source>
          <target state="translated">&lt;code&gt;--notes&lt;/code&gt; が有効な場合、ノートからのメッセージは、ログメッセージの一部であるかのように照合されます。</target>
        </trans-unit>
        <trans-unit id="b84c74a91c715b3bf1b4e927529a07a15aed9721" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--numstat&lt;/code&gt; has been given, do not munge pathnames, but use a NUL-terminated machine-readable format.</source>
          <target state="translated">&lt;code&gt;--numstat&lt;/code&gt; が指定されている場合は、パス名を変更せず、NULで終了する機械可読形式を使用してください。</target>
        </trans-unit>
        <trans-unit id="d371e700585c518084c33d84fef0af43b13c3439" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--raw&lt;/code&gt;, &lt;code&gt;--numstat&lt;/code&gt;, &lt;code&gt;--name-only&lt;/code&gt; or &lt;code&gt;--name-status&lt;/code&gt; has been given, do not munge pathnames and use NULs as output field terminators.</source>
          <target state="translated">とき &lt;code&gt;--raw&lt;/code&gt; 、 &lt;code&gt;--numstat&lt;/code&gt; 、 &lt;code&gt;--name-only&lt;/code&gt; または &lt;code&gt;--name-status&lt;/code&gt; 与えられている、出力フィールドターミネータとしてのmungeないパス名と使用NULsを行います。</target>
        </trans-unit>
        <trans-unit id="e163d548a1a886a531d60736c2ba3e851388a10a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--root&lt;/code&gt; is specified the initial commit will be shown as a big creation event. This is equivalent to a diff against the NULL tree.</source>
          <target state="translated">とき &lt;code&gt;--root&lt;/code&gt; が指定された初期には、コミットビッグ作成イベントとして表示されます。これは、NULLツリーに対する差分と同等です。</target>
        </trans-unit>
        <trans-unit id="8183759ad974b12070a46362dbaa27565534e645" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--show-pulls&lt;/code&gt; is paired with &lt;code&gt;--simplify-merges&lt;/code&gt;, the graph includes all of the necessary information:</source>
          <target state="translated">場合 &lt;code&gt;--show-pulls&lt;/code&gt; と対にされる &lt;code&gt;--simplify-merges&lt;/code&gt; 、グラフは、必要な情報のすべてを含みます。</target>
        </trans-unit>
        <trans-unit id="5b88ba2b22685842fbd9b8b75fb2959da8ea9e8b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--stdin&lt;/code&gt; is specified, the command does not take &amp;lt;tree-ish&amp;gt; arguments from the command line. Instead, it reads lines containing either two &amp;lt;tree&amp;gt;, one &amp;lt;commit&amp;gt;, or a list of &amp;lt;commit&amp;gt; from its standard input. (Use a single space as separator.)</source>
          <target state="translated">とき &lt;code&gt;--stdin&lt;/code&gt; を指定され、コマンドは、コマンドラインから&amp;lt;木っぽい&amp;gt;引数を取りません。代わりに、2つの&amp;lt;tree&amp;gt;、1つの&amp;lt;commit&amp;gt;、または&amp;lt;commit&amp;gt;のリストを含む行を標準入力から読み取ります。（区切り文字として単一のスペースを使用します。）</target>
        </trans-unit>
        <trans-unit id="c23ac888d8fe422c1532e2aed10782043e7c6859" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--temp&lt;/code&gt; is used (or implied by &lt;code&gt;--stage=all&lt;/code&gt;) &lt;code&gt;git checkout-index&lt;/code&gt; will create a temporary file for each index entry being checked out. The index will not be updated with stat information. These options can be useful if the caller needs all stages of all unmerged entries so that the unmerged files can be processed by an external merge tool.</source>
          <target state="translated">とき &lt;code&gt;--temp&lt;/code&gt; が使用されている（または黙示による &lt;code&gt;--stage=all&lt;/code&gt; ） &lt;code&gt;git checkout-index&lt;/code&gt; の各インデックスエントリビーイングのための一時ファイルを作成しますが、チェックアウト。インデックスは統計情報で更新されません。これらのオプションは、マージされていないファイルを外部のマージツールで処理できるように、呼び出し元がすべてのマージされていないエントリのすべてのステージを必要とする場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="5c97ac9560dda79ead627bde39274f79b6e5dd8a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;-S&lt;/code&gt; or &lt;code&gt;-G&lt;/code&gt; are used without &lt;code&gt;--pickaxe-all&lt;/code&gt;, only filepairs that match their respective criterion are kept in the output. When &lt;code&gt;--pickaxe-all&lt;/code&gt; is used, if even one filepair matches their respective criterion in a changeset, the entire changeset is kept. This behavior is designed to make reviewing changes in the context of the whole changeset easier.</source>
          <target state="translated">とき &lt;code&gt;-S&lt;/code&gt; または &lt;code&gt;-G&lt;/code&gt; をせずに使用されている &lt;code&gt;--pickaxe-all&lt;/code&gt; 、それぞれの基準に一致のみfilepairsは出力に保存されています。とき &lt;code&gt;--pickaxe-all&lt;/code&gt; 使用されていても1 filepairがチェンジで、それぞれの基準に一致した場合、全体のチェンジが保たれています。この動作は、変更セット全体のコンテキストで変更を簡単に確認できるように設計されています。</target>
        </trans-unit>
        <trans-unit id="b7230470efbcbdb8b4c76cdcdcf3272fde68030f" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;-S&lt;/code&gt; or &lt;code&gt;-G&lt;/code&gt; finds a change, show all the changes in that changeset, not just the files that contain the change in &amp;lt;string&amp;gt;.</source>
          <target state="translated">とき &lt;code&gt;-S&lt;/code&gt; または &lt;code&gt;-G&lt;/code&gt; が変更を見つけ、そのチェンジ内のすべての変更、&amp;lt;文字列&amp;gt;の変化が含まれていないファイルだけを表示します。</target>
        </trans-unit>
        <trans-unit id="b52ce403c26e2631158c50ee6bd3c17065ed82dc" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;-u&lt;/code&gt; option is not used, untracked files and directories are shown (i.e. the same as specifying &lt;code&gt;normal&lt;/code&gt;), to help you avoid forgetting to add newly created files. Because it takes extra work to find untracked files in the filesystem, this mode may take some time in a large working tree. Consider enabling untracked cache and split index if supported (see &lt;code&gt;git update-index --untracked-cache&lt;/code&gt; and &lt;code&gt;git update-index
--split-index&lt;/code&gt;), Otherwise you can use &lt;code&gt;no&lt;/code&gt; to have &lt;code&gt;git status&lt;/code&gt; return more quickly without showing untracked files.</source>
          <target state="translated">ときに &lt;code&gt;-u&lt;/code&gt; オプションが使用されていない、人跡未踏のファイルとディレクトリが（指定するのと同じつまり、表示され &lt;code&gt;normal&lt;/code&gt; 、あなたが新たに作成されたファイルを追加し忘れ避けるために、）。ファイルシステムで追跡されていないファイルを見つけるには追加の作業が必要になるため、このモードでは、大きな作業ツリーでは時間がかかる場合があります。サポートされている場合は、追跡されていないキャッシュと分割インデックスを有効にすることを検討してください（ &lt;code&gt;git update-index --untracked-cache&lt;/code&gt; および &lt;code&gt;git update-index --split-index&lt;/code&gt; 参照）。そうでない場合は、 &lt;code&gt;no&lt;/code&gt; を使用して、追跡されていないファイルを表示せずに &lt;code&gt;git status&lt;/code&gt; より迅速に返すことができます。</target>
        </trans-unit>
        <trans-unit id="97c7c816e31485397947c4cd78f79e742f80ec39" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;-z&lt;/code&gt; output option is in effect, the output is formatted this way:</source>
          <target state="translated">とき &lt;code&gt;-z&lt;/code&gt; 出力オプションが有効である、出力はこのようにフォーマットされます。</target>
        </trans-unit>
        <trans-unit id="2bf71954fc8fac90c9030e3b9b1232971580d22a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;FETCH_HEAD&lt;/code&gt; (and no other commit) is specified, the branches recorded in the &lt;code&gt;.git/FETCH_HEAD&lt;/code&gt; file by the previous invocation of &lt;code&gt;git fetch&lt;/code&gt; for merging are merged to the current branch.</source>
          <target state="translated">とき &lt;code&gt;FETCH_HEAD&lt;/code&gt; （および他のコミットしない）が指定され、中に記録された枝 &lt;code&gt;.git/FETCH_HEAD&lt;/code&gt; の以前の呼び出しによって、ファイル &lt;code&gt;git fetch&lt;/code&gt; 現在のブランチにマージされているマージします。</target>
        </trans-unit>
        <trans-unit id="30aaf2e9dd06a0335c5f1cb4c0791345a6730170" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;core.sparseCheckoutCone&lt;/code&gt; is enabled, the input list is considered a list of directories instead of sparse-checkout patterns. The command writes patterns to the sparse-checkout file to include all files contained in those directories (recursively) as well as files that are siblings of ancestor directories. The input format matches the output of &lt;code&gt;git ls-tree --name-only&lt;/code&gt;. This includes interpreting pathnames that begin with a double quote (&quot;) as C-style quoted strings.</source>
          <target state="translated">とき &lt;code&gt;core.sparseCheckoutCone&lt;/code&gt; が有効になっている、入力リストではなく、スパース・チェックアウト・パターンのディレクトリのリストと考えられています。このコマンドは、スパースチェックアウトファイルにパターンを書き込み、それらのディレクトリに含まれるすべてのファイル（再帰的に）と、祖先ディレクトリの兄弟であるファイルを含めます。入力形式は、 &lt;code&gt;git ls-tree --name-only&lt;/code&gt; の出力と一致します。これには、二重引用符（ &quot;）で始まるパス名をCスタイルの引用符で囲まれた文字列として解釈することが含まれます。</target>
        </trans-unit>
        <trans-unit id="a79eb2995cdbf5e2d0a3c4b4e62d970b5798ea30" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;extensions.worktreeConfig&lt;/code&gt; is enabled, the config file &lt;code&gt;.git/worktrees/&amp;lt;id&amp;gt;/config.worktree&lt;/code&gt; is read after &lt;code&gt;.git/config&lt;/code&gt; is.</source>
          <target state="translated">とき &lt;code&gt;extensions.worktreeConfig&lt;/code&gt; が有効になっている、設定ファイル &lt;code&gt;.git/worktrees/&amp;lt;id&amp;gt;/config.worktree&lt;/code&gt; 後に読み込まれる &lt;code&gt;.git/config&lt;/code&gt; にあります。</target>
        </trans-unit>
        <trans-unit id="093107f57324ea8ddf834562dc5da735634ce1c2" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;fetch.fsckObjects&lt;/code&gt; or &lt;code&gt;receive.fsckObjects&lt;/code&gt; are not set, the value of this variable is used instead. Defaults to false.</source>
          <target state="translated">場合 &lt;code&gt;fetch.fsckObjects&lt;/code&gt; 又は &lt;code&gt;receive.fsckObjects&lt;/code&gt; が設定されていない、この変数の値が代わりに使用されます。デフォルトはfalseです。</target>
        </trans-unit>
        <trans-unit id="f0f4e4ab298d72d3ce878991ffe1cd2532ffab74" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;fetch.unpackLimit&lt;/code&gt; or &lt;code&gt;receive.unpackLimit&lt;/code&gt; are not set, the value of this variable is used instead. The default value is 100.</source>
          <target state="translated">場合 &lt;code&gt;fetch.unpackLimit&lt;/code&gt; 又は &lt;code&gt;receive.unpackLimit&lt;/code&gt; が設定されていない、この変数の値が代わりに使用されます。デフォルト値は100です。</target>
        </trans-unit>
        <trans-unit id="0f43e1a31ad9e45784cdafec68b8141e1a628402" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; is set, errors can be switched to warnings and vice versa by configuring the &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; setting where the &lt;code&gt;&amp;lt;msg-id&amp;gt;&lt;/code&gt; is the fsck message ID and the value is one of &lt;code&gt;error&lt;/code&gt;, &lt;code&gt;warn&lt;/code&gt; or &lt;code&gt;ignore&lt;/code&gt;. For convenience, fsck prefixes the error/warning with the message ID, e.g. &quot;missingEmail: invalid author/committer line - missing email&quot; means that setting &lt;code&gt;fsck.missingEmail = ignore&lt;/code&gt; will hide that issue.</source>
          <target state="translated">とき &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; 設定され、エラーがその逆の設定によって警告とバイスに切り替えることができ &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; 設定する場合 &lt;code&gt;&amp;lt;msg-id&amp;gt;&lt;/code&gt; のfsckメッセージIDであり、値の一つである &lt;code&gt;error&lt;/code&gt; 、 &lt;code&gt;warn&lt;/code&gt; または &lt;code&gt;ignore&lt;/code&gt; ます。便宜上、fsckはエラー/警告の前にメッセージIDを付けます。たとえば、「missingEmail：無効な作成者/コミッター行-メールがありません」は、 &lt;code&gt;fsck.missingEmail = ignore&lt;/code&gt; を設定するとその問題が非表示になることを意味します。</target>
        </trans-unit>
        <trans-unit id="ce3f108ee8253a42ecb067bc1a011bcbcd3ad290" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git apply&lt;/code&gt; is used as a &quot;better GNU patch&quot;, the user can pass the &lt;code&gt;--unsafe-paths&lt;/code&gt; option to override this safety check. This option has no effect when &lt;code&gt;--index&lt;/code&gt; or &lt;code&gt;--cached&lt;/code&gt; is in use.</source>
          <target state="translated">ときに &lt;code&gt;git apply&lt;/code&gt; 、「より良いGNUパッチ」として使用され、ユーザーが渡すことができ &lt;code&gt;--unsafe-paths&lt;/code&gt; この安全チェックを無効にするオプションを選択します。 &lt;code&gt;--index&lt;/code&gt; または &lt;code&gt;--cached&lt;/code&gt; が使用されている場合、このオプションは効果がありません。</target>
        </trans-unit>
        <trans-unit id="dea5ce8f581717a21d1ee89e4952655599f11488" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git difftool&lt;/code&gt; is invoked with this tool (either through the &lt;code&gt;-t&lt;/code&gt; or &lt;code&gt;--tool&lt;/code&gt; option or the &lt;code&gt;diff.tool&lt;/code&gt; configuration variable) the configured command line will be invoked with the following variables available: &lt;code&gt;$LOCAL&lt;/code&gt; is set to the name of the temporary file containing the contents of the diff pre-image and &lt;code&gt;$REMOTE&lt;/code&gt; is set to the name of the temporary file containing the contents of the diff post-image. &lt;code&gt;$MERGED&lt;/code&gt; is the name of the file which is being compared. &lt;code&gt;$BASE&lt;/code&gt; is provided for compatibility with custom merge tool commands and has the same value as &lt;code&gt;$MERGED&lt;/code&gt;.</source>
          <target state="translated">とき &lt;code&gt;git difftool&lt;/code&gt; 、このツール（のいずれかを通じてで呼び出され &lt;code&gt;-t&lt;/code&gt; または &lt;code&gt;--tool&lt;/code&gt; オプションまたは &lt;code&gt;diff.tool&lt;/code&gt; の設定変数）設定され、コマンドラインは、使用可能な以下の変数を使用して呼び出されます： &lt;code&gt;$LOCAL&lt;/code&gt; 、一時の名前に設定されています差分プリイメージのコンテンツを含むファイルと &lt;code&gt;$REMOTE&lt;/code&gt; は、差分ポストイメージのコンテンツを含む一時ファイルの名前に設定されます。 &lt;code&gt;$MERGED&lt;/code&gt; は、比較されているファイルの名前です。 &lt;code&gt;$BASE&lt;/code&gt; は、カスタムマージツールコマンドとの互換性のために提供されており、 &lt;code&gt;$MERGED&lt;/code&gt; と同じ値を持っています。</target>
        </trans-unit>
        <trans-unit id="02bc7953c8eb819402a97fdb05db86103d3e94f0" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git fetch&lt;/code&gt; is run with explicit branches and/or tags to fetch on the command line, e.g. &lt;code&gt;git fetch origin master&lt;/code&gt;, the &amp;lt;refspec&amp;gt;s given on the command line determine what are to be fetched (e.g. &lt;code&gt;master&lt;/code&gt; in the example, which is a short-hand for &lt;code&gt;master:&lt;/code&gt;, which in turn means &quot;fetch the &lt;code&gt;master&lt;/code&gt; branch but I do not explicitly say what remote-tracking branch to update with it from the command line&quot;), and the example command will fetch &lt;code&gt;only&lt;/code&gt; the &lt;code&gt;master&lt;/code&gt; branch. The &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; values determine which remote-tracking branch, if any, is updated. When used in this way, the &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; values do not have any effect in deciding &lt;code&gt;what&lt;/code&gt; gets fetched (i.e. the values are not used as refspecs when the command-line lists refspecs); they are only used to decide &lt;code&gt;where&lt;/code&gt; the refs that are fetched are stored by acting as a mapping.</source>
          <target state="translated">ときに &lt;code&gt;git fetch&lt;/code&gt; 例えば、コマンドラインでフェッチするために、明示的な枝および/またはタグで実行され &lt;code&gt;git fetch origin master&lt;/code&gt; 、&amp;lt;refspec&amp;gt; Sコマンドラインで与えられた例（フェッチされるかを決定 &lt;code&gt;master&lt;/code&gt; である例では、 &lt;code&gt;master:&lt;/code&gt; の省略形です。つまり、「 &lt;code&gt;master&lt;/code&gt; ブランチをフェッチしますが、コマンドラインから更新するリモートトラッキングブランチを明示的に指定することはありません」）。例のコマンドは、 &lt;code&gt;master&lt;/code&gt; ブランチ &lt;code&gt;only&lt;/code&gt; をフェッチします。 &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; 、更新された場合の値は、どのリモート追跡ブランチを決定します。このように使用すると、 &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; 値は、 &lt;code&gt;what&lt;/code&gt; をフェッチするかを決定するのに影響しません（つまり、コマンドラインがrefspecをリストするとき、値はrefspecとして使用されません）。それらは、マッピングとして機能することにより、フェッチされた参照が格納される &lt;code&gt;where&lt;/code&gt; を決定するためにのみ使用されます。</target>
        </trans-unit>
        <trans-unit id="d3bb27ea8d5739147518646e08d478432b5ac353" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git fetch&lt;/code&gt; is run without specifying what branches and/or tags to fetch on the command line, e.g. &lt;code&gt;git fetch origin&lt;/code&gt; or &lt;code&gt;git fetch&lt;/code&gt;, &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; values are used as the refspecs&amp;mdash;​they specify which refs to fetch and which local refs to update. The example above will fetch all branches that exist in the &lt;code&gt;origin&lt;/code&gt; (i.e. any ref that matches the left-hand side of the value, &lt;code&gt;refs/heads/*&lt;/code&gt;) and update the corresponding remote-tracking branches in the &lt;code&gt;refs/remotes/origin/*&lt;/code&gt; hierarchy.</source>
          <target state="translated">ときに &lt;code&gt;git fetch&lt;/code&gt; 例えば、支店および/またはタグは、コマンドラインでフェッチするかを指定せずに実行された &lt;code&gt;git fetch origin&lt;/code&gt; または &lt;code&gt;git fetch&lt;/code&gt; 、 &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; 値はrefspecs-として使用されている彼らは、レフリーがフェッチするかを指定し、更新するローカル参照。上記の例は、 &lt;code&gt;origin&lt;/code&gt; 存在するすべてのブランチ（つまり、値の左側に一致するすべてのref &lt;code&gt;refs/heads/*&lt;/code&gt; ）をフェッチし、 &lt;code&gt;refs/remotes/origin/*&lt;/code&gt; の対応するリモート追跡ブランチを更新します階層。</target>
        </trans-unit>
        <trans-unit id="6bfc306f6ccec6cbac00c82d44f7befe47671739" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git fetch&lt;/code&gt; is used with &lt;code&gt;&amp;lt;src&amp;gt;:&amp;lt;dst&amp;gt;&lt;/code&gt; refspec it may refuse to update the local branch as discussed in the &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; part below. This option overrides that check.</source>
          <target state="translated">ときに &lt;code&gt;git fetch&lt;/code&gt; で使用される &lt;code&gt;&amp;lt;src&amp;gt;:&amp;lt;dst&amp;gt;&lt;/code&gt; refspecそれはで説明したようにローカルブランチを更新するために拒否することができる &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; 下記の一部。このオプションはそのチェックを上書きします。</target>
        </trans-unit>
        <trans-unit id="b8a0a18f13c1248a211519fc4b6c3ee775403075" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git fetch&lt;/code&gt; is used with &lt;code&gt;&amp;lt;src&amp;gt;:&amp;lt;dst&amp;gt;&lt;/code&gt; refspec it may refuse to update the local branch as discussed in the &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; part of the &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt; documentation. This option overrides that check.</source>
          <target state="translated">&lt;code&gt;git fetch&lt;/code&gt; が &lt;code&gt;&amp;lt;src&amp;gt;:&amp;lt;dst&amp;gt;&lt;/code&gt; refspecで使用される場合、&lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt;ドキュメントの &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; の部分で説明されているように、ローカルブランチの更新を拒否する場合があります。このオプションはそのチェックを上書きします。</target>
        </trans-unit>
        <trans-unit id="946d45913d1a6d20975808ddb9f4de7a3a592055" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git gc&lt;/code&gt; is run, it calls &lt;code&gt;git worktree prune --expire 3.months.ago&lt;/code&gt;. This config variable can be used to set a different grace period. The value &quot;now&quot; may be used to disable the grace period and prune &lt;code&gt;$GIT_DIR/worktrees&lt;/code&gt; immediately, or &quot;never&quot; may be used to suppress pruning.</source>
          <target state="translated">とき &lt;code&gt;git gc&lt;/code&gt; 実行され、それが呼び出されます &lt;code&gt;git worktree prune --expire 3.months.ago&lt;/code&gt; 。この構成変数を使用して、異なる猶予期間を設定できます。値「now」を使用して猶予期間を無効にし、 &lt;code&gt;$GIT_DIR/worktrees&lt;/code&gt; すぐにプルーニングするか、「never」を使用してプルーニングを抑制できます。</target>
        </trans-unit>
        <trans-unit id="bdaf9b565f5bc5effacd5e94ca1e6e23df9c9f7a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git gc&lt;/code&gt; is run, it will call &lt;code&gt;prune --expire 2.weeks.ago&lt;/code&gt;. Override the grace period with this config variable. The value &quot;now&quot; may be used to disable this grace period and always prune unreachable objects immediately, or &quot;never&quot; may be used to suppress pruning. This feature helps prevent corruption when &lt;code&gt;git gc&lt;/code&gt; runs concurrently with another process writing to the repository; see the &quot;NOTES&quot; section of &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt;.</source>
          <target state="translated">とき &lt;code&gt;git gc&lt;/code&gt; 実行され、それが呼び出されます &lt;code&gt;prune --expire 2.weeks.ago&lt;/code&gt; 。この構成変数で猶予期間をオーバーライドします。値「now」を使用して、この猶予期間を無効にして常に到達不能オブジェクトをすぐにプルーニングするか、「never」を使用してプルーニングを抑制できます。この機能は、 &lt;code&gt;git gc&lt;/code&gt; がリポジトリに書き込む別のプロセスと同時に実行される場合の破損を防ぐのに役立ちます。&lt;a href=&quot;git-gc&quot;&gt;git-gc [1]&lt;/a&gt;の「NOTES」セクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="9771ab35f0db8c62ffb81b026ac116ab479df958" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git mergetool&lt;/code&gt; is invoked with this tool (either through the &lt;code&gt;-t&lt;/code&gt; or &lt;code&gt;--tool&lt;/code&gt; option or the &lt;code&gt;merge.tool&lt;/code&gt; configuration variable) the configured command line will be invoked with &lt;code&gt;$BASE&lt;/code&gt; set to the name of a temporary file containing the common base for the merge, if available; &lt;code&gt;$LOCAL&lt;/code&gt; set to the name of a temporary file containing the contents of the file on the current branch; &lt;code&gt;$REMOTE&lt;/code&gt; set to the name of a temporary file containing the contents of the file to be merged, and &lt;code&gt;$MERGED&lt;/code&gt; set to the name of the file to which the merge tool should write the result of the merge resolution.</source>
          <target state="translated">とき &lt;code&gt;git mergetool&lt;/code&gt; 、このツールで（いずれかを介して起動される &lt;code&gt;-t&lt;/code&gt; または &lt;code&gt;--tool&lt;/code&gt; オプションまたは &lt;code&gt;merge.tool&lt;/code&gt; の設定変数）に構成コマンドラインがで呼び出されます &lt;code&gt;$BASE&lt;/code&gt; ための共通基盤を含む一時ファイルの名前に設定可能な場合はマージ。 &lt;code&gt;$LOCAL&lt;/code&gt; は、現在のブランチ上のファイルの内容を含む一時ファイルの名前に設定されます。 &lt;code&gt;$REMOTE&lt;/code&gt; は、マージされるファイルの内容を含む一時ファイルの名前に設定され、 &lt;code&gt;$MERGED&lt;/code&gt; は、マージツールがマージ解決の結果を書き込むファイルの名前に設定されます。</target>
        </trans-unit>
        <trans-unit id="8d649c2a1b515f828b380ed0228639a9abf6f2e7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git-difftool&lt;/code&gt; is invoked with the &lt;code&gt;-g&lt;/code&gt; or &lt;code&gt;--gui&lt;/code&gt; option the default diff tool will be read from the configured &lt;code&gt;diff.guitool&lt;/code&gt; variable instead of &lt;code&gt;diff.tool&lt;/code&gt;. The &lt;code&gt;--no-gui&lt;/code&gt; option can be used to override this setting. If &lt;code&gt;diff.guitool&lt;/code&gt; is not set, we will fallback in the order of &lt;code&gt;merge.guitool&lt;/code&gt;, &lt;code&gt;diff.tool&lt;/code&gt;, &lt;code&gt;merge.tool&lt;/code&gt; until a tool is found.</source>
          <target state="translated">とき &lt;code&gt;git-difftool&lt;/code&gt; で呼び出される &lt;code&gt;-g&lt;/code&gt; または &lt;code&gt;--gui&lt;/code&gt; オプションデフォルトの差分ツールは、設定から読み込まれます &lt;code&gt;diff.guitool&lt;/code&gt; の変数の代わりに、 &lt;code&gt;diff.tool&lt;/code&gt; 。 &lt;code&gt;--no-gui&lt;/code&gt; のオプションは、この設定を上書きするために使用することができます。場合 &lt;code&gt;diff.guitool&lt;/code&gt; が設定されていない場合、我々は、の順にフォールバックします &lt;code&gt;merge.guitool&lt;/code&gt; 、 &lt;code&gt;diff.tool&lt;/code&gt; 、 &lt;code&gt;merge.tool&lt;/code&gt; ツールが見つかるまで。</target>
        </trans-unit>
        <trans-unit id="dab1778e78eece39a70fe4959b77fef05af95366" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git-mergetool&lt;/code&gt; is invoked with the &lt;code&gt;-g&lt;/code&gt; or &lt;code&gt;--gui&lt;/code&gt; option the default merge tool will be read from the configured &lt;code&gt;merge.guitool&lt;/code&gt; variable instead of &lt;code&gt;merge.tool&lt;/code&gt;. If &lt;code&gt;merge.guitool&lt;/code&gt; is not set, we will fallback to the tool configured under &lt;code&gt;merge.tool&lt;/code&gt;.</source>
          <target state="translated">とき &lt;code&gt;git-mergetool&lt;/code&gt; で呼び出される &lt;code&gt;-g&lt;/code&gt; または &lt;code&gt;--gui&lt;/code&gt; オプションデフォルトマージツールは、設定から読み込まれます &lt;code&gt;merge.guitool&lt;/code&gt; の代わりに変数 &lt;code&gt;merge.tool&lt;/code&gt; 。場合 &lt;code&gt;merge.guitool&lt;/code&gt; が設定されていない場合、我々は下に構成ツールにフォールバックします &lt;code&gt;merge.tool&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="55d1f905322639499a3e0c7d64b920e915841fa1" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;group&lt;/code&gt; (or &lt;code&gt;true&lt;/code&gt;), the repository is made shareable between several users in a group (making sure all the files and objects are group-writable). When &lt;code&gt;all&lt;/code&gt; (or &lt;code&gt;world&lt;/code&gt; or &lt;code&gt;everybody&lt;/code&gt;), the repository will be readable by all users, additionally to being group-shareable. When &lt;code&gt;umask&lt;/code&gt; (or &lt;code&gt;false&lt;/code&gt;), Git will use permissions reported by umask(2). When &lt;code&gt;0xxx&lt;/code&gt;, where &lt;code&gt;0xxx&lt;/code&gt; is an octal number, files in the repository will have this mode value. &lt;code&gt;0xxx&lt;/code&gt; will override user&amp;rsquo;s umask value (whereas the other options will only override requested parts of the user&amp;rsquo;s umask value). Examples: &lt;code&gt;0660&lt;/code&gt; will make the repo read/write-able for the owner and group, but inaccessible to others (equivalent to &lt;code&gt;group&lt;/code&gt; unless umask is e.g. &lt;code&gt;0022&lt;/code&gt;). &lt;code&gt;0640&lt;/code&gt; is a repository that is group-readable but not group-writable. See &lt;a href=&quot;git-init&quot;&gt;git-init[1]&lt;/a&gt;. False by default.</source>
          <target state="translated">&lt;code&gt;group&lt;/code&gt; （または &lt;code&gt;true&lt;/code&gt; ）すると、リポジトリはグループ内の複数のユーザー間で共有可能になります（すべてのファイルとオブジェクトがグループ書き込み可能であることを確認してください）。場合は &lt;code&gt;all&lt;/code&gt; （または &lt;code&gt;world&lt;/code&gt; または &lt;code&gt;everybody&lt;/code&gt; ）、リポジトリはさらに、グループ共有可能であることに、すべてのユーザーが読み取り可能になります。とき &lt;code&gt;umask&lt;/code&gt; （または &lt;code&gt;false&lt;/code&gt; ）、Gitはアクセス許可を使用しますのumask（2）により報告されました。とき &lt;code&gt;0xxx&lt;/code&gt; 、どこ &lt;code&gt;0xxx&lt;/code&gt; 進数である、リポジトリ内のファイルは、このモード値を持つことになります。 &lt;code&gt;0xxx&lt;/code&gt; はユーザーのumask値をオーバーライドします（他のオプションはユーザーのumask値の要求された部分のみをオーバーライドします）。例： &lt;code&gt;0660&lt;/code&gt; 所有者とグループはリポジトリを読み取り/書き込み可能にしますが、他のユーザーはアクセスできません（umaskが &lt;code&gt;0022&lt;/code&gt; でない限り、 &lt;code&gt;group&lt;/code&gt; と同じです）。 &lt;code&gt;0640&lt;/code&gt; は、グループは読み取り可能ですが、グループが書き込み可能ではないリポジトリーです。&lt;a href=&quot;git-init&quot;&gt;git-init [1]を&lt;/a&gt;参照してください。デフォルトではfalse。</target>
        </trans-unit>
        <trans-unit id="0c640b1443fdc376fb0e05e5b19871e0f70bfa75" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;interactive&lt;/code&gt;, enable the interactive mode of rebase.</source>
          <target state="translated">&lt;code&gt;interactive&lt;/code&gt; 場合、リベースのインタラクティブモードを有効にします。</target>
        </trans-unit>
        <trans-unit id="0e5d1d0d5309f291d73a19a6f71347b59d761978" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;konqueror&lt;/code&gt; is specified in the &lt;code&gt;man.viewer&lt;/code&gt; configuration variable, we launch &lt;code&gt;kfmclient&lt;/code&gt; to try to open the man page on an already opened konqueror in a new tab if possible.</source>
          <target state="translated">&lt;code&gt;konqueror&lt;/code&gt; が &lt;code&gt;man.viewer&lt;/code&gt; 構成変数で指定されている場合、kfmclientを起動して、 &lt;code&gt;kfmclient&lt;/code&gt; 、すでに開いているkonquerorのmanページを新しいタブで開こうとします。</target>
        </trans-unit>
        <trans-unit id="162b4f89725e01e084b1d2a9bb66f41a211da6f6" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;matching&lt;/code&gt; mode is specified, paths that explicitly match an ignored pattern are shown. If a directory matches an ignore pattern, then it is shown, but not paths contained in the ignored directory. If a directory does not match an ignore pattern, but all contents are ignored, then the directory is not shown, but all contents are shown.</source>
          <target state="translated">とき &lt;code&gt;matching&lt;/code&gt; モードが指定され、明示的に無視されたパターンと一致する経路が示されています。ディレクトリが無視パターンに一致する場合、それは表示されますが、無視されたディレクトリに含まれるパスは表示されません。ディレクトリが無視パターンに一致しないが、すべてのコンテンツが無視される場合、ディレクトリは表示されませんが、すべてのコンテンツが表示されます。</target>
        </trans-unit>
        <trans-unit id="7ee4878df1abaf60b54059eba9faa52c16598786" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;merges&lt;/code&gt; (or just &lt;code&gt;m&lt;/code&gt;), pass the &lt;code&gt;--rebase-merges&lt;/code&gt; option to &lt;code&gt;git rebase&lt;/code&gt; so that the local merge commits are included in the rebase (see &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; for details).</source>
          <target state="translated">&lt;code&gt;merges&lt;/code&gt; するとき（または単に &lt;code&gt;m&lt;/code&gt; ）、 &lt;code&gt;--rebase-merges&lt;/code&gt; &lt;code&gt;git rebase&lt;/code&gt; -mergesオプションをgit rebaseに渡して、ローカルマージコミットがリベースに含まれるようにします（詳細については、&lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]&lt;/a&gt;を参照してください）。</target>
        </trans-unit>
        <trans-unit id="239b51beb1f8c13233881b0568518d58e269df96" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;merges&lt;/code&gt;, pass the &lt;code&gt;--rebase-merges&lt;/code&gt; option to &lt;code&gt;git rebase&lt;/code&gt; so that the local merge commits are included in the rebase (see &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; for details).</source>
          <target state="translated">&lt;code&gt;merges&lt;/code&gt; する際、 &lt;code&gt;--rebase-merges&lt;/code&gt; オプションを &lt;code&gt;git rebase&lt;/code&gt; に渡して、ローカルマージコミットがリベースに含まれるようにします（詳細は&lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]&lt;/a&gt;を参照）。</target>
        </trans-unit>
        <trans-unit id="26887709475bb99a484f3550dfcf66463a02ff1c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;preserve&lt;/code&gt; (deprecated in favor of &lt;code&gt;merges&lt;/code&gt;), also pass &lt;code&gt;--preserve-merges&lt;/code&gt; along to &lt;code&gt;git rebase&lt;/code&gt; so that locally committed merge commits will not be flattened by running &lt;code&gt;git pull&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;preserve&lt;/code&gt; する場合（ &lt;code&gt;merges&lt;/code&gt; ために非推奨）、ローカルでコミットされたマージコミットが &lt;code&gt;git pull&lt;/code&gt; を実行してフラット化されないように、 &lt;code&gt;git rebase&lt;/code&gt; に &lt;code&gt;--preserve-merges&lt;/code&gt; も渡します。</target>
        </trans-unit>
        <trans-unit id="1aa5ac29106f7e567cb177a446057fe6893dfb3c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;preserve&lt;/code&gt; (or just &lt;code&gt;p&lt;/code&gt;, deprecated in favor of &lt;code&gt;merges&lt;/code&gt;), also pass &lt;code&gt;--preserve-merges&lt;/code&gt; along to &lt;code&gt;git rebase&lt;/code&gt; so that locally committed merge commits will not be flattened by running &lt;code&gt;git pull&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;preserve&lt;/code&gt; する場合（または単に &lt;code&gt;p&lt;/code&gt; 、 &lt;code&gt;merges&lt;/code&gt; を優先して非推奨）、 &lt;code&gt;--preserve-merges&lt;/code&gt; を &lt;code&gt;git rebase&lt;/code&gt; に渡して、ローカルでコミットされたマージコミットがgitpullを実行してもフラット化されないようにし &lt;code&gt;git pull&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c040d756e251986ff4d930aa40402b774da81b76" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;preserveUser&lt;/code&gt; is true, &lt;code&gt;git p4&lt;/code&gt; normally dies if it cannot find an author in the p4 user map. This setting submits the change regardless.</source>
          <target state="translated">とき &lt;code&gt;preserveUser&lt;/code&gt; が真である、 &lt;code&gt;git p4&lt;/code&gt; 、それはP4のユーザマップで著者を見つけることができない場合は正常に死にます。この設定は、関係なく変更を送信します。</target>
        </trans-unit>
        <trans-unit id="f1cb457481e4cab2531cdb48fb2ed70a72c47f80" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;receive-pack&lt;/code&gt; takes in objects, they are placed into a temporary &quot;quarantine&quot; directory within the &lt;code&gt;$GIT_DIR/objects&lt;/code&gt; directory and migrated into the main object store only after the &lt;code&gt;pre-receive&lt;/code&gt; hook has completed. If the push fails before then, the temporary directory is removed entirely.</source>
          <target state="translated">ときに &lt;code&gt;receive-pack&lt;/code&gt; オブジェクトに取り、彼らは内の一時的な「隔離」ディレクトリに配置されている &lt;code&gt;$GIT_DIR/objects&lt;/code&gt; ディレクトリをし、後にのみ、メインオブジェクトストアに移行 &lt;code&gt;pre-receive&lt;/code&gt; フックが完了しました。それ以前にプッシュが失敗した場合、一時ディレクトリは完全に削除されます。</target>
        </trans-unit>
        <trans-unit id="13eed45e8cb127a4420b06f0b52f497c696b7d45" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;text&lt;/code&gt; is set to &quot;auto&quot;, the path is marked for automatic end-of-line conversion. If Git decides that the content is text, its line endings are converted to LF on checkin. When the file has been committed with CRLF, no conversion is done.</source>
          <target state="translated">&lt;code&gt;text&lt;/code&gt; が「auto」に設定されている場合、パスは自動行末変換用にマークされます。コンテンツがテキストであるとGitが判断した場合、その行末はチェックイン時にLFに変換されます。ファイルがCRLFでコミットされている場合、変換は行われません。</target>
        </trans-unit>
        <trans-unit id="2bb8610f0d3f51c94aca7dd51e3603814301750d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;text=auto&lt;/code&gt; conversion is enabled in a cross-platform project using push and pull to a central repository the text files containing CRLFs should be normalized.</source>
          <target state="translated">場合は &lt;code&gt;text=auto&lt;/code&gt; 変換が中央リポジトリにのCRLFを含むテキストファイルをプッシュプルを使用したクロスプラットフォームのプロジェクトで有効になっている正規化されなければなりません。</target>
        </trans-unit>
        <trans-unit id="f1b569ad0a0d3f731d90377a830d25de99487fad" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;upload-pack&lt;/code&gt; has started &lt;code&gt;pack-objects&lt;/code&gt;, there may be a quiet period while &lt;code&gt;pack-objects&lt;/code&gt; prepares the pack. Normally it would output progress information, but if &lt;code&gt;--quiet&lt;/code&gt; was used for the fetch, &lt;code&gt;pack-objects&lt;/code&gt; will output nothing at all until the pack data begins. Some clients and networks may consider the server to be hung and give up. Setting this option instructs &lt;code&gt;upload-pack&lt;/code&gt; to send an empty keepalive packet every &lt;code&gt;uploadpack.keepAlive&lt;/code&gt; seconds. Setting this option to 0 disables keepalive packets entirely. The default is 5 seconds.</source>
          <target state="translated">&lt;code&gt;upload-pack&lt;/code&gt; が &lt;code&gt;pack-objects&lt;/code&gt; を開始したとき、 &lt;code&gt;pack-objects&lt;/code&gt; がパックを準備している間、静かな期間がある場合があります。通常は進捗情報を出力しますが、フェッチに &lt;code&gt;--quiet&lt;/code&gt; を使用した場合、 &lt;code&gt;pack-objects&lt;/code&gt; はパックデータが開始するまで何も出力しません。一部のクライアントとネットワークは、サーバーがハングしてあきらめたと見なす場合があります。このオプションを指示する設定 &lt;code&gt;upload-pack&lt;/code&gt; 空のキープアライブパケットごとに送信するための &lt;code&gt;uploadpack.keepAlive&lt;/code&gt; 秒。このオプションを0に設定すると、キープアライブパケットが完全に無効になります。デフォルトは5秒です。</target>
        </trans-unit>
        <trans-unit id="09ea8c9e4617731ed2a0cdf40185d39ec477e171" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;uploadpack.hideRefs&lt;/code&gt; is in effect, allow &lt;code&gt;upload-pack&lt;/code&gt; to accept a fetch request that asks for an object at the tip of a hidden ref (by default, such a request is rejected). See also &lt;code&gt;uploadpack.hideRefs&lt;/code&gt;. Even if this is false, a client may be able to steal objects via the techniques described in the &quot;SECURITY&quot; section of the &lt;a href=&quot;gitnamespaces&quot;&gt;gitnamespaces[7]&lt;/a&gt; man page; it&amp;rsquo;s best to keep private data in a separate repository.</source>
          <target state="translated">&lt;code&gt;uploadpack.hideRefs&lt;/code&gt; が有効な場合、非表示の参照の先端にあるオブジェクトを要求するフェッチ要求を受け入れるように、 &lt;code&gt;upload-pack&lt;/code&gt; に許可します（デフォルトでは、そのような要求は拒否されます）。 &lt;code&gt;uploadpack.hideRefs&lt;/code&gt; も参照してください。これがfalseの場合でも、クライアントは&lt;a href=&quot;gitnamespaces&quot;&gt;gitnamespaces [7]の&lt;/a&gt; manページの「SECURITY」セクションで説明されている手法を使用してオブジェクトを盗む可能性があります。プライベートデータは別のリポジトリに保存することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="5f953a201b0ae4d35f35034718b3114ef928787f" translate="yes" xml:space="preserve">
          <source>When Git doesn&amp;rsquo;t know how to handle a certain transport protocol, it attempts to use the &lt;code&gt;remote-&amp;lt;transport&amp;gt;&lt;/code&gt; remote helper, if one exists. To explicitly request a remote helper, the following syntax may be used:</source>
          <target state="translated">Gitが特定のトランスポートプロトコルの処理方法を知らない場合、リモートヘルパーが存在する場合は、リモートヘルパー &lt;code&gt;remote-&amp;lt;transport&amp;gt;&lt;/code&gt; を使用しようとします。リモートヘルパーを明示的に要求するには、次の構文を使用できます。</target>
        </trans-unit>
        <trans-unit id="cf58a154a8f8fa8889640812d376b7964ce7bef2" translate="yes" xml:space="preserve">
          <source>When Git encounters a URL of the form &lt;code&gt;&amp;lt;transport&amp;gt;://&amp;lt;address&amp;gt;&lt;/code&gt;, where &lt;code&gt;&amp;lt;transport&amp;gt;&lt;/code&gt; is a protocol that it cannot handle natively, it automatically invokes &lt;code&gt;git remote-&amp;lt;transport&amp;gt;&lt;/code&gt; with the full URL as the second argument. If such a URL is encountered directly on the command line, the first argument is the same as the second, and if it is encountered in a configured remote, the first argument is the name of that remote.</source>
          <target state="translated">Gitが &lt;code&gt;&amp;lt;transport&amp;gt;://&amp;lt;address&amp;gt;&lt;/code&gt; という形式のURLを検出すると、 &lt;code&gt;&amp;lt;transport&amp;gt;&lt;/code&gt; はネイティブで処理できないプロトコルであり、2番目の引数として完全なURLを指定して &lt;code&gt;git remote-&amp;lt;transport&amp;gt;&lt;/code&gt; を自動的に呼び出します。そのようなURLがコマンドラインで直接検出される場合、最初の引数は2番目の引数と同じです。構成されたリモートで検出される場合、最初の引数はそのリモートの名前です。</target>
        </trans-unit>
        <trans-unit id="27018e5bb4c8622ebcfed2f81b80284203c3bc2f" translate="yes" xml:space="preserve">
          <source>When Git encounters the first file that needs to be cleaned or smudged, it starts the filter and performs the handshake. In the handshake, the welcome message sent by Git is &quot;git-filter-client&quot;, only version 2 is supported, and the supported capabilities are &quot;clean&quot;, &quot;smudge&quot;, and &quot;delay&quot;.</source>
          <target state="translated">Gitは、クリーン化やスマッジが必要な最初のファイルに遭遇すると、フィルターを起動してハンドシェイクを実行します。ハンドシェイクでは、Gitが送るウェルカムメッセージは「git-filter-client」、サポートされているのはバージョン2のみで、サポートされている機能は「clean」「smudge」「delay」です。</target>
        </trans-unit>
        <trans-unit id="f51f886a7edb2e397d8670010685e9d17fb9bc09" translate="yes" xml:space="preserve">
          <source>When Git needs authentication for a particular URL context, credential-store will consider that context a pattern to match against each entry in the credentials file. If the protocol, hostname, and username (if we already have one) match, then the password is returned to Git. See the discussion of configuration in &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials[7]&lt;/a&gt; for more information.</source>
          <target state="translated">Gitが特定のURLコンテキストの認証を必要とする場合、credential-storeは、そのコンテキストを、信任状ファイルの各エントリーと照合するパターンと見なします。プロトコル、ホスト名、およびユーザー名（既にある場合）が一致すると、パスワードがGitに返されます。詳細については、&lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials [7]の&lt;/a&gt;構成の説明を参照してください。</target>
        </trans-unit>
        <trans-unit id="fbdc4494c8c569621bd35073fd02055c267f7e54" translate="yes" xml:space="preserve">
          <source>When Git needs to show you a diff for the path with &lt;code&gt;diff&lt;/code&gt; attribute set to &lt;code&gt;jcdiff&lt;/code&gt;, it calls the command you specified with the above configuration, i.e. &lt;code&gt;j-c-diff&lt;/code&gt;, with 7 parameters, just like &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; program is called. See &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt; for details.</source>
          <target state="translated">Gitは、 &lt;code&gt;diff&lt;/code&gt; 属性が &lt;code&gt;jcdiff&lt;/code&gt; に設定されたパスの差分を表示する必要がある場合、 &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; プログラムが呼び出されるのと同じように、上記の構成で指定したコマンド、つまり &lt;code&gt;j-c-diff&lt;/code&gt; を7つのパラメーターで呼び出します。詳細については、&lt;a href=&quot;git&quot;&gt;git [1]&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="bb3065603615c6a64dfcb623c10f42c6b9e417fa" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;git push --signed&lt;/code&gt; sent a push certificate with a &quot;nonce&quot; that was issued by a receive-pack serving the same repository within this many seconds, export the &quot;nonce&quot; found in the certificate to &lt;code&gt;GIT_PUSH_CERT_NONCE&lt;/code&gt; to the hooks (instead of what the receive-pack asked the sending side to include). This may allow writing checks in &lt;code&gt;pre-receive&lt;/code&gt; and &lt;code&gt;post-receive&lt;/code&gt; a bit easier. Instead of checking &lt;code&gt;GIT_PUSH_CERT_NONCE_SLOP&lt;/code&gt; environment variable that records by how many seconds the nonce is stale to decide if they want to accept the certificate, they only can check &lt;code&gt;GIT_PUSH_CERT_NONCE_STATUS&lt;/code&gt; is &lt;code&gt;OK&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git push --signed&lt;/code&gt; が、この数秒以内に同じリポジトリを提供する受信パックによって発行された「nonce」を含むプッシュ証明書を送信したとき、証明書で見つかった「nonce」をフックに（代わりに） &lt;code&gt;GIT_PUSH_CERT_NONCE&lt;/code&gt; にエクスポートします受信パックが送信側に含めるように要求したもの）。これは、中に小切手を書くことを可能にする &lt;code&gt;pre-receive&lt;/code&gt; と &lt;code&gt;post-receive&lt;/code&gt; 少し簡単。ナンスが古くなっている秒数を記録する &lt;code&gt;GIT_PUSH_CERT_NONCE_SLOP&lt;/code&gt; 環境変数をチェックして証明書を受け入れるかどうかを決定する代わりに、 &lt;code&gt;GIT_PUSH_CERT_NONCE_STATUS&lt;/code&gt; が &lt;code&gt;OK&lt;/code&gt; かどうかのみをチェックできます。</target>
        </trans-unit>
        <trans-unit id="f34a76491c47ddfcf2959dd6944574eeda479afa" translate="yes" xml:space="preserve">
          <source>When a command has finished, and the client has received the entire response from the server, a client can either request that another command be executed or can terminate the connection. A client may optionally send an empty request consisting of just a flush-pkt to indicate that no more requests will be made.</source>
          <target state="translated">コマンドが終了し、クライアントがサーバーからの応答全体を受け取ったとき、クライアントは別のコマンドの実行を 要求するか、接続を終了するかのいずれかを行うことができる。クライアントはオプションで、これ以上のリクエストが行われないことを示すために flush-pkt だけで構成される空のリクエストを送ることができます。</target>
        </trans-unit>
        <trans-unit id="98e606d10b24cc0c03b08a4efd9e014e2a7d092f" translate="yes" xml:space="preserve">
          <source>When a commit is created in this state, the branch is updated to refer to the new commit. Specifically, &lt;code&gt;git commit&lt;/code&gt; creates a new commit &lt;code&gt;d&lt;/code&gt;, whose parent is commit &lt;code&gt;c&lt;/code&gt;, and then updates branch &lt;code&gt;master&lt;/code&gt; to refer to new commit &lt;code&gt;d&lt;/code&gt;. &lt;code&gt;HEAD&lt;/code&gt; still refers to branch &lt;code&gt;master&lt;/code&gt; and so indirectly now refers to commit &lt;code&gt;d&lt;/code&gt;:</source>
          <target state="translated">この状態でコミットが作成されると、新しいコミットを参照するようにブランチが更新されます。具体的には、 &lt;code&gt;git commit&lt;/code&gt; 新しいを作成し、コミット &lt;code&gt;d&lt;/code&gt; その親コミットされ、 &lt;code&gt;c&lt;/code&gt; 、そしてブランチ更新 &lt;code&gt;master&lt;/code&gt; 新しいコミットを参照するために &lt;code&gt;d&lt;/code&gt; 。 &lt;code&gt;HEAD&lt;/code&gt; はまだブランチ &lt;code&gt;master&lt;/code&gt; を指しているため、間接的にcommit &lt;code&gt;d&lt;/code&gt; を指します。</target>
        </trans-unit>
        <trans-unit id="b5e6d106b45c449ef3f9978fa7e9a2c319abd6d7" translate="yes" xml:space="preserve">
          <source>When a conflict occurs while rebasing, rebase stops and asks the user to resolve. Since the user may need to make notable changes while resolving conflicts, after conflicts are resolved and the user has run &lt;code&gt;git rebase --continue&lt;/code&gt;, the rebase should open an editor and ask the user to update the commit message. The merge backend does this, while the apply backend blindly applies the original commit message.</source>
          <target state="translated">リベース中に競合が発生すると、リベースは停止し、ユーザーに解決を求めます。ユーザーは競合の解決中に注目すべき変更を加える必要がある場合があるため、競合が解決され、ユーザーが &lt;code&gt;git rebase --continue&lt;/code&gt; を実行した後、リベースはエディターを開き、ユーザーにコミットメッセージの更新を依頼する必要があります。マージバックエンドはこれを行いますが、適用バックエンドは元のコミットメッセージを盲目的に適用します。</target>
        </trans-unit>
        <trans-unit id="a1d656a10ad8d92cd23d5675fa9c3ba2b92a8d6f" translate="yes" xml:space="preserve">
          <source>When a curl trace is enabled (see &lt;code&gt;GIT_TRACE_CURL&lt;/code&gt; above), do not dump data (that is, only dump info lines and headers).</source>
          <target state="translated">curlトレースが有効な場合（上記の &lt;code&gt;GIT_TRACE_CURL&lt;/code&gt; を参照）、データをダンプしないでください（つまり、情報行とヘッダーのみをダンプします）。</target>
        </trans-unit>
        <trans-unit id="855748d09cda03242c615ed9f83d928cff4dd252" translate="yes" xml:space="preserve">
          <source>When a fetch mirror is created with &lt;code&gt;--mirror=fetch&lt;/code&gt;, the refs will not be stored in the &lt;code&gt;refs/remotes/&lt;/code&gt; namespace, but rather everything in &lt;code&gt;refs/&lt;/code&gt; on the remote will be directly mirrored into &lt;code&gt;refs/&lt;/code&gt; in the local repository. This option only makes sense in bare repositories, because a fetch would overwrite any local commits.</source>
          <target state="translated">フェッチミラーが &lt;code&gt;--mirror=fetch&lt;/code&gt; で作成されると、 &lt;code&gt;refs/remotes/&lt;/code&gt; はrefs / remotes /名前空間に保存されませんが、リモートの &lt;code&gt;refs/&lt;/code&gt; すべてがローカルリポジトリの &lt;code&gt;refs/&lt;/code&gt; に直接ミラーリングされます。フェッチはローカルコミットを上書きするため、このオプションはベアリポジトリでのみ意味があります。</target>
        </trans-unit>
        <trans-unit id="747511f053f093bdd8637c2efa65029ba86d5e79" translate="yes" xml:space="preserve">
          <source>When a git process is a (direct or indirect) child of another git process, it inherits Trace2 context information. This allows the child to print the command hierarchy. This example shows gc as child[3] of fetch. When the gc process reports its name as &quot;gc&quot;, it also reports the hierarchy as &quot;fetch/gc&quot;. (In this example, trace2 messages from the child process is indented for clarity.)</source>
          <target state="translated">git プロセスが他の git プロセスの (直接的または間接的な)子プロセスである場合、Trace2 のコンテキスト情報を継承します。これにより、子プロセスはコマンド階層を表示することができます。この例では、gc を fetch の child[3]としています。gc プロセスが自分の名前を &quot;gc&quot; と報告すると、階層も &quot;fetch/gc&quot; と報告します。(この例では、わかりやすくするために、子プロセスからのtrace2メッセージをインデントしています)。</target>
        </trans-unit>
        <trans-unit id="dcc866e382263d0b053b9eb6226d8321d2b6f3a3" translate="yes" xml:space="preserve">
          <source>When a helper is executed, it will have one &quot;operation&quot; argument appended to its command line, which is one of:</source>
          <target state="translated">ヘルパーが実行されると、そのヘルパーはそのコマンドラインに1つの &quot;操作 &quot;引数が追加されます。</target>
        </trans-unit>
        <trans-unit id="79294381fcaa0a0dccaa2b41ac29dc7daa74e3f5" translate="yes" xml:space="preserve">
          <source>When a local branch is started off a remote-tracking branch, Git sets up the branch (specifically the &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; and &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; configuration entries) so that &lt;code&gt;git pull&lt;/code&gt; will appropriately merge from the remote-tracking branch. This behavior may be changed via the global &lt;code&gt;branch.autoSetupMerge&lt;/code&gt; configuration flag. That setting can be overridden by using the &lt;code&gt;--track&lt;/code&gt; and &lt;code&gt;--no-track&lt;/code&gt; options, and changed later using &lt;code&gt;git branch --set-upstream-to&lt;/code&gt;.</source>
          <target state="translated">ローカルブランチがリモートトラッキングブランチから開始されると、Gitはブランチ（特に、 &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; および &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; 構成エントリ）をセットアップして、 &lt;code&gt;git pull&lt;/code&gt; がリモートブランチから適切にマージされるようにします追跡ブランチ。この動作は、グローバル &lt;code&gt;branch.autoSetupMerge&lt;/code&gt; 構成フラグを介して変更できます。この設定は &lt;code&gt;--track&lt;/code&gt; および &lt;code&gt;--no-track&lt;/code&gt; オプションを使用してオーバーライドでき、後で &lt;code&gt;git branch --set-upstream-to&lt;/code&gt; を使用して変更できます。</target>
        </trans-unit>
        <trans-unit id="dbb99a5451930fe8366dedb022737c46385ca3a6" translate="yes" xml:space="preserve">
          <source>When a merge commit is included by &lt;code&gt;--show-pulls&lt;/code&gt;, the merge is treated as if it &quot;pulled&quot; the change from another branch. When using &lt;code&gt;--show-pulls&lt;/code&gt; on this example (and no other options) the resulting graph is:</source>
          <target state="translated">マージコミットが &lt;code&gt;--show-pulls&lt;/code&gt; に含まれている場合、マージは別のブランチから変更を「プル」したかのように扱われます。この例で &lt;code&gt;--show-pulls&lt;/code&gt; を使用すると（他のオプションは使用しない場合）、結果のグラフは次のようになります。</target>
        </trans-unit>
        <trans-unit id="8e12783acd89ac9262429bc89fcf85d9b95e88c1" translate="yes" xml:space="preserve">
          <source>When a merge conflict happens during switching branches with the &lt;code&gt;-m&lt;/code&gt; option, you would see something like this:</source>
          <target state="translated">&lt;code&gt;-m&lt;/code&gt; オプションを使用してブランチを切り替えるときにマージの競合が発生すると、次のようになります。</target>
        </trans-unit>
        <trans-unit id="8b8f6236a48634fd451e67557b1ed432c992a4a6" translate="yes" xml:space="preserve">
          <source>When a merge conflict happens, the index entries for conflicting paths are left unmerged, and you need to resolve the conflicts and mark the resolved paths with &lt;code&gt;git add&lt;/code&gt; (or &lt;code&gt;git rm&lt;/code&gt; if the merge should result in deletion of the path).</source>
          <target state="translated">マージの競合が発生すると、競合するパスのインデックスエントリはマージされないままになるため、競合を解決し、解決されたパスを &lt;code&gt;git add&lt;/code&gt; （またはマージによってパスが削除される場合は &lt;code&gt;git rm&lt;/code&gt; )でマークする必要があります。</target>
        </trans-unit>
        <trans-unit id="054b9e9957838ff74728498487ffff5f26346d88" translate="yes" xml:space="preserve">
          <source>When a merge isn&amp;rsquo;t resolved automatically, Git leaves the index and the working tree in a special state that gives you all the information you need to help resolve the merge.</source>
          <target state="translated">マージが自動的に解決されない場合、Gitはインデックスと作業ツリーを特別な状態にして、マージの解決に必要なすべての情報を提供します。</target>
        </trans-unit>
        <trans-unit id="1d6b6e4ed4a39cb92155b19d26f3a8478b8d6d5c" translate="yes" xml:space="preserve">
          <source>When a new branch is created with &lt;code&gt;git branch&lt;/code&gt;, &lt;code&gt;git switch&lt;/code&gt; or &lt;code&gt;git checkout&lt;/code&gt; that tracks another branch, this variable tells Git to set up pull to rebase instead of merge (see &quot;branch.&amp;lt;name&amp;gt;.rebase&quot;). When &lt;code&gt;never&lt;/code&gt;, rebase is never automatically set to true. When &lt;code&gt;local&lt;/code&gt;, rebase is set to true for tracked branches of other local branches. When &lt;code&gt;remote&lt;/code&gt;, rebase is set to true for tracked branches of remote-tracking branches. When &lt;code&gt;always&lt;/code&gt;, rebase will be set to true for all tracking branches. See &quot;branch.autoSetupMerge&quot; for details on how to set up a branch to track another branch. This option defaults to never.</source>
          <target state="translated">別のブランチを追跡する &lt;code&gt;git branch&lt;/code&gt; 、 &lt;code&gt;git switch&lt;/code&gt; または &lt;code&gt;git checkout&lt;/code&gt; を使用して新しいブランチが作成されると、この変数はマージの代わりにリベースするプルを設定するようにGitに指示します（「branch。&amp;lt;name&amp;gt; .rebase」を参照）。 &lt;code&gt;never&lt;/code&gt; の場合、リベースが自動的にtrueに設定されることはありません。 &lt;code&gt;local&lt;/code&gt; の場合、他のローカルブランチの追跡されたブランチに対してrebaseがtrueに設定されます。 &lt;code&gt;remote&lt;/code&gt; の場合、リモート追跡ブランチの追跡ブランチに対してrebaseがtrueに設定されます。ときは &lt;code&gt;always&lt;/code&gt; 、リベースは、すべての追跡ブランチをtrueに設定されます。ブランチをセットアップして別のブランチを追跡する方法の詳細については、「branch.autoSetupMerge」を参照してください。このオプションのデフォルトは決してありません。</target>
        </trans-unit>
        <trans-unit id="ed0adff8e63a6741e1694d5ebc304264bd392424" translate="yes" xml:space="preserve">
          <source>When a patch failure occurs, &amp;lt;msg&amp;gt; will be printed to the screen before exiting. This overrides the standard message informing you to use &lt;code&gt;--continue&lt;/code&gt; or &lt;code&gt;--skip&lt;/code&gt; to handle the failure. This is solely for internal use between &lt;code&gt;git rebase&lt;/code&gt; and &lt;code&gt;git am&lt;/code&gt;.</source>
          <target state="translated">パッチ障害が発生すると、終了する前に&amp;lt;msg&amp;gt;が画面に出力されます。これにより、 &lt;code&gt;--continue&lt;/code&gt; または &lt;code&gt;--skip&lt;/code&gt; を使用して失敗を処理するように通知する標準メッセージが上書きされます。これは &lt;code&gt;git rebase&lt;/code&gt; と &lt;code&gt;git am&lt;/code&gt; の間の内部使用専用です。</target>
        </trans-unit>
        <trans-unit id="d5b066fa036c4bb98c79472fbdf38de3d119f100" translate="yes" xml:space="preserve">
          <source>When a patch is part of an ongoing discussion, the patch generated by &lt;code&gt;git format-patch&lt;/code&gt; can be tweaked to take advantage of the &lt;code&gt;git am --scissors&lt;/code&gt; feature. After your response to the discussion comes a line that consists solely of &quot;&lt;code&gt;-- &amp;gt;8 --&lt;/code&gt;&quot; (scissors and perforation), followed by the patch with unnecessary header fields removed:</source>
          <target state="translated">パッチが進行中の議論の一部である場合、 &lt;code&gt;git format-patch&lt;/code&gt; によって生成されたパッチを調整して、 &lt;code&gt;git am --scissors&lt;/code&gt; 機能を利用できます。ディスカッションに対する応答の後に、「 &lt;code&gt;-- &amp;gt;8 --&lt;/code&gt; 」（はさみとミシン目）のみで構成される行が続き、不要なヘッダーフィールドが削除されたパッチが続きます。</target>
        </trans-unit>
        <trans-unit id="f3cb24e54c9837370739d06bd25b8c911a05ee6b" translate="yes" xml:space="preserve">
          <source>When a path is in the &quot;unmerged&quot; state, running &lt;code&gt;git update-index&lt;/code&gt; for that path tells Git to mark the path resolved.</source>
          <target state="translated">パスが「マージされていない」状態の場合、そのパスに対して &lt;code&gt;git update-index&lt;/code&gt; を実行すると、Gitにパスを解決済みとしてマークするように指示します。</target>
        </trans-unit>
        <trans-unit id="f8965008f9824bf8da0b033710c2d7ac1f3f6568" translate="yes" xml:space="preserve">
          <source>When a pure mode change is encountered (which has no index information), the information is read from the current index instead.</source>
          <target state="translated">純粋なモード変更(インデックス情報を持たない)に遭遇した場合、代わりに現在のインデックスから情報が読み込まれます。</target>
        </trans-unit>
        <trans-unit id="ef4651b07e5b8cb97cb93de85df1d7e556426d24" translate="yes" xml:space="preserve">
          <source>When a push mirror is created with &lt;code&gt;--mirror=push&lt;/code&gt;, then &lt;code&gt;git push&lt;/code&gt; will always behave as if &lt;code&gt;--mirror&lt;/code&gt; was passed.</source>
          <target state="translated">&lt;code&gt;--mirror=push&lt;/code&gt; を使用してプッシュミラーを作成すると、 &lt;code&gt;git push&lt;/code&gt; は常に &lt;code&gt;--mirror&lt;/code&gt; が渡されたかのように動作します。</target>
        </trans-unit>
        <trans-unit id="deb13d30f8ba66c920f6495f36b99921916b0fbc" translate="yes" xml:space="preserve">
          <source>When a rebase required merge conflicts to be resolved, compare the changes introduced by the rebase directly afterwards using:</source>
          <target state="translated">リベースでマージの競合を解決する必要があった場合、リベースで導入された変更を直接比較するには、次のように使用します。</target>
        </trans-unit>
        <trans-unit id="350766930233515327656bc7b70b13214a7aa33c" translate="yes" xml:space="preserve">
          <source>When a ref is updated, reflog entries are created to keep track of the reason why the ref was updated (which is typically the name of the high-level command that updated the ref), in addition to the old and new values of the ref. A scripted Porcelain command can use set_reflog_action helper function in &lt;code&gt;git-sh-setup&lt;/code&gt; to set its name to this variable when it is invoked as the top level command by the end user, to be recorded in the body of the reflog.</source>
          <target state="translated">refが更新されると、refの古い値と新しい値に加えて、refが更新された理由（通常は、refを更新した高レベルコマンドの名前）を追跡するためのreflogエントリが作成されます。 。スクリプト化されたPorcelainコマンドは、 &lt;code&gt;git-sh-setup&lt;/code&gt; の set_reflog_actionヘルパー関数を使用して、エンドユーザーがトップレベルのコマンドとして呼び出されたときにその名前をこの変数に設定し、reflogの本文に記録できます。</target>
        </trans-unit>
        <trans-unit id="0a564cf0d83332d2cd6fd3ac884cec9942b078c7" translate="yes" xml:space="preserve">
          <source>When a repository is synchronized via &lt;code&gt;git push&lt;/code&gt; and &lt;code&gt;git pull&lt;/code&gt; objects packed in the source repository are usually stored unpacked in the destination. While this allows you to use different packing strategies on both ends, it also means you may need to repack both repositories every once in a while.</source>
          <target state="translated">リポジトリが &lt;code&gt;git push&lt;/code&gt; および &lt;code&gt;git pull&lt;/code&gt; を介して同期されると、ソースリポジトリにパックされたオブジェクトは通常、解凍されて宛先に格納されます。これにより、両端で異なるパッキング戦略を使用できるようになりますが、両方のリポジトリをたまに再パッキングする必要がある場合もあります。</target>
        </trans-unit>
        <trans-unit id="89c3a76b400f69bc409951d41f44580e1ce5b550" translate="yes" xml:space="preserve">
          <source>When a scripting language specific quoting is in effect, everything between a top-level opening atom and its matching %(end) is evaluated according to the semantics of the opening atom and only its result from the top-level is quoted.</source>
          <target state="translated">スクリプト言語固有のクォートが有効な場合、トップレベルのオープニング・アトムとそれにマッチする %(end)の間のすべてがオープニング・アトムのセマンティクスに従って評価され、トップレベルからの結果のみがクォートされます。</target>
        </trans-unit>
        <trans-unit id="1d0d6b410e7d083b396401fa9485dd3214d89132" translate="yes" xml:space="preserve">
          <source>When a variable is said to take a boolean value, many synonyms are accepted for &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;; these are all case-insensitive.</source>
          <target state="translated">変数がブール値を取ると言われる場合、多くの同義語は &lt;code&gt;true&lt;/code&gt; と &lt;code&gt;false&lt;/code&gt; で受け入れられます。これらはすべて大文字と小文字を区別しません。</target>
        </trans-unit>
        <trans-unit id="085e4eddfd9be8c4f3b576466769939a6475604e" translate="yes" xml:space="preserve">
          <source>When accepting a new code drop for a vendor branch, you probably want to record both the removal of paths and additions of new paths as well as modifications of existing paths.</source>
          <target state="translated">ベンダーブランチの新しいコードドロップを受け入れる際には、既存のパスの変更だけでなく、パスの削除と新しいパスの追加の両方を記録したいと思うでしょう。</target>
        </trans-unit>
        <trans-unit id="98d4ec1ab85d43886cf359223c5c65ec41aa50b0" translate="yes" xml:space="preserve">
          <source>When accepting a signed push (see &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;), the signed push certificate is stored in a blob and an environment variable &lt;code&gt;GIT_PUSH_CERT&lt;/code&gt; can be consulted for its object name. See the description of &lt;code&gt;post-receive&lt;/code&gt; hook for an example. In addition, the certificate is verified using GPG and the result is exported with the following environment variables:</source>
          <target state="translated">署名付きプッシュを受け入れるとき（&lt;a href=&quot;git-push&quot;&gt;git-push [1]を&lt;/a&gt;参照）、署名付きプッシュ証明書はblobに保存され、環境変数 &lt;code&gt;GIT_PUSH_CERT&lt;/code&gt; でオブジェクト名を調べることができます。例については、 &lt;code&gt;post-receive&lt;/code&gt; フックの説明を参照してください。さらに、証明書はGPGを使用して検証され、結果は次の環境変数とともにエクスポートされます。</target>
        </trans-unit>
        <trans-unit id="5d78f94855bee5654824b328b5c74fbbbf68d2ce" translate="yes" xml:space="preserve">
          <source>When acquiring credentials, consider the &quot;path&quot; component of an http or https URL to be important. Defaults to false. See &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials[7]&lt;/a&gt; for more information.</source>
          <target state="translated">資格情報を取得するときは、httpまたはhttpsのURLの「パス」コンポーネントが重要であると考えてください。デフォルトはfalseです。詳細については、&lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials [7]&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="36125e3b1dadcf8415f427875bfbe6e3edb592ec" translate="yes" xml:space="preserve">
          <source>When adding notes to an object that already has notes, overwrite the existing notes (instead of aborting).</source>
          <target state="translated">すでにノートがあるオブジェクトにノートを追加する場合は、既存のノートを上書きします(アボートするのではなく)。</target>
        </trans-unit>
        <trans-unit id="31a6893d1f507cb4bce24b6631d6f67bbe0ca8c3" translate="yes" xml:space="preserve">
          <source>When advertising tips of available history from an alternate, use the shell to execute the specified command instead of &lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref[1]&lt;/a&gt;. The first argument is the absolute path of the alternate. Output must contain one hex object id per line (i.e., the same as produced by &lt;code&gt;git for-each-ref
--format='%(objectname)'&lt;/code&gt;).</source>
          <target state="translated">利用可能な履歴のヒントを代替からアドバタイズする場合は、&lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref [1]の&lt;/a&gt;代わりにシェルを使用して、指定されたコマンドを実行します。最初の引数は、代替の絶対パスです。出力には、1行に1つの16進オブジェクトIDが含まれている必要があります（つまり、 &lt;code&gt;git for-each-ref --format='%(objectname)'&lt;/code&gt; によって生成されるものと同じです）。</target>
        </trans-unit>
        <trans-unit id="aee562f05eaa47b0988f9365fa4403a675334ce1" translate="yes" xml:space="preserve">
          <source>When an argument can be misunderstood as either a revision or a path, they can be disambiguated by placing &lt;code&gt;--&lt;/code&gt; between them. E.g. &lt;code&gt;git diff -- HEAD&lt;/code&gt; is, &quot;I have a file called HEAD in my work tree. Please show changes between the version I staged in the index and what I have in the work tree for that file&quot;, not &quot;show difference between the HEAD commit and the work tree as a whole&quot;. You can say &lt;code&gt;git diff HEAD --&lt;/code&gt; to ask for the latter.</source>
          <target state="translated">引数がリビジョンまたはパスのいずれかと誤解される可能性がある場合は、それらの間に &lt;code&gt;--&lt;/code&gt; を置くことにより、曖昧さをなくすことができます。例： &lt;code&gt;git diff -- HEAD&lt;/code&gt; は、「ワークツリーにHEADというファイルがあります。インデックスでステージングしたバージョンとそのファイルのワークツリーにあるものの違いを表示してください」ではなく、「 HEADコミットとワークツリー全体」 &lt;code&gt;git diff HEAD --&lt;/code&gt; 後者を要求するように言うことができます。</target>
        </trans-unit>
        <trans-unit id="8ed1e316e9f06aa8f0fbb451acc5e5dd1d53d618" translate="yes" xml:space="preserve">
          <source>When an argument may be understood either as a reference or as a file name, choose to understand it as a format-patch argument (&lt;code&gt;--format-patch&lt;/code&gt;) or as a file name (&lt;code&gt;--no-format-patch&lt;/code&gt;). By default, when such a conflict occurs, git send-email will fail.</source>
          <target state="translated">引数が参照またはファイル名のいずれかとして理解される可能性がある場合、それをフォーマットパッチ引数（ &lt;code&gt;--format-patch&lt;/code&gt; ）またはファイル名（ &lt;code&gt;--no-format-patch&lt;/code&gt; ）として理解することを選択します。デフォルトでは、このような競合が発生すると、git send-emailは失敗します。</target>
        </trans-unit>
        <trans-unit id="daa45faaafc93f57dcfa6219226fd8a2224c7353" translate="yes" xml:space="preserve">
          <source>When an interactive command (such as &lt;code&gt;git add --patch&lt;/code&gt;) shows a colorized diff, git will pipe the diff through the shell command defined by this configuration variable. The command may mark up the diff further for human consumption, provided that it retains a one-to-one correspondence with the lines in the original diff. Defaults to disabled (no filtering).</source>
          <target state="translated">対話型コマンド（ &lt;code&gt;git add --patch&lt;/code&gt; など）がカラー化された差分を表示する場合、gitはこの構成変数で定義されたシェルコマンドに差分をパイプします。コマンドは、元の差分の行との1対1の対応を保持している場合に限り、人間が使用できるように差分をさらにマークアップできます。デフォルトは無効（フィルタリングなし）です。</target>
        </trans-unit>
        <trans-unit id="66bd09d84d7f728fe64b22afe9c1d5b02faccf2f" translate="yes" xml:space="preserve">
          <source>When an optional Git branch name (or a Git commit object name) is specified as an argument, the subcommand works on the specified branch, not on the current branch.</source>
          <target state="translated">オプションの Git ブランチ名 (あるいは Git コミットオブジェクト名)を引数に指定すると、このサブコマンドは現在のブランチではなく指定したブランチで動作します。</target>
        </trans-unit>
        <trans-unit id="54600ca959ccb5286a6125f852754e8a441f6246" translate="yes" xml:space="preserve">
          <source>When an update changes a branch (or more in general, a ref) that used to point at commit A to point at another commit B, it is called a fast-forward update if and only if B is a descendant of A.</source>
          <target state="translated">コミット A を指していたブランチ (あるいは一般的には ref)を別のコミット B を指すように更新する場合、B が A の子孫である場合に限り、早送り更新と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="b999dfcfa57d71ee62dbc42f4d8a0527e63491d1" translate="yes" xml:space="preserve">
          <source>When applying a patch, detect a new or modified line that has whitespace errors. What are considered whitespace errors is controlled by &lt;code&gt;core.whitespace&lt;/code&gt; configuration. By default, trailing whitespaces (including lines that solely consist of whitespaces) and a space character that is immediately followed by a tab character inside the initial indent of the line are considered whitespace errors.</source>
          <target state="translated">パッチを適用するときに、空白エラーのある新しい行または変更された行を検出します。空白エラーと見なされるものは、 &lt;code&gt;core.whitespace&lt;/code&gt; 構成によって制御されます。デフォルトでは、末尾の空白（空白のみで構成される行を含む）および行の最初のインデント内の直後にタブ文字が続く空白文字は、空白エラーと見なされます。</target>
        </trans-unit>
        <trans-unit id="b3581e25b4edfc3eae85f688560f931e31414d31" translate="yes" xml:space="preserve">
          <source>When applying a patch, ignore additions made by the patch. This can be used to extract the common part between two files by first running &lt;code&gt;diff&lt;/code&gt; on them and applying the result with this option, which would apply the deletion part but not the addition part.</source>
          <target state="translated">パッチを適用するときは、パッチによる追加を無視してください。これを使用して、最初に2つのファイルで &lt;code&gt;diff&lt;/code&gt; を実行し、このオプションで結果を適用することにより、2つのファイル間の共通部分を抽出できます。これにより、削除部分は適用されますが、追加部分は適用されません。</target>
        </trans-unit>
        <trans-unit id="6bf2c606b0bf760a50dfcc2e9e2a1dfc6d6ce1b9" translate="yes" xml:space="preserve">
          <source>When applying a patch, ignore changes in whitespace in context lines if necessary. Context lines will preserve their whitespace, and they will not undergo whitespace fixing regardless of the value of the &lt;code&gt;--whitespace&lt;/code&gt; option. New lines will still be fixed, though.</source>
          <target state="translated">パッチを適用するときは、必要に応じてコンテキスト行の空白の変更を無視してください。コンテキスト行は空白を保持し、 &lt;code&gt;--whitespace&lt;/code&gt; オプションの値に関係なく空白の修正は行われません。ただし、新しい行は修正されます。</target>
        </trans-unit>
        <trans-unit id="588f408b6e1e0374e87fb8fe5ff6e5cd0dca42b8" translate="yes" xml:space="preserve">
          <source>When applying the patch only to the working tree, mark new files to be added to the index later (see &lt;code&gt;--intent-to-add&lt;/code&gt; option in &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt;). This option is ignored unless running in a Git repository and &lt;code&gt;--index&lt;/code&gt; is not specified. Note that &lt;code&gt;--index&lt;/code&gt; could be implied by other options such as &lt;code&gt;--cached&lt;/code&gt; or &lt;code&gt;--3way&lt;/code&gt;.</source>
          <target state="translated">作業ツリーのみにパッチを適用する場合、後でインデックスに追加する新しいファイルにマークを付けます（&lt;a href=&quot;git-add&quot;&gt;git-add [1]の&lt;/a&gt; &lt;code&gt;--intent-to-add&lt;/code&gt; オプションを参照）。このオプションは、Gitリポジトリで実行され、 &lt;code&gt;--index&lt;/code&gt; が指定されていない場合は無視されます。 &lt;code&gt;--index&lt;/code&gt; は &lt;code&gt;--cached&lt;/code&gt; や &lt;code&gt;--3way&lt;/code&gt; などの他のオプションによって暗示される可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="59fa333bf5332a3a74a0fa1b62097787ae41682d" translate="yes" xml:space="preserve">
          <source>When asking to &lt;code&gt;abort&lt;/code&gt; (which is the default), this program will die when encountering a signed tag. With &lt;code&gt;strip&lt;/code&gt;, the tags will silently be made unsigned, with &lt;code&gt;warn-strip&lt;/code&gt; they will be made unsigned but a warning will be displayed, with &lt;code&gt;verbatim&lt;/code&gt;, they will be silently exported and with &lt;code&gt;warn&lt;/code&gt;, they will be exported, but you will see a warning.</source>
          <target state="translated">&lt;code&gt;abort&lt;/code&gt; するように要求すると（これはデフォルトです）、このプログラムは署名されたタグに遭遇すると終了します。では &lt;code&gt;strip&lt;/code&gt; 、とタグが静かに、未署名の行われる &lt;code&gt;warn-strip&lt;/code&gt; で、彼らは符号なし行われますが、警告が表示されます &lt;code&gt;verbatim&lt;/code&gt; 、彼らは静かに輸出されるとして &lt;code&gt;warn&lt;/code&gt; 、それらがエクスポートされますが、あなたは警告が表示されます。</target>
        </trans-unit>
        <trans-unit id="a094fa226ab8da9ad05df22ffe9e8c64cbd9aea9" translate="yes" xml:space="preserve">
          <source>When asking to &lt;code&gt;abort&lt;/code&gt; (which is the default), this program will die when encountering such a tag. With &lt;code&gt;drop&lt;/code&gt; it will omit such tags from the output. With &lt;code&gt;rewrite&lt;/code&gt;, if the tagged object is a commit, it will rewrite the tag to tag an ancestor commit (via parent rewriting; see &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;abort&lt;/code&gt; を要求する場合（デフォルト）、このプログラムはそのようなタグに遭遇すると終了します。 &lt;code&gt;drop&lt;/code&gt; それは出力から、このようなタグを省略します。 &lt;code&gt;rewrite&lt;/code&gt; タグ付きオブジェクトがコミットである場合、それは（;参照親書き換えを介してコミット祖先をタグ付けするタグを書き換えるであろう&lt;a href=&quot;git-rev-list&quot;&gt;[1]のgit-REV-リスト&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="034f3e54dc418fd0aaba391926e4cdc6f9338cc5" translate="yes" xml:space="preserve">
          <source>When called with &lt;code&gt;--incremental&lt;/code&gt; option, the command outputs the result as it is built. The output generally will talk about lines touched by more recent commits first (i.e. the lines will be annotated out of order) and is meant to be used by interactive viewers.</source>
          <target state="translated">&lt;code&gt;--incremental&lt;/code&gt; オプションを指定して呼び出すと、コマンドはビルド時に結果を出力します。出力は一般に、最近のコミットによって最初に触れられた行について話します（つまり、行は順不同で注釈が付けられます）。インタラクティブなビューアによって使用されることを意図しています。</target>
        </trans-unit>
        <trans-unit id="37ed40c0b9c191bc52be1eea56e95c21c8c30c92" translate="yes" xml:space="preserve">
          <source>When checking out paths from the index, check out stage #2 (&lt;code&gt;ours&lt;/code&gt;) or #3 (&lt;code&gt;theirs&lt;/code&gt;) for unmerged paths.</source>
          <target state="translated">インデックスからパスをチェックアウトするときは、マージされていないパスのステージ＃2（ &lt;code&gt;ours&lt;/code&gt; ）または＃3（ &lt;code&gt;theirs&lt;/code&gt; ）をチェックアウトします。</target>
        </trans-unit>
        <trans-unit id="b2d7eb083886da1526ca38a6780f9e98825df5e6" translate="yes" xml:space="preserve">
          <source>When checking out paths from the index, do not fail upon unmerged entries; instead, unmerged entries are ignored.</source>
          <target state="translated">インデックスからのパスをチェックアウトする際には、マージされていないエントリで失敗しないようにしてください。</target>
        </trans-unit>
        <trans-unit id="87b021689017efd0b4fbe642f48fde6408f7cde4" translate="yes" xml:space="preserve">
          <source>When checking out paths from the index, this option lets you recreate the conflicted merge in the specified paths.</source>
          <target state="translated">インデックスからパスをチェックアウトする際に、このオプションを使用すると、指定したパス内の競合するマージを再作成することができます。</target>
        </trans-unit>
        <trans-unit id="44968c91f62b2f1c7eb77848556b128eac9d4512" translate="yes" xml:space="preserve">
          <source>When cloning an SVN repository, if none of the options for describing the repository layout is used (--trunk, --tags, --branches, --stdlayout), &lt;code&gt;git svn clone&lt;/code&gt; will create a Git repository with completely linear history, where branches and tags appear as separate directories in the working copy. While this is the easiest way to get a copy of a complete repository, for projects with many branches it will lead to a working copy many times larger than just the trunk. Thus for projects using the standard directory structure (trunk/branches/tags), it is recommended to clone with option &lt;code&gt;--stdlayout&lt;/code&gt;. If the project uses a non-standard structure, and/or if branches and tags are not required, it is easiest to only clone one directory (typically trunk), without giving any repository layout options. If the full history with branches and tags is required, the options &lt;code&gt;--trunk&lt;/code&gt; / &lt;code&gt;--branches&lt;/code&gt; / &lt;code&gt;--tags&lt;/code&gt; must be used.</source>
          <target state="translated">SVNリポジトリのクローンを作成するときに、リポジトリレイアウトを説明するオプション（--trunk、-tags、-branches、-stdlayout）を使用しない場合、 &lt;code&gt;git svn clone&lt;/code&gt; は完全に線形の履歴を持つGitリポジトリを作成します。ブランチとタグは、作業コピーの個別のディレクトリとして表示されます。これは完全なリポジトリのコピーを取得する最も簡単な方法ですが、多くのブランチを持つプロジェクトの場合、トランクよりも何倍も大きい作業コピーが作成されます。したがって、標準のディレクトリ構造（trunk / branches / tags）を使用するプロジェクトでは、オプション &lt;code&gt;--stdlayout&lt;/code&gt; を使用してクローンを作成することをお勧めします。プロジェクトで非標準の構造を使用している場合や、ブランチやタグが不要な場合は、リポジトリレイアウトオプションを指定せずに、1つのディレクトリ（通常はトランク）のみを複製するのが最も簡単です。ブランチとタグの完全な履歴が必要な場合、オプション &lt;code&gt;--trunk&lt;/code&gt; / &lt;code&gt;--branches&lt;/code&gt; / &lt;code&gt;--tags&lt;/code&gt; を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="cf5bdc8ee9de0e891bd2e2ffd6ad5374a27fb398" translate="yes" xml:space="preserve">
          <source>When cloning or pulling a repository containing submodules the submodules will not be checked out by default; You can instruct &lt;code&gt;clone&lt;/code&gt; to recurse into submodules. The &lt;code&gt;init&lt;/code&gt; and &lt;code&gt;update&lt;/code&gt; subcommands of &lt;code&gt;git submodule&lt;/code&gt; will maintain submodules checked out and at an appropriate revision in your working tree. Alternatively you can set &lt;code&gt;submodule.recurse&lt;/code&gt; to have &lt;code&gt;checkout&lt;/code&gt; recursing into submodules.</source>
          <target state="translated">サブモジュールを含むリポジトリを複製またはプルするとき、サブモジュールはデフォルトではチェックアウトされません。 &lt;code&gt;clone&lt;/code&gt; にサブモジュールに再帰するように指示できます。 &lt;code&gt;git submodule&lt;/code&gt; の &lt;code&gt;init&lt;/code&gt; および &lt;code&gt;update&lt;/code&gt; サブコマンドは、チェックアウトされたサブモジュールと作業ツリーの適切なリビジョンを維持します。または、 &lt;code&gt;submodule.recurse&lt;/code&gt; を設定して、 &lt;code&gt;checkout&lt;/code&gt; をサブモジュールに再帰させることもできます。</target>
        </trans-unit>
        <trans-unit id="2bdda0ba49ff183f8b76fb42fb3146b89e404d42" translate="yes" xml:space="preserve">
          <source>When cloning or pulling a repository containing submodules the submodules will not be checked out by default; you can instruct &lt;code&gt;clone&lt;/code&gt; to recurse into submodules. The &lt;code&gt;init&lt;/code&gt; and &lt;code&gt;update&lt;/code&gt; subcommands of &lt;code&gt;git submodule&lt;/code&gt; will maintain submodules checked out and at an appropriate revision in your working tree. Alternatively you can set &lt;code&gt;submodule.recurse&lt;/code&gt; to have &lt;code&gt;checkout&lt;/code&gt; recursing into submodules (note that &lt;code&gt;submodule.recurse&lt;/code&gt; also affects other Git commands, see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for a complete list).</source>
          <target state="translated">サブモジュールを含むリポジトリのクローンを作成またはプルする場合、サブモジュールはデフォルトでチェックアウトされません。サブモジュールに再帰するように &lt;code&gt;clone&lt;/code&gt; に指示できます。 &lt;code&gt;git submodule&lt;/code&gt; の &lt;code&gt;init&lt;/code&gt; および &lt;code&gt;update&lt;/code&gt; サブコマンドは、チェックアウトされたサブモジュールを作業ツリーの適切なリビジョンに維持します。または、 &lt;code&gt;submodule.recurse&lt;/code&gt; を設定して、 &lt;code&gt;checkout&lt;/code&gt; をサブモジュールに再帰的に設定することもできます（ &lt;code&gt;submodule.recurse&lt;/code&gt; は他のGitコマンドにも影響します。完全なリストについては、&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;を参照してください）。</target>
        </trans-unit>
        <trans-unit id="e96f700dec6ecf67635f001fe97af20a3a1af7ba" translate="yes" xml:space="preserve">
          <source>When combining multiple &lt;code&gt;--contains&lt;/code&gt; and &lt;code&gt;--no-contains&lt;/code&gt; filters, only references that contain at least one of the &lt;code&gt;--contains&lt;/code&gt; commits and contain none of the &lt;code&gt;--no-contains&lt;/code&gt; commits are shown.</source>
          <target state="translated">複数の &lt;code&gt;--contains&lt;/code&gt; フィルターと &lt;code&gt;--no-contains&lt;/code&gt; フィルターを組み合わせる場合、少なくとも1つの &lt;code&gt;--contains&lt;/code&gt; コミットを含み、-no &lt;code&gt;--no-contains&lt;/code&gt; コミットを含まない参照のみが表示されます。</target>
        </trans-unit>
        <trans-unit id="3693ecef45adf0e594fc21eeb7dc1180a98b303e" translate="yes" xml:space="preserve">
          <source>When combining multiple &lt;code&gt;--merged&lt;/code&gt; and &lt;code&gt;--no-merged&lt;/code&gt; filters, only references that are reachable from at least one of the &lt;code&gt;--merged&lt;/code&gt; commits and from none of the &lt;code&gt;--no-merged&lt;/code&gt; commits are shown.</source>
          <target state="translated">複数の &lt;code&gt;--merged&lt;/code&gt; フィルターと &lt;code&gt;--no-merged&lt;/code&gt; フィルターを組み合わせる場合、少なくとも1つの &lt;code&gt;--merged&lt;/code&gt; コミットから到達可能であり、-no &lt;code&gt;--no-merged&lt;/code&gt; コミットのいずれからも到達できない参照のみが表示されます。</target>
        </trans-unit>
        <trans-unit id="f6f5e261fa8e1325a05e77f0fa02cd4e804a016b" translate="yes" xml:space="preserve">
          <source>When committing fixups, consider using &lt;code&gt;merge&lt;/code&gt; to connect the commit(s) which are supplying file revisions to the fixup branch. Doing so will allow tools such as &lt;code&gt;git blame&lt;/code&gt; to track through the real commit history and properly annotate the source files.</source>
          <target state="translated">フィックスアップをコミットするときは、 &lt;code&gt;merge&lt;/code&gt; を使用して、ファイルリビジョンを提供しているコミットをフィックスアップブランチに接続することを検討してください。そうすることで、 &lt;code&gt;git blame&lt;/code&gt; などのツールが実際のコミット履歴を追跡し、ソースファイルに適切に注釈を付けることができます。</target>
        </trans-unit>
        <trans-unit id="187746ad8497cb1dac2dfe493269450955422d85" translate="yes" xml:space="preserve">
          <source>When committing to svn from Git (as part of &lt;code&gt;set-tree&lt;/code&gt; or &lt;code&gt;dcommit&lt;/code&gt; operations), if the existing log message doesn&amp;rsquo;t already have a &lt;code&gt;From:&lt;/code&gt; or &lt;code&gt;Signed-off-by:&lt;/code&gt; line, append a &lt;code&gt;From:&lt;/code&gt; line based on the Git commit&amp;rsquo;s author string. If you use this, then &lt;code&gt;--use-log-author&lt;/code&gt; will retrieve a valid author string for all commits.</source>
          <target state="translated">（ &lt;code&gt;set-tree&lt;/code&gt; または &lt;code&gt;dcommit&lt;/code&gt; 操作の一部として）Gitからsvnにコミットするときに、既存のログメッセージに &lt;code&gt;From:&lt;/code&gt; または &lt;code&gt;Signed-off-by:&lt;/code&gt; 行がない場合、Gitコミットに基づいて &lt;code&gt;From:&lt;/code&gt; 行を追加します著者の文字列。これを使用すると、 &lt;code&gt;--use-log-author&lt;/code&gt; はすべてのコミットに対して有効な作成者文字列を取得します。</target>
        </trans-unit>
        <trans-unit id="df4d9e8de337675930b7c7d126c3cbfdb0d919e8" translate="yes" xml:space="preserve">
          <source>When common porcelain operations that create objects are run, they will check whether the repository has grown substantially since the last maintenance, and if so run &lt;code&gt;git gc&lt;/code&gt; automatically. See &lt;code&gt;gc.auto&lt;/code&gt; below for how to disable this behavior.</source>
          <target state="translated">オブジェクトを作成する一般的な磁器操作が実行されると、最後のメンテナンス以降、リポジトリが大幅に増加しているかどうかが確認され、そうであれば &lt;code&gt;git gc&lt;/code&gt; が自動的に実行されます。この動作を無効にする方法については、以下の &lt;code&gt;gc.auto&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="5cef5cc19d56f034a0850f6ce0dc6add0c966a70" translate="yes" xml:space="preserve">
          <source>When comparing two trees, the ID of both trees (separated by a space and terminated by a newline) is printed before the difference. When comparing commits, the ID of the first (or only) commit, followed by a newline, is printed.</source>
          <target state="translated">2つのツリーを比較する場合、両方のツリーのID(スペースで区切られ、改行で終わる)が差分の前に表示されます。コミットを比較する場合、最初の (または唯一の)コミットの ID が表示され、その後に改行が続きます。</target>
        </trans-unit>
        <trans-unit id="fe249445673b1134855083e0c3b366c4aeeb2c8e" translate="yes" xml:space="preserve">
          <source>When converting a value to its canonical form using the &lt;code&gt;--type=bool&lt;/code&gt; type specifier, &lt;code&gt;git config&lt;/code&gt; will ensure that the output is &quot;true&quot; or &quot;false&quot; (spelled in lowercase).</source>
          <target state="translated">&lt;code&gt;--type=bool&lt;/code&gt; タイプ指定子を使用して値を正規の形式に変換する場合、 &lt;code&gt;git config&lt;/code&gt; は出力が「true」または「false」（小文字のスペル）であることを確認します。</target>
        </trans-unit>
        <trans-unit id="5800d8777d6f116b967a3c4b503079e04a8dd27b" translate="yes" xml:space="preserve">
          <source>When copying a remote repository, you&amp;rsquo;ll want to at a minimum update the index cache when you do this, and especially with other peoples' repositories you often want to make sure that the index cache is in some known state (you don&amp;rsquo;t know &lt;strong&gt;what&lt;/strong&gt; they&amp;rsquo;ve done and not yet checked in), so usually you&amp;rsquo;ll precede the &lt;code&gt;git update-index&lt;/code&gt; with a</source>
          <target state="translated">リモートリポジトリをコピーするときは、少なくともこの操作を行うときにインデックスキャッシュを更新する必要があります。特に他の人のリポジトリでは、インデックスキャッシュが既知の状態であることを確認したい場合があります（知って&lt;strong&gt;どのような&lt;/strong&gt;ので、通常、あなたが先行するだろう、彼らは）行われ、まだチェックインいませんでした &lt;code&gt;git update-index&lt;/code&gt; Aと</target>
        </trans-unit>
        <trans-unit id="a0c9c076efebd050282e8220820bf37e469a5914" translate="yes" xml:space="preserve">
          <source>When copying notes during a rewrite (see the &quot;notes.rewrite.&amp;lt;command&amp;gt;&quot; option), determines what to do if the target commit already has a note. Must be one of &lt;code&gt;overwrite&lt;/code&gt;, &lt;code&gt;concatenate&lt;/code&gt;, &lt;code&gt;cat_sort_uniq&lt;/code&gt;, or &lt;code&gt;ignore&lt;/code&gt;. Defaults to &lt;code&gt;concatenate&lt;/code&gt;.</source>
          <target state="translated">書き換え中にメモをコピーする場合（「notes.rewrite。&amp;lt;command&amp;gt;」オプションを参照）、ターゲットのコミットに既にメモがある場合の処理​​を決定します。 &lt;code&gt;overwrite&lt;/code&gt; 、 &lt;code&gt;concatenate&lt;/code&gt; 、 &lt;code&gt;cat_sort_uniq&lt;/code&gt; 、または &lt;code&gt;ignore&lt;/code&gt; のいずれかである必要があります。デフォルトでは &lt;code&gt;concatenate&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="f2daf889c63a8ae3ef0bd84b9e0a7bae3186ea5d" translate="yes" xml:space="preserve">
          <source>When copying notes during a rewrite, specifies the (fully qualified) ref whose notes should be copied. May be a glob, in which case notes in all matching refs will be copied. You may also specify this configuration several times.</source>
          <target state="translated">書き換え中にノートをコピーする場合、ノートをコピーする(完全修飾された)ref を指定します。グロブであってもよいが、その場合、一致するすべての ref のノートがコピーされる。この設定は複数回指定することもできます。</target>
        </trans-unit>
        <trans-unit id="c445d369a5c50740a59f3ad28697ace644e2811e" translate="yes" xml:space="preserve">
          <source>When copying notes during a rewrite, specifies the (fully qualified) ref whose notes should be copied. The ref may be a glob, in which case notes in all matching refs will be copied. You may also specify this configuration several times.</source>
          <target state="translated">書き換え中にノートをコピーする場合、ノートをコピーする(完全修飾された)ref を指定します。ref はグロブである可能性があり、その場合、一致するすべての ref のノートがコピーされます。この設定は複数回指定することもできます。</target>
        </trans-unit>
        <trans-unit id="1243aaab79ff33e7a2d49c8eb8b4f16703a1c016" translate="yes" xml:space="preserve">
          <source>When copying notes during a rewrite, what to do if the target commit already has a note. Must be one of &lt;code&gt;overwrite&lt;/code&gt;, &lt;code&gt;concatenate&lt;/code&gt;, &lt;code&gt;cat_sort_uniq&lt;/code&gt;, or &lt;code&gt;ignore&lt;/code&gt;. Defaults to &lt;code&gt;concatenate&lt;/code&gt;.</source>
          <target state="translated">書き換え中にメモをコピーするときに、ターゲットコミットに既にメモがある場合の対処方法。 &lt;code&gt;overwrite&lt;/code&gt; 、 &lt;code&gt;concatenate&lt;/code&gt; 、 &lt;code&gt;cat_sort_uniq&lt;/code&gt; 、または &lt;code&gt;ignore&lt;/code&gt; のいずれかである必要があります。デフォルトでは &lt;code&gt;concatenate&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="fb6ea94e62e06bb5ee870300111df0d9f630f320" translate="yes" xml:space="preserve">
          <source>When copying notes during a rewrite, what to do if the target commit already has a note. Must be one of &lt;code&gt;overwrite&lt;/code&gt;, &lt;code&gt;concatenate&lt;/code&gt;, &lt;code&gt;cat_sort_uniq&lt;/code&gt;, or &lt;code&gt;ignore&lt;/code&gt;. This overrides the &lt;code&gt;core.rewriteMode&lt;/code&gt; setting.</source>
          <target state="translated">書き換え中にメモをコピーするときに、ターゲットコミットに既にメモがある場合の対処方法。 &lt;code&gt;overwrite&lt;/code&gt; 、 &lt;code&gt;concatenate&lt;/code&gt; 、 &lt;code&gt;cat_sort_uniq&lt;/code&gt; 、または &lt;code&gt;ignore&lt;/code&gt; のいずれかである必要があります。これは、 &lt;code&gt;core.rewriteMode&lt;/code&gt; 設定をオーバーライドします。</target>
        </trans-unit>
        <trans-unit id="fa7e030aba2e9a9a4e5882753f19d2b4a66b4e16" translate="yes" xml:space="preserve">
          <source>When creating a new branch, if &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is a branch, mark it as &quot;upstream&quot; from the new branch. This is the default if &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is a remote-tracking branch. See &quot;--track&quot; in &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; for details.</source>
          <target state="translated">新しいブランチを作成するときに、 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; がブランチである場合、新しいブランチの「上流」としてマークします。 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; がリモート追跡ブランチの場合、これがデフォルトです。詳細については、&lt;a href=&quot;git-branch&quot;&gt;git-branch [1]の&lt;/a&gt;「--track」を参照してください。</target>
        </trans-unit>
        <trans-unit id="4e04dc75cba18b40521f918d2128a9cc7f50298f" translate="yes" xml:space="preserve">
          <source>When creating a new branch, if &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is a branch, mark it as &quot;upstream&quot; from the new branch. This is the default if &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is a remote-tracking branch. See &lt;code&gt;--track&lt;/code&gt; in &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; for details.</source>
          <target state="translated">新しいブランチを作成するときに、 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; がブランチである場合は、新しいブランチの「アップストリーム」としてマークします。 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; がリモート追跡ブランチの場合、これがデフォルトです。詳細 &lt;code&gt;--track&lt;/code&gt; は、&lt;a href=&quot;git-branch&quot;&gt;git-branch [1]の&lt;/a&gt;--trackを参照してください。</target>
        </trans-unit>
        <trans-unit id="54d8049451fa958ada38921d90347d3ee7c4d771" translate="yes" xml:space="preserve">
          <source>When creating a new branch, set up &quot;upstream&quot; configuration. &lt;code&gt;-c&lt;/code&gt; is implied. See &lt;code&gt;--track&lt;/code&gt; in &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; for details.</source>
          <target state="translated">新しいブランチを作成するときは、「アップストリーム」構成をセットアップします。 &lt;code&gt;-c&lt;/code&gt; が暗示されます。詳細 &lt;code&gt;--track&lt;/code&gt; は、&lt;a href=&quot;git-branch&quot;&gt;git-branch [1]の&lt;/a&gt;--trackを参照してください。</target>
        </trans-unit>
        <trans-unit id="fc590aa31fec73c4296b9f428640a84b6d3e91a7" translate="yes" xml:space="preserve">
          <source>When creating a new branch, set up &quot;upstream&quot; configuration. See &quot;--track&quot; in &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; for details.</source>
          <target state="translated">新しいブランチを作成するときは、「アップストリーム」構成をセットアップします。詳細については、&lt;a href=&quot;git-branch&quot;&gt;git-branch [1]の&lt;/a&gt;「--track」を参照してください。</target>
        </trans-unit>
        <trans-unit id="67211ea9327a11f7c102d4d6622e44707e57316e" translate="yes" xml:space="preserve">
          <source>When creating a new branch, set up &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; and &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; configuration entries to mark the start-point branch as &quot;upstream&quot; from the new branch. This configuration will tell git to show the relationship between the two branches in &lt;code&gt;git status&lt;/code&gt; and &lt;code&gt;git branch -v&lt;/code&gt;. Furthermore, it directs &lt;code&gt;git pull&lt;/code&gt; without arguments to pull from the upstream when the new branch is checked out.</source>
          <target state="translated">新しいブランチを作成するときは、 &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; と &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; 構成エントリを設定して、開始点ブランチを新しいブランチの「上流」としてマークします。この構成は、 &lt;code&gt;git status&lt;/code&gt; 2つのブランチと &lt;code&gt;git branch -v&lt;/code&gt; の関係を示すようにgitに指示します。さらに、新しいブランチがチェックアウトされるときに、引数なしで &lt;code&gt;git pull&lt;/code&gt; に上流からプルするように指示します。</target>
        </trans-unit>
        <trans-unit id="30421c6d8900807173aa121649f943a72b9b4dbe" translate="yes" xml:space="preserve">
          <source>When creating a packed archive in a repository that has existing packs, the command reuses existing deltas. This sometimes results in a slightly suboptimal pack. This flag tells the command not to reuse existing deltas but compute them from scratch.</source>
          <target state="translated">既存のパックがあるリポジトリでパックされたアーカイブを作成する場合、コマンドは既存のデルタを再利用します。これにより、わずかに最適ではないパックになってしまうことがあります。このフラグは、既存のデルタを再利用せず、ゼロから計算するようにコマンドに指示します。</target>
        </trans-unit>
        <trans-unit id="40641904740525d3a46d2f53ea1f042429403d62" translate="yes" xml:space="preserve">
          <source>When creating files, prepend &amp;lt;string&amp;gt; (usually a directory including a trailing /)</source>
          <target state="translated">ファイルを作成するときは、&amp;lt;string&amp;gt;（通常、末尾に/を含むディレクトリ）を付加します。</target>
        </trans-unit>
        <trans-unit id="55d2573d14b31c180f96244b6210a62251fe4b79" translate="yes" xml:space="preserve">
          <source>When dealing with &lt;code&gt;git diff-tree&lt;/code&gt; output, it takes advantage of the fact that the patch is prefixed with the object name of the commit, and outputs two 40-byte hexadecimal strings. The first string is the patch ID, and the second string is the commit ID. This can be used to make a mapping from patch ID to commit ID.</source>
          <target state="translated">&lt;code&gt;git diff-tree&lt;/code&gt; 出力を処理する場合、パッチの先頭にコミットのオブジェクト名が付けられるという事実を利用して、2つの40バイトの16進数文字列を出力します。最初の文字列はパッチIDで、2番目の文字列はコミットIDです。これは、パッチIDからコミットIDへのマッピングを作成するために使用できます。</target>
        </trans-unit>
        <trans-unit id="d776ef3252048cd13183a8501d7c0015731386cd" translate="yes" xml:space="preserve">
          <source>When deciding what attributes are assigned to a path, Git consults &lt;code&gt;$GIT_DIR/info/attributes&lt;/code&gt; file (which has the highest precedence), &lt;code&gt;.gitattributes&lt;/code&gt; file in the same directory as the path in question, and its parent directories up to the toplevel of the work tree (the further the directory that contains &lt;code&gt;.gitattributes&lt;/code&gt; is from the path in question, the lower its precedence). Finally global and system-wide files are considered (they have the lowest precedence).</source>
          <target state="translated">パスに割り当てる属性を決定するとき、Gitは &lt;code&gt;$GIT_DIR/info/attributes&lt;/code&gt; ファイル（優先順位が最も高い）、問題のパスと同じディレクトリにある &lt;code&gt;.gitattributes&lt;/code&gt; ファイル、およびその最上位レベルまでの親ディレクトリを調べます作業ツリー（ &lt;code&gt;.gitattributes&lt;/code&gt; を含むディレクトリが問題のパスから遠いほど、優先順位が低くなります）。最後に、グローバルファイルとシステム全体のファイルが考慮されます（優先順位が最も低くなります）。</target>
        </trans-unit>
        <trans-unit id="be47e73cae5925c270f0353e0b448f44fba38688" translate="yes" xml:space="preserve">
          <source>When deinitialized or deleted (see below), the submodule&amp;rsquo;s Git directory is automatically moved to &lt;code&gt;$GIT_DIR/modules/&amp;lt;name&amp;gt;/&lt;/code&gt; of the superproject.</source>
          <target state="translated">初期化解除または削除（下記参照）すると、サブモジュールのGitディレクトリはスーパー &lt;code&gt;$GIT_DIR/modules/&amp;lt;name&amp;gt;/&lt;/code&gt; に自動的に移動されます。</target>
        </trans-unit>
        <trans-unit id="d6198e5c096df70165a4ba7282b14c9062838d85" translate="yes" xml:space="preserve">
          <source>When displaying names of reachable objects, in addition to the SHA-1 also display a name that describes &lt;strong&gt;how&lt;/strong&gt; they are reachable, compatible with &lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse[1]&lt;/a&gt;, e.g. &lt;code&gt;HEAD@{1234567890}~25^2:src/&lt;/code&gt;.</source>
          <target state="translated">到達可能なオブジェクトの名前を表示する場合、SHA-1に加えて、到達可能性を説明する名前も表示され&lt;strong&gt;ます。&lt;/strong&gt;これは&lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse [1]&lt;/a&gt;と互換性があります（例： &lt;code&gt;HEAD@{1234567890}~25^2:src/&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="39ccc422d97039f55d5b75b982904e65809f0ab0" translate="yes" xml:space="preserve">
          <source>When doing a dry-run, give the output in a porcelain-ready format. See &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; for details. Implies &lt;code&gt;--dry-run&lt;/code&gt;.</source>
          <target state="translated">予行演習を行う場合は、磁器に対応した形式で出力してください。参照&lt;a href=&quot;git-status&quot;&gt;のgit-状態[1]&lt;/a&gt;詳細については、を。意味 &lt;code&gt;--dry-run&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="91fdf83cd4cf2351c13b94fc0d59dcd9a51c5b73" translate="yes" xml:space="preserve">
          <source>When doing a dry-run, give the output in the long-format. Implies &lt;code&gt;--dry-run&lt;/code&gt;.</source>
          <target state="translated">予行演習を行うときは、出力を長形式で提供します。意味 &lt;code&gt;--dry-run&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7320eee3c7f6d76666dfe697952518d827846a03" translate="yes" xml:space="preserve">
          <source>When doing a dry-run, give the output in the short-format. See &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; for details. Implies &lt;code&gt;--dry-run&lt;/code&gt;.</source>
          <target state="translated">予行演習を行う場合は、短い形式で出力してください。詳細については、&lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt;を参照してください。意味 &lt;code&gt;--dry-run&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9aa102d4a4b04252e6d4b5a0080dce309ef777d4" translate="yes" xml:space="preserve">
          <source>When doing a repository conversion, use a unique mark per commit (&lt;code&gt;mark :&amp;lt;n&amp;gt;&lt;/code&gt;) and supply the --export-marks option on the command line. fast-import will dump a file which lists every mark and the Git object SHA-1 that corresponds to it. If the frontend can tie the marks back to the source repository, it is easy to verify the accuracy and completeness of the import by comparing each Git commit to the corresponding source revision.</source>
          <target state="translated">リポジトリ変換を行うときは、コミットごとに一意のマーク（ &lt;code&gt;mark :&amp;lt;n&amp;gt;&lt;/code&gt; ）を使用し、コマンドラインで--export-marksオプションを指定します。 fast-importは、すべてのマークとそれに対応するGitオブジェクトSHA-1をリストしたファイルをダンプします。フロントエンドがマークをソースリポジトリに結び付けることができる場合、各Gitコミットを対応するソースリビジョンと比較することで、インポートの正確さと完全性を簡単に検証できます。</target>
        </trans-unit>
        <trans-unit id="6f397bf185a0b1be7403f8c718221517e54d79b2" translate="yes" xml:space="preserve">
          <source>When editing the commit message, start the editor with the contents in the given file. The &lt;code&gt;commit.template&lt;/code&gt; configuration variable is often used to give this option implicitly to the command. This mechanism can be used by projects that want to guide participants with some hints on what to write in the message in what order. If the user exits the editor without editing the message, the commit is aborted. This has no effect when a message is given by other means, e.g. with the &lt;code&gt;-m&lt;/code&gt; or &lt;code&gt;-F&lt;/code&gt; options.</source>
          <target state="translated">コミットメッセージを編集するときは、指定されたファイルの内容でエディターを起動します。 &lt;code&gt;commit.template&lt;/code&gt; 設定変数は、多くの場合、コマンドに暗黙のうちに、このオプションを与えるために使用されます。このメカニズムは、メッセージに何をどの順序で書き込むかについてのヒントを参加者に提供したいプロジェクトで使用できます。ユーザーがメッセージを編集せずにエディターを終了すると、コミットは中止されます。これは、メッセージが &lt;code&gt;-m&lt;/code&gt; または &lt;code&gt;-F&lt;/code&gt; オプションなどの他の方法で与えられた場合には効果がありません。</target>
        </trans-unit>
        <trans-unit id="7835173f74e58e15c8891f5a3e0b3af743fd1c66" translate="yes" xml:space="preserve">
          <source>When editing, provide the raw object contents rather than pretty-printed ones. Currently this only affects trees, which will be shown in their binary form. This is harder to work with, but can help when repairing a tree that is so corrupted it cannot be pretty-printed. Note that you may need to configure your editor to cleanly read and write binary data.</source>
          <target state="translated">編集時には、きれいに印刷されたものではなく、生のオブジェクトの内容を提供するようにしました。現在のところ、これはツリーにのみ影響し、バイナリ形式で表示されます。これは作業が難しくなりますが、きれいに印刷できないほど破損したツリーを修復するときに役立ちます。バイナリデータをきれいに読み書きできるようにエディタを設定する必要があるかもしれないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="ce47e94310de9fcb0d82c1f052bbcc38f3a11f76" translate="yes" xml:space="preserve">
          <source>When enabled, the default &lt;code&gt;post-update&lt;/code&gt; hook runs &lt;code&gt;git update-server-info&lt;/code&gt; to keep the information used by dumb transports (e.g., HTTP) up to date. If you are publishing a Git repository that is accessible via HTTP, you should probably enable this hook.</source>
          <target state="translated">有効にすると、デフォルト &lt;code&gt;post-update&lt;/code&gt; フックが &lt;code&gt;git update-server-info&lt;/code&gt; を実行して、ダムトランスポート（HTTPなど）が使用する情報を最新の状態に保ちます。HTTP経由でアクセス可能なGitリポジトリを公開する場合は、おそらくこのフックを有効にする必要があります。</target>
        </trans-unit>
        <trans-unit id="a529b1482d7666548417edb1d901df1240194350" translate="yes" xml:space="preserve">
          <source>When encountering a non-ASCII message or subject that does not declare its encoding, add headers/quoting to indicate it is encoded in &amp;lt;encoding&amp;gt;. Default is the value of the &lt;code&gt;sendemail.assume8bitEncoding&lt;/code&gt;; if that is unspecified, this will be prompted for if any non-ASCII files are encountered.</source>
          <target state="translated">エンコードが宣言されていない非ASCIIメッセージまたは件名を検出した場合は、&amp;lt;encoding&amp;gt;でエンコードされていることを示すヘッダー/引用符を追加します。デフォルトは &lt;code&gt;sendemail.assume8bitEncoding&lt;/code&gt; の値です。これが指定されていない場合、非ASCIIファイルが検出された場合にプロンプ​​トが表示されます。</target>
        </trans-unit>
        <trans-unit id="c331bd8bb74634e4f18684aaa53f36ba8f8cf37d" translate="yes" xml:space="preserve">
          <source>When erasing credentials, matching credentials will be erased from all files.</source>
          <target state="translated">クレデンシャルを消去する場合、一致するクレデンシャルはすべてのファイルから消去されます。</target>
        </trans-unit>
        <trans-unit id="74e58a3904b06fc63c005d33dc33b553098868b7" translate="yes" xml:space="preserve">
          <source>When extensions.worktreeConfig is enabled, the config file &lt;code&gt;.git/worktrees/&amp;lt;id&amp;gt;/config.worktree&lt;/code&gt; is read after &lt;code&gt;.git/config&lt;/code&gt; is.</source>
          <target state="translated">extensions.worktreeConfigが有効になっている場合、構成ファイル &lt;code&gt;.git/worktrees/&amp;lt;id&amp;gt;/config.worktree&lt;/code&gt; は &lt;code&gt;.git/config&lt;/code&gt; の後に読み取られます。</target>
        </trans-unit>
        <trans-unit id="3a73371934954e7de3c00c5b21339d1552e97b06" translate="yes" xml:space="preserve">
          <source>When false, merge the current branch into the upstream branch.</source>
          <target state="translated">false の場合、現在のブランチを上流ブランチにマージします。</target>
        </trans-unit>
        <trans-unit id="d5dfb7a500ca38e6f311c3fe54f4fbaf71bc47ce" translate="yes" xml:space="preserve">
          <source>When fetching refs listed on the command line, use the specified refspec (can be given more than once) to map the refs to remote-tracking branches, instead of the values of &lt;code&gt;remote.*.fetch&lt;/code&gt; configuration variables for the remote repository. Providing an empty &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; to the &lt;code&gt;--refmap&lt;/code&gt; option causes Git to ignore the configured refspecs and rely entirely on the refspecs supplied as command-line arguments. See section on &quot;Configured Remote-tracking Branches&quot; for details.</source>
          <target state="translated">コマンドラインにリストされている参照を &lt;code&gt;remote.*.fetch&lt;/code&gt; するときは、リモートリポジトリのremote。*。fetch構成変数の値ではなく、指定されたrefspec（複数回指定できます）を使用して、参照をリモート追跡ブランチにマップします。 &lt;code&gt;--refmap&lt;/code&gt; オプションに空の &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; を指定すると、Gitは構成されたrefspecを無視し、コマンドライン引数として提供されたrefspecに完全に依存します。詳細については、「構成済みのリモート追跡ブランチ」のセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="c8afe72df4116adf55dd615031acfafbceae0ec5" translate="yes" xml:space="preserve">
          <source>When fetching refs listed on the command line, use the specified refspec (can be given more than once) to map the refs to remote-tracking branches, instead of the values of &lt;code&gt;remote.*.fetch&lt;/code&gt; configuration variables for the remote repository. See section on &quot;Configured Remote-tracking Branches&quot; for details.</source>
          <target state="translated">コマンドラインにリストされている参照を &lt;code&gt;remote.*.fetch&lt;/code&gt; するときは、リモートリポジトリのremote。*。fetch構成変数の値の代わりに、指定されたrefspec（複数回指定できる）を使用して、参照をリモート追跡ブランチにマップします。詳細については、「設定されたリモート追跡ブランチ」のセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="f131c02a4584603f0de6ca46a404ddf3258dbf13" translate="yes" xml:space="preserve">
          <source>When files are modified outside of Git, the user will need to stage the modified files explicitly (e.g. see &lt;code&gt;Examples&lt;/code&gt; section in &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt;). Git will not normally detect changes to those files.</source>
          <target state="translated">Gitの外部でファイルが変更された場合、ユーザーは変更されたファイルを明示的にステージングする必要があります（例：&lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]の&lt;/a&gt;「 &lt;code&gt;Examples&lt;/code&gt; セクションを参照）。Gitは通常、これらのファイルへの変更を検出しません。</target>
        </trans-unit>
        <trans-unit id="e95f7718835508fa2f714691dae7615b5ccee03a" translate="yes" xml:space="preserve">
          <source>When filtering history with &lt;code&gt;&amp;lt;path&amp;gt;&amp;hellip;​&lt;/code&gt;, does not prune some history. (See &quot;History simplification&quot; in &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; for a more detailed explanation.)</source>
          <target state="translated">歴史をフィルタリングすると &lt;code&gt;&amp;lt;path&amp;gt;&amp;hellip;​&lt;/code&gt; 、いくつかの歴史を整理しません。（詳細な説明については、&lt;a href=&quot;git-log&quot;&gt;git-log [1]の&lt;/a&gt;「履歴の簡略化」を参照してください。）</target>
        </trans-unit>
        <trans-unit id="18f94df4064f0faddb37415d13a088dd57356563" translate="yes" xml:space="preserve">
          <source>When first created, objects are stored in individual files, but for efficiency may later be compressed together into &quot;pack files&quot;.</source>
          <target state="translated">最初に作成されたときには、オブジェクトは個々のファイルに格納されますが、効率化のために後でまとめて「パックファイル」に圧縮されることがあります。</target>
        </trans-unit>
        <trans-unit id="3ce1186a221491da0c957498f84e962314b0f4f4" translate="yes" xml:space="preserve">
          <source>When given a range of commits to display (e.g. &lt;code&gt;commit1..commit2&lt;/code&gt; or &lt;code&gt;commit2 ^commit1&lt;/code&gt;), only display commits that exist directly on the ancestry chain between the &lt;code&gt;commit1&lt;/code&gt; and &lt;code&gt;commit2&lt;/code&gt;, i.e. commits that are both descendants of &lt;code&gt;commit1&lt;/code&gt;, and ancestors of &lt;code&gt;commit2&lt;/code&gt;.</source>
          <target state="translated">（例えば、ディスプレイへのコミットの範囲が与えられたとき &lt;code&gt;commit1..commit2&lt;/code&gt; 又は &lt;code&gt;commit2 ^commit1&lt;/code&gt; ）のみの間の祖先鎖上に直接存在するコミット表示 &lt;code&gt;commit1&lt;/code&gt; と &lt;code&gt;commit2&lt;/code&gt; の子孫の両方である、すなわちコミット &lt;code&gt;commit1&lt;/code&gt; 、との祖先 &lt;code&gt;commit2&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="e006844e32fc3d063be827d3911798e9ae2b69bd" translate="yes" xml:space="preserve">
          <source>When given a range of commits to display (e.g. &lt;code&gt;commit1..commit2&lt;/code&gt; or &lt;code&gt;commit2 ^commit1&lt;/code&gt;), only display commits that exist directly on the ancestry chain between the &lt;code&gt;commit1&lt;/code&gt; and &lt;code&gt;commit2&lt;/code&gt;, i.e. commits that are both descendants of &lt;code&gt;commit1&lt;/code&gt;, and ancestors of &lt;code&gt;commit2&lt;/code&gt;. (See &quot;History simplification&quot; in &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; for a more detailed explanation.)</source>
          <target state="translated">（例えば、ディスプレイへのコミットの範囲が与えられたとき &lt;code&gt;commit1..commit2&lt;/code&gt; 又は &lt;code&gt;commit2 ^commit1&lt;/code&gt; ）のみの間の祖先鎖上に直接存在するコミット表示 &lt;code&gt;commit1&lt;/code&gt; と &lt;code&gt;commit2&lt;/code&gt; の子孫の両方である、すなわちコミット &lt;code&gt;commit1&lt;/code&gt; 、との祖先 &lt;code&gt;commit2&lt;/code&gt; を。 （詳細な説明については、&lt;a href=&quot;git-log&quot;&gt;git-log [1]の&lt;/a&gt;「履歴の簡略化」を参照してください。）</target>
        </trans-unit>
        <trans-unit id="8281565ed0f01821dd04f5b4f8a282147fc8eb15" translate="yes" xml:space="preserve">
          <source>When given a two-part name section.key, the value for section.&amp;lt;url&amp;gt;.key whose &amp;lt;url&amp;gt; part matches the best to the given URL is returned (if no such key exists, the value for section.key is used as a fallback). When given just the section as name, do so for all the keys in the section and list them. Returns error code 1 if no value is found.</source>
          <target state="translated">2部構成の名前section.keyが指定されると、&amp;lt;url&amp;gt;部分が指定されたURLに最も一致するsection。&amp;lt;url&amp;gt; .keyの値が返されます（そのようなキーが存在しない場合、section.keyの値が使用されますフォールバックとして）。名前としてセクションのみを指定する場合は、セクション内のすべてのキーに対してそのようにし、それらをリストします。値が見つからない場合は、エラーコード1を返します。</target>
        </trans-unit>
        <trans-unit id="f88bacf945cb9e0553c03a8ac1d906d306ca24eb" translate="yes" xml:space="preserve">
          <source>When given an SVN revision number of the form &lt;code&gt;rN&lt;/code&gt;, returns the corresponding Git commit hash (this can optionally be followed by a tree-ish to specify which branch should be searched). When given a tree-ish, returns the corresponding SVN revision number.</source>
          <target state="translated">&lt;code&gt;rN&lt;/code&gt; の形式のSVNリビジョン番号を指定すると、対応するGitコミットハッシュを返します（オプションで、ツリーのように続けて検索するブランチを指定できます）。ツリー風に指定すると、対応するSVNリビジョン番号を返します。</target>
        </trans-unit>
        <trans-unit id="a96423d691859ec79cd98b29f7765677feb267ba" translate="yes" xml:space="preserve">
          <source>When given, and the repository to clone from is accessed via ssh, this specifies a non-default path for the command run on the other end.</source>
          <target state="translated">これが与えられ、クローンを作成するリポジトリが ssh 経由でアクセスされている場合、もう一方の端で実行されるコマンドのデフォルト以外のパスを指定します。</target>
        </trans-unit>
        <trans-unit id="d1fb59a7ba9cbb456b044d488d1684f86345d108" translate="yes" xml:space="preserve">
          <source>When given, and the repository to fetch from is handled by &lt;code&gt;git fetch-pack&lt;/code&gt;, &lt;code&gt;--exec=&amp;lt;upload-pack&amp;gt;&lt;/code&gt; is passed to the command to specify non-default path for the command run on the other end.</source>
          <target state="translated">指定すると、フェッチ元のリポジトリが &lt;code&gt;git fetch-pack&lt;/code&gt; によって処理され、 &lt;code&gt;--exec=&amp;lt;upload-pack&amp;gt;&lt;/code&gt; がコマンドに渡され、相手側で実行されるコマンドのデフォルト以外のパスが指定されます。</target>
        </trans-unit>
        <trans-unit id="347806ba4d643d64e35fb6159f6ca9df9bd36627" translate="yes" xml:space="preserve">
          <source>When giving multiple pattern expressions combined with &lt;code&gt;--or&lt;/code&gt;, this flag is specified to limit the match to files that have lines to match all of them.</source>
          <target state="translated">&lt;code&gt;--or&lt;/code&gt; と組み合わせて複数のパターン式を指定する場合、このフラグを指定して、すべてに一致する行があるファイルに一致を制限します。</target>
        </trans-unit>
        <trans-unit id="a0b6fe15df65f2d5daa97101d52d41abe4f1ad3a" translate="yes" xml:space="preserve">
          <source>When grepping the object store (with &lt;code&gt;--cached&lt;/code&gt; or giving tree objects), running with multiple threads might perform slower than single threaded if &lt;code&gt;--textconv&lt;/code&gt; is given and there&amp;rsquo;re too many text conversions. So if you experience low performance in this case, it might be desirable to use &lt;code&gt;--threads=1&lt;/code&gt;.</source>
          <target state="translated">オブジェクトストアをgrepする場合（ &lt;code&gt;--cached&lt;/code&gt; またはツリーオブジェクトを指定）、- &lt;code&gt;--textconv&lt;/code&gt; が指定され、テキスト変換が多すぎると、複数のスレッドで実行するとシングルスレッドよりもパフォーマンスが低下する可能性があります。したがって、この場合にパフォーマンスが低下する場合は、 &lt;code&gt;--threads=1&lt;/code&gt; を使用することが望ましい場合があります。</target>
        </trans-unit>
        <trans-unit id="4aea2178dff194f0c4c01be5fd5d2a4667a09068" translate="yes" xml:space="preserve">
          <source>When he&amp;rsquo;s ready, he tells Alice to pull changes from the repository at /home/bob/myrepo. She does this with:</source>
          <target state="translated">準備ができたら、アリスに/ home / bob / myrepoのリポジトリから変更をプルするように指示します。彼女はこれを行います：</target>
        </trans-unit>
        <trans-unit id="66bba6f8c73ac5f72ec362ac6e58a5210f96d2e5" translate="yes" xml:space="preserve">
          <source>When importing a renamed file or directory, simply delete the old name(s) and modify the new name(s) during the corresponding commit. Git performs rename detection after-the-fact, rather than explicitly during a commit.</source>
          <target state="translated">リネームされたファイルやディレクトリをインポートする際には、古い名前を削除し、対応するコミットの際に新しい名前を変更するだけです。Git は、コミット中に明示的にリネームを検出するのではなく、その場でリネームを検出します。</target>
        </trans-unit>
        <trans-unit id="547b791fe6e4a112ecfb6e63c2e9ee0d26e77b05" translate="yes" xml:space="preserve">
          <source>When in cone mode, the &lt;code&gt;git sparse-checkout set&lt;/code&gt; subcommand takes a list of directories instead of a list of sparse-checkout patterns. In this mode, the command &lt;code&gt;git sparse-checkout set A/B/C&lt;/code&gt; sets the directory &lt;code&gt;A/B/C&lt;/code&gt; as a recursive pattern, the directories &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;A/B&lt;/code&gt; are added as parent patterns. The resulting sparse-checkout file is now</source>
          <target state="translated">コーンモードの場合、 &lt;code&gt;git sparse-checkout set&lt;/code&gt; サブコマンドは、スパースチェックアウトパターンのリストではなく、ディレクトリのリストを取得します。このモードでは、コマンド &lt;code&gt;git sparse-checkout set A/B/C&lt;/code&gt; は、ディレクトリ &lt;code&gt;A/B/C&lt;/code&gt; を再帰的パターンとして設定し、ディレクトリ &lt;code&gt;A&lt;/code&gt; と &lt;code&gt;A/B&lt;/code&gt; は親パターンとして追加されます。結果のスパースチェックアウトファイルは次のようになります</target>
        </trans-unit>
        <trans-unit id="3cdd5299d04b153fd0e295904b9e12eec6b499c8" translate="yes" xml:space="preserve">
          <source>When in list mode, show sha1 and commit subject line for each head, along with relationship to upstream branch (if any). If given twice, print the path of the linked worktree (if any) and the name of the upstream branch, as well (see also &lt;code&gt;git remote show &amp;lt;remote&amp;gt;&lt;/code&gt;). Note that the current worktree&amp;rsquo;s HEAD will not have its path printed (it will always be your current directory).</source>
          <target state="translated">リストモードの場合、上流のブランチとの関係（存在する場合）とともに、各ヘッドのsha1とコミットの件名を表示します。2回指定した場合、リンクされたワークツリー（存在する場合）のパスと上流のブランチの名前も出力します（ &lt;code&gt;git remote show &amp;lt;remote&amp;gt;&lt;/code&gt; も参照）。現在のワークツリーのHEADにはパスが印刷されないことに注意してください（常に現在のディレクトリになります）。</target>
        </trans-unit>
        <trans-unit id="df3e42ff48559b3d46a4606cc43ea02a4d5742e5" translate="yes" xml:space="preserve">
          <source>When informative errors are turned on, git-daemon will report more verbose errors to the client, differentiating conditions like &quot;no such repository&quot; from &quot;repository not exported&quot;. This is more convenient for clients, but may leak information about the existence of unexported repositories. When informative errors are not enabled, all errors report &quot;access denied&quot; to the client. The default is --no-informative-errors.</source>
          <target state="translated">informative errors をオンにすると、git-daemon は &quot;no such repository&quot; のような状態を &quot;repository not exported&quot; と区別して、より冗長なエラーをクライアントに報告します。この方がクライアントにとっては便利ですが、エクスポートされていないリポジトリの存在についての情報が漏れてしまうかもしれません。情報提供型エラーが有効になっていない場合、すべてのエラーがクライアントに「アクセス拒否」を報告します。デフォルトは --no-informative-errors です。</target>
        </trans-unit>
        <trans-unit id="882f7c25abfabdf5a0527656f301ec49c21b72e8" translate="yes" xml:space="preserve">
          <source>When initializing submodules, a &lt;code&gt;.gitmodules&lt;/code&gt; file in the top-level directory of the containing repository is used to find the url of each submodule. This file should be formatted in the same way as &lt;code&gt;$GIT_DIR/config&lt;/code&gt;. The key to each submodule url is &quot;submodule.$name.url&quot;. See &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt; for details.</source>
          <target state="translated">サブモジュールを初期化するとき、含まれているリポジトリの最上位ディレクトリにある &lt;code&gt;.gitmodules&lt;/code&gt; ファイルを使用して、各サブモジュールのURLを検索します。このファイルは &lt;code&gt;$GIT_DIR/config&lt;/code&gt; と同じ方法でフォーマットする必要があります。各サブモジュールURLのキーは「submodule。$ name.url」です。詳細については、&lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5]&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="854c3f2001a62b8064a99a360e1e32072b64ad8e" translate="yes" xml:space="preserve">
          <source>When initially invoking &lt;code&gt;git am&lt;/code&gt;, you give it the names of the mailboxes to process. Upon seeing the first patch that does not apply, it aborts in the middle. You can recover from this in one of two ways:</source>
          <target state="translated">最初に &lt;code&gt;git am&lt;/code&gt; を呼び出すときに、処理するメールボックスの名前をそれに与えます。適用されない最初のパッチを確認すると、途中で中止されます。この状態から回復するには、次の2つの方法があります。</target>
        </trans-unit>
        <trans-unit id="ae919810620b188b4a098cb2c7010981f59eb2a8" translate="yes" xml:space="preserve">
          <source>When invoking a custom merge tool, Git uses a set of temporary files to pass to the tool. If the tool returns an error and this variable is set to &lt;code&gt;true&lt;/code&gt;, then these temporary files will be preserved, otherwise they will be removed after the tool has exited. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">カスタムマージツールを呼び出す場合、Gitは一連の一時ファイルを使用してツールに渡します。ツールがエラーを返し、この変数が &lt;code&gt;true&lt;/code&gt; に設定されている場合、これらの一時ファイルは保持されます。それ以外の場合は、ツールの終了後に削除されます。デフォルトは &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="8b149cf0c1c59f45e7d020f119cab62bcf88ef5e" translate="yes" xml:space="preserve">
          <source>When it comes to editing that commit, execute &lt;code&gt;git reset HEAD^&lt;/code&gt;. The effect is that the HEAD is rewound by one, and the index follows suit. However, the working tree stays the same.</source>
          <target state="translated">そのコミットの編集に関しては、 &lt;code&gt;git reset HEAD^&lt;/code&gt; 実行します。その効果は、HEADが1つ巻き戻され、インデックスがそれに追随することです。ただし、作業ツリーは同じままです。</target>
        </trans-unit>
        <trans-unit id="54d95c16d8a8ecd15ca228486caba0d9b645aa97" translate="yes" xml:space="preserve">
          <source>When it is not obvious how to apply a change, the following happens:</source>
          <target state="translated">変化をどのように適用したらよいかわからない場合は、次のようになります。</target>
        </trans-unit>
        <trans-unit id="42b78027e34d66bfdfc08d7cf571f024832571b4" translate="yes" xml:space="preserve">
          <source>When it is not obvious how to reconcile the changes, the following happens:</source>
          <target state="translated">どうやって調整したらいいのかわからないときは、次のようになります。</target>
        </trans-unit>
        <trans-unit id="ac3a9525cba718f2ba4c34b577914369145b2d3f" translate="yes" xml:space="preserve">
          <source>When listing references from an alternate, list only references that begin with the given prefix. Prefixes match as if they were given as arguments to &lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref[1]&lt;/a&gt;. To list multiple prefixes, separate them with whitespace. If &lt;code&gt;core.alternateRefsCommand&lt;/code&gt; is set, setting &lt;code&gt;core.alternateRefsPrefixes&lt;/code&gt; has no effect.</source>
          <target state="translated">代替からの参照を一覧表示する場合、指定されたプレフィックスで始まる参照のみを一覧表示します。プレフィックスは、&lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref [1]&lt;/a&gt;への引数として与えられたかのように一致します。複数の接頭辞をリストするには、空白で区切ります。場合 &lt;code&gt;core.alternateRefsCommand&lt;/code&gt; が設定され、設定 &lt;code&gt;core.alternateRefsPrefixes&lt;/code&gt; しても効果はありません。</target>
        </trans-unit>
        <trans-unit id="9485b24ac5fd9e24de580d1b4ae98203a381daa8" translate="yes" xml:space="preserve">
          <source>When listing, use the specified &amp;lt;format&amp;gt;, which can be one of &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;medium&lt;/code&gt; and &lt;code&gt;long&lt;/code&gt;. When omitted, the format defaults to &lt;code&gt;short&lt;/code&gt;.</source>
          <target state="translated">リストするときは、指定された&amp;lt;format&amp;gt;を使用します。これは、 &lt;code&gt;short&lt;/code&gt; 、 &lt;code&gt;medium&lt;/code&gt; 、 &lt;code&gt;long&lt;/code&gt; のいずれかです。省略した場合、フォーマットはデフォルトで &lt;code&gt;short&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="0de171dd2f5efd6969d6cc172c7d84e26d4bf231" translate="yes" xml:space="preserve">
          <source>When loosening unreachable objects, do not bother loosening any objects older than &lt;code&gt;&amp;lt;when&amp;gt;&lt;/code&gt;. This can be used to optimize out the write of any objects that would be immediately pruned by a follow-up &lt;code&gt;git prune&lt;/code&gt;.</source>
          <target state="translated">到達できないオブジェクトを緩めるときは、 &lt;code&gt;&amp;lt;when&amp;gt;&lt;/code&gt; より古いオブジェクトを緩めないでください。これは、フォローアップ &lt;code&gt;git prune&lt;/code&gt; によってすぐに除去されるオブジェクトの書き込みを最適化するために使用できます。</target>
        </trans-unit>
        <trans-unit id="2ecd3bb7ffbd4f19e0c8d754d499b7e6453c84ef" translate="yes" xml:space="preserve">
          <source>When merging an annotated (and possibly signed) tag, Git always creates a merge commit even if a fast-forward merge is possible, and the commit message template is prepared with the tag message. Additionally, if the tag is signed, the signature check is reported as a comment in the message template. See also &lt;a href=&quot;git-tag&quot;&gt;git-tag[1]&lt;/a&gt;.</source>
          <target state="translated">注釈付き（および場合によっては署名済み）のタグをマージするとき、Gitは早送りマージが可能であっても常にマージコミットを作成し、コミットメッセージテンプレートはタグメッセージで準備されます。さらに、タグが署名されている場合、署名チェックはメッセージテンプレートのコメントとして報告されます。&lt;a href=&quot;git-tag&quot;&gt;git-tag [1]&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="fe18117100b1e7049979d08b3604c39a0ff0f463" translate="yes" xml:space="preserve">
          <source>When merging notes, be more verbose. When pruning notes, report all object names whose notes are removed.</source>
          <target state="translated">ノートを結合するときは、より冗長にします。ノートを剪定するときは、ノートが削除されたオブジェクト名をすべて報告します。</target>
        </trans-unit>
        <trans-unit id="2a6ffb56c555f1836377a0b4eb9f01a6db423b92" translate="yes" xml:space="preserve">
          <source>When merging notes, operate quietly.</source>
          <target state="translated">ノートを結合するときは、静かに操作してください。</target>
        </trans-unit>
        <trans-unit id="452e3643271eefd0a90ad1d2e336613f571129ec" translate="yes" xml:space="preserve">
          <source>When merging notes, resolve notes conflicts using the given strategy. The following strategies are recognized: &quot;manual&quot; (default), &quot;ours&quot;, &quot;theirs&quot;, &quot;union&quot; and &quot;cat_sort_uniq&quot;. This option overrides the &quot;notes.mergeStrategy&quot; configuration setting. See the &quot;NOTES MERGE STRATEGIES&quot; section below for more information on each notes merge strategy.</source>
          <target state="translated">ノートをマージするときは、与えられた戦略を使用してノートの競合を解決します。以下のストラテジーが認識されます。&quot;マニュアル」(デフォルト)、「私たちの」、「彼らの」、「ユニオン」、および「cat_sort_uniq」です。このオプションは &quot;notes.mergeStrategy&quot; 構成設定を上書きします。各ノートのマージ戦略の詳細については、以下の「NOTES MERGE STRATEGIES」のセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="a1f0170f40742ebfd5d162ab78a6fe6f60fbd4e1" translate="yes" xml:space="preserve">
          <source>When missing or is set to &lt;code&gt;default&lt;/code&gt;, many fields in the stat structure are checked to detect if a file has been modified since Git looked at it. When this configuration variable is set to &lt;code&gt;minimal&lt;/code&gt;, sub-second part of mtime and ctime, the uid and gid of the owner of the file, the inode number (and the device number, if Git was compiled to use it), are excluded from the check among these fields, leaving only the whole-second part of mtime (and ctime, if &lt;code&gt;core.trustCtime&lt;/code&gt; is set) and the filesize to be checked.</source>
          <target state="translated">存在しないか &lt;code&gt;default&lt;/code&gt; に設定されている場合、Gitがファイルを参照してからファイルが変更されたかどうかを検出するために、stat構造体の多くのフィールドがチェックされます。この構成変数がに設定されている場合 &lt;code&gt;minimal&lt;/code&gt; （Gitのは、それを使用するためにコンパイルされた場合、デバイス番号）のmtimeとCTIMEのサブ第二の部分、uidとファイルの所有者のGID、inode番号から除外されていますこれらのフィールド間のチェック &lt;code&gt;core.trustCtime&lt;/code&gt; （およびcore.trustCtimeが設定されている場合はctime）の秒部分のみと、チェックするファイルサイズを残します。</target>
        </trans-unit>
        <trans-unit id="0689b4b76e007bf9e9f69e1368a4eed9e3d9055a" translate="yes" xml:space="preserve">
          <source>When more than one pattern matches the path, a later line overrides an earlier line. This overriding is done per attribute.</source>
          <target state="translated">複数のパターンがパスにマッチする場合、後の行が前の行を上書きします。この上書きは属性ごとに行われます。</target>
        </trans-unit>
        <trans-unit id="7de11bcf0fc6f31a9913abfce53b7b83c6075119" translate="yes" xml:space="preserve">
          <source>When moved lines are colored using e.g. the &lt;code&gt;diff.colorMoved&lt;/code&gt; setting, this option controls the &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; how spaces are treated for details of valid modes see &lt;code&gt;--color-moved-ws&lt;/code&gt; in &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;.</source>
          <target state="translated">移動した線に、たとえば &lt;code&gt;diff.colorMoved&lt;/code&gt; 設定を使用して色を付ける場合、このオプションは、 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; で有効なモードの詳細についてスペースの処理方法を制御します &lt;code&gt;--color-moved-ws&lt;/code&gt; を参照してくださいで&lt;a href=&quot;git-diff&quot;&gt;のgit-diffの[1] &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="52b8058d0bfbbff70a9ce60ad478453479b9a747" translate="yes" xml:space="preserve">
          <source>When multiple patches are output, the subject prefix will instead be &quot;[PATCH n/m] &quot;. To force 1/1 to be added for a single patch, use &lt;code&gt;-n&lt;/code&gt;. To omit patch numbers from the subject, use &lt;code&gt;-N&lt;/code&gt;.</source>
          <target state="translated">複数のパッチが出力される場合、件名のプレフィックスは「[PATCH n / m]」になります。1つのパッチに1/1を強制的に追加するには、 &lt;code&gt;-n&lt;/code&gt; を使用します。件名からパッチ番号を省略するには、次を使用します。 &lt;code&gt;-N&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="f1cdd3c7b73eb4476790691d3f8180aaaecc09ec" translate="yes" xml:space="preserve">
          <source>When multiple working trees are used, most of files in $GIT_DIR are per-worktree with a few known exceptions. All files under &lt;code&gt;common&lt;/code&gt; however will be shared between all working trees.</source>
          <target state="translated">複数の作業ツリーが使用されている場合、$ GIT_DIRのほとんどのファイルは、いくつかの既知の例外を除いて、作業ツリーごとです。ただし、 &lt;code&gt;common&lt;/code&gt; 下にあるすべてのファイルは、すべての作業ツリー間で共有されます。</target>
        </trans-unit>
        <trans-unit id="dea6d60865820d20f017799a5c24231f89c30494" translate="yes" xml:space="preserve">
          <source>When neither the command-line nor the configuration specify what to push, the default behavior is used, which corresponds to the &lt;code&gt;simple&lt;/code&gt; value for &lt;code&gt;push.default&lt;/code&gt;: the current branch is pushed to the corresponding upstream branch, but as a safety measure, the push is aborted if the upstream branch does not have the same name as the local one.</source>
          <target state="translated">コマンドラインも設定もプッシュするものを指定しない場合、デフォルトの動作が使用されます。これは &lt;code&gt;push.default&lt;/code&gt; の &lt;code&gt;simple&lt;/code&gt; 値に対応します。現在のブランチは対応する上流のブランチにプッシュされますが、安全対策として、プッシュ上流のブランチの名前がローカルのブランチと同じでない場合は、中止されます。</target>
        </trans-unit>
        <trans-unit id="60de604c8e6be170ca14a17caf3d8c66cf8e4c1f" translate="yes" xml:space="preserve">
          <source>When no &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; is given, &lt;code&gt;stash@{0}&lt;/code&gt; is assumed, otherwise &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; must be a reference of the form &lt;code&gt;stash@{&amp;lt;revision&amp;gt;}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; が指定されていない場合、 &lt;code&gt;stash@{0}&lt;/code&gt; が想定されます。それ以外の場合、 &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; は &lt;code&gt;stash@{&amp;lt;revision&amp;gt;}&lt;/code&gt; 形式の参照である必要があります。</target>
        </trans-unit>
        <trans-unit id="1cb728a038f1c7e17113ec68844d5bac04accdd7" translate="yes" xml:space="preserve">
          <source>When no &lt;code&gt;--push-option=&amp;lt;option&amp;gt;&lt;/code&gt; argument is given from the command line, &lt;code&gt;git push&lt;/code&gt; behaves as if each &amp;lt;value&amp;gt; of this variable is given as &lt;code&gt;--push-option=&amp;lt;value&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">いかなる場合 &lt;code&gt;--push-option=&amp;lt;option&amp;gt;&lt;/code&gt; 引数は、コマンドラインから与えられていない &lt;code&gt;git push&lt;/code&gt; この変数の各&amp;lt;値&amp;gt;として与えられるかのように振る舞います &lt;code&gt;--push-option=&amp;lt;value&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a166fc08fc71ee0e3d700a37b70f8845fb53d565" translate="yes" xml:space="preserve">
          <source>When no &lt;code&gt;--whitespace&lt;/code&gt; flag is given from the command line, this configuration item is used as the default.</source>
          <target state="translated">&lt;code&gt;--whitespace&lt;/code&gt; がない場合コマンドラインからフラグが指定されてい、この構成アイテムがデフォルトとして使用されます。</target>
        </trans-unit>
        <trans-unit id="b29755631cf67968424c24b41012b3c14a5bc20f" translate="yes" xml:space="preserve">
          <source>When no refspec was given on the command line, then &lt;code&gt;git pull&lt;/code&gt; uses the refspec from the configuration or &lt;code&gt;$GIT_DIR/remotes/&amp;lt;origin&amp;gt;&lt;/code&gt;. In such cases, the following rules apply:</source>
          <target state="translated">コマンドラインでrefspecが指定されていない場合、 &lt;code&gt;git pull&lt;/code&gt; は構成または &lt;code&gt;$GIT_DIR/remotes/&amp;lt;origin&amp;gt;&lt;/code&gt; からのrefspec を使用します。このような場合、次の規則が適用されます。</target>
        </trans-unit>
        <trans-unit id="feee7e6efffd7b04e5558aa779c91bc6a7b795bd" translate="yes" xml:space="preserve">
          <source>When no remote is specified (via -r) the &lt;code&gt;HEAD&lt;/code&gt; branch from CVS is imported to the &lt;code&gt;origin&lt;/code&gt; branch within the Git repository, as &lt;code&gt;HEAD&lt;/code&gt; already has a special meaning for Git. When a remote is specified the &lt;code&gt;HEAD&lt;/code&gt; branch is named remotes/&amp;lt;remote&amp;gt;/master mirroring &lt;code&gt;git clone&lt;/code&gt; behaviour. Use this option if you want to import into a different branch.</source>
          <target state="translated">（-rを介して）リモートが指定されていない場合、 &lt;code&gt;HEAD&lt;/code&gt; はすでにGitに特別な意味を持っているため、CVSからの &lt;code&gt;HEAD&lt;/code&gt; ブランチはGitリポジトリ内の &lt;code&gt;origin&lt;/code&gt; ブランチにインポートされます。リモートが指定されている場合、 &lt;code&gt;HEAD&lt;/code&gt; ブランチはremotes / &amp;lt;remote&amp;gt; / master mirroringという名前になります &lt;code&gt;git clone&lt;/code&gt; behaviourます。別のブランチにインポートする場合は、このオプションを使用します。</target>
        </trans-unit>
        <trans-unit id="ac03f302c1aadb048fb52d65d000d2a5006af96e" translate="yes" xml:space="preserve">
          <source>When no remote is specified, by default the &lt;code&gt;origin&lt;/code&gt; remote will be used, unless there&amp;rsquo;s an upstream branch configured for the current branch.</source>
          <target state="translated">リモートが指定されていない場合、デフォルトで &lt;code&gt;origin&lt;/code&gt; ない場合、現在のブランチに設定されたアップストリームブランチがない限り、リモートが使用されます。</target>
        </trans-unit>
        <trans-unit id="d52e3dbbfef371828cf1a5d65a8a3d7860fbbc07" translate="yes" xml:space="preserve">
          <source>When on branch &amp;lt;name&amp;gt;, it overrides &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; for pushing. It also overrides &lt;code&gt;remote.pushDefault&lt;/code&gt; for pushing from branch &amp;lt;name&amp;gt;. When you pull from one place (e.g. your upstream) and push to another place (e.g. your own publishing repository), you would want to set &lt;code&gt;remote.pushDefault&lt;/code&gt; to specify the remote to push to for all branches, and use this option to override it for a specific branch.</source>
          <target state="translated">ブランチ&amp;lt;name&amp;gt;にある場合、プッシュするために &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; をオーバーライドします。また、ブランチ&amp;lt;name&amp;gt;からプッシュするために &lt;code&gt;remote.pushDefault&lt;/code&gt; をオーバーライドします。ある場所（たとえば、アップストリーム）からプルし、別の場所（たとえば、独自の公開リポジトリ）にプッシュするときは、 &lt;code&gt;remote.pushDefault&lt;/code&gt; を設定します。にプッシュする場合、をして、すべてのブランチにプッシュするリモートを指定し、このオプションを使用してオーバーライドします。特定のブランチ用。</target>
        </trans-unit>
        <trans-unit id="2c5d62eaf7dc4c0abb09284bfc14bacce3f382aa" translate="yes" xml:space="preserve">
          <source>When on branch &amp;lt;name&amp;gt;, it tells &lt;code&gt;git fetch&lt;/code&gt; and &lt;code&gt;git push&lt;/code&gt; which remote to fetch from/push to. The remote to push to may be overridden with &lt;code&gt;remote.pushDefault&lt;/code&gt; (for all branches). The remote to push to, for the current branch, may be further overridden by &lt;code&gt;branch.&amp;lt;name&amp;gt;.pushRemote&lt;/code&gt;. If no remote is configured, or if you are not on any branch, it defaults to &lt;code&gt;origin&lt;/code&gt; for fetching and &lt;code&gt;remote.pushDefault&lt;/code&gt; for pushing. Additionally, &lt;code&gt;.&lt;/code&gt; (a period) is the current local repository (a dot-repository), see &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt;'s final note below.</source>
          <target state="translated">ブランチ&amp;lt;name&amp;gt;にあるとき、それは &lt;code&gt;git fetch&lt;/code&gt; と &lt;code&gt;git push&lt;/code&gt; にどのリモートからフェッチする/プッシュするかを伝えます。プッシュ先のリモートは、 &lt;code&gt;remote.pushDefault&lt;/code&gt; （すべてのブランチ）でオーバーライドできます。現在のブランチのプッシュ先のリモートは、 &lt;code&gt;branch.&amp;lt;name&amp;gt;.pushRemote&lt;/code&gt; によってさらにオーバーライドされる場合があります。リモートが構成されていない場合、またはどのブランチにもいない場合、デフォルトでは、フェッチの場合は &lt;code&gt;origin&lt;/code&gt; に、プッシュの場合は &lt;code&gt;remote.pushDefault&lt;/code&gt; になります。さらに、 &lt;code&gt;.&lt;/code&gt; （ピリオド）は現在のローカルリポジトリ（ドットリポジトリ） &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; 下記のbranch。&amp;lt;name&amp;gt; .mergeの最後のメモを参照してください。</target>
        </trans-unit>
        <trans-unit id="99875f2b6ac5843dc20c0934eb9cdf10f7711c8e" translate="yes" xml:space="preserve">
          <source>When one of these flags is specified, the object name recorded for the paths are not updated. Instead, these options set and unset the &quot;fsmonitor valid&quot; bit for the paths. See section &quot;File System Monitor&quot; below for more information.</source>
          <target state="translated">これらのフラグのいずれかが指定された場合、パスに記録されているオブジェクト名は更新されません。代わりに、これらのオプションはパスの &quot;fsmonitor valid &quot;ビットを設定したり解除したりする。詳細は後述の「ファイルシステムモニタ」を参照してください。</target>
        </trans-unit>
        <trans-unit id="095b3a1631077463d64190b5c04e9903f37eec26" translate="yes" xml:space="preserve">
          <source>When one of these flags is specified, the object name recorded for the paths are not updated. Instead, these options set and unset the &quot;skip-worktree&quot; bit for the paths. See section &quot;Skip-worktree bit&quot; below for more information.</source>
          <target state="translated">これらのフラグのいずれかが指定された場合、パスに記録されたオブジェクト名は更新されません。その代わりに、これらのオプションはパスの「スキップ・ワークツリー」ビットを設定したり解除したりします。詳細については、後述の「スキップワークツリービット」を参照してください。</target>
        </trans-unit>
        <trans-unit id="6e8f4e10b13b6ff83d83df5063d58c36d64a87b8" translate="yes" xml:space="preserve">
          <source>When one or more &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; are specified explicitly (whether on the command line or via &lt;code&gt;--stdin&lt;/code&gt;), it can be either a single pattern, or a pair of such pattern separated by a colon &quot;:&quot; (this means that a ref name cannot have a colon in it). A single pattern &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; is just a shorthand for &lt;code&gt;&amp;lt;name&amp;gt;:&amp;lt;name&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">1つ以上の &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; が明示的に指定されている場合（コマンドラインまたは &lt;code&gt;--stdin&lt;/code&gt; を介して）、単一のパターン、またはコロン「：」で区切られたそのようなパターンのペアのいずれかになります（これは、ref名前にコロンを含めることはできません）。単一のパターン &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; は、 &lt;code&gt;&amp;lt;name&amp;gt;:&amp;lt;name&amp;gt;&lt;/code&gt; の省略形です。</target>
        </trans-unit>
        <trans-unit id="9a9b16c534806b7638cc46892a28dd173752ed8c" translate="yes" xml:space="preserve">
          <source>When packing a blob fast-import always attempts to deltify against the last blob written. Unless specifically arranged for by the frontend, this will probably not be a prior version of the same file, so the generated delta will not be the smallest possible. The resulting packfile will be compressed, but will not be optimal.</source>
          <target state="translated">blob をパッキングするとき、fast-import は常に最後に書き込まれた blob に対してデルタ化を試みます。フロントエンドが特に指定しない限り、これはおそらく同じファイルの前のバージョンではないので、生成されるデルタは可能な限り最小にはなりません。結果として得られるパックファイルは圧縮されますが、最適ではありません。</target>
        </trans-unit>
        <trans-unit id="76e4bf1d99930055a44aa05818b2c065730f60bb" translate="yes" xml:space="preserve">
          <source>When passed to &lt;code&gt;init&lt;/code&gt; or &lt;code&gt;clone&lt;/code&gt; this regular expression will be preserved as a config key. See &lt;code&gt;fetch&lt;/code&gt; for a description of &lt;code&gt;--ignore-paths&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;init&lt;/code&gt; または &lt;code&gt;clone&lt;/code&gt; に渡されると、この正規表現は設定キーとして保持されます。 &lt;code&gt;--ignore-paths&lt;/code&gt; の説明については、 &lt;code&gt;fetch&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="d6a3308486ea0114e28423fc585e726bdfefa0d3" translate="yes" xml:space="preserve">
          <source>When passed to &lt;code&gt;init&lt;/code&gt; or &lt;code&gt;clone&lt;/code&gt; this regular expression will be preserved as a config key. See &lt;code&gt;fetch&lt;/code&gt; for a description of &lt;code&gt;--ignore-refs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;init&lt;/code&gt; または &lt;code&gt;clone&lt;/code&gt; に渡されると、この正規表現は設定キーとして保持されます。 &lt;code&gt;--ignore-refs&lt;/code&gt; の説明については、 &lt;code&gt;fetch&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="247954c989ece2f916f72b869f8bb1eb7f01f09e" translate="yes" xml:space="preserve">
          <source>When passed to &lt;code&gt;init&lt;/code&gt; or &lt;code&gt;clone&lt;/code&gt; this regular expression will be preserved as a config key. See &lt;code&gt;fetch&lt;/code&gt; for a description of &lt;code&gt;--include-paths&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;init&lt;/code&gt; または &lt;code&gt;clone&lt;/code&gt; に渡されると、この正規表現は設定キーとして保持されます。 &lt;code&gt;--include-paths&lt;/code&gt; の説明については、 &lt;code&gt;fetch&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="701b3c119f368819101d8af88b842359e5cb7ac8" translate="yes" xml:space="preserve">
          <source>When paths are given, show them (note that this isn&amp;rsquo;t really raw pathnames, but rather a list of patterns to match). Otherwise implicitly uses the root level of the tree as the sole path argument.</source>
          <target state="translated">パスが指定されたら、それらを表示します（これは実際のパス名ではなく、一致するパターンのリストであることに注意してください）。それ以外の場合は、ツリーのルートレベルを唯一のパス引数として暗黙的に使用します。</target>
        </trans-unit>
        <trans-unit id="a12bc3537fe67daac72917848a655d5078c91711" translate="yes" xml:space="preserve">
          <source>When pathspec is given on the command line, commit the contents of the files that match the pathspec without recording the changes already added to the index. The contents of these files are also staged for the next commit on top of what have been staged before.</source>
          <target state="translated">コマンドラインでpathspecが与えられた場合、すでにインデックスに追加されている変更を記録せずに、pathspecにマッチしたファイルの内容をコミットします。これらのファイルの内容は、それまでにステージされていたものの上に、次のコミットのためにステージされます。</target>
        </trans-unit>
        <trans-unit id="1a6dc462ca36ebe8779cf750259e000c162a076a" translate="yes" xml:space="preserve">
          <source>When pathspec is given to &lt;code&gt;git stash push&lt;/code&gt;, the new stash entry records the modified states only for the files that match the pathspec. The index entries and working tree files are then rolled back to the state in HEAD only for these files, too, leaving files that do not match the pathspec intact.</source>
          <target state="translated">pathspecが &lt;code&gt;git stash push&lt;/code&gt; に指定されている場合に、新しいstashエントリーは、pathspecに一致するファイルについてのみ変更された状態を記録します。インデックスエントリと作業ツリーファイルは、これらのファイルに対してのみHEADの状態にロールバックされ、pathspecと一致しないファイルはそのまま残ります。</target>
        </trans-unit>
        <trans-unit id="20284d20320c7f9cdd342728ed75cf98e12a1b6c" translate="yes" xml:space="preserve">
          <source>When possible, &lt;code&gt;pack-objects&lt;/code&gt; tries to reuse existing on-disk deltas to avoid having to search for new ones on the fly. This is an important optimization for serving fetches, because it means the server can avoid inflating most objects at all and just send the bytes directly from disk. This optimization can&amp;rsquo;t work when an object is stored as a delta against a base which the receiver does not have (and which we are not already sending). In that case the server &quot;breaks&quot; the delta and has to find a new one, which has a high CPU cost. Therefore it&amp;rsquo;s important for performance that the set of objects in on-disk delta relationships match what a client would fetch.</source>
          <target state="translated">可能であれば、 &lt;code&gt;pack-objects&lt;/code&gt; は既存のディスク上のデルタを再利用して、新しいデルタをその場で検索する必要がないようにします。これはフェッチを提供するための重要な最適化です。これは、サーバーがほとんどのオブジェクトを膨らませることを回避し、バイトをディスクから直接送信できることを意味します。この最適化は、オブジェクトが、受信者が持っていない（まだ送信していない）ベースに対するデルタとして格納されている場合は機能しません。その場合、サーバーはデルタを「破壊」し、CPUコストが高い新しいデルタを見つける必要があります。したがって、ディスク上のデルタ関係にあるオブジェクトのセットが、クライアントがフェッチするものと一致することがパフォーマンスにとって重要です。</target>
        </trans-unit>
        <trans-unit id="a5d1e2c9c76493f4d0a607592b15388eabc93e4e" translate="yes" xml:space="preserve">
          <source>When present, it will also copy the value of &lt;code&gt;submodule.$name.update&lt;/code&gt;. This command does not alter existing information in .git/config. You can then customize the submodule clone URLs in .git/config for your local setup and proceed to &lt;code&gt;git submodule update&lt;/code&gt;; you can also just use &lt;code&gt;git submodule update --init&lt;/code&gt; without the explicit &lt;code&gt;init&lt;/code&gt; step if you do not intend to customize any submodule locations.</source>
          <target state="translated">存在する場合は、 &lt;code&gt;submodule.$name.update&lt;/code&gt; 値もコピーします。このコマンドは、.git / config内の既存の情報を変更しません。次に、ローカルセットアップ用に.git / configのサブモジュールクローンURLをカスタマイズして、 &lt;code&gt;git submodule update&lt;/code&gt; 進みます。サブモジュールの場所をカスタマイズするつもりがない場合は、明示的な &lt;code&gt;init&lt;/code&gt; ステップなしで &lt;code&gt;git submodule update --init&lt;/code&gt; を使用することもできます。</target>
        </trans-unit>
        <trans-unit id="fb5aacfd35a68a879acea2ba6edf150f79c935f9" translate="yes" xml:space="preserve">
          <source>When pushing to a remote that is different from the remote you normally pull from, work as &lt;code&gt;current&lt;/code&gt;. This is the safest option and is suited for beginners.</source>
          <target state="translated">通常プルするリモートとは異なるリモートにプッシュする場合は、 &lt;code&gt;current&lt;/code&gt; として動作します。これは最も安全なオプションであり、初心者に適しています。</target>
        </trans-unit>
        <trans-unit id="f99e4f9643f5e033d51557f2aab4b69c000e9e23" translate="yes" xml:space="preserve">
          <source>When pushing, request the remote server to update refs in a single atomic transaction. If successful, all refs will be updated, or none will. If the remote side does not support this capability, the push will fail.</source>
          <target state="translated">プッシュする場合は、リモートサーバに単一のアトミックトランザクションで refs を更新するように要求します。成功した場合はすべての refs が更新され、そうでない場合は何も更新されません。リモート側がこの機能をサポートしていない場合、プッシュは失敗します。</target>
        </trans-unit>
        <trans-unit id="24e8d08f5bcd393fd98db303b5bfff38ae149335" translate="yes" xml:space="preserve">
          <source>When reading the &lt;code&gt;core.repositoryformatversion&lt;/code&gt; variable, a git implementation which supports version 1 MUST also read any configuration keys found in the &lt;code&gt;extensions&lt;/code&gt; section of the configuration file.</source>
          <target state="translated">&lt;code&gt;core.repositoryformatversion&lt;/code&gt; 変数を読み取るとき、バージョン1をサポートするgit実装は、構成ファイルの &lt;code&gt;extensions&lt;/code&gt; セクションにある構成キーも読み取る必要があります。</target>
        </trans-unit>
        <trans-unit id="d49438aa2f88cdc57a3b7001a0406b8491bbad55" translate="yes" xml:space="preserve">
          <source>When reading trailers, there can be whitespaces after the token, the separator and the value. There can also be whitespaces inside the token and the value. The value may be split over multiple lines with each subsequent line starting with whitespace, like the &quot;folding&quot; in RFC 822.</source>
          <target state="translated">トレーラーを読むとき、トークン、区切り文字、値の後に空白が入ることがあります。また、トークンと値の中にも空白を入れることができます。値は、RFC 822の &quot;folding &quot;のように、後続の各行がホワイトスペースで始まるように、複数の行に分割することができます。</target>
        </trans-unit>
        <trans-unit id="c808cfa1e01223bf6f90ceb1edbec20a1b9b3321" translate="yes" xml:space="preserve">
          <source>When reading, the values are read from the system, global and repository local configuration files by default, and options &lt;code&gt;--system&lt;/code&gt;, &lt;code&gt;--global&lt;/code&gt;, &lt;code&gt;--local&lt;/code&gt;, &lt;code&gt;--worktree&lt;/code&gt; and &lt;code&gt;--file &amp;lt;filename&amp;gt;&lt;/code&gt; can be used to tell the command to read from only that location (see &lt;a href=&quot;#FILES&quot;&gt;FILES&lt;/a&gt;).</source>
          <target state="translated">読み取り時には、値はデフォルトでシステム、グローバルおよびリポジトリローカル構成ファイルから読み取られ、オプション &lt;code&gt;--system&lt;/code&gt; 、-- &lt;code&gt;--global&lt;/code&gt; 、-- &lt;code&gt;--local&lt;/code&gt; 、-- &lt;code&gt;--worktree&lt;/code&gt; および &lt;code&gt;--file &amp;lt;filename&amp;gt;&lt;/code&gt; を使用して、その場所からのみ読み取るコマンド（&lt;a href=&quot;#FILES&quot;&gt;FILESを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="35058e27fd0502a5cbd6b1225fdbfa49a5b7004d" translate="yes" xml:space="preserve">
          <source>When recording the commit, append a line that says &quot;(cherry picked from commit &amp;hellip;​)&quot; to the original commit message in order to indicate which commit this change was cherry-picked from. This is done only for cherry picks without conflicts. Do not use this option if you are cherry-picking from your private branch because the information is useless to the recipient. If on the other hand you are cherry-picking between two publicly visible branches (e.g. backporting a fix to a maintenance branch for an older release from a development branch), adding this information can be useful.</source>
          <target state="translated">コミットを記録するときは、「（コミットから選択されたチェリー&amp;hellip;）」という行を元のコミットメッセージに追加して、この変更がチェリーピックされたコミットを示します。これは、競合のないチェリーピックに対してのみ行われます。情報が受信者にとって役に立たないため、プライベートブランチから厳選する場合は、このオプションを使用しないでください。一方、公開されている2つのブランチ間で選択している場合（たとえば、開発ブランチからの古いリリースのメンテナンスブランチに修正をバックポートする場合）、この情報を追加すると便利です。</target>
        </trans-unit>
        <trans-unit id="ccaf8e1c6e304870dc79f0b6ba9e209459375c19" translate="yes" xml:space="preserve">
          <source>When recording your own work, the contents of modified files in your working tree are temporarily stored to a staging area called the &quot;index&quot; with &lt;code&gt;git add&lt;/code&gt;. A file can be reverted back, only in the index but not in the working tree, to that of the last commit with &lt;code&gt;git restore --staged &amp;lt;file&amp;gt;&lt;/code&gt;, which effectively reverts &lt;code&gt;git add&lt;/code&gt; and prevents the changes to this file from participating in the next commit. After building the state to be committed incrementally with these commands, &lt;code&gt;git commit&lt;/code&gt; (without any pathname parameter) is used to record what has been staged so far. This is the most basic form of the command. An example:</source>
          <target state="translated">自分の作業を記録するとき、作業ツリー内の変更されたファイルの内容は、 &lt;code&gt;git add&lt;/code&gt; を使用して「インデックス」と呼ばれるステージング領域に一時的に保存されます。 &lt;code&gt;git restore --staged &amp;lt;file&amp;gt;&lt;/code&gt; を使用して、ファイルをインデックス内のみで作業ツリー内ではなく、最後のコミットのファイルに戻すことができます。これにより、 &lt;code&gt;git add&lt;/code&gt; が効果的に元に戻され、このファイルへの変更が次のコミット。これらのコマンドで段階的にコミットされる状態を構築した後、 &lt;code&gt;git commit&lt;/code&gt; （パス名パラメーターなし）を使用して、これまでにステージングされた内容を記録します。これは、コマンドの最も基本的な形式です。例：</target>
        </trans-unit>
        <trans-unit id="35cd60207a202ee3a283a2d8b2047b148806b6b3" translate="yes" xml:space="preserve">
          <source>When remote and local branch are both named &quot;test&quot;:</source>
          <target state="translated">リモートブランチとローカルブランチの両方に &quot;test &quot;という名前がついている場合。</target>
        </trans-unit>
        <trans-unit id="2eefb86cce90a60f5ab07db6487aa99da3ba4333" translate="yes" xml:space="preserve">
          <source>When rename/copy is involved, &lt;code&gt;file1&lt;/code&gt; and &lt;code&gt;file2&lt;/code&gt; show the name of the source file of the rename/copy and the name of the file that rename/copy produces, respectively.</source>
          <target state="translated">名前の変更/コピーが関係している場合、 &lt;code&gt;file1&lt;/code&gt; と &lt;code&gt;file2&lt;/code&gt; はそれぞれ、名前の変更/コピーのソースファイルの名前と、名前の変更/コピーによって生成されるファイルの名前を示します。</target>
        </trans-unit>
        <trans-unit id="3475b12f6b8e32c3a9c4f496f5f906d95460d63d" translate="yes" xml:space="preserve">
          <source>When repacking with delta islands the delta window tends to get clogged with candidates that are forbidden by the config. Repacking with a big --window helps (and doesn&amp;rsquo;t take as long as it otherwise might because we can reject some object pairs based on islands before doing any computation on the content).</source>
          <target state="translated">デルタアイランドで再パックする場合、デルタウィンドウは、構成で禁止されている候補で詰まる傾向があります。大きな--windowで再パックすることは役立ちます（コンテンツで計算を行う前にアイランドに基づくオブジェクトペアを拒否できるため、そうでない場合と同じくらい時間がかかりません）。</target>
        </trans-unit>
        <trans-unit id="9f9b14ed67913870e54606a7e4140c245c13e689" translate="yes" xml:space="preserve">
          <source>When restoring files in the working tree from the index, use stage #2 (&lt;code&gt;ours&lt;/code&gt;) or #3 (&lt;code&gt;theirs&lt;/code&gt;) for unmerged paths.</source>
          <target state="translated">インデックスから作業ツリー内のファイルを復元する場合、マージされていないパスにはステージ＃2（ &lt;code&gt;ours&lt;/code&gt; ）または＃3（ &lt;code&gt;theirs&lt;/code&gt; ）を使用します。</target>
        </trans-unit>
        <trans-unit id="f350add778942f50c4b0b2f8798762ec9d6fc205" translate="yes" xml:space="preserve">
          <source>When restoring files on the working tree from the index, do not abort the operation if there are unmerged entries and neither &lt;code&gt;--ours&lt;/code&gt;, &lt;code&gt;--theirs&lt;/code&gt;, &lt;code&gt;--merge&lt;/code&gt; or &lt;code&gt;--conflict&lt;/code&gt; is specified. Unmerged paths on the working tree are left alone.</source>
          <target state="translated">インデックスから作業ツリー上のファイルを復元するときに、 &lt;code&gt;--theirs&lt;/code&gt; いないエントリがあり、-- &lt;code&gt;--ours&lt;/code&gt; 、-- theirs、 &lt;code&gt;--merge&lt;/code&gt; merge、または &lt;code&gt;--conflict&lt;/code&gt; のいずれも指定されていない場合は、操作を中止しないでください。作業ツリーのマージされていないパスはそのまま残されます。</target>
        </trans-unit>
        <trans-unit id="84ac309392e16a1f3dcc1a792805de1c5dea7161" translate="yes" xml:space="preserve">
          <source>When restoring files on the working tree from the index, recreate the conflicted merge in the unmerged paths.</source>
          <target state="translated">インデックスから作業ツリー上のファイルを復元する際に、マージされていないパスで競合していたマージを再作成します。</target>
        </trans-unit>
        <trans-unit id="273a9228c51e5936f4d142f339102a2bbdd8c3b8" translate="yes" xml:space="preserve">
          <source>When retrieving svn commits into Git (as part of &lt;code&gt;fetch&lt;/code&gt;, &lt;code&gt;rebase&lt;/code&gt;, or &lt;code&gt;dcommit&lt;/code&gt; operations), look for the first &lt;code&gt;From:&lt;/code&gt; or &lt;code&gt;Signed-off-by:&lt;/code&gt; line in the log message and use that as the author string.</source>
          <target state="translated">Gitへのsvnコミットを（ &lt;code&gt;fetch&lt;/code&gt; 、 &lt;code&gt;rebase&lt;/code&gt; 、または &lt;code&gt;dcommit&lt;/code&gt; 操作の一部として）取得する場合、ログメッセージで最初の &lt;code&gt;From:&lt;/code&gt; または &lt;code&gt;Signed-off-by:&lt;/code&gt; 行を探し、それを作成者の文字列として使用します。</target>
        </trans-unit>
        <trans-unit id="78d119701beb340fc1dce20129de3c1bebaf8055" translate="yes" xml:space="preserve">
          <source>When revision range specifiers are used to limit the annotation, lines that have not changed since the range boundary (either the commit v2.6.18 or the most recent commit that is more than 3 weeks old in the above example) are blamed for that range boundary commit.</source>
          <target state="translated">アノテーションを制限するためにリビジョン範囲指定子が使用されている場合、範囲境界から変更されていない行(v2.6.18のコミットか、上記の例では3週間以上前の最新のコミットのいずれか)は、その範囲境界のコミットのせいにされてしまいます。</target>
        </trans-unit>
        <trans-unit id="802f2e7848870b44ce9f04fb441477cd05447e6c" translate="yes" xml:space="preserve">
          <source>When rewriting commits with &amp;lt;command&amp;gt; (currently &lt;code&gt;amend&lt;/code&gt; or &lt;code&gt;rebase&lt;/code&gt;) and this variable is set to &lt;code&gt;true&lt;/code&gt;, Git automatically copies your notes from the original to the rewritten commit. Defaults to &lt;code&gt;true&lt;/code&gt;, but see &quot;notes.rewriteRef&quot; below.</source>
          <target state="translated">&amp;lt;command&amp;gt;（現在は &lt;code&gt;amend&lt;/code&gt; または &lt;code&gt;rebase&lt;/code&gt; ）を使用してコミットを書き換え、この変数が &lt;code&gt;true&lt;/code&gt; に設定されている場合、Gitは元のメモを書き換えられたコミットに自動的にコピーします。デフォルトは &lt;code&gt;true&lt;/code&gt; ですが、以下の「notes.rewriteRef」を参照してください。</target>
        </trans-unit>
        <trans-unit id="b9c5c034bfc575d885230ecf217359276486be76" translate="yes" xml:space="preserve">
          <source>When rewriting commits with &amp;lt;command&amp;gt; (currently &lt;code&gt;amend&lt;/code&gt; or &lt;code&gt;rebase&lt;/code&gt;), if this variable is &lt;code&gt;false&lt;/code&gt;, git will not copy notes from the original to the rewritten commit. Defaults to &lt;code&gt;true&lt;/code&gt;. See also &quot;&lt;code&gt;notes.rewriteRef&lt;/code&gt;&quot; below.</source>
          <target state="translated">&amp;lt;command&amp;gt;を使用してコミットを書き換えるとき（現在は &lt;code&gt;amend&lt;/code&gt; または &lt;code&gt;rebase&lt;/code&gt; ）、この変数が &lt;code&gt;false&lt;/code&gt; の場合、gitは元のメモを書き換えられたコミットにコピーしません。デフォルトは &lt;code&gt;true&lt;/code&gt; です。以下の「 &lt;code&gt;notes.rewriteRef&lt;/code&gt; 」も参照してください。</target>
        </trans-unit>
        <trans-unit id="0528b909a801bc351dbefd46a3e339150f63bb9d" translate="yes" xml:space="preserve">
          <source>When rewriting commits, which notes to copy from the original to the rewritten commit. Must be a colon-delimited list of refs or globs.</source>
          <target state="translated">コミットを書き換える際に、元のコミットから書き換えられたコミットにどのメモをコピーするかを指定します。コロンで区切られた参照またはグロブのリストでなければなりません。</target>
        </trans-unit>
        <trans-unit id="777967b1b1cbeac1b786b4e659ef472d75c08474" translate="yes" xml:space="preserve">
          <source>When run from a subdirectory of the project, it can be told to exclude changes outside the directory and show pathnames relative to it with this option. When you are not in a subdirectory (e.g. in a bare repository), you can name which subdirectory to make the output relative to by giving a &amp;lt;path&amp;gt; as an argument.</source>
          <target state="translated">プロジェクトのサブディレクトリから実行すると、このオプションを使用して、ディレクトリ外の変更を除外し、ディレクトリに関連するパス名を表示するように指示できます。サブディレクトリ（たとえば、ベアリポジトリ内）にいない場合は、&amp;lt;path&amp;gt;を引数として指定することにより、出力を相対的にするサブディレクトリに名前を付けることができます。</target>
        </trans-unit>
        <trans-unit id="1526deda1d1c171ba9bb8aedb499ef46fa3558ac" translate="yes" xml:space="preserve">
          <source>When run from a subdirectory of the project, it can be told to exclude changes outside the directory and show pathnames relative to it with this option. When you are not in a subdirectory (e.g. in a bare repository), you can name which subdirectory to make the output relative to by giving a &amp;lt;path&amp;gt; as an argument. &lt;code&gt;--no-relative&lt;/code&gt; can be used to countermand both &lt;code&gt;diff.relative&lt;/code&gt; config option and previous &lt;code&gt;--relative&lt;/code&gt;.</source>
          <target state="translated">プロジェクトのサブディレクトリから実行する場合、このオプションを使用して、ディレクトリ外の変更を除外し、それに関連するパス名を表示するように指示できます。サブディレクトリ（ベアリポジトリなど）にいない場合は、引数として&amp;lt;path&amp;gt;を指定することで、出力を作成するサブディレクトリに名前を付けることができます。 &lt;code&gt;--no-relative&lt;/code&gt; を使用して、 &lt;code&gt;diff.relative&lt;/code&gt; 構成オプションと以前の &lt;code&gt;--relative&lt;/code&gt; の両方を無効にすることができます。</target>
        </trans-unit>
        <trans-unit id="c27ca634a7183f46a280e82c3af06c829ca10b89" translate="yes" xml:space="preserve">
          <source>When run from a subdirectory, the command usually outputs paths relative to the current directory. This option forces paths to be output relative to the project top directory.</source>
          <target state="translated">サブディレクトリから実行する場合、コマンドは通常、カレントディレクトリからの相対パスを出力します。このオプションは、プロジェクトのトップディレクトリからの相対パスを強制的に出力します。</target>
        </trans-unit>
        <trans-unit id="ed0ff11c4a5dd052209fd6d888b93db83b1003f1" translate="yes" xml:space="preserve">
          <source>When run in a directory that does not have &quot;.git&quot; repository directory, Git tries to find such a directory in the parent directories to find the top of the working tree, but by default it does not cross filesystem boundaries. This environment variable can be set to true to tell Git not to stop at filesystem boundaries. Like &lt;code&gt;GIT_CEILING_DIRECTORIES&lt;/code&gt;, this will not affect an explicit repository directory set via &lt;code&gt;GIT_DIR&lt;/code&gt; or on the command line.</source>
          <target state="translated">「.git」リポジトリディレクトリがないディレクトリで実行すると、Gitは親ディレクトリでそのようなディレクトリを見つけて作業ツリーの最上部を見つけようとしますが、デフォルトではファイルシステムの境界を越えません。この環境変数をtrueに設定すると、ファイルシステムの境界で停止しないようにGitに指示できます。 &lt;code&gt;GIT_CEILING_DIRECTORIES&lt;/code&gt; と同様に、これは &lt;code&gt;GIT_DIR&lt;/code&gt; またはコマンドラインで設定された明示的なリポジトリディレクトリには影響しません。</target>
        </trans-unit>
        <trans-unit id="9ce1b9e20fc14e8e8925879039b8daf3d52acd6a" translate="yes" xml:space="preserve">
          <source>When running the command with &lt;code&gt;-u&lt;/code&gt; and &lt;code&gt;-m&lt;/code&gt; options, the merge result may need to overwrite paths that are not tracked in the current branch. The command usually refuses to proceed with the merge to avoid losing such a path. However this safety valve sometimes gets in the way. For example, it often happens that the other branch added a file that used to be a generated file in your branch, and the safety valve triggers when you try to switch to that branch after you ran &lt;code&gt;make&lt;/code&gt; but before running &lt;code&gt;make clean&lt;/code&gt; to remove the generated file. This option tells the command to read per-directory exclude file (usually &lt;code&gt;.gitignore&lt;/code&gt;) and allows such an untracked but explicitly ignored file to be overwritten.</source>
          <target state="translated">&lt;code&gt;-u&lt;/code&gt; および &lt;code&gt;-m&lt;/code&gt; オプションを指定してコマンドを実行すると、マージ結果で、現在のブランチで追跡されていないパスを上書きする必要がある場合があります。コマンドは通常、そのようなパスが失われないようにするために、マージの続行を拒否します。ただし、この安全弁が邪魔になることがあります。たとえば、他のブランチがブランチで生成されたファイルであったファイルを追加し、 &lt;code&gt;make&lt;/code&gt; を実行した後、 &lt;code&gt;make clean&lt;/code&gt; を実行して生成されたファイルを削除する前にそのブランチに切り替えようとすると、安全弁がトリガーされることがよくありますファイル。このオプションは、ディレクトリごとの除外ファイル（通常は &lt;code&gt;.gitignore&lt;/code&gt; ）を読み取るようにコマンドに指示し、そのような追跡されないが明示的に無視されたファイルを上書きできるようにします。</target>
        </trans-unit>
        <trans-unit id="df426fd8f20937aff52c156a03a07b3202618140" translate="yes" xml:space="preserve">
          <source>When sending a patch this way, most often you are sending your own patch, so in addition to the &quot;&lt;code&gt;From $SHA1 $magic_timestamp&lt;/code&gt;&quot; marker you should omit &lt;code&gt;From:&lt;/code&gt; and &lt;code&gt;Date:&lt;/code&gt; lines from the patch file. The patch title is likely to be different from the subject of the discussion the patch is in response to, so it is likely that you would want to keep the Subject: line, like the example above.</source>
          <target state="translated">この方法でパッチを送信する場合、ほとんどの場合、独自のパッチを送信するため、「 &lt;code&gt;From $SHA1 $magic_timestamp&lt;/code&gt; 」マーカーに加えて、パッチファイルから &lt;code&gt;From:&lt;/code&gt; および &lt;code&gt;Date:&lt;/code&gt; 行を省略します。パッチのタイトルは、パッチが対応するディスカッションの件名とは異なる可能性が高いため、上記の例のように、Subject：行を保持したい場合があります。</target>
        </trans-unit>
        <trans-unit id="85b26b0293721642a3d3ba409cae09a21a570f47" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;always&lt;/code&gt;, always highlight matches. When &lt;code&gt;false&lt;/code&gt; (or &lt;code&gt;never&lt;/code&gt;), never. When set to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;auto&lt;/code&gt;, use color only when the output is written to the terminal. If unset, then the value of &lt;code&gt;color.ui&lt;/code&gt; is used (&lt;code&gt;auto&lt;/code&gt; by default).</source>
          <target state="translated">&lt;code&gt;always&lt;/code&gt; に設定すると、常に一致を強調表示します。 &lt;code&gt;false&lt;/code&gt; （または &lt;code&gt;never&lt;/code&gt; ）でない場合、決して。 &lt;code&gt;true&lt;/code&gt; または &lt;code&gt;auto&lt;/code&gt; に設定されている場合、出力が端末に書き込まれるときにのみ色を使用します。設定しない場合、 &lt;code&gt;color.ui&lt;/code&gt; の値が使用されます（デフォルトでは &lt;code&gt;auto&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="dfd0a45591bf4cdb6d73f4e9b16cc039b04690be" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;always&lt;/code&gt;, always use colors for interactive prompts and displays (such as those used by &quot;git-add --interactive&quot; and &quot;git-clean --interactive&quot;). When false (or &lt;code&gt;never&lt;/code&gt;), never. When set to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;auto&lt;/code&gt;, use colors only when the output is to the terminal. If unset, then the value of &lt;code&gt;color.ui&lt;/code&gt; is used (&lt;code&gt;auto&lt;/code&gt; by default).</source>
          <target state="translated">&lt;code&gt;always&lt;/code&gt; に設定されている場合、インタラクティブプロンプトとディスプレイには常に色を使用します（「git-add --interactive」や「git-clean --interactive」で使用される色など）。false（または、 &lt;code&gt;never&lt;/code&gt; ）でない場合、決して。 &lt;code&gt;true&lt;/code&gt; または &lt;code&gt;auto&lt;/code&gt; に設定されている場合、出力が端末への場合のみ色を使用します。設定しない場合、 &lt;code&gt;color.ui&lt;/code&gt; の値が使用されます（デフォルトでは &lt;code&gt;auto&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="9ba7d00c9f4d532d2b9486b8c87259ed84e278f3" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;change&lt;/code&gt;, tells &lt;code&gt;git apply&lt;/code&gt; to ignore changes in whitespace, in the same way as the &lt;code&gt;--ignore-space-change&lt;/code&gt; option. When set to one of: no, none, never, false tells &lt;code&gt;git apply&lt;/code&gt; to respect all whitespace differences. See &lt;a href=&quot;git-apply&quot;&gt;git-apply[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;change&lt;/code&gt; に設定すると、-- &lt;code&gt;--ignore-space-change&lt;/code&gt; オプションと同じ方法で、空白の変更を無視するように &lt;code&gt;git apply&lt;/code&gt; に指示します。no、none、never、falseのいずれかに設定すると、すべての空白の違いを尊重 &lt;code&gt;git apply&lt;/code&gt; ようにgit applyに指示します。&lt;a href=&quot;git-apply&quot;&gt;git-apply [1]を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="8d6e4c3c7b2c6d56efae11b1e0ed0dcb5ce2357b" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;merges&lt;/code&gt;, rebase using &lt;code&gt;git rebase --rebase-merges&lt;/code&gt; so that the local merge commits are included in the rebase (see &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; for details).</source>
          <target state="translated">&lt;code&gt;git rebase --rebase-merges&lt;/code&gt; 設定した場合 &lt;code&gt;merges&lt;/code&gt; 、git rebase --rebase-mergesを使用してリベースし、ローカルマージコミットがリベースに含まれるようにします（詳細は&lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]&lt;/a&gt;を参照）。</target>
        </trans-unit>
        <trans-unit id="3726def44fed6d7863a8f10abeef80361e6f2701" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;preserve&lt;/code&gt; (deprecated in favor of &lt;code&gt;merges&lt;/code&gt;), rebase with the &lt;code&gt;--preserve-merges&lt;/code&gt; option passed to &lt;code&gt;git rebase&lt;/code&gt; so that locally created merge commits will not be flattened.</source>
          <target state="translated">&lt;code&gt;preserve&lt;/code&gt; するように設定されている場合（ &lt;code&gt;merges&lt;/code&gt; ため非推奨）、ローカルで作成されたマージコミットがフラット化されないように、 &lt;code&gt;git rebase&lt;/code&gt; に渡される &lt;code&gt;--preserve-merges&lt;/code&gt; オプションでリベースします。</target>
        </trans-unit>
        <trans-unit id="14ded32327ec4343589fd7082ddc1f7fdc8962f6" translate="yes" xml:space="preserve">
          <source>When set to true, &lt;code&gt;git reset&lt;/code&gt; will default to the &lt;code&gt;--quiet&lt;/code&gt; option.</source>
          <target state="translated">trueに設定すると、 &lt;code&gt;git reset&lt;/code&gt; はデフォルトで &lt;code&gt;--quiet&lt;/code&gt; オプションになります。</target>
        </trans-unit>
        <trans-unit id="01f095efe30e9d32fee48e094d88f96d4eba1bad" translate="yes" xml:space="preserve">
          <source>When set to true, &lt;code&gt;git-rerere&lt;/code&gt; updates the index with the resulting contents after it cleanly resolves conflicts using previously recorded resolution. Defaults to false.</source>
          <target state="translated">trueに設定すると、 &lt;code&gt;git-rerere&lt;/code&gt; は以前に記録された解決策を使用して競合を完全に解決した後、結果のコンテンツでインデックスを更新します。デフォルトはfalseです。</target>
        </trans-unit>
        <trans-unit id="e2cc234f1ab166d2852bd6878a576806a19d5021" translate="yes" xml:space="preserve">
          <source>When set to true, a clone of this submodule will be performed as a shallow clone (with a history depth of 1) unless the user explicitly asks for a non-shallow clone.</source>
          <target state="translated">trueに設定すると、ユーザが明示的に浅くないクローンを要求しない限り、このサブモジュールのクローンは浅いクローンとして実行されます (履歴の深さは1)。</target>
        </trans-unit>
        <trans-unit id="6b72e60e4df8bc4b62a55c38ddf1b7b574998e6d" translate="yes" xml:space="preserve">
          <source>When set to true, automatically create a temporary stash entry before the operation begins, and apply it after the operation ends. This means that you can run merge on a dirty worktree. However, use with care: the final stash application after a successful merge might result in non-trivial conflicts. This option can be overridden by the &lt;code&gt;--no-autostash&lt;/code&gt; and &lt;code&gt;--autostash&lt;/code&gt; options of &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt;. Defaults to false.</source>
          <target state="translated">trueに設定すると、操作を開始する前に一時的なstashエントリを自動的に作成し、操作の終了後に適用します。これは、ダーティワークツリーでマージを実行できることを意味します。ただし、注意して使用してください。マージが成功した後の最後のstashアプリケーションは、重要な競合を引き起こす可能性があります。このオプションは、&lt;a href=&quot;git-merge&quot;&gt;git-merge [1]&lt;/a&gt;の &lt;code&gt;--no-autostash&lt;/code&gt; および &lt;code&gt;--autostash&lt;/code&gt; オプションでオーバーライドできます。デフォルトはfalseです。</target>
        </trans-unit>
        <trans-unit id="c92df8026c7e3a5d595e452302b48399c0fa7807" translate="yes" xml:space="preserve">
          <source>When set to true, automatically create a temporary stash entry before the operation begins, and apply it after the operation ends. This means that you can run rebase on a dirty worktree. However, use with care: the final stash application after a successful rebase might result in non-trivial conflicts. This option can be overridden by the &lt;code&gt;--no-autostash&lt;/code&gt; and &lt;code&gt;--autostash&lt;/code&gt; options of &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt;. Defaults to false.</source>
          <target state="translated">trueに設定すると、操作が始まる前に一時的なstashエントリーが自動的に作成され、操作が終了した後にそれが適用されます。これは、ダーティなワークツリーでリベースを実行できることを意味します。ただし、注意して使用してください。リベースが成功した後の最後のstashアプリケーションは、重要な競合を引き起こす可能性があります。このオプションは、&lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]&lt;/a&gt;の &lt;code&gt;--no-autostash&lt;/code&gt; および &lt;code&gt;--autostash&lt;/code&gt; オプションによって上書きできます。デフォルトはfalseです。</target>
        </trans-unit>
        <trans-unit id="454e58d95a3a4a743aeef0859eac2b9c78e6f07a" translate="yes" xml:space="preserve">
          <source>When set to true, fetching from this remote by default will also remove any local tags that no longer exist on the remote if pruning is activated in general via &lt;code&gt;remote.&amp;lt;name&amp;gt;.prune&lt;/code&gt;, &lt;code&gt;fetch.prune&lt;/code&gt; or &lt;code&gt;--prune&lt;/code&gt;. Overrides &lt;code&gt;fetch.pruneTags&lt;/code&gt; settings, if any.</source>
          <target state="translated">trueに設定すると、このリモートからデフォルトでフェッチすると、一般にプルーニングが &lt;code&gt;remote.&amp;lt;name&amp;gt;.prune&lt;/code&gt; 、 &lt;code&gt;fetch.prune&lt;/code&gt; または &lt;code&gt;--prune&lt;/code&gt; を介してアクティブ化されている場合、リモートに存在しないローカルタグも削除されます。 &lt;code&gt;fetch.pruneTags&lt;/code&gt; 設定をオーバーライドします（ある場合）。</target>
        </trans-unit>
        <trans-unit id="2f08cdfbf2bbbb5ba49961d7515ae4f7f92a166e" translate="yes" xml:space="preserve">
          <source>When set to true, fetching from this remote by default will also remove any remote-tracking references that no longer exist on the remote (as if the &lt;code&gt;--prune&lt;/code&gt; option was given on the command line). Overrides &lt;code&gt;fetch.prune&lt;/code&gt; settings, if any.</source>
          <target state="translated">trueに設定すると、デフォルトでこのリモートからフェッチすると、リモートに存在しなくなったリモートトラッキング参照も削除されます（コマンドラインで &lt;code&gt;--prune&lt;/code&gt; オプションが指定されたかのように）。 &lt;code&gt;fetch.prune&lt;/code&gt; 設定があれば、それをオーバーライドします。</target>
        </trans-unit>
        <trans-unit id="5739477a3b9489a88899be9378f898520709209f" translate="yes" xml:space="preserve">
          <source>When set to true, git-receive-pack will advertise the push options capability to its clients. False by default.</source>
          <target state="translated">true に設定すると、git-receive-pack はクライアントにプッシュオプションの機能を宣伝します。デフォルトは False です。</target>
        </trans-unit>
        <trans-unit id="af12eb66ec26d00e256f0fbfcc7125aeb108aa2e" translate="yes" xml:space="preserve">
          <source>When set to true, this remote will be used to fetch promisor objects.</source>
          <target state="translated">true に設定すると、このリモートはプロミバイザオブジェクトのフェッチに使用されます。</target>
        </trans-unit>
        <trans-unit id="384788e82f8977bea09d8463e5bbfca26ec8a699" translate="yes" xml:space="preserve">
          <source>When set, the fetch or receive will abort in the case of a malformed object or a link to a nonexistent object. In addition, various other issues are checked for, including legacy issues (see &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt;), and potential security issues like the existence of a &lt;code&gt;.GIT&lt;/code&gt; directory or a malicious &lt;code&gt;.gitmodules&lt;/code&gt; file (see the release notes for v2.2.1 and v2.17.1 for details). Other sanity and security checks may be added in future releases.</source>
          <target state="translated">設定すると、不正なオブジェクトまたは存在しないオブジェクトへのリンクの場合、フェッチまたは受信は中止されます。さらに、レガシーの問題（ &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; 参照）や、 &lt;code&gt;.GIT&lt;/code&gt; ディレクトリや悪意のある &lt;code&gt;.gitmodules&lt;/code&gt; ファイルの存在などの潜在的なセキュリティ問題（v2のリリースノートを参照）など、他のさまざまな問題がチェックされます。詳細については、2.1およびv2.17.1）。その他の健全性およびセキュリティチェックは、将来のリリースで追加される可能性があります。</target>
        </trans-unit>
        <trans-unit id="51a9809b150b3fa600feb6c1ea57e78e8de9e787" translate="yes" xml:space="preserve">
          <source>When showing &lt;code&gt;short&lt;/code&gt; or &lt;code&gt;porcelain&lt;/code&gt; status output, print the filename verbatim and terminate the entries with NUL, instead of LF. If no format is given, implies the &lt;code&gt;--porcelain&lt;/code&gt; output format. Without the &lt;code&gt;-z&lt;/code&gt; option, filenames with &quot;unusual&quot; characters are quoted as explained for the configuration variable &lt;code&gt;core.quotePath&lt;/code&gt; (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;short&lt;/code&gt; または &lt;code&gt;porcelain&lt;/code&gt; ステータス出力を表示する場合、ファイル名をそのまま印刷し、LFではなくNULでエントリを終了します。フォーマットが指定されていない場合は、 &lt;code&gt;--porcelain&lt;/code&gt; 出力フォーマットを意味します。 &lt;code&gt;-z&lt;/code&gt; オプションを使用しない場合、「異常な」文字を含むファイル名は、構成変数 &lt;code&gt;core.quotePath&lt;/code&gt; で説明されているように引用符で囲まれます（&lt;a href=&quot;git-config&quot;&gt;git-config [1]を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="43f2e6f1690661b84f31283fe1b400a9df885029" translate="yes" xml:space="preserve">
          <source>When showing a change that involves a rename or a copy, &lt;code&gt;--stat&lt;/code&gt; output formats the pathnames compactly by combining common prefix and suffix of the pathnames. For example, a change that moves &lt;code&gt;arch/i386/Makefile&lt;/code&gt; to &lt;code&gt;arch/x86/Makefile&lt;/code&gt; while modifying 4 lines will be shown like this:</source>
          <target state="translated">名前変更またはコピーを伴う変更を表示する場合、 &lt;code&gt;--stat&lt;/code&gt; 出力は、パス名の共通のプレフィックスとサフィックスを組み合わせることにより、パス名をコンパクトにフォーマットします。たとえば、4行を変更しながら &lt;code&gt;arch/i386/Makefile&lt;/code&gt; を &lt;code&gt;arch/x86/Makefile&lt;/code&gt; に移動する変更は、次のように表示されます。</target>
        </trans-unit>
        <trans-unit id="5d4332d6cfe825bd00a3bfef76e9ffde728a5dde" translate="yes" xml:space="preserve">
          <source>When showing commit messages, also show notes which are stored in the given ref. The ref must be fully qualified. If the given ref does not exist, it is not an error but means that no notes should be printed.</source>
          <target state="translated">コミットメッセージを表示する際には、与えられた ref に保存されているノートも表示します。refは完全に修飾されていなければなりません。指定された ref が存在しない場合はエラーではありませんが、ノートを印刷すべきではないことを意味します。</target>
        </trans-unit>
        <trans-unit id="43020b05da28d5245a5572e708a459c7bb4d40bf" translate="yes" xml:space="preserve">
          <source>When showing object names, prefix them with &lt;code&gt;^&lt;/code&gt; and strip &lt;code&gt;^&lt;/code&gt; prefix from the object names that already have one.</source>
          <target state="translated">オブジェクト名を表示するときは、プレフィックスに &lt;code&gt;^&lt;/code&gt; を付け、すでに存在するオブジェクト名から &lt;code&gt;^&lt;/code&gt; プレフィックスを取り除きます。</target>
        </trans-unit>
        <trans-unit id="bf158ec030a04af48fd84ff99f4cdef61dbc802c" translate="yes" xml:space="preserve">
          <source>When showing the value of &amp;lt;name&amp;gt; as a symbolic ref, try to shorten the value, e.g. from &lt;code&gt;refs/heads/master&lt;/code&gt; to &lt;code&gt;master&lt;/code&gt;.</source>
          <target state="translated">&amp;lt;name&amp;gt;の値をシンボリック参照として表示する場合は、値を短くしてください（例： &lt;code&gt;refs/heads/master&lt;/code&gt; から &lt;code&gt;master&lt;/code&gt; )。</target>
        </trans-unit>
        <trans-unit id="d07871fea9de7a0886062f3dfa8bbc506d97b667" translate="yes" xml:space="preserve">
          <source>When shown by &lt;code&gt;git diff-tree -c&lt;/code&gt;, it compares the parents of a merge commit with the merge result (i.e. file1..fileN are the parents). When shown by &lt;code&gt;git diff-files -c&lt;/code&gt;, it compares the two unresolved merge parents with the working tree file (i.e. file1 is stage 2 aka &quot;our version&quot;, file2 is stage 3 aka &quot;their version&quot;).</source>
          <target state="translated">で示された場合 &lt;code&gt;git diff-tree -c&lt;/code&gt; 、それがマージの親はマージ結果をコミット比較する（すなわちfile1..fileNは親です）。で示される場合には &lt;code&gt;git diff-files -c&lt;/code&gt; 、それは作業ツリーのファイルと2人の未解決のマージ両親を比較する（つまり、file1が「私たちのバージョン」別名、ステージ2で、FILE2は「彼らのバージョン」別名ステージ3です）。</target>
        </trans-unit>
        <trans-unit id="aea42e2933202e5e3d5f69076d6bebeb378dfcd9" translate="yes" xml:space="preserve">
          <source>When some commits have been skipped (using &quot;git bisect skip&quot;), then the bisection algorithm is the same for step 1) to 3). But then we use roughly the following steps:</source>
          <target state="translated">いくつかのコミットがスキップされている場合 (「git bisect skip」を使用)、二等分アルゴリズムはステップ 1)から 3)まで同じです。しかし、大まかには次のようなステップを使います。</target>
        </trans-unit>
        <trans-unit id="4192528671a22eca45fcad6bb5614a7ec165a5d4" translate="yes" xml:space="preserve">
          <source>When specified one or more times, &lt;code&gt;-L&lt;/code&gt; restricts annotation to the requested lines.</source>
          <target state="translated">&lt;code&gt;-L&lt;/code&gt; を 1回以上指定すると、注釈は要求された行に制限されます。</target>
        </trans-unit>
        <trans-unit id="75acd7ee44b0e77c6b233d3615dca447d4cfdc8c" translate="yes" xml:space="preserve">
          <source>When specifying the -v option the format used is:</source>
          <target state="translated">v オプションを指定すると、使用されるフォーマットは次のようになります。</target>
        </trans-unit>
        <trans-unit id="0550af8039db48de114d18431bb7375cee83b91b" translate="yes" xml:space="preserve">
          <source>When switching branches with &lt;code&gt;--merge&lt;/code&gt;, staged changes may be lost.</source>
          <target state="translated">&lt;code&gt;--merge&lt;/code&gt; を使用してブランチを切り替えると、段階的な変更が失われる可能性があります。</target>
        </trans-unit>
        <trans-unit id="1f4fa4b7e00510c39cb24519dad3b49f07cff89d" translate="yes" xml:space="preserve">
          <source>When switching branches, if you have local modifications to one or more files that are different between the current branch and the branch to which you are switching, the command refuses to switch branches in order to preserve your modifications in context. However, with this option, a three-way merge between the current branch, your working tree contents, and the new branch is done, and you will be on the new branch.</source>
          <target state="translated">ブランチを切り替える際に、現在のブランチと切り替え先のブランチで異なるファイルにローカルで変更があった場合、コマンドは変更内容をコンテキストとして保持するためにブランチの切り替えを拒否します。しかし、このオプションを使用すると、現在のブランチ、作業ツリーの内容、新しいブランチの間で三者間のマージが行われ、新しいブランチに移動します。</target>
        </trans-unit>
        <trans-unit id="7b0d58bb9103d272bfd260e85d337e6780ed225d" translate="yes" xml:space="preserve">
          <source>When switching branches, proceed even if the index or the working tree differs from &lt;code&gt;HEAD&lt;/code&gt;. This is used to throw away local changes.</source>
          <target state="translated">ブランチを切り替えるときは、インデックスまたは作業ツリーが &lt;code&gt;HEAD&lt;/code&gt; と異なっていても続行してください。これは、ローカルの変更を破棄するために使用されます。</target>
        </trans-unit>
        <trans-unit id="c0e1144ec53aca779c8724f81a0ba0a804f51a81" translate="yes" xml:space="preserve">
          <source>When the &quot;-C&quot; option is used, the original contents of modified files, and deleted files (and also unmodified files, if the &quot;--find-copies-harder&quot; option is used) are considered as candidates of the source files in rename/copy operation. If the input were like these filepairs, that talk about a modified file fileY and a newly created file file0:</source>
          <target state="translated">C &quot;オプションを使用した場合、変更されたファイルの元の内容と削除されたファイル(--find-copies-harderオプションを使用した場合は未変更のファイルも含む)がリネーム/コピー操作の元ファイルの候補として考慮されます。入力が以下のファイルペアのようなものだとすると,修正ファイルYと新規作成ファイル0の話になります.</target>
        </trans-unit>
        <trans-unit id="f6565c60ff0e235a6b049473d40ff8e72074a702" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; argument is a branch name, the &lt;code&gt;--detach&lt;/code&gt; option can be used to detach &lt;code&gt;HEAD&lt;/code&gt; at the tip of the branch (&lt;code&gt;git checkout
&amp;lt;branch&amp;gt;&lt;/code&gt; would check out that branch without detaching &lt;code&gt;HEAD&lt;/code&gt;).</source>
          <target state="translated">とき &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 引数はブランチ名で、 &lt;code&gt;--detach&lt;/code&gt; オプションは、デタッチに使用することができ &lt;code&gt;HEAD&lt;/code&gt; 枝の先端に（ &lt;code&gt;git checkout &amp;lt;branch&amp;gt;&lt;/code&gt; 取り外すことなく、そのブランチをチェックアウトでしょう &lt;code&gt;HEAD&lt;/code&gt; を）。</target>
        </trans-unit>
        <trans-unit id="588cf4af82a088b4d8241fca9de08188511b35c3" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;--aggressive&lt;/code&gt; option is supplied, &lt;a href=&quot;git-repack&quot;&gt;git-repack[1]&lt;/a&gt; will be invoked with the &lt;code&gt;-f&lt;/code&gt; flag, which in turn will pass &lt;code&gt;--no-reuse-delta&lt;/code&gt; to &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt;. This will throw away any existing deltas and re-compute them, at the expense of spending much more time on the repacking.</source>
          <target state="translated">&lt;code&gt;--aggressive&lt;/code&gt; オプションが供給される、&lt;a href=&quot;git-repack&quot;&gt;のgit -再梱包[1]&lt;/a&gt;で呼び出される &lt;code&gt;-f&lt;/code&gt; 順番に通過するフラッグ、 &lt;code&gt;--no-reuse-delta&lt;/code&gt; に&lt;a href=&quot;git-pack-objects&quot;&gt;gitのパック・オブジェクト[1] &lt;/a&gt;。これにより、既存のデルタが破棄されて再計算されますが、再パッキングに多くの時間が費やされます。</target>
        </trans-unit>
        <trans-unit id="36c732582138b85601314513444f94ba223454f7" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;--auto-merge&lt;/code&gt; is given, meld will merge all non-conflicting parts automatically, highlight the conflicting parts and wait for user decision. Setting &lt;code&gt;mergetool.meld.useAutoMerge&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; tells Git to unconditionally use the &lt;code&gt;--auto-merge&lt;/code&gt; option with &lt;code&gt;meld&lt;/code&gt;. Setting this value to &lt;code&gt;auto&lt;/code&gt; makes git detect whether &lt;code&gt;--auto-merge&lt;/code&gt; is supported and will only use &lt;code&gt;--auto-merge&lt;/code&gt; when available. A value of &lt;code&gt;false&lt;/code&gt; avoids using &lt;code&gt;--auto-merge&lt;/code&gt; altogether, and is the default value.</source>
          <target state="translated">とき &lt;code&gt;--auto-merge&lt;/code&gt; 与えられ、メルドは、自動的にすべての競合しない部分をマージ矛盾する部分をハイライト表示し、ユーザの決定を待ちます。設定 &lt;code&gt;mergetool.meld.useAutoMerge&lt;/code&gt; をする &lt;code&gt;true&lt;/code&gt; 無条件に使用するGitリポジトリを伝え &lt;code&gt;--auto-merge&lt;/code&gt; とオプション &lt;code&gt;meld&lt;/code&gt; 。この値を &lt;code&gt;auto&lt;/code&gt; に設定すると、gitは &lt;code&gt;--auto-merge&lt;/code&gt; がサポートされているかどうかを検出 &lt;code&gt;--auto-merge&lt;/code&gt; 、使用可能な場合にのみ--auto-mergeを使用します。 &lt;code&gt;false&lt;/code&gt; の値は、 &lt;code&gt;--auto-merge&lt;/code&gt; 使用を完全に回避し、デフォルト値です。</target>
        </trans-unit>
        <trans-unit id="82879b1b4c41ea78abef977470f6f223214f239a" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;--stdin&lt;/code&gt; option is provided, the patterns are read from standard in as a newline-delimited list instead of from the arguments.</source>
          <target state="translated">とき &lt;code&gt;--stdin&lt;/code&gt; オプションが提供され、パターンは改行で区切られたリストとしての代わりに、引数から標準でから読み込まれます。</target>
        </trans-unit>
        <trans-unit id="0e72b560677fc7dbf879d4b64bab949efbe4ffc6" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;-l&lt;/code&gt; option is used, format changes to</source>
          <target state="translated">ときに &lt;code&gt;-l&lt;/code&gt; オプションを使用する、フォーマットが変更に</target>
        </trans-unit>
        <trans-unit id="2d7535050bbd171bed81a20302444843893d883d" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;-z&lt;/code&gt; option is given, pathnames are printed as is and without any quoting and lines are terminated with a NUL (ASCII 0x00) byte.</source>
          <target state="translated">場合 &lt;code&gt;-z&lt;/code&gt; オプションが指定され、任意の引用なしでラインがNUL（ASCII 0&amp;times;00）バイトで終端されているように、パス名が印刷されています。</target>
        </trans-unit>
        <trans-unit id="e231e06fa3f3b3606e814466b6e12bf27e65315d" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;.gitattributes&lt;/code&gt; file is missing from the work tree, the path in the index is used as a fall-back. During checkout process, &lt;code&gt;.gitattributes&lt;/code&gt; in the index is used and then the file in the working tree is used as a fall-back.</source>
          <target state="translated">&lt;code&gt;.gitattributes&lt;/code&gt; ファイルが作業ツリーにない場合、インデックス内のパスがフォールバックとして使用されます。チェックアウトプロセス中に、インデックス内の &lt;code&gt;.gitattributes&lt;/code&gt; が使用され、作業ツリー内のファイルがフォールバックとして使用されます。</target>
        </trans-unit>
        <trans-unit id="ca6fe469ff13b0a4412dea9bd34db705e00a71db" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;LESS&lt;/code&gt; environment variable is unset, Git sets it to &lt;code&gt;FRX&lt;/code&gt; (if &lt;code&gt;LESS&lt;/code&gt; environment variable is set, Git does not change it at all). If you want to selectively override Git&amp;rsquo;s default setting for &lt;code&gt;LESS&lt;/code&gt;, you can set &lt;code&gt;core.pager&lt;/code&gt; to e.g. &lt;code&gt;less -S&lt;/code&gt;. This will be passed to the shell by Git, which will translate the final command to &lt;code&gt;LESS=FRX less -S&lt;/code&gt;. The environment does not set the &lt;code&gt;S&lt;/code&gt; option but the command line does, instructing less to truncate long lines. Similarly, setting &lt;code&gt;core.pager&lt;/code&gt; to &lt;code&gt;less -+F&lt;/code&gt; will deactivate the &lt;code&gt;F&lt;/code&gt; option specified by the environment from the command-line, deactivating the &quot;quit if one screen&quot; behavior of &lt;code&gt;less&lt;/code&gt;. One can specifically activate some flags for particular commands: for example, setting &lt;code&gt;pager.blame&lt;/code&gt; to &lt;code&gt;less -S&lt;/code&gt; enables line truncation only for &lt;code&gt;git blame&lt;/code&gt;.</source>
          <target state="translated">とき &lt;code&gt;LESS&lt;/code&gt; の環境変数が設定されていない、Gitはそれを設定し &lt;code&gt;FRX&lt;/code&gt; （場合 &lt;code&gt;LESS&lt;/code&gt; の環境変数が設定され、Gitがすべてでそれを変更しません）。 &lt;code&gt;core.pager&lt;/code&gt; &lt;code&gt;LESS&lt;/code&gt; のデフォルト設定を選択的にオーバーライドする場合は、core.pagerをたとえば &lt;code&gt;less -S&lt;/code&gt; に設定できます。これはGitによってシェルに渡され、最後のコマンドが &lt;code&gt;LESS=FRX less -S&lt;/code&gt; に変換されます。環境は &lt;code&gt;S&lt;/code&gt; オプションを設定しませんが、コマンドラインは設定し、長い行を切り捨てるように少なく指示します。同様に、 &lt;code&gt;core.pager&lt;/code&gt; をless- &lt;code&gt;less -+F&lt;/code&gt; に設定すると、 &lt;code&gt;F&lt;/code&gt; が非アクティブになります「やめる場合は、1つの画面」行動不活性化するコマンドラインから、環境によって指定されたオプション、 &lt;code&gt;less&lt;/code&gt; 。特定のコマンドのフラグを具体的にアクティブにすることができます。たとえば、 &lt;code&gt;pager.blame&lt;/code&gt; を &lt;code&gt;less -S&lt;/code&gt; に設定すると、 &lt;code&gt;git blame&lt;/code&gt; に対してのみ行の切り捨てが有効になります。</target>
        </trans-unit>
        <trans-unit id="74ad9f83ee4c2323b6a50919a4a444bb844e349c" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;core.fsmonitor&lt;/code&gt; configuration variable is changed, the file system monitor is added to or removed from the index the next time a command reads the index. When &lt;code&gt;--[no-]fsmonitor&lt;/code&gt; are used, the file system monitor is immediately added to or removed from the index.</source>
          <target state="translated">場合 &lt;code&gt;core.fsmonitor&lt;/code&gt; の構成変数が変更され、ファイル・システム・モニターは、インデックスからのコマンドは、インデックスを読み取る次回に追加または削除されています。場合 &lt;code&gt;--[no-]fsmonitor&lt;/code&gt; 使用される、ファイル・システム・モニターはすぐに追加またはインデックスから削除されます。</target>
        </trans-unit>
        <trans-unit id="a4c9cc7c80e5659747cb4b3bf0914ba1addde698" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;core.untrackedCache&lt;/code&gt; configuration variable is changed, the untracked cache is added to or removed from the index the next time a command reads the index; while when &lt;code&gt;--[no-|force-]untracked-cache&lt;/code&gt; are used, the untracked cache is immediately added to or removed from the index.</source>
          <target state="translated">場合 &lt;code&gt;core.untrackedCache&lt;/code&gt; の構成変数が変更され、追跡されていないキャッシュインデックスからのコマンドは、インデックスを読み取る次回に追加または削除されています。一方、 &lt;code&gt;--[no-|force-]untracked-cache&lt;/code&gt; を使用すると、追跡されていないキャッシュがすぐにインデックスに追加されるか、インデックスから削除されます。</target>
        </trans-unit>
        <trans-unit id="a212ca612f0b7b9b082dffe71078dd396d414402" translate="yes" xml:space="preserve">
          <source>When the attribute &lt;code&gt;ident&lt;/code&gt; is set for a path, Git replaces &lt;code&gt;$Id$&lt;/code&gt; in the blob object with &lt;code&gt;$Id:&lt;/code&gt;, followed by the 40-character hexadecimal blob object name, followed by a dollar sign &lt;code&gt;$&lt;/code&gt; upon checkout. Any byte sequence that begins with &lt;code&gt;$Id:&lt;/code&gt; and ends with &lt;code&gt;$&lt;/code&gt; in the worktree file is replaced with &lt;code&gt;$Id$&lt;/code&gt; upon check-in.</source>
          <target state="translated">パスに属性 &lt;code&gt;ident&lt;/code&gt; が設定されている場合、Gitはblobオブジェクトの &lt;code&gt;$Id$&lt;/code&gt; を &lt;code&gt;$Id:&lt;/code&gt; に置き換え、その後に40文字の16進数のblobオブジェクト名を続け、チェックアウト時にドル記号 &lt;code&gt;$&lt;/code&gt; を続けます。ワークツリーファイルで &lt;code&gt;$Id:&lt;/code&gt; で始まり &lt;code&gt;$&lt;/code&gt; で終わるバイトシーケンスは、チェックイン時に &lt;code&gt;$Id$&lt;/code&gt; に置き換えられます。</target>
        </trans-unit>
        <trans-unit id="fa514f01de77ed627378917f2aa0b40cefa8c9a0" translate="yes" xml:space="preserve">
          <source>When the command enters the interactive mode, it shows the files and directories to be cleaned, and goes into its interactive command loop.</source>
          <target state="translated">コマンドが対話型モードに入ると、クリーンアップするファイルとディレクトリを表示し、対話型コマンドループに入ります。</target>
        </trans-unit>
        <trans-unit id="8e767c7023b00ca52d4fb770ab49ce4dc284f987" translate="yes" xml:space="preserve">
          <source>When the command enters the interactive mode, it shows the output of the &lt;code&gt;status&lt;/code&gt; subcommand, and then goes into its interactive command loop.</source>
          <target state="translated">コマンドがインタラクティブモードに入ると、 &lt;code&gt;status&lt;/code&gt; サブコマンドの出力が表示され、インタラクティブコマンドループに入ります。</target>
        </trans-unit>
        <trans-unit id="e95952399796aad65deb415e39c303153d01cdf9" translate="yes" xml:space="preserve">
          <source>When the command is invoked from a subdirectory, show the path of the current directory relative to the top-level directory.</source>
          <target state="translated">サブディレクトリからコマンドが起動された場合、トップレベルディレクトリからの相対的なカレントディレクトリのパスを表示します。</target>
        </trans-unit>
        <trans-unit id="45506eccf72696bf6e0287a6eeda327142bb0f41" translate="yes" xml:space="preserve">
          <source>When the command is invoked from a subdirectory, show the path of the top-level directory relative to the current directory (typically a sequence of &quot;../&quot;, or an empty string).</source>
          <target state="translated">コマンドがサブディレクトリから起動された場合、カレントディレクトリからの相対的なトップレベルディレクトリのパスを表示します (通常は &quot;../&quot; のシーケンス、または空の文字列)。</target>
        </trans-unit>
        <trans-unit id="609d76b7287e730d5e5fcae1b57a1cde4d02d1ae" translate="yes" xml:space="preserve">
          <source>When the command is run without pathspec, it errors out, instead of deinit-ing everything, to prevent mistakes.</source>
          <target state="translated">pathspecなしでコマンドを実行すると、すべてをdeinitするのではなく、エラーアウトしてしまうので、ミスを防ぎます。</target>
        </trans-unit>
        <trans-unit id="2ebded60d45ed8776b0324d8d2138df90f552a15" translate="yes" xml:space="preserve">
          <source>When the command line does not specify what to push with &lt;code&gt;&amp;lt;refspec&amp;gt;...&lt;/code&gt; arguments or &lt;code&gt;--all&lt;/code&gt;, &lt;code&gt;--mirror&lt;/code&gt;, &lt;code&gt;--tags&lt;/code&gt; options, the command finds the default &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; by consulting &lt;code&gt;remote.*.push&lt;/code&gt; configuration, and if it is not found, honors &lt;code&gt;push.default&lt;/code&gt; configuration to decide what to push (See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for the meaning of &lt;code&gt;push.default&lt;/code&gt;).</source>
          <target state="translated">コマンドラインがでプッシュするかを指定しない場合 &lt;code&gt;&amp;lt;refspec&amp;gt;...&lt;/code&gt; 引数または &lt;code&gt;--all&lt;/code&gt; 、 &lt;code&gt;--mirror&lt;/code&gt; 、 &lt;code&gt;--tags&lt;/code&gt; オプション、コマンドはデフォルト見つかっ &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; コンサルティングにより、 &lt;code&gt;remote.*.push&lt;/code&gt; 構成、見つからない場合は、 &lt;code&gt;push.default&lt;/code&gt; 構成を尊重して、何をプッシュするかを決定します（ &lt;code&gt;push.default&lt;/code&gt; の意味については、&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;を参照してください）。</target>
        </trans-unit>
        <trans-unit id="4f61ade639e58b8586884fe92cb9eea816606ac2" translate="yes" xml:space="preserve">
          <source>When the command line does not specify where to push with the &lt;code&gt;&amp;lt;repository&amp;gt;&lt;/code&gt; argument, &lt;code&gt;branch.*.remote&lt;/code&gt; configuration for the current branch is consulted to determine where to push. If the configuration is missing, it defaults to &lt;code&gt;origin&lt;/code&gt;.</source>
          <target state="translated">コマンドラインで &lt;code&gt;&amp;lt;repository&amp;gt;&lt;/code&gt; 引数を使用してどこにプッシュするかを指定しない場合、現在のブランチの &lt;code&gt;branch.*.remote&lt;/code&gt; 構成が参照され、どこにプッシュするかが決定されます。設定がない場合、デフォルトで &lt;code&gt;origin&lt;/code&gt; に設定されます。</target>
        </trans-unit>
        <trans-unit id="4dd963bd8e58b7ff2b11f8f622df35ecbcf28d58" translate="yes" xml:space="preserve">
          <source>When the commit diffs differ, &lt;code&gt;git range-diff&lt;/code&gt; recreates the original diffs' coloring, and adds outer -/+ diff markers with the &lt;strong&gt;background&lt;/strong&gt; being red/green to make it easier to see e.g. when there was a change in what exact lines were added.</source>
          <target state="translated">commit差分が異なる場合、 &lt;code&gt;git range-diff&lt;/code&gt; は元のdiffの色を再作成し、外側の-/ +差分マーカーを追加して&lt;strong&gt;背景&lt;/strong&gt;を赤/緑にして、たとえば正確な行が追加されたときに変更があったときに見やすくします。</target>
        </trans-unit>
        <trans-unit id="3625aba84b870871330cdfd48d8779c4e4badb58" translate="yes" xml:space="preserve">
          <source>When the commit log message begins with &quot;squash! &amp;hellip;​&quot; (or &quot;fixup! &amp;hellip;​&quot;), and there is already a commit in the todo list that matches the same &lt;code&gt;...&lt;/code&gt;, automatically modify the todo list of rebase -i so that the commit marked for squashing comes right after the commit to be modified, and change the action of the moved commit from &lt;code&gt;pick&lt;/code&gt; to &lt;code&gt;squash&lt;/code&gt; (or &lt;code&gt;fixup&lt;/code&gt;). A commit matches the &lt;code&gt;...&lt;/code&gt; if the commit subject matches, or if the &lt;code&gt;...&lt;/code&gt; refers to the commit&amp;rsquo;s hash. As a fall-back, partial matches of the commit subject work, too. The recommended way to create fixup/squash commits is by using the &lt;code&gt;--fixup&lt;/code&gt;/&lt;code&gt;--squash&lt;/code&gt; options of &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt;.</source>
          <target state="translated">ログをコミットするとメッセージがで始まる「スカッシュ！...」（または「フィックスアップは！...」）、および同じ一致したToDoリストにコミットすでにある &lt;code&gt;...&lt;/code&gt; 自動のToDoリストを変更し、リベース-i &lt;code&gt;squash&lt;/code&gt; 対象としてマークされたコミットが変更されるコミットの直後に来るようにし、移動されたコミットのアクションを &lt;code&gt;pick&lt;/code&gt; からスカッシュ（または &lt;code&gt;fixup&lt;/code&gt; ）に変更します。コミットサブジェクトが一致する場合、または &lt;code&gt;...&lt;/code&gt; がコミットのハッシュを参照する場合、コミットは &lt;code&gt;...&lt;/code&gt; に一致します。フォールバックとして、コミットサブジェクトの部分一致も機能します。fixup / squashコミットを作成するための推奨される方法は、&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]の&lt;/a&gt; &lt;code&gt;--fixup&lt;/code&gt; / &lt;code&gt;--squash&lt;/code&gt; オプションを使用することです。。</target>
        </trans-unit>
        <trans-unit id="777196d17b1a10c66d0cd105e5fb66da2363f7b1" translate="yes" xml:space="preserve">
          <source>When the config key &lt;code&gt;extensions.partialclone&lt;/code&gt; is set, it indicates that the repo was created with a partial clone (or later performed a partial fetch) and that the remote may have omitted sending certain unwanted objects. Such a remote is called a &quot;promisor remote&quot; and it promises that all such omitted objects can be fetched from it in the future.</source>
          <target state="translated">構成キー &lt;code&gt;extensions.partialclone&lt;/code&gt; が設定されている場合、これは、リポジトリが部分的なクローンで作成された（または後で部分的なフェッチを実行した）こと、およびリモートが特定の不要なオブジェクトの送信を省略した可能性があることを示します。そのようなリモートは「promisorリモート」と呼ばれ、そのような省略されたすべてのオブジェクトを将来的にそこからフェッチできることを約束します。</target>
        </trans-unit>
        <trans-unit id="ef73607bec133cc1d32aaf64deafc8c72104731d" translate="yes" xml:space="preserve">
          <source>When the config key &lt;code&gt;extensions.preciousObjects&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, objects in the repository MUST NOT be deleted (e.g., by &lt;code&gt;git-prune&lt;/code&gt; or &lt;code&gt;git repack -d&lt;/code&gt;).</source>
          <target state="translated">設定キー &lt;code&gt;extensions.preciousObjects&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; に設定されている場合、リポジトリ内のオブジェクトを削除してはなりません（例えば、 &lt;code&gt;git-prune&lt;/code&gt; または &lt;code&gt;git repack -d&lt;/code&gt; によって）。</target>
        </trans-unit>
        <trans-unit id="e23e26ad367e6b915821bbb7b38753fa6fd4c240" translate="yes" xml:space="preserve">
          <source>When the current working directory is below the repository directory print &quot;true&quot;, otherwise &quot;false&quot;.</source>
          <target state="translated">現在の作業ディレクトリがリポジトリの下にある場合は &quot;true &quot;を、そうでない場合は &quot;false &quot;を表示します。</target>
        </trans-unit>
        <trans-unit id="8a7aa53d7bbe6bfa657a2a1bb84359882384d7fa" translate="yes" xml:space="preserve">
          <source>When the current working directory is inside the work tree of the repository print &quot;true&quot;, otherwise &quot;false&quot;.</source>
          <target state="translated">現在の作業ディレクトリがリポジトリの作業ツリー内にある場合は &quot;true &quot;を、そうでない場合は &quot;false &quot;を表示します。</target>
        </trans-unit>
        <trans-unit id="e614fb1c074d0b3ebd865c7756d786dc01074ea4" translate="yes" xml:space="preserve">
          <source>When the environment variable &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; is set, the program named by it is called to generate diffs, and Git does not use its builtin diff machinery. For a path that is added, removed, or modified, &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; is called with 7 parameters:</source>
          <target state="translated">環境変数 &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; が設定されている場合、それによって指定されたプログラムが呼び出されてdiffが生成され、Gitは組み込みのdiff機構を使用しません。追加、削除、または変更されたパスの場合、 &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; が7つのパラメーターで呼び出されます。</target>
        </trans-unit>
        <trans-unit id="dd7dc6a4dcd86a8d725c2332772df83ad820f427" translate="yes" xml:space="preserve">
          <source>When the environment variable &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; is set, the program named by it is called, instead of the diff invocation described above. For a path that is added, removed, or modified, &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; is called with 7 parameters:</source>
          <target state="translated">環境変数 &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; が設定されると、上記のdiff呼び出しの代わりに、それによって指定されたプログラムが呼び出されます。追加、削除、または変更されたパスの場合、 &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; が7つのパラメーターで呼び出されます。</target>
        </trans-unit>
        <trans-unit id="ec4de571b6827b1e0107c62834d6f8cf9f50bba2" translate="yes" xml:space="preserve">
          <source>When the git-rebase command is run, it will first execute a &quot;pre-rebase&quot; hook if one exists. You can use this hook to do sanity checks and reject the rebase if it isn&amp;rsquo;t appropriate. Please see the template pre-rebase hook script for an example.</source>
          <target state="translated">git-rebaseコマンドを実行すると、「pre-rebase」フックが存在する場合、最初にそれが実行されます。このフックを使用して健全性チェックを行い、適切でない場合はリベースを拒否できます。例については、テンプレートのリベース前フックスクリプトを参照してください。</target>
        </trans-unit>
        <trans-unit id="4663df00f4cd516023be3e887d8ecce789e72f00" translate="yes" xml:space="preserve">
          <source>When the history involves criss-cross merges, there can be more than one &lt;code&gt;best&lt;/code&gt; common ancestor for two commits. For example, with this topology:</source>
          <target state="translated">歴史が十字型のマージを含む場合、2つのコミットに対して複数の &lt;code&gt;best&lt;/code&gt; 一般的な祖先が存在する可能性があります。たとえば、次のトポロジでは：</target>
        </trans-unit>
        <trans-unit id="58beafa5cea14c3b99014fb314d938b1ee9fac65" translate="yes" xml:space="preserve">
          <source>When the man viewer, specified by the &lt;code&gt;man.viewer&lt;/code&gt; configuration variables, is not among the supported ones, then the corresponding &lt;code&gt;man.&amp;lt;tool&amp;gt;.cmd&lt;/code&gt; configuration variable will be looked up. If this variable exists then the specified tool will be treated as a custom command and a shell eval will be used to run the command with the man page passed as arguments.</source>
          <target state="translated">&lt;code&gt;man.viewer&lt;/code&gt; 構成変数で指定されたmanビューアがサポートされているものの中にない場合、対応する &lt;code&gt;man.&amp;lt;tool&amp;gt;.cmd&lt;/code&gt; 構成変数が検索されます。この変数が存在する場合、指定されたツールはカスタムコマンドとして扱われ、シェルevalが引数として渡されたmanページでコマンドを実行するために使用されます。</target>
        </trans-unit>
        <trans-unit id="d01c091e9d01b5baf9f294a1d7b9c823d7d014bc" translate="yes" xml:space="preserve">
          <source>When the output goes to a terminal, it is color-coded by default, just like regular &lt;code&gt;git diff&lt;/code&gt;'s output. In addition, the first line (adding a commit) is green, the last line (deleting a commit) is red, the second line (with a perfect match) is yellow like the commit header of &lt;code&gt;git
show&lt;/code&gt;'s output, and the third line colors the old commit red, the new one green and the rest like &lt;code&gt;git show&lt;/code&gt;'s commit header.</source>
          <target state="translated">出力が端末に送られると、通常の &lt;code&gt;git diff&lt;/code&gt; の出力と同じように、デフォルトで色分けされます。さらに、最初の行（コミットの追加）は緑、最後の行（コミットの削除）は赤、2行目（完全一致）は &lt;code&gt;git show&lt;/code&gt; の出力のコミットヘッダーのように黄色、3行目は黄色です。線は古いコミットを赤で、新しいコミットを緑で、残りは &lt;code&gt;git show&lt;/code&gt; のコミットヘッダーの色です。</target>
        </trans-unit>
        <trans-unit id="ecf68ce55bda2542529810833e005e7f157f71c2" translate="yes" xml:space="preserve">
          <source>When the patch does not apply cleanly, fall back on 3-way merge if the patch records the identity of blobs it is supposed to apply to and we have those blobs available locally. &lt;code&gt;--no-3way&lt;/code&gt; can be used to override am.threeWay configuration variable. For more information, see am.threeWay in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">パッチがクリーンに適用されない場合、パッチが適用するはずのblobのIDをパッチが記録し、ローカルでそれらのblobを使用できる場合は、3ウェイマージにフォールバックします。 &lt;code&gt;--no-3way&lt;/code&gt; を使用して、am.threeWay構成変数をオーバーライドできます。詳細については、&lt;a href=&quot;git-config&quot;&gt;git-config [1]の&lt;/a&gt; am.threeWayを参照してください。</target>
        </trans-unit>
        <trans-unit id="28728fcf386b485f532ec99285643062f0405ba5" translate="yes" xml:space="preserve">
          <source>When the patch does not apply cleanly, fall back on 3-way merge if the patch records the identity of blobs it is supposed to apply to, and we have those blobs available locally, possibly leaving the conflict markers in the files in the working tree for the user to resolve. This option implies the &lt;code&gt;--index&lt;/code&gt; option, and is incompatible with the &lt;code&gt;--reject&lt;/code&gt; and the &lt;code&gt;--cached&lt;/code&gt; options.</source>
          <target state="translated">パッチがきれいに適用されない場合、パッチが適用されるはずのblobのIDを記録し、それらのblobがローカルで利用可能であれば、3ウェイマージにフォールバックし、作業ツリー内のファイルに競合マーカーを残す可能性があります。ユーザーが解決するため。このオプションは &lt;code&gt;--index&lt;/code&gt; オプションを意味し、 &lt;code&gt;--reject&lt;/code&gt; および &lt;code&gt;--cached&lt;/code&gt; オプションと互換性がありません。</target>
        </trans-unit>
        <trans-unit id="bdd1b4760c591dff915e966378bff929405d28b1" translate="yes" xml:space="preserve">
          <source>When the push is complete, outputs one or more &lt;code&gt;ok &amp;lt;dst&amp;gt;&lt;/code&gt; or &lt;code&gt;error &amp;lt;dst&amp;gt; &amp;lt;why&amp;gt;?&lt;/code&gt; lines to indicate success or failure of each pushed ref. The status report output is terminated by a blank line. The option field &amp;lt;why&amp;gt; may be quoted in a C style string if it contains an LF.</source>
          <target state="translated">プッシュが完了すると、1つ以上の &lt;code&gt;ok &amp;lt;dst&amp;gt;&lt;/code&gt; または &lt;code&gt;error &amp;lt;dst&amp;gt; &amp;lt;why&amp;gt;?&lt;/code&gt; プッシュされた各参照の成功または失敗を示す線。ステータスレポートの出力は空白行で終了します。オプションフィールド&amp;lt;why&amp;gt;にLFが含まれている場合は、Cスタイルの文字列で引用符で囲むことができます。</target>
        </trans-unit>
        <trans-unit id="c36826b0bb47b2400e28127fc2b6b138c228a63f" translate="yes" xml:space="preserve">
          <source>When the remote branch you want to fetch is known to be rewound and rebased regularly, it is expected that its new tip will not be descendant of its previous tip (as stored in your remote-tracking branch the last time you fetched). You would want to use the &lt;code&gt;+&lt;/code&gt; sign to indicate non-fast-forward updates will be needed for such branches. There is no way to determine or declare that a branch will be made available in a repository with this behavior; the pulling user simply must know this is the expected usage pattern for a branch.</source>
          <target state="translated">フェッチするリモートブランチが定期的に巻き戻されてリベースされることがわかっている場合、その新しいチップは以前のチップの子孫にならないことが予想されます（最後にフェッチしたときにリモート追跡ブランチに格納されているため）。 &lt;code&gt;+&lt;/code&gt; 記号を使用して、そのようなブランチで非早送りの更新が必要になることを示します。この動作でブランチがリポジトリで利用可能になることを決定または宣言する方法はありません。プルするユーザーは、これがブランチの予想される使用パターンであることを知っている必要があります。</target>
        </trans-unit>
        <trans-unit id="c2d02d0fdbdd6b68f91184ab0fd8a5fcfd84e982" translate="yes" xml:space="preserve">
          <source>When the repository is bare print &quot;true&quot;, otherwise &quot;false&quot;.</source>
          <target state="translated">リポジトリがベアの場合は &quot;true &quot;を、そうでない場合は &quot;false &quot;を表示します。</target>
        </trans-unit>
        <trans-unit id="4881892c9231f2a8cbf0d32abf5995af521026ca" translate="yes" xml:space="preserve">
          <source>When the repository is shallow print &quot;true&quot;, otherwise &quot;false&quot;.</source>
          <target state="translated">リポジトリが浅い場合は &quot;true &quot;を、そうでない場合は &quot;false &quot;を表示します。</target>
        </trans-unit>
        <trans-unit id="37826a890a4b64bdd1230276a23bd80630675ca5" translate="yes" xml:space="preserve">
          <source>When the repository named by &lt;code&gt;&amp;lt;url&amp;gt;&lt;/code&gt; has the commit at a tip of a ref that is different from the ref you have locally, you can use the &lt;code&gt;&amp;lt;local&amp;gt;:&amp;lt;remote&amp;gt;&lt;/code&gt; syntax, to have its local name, a colon &lt;code&gt;:&lt;/code&gt;, and its remote name.</source>
          <target state="translated">&lt;code&gt;&amp;lt;url&amp;gt;&lt;/code&gt; で指定されたリポジトリのコミットが、ローカルにある参照とは異なる参照の先端にある場合、 &lt;code&gt;&amp;lt;local&amp;gt;:&amp;lt;remote&amp;gt;&lt;/code&gt; 構文を使用して、ローカル名、コロン &lt;code&gt;:&lt;/code&gt; 、とそのリモート名。</target>
        </trans-unit>
        <trans-unit id="a7fe7f8247bda757ca8d697055bcfe0913ae2caf" translate="yes" xml:space="preserve">
          <source>When the repository to clone from is on a local machine, this flag bypasses the normal &quot;Git aware&quot; transport mechanism and clones the repository by making a copy of HEAD and everything under objects and refs directories. The files under &lt;code&gt;.git/objects/&lt;/code&gt; directory are hardlinked to save space when possible.</source>
          <target state="translated">クローン元のリポジトリがローカルマシン上にある場合、このフラグは通常の「Git対応」トランスポートメカニズムをバイパスし、オブジェクトとrefsディレクトリの下にHEADとすべてのコピーを作成してリポジトリをクローンします。 &lt;code&gt;.git/objects/&lt;/code&gt; ディレクトリの下のファイルは、可能な場合はスペースを節約するためにハードリンクされています。</target>
        </trans-unit>
        <trans-unit id="87edb2bef2f28c0f63de7720d331d50db0279e94" translate="yes" xml:space="preserve">
          <source>When the repository to clone is on the local machine, instead of using hard links, automatically setup &lt;code&gt;.git/objects/info/alternates&lt;/code&gt; to share the objects with the source repository. The resulting repository starts out without any object of its own.</source>
          <target state="translated">クローンを作成するリポジトリがローカルマシン上にある場合、ハードリンクを使用する代わりに、 &lt;code&gt;.git/objects/info/alternates&lt;/code&gt; を自動的にセットアップして、オブジェクトをソースリポジトリと共有します。結果のリポジトリは、独自のオブジェクトなしで開始されます。</target>
        </trans-unit>
        <trans-unit id="e18b845f941d21aaf5232c387f67cb23d0a4e759" translate="yes" xml:space="preserve">
          <source>When the result of a &lt;code&gt;git bisect&lt;/code&gt; is a non-merge commit, you should normally be able to discover the problem by examining just that commit. Developers can make this easy by breaking their changes into small self-contained commits. That won&amp;rsquo;t help in the case above, however, because the problem isn&amp;rsquo;t obvious from examination of any single commit; instead, a global view of the development is required. To make matters worse, the change in semantics in the problematic function may be just one small part of the changes in the upper line of development.</source>
          <target state="translated">&lt;code&gt;git bisect&lt;/code&gt; の結果が非マージコミットである場合、通常はそのコミットのみを調べることで問題を発見できるはずです。開発者は、変更を小さな自己完結型のコミットに分割することで、これを容易にすることができます。ただし、上記の場合は問題ありません。問題は単一のコミットを調べても明らかではないためです。代わりに、開発のグローバルな視点が必要です。さらに悪いことに、問題のある関数のセマンティクスの変更は、開発の上位ラインの変更のほんの一部にすぎない場合があります。</target>
        </trans-unit>
        <trans-unit id="57dfd8622d0e5d97d5c5344dbdac2c35010a468d" translate="yes" xml:space="preserve">
          <source>When the split index feature is used, shared index files that were not modified since the time this variable specifies will be removed when a new shared index file is created. The value &quot;now&quot; expires all entries immediately, and &quot;never&quot; suppresses expiration altogether. The default value is &quot;2.weeks.ago&quot;. Note that a shared index file is considered modified (for the purpose of expiration) each time a new split-index file is either created based on it or read from it. See &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt;.</source>
          <target state="translated">分割インデックス機能を使用すると、この変数が指定する時刻以降に変更されなかった共有インデックスファイルは、新しい共有インデックスファイルが作成されるときに削除されます。値「now」はすべてのエントリーを即時に期限切れにし、「never」は期限切れを完全に抑制します。デフォルト値は「2.weeks.ago」です。共有インデックスファイルは、それに基づいて新しい分割インデックスファイルが作成されるか、またはそこから読み取られるたびに、変更された（期限切れの目的で）と見なされることに注意してください。&lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="887ef75c2523fd6b4da84b3a0a714f4995305746" translate="yes" xml:space="preserve">
          <source>When the split index feature is used, this specifies the percent of entries the split index can contain compared to the total number of entries in both the split index and the shared index before a new shared index is written. The value should be between 0 and 100. If the value is 0 then a new shared index is always written, if it is 100 a new shared index is never written. By default the value is 20, so a new shared index is written if the number of entries in the split index would be greater than 20 percent of the total number of entries. See &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt;.</source>
          <target state="translated">分割インデックス機能を使用する場合、これは、新しい共有インデックスが書き込まれる前の分割インデックスと共有インデックスの両方のエントリの総数と比較した、分割インデックスに含めることができるエントリの割合を指定します。値は0から100の間でなければなりません。値が0の場合、新しい共有インデックスが常に書き込まれます。100の場合、新しい共有インデックスは決して書き込まれません。デフォルトの値は20です。そのため、分割インデックスのエントリ数がエントリの総数の20％を超える場合、新しい共有インデックスが書き込まれます。&lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="1631afdb92ffecd0a40ddcd8f40433691ff79d82" translate="yes" xml:space="preserve">
          <source>When the value is &lt;code&gt;interactive&lt;/code&gt; (or just &lt;code&gt;i&lt;/code&gt;), the rebase is run in interactive mode.</source>
          <target state="translated">値が &lt;code&gt;interactive&lt;/code&gt; （または単に &lt;code&gt;i&lt;/code&gt; ）の場合、リベースはインタラクティブモードで実行されます。</target>
        </trans-unit>
        <trans-unit id="249674ff1351f5c865508a34f368a209ce692426" translate="yes" xml:space="preserve">
          <source>When the value is &lt;code&gt;interactive&lt;/code&gt;, the rebase is run in interactive mode.</source>
          <target state="translated">値が &lt;code&gt;interactive&lt;/code&gt; の場合、リベースはインタラクティブモードで実行されます。</target>
        </trans-unit>
        <trans-unit id="2a8620af5de619d02cbdb1290090cf457f4270c6" translate="yes" xml:space="preserve">
          <source>When the working tree is updated, using --recurse-submodules will also recursively reset the working tree of all active submodules according to the commit recorded in the superproject, also setting the submodules' HEAD to be detached at that commit.</source>
          <target state="translated">作業ツリーが更新されると、--recurse-submodulesを使うと、スーパープロジェクトに記録されたコミットに応じて、すべてのアクティブなサブモジュールの作業ツリーが再帰的にリセットされ、そのコミットでサブモジュールのHEADが切り離されるように設定されます。</target>
        </trans-unit>
        <trans-unit id="bbc30d1504ae5818b5ebed3f68f464e3d8d41b06" translate="yes" xml:space="preserve">
          <source>When there are approximately more than this many loose objects in the repository, &lt;code&gt;git gc --auto&lt;/code&gt; will pack them. Some Porcelain commands use this command to perform a light-weight garbage collection from time to time. The default value is 6700.</source>
          <target state="translated">リポジトリにこれより多くの緩いオブジェクトがほぼ存在する場合、 &lt;code&gt;git gc --auto&lt;/code&gt; はそれらをパックします。一部の磁器コマンドは、このコマンドを使用して、軽量のガベージコレクションを時々実行します。デフォルト値は6700です。</target>
        </trans-unit>
        <trans-unit id="c316674f184677333eb7d2b00fe1f02bf0eda4b8" translate="yes" xml:space="preserve">
          <source>When there are content conflicts, the merge machinery tries to annotate each side&amp;rsquo;s conflict markers with the commits where the content came from. Since the apply backend drops the original information about the rebased commits and their parents (and instead generates new fake commits based off limited information in the generated patches), those commits cannot be identified; instead it has to fall back to a commit summary. Also, when merge.conflictStyle is set to diff3, the apply backend will use &quot;constructed merge base&quot; to label the content from the merge base, and thus provide no information about the merge base commit whatsoever.</source>
          <target state="translated">コンテンツの競合がある場合、マージ機構は、コンテンツの送信元のコミットで各側の競合マーカーに注釈を付けようとします。適用バックエンドは、リベースされたコミットとその親に関する元の情報を削除するため（代わりに、生成されたパッチの限られた情報に基づいて新しい偽のコミットを生成します）、それらのコミットを識別できません。代わりに、コミットの要約にフォールバックする必要があります。また、merge.conflictStyleがdiff3に設定されている場合、適用バックエンドは「構築されたマージベース」を使用してマージベースのコンテンツにラベルを付けるため、マージベースのコミットに関する情報はまったく提供されません。</target>
        </trans-unit>
        <trans-unit id="62fefa7cb364ff9a836bef0837ac15925fecc8f2" translate="yes" xml:space="preserve">
          <source>When there are more than this many packs that are not marked with &lt;code&gt;*.keep&lt;/code&gt; file in the repository, &lt;code&gt;git gc
--auto&lt;/code&gt; consolidates them into one larger pack. The default value is 50. Setting this to 0 disables it. Setting &lt;code&gt;gc.auto&lt;/code&gt; to 0 will also disable this.</source>
          <target state="translated">リポジトリに &lt;code&gt;*.keep&lt;/code&gt; ファイルでマークされていないパックがこれより多くある場合、 &lt;code&gt;git gc --auto&lt;/code&gt; はそれらを1つの大きなパックに統合します。デフォルト値は50です。これを0に設定すると、無効になります。 &lt;code&gt;gc.auto&lt;/code&gt; を0に設定すると、これも無効になります。</target>
        </trans-unit>
        <trans-unit id="a99bf9777c550eb2f6602e82876314f8cadcb15d" translate="yes" xml:space="preserve">
          <source>When there is only one argument given and it is not &lt;code&gt;--&lt;/code&gt; (e.g. &lt;code&gt;git
checkout abc&lt;/code&gt;), and when the argument is both a valid &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; (e.g. a branch &lt;code&gt;abc&lt;/code&gt; exists) and a valid &lt;code&gt;&amp;lt;pathspec&amp;gt;&lt;/code&gt; (e.g. a file or a directory whose name is &quot;abc&quot; exists), Git would usually ask you to disambiguate. Because checking out a branch is so common an operation, however, &lt;code&gt;git checkout abc&lt;/code&gt; takes &quot;abc&quot; as a &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; in such a situation. Use &lt;code&gt;git checkout -- &amp;lt;pathspec&amp;gt;&lt;/code&gt; if you want to checkout these paths out of the index.</source>
          <target state="translated">与えられた引数が1つだけでなく &lt;code&gt;--&lt;/code&gt; （たとえば &lt;code&gt;git checkout abc&lt;/code&gt; ）であり、引数が有効な &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; （たとえば、ブランチ &lt;code&gt;abc&lt;/code&gt; が存在する）と有効な &lt;code&gt;&amp;lt;pathspec&amp;gt;&lt;/code&gt; （たとえば、ファイル）の場合または「abc」という名前のディレクトリが存在する場合）、Gitは通常、曖昧さをなくすように要求します。ただし、ブランチのチェックアウトは非常に一般的な操作であるため、このような状況では &lt;code&gt;git checkout abc&lt;/code&gt; は「abc」を &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; として扱います。これらのパスをインデックスからチェックアウトする場合は、 &lt;code&gt;git checkout -- &amp;lt;pathspec&amp;gt;&lt;/code&gt; 使用します。</target>
        </trans-unit>
        <trans-unit id="3ff1d02c565a22d417998ec283b077273b716d4a" translate="yes" xml:space="preserve">
          <source>When these environment variables are set, the corresponding command-line arguments may not be used.</source>
          <target state="translated">これらの環境変数が設定されている場合、対応するコマンドライン引数は使用できません。</target>
        </trans-unit>
        <trans-unit id="86c4d2dcd046b538b0d9c792061f20bffd3f8c8e" translate="yes" xml:space="preserve">
          <source>When this flag is provided, the pack is read from stdin instead and a copy is then written to &amp;lt;pack-file&amp;gt;. If &amp;lt;pack-file&amp;gt; is not specified, the pack is written to objects/pack/ directory of the current Git repository with a default name determined from the pack content. If &amp;lt;pack-file&amp;gt; is not specified consider using --keep to prevent a race condition between this process and &lt;code&gt;git repack&lt;/code&gt;.</source>
          <target state="translated">このフラグを指定すると、代わりにパックがstdinから読み取られ、コピーが&amp;lt;pack-file&amp;gt;に書き込まれます。 &amp;lt;pack-file&amp;gt;が指定されていない場合、パックは、現在のGitリポジトリーのobjects / pack /ディレクトリーに書き込まれ、デフォルトの名前はパックの内容から決定されます。 &amp;lt;pack-file&amp;gt;が指定されていない場合は、このプロセスと &lt;code&gt;git repack&lt;/code&gt; repackの間の競合状態を防ぐために--keepの使用を検討してください。</target>
        </trans-unit>
        <trans-unit id="c91915e7d5f6096e68c1652d49f4ac505147354d" translate="yes" xml:space="preserve">
          <source>When this flag is specified, the object names recorded for the paths are not updated. Instead, this option sets/unsets the &quot;assume unchanged&quot; bit for the paths. When the &quot;assume unchanged&quot; bit is on, the user promises not to change the file and allows Git to assume that the working tree file matches what is recorded in the index. If you want to change the working tree file, you need to unset the bit to tell Git. This is sometimes helpful when working with a big project on a filesystem that has very slow lstat(2) system call (e.g. cifs).</source>
          <target state="translated">このフラグが指定された場合、パスに記録されているオブジェクト名は更新されません。その代わりに、このオプションはパスの &quot;asculus unchanged&quot; ビットを設定したり解除したりします。assume unchanged&quot; ビットがオンの場合、ユーザーはファイルを変更しないことを約束し、Git は作業木ファイルがインデックスに記録されているものと一致しているとみなすようにします。作業木ファイルを変更したい場合は、このビットを解除して Git に伝える必要があります。これは、lstat(2)のシステムコールが非常に遅いファイルシステム上で大きなプロジェクトを扱うときに役立つことがあります (例:cifs)。</target>
        </trans-unit>
        <trans-unit id="b1f75c6b9b1b22670befceda22525699cad697f2" translate="yes" xml:space="preserve">
          <source>When this form of &lt;code&gt;git read-tree&lt;/code&gt; returns successfully, you can see which of the &quot;local changes&quot; that you made were carried forward by running &lt;code&gt;git diff-index --cached $M&lt;/code&gt;. Note that this does not necessarily match what &lt;code&gt;git diff-index --cached $H&lt;/code&gt; would have produced before such a two tree merge. This is because of cases 18 and 19 --- if you already had the changes in $M (e.g. maybe you picked it up via e-mail in a patch form), &lt;code&gt;git diff-index
--cached $H&lt;/code&gt; would have told you about the change before this merge, but it would not show in &lt;code&gt;git diff-index --cached $M&lt;/code&gt; output after the two-tree merge.</source>
          <target state="translated">この形式の &lt;code&gt;git read-tree&lt;/code&gt; が正常に戻ると、 &lt;code&gt;git diff-index --cached $M&lt;/code&gt; ことにより、実行された「ローカル変更」のどれが繰り越されたかを確認できます。これは、そのような2つのツリーのマージ前に &lt;code&gt;git diff-index --cached $H&lt;/code&gt; が生成したものと必ずしも一致しないことに注意してください。これは、ケース18と19が原因です--- $ Mにすでに変更がある場合（たとえば、パッチフォームで電子メールを介して受け取った場合など）、 &lt;code&gt;git diff-index --cached $H&lt;/code&gt; が通知します。このマージの前の変更についてですが、2つのツリーのマージ後の &lt;code&gt;git diff-index --cached $M&lt;/code&gt; 出力には表示されません。</target>
        </trans-unit>
        <trans-unit id="a7b5d3881356f9c9c7fd25660fd80f9c16873a97" translate="yes" xml:space="preserve">
          <source>When this option is specified, the behavior is as if a special &lt;code&gt;&amp;lt;token&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; argument were added at the beginning of the command line, where &amp;lt;value&amp;gt; is taken to be the standard output of the specified command with any leading and trailing whitespace trimmed off.</source>
          <target state="translated">このオプションを指定すると、コマンドラインの先頭に特別な &lt;code&gt;&amp;lt;token&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; 引数が追加されたかのように動作します。末尾の空白は削除されました。</target>
        </trans-unit>
        <trans-unit id="fe0e96d95c4eefa9bfe72917d015cf48a18efcc2" translate="yes" xml:space="preserve">
          <source>When this special attribute is read by &lt;code&gt;git credential&lt;/code&gt;, the value is parsed as a URL and treated as if its constituent parts were read (e.g., &lt;code&gt;url=https://example.com&lt;/code&gt; would behave as if &lt;code&gt;protocol=https&lt;/code&gt; and &lt;code&gt;host=example.com&lt;/code&gt; had been provided). This can help callers avoid parsing URLs themselves.</source>
          <target state="translated">この特別な属性がで読み込まれると &lt;code&gt;git credential&lt;/code&gt; その構成部品が読み込まれたかのように、値がURLとして解析され、扱われている（例えば、 &lt;code&gt;url=https://example.com&lt;/code&gt; かのように振る舞う &lt;code&gt;protocol=https&lt;/code&gt; および &lt;code&gt;host=example.com&lt;/code&gt; が提供されていました）。これは、呼び出し元がURL自体を解析することを回避するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="de58814133990da5a575ac12a35ef9b3b981ae4a" translate="yes" xml:space="preserve">
          <source>When this special attribute is read by &lt;code&gt;git credential&lt;/code&gt;, the value is parsed as a URL and treated as if its constituent parts were read (e.g., &lt;code&gt;url=https://example.com&lt;/code&gt; would behave as if &lt;code&gt;protocol=https&lt;/code&gt; and &lt;code&gt;host=example.com&lt;/code&gt; had been provided). This can help callers avoid parsing URLs themselves. Note that any components which are missing from the URL (e.g., there is no username in the example above) will be set to empty; if you want to provide a URL and override some attributes, provide the URL attribute first, followed by any overrides.</source>
          <target state="translated">この特別な属性が &lt;code&gt;git credential&lt;/code&gt; によって読み取られると、値はURLとして解析され、構成要素が読み取られたかのように処理されます（たとえば、 &lt;code&gt;url=https://example.com&lt;/code&gt; は &lt;code&gt;protocol=https&lt;/code&gt; および &lt;code&gt;host=example.com&lt;/code&gt; ように動作します。 comが提供されていました）。これは、呼び出し元がURL自体を解析しないようにするのに役立ちます。 URLから欠落しているコンポーネント（上記の例ではユーザー名がないなど）は空に設定されることに注意してください。 URLを指定して一部の属性をオーバーライドする場合は、最初にURL属性を指定してから、オーバーライドを指定します。</target>
        </trans-unit>
        <trans-unit id="882eafec7b82da90c1fd3ae7dc7040457d013cf9" translate="yes" xml:space="preserve">
          <source>When trace files are written to a target directory, they will be named according to the last component of the SID (optionally followed by a counter to avoid filename collisions).</source>
          <target state="translated">トレースファイルがターゲットディレクトリに書き込まれると、SID の最後のコンポーネントに応じて名前が付けられます(ファイル名の衝突を避けるために、オプションでカウンターを後に付けます)。</target>
        </trans-unit>
        <trans-unit id="1771ffd8c74f9f0b2e623ff3c52581b28a17469b" translate="yes" xml:space="preserve">
          <source>When tracking multiple directories (using --stdlayout, --branches, or --tags options), git svn will attempt to connect to the root (or highest allowed level) of the Subversion repository. This default allows better tracking of history if entire projects are moved within a repository, but may cause issues on repositories where read access restrictions are in place. Passing &lt;code&gt;--no-minimize-url&lt;/code&gt; will allow git svn to accept URLs as-is without attempting to connect to a higher level directory. This option is off by default when only one URL/branch is tracked (it would do little good).</source>
          <target state="translated">複数のディレクトリを追跡するとき（--stdlayout、-branches、または--tagsオプションを使用）、git svnはSubversionリポジトリのルート（または許可されている最高レベル）への接続を試みます。このデフォルトでは、プロジェクト全体がリポジトリ内で移動された場合に履歴の追跡が改善されますが、読み取りアクセス制限が設定されているリポジトリで問題が発生する可能性があります。 &lt;code&gt;--no-minimize-url&lt;/code&gt; を渡すと、git svnが上位レベルのディレクトリに接続することなく、URLをそのまま受け入れることができます。このオプションは、追跡されるURL /ブランチが1つだけの場合、デフォルトではオフになっています（ほとんど役に立ちません）。</target>
        </trans-unit>
        <trans-unit id="442a6a05d34f849ad275ea5e7d6f50f5aafe59d9" translate="yes" xml:space="preserve">
          <source>When true, and when reachability bitmaps are enabled, pack-objects will try to send parts of the bitmapped packfile verbatim. This can reduce memory and CPU usage to serve fetches, but might result in sending a slightly larger pack. Defaults to true.</source>
          <target state="translated">true の場合、そしてリーチャビリティ・ビットマップが有効になっている場合、パックオブジェクトはビットマップされたパックファイルの一部をそのまま送信しようとします。これにより、フェッチを提供するためのメモリと CPU の使用量を減らすことができますが、結果として少し大きめのパックを送ることになるかもしれません。デフォルトは true です。</target>
        </trans-unit>
        <trans-unit id="fce35b3add797f616ba5b3be537b437a03e625f0" translate="yes" xml:space="preserve">
          <source>When true, git will default to using the &lt;code&gt;--sparse&lt;/code&gt; option in &lt;code&gt;git pack-objects&lt;/code&gt; when the &lt;code&gt;--revs&lt;/code&gt; option is present. This algorithm only walks trees that appear in paths that introduce new objects. This can have significant performance benefits when computing a pack to send a small change. However, it is possible that extra objects are added to the pack-file if the included commits contain certain types of direct renames. Default is &lt;code&gt;false&lt;/code&gt; unless &lt;code&gt;feature.experimental&lt;/code&gt; is enabled.</source>
          <target state="translated">trueの場合、 &lt;code&gt;--revs&lt;/code&gt; オプションが存在する場合、gitはデフォルトで &lt;code&gt;git pack-objects&lt;/code&gt; の &lt;code&gt;--sparse&lt;/code&gt; オプションを使用します。このアルゴリズムは、新しいオブジェクトを導入するパスに表示されるツリーのみをウォークします。これにより、小さな変更を送信するパックを計算するときに、パフォーマンスが大幅に向上します。ただし、含まれているコミットに特定のタイプの直接名前変更が含まれている場合、余分なオブジェクトがパックファイルに追加される可能性があります。 &lt;code&gt;feature.experimental&lt;/code&gt; が有効でない限り、デフォルトは &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="a46d4189a8b9229b7d91d54cdebfebe81ffd9ae6" translate="yes" xml:space="preserve">
          <source>When true, git will default to using the &lt;code&gt;--sparse&lt;/code&gt; option in &lt;code&gt;git pack-objects&lt;/code&gt; when the &lt;code&gt;--revs&lt;/code&gt; option is present. This algorithm only walks trees that appear in paths that introduce new objects. This can have significant performance benefits when computing a pack to send a small change. However, it is possible that extra objects are added to the pack-file if the included commits contain certain types of direct renames. Default is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">trueの場合、 &lt;code&gt;--revs&lt;/code&gt; オプションが存在する場合、gitはデフォルトで &lt;code&gt;--sparse&lt;/code&gt; &lt;code&gt;git pack-objects&lt;/code&gt; --sparseオプションを使用します。このアルゴリズムは、新しいオブジェクトを導入するパスに表示されるツリーのみをウォークします。これは、小さな変更を送信するパックを計算するときに、パフォーマンスに大きなメリットをもたらす可能性があります。ただし、含まれているコミットに特定のタイプの直接名前変更が含まれている場合は、追加のオブジェクトがパックファイルに追加される可能性があります。デフォルトは &lt;code&gt;true&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="5d73311a3b4a00977d7e2237078b01efb9320bfa" translate="yes" xml:space="preserve">
          <source>When true, git will include a &quot;hash cache&quot; section in the bitmap index (if one is written). This cache can be used to feed git&amp;rsquo;s delta heuristics, potentially leading to better deltas between bitmapped and non-bitmapped objects (e.g., when serving a fetch between an older, bitmapped pack and objects that have been pushed since the last gc). The downside is that it consumes 4 bytes per object of disk space. Defaults to true.</source>
          <target state="translated">trueの場合、gitはビットマップインデックスに「ハッシュキャッシュ」セクションを含めます（書き込まれる場合）。このキャッシュを使用してgitのデルタヒューリスティックをフィードし、ビットマップオブジェクトと非ビットマップオブジェクトの間のデルタを改善できる可能性があります（たとえば、古いビットマップパックと最後のgc以降にプッシュされたオブジェクト間のフェッチを提供する場合）。欠点は、ディスク領域のオブジェクトごとに4バイトを消費することです。デフォルトはtrueです。</target>
        </trans-unit>
        <trans-unit id="98f36898b39f3ac14609adb644f7b367554be4b3" translate="yes" xml:space="preserve">
          <source>When true, git will use pack bitmaps (if available) when packing to stdout (e.g., during the server side of a fetch). Defaults to true. You should not generally need to turn this off unless you are debugging pack bitmaps.</source>
          <target state="translated">true を指定すると、stdout へのパッキング時 (たとえばサーバー側でのフェッチ時など)に git は (利用可能な場合は)pack bitmaps を使用します。デフォルトは true です。pack bitmaps をデバッグしている場合を除いて、一般的にはこの設定をオフにする必要はありません。</target>
        </trans-unit>
        <trans-unit id="3060361b8b64f7f4f15aa5d402b402d65fd1ef21" translate="yes" xml:space="preserve">
          <source>When true, git will write a bitmap index when packing all objects to disk (e.g., when &lt;code&gt;git repack -a&lt;/code&gt; is run). This index can speed up the &quot;counting objects&quot; phase of subsequent packs created for clones and fetches, at the cost of some disk space and extra time spent on the initial repack. This has no effect if multiple packfiles are created. Defaults to true on bare repos, false otherwise.</source>
          <target state="translated">trueの場合、すべてのオブジェクトをディスクにパックするとき（たとえば、 &lt;code&gt;git repack -a&lt;/code&gt; を実行するとき）、gitはビットマップインデックスを書き込みます。このインデックスを使用すると、クローンとフェッチ用に作成される後続のパックの「オブジェクトのカウント」フェーズを高速化できますが、一部のディスク領域と最初の再パックに費やされる余分な時間が犠牲になります。複数のパックファイルが作成される場合、これは効果がありません。デフォルトでは、ベアリポジトリではtrue、それ以外の場合はfalseです。</target>
        </trans-unit>
        <trans-unit id="b7b0c56b83a62c5cf7d9e0b77ba1430747588d7a" translate="yes" xml:space="preserve">
          <source>When true, rebase branches on top of the fetched branch, instead of merging the default branch from the default remote when &quot;git pull&quot; is run. See &quot;branch.&amp;lt;name&amp;gt;.rebase&quot; for setting this on a per-branch basis.</source>
          <target state="translated">trueの場合、「git pull」が実行されたときにデフォルトのリモートからデフォルトのブランチをマージするのではなく、フェッチされたブランチの上にブランチをリベースします。これをブランチごとに設定する方法については、「branch。&amp;lt;name&amp;gt; .rebase」を参照してください。</target>
        </trans-unit>
        <trans-unit id="c15c8ba9ac152f7e581087f6ca67eb8a95961a05" translate="yes" xml:space="preserve">
          <source>When true, rebase the branch &amp;lt;name&amp;gt; on top of the fetched branch, instead of merging the default branch from the default remote when &quot;git pull&quot; is run. See &quot;pull.rebase&quot; for doing this in a non branch-specific manner.</source>
          <target state="translated">trueの場合、「git pull」の実行時にデフォルトのリモートからデフォルトのブランチをマージするのではなく、フェッチされたブランチの上にブランチ&amp;lt;name&amp;gt;をリベースします。ブランチ固有ではない方法でこれを行うには、「pull.rebase」を参照してください。</target>
        </trans-unit>
        <trans-unit id="32f2ccfcaf97ac2d1b8fdcbcf4ee46e8d18499a7" translate="yes" xml:space="preserve">
          <source>When true, rebase the current branch on top of the upstream branch after fetching. If there is a remote-tracking branch corresponding to the upstream branch and the upstream branch was rebased since last fetched, the rebase uses that information to avoid rebasing non-local changes.</source>
          <target state="translated">true の場合、フェッチ後に現在のブランチを上流ブランチの上にリベースします。上流ブランチに対応するリモートトラッキングブランチがあり、最後にフェッチした後に上流ブランチがリベースされた場合、リベースはその情報を使用して、ローカル以外の変更をリベースしないようにします。</target>
        </trans-unit>
        <trans-unit id="e3872f2dbeef66b0c7927df02dbbfa3a35c8d12b" translate="yes" xml:space="preserve">
          <source>When two trees are given, it compares the first tree with the second. When a single commit is given, it compares the commit with its parents. The remaining commits, when given, are used as if they are parents of the first commit.</source>
          <target state="translated">2つの木が与えられた場合、最初の木と2番目の木を比較します。単一のコミットが与えられた場合、そのコミットとその親を比較します。残りのコミットが与えられた場合、最初のコミットの親であるかのように使用されます。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
