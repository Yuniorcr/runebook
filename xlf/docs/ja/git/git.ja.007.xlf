<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="git">
    <body>
      <group id="git">
        <trans-unit id="9f1df172d790d81927bf10eb32b7a53862fd94a5" translate="yes" xml:space="preserve">
          <source>Interrupted workflow</source>
          <target state="translated">ワークフローの中断</target>
        </trans-unit>
        <trans-unit id="b566252f7afe805214a7771e6b2a586b4e458c82" translate="yes" xml:space="preserve">
          <source>Introduction to &quot;git bisect&quot;</source>
          <target state="translated">git bisect」の紹介</target>
        </trans-unit>
        <trans-unit id="273a20c96a580af6e0e1fc6c4491680cd6e13de6" translate="yes" xml:space="preserve">
          <source>Intuitiveness is not the goal here. Repeatability is. The reason for the &quot;no arguments means no work&quot; behavior is that from scripts you are supposed to be able to do:</source>
          <target state="translated">直感性はここでのゴールではない。重要なのは再現性です。引数がないと仕事にならない」という動作の理由は、スクリプトからできるようになることが前提になっているからです。</target>
        </trans-unit>
        <trans-unit id="6a9b44369c96eafd66d755034e5ce80488ad8832" translate="yes" xml:space="preserve">
          <source>Invocation</source>
          <target state="translated">Invocation</target>
        </trans-unit>
        <trans-unit id="1d5f124f7b2f261867ec41e2c056658bb6e88c34" translate="yes" xml:space="preserve">
          <source>Invoke a text editor (see GIT_EDITOR in &lt;a href=&quot;git-var&quot;&gt;git-var[1]&lt;/a&gt;) to edit an introductory message for the patch series.</source>
          <target state="translated">テキストエディターを呼び出し（&lt;a href=&quot;git-var&quot;&gt;git-var [1]の&lt;/a&gt; GIT_EDITORを参照）、パッチシリーズの紹介メッセージを編集します。</target>
        </trans-unit>
        <trans-unit id="9ba2ef7b89376be98d487b046c212677da3221b4" translate="yes" xml:space="preserve">
          <source>Invoke an editor before committing successful mechanical merge to further edit the auto-generated merge message, so that the user can explain and justify the merge. The &lt;code&gt;--no-edit&lt;/code&gt; option can be used to accept the auto-generated message (this is generally discouraged).</source>
          <target state="translated">機械的なマージをコミットする前にエディターを起動して、自動生成されたマージメッセージをさらに編集し、ユーザーがマージを説明および正当化できるようにします。 &lt;code&gt;--no-edit&lt;/code&gt; オプションは、（これは一般的に推奨され）、自動生成されたメッセージを受け入れるために使用することができます。</target>
        </trans-unit>
        <trans-unit id="a978683542367bbc42f0a41dd9d11a4a00c553d9" translate="yes" xml:space="preserve">
          <source>Invoke an editor before committing successful mechanical merge to further edit the auto-generated merge message, so that the user can explain and justify the merge. The &lt;code&gt;--no-edit&lt;/code&gt; option can be used to accept the auto-generated message (this is generally discouraged). The &lt;code&gt;--edit&lt;/code&gt; (or &lt;code&gt;-e&lt;/code&gt;) option is still useful if you are giving a draft message with the &lt;code&gt;-m&lt;/code&gt; option from the command line and want to edit it in the editor.</source>
          <target state="translated">機械的なマージをコミットする前にエディターを起動して、自動生成されたマージメッセージをさらに編集し、ユーザーがマージを説明および正当化できるようにします。 &lt;code&gt;--no-edit&lt;/code&gt; オプションは、（これは一般的に推奨され）、自動生成されたメッセージを受け入れるために使用することができます。 &lt;code&gt;--edit&lt;/code&gt; （または &lt;code&gt;-e&lt;/code&gt; あなたとドラフトメッセージ与えている場合）オプションはまだ有効です &lt;code&gt;-m&lt;/code&gt; コマンドラインからオプションを、エディタで編集にそれをしたいです。</target>
        </trans-unit>
        <trans-unit id="ab51558f752b86c08b9c277e1cd35bd4f5da28bc" translate="yes" xml:space="preserve">
          <source>Invoke the sendemail-validate hook if present (see &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;).</source>
          <target state="translated">sendemail-validateフックが存在する場合はそれを呼び出します（&lt;a href=&quot;githooks&quot;&gt;githooks [5]を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="6307458f7efb25e5d4237ad7a4e972e464f2ab54" translate="yes" xml:space="preserve">
          <source>Invoked by &lt;code&gt;git archive --remote&lt;/code&gt; and sends a generated archive to the other end over the Git protocol.</source>
          <target state="translated">&lt;code&gt;git archive --remote&lt;/code&gt; によって呼び出され、生成されたアーカイブをGitプロトコルを介して相手側に送信します。</target>
        </trans-unit>
        <trans-unit id="4591feb10dd06f62e310d9c287cf3f981ce9babf" translate="yes" xml:space="preserve">
          <source>Invoked by &lt;code&gt;git fetch-pack&lt;/code&gt;, learns what objects the other side is missing, and sends them after packing.</source>
          <target state="translated">&lt;code&gt;git fetch-pack&lt;/code&gt; によって呼び出され、反対側で欠落しているオブジェクトを学習し、パッキング後に送信します。</target>
        </trans-unit>
        <trans-unit id="a7f91dd525c007f2b681e8a032a0618f9a34ea1c" translate="yes" xml:space="preserve">
          <source>Invoked by &lt;code&gt;git send-pack&lt;/code&gt; and updates the repository with the information fed from the remote end.</source>
          <target state="translated">&lt;code&gt;git send-pack&lt;/code&gt; によって呼び出され、リモートエンドから提供された情報でリポジトリを更新します。</target>
        </trans-unit>
        <trans-unit id="d65563f7b9f547034dceec39b8ac04f9c683c150" translate="yes" xml:space="preserve">
          <source>Invokes &lt;code&gt;git-receive-pack&lt;/code&gt; on a possibly remote repository, and updates it from the current repository, sending named refs.</source>
          <target state="translated">リモートのリポジトリで &lt;code&gt;git-receive-pack&lt;/code&gt; を呼び出し、現在のリポジトリからそれを更新して、名前付き参照を送信します。</target>
        </trans-unit>
        <trans-unit id="b53ca0a7337f2511de77389036559a87c502bc3d" translate="yes" xml:space="preserve">
          <source>Invokes &lt;code&gt;git-upload-pack&lt;/code&gt; on a possibly remote repository and asks it to send objects missing from this repository, to update the named heads. The list of commits available locally is found out by scanning the local refs/ hierarchy and sent to &lt;code&gt;git-upload-pack&lt;/code&gt; running on the other end.</source>
          <target state="translated">可能性のあるリモートリポジトリで &lt;code&gt;git-upload-pack&lt;/code&gt; を呼び出し、このリポジトリにないオブジェクトを送信して、名前付きヘッドを更新するように要求します。ローカルで利用可能なコミットのリストは、ローカルのrefs /階層をスキャンすることによって見つけられ、反対側で実行されている &lt;code&gt;git-upload-pack&lt;/code&gt; に送信されます。</target>
        </trans-unit>
        <trans-unit id="a31ffeaabebc608f725ad5aea0019f330d8c2ea7" translate="yes" xml:space="preserve">
          <source>Invoking &lt;code&gt;git add -e&lt;/code&gt; or selecting &lt;code&gt;e&lt;/code&gt; from the interactive hunk selector will open a patch in your editor; after the editor exits, the result is applied to the index. You are free to make arbitrary changes to the patch, but note that some changes may have confusing results, or even result in a patch that cannot be applied. If you want to abort the operation entirely (i.e., stage nothing new in the index), simply delete all lines of the patch. The list below describes some common things you may see in a patch, and which editing operations make sense on them.</source>
          <target state="translated">&lt;code&gt;git add -e&lt;/code&gt; を呼び出すか、対話型のハンクセレクターから &lt;code&gt;e&lt;/code&gt; を選択すると、エディターでパッチが開きます。エディターが終了すると、結果がインデックスに適用されます。パッチは自由に変更できますが、一部の変更では混乱を招く結果になる場合や、パッチを適用できない場合さえあることに注意してください。操作を完全に中止する場合（つまり、インデックスに新しいものをステージングしない場合）は、パッチのすべての行を削除します。以下のリストは、パッチに表示される可能性のあるいくつかの一般的なものと、それらに対してどの編集操作が意味があるかを説明しています。</target>
        </trans-unit>
        <trans-unit id="7eda501750cd6c5e49ea1b4fd74542b592feab87" translate="yes" xml:space="preserve">
          <source>Involving QA people and if possible end users</source>
          <target state="translated">QA担当者や可能であればエンドユーザーを巻き込む</target>
        </trans-unit>
        <trans-unit id="4ddb9cd693a2e162ef85f6fbfe4abc845111ebb9" translate="yes" xml:space="preserve">
          <source>Is a synonym for &lt;code&gt;zebra&lt;/code&gt;. This may change to a more sensible mode in the future.</source>
          <target state="translated">&lt;code&gt;zebra&lt;/code&gt; 同義語です。これは将来、より適切なモードに変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="4f13daaae3d7fc7ba5d15c4ccfc54188d83d267e" translate="yes" xml:space="preserve">
          <source>Is used as suggested name when creating new branches using the &lt;a href=&quot;git-gui&quot;&gt;git-gui[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;git-gui&quot;&gt;git-gui [1]&lt;/a&gt;を使用して新しいブランチを作成するときに推奨される名前として使用されます。</target>
        </trans-unit>
        <trans-unit id="6f3229278b909458bc76fcc500cf44677191a296" translate="yes" xml:space="preserve">
          <source>Islands are configured via the &lt;code&gt;pack.island&lt;/code&gt; option, which can be specified multiple times. Each value is a left-anchored regular expressions matching refnames. For example:</source>
          <target state="translated">アイランドは、複数回指定できる &lt;code&gt;pack.island&lt;/code&gt; オプションを介して構成されます。各値は、refnameに一致する左にアンカーされた正規表現です。例えば：</target>
        </trans-unit>
        <trans-unit id="30ce4cb25faae86427d8ac22e8f50a0a74f3f393" translate="yes" xml:space="preserve">
          <source>Issues</source>
          <target state="translated">Issues</target>
        </trans-unit>
        <trans-unit id="0120e142d77ed0c1102a3548e5e6ca12ae1c469b" translate="yes" xml:space="preserve">
          <source>Issues which are security relevant should be disclosed privately to the Git Security mailing list &amp;lt;&lt;a href=&quot;mailto:git-security@googlegroups.com&quot;&gt;git-security@googlegroups.com&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">セキュリティ関連の問題は、Git Securityメーリングリスト&amp;lt; &lt;a href=&quot;mailto:git-security@googlegroups.com&quot;&gt;git-security@googlegroups.com&lt;/a&gt; &amp;gt;に非公開で公開する必要があります。</target>
        </trans-unit>
        <trans-unit id="7e6ca0d89968d14a4a145a03ebcf512ab164b2cf" translate="yes" xml:space="preserve">
          <source>Issuing a &lt;code&gt;filedeleteall&lt;/code&gt; followed by the needed &lt;code&gt;filemodify&lt;/code&gt; commands to set the correct content will produce the same results as sending only the needed &lt;code&gt;filemodify&lt;/code&gt; and &lt;code&gt;filedelete&lt;/code&gt; commands. The &lt;code&gt;filedeleteall&lt;/code&gt; approach may however require fast-import to use slightly more memory per active branch (less than 1 MiB for even most large projects); so frontends that can easily obtain only the affected paths for a commit are encouraged to do so.</source>
          <target state="translated">発行 &lt;code&gt;filedeleteall&lt;/code&gt; 必要が続い &lt;code&gt;filemodify&lt;/code&gt; 正しい内容を設定するためのコマンドにのみ必要な送信と同じ結果を生成します &lt;code&gt;filemodify&lt;/code&gt; と &lt;code&gt;filedelete&lt;/code&gt; コマンドを。 &lt;code&gt;filedeleteall&lt;/code&gt; のアプローチは、しかし、（も、最も大規模なプロジェクトのために1未満MIB）能動ブランチあたりわずかに多くのメモリを使用する高速インポートを必要とするかもしれません。そのため、コミットの影響を受けるパスのみを簡単に取得できるフロントエンドは、そうすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="bdf45bc4332be1bec5eceb55b9547e5441cbefc8" translate="yes" xml:space="preserve">
          <source>It adds the submodule&amp;rsquo;s clone path to the &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt; file and adds this file to the index, ready to be committed.</source>
          <target state="translated">サブモジュールのクローンパスを&lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5]&lt;/a&gt;ファイルに追加し、このファイルをインデックスに追加して、コミットする準備が整います。</target>
        </trans-unit>
        <trans-unit id="8c81521fe76c33a9e0c12152a7126a3168cdc6bc" translate="yes" xml:space="preserve">
          <source>It adds the submodule&amp;rsquo;s current commit ID to the index, ready to be committed.</source>
          <target state="translated">サブモジュールの現在のコミットIDをインデックスに追加し、コミットする準備が整います。</target>
        </trans-unit>
        <trans-unit id="d31bfc2387ea73611500553c1004cb0667d4f160" translate="yes" xml:space="preserve">
          <source>It affects the way a change that amounts to a total rewrite of a file not as a series of deletion and insertion mixed together with a very few lines that happen to match textually as the context, but as a single deletion of everything old followed by a single insertion of everything new, and the number &lt;code&gt;m&lt;/code&gt; controls this aspect of the -B option (defaults to 60%). &lt;code&gt;-B/70%&lt;/code&gt; specifies that less than 30% of the original should remain in the result for Git to consider it a total rewrite (i.e. otherwise the resulting patch will be a series of deletion and insertion mixed together with context lines).</source>
          <target state="translated">これは、一連の削除と挿入が混合され、テキストとしてコンテキストとして一致する非常に少数の行ではなく、古いすべての単一の削除とそれに続く新しいものすべてを1回挿入すると、 &lt;code&gt;m&lt;/code&gt; という数字が-Bオプションのこの側面を制御します（デフォルトは60％）。 &lt;code&gt;-B/70%&lt;/code&gt; は、Gitがそれを完全な書き直しと見なすために、元の30％未満が結果に残る必要があることを指定します（それ以外の場合、結果のパッチは、コンテキスト行と混合された一連の削除と挿入になります）。</target>
        </trans-unit>
        <trans-unit id="3769038328418f1b146bfedf460a0d4ea1eab91b" translate="yes" xml:space="preserve">
          <source>It also allows a &quot;ref&quot; file to be a symbolic pointer to another ref file by starting with the four-byte header sequence of &quot;ref:&quot;.</source>
          <target state="translated">また、&quot;ref &quot;ファイルを、&quot;ref:&quot;の4バイトのヘッダシーケンスで始まる別のrefファイルへのシンボリックポインタにすることもできる。</target>
        </trans-unit>
        <trans-unit id="c1a8e562ae70e23b9286b736cb60f8fd411f796d" translate="yes" xml:space="preserve">
          <source>It can also be useful in scripts passed to &quot;git bisect run&quot; to &quot;exit 255&quot; if some very abnormal situation is detected.</source>
          <target state="translated">また、&quot;git bisect run&quot; に渡されたスクリプトの中で、何か非常に異常な状況が検出された場合に &quot;exit 255&quot; を実行するのにも役立ちます。</target>
        </trans-unit>
        <trans-unit id="79b5b9aab5919bae0a6145dab082f1d19cd80f67" translate="yes" xml:space="preserve">
          <source>It can be cumbersome to input the same credentials over and over. Git provides two methods to reduce this annoyance:</source>
          <target state="translated">同じ認証情報を何度も入力するのは面倒です。Git には、この煩わしさを軽減するための二つの方法が用意されています。</target>
        </trans-unit>
        <trans-unit id="4e1aaed29365e5e25e94340f3a0f563a3458fb95" translate="yes" xml:space="preserve">
          <source>It can be used to inspect the current working tree and refuse to make a commit if it does not pass certain test.</source>
          <target state="translated">これは、現在の作業ツリーを検査し、特定のテストに合格しない場合にコミットを拒否するために使用することができます。</target>
        </trans-unit>
        <trans-unit id="15367977bf1bc97e62677f2311accebdf50497b6" translate="yes" xml:space="preserve">
          <source>It can efficiently represent information about merge conflicts between different tree objects, allowing each pathname to be associated with sufficient information about the trees involved that you can create a three-way merge between them.</source>
          <target state="translated">これは、異なるツリーオブジェクト間のマージの競合に関する情報を効率的に表現することができ、各パス名を、関係するツリーに関する十分な情報と関連付けることができ、それらの間で三者間のマージを作成することができるようになります。</target>
        </trans-unit>
        <trans-unit id="61f59429096395b0e09a9585119ef97dbe0f3099" translate="yes" xml:space="preserve">
          <source>It cannot show more than 29 branches and commits at a time.</source>
          <target state="translated">一度に29以上のブランチとコミットを表示することはできません。</target>
        </trans-unit>
        <trans-unit id="84908290c2ad8351819557b635db90afccbc35f1" translate="yes" xml:space="preserve">
          <source>It clones the submodule from &lt;code&gt;&amp;lt;repo&amp;gt;&lt;/code&gt; to the given &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; under the current directory and by default checks out the master branch.</source>
          <target state="translated">サブモジュールを &lt;code&gt;&amp;lt;repo&amp;gt;&lt;/code&gt; から現在のディレクトリの下の指定された &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; に複製し、デフォルトでマスターブランチをチェックアウトします。</target>
        </trans-unit>
        <trans-unit id="d2f2a22f8382dea93b62981d5e21e0c74a8c6b46" translate="yes" xml:space="preserve">
          <source>It could also be used to log the old..new status. However, it does not know the entire set of branches, so it would end up firing one e-mail per ref when used naively, though. The &lt;a href=&quot;#post-receive&quot;&gt;&lt;em&gt;post-receive&lt;/em&gt;&lt;/a&gt; hook is more suited to that.</source>
          <target state="translated">old..newステータスのログにも使用できます。ただし、ブランチのセット全体を認識していないため、単純に使用すると、参照ごとに1つの電子メールが送信されます。&lt;a href=&quot;#post-receive&quot;&gt;&lt;em&gt;ポスト受ける&lt;/em&gt;&lt;/a&gt;フックがそれに適しています。</target>
        </trans-unit>
        <trans-unit id="784deb932c786d53caa1d9cefe7cd05964d957b0" translate="yes" xml:space="preserve">
          <source>It defaults to &lt;code&gt;blue,12 month ago,white,1 month ago,red&lt;/code&gt;, which colors everything older than one year blue, recent changes between one month and one year old are kept white, and lines introduced within the last month are colored red.</source>
          <target state="translated">デフォルトは &lt;code&gt;blue,12 month ago,white,1 month ago,red&lt;/code&gt; 、1年以上古いものはすべて青で表示されます。1か月から1年前の最近の変更は白のままで、先月に導入された線は赤で表示されます。</target>
        </trans-unit>
        <trans-unit id="91de163844ee67c93c1b1c843cc5bef0832c9f25" translate="yes" xml:space="preserve">
          <source>It does its best to do the safe thing, it will check that the files are unchanged and up to date in the CVS checkout, and it will not autocommit by default.</source>
          <target state="translated">それは安全なことをするために最善を尽くします、それはCVSチェックアウトでファイルが変更されていないことと最新の状態であることをチェックします、そしてそれはデフォルトでは自動コミットされません。</target>
        </trans-unit>
        <trans-unit id="92564150ed02a0207f639f4b1e8f897270e7157d" translate="yes" xml:space="preserve">
          <source>It does this by storing some additional data for each entry (such as the last modified time). This data is not displayed above, and is not stored in the created tree object, but it can be used to determine quickly which files in the working directory differ from what was stored in the index, and thus save Git from having to read all of the data from such files to look for changes.</source>
          <target state="translated">これは、各エントリごとに追加のデータ (最終更新時刻など)を保存することで行います。このデータは上には表示されず、作成されたツリーオブジェクトにも保存されませんが、作業ディレクトリ内のどのファイルがインデックスに保存されていたものと異なるのかを素早く判断するために使うことができます。</target>
        </trans-unit>
        <trans-unit id="af8ba1869bb0a79ae9cea38b1af5617b9069dca1" translate="yes" xml:space="preserve">
          <source>It enables git to work together with a file system monitor (see the &quot;fsmonitor-watchman&quot; section of &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;) that can inform it as to what files have been modified. This enables git to avoid having to lstat() every file to find modified files.</source>
          <target state="translated">これにより、gitはファイルシステムモニター（&lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt;の「fsmonitor-watchman」セクションを参照）と連携して、変更されたファイルを通知できるようになります。これにより、変更されたファイルを見つけるためにgitがすべてのファイルをlstat（）する必要がなくなります。</target>
        </trans-unit>
        <trans-unit id="af9f31199487ba705eebc5dd4bc13449d71955c8" translate="yes" xml:space="preserve">
          <source>It expects to be dealing with one project only. If it sees branches that have different roots, it will refuse to run. In that case, edit your &amp;lt;archive/branch&amp;gt; parameters to define clearly the scope of the import.</source>
          <target state="translated">1つのプロジェクトのみを扱うことを想定しています。異なるルートを持つブランチが見つかると、実行を拒否します。その場合は、&amp;lt;archive / branch&amp;gt;パラメータを編集して、インポートのスコープを明確に定義します。</target>
        </trans-unit>
        <trans-unit id="d015f51d5305572fa694969daaad327b702a39d6" translate="yes" xml:space="preserve">
          <source>It helps to divide these functions into groups for discussion purposes.</source>
          <target state="translated">これらの機能をグループに分けて議論の目的に役立てることができます。</target>
        </trans-unit>
        <trans-unit id="cf8815ec8cef4d3d8f9a8adf49f25148a4887929" translate="yes" xml:space="preserve">
          <source>It is &lt;code&gt;&amp;lt;unix timestamp&amp;gt; &amp;lt;time zone offset&amp;gt;&lt;/code&gt;, where &lt;code&gt;&amp;lt;unix
timestamp&amp;gt;&lt;/code&gt; is the number of seconds since the UNIX epoch. &lt;code&gt;&amp;lt;time zone offset&amp;gt;&lt;/code&gt; is a positive or negative offset from UTC. For example CET (which is 1 hour ahead of UTC) is &lt;code&gt;+0100&lt;/code&gt;.</source>
          <target state="translated">これは、 &lt;code&gt;&amp;lt;unix timestamp&amp;gt; &amp;lt;time zone offset&amp;gt;&lt;/code&gt; 。ここで、 &lt;code&gt;&amp;lt;unix timestamp&amp;gt;&lt;/code&gt; は、UNIXエポックからの秒数です。 &lt;code&gt;&amp;lt;time zone offset&amp;gt;&lt;/code&gt; は、UTCからの正または負のオフセットです。たとえば、CET（UTCより1時間進んでいる）は &lt;code&gt;+0100&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="3f4ae55d14bc9f41dc555ac55a4684de8bea2c17" translate="yes" xml:space="preserve">
          <source>It is OK to include files which have not actually changed. All changes including newly-created and deleted files should be included. When files are renamed, both the old and the new name should be included.</source>
          <target state="translated">実際には変更されていないファイルを含めても構いません。新しく作成されたファイルや削除されたファイルを含むすべての変更を含める必要があります。ファイルの名前が変更された場合は、古い名前と新しい名前の両方を含める必要があります。</target>
        </trans-unit>
        <trans-unit id="854a36265382bec82daa5a74f777ff212834a549" translate="yes" xml:space="preserve">
          <source>It is a good idea to introduce yourself to Git with your name and public email address before doing any operation. The easiest way to do so is:</source>
          <target state="translated">何か操作をする前に、自分の名前と公開メールアドレスでGitに自己紹介をしておくと良いでしょう。一番簡単な方法は</target>
        </trans-unit>
        <trans-unit id="0dc733d75bf5327e08cfc3134be1a3042cbb2515" translate="yes" xml:space="preserve">
          <source>It is a rough equivalent for:</source>
          <target state="translated">に大まかに相当します。</target>
        </trans-unit>
        <trans-unit id="95c229774b9b51315840e554d56265719cd8be5c" translate="yes" xml:space="preserve">
          <source>It is also a good idea when using any VCS to have only one small logical change in each commit.</source>
          <target state="translated">また、どのVCSを使用する場合でも、コミットごとに小さな論理的な変更が1つだけあるのは良いアイデアです。</target>
        </trans-unit>
        <trans-unit id="6c5a3acbba80472c3128c6339cb1639b4bd8a27a" translate="yes" xml:space="preserve">
          <source>It is also permitted for a notes ref to point directly to a tree object, in which case the history of the notes can be read with &lt;code&gt;git log -p -g &amp;lt;refname&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">notes refがツリーオブジェクトを直接指すことも許可されています。この場合、メモの履歴は &lt;code&gt;git log -p -g &amp;lt;refname&amp;gt;&lt;/code&gt; で読み取ることができます。</target>
        </trans-unit>
        <trans-unit id="df38f390855a08aaa74243c50bf2cb099b03fbb3" translate="yes" xml:space="preserve">
          <source>It is also possible for perpetually modified files to occur on any platform if a smudge or clean filter is in use on your system but a file was previously committed without running the smudge or clean filter. To fix this, run the following on an otherwise clean working tree:</source>
          <target state="translated">また、システム上でスマッジやクリーンフィルタが使用されていても、そのファイルがスマッジやクリーンフィルタを実行せずにコミットされていた場合、どのプラットフォームでもファイルが永続的に変更される可能性があります。これを修正するには、クリーンな作業ツリー上で以下を実行してください。</target>
        </trans-unit>
        <trans-unit id="b16dc4f2558875d3f67cc118d8aee343695acae5" translate="yes" xml:space="preserve">
          <source>It is also possible to fetch a subset of branches or tags by using a comma-separated list of names within braces. For example:</source>
          <target state="translated">中括弧内の名前をカンマで区切ったリストを使用して、ブランチやタグのサブセットを取得することも可能です。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="12b7523072e662c296ea1a80ba59ec7ed5fcb7e4" translate="yes" xml:space="preserve">
          <source>It is also possible to introduce completely new merge commits from scratch by adding a command of the form &lt;code&gt;merge &amp;lt;merge-head&amp;gt;&lt;/code&gt;. This form will generate a tentative commit message and always open an editor to let the user edit it. This can be useful e.g. when a topic branch turns out to address more than a single concern and wants to be split into two or even more topic branches. Consider this todo list:</source>
          <target state="translated">&lt;code&gt;merge &amp;lt;merge-head&amp;gt;&lt;/code&gt; の形式のコマンドを追加することにより、完全に新しいマージコミットを最初から導入することもできます。このフォームは一時的なコミットメッセージを生成し、常にエディターを開いてユーザーが編集できるようにします。これは、たとえば、トピックブランチが複数の問題に対処し、2つ以上のトピックブランチに分割したい場合に役立ちます。次のToDoリストを検討してください。</target>
        </trans-unit>
        <trans-unit id="e8d4e8a65d3b558ba4900bdd06798676f68d11ad" translate="yes" xml:space="preserve">
          <source>It is also possible to provide true CVS access to a Git repository, so that developers can still use CVS; see &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver[1]&lt;/a&gt; for details.</source>
          <target state="translated">開発者がCVSを引き続き使用できるように、Gitリポジトリへの真のCVSアクセスを提供することもできます。詳細は&lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver [1]&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="3fcb2e34d6c27144258c45911fcc9298afaeeefa" translate="yes" xml:space="preserve">
          <source>It is also possible to replace commits further back in the history, but this is an advanced topic to be left for &lt;a href=&quot;#cleaning-up-history&quot;&gt;another chapter&lt;/a&gt;.</source>
          <target state="translated">履歴をさらに遡ってコミットを置き換えることも可能ですが、これは&lt;a href=&quot;#cleaning-up-history&quot;&gt;別の章に&lt;/a&gt;残しておくべき高度なトピックです。</target>
        </trans-unit>
        <trans-unit id="14665d6ab0c5fa19cd26aec534fecd5dda3c4692" translate="yes" xml:space="preserve">
          <source>It is also run after &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt;, unless the &lt;code&gt;--no-checkout&lt;/code&gt; (&lt;code&gt;-n&lt;/code&gt;) option is used. The first parameter given to the hook is the null-ref, the second the ref of the new HEAD and the flag is always 1. Likewise for &lt;code&gt;git worktree add&lt;/code&gt; unless &lt;code&gt;--no-checkout&lt;/code&gt; is used.</source>
          <target state="translated">&lt;code&gt;--no-checkout&lt;/code&gt; （ &lt;code&gt;-n&lt;/code&gt; ）オプションが使用されていない限り、&lt;a href=&quot;git-clone&quot;&gt;git-clone [1]の&lt;/a&gt;後にも実行されます。フックに指定された最初のパラメーターはnull-refで、2番目は新しいHEADの参照であり、フラグは常に1です。同様に &lt;code&gt;--no-checkout&lt;/code&gt; が使用されない限り、 &lt;code&gt;git worktree add&lt;/code&gt; の場合も同様です。</target>
        </trans-unit>
        <trans-unit id="2bf0b4701dd5a8615d5c5a4270f19ec18f43aa49" translate="yes" xml:space="preserve">
          <source>It is an error if &amp;lt;dst&amp;gt; matches more than one remote refs.</source>
          <target state="translated">&amp;lt;dst&amp;gt;が複数のリモート参照に一致する場合、エラーになります。</target>
        </trans-unit>
        <trans-unit id="47ed8fd8a6ccf512f8dd41b7de1bb50b3d494692" translate="yes" xml:space="preserve">
          <source>It is an error if &amp;lt;src&amp;gt; does not match exactly one of the local refs.</source>
          <target state="translated">&amp;lt;src&amp;gt;がローカル参照の1つと正確に一致しない場合、エラーになります。</target>
        </trans-unit>
        <trans-unit id="08551e573ca80a9130c1ec33d2456a204ee6a838" translate="yes" xml:space="preserve">
          <source>It is an error to specify a ref that does not pass &quot;git check-ref-format&quot; scrutiny. Duplicated values are filtered.</source>
          <target state="translated">git check-ref-format&quot; の scrutiny を通らない ref を指定するとエラーになります。重複した値はフィルタリングされます。</target>
        </trans-unit>
        <trans-unit id="91dc5c05cc945b2e35d03a4d25f4568585356b02" translate="yes" xml:space="preserve">
          <source>It is assumed that any handshaking procedures have already been completed (such as sending service request for git://) before this helper is started.</source>
          <target state="translated">このヘルパーが起動される前に、ハンドシェイクの手続き (git://へのサービスリクエストの送信など)がすでに完了していることが想定されます。</target>
        </trans-unit>
        <trans-unit id="7a3002fc7973dbc26474a90f4bdcb162301b4e67" translate="yes" xml:space="preserve">
          <source>It is currently only possible to recreate the merge commits using the &lt;code&gt;recursive&lt;/code&gt; merge strategy; Different merge strategies can be used only via explicit &lt;code&gt;exec git merge -s &amp;lt;strategy&amp;gt; [...]&lt;/code&gt; commands.</source>
          <target state="translated">現在、 &lt;code&gt;recursive&lt;/code&gt; マージ戦略を使用してマージコミットを再作成することのみが可能です。異なるマージ戦略は、明示的な &lt;code&gt;exec git merge -s &amp;lt;strategy&amp;gt; [...]&lt;/code&gt; コマンドを介してのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="bd70cf0a22a7ad38ee60197dd400f891cf0d57a3" translate="yes" xml:space="preserve">
          <source>It is expected that the content of the commit object you created while following the example above generates a different SHA-1 hash than the one shown above because the commit object records the time when it was created and the name of the person performing the commit.</source>
          <target state="translated">上記の例に従って作成したコミットオブジェクトの内容は、コミットオブジェクトが作成された時刻とコミットを実行した人の名前が記録されているため、上記の内容とは異なるSHA-1ハッシュが生成されることが予想されます。</target>
        </trans-unit>
        <trans-unit id="f78a88555b80a7cb6f279e6cf8551b4ade125a2a" translate="yes" xml:space="preserve">
          <source>It is followed by one or more extended header lines (this example shows a merge with two parents):</source>
          <target state="translated">これの後には、1 つ以上の拡張ヘッダ行が続きます (この例では、2 つの親を持つマージを示しています)。</target>
        </trans-unit>
        <trans-unit id="4d181ca929d0bcae1d19e843f3c648e99a609d36" translate="yes" xml:space="preserve">
          <source>It is followed by one or more extended header lines:</source>
          <target state="translated">これには、1つ以上の拡張ヘッダ行が続きます。</target>
        </trans-unit>
        <trans-unit id="a6770fb3a63d614ebdc42bea002a81ec83ae2568" translate="yes" xml:space="preserve">
          <source>It is followed by two-line from-file/to-file header</source>
          <target state="translated">2 行の from-file/to-file ヘッダが続きます。</target>
        </trans-unit>
        <trans-unit id="31bbdf9a81fa3062a8106d3f0d5511057b4a5222" translate="yes" xml:space="preserve">
          <source>It is highly functional. However, not all methods are implemented, and for those methods that are implemented, not all switches are implemented.</source>
          <target state="translated">高機能である。ただし、すべてのメソッドが実装されているわけではなく、実装されているメソッドについては、すべてのスイッチが実装されているわけではありません。</target>
        </trans-unit>
        <trans-unit id="13209c7d424e2b65e2d35ccb5123d7d58e26c1e7" translate="yes" xml:space="preserve">
          <source>It is important to realize that at this point nothing refers to commit &lt;code&gt;f&lt;/code&gt;. Eventually commit &lt;code&gt;f&lt;/code&gt; (and by extension commit &lt;code&gt;e&lt;/code&gt;) will be deleted by the routine Git garbage collection process, unless we create a reference before that happens. If we have not yet moved away from commit &lt;code&gt;f&lt;/code&gt;, any of these will create a reference to it:</source>
          <target state="translated">この時点では、コミット &lt;code&gt;f&lt;/code&gt; は参照されていないことに注意してください。最終的にcommit &lt;code&gt;f&lt;/code&gt; （および拡張commit &lt;code&gt;e&lt;/code&gt; ）は、発生する前に参照を作成しない限り、ルーチンのGitガベージコレクションプロセスによって削除されます。まだコミット &lt;code&gt;f&lt;/code&gt; から離れていない場合、これらのいずれかがそれへの参照を作成します。</target>
        </trans-unit>
        <trans-unit id="15e77b99d56294dd4d998fab1260c89fc2b1f677" translate="yes" xml:space="preserve">
          <source>It is likely that you will be pulling from the same remote repository from time to time. As a short hand, you can store the remote repository URL in the local repository&amp;rsquo;s config file like this:</source>
          <target state="translated">場合によっては、同じリモートリポジトリからプルすることがあります。簡単に言うと、次のように、リモートリポジトリのURLをローカルリポジトリの構成ファイルに保存できます。</target>
        </trans-unit>
        <trans-unit id="e468ce82ca7a37df3e0ccb7eddd0ee514020b622" translate="yes" xml:space="preserve">
          <source>It is likely that you will be working on more than one thing at a time. It is easy to manage those more-or-less independent tasks using branches with Git.</source>
          <target state="translated">一度に複数の作業を行うこともあるでしょう。Git を使ってブランチを使えば、それらのタスクを管理するのは簡単です。</target>
        </trans-unit>
        <trans-unit id="cdfac588afc71ee687618e7ec3bc2f824e200606" translate="yes" xml:space="preserve">
          <source>It is not always easy for new developers to find their way through Git&amp;rsquo;s source code. This section gives you a little guidance to show where to start.</source>
          <target state="translated">新しい開発者がGitのソースコードを自分の道で見つけるのは必ずしも簡単ではありません。このセクションでは、どこから始めればよいかを示すための簡単なガイダンスを示します。</target>
        </trans-unit>
        <trans-unit id="deded1cb8baf6033568ee8de4cb9cb55818cb450" translate="yes" xml:space="preserve">
          <source>It is not recommended to use this feature if you intend to export changes back to CVS again later with &lt;code&gt;git cvsexportcommit&lt;/code&gt;.</source>
          <target state="translated">後で &lt;code&gt;git cvsexportcommit&lt;/code&gt; を使用して変更をCVSにエクスポートする場合は、この機能を使用することはお勧めしません。</target>
        </trans-unit>
        <trans-unit id="598d612724092a05c80fc92ca656e4e685e7e227" translate="yes" xml:space="preserve">
          <source>It is obviously a good idea not to have commits with changes that knowingly break things, even if some other commits later fix the breakage.</source>
          <target state="translated">明らかに、故意に物事を壊すような変更を加えたコミットはしない方が良いでしょう。</target>
        </trans-unit>
        <trans-unit id="8402ec5252190f6132c0772d2b1eafbec27785df" translate="yes" xml:space="preserve">
          <source>It is possible that a merge failure will prevent this process from being completely automatic. You will have to resolve any such merge failure and run &lt;code&gt;git rebase --continue&lt;/code&gt;. Another option is to bypass the commit that caused the merge failure with &lt;code&gt;git rebase --skip&lt;/code&gt;. To check out the original &amp;lt;branch&amp;gt; and remove the .git/rebase-apply working files, use the command &lt;code&gt;git rebase --abort&lt;/code&gt; instead.</source>
          <target state="translated">マージが失敗すると、このプロセスが完全に自動化されなくなる可能性があります。そのようなマージの失敗を解決し、 &lt;code&gt;git rebase --continue&lt;/code&gt; を実行する必要があります。別のオプションは、 &lt;code&gt;git rebase --skip&lt;/code&gt; でマージの失敗を引き起こしたコミットをバイパスすることです。元の&amp;lt;branch&amp;gt;をチェックアウトして.git / rebase-apply作業ファイルを削除するには、代わりにコマンド &lt;code&gt;git rebase --abort&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="2ea7f2913c3e95cfd4ae5ff1f6d8aecb190ef204" translate="yes" xml:space="preserve">
          <source>It is possible to construct these old form repositories manually.</source>
          <target state="translated">これらの古い形式のリポジトリを手動で構築することができます。</target>
        </trans-unit>
        <trans-unit id="548453998a9c855739e7eb9ec21e0581e0ed374b" translate="yes" xml:space="preserve">
          <source>It is possible to disable use of replacement references for any command using the &lt;code&gt;--no-replace-objects&lt;/code&gt; option just after &lt;code&gt;git&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git&lt;/code&gt; の直後に &lt;code&gt;--no-replace-objects&lt;/code&gt; オプションを使用すると、コマンドの置換参照の使用を無効にすることができます。</target>
        </trans-unit>
        <trans-unit id="c06956dd566d0990dc7bdbc85eb39fd34edd8452" translate="yes" xml:space="preserve">
          <source>It is preceded with a &quot;git diff&quot; header that looks like this:</source>
          <target state="translated">このような &quot;git diff &quot;ヘッダが先行しています。</target>
        </trans-unit>
        <trans-unit id="fae83443f259566d0e3ea169c2bee02ad7796585" translate="yes" xml:space="preserve">
          <source>It is preceded with a &quot;git diff&quot; header, that looks like this (when the &lt;code&gt;-c&lt;/code&gt; option is used):</source>
          <target state="translated">次のような「git diff」ヘッダーが前に付きます（ &lt;code&gt;-c&lt;/code&gt; オプションが使用されている場合）。</target>
        </trans-unit>
        <trans-unit id="41c2e2ee7c9260a90ac9d47c12dc86595dc670c7" translate="yes" xml:space="preserve">
          <source>It is purely performance optimization, originally intended for MacOS X, where recursive directory traversal is slow. Gitweb follows symbolic links, but it detects cycles, ignoring any duplicate files and directories.</source>
          <target state="translated">これは純粋にパフォーマンスを最適化するためのもので、元々はMacOS X用に作られたもので、再帰的なディレクトリ移動が遅いのが特徴です。Gitweb はシンボリックリンクに従いますが、サイクルを検出して重複したファイルやディレクトリを無視します。</target>
        </trans-unit>
        <trans-unit id="bcd29e9bb49344b0e527480d5a1209557826cefc" translate="yes" xml:space="preserve">
          <source>It is recommended that &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; always be encoded using UTF-8.</source>
          <target state="translated">&lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; は常にUTF-8を使用してエンコードすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="987c2f12e083069e2c3c6529da1c2b8427b5d901" translate="yes" xml:space="preserve">
          <source>It is safer if both &lt;code&gt;test.sh&lt;/code&gt; and &lt;code&gt;check_test_case.sh&lt;/code&gt; are outside the repository to prevent interactions between the bisect, make and test processes and the scripts.</source>
          <target state="translated">bisect、make、testプロセスとスクリプト間の相互作用を防ぐために、 &lt;code&gt;test.sh&lt;/code&gt; と &lt;code&gt;check_test_case.sh&lt;/code&gt; の両方がリポジトリの外にある場合は、より安全です。</target>
        </trans-unit>
        <trans-unit id="07dbd897b2b790cda3e0cd6c93a27be05c0967a5" translate="yes" xml:space="preserve">
          <source>It is sometimes useful to be able to checkout a commit that is not at the tip of any named branch, or even to create a new commit that is not referenced by a named branch. Let&amp;rsquo;s look at what happens when we checkout commit &lt;code&gt;b&lt;/code&gt; (here we show two ways this may be done):</source>
          <target state="translated">名前付きブランチの先端にないコミットをチェックアウトしたり、名前付きブランチによって参照されていない新しいコミットを作成したりできると便利な場合があります。commit &lt;code&gt;b&lt;/code&gt; をチェックアウトするとどうなるかを見てみましょう（ここでは、これを行う2つの方法を示します）。</target>
        </trans-unit>
        <trans-unit id="19dd47dcbbf16a9cccaac6e901efe1eb6d41c6b4" translate="yes" xml:space="preserve">
          <source>It is still your responsibility to make sure that the email message sent by your email program meets the standards of your project. Many projects do not like patches to be attached. Some mail agents will transform patches (e.g. wrap lines, send them as format=flowed) in ways that make them fail. You will get angry flames ridiculing you if you don&amp;rsquo;t check this.</source>
          <target state="translated">電子メールプログラムによって送信された電子メールメッセージがプロジェクトの基準を満たしていることを確認するのは、依然としてあなたの責任です。多くのプロジェクトは、パッチを添付することを好みません。一部のメールエージェントは、パッチを変換して（行の折り返し、format = flowedとして送信）、失敗するようにします。これをチェックしないと、怒りの炎があなたをからかいます。</target>
        </trans-unit>
        <trans-unit id="446989de9f552ff7a375d76851b391396cb21747" translate="yes" xml:space="preserve">
          <source>It is unlikely that you would have any conflicts here &amp;hellip;​ but you might if you spent a while on this step and had also pulled new versions from upstream.</source>
          <target state="translated">ここで競合が発生する可能性はほとんどありません&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="5d35217f8f6c81e1e684634a0bdd90859d19f06a" translate="yes" xml:space="preserve">
          <source>It is up to the user to ensure that no In-Reply-To header already exists when &lt;code&gt;git send-email&lt;/code&gt; is asked to add it (especially note that &lt;code&gt;git format-patch&lt;/code&gt; can be configured to do the threading itself). Failure to do so may not produce the expected result in the recipient&amp;rsquo;s MUA.</source>
          <target state="translated">追加するように &lt;code&gt;git send-email&lt;/code&gt; が要求されたときにIn-Reply-Toヘッダーが存在しないことを確認するのはユーザーの &lt;code&gt;git format-patch&lt;/code&gt; （特に、スレッド自体を実行するようにgit format-patchを構成できることに注意してください）。そうしないと、受信者のMUAで期待される結果が得られない場合があります。</target>
        </trans-unit>
        <trans-unit id="28ab82f4261b972bffcbd084fca6120764f529fe" translate="yes" xml:space="preserve">
          <source>It is useful when you&amp;rsquo;re looking for an exact block of code (like a struct), and want to know the history of that block since it first came into being: use the feature iteratively to feed the interesting block in the preimage back into &lt;code&gt;-S&lt;/code&gt;, and keep going until you get the very first version of the block.</source>
          <target state="translated">（構造体などの）コードの正確なブロックを探していて、そのブロックが最初に登場してからの履歴を知りたい場合に便利です。この機能を繰り返し使用して、プレイメージ内の興味深いブロックをフィードバックします。 &lt;code&gt;-S&lt;/code&gt; 、そしてブロックの最初のバージョンが得られるまで続けます。</target>
        </trans-unit>
        <trans-unit id="212ba732375c1f9e18ce6b37fe943bc0a79e8a67" translate="yes" xml:space="preserve">
          <source>It is very important that the basis used be held by the destination. It is okay to err on the side of caution, causing the bundle file to contain objects already in the destination, as these are ignored when unpacking at the destination.</source>
          <target state="translated">使用する基底がデスティネーションで保持されていることが非常に重要です。バンドルファイルにはすでに宛先にあるオブジェクトが含まれていても構いません。</target>
        </trans-unit>
        <trans-unit id="f89d35d0ac276c4d31876791b9f069b985ca50ec" translate="yes" xml:space="preserve">
          <source>It may well be that among networking people, they may want to exchange the tags internal to their group, but in that workflow they are most likely tracking each other&amp;rsquo;s progress by having remote-tracking branches. Again, the heuristic to automatically follow such tags is a good thing.</source>
          <target state="translated">ネットワーキングの人々の間で、グループの内部でタグを交換したいと思うかもしれませんが、そのワークフローでは、リモートトラッキングブランチを使用することで、お互いの進捗を追跡している可能性が高いです。繰り返しになりますが、このようなタグを自動的に追跡するヒューリスティックは良いことです。</target>
        </trans-unit>
        <trans-unit id="b30dde80280e412c885fe09e1718d04b65bebbd4" translate="yes" xml:space="preserve">
          <source>It must be readable in order, from beginning to end, by someone intelligent with a basic grasp of the UNIX command line, but without any special knowledge of Git. If necessary, any other prerequisites should be specifically mentioned as they arise.</source>
          <target state="translated">UNIX のコマンドラインを基本的に把握している知的な人が、Git の特別な知識がなくても最初から最後まで順番に読めるようにしなければなりません。必要であれば、その他の前提条件については、その都度具体的に言及する必要があります。</target>
        </trans-unit>
        <trans-unit id="105999ab02cc181d3d21d02fda72679e92aee0b2" translate="yes" xml:space="preserve">
          <source>It should be stressed that this hierarchy is purely &lt;strong&gt;informal&lt;/strong&gt;. There is nothing fundamental in Git that enforces the &quot;chain of patch flow&quot; this hierarchy implies. You do not have to pull from only one remote repository.</source>
          <target state="translated">この階層は純粋に&lt;strong&gt;非公式である&lt;/strong&gt;ことを強調しておく必要があります。この階層が意味する「パッチフローのチェーン」を実施するGitには基本的なものは何もありません。リモートリポジトリを1つだけプルする必要はありません。</target>
        </trans-unit>
        <trans-unit id="7beffad8901e95a09a82e88d22525a3cad3065d8" translate="yes" xml:space="preserve">
          <source>It shows that foo.png has differences from HEAD (but that is binary so line count cannot be shown) and there is no difference between indexed copy and the working tree version (if the working tree version were also different, &lt;code&gt;binary&lt;/code&gt; would have been shown in place of &lt;code&gt;nothing&lt;/code&gt;). The other file, git-add--interactive.perl, has 403 lines added and 35 lines deleted if you commit what is in the index, but working tree file has further modifications (one addition and one deletion).</source>
          <target state="translated">foo.pngにはHEADとの違いがあり（ただし、バイナリであるため行数を表示できません）、インデックス付きコピーと作業ツリーのバージョンに違いはありません（作業ツリーのバージョンも異なる場合は、 &lt;code&gt;binary&lt;/code&gt; が表示されます）。 &lt;code&gt;nothing&lt;/code&gt; 代わりに）。もう1つのファイルgit-add--interactive.perlには、インデックスにあるものをコミットすると403行が追加され、35行が削除されますが、作業ツリーファイルにはさらに変更が加えられます（1回の追加と1回の削除）。</target>
        </trans-unit>
        <trans-unit id="593ae3fc1288babccd02a202f40d492d26634f5a" translate="yes" xml:space="preserve">
          <source>It shows that foo.png has differences from HEAD (but that is binary so line count cannot be shown) and there is no difference between indexed copy and the working tree version (if the working tree version were also different, &lt;code&gt;binary&lt;/code&gt; would have been shown in place of &lt;code&gt;nothing&lt;/code&gt;). The other file, git-add{litdd}interactive.perl, has 403 lines added and 35 lines deleted if you commit what is in the index, but working tree file has further modifications (one addition and one deletion).</source>
          <target state="translated">foo.pngはHEADとは異なり（ただし、バイナリであるため行数を表示できません）、インデックス付きコピーと作業ツリーのバージョンに違いはありません（作業ツリーのバージョンも異なる場合、 &lt;code&gt;binary&lt;/code&gt; が表示されます） &lt;code&gt;nothing&lt;/code&gt; 代わりに）。もう1つのファイルgit-add {litdd} interactive.perlには、インデックス内の内容をコミットすると403行が追加され、35行が削除されますが、作業ツリーファイルにはさらに変更（1つの追加と1つの削除）があります。</target>
        </trans-unit>
        <trans-unit id="1f22531fd9489cd1b4496c81c3454037c20af1a5" translate="yes" xml:space="preserve">
          <source>It takes a variable number of parameters, each of which is the name of ref that was actually updated.</source>
          <target state="translated">これは可変数のパラメータを取り、それぞれが実際に更新された ref の名前となります。</target>
        </trans-unit>
        <trans-unit id="8d1640303505dff202eb78d383641a82298beff2" translate="yes" xml:space="preserve">
          <source>It takes on the standard input the specification of the options to parse and understand, and echoes on the standard output a string suitable for &lt;code&gt;sh(1)&lt;/code&gt;&lt;code&gt;eval&lt;/code&gt; to replace the arguments with normalized ones. In case of error, it outputs usage on the standard error stream, and exits with code 129.</source>
          <target state="translated">解析および理解するオプションの指定を標準入力に取り、標準出力に &lt;code&gt;sh(1)&lt;/code&gt; &lt;code&gt;eval&lt;/code&gt; に適した文字列をエコーし​​て、引数を正規化されたものに置き換えます。エラーが発生した場合は、標準エラーストリームの使用状況を出力し、コード129で終了します。</target>
        </trans-unit>
        <trans-unit id="9fc9d0adb73a5f351f66393e06f90ebbcd611062" translate="yes" xml:space="preserve">
          <source>It takes one to three parameters. The first is the name of the file that contains the commit log message. The second is the source of the commit message, and can be: &lt;code&gt;message&lt;/code&gt; (if a &lt;code&gt;-m&lt;/code&gt; or &lt;code&gt;-F&lt;/code&gt; option was given); &lt;code&gt;template&lt;/code&gt; (if a &lt;code&gt;-t&lt;/code&gt; option was given or the configuration option &lt;code&gt;commit.template&lt;/code&gt; is set); &lt;code&gt;merge&lt;/code&gt; (if the commit is a merge or a &lt;code&gt;.git/MERGE_MSG&lt;/code&gt; file exists); &lt;code&gt;squash&lt;/code&gt; (if a &lt;code&gt;.git/SQUASH_MSG&lt;/code&gt; file exists); or &lt;code&gt;commit&lt;/code&gt;, followed by a commit SHA-1 (if a &lt;code&gt;-c&lt;/code&gt;, &lt;code&gt;-C&lt;/code&gt; or &lt;code&gt;--amend&lt;/code&gt; option was given).</source>
          <target state="translated">1〜3つのパラメーターを使用します。1つ目は、コミットログメッセージを含むファイルの名前です。第二は、コミットメッセージのソースであり、であることができる： &lt;code&gt;message&lt;/code&gt; （場合 &lt;code&gt;-m&lt;/code&gt; または &lt;code&gt;-F&lt;/code&gt; オプションが与えられました）。 &lt;code&gt;template&lt;/code&gt; （ &lt;code&gt;-t&lt;/code&gt; オプションが指定された場合、または構成オプション &lt;code&gt;commit.template&lt;/code&gt; が設定されている場合）; &lt;code&gt;merge&lt;/code&gt; （コミットがマージであるか、 &lt;code&gt;.git/MERGE_MSG&lt;/code&gt; ファイルが存在する場合）; &lt;code&gt;squash&lt;/code&gt; （ &lt;code&gt;.git/SQUASH_MSG&lt;/code&gt; ファイルが存在する場合）; または &lt;code&gt;commit&lt;/code&gt; 、続いてcommit SHA-1（ &lt;code&gt;-c&lt;/code&gt; 、 &lt;code&gt;-C&lt;/code&gt; または &lt;code&gt;--amend&lt;/code&gt; の場合) オプションが与えられた）。</target>
        </trans-unit>
        <trans-unit id="ee62cbb1781a10ccff3a10f01577042e41951364" translate="yes" xml:space="preserve">
          <source>It tells you that it did an &quot;Automatic merge&quot;, which failed due to conflicts in &lt;code&gt;hello&lt;/code&gt;.</source>
          <target state="translated">「自動マージ」を実行したことを &lt;code&gt;hello&lt;/code&gt; ますが、helloの競合が原因で失敗しました。</target>
        </trans-unit>
        <trans-unit id="31dbee78e4c488ce29554dd490d874937eb736b5" translate="yes" xml:space="preserve">
          <source>It used to be that the command defaulted to do &lt;code&gt;-x&lt;/code&gt; described above, and &lt;code&gt;-r&lt;/code&gt; was to disable it. Now the default is not to do &lt;code&gt;-x&lt;/code&gt; so this option is a no-op.</source>
          <target state="translated">以前は、コマンドがデフォルトで上記の &lt;code&gt;-x&lt;/code&gt; を実行し、 &lt;code&gt;-r&lt;/code&gt; がそれを無効にすることでした。現在、デフォルトでは &lt;code&gt;-x&lt;/code&gt; を実行しないため、このオプションは何もしません。</target>
        </trans-unit>
        <trans-unit id="d5579126502958d7cf2a79d1e6eb0f1ab9f1fb74" translate="yes" xml:space="preserve">
          <source>It uses &lt;code&gt;showbranch.default&lt;/code&gt; multi-valued configuration items if no &amp;lt;rev&amp;gt; or &amp;lt;glob&amp;gt; is given on the command line.</source>
          <target state="translated">コマンドラインで&amp;lt;rev&amp;gt;または&amp;lt;glob&amp;gt;が指定されていない場合は、 &lt;code&gt;showbranch.default&lt;/code&gt; 多値構成項目を使用します。</target>
        </trans-unit>
        <trans-unit id="c599d3ca0dc61039dd83109e0beef002f0abd196" translate="yes" xml:space="preserve">
          <source>It verifies that the directory has the magic file &quot;git-daemon-export-ok&quot;, and it will refuse to export any Git directory that hasn&amp;rsquo;t explicitly been marked for export this way (unless the &lt;code&gt;--export-all&lt;/code&gt; parameter is specified). If you pass some directory paths as &lt;code&gt;git daemon&lt;/code&gt; arguments, you can further restrict the offers to a whitelist comprising of those.</source>
          <target state="translated">ディレクトリにマジックファイル &quot;git-daemon-export-ok&quot;があることを確認し、この方法でエクスポート用に明示的にマークされていないGitディレクトリのエクスポートを拒否します（ &lt;code&gt;--export-all&lt;/code&gt; パラメーターが指定されている場合を除く））。 &lt;code&gt;git daemon&lt;/code&gt; 引数としていくつかのディレクトリパスを渡す場合、オファーをそれらで構成されるホワイトリストにさらに制限できます。</target>
        </trans-unit>
        <trans-unit id="3fd1b09d35c94e426d7de9278697f8281d2f9b0b" translate="yes" xml:space="preserve">
          <source>It verifies that the directory has the magic file &quot;git-daemon-export-ok&quot;, and it will refuse to export any Git directory that hasn&amp;rsquo;t explicitly been marked for export this way (unless the &lt;code&gt;GIT_HTTP_EXPORT_ALL&lt;/code&gt; environmental variable is set).</source>
          <target state="translated">ディレクトリにマジックファイル「git-daemon-export-ok」があることを確認し、この方法でエクスポートするように明示的にマークされていないGitディレクトリのエクスポートを拒否します（ &lt;code&gt;GIT_HTTP_EXPORT_ALL&lt;/code&gt; 環境変数が設定されていない場合）。</target>
        </trans-unit>
        <trans-unit id="6a949f37aaca4177eee5df32a3761a98f4054a56" translate="yes" xml:space="preserve">
          <source>It was a tool of absolute last resort. I&amp;rsquo;d rather spend days looking at printk output than do a manual &lt;code&gt;patch bisection&lt;/code&gt;.</source>
          <target state="translated">それは絶対的な最後の手段でした。手動で &lt;code&gt;patch bisection&lt;/code&gt; 行うよりも、printkの出力を確認することに何日も費やしたいと思います。</target>
        </trans-unit>
        <trans-unit id="839ea1dcb179bd0fd1a734d84c9b044b60c7a423" translate="yes" xml:space="preserve">
          <source>It will be useful to have a Git repository to experiment with as you read this manual.</source>
          <target state="translated">このマニュアルを読みながら、実験用のGitリポジトリを用意しておくと便利でしょう。</target>
        </trans-unit>
        <trans-unit id="a1e588b366d6eee7b2a111ab040de25b982fdb3f" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s also possible for a push to fail in this way when other people have the right to push to the same repository. In that case, the correct solution is to retry the push after first updating your work: either by a pull, or by a fetch followed by a rebase; see the &lt;a href=&quot;#setting-up-a-shared-repository&quot;&gt;next section&lt;/a&gt; and &lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration[7]&lt;/a&gt; for more.</source>
          <target state="translated">他の人が同じリポジトリにプッシュする権利を持っている場合、プッシュがこのように失敗する可能性もあります。その場合、正しい解決策は、最初に作業を更新した後でプッシュを再試行することです。詳細については、&lt;a href=&quot;#setting-up-a-shared-repository&quot;&gt;次のセクション&lt;/a&gt;と&lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration [7]&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="fb4f6e12e9b3bc515593c3c6f58a010f2584b187" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s best to remove one of the files such that you only have one file. You can do this with commands like the following (assuming two files &lt;code&gt;AFile.txt&lt;/code&gt; and &lt;code&gt;afile.txt&lt;/code&gt;) on an otherwise clean working tree:</source>
          <target state="translated">ファイルが1つだけになるように、ファイルの1つを削除することをお勧めします。これは、他の点ではクリーンな作業ツリーで、次のようなコマンド（2つのファイル &lt;code&gt;AFile.txt&lt;/code&gt; と &lt;code&gt;afile.txt&lt;/code&gt; を想定）を使用して実行できます。</target>
        </trans-unit>
        <trans-unit id="68ec6258a88fcfa8b2ee5adddb372d62ea174c2e" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s common to try to use &lt;code&gt;pre-commit&lt;/code&gt; hooks (or, for commit messages, &lt;code&gt;commit-msg&lt;/code&gt; hooks) to check these things, which is great if you&amp;rsquo;re working as a solo developer and want the tooling to help you. However, using hooks on a developer machine is not effective as a policy control because a user can bypass these hooks with &lt;code&gt;--no-verify&lt;/code&gt; without being noticed (among various other ways). Git assumes that the user is in control of their local repositories and doesn&amp;rsquo;t try to prevent this or tattle on the user.</source>
          <target state="translated">&lt;code&gt;pre-commit&lt;/code&gt; フック（または、コミットメッセージの場合は &lt;code&gt;commit-msg&lt;/code&gt; フック）を使用してこれらをチェックするのが一般的です。これは、単独の開発者として作業していて、ツールが役立つ場合に最適です。ただし、開発者のマシンでフックを使用することは、ユーザーが（他のさまざまな方法の中でも）気付かれることなく &lt;code&gt;--no-verify&lt;/code&gt; を使用してこれらのフックをバイパスできるため、ポリシーコントロールとしては効果的ではありません。Gitは、ユーザーがローカルリポジトリを管理していることを前提としており、これを防止したり、ユーザーを攻撃したりすることはありません。</target>
        </trans-unit>
        <trans-unit id="c8e637a625c72275676a912327970832afbb1fc7" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s especially instructive to look at &quot;commit&quot; objects, since those tend to be small and fairly self-explanatory. In particular, if you follow the convention of having the top commit name in &lt;code&gt;.git/HEAD&lt;/code&gt;, you can do</source>
          <target state="translated">「コミット」オブジェクトは小さく、かなり自明である傾向があるため、これを確認することは特に有益です。特に、 &lt;code&gt;.git/HEAD&lt;/code&gt; でトップコミット名を持つという慣習に従っている場合、次のことができます。</target>
        </trans-unit>
        <trans-unit id="ebca6c1346b961bb4e2f8a08e1112a09cf4c4143" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s far too easy to accidentally mix up old and new history. It&amp;rsquo;s still possible with any tool, but git-filter-branch almost invites it. If lucky, the only downside is users getting frustrated that they don&amp;rsquo;t know how to shrink their repo and remove the old stuff. If unlucky, they merge old and new history and end up with multiple &quot;copies&quot; of each commit, some of which have unwanted or sensitive files and others which don&amp;rsquo;t. This comes about in multiple different ways:</source>
          <target state="translated">古い履歴と新しい履歴を誤って混同することはあまりにも簡単です。それはどのツールでもまだ可能ですが、git-filter-branchはほとんどそれを招待します。運が良ければ、唯一の欠点は、ユーザーがリポジトリを縮小して古いものを削除する方法がわからないことに不満を感じることです。運が悪いと、古い履歴と新しい履歴がマージされ、各コミットの複数の「コピー」が作成されます。その中には、不要なファイルや機密ファイルが含まれているものと、そうでないものがあります。これには複数の異なる方法があります。</target>
        </trans-unit>
        <trans-unit id="7fb3124f269af4d6382e41b308c15a44d9e7c09f" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s not safe to run &lt;code&gt;git submodule update&lt;/code&gt; if you&amp;rsquo;ve made and committed changes within a submodule without checking out a branch first. They will be silently overwritten:</source>
          <target state="translated">最初にブランチをチェックアウトせずにサブモジュール内で変更を行ってコミットした場合、 &lt;code&gt;git submodule update&lt;/code&gt; を実行するのは安全ではありません。それらは黙って上書きされます：</target>
        </trans-unit>
        <trans-unit id="199b24a07e7c4f542f5c9b6cd233e68c58c149e6" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible to push any type of object to any namespace outside of &lt;code&gt;refs/{tags,heads}/*&lt;/code&gt;. In the case of tags and commits, these will be treated as if they were the commits inside &lt;code&gt;refs/heads/*&lt;/code&gt; for the purposes of whether the update is allowed.</source>
          <target state="translated">任意のタイプのオブジェクトを &lt;code&gt;refs/{tags,heads}/*&lt;/code&gt; 外の任意の名前空間にプッシュできます。タグとコミットの場合、更新が許可されるかどうかの目的で、これらは &lt;code&gt;refs/heads/*&lt;/code&gt; 内のコミットであるかのように扱われます。</target>
        </trans-unit>
        <trans-unit id="cd25bf8e6a6252931a48d686e2c25ca4a7c9f16e" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s probably not worth it to use this option on a given repository without running tailored performance benchmarks on it. It takes a lot more time, and the resulting space/delta optimization may or may not be worth it. Not using this at all is the right trade-off for most users and their repositories.</source>
          <target state="translated">カスタマイズされたパフォーマンスベンチマークを実行せずに、特定のリポジトリでこのオプションを使用することはおそらく価値がありません。これにはさらに多くの時間がかかり、結果として生じるスペース/デルタの最適化は価値がある場合とそうでない場合があります。これをまったく使用しないことは、ほとんどのユーザーとそのリポジトリにとって適切なトレードオフです。</target>
        </trans-unit>
        <trans-unit id="6c2d9fe7b4d73e7c5f324adf6070448f4f753fb5" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s reasonable to e.g. configure &lt;code&gt;fetch.pruneTags=true&lt;/code&gt; in &lt;code&gt;~/.gitconfig&lt;/code&gt; to have tags pruned whenever &lt;code&gt;git fetch --prune&lt;/code&gt; is run, without making every invocation of &lt;code&gt;git fetch&lt;/code&gt; without &lt;code&gt;--prune&lt;/code&gt; an error.</source>
          <target state="translated">これは、例えばのconfigureに合理的だ &lt;code&gt;fetch.pruneTags=true&lt;/code&gt; で &lt;code&gt;~/.gitconfig&lt;/code&gt; たび剪定タグを持っている &lt;code&gt;git fetch --prune&lt;/code&gt; のすべての呼び出しにすることなく、実行された &lt;code&gt;git fetch&lt;/code&gt; なし &lt;code&gt;--prune&lt;/code&gt; エラー。</target>
        </trans-unit>
        <trans-unit id="bb5eba09f5b7ed44896e1f2e304b6636d8012774" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s tempting to try to use certain features of &lt;code&gt;git update-index&lt;/code&gt;, namely the assume-unchanged and skip-worktree bits, but these don&amp;rsquo;t work properly for this purpose and shouldn&amp;rsquo;t be used this way.</source>
          <target state="translated">&lt;code&gt;git update-index&lt;/code&gt; の特定の機能、つまり、assume-unchangedビットとskip-worktreeビットを使用しようとするのは魅力的ですが、これらはこの目的では適切に機能しないため、このように使用しないでください。</target>
        </trans-unit>
        <trans-unit id="b2ec8a66f406e3cd9a737fd2597d771efa24775d" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s usually much more common that you merge with somebody else than merging with your own branches, so it&amp;rsquo;s worth pointing out that Git makes that very easy too, and in fact, it&amp;rsquo;s not that different from doing a &lt;code&gt;git merge&lt;/code&gt;. In fact, a remote merge ends up being nothing more than &quot;fetch the work from a remote repository into a temporary tag&quot; followed by a &lt;code&gt;git merge&lt;/code&gt;.</source>
          <target state="translated">通常、自分のブランチとマージするよりも他の人とマージする方がはるかに一般的です。そのため、Gitを使用することも非常に簡単であり、実際には &lt;code&gt;git merge&lt;/code&gt; を実行することとそれほど変わりません。実際、リモートマージは、「リモートリポジトリから一時的なタグに作業をフェッチする」にすぎず、その後に &lt;code&gt;git merge&lt;/code&gt; 続きます。</target>
        </trans-unit>
        <trans-unit id="09aeea995eee0f7341283401be15ea3abb990fd5" translate="yes" xml:space="preserve">
          <source>Iterate over all refs that match &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; and show them according to the given &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt;, after sorting them according to the given set of &lt;code&gt;&amp;lt;key&amp;gt;&lt;/code&gt;. If &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt; is given, stop after showing that many refs. The interpolated values in &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; can optionally be quoted as string literals in the specified host language allowing their direct evaluation in that language.</source>
          <target state="translated">&lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; に一致するすべての参照を反復処理し、指定された &lt;code&gt;&amp;lt;key&amp;gt;&lt;/code&gt; のセットに従って並べ替えた後、指定された &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; に従ってそれらを表示します。 &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt; が指定されている場合は、その数の参照を表示した後に停止します。 &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; の補間値は、オプションで、指定されたホスト言語の文字列リテラルとして引用でき、その言語で直接評価できます。</target>
        </trans-unit>
        <trans-unit id="ddf6f030820afdde653bed6b6ae7f0e48144f06d" translate="yes" xml:space="preserve">
          <source>Join two or more development histories together</source>
          <target state="translated">2つ以上の開発履歴を一緒に結合する</target>
        </trans-unit>
        <trans-unit id="045fff3a75d61e019edb089792c9fca9353d7073" translate="yes" xml:space="preserve">
          <source>Just as the filesystem &lt;code&gt;.&lt;/code&gt; (period) refers to the current directory, using a &lt;code&gt;.&lt;/code&gt; as a repository name in Git (a dot-repository) is a relative path and means your current repository.</source>
          <target state="translated">ファイルシステムと同じように &lt;code&gt;.&lt;/code&gt; （ピリオド）は、を使用して現在のディレクトリを参照し &lt;code&gt;.&lt;/code&gt; Gitのリポジトリ名（ドットリポジトリ）は相対パスであり、現在のリポジトリを意味します。</target>
        </trans-unit>
        <trans-unit id="dec0baabf794bebc3957d3bc4ac6d462cd46c778" translate="yes" xml:space="preserve">
          <source>Just doing &lt;code&gt;git checkout-index&lt;/code&gt; does nothing. You probably meant &lt;code&gt;git checkout-index -a&lt;/code&gt;. And if you want to force it, you want &lt;code&gt;git checkout-index -f -a&lt;/code&gt;.</source>
          <target state="translated">ただ、やって &lt;code&gt;git checkout-index&lt;/code&gt; 何もしません。おそらく &lt;code&gt;git checkout-index -a&lt;/code&gt; を意味します。強制したい場合は、 &lt;code&gt;git checkout-index -f -a&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="af0df6a1820c3268e00c2212c3d633096817d6ad" translate="yes" xml:space="preserve">
          <source>Just in case you are doing something exotic, it should be noted that all of the &amp;lt;commit&amp;gt; in the above description, except in the &lt;code&gt;--merge-base&lt;/code&gt; case and in the last two forms that use &lt;code&gt;..&lt;/code&gt; notations, can be any &amp;lt;tree&amp;gt;.</source>
          <target state="translated">エキゾチックなことをしている場合に備えて、上記の説明のすべての&amp;lt;commit&amp;gt;は、 &lt;code&gt;--merge-base&lt;/code&gt; 場合と、 &lt;code&gt;..&lt;/code&gt; 表記を使用する最後の2つの形式を除いて、任意の&amp;lt;にすることができることに注意してください。ツリー&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="4909a5e9d012cc77cb3f33966c75c24bd556a2c1" translate="yes" xml:space="preserve">
          <source>Just in case you are doing something exotic, it should be noted that all of the &amp;lt;commit&amp;gt; in the above description, except in the last two forms that use &quot;..&quot; notations, can be any &amp;lt;tree&amp;gt;.</source>
          <target state="translated">何かエキゾチックなことをしている場合に備えて、「..」表記を使用する最後の2つの形式を除いて、上記の説明のすべての&amp;lt;commit&amp;gt;は任意の&amp;lt;tree&amp;gt;であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="4be9ee55a1cb0649bc08a5f7fcba1609e56fcabe" translate="yes" xml:space="preserve">
          <source>Just like &lt;code&gt;push&lt;/code&gt;, a batch sequence of one or more &lt;code&gt;import&lt;/code&gt; is terminated with a blank line. For each batch of &lt;code&gt;import&lt;/code&gt;, the remote helper should produce a fast-import stream terminated by a &lt;code&gt;done&lt;/code&gt; command.</source>
          <target state="translated">&lt;code&gt;push&lt;/code&gt; と同様に、1つ以上の &lt;code&gt;import&lt;/code&gt; バッチシーケンスは空白行で終了します。 &lt;code&gt;import&lt;/code&gt; バッチごとに、リモートヘルパーは、 &lt;code&gt;done&lt;/code&gt; コマンドで終了する高速インポートストリームを生成する必要があります。</target>
        </trans-unit>
        <trans-unit id="586f68de6dc69eba27bb1d4e9d9bb6d0f56b4317" translate="yes" xml:space="preserve">
          <source>Just make sure to disable line wrapping in the email client (GMail&amp;rsquo;s web interface will wrap lines no matter what, so you need to use a real IMAP client).</source>
          <target state="translated">メールクライアントで行の折り返しを無効にしてください（GMailのウェブインターフェースは何があっても行を折り返すため、実際のIMAPクライアントを使用する必要があります）。</target>
        </trans-unit>
        <trans-unit id="40ff32435dadcaf90c9ed938f5946c67e774e649" translate="yes" xml:space="preserve">
          <source>Just make sure to disable line wrapping in the email client (Gmail&amp;rsquo;s web interface will wrap lines no matter what, so you need to use a real IMAP client).</source>
          <target state="translated">電子メールクライアントで行の折り返しを無効にしてください（GmailのWebインターフェイスは何があっても行を折り返すため、実際のIMAPクライアントを使用する必要があります）。</target>
        </trans-unit>
        <trans-unit id="a7ee38bb7be4fc44198cb2685d9601dcf2b9f569" translate="yes" xml:space="preserve">
          <source>K</source>
          <target state="translated">K</target>
        </trans-unit>
        <trans-unit id="b97e8895c584b11a83b65d2dacb8c53b7178dd19" translate="yes" xml:space="preserve">
          <source>KMail</source>
          <target state="translated">KMail</target>
        </trans-unit>
        <trans-unit id="2341c447151da84825db8427aea972cadd7288d2" translate="yes" xml:space="preserve">
          <source>Keep a list of repositories you work with regularly:</source>
          <target state="translated">定期的に作業するリポジトリのリストを保管しておきましょう。</target>
        </trans-unit>
        <trans-unit id="2367d7104c669108a5a4faee96aaf23e4129a768" translate="yes" xml:space="preserve">
          <source>Keep changes in working tree while discarding some previous commits</source>
          <target state="translated">以前のコミットをいくつか破棄しながら、作業ツリーの変更を保持</target>
        </trans-unit>
        <trans-unit id="efc112fed108eb2af53bef134295307559c52881" translate="yes" xml:space="preserve">
          <source>Keep downloaded pack.</source>
          <target state="translated">ダウンロードしたパックを保持します。</target>
        </trans-unit>
        <trans-unit id="9b356018df37cea79789cf69374ce84ecae93c35" translate="yes" xml:space="preserve">
          <source>Keep in mind that the &lt;code&gt;*&lt;/code&gt; (asterisk) wildcard of the local ref (right of the &lt;code&gt;:&lt;/code&gt;) &lt;strong&gt;must&lt;/strong&gt; be the farthest right path component; however the remote wildcard may be anywhere as long as it&amp;rsquo;s an independent path component (surrounded by &lt;code&gt;/&lt;/code&gt; or EOL). This type of configuration is not automatically created by &lt;code&gt;init&lt;/code&gt; and should be manually entered with a text-editor or using &lt;code&gt;git config&lt;/code&gt;.</source>
          <target state="translated">ことを覚えておいてください &lt;code&gt;*&lt;/code&gt; （右のローカル参照の（アスタリスク）ワイルドカード &lt;code&gt;:&lt;/code&gt; ）&lt;strong&gt;しなければならない&lt;/strong&gt;最右パスコンポーネントであること。ただし、リモートワイルドカードは、独立したパスコンポーネント（ &lt;code&gt;/&lt;/code&gt; またはEOLで囲まれている）であればどこでもかまいません。このタイプの構成は、 &lt;code&gt;init&lt;/code&gt; によって自動的に作成されるものではないため、テキストエディターまたは &lt;code&gt;git config&lt;/code&gt; を使用して手動で入力する必要があります。</target>
        </trans-unit>
        <trans-unit id="f28d8482458ad8eaca4da9ce6d9f18435a267b61" translate="yes" xml:space="preserve">
          <source>Keep repeating the process: compile the tree, test it, and depending on whether it is good or bad run &lt;code&gt;git bisect good&lt;/code&gt; or &lt;code&gt;git bisect bad&lt;/code&gt; to ask for the next commit that needs testing.</source>
          <target state="translated">プロセスを繰り返し続けます。ツリーをコンパイルしてテストし、それが良いか悪いかによって &lt;code&gt;git bisect good&lt;/code&gt; または &lt;code&gt;git bisect bad&lt;/code&gt; を実行して、テストが必要な次のコミットを要求します。</target>
        </trans-unit>
        <trans-unit id="4faf21022722c230f52c5287ce302764467e820e" translate="yes" xml:space="preserve">
          <source>Keep the commits that do not change anything from its parents in the result.</source>
          <target state="translated">結果的に親から何も変わらないコミットを維持します。</target>
        </trans-unit>
        <trans-unit id="ea4937dada87f98e69877594a5bd03ebc5a4fc74" translate="yes" xml:space="preserve">
          <source>Keep the current index contents, and read the contents of the named tree-ish under the directory at &lt;code&gt;&amp;lt;prefix&amp;gt;&lt;/code&gt;. The command will refuse to overwrite entries that already existed in the original index file.</source>
          <target state="translated">現在のインデックスの内容を保持し、 &lt;code&gt;&amp;lt;prefix&amp;gt;&lt;/code&gt; のディレクトリにある名前付きtree-ishの内容を読み取ります。このコマンドは、元のインデックスファイルにすでに存在するエントリの上書きを拒否します。</target>
        </trans-unit>
        <trans-unit id="d737c66ea055bf55ed844d15e52460a96096a67f" translate="yes" xml:space="preserve">
          <source>Keep the version from your branch in the work tree, but leave the path in the conflicted state for the user to sort out.</source>
          <target state="translated">ブランチのバージョンは作業ツリーに残しておきますが、パスはユーザーが整理できるように競合状態のままにしておきます。</target>
        </trans-unit>
        <trans-unit id="f9e507eaf43dc998f773c565be5cccbd49c418b4" translate="yes" xml:space="preserve">
          <source>Keep the working tree locked after creation. This is the equivalent of &lt;code&gt;git worktree lock&lt;/code&gt; after &lt;code&gt;git worktree add&lt;/code&gt;, but without a race condition.</source>
          <target state="translated">作成後は、作業ツリーをロックしたままにします。これは相当である &lt;code&gt;git worktree lock&lt;/code&gt; 後 &lt;code&gt;git worktree add&lt;/code&gt; が、競合状態なし。</target>
        </trans-unit>
        <trans-unit id="95e57eb6304d53fb35eb7b893fc3d7458db2c90c" translate="yes" xml:space="preserve">
          <source>Keep the working tree locked after creation. This is the equivalent of &lt;code&gt;git worktree lock&lt;/code&gt; after &lt;code&gt;git worktree add&lt;/code&gt;, but without race condition.</source>
          <target state="translated">作成後、作業ツリーをロックしたままにします。これは &lt;code&gt;git worktree add&lt;/code&gt; の後の &lt;code&gt;git worktree lock&lt;/code&gt; と同等ですが、競合状態はありません。</target>
        </trans-unit>
        <trans-unit id="b288ae9d082d21fcccb8cbea92de9e2fd90c35f9" translate="yes" xml:space="preserve">
          <source>Keep unreachable objects in loose form. This implies &lt;code&gt;--revs&lt;/code&gt;.</source>
          <target state="translated">到達不能な物体はゆるい形で保管してください。これは &lt;code&gt;--revs&lt;/code&gt; を意味します。</target>
        </trans-unit>
        <trans-unit id="5fef7648dce54325886b4bd2e05123b8e3f3ba8b" translate="yes" xml:space="preserve">
          <source>Keep working in your primary repository. Your changes include modifications of your own, patches you receive via e-mails, and merges resulting from pulling the &quot;public&quot; repositories of your &quot;project lead&quot; and possibly your &quot;sub-subsystem maintainers&quot;.</source>
          <target state="translated">プライマリリポジトリで作業を続けてください。あなたの変更には、あなた自身の変更、電子メールで受け取ったパッチ、あなたの &quot;プロジェクトリーダー &quot;や場合によっては &quot;サブサブシステムメンテナ &quot;の &quot;公開 &quot;リポジトリを引っ張ってきた結果のマージなどが含まれます。</target>
        </trans-unit>
        <trans-unit id="ca6eb7beb12ef44a32102578e1d606b2be688242" translate="yes" xml:space="preserve">
          <source>Keep working in your primary repository. Your changes include modifications of your own, patches you receive via e-mails, and merges resulting from pulling the &quot;public&quot; repositories of your &quot;subsystem maintainers&quot;.</source>
          <target state="translated">プライマリリポジトリで作業を続けてください。あなたの変更には、あなた自身の変更、電子メールで受け取ったパッチ、あなたの「サブシステムメンテナ」の「公開」リポジトリを引っ張ってきた結果のマージが含まれます。</target>
        </trans-unit>
        <trans-unit id="04e2360cc7b28c2ccb26642bb98ceb0fcbba2f5a" translate="yes" xml:space="preserve">
          <source>Keeping a patch series up to date using git rebase</source>
          <target state="translated">git rebase を使ってパッチシリーズを最新の状態に保つ</target>
        </trans-unit>
        <trans-unit id="b81b785228a23fa6b75a5abffb474819b40a8136" translate="yes" xml:space="preserve">
          <source>Kill keywords: will extract files with &lt;code&gt;-kk&lt;/code&gt; from the CVS archive to avoid noisy changesets. Highly recommended, but off by default to preserve compatibility with early imported trees.</source>
          <target state="translated">キーワードの削除：ノイズの多い変更セットを回避するために、CVSアーカイブから &lt;code&gt;-kk&lt;/code&gt; でファイルを抽出します。強くお勧めしますが、初期にインポートされたツリーとの互換性を維持するためにデフォルトではオフになっています。</target>
        </trans-unit>
        <trans-unit id="02658e782a0ecc008f0ca6ffc2a20f7bdbee96d7" translate="yes" xml:space="preserve">
          <source>Label for the &quot;home link&quot; at the top of all pages, leading to &lt;code&gt;$home_link&lt;/code&gt; (usually the main gitweb page, which contains the projects list). It is used as the first component of gitweb&amp;rsquo;s &quot;breadcrumb trail&quot;: &lt;code&gt;&amp;lt;home link&amp;gt; / &amp;lt;project&amp;gt; / &amp;lt;action&amp;gt;&lt;/code&gt;. Can be set at build time using the &lt;code&gt;GITWEB_HOME_LINK_STR&lt;/code&gt; variable. By default it is set to &quot;projects&quot;, as this link leads to the list of projects. Another popular choice is to set it to the name of site. Note that it is treated as raw HTML so it should not be set from untrusted sources.</source>
          <target state="translated">すべてのページの上部にある「ホームリンク」のラベル。 &lt;code&gt;$home_link&lt;/code&gt; （通常、プロジェクトリストを含むメインのgitwebページ）につながります。 gitwebの「パンくずリスト」の最初のコンポーネントとして使用されます： &lt;code&gt;&amp;lt;home link&amp;gt; / &amp;lt;project&amp;gt; / &amp;lt;action&amp;gt;&lt;/code&gt; 。ビルド時に &lt;code&gt;GITWEB_HOME_LINK_STR&lt;/code&gt; 変数を使用して設定できます。このリンクはプロジェクトのリストにつながるため、デフォルトでは「プロジェクト」に設定されています。もう1つの一般的な選択は、サイトの名前に設定することです。未加工のHTMLとして扱われるため、信頼できないソースから設定しないでください。</target>
        </trans-unit>
        <trans-unit id="f135ec40c7a65e232b6284c7eadaae14bc4ec8e7" translate="yes" xml:space="preserve">
          <source>Labelling of conflicts markers</source>
          <target state="translated">競合マーカーのラベリング</target>
        </trans-unit>
        <trans-unit id="19b52717c24503e82535f1da97544e03ef42f759" translate="yes" xml:space="preserve">
          <source>Large projects are often composed of smaller, self-contained modules. For example, an embedded Linux distribution&amp;rsquo;s source tree would include every piece of software in the distribution with some local modifications; a movie player might need to build against a specific, known-working version of a decompression library; several independent programs might all share the same build scripts.</source>
          <target state="translated">大規模なプロジェクトは、多くの場合、小さな自己完結型のモジュールで構成されています。たとえば、組み込みLinuxディストリビューションのソースツリーには、ディストリビューション内のすべてのソフトウェアが含まれ、ローカルに変更が加えられます。映画プレーヤーは、解凍ライブラリの特定の既知のバージョンに対してビルドする必要があるかもしれません。複数の独立したプログラムがすべて同じビルドスクリプトを共有する場合があります。</target>
        </trans-unit>
        <trans-unit id="eebf4c31734b36e391dbec8f9bdc861cf73858fc" translate="yes" xml:space="preserve">
          <source>Later, Bob can update his repo with Alice&amp;rsquo;s latest changes using</source>
          <target state="translated">その後、ボブはアリスの最新の変更でリポジトリを更新できます。</target>
        </trans-unit>
        <trans-unit id="b67e320eff785b446a82207f60f64bae4d9398b2" translate="yes" xml:space="preserve">
          <source>Later, you can see whether your changes have been applied by saying (still on &lt;code&gt;topic&lt;/code&gt;):</source>
          <target state="translated">後で、次のように言うことで変更が適用されたかどうかを確認できます（まだ &lt;code&gt;topic&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="0c480c6f24e2582817904a3ca717bfe059eaf9ba" translate="yes" xml:space="preserve">
          <source>Leading &lt;code&gt;Re:&lt;/code&gt;, &lt;code&gt;re:&lt;/code&gt;, and &lt;code&gt;:&lt;/code&gt;.</source>
          <target state="translated">リーディング &lt;code&gt;Re:&lt;/code&gt; 、 &lt;code&gt;re:&lt;/code&gt; 、 &lt;code&gt;:&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6cba31f4e857a58fc5d56324b4f5b7ba501d5431" translate="yes" xml:space="preserve">
          <source>Leading and trailing whitespace are ignored.</source>
          <target state="translated">先頭と末尾の空白は無視されます。</target>
        </trans-unit>
        <trans-unit id="9400d93a0e4bf560ae2ff2a8521028a1c12485de" translate="yes" xml:space="preserve">
          <source>Leading and trailing whitespace.</source>
          <target state="translated">先頭と末尾の空白。</target>
        </trans-unit>
        <trans-unit id="b0ca289dea1d9e545043917d0313a90afe03b7b2" translate="yes" xml:space="preserve">
          <source>Leading bracketed strings (between &lt;code&gt;[&lt;/code&gt; and &lt;code&gt;]&lt;/code&gt;, usually &lt;code&gt;[PATCH]&lt;/code&gt;).</source>
          <target state="translated">先頭の括弧で囲まれた文字列（ &lt;code&gt;[&lt;/code&gt; と &lt;code&gt;]&lt;/code&gt; の間、通常 &lt;code&gt;[PATCH]&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="7f2cfa3cf0fb13a4db7434c1da2b8c70142683de" translate="yes" xml:space="preserve">
          <source>Leaving this value at the default size is fine unless you know that either the remote server or a proxy in the middle doesn&amp;rsquo;t support HTTP/1.1 (which introduced the chunked transfer encoding) or is known to be broken with chunked data. This is often (erroneously) suggested as a solution for generic push problems, but since almost every server and proxy supports at least HTTP/1.1, raising this value usually doesn&amp;rsquo;t solve most push problems. A server or proxy that didn&amp;rsquo;t correctly support HTTP/1.1 and chunked transfer encoding wouldn&amp;rsquo;t be that useful on the Internet today, since it would break lots of traffic.</source>
          <target state="translated">リモートサーバーまたは中間のプロキシがHTTP / 1.1（チャンク転送エンコーディングを導入）をサポートしていないか、チャンクデータで壊れていることがわかっている場合を除いて、この値をデフォルトサイズのままにしておくことは問題ありません。これは、一般的なプッシュの問題の解決策として（誤って）提案されることがよくありますが、ほとんどすべてのサーバーとプロキシが少なくともHTTP / 1.1をサポートしているため、この値を上げてもほとんどのプッシュの問題は解決されません。 HTTP / 1.1とチャンク転送エンコーディングを正しくサポートしていなかったサーバーまたはプロキシは、大量のトラフィックを遮断するため、今日のインターネットではそれほど有用ではありません。</target>
        </trans-unit>
        <trans-unit id="c5fae931542a3559bb8c0d5b861a24e60a1ac67c" translate="yes" xml:space="preserve">
          <source>Left-, middle-, or right-align the content between %(align:&amp;hellip;​) and %(end). The &quot;align:&quot; is followed by &lt;code&gt;width=&amp;lt;width&amp;gt;&lt;/code&gt; and &lt;code&gt;position=&amp;lt;position&amp;gt;&lt;/code&gt; in any order separated by a comma, where the &lt;code&gt;&amp;lt;position&amp;gt;&lt;/code&gt; is either left, right or middle, default being left and &lt;code&gt;&amp;lt;width&amp;gt;&lt;/code&gt; is the total length of the content with alignment. For brevity, the &quot;width=&quot; and/or &quot;position=&quot; prefixes may be omitted, and bare &amp;lt;width&amp;gt; and &amp;lt;position&amp;gt; used instead. For instance, &lt;code&gt;%(align:&amp;lt;width&amp;gt;,&amp;lt;position&amp;gt;)&lt;/code&gt;. If the contents length is more than the width then no alignment is performed. If used with &lt;code&gt;--quote&lt;/code&gt; everything in between %(align:&amp;hellip;​) and %(end) is quoted, but if nested then only the topmost level performs quoting.</source>
          <target state="translated">％（align：&amp;hellip;）と％（end）の間でコンテンツを左揃え、中央揃え、または右揃えします。 「align：」の後には、カンマで区切られた任意の順序で &lt;code&gt;width=&amp;lt;width&amp;gt;&lt;/code&gt; と &lt;code&gt;position=&amp;lt;position&amp;gt;&lt;/code&gt; が続きます。 &lt;code&gt;&amp;lt;position&amp;gt;&lt;/code&gt; は左、右、または中央のいずれかで、デフォルトは左で、 &lt;code&gt;&amp;lt;width&amp;gt;&lt;/code&gt; は合計です配置されたコンテンツの長さ。簡潔にするために、「width =」および/または「position =」プレフィックスを省略し、代わりに裸の&amp;lt;width&amp;gt;と&amp;lt;position&amp;gt;を使用できます。たとえば、 &lt;code&gt;%(align:&amp;lt;width&amp;gt;,&amp;lt;position&amp;gt;)&lt;/code&gt; 。内容の長さが幅より大きい場合、位置合わせは行われません。 &lt;code&gt;--quote&lt;/code&gt; とともに使用すると、％（align：&amp;hellip;）と％（end）の間のすべてが引用されます。ただし、ネストされている場合は、最上位レベルのみが引用を実行します。</target>
        </trans-unit>
        <trans-unit id="4913da5c2a93f28cfca5df10654d75686a764062" translate="yes" xml:space="preserve">
          <source>Legacy alias for &lt;code&gt;--smtp-encryption ssl&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--smtp-encryption ssl&lt;/code&gt; のレガシーエイリアス。</target>
        </trans-unit>
        <trans-unit id="8c79d7d578b1dfedd061424fe06d7bbd7bf7860a" translate="yes" xml:space="preserve">
          <source>Legacy monitoring operations are not supported (edit, watch and related). Exports and tagging (tags and branches) are not supported at this stage.</source>
          <target state="translated">レガシー監視操作(編集、ウォッチ、関連)はサポートされていません。エクスポートとタグ付け(タグとブランチ)は現段階ではサポートされていません。</target>
        </trans-unit>
        <trans-unit id="efdb524a0ef0e2256e12ca50686b4d8bc222c208" translate="yes" xml:space="preserve">
          <source>Lesson three is: study the code. Really, it is the best way to learn about the organization of Git (after you know the basic concepts).</source>
          <target state="translated">レッスン3は、コードを勉強することです。本当に、(基本的な概念を知った上で)Gitの組織を学ぶには最適な方法です。</target>
        </trans-unit>
        <trans-unit id="893b35eb2ef36c307a5615060033f2510cf02d9b" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s also suppose that we have a cleaned up graph like one after step 1) in the bisection algorithm above. This means that we can measure the information we get in terms of number of commit we can remove from the graph..</source>
          <target state="translated">上記の二分法アルゴリズムのステップ1）の後のようなクリーンアップされたグラフがあると仮定しましょう。これは、グラフから削除できるコミット数の観点から取得した情報を測定できることを意味します。</target>
        </trans-unit>
        <trans-unit id="c8d0e17bfd7a63329a6082665d278b7fb499b0b6" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s skip over the obvious details; the only really interesting part here is the call to &lt;code&gt;get_sha1()&lt;/code&gt;. It tries to interpret &lt;code&gt;argv[2]&lt;/code&gt; as an object name, and if it refers to an object which is present in the current repository, it writes the resulting SHA-1 into the variable &lt;code&gt;sha1&lt;/code&gt;.</source>
          <target state="translated">明らかな詳細はスキップしてみましょう。ここで唯一興味深い部分は、 &lt;code&gt;get_sha1()&lt;/code&gt; の呼び出しです。 &lt;code&gt;argv[2]&lt;/code&gt; をオブジェクト名として解釈しようとし、現在のリポジトリに存在するオブジェクトを参照している場合は、結果のSHA-1を変数 &lt;code&gt;sha1&lt;/code&gt; に書き込みます。</target>
        </trans-unit>
        <trans-unit id="cc9abf37f1be76cb29eb48ded27f1fe2938a8b22" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start a new project and create a small amount of history:</source>
          <target state="translated">新しいプロジェクトを開始して、少量の履歴を作成してみましょう。</target>
        </trans-unit>
        <trans-unit id="f0d62f9783a955198cc607ca11b36e935a346c02" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take the following graph as an example:</source>
          <target state="translated">例として次のグラフを見てみましょう：</target>
        </trans-unit>
        <trans-unit id="1c0b60e2ec5a47fbbf8d5055a8c4fd552a20bdbd" translate="yes" xml:space="preserve">
          <source>Lets you rewrite Git revision history by rewriting the branches mentioned in the &amp;lt;rev-list options&amp;gt;, applying custom filters on each revision. Those filters can modify each tree (e.g. removing a file or running a perl rewrite on all files) or information about each commit. Otherwise, all information (including original commit times or merge information) will be preserved.</source>
          <target state="translated">各リビジョンにカスタムフィルターを適用して、&amp;lt;rev-list options&amp;gt;に記載されているブランチを書き換えることで、Gitリビジョン履歴を書き換えることができます。これらのフィルターは、各ツリー（ファイルの削除やすべてのファイルでperlの書き換えを実行するなど）または各コミットに関する情報を変更できます。それ以外の場合は、すべての情報（元のコミット時間またはマージ情報を含む）が保持されます。</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">MITライセンスに基づいてライセンスされています。</target>
        </trans-unit>
        <trans-unit id="8a762e028503c19597a52f977263fd61a8df56e0" translate="yes" xml:space="preserve">
          <source>Lighttpd</source>
          <target state="translated">Lighttpd</target>
        </trans-unit>
        <trans-unit id="c20b9e30add4d8fcb9e944c3a79357b0eb58faf9" translate="yes" xml:space="preserve">
          <source>Like --allow-empty this command is primarily for use by foreign SCM interface scripts. It allows you to create a commit with an empty commit message without using plumbing commands like &lt;a href=&quot;git-commit-tree&quot;&gt;git-commit-tree[1]&lt;/a&gt;.</source>
          <target state="translated">--allow-emptyと同様に、このコマンドは主に外部SCMインターフェーススクリプトで使用するためのものです。&lt;a href=&quot;git-commit-tree&quot;&gt;git-commit-tree [1]の&lt;/a&gt;ような配管コマンドを使用せずに、空のコミットメッセージでコミットを作成できます。</target>
        </trans-unit>
        <trans-unit id="5f6f49e5a6f1778648e9730643fd43474f2dbc13" translate="yes" xml:space="preserve">
          <source>Like --get-all, but interprets the name as a regular expression and writes out the key names. Regular expression matching is currently case-sensitive and done against a canonicalized version of the key in which section and variable names are lowercased, but subsection names are not.</source>
          <target state="translated">これは --get-all と似ていますが、名前を正規表現として解釈し、キー名を書き出します。正規表現のマッチングは現在のところ大文字小文字を区別しており、セクション名と変数名は小文字になりますが、 サブセクション名は小文字になりません。</target>
        </trans-unit>
        <trans-unit id="f93e6625e77c19d6664d2e45faf25a33780dbe37" translate="yes" xml:space="preserve">
          <source>Like --import-marks but instead of erroring out, silently skips the file if it does not exist.</source>
          <target state="translated">import-marks と似ていますが、エラーアウトする代わりに、ファイルが存在しない場合は黙ってスキップします。</target>
        </trans-unit>
        <trans-unit id="0eda32196b28e34b5200ae38915b28d72ba0802b" translate="yes" xml:space="preserve">
          <source>Like --import-marks except in two respects: first, only one &quot;feature import-marks&quot; or &quot;feature import-marks-if-exists&quot; command is allowed per stream; second, an --import-marks= or --import-marks-if-exists command-line option overrides any of these &quot;feature&quot; commands in the stream; third, &quot;feature import-marks-if-exists&quot; like a corresponding command-line option silently skips a nonexistent file.</source>
          <target state="translated">2つの点を除いて --import-marks と似ているが、1つ目はストリームごとに1つの &quot;feature import-marks&quot; または &quot;feature import-marks-if-exists&quot; コマンドのみが許可されていること、2つ目は --import-marks=または --import-marks-if-exists コマンドラインオプションがストリーム内のこれらの &quot;feature&quot; コマンドのいずれかを上書きすること、3つ目は対応するコマンドラインオプションのような &quot;feature import-marks-if-exists&quot; が存在しないファイルを静かにスキップすること。</target>
        </trans-unit>
        <trans-unit id="ea166a12e166b75ad46458f975797a03647dc62d" translate="yes" xml:space="preserve">
          <source>Like --keep create a .keep file before moving the index into its final destination, but rather than creating an empty file place &lt;code&gt;&amp;lt;msg&amp;gt;&lt;/code&gt; followed by an LF into the .keep file. The &lt;code&gt;&amp;lt;msg&amp;gt;&lt;/code&gt; message can later be searched for within all .keep files to locate any which have outlived their usefulness.</source>
          <target state="translated">--keepと同様に、インデックスを最終的な宛先に移動する前に.keepファイルを作成しますが、空のファイルを作成するのではなく、 &lt;code&gt;&amp;lt;msg&amp;gt;&lt;/code&gt; に続けてLFを.keepファイルに配置します。 &lt;code&gt;&amp;lt;msg&amp;gt;&lt;/code&gt; メッセージは、後でその有用性をより長生きしているいずれかを見つけるために、すべての.keepファイル内で検索することができます。</target>
        </trans-unit>
        <trans-unit id="da58772c0d323657b31dd0d6c68daa01b72022dc" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;--cherry-pick&lt;/code&gt; (see below) but mark equivalent commits with &lt;code&gt;=&lt;/code&gt; rather than omitting them, and inequivalent ones with &lt;code&gt;+&lt;/code&gt;.</source>
          <target state="translated">同様 &lt;code&gt;--cherry-pick&lt;/code&gt; （下記参照）が、と同等のコミットマーク &lt;code&gt;=&lt;/code&gt; のではなく、それらを省略し、と非等価もの &lt;code&gt;+&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="18b014ee75198b1ce501d5b1546fe06cd49ddd23" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;--git-dir&lt;/code&gt;, but its output is always the canonicalized absolute path.</source>
          <target state="translated">同様 &lt;code&gt;--git-dir&lt;/code&gt; のが、その出力は常に正規化絶対パスです。</target>
        </trans-unit>
        <trans-unit id="af1d4315bb510027eb7e61b588f2b477e26e55d4" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;--refresh&lt;/code&gt;, but checks stat information unconditionally, without regard to the &quot;assume unchanged&quot; setting.</source>
          <target state="translated">同様 &lt;code&gt;--refresh&lt;/code&gt; が、無条件にチェックSTAT情報、「変わらないと仮定」の設定に関係なく。</target>
        </trans-unit>
        <trans-unit id="649d7b810a2269259a3e3571033e0da598ccd04e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;-C&lt;/code&gt;, but with &lt;code&gt;-c&lt;/code&gt; the editor is invoked, so that the user can further edit the commit message.</source>
          <target state="translated">&lt;code&gt;-C&lt;/code&gt; と似ていますが、 &lt;code&gt;-c&lt;/code&gt; を指定するとエディターが呼び出されるため、ユーザーはコミットメッセージをさらに編集できます。</target>
        </trans-unit>
        <trans-unit id="72f500fc1c4bd05ad014fbedf9cd9b9fb51f168b" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;-C&lt;/code&gt;, but with &lt;code&gt;-c&lt;/code&gt; the editor is invoked, so that the user can further edit the note message.</source>
          <target state="translated">&lt;code&gt;-C&lt;/code&gt; と似ていますが、 &lt;code&gt;-c&lt;/code&gt; を指定するとエディターが呼び出されるため、ユーザーはメモメッセージをさらに編集できます。</target>
        </trans-unit>
        <trans-unit id="f749f3d3ddfe6600b3752ee19e4bd9b6731f362f" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;email&lt;/code&gt;, but lines in the commit message starting with &quot;From &quot; (preceded by zero or more &quot;&amp;gt;&quot;) are quoted with &quot;&amp;gt;&quot; so they aren&amp;rsquo;t confused as starting a new commit.</source>
          <target state="translated">&lt;code&gt;email&lt;/code&gt; と同様ですが、コミットメッセージの「From」で始まる行（前に0個以上の「&amp;gt;」が付いている）は「&amp;gt;」で引用されているため、新しいコミットの開始と混同されることはありません。</target>
        </trans-unit>
        <trans-unit id="5f2734a31de3aa99c55dc536f672e3afeacd6e67" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; this variable has corresponding &lt;code&gt;receive.fsck.skipList&lt;/code&gt; and &lt;code&gt;fetch.fsck.skipList&lt;/code&gt; variants.</source>
          <target state="translated">同様 &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; この変数は対応してい &lt;code&gt;receive.fsck.skipList&lt;/code&gt; と &lt;code&gt;fetch.fsck.skipList&lt;/code&gt; バリアントを。</target>
        </trans-unit>
        <trans-unit id="8f4973bf138d30d1fbff518822c72869393d6ab3" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;git push&lt;/code&gt; or &lt;code&gt;git fetch&lt;/code&gt;, imports handled by fast-import are safe to run alongside parallel &lt;code&gt;git repack -a -d&lt;/code&gt; or &lt;code&gt;git gc&lt;/code&gt; invocations, or any other Git operation (including &lt;code&gt;git prune&lt;/code&gt;, as loose objects are never used by fast-import).</source>
          <target state="translated">同様 &lt;code&gt;git push&lt;/code&gt; または &lt;code&gt;git fetch&lt;/code&gt; 高速インポートが取り扱う輸入、パラレルと一緒に実行しても安全です &lt;code&gt;git repack -a -d&lt;/code&gt; または &lt;code&gt;git gc&lt;/code&gt; 呼び出し、または任意の他のGitの操作（ &lt;code&gt;git prune&lt;/code&gt; 、緩いオブジェクトはで使用されることはありませんように高速インポート）。</target>
        </trans-unit>
        <trans-unit id="c7a0caab42cb430b8f7eb62e2b9ee91196438e5f" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;git rebase&lt;/code&gt;; this requires that the working tree be clean and have no uncommitted changes.</source>
          <target state="translated">同様に &lt;code&gt;git rebase&lt;/code&gt; 。これには、作業ツリーがクリーンで、コミットされていない変更がないことが必要です。</target>
        </trans-unit>
        <trans-unit id="94b902a35ff412729993e3558dc74f40d9a138f0" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;mailmap.file&lt;/code&gt;, but consider the value as a reference to a blob in the repository. If both &lt;code&gt;mailmap.file&lt;/code&gt; and &lt;code&gt;mailmap.blob&lt;/code&gt; are given, both are parsed, with entries from &lt;code&gt;mailmap.file&lt;/code&gt; taking precedence. In a bare repository, this defaults to &lt;code&gt;HEAD:.mailmap&lt;/code&gt;. In a non-bare repository, it defaults to empty.</source>
          <target state="translated">同様 &lt;code&gt;mailmap.file&lt;/code&gt; が、リポジトリ内のBLOBへの参照として値を検討してください。 &lt;code&gt;mailmap.file&lt;/code&gt; と &lt;code&gt;mailmap.blob&lt;/code&gt; の両方が指定されている場合は、両方が解析され、 &lt;code&gt;mailmap.file&lt;/code&gt; からのエントリが優先されます。ベアリポジトリでは、これはデフォルトで &lt;code&gt;HEAD:.mailmap&lt;/code&gt; になります。非ベアリポジトリでは、デフォルトで空になっています。</target>
        </trans-unit>
        <trans-unit id="e5b79d6b46ed0bad865e7c66642f5df5197bbc3e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;pop&lt;/code&gt;, but do not remove the state from the stash list. Unlike &lt;code&gt;pop&lt;/code&gt;, &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; may be any commit that looks like a commit created by &lt;code&gt;stash push&lt;/code&gt; or &lt;code&gt;stash create&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pop&lt;/code&gt; と同様ですが、スタッシュリストから状態を削除しません。 &lt;code&gt;pop&lt;/code&gt; とは異なり、 &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; は、 &lt;code&gt;stash push&lt;/code&gt; または &lt;code&gt;stash create&lt;/code&gt; によって作成されたコミットのように見える任意のコミットです。</target>
        </trans-unit>
        <trans-unit id="b42cf6e877b403442b6c5e230e0a3121abfa79f2" translate="yes" xml:space="preserve">
          <source>Like get, but returns all values for a multi-valued key.</source>
          <target state="translated">get と似ていますが、複数の値を持つキーのすべての値を返します。</target>
        </trans-unit>
        <trans-unit id="73701f369b01fba26e9d0bb68ef652b62a8e8ce1" translate="yes" xml:space="preserve">
          <source>Like host.example:foo/repo, but use /home/foo/.ssh/somekey as keypair and user as user on remote side. This avoids needing to edit .ssh/config.</source>
          <target state="translated">host.example:foo/repo のように、鍵ペアとして /home/foo/.ssh/somekey を、リモート側のユーザとして user を使用します。これにより、.ssh/config を編集する必要がなくなります。</target>
        </trans-unit>
        <trans-unit id="6a22ef6226883a7823ee7468ab3e5221cd1b0fcc" translate="yes" xml:space="preserve">
          <source>Like many programs that switch user id, the daemon does not reset environment variables such as &lt;code&gt;$HOME&lt;/code&gt; when it runs git programs, e.g. &lt;code&gt;upload-pack&lt;/code&gt; and &lt;code&gt;receive-pack&lt;/code&gt;. When using this option, you may also want to set and export &lt;code&gt;HOME&lt;/code&gt; to point at the home directory of &lt;code&gt;&amp;lt;user&amp;gt;&lt;/code&gt; before starting the daemon, and make sure any Git configuration files in that directory are readable by &lt;code&gt;&amp;lt;user&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">ユーザーIDを切り替える多くのプログラムと同様に、デーモンは、gitプログラムを実行するときに &lt;code&gt;$HOME&lt;/code&gt; などの環境変数をリセットしません（例： &lt;code&gt;upload-pack&lt;/code&gt; や &lt;code&gt;receive-pack&lt;/code&gt; )。このオプションを使用する場合、デーモンを開始する前に &lt;code&gt;HOME&lt;/code&gt; を設定してエクスポートし、 &lt;code&gt;&amp;lt;user&amp;gt;&lt;/code&gt; のホームディレクトリを指すようにし、そのディレクトリ内のGit構成ファイルが &lt;code&gt;&amp;lt;user&amp;gt;&lt;/code&gt; から読み取り可能であることを確認することもできます。</target>
        </trans-unit>
        <trans-unit id="955d6409ae367c03bad138119c6bf959eda46b3c" translate="yes" xml:space="preserve">
          <source>Likewise, when the &lt;code&gt;LV&lt;/code&gt; environment variable is unset, Git sets it to &lt;code&gt;-c&lt;/code&gt;. You can override this setting by exporting &lt;code&gt;LV&lt;/code&gt; with another value or setting &lt;code&gt;core.pager&lt;/code&gt; to &lt;code&gt;lv +c&lt;/code&gt;.</source>
          <target state="translated">同様に、 &lt;code&gt;LV&lt;/code&gt; 環境変数が設定されていない場合、Gitはそれを &lt;code&gt;-c&lt;/code&gt; に設定します。この設定を上書きするには、 &lt;code&gt;LV&lt;/code&gt; を別の値でエクスポートするか、 &lt;code&gt;core.pager&lt;/code&gt; を &lt;code&gt;lv +c&lt;/code&gt; 設定します。</target>
        </trans-unit>
        <trans-unit id="da647d41a556bd9f858a9fb821a95fe4fa6d0849" translate="yes" xml:space="preserve">
          <source>Limit commits to the ones touching files in the given paths. Note, to avoid ambiguity with respect to revision names use &quot;--&quot; to separate the paths from any preceding options.</source>
          <target state="translated">指定したパス内のファイルに触れるコミットを制限します。リビジョン名の曖昧さを避けるために、前のオプションとパスを区切るために &quot;--&quot; を使用することに注意してください。</target>
        </trans-unit>
        <trans-unit id="a8f6287e3aa57458fad3449d202e28c228d6d460" translate="yes" xml:space="preserve">
          <source>Limit diff output to named subtrees.</source>
          <target state="translated">diffの出力を名前付きのサブツリーに制限します。</target>
        </trans-unit>
        <trans-unit id="73ea1d1481ae126a39e8d8a25424a40b0120067c" translate="yes" xml:space="preserve">
          <source>Limit fetching to ancestor-chains not longer than n. &lt;code&gt;git-upload-pack&lt;/code&gt; treats the special depth 2147483647 as infinite even if there is an ancestor-chain that long.</source>
          <target state="translated">フェッチをn以下の祖先チェーンに制限します。 &lt;code&gt;git-upload-pack&lt;/code&gt; は、そのような祖先チェーンがある場合でも、特別な深さ2147483647を無限として扱います。</target>
        </trans-unit>
        <trans-unit id="3548328e70b776f579a206b5e26f3a2cdd3bf54c" translate="yes" xml:space="preserve">
          <source>Limit fetching to the specified number of commits from the tip of each remote branch history. If fetching to a &lt;code&gt;shallow&lt;/code&gt; repository created by &lt;code&gt;git clone&lt;/code&gt; with &lt;code&gt;--depth=&amp;lt;depth&amp;gt;&lt;/code&gt; option (see &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt;), deepen or shorten the history to the specified number of commits. Tags for the deepened commits are not fetched.</source>
          <target state="translated">各リモートブランチ履歴の先端からのフェッチを指定したコミット数に制限します。 &lt;code&gt;--depth=&amp;lt;depth&amp;gt;&lt;/code&gt; オプション（&lt;a href=&quot;git-clone&quot;&gt;git-clone [1]を&lt;/a&gt;参照）を使用して &lt;code&gt;git clone&lt;/code&gt; によって作成された &lt;code&gt;shallow&lt;/code&gt; リポジトリーにフェッチする場合は、履歴を指定したコミット数に拡張または短縮します。深められたコミットのタグはフェッチされません。</target>
        </trans-unit>
        <trans-unit id="406e704b5fa6637d1092aef900d6bea100f59424" translate="yes" xml:space="preserve">
          <source>Limit output to the one commit object which is roughly halfway between included and excluded commits. Note that the bad bisection ref &lt;code&gt;refs/bisect/bad&lt;/code&gt; is added to the included commits (if it exists) and the good bisection refs &lt;code&gt;refs/bisect/good-*&lt;/code&gt; are added to the excluded commits (if they exist). Thus, supposing there are no refs in &lt;code&gt;refs/bisect/&lt;/code&gt;, if</source>
          <target state="translated">含まれるコミットと除外されるコミットのほぼ中間にある1つのコミットオブジェクトに出力を制限します。不正な二分リファレンス &lt;code&gt;refs/bisect/bad&lt;/code&gt; が含まれているコミット（存在する場合）に追加され、正常な二分リファレンスrefs / &lt;code&gt;refs/bisect/good-*&lt;/code&gt; が除外されたコミット（存在する場合）に追加されることに注意してください。したがって、 &lt;code&gt;refs/bisect/&lt;/code&gt; に参照がない場合、</target>
        </trans-unit>
        <trans-unit id="2b149769f0e9e62c7755e40f7d9c9b100ff198f3" translate="yes" xml:space="preserve">
          <source>Limit the commits output to ones that match all given &lt;code&gt;--grep&lt;/code&gt;, instead of ones that match at least one.</source>
          <target state="translated">コミット出力を、少なくとも1つに一致するものではなく、指定されたすべての &lt;code&gt;--grep&lt;/code&gt; に一致するものに制限します。</target>
        </trans-unit>
        <trans-unit id="119c553a83e823fd710ae4f2da2e455c4cb090b7" translate="yes" xml:space="preserve">
          <source>Limit the commits output to ones with author/committer header lines that match the specified pattern (regular expression). With more than one &lt;code&gt;--author=&amp;lt;pattern&amp;gt;&lt;/code&gt;, commits whose author matches any of the given patterns are chosen (similarly for multiple &lt;code&gt;--committer=&amp;lt;pattern&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">コミット出力を、指定されたパターン（正規表現）に一致する作成者/コミッターのヘッダー行を持つものに制限します。 &lt;code&gt;--author=&amp;lt;pattern&amp;gt;&lt;/code&gt; が複数ある場合、作成者が指定されたパターンのいずれかに一致するコミットが選択されます（複数の &lt;code&gt;--committer=&amp;lt;pattern&amp;gt;&lt;/code&gt; の場合と同様に）。</target>
        </trans-unit>
        <trans-unit id="dd1c85bc38b39ba5aff2bee57d4deea0c60fd712" translate="yes" xml:space="preserve">
          <source>Limit the commits output to ones with log message that do not match the pattern specified with &lt;code&gt;--grep=&amp;lt;pattern&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--grep=&amp;lt;pattern&amp;gt;&lt;/code&gt; で指定されたパターンと一致しないログメッセージのコミット出力に制限します。</target>
        </trans-unit>
        <trans-unit id="bd9eadb3ad8dfb9ffb371dc1589fe6576ab540f4" translate="yes" xml:space="preserve">
          <source>Limit the commits output to ones with log message that matches the specified pattern (regular expression). With more than one &lt;code&gt;--grep=&amp;lt;pattern&amp;gt;&lt;/code&gt;, commits whose message matches any of the given patterns are chosen (but see &lt;code&gt;--all-match&lt;/code&gt;).</source>
          <target state="translated">コミットの出力を、指定したパターン（正規表現）に一致するログメッセージを含むものに制限します。 &lt;code&gt;--grep=&amp;lt;pattern&amp;gt;&lt;/code&gt; が複数ある場合、指定したパターンのいずれかに一致するメッセージを持つコミットが選択されます（ただし、 &lt;code&gt;--all-match&lt;/code&gt; を参照）。</target>
        </trans-unit>
        <trans-unit id="d1b86714045e4612b85a2fa8cf22123bd3513cb6" translate="yes" xml:space="preserve">
          <source>Limit the commits output to ones with reflog entries that match the specified pattern (regular expression). With more than one &lt;code&gt;--grep-reflog&lt;/code&gt;, commits whose reflog message matches any of the given patterns are chosen. It is an error to use this option unless &lt;code&gt;--walk-reflogs&lt;/code&gt; is in use.</source>
          <target state="translated">コミット出力を、指定したパターン（正規表現）に一致するreflogエントリを持つものに制限します。 &lt;code&gt;--grep-reflog&lt;/code&gt; が複数ある場合、指定したパターンのいずれかに一致するreflogメッセージを持つコミットが選択されます。 &lt;code&gt;--walk-reflogs&lt;/code&gt; が使用されていない限り、このオプションを使用するとエラーになります。</target>
        </trans-unit>
        <trans-unit id="2b5d877818bdb0956a66e366504390cf3fe65b29" translate="yes" xml:space="preserve">
          <source>Limit the commits output to specified time range.</source>
          <target state="translated">コミットの出力を指定した時間範囲に制限します。</target>
        </trans-unit>
        <trans-unit id="d8dbf5f629bd3296e9ab1177de95e69729e1d54b" translate="yes" xml:space="preserve">
          <source>Limit the displayed commits to those directly on the ancestry chain between the &amp;ldquo;from&amp;rdquo; and &amp;ldquo;to&amp;rdquo; commits in the given commit range. I.e. only display commits that are ancestor of the &amp;ldquo;to&amp;rdquo; commit and descendants of the &amp;ldquo;from&amp;rdquo; commit.</source>
          <target state="translated">表示されるコミットを、指定されたコミット範囲の「from」と「to」のコミットの間の祖先チェーン上の直接のものに制限します。つまり、「to」コミットの祖先であるコミットと「from」コミットの子孫であるコミットのみを表示します。</target>
        </trans-unit>
        <trans-unit id="ed8c2d4ed1408e7d7da83719bcf77ad7b5896ff9" translate="yes" xml:space="preserve">
          <source>Limit the number of commits imported. Workaround for cases where cvsimport leaks memory.</source>
          <target state="translated">インポートされるコミット数を制限します。cvsimport がメモリをリークする場合の回避策。</target>
        </trans-unit>
        <trans-unit id="1adada65b7a03da88bf0748c36055d961c64b07a" translate="yes" xml:space="preserve">
          <source>Limit the number of commits to output.</source>
          <target state="translated">出力するコミット数を制限します。</target>
        </trans-unit>
        <trans-unit id="38e02fe4379a543b3e47180cba4d6468bec3e601" translate="yes" xml:space="preserve">
          <source>Limit the revisions to show. This can be either a single revision meaning show from the given revision and back, or it can be a range in the form &quot;&lt;code&gt;&amp;lt;from&amp;gt;&lt;/code&gt;..&lt;code&gt;&amp;lt;to&amp;gt;&lt;/code&gt;&quot; to show all revisions between &lt;code&gt;&amp;lt;from&amp;gt;&lt;/code&gt; and back to &lt;code&gt;&amp;lt;to&amp;gt;&lt;/code&gt;. Note, more advanced revision selection can be applied. For a more complete list of ways to spell object names, see &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;.</source>
          <target state="translated">表示するリビジョンを制限します。これは、指定したリビジョンと背中からショーを意味する単一のリビジョンのいずれかにすることも、「形式の範囲することができ &lt;code&gt;&amp;lt;from&amp;gt;&lt;/code&gt; .. &lt;code&gt;&amp;lt;to&amp;gt;&lt;/code&gt; の間のすべてのリビジョン示すために、」 &lt;code&gt;&amp;lt;from&amp;gt;&lt;/code&gt; してまで戻っ &lt;code&gt;&amp;lt;to&amp;gt;&lt;/code&gt; 。より高度なリビジョン選択を適用できることに注意してください。オブジェクト名を綴る方法のより完全なリストについては、&lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="674ff0df4160db3404d979762630ae612e98f156" translate="yes" xml:space="preserve">
          <source>Limit the width of the graph part in --stat output. If set, applies to all commands generating --stat output except format-patch.</source>
          <target state="translated">stat出力のグラフ部分の幅を制限します。設定されている場合、format-patch以外の--stat出力を生成するすべてのコマンドに適用されます。</target>
        </trans-unit>
        <trans-unit id="29e45322508b52ceb051971d532eab460b3dc7d7" translate="yes" xml:space="preserve">
          <source>Limit to &quot;refs/heads&quot; and &quot;refs/tags&quot;, respectively. These options are not mutually exclusive; when given both, references stored in &quot;refs/heads&quot; and &quot;refs/tags&quot; are displayed.</source>
          <target state="translated">それぞれ &quot;refs/heads &quot;と &quot;refs/tags &quot;に制限します。これらのオプションは相互に排他的ではありません。 両方を指定した場合、&quot;refs/heads &quot;と &quot;refs/tags &quot;に格納されている参照が表示されます。</target>
        </trans-unit>
        <trans-unit id="66b9fb961da3804ca95085a20ace37a86529e6f7" translate="yes" xml:space="preserve">
          <source>Limit to only refs/heads and refs/tags, respectively. These options are &lt;code&gt;not&lt;/code&gt; mutually exclusive; when given both, references stored in refs/heads and refs/tags are displayed.</source>
          <target state="translated">refs / headsとrefs / tagsのみにそれぞれ制限します。これらのオプションは相互に排他的ではあり &lt;code&gt;not&lt;/code&gt; 。両方を指定すると、refs / headsとrefs / tagsに保存されている参照が表示されます。</target>
        </trans-unit>
        <trans-unit id="cce06ee642a7b80587fe58f4572571b699424f46" translate="yes" xml:space="preserve">
          <source>Limit to only refs/heads and refs/tags, respectively. These options are &lt;code&gt;not&lt;/code&gt; mutually exclusive; when given both, references stored in refs/heads and refs/tags are displayed. Note that &lt;code&gt;git ls-remote -h&lt;/code&gt; used without anything else on the command line gives help, consistent with other git subcommands.</source>
          <target state="translated">それぞれ、refs / headsとrefs / tagsのみに制限します。これらのオプションは相互に排他的ではあり &lt;code&gt;not&lt;/code&gt; 。両方を指定すると、refs / headsとrefs / tagsに格納されている参照が表示されます。コマンドラインで他に何もせずに使用された &lt;code&gt;git ls-remote -h&lt;/code&gt; は、他のgitサブコマンドと一致してヘルプを提供することに注意してください。</target>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="e8bb22d887f5d59400be2b36a39e61d714bda7bc" translate="yes" xml:space="preserve">
          <source>Limiting the diff output</source>
          <target state="translated">diff出力の制限</target>
        </trans-unit>
        <trans-unit id="b7748eb338af2086cdad1f6af364c3481df64676" translate="yes" xml:space="preserve">
          <source>Limits the number of commits to show to 3.</source>
          <target state="translated">表示するコミット数を 3 に制限します。</target>
        </trans-unit>
        <trans-unit id="efd756293dbb86969a7022bf4157b3145d6076f3" translate="yes" xml:space="preserve">
          <source>Limits the paths affected by the operation.</source>
          <target state="translated">操作の影響を受けるパスを制限します。</target>
        </trans-unit>
        <trans-unit id="8375cb461aa1ace8d2ffdda18edb87b333f2f4d1" translate="yes" xml:space="preserve">
          <source>Line numbers count from 1.</source>
          <target state="translated">行番号は1から数えます。</target>
        </trans-unit>
        <trans-unit id="3d9326a0fc6538daba3b0f3096cf5c416812b52b" translate="yes" xml:space="preserve">
          <source>Lines starting with a hash (&quot;&lt;code&gt;#&lt;/code&gt;&quot;) are ignored, so they can be used for comments. Add a backslash (&quot;&lt;code&gt;\&lt;/code&gt;&quot;) to the beginning of the pattern if it starts with a hash.</source>
          <target state="translated">ハッシュ（ &quot; &lt;code&gt;#&lt;/code&gt; &quot;）で始まる行は無視されるため、コメントに使用できます。ハッシュで始まる場合は、パターンの先頭にバックスラッシュ（ &quot; &lt;code&gt;\&lt;/code&gt; &quot;）を追加します。</target>
        </trans-unit>
        <trans-unit id="8e28fd820953d60830c4b1106307e2e0b6872452" translate="yes" xml:space="preserve">
          <source>Linewrap the output by wrapping each line at &lt;code&gt;width&lt;/code&gt;. The first line of each entry is indented by &lt;code&gt;indent1&lt;/code&gt; spaces, and the second and subsequent lines are indented by &lt;code&gt;indent2&lt;/code&gt; spaces. &lt;code&gt;width&lt;/code&gt;, &lt;code&gt;indent1&lt;/code&gt;, and &lt;code&gt;indent2&lt;/code&gt; default to 76, 6 and 9 respectively.</source>
          <target state="translated">各行をwidthで折り返すことにより、出力を改行し &lt;code&gt;width&lt;/code&gt; 。各エントリの1行目は、 &lt;code&gt;indent1&lt;/code&gt; スペースでインデントされ、2行目以降は、 &lt;code&gt;indent2&lt;/code&gt; スペースでインデントされます。 &lt;code&gt;width&lt;/code&gt; 、 &lt;code&gt;indent1&lt;/code&gt; 、および &lt;code&gt;indent2&lt;/code&gt; のデフォルトは、それぞれ76、6、および9です。</target>
        </trans-unit>
        <trans-unit id="1d1f6a47e210ac264339f2e30472d9fdf4025a54" translate="yes" xml:space="preserve">
          <source>Links and their targets</source>
          <target state="translated">リンクとその対象</target>
        </trans-unit>
        <trans-unit id="7177342122325630102d4a83723d13417535ac19" translate="yes" xml:space="preserve">
          <source>Linus Torvalds originally designed Git to be a user space file system, i.e. the infrastructure to hold files and directories. That ensured the efficiency and speed of Git.</source>
          <target state="translated">Linus TorvaldsはもともとGitをユーザー空間のファイルシステム、つまりファイルやディレクトリを保持するためのインフラストラクチャとして設計しました。それがGitの効率性とスピードを確保していました。</target>
        </trans-unit>
        <trans-unit id="9f9879c2ed0b6b8dfd5d9b1ecb4faa0c5584d26d" translate="yes" xml:space="preserve">
          <source>Linus Torvalds, for example, makes new kernel releases by tagging them, then running:</source>
          <target state="translated">例えば、Linus Torvalds は、新しいカーネルのリリースをタグ付けして実行することで、新しいカーネルのリリースを作成しています。</target>
        </trans-unit>
        <trans-unit id="c215fd74e10e91e4728dc7ef559cf830d21a3457" translate="yes" xml:space="preserve">
          <source>Linus&amp;rsquo;s tree will be stored in the remote-tracking branch named origin/master, and can be updated using &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;; you can track other public trees using &lt;a href=&quot;git-remote&quot;&gt;git-remote[1]&lt;/a&gt; to set up a &quot;remote&quot; and &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt; to keep them up to date; see &lt;a href=&quot;#repositories-and-branches&quot;&gt;Repositories and Branches&lt;/a&gt;.</source>
          <target state="translated">Linusのツリーはorigin / masterという名前のリモート追跡ブランチに保存され、&lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt;を使用して更新できます。&lt;a href=&quot;git-remote&quot;&gt;git-remote [1]&lt;/a&gt;を使用して「リモート」を設定し、&lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt;を使用して他のパブリックツリーを追跡し、最新の状態に保つことができます。&lt;a href=&quot;#repositories-and-branches&quot;&gt;リポジトリとブランチを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="4a79bad3bb798b3bdc01c2a7bbb2df04a2b261bb" translate="yes" xml:space="preserve">
          <source>List (array reference) of feature parameters (if there are any), used also to toggle (enable or disable) given feature.</source>
          <target state="translated">機能パラメータのリスト (配列参照)(もしあれば)で、指定した機能をトグル (有効または無効)するためにも使用します。</target>
        </trans-unit>
        <trans-unit id="7ee03188f58cdb7509c4f88e1a300f564da6d9fa" translate="yes" xml:space="preserve">
          <source>List all attributes that are associated with the specified paths. If this option is used, then &lt;code&gt;unspecified&lt;/code&gt; attributes will not be included in the output.</source>
          <target state="translated">指定されたパスに関連付けられているすべての属性をリストします。このオプションを使用すると、 &lt;code&gt;unspecified&lt;/code&gt; されていない属性は出力に含まれません。</target>
        </trans-unit>
        <trans-unit id="250839942391006b259bdb87bdef885727a6f6a9" translate="yes" xml:space="preserve">
          <source>List all available configuration variables. This is a short summary of the list in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">使用可能なすべての構成変数をリストします。これは&lt;a href=&quot;git-config&quot;&gt;git-config [1]の&lt;/a&gt;リストの短い要約です。</target>
        </trans-unit>
        <trans-unit id="12ac07106316dd6381b9d3b75b7cd7d028c9fa93" translate="yes" xml:space="preserve">
          <source>List all commits reachable from all refs</source>
          <target state="translated">すべての ref から到達可能なすべてのコミットをリストアップする</target>
        </trans-unit>
        <trans-unit id="dca598d76b2fd502e68ee09810f65324e1da32ae" translate="yes" xml:space="preserve">
          <source>List all tags (lightweight and annotated) in given repository.</source>
          <target state="translated">与えられたリポジトリ内のすべてのタグ(軽量で注釈付きのもの)をリストアップします。</target>
        </trans-unit>
        <trans-unit id="df1447e22cac81b01f2aee49d9517212423de9a9" translate="yes" xml:space="preserve">
          <source>List all variables set in config file, along with their values.</source>
          <target state="translated">設定ファイルに設定されているすべての変数とその値を一覧表示します。</target>
        </trans-unit>
        <trans-unit id="aa1b92c795a51cb41c1ee54087151d51eda95116" translate="yes" xml:space="preserve">
          <source>List both remote-tracking branches and local branches. Combine with &lt;code&gt;--list&lt;/code&gt; to match optional pattern(s).</source>
          <target state="translated">リモート追跡ブランチとローカルブランチの両方をリストします。 &lt;code&gt;--list&lt;/code&gt; と組み合わせて、オプションのパターンに一致させます。</target>
        </trans-unit>
        <trans-unit id="670ea777adabe92ea2a21ddec9e8062878d9ce68" translate="yes" xml:space="preserve">
          <source>List branches. With optional &lt;code&gt;&amp;lt;pattern&amp;gt;...&lt;/code&gt;, e.g. &lt;code&gt;git
branch --list 'maint-*'&lt;/code&gt;, list only the branches that match the pattern(s).</source>
          <target state="translated">ブランチを一覧表示します。オプションの &lt;code&gt;&amp;lt;pattern&amp;gt;...&lt;/code&gt; 、たとえば &lt;code&gt;git branch --list 'maint-*'&lt;/code&gt; を使用すると、パターンに一致するブランチのみが一覧表示されます。</target>
        </trans-unit>
        <trans-unit id="ecd6ee4f3b1cdf8c4e62426b401b6921926e6641" translate="yes" xml:space="preserve">
          <source>List commands by group. This is an internal/experimental option and may change or be removed in the future. Supported groups are: builtins, parseopt (builtin commands that use parse-options), main (all commands in libexec directory), others (all other commands in &lt;code&gt;$PATH&lt;/code&gt; that have git- prefix), list-&amp;lt;category&amp;gt; (see categories in command-list.txt), nohelpers (exclude helper commands), alias and config (retrieve command list from config variable completion.commands)</source>
          <target state="translated">コマンドをグループ別にリストします。これは内部/実験的なオプションであり、将来変更または削除される可能性があります。サポートされるグループは、builtins、parseopt（parse-optionsを使用する組み込みコマンド）、main（libexecディレクトリ内のすべてのコマンド）、その他（git-プレフィックスを持つ &lt;code&gt;$PATH&lt;/code&gt; 内の他のすべてのコマンド）、list- &amp;lt;category&amp;gt;（のカテゴリを参照） command-list.txt）、nohelpers（ヘルパーコマンドを除外）、alias、config（config変数completion.commandsからコマンドリストを取得）</target>
        </trans-unit>
        <trans-unit id="238ed7681a7fd585fe1d585aba4d3e4521202ffa" translate="yes" xml:space="preserve">
          <source>List commits that are reachable by following the &lt;code&gt;parent&lt;/code&gt; links from the given commit(s), but exclude commits that are reachable from the one(s) given with a &lt;code&gt;^&lt;/code&gt; in front of them. The output is given in reverse chronological order by default.</source>
          <target state="translated">指定されたコミットから &lt;code&gt;parent&lt;/code&gt; リンクをたどることによって到達可能なコミットを一覧表示しますが、先頭に &lt;code&gt;^&lt;/code&gt; を付けて指定されたコミットから到達可能なコミットは除外します。デフォルトでは、出力は新しい順に表示されます。</target>
        </trans-unit>
        <trans-unit id="4360f3a3310a6afc913d6c5b075b5763b91121d3" translate="yes" xml:space="preserve">
          <source>List details of each working tree. The main working tree is listed first, followed by each of the linked working trees. The output details include whether the working tree is bare, the revision currently checked out, and the branch currently checked out (or &quot;detached HEAD&quot; if none).</source>
          <target state="translated">各作業木の詳細を一覧表示します。メインの作業ツリーが最初に表示され、その後にリンクされた各作業ツリーが表示されます。出力される詳細には、作業ツリーがむき出しかどうか、現在チェックアウトされているリビジョン、現在チェックアウトされているブランチ(ない場合は &quot;detached HEAD&quot; )が含まれます。</target>
        </trans-unit>
        <trans-unit id="f8cd82f860b84646c498bf5c68b11bdf176a80b7" translate="yes" xml:space="preserve">
          <source>List details of each working tree. The main working tree is listed first, followed by each of the linked working trees. The output details include whether the working tree is bare, the revision currently checked out, the branch currently checked out (or &quot;detached HEAD&quot; if none), and &quot;locked&quot; if the worktree is locked.</source>
          <target state="translated">各作業木の詳細を一覧表示します。メインの作業ツリーが最初に表示され、その後にリンクされた各作業ツリーが表示されます。出力される詳細情報には、作業ツリーがむき出しかどうか、現在チェックアウトされているリビジョン、現在チェックアウトされているブランチ(ない場合は &quot;detached HEAD&quot;)、作業ツリーがロックされている場合は &quot;locked &quot;が含まれます。</target>
        </trans-unit>
        <trans-unit id="adfacb775267bd93896cdbdf525c103ac26c16d4" translate="yes" xml:space="preserve">
          <source>List details of each worktree. The main worktree is listed first, followed by each of the linked worktrees. The output details include if the worktree is bare, the revision currently checked out, and the branch currently checked out (or &lt;code&gt;detached HEAD&lt;/code&gt; if none).</source>
          <target state="translated">各ワークツリーの詳細をリストします。メインのワークツリーが最初にリストされ、その後にリンクされた各ワークツリーが続きます。出力の詳細には、ワークツリーがベアであるかどうか、現在チェックアウトされているリビジョン、および現在チェックアウトされているブランチが含まれます（または、存在しない場合は &lt;code&gt;detached HEAD&lt;/code&gt; ます）。</target>
        </trans-unit>
        <trans-unit id="1481dab663abae987b5437270fc0152b6258984f" translate="yes" xml:space="preserve">
          <source>List of Git base URLs. These URLs are used to generate URLs describing from where to fetch a project, which are shown on project summary page. The full fetch URL is &quot;&lt;code&gt;$git_base_url/$project&lt;/code&gt;&quot;, for each element of this list. You can set up multiple base URLs (for example one for &lt;code&gt;git://&lt;/code&gt; protocol, and one for &lt;code&gt;http://&lt;/code&gt; protocol).</source>
          <target state="translated">GitベースURLのリスト。これらのURLは、プロジェクトの概要ページに表示される、プロジェクトのフェッチ元を示すURLを生成するために使用されます。このリストの各要素の完全なフェッチURLは「 &lt;code&gt;$git_base_url/$project&lt;/code&gt; 」です。複数のベースURLを設定できます（たとえば、1つは &lt;code&gt;git://&lt;/code&gt; プロトコル用、もう1つは &lt;code&gt;http://&lt;/code&gt; プロトコル用）。</target>
        </trans-unit>
        <trans-unit id="e9453e698a4a15232ec2c038afd4c298aede850c" translate="yes" xml:space="preserve">
          <source>List of URIs of stylesheets (relative to the base URI of a page). You might specify more than one stylesheet, for example to use &quot;gitweb.css&quot; as base with site specific modifications in a separate stylesheet to make it easier to upgrade gitweb. For example, you can add a &lt;code&gt;site&lt;/code&gt; stylesheet by putting</source>
          <target state="translated">スタイルシートのURIのリスト（ページのベースURIを基準にして）。たとえば、「gitweb.css」をベースとして使用し、別のスタイルシートでサイト固有の変更を加えて、gitwebのアップグレードを容易にするために、複数のスタイルシートを指定する場合があります。たとえば、 &lt;code&gt;site&lt;/code&gt; スタイルシートを追加するには、</target>
        </trans-unit>
        <trans-unit id="d9ab3387c39e123d7aac2edb253dcdba7080f753" translate="yes" xml:space="preserve">
          <source>List of additional directories under &quot;refs&quot; which are going to be used as branch refs. For example if you have a gerrit setup where all branches under refs/heads/ are official, push-after-review ones and branches under refs/sandbox/, refs/wip and refs/other are user ones where permissions are much wider, then you might want to set this variable as follows:</source>
          <target state="translated">refs&quot; の下にある、ブランチの参照として使われる追加のディレクトリのリスト。例えば、gerrit の設定で、refs/heads/以下のブランチはすべて公式のもので、プッシュした後にレビューするもので、refs/sandbox/,refs/wip,refs/other 以下のブランチはユーザのもので、パーミッションの範囲がもっと広い場合、この変数を以下のように設定したいかもしれません。</target>
        </trans-unit>
        <trans-unit id="c919f43c88ec5761218ece7f29ac150fc5c1298f" translate="yes" xml:space="preserve">
          <source>List of branches to be imported when branch detection is enabled. Each entry should be a pair of branch names separated by a colon (:). This example declares that both branchA and branchB were created from main:</source>
          <target state="translated">ブランチ検出が有効な場合にインポートされるブランチのリスト。各エントリは、コロン (:)で区切られたブランチ名のペアでなければなりません。この例では、branchA と branchB の両方が main から作成されたことを宣言しています。</target>
        </trans-unit>
        <trans-unit id="3d6057539fc43b4e5580b21aa940b705e61341be" translate="yes" xml:space="preserve">
          <source>List of p4 labels to ignore. This is built automatically as unimportable labels are discovered.</source>
          <target state="translated">無視する p4 ラベルのリスト。これは、重要でないラベルが発見されると自動的に構築されます。</target>
        </trans-unit>
        <trans-unit id="ed979d0137e2b09484f09056901ac3efce874117" translate="yes" xml:space="preserve">
          <source>List only commits on the respective side of a symmetric difference, i.e. only those which would be marked &lt;code&gt;&amp;lt;&lt;/code&gt; resp. &lt;code&gt;&amp;gt;&lt;/code&gt; by &lt;code&gt;--left-right&lt;/code&gt;.</source>
          <target state="translated">対称差分のそれぞれの側のコミットのみをリストします。つまり、 &lt;code&gt;&amp;lt;&lt;/code&gt; resp とマークされるコミットのみをリストします。 &lt;code&gt;&amp;gt;&lt;/code&gt; による &lt;code&gt;--left-right&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="db38d2130aa4774e0a5e01e813cbe87b286b5c58" translate="yes" xml:space="preserve">
          <source>List only filenames (instead of the &quot;long&quot; output), one per line.</source>
          <target state="translated">ファイル名のみをリストアップします(&quot;長い &quot;出力の代わりに)。</target>
        </trans-unit>
        <trans-unit id="ca0ba00456e1892ce61ce3c77aa65cb5194d4e6c" translate="yes" xml:space="preserve">
          <source>List or delete (if used with -d) the remote-tracking branches. Combine with &lt;code&gt;--list&lt;/code&gt; to match the optional pattern(s).</source>
          <target state="translated">リモート追跡ブランチを一覧表示または削除します（-dと共に使用した場合）。 &lt;code&gt;--list&lt;/code&gt; と組み合わせて、オプションのパターンに一致させます。</target>
        </trans-unit>
        <trans-unit id="22eb51b821276ed4742fd46da8d914f3eb506ca1" translate="yes" xml:space="preserve">
          <source>List output format</source>
          <target state="translated">リスト出力形式</target>
        </trans-unit>
        <trans-unit id="961866b18d2006e9e2f1c57af615530c0dcb0176" translate="yes" xml:space="preserve">
          <source>List references in a local repository</source>
          <target state="translated">ローカルリポジトリ内の参照を一覧表示する</target>
        </trans-unit>
        <trans-unit id="7a309b311eeb5429dbbc4c270383e0c9240ea7dd" translate="yes" xml:space="preserve">
          <source>List references in a remote repository</source>
          <target state="translated">リモートリポジトリ内の参照を一覧表示する</target>
        </trans-unit>
        <trans-unit id="c3c4b04779710ca49a121ec3b626bb207fe0cc86" translate="yes" xml:space="preserve">
          <source>List replace refs for objects that match the given pattern (or all if no pattern is given). Typing &quot;git replace&quot; without arguments, also lists all replace refs.</source>
          <target state="translated">指定したパターンにマッチするオブジェクトの replace refs を一覧表示します (パターンが指定されていない場合はすべて表示します)。引数を指定せずに &quot;git replace&quot; と入力すると、すべての置換参照をリストアップします。</target>
        </trans-unit>
        <trans-unit id="dd864736379915e26071e39557a37c9a699c5cd9" translate="yes" xml:space="preserve">
          <source>List some tags in a table with unequal column widths:</source>
          <target state="translated">列の幅が不均等な表のいくつかのタグをリストアップします。</target>
        </trans-unit>
        <trans-unit id="c3a7e0023c585da8fc00add926f4e7fe3e4bed2d" translate="yes" xml:space="preserve">
          <source>List tags. With optional &lt;code&gt;&amp;lt;pattern&amp;gt;...&lt;/code&gt;, e.g. &lt;code&gt;git tag --list
'v-*'&lt;/code&gt;, list only the tags that match the pattern(s).</source>
          <target state="translated">タグをリストします。オプションの &lt;code&gt;&amp;lt;pattern&amp;gt;...&lt;/code&gt; 、たとえば &lt;code&gt;git tag --list 'v-*'&lt;/code&gt; を使用すると、パターンに一致するタグのみがリストされます。</target>
        </trans-unit>
        <trans-unit id="42f93b25d56793afc3463e924a37b81b3e45f73d" translate="yes" xml:space="preserve">
          <source>List the GIT_* environment variables that are local to the repository (e.g. GIT_DIR or GIT_WORK_TREE, but not GIT_EDITOR). Only the names of the variables are listed, not their value, even if they are set.</source>
          <target state="translated">リポジトリにローカルにある GIT_*環境変数をリストアップします (GIT_DIR や GIT_WORK_TREE などですが、GIT_EDITOR ではありません)。設定されている場合でも、変数名のみがリストアップされ、値は表示されません。</target>
        </trans-unit>
        <trans-unit id="dc410162c15e0c2fc959648b2d515436ff66231c" translate="yes" xml:space="preserve">
          <source>List the contents of a tree object</source>
          <target state="translated">ツリーオブジェクトの内容を一覧表示する</target>
        </trans-unit>
        <trans-unit id="c77a61ab930b102983b7633429f2e1c89c8a648a" translate="yes" xml:space="preserve">
          <source>List the notes object for a given object. If no object is given, show a list of all note objects and the objects they annotate (in the format &quot;&amp;lt;note object&amp;gt; &amp;lt;annotated object&amp;gt;&quot;). This is the default subcommand if no subcommand is given.</source>
          <target state="translated">指定されたオブジェクトのノートオブジェクトを一覧表示します。オブジェクトが指定されていない場合は、すべてのノートオブジェクトとそれらに注釈を付けるオブジェクトのリストを（「&amp;lt;ノートオブジェクト&amp;gt; &amp;lt;注釈付きオブジェクト&amp;gt;」の形式で）表示します。サブコマンドが指定されていない場合、これがデフォルトのサブコマンドです。</target>
        </trans-unit>
        <trans-unit id="160440cac4234691b237108179766c8ac388a3dd" translate="yes" xml:space="preserve">
          <source>List the stash entries that you currently have. Each &lt;code&gt;stash entry&lt;/code&gt; is listed with its name (e.g. &lt;code&gt;stash@{0}&lt;/code&gt; is the latest entry, &lt;code&gt;stash@{1}&lt;/code&gt; is the one before, etc.), the name of the branch that was current when the entry was made, and a short description of the commit the entry was based on.</source>
          <target state="translated">現在持っているstashエントリーをリストします。各 &lt;code&gt;stash entry&lt;/code&gt; は、その名前（例： &lt;code&gt;stash@{0}&lt;/code&gt; が最新のエントリ、 &lt;code&gt;stash@{1}&lt;/code&gt; が1つ前のエントリなど）、エントリが作成されたときに最新であったブランチの名前、およびエントリが基づくコミットの短い説明。</target>
        </trans-unit>
        <trans-unit id="0928a18c981cee8dd1bbd962ad11b79b09b49f73" translate="yes" xml:space="preserve">
          <source>List, create, or delete branches</source>
          <target state="translated">ブランチの一覧表示、作成、削除</target>
        </trans-unit>
        <trans-unit id="7d888e358c6ef40ec2a0a8a674979b45cd6d1cf4" translate="yes" xml:space="preserve">
          <source>Listed below are options that control the formatting of diff output. Some of them are specific to &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt;, however other diff options may be given. See &lt;a href=&quot;git-diff-files&quot;&gt;git-diff-files[1]&lt;/a&gt; for more options.</source>
          <target state="translated">以下は、diff出力のフォーマットを制御するオプションです。それらのいくつかは&lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list [1]&lt;/a&gt;に固有のものですが、他のdiffオプションを指定することもできます。その他のオプションについては、&lt;a href=&quot;git-diff-files&quot;&gt;git-diff-files [1]&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="3248fa00aea630b8bbaf0b4709f9f26882639bdc" translate="yes" xml:space="preserve">
          <source>Listen on a specific IP address or hostname. IP addresses can be either an IPv4 address or an IPv6 address if supported. If IPv6 is not supported, then --listen=hostname is also not supported and --listen must be given an IPv4 address. Can be given more than once. Incompatible with &lt;code&gt;--inetd&lt;/code&gt; option.</source>
          <target state="translated">特定のIPアドレスまたはホスト名をリッスンします。サポートされている場合、IPアドレスはIPv4アドレスまたはIPv6アドレスのいずれかです。IPv6がサポートされていない場合、-listen = hostnameもサポートされないため、-listenにIPv4アドレスを指定する必要があります。複数回指定できます。 &lt;code&gt;--inetd&lt;/code&gt; オプションと互換性がありません。</target>
        </trans-unit>
        <trans-unit id="4f53ff7586b49256325ec58801bfe143f18e21e3" translate="yes" xml:space="preserve">
          <source>Listen on an alternative port. Incompatible with &lt;code&gt;--inetd&lt;/code&gt; option.</source>
          <target state="translated">代替ポートでリッスンします。 &lt;code&gt;--inetd&lt;/code&gt; オプションと互換性がありません。</target>
        </trans-unit>
        <trans-unit id="3e35805a9773260286dfbc09d02caaf5994dc0ce" translate="yes" xml:space="preserve">
          <source>Listing a single attribute:</source>
          <target state="translated">単一の属性をリストアップします。</target>
        </trans-unit>
        <trans-unit id="69751d90f1fec1736a7673316bf3b759c5271c7d" translate="yes" xml:space="preserve">
          <source>Listing all attributes for a file:</source>
          <target state="translated">ファイルのすべての属性をリストアップします。</target>
        </trans-unit>
        <trans-unit id="e231fe1cc3d8844bfddb76169e22179c8767ce9e" translate="yes" xml:space="preserve">
          <source>Listing an attribute for multiple files:</source>
          <target state="translated">複数のファイルの属性をリストアップします。</target>
        </trans-unit>
        <trans-unit id="d1d9eec0e1bd38bd76cb67feb04b08b5d78c11bd" translate="yes" xml:space="preserve">
          <source>Listing branches from a specific remote</source>
          <target state="translated">特定のリモートからの分岐をリストアップ</target>
        </trans-unit>
        <trans-unit id="14162152c45d26fb9527c9f0660bef886294e5bf" translate="yes" xml:space="preserve">
          <source>Listing multiple attributes for a file:</source>
          <target state="translated">ファイルの複数の属性をリストアップします。</target>
        </trans-unit>
        <trans-unit id="540f872616da666be00fd2f7f78a7ae984c11b9a" translate="yes" xml:space="preserve">
          <source>Lists all local or all remote-tracking branches in given repository.</source>
          <target state="translated">指定されたリポジトリ内のすべてのローカルブランチまたはすべてのリモートトラッキングブランチをリストアップします。</target>
        </trans-unit>
        <trans-unit id="b5500d120a9a13cb3af42448653e0cde10752de4" translate="yes" xml:space="preserve">
          <source>Lists commit objects in reverse chronological order</source>
          <target state="translated">コミットオブジェクトを時系列を逆にしてリストアップします。</target>
        </trans-unit>
        <trans-unit id="6385084e9b2c3e78376900259ba28376e3a28618" translate="yes" xml:space="preserve">
          <source>Lists the available Git repositories. This is the default command if no repository is specified in the URL.</source>
          <target state="translated">利用可能な Git リポジトリを一覧表示します。URL にリポジトリが指定されていない場合は、これがデフォルトのコマンドとなります。</target>
        </trans-unit>
        <trans-unit id="9438685d87876d6c82356bf9b864c1c6136c1266" translate="yes" xml:space="preserve">
          <source>Lists the capabilities of the helper, one per line, ending with a blank line. Each capability may be preceded with &lt;code&gt;*&lt;/code&gt;, which marks them mandatory for Git versions using the remote helper to understand. Any unknown mandatory capability is a fatal error.</source>
          <target state="translated">ヘルパーの機能を1行に1つずつリストし、空白行で終了します。各機能の前に &lt;code&gt;*&lt;/code&gt; を付けることができます。これは、理解するためにリモートヘルパーを使用するGitバージョンに必須であることを示します。不明な必須機能は致命的なエラーです。</target>
        </trans-unit>
        <trans-unit id="8c594a1bf48edecf6065890a7f89cc7fa404495f" translate="yes" xml:space="preserve">
          <source>Lists the contents of a given tree object, like what &quot;/bin/ls -a&quot; does in the current working directory. Note that:</source>
          <target state="translated">与えられたツリーオブジェクトの内容をリストアップします。これに注意してください。</target>
        </trans-unit>
        <trans-unit id="9cc5eb61d77cd46774cb42ac22301b7d413d58c5" translate="yes" xml:space="preserve">
          <source>Lists the properties stored in the Subversion repository about a given file or directory. Use -r/--revision to refer to a specific Subversion revision.</source>
          <target state="translated">与えられたファイルやディレクトリについて、Subversion リポジトリに保存されているプロパティを一覧表示します。特定の Subversion リビジョンを参照するには -r/--revision を使用します。</target>
        </trans-unit>
        <trans-unit id="11c5aa2ca7f7c3e091142bb69f047bf1ca338d7f" translate="yes" xml:space="preserve">
          <source>Lists the references defined in the bundle. If followed by a list of references, only references matching those given are printed out.</source>
          <target state="translated">バンドルで定義されている参照を一覧表示します。参照のリストが続く場合は、与えられたものにマッチする参照のみが出力されます。</target>
        </trans-unit>
        <trans-unit id="ce5afcadd9730c2206b4e08d09ffc836dddfab54" translate="yes" xml:space="preserve">
          <source>Lists the refs, one per line, in the format &quot;&amp;lt;value&amp;gt; &amp;lt;name&amp;gt; [&amp;lt;attr&amp;gt; &amp;hellip;​]&quot;. The value may be a hex sha1 hash, &quot;@&amp;lt;dest&amp;gt;&quot; for a symref, &quot;:&amp;lt;keyword&amp;gt; &amp;lt;value&amp;gt;&quot; for a key-value pair, or &quot;?&quot; to indicate that the helper could not get the value of the ref. A space-separated list of attributes follows the name; unrecognized attributes are ignored. The list ends with a blank line.</source>
          <target state="translated">参照を1行に1つずつ、「&amp;lt;値&amp;gt; &amp;lt;名前&amp;gt; [&amp;lt;attr&amp;gt;&amp;hellip;]」の形式で一覧表示します。値は、16進のsha1ハッシュ、symrefの場合は「@ &amp;lt;dest&amp;gt;」、キーと値のペアの場合は「：&amp;lt;keyword&amp;gt; &amp;lt;value&amp;gt;」、または「？」です。ヘルパーが参照の値を取得できなかったことを示します。名前の後には、スペースで区切られた属性のリストが続きます。認識されない属性は無視されます。リストは空白行で終わります。</target>
        </trans-unit>
        <trans-unit id="cb27642bee7df675e576f1467eabd36ebf236a0c" translate="yes" xml:space="preserve">
          <source>Lists the refs, one per line, in the format &quot;&amp;lt;value&amp;gt; &amp;lt;name&amp;gt; [&amp;lt;attr&amp;gt; &amp;hellip;​]&quot;. The value may be a hex sha1 hash, &quot;@&amp;lt;dest&amp;gt;&quot; for a symref, or &quot;?&quot; to indicate that the helper could not get the value of the ref. A space-separated list of attributes follows the name; unrecognized attributes are ignored. The list ends with a blank line.</source>
          <target state="translated">「&amp;lt;値&amp;gt; &amp;lt;名前&amp;gt; [&amp;lt;属性&amp;gt;&amp;hellip;]」の形式で、1行に1つずつ参照を一覧表示します。値は16進数のsha1ハッシュ、symrefの場合は「@ &amp;lt;dest&amp;gt;」、「？」の場合があります。ヘルパーが参照の値を取得できなかったことを示します。名前の後に、スペースで区切られた属性のリストが続きます。認識されない属性は無視されます。リストは空白行で終わります。</target>
        </trans-unit>
        <trans-unit id="8cf165480241df10f979b6b7157595e5407c755f" translate="yes" xml:space="preserve">
          <source>Literal percent sign.</source>
          <target state="translated">文字通りのパーセント記号。</target>
        </trans-unit>
        <trans-unit id="c9b025ce8a30fb92786ef26cc44501e09df585de" translate="yes" xml:space="preserve">
          <source>Literal space in command or argument.</source>
          <target state="translated">コマンドまたは引数のリテラルスペース。</target>
        </trans-unit>
        <trans-unit id="3e47004eca06847317d03882ea01098236feca24" translate="yes" xml:space="preserve">
          <source>Loads annotations as described above and automatically scrolls the view to center on line &lt;code&gt;100&lt;/code&gt;.</source>
          <target state="translated">上記のように注釈をロードし、ビューを自動的にスクロールして行 &lt;code&gt;100&lt;/code&gt; の中央に配置します。</target>
        </trans-unit>
        <trans-unit id="f638d2718f9a7fa3228a4c22ea27ab0cb7ce0ed8" translate="yes" xml:space="preserve">
          <source>Local directory</source>
          <target state="translated">ローカルディレクトリ</target>
        </trans-unit>
        <trans-unit id="83cd95e5e26d810cf34fa10fd02190221225a995" translate="yes" xml:space="preserve">
          <source>Locate a good region of the object graph in a damaged repository</source>
          <target state="translated">破損したリポジトリ内のオブジェクトグラフの良い領域を探す</target>
        </trans-unit>
        <trans-unit id="c6b89ef8cfe5b4e0d5f71a9018f7c23272508e1d" translate="yes" xml:space="preserve">
          <source>Location of repositories</source>
          <target state="translated">リポジトリの場所</target>
        </trans-unit>
        <trans-unit id="a8464429b3dd8a54d4c3a8d0aaf7809c3b93d077" translate="yes" xml:space="preserve">
          <source>Locations of Marks Files</source>
          <target state="translated">マークスファイルの位置</target>
        </trans-unit>
        <trans-unit id="747742f75a08750185466d70d49a66f609262970" translate="yes" xml:space="preserve">
          <source>Locations of the common system-wide configuration file, the fallback system-wide configuration file and the per-instance configuration file are defined at compile time using build-time Makefile configuration variables, respectively &lt;code&gt;GITWEB_CONFIG_COMMON&lt;/code&gt;, &lt;code&gt;GITWEB_CONFIG_SYSTEM&lt;/code&gt; and &lt;code&gt;GITWEB_CONFIG&lt;/code&gt;.</source>
          <target state="translated">共通のシステム全体の構成ファイル、フォールバックシステム全体の構成ファイル、およびインスタンスごとの構成ファイルの場所は、ビルド時にMakefile構成変数である &lt;code&gt;GITWEB_CONFIG_COMMON&lt;/code&gt; 、 &lt;code&gt;GITWEB_CONFIG_SYSTEM&lt;/code&gt; 、および &lt;code&gt;GITWEB_CONFIG&lt;/code&gt; を使用して、コンパイル時に定義されます。</target>
        </trans-unit>
        <trans-unit id="ff8e7c6671e74ff8d9e440b7a275b6b3047a92bf" translate="yes" xml:space="preserve">
          <source>Log details about the incoming connections and requested files.</source>
          <target state="translated">着信接続と要求されたファイルの詳細をログに記録します。</target>
        </trans-unit>
        <trans-unit id="c1bbca864796e717c6563546ee8bb0273fbae9ac" translate="yes" xml:space="preserve">
          <source>Logging updates</source>
          <target state="translated">ロギングの更新</target>
        </trans-unit>
        <trans-unit id="e76f4d6fb1700b21a7cf7fc7a62d7a34c7014ae2" translate="yes" xml:space="preserve">
          <source>Long Running Filter Process</source>
          <target state="translated">長時間稼働のフィルタープロセス</target>
        </trans-unit>
        <trans-unit id="555712d9829e6328a9b7d5ec70facbda745fb9b3" translate="yes" xml:space="preserve">
          <source>Look at the diffs from each branch. &lt;code&gt;git log --merge -p &amp;lt;path&amp;gt;&lt;/code&gt; will show diffs first for the &lt;code&gt;HEAD&lt;/code&gt; version and then the &lt;code&gt;MERGE_HEAD&lt;/code&gt; version.</source>
          <target state="translated">各ブランチの差分を見てください。 &lt;code&gt;git log --merge -p &amp;lt;path&amp;gt;&lt;/code&gt; は、最初に &lt;code&gt;HEAD&lt;/code&gt; バージョンの差分を表示し、次に &lt;code&gt;MERGE_HEAD&lt;/code&gt; バージョンの差分を表示します。</target>
        </trans-unit>
        <trans-unit id="a326ab540e0d9536d53dbc94d57cb0c25e24d9a1" translate="yes" xml:space="preserve">
          <source>Look at the diffs. &lt;code&gt;git diff&lt;/code&gt; will show a three-way diff, highlighting changes from both the &lt;code&gt;HEAD&lt;/code&gt; and &lt;code&gt;MERGE_HEAD&lt;/code&gt; versions.</source>
          <target state="translated">差分を見てください。 &lt;code&gt;git diff&lt;/code&gt; は3方向の差分を表示し、 &lt;code&gt;HEAD&lt;/code&gt; バージョンと &lt;code&gt;MERGE_HEAD&lt;/code&gt; バージョンの両方からの変更を強調表示します。</target>
        </trans-unit>
        <trans-unit id="f8c63749f2ae2fa24fa7ef48c360ef59f66a1f48" translate="yes" xml:space="preserve">
          <source>Look at the originals. &lt;code&gt;git show :1:filename&lt;/code&gt; shows the common ancestor, &lt;code&gt;git show :2:filename&lt;/code&gt; shows the &lt;code&gt;HEAD&lt;/code&gt; version, and &lt;code&gt;git show :3:filename&lt;/code&gt; shows the &lt;code&gt;MERGE_HEAD&lt;/code&gt; version.</source>
          <target state="translated">オリジナルを見てください。 &lt;code&gt;git show :1:filename&lt;/code&gt; は共通の祖先を示し、 &lt;code&gt;git show :2:filename&lt;/code&gt; は &lt;code&gt;HEAD&lt;/code&gt; バージョンを示し、 &lt;code&gt;git show :3:filename&lt;/code&gt; は &lt;code&gt;MERGE_HEAD&lt;/code&gt; バージョンを示します。</target>
        </trans-unit>
        <trans-unit id="6a423d84e076a3272fdc685127299ea63ea761ac" translate="yes" xml:space="preserve">
          <source>Look for a fix instead of a regression in the code</source>
          <target state="translated">コードの回帰の代わりに修正を探す</target>
        </trans-unit>
        <trans-unit id="4ab23275475ac09a44d78ac861e7af3c95082023" translate="yes" xml:space="preserve">
          <source>Look for attributes in .gitattributes files in the working tree as well (see &lt;a href=&quot;#ATTRIBUTES&quot;&gt;ATTRIBUTES&lt;/a&gt;).</source>
          <target state="translated">作業ツリーの.gitattributesファイルでも属性を探します（&lt;a href=&quot;#ATTRIBUTES&quot;&gt;属性を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="5e41023ffb67a9b868c13a5cdc624ea0d794092d" translate="yes" xml:space="preserve">
          <source>Look for differences that change the number of occurrences of the specified object. Similar to &lt;code&gt;-S&lt;/code&gt;, just the argument is different in that it doesn&amp;rsquo;t search for a specific string but for a specific object id.</source>
          <target state="translated">指定されたオブジェクトの出現回数を変更する違いを探します。 &lt;code&gt;-S&lt;/code&gt; と同様に、特定の文字列ではなく特定のオブジェクトIDを検索するという点で、引数だけが異なります。</target>
        </trans-unit>
        <trans-unit id="a838d092d782360d96378f1e4ff8a0b5fffd060f" translate="yes" xml:space="preserve">
          <source>Look for differences that change the number of occurrences of the specified string (i.e. addition/deletion) in a file. Intended for the scripter&amp;rsquo;s use.</source>
          <target state="translated">ファイル内の指定された文字列（つまり、追加/削除）の出現回数を変更する違いを探します。スクリプト作成者の使用を目的としています。</target>
        </trans-unit>
        <trans-unit id="b8df136f2384d637ef409fc2baddd2b9dce73992" translate="yes" xml:space="preserve">
          <source>Look for differences whose patch text contains added/removed lines that match &amp;lt;regex&amp;gt;.</source>
          <target state="translated">&amp;lt;regex&amp;gt;に一致する追加/削除された行がパッチテキストに含まれている違いを探します。</target>
        </trans-unit>
        <trans-unit id="4cef9adbc5be0f5f01b5c2739071b69091cb4a32" translate="yes" xml:space="preserve">
          <source>Look for specified patterns in the tracked files in the work tree, blobs registered in the index file, or blobs in given tree objects. Patterns are lists of one or more search expressions separated by newline characters. An empty string as search expression matches all lines.</source>
          <target state="translated">ワークツリー内の追跡ファイル、インデックスファイルに登録されているブロブ、または与えられたツリーオブジェクト内のブロブの中から、指定されたパターンを探します。パターンは、改行文字で区切られた1つ以上の検索式のリストです。検索式として空の文字列を指定すると、すべての行にマッチします。</target>
        </trans-unit>
        <trans-unit id="07448c29252081320f670b2265de0e9cba50a292" translate="yes" xml:space="preserve">
          <source>Look up layout mode using configuration variable column.&amp;lt;name&amp;gt; and column.ui.</source>
          <target state="translated">構成変数column。&amp;lt;name&amp;gt;およびcolumn.uiを使用してレイアウトモードを検索します。</target>
        </trans-unit>
        <trans-unit id="b62eefc27e1aeffa75b2d4761547bc2b8bc497bd" translate="yes" xml:space="preserve">
          <source>Looks at the current index and checks to see if merges or updates are needed by checking stat() information.</source>
          <target state="translated">現在のインデックスを見て、stat()情報をチェックしてマージや更新が必要かどうかをチェックします。</target>
        </trans-unit>
        <trans-unit id="4b7876b6a8ad520457ce71bfe745148e3c567edb" translate="yes" xml:space="preserve">
          <source>Looks for &lt;code&gt;solution&lt;/code&gt;, excluding files in &lt;code&gt;Documentation&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Documentation&lt;/code&gt; 内のファイルを除外して、 &lt;code&gt;solution&lt;/code&gt; を探します。</target>
        </trans-unit>
        <trans-unit id="2f3233017974f60253fdf12d744b51a535433787" translate="yes" xml:space="preserve">
          <source>Looks for &lt;code&gt;time_t&lt;/code&gt; in all tracked .c and .h files in the working directory and its subdirectories.</source>
          <target state="translated">探し &lt;code&gt;time_t&lt;/code&gt; のすべてでは、作業ディレクトリとそのサブディレクトリでの.cと.hファイルを追跡しました。</target>
        </trans-unit>
        <trans-unit id="558837c842e106c2ed3e4e9a131c3a7442c122b9" translate="yes" xml:space="preserve">
          <source>Looks for a line that has &lt;code&gt;#define&lt;/code&gt; and either &lt;code&gt;MAX_PATH&lt;/code&gt; or &lt;code&gt;PATH_MAX&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;#define&lt;/code&gt; と &lt;code&gt;MAX_PATH&lt;/code&gt; または &lt;code&gt;PATH_MAX&lt;/code&gt; のいずれかを含む行を探します。</target>
        </trans-unit>
        <trans-unit id="432adcaf916374b14ccc5f4491d7cd8a1e3d3e44" translate="yes" xml:space="preserve">
          <source>Looks for a line that has &lt;code&gt;NODE&lt;/code&gt; or &lt;code&gt;Unexpected&lt;/code&gt; in files that have lines that match both.</source>
          <target state="translated">持っている行を探します &lt;code&gt;NODE&lt;/code&gt; または &lt;code&gt;Unexpected&lt;/code&gt; 両方と一致する行を持つファイルに。</target>
        </trans-unit>
        <trans-unit id="b11d66d44e8db145700e0edb6375620b652f740a" translate="yes" xml:space="preserve">
          <source>Low-level commands (plumbing)</source>
          <target state="translated">低レベルコマンド(配管</target>
        </trans-unit>
        <trans-unit id="0ffc3dae4e51a700bf1ca804b93845e0102810f8" translate="yes" xml:space="preserve">
          <source>Low-level git operations</source>
          <target state="translated">低レベルの git 操作</target>
        </trans-unit>
        <trans-unit id="c63ae6dd4fc9f9dda66970e827d13f7c73fe841c" translate="yes" xml:space="preserve">
          <source>M</source>
          <target state="translated">M</target>
        </trans-unit>
        <trans-unit id="5d487fc78e43a0306fd5f718aec828744ee6e786" translate="yes" xml:space="preserve">
          <source>M: modification of the contents or mode of a file</source>
          <target state="translated">M:ファイルの内容やモードの変更</target>
        </trans-unit>
        <trans-unit id="0f48f030cf13414eeafe91359c3c62bf97314f35" translate="yes" xml:space="preserve">
          <source>Magic Options</source>
          <target state="translated">マジックオプション</target>
        </trans-unit>
        <trans-unit id="7d828d176880cf3ec5ec8010d93f54010eebda7b" translate="yes" xml:space="preserve">
          <source>Maildir splitting relies upon filenames being sorted to output patches in the correct order.</source>
          <target state="translated">Maildir の分割は、パッチが正しい順序で出力されるようにファイル名がソートされていることに依存します。</target>
        </trans-unit>
        <trans-unit id="57a6217babf3a984d54a72505b0f2a4f3e1be542" translate="yes" xml:space="preserve">
          <source>Main porcelain commands</source>
          <target state="translated">主な磁器コマンド</target>
        </trans-unit>
        <trans-unit id="46b62a0f964fab2f018eee342e7b4db44adbc685" translate="yes" xml:space="preserve">
          <source>Maintaining topic branches for a Linux subsystem maintainer</source>
          <target state="translated">Linux サブシステムメンテナのトピックブランチの管理</target>
        </trans-unit>
        <trans-unit id="52f0f393e457cb924c234a7254a4daec3a0cbf32" translate="yes" xml:space="preserve">
          <source>Maintenance branch management after a feature release</source>
          <target state="translated">機能リリース後のメンテナンスブランチ管理</target>
        </trans-unit>
        <trans-unit id="319909b05c9210e6ff8b8a19f69dc9189ee2cca4" translate="yes" xml:space="preserve">
          <source>Make &lt;code&gt;git gc --auto&lt;/code&gt; return immediately and run in background if the system supports it. Default is true.</source>
          <target state="translated">作る &lt;code&gt;git gc --auto&lt;/code&gt; それをすぐに復帰し、システムサポートしている場合、バックグラウンドで実行します。デフォルトはtrueです。</target>
        </trans-unit>
        <trans-unit id="77c42361d50b9bdea29b692160b9eae95cceb52e" translate="yes" xml:space="preserve">
          <source>Make &lt;code&gt;git show-ref&lt;/code&gt; act as a filter that reads refs from stdin of the form &quot;&lt;code&gt;^(?:&amp;lt;anything&amp;gt;\s)?&amp;lt;refname&amp;gt;(?:\^{})?$&lt;/code&gt;&quot; and performs the following actions on each: (1) strip &quot;^{}&quot; at the end of line if any; (2) ignore if pattern is provided and does not head-match refname; (3) warn if refname is not a well-formed refname and skip; (4) ignore if refname is a ref that exists in the local repository; (5) otherwise output the line.</source>
          <target state="translated">作る &lt;code&gt;git show-ref&lt;/code&gt; 形式の標準入力からの引用文献を読み込み、フィルタとしての行為を&quot; &lt;code&gt;^(?:&amp;lt;anything&amp;gt;\s)?&amp;lt;refname&amp;gt;(?:\^{})?$&lt;/code&gt; &quot;と行い、それぞれに次のアクション：（1）行末に「^ {}」があればそれを取り除きます。（2）パターンが提供され、refnameと一致しない場合は無視します。（3）refnameが整形式のrefnameでない場合に警告し、スキップします。（4）refnameがローカルリポジトリに存在するrefである場合は無視します。（5）それ以外の場合はラインを出力します。</target>
        </trans-unit>
        <trans-unit id="51befbcaeb5eba297db1a634b8802a7f0078cead" translate="yes" xml:space="preserve">
          <source>Make &lt;code&gt;git svn&lt;/code&gt; less verbose. Specify a second time to make it even less verbose.</source>
          <target state="translated">作る &lt;code&gt;git svn&lt;/code&gt; それほど冗長。2回目を指定すると、冗長度がさらに低くなります。</target>
        </trans-unit>
        <trans-unit id="2da3bd3f8069e8e437af583aecc3a384c81edd34" translate="yes" xml:space="preserve">
          <source>Make a &lt;code&gt;bare&lt;/code&gt; Git repository. That is, instead of creating &lt;code&gt;&amp;lt;directory&amp;gt;&lt;/code&gt; and placing the administrative files in &lt;code&gt;&amp;lt;directory&amp;gt;/.git&lt;/code&gt;, make the &lt;code&gt;&amp;lt;directory&amp;gt;&lt;/code&gt; itself the &lt;code&gt;$GIT_DIR&lt;/code&gt;. This obviously implies the &lt;code&gt;--no-checkout&lt;/code&gt; because there is nowhere to check out the working tree. Also the branch heads at the remote are copied directly to corresponding local branch heads, without mapping them to &lt;code&gt;refs/remotes/origin/&lt;/code&gt;. When this option is used, neither remote-tracking branches nor the related configuration variables are created.</source>
          <target state="translated">作る &lt;code&gt;bare&lt;/code&gt; Gitリポジトリを。つまり、 &lt;code&gt;&amp;lt;directory&amp;gt;&lt;/code&gt; を作成して管理ファイルを &lt;code&gt;&amp;lt;directory&amp;gt;/.git&lt;/code&gt; &lt;code&gt;$GIT_DIR&lt;/code&gt; 配置する代わりに、 &lt;code&gt;&amp;lt;directory&amp;gt;&lt;/code&gt; 自体を$ GIT_DIRにします。作業ツリーをチェックアウトする場所がないため、これは明らかに &lt;code&gt;--no-checkout&lt;/code&gt; を意味します。また、リモートのブランチヘッドは、 &lt;code&gt;refs/remotes/origin/&lt;/code&gt; マッピングせずに、対応するローカルブランチヘッドに直接コピーされます。このオプションを使用すると、リモート追跡ブランチも関連する構成変数も作成されません。</target>
        </trans-unit>
        <trans-unit id="6ca024f41825508ff37398849dd7bbbd184e78e6" translate="yes" xml:space="preserve">
          <source>Make a GPG-signed tag, using the default e-mail address&amp;rsquo;s key. The default behavior of tag GPG-signing is controlled by &lt;code&gt;tag.gpgSign&lt;/code&gt; configuration variable if it exists, or disabled otherwise. See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">デフォルトの電子メールアドレスのキーを使用して、GPG署名付きタグを作成します。タグGPG署名のデフォルトの動作は、 &lt;code&gt;tag.gpgSign&lt;/code&gt; 構成変数が存在する場合はそれによって制御され、存在しない場合は無効になります。&lt;a href=&quot;git-config&quot;&gt;git-config [1]を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="d5a6f6bd2dfbdab5f143e86ea9155fad4e43a30c" translate="yes" xml:space="preserve">
          <source>Make a GPG-signed tag, using the given key.</source>
          <target state="translated">与えられたキーを使用して、GPG 符号付きタグを作成します。</target>
        </trans-unit>
        <trans-unit id="99f2296af5452e1eec1986dbc7a0151a5ba6b1fc" translate="yes" xml:space="preserve">
          <source>Make a commit by taking the updated working tree contents of the paths specified on the command line, disregarding any contents that have been staged for other paths. This is the default mode of operation of &lt;code&gt;git commit&lt;/code&gt; if any paths are given on the command line, in which case this option can be omitted. If this option is specified together with &lt;code&gt;--amend&lt;/code&gt;, then no paths need to be specified, which can be used to amend the last commit without committing changes that have already been staged. If used together with &lt;code&gt;--allow-empty&lt;/code&gt; paths are also not required, and an empty commit will be created.</source>
          <target state="translated">コマンドラインで指定されたパスの更新された作業ツリーのコンテンツを取得してコミットします。他のパスにステージングされたコンテンツは無視されます。コマンドラインでパスが指定されている場合、これは &lt;code&gt;git commit&lt;/code&gt; のデフォルトの操作モードです。この場合、このオプションは省略できます。このオプションを &lt;code&gt;--amend&lt;/code&gt; と一緒に指定する場合、パスを指定する必要はありません。これは、すでにステージングされている変更をコミットすることなく、最後のコミットを修正するために使用できます。 &lt;code&gt;--allow-empty&lt;/code&gt; パスと一緒に使用する場合も不要で、空のコミットが作成されます。</target>
        </trans-unit>
        <trans-unit id="2e9bf6a1a9ac175346438fe9d4c19601601a0ebd" translate="yes" xml:space="preserve">
          <source>Make a list of the commits which are about to be rebased. Let the user edit that list before rebasing. This mode can also be used to split commits (see SPLITTING COMMITS below).</source>
          <target state="translated">リベースしようとしているコミットのリストを作成します。リベース前にそのリストを編集することができます。このモードはコミットを分割するのにも使えます (後述のコミットの分割を参照してください)。</target>
        </trans-unit>
        <trans-unit id="f382849103310ffba0e3d31128dfababfd915957" translate="yes" xml:space="preserve">
          <source>Make a local clone that borrows from the current directory, without checking things out:</source>
          <target state="translated">カレントディレクトリから借用するローカルクローンを作成します。</target>
        </trans-unit>
        <trans-unit id="d7a3e91b3667d18f363db6d6cc32c0afec1ed1d5" translate="yes" xml:space="preserve">
          <source>Make a side branch for every topic (feature, bugfix, &amp;hellip;​). Fork it off at the oldest integration branch that you will eventually want to merge it into.</source>
          <target state="translated">すべてのトピック（機能、バグ修正など）のサイドブランチを作成します。最終的にそれをマージする必要がある最も古い統合ブランチで分岐します。</target>
        </trans-unit>
        <trans-unit id="89db797c5d89c53349b8d88ec549bb720f48d1f7" translate="yes" xml:space="preserve">
          <source>Make an unsigned, annotated tag object</source>
          <target state="translated">符号なしの注釈付きタグオブジェクトを作成する</target>
        </trans-unit>
        <trans-unit id="f88ecf2f4eb0c5509c792cd2c61ea44a524baf96" translate="yes" xml:space="preserve">
          <source>Make corrections to working tree files.</source>
          <target state="translated">作業木ファイルの修正を行います。</target>
        </trans-unit>
        <trans-unit id="79ee7beb56d7493ce335c85dd0a8333674bff17b" translate="yes" xml:space="preserve">
          <source>Make git-send-email less verbose. One line per email should be all that is output.</source>
          <target state="translated">git-send-email を冗長にしないようにします。一通のメールにつき、出力されるのは一行だけにしましょう。</target>
        </trans-unit>
        <trans-unit id="ff429cc18c1dac972928cb3da6e4d06bbfe2d8ec" translate="yes" xml:space="preserve">
          <source>Make one commit and return to the shell when it is complete. This command returns a non-zero exit code if the window was closed in any way other than by making a commit.</source>
          <target state="translated">一つのコミットを行い、完了したらシェルに戻ります。このコマンドは、コミット以外の方法でウィンドウが閉じられた場合、0 以外の終了コードを返します。</target>
        </trans-unit>
        <trans-unit id="31ca9c9bf3eab94aff99250728fe74f77977b844" translate="yes" xml:space="preserve">
          <source>Make sure Git knows who to blame:</source>
          <target state="translated">誰のせいにするかGitに確認してくれ</target>
        </trans-unit>
        <trans-unit id="cf12b54cc8063982ae2c9b96588de4f236c9e743" translate="yes" xml:space="preserve">
          <source>Make sure all submodule commits used by the revisions to be pushed are available on a remote-tracking branch. If the value is &lt;code&gt;check&lt;/code&gt; then Git will verify that all submodule commits that changed in the revisions to be pushed are available on at least one remote of the submodule. If any commits are missing, the push will be aborted and exit with non-zero status. If the value is &lt;code&gt;on-demand&lt;/code&gt; then all submodules that changed in the revisions to be pushed will be pushed. If on-demand was not able to push all necessary revisions it will also be aborted and exit with non-zero status. If the value is &lt;code&gt;no&lt;/code&gt; then default behavior of ignoring submodules when pushing is retained. You may override this configuration at time of push by specifying &lt;code&gt;--recurse-submodules=check|on-demand|no&lt;/code&gt;.</source>
          <target state="translated">プッシュするリビジョンで使用されるすべてのサブモジュールコミットがリモート追跡ブランチで利用可能であることを確認してください。値が &lt;code&gt;check&lt;/code&gt; 場合、Gitはプッシュされるリビジョンで変更されたすべてのサブモジュールコミットが、サブモジュールの少なくとも1つのリモートで使用可能であることを確認します。コミットが欠落している場合、プッシュは中止され、ゼロ以外のステータスで終了します。値が &lt;code&gt;on-demand&lt;/code&gt; 場合、プッシュされるリビジョンで変更されたすべてのサブモジュールがプッシュされます。オンデマンドで必要なすべてのリビジョンをプッシュできなかった場合も、中止され、ゼロ以外のステータスで終了します。値が &lt;code&gt;no&lt;/code&gt; の場合、プッシュ時にサブモジュールを無視するデフォルトの動作が保持されます。次のように指定することで、プッシュ時にこの構成をオーバーライドできます。 &lt;code&gt;--recurse-submodules=check|on-demand|no&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9e58089d4f2b4b0ca2024cc65ec03ed1d72bcb40" translate="yes" xml:space="preserve">
          <source>Make sure all submodule commits used by the revisions to be pushed are available on a remote-tracking branch. If the value is &lt;code&gt;check&lt;/code&gt; then Git will verify that all submodule commits that changed in the revisions to be pushed are available on at least one remote of the submodule. If any commits are missing, the push will be aborted and exit with non-zero status. If the value is &lt;code&gt;on-demand&lt;/code&gt; then all submodules that changed in the revisions to be pushed will be pushed. If on-demand was not able to push all necessary revisions it will also be aborted and exit with non-zero status. If the value is &lt;code&gt;no&lt;/code&gt; then default behavior of ignoring submodules when pushing is retained. You may override this configuration at time of push by specifying &lt;code&gt;--recurse-submodules=check|on-demand|no&lt;/code&gt;. If not set, &lt;code&gt;no&lt;/code&gt; is used by default, unless &lt;code&gt;submodule.recurse&lt;/code&gt; is set (in which case a &lt;code&gt;true&lt;/code&gt; value means &lt;code&gt;on-demand&lt;/code&gt;).</source>
          <target state="translated">プッシュされるリビジョンで使用されるすべてのサブモジュールコミットがリモートトラッキングブランチで利用可能であることを確認してください。値が &lt;code&gt;check&lt;/code&gt; 場合、Gitは、プッシュされるリビジョンで変更されたすべてのサブモジュールコミットが、サブモジュールの少なくとも1つのリモートで使用可能であることを確認します。コミットが欠落している場合、プッシュは中止され、ゼロ以外のステータスで終了します。値が &lt;code&gt;on-demand&lt;/code&gt; 場合、プッシュされるリビジョンで変更されたすべてのサブモジュールがプッシュされます。オンデマンドで必要なすべてのリビジョンをプッシュできなかった場合も、中止され、ゼロ以外のステータスで終了します。値が &lt;code&gt;no&lt;/code&gt; の場合、プッシュ時にサブモジュールを無視するデフォルトの動作が保持されます。指定することにより、プッシュ時にこの構成をオーバーライドできます &lt;code&gt;--recurse-submodules=check|on-demand|no&lt;/code&gt; 。設定されていない場合、 &lt;code&gt;submodule.recurse&lt;/code&gt; が設定されていない限り、デフォルトでは &lt;code&gt;no&lt;/code&gt; が使用されます（この場合、 &lt;code&gt;true&lt;/code&gt; 値は &lt;code&gt;on-demand&lt;/code&gt; 意味します）。</target>
        </trans-unit>
        <trans-unit id="70b6629c434b51e7d9186d1fc6fe97c1a3725440" translate="yes" xml:space="preserve">
          <source>Make sure committers have a umask of at most 027, so that the directories they create are writable and searchable by other group members.</source>
          <target state="translated">コミッターが作成したディレクトリが他のグループメンバーから書き込み可能で検索可能なように、umask を最大でも 027 にするようにしてください。</target>
        </trans-unit>
        <trans-unit id="4b35196a3d616941ad0c8a125c3a9f25e1bdc376" translate="yes" xml:space="preserve">
          <source>Make sure this directory is available for others you want your changes to be pulled via the transport of your choice. Also you need to make sure that you have the &lt;code&gt;git-receive-pack&lt;/code&gt; program on the &lt;code&gt;$PATH&lt;/code&gt;.</source>
          <target state="translated">選択したトランスポートを介して変更をプルしたい他のユーザーがこのディレクトリを利用できることを確認してください。また、 &lt;code&gt;$PATH&lt;/code&gt; &lt;code&gt;git-receive-pack&lt;/code&gt; プログラムがあることを確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="6631b9ca24ae751d7ee25163002526a066325c25" translate="yes" xml:space="preserve">
          <source>Make the first mail (or all the mails with &lt;code&gt;--no-thread&lt;/code&gt;) appear as a reply to the given &amp;lt;message id&amp;gt;, which avoids breaking threads to provide a new patch series.</source>
          <target state="translated">最初のメール（または &lt;code&gt;--no-thread&lt;/code&gt; を含むすべてのメール）を、指定された&amp;lt;メッセージID&amp;gt;への返信として表示します。これにより、スレッドを壊して新しいパッチシリーズを提供することが回避されます。</target>
        </trans-unit>
        <trans-unit id="5a1ce0ecb5c94a2505e8bfd1950281f48170d98f" translate="yes" xml:space="preserve">
          <source>Make the first mail (or all the mails with &lt;code&gt;--no-thread&lt;/code&gt;) appear as a reply to the given Message-Id, which avoids breaking threads to provide a new patch series. The second and subsequent emails will be sent as replies according to the &lt;code&gt;--[no-]chain-reply-to&lt;/code&gt; setting.</source>
          <target state="translated">最初のメール（または &lt;code&gt;--no-thread&lt;/code&gt; を含むすべてのメール）を、指定されたMessage-Idへの返信として表示します。これにより、スレッドを壊して新しいパッチシリーズを提供することが回避されます。2番目以降のメールは、 &lt;code&gt;--[no-]chain-reply-to&lt;/code&gt; 設定に従って返信として送信されます。</target>
        </trans-unit>
        <trans-unit id="b064d6e8766baf86355fa160624701d28d48e0eb" translate="yes" xml:space="preserve">
          <source>Make the program exit with codes similar to diff(1). That is, it exits with 1 if there were differences and 0 means no differences.</source>
          <target state="translated">プログラムを diff(1)と同様のコードで終了させるようにします。つまり、差分があれば1で終了し、0は差分がないことを意味します。</target>
        </trans-unit>
        <trans-unit id="033698ff1d93839c9dc26bb7039e879974408d51" translate="yes" xml:space="preserve">
          <source>Make the repository group-writable, (and g+sx, since the git group may be not the primary group of all users). This is used to loosen the permissions of an otherwise safe umask(2) value. Note that the umask still applies to the other permission bits (e.g. if umask is &lt;code&gt;0022&lt;/code&gt;, using &lt;code&gt;group&lt;/code&gt; will not remove read privileges from other (non-group) users). See &lt;code&gt;0xxx&lt;/code&gt; for how to exactly specify the repository permissions.</source>
          <target state="translated">リポジトリグループを書き込み可能にします（gitグループはすべてのユーザーのプライマリグループではない可能性があるため、g + sxを使用します）。これは、他の点では安全なumask（2）値の許可を緩めるために使用されます。なお、umaskは他の許可ビットにも適用されます（たとえば、umaskが &lt;code&gt;0022&lt;/code&gt; の場合、 &lt;code&gt;group&lt;/code&gt; を使用しても、他の（グループ以外の）ユーザーからの読み取り特権は削除されません）。リポジトリの権限を正確に指定する方法については、 &lt;code&gt;0xxx&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="daa563a54f59f3d95749377d0e4af4c611fecd18" translate="yes" xml:space="preserve">
          <source>Making a change</source>
          <target state="translated">変化を起こす</target>
        </trans-unit>
        <trans-unit id="9aef7fbf27451a8c36fe7bf7a109aea9540e01ca" translate="yes" xml:space="preserve">
          <source>Making changes</source>
          <target state="translated">変更を加えること</target>
        </trans-unit>
        <trans-unit id="992a7beb5615876037da9b0e5b4a3e7c21af51d8" translate="yes" xml:space="preserve">
          <source>Making some changes to the working directory using your favorite editor.</source>
          <target state="translated">お気に入りのエディタを使って作業ディレクトリに変更を加えます。</target>
        </trans-unit>
        <trans-unit id="bf4919466a0f70dfd02acc3627e75ad16a05f620" translate="yes" xml:space="preserve">
          <source>Manage multiple working trees</source>
          <target state="translated">複数の作業木の管理</target>
        </trans-unit>
        <trans-unit id="6ec4a25401fa228522c7be97da233480069758e8" translate="yes" xml:space="preserve">
          <source>Manage multiple working trees attached to the same repository.</source>
          <target state="translated">同じリポジトリに接続された複数の作業ツリーを管理します。</target>
        </trans-unit>
        <trans-unit id="5f089a6eb7f251a9a2fe0a3f833141f8db37c3ff" translate="yes" xml:space="preserve">
          <source>Manage reflog information</source>
          <target state="translated">リブログ情報の管理</target>
        </trans-unit>
        <trans-unit id="021ab6f7ef8793b1b816ea4bdd5e727ce06994e0" translate="yes" xml:space="preserve">
          <source>Manage set of tracked repositories</source>
          <target state="translated">追跡されたリポジトリのセットを管理する</target>
        </trans-unit>
        <trans-unit id="65f908ba554d3d8c75571c008e2b6e59e8585d63" translate="yes" xml:space="preserve">
          <source>Manage the serialized commit-graph file.</source>
          <target state="translated">シリアル化されたコミットグラフファイルを管理します。</target>
        </trans-unit>
        <trans-unit id="4a3e0eed31d02104159aa0bed6d5acb0e05768b8" translate="yes" xml:space="preserve">
          <source>Manage the set of repositories (&quot;remotes&quot;) whose branches you track.</source>
          <target state="translated">追跡しているブランチのリポジトリ(「リモート」)のセットを管理します。</target>
        </trans-unit>
        <trans-unit id="3507e0027b822825db37aad1b6a1e0779dcd0d96" translate="yes" xml:space="preserve">
          <source>Managing branches</source>
          <target state="translated">支店の管理</target>
        </trans-unit>
        <trans-unit id="279735249dbe3dcc024592a529bd9cb39b1b8496" translate="yes" xml:space="preserve">
          <source>Manipulate the notes tree in &amp;lt;ref&amp;gt;. This overrides &lt;code&gt;GIT_NOTES_REF&lt;/code&gt; and the &quot;core.notesRef&quot; configuration. The ref specifies the full refname when it begins with &lt;code&gt;refs/notes/&lt;/code&gt;; when it begins with &lt;code&gt;notes/&lt;/code&gt;, &lt;code&gt;refs/&lt;/code&gt; and otherwise &lt;code&gt;refs/notes/&lt;/code&gt; is prefixed to form a full name of the ref.</source>
          <target state="translated">&amp;lt;ref&amp;gt;のノートツリーを操作します。これは、 &lt;code&gt;GIT_NOTES_REF&lt;/code&gt; および「core.notesRef」構成をオーバーライドします。refは、 &lt;code&gt;refs/notes/&lt;/code&gt; で始まる完全なrefnameを指定します。 &lt;code&gt;notes/&lt;/code&gt; で始まる場合は、 &lt;code&gt;refs/&lt;/code&gt; 、それ以外の場合は &lt;code&gt;refs/notes/&lt;/code&gt; が接頭辞として付けられ、refの完全な名前が形成されます。</target>
        </trans-unit>
        <trans-unit id="ad0e6ab545d99b4fca1e842f2d64e34b5bf6ca91" translate="yes" xml:space="preserve">
          <source>Manipulating branches</source>
          <target state="translated">枝の操作</target>
        </trans-unit>
        <trans-unit id="e163593ceb018ccfe91e5474069f8880c01bf32f" translate="yes" xml:space="preserve">
          <source>Manipulation commands</source>
          <target state="translated">操作コマンド</target>
        </trans-unit>
        <trans-unit id="a4c79f29e9d9d5fa1534359d2910523c3bd41716" translate="yes" xml:space="preserve">
          <source>Manipulators:</source>
          <target state="translated">Manipulators:</target>
        </trans-unit>
        <trans-unit id="2d6fc489721f7990b3e0a46d8dbd0fae7613420d" translate="yes" xml:space="preserve">
          <source>Many (most?) public remote repositories will not contain any of the checked out files or even an index file, and will &lt;strong&gt;only&lt;/strong&gt; contain the actual core Git files. Such a repository usually doesn&amp;rsquo;t even have the &lt;code&gt;.git&lt;/code&gt; subdirectory, but has all the Git files directly in the repository.</source>
          <target state="translated">多くの（ほとんど？）パブリックリモートリポジトリには、チェックアウトされたファイルやインデックスファイルは含まれ&lt;strong&gt;ず&lt;/strong&gt;、実際のコアGitファイル&lt;strong&gt;のみ&lt;/strong&gt;が含まれます。このようなリポジトリには通常、 &lt;code&gt;.git&lt;/code&gt; サブディレクトリさえありませんが、すべてのGitファイルが直接リポジトリにあります。</target>
        </trans-unit>
        <trans-unit id="23a4d8d6b8951ee492fd478361a461e34445c192" translate="yes" xml:space="preserve">
          <source>Many Git commands also take sets of commits, which can be specified in a number of ways. Here are some examples with &lt;code&gt;git log&lt;/code&gt;:</source>
          <target state="translated">多くのGitコマンドは、コミットのセットも取得します。これは、さまざまな方法で指定できます。 &lt;code&gt;git log&lt;/code&gt; の例をいくつか示します。</target>
        </trans-unit>
        <trans-unit id="cb5f624f4f524730b1dad471a4cc62df1265c105" translate="yes" xml:space="preserve">
          <source>Many Git commands take revision parameters as arguments. Depending on the command, they denote a specific commit or, for commands which walk the revision graph (such as &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;), all commits which are reachable from that commit. For commands that walk the revision graph one can also specify a range of revisions explicitly.</source>
          <target state="translated">多くのGitコマンドは、リビジョンパラメーターを引数として受け取ります。コマンドに応じて、特定のコミット、またはリビジョングラフを&lt;a href=&quot;git-log&quot;&gt;たどる&lt;/a&gt;コマンド（git-log [1]など）の場合、そのコミットから到達可能なすべてのコミットを示します。リビジョングラフをたどるコマンドの場合、リビジョンの範囲を明示的に指定することもできます。</target>
        </trans-unit>
        <trans-unit id="8eadff7d5c23284bf3e40779cca1324c9880e38b" translate="yes" xml:space="preserve">
          <source>Many Git porcelainish commands take mixture of flags (i.e. parameters that begin with a dash &lt;code&gt;-&lt;/code&gt;) and parameters meant for the underlying &lt;code&gt;git rev-list&lt;/code&gt; command they use internally and flags and parameters for the other commands they use downstream of &lt;code&gt;git rev-list&lt;/code&gt;. This command is used to distinguish between them.</source>
          <target state="translated">多くのGit磁器コマンドは、フラグ（ダッシュ &lt;code&gt;-&lt;/code&gt; で始まるパラメーター）と、内部で使用する基礎となる &lt;code&gt;git rev-list&lt;/code&gt; コマンド用のパラメーター、および &lt;code&gt;git rev-list&lt;/code&gt; の下流で使用する他のコマンド用のフラグとパラメーターを組み合わせて使用​​します。このコマンドは、それらを区別するために使用されます。</target>
        </trans-unit>
        <trans-unit id="07f9a7fabb84ff55c93b5220c84bc1016373588c" translate="yes" xml:space="preserve">
          <source>Many command-line options can be provided as part of the fast-import stream itself by using the &lt;code&gt;feature&lt;/code&gt; or &lt;code&gt;option&lt;/code&gt; commands. However, some of these options are unsafe (e.g., allowing fast-import to access the filesystem outside of the repository). These options are disabled by default, but can be allowed by providing this option on the command line. This currently impacts only the &lt;code&gt;export-marks&lt;/code&gt;, &lt;code&gt;import-marks&lt;/code&gt;, and &lt;code&gt;import-marks-if-exists&lt;/code&gt; feature commands.</source>
          <target state="translated">多くのコマンドラインオプションは、 &lt;code&gt;feature&lt;/code&gt; または &lt;code&gt;option&lt;/code&gt; コマンドを使用して、高速インポートストリーム自体の一部として提供できます。ただし、これらのオプションの一部は安全ではありません（たとえば、高速インポートでリポジトリ外のファイルシステムにアクセスできるようにします）。これらのオプションはデフォルトでは無効になっていますが、コマンドラインでこのオプションを指定することで許可できます。これは現在、 &lt;code&gt;export-marks&lt;/code&gt; 、 &lt;code&gt;import-marks&lt;/code&gt; 、および &lt;code&gt;import-marks-if-exists&lt;/code&gt; 機能コマンドにのみ影響します。</target>
        </trans-unit>
        <trans-unit id="b810424b3fea997d54a1c6f50a7ffa7b2bdf31cc" translate="yes" xml:space="preserve">
          <source>Many commands allow wildcards in paths, but you need to protect them from getting globbed by the shell. These two mean different things:</source>
          <target state="translated">多くのコマンドではパスにワイルドカードを許可していますが、シェルにグロブされないようにする必要があります。この二つは異なる意味を持っています。</target>
        </trans-unit>
        <trans-unit id="f769735173b4b17536b3bddf331e35fc94c1f6c2" translate="yes" xml:space="preserve">
          <source>Many commands take revisions (most often &quot;commits&quot;, but sometimes &quot;tree-ish&quot;, depending on the context and command) and paths as their arguments. Here are the rules:</source>
          <target state="translated">多くのコマンドはリビジョン (多くの場合 &quot;commits&quot; ですが、コンテキストやコマンドによっては &quot;tree&quot; のようなものもあります)とパスを引数にとります。以下にそのルールを示します。</target>
        </trans-unit>
        <trans-unit id="51a04d163df59d3e4e585f46784dd69c625e4feb" translate="yes" xml:space="preserve">
          <source>Many commands that can work on files in the working tree and/or in the index can take &lt;code&gt;--cached&lt;/code&gt; and/or &lt;code&gt;--index&lt;/code&gt; options. Sometimes people incorrectly think that, because the index was originally called cache, these two are synonyms. They are &lt;strong&gt;not&lt;/strong&gt; &amp;mdash; these two options mean very different things.</source>
          <target state="translated">作業ツリーおよび/またはインデックス内のファイルを操作できる多くのコマンドは、 &lt;code&gt;--index&lt;/code&gt; および/または--indexオプションを取ることが &lt;code&gt;--cached&lt;/code&gt; ます。インデックスはもともとキャッシュと呼ばれていたため、この2つは同義語であると誤解されることがあります。そうではあり&lt;strong&gt;ません&lt;/strong&gt; &amp;mdash;これらの2つのオプションは非常に異なることを意味します。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="41a419d79cd72b9d54b27ecee9672655c35e91cc" translate="yes" xml:space="preserve">
          <source>Many gitweb features can be enabled (or disabled) and configured using the &lt;code&gt;%feature&lt;/code&gt; hash. Names of gitweb features are keys of this hash.</source>
          <target state="translated">多くのgitweb機能は、 &lt;code&gt;%feature&lt;/code&gt; ハッシュを使用して有効化（または無効化）および構成できます。gitweb機能の名前は、このハッシュのキーです。</target>
        </trans-unit>
        <trans-unit id="919a2ac82af6ff1bc82b2171d1abca264db10f6e" translate="yes" xml:space="preserve">
          <source>Many installations of sshd do not invoke your shell as the login shell when you directly run programs; what this means is that if your login shell is &lt;em&gt;bash&lt;/em&gt;, only &lt;code&gt;.bashrc&lt;/code&gt; is read and not &lt;code&gt;.bash_profile&lt;/code&gt;. As a workaround, make sure &lt;code&gt;.bashrc&lt;/code&gt; sets up &lt;code&gt;$PATH&lt;/code&gt; so that you can run &lt;em&gt;git-receive-pack&lt;/em&gt; program.</source>
          <target state="translated">sshdの多くのインストールでは、プログラムを直接実行するときに、シェルをログインシェルとして起動しません。つまり、ログインシェルが&lt;em&gt;bashの&lt;/em&gt;場合、 &lt;code&gt;.bash_profile&lt;/code&gt; ではなく &lt;code&gt;.bashrc&lt;/code&gt; のみが読み取られます。回避策として、&lt;em&gt;git-receive-pack&lt;/em&gt;プログラムを実行できるように、 &lt;code&gt;.bashrc&lt;/code&gt; が &lt;code&gt;$PATH&lt;/code&gt; 設定していることを確認してください。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b683891958210e2ee979b3e8c7ad10f12997dda2" translate="yes" xml:space="preserve">
          <source>Many mailers if not set up properly will corrupt whitespace. Here are two common types of corruption:</source>
          <target state="translated">適切に設定されていない場合、多くのメーラーはホワイトスペースを破損してしまいます。ここでは、2つの一般的な破損のタイプを紹介します。</target>
        </trans-unit>
        <trans-unit id="193dde6b7f3a20700543ed6450f24935f7b33dfa" translate="yes" xml:space="preserve">
          <source>Many of the higher-level commands were originally implemented as shell scripts using a smaller core of low-level Git commands. These can still be useful when doing unusual things with Git, or just as a way to understand its inner workings.</source>
          <target state="translated">上位レベルのコマンドの多くは、元々は低レベルの Git コマンドの小さなコアを使ったシェルスクリプトとして実装されていました。これらのコマンドは、Git を使って変わったことをするときや、Git の内部の仕組みを理解するための手段として今でも役に立つでしょう。</target>
        </trans-unit>
        <trans-unit id="3d6c28c55f8170d273c49f3e427a981c665cf6ea" translate="yes" xml:space="preserve">
          <source>Many operations in Git depend on your filesystem to have an efficient &lt;code&gt;lstat(2)&lt;/code&gt; implementation, so that &lt;code&gt;st_mtime&lt;/code&gt; information for working tree files can be cheaply checked to see if the file contents have changed from the version recorded in the index file. Unfortunately, some filesystems have inefficient &lt;code&gt;lstat(2)&lt;/code&gt;. If your filesystem is one of them, you can set &quot;assume unchanged&quot; bit to paths you have not changed to cause Git not to do this check. Note that setting this bit on a path does not mean Git will check the contents of the file to see if it has changed &amp;mdash; it makes Git to omit any checking and assume it has &lt;strong&gt;not&lt;/strong&gt; changed. When you make changes to working tree files, you have to explicitly tell Git about it by dropping &quot;assume unchanged&quot; bit, either before or after you modify them.</source>
          <target state="translated">Gitの多くの操作は、効率的な &lt;code&gt;lstat(2)&lt;/code&gt; 実装をファイルシステムに依存しているため、作業ツリーファイルの &lt;code&gt;st_mtime&lt;/code&gt; 情報を安価にチェックして、ファイルの内容がインデックスファイルに記録されているバージョンから変更されているかどうかを確認できます。残念ながら、一部のファイルシステムには非効率的な &lt;code&gt;lstat(2)&lt;/code&gt; があります。ファイルシステムがそのうちの1つである場合は、変更されていないパスに「想定されていない」ビットを設定して、Gitがこのチェックを行わないようにすることができます。パスにこのビットを設定しても、Gitがファイルの内容をチェックして変更されているかどうかを確認するわけではあり&lt;strong&gt;ません。&lt;/strong&gt;これにより、Gitはチェックを省略し、変更されて&lt;strong&gt;いない&lt;/strong&gt;と想定します。&lt;strong&gt;&lt;/strong&gt;かわった。作業ツリーファイルに変更を加える場合は、変更前または変更後に「変更されていないものを想定」ビットをドロップして、Gitに明示的に通知する必要があります。</target>
        </trans-unit>
        <trans-unit id="a799d1cceae5d3b6566df7c502b0ed31229cf195" translate="yes" xml:space="preserve">
          <source>Many revision control systems provide an &lt;code&gt;add&lt;/code&gt; command that tells the system to start tracking changes to a new file. Git&amp;rsquo;s &lt;code&gt;add&lt;/code&gt; command does something simpler and more powerful: &lt;code&gt;git add&lt;/code&gt; is used both for new and newly modified files, and in both cases it takes a snapshot of the given files and stages that content in the index, ready for inclusion in the next commit.</source>
          <target state="translated">多くのリビジョン管理システムには、システムに新しいファイルへの変更の追跡を開始するように指示する &lt;code&gt;add&lt;/code&gt; コマンドが用意されています。Gitの &lt;code&gt;add&lt;/code&gt; コマンドは、よりシンプルで強力な処理を実行します &lt;code&gt;git add&lt;/code&gt; は、新規ファイルと新しく変更されたファイルの両方に使用され、どちらの場合も、指定されたファイルのスナップショットを取り、そのコンテンツをインデックスにステージングして、次のコミットに含める準備が整います。</target>
        </trans-unit>
        <trans-unit id="f4ad3aa56684a237b2a48778413d62e45b68868b" translate="yes" xml:space="preserve">
          <source>Many tags. Will create a tag for every commit, reflecting the commit name in the Arch repository.</source>
          <target state="translated">たくさんのタグ。すべてのコミットに対して、Arch リポジトリのコミット名を反映したタグを作成します。</target>
        </trans-unit>
        <trans-unit id="6b4939f173ca46ae5e70f2a578215c85acafb3ce" translate="yes" xml:space="preserve">
          <source>Many thanks to Ingo Molnar for giving me very useful information that appears in this paper, for commenting on this paper, for his suggestions to improve &quot;git bisect&quot; and for evangelizing &quot;git bisect&quot; on the linux kernel mailing lists.</source>
          <target state="translated">Ingo Molnar さんには、この論文に登場する非常に有用な情報を提供してくれたこと、この論文へのコメント、&quot;git bisect&quot; を改善するための彼の提案、そして linux カーネルのメーリングリストで &quot;git bisect&quot; を広めてくれたことに感謝します。</target>
        </trans-unit>
        <trans-unit id="5bd4feea472ac1f81e9eed337015c1647da376b9" translate="yes" xml:space="preserve">
          <source>Many thanks to Junio Hamano for his help in reviewing this paper, for reviewing the patches I sent to the Git mailing list, for discussing some ideas and helping me improve them, for improving &quot;git bisect&quot; a lot and for his awesome work in maintaining and developing Git.</source>
          <target state="translated">この論文のレビューを手伝ってくれた浜野純夫さん、Git メーリングリストに送ったパッチをレビューしてくれたこと、いくつかのアイデアを議論して改善を手伝ってくれたこと、&quot;git bisect&quot; をたくさん改善してくれたこと、そして Git の維持と開発に携わってくれた彼の素晴らしい仕事に感謝します。</target>
        </trans-unit>
        <trans-unit id="a308e878405ccac0452dc3a943e6c4f471d0d0f3" translate="yes" xml:space="preserve">
          <source>Many thanks to Linus Torvalds for inventing, developing and evangelizing &quot;git bisect&quot;, Git and Linux.</source>
          <target state="translated">Git bisect&quot;、Git、Linux を発明し、開発し、伝道してくれた Linus Torvalds に感謝します。</target>
        </trans-unit>
        <trans-unit id="64e052904657c30a32be467111b38e2db70890d3" translate="yes" xml:space="preserve">
          <source>Many thanks to the Linux-Kongress program committee for choosing the author to given a talk and for publishing this paper.</source>
          <target state="translated">Linux-Kongress プログラム委員会の皆様には、講演の執筆者を選んでいただき、この論文を発表していただいたことに感謝します。</target>
        </trans-unit>
        <trans-unit id="a813e2d801820a3507d225cfe410c73c1e3814a5" translate="yes" xml:space="preserve">
          <source>Many thanks to the many other great people who helped one way or another when I worked on Git, especially to Andreas Ericsson, Johannes Schindelin, H. Peter Anvin, Daniel Barkalow, Bill Lear, John Hawley, Shawn O. Pierce, Jeff King, Sam Vilain, Jon Seymour.</source>
          <target state="translated">特に、Andreas Ericsson、Johannes Schindelin、H.Peter Anvin、Daniel Barkalow、Bill Lear、John Hawley、Shawn O.Pierce、Jeff King、Sam Vilain、Jon Seymour に感謝します。</target>
        </trans-unit>
        <trans-unit id="970bd5edbccf4926f346f36ced29b782ff134b0f" translate="yes" xml:space="preserve">
          <source>Many things can then be done very naturally:</source>
          <target state="translated">そうすると、多くのことがとても自然にできるようになります。</target>
        </trans-unit>
        <trans-unit id="08ed471839ae0d35cbf114cdc8b4fb025451ea78" translate="yes" xml:space="preserve">
          <source>Map a P4 user to a name and email address in Git. Use a string with the following format to create a mapping:</source>
          <target state="translated">P4 ユーザーを Git で名前とメールアドレスにマッピングします。以下の形式の文字列を使用してマッピングを作成します。</target>
        </trans-unit>
        <trans-unit id="84e3b6902de1ae94c28d951dff280df12bc818fa" translate="yes" xml:space="preserve">
          <source>Mapping authors</source>
          <target state="translated">マッピング作成者</target>
        </trans-unit>
        <trans-unit id="ecca08ad6644372b493b29196801e0262451ee0a" translate="yes" xml:space="preserve">
          <source>Mapping between Subversion revision numbers and Git commit names. In a repository where the noMetadata option is not set, this can be rebuilt from the git-svn-id: lines that are at the end of every commit (see the &lt;code&gt;svn.noMetadata&lt;/code&gt; section above for details).</source>
          <target state="translated">Subversionリビジョン番号とGitコミット名の間のマッピング。noMetadataオプションが設定されていないリポジトリでは、すべてのコミットの最後にあるgit-svn-id：行から再構築できます（詳細については、上記の &lt;code&gt;svn.noMetadata&lt;/code&gt; セクションを参照してください）。</target>
        </trans-unit>
        <trans-unit id="f80c6e32aadbd525747e2562fb58002684c64ae1" translate="yes" xml:space="preserve">
          <source>Mark lines that were changed by an ignored revision that we attributed to another commit with a &lt;code&gt;?&lt;/code&gt; in the output of &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt;.</source>
          <target state="translated">無視されたリビジョンによって変更された行にマークを付けます &lt;code&gt;?&lt;/code&gt; &lt;a href=&quot;git-blame&quot;&gt;git-blame [1]&lt;/a&gt;の出力で。</target>
        </trans-unit>
        <trans-unit id="e0a93a83bc77d4e299bb423ede0b0e7523360c05" translate="yes" xml:space="preserve">
          <source>Mark lines that were changed by an ignored revision that we could not attribute to another commit with a &lt;code&gt;*&lt;/code&gt; in the output of &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;git-blame&quot;&gt;git-blame [1]の&lt;/a&gt;出力で、 &lt;code&gt;*&lt;/code&gt; を使用して別のコミットに起因しない無視されたリビジョンによって変更された行にマークを付けます。</target>
        </trans-unit>
        <trans-unit id="ffa04a5e9e510ce8e8a9af22652c96cb5f2a2455" translate="yes" xml:space="preserve">
          <source>Mark the commit you want to split with the action &quot;edit&quot;.</source>
          <target state="translated">分割したいコミットを &quot;edit &quot;というアクションでマークします。</target>
        </trans-unit>
        <trans-unit id="9ad05336158823a7d5e9d2740631e3ed3e7b77cc" translate="yes" xml:space="preserve">
          <source>Mark the series as the &amp;lt;n&amp;gt;-th iteration of the topic. The output filenames have &lt;code&gt;v&amp;lt;n&amp;gt;&lt;/code&gt; prepended to them, and the subject prefix (&quot;PATCH&quot; by default, but configurable via the &lt;code&gt;--subject-prefix&lt;/code&gt; option) has ` v&amp;lt;n&amp;gt;` appended to it. E.g. &lt;code&gt;--reroll-count=4&lt;/code&gt; may produce &lt;code&gt;v4-0001-add-makefile.patch&lt;/code&gt; file that has &quot;Subject: [PATCH v4 1/20] Add makefile&quot; in it.</source>
          <target state="translated">シリーズをトピックの&amp;lt;n&amp;gt;番目の反復としてマークします。出力ファイル名の前には &lt;code&gt;v&amp;lt;n&amp;gt;&lt;/code&gt; が付いており、件名のプレフィックス（デフォルトでは &quot;PATCH&quot;ですが、 &lt;code&gt;--subject-prefix&lt;/code&gt; オプションで設定可能）に `v &amp;lt;n&amp;gt;`が追加されています。たとえば &lt;code&gt;--reroll-count=4&lt;/code&gt; は、「Subject：[PATCH v4 1/20] Add makefile」が含まれている &lt;code&gt;v4-0001-add-makefile.patch&lt;/code&gt; ファイルを生成する場合があります。</target>
        </trans-unit>
        <trans-unit id="eb02cc756d5e31341021dd6b9e08120c18cfff12" translate="yes" xml:space="preserve">
          <source>Mark which side of a symmetric difference a commit is reachable from. Commits from the left side are prefixed with &lt;code&gt;&amp;lt;&lt;/code&gt; and those from the right with &lt;code&gt;&amp;gt;&lt;/code&gt;. If combined with &lt;code&gt;--boundary&lt;/code&gt;, those commits are prefixed with &lt;code&gt;-&lt;/code&gt;.</source>
          <target state="translated">対称差分のどちらの側からコミットに到達できるかをマークします。左側からのコミットの前には &lt;code&gt;&amp;lt;&lt;/code&gt; が付き、右側からのコミットには &lt;code&gt;&amp;gt;&lt;/code&gt; が付きます。 &lt;code&gt;--boundary&lt;/code&gt; と組み合わせると、これらのコミットの先頭に &lt;code&gt;-&lt;/code&gt; が付きます。</target>
        </trans-unit>
        <trans-unit id="6cf65e398a783b020004a05bc4b12965bd321675" translate="yes" xml:space="preserve">
          <source>Mark which side of a symmetric difference a commit is reachable from. Commits from the left side are prefixed with a &lt;code&gt;&amp;lt;&lt;/code&gt; symbol and those from the right with a &lt;code&gt;&amp;gt;&lt;/code&gt; symbol.</source>
          <target state="translated">対称差分のどちらの側からコミットに到達できるかをマークします。左側からのコミットが付いさ &lt;code&gt;&amp;lt;&lt;/code&gt; シンボルと右側からのもの &lt;code&gt;&amp;gt;&lt;/code&gt; 記号。</target>
        </trans-unit>
        <trans-unit id="d120d1dcfa9af04a37a29923ad102f9ac75edbe0" translate="yes" xml:space="preserve">
          <source>Marking files as binary</source>
          <target state="translated">ファイルをバイナリとしてマークする</target>
        </trans-unit>
        <trans-unit id="3549e52dba075c1ca63de7856965a26fd121848f" translate="yes" xml:space="preserve">
          <source>Marks are stored in a sparse array, using 1 pointer (4 bytes or 8 bytes, depending on pointer size) per mark. Although the array is sparse, frontends are still strongly encouraged to use marks between 1 and n, where n is the total number of marks required for this import.</source>
          <target state="translated">マークは疎な配列に格納され、マークごとに 1 つのポインタ (ポインタのサイズに応じて 4 バイトまたは 8 バイト)を使用します。配列は疎なものですが、フロントエンドでは 1 から n の間のマークを使用することが強く推奨されています。</target>
        </trans-unit>
        <trans-unit id="c020b534de76a3110681e8b3a1131c198a04e4dd" translate="yes" xml:space="preserve">
          <source>Marks must be declared (via &lt;code&gt;mark&lt;/code&gt;) before they can be used.</source>
          <target state="translated">マークは、使用する前に（ &lt;code&gt;mark&lt;/code&gt; を介して）宣言する必要があります。</target>
        </trans-unit>
        <trans-unit id="e23875af098ed58ac7ddbf626ebbfd55b3530c2d" translate="yes" xml:space="preserve">
          <source>Marks the end of the stream. This command is optional unless the &lt;code&gt;done&lt;/code&gt; feature was requested using the &lt;code&gt;--done&lt;/code&gt; command-line option or &lt;code&gt;feature done&lt;/code&gt; command.</source>
          <target state="translated">ストリームの終わりを示します。 &lt;code&gt;--done&lt;/code&gt; コマンドラインオプションまたは &lt;code&gt;feature done&lt;/code&gt; コマンドを使用してdone機能が要求さ &lt;code&gt;done&lt;/code&gt; ない限り、このコマンドはオプションです。</target>
        </trans-unit>
        <trans-unit id="6dd5e3d7525f7c72ed149669f4682e8cf2613e2e" translate="yes" xml:space="preserve">
          <source>Match paths exactly (i.e. don&amp;rsquo;t allow &quot;/foo/repo&quot; when the real path is &quot;/foo/repo.git&quot; or &quot;/foo/repo/.git&quot;) and don&amp;rsquo;t do user-relative paths. &lt;code&gt;git daemon&lt;/code&gt; will refuse to start when this option is enabled and no whitelist is specified.</source>
          <target state="translated">パスを正確に一致させ（つまり、実際のパスが「/foo/repo.git」または「/foo/repo/.git」の場合は「/ foo / repo」を許可せず）、ユーザー相対パスを使用しないでください。このオプションが有効で、ホワイトリストが指定されていない場合、 &lt;code&gt;git daemon&lt;/code&gt; は起動を拒否します。</target>
        </trans-unit>
        <trans-unit id="1c5cb990d5ea569aee72e359a127ac5dd4a253ea" translate="yes" xml:space="preserve">
          <source>Match the pattern only at word boundary (either begin at the beginning of a line, or preceded by a non-word character; end at the end of a line or followed by a non-word character).</source>
          <target state="translated">単語の境界でのみパターンを一致させます(行頭で始まるか、単語以外の文字が先行します。</target>
        </trans-unit>
        <trans-unit id="ca182a2e7bbbd5ec9c62eec976529a0aa078540e" translate="yes" xml:space="preserve">
          <source>Match the regular expression limiting patterns without regard to letter case.</source>
          <target state="translated">大文字小文字に関係なく、正規表現の制限パターンを一致させます。</target>
        </trans-unit>
        <trans-unit id="1452c4b1c4eed7c80174fb8c82a8ed6f95d98c4d" translate="yes" xml:space="preserve">
          <source>Maximum delta depth, for blob and tree deltification. Default is 50.</source>
          <target state="translated">ブ ロ ブ と ツリーの差分化のための最大差分深さ。デフォルトは50です。</target>
        </trans-unit>
        <trans-unit id="384f40abc20254795ab29a564353f53402412c1e" translate="yes" xml:space="preserve">
          <source>Maximum number of branches to maintain active at once. See &amp;ldquo;Memory Utilization&amp;rdquo; below for details. Default is 5.</source>
          <target state="translated">一度にアクティブに維持するブランチの最大数。詳細については、以下の「メモリ使用率」を参照してください。デフォルトは5です。</target>
        </trans-unit>
        <trans-unit id="0a8681cfb7605cda2b80805ca7e930924afc3f52" translate="yes" xml:space="preserve">
          <source>Maximum number of bytes per thread to reserve for caching base objects that may be referenced by multiple deltified objects. By storing the entire decompressed base objects in a cache Git is able to avoid unpacking and decompressing frequently used base objects multiple times.</source>
          <target state="translated">複数の差分化されたオブジェクトが参照する可能性のあるベースオブジェクトをキャッシュするために確保する、スレッドあたりの最大バイト数。解凍されたベースオブジェクト全体をキャッシュに保存することで、Git は使用頻度の高いベースオブジェクトを何度も解凍したり解凍したりすることを避けることができます。</target>
        </trans-unit>
        <trans-unit id="5ba691ad2489c6a98bfddfb725c399a5433235ec" translate="yes" xml:space="preserve">
          <source>Maximum number of bytes to map simultaneously into memory from pack files. If Git needs to access more than this many bytes at once to complete an operation it will unmap existing regions to reclaim virtual address space within the process.</source>
          <target state="translated">パックファイルから同時にメモリにマップする最大バイト数。一度にこのバイト数以上のアクセスが必要な場合は、既存の領域のマッピングを解除してプロセス内の仮想アドレス空間を確保します。</target>
        </trans-unit>
        <trans-unit id="015780ae5eaf5a16460a6c6f6a47f9fd68665f6e" translate="yes" xml:space="preserve">
          <source>Maximum number of bytes to reserve for caching base objects that may be referenced by multiple deltified objects. By storing the entire decompressed base objects in a cache Git is able to avoid unpacking and decompressing frequently used base objects multiple times.</source>
          <target state="translated">複数の差分化されたオブジェクトが参照する可能性のあるベースオブジェクトをキャッシュするために確保する最大バイト数。解凍されたベースオブジェクト全体をキャッシュに格納することで、Git は使用頻度の高いベースオブジェクトを何度も解凍したり解凍したりすることを避けることができます。</target>
        </trans-unit>
        <trans-unit id="9639a9871e3fa301072f34b62bd6d8d1df5dfde8" translate="yes" xml:space="preserve">
          <source>Maximum number of concurrent clients, defaults to 32. Set it to zero for no limit.</source>
          <target state="translated">同時接続クライアントの最大数、デフォルトは 32 です。無制限にするにはゼロに設定します。</target>
        </trans-unit>
        <trans-unit id="3fca64028c3b9d66663fb33bbabf381bdeaeb020" translate="yes" xml:space="preserve">
          <source>Maximum size in bytes of the buffer used by smart HTTP transports when POSTing data to the remote system. For requests larger than this buffer size, HTTP/1.1 and Transfer-Encoding: chunked is used to avoid creating a massive pack file locally. Default is 1 MiB, which is sufficient for most requests.</source>
          <target state="translated">リモートシステムにデータを POST する際にスマート HTTP トランスポートが使用するバッファの最大サイズをバイト単位で指定します。このバッファサイズよりも大きなリクエストに対しては、ローカルに巨大なパックファイルを作成するのを避けるために、HTTP/1.1 および Transfer-Encoding:chunked が使用されます。デフォルトは 1 MiB で、ほとんどのリクエストにはこれで十分です。</target>
        </trans-unit>
        <trans-unit id="d63005f2c2b8f8c3239933e10d80e78d75fee39e" translate="yes" xml:space="preserve">
          <source>Maximum size of a blob that fast-import will attempt to create a delta for, expressed in bytes. The default is 512m (512 MiB). Some importers may wish to lower this on systems with constrained memory.</source>
          <target state="translated">fast-importがデルタを作成しようとするブロブの最大サイズをバイト単位で指定します。デフォルトは512m (512 MiB)です。メモリが制限されているシステムでは、この値を下げたいと思うインポーターもいるかもしれません。</target>
        </trans-unit>
        <trans-unit id="d3dd84835c1a4e2de21619e12a6eaaff0c2d1fd8" translate="yes" xml:space="preserve">
          <source>Maximum size of each output pack file. The size can be suffixed with &quot;k&quot;, &quot;m&quot;, or &quot;g&quot;. The minimum size allowed is limited to 1 MiB. If specified, multiple packfiles may be created, which also prevents the creation of a bitmap index. The default is unlimited, unless the config variable &lt;code&gt;pack.packSizeLimit&lt;/code&gt; is set.</source>
          <target state="translated">各出力パックファイルの最大サイズ。サイズの末尾には、「k」、「m」、または「g」を付けることができます。許可される最小サイズは1 MiBに制限されています。指定した場合、複数のパックファイルが作成される可能性があり、ビットマップインデックスの作成も妨げられます。構成変数 &lt;code&gt;pack.packSizeLimit&lt;/code&gt; が設定されていない限り、デフォルトは無制限です。</target>
        </trans-unit>
        <trans-unit id="b8685db9c67d15fcb99750ad6a0c6f6dc3e27c92" translate="yes" xml:space="preserve">
          <source>Maximum size of each output packfile. The default is unlimited.</source>
          <target state="translated">各出力パックファイルの最大サイズ。デフォルトは無制限です。</target>
        </trans-unit>
        <trans-unit id="ecff084a0c01e319db62c5b088c7a98c5cc26a2a" translate="yes" xml:space="preserve">
          <source>May be an unabbreviated ref name or a glob and may be specified multiple times. A warning will be issued for refs that do not exist, but a glob that does not match any refs is silently ignored.</source>
          <target state="translated">省略されていない ref 名またはグロブで、複数回指定できます。存在しない参照に対しては警告が発せられますが、どの参照にも一致しないグロブは静かに無視されます。</target>
        </trans-unit>
        <trans-unit id="706c83c32d28c2f1cb1aaafc37be7356f71e7631" translate="yes" xml:space="preserve">
          <source>May be set to a boolean value, or the string &lt;code&gt;if-asked&lt;/code&gt;. A true value causes all pushes to be GPG signed, as if &lt;code&gt;--signed&lt;/code&gt; is passed to &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;. The string &lt;code&gt;if-asked&lt;/code&gt; causes pushes to be signed if the server supports it, as if &lt;code&gt;--signed=if-asked&lt;/code&gt; is passed to &lt;code&gt;git push&lt;/code&gt;. A false value may override a value from a lower-priority config file. An explicit command-line flag always overrides this config option.</source>
          <target state="translated">ブール値または文字列 &lt;code&gt;if-asked&lt;/code&gt; に設定できます。 true値を指定すると、&lt;a href=&quot;git-push&quot;&gt;-- &lt;/a&gt; &lt;code&gt;--signed&lt;/code&gt; がgit-push [1]に渡されたかのように、すべてのプッシュがGPG署名されます。文字列 &lt;code&gt;if-asked&lt;/code&gt; は、サーバーがサポートしている場合、 &lt;code&gt;--signed=if-asked&lt;/code&gt; が &lt;code&gt;git push&lt;/code&gt; に渡されたかのようにプッシュに署名させます。 false値は、優先度の低い構成ファイルの値をオーバーライドする場合があります。明示的なコマンドラインフラグは、常にこの構成オプションをオーバーライドします。</target>
        </trans-unit>
        <trans-unit id="8555af2d5095b661ce8d37e9e0375fb4c8ea77d6" translate="yes" xml:space="preserve">
          <source>May be used to make sure all submodule commits used by the revisions to be pushed are available on a remote-tracking branch. If &lt;code&gt;check&lt;/code&gt; is used Git will verify that all submodule commits that changed in the revisions to be pushed are available on at least one remote of the submodule. If any commits are missing the push will be aborted and exit with non-zero status. If &lt;code&gt;on-demand&lt;/code&gt; is used all submodules that changed in the revisions to be pushed will be pushed. If on-demand was not able to push all necessary revisions it will also be aborted and exit with non-zero status. If &lt;code&gt;only&lt;/code&gt; is used all submodules will be recursively pushed while the superproject is left unpushed. A value of &lt;code&gt;no&lt;/code&gt; or using &lt;code&gt;--no-recurse-submodules&lt;/code&gt; can be used to override the push.recurseSubmodules configuration variable when no submodule recursion is required.</source>
          <target state="translated">プッシュされるリビジョンによって使用されるすべてのサブモジュールコミットがリモート追跡ブランチで利用可能であることを確認するために使用できます。場合は &lt;code&gt;check&lt;/code&gt; 使用されているGitはプッシュするリビジョンで変更されたすべてのサブモジュールのコミットは、リモート・サブモジュールの少なくとも一方で利用可能であることを確認します。コミットが欠落している場合、プッシュは中止され、ゼロ以外のステータスで終了します。 &lt;code&gt;on-demand&lt;/code&gt; が使用されている場合、プッシュされるリビジョンで変更されたすべてのサブモジュールがプッシュされます。オンデマンドで必要なすべてのリビジョンをプッシュできなかった場合も、中止され、ゼロ以外のステータスで終了します。場合 &lt;code&gt;only&lt;/code&gt; 使用されている親プロジェクトがunpushed残したまま、すべてのサブモジュールを再帰的にプッシュされます。 &lt;code&gt;no&lt;/code&gt; の値または &lt;code&gt;--no-recurse-submodules&lt;/code&gt; を使用 サブモジュールの再帰が不要な場合、push.recurseSubmodules構成変数をオーバーライドするために使用できます。</target>
        </trans-unit>
        <trans-unit id="8be2a61b9ad007dcdaebc339c9660a293e37ceee" translate="yes" xml:space="preserve">
          <source>Mbox file to split. If not given, the mbox is read from the standard input.</source>
          <target state="translated">分割するmboxファイル。指定されていない場合は、標準入力からmboxが読み込まれます。</target>
        </trans-unit>
        <trans-unit id="1ce7743133ea15a3c11834ae295610d6b0aca98e" translate="yes" xml:space="preserve">
          <source>Memory utilization</source>
          <target state="translated">メモリ使用率</target>
        </trans-unit>
        <trans-unit id="94804378bc64156caa1411beabf938d0cc1f334a" translate="yes" xml:space="preserve">
          <source>Merge a topic branch into the current branch, which resulted in a fast-forward.</source>
          <target state="translated">トピックブランチを現在のブランチにマージすると、早送りになりました。</target>
        </trans-unit>
        <trans-unit id="aa4cb5d8e33b071846e0985dfd9e8a73b7ff3b77" translate="yes" xml:space="preserve">
          <source>Merge branch &lt;code&gt;maint&lt;/code&gt; into the current branch, but do not make a new commit automatically:</source>
          <target state="translated">ブランチの &lt;code&gt;maint&lt;/code&gt; を現在のブランチにマージしますが、新しいコミットを自動的に行わないでください：</target>
        </trans-unit>
        <trans-unit id="36c2108053218bb1c9bd1daf5d80ef9e2b56153b" translate="yes" xml:space="preserve">
          <source>Merge branch &lt;code&gt;obsolete&lt;/code&gt; into the current branch, using &lt;code&gt;ours&lt;/code&gt; merge strategy:</source>
          <target state="translated">マージブランチ &lt;code&gt;obsolete&lt;/code&gt; 使用して、現在のブランチに、 &lt;code&gt;ours&lt;/code&gt; マージ戦略を：</target>
        </trans-unit>
        <trans-unit id="2340cae4ab971b09adab3732a6eccbc0f94439af" translate="yes" xml:space="preserve">
          <source>Merge branches &lt;code&gt;fixes&lt;/code&gt; and &lt;code&gt;enhancements&lt;/code&gt; on top of the current branch, making an octopus merge:</source>
          <target state="translated">現在のブランチの上にブランチの &lt;code&gt;fixes&lt;/code&gt; と &lt;code&gt;enhancements&lt;/code&gt; をマージし、タコをマージします。</target>
        </trans-unit>
        <trans-unit id="3b3fe151c69070e113efe45497e8fbe34f98eda0" translate="yes" xml:space="preserve">
          <source>Merge into the current branch the remote branch &lt;code&gt;next&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;next&lt;/code&gt; リモートブランチを現在のブランチにマージします。</target>
        </trans-unit>
        <trans-unit id="c5d9976d41384cd800a73252d5887846f7995334" translate="yes" xml:space="preserve">
          <source>Merge one patch into CVS</source>
          <target state="translated">1つのパッチをCVSにマージ</target>
        </trans-unit>
        <trans-unit id="ebf628d17763f2d1db5244a9d541825468f6e3f2" translate="yes" xml:space="preserve">
          <source>Merge one patch into CVS (-c and -w options). The working directory is within the Git Repo</source>
          <target state="translated">1 つのパッチを CVS にマージします (-c オプションと -w オプション)。作業ディレクトリは、Git Repo</target>
        </trans-unit>
        <trans-unit id="374bc1e6ce1c863c36094e824049bd53454731f0" translate="yes" xml:space="preserve">
          <source>Merge pending patches into CVS automatically &amp;mdash; only if you really know what you are doing</source>
          <target state="translated">保留中のパッチをCVSに自動的にマージします&amp;mdash;何をしているのか本当にわかっている場合のみ</target>
        </trans-unit>
        <trans-unit id="1ecf516cb34751fcee31d345dc521d62850b1084" translate="yes" xml:space="preserve">
          <source>Merge strategies</source>
          <target state="translated">マージ戦略</target>
        </trans-unit>
        <trans-unit id="6455bb1c3dd50961d850d4ec4f8b22adf354885c" translate="yes" xml:space="preserve">
          <source>Merge the given notes ref into the current notes ref. This will try to merge the changes made by the given notes ref (called &quot;remote&quot;) since the merge-base (if any) into the current notes ref (called &quot;local&quot;).</source>
          <target state="translated">与えられたノート ref を現在のノート ref にマージします。これは、与えられたノート ref (「リモート」と呼ばれる)がマージベース (もしあれば)以降に行った変更を、現在のノート ref (「ローカル」と呼ばれる)にマージしようとします。</target>
        </trans-unit>
        <trans-unit id="06a4a977ae422fbb370e91879e13703bae28bf9d" translate="yes" xml:space="preserve">
          <source>Merge tracking</source>
          <target state="translated">マージのトラッキング</target>
        </trans-unit>
        <trans-unit id="af8c9dbb2cf6a08b436fada56eb16ee91017d8ce" translate="yes" xml:space="preserve">
          <source>Merge workflow</source>
          <target state="translated">ワークフローのマージ</target>
        </trans-unit>
        <trans-unit id="01d28a50eda177ec75942bb24c131250cdadabfb" translate="yes" xml:space="preserve">
          <source>Merges</source>
          <target state="translated">Merges</target>
        </trans-unit>
        <trans-unit id="c4dada76f0f6e7dcbd827c4ba6bada46b3c6714c" translate="yes" xml:space="preserve">
          <source>Merges (to be discussed later), as well as operations such as &lt;code&gt;git reset&lt;/code&gt;, which change the currently checked-out commit, generally set ORIG_HEAD to the value HEAD had before the current operation.</source>
          <target state="translated">マージ（後で説明します）、および現在チェックアウトされているコミットを変更する &lt;code&gt;git reset&lt;/code&gt; などの操作は、通常、ORIG_HEADを現在の操作の前にHEADが持っていた値に設定します。</target>
        </trans-unit>
        <trans-unit id="376269fe69e269c1639bc7c223893145d88653cf" translate="yes" xml:space="preserve">
          <source>Merges are always included. However, their parent list is rewritten: Along each parent, prune away commits that are not included themselves. This results in</source>
          <target state="translated">マージは常に含まれています。ただし、親リストは書き換えられます。それぞれの親に沿って、それ自体が含まれていないコミットを削除します。その結果、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="6da92828bff93237c525d505f61963005fa8aa9b" translate="yes" xml:space="preserve">
          <source>Merges can be also made simpler by using smaller branches or by using many topic branches instead of only long version related branches.</source>
          <target state="translated">また、マージは、より小さなブランチを使用したり、長いバージョンに関連するブランチだけではなく、多くのトピックブランチを使用したりすることで、より簡単に行うことができます。</target>
        </trans-unit>
        <trans-unit id="18462046f484e3565df5821cdce8eadab95f1224" translate="yes" xml:space="preserve">
          <source>Merges have many advantages, so we try to solve as many problems as possible with merges alone. Cherry-picking is still occasionally useful; see &quot;Merging upwards&quot; below for an example.</source>
          <target state="translated">マージには多くの利点があるので、できるだけ多くの問題をマージだけで解決するようにしています。チェリーピッキングは今でも時々役に立ちます。</target>
        </trans-unit>
        <trans-unit id="40de0d4de887a374168bf79e72c7aa0fa4594d6e" translate="yes" xml:space="preserve">
          <source>Merging</source>
          <target state="translated">Merging</target>
        </trans-unit>
        <trans-unit id="31c92682cbfd6598c97a2306d8a83a0e953592eb" translate="yes" xml:space="preserve">
          <source>Merging and rebasing</source>
          <target state="translated">マージとリベース</target>
        </trans-unit>
        <trans-unit id="f2204607f23628214b6d42add29d21c7f2e29b95" translate="yes" xml:space="preserve">
          <source>Merging branches with differing checkin/checkout attributes</source>
          <target state="translated">チェックイン/チェックアウトの属性が異なるブランチのマージ</target>
        </trans-unit>
        <trans-unit id="c535f2db054f922c7b696495f8b89a913e2a11c4" translate="yes" xml:space="preserve">
          <source>Merging external work</source>
          <target state="translated">外部作業のマージ</target>
        </trans-unit>
        <trans-unit id="603157d894d36cb77fbe21d75b0d20a12dc01779" translate="yes" xml:space="preserve">
          <source>Merging inside a &lt;a href=&quot;#def_shallow_clone&quot;&gt;shallow clone&lt;/a&gt; will work as long as a merge base is in the recent history. Otherwise, it will be like merging unrelated histories and may have to result in huge conflicts. This limitation may make such a repository unsuitable to be used in merge based workflows.</source>
          <target state="translated">&lt;a href=&quot;#def_shallow_clone&quot;&gt;浅いクローン&lt;/a&gt;内でのマージは、マージベースが最近の履歴にある限り機能します。それ以外の場合は、無関係な履歴をマージするようなものであり、巨大な競合が発生する可能性があります。この制限により、そのようなリポジトリはマージベースのワークフローで使用するのに適さなくなる場合があります。</target>
        </trans-unit>
        <trans-unit id="ab26fbd41a8ed9c39ebd7d129433578a03343e81" translate="yes" xml:space="preserve">
          <source>Merging multiple trees</source>
          <target state="translated">複数の木をマージする</target>
        </trans-unit>
        <trans-unit id="f73ac93115d3cdadc50aebe7fa9b08f89899740b" translate="yes" xml:space="preserve">
          <source>Merging multiple trees, continued</source>
          <target state="translated">複数の木の結合、続き</target>
        </trans-unit>
        <trans-unit id="98b404243306169adb88696dc4ad2165a137c1ac" translate="yes" xml:space="preserve">
          <source>Merging tag</source>
          <target state="translated">タグのマージ</target>
        </trans-unit>
        <trans-unit id="1af53d3a2af732fec14191525698059a5e40b8d4" translate="yes" xml:space="preserve">
          <source>Merging two branches</source>
          <target state="translated">2つのブランチをマージする</target>
        </trans-unit>
        <trans-unit id="6153c9c2afc2b444427af54ff710f1f84e9dda45" translate="yes" xml:space="preserve">
          <source>Merging upwards</source>
          <target state="translated">上向きにマージ</target>
        </trans-unit>
        <trans-unit id="5f2cbd107037ed23248e5058a7a64cd6bae05468" translate="yes" xml:space="preserve">
          <source>Miscellaneous</source>
          <target state="translated">Miscellaneous</target>
        </trans-unit>
        <trans-unit id="ede02150d3611f561b342e50cd978f7d1c7b1d2a" translate="yes" xml:space="preserve">
          <source>Miscellaneous capabilities</source>
          <target state="translated">その他の機能</target>
        </trans-unit>
        <trans-unit id="5b0739f48e82ea34788c95cbd8a03adab72795db" translate="yes" xml:space="preserve">
          <source>Miscellaneous differences</source>
          <target state="translated">その他の違い</target>
        </trans-unit>
        <trans-unit id="68e2e957e53389b060cb16e85d086c46b6c88151" translate="yes" xml:space="preserve">
          <source>Missing From or In-Reply-To headers will be prompted for.</source>
          <target state="translated">Missing FromヘッダまたはIn-Reply-Toヘッダは、プロンプトが表示されます。</target>
        </trans-unit>
        <trans-unit id="00b61542d0211972bc61982931e3e8c50577c383" translate="yes" xml:space="preserve">
          <source>Modified content is represented by &quot;-&quot; lines (removing the old content) followed by &quot;+&quot; lines (adding the replacement content). You can prevent staging the modification by converting &quot;-&quot; lines to &quot; &quot;, and removing &quot;+&quot; lines. Beware that modifying only half of the pair is likely to introduce confusing changes to the index.</source>
          <target state="translated">変更された内容は、&quot;-&quot;行(古い内容を削除する)と &quot;+&quot;行(代替内容を追加する)で表されます。変更された内容は、&quot;-&quot;行を&quot; &quot;に変換し、&quot;+&quot;行を削除することで、ステージングを防ぐことができます。ペアの半分だけを変更すると、インデックスが混乱する可能性があるので注意してください。</target>
        </trans-unit>
        <trans-unit id="6e5a153f7d9724480c99f8d43544411a606a03ba" translate="yes" xml:space="preserve">
          <source>Modifies the index or directory cache. Each file mentioned is updated into the index and any &lt;code&gt;unmerged&lt;/code&gt; or &lt;code&gt;needs updating&lt;/code&gt; state is cleared.</source>
          <target state="translated">インデックスまたはディレクトリキャッシュを変更します。言及された各ファイルはインデックスに更新され、 &lt;code&gt;unmerged&lt;/code&gt; されていない、または &lt;code&gt;needs updating&lt;/code&gt; 状態はすべてクリアされます。</target>
        </trans-unit>
        <trans-unit id="f87d4010c94238df04ebfd441b3a0111f33d7a25" translate="yes" xml:space="preserve">
          <source>Modify behavior of the next command naming a &amp;lt;ref&amp;gt;. The only valid option is &lt;code&gt;no-deref&lt;/code&gt; to avoid dereferencing a symbolic ref.</source>
          <target state="translated">&amp;lt;ref&amp;gt;という名前の次のコマンドの動作を変更します。シンボリック参照の逆参照を回避するための唯一の有効なオプションは &lt;code&gt;no-deref&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="eeb79095663bd56bf370bd2096cd4a5ecc99b3a1" translate="yes" xml:space="preserve">
          <source>Modify some files, then add their updated contents to the index:</source>
          <target state="translated">いくつかのファイルを修正し、更新された内容をインデックスに追加します。</target>
        </trans-unit>
        <trans-unit id="19db1a3cc38a1c275e20ba3eb14f5761050f2bac" translate="yes" xml:space="preserve">
          <source>Modifying the index is easy:</source>
          <target state="translated">インデックスの修正は簡単です。</target>
        </trans-unit>
        <trans-unit id="3d6095a82dcd262f6e6b119640e8d9b20bcf7da2" translate="yes" xml:space="preserve">
          <source>More detail on the following is available from the &lt;a href=&quot;user-manual#git-concepts&quot;&gt;Git concepts chapter of the user-manual&lt;/a&gt; and &lt;a href=&quot;gitcore-tutorial&quot;&gt;gitcore-tutorial[7]&lt;/a&gt;.</source>
          <target state="translated">以下の詳細について&lt;a href=&quot;user-manual#git-concepts&quot;&gt;は、user-manual&lt;/a&gt;および&lt;a href=&quot;gitcore-tutorial&quot;&gt;gitcore-tutorial [7]&lt;/a&gt;のGitコンセプトの章を参照してください。</target>
        </trans-unit>
        <trans-unit id="06099ebf3c1fb2d228710b5b862871e1eab3c063" translate="yes" xml:space="preserve">
          <source>More generally, a branch that is created from a remote-tracking branch will pull by default from that branch. See the descriptions of the &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; and &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; options in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;, and the discussion of the &lt;code&gt;--track&lt;/code&gt; option in &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt;, to learn how to control these defaults.</source>
          <target state="translated">より一般的には、リモート追跡ブランチから作成されたブランチは、デフォルトでそのブランチからプルします。説明を参照してください &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; して &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; のオプション&lt;a href=&quot;git-config&quot;&gt;[1]はgit-config設定&lt;/a&gt;、およびの議論 &lt;code&gt;--track&lt;/code&gt; でオプション&lt;a href=&quot;git-checkout&quot;&gt;のgit-アウト[1]&lt;/a&gt;どのように学習し、これらのデフォルトを制御します。</target>
        </trans-unit>
        <trans-unit id="415ceff2cb011b2c5375c0d469dab2cba200eaed" translate="yes" xml:space="preserve">
          <source>More generally, among the two commits to compute the merge base from, one is specified by the first commit argument on the command line; the other commit is a (possibly hypothetical) commit that is a merge across all the remaining commits on the command line.</source>
          <target state="translated">より一般的には、マージベースを計算する 2 つのコミットのうち 1 つはコマンドラインの最初のコミット引数で指定され、もう 1 つのコミットはコマンドライン上の残りのすべてのコミットをマージした (仮定の)コミットです。</target>
        </trans-unit>
        <trans-unit id="816cda5b46035bd1542e1775969151ec4a09cada" translate="yes" xml:space="preserve">
          <source>More importantly, it allows the update of a ref file to follow these symbolic pointers, whether they are symlinks or these &quot;regular file symbolic refs&quot;. It follows &lt;strong&gt;real&lt;/strong&gt; symlinks only if they start with &quot;refs/&quot;: otherwise it will just try to read them and update them as a regular file (i.e. it will allow the filesystem to follow them, but will overwrite such a symlink to somewhere else with a regular filename).</source>
          <target state="translated">さらに重要なことは、シンボリックリンクであろうと「通常のファイルシンボリック参照」であろうと、これらのシンボリックポインターに従うrefファイルの更新を可能にします。&quot;refs /&quot;で始まる場合にのみ、&lt;strong&gt;実際の&lt;/strong&gt;シンボリックリンクをたどります。それ以外の場合は、それらを読み取って通常のファイルとして更新しようとします（つまり、ファイルシステムがそれらをたどることができますが、そのようなシンボリックリンクを他の場所に上書きします通常のファイル名）。</target>
        </trans-unit>
        <trans-unit id="2be26ffe68463b96abc5601cef9bdbafbf2f631d" translate="yes" xml:space="preserve">
          <source>More interestingly, you can also give &lt;code&gt;git diff-tree&lt;/code&gt; the &lt;code&gt;--pretty&lt;/code&gt; flag, which tells it to also show the commit message and author and date of the commit, and you can tell it to show a whole series of diffs. Alternatively, you can tell it to be &quot;silent&quot;, and not show the diffs at all, but just show the actual commit message.</source>
          <target state="translated">さらに興味深いことに、 &lt;code&gt;git diff-tree&lt;/code&gt; に &lt;code&gt;--pretty&lt;/code&gt; フラグを指定して、コミットメッセージと作成者とコミットの日付も表示するように指示したり、一連の差分全体を表示するように指示したりできます。あるいは、それを「サイレント」にして、差分をまったく表示せず、実際のコミットメッセージを表示するように指示することもできます。</target>
        </trans-unit>
        <trans-unit id="854ef0fd2eba012b7c2e6ecb33388db153e60f9a" translate="yes" xml:space="preserve">
          <source>More on recovery from repository corruption. See: &lt;a href=&quot;https://lore.kernel.org/git/Pine.LNX.4.64.0702272039540.12485@woody.linux-foundation.org/&quot;&gt;https://lore.kernel.org/git/Pine.LNX.4.64.0702272039540.12485@woody.linux-foundation.org/&lt;/a&gt;&lt;a href=&quot;https://lore.kernel.org/git/Pine.LNX.4.64.0702141033400.3604@woody.linux-foundation.org/&quot;&gt;https://lore.kernel.org/git/Pine.LNX.4.64.0702141033400.3604@woody.linux-foundation.org/&lt;/a&gt;</source>
          <target state="translated">リポジトリの破損からの回復の詳細。参照：&lt;a href=&quot;https://lore.kernel.org/git/Pine.LNX.4.64.0702272039540.12485@woody.linux-foundation.org/&quot;&gt;https&lt;/a&gt; : //lore.kernel.org/git/Pine.LNX.4.64.0702272039540.12485@woody.linux-foundation.org/ &lt;a href=&quot;https://lore.kernel.org/git/Pine.LNX.4.64.0702141033400.3604@woody.linux-foundation.org/&quot;&gt;https://lore.kernel.org/git/Pine.LNX.4.64.0702141033400.3604@ woody.linux-foundation.org/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e1784c94f3b7a373b03c0ae45229574de43eee20" translate="yes" xml:space="preserve">
          <source>More precisely, &lt;code&gt;git pull&lt;/code&gt; runs &lt;code&gt;git fetch&lt;/code&gt; with the given parameters and calls &lt;code&gt;git merge&lt;/code&gt; to merge the retrieved branch heads into the current branch. With &lt;code&gt;--rebase&lt;/code&gt;, it runs &lt;code&gt;git rebase&lt;/code&gt; instead of &lt;code&gt;git merge&lt;/code&gt;.</source>
          <target state="translated">より正確には、 &lt;code&gt;git pull&lt;/code&gt; は指定されたパラメーターで &lt;code&gt;git fetch&lt;/code&gt; を実行し、 &lt;code&gt;git merge&lt;/code&gt; を呼び出して、取得したブランチヘッドを現在のブランチにマージします。 &lt;code&gt;--rebase&lt;/code&gt; 、それが実行されます &lt;code&gt;git rebase&lt;/code&gt; の代わりに &lt;code&gt;git merge&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="17f51f170751975b2cc4764665c6e712fb67447f" translate="yes" xml:space="preserve">
          <source>Most CVS command arguments that read CVS tags or revision numbers (typically -r) work, and also support any git refspec (tag, branch, commit ID, etc). However, CVS revision numbers for non-default branches are not well emulated, and cvs log does not show tags or branches at all. (Non-main-branch CVS revision numbers superficially resemble CVS revision numbers, but they actually encode a git commit ID directly, rather than represent the number of revisions since the branch point.)</source>
          <target state="translated">CVS タグやリビジョン番号 (通常は -r)を読み取るほとんどの CVS コマンド引数は動作しますし、git の refspec (タグ、ブランチ、コミット ID など)もサポートしています。しかし、デフォルトではないブランチの CVS リビジョン番号はうまくエミュレートされておらず、cvs log はタグやブランチを全く表示しません。(非メインブランチの CVS リビジョン番号は表面的には CVS リビジョン番号に似ていますが、実際には git のコミット ID を直接エンコードしたもので、ブランチポイント以降のリビジョン数を表すものではありません)。</target>
        </trans-unit>
        <trans-unit id="880f481ef12ec663b5ff4186eb50766022add75f" translate="yes" xml:space="preserve">
          <source>Most bottlenecks appear to be in foreign source data access (the source just cannot extract revisions fast enough) or disk IO (fast-import writes as fast as the disk will take the data). Imports will run faster if the source data is stored on a different drive than the destination Git repository (due to less IO contention).</source>
          <target state="translated">ほとんどのボトルネックは、外部からのソースデータへのアクセス (ソース側がリビジョンを高速に抽出できない)あるいはディスクの IO (ディスクがデータを取得するのと同じくらいの速さでインポートの書き込みを行う)にあるようです。移行元のデータが移行先の Git リポジトリとは別のドライブに保存されている場合は、インポートの実行速度が速くなります (IO の競合が少なくなるからです)。</target>
        </trans-unit>
        <trans-unit id="b1a743b45e6efbd5b49b8c3c8d73ad9b477276e1" translate="yes" xml:space="preserve">
          <source>Most commits have only one parent, but it is also common for a commit to have multiple parents. In that case the commit represents a merge, with the parent references pointing to the heads of the merged branches.</source>
          <target state="translated">ほとんどのコミットの親はひとつだけですが、複数の親を持つこともよくあります。この場合、コミットはマージを表し、親参照はマージされたブランチの先頭を指します。</target>
        </trans-unit>
        <trans-unit id="6e0466db6c595523512aab889a71c0ecc693c19a" translate="yes" xml:space="preserve">
          <source>Most hosting providers use a single SSH account for pushing; that is, all users push to the &lt;code&gt;git&lt;/code&gt; account (e.g., &lt;code&gt;git@git.example.org&lt;/code&gt;). If that&amp;rsquo;s the case for your provider, you can set up multiple aliases in SSH to make it clear which key pair to use. For example, you could write something like the following in &lt;code&gt;~/.ssh/config&lt;/code&gt;, substituting the proper private key file:</source>
          <target state="translated">ほとんどのホスティングプロバイダーは、プッシュに単一のSSHアカウントを使用します。つまり、すべてのユーザーが &lt;code&gt;git&lt;/code&gt; アカウント（例： &lt;code&gt;git@git.example.org&lt;/code&gt; ）にプッシュします。プロバイダーの場合は、SSHで複数のエイリアスを設定して、使用するキーペアを明確にすることができます。たとえば、 &lt;code&gt;~/.ssh/config&lt;/code&gt; に次のようなものを記述して、適切な秘密鍵ファイルに置き換えることができます。</target>
        </trans-unit>
        <trans-unit id="4d50eced4caaa6d0cca3ee6a1e2e2e07d0d5849b" translate="yes" xml:space="preserve">
          <source>Most importantly, merging works at the branch level, while cherry-picking works at the commit level. This means that a merge can carry over the changes from 1, 10, or 1000 commits with equal ease, which in turn means the workflow scales much better to a large number of contributors (and contributions). Merges are also easier to understand because a merge commit is a &quot;promise&quot; that all changes from all its parents are now included.</source>
          <target state="translated">最も重要なことは、マージはブランチレベルで動作するのに対し、チェリーピックはコミットレベルで動作するということです。つまり、マージでは 1 コミット、10 コミット、1000 コミットの変更を同じように簡単に引き継ぐことができ、多くの貢献者 (と貢献者)に向けてワークフローを拡張することができます。マージはまた、親コミットからのすべての変更が含まれているという「約束」でもあるので、理解しやすくなります。</target>
        </trans-unit>
        <trans-unit id="2e130c2e2dd2a16594642aa625e1fc3c4df26608" translate="yes" xml:space="preserve">
          <source>Most of features are configured via &lt;code&gt;%feature&lt;/code&gt; hash; however some of extra gitweb features can be turned on and configured using variables described below. This list beside configuration variables that control how gitweb looks does contain variables configuring administrative side of gitweb (e.g. cross-site scripting prevention; admittedly this as side effect affects how &quot;summary&quot; pages look like, or load limiting).</source>
          <target state="translated">ほとんどの機能は &lt;code&gt;%feature&lt;/code&gt; ハッシュを介して構成されます。ただし、追加のgitweb機能のいくつかは、以下で説明する変数を使用してオンにして構成することができます。gitwebの外観を制御する構成変数の横にあるこのリストには、gitwebの管理面を構成する変数が含まれています（たとえば、クロスサイトスクリプティングの防止。副作用として、これは「概要」ページの外観や負荷制限に影響を与えるためです）。</target>
        </trans-unit>
        <trans-unit id="12c479c9b5f1b05779ca1427f8469c4d0c8e41b4" translate="yes" xml:space="preserve">
          <source>Most of what &lt;code&gt;git rev-list&lt;/code&gt; did is contained in &lt;code&gt;revision.c&lt;/code&gt; and &lt;code&gt;revision.h&lt;/code&gt;. It wraps the options in a struct named &lt;code&gt;rev_info&lt;/code&gt;, which controls how and what revisions are walked, and more.</source>
          <target state="translated">&lt;code&gt;git rev-list&lt;/code&gt; が行ったことのほとんどは、 &lt;code&gt;revision.c&lt;/code&gt; と &lt;code&gt;revision.h&lt;/code&gt; に含まれています。オプションを &lt;code&gt;rev_info&lt;/code&gt; という名前の構造体にラップします。これは、どのリビジョンをどのように、どのリビジョンをたどるかなどを制御します。</target>
        </trans-unit>
        <trans-unit id="9ceb817bd0e340cfd6e3a665612ec974c7873cd6" translate="yes" xml:space="preserve">
          <source>Most operations that add an object to the database update the modification time of the object if it is already present so that #1 applies.</source>
          <target state="translated">オブジェクトをデータベースに追加するほとんどの操作は、オブジェクトが既に存在する場合には、#1が適用されるようにオブジェクトの変更時刻を更新します。</target>
        </trans-unit>
        <trans-unit id="ed4a3f36c4746567049b5d83d49f91438e7cd1fa" translate="yes" xml:space="preserve">
          <source>Most projects also use &lt;a href=&quot;#def_tag&quot;&gt;tags&lt;/a&gt;. Tags, like heads, are references into the project&amp;rsquo;s history, and can be listed using the &lt;a href=&quot;git-tag&quot;&gt;git-tag[1]&lt;/a&gt; command:</source>
          <target state="translated">ほとんどのプロジェクトでも&lt;a href=&quot;#def_tag&quot;&gt;タグを&lt;/a&gt;使用しています。ヘッドと同様に、タグはプロジェクトの履歴への参照であり、&lt;a href=&quot;git-tag&quot;&gt;git-tag [1]&lt;/a&gt;コマンドを使用してリストできます。</target>
        </trans-unit>
        <trans-unit id="6e9a1bc6364ad2c889e7f09c69628c8251c67662" translate="yes" xml:space="preserve">
          <source>Most projects with multiple contributors (such as the Linux kernel, or Git itself) have frequent merges, and &lt;code&gt;gitk&lt;/code&gt; does a better job of visualizing their history. For example,</source>
          <target state="translated">複数のコントリビューター（LinuxカーネルやGit自体など）を持つほとんどのプロジェクトは頻繁にマージされ、 &lt;code&gt;gitk&lt;/code&gt; はその履歴を視覚化するのに優れています。例えば、</target>
        </trans-unit>
        <trans-unit id="b110af03cd46bd74e1684a2cb53fb12fe52de561" translate="yes" xml:space="preserve">
          <source>Mostly a synonym to &lt;a href=&quot;#def_shallow_repository&quot;&gt;shallow repository&lt;/a&gt; but the phrase makes it more explicit that it was created by running &lt;code&gt;git clone --depth=&amp;hellip;​&lt;/code&gt; command.</source>
          <target state="translated">大抵の同義語&lt;a href=&quot;#def_shallow_repository&quot;&gt;浅いリポジトリ&lt;/a&gt;が、フレーズは、それが実行することによって作成されたこと、それがより明確になり &lt;code&gt;git clone --depth=&amp;hellip;​&lt;/code&gt; コマンドを。</target>
        </trans-unit>
        <trans-unit id="0a0252ca3dca0dd6561eccb6a1ba0495bf433801" translate="yes" xml:space="preserve">
          <source>Mostly a synonym to &lt;a href=&quot;#def_shallow_repository&quot;&gt;shallow repository&lt;/a&gt; but the phrase makes it more explicit that it was created by running &lt;code&gt;git clone --depth=...&lt;/code&gt; command.</source>
          <target state="translated">ほとんどの場合、&lt;a href=&quot;#def_shallow_repository&quot;&gt;浅いリポジトリの&lt;/a&gt;同義語ですが、このフレーズは、 &lt;code&gt;git clone --depth=...&lt;/code&gt; コマンドを実行して作成されたことをより明確にします。</target>
        </trans-unit>
        <trans-unit id="3a5117e8beb61f9ec394ef9854333d01751bcf99" translate="yes" xml:space="preserve">
          <source>Mounting one repository inside another</source>
          <target state="translated">リポジトリを別のリポジトリにマウントする</target>
        </trans-unit>
        <trans-unit id="9dfd3ade6b1a6694324bf4f4adc30f26dd2cc430" translate="yes" xml:space="preserve">
          <source>Move a working tree to a new location. Note that the main working tree or linked working trees containing submodules cannot be moved with this command. (The &lt;code&gt;git worktree repair&lt;/code&gt; command, however, can reestablish the connection with linked working trees if you move the main working tree manually.)</source>
          <target state="translated">作業ツリーを新しい場所に移動します。このコマンドでは、メイン作業ツリーまたはサブモジュールを含むリンクされた作業ツリーを移動できないことに注意してください。（ただし、 &lt;code&gt;git worktree repair&lt;/code&gt; コマンドは、メインの作業ツリーを手動で移動すると、リンクされた作業ツリーとの接続を再確立できます。）</target>
        </trans-unit>
        <trans-unit id="437db9b7f03fcf9c59c19e8599b81a4181786550" translate="yes" xml:space="preserve">
          <source>Move a working tree to a new location. Note that the main working tree or linked working trees containing submodules cannot be moved.</source>
          <target state="translated">作業ツリーを新しい場所に移動します。メインの作業ツリーやサブモジュールを含むリンクされた作業ツリーは移動できないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="00451deb449902283a1a1b09ee616f563047050b" translate="yes" xml:space="preserve">
          <source>Move objects and refs by archive</source>
          <target state="translated">アーカイブによるオブジェクトや参照先の移動</target>
        </trans-unit>
        <trans-unit id="0a2aa584391bc2ed097c1ace071233493faa0978" translate="yes" xml:space="preserve">
          <source>Move or rename a file, a directory, or a symlink</source>
          <target state="translated">ファイル、ディレクトリ、シンボリックリンクの移動や名前の変更</target>
        </trans-unit>
        <trans-unit id="4bc0abe3ae87a3007e76abb67d150957939b61b8" translate="yes" xml:space="preserve">
          <source>Move or rename a file, directory or symlink.</source>
          <target state="translated">ファイル、ディレクトリ、シンボリックリンクを移動したり、名前を変更したりします。</target>
        </trans-unit>
        <trans-unit id="24cb8f062e449dc4167b50460e2e7341fe4e0aa6" translate="yes" xml:space="preserve">
          <source>Move/rename a branch and the corresponding reflog.</source>
          <target state="translated">ブランチとそれに対応するリブログを移動/名前を付けます。</target>
        </trans-unit>
        <trans-unit id="86a2fcc8fa8d4ad8c3c46b9d3e5182feb14f1b60" translate="yes" xml:space="preserve">
          <source>Moved lines are not highlighted.</source>
          <target state="translated">移動した行はハイライトされません。</target>
        </trans-unit>
        <trans-unit id="e5cbd47a10df638d21a9258d79ed6bd371f01027" translate="yes" xml:space="preserve">
          <source>Moved lines of code are colored differently. It can be changed by the &lt;code&gt;diff.colorMoved&lt;/code&gt; configuration setting. The &amp;lt;mode&amp;gt; defaults to &lt;code&gt;no&lt;/code&gt; if the option is not given and to &lt;code&gt;zebra&lt;/code&gt; if the option with no mode is given. The mode must be one of:</source>
          <target state="translated">移動したコード行の色が異なります。 &lt;code&gt;diff.colorMoved&lt;/code&gt; 構成設定で変更できます。オプションが指定されてい &lt;code&gt;no&lt;/code&gt; 場合、&amp;lt;mode&amp;gt;のデフォルトはnoであり、モードのないオプションが指定されている場合は &lt;code&gt;zebra&lt;/code&gt; です。モードは次のいずれかである必要があります。</target>
        </trans-unit>
        <trans-unit id="b99084289befcccb3b6f25bb5a902159aaa2283b" translate="yes" xml:space="preserve">
          <source>Moved lines of code are colored differently. The &amp;lt;mode&amp;gt; defaults to &lt;code&gt;no&lt;/code&gt; if the option is not given and to &lt;code&gt;zebra&lt;/code&gt; if the option with no mode is given. The mode must be one of:</source>
          <target state="translated">移動したコード行の色が異なります。オプションが指定されてい &lt;code&gt;no&lt;/code&gt; 場合、&amp;lt;mode&amp;gt;のデフォルトはnoであり、モードのないオプションが指定されている場合は &lt;code&gt;zebra&lt;/code&gt; です。モードは次のいずれかである必要があります。</target>
        </trans-unit>
        <trans-unit id="b9c1e9c13eb039f68657e5a15bbd12085ba143c2" translate="yes" xml:space="preserve">
          <source>Moving a submodule using a gitfile (which means they were cloned with a Git version 1.7.8 or newer) will update the gitfile and core.worktree setting to make the submodule work in the new location. It also will attempt to update the submodule.&amp;lt;name&amp;gt;.path setting in the &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt; file and stage that file (unless -n is used).</source>
          <target state="translated">gitfile（Gitバージョン1.7.8以降で複製されたもの）を使用してサブモジュールを移動すると、gitfileとcore.worktree設定が更新され、サブモジュールが新しい場所で機能するようになります。また、&lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5]&lt;/a&gt;ファイルのsubmodule。&amp;lt;name&amp;gt; .path設定を更新し、そのファイルをステージングします（-nが使用されている場合を除く）。</target>
        </trans-unit>
        <trans-unit id="64f4589d8b3cd6346365a117e7caa3c7d877c770" translate="yes" xml:space="preserve">
          <source>Mua-specific hints</source>
          <target state="translated">ムア固有のヒント</target>
        </trans-unit>
        <trans-unit id="c811c6583f834ffbc46d39586b81b1cb3e49b3e5" translate="yes" xml:space="preserve">
          <source>Multi-pack-index (midx) files have the following format:</source>
          <target state="translated">マルチパックインデックス(midx)ファイルの形式は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="53148ea4bd03c54715064a8f67e0cc8cc140f85c" translate="yes" xml:space="preserve">
          <source>Multiple --notes options can be combined to control which notes are being displayed. Examples: &quot;--notes=foo&quot; will show only notes from &quot;refs/notes/foo&quot;; &quot;--notes=foo --notes&quot; will show both notes from &quot;refs/notes/foo&quot; and from the default notes ref(s).</source>
          <target state="translated">複数の --notes オプションを組み合わせて、どのノートを表示するかを制御することができます。例えば、&quot;--notes=foo &quot;は &quot;refs/notes/foo &quot;のノートのみを表示します。&quot;--notes=foo&quot; は &quot;refs/notes/foo&quot; のノートのみを表示し、&quot;--notes=foo --notes&quot; は &quot;refs/notes/foo&quot; とデフォルトのノート ref(複数可)の両方を表示します。</target>
        </trans-unit>
        <trans-unit id="63667e9cd419f9751274dd2f16bda1512b373262" translate="yes" xml:space="preserve">
          <source>Multiple &lt;code&gt;--filter=&lt;/code&gt; flags can be specified to combine filters. Only objects which are accepted by every filter are included.</source>
          <target state="translated">複数の &lt;code&gt;--filter=&lt;/code&gt; フラグを指定して、フィルターを組み合わせることができます。すべてのフィルターで受け入れられるオブジェクトのみが含まれます。</target>
        </trans-unit>
        <trans-unit id="dc96f8ef1ccc109ff4dae28503fa1d96c62fb1de" translate="yes" xml:space="preserve">
          <source>Multiple checkout in general is still experimental, and the support for submodules is incomplete. It is NOT recommended to make multiple checkouts of a superproject.</source>
          <target state="translated">一般的なマルチチェックアウトはまだ実験的なものであり、サブモジュールのサポートは不完全です。スーパープロジェクトの複数チェックアウトは推奨されていません。</target>
        </trans-unit>
        <trans-unit id="5a07b93df04fb253e2e899a192e36f3454a882cd" translate="yes" xml:space="preserve">
          <source>Multiple fetch, branches, and tags keys are supported:</source>
          <target state="translated">複数のフェッチ、ブランチ、タグキーをサポートしています。</target>
        </trans-unit>
        <trans-unit id="279d7da4653c2486ef148e9e285812a9ab391b1e" translate="yes" xml:space="preserve">
          <source>Multiple lines can be added to an option by using the &lt;code&gt;--add&lt;/code&gt; option. If you want to update or unset an option which can occur on multiple lines, a &lt;code&gt;value-pattern&lt;/code&gt; (which is an extended regular expression, unless the &lt;code&gt;--fixed-value&lt;/code&gt; option is given) needs to be given. Only the existing values that match the pattern are updated or unset. If you want to handle the lines that do &lt;strong&gt;not&lt;/strong&gt; match the pattern, just prepend a single exclamation mark in front (see also &lt;a href=&quot;#EXAMPLES&quot;&gt;EXAMPLES&lt;/a&gt;), but note that this only works when the &lt;code&gt;--fixed-value&lt;/code&gt; option is not in use.</source>
          <target state="translated">&lt;code&gt;--add&lt;/code&gt; オプションを使用すると、オプションに複数の行を追加できます。複数行で発生する可能性のあるオプションを更新または設定解除する場合は、 &lt;code&gt;value-pattern&lt;/code&gt; （ &lt;code&gt;--fixed-value&lt;/code&gt; オプションが指定されていない限り、拡張正規表現）を指定する必要があります。パターンに一致する既存の値のみが更新または設定解除されます。パターンに一致し&lt;strong&gt;ない&lt;/strong&gt;行を処理する場合は、前に1つの感嘆符を &lt;code&gt;--fixed-value&lt;/code&gt; だけです（&lt;a href=&quot;#EXAMPLES&quot;&gt;例&lt;/a&gt;も参照）。ただし、これは--fixed-valueオプションが使用されていない場合にのみ機能することに注意してください。</target>
        </trans-unit>
        <trans-unit id="b46275ca6ba0af124488d22d1e877279bfe2e6c0" translate="yes" xml:space="preserve">
          <source>Multiple lines can be added to an option by using the &lt;code&gt;--add&lt;/code&gt; option. If you want to update or unset an option which can occur on multiple lines, a POSIX regexp &lt;code&gt;value_regex&lt;/code&gt; needs to be given. Only the existing values that match the regexp are updated or unset. If you want to handle the lines that do &lt;strong&gt;not&lt;/strong&gt; match the regex, just prepend a single exclamation mark in front (see also &lt;a href=&quot;#EXAMPLES&quot;&gt;EXAMPLES&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;--add&lt;/code&gt; オプションを使用すると、オプションに複数の行を追加できます。複数の行で発生する可能性があるオプションを更新または設定解除する場合は、POSIX regexp &lt;code&gt;value_regex&lt;/code&gt; を指定する必要があります。正規表現に一致する既存の値のみが更新または設定解除されます。正規表現に一致し&lt;strong&gt;ない&lt;/strong&gt;行を処理する場合は、先頭に感嘆符を1つ追加するだけです（「&lt;a href=&quot;#EXAMPLES&quot;&gt;例&lt;/a&gt;」も参照）。</target>
        </trans-unit>
        <trans-unit id="77c43675935243a813626f8da7cb046544167112" translate="yes" xml:space="preserve">
          <source>Multiple tags on the same revision are not imported.</source>
          <target state="translated">同じリビジョンの複数のタグはインポートされません。</target>
        </trans-unit>
        <trans-unit id="f2beb5df6d3d8f2a372e3411ba76c2a81700ed4b" translate="yes" xml:space="preserve">
          <source>Multiple values may be given to the &lt;code&gt;man.viewer&lt;/code&gt; configuration variable. Their corresponding programs will be tried in the order listed in the configuration file.</source>
          <target state="translated">&lt;code&gt;man.viewer&lt;/code&gt; 構成変数に複数の値を指定できます。対応するプログラムは、構成ファイルにリストされている順序で試行されます。</target>
        </trans-unit>
        <trans-unit id="ee6ae3f9558f190018d900b972ec0dd86c3ef0ee" translate="yes" xml:space="preserve">
          <source>Munging the diff output</source>
          <target state="translated">デフ出力をマンネリ化</target>
        </trans-unit>
        <trans-unit id="31284f7dc1d9489b6ba33462518d05bce29455ee" translate="yes" xml:space="preserve">
          <source>Must be a blob id</source>
          <target state="translated">ブロブIDである必要があります。</target>
        </trans-unit>
        <trans-unit id="bab4c6d734b3b13c2268e7fc81c79c9b99eef1dd" translate="yes" xml:space="preserve">
          <source>NORMAL Format</source>
          <target state="translated">ノーマルフォーマット</target>
        </trans-unit>
        <trans-unit id="4b5d099fcd6efcc01a4251de7ab2ddb7c47dd96b" translate="yes" xml:space="preserve">
          <source>NOTE! &lt;code&gt;git checkout-index&lt;/code&gt; normally refuses to overwrite old files, so if you have an old version of the tree already checked out, you will need to use the &lt;code&gt;-f&lt;/code&gt; flag ('before' the &lt;code&gt;-a&lt;/code&gt; flag or the filename) to 'force' the checkout.</source>
          <target state="translated">注意！ &lt;code&gt;git checkout-index&lt;/code&gt; は通常、古いファイルの上書きを拒否するため、古いバージョンのツリーがすでにチェックアウトされている場合は、 &lt;code&gt;-f&lt;/code&gt; フラグ（「 &lt;code&gt;-a&lt;/code&gt; フラグの前」またはファイル名）を使用して「強制」する必要があります。チェックアウト。</target>
        </trans-unit>
        <trans-unit id="85ffa1dd083241144d9fbe2b1d63ba53159cc3e5" translate="yes" xml:space="preserve">
          <source>NOTE! &lt;code&gt;git checkout-index&lt;/code&gt; normally refuses to overwrite old files, so if you have an old version of the tree already checked out, you will need to use the &lt;code&gt;-f&lt;/code&gt; flag (&lt;code&gt;before&lt;/code&gt; the &lt;code&gt;-a&lt;/code&gt; flag or the filename) to &lt;code&gt;force&lt;/code&gt; the checkout.</source>
          <target state="translated">注意！ &lt;code&gt;git checkout-index&lt;/code&gt; 、通常、あなたが木既にチェックアウトの古いバージョンを持っているのであれば、古いファイルを上書きすることを拒否し、あなたが使用する必要があります &lt;code&gt;-f&lt;/code&gt; （フラグを &lt;code&gt;before&lt;/code&gt; &lt;code&gt;-a&lt;/code&gt; するフラグまたはファイル名） &lt;code&gt;force&lt;/code&gt; チェックアウトを。</target>
        </trans-unit>
        <trans-unit id="1264e842b1d5e884b1bcd9c56e546555c80966fe" translate="yes" xml:space="preserve">
          <source>NOTE! A &lt;code&gt;--remove&lt;/code&gt; flag does 'not' mean that subsequent filenames will necessarily be removed: if the files still exist in your directory structure, the index will be updated with their new status, not removed. The only thing &lt;code&gt;--remove&lt;/code&gt; means is that update-index will be considering a removed file to be a valid thing, and if the file really does not exist any more, it will update the index accordingly.</source>
          <target state="translated">注意！ &lt;code&gt;--remove&lt;/code&gt; ファイルがまだあなたのディレクトリ構造に存在する場合、インデックスは削除されません、彼らの新しい状態で更新されます。フラグは、後続のファイル名は必ず削除されることを意味するもの「ではない」ん。唯一の &lt;code&gt;--remove&lt;/code&gt; は、update-indexが削除されたファイルを有効なものと見なし、ファイルが実際に存在しなくなった場合に、それに応じてインデックスを更新することを意味します。</target>
        </trans-unit>
        <trans-unit id="14b973ba3566912be86ce74a38691b683bb1cd64" translate="yes" xml:space="preserve">
          <source>NOTE! A &lt;code&gt;--remove&lt;/code&gt; flag does &lt;code&gt;not&lt;/code&gt; mean that subsequent filenames will necessarily be removed: if the files still exist in your directory structure, the index will be updated with their new status, not removed. The only thing &lt;code&gt;--remove&lt;/code&gt; means is that update-index will be considering a removed file to be a valid thing, and if the file really does not exist any more, it will update the index accordingly.</source>
          <target state="translated">注意！ &lt;code&gt;--remove&lt;/code&gt; フラグがない &lt;code&gt;not&lt;/code&gt; ファイルがまだあなたのディレクトリ構造に存在する場合、インデックスは削除されません、彼らの新しい状態で更新されます。その後のファイル名は必ず削除されることを意味します。 &lt;code&gt;--remove&lt;/code&gt; が意味する唯一のことは、update-indexが削除されたファイルを有効なものと見なし、ファイルが実際に存在しなくなった場合、それに応じてインデックスを更新することです。</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="cab1b18ac6c645752b07db74b58a821d43db7033" translate="yes" xml:space="preserve">
          <source>Name for the new branch.</source>
          <target state="translated">新しいブランチの名前。</target>
        </trans-unit>
        <trans-unit id="ae3aefe579fe0e7749a842bc31610ab7a07dfe4c" translate="yes" xml:space="preserve">
          <source>Name of a HTML file which, if it exists, is included on the gitweb projects overview page (&quot;projects_list&quot; view). Relative to the directory containing the gitweb.cgi script. Default value can be adjusted during build time using &lt;code&gt;GITWEB_HOMETEXT&lt;/code&gt; variable. By default set to &lt;code&gt;indextext.html&lt;/code&gt;.</source>
          <target state="translated">gitwebプロジェクトの概要ページ（ &quot;projects_list&quot;ビュー）に含まれているHTMLファイルの名前。gitweb.cgiスクリプトを含むディレクトリに対して相対的です。デフォルト値は、 &lt;code&gt;GITWEB_HOMETEXT&lt;/code&gt; 変数を使用してビルド時に調整できます。デフォルトでは &lt;code&gt;indextext.html&lt;/code&gt; に設定されています。</target>
        </trans-unit>
        <trans-unit id="b26ce2bab88403572eb261078ddb7db93d3d704e" translate="yes" xml:space="preserve">
          <source>Name of a file with HTML to be included at the bottom of each page. Relative to the directory containing the &lt;code&gt;gitweb.cgi&lt;/code&gt; script. Can be set using &lt;code&gt;GITWEB_SITE_FOOTER&lt;/code&gt; at build time. No default value.</source>
          <target state="translated">各ページの下部に含めるHTMLを含むファイルの名前。 &lt;code&gt;gitweb.cgi&lt;/code&gt; スクリプトを含むディレクトリに対して相対的です。ビルド時に &lt;code&gt;GITWEB_SITE_FOOTER&lt;/code&gt; を使用して設定できます。デフォルト値はありません。</target>
        </trans-unit>
        <trans-unit id="cb37057e9d095a173db9c241ef8419b86a202d02" translate="yes" xml:space="preserve">
          <source>Name of a file with HTML to be included at the top of each page. Relative to the directory containing the &lt;code&gt;gitweb.cgi&lt;/code&gt; script. Can be set using &lt;code&gt;GITWEB_SITE_HEADER&lt;/code&gt; at build time. No default value.</source>
          <target state="translated">各ページの上部に含めるHTMLを含むファイルの名前。 &lt;code&gt;gitweb.cgi&lt;/code&gt; スクリプトを含むディレクトリに対して相対的です。ビルド時に &lt;code&gt;GITWEB_SITE_HEADER&lt;/code&gt; を使用して設定できます。デフォルト値はありません。</target>
        </trans-unit>
        <trans-unit id="389075bf1328d95e30f257d38d278dd3a0c94121" translate="yes" xml:space="preserve">
          <source>Name of a plain text file listing projects, or a name of directory to be scanned for projects.</source>
          <target state="translated">プロジェクトをリストアップしたプレーンテキストファイルの名前、またはプロジェクトをスキャンするディレクトリの名前。</target>
        </trans-unit>
        <trans-unit id="c0afa4635407444ed041e335278cc30cd2a11b14" translate="yes" xml:space="preserve">
          <source>Name of the SSL backend to use (e.g. &quot;openssl&quot; or &quot;schannel&quot;). This option is ignored if cURL lacks support for choosing the SSL backend at runtime.</source>
          <target state="translated">使用するSSLバックエンドの名前 (例:&quot;openssl&quot; や &quot;schannel&quot;)。cURLが実行時にSSLバックエンドを選択するサポートを欠いている場合、このオプションは無視されます。</target>
        </trans-unit>
        <trans-unit id="4d338fcbbcef71a5bde9a77e37abcbca835f1d4a" translate="yes" xml:space="preserve">
          <source>Name of the user running &lt;code&gt;git-cvsserver&lt;/code&gt;. If no name can be determined, the numeric uid is used.</source>
          <target state="translated">&lt;code&gt;git-cvsserver&lt;/code&gt; を実行しているユーザーの名前。名前を判別できない場合は、数値のuidが使用されます。</target>
        </trans-unit>
        <trans-unit id="33a3a9f4baab999f10555d77c61fc17ad7a2e690" translate="yes" xml:space="preserve">
          <source>Name of your site or organization, to appear in page titles. Set it to something descriptive for clearer bookmarks etc. If this variable is not set or is, then gitweb uses the value of the &lt;code&gt;SERVER_NAME&lt;/code&gt;&lt;code&gt;CGI&lt;/code&gt; environment variable, setting site name to &quot;$SERVER_NAME Git&quot;, or &quot;Untitled Git&quot; if this variable is not set (e.g. if running gitweb as standalone script).</source>
          <target state="translated">ページタイトルに表示されるサイトまたは組織の名前。この変数が設定されていないか設定されている場合は、わかりやすいブックマークに設定してください。この変数が設定されていない場合は、gitwebは &lt;code&gt;SERVER_NAME&lt;/code&gt; &lt;code&gt;CGI&lt;/code&gt; 環境変数の値を使用し、サイト名を「$ SERVER_NAME Git」、またはこの変数が「無題のGit」に設定します設定されていません（たとえば、gitwebをスタンドアロンスクリプトとして実行している場合）。</target>
        </trans-unit>
        <trans-unit id="ac84f0f88b7824faf06c4b53397972bcd09b01be" translate="yes" xml:space="preserve">
          <source>Name output in &lt;code&gt;[PATCH n/m]&lt;/code&gt; format, even with a single patch.</source>
          <target state="translated">単一のパッチでも &lt;code&gt;[PATCH n/m]&lt;/code&gt; 形式で名前を出力します。</target>
        </trans-unit>
        <trans-unit id="ffd008dca3705155e76303827e2a4d3059068c9a" translate="yes" xml:space="preserve">
          <source>Name output in &lt;code&gt;[PATCH]&lt;/code&gt; format.</source>
          <target state="translated">&lt;code&gt;[PATCH]&lt;/code&gt; 形式で名前を出力します。</target>
        </trans-unit>
        <trans-unit id="fe45d9f50e3991235a5aaf79d20ba4e50638c193" translate="yes" xml:space="preserve">
          <source>Named file in &lt;code&gt;$GIT_DIR/branches&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;$GIT_DIR/branches&lt;/code&gt; 内の名前付きファイル</target>
        </trans-unit>
        <trans-unit id="e694d096f60594b306ed977a1cb3bf7e40731642" translate="yes" xml:space="preserve">
          <source>Named file in &lt;code&gt;$GIT_DIR/remotes&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;$GIT_DIR/remotes&lt;/code&gt; 内の名前付きファイル</target>
        </trans-unit>
        <trans-unit id="4d0059ee6bf7ca65460797daae6395c800b562c5" translate="yes" xml:space="preserve">
          <source>Named pointers called refs mark interesting points in history. A ref may contain the SHA-1 name of an object or the name of another ref. Refs with names beginning &lt;code&gt;ref/head/&lt;/code&gt; contain the SHA-1 name of the most recent commit (or &quot;head&quot;) of a branch under development. SHA-1 names of tags of interest are stored under &lt;code&gt;ref/tags/&lt;/code&gt;. A special ref named &lt;code&gt;HEAD&lt;/code&gt; contains the name of the currently checked-out branch.</source>
          <target state="translated">refsと呼ばれる名前付きポインターは、履歴内の興味深いポイントを示します。refには、オブジェクトのSHA-1名または別のrefの名前を含めることができます。名前が &lt;code&gt;ref/head/&lt;/code&gt; 始まるrefには、開発中のブランチの最新のコミット（または「ヘッド」）のSHA-1名が含まれています。対象のタグのSHA-1名は &lt;code&gt;ref/tags/&lt;/code&gt; 保存されます。 &lt;code&gt;HEAD&lt;/code&gt; という名前の特別な参照には、現在チェックアウトされているブランチの名前が含まれています。</target>
        </trans-unit>
        <trans-unit id="afc8b12ea961269025f67734b3112ac3163fa044" translate="yes" xml:space="preserve">
          <source>Named remote in configuration file</source>
          <target state="translated">設定ファイルで指定されたリモート</target>
        </trans-unit>
        <trans-unit id="60da66dd4d339a94ae12e8c7a620ab333cdfa554" translate="yes" xml:space="preserve">
          <source>Names a low-level merge driver to be used when performing an internal merge between common ancestors. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">共通の祖先間で内部マージを実行するときに使用される低レベルのマージドライバーを指定します。詳細については、&lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="7238264e2238da432cea4cee3e4e4ec456281760" translate="yes" xml:space="preserve">
          <source>Naming branches, tags, and other references</source>
          <target state="translated">ブランチ、タグ、その他の参照の命名</target>
        </trans-unit>
        <trans-unit id="a8a795a40591e9038f52c089f34245ee06ab71bc" translate="yes" xml:space="preserve">
          <source>Naming commits</source>
          <target state="translated">ネーミングコミット</target>
        </trans-unit>
        <trans-unit id="7b635b48de06412b114cd8e91f1912aac5470b03" translate="yes" xml:space="preserve">
          <source>Nearly proper rewriting of tag objects is supported. If the tag has a message attached, a new tag object will be created with the same message, author, and timestamp. If the tag has a signature attached, the signature will be stripped. It is by definition impossible to preserve signatures. The reason this is &quot;nearly&quot; proper, is because ideally if the tag did not change (points to the same object, has the same name, etc.) it should retain any signature. That is not the case, signatures will always be removed, buyer beware. There is also no support for changing the author or timestamp (or the tag message for that matter). Tags which point to other tags will be rewritten to point to the underlying commit.</source>
          <target state="translated">タグオブジェクトのほぼ適切な書き換えがサポートされています。タグにメッセージが添付されている場合、同じメッセージ、作者、タイムスタンプで新しいタグオブジェクトが作成されます。タグに署名が添付されている場合、署名は削除されます。署名を保存することは定義上不可能です。これが「ほぼ」適切である理由は、理想的にはタグが変化しなければ(同じオブジェクトを指している、同じ名前を持っている、など)、署名を保持するべきだからです。それはそうではなく、署名は常に削除されます。また、作者やタイムスタンプ(あるいはタグメッセージ)の変更もサポートされていません。他のタグを指しているタグは、元のコミットを指すように書き換えられます。</target>
        </trans-unit>
        <trans-unit id="ec8ce921b28e9d3cf6cf20eaf08287c17f378d35" translate="yes" xml:space="preserve">
          <source>Negating options</source>
          <target state="translated">オプションを否定する</target>
        </trans-unit>
        <trans-unit id="781db1e57c260d141571a81cbcc3db723749ad7f" translate="yes" xml:space="preserve">
          <source>Nevertheless, the code at C is broken, because the callers added on the lower line of development have not been converted to the new semantics introduced on the upper line of development. So if all you know is that D is bad, that Z is good, and that &lt;a href=&quot;git-bisect&quot;&gt;git-bisect[1]&lt;/a&gt; identifies C as the culprit, how will you figure out that the problem is due to this change in semantics?</source>
          <target state="translated">それでも、Cのコードは壊れています。開発の下の行に追加された呼び出し元が、開発の上の行に導入された新しいセマンティクスに変換されていないためです。Dが悪い、Zが良い、そして&lt;a href=&quot;git-bisect&quot;&gt;git-bisect [1]が&lt;/a&gt; Cを犯人として特定していることがわかっている場合、問題がこのセマンティクスの変更によるものであるとどうやって理解できますか？</target>
        </trans-unit>
        <trans-unit id="a6160e254f396c410b853d5ee2bc722e35ccb61c" translate="yes" xml:space="preserve">
          <source>Nevertheless, this is a common practice for people that need a simple way to publish a work-in-progress patch series, and it is an acceptable compromise as long as you warn other developers that this is how you intend to manage the branch.</source>
          <target state="translated">とはいえ、これは進行中のパッチシリーズを簡単に公開する方法を必要としている人にとってはよくあることであり、他の開発者にこれがあなたがブランチを管理するつもりであることを警告している限り、許容できる妥協点です。</target>
        </trans-unit>
        <trans-unit id="208a508aabbf19798034826f77ed481ec28e90cc" translate="yes" xml:space="preserve">
          <source>New features:</source>
          <target state="translated">新機能を搭載しています。</target>
        </trans-unit>
        <trans-unit id="c191eda851b2a021b1ece3943d51bb10c7c6e4eb" translate="yes" xml:space="preserve">
          <source>New marks are created automatically. Existing marks can be moved to another object simply by reusing the same &lt;code&gt;&amp;lt;idnum&amp;gt;&lt;/code&gt; in another &lt;code&gt;mark&lt;/code&gt; command.</source>
          <target state="translated">新しいマークは自動的に作成されます。別の &lt;code&gt;mark&lt;/code&gt; コマンドで同じ &lt;code&gt;&amp;lt;idnum&amp;gt;&lt;/code&gt; を再利用するだけで、既存のマークを別のオブジェクトに移動できます。</target>
        </trans-unit>
        <trans-unit id="34f293962e034aa3adab30d6ce7bb006c129576e" translate="yes" xml:space="preserve">
          <source>New objects written by fast-import are not available immediately. Most fast-import commands have no visible effect until the next checkpoint (or completion). The frontend can send commands to fill fast-import&amp;rsquo;s input pipe without worrying about how quickly they will take effect, which improves performance by simplifying scheduling.</source>
          <target state="translated">高速インポートによって作成された新しいオブジェクトは、すぐには利用できません。ほとんどの高速インポートコマンドは、次のチェックポイント（または完了）まで目に見える効果はありません。フロントエンドはコマンドを送信して、コマンドの効果がどれだけ速く反映されるかを気にすることなく、高速インポートの入力パイプを埋めることができます。これにより、スケジューリングが簡素化され、パフォーマンスが向上します。</target>
        </trans-unit>
        <trans-unit id="bd5d84635e8045ac3e97cdc31b8e7c57fb2006ba" translate="yes" xml:space="preserve">
          <source>New remote-tracking branches will be stored under the shorthand name that you gave &lt;code&gt;git remote add&lt;/code&gt;, in this case &lt;code&gt;staging&lt;/code&gt;:</source>
          <target state="translated">新しいリモート追跡ブランチは、 &lt;code&gt;git remote add&lt;/code&gt; を指定した省略名で保存されます。この場合は、 &lt;code&gt;staging&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="408210d4e2e7bc9a95a98e6b1bf8a3bd1ff14459" translate="yes" xml:space="preserve">
          <source>New users are encouraged to use &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; instead. The &lt;code&gt;whatchanged&lt;/code&gt; command is essentially the same as &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; but defaults to show the raw format diff output and to skip merges.</source>
          <target state="translated">新しいユーザーは代わりに&lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt;を使用することをお勧めします。 &lt;code&gt;whatchanged&lt;/code&gt; コマンドは、本質的に同じである&lt;a href=&quot;git-log&quot;&gt;、[1] gitのログ&lt;/a&gt;が、デフォルトは、RAW形式の差分出力を表示し、マージをスキップします。</target>
        </trans-unit>
        <trans-unit id="04e09d741912def77b41c31c7fd7bada0af8f8f2" translate="yes" xml:space="preserve">
          <source>Newer &lt;code&gt;git diff&lt;/code&gt; output has embedded &lt;code&gt;index information&lt;/code&gt; for each blob to help identify the original version that the patch applies to. When this flag is given, and if the original versions of the blobs are available locally, builds a temporary index containing those blobs.</source>
          <target state="translated">新しい &lt;code&gt;git diff&lt;/code&gt; 出力には、パッチが適用される元のバージョンの識別に役立つように、各BLOBの &lt;code&gt;index information&lt;/code&gt; が埋め込まれています。このフラグが指定されている場合、元のバージョンのblobがローカルで利用できる場合は、それらのblobを含む一時インデックスを作成します。</target>
        </trans-unit>
        <trans-unit id="7f94af506f4cd517718453425d685ea35e84d4c7" translate="yes" xml:space="preserve">
          <source>Newly created objects are initially created in a file named after the object&amp;rsquo;s SHA-1 hash (stored in &lt;code&gt;.git/objects&lt;/code&gt;).</source>
          <target state="translated">新しく作成されたオブジェクトは、最初にオブジェクトのSHA-1ハッシュ（ &lt;code&gt;.git/objects&lt;/code&gt; に格納されている）にちなんで名付けられたファイルに作成されます。</target>
        </trans-unit>
        <trans-unit id="5efdf7f0d1fca004c74269609acfa25723d86160" translate="yes" xml:space="preserve">
          <source>Next step: get familiar with the object naming. Read &lt;a href=&quot;#naming-commits&quot;&gt;Naming commits&lt;/a&gt;. There are quite a few ways to name an object (and not only revisions!). All of these are handled in &lt;code&gt;sha1_name.c&lt;/code&gt;. Just have a quick look at the function &lt;code&gt;get_sha1()&lt;/code&gt;. A lot of the special handling is done by functions like &lt;code&gt;get_sha1_basic()&lt;/code&gt; or the likes.</source>
          <target state="translated">次のステップ：オブジェクトの命名に慣れます。&lt;a href=&quot;#naming-commits&quot;&gt;ネーミングコミット&lt;/a&gt;を読む。オブジェクトに名前を付ける方法はかなり多くあります（リビジョンだけではありません！）。これらはすべて &lt;code&gt;sha1_name.c&lt;/code&gt; で処理されます。関数 &lt;code&gt;get_sha1()&lt;/code&gt; をざっと見てください。特別な処理の多くは、 &lt;code&gt;get_sha1_basic()&lt;/code&gt; などの関数によって行われます。</target>
        </trans-unit>
        <trans-unit id="11fc14203dd0f4441645a9c34d5dd022905f56e4" translate="yes" xml:space="preserve">
          <source>Next steps</source>
          <target state="translated">次のステップ</target>
        </trans-unit>
        <trans-unit id="817a91571b93a177740989ad9e63a1941cffb303" translate="yes" xml:space="preserve">
          <source>Next time, after seeing the same conflicted automerge, running &lt;code&gt;git rerere&lt;/code&gt; will perform a three-way merge between the earlier conflicted automerge, the earlier manual resolution, and the current conflicted automerge. If this three-way merge resolves cleanly, the result is written out to your working tree file, so you do not have to manually resolve it. Note that &lt;code&gt;git rerere&lt;/code&gt; leaves the index file alone, so you still need to do the final sanity checks with &lt;code&gt;git diff&lt;/code&gt; (or &lt;code&gt;git diff -c&lt;/code&gt;) and &lt;code&gt;git add&lt;/code&gt; when you are satisfied.</source>
          <target state="translated">次回、同じ競合する自動マージを確認した後、 &lt;code&gt;git rerere&lt;/code&gt; を実行すると、以前の競合する自動マージ、以前の手動の解決策、現在の競合する自動マージの間で3者間マージが実行されます。この3者間マージが問題なく解決される場合、結果は作業ツリーファイルに書き出されるため、手動で解決する必要はありません。 &lt;code&gt;git rerere&lt;/code&gt; はインデックスファイルをそのままにするので、満足したら &lt;code&gt;git diff&lt;/code&gt; （または &lt;code&gt;git diff -c&lt;/code&gt; ）と &lt;code&gt;git add&lt;/code&gt; を使用して最終的な健全性チェックを行う必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="74ccc5b41472ca3ff8486dd211ddfe0cae9246c3" translate="yes" xml:space="preserve">
          <source>Next, commit the changes stored in the index. The &lt;code&gt;-c&lt;/code&gt; option specifies to pre-populate the commit message from the original message that you started with in the first commit. This is helpful to avoid retyping it. The &lt;code&gt;HEAD@{1}&lt;/code&gt; is a special notation for the commit that &lt;code&gt;HEAD&lt;/code&gt; used to be at prior to the original reset commit (1 change ago). See &lt;a href=&quot;git-reflog&quot;&gt;git-reflog[1]&lt;/a&gt; for more details. You may also use any other valid commit reference.</source>
          <target state="translated">次に、インデックスに保存されている変更をコミットします。 &lt;code&gt;-c&lt;/code&gt; オプションを指定は、事前移入あなたが最初のコミットでの使用を開始することを、元のメッセージからのメッセージをコミットします。これは再入力を避けるのに役立ちます。 &lt;code&gt;HEAD@{1}&lt;/code&gt; ことをコミットするための特別な表記法である &lt;code&gt;HEAD&lt;/code&gt; が元のリセットの前には、（1変更前）コミットになるように使用されます。詳細については、&lt;a href=&quot;git-reflog&quot;&gt;git-reflog [1]&lt;/a&gt;を参照してください。他の有効なコミット参照も使用できます。</target>
        </trans-unit>
        <trans-unit id="d481150e66b12915d203137377672c89781fe045" translate="yes" xml:space="preserve">
          <source>Next, copy &lt;code&gt;proj.git&lt;/code&gt; to the server where you plan to host the public repository. You can use scp, rsync, or whatever is most convenient.</source>
          <target state="translated">次に、パブリックリポジトリをホストする予定のサーバーに &lt;code&gt;proj.git&lt;/code&gt; をコピーします。scp、rsync、または最も便利なものを使用できます。</target>
        </trans-unit>
        <trans-unit id="04e0b9feb1c4a494995ed09ad261d2d4e9ce11c5" translate="yes" xml:space="preserve">
          <source>Next, give every team member read/write access to this repository. One easy way to do this is to give all the team members ssh access to the machine where the repository is hosted. If you don&amp;rsquo;t want to give them a full shell on the machine, there is a restricted shell which only allows users to do Git pushes and pulls; see &lt;a href=&quot;git-shell&quot;&gt;git-shell[1]&lt;/a&gt;.</source>
          <target state="translated">次に、すべてのチームメンバーにこのリポジトリへの読み取り/書き込みアクセス権を付与します。これを行う簡単な方法の1つは、すべてのチームメンバーに、リポジトリがホストされているマシンへのSSHアクセスを許可することです。マシン上の完全なシェルを提供したくない場合は、ユーザーがGitのプッシュとプルのみを実行できる制限付きシェルがあります。&lt;a href=&quot;git-shell&quot;&gt;git-shell [1]を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="28d55d870524553fca2220c18e5b9bb0de3dcbdb" translate="yes" xml:space="preserve">
          <source>Next, tell Git to take a snapshot of the contents of all files under the current directory (note the &lt;code&gt;.&lt;/code&gt;), with &lt;code&gt;git add&lt;/code&gt;:</source>
          <target state="translated">次に、（注意現在のディレクトリの下のすべてのファイルの内容のスナップショットを取るためにGitリポジトリを伝える &lt;code&gt;.&lt;/code&gt; で、） &lt;code&gt;git add&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="596419ac8ea3393898cb55dbbde5c3613a819bd1" translate="yes" xml:space="preserve">
          <source>Next, we interactively select diff hunks to add using the &lt;code&gt;git add -p&lt;/code&gt; facility. This will ask you about each diff hunk in sequence and you can use simple commands such as &quot;yes, include this&quot;, &quot;No don&amp;rsquo;t include this&quot; or even the very powerful &quot;edit&quot; facility.</source>
          <target state="translated">次に、 &lt;code&gt;git add -p&lt;/code&gt; 機能を使用して、追加する差分ハンクを対話的に選択します。これにより、各差分ハンクについて順番に尋ねられ、「はい、これを含める」、「いいえ、これを含めない」、または非常に強力な「編集」機能などの単純なコマンドを使用できます。</target>
        </trans-unit>
        <trans-unit id="8951da293ad0f99492d7f4956f721a58ac3b7ff1" translate="yes" xml:space="preserve">
          <source>No checkout of HEAD is performed after the clone is complete.</source>
          <target state="translated">クローン完了後、HEADのチェックアウトは行われません。</target>
        </trans-unit>
        <trans-unit id="cfeba19b6e040607769791cbfbefd83c894b180c" translate="yes" xml:space="preserve">
          <source>No modifications to submodules are ignored, all of committed differences, and modifications to tracked and untracked files are shown. This is the default option.</source>
          <target state="translated">サブモジュールへの変更は無視され、コミットされた差分はすべて無視され、追跡されたファイルと追跡されていないファイルへの変更は表示されます。これはデフォルトのオプションです。</target>
        </trans-unit>
        <trans-unit id="e2a67085604f2eb59fb72fa11fe30ca6d6e00a34" translate="yes" xml:space="preserve">
          <source>No other changes are made. In particular, the local modifications you had before you started merge will stay the same and the index entries for them stay as they were, i.e. matching &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">他の変更は行われません。特に、マージを開始する前に行ったローカル変更は同じままで、それらのインデックスエントリはそのままで、つまり &lt;code&gt;HEAD&lt;/code&gt; に一致します。</target>
        </trans-unit>
        <trans-unit id="de8a6fbc5b9c2db6f89c1e3ad733992686a5d62a" translate="yes" xml:space="preserve">
          <source>No other kinds of lines (e.g. empty lines or comment lines) are allowed in the file, even though some may be silently ignored. Do not view or edit the file with editors.</source>
          <target state="translated">ファイルの中では、他の種類の行(空行やコメント行など)は許可されていません(黙って無視されている行もあります)。エディタでファイルを見たり編集したりしないでください。</target>
        </trans-unit>
        <trans-unit id="c967d0b967e1e36091e8958a5454d9ea9951dded" translate="yes" xml:space="preserve">
          <source>No other modifications are made.</source>
          <target state="translated">それ以外の改造はしていません。</target>
        </trans-unit>
        <trans-unit id="57658df76cf3f4fecaffea0a60cae0068e21e278" translate="yes" xml:space="preserve">
          <source>No patch introduces a regression: after applying any initial part of the series, the resulting project still compiles and works, and has no bugs that it didn&amp;rsquo;t have before.</source>
          <target state="translated">パッチはリグレッションを引き起こしません：シリーズの最初の部分を適用した後、結果のプロジェクトはまだコンパイルされて機能し、以前にはなかったバグはありません。</target>
        </trans-unit>
        <trans-unit id="0d39633312554b0ea8cb734d680c4698c57a7afd" translate="yes" xml:space="preserve">
          <source>No pattern matches the path, and nothing says if the path has or does not have the attribute, the attribute for the path is said to be Unspecified.</source>
          <target state="translated">パスと一致するパターンはなく、パスが属性を持っているか持っていないかは何も書いていないので、パスの属性はUnspecifiedと言われています。</target>
        </trans-unit>
        <trans-unit id="772b72b88edec66167df810a58edde895140fe67" translate="yes" xml:space="preserve">
          <source>No promises are made about the interface, or that this program won&amp;rsquo;t disappear without warning in the next version of Git. Don&amp;rsquo;t use it.</source>
          <target state="translated">インターフェイスについては何も約束されていません。また、このプログラムが次のバージョンのGitで警告なしに消えることはありません。使用しないでください。</target>
        </trans-unit>
        <trans-unit id="c90ed1cbdf989952fffa921b682ee1beb354558a" translate="yes" xml:space="preserve">
          <source>No special setup is needed for SSH access, other than having Git tools in the PATH. If you have clients that do not accept the CVS_SERVER environment variable, you can rename &lt;code&gt;git-cvsserver&lt;/code&gt; to &lt;code&gt;cvs&lt;/code&gt;.</source>
          <target state="translated">PATHにGitツールがあること以外は、SSHアクセスに特別な設定は必要ありません。 CVS_SERVER環境変数を受け入れないクライアントがある場合は、 &lt;code&gt;git-cvsserver&lt;/code&gt; の名前を &lt;code&gt;cvs&lt;/code&gt; に変更できます。</target>
        </trans-unit>
        <trans-unit id="f8302d8fa548b77adf094708d453bfd512d86a1e" translate="yes" xml:space="preserve">
          <source>No-op. Rebasing commits with an empty message used to fail and this option would override that behavior, allowing commits with empty messages to be rebased. Now commits with an empty message do not cause rebasing to halt.</source>
          <target state="translated">いいえ。空のメッセージを含むコミットのリベースに失敗していましたが、このオプションはその挙動を上書きし、空のメッセージを含むコミットのリベースを可能にします。これで、空のメッセージを含むコミットでもリベースが停止しなくなりました。</target>
        </trans-unit>
        <trans-unit id="a5febeaff9fb6579d7fb9744e50b3994bde6d8e3" translate="yes" xml:space="preserve">
          <source>Non-ascii filenames can be silently removed despite being in a desired directory. Keeping only wanted paths is often done using pipelines like &lt;code&gt;git ls-files | grep -v ^WANTED_DIR/ | xargs git rm&lt;/code&gt;. ls-files will only quote filenames if needed, so folks may not notice that one of the files didn&amp;rsquo;t match the regex (at least not until it&amp;rsquo;s much too late). Yes, someone who knows about core.quotePath can avoid this (unless they have other special characters like \t, \n, or &quot;), and people who use ls-files -z with something other than grep can avoid this, but that doesn&amp;rsquo;t mean they will.</source>
          <target state="translated">ASCII以外のファイル名は、目的のディレクトリにあるにもかかわらずサイレントに削除できます。必要なパスのみを保持することは、多くの場合 &lt;code&gt;git ls-files | grep -v ^WANTED_DIR/ | xargs git rm&lt;/code&gt; ようなパイプラインを使用して行われます。 grep -v ^ WANTED_DIR / | xargs git rm。 ls-filesは必要な場合にのみファイル名を引用するため、ファイルの1つが正規表現に一致しなかったことに気付かない場合があります（少なくとも手遅れになるまでは）。はい、core.quotePathを知っている人はこれを回避できます（\ t、\ n、または &quot;のような他の特殊文字が含まれている場合を除きます）。ls-files-zをgrep以外で使用すると回避できますが、彼らがそうするつもりはありません。</target>
        </trans-unit>
        <trans-unit id="e2858812ab58a3c85b7437528709a46037dcfba6" translate="yes" xml:space="preserve">
          <source>Non-cached mode</source>
          <target state="translated">非キャッシュモード</target>
        </trans-unit>
        <trans-unit id="28592521357265f4a182551c4308e7cea911b93e" translate="yes" xml:space="preserve">
          <source>Non-empty context lines that have one extra whitespace at the beginning.</source>
          <target state="translated">空ではないコンテキスト行で、先頭に余分な空白が1つあるもの。</target>
        </trans-unit>
        <trans-unit id="54b4652d3bd254c89ec712af1b81619180dc7f11" translate="yes" xml:space="preserve">
          <source>None of the provided paths are ignored.</source>
          <target state="translated">提供されたパスはいずれも無視されます。</target>
        </trans-unit>
        <trans-unit id="53d641d85a09ede95cefeac02aadaca1a7fcd396" translate="yes" xml:space="preserve">
          <source>Normalize &lt;code&gt;refname&lt;/code&gt; by removing any leading slash (&lt;code&gt;/&lt;/code&gt;) characters and collapsing runs of adjacent slashes between name components into a single slash. If the normalized refname is valid then print it to standard output and exit with a status of 0, otherwise exit with a non-zero status. (&lt;code&gt;--print&lt;/code&gt; is a deprecated way to spell &lt;code&gt;--normalize&lt;/code&gt;.)</source>
          <target state="translated">先頭のスラッシュ（ &lt;code&gt;/&lt;/code&gt; ）文字を削除し、名前コンポーネント間の隣接するスラッシュのランを単一のスラッシュに &lt;code&gt;refname&lt;/code&gt; することにより、refnameを正規化します。正規化されたrefnameが有効な場合は、標準出力に出力し、ステータス0で終了します。それ以外の場合は、ゼロ以外のステータスで終了します。（ &lt;code&gt;--print&lt;/code&gt; は--normalizeのスペルを非推奨にする方法 &lt;code&gt;--normalize&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="cd7a46a34b030b4fa7a1f4c298bb470454f5bdc6" translate="yes" xml:space="preserve">
          <source>Normally &lt;code&gt;git write-tree&lt;/code&gt; ensures that the objects referenced by the directory exist in the object database. This option disables this check.</source>
          <target state="translated">通常、 &lt;code&gt;git write-tree&lt;/code&gt; は、ディレクトリによって参照されるオブジェクトがオブジェクトデータベースに存在することを保証します。このオプションは、このチェックを無効にします。</target>
        </trans-unit>
        <trans-unit id="88fcf17b3fc3a47614adb1a8f9a3b0161d3a2185" translate="yes" xml:space="preserve">
          <source>Normally a &quot;commit&quot; has one parent: the previous state of the tree before a certain change was made. However, sometimes it can have two or more parent commits, in which case we call it a &quot;merge&quot;, due to the fact that such a commit brings together (&quot;merges&quot;) two or more previous states represented by other commits.</source>
          <target state="translated">通常、&quot;コミット&quot; は一つの親を持ちます:ある変更が行われる前のツリーの前の状態です。このようなコミットは、他のコミットが表す二つ以上の前の状態をまとめてマージすることから、「マージ」と呼ばれています。</target>
        </trans-unit>
        <trans-unit id="a69474e938cf33a616aeca615fe9997480c7c945" translate="yes" xml:space="preserve">
          <source>Normally a commit would identify a new &quot;HEAD&quot; state, and while Git doesn&amp;rsquo;t care where you save the note about that state, in practice we tend to just write the result to the file that is pointed at by &lt;code&gt;.git/HEAD&lt;/code&gt;, so that we can always see what the last committed state was.</source>
          <target state="translated">通常、コミットは新しい &quot;HEAD&quot;状態を識別し、Gitはその状態に関するメモをどこに保存するかを気にしませんが、実際には &lt;code&gt;.git/HEAD&lt;/code&gt; が指すファイルに結果を書き込む傾向があります。最後にコミットされた状態を常に確認できるようにします。</target>
        </trans-unit>
        <trans-unit id="de60fcb388acbd1518bd224ad2216b3a990124fa" translate="yes" xml:space="preserve">
          <source>Normally batch output is flushed after each object is output, so that a process can interactively read and write from &lt;code&gt;cat-file&lt;/code&gt;. With this option, the output uses normal stdio buffering; this is much more efficient when invoking &lt;code&gt;--batch-check&lt;/code&gt; on a large number of objects.</source>
          <target state="translated">通常、バッチ出力は各オブジェクトが出力された後にフラッシュされるため、プロセスは &lt;code&gt;cat-file&lt;/code&gt; からインタラクティブに読み書きできます。このオプションを使用すると、出力は通常のstdioバッファリングを使用します。これは、多数のオブジェクトに対して &lt;code&gt;--batch-check&lt;/code&gt; を呼び出すときにはるかに効率的です。</target>
        </trans-unit>
        <trans-unit id="38e091b35be2fc0762233a3d599b506f3b643fb1" translate="yes" xml:space="preserve">
          <source>Normally commits are only added to a project, never taken away or replaced. Git is designed with this assumption, and violating it will cause Git&amp;rsquo;s merge machinery (for example) to do the wrong thing.</source>
          <target state="translated">通常、コミットはプロジェクトにのみ追加され、取り除かれたり置き換えられたりすることはありません。Gitはこの前提で設計されており、これに違反すると、Gitのマージ機構（たとえば）が間違った動作をします。</target>
        </trans-unit>
        <trans-unit id="9122c3565585fe79768943dc25f1cf167ffbd58d" translate="yes" xml:space="preserve">
          <source>Normally the &lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt; stores the name of a &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt;, and commands that operate on the history HEAD represents operate on the history leading to the tip of the branch the HEAD points at. However, Git also allows you to &lt;a href=&quot;#def_checkout&quot;&gt;check out&lt;/a&gt; an arbitrary &lt;a href=&quot;#def_commit&quot;&gt;commit&lt;/a&gt; that isn&amp;rsquo;t necessarily the tip of any particular branch. The HEAD in such a state is called &quot;detached&quot;.</source>
          <target state="translated">通常、&lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt;には&lt;a href=&quot;#def_branch&quot;&gt;ブランチ&lt;/a&gt;の名前が​​格納され、HEADが表す履歴を操作するコマンドは、HEADが指すブランチの先端に至る履歴を操作します。ただし、Gitを使用すると、特定のブランチの先端とは限らない任意の&lt;a href=&quot;#def_commit&quot;&gt;コミット&lt;/a&gt;を&lt;a href=&quot;#def_checkout&quot;&gt;チェックアウト&lt;/a&gt;することもできます。このような状態のHEADを「デタッチ」と呼びます。</target>
        </trans-unit>
        <trans-unit id="cc5f74671cf296af564ff0627cbd1c153eed7819" translate="yes" xml:space="preserve">
          <source>Normally the branch merged in is the HEAD of the remote repository, but the choice is determined by the branch.&amp;lt;name&amp;gt;.remote and branch.&amp;lt;name&amp;gt;.merge options; see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for details.</source>
          <target state="translated">通常、マージされるブランチはリモートリポジトリのHEADですが、選択は、branch。&amp;lt;name&amp;gt; .remoteおよびbranch。&amp;lt;name&amp;gt; .mergeオプションによって決定されます。詳細は&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="f22467859cfedb6f904df5424dcd9afb82c226b1" translate="yes" xml:space="preserve">
          <source>Normally whenever a branch head in a public repository is modified, it is modified to point to a descendant of the commit that it pointed to before. By forcing a push in this situation, you break that convention. (See &lt;a href=&quot;#problems-With-rewriting-history&quot;&gt;Problems with rewriting history&lt;/a&gt;.)</source>
          <target state="translated">通常、パブリックリポジトリのブランチヘッドが変更されるたびに、以前にポイントしたコミットの子孫をポイントするように変更されます。この状況でプッシュを強制することにより、その慣習を破ります。（&lt;a href=&quot;#problems-With-rewriting-history&quot;&gt;履歴の書き換えに関する問題を&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="43244e83cbae6a59cf653d315de1a56015589247" translate="yes" xml:space="preserve">
          <source>Normally, &lt;code&gt;git rerere&lt;/code&gt; is run without arguments or user-intervention. However, it has several commands that allow it to interact with its working state.</source>
          <target state="translated">通常、 &lt;code&gt;git rerere&lt;/code&gt; は引数やユーザー介入なしで実行されます。ただし、動作状態を操作できるいくつかのコマンドがあります。</target>
        </trans-unit>
        <trans-unit id="d7d70adae9e248dcbf5927b7eeba22fdf79a73fb" translate="yes" xml:space="preserve">
          <source>Normally, only files unknown to Git are removed, but if the &lt;code&gt;-x&lt;/code&gt; option is specified, ignored files are also removed. This can, for example, be useful to remove all build products.</source>
          <target state="translated">通常、Gitに認識されていないファイルのみが削除されますが、 &lt;code&gt;-x&lt;/code&gt; オプションが指定されている場合、無視されたファイルも削除されます。これは、たとえば、すべてのビルド製品を削除するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="ea1a90319260338e8b5ddefd985427f3690ce910" translate="yes" xml:space="preserve">
          <source>Normally, the &quot;git svn clone&quot; and &quot;git svn rebase&quot; commands attempt to recreate empty directories that are in the Subversion repository. If this option is set to &quot;false&quot;, then empty directories will only be created if the &quot;git svn mkdirs&quot; command is run explicitly. If unset, &lt;code&gt;git svn&lt;/code&gt; assumes this option to be &quot;true&quot;.</source>
          <target state="translated">通常、「git svn clone」コマンドと「git svn rebase」コマンドは、Subversionリポジトリにある空のディレクトリを再作成しようとします。このオプションを「false」に設定すると、「git svn mkdirs」コマンドが明示的に実行された場合にのみ空のディレクトリが作成されます。設定されていない場合、 &lt;code&gt;git svn&lt;/code&gt; はこのオプションを「true」と見なします。</target>
        </trans-unit>
        <trans-unit id="cbab35b86acdc7c387af4e06856d3dc90a27828f" translate="yes" xml:space="preserve">
          <source>Normally, the &quot;name&quot; field contains the canonical name of the command. When a canonical name is not available, one of these special values are used:</source>
          <target state="translated">通常、「name」フィールドにはコマンドの正式名称が含まれます。正準名が利用できない場合は、これらの特別な値のいずれかが使用されます。</target>
        </trans-unit>
        <trans-unit id="a72159c3df537e6c1eeaac201666cb67a55dea2c" translate="yes" xml:space="preserve">
          <source>Normally, the first commit in an SVN branch consists of a copy operation. &lt;code&gt;git svn&lt;/code&gt; will read this commit to get the SVN revision the branch was created from. It will then try to find the Git commit that corresponds to this SVN revision, and use that as the parent of the branch. However, it is possible that there is no suitable Git commit to serve as parent. This will happen, among other reasons, if the SVN branch is a copy of a revision that was not fetched by &lt;code&gt;git svn&lt;/code&gt; (e.g. because it is an old revision that was skipped with &lt;code&gt;--revision&lt;/code&gt;), or if in SVN a directory was copied that is not tracked by &lt;code&gt;git svn&lt;/code&gt; (such as a branch that is not tracked at all, or a subdirectory of a tracked branch). In these cases, &lt;code&gt;git svn&lt;/code&gt; will still create a Git branch, but instead of using an existing Git commit as the parent of the branch, it will read the SVN history of the directory the branch was copied from and create appropriate Git commits. This is indicated by the message &quot;Initializing parent: &amp;lt;branchname&amp;gt;&quot;.</source>
          <target state="translated">通常、SVNブランチの最初のコミットはコピー操作で構成されます。 &lt;code&gt;git svn&lt;/code&gt; はこのコミットを読み取り、ブランチの作成元であるSVNリビジョンを取得します。次に、このSVNリビジョンに対応するGitコミットを見つけて、ブランチの親として使用します。ただし、親として機能する適切なGitコミットがない可能性があります。これは、SVNの枝がでフェッチされなかったリビジョンのコピーである場合、他の理由の中で、どうなる &lt;code&gt;git svn&lt;/code&gt; （それがでスキップされた古いリビジョンであるため、例えば &lt;code&gt;--revision&lt;/code&gt; ）、またはディレクトリがコピーされたSVNであればこれは &lt;code&gt;git svn&lt;/code&gt; によって追跡されません（まったく追跡されないブランチ、または追跡されるブランチのサブディレクトリなど）。これらの場合、 &lt;code&gt;git svn&lt;/code&gt; Gitブランチは引き続き作成されますが、既存のGitコミットをブランチの親として使用する代わりに、ブランチのコピー元のディレクトリのSVN履歴を読み取り、適切なGitコミットを作成します。これは、「Initializing parent：&amp;lt;branchname&amp;gt;」というメッセージで示されます。</target>
        </trans-unit>
        <trans-unit id="4d54b3aadfbad6c493d83bcb2428d0cb9e46992e" translate="yes" xml:space="preserve">
          <source>Normally, when no &amp;lt;path&amp;gt; is specified, git clean will not recurse into untracked directories to avoid removing too much. Specify -d to have it recurse into such directories as well. If any paths are specified, -d is irrelevant; all untracked files matching the specified paths (with exceptions for nested git directories mentioned under &lt;code&gt;--force&lt;/code&gt;) will be removed.</source>
          <target state="translated">通常、&amp;lt;path&amp;gt;が指定されていない場合、あまり削除されないように、git cleanは追跡されていないディレクトリに再帰しません。-dを指定すると、そのようなディレクトリにも再帰しま​​す。パスが指定されている場合、-dは無関係です。指定されたパスに一致する追跡されていないすべてのファイル（ &lt;code&gt;--force&lt;/code&gt; で言及されているネストされたgitディレクトリを除く）は削除されます。</target>
        </trans-unit>
        <trans-unit id="429c7c6d611a6b06377c7694b2f456c87ba75047" translate="yes" xml:space="preserve">
          <source>Not all pattern types support patterns containing \0. Git will error out if a given pattern type can&amp;rsquo;t support such a pattern. The &lt;code&gt;--perl-regexp&lt;/code&gt; pattern type when compiled against the PCRE v2 backend has the widest support for these types of patterns.</source>
          <target state="translated">すべてのパターンタイプが\ 0を含むパターンをサポートしているわけではありません。特定のパターンタイプがそのようなパターンをサポートできない場合、Gitはエラーになります。 &lt;code&gt;--perl-regexp&lt;/code&gt; PCRE v2のバックエンドに対してコンパイルされたパターンのタイプは、パターンのこれらのタイプの最も広いサポートを有しています。</target>
        </trans-unit>
        <trans-unit id="fc85aa9ed9f2a57ce72e656178cf6fe66c794d02" translate="yes" xml:space="preserve">
          <source>Not all values are equally unambiguous:</source>
          <target state="translated">すべての価値観が同じように曖昧ではありません。</target>
        </trans-unit>
        <trans-unit id="8394b0fb9c23c1116919b0832addc200fe1387df" translate="yes" xml:space="preserve">
          <source>Not to worry. It left the (trivial) conflict in &lt;code&gt;hello&lt;/code&gt; in the same form you should already be well used to if you&amp;rsquo;ve ever used CVS, so let&amp;rsquo;s just open &lt;code&gt;hello&lt;/code&gt; in our editor (whatever that may be), and fix it up somehow. I&amp;rsquo;d suggest just making it so that &lt;code&gt;hello&lt;/code&gt; contains all four lines:</source>
          <target state="translated">心配無用。これは、CVSを使用したことがあれば慣れているはずの同じ形式の &lt;code&gt;hello&lt;/code&gt; （些細な）競合を残したので、エディターで &lt;code&gt;hello&lt;/code&gt; を開いて（それが何であれ）、どうにかして修正します。 &lt;code&gt;hello&lt;/code&gt; 、helloに4行すべてが含まれるようにすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="b7ed8e5f5bf09b0c843d3af582307ddfb588c4c6" translate="yes" xml:space="preserve">
          <source>Note about fast-forwards</source>
          <target state="translated">早送りについての注意点</target>
        </trans-unit>
        <trans-unit id="318ccd302e94c5b26153ff4314826ba81af60a67" translate="yes" xml:space="preserve">
          <source>Note about git config --global</source>
          <target state="translated">git config --global についての注意点</target>
        </trans-unit>
        <trans-unit id="7da8f06b5e46e2bca162125caa0438ca1631ce6d" translate="yes" xml:space="preserve">
          <source>Note about git-config --global</source>
          <target state="translated">git-config --global についての注意点</target>
        </trans-unit>
        <trans-unit id="a858b9b8c7722185661603839f0881f8c7f88318" translate="yes" xml:space="preserve">
          <source>Note about konqueror</source>
          <target state="translated">コンクラーについての注意事項</target>
        </trans-unit>
        <trans-unit id="01b5dd07775875ee6aa9a8a3da76365c637f9b1a" translate="yes" xml:space="preserve">
          <source>Note also that multiple copies of an object may be present in the object database; in this case, it is undefined which copy&amp;rsquo;s size or delta base will be reported.</source>
          <target state="translated">オブジェクトの複数のコピーがオブジェクトデータベースに存在する場合があることにも注意してください。この場合、どのコピーのサイズまたはデルタベースが報告されるかは定義されていません。</target>
        </trans-unit>
        <trans-unit id="e92cbc9ca374ec932eab116752367c5739918c53" translate="yes" xml:space="preserve">
          <source>Note for Git users, that it is equivalent as keeping only the commit given by:</source>
          <target state="translated">Git ユーザーにとっては、これは与えられたコミットのみを保持しているのと同じであることに注意してください。</target>
        </trans-unit>
        <trans-unit id="9cd066f98a94620416bd40171030f2cd3deb4780" translate="yes" xml:space="preserve">
          <source>Note how the rule to only follow the TREESAME parent, if one is available, removed &lt;code&gt;B&lt;/code&gt; from consideration entirely. &lt;code&gt;C&lt;/code&gt; was considered via &lt;code&gt;N&lt;/code&gt;, but is TREESAME. Root commits are compared to an empty tree, so &lt;code&gt;I&lt;/code&gt; is !TREESAME.</source>
          <target state="translated">TREESAME親のみが従うというルールがある場合は、それが使用可能な場合に、 &lt;code&gt;B&lt;/code&gt; を完全に考慮から外したことに注意してください。 &lt;code&gt;C&lt;/code&gt; は &lt;code&gt;N&lt;/code&gt; を介して検討されましたが、TREESAMEです。ルートコミットは空の木に比べて、そうしている &lt;code&gt;I&lt;/code&gt; ！TREESAMEです。</target>
        </trans-unit>
        <trans-unit id="8bfd2da46a110f046c6975fde1a8b82933cacdc7" translate="yes" xml:space="preserve">
          <source>Note how there is no need for an entry for &lt;code&gt;&amp;lt;jane@laptop.(none)&amp;gt;&lt;/code&gt;, because the real name of that author is already correct.</source>
          <target state="translated">&lt;code&gt;&amp;lt;jane@laptop.(none)&amp;gt;&lt;/code&gt; エントリの必要がないことに注意してください。その作者の本名はすでに正しいからです。</target>
        </trans-unit>
        <trans-unit id="a357a7dbcbc2a41b2d3445e7cfb8ae38a48bfe09" translate="yes" xml:space="preserve">
          <source>Note in the example that we set up a triangular workflow, where we pull from one location and push to another. In a non-triangular workflow, &lt;code&gt;@{push}&lt;/code&gt; is the same as &lt;code&gt;@{upstream}&lt;/code&gt;, and there is no need for it.</source>
          <target state="translated">この例では、ある場所からプルして別の場所にプッシュする三角ワークフローを設定していることに注意してください。三角形以外のワークフローでは、 &lt;code&gt;@{push}&lt;/code&gt; は &lt;code&gt;@{upstream}&lt;/code&gt; と同じであり、その必要はありません。</target>
        </trans-unit>
        <trans-unit id="01660f89f7c458ce6428d6e0df0b322692b74596" translate="yes" xml:space="preserve">
          <source>Note that &quot;%f&quot; is the name of the path that is being worked on. Depending on the version that is being filtered, the corresponding file on disk may not exist, or may have different contents. So, smudge and clean commands should not try to access the file on disk, but only act as filters on the content provided to them on standard input.</source>
          <target state="translated">f&quot; は作業中のパス名であることに注意してください。フィルタリングされるバージョンによっては、ディスク上に対応するファイルが存在しなかったり、内容が異なる場合があります。そのため、smudge コマンドや clean コマンドは、ディスク上のファイルにアクセスしようとせず、標準入力で提供された内容に対するフィルタとしてのみ動作するようにすべきです。</target>
        </trans-unit>
        <trans-unit id="014f6a8d43d7b297d024fa501c939621bed28154" translate="yes" xml:space="preserve">
          <source>Note that &quot;../&quot; is not special and will match literally, which is unlikely what you want.</source>
          <target state="translated">./」は特別なものではなく、文字通りに一致することに注意してください。</target>
        </trans-unit>
        <trans-unit id="8b91ded5c4fad4671b25fb8bfeab09bc89a0acef" translate="yes" xml:space="preserve">
          <source>Note that (3) is a historical artefact and will be ignored if the (1) and (2) specify that the submodule is not active. In other words, if we have a &lt;code&gt;submodule.&amp;lt;name&amp;gt;.active&lt;/code&gt; set to &lt;code&gt;false&lt;/code&gt; or if the submodule&amp;rsquo;s path is excluded in the pathspec in &lt;code&gt;submodule.active&lt;/code&gt;, the url doesn&amp;rsquo;t matter whether it is present or not. This is illustrated in the example that follows.</source>
          <target state="translated">（3）は歴史的なアーティファクトであり、（1）および（2）がサブモジュールがアクティブでないことを指定している場合は無視されることに注意してください。我々が持っている言い換えれば、 &lt;code&gt;submodule.&amp;lt;name&amp;gt;.active&lt;/code&gt; セットに &lt;code&gt;false&lt;/code&gt; 場合や、サブモジュールのパスがでPATHSPECに除外されている &lt;code&gt;submodule.active&lt;/code&gt; 、urlはそれが存在するかどうか問題ではありません。これは、次の例で説明されています。</target>
        </trans-unit>
        <trans-unit id="6fec9940a0e0728d1bf92151624eb87584d6019f" translate="yes" xml:space="preserve">
          <source>Note that --more, --list, --independent and --merge-base options are mutually exclusive.</source>
          <target state="translated">more,--list,--independent,--merge-base オプションは相互に排他的であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="9b9a74f48dd77c7cda36904d8ae57495c22af6f7" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;--force&lt;/code&gt; applies to all the refs that are pushed, hence using it with &lt;code&gt;push.default&lt;/code&gt; set to &lt;code&gt;matching&lt;/code&gt; or with multiple push destinations configured with &lt;code&gt;remote.*.push&lt;/code&gt; may overwrite refs other than the current branch (including local refs that are strictly behind their remote counterpart). To force a push to only one branch, use a &lt;code&gt;+&lt;/code&gt; in front of the refspec to push (e.g &lt;code&gt;git push
origin +master&lt;/code&gt; to force a push to the &lt;code&gt;master&lt;/code&gt; branch). See the &lt;code&gt;&amp;lt;refspec&amp;gt;...&lt;/code&gt; section above for details.</source>
          <target state="translated">そのノート &lt;code&gt;--force&lt;/code&gt; が故にでそれを使用して、プッシュされたすべての参考文献に適用 &lt;code&gt;push.default&lt;/code&gt; のにセット &lt;code&gt;matching&lt;/code&gt; またはで構成された複数のプッシュ先と &lt;code&gt;remote.*.push&lt;/code&gt; （あるローカル参考文献を含めて、現在のブランチ以外の参考文献を上書きすることができます完全にリモートの相手の背後にあります）。1つのブランチのみにプッシュを強制するには、refspecの前に &lt;code&gt;+&lt;/code&gt; を使用してプッシュします（例： &lt;code&gt;git push origin +master&lt;/code&gt; は &lt;code&gt;master&lt;/code&gt; ブランチに強制的にプッシュします）。詳細については、上記の &lt;code&gt;&amp;lt;refspec&amp;gt;...&lt;/code&gt; セクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="f71426a1d6dfa55d8e5b4bb3bb7ddab1eba41559" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;--patch&lt;/code&gt; can accept no pathspec and will prompt to restore all modified paths.</source>
          <target state="translated">&lt;code&gt;--patch&lt;/code&gt; はpathspecを受け入れることができず、変更されたすべてのパスを復元するように要求することに注意してください。</target>
        </trans-unit>
        <trans-unit id="788dab85e40bdd496cc4b3d8bdc2f5695fd79580" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;combined diff&lt;/code&gt; lists only files which were modified from all parents.</source>
          <target state="translated">&lt;code&gt;combined diff&lt;/code&gt; は、すべての親から変更されたファイルのみをリストすることに注意してください。</target>
        </trans-unit>
        <trans-unit id="e64bae554ef50a53010f144d204d2601ed2388af" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;git --help ...&lt;/code&gt; is identical to &lt;code&gt;git help ...&lt;/code&gt; because the former is internally converted into the latter.</source>
          <target state="translated">注意 &lt;code&gt;git --help ...&lt;/code&gt; 同じです &lt;code&gt;git help ...&lt;/code&gt; 前者は内部的に後者に変換されるため。</target>
        </trans-unit>
        <trans-unit id="0f050e4f28b585b64021f162ba65306d71b16a1c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;git add&lt;/code&gt; always adds just the current contents of a file to the index; further changes to the same file will be ignored unless you run &lt;code&gt;git add&lt;/code&gt; on the file again.</source>
          <target state="translated">&lt;code&gt;git add&lt;/code&gt; は常にファイルの現在の内容だけをインデックスに追加することに注意してください。同じファイルへのそれ以上の変更は、ファイルに対して再度 &lt;code&gt;git add&lt;/code&gt; を実行しない限り無視されます。</target>
        </trans-unit>
        <trans-unit id="a75d3b6c972faf4b238fb20e64f0ae5ba4c5e6f0" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;git diff-tree&lt;/code&gt; can use the tree encapsulated in a commit object.</source>
          <target state="translated">&lt;code&gt;git diff-tree&lt;/code&gt; は、コミットオブジェクトにカプセル化されたツリーを使用できることに注意してください。</target>
        </trans-unit>
        <trans-unit id="c22023840a6edf8cbd10c5905bf1fe0b2598253c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;trailers&lt;/code&gt; do not follow and are not intended to follow many rules for RFC 822 headers. For example they do not follow the encoding rules and probably many other rules.</source>
          <target state="translated">&lt;code&gt;trailers&lt;/code&gt; は従わず、RFC 822ヘッダーの多くのルールに従うことを意図していないことに注意してください。たとえば、エンコーディングルールやおそらく他の多くのルールに従っていません。</target>
        </trans-unit>
        <trans-unit id="99d4b644b5be625d6423f4cb1035eccb3ada0dfe" translate="yes" xml:space="preserve">
          <source>Note that Git at the core level treats path names simply as sequences of non-NUL bytes, there are no path name encoding conversions (except on Mac and Windows). Therefore, using non-ASCII path names will mostly work even on platforms and file systems that use legacy extended ASCII encodings. However, repositories created on such systems will not work properly on UTF-8-based systems (e.g. Linux, Mac, Windows) and vice versa. Additionally, many Git-based tools simply assume path names to be UTF-8 and will fail to display other encodings correctly.</source>
          <target state="translated">Git のコアレベルでは、パス名は単に non-NUL バイトのシーケンスとして扱われ、パス名のエンコーディング変換は行われません (Mac と Windows を除く)。そのため、従来の拡張 ASCII エンコーディングを使用しているプラットフォームやファイルシステムでも、非 ASCII パス名を使用すればほとんどの場合は動作します。しかし、そのようなシステムで作成されたリポジトリは UTF-8 ベースのシステム (Linux、Mac、Windows など)では正しく動作しませんし、その逆も同様です。さらに、多くの Git ベースのツールは単にパス名を UTF-8 と仮定しているだけで、他のエンコーディングを正しく表示できません。</target>
        </trans-unit>
        <trans-unit id="9883f1d7503e774a80aca1b5641976f5b274bd93" translate="yes" xml:space="preserve">
          <source>Note that a &lt;code&gt;filerename&lt;/code&gt; is the same as a &lt;code&gt;filecopy&lt;/code&gt; followed by a &lt;code&gt;filedelete&lt;/code&gt; of the source location. There is a slight performance advantage to using &lt;code&gt;filerename&lt;/code&gt;, but the advantage is so small that it is never worth trying to convert a delete/add pair in source material into a rename for fast-import. This &lt;code&gt;filerename&lt;/code&gt; command is provided just to simplify frontends that already have rename information and don&amp;rsquo;t want bother with decomposing it into a &lt;code&gt;filecopy&lt;/code&gt; followed by a &lt;code&gt;filedelete&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;filerename&lt;/code&gt; は、 &lt;code&gt;filecopy&lt;/code&gt; の後にソースの場所の &lt;code&gt;filedelete&lt;/code&gt; が続くのと同じであることに注意してください。 &lt;code&gt;filerename&lt;/code&gt; の使用には若干のパフォーマンス上の利点がありますが、その利点は非常に小さいため、ソースマテリアルの削除/追加のペアを高速インポート用の名前変更に変換する価値はありません。この &lt;code&gt;filerename&lt;/code&gt; コマンドは、すでに名前変更情報があり、それを &lt;code&gt;filecopy&lt;/code&gt; に分解してからfiledeleteを実行することに煩わされたくないフロントエンドを単純化するためにのみ提供されてい &lt;code&gt;filedelete&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0f7296e0d288c1c6e4ca2a5e972f6c90872dfac0" translate="yes" xml:space="preserve">
          <source>Note that a commit does not itself contain any information about what actually changed; all changes are calculated by comparing the contents of the tree referred to by this commit with the trees associated with its parents. In particular, Git does not attempt to record file renames explicitly, though it can identify cases where the existence of the same file data at changing paths suggests a rename. (See, for example, the &lt;code&gt;-M&lt;/code&gt; option to &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;).</source>
          <target state="translated">コミット自体には、実際に変更された内容に関する情報は含まれていません。すべての変更は、このコミットによって参照されるツリーの内容を、その親に関連付けられているツリーと比較することによって計算されます。特に、Gitはファイルの名前変更を明示的に記録しようとしませんが、パスの変更時に同じファイルデータが存在することで名前の変更が示唆される場合を識別できます。（たとえば、&lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt;の &lt;code&gt;-M&lt;/code&gt; オプションを参照してください）。</target>
        </trans-unit>
        <trans-unit id="54977b94f7c8617e07e8f365a31b9faa2fc062c5" translate="yes" xml:space="preserve">
          <source>Note that a more compact instruction does not change offset and size encoding. For example, if only offset2 is omitted like below, offset3 still contains bits 16-23. It does not become offset2 and contains bits 8-15 even if it&amp;rsquo;s right next to offset1.</source>
          <target state="translated">よりコンパクトな命令はオフセットとサイズのエンコーディングを変更しないことに注意してください。たとえば、以下のようにoffset2だけが省略されている場合でも、offset3にはビット16〜23が含まれています。offset1のすぐ隣にあっても、offset2にはならず、ビット8〜15が含まれます。</target>
        </trans-unit>
        <trans-unit id="2599b1548726c0979f146506e9008608bae9db4a" translate="yes" xml:space="preserve">
          <source>Note that a rebase merge works by replaying each commit from the working branch on top of the &amp;lt;upstream&amp;gt; branch. Because of this, when a merge conflict happens, the side reported as &lt;code&gt;ours&lt;/code&gt; is the so-far rebased series, starting with &amp;lt;upstream&amp;gt;, and &lt;code&gt;theirs&lt;/code&gt; is the working branch. In other words, the sides are swapped.</source>
          <target state="translated">リベースマージは、&amp;lt;upstream&amp;gt;ブランチの上にある作業ブランチから各コミットを再生することで機能することに注意してください。このため、マージの競合が発生すると、&amp;lt;upstream&amp;gt;から始まる、これまでにリベースされたシリーズが、 &lt;code&gt;ours&lt;/code&gt; として報告された側であり、 &lt;code&gt;theirs&lt;/code&gt; は作業ブランチです。つまり、辺が入れ替わります。</target>
        </trans-unit>
        <trans-unit id="8523c23f527cd324df8d4075c34f666be6f6f3b7" translate="yes" xml:space="preserve">
          <source>Note that all forms other than &lt;code&gt;--force-with-lease=&amp;lt;refname&amp;gt;:&amp;lt;expect&amp;gt;&lt;/code&gt; that specifies the expected current value of the ref explicitly are still experimental and their semantics may change as we gain experience with this feature.</source>
          <target state="translated">refの予想される現在の値を明示的に指定する &lt;code&gt;--force-with-lease=&amp;lt;refname&amp;gt;:&amp;lt;expect&amp;gt;&lt;/code&gt; 以外のすべての形式はまだ実験的なものであり、この機能の経験を積むにつれてその意味が変わる可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="4c01852cae3ff7462ff1404dd165465e299075b3" translate="yes" xml:space="preserve">
          <source>Note that all these configuration variables should probably be set using the &lt;code&gt;--global&lt;/code&gt; flag, for example like this:</source>
          <target state="translated">これらすべての構成変数は、たとえば &lt;code&gt;--global&lt;/code&gt; フラグを使用して、たとえば次のように設定する必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="11bfa085b8a4e40f2da0245c59f1751f600a1ada" translate="yes" xml:space="preserve">
          <source>Note that any of the &lt;code&gt;refs/*&lt;/code&gt; cases above may come either from the &lt;code&gt;$GIT_DIR/refs&lt;/code&gt; directory or from the &lt;code&gt;$GIT_DIR/packed-refs&lt;/code&gt; file. While the ref name encoding is unspecified, UTF-8 is preferred as some output processing may assume ref names in UTF-8.</source>
          <target state="translated">上記の &lt;code&gt;refs/*&lt;/code&gt; のケースは、 &lt;code&gt;$GIT_DIR/refs&lt;/code&gt; ディレクトリまたは &lt;code&gt;$GIT_DIR/packed-refs&lt;/code&gt; ファイルのいずれかにあることに注意してください。参照名のエンコーディングは指定されていませんが、一部の出力処理ではUTF-8での参照名を想定している場合があるため、UTF-8が推奨されます。</target>
        </trans-unit>
        <trans-unit id="508d8a380e829238fc278b6ce7f900eddc6afba3" translate="yes" xml:space="preserve">
          <source>Note that any protocol restrictions will be applied to the rewritten URL. If the rewrite changes the URL to use a custom protocol or remote helper, you may need to adjust the &lt;code&gt;protocol.*.allow&lt;/code&gt; config to permit the request. In particular, protocols you expect to use for submodules must be set to &lt;code&gt;always&lt;/code&gt; rather than the default of &lt;code&gt;user&lt;/code&gt;. See the description of &lt;code&gt;protocol.allow&lt;/code&gt; above.</source>
          <target state="translated">プロトコルの制限は、書き換えられたURLに適用されることに注意してください。書き換えによってカスタムプロトコルまたはリモートヘルパーを使用するようにURLが変更された場合は、 &lt;code&gt;protocol.*.allow&lt;/code&gt; configを調整してリクエストを許可する必要がある場合があります。特に、サブモジュールに使用する予定のプロトコルは、デフォルトの &lt;code&gt;user&lt;/code&gt; ではなく、 &lt;code&gt;always&lt;/code&gt; に設定する必要があります。上記の &lt;code&gt;protocol.allow&lt;/code&gt; の説明を参照してください。</target>
        </trans-unit>
        <trans-unit id="85755e8e95f86917d98f865efeaea006efa16988" translate="yes" xml:space="preserve">
          <source>Note that any tree or blob object can be examined using &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt; with the &amp;lt;revision&amp;gt;:&amp;lt;path&amp;gt; syntax. This can sometimes be useful for browsing the contents of a tree that is not currently checked out.</source>
          <target state="translated">ツリーまたはblobオブジェクトは、&lt;a href=&quot;git-show&quot;&gt;git-show [1]を使用&lt;/a&gt;して&amp;lt;revision&amp;gt;：&amp;lt;path&amp;gt;構文で検査できることに注意してください。これは、現在チェックアウトされていないツリーのコンテンツを閲覧する場合に役立つことがあります。</target>
        </trans-unit>
        <trans-unit id="fbb379f0a0fd79434d80db46f9a2b53054c72c7c" translate="yes" xml:space="preserve">
          <source>Note that attributes are by default taken from the &lt;code&gt;.gitattributes&lt;/code&gt; files in the tree that is being archived. If you want to tweak the way the output is generated after the fact (e.g. you committed without adding an appropriate export-ignore in its &lt;code&gt;.gitattributes&lt;/code&gt;), adjust the checked out &lt;code&gt;.gitattributes&lt;/code&gt; file as necessary and use &lt;code&gt;--worktree-attributes&lt;/code&gt; option. Alternatively you can keep necessary attributes that should apply while archiving any tree in your &lt;code&gt;$GIT_DIR/info/attributes&lt;/code&gt; file.</source>
          <target state="translated">属性はデフォルトで、アーカイブされるツリー内の &lt;code&gt;.gitattributes&lt;/code&gt; ファイルから取得されることに注意してください。事後に出力が生成される方法を微調整したい場合（たとえば、 &lt;code&gt;.gitattributes&lt;/code&gt; に適切なexport-ignoreを追加せずにコミットした場合）、必要に応じてチェックアウトされた &lt;code&gt;.gitattributes&lt;/code&gt; ファイルを調整し、 &lt;code&gt;--worktree-attributes&lt;/code&gt; オプションを使用します。または、 &lt;code&gt;$GIT_DIR/info/attributes&lt;/code&gt; ファイルにツリーをアーカイブするときに適用する必要のある属性を保持することもできます。</target>
        </trans-unit>
        <trans-unit id="cff58353f0553493321de729107a5ed939f5819e" translate="yes" xml:space="preserve">
          <source>Note that changing the compression level will not automatically recompress all existing objects. You can force recompression by passing the -F option to &lt;a href=&quot;git-repack&quot;&gt;git-repack[1]&lt;/a&gt;.</source>
          <target state="translated">圧縮レベルを変更しても、既存のすべてのオブジェクトが自動的に再圧縮されるわけではないことに注意してください。-Fオプションを&lt;a href=&quot;git-repack&quot;&gt;git-repack [1]に&lt;/a&gt;渡すことにより、再圧縮を強制できます。</target>
        </trans-unit>
        <trans-unit id="64e3311b0fc4c31b0c8a5b69594b7b0fffce6672" translate="yes" xml:space="preserve">
          <source>Note that commands that operate on the history of the current branch (e.g. &lt;code&gt;git commit&lt;/code&gt; to build a new history on top of it) still work while the HEAD is detached. They update the HEAD to point at the tip of the updated history without affecting any branch. Commands that update or inquire information &lt;code&gt;about&lt;/code&gt; the current branch (e.g. &lt;code&gt;git
branch --set-upstream-to&lt;/code&gt; that sets what remote-tracking branch the current branch integrates with) obviously do not work, as there is no (real) current branch to ask about in this state.</source>
          <target state="translated">現在のブランチの履歴を操作するコマンド（たとえば、その上に新しい履歴を構築する &lt;code&gt;git commit&lt;/code&gt; ）は、HEADがデタッチされている間も機能することに注意してください。ブランチに影響を与えることなく、更新された履歴の先端を指すようにHEADを更新します。現在のブランチ &lt;code&gt;about&lt;/code&gt; 問い合わせる（実際の）現在のブランチがないため、現在のブランチに関する情報を更新または照会するコマンド（たとえば、現在のブランチが統合するリモート追跡ブランチを設定 &lt;code&gt;git branch --set-upstream-to&lt;/code&gt; ）は明らかに機能しませんこの状態で。</target>
        </trans-unit>
        <trans-unit id="ca37287a6d2fcb3a044758adb2f9a6569545f92f" translate="yes" xml:space="preserve">
          <source>Note that commits that do not include the trailer will not be counted. Likewise, commits with multiple trailers (e.g., multiple signoffs) may be counted more than once (but only once per unique trailer value in that commit).</source>
          <target state="translated">トレーラーを含まないコミットはカウントされないことに注意してください。同様に、複数のトレイラーを含むコミット (例えば、複数のサインオフ)は複数回カウントされる可能性があります (ただし、そのコミット内のユニークなトレイラーの値につき、1回のみ)。</target>
        </trans-unit>
        <trans-unit id="021097bf28be68716f4d1858bb9538ff20243dc2" translate="yes" xml:space="preserve">
          <source>Note that commits which start empty are kept (unless --no-keep-empty is specified), and commits which are clean cherry-picks (as determined by &lt;code&gt;git log --cherry-mark ...&lt;/code&gt;) are detected and dropped as a preliminary step (unless --reapply-cherry-picks is passed).</source>
          <target state="translated">空で開始するコミットは保持され（--no-keep-emptyが指定されていない限り）、クリーンなチェリーピックであるコミット（ &lt;code&gt;git log --cherry-mark ...&lt;/code&gt; によって決定される）が検出され、としてドロップされることに注意してください。準備ステップ（--reapply-cherry-picksが渡されない限り）。</target>
        </trans-unit>
        <trans-unit id="c16e502657efa32285522830eee76fe68f8a2daa" translate="yes" xml:space="preserve">
          <source>Note that despite the name of the first mode, color is used to highlight the changed parts in all modes if enabled.</source>
          <target state="translated">最初のモードの名前にもかかわらず、有効になっている場合は、すべてのモードで変更された部分を強調するために色が使用されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="53b666711e62d15ce074196074eb30f8dac41460" translate="yes" xml:space="preserve">
          <source>Note that diff options passed to the command affect how the primary product of &lt;code&gt;format-patch&lt;/code&gt; is generated, and they are not passed to the underlying &lt;code&gt;range-diff&lt;/code&gt; machinery used to generate the cover-letter material (this may change in the future).</source>
          <target state="translated">コマンドに渡されるdiffオプションは、 &lt;code&gt;format-patch&lt;/code&gt; の主な生成物の生成方法に影響し、カバーレターマテリアルの生成に使用される基になる &lt;code&gt;range-diff&lt;/code&gt; 機構には渡されないことに注意してください（これは将来変更される可能性があります）。</target>
        </trans-unit>
        <trans-unit id="e0e05126bbcc50063c2790c39405469ee70a21a8" translate="yes" xml:space="preserve">
          <source>Note that during &lt;code&gt;git rebase&lt;/code&gt; and &lt;code&gt;git pull --rebase&lt;/code&gt;, &lt;code&gt;ours&lt;/code&gt; and &lt;code&gt;theirs&lt;/code&gt; may appear swapped. See the explanation of the same options in &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;git rebase&lt;/code&gt; と &lt;code&gt;git pull --rebase&lt;/code&gt; の間、 &lt;code&gt;ours&lt;/code&gt; と &lt;code&gt;theirs&lt;/code&gt; は入れ替わったように見えるかもしれないことに注意してください。詳細については、&lt;a href=&quot;git-checkout&quot;&gt;git-checkout [1]&lt;/a&gt;の同じオプションの説明を参照してください。</target>
        </trans-unit>
        <trans-unit id="1af7aa20d72debc79fb9171e27e72669f87bd742" translate="yes" xml:space="preserve">
          <source>Note that during &lt;code&gt;git rebase&lt;/code&gt; and &lt;code&gt;git pull --rebase&lt;/code&gt;, &lt;code&gt;ours&lt;/code&gt; and &lt;code&gt;theirs&lt;/code&gt; may appear swapped; &lt;code&gt;--ours&lt;/code&gt; gives the version from the branch the changes are rebased onto, while &lt;code&gt;--theirs&lt;/code&gt; gives the version from the branch that holds your work that is being rebased.</source>
          <target state="translated">&lt;code&gt;git rebase&lt;/code&gt; と &lt;code&gt;git pull --rebase&lt;/code&gt; の実行中、 &lt;code&gt;ours&lt;/code&gt; と &lt;code&gt;theirs&lt;/code&gt; は入れ替わったように見える場合があることに注意してください。 &lt;code&gt;--ours&lt;/code&gt; は一方で、変更が上にリベースされているブランチからのバージョンを提供します &lt;code&gt;--theirs&lt;/code&gt; がリベースされているあなたの仕事を保持しているブランチからのバージョンを提供します。</target>
        </trans-unit>
        <trans-unit id="c0c3e4b221eecb8ab2fd8007bde41fbeccbc289b" translate="yes" xml:space="preserve">
          <source>Note that earlier implementation left a broken pair as a separate creation and deletion patches. This was an unnecessary hack and the latest implementation always merges all the broken pairs back into modifications, but the resulting patch output is formatted differently for easier review in case of such a complete rewrite by showing the entire contents of old version prefixed with &lt;code&gt;-&lt;/code&gt;, followed by the entire contents of new version prefixed with &lt;code&gt;+&lt;/code&gt;.</source>
          <target state="translated">以前の実装では、壊れたペアが個別の作成および削除パッチとして残されていたことに注意してください。これは不必要なハックであり、最新の実装ではすべての壊れたペアが常に変更にマージされますが、結果のパッチ出力は異なる形式でフォーマットされているため、前に &lt;code&gt;-&lt;/code&gt; を付けた古いバージョンのコンテンツ全体を表示することで、完全に書き直した場合に簡単に確認できます。 &lt;code&gt;+&lt;/code&gt; で始まる新しいバージョンのコンテンツ全体。</target>
        </trans-unit>
        <trans-unit id="1e94eb3093be7f837a0c2027288d60b6c3b52e2c" translate="yes" xml:space="preserve">
          <source>Note that earlier versions of this command did not complain and produced incorrect results if you gave these options.</source>
          <target state="translated">このコマンドの以前のバージョンでは、これらのオプションを指定しても文句を言わず、誤った結果を生成していたことに注意してください。</target>
        </trans-unit>
        <trans-unit id="5d58dd5b84f29e01b510ca03eab20796ad3c7cbe" translate="yes" xml:space="preserve">
          <source>Note that extra commits can be shown to give a meaningful history.</source>
          <target state="translated">余分なコミットは、意味のある履歴を示すことができることに注意してください。</target>
        </trans-unit>
        <trans-unit id="5d8bcfac8a1a61a9e4be4013c3b0af7c68e4f7e1" translate="yes" xml:space="preserve">
          <source>Note that fast-forward updates do not create a merge commit and therefore there is no way to stop those merges with --no-commit. Thus, if you want to ensure your branch is not changed or updated by the merge command, use --no-ff with --no-commit.</source>
          <target state="translated">早送り更新ではマージコミットは発生しないので、 --no-commit でマージを止める方法はないことに注意してください。したがって、マージコマンドによってブランチが変更されたり更新されたりしないようにしたい場合は、 --no-commit と --no-ff を使用してください。</target>
        </trans-unit>
        <trans-unit id="f0d1c52e1eb6b4521a19e733ce553d5995206cf5" translate="yes" xml:space="preserve">
          <source>Note that fast-import automatically switches packfiles when the current packfile reaches --max-pack-size, or 4 GiB, whichever limit is smaller. During an automatic packfile switch fast-import does not update the branch refs, tags or marks.</source>
          <target state="translated">現在のパックファイルが --max-pack-size または 4GiB のいずれか小さい方に達すると、fast-import は自動的にパックファイルを切り替えることに注意してください。自動パックファイル切り替えの間、fast-import はブランチの参照、タグ、マークを更新しません。</target>
        </trans-unit>
        <trans-unit id="6615d1d4a8cbe8f9f5da36594407e26f3b365d70" translate="yes" xml:space="preserve">
          <source>Note that git log starts with the most recent commit and works backwards through the parents; however, since Git history can contain multiple independent lines of development, the particular order that commits are listed in may be somewhat arbitrary.</source>
          <target state="translated">しかし、Git の履歴には複数の独立した開発ラインが含まれていることがあるので、コミットの並び順は任意のものになるかもしれません。</target>
        </trans-unit>
        <trans-unit id="b6e44338fe1bf08aabf78cd81639eb77b1309fea" translate="yes" xml:space="preserve">
          <source>Note that git pull always merges into the current branch, regardless of what else is given on the command line.</source>
          <target state="translated">git pull は常に現在のブランチにマージされることに注意しましょう。</target>
        </trans-unit>
        <trans-unit id="bcdb8efaa60d12b40472e9e7be3ed7ef20fcfd01" translate="yes" xml:space="preserve">
          <source>Note that git-svn keeps track of the highest revision in which a branch or tag has appeared. If the subset of branches or tags is changed after fetching, then $GIT_DIR/svn/.metadata must be manually edited to remove (or reset) branches-maxRev and/or tags-maxRev as appropriate.</source>
          <target state="translated">git-svn は、ブランチやタグが出現した最高リビジョンを追跡していることに注意しましょう。取得後にブランチやタグのサブセットが変更された場合は、$GIT_DIR/svn/.metadata を手動で編集して branches-maxRev や tags-maxRev を削除 (あるいはリセット)しなければなりません。</target>
        </trans-unit>
        <trans-unit id="9d6b14c8954c11ebf9dc491ca128004d883ac7cd" translate="yes" xml:space="preserve">
          <source>Note that he doesn&amp;rsquo;t need to give the path to Alice&amp;rsquo;s repository; when Bob cloned Alice&amp;rsquo;s repository, Git stored the location of her repository in the repository configuration, and that location is used for pulls:</source>
          <target state="translated">アリスのリポジトリへのパスを指定する必要がないことに注意してください。ボブがアリスのリポジトリを複製したとき、Gitは彼女のリポジトリの場所をリポジトリ設定に保存し、その場所はプルに使用されます。</target>
        </trans-unit>
        <trans-unit id="d033887586c63461935e98a544790f02b6895719" translate="yes" xml:space="preserve">
          <source>Note that if no extensions are specified in the config file, then &lt;code&gt;core.repositoryformatversion&lt;/code&gt; SHOULD be set to &lt;code&gt;0&lt;/code&gt; (setting it to &lt;code&gt;1&lt;/code&gt; provides no benefit, and makes the repository incompatible with older implementations of git).</source>
          <target state="translated">設定ファイルで拡張子が指定されていない場合、 &lt;code&gt;core.repositoryformatversion&lt;/code&gt; を &lt;code&gt;0&lt;/code&gt; に設定する必要があります（ &lt;code&gt;1&lt;/code&gt; に設定してもメリットはなく、リポジトリがgitの古い実装と互換性がなくなります）。</target>
        </trans-unit>
        <trans-unit id="855e515073658cd86a49dd1065464c65266acbcf" translate="yes" xml:space="preserve">
          <source>Note that if the &lt;code&gt;bidi-import&lt;/code&gt; capability is used the complete batch sequence has to be buffered before starting to send data to fast-import to prevent mixing of commands and fast-import responses on the helper&amp;rsquo;s stdin.</source>
          <target state="translated">&lt;code&gt;bidi-import&lt;/code&gt; 機能を使用する場合、ヘルパーの標準入力でコマンドと高速インポート応答が混在しないように、高速インポートへのデータの送信を開始する前に、完全なバッチシーケンスをバッファーする必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="b689c65aa31e82a2dbc37c89c0ac3187b41716e6" translate="yes" xml:space="preserve">
          <source>Note that if the current branch head was your only reference to a particular point in history, then resetting that branch may leave you with no way to find the history it used to point to; so use this command carefully.</source>
          <target state="translated">現在のブランチの先頭が歴史上の特定のポイントへの唯一の参照であった場合、そのブランチをリセットすると、そのブランチが指し示していた歴史を見つけることができなくなる可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="e6c226fbc041b7aed3f8d988d110ae660c99fecc" translate="yes" xml:space="preserve">
          <source>Note that if the number of kept packs is more than gc.autoPackLimit, this configuration variable is ignored, all packs except the base pack will be repacked. After this the number of packs should go below gc.autoPackLimit and gc.bigPackThreshold should be respected again.</source>
          <target state="translated">保存パック数が gc.autoPackLimit を超えた場合、この設定変数は無視され、ベースパックを除くすべてのパックが再パックされます。この後、パック数はgc.autoPackLimit以下になり、gc.bigPackThresholdが再び尊重されます。</target>
        </trans-unit>
        <trans-unit id="876a2eaaf30082c69c38a89b274fd268226ca0ba" translate="yes" xml:space="preserve">
          <source>Note that if you also want to skip the first commit of the range you would issue the command:</source>
          <target state="translated">範囲の最初のコミットをスキップしたい場合は、コマンドを発行することに注意してください。</target>
        </trans-unit>
        <trans-unit id="56435425656273c2a6900d84ec2f6b2bfe4a637a" translate="yes" xml:space="preserve">
          <source>Note that if you are verifying a name from an untrusted source, it is wise to use &lt;code&gt;--end-of-options&lt;/code&gt; so that the name argument is not mistaken for another option.</source>
          <target state="translated">信頼できないソースからの名前を検証する場合は、name引数が別のオプションと間違えられないように &lt;code&gt;--end-of-options&lt;/code&gt; を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="24a094d13c9af525346a8eec9bbd2cdea3f73c32" translate="yes" xml:space="preserve">
          <source>Note that in all cases, the editor value will be passed to the shell, so any arguments containing spaces should be appropriately quoted. Additionally, if your editor normally detaches from the terminal when invoked, you should specify it with an argument that makes it not do that, or else Git will not see any changes. An example of a configuration addressing both of these issues on Windows would be the configuration &lt;code&gt;&quot;C:\Program Files\Vim\gvim.exe&quot; --nofork&lt;/code&gt;, which quotes the filename with spaces and specifies the &lt;code&gt;--nofork&lt;/code&gt; option to avoid backgrounding the process.</source>
          <target state="translated">いずれの場合も、エディターの値はシェルに渡されるため、スペースを含む引数は適切に引用符で囲む必要があることに注意してください。さらに、エディターが呼び出されたときに通常ターミナルからデタッチする場合は、それを行わないようにする引数を指定して指定する必要があります。そうしないと、Gitは変更を認識しません。Windowsでこれらの問題の両方に対処する構成の例は、構成 &lt;code&gt;&quot;C:\Program Files\Vim\gvim.exe&quot; --nofork&lt;/code&gt; 。これは、ファイル名をスペースで引用し、 &lt;code&gt;--nofork&lt;/code&gt; オプションを指定してバックグラウンドを回避します。処理する。</target>
        </trans-unit>
        <trans-unit id="102fd7adeeb68915f128c7eebf4ae04f1c363d22" translate="yes" xml:space="preserve">
          <source>Note that in general, Alice would want her local changes committed before initiating this &quot;pull&quot;. If Bob&amp;rsquo;s work conflicts with what Alice did since their histories forked, Alice will use her working tree and the index to resolve conflicts, and existing local changes will interfere with the conflict resolution process (Git will still perform the fetch but will refuse to merge --- Alice will have to get rid of her local changes in some way and pull again when this happens).</source>
          <target state="translated">一般に、アリスはこの「プル」を開始する前に、ローカルの変更をコミットすることを望みます。 Bobの作業が履歴の分岐以降にAliceが行った作業と競合する場合、Aliceは作業ツリーとインデックスを使用して競合を解決し、既存のローカル変更は競合解決プロセスを妨害します（Gitは引き続きフェッチを実行しますが、マージを拒否します- -アリスは、何らかの方法でローカルの変更を取り除き、これが発生したときに再度プルする必要があります）。</target>
        </trans-unit>
        <trans-unit id="51fccf4fe2d201a349cf25a2b82190079f387e94" translate="yes" xml:space="preserve">
          <source>Note that in older documentation you may see the index called the &quot;current directory cache&quot; or just the &quot;cache&quot;. It has three important properties:</source>
          <target state="translated">古いドキュメントでは、&quot;カレントディレクトリキャッシュ &quot;と呼ばれるインデックスや、単に &quot;キャッシュ &quot;と呼ばれるインデックスを見ることがあることに注意してください。これには3つの重要なプロパティがあります。</target>
        </trans-unit>
        <trans-unit id="86ef833f0b802486b88e99a2562a2a2a3eec1f68" translate="yes" xml:space="preserve">
          <source>Note that in this file, the exception for &lt;code&gt;core.bare&lt;/code&gt; and &lt;code&gt;core.worktree&lt;/code&gt; is gone. If they exist in &lt;code&gt;$GIT_DIR/config&lt;/code&gt;, you must move them to the &lt;code&gt;config.worktree&lt;/code&gt; of the main working tree. You may also take this opportunity to review and move other configuration that you do not want to share to all working trees:</source>
          <target state="translated">このファイルでは、 &lt;code&gt;core.bare&lt;/code&gt; と &lt;code&gt;core.worktree&lt;/code&gt; の例外がなくなっていることに注意してください。それらが &lt;code&gt;$GIT_DIR/config&lt;/code&gt; に存在する場合は、メインの作業ツリーの &lt;code&gt;config.worktree&lt;/code&gt; に移動する必要があります。この機会に、共有したくない他の構成を確認して、すべての作業ツリーに移動することもできます。</target>
        </trans-unit>
        <trans-unit id="33bb6a06b88e89af07ea98fc22445ba64a91b75d" translate="yes" xml:space="preserve">
          <source>Note that in this file, the exception for &lt;code&gt;core.bare&lt;/code&gt; and &lt;code&gt;core.worktree&lt;/code&gt; is gone. If you have them in $GIT_DIR/config before, you must move them to the &lt;code&gt;config.worktree&lt;/code&gt; of the main working tree. You may also take this opportunity to review and move other configuration that you do not want to share to all working trees:</source>
          <target state="translated">このファイルでは、 &lt;code&gt;core.bare&lt;/code&gt; および &lt;code&gt;core.worktree&lt;/code&gt; の例外がなくなっていることに注意してください。以前に$ GIT_DIR / configにある &lt;code&gt;config.worktree&lt;/code&gt; は、メインの作業ツリーのconfig.worktreeに移動する必要があります。この機会に、共有したくない他の構成を確認して、すべての作業ツリーに移動することもできます。</target>
        </trans-unit>
        <trans-unit id="22d9723cd6f0838bff4c15676f064d8d67f92e00" translate="yes" xml:space="preserve">
          <source>Note that increasing this value will increase the memory used on every relevant push that Git does over HTTP or HTTPS, since the entire buffer is allocated regardless of whether or not it is all used. Thus, it&amp;rsquo;s best to leave it at the default unless you are sure you need a different value.</source>
          <target state="translated">この値を増やすと、すべてが使用されているかどうかに関係なくバッファ全体が割り当てられるため、GitがHTTPまたはHTTPSを介して行うすべての関連プッシュで使用されるメモリが増えることに注意してください。したがって、別の値が必要であることが確実でない限り、デフォルトのままにしておくことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="f62684e2b0c86eaa1fac93a58127ba986d09144a" translate="yes" xml:space="preserve">
          <source>Note that it is currently &lt;strong&gt;always&lt;/strong&gt; an array reference, even if feature doesn&amp;rsquo;t accept any configuration parameters, and 'default' is used only to turn it on or off. In such case you turn feature on by setting this element to &lt;code&gt;[1]&lt;/code&gt;, and torn it off by setting it to &lt;code&gt;[0]&lt;/code&gt;. See also the passage about the &quot;blame&quot; feature in the &quot;Examples&quot; section.</source>
          <target state="translated">機能が構成パラメーターを受け入れない場合でも、現在は&lt;strong&gt;常に&lt;/strong&gt;配列参照であり、「デフォルト」はオンまたはオフにするためにのみ使用されることに注意してください。このような場合は、この要素を &lt;code&gt;[1]&lt;/code&gt; に設定して機能をオンにし、 &lt;code&gt;[0]&lt;/code&gt; に設定して機能をオフにします。「例」セクションの「非難」機能に関する節も参照してください。</target>
        </trans-unit>
        <trans-unit id="c6d71837c5b2acf93d8b7a746fdb13a8f313316a" translate="yes" xml:space="preserve">
          <source>Note that it is possible for refname to not have sha1-new when this hook runs. This can easily occur if another user modifies the ref after it was updated by &lt;code&gt;git-receive-pack&lt;/code&gt;, but before the hook was able to evaluate it. It is recommended that hooks rely on sha1-new rather than the current value of refname.</source>
          <target state="translated">このフックの実行時に、refnameがsha1-newを持たない可能性があることに注意してください。これは、 &lt;code&gt;git-receive-pack&lt;/code&gt; によって更新された後、フックが評価できるようになる前に、別のユーザーが参照を変更した場合に簡単に発生します。フックは、refnameの現在の値ではなく、sha1-newに依存することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="288f25c901caafda3b52f9e96d7bc31178f41bbc" translate="yes" xml:space="preserve">
          <source>Note that merge commits may have more than one parent:</source>
          <target state="translated">マージコミットは複数の親を持つ可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="f7a71f0bea03e654472a727d94dd31231e4320a4" translate="yes" xml:space="preserve">
          <source>Note that multiple helpers may be defined. See &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials[7]&lt;/a&gt; for details and examples.</source>
          <target state="translated">複数のヘルパーを定義できることに注意してください。参照してください&lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials [7]&lt;/a&gt;詳細と例について。</target>
        </trans-unit>
        <trans-unit id="b4bd4c01bcc139c9e086b4c697c46e8ed5645dbb" translate="yes" xml:space="preserve">
          <source>Note that namespaces which include a &lt;code&gt;/&lt;/code&gt; will expand to a hierarchy of namespaces; for example, &lt;code&gt;GIT_NAMESPACE=foo/bar&lt;/code&gt; will store refs under &lt;code&gt;refs/namespaces/foo/refs/namespaces/bar/&lt;/code&gt;. This makes paths in &lt;code&gt;GIT_NAMESPACE&lt;/code&gt; behave hierarchically, so that cloning with &lt;code&gt;GIT_NAMESPACE=foo/bar&lt;/code&gt; produces the same result as cloning with &lt;code&gt;GIT_NAMESPACE=foo&lt;/code&gt; and cloning from that repo with &lt;code&gt;GIT_NAMESPACE=bar&lt;/code&gt;. It also avoids ambiguity with strange namespace paths such as &lt;code&gt;foo/refs/heads/&lt;/code&gt;, which could otherwise generate directory/file conflicts within the &lt;code&gt;refs&lt;/code&gt; directory.</source>
          <target state="translated">&lt;code&gt;/&lt;/code&gt; を含む名前空間は、名前空間の階層に展開されることに注意してください。たとえば、 &lt;code&gt;GIT_NAMESPACE=foo/bar&lt;/code&gt; は、 &lt;code&gt;refs/namespaces/foo/refs/namespaces/bar/&lt;/code&gt; を格納します。これにより、 &lt;code&gt;GIT_NAMESPACE&lt;/code&gt; のパスが階層的に動作するため、 &lt;code&gt;GIT_NAMESPACE=foo/bar&lt;/code&gt; を使用したクローン作成は、 &lt;code&gt;GIT_NAMESPACE=foo&lt;/code&gt; を使用したクローン作成および &lt;code&gt;GIT_NAMESPACE=bar&lt;/code&gt; を使用したそのリポジトリからのクローン作成と同じ結果になります。また、 &lt;code&gt;foo/refs/heads/&lt;/code&gt; などの &lt;code&gt;refs&lt;/code&gt; ディレクトリ内でディレクトリ/ファイルの競合が発生する可能性がある奇妙な名前空間パスのあいまいさも回避されます。</target>
        </trans-unit>
        <trans-unit id="5960cd2f6a18c56540790aa3e8525ad5bfd7623b" translate="yes" xml:space="preserve">
          <source>Note that no attempts whatsoever are made to validate the encoding.</source>
          <target state="translated">エンコーディングを検証する試みは一切行われていないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="a90bb6c9021795be1cb1c05d155b4badc4462ac4" translate="yes" xml:space="preserve">
          <source>Note that not all diffs can feature all types. For instance, diffs from the index to the working tree can never have Added entries (because the set of paths included in the diff is limited by what is in the index). Similarly, copied and renamed entries cannot appear if detection for those types is disabled.</source>
          <target state="translated">すべての diff がすべてのタイプを特徴づけることができるわけではないことに注意してください。例えば、インデックスから作業ツリーへの diff は、追加エントリを持つことはできません (diff に含まれるパスのセットはインデックスにあるものによって制限されるからです)。同様に、コピーされたエントリや名前が変更されたエントリは、それらのタイプの検出が無効になっている場合には表示されません。</target>
        </trans-unit>
        <trans-unit id="b214bd38041e6a3ecd59f0a8d74547fecd3e66a2" translate="yes" xml:space="preserve">
          <source>Note that omitting the &lt;code&gt;=&lt;/code&gt; in &lt;code&gt;git -c foo.bar ...&lt;/code&gt; is allowed and sets &lt;code&gt;foo.bar&lt;/code&gt; to the boolean true value (just like &lt;code&gt;[foo]bar&lt;/code&gt; would in a config file). Including the equals but with an empty value (like &lt;code&gt;git -c
foo.bar= ...&lt;/code&gt;) sets &lt;code&gt;foo.bar&lt;/code&gt; to the empty string which &lt;code&gt;git config
--type=bool&lt;/code&gt; will convert to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">省略することを注意 &lt;code&gt;=&lt;/code&gt; で &lt;code&gt;git -c foo.bar ...&lt;/code&gt; 許可し、セットはされ &lt;code&gt;foo.bar&lt;/code&gt; ブール値trueに（だけのような &lt;code&gt;[foo]bar&lt;/code&gt; の設定ファイルになります）。等しいが空の値を含む（ &lt;code&gt;git -c foo.bar= ...&lt;/code&gt; ）と、 &lt;code&gt;foo.bar&lt;/code&gt; が空の文字列に &lt;code&gt;git config --type=bool&lt;/code&gt; れ &lt;code&gt;false&lt;/code&gt; 。これはgit config --type = boolがfalseに変換します。</target>
        </trans-unit>
        <trans-unit id="1650f0c21da45bf27c2f0a10dc06aba9ed69b7fe" translate="yes" xml:space="preserve">
          <source>Note that paths and refnames are split into tokens at slash boundaries. The command above would anonymize &lt;code&gt;subdir/secret.c&lt;/code&gt; as something like &lt;code&gt;path123/bar.c&lt;/code&gt;; you could then search for &lt;code&gt;bar.c&lt;/code&gt; in the anonymized repository to determine the final pathname.</source>
          <target state="translated">パスとrefnameは、スラッシュ境界でトークンに分割されることに注意してください。上記のコマンドは、 &lt;code&gt;subdir/secret.c&lt;/code&gt; を &lt;code&gt;path123/bar.c&lt;/code&gt; のようなものとして匿名化します。次に、匿名化されたリポジトリで &lt;code&gt;bar.c&lt;/code&gt; を検索して、最終的なパス名を決定できます。</target>
        </trans-unit>
        <trans-unit id="2d893e89ed900e1f0840df95a39350717d32e84c" translate="yes" xml:space="preserve">
          <source>Note that per repository configuration can be set in &lt;code&gt;$GIT_DIR/cloneurl&lt;/code&gt; file, or as values of multi-value &lt;code&gt;gitweb.url&lt;/code&gt; configuration variable in project config. Per-repository configuration takes precedence over value composed from &lt;code&gt;@git_base_url_list&lt;/code&gt; elements and project name.</source>
          <target state="translated">リポジトリごとの構成は、 &lt;code&gt;$GIT_DIR/cloneurl&lt;/code&gt; ファイルで、またはプロジェクト構成の複数値 &lt;code&gt;gitweb.url&lt;/code&gt; 構成変数の値として設定できることに注意してください。リポジトリごとの構成は、 &lt;code&gt;@git_base_url_list&lt;/code&gt; 要素とプロジェクト名から構成される値よりも優先されます。</target>
        </trans-unit>
        <trans-unit id="882882a5ca6dfe25f69ac7554d444a260301cac9" translate="yes" xml:space="preserve">
          <source>Note that raising this limit is only effective for disabling chunked transfer encoding and therefore should be used only where the remote server or a proxy only supports HTTP/1.0 or is noncompliant with the HTTP standard. Raising this is not, in general, an effective solution for most push problems, but can increase memory consumption significantly since the entire buffer is allocated even for small pushes.</source>
          <target state="translated">この制限値を上げることは、チャンク化された転送エンコーディングを無効にする場合にのみ有効であり、リモートサーバやプロキシがHTTP/1.0しかサポートしていないか、HTTP標準に準拠していない場合にのみ使用すべきであることに注意してください。これを上げることは、一般的にはほとんどのプッシュ問題に対して効果的な解決策ではありませんが、小さなプッシュに対してもバッファ全体が割り当てられるため、メモリ消費を大幅に増加させる可能性があります。</target>
        </trans-unit>
        <trans-unit id="fccadef8ff02c3c7b5e8091c077ff771f4d090ed" translate="yes" xml:space="preserve">
          <source>Note that rule 3 disallows many cases that do not have any privacy implications. These rules are subject to change in future versions of git, and the server accessed by &lt;code&gt;git archive --remote&lt;/code&gt; may or may not follow these exact rules.</source>
          <target state="translated">ルール3は、プライバシーに影響を与えない多くのケースを許可しないことに注意してください。これらのルールはgitの将来のバージョンで変更される可能性があり、 &lt;code&gt;git archive --remote&lt;/code&gt; によってアクセスされるサーバーはこれらの正確なルールに従う場合とそうでない場合があります。</target>
        </trans-unit>
        <trans-unit id="6b2cd45b5672bcfb50850c37a2d3873eae0b00dc" translate="yes" xml:space="preserve">
          <source>Note that running &lt;code&gt;git repack&lt;/code&gt; without the &lt;code&gt;--local&lt;/code&gt; option in a repository cloned with &lt;code&gt;--shared&lt;/code&gt; will copy objects from the source repository into a pack in the cloned repository, removing the disk space savings of &lt;code&gt;clone --shared&lt;/code&gt;. It is safe, however, to run &lt;code&gt;git gc&lt;/code&gt;, which uses the &lt;code&gt;--local&lt;/code&gt; option by default.</source>
          <target state="translated">&lt;code&gt;--shared&lt;/code&gt; で複製されたリポジトリで &lt;code&gt;--local&lt;/code&gt; オプションを指定せずに &lt;code&gt;git repack&lt;/code&gt; repackを実行すると、オブジェクトがソースリポジトリから複製されたリポジトリのパックにコピーされ、 &lt;code&gt;clone --shared&lt;/code&gt; によるディスク領域の節約が削除されます。ただし、デフォルトで &lt;code&gt;--local&lt;/code&gt; オプションを使用する &lt;code&gt;git gc&lt;/code&gt; を実行しても安全です。</target>
        </trans-unit>
        <trans-unit id="140dadc93eb0ab3b9abb37d56f2b3ec8284a753b" translate="yes" xml:space="preserve">
          <source>Note that since this operation is very I/O expensive, it might be a good idea to redirect the temporary directory off-disk with the &lt;code&gt;-d&lt;/code&gt; option, e.g. on tmpfs. Reportedly the speedup is very noticeable.</source>
          <target state="translated">この操作はI / Oに非常に負荷がかかるため、一時ディレクトリを &lt;code&gt;-d&lt;/code&gt; オプション（tmpfsなど）を使用してディスク外にリダイレクトすることをお勧めします。報告によると、スピードアップは非常に顕著です。</target>
        </trans-unit>
        <trans-unit id="406b2d499d377ca290ed5b4924c72cd2cd51a43f" translate="yes" xml:space="preserve">
          <source>Note that some configuration can be controlled on per-repository rather than gitweb-wide basis: see &quot;Per-repository gitweb configuration&quot; subsection on &lt;a href=&quot;gitweb&quot;&gt;gitweb[1]&lt;/a&gt; manpage.</source>
          <target state="translated">一部の構成はgitweb全体ではなくリポジトリごとに制御できることに注意してください&lt;a href=&quot;gitweb&quot;&gt;。gitweb[1]&lt;/a&gt;マンページの「リポジトリごとのgitweb構成」サブセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="ebdc2effe725ce03b669fc182e42bedc757b01ae" translate="yes" xml:space="preserve">
          <source>Note that some subcommand (e.g. &lt;code&gt;git grep&lt;/code&gt;) may behave differently when there are things on the command line other than &lt;code&gt;-h&lt;/code&gt;, but &lt;code&gt;git
subcmd -h&lt;/code&gt; without anything else on the command line is meant to consistently give the usage.</source>
          <target state="translated">いくつかのサブコマンド（たとえばことを注意 &lt;code&gt;git grep&lt;/code&gt; ）物事が以外のコマンドラインに存在する場合に、異なる動作をする場合があり &lt;code&gt;-h&lt;/code&gt; が、 &lt;code&gt;git subcmd -h&lt;/code&gt; コマンドラインで他に何もせずには一貫して使用を与えることを意味しています。</target>
        </trans-unit>
        <trans-unit id="dd6bdc1118aa11562877a299d06f5353533bbf79" translate="yes" xml:space="preserve">
          <source>Note that specifying a protocol is mandatory and if the URL doesn&amp;rsquo;t specify a hostname (e.g., &quot;cert:///path/to/file&quot;) the credential will contain a hostname attribute whose value is an empty string.</source>
          <target state="translated">プロトコルの指定は必須であり、URLでホスト名が指定されていない場合（「cert：/// path / to / file」など）、資格情報には、値が空の文字列であるホスト名属性が含まれることに注意してください。</target>
        </trans-unit>
        <trans-unit id="0d8f5c59efaf04f91fb17771a5f9956f75377d81" translate="yes" xml:space="preserve">
          <source>Note that terminology has changed since that revision. For example, the README in that revision uses the word &quot;changeset&quot; to describe what we now call a &lt;a href=&quot;#def_commit_object&quot;&gt;commit&lt;/a&gt;.</source>
          <target state="translated">その改訂以降、用語が変更されていることに注意してください。たとえば、そのリビジョンのREADMEでは、「チェンジセット」という単語を使用して、現在&lt;a href=&quot;#def_commit_object&quot;&gt;commit&lt;/a&gt;と呼んでいるものを説明しています。</target>
        </trans-unit>
        <trans-unit id="9142b2dfed27b980836bfa3cd8737a30cbbd1e38" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;name&lt;/code&gt; forms of these variables conventionally refer to some form of a personal name. See &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; and the environment variables section of &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt; for more information on these settings and the &lt;code&gt;credential.username&lt;/code&gt; option if you&amp;rsquo;re looking for authentication credentials instead.</source>
          <target state="translated">これらの変数の &lt;code&gt;name&lt;/code&gt; 形式は、通常、何らかの形式の個人名を参照していることに注意してください。これらの設定と、代わりに認証資格情報を探している場合は &lt;code&gt;credential.username&lt;/code&gt; オプションの詳細については、&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt;および&lt;a href=&quot;git&quot;&gt;git [1]&lt;/a&gt;の環境変数のセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="1162a2144d0b881d5670bbd9b0805334b2b73beb" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;t_rel&lt;/code&gt; field contains the observed run time in seconds for the child process (starting before the fork/exec/spawn and stopping after the waitpid() and includes OS process creation overhead). So this time will be slightly larger than the atexit time reported by the child process itself.</source>
          <target state="translated">&lt;code&gt;t_rel&lt;/code&gt; フィールドには、子プロセスの監視された実行時間が秒単位で含まれていることに注意してください（fork / exec / spawnの前に開始し、waitpid（）の後に停止し、OSプロセスの作成オーバーヘッドが含まれます）。したがって、この時間は、子プロセス自体によって報告されるatexit時間よりもわずかに長くなります。</target>
        </trans-unit>
        <trans-unit id="b7757b33b688da6e41f6e15271bd961d7647767a" translate="yes" xml:space="preserve">
          <source>Note that the SVN URL of the commiturl config key includes the SVN branch. If you rather want to set the commit URL for an entire SVN repository use svn-remote.&amp;lt;name&amp;gt;.pushurl instead.</source>
          <target state="translated">commiturl設定キーのSVN URLにはSVNブランチが含まれていることに注意してください。SVNリポジトリ全体のコミットURLを設定する場合は、代わりにsvn-remote。&amp;lt;name&amp;gt; .pushurlを使用してください。</target>
        </trans-unit>
        <trans-unit id="cb5d63c2ce1d70a7eb8e0b6357957166a5a229f7" translate="yes" xml:space="preserve">
          <source>Note that the asterisk &lt;code&gt;*&lt;/code&gt; is quoted from the shell in this example; this lets Git, and not the shell, expand the pathnames of files and subdirectories under the &lt;code&gt;Documentation/&lt;/code&gt; directory.</source>
          <target state="translated">この例では、アスタリスク &lt;code&gt;*&lt;/code&gt; はシェルから引用されていることに注意してください。これにより、シェルではなくGitが、 &lt;code&gt;Documentation/&lt;/code&gt; ディレクトリの下のファイルとサブディレクトリのパス名を展開できます。</target>
        </trans-unit>
        <trans-unit id="ce32bdb056375627c69f9422ed26926b9107752d" translate="yes" xml:space="preserve">
          <source>Note that the asterisk &lt;code&gt;*&lt;/code&gt; is quoted from the shell in this example; this lets the command include the files from subdirectories of &lt;code&gt;Documentation/&lt;/code&gt; directory.</source>
          <target state="translated">この例では、アスタリスク &lt;code&gt;*&lt;/code&gt; はシェルから引用されていることに注意してください。これにより、 &lt;code&gt;Documentation/&lt;/code&gt; ディレクトリのサブディレクトリからのファイルをコマンドに含めることができます。</target>
        </trans-unit>
        <trans-unit id="8938c6c44864ae040ef79f140140b8a3da4caab5" translate="yes" xml:space="preserve">
          <source>Note that the commit message will already be filled in for you with some information about the merge. Normally you can just use this default message unchanged, but you may add additional commentary of your own if desired.</source>
          <target state="translated">コミットメッセージには、マージに関する情報がすでに記入されていることに注意してください。通常はこのデフォルトのメッセージをそのまま使うことができますが、必要に応じてコメントを追加しても構いません。</target>
        </trans-unit>
        <trans-unit id="131272668a67eaa5ac9294087a9ff4488c82c210" translate="yes" xml:space="preserve">
          <source>Note that the example that we will use is really a toy example, we will be looking for the first commit that has a version like &quot;2.6.26-something&quot;, that is the commit that has a &quot;SUBLEVEL = 26&quot; line in the top level Makefile. This is a toy example because there are better ways to find this commit with Git than using &quot;git bisect&quot; (for example &quot;git blame&quot; or &quot;git log -S&amp;lt;string&amp;gt;&quot;).</source>
          <target state="translated">使用する例は実際にはおもちゃの例であることに注意してください。「2.6.26-something」のようなバージョンを持つ最初のコミットを探します。つまり、「SUBLEVEL = 26」の行があるコミットです。トップレベルのMakefile。これはおもちゃの例です。「git bisect」（「git blame」や「git log -S &amp;lt;string&amp;gt;」など）を使用するよりもGitでこのコミットを見つける方が良いためです。</target>
        </trans-unit>
        <trans-unit id="5e386156a3e0996458a30d74f4a22474e7420343" translate="yes" xml:space="preserve">
          <source>Note that the files all have mode 644 or 755: Git actually only pays attention to the executable bit.</source>
          <target state="translated">すべてのファイルが644か755のモードになっていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="d2e57a867612d1ae307185458bab810ae89e20a5" translate="yes" xml:space="preserve">
          <source>Note that the first word of an alias does not necessarily have to be a command. It can be a command-line option that will be passed into the invocation of &lt;code&gt;git&lt;/code&gt;. In particular, this is useful when used with &lt;code&gt;-c&lt;/code&gt; to pass in one-time configurations or &lt;code&gt;-p&lt;/code&gt; to force pagination. For example, &lt;code&gt;loud-rebase = -c commit.verbose=true rebase&lt;/code&gt; can be defined such that running &lt;code&gt;git loud-rebase&lt;/code&gt; would be equivalent to &lt;code&gt;git -c commit.verbose=true rebase&lt;/code&gt;. Also, &lt;code&gt;ps = -p status&lt;/code&gt; would be a helpful alias since &lt;code&gt;git ps&lt;/code&gt; would paginate the output of &lt;code&gt;git status&lt;/code&gt; where the original command does not.</source>
          <target state="translated">エイリアスの最初の単語は必ずしもコマンドである必要はないことに注意してください。 &lt;code&gt;git&lt;/code&gt; の呼び出しに渡されるコマンドラインオプションにすることができます。特に、これは &lt;code&gt;-c&lt;/code&gt; とともに使用して1回限りの構成で渡す場合、または &lt;code&gt;-p&lt;/code&gt; を使用して強制的にページ分割を行う場合に役立ちます。たとえば、 &lt;code&gt;loud-rebase = -c commit.verbose=true rebase&lt;/code&gt; は、 &lt;code&gt;git loud-rebase&lt;/code&gt; を実行すると &lt;code&gt;git -c commit.verbose=true rebase&lt;/code&gt; と同等になるように定義できます。また、 &lt;code&gt;git ps&lt;/code&gt; は元のコマンドでは行われない &lt;code&gt;git status&lt;/code&gt; の出力にページ番号を付けるため、 &lt;code&gt;ps = -p status&lt;/code&gt; は便利なエイリアスになります。</target>
        </trans-unit>
        <trans-unit id="650b87912cfe39dc5747fbba67473a3822f86ab9" translate="yes" xml:space="preserve">
          <source>Note that the form &lt;code&gt;--filter=sparse:path=&amp;lt;path&amp;gt;&lt;/code&gt; that wants to read from an arbitrary path on the filesystem has been dropped for security reasons.</source>
          <target state="translated">ファイルシステムの任意のパスから読み取りたい &lt;code&gt;--filter=sparse:path=&amp;lt;path&amp;gt;&lt;/code&gt; という形式は、セキュリティ上の理由から削除されていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="d8075e043d9a3ca9826ff1989c66c1905d9648ca" translate="yes" xml:space="preserve">
          <source>Note that the grafts mechanism is outdated and can lead to problems transferring objects between repositories; see &lt;a href=&quot;git-replace&quot;&gt;git-replace[1]&lt;/a&gt; for a more flexible and robust system to do the same thing.</source>
          <target state="translated">接ぎ木メカニズムは時代遅れであり、リポジトリ間でオブジェクトを転送するときに問題が発生する可能性があることに注意してください。同じことを行うためのより柔軟で堅牢なシステムについては、&lt;a href=&quot;git-replace&quot;&gt;git-replace [1]&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="0b0bdd8828d416a94597b15ce8aefc2c0b976fde" translate="yes" xml:space="preserve">
          <source>Note that the last point clashes with the other two: a topic that has been merged elsewhere should not be rebased. See the section on RECOVERING FROM UPSTREAM REBASE in &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt;.</source>
          <target state="translated">最後の点は他の2つと衝突することに注意してください。他の場所にマージされたトピックはリベースしないでください。&lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]の&lt;/a&gt; UPSTREAM REBASEからの復旧に関するセクションをご覧ください。</target>
        </trans-unit>
        <trans-unit id="bd4901c4d1f08f37f3106399dbc26a76568f48fe" translate="yes" xml:space="preserve">
          <source>Note that the leading character does not have to be a dot; for example, you can use &lt;code&gt;--suffix=-patch&lt;/code&gt; to get &lt;code&gt;0001-description-of-my-change-patch&lt;/code&gt;.</source>
          <target state="translated">先頭の文字がドットである必要はないことに注意してください。たとえば、-- &lt;code&gt;--suffix=-patch&lt;/code&gt; を使用して &lt;code&gt;0001-description-of-my-change-patch&lt;/code&gt; を取得できます。</target>
        </trans-unit>
        <trans-unit id="833f1e85ef857dfcde43c87fdacaaa1075b0d6b3" translate="yes" xml:space="preserve">
          <source>Note that the maintainer(s) may impose restrictions, such as &quot;Signed-off-by&quot; requirements, that all commits/patches submitted for inclusion must adhere to. Consult your project&amp;rsquo;s documentation for more information.</source>
          <target state="translated">メンテナは、 &quot;Signed-off-by&quot;の要件など、含めるために送信されたすべてのコミット/パッチが遵守しなければならない制限を課す場合があることに注意してください。詳細については、プロジェクトのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="50f092ab1e91fa0de2c9ed05785c4a967888dc6a" translate="yes" xml:space="preserve">
          <source>Note that the name &quot;origin&quot; is just the name that Git uses by default to refer to the repository that you cloned from.</source>
          <target state="translated">なお、&quot;origin &quot;という名前は、デフォルトではGitがクローンしたリポジトリを参照するために使用する名前にすぎません。</target>
        </trans-unit>
        <trans-unit id="22728656f144a546aef50a70cd21a26fce3a8c1d" translate="yes" xml:space="preserve">
          <source>Note that the patch is always used as-is without charset conversion, even with this flag.</source>
          <target state="translated">このフラグがあっても、パッチは常に文字コード変換をせずにそのまま使用されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="9bea9d7e3f1393135579965b1439ff9a7baaf238" translate="yes" xml:space="preserve">
          <source>Note that the push URL and the fetch URL, even though they can be set differently, must still refer to the same place. What you pushed to the push URL should be what you would see if you immediately fetched from the fetch URL. If you are trying to fetch from one place (e.g. your upstream) and push to another (e.g. your publishing repository), use two separate remotes.</source>
          <target state="translated">プッシュ URL とフェッチ URL は、設定が異なっていても同じ場所を参照しなければならないことに注意してください。プッシュ URL にプッシュしたものは、フェッチ URL からすぐにフェッチした場合に表示されるものでなければなりません。ある場所(アップストリームなど)からフェッチして、別の場所(パブリッシングリポジトリなど)にプッシュしようとしている場合は、2つの別々のリモートを使用します。</target>
        </trans-unit>
        <trans-unit id="f8efe69c6940942131795b6ce6c48d7e64d9560b" translate="yes" xml:space="preserve">
          <source>Note that the reflog history is very different from normal Git history. While normal history is shared by every repository that works on the same project, the reflog history is not shared: it tells you only about how the branches in your local repository have changed over time.</source>
          <target state="translated">reflog の履歴は、通常の Git の履歴とは大きく異なることに注意しましょう。通常の履歴は同じプロジェクトで働くすべてのリポジトリで共有されますが、 reflog の履歴は共有されません。</target>
        </trans-unit>
        <trans-unit id="9a9c3b4049e20efd5a28033d7014008a8c2ac264" translate="yes" xml:space="preserve">
          <source>Note that the script (&lt;code&gt;my_script&lt;/code&gt; in the above example) should exit with code 0 if the current source code is good/old, and exit with a code between 1 and 127 (inclusive), except 125, if the current source code is bad/new.</source>
          <target state="translated">スクリプト（上記の例では &lt;code&gt;my_script&lt;/code&gt; ）は、現在のソースコードが良好/古い場合はコード0で終了し、現在のソースコードが不正な場合は125を除いて1〜127（両端を含む）のコードで終了することに注意してください。新着。</target>
        </trans-unit>
        <trans-unit id="5586aefc0f8bd69c9dcf3cf3294d72d0db17f0fc" translate="yes" xml:space="preserve">
          <source>Note that the second point is true even across machines. You can duplicate a remote Git repository with &lt;strong&gt;any&lt;/strong&gt; regular copy mechanism, be it &lt;code&gt;scp&lt;/code&gt;, &lt;code&gt;rsync&lt;/code&gt; or &lt;code&gt;wget&lt;/code&gt;.</source>
          <target state="translated">2番目のポイントは、マシン間でも当てはまることに注意してください。 &lt;code&gt;scp&lt;/code&gt; 、 &lt;code&gt;rsync&lt;/code&gt; 、 &lt;code&gt;wget&lt;/code&gt; など、通常のコピーメカニズムを&lt;strong&gt;使用し&lt;/strong&gt;てリモートGitリポジトリを複製できます。</target>
        </trans-unit>
        <trans-unit id="e9e6bb5468c99a3a334f80fab3dbb52fc16223c6" translate="yes" xml:space="preserve">
          <source>Note that the session-id of the child process is not available to the current/spawning process, so the child&amp;rsquo;s PID is reported here as a hint for post-processing. (But it is only a hint because the child process may be a shell script which doesn&amp;rsquo;t have a session-id.)</source>
          <target state="translated">子プロセスのセッションIDは現在のプロセス/生成プロセスでは使用できないため、子プロセスのヒントとして子のPIDがここで報告されることに注意してください。（ただし、子プロセスはセッションIDを持たないシェルスクリプトである可能性があるため、これはヒントにすぎません。）</target>
        </trans-unit>
        <trans-unit id="e98f559f39ce7645bbbb14c50cc4f9c4dc239749" translate="yes" xml:space="preserve">
          <source>Note that the sizes of objects on disk are reported accurately, but care should be taken in drawing conclusions about which refs or objects are responsible for disk usage. The size of a packed non-delta object may be much larger than the size of objects which delta against it, but the choice of which object is the base and which is the delta is arbitrary and is subject to change during a repack.</source>
          <target state="translated">ディスク上のオブジェクトのサイズは正確に報告されていますが、どの参照先やオブジェクトがディスクの使用に影響を与えているかについての結論を出す際には注意が必要です。パックされた非デルタオブジェクトのサイズは、それに対してデルタするオブジェクトのサイズよりもはるかに大きいかもしれませんが、どのオブジェクトをベースとし、どのオブジェクトをデルタとするかの選択は任意であり、リパック中に変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="47fc7cad6a527b522ab5e266e3e278a07a579735" translate="yes" xml:space="preserve">
          <source>Note that the suffix you get if you type these commands today may be longer than what Linus saw above when he ran these commands, as your Git repository may have new commits whose object names begin with 975b that did not exist back then, and &quot;-g975b&quot; suffix alone may not be sufficient to disambiguate these commits.</source>
          <target state="translated">今日これらのコマンドを入力したときに得られるサフィックスは、Linus が上記のコマンドを実行したときのものよりも長いものになるかもしれないことに注意しましょう。</target>
        </trans-unit>
        <trans-unit id="7eeba5803dc504042af48f9504a175baa6f39016" translate="yes" xml:space="preserve">
          <source>Note that the target of a &lt;code&gt;push&lt;/code&gt; is normally a &lt;a href=&quot;#def_bare_repository&quot;&gt;bare&lt;/a&gt; repository. You can also push to a repository that has a checked-out working tree, but a push to update the currently checked-out branch is denied by default to prevent confusion. See the description of the receive.denyCurrentBranch option in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;push&lt;/code&gt; のターゲットは通常、&lt;a href=&quot;#def_bare_repository&quot;&gt;ベア&lt;/a&gt;リポジトリであることに注意してください。チェックアウトされた作業ツリーがあるリポジトリにプッシュすることもできますが、混乱を避けるために、現在チェックアウトされているブランチを更新するプッシュはデフォルトで拒否されます。詳細については、&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;のreceive.denyCurrentBranchオプションの説明を参照してください。</target>
        </trans-unit>
        <trans-unit id="110e365a18d2e41e53b11ff50c7bbd9d01eae2f0" translate="yes" xml:space="preserve">
          <source>Note that the two techniques outlined above (exporting via &lt;a href=&quot;#exporting-via-http&quot;&gt;http&lt;/a&gt; or &lt;a href=&quot;#exporting-via-git&quot;&gt;git&lt;/a&gt;) allow other maintainers to fetch your latest changes, but they do not allow write access, which you will need to update the public repository with the latest changes created in your private repository.</source>
          <target state="translated">上記の2つの手法（&lt;a href=&quot;#exporting-via-http&quot;&gt;http&lt;/a&gt;または&lt;a href=&quot;#exporting-via-git&quot;&gt;git&lt;/a&gt;を介したエクスポート）では、他のメンテナーが最新の変更を取得できますが、書き込みアクセスは許可されません。プライベートリポジトリで作成された最新の変更でパブリックリポジトリを更新する必要があります。</target>
        </trans-unit>
        <trans-unit id="ae8ea7d3546a16ede3faa6039563fb0d737e4467" translate="yes" xml:space="preserve">
          <source>Note that the version which &lt;code&gt;git bisect&lt;/code&gt; checks out for you at each point is just a suggestion, and you&amp;rsquo;re free to try a different version if you think it would be a good idea. For example, occasionally you may land on a commit that broke something unrelated; run</source>
          <target state="translated">&lt;code&gt;git bisect&lt;/code&gt; が各時点でチェックアウトするバージョンは単なる提案であり、良いアイデアだと思われる場合は、別のバージョンを自由に試すことができます。たとえば、関係のない何かを壊したコミットに時折遭遇するかもしれません。走る</target>
        </trans-unit>
        <trans-unit id="1000c60b0f402f5d9e4c69088fd79818a06e5e98" translate="yes" xml:space="preserve">
          <source>Note that there are two ways to checkout a particular branch. As described elsewhere on this page, the &quot;module&quot; parameter of cvs checkout is interpreted as a branch name, and it becomes the main branch. It remains the main branch for a given sandbox even if you temporarily make another branch sticky with cvs update -r. Alternatively, the -r argument can indicate some other branch to actually checkout, even though the module is still the &quot;main&quot; branch. Tradeoffs (as currently implemented): Each new &quot;module&quot; creates a new database on disk with a history for the given module, and after the database is created, operations against that main branch are fast. Or alternatively, -r doesn&amp;rsquo;t take any extra disk space, but may be significantly slower for many operations, like cvs update.</source>
          <target state="translated">特定のブランチをチェックアウトするには2つの方法があることに注意してください。このページの他の場所で説明されているように、cvs checkoutの「モジュール」パラメーターはブランチ名として解釈され、メインブランチになります。 cvs update -rを使用して一時的に別のブランチをスティッキーにした場合でも、特定のサンドボックスのメインブランチのままです。または、モジュールがまだ「メイン」ブランチである場合でも、-r引数は実際にチェックアウトする他のブランチを示すことができます。トレードオフ（現在実装されているもの）：新しい「モジュール」ごとに、指定されたモジュールの履歴を持つディスク上に新しいデータベースが作成され、データベースが作成された後、そのメインブランチに対する操作は高速です。または、-rは余分なディスク容量を必要としませんが、cvs updateなどの多くの操作では大幅に遅くなる可能性があります。</target>
        </trans-unit>
        <trans-unit id="4fe39a3f8a6c98b987fad41f0865478fee4d146d" translate="yes" xml:space="preserve">
          <source>Note that these are applied before commit ordering and formatting options, such as &lt;code&gt;--reverse&lt;/code&gt;.</source>
          <target state="translated">これらは、-- &lt;code&gt;--reverse&lt;/code&gt; などのコミットの順序付けとフォーマットのオプションの前に適用されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="33723cad0621665104eb7762cf8f60a246a13517" translate="yes" xml:space="preserve">
          <source>Note that these configuration variables should probably be set using the &lt;code&gt;--global&lt;/code&gt; flag, for example like this:</source>
          <target state="translated">これらの構成変数は、おそらく次のように &lt;code&gt;--global&lt;/code&gt; フラグを使用して設定する必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="ccb8cdc33c08512e4436bbf3b8db5bc9921ae58d" translate="yes" xml:space="preserve">
          <source>Note that this affects all diff-based output types, e.g. those produced by &lt;code&gt;--stat&lt;/code&gt;, etc.</source>
          <target state="translated">これは、すべてのdiffベースの出力タイプ、たとえば &lt;code&gt;--stat&lt;/code&gt; によって生成される出力タイプなどに影響することに注意してください。</target>
        </trans-unit>
        <trans-unit id="0691624d8498eccd40578875388b7f8bab2a7b6c" translate="yes" xml:space="preserve">
          <source>Note that this applies only to accessing the repository&amp;rsquo;s disk contents directly. An older client which understands only format &lt;code&gt;0&lt;/code&gt; may still connect via &lt;code&gt;git://&lt;/code&gt; to a repository using format &lt;code&gt;1&lt;/code&gt;, as long as the server process understands format &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">これは、リポジトリのディスクコンテンツに直接アクセスする場合にのみ適用されることに注意してください。サーバープロセスがフォーマット &lt;code&gt;1&lt;/code&gt; を理解している限り、フォーマット &lt;code&gt;0&lt;/code&gt; のみを &lt;code&gt;git://&lt;/code&gt; 古いクライアントは、フォーマット &lt;code&gt;1&lt;/code&gt; を使用してgit：//経由でリポジトリに接続できます。</target>
        </trans-unit>
        <trans-unit id="c3528bf60e5e55bcec2b34b4efbb66a2e2ad0ca9" translate="yes" xml:space="preserve">
          <source>Note that this assumes that none of the blobs and commit messages referenced by that revision range contains the string &lt;code&gt;refs/heads/master&lt;/code&gt;.</source>
          <target state="translated">これは、そのリビジョン範囲によって参照されるblobおよびコミットメッセージのいずれにも文字列 &lt;code&gt;refs/heads/master&lt;/code&gt; が含まれていないことを前提としています。</target>
        </trans-unit>
        <trans-unit id="b2c1b09dd03782a35574f4220ce1860b1a59abed" translate="yes" xml:space="preserve">
          <source>Note that this configuration variable is ignored if it is seen in the repository-level config (this is a safety measure against fetching from untrusted repositories).</source>
          <target state="translated">この設定変数がリポジトリレベルの設定で見られる場合は無視されることに注意してください (これは信頼されていないリポジトリからのフェッチに対する安全対策です)。</target>
        </trans-unit>
        <trans-unit id="8243e24ce26ee48638bea5b267bba5916eee07a8" translate="yes" xml:space="preserve">
          <source>Note that this is currently only implemented for the client side of clones and fetches.</source>
          <target state="translated">現在のところ、これはクローンとフェッチのクライアント側にのみ実装されていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="7278e2ca069b871494710e49f702957a299741e8" translate="yes" xml:space="preserve">
          <source>Note that this is the old file data; so the object that Git named in its response to the initial tree was a tree with a snapshot of the directory state that was recorded by the first commit.</source>
          <target state="translated">これは古いファイルデータなので、Git が最初のツリーに対するレスポンスで名付けたオブジェクトは、最初のコミットで記録されたディレクトリの状態のスナップショットを含むツリーでした。</target>
        </trans-unit>
        <trans-unit id="8524e2a4579b70a19e36821a3f8f1b43bac12c4a" translate="yes" xml:space="preserve">
          <source>Note that this list is non-comprehensive and not necessarily complete. For command-specific variables, you will find a more detailed description in the appropriate manual page.</source>
          <target state="translated">このリストは包括的なものではなく、必ずしも完全なものではないことに注意してください。コマンド固有の変数については、該当するマニュアルページに詳細な説明があります。</target>
        </trans-unit>
        <trans-unit id="a06dd344c0e0f4252ac8d0d18c1815e7f413d617" translate="yes" xml:space="preserve">
          <source>Note that this may contain embedded LF or CRLF characters that are not escaped, so the event may spill across multiple lines.</source>
          <target state="translated">これには、エスケープされていないLFまたはCRLF文字が埋め込まれている可能性があるため、イベントが複数の行にまたがる可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="954610f540e4dda45ac67b28e742adb370b9dd1c" translate="yes" xml:space="preserve">
          <source>Note that this may mean that multiple Git commits are created for a single SVN revision.</source>
          <target state="translated">これは、一つの SVN リビジョンに対して複数の Git コミットが作成されていることを意味することに注意してください。</target>
        </trans-unit>
        <trans-unit id="69a24fcf6b082a94d6b3e16af2197fed496268e4" translate="yes" xml:space="preserve">
          <source>Note that this option is only useful if you are actually sending the emails and want to identify yourself as the sender, but retain the original author (and &lt;code&gt;git am&lt;/code&gt; will correctly pick up the in-body header). Note also that &lt;code&gt;git send-email&lt;/code&gt; already handles this transformation for you, and this option should not be used if you are feeding the result to &lt;code&gt;git send-email&lt;/code&gt;.</source>
          <target state="translated">このオプションは、実際にメールを送信していて、自分を送信者として識別したいが、元の作成者は保持する場合にのみ役立つことに注意してください（ &lt;code&gt;git am&lt;/code&gt; は、本文のヘッダーを正しく取得します）。 &lt;code&gt;git send-email&lt;/code&gt; がすでにこの変換を処理していることにも注意してください。結果を &lt;code&gt;git send-email&lt;/code&gt; に送る場合は、このオプションを使用しないでください。</target>
        </trans-unit>
        <trans-unit id="d0a34c500aa8e9fdf22f16d59ae03a1a8711ff64" translate="yes" xml:space="preserve">
          <source>Note that this option uses the no overlay mode by default (see also &lt;code&gt;--overlay&lt;/code&gt;), and currently doesn&amp;rsquo;t support overlay mode.</source>
          <target state="translated">このオプションはデフォルトでオーバーレイなしモードを使用し（ &lt;code&gt;--overlay&lt;/code&gt; も参照）、現在オーバーレイモードをサポートしていないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="c4360f69bfd218e96ff125f09b08b60281e46fca" translate="yes" xml:space="preserve">
          <source>Note that this setting should only be set by &lt;a href=&quot;git-init&quot;&gt;git-init[1]&lt;/a&gt; or &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt;. Trying to change it after initialization will not work and will produce hard-to-diagnose issues.</source>
          <target state="translated">この設定は、&lt;a href=&quot;git-init&quot;&gt;git-init [1]&lt;/a&gt;または&lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt;によってのみ設定する必要があることに注意してください。初期化後に変更しようとすると機能せず、診断が難しい問題が発生します。</target>
        </trans-unit>
        <trans-unit id="e3aa2cd05420cf442d246cf6450d49e1768c842c" translate="yes" xml:space="preserve">
          <source>Note that this variable is honored even when set in a configuration file in a &quot;.git&quot; subdirectory of a directory and its value differs from the latter directory (e.g. &quot;/path/to/.git/config&quot; has core.worktree set to &quot;/different/path&quot;), which is most likely a misconfiguration. Running Git commands in the &quot;/path/to&quot; directory will still use &quot;/different/path&quot; as the root of the work tree and can cause confusion unless you know what you are doing (e.g. you are creating a read-only snapshot of the same index to a location different from the repository&amp;rsquo;s usual working tree).</source>
          <target state="translated">この変数は、ディレクトリの「.git」サブディレクトリにある構成ファイルで設定された場合でも尊重され、その値は後者のディレクトリとは異なります（たとえば、「/ path / to / .git / config」ではcore.worktreeが&quot;/ different / path&quot;）、これはおそらく構成の誤りです。&quot;/ path / to&quot;ディレクトリでGitコマンドを実行すると、作業ツリーのルートとして &quot;/ different / path&quot;が引き続き使用され、何をしているのかわからない場合（たとえば、読み取り専用のスナップショットを作成している場合）リポジトリの通常の作業ツリーとは異なる場所への同じインデックス）。</target>
        </trans-unit>
        <trans-unit id="f66853802a66e4aff14a38d5843516f4164ff5ba" translate="yes" xml:space="preserve">
          <source>Note that this will create the new branch, but it will not switch the working tree to it; use &quot;git switch &amp;lt;newbranch&amp;gt;&quot; to switch to the new branch.</source>
          <target state="translated">これは新しいブランチを作成しますが、作業ツリーをブランチに切り替えないことに注意してください。「git switch &amp;lt;newbranch&amp;gt;」を使用して、新しいブランチに切り替えます。</target>
        </trans-unit>
        <trans-unit id="f6e42ae8cab92e791d65bf753cdda97ba478a01b" translate="yes" xml:space="preserve">
          <source>Note that unless one of &lt;code&gt;-c&lt;/code&gt;, &lt;code&gt;--cc&lt;/code&gt;, or &lt;code&gt;-m&lt;/code&gt; is given, merge commits will never show a diff, even if a diff format like &lt;code&gt;--patch&lt;/code&gt; is selected, nor will they match search options like &lt;code&gt;-S&lt;/code&gt;. The exception is when &lt;code&gt;--first-parent&lt;/code&gt; is in use, in which merges are treated like normal single-parent commits (this can be overridden by providing a combined-diff option or with &lt;code&gt;--no-diff-merges&lt;/code&gt;).</source>
          <target state="translated">なお、のいずれかの場合を除き &lt;code&gt;-c&lt;/code&gt; 、 &lt;code&gt;--cc&lt;/code&gt; 、または &lt;code&gt;-m&lt;/code&gt; を指定すると、マージコミットがあってもdiff形式のように、差分を表示することはありません &lt;code&gt;--patch&lt;/code&gt; ように選択され、また彼らが一致する検索オプション &lt;code&gt;-S&lt;/code&gt; 。例外は、 &lt;code&gt;--first-parent&lt;/code&gt; が使用されている場合です。この場合、マージは通常の単一親コミットのように扱われます（これは、combined-diffオプションを提供するか、 &lt;code&gt;--no-diff-merges&lt;/code&gt; mergesを使用してオーバーライドできます）。</target>
        </trans-unit>
        <trans-unit id="48c8adea213e6ac01f80c59a6b72ca8bc5d0c4be" translate="yes" xml:space="preserve">
          <source>Note that unreachable, packed objects will remain. If this is not desired, see &lt;a href=&quot;git-repack&quot;&gt;git-repack[1]&lt;/a&gt;.</source>
          <target state="translated">到達できないパックされたオブジェクトが残ることに注意してください。これが望ましくない場合は、&lt;a href=&quot;git-repack&quot;&gt;git-repack [1]を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="f9c873a19166627d45cbe06c1e92f0fc64675a0f" translate="yes" xml:space="preserve">
          <source>Note that users fetching over dumb protocols will have to fetch the whole new pack in order to get any contained object, no matter how many other objects in that pack they already have locally.</source>
          <target state="translated">ダムプロトコルをフェッチしているユーザは、そのパックに含まれているオブジェクトを取得するためには、そのパックに含まれているオブジェクトがローカルにいくつあったとしても、新しいパック全体をフェッチしなければならないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="511b177ad0f4f309a1f22f8d5a0729bb57a27072" translate="yes" xml:space="preserve">
          <source>Note that we deliberately chose not to re-code the commit log message when a commit is made to force UTF-8 at the commit object level, because re-coding to UTF-8 is not necessarily a reversible operation.</source>
          <target state="translated">コミット時にコミットログメッセージを再コードしないようにしたのは、コミットオブジェクトレベルでUTF-8を強制するためです。</target>
        </trans-unit>
        <trans-unit id="352feed71993cca2768c0de80ab4efdfef627645" translate="yes" xml:space="preserve">
          <source>Note that we pick a single island for each regex to go into, using &quot;last one wins&quot; ordering (which allows repo-specific config to take precedence over user-wide config, and so forth).</source>
          <target state="translated">各regexに対して、&quot;last one wins &quot;の順序を使って、1つの島を選んでいることに注意してください (これにより、レポ固有の設定がユーザー全体の設定などよりも優先されるようになります)。</target>
        </trans-unit>
        <trans-unit id="0f413678af329d8b352f68927252d8a326f2b212" translate="yes" xml:space="preserve">
          <source>Note that when matching against a tree object, attributes are still obtained from working tree, not from the given tree object.</source>
          <target state="translated">ツリーオブジェクトに対してマッチングを行う場合、属性は与えられたツリーオブジェクトからではなく、作業ツリーから取得されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="6f16ff14e66ecdeaed0888755a04ec80e3903de7" translate="yes" xml:space="preserve">
          <source>Note that when providing a &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt;, you must use &lt;code&gt;--list&lt;/code&gt;; otherwise the command may be interpreted as branch creation.</source>
          <target state="translated">&lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; を指定する場合は、-- &lt;code&gt;--list&lt;/code&gt; 使用する必要があることに注意してください。そうでない場合、コマンドはブランチの作成と解釈される場合があります。</target>
        </trans-unit>
        <trans-unit id="2e31fbecbd095ab339f753f545ee8ad3cdcfd7be" translate="yes" xml:space="preserve">
          <source>Note that when you&amp;rsquo;ve moved or copied a Git repository, your Git index file (which caches various information, notably some of the &quot;stat&quot; information for the files involved) will likely need to be refreshed. So after you do a &lt;code&gt;cp -a&lt;/code&gt; to create a new copy, you&amp;rsquo;ll want to do</source>
          <target state="translated">Gitリポジトリを移動またはコピーした場合、Gitインデックスファイル（さまざまな情報、特に関連するファイルの「stat」情報の一部をキャッシュする）を更新する必要がある可能性があります。したがって、 &lt;code&gt;cp -a&lt;/code&gt; を実行して新しいコピーを作成した後、</target>
        </trans-unit>
        <trans-unit id="b6e7add23d70ae9c79a92003e95b0646493f7240" translate="yes" xml:space="preserve">
          <source>Note that without &lt;code&gt;--full-history&lt;/code&gt;, this still simplifies merges: if one of the parents is TREESAME, we follow only that one, so the other sides of the merge are never walked.</source>
          <target state="translated">&lt;code&gt;--full-history&lt;/code&gt; がなくても、これはマージを単純化することに注意してください。親の1つがTREESAMEの場合、その1つだけに従うため、マージの反対側は決して実行されません。</target>
        </trans-unit>
        <trans-unit id="26c6b6e45f05961054f9762544f517daa6e3a44f" translate="yes" xml:space="preserve">
          <source>Note that without parent rewriting, it is not really possible to talk about the parent/child relationships between the commits, so we show them disconnected.</source>
          <target state="translated">親の書き換えがないと、コミット間の親子関係を語ることが本当にできないので、切り離して表示していることに注意してください。</target>
        </trans-unit>
        <trans-unit id="40996350a13d178ee15ae3215e9ae292d6702c1c" translate="yes" xml:space="preserve">
          <source>Note that you can get more information on a packfile by calling &lt;a href=&quot;git-verify-pack&quot;&gt;git-verify-pack[1]&lt;/a&gt;. However, as this command considers only the index file itself, it&amp;rsquo;s both faster and more flexible.</source>
          <target state="translated">&lt;a href=&quot;git-verify-pack&quot;&gt;git-verify-pack [1]を&lt;/a&gt;呼び出すことで、パックファイルの詳細情報を取得できることに注意してください。ただし、このコマンドではインデックスファイル自体しか考慮されないため、より高速で柔軟性があります。</target>
        </trans-unit>
        <trans-unit id="191247c1388c3f45dfe82bf6b2f0384fea86edc8" translate="yes" xml:space="preserve">
          <source>Note that you cannot generally put &lt;code&gt;git for-each-ref&lt;/code&gt; directly into the config value, as it does not take a repository path as an argument (but you can wrap the command above in a shell script).</source>
          <target state="translated">あなたは、一般的に置くことができないことを注意 &lt;code&gt;git for-each-ref&lt;/code&gt; それは、引数としてリポジトリのパスを取ることはありません（ただし、シェルスクリプトで上記のコマンドをラップすることができます）と、設定値に直接。</target>
        </trans-unit>
        <trans-unit id="0fb44a035d4df6f6306133b267ae1546e220d2ba" translate="yes" xml:space="preserve">
          <source>Note that you should not do Octopus just because you can. An octopus is a valid thing to do and often makes it easier to view the commit history if you are merging more than two independent changes at the same time. However, if you have merge conflicts with any of the branches you are merging in and need to hand resolve, that is an indication that the development happened in those branches were not independent after all, and you should merge two at a time, documenting how you resolved the conflicts, and the reason why you preferred changes made in one side over the other. Otherwise it would make the project history harder to follow, not easier.</source>
          <target state="translated">オクトパスはできるからといってやってはいけないことに注意してください。オクトパスを行うことは有効なことであり、二つ以上の独立した変更を同時にマージしている場合、コミット履歴を見るのが簡単になることがよくあります。しかし、マージしているブランチのいずれかとマージの競合があり、手作業で解決する必要がある場合は、そのブランチで起こった開発が結局は独立していなかったことを示しているので、一度に二つのブランチをマージし、競合をどのように解決したのか、そして、一方のブランチでの変更を他方のブランチよりも優先した理由を文書化しておくべきです。そうしないと、プロジェクトの歴史を追うのが難しくなります。</target>
        </trans-unit>
        <trans-unit id="482be6a864fbdcc5f9a936e9708b6d9c3eb14ff5" translate="yes" xml:space="preserve">
          <source>Note the addition of the &lt;code&gt;+&lt;/code&gt; sign. Alternatively, you can use the &lt;code&gt;-f&lt;/code&gt; flag to force the remote update, as in:</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; 記号が追加されていることに注意してください。または、次のように &lt;code&gt;-f&lt;/code&gt; フラグを使用してリモート更新を強制できます。</target>
        </trans-unit>
        <trans-unit id="c14d9654c43dfc38c5ce0e390578cf211f8eb175" translate="yes" xml:space="preserve">
          <source>Note the addition of the &lt;code&gt;+&lt;/code&gt; sign. Alternatively, you can use the &lt;code&gt;-f&lt;/code&gt; flag to force updates of all the fetched branches, as in:</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; 記号が追加されていることに注意してください。または、次のように &lt;code&gt;-f&lt;/code&gt; フラグを使用して、フェッチされたすべてのブランチを強制的に更新できます。</target>
        </trans-unit>
        <trans-unit id="2261964ad436001973909975a060cb501a98c780" translate="yes" xml:space="preserve">
          <source>Note the last point. Do &lt;code&gt;not&lt;/code&gt; use &lt;code&gt;git pull&lt;/code&gt; unless you actually want to merge the remote branch.</source>
          <target state="translated">最後の点に注意してください。リモートブランチを実際にマージする必要がない限り、 &lt;code&gt;git pull&lt;/code&gt; を使用し &lt;code&gt;not&lt;/code&gt; ください。</target>
        </trans-unit>
        <trans-unit id="b5d534f9876445dbbed162e13c3b9e1bade912b4" translate="yes" xml:space="preserve">
          <source>Note the major differences in &lt;code&gt;N&lt;/code&gt;, &lt;code&gt;P&lt;/code&gt;, and &lt;code&gt;Q&lt;/code&gt; over &lt;code&gt;--full-history&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;--full-history&lt;/code&gt; に対する &lt;code&gt;N&lt;/code&gt; 、 &lt;code&gt;P&lt;/code&gt; 、および &lt;code&gt;Q&lt;/code&gt; の主な違いに注意してください。</target>
        </trans-unit>
        <trans-unit id="592ed4ba86d62c504859114fd8d03df0827a06fa" translate="yes" xml:space="preserve">
          <source>Note the quotes around &lt;code&gt;*.c&lt;/code&gt;. The file &lt;code&gt;hello.c&lt;/code&gt; will also be checked out, even though it is no longer in the working tree, because the file globbing is used to match entries in the index (not in the working tree by the shell).</source>
          <target state="translated">&lt;code&gt;*.c&lt;/code&gt; の前後の引用符に注意してください。ファイル &lt;code&gt;hello.c&lt;/code&gt; は、作業ツリーには存在しなくても、チェックアウトされます。これは、ファイルグロビングがインデックスのエントリの照合に使用されるためです（シェルでは作業ツリーではありません）。</target>
        </trans-unit>
        <trans-unit id="d840183324e7e2c4b1d9b149ae89bf837a67da9c" translate="yes" xml:space="preserve">
          <source>Note the quotes around &lt;code&gt;*.c&lt;/code&gt;. The file &lt;code&gt;hello.c&lt;/code&gt; will also be restored, even though it is no longer in the working tree, because the file globbing is used to match entries in the index (not in the working tree by the shell).</source>
          <target state="translated">&lt;code&gt;*.c&lt;/code&gt; の前後の引用符に注意してください。ファイルグロビングはインデックス内のエントリの照合に使用されるため（シェルでは作業ツリーではない）、ファイル &lt;code&gt;hello.c&lt;/code&gt; も復元されます。</target>
        </trans-unit>
        <trans-unit id="86811ec658abf1645177c2f89c78cd1610e7ea04" translate="yes" xml:space="preserve">
          <source>Note what happens to the different &lt;code&gt;git diff-*&lt;/code&gt; versions here. After we&amp;rsquo;ve updated &lt;code&gt;hello&lt;/code&gt; in the index, &lt;code&gt;git diff-files -p&lt;/code&gt; now shows no differences, but &lt;code&gt;git diff-index -p HEAD&lt;/code&gt; still &lt;strong&gt;does&lt;/strong&gt; show that the current state is different from the state we committed. In fact, now &lt;code&gt;git diff-index&lt;/code&gt; shows the same difference whether we use the &lt;code&gt;--cached&lt;/code&gt; flag or not, since now the index is coherent with the working tree.</source>
          <target state="translated">ここで異なる &lt;code&gt;git diff-*&lt;/code&gt; バージョンに何が起こるか注意してください。インデックスの &lt;code&gt;hello&lt;/code&gt; を更新した後、 &lt;code&gt;git diff-files -p&lt;/code&gt; は違いを表示しなくなりましたが、 &lt;code&gt;git diff-index -p HEAD&lt;/code&gt; &lt;strong&gt;は&lt;/strong&gt;、現在の状態がコミットした状態と異なることをまだ示しています。実際、今では &lt;code&gt;git diff-index&lt;/code&gt; は &lt;code&gt;--cached&lt;/code&gt; フラグを使用してもしなくても同じ違いを示しています。これは、インデックスが作業ツリーと一貫しているためです。</target>
        </trans-unit>
        <trans-unit id="c96f5bf9205aae211cb148d5f8bcf4fb9ebed15b" translate="yes" xml:space="preserve">
          <source>Note, by the way, that lots of commands take a tree as an argument. But as we can see above, a tree can be referred to in many different ways&amp;mdash;​by the SHA-1 name for that tree, by the name of a commit that refers to the tree, by the name of a branch whose head refers to that tree, etc.--and most such commands can accept any of these names.</source>
          <target state="translated">ちなみに、多くのコマンドはツリーを引数として取ることに注意してください。しかし、上記のように、ツリーはさまざまな方法で参照できます。ツリーのSHA-1名、ツリーを参照するコミットの名前、ヘッドが参照するブランチの名前そのツリーなどに-そしてそのようなコマンドのほとんどはこれらの名前のどれでも受け入れることができます。</target>
        </trans-unit>
        <trans-unit id="ba28d9bd22f696c9f9b774765c5cbeba6fcd1342" translate="yes" xml:space="preserve">
          <source>Note, for the reasons stated above usage of context-free patches is discouraged.</source>
          <target state="translated">上記の理由から、コンテキストフリーのパッチの使用はお勧めしません。</target>
        </trans-unit>
        <trans-unit id="22eddd855ac86c24360d06b5276ff8c7e192d879" translate="yes" xml:space="preserve">
          <source>Note, this safety check does not mean that a checkout will generate a file identical to the original file for a different setting of &lt;code&gt;core.eol&lt;/code&gt; and &lt;code&gt;core.autocrlf&lt;/code&gt;, but only for the current one. For example, a text file with &lt;code&gt;LF&lt;/code&gt; would be accepted with &lt;code&gt;core.eol=lf&lt;/code&gt; and could later be checked out with &lt;code&gt;core.eol=crlf&lt;/code&gt;, in which case the resulting file would contain &lt;code&gt;CRLF&lt;/code&gt;, although the original file contained &lt;code&gt;LF&lt;/code&gt;. However, in both work trees the line endings would be consistent, that is either all &lt;code&gt;LF&lt;/code&gt; or all &lt;code&gt;CRLF&lt;/code&gt;, but never mixed. A file with mixed line endings would be reported by the &lt;code&gt;core.safecrlf&lt;/code&gt; mechanism.</source>
          <target state="translated">この安全性チェックは、チェックアウトが &lt;code&gt;core.eol&lt;/code&gt; と &lt;code&gt;core.autocrlf&lt;/code&gt; の異なる設定に対して元のファイルと同一のファイルを生成することを意味するのではなく、現在のファイルに対してのみ生成することに注意してください。たとえば、 &lt;code&gt;LF&lt;/code&gt; を含むテキストファイルは &lt;code&gt;core.eol=lf&lt;/code&gt; で受け入れられ、後で &lt;code&gt;core.eol=crlf&lt;/code&gt; でチェックアウトできます。その場合、元のファイルには &lt;code&gt;LF&lt;/code&gt; が含まれていても、結果のファイルには &lt;code&gt;CRLF&lt;/code&gt; が含まれます。ただし、どちらの作業ツリーでも、 &lt;code&gt;CRLF&lt;/code&gt; は一貫しています。つまり、すべて &lt;code&gt;LF&lt;/code&gt; またはすべてCRLFですが、決して混在しません。行末が混在するファイルは、 &lt;code&gt;core.safecrlf&lt;/code&gt; によって報告されます。 機構。</target>
        </trans-unit>
        <trans-unit id="955b317bd13857ee21eddce08c9664927a950a2e" translate="yes" xml:space="preserve">
          <source>Note. A single level of backslashes are eaten by the configuration file parser, so you would need to double the backslashes; the pattern above picks a line that begins with a backslash, and zero or more occurrences of &lt;code&gt;sub&lt;/code&gt; followed by &lt;code&gt;section&lt;/code&gt; followed by open brace, to the end of line.</source>
          <target state="translated">注意。単一レベルのバックスラッシュが構成ファイルパーサーによって使用されるため、バックスラッシュを2倍にする必要があります。上記のパターンは、バックスラッシュで始まる行を選択し、0個以上の &lt;code&gt;sub&lt;/code&gt; の後に &lt;code&gt;section&lt;/code&gt; 続き、開き括弧が続き、行の終わりまで続きます。</target>
        </trans-unit>
        <trans-unit id="c3a8d5b6840faaf677f5d3f6a79125e45b041b0b" translate="yes" xml:space="preserve">
          <source>Note. When the &quot;-C&quot; option is used with &lt;code&gt;--find-copies-harder&lt;/code&gt; option, &lt;code&gt;git diff-*&lt;/code&gt; commands feed unmodified filepairs to diffcore mechanism as well as modified ones. This lets the copy detector consider unmodified files as copy source candidates at the expense of making it slower. Without &lt;code&gt;--find-copies-harder&lt;/code&gt;, &lt;code&gt;git diff-*&lt;/code&gt; commands can detect copies only if the file that was copied happened to have been modified in the same changeset.</source>
          <target state="translated">注意。 「-C」オプションを &lt;code&gt;--find-copies-harder&lt;/code&gt; オプションと共に使用すると、 &lt;code&gt;git diff-*&lt;/code&gt; コマンドは、変更されていないファイルペアを変更されたファイルペアだけでなく、diffcoreメカニズムにもフィードします。これにより、コピー検出機能は、変更を遅くする代わりに、変更されていないファイルをコピー元の候補と見なします。なければ &lt;code&gt;--find-copies-harder&lt;/code&gt; 、 &lt;code&gt;git diff-*&lt;/code&gt; コマンドは、コピーされたファイルは同じチェンジで変更されたために起こった場合にのみ、コピーを検出することができます。</target>
        </trans-unit>
        <trans-unit id="9ed1ac27dff5378ed96f590f4322050a04cabf6d" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;git revert&lt;/code&gt; is used to record some new commits to reverse the effect of some earlier commits (often only a faulty one). If you want to throw away all uncommitted changes in your working directory, you should see &lt;a href=&quot;git-reset&quot;&gt;git-reset[1]&lt;/a&gt;, particularly the &lt;code&gt;--hard&lt;/code&gt; option. If you want to extract specific files as they were in another commit, you should see &lt;a href=&quot;git-restore&quot;&gt;git-restore[1]&lt;/a&gt;, specifically the &lt;code&gt;--source&lt;/code&gt; option. Take care with these alternatives as both will discard uncommitted changes in your working directory.</source>
          <target state="translated">注： &lt;code&gt;git revert&lt;/code&gt; は、いくつかの新しいコミットを記録して、以前のコミット（多くの場合、障害のあるコミットのみ）の影響を元に戻すために使用されます。作業ディレクトリでコミットされていないすべての変更を &lt;code&gt;--hard&lt;/code&gt; 場合は、&lt;a href=&quot;git-reset&quot;&gt;git-reset [1]&lt;/a&gt;、特に--hardオプションが表示されます。別のコミットと同じように特定のファイルを抽出する場合は、&lt;a href=&quot;git-restore&quot;&gt;git-restore [1]&lt;/a&gt;、特に &lt;code&gt;--source&lt;/code&gt; オプションが表示されます。どちらも作業ディレクトリ内のコミットされていない変更を破棄するため、これらの選択肢には注意してください。</target>
        </trans-unit>
        <trans-unit id="6007883f602581f1393822506c41cbfbfd02c805" translate="yes" xml:space="preserve">
          <source>Note: A thin pack violates the packed archive format by omitting required objects and is thus unusable by Git without making it self-contained. Use &lt;code&gt;git index-pack --fix-thin&lt;/code&gt; (see &lt;a href=&quot;git-index-pack&quot;&gt;git-index-pack[1]&lt;/a&gt;) to restore the self-contained property.</source>
          <target state="translated">注：シンパックは、必要なオブジェクトを省略することでパックアーカイブ形式に違反するため、自己完結型にしないとGitで使用できません。使用 &lt;code&gt;git index-pack --fix-thin&lt;/code&gt; （参照&lt;a href=&quot;git-index-pack&quot;&gt;のgit-インデックスパック[1] &lt;/a&gt;）自己完結型のプロパティを復元します。</target>
        </trans-unit>
        <trans-unit id="1f8f5701942fbb7ebefa9dee3f4f37f4528c7cfd" translate="yes" xml:space="preserve">
          <source>Note: Make sure you quote the result when passing it to &lt;code&gt;eval&lt;/code&gt;. See below for an example.</source>
          <target state="translated">注： &lt;code&gt;eval&lt;/code&gt; に渡すときは、必ず結果を引用してください。例については、以下を参照してください。</target>
        </trans-unit>
        <trans-unit id="b0f0e4e61a2bb004cf3ec68d5169e8ba972a47ee" translate="yes" xml:space="preserve">
          <source>Note: Newer CVS versions (&amp;gt;= 1.12.11) also support specifying CVS_SERVER directly in CVSROOT like</source>
          <target state="translated">注：新しいCVSバージョン（&amp;gt; = 1.12.11）では、CVSROOTで直接CVS_SERVERを指定することもできます。</target>
        </trans-unit>
        <trans-unit id="b833243d544e1089f2767ea8843cab2eed5526b2" translate="yes" xml:space="preserve">
          <source>Note: Porcelain commands such as &lt;code&gt;git gc&lt;/code&gt; (see &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt;), &lt;code&gt;git repack&lt;/code&gt; (see &lt;a href=&quot;git-repack&quot;&gt;git-repack[1]&lt;/a&gt;) pass this option by default in modern Git when they put objects in your repository into pack files. So does &lt;code&gt;git bundle&lt;/code&gt; (see &lt;a href=&quot;git-bundle&quot;&gt;git-bundle[1]&lt;/a&gt;) when it creates a bundle.</source>
          <target state="translated">注： &lt;code&gt;git gc&lt;/code&gt; （&lt;a href=&quot;git-gc&quot;&gt;git-gc [1]を&lt;/a&gt;参照）、 &lt;code&gt;git repack&lt;/code&gt; （&lt;a href=&quot;git-repack&quot;&gt;git-repack [1]を&lt;/a&gt;参照）などの磁器コマンドは、リポジトリ内のオブジェクトをパックファイルに入れるときに、デフォルトでこのオプションを渡します。そうする &lt;code&gt;git bundle&lt;/code&gt; （参照&lt;a href=&quot;git-bundle&quot;&gt;のgit-バンドルを[1]&lt;/a&gt;それはバンドルを作成します）。</target>
        </trans-unit>
        <trans-unit id="7a04bc9af081bc88d648e6675a2308737bd31c23" translate="yes" xml:space="preserve">
          <source>Note: Some inetd servers let you specify the name of the executable independently of the value of argv[0] (i.e. the name the program assumes it was executed with). In this case the correct line in /etc/inetd.conf looks like</source>
          <target state="translated">注意:inetd サーバの中には argv[0]の値とは別に実行ファイルの名前を指定できるものがあります (つまり、プログラムが実行されたと仮定した名前)。この場合、/etc/inetd.conf の正しい行は次のようになります。</target>
        </trans-unit>
        <trans-unit id="722ccad077353010f3a3bf5b634c417679782a2c" translate="yes" xml:space="preserve">
          <source>Note: Whenever the clean filter is changed, the repo should be renormalized: $ git add --renormalize .</source>
          <target state="translated">Note:クリーンフィルタを変更したときはいつでも、レポをリノーマライズしなければなりません。</target>
        </trans-unit>
        <trans-unit id="e979029bca285fbda95b190d7e0a6ad42b034f7b" translate="yes" xml:space="preserve">
          <source>Note: the first command (&lt;code&gt;label onto&lt;/code&gt;) labels the revision onto which the commits are rebased; The name &lt;code&gt;onto&lt;/code&gt; is just a convention, as a nod to the &lt;code&gt;--onto&lt;/code&gt; option.</source>
          <target state="translated">注：最初のコマンド（ &lt;code&gt;label onto&lt;/code&gt; on）は、コミットがリベースされるリビジョンにラベルを付けます。 &lt;code&gt;onto&lt;/code&gt; という名前は &lt;code&gt;--onto&lt;/code&gt; オプションのうなずきとして、単なる慣例です。</target>
        </trans-unit>
        <trans-unit id="c1bc321618eb470344ec0a0359d287ae90474ae5" translate="yes" xml:space="preserve">
          <source>Note: the following core Perl modules that may be installed with your distribution of Perl are required: MIME::Base64, MIME::QuotedPrint, Net::Domain and Net::SMTP. These additional Perl modules are also required: Authen::SASL and Mail::Address.</source>
          <target state="translated">注意:Perl のディストリビューションと一緒にインストールされている可能性のある以下のコア Perl モジュールが必要です。MIME::Base64、MIME::QuotedPrint、Net::Domain および Net::SMTP。これらの追加の Perl モジュールも必要です。Authen::SASL および Mail::Address です。</target>
        </trans-unit>
        <trans-unit id="9ca0395056bb808a73d2de7297fac7a555e73c25" translate="yes" xml:space="preserve">
          <source>Note: you can specify the default pretty format in the repository configuration (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">注：リポジトリ設定でデフォルトのpretty形式を指定できます（&lt;a href=&quot;git-config&quot;&gt;git-config [1]を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="399df4ce8f932f9b96c0fdefbfc88e37bceafef0" translate="yes" xml:space="preserve">
          <source>Note: you need to ensure each user that is going to invoke &lt;code&gt;git-cvsserver&lt;/code&gt; has write access to the log file and to the database (see &lt;a href=&quot;#dbbackend&quot;&gt;Database Backend&lt;/a&gt;. If you want to offer write access over SSH, the users of course also need write access to the Git repository itself.</source>
          <target state="translated">注： &lt;code&gt;git-cvsserver&lt;/code&gt; を呼び出す各ユーザーがログファイルとデータベースへの書き込みアクセス権を持っていることを確認する必要があります（&lt;a href=&quot;#dbbackend&quot;&gt;データベースバックエンドを&lt;/a&gt;参照してください。SSH経由で書き込みアクセス権を提供する場合は、もちろんユーザーにも書き込みアクセス権が必要です。 Gitリポジトリ自体に。</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="803fb7d2ab5d83b44291b7856ec7ac09a4ad4990" translate="yes" xml:space="preserve">
          <source>Notes can also be added to patches prepared with &lt;code&gt;git format-patch&lt;/code&gt; by using the &lt;code&gt;--notes&lt;/code&gt; option. Such notes are added as a patch commentary after a three dash separator line.</source>
          <target state="translated">&lt;code&gt;--notes&lt;/code&gt; オプションを使用して、 &lt;code&gt;git format-patch&lt;/code&gt; で作成したパッチにメモを追加することもできます。このようなメモは、3つのダッシュの区切り線の後にパッチ解説として追加されます。</target>
        </trans-unit>
        <trans-unit id="680f18d9848c14869bd7dca451d5f596480f4677" translate="yes" xml:space="preserve">
          <source>Notes merge strategies</source>
          <target state="translated">ノートのマージ戦略</target>
        </trans-unit>
        <trans-unit id="abd4e292c73314f22de94f0e2806350a1ebe4452" translate="yes" xml:space="preserve">
          <source>Notes on frequently confused options</source>
          <target state="translated">よく混同するオプションの注意点</target>
        </trans-unit>
        <trans-unit id="2ae531e195e6eb05828dc645d74752ea4fda83e4" translate="yes" xml:space="preserve">
          <source>Notes on threads</source>
          <target state="translated">スレッドに関する注意事項</target>
        </trans-unit>
        <trans-unit id="f5aa58376045f00b2abde3758c9ee9232861fade" translate="yes" xml:space="preserve">
          <source>Notes ref to read and manipulate instead of &lt;code&gt;refs/notes/commits&lt;/code&gt;. Must be an unabbreviated ref name. This setting can be overridden through the environment and command line.</source>
          <target state="translated">&lt;code&gt;refs/notes/commits&lt;/code&gt; の代わりに、Notesは読み取りと操作を参照します。省略されていない参照名でなければなりません。この設定は、環境とコマンドラインで上書きできます。</target>
        </trans-unit>
        <trans-unit id="27c7345a105341e9d7ed2a9f6b06c674d31c0796" translate="yes" xml:space="preserve">
          <source>Notice all types of potential whitespace errors known to Git. The tab width is taken from the value of the &lt;code&gt;core.whitespace&lt;/code&gt; configuration variable.</source>
          <target state="translated">Gitが認識しているあらゆるタイプの潜在的な空白エラーに注意してください。タブ幅は、 &lt;code&gt;core.whitespace&lt;/code&gt; 構成変数の値から取得されます。</target>
        </trans-unit>
        <trans-unit id="b1fa74b0ca5d38d82ab602be416ab241bc186864" translate="yes" xml:space="preserve">
          <source>Notice that regardless of which checkout command we use, &lt;code&gt;HEAD&lt;/code&gt; now refers directly to commit &lt;code&gt;b&lt;/code&gt;. This is known as being in detached &lt;code&gt;HEAD&lt;/code&gt; state. It means simply that &lt;code&gt;HEAD&lt;/code&gt; refers to a specific commit, as opposed to referring to a named branch. Let&amp;rsquo;s see what happens when we create a commit:</source>
          <target state="translated">使用するチェックアウトコマンドに関係なく、 &lt;code&gt;HEAD&lt;/code&gt; はcommit &lt;code&gt;b&lt;/code&gt; を直接参照するようになりました。これは、切り離された &lt;code&gt;HEAD&lt;/code&gt; 状態であると呼ばれます。これは単に、名前付きブランチを指すのではなく、 &lt;code&gt;HEAD&lt;/code&gt; が特定のコミットを指すことを意味します。コミットを作成するとどうなるか見てみましょう：</target>
        </trans-unit>
        <trans-unit id="394d5767b4ce0798e4d7b91dc89c97c41a6b7f18" translate="yes" xml:space="preserve">
          <source>Notice that since &lt;code&gt;M&lt;/code&gt; is reachable from &lt;code&gt;R&lt;/code&gt;, the edge from &lt;code&gt;N&lt;/code&gt; to &lt;code&gt;M&lt;/code&gt; was simplified away. However, &lt;code&gt;N&lt;/code&gt; still appears in the history as an important commit because it &quot;pulled&quot; the change &lt;code&gt;R&lt;/code&gt; into the main branch.</source>
          <target state="translated">&lt;code&gt;M&lt;/code&gt; は &lt;code&gt;R&lt;/code&gt; から到達可能であるため、 &lt;code&gt;N&lt;/code&gt; から &lt;code&gt;M&lt;/code&gt; へのエッジが単純化されていることに注意してください。ただし、 &lt;code&gt;N&lt;/code&gt; は、変更 &lt;code&gt;R&lt;/code&gt; をメインブランチに「プル」したため、重要なコミットとして履歴に表示されます。</target>
        </trans-unit>
        <trans-unit id="223ae08c12689ce4cda40425ac912a2b7bc15955" translate="yes" xml:space="preserve">
          <source>Notify the helper this is a clone request (i.e. the current repository is guaranteed empty).</source>
          <target state="translated">ヘルパーにこれがクローン要求であることを通知します (つまり、現在のリポジトリが空であることが保証されます)。</target>
        </trans-unit>
        <trans-unit id="4abfc187ad76ac88063d3dc9dd98a5854ac68fcf" translate="yes" xml:space="preserve">
          <source>Now add the changes to the index that you want to have in the first commit. You can use &lt;code&gt;git add&lt;/code&gt; (possibly interactively) or &lt;code&gt;git gui&lt;/code&gt; (or both) to do that.</source>
          <target state="translated">ここで、最初のコミットで使用するインデックスに変更を追加します。これを行うには、 &lt;code&gt;git add&lt;/code&gt; （おそらく対話式）または &lt;code&gt;git gui&lt;/code&gt; （またはその両方）を使用できます。</target>
        </trans-unit>
        <trans-unit id="f89d262ba51a934099d56714cbb679d531203dd2" translate="yes" xml:space="preserve">
          <source>Now clone the superproject:</source>
          <target state="translated">今すぐスーパープロジェクトのクローンを作成してください。</target>
        </trans-unit>
        <trans-unit id="ba793c9ae00cb4d237b36de220bcaff0d64b7a28" translate="yes" xml:space="preserve">
          <source>Now create the branches in which you are going to work; these start out at the current tip of origin/master branch, and should be set up (using the &lt;code&gt;--track&lt;/code&gt; option to &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt;) to merge changes in from Linus by default.</source>
          <target state="translated">次に、作業するブランチを作成します。これらはorigin / masterブランチの現在の先端から始まり、（&lt;a href=&quot;git-branch&quot;&gt;git-branch [1]&lt;/a&gt;の &lt;code&gt;--track&lt;/code&gt; オプションを使用して）デフォルトでLinusからの変更をマージするようにセットアップする必要があります。</target>
        </trans-unit>
        <trans-unit id="b3aa6a5493fd6ad1a98101f846b1686abf42b2c1" translate="yes" xml:space="preserve">
          <source>Now create the superproject and add all the submodules:</source>
          <target state="translated">さて、スーパープロジェクトを作成し、すべてのサブモジュールを追加します。</target>
        </trans-unit>
        <trans-unit id="aec2ee2ebf7f0a1017c29bcb872a25ae6bf7b23d" translate="yes" xml:space="preserve">
          <source>Now is a good point to take a break to let this information sink in.</source>
          <target state="translated">今は、この情報を流し込むために休憩を取るのに良いポイントです。</target>
        </trans-unit>
        <trans-unit id="8125d3bd8f5c390de8746d2ef58ce50b7de72c0b" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s suppose that commit J is bad and commit G is good and that we apply the bisection algorithm like it has been previously described.</source>
          <target state="translated">ここで、コミットJが不良でコミットGが良好であり、前述のように二分法アルゴリズムを適用するとします。</target>
        </trans-unit>
        <trans-unit id="880aeec71bcb81a6f397f1be442543fc2e21cab4" translate="yes" xml:space="preserve">
          <source>Now suppose that Joe wants his middle name initial used, and Jane prefers her family name fully spelled out. A proper &lt;code&gt;.mailmap&lt;/code&gt; file would look like:</source>
          <target state="translated">ここで、ジョーがミドルネームのイニシャルを使用することを望み、ジェーンは完全に綴られた姓を好むとします。適切な &lt;code&gt;.mailmap&lt;/code&gt; ファイルは次のようになります。</target>
        </trans-unit>
        <trans-unit id="3e7c06961fbf7a9468c5f87e472b9bdf95e1fa5a" translate="yes" xml:space="preserve">
          <source>Now to apply some patches from the community. Think of a short snappy name for a branch to hold this patch (or related group of patches), and create a new branch from a recent stable tag of Linus&amp;rsquo;s branch. Picking a stable base for your branch will: 1) help you: by avoiding inclusion of unrelated and perhaps lightly tested changes 2) help future bug hunters that use &lt;code&gt;git bisect&lt;/code&gt; to find problems</source>
          <target state="translated">コミュニティからのパッチをいくつか適用します。このパッチ（または関連するパッチのグループ）を保持するブランチの簡潔な名前を考え、Linusのブランチの最近の安定したタグから新しいブランチを作成します。ブランチの安定したベースを選択すると、1）助けになります：関連のない、おそらく軽くテストされた変更が含まれないようにすることで2） &lt;code&gt;git bisect&lt;/code&gt; を使用する将来のバグハンターが問題を見つけるのに役立ちます</target>
        </trans-unit>
        <trans-unit id="31a13e21421ef92e8ef4a0a89bea77231f7d36fb" translate="yes" xml:space="preserve">
          <source>Now use &lt;code&gt;git submodule update&lt;/code&gt; to clone the repositories and check out the commits specified in the superproject:</source>
          <target state="translated">&lt;code&gt;git submodule update&lt;/code&gt; を使用してリポジトリのクローンを作成し、スーパープロジェクトで指定されたコミットを確認します。</target>
        </trans-unit>
        <trans-unit id="93f7a0302cd464e3e88673ccf5b8a8b034507a50" translate="yes" xml:space="preserve">
          <source>Now we are ready to experiment with the merge by hand.</source>
          <target state="translated">これで、手でマージの実験ができるようになりました。</target>
        </trans-unit>
        <trans-unit id="0479e792f6adb8abb7cacffe33ca0f7a5b48ab2f" translate="yes" xml:space="preserve">
          <source>Now we will suppose that there is only one &quot;first bad commit&quot;. This means that all its descendants are &quot;bad&quot; and all the other commits are &quot;good&quot;. And we will suppose that all commits have an equal probability of being good or bad, or of being the first bad commit, so knowing the state of c commits gives always the same amount of information wherever these c commits are on the graph and whatever c is. (So we suppose that these commits being for example on a branch or near a good or a bad commit does not give more or less information).</source>
          <target state="translated">ここでは、「最初の悪いコミット」が1つしかないと仮定します。これは、その子孫はすべて &quot;不良 &quot;であり、他のコミットはすべて &quot;良 &quot;であることを意味します。そして、すべてのコミットが良いコミットであるか悪いコミットであるか、最初の悪いコミットであるかは同じ確率であると仮定します。(つまり、これらのコミットが例えばブランチ上にあったり、良いコミットや悪いコミットの近くにあったりしても、情報量が多くなったり少なくなったりすることはないと仮定します)。</target>
        </trans-unit>
        <trans-unit id="16cb16561e679da512d88420e76326b5c722ec8f" translate="yes" xml:space="preserve">
          <source>Now when the background process runs &lt;code&gt;git fetch origin&lt;/code&gt; the references on &lt;code&gt;origin-push&lt;/code&gt; won&amp;rsquo;t be updated, and thus commands like:</source>
          <target state="translated">これで、バックグラウンドプロセスが &lt;code&gt;git fetch origin&lt;/code&gt; を実行するとき、 &lt;code&gt;origin-push&lt;/code&gt; の参照は更新されないため、次のようなコマンドが実行されます。</target>
        </trans-unit>
        <trans-unit id="3ecf9739a1d0abf420c43be7ddca1b7fc46c48f7" translate="yes" xml:space="preserve">
          <source>Now you apply the patch(es), run some tests, and commit the change(s). If the patch is a multi-part series, then you should apply each as a separate commit to this branch.</source>
          <target state="translated">ここで、パッチを適用し、テストを実行し、変更をコミットします。パッチが複数のパートに分かれている場合は、それぞれを別々のコミットとしてこのブランチに適用してください。</target>
        </trans-unit>
        <trans-unit id="ac8b110d69f8df7d9503ad0a18549a8731f4daf9" translate="yes" xml:space="preserve">
          <source>Now you are wiser, because you know that it happened 940 revisions before v0.99.</source>
          <target state="translated">v0.99以前の940リビジョンで起きていたことを知っているので、今のあなたはより賢明です。</target>
        </trans-unit>
        <trans-unit id="54796c29834d872153c55921bf00540d7c6165a5" translate="yes" xml:space="preserve">
          <source>Now you can proceed with the creation of the feature release. Apply a tag to the tip of &lt;code&gt;master&lt;/code&gt; indicating the release version:</source>
          <target state="translated">これで、機能リリースの作成に進むことができます。 &lt;code&gt;master&lt;/code&gt; の先端にリリースバージョンを示すタグを適用します。</target>
        </trans-unit>
        <trans-unit id="d60447094204d4dec9840c772eacade572f28205" translate="yes" xml:space="preserve">
          <source>Now you know that blob 4b9458b3 is missing, and that the tree 2d9263c6 points to it. If you could find just one copy of that missing blob object, possibly in some other repository, you could move it into &lt;code&gt;.git/objects/4b/9458b3&amp;hellip;​&lt;/code&gt; and be done. Suppose you can&amp;rsquo;t. You can still examine the tree that pointed to it with &lt;a href=&quot;git-ls-tree&quot;&gt;git-ls-tree[1]&lt;/a&gt;, which might output something like:</source>
          <target state="translated">これで、blob 4b9458b3が欠落し、ツリー2d9263c6がそれを指していることがわかりました。あなたはおそらくいくつかの他のリポジトリに、その欠落しているブロブオブジェクトのただ一つのコピーを見つけることができれば、あなたにそれを動かすことができ &lt;code&gt;.git/objects/4b/9458b3&amp;hellip;​&lt;/code&gt; と行われます。できないとしましょう。&lt;a href=&quot;git-ls-tree&quot;&gt;git-ls-tree [1]を使用して&lt;/a&gt;、それを指し示しているツリーを調べることができます。</target>
        </trans-unit>
        <trans-unit id="27bdc85bfa21b19b41e38ad33e104e7c138a6d4d" translate="yes" xml:space="preserve">
          <source>Now you know that blob 4b9458b3 is missing, and that the tree 2d9263c6 points to it. If you could find just one copy of that missing blob object, possibly in some other repository, you could move it into &lt;code&gt;.git/objects/4b/9458b3...&lt;/code&gt; and be done. Suppose you can&amp;rsquo;t. You can still examine the tree that pointed to it with &lt;a href=&quot;git-ls-tree&quot;&gt;git-ls-tree[1]&lt;/a&gt;, which might output something like:</source>
          <target state="translated">これで、blob 4b9458b3が欠落しており、ツリー2d9263c6がそれを指していることがわかります。欠落しているblobオブジェクトのコピーが1つだけ見つかった場合は、おそらく他のリポジトリで、それを &lt;code&gt;.git/objects/4b/9458b3...&lt;/code&gt; 移動して実行できます。できないとしましょう。&lt;a href=&quot;git-ls-tree&quot;&gt;git-ls-tree [1]を使用して&lt;/a&gt;、それを指しているツリーを引き続き調べることができます。</target>
        </trans-unit>
        <trans-unit id="c93b9bdc902ddf8466cfefc51dc1f28429545152" translate="yes" xml:space="preserve">
          <source>Now you&amp;rsquo;ve split out many of the changes into their own commits, and might no longer use the patch mode of &lt;code&gt;git add&lt;/code&gt;, in order to select all remaining uncommitted changes.</source>
          <target state="translated">これで、変更の多くを独自のコミットに分割しました。残りのコミットされていないすべての変更を選択するために、 &lt;code&gt;git add&lt;/code&gt; のパッチモードを使用しない可能性があります。</target>
        </trans-unit>
        <trans-unit id="69b6ae43249b3d4c8e61d7b20084413cd49e5e3e" translate="yes" xml:space="preserve">
          <source>Now, for the meat:</source>
          <target state="translated">さて、お肉です。</target>
        </trans-unit>
        <trans-unit id="4449e60d3fdd6703a4970ef116187e4c17d80dc4" translate="yes" xml:space="preserve">
          <source>Now, in this case we&amp;rsquo;ve intentionally created a situation where the merge will need to be fixed up by hand, though, so Git will do as much of it as it can automatically (which in this case is just merge the &lt;code&gt;example&lt;/code&gt; file, which had no differences in the &lt;code&gt;mybranch&lt;/code&gt; branch), and say:</source>
          <target state="translated">さて、この場合、意図的にマージを手動で修正する必要がある状況を作成しました。そのため、Gitはできる限り多くのことを自動的に実行します（この場合は &lt;code&gt;example&lt;/code&gt; ファイルをマージするだけです）。 &lt;code&gt;mybranch&lt;/code&gt; ブランチに違いはありませんでした）、そして言う：</target>
        </trans-unit>
        <trans-unit id="93036e7630aadf8fab80b9b1079ffb3d1ea1e18f" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s pretend you are the one who did all the work in &lt;code&gt;mybranch&lt;/code&gt;, and the fruit of your hard work has finally been merged to the &lt;code&gt;master&lt;/code&gt; branch. Let&amp;rsquo;s go back to &lt;code&gt;mybranch&lt;/code&gt;, and run &lt;code&gt;git merge&lt;/code&gt; to get the &quot;upstream changes&quot; back to your branch.</source>
          <target state="translated">さて、あなたが &lt;code&gt;mybranch&lt;/code&gt; ですべての作業を行った人であると仮定しましょう。あなたのハードワークの成果がついに &lt;code&gt;master&lt;/code&gt; ブランチにマージされました。 &lt;code&gt;mybranch&lt;/code&gt; に戻り、 &lt;code&gt;git merge&lt;/code&gt; を実行して、「上流の変更」をブランチに戻しましょう。</target>
        </trans-unit>
        <trans-unit id="7c23965b9cba90dec960d959f0eea85b60ea2b28" translate="yes" xml:space="preserve">
          <source>Now, since we&amp;rsquo;ve updated &lt;code&gt;hello&lt;/code&gt; in the index, we can commit the new version. We could do it by writing the tree by hand again, and committing the tree (this time we&amp;rsquo;d have to use the &lt;code&gt;-p HEAD&lt;/code&gt; flag to tell commit that the HEAD was the &lt;strong&gt;parent&lt;/strong&gt; of the new commit, and that this wasn&amp;rsquo;t an initial commit any more), but you&amp;rsquo;ve done that once already, so let&amp;rsquo;s just use the helpful script this time:</source>
          <target state="translated">これで、インデックスの &lt;code&gt;hello&lt;/code&gt; を更新したので、新しいバージョンをコミットできます。ツリーをもう一度手で書いて、ツリーをコミットすることでそれを行うことができます（今回は &lt;code&gt;-p HEAD&lt;/code&gt; フラグを使用して、HEADが新しいコミットの&lt;strong&gt;親&lt;/strong&gt;であり、これはそうではなかったことをコミットに伝える必要があります）最初のコミットはこれ以上ありませんが、すでに一度実行したので、今回は役立つスクリプトを使用します。</target>
        </trans-unit>
        <trans-unit id="dfab069f398c1bff7a8b8aa3dadd95d2ce84088a" translate="yes" xml:space="preserve">
          <source>Now, to make it a bit more interesting, let&amp;rsquo;s assume that somebody else does some work in the original branch, and simulate that by going back to the master branch, and editing the same file differently there:</source>
          <target state="translated">ここで、もう少し面白くするために、他の誰かが元のブランチで作業を行っていると想定し、masterブランチに戻って同じファイルを別の場所で編集することでそれをシミュレートします。</target>
        </trans-unit>
        <trans-unit id="83bf1df5f5028baeb9804ff8b012e2bfb43363e7" translate="yes" xml:space="preserve">
          <source>Now, we want to go to the next stage in Git, which is to take the files that Git knows about in the index, and commit them as a real tree. We do that in two phases: creating a &lt;code&gt;tree&lt;/code&gt; object, and committing that &lt;code&gt;tree&lt;/code&gt; object as a &lt;code&gt;commit&lt;/code&gt; object together with an explanation of what the tree was all about, along with information of how we came to that state.</source>
          <target state="translated">ここで、Gitの次のステージに進みます。つまり、Gitがインデックスで認識しているファイルを取得し、それらを実際のツリーとしてコミットします。これは2つのフェーズで行います。 &lt;code&gt;tree&lt;/code&gt; オブジェクトを作成し、その &lt;code&gt;tree&lt;/code&gt; オブジェクトを &lt;code&gt;commit&lt;/code&gt; オブジェクトとしてコミットするとともに、ツリーの概要と、その状態になった方法に関する情報を提供します。</target>
        </trans-unit>
        <trans-unit id="4b50314ab323fb71cb3292dbd2b0326c17673414" translate="yes" xml:space="preserve">
          <source>Now, you will get the rewritten history saved in HEAD.</source>
          <target state="translated">これで、HEADに保存されている書き換え履歴が手に入ります。</target>
        </trans-unit>
        <trans-unit id="575836ebc8e262c11aa86a9dd4e0c52f7d072bcd" translate="yes" xml:space="preserve">
          <source>Now, you&amp;rsquo;ve got two branches, and you decide that you want to merge the work done. Before we do that, let&amp;rsquo;s introduce a cool graphical tool that helps you view what&amp;rsquo;s going on:</source>
          <target state="translated">これで、2つのブランチがあり、完了した作業をマージすることにしました。その前に、何が起こっているのかを確認するのに役立つクールなグラフィカルツールを紹介しましょう。</target>
        </trans-unit>
        <trans-unit id="910f1e558e60364937a941e26d7def6b701f836e" translate="yes" xml:space="preserve">
          <source>Nowadays though gitweb should create HTML base tag when needed (to set base URI for relative links), so it should work automatically.</source>
          <target state="translated">最近のgitwebは必要に応じてHTMLのベースタグを作成するようになっているので(相対リンクのベースURIを設定するために)、自動的に動作するようになっているはずです。</target>
        </trans-unit>
        <trans-unit id="9a11d4479b92e7b2c9a9fc979b41f6f7eb2a1edf" translate="yes" xml:space="preserve">
          <source>Nowadays, &lt;code&gt;git log&lt;/code&gt; is a builtin, which means that it is &lt;code&gt;contained&lt;/code&gt; in the command &lt;code&gt;git&lt;/code&gt;. The source side of a builtin is</source>
          <target state="translated">現在、 &lt;code&gt;git log&lt;/code&gt; は組み込みで、コマンド &lt;code&gt;git&lt;/code&gt; に &lt;code&gt;contained&lt;/code&gt; れています。組み込みのソース側は</target>
        </trans-unit>
        <trans-unit id="33e31083ab9551e7141ee8a3ee7a0a4d045c20a2" translate="yes" xml:space="preserve">
          <source>Number of bytes of a pack file to map into memory in a single mapping operation. Larger window sizes may allow your system to process a smaller number of large pack files more quickly. Smaller window sizes will negatively affect performance due to increased calls to the operating system&amp;rsquo;s memory manager, but may improve performance when accessing a large number of large pack files.</source>
          <target state="translated">単一のマッピング操作でメモリにマップするパックファイルのバイト数。ウィンドウサイズを大きくすると、システムが少数の大きなパックファイルをより速く処理できるようになります。ウィンドウサイズを小さくすると、オペレーティングシステムのメモリマネージャーへの呼び出しが増えるため、パフォーマンスに悪影響を及ぼしますが、多数の大きなパックファイルにアクセスするときのパフォーマンスは向上する可能性があります。</target>
        </trans-unit>
        <trans-unit id="782270330831f0728fbf1b39424dcd7ac04c3bcf" translate="yes" xml:space="preserve">
          <source>Number of grep worker threads to use. If unset (or set to 0), 8 threads are used by default (for now).</source>
          <target state="translated">使用する grep ワーカースレッドの数。未設定 (または 0 に設定)の場合、デフォルトでは (今のところ)8 個のスレッドが使用されます。</target>
        </trans-unit>
        <trans-unit id="07386a7e3f4686f698d276d122f56af1a564e2f6" translate="yes" xml:space="preserve">
          <source>Number of grep worker threads to use. If unset (or set to 0), Git will use as many threads as the number of logical cores available.</source>
          <target state="translated">使用する grep ワーカーのスレッド数。未設定 (あるいは 0 に設定)の場合、Git は利用可能な論理コア数と同じ数のスレッドを使用します。</target>
        </trans-unit>
        <trans-unit id="b3f7cd4c72eff1cd06e6ea960c75592f7883408d" translate="yes" xml:space="preserve">
          <source>Number of grep worker threads to use. See &lt;code&gt;grep.threads&lt;/code&gt; in &lt;a href=&quot;git-grep&quot;&gt;git-grep[1]&lt;/a&gt; for more information.</source>
          <target state="translated">使用するgrepワーカースレッドの数。詳細 &lt;code&gt;grep.threads&lt;/code&gt; は、&lt;a href=&quot;git-grep&quot;&gt;git-grep [1]の&lt;/a&gt;grep.threadsを参照してください。</target>
        </trans-unit>
        <trans-unit id="340883bf973e4a0a0a15928c3b44200ef6d0edac" translate="yes" xml:space="preserve">
          <source>Number of grep worker threads to use. See &lt;code&gt;grep.threads&lt;/code&gt; in &lt;code&gt;CONFIGURATION&lt;/code&gt; for more information.</source>
          <target state="translated">使用するgrepワーカースレッドの数。詳細 &lt;code&gt;grep.threads&lt;/code&gt; は、 &lt;code&gt;CONFIGURATION&lt;/code&gt; のgrep.threadsを参照してください。</target>
        </trans-unit>
        <trans-unit id="4a06461d5cac364fcad71d6e428b30d7321d874b" translate="yes" xml:space="preserve">
          <source>Number of messages to be sent per connection, after that a relogin will happen. If the value is 0 or undefined, send all messages in one connection. See also the &lt;code&gt;--batch-size&lt;/code&gt; option of &lt;a href=&quot;git-send-email&quot;&gt;git-send-email[1]&lt;/a&gt;.</source>
          <target state="translated">接続ごとに送信されるメッセージの数。その後、再ログインが行われます。値が0または未定義の場合、すべてのメッセージを1つの接続で送信します。&lt;a href=&quot;git-send-email&quot;&gt;git-send-email [1]&lt;/a&gt;の &lt;code&gt;--batch-size&lt;/code&gt; オプションも参照してください。</target>
        </trans-unit>
        <trans-unit id="263d5a12c4d7938e6b1945ed2d424a531e8ffd37" translate="yes" xml:space="preserve">
          <source>Number of parallel children to be used for all forms of fetching.</source>
          <target state="translated">すべての形式のフェッチに使用される並列子の数。</target>
        </trans-unit>
        <trans-unit id="5f124a70076360d6cdb202a3452dac6608d9c87a" translate="yes" xml:space="preserve">
          <source>Number of seconds to cache credentials (default: 900).</source>
          <target state="translated">資格情報をキャッシュする秒数 (既定値:900)。</target>
        </trans-unit>
        <trans-unit id="0600a433ee142590b5ed0795ec15517899403cc1" translate="yes" xml:space="preserve">
          <source>OBJ_BLOB (3)</source>
          <target state="translated">OBJ_BLOB (3)</target>
        </trans-unit>
        <trans-unit id="20a9deedd57091e656a9ceb8afe723fea4c8ae28" translate="yes" xml:space="preserve">
          <source>OBJ_COMMIT (1)</source>
          <target state="translated">OBJ_COMMIT (1)</target>
        </trans-unit>
        <trans-unit id="33b36795cfe9033fd325f2c4f57ccf4bbcdb1c8c" translate="yes" xml:space="preserve">
          <source>OBJ_OFS_DELTA (6)</source>
          <target state="translated">OBJ_OFS_DELTA (6)</target>
        </trans-unit>
        <trans-unit id="ad63d6a2f7a5f774df4b60dc52ffc40dc66ab330" translate="yes" xml:space="preserve">
          <source>OBJ_REF_DELTA (7)</source>
          <target state="translated">OBJ_REF_DELTA (7)</target>
        </trans-unit>
        <trans-unit id="bf0dce0da3b6ff387e755df6e790a1cac5898dd7" translate="yes" xml:space="preserve">
          <source>OBJ_TAG (4)</source>
          <target state="translated">OBJ_TAG (4)</target>
        </trans-unit>
        <trans-unit id="2f77abc6705f39815a181a261b98c26e748660a6" translate="yes" xml:space="preserve">
          <source>OBJ_TREE (2)</source>
          <target state="translated">OBJ_TREE (2)</target>
        </trans-unit>
        <trans-unit id="bcb75e6bd3e418ec921606a22f47e84ce889c09d" translate="yes" xml:space="preserve">
          <source>OK, still with me? To give us an example to look at, let&amp;rsquo;s go back to the earlier repository with &quot;hello&quot; and &quot;example&quot; file, and bring ourselves back to the pre-merge state:</source>
          <target state="translated">はい、まだ私と一緒ですか？例を示すために、「hello」と「example」ファイルを使用して以前のリポジトリに戻り、マージ前の状態に戻します。</target>
        </trans-unit>
        <trans-unit id="6477da6d91ea639e6e30c40f69d7500177d55603" translate="yes" xml:space="preserve">
          <source>OK, this all sounds like a collection of totally nonsensical rules, but it&amp;rsquo;s actually exactly what you want in order to do a fast merge. The different stages represent the &quot;result tree&quot; (stage 0, aka &quot;merged&quot;), the original tree (stage 1, aka &quot;orig&quot;), and the two trees you are trying to merge (stage 2 and 3 respectively).</source>
          <target state="translated">OK、これはまったく無意味なルールの集まりのように聞こえますが、実際には、高速なマージを行うためにまさに必要なものです。異なるステージは、「結果ツリー」（ステージ0、別名「マージ済み」）、元のツリー（ステージ1、別名「orig」）、およびマージしようとしている2つのツリー（それぞれステージ2および3）を表します。</target>
        </trans-unit>
        <trans-unit id="30c34ea4528b5e99d721b2ada273c08402f70a1d" translate="yes" xml:space="preserve">
          <source>Object Traversal</source>
          <target state="translated">オブジェクトトラバーサル</target>
        </trans-unit>
        <trans-unit id="e07348665c9e3f452362a58c36e1f55665279269" translate="yes" xml:space="preserve">
          <source>Object access and manipulation</source>
          <target state="translated">オブジェクトへのアクセスと操作</target>
        </trans-unit>
        <trans-unit id="d963c54afefdbe29bbc1f0380d42869afd8a753b" translate="yes" xml:space="preserve">
          <source>Object size identified by &amp;lt;object&amp;gt; is given in bytes, and right-justified with minimum width of 7 characters. Object size is given only for blobs (file) entries; for other entries &lt;code&gt;-&lt;/code&gt; character is used in place of size.</source>
          <target state="translated">&amp;lt;object&amp;gt;で識別されるオブジェクトのサイズはバイト単位で指定され、最小幅7文字で右揃えされます。オブジェクトサイズはblob（ファイル）エントリに対してのみ指定されます。他のエントリの場合 &lt;code&gt;-&lt;/code&gt; サイズの代わりに文字が使用されます。</target>
        </trans-unit>
        <trans-unit id="5a755e02f9fddc8d9863cff303858fc5c0963f4b" translate="yes" xml:space="preserve">
          <source>Object storage format</source>
          <target state="translated">オブジェクト格納形式</target>
        </trans-unit>
        <trans-unit id="4410a56144704dcadb0adeabc1f66b086332a778" translate="yes" xml:space="preserve">
          <source>Object store associated with this repository. Usually an object store is self sufficient (i.e. all the objects that are referred to by an object found in it are also found in it), but there are a few ways to violate it.</source>
          <target state="translated">このリポジトリに関連付けられたオブジェクトストア。通常、オブジェクトストアは自己完結型 (つまり、そこにあるオブジェクトが参照しているすべてのオブジェクトがそこにもある)ですが、これに違反する方法がいくつかあります。</target>
        </trans-unit>
        <trans-unit id="66c888d10ab6a46198fcec7325df97ad7688050e" translate="yes" xml:space="preserve">
          <source>Object types</source>
          <target state="translated">オブジェクトの種類</target>
        </trans-unit>
        <trans-unit id="397880af9235fafbc028a684c78f613458679a72" translate="yes" xml:space="preserve">
          <source>Objects that already exist in the repository will &lt;strong&gt;not&lt;/strong&gt; be unpacked from the packfile. Therefore, nothing will be unpacked if you use this command on a packfile that exists within the target repository.</source>
          <target state="translated">リポジトリにすでに存在するオブジェクトは、packfileからアンパックされ&lt;strong&gt;ません&lt;/strong&gt;。したがって、ターゲットリポジトリ内に存在するpackfileに対してこのコマンドを使用しても、何も解凍されません。</target>
        </trans-unit>
        <trans-unit id="f90e1faea66f4ee07afc15b9cfbe6b37aebe1076" translate="yes" xml:space="preserve">
          <source>Objects unreachable from the refs in packs named with --unpacked= option are added to the resulting pack, in addition to the reachable objects that are not in packs marked with *.keep files. This implies &lt;code&gt;--revs&lt;/code&gt;.</source>
          <target state="translated">--unpacked =オプションで名前が付けられたパックの参照から到達できないオブジェクトは、*。keepファイルでマークされたパックにない到達可能なオブジェクトに加えて、結果のパックに追加されます。これは &lt;code&gt;--revs&lt;/code&gt; を意味します。</target>
        </trans-unit>
        <trans-unit id="c4b47085e458e48bb4b0605ca6d2f6a3cc7755c2" translate="yes" xml:space="preserve">
          <source>Obsolete for: &lt;a href=&quot;#def_index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">廃止：&lt;a href=&quot;#def_index&quot;&gt;インデックス&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d42a49317326d6b79f20beebf76935d065ccac7f" translate="yes" xml:space="preserve">
          <source>Obviously, endless variations are possible; for example, to see all commits reachable from some head but not from any tag in the repository:</source>
          <target state="translated">もちろん、無限のバリエーションが可能です。例えば、リポジトリ内のどのタグからではなく、どこかのヘッドから到達可能なコミットをすべて見ることができます。</target>
        </trans-unit>
        <trans-unit id="80e98962116f1f595b28a3f430e4b1f9c4dbde82" translate="yes" xml:space="preserve">
          <source>Occasionally, the maintainer may get merge conflicts when they try to pull changes from downstream. In this case, they can ask downstream to do the merge and resolve the conflicts themselves (perhaps they will know better how to resolve them). It is one of the rare cases where downstream &lt;code&gt;should&lt;/code&gt; merge from upstream.</source>
          <target state="translated">メンテナがダウンストリームから変更をプルしようとすると、マージの競合が発生する場合があります。この場合、ダウンストリームにマージを実行して競合を解決するよう依頼することができます（おそらく、競合を解決する方法をよりよく理解しているでしょう）。これは、下流のはまれなケースの一つである &lt;code&gt;should&lt;/code&gt; 、上流から合流します。</target>
        </trans-unit>
        <trans-unit id="7c4df738049a7589e8637595f08e890f6ad9d98e" translate="yes" xml:space="preserve">
          <source>Of course some kind of software is developed, then used during some time without being improved on much, and then finally thrown away. In this case, of course, regressions may not be a big problem. But on the other hand, there is a lot of big software that is continually developed and maintained during years or even tens of years by a lot of people. And as there are often many people who depend (sometimes critically) on such software, regressions are a really big problem.</source>
          <target state="translated">もちろん、ある種のソフトウェアは開発され、その後、あまり改良されることなくしばらくの間使用され、最後には捨てられてしまいます。この場合、もちろん、リグレッションは大きな問題ではないかもしれません。しかし、一方で、多くの人が何年も何十年もの間、継続的に開発し、メンテナンスされている大きなソフトウェアがたくさんあります。そして、そのようなソフトウェアに(時には批判的に)依存している多くの人々がいることが多いので、リグレッションは本当に大きな問題です。</target>
        </trans-unit>
        <trans-unit id="19fce424b8331b64c65b8a6acafb03304b015bfc" translate="yes" xml:space="preserve">
          <source>Of course the &quot;bad&quot; commit cannot be an ancestor of a &quot;good&quot; commit, because the ancestors of the good commits are supposed to be &quot;good&quot;. And all the &quot;good&quot; commits must be related to the bad commit. They cannot be on a branch that has no link with the branch of the &quot;bad&quot; commit. But it is possible for a good commit to be related to a bad commit and yet not be neither one of its ancestor nor one of its descendants.</source>
          <target state="translated">もちろん、&quot;悪い &quot;コミットは &quot;良い &quot;コミットの祖先にはなりえません。また、すべての &quot;良い&quot; コミットは悪いコミットに関連していなければなりません。これらのコミットは、「悪い」コミットのブランチとは関係のないブランチには存在してはいけません。しかし、良いコミットが悪いコミットに関連していても、その先祖の一つでも子孫の一つでもないということはあり得ます。</target>
        </trans-unit>
        <trans-unit id="7c78c10d5c75907a546f96553e9802bb23f4c982" translate="yes" xml:space="preserve">
          <source>Of course, there may be more than one answer&amp;mdash;​if the history branched after commit e05db0fd, then there could be multiple &quot;earliest&quot; tagged releases.</source>
          <target state="translated">もちろん、複数の回答が存在する可能性があります。e05db0fdのコミット後に履歴が分岐した場合、「最も古い」タグ付きリリースが複数存在する可能性があります。</target>
        </trans-unit>
        <trans-unit id="bc73231ef0df798acd7604c5e90f5ea460992bab" translate="yes" xml:space="preserve">
          <source>Often people use &lt;code&gt;git pull&lt;/code&gt; without giving any parameter. Traditionally, this has been equivalent to saying &lt;code&gt;git pull
origin&lt;/code&gt;. However, when configuration &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; is present while on branch &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt;, that value is used instead of &lt;code&gt;origin&lt;/code&gt;.</source>
          <target state="translated">多くの場合、パラメータを指定せずに &lt;code&gt;git pull&lt;/code&gt; を使用します。伝統的に、これは &lt;code&gt;git pull origin&lt;/code&gt; と言うことと同等でした。しかし、コンフィギュレーション・ &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; 枝に存在しばらくある &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; 、その値が代わりに使用される &lt;code&gt;origin&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="813c6a487fc92be3bf23c6677bbfade25d37be89" translate="yes" xml:space="preserve">
          <source>Often the current branch head is an ancestor of the named commit. This is the most common case especially when invoked from &lt;code&gt;git pull&lt;/code&gt;: you are tracking an upstream repository, you have committed no local changes, and now you want to update to a newer upstream revision. In this case, a new commit is not needed to store the combined history; instead, the &lt;code&gt;HEAD&lt;/code&gt; (along with the index) is updated to point at the named commit, without creating an extra merge commit.</source>
          <target state="translated">多くの場合、現在のブランチヘッドは名前付きコミットの祖先です。これは、特に &lt;code&gt;git pull&lt;/code&gt; から呼び出された場合に最も一般的なケースです。上流のリポジトリを追跡していて、ローカルの変更をコミットしておらず、新しい上流のリビジョンに更新したい場合。この場合、結合された履歴を保存するために新しいコミットは必要ありません。代わりに、 &lt;code&gt;HEAD&lt;/code&gt; （およびインデックス）は、追加のマージコミットを作成することなく、指定されたコミットを指すように更新されます。</target>
        </trans-unit>
        <trans-unit id="bc22c639538c04ca7d5608268e4dc9b34f324581" translate="yes" xml:space="preserve">
          <source>Often the overview of the change is useful to get a feel of each step</source>
          <target state="translated">多くの場合、変更の概要は、各ステップの感触を得るのに便利です。</target>
        </trans-unit>
        <trans-unit id="a0ef5be0d5f74372c2549cc7906cdb110a910654" translate="yes" xml:space="preserve">
          <source>Often, &quot;please pull&quot; messages on the mailing list just provide two pieces of information: a repo URL and a branch name; this is designed to be easily cut&amp;amp;pasted at the end of a &lt;code&gt;git fetch&lt;/code&gt; command line:</source>
          <target state="translated">多くの場合、メーリングリストの「プルしてください」メッセージは、2つの情報を提供するだけです。リポジトリのURLとブランチ名です。これは、 &lt;code&gt;git fetch&lt;/code&gt; コマンドラインの最後で簡単にカットアンドペーストできるように設計されています。</target>
        </trans-unit>
        <trans-unit id="b90f5f996d698883902ffd1dba32d6eea369ef9a" translate="yes" xml:space="preserve">
          <source>Older documentation written before the packed-refs mechanism was introduced may still say things like &quot;.git/refs/heads/&amp;lt;branch&amp;gt; file exists&quot; when it means &quot;branch &amp;lt;branch&amp;gt; exists&quot;.</source>
          <target state="translated">pack-refsメカニズムが導入される前に作成された古いドキュメントでは、「ブランチ&amp;lt;branch&amp;gt;が存在する」という意味で、「。git / refs / heads / &amp;lt;branch&amp;gt;ファイルが存在する」のように記載されている場合があります。</target>
        </trans-unit>
        <trans-unit id="a148aab8f38b980de65dd5f412fc336ae5d855f6" translate="yes" xml:space="preserve">
          <source>Older scripts may depend on the historical behaviour of not allowing the user to edit the merge log message. They will see an editor opened when they run &lt;code&gt;git merge&lt;/code&gt;. To make it easier to adjust such scripts to the updated behaviour, the environment variable &lt;code&gt;GIT_MERGE_AUTOEDIT&lt;/code&gt; can be set to &lt;code&gt;no&lt;/code&gt; at the beginning of them.</source>
          <target state="translated">古いスクリプトは、ユーザーがマージログメッセージを編集できないという過去の動作に依存している場合があります。 &lt;code&gt;git merge&lt;/code&gt; を実行すると、エディターが開きます。このようなスクリプトを更新された動作に合わせて調整しやすくするために、環境変数 &lt;code&gt;GIT_MERGE_AUTOEDIT&lt;/code&gt; を最初に &lt;code&gt;no&lt;/code&gt; に設定できます。</target>
        </trans-unit>
        <trans-unit id="3a027c8ab6aede7960dbe3d141d016ee3e6589ef" translate="yes" xml:space="preserve">
          <source>Older versions of &lt;code&gt;meld&lt;/code&gt; do not support the &lt;code&gt;--output&lt;/code&gt; option. Git will attempt to detect whether &lt;code&gt;meld&lt;/code&gt; supports &lt;code&gt;--output&lt;/code&gt; by inspecting the output of &lt;code&gt;meld --help&lt;/code&gt;. Configuring &lt;code&gt;mergetool.meld.hasOutput&lt;/code&gt; will make Git skip these checks and use the configured value instead. Setting &lt;code&gt;mergetool.meld.hasOutput&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; tells Git to unconditionally use the &lt;code&gt;--output&lt;/code&gt; option, and &lt;code&gt;false&lt;/code&gt; avoids using &lt;code&gt;--output&lt;/code&gt;.</source>
          <target state="translated">古いバージョンの &lt;code&gt;meld&lt;/code&gt; は &lt;code&gt;--output&lt;/code&gt; オプションをサポートしていません。 Gitはかどうかを検出しようと &lt;code&gt;meld&lt;/code&gt; サポート &lt;code&gt;--output&lt;/code&gt; の出力検査することによって、 &lt;code&gt;meld --help&lt;/code&gt; 。 &lt;code&gt;mergetool.meld.hasOutput&lt;/code&gt; を構成すると、Gitはこれらのチェックをスキップし、代わりに構成された値を使用します。 &lt;code&gt;mergetool.meld.hasOutput&lt;/code&gt; を &lt;code&gt;true&lt;/code&gt; に設定すると、Gitに &lt;code&gt;--output&lt;/code&gt; オプションを無条件で使用するように指示し、 &lt;code&gt;false&lt;/code&gt; を指定すると &lt;code&gt;--output&lt;/code&gt; の使用を回避します。</target>
        </trans-unit>
        <trans-unit id="8511fe9d48b84ff3883d162d35ccd3dcba224454" translate="yes" xml:space="preserve">
          <source>Older versions of Git (before 2.20) documented that the object names list should be sorted. This was never a requirement, the object names could appear in any order, but when reading the list we tracked whether the list was sorted for the purposes of an internal binary search implementation, which could save itself some work with an already sorted list. Unless you had a humongous list there was no reason to go out of your way to pre-sort the list. After Git version 2.20 a hash implementation is used instead, so there&amp;rsquo;s now no reason to pre-sort the list.</source>
          <target state="translated">古いバージョンのGit（2.20より前）では、オブジェクト名リストをソートする必要があると記載されていました。これは必須ではなく、オブジェクト名は任意の順序で表示できますが、リストを読み取るときに、リストが内部バイナリ検索実装のためにソートされているかどうかを追跡しました。あなたが膨大なリストを持っていない限り、リストを事前に分類するためにあなたの道を行く理由はありませんでした。Gitバージョン2.20以降では、代わりにハッシュ実装が使用されるため、リストを事前にソートする理由はありません。</target>
        </trans-unit>
        <trans-unit id="c51aaa3680fede028efcceee261b4919c277f552" translate="yes" xml:space="preserve">
          <source>Omit any commit that introduces the same change as another commit on the &amp;ldquo;other side&amp;rdquo; when the set of commits are limited with symmetric difference.</source>
          <target state="translated">一連のコミットが対称的な違いで制限されている場合は、「反対側」で別のコミットと同じ変更を導入するコミットを省略します。</target>
        </trans-unit>
        <trans-unit id="e35d3ce0c9ea9ff6d661fcb1cbc8e08ffef97df6" translate="yes" xml:space="preserve">
          <source>Omit diff output for unmerged entries and just show &quot;Unmerged&quot;. Can be used only when comparing the working tree with the index.</source>
          <target state="translated">マージされていないエントリの差分出力を省略し、&quot;Unmerged &quot;のみを表示します。作業ツリーとインデックスを比較する場合にのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="3138b0b10501de06a44e08d0de4b10a83646644b" translate="yes" xml:space="preserve">
          <source>Omit objects that are known to be in the promisor remote. (This option has the purpose of operating only on locally created objects, so that when we repack, we still maintain a distinction between locally created objects [without .promisor] and objects from the promisor remote [with .promisor].) This is used with partial clone.</source>
          <target state="translated">プロマイザリモートにあることがわかっているオブジェクトを省略します (このオプションは、ローカルに作成されたオブジェクトに対してのみ動作するという目的があるので、リパックするときには、ローカルに作成されたオブジェクト [not .promisor]とプロマイザリモートにあるオブジェクト [with .promisor]の区別を維持します)。(このオプションは、ローカルに作成されたオブジェクトに対してのみ動作するという目的がありますので、リパックする際には、ローカルに作成されたオブジェクト[.promisorなし]とプロミザリモートにあるオブジェクト[.promisorあり]の区別を維持します)。これはパーシャルクローンと一緒に使用されます。</target>
        </trans-unit>
        <trans-unit id="fcfe3e3e988e33991f3ebb33b70ee9c58a79e5d0" translate="yes" xml:space="preserve">
          <source>Omit the preimage for deletes, i.e. print only the header but not the diff between the preimage and &lt;code&gt;/dev/null&lt;/code&gt;. The resulting patch is not meant to be applied with &lt;code&gt;patch&lt;/code&gt; or &lt;code&gt;git apply&lt;/code&gt;; this is solely for people who want to just concentrate on reviewing the text after the change. In addition, the output obviously lacks enough information to apply such a patch in reverse, even manually, hence the name of the option.</source>
          <target state="translated">削除の場合、プリイメージを省略し &lt;code&gt;/dev/null&lt;/code&gt; 。つまり、プリイメージと/ dev / nullの間の差分ではなく、ヘッダーのみを出力します。結果のパッチは、 &lt;code&gt;patch&lt;/code&gt; や &lt;code&gt;git apply&lt;/code&gt; で適用されることを意図していません。これは、変更後のテキストの確認に集中したい人のためのものです。さらに、出力には、そのようなパッチを手動で適用しても逆に適用するのに十分な情報がないため、オプションの名前です。</target>
        </trans-unit>
        <trans-unit id="2c239b325c52048ed0e0df682e63161da794c522" translate="yes" xml:space="preserve">
          <source>Omitting &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; detaches &lt;code&gt;HEAD&lt;/code&gt; at the tip of the current branch.</source>
          <target state="translated">省略 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 切り離し &lt;code&gt;HEAD&lt;/code&gt; を現在のブランチの先端で。</target>
        </trans-unit>
        <trans-unit id="6f08ea1a85b441d7cdb4b9da4840e51d4a63074c" translate="yes" xml:space="preserve">
          <source>Omitting the &lt;code&gt;from&lt;/code&gt; command in the first commit of a new branch will cause fast-import to create that commit with no ancestor. This tends to be desired only for the initial commit of a project. If the frontend creates all files from scratch when making a new branch, a &lt;code&gt;merge&lt;/code&gt; command may be used instead of &lt;code&gt;from&lt;/code&gt; to start the commit with an empty tree. Omitting the &lt;code&gt;from&lt;/code&gt; command on existing branches is usually desired, as the current commit on that branch is automatically assumed to be the first ancestor of the new commit.</source>
          <target state="translated">新しいブランチの最初のコミットで &lt;code&gt;from&lt;/code&gt; コマンドを省略すると、高速インポートで祖先のないコミットが作成されます。これは、プロジェクトの最初のコミットにのみ必要になる傾向があります。フロントエンドは、最初からすべてのファイルを作成する場合、新しいブランチを作成する際に、 &lt;code&gt;merge&lt;/code&gt; コマンドの代わりに使用することができる &lt;code&gt;from&lt;/code&gt; 、空のツリーでコミットを開始します。そのブランチでの現在のコミットは自動的に新しいコミットの最初の祖先であると想定されるため、既存のブランチで &lt;code&gt;from&lt;/code&gt; コマンドを省略することが通常望まれます。</target>
        </trans-unit>
        <trans-unit id="2e6ae0a1101e66bbdd1aff8c2583b81c23208b83" translate="yes" xml:space="preserve">
          <source>On Automatic following</source>
          <target state="translated">自動で次のように</target>
        </trans-unit>
        <trans-unit id="82b4aa90bf6690a7ed8e3558248667b070567fb7" translate="yes" xml:space="preserve">
          <source>On Backdating Tags</source>
          <target state="translated">バックデートのタグについて</target>
        </trans-unit>
        <trans-unit id="52c1ff7f8dbe6e1f6639547a437fb78c51994ab9" translate="yes" xml:space="preserve">
          <source>On Re-tagging</source>
          <target state="translated">再タグ付けについて</target>
        </trans-unit>
        <trans-unit id="a3e5a575b7ca5dced5a48ec2289cb57e77edaa64" translate="yes" xml:space="preserve">
          <source>On an inefficient filesystem with &lt;code&gt;core.ignorestat&lt;/code&gt; set</source>
          <target state="translated">&lt;code&gt;core.ignorestat&lt;/code&gt; が設定されている非効率的なファイルシステム</target>
        </trans-unit>
        <trans-unit id="3fc5d80f58915bdd0c5c8219fc8fa34ba2d1e212" translate="yes" xml:space="preserve">
          <source>On any other error, the exit status may be any other non-zero value.</source>
          <target state="translated">その他のエラーが発生した場合、終了ステータスは0以外の任意の値になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="ccf984a0700972bcd62e51c87e569c1158e56007" translate="yes" xml:space="preserve">
          <source>On large repositories, Git depends on compression to keep the history information from taking up too much space on disk or in memory. Some Git commands may automatically run &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt;, so you don&amp;rsquo;t have to worry about running it manually. However, compressing a large repository may take a while, so you may want to call &lt;code&gt;gc&lt;/code&gt; explicitly to avoid automatic compression kicking in when it is not convenient.</source>
          <target state="translated">大規模なリポジトリーでは、Gitは圧縮に依存して、履歴情報がディスクまたはメモリー内で多くのスペースを占有しないようにします。一部のGitコマンドは&lt;a href=&quot;git-gc&quot;&gt;git-gc [1]を&lt;/a&gt;自動的に実行する場合があるため、手動で実行することを心配する必要はありません。ただし、大きなリポジトリの圧縮には時間がかかる場合があるため、 &lt;code&gt;gc&lt;/code&gt; を明示的に呼び出して、不都合なときに自動圧縮が開始されるのを回避することができます。</target>
        </trans-unit>
        <trans-unit id="d4d8aed3bf55796608219c0adac254008695a3f9" translate="yes" xml:space="preserve">
          <source>On some file system/operating system combinations, this is unreliable. Set this config setting to &lt;code&gt;rename&lt;/code&gt; there; However, This will remove the check that makes sure that existing object files will not get overwritten.</source>
          <target state="translated">一部のファイルシステムとオペレーティングシステムの組み合わせでは、これは信頼できません。ここで &lt;code&gt;rename&lt;/code&gt; を変更するには、この構成設定を設定します。ただし、これにより、既存のオブジェクトファイルが上書きされないようにするチェックが削除されます。</target>
        </trans-unit>
        <trans-unit id="5895edccc183158d9e3740d2cebb6ada4fc33444" translate="yes" xml:space="preserve">
          <source>On submit, re-author changes to reflect the Git author, regardless of who invokes &lt;code&gt;git p4 submit&lt;/code&gt;.</source>
          <target state="translated">送信時に、誰が &lt;code&gt;git p4 submit&lt;/code&gt; を呼び出したかに関係なく、Gitの作成者を反映するように変更を再作成します。</target>
        </trans-unit>
        <trans-unit id="625dc8e72565a5aa6c893e4054fd5a7bd4cd4c77" translate="yes" xml:space="preserve">
          <source>On success, the command returns the exit code 0.</source>
          <target state="translated">成功すると、コマンドは終了コード 0 を返します。</target>
        </trans-unit>
        <trans-unit id="55bf26a2244670497728b53622880350724b3943" translate="yes" xml:space="preserve">
          <source>On success, the exit status is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">成功すると、終了ステータスは &lt;code&gt;0&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="990e4d4ec388fa2b56426ae37da6b01c179599b8" translate="yes" xml:space="preserve">
          <source>On success, the exit status is &lt;code&gt;0&lt;/code&gt;. If the filter can&amp;rsquo;t find any commits to rewrite, the exit status is &lt;code&gt;2&lt;/code&gt;. On any other error, the exit status may be any other non-zero value.</source>
          <target state="translated">成功した場合、終了ステータスは &lt;code&gt;0&lt;/code&gt; です。フィルターが書き換えるコミットを見つけられない場合、終了ステータスは &lt;code&gt;2&lt;/code&gt; です。その他のエラーの場合、終了ステータスはその他のゼロ以外の値になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="9b26f7834b511fe2fcda898a4f6a6ea24bf02deb" translate="yes" xml:space="preserve">
          <source>On the filesystem, a submodule usually (but not always - see FORMS below) consists of (i) a Git directory located under the &lt;code&gt;$GIT_DIR/modules/&lt;/code&gt; directory of its superproject, (ii) a working directory inside the superproject&amp;rsquo;s working directory, and a &lt;code&gt;.git&lt;/code&gt; file at the root of the submodule&amp;rsquo;s working directory pointing to (i).</source>
          <target state="translated">ファイルシステムでは、サブモジュールは通常（常にではありませんが、以下のFORMSを参照）、（i）スーパー &lt;code&gt;$GIT_DIR/modules/&lt;/code&gt; の$ GIT_DIR / modules /ディレクトリの下にあるGitディレクトリ、（ii）スーパープロジェクトの作業ディレクトリ内の作業ディレクトリ、および &lt;code&gt;.git&lt;/code&gt; （I）を指しているサブモジュールの作業ディレクトリのルートにあるファイル。</target>
        </trans-unit>
        <trans-unit id="4db9025909f7f5bf5e13acbeaf805aa54cd01729" translate="yes" xml:space="preserve">
          <source>On the other hand if you do this often, then it can be worth having scripts to avoid too much typing.</source>
          <target state="translated">一方で、これを頻繁に行うのであれば、タイプしすぎないようにスクリプトを持つ価値があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="683649c177c2041eda8a2d9bcca87e40a04a531c" translate="yes" xml:space="preserve">
          <source>On the other hand, if instead of merging at C you had rebased the history between Z to B on top of A, you would have gotten this linear history:</source>
          <target state="translated">一方、Cでマージするのではなく、Aの上にZからBまでの履歴をリベースしていたら、このような直線的な履歴が得られたことになります。</target>
        </trans-unit>
        <trans-unit id="0322f18dd0193743bffa03c418d12c6fe0b24261" translate="yes" xml:space="preserve">
          <source>On the other hand, if you are fetching because you would want a one-shot merge from somebody else, you typically do not want to get tags from there. This happens more often for people near the toplevel but not limited to them. Mere mortals when pulling from each other do not necessarily want to automatically get private anchor point tags from the other person.</source>
          <target state="translated">一方、他の誰かから一発でマージしたいからフェッチしているのであれば、一般的にはそこからタグを取得したくありません。これはトップレベルの近くにいる人の方が頻繁に起こるが、これに限定されるものではない。互いにプルしているときに、他の人からプライベートなアンカーポイントのタグを自動的に取得したいとは限りません。</target>
        </trans-unit>
        <trans-unit id="ff26b6c1b15a595913b474bb862db9261a722064" translate="yes" xml:space="preserve">
          <source>On the other hand, when &lt;code&gt;git gc&lt;/code&gt; runs concurrently with another process, there is a risk of it deleting an object that the other process is using but hasn&amp;rsquo;t created a reference to. This may just cause the other process to fail or may corrupt the repository if the other process later adds a reference to the deleted object. Git has two features that significantly mitigate this problem:</source>
          <target state="translated">一方、 &lt;code&gt;git gc&lt;/code&gt; が別のプロセスと同時に実行されると、他のプロセスが使用しているが参照を作成していないオブジェクトが削除されるリスクがあります。これは、他のプロセスが失敗したり、他のプロセスが削除されたオブジェクトへの参照を後で追加した場合にリポジトリを破壊したりする可能性があります。Gitには、この問題を大幅に軽減する2つの機能があります。</target>
        </trans-unit>
        <trans-unit id="9cc6a0108c9ca30d35fc16f0e158699698e2687d" translate="yes" xml:space="preserve">
          <source>On the plus side, distributed revision control systems can much better integrate with external sources. In a centralized model, a single arbitrary snapshot of the external project is exported from its own revision control and then imported into the local revision control on a vendor branch. All the history is hidden. With distributed revision control you can clone the entire external history and much more easily follow development and re-merge local changes.</source>
          <target state="translated">プラス面では、分散型リビジョン管理システムは、外部ソースとの統合性が格段に向上します。集中型モデルでは、外部プロジェクトの単一の任意のスナップショットが、それ自身のリビジョンコントロールからエクスポートされ、ベンダーブランチのローカルリビジョンコントロールにインポートされます。履歴はすべて非表示になります。分散リビジョンコントロールを使用すると、外部の履歴全体をクローンして、開発のフォローやローカルの変更の再マージをより簡単に行うことができます。</target>
        </trans-unit>
        <trans-unit id="90597c320571938c2a30a9ec587f181632e3da9c" translate="yes" xml:space="preserve">
          <source>On the receiving side, failing fsckObjects will make those objects unreachable, see &quot;QUARANTINE ENVIRONMENT&quot; in &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack[1]&lt;/a&gt;. On the fetch side, malformed objects will instead be left unreferenced in the repository.</source>
          <target state="translated">受信側では、fsckObjectsに失敗すると、これらのオブジェクトに到達できなくなります。git &lt;a href=&quot;git-receive-pack&quot;&gt;-receive-pack [1]の&lt;/a&gt;「QUARANTINE ENVIRONMENT」を参照してください。フェッチ側では、不正なオブジェクトはリポジトリで参照されないままになります。</target>
        </trans-unit>
        <trans-unit id="0cb32cbc06583a961d1463cba3f54ceac091ac9b" translate="yes" xml:space="preserve">
          <source>Once a patch completes the great cycle (moving from test to release, then pulled by Linus, and finally coming back into your local &lt;code&gt;origin/master&lt;/code&gt; branch), the branch for this change is no longer needed. You detect this when the output from:</source>
          <target state="translated">パッチが素晴らしいサイクル（テストからリリースに移り、Linusによってプルされ、最後にローカルの &lt;code&gt;origin/master&lt;/code&gt; ブランチに戻る）を完了すると、この変更のためのブランチは不要になります。これは、次の出力から検出されます。</target>
        </trans-unit>
        <trans-unit id="b9ebb68ceda33b5f55394a76815abe93f554d5a0" translate="yes" xml:space="preserve">
          <source>Once again, check to verify that you&amp;rsquo;ve included what you want to. You may also wish to verify that git diff doesn&amp;rsquo;t show any remaining changes to be committed later.</source>
          <target state="translated">もう一度、必要なものが含まれていることを確認してください。git diffに、後でコミットする残りの変更が表示されていないことを確認することもできます。</target>
        </trans-unit>
        <trans-unit id="90e05562a65001025b0b72d96c6a4e4b947387b5" translate="yes" xml:space="preserve">
          <source>Once housekeeping is triggered by exceeding the limits of configuration options such as &lt;code&gt;gc.auto&lt;/code&gt; and &lt;code&gt;gc.autoPackLimit&lt;/code&gt;, all other housekeeping tasks (e.g. rerere, working trees, reflog&amp;hellip;​) will be performed as well.</source>
          <target state="translated">&lt;code&gt;gc.auto&lt;/code&gt; や &lt;code&gt;gc.autoPackLimit&lt;/code&gt; などの構成オプションの制限を超えてハウスキーピングがトリガーされると、他のすべてのハウスキーピングタスク（たとえば、rerere、working trees、reflog&amp;hellip;）も実行されます。</target>
        </trans-unit>
        <trans-unit id="e4fac50f608beca9583acae6e66b5b839bc7af82" translate="yes" xml:space="preserve">
          <source>Once satisfied with the hunks you want to include, you should verify what has been prepared for the first commit by using &lt;code&gt;git diff --cached&lt;/code&gt;. This shows all the changes that have been moved into the index and are about to be committed.</source>
          <target state="translated">含めるハンクに満足したら、 &lt;code&gt;git diff --cached&lt;/code&gt; を使用して、最初のコミットのために何が準備されているかを確認する必要があります。これは、インデックスに移動され、コミットされるすべての変更を示します。</target>
        </trans-unit>
        <trans-unit id="3dd9fb6970c316fd22de16c64bf93a0699f63f8d" translate="yes" xml:space="preserve">
          <source>Once the commits are ready to be sent, run the following command:</source>
          <target state="translated">コミットを送信する準備ができたら、以下のコマンドを実行します。</target>
        </trans-unit>
        <trans-unit id="40868be271f12676d4171e28016f98d26c82d485" translate="yes" xml:space="preserve">
          <source>Once the index has been created, the hash that goes into the name of the pack/idx file is printed to stdout. If --stdin was also used then this is prefixed by either &quot;pack\t&quot;, or &quot;keep\t&quot; if a new .keep file was successfully created. This is useful to remove a .keep file used as a lock to prevent the race with &lt;code&gt;git repack&lt;/code&gt; mentioned above.</source>
          <target state="translated">インデックスが作成されると、pack / idxファイルの名前に含まれるハッシュがstdoutに出力されます。--stdinも使用された場合、これには「pack \ t」、または新しい.keepファイルが正常に作成された場合は「keep \ t」のプレフィックスが付きます。これは、との競争を防ぐためにロックとして使用.keepファイル削除すると便利です &lt;code&gt;git repack&lt;/code&gt; 、上記に。</target>
        </trans-unit>
        <trans-unit id="bc0e79bf062114aed97a847d2dbf78bde74bcedc" translate="yes" xml:space="preserve">
          <source>Once the index has been created, the list of object names is sorted and the SHA-1 hash of that list is printed to stdout. If --stdin was also used then this is prefixed by either &quot;pack\t&quot;, or &quot;keep\t&quot; if a new .keep file was successfully created. This is useful to remove a .keep file used as a lock to prevent the race with &lt;code&gt;git repack&lt;/code&gt; mentioned above.</source>
          <target state="translated">インデックスが作成されると、オブジェクト名のリストがソートされ、そのリストのSHA-1ハッシュがstdoutに出力されます。--stdinも使用された場合、新しい.keepファイルが正常に作成された場合は、「pack \ t」または「keep \ t」のいずれかが前に付きます。これは、ロックとして使用されている.keepファイルを削除して、上記の &lt;code&gt;git repack&lt;/code&gt; repackとの競合を防ぐのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="267c8839170c35911e5505454167dce43ef8461e" translate="yes" xml:space="preserve">
          <source>Once the index is updated with the results of the conflict resolution, instead of creating a new commit, just run</source>
          <target state="translated">インデックスがコンフリクト解決の結果で更新されたら、新しいコミットを作成する代わりに</target>
        </trans-unit>
        <trans-unit id="dce83a819a58902526be63ab88beb478ade1a830" translate="yes" xml:space="preserve">
          <source>Once tracking a Subversion repository (with any of the above methods), the Git repository can be updated from Subversion by the &lt;code&gt;fetch&lt;/code&gt; command and Subversion updated from Git by the &lt;code&gt;dcommit&lt;/code&gt; command.</source>
          <target state="translated">（上記の方法のいずれかを使用して）Subversionリポジトリーを追跡すると、Gitリポジトリーは、 &lt;code&gt;fetch&lt;/code&gt; コマンドによってSubversionから更新され、 &lt;code&gt;dcommit&lt;/code&gt; コマンドによってGitから更新されます。</target>
        </trans-unit>
        <trans-unit id="f7c323cf6aca82334469eb4ac31bb75f493bfcb2" translate="yes" xml:space="preserve">
          <source>Once you fetch from the remote repository, you &lt;code&gt;merge&lt;/code&gt; that with your current branch.</source>
          <target state="translated">リモートリポジトリからフェッチしたら、それを現在のブランチと &lt;code&gt;merge&lt;/code&gt; します。</target>
        </trans-unit>
        <trans-unit id="196d7a30344d61fce15a29277d1febbefab63366" translate="yes" xml:space="preserve">
          <source>Once you have packed objects, you do not need to leave the unpacked objects that are contained in the pack file anymore.</source>
          <target state="translated">一度オブジェクトをパックしてしまえば、パックファイルに含まれているパックされていないオブジェクトを残す必要はもうありません。</target>
        </trans-unit>
        <trans-unit id="19419c3fb2ffef21b9b034f5ca5d579751e9cffb" translate="yes" xml:space="preserve">
          <source>Once you have specified at least one bad and one good commit, &lt;code&gt;git
bisect&lt;/code&gt; selects a commit in the middle of that range of history, checks it out, and outputs something similar to the following:</source>
          <target state="translated">少なくとも1つの不良コミットと1つの良好なコミットを指定すると、 &lt;code&gt;git bisect&lt;/code&gt; はその履歴の範囲の真ん中にあるコミットを選択し、それをチェックアウトして、次のようなものを出力します。</target>
        </trans-unit>
        <trans-unit id="a222e7e00ea22df97bc019f6fbda7d4a739d08f0" translate="yes" xml:space="preserve">
          <source>Once you know the three trees you are going to merge (the one &quot;original&quot; tree, aka the common tree, and the two &quot;result&quot; trees, aka the branches you want to merge), you do a &quot;merge&quot; read into the index. This will complain if it has to throw away your old index contents, so you should make sure that you&amp;rsquo;ve committed those&amp;mdash;​in fact you would normally always do a merge against your last commit (which should thus match what you have in your current index anyway).</source>
          <target state="translated">マージする3つのツリー（1つは「元の」ツリー、別名は共通ツリー、2つは「結果」ツリー、別名はマージするブランチ）がわかったら、「マージ」を読み取り、インデックス。古いインデックスの内容を破棄する必要がある場合、これは文句を言うので、それらをコミットしたことを確認する必要があります。実際、通常は常に最後のコミットに対してマージを実行します（したがって、とにかく現在のインデックス）。</target>
        </trans-unit>
        <trans-unit id="2f6bdbc854c9f4a06850e81f40a40893a853f873" translate="yes" xml:space="preserve">
          <source>Once your commits are ready to be sent to the mailing list, run the following commands:</source>
          <target state="translated">コミットをメーリングリストに送る準備ができたら、以下のコマンドを実行してください。</target>
        </trans-unit>
        <trans-unit id="1e3411b288c5ece442ec5affcc9ccff7867288ff" translate="yes" xml:space="preserve">
          <source>One can also modify context lines by staging them for removal (by converting &quot; &quot; to &quot;-&quot;) and adding a &quot;+&quot; line with the new content. Similarly, one can modify &quot;+&quot; lines for existing additions or modifications. In all cases, the new modification will appear reverted in the working tree.</source>
          <target state="translated">また、削除のためにそれらをステージングし(&quot; &quot; を &quot;-&quot; に変換することで)、新しい内容の &quot;+&quot; 行を追加することで、コンテキスト行を修正することもできます。同様に、既存の追加や変更に対して &quot;+&quot;行を修正することもできます。いずれの場合も、新しい変更は作業ツリーに戻されて表示されます。</target>
        </trans-unit>
        <trans-unit id="cefda8701820e17ff3e5c1f9d74674c9ba3ca4b0" translate="yes" xml:space="preserve">
          <source>One feature worth pointing out is the three-way merge, which can help if you get conflicts: &lt;code&gt;git am -3&lt;/code&gt; will use index information contained in patches to figure out the merge base. See &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt; for other options.</source>
          <target state="translated">指摘する価値のある機能の1つは、3者間マージです。これは、競合が発生した場合に役立ちます &lt;code&gt;git am -3&lt;/code&gt; は、パッチに含まれるインデックス情報を使用してマージベースを特定します。他のオプションについては&lt;a href=&quot;git-am&quot;&gt;git-am [1]&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="91b115a828fd51fba09fc11d7213ae15c1c47544" translate="yes" xml:space="preserve">
          <source>One important aspect of Git is its distributed nature, which largely means there is no inherent &quot;upstream&quot; or &quot;downstream&quot; in the system. On the face of it, the above example might seem to indicate that the tag namespace is owned by the upper echelon of people and that tags only flow downwards, but that is not the case. It only shows that the usage pattern determines who are interested in whose tags.</source>
          <target state="translated">Git の重要な点のひとつは分散型であるということです。これは、システムには本質的な「上流」や「下流」が存在しないことを意味します。一見すると、上の例は、タグの名前空間は上層部の人々によって所有されており、タグは下にしか流れないことを示しているように見えるかもしれませんが、そうではありません。使用パターンによって誰が誰のタグに興味を持つかが決まることを示しているに過ぎません。</target>
        </trans-unit>
        <trans-unit id="04ced8b13491984476dfed877ea62bd96c9df7a6" translate="yes" xml:space="preserve">
          <source>One major difference between &lt;code&gt;git submodule update&lt;/code&gt; and &lt;code&gt;git submodule add&lt;/code&gt; is that &lt;code&gt;git submodule update&lt;/code&gt; checks out a specific commit, rather than the tip of a branch. It&amp;rsquo;s like checking out a tag: the head is detached, so you&amp;rsquo;re not working on a branch.</source>
          <target state="translated">&lt;code&gt;git submodule update&lt;/code&gt; と &lt;code&gt;git submodule add&lt;/code&gt; の大きな違いの1つは、 &lt;code&gt;git submodule update&lt;/code&gt; がブランチの先端ではなく特定のコミットをチェックアウトすることです。これは、タグをチェックアウトするようなものです。ヘッドが分離されているため、ブランチで作業していません。</target>
        </trans-unit>
        <trans-unit id="8d6438f7bb62b577ed24501432d3010343f7c06f" translate="yes" xml:space="preserve">
          <source>One nice about &quot;git bisect&quot; is that it is not only a developer tool. It can effectively be used by QA people or even end users (if they have access to the source code or if they can get access to all the builds).</source>
          <target state="translated">git bisect&quot; の良いところは、開発者だけのツールではないということです。QA の人やエンドユーザーでさえも (彼らがソースコードにアクセスできるか、すべてのビルドにアクセスできるのであれば)効果的に使うことができます。</target>
        </trans-unit>
        <trans-unit id="142f19dfe765b1c5ce574050578fa3bc8f7c4c07" translate="yes" xml:space="preserve">
          <source>One note: the special &lt;code&gt;master&lt;/code&gt; head is the default branch, which is why the &lt;code&gt;.git/HEAD&lt;/code&gt; file was created points to it even if it doesn&amp;rsquo;t yet exist. Basically, the &lt;code&gt;HEAD&lt;/code&gt; link is supposed to always point to the branch you are working on right now, and you always start out expecting to work on the &lt;code&gt;master&lt;/code&gt; branch.</source>
          <target state="translated">1つの注意：特別な &lt;code&gt;master&lt;/code&gt; ヘッドはデフォルトのブランチです。そのため、 &lt;code&gt;.git/HEAD&lt;/code&gt; ファイルがまだ存在していなくても、それがポイントされます。基本的に、 &lt;code&gt;HEAD&lt;/code&gt; リンクは常に現在作業中のブランチを指すようになっているため、常に &lt;code&gt;master&lt;/code&gt; ブランチで作業することを期待して開始します。</target>
        </trans-unit>
        <trans-unit id="29a0c8f350324f991b248dd3aa593e11f5862130" translate="yes" xml:space="preserve">
          <source>One obvious improvement to this algorithm would be to look for a commit that has an associated value near the one of the best bisection commit, and that is on another branch, before using the PRNG. Because if such a commit exists, then it is not very likely to be untestable too, so it will probably give more information than a nearly randomly chosen one.</source>
          <target state="translated">このアルゴリズムの明らかな改良点は、PRNG を使う前に、最高の二等分コミットの値に近い値を持つ、別のブランチにあるコミットを探すことです。なぜなら、もしそのようなコミットが存在するならば、それもテスト不可能である可能性が低いので、ほぼランダムに選ばれたコミットよりも多くの情報が得られるだろうからです。</target>
        </trans-unit>
        <trans-unit id="e1159b72c8727d654a00df87bb5a62e68448d486" translate="yes" xml:space="preserve">
          <source>One of the following transports can be used to name the repository to download from:</source>
          <target state="translated">以下のいずれかのトランスポートを使用して、ダウンロードするリポジトリの名前を指定することができます。</target>
        </trans-unit>
        <trans-unit id="f2e9320213d36179f9f718d529b707eca70ac72d" translate="yes" xml:space="preserve">
          <source>One of the ideas of having a branch is that you do some (possibly experimental) work in it, and eventually merge it back to the main branch. So assuming you created the above &lt;code&gt;mybranch&lt;/code&gt; that started out being the same as the original &lt;code&gt;master&lt;/code&gt; branch, let&amp;rsquo;s make sure we&amp;rsquo;re in that branch, and do some work there.</source>
          <target state="translated">ブランチを持つことのアイデアの1つは、ブランチで（おそらく実験的な）作業を行い、最終的にメインブランチにマージすることです。したがって、元の &lt;code&gt;master&lt;/code&gt; ブランチと同じである上記の &lt;code&gt;mybranch&lt;/code&gt; を作成したと想定して、そのブランチにいることを確認し、そこでいくつかの作業を行います。</target>
        </trans-unit>
        <trans-unit id="07b5c446feb269c31391e3ec2cd0376191f84e84" translate="yes" xml:space="preserve">
          <source>One of the identifiers &quot;&lt;a href=&quot;#def_commit_object&quot;&gt;commit&lt;/a&gt;&quot;, &quot;&lt;a href=&quot;#def_tree_object&quot;&gt;tree&lt;/a&gt;&quot;, &quot;&lt;a href=&quot;#def_tag_object&quot;&gt;tag&lt;/a&gt;&quot; or &quot;&lt;a href=&quot;#def_blob_object&quot;&gt;blob&lt;/a&gt;&quot; describing the type of an &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#def_object&quot;&gt;オブジェクトの&lt;/a&gt;タイプを説明する「&lt;a href=&quot;#def_commit_object&quot;&gt;コミット&lt;/a&gt;」、「&lt;a href=&quot;#def_tree_object&quot;&gt;ツリー&lt;/a&gt;」、「&lt;a href=&quot;#def_tag_object&quot;&gt;タグ&lt;/a&gt;」、または「&lt;a href=&quot;#def_blob_object&quot;&gt;ブロブ&lt;/a&gt;」のいずれかの識別子。</target>
        </trans-unit>
        <trans-unit id="4cfd499f1faa2bf47281b08252a27709dbf65c31" translate="yes" xml:space="preserve">
          <source>One or more of the options below may be used to determine the files shown:</source>
          <target state="translated">表示されているファイルを決定するために、以下のオプションの1つ以上を使用することができます。</target>
        </trans-unit>
        <trans-unit id="5fdc57e5472e4e105b70357796e6b6c7c9687799" translate="yes" xml:space="preserve">
          <source>One or more of the provided paths is ignored.</source>
          <target state="translated">提供されたパスのうち1つ以上は無視されます。</target>
        </trans-unit>
        <trans-unit id="fa8d672b6bbfcb201a67403df350a9a5a712d006" translate="yes" xml:space="preserve">
          <source>One phase in branch detection involves looking at p4 branches to find new ones to import. By default, all branches are inspected. This option limits the search to just those owned by the single user named in the variable.</source>
          <target state="translated">ブランチ検出の一つの段階では、p4 のブランチを調べてインポートする新しいブランチを見つけます。デフォルトでは、すべてのブランチが検査されます。このオプションは、変数で指定された単一のユーザが所有するブランチのみを検索対象とします。</target>
        </trans-unit>
        <trans-unit id="11468bd4c23009003db390c522332f7c3d2a8eae" translate="yes" xml:space="preserve">
          <source>One problem with &quot;git replace&quot; is that currently it stores all the replacements refs in &quot;refs/replace/&quot;, but it would be perhaps better if the replacement refs that are useful only for bisecting would be in &quot;refs/replace/bisect/&quot;. This way the replacement refs could be used only for bisecting, while other refs directly in &quot;refs/replace/&quot; would be used nearly all the time.</source>
          <target state="translated">git replace&quot; の問題点のひとつは、現在はすべての置換用 refs を &quot;refs/replace/&quot; に保存しているということです。そうすれば、置換用の参照は二分法のためだけに使われ、&quot;refs/replace/&quot;に直接ある他の参照はほぼずっと使われることになります。</target>
        </trans-unit>
        <trans-unit id="d1e2a86cedb580a377c28acdbf81410bf88bf79b" translate="yes" xml:space="preserve">
          <source>One record (for project / repository) per line; does not support line continuation (newline escaping).</source>
          <target state="translated">1行に1レコード(プロジェクト/リポジトリ用)。</target>
        </trans-unit>
        <trans-unit id="8e018f50410d5f4a4feb43d8b0ec18d17af4444c" translate="yes" xml:space="preserve">
          <source>One such software is the Linux kernel. And if we look at the Linux kernel, we can see that a lot of time and effort is spent to fight regressions. The release cycle start with a 2 weeks long merge window. Then the first release candidate (rc) version is tagged. And after that about 7 or 8 more rc versions will appear with around one week between each of them, before the final release.</source>
          <target state="translated">そのようなソフトウェアの一つがLinuxカーネルです。そして、Linuxカーネルを見てみると、リグレッションと戦うために多くの時間と労力が費やされていることがわかります。リリースサイクルは2週間の長いマージウィンドウから始まります。その後、最初のリリース候補 (rc)バージョンがタグ付けされます。その後、最終リリースまでの間に約1週間の間に7、8つのrcバージョンが現れます。</target>
        </trans-unit>
        <trans-unit id="bdac2081c61d66c365f2d2f97739c2e3f666a74e" translate="yes" xml:space="preserve">
          <source>One usage scenario is to run unit tests in the hook.</source>
          <target state="translated">1つの利用法としては、フックでユニットテストを実行するという方法があります。</target>
        </trans-unit>
        <trans-unit id="f9e9013eccf2a70e5a5f30b1ea62b3495fc5c835" translate="yes" xml:space="preserve">
          <source>One use of the content filtering is to massage the content into a shape that is more convenient for the platform, filesystem, and the user to use. For this mode of operation, the key phrase here is &quot;more convenient&quot; and not &quot;turning something unusable into usable&quot;. In other words, the intent is that if someone unsets the filter driver definition, or does not have the appropriate filter program, the project should still be usable.</source>
          <target state="translated">コンテンツフィルタリングの用途の一つに、プラットフォームやファイルシステム、ユーザーにとってより便利な形にコンテンツをマッサージするというものがあります。この動作モードでは、ここでのキーワードは「より便利に」であり、「使えないものを使えるものに変える」ということではありません。言い換えれば、誰かがフィルタドライバの定義を解除したり、適切なフィルタプログラムを持っていなかったりしても、プロジェクトはまだ使えるはずだということです。</target>
        </trans-unit>
        <trans-unit id="bf346c4d1c8b72f5f128424640398ae0ca4f5b99" translate="yes" xml:space="preserve">
          <source>One way to test if your MUA is set up correctly is:</source>
          <target state="translated">あなたのMUAが正しく設定されているかどうかをテストする方法の一つです。</target>
        </trans-unit>
        <trans-unit id="2d149b07bfc5760abe904c522d47cdc6ed806f7c" translate="yes" xml:space="preserve">
          <source>Only allow &lt;code&gt;--filter=tree:&amp;lt;n&amp;gt;&lt;/code&gt; when &lt;code&gt;&amp;lt;n&amp;gt;&lt;/code&gt; is no more than the value of &lt;code&gt;uploadpackfilter.tree.maxDepth&lt;/code&gt;. If set, this also implies &lt;code&gt;uploadpackfilter.tree.allow=true&lt;/code&gt;, unless this configuration variable had already been set. Has no effect if unset.</source>
          <target state="translated">のみを許可 &lt;code&gt;--filter=tree:&amp;lt;n&amp;gt;&lt;/code&gt; とき &lt;code&gt;&amp;lt;n&amp;gt;&lt;/code&gt; これ以上の値よりも &lt;code&gt;uploadpackfilter.tree.maxDepth&lt;/code&gt; 。設定されている場合、この構成変数がすでに設定されていない限り、これは &lt;code&gt;uploadpackfilter.tree.allow=true&lt;/code&gt; も意味します。設定されていない場合は効果がありません。</target>
        </trans-unit>
        <trans-unit id="b7da7d48889d5c708679796bf76623241882d879" translate="yes" xml:space="preserve">
          <source>Only allow viewing of repositories also shown on the overview page. This for example makes &lt;code&gt;$export_ok&lt;/code&gt; file decide if repository is available and not only if it is shown. If &lt;code&gt;$projects_list&lt;/code&gt; points to file with list of project, only those repositories listed would be available for gitweb. Can be set during building gitweb via &lt;code&gt;GITWEB_STRICT_EXPORT&lt;/code&gt;. By default this variable is not set, which means that you can directly access those repositories that are hidden from projects list page (e.g. the are not listed in the $projects_list file).</source>
          <target state="translated">概要ページにも表示されるリポジトリの表示のみを許可します。たとえば、これは &lt;code&gt;$export_ok&lt;/code&gt; ファイルに、リポジトリが表示されているかどうかだけでなく、リポジトリが使用可能かどうかを決定させます。 &lt;code&gt;$projects_list&lt;/code&gt; がプロジェクトのリストを含むファイルを指している場合、リストされているリポジトリのみがgitwebで使用できます。 GITWEB_STRICT_EXPORTを介して &lt;code&gt;GITWEB_STRICT_EXPORT&lt;/code&gt; をビルドするときに設定できます。デフォルトでは、この変数は設定されていません。つまり、プロジェクトリストページで非表示になっているリポジトリに直接アクセスできます（例：$ projects_listファイルにリストされていない）。</target>
        </trans-unit>
        <trans-unit id="a9db6957ecdccb26c443588b379fe63817da234e" translate="yes" xml:space="preserve">
          <source>Only anonymous access is provided by pserve by default. To commit you will have to create pserver accounts, simply add a gitcvs.authdb setting in the config file of the repositories you want the cvsserver to allow writes to, for example:</source>
          <target state="translated">デフォルトでは、pserve は匿名アクセスのみを提供しています。コミットするには pserver のアカウントを作成しなければなりませんが、cvserver が書き込みを許可するリポジトリの設定ファイルに gitcvs.authdb の設定を追加するだけです。</target>
        </trans-unit>
        <trans-unit id="f8de1f9ddde9f99ee756c31ae048d708dda7832c" translate="yes" xml:space="preserve">
          <source>Only bind the web server to the local IP (127.0.0.1).</source>
          <target state="translated">ウェブサーバーをローカルIP(127.0.0.0.1)にのみバインドします。</target>
        </trans-unit>
        <trans-unit id="914060d4007bba68d0e5b57a08eb8520cbc0281b" translate="yes" xml:space="preserve">
          <source>Only consider tags matching the given &lt;code&gt;glob(7)&lt;/code&gt; pattern, excluding the &quot;refs/tags/&quot; prefix. If used with &lt;code&gt;--all&lt;/code&gt;, it also considers local branches and remote-tracking references matching the pattern, excluding respectively &quot;refs/heads/&quot; and &quot;refs/remotes/&quot; prefix; references of other types are never considered. If given multiple times, a list of patterns will be accumulated, and tags matching any of the patterns will be considered. Use &lt;code&gt;--no-match&lt;/code&gt; to clear and reset the list of patterns.</source>
          <target state="translated">「refs / tags /」接頭辞を除いて、指定された &lt;code&gt;glob(7)&lt;/code&gt; パターンに一致するタグのみを考慮します。 &lt;code&gt;--all&lt;/code&gt; と一緒に使用すると、パターンに一致するローカルブランチおよびリモートトラッキング参照も考慮されます。それぞれ「refs / heads /」および「refs / remotes /」プレフィックスは除外されます。他のタイプの参照は考慮されません。複数回指定すると、パターンのリストが蓄積され、パターンのいずれかに一致するタグが考慮されます。パターンのリストをクリアしてリセットするには、 &lt;code&gt;--no-match&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="941066ff4f5ea2a1056ac361a36573c125ff04f2" translate="yes" xml:space="preserve">
          <source>Only create a packed archive if it would contain at least one object.</source>
          <target state="translated">少なくとも 1 つのオブジェクトを含む場合にのみ、パックされたアーカイブを作成します。</target>
        </trans-unit>
        <trans-unit id="83ca14f8cd2c9566aaa74ad9a438e0a15bc783b9" translate="yes" xml:space="preserve">
          <source>Only expire loose objects older than &amp;lt;time&amp;gt;.</source>
          <target state="translated">&amp;lt;time&amp;gt;より古い緩いオブジェクトのみを期限切れにします。</target>
        </trans-unit>
        <trans-unit id="d50becec82fb156672fd24c1ecb55cefe6d9b0c0" translate="yes" xml:space="preserve">
          <source>Only list branches of the given object.</source>
          <target state="translated">与えられたオブジェクトのブランチのみをリストアップします。</target>
        </trans-unit>
        <trans-unit id="ae8314faed018be3007d334a54cd4f7b3bde067a" translate="yes" xml:space="preserve">
          <source>Only list branches which contain the specified commit (HEAD if not specified). Implies &lt;code&gt;--list&lt;/code&gt;.</source>
          <target state="translated">指定されたコミット（指定されていない場合はHEAD）を含むブランチのみをリストします。 &lt;code&gt;--list&lt;/code&gt; を意味します。</target>
        </trans-unit>
        <trans-unit id="b39fcb7ccfd206d2a11b5cac77f876ebbcdc59a6" translate="yes" xml:space="preserve">
          <source>Only list branches which don&amp;rsquo;t contain the specified commit (HEAD if not specified). Implies &lt;code&gt;--list&lt;/code&gt;.</source>
          <target state="translated">指定されたコミット（指定されていない場合はHEAD）を含まないブランチのみをリストします。 &lt;code&gt;--list&lt;/code&gt; を意味します。</target>
        </trans-unit>
        <trans-unit id="5d91bc93b24e96b92cd74b3016507c8892f02d8e" translate="yes" xml:space="preserve">
          <source>Only list branches whose tips are not reachable from the specified commit (HEAD if not specified). Implies &lt;code&gt;--list&lt;/code&gt;, incompatible with &lt;code&gt;--merged&lt;/code&gt;.</source>
          <target state="translated">指定されたコミット（指定されていない場合はHEAD）からヒントに到達できないブランチのみをリストします。意味 &lt;code&gt;--list&lt;/code&gt; と互換性がない、 &lt;code&gt;--merged&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7f18c194fbea0e6a25127dd2c0242348888bebb8" translate="yes" xml:space="preserve">
          <source>Only list branches whose tips are not reachable from the specified commit (HEAD if not specified). Implies &lt;code&gt;--list&lt;/code&gt;.</source>
          <target state="translated">指定されたコミットからヒントに到達できないブランチのみをリストします（指定されていない場合はHEAD）。 &lt;code&gt;--list&lt;/code&gt; を意味します。</target>
        </trans-unit>
        <trans-unit id="368e1f5311ab357c6579dd2598d3554e5f69ab7b" translate="yes" xml:space="preserve">
          <source>Only list branches whose tips are reachable from the specified commit (HEAD if not specified). Implies &lt;code&gt;--list&lt;/code&gt;, incompatible with &lt;code&gt;--no-merged&lt;/code&gt;.</source>
          <target state="translated">指定されたコミット（指定されていない場合はHEAD）からヒントに到達できるブランチのみをリストします。意味 &lt;code&gt;--list&lt;/code&gt; と互換性がない、 &lt;code&gt;--no-merged&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8e8c13c3ac0a7b1c9d8836463a5f79c31b1444a5" translate="yes" xml:space="preserve">
          <source>Only list branches whose tips are reachable from the specified commit (HEAD if not specified). Implies &lt;code&gt;--list&lt;/code&gt;.</source>
          <target state="translated">指定されたコミットからヒントに到達できるブランチのみをリストします（指定されていない場合はHEAD）。 &lt;code&gt;--list&lt;/code&gt; を意味します。</target>
        </trans-unit>
        <trans-unit id="dc004fe98c7c853edcd721c4a4743bbe17dc0ceb" translate="yes" xml:space="preserve">
          <source>Only list refs which contain the specified commit (HEAD if not specified).</source>
          <target state="translated">指定されたコミットを含む参照のみをリストアップします (指定されていない場合は HEAD)。</target>
        </trans-unit>
        <trans-unit id="53301ab6d13e8c23069a84dba2acf3daf5a67784" translate="yes" xml:space="preserve">
          <source>Only list refs which don&amp;rsquo;t contain the specified commit (HEAD if not specified).</source>
          <target state="translated">指定されたコミット（指定されていない場合はHEAD）を含まない参照のみをリストします。</target>
        </trans-unit>
        <trans-unit id="13917fddfb76486aac0b6b32382a8222d7ef7129" translate="yes" xml:space="preserve">
          <source>Only list refs which points at the given object.</source>
          <target state="translated">与えられたオブジェクトを指す参照のみをリストアップします。</target>
        </trans-unit>
        <trans-unit id="d63446ed3ed439dd64fa48118858d7dc8f885568" translate="yes" xml:space="preserve">
          <source>Only list refs whose tips are not reachable from the specified commit (HEAD if not specified), incompatible with &lt;code&gt;--merged&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--merged&lt;/code&gt; と互換性がなく、指定されたコミット（指定されていない場合はHEAD）からヒントに到達できない参照のみをリストします。</target>
        </trans-unit>
        <trans-unit id="a3045719971c55f87c34a7fd746215fdcca5bdb6" translate="yes" xml:space="preserve">
          <source>Only list refs whose tips are not reachable from the specified commit (HEAD if not specified).</source>
          <target state="translated">指定されたコミットからヒントに到達できない refs のみをリストアップします (指定されていない場合は HEAD)。</target>
        </trans-unit>
        <trans-unit id="b4d24af2a09941026de883e7412997a62ab6d500" translate="yes" xml:space="preserve">
          <source>Only list refs whose tips are reachable from the specified commit (HEAD if not specified), incompatible with &lt;code&gt;--no-merged&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--no-merged&lt;/code&gt; と互換性がなく、指定されたコミット（指定されていない場合はHEAD）からヒントに到達できる参照のみをリストします。</target>
        </trans-unit>
        <trans-unit id="ba8f796a110a2bce3b3362030f4149e3e571d92d" translate="yes" xml:space="preserve">
          <source>Only list refs whose tips are reachable from the specified commit (HEAD if not specified).</source>
          <target state="translated">指定されたコミット(指定されていない場合はHEAD)からTipが到達可能なrefのみをリストアップします。</target>
        </trans-unit>
        <trans-unit id="817a4e30ee524e4266621c0a4648ab3909ffeed4" translate="yes" xml:space="preserve">
          <source>Only list tags of the given object (HEAD if not specified). Implies &lt;code&gt;--list&lt;/code&gt;.</source>
          <target state="translated">指定されたオブジェクトのタグのみをリストします（指定されていない場合はHEAD）。 &lt;code&gt;--list&lt;/code&gt; を意味します。</target>
        </trans-unit>
        <trans-unit id="83f1d08e3476b4b0f43eedc9885a23e56ff396f3" translate="yes" xml:space="preserve">
          <source>Only list tags which contain the specified commit (HEAD if not specified). Implies &lt;code&gt;--list&lt;/code&gt;.</source>
          <target state="translated">指定されたコミット（指定されていない場合はHEAD）を含むタグのみをリストします。 &lt;code&gt;--list&lt;/code&gt; を意味します。</target>
        </trans-unit>
        <trans-unit id="4bae480f98a8915919a61381cb993558ff75823a" translate="yes" xml:space="preserve">
          <source>Only list tags which don&amp;rsquo;t contain the specified commit (HEAD if not specified). Implies &lt;code&gt;--list&lt;/code&gt;.</source>
          <target state="translated">指定されたコミット（指定されていない場合はHEAD）を含まないタグのみをリストします。 &lt;code&gt;--list&lt;/code&gt; を意味します。</target>
        </trans-unit>
        <trans-unit id="db9714bdab86b2c5263129a27ca40bb06f5dcdf2" translate="yes" xml:space="preserve">
          <source>Only list tags whose commits are not reachable from the specified commit (&lt;code&gt;HEAD&lt;/code&gt; if not specified), incompatible with &lt;code&gt;--merged&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--merged&lt;/code&gt; と互換性がなく、指定されたコミット（指定されていない場合は &lt;code&gt;HEAD&lt;/code&gt; ）からコミットに到達できないタグのみをリストします。</target>
        </trans-unit>
        <trans-unit id="0941b6737a5c9cc5d8d6c699e027514c86f27e53" translate="yes" xml:space="preserve">
          <source>Only list tags whose commits are not reachable from the specified commit (&lt;code&gt;HEAD&lt;/code&gt; if not specified).</source>
          <target state="translated">指定されたコミットからコミットに到達できないタグのみをリストします（指定されていない場合は &lt;code&gt;HEAD&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="1c62aa2054943bc2c5749c5693c2757ab8e53449" translate="yes" xml:space="preserve">
          <source>Only list tags whose commits are reachable from the specified commit (&lt;code&gt;HEAD&lt;/code&gt; if not specified), incompatible with &lt;code&gt;--no-merged&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--no-merged&lt;/code&gt; と互換性がなく、指定されたコミット（指定されていない場合は &lt;code&gt;HEAD&lt;/code&gt; ）からコミットに到達できるタグのみをリストします。</target>
        </trans-unit>
        <trans-unit id="bc01884094a83344ad50773c56388f9731a753fa" translate="yes" xml:space="preserve">
          <source>Only list tags whose commits are reachable from the specified commit (&lt;code&gt;HEAD&lt;/code&gt; if not specified).</source>
          <target state="translated">指定されたコミットからコミットに到達できるタグのみをリストします（指定されていない場合は &lt;code&gt;HEAD&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="b0cdb0cde0c40de0beaaced5d658f2a7018630fe" translate="yes" xml:space="preserve">
          <source>Only look at the history which touches the given subdirectory. The result will contain that directory (and only that) as its project root. Implies &lt;a href=&quot;#Remap_to_ancestor&quot;&gt;Remap to ancestor&lt;/a&gt;.</source>
          <target state="translated">与えられたサブディレクトリに触れる履歴のみを見てください。結果には、プロジェクトルートとしてそのディレクトリ（およびそのディレクトリのみ）が含まれます。&lt;a href=&quot;#Remap_to_ancestor&quot;&gt;先祖への&lt;/a&gt;リマップを意味します。</target>
        </trans-unit>
        <trans-unit id="2bbdf47a64eee45ee95696813788d11863c01152" translate="yes" xml:space="preserve">
          <source>Only meaningful in &lt;code&gt;--parseopt&lt;/code&gt; mode. Lets the option parser stop at the first non-option argument. This can be used to parse sub-commands that take options themselves.</source>
          <target state="translated">&lt;code&gt;--parseopt&lt;/code&gt; モードでのみ意味があります。オプションパーサーが最初の非オプション引数で停止できるようにします。これは、オプション自体を取るサブコマンドを解析するために使用できます。</target>
        </trans-unit>
        <trans-unit id="d8057f98f6fd66c86adb34f091c531e316f7ca42" translate="yes" xml:space="preserve">
          <source>Only meaningful in &lt;code&gt;--parseopt&lt;/code&gt; mode. Output the options in their long form if available, and with their arguments stuck.</source>
          <target state="translated">&lt;code&gt;--parseopt&lt;/code&gt; モードでのみ意味があります。可能な場合はオプションを長い形式で出力し、引数はスタックしたままにします。</target>
        </trans-unit>
        <trans-unit id="6000fe90599266e72e627572d6cdbc969916ee02" translate="yes" xml:space="preserve">
          <source>Only meaningful in &lt;code&gt;--parseopt&lt;/code&gt; mode. Tells the option parser to echo out the first &lt;code&gt;--&lt;/code&gt; met instead of skipping it.</source>
          <target state="translated">&lt;code&gt;--parseopt&lt;/code&gt; モードでのみ意味があります。オプションパーサーに最初のメッセージをエコーするように指示します &lt;code&gt;--&lt;/code&gt; スキップする代わりに一致します。</target>
        </trans-unit>
        <trans-unit id="fd3f5d99fba63ca8e5d281298074650f7e9548b0" translate="yes" xml:space="preserve">
          <source>Only meaningful in &lt;code&gt;--verify&lt;/code&gt; mode. Do not output an error message if the first argument is not a valid object name; instead exit with non-zero status silently. SHA-1s for valid object names are printed to stdout on success.</source>
          <target state="translated">&lt;code&gt;--verify&lt;/code&gt; モードでのみ意味があります。最初の引数が有効なオブジェクト名でない場合、エラーメッセージを出力しません。代わりにゼロ以外のステータスで静かに終了します。有効なオブジェクト名のSHA-1は、成功するとstdoutに出力されます。</target>
        </trans-unit>
        <trans-unit id="94590902338d0f64df58223a7c9238b6579f4aae" translate="yes" xml:space="preserve">
          <source>Only meaningful with &lt;code&gt;--pathspec-from-file&lt;/code&gt;. Pathspec elements are separated with NUL character and all other characters are taken literally (including newlines and quotes).</source>
          <target state="translated">&lt;code&gt;--pathspec-from-file&lt;/code&gt; でのみ意味があります。Pathspec要素はNUL文字で区切られ、他のすべての文字は文字どおりに解釈されます（改行と引用符を含む）。</target>
        </trans-unit>
        <trans-unit id="0ecebefb0a1162c42954005e600970eacea40ab1" translate="yes" xml:space="preserve">
          <source>Only meaningful with &lt;code&gt;--stdin&lt;/code&gt; or &lt;code&gt;--index-info&lt;/code&gt;; paths are separated with NUL character instead of LF.</source>
          <target state="translated">&lt;code&gt;--stdin&lt;/code&gt; または &lt;code&gt;--index-info&lt;/code&gt; でのみ意味があります。パスはLFではなくNUL文字で区切られます。</target>
        </trans-unit>
        <trans-unit id="6ad4315a7f6c11660aa6c643c4b95eaab7a8d728" translate="yes" xml:space="preserve">
          <source>Only meaningful with &lt;code&gt;--stdin&lt;/code&gt;; paths are separated with NUL character instead of LF.</source>
          <target state="translated">&lt;code&gt;--stdin&lt;/code&gt; でのみ意味があります。パスはLFではなくNUL文字で区切られます。</target>
        </trans-unit>
        <trans-unit id="2ebb91d27792ee23446f1d49f12e2e8cf850fef7" translate="yes" xml:space="preserve">
          <source>Only necessary if --compose is also set. If --compose is not set, this will be prompted for.</source>
          <target state="translated">compose が設定されている場合にのみ必要です。composeが設定されていない場合は、プロンプトが表示されます。</target>
        </trans-unit>
        <trans-unit id="3a2cfa8e4dfa7576e427c217c4a335798a141827" translate="yes" xml:space="preserve">
          <source>Only one parameter should be set to &quot;1&quot; when the hook runs. The hook running passing &quot;1&quot;, &quot;1&quot; should not be possible.</source>
          <target state="translated">フックが走るときのパラメータは1つだけ「1」にしてください。&quot;1&quot;、&quot;1 &quot;を渡してのフック実行はできないはずです。</target>
        </trans-unit>
        <trans-unit id="bf7e12b67481a70907ee19a1cd34bdb9c2cfbcbb" translate="yes" xml:space="preserve">
          <source>Only output exact matches (a tag directly references the supplied commit). This is a synonym for --candidates=0.</source>
          <target state="translated">完全に一致するものだけを出力します (タグは指定されたコミットを直接参照します)。これは --candidates=0 と同義です。</target>
        </trans-unit>
        <trans-unit id="16dbfb260245eaec3998212f13b1a52e2d286e0a" translate="yes" xml:space="preserve">
          <source>Only p4 labels matching this regular expression will be exported. The default value is &lt;code&gt;[a-zA-Z0-9_\-.]+$&lt;/code&gt;.</source>
          <target state="translated">この正規表現に一致するp4ラベルのみがエクスポートされます。デフォルト値は &lt;code&gt;[a-zA-Z0-9_\-.]+$&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="eeb8bb30ea7ba21536e78e1ff49007a02268174b" translate="yes" xml:space="preserve">
          <source>Only p4 labels matching this regular expression will be imported. The default value is &lt;code&gt;[a-zA-Z0-9_\-.]+$&lt;/code&gt;.</source>
          <target state="translated">この正規表現に一致するp4ラベルのみがインポートされます。デフォルト値は &lt;code&gt;[a-zA-Z0-9_\-.]+$&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="e2fdb861f4cc24f6e2448e8ab0d3c248ec24997f" translate="yes" xml:space="preserve">
          <source>Only perform tests on the working directory to make sure untracked cache can be used. You have to manually enable untracked cache using &lt;code&gt;--untracked-cache&lt;/code&gt; or &lt;code&gt;--force-untracked-cache&lt;/code&gt; or the &lt;code&gt;core.untrackedCache&lt;/code&gt; configuration variable afterwards if you really want to use it. If a test fails the exit code is 1 and a message explains what is not working as needed, otherwise the exit code is 0 and OK is printed.</source>
          <target state="translated">作業ディレクトリでのみテストを実行して、追跡されていないキャッシュを使用できることを確認してください。本当に使用したい場合は、 &lt;code&gt;core.untrackedCache&lt;/code&gt; &lt;code&gt;--untracked-cache&lt;/code&gt; または &lt;code&gt;--force-untracked-cache&lt;/code&gt; untracked-cacheまたはcore.untrackedCache構成変数を使用して、追跡されていないキャッシュを手動で有効にする必要があります。テストが失敗した場合、終了コードは1であり、必要に応じて何が機能していないかを説明するメッセージが表示されます。それ以外の場合、終了コードは0でOKが出力されます。</target>
        </trans-unit>
        <trans-unit id="9b88e48a96d98ad3b76de8b5d274db692fc6b29c" translate="yes" xml:space="preserve">
          <source>Only print error and warning messages; all other output will be suppressed.</source>
          <target state="translated">エラーメッセージと警告メッセージのみを表示し、それ以外の出力はすべて抑制されます。</target>
        </trans-unit>
        <trans-unit id="3791d8648f923430d0795b4e9f5031ac211bf7f1" translate="yes" xml:space="preserve">
          <source>Only print error messages.</source>
          <target state="translated">エラーメッセージのみを印刷します。</target>
        </trans-unit>
        <trans-unit id="affbeb73b1dd267a08167d9ea74afe477ad3529f" translate="yes" xml:space="preserve">
          <source>Only show the SHA-1 hash, not the reference name. When combined with --dereference the dereferenced tag will still be shown after the SHA-1.</source>
          <target state="translated">参照名ではなく、SHA-1 ハッシュのみを表示します。参照先タグは、--dereferenceと組み合わせても、SHA-1の後に表示されます。</target>
        </trans-unit>
        <trans-unit id="74a12c610ac9d71beb7074574ccb847224f9f712" translate="yes" xml:space="preserve">
          <source>Only show the given commits, but do not traverse their ancestors. This has no effect if a range is specified. If the argument &lt;code&gt;unsorted&lt;/code&gt; is given, the commits are shown in the order they were given on the command line. Otherwise (if &lt;code&gt;sorted&lt;/code&gt; or no argument was given), the commits are shown in reverse chronological order by commit time. Cannot be combined with &lt;code&gt;--graph&lt;/code&gt;.</source>
          <target state="translated">指定されたコミットのみを表示し、その祖先をトラバースしないでください。範囲が指定されている場合、これは効果がありません。 &lt;code&gt;unsorted&lt;/code&gt; 引数が指定された場合、コミットはコマンドラインで指定された順序で表示されます。それ以外の場合（ &lt;code&gt;sorted&lt;/code&gt; 場合、または引数が指定されていない場合）、コミットはコミット時刻の新しい順に表示されます。 &lt;code&gt;--graph&lt;/code&gt; と組み合わせることはできません。</target>
        </trans-unit>
        <trans-unit id="6ed956e65db38a49fac1dac50248e7edb1c43fb7" translate="yes" xml:space="preserve">
          <source>Only submodules using a gitfile (which means they were cloned with a Git version 1.7.8 or newer) will be removed from the work tree, as their repository lives inside the .git directory of the superproject. If a submodule (or one of those nested inside it) still uses a .git directory, &lt;code&gt;git rm&lt;/code&gt; will move the submodules git directory into the superprojects git directory to protect the submodule&amp;rsquo;s history. If it exists the submodule.&amp;lt;name&amp;gt; section in the &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt; file will also be removed and that file will be staged (unless --cached or -n are used).</source>
          <target state="translated">gitfileを使用するサブモジュール（つまり、Gitバージョン1.7.8以降で複製されたもの）のみが、スーパープロジェクトの.gitディレクトリ内にリポジトリが存在するため、ワークツリーから削除されます。サブモジュール（またはその中にネストされたモジュール）が.gitディレクトリを使用している場合、 &lt;code&gt;git rm&lt;/code&gt; はサブモジュールの履歴を保護するために、サブモジュールのgitディレクトリをスーパープロジェクトのgitディレクトリに移動します。存在する場合は、&lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5]&lt;/a&gt;ファイルのsubmodule。&amp;lt;name&amp;gt;セクションも削除され、そのファイルがステージングされます（--cachedまたは-nが使用されている場合を除く）。</target>
        </trans-unit>
        <trans-unit id="f3b6918bb732fd2722633a305233dd0ec34bff15" translate="yes" xml:space="preserve">
          <source>Only takes effect for dates shown in human-readable format, such as when using &lt;code&gt;--pretty&lt;/code&gt;. &lt;code&gt;log.date&lt;/code&gt; config variable sets a default value for the log command&amp;rsquo;s &lt;code&gt;--date&lt;/code&gt; option. By default, dates are shown in the original time zone (either committer&amp;rsquo;s or author&amp;rsquo;s). If &lt;code&gt;-local&lt;/code&gt; is appended to the format (e.g., &lt;code&gt;iso-local&lt;/code&gt;), the user&amp;rsquo;s local time zone is used instead.</source>
          <target state="translated">&lt;code&gt;--pretty&lt;/code&gt; を使用する場合など、人間が読める形式で表示される日付に対してのみ有効です。 &lt;code&gt;log.date&lt;/code&gt; 構成変数は、logコマンドの &lt;code&gt;--date&lt;/code&gt; オプションのデフォルト値を設定します。デフォルトでは、日付は元のタイムゾーン（コミッターまたは作成者のいずれか）で表示されます。形式に &lt;code&gt;-local&lt;/code&gt; が追加されている場合（例： &lt;code&gt;iso-local&lt;/code&gt; ）、代わりにユーザーのローカルタイムゾーンが使用されます。</target>
        </trans-unit>
        <trans-unit id="28227446e42814d459bad1017137f194a3d411bf" translate="yes" xml:space="preserve">
          <source>Only the initial ref advertisement is output, and the program exits immediately. This fits with the HTTP GET request model, where no request content is received but a response must be produced.</source>
          <target state="translated">最初の ref アドバタイズメントのみが出力され、プログラムはすぐに終了します。これはHTTP GETリクエストモデルに適合しています。</target>
        </trans-unit>
        <trans-unit id="d70e32ee66c9f176a2ec41ee4464e248b98de054" translate="yes" xml:space="preserve">
          <source>Only the rev_map and refs/remotes/git-svn are changed (see &lt;code&gt;$GIT_DIR/svn/**/.rev_map.*&lt;/code&gt; in the FILES section below for details). Follow &lt;code&gt;reset&lt;/code&gt; with a &lt;code&gt;fetch&lt;/code&gt; and then &lt;code&gt;git reset&lt;/code&gt; or &lt;code&gt;git rebase&lt;/code&gt; to move local branches onto the new tree.</source>
          <target state="translated">rev_mapとrefs / remotes / git-svnのみが変更されます（詳細については、以下の「ファイル」セクションの &lt;code&gt;$GIT_DIR/svn/**/.rev_map.*&lt;/code&gt; を参照してください）。フォロー &lt;code&gt;reset&lt;/code&gt; して &lt;code&gt;fetch&lt;/code&gt; して、 &lt;code&gt;git reset&lt;/code&gt; や &lt;code&gt;git rebase&lt;/code&gt; 新しい木の上に移動するために、ローカルのブランチを。</target>
        </trans-unit>
        <trans-unit id="32e7b8a674c1b57420afbf6e783864cc587eae94" translate="yes" xml:space="preserve">
          <source>Only the selected commits are shown, plus some to have a meaningful history.</source>
          <target state="translated">選択されたコミットのみが表示され、それに加えて意味のある履歴を持ついくつかのコミットが表示されます。</target>
        </trans-unit>
        <trans-unit id="5988bcb17bfff8bdefbf4f11c653c30a84ac354c" translate="yes" xml:space="preserve">
          <source>Only untracked files in submodules will be ignored. Committed differences and modifications to tracked files will show up.</source>
          <target state="translated">サブモジュール内の追跡されていないファイルだけが無視されます。コミットされた差分や追跡されたファイルへの修正は表示されます。</target>
        </trans-unit>
        <trans-unit id="a35d5f8b7ffccc1327ae3b4b170fadaf17be62a8" translate="yes" xml:space="preserve">
          <source>Only update and add files to the working directory, but don&amp;rsquo;t delete them, similar to how 'cp -R' would update the contents in the destination directory. This is the default mode in a &lt;a href=&quot;#def_checkout&quot;&gt;checkout&lt;/a&gt; when checking out files from the &lt;a href=&quot;#def_index&quot;&gt;index&lt;/a&gt; or a &lt;a href=&quot;#def_tree-ish&quot;&gt;tree-ish&lt;/a&gt;. In contrast, no-overlay mode also deletes tracked files not present in the source, similar to 'rsync --delete'.</source>
          <target state="translated">「cp -R」が宛先ディレクトリーの内容を更新する方法と同様に、ファイルを更新して作業ディレクトリーに追加するだけで、削除はしません。これは、&lt;a href=&quot;#def_index&quot;&gt;インデックス&lt;/a&gt;または&lt;a href=&quot;#def_tree-ish&quot;&gt;ツリーっぽい&lt;/a&gt;からファイルをチェックアウトするときのチェック&lt;a href=&quot;#def_checkout&quot;&gt;アウトの&lt;/a&gt;デフォルトモードです。対照的に、オーバーレイなしモードでは、「rsync --delete」と同様に、ソースに存在しない追跡ファイルも削除されます。</target>
        </trans-unit>
        <trans-unit id="a09a6feef23c1bf8bf8489c07fa754b0e3467e64" translate="yes" xml:space="preserve">
          <source>Only update and add files to the working directory, but don&amp;rsquo;t delete them, similar to how &lt;code&gt;cp -R&lt;/code&gt; would update the contents in the destination directory. This is the default mode in a &lt;a href=&quot;#def_checkout&quot;&gt;checkout&lt;/a&gt; when checking out files from the &lt;a href=&quot;#def_index&quot;&gt;index&lt;/a&gt; or a &lt;a href=&quot;#def_tree-ish&quot;&gt;tree-ish&lt;/a&gt;. In contrast, no-overlay mode also deletes tracked files not present in the source, similar to &lt;code&gt;rsync --delete&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;cp -R&lt;/code&gt; が宛先ディレクトリーの内容を更新する方法と同様に、ファイルを更新して作業ディレクトリーに追加するだけで、削除はしません。これは、&lt;a href=&quot;#def_index&quot;&gt;インデックス&lt;/a&gt;または&lt;a href=&quot;#def_tree-ish&quot;&gt;ツリーっぽい&lt;/a&gt;からファイルをチェックアウトするときのチェック&lt;a href=&quot;#def_checkout&quot;&gt;アウトの&lt;/a&gt;デフォルトモードです。対照的に、オーバーレイなしモードでは、 &lt;code&gt;rsync --delete&lt;/code&gt; と同様に、ソースに存在しない追跡ファイルも削除されます。</target>
        </trans-unit>
        <trans-unit id="cd6ac5160ec46e3d1df2371d183d50a5e06ffdbe" translate="yes" xml:space="preserve">
          <source>Only use refs whose names match a given shell pattern. The pattern can be one of branch name, tag name or fully qualified ref name. If given multiple times, use refs whose names match any of the given shell patterns. Use &lt;code&gt;--no-refs&lt;/code&gt; to clear any previous ref patterns given.</source>
          <target state="translated">名前が特定のシェルパターンに一致する参照のみを使用します。パターンは、ブランチ名、タグ名、または完全修飾参照名のいずれかです。複数回指定する場合は、指定したシェルパターンのいずれかに名前が一致する参照を使用します。 &lt;code&gt;--no-refs&lt;/code&gt; を使用して、指定された以前のrefパターンをクリアします。</target>
        </trans-unit>
        <trans-unit id="2d533153e7612cafa4bc7b83b50dd3abb697af0e" translate="yes" xml:space="preserve">
          <source>Only used with the &lt;code&gt;dcommit&lt;/code&gt;, &lt;code&gt;set-tree&lt;/code&gt; and &lt;code&gt;commit-diff&lt;/code&gt; commands.</source>
          <target state="translated">&lt;code&gt;dcommit&lt;/code&gt; 、 &lt;code&gt;set-tree&lt;/code&gt; 、および &lt;code&gt;commit-diff&lt;/code&gt; コマンドでのみ使用されます。</target>
        </trans-unit>
        <trans-unit id="901e1e4a237282bb48e582bb5bf0599881cd0084" translate="yes" xml:space="preserve">
          <source>Only used with the &lt;code&gt;init&lt;/code&gt; command. These are passed directly to &lt;code&gt;git init&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;init&lt;/code&gt; コマンドでのみ使用されます。これらは &lt;code&gt;git init&lt;/code&gt; に直接渡されます。</target>
        </trans-unit>
        <trans-unit id="f5e61001de0ada8f2eb5dc9bbc0a16644112482b" translate="yes" xml:space="preserve">
          <source>Only used with the &lt;code&gt;set-tree&lt;/code&gt; command.</source>
          <target state="translated">&lt;code&gt;set-tree&lt;/code&gt; コマンドでのみ使用されます。</target>
        </trans-unit>
        <trans-unit id="e227b5617ca7c2b377054ab1d12644a8cc591504" translate="yes" xml:space="preserve">
          <source>Only useful with &lt;code&gt;--filter=&lt;/code&gt;; prints a list of the objects omitted by the filter. Object IDs are prefixed with a &amp;ldquo;~&amp;rdquo; character.</source>
          <target state="translated">&lt;code&gt;--filter=&lt;/code&gt; でのみ役立ちます。フィルターによって除外されたオブジェクトのリストを出力します。オブジェクトIDの前には「〜」文字が付いています。</target>
        </trans-unit>
        <trans-unit id="c898c5ecedbff05a6572c10f50d4d5872a590271" translate="yes" xml:space="preserve">
          <source>Only useful with &lt;code&gt;--objects&lt;/code&gt;; does not print the names of the object IDs that are found. This inverts &lt;code&gt;--object-names&lt;/code&gt;. This flag allows the output to be more easily parsed by commands such as &lt;a href=&quot;git-cat-file&quot;&gt;git-cat-file[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;--objects&lt;/code&gt; でのみ役立ちます。見つかったオブジェクトIDの名前は出力しません。 &lt;code&gt;--object-names&lt;/code&gt; を逆にします。このフラグを使用すると、&lt;a href=&quot;git-cat-file&quot;&gt;git-cat-file [1]&lt;/a&gt;などのコマンドで出力をより簡単に解析できます。</target>
        </trans-unit>
        <trans-unit id="cbbf115261d96b04c5005e948b7d150b4779f83e" translate="yes" xml:space="preserve">
          <source>Only useful with &lt;code&gt;--objects&lt;/code&gt;; print the names of the object IDs that are found. This is the default behavior.</source>
          <target state="translated">&lt;code&gt;--objects&lt;/code&gt; でのみ役立ちます。見つかったオブジェクトIDの名前を出力します。これがデフォルトの動作です。</target>
        </trans-unit>
        <trans-unit id="96aa4c0ed29b4ff25b67f82110d672c478c9f0a4" translate="yes" xml:space="preserve">
          <source>Only useful with &lt;code&gt;--objects&lt;/code&gt;; print the object IDs that are not in packs.</source>
          <target state="translated">&lt;code&gt;--objects&lt;/code&gt; でのみ役立ちます。パックに含まれていないオブジェクトIDを出力します。</target>
        </trans-unit>
        <trans-unit id="395c9938b3e2e6eaf4d1417f6499451782d5fa84" translate="yes" xml:space="preserve">
          <source>Only useful with one of the &lt;code&gt;--objects*&lt;/code&gt;; omits objects (usually blobs) from the list of printed objects. The &lt;code&gt;&amp;lt;filter-spec&amp;gt;&lt;/code&gt; may be one of the following:</source>
          <target state="translated">&lt;code&gt;--objects*&lt;/code&gt; いずれかでのみ役立ちます。印刷されたオブジェクトのリストからオブジェクト（通常はblob）を省略します。 &lt;code&gt;&amp;lt;filter-spec&amp;gt;&lt;/code&gt; 以下のいずれかであってもよいです。</target>
        </trans-unit>
        <trans-unit id="c55263ee2e693cf4a68e8c688a3aeedef8c016f1" translate="yes" xml:space="preserve">
          <source>Only valid setting is &quot;--unified=??&quot; or &quot;-u??&quot; to set the number of context lines shown when a unified diff is created. This takes precedence over any &quot;-U&quot; or &quot;--unified&quot; option value passed on the Git diff command line.</source>
          <target state="translated">有効な設定は、&quot;--unified=???&quot; あるいは &quot;-u???&quot; のみです。これは、Git diff コマンドラインで指定した &quot;-U&quot; や &quot;--unified&quot; オプションよりも優先されます。</target>
        </trans-unit>
        <trans-unit id="77fb8a535dafe4973135cbd89eaf06e8f07b4529" translate="yes" xml:space="preserve">
          <source>Only works if the changes (patch IDs based on the diff contents) on &lt;code&gt;subsystem&lt;/code&gt; are literally the same before and after the rebase &lt;code&gt;subsystem&lt;/code&gt; did.</source>
          <target state="translated">&lt;code&gt;subsystem&lt;/code&gt; の変更（diffの内容に基づくパッチID）がリベース &lt;code&gt;subsystem&lt;/code&gt; 前後で文字通り同じである場合にのみ機能します。</target>
        </trans-unit>
        <trans-unit id="5a64b44f8d7042d0b4832141c36a7e5d8d6c4434" translate="yes" xml:space="preserve">
          <source>Oops. That wasn&amp;rsquo;t very readable. It just spit out its own internal version of a &lt;code&gt;diff&lt;/code&gt;, but that internal version really just tells you that it has noticed that &quot;hello&quot; has been modified, and that the old object contents it had have been replaced with something else.</source>
          <target state="translated">おっとっと。それはあまり読みにくいものでした。独自の内部バージョンの &lt;code&gt;diff&lt;/code&gt; を出力するだけですが、その内部バージョンは、「hello」が変更されたこと、および古いオブジェクトの内容が他の何かで置き換えられたことに気づいたことを伝えています。</target>
        </trans-unit>
        <trans-unit id="0e55d62611877e337f8aa065fb0b3d20e9fe0e5a" translate="yes" xml:space="preserve">
          <source>Open a compose window and click the external editor icon.</source>
          <target state="translated">コンポーズウィンドウを開き、外部エディタのアイコンをクリックします。</target>
        </trans-unit>
        <trans-unit id="db4ff8c108e7b94773be0de613a7b629cb1df8fa" translate="yes" xml:space="preserve">
          <source>Open an editor and edit the text to explain what the branch is for, to be used by various other commands (e.g. &lt;code&gt;format-patch&lt;/code&gt;, &lt;code&gt;request-pull&lt;/code&gt;, and &lt;code&gt;merge&lt;/code&gt; (if enabled)). Multi-line explanations may be used.</source>
          <target state="translated">エディターを開き、テキストを編集して、ブランチの目的を説明し、他のさまざまなコマンド（たとえば、 &lt;code&gt;format-patch&lt;/code&gt; 、 &lt;code&gt;request-pull&lt;/code&gt; 、および &lt;code&gt;merge&lt;/code&gt; （有効な場合））で使用します。複数行の説明が使用される場合があります。</target>
        </trans-unit>
        <trans-unit id="577c09c011d74bfddaa145d1c3817d3d9900cb19" translate="yes" xml:space="preserve">
          <source>Open the diff vs. the index in an editor and let the user edit it. After the editor was closed, adjust the hunk headers and apply the patch to the index.</source>
          <target state="translated">エディタでdiff対indexを開き、編集させる。エディタを閉じた後、ハンクヘッダを調整し、インデックスにパッチを適用しました。</target>
        </trans-unit>
        <trans-unit id="1e40bc8b6fc685aae183dd5f07e4256cd3e46abe" translate="yes" xml:space="preserve">
          <source>Open the matching files in the pager (not the output of &lt;code&gt;grep&lt;/code&gt;). If the pager happens to be &quot;less&quot; or &quot;vi&quot;, and the user specified only one pattern, the first file is positioned at the first match automatically. The &lt;code&gt;pager&lt;/code&gt; argument is optional; if specified, it must be stuck to the option without a space. If &lt;code&gt;pager&lt;/code&gt; is unspecified, the default pager will be used (see &lt;code&gt;core.pager&lt;/code&gt; in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">ポケットベルで一致するファイルを開きます（ &lt;code&gt;grep&lt;/code&gt; の出力ではありません）。ページャーがたまたま「少ない」または「vi」で、ユーザーがパターンを1つだけ指定した場合、最初のファイルは最初に一致した位置に自動的に配置されます。 &lt;code&gt;pager&lt;/code&gt; 引数はオプションです。指定する場合は、スペースなしでオプションに固執する必要があります。場合 &lt;code&gt;pager&lt;/code&gt; 指定されていない、デフォルトページャは（参照に使用される &lt;code&gt;core.pager&lt;/code&gt; で&lt;a href=&quot;git-config&quot;&gt;のgit-configと[1] &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="8ab75f225f79420c5b860ca24bd40f7491c784f1" translate="yes" xml:space="preserve">
          <source>Opens an editor to modify the specified config file; either &lt;code&gt;--system&lt;/code&gt;, &lt;code&gt;--global&lt;/code&gt;, or repository (default).</source>
          <target state="translated">エディターを開いて、指定された構成ファイルを変更します。どちらか &lt;code&gt;--system&lt;/code&gt; 、 &lt;code&gt;--global&lt;/code&gt; 、またはリポジトリ（デフォルト）。</target>
        </trans-unit>
        <trans-unit id="869e0439c9b6be4fa4547f64fcc46a677445443d" translate="yes" xml:space="preserve">
          <source>Operate quietly. Implies --no-progress.</source>
          <target state="translated">静かに操作してください。no-progressを意味します。</target>
        </trans-unit>
        <trans-unit id="976297b1ff380abe9b067b3a1569ff64fe97ece7" translate="yes" xml:space="preserve">
          <source>Operate quietly. Progress is not reported to the standard error stream.</source>
          <target state="translated">静かに操作してください。進捗状況は標準エラーストリームには報告されません。</target>
        </trans-unit>
        <trans-unit id="09f22e6b29a644f35840ab8527beed58937c2452" translate="yes" xml:space="preserve">
          <source>Operating modes</source>
          <target state="translated">動作モード</target>
        </trans-unit>
        <trans-unit id="b5ddf3c63568d76ebc23d453be7fdb731eb8db1b" translate="yes" xml:space="preserve">
          <source>Operation Modes</source>
          <target state="translated">操作モード</target>
        </trans-unit>
        <trans-unit id="7196d0b4f156df0cb7286af7737967727f46300d" translate="yes" xml:space="preserve">
          <source>Operation modes</source>
          <target state="translated">操作モード</target>
        </trans-unit>
        <trans-unit id="1bc69d57cbb59ff5bdbc63f455c23bce178e5e54" translate="yes" xml:space="preserve">
          <source>Operations supported</source>
          <target state="translated">対応業務</target>
        </trans-unit>
        <trans-unit id="573db325843d7fd90adea414c1ffec090ab48249" translate="yes" xml:space="preserve">
          <source>Optimize a pack that will be provided to a client with a shallow repository. This option, combined with --thin, can result in a smaller pack at the cost of speed.</source>
          <target state="translated">リポジトリが浅いクライアントに提供されるパックを最適化します。このオプションを --thin と組み合わせることで、速度を犠牲にしてパックを小さくすることができます。</target>
        </trans-unit>
        <trans-unit id="4679da9817f2d593d1926870257534b31ee86cfa" translate="yes" xml:space="preserve">
          <source>Option commands must be the first commands on the input (not counting feature commands), to give an option command after any non-option command is an error.</source>
          <target state="translated">オプションコマンドは入力の最初のコマンドでなければなりません(機能コマンドはカウントされません)。</target>
        </trans-unit>
        <trans-unit id="da44303dd559700c5ce39d2667eb27c2885407ef" translate="yes" xml:space="preserve">
          <source>Optional &amp;lt;path&amp;gt; arguments limit which submodules will be initialized. If no path is specified and submodule.active has been configured, submodules configured to be active will be initialized, otherwise all submodules are initialized.</source>
          <target state="translated">オプションの&amp;lt;path&amp;gt;引数は、初期化されるサブモジュールを制限します。パスが指定されておらず、submodule.activeが構成されている場合、アクティブになるように構成されたサブモジュールが初期化されます。それ以外の場合は、すべてのサブモジュールが初期化されます。</target>
        </trans-unit>
        <trans-unit id="e95e402b64c3c594a37117914c5cb87d814b2b44" translate="yes" xml:space="preserve">
          <source>Optional modifiers can be provided in the beginning of the value to filter commands for specific actions: create (a), modify (m), delete (d). A &lt;code&gt;!&lt;/code&gt; can be included in the modifiers to negate the reference prefix entry. E.g.:</source>
          <target state="translated">値の先頭にオプションの修飾子を指定して、特定のアクション（作成（a）、変更（m）、削除（d））のコマンドをフィルター処理できます。A &lt;code&gt;!&lt;/code&gt; 修飾子に含めて、参照プレフィックスエントリを無効にすることができます。例えば：</target>
        </trans-unit>
        <trans-unit id="be215efb6b35fec1e17ea79655a45bba1595ca40" translate="yes" xml:space="preserve">
          <source>Optionally a new branch could be created with either &lt;code&gt;-c&lt;/code&gt;, &lt;code&gt;-C&lt;/code&gt;, automatically from a remote branch of same name (see &lt;code&gt;--guess&lt;/code&gt;), or detach the working tree from any branch with &lt;code&gt;--detach&lt;/code&gt;, along with switching.</source>
          <target state="translated">必要に応じて新しいブランチのいずれかを使用して作成することができ &lt;code&gt;-c&lt;/code&gt; 、 &lt;code&gt;-C&lt;/code&gt; （参照自動的に同じ名前のリモートブランチから、 &lt;code&gt;--guess&lt;/code&gt; ）、またはを持つ任意の枝から作業ツリーを切り離し &lt;code&gt;--detach&lt;/code&gt; 、スイッチングと一緒に。</target>
        </trans-unit>
        <trans-unit id="d773dc6382eb3328de30b1c7224e0be840082992" translate="yes" xml:space="preserve">
          <source>Optionally may output a &lt;code&gt;lock &amp;lt;file&amp;gt;&lt;/code&gt; line indicating the full path of a file under &lt;code&gt;$GIT_DIR/objects/pack&lt;/code&gt; which is keeping a pack until refs can be suitably updated. The path must end with &lt;code&gt;.keep&lt;/code&gt;. This is a mechanism to name a &amp;lt;pack,idx,keep&amp;gt; tuple by giving only the keep component. The kept pack will not be deleted by a concurrent repack, even though its objects may not be referenced until the fetch completes. The &lt;code&gt;.keep&lt;/code&gt; file will be deleted at the conclusion of the fetch.</source>
          <target state="translated">オプションで、refが適切に更新されるまで &lt;code&gt;$GIT_DIR/objects/pack&lt;/code&gt; を保持している$ GIT_DIR / objects / packの下のファイルの完全パスを示す &lt;code&gt;lock &amp;lt;file&amp;gt;&lt;/code&gt; 行を出力できます。パスは &lt;code&gt;.keep&lt;/code&gt; で終わる必要があります。これは、keepコンポーネントのみを指定して&amp;lt;pack、idx、keep&amp;gt;タプルに名前を付けるメカニズムです。保存されたパックは、フェッチが完了するまでオブジェクトが参照されない場合でも、同時再パックによって削除されません。 &lt;code&gt;.keep&lt;/code&gt; ファイルは、フェッチの終了時に削除されます。</target>
        </trans-unit>
        <trans-unit id="66770b44a484bf62b3beb74f057263164da82747" translate="yes" xml:space="preserve">
          <source>Optionally with -m:</source>
          <target state="translated">オプションで-mを使用します。</target>
        </trans-unit>
        <trans-unit id="3e5a4f0fcbf7c88862ec022584d8faedebb202bf" translate="yes" xml:space="preserve">
          <source>Optionally, a &amp;lt;ref&amp;gt; parameter can be prefixed with a plus &lt;code&gt;+&lt;/code&gt; sign to disable the fast-forward check only on that ref.</source>
          <target state="translated">必要に応じて、&amp;lt;ref&amp;gt;パラメータの前にプラス &lt;code&gt;+&lt;/code&gt; 記号を付けて、その参照でのみ早送りチェックを無効にすることができます。</target>
        </trans-unit>
        <trans-unit id="5ad18880dec3737f40f1be35d71296de89bc6175" translate="yes" xml:space="preserve">
          <source>Optionally, it can merge a tree into the index, perform a fast-forward (i.e. 2-way) merge, or a 3-way merge, with the &lt;code&gt;-m&lt;/code&gt; flag. When used with &lt;code&gt;-m&lt;/code&gt;, the &lt;code&gt;-u&lt;/code&gt; flag causes it to also update the files in the work tree with the result of the merge.</source>
          <target state="translated">オプションで、 &lt;code&gt;-m&lt;/code&gt; フラグを使用して、ツリーを索引にマージし、早送り（つまり、2方向）マージ、または3方向マージを実行できます。 &lt;code&gt;-m&lt;/code&gt; と一緒に使用すると、 &lt;code&gt;-u&lt;/code&gt; フラグは、マージの結果で作業ツリー内のファイルも更新します。</target>
        </trans-unit>
        <trans-unit id="6bf5da9c080bee3a8142586c412aa39971137eee" translate="yes" xml:space="preserve">
          <source>Options</source>
          <target state="translated">Options</target>
        </trans-unit>
        <trans-unit id="c844411e7897e1475e2bbc7e1cd47d6ca3b70b75" translate="yes" xml:space="preserve">
          <source>Options for --parseopt</source>
          <target state="translated">parseopt のオプション</target>
        </trans-unit>
        <trans-unit id="9c25d7f1531501faea711b1933ac2734dd8f1324" translate="yes" xml:space="preserve">
          <source>Options for &lt;code&gt;delete&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;delete&lt;/code&gt; オプション</target>
        </trans-unit>
        <trans-unit id="7eec6c07b2d8ff28d282e8d3918c0430dfd638ff" translate="yes" xml:space="preserve">
          <source>Options for &lt;code&gt;expire&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;expire&lt;/code&gt; オプション</target>
        </trans-unit>
        <trans-unit id="e73b9df34672d383e318c543fe1ed5467baa2316" translate="yes" xml:space="preserve">
          <source>Options for &lt;code&gt;show&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;show&lt;/code&gt; オプション</target>
        </trans-unit>
        <trans-unit id="fcc02e852676cd8c1162b2b42e5759f86fcae990" translate="yes" xml:space="preserve">
          <source>Options for Files</source>
          <target state="translated">ファイルのオプション</target>
        </trans-unit>
        <trans-unit id="fd6ce8b428a235dff74127968e45c8e950a3e68b" translate="yes" xml:space="preserve">
          <source>Options for Filtering</source>
          <target state="translated">フィルタリングのオプション</target>
        </trans-unit>
        <trans-unit id="f0e43560a9524e814096613f5d3adbb780ab9547" translate="yes" xml:space="preserve">
          <source>Options for Frontends</source>
          <target state="translated">フロントエンドのオプション</target>
        </trans-unit>
        <trans-unit id="6de07b5e7d3355f1ee784587e4e9b9310ce89167" translate="yes" xml:space="preserve">
          <source>Options for Objects</source>
          <target state="translated">オブジェクトのオプション</target>
        </trans-unit>
        <trans-unit id="7bba8ce1354b61b02f672f2468b0b0f0c600077c" translate="yes" xml:space="preserve">
          <source>Options for Output</source>
          <target state="translated">出力のオプション</target>
        </trans-unit>
        <trans-unit id="b8bceb2d83c081f4f5d71559b2d0f07edc9ee034" translate="yes" xml:space="preserve">
          <source>Options for a credential context can be configured either in &lt;code&gt;credential.*&lt;/code&gt; (which applies to all credentials), or &lt;code&gt;credential.&amp;lt;url&amp;gt;.*&lt;/code&gt;, where &amp;lt;url&amp;gt; matches the context as described above.</source>
          <target state="translated">資格情報コンテキストのオプションは、credential &lt;code&gt;credential.*&lt;/code&gt; （すべての資格情報に適用されます）または &lt;code&gt;credential.&amp;lt;url&amp;gt;.*&lt;/code&gt; いずれかで構成できます。ここで、&amp;lt;url&amp;gt;は上記のコンテキストと一致します。</target>
        </trans-unit>
        <trans-unit id="99e5139a65bfab6cb84777a431cb5c7403976793" translate="yes" xml:space="preserve">
          <source>Options related to fetching</source>
          <target state="translated">フェッチに関連するオプション</target>
        </trans-unit>
        <trans-unit id="d96532d12a36cc4bb8cc0dcd0b87def47cb21823" translate="yes" xml:space="preserve">
          <source>Options related to merging</source>
          <target state="translated">合併に関連するオプション</target>
        </trans-unit>
        <trans-unit id="d2ce95980d5d4dcb8790725834688357cc504679" translate="yes" xml:space="preserve">
          <source>Options with long option names can be negated by prefixing &lt;code&gt;--no-&lt;/code&gt;. For example, &lt;code&gt;git branch&lt;/code&gt; has the option &lt;code&gt;--track&lt;/code&gt; which is &lt;code&gt;on&lt;/code&gt; by default. You can use &lt;code&gt;--no-track&lt;/code&gt; to override that behaviour. The same goes for &lt;code&gt;--color&lt;/code&gt; and &lt;code&gt;--no-color&lt;/code&gt;.</source>
          <target state="translated">長いオプション名を持つオプションは、接頭辞 &lt;code&gt;--no-&lt;/code&gt; を付けることで無効にできます。たとえば、 &lt;code&gt;git branch&lt;/code&gt; は &lt;code&gt;--track&lt;/code&gt; オプションがあり、デフォルトで &lt;code&gt;on&lt;/code&gt; ています。 &lt;code&gt;--no-track&lt;/code&gt; を使用して、その動作をオーバーライドできます。 &lt;code&gt;--color&lt;/code&gt; と &lt;code&gt;--no-color&lt;/code&gt; についても同様です。</target>
        </trans-unit>
        <trans-unit id="28e5f716aa8e690cf7323a0d5515626aac785807" translate="yes" xml:space="preserve">
          <source>Or if you are looking for the commit that fixed a bug, you might use</source>
          <target state="translated">また、バグを修正したコミットを探している場合は</target>
        </trans-unit>
        <trans-unit id="9bcee5b07c3eb51996fe06466cb572259d48e74e" translate="yes" xml:space="preserve">
          <source>Or if you want more control, you can inspect the current state using for example &quot;git bisect visualize&quot;. It will launch gitk (or &quot;git log&quot; if the &lt;code&gt;DISPLAY&lt;/code&gt; environment variable is not set) to help you find a better bisection point.</source>
          <target state="translated">または、より詳細な制御が必要な場合は、たとえば「git bisect visualize」を使用して現在の状態を検査できます。gitk（または &lt;code&gt;DISPLAY&lt;/code&gt; 環境変数が設定されていない場合は「git log」）を起動して、より適切な二分点を見つけるのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="ee046ba1657a42f0c8096ff30555d679415a486a" translate="yes" xml:space="preserve">
          <source>Or you could recall that the &lt;code&gt;&amp;hellip;​&lt;/code&gt; operator selects all commits reachable from either one reference or the other but not both; so</source>
          <target state="translated">それとも、ことを思い出すことができ &lt;code&gt;&amp;hellip;​&lt;/code&gt; オペレータが一つの基準や他のではなく、両方のいずれかから到達可能なすべてのコミットを選択します。そう</target>
        </trans-unit>
        <trans-unit id="9af1a9bbcb80d3a49080e3a67d92d5ab7f0cace1" translate="yes" xml:space="preserve">
          <source>Or you could recall that the &lt;code&gt;...&lt;/code&gt; operator selects all commits reachable from either one reference or the other but not both; so</source>
          <target state="translated">または、 &lt;code&gt;...&lt;/code&gt; 演算子は、どちらか一方の参照から到達可能なすべてのコミットを選択しますが、両方は選択しないことを思い出してください。そう</target>
        </trans-unit>
        <trans-unit id="d85642c3d553b535f4731e23589126805881407c" translate="yes" xml:space="preserve">
          <source>Or, if you&amp;rsquo;ve already committed the merge that you want to throw away,</source>
          <target state="translated">または、破棄したいマージをすでにコミットしている場合は、</target>
        </trans-unit>
        <trans-unit id="7ec7c556c34b1673fc7046a255bf7eb40c6a1622" translate="yes" xml:space="preserve">
          <source>Or, prepare and create the commit in one step:</source>
          <target state="translated">または、コミットの準備と作成をワンステップで行う。</target>
        </trans-unit>
        <trans-unit id="6d9770079506b18bb9154a95e976f54ab47a2b44" translate="yes" xml:space="preserve">
          <source>Ordinary changed entries have the following format:</source>
          <target state="translated">通常の変更されたエントリは、以下のような形式になっています。</target>
        </trans-unit>
        <trans-unit id="789d55cf79d409acbcc0305ff19dbfa36d82a93d" translate="yes" xml:space="preserve">
          <source>Ordinary commits are only included if they are !TREESAME (though this can be changed, see &lt;code&gt;--sparse&lt;/code&gt; below).</source>
          <target state="translated">通常のコミットは、！TREESAMEの場合にのみ含まれます（これは変更できますが、以下の &lt;code&gt;--sparse&lt;/code&gt; を参照してください）。</target>
        </trans-unit>
        <trans-unit id="3b945495727bab8a02c63542fdf26a485a2839f4" translate="yes" xml:space="preserve">
          <source>Original (version 1) pack-*.idx files have the following format:</source>
          <target state="translated">オリジナル(バージョン1)のpack-*.idxファイルの形式は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="cd07568ac3f8fe8b9f1ca323e6aea33ce69f4d0c" translate="yes" xml:space="preserve">
          <source>Originally, &lt;code&gt;git svn&lt;/code&gt; recommended that developers pulled or merged from the &lt;code&gt;git svn&lt;/code&gt; branch. This was because the author favored &lt;code&gt;git svn set-tree B&lt;/code&gt; to commit a single head rather than the &lt;code&gt;git svn set-tree A..B&lt;/code&gt; notation to commit multiple commits. Use of &lt;code&gt;git pull&lt;/code&gt; or &lt;code&gt;git merge&lt;/code&gt; with &lt;code&gt;git svn set-tree A..B&lt;/code&gt; will cause non-linear history to be flattened when committing into SVN and this can lead to merge commits unexpectedly reversing previous commits in SVN.</source>
          <target state="translated">元々、 &lt;code&gt;git svn&lt;/code&gt; は、開発者が &lt;code&gt;git svn&lt;/code&gt; ブランチからプルまたはマージすることを推奨していました。これは、複数のコミットをコミットする &lt;code&gt;git svn set-tree A..B&lt;/code&gt; 表記ではなく、 &lt;code&gt;git svn set-tree B&lt;/code&gt; が単一のヘッドをコミットすることを好んだためです。 &lt;code&gt;git pull&lt;/code&gt; または &lt;code&gt;git merge&lt;/code&gt; を &lt;code&gt;git svn set-tree A..B&lt;/code&gt; と一緒に使用すると、SVNにコミットするときに非線形履歴がフラット化され、これによりマージコミットが予期せずSVNの以前のコミットを元に戻す可能性があります。</target>
        </trans-unit>
        <trans-unit id="6e6a6f2086bb5fe5dbfd17d8d5f502d48759834b" translate="yes" xml:space="preserve">
          <source>Other</source>
          <target state="translated">Other</target>
        </trans-unit>
        <trans-unit id="14bc34cb5d8d9f5a1986c4b4ced74a089ed31e83" translate="yes" xml:space="preserve">
          <source>Other &amp;lt;rev&amp;gt;^ Parent Shorthand Notations</source>
          <target state="translated">その他の&amp;lt;rev&amp;gt; ^親の省略表記</target>
        </trans-unit>
        <trans-unit id="a3c040aeed88ddd482d5dec178bd5bb0b940738f" translate="yes" xml:space="preserve">
          <source>Other Items</source>
          <target state="translated">その他の項目</target>
        </trans-unit>
        <trans-unit id="9cb6f2fb01dfa81e12bc1e11f0e7b676e54669fd" translate="yes" xml:space="preserve">
          <source>Other Options</source>
          <target state="translated">その他のオプション</target>
        </trans-unit>
        <trans-unit id="b66b145fc26fc91268f852efc133debcedca1335" translate="yes" xml:space="preserve">
          <source>Other ambiguity resolutions might be added in the future, but for now any other cases will error out with an error indicating what we tried, and depending on the &lt;code&gt;advice.pushUnqualifiedRefname&lt;/code&gt; configuration (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;) suggest what refs/ namespace you may have wanted to push to.</source>
          <target state="translated">その他のあいまいさの解像度は、将来追加されるかもしれないが、今のところそれ以外の場合はエラー、我々がしようとしたものを示す、とに依存してエラーになります &lt;code&gt;advice.pushUnqualifiedRefname&lt;/code&gt; の設定（参照&lt;a href=&quot;git-config&quot;&gt;[1]のgit-config設定を&lt;/a&gt;）何レフリー/名前空間を提案しますプッシュしたかったかもしれません。</target>
        </trans-unit>
        <trans-unit id="0d7c9916d5a97cfdd8b058afc3d1bac1c0a81b1f" translate="yes" xml:space="preserve">
          <source>Other arbitrary characters can also be encoded. For instance, &lt;code&gt;combine:tree:3+blob:none&lt;/code&gt; and &lt;code&gt;combine:tree%3A3+blob%3Anone&lt;/code&gt; are equivalent.</source>
          <target state="translated">他の任意の文字もエンコードできます。たとえば、 &lt;code&gt;combine:tree:3+blob:none&lt;/code&gt; と &lt;code&gt;combine:tree%3A3+blob%3Anone&lt;/code&gt; は同等です。</target>
        </trans-unit>
        <trans-unit id="fca088ce123c6c3692799642c2a4b46b5050ca1e" translate="yes" xml:space="preserve">
          <source>Other consecutive asterisks are considered invalid.</source>
          <target state="translated">それ以外の連続したアスタリスクは無効です。</target>
        </trans-unit>
        <trans-unit id="060f4f2bc2ee9b99f69af6360a0055db64443a39" translate="yes" xml:space="preserve">
          <source>Other consecutive asterisks are considered regular asterisks and will match according to the previous rules.</source>
          <target state="translated">その他の連続したアスタリスクは通常のアスタリスクとみなされ、前のルールに従ってマッチします。</target>
        </trans-unit>
        <trans-unit id="3c7b99f717eee9f16429ca9a79551f060c8f8236" translate="yes" xml:space="preserve">
          <source>Other diff formats</source>
          <target state="translated">その他の差分フォーマット</target>
        </trans-unit>
        <trans-unit id="81458045196e38ce4846b13cecf95d14abe58433" translate="yes" xml:space="preserve">
          <source>Other git-related tools may and do use their own variables. When inventing new variables for use in your own tool, make sure their names do not conflict with those that are used by Git itself and other popular tools, and describe them in your documentation.</source>
          <target state="translated">git 関連の他のツールでは、独自の変数を使用している場合もありますし、使用している場合もあります。独自のツールで使用するために新しい変数を作成する場合は、その名前が Git 自体や他の一般的なツールで使用されているものと衝突しないように注意し、ドキュメントに記述します。</target>
        </trans-unit>
        <trans-unit id="97855915001e4fe7ef5deb1c023c4697931e633c" translate="yes" xml:space="preserve">
          <source>Other options are available to control how the manual page is displayed. See &lt;a href=&quot;git-help&quot;&gt;git-help[1]&lt;/a&gt; for more information, because &lt;code&gt;git --help ...&lt;/code&gt; is converted internally into &lt;code&gt;git
help ...&lt;/code&gt;.</source>
          <target state="translated">マニュアルページの表示方法を制御する他のオプションが利用可能です。参照してください&lt;a href=&quot;git-help&quot;&gt;gitのヘルプ[1]&lt;/a&gt;ので、より多くの情報のために &lt;code&gt;git --help ...&lt;/code&gt; に内部的に変換され、 &lt;code&gt;git help ...&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e9c8373137a028157f66c53c01b431d29c570146" translate="yes" xml:space="preserve">
          <source>Other tools</source>
          <target state="translated">その他のツール</target>
        </trans-unit>
        <trans-unit id="89cbbb5c1b80969d7050a561dcd36c87c0241792" translate="yes" xml:space="preserve">
          <source>Other tools to fight regressions</source>
          <target state="translated">その他の退行対策ツール</target>
        </trans-unit>
        <trans-unit id="15219db000aadb43433107a930098d54a12a2bf5" translate="yes" xml:space="preserve">
          <source>Other types of dangling objects (blobs and trees) are also possible, and dangling objects can arise in other situations.</source>
          <target state="translated">他の種類のぶら下がり物(ブロブや木)も可能で、他の状況でもぶら下がり物が発生することがあります。</target>
        </trans-unit>
        <trans-unit id="a8ad1c87f168347a129392343ff35eecf4e32d0a" translate="yes" xml:space="preserve">
          <source>Other variables</source>
          <target state="translated">その他の変数</target>
        </trans-unit>
        <trans-unit id="dd705eff4c453915d022538452adca45ea549424" translate="yes" xml:space="preserve">
          <source>Other ways</source>
          <target state="translated">その他の方法</target>
        </trans-unit>
        <trans-unit id="cf96d288cbee7ebb53d0ff80a9f63e5beaf8b0b4" translate="yes" xml:space="preserve">
          <source>Otherwise the remote branch of the first refspec is merged.</source>
          <target state="translated">それ以外の場合は、最初の refspec のリモートブランチがマージされます。</target>
        </trans-unit>
        <trans-unit id="32a9647b920b895ad400011726c72473bb775600" translate="yes" xml:space="preserve">
          <source>Otherwise, a tag reference that points directly at the given object (i.e., a lightweight tag) is created.</source>
          <target state="translated">そうでない場合は、与えられたオブジェクトを直接指すタグ参照(つまり軽量タグ)が作成されます。</target>
        </trans-unit>
        <trans-unit id="4b4eb603a71c26301f006805965a2bb224fe1a8d" translate="yes" xml:space="preserve">
          <source>Otherwise, all you need to do is start &lt;a href=&quot;git-daemon&quot;&gt;git-daemon[1]&lt;/a&gt;; it will listen on port 9418. By default, it will allow access to any directory that looks like a Git directory and contains the magic file git-daemon-export-ok. Passing some directory paths as &lt;code&gt;git daemon&lt;/code&gt; arguments will further restrict the exports to those paths.</source>
          <target state="translated">それ以外の場合は、&lt;a href=&quot;git-daemon&quot;&gt;git-daemon [1]を&lt;/a&gt;起動するだけです。ポート9418でリッスンします。デフォルトでは、Gitディレクトリのように見え、マジックファイルgit-daemon-export-okが含まれているすべてのディレクトリへのアクセスが許可されます。 &lt;code&gt;git daemon&lt;/code&gt; 引数として一部のディレクトリパスを渡すと、それらのパスへのエクスポートがさらに制限されます。</target>
        </trans-unit>
        <trans-unit id="83933e66c19657c277855328b7212d55be330b69" translate="yes" xml:space="preserve">
          <source>Otherwise, if the &lt;code&gt;SSH_ASKPASS&lt;/code&gt; environment variable is set, its value is used as above.</source>
          <target state="translated">それ以外の場合、 &lt;code&gt;SSH_ASKPASS&lt;/code&gt; 環境変数が設定されていれば、その値が上記のように使用されます。</target>
        </trans-unit>
        <trans-unit id="06aca3f538987dd4baec5bd30c2c8ddce8b7736e" translate="yes" xml:space="preserve">
          <source>Otherwise, if the &lt;code&gt;core.askPass&lt;/code&gt; configuration variable is set, its value is used as above.</source>
          <target state="translated">それ以外の場合、 &lt;code&gt;core.askPass&lt;/code&gt; 構成変数が設定されていれば、その値が上記のように使用されます。</target>
        </trans-unit>
        <trans-unit id="3a26962584221262caf565e9653ff026d1f2d21a" translate="yes" xml:space="preserve">
          <source>Otherwise, if the helper string begins with an absolute path, the verbatim helper string becomes the command.</source>
          <target state="translated">そうでなければ、ヘルパー文字列が絶対パスで始まる場合は、そのヘルパー文字列がコマンドになります。</target>
        </trans-unit>
        <trans-unit id="4215362e197715214628992e14b639b7a98dbd7a" translate="yes" xml:space="preserve">
          <source>Otherwise, show the index format.</source>
          <target state="translated">それ以外の場合は、インデックス形式を表示します。</target>
        </trans-unit>
        <trans-unit id="1bddd3a0b4a752779f115c3518d3c2b277475b51" translate="yes" xml:space="preserve">
          <source>Otherwise, success is indicated the Unix way, i.e. by simply exiting with a zero exit status.</source>
          <target state="translated">それ以外の場合は、Unix の方法、つまり単にゼロの終了ステータスで終了することで成功を示します。</target>
        </trans-unit>
        <trans-unit id="adf9fb3bc458cf17571d90a6a9fffeaa1b715a6a" translate="yes" xml:space="preserve">
          <source>Otherwise, the merge proceeds in the usual way.</source>
          <target state="translated">それ以外の場合は、通常の方法でマージが行われます。</target>
        </trans-unit>
        <trans-unit id="682c927c4310cf70e63b7011c8ec332cb5444742" translate="yes" xml:space="preserve">
          <source>Otherwise, the string &quot;git credential-&quot; is prepended to the helper string, and the result becomes the command.</source>
          <target state="translated">そうでない場合は、ヘルパー文字列の前に &quot;git credential-&quot; という文字列が付加され、結果がコマンドになります。</target>
        </trans-unit>
        <trans-unit id="0d438a86f2545e54eff98d96612fdf5bccb833ed" translate="yes" xml:space="preserve">
          <source>Otherwise, the topic that was merged to suddenly contains more than a single (well-separated) change. The many resulting small merges will greatly clutter up history. Anyone who later investigates the history of a file will have to find out whether that merge affected the topic in development. An upstream might even inadvertently be merged into a &quot;more stable&quot; branch. And so on.</source>
          <target state="translated">そうでなければ、突然マージされたトピックには、単一の (よく分離された)変更以上のものが含まれています。結果として生じる多くの小さなマージは、履歴を大きく乱雑にしてしまいます。後でファイルの履歴を調査する人は、そのマージが開発中のトピックに影響を与えたかどうかを調べる必要があります。上流のブランチがうっかり「より安定した」ブランチにマージされてしまうこともあるかもしれません。このようなこともあります。</target>
        </trans-unit>
        <trans-unit id="9aea25a9a0905a830a51359c1723b329df787dff" translate="yes" xml:space="preserve">
          <source>Otherwise, the user is prompted on the terminal.</source>
          <target state="translated">それ以外の場合は、端末上でプロンプトが表示されます。</target>
        </trans-unit>
        <trans-unit id="38c6fc8779b3b84c1e5bc6184edd3674dd536e89" translate="yes" xml:space="preserve">
          <source>Otherwise, this command applies the arguments passed using the &lt;code&gt;--trailer&lt;/code&gt; option, if any, to the commit message part of each input file. The result is emitted on the standard output.</source>
          <target state="translated">それ以外の場合、このコマンドは &lt;code&gt;--trailer&lt;/code&gt; オプションを使用して渡された引数があれば、それを各入力ファイルのコミットメッセージ部分に適用します。結果は標準出力に出力されます。</target>
        </trans-unit>
        <trans-unit id="7befa93bf7555efa6c53836dd2ebb58604474c19" translate="yes" xml:space="preserve">
          <source>Otherwise, you need more information. How do you tell which version of the file has been lost?</source>
          <target state="translated">そうでない場合は、より多くの情報が必要です。どのバージョンのファイルが失われたか、どのようにして見分けることができますか?</target>
        </trans-unit>
        <trans-unit id="4bed336194a9a5c86b6a734f03b3570d2aae1a68" translate="yes" xml:space="preserve">
          <source>Output</source>
          <target state="translated">Output</target>
        </trans-unit>
        <trans-unit id="bfba9983f4010a4e13ddf1f4da6c4d9462a74630" translate="yes" xml:space="preserve">
          <source>Output &quot;connectivity-ok&quot; if the received pack is self-contained and connected.</source>
          <target state="translated">受信したパックが自己完結して接続されている場合は「connectivity-ok」を出力します。</target>
        </trans-unit>
        <trans-unit id="14d787baf83270b720015688dc1b0d825f139765" translate="yes" xml:space="preserve">
          <source>Output \0 instead of the character that normally follows a file name.</source>
          <target state="translated">ファイル名の後に続く文字の代わりに、「0」を出力します。</target>
        </trans-unit>
        <trans-unit id="02b83bf95635a4c88bd0634054e0b05541ae55d4" translate="yes" xml:space="preserve">
          <source>Output a condensed summary of extended header information such as creations, renames and mode changes.</source>
          <target state="translated">作成、リネーム、モード変更などの拡張ヘッダ情報の要約を出力します。</target>
        </trans-unit>
        <trans-unit id="6dbea2796f7c2da05dc872fbc20cb3b286f106fd" translate="yes" xml:space="preserve">
          <source>Output a condensed summary of extended header information such as file creations or deletions (&quot;new&quot; or &quot;gone&quot;, optionally &quot;+l&quot; if it&amp;rsquo;s a symlink) and mode changes (&quot;+x&quot; or &quot;-x&quot; for adding or removing executable bit respectively) in diffstat. The information is put between the filename part and the graph part. Implies &lt;code&gt;--stat&lt;/code&gt;.</source>
          <target state="translated">ファイルの作成または削除（「新規」または「削除」、オプションでシンボリックリンクの場合は「+ l」）およびモード変更（「+ x」または「-x」で追加または削除）などの拡張ヘッダー情報の要約を出力しますdiffstatの実行可能ビット）。情報は、ファイル名部分とグラフ部分の間に置かれます。意味 &lt;code&gt;--stat&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="86b8e4f6e5044ecf1fc221aacfd89b826aa45a4b" translate="yes" xml:space="preserve">
          <source>Output all merge bases for the commits, instead of just one.</source>
          <target state="translated">コミットのすべてのマージベースを出力します。</target>
        </trans-unit>
        <trans-unit id="c4fd496863f1ea4adcfb9e1e5209189d8bcbae5b" translate="yes" xml:space="preserve">
          <source>Output an all-zero hash in each patch&amp;rsquo;s From header instead of the hash of the commit.</source>
          <target state="translated">コミットのハッシュではなく、各パッチのFromヘッダーにすべてゼロのハッシュを出力します。</target>
        </trans-unit>
        <trans-unit id="646a42919af7ad3c76023f798af12df793449561" translate="yes" xml:space="preserve">
          <source>Output diff in reverse.</source>
          <target state="translated">出力差分を逆にしています。</target>
        </trans-unit>
        <trans-unit id="973b33dc2cc053fd8a3739d3b278f90232b34e64" translate="yes" xml:space="preserve">
          <source>Output excluded boundary commits. Boundary commits are prefixed with &lt;code&gt;-&lt;/code&gt;.</source>
          <target state="translated">除外された境界コミットを出力します。境界コミットには接頭辞 &lt;code&gt;-&lt;/code&gt; が付きます。</target>
        </trans-unit>
        <trans-unit id="c3872ebaf63738dccf26222059fb06a34ea9a53d" translate="yes" xml:space="preserve">
          <source>Output file names will be a simple number sequence without the default first line of the commit appended.</source>
          <target state="translated">出力ファイル名は、コミットのデフォルトの最初の行を付加しない単純な数字のシーケンスになります。</target>
        </trans-unit>
        <trans-unit id="c03f08a8f205e4568e916e3cfaa50c6a48749706" translate="yes" xml:space="preserve">
          <source>Output format</source>
          <target state="translated">出力形式</target>
        </trans-unit>
        <trans-unit id="d018168db6adc860beb206930bf9272bcf4432cb" translate="yes" xml:space="preserve">
          <source>Output from &lt;code&gt;git describe&lt;/code&gt;; i.e. a closest tag, optionally followed by a dash and a number of commits, followed by a dash, a &lt;code&gt;g&lt;/code&gt;, and an abbreviated object name.</source>
          <target state="translated">&lt;code&gt;git describe&lt;/code&gt; からの出力。つまり、最も近いタグで、オプションでダッシュといくつかのコミットが続き、その後にダッシュ、 &lt;code&gt;g&lt;/code&gt; 、および省略されたオブジェクト名が続きます。</target>
        </trans-unit>
        <trans-unit id="57be6fd315ed7958a6a11b416634cb9af54c1202" translate="yes" xml:space="preserve">
          <source>Output information on each ref</source>
          <target state="translated">各レフの出力情報</target>
        </trans-unit>
        <trans-unit id="a471d58e2fcbf4f373e5dd800df97d7ecddc4b2a" translate="yes" xml:space="preserve">
          <source>Output only the last line of the &lt;code&gt;--stat&lt;/code&gt; format containing total number of modified files, as well as number of added and deleted lines.</source>
          <target state="translated">変更されたファイルの総数と追加および削除された行の数を含む &lt;code&gt;--stat&lt;/code&gt; 形式の最後の行のみを出力します。</target>
        </trans-unit>
        <trans-unit id="09afa8b7712ce7db5d67e850045b13df59d4e1ae" translate="yes" xml:space="preserve">
          <source>Output only the names of config variables for &lt;code&gt;--list&lt;/code&gt; or &lt;code&gt;--get-regexp&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--list&lt;/code&gt; または &lt;code&gt;--get-regexp&lt;/code&gt; の設定変数の名前のみを出力します。</target>
        </trans-unit>
        <trans-unit id="86aa1f4dbf3c69df52c4dcdcb3513ddaac888349" translate="yes" xml:space="preserve">
          <source>Output only the trailers, not any other parts of the input.</source>
          <target state="translated">入力の他の部分は出力せず、トレーラのみを出力します。</target>
        </trans-unit>
        <trans-unit id="db37f07e7f23e51cc792b3b6ff625f7fbb6a099c" translate="yes" xml:space="preserve">
          <source>Output only trailers that exist in the input; do not add any from the command-line or by following configured &lt;code&gt;trailer.*&lt;/code&gt; rules.</source>
          <target state="translated">入力に存在するトレーラーのみを出力します。コマンドラインから、または構成された &lt;code&gt;trailer.*&lt;/code&gt; ルールに従って追加しないでください。</target>
        </trans-unit>
        <trans-unit id="9f94a54620a30e7ce03e12a657369e604dddd0ea" translate="yes" xml:space="preserve">
          <source>Output stability</source>
          <target state="translated">出力安定性</target>
        </trans-unit>
        <trans-unit id="eec068e91917644b4f85137aa6730536687188c8" translate="yes" xml:space="preserve">
          <source>Output the commits chosen to be shown (see Commit Limiting section above) in reverse order. Cannot be combined with &lt;code&gt;--walk-reflogs&lt;/code&gt;.</source>
          <target state="translated">表示するように選択されたコミット（上記のコミット制限のセクションを参照）を逆の順序で出力します。 &lt;code&gt;--walk-reflogs&lt;/code&gt; と組み合わせることはできません。</target>
        </trans-unit>
        <trans-unit id="b5f16fa854dad4b03b2649c62b3407ce506ca41f" translate="yes" xml:space="preserve">
          <source>Output the distribution of relative amount of changes for each sub-directory. The behavior of &lt;code&gt;--dirstat&lt;/code&gt; can be customized by passing it a comma separated list of parameters. The defaults are controlled by the &lt;code&gt;diff.dirstat&lt;/code&gt; configuration variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). The following parameters are available:</source>
          <target state="translated">各サブディレクトリの相対的な変更量の分布を出力します。 &lt;code&gt;--dirstat&lt;/code&gt; の動作は、パラメーターのコンマ区切りリストを渡すことでカスタマイズできます。デフォルトは、 &lt;code&gt;diff.dirstat&lt;/code&gt; 構成変数によって制御されます（&lt;a href=&quot;git-config&quot;&gt;git-config [1]を&lt;/a&gt;参照）。次のパラメータを使用できます。</target>
        </trans-unit>
        <trans-unit id="f44ba9d91e7de35dadf965ce7b9f83b740777703" translate="yes" xml:space="preserve">
          <source>Output to a specific file instead of stdout.</source>
          <target state="translated">stdoutの代わりに特定のファイルに出力します。</target>
        </trans-unit>
        <trans-unit id="1374322e99ee5a882a272ee284ec9ea86e209683" translate="yes" xml:space="preserve">
          <source>Output uses the same format as &lt;code&gt;git cat-file --batch&lt;/code&gt;:</source>
          <target state="translated">出力は &lt;code&gt;git cat-file --batch&lt;/code&gt; と同じ形式を使用します。</target>
        </trans-unit>
        <trans-unit id="50880c18d623e2367f83a87791b3da910b72fa81" translate="yes" xml:space="preserve">
          <source>Output uses the same format as &lt;code&gt;git ls-tree &amp;lt;tree&amp;gt; -- &amp;lt;path&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">出力は &lt;code&gt;git ls-tree &amp;lt;tree&amp;gt; -- &amp;lt;path&amp;gt;&lt;/code&gt; と同じ形式を使用します：</target>
        </trans-unit>
        <trans-unit id="12aec147318e848c7d54969418eb1ab7603e65c0" translate="yes" xml:space="preserve">
          <source>Outputs some statistics to stderr. Has a small performance penalty.</source>
          <target state="translated">いくつかの統計情報を標準エラーに出力します。パフォーマンスに若干のペナルティがあります。</target>
        </trans-unit>
        <trans-unit id="bb044abda9deb6fdc3e0634ed0f85ce258bcc5dc" translate="yes" xml:space="preserve">
          <source>Outputs the SHA1 of every commit in &lt;code&gt;&amp;lt;limit&amp;gt;..&amp;lt;head&amp;gt;&lt;/code&gt;, prefixed with &lt;code&gt;-&lt;/code&gt; for commits that have an equivalent in &amp;lt;upstream&amp;gt;, and &lt;code&gt;+&lt;/code&gt; for commits that do not.</source>
          <target state="translated">&lt;code&gt;&amp;lt;limit&amp;gt;..&amp;lt;head&amp;gt;&lt;/code&gt; 内のすべてのコミットのSHA1を出力します。 &amp;lt;upstream&amp;gt;に対応するコミットがある場合は &lt;code&gt;-&lt;/code&gt; を、ない場合は &lt;code&gt;+&lt;/code&gt; を前に付けて出力します。</target>
        </trans-unit>
        <trans-unit id="27115802f1c296a1dfb4ce768084e3e086e70c8c" translate="yes" xml:space="preserve">
          <source>Override &lt;code&gt;tag.gpgSign&lt;/code&gt; configuration variable that is set to force each and every tag to be signed.</source>
          <target state="translated">すべてのタグに強制的に署名するように設定されている &lt;code&gt;tag.gpgSign&lt;/code&gt; 構成変数をオーバーライドします。</target>
        </trans-unit>
        <trans-unit id="f98c38feba04de33a87daf02cddb4bc0af45f925" translate="yes" xml:space="preserve">
          <source>Override earlier --rebase.</source>
          <target state="translated">以前の --rebase をオーバーライドします。</target>
        </trans-unit>
        <trans-unit id="bf7cdfd38925dba890e8c6c44d76b710ca912a26" translate="yes" xml:space="preserve">
          <source>Override the HTTP proxy, normally configured using the &lt;code&gt;http_proxy&lt;/code&gt;, &lt;code&gt;https_proxy&lt;/code&gt;, and &lt;code&gt;all_proxy&lt;/code&gt; environment variables (see &lt;code&gt;curl(1)&lt;/code&gt;). In addition to the syntax understood by curl, it is possible to specify a proxy string with a user name but no password, in which case git will attempt to acquire one in the same way it does for other credentials. See &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials[7]&lt;/a&gt; for more information. The syntax thus is &lt;code&gt;[protocol://][user[:password]@]proxyhost[:port]&lt;/code&gt;. This can be overridden on a per-remote basis; see remote.&amp;lt;name&amp;gt;.proxy</source>
          <target state="translated">通常は &lt;code&gt;http_proxy&lt;/code&gt; 、 &lt;code&gt;https_proxy&lt;/code&gt; 、および &lt;code&gt;all_proxy&lt;/code&gt; 環境変数を使用して構成されたHTTPプロキシーをオーバーライドします（ &lt;code&gt;curl(1)&lt;/code&gt; を参照）。curlが理解する構文に加えて、ユーザー名でパスワードなしでプロキシ文字列を指定することができます。その場合、gitは他の資格情報と同じ方法でプロキシ文字列を取得しようとします。詳細については、&lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials [7]&lt;/a&gt;を参照してください。したがって、構文は &lt;code&gt;[protocol://][user[:password]@]proxyhost[:port]&lt;/code&gt; です。これは、リモートごとにオーバーライドできます。remote。&amp;lt;name&amp;gt; .proxyを参照してください</target>
        </trans-unit>
        <trans-unit id="ca2a7d0ade908f47d0a242141742817435033d82" translate="yes" xml:space="preserve">
          <source>Override the author date used in the commit.</source>
          <target state="translated">コミットで使用した作者の日付を上書きします。</target>
        </trans-unit>
        <trans-unit id="afbb46ef37a88110fa3c814b4440b9bab3c588ca" translate="yes" xml:space="preserve">
          <source>Override the commit author. Specify an explicit author using the standard &lt;code&gt;A U Thor &amp;lt;author@example.com&amp;gt;&lt;/code&gt; format. Otherwise &amp;lt;author&amp;gt; is assumed to be a pattern and is used to search for an existing commit by that author (i.e. rev-list --all -i --author=&amp;lt;author&amp;gt;); the commit author is then copied from the first such commit found.</source>
          <target state="translated">コミット作者を上書きします。標準の &lt;code&gt;A U Thor &amp;lt;author@example.com&amp;gt;&lt;/code&gt; 形式を使用して、明示的な作成者を指定します。それ以外の場合、&amp;lt;author&amp;gt;はパターンであると見なされ、その作成者による既存のコミットの検索に使用されます（つまり、rev-list --all -i --author = &amp;lt;author&amp;gt;）。コミットの作成者は、最初に見つかったそのようなコミットからコピーされます。</target>
        </trans-unit>
        <trans-unit id="e3aa6564c96bc2c1fa2d64bc52314ce125c2e1b2" translate="yes" xml:space="preserve">
          <source>Override the default help format used by &lt;a href=&quot;git-help&quot;&gt;git-help[1]&lt;/a&gt;. Values &lt;code&gt;man&lt;/code&gt;, &lt;code&gt;info&lt;/code&gt;, &lt;code&gt;web&lt;/code&gt; and &lt;code&gt;html&lt;/code&gt; are supported. &lt;code&gt;man&lt;/code&gt; is the default. &lt;code&gt;web&lt;/code&gt; and &lt;code&gt;html&lt;/code&gt; are the same.</source>
          <target state="translated">&lt;a href=&quot;git-help&quot;&gt;git-help [1]が&lt;/a&gt;使用するデフォルトのヘルプ形式を上書きします。値 &lt;code&gt;man&lt;/code&gt; 、 &lt;code&gt;info&lt;/code&gt; 、 &lt;code&gt;web&lt;/code&gt; および &lt;code&gt;html&lt;/code&gt; がサポートされています。 &lt;code&gt;man&lt;/code&gt; がデフォルトです。 &lt;code&gt;web&lt;/code&gt; と &lt;code&gt;html&lt;/code&gt; は同じです。</target>
        </trans-unit>
        <trans-unit id="90af133b98db5fc195076e23392ec3cd67c3e89c" translate="yes" xml:space="preserve">
          <source>Override the default tempdir.</source>
          <target state="translated">デフォルトの tempdir を上書きします。</target>
        </trans-unit>
        <trans-unit id="5b51681506c224a8c47f1343a9ecd64433151e38" translate="yes" xml:space="preserve">
          <source>Override the executable bit of the added files. The executable bit is only changed in the index, the files on disk are left unchanged.</source>
          <target state="translated">追加したファイルの実行可能ビットを上書きします。実行可能ビットが変更されるのはインデックスのみで、ディスク上のファイルは変更されません。</target>
        </trans-unit>
        <trans-unit id="2478241e90c06d40d8344e2c734cc9e34ffd0d73" translate="yes" xml:space="preserve">
          <source>Override the path for the given tool that may be used to browse HTML help (see &lt;code&gt;-w&lt;/code&gt; option in &lt;a href=&quot;git-help&quot;&gt;git-help[1]&lt;/a&gt;) or a working repository in gitweb (see &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb[1]&lt;/a&gt;).</source>
          <target state="translated">HTMLヘルプ（&lt;a href=&quot;git-help&quot;&gt;git-help [1]の&lt;/a&gt; &lt;code&gt;-w&lt;/code&gt; オプションを参照）またはgitwebの作業リポジトリ（&lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb [1]を&lt;/a&gt;参照）を参照するために使用できる特定のツールのパスをオーバーライドします。</target>
        </trans-unit>
        <trans-unit id="eeb1b59c781a411c8a2ade9041a0a224d6888a83" translate="yes" xml:space="preserve">
          <source>Override the path for the given tool that may be used to display help in the &lt;code&gt;man&lt;/code&gt; format. See &lt;a href=&quot;git-help&quot;&gt;git-help[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;man&lt;/code&gt; 形式でヘルプを表示するために使用できる特定のツールのパスをオーバーライドします。&lt;a href=&quot;git-help&quot;&gt;git-help [1]を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="adf75a51b2ad5d1ae80303fa7c85676af23cae71" translate="yes" xml:space="preserve">
          <source>Override the path for the given tool. This is useful in case your tool is not in the PATH.</source>
          <target state="translated">与えられたツールのパスを上書きします。これは、ツールがPATHにない場合に便利です。</target>
        </trans-unit>
        <trans-unit id="d7b3947bcc6a75423b4dad1a16da833c821be77f" translate="yes" xml:space="preserve">
          <source>Override the up-to-date check.</source>
          <target state="translated">最新のチェックを上書きします。</target>
        </trans-unit>
        <trans-unit id="4f22a960f4dfa712696d5fbbb0afb1a8a1360ea3" translate="yes" xml:space="preserve">
          <source>Overrides a previous &lt;code&gt;--no-walk&lt;/code&gt;.</source>
          <target state="translated">以前の &lt;code&gt;--no-walk&lt;/code&gt; を上書きします。</target>
        </trans-unit>
        <trans-unit id="dcd0bd07179d4dab7adf6735a6d8e2d1ef6bb9e3" translate="yes" xml:space="preserve">
          <source>Overwrite the contents of the files that match the pathspec. When the &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; (most often a commit) is not given, overwrite working tree with the contents in the index. When the &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; is given, overwrite both the index and the working tree with the contents at the &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">pathspecに一致するファイルの内容を上書きします。とき &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; （ほとんどの場合、コミット）、指数の内容を上書き作業ツリーを与えられていません。とき &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; 与えられ、インデックスとの内容で作業ツリーの両方上書き &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bdd66a641be22e4e3d7b30653f72f1e5443e834b" translate="yes" xml:space="preserve">
          <source>P4 does not have the same concept of a branch as Git. Instead, p4 organizes its content as a directory tree, where by convention different logical branches are in different locations in the tree. The &lt;code&gt;p4 branch&lt;/code&gt; command is used to maintain mappings between different areas in the tree, and indicate related content. &lt;code&gt;git p4&lt;/code&gt; can use these mappings to determine branch relationships.</source>
          <target state="translated">P4には、Gitと同じブランチの概念はありません。代わりに、p4はその内容をディレクトリツリーとして編成します。慣例により、ツリー内の異なる場所に異なる論理ブランチがあります。 &lt;code&gt;p4 branch&lt;/code&gt; 命令は、ツリー内の異なる領域間のマッピングを維持するために使用、および関連コンテンツを示しています。 &lt;code&gt;git p4&lt;/code&gt; はこれらのマッピングを使用してブランチの関係を決定できます。</target>
        </trans-unit>
        <trans-unit id="c377e9687b993a1d0b2786f798f75e99668d5825" translate="yes" xml:space="preserve">
          <source>P4 repositories can be added to an existing Git repository using &lt;code&gt;git p4 sync&lt;/code&gt; too:</source>
          <target state="translated">&lt;code&gt;git p4 sync&lt;/code&gt; を使用して、P4リポジトリを既存のGitリポジトリに追加することもできます。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
