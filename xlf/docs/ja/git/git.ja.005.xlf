<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="git">
    <body>
      <group id="git">
        <trans-unit id="23b7a95dc6b5470754cb8fce020cce7d3aab1ac0" translate="yes" xml:space="preserve">
          <source>Due to the non-quarantine nature of the &lt;code&gt;fetch.fsckObjects&lt;/code&gt; implementation it cannot be relied upon to leave the object store clean like &lt;code&gt;receive.fsckObjects&lt;/code&gt; can.</source>
          <target state="translated">原因の非検疫自然に &lt;code&gt;fetch.fsckObjects&lt;/code&gt; の実装、のようなきれいなオブジェクトストアを残すために依存することはできません &lt;code&gt;receive.fsckObjects&lt;/code&gt; ことができます。</target>
        </trans-unit>
        <trans-unit id="68e19d88dc6eefe7753376e94bb2d970e8771158" translate="yes" xml:space="preserve">
          <source>Dumps the internal marks table to &amp;lt;file&amp;gt; when complete. Marks are written one per line as &lt;code&gt;:markid SHA-1&lt;/code&gt;. Frontends can use this file to validate imports after they have been completed, or to save the marks table across incremental runs. As &amp;lt;file&amp;gt; is only opened and truncated at checkpoint (or completion) the same path can also be safely given to --import-marks.</source>
          <target state="translated">完了時に内部マークテーブルを&amp;lt;file&amp;gt;にダンプします。マークは &lt;code&gt;:markid SHA-1&lt;/code&gt; として1行に1つ書き込まれます。フロントエンドはこのファイルを使用して、インポートが完了した後にインポートを検証したり、増分実行にわたってマークテーブルを保存したりできます。 &amp;lt;file&amp;gt;はチェックポイント（または完了）でのみ開かれて切り捨てられるため、同じパスを--import-marksに安全に指定することもできます。</target>
        </trans-unit>
        <trans-unit id="d5f9d9df34707e95a5d4be8e3705f8049d385295" translate="yes" xml:space="preserve">
          <source>Dumps the internal marks table to &amp;lt;file&amp;gt; when complete. Marks are written one per line as &lt;code&gt;:markid SHA-1&lt;/code&gt;. Only marks for revisions are dumped; marks for blobs are ignored. Backends can use this file to validate imports after they have been completed, or to save the marks table across incremental runs. As &amp;lt;file&amp;gt; is only opened and truncated at completion, the same path can also be safely given to --import-marks. The file will not be written if no new object has been marked/exported.</source>
          <target state="translated">完了時に内部マークテーブルを&amp;lt;file&amp;gt;にダンプします。マークは &lt;code&gt;:markid SHA-1&lt;/code&gt; として1行に1つ書き込まれます。リビジョンのマークのみがダンプされます。 blobのマークは無視されます。バックエンドはこのファイルを使用して、インポートが完了した後にインポートを検証したり、増分実行にわたってマークテーブルを保存したりできます。 &amp;lt;file&amp;gt;は完了時にのみ開かれ、切り捨てられるため、同じパスを--import-marksに安全に指定することもできます。新しいオブジェクトがマーク/エクスポートされていない場合、ファイルは書き込まれません。</target>
        </trans-unit>
        <trans-unit id="aec3ad9b971b7ff8255345b154c94258f560f0d2" translate="yes" xml:space="preserve">
          <source>During a merge, the working tree files are updated to reflect the result of the merge. Among the changes made to the common ancestor&amp;rsquo;s version, non-overlapping ones (that is, you changed an area of the file while the other side left that area intact, or vice versa) are incorporated in the final result verbatim. When both sides made changes to the same area, however, Git cannot randomly pick one side over the other, and asks you to resolve it by leaving what both sides did to that area.</source>
          <target state="translated">マージ中、作業ツリーファイルは、マージの結果を反映するように更新されます。共通の祖先のバージョンに加えられた変更のうち、重複しないもの（つまり、ファイルの領域を変更し、反対側がその領域をそのまま残した、またはその逆）は、最終的な結果にそのまま組み込まれます。ただし、両側が同じ領域に変更を加えた場合、Gitは片側をもう片方にランダムに選択することはできず、両側がその領域に行ったことを残して解決するように求めます。</target>
        </trans-unit>
        <trans-unit id="d0b0f9a14f12b4d06a31ddb153754d3c653f1bb2" translate="yes" xml:space="preserve">
          <source>During fsck git may find issues with legacy data which wouldn&amp;rsquo;t be generated by current versions of git, and which wouldn&amp;rsquo;t be sent over the wire if &lt;code&gt;transfer.fsckObjects&lt;/code&gt; was set. This feature is intended to support working with legacy repositories containing such data.</source>
          <target state="translated">fsckの実行中に、gitはレガシーデータの問題を検出する可能性があります。これは、現在のバージョンのgitでは生成されず、 &lt;code&gt;transfer.fsckObjects&lt;/code&gt; が設定されている場合はネットワーク経由で送信されません。この機能は、そのようなデータを含むレガシーリポジトリの操作をサポートすることを目的としています。</target>
        </trans-unit>
        <trans-unit id="0eedfc5c015b233e6082e4e46ded41bc5da25b25" translate="yes" xml:space="preserve">
          <source>During the merge, the index holds three versions of each file. Each of these three &quot;file stages&quot; represents a different version of the file:</source>
          <target state="translated">マージの間、インデックスは各ファイルの3つのバージョンを保持します。これら3つの &quot;ファイルステージ &quot;はそれぞれ異なるバージョンのファイルを表します。</target>
        </trans-unit>
        <trans-unit id="338f11841fc746012903e84c16b88356c6508da5" translate="yes" xml:space="preserve">
          <source>During the normal execution of several Git commands, call-outs are made to optional scripts that allow a developer to add functionality or checking. Typically, the hooks allow for a command to be pre-verified and potentially aborted, and allow for a post-notification after the operation is done. The hook scripts are found in the &lt;code&gt;$GIT_DIR/hooks/&lt;/code&gt; directory, and are enabled by simply removing the &lt;code&gt;.sample&lt;/code&gt; suffix from the filename. In earlier versions of Git you had to make them executable.</source>
          <target state="translated">複数のGitコマンドの通常の実行中に、開発者が機能を追加したりチェックしたりできるオプションのスクリプトが呼び出されます。通常、フックを使用すると、コマンドを事前に検証して中止できる可能性があり、操作が完了した後に通知を行うことができます。フックスクリプトは &lt;code&gt;$GIT_DIR/hooks/&lt;/code&gt; ディレクトリにあり、ファイル名から &lt;code&gt;.sample&lt;/code&gt; サフィックスを削除するだけで有効になります。以前のバージョンのGitでは、それらを実行可能にする必要がありました。</target>
        </trans-unit>
        <trans-unit id="0c9afe2970bcd3db38ea14d913886ce00bad52d6" translate="yes" xml:space="preserve">
          <source>E.g, &lt;code&gt;format:&quot;The author of %h was %an, %ar%nThe title was &amp;gt;&amp;gt;%s&amp;lt;&amp;lt;%n&quot;&lt;/code&gt; would show something like this:</source>
          <target state="translated">例： &lt;code&gt;format:&quot;The author of %h was %an, %ar%nThe title was &amp;gt;&amp;gt;%s&amp;lt;&amp;lt;%n&quot;&lt;/code&gt; は次のように表示されます。</target>
        </trans-unit>
        <trans-unit id="f48496348ce670a87dfe7a89fce6efc7850de45b" translate="yes" xml:space="preserve">
          <source>EVENT Format</source>
          <target state="translated">イベントフォーマット</target>
        </trans-unit>
        <trans-unit id="6c7b6f5f1d21b52d57339a7396d0f52ff8e6b468" translate="yes" xml:space="preserve">
          <source>Each &quot;index&quot; entry has two bits worth of &quot;stage&quot; state. stage 0 is the normal one, and is the only one you&amp;rsquo;d see in any kind of normal use.</source>
          <target state="translated">各「インデックス」エントリには、2ビット分の「ステージ」状態があります。ステージ0は通常のステージであり、あらゆる種類の通常の使用で見られる唯一のステージです。</target>
        </trans-unit>
        <trans-unit id="81f54a7f6a9b658757fad1b0dd5d1a9971c93ea4" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;%feature&lt;/code&gt; hash element is a hash reference and has the following structure:</source>
          <target state="translated">各 &lt;code&gt;%feature&lt;/code&gt; ハッシュ要素はハッシュ参照であり、次の構造を持っています：</target>
        </trans-unit>
        <trans-unit id="b26592933b83f1f492565be647afc2706b49b317" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;-p&lt;/code&gt; indicates the id of a parent commit object.</source>
          <target state="translated">各 &lt;code&gt;-p&lt;/code&gt; は、親コミットオブジェクトのIDを示します。</target>
        </trans-unit>
        <trans-unit id="e2a09fd45cc17448d565b97a290193dc0600d3ce" translate="yes" xml:space="preserve">
          <source>Each action is implemented as a subroutine, and must be present in %actions hash. Some actions are disabled by default, and must be turned on via feature mechanism. For example to enable &lt;code&gt;blame&lt;/code&gt; view add the following to gitweb configuration file:</source>
          <target state="translated">各アクションはサブルーチンとして実装され、％actionsハッシュに存在する必要があります。一部のアクションはデフォルトで無効になっており、機能メカニズムを介してオンにする必要があります。たとえば、 &lt;code&gt;blame&lt;/code&gt; ビューを有効にするには、gitweb構成ファイルに以下を追加します。</target>
        </trans-unit>
        <trans-unit id="4a431caa46e2fb6d34e98615d6339148b9977f86" translate="yes" xml:space="preserve">
          <source>Each attribute can be in one of these states for a given path:</source>
          <target state="translated">各属性は、与えられたパスに対して、これらの状態のいずれかになることができます。</target>
        </trans-unit>
        <trans-unit id="80fa6b90c4af909cefe5f1fba5144ae109300923" translate="yes" xml:space="preserve">
          <source>Each blame entry always starts with a line of:</source>
          <target state="translated">それぞれの非難エントリは常に行から始まります。</target>
        </trans-unit>
        <trans-unit id="2235e2f29b242d64317e253060371b53dfcfe3a6" translate="yes" xml:space="preserve">
          <source>Each command for the &lt;code&gt;proc-receive&lt;/code&gt; hook may point to a pseudo-reference and always has a zero-old as its old-oid, while the &lt;code&gt;proc-receive&lt;/code&gt; hook may update an alternate reference and the alternate reference may exist already with a non-zero old-oid. For this case, this hook will use &quot;option&quot; directives to report extended attributes for the reference given by the leading &quot;ok&quot; directive.</source>
          <target state="translated">Each command for the &lt;code&gt;proc-receive&lt;/code&gt; hook may point to a pseudo-reference and always has a zero-old as its old-oid, while the &lt;code&gt;proc-receive&lt;/code&gt; hook may update an alternate reference and the alternate reference may exist already with a non-zero old-oid. For this case, this hook will use &quot;option&quot; directives to report extended attributes for the reference given by the leading &quot;ok&quot; directive.</target>
        </trans-unit>
        <trans-unit id="890525cbde82d7616c57fdec079512ee27038efd" translate="yes" xml:space="preserve">
          <source>Each commit imported by &lt;code&gt;git p4&lt;/code&gt; has a line at the end of the log message indicating the p4 depot location and change number. This line is used by later &lt;code&gt;git p4 sync&lt;/code&gt; operations to know which p4 changes are new.</source>
          <target state="translated">&lt;code&gt;git p4&lt;/code&gt; によってインポートされた各コミットのログメッセージの最後に、p4デポの場所と変更番号を示す行があります。この行は、どのp4の変更が新しいかを知るために、後の &lt;code&gt;git p4 sync&lt;/code&gt; 操作で使用されます。</target>
        </trans-unit>
        <trans-unit id="0d7aba1c95771e1fa299e8f177a2cb8fdb72c0d3" translate="yes" xml:space="preserve">
          <source>Each event is a JSON-object containing multiple key/value pairs written as a single line and followed by a LF.</source>
          <target state="translated">各イベントは、複数のキー/値のペアを含むJSONオブジェクトで、1行で記述され、その後にLFが続きます。</target>
        </trans-unit>
        <trans-unit id="93024a055d9225f66feed1627e9698b1aeced23b" translate="yes" xml:space="preserve">
          <source>Each group of changes (called a &quot;hunk&quot;) in the textual diff output is prefixed with a line of the form:</source>
          <target state="translated">テキスト diff 出力の各変更グループ(「ハンク」と呼ばれる)の前には、形式の行が付けられています。</target>
        </trans-unit>
        <trans-unit id="227cc42fafaaa73089d47f3a2585fc225301de56" translate="yes" xml:space="preserve">
          <source>Each helper is specified by a single string in the configuration variable &lt;code&gt;credential.helper&lt;/code&gt; (and others, see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). The string is transformed by Git into a command to be executed using these rules:</source>
          <target state="translated">各ヘルパーは、構成変数 &lt;code&gt;credential.helper&lt;/code&gt; （およびその他の場合は&lt;a href=&quot;git-config&quot;&gt;git-config [1]を&lt;/a&gt;参照）の単一の文字列で指定されます。文字列はGitによって、次のルールを使用して実行されるコマンドに変換されます。</target>
        </trans-unit>
        <trans-unit id="82afba91b0fbc1511d9d66475a7a1226634e3792" translate="yes" xml:space="preserve">
          <source>Each instruction has variable length. Instruction type is determined by the seventh bit of the first octet. The following diagrams follow the convention in RFC 1951 (Deflate compressed data format).</source>
          <target state="translated">各命令は可変長です。命令の種類は、最初のオクテットの7番目のビットによって決定されます。以下の図は、RFC 1951 (Deflate compressed data format)の規約に従っています。</target>
        </trans-unit>
        <trans-unit id="e70c1e613f5f534aeea8db8eaf0d4059228f6833" translate="yes" xml:space="preserve">
          <source>Each line in &lt;code&gt;gitattributes&lt;/code&gt; file is of form:</source>
          <target state="translated">各行 &lt;code&gt;gitattributes&lt;/code&gt; のファイルの形式は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="1c072d6c2cdd76489a2967b2e7ee81381c672ff3" translate="yes" xml:space="preserve">
          <source>Each line in a &lt;code&gt;gitignore&lt;/code&gt; file specifies a pattern. When deciding whether to ignore a path, Git normally checks &lt;code&gt;gitignore&lt;/code&gt; patterns from multiple sources, with the following order of precedence, from highest to lowest (within one level of precedence, the last matching pattern decides the outcome):</source>
          <target state="translated">各行 &lt;code&gt;gitignore&lt;/code&gt; のファイルには、パターンを指定します。パスを無視するかどうかを決定するとき、Gitは通常、複数のソースからの &lt;code&gt;gitignore&lt;/code&gt; パターンを、次の優先順位で最高から最低までチェックします（1レベルの優先度内で、最後に一致したパターンが結果を決定します）。</target>
        </trans-unit>
        <trans-unit id="d043aa624315c625b39f19b7c5a71a08d0fbefd2" translate="yes" xml:space="preserve">
          <source>Each line of options has this format:</source>
          <target state="translated">オプションの各行には、この形式があります。</target>
        </trans-unit>
        <trans-unit id="ce263659ab1a0135f8fda2a68c8ecc96cb2e4b52" translate="yes" xml:space="preserve">
          <source>Each line of the &lt;code&gt;git ls-files --unmerged&lt;/code&gt; output begins with the blob mode bits, blob SHA-1, 'stage number', and the filename. The 'stage number' is Git&amp;rsquo;s way to say which tree it came from: stage 1 corresponds to the &lt;code&gt;$orig&lt;/code&gt; tree, stage 2 to the &lt;code&gt;HEAD&lt;/code&gt; tree, and stage 3 to the &lt;code&gt;$target&lt;/code&gt; tree.</source>
          <target state="translated">各ライン &lt;code&gt;git ls-files --unmerged&lt;/code&gt; 出力BLOBモードビット、BLOBのSHA-1、「段数」、およびファイル名で始まります。「ステージ番号」は、Gitがどのツリーから来たかを表す方法です。ステージ1は &lt;code&gt;$orig&lt;/code&gt; ツリーに対応し、ステージ2は &lt;code&gt;HEAD&lt;/code&gt; ツリーに対応し、ステージ3は &lt;code&gt;$target&lt;/code&gt; ツリーに対応します。</target>
        </trans-unit>
        <trans-unit id="a2e72e23a1ee3c2cf405696e86ad1ef3c4d6f422" translate="yes" xml:space="preserve">
          <source>Each line of the &lt;code&gt;git ls-files --unmerged&lt;/code&gt; output begins with the blob mode bits, blob SHA-1, &lt;code&gt;stage number&lt;/code&gt;, and the filename. The &lt;code&gt;stage number&lt;/code&gt; is Git&amp;rsquo;s way to say which tree it came from: stage 1 corresponds to the &lt;code&gt;$orig&lt;/code&gt; tree, stage 2 to the &lt;code&gt;HEAD&lt;/code&gt; tree, and stage 3 to the &lt;code&gt;$target&lt;/code&gt; tree.</source>
          <target state="translated">各ライン &lt;code&gt;git ls-files --unmerged&lt;/code&gt; 出力BLOBモードビット、BLOBのSHA-1、始まる &lt;code&gt;stage number&lt;/code&gt; 、およびファイル名。 &lt;code&gt;stage number&lt;/code&gt; 、ステージ1に相当する：それはから来た木言うためにGitの方法です &lt;code&gt;$orig&lt;/code&gt; ツリーにステージ2 &lt;code&gt;HEAD&lt;/code&gt; のツリー、そしてステージ3 &lt;code&gt;$target&lt;/code&gt; ツリー。</target>
        </trans-unit>
        <trans-unit id="ac1b4287ed9a44af81d40c798f15ea7666d1fc7e" translate="yes" xml:space="preserve">
          <source>Each linked working tree has a private sub-directory in the repository&amp;rsquo;s $GIT_DIR/worktrees directory. The private sub-directory&amp;rsquo;s name is usually the base name of the linked working tree&amp;rsquo;s path, possibly appended with a number to make it unique. For example, when &lt;code&gt;$GIT_DIR=/path/main/.git&lt;/code&gt; the command &lt;code&gt;git worktree add /path/other/test-next next&lt;/code&gt; creates the linked working tree in &lt;code&gt;/path/other/test-next&lt;/code&gt; and also creates a &lt;code&gt;$GIT_DIR/worktrees/test-next&lt;/code&gt; directory (or &lt;code&gt;$GIT_DIR/worktrees/test-next1&lt;/code&gt; if &lt;code&gt;test-next&lt;/code&gt; is already taken).</source>
          <target state="translated">リンクされた各作業ツリーには、リポジトリの$ GIT_DIR / worktreesディレクトリにプライベートサブディレクトリがあります。プライベートサブディレクトリの名前は通常、リンクされた作業ツリーのパスのベース名であり、一意にするために番号が付加されている可能性があります。たとえば、 &lt;code&gt;$GIT_DIR=/path/main/.git&lt;/code&gt; コマンド &lt;code&gt;git worktree add /path/other/test-next next&lt;/code&gt; は、リンクされた作業ツリーを &lt;code&gt;/path/other/test-next&lt;/code&gt; に作成し、さらに &lt;code&gt;$GIT_DIR/worktrees/test-next&lt;/code&gt; 作成します。/ test-nextディレクトリ（ &lt;code&gt;test-next&lt;/code&gt; がすでに取得されている場合は &lt;code&gt;$GIT_DIR/worktrees/test-next1&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="08c05bcbce27635e929ab0aeef0154946c733deb" translate="yes" xml:space="preserve">
          <source>Each linked working tree has a private sub-directory in the repository&amp;rsquo;s &lt;code&gt;$GIT_DIR/worktrees&lt;/code&gt; directory. The private sub-directory&amp;rsquo;s name is usually the base name of the linked working tree&amp;rsquo;s path, possibly appended with a number to make it unique. For example, when &lt;code&gt;$GIT_DIR=/path/main/.git&lt;/code&gt; the command &lt;code&gt;git worktree add /path/other/test-next next&lt;/code&gt; creates the linked working tree in &lt;code&gt;/path/other/test-next&lt;/code&gt; and also creates a &lt;code&gt;$GIT_DIR/worktrees/test-next&lt;/code&gt; directory (or &lt;code&gt;$GIT_DIR/worktrees/test-next1&lt;/code&gt; if &lt;code&gt;test-next&lt;/code&gt; is already taken).</source>
          <target state="translated">リンクされた各作業ツリーには、リポジトリの &lt;code&gt;$GIT_DIR/worktrees&lt;/code&gt; ディレクトリにプライベートサブディレクトリがあります。プライベートサブディレクトリの名前は通常、リンクされた作業ツリーのパスのベース名であり、一意にするために番号が追加される場合があります。たとえば、 &lt;code&gt;$GIT_DIR=/path/main/.git&lt;/code&gt; 、コマンド &lt;code&gt;git worktree add /path/other/test-next next&lt;/code&gt; は、リンクされた作業ツリーを &lt;code&gt;/path/other/test-next&lt;/code&gt; に作成し、 &lt;code&gt;$GIT_DIR/worktrees/test-next&lt;/code&gt; も作成します。/ test-nextディレクトリ（または、 &lt;code&gt;test-next&lt;/code&gt; がすでに実行されている場合は &lt;code&gt;$GIT_DIR/worktrees/test-next1&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="0e13434b85bdba9c36937ef9acd2f33c427adfe8" translate="yes" xml:space="preserve">
          <source>Each of the attribute requirements for the path takes one of these forms:</source>
          <target state="translated">パスの各属性要件は、以下のいずれかの形式をとります。</target>
        </trans-unit>
        <trans-unit id="58398b8104bc9622bb9865f6e7c9793546a9471d" translate="yes" xml:space="preserve">
          <source>Each of the four branches is usually a direct descendant of the one above it.</source>
          <target state="translated">4つの枝のそれぞれは、通常、その上の枝の直系の子孫です。</target>
        </trans-unit>
        <trans-unit id="dfc2dc1cc1f2e4f6e3d7ce6e6191c01415d0880b" translate="yes" xml:space="preserve">
          <source>Each of these options must appear first on the command line.</source>
          <target state="translated">これらのオプションのそれぞれは、コマンドラインで最初に表示される必要があります。</target>
        </trans-unit>
        <trans-unit id="79d9036a8f3f011f6caea432d8fa6198deb15d8c" translate="yes" xml:space="preserve">
          <source>Each other line contains a single pattern.</source>
          <target state="translated">他の各行には1つのパターンが含まれています。</target>
        </trans-unit>
        <trans-unit id="36e6db0cb81d09d2c644d8a7c4b702648cc38f78" translate="yes" xml:space="preserve">
          <source>Each patch can be applied in order.</source>
          <target state="translated">それぞれのパッチは順番に貼ることができます。</target>
        </trans-unit>
        <trans-unit id="6d39c2ae5926cd9b5a6631ab32e0430d3e598f09" translate="yes" xml:space="preserve">
          <source>Each patch includes a single logical change, together with a message explaining the change.</source>
          <target state="translated">それぞれのパッチには、論理的な変更点が1つと、その変更点を説明するメッセージが含まれています。</target>
        </trans-unit>
        <trans-unit id="493d693b4f2b5ea37d0460dc9ff9f76e6d401041" translate="yes" xml:space="preserve">
          <source>Each pattern pair consists of the source side (before the colon) and the destination side (after the colon). The ref to be pushed is determined by finding a match that matches the source side, and where it is pushed is determined by using the destination side.</source>
          <target state="translated">各パターンペアは、ソース側(コロンの前)とデスティネーション側(コロンの後)で構成されています。押されるRefは、ソース側に一致するマッチを見つけることで決定され、どこに押されるかは、デスティネーション側を利用して決定されます。</target>
        </trans-unit>
        <trans-unit id="b313cea753099ce8f3968fb8a5c9e65e86c611ac" translate="yes" xml:space="preserve">
          <source>Each pattern pair consists of the source side (before the colon) and the destination side (after the colon). The ref to be pushed is determined by finding a match that matches the source side, and where it is pushed is determined by using the destination side. The rules used to match a ref are the same rules used by &lt;code&gt;git rev-parse&lt;/code&gt; to resolve a symbolic ref name. See &lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse[1]&lt;/a&gt;.</source>
          <target state="translated">各パターンのペアは、ソース側（コロンの前）と宛先側（コロンの後）で構成されます。プッシュされる参照は、ソース側と一致する一致を見つけることによって決定され、プッシュされる場所は宛先側を使用して決定されます。refの照合に使用されるルールは、シンボリックref名を解決するために &lt;code&gt;git rev-parse&lt;/code&gt; が使用するルールと同じです。&lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse [1]を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="b2aa7f4f33bfb7b26b4af691cb7e2c6d52612b8b" translate="yes" xml:space="preserve">
          <source>Each remote helper is expected to support only a subset of commands. The operations a helper supports are declared to Git in the response to the &lt;code&gt;capabilities&lt;/code&gt; command (see COMMANDS, below).</source>
          <target state="translated">各リモートヘルパーは、コマンドのサブセットのみをサポートすることが期待されています。ヘルパーがサポートする操作は、 &lt;code&gt;capabilities&lt;/code&gt; コマンドへの応答でGitに宣言されます（以下のコマンドを参照）。</target>
        </trans-unit>
        <trans-unit id="640db855296fc622a8934e713d8f1835acdff3f5" translate="yes" xml:space="preserve">
          <source>Each time a new shared index file is created, the old shared index files are deleted if their modification time is older than what is specified by the splitIndex.sharedIndexExpire config variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">新しい共有インデックスファイルが作成されるたびに、変更時刻がsplitIndex.sharedIndexExpire構成変数で指定されたものよりも古い場合、古い共有インデックスファイルは削除されます（&lt;a href=&quot;git-config&quot;&gt;git-config [1]を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="6b67247d73793e579b74a9b09ccf935b5a398f89" translate="yes" xml:space="preserve">
          <source>Each time a superproject update moves a populated submodule (e.g. when switching between commits before and after the move) a stale submodule checkout will remain in the old location and an empty directory will appear in the new location. To populate the submodule again in the new location the user will have to run &quot;git submodule update&quot; afterwards. Removing the old directory is only safe when it uses a gitfile, as otherwise the history of the submodule will be deleted too. Both steps will be obsolete when recursive submodule update has been implemented.</source>
          <target state="translated">スーパープロジェクトの更新がサブモジュールを移動するたびに (移動の前後でコミットを切り替えるときなど)、古いサブモジュールのチェックアウトが古い場所に残ってしまい、新しい場所には空のディレクトリが表示されます。新しい場所に再びサブモジュールを配置するには、その後で &quot;git submodule update&quot; を実行しなければなりません。古いディレクトリを削除するのが安全なのは、gitfile を使っているときだけです。再帰的なサブモジュールの更新が実装された後では、どちらの手順も廃止されるでしょう。</target>
        </trans-unit>
        <trans-unit id="70398d4e57fc6de31488380bf7caac1138d58530" translate="yes" xml:space="preserve">
          <source>Each time a superproject update removes a populated submodule (e.g. when switching between commits before and after the removal) a stale submodule checkout will remain in the old location. Removing the old directory is only safe when it uses a gitfile, as otherwise the history of the submodule will be deleted too. This step will be obsolete when recursive submodule update has been implemented.</source>
          <target state="translated">スーパープロジェクトの更新のたびに (たとえば、削除の前後でコミットを切り替えるときなど)、古いサブモジュールのチェックアウトが古い場所に残ってしまいます。古いディレクトリを削除するのが安全なのは、gitfile を使っているときだけです。再帰的なサブモジュールの更新が実装されたときには、このステップは廃止されるでしょう。</target>
        </trans-unit>
        <trans-unit id="49035126eea24f612f322a34d235d8eeac55e17a" translate="yes" xml:space="preserve">
          <source>Each time you resolve the conflicts in a file and update the index:</source>
          <target state="translated">ファイル内の競合を解決してインデックスを更新するたびに</target>
        </trans-unit>
        <trans-unit id="91df855bba63011edb2c56419d0fb8efa1e50e11" translate="yes" xml:space="preserve">
          <source>Earlier we said that trivial merges are done inside &lt;code&gt;git read-tree -m&lt;/code&gt;. For example, if the file did not change from &lt;code&gt;$orig&lt;/code&gt; to &lt;code&gt;HEAD&lt;/code&gt; or &lt;code&gt;$target&lt;/code&gt;, or if the file changed from &lt;code&gt;$orig&lt;/code&gt; to &lt;code&gt;HEAD&lt;/code&gt; and &lt;code&gt;$orig&lt;/code&gt; to &lt;code&gt;$target&lt;/code&gt; the same way, obviously the final outcome is what is in &lt;code&gt;HEAD&lt;/code&gt;. What the above example shows is that file &lt;code&gt;hello.c&lt;/code&gt; was changed from &lt;code&gt;$orig&lt;/code&gt; to &lt;code&gt;HEAD&lt;/code&gt; and &lt;code&gt;$orig&lt;/code&gt; to &lt;code&gt;$target&lt;/code&gt; in a different way. You could resolve this by running your favorite 3-way merge program, e.g. &lt;code&gt;diff3&lt;/code&gt;, &lt;code&gt;merge&lt;/code&gt;, or Git&amp;rsquo;s own merge-file, on the blob objects from these three stages yourself, like this:</source>
          <target state="translated">以前に、些細なマージは &lt;code&gt;git read-tree -m&lt;/code&gt; 内で行われると述べました。たとえば、ファイルが &lt;code&gt;$orig&lt;/code&gt; から &lt;code&gt;HEAD&lt;/code&gt; または &lt;code&gt;$target&lt;/code&gt; に変更されなかった場合、またはファイルが &lt;code&gt;$orig&lt;/code&gt; から &lt;code&gt;HEAD&lt;/code&gt; および &lt;code&gt;$orig&lt;/code&gt; から &lt;code&gt;$target&lt;/code&gt; に同じように変更された場合、明らかに最終的な結果は &lt;code&gt;HEAD&lt;/code&gt; にあります。上記の例は、ファイル &lt;code&gt;hello.c&lt;/code&gt; が &lt;code&gt;$orig&lt;/code&gt; から &lt;code&gt;HEAD&lt;/code&gt; に、 &lt;code&gt;$orig&lt;/code&gt; から &lt;code&gt;$target&lt;/code&gt; に別の方法で変更されたことを示しています。これを解決するには、お気に入りの3者間マージプログラム（ &lt;code&gt;diff3&lt;/code&gt; など)を実行します。、 &lt;code&gt;merge&lt;/code&gt; 、またはGit独自のmerge-fileで、これらの3つのステージのblobオブジェクトを自分で次のように指定します。</target>
        </trans-unit>
        <trans-unit id="cf0ee6adeaeadff98f7e216b0d8eb81b31226098" translate="yes" xml:space="preserve">
          <source>Earlier, we saw that one file under &lt;code&gt;.git/objects/??/&lt;/code&gt; directory is stored for each Git object you create. This representation is efficient to create atomically and safely, but not so convenient to transport over the network. Since Git objects are immutable once they are created, there is a way to optimize the storage by &quot;packing them together&quot;. The command</source>
          <target state="translated">以前に、作成したGitオブジェクトごとに、 &lt;code&gt;.git/objects/??/&lt;/code&gt; ディレクトリの下に1つのファイルが保存されていることを確認しました。この表現は、アトミックかつ安全に作成するのに効率的ですが、ネットワークを介した転送にはそれほど便利ではありません。Gitオブジェクトは、一度作成すると不変であるため、「一緒にパック」することでストレージを最適化する方法があります。コマンド</target>
        </trans-unit>
        <trans-unit id="b4c8a83331a00582f4030fa5296077717cda7730" translate="yes" xml:space="preserve">
          <source>Ease of use. It is often much simpler to write a binary to text transformation than it is to perform your own diff. In many cases, existing programs can be used as textconv filters (e.g., exif, odt2txt).</source>
          <target state="translated">使いやすさ。バイナリからテキストへの変換は、自分でdiffを実行するよりも、バイナリからテキストへの変換を書いた方がはるかに簡単であることが多いです。多くの場合、既存のプログラムをtextconvフィルタ(exif、odt2txtなど)として使用することができます。</target>
        </trans-unit>
        <trans-unit id="b4d52eb229c8c557c44ab0035085b989953060f9" translate="yes" xml:space="preserve">
          <source>Easily extendable as capabilities are moved into their own section of the protocol, no longer being hidden behind a NUL byte and limited by the size of a pkt-line</source>
          <target state="translated">能力がプロトコルの独自のセクションに移動し、NULバイトの後ろに隠されたり、pkt-lineのサイズに制限されたりすることがなくなり、容易に拡張可能になります。</target>
        </trans-unit>
        <trans-unit id="c0ecd6c3f25fc4cb4d76566a21fece2ca48f95ab" translate="yes" xml:space="preserve">
          <source>Easy case: The changes are literally the same.</source>
          <target state="translated">簡単なケース。変更点は文字通り同じです。</target>
        </trans-unit>
        <trans-unit id="d4f35a5d52e75e1ab425158dcb45339db600d3f4" translate="yes" xml:space="preserve">
          <source>Eclipse 3.0, 3.1.2 on MacOSX (see Eclipse CVS Client Notes)</source>
          <target state="translated">Eclipse 3.0,3.1.2 on MacOSX (Eclipse CVS クライアントノートを参照)</target>
        </trans-unit>
        <trans-unit id="f5e176bd2c2df731632b9ca0ee7983e84b3d8517" translate="yes" xml:space="preserve">
          <source>Eclipse cvs client notes</source>
          <target state="translated">Eclipse の cvs クライアントノート</target>
        </trans-unit>
        <trans-unit id="ea0675157801730c96e515d20a6ad02ac765e6d4" translate="yes" xml:space="preserve">
          <source>Edit an object&amp;rsquo;s content interactively. The existing content for &amp;lt;object&amp;gt; is pretty-printed into a temporary file, an editor is launched on the file, and the result is parsed to create a new object of the same type as &amp;lt;object&amp;gt;. A replacement ref is then created to replace &amp;lt;object&amp;gt; with the newly created object. See &lt;a href=&quot;git-var&quot;&gt;git-var[1]&lt;/a&gt; for details about how the editor will be chosen.</source>
          <target state="translated">オブジェクトのコンテンツをインタラクティブに編集します。&amp;lt;object&amp;gt;の既存のコンテンツが一時ファイルにきれいに出力され、エディターがファイルで起動され、結果が解析されて&amp;lt;object&amp;gt;と同じタイプの新しいオブジェクトが作成されます。次に、置換参照が作成され、&amp;lt;object&amp;gt;が新しく作成されたオブジェクトに置き換えられます。参照&lt;a href=&quot;git-var&quot;&gt;のgit-VAR [1]&lt;/a&gt;エディタが選択される方法の詳細については。</target>
        </trans-unit>
        <trans-unit id="0f76fc2a41a48ffbf729f7fe389bfe3f0b08de68" translate="yes" xml:space="preserve">
          <source>Edit the commit message before committing to SVN. This is off by default for objects that are commits, and forced on when committing tree objects.</source>
          <target state="translated">SVN にコミットする前にコミットメッセージを編集します。これはコミットするオブジェクトに対してはデフォルトではオフになっており、ツリーオブジェクトをコミットする際には強制的にオンになります。</target>
        </trans-unit>
        <trans-unit id="c92b0955a7a67e8bc1f5f7afd177ec4ed55d0e4c" translate="yes" xml:space="preserve">
          <source>Edit the files in place.</source>
          <target state="translated">その場で編集します。</target>
        </trans-unit>
        <trans-unit id="b87cea5cffa31e45fd50bcd7540894242796f029" translate="yes" xml:space="preserve">
          <source>Edit the notes for a given object (defaults to HEAD).</source>
          <target state="translated">指定されたオブジェクトのノートを編集します(デフォルトは HEAD)。</target>
        </trans-unit>
        <trans-unit id="81933d4e997d5f22262236af308c480381855b0f" translate="yes" xml:space="preserve">
          <source>Edit the todo list during an interactive rebase.</source>
          <target state="translated">インタラクティブなリベース中に TODO リストを編集します。</target>
        </trans-unit>
        <trans-unit id="f392476dbdf7968fc4726a7173f15cf238dddd46" translate="yes" xml:space="preserve">
          <source>Editing patches</source>
          <target state="translated">パッチの編集</target>
        </trans-unit>
        <trans-unit id="8f25a859269ca51039632dd6bba28fb061cfb8d4" translate="yes" xml:space="preserve">
          <source>Effects</source>
          <target state="translated">Effects</target>
        </trans-unit>
        <trans-unit id="7002bc1d2bcb94f212817ade973f1baffe1d4266" translate="yes" xml:space="preserve">
          <source>Either a &lt;a href=&quot;#def_working_tree&quot;&gt;working tree&lt;/a&gt;, or a &lt;a href=&quot;#def_tree_object&quot;&gt;tree object&lt;/a&gt; together with the dependent &lt;a href=&quot;#def_blob_object&quot;&gt;blob&lt;/a&gt; and tree objects (i.e. a stored representation of a working tree).</source>
          <target state="translated">いずれかの&lt;a href=&quot;#def_working_tree&quot;&gt;作業ツリー&lt;/a&gt;または&lt;a href=&quot;#def_tree_object&quot;&gt;ツリーオブジェクト&lt;/a&gt;依存と共に&lt;a href=&quot;#def_blob_object&quot;&gt;ブロブ&lt;/a&gt;とツリーオブジェクト（作業ツリーの、すなわちA格納された表現）。</target>
        </trans-unit>
        <trans-unit id="bc0851580574fafe647ac3b5e7bd049ba47eee8d" translate="yes" xml:space="preserve">
          <source>Either the hash or the filename under [URL]/refs/ to pull.</source>
          <target state="translated">URL]/refs/以下のハッシュかファイル名のどちらかを指定してください。</target>
        </trans-unit>
        <trans-unit id="3c055884457fa0453683ceee26bbe41d08beb912" translate="yes" xml:space="preserve">
          <source>Either way, if you have a string of untestable commits, it might happen that the regression you are looking for has been introduced by one of these untestable commits. In this case it&amp;rsquo;s not possible to tell for sure which commit introduced the regression.</source>
          <target state="translated">どちらの方法でも、テスト不可能なコミットの文字列がある場合、探している回帰がこれらのテスト不可能なコミットのいずれかによって引き起こされた可能性があります。この場合、どのコミットがリグレッションを引き起こしたかを確実に判断することはできません。</target>
        </trans-unit>
        <trans-unit id="84add5b2952787581cb9a8851eef63d1ec75d22b" translate="yes" xml:space="preserve">
          <source>Email</source>
          <target state="translated">Email</target>
        </trans-unit>
        <trans-unit id="727400f70d8ff4dd021cd3b46cd8407431accd18" translate="yes" xml:space="preserve">
          <source>Empty commits</source>
          <target state="translated">空のコミット</target>
        </trans-unit>
        <trans-unit id="64c856db8d7087653e88ddbd52d985c5029c26f3" translate="yes" xml:space="preserve">
          <source>Empty context lines that do not have &lt;code&gt;any&lt;/code&gt; whitespace.</source>
          <target state="translated">持っていない空のコンテキスト行 &lt;code&gt;any&lt;/code&gt; の空白を。</target>
        </trans-unit>
        <trans-unit id="bc35de4b332414e34ea66c4e2722d1b3c677ee26" translate="yes" xml:space="preserve">
          <source>Enable &quot;sparse checkout&quot; feature. See &lt;a href=&quot;git-sparse-checkout&quot;&gt;git-sparse-checkout[1]&lt;/a&gt; for more information.</source>
          <target state="translated">「スパースチェックアウト」機能を有効にします。詳細については、&lt;a href=&quot;git-sparse-checkout&quot;&gt;git-sparse-checkout [1]&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="b1506b425dd0a659b4e3f7dbaad1db76c1920ca2" translate="yes" xml:space="preserve">
          <source>Enable (1) or disable (0) debug output. If enabled, SMTP commands and replies will be printed. Useful to debug TLS connection and authentication problems.</source>
          <target state="translated">デバッグ出力を有効(1)または無効(0)にします。有効にすると、SMTP コマンドと返信が出力されます。TLS 接続や認証の問題をデバッグするのに便利です。</target>
        </trans-unit>
        <trans-unit id="5ca5f9ffb4eef636571b0732ca8e82f4b117bf57" translate="yes" xml:space="preserve">
          <source>Enable Git&amp;rsquo;s password prompt for the SSL certificate. Otherwise OpenSSL will prompt the user, possibly many times, if the certificate or private key is encrypted. Can be overridden by the &lt;code&gt;GIT_SSL_CERT_PASSWORD_PROTECTED&lt;/code&gt; environment variable.</source>
          <target state="translated">SSL証明書のGitのパスワードプロンプトを有効にします。そうでない場合、証明書または秘密鍵が暗号化されている場合、OpenSSLはユーザーにおそらく何回もプロンプトを出します。 &lt;code&gt;GIT_SSL_CERT_PASSWORD_PROTECTED&lt;/code&gt; 環境変数によってオーバーライドできます。</target>
        </trans-unit>
        <trans-unit id="22af37288ef16d6e96158d900edae0bae2453223" translate="yes" xml:space="preserve">
          <source>Enable Git&amp;rsquo;s password prompt for the proxy SSL certificate. Otherwise OpenSSL will prompt the user, possibly many times, if the certificate or private key is encrypted. Can be overriden by the &lt;code&gt;GIT_PROXY_SSL_CERT_PASSWORD_PROTECTED&lt;/code&gt; environment variable.</source>
          <target state="translated">プロキシSSL証明書に対してGitのパスワードプロンプトを有効にします。それ以外の場合、証明書または秘密鍵が暗号化されていると、OpenSSLはユーザーにプロンプ​​トを表示します。 &lt;code&gt;GIT_PROXY_SSL_CERT_PASSWORD_PROTECTED&lt;/code&gt; 環境変数でオーバーライドできます。</target>
        </trans-unit>
        <trans-unit id="202cfbf6c643ccf61c3e6855fb4942a959d7c88c" translate="yes" xml:space="preserve">
          <source>Enable and configure &quot;patches&quot; view, which displays list of commits in email (plain text) output format; see also &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt;. The value is the maximum number of patches in a patchset generated in &quot;patches&quot; view. Set the &lt;code&gt;default&lt;/code&gt; field to a list containing single item of or to an empty list to disable patch view, or to a list containing a single negative number to remove any limit. Default value is 16.</source>
          <target state="translated">コミットのリストを電子メール（プレーンテキスト）出力形式で表示する「パッチ」ビューを有効にして構成します。&lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]&lt;/a&gt;も参照してください。この値は、「パッチ」ビューで生成されるパッチセット内のパッチの最大数です。設定 &lt;code&gt;default&lt;/code&gt; のまたは無効パッチビューに、または任意の制限を除去するために、単一の負の数を含むリストに空のリストへの単一のアイテムを含むリストにフィールドを。デフォルト値は16です。</target>
        </trans-unit>
        <trans-unit id="3ec940cc58a7e0a3ca8323d3832e04ecb527aead" translate="yes" xml:space="preserve">
          <source>Enable and configure the &quot;snapshot&quot; action, which allows user to download a compressed archive of any tree or commit, as produced by &lt;a href=&quot;git-archive&quot;&gt;git-archive[1]&lt;/a&gt; and possibly additionally compressed. This can potentially generate high traffic if you have large project.</source>
          <target state="translated">「スナップショット」アクションを有効にして構成します。これにより、&lt;a href=&quot;git-archive&quot;&gt;git-archive [1]&lt;/a&gt;によって生成され、場合によってはさらに圧縮された、ツリーまたはコミットの圧縮アーカイブをダウンロードできます。大規模なプロジェクトがある場合、これは潜在的に高いトラフィックを生成する可能性があります。</target>
        </trans-unit>
        <trans-unit id="875ff7ca114490b100a4ae7597d23eb505e57466" translate="yes" xml:space="preserve">
          <source>Enable and configure the ability to change a common time zone for dates in gitweb output via JavaScript. Dates in gitweb output include authordate and committerdate in &quot;commit&quot;, &quot;commitdiff&quot; and &quot;log&quot; views, and taggerdate in &quot;tag&quot; view. Enabled by default.</source>
          <target state="translated">gitweb 出力の日付の共通タイムゾーンを JavaScript で変更する機能を有効にし、設定します。gitweb 出力の日付には、&quot;commit&quot; ビュー、&quot;commitdiff&quot; ビュー、&quot;log&quot; ビューの authordate および committerdate、そして &quot;tag&quot; ビューの taggerdate が含まれます。デフォルトでは有効になっています。</target>
        </trans-unit>
        <trans-unit id="e1b8a656580e419265edb3d93e7fbf612f88122b" translate="yes" xml:space="preserve">
          <source>Enable config options that are new to Git, and are being considered for future defaults. Config settings included here may be added or removed with each release, including minor version updates. These settings may have unintended interactions since they are so new. Please enable this setting if you are interested in providing feedback on experimental features. The new default values are:</source>
          <target state="translated">Git にとって新しい設定オプションで、将来のデフォルト設定として検討されているものを有効にします。ここに含まれる設定は、マイナーバージョンの更新を含め、リリースのたびに追加されたり削除されたりする可能性があります。これらの設定は非常に新しいものなので、意図しない相互作用が発生する可能性があります。実験的な機能についてフィードバックを提供したい場合は、この設定を有効にしてください。新しいデフォルト値は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="8740fb3b16d2502b6a07330a252227f128574417" translate="yes" xml:space="preserve">
          <source>Enable config options that optimize for repos with many files in the working directory. With many files, commands such as &lt;code&gt;git status&lt;/code&gt; and &lt;code&gt;git checkout&lt;/code&gt; may be slow and these new defaults improve performance:</source>
          <target state="translated">作業ディレクトリに多くのファイルがあるリポジトリを最適化する構成オプションを有効にします。多くのファイルでは、 &lt;code&gt;git status&lt;/code&gt; や &lt;code&gt;git checkout&lt;/code&gt; などのコマンドが遅くなる可能性があり、これらの新しいデフォルトによりパフォーマンスが向上します。</target>
        </trans-unit>
        <trans-unit id="b62688a948f16b8896e24589781ecaee64693ffd" translate="yes" xml:space="preserve">
          <source>Enable displaying how much time and how many Git commands it took to generate and display each page in the page footer (at the bottom of page). For example the footer might contain: &quot;This page took 6.53325 seconds and 13 Git commands to generate.&quot; Disabled by default.</source>
          <target state="translated">各ページの生成にかかった時間と Git コマンドの数を表示し、各ページのフッター (ページの下部)に表示することを有効にします。たとえば、フッターには &quot;This page took 6.53325 seconds and 13 Git commands to generate.&quot; といった内容が表示されます。デフォルトでは無効になっています。</target>
        </trans-unit>
        <trans-unit id="c9bd131fb11e7d8a575c789c619c56115c835cfc" translate="yes" xml:space="preserve">
          <source>Enable displaying remote heads (remote-tracking branches) in the &quot;heads&quot; list. In most cases the list of remote-tracking branches is an unnecessary internal private detail, and this feature is therefore disabled by default. &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb[1]&lt;/a&gt;, which is usually used to browse local repositories, enables and uses this feature.</source>
          <target state="translated">「ヘッド」リストにリモートヘッド（リモートトラッキングブランチ）を表示できるようにします。ほとんどの場合、リモート追跡ブランチのリストは不必要な内部プライベート詳細であり、この機能はデフォルトで無効になっています。&lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb [1]&lt;/a&gt;は、通常ローカルリポジトリの参照に使用され、この機能を有効にして使用します。</target>
        </trans-unit>
        <trans-unit id="39da6c4d119e094eeb647ff45a2f63bf34d04c9c" translate="yes" xml:space="preserve">
          <source>Enable grep search, which lists the files in currently selected tree (directory) containing the given string; see &lt;a href=&quot;git-grep&quot;&gt;git-grep[1]&lt;/a&gt;. This can be potentially CPU-intensive, of course. Enabled by default.</source>
          <target state="translated">指定された文字列を含む現在選択されているツリー（ディレクトリ）内のファイルを一覧表示するgrep検索を有効にします。&lt;a href=&quot;git-grep&quot;&gt;git-grep [1]を&lt;/a&gt;参照してください。もちろん、これは潜在的にCPUに負荷がかかる可能性があります。デフォルトで有効になっています。</target>
        </trans-unit>
        <trans-unit id="393e4a210cdfd96d50c3abf9958899d9c77b22c9" translate="yes" xml:space="preserve">
          <source>Enable more strict checking, namely to catch a file mode recorded with g+w bit set, which was created by older versions of Git. Existing repositories, including the Linux kernel, Git itself, and sparse repository have old objects that triggers this check, but it is recommended to check new projects with this flag.</source>
          <target state="translated">より厳密なチェック、すなわち古いバージョンの Git で作成された g+w ビットがセットされた状態で記録されたファイルモードをキャッチすることを有効にします。Linuxカーネル、Git自体、スパースリポジトリなどの既存のリポジトリには、このチェックをトリガーする古いオブジェクトがありますが、新しいプロジェクトをチェックする際には、このフラグを立ててチェックすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="8081f1426d8047f2f5c9039fb2b3187c4aed51ad" translate="yes" xml:space="preserve">
          <source>Enable multipart/mixed attachments as the default for &lt;code&gt;format-patch&lt;/code&gt;. The value can also be a double quoted string which will enable attachments as the default and set the value as the boundary. See the --attach option in &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;format-patch&lt;/code&gt; のデフォルトとしてmultipart / mixed添付ファイルを有効にします。値は、デフォルトで添付ファイルを有効にし、境界として値を設定する二重引用符で囲んだ文字列にすることもできます。&lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]&lt;/a&gt;の--attachオプションを参照してください。</target>
        </trans-unit>
        <trans-unit id="d973b021f64131371542864785f310ed020b9e66" translate="yes" xml:space="preserve">
          <source>Enable or disable files system monitor feature. These options take effect whatever the value of the &lt;code&gt;core.fsmonitor&lt;/code&gt; configuration variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). But a warning is emitted when the change goes against the configured value, as the configured value will take effect next time the index is read and this will remove the intended effect of the option.</source>
          <target state="translated">ファイルシステムモニター機能を有効または無効にします。これらのオプションは、 &lt;code&gt;core.fsmonitor&lt;/code&gt; 構成変数の値が何であっても有効です（&lt;a href=&quot;git-config&quot;&gt;git-config [1]を&lt;/a&gt;参照）。ただし、変更が構成された値に対して行われると警告が発行されます。構成された値は、次にインデックスが読み取られたときに有効になり、これによりオプションの意図した効果が削除されるためです。</target>
        </trans-unit>
        <trans-unit id="d83423bb73684fa975c3f77aeba009920792cf88" translate="yes" xml:space="preserve">
          <source>Enable or disable split index mode. If split-index mode is already enabled and &lt;code&gt;--split-index&lt;/code&gt; is given again, all changes in $GIT_DIR/index are pushed back to the shared index file.</source>
          <target state="translated">分割インデックスモードを有効または無効にします。分割インデックスモードがすでに有効で、 &lt;code&gt;--split-index&lt;/code&gt; が再度指定されている場合、$ GIT_DIR / indexのすべての変更が共有インデックスファイルにプッシュバックされます。</target>
        </trans-unit>
        <trans-unit id="f8b0173e3fdc03c4e03595346f1584e741b798c1" translate="yes" xml:space="preserve">
          <source>Enable or disable untracked cache feature. Please use &lt;code&gt;--test-untracked-cache&lt;/code&gt; before enabling it.</source>
          <target state="translated">追跡されないキャッシュ機能を有効または無効にします。有効にする前に &lt;code&gt;--test-untracked-cache&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="5d058dbf876c4efd16b9ed5eae486a10be79bb86" translate="yes" xml:space="preserve">
          <source>Enable parallel index preload for operations like &lt;code&gt;git diff&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;git diff&lt;/code&gt; などの操作で並列インデックスのプリロードを有効にする</target>
        </trans-unit>
        <trans-unit id="1aa8a755e195170094ad7c0108b7874b637b96b6" translate="yes" xml:space="preserve">
          <source>Enable showing size of blobs (ordinary files) in a &quot;tree&quot; view, in a separate column, similar to what &lt;code&gt;ls -l&lt;/code&gt; does; see description of &lt;code&gt;-l&lt;/code&gt; option in &lt;a href=&quot;git-ls-tree&quot;&gt;git-ls-tree[1]&lt;/a&gt; manpage. This costs a bit of I/O. Enabled by default.</source>
          <target state="translated">&lt;code&gt;ls -l&lt;/code&gt; と同様に、「ツリー」ビューの別の列にblob（通常のファイル）のサイズを表示できるようにします。&lt;a href=&quot;git-ls-tree&quot;&gt;git-ls-tree [1]&lt;/a&gt;マンページの &lt;code&gt;-l&lt;/code&gt; オプションの説明を参照してください。これには少しI / Oがかかります。デフォルトで有効になっています。</target>
        </trans-unit>
        <trans-unit id="72fa50bb7bb0362a9a5efa2aa6f34941c4906089" translate="yes" xml:space="preserve">
          <source>Enable stricter reference checking by requiring an exact ref path. Aside from returning an error code of 1, it will also print an error message if &lt;code&gt;--quiet&lt;/code&gt; was not specified.</source>
          <target state="translated">正確な参照パスを要求することにより、より厳密な参照チェックを有効にします。 &lt;code&gt;--quiet&lt;/code&gt; が指定されていない場合、エラーコード1を返すだけでなく、エラーメッセージも出力します。</target>
        </trans-unit>
        <trans-unit id="48730f76cba5f67862630837d3f93d8ce9288066" translate="yes" xml:space="preserve">
          <source>Enable text search, which will list the commits which match author, committer or commit text to a given string; see the description of &lt;code&gt;--author&lt;/code&gt;, &lt;code&gt;--committer&lt;/code&gt; and &lt;code&gt;--grep&lt;/code&gt; options in &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; manpage. Enabled by default.</source>
          <target state="translated">テキスト検索を有効にします。これにより、作成者、コミッター、またはテキストを特定の文字列に一致させるコミットが一覧表示されます。&lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt;マンページの &lt;code&gt;--author&lt;/code&gt; 、-- &lt;code&gt;--committer&lt;/code&gt; および &lt;code&gt;--grep&lt;/code&gt; オプションの説明を参照してください。デフォルトで有効になっています。</target>
        </trans-unit>
        <trans-unit id="5bf942f17a0adbd66d5dff03794ede7ed6ce3a03" translate="yes" xml:space="preserve">
          <source>Enable the &quot;blame&quot; and &quot;blame_incremental&quot; blob views, showing for each line the last commit that modified it; see &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt;. This can be very CPU-intensive and is therefore disabled by default.</source>
          <target state="translated">「blame」および「blame_incremental」blobビューを有効にして、各行について、それを変更した最後のコミットを表示します。&lt;a href=&quot;git-blame&quot;&gt;git-blame [1]を&lt;/a&gt;参照してください。これはCPUを集中的に使用する可能性があるため、デフォルトでは無効になっています。</target>
        </trans-unit>
        <trans-unit id="d7fc03efc211d064bf3be01f125339a0be59fcba" translate="yes" xml:space="preserve">
          <source>Enable the &lt;code&gt;core.sparseCheckout&lt;/code&gt; setting. If the sparse-checkout file does not exist, then populate it with patterns that match every file in the root directory and no other directories, then will remove all directories tracked by Git. Add patterns to the sparse-checkout file to repopulate the working directory.</source>
          <target state="translated">&lt;code&gt;core.sparseCheckout&lt;/code&gt; 設定を有効にします。 sparse-checkoutファイルが存在しない場合は、ルートディレクトリ内のすべてのファイルに一致し、他のディレクトリには一致しないパターンを設定して、Gitが追跡するすべてのディレクトリを削除します。疎チェックアウトファイルにパターンを追加して、作業ディレクトリを再設定します。</target>
        </trans-unit>
        <trans-unit id="388296e4f7d314018094f8c18fc5c6de39a494b4" translate="yes" xml:space="preserve">
          <source>Enable the heuristic that shifts diff hunk boundaries to make patches easier to read. This is the default.</source>
          <target state="translated">パッチを読みやすくするために diff ハンクの境界をシフトするヒューリスティックを有効にします。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="01f1f887420f77509dbb30a6ca88007ca92eded6" translate="yes" xml:space="preserve">
          <source>Enable the reflog. Updates to a ref &amp;lt;ref&amp;gt; is logged to the file &quot;&lt;code&gt;$GIT_DIR/logs/&amp;lt;ref&amp;gt;&lt;/code&gt;&quot;, by appending the new and old SHA-1, the date/time and the reason of the update, but only when the file exists. If this configuration variable is set to &lt;code&gt;true&lt;/code&gt;, missing &quot;&lt;code&gt;$GIT_DIR/logs/&amp;lt;ref&amp;gt;&lt;/code&gt;&quot; file is automatically created for branch heads (i.e. under &lt;code&gt;refs/heads/&lt;/code&gt;), remote refs (i.e. under &lt;code&gt;refs/remotes/&lt;/code&gt;), note refs (i.e. under &lt;code&gt;refs/notes/&lt;/code&gt;), and the symbolic ref &lt;code&gt;HEAD&lt;/code&gt;. If it is set to &lt;code&gt;always&lt;/code&gt;, then a missing reflog is automatically created for any ref under &lt;code&gt;refs/&lt;/code&gt;.</source>
          <target state="translated">reflogを有効にします。参照&amp;lt;ref&amp;gt;への更新は、ファイル &quot; &lt;code&gt;$GIT_DIR/logs/&amp;lt;ref&amp;gt;&lt;/code&gt; &quot;に記録されます。これには、新旧のSHA-1、日付/時刻、更新の理由が追加されますが、ファイルが存在する場合のみです。 。この構成変数が &lt;code&gt;true&lt;/code&gt; に設定されている場合、欠落している「 &lt;code&gt;$GIT_DIR/logs/&amp;lt;ref&amp;gt;&lt;/code&gt; 」ファイルは、ブランチヘッド（つまり &lt;code&gt;refs/heads/&lt;/code&gt; 下）、リモートリファレンス（つまり &lt;code&gt;refs/remotes/&lt;/code&gt; 下）、メモrefs（つまり、 &lt;code&gt;refs/notes/&lt;/code&gt; ）、およびシンボリックref &lt;code&gt;HEAD&lt;/code&gt; の下にあります。 &lt;code&gt;always&lt;/code&gt; に設定されている場合、 &lt;code&gt;refs/&lt;/code&gt; 下のすべての参照に対して欠落している参照ログが自動的に作成されます。</target>
        </trans-unit>
        <trans-unit id="b50a25e099857665aa0b9ce95777350330756bcc" translate="yes" xml:space="preserve">
          <source>Enable the so called pickaxe search, which will list the commits that introduced or removed a given string in a file. This can be practical and quite faster alternative to &quot;blame&quot; action, but it is still potentially CPU-intensive. Enabled by default.</source>
          <target state="translated">いわゆる pickaxe 検索を有効にします。これは、ファイル内の特定の文字列を導入したり削除したりしたコミットをリストアップします。これは実用的で、&quot;blame &quot;アクションの代わりに非常に高速になりますが、CPU負荷が高くなる可能性があります。デフォルトでは有効になっています。</target>
        </trans-unit>
        <trans-unit id="e8928096a1d83fe75290fee4b17a3faa5d2c2864" translate="yes" xml:space="preserve">
          <source>Enable the specified feature. This requires that fast-import supports the specified feature, and aborts if it does not.</source>
          <target state="translated">指定された機能を有効にします。これはfast-importが指定された機能をサポートしている必要があり、サポートしていない場合はアボートします。</target>
        </trans-unit>
        <trans-unit id="cb33ed4fbb60981dda9e34bad99e8fe5205271b1" translate="yes" xml:space="preserve">
          <source>Enable/disable the service site-wide per default. Note that a service disabled site-wide can still be enabled per repository if it is marked overridable and the repository enables the service with a configuration item.</source>
          <target state="translated">デフォルトでサイト全体でサービスを有効化/無効化します。サイト全体で無効になっているサービスがオーバーライド可能とマークされていて、リポジトリが設定項目でサービスを有効にしている場合は、リポジトリごとに有効にすることができることに注意してください。</target>
        </trans-unit>
        <trans-unit id="35a563959614f6c71c72cc0395ec6a9ebde3235d" translate="yes" xml:space="preserve">
          <source>Enables (or disables) progress messages displayed by the transport helper during a command.</source>
          <target state="translated">コマンド中にトランスポートヘルパーが表示するプログレスメッセージを有効(または無効)にする。</target>
        </trans-unit>
        <trans-unit id="c889da55fe7b392cff2ceaa7f38c976ee6969838" translate="yes" xml:space="preserve">
          <source>Enables a curl full trace dump of all incoming and outgoing data, including descriptive information, of the git transport protocol. This is similar to doing curl &lt;code&gt;--trace-ascii&lt;/code&gt; on the command line. See &lt;code&gt;GIT_TRACE&lt;/code&gt; for available trace output options.</source>
          <target state="translated">gitトランスポートプロトコルのすべての着信および発信データ（説明情報を含む）のcurlフルトレースダンプを有効にします。これは、コマンドラインでcurl-- &lt;code&gt;--trace-ascii&lt;/code&gt; を実行するのと似ています。使用可能なトレース出力オプションについては、 &lt;code&gt;GIT_TRACE&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="55ef71c7bfb2fa4d7687d0c6a055c6d9acec70dd" translate="yes" xml:space="preserve">
          <source>Enables a curl full trace dump of all incoming and outgoing data, including descriptive information, of the git transport protocol. This is similar to doing curl &lt;code&gt;--trace-ascii&lt;/code&gt; on the command line. This option overrides setting the &lt;code&gt;GIT_CURL_VERBOSE&lt;/code&gt; environment variable. See &lt;code&gt;GIT_TRACE&lt;/code&gt; for available trace output options.</source>
          <target state="translated">gitトランスポートプロトコルのすべての送受信データ（説明情報を含む）のカールフルトレースダンプを有効にします。これは、コマンドラインでcurl &lt;code&gt;--trace-ascii&lt;/code&gt; を実行するのと似ています。このオプションは、 &lt;code&gt;GIT_CURL_VERBOSE&lt;/code&gt; 環境変数の設定をオーバーライドします。使用可能なトレース出力オプションについては、 &lt;code&gt;GIT_TRACE&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="6691f775d187ea6f64d054b6823e9e86f9c085bf" translate="yes" xml:space="preserve">
          <source>Enables general trace messages, e.g. alias expansion, built-in command execution and external command execution.</source>
          <target state="translated">一般的なトレースメッセージ(エイリアス展開、組み込みコマンド実行、外部コマンド実行など)を有効にします。</target>
        </trans-unit>
        <trans-unit id="e48905b14288617c8ceaa87834665d923c04c051" translate="yes" xml:space="preserve">
          <source>Enables more detailed trace messages from the &quot;trace2&quot; library. Output from &lt;code&gt;GIT_TRACE2&lt;/code&gt; is a simple text-based format for human readability.</source>
          <target state="translated">「trace2」ライブラリからのより詳細なトレースメッセージを有効にします。 &lt;code&gt;GIT_TRACE2&lt;/code&gt; からの出力は、人間が読みやすいように単純なテキストベースの形式です。</target>
        </trans-unit>
        <trans-unit id="660988c86be3da054f2d2df3321eefbdd55b0999" translate="yes" xml:space="preserve">
          <source>Enables performance related trace messages, e.g. total execution time of each Git command. See &lt;code&gt;GIT_TRACE&lt;/code&gt; for available trace output options.</source>
          <target state="translated">各Gitコマンドの合計実行時間など、パフォーマンス関連のトレースメッセージを有効にします。使用可能なトレース出力オプションについては、 &lt;code&gt;GIT_TRACE&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="dc7b8ed816ac9633bd1375cea1e49bf11b8f4cfe" translate="yes" xml:space="preserve">
          <source>Enables the &quot;cone mode&quot; of the sparse checkout feature. When the sparse-checkout file contains a limited set of patterns, then this mode provides significant performance advantages. See &lt;a href=&quot;git-sparse-checkout&quot;&gt;git-sparse-checkout[1]&lt;/a&gt; for more information.</source>
          <target state="translated">スパースチェックアウト機能の「コーンモード」を有効にします。スパースチェックアウトファイルに含まれるパターンのセットが限られている場合、このモードではパフォーマンスが大幅に向上します。詳細については、&lt;a href=&quot;git-sparse-checkout&quot;&gt;git-sparse-checkout [1]&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="69a28feccce4c72bcadfb900d39f7f184847d39a" translate="yes" xml:space="preserve">
          <source>Enables trace messages for all accesses to any packs. For each access, the pack file name and an offset in the pack is recorded. This may be helpful for troubleshooting some pack-related performance problems. See &lt;code&gt;GIT_TRACE&lt;/code&gt; for available trace output options.</source>
          <target state="translated">任意のパックへのすべてのアクセスのトレースメッセージを有効にします。アクセスごとに、パックファイル名とパック内のオフセットが記録されます。これは、いくつかのパック関連のパフォーマンス問題のトラブルシューティングに役立つ場合があります。使用可能なトレース出力オプションについては、 &lt;code&gt;GIT_TRACE&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="facc11ad57d6672e51f919b154eb028564e3944e" translate="yes" xml:space="preserve">
          <source>Enables trace messages for all packets coming in or out of a given program. This can help with debugging object negotiation or other protocol issues. Tracing is turned off at a packet starting with &quot;PACK&quot; (but see &lt;code&gt;GIT_TRACE_PACKFILE&lt;/code&gt; below). See &lt;code&gt;GIT_TRACE&lt;/code&gt; for available trace output options.</source>
          <target state="translated">特定のプログラムに出入りするすべてのパケットのトレースメッセージを有効にします。これは、オブジェクトネゴシエーションまたはその他のプロトコルの問題のデバッグに役立ちます。「PACK」で始まるパケットでトレースがオフになります（ただし、以下の &lt;code&gt;GIT_TRACE_PACKFILE&lt;/code&gt; を参照）。使用可能なトレース出力オプションについては、 &lt;code&gt;GIT_TRACE&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="edb9b39606e0f9447b27a5131ddede4062e0f50d" translate="yes" xml:space="preserve">
          <source>Enables trace messages for operations on the ref database. See &lt;code&gt;GIT_TRACE&lt;/code&gt; for available trace output options.</source>
          <target state="translated">refデータベースでの操作のトレースメッセージを有効にします。使用可能なトレース出力オプションについては、 &lt;code&gt;GIT_TRACE&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="3a96e0b90f936140e14c4f59157281584502b280" translate="yes" xml:space="preserve">
          <source>Enables trace messages for the filesystem monitor extension. See &lt;code&gt;GIT_TRACE&lt;/code&gt; for available trace output options.</source>
          <target state="translated">ファイルシステムモニター拡張のトレースメッセージを有効にします。使用可能なトレース出力オプションについては、 &lt;code&gt;GIT_TRACE&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="226b098ac2b03df2efedb4d6f3177d8a53d1323d" translate="yes" xml:space="preserve">
          <source>Enables trace messages printing the .git, working tree and current working directory after Git has completed its setup phase. See &lt;code&gt;GIT_TRACE&lt;/code&gt; for available trace output options.</source>
          <target state="translated">Gitがセットアップフェーズを完了した後、.git、作業ツリー、現在の作業ディレクトリを出力するトレースメッセージを有効にします。使用可能なトレース出力オプションについては、 &lt;code&gt;GIT_TRACE&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="0876ec8b14060e46110f6e776b65e26631e1613f" translate="yes" xml:space="preserve">
          <source>Enables trace messages that can help debugging fetching / cloning of shallow repositories. See &lt;code&gt;GIT_TRACE&lt;/code&gt; for available trace output options.</source>
          <target state="translated">浅いリポジトリのフェッチ/クローンのデバッグに役立つトレースメッセージを有効にします。使用可能なトレース出力オプションについては、 &lt;code&gt;GIT_TRACE&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="d9d84b12f1c34508f5365e4fa51faae6983f4d76" translate="yes" xml:space="preserve">
          <source>Enables tracing of packfiles sent or received by a given program. Unlike other trace output, this trace is verbatim: no headers, and no quoting of binary data. You almost certainly want to direct into a file (e.g., &lt;code&gt;GIT_TRACE_PACKFILE=/tmp/my.pack&lt;/code&gt;) rather than displaying it on the terminal or mixing it with other trace output.</source>
          <target state="translated">特定のプログラムによって送信または受信されたパックファイルのトレースを有効にします。他のトレース出力とは異なり、このトレースは逐語的です。ヘッダーもバイナリデータの引用もありません。ほとんどの場合、ファイルをターミナルに表示したり、他のトレース出力と混合したりするのではなく、ファイル（ &lt;code&gt;GIT_TRACE_PACKFILE=/tmp/my.pack&lt;/code&gt; など）に送りたいと思います。</target>
        </trans-unit>
        <trans-unit id="e7a1430764d62a995667824305a6bb53b99cb2fa" translate="yes" xml:space="preserve">
          <source>Enabling a Target</source>
          <target state="translated">ターゲットを有効にする</target>
        </trans-unit>
        <trans-unit id="619b6ac53993b275b163fbd1d47132e1851812f0" translate="yes" xml:space="preserve">
          <source>Encode email headers that have non-ASCII characters with &quot;Q-encoding&quot; (described in RFC 2047) for email transmission. Defaults to true.</source>
          <target state="translated">非ASCII文字を持つ電子メールヘッダを、電子メール送信用に「Q-encoding」(RFC2047で説明されている)でエンコードする。デフォルトは true です。</target>
        </trans-unit>
        <trans-unit id="aae00f8479c80f28e526371cda478b9f2e76f78a" translate="yes" xml:space="preserve">
          <source>Encode email headers that have non-ASCII characters with &quot;Q-encoding&quot; (described in RFC 2047), instead of outputting the headers verbatim. Defaults to the value of the &lt;code&gt;format.encodeEmailHeaders&lt;/code&gt; configuration variable.</source>
          <target state="translated">ヘッダーを逐語的に出力する代わりに、非ASCII文字を含む電子メールヘッダーを「Q-encoding」（RFC 2047で説明）でエンコードします。デフォルトは、 &lt;code&gt;format.encodeEmailHeaders&lt;/code&gt; 構成変数の値です。</target>
        </trans-unit>
        <trans-unit id="3ff218bfdfe647deb6f8afd9e1fb8602500fad3a" translate="yes" xml:space="preserve">
          <source>Encoding to use when displaying logs. (See &lt;code&gt;Discussion&lt;/code&gt; above.) Defaults to the value of &lt;code&gt;i18n.commitEncoding&lt;/code&gt; if set, and UTF-8 otherwise.</source>
          <target state="translated">ログを表示するときに使用するエンコーディング。（参照 &lt;code&gt;Discussion&lt;/code&gt; 上記。）の値にデフォルト &lt;code&gt;i18n.commitEncoding&lt;/code&gt; 設定されている場合、及びUTF-8さもなければ。</target>
        </trans-unit>
        <trans-unit id="89269a8275f94980b4ffe877e221e0d466987782" translate="yes" xml:space="preserve">
          <source>End-of-line conversion</source>
          <target state="translated">エンドオブライン変換</target>
        </trans-unit>
        <trans-unit id="ab7c0d7ed2b514b7971808ab6a9cdbd8fa7e7be5" translate="yes" xml:space="preserve">
          <source>Enhanced option parser</source>
          <target state="translated">強化されたオプションパーサー</target>
        </trans-unit>
        <trans-unit id="d48b2fd91c06d512d371b7025cd11deeb23b34ad" translate="yes" xml:space="preserve">
          <source>Ensure at least &amp;lt;n&amp;gt; lines of surrounding context match before and after each change. When fewer lines of surrounding context exist they all must match. By default no context is ever ignored.</source>
          <target state="translated">各変更の前後に、前後のコンテキストの少なくとも&amp;lt;n&amp;gt;行が一致することを確認してください。周囲のコンテキストの行が少ない場合、それらはすべて一致する必要があります。デフォルトでは、コンテキストは無視されません。</target>
        </trans-unit>
        <trans-unit id="40fd8773c6f206a9063f0067c04f352f2f44d8bc" translate="yes" xml:space="preserve">
          <source>Ensure at least &amp;lt;n&amp;gt; lines of surrounding context match before and after each change. When fewer lines of surrounding context exist they all must match. By default no context is ever ignored. Implies --apply.</source>
          <target state="translated">各変更の前後で、周囲のコンテキストの少なくとも&amp;lt;n&amp;gt;行が一致することを確認してください。周囲のコンテキストの行が少ない場合は、すべて一致する必要があります。デフォルトでは、コンテキストが無視されることはありません。--applyを意味します。</target>
        </trans-unit>
        <trans-unit id="6825ec27b2b654ed999d31628f8e31396467a23b" translate="yes" xml:space="preserve">
          <source>Ensure mod_cgi, mod_alias, and mod_env are enabled, set GIT_PROJECT_ROOT (or DocumentRoot) appropriately, and create a ScriptAlias to the CGI:</source>
          <target state="translated">mod_cgi、mod_alias、mod_envが有効になっていることを確認し、GIT_PROJECT_ROOT(またはDocumentRoot)を適切に設定し、CGIへのScriptAliasを作成します。</target>
        </trans-unit>
        <trans-unit id="136727d71b4774df6f61241cd1f96329e996c416" translate="yes" xml:space="preserve">
          <source>Ensure that &lt;code&gt;mod_cgi&lt;/code&gt;, &lt;code&gt;mod_alias&lt;/code&gt;, &lt;code&gt;mod_auth&lt;/code&gt;, &lt;code&gt;mod_setenv&lt;/code&gt; are loaded, then set &lt;code&gt;GIT_PROJECT_ROOT&lt;/code&gt; appropriately and redirect all requests to the CGI:</source>
          <target state="translated">ていることを確認し &lt;code&gt;mod_cgi&lt;/code&gt; の、 &lt;code&gt;mod_alias&lt;/code&gt; 、 &lt;code&gt;mod_auth&lt;/code&gt; 、 &lt;code&gt;mod_setenv&lt;/code&gt; ロードされ、その後、設定 &lt;code&gt;GIT_PROJECT_ROOT&lt;/code&gt; を適切にし、CGIへのすべての要求をリダイレクトします。</target>
        </trans-unit>
        <trans-unit id="05b99bf62f144f697a8ee2786cac4dbb9ea1f0fb" translate="yes" xml:space="preserve">
          <source>Ensures that a reference name is well formed</source>
          <target state="translated">参照名がしっかりと形成されていることを確認します。</target>
        </trans-unit>
        <trans-unit id="ced8b1d7750a47c0481b135a1b95578c79b545a4" translate="yes" xml:space="preserve">
          <source>Ensuring good performance</source>
          <target state="translated">パフォーマンスの確保</target>
        </trans-unit>
        <trans-unit id="bbdd824923a22a7ee366da56344be9b791387ca5" translate="yes" xml:space="preserve">
          <source>Ensuring reliability</source>
          <target state="translated">信頼性の確保</target>
        </trans-unit>
        <trans-unit id="35254b488f033ee2fce6cea7c360bd0f51157448" translate="yes" xml:space="preserve">
          <source>Enter &lt;code&gt;git name-rev&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;git name-rev&lt;/code&gt; と入力します。</target>
        </trans-unit>
        <trans-unit id="35cd2b0a8df7f89252ec5f994efe80c34ae3bb81" translate="yes" xml:space="preserve">
          <source>Entries that begin with &lt;code&gt;&quot;&lt;/code&gt; (double-quote) will be interpreted as C-style quoted paths, removing leading and trailing double-quotes and respecting backslash escapes. E.g., the value &lt;code&gt;&quot;path-with-\&quot;-and-:-in-it&quot;:vanilla-path&lt;/code&gt; has two paths: &lt;code&gt;path-with-&quot;-and-:-in-it&lt;/code&gt; and &lt;code&gt;vanilla-path&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;&lt;/code&gt; （二重引用符）で始まるエントリは、Cスタイルの引用符付きパスとして解釈され、先頭と末尾の二重引用符が削除され、バックスラッシュエスケープが考慮されます。たとえば、値 &lt;code&gt;&quot;path-with-\&quot;-and-:-in-it&quot;:vanilla-path&lt;/code&gt; with- \ &quot;-and-：-in- it &quot;：vanilla-pathには、 &lt;code&gt;path-with-&quot;-and-:-in-it&lt;/code&gt; と &lt;code&gt;vanilla-path&lt;/code&gt; の 2つのパスがあります。</target>
        </trans-unit>
        <trans-unit id="d443a1185575c125d61e0af393b044d7b06ef572" translate="yes" xml:space="preserve">
          <source>Environment</source>
          <target state="translated">Environment</target>
        </trans-unit>
        <trans-unit id="8403ba2a4a5aa9baffc30d3d46a39f555141e42f" translate="yes" xml:space="preserve">
          <source>Environment and configuration variables</source>
          <target state="translated">環境変数と設定変数</target>
        </trans-unit>
        <trans-unit id="1173b2e11bd16e5dc36c119a4b84f02be11626b5" translate="yes" xml:space="preserve">
          <source>Environment variables</source>
          <target state="translated">環境変数</target>
        </trans-unit>
        <trans-unit id="2e9c1d645028b692809462da156b1ceab497759c" translate="yes" xml:space="preserve">
          <source>Environment variables passed to command</source>
          <target state="translated">コマンドに渡される環境変数</target>
        </trans-unit>
        <trans-unit id="0939f663868ba2e69e812a3d630f787f9c5cfc8e" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&amp;lt;rev&amp;gt;^&amp;lt;n&amp;gt;..&amp;lt;rev&amp;gt;&lt;/code&gt;, with &lt;code&gt;&amp;lt;n&amp;gt;&lt;/code&gt; = 1 if not given.</source>
          <target state="translated">&lt;code&gt;&amp;lt;rev&amp;gt;^&amp;lt;n&amp;gt;..&amp;lt;rev&amp;gt;&lt;/code&gt; と同等で、指定されていない場合は &lt;code&gt;&amp;lt;n&amp;gt;&lt;/code&gt; = 1です。</target>
        </trans-unit>
        <trans-unit id="0c3185db11169cc7a29ed7dd80f79aa18ce0f759" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;--word-diff=color&lt;/code&gt; plus (if a regex was specified) &lt;code&gt;--word-diff-regex=&amp;lt;regex&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">相当 &lt;code&gt;--word-diff=color&lt;/code&gt; （正規表現が指定されている場合）に加え &lt;code&gt;--word-diff-regex=&amp;lt;regex&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fce804cbafec5e50fdfe3953fee8d48f776185de" translate="yes" xml:space="preserve">
          <source>Equivalent to passing &lt;code&gt;&amp;lt;base&amp;gt;..&amp;lt;rev1&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;base&amp;gt;..&amp;lt;rev2&amp;gt;&lt;/code&gt;. Note that &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; does not need to be the exact branch point of the branches. Example: after rebasing a branch &lt;code&gt;my-topic&lt;/code&gt;, &lt;code&gt;git range-diff my-topic@{u} my-topic@{1} my-topic&lt;/code&gt; would show the differences introduced by the rebase.</source>
          <target state="translated">&lt;code&gt;&amp;lt;base&amp;gt;..&amp;lt;rev1&amp;gt;&lt;/code&gt; および &lt;code&gt;&amp;lt;base&amp;gt;..&amp;lt;rev2&amp;gt;&lt;/code&gt; を渡すことと同等です。 &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; は、ブランチの正確なブランチポイントである必要はないことに注意してください。例：ブランチ &lt;code&gt;my-topic&lt;/code&gt; をリベースした後、 &lt;code&gt;git range-diff my-topic@{u} my-topic@{1} my-topic&lt;/code&gt; は、リベースによって導入された違いを示します。</target>
        </trans-unit>
        <trans-unit id="fee223c131ae45dd7f0054cc61edf8587521b104" translate="yes" xml:space="preserve">
          <source>Equivalent to passing &lt;code&gt;&amp;lt;rev2&amp;gt;..&amp;lt;rev1&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;rev1&amp;gt;..&amp;lt;rev2&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;rev2&amp;gt;..&amp;lt;rev1&amp;gt;&lt;/code&gt; および &lt;code&gt;&amp;lt;rev1&amp;gt;..&amp;lt;rev2&amp;gt;&lt;/code&gt; を渡すことと同等です。</target>
        </trans-unit>
        <trans-unit id="d9b3a0b879a412ed7b377d180ca1727a3b8f2d6d" translate="yes" xml:space="preserve">
          <source>Error out if the stream ends without a &lt;code&gt;done&lt;/code&gt; command. Without this feature, errors causing the frontend to end abruptly at a convenient point in the stream can go undetected. This may occur, for example, if an import front end dies in mid-operation without emitting SIGTERM or SIGKILL at its subordinate git fast-import instance.</source>
          <target state="translated">ストリームが &lt;code&gt;done&lt;/code&gt; コマンドなしで終了した場合、エラーになります。この機能がないと、ストリームの都合の良い場所でフロントエンドが突然終了するエラーが検出されない可能性があります。これは、たとえば、下位のgit高速インポートインスタンスでSIGTERMまたはSIGKILLを発行せずに、インポートフロントエンドが動作中に停止した場合に発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="137e434092ea32c83e7a34f0c9bc0aa62d172e84" translate="yes" xml:space="preserve">
          <source>Especially useful for interoperability with a foreign versioning system.</source>
          <target state="translated">特に海外のバージョニングシステムとの相互運用性を高めるのに便利です。</target>
        </trans-unit>
        <trans-unit id="058d99599bd9d3348c2826266e98651571ad20e7" translate="yes" xml:space="preserve">
          <source>Evaluates an arbitrary shell command in each checked out submodule. The command has access to the variables $name, $sm_path, $displaypath, $sha1 and $toplevel: $name is the name of the relevant submodule section in &lt;code&gt;.gitmodules&lt;/code&gt;, $sm_path is the path of the submodule as recorded in the immediate superproject, $displaypath contains the relative path from the current working directory to the submodules root directory, $sha1 is the commit as recorded in the immediate superproject, and $toplevel is the absolute path to the top-level of the immediate superproject. Note that to avoid conflicts with &lt;code&gt;$PATH&lt;/code&gt; on Windows, the &lt;code&gt;$path&lt;/code&gt; variable is now a deprecated synonym of &lt;code&gt;$sm_path&lt;/code&gt; variable. Any submodules defined in the superproject but not checked out are ignored by this command. Unless given &lt;code&gt;--quiet&lt;/code&gt;, foreach prints the name of each submodule before evaluating the command. If &lt;code&gt;--recursive&lt;/code&gt; is given, submodules are traversed recursively (i.e. the given shell command is evaluated in nested submodules as well). A non-zero return from the command in any submodule causes the processing to terminate. This can be overridden by adding &lt;code&gt;|| :&lt;/code&gt; to the end of the command.</source>
          <target state="translated">チェックアウトされた各サブモジュールで任意のシェルコマンドを評価します。コマンドは変数$ name、$ sm_path、$ displaypath、$ sha1、および$ toplevelにアクセスできます。$ nameは &lt;code&gt;.gitmodules&lt;/code&gt; の関連するサブモジュールセクションの名前、$ sm_pathは直接のスーパープロジェクトに記録されているサブモジュールのパスです、$ displaypathには現在の作業ディレクトリからサブモジュールのルートディレクトリへの相対パスが含まれ、$ sha1は直接のスーパープロジェクトに記録されているコミット、$ toplevelは直接のスーパープロジェクトのトップレベルへの絶対パスです。Windows での &lt;code&gt;$PATH&lt;/code&gt; との競合を回避するために、 &lt;code&gt;$path&lt;/code&gt; 変数は &lt;code&gt;$sm_path&lt;/code&gt; 非推奨の同義語になりました。変数。スーパープロジェクトで定義されているがチェックアウトされていないサブモジュールは、このコマンドでは無視されます。 &lt;code&gt;--quiet&lt;/code&gt; を指定しない限り、foreachはコマンドを評価する前に各サブモジュールの名前を出力します。 &lt;code&gt;--recursive&lt;/code&gt; が指定されている場合、サブモジュールは再帰的にトラバースされます（つまり、指定されたシェルコマンドはネストされたサブモジュールでも評価されます）。サブモジュールのコマンドからゼロ以外の値が返されると、処理が終了します。 &lt;code&gt;|| :&lt;/code&gt; を追加することでこれを上書きできます。：コマンドの終わりまで。</target>
        </trans-unit>
        <trans-unit id="3346640c72369c22dbe8ece1ce186df75f62b7da" translate="yes" xml:space="preserve">
          <source>Even if you don&amp;rsquo;t need to edit files but only want to e.g. rename or remove some and thus can avoid checking out each file (i.e. you can use --index-filter), you still are passing shell snippets for your filters. This means that for every commit, you have to have a prepared git repo where those filters can be run. That&amp;rsquo;s a significant setup.</source>
          <target state="translated">ファイルを編集する必要はないが、たとえば名前を変更するか、ファイルを削除するだけで各ファイルのチェックアウトを回避できる場合（つまり、-index-filterを使用できる場合）でも、フィルターのシェルスニペットを渡しています。つまり、すべてのコミットに対して、これらのフィルターを実行できるgitリポジトリを準備する必要があります。これは重要な設定です。</target>
        </trans-unit>
        <trans-unit id="5eb6ad0af0ebc64a82d836be8d647670a50936f8" translate="yes" xml:space="preserve">
          <source>Even if you hide refs, a client may still be able to steal the target objects via the techniques described in the &quot;SECURITY&quot; section of the &lt;a href=&quot;gitnamespaces&quot;&gt;gitnamespaces[7]&lt;/a&gt; man page; it&amp;rsquo;s best to keep private data in a separate repository.</source>
          <target state="translated">refを非表示にしても、&lt;a href=&quot;gitnamespaces&quot;&gt;gitnamespaces [7]の&lt;/a&gt; manページの「SECURITY」セクションで説明されている手法を使用して、クライアントがターゲットオブジェクトを盗む可能性があります。プライベートデータは別のリポジトリに保存することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="631b3a432b8ec594fabc393b96af10483ed3b9bf" translate="yes" xml:space="preserve">
          <source>Even if you may have local modifications in your working tree, you can safely say &lt;code&gt;git pull&lt;/code&gt; when you know that the change in the other branch does not overlap with them.</source>
          <target state="translated">作業ツリーにローカルの変更がある場合でも、他のブランチの変更がそれらと重複しないことがわかっている場合は、 &lt;code&gt;git pull&lt;/code&gt; と安全に言うことができます。</target>
        </trans-unit>
        <trans-unit id="e9dc426299074d12c83589e674bb08692f265116" translate="yes" xml:space="preserve">
          <source>Even when version sort is used in &lt;a href=&quot;git-tag&quot;&gt;git-tag[1]&lt;/a&gt;, tagnames with the same base version but different suffixes are still sorted lexicographically, resulting e.g. in prerelease tags appearing after the main release (e.g. &quot;1.0-rc1&quot; after &quot;1.0&quot;). This variable can be specified to determine the sorting order of tags with different suffixes.</source>
          <target state="translated">バージョンの並べ替えが&lt;a href=&quot;git-tag&quot;&gt;git-tag [1]&lt;/a&gt;で使用されている場合でも、ベースバージョンは同じでサフィックスが異なるタグ名は辞書順に並べ替えられるため、たとえばメインリリースの後にプレリリースタグが表示されます（たとえば「1.0」の後に「1.0-rc1」）。 。この変数を指定して、サフィックスが異なるタグのソート順を決定できます。</target>
        </trans-unit>
        <trans-unit id="9e079d1f744d65307fba536fb55c673ed5690ed3" translate="yes" xml:space="preserve">
          <source>Event-Specific Key/Value Pairs</source>
          <target state="translated">イベント固有のキー/値のペア</target>
        </trans-unit>
        <trans-unit id="574b5ade849d92dcfbdbf5ca26c3f1b37761f49f" translate="yes" xml:space="preserve">
          <source>Events are written as lines of the form:</source>
          <target state="translated">イベントは形式の行として書かれています。</target>
        </trans-unit>
        <trans-unit id="af0aec79a3d13a4c4b91dbf7a8bc02d48eb692d6" translate="yes" xml:space="preserve">
          <source>Eventually the conclusion started with:</source>
          <target state="translated">最終的には結論から始まりました。</target>
        </trans-unit>
        <trans-unit id="e1529d50cc2b2be76fa87bc3d3169dd428571183" translate="yes" xml:space="preserve">
          <source>Eventually there will be no more revisions left to inspect, and the command will print out a description of the first bad commit. The reference &lt;code&gt;refs/bisect/bad&lt;/code&gt; will be left pointing at that commit.</source>
          <target state="translated">最終的には検査するリビジョンがなくなり、コマンドは最初の不良コミットの説明を出力します。参照 &lt;code&gt;refs/bisect/bad&lt;/code&gt; は、そのコミットを指したままになります。</target>
        </trans-unit>
        <trans-unit id="33494a61e10c94c6a655dac5cf7ce556eb778f1d" translate="yes" xml:space="preserve">
          <source>Every change in the history of a project is represented by a commit. The &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt; command shows the most recent commit on the current branch:</source>
          <target state="translated">プロジェクトの履歴のすべての変更は、コミットによって表されます。&lt;a href=&quot;git-show&quot;&gt;gitのショー[1]&lt;/a&gt;最新のが現在のブランチにコミットコマンドショー：</target>
        </trans-unit>
        <trans-unit id="c0294fb403c28f35bf86f99624f936e70c163f9d" translate="yes" xml:space="preserve">
          <source>Every commit (except the very first commit in a project) also has a parent commit which shows what happened before this commit. Following the chain of parents will eventually take you back to the beginning of the project.</source>
          <target state="translated">すべてのコミット(プロジェクトの最初のコミットを除く)には、このコミットの前に何が起こったかを示す親コミットがあります。親コミットの連鎖をたどることで、最終的にはプロジェクトの最初に戻ることができます。</target>
        </trans-unit>
        <trans-unit id="2fd9540af511da41e4e859d7e772df1cd2e0716c" translate="yes" xml:space="preserve">
          <source>Every commit has a 40-hexdigit id, sometimes called the &quot;object name&quot; or the &quot;SHA-1 id&quot;, shown on the first line of the &lt;code&gt;git show&lt;/code&gt; output. You can usually refer to a commit by a shorter name, such as a tag or a branch name, but this longer name can also be useful. Most importantly, it is a globally unique name for this commit: so if you tell somebody else the object name (for example in email), then you are guaranteed that name will refer to the same commit in their repository that it does in yours (assuming their repository has that commit at all). Since the object name is computed as a hash over the contents of the commit, you are guaranteed that the commit can never change without its name also changing.</source>
          <target state="translated">すべてのコミットには40桁の16進数のIDがあり、「オブジェクト名」または「SHA-1 ID」と呼ばれることもあり、 &lt;code&gt;git show&lt;/code&gt; 出力の最初の行に表示されます。通常、タグやブランチ名などの短い名前でコミットを参照できますが、この長い名前も役立ちます。最も重要なのは、それがこのコミットのグローバルに一意の名前であることです。そのため、他の人にオブジェクト名（たとえば、電子メールで）を伝えると、その名前がリポジトリ内のコミットと同じコミットを参照することが保証されます（彼らのリポジトリがそのコミットを持っていると仮定します）。オブジェクト名はコミットの内容に対するハッシュとして計算されるため、名前も変更しない限り、コミットは決して変更できないことが保証されます。</target>
        </trans-unit>
        <trans-unit id="2c58cc3c4a4eeeefba12cfd52db7d6b22833ae51" translate="yes" xml:space="preserve">
          <source>Every commit usually has one &quot;parent&quot; commit which points to the previous state of the project:</source>
          <target state="translated">すべてのコミットには通常、プロジェクトの前の状態を指す &quot;親 &quot;コミットがあります。</target>
        </trans-unit>
        <trans-unit id="1a873d3296fdc5740fd2d57065300557ff50e9de" translate="yes" xml:space="preserve">
          <source>Every git repository is marked with a numeric version in the &lt;code&gt;core.repositoryformatversion&lt;/code&gt; key of its &lt;code&gt;config&lt;/code&gt; file. This version specifies the rules for operating on the on-disk repository data. An implementation of git which does not understand a particular version advertised by an on-disk repository MUST NOT operate on that repository; doing so risks not only producing wrong results, but actually losing data.</source>
          <target state="translated">すべてのgitリポジトリは、 &lt;code&gt;config&lt;/code&gt; ファイルの &lt;code&gt;core.repositoryformatversion&lt;/code&gt; キーで数値バージョンでマークされています。このバージョンは、ディスク上のリポジトリデータを操作するためのルールを指定します。ディスク上のリポジトリによってアドバタイズされた特定のバージョンを理解しないgitの実装は、そのリポジトリで動作してはなりません（MUST NOT）。これを行うと、間違った結果が生成されるだけでなく、実際にデータが失われる危険があります。</target>
        </trans-unit>
        <trans-unit id="62d7b4b8755b9c58dc64c45f9e43e9a1848ebae6" translate="yes" xml:space="preserve">
          <source>Every helper must support the &quot;capabilities&quot; command, which Git uses to determine what other commands the helper will accept. Those other commands can be used to discover and update remote refs, transport objects between the object database and the remote repository, and update the local object store.</source>
          <target state="translated">すべてのヘルパーは &quot;capabilities&quot; コマンドをサポートしなければなりません。これらのコマンドは、リモート参照の発見や更新、オブジェクトデータベースとリモートリポジトリの間でのオブジェクトの転送、ローカルのオブジェクトストアの更新などに使用できます。</target>
        </trans-unit>
        <trans-unit id="a5adcecab706a9dd84c1d3eebe8cd1a4069a04b5" translate="yes" xml:space="preserve">
          <source>Every non-overlapping match of the &amp;lt;regex&amp;gt; is considered a word. Anything between these matches is considered whitespace and ignored(!) for the purposes of finding differences. You may want to append &lt;code&gt;|[^[:space:]]&lt;/code&gt; to your regular expression to make sure that it matches all non-whitespace characters. A match that contains a newline is silently truncated(!) at the newline.</source>
          <target state="translated">&amp;lt;regex&amp;gt;の重複しない一致はすべて単語と見なされます。これらの一致の間にあるものはすべて空白と見なされ、違いを見つけるために無視（！）されます。正規表現に &lt;code&gt;|[^[:space:]]&lt;/code&gt; を追加して、空白以外のすべての文字と一致することを確認できます。改行を含む一致は、改行でサイレントに切り捨てられます（！）。</target>
        </trans-unit>
        <trans-unit id="ca9e8deab33d39332d7b528ab194c9573c58ac97" translate="yes" xml:space="preserve">
          <source>Every notes change creates a new commit at the specified notes ref. You can therefore inspect the history of the notes by invoking, e.g., &lt;code&gt;git log -p notes/commits&lt;/code&gt;. Currently the commit message only records which operation triggered the update, and the commit authorship is determined according to the usual rules (see &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt;). These details may change in the future.</source>
          <target state="translated">ノートが変更されるたびに、指定されたノート参照に新しいコミットが作成されます。したがって、たとえば &lt;code&gt;git log -p notes/commits&lt;/code&gt; を呼び出すことにより、メモの履歴を調べることができます。現在、コミットメッセージは更新をトリガーした操作のみを記録し、コミットの作成者は通常のルールに従って決定されます（&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]を&lt;/a&gt;参照）。これらの詳細は将来変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="5bfad9a034d5ed29730f0b4fba66efb6b1249b9d" translate="yes" xml:space="preserve">
          <source>Every once in a while have your frontend emit a &lt;code&gt;progress&lt;/code&gt; message to fast-import. The contents of the messages are entirely free-form, so one suggestion would be to output the current month and year each time the current commit date moves into the next month. Your users will feel better knowing how much of the data stream has been processed.</source>
          <target state="translated">時々、フロントエンドに &lt;code&gt;progress&lt;/code&gt; メッセージを出力させて高速インポートします。メッセージの内容は完全に自由形式であるため、現在のコミット日付が翌月に移動するたびに現在の月と年を出力することをお勧めします。ユーザーは、データストリームのどの程度が処理されたかをよく理解できます。</target>
        </trans-unit>
        <trans-unit id="cda48ad1074123130b527f02f3f1db8c4fd5c129" translate="yes" xml:space="preserve">
          <source>Every once in a while, &lt;code&gt;git repack&lt;/code&gt; the public repository. Go back to step 5. and continue working.</source>
          <target state="translated">&lt;code&gt;git repack&lt;/code&gt; 、gitは公開リポジトリを再パックします。手順5に戻り、作業を続けます。</target>
        </trans-unit>
        <trans-unit id="0196a37f323e9613bd5e5c6dc6db74a2907c6a83" translate="yes" xml:space="preserve">
          <source>Every time a client connects, first run an external command specified by the &amp;lt;path&amp;gt; with service name (e.g. &quot;upload-pack&quot;), path to the repository, hostname (%H), canonical hostname (%CH), IP address (%IP), and TCP port (%P) as its command-line arguments. The external command can decide to decline the service by exiting with a non-zero status (or to allow it by exiting with a zero status). It can also look at the $REMOTE_ADDR and &lt;code&gt;$REMOTE_PORT&lt;/code&gt; environment variables to learn about the requestor when making this decision.</source>
          <target state="translated">クライアントが接続するたびに、最初に&amp;lt;path&amp;gt;で指定された外部コマンドをサービス名（たとえば、「upload-pack」）、リポジトリへのパス、ホスト名（％H）、正規ホスト名（％CH）、IPアドレス（ ％IP）、およびコマンドライン引数としてのTCPポート（％P）。外部コマンドは、0以外のステータスで終了することにより（または0ステータスで終了することでサービスを許可することにより）サービスを拒否することを決定できます。また、$ REMOTE_ADDRおよび &lt;code&gt;$REMOTE_PORT&lt;/code&gt; 環境変数を調べて、この決定を行うときにリクエスターについて知ることができます。</target>
        </trans-unit>
        <trans-unit id="ed1e82e85b3b43f7a452c7545f1946734ba8fe78" translate="yes" xml:space="preserve">
          <source>Everyday Git</source>
          <target state="translated">毎日のGit</target>
        </trans-unit>
        <trans-unit id="30edee05f0b86fdef0d1b80bced0b054568a2749" translate="yes" xml:space="preserve">
          <source>Everyday Git With 20 Commands Or So</source>
          <target state="translated">20 個のコマンドを使った日常的な Git</target>
        </trans-unit>
        <trans-unit id="0043a64d3fef8a7a23f6cd840b45f8af10f67f75" translate="yes" xml:space="preserve">
          <source>Exact byte count format</source>
          <target state="translated">正確なバイト数のフォーマット</target>
        </trans-unit>
        <trans-unit id="6e07117d26445f4c876a2dd689294f11cef857f4" translate="yes" xml:space="preserve">
          <source>Examining an old version without creating a new branch</source>
          <target state="translated">新しいブランチを作成せずに古いバージョンを調べる</target>
        </trans-unit>
        <trans-unit id="d496fa33f8661db7b0850d74bbd80c109526f113" translate="yes" xml:space="preserve">
          <source>Examining branches from a remote repository</source>
          <target state="translated">リモートリポジトリからのブランチの検討</target>
        </trans-unit>
        <trans-unit id="bb504595062729729e7244c3229ce860c38e6b76" translate="yes" xml:space="preserve">
          <source>Examining dangling objects</source>
          <target state="translated">ぶら下がり物の検査</target>
        </trans-unit>
        <trans-unit id="9cb0f2fbccfd2e1df3b3fea66d90520dda3d9cf1" translate="yes" xml:space="preserve">
          <source>Examining the data</source>
          <target state="translated">データを調べる</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="cfd85acb33cc1367c953b61c1f0a7ad60c2565a2" translate="yes" xml:space="preserve">
          <source>Example 1: Your history contains commits by two authors, Jane and Joe, whose names appear in the repository under several forms:</source>
          <target state="translated">例 1:あなたの履歴には Jane と Joe という 2 人の作者によるコミットが含まれています。</target>
        </trans-unit>
        <trans-unit id="aa58f391e50840be9e94b87f72faa5f731cb5766" translate="yes" xml:space="preserve">
          <source>Example 2: Your repository contains commits from the following authors:</source>
          <target state="translated">例2:あなたのリポジトリには、以下の著者からのコミットが含まれています。</target>
        </trans-unit>
        <trans-unit id="8a76cea78511b0d3032b5011d701b256e4fa824c" translate="yes" xml:space="preserve">
          <source>Example contents:</source>
          <target state="translated">内容の例。</target>
        </trans-unit>
        <trans-unit id="ee2fa80210fe959342ddb79b523484b1b7a07d33" translate="yes" xml:space="preserve">
          <source>Example to exclude everything except a specific directory &lt;code&gt;foo/bar&lt;/code&gt; (note the &lt;code&gt;/*&lt;/code&gt; - without the slash, the wildcard would also exclude everything within &lt;code&gt;foo/bar&lt;/code&gt;):</source>
          <target state="translated">特定のディレクトリ &lt;code&gt;foo/bar&lt;/code&gt; を除くすべてを除外する例（ &lt;code&gt;/*&lt;/code&gt; に注意してください-スラッシュがない場合、ワイルドカードは &lt;code&gt;foo/bar&lt;/code&gt; 内のすべても除外します）：</target>
        </trans-unit>
        <trans-unit id="59e08af9047abc909e804faec8919301def86320" translate="yes" xml:space="preserve">
          <source>Example trace2 api usage</source>
          <target state="translated">trace2 api の使用例</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="523ae6b1873ceced0f776c362dc256ed64902255" translate="yes" xml:space="preserve">
          <source>Example: If you know that there was some test case for &lt;code&gt;git bundle&lt;/code&gt;, but do not remember where it was (yes, you &lt;code&gt;could&lt;/code&gt;&lt;code&gt;git grep bundle t/&lt;/code&gt;, but that does not illustrate the point!):</source>
          <target state="translated">例： &lt;code&gt;git bundle&lt;/code&gt; のテストケースがあることはわかっているが、どこにあったか覚えていない場合（そうです、 &lt;code&gt;git grep bundle t/&lt;/code&gt; を使用 &lt;code&gt;could&lt;/code&gt; ますが、それは要点を示していません！）：</target>
        </trans-unit>
        <trans-unit id="14e4d3109673cecf5094a599bce7b8cb418a458c" translate="yes" xml:space="preserve">
          <source>Example: Let commits &lt;code&gt;1--2&lt;/code&gt; be the first iteration of a patch series and &lt;code&gt;A--C&lt;/code&gt; the second iteration. Let&amp;rsquo;s assume that &lt;code&gt;A&lt;/code&gt; is a cherry-pick of &lt;code&gt;2,&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt; is a cherry-pick of &lt;code&gt;1&lt;/code&gt; but with a small modification (say, a fixed typo). Visualize the commits as a bipartite graph:</source>
          <target state="translated">例：コミット &lt;code&gt;1--2&lt;/code&gt; 一連のパッチの最初の反復、 &lt;code&gt;A--C&lt;/code&gt; 2番目の反復とします。さんがいると仮定しましょう &lt;code&gt;A&lt;/code&gt; がオブ選ぶ桜で &lt;code&gt;2,&lt;/code&gt; および &lt;code&gt;C&lt;/code&gt; はの-選ぶ桜である &lt;code&gt;1&lt;/code&gt; が、小さな変更（例えば、固定タイプミス）を持ちます。コミットを2部グラフとして視覚化します。</target>
        </trans-unit>
        <trans-unit id="d3bad2d15f343f55dc9f681daca1b6f3326d18b3" translate="yes" xml:space="preserve">
          <source>Example: The following will count changed files, while ignoring directories with less than 10% of the total amount of changed files, and accumulating child directory counts in the parent directories: &lt;code&gt;--dirstat=files,10,cumulative&lt;/code&gt;.</source>
          <target state="translated">例：次は、変更されたファイルをカウントしますが、変更されたファイルの合計量の10％未満のディレクトリを無視し、親ディレクトリに子ディレクトリのカウントを &lt;code&gt;--dirstat=files,10,cumulative&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e5998a18b5c87282a79f47b763c8725aa5e8349e" translate="yes" xml:space="preserve">
          <source>Example: The following will count changed files, while ignoring directories with less than 10% of the total amount of changed files, and accumulating child directory counts in the parent directories: &lt;code&gt;files,10,cumulative&lt;/code&gt;.</source>
          <target state="translated">例：次は、変更されたファイルをカウントしますが、変更されたファイルの合計量の10％未満のディレクトリは無視し、親ディレクトリに子ディレクトリのカウントを &lt;code&gt;files,10,cumulative&lt;/code&gt; ：files、10、cumulative。</target>
        </trans-unit>
        <trans-unit id="f7fe9add2c66b1dd7342bec4baea68d566885937" translate="yes" xml:space="preserve">
          <source>Example: let&amp;rsquo;s say I had renamed &lt;code&gt;commit.c&lt;/code&gt; to &lt;code&gt;git-commit.c&lt;/code&gt;, and I had done an &lt;code&gt;update-index&lt;/code&gt; to make that effective in the index file. &lt;code&gt;git diff-files&lt;/code&gt; wouldn&amp;rsquo;t show anything at all, since the index file matches my working directory. But doing a &lt;code&gt;git diff-index&lt;/code&gt; does:</source>
          <target state="translated">例：聞かせてのは、私が名前を変更していたと言う &lt;code&gt;commit.c&lt;/code&gt; をする &lt;code&gt;git-commit.c&lt;/code&gt; 、そして私が行っていた &lt;code&gt;update-index&lt;/code&gt; インデックスファイルにそれが効果的にするために。インデックスファイルは私の作業ディレクトリと一致するため、 &lt;code&gt;git diff-files&lt;/code&gt; は何も表示しません。しかし、 &lt;code&gt;git diff-index&lt;/code&gt; を実行すると、次のようになります。</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="22540b4db15515332cef1b1a56998eebfeba111a" translate="yes" xml:space="preserve">
          <source>Examples for &lt;code&gt;-c&lt;/code&gt; and &lt;code&gt;--cc&lt;/code&gt; without &lt;code&gt;--combined-all-paths&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;--combined-all-paths&lt;/code&gt; なしの &lt;code&gt;-c&lt;/code&gt; および &lt;code&gt;--cc&lt;/code&gt; の例：</target>
        </trans-unit>
        <trans-unit id="6ba2b2f11f2e1285e022c78a54e28e01334ece54" translate="yes" xml:space="preserve">
          <source>Examples when &lt;code&gt;--combined-all-paths&lt;/code&gt; added to either &lt;code&gt;-c&lt;/code&gt; or &lt;code&gt;--cc&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;--combined-all-paths&lt;/code&gt; が &lt;code&gt;-c&lt;/code&gt; または &lt;code&gt;--cc&lt;/code&gt; に追加された場合の例：</target>
        </trans-unit>
        <trans-unit id="b280d2c89a83a2bacb63527574e5853bea86f936" translate="yes" xml:space="preserve">
          <source>Examples.</source>
          <target state="translated">Examples.</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="24d0d5f830ca936a2b1158c4418847e58a17c132" translate="yes" xml:space="preserve">
          <source>Except for the &lt;code&gt;simple&lt;/code&gt; variant, command-line parameters are likely to change as git gains new features.</source>
          <target state="translated">&lt;code&gt;simple&lt;/code&gt; バリアントを除いて、gitが新機能を取得するにつれて、コマンドラインパラメータは変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="16cb9d6dc5634fc561d2d614f979976dfee73770" translate="yes" xml:space="preserve">
          <source>Except in a fast-forward merge (see above), the branches to be merged must be tied together by a merge commit that has both of them as its parents.</source>
          <target state="translated">早送りマージ (上記参照)の場合を除き、マージするブランチは、両方のブランチを親として持つマージコミットで結ばれていなければなりません。</target>
        </trans-unit>
        <trans-unit id="262c2a4eb81a10a2c9efd3343c2ae85fe92bbd6e" translate="yes" xml:space="preserve">
          <source>Exclude commits that are reachable from &amp;lt;rev&amp;gt; (i.e. &amp;lt;rev&amp;gt; and its ancestors).</source>
          <target state="translated">&amp;lt;rev&amp;gt;から到達可能なコミット（つまり、&amp;lt;rev&amp;gt;とその祖先）を除外します。</target>
        </trans-unit>
        <trans-unit id="f270c263f13543cd4c2b3020f92a691a85883aa7" translate="yes" xml:space="preserve">
          <source>Exclude patterns</source>
          <target state="translated">除外パターン</target>
        </trans-unit>
        <trans-unit id="87263b3bb52abcdab4a719253ddba1eca4b803f6" translate="yes" xml:space="preserve">
          <source>Exclude selected depot paths when cloning or syncing.</source>
          <target state="translated">複製や同期の際に、選択したデポパスを除外します。</target>
        </trans-unit>
        <trans-unit id="80be5859c8610b0a7e5a0e2227ba09cb8e75bd2e" translate="yes" xml:space="preserve">
          <source>Exclude the given pack from repacking. This is the equivalent of having &lt;code&gt;.keep&lt;/code&gt; file on the pack. &lt;code&gt;&amp;lt;pack-name&amp;gt;&lt;/code&gt; is the pack file name without leading directory (e.g. &lt;code&gt;pack-123.pack&lt;/code&gt;). The option could be specified multiple times to keep multiple packs.</source>
          <target state="translated">指定されたパックを再梱包から除外します。これは、パックに &lt;code&gt;.keep&lt;/code&gt; ファイルを置くのと同じです。 &lt;code&gt;&amp;lt;pack-name&amp;gt;&lt;/code&gt; は、先頭のディレクトリを除いたパックファイル名です（例： &lt;code&gt;pack-123.pack&lt;/code&gt; ）。このオプションを複数回指定して、複数のパックを保持できます。</target>
        </trans-unit>
        <trans-unit id="c21ad96ce2991b5c76c93826f8c1c709d756ef00" translate="yes" xml:space="preserve">
          <source>Exclude the specified patterns from the log decorations. This is similar to the &lt;code&gt;--decorate-refs-exclude&lt;/code&gt; command-line option, but the config option can be overridden by the &lt;code&gt;--decorate-refs&lt;/code&gt; option.</source>
          <target state="translated">指定されたパターンをログの装飾から除外します。これは &lt;code&gt;--decorate-refs-exclude&lt;/code&gt; コマンドラインオプションに似ていますが、configオプションは &lt;code&gt;--decorate-refs&lt;/code&gt; オプションで上書きできます。</target>
        </trans-unit>
        <trans-unit id="f719c666cee23f0f1f956fb1a3762ec3484afe81" translate="yes" xml:space="preserve">
          <source>Existing trailers are extracted from the input message by looking for a group of one or more lines that (i) is all trailers, or (ii) contains at least one Git-generated or user-configured trailer and consists of at least 25% trailers. The group must be preceded by one or more empty (or whitespace-only) lines. The group must either be at the end of the message or be the last non-whitespace lines before a line that starts with &lt;code&gt;---&lt;/code&gt; (followed by a space or the end of the line). Such three minus signs start the patch part of the message. See also &lt;code&gt;--no-divider&lt;/code&gt; below.</source>
          <target state="translated">既存のトレーラーは、（i）すべてがトレーラーである、または（ii）少なくとも1つのGit生成またはユーザー構成のトレーラーを含み、少なくとも25％のトレーラーで構成される1つ以上の行のグループを探すことにより、入力メッセージから抽出されます。 。グループの前には、1つ以上の空の（または空白のみの）行が必要です。グループはメッセージの最後にあるか、または &lt;code&gt;---&lt;/code&gt; で始まる行の前の最後の非空白行である必要があります（その後にスペースまたは行の終わりが続きます）。このような3つのマイナス記号は、メッセージのパッチ部分を開始します。以下の &lt;code&gt;--no-divider&lt;/code&gt; も参照してください。</target>
        </trans-unit>
        <trans-unit id="d3460174eb1c6ec5b3dd3ca9e87848d068de28a1" translate="yes" xml:space="preserve">
          <source>Exit code between 128 and 255 are special to &quot;git bisect run&quot;. They make it stop immediately the bisection process. This is useful for example if the command passed takes too long to complete, because you can kill it with a signal and it will stop the bisection process.</source>
          <target state="translated">128から255の間の終了コードは、&quot;git bisect run &quot;に特別なものです。これらのコードを使用すると、バイセクション処理を即座に停止させることができます。これは、例えば、渡されたコマンドが完了するまでに時間がかかりすぎる場合などに便利です。</target>
        </trans-unit>
        <trans-unit id="1de8b457f24c5f9f27dc6145c115a0b05b79738e" translate="yes" xml:space="preserve">
          <source>Exit difftool if the invoked diff tool returns a non-zero exit status.</source>
          <target state="translated">起動された diff ツールが 0 以外の終了ステータスを返した場合に difftool を終了します。</target>
        </trans-unit>
        <trans-unit id="105ec316e78b2e21f4200658aebb690c6bfce1c8" translate="yes" xml:space="preserve">
          <source>Exit status</source>
          <target state="translated">終了ステータス</target>
        </trans-unit>
        <trans-unit id="3a152e1aa09a1f7c436eafcd44ff191b58dde03b" translate="yes" xml:space="preserve">
          <source>Exit with a zero status even if no files matched.</source>
          <target state="translated">一致するファイルがない場合でも、ステータスが0の状態で終了します。</target>
        </trans-unit>
        <trans-unit id="f661c1461c19e28f4ca3bd981e37f108a510e5f9" translate="yes" xml:space="preserve">
          <source>Exit with status &quot;2&quot; when no matching refs are found in the remote repository. Usually the command exits with status &quot;0&quot; to indicate it successfully talked with the remote repository, whether it found any matching refs.</source>
          <target state="translated">リモートリポジトリにマッチする refs が見つからなかった場合は、ステータス &quot;2&quot; で終了します。通常、コマンドはリモートリポジトリとの対話に成功したことを示すステータス &quot;0&quot; で終了します。</target>
        </trans-unit>
        <trans-unit id="a5a799b0a561590f135d49ee5ebae00be685efb3" translate="yes" xml:space="preserve">
          <source>Exit with zero status if &amp;lt;object&amp;gt; exists and is a valid object. If &amp;lt;object&amp;gt; is of an invalid format exit with non-zero and emits an error on stderr.</source>
          <target state="translated">&amp;lt;object&amp;gt;が存在し、それが有効なオブジェクトである場合は、ステータスが0で終了します。&amp;lt;object&amp;gt;の形式が無効な場合は、ゼロ以外で終了し、stderrでエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="a4fd2157951095e7b5d26b7c3906810fced8fee9" translate="yes" xml:space="preserve">
          <source>Expand the URL of the given remote repository taking into account any &quot;url.&amp;lt;base&amp;gt;.insteadOf&quot; config setting (See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;) and exit without talking to the remote.</source>
          <target state="translated">&quot;url。&amp;lt;base&amp;gt; .insteadOf&quot;構成設定（&lt;a href=&quot;git-config&quot;&gt;git-config [1]を&lt;/a&gt;参照）を考慮して、指定されたリモートリポジトリのURL を展開し、リモートと対話せずに終了します。</target>
        </trans-unit>
        <trans-unit id="82a1b2399131b1d56f52c1e5725ea0754c8c3b25" translate="yes" xml:space="preserve">
          <source>Experimental. If set, clients will attempt to communicate with a server using the specified protocol version. If unset, no attempt will be made by the client to communicate using a particular protocol version, this results in protocol version 0 being used. Supported versions:</source>
          <target state="translated">実験用。設定されている場合、クライアントは指定されたプロトコルバージョンを使用してサーバとの通信を試みます。設定されていない場合、クライアントは特定のプロトコルバージョンを使用して通信を試みません。サポートされているバージョン。</target>
        </trans-unit>
        <trans-unit id="374e58867af910990ca1f09ab8f9576e68a9b14e" translate="yes" xml:space="preserve">
          <source>Experimental; for internal use only. Can attempt to connect to a remote server for communication using git&amp;rsquo;s wire-protocol version 2. See the documentation for the stateless-connect command for more information.</source>
          <target state="translated">実験的; 内部使用のみ。gitのワイヤープロトコルバージョン2を使用して、通信のためにリモートサーバーに接続を試みることができます。詳細については、stateless-connectコマンドのドキュメントをご覧ください。</target>
        </trans-unit>
        <trans-unit id="a6c1ea190613127e3c33180eee19de027a289612" translate="yes" xml:space="preserve">
          <source>Experimental; for internal use only. Connects to the given remote service for communication using git&amp;rsquo;s wire-protocol version 2. Valid replies to this command are empty line (connection established), &lt;code&gt;fallback&lt;/code&gt; (no smart transport support, fall back to dumb transports) and just exiting with error message printed (can&amp;rsquo;t connect, don&amp;rsquo;t bother trying to fall back). After line feed terminating the positive (empty) response, the output of the service starts. Messages (both request and response) must consist of zero or more PKT-LINEs, terminating in a flush packet. Response messages will then have a response end packet after the flush packet to indicate the end of a response. The client must not expect the server to store any state in between request-response pairs. After the connection ends, the remote helper exits.</source>
          <target state="translated">実験的;内部使用のみ。 gitのワイヤープロトコルバージョン2を使用して通信するために、指定されたリモートサービスに接続します。このコマンドへの有効な応答は、空の行（接続が確立されている）、 &lt;code&gt;fallback&lt;/code&gt; （スマートトランスポートのサポートなし、ダムトランスポートにフォールバック）、およびエラーメッセージが出力された状態で終了することです（接続できません。フォールバックしようとしないでください）。改行が肯定（空）応答を終了した後、サービスの出力が開始されます。メッセージ（要求と応答の両方）は、0個以上のPKT-LINEで構成され、フラッシュパケットで終了する必要があります。応答メッセージには、応答の終了を示すフラッシュパケットの後に応答終了パケットがあります。クライアントは、サーバーが要求と応答のペアの間に状態を格納することを期待してはなりません。接続が終了すると、リモートヘルパーが終了します。</target>
        </trans-unit>
        <trans-unit id="5ed48ec751df29bb5c7b56db740a48bfdffd6f47" translate="yes" xml:space="preserve">
          <source>Experimental; for internal use only. Connects to the given remote service for communication using git&amp;rsquo;s wire-protocol version 2. Valid replies to this command are empty line (connection established), &lt;code&gt;fallback&lt;/code&gt; (no smart transport support, fall back to dumb transports) and just exiting with error message printed (can&amp;rsquo;t connect, don&amp;rsquo;t bother trying to fall back). After line feed terminating the positive (empty) response, the output of the service starts. Messages (both request and response) must consist of zero or more PKT-LINEs, terminating in a flush packet. The client must not expect the server to store any state in between request-response pairs. After the connection ends, the remote helper exits.</source>
          <target state="translated">実験的; 内部使用のみ。gitのワイヤプロトコルバージョン2を使用して、通信のために指定されたリモートサービスに接続します。このコマンドへの有効な応答は、空の行（接続が確立）、 &lt;code&gt;fallback&lt;/code&gt; （スマートトランスポートサポートなし、ダムトランスポートにフォールバック）、エラーメッセージが出力されて終了します（接続できない、フォールバックしようとしないでください）。肯定（空）応答を終了する改行後、サービスの出力が開始されます。メッセージ（要求と応答の両方）は、ゼロ個以上のPKT-LINEで構成され、フラッシュパケットで終了する必要があります。クライアントは、サーバーが要求と応答のペアの間に状態を格納することを期待してはなりません。接続が終了すると、リモートヘルパーが終了します。</target>
        </trans-unit>
        <trans-unit id="e024c1b1cf5dfc23f1661897286cc082f5684cef" translate="yes" xml:space="preserve">
          <source>Expire all reflogs with &lt;code&gt;git reflog expire --expire=now --all&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git reflog expire --expire=now --all&lt;/code&gt; ですべてのreflogを期限切れにします。</target>
        </trans-unit>
        <trans-unit id="4f38f9dff86033ea204fa903651e0d6603ef28dd" translate="yes" xml:space="preserve">
          <source>Explicitly allow or ban the object filter corresponding to &lt;code&gt;&amp;lt;filter&amp;gt;&lt;/code&gt;, where &lt;code&gt;&amp;lt;filter&amp;gt;&lt;/code&gt; may be one of: &lt;code&gt;blob:none&lt;/code&gt;, &lt;code&gt;blob:limit&lt;/code&gt;, &lt;code&gt;tree&lt;/code&gt;, &lt;code&gt;sparse:oid&lt;/code&gt;, or &lt;code&gt;combine&lt;/code&gt;. If using combined filters, both &lt;code&gt;combine&lt;/code&gt; and all of the nested filter kinds must be allowed. Defaults to &lt;code&gt;uploadpackfilter.allow&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;filter&amp;gt;&lt;/code&gt; に対応するオブジェクトフィルターを明示的に許可または禁止します。 &lt;code&gt;&amp;lt;filter&amp;gt;&lt;/code&gt; は、 &lt;code&gt;blob:limit&lt;/code&gt; &lt;code&gt;blob:none&lt;/code&gt; 、blob：limit、 &lt;code&gt;tree&lt;/code&gt; 、 &lt;code&gt;sparse:oid&lt;/code&gt; 、 &lt;code&gt;combine&lt;/code&gt; のいずれかになります。結合フィルターを使用する場合は、 &lt;code&gt;combine&lt;/code&gt; とネストされたすべてのフィルターの種類の両方を許可する必要があります。デフォルトは &lt;code&gt;uploadpackfilter.allow&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="ee5da57f58adf9c1ddf8dd03613cf7957a586adf" translate="yes" xml:space="preserve">
          <source>Exploring git history</source>
          <target state="translated">git の歴史を探る</target>
        </trans-unit>
        <trans-unit id="89032b84259ca753da6ee3335cc874eda5aea88c" translate="yes" xml:space="preserve">
          <source>Exploring history</source>
          <target state="translated">歴史を探る</target>
        </trans-unit>
        <trans-unit id="9594b6cd33e22cedcea0b51e30d878456e8b0103" translate="yes" xml:space="preserve">
          <source>Export Git tags to p4 labels, as per --export-labels.</source>
          <target state="translated">export-labels のように、Git タグを p4 ラベルにエクスポートします。</target>
        </trans-unit>
        <trans-unit id="1d5637309048195a7021fdbec654e04c3399ceec" translate="yes" xml:space="preserve">
          <source>Export a single commit to a CVS checkout</source>
          <target state="translated">単一のコミットを CVS チェックアウトにエクスポートする</target>
        </trans-unit>
        <trans-unit id="3b1e75b4d51f1271061fcd403a0829e4ee2dbe12" translate="yes" xml:space="preserve">
          <source>Export files with a prefix</source>
          <target state="translated">接頭辞付きのファイルをエクスポートする</target>
        </trans-unit>
        <trans-unit id="265e5cf875ec82b17c2d01a82792a32a43a95b55" translate="yes" xml:space="preserve">
          <source>Export tags from Git as p4 labels. Tags found in Git are applied to the perforce working directory.</source>
          <target state="translated">Git からタグを p4 ラベルとしてエクスポートします。Gitで見つけたタグは、perforceの作業ディレクトリに適用されます。</target>
        </trans-unit>
        <trans-unit id="e1e5965077094d7c4756e516413e72a854f313c9" translate="yes" xml:space="preserve">
          <source>Exporting a Git repository via the Git protocol</source>
          <target state="translated">Git プロトコルによる Git リポジトリのエクスポート</target>
        </trans-unit>
        <trans-unit id="70581f8681dac905a7c1fddd025df98d77759bfd" translate="yes" xml:space="preserve">
          <source>Exporting a git repository via HTTP</source>
          <target state="translated">HTTP で git リポジトリをエクスポートする</target>
        </trans-unit>
        <trans-unit id="7d0c2b669436b3c66b28c30bf0f8b2f1227f2bfb" translate="yes" xml:space="preserve">
          <source>Exports a commit from Git to a CVS checkout, making it easier to merge patches from a Git repository into a CVS repository.</source>
          <target state="translated">Git から CVS チェックアウトにコミットをエクスポートし、Git リポジトリから CVS リポジトリへのパッチのマージを容易にします。</target>
        </trans-unit>
        <trans-unit id="91d81689bc4c223caafef827873bd7159612ae71" translate="yes" xml:space="preserve">
          <source>External Systems</source>
          <target state="translated">外部システム</target>
        </trans-unit>
        <trans-unit id="fa9abe3df3ff3676c618be0248e4529ceae9c936" translate="yes" xml:space="preserve">
          <source>External data format</source>
          <target state="translated">外部データ形式</target>
        </trans-unit>
        <trans-unit id="0b01e11ac46c849a71c428abcd94e12009d5387f" translate="yes" xml:space="preserve">
          <source>Extract all commits that lead to &lt;code&gt;origin&lt;/code&gt; since the inception of the project:</source>
          <target state="translated">プロジェクトの開始以来、 &lt;code&gt;origin&lt;/code&gt; つながるすべてのコミットを抽出します。</target>
        </trans-unit>
        <trans-unit id="86dd39e46e8ada53c01392c7b98857ff781b5490" translate="yes" xml:space="preserve">
          <source>Extract all commits which are in the current branch but not in the origin branch:</source>
          <target state="translated">現在のブランチにあるが、元のブランチにはないすべてのコミットを抽出します。</target>
        </trans-unit>
        <trans-unit id="293a4ac8183e30cb22a3c912e62cea8f83a17a45" translate="yes" xml:space="preserve">
          <source>Extract commit ID from an archive created using git-archive</source>
          <target state="translated">git-archive で作成したアーカイブからコミット ID を抽出する</target>
        </trans-unit>
        <trans-unit id="e52c75685be818f69a594f72535500e2b5f0de7d" translate="yes" xml:space="preserve">
          <source>Extract commits between revisions R1 and R2, and apply them on top of the current branch using &lt;code&gt;git am&lt;/code&gt; to cherry-pick them:</source>
          <target state="translated">リビジョンR1とR2の間のコミットを抽出し、 &lt;code&gt;git am&lt;/code&gt; を使用して現在のブランチの上に適用し、それらをチェリーピックします。</target>
        </trans-unit>
        <trans-unit id="a8d5387dbff833fee6e262477f3c484440daa076" translate="yes" xml:space="preserve">
          <source>Extract the last commit as a patch, and add a &lt;code&gt;Cc&lt;/code&gt; and a &lt;code&gt;Reviewed-by&lt;/code&gt; trailer to it:</source>
          <target state="translated">最後のコミットをパッチとして抽出し、それに &lt;code&gt;Cc&lt;/code&gt; とReview &lt;code&gt;Reviewed-by&lt;/code&gt; トレーラーを追加します。</target>
        </trans-unit>
        <trans-unit id="d9851ec1c9a62576efac72204eb04797ad73e77a" translate="yes" xml:space="preserve">
          <source>Extract three topmost commits from the current branch and format them as e-mailable patches:</source>
          <target state="translated">現在のブランチから一番上の三つのコミットを抽出し、それらをメール可能なパッチとしてフォーマットします。</target>
        </trans-unit>
        <trans-unit id="849870ce78e05c63608a62580dff149aaa2767a8" translate="yes" xml:space="preserve">
          <source>Extracted diagnostics</source>
          <target state="translated">抽出された診断</target>
        </trans-unit>
        <trans-unit id="fd728d82ed551d8e8658407681eee58615e4b172" translate="yes" xml:space="preserve">
          <source>Extracts patch and authorship from a single e-mail message</source>
          <target state="translated">単一の電子メールメッセージからパッチとオーサリングを抽出</target>
        </trans-unit>
        <trans-unit id="77dbd3520a3a25fa2f64b3a79e8cdd2c5b438dfc" translate="yes" xml:space="preserve">
          <source>False by default.</source>
          <target state="translated">デフォルトではFalseです。</target>
        </trans-unit>
        <trans-unit id="8f5880afd2dba5ba402b936eb6b908e040c6c17a" translate="yes" xml:space="preserve">
          <source>Fast-forward merge</source>
          <target state="translated">早送りマージ</target>
        </trans-unit>
        <trans-unit id="235360a9581b02e6b66f950074d19d23f01883c5" translate="yes" xml:space="preserve">
          <source>Fast-forward merges</source>
          <target state="translated">早送りマージ</target>
        </trans-unit>
        <trans-unit id="4b4c24663902945e814f463b99629f081662828a" translate="yes" xml:space="preserve">
          <source>Features in &lt;code&gt;%feature&lt;/code&gt;</source>
          <target state="translated">内特長 &lt;code&gt;%feature&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ac7a3c81a6bcc5d5ecdbb8a42e39a3cabf204420" translate="yes" xml:space="preserve">
          <source>Fetch &amp;lt;n&amp;gt; log entries per request when scanning Subversion history. The default is 100. For very large Subversion repositories, larger values may be needed for &lt;code&gt;clone&lt;/code&gt;/&lt;code&gt;fetch&lt;/code&gt; to complete in reasonable time. But overly large values may lead to higher memory usage and request timeouts.</source>
          <target state="translated">Subversion履歴をスキャンするときに、リクエストごとに&amp;lt;n&amp;gt;ログエントリを取得します。デフォルトは100です。非常に大きなSubversionリポジトリの場合、 &lt;code&gt;clone&lt;/code&gt; / &lt;code&gt;fetch&lt;/code&gt; が妥当な時間で完了するには、より大きな値が必要になる場合があります。ただし、値が大きすぎると、メモリ使用量とリクエストのタイムアウトが高くなる可能性があります。</target>
        </trans-unit>
        <trans-unit id="5fa9cbd39c84571e7bd481863d7516ff6663aa26" translate="yes" xml:space="preserve">
          <source>Fetch a &quot;thin&quot; pack, which records objects in deltified form based on objects not included in the pack to reduce network traffic.</source>
          <target state="translated">ネットワークトラフィックを削減するために、パックに含まれていないオブジェクトに基づいてデルタ化された形でオブジェクトを記録する「シン」パックをフェッチします。</target>
        </trans-unit>
        <trans-unit id="bfa61173eb5ea4c62442430cdd5a0f9a2ccdc304" translate="yes" xml:space="preserve">
          <source>Fetch a branch from a different repository, and give it a new name in your repository:</source>
          <target state="translated">別のリポジトリからブランチを取得し、リポジトリ内で新しい名前を付けます。</target>
        </trans-unit>
        <trans-unit id="5f0a6423762963194f97ca1e3c9e8131a33fa3bd" translate="yes" xml:space="preserve">
          <source>Fetch a branch in a different Git repository, then merge into the current branch:</source>
          <target state="translated">別の Git リポジトリにあるブランチを取得し、現在のブランチにマージします。</target>
        </trans-unit>
        <trans-unit id="4b2c92720b4e036e2e3a513a4ac4888b092fd45b" translate="yes" xml:space="preserve">
          <source>Fetch all remote refs.</source>
          <target state="translated">すべてのリモート参照を取得します。</target>
        </trans-unit>
        <trans-unit id="fc6f62670a87982450c7fd1465c966b498d51b73" translate="yes" xml:space="preserve">
          <source>Fetch all remotes.</source>
          <target state="translated">すべてのリモコンを取得します。</target>
        </trans-unit>
        <trans-unit id="7176a82579f2b775ede7e6b5698f625105e5e80d" translate="yes" xml:space="preserve">
          <source>Fetch all tags from the remote (i.e., fetch remote tags &lt;code&gt;refs/tags/*&lt;/code&gt; into local tags with the same name), in addition to whatever else would otherwise be fetched. Using this option alone does not subject tags to pruning, even if --prune is used (though tags may be pruned anyway if they are also the destination of an explicit refspec; see &lt;code&gt;--prune&lt;/code&gt;).</source>
          <target state="translated">他の方法でフェッチされるものに加えて、リモートからすべてのタグをフェッチします（つまり、リモートタグ &lt;code&gt;refs/tags/*&lt;/code&gt; を同じ名前のローカルタグにフェッチします）。（彼らはまた、明示的なrefspecの目的地である場合にタグがとにかく剪定することができるものの、見るだけでは、このオプションを使用すると、--pruneが使用されている場合でも、プルーニングの対象とならないタグを行い &lt;code&gt;--prune&lt;/code&gt; を）。</target>
        </trans-unit>
        <trans-unit id="24eb114caf72bd86613f02567ef244ced32c67f3" translate="yes" xml:space="preserve">
          <source>Fetch branches and/or tags (collectively, &quot;refs&quot;) from one or more other repositories, along with the objects necessary to complete their histories. Remote-tracking branches are updated (see the description of &amp;lt;refspec&amp;gt; below for ways to control this behavior).</source>
          <target state="translated">1つ以上の他のリポジトリからブランチやタグ（まとめて「refs」）を、それらの履歴を完成するために必要なオブジェクトとともにフェッチします。リモート追跡ブランチが更新されました（この動作を制御する方法については、以下の&amp;lt;refspec&amp;gt;の説明を参照してください）。</target>
        </trans-unit>
        <trans-unit id="31082e75ce46d9d1d50a3e2e4d3442657ed8677f" translate="yes" xml:space="preserve">
          <source>Fetch from and integrate with another repository or a local branch</source>
          <target state="translated">他のリポジトリやローカルブランチからの取得と統合</target>
        </trans-unit>
        <trans-unit id="31bd9486b123aa2097f6934aa8fc09cb0582f241" translate="yes" xml:space="preserve">
          <source>Fetch master, using file descriptor #17 to communicate with git-upload-pack.</source>
          <target state="translated">マスターを取得し、ファイルディスクリプター #17 を使用して git-upload-pack と通信します。</target>
        </trans-unit>
        <trans-unit id="c7b7a55dc86420061c3ee2c8e313312034e265da" translate="yes" xml:space="preserve">
          <source>Fetch only from the SVN parent of the current HEAD.</source>
          <target state="translated">現在のHEADのSVN親からのみ取得します。</target>
        </trans-unit>
        <trans-unit id="ab869fa62e8a09f8f5c922fc9c36375323cdbbc8" translate="yes" xml:space="preserve">
          <source>Fetch unfetched revisions from the Subversion remote we are tracking. The name of the [svn-remote &quot;&amp;hellip;​&quot;] section in the $GIT_DIR/config file may be specified as an optional command-line argument.</source>
          <target state="translated">追跡していないSubversionリモートからフェッチされていないリビジョンをフェッチします。$ GIT_DIR / configファイルの[svn-remote &quot;&amp;hellip;&quot;]セクションの名前は、オプションのコマンドライン引数として指定できます。</target>
        </trans-unit>
        <trans-unit id="280e77f3e0aa84ca742f26ca190cb5692edeefd2" translate="yes" xml:space="preserve">
          <source>Fetch updates for remotes or remote groups in the repository as defined by &lt;code&gt;remotes.&amp;lt;group&amp;gt;&lt;/code&gt;. If neither group nor remote is specified on the command line, the configuration parameter remotes.default will be used; if remotes.default is not defined, all remotes which do not have the configuration parameter &lt;code&gt;remote.&amp;lt;name&amp;gt;.skipDefaultUpdate&lt;/code&gt; set to true will be updated. (See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;remotes.&amp;lt;group&amp;gt;&lt;/code&gt; 定義されているように、リポジトリ内のリモートまたはリモートグループの更新をフェッチします。コマンドラインでgroupもremoteも指定されていない場合、構成パラメーターremotes.defaultが使用されます。 remotes.defaultが定義されていない場合、構成パラメーター &lt;code&gt;remote.&amp;lt;name&amp;gt;.skipDefaultUpdate&lt;/code&gt; がtrueに設定されていないすべてのリモートが更新されます。 （&lt;a href=&quot;git-config&quot;&gt;git-config [1]を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="15a003694d110886a95c99728ccaa08a956586a4" translate="yes" xml:space="preserve">
          <source>Fetch updates for remotes or remote groups in the repository as defined by remotes.&amp;lt;group&amp;gt;. If neither group nor remote is specified on the command line, the configuration parameter remotes.default will be used; if remotes.default is not defined, all remotes which do not have the configuration parameter remote.&amp;lt;name&amp;gt;.skipDefaultUpdate set to true will be updated. (See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">remotes。&amp;lt;group&amp;gt;で定義されているリポジトリ内のリモートまたはリモートグループの更新をフェッチします。コマンドラインでグループもリモートも指定されていない場合、構成パラメーターremotes.defaultが使用されます。remotes.defaultが定義されていない場合、構成パラメーターremote。&amp;lt;name&amp;gt; .skipDefaultUpdateがtrueに設定されていないすべてのリモートが更新されます。（&lt;a href=&quot;git-config&quot;&gt;git-config [1]を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="82e98a6b98be0542f3ca46bd6c66454d11bde6bb" translate="yes" xml:space="preserve">
          <source>Fetches the given object, writing the necessary objects to the database. Fetch commands are sent in a batch, one per line, terminated with a blank line. Outputs a single blank line when all fetch commands in the same batch are complete. Only objects which were reported in the output of &lt;code&gt;list&lt;/code&gt; with a sha1 may be fetched this way.</source>
          <target state="translated">指定されたオブジェクトをフェッチして、必要なオブジェクトをデータベースに書き込みます。フェッチコマンドは、1行に1つずつバッチで送信され、空白行で終了します。同じバッチ内のすべてのフェッチコマンドが完了したときに、1つの空白行を出力します。この方法でフェッチできるのは、sha1 を使用して &lt;code&gt;list&lt;/code&gt; の出力で報告されたオブジェクトのみです。</target>
        </trans-unit>
        <trans-unit id="5e512ef616863b90580db01bc69e67097028beb3" translate="yes" xml:space="preserve">
          <source>Fetching a &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt; means to get the branch&amp;rsquo;s &lt;a href=&quot;#def_head_ref&quot;&gt;head ref&lt;/a&gt; from a remote &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt;, to find out which objects are missing from the local &lt;a href=&quot;#def_object_database&quot;&gt;object database&lt;/a&gt;, and to get them, too. See also &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#def_branch&quot;&gt;ブランチ&lt;/a&gt;をフェッチするということは、リモート&lt;a href=&quot;#def_repository&quot;&gt;リポジトリ&lt;/a&gt;からブランチの&lt;a href=&quot;#def_head_ref&quot;&gt;ヘッドリファレンス&lt;/a&gt;を取得し、ローカル&lt;a href=&quot;#def_object_database&quot;&gt;オブジェクトデータベース&lt;/a&gt;から欠落しているオブジェクトを見つけ、それらも取得することを意味します。&lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="ca528f4260a5f0ff38dd8302ddb33ede05c8ee7e" translate="yes" xml:space="preserve">
          <source>Fetching branches from other repositories</source>
          <target state="translated">他のリポジトリからのブランチの取得</target>
        </trans-unit>
        <trans-unit id="38fdecc5037849cb76e9ff10175400ab8d8520f4" translate="yes" xml:space="preserve">
          <source>Fetching from a remote repository is done by, unsurprisingly, &lt;code&gt;git fetch&lt;/code&gt;:</source>
          <target state="translated">当然のことながら、リモートリポジトリからの &lt;code&gt;git fetch&lt;/code&gt; はgit fetchによって行われます。</target>
        </trans-unit>
        <trans-unit id="66837c163f00048d36bcb5882cef29f3589ed957" translate="yes" xml:space="preserve">
          <source>Fetching individual branches</source>
          <target state="translated">個々のブランチの取得</target>
        </trans-unit>
        <trans-unit id="95fb769cdd33ccd5fcde15b12c59c0228df81279" translate="yes" xml:space="preserve">
          <source>Field names</source>
          <target state="translated">フィールド名</target>
        </trans-unit>
        <trans-unit id="7d4e1fd5661dae539542971bb6b2fc728d599c94" translate="yes" xml:space="preserve">
          <source>Fields that have name-email-date tuple as its value (&lt;code&gt;author&lt;/code&gt;, &lt;code&gt;committer&lt;/code&gt;, and &lt;code&gt;tagger&lt;/code&gt;) can be suffixed with &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;email&lt;/code&gt;, and &lt;code&gt;date&lt;/code&gt; to extract the named component.</source>
          <target state="translated">name-email-dateタプルを値として持つフィールド（ &lt;code&gt;author&lt;/code&gt; 、 &lt;code&gt;committer&lt;/code&gt; 、および &lt;code&gt;tagger&lt;/code&gt; ）には、 &lt;code&gt;name&lt;/code&gt; 、 &lt;code&gt;email&lt;/code&gt; 、および &lt;code&gt;date&lt;/code&gt; をサフィックスとして付けて、名前付きコンポーネントを抽出できます。</target>
        </trans-unit>
        <trans-unit id="f890c334357c63fe5c4a4300d447bac89c08dc17" translate="yes" xml:space="preserve">
          <source>Fields that have name-email-date tuple as its value (&lt;code&gt;author&lt;/code&gt;, &lt;code&gt;committer&lt;/code&gt;, and &lt;code&gt;tagger&lt;/code&gt;) can be suffixed with &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;email&lt;/code&gt;, and &lt;code&gt;date&lt;/code&gt; to extract the named component. For email fields (&lt;code&gt;authoremail&lt;/code&gt;, &lt;code&gt;committeremail&lt;/code&gt; and &lt;code&gt;taggeremail&lt;/code&gt;), &lt;code&gt;:trim&lt;/code&gt; can be appended to get the email without angle brackets, and &lt;code&gt;:localpart&lt;/code&gt; to get the part before the &lt;code&gt;@&lt;/code&gt; symbol out of the trimmed email.</source>
          <target state="translated">値としてname-email-dateタプルを持つフィールド（ &lt;code&gt;author&lt;/code&gt; 、 &lt;code&gt;committer&lt;/code&gt; 、および &lt;code&gt;tagger&lt;/code&gt; ）には、 &lt;code&gt;name&lt;/code&gt; 、 &lt;code&gt;email&lt;/code&gt; 、および &lt;code&gt;date&lt;/code&gt; の接尾辞を付けて、名前付きコンポーネントを抽出できます。メールフィールド（ &lt;code&gt;authoremail&lt;/code&gt; 、 &lt;code&gt;committeremail&lt;/code&gt; 、 &lt;code&gt;taggeremail&lt;/code&gt; ）の場合、 &lt;code&gt;:trim&lt;/code&gt; を追加して山かっこなしでメールを取得し、 &lt;code&gt;:localpart&lt;/code&gt; を追加してトリミングされたメールから &lt;code&gt;@&lt;/code&gt; 記号の前の部分を取得できます。</target>
        </trans-unit>
        <trans-unit id="ed2ff2065be5f4efd23916d9b5c024804bb05ec6" translate="yes" xml:space="preserve">
          <source>Fields use modified URI encoding, defined in RFC 3986, section 2.1 (Percent-Encoding), or rather &quot;Query string encoding&quot; (see &lt;a href=&quot;https://en.wikipedia.org/wiki/Query_string#URL_encoding&quot;&gt;https://en.wikipedia.org/wiki/Query_string#URL_encoding&lt;/a&gt;), the difference being that SP (&quot; &quot;) can be encoded as &quot;+&quot; (and therefore &quot;+&quot; has to be also percent-encoded).</source>
          <target state="translated">フィールドは、RFC 3986、セクション2.1（Percent-Encoding）で定義された変更されたURIエンコーディング、または「クエリ文字列エンコーディング」（&lt;a href=&quot;https://en.wikipedia.org/wiki/Query_string#URL_encoding&quot;&gt;https://en.wikipedia.org/wiki/Query_string#URL_encodingを&lt;/a&gt;参照）を使用します。違いは、そのSPです。 （ &quot;&quot;）は &quot;+&quot;としてエンコードできます（したがって、 &quot;+&quot;もパーセントでエンコードする必要があります）。</target>
        </trans-unit>
        <trans-unit id="ff9cc1a6f5bb5a91d014bd56871d8a7e6dedf925" translate="yes" xml:space="preserve">
          <source>Fighting regressions overview</source>
          <target state="translated">ファイティング回帰の概要</target>
        </trans-unit>
        <trans-unit id="dc286ffc3d263eab0659e5254ed6cbdfe1ed4661" translate="yes" xml:space="preserve">
          <source>Figuring out why this works is left as an exercise to the (advanced) student. The &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, &lt;a href=&quot;git-diff-tree&quot;&gt;git-diff-tree[1]&lt;/a&gt;, and &lt;a href=&quot;git-hash-object&quot;&gt;git-hash-object[1]&lt;/a&gt; man pages may prove helpful.</source>
          <target state="translated">これが機能する理由を理解することは、（上級）学生の練習問題として残されます。&lt;a href=&quot;git-log&quot;&gt;gitのログ[1] &lt;/a&gt;、&lt;a href=&quot;git-diff-tree&quot;&gt;のgit-diffの木[1] &lt;/a&gt;、および&lt;a href=&quot;git-hash-object&quot;&gt;gitのハッシュオブジェクト[1]&lt;/a&gt; manページが参考になるかもしれません。</target>
        </trans-unit>
        <trans-unit id="39b2ed94cef5d6961eea0620d66a925578f2f283" translate="yes" xml:space="preserve">
          <source>File containing the SSL certificate when fetching or pushing over HTTPS. Can be overridden by the &lt;code&gt;GIT_SSL_CERT&lt;/code&gt; environment variable.</source>
          <target state="translated">HTTPS経由でフェッチまたはプッシュするときのSSL証明書を含むファイル。 &lt;code&gt;GIT_SSL_CERT&lt;/code&gt; 環境変数によってオーバーライドできます。</target>
        </trans-unit>
        <trans-unit id="e3b34071a7a6143f1cfbfe18d8122a378b6725a7" translate="yes" xml:space="preserve">
          <source>File containing the SSL private key when fetching or pushing over HTTPS. Can be overridden by the &lt;code&gt;GIT_SSL_KEY&lt;/code&gt; environment variable.</source>
          <target state="translated">HTTPS経由でフェッチまたはプッシュするときのSSL秘密鍵を含むファイル。 &lt;code&gt;GIT_SSL_KEY&lt;/code&gt; 環境変数によってオーバーライドできます。</target>
        </trans-unit>
        <trans-unit id="a25f7e6a9a15db1a7bb16a1513a308705fbf008c" translate="yes" xml:space="preserve">
          <source>File containing the certificates to verify the peer with when fetching or pushing over HTTPS. Can be overridden by the &lt;code&gt;GIT_SSL_CAINFO&lt;/code&gt; environment variable.</source>
          <target state="translated">HTTPS経由でフェッチまたはプッシュするときにピアを検証するための証明書を含むファイル。 &lt;code&gt;GIT_SSL_CAINFO&lt;/code&gt; 環境変数によってオーバーライドできます。</target>
        </trans-unit>
        <trans-unit id="51de61b9fb1649e39093ab80c2a7df2f9e16643a" translate="yes" xml:space="preserve">
          <source>File globbing matches across directory boundaries. Thus, given two directories &lt;code&gt;d&lt;/code&gt; and &lt;code&gt;d2&lt;/code&gt;, there is a difference between using &lt;code&gt;git rm 'd*'&lt;/code&gt; and &lt;code&gt;git rm 'd/*'&lt;/code&gt;, as the former will also remove all of directory &lt;code&gt;d2&lt;/code&gt;.</source>
          <target state="translated">ファイルのグロビングは、ディレクトリの境界を越えて一致します。したがって、2つのディレクトリ &lt;code&gt;d&lt;/code&gt; と &lt;code&gt;d2&lt;/code&gt; がある場合、前者もすべてのディレクトリ &lt;code&gt;d2&lt;/code&gt; を削除するため、 &lt;code&gt;git rm 'd*'&lt;/code&gt; と &lt;code&gt;git rm 'd/*'&lt;/code&gt; の使用には違いがあります。</target>
        </trans-unit>
        <trans-unit id="46bdca067f191e47ac236c4a9946147313edeadf" translate="yes" xml:space="preserve">
          <source>File inclusion (&lt;code&gt;:include: /path/name&lt;/code&gt;) is not supported.</source>
          <target state="translated">ファイルの組み込み（ &lt;code&gt;:include: /path/name&lt;/code&gt; ）はサポートされていません。</target>
        </trans-unit>
        <trans-unit id="0052ebd08e3dda2e68d8ee7b082b7c890d6ddeef" translate="yes" xml:space="preserve">
          <source>File indicating how to order files within a diff. See the &lt;code&gt;-O&lt;/code&gt; option to &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; for details. If &lt;code&gt;diff.orderFile&lt;/code&gt; is a relative pathname, it is treated as relative to the top of the working tree.</source>
          <target state="translated">diff内でファイルを注文する方法を示すファイル。詳細については、&lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt;の &lt;code&gt;-O&lt;/code&gt; オプションを参照してください。場合 &lt;code&gt;diff.orderFile&lt;/code&gt; が相対パス名で、それは作業ツリーの最上部からの相対パスとして扱われます。</target>
        </trans-unit>
        <trans-unit id="f2b61a4d1705fa3305542b48c5c1ffd38b30200f" translate="yes" xml:space="preserve">
          <source>File modes are printed as 6-digit octal numbers including the file type and file permission bits.</source>
          <target state="translated">ファイルモードは、ファイルタイプとファイルパーミッションビットを含む6桁の8進数で表示されます。</target>
        </trans-unit>
        <trans-unit id="cd4c7b960aaa326dfff2bf746e515a16b2b5bd4d" translate="yes" xml:space="preserve">
          <source>File system monitor</source>
          <target state="translated">ファイルシステムモニタ</target>
        </trans-unit>
        <trans-unit id="dab1e8f60ab6cd6f09a76739b1f40f880fb79310" translate="yes" xml:space="preserve">
          <source>File to use for (filename extension based) guessing of MIME types before trying &lt;code&gt;/etc/mime.types&lt;/code&gt;. &lt;strong&gt;NOTE&lt;/strong&gt; that this path, if relative, is taken as relative to the current Git repository, not to CGI script. If unset, only &lt;code&gt;/etc/mime.types&lt;/code&gt; is used (if present on filesystem). If no mimetypes file is found, mimetype guessing based on extension of file is disabled. Unset by default.</source>
          <target state="translated">&lt;code&gt;/etc/mime.types&lt;/code&gt; を試す前にMIMEタイプを（ファイル名拡張子に基づいて）推測するために使用するファイル。&lt;strong&gt;注&lt;/strong&gt;このパスは、相対的な場合ではなく、CGIスクリプトに、現在のGitリポジトリに相対として解釈されていること。設定されていない場合、 &lt;code&gt;/etc/mime.types&lt;/code&gt; のみが使用されます（ファイルシステムに存在する場合）。MIMEタイプファイルが見つからない場合、ファイルの拡張子に基づくMIMEタイプの推測は無効になります。デフォルトでは設定解除されています。</target>
        </trans-unit>
        <trans-unit id="f045415cfa170f304a990874fe0966e6d4eacafb" translate="yes" xml:space="preserve">
          <source>File with repository URL (used for clone and fetch), one per line. Displayed in the project summary page. You can use multiple-valued &lt;code&gt;gitweb.url&lt;/code&gt; repository configuration variable for that, but the file takes precedence.</source>
          <target state="translated">1行に1つずつのリポジトリURL（クローンとフェッチに使用）を含むファイル。プロジェクトの概要ページに表示されます。複数の値を持つ &lt;code&gt;gitweb.url&lt;/code&gt; リポジトリ設定変数を使用できますが、ファイルが優先されます。</target>
        </trans-unit>
        <trans-unit id="f73380191ad1f1caa70019147dbb81cb74dd0fbd" translate="yes" xml:space="preserve">
          <source>File/directory structure</source>
          <target state="translated">ファイル/ディレクトリ構造</target>
        </trans-unit>
        <trans-unit id="ee97d026e695edaa3af17191656d312a0a7a2ccb" translate="yes" xml:space="preserve">
          <source>Filenames with spaces are often mishandled by shell snippets since they cause problems for shell pipelines. Not everyone is familiar with find -print0, xargs -0, git-ls-files -z, etc. Even people who are familiar with these may assume such flags are not relevant because someone else renamed any such files in their repo back before the person doing the filtering joined the project. And often, even those familiar with handling arguments with spaces may not do so just because they aren&amp;rsquo;t in the mindset of thinking about everything that could possibly go wrong.</source>
          <target state="translated">スペースのあるファイル名は、シェルパイプラインに問題を引き起こすため、シェルスニペットによって誤って処理されることがよくあります。誰もがfind -print0、xargs -0、git-ls-files -zなどに精通しているわけではありません。これらのフラグに精通している人でも、他の誰かがリポジトリの前にそのようなファイルの名前をフィルタリングを行う人がプロジェクトに参加しました。そして、多くの場合、スペースで引数を処理することに慣れている人でも、うまくいかない可能性のあるすべてのことについて考えているわけではないので、そうしない場合があります。</target>
        </trans-unit>
        <trans-unit id="6ce6c512ea433a7fc5c8841628e7696cd0ff7f2b" translate="yes" xml:space="preserve">
          <source>Files</source>
          <target state="translated">Files</target>
        </trans-unit>
        <trans-unit id="669b1abdd74168ff79423d155c9ddb7e43a80b6e" translate="yes" xml:space="preserve">
          <source>Files (and pointers to subtrees) within active trees require 52 or 64 bytes (32/64 bit platforms) per entry. To conserve space, file and tree names are pooled in a common string table, allowing the filename &amp;ldquo;Makefile&amp;rdquo; to use just 16 bytes (after including the string header overhead) no matter how many times it occurs within the project.</source>
          <target state="translated">アクティブツリー内のファイル（およびサブツリーへのポインター）には、エントリごとに52バイトまたは64バイト（32/64ビットプラットフォーム）が必要です。スペースを節約するために、ファイル名とツリー名は共通の文字列テーブルにプールされるため、プロジェクト内で何回発生しても、ファイル名「Makefile」は（文字列ヘッダーのオーバーヘッドを含めた後）16バイトだけを使用できます。</target>
        </trans-unit>
        <trans-unit id="94bbb76c1352043c45a00df324ef04fea70e6730" translate="yes" xml:space="preserve">
          <source>Files and directories in the template directory whose name do not start with a dot will be copied to the &lt;code&gt;$GIT_DIR&lt;/code&gt; after it is created.</source>
          <target state="translated">名前がドットで始まらないテンプレートディレクトリ内のファイルとディレクトリは、作成後に &lt;code&gt;$GIT_DIR&lt;/code&gt; にコピーされます。</target>
        </trans-unit>
        <trans-unit id="d1270c9a81ec2853fddc0c884f8ccb1e8a45b97e" translate="yes" xml:space="preserve">
          <source>Files and directories with the attribute &lt;code&gt;export-ignore&lt;/code&gt; won&amp;rsquo;t be added to archive files.</source>
          <target state="translated">属性 &lt;code&gt;export-ignore&lt;/code&gt; を持つファイルおよびディレクトリは、アーカイブファイルに追加されません。</target>
        </trans-unit>
        <trans-unit id="e3974c4c3ce398cf177c9471660017bb110038df" translate="yes" xml:space="preserve">
          <source>Files and directories with the attribute export-ignore won&amp;rsquo;t be added to archive files. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">属性export-ignoreを持つファイルおよびディレクトリは、アーカイブファイルに追加されません。詳細については、&lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="a7b0ec5c5be81a4a3b161d0317a98cc9a7a62cb3" translate="yes" xml:space="preserve">
          <source>Files larger than this size are stored deflated, without attempting delta compression. Storing large files without delta compression avoids excessive memory usage, at the slight expense of increased disk usage. Additionally files larger than this size are always treated as binary.</source>
          <target state="translated">このサイズより大きいファイルは、デルタ圧縮を試みずにデフレーションされて保存されます。デルタ圧縮を行わずに大きなファイルを保存することで、過剰なメモリ使用を避けることができますが、ディスク使用量の増加を多少犠牲にしています。さらに、このサイズより大きいファイルは常にバイナリとして扱われます。</target>
        </trans-unit>
        <trans-unit id="b57b0d88e9fd775cd564cc119a3989093d68ff8d" translate="yes" xml:space="preserve">
          <source>Files to act on. Note that files beginning with &lt;code&gt;.&lt;/code&gt; are discarded. This includes &lt;code&gt;./file&lt;/code&gt; and &lt;code&gt;dir/./file&lt;/code&gt;. If you don&amp;rsquo;t want this, then use cleaner names. The same applies to directories ending &lt;code&gt;/&lt;/code&gt; and paths with &lt;code&gt;//&lt;/code&gt;</source>
          <target state="translated">処理するファイル。で始まるファイルに注意してください &lt;code&gt;.&lt;/code&gt; 破棄されます。これには &lt;code&gt;./file&lt;/code&gt; および &lt;code&gt;dir/./file&lt;/code&gt; 含まれます。これが必要ない場合は、よりわかりやすい名前を使用してください。同じことが、エンディングのディレクトリに適用されます &lt;code&gt;/&lt;/code&gt; ととパス &lt;code&gt;//&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a229bb6156d5f90b453ca5e0ca33977f1a3e6a8a" translate="yes" xml:space="preserve">
          <source>Files to add content from. Fileglobs (e.g. &lt;code&gt;*.c&lt;/code&gt;) can be given to add all matching files. Also a leading directory name (e.g. &lt;code&gt;dir&lt;/code&gt; to add &lt;code&gt;dir/file1&lt;/code&gt; and &lt;code&gt;dir/file2&lt;/code&gt;) can be given to update the index to match the current state of the directory as a whole (e.g. specifying &lt;code&gt;dir&lt;/code&gt; will record not just a file &lt;code&gt;dir/file1&lt;/code&gt; modified in the working tree, a file &lt;code&gt;dir/file2&lt;/code&gt; added to the working tree, but also a file &lt;code&gt;dir/file3&lt;/code&gt; removed from the working tree). Note that older versions of Git used to ignore removed files; use &lt;code&gt;--no-all&lt;/code&gt; option if you want to add modified or new files but ignore removed ones.</source>
          <target state="translated">コンテンツを追加するファイル。 Fileglobs（たとえば、 &lt;code&gt;*.c&lt;/code&gt; ）を指定して、一致するすべてのファイルを追加できます。また、主要なディレクトリ名は、（例えば &lt;code&gt;dir&lt;/code&gt; が追加する &lt;code&gt;dir/file1&lt;/code&gt; と &lt;code&gt;dir/file2&lt;/code&gt; （例えば指定全体として、ディレクトリの現在の状態に一致するようにインデックスを更新するために与えることができます） &lt;code&gt;dir&lt;/code&gt; がないだけで、ファイルを記録します &lt;code&gt;dir/file1&lt;/code&gt; 変更します作業ツリーでは、ファイル &lt;code&gt;dir/file2&lt;/code&gt; が作業ツリーに追加されますが、ファイル &lt;code&gt;dir/file3&lt;/code&gt; も作業ツリーから削除されます）。古いバージョンのGitは削除されたファイルを無視していたことに注意してください。変更されたファイルまたは新しいファイルを追加し、削除されたファイルは無視する場合は、 &lt;code&gt;--no-all&lt;/code&gt; オプションを使用します。</target>
        </trans-unit>
        <trans-unit id="965ffdf35ae99a80180c99419426ec2062c992e9" translate="yes" xml:space="preserve">
          <source>Files to remove. A leading directory name (e.g. &lt;code&gt;dir&lt;/code&gt; to remove &lt;code&gt;dir/file1&lt;/code&gt; and &lt;code&gt;dir/file2&lt;/code&gt;) can be given to remove all files in the directory, and recursively all sub-directories, but this requires the &lt;code&gt;-r&lt;/code&gt; option to be explicitly given.</source>
          <target state="translated">削除するファイル。（例えば主要なディレクトリ名 &lt;code&gt;dir&lt;/code&gt; 削除する &lt;code&gt;dir/file1&lt;/code&gt; と &lt;code&gt;dir/file2&lt;/code&gt; ）をディレクトリ内のすべてのファイルを削除するために与えられ、そして再帰的にすべてのサブディレクトリが、これは必要とすることができ &lt;code&gt;-r&lt;/code&gt; 明示的に指定するオプションを選択します。</target>
        </trans-unit>
        <trans-unit id="6fcfbd1668d25020111102295bf825ad36cd4ad7" translate="yes" xml:space="preserve">
          <source>Files to remove. Fileglobs (e.g. &lt;code&gt;*.c&lt;/code&gt;) can be given to remove all matching files. If you want Git to expand file glob characters, you may need to shell-escape them. A leading directory name (e.g. &lt;code&gt;dir&lt;/code&gt; to remove &lt;code&gt;dir/file1&lt;/code&gt; and &lt;code&gt;dir/file2&lt;/code&gt;) can be given to remove all files in the directory, and recursively all sub-directories, but this requires the &lt;code&gt;-r&lt;/code&gt; option to be explicitly given.</source>
          <target state="translated">削除するファイル。Fileglobs（たとえば &lt;code&gt;*.c&lt;/code&gt; ）を指定して、一致するすべてのファイルを削除できます。Gitでファイルグロブ文字を展開する場合は、それらをシェルエスケープする必要があります。（例えば主要なディレクトリ名 &lt;code&gt;dir&lt;/code&gt; 削除する &lt;code&gt;dir/file1&lt;/code&gt; と &lt;code&gt;dir/file2&lt;/code&gt; ）をディレクトリ内のすべてのファイルを削除するために与えられ、そして再帰的にすべてのサブディレクトリが、これは必要とすることができ &lt;code&gt;-r&lt;/code&gt; 明示的に指定するオプションを選択します。</target>
        </trans-unit>
        <trans-unit id="d69266d087a66debaeaa16301b1f83a323ef3a05" translate="yes" xml:space="preserve">
          <source>Files to show. If no files are given all files which match the other specified criteria are shown.</source>
          <target state="translated">表示するファイル。ファイルが指定されていない場合は、他の指定された基準に一致するすべてのファイルが表示されます。</target>
        </trans-unit>
        <trans-unit id="94b61f142196a44a91e5065c7d0adcb5cad7dae3" translate="yes" xml:space="preserve">
          <source>Files with conflicts are marked specially in the index, so until you resolve the problem and update the index, &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; will fail:</source>
          <target state="translated">競合のあるファイルはインデックスで特別にマークされているため、問題を解決してインデックスを更新するまで、&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt;は失敗します。</target>
        </trans-unit>
        <trans-unit id="96e578211aa295317cf257310712fa28ccd8f6c6" translate="yes" xml:space="preserve">
          <source>Filters</source>
          <target state="translated">Filters</target>
        </trans-unit>
        <trans-unit id="1cf100e1097311bd9759a52dc063dba54a0c3fc0" translate="yes" xml:space="preserve">
          <source>Finalize an in-progress &lt;code&gt;git notes merge&lt;/code&gt;. Use this option when you have resolved the conflicts that &lt;code&gt;git notes merge&lt;/code&gt; stored in .git/NOTES_MERGE_WORKTREE. This amends the partial merge commit created by &lt;code&gt;git notes merge&lt;/code&gt; (stored in .git/NOTES_MERGE_PARTIAL) by adding the notes in .git/NOTES_MERGE_WORKTREE. The notes ref stored in the .git/NOTES_MERGE_REF symref is updated to the resulting commit.</source>
          <target state="translated">進行中の &lt;code&gt;git notes merge&lt;/code&gt; を確定します。.git / NOTES_MERGE_WORKTREEに保存されている &lt;code&gt;git notes merge&lt;/code&gt; 競合を解決した場合、このオプションを使用します。これは、.git / NOTES_MERGE_WORKTREEにメモを追加することにより、 &lt;code&gt;git notes merge&lt;/code&gt; （.git / NOTES_MERGE_PARTIALに格納されている）によって作成された部分的なマージコミットを修正します。.git / NOTES_MERGE_REF symrefに保存されているnotes refは、結果のコミットに更新されます。</target>
        </trans-unit>
        <trans-unit id="9eb00b677ea152c9f2f0f234add05ac350dd5a77" translate="yes" xml:space="preserve">
          <source>Finally it examines &lt;code&gt;$GIT_DIR/info/attributes&lt;/code&gt;. This file is used to override the in-tree settings. The first line is a match, and &lt;code&gt;foo&lt;/code&gt; is set, &lt;code&gt;bar&lt;/code&gt; is reverted to unspecified state, and &lt;code&gt;baz&lt;/code&gt; is unset.</source>
          <target state="translated">最後に &lt;code&gt;$GIT_DIR/info/attributes&lt;/code&gt; 調べます。このファイルは、ツリー内の設定を上書きするために使用されます。最初の行は一致で、 &lt;code&gt;foo&lt;/code&gt; が設定され、 &lt;code&gt;bar&lt;/code&gt; は指定されていない状態に戻され、 &lt;code&gt;baz&lt;/code&gt; は設定されていません。</target>
        </trans-unit>
        <trans-unit id="331d183abb3e32c5b94fe163358b0bd60def41df" translate="yes" xml:space="preserve">
          <source>Finally, if &lt;code&gt;--expire-time=&amp;lt;datetime&amp;gt;&lt;/code&gt; is not specified, let &lt;code&gt;datetime&lt;/code&gt; be the current time. After writing the split commit-graph, delete all unused commit-graph whose modified times are older than &lt;code&gt;datetime&lt;/code&gt;.</source>
          <target state="translated">最後に、 &lt;code&gt;--expire-time=&amp;lt;datetime&amp;gt;&lt;/code&gt; が指定されていない場合は、 &lt;code&gt;datetime&lt;/code&gt; を現在の時刻とします。分割コミットグラフを書き込んだ後、変更時刻が &lt;code&gt;datetime&lt;/code&gt; より古い未使用のコミットグラフをすべて削除します。</target>
        </trans-unit>
        <trans-unit id="43d1a6457be0c846de5bf38ab3298d9d3628832d" translate="yes" xml:space="preserve">
          <source>Finally, it is possible to specify an arbitrary perl subroutine that will be called for each repository to determine if it can be exported. The subroutine receives an absolute path to the project (repository) as its only parameter (i.e. &quot;$projectroot/$project&quot;).</source>
          <target state="translated">最後に、エクスポートできるかどうかを判断するために、リポジトリごとに呼び出される任意のperlサブルーチンを指定することができます。このサブルーチンは、プロジェクト(リポジトリ)への絶対パスを唯一のパラメータとして受け取ります(例:&quot;$projectroot/$project&quot;)。</target>
        </trans-unit>
        <trans-unit id="24d1078763f97a2ccc23634e9fb57ca6945117cd" translate="yes" xml:space="preserve">
          <source>Finally, it&amp;rsquo;s worth looking at the effect of &lt;code&gt;git add&lt;/code&gt; on the index file:</source>
          <target state="translated">最後に、インデックスファイルに対する &lt;code&gt;git add&lt;/code&gt; の影響を確認する価値があります。</target>
        </trans-unit>
        <trans-unit id="8264955cf61255273040b40a18d8fbbb22fa2f72" translate="yes" xml:space="preserve">
          <source>Finally, most commands that take filenames will optionally allow you to precede any filename by a commit, to specify a particular version of the file:</source>
          <target state="translated">最後に、ファイル名を取るほとんどのコマンドでは、ファイルの特定のバージョンを指定するために、任意のファイル名の前にコミットを付けることができます。</target>
        </trans-unit>
        <trans-unit id="6c56e02ffa0dc0d04395282d17622dfa271e848b" translate="yes" xml:space="preserve">
          <source>Finally, runs of whitespace are normalized to a single ASCII space character.</source>
          <target state="translated">最後に、ホワイトスペースの実行は、1つのASCIIスペース文字に正規化されます。</target>
        </trans-unit>
        <trans-unit id="f254df0ed5803ab0d672797542ab7bd433761746" translate="yes" xml:space="preserve">
          <source>Finally, see &lt;a href=&quot;#todo&quot;&gt;Notes and todo list for this manual&lt;/a&gt; for ways that you can help make this manual more complete.</source>
          <target state="translated">最後に、このマニュアルをより完全にするために役立つ方法&lt;a href=&quot;#todo&quot;&gt;については、このマニュアルの&lt;/a&gt;「メモとtodoリスト」を参照してください。</target>
        </trans-unit>
        <trans-unit id="0f28877b4b3e20afaa3344b89d8d8e7dd3cc9a77" translate="yes" xml:space="preserve">
          <source>Finally, the list of matching commits is shown in the order of the second commit range, with unmatched commits being inserted just after all of their ancestors have been shown.</source>
          <target state="translated">最後に、一致するコミットのリストは、2 番目のコミット範囲の順に表示されます。</target>
        </trans-unit>
        <trans-unit id="9a3fea8b3f0925da6c2b86381c6c149ac6f29683" translate="yes" xml:space="preserve">
          <source>Finally, there are a few odds and ends which are not purely moving from one representation to the other:</source>
          <target state="translated">最後に、一方の表現から他方の表現へと純粋に移動するのではなく、いくつかのオッズとエンドがあります。</target>
        </trans-unit>
        <trans-unit id="3fe4e962ec8320ef45c1375652f3937a50d04ca2" translate="yes" xml:space="preserve">
          <source>Finally, there is a fifth simplification mode available:</source>
          <target state="translated">最後に、第5の簡略化モードが用意されています。</target>
        </trans-unit>
        <trans-unit id="be9a3fea0f82381aa185e3a3e7bc70453cddfef1" translate="yes" xml:space="preserve">
          <source>Finally, these options can be combined with a layout option (defaults to &lt;code&gt;nodense&lt;/code&gt;):</source>
          <target state="translated">最後に、これらのオプションはレイアウトオプションと組み合わせることができます（デフォルトは &lt;code&gt;nodense&lt;/code&gt; です）：</target>
        </trans-unit>
        <trans-unit id="20a1c9ffc616ee01b8dce65bdb93f7148cbfeb85" translate="yes" xml:space="preserve">
          <source>Find a helper.</source>
          <target state="translated">ヘルパーを探す。</target>
        </trans-unit>
        <trans-unit id="30d88faf5655c44ff9e677fe0e00c8e9ca77aa3d" translate="yes" xml:space="preserve">
          <source>Find a ref that matches &lt;code&gt;experimental&lt;/code&gt; in the &lt;code&gt;origin&lt;/code&gt; repository (e.g. &lt;code&gt;refs/heads/experimental&lt;/code&gt;), and delete it.</source>
          <target state="translated">一致するREF検索 &lt;code&gt;experimental&lt;/code&gt; における &lt;code&gt;origin&lt;/code&gt; リポジトリを（例えば &lt;code&gt;refs/heads/experimental&lt;/code&gt; ）し、それを削除します。</target>
        </trans-unit>
        <trans-unit id="ef251b247769ae2bcbe4a6086b08e0deff95b9d6" translate="yes" xml:space="preserve">
          <source>Find a ref that matches &lt;code&gt;master&lt;/code&gt; in the source repository (most likely, it would find &lt;code&gt;refs/heads/master&lt;/code&gt;), and update the same ref (e.g. &lt;code&gt;refs/heads/master&lt;/code&gt;) in &lt;code&gt;origin&lt;/code&gt; repository with it. If &lt;code&gt;master&lt;/code&gt; did not exist remotely, it would be created.</source>
          <target state="translated">一致するREF検索 &lt;code&gt;master&lt;/code&gt; （ほとんどの場合、それが見つけるだろうソースリポジトリに &lt;code&gt;refs/heads/master&lt;/code&gt; （例えば）、および同じ参照を更新する &lt;code&gt;refs/heads/master&lt;/code&gt; で） &lt;code&gt;origin&lt;/code&gt; それにリポジトリ。 &lt;code&gt;master&lt;/code&gt; がリモートに存在しない場合は作成されます。</target>
        </trans-unit>
        <trans-unit id="ccef9d1bcc3ad53f8d4e9015291e141315fc185c" translate="yes" xml:space="preserve">
          <source>Find as good common ancestors as possible for a merge</source>
          <target state="translated">できるだけ良い共通の先祖を見つけてください。</target>
        </trans-unit>
        <trans-unit id="d3f173da3a7dce0bd9994325b78952d16aab8240" translate="yes" xml:space="preserve">
          <source>Find commits yet to be applied to upstream</source>
          <target state="translated">アップストリームにまだ適用されていないコミットを探す</target>
        </trans-unit>
        <trans-unit id="f766cd71208fbf6c57bd1c63b40f06ddd3b5b9dc" translate="yes" xml:space="preserve">
          <source>Find first tagged version including a given fix</source>
          <target state="translated">与えられた修正を含む最初のタグ付きバージョンを探す</target>
        </trans-unit>
        <trans-unit id="df9e9c717faf5fac976a38f227398efdc30aeda9" translate="yes" xml:space="preserve">
          <source>Find redundant pack files</source>
          <target state="translated">冗長なパックファイルを探す</target>
        </trans-unit>
        <trans-unit id="44f9539ac1c361035e9a88da329c269fe8a0f4cb" translate="yes" xml:space="preserve">
          <source>Find symbolic names for given revs</source>
          <target state="translated">与えられたレヴスの記号名を検索します。</target>
        </trans-unit>
        <trans-unit id="f381cb9cf3280c2142361c5998997b7124410055" translate="yes" xml:space="preserve">
          <source>Find the color configured for &lt;code&gt;name&lt;/code&gt; (e.g. &lt;code&gt;color.diff.new&lt;/code&gt;) and output it as the ANSI color escape sequence to the standard output. The optional &lt;code&gt;default&lt;/code&gt; parameter is used instead, if there is no color configured for &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 用に構成された色（例： &lt;code&gt;color.diff.new&lt;/code&gt; ）を見つけ、それをANSIカラーエスケープシーケンスとして標準出力に出力します。 &lt;code&gt;name&lt;/code&gt; に色が設定されていない場合は、代わりにオプションの &lt;code&gt;default&lt;/code&gt; パラメータが使用されます。</target>
        </trans-unit>
        <trans-unit id="40d2e7dbd88f8b4a905f40b739ac46054d6c280f" translate="yes" xml:space="preserve">
          <source>Find the color setting for &lt;code&gt;name&lt;/code&gt; (e.g. &lt;code&gt;color.diff&lt;/code&gt;) and output &quot;true&quot; or &quot;false&quot;. &lt;code&gt;stdout-is-tty&lt;/code&gt; should be either &quot;true&quot; or &quot;false&quot;, and is taken into account when configuration says &quot;auto&quot;. If &lt;code&gt;stdout-is-tty&lt;/code&gt; is missing, then checks the standard output of the command itself, and exits with status 0 if color is to be used, or exits with status 1 otherwise. When the color setting for &lt;code&gt;name&lt;/code&gt; is undefined, the command uses &lt;code&gt;color.ui&lt;/code&gt; as fallback.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; のカラー設定（例： &lt;code&gt;color.diff&lt;/code&gt; ）を見つけ、「true」または「false」を出力します。 &lt;code&gt;stdout-is-tty&lt;/code&gt; は「true」または「false」のいずれかである必要があり、構成が「auto」と言ったときに考慮されます。場合 &lt;code&gt;stdout-is-tty&lt;/code&gt; 欠落している場合、コマンド自体の標準出力をチェックし、ステータス0で終了色を使用する場合、またはそうでなければステータス1で終了します。 &lt;code&gt;name&lt;/code&gt; のカラー設定が未定義の場合、コマンドは &lt;code&gt;color.ui&lt;/code&gt; をフォールバックとして使用します。</target>
        </trans-unit>
        <trans-unit id="df59454620e80f086423090568733ac46b2847e0" translate="yes" xml:space="preserve">
          <source>Find the point at which a branch (or any history that leads to &amp;lt;commit&amp;gt;) forked from another branch (or any reference) &amp;lt;ref&amp;gt;. This does not just look for the common ancestor of the two commits, but also takes into account the reflog of &amp;lt;ref&amp;gt; to see if the history leading to &amp;lt;commit&amp;gt; forked from an earlier incarnation of the branch &amp;lt;ref&amp;gt; (see discussion on this mode below).</source>
          <target state="translated">ブランチ（または&amp;lt;commit&amp;gt;につながる履歴）が別のブランチ（または任意の参照）&amp;lt;ref&amp;gt;から分岐したポイントを見つけます。これは、2つのコミットの共通の祖先を探すだけでなく、&amp;lt;ref&amp;gt;のreflogも考慮して、&amp;lt;commit&amp;gt;につながる履歴がブランチ&amp;lt;ref&amp;gt;の以前の化身から分岐したかどうかを確認します（以下の説明を参照）以下のこのモード）。</target>
        </trans-unit>
        <trans-unit id="9da189d134fc7190f0c6c1f5c3193ab5948bf13c" translate="yes" xml:space="preserve">
          <source>Finding commits referencing a file with given content</source>
          <target state="translated">指定された内容のファイルを参照しているコミットを見つける</target>
        </trans-unit>
        <trans-unit id="e333b71e49766be9f1d76f262411fa340daf0c70" translate="yes" xml:space="preserve">
          <source>Finding commits which commit messages matches given search term.</source>
          <target state="translated">指定された検索条件にマッチするコミットメッセージを見つけます。</target>
        </trans-unit>
        <trans-unit id="1eaaf96aa600c577b3f3a9747228f1b65b0ceefc" translate="yes" xml:space="preserve">
          <source>Finding files</source>
          <target state="translated">ファイルの検索</target>
        </trans-unit>
        <trans-unit id="2fc00785f4570abeeda498c54f0284462aed8b44" translate="yes" xml:space="preserve">
          <source>Finding performance regressions</source>
          <target state="translated">パフォーマンス回帰を見つける</target>
        </trans-unit>
        <trans-unit id="bc2b131e580f41edfbbcd8f6c9c60a09f1a25b76" translate="yes" xml:space="preserve">
          <source>Finds symbolic names suitable for human digestion for revisions given in any format parsable by &lt;code&gt;git rev-parse&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git rev-parse&lt;/code&gt; で解析可能な任意の形式で指定されたリビジョンの人間の消化に適したシンボリック名を検索します。</target>
        </trans-unit>
        <trans-unit id="7d4b2472daa261c193507bf4d856ace529dabcc6" translate="yes" xml:space="preserve">
          <source>First let&amp;rsquo;s assume your &lt;code&gt;topic&lt;/code&gt; is based on branch &lt;code&gt;next&lt;/code&gt;. For example, a feature developed in &lt;code&gt;topic&lt;/code&gt; depends on some functionality which is found in &lt;code&gt;next&lt;/code&gt;.</source>
          <target state="translated">まず、 &lt;code&gt;topic&lt;/code&gt; がブランチ &lt;code&gt;next&lt;/code&gt; に基づいていると仮定しましょう。たとえば、 &lt;code&gt;topic&lt;/code&gt; 開発された機能は、 &lt;code&gt;next&lt;/code&gt; にあるいくつかの機能に依存しています。</target>
        </trans-unit>
        <trans-unit id="ed8007e4d48fad1e0a696af768b6078f3fa95c0a" translate="yes" xml:space="preserve">
          <source>First let&amp;rsquo;s define &quot;best bisection point&quot;. We will say that a commit X is a best bisection point or a best bisection commit if knowing its state (&quot;good&quot; or &quot;bad&quot;) gives as much information as possible whether the state of the commit happens to be &quot;good&quot; or &quot;bad&quot;.</source>
          <target state="translated">まず、「最高の二等分点」を定義しましょう。コミットXは、その状態（「良好」または「不良」）を知って、コミットの状態が「良好」または「良好」のどちらであるかを可能な限り多く提供する場合、最良の二分ポイントまたは最良の二分コミットであると言います。悪い&quot;。</target>
        </trans-unit>
        <trans-unit id="ee7f8a8fdabeacb4105bb68c4dfba6a20cea041f" translate="yes" xml:space="preserve">
          <source>First merges by themselves can introduce some regressions even when the merge needs no source code conflict resolution. This is because a semantic change can happen in one branch while the other branch is not aware of it.</source>
          <target state="translated">最初のマージは、ソースコードの競合解決を必要としない場合でも、それ自体でいくつかの回帰を導入することができます。これは、あるブランチではセマンティックな変更が起きても、他のブランチではそれに気づかないからです。</target>
        </trans-unit>
        <trans-unit id="05a55fcafe087cbd44c02228e1ac75a34a01c1f1" translate="yes" xml:space="preserve">
          <source>First, build a history graph in the same way that &lt;code&gt;--full-history&lt;/code&gt; with parent rewriting does (see above).</source>
          <target state="translated">まず、親の書き換えを &lt;code&gt;--full-history&lt;/code&gt; と同じ方法で履歴グラフを作成します（上記を参照）。</target>
        </trans-unit>
        <trans-unit id="08310df25f406cc10b8d6127f9ec844567b780fb" translate="yes" xml:space="preserve">
          <source>First, if you wish to continue to release maintenance fixes for the feature release made before the recent one, then you must create another branch to track commits for that previous release.</source>
          <target state="translated">まず、最近のリリースより前に作られた機能のメンテナンスフィックスを継続してリリースしたい場合は、その前のリリースのコミットを追跡するために別のブランチを作成しなければなりません。</target>
        </trans-unit>
        <trans-unit id="3f7b81f4c441b31ef96f877571ae9e6d0b762fd6" translate="yes" xml:space="preserve">
          <source>First, in .gitattributes, you would assign the &lt;code&gt;diff&lt;/code&gt; attribute for paths.</source>
          <target state="translated">まず、.gitattributesで、パスに &lt;code&gt;diff&lt;/code&gt; 属性を割り当てます。</target>
        </trans-unit>
        <trans-unit id="b3f5f5cacf6c72eb426cf54eb30cee145c3bf1f2" translate="yes" xml:space="preserve">
          <source>First, install version 2.1 or higher of cvsps from &lt;a href=&quot;https://github.com/andreyvit/cvsps&quot;&gt;https://github.com/andreyvit/cvsps&lt;/a&gt; and make sure it is in your path. Then cd to a checked out CVS working directory of the project you are interested in and run &lt;a href=&quot;git-cvsimport&quot;&gt;git-cvsimport[1]&lt;/a&gt;:</source>
          <target state="translated">最初に、&lt;a href=&quot;https://github.com/andreyvit/cvsps&quot;&gt;https：&lt;/a&gt; //github.com/andreyvit/cvspsからバージョン2.1以降のcvspsをインストールし、パスに含まれていることを確認します。次に、関心のあるプロジェクトのチェックアウトされたCVS作業ディレクトリにcdし、&lt;a href=&quot;git-cvsimport&quot;&gt;git-cvsimport [1]&lt;/a&gt;を実行します。</target>
        </trans-unit>
        <trans-unit id="576e890855dbcdc8bc3ac7fde0afbe81b0fdd016" translate="yes" xml:space="preserve">
          <source>First, note that you can get documentation for a command such as &lt;code&gt;git log --graph&lt;/code&gt; with:</source>
          <target state="translated">まず、 &lt;code&gt;git log --graph&lt;/code&gt; などのコマンドのドキュメントを取得できることに注意してください。</target>
        </trans-unit>
        <trans-unit id="9a679f4d1f2379fb3e8b418dd1cdea69390f805f" translate="yes" xml:space="preserve">
          <source>First, reset the history back one commit so that we remove the original commit, but leave the working tree with all the changes. The -N ensures that any new files added with &lt;code&gt;HEAD&lt;/code&gt; are still marked so that &lt;code&gt;git add -p&lt;/code&gt; will find them.</source>
          <target state="translated">最初に、履歴を1つのコミットにリセットして、元のコミットを削除しますが、作業ツリーにはすべての変更を残します。-Nを指定すると、 &lt;code&gt;HEAD&lt;/code&gt; で追加されたすべての新しいファイルが引き続きマークされるため、 &lt;code&gt;git add -p&lt;/code&gt; でそれらを見つけることができます。</target>
        </trans-unit>
        <trans-unit id="eac258ebc7c4ff84505375d195a1e24d04961706" translate="yes" xml:space="preserve">
          <source>First, use &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt;; for example:</source>
          <target state="translated">まず、&lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]を使用し&lt;/a&gt;ます。例えば：</target>
        </trans-unit>
        <trans-unit id="af62e3f15d84326a813952b253791dac4ec57aaa" translate="yes" xml:space="preserve">
          <source>First, you need to create an empty repository on the remote machine that will house your public repository. This empty repository will be populated and be kept up to date by pushing into it later. Obviously, this repository creation needs to be done only once.</source>
          <target state="translated">まず、パブリックリポジトリを格納するリモートマシン上に空のリポジトリを作成する必要があります。この空のリポジトリは、後でプッシュすることで最新の状態に保たれます。明らかに、このリポジトリの作成は一度だけ行う必要があります。</target>
        </trans-unit>
        <trans-unit id="52835c0708aa62a7396cacc7dfc2df24ce8a002c" translate="yes" xml:space="preserve">
          <source>Fix a &quot;thin&quot; pack produced by &lt;code&gt;git pack-objects --thin&lt;/code&gt; (see &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt; for details) by adding the excluded objects the deltified objects are based on to the pack. This option only makes sense in conjunction with --stdin.</source>
          <target state="translated">&lt;code&gt;git pack-objects --thin&lt;/code&gt; （詳細については&lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects [1]&lt;/a&gt;を参照）によって生成された「シン」パックを修正して、削除されたオブジェクトが基づいている除外オブジェクトをパックに追加します。このオプションは、-stdinと組み合わせた場合にのみ意味があります。</target>
        </trans-unit>
        <trans-unit id="6bef9039e49cd5a1bb992311087de16992b814ac" translate="yes" xml:space="preserve">
          <source>Fix the ignore-paths or SVN permissions problem that caused &quot;r2&quot; to be incomplete in the first place. Then:</source>
          <target state="translated">無視パスやSVNのパーミッションの問題を修正し、&quot;r2 &quot;がそもそも不完全なものになってしまう原因となっていました。それから</target>
        </trans-unit>
        <trans-unit id="bf5e51b162922584144bf607debb47b58ed7a8df" translate="yes" xml:space="preserve">
          <source>Fixing a mistake by rewriting history</source>
          <target state="translated">歴史の書き換えによるミスの修正</target>
        </trans-unit>
        <trans-unit id="afb2d222f3591d3622f9d0c44f698fe7e6dc0a83" translate="yes" xml:space="preserve">
          <source>Fixing a mistake with a new commit</source>
          <target state="translated">新しいコミットでミスを修正する</target>
        </trans-unit>
        <trans-unit id="c169f9b52cd517560d8a456346335c3aedbfac2b" translate="yes" xml:space="preserve">
          <source>Fixing mistakes</source>
          <target state="translated">ミスの修正</target>
        </trans-unit>
        <trans-unit id="de18d069db0d9d56daecfccdb3a27275518bc1f7" translate="yes" xml:space="preserve">
          <source>Flags and parameters to be parsed.</source>
          <target state="translated">解析するフラグとパラメータ。</target>
        </trans-unit>
        <trans-unit id="8a2fcacfdef0a8b1fd083381230b0ac0cbbdea61" translate="yes" xml:space="preserve">
          <source>Follow merge ancestry and attempt to import trees that have been merged from. Specify a depth greater than 1 if patch logs have been pruned.</source>
          <target state="translated">merge ancestryに従って、マージされたツリーのインポートを試みます。パッチログが剪定されている場合は、1よりも大きい深さを指定します。</target>
        </trans-unit>
        <trans-unit id="fc08e4a2c4c96e25ad3223cdd944785cb30a915c" translate="yes" xml:space="preserve">
          <source>Follow only the first parent commit upon seeing a merge commit.</source>
          <target state="translated">マージコミットを確認したら、最初の親コミットのみをフォローします。</target>
        </trans-unit>
        <trans-unit id="f48973c6479f97ed9cbdd1aa747abb3d724dfc88" translate="yes" xml:space="preserve">
          <source>Follow only the first parent commit upon seeing a merge commit. This is useful when you wish to not match tags on branches merged in the history of the target commit.</source>
          <target state="translated">マージコミットを見たときに最初の親コミットのみをフォローします。これは、ターゲットコミットの履歴にあるマージされたブランチのタグにマッチしないようにしたい場合に便利です。</target>
        </trans-unit>
        <trans-unit id="37deb1921d5628bb8484cd98e5d1812d850199d4" translate="yes" xml:space="preserve">
          <source>Follow only the first parent commit upon seeing a merge commit. This option can be used to determine when a line was introduced to a particular integration branch, rather than when it was introduced to the history overall.</source>
          <target state="translated">マージコミットを見たときに最初の親コミットのみをフォローします。このオプションを使用すると、履歴全体にいつ導入されたかではなく、特定の統合ブランチにいつ導入されたかを判断することができます。</target>
        </trans-unit>
        <trans-unit id="592429d37f44072b1083ee8b6715edf266446955" translate="yes" xml:space="preserve">
          <source>Follow only the first parent commit upon seeing a merge commit. This option can give a better overview when viewing the evolution of a particular topic branch, because merges into a topic branch tend to be only about adjusting to updated upstream from time to time, and this option allows you to ignore the individual commits brought in to your history by such a merge.</source>
          <target state="translated">マージコミットを見たときに最初の親コミットのみをフォローします。なぜなら、トピックブランチへのマージは時々更新される上流への調整のみを目的としている傾向があるからです。このオプションを使用すると、そのようなマージによって履歴に追加された個々のコミットを無視することができます。</target>
        </trans-unit>
        <trans-unit id="d67b9781a4352de8f66549a8b248fd66aceb7858" translate="yes" xml:space="preserve">
          <source>Follow only the first parent commit upon seeing a merge commit. This option can give a better overview when viewing the evolution of a particular topic branch, because merges into a topic branch tend to be only about adjusting to updated upstream from time to time, and this option allows you to ignore the individual commits brought in to your history by such a merge. Cannot be combined with --bisect.</source>
          <target state="translated">マージコミットを見たときに最初の親コミットのみをフォローします。なぜなら、トピックブランチへのマージは時々更新される上流への調整のみを目的としている傾向があるからです。このオプションを使用すると、そのようなマージによって履歴に追加された個々のコミットを無視することができます。bisect と組み合わせることはできません。</target>
        </trans-unit>
        <trans-unit id="1b82a1274463e2bfba901905e39b02d331c44520" translate="yes" xml:space="preserve">
          <source>Following general best practices</source>
          <target state="translated">一般的なベストプラクティスに従う</target>
        </trans-unit>
        <trans-unit id="788b60e8a3fa302c96ca5000ec7c36053afb1c38" translate="yes" xml:space="preserve">
          <source>Following the headers, a series of lines are printed for tracked entries. One of three different line formats may be used to describe an entry depending on the type of change. Tracked entries are printed in an undefined order; parsers should allow for a mixture of the 3 line types in any order.</source>
          <target state="translated">ヘッダの後には、追跡されたエントリのための一連の行が印刷されます。変更のタイプに応じて、3つの異なる行フォーマットのうちの1つをエントリを記述するために使用することができます。追跡されたエントリは、不定の順序で印刷されます。パーサは、3つの行タイプをどの順序でも混在させることができるようにしなければなりません。</target>
        </trans-unit>
        <trans-unit id="0af351e25b3235e5cb0b144d879a5948cd0b6627" translate="yes" xml:space="preserve">
          <source>Following the tracked entries (and if requested), a series of lines will be printed for untracked and then ignored items found in the worktree.</source>
          <target state="translated">追跡されたエントリに続いて(要求された場合には)、ワークツリーで見つかった追跡されていない項目と無視された項目のための一連の行が印刷されます。</target>
        </trans-unit>
        <trans-unit id="18388d4087a6542b5572bea29a06b35e2aae5326" translate="yes" xml:space="preserve">
          <source>Following these N lines, one-line log for each commit is displayed, indented N places. If a commit is on the I-th branch, the I-th indentation character shows a &lt;code&gt;+&lt;/code&gt; sign; otherwise it shows a space. Merge commits are denoted by a &lt;code&gt;-&lt;/code&gt; sign. Each commit shows a short name that can be used as an extended SHA-1 to name that commit.</source>
          <target state="translated">これらのN行に続いて、コミットごとに1行のログが表示されます。コミットがI番目のブランチにある場合、I番目のインデント文字は &lt;code&gt;+&lt;/code&gt; 記号を示します。それ以外の場合はスペースを示します。マージコミットは &lt;code&gt;-&lt;/code&gt; 記号で示されます。各コミットは、そのコミットに名前を付けるための拡張SHA-1として使用できる短い名前を示します。</target>
        </trans-unit>
        <trans-unit id="348633bb6883a2c8b3944ebb9c0c3986369c6bb3" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;-c&lt;/code&gt; and &lt;code&gt;--cc&lt;/code&gt;, only the destination or final path is shown even if the file was renamed on any side of history. With &lt;code&gt;--combined-all-paths&lt;/code&gt;, the name of the path in each parent is shown followed by the name of the path in the merge commit.</source>
          <target state="translated">ため &lt;code&gt;-c&lt;/code&gt; と &lt;code&gt;--cc&lt;/code&gt; ファイルは履歴のいずれかの側に改名された場合でも、唯一の宛先または最終パスが示されています。 &lt;code&gt;--combined-all-paths&lt;/code&gt; 、各親にパス名がマージにおけるパスコミットの名前が続く示されています。</target>
        </trans-unit>
        <trans-unit id="299f58cbaec7164b54b0f4129532e8b5c1642be3" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;branch&lt;/code&gt; and &lt;code&gt;tag&lt;/code&gt;, display the urls that will be used for copying when creating the branch or tag.</source>
          <target state="translated">以下のため &lt;code&gt;branch&lt;/code&gt; と &lt;code&gt;tag&lt;/code&gt; 、ブランチやタグを作成するときにコピーするために使用されるURLを表示します。</target>
        </trans-unit>
        <trans-unit id="007222e8d7dfa1e11f08c139bdea5864653b03fb" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;dcommit&lt;/code&gt;, print out the series of Git arguments that would show which diffs would be committed to SVN.</source>
          <target state="translated">&lt;code&gt;dcommit&lt;/code&gt; 、SVNにコミットされるであろう差分表示されるでしょうGitの一連の引数をプリントアウトします。</target>
        </trans-unit>
        <trans-unit id="7661574c1331f1ffadb88e65b09fb7bbb3d5b369" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;rebase&lt;/code&gt;, display the local branch associated with the upstream svn repository associated with the current branch and the URL of svn repository that will be fetched from.</source>
          <target state="translated">ため &lt;code&gt;rebase&lt;/code&gt; 、現在のブランチとからフェッチなり、SVNリポジトリのURLに関連付けられた上流SVNリポジトリに関連付けられているローカルブランチを表示します。</target>
        </trans-unit>
        <trans-unit id="8054fb75013a9d33733a54185710f048c11e6754" translate="yes" xml:space="preserve">
          <source>For Git developers, &lt;a href=&quot;gitcore-tutorial&quot;&gt;gitcore-tutorial[7]&lt;/a&gt; goes into detail on the lower-level Git mechanisms involved in, for example, creating a new commit.</source>
          <target state="translated">Git開発者向けに、&lt;a href=&quot;gitcore-tutorial&quot;&gt;gitcore-tutorial [7]&lt;/a&gt;は、たとえば、新しいコミットの作成に関連する低レベルのGitメカニズムについて詳しく説明しています。</target>
        </trans-unit>
        <trans-unit id="9c7a8b6d1a7a0700f3cd22ce6172861bfe044c11" translate="yes" xml:space="preserve">
          <source>For SSH clients that will make commits, make sure their server-side .ssh/environment files (or .bashrc, etc., according to their specific shell) export appropriate values for GIT_AUTHOR_NAME, GIT_AUTHOR_EMAIL, GIT_COMMITTER_NAME, and GIT_COMMITTER_EMAIL. For SSH clients whose login shell is bash, .bashrc may be a reasonable alternative.</source>
          <target state="translated">コミットを行う SSH クライアントの場合、サーバ側の .ssh/environment ファイル (または特定のシェルに応じた .bashrc など)に GIT_AUTHOR_NAME,GIT_AUTHOR_EMAIL,GIT_COMMITTER_NAME,GIT_COMMITTER_EMAIL の適切な値が書き出されていることを確認してください。ログインシェルが bash である SSH クライアントの場合、.bashrc が妥当な代替手段となるかもしれません。</target>
        </trans-unit>
        <trans-unit id="e127a96a43fc87667b0c86a8698d094b3fabedbe" translate="yes" xml:space="preserve">
          <source>For URLs in &lt;code&gt;https://weak.example.com&lt;/code&gt;, &lt;code&gt;http.sslVerify&lt;/code&gt; is set to false, while it is set to &lt;code&gt;true&lt;/code&gt; for all others:</source>
          <target state="translated">&lt;code&gt;https://weak.example.com&lt;/code&gt; の URLの場合、 &lt;code&gt;http.sslVerify&lt;/code&gt; はfalseに設定されてい &lt;code&gt;true&lt;/code&gt; が、他のすべてのURLではtrueに設定されています。</target>
        </trans-unit>
        <trans-unit id="701bbbb19204ae1c36fbfa4b6462dff9d4624e60" translate="yes" xml:space="preserve">
          <source>For a &lt;code&gt;get&lt;/code&gt; operation, the helper should produce a list of attributes on stdout in the same format (see &lt;a href=&quot;git-credential&quot;&gt;git-credential[1]&lt;/a&gt; for common attributes). A helper is free to produce a subset, or even no values at all if it has nothing useful to provide. Any provided attributes will overwrite those already known about by Git&amp;rsquo;s credential subsystem.</source>
          <target state="translated">以下のため &lt;code&gt;get&lt;/code&gt; 操作、ヘルパーが（参照と同じ形式で標準出力に属性のリストを生成しなければならない&lt;a href=&quot;git-credential&quot;&gt;のgit-資格[1]&lt;/a&gt;一般的な属性のため）。ヘルパーはサブセットを自由に作成できます。提供するのに役立つものがない場合は、値をまったく作成しません。提供された属性は、Gitの資格情報サブシステムによってすでに知られている属性を上書きします。</target>
        </trans-unit>
        <trans-unit id="ef97080144d6e0b76f4c32d65bbd8d420f1d9d3f" translate="yes" xml:space="preserve">
          <source>For a &lt;code&gt;store&lt;/code&gt; or &lt;code&gt;erase&lt;/code&gt; operation, the helper&amp;rsquo;s output is ignored.</source>
          <target state="translated">以下のために &lt;code&gt;store&lt;/code&gt; または &lt;code&gt;erase&lt;/code&gt; 動作では、ヘルパーの出力は無視されます。</target>
        </trans-unit>
        <trans-unit id="51c95f036bd90f837a4d78c935d1c885601df8ec" translate="yes" xml:space="preserve">
          <source>For a custom merge command, specify whether the exit code of the merge command can be used to determine whether the merge was successful. If this is not set to true then the merge target file timestamp is checked and the merge assumed to have been successful if the file has been updated, otherwise the user is prompted to indicate the success of the merge.</source>
          <target state="translated">カスタム マージ コマンドの場合、マージが成功したかどうかを判断するために、マージ コマンドの終了コードを使用できるかどうかを指定します。これが true に設定されていない場合は、マージ対象のファイルのタイムスタンプがチェックされ、ファイルが更新されていればマージが成功したものとみなされますが、そうでない場合は、マージが成功したことを示すプロンプトが表示されます。</target>
        </trans-unit>
        <trans-unit id="832a920de5e5a1607e20fda89c6b16105d6a3d66" translate="yes" xml:space="preserve">
          <source>For a description of which objects are considered for pruning, see &lt;code&gt;git fsck&lt;/code&gt;'s --unreachable option.</source>
          <target state="translated">どのオブジェクトがプルーニングの対象となるかについては、 &lt;code&gt;git fsck&lt;/code&gt; の--unreachableオプションを参照してください。</target>
        </trans-unit>
        <trans-unit id="7772aa877c345ccdb695091fd19f024126a4a0b8" translate="yes" xml:space="preserve">
          <source>For a detailed description of &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; see above under &lt;code&gt;from&lt;/code&gt;.</source>
          <target state="translated">詳細については &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; の下に上記参照 &lt;code&gt;from&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="97b7c41fd980027cd240574fa45f8b9cf3a30c50" translate="yes" xml:space="preserve">
          <source>For a detailed description of &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; see above under &lt;code&gt;commit&lt;/code&gt; and &lt;code&gt;from&lt;/code&gt;.</source>
          <target state="translated">詳細については、 &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; と &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 下の上記参照 &lt;code&gt;commit&lt;/code&gt; と &lt;code&gt;from&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c4f4b9fba6569cfb2eebe32e9b505f5e163da8ae" translate="yes" xml:space="preserve">
          <source>For a failed update, more details are given:</source>
          <target state="translated">失敗したアップデートについては、詳細を記載しています。</target>
        </trans-unit>
        <trans-unit id="243468740a36ab67df241df82903537b2a102239" translate="yes" xml:space="preserve">
          <source>For a more complete list of ways to spell &amp;lt;commit&amp;gt;, see &quot;SPECIFYING REVISIONS&quot; section in &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;. However, &quot;diff&quot; is about comparing two &lt;code&gt;endpoints&lt;/code&gt;, not ranges, and the range notations (&quot;&amp;lt;commit&amp;gt;..&amp;lt;commit&amp;gt;&quot; and &quot;&amp;lt;commit&amp;gt;...&amp;lt;commit&amp;gt;&quot;) do not mean a range as defined in the &quot;SPECIFYING RANGES&quot; section in &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;.</source>
          <target state="translated">&amp;lt;commit&amp;gt;を綴る方法のより完全なリストについては、&lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]の&lt;/a&gt;「改訂の指定」セクションを参照してください。ただし、「diff」は範囲ではなく2つの &lt;code&gt;endpoints&lt;/code&gt; 比較するものであり、範囲の表記（ &quot;&amp;lt;commit&amp;gt; .. &amp;lt;commit&amp;gt;&quot;および &quot;&amp;lt;commit&amp;gt; ... &amp;lt;commit&amp;gt;&quot;）は、&lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]&lt;/a&gt;の「範囲の指定」セクション。</target>
        </trans-unit>
        <trans-unit id="aef391cab8f8e654bd28a4ebab3ff359b2dd758d" translate="yes" xml:space="preserve">
          <source>For a more complete list of ways to spell object names, see &quot;SPECIFYING REVISIONS&quot; section in &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;.</source>
          <target state="translated">オブジェクト名を綴る方法のより完全なリストについては、&lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]の&lt;/a&gt;「改訂の指定」セクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="ffb03e9988d5aab6ca13a5c4410e25c3bc4d2c1f" translate="yes" xml:space="preserve">
          <source>For a more detailed discussion of the procedure and additional tips, see the &quot;INTERACTIVE MODE&quot; section of &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt;.</source>
          <target state="translated">手順の詳細と追加のヒントについては、&lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]&lt;/a&gt;の「インタラクティブモード」セクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="21840545ec0ef1fb11dadc3e0bd425ddda71d447" translate="yes" xml:space="preserve">
          <source>For a path that is unmerged, &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; is called with 1 parameter, &amp;lt;path&amp;gt;.</source>
          <target state="translated">マージされていないパスの場合、 &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; が1つのパラメーター&amp;lt;path&amp;gt;で呼び出されます。</target>
        </trans-unit>
        <trans-unit id="bf84b30d98b0b2aee4084cebd6a510d7735317e2" translate="yes" xml:space="preserve">
          <source>For a regular file &lt;code&gt;f&lt;/code&gt;, &lt;code&gt;echo HEAD:f | git cat-file --batch&lt;/code&gt; would print</source>
          <target state="translated">通常のファイル &lt;code&gt;f&lt;/code&gt; の場合、 &lt;code&gt;echo HEAD:f | git cat-file --batch&lt;/code&gt; は印刷されます</target>
        </trans-unit>
        <trans-unit id="3d0f9234523f6052cd5829e5dd1cdac95a9b09fd" translate="yes" xml:space="preserve">
          <source>For a simple local test, you can use &lt;a href=&quot;git-remote-ext&quot;&gt;git-remote-ext[1]&lt;/a&gt;:</source>
          <target state="translated">単純なローカルテストの場合は、&lt;a href=&quot;git-remote-ext&quot;&gt;git-remote-ext [1]を&lt;/a&gt;使用できます。</target>
        </trans-unit>
        <trans-unit id="428bfb3c06af83865df8238da30e9618f9cb0a09" translate="yes" xml:space="preserve">
          <source>For a successfully fetched ref, the summary shows the old and new values of the ref in a form suitable for using as an argument to &lt;code&gt;git log&lt;/code&gt; (this is &lt;code&gt;&amp;lt;old&amp;gt;..&amp;lt;new&amp;gt;&lt;/code&gt; in most cases, and &lt;code&gt;&amp;lt;old&amp;gt;...&amp;lt;new&amp;gt;&lt;/code&gt; for forced non-fast-forward updates).</source>
          <target state="translated">正常にフェッチされたrefの要約には、refの古い値と新しい値が &lt;code&gt;git log&lt;/code&gt; の引数として使用するのに適した形式で表示されます（ほとんどの場合、これは &lt;code&gt;&amp;lt;old&amp;gt;..&amp;lt;new&amp;gt;&lt;/code&gt; 、および &lt;code&gt;&amp;lt;old&amp;gt;...&amp;lt;new&amp;gt;&lt;/code&gt; （強制的な非早送り更新の場合）。</target>
        </trans-unit>
        <trans-unit id="95550d69988e7a758b9c94b13942bde9ad57e2ef" translate="yes" xml:space="preserve">
          <source>For a successfully pushed ref, the summary shows the old and new values of the ref in a form suitable for using as an argument to &lt;code&gt;git log&lt;/code&gt; (this is &lt;code&gt;&amp;lt;old&amp;gt;..&amp;lt;new&amp;gt;&lt;/code&gt; in most cases, and &lt;code&gt;&amp;lt;old&amp;gt;...&amp;lt;new&amp;gt;&lt;/code&gt; for forced non-fast-forward updates).</source>
          <target state="translated">正常にプッシュされたrefの要約には、refの古い値と新しい値が &lt;code&gt;git log&lt;/code&gt; の引数として使用するのに適した形式で表示されます（ほとんどの場合、これは &lt;code&gt;&amp;lt;old&amp;gt;..&amp;lt;new&amp;gt;&lt;/code&gt; 、および &lt;code&gt;&amp;lt;old&amp;gt;...&amp;lt;new&amp;gt;&lt;/code&gt; （強制的な非早送り更新の場合）。</target>
        </trans-unit>
        <trans-unit id="d2bfe73291a6ef412f90bf2eac1210664a9553b3" translate="yes" xml:space="preserve">
          <source>For all objects, the following names can be used:</source>
          <target state="translated">すべてのオブジェクトに対して、以下の名前を使用することができます。</target>
        </trans-unit>
        <trans-unit id="96992b112d12dd337ecf884c867dcddc44e026cf" translate="yes" xml:space="preserve">
          <source>For all options that output values and/or keys, always end values with the null character (instead of a newline). Use newline instead as a delimiter between key and value. This allows for secure parsing of the output without getting confused e.g. by values that contain line breaks.</source>
          <target state="translated">値やキーを出力するすべてのオプシ ョ ンでは、 値の末尾には必ずヌルキ ャ ラ ク タ (改行ではな く)を付けて く だ さ い。キーと値の間の区切り文字としては、代わりに改行を用います。これにより、例えば改行を含む値などで混乱することなく、安全に出力を解析することができます。</target>
        </trans-unit>
        <trans-unit id="8ac2c111de5df363fa2f5b2b630af5f75a90bcb1" translate="yes" xml:space="preserve">
          <source>For an unmerged path, instead of recording a single mode/SHA-1 pair, the index records up to three such pairs; one from tree O in stage 1, A in stage 2, and B in stage 3. This information can be used by the user (or the porcelain) to see what should eventually be recorded at the path. (see &lt;a href=&quot;git-read-tree&quot;&gt;git-read-tree[1]&lt;/a&gt; for more information on state)</source>
          <target state="translated">マージされていないパスの場合、インデックスは単一のモードとSHA-1のペアを記録する代わりに、最大3つのペアを記録します。ステージ1のツリーO、ステージ2のA、ステージ3のBから1つ。この情報は、ユーザー（または磁器）がパスで最終的に何を記録するかを確認するために使用できます。（状態の詳細については、&lt;a href=&quot;git-read-tree&quot;&gt;git-read-tree [1]&lt;/a&gt;を参照してください）</target>
        </trans-unit>
        <trans-unit id="43b2d74a2014d25aa6c53b32650e8baad61de67e" translate="yes" xml:space="preserve">
          <source>For any commit graph, you can see the number associated with each commit using &quot;git rev-list --bisect-all&quot;.</source>
          <target state="translated">任意のコミットグラフについては、&quot;git rev-list --bisect-all&quot; を使用すると、それぞれのコミットに関連する番号を見ることができます。</target>
        </trans-unit>
        <trans-unit id="672441c22b399b226ed91a2cbed5740025f9d076" translate="yes" xml:space="preserve">
          <source>For any remote-tracking branch &lt;code&gt;%(upstream)&lt;/code&gt;, &lt;code&gt;%(upstream:remotename)&lt;/code&gt; and &lt;code&gt;%(upstream:remoteref)&lt;/code&gt; refer to the name of the remote and the name of the tracked remote ref, respectively. In other words, the remote-tracking branch can be updated explicitly and individually by using the refspec &lt;code&gt;%(upstream:remoteref):%(upstream)&lt;/code&gt; to fetch from &lt;code&gt;%(upstream:remotename)&lt;/code&gt;.</source>
          <target state="translated">リモート追跡ブランチ &lt;code&gt;%(upstream)&lt;/code&gt; 、 &lt;code&gt;%(upstream:remotename)&lt;/code&gt; および &lt;code&gt;%(upstream:remoteref)&lt;/code&gt; の場合、それぞれリモートの名前と追跡されたリモート参照の名前を参照します。換言すれば、リモート追跡ブランチはrefspec使用して明示的かつ個別に更新することができ &lt;code&gt;%(upstream:remoteref):%(upstream)&lt;/code&gt; からフェッチする &lt;code&gt;%(upstream:remotename)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="242026e8d7d0593118b4fae738fc0c3f1a90be23" translate="yes" xml:space="preserve">
          <source>For atomicity, &lt;code&gt;git apply&lt;/code&gt; by default fails the whole patch and does not touch the working tree when some of the hunks do not apply. This option makes it apply the parts of the patch that are applicable, and leave the rejected hunks in corresponding *.rej files.</source>
          <target state="translated">アトミック性の &lt;code&gt;git apply&lt;/code&gt; 、デフォルトではgit applyはパッチ全体を失敗させ、一部のハンクが適用されない場合は作業ツリーに触れません。このオプションは、適用可能なパッチの部分を適用し、拒否されたハンクを対応する* .rejファイルに残します。</target>
        </trans-unit>
        <trans-unit id="8d098e130baba0ccc99da718229f5fc6bc213a77" translate="yes" xml:space="preserve">
          <source>For backwards compatibility, the &lt;code&gt;crlf&lt;/code&gt; attribute is interpreted as follows:</source>
          <target state="translated">下位互換性のために、 &lt;code&gt;crlf&lt;/code&gt; 属性は次のように解釈されます。</target>
        </trans-unit>
        <trans-unit id="816a47e0ab5f0e7c8c410570167eb66d775695ae" translate="yes" xml:space="preserve">
          <source>For best consistency with &lt;code&gt;cvs&lt;/code&gt;, it is probably best to override the defaults by setting &lt;code&gt;gitcvs.usecrlfattr&lt;/code&gt; to true, and &lt;code&gt;gitcvs.allBinary&lt;/code&gt; to &quot;guess&quot;.</source>
          <target state="translated">&lt;code&gt;cvs&lt;/code&gt; との一貫性を &lt;code&gt;gitcvs.usecrlfattr&lt;/code&gt; ために、gitcvs.usecrlfattrをtrueに設定し、 &lt;code&gt;gitcvs.allBinary&lt;/code&gt; を &quot;guess&quot;に設定することでデフォルトを上書きするのがおそらく最善です。</target>
        </trans-unit>
        <trans-unit id="bad93aa83b2df49f46d609a291da6014ee26a719" translate="yes" xml:space="preserve">
          <source>For best results, &lt;code&gt;clean&lt;/code&gt; should not alter its output further if it is run twice (&quot;clean&amp;rarr;clean&quot; should be equivalent to &quot;clean&quot;), and multiple &lt;code&gt;smudge&lt;/code&gt; commands should not alter &lt;code&gt;clean&lt;/code&gt;'s output (&quot;smudge&amp;rarr;smudge&amp;rarr;clean&quot; should be equivalent to &quot;clean&quot;). See the section on merging below.</source>
          <target state="translated">最良の結果を得るには、 &lt;code&gt;clean&lt;/code&gt; が2回実行された場合に出力を変更しないでください（ &quot;clean&amp;rarr;clean&quot;は &quot;clean&quot;と同等です）。複数の &lt;code&gt;smudge&lt;/code&gt; コマンドで &lt;code&gt;clean&lt;/code&gt; の出力を変更しないでください（ &quot;smudge&amp;rarr;smudge&amp;rarr;clean&quot; 「クリーン」と同等である必要があります）。以下のマージに関するセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="8d3928084bacb031775f5d7bad0ceaa321b4778c" translate="yes" xml:space="preserve">
          <source>For blobs and trees, you can&amp;rsquo;t do the same, but you can still examine them. You can just do</source>
          <target state="translated">ブロブとツリーの場合、同じことはできませんが、それらを調べることはできます。あなたはただすることができます</target>
        </trans-unit>
        <trans-unit id="d0eec01499f14d036682e7faa93df840595c4ccf" translate="yes" xml:space="preserve">
          <source>For commit and tag objects, the special &lt;code&gt;creatordate&lt;/code&gt; and &lt;code&gt;creator&lt;/code&gt; fields will correspond to the appropriate date or name-email-date tuple from the &lt;code&gt;committer&lt;/code&gt; or &lt;code&gt;tagger&lt;/code&gt; fields depending on the object type. These are intended for working on a mix of annotated and lightweight tags.</source>
          <target state="translated">コミットとタグオブジェクトに対して、特別 &lt;code&gt;creatordate&lt;/code&gt; と &lt;code&gt;creator&lt;/code&gt; フィールドから適切な日付や名前、電子メールの日付タプルに対応する &lt;code&gt;committer&lt;/code&gt; または &lt;code&gt;tagger&lt;/code&gt; オブジェクトの種類に応じてフィールド。これらは、注釈付きタグと軽量タグの組み合わせで作業することを目的としています。</target>
        </trans-unit>
        <trans-unit id="f1ce66454707d43159aa08f01addd1a2cbbd5b3f" translate="yes" xml:space="preserve">
          <source>For commits it shows the log message and textual diff. It also presents the merge commit in a special format as produced by &lt;code&gt;git diff-tree --cc&lt;/code&gt;.</source>
          <target state="translated">コミットの場合、ログメッセージとテキスト形式の差分が表示されます。また、 &lt;code&gt;git diff-tree --cc&lt;/code&gt; によって生成される特殊な形式でマージコミットを示します。</target>
        </trans-unit>
        <trans-unit id="65305ecf02c6387d8a2b51f2d0ea21b43d00656b" translate="yes" xml:space="preserve">
          <source>For commits which do not start empty but become empty after rebasing, see the --empty flag.</source>
          <target state="translated">リベース後に空にならないコミットについては --empty フラグを参照してください。</target>
        </trans-unit>
        <trans-unit id="5788d84088826961fe0565ab052c9c41c47117d5" translate="yes" xml:space="preserve">
          <source>For commits, you can just use:</source>
          <target state="translated">コミットの場合は、以下のようにします。</target>
        </trans-unit>
        <trans-unit id="600c796c6fdee3517d0340d7c98d0e629e148085" translate="yes" xml:space="preserve">
          <source>For conflicting paths, the index file records up to three versions, as described in the &quot;TRUE MERGE&quot; section of &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt;. The working tree files will include a description of the conflict bracketed by the usual conflict markers &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">パスが競合する場合、&lt;a href=&quot;git-merge&quot;&gt;git-merge [1]&lt;/a&gt;の「TRUE MERGE」セクションで説明されているように、インデックスファイルには最大3つのバージョンが記録されます。作業ツリーファイルには、通常の競合マーカー &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; および &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; で囲まれた競合の説明が含まれます。</target>
        </trans-unit>
        <trans-unit id="35aa73e9eb71becc5a3756c0cf556cc7d0b77d41" translate="yes" xml:space="preserve">
          <source>For conflicting paths, the index file records up to three versions: stage 1 stores the version from the common ancestor, stage 2 from &lt;code&gt;HEAD&lt;/code&gt;, and stage 3 from &lt;code&gt;MERGE_HEAD&lt;/code&gt; (you can inspect the stages with &lt;code&gt;git ls-files -u&lt;/code&gt;). The working tree files contain the result of the &quot;merge&quot; program; i.e. 3-way merge results with familiar conflict markers &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;&lt;code&gt;===&lt;/code&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">競合するパスの場合、インデックスファイルには最大3つのバージョンが記録されます。ステージ1は共通の祖先からのバージョン、 &lt;code&gt;HEAD&lt;/code&gt; からのステージ2 、および &lt;code&gt;MERGE_HEAD&lt;/code&gt; からのステージ3を格納します（ &lt;code&gt;git ls-files -u&lt;/code&gt; でステージを検査できます）。作業ツリーファイルには、「マージ」プログラムの結果が含まれています。つまり、使い慣れた競合マーカー &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; &lt;code&gt;===&lt;/code&gt; &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; を使用した3者間マージ結果。</target>
        </trans-unit>
        <trans-unit id="7a860b5275da5a9c9fab93cf772cd75bc2e0f4eb" translate="yes" xml:space="preserve">
          <source>For consistency, we also try such a trick if &lt;code&gt;man.konqueror.path&lt;/code&gt; is set to something like &lt;code&gt;A_PATH_TO/konqueror&lt;/code&gt;. That means we will try to launch &lt;code&gt;A_PATH_TO/kfmclient&lt;/code&gt; instead.</source>
          <target state="translated">一貫性を &lt;code&gt;man.konqueror.path&lt;/code&gt; ために、man.konqueror.pathが &lt;code&gt;A_PATH_TO/konqueror&lt;/code&gt; のように設定されている場合にも、このようなトリックを試します。つまり、代わりに &lt;code&gt;A_PATH_TO/kfmclient&lt;/code&gt; を起動しようとします。</target>
        </trans-unit>
        <trans-unit id="303c07dbeb4d9b201e995967f10cae861d7b985d" translate="yes" xml:space="preserve">
          <source>For convenience, this data is saved to &lt;code&gt;$GIT_DIR/cvs-authors&lt;/code&gt; each time the &lt;code&gt;-A&lt;/code&gt; option is provided and read from that same file each time &lt;code&gt;git cvsimport&lt;/code&gt; is run.</source>
          <target state="translated">便宜上、このデータは &lt;code&gt;-A&lt;/code&gt; オプションが指定されるたびに &lt;code&gt;$GIT_DIR/cvs-authors&lt;/code&gt; 保存され、 &lt;code&gt;git cvsimport&lt;/code&gt; が実行されるたびに同じファイルから読み取られます。</target>
        </trans-unit>
        <trans-unit id="bc9270ed7ea5a3e841c3245ec308c8ddd86f1b91" translate="yes" xml:space="preserve">
          <source>For credential lookups, the files are read in the order given above, with the first matching credential found taking precedence over credentials found in files further down the list.</source>
          <target state="translated">クレデンシャル検索では、ファイルは上記の順序で読み込まれ、最初に見つかった一致するクレデンシャルが、リストの下のファイルで見つかったクレデンシャルよりも優先されます。</target>
        </trans-unit>
        <trans-unit id="78e4826a9de5d7b3349b3c973d4bc09ea13a37ed" translate="yes" xml:space="preserve">
          <source>For each &amp;ldquo;Name &amp;lt;user@host&amp;gt;&amp;rdquo; or &amp;ldquo;&amp;lt;user@host&amp;gt;&amp;rdquo; from the command-line or standard input (when using &lt;code&gt;--stdin&lt;/code&gt;), look up the person&amp;rsquo;s canonical name and email address (see &quot;Mapping Authors&quot; below). If found, print them; otherwise print the input as-is.</source>
          <target state="translated">コマンドラインまたは標準入力（ &lt;code&gt;--stdin&lt;/code&gt; を使用する場合）からの「名前&amp;lt;user @ host&amp;gt;」または「&amp;lt;user @ host&amp;gt;」ごとに、ユーザーの正規名とメールアドレスを検索します（以下の「作成者のマッピング」を参照） ）。見つかった場合は印刷します。それ以外の場合は、入力をそのまま印刷します。</target>
        </trans-unit>
        <trans-unit id="317daaebd1883bdffebfa8e7b1777b5a4f83c1ca" translate="yes" xml:space="preserve">
          <source>For each &amp;lt;pathspec&amp;gt; given on command line, descend at most &amp;lt;depth&amp;gt; levels of directories. A value of -1 means no limit. This option is ignored if &amp;lt;pathspec&amp;gt; contains active wildcards. In other words if &quot;a*&quot; matches a directory named &quot;a*&quot;, &quot;*&quot; is matched literally so --max-depth is still effective.</source>
          <target state="translated">コマンドラインで指定された各&amp;lt;pathspec&amp;gt;について、最大で&amp;lt;depth&amp;gt;レベルのディレクトリまで下ります。値-1は、制限がないことを意味します。&amp;lt;pathspec&amp;gt;にアクティブなワイルドカードが含まれている場合、このオプションは無視されます。つまり、「a *」が「a *」という名前のディレクトリと一致する場合、「*」は文字通りに一致するため、-max-depthは引き続き有効です。</target>
        </trans-unit>
        <trans-unit id="5e28a0aae950ca165e06c71e20e1b405d570f17a" translate="yes" xml:space="preserve">
          <source>For each URI the server sends, it sends a hash of the pack&amp;rsquo;s contents (as output by git index-pack) followed by the URI.</source>
          <target state="translated">サーバーが送信するURIごとに、パックの内容のハッシュ（git index-packによって出力される）とそれに続くURIが送信されます。</target>
        </trans-unit>
        <trans-unit id="6cf7cc0cba8ed8b7ebafa73d62528bdea5d7f903" translate="yes" xml:space="preserve">
          <source>For each commit a separate file is created in the current directory.</source>
          <target state="translated">コミットごとに、カレントディレクトリに別のファイルが作成されます。</target>
        </trans-unit>
        <trans-unit id="6e5eb78674e89f34ddd48ded79bd04ac86b27923" translate="yes" xml:space="preserve">
          <source>For each commit, show a summary of changes using the raw diff format. See the &quot;RAW OUTPUT FORMAT&quot; section of &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;. This is different from showing the log itself in raw format, which you can achieve with &lt;code&gt;--format=raw&lt;/code&gt;.</source>
          <target state="translated">コミットごとに、生の差分形式を使用して変更の概要を表示します。&lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt;の「RAW出力フォーマット」セクションを参照してください。これは、ログ自体をraw形式で表示することとは異なります。これは、-- &lt;code&gt;--format=raw&lt;/code&gt; 実現できます。</target>
        </trans-unit>
        <trans-unit id="334d2ef126bc398bc9fdce4f33bf828f0bbaab0d" translate="yes" xml:space="preserve">
          <source>For each commit-ish supplied, &lt;code&gt;git describe&lt;/code&gt; will first look for a tag which tags exactly that commit. Annotated tags will always be preferred over lightweight tags, and tags with newer dates will always be preferred over tags with older dates. If an exact match is found, its name will be output and searching will stop.</source>
          <target state="translated">提供された各commit-ish &lt;code&gt;git describe&lt;/code&gt; 、git describeはまず、そのコミットを正確にタグ付けするタグを探します。注釈付きタグは常に軽量タグよりも優先され、新しい日付のタグは常に古い日付のタグよりも優先されます。完全一致が見つかった場合、その名前が出力され、検索は停止します。</target>
        </trans-unit>
        <trans-unit id="499cd7809be15aac9ff7cdcafa51d0930d0f78d9" translate="yes" xml:space="preserve">
          <source>For each contact, a single line is output, terminated by a newline. If the name is provided or known to the &lt;code&gt;mailmap&lt;/code&gt;, &amp;ldquo;Name &amp;lt;user@host&amp;gt;&amp;rdquo; is printed; otherwise only &amp;ldquo;&amp;lt;user@host&amp;gt;&amp;rdquo; is printed.</source>
          <target state="translated">連絡先ごとに、改行で終了する単一の行が出力されます。名前が提供されているか、 &lt;code&gt;mailmap&lt;/code&gt; れている場合、「Name &amp;lt;user @ host&amp;gt;」が出力されます。それ以外の場合は、「&amp;lt;user @ host&amp;gt;」のみが出力されます。</target>
        </trans-unit>
        <trans-unit id="0e11740c89977d85e4dd98daa923a91e3f5130da" translate="yes" xml:space="preserve">
          <source>For each patch the code attempts to extract the author from the patch description. If that fails it falls back to the author specified with --author. If the --author flag was not given the patch description is displayed and the user is asked to interactively enter the author of the patch.</source>
          <target state="translated">各パッチについて、コードはパッチの説明から作者を抽出しようとします。もしそれが失敗した場合は --author で指定された作者に戻ります。author フラグが与えられていない場合は、パッチの説明が表示され、ユーザは対話的にパッチの作者を入力するように求められます。</target>
        </trans-unit>
        <trans-unit id="5681283d451e4fc4fc0ca3089786f576c8a1186d" translate="yes" xml:space="preserve">
          <source>For each path &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; is called, two environment variables, &lt;code&gt;GIT_DIFF_PATH_COUNTER&lt;/code&gt; and &lt;code&gt;GIT_DIFF_PATH_TOTAL&lt;/code&gt; are set.</source>
          <target state="translated">&lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; が呼び出されるパスごとに、 &lt;code&gt;GIT_DIFF_PATH_COUNTER&lt;/code&gt; と &lt;code&gt;GIT_DIFF_PATH_TOTAL&lt;/code&gt; の 2つの環境変数が設定されます。</target>
        </trans-unit>
        <trans-unit id="17e261e522ccbc792cc7bd181c9a0bd755a56975" translate="yes" xml:space="preserve">
          <source>For each pathname given via the command-line or from a file via &lt;code&gt;--stdin&lt;/code&gt;, check whether the file is excluded by .gitignore (or other input files to the exclude mechanism) and output the path if it is excluded.</source>
          <target state="translated">コマンドラインを介して、または &lt;code&gt;--stdin&lt;/code&gt; を介してファイルから指定された各パス名について、ファイルが.gitignore（または除外メカニズムへの他の入力ファイル）によって除外されているかどうかを確認し、除外されている場合はパスを出力します。</target>
        </trans-unit>
        <trans-unit id="3b2b4e958456928c896ce5a2236319df3a467837" translate="yes" xml:space="preserve">
          <source>For each reference update that was added to the transaction, the hook receives on standard input a line of the format:</source>
          <target state="translated">トランザクションに追加された各参照更新に対して、フックは標準入力でフォーマットの行を受け取ります。</target>
        </trans-unit>
        <trans-unit id="c7b8eb760e478aaaedca171d489f16e4864063c9" translate="yes" xml:space="preserve">
          <source>For each repo that you want accessible from CVS you need to edit config in the repo and add the following section.</source>
          <target state="translated">CVSからアクセスできるようにしたい各レポについては、レポ内のconfigを編集して以下のセクションを追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="4a6b07eab1d3f6d06954967f77b7754d8ea06736" translate="yes" xml:space="preserve">
          <source>For every branch that is up to date or successfully pushed, add upstream (tracking) reference, used by argument-less &lt;a href=&quot;git-pull&quot;&gt;git-pull[1]&lt;/a&gt; and other commands. For more information, see &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">最新の、または正常にプッシュされたすべてのブランチに対して、引数なしの&lt;a href=&quot;git-pull&quot;&gt;git-pull [1]&lt;/a&gt;およびその他のコマンドで使用される上流（追跡）参照を追加します。詳細については、&lt;a href=&quot;git-config&quot;&gt;git-config [1]の&lt;/a&gt; &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="288f34b4fe961722eeaf789d738c3abe79ce0128" translate="yes" xml:space="preserve">
          <source>For every pathname, this command will list if each attribute is &lt;code&gt;unspecified&lt;/code&gt;, &lt;code&gt;set&lt;/code&gt;, or &lt;code&gt;unset&lt;/code&gt; as a gitattribute on that pathname.</source>
          <target state="translated">すべてのパス名について、このコマンドは、各属性がそのパス名のgitattributeとして &lt;code&gt;unspecified&lt;/code&gt; 、 &lt;code&gt;set&lt;/code&gt; 、または &lt;code&gt;unset&lt;/code&gt; れているかどうかをリストします。</target>
        </trans-unit>
        <trans-unit id="dc3c09a115b4ee611eb7505826a4fa0c2a8495d8" translate="yes" xml:space="preserve">
          <source>For example</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="b8684a0f4f3937af285df51bf478195b9b43d0d0" translate="yes" xml:space="preserve">
          <source>For example &lt;a href=&quot;git-daemon&quot;&gt;git-daemon[1]&lt;/a&gt; by default (unless &lt;code&gt;--export-all&lt;/code&gt; option is used) allows pulling only for those repositories that have &lt;code&gt;git-daemon-export-ok&lt;/code&gt; file. Adding</source>
          <target state="translated">たとえば、デフォルトで&lt;a href=&quot;git-daemon&quot;&gt;git-daemon [1]&lt;/a&gt;を使用すると（ &lt;code&gt;--export-all&lt;/code&gt; オプションが使用されていない場合）、 &lt;code&gt;git-daemon-export-ok&lt;/code&gt; ファイルを持つリポジトリのみをプルできます。追加</target>
        </trans-unit>
        <trans-unit id="46e0aea8ec6e607a64677afaf2a0016d08ab966a" translate="yes" xml:space="preserve">
          <source>For example David Miller wrote &lt;a href=&quot;#6&quot;&gt;[6]&lt;/a&gt;:</source>
          <target state="translated">たとえば、David Millerは&lt;a href=&quot;#6&quot;&gt;[6]と&lt;/a&gt;書いています。</target>
        </trans-unit>
        <trans-unit id="0e389491903e64c421beccd08371ba327e60cc0c" translate="yes" xml:space="preserve">
          <source>For example an effect from the submodule&amp;rsquo;s &lt;code&gt;.gitignore&lt;/code&gt; file would be observed when you run &lt;code&gt;git status --ignore-submodules=none&lt;/code&gt; in the superproject. This collects information from the submodule&amp;rsquo;s working directory by running &lt;code&gt;status&lt;/code&gt; in the submodule while paying attention to the &lt;code&gt;.gitignore&lt;/code&gt; file of the submodule.</source>
          <target state="translated">たとえば、スーパー &lt;code&gt;git status --ignore-submodules=none&lt;/code&gt; を実行すると、サブモジュールの &lt;code&gt;.gitignore&lt;/code&gt; ファイルからの影響が観察されます。これは、サブモジュールの &lt;code&gt;.gitignore&lt;/code&gt; ファイルに注意を払いながら、サブモジュールで &lt;code&gt;status&lt;/code&gt; を実行することにより、サブモジュールの作業ディレクトリから情報を収集します。</target>
        </trans-unit>
        <trans-unit id="56e9b1c030d9ba0ed8f301bc4d928b5ec348ecfb" translate="yes" xml:space="preserve">
          <source>For example if commit &lt;code&gt;foo&lt;/code&gt; has been replaced by commit &lt;code&gt;bar&lt;/code&gt;:</source>
          <target state="translated">たとえば、commit &lt;code&gt;foo&lt;/code&gt; がcommit &lt;code&gt;bar&lt;/code&gt; に置き換えられた場合：</target>
        </trans-unit>
        <trans-unit id="fc4ffa566856e8487717cc75478e8ddebf738773" translate="yes" xml:space="preserve">
          <source>For example if repositories you are hosting use &quot;phtml&quot; extension for PHP files, and you want to have correct syntax-highlighting for those files, you can add the following to gitweb configuration:</source>
          <target state="translated">たとえば、あなたがホストしているリポジトリで PHP ファイルに &quot;phtml&quot; という拡張子を使用していて、それらのファイルに対して正しいシンタックスハイライトを適用したい場合は、gitweb の設定に次のように追加します。</target>
        </trans-unit>
        <trans-unit id="5154cf5119ca3a0384ad194cc198ec59c07c7ac1" translate="yes" xml:space="preserve">
          <source>For example if we start with a graph like this:</source>
          <target state="translated">例えば、このようなグラフから始めるとします。</target>
        </trans-unit>
        <trans-unit id="011e69a8d88e3f2ecd0b2c97750e695437a8b7be" translate="yes" xml:space="preserve">
          <source>For example one branch can change the semantic of a function while the other branch add more calls to the same function.</source>
          <target state="translated">例えば、あるブランチでは関数のセマンティックを変更し、別のブランチでは同じ関数への呼び出しを追加することができます。</target>
        </trans-unit>
        <trans-unit id="948250d1153d7a9c5c187de68da76cbf9fe7a0b6" translate="yes" xml:space="preserve">
          <source>For example since all normal branches are stored under &lt;code&gt;refs/heads/&lt;/code&gt; name the tag fixup branch &lt;code&gt;TAG_FIXUP&lt;/code&gt;. This way it is impossible for the fixup branch used by the importer to have namespace conflicts with real branches imported from the source (the name &lt;code&gt;TAG_FIXUP&lt;/code&gt; is not &lt;code&gt;refs/heads/TAG_FIXUP&lt;/code&gt;).</source>
          <target state="translated">たとえば、すべての通常のブランチは &lt;code&gt;refs/heads/&lt;/code&gt; という名前で保存されるため、タグフィックスアップブランチ &lt;code&gt;TAG_FIXUP&lt;/code&gt; に名前を付けます。このようにして、インポーターが使用するフィックスアップブランチが、ソースからインポートされた実際のブランチと名前空間を競合させることは不可能です（名前 &lt;code&gt;TAG_FIXUP&lt;/code&gt; は &lt;code&gt;refs/heads/TAG_FIXUP&lt;/code&gt; ではありません）。</target>
        </trans-unit>
        <trans-unit id="4be01aa529e151bdbbe73a5ece143631e964e4ac" translate="yes" xml:space="preserve">
          <source>For example some test suites could be run automatically at night with some unusual (or even random) configurations. And if a regression is found by a test suite, then &quot;git bisect&quot; can be automatically launched, and its result can be emailed to the author of the first bad commit found by &quot;git bisect&quot;, and perhaps other people too. And a new entry in the bug tracking system could be automatically created too.</source>
          <target state="translated">たとえば、いくつかのテストスイートは夜間に、通常とは異なる (あるいはランダムな)設定で自動的に実行されるかもしれません。そして、テストスイートでリグレッションが見つかった場合は、自動的に &quot;git bisect&quot; を起動し、その結果を &quot;git bisect&quot; で最初に見つかった不正なコミットの作者や、おそらく他の人にもメールで知らせることができるようになります。そして、バグ追跡システムの新しいエントリも自動的に作成されるようになります。</target>
        </trans-unit>
        <trans-unit id="8bbfe98ebcd584e72bba80caca0bbe3de761fb8b" translate="yes" xml:space="preserve">
          <source>For example using:</source>
          <target state="translated">例えば、使用しています。</target>
        </trans-unit>
        <trans-unit id="b2715e2afcd57211e00aecf4fa8f8efd172203eb" translate="yes" xml:space="preserve">
          <source>For example with the following graph where H is the &quot;bad&quot; commit and A and D are some parents of some &quot;good&quot; commits:</source>
          <target state="translated">例えば、以下のグラフでは、H が「悪い」コミット、A と D が「良い」コミットの親であるとします。</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="33f7a1b1f9148ad49a81c77432db9d624e3ed14b" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;--batch&lt;/code&gt; without a custom format would produce:</source>
          <target state="translated">たとえば、カスタム形式なしで &lt;code&gt;--batch&lt;/code&gt; を実行すると、次のようになります。</target>
        </trans-unit>
        <trans-unit id="f103141294055917b49b4ff3b11f28f0e7b09a93" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;--cherry-pick --right-only A...B&lt;/code&gt; omits those commits from &lt;code&gt;B&lt;/code&gt; which are in &lt;code&gt;A&lt;/code&gt; or are patch-equivalent to a commit in &lt;code&gt;A&lt;/code&gt;. In other words, this lists the &lt;code&gt;+&lt;/code&gt; commits from &lt;code&gt;git cherry A B&lt;/code&gt;. More precisely, &lt;code&gt;--cherry-pick --right-only --no-merges&lt;/code&gt; gives the exact list.</source>
          <target state="translated">たとえば、-- &lt;code&gt;--cherry-pick --right-only A...B&lt;/code&gt; は、 &lt;code&gt;A&lt;/code&gt; にある、または &lt;code&gt;A&lt;/code&gt; のコミットにパッチ相当する &lt;code&gt;B&lt;/code&gt; からのコミットを省略します。言い換えれば、これは &lt;code&gt;git cherry A B&lt;/code&gt; からの &lt;code&gt;+&lt;/code&gt; コミットをリストします。より正確には、-- &lt;code&gt;--cherry-pick --right-only --no-merges&lt;/code&gt; は正確なリストを提供します。</target>
        </trans-unit>
        <trans-unit id="f8a58c9ab1aebec2fe76ee8cb4f7dc47b3afba08" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;--word-diff-regex=.&lt;/code&gt; will treat each character as a word and, correspondingly, show differences character by character.</source>
          <target state="translated">たとえば、 &lt;code&gt;--word-diff-regex=.&lt;/code&gt; 各文字を単語として扱い、それに応じて文字ごとに違いを示します。</target>
        </trans-unit>
        <trans-unit id="9497e805114a62dd0cfbb0fd446cb80188b76834" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;git bisect reset bisect/bad&lt;/code&gt; will check out the first bad revision, while &lt;code&gt;git bisect reset HEAD&lt;/code&gt; will leave you on the current bisection commit and avoid switching commits at all.</source>
          <target state="translated">たとえば、 &lt;code&gt;git bisect reset bisect/bad&lt;/code&gt; は最初の不良リビジョンをチェックアウトしますが、 &lt;code&gt;git bisect reset HEAD&lt;/code&gt; は現在の二分コミットをそのままにし、コミットの切り替えをまったく回避します。</target>
        </trans-unit>
        <trans-unit id="fe1483bfc3665f725dee6688f5887a817d1f226c" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;main-worktree/HEAD&lt;/code&gt; or &lt;code&gt;main-worktree/refs/bisect/good&lt;/code&gt; resolve to the same value as the main working tree&amp;rsquo;s &lt;code&gt;HEAD&lt;/code&gt; and &lt;code&gt;refs/bisect/good&lt;/code&gt; respectively. Similarly, &lt;code&gt;worktrees/foo/HEAD&lt;/code&gt; or &lt;code&gt;worktrees/bar/refs/bisect/bad&lt;/code&gt; are the same as &lt;code&gt;$GIT_COMMON_DIR/worktrees/foo/HEAD&lt;/code&gt; and &lt;code&gt;$GIT_COMMON_DIR/worktrees/bar/refs/bisect/bad&lt;/code&gt;.</source>
          <target state="translated">たとえば、 &lt;code&gt;main-worktree/HEAD&lt;/code&gt; または &lt;code&gt;main-worktree/refs/bisect/good&lt;/code&gt; は、それぞれメインの作業ツリーの &lt;code&gt;HEAD&lt;/code&gt; および &lt;code&gt;refs/bisect/good&lt;/code&gt; と同じ値に解決されます。同様に、 &lt;code&gt;worktrees/foo/HEAD&lt;/code&gt; または &lt;code&gt;worktrees/bar/refs/bisect/bad&lt;/code&gt; は、 &lt;code&gt;$GIT_COMMON_DIR/worktrees/foo/HEAD&lt;/code&gt; および &lt;code&gt;$GIT_COMMON_DIR/worktrees/bar/refs/bisect/bad&lt;/code&gt; と同じです。</target>
        </trans-unit>
        <trans-unit id="138442d2b65de29c2047a8caafb4d9bebbf214b3" translate="yes" xml:space="preserve">
          <source>For example, Documentation/*.jpg will match all .jpg files in the Documentation subtree, including Documentation/chapter_1/figure_1.jpg.</source>
          <target state="translated">例えば、Documentation/*.jpgは、Documentation/chapter_1/figure_1.jpgを含むDocumentationサブツリーのすべての.jpgファイルにマッチします。</target>
        </trans-unit>
        <trans-unit id="0d743ee5b8f526c69043aec1a6e6a8e47be44f66" translate="yes" xml:space="preserve">
          <source>For example, Microsoft Visual Studio resources files (&lt;code&gt;*.rc&lt;/code&gt;) or PowerShell script files (&lt;code&gt;*.ps1&lt;/code&gt;) are sometimes encoded in UTF-16. If you declare &lt;code&gt;*.ps1&lt;/code&gt; as files as UTF-16 and you add &lt;code&gt;foo.ps1&lt;/code&gt; with a &lt;code&gt;working-tree-encoding&lt;/code&gt; enabled Git client, then &lt;code&gt;foo.ps1&lt;/code&gt; will be stored as UTF-8 internally. A client without &lt;code&gt;working-tree-encoding&lt;/code&gt; support will checkout &lt;code&gt;foo.ps1&lt;/code&gt; as UTF-8 encoded file. This will typically cause trouble for the users of this file.</source>
          <target state="translated">たとえば、Microsoft Visual Studioリソースファイル（ &lt;code&gt;*.rc&lt;/code&gt; ）またはPowerShellスクリプトファイル（ &lt;code&gt;*.ps1&lt;/code&gt; ）は、UTF-16でエンコードされる場合があります。あなたが宣言した場合 &lt;code&gt;*.ps1&lt;/code&gt; UTF-16などのファイルとして、あなたが追加 &lt;code&gt;foo.ps1&lt;/code&gt; をして &lt;code&gt;working-tree-encoding&lt;/code&gt; のGitクライアントを有効にし、その後、 &lt;code&gt;foo.ps1&lt;/code&gt; は内部的にUTF-8として保存されます。 &lt;code&gt;working-tree-encoding&lt;/code&gt; サポートのないクライアントは、 &lt;code&gt;foo.ps1&lt;/code&gt; をUTF-8エンコードファイルとしてチェックアウトします。これは通常、このファイルのユーザーに問題を引き起こします。</target>
        </trans-unit>
        <trans-unit id="1ed869792207741cfe6bed98106c7b8b8a3d4f0d" translate="yes" xml:space="preserve">
          <source>For example, a patch that talks about updating &lt;code&gt;a/git-gui.sh&lt;/code&gt; to &lt;code&gt;b/git-gui.sh&lt;/code&gt; can be applied to the file in the working tree &lt;code&gt;modules/git-gui/git-gui.sh&lt;/code&gt; by running &lt;code&gt;git apply --directory=modules/git-gui&lt;/code&gt;.</source>
          <target state="translated">たとえば、a &lt;code&gt;a/git-gui.sh&lt;/code&gt; を &lt;code&gt;b/git-gui.sh&lt;/code&gt; に更新することを説明するパッチは、 &lt;code&gt;git apply --directory=modules/git-gui&lt;/code&gt; 実行して、作業ツリー &lt;code&gt;modules/git-gui/git-gui.sh&lt;/code&gt; のファイルに適用できます。 -directory = modules / git-gui。</target>
        </trans-unit>
        <trans-unit id="ce77d8f6da94ff85eab04ae4cdac09d8840be36a" translate="yes" xml:space="preserve">
          <source>For example, a pattern &lt;code&gt;doc/frotz/&lt;/code&gt; matches &lt;code&gt;doc/frotz&lt;/code&gt; directory, but not &lt;code&gt;a/doc/frotz&lt;/code&gt; directory; however &lt;code&gt;frotz/&lt;/code&gt; matches &lt;code&gt;frotz&lt;/code&gt; and &lt;code&gt;a/frotz&lt;/code&gt; that is a directory (all paths are relative from the &lt;code&gt;.gitignore&lt;/code&gt; file).</source>
          <target state="translated">たとえば、パターン &lt;code&gt;doc/frotz/&lt;/code&gt; &lt;code&gt;doc/frotz&lt;/code&gt; ディレクトリと一致しますが &lt;code&gt;a/doc/frotz&lt;/code&gt; ディレクトリとは一致しません。ただし、 &lt;code&gt;frotz/&lt;/code&gt; は、 &lt;code&gt;frotz&lt;/code&gt; およびディレクトリである &lt;code&gt;a/frotz&lt;/code&gt; に一致します（すべてのパスは &lt;code&gt;.gitignore&lt;/code&gt; ファイルからの相対パスです）。</target>
        </trans-unit>
        <trans-unit id="67b1d0bce407e8b4870f6f6a95250837544f5b7b" translate="yes" xml:space="preserve">
          <source>For example, an attempt to rearrange</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="5bf319ce2803b376c46250398e2ab2c650bad072" translate="yes" xml:space="preserve">
          <source>For example, at the time this page was written, the &lt;a href=&quot;http://repo.or.cz&quot;&gt;http://repo.or.cz&lt;/a&gt; Git hosting site set it to the following to enable graphical log (using the third party tool &lt;strong&gt;git-browser&lt;/strong&gt;):</source>
          <target state="translated">たとえば、このページが作成された時点で、&lt;a href=&quot;http://repo.or.cz&quot;&gt;http：//repo.or.cz&lt;/a&gt; Gitホスティングサイトは、（サードパーティツール&lt;strong&gt;git-browserを使用して&lt;/strong&gt;）グラフィカルログを有効にするために次のように設定しています。</target>
        </trans-unit>
        <trans-unit id="ff9841351106eb72affbaa34cd9000cbe695e6c0" translate="yes" xml:space="preserve">
          <source>For example, consider a git repository containing:</source>
          <target state="translated">例えば、git リポジトリに含まれているものを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="aa3e19341d33b69e0c7637f09cb4c872d477e052" translate="yes" xml:space="preserve">
          <source>For example, for the above graph, a command like:</source>
          <target state="translated">例えば、上のグラフの場合、次のようなコマンドを実行します。</target>
        </trans-unit>
        <trans-unit id="e5fffc70646f6a27f7f67e5894c9b6fc5ccd683b" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;$projectroot&lt;/code&gt; is set to &quot;/srv/git&quot; by putting the following in gitweb config file:</source>
          <target state="translated">例えば、場合 &lt;code&gt;$projectroot&lt;/code&gt; gitwebの設定ファイルに次のように置くことによって、「/ srvの/ gitの」に設定されています：</target>
        </trans-unit>
        <trans-unit id="852dc3836c1061d866e063a7498878f33ef3ce12" translate="yes" xml:space="preserve">
          <source>For example, if the P4 repository structure is:</source>
          <target state="translated">例えば、P4のリポジトリ構造の場合。</target>
        </trans-unit>
        <trans-unit id="36dce8b0d031af7904e6cd8255529f9ec8396929" translate="yes" xml:space="preserve">
          <source>For example, if the file you want to change is some sort of config file, the repository can include a sample config file that can then be copied into the ignored name and modified. The repository can even include a script to treat the sample file as a template, modifying and copying it automatically.</source>
          <target state="translated">例えば、変更したいファイルが何らかの設定ファイルである場合、リポジトリにはサンプルの設定ファイルを含めることができ、それを無視された名前にコピーして変更することができます。リポジトリには、サンプルファイルをテンプレートとして扱い、自動的に修正してコピーするスクリプトを含めることもできます。</target>
        </trans-unit>
        <trans-unit id="4035b3eacf18f396eb5e00ae6815d18cf72feae5" translate="yes" xml:space="preserve">
          <source>For example, if the value for this option is &quot;%=$&quot;, then only lines using the format &lt;code&gt;&amp;lt;token&amp;gt;&amp;lt;sep&amp;gt;&amp;lt;value&amp;gt;&lt;/code&gt; with &amp;lt;sep&amp;gt; containing &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;=&lt;/code&gt; or &lt;code&gt;$&lt;/code&gt; and then spaces will be considered trailers. And &lt;code&gt;%&lt;/code&gt; will be the default separator used, so by default trailers will appear like: &lt;code&gt;&amp;lt;token&amp;gt;% &amp;lt;value&amp;gt;&lt;/code&gt; (one percent sign and one space will appear between the token and the value).</source>
          <target state="translated">たとえば、このオプションの値が &quot;％= $&quot;の場合、 &lt;code&gt;&amp;lt;token&amp;gt;&amp;lt;sep&amp;gt;&amp;lt;value&amp;gt;&lt;/code&gt; の形式を使用し、&amp;lt;sep&amp;gt;に &lt;code&gt;%&lt;/code&gt; 、 &lt;code&gt;=&lt;/code&gt; 、または &lt;code&gt;$&lt;/code&gt; が含まれ、スペースがトレーラーと見なされます。また、 &lt;code&gt;%&lt;/code&gt; は使用されるデフォルトの区切り文字であるため、デフォルトではトレーラは &lt;code&gt;&amp;lt;token&amp;gt;% &amp;lt;value&amp;gt;&lt;/code&gt; ようになります（トークンと値の間に1つのパーセント記号と1つのスペースが表示されます）。</target>
        </trans-unit>
        <trans-unit id="534223d4530dd35132999074203db95c4ecee123" translate="yes" xml:space="preserve">
          <source>For example, if this variable is set to &quot;refs/for&quot;, pushing to reference such as &quot;refs/for/master&quot; will not create or update a reference named &quot;refs/for/master&quot;, but may create or update a pull request directly by running the hook &quot;proc-receive&quot;.</source>
          <target state="translated">例えば、この変数が &quot;refs/for &quot;に設定されている場合、&quot;refs/for/master &quot;のような参照にプッシュしても、&quot;refs/for/master &quot;という名前の参照は作成または更新されませんが、フック &quot;proc-receive &quot;を実行することで直接プルリクエストを作成または更新することができます。</target>
        </trans-unit>
        <trans-unit id="5103535d9f29750b8c9135f826c57c311f8eeae1" translate="yes" xml:space="preserve">
          <source>For example, if we want a password for &lt;code&gt;https://example.com/foo.git&lt;/code&gt;, we might generate the following credential description (don&amp;rsquo;t forget the blank line at the end; it tells &lt;code&gt;git credential&lt;/code&gt; that the application finished feeding all the information it has):</source>
          <target state="translated">たとえば、 &lt;code&gt;https://example.com/foo.git&lt;/code&gt; のパスワードが必要な場合は、次の認証情報の説明を生成します（最後の空白行を忘れないでください。これにより、アプリケーションはすべてのフィードを終了したことを &lt;code&gt;git credential&lt;/code&gt; に伝えますそれが持っている情報）：</target>
        </trans-unit>
        <trans-unit id="bb2f882b3f8efdae1333b719a705576641ca3f31" translate="yes" xml:space="preserve">
          <source>For example, if you are looking for a commit that introduced a performance regression, you might use</source>
          <target state="translated">例えば、パフォーマンスリグレッションを導入したコミットを探している場合、次のようにします。</target>
        </trans-unit>
        <trans-unit id="68d306989ac898943c9324c1636692924527fd1d" translate="yes" xml:space="preserve">
          <source>For example, if you have this topology:</source>
          <target state="translated">例えば、このようなトポロジーを持っているとします。</target>
        </trans-unit>
        <trans-unit id="a61cdb8cd8334eeef24d9dfefb310bcbd689195c" translate="yes" xml:space="preserve">
          <source>For example, if you have two branches, &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, a usual way to list all commits on only one side of them is with &lt;code&gt;--left-right&lt;/code&gt; (see the example below in the description of the &lt;code&gt;--left-right&lt;/code&gt; option). However, it shows the commits that were cherry-picked from the other branch (for example, &amp;ldquo;3rd on b&amp;rdquo; may be cherry-picked from branch A). With this option, such pairs of commits are excluded from the output.</source>
          <target state="translated">たとえば、 &lt;code&gt;A&lt;/code&gt; と &lt;code&gt;B&lt;/code&gt; の 2つのブランチがある場合、それらの片側だけですべてのコミットをリストする通常の方法は &lt;code&gt;--left-right&lt;/code&gt; を使用することです（ &lt;code&gt;--left-right&lt;/code&gt; オプションの説明で以下の例を参照してください）。 。ただし、他のブランチからチェリーピックされたコミットが表示されます（たとえば、「3rd on b」はブランチAからチェリーピックされる場合があります）。このオプションを使用すると、そのようなコミットのペアは出力から除外されます。</target>
        </trans-unit>
        <trans-unit id="fe897c525854ed4ff520e569183f4547ca07cbf6" translate="yes" xml:space="preserve">
          <source>For example, if you use mod_perl to run the script, and have dumb HTTP protocol authentication configured for your repositories, you can use the following hook to allow access only if the user is authorized to read the files:</source>
          <target state="translated">例えば、mod_perl を使用してスクリプトを実行し、リポジトリにダム HTTP プロトコル認証を設定している場合、以下のフックを使用して、ユーザがファイルを読むことを許可されている場合にのみアクセスを許可することができます。</target>
        </trans-unit>
        <trans-unit id="86c7872b373de97c557b525ebe5143ba729f1f41" translate="yes" xml:space="preserve">
          <source>For example, if you want to reorder the last 5 commits, such that what was HEAD~4 becomes the new HEAD. To achieve that, you would call &lt;code&gt;git rebase&lt;/code&gt; like this:</source>
          <target state="translated">たとえば、HEAD〜4であったものが新しいHEADになるように、最後の5つのコミットを並べ替える場合。そのためには、次のように &lt;code&gt;git rebase&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="3cb17626983b1627f4a677c41e03478d83711c28" translate="yes" xml:space="preserve">
          <source>For example, imagine you store the refs for each fork in &lt;code&gt;refs/virtual/ID&lt;/code&gt;, where &lt;code&gt;ID&lt;/code&gt; is a numeric identifier. You might then configure:</source>
          <target state="translated">たとえば、各フォークの参照を &lt;code&gt;refs/virtual/ID&lt;/code&gt; に保存するとします &lt;code&gt;ID&lt;/code&gt; は数値識別子です。次に、以下を構成します。</target>
        </trans-unit>
        <trans-unit id="30bbf60289c9238f0d33e5175010f4e252c9853c" translate="yes" xml:space="preserve">
          <source>For example, in .gitattributes, you would assign the &lt;code&gt;filter&lt;/code&gt; attribute for paths.</source>
          <target state="translated">たとえば、.gitattributesでは、パスに &lt;code&gt;filter&lt;/code&gt; 属性を割り当てます。</target>
        </trans-unit>
        <trans-unit id="c7b53804fabf5a8d611f469400f3d23e0cdaf582" translate="yes" xml:space="preserve">
          <source>For example, in a commit history like this:</source>
          <target state="translated">例えば、このようなコミット履歴では</target>
        </trans-unit>
        <trans-unit id="806ca5f41259915dee6774976f8cdf13ec61deac" translate="yes" xml:space="preserve">
          <source>For example, let&amp;rsquo;s say that you have worked on your working directory, updated some files in the index and are ready to commit. You want to see exactly &lt;strong&gt;what&lt;/strong&gt; you are going to commit, without having to write a new tree object and compare it that way, and to do that, you just do</source>
          <target state="translated">たとえば、作業ディレクトリで作業し、インデックス内のいくつかのファイルを更新して、コミットする準備ができたとします。新しいツリーオブジェクトを作成してそのように比較する必要なしに、コミットする&lt;strong&gt;内容&lt;/strong&gt;を正確に確認したい。それを行うには、</target>
        </trans-unit>
        <trans-unit id="476c3fc4a50784809d3ca0defbcdf28a5bcb4395" translate="yes" xml:space="preserve">
          <source>For example, main-worktree/HEAD or main-worktree/refs/bisect/good resolve to the same value as the main working tree&amp;rsquo;s HEAD and refs/bisect/good respectively. Similarly, worktrees/foo/HEAD or worktrees/bar/refs/bisect/bad are the same as GIT_COMMON_DIR/worktrees/foo/HEAD and GIT_COMMON_DIR/worktrees/bar/refs/bisect/bad.</source>
          <target state="translated">たとえば、main-worktree / HEADまたはmain-worktree / refs / bisect / goodは、それぞれメインの作業ツリーのHEADおよびrefs / bisect / goodと同じ値に解決されます。同様に、worktrees / foo / HEADまたはworktrees / bar / refs / bisect / badは、GIT_COMMON_DIR / worktrees / foo / HEADおよびGIT_COMMON_DIR / worktrees / bar / refs / bisect / badと同じです。</target>
        </trans-unit>
        <trans-unit id="266db89f5ed370855ec231f0d9586be36c8c2a06" translate="yes" xml:space="preserve">
          <source>For example, running &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; generates this tree object from the index, stores it in the object database, and uses it as the tree object associated with the new commit.</source>
          <target state="translated">たとえば、&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]を実行すると&lt;/a&gt;、インデックスからこのツリーオブジェクトが生成され、オブジェクトデータベースに格納され、新しいコミットに関連付けられたツリーオブジェクトとして使用されます。</target>
        </trans-unit>
        <trans-unit id="9241280c5dcf375f9e4ee8c8496a1f68f481ea18" translate="yes" xml:space="preserve">
          <source>For example, starting with this index:</source>
          <target state="translated">例えば、このインデックスから始めると</target>
        </trans-unit>
        <trans-unit id="37236815fc65047678c9d53df59b5a94b9133df3" translate="yes" xml:space="preserve">
          <source>For example, the following fetch command spawned ssh, index-pack, rev-list, and gc. This example also shows that fetch took 5.199 seconds and of that 4.932 was in ssh.</source>
          <target state="translated">例えば、以下の fetch コマンドは ssh、index-pack、rev-list、および gc を生成しました。この例では、fetch には 5.199 秒かかり、そのうち 4.932 秒は ssh にあったことがわかります。</target>
        </trans-unit>
        <trans-unit id="675eb647719ee2ad2bd9af2ee96b8f7029195efd" translate="yes" xml:space="preserve">
          <source>For example, the following setting produces a breadcrumb trail like &quot;home / dev / projects / &amp;hellip;​&quot; where &quot;projects&quot; is the home link.</source>
          <target state="translated">たとえば、次の設定は「home / dev / projects /&amp;hellip;」のようなパンくずリストを作成します。ここで、「projects」はホームリンクです。</target>
        </trans-unit>
        <trans-unit id="f229d0901b53da5a8037ba5b963ab5e1b0a84fc7" translate="yes" xml:space="preserve">
          <source>For example, the hook can simply run &lt;code&gt;git read-tree -u -m HEAD &quot;$1&quot;&lt;/code&gt; in order to emulate &lt;code&gt;git fetch&lt;/code&gt; that is run in the reverse direction with &lt;code&gt;git push&lt;/code&gt;, as the two-tree form of &lt;code&gt;git read-tree -u -m&lt;/code&gt; is essentially the same as &lt;code&gt;git switch&lt;/code&gt; or &lt;code&gt;git checkout&lt;/code&gt; that switches branches while keeping the local changes in the working tree that do not interfere with the difference between the branches.</source>
          <target state="translated">たとえば、フックは単に &lt;code&gt;git read-tree -u -m HEAD &quot;$1&quot;&lt;/code&gt; を実行して、 &lt;code&gt;git push&lt;/code&gt; で逆方向に実行される &lt;code&gt;git fetch&lt;/code&gt; をエミュレートするために、2つのツリー形式の &lt;code&gt;git read-tree -u -m&lt;/code&gt; は、ブランチ間の違いを妨げない作業ツリーのローカル変更を維持しながらブランチを切り替える &lt;code&gt;git switch&lt;/code&gt; または &lt;code&gt;git checkout&lt;/code&gt; と基本的に同じです。</target>
        </trans-unit>
        <trans-unit id="2232af53268b39393df426da2516589a0d0a00e9" translate="yes" xml:space="preserve">
          <source>For example, the multithreaded preload-index code can be instrumented with a region around the thread pool and then per-thread start and exit events within the threadproc.</source>
          <target state="translated">例えば、マルチスレッドのプリロードインデックスコードは、スレッドプールの周囲の領域をインストルメントし、スレッドproc内でスレッドごとの開始イベントと終了イベントを発生させることができます。</target>
        </trans-unit>
        <trans-unit id="c6165309453e90635fafde69fa6a0dbf363059c7" translate="yes" xml:space="preserve">
          <source>For example, there can be a &quot;main&quot; branch, and a &quot;dev&quot; branch that was forked of the main branch at a commit named &quot;D&quot; like this:</source>
          <target state="translated">例えば、&quot;main&quot; ブランチと、&quot;d&quot; という名前のコミットでメインブランチをフォークした &quot;dev&quot; ブランチがあります。</target>
        </trans-unit>
        <trans-unit id="fc0695ddae75754b17aaf6b6d741676357b02fb6" translate="yes" xml:space="preserve">
          <source>For example, this configuration:</source>
          <target state="translated">例えば、この構成。</target>
        </trans-unit>
        <trans-unit id="03526c1b7e3b294cd55189c8a4305129233dcf64" translate="yes" xml:space="preserve">
          <source>For example, this line in &lt;code&gt;.gitattributes&lt;/code&gt; can be used to tell the merge machinery to leave much longer (instead of the usual 7-character-long) conflict markers when merging the file &lt;code&gt;Documentation/git-merge.txt&lt;/code&gt; results in a conflict.</source>
          <target state="translated">たとえば、 &lt;code&gt;.gitattributes&lt;/code&gt; のこの行を使用して、 &lt;code&gt;Documentation/git-merge.txt&lt;/code&gt; をマージすると競合が発生した場合に、マージマシンに（通常の7文字長ではなく）より長い競合マーカーを残すように指示できます。</target>
        </trans-unit>
        <trans-unit id="0b89cc0f3038d951dcea25e6121459d7deb13668" translate="yes" xml:space="preserve">
          <source>For example, to default to pushing only the current branch to &lt;code&gt;origin&lt;/code&gt; use &lt;code&gt;git config remote.origin.push HEAD&lt;/code&gt;. Any valid &amp;lt;refspec&amp;gt; (like the ones in the examples below) can be configured as the default for &lt;code&gt;git push origin&lt;/code&gt;.</source>
          <target state="translated">たとえば、デフォルトで現在のブランチのみを &lt;code&gt;origin&lt;/code&gt; にプッシュするには、 &lt;code&gt;git config remote.origin.push HEAD&lt;/code&gt; を使用します。有効な&amp;lt;refspec&amp;gt;（以下の例にあるような）は、 &lt;code&gt;git push origin&lt;/code&gt; のデフォルトとして構成できます。</target>
        </trans-unit>
        <trans-unit id="119ea88469245e9be5ce50fb433af7f4a91870c1" translate="yes" xml:space="preserve">
          <source>For example, to show the diff of the exif information of a file instead of the binary information (assuming you have the exif tool installed), add the following section to your &lt;code&gt;$GIT_DIR/config&lt;/code&gt; file (or &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; file):</source>
          <target state="translated">たとえば、バイナリ情報の代わりにファイルのexif情報の差分を表示するには（exifツールがインストールされている場合）、次のセクションを &lt;code&gt;$GIT_DIR/config&lt;/code&gt; ファイル（または &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; ファイル）に追加します。</target>
        </trans-unit>
        <trans-unit id="0cf3c72a4130dae24f8e93d376c795356d04a806" translate="yes" xml:space="preserve">
          <source>For example, with this topology:</source>
          <target state="translated">例えば、このトポロジーでは</target>
        </trans-unit>
        <trans-unit id="9026d38d92fad70bfcca633c7e54419876aa74d7" translate="yes" xml:space="preserve">
          <source>For example, with this:</source>
          <target state="translated">例えば、これを使って</target>
        </trans-unit>
        <trans-unit id="94a38b75a57da5e0f9eccf5408c94c3056500ecd" translate="yes" xml:space="preserve">
          <source>For example, you can choose a single person to maintain the project&amp;rsquo;s primary public repository. Other developers then clone this repository and each work in their own clone. When they have a series of changes that they&amp;rsquo;re happy with, they ask the maintainer to pull from the branch containing the changes. The maintainer reviews their changes and pulls them into the primary repository, which other developers pull from as necessary to stay coordinated. The Linux kernel and other projects use variants of this model.</source>
          <target state="translated">たとえば、プロジェクトのプライマリパブリックリポジトリを維持するために1人の人物を選択できます。その後、他の開発者がこのリポジトリのクローンを作成し、それぞれが独自のクローンで作業します。満足できる一連の変更がある場合、彼らはメンテナに変更を含むブランチからプルするように依頼します。メンテナは変更をレビューし、プライマリリポジトリにプルします。他の開発者は、調整を維持するために必要に応じてそこからプルします。Linuxカーネルお​​よびその他のプロジェクトは、このモデルのバリアントを使用します。</target>
        </trans-unit>
        <trans-unit id="0740e14a7a7f21956f0379ce28c5b2be003ef53b" translate="yes" xml:space="preserve">
          <source>For example, you&amp;rsquo;d want to do this after doing a &lt;code&gt;git read-tree&lt;/code&gt;, to link up the stat index details with the proper files.</source>
          <target state="translated">たとえば、 &lt;code&gt;git read-tree&lt;/code&gt; を実行した後、これを実行して、statインデックスの詳細を適切なファイルにリンクします。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="0af803cded757214a9f60d6e61360566eb8261f1" translate="yes" xml:space="preserve">
          <source>For git&amp;rsquo;s pre-defined color slots, the attributes are meant to be reset at the beginning of each item in the colored output. So setting &lt;code&gt;color.decorate.branch&lt;/code&gt; to &lt;code&gt;black&lt;/code&gt; will paint that branch name in a plain &lt;code&gt;black&lt;/code&gt;, even if the previous thing on the same output line (e.g. opening parenthesis before the list of branch names in &lt;code&gt;log --decorate&lt;/code&gt; output) is set to be painted with &lt;code&gt;bold&lt;/code&gt; or some other attribute. However, custom log formats may do more complicated and layered coloring, and the negated forms may be useful there.</source>
          <target state="translated">gitの事前定義されたカラースロットの場合、属性はカラー出力の各アイテムの先頭でリセットされることを意図しています。設定だから &lt;code&gt;color.decorate.branch&lt;/code&gt; をする &lt;code&gt;black&lt;/code&gt; 無地でそのブランチ名をペイントします &lt;code&gt;black&lt;/code&gt; 、同じ出力ライン（中支店名リストの前に例えば左括弧の前の事も、 &lt;code&gt;log --decorate&lt;/code&gt; 出力）に設定されています &lt;code&gt;bold&lt;/code&gt; またはその他の属性でペイントされます。ただし、カスタムログ形式はより複雑で階層化された色分けを行う場合があり、否定された形式が役立つ場合があります。</target>
        </trans-unit>
        <trans-unit id="e39902dddf1a6f048d53b1c87575ee4b12254521" translate="yes" xml:space="preserve">
          <source>For hints on submission using the IMAP interface, see the EXAMPLE section of &lt;a href=&quot;git-imap-send&quot;&gt;git-imap-send[1]&lt;/a&gt;.</source>
          <target state="translated">IMAPインターフェースを使用した&lt;a href=&quot;git-imap-send&quot;&gt;送信の&lt;/a&gt;ヒントについては、git-imap-send [1]の「例」セクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="30ba9877f29cd2e9b6e46df54ef9603700cf47bd" translate="yes" xml:space="preserve">
          <source>For hints on using &lt;code&gt;git send-email&lt;/code&gt; to send your patches through the GMail SMTP server, see the EXAMPLE section of &lt;a href=&quot;git-send-email&quot;&gt;git-send-email[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;git send-email&lt;/code&gt; を使用してGMail SMTPサーバー経由でパッチを送信するためのヒントについては、&lt;a href=&quot;git-send-email&quot;&gt;git-send-email [1]の「&lt;/a&gt;例」セクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="98a5ba2755b886f28a6b38a3063fb22b4953fd08" translate="yes" xml:space="preserve">
          <source>For instance, if the command &lt;code&gt;git push origin master:foreign&lt;/code&gt; were run the hook would receive a line like the following:</source>
          <target state="translated">たとえば、コマンド &lt;code&gt;git push origin master:foreign&lt;/code&gt; が実行された場合、フックは次のような行を受け取ります。</target>
        </trans-unit>
        <trans-unit id="b7654d69e08e0a1f9383662a9764223dc833d854" translate="yes" xml:space="preserve">
          <source>For instance, if the main working tree (or bare repository) is moved, linked working trees will be unable to locate it. Running &lt;code&gt;repair&lt;/code&gt; in the main working tree will reestablish the connection from linked working trees back to the main working tree.</source>
          <target state="translated">たとえば、メインの作業ツリー（またはベアリポジトリ）が移動された場合、リンクされた作業ツリーはそれを見つけることができません。メイン作業ツリーで &lt;code&gt;repair&lt;/code&gt; を実行すると、リンクされた作業ツリーからメイン作業ツリーへの接続が再確立されます。</target>
        </trans-unit>
        <trans-unit id="e0da88c77b6050a1f8498227b0e9ea61aad1dd42" translate="yes" xml:space="preserve">
          <source>For instance, if you configured the &lt;code&gt;diff.algorithm&lt;/code&gt; variable to a non-default value and want to use the default one, then you have to use &lt;code&gt;--diff-algorithm=default&lt;/code&gt; option.</source>
          <target state="translated">たとえば、 &lt;code&gt;diff.algorithm&lt;/code&gt; 変数をデフォルト以外の値に設定し、デフォルトの値を使用したい場合は、 &lt;code&gt;--diff-algorithm=default&lt;/code&gt; オプションを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="c03b6c2e674301ea043615909864bcef9fc3a8b4" translate="yes" xml:space="preserve">
          <source>For instance, imagine we are accessing &lt;code&gt;https://example.com/foo.git&lt;/code&gt;. When Git looks into a config file to see if a section matches this context, it will consider the two a match if the context is a more-specific subset of the pattern in the config file. For example, if you have this in your config file:</source>
          <target state="translated">たとえば、 &lt;code&gt;https://example.com/foo.git&lt;/code&gt; にアクセスしているとしましょう。Gitが構成ファイルを調べてセクションがこのコンテキストに一致するかどうかを確認するときに、コンテキストが構成ファイル内のパターンのより具体的なサブセットである場合、2つは一致すると見なします。たとえば、設定ファイルにこれがある場合：</target>
        </trans-unit>
        <trans-unit id="160dca6e4172cec7a014617ee2140fea1d612055" translate="yes" xml:space="preserve">
          <source>For internal use only. Used in handshaking the wire protocol. Contains a colon &lt;code&gt;:&lt;/code&gt; separated list of keys with optional values &lt;code&gt;key[=value]&lt;/code&gt;. Presence of unknown keys and values must be ignored.</source>
          <target state="translated">内部使用のみ。ワイヤプロトコルのハンドシェイクで使用されます。結腸含ま &lt;code&gt;:&lt;/code&gt; オプションの値を持つキーの区切りリスト &lt;code&gt;key[=value]&lt;/code&gt; 。不明なキーと値の存在は無視する必要があります。</target>
        </trans-unit>
        <trans-unit id="7c3c8218b8f3420e2d309aa9107b8abd4e99e346" translate="yes" xml:space="preserve">
          <source>For local repositories, also supported by Git natively, the following syntaxes may be used:</source>
          <target state="translated">Git でネイティブにサポートされているローカルリポジトリの場合は、以下の構文を使うことができます。</target>
        </trans-unit>
        <trans-unit id="cc185d3a233093301eeacaae1d44792c3563d415" translate="yes" xml:space="preserve">
          <source>For more detailed explanation on these common options, see also &lt;a href=&quot;gitdiffcore&quot;&gt;gitdiffcore[7]&lt;/a&gt;.</source>
          <target state="translated">これらの一般的なオプションの詳細については、&lt;a href=&quot;gitdiffcore&quot;&gt;gitdiffcore [7]&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="cfb518a2bdb468f6a1698c12278a7c2890c2e01b" translate="yes" xml:space="preserve">
          <source>For more details about the &amp;lt;pathspec&amp;gt; syntax, see the &lt;code&gt;pathspec&lt;/code&gt; entry in &lt;a href=&quot;gitglossary&quot;&gt;gitglossary[7]&lt;/a&gt;.</source>
          <target state="translated">&amp;lt;pathspec&amp;gt;構文の詳細については、&lt;a href=&quot;gitglossary&quot;&gt;gitglossary [7]の&lt;/a&gt; &lt;code&gt;pathspec&lt;/code&gt; エントリを参照してください。</target>
        </trans-unit>
        <trans-unit id="f0360b14fd2012ea432fadffcf3782c95bbb3d96" translate="yes" xml:space="preserve">
          <source>For more details, see the &lt;code&gt;pathspec&lt;/code&gt; entry in &lt;a href=&quot;gitglossary&quot;&gt;gitglossary[7]&lt;/a&gt;.</source>
          <target state="translated">詳細については、&lt;a href=&quot;gitglossary&quot;&gt;gitglossary [7]の&lt;/a&gt; &lt;code&gt;pathspec&lt;/code&gt; エントリを参照してください。</target>
        </trans-unit>
        <trans-unit id="dee223e709585f8622ae3db9c408c2275df286e3" translate="yes" xml:space="preserve">
          <source>For more information about submodules, see &lt;a href=&quot;gitsubmodules&quot;&gt;gitsubmodules[7]&lt;/a&gt;.</source>
          <target state="translated">サブモジュールの詳細については、&lt;a href=&quot;gitsubmodules&quot;&gt;gitsubmodules [7]を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="cf4d0c9e8fd0a561af6eb800b4aa95d1953e08dc" translate="yes" xml:space="preserve">
          <source>For non-linear topology, such as</source>
          <target state="translated">のような非線形トポロジーの場合</target>
        </trans-unit>
        <trans-unit id="6869cf2d54fdd333756ee082074da9e8aa4cabf1" translate="yes" xml:space="preserve">
          <source>For now, the paranoid need to find some way to emulate the quarantine environment if they&amp;rsquo;d like the same protection as &quot;push&quot;. E.g. in the case of an internal mirror do the mirroring in two steps, one to fetch the untrusted objects, and then do a second &quot;push&quot; (which will use the quarantine) to another internal repo, and have internal clients consume this pushed-to repository, or embargo internal fetches and only allow them once a full &quot;fsck&quot; has run (and no new fetches have happened in the meantime).</source>
          <target state="translated">今のところ、偏執的な人々は、「プッシュ」と同じ保護が必要な場合に、隔離環境をエミュレートする方法を見つける必要があります。たとえば、内部ミラーリングの場合、2つのステップでミラーリングを実行します。1つは信頼できないオブジェクトをフェッチし、次に2番目の「プッシュ」（検疫を使用）を別の内部リポジトリに実行し、内部クライアントがこのプッシュを消費するようにします。リポジトリ、または内部フェッチを禁止し、完全な「fsck」が実行されたときにのみ許可します（その間、新しいフェッチは発生しません）。</target>
        </trans-unit>
        <trans-unit id="133fa5a74f060c815b7406a1ab993c4e06ad0024" translate="yes" xml:space="preserve">
          <source>For open source projects it can be a good way to get more useful contributions from end users, and to introduce them to QA and development activities.</source>
          <target state="translated">オープンソースプロジェクトでは、エンドユーザーからより多くの有用な貢献を得ることができ、QAや開発活動に導入することができます。</target>
        </trans-unit>
        <trans-unit id="dd41930f44da136ca06d3f66916ab11faa591b27" translate="yes" xml:space="preserve">
          <source>For our first example, we&amp;rsquo;re going to start a totally new repository from scratch, with no pre-existing files, and we&amp;rsquo;ll call it &lt;code&gt;git-tutorial&lt;/code&gt;. To start up, create a subdirectory for it, change into that subdirectory, and initialize the Git infrastructure with &lt;code&gt;git init&lt;/code&gt;:</source>
          <target state="translated">最初の例では、既存のファイルを使用せずに、まったく新しいリポジトリをゼロから開始します。これを &lt;code&gt;git-tutorial&lt;/code&gt; と呼びます。起動するには、そのサブディレクトリを作成し、そのサブディレクトリに移動して、Gitインフラストラクチャを &lt;code&gt;git init&lt;/code&gt; で初期化します。</target>
        </trans-unit>
        <trans-unit id="5307fd3985478faa6faac86f16463cb9c367c366" translate="yes" xml:space="preserve">
          <source>For paths with merge conflicts, &lt;code&gt;X&lt;/code&gt; and &lt;code&gt;Y&lt;/code&gt; show the modification states of each side of the merge. For paths that do not have merge conflicts, &lt;code&gt;X&lt;/code&gt; shows the status of the index, and &lt;code&gt;Y&lt;/code&gt; shows the status of the work tree. For untracked paths, &lt;code&gt;XY&lt;/code&gt; are &lt;code&gt;??&lt;/code&gt;. Other status codes can be interpreted as follows:</source>
          <target state="translated">マージの競合があるパスの場合、 &lt;code&gt;X&lt;/code&gt; と &lt;code&gt;Y&lt;/code&gt; はマージの各側の変更状態を示します。マージの競合がないパスの場合、 &lt;code&gt;X&lt;/code&gt; はインデックスのステータスを示し、 &lt;code&gt;Y&lt;/code&gt; は作業ツリーのステータスを示します。追跡されていないパスの場合、 &lt;code&gt;XY&lt;/code&gt; は &lt;code&gt;??&lt;/code&gt; 。他のステータスコードは次のように解釈できます。</target>
        </trans-unit>
        <trans-unit id="7032989b4e615b54922dcaa29834b5d11069ae03" translate="yes" xml:space="preserve">
          <source>For people who do parsing: to make it more robust, just ignore any lines between the first and last one (&quot;&amp;lt;sha1&amp;gt;&quot; and &quot;filename&quot; lines) where you do not recognize the tag words (or care about that particular one) at the beginning of the &quot;extended information&quot; lines. That way, if there is ever added information (like the commit encoding or extended commit commentary), a blame viewer will not care.</source>
          <target state="translated">解析を行う人の場合：より堅牢にするために、最初と最後の行の間の行（ &quot;&amp;lt;sha1&amp;gt;&quot;と &quot;filename&quot;の行）を無視して、タグの単語を認識しない（またはその特定の行を気にする） 「拡張情報」行の先頭。このように、情報が追加された場合（コミットエンコーディングや拡張コミットコメントなど）、非難ビューアは気にしません。</target>
        </trans-unit>
        <trans-unit id="d3a8933e3664a281a0f1007219c1a5fb906f5b9c" translate="yes" xml:space="preserve">
          <source>For performance reasons, by default, &lt;code&gt;-C&lt;/code&gt; option finds copies only if the original file of the copy was modified in the same changeset. This flag makes the command inspect unmodified files as candidates for the source of copy. This is a very expensive operation for large projects, so use it with caution. Giving more than one &lt;code&gt;-C&lt;/code&gt; option has the same effect.</source>
          <target state="translated">パフォーマンス上の理由から、デフォルトでは、 &lt;code&gt;-C&lt;/code&gt; オプションはコピーの元のファイルが同じチェンジセットで変更された場合にのみコピーを検索します。このフラグにより​​、コマンドは変更されていないファイルをコピー元の候補として検査します。これは大規模なプロジェクトでは非常にコストのかかる操作なので、注意して使用してください。複数の &lt;code&gt;-C&lt;/code&gt; オプションを指定しても同じ効果があります。</target>
        </trans-unit>
        <trans-unit id="9b9345e0345532d160619f268731569cef16617e" translate="yes" xml:space="preserve">
          <source>For plain blobs, it shows the plain contents.</source>
          <target state="translated">プレーン・ブロブの場合は、プレーン・コンテンツを表示します。</target>
        </trans-unit>
        <trans-unit id="9e1c4f262d546f1a8d01796c1dc838262d4af7ed" translate="yes" xml:space="preserve">
          <source>For precedence rules within and between exclude sources, see &lt;a href=&quot;gitignore&quot;&gt;gitignore[5]&lt;/a&gt;.</source>
          <target state="translated">除外ソース内および除外ソース間の優先ルールについては、&lt;a href=&quot;gitignore&quot;&gt;gitignore [5]を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="1e52f5f667fd4d7c4b839fc8977488698f28dddb" translate="yes" xml:space="preserve">
          <source>For projects with few developers, or for synchronizing a few private repositories, this may be all you need.</source>
          <target state="translated">開発者の少ないプロジェクトや、いくつかのプライベートリポジトリを同期させるためには、これが必要なすべてかもしれません。</target>
        </trans-unit>
        <trans-unit id="0fbf0a1225d8cd0da43e8dc6b186868e699b6219" translate="yes" xml:space="preserve">
          <source>For quickly making a snapshot, you can omit &quot;push&quot;. In this mode, non-option arguments are not allowed to prevent a misspelled subcommand from making an unwanted stash entry. The two exceptions to this are &lt;code&gt;stash -p&lt;/code&gt; which acts as alias for &lt;code&gt;stash push -p&lt;/code&gt; and pathspec elements, which are allowed after a double hyphen &lt;code&gt;--&lt;/code&gt; for disambiguation.</source>
          <target state="translated">スナップショットをすばやく作成するために、「プッシュ」を省略できます。このモードでは、オプション以外の引数を使用して、スペルミスのあるサブコマンドが不要なstashエントリを作成するのを防ぐことはできません。これには2つの例外がある &lt;code&gt;stash -p&lt;/code&gt; の別名として機能 &lt;code&gt;stash push -p&lt;/code&gt; と二重ハイフンの後に許可されていPATHSPEC要素、 &lt;code&gt;--&lt;/code&gt; 曖昧さ回避のために。</target>
        </trans-unit>
        <trans-unit id="513a986f0bbc369f77d7fc94a6a47375b99e8d89" translate="yes" xml:space="preserve">
          <source>For quickly making a snapshot, you can omit &quot;push&quot;. In this mode, non-option arguments are not allowed to prevent a misspelled subcommand from making an unwanted stash entry. The two exceptions to this are &lt;code&gt;stash -p&lt;/code&gt; which acts as alias for &lt;code&gt;stash push -p&lt;/code&gt; and pathspecs, which are allowed after a double hyphen &lt;code&gt;--&lt;/code&gt; for disambiguation.</source>
          <target state="translated">スナップショットをすばやく作成するには、「プッシュ」を省略できます。このモードでは、オプション以外の引数を使用して、スペルが間違っているサブコマンドが不要なstashエントリを作成するのを防ぐことはできません。これには2つの例外がある &lt;code&gt;stash -p&lt;/code&gt; の別名として機能 &lt;code&gt;stash push -p&lt;/code&gt; 二重ハイフンの後に許可されているとpathspecs、 &lt;code&gt;--&lt;/code&gt; 曖昧さ回避のために。</target>
        </trans-unit>
        <trans-unit id="10b29e2b2e8e16a8f0d937588e990a303d5a39cb" translate="yes" xml:space="preserve">
          <source>For reading options: read only from global &lt;code&gt;~/.gitconfig&lt;/code&gt; and from &lt;code&gt;$XDG_CONFIG_HOME/git/config&lt;/code&gt; rather than from all available files.</source>
          <target state="translated">読み取りオプションの場合：利用可能なすべてのファイルからではなく、グローバル &lt;code&gt;~/.gitconfig&lt;/code&gt; および &lt;code&gt;$XDG_CONFIG_HOME/git/config&lt;/code&gt; からのみ読み取ります。</target>
        </trans-unit>
        <trans-unit id="f670c3a49f96ee071030446b2338be3d3b61c282" translate="yes" xml:space="preserve">
          <source>For reading options: read only from system-wide &lt;code&gt;$(prefix)/etc/gitconfig&lt;/code&gt; rather than from all available files.</source>
          <target state="translated">読み取りオプションの場合：使用可能なすべてのファイルからではなく、システム全体の &lt;code&gt;$(prefix)/etc/gitconfig&lt;/code&gt; からのみ読み取ります。</target>
        </trans-unit>
        <trans-unit id="1a0b8cd1ef1778fc9e72b8ac1ede20b2c02305dd" translate="yes" xml:space="preserve">
          <source>For reading options: read only from the repository &lt;code&gt;.git/config&lt;/code&gt; rather than from all available files.</source>
          <target state="translated">読み取りオプションの場合：使用可能なすべてのファイルからではなく、リポジトリ &lt;code&gt;.git/config&lt;/code&gt; からのみ読み取ります。</target>
        </trans-unit>
        <trans-unit id="52ad1818a91b579273748ec3f745c2ea8925da11" translate="yes" xml:space="preserve">
          <source>For remote helpers that implement &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;export&lt;/code&gt;, this capability allows the refs to be constrained to a private namespace, instead of writing to refs/heads or refs/remotes directly. It is recommended that all importers providing the &lt;code&gt;import&lt;/code&gt; capability use this. It&amp;rsquo;s mandatory for &lt;code&gt;export&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;import&lt;/code&gt; または &lt;code&gt;export&lt;/code&gt; を実装するリモートヘルパーの場合、この機能により、refs / headsまたはrefs / remotesに直接書き込むのではなく、refをプライベート名前空間に制約できます。 &lt;code&gt;import&lt;/code&gt; 機能を提供するすべてのインポーターがこれを使用することをお勧めします。 &lt;code&gt;export&lt;/code&gt; 必須です。</target>
        </trans-unit>
        <trans-unit id="443450d98036603164f83ff3df4c2bf679d11741" translate="yes" xml:space="preserve">
          <source>For remotes that require curl (http, https and ftp), the URL to the proxy to use for that remote. Set to the empty string to disable proxying for that remote.</source>
          <target state="translated">curl を必要とするリモート (http、https、ftp)の場合、そのリモートで使用するプロキシの URL。空の文字列を設定すると、そのリモートのプロキシを無効にします。</target>
        </trans-unit>
        <trans-unit id="8af93420a9afb3e813edb57f9ce58a35a5de2989" translate="yes" xml:space="preserve">
          <source>For remotes that require curl (http, https and ftp), the method to use for authenticating against the proxy in use (probably set in &lt;code&gt;remote.&amp;lt;name&amp;gt;.proxy&lt;/code&gt;). See &lt;code&gt;http.proxyAuthMethod&lt;/code&gt;.</source>
          <target state="translated">curl（http、https、およびftp）を必要とする &lt;code&gt;remote.&amp;lt;name&amp;gt;.proxy&lt;/code&gt; 場合、使用中のプロキシに対する認証に使用するメソッド（おそらくremote。&amp;lt;name&amp;gt; .proxyで設定）。 &lt;code&gt;http.proxyAuthMethod&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="ff12c5f69e6a4dbe2b8b7bc739ac234198e179f4" translate="yes" xml:space="preserve">
          <source>For scripting, you can ask it to be quiet with the &quot;--quiet&quot; flag, which allows you to do things like</source>
          <target state="translated">スクリプトでは、&quot;--quiet&quot; フラグを使って静かにするように要求することができます。</target>
        </trans-unit>
        <trans-unit id="6ad68ca568ca7f00dfca41d4efe640136cb611e6" translate="yes" xml:space="preserve">
          <source>For some frontends, though, it is useful to be able to read back data from the current repository as it is being updated (for example when the source material describes objects in terms of patches to be applied to previously imported objects). This can be accomplished by connecting the frontend and fast-import via bidirectional pipes:</source>
          <target state="translated">しかし、いくつかのフロントエンドでは、現在のリポジトリが更新されているときに、現在のリポジトリからデータを読み返すことができると便利です (例えば、ソースマテリアルに、以前にインポートされたオブジェクトに適用されるパッチの観点からオブジェクトが記述されている場合など)。これは、フロントエンドと高速インポートを双方向パイプで接続することで実現できます。</target>
        </trans-unit>
        <trans-unit id="b5ea8ea5b2c1cd3e6d47c32a09c62d3c70b6ee6f" translate="yes" xml:space="preserve">
          <source>For some interesting examples of Git use, see the &lt;a href=&quot;howto-index&quot;&gt;howtos&lt;/a&gt;.</source>
          <target state="translated">Gitの興味深い使用例については、&lt;a href=&quot;howto-index&quot;&gt;howtosを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="fd917a632df420113bd1fa62c1a75d6d0838fcf8" translate="yes" xml:space="preserve">
          <source>For sorting purposes, fields with numeric values sort in numeric order (&lt;code&gt;objectsize&lt;/code&gt;, &lt;code&gt;authordate&lt;/code&gt;, &lt;code&gt;committerdate&lt;/code&gt;, &lt;code&gt;creatordate&lt;/code&gt;, &lt;code&gt;taggerdate&lt;/code&gt;). All other fields are used to sort in their byte-value order.</source>
          <target state="translated">目的、番号順（ソートで数値を持つフィールドをソートするための &lt;code&gt;objectsize&lt;/code&gt; 、 &lt;code&gt;authordate&lt;/code&gt; 、 &lt;code&gt;committerdate&lt;/code&gt; 、 &lt;code&gt;creatordate&lt;/code&gt; 、 &lt;code&gt;taggerdate&lt;/code&gt; ）。他のすべてのフィールドは、バイト値の順序でソートするために使用されます。</target>
        </trans-unit>
        <trans-unit id="032b282727ffc0c1c45df3e884598bae17ea6ac4" translate="yes" xml:space="preserve">
          <source>For specifying settings like &lt;code&gt;verbosity&lt;/code&gt; (how much output to write to stderr) and &lt;code&gt;depth&lt;/code&gt; (how much history is wanted in the case of a shallow clone) that affect how other commands are carried out.</source>
          <target state="translated">以下のような設定を指定するための &lt;code&gt;verbosity&lt;/code&gt; と（どのくらいの出力標準エラー出力への書き込みに） &lt;code&gt;depth&lt;/code&gt; 他のコマンドが実行される方法に影響を与える（浅いクローンの場合に指名手配されてどのくらいの歴史）。</target>
        </trans-unit>
        <trans-unit id="c02205be8f69628f646f89a0276ec82187cc890c" translate="yes" xml:space="preserve">
          <source>For submodules, this setting can be overridden using the &lt;code&gt;submodule.fetchJobs&lt;/code&gt; config setting.</source>
          <target state="translated">サブモジュールの場合、この設定は &lt;code&gt;submodule.fetchJobs&lt;/code&gt; 構成設定を使用してオーバーライドできます。</target>
        </trans-unit>
        <trans-unit id="c4b69b6e908fa58f8bfb0090b464d01ba7afd33a" translate="yes" xml:space="preserve">
          <source>For such a test, you need to merge master and topic somehow. One way to do it is to pull master into the topic branch:</source>
          <target state="translated">このようなテストでは、master と topic を何らかの方法でマージする必要があります。その方法の一つは、master をトピックブランチに引っ張ってくることです。</target>
        </trans-unit>
        <trans-unit id="e3a970f50f86b7e372ecc38ba0a4b965f601d385" translate="yes" xml:space="preserve">
          <source>For tags, it shows the tag message and the referenced objects.</source>
          <target state="translated">タグの場合は、タグメッセージと参照されているオブジェクトを表示します。</target>
        </trans-unit>
        <trans-unit id="e66e4764a23ddc1ac17a40208b614c40e3d1e8cd" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;squash&lt;/code&gt; and &lt;code&gt;fixup&lt;/code&gt; operation, all commits that were squashed are listed as being rewritten to the squashed commit. This means that there will be several lines sharing the same &lt;code&gt;new-sha1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;squash&lt;/code&gt; および &lt;code&gt;fixup&lt;/code&gt; 操作の場合、スカッシュされたすべてのコミットは、スカッシュされたコミットに書き直されているものとしてリストされます。これは、同じ &lt;code&gt;new-sha1&lt;/code&gt; を共有する複数の行が存在することを意味します。</target>
        </trans-unit>
        <trans-unit id="0288085d533925ac75b1f295d9e834640d8fad16" translate="yes" xml:space="preserve">
          <source>For the complete list of paths which Git checks for references, and the order it uses to decide which to choose when there are multiple references with the same shorthand name, see the &quot;SPECIFYING REVISIONS&quot; section of &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;.</source>
          <target state="translated">Gitが参照をチェックするパスの完全なリスト、および同じ省略形の参照が複数ある場合に選択を決定するためにGitが使用する順序については、&lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]&lt;/a&gt;の「リビジョンの指定」セクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="44d025151b0ff5e996c1070f067a89933eee64e1" translate="yes" xml:space="preserve">
          <source>For the initial import, &lt;code&gt;git archimport&lt;/code&gt; expects to find itself in an empty directory. To follow the development of a project that uses Arch, rerun &lt;code&gt;git archimport&lt;/code&gt; with the same parameters as the initial import to perform incremental imports.</source>
          <target state="translated">最初のインポートでは、 &lt;code&gt;git archimport&lt;/code&gt; は空のディレクトリで自分自身を見つけることを期待しています。Archを使用するプロジェクトの開発を追跡するには、最初のインポートと同じパラメーターを使用して &lt;code&gt;git archimport&lt;/code&gt; を再実行し、増分インポートを実行します。</target>
        </trans-unit>
        <trans-unit id="c91c81358174e9b87a92bafd019b5720cbf2a8d2" translate="yes" xml:space="preserve">
          <source>For the purpose of breaking a filepair, diffcore-break examines the extent of changes between the contents of the files before and after modification (i.e. the contents that have &quot;bcd1234&amp;hellip;​&quot; and &quot;0123456&amp;hellip;​&quot; as their SHA-1 content ID, in the above example). The amount of deletion of original contents and insertion of new material are added together, and if it exceeds the &quot;break score&quot;, the filepair is broken into two. The break score defaults to 50% of the size of the smaller of the original and the result (i.e. if the edit shrinks the file, the size of the result is used; if the edit lengthens the file, the size of the original is used), and can be customized by giving a number after &quot;-B&quot; option (e.g. &quot;-B75&quot; to tell it to use 75%).</source>
          <target state="translated">ファイルペアを破壊する目的で、diffcore-breakは変更前と変更後のファイルのコンテンツ間の変更の程度を調べます（つまり、SHA-1コンテンツIDとして「bcd1234&amp;hellip;」と「0123456&amp;hellip;」を含むコンテンツ） 、上記の例）。元のコンテンツの削除量と新しい素材の挿入量が加算され、「分割スコア」を超えるとファイルペアが2つに分割されます。ブレークスコアのデフォルトは、元のサイズと結果の小さい方のサイズの50％です（つまり、編集によりファイルが縮小された場合、結果のサイズが使用されます。編集によりファイルが長くなった場合、元のサイズが使用されます。 ）、「-B」オプションの後に数字を指定することでカスタマイズできます（たとえば、「-B75」で75％を使用するように指示できます）。</target>
        </trans-unit>
        <trans-unit id="62f1a958bc660b7d22544723f673271098befa81" translate="yes" xml:space="preserve">
          <source>For the purpose of merging broken filepairs back, it uses a different &quot;extent of changes&quot; computation from the ones used by diffcore-break and diffcore-rename. It counts only the deletion from the original, and does not count insertion. If you removed only 10 lines from a 100-line document, even if you added 910 new lines to make a new 1000-line document, you did not do a complete rewrite. diffcore-break breaks such a case in order to help diffcore-rename to consider such filepairs as candidate of rename/copy detection, but if filepairs broken that way were not matched with other filepairs to create rename/copy, then this transformation merges them back into the original &quot;modification&quot;.</source>
          <target state="translated">壊れたファイルペアをマージする目的で、diffcorore-break や diffcorore-rename とは異なる「変更の範囲」の計算を使用します。これは元のファイルからの削除のみをカウントし、挿入はカウントしません。100 行の文書から 10 行しか削除されていない場合、910 行を追加して 1000 行の文書を作成したとしても、完全な書き換えを行ったわけではありません。 diffcode-break は、diffcode-rename がそのようなファイルペアをリネーム/コピー検出の候補とみなすのを助けるために、このようなケースをブレークしますが、そのようにブレークしたファイルペアが他のファイルペアとマッチしてリネーム/コピーが作成されなかった場合、この変換はそれらを元の「変更」に戻します。</target>
        </trans-unit>
        <trans-unit id="6ab2225889ebaecccd59bff89db6e9b9331d68f2" translate="yes" xml:space="preserve">
          <source>For the sake of clarity, let&amp;rsquo;s stay with &lt;code&gt;git cat-file&lt;/code&gt;, because it</source>
          <target state="translated">明確化のために、とのご滞在を聞かせて &lt;code&gt;git cat-file&lt;/code&gt; 、それ理由</target>
        </trans-unit>
        <trans-unit id="3256aa918e5b4c1710b691c8cd23b5d5181ec72c" translate="yes" xml:space="preserve">
          <source>For the sake of simplicity and interoperating with Subversion, it is recommended that all &lt;code&gt;git svn&lt;/code&gt; users clone, fetch and dcommit directly from the SVN server, and avoid all &lt;code&gt;git clone&lt;/code&gt;/&lt;code&gt;pull&lt;/code&gt;/&lt;code&gt;merge&lt;/code&gt;/&lt;code&gt;push&lt;/code&gt; operations between Git repositories and branches. The recommended method of exchanging code between Git branches and users is &lt;code&gt;git format-patch&lt;/code&gt; and &lt;code&gt;git am&lt;/code&gt;, or just 'dcommit&amp;rsquo;ing to the SVN repository.</source>
          <target state="translated">単純化とSubversionとの相互運用のために、すべての &lt;code&gt;git svn&lt;/code&gt; ユーザーがSVNサーバーから直接複製、フェッチ、dcommitし、Gitリポジトリとブランチ間のすべての &lt;code&gt;git clone&lt;/code&gt; / &lt;code&gt;pull&lt;/code&gt; / &lt;code&gt;merge&lt;/code&gt; / &lt;code&gt;push&lt;/code&gt; 操作を回避することをお勧めします。Gitブランチとユーザー間でコードを交換するための推奨される方法は、 &lt;code&gt;git format-patch&lt;/code&gt; と &lt;code&gt;git am&lt;/code&gt; 、またはSVNリポジトリへの「dcommit」です。</target>
        </trans-unit>
        <trans-unit id="2279b6e7f152e69847961316b26521ce7eeaaca8" translate="yes" xml:space="preserve">
          <source>For these commands, specifying a single revision, using the notation described in the previous section, means the set of commits &lt;code&gt;reachable&lt;/code&gt; from the given commit.</source>
          <target state="translated">これらのコマンドの場合、前のセクションで説明した表記を使用して単一のリビジョンを指定することは、特定のコミットから &lt;code&gt;reachable&lt;/code&gt; コミットのセットを意味します。</target>
        </trans-unit>
        <trans-unit id="bd23aa2eb5a5735171ddacb742b9284ac1e13d5d" translate="yes" xml:space="preserve">
          <source>For this example, suppose &lt;code&gt;I&lt;/code&gt; created &lt;code&gt;file.txt&lt;/code&gt; which was modified by &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, and &lt;code&gt;X&lt;/code&gt; in different ways. The single-parent commits &lt;code&gt;C&lt;/code&gt;, &lt;code&gt;Z&lt;/code&gt;, and &lt;code&gt;Y&lt;/code&gt; do not change &lt;code&gt;file.txt&lt;/code&gt;. The merge commit &lt;code&gt;M&lt;/code&gt; was created by resolving the merge conflict to include both changes from &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; and hence is not TREESAME to either. The merge commit &lt;code&gt;R&lt;/code&gt;, however, was created by ignoring the contents of &lt;code&gt;file.txt&lt;/code&gt; at &lt;code&gt;M&lt;/code&gt; and taking only the contents of &lt;code&gt;file.txt&lt;/code&gt; at &lt;code&gt;X&lt;/code&gt;. Hence, &lt;code&gt;R&lt;/code&gt; is TREESAME to &lt;code&gt;X&lt;/code&gt; but not &lt;code&gt;M&lt;/code&gt;. Finally, the natural merge resolution to create &lt;code&gt;N&lt;/code&gt; is to take the contents of &lt;code&gt;file.txt&lt;/code&gt; at &lt;code&gt;R&lt;/code&gt;, so &lt;code&gt;N&lt;/code&gt; is TREESAME to &lt;code&gt;R&lt;/code&gt; but not &lt;code&gt;C&lt;/code&gt;. The merge commits &lt;code&gt;O&lt;/code&gt; and &lt;code&gt;P&lt;/code&gt; are TREESAME to their first parents, but not to their second parents, &lt;code&gt;Z&lt;/code&gt; and &lt;code&gt;Y&lt;/code&gt; respectively.</source>
          <target state="translated">この例では、 &lt;code&gt;A&lt;/code&gt; 、 &lt;code&gt;B&lt;/code&gt; 、および &lt;code&gt;X&lt;/code&gt; によってさまざまな方法で変更された &lt;code&gt;file.txt&lt;/code&gt; &lt;code&gt;I&lt;/code&gt; 作成したとします。ひとり親のコミット &lt;code&gt;C&lt;/code&gt; 、 &lt;code&gt;Z&lt;/code&gt; 、および &lt;code&gt;Y&lt;/code&gt; は &lt;code&gt;file.txt&lt;/code&gt; を変更しません。マージコミット &lt;code&gt;M&lt;/code&gt; は、マージの競合を解決して &lt;code&gt;A&lt;/code&gt; と &lt;code&gt;B&lt;/code&gt; の両方の変更を含めることによって作成されたため、どちらにもTREESAMEではありません。マージコミット &lt;code&gt;R&lt;/code&gt; を、しかし、内容無視することによって作成された &lt;code&gt;file.txt&lt;/code&gt; などをで &lt;code&gt;M&lt;/code&gt; との内容だけ取っ &lt;code&gt;file.txt&lt;/code&gt; などをで &lt;code&gt;X&lt;/code&gt; 。したがって、 &lt;code&gt;R&lt;/code&gt; は &lt;code&gt;X&lt;/code&gt; に対してTREESAMEですが、 &lt;code&gt;M&lt;/code&gt; ではありません。最後に、作成する自然のマージ解像度 &lt;code&gt;N&lt;/code&gt; は、内容取ることである &lt;code&gt;file.txt&lt;/code&gt; などをで &lt;code&gt;R&lt;/code&gt; ので、 &lt;code&gt;N&lt;/code&gt; はにTREESAMEで &lt;code&gt;R&lt;/code&gt; はなく、 &lt;code&gt;C&lt;/code&gt; 。マージコミット &lt;code&gt;O&lt;/code&gt; と &lt;code&gt;P&lt;/code&gt; は、最初の親に対してはTREESAMEですが、2番目の親である &lt;code&gt;Z&lt;/code&gt; と &lt;code&gt;Y&lt;/code&gt; に対してはそれぞれTREESAMEではありません。</target>
        </trans-unit>
        <trans-unit id="74da4e1940c3e7e40b0478bfdb6a84a981ccd45c" translate="yes" xml:space="preserve">
          <source>For this reason it is strongly recommended that users repack the repository with &lt;code&gt;git repack -a -d&lt;/code&gt; after fast-import completes, allowing Git to reorganize the packfiles for faster data access. If blob deltas are suboptimal (see above) then also adding the &lt;code&gt;-f&lt;/code&gt; option to force recomputation of all deltas can significantly reduce the final packfile size (30-50% smaller can be quite typical).</source>
          <target state="translated">このため、高速インポートの完了後に &lt;code&gt;git repack -a -d&lt;/code&gt; を使用してリポジトリを再パックし、Gitがパックファイルを再編成してデータアクセスを高速化することを強くお勧めします。blobデルタが最適ではない場合（上記を参照）、- &lt;code&gt;-f&lt;/code&gt; オプションを追加してすべてのデルタの再計算を強制すると、最終的なパックファイルサイズを大幅に削減できます（30〜50％小さいのはかなり一般的です）。</target>
        </trans-unit>
        <trans-unit id="0c101be68a53a28136d34207f208a2b09cd96fd2" translate="yes" xml:space="preserve">
          <source>For transports that SVN handles authentication for (http, https, and plain svn), specify the username. For other transports (e.g. &lt;code&gt;svn+ssh://&lt;/code&gt;), you must include the username in the URL, e.g. &lt;code&gt;svn+ssh://foo@svn.bar.com/project&lt;/code&gt;</source>
          <target state="translated">SVNが認証を処理するトランスポート（http、https、およびプレーンsvn）の場合は、ユーザー名を指定します。他のトランスポート（例： &lt;code&gt;svn+ssh://&lt;/code&gt; ）の場合、URLにユーザー名を含める必要があります。例： &lt;code&gt;svn+ssh://foo@svn.bar.com/project&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="884bf4d941685ae2ac82a222d5a5cd34350cf6bb" translate="yes" xml:space="preserve">
          <source>For trees, it shows the names (equivalent to &lt;code&gt;git ls-tree&lt;/code&gt; with --name-only).</source>
          <target state="translated">ツリーの場合、名前が表示されます（--name-onlyを指定した &lt;code&gt;git ls-tree&lt;/code&gt; と同等）。</target>
        </trans-unit>
        <trans-unit id="add825378fcd5c043a391a94c20d1353e2f3f4d7" translate="yes" xml:space="preserve">
          <source>For true distributed development that supports proper merging, published branches should never be rewritten.</source>
          <target state="translated">適切なマージをサポートする真の分散開発のためには、公開されているブランチは決して書き換えてはいけません。</target>
        </trans-unit>
        <trans-unit id="3d68fc99046b8e48302665b1b866f7694067fd6a" translate="yes" xml:space="preserve">
          <source>For use with --textconv or --filters, to allow specifying an object name and a path separately, e.g. when it is difficult to figure out the revision from which the blob came.</source>
          <target state="translated">textconv や --filters と一緒に使うと、オブジェクト名とパスを別々に指定できるようになります。</target>
        </trans-unit>
        <trans-unit id="e72ffb4fac055436e16518cc2f4fb21127e4cb40" translate="yes" xml:space="preserve">
          <source>For writing options: write to global &lt;code&gt;~/.gitconfig&lt;/code&gt; file rather than the repository &lt;code&gt;.git/config&lt;/code&gt;, write to &lt;code&gt;$XDG_CONFIG_HOME/git/config&lt;/code&gt; file if this file exists and the &lt;code&gt;~/.gitconfig&lt;/code&gt; file doesn&amp;rsquo;t.</source>
          <target state="translated">書き込みオプションの場合：リポジトリ &lt;code&gt;.git/config&lt;/code&gt; ではなくグローバル &lt;code&gt;~/.gitconfig&lt;/code&gt; ファイルに書き込みます。このファイルが存在し、 &lt;code&gt;~/.gitconfig&lt;/code&gt; ファイルが存在しない場合は、 &lt;code&gt;$XDG_CONFIG_HOME/git/config&lt;/code&gt; ファイルに書き込みます。</target>
        </trans-unit>
        <trans-unit id="1d4f90bdceeed64344a78d1a30eb973c4a695eed" translate="yes" xml:space="preserve">
          <source>For writing options: write to system-wide &lt;code&gt;$(prefix)/etc/gitconfig&lt;/code&gt; rather than the repository &lt;code&gt;.git/config&lt;/code&gt;.</source>
          <target state="translated">書き込みオプションの場合：リポジトリ &lt;code&gt;.git/config&lt;/code&gt; ではなく、システム全体の &lt;code&gt;$(prefix)/etc/gitconfig&lt;/code&gt; に書き込みます。</target>
        </trans-unit>
        <trans-unit id="ab6a40ba6d951665186720914cfcdda1831523bb" translate="yes" xml:space="preserve">
          <source>For writing options: write to the repository &lt;code&gt;.git/config&lt;/code&gt; file. This is the default behavior.</source>
          <target state="translated">書き込みオプションの場合：リポジトリの &lt;code&gt;.git/config&lt;/code&gt; ファイルに書き込みます。これがデフォルトの動作です。</target>
        </trans-unit>
        <trans-unit id="1b61f0964f0c12ab159b1b9cbdaad36acf5d4cd8" translate="yes" xml:space="preserve">
          <source>Force &lt;code&gt;git gc&lt;/code&gt; to run even if there may be another &lt;code&gt;git gc&lt;/code&gt; instance running on this repository.</source>
          <target state="translated">このリポジトリで別の &lt;code&gt;git gc&lt;/code&gt; インスタンスが実行されている場合でも、強制的に &lt;code&gt;git gc&lt;/code&gt; を実行します。</target>
        </trans-unit>
        <trans-unit id="2041f78f7b4213165ad0484df1b0863ad820d047" translate="yes" xml:space="preserve">
          <source>Force renaming or moving of a file even if the target exists</source>
          <target state="translated">ターゲットが存在する場合でも、ファイルの名前変更や移動を強制的に行う</target>
        </trans-unit>
        <trans-unit id="ecd78b0e67ad331a13ae4cb8f4e6a9ed04fc189e" translate="yes" xml:space="preserve">
          <source>Force the cloning process from a repository on a local filesystem to copy the files under the &lt;code&gt;.git/objects&lt;/code&gt; directory instead of using hardlinks. This may be desirable if you are trying to make a back-up of your repository.</source>
          <target state="translated">ローカルファイルシステムのリポジトリからのクローン作成プロセスで、ハードリンクを使用する代わりに &lt;code&gt;.git/objects&lt;/code&gt; ディレクトリの下にファイルをコピーするように強制します。リポジトリのバックアップを作成する場合は、これが望ましい場合があります。</target>
        </trans-unit>
        <trans-unit id="5aad6db9c36a2f2837e6ea58135f2a7c135ffcc5" translate="yes" xml:space="preserve">
          <source>Force the merge even if the files are not up to date.</source>
          <target state="translated">ファイルが最新でなくても強制的にマージします。</target>
        </trans-unit>
        <trans-unit id="b35554b966d1f9e773a7eeb185af7c152ef043be" translate="yes" xml:space="preserve">
          <source>Force the parent commit, even if it is not a direct parent.</source>
          <target state="translated">直接の親ではない場合でも、強制的に親コミットを行います。</target>
        </trans-unit>
        <trans-unit id="8fd0762700f6c31dd37961618e48e9600a28f63f" translate="yes" xml:space="preserve">
          <source>Force updating modified existing branches, even if doing so would cause commits to be lost (as the new commit does not contain the old commit).</source>
          <target state="translated">(新しいコミットには古いコミットが含まれていないため)コミットが失われてしまう可能性があるとしても、変更された既存のブランチを強制的に更新します。</target>
        </trans-unit>
        <trans-unit id="3c16110b137eeeb074b6bb1a45d5cee67e8b8d7d" translate="yes" xml:space="preserve">
          <source>Forces fast-import to close the current packfile, generate its unique SHA-1 checksum and index, and start a new packfile. This command is optional and is not needed to perform an import.</source>
          <target state="translated">fast-import を強制的に実行して現在のパックファイルを閉じ、そのユニークな SHA-1 チェックサムとインデックスを生成し、新しいパックファイルを開始します。このコマンドはオプションであり、インポートを実行するためには必要ありません。</target>
        </trans-unit>
        <trans-unit id="1a687c2c8da515bb3889e24f9c0c80b813b24084" translate="yes" xml:space="preserve">
          <source>Forces fast-import to close the current packfile, start a new one, and to save out all current branch refs, tags and marks.</source>
          <target state="translated">強制的に fast-import を実行して現在のパックファイルを閉じ、新しいパックファイルを起動し、現在のブランチの参照、タグ、マークをすべて保存します。</target>
        </trans-unit>
        <trans-unit id="434a9daac438458d6a5542866bf4627ab056ebc0" translate="yes" xml:space="preserve">
          <source>Forcing git fetch to do non-fast-forward updates</source>
          <target state="translated">git fetch で非 fast-forward 更新を行うようにする</target>
        </trans-unit>
        <trans-unit id="07c2be944c0e6602c04932a6e3d9ec7d07d27d65" translate="yes" xml:space="preserve">
          <source>Forget about the current merge in progress. Leave the index and the working tree as-is.</source>
          <target state="translated">現在進行中のマージのことは忘れてください。インデックスと作業ツリーはそのままにしておきます。</target>
        </trans-unit>
        <trans-unit id="b7fac01fb2068412feecd8f7081be42b5f011f68" translate="yes" xml:space="preserve">
          <source>Forget about the current merge in progress. Leave the index and the working tree as-is. If &lt;code&gt;MERGE_AUTOSTASH&lt;/code&gt; is present, the stash entry will be saved to the stash list.</source>
          <target state="translated">進行中の現在のマージを忘れてください。インデックスと作業ツリーはそのままにしておきます。場合 &lt;code&gt;MERGE_AUTOSTASH&lt;/code&gt; が存在している、隠しエントリはスタッシュリストに保存されます。</target>
        </trans-unit>
        <trans-unit id="81bdf759eac78632844fbde02bcf81c1762add7d" translate="yes" xml:space="preserve">
          <source>Forget about the current operation in progress. Can be used to clear the sequencer state after a failed cherry-pick or revert.</source>
          <target state="translated">現在進行中の操作を忘れる。チェリーピックやリバートに失敗した後にシーケンサの状態をクリアするために使用できます。</target>
        </trans-unit>
        <trans-unit id="bc2093ee15e651049bc58aa54bb94be570859e07" translate="yes" xml:space="preserve">
          <source>Format data by columns:</source>
          <target state="translated">データを列でフォーマットします。</target>
        </trans-unit>
        <trans-unit id="74cf0d3233deb63a1885a09b7a59d2c4cacb7451" translate="yes" xml:space="preserve">
          <source>Format data by rows:</source>
          <target state="translated">データを行単位でフォーマットします。</target>
        </trans-unit>
        <trans-unit id="1490d94054ac9f1a7565287cb4c10caa7d0a3ff1" translate="yes" xml:space="preserve">
          <source>Format of the file(s) specified in sendemail.aliasesFile. Must be one of &lt;code&gt;mutt&lt;/code&gt;, &lt;code&gt;mailrc&lt;/code&gt;, &lt;code&gt;pine&lt;/code&gt;, &lt;code&gt;elm&lt;/code&gt;, or &lt;code&gt;gnus&lt;/code&gt;, or &lt;code&gt;sendmail&lt;/code&gt;.</source>
          <target state="translated">sendemail.aliasesFileで指定されたファイルの形式。いずれかでなければなりません &lt;code&gt;mutt&lt;/code&gt; の、 &lt;code&gt;mailrc&lt;/code&gt; 、 &lt;code&gt;pine&lt;/code&gt; 、 &lt;code&gt;elm&lt;/code&gt; 、または &lt;code&gt;gnus&lt;/code&gt; 、または &lt;code&gt;sendmail&lt;/code&gt; の。</target>
        </trans-unit>
        <trans-unit id="85b75659b13a3c18419a2059ae24d18f7aec62d9" translate="yes" xml:space="preserve">
          <source>Format of the resulting archive: &lt;code&gt;tar&lt;/code&gt; or &lt;code&gt;zip&lt;/code&gt;. If this option is not given, and the output file is specified, the format is inferred from the filename if possible (e.g. writing to &quot;foo.zip&quot; makes the output to be in the zip format). Otherwise the output format is &lt;code&gt;tar&lt;/code&gt;.</source>
          <target state="translated">結果のアーカイブの形式： &lt;code&gt;tar&lt;/code&gt; または &lt;code&gt;zip&lt;/code&gt; 。このオプションが指定されておらず、出力ファイルが指定されている場合、形式は可能であればファイル名から推測されます（たとえば、「foo.zip」に書き込むと、出力はzip形式になります）。それ以外の場合、出力形式は &lt;code&gt;tar&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="2804d9f16a38553f8238529c90d66e7d7426c150" translate="yes" xml:space="preserve">
          <source>Formats</source>
          <target state="translated">Formats</target>
        </trans-unit>
        <trans-unit id="4bec9575721b2739ed1e7c56eb6c8471084fcbcf" translate="yes" xml:space="preserve">
          <source>Forms</source>
          <target state="translated">Forms</target>
        </trans-unit>
        <trans-unit id="97808e16f7b3e0748cf911affe6a2e5f5336bd69" translate="yes" xml:space="preserve">
          <source>Fortunately, Git also keeps a log, called a &quot;reflog&quot;, of all the previous values of each branch. So in this case you can still find the old history using, for example,</source>
          <target state="translated">幸いなことに、Git は &quot;reflog&quot; と呼ばれる、各ブランチの以前のすべての値のログも保持しています。ですから、この場合でも、例えば以下のようにして古い履歴を見つけることができます。</target>
        </trans-unit>
        <trans-unit id="52aedb174e481572a146a6eee6e65f3145e19419" translate="yes" xml:space="preserve">
          <source>Fortunately, when you try and merge branches imported from Arch, Git will find a good merge base, and it has a good chance of identifying patches that have been traded out-of-sequence between the branches.</source>
          <target state="translated">幸いなことに、Arch からインポートしたブランチをマージしようとすると、Git は良いマージベースを見つけてくれるので、ブランチ間で順番がずれて取引されたパッチを特定することができます。</target>
        </trans-unit>
        <trans-unit id="f243a4b31e069ad1af1905a7b7ee3c0a6bc4a9d9" translate="yes" xml:space="preserve">
          <source>Freely Skip Around Branches</source>
          <target state="translated">枝を自由にスキップ</target>
        </trans-unit>
        <trans-unit id="4f5fb89546fa56451bf07260d4420bcc62940bb0" translate="yes" xml:space="preserve">
          <source>Frequently Asked Questions (FAQ)</source>
          <target state="translated">よくある質問(FAQ</target>
        </trans-unit>
        <trans-unit id="6954599bb4bd53fc74592c122080450ce5ed81db" translate="yes" xml:space="preserve">
          <source>Frequently asked questions about using Git</source>
          <target state="translated">Gitの使用に関するよくある質問</target>
        </trans-unit>
        <trans-unit id="bc2451038a48527dcbeab53ccfe9fbac5f2cad0f" translate="yes" xml:space="preserve">
          <source>From a clean working directory:</source>
          <target state="translated">きれいな作業ディレクトリから</target>
        </trans-unit>
        <trans-unit id="e5d597f5b08d8d486fa4fe348997e77a44c54af8" translate="yes" xml:space="preserve">
          <source>From a remote repository:</source>
          <target state="translated">リモートリポジトリから</target>
        </trans-unit>
        <trans-unit id="288bfe5db4a5e76e3e6479e8536caa4995b7e02e" translate="yes" xml:space="preserve">
          <source>From a tarball:</source>
          <target state="translated">タールボールから。</target>
        </trans-unit>
        <trans-unit id="734c2e78c0e94a1be8f8ce3bed6beeb7e74b3905" translate="yes" xml:space="preserve">
          <source>From the Git 1.5.4 series and further, many Git commands (not all of them at the time of the writing though) come with an enhanced option parser.</source>
          <target state="translated">Git 1.5.4 シリーズ以降、多くの Git コマンド (執筆時点ではすべてではありませんが)にオプションパーサーが追加されました。</target>
        </trans-unit>
        <trans-unit id="a7a0e1c60991430a8700058d7dbaaa429f71c02b" translate="yes" xml:space="preserve">
          <source>From this point, the result of either of the following commands:</source>
          <target state="translated">この時点から、以下のいずれかのコマンドの結果になります。</target>
        </trans-unit>
        <trans-unit id="3e41340cee5d477151048da29744ee1316a7f6cb" translate="yes" xml:space="preserve">
          <source>Frontends may choose to issue checkpoints during extremely large and long running imports, or when they need to allow another Git process access to a branch. However given that a 30 GiB Subversion repository can be loaded into Git through fast-import in about 3 hours, explicit checkpointing may not be necessary.</source>
          <target state="translated">フロントエンドは、非常に大規模で長時間のインポートの際にチェックポイントを発行したり、別の Git プロセスがブランチにアクセスできるようにする必要がある場合にチェックポイントを発行したりすることがあります。しかし、30GiB の Subversion リポジトリを高速インポートで約 3 時間で Git にロードできることを考えると、明示的なチェックポイントは必要ないかもしれません。</target>
        </trans-unit>
        <trans-unit id="45f585d5b13263a74e89d30321fceb20439bc1e7" translate="yes" xml:space="preserve">
          <source>Frontends should prefer the &lt;code&gt;raw&lt;/code&gt; format if the source material already uses UNIX-epoch format, can be coaxed to give dates in that format, or its format is easily convertible to it, as there is no ambiguity in parsing.</source>
          <target state="translated">ソース素材がすでにUNIXエポック形式を使用している場合、フロントエンドは &lt;code&gt;raw&lt;/code&gt; 形式を優先する必要があります。その形式で日付を与えるように調整できる場合、または解析に曖昧さがないため、その形式は簡単に変換できます。</target>
        </trans-unit>
        <trans-unit id="f3cc2873d5f4e3e8be387b77133d15ba005de66f" translate="yes" xml:space="preserve">
          <source>Frontends which have efficient access to all revisions of a single file (for example reading an RCS/CVS ,v file) can choose to supply all revisions of that file as a sequence of consecutive &lt;code&gt;blob&lt;/code&gt; commands. This allows fast-import to deltify the different file revisions against each other, saving space in the final packfile. Marks can be used to later identify individual file revisions during a sequence of &lt;code&gt;commit&lt;/code&gt; commands.</source>
          <target state="translated">単一のファイルのすべてのリビジョンに効率的にアクセスできるフロントエンド（たとえば、RCS / CVS、vファイルの読み取り）は、そのファイルのすべてのリビジョンを一連の連続した &lt;code&gt;blob&lt;/code&gt; コマンドとして提供することを選択できます。これにより、高速インポートで異なるファイルリビジョンを相互に区別して、最終的なパックファイルのスペースを節約できます。マークは、一連の &lt;code&gt;commit&lt;/code&gt; コマンドの実行中に、後で個々のファイルリビジョンを識別するために使用できます。</target>
        </trans-unit>
        <trans-unit id="3519d227e718b16c5b769aae01680cf2cd77dc46" translate="yes" xml:space="preserve">
          <source>Full URL and absolute URL of the gitweb script; in earlier versions of gitweb you might have need to set those variables, but now there should be no need to do it. See &lt;code&gt;$per_request_config&lt;/code&gt; if you need to set them still.</source>
          <target state="translated">gitwebスクリプトの完全なURLと絶対URL。以前のバージョンのgitwebでは、これらの変数を設定する必要があったかもしれませんが、現在は設定する必要はありません。まだ設定する必要がある場合は、 &lt;code&gt;$per_request_config&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="a108e2708a06a554ba0c3dc09504268225bd27f7" translate="yes" xml:space="preserve">
          <source>Full pattern set</source>
          <target state="translated">フルパターンセット</target>
        </trans-unit>
        <trans-unit id="b8fec8cb8e4460222f34da65fd7e0d2a0f5118ab" translate="yes" xml:space="preserve">
          <source>Function used to determine which repositories should be shown. This subroutine should take one parameter, the full path to a project, and if it returns true, that project will be included in the projects list and can be accessed through gitweb as long as it fulfills the other requirements described by $export_ok, $projects_list, and $projects_maxdepth. Example:</source>
          <target state="translated">どのリポジトリを表示するかを決めるための関数です。このサブルーチンのパラメータはひとつで、プロジェクトへのフルパスを指定します。これが true を返すと、そのプロジェクトはプロジェクト一覧に含まれ、gitweb からアクセスできるようになります。例を示します。</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="953f869510869f147aa66935f6f2e4c1b01346f2" translate="yes" xml:space="preserve">
          <source>Fundamental data structures and utilities of Git. Exposes only limited source code management tools.</source>
          <target state="translated">Gitの基本的なデータ構造とユーティリティ。限られたソースコード管理ツールのみを公開しています。</target>
        </trans-unit>
        <trans-unit id="2a68bfcdf45f0d6508d348a650a90dad4898fc87" translate="yes" xml:space="preserve">
          <source>Further chapters cover more specialized topics.</source>
          <target state="translated">さらなる章では、より専門的なトピックを取り上げています。</target>
        </trans-unit>
        <trans-unit id="bc4614e5e44f10e9735555c384229ac13d88fcbe" translate="yes" xml:space="preserve">
          <source>Further documentation</source>
          <target state="translated">その他のドキュメント</target>
        </trans-unit>
        <trans-unit id="1a67b11bbb73911c0ea7f808bf383dac0f90b1d2" translate="yes" xml:space="preserve">
          <source>Further suppose that the other person already pushed changes leading to A back to the original repository from which you two obtained the original commit X.</source>
          <target state="translated">さらに、もう一人の人がすでに A につながる変更を元のリポジトリに押し戻していたとします。</target>
        </trans-unit>
        <trans-unit id="11dea5e071893c59426ef6a8d5f500708e7c087c" translate="yes" xml:space="preserve">
          <source>Further, remember how I said that &lt;code&gt;git write-tree&lt;/code&gt; writes the contents of the &lt;strong&gt;index&lt;/strong&gt; file to the tree, and thus what we just committed was in fact the &lt;strong&gt;original&lt;/strong&gt; contents of the file &lt;code&gt;hello&lt;/code&gt;, not the new ones. We did that on purpose, to show the difference between the index state, and the state in the working tree, and how they don&amp;rsquo;t have to match, even when we commit things.</source>
          <target state="translated">さらに、 &lt;code&gt;git write-tree&lt;/code&gt; が&lt;strong&gt;インデックス&lt;/strong&gt;ファイルのコンテンツをツリーに書き込むと言ったので、コミットしたのは実際には新しいコンテンツではなく、&lt;strong&gt;元&lt;/strong&gt;のファイル &lt;code&gt;hello&lt;/code&gt; のコンテンツでした。これは、インデックスの状態と作業ツリーの状態の違い、およびコミットする場合でも一致する必要がない方法を示すために意図的に行いました。</target>
        </trans-unit>
        <trans-unit id="12a1c3eb3c3466df160e63355f0a70980e5d8a54" translate="yes" xml:space="preserve">
          <source>Further, several additional files are created or updated per commit by git-filter-branch. Some of these are for supporting the convenience functions provided by git-filter-branch (such as map()), while others are for keeping track of internal state (but could have also been accessed by user filters; one of git-filter-branch&amp;rsquo;s regression tests does so). This essentially amounts to using the filesystem as an IPC mechanism between git-filter-branch and the user-provided filters. Disks tend to be a slow IPC mechanism, and writing these files also effectively represents a forced synchronization point between separate processes that we hit with every commit.</source>
          <target state="translated">さらに、git-filter-branchにより、コミットごとにいくつかの追加ファイルが作成または更新されます。これらの一部はgit-filter-branchによって提供される便利な関数（map（）など）をサポートするためのものであり、その他は内部状態を追跡するためのものです（ただしユーザーフィルターからアクセスすることもできます; git-filter-の1つ）ブランチの回帰テストはそうします）。これは基本的に、ファイルシステムをgit-filter-branchとユーザー指定のフィルター間のIPCメカニズムとして使用することになります。ディスクは遅いIPCメカニズムである傾向があり、これらのファイルの書き込みは、コミットごとにヒットする個別のプロセス間の強制同期ポイントを効果的に表します。</target>
        </trans-unit>
        <trans-unit id="48717135930571b8087beeed13bb405458558d68" translate="yes" xml:space="preserve">
          <source>Further, the above facts mean that there are multiple reasons that &quot;tracked&quot; files might not be present in the working copy: sparsity pattern application from sparse-checkout, and submodule initialization state. Thus, commands like &lt;code&gt;git grep&lt;/code&gt; that work on tracked files in the working copy may return results that are limited by either or both of these restrictions.</source>
          <target state="translated">さらに、上記の事実は、「追跡された」ファイルが作業コピーに存在しない可能性がある複数の理由があることを意味します。スパースチェックアウトからのスパースパターンアプリケーション、およびサブモジュールの初期化状態です。したがって、作業コピー内の追跡されたファイルで機能する &lt;code&gt;git grep&lt;/code&gt; のようなコマンドは、これらの制限のいずれかまたは両方によって制限される結果を返す場合があります。</target>
        </trans-unit>
        <trans-unit id="7ca2383accb8da62a165b73e8556d1713934adf2" translate="yes" xml:space="preserve">
          <source>Furthermore, &lt;code&gt;git read-tree&lt;/code&gt; has special-case logic that says: if you see a file that matches in all respects in the following states, it &quot;collapses&quot; back to &quot;stage0&quot;:</source>
          <target state="translated">さらに、 &lt;code&gt;git read-tree&lt;/code&gt; には次のような特別なケースのロジックがあります。次の状態ですべての点で一致するファイルが表示されると、「折りたたまれて」「stage0」に戻ります。</target>
        </trans-unit>
        <trans-unit id="31a08e0ad75da0260fa91bb8e152e897858a7305" translate="yes" xml:space="preserve">
          <source>Furthermore, passwords need not be specified in configuration files or on the command line. If a username has been specified (with &lt;code&gt;--smtp-user&lt;/code&gt; or a &lt;code&gt;sendemail.smtpUser&lt;/code&gt;), but no password has been specified (with &lt;code&gt;--smtp-pass&lt;/code&gt; or &lt;code&gt;sendemail.smtpPass&lt;/code&gt;), then a password is obtained using &lt;code&gt;git-credential&lt;/code&gt;.</source>
          <target state="translated">さらに、構成ファイルやコマンドラインでパスワードを指定する必要はありません。ユーザー名が指定されている（ &lt;code&gt;--smtp-user&lt;/code&gt; または &lt;code&gt;sendemail.smtpUser&lt;/code&gt; ）が、パスワードが指定されていない（ &lt;code&gt;--smtp-pass&lt;/code&gt; または &lt;code&gt;sendemail.smtpPass&lt;/code&gt; ）場合、パスワードは &lt;code&gt;git-credential&lt;/code&gt; を使用して取得されます。</target>
        </trans-unit>
        <trans-unit id="eebdda6fedb5243cc4950de3133a043a2ebece61" translate="yes" xml:space="preserve">
          <source>Furthermore, supplying &lt;code&gt;--aggressive&lt;/code&gt; will tweak the &lt;code&gt;--depth&lt;/code&gt; and &lt;code&gt;--window&lt;/code&gt; options passed to &lt;a href=&quot;git-repack&quot;&gt;git-repack[1]&lt;/a&gt;. See the &lt;code&gt;gc.aggressiveDepth&lt;/code&gt; and &lt;code&gt;gc.aggressiveWindow&lt;/code&gt; settings below. By using a larger window size we&amp;rsquo;re more likely to find more optimal deltas.</source>
          <target state="translated">また、供給 &lt;code&gt;--aggressive&lt;/code&gt; は微調整されます &lt;code&gt;--depth&lt;/code&gt; と &lt;code&gt;--window&lt;/code&gt; に渡されるオプション&lt;a href=&quot;git-repack&quot;&gt;のgit-再パック[1] &lt;/a&gt;。以下の &lt;code&gt;gc.aggressiveDepth&lt;/code&gt; と &lt;code&gt;gc.aggressiveWindow&lt;/code&gt; の設定をご覧ください。より大きなウィンドウサイズを使用することで、より最適なデルタを見つける可能性が高くなります。</target>
        </trans-unit>
        <trans-unit id="c04d9fd3f33708a82d676293fc52e5a70fbf49e1" translate="yes" xml:space="preserve">
          <source>Future work</source>
          <target state="translated">今後の仕事</target>
        </trans-unit>
        <trans-unit id="7fa52712e6497fe42aeefb82c610da75e312ec0f" translate="yes" xml:space="preserve">
          <source>GITWEB_CONFIG</source>
          <target state="translated">GITWEB_CONFIG</target>
        </trans-unit>
        <trans-unit id="9636fb1dbafa2b47af9b2233bf38584401d20651" translate="yes" xml:space="preserve">
          <source>GITWEB_CONFIG_COMMON</source>
          <target state="translated">GITWEB_CONFIG_COMMON</target>
        </trans-unit>
        <trans-unit id="f726c6360c3b65b3b136cb8ed08c06cd6bb3dc13" translate="yes" xml:space="preserve">
          <source>GITWEB_CONFIG_SYSTEM</source>
          <target state="translated">GITWEB_CONFIG_SYSTEM</target>
        </trans-unit>
        <trans-unit id="7280da4640f08695fca3fbf79b196a715d6c95d5" translate="yes" xml:space="preserve">
          <source>GIT_ALTERNATE_OBJECT_DIRECTORIES</source>
          <target state="translated">GIT_ALTERNATE_OBJECT_DIRECTORIES</target>
        </trans-unit>
        <trans-unit id="964a2aa0953b5ffb1cfcd8b66bb3d22332570f05" translate="yes" xml:space="preserve">
          <source>GIT_AUTHOR_IDENT</source>
          <target state="translated">GIT_AUTHOR_IDENT</target>
        </trans-unit>
        <trans-unit id="725c6b7276951cf72d0731356407b6a84b3e59ef" translate="yes" xml:space="preserve">
          <source>GIT_COMMITTER_IDENT</source>
          <target state="translated">GIT_COMMITTER_IDENT</target>
        </trans-unit>
        <trans-unit id="3869ed3f7a51f55040f7a430ffe9ba97f98e246e" translate="yes" xml:space="preserve">
          <source>GIT_CONFIG</source>
          <target state="translated">GIT_CONFIG</target>
        </trans-unit>
        <trans-unit id="a5d490c74fb40af786be750b380476b10d1e4b69" translate="yes" xml:space="preserve">
          <source>GIT_CONFIG_NOSYSTEM</source>
          <target state="translated">GIT_CONFIG_NOSYSTEM</target>
        </trans-unit>
        <trans-unit id="01c412ca4d08642575a66ac381c4483c043b0ee1" translate="yes" xml:space="preserve">
          <source>GIT_CVSSERVER_BASE_PATH takes the place of the argument to --base-path.</source>
          <target state="translated">GIT_CVSSERVER_BASE_PATH は --base-path の引数の代わりになります。</target>
        </trans-unit>
        <trans-unit id="4f0780cd85f15ce5f825b343d1c06abf4cfc9741" translate="yes" xml:space="preserve">
          <source>GIT_CVSSERVER_ROOT specifies a single-directory whitelist. The repository must still be configured to allow access through git-cvsserver, as described above.</source>
          <target state="translated">git_cvsserver_root は単一ディレクトリのホワイトリストを指定します。リポジトリは、上で説明したように git-cvsserver を通してアクセスできるように設定しなければなりません。</target>
        </trans-unit>
        <trans-unit id="4ad19a85aef9ab4dcb6f62d95b8acf07e4c4828f" translate="yes" xml:space="preserve">
          <source>GIT_EDITOR</source>
          <target state="translated">GIT_EDITOR</target>
        </trans-unit>
        <trans-unit id="c8b3461d27dba4e8c6ce0c25c772c18d60c891a3" translate="yes" xml:space="preserve">
          <source>GIT_EXT_SERVICE</source>
          <target state="translated">GIT_EXT_SERVICE</target>
        </trans-unit>
        <trans-unit id="f4a08871056eea1076c323923e7cd2cd5fd6c0a8" translate="yes" xml:space="preserve">
          <source>GIT_EXT_SERVICE_NOPREFIX</source>
          <target state="translated">GIT_EXT_SERVICE_NOPREFIX</target>
        </trans-unit>
        <trans-unit id="08b684f4da6721d3a2c8e7b518324c7c98994b4e" translate="yes" xml:space="preserve">
          <source>GIT_INDEX_FILE</source>
          <target state="translated">GIT_INDEX_FILE</target>
        </trans-unit>
        <trans-unit id="cf57e9b3a04f2696e64705102232bab489ed97a5" translate="yes" xml:space="preserve">
          <source>GIT_OBJECT_DIRECTORY</source>
          <target state="translated">GIT_OBJECT_DIRECTORY</target>
        </trans-unit>
        <trans-unit id="924d60649d04fe751450b8bd3f1fc4a48bf559cb" translate="yes" xml:space="preserve">
          <source>GIT_PAGER</source>
          <target state="translated">GIT_PAGER</target>
        </trans-unit>
        <trans-unit id="ef2d6ed7bd1e2bfa87dc927172ada3fd1bdae6d2" translate="yes" xml:space="preserve">
          <source>GIT_TRANSLOOP_DEBUG</source>
          <target state="translated">GIT_TRANSLOOP_DEBUG</target>
        </trans-unit>
        <trans-unit id="a16f454460c35cd8704027fca6876a6a8646b0f2" translate="yes" xml:space="preserve">
          <source>GMail</source>
          <target state="translated">GMail</target>
        </trans-unit>
        <trans-unit id="cda466cee33ea6d923c0d1a6805da6ace37ac3f0" translate="yes" xml:space="preserve">
          <source>GMail does not have any way to turn off line wrapping in the web interface, so it will mangle any emails that you send. You can however use &quot;git send-email&quot; and send your patches through the GMail SMTP server, or use any IMAP email client to connect to the google IMAP server and forward the emails through that.</source>
          <target state="translated">GMail には、Web インターフェースでラインラッピングをオフにする方法がないので、送信したメールが混乱してしまいます。しかし、&quot;git send-email&quot; を使って GMail の SMTP サーバーからパッチを送ったり、IMAP メールクライアントを使って google IMAP サーバーに接続し、そこからメールを転送したりすることができます。</target>
        </trans-unit>
        <trans-unit id="31f314da9a863256952d9852bb7b935e9c829e75" translate="yes" xml:space="preserve">
          <source>GPG sign pushes.</source>
          <target state="translated">GPGサインが押す。</target>
        </trans-unit>
        <trans-unit id="d2cc3c3070810078ed6b670e4bd5c8639504233f" translate="yes" xml:space="preserve">
          <source>GPG-sign commits. The &lt;code&gt;keyid&lt;/code&gt; argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space.</source>
          <target state="translated">GPG署名コミット。 &lt;code&gt;keyid&lt;/code&gt; の引数はコミッターのアイデンティティオプションで、デフォルトです。指定する場合は、スペースなしでオプションに固執する必要があります。</target>
        </trans-unit>
        <trans-unit id="b1aed1c7977c0e2de26949b45fd71f731a4b1c8b" translate="yes" xml:space="preserve">
          <source>GPG-sign commits. The &lt;code&gt;keyid&lt;/code&gt; argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space. &lt;code&gt;--no-gpg-sign&lt;/code&gt; is useful to countermand a &lt;code&gt;--gpg-sign&lt;/code&gt; option given earlier on the command line.</source>
          <target state="translated">GPG-コミットに署名します。 &lt;code&gt;keyid&lt;/code&gt; の引数はコミッターのアイデンティティオプションで、デフォルトです。指定する場合は、スペースなしでオプションに固定する必要があります。 &lt;code&gt;--no-gpg-sign&lt;/code&gt; は、コマンドラインで前に指定した &lt;code&gt;--gpg-sign&lt;/code&gt; オプションを無効にするのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="064f918c2672d1e438a7a65cbdf8c083e0ff21e6" translate="yes" xml:space="preserve">
          <source>GPG-sign commits. The &lt;code&gt;keyid&lt;/code&gt; argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space. &lt;code&gt;--no-gpg-sign&lt;/code&gt; is useful to countermand both &lt;code&gt;commit.gpgSign&lt;/code&gt; configuration variable, and earlier &lt;code&gt;--gpg-sign&lt;/code&gt;.</source>
          <target state="translated">GPG-コミットに署名します。 &lt;code&gt;keyid&lt;/code&gt; の引数はコミッターのアイデンティティオプションで、デフォルトです。指定する場合は、スペースなしでオプションに固定する必要があります。 &lt;code&gt;--no-gpg-sign&lt;/code&gt; は、 &lt;code&gt;commit.gpgSign&lt;/code&gt; 構成変数と以前の &lt;code&gt;--gpg-sign&lt;/code&gt; の両方を無効にするのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="280cb8af503fd81af0776da1e5da5b505a515ac5" translate="yes" xml:space="preserve">
          <source>GPG-sign the push request to update refs on the receiving side, to allow it to be checked by the hooks and/or be logged. If &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;--no-signed&lt;/code&gt;, no signing will be attempted. If &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;--signed&lt;/code&gt;, the push will fail if the server does not support signed pushes. If set to &lt;code&gt;if-asked&lt;/code&gt;, sign if and only if the server supports signed pushes. The push will also fail if the actual call to &lt;code&gt;gpg --sign&lt;/code&gt; fails. See &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack[1]&lt;/a&gt; for the details on the receiving end.</source>
          <target state="translated">プッシュリクエストにGPG署名して、受信側のrefを更新し、フックでチェックしたりログに記録したりできるようにします。場合は &lt;code&gt;false&lt;/code&gt; または &lt;code&gt;--no-signed&lt;/code&gt; 、何の署名が試行されません。場合は &lt;code&gt;true&lt;/code&gt; または &lt;code&gt;--signed&lt;/code&gt; サーバが署名したプッシュをサポートしていない場合、プッシュは失敗します。 &lt;code&gt;if-asked&lt;/code&gt; に設定した場合、サーバーが署名付きプッシュをサポートする場合にのみ署名します。 &lt;code&gt;gpg --sign&lt;/code&gt; への実際の呼び出しが失敗した場合も、プッシュは失敗します。参照&lt;a href=&quot;git-receive-pack&quot;&gt;[1]のgit -受信パック&lt;/a&gt;受信側の詳細については。</target>
        </trans-unit>
        <trans-unit id="359179ddafe5ac57f233ce54be02401d37d2bd8b" translate="yes" xml:space="preserve">
          <source>GPG-sign the resulting merge commit. The &lt;code&gt;keyid&lt;/code&gt; argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space.</source>
          <target state="translated">結果のマージコミットにGPG署名します。 &lt;code&gt;keyid&lt;/code&gt; の引数はコミッターのアイデンティティオプションで、デフォルトです。指定する場合は、スペースなしでオプションに固執する必要があります。</target>
        </trans-unit>
        <trans-unit id="701d2f8958de65d8fe7b7eb1b839a88b4e25736c" translate="yes" xml:space="preserve">
          <source>GPG-sign the resulting merge commit. The &lt;code&gt;keyid&lt;/code&gt; argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space. &lt;code&gt;--no-gpg-sign&lt;/code&gt; is useful to countermand both &lt;code&gt;commit.gpgSign&lt;/code&gt; configuration variable, and earlier &lt;code&gt;--gpg-sign&lt;/code&gt;.</source>
          <target state="translated">GPG-結果のマージコミットに署名します。 &lt;code&gt;keyid&lt;/code&gt; の引数はコミッターのアイデンティティオプションで、デフォルトです。指定する場合は、スペースなしでオプションに固定する必要があります。 &lt;code&gt;--no-gpg-sign&lt;/code&gt; は、 &lt;code&gt;commit.gpgSign&lt;/code&gt; 構成変数と以前の &lt;code&gt;--gpg-sign&lt;/code&gt; の両方を無効にするのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="524cceb20916aff43a2680247362fb603a1a49c8" translate="yes" xml:space="preserve">
          <source>Garbage collect all unreferenced objects with &lt;code&gt;git gc --prune=now&lt;/code&gt; (or if your git-gc is not new enough to support arguments to &lt;code&gt;--prune&lt;/code&gt;, use &lt;code&gt;git repack -ad; git prune&lt;/code&gt; instead).</source>
          <target state="translated">&lt;code&gt;git gc --prune=now&lt;/code&gt; を使用して、参照されていないすべてのオブジェクトをガベージコレクションします（または、git-gcが &lt;code&gt;--prune&lt;/code&gt; への引数をサポートするのに十分に新しくない場合は、代わりに &lt;code&gt;git repack -ad; git prune&lt;/code&gt; repack -adを使用してください。代わりにgit prune）。</target>
        </trans-unit>
        <trans-unit id="5bcb5f8aaf1a9e559046fd7b5b3d79bbe4d3f426" translate="yes" xml:space="preserve">
          <source>General options</source>
          <target state="translated">一般的なオプション</target>
        </trans-unit>
        <trans-unit id="a5879c5c764017ca2130842dc888dcc88c04c99e" translate="yes" xml:space="preserve">
          <source>General variables</source>
          <target state="translated">一般変数</target>
        </trans-unit>
        <trans-unit id="55fd2438a0c551b4e16240eed52ec4917c61134a" translate="yes" xml:space="preserve">
          <source>Generally speaking, rule (3) above is the simplest for users to specify. Authors of credential helpers should make an effort to assist their users by naming their program &quot;git-credential-$NAME&quot;, and putting it in the &lt;code&gt;$PATH&lt;/code&gt; or &lt;code&gt;$GIT_EXEC_PATH&lt;/code&gt; during installation, which will allow a user to enable it with &lt;code&gt;git config credential.helper $NAME&lt;/code&gt;.</source>
          <target state="translated">一般的に、上記のルール（3）は、ユーザーが指定するのが最も簡単です。資格情報ヘルパーの作成者は、プログラムに「git-credential- $ NAME」という名前を付け、インストール中に &lt;code&gt;$PATH&lt;/code&gt; または &lt;code&gt;$GIT_EXEC_PATH&lt;/code&gt; に配置することで、ユーザーを支援するように努める必要があります。これにより、ユーザーは &lt;code&gt;git config credential.helper $NAME&lt;/code&gt; configcredentialでプログラムを有効にできます。 .helper $ NAME。</target>
        </trans-unit>
        <trans-unit id="f8e6a94549428bad778124c3c140042198abcb13" translate="yes" xml:space="preserve">
          <source>Generally this mode is used as an administrative interface to allow users to list repositories they have access to, create, delete, or rename repositories, or change repository descriptions and permissions.</source>
          <target state="translated">一般的にこのモードは管理インターフェイスとして使用され、ユーザーがアクセスできるリポジトリの一覧表示、リポジトリの作成、削除、名前の変更、リポジトリの説明や権限の変更などを行うことができます。</target>
        </trans-unit>
        <trans-unit id="5338e8546078668a151a9dabd932d38a31f12f5b" translate="yes" xml:space="preserve">
          <source>Generally, &lt;code&gt;git p4 clone&lt;/code&gt; is used to create a new Git directory from an existing p4 repository:</source>
          <target state="translated">一般に、 &lt;code&gt;git p4 clone&lt;/code&gt; は、既存のp4リポジトリから新しいGitディレクトリを作成するために使用されます。</target>
        </trans-unit>
        <trans-unit id="ad37ee86e2b3d890455e76bc1e7e0fc45d3460de" translate="yes" xml:space="preserve">
          <source>Generally, all Git operations work on the index file. Some operations work &lt;strong&gt;purely&lt;/strong&gt; on the index file (showing the current state of the index), but most operations move data between the index file and either the database or the working directory. Thus there are four main combinations:</source>
          <target state="translated">通常、すべてのGit操作はインデックスファイルに対して機能します。一部の操作は&lt;strong&gt;純粋&lt;/strong&gt;にインデックスファイルに対して機能します（インデックスの現在の状態を表示します）が、ほとんどの操作はインデックスファイルとデータベースまたは作業ディレクトリの間でデータを移動します。したがって、4つの主要な組み合わせがあります。</target>
        </trans-unit>
        <trans-unit id="c30116e53a947e31daeae056572933416099fbe0" translate="yes" xml:space="preserve">
          <source>Generally, dangling objects aren&amp;rsquo;t anything to worry about. They can even be very useful: if you screw something up, the dangling objects can be how you recover your old tree (say, you did a rebase, and realized that you really didn&amp;rsquo;t want to&amp;mdash;​you can look at what dangling objects you have, and decide to reset your head to some old dangling state).</source>
          <target state="translated">一般的に、ぶら下がっているオブジェクトは心配する必要はありません。これらは非常に便利な場合もあります。何かを台無しにすると、ぶら下がっているオブジェクトは、古いツリーを回復する方法になります（たとえば、リベースを実行したときに、本当にしたくないことに気付いた場合、ぶら下がっているものを見ることができます）あなたが持っているオブジェクト、そしてあなたの頭をいくつかの古いぶら下がっている状態にリセットすることにしました）。</target>
        </trans-unit>
        <trans-unit id="aefb0f39d3bd01ba3e438537ce5e3b6f3d075591" translate="yes" xml:space="preserve">
          <source>Generate a &lt;code&gt;$GIT_DIR/cvs-revisions&lt;/code&gt; file containing a mapping from CVS revision numbers to newly-created Git commit IDs. The generated file will contain one line for each (filename, revision) pair imported; each line will look like</source>
          <target state="translated">CVSリビジョン番号から新しく作成されたGitコミットIDへのマッピングを含む &lt;code&gt;$GIT_DIR/cvs-revisions&lt;/code&gt; ファイルを生成します。生成されたファイルには、インポートされた（ファイル名、リビジョン）ペアごとに1行が含まれます。各行は次のようになります</target>
        </trans-unit>
        <trans-unit id="d956a0b3c8358372085439a04d4b2593dd2bec54" translate="yes" xml:space="preserve">
          <source>Generate a credential description based on the context.</source>
          <target state="translated">コンテキストに基づいてクレデンシャルの説明を生成します。</target>
        </trans-unit>
        <trans-unit id="8b4e72c7495787832a335e23db7d41cdc955de4e" translate="yes" xml:space="preserve">
          <source>Generate a diff using the &quot;anchored diff&quot; algorithm.</source>
          <target state="translated">anchored diff&quot; アルゴリズムを使用して diff を生成します。</target>
        </trans-unit>
        <trans-unit id="c65b3bd43c187f9009fd8be60c354464048bfb2c" translate="yes" xml:space="preserve">
          <source>Generate a diff using the &quot;histogram diff&quot; algorithm.</source>
          <target state="translated">ヒストグラム差分」アルゴリズムを使用して差分を生成します。</target>
        </trans-unit>
        <trans-unit id="5a810f6cb04f85c060e73d8366053dc83cbde1b6" translate="yes" xml:space="preserve">
          <source>Generate a diff using the &quot;patience diff&quot; algorithm.</source>
          <target state="translated">忍耐差分」アルゴリズムを使用して差分を生成します。</target>
        </trans-unit>
        <trans-unit id="f50a5c7af33db239a645bbb0a36b9c949e7a8bfe" translate="yes" xml:space="preserve">
          <source>Generate a diffstat. By default, as much space as necessary will be used for the filename part, and the rest for the graph part. Maximum width defaults to terminal width, or 80 columns if not connected to a terminal, and can be overridden by &lt;code&gt;&amp;lt;width&amp;gt;&lt;/code&gt;. The width of the filename part can be limited by giving another width &lt;code&gt;&amp;lt;name-width&amp;gt;&lt;/code&gt; after a comma. The width of the graph part can be limited by using &lt;code&gt;--stat-graph-width=&amp;lt;width&amp;gt;&lt;/code&gt; (affects all commands generating a stat graph) or by setting &lt;code&gt;diff.statGraphWidth=&amp;lt;width&amp;gt;&lt;/code&gt; (does not affect &lt;code&gt;git format-patch&lt;/code&gt;). By giving a third parameter &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt;, you can limit the output to the first &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt; lines, followed by &lt;code&gt;...&lt;/code&gt; if there are more.</source>
          <target state="translated">diffstatを生成します。デフォルトでは、ファイル名部分には必要なだけのスペースが使用され、残りはグラフ部分に使用されます。最大幅のデフォルトはターミナルの幅、またはターミナルに接続されていない場合は80カラムで、 &lt;code&gt;&amp;lt;width&amp;gt;&lt;/code&gt; によってオーバーライドできます。ファイル名の部分の幅は、カンマの後に別の幅 &lt;code&gt;&amp;lt;name-width&amp;gt;&lt;/code&gt; を指定することで制限できます。グラフの部分の幅は、使用することによって制限することができる &lt;code&gt;--stat-graph-width=&amp;lt;width&amp;gt;&lt;/code&gt; （STATグラフを生成するすべてのコマンドに影響を与える）、または設定すること &lt;code&gt;diff.statGraphWidth=&amp;lt;width&amp;gt;&lt;/code&gt; （影響を与えない &lt;code&gt;git format-patch&lt;/code&gt; ） 。 3番目のパラメーター &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt; を指定すると、出力を最初の &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt; 行に制限できます。に続く &lt;code&gt;...&lt;/code&gt; もっとある場合。</target>
        </trans-unit>
        <trans-unit id="9a58997012274b692734905439c472fc9bf49724" translate="yes" xml:space="preserve">
          <source>Generate a request asking your upstream project to pull changes into their tree. The request, printed to the standard output, begins with the branch description, summarizes the changes and indicates from where they can be pulled.</source>
          <target state="translated">上流のプロジェクトに変更をツリーに引っ張ってくるように依頼するリクエストを生成します。標準出力に出力されるリクエストは、ブランチの説明で始まり、変更点を要約し、どこから変更点を引っ張ってくるかを示します。</target>
        </trans-unit>
        <trans-unit id="e43be14252a09239d3a95e69575c334d9dcee155" translate="yes" xml:space="preserve">
          <source>Generate diffs with &amp;lt;n&amp;gt; lines of context instead of the default of 3. This value is overridden by the -U option.</source>
          <target state="translated">デフォルトの3ではなく、&amp;lt;n&amp;gt;行のコンテキストでdiffを生成します。この値は、-Uオプションによってオーバーライドされます。</target>
        </trans-unit>
        <trans-unit id="0c3fb6d76074c691f7bc9656642039721293ad30" translate="yes" xml:space="preserve">
          <source>Generate diffs with &amp;lt;n&amp;gt; lines of context instead of the usual three. Implies &lt;code&gt;--patch&lt;/code&gt;.</source>
          <target state="translated">通常の3行ではなく、&amp;lt;n&amp;gt;行のコンテキストでdiffを生成します。意味 &lt;code&gt;--patch&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5423824f37bf5ebdc5aa787498e564ca92935ec4" translate="yes" xml:space="preserve">
          <source>Generate diffs with &amp;lt;n&amp;gt; lines of context instead of the usual three. Implies &lt;code&gt;--patch&lt;/code&gt;. Implies &lt;code&gt;-p&lt;/code&gt;.</source>
          <target state="translated">通常の3行ではなく、&amp;lt;n&amp;gt;行のコンテキストでdiffを生成します。意味 &lt;code&gt;--patch&lt;/code&gt; 。 &lt;code&gt;-p&lt;/code&gt; を意味します。</target>
        </trans-unit>
        <trans-unit id="c5ed7cc57b573e7d3d35a890e87a64e8016055b8" translate="yes" xml:space="preserve">
          <source>Generate patch (see section on generating patches).</source>
          <target state="translated">パッチを生成します(パッチの生成の項を参照)。</target>
        </trans-unit>
        <trans-unit id="468bd18b2fd829a488878e7cd9b8b00c33a3bf5f" translate="yes" xml:space="preserve">
          <source>Generate patch (see section on generating patches). This is the default.</source>
          <target state="translated">パッチを生成します (パッチの生成のセクションを参照してください)。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="0305bd83d4a1ca283e78c45f30f1d98f9bb246bc" translate="yes" xml:space="preserve">
          <source>Generate plain patches without any diffstats.</source>
          <target state="translated">diffstatsを使わずにプレーンなパッチを生成します。</target>
        </trans-unit>
        <trans-unit id="0cceb279f32e8c4384bb0e8684243cdf862ab779" translate="yes" xml:space="preserve">
          <source>Generate the diff in raw format.</source>
          <target state="translated">生の形式で差分を生成します。</target>
        </trans-unit>
        <trans-unit id="c49c41c6395d0de919c07a57d58570e04e74713d" translate="yes" xml:space="preserve">
          <source>Generate the diff in raw format. This is the default.</source>
          <target state="translated">差分を生の形式で生成します。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="88ef8fc7ea6872f6140c434b84c60ed4bc477b71" translate="yes" xml:space="preserve">
          <source>Generates a summary of pending changes</source>
          <target state="translated">保留中の変更の概要を生成します。</target>
        </trans-unit>
        <trans-unit id="b812709580c6b66bf19a88239714db45c6f547d3" translate="yes" xml:space="preserve">
          <source>Generates an RSS (or Atom) feed of changes to repository.</source>
          <target state="translated">リポジトリへの変更のRSS(またはAtom)フィードを生成します。</target>
        </trans-unit>
        <trans-unit id="6d3ce11672e300b3630956d5357a3f156d393821" translate="yes" xml:space="preserve">
          <source>Generating RSS and Atom feeds of commits, for any branch. The feeds are auto-discoverable in modern web browsers.</source>
          <target state="translated">任意のブランチのコミットの RSS および Atom フィードを生成します。フィードは最新のウェブブラウザで自動検出可能です。</target>
        </trans-unit>
        <trans-unit id="39bd3cb8cae2c62c26836b759476b4dce92db62c" translate="yes" xml:space="preserve">
          <source>Generating diff text</source>
          <target state="translated">差分テキストの生成</target>
        </trans-unit>
        <trans-unit id="6e83f1be8cebf28e1aa935d46feefe8c9c9b6bff" translate="yes" xml:space="preserve">
          <source>Generating diffs</source>
          <target state="translated">差分の生成</target>
        </trans-unit>
        <trans-unit id="d70a52c9081d71ce670fc7b47fc3bc012193cc1a" translate="yes" xml:space="preserve">
          <source>Generating patch text with -p</source>
          <target state="translated">p でパッチテキストを生成する</target>
        </trans-unit>
        <trans-unit id="6aeb48d435992fb6dfeaeb57975b9744c65abe0f" translate="yes" xml:space="preserve">
          <source>Generating projects list using gitweb</source>
          <target state="translated">gitweb を使ったプロジェクト一覧の生成</target>
        </trans-unit>
        <trans-unit id="77a43161f16023a4081e441eda8d16415635830a" translate="yes" xml:space="preserve">
          <source>Generic &amp;lt;revision range&amp;gt; expression (see &quot;SPECIFYING REVISIONS&quot; section in &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;) means the commits in the specified range.</source>
          <target state="translated">一般的な&amp;lt;revision range&amp;gt;式（&lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]の&lt;/a&gt;「SPECIFYING REVISIONS」セクションを参照）は、指定された範囲のコミットを意味します。</target>
        </trans-unit>
        <trans-unit id="6a8b0f1bc43a4668545c1d049581bdef7899704d" translate="yes" xml:space="preserve">
          <source>Get and set repository or global options</source>
          <target state="translated">リポジトリまたはグローバルオプションの取得と設定</target>
        </trans-unit>
        <trans-unit id="e36c9f7c3a3791a600900bd999a01e746ced35ba" translate="yes" xml:space="preserve">
          <source>Get the value for a given key (optionally filtered by a regex matching the value). Returns error code 1 if the key was not found and the last value if multiple key values were found.</source>
          <target state="translated">指定したキーの値を取得します (オプションで、値にマッチする正規表現でフィルタリングします)。キーが見つからなかった場合はエラーコード 1 を、 複数のキーの値が見つかった場合は最後の値を返します。</target>
        </trans-unit>
        <trans-unit id="1ed0d09699cf6099e40ea031af476399c03ae869" translate="yes" xml:space="preserve">
          <source>Gets the Subversion property given as the first argument, for a file. A specific revision can be specified with -r/--revision.</source>
          <target state="translated">第一引数に与えられた Subversion のプロパティをファイルに対して取得します。特定のリビジョンを指定するには -r/--revision を指定します。</target>
        </trans-unit>
        <trans-unit id="516c94a58b7d13bbfd33d93293ff07c0a7a0cbf5" translate="yes" xml:space="preserve">
          <source>Getting and Creating Projects</source>
          <target state="translated">プロジェクトの取得と作成</target>
        </trans-unit>
        <trans-unit id="970eb65fbea28c10c8dd662819611907796540db" translate="yes" xml:space="preserve">
          <source>Getting changes out is easy:</source>
          <target state="translated">変更を出すのは簡単です。</target>
        </trans-unit>
        <trans-unit id="f3ce20bb7af9a1868b401164829dfe90efbb8e6d" translate="yes" xml:space="preserve">
          <source>Getting conflict-resolution help during a merge</source>
          <target state="translated">マージ時の紛争解決の助けを得る</target>
        </trans-unit>
        <trans-unit id="060f712c74598ce01e86d56802d9344d8ed68bb7" translate="yes" xml:space="preserve">
          <source>Getting help</source>
          <target state="translated">助けを求める</target>
        </trans-unit>
        <trans-unit id="c459e54c0b44554b9b817457994c7c37528258a0" translate="yes" xml:space="preserve">
          <source>Getting updates with git pull</source>
          <target state="translated">git pull でアップデートを取得する</target>
        </trans-unit>
        <trans-unit id="5819778898df55e3a762f0c5728b457970d72cae" translate="yes" xml:space="preserve">
          <source>Git</source>
          <target state="translated">Git</target>
        </trans-unit>
        <trans-unit id="d732d81f4de6cbbc7c08999550694240dc675ed1" translate="yes" xml:space="preserve">
          <source>Git Commits</source>
          <target state="translated">Git コミット</target>
        </trans-unit>
        <trans-unit id="d0aaf3f6b8eb7d9c0d9e9cfe8351718f5fff142e" translate="yes" xml:space="preserve">
          <source>Git Diffs</source>
          <target state="translated">Git の差分</target>
        </trans-unit>
        <trans-unit id="2f8f97d0e40130f1bd878938daff8ad22d7dc440" translate="yes" xml:space="preserve">
          <source>Git Native</source>
          <target state="translated">Git ネイティブ</target>
        </trans-unit>
        <trans-unit id="29dd0634894701f7508333c275f98d0f1320daee" translate="yes" xml:space="preserve">
          <source>Git Repository Layout</source>
          <target state="translated">Git リポジトリのレイアウト</target>
        </trans-unit>
        <trans-unit id="d6e98b90bf56079b25bb9356fe9439f3123affff" translate="yes" xml:space="preserve">
          <source>Git Thread Messages</source>
          <target state="translated">Git スレッドメッセージ</target>
        </trans-unit>
        <trans-unit id="cae0e86da292416c6a36a0e4ce238566c9d247c3" translate="yes" xml:space="preserve">
          <source>Git Transport</source>
          <target state="translated">Git トランスポート</target>
        </trans-unit>
        <trans-unit id="a7c39055264c29496e9ec925896bc3e3ec696cb4" translate="yes" xml:space="preserve">
          <source>Git allows you to specify scripts called &quot;hooks&quot; to be run at certain points. You can use these, for example, to send all commits to the shared repository to a mailing list. See &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;.</source>
          <target state="translated">Gitでは、特定の時点で実行される「フック」と呼ばれるスクリプトを指定できます。たとえば、これらを使用して、共有リポジトリへのすべてのコミットをメーリングリストに送信できます。&lt;a href=&quot;githooks&quot;&gt;githooks [5]を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="6d26d4c60652b93a42ab638ebb72c8ba6beaba72" translate="yes" xml:space="preserve">
          <source>Git also keeps a pristine copy of Alice&amp;rsquo;s master branch under the name &quot;origin/master&quot;:</source>
          <target state="translated">Gitは、アリスのマスターブランチの元のコピーを「origin / master」という名前で保持しています。</target>
        </trans-unit>
        <trans-unit id="1738762c7d776a74999cdf10e57649ca4dc7876a" translate="yes" xml:space="preserve">
          <source>Git also provides a tool called &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt; (am stands for &quot;apply mailbox&quot;), for importing such an emailed series of patches. Just save all of the patch-containing messages, in order, into a single mailbox file, say &lt;code&gt;patches.mbox&lt;/code&gt;, then run</source>
          <target state="translated">Gitは、そのような電子メールで送信された一連のパッチをインポートするための&lt;a href=&quot;git-am&quot;&gt;git-am [1]&lt;/a&gt;（amは「apply mailbox」の略）と呼ばれるツールも提供しています。パッチを含むすべてのメッセージを順番に1つのメールボックスファイル（ &lt;code&gt;patches.mbox&lt;/code&gt; など）に保存して、次を実行するだけです。</target>
        </trans-unit>
        <trans-unit id="1dc53eccf42e15dc7948bd5d68aac36dca57063c" translate="yes" xml:space="preserve">
          <source>Git archive</source>
          <target state="translated">Git アーカイブ</target>
        </trans-unit>
        <trans-unit id="54c5b60d3b067a46392b8d1f7e7e747f00fb6589" translate="yes" xml:space="preserve">
          <source>Git can also be used in a CVS-like mode, with a central repository that various users push changes to; see &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt; and &lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration[7]&lt;/a&gt;.</source>
          <target state="translated">Gitは、さまざまなユーザーが変更をプッシュする中央リポジトリーを備えたCVSのようなモードでも使用できます。&lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt;および&lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration [7]を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="12dda0ab622d98c0bb3ecd2dcca2f78143c72090" translate="yes" xml:space="preserve">
          <source>Git can detect errors when it reads an object, by checking that the object&amp;rsquo;s name is still the SHA-1 hash of its contents.</source>
          <target state="translated">Gitは、オブジェクトの名前がコンテンツのSHA-1ハッシュであることを確認することで、オブジェクトを読み取るときにエラーを検出できます。</target>
        </trans-unit>
        <trans-unit id="e99355d5c834d0a7e793f2a903c686c73ccc0248" translate="yes" xml:space="preserve">
          <source>Git can help you perform a three-way merge, which can in turn be used for a many-way merge by repeating the merge procedure several times. The usual situation is that you only do one three-way merge (reconciling two lines of history) and commit the result, but if you like to, you can merge several branches in one go.</source>
          <target state="translated">Git は三元マージを実行するのを手助けしてくれます。通常は、三元マージ (二行の履歴の照合)を一回だけ行い、その結果をコミットするのが一般的ですが、お好みであれば、複数のブランチを一度にマージすることもできます。</target>
        </trans-unit>
        <trans-unit id="9711e4cc3e77224217a8eadfcd9bddb77a1a6b3f" translate="yes" xml:space="preserve">
          <source>Git can quickly determine whether two objects are identical or not, just by comparing names.</source>
          <target state="translated">Git は、名前を比較するだけで、2つのオブジェクトが同じかどうかを素早く判断することができます。</target>
        </trans-unit>
        <trans-unit id="66761dbf024e7710e093b6a26bb079c9a462b99d" translate="yes" xml:space="preserve">
          <source>Git comes with a &quot;curl&quot; family of remote helpers, that handle various transport protocols, such as &lt;code&gt;git-remote-http&lt;/code&gt;, &lt;code&gt;git-remote-https&lt;/code&gt;, &lt;code&gt;git-remote-ftp&lt;/code&gt; and &lt;code&gt;git-remote-ftps&lt;/code&gt;. They implement the capabilities &lt;code&gt;fetch&lt;/code&gt;, &lt;code&gt;option&lt;/code&gt;, and &lt;code&gt;push&lt;/code&gt;.</source>
          <target state="translated">Gitには、 &lt;code&gt;git-remote-http&lt;/code&gt; 、 &lt;code&gt;git-remote-https&lt;/code&gt; 、 &lt;code&gt;git-remote-ftp&lt;/code&gt; 、 &lt;code&gt;git-remote-ftps&lt;/code&gt; などのさまざまなトランスポートプロトコルを処理するリモートヘルパーの「curl」ファミリーが付属しています。これらは、 &lt;code&gt;fetch&lt;/code&gt; 、 &lt;code&gt;option&lt;/code&gt; 、および &lt;code&gt;push&lt;/code&gt; 機能を実装します。</target>
        </trans-unit>
        <trans-unit id="91008229119a3ca60fa9a13273e5a206ad3c01e1" translate="yes" xml:space="preserve">
          <source>Git command-line interface and conventions</source>
          <target state="translated">Git コマンドラインのインターフェイスと規約</target>
        </trans-unit>
        <trans-unit id="590c7b2e50468cb97c1bacdf4c22b05f53204bcc" translate="yes" xml:space="preserve">
          <source>Git commands</source>
          <target state="translated">Git コマンド</target>
        </trans-unit>
        <trans-unit id="748a4c7cdb8da160e4137b5f163f8f4f719642f9" translate="yes" xml:space="preserve">
          <source>Git concepts</source>
          <target state="translated">Git の概念</target>
        </trans-unit>
        <trans-unit id="23daed08ae51790de19c33ed17896e5944bcf442" translate="yes" xml:space="preserve">
          <source>Git considers each credential to have a context defined by a URL. This context is used to look up context-specific configuration, and is passed to any helpers, which may use it as an index into secure storage.</source>
          <target state="translated">Git は、各クレデンシャルが URL で定義されたコンテキストを持つと考えます。このコンテキストは、コンテキスト固有の設定を調べるために使われ、ヘルパーに渡されます。</target>
        </trans-unit>
        <trans-unit id="50d371d1d26e20ed2106ca5d2c77efab159f6b5e" translate="yes" xml:space="preserve">
          <source>Git data exporter</source>
          <target state="translated">Git データエクスポート</target>
        </trans-unit>
        <trans-unit id="df14b19afe5ac9b190d2e62a9bb072306d0becda" translate="yes" xml:space="preserve">
          <source>Git did not try to send the ref at all, typically because it is not a fast-forward and you did not force the update.</source>
          <target state="translated">Git が ref を全く送ろうとしなかったのは、典型的には早送りではなく、更新を強制的に行わなかったからです。</target>
        </trans-unit>
        <trans-unit id="2dac5af4573e16931bda9b37c2f40888a8b49b4e" translate="yes" xml:space="preserve">
          <source>Git diff features. By performing only the transformation step yourself, you can still utilize many of Git&amp;rsquo;s diff features, including colorization, word-diff, and combined diffs for merges.</source>
          <target state="translated">Git diff機能。変換ステップのみを自分で実行することにより、色付け、単語差分、マージ用の結合差分など、Gitの差分機能の多くを引き続き利用できます。</target>
        </trans-unit>
        <trans-unit id="4e4742213b12ec1297779eac50efdab191f84da4" translate="yes" xml:space="preserve">
          <source>Git differs from CVS in that every working tree contains a repository with a full copy of the project history, and no repository is inherently more important than any other. However, you can emulate the CVS model by designating a single shared repository which people can synchronize with; this document explains how to do that.</source>
          <target state="translated">Git は CVS とは異なり、すべての作業ツリーにはプロジェクトの履歴を完全にコピーしたリポジトリが含まれており、どのリポジトリも本質的に他のどのリポジトリよりも重要なものではありません。しかし、人々が同期できる単一の共有リポジトリを指定することで CVS モデルをエミュレートすることができます。</target>
        </trans-unit>
        <trans-unit id="52ba75f7d53c0098d95000c61cda5fd5ea6917af" translate="yes" xml:space="preserve">
          <source>Git directory name</source>
          <target state="translated">Git ディレクトリ名</target>
        </trans-unit>
        <trans-unit id="5d9fa4d20745d4b5b2bcfd60f9d543f73fbbd4e6" translate="yes" xml:space="preserve">
          <source>Git directory name, where all characters except for alphanumeric ones, &lt;code&gt;.&lt;/code&gt;, and &lt;code&gt;-&lt;/code&gt; are replaced with &lt;code&gt;_&lt;/code&gt; (this should make it easier to use the directory name in a filename if wanted)</source>
          <target state="translated">Gitディレクトリ名 &lt;code&gt;.&lt;/code&gt; 英数字以外のすべての文字。、および &lt;code&gt;-&lt;/code&gt; は &lt;code&gt;_&lt;/code&gt; に置き換えられます（これにより、必要に応じて、ファイル名にディレクトリ名を使用しやすくなります）</target>
        </trans-unit>
        <trans-unit id="9cf813a3cd69ecbe5e00c63d983206328e14b759" translate="yes" xml:space="preserve">
          <source>Git does not allow partial checkouts, so duplicating this approach in Git would force developers to keep a local copy of modules they are not interested in touching. Commits in an enormous checkout would be slower than you&amp;rsquo;d expect as Git would have to scan every directory for changes. If modules have a lot of local history, clones would take forever.</source>
          <target state="translated">Gitでは部分的なチェックアウトが許可されていないため、Gitでこのアプローチを複製すると、開発者は、関係のないモジュールのローカルコピーを保持する必要があります。Gitはすべてのディレクトリで変更をスキャンする必要があるため、膨大なチェックアウトでのコミットは、予想よりも遅くなります。モジュールに多くのローカル履歴がある場合、クローンは永遠にかかります。</target>
        </trans-unit>
        <trans-unit id="8b2d9679cf8575fc6c4cfb84434fb5d8180eb7ab" translate="yes" xml:space="preserve">
          <source>Git explained</source>
          <target state="translated">Gitの説明</target>
        </trans-unit>
        <trans-unit id="97b68f2c19cbd9c04d7ca8ff88d2678de8cfd1c0" translate="yes" xml:space="preserve">
          <source>Git for CVS users</source>
          <target state="translated">CVS ユーザーのための Git</target>
        </trans-unit>
        <trans-unit id="0db9018815b17c54cf84524352784d68bf492b44" translate="yes" xml:space="preserve">
          <source>Git glossary</source>
          <target state="translated">Git 用語集</target>
        </trans-unit>
        <trans-unit id="11c6d04869311aae599c74c45ab29a30fd9dc2d3" translate="yes" xml:space="preserve">
          <source>Git has a default disposition of keeping data unless it&amp;rsquo;s explicitly thrown away; this extends to holding onto local references to branches on remotes that have themselves deleted those branches.</source>
          <target state="translated">Gitには、明示的に破棄されない限り、データを保持するというデフォルトの性質があります。これは、それら自体がそれらのブランチを削除したリモート上のブランチへのローカル参照を保持することにまで及びます。</target>
        </trans-unit>
        <trans-unit id="c792c246c2740fcc85816c7742979ab9c07c5067" translate="yes" xml:space="preserve">
          <source>Git has an internal interface for storing and retrieving credentials from system-specific helpers, as well as prompting the user for usernames and passwords. The git-credential command exposes this interface to scripts which may want to retrieve, store, or prompt for credentials in the same manner as Git. The design of this scriptable interface models the internal C API; see credential.h for more background on the concepts.</source>
          <target state="translated">Git には、システム固有のヘルパーから認証情報を保存したり取得したりするための内部インターフェイスがあります。git-credential コマンドは、このインターフェイスをスクリプトに公開します。このスクリプト可能なインターフェイスのデザインは、内部の C API をモデルにしています。</target>
        </trans-unit>
        <trans-unit id="b5c69a965c60312962f3f44179acdc3a60b40e17" translate="yes" xml:space="preserve">
          <source>Git has no way of knowing that the new head is an updated version of the old head; it treats this situation exactly the same as it would if two developers had independently done the work on the old and new heads in parallel. At this point, if someone attempts to merge the new head in to their branch, Git will attempt to merge together the two (old and new) lines of development, instead of trying to replace the old by the new. The results are likely to be unexpected.</source>
          <target state="translated">Git は、新しいヘッドが古いヘッドの更新版であることを知る方法がありません。この状況を、二人の開発者がそれぞれ独立して古いヘッドと新しいヘッドの作業を並行して行った場合とまったく同じように扱います。この時点で、誰かが新しいヘッドを自分のブランチにマージしようとすると、Git は古いものを新しいものに置き換えようとするのではなく、二つの開発ライン (古いものと新しいもの)をマージしようとします。その結果は予想外のものになる可能性が高いです。</target>
        </trans-unit>
        <trans-unit id="06c2297147a37b1c482365d9d8f31d8dedf40fc4" translate="yes" xml:space="preserve">
          <source>Git history is represented as a series of interrelated commits. We have already seen that the &lt;code&gt;git log&lt;/code&gt; command can list those commits. Note that first line of each git log entry also gives a name for the commit:</source>
          <target state="translated">Gitの履歴は、相互に関連する一連のコミットとして表されます。 &lt;code&gt;git log&lt;/code&gt; コマンドがそれらのコミットを一覧表示できることはすでに見てきました。各gitログエントリの最初の行には、コミットの名前も表示されます。</target>
        </trans-unit>
        <trans-unit id="3e99ade0692d549a8a950dd96317ceaffb9107bb" translate="yes" xml:space="preserve">
          <source>Git imposes the following rules on how references are named:</source>
          <target state="translated">Git は、参照の名前の付け方について次のようなルールを課しています。</target>
        </trans-unit>
        <trans-unit id="a288f739ab4cf5d9993c702076fe0dc6fc3ee3ba" translate="yes" xml:space="preserve">
          <source>Git internal format</source>
          <target state="translated">Git 内部フォーマット</target>
        </trans-unit>
        <trans-unit id="64a97e8eaa30379dfa62ee80bea9820c4fe8a22e" translate="yes" xml:space="preserve">
          <source>Git is a Distributed Version Control system (DVCS) created by Linus Torvalds and maintained by Junio Hamano.</source>
          <target state="translated">GitはLinus Torvalds氏によって作成され、浜野純男氏によってメンテナンスされている分散バージョン管理システム(DVCS)です。</target>
        </trans-unit>
        <trans-unit id="f3967c7f5aeb4487a30c2b76c0330d8f45c7d45a" translate="yes" xml:space="preserve">
          <source>Git is a fast distributed revision control system.</source>
          <target state="translated">Gitは高速な分散リビジョン管理システムです。</target>
        </trans-unit>
        <trans-unit id="39998d13fc7a27f9efbe60a086c013b3bd3030af" translate="yes" xml:space="preserve">
          <source>Git is a fast, scalable, distributed revision control system with an unusually rich command set that provides both high-level operations and full access to internals.</source>
          <target state="translated">Gitは、高速でスケーラブルな分散型リビジョン管理システムであり、高レベルの操作と内部へのフルアクセスの両方を提供する異常に豊富なコマンドセットを備えています。</target>
        </trans-unit>
        <trans-unit id="9fb5868e31358193ca8585301de5ca9891b34989" translate="yes" xml:space="preserve">
          <source>Git is best thought of as a tool for storing the history of a collection of files. It does this by storing compressed snapshots of the contents of a file hierarchy, together with &quot;commits&quot; which show the relationships between these snapshots.</source>
          <target state="translated">Git は、ファイルの集合体の履歴を保存するためのツールと考えたほうがよいでしょう。これは、ファイル階層の内容を圧縮したスナップショットと、それらのスナップショット間の関係を示す &quot;commits&quot; を保存することで実現します。</target>
        </trans-unit>
        <trans-unit id="35ff36d5accbb4f2dda359fd3229598730d5aa08" translate="yes" xml:space="preserve">
          <source>Git is best thought of as a tool for storing the history of a collection of files. It stores the history as a compressed collection of interrelated snapshots of the project&amp;rsquo;s contents. In Git each such version is called a &lt;a href=&quot;#def_commit&quot;&gt;commit&lt;/a&gt;.</source>
          <target state="translated">Gitは、ファイルのコレクションの履歴を保存するためのツールとして最適です。履歴は、プロジェクトのコンテンツの相互に関連するスナップショットの圧縮されたコレクションとして保存されます。Gitでは、そのような各バージョンは&lt;a href=&quot;#def_commit&quot;&gt;コミット&lt;/a&gt;と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="7a9590b40529c70c530e12c39759365698786125" translate="yes" xml:space="preserve">
          <source>Git is built on a small number of simple but powerful ideas. While it is possible to get things done without understanding them, you will find Git much more intuitive if you do.</source>
          <target state="translated">Gitは少数のシンプルでありながら強力なアイデアの上に構築されています。それを理解せずに物事を進めることも可能ですが、そうすればGitはずっと直感的に使えるようになるでしょう。</target>
        </trans-unit>
        <trans-unit id="acccb72bd7439cce396900f6956100688cfe6ddd" translate="yes" xml:space="preserve">
          <source>Git is to some extent character encoding agnostic.</source>
          <target state="translated">Gitはある程度文字コード不可知です。</target>
        </trans-unit>
        <trans-unit id="db4366f04a4436ab91b01ad18e3f75e42a556e25" translate="yes" xml:space="preserve">
          <source>Git namespaces</source>
          <target state="translated">Git の名前空間</target>
        </trans-unit>
        <trans-unit id="a87c04c678f1edcfea18d0a701f5da80659e7540" translate="yes" xml:space="preserve">
          <source>Git neither stops nor restarts the filter process in case the &quot;error&quot;/&quot;abort&quot; status is set. However, Git sets its exit code according to the &lt;code&gt;filter.&amp;lt;driver&amp;gt;.required&lt;/code&gt; flag, mimicking the behavior of the &lt;code&gt;filter.&amp;lt;driver&amp;gt;.clean&lt;/code&gt; / &lt;code&gt;filter.&amp;lt;driver&amp;gt;.smudge&lt;/code&gt; mechanism.</source>
          <target state="translated">「エラー」/「中止」ステータスが設定されている場合、Gitはフィルタープロセスを停止も再開もしません。ただし、Gitは &lt;code&gt;filter.&amp;lt;driver&amp;gt;.required&lt;/code&gt; フラグに従って終了コードを設定し、 &lt;code&gt;filter.&amp;lt;driver&amp;gt;.clean&lt;/code&gt; / &lt;code&gt;filter.&amp;lt;driver&amp;gt;.smudge&lt;/code&gt; メカニズムの動作を模倣します。</target>
        </trans-unit>
        <trans-unit id="bcbcedc091eff7502178afecdce9f3afdc72dc05" translate="yes" xml:space="preserve">
          <source>Git provides extremely flexible and fast tools for exploring the history of a project.</source>
          <target state="translated">Git は、プロジェクトの歴史を探るための非常に柔軟で高速なツールを提供します。</target>
        </trans-unit>
        <trans-unit id="38200bd70c851718b2397208bade5f568860b37a" translate="yes" xml:space="preserve">
          <source>Git recognizes files encoded in ASCII or one of its supersets (e.g. UTF-8, ISO-8859-1, &amp;hellip;​) as text files. Files encoded in certain other encodings (e.g. UTF-16) are interpreted as binary and consequently built-in Git text processing tools (e.g. &lt;code&gt;git diff&lt;/code&gt;) as well as most Git web front ends do not visualize the contents of these files by default.</source>
          <target state="translated">Gitは、ASCIIまたはそのスーパーセット（UTF-8、ISO-8859-1など）でエンコードされたファイルをテキストファイルとして認識します。他の特定のエンコーディング（UTF-16など）でエンコードされたファイルはバイナリとして解釈されるため、組み込みのGitテキスト処理ツール（ &lt;code&gt;git diff&lt;/code&gt; など）とほとんどのGit Webフロントエンドは、デフォルトではこれらのファイルのコンテンツを視覚化しません。</target>
        </trans-unit>
        <trans-unit id="db884716c8275e6cfa36ed29dbc5d360bba57d0e" translate="yes" xml:space="preserve">
          <source>Git relies on the proper configuration of this variable for your operating and file system. Modifying this value may result in unexpected behavior.</source>
          <target state="translated">Git は、この変数の適切な設定に依存しています。この値を変更すると、予期せぬ動作をする可能性があります。</target>
        </trans-unit>
        <trans-unit id="a66f7e50154ea192af5f4749135be70398075b72" translate="yes" xml:space="preserve">
          <source>Git repositories are normally totally self-sufficient and relocatable. Unlike CVS, for example, there is no separate notion of &quot;repository&quot; and &quot;working tree&quot;. A Git repository normally &lt;strong&gt;is&lt;/strong&gt; the working tree, with the local Git information hidden in the &lt;code&gt;.git&lt;/code&gt; subdirectory. There is nothing else. What you see is what you got.</source>
          <target state="translated">Gitリポジトリは通常、完全に自己完結型で再配置可能です。たとえば、CVSとは異なり、「リポジトリ」と「ワーキングツリー」という別個の概念はありません。通常、Gitリポジトリ&lt;strong&gt;は&lt;/strong&gt;作業ツリーであり、ローカルGit情報は &lt;code&gt;.git&lt;/code&gt; サブディレクトリに隠されています。他には何もありません。あなたが見るものはあなたが得たものです。</target>
        </trans-unit>
        <trans-unit id="cf8c005d3f0e4d9e1ff9d1e8d46ef8fd98f0bbf4" translate="yes" xml:space="preserve">
          <source>Git repository format versions</source>
          <target state="translated">Git リポジトリ形式のバージョン</target>
        </trans-unit>
        <trans-unit id="cd868bd588534f7cc4b6680d57c0627b3503b53c" translate="yes" xml:space="preserve">
          <source>Git sends the remote helper a list of commands on standard input, one per line. The first command is always the &lt;code&gt;capabilities&lt;/code&gt; command, in response to which the remote helper must print a list of the capabilities it supports (see below) followed by a blank line. The response to the capabilities command determines what commands Git uses in the remainder of the command stream.</source>
          <target state="translated">Gitはリモートヘルパーにコマンドのリストを標準入力で1行に1つ送信します。最初のコマンドは常に &lt;code&gt;capabilities&lt;/code&gt; コマンドです。これに応じて、リモートヘルパーは、サポートする機能のリスト（下記を参照）を出力する必要があり、その後に空白行が続きます。capabilitiesコマンドへの応答により、Gitがコマンドストリームの残りの部分で使用するコマンドが決まります。</target>
        </trans-unit>
        <trans-unit id="49f2ae128519616ee7193d5988bcbce620249ed4" translate="yes" xml:space="preserve">
          <source>Git supports dividing the refs of a single repository into multiple namespaces, each of which has its own branches, tags, and HEAD. Git can expose each namespace as an independent repository to pull from and push to, while sharing the object store, and exposing all the refs to operations such as &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt;.</source>
          <target state="translated">Gitは、単一のリポジトリーの参照を複数の名前空間に分割することをサポートします。各名前空間には、独自のブランチ、タグ、およびHEADがあります。Gitは、オブジェクトストアを共有し、すべての参照を&lt;a href=&quot;git-gc&quot;&gt;git-gc [1]&lt;/a&gt;などの操作に公開しながら、プルおよびプッシュする独立したリポジトリとして各名前空間を公開できます。</target>
        </trans-unit>
        <trans-unit id="da0d87f50d864c408fa4b395576786d97bb31ddd" translate="yes" xml:space="preserve">
          <source>Git supports ssh, git, http, and https protocols (in addition, ftp, and ftps can be used for fetching, but this is inefficient and deprecated; do not use it).</source>
          <target state="translated">Git は ssh,git,http,https プロトコルをサポートしています (さらに、ftp,ftps をフェッチに使うこともできますが、これは効率が悪く非推奨ですので使わないでください)。</target>
        </trans-unit>
        <trans-unit id="2cde7635ac8cf69f2e210aa19a54d3042440cb25" translate="yes" xml:space="preserve">
          <source>Git tracks content not files</source>
          <target state="translated">Git はファイルではなくコンテンツを追跡する</target>
        </trans-unit>
        <trans-unit id="d302527fd1d763cfe7e5d18396b3435236371be0" translate="yes" xml:space="preserve">
          <source>Git treats the pattern as a shell glob suitable for consumption by fnmatch(3) with the FNM_PATHNAME flag: wildcards in the pattern will not match a / in the pathname. For example, &quot;Documentation/*.html&quot; matches &quot;Documentation/git.html&quot; but not &quot;Documentation/ppc/ppc.html&quot; or &quot;tools/perf/Documentation/perf.html&quot;.</source>
          <target state="translated">Git は、パターンを FNM_PATHNAME フラグを指定した fnmatch(3)で使用するのに適したシェル・グロブとして扱います:パターン内のワイルドカードはパス名の/にマッチしません。例えば、&quot;Documentation/*.html &quot;は &quot;Documentation/git.html &quot;にマッチしますが、&quot;Documentation/ppc/ppc.html &quot;や &quot;tools/perf/Documentation/perf.html &quot;にはマッチしません。</target>
        </trans-unit>
        <trans-unit id="f8bad0cd453249cf5d129aec87c3431738399e00" translate="yes" xml:space="preserve">
          <source>Git understands the following attributes:</source>
          <target state="translated">Gitは以下の属性を理解しています。</target>
        </trans-unit>
        <trans-unit id="7e54cce67cf2641b15706179b6168b5a2d3b1bcd" translate="yes" xml:space="preserve">
          <source>Git urls</source>
          <target state="translated">Git urls</target>
        </trans-unit>
        <trans-unit id="751190188de5688aa514632f7b1c3310593ad2c7" translate="yes" xml:space="preserve">
          <source>Git users can broadly be grouped into four categories for the purposes of describing here a small set of useful command for everyday Git.</source>
          <target state="translated">ここでは、日常的なGitのための便利なコマンドの小さなセットを記述する目的で、Gitユーザーを大きく4つのカテゴリに分類することができます。</target>
        </trans-unit>
        <trans-unit id="b7ac07d144784e0a8c84df59d7316744b8847546" translate="yes" xml:space="preserve">
          <source>Git uses a simple text format to store customizations that are per repository and are per user. Such a configuration file may look like this:</source>
          <target state="translated">Gitは、リポジトリごと、ユーザーごとのカスタマイズを保存するためにシンプルなテキスト形式を使用しています。このような設定ファイルは次のようになります。</target>
        </trans-unit>
        <trans-unit id="172b4ceb66bee5a713d5dcc15584b89df5db983d" translate="yes" xml:space="preserve">
          <source>Git usually guesses correctly whether a blob contains text or binary data by examining the beginning of the contents. However, sometimes you may want to override its decision, either because a blob contains binary data later in the file, or because the content, while technically composed of text characters, is opaque to a human reader. For example, many postscript files contain only ASCII characters, but produce noisy and meaningless diffs.</source>
          <target state="translated">Git は通常、ブロブにテキストデータが含まれているのかバイナリデータが含まれているのかを、コンテンツの先頭を調べて正確に推測します。しかし、時にはその判断を上書きしたくなることもあるでしょう。それは、ブロブがファイルの後半にバイナリデータを含んでいたり、技術的にはテキスト文字で構成されていても内容が不透明だったりするからです。例えば、多くの postscript ファイルは ASCII 文字だけを含んでいますが、ノイズの多い無意味な diff を生成します。</target>
        </trans-unit>
        <trans-unit id="8049931f388e861f0f1d36c522924184358c43ba" translate="yes" xml:space="preserve">
          <source>Git was started by Linus Torvalds, and is currently maintained by Junio C Hamano. Numerous contributions have come from the Git mailing list &amp;lt;&lt;a href=&quot;mailto:git@vger.kernel.org&quot;&gt;git@vger.kernel.org&lt;/a&gt;&amp;gt;. &lt;a href=&quot;http://www.openhub.net/p/git/contributors/summary&quot;&gt;http://www.openhub.net/p/git/contributors/summary&lt;/a&gt; gives you a more complete list of contributors.</source>
          <target state="translated">GitはLinus Torvaldsによって開始され、現在Junio C Hamanoによって保守されています。Gitメーリングリスト&amp;lt; &lt;a href=&quot;mailto:git@vger.kernel.org&quot;&gt;git@vger.kernel.org&lt;/a&gt; &amp;gt; から多くの貢献が寄せられています。&lt;a href=&quot;http://www.openhub.net/p/git/contributors/summary&quot;&gt;http://www.openhub.net/p/git/contributors/summary&lt;/a&gt;は、より完全な貢献者のリストを提供します。</target>
        </trans-unit>
        <trans-unit id="526caa17e283066f503c081c2465980601606a1b" translate="yes" xml:space="preserve">
          <source>Git web interface (web frontend to Git repositories)</source>
          <target state="translated">Git ウェブインターフェース (Git リポジトリへのウェブフロントエンド)</target>
        </trans-unit>
        <trans-unit id="041fb03988c0360186f3faf7d7f4aee25aff3a46" translate="yes" xml:space="preserve">
          <source>Git will apply each patch in order; if any conflicts are found, it will stop, and you can fix the conflicts as described in &quot;&lt;a href=&quot;#resolving-a-merge&quot;&gt;Resolving a merge&lt;/a&gt;&quot;. (The &lt;code&gt;-3&lt;/code&gt; option tells Git to perform a merge; if you would prefer it just to abort and leave your tree and index untouched, you may omit that option.)</source>
          <target state="translated">Gitは各パッチを順番に適用します。競合が見つかった場合は停止し、「&lt;a href=&quot;#resolving-a-merge&quot;&gt;マージの解決&lt;/a&gt;」の説明に従って競合を修正できます。（ &lt;code&gt;-3&lt;/code&gt; オプションは、Gitにマージを実行するように指示します。中止して、ツリーとインデックスをそのままにする場合は、そのオプションを省略できます。）</target>
        </trans-unit>
        <trans-unit id="5affbc744831be1e58dd602e173c2e8a9635241c" translate="yes" xml:space="preserve">
          <source>Git will fail (gracefully) in case it needs to modify this file in the index e.g. when merging in a commit; thus, in case the assumed-untracked file is changed upstream, you will need to handle the situation manually.</source>
          <target state="translated">Git は、コミットでマージする際などにインデックス内のこのファイルを変更する必要がある場合には (潔く)失敗します。</target>
        </trans-unit>
        <trans-unit id="48da4a71e3b0bf95013a3e083375ba4a4f8d9442" translate="yes" xml:space="preserve">
          <source>Git will limit what files it checks for changes as well as which directories are checked for untracked files based on the path names given.</source>
          <target state="translated">Git は、与えられたパス名に基づいて、変更をチェックするファイルを制限したり、追跡されていないファイルをチェックするディレクトリを制限したりします。</target>
        </trans-unit>
        <trans-unit id="9b6711c26bfff56f55ea4e0cb9cd80ae556f923a" translate="yes" xml:space="preserve">
          <source>Git will reply</source>
          <target state="translated">Gitが返信する</target>
        </trans-unit>
        <trans-unit id="bca1285083439b77ee97a317766aadc935c0bbdf" translate="yes" xml:space="preserve">
          <source>Git will sometimes need credentials from the user in order to perform operations; for example, it may need to ask for a username and password in order to access a remote repository over HTTP. This manual describes the mechanisms Git uses to request these credentials, as well as some features to avoid inputting these credentials repeatedly.</source>
          <target state="translated">たとえば、HTTP でリモートリポジトリにアクセスするためにユーザー名とパスワードを要求しなければならないことがあります。このマニュアルでは、Git がこれらの認証情報を要求するための仕組みと、認証情報の繰り返し入力を避けるための機能について説明します。</target>
        </trans-unit>
        <trans-unit id="dd4de92d6643474e91f15af2289a2ff1175302eb" translate="yes" xml:space="preserve">
          <source>Git writes temporary &lt;code&gt;BASE&lt;/code&gt;, &lt;code&gt;LOCAL&lt;/code&gt;, and &lt;code&gt;REMOTE&lt;/code&gt; versions of conflicting files in the worktree by default. Git will attempt to use a temporary directory for these files when set &lt;code&gt;true&lt;/code&gt;. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Gitはデフォルトで、競合するファイルの一時的な &lt;code&gt;BASE&lt;/code&gt; 、 &lt;code&gt;LOCAL&lt;/code&gt; 、および &lt;code&gt;REMOTE&lt;/code&gt; バージョンをワークツリーに書き込みます。 &lt;code&gt;true&lt;/code&gt; に設定すると、Gitはこれらのファイルの一時ディレクトリを使用しようとします。デフォルトは &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="24c7b4499addc9a93ccbe263411515a9a891fc27" translate="yes" xml:space="preserve">
          <source>Git&amp;rsquo;s ability to quickly import and merge patches allows a single maintainer to process incoming changes even at very high rates. And when that becomes too much, &lt;code&gt;git pull&lt;/code&gt; provides an easy way for that maintainer to delegate this job to other maintainers while still allowing optional review of incoming changes.</source>
          <target state="translated">パッチをすばやくインポートしてマージするGitの機能により、1人のメンテナーが非常に高いレートで入ってくる変更を処理することができます。そして、それが多すぎる場合、 &lt;code&gt;git pull&lt;/code&gt; は、メンテナーがこのジョブを他のメンテナーに委任すると同時に、着信する変更のオプションのレビューを可能にする簡単な方法を提供します。</target>
        </trans-unit>
        <trans-unit id="9715a07ab0249fd3ddbc253711eb7248c1c1366b" translate="yes" xml:space="preserve">
          <source>Git&amp;rsquo;s i18n setup code for shell scripts</source>
          <target state="translated">シェルスクリプト用のGitのi18nセットアップコード</target>
        </trans-unit>
        <trans-unit id="4917cf9f784e37253e2667c9ea0e66247909051b" translate="yes" xml:space="preserve">
          <source>Git&amp;rsquo;s submodule support allows a repository to contain, as a subdirectory, a checkout of an external project. Submodules maintain their own identity; the submodule support just stores the submodule repository location and commit ID, so other developers who clone the containing project (&quot;superproject&quot;) can easily clone all the submodules at the same revision. Partial checkouts of the superproject are possible: you can tell Git to clone none, some or all of the submodules.</source>
          <target state="translated">Gitのサブモジュールのサポートにより、リポジトリーにサブプロジェクトとして外部プロジェクトのチェックアウトを含めることができます。サブモジュールは独自のIDを維持します。サブモジュールのサポートはサブモジュールリポジトリの場所とコミットIDを格納するだけなので、含まれているプロジェクト（「スーパープロジェクト」）を複製する他の開発者は、同じリビジョンのすべてのサブモジュールを簡単に複製できます。スーパープロジェクトの部分的なチェックアウトが可能です。Gitにサブモジュールを複製しないように指示することも、一部またはすべてのサブモジュールを複製することもできます。</target>
        </trans-unit>
        <trans-unit id="f1ffaf3a57e8861e273a81c5d860f0898c1c6dac" translate="yes" xml:space="preserve">
          <source>Gitk was the first graphical repository browser. It&amp;rsquo;s written in tcl/tk.</source>
          <target state="translated">Gitkは最初のグラフィカルリポジトリブラウザでした。それはtcl / tkで書かれています。</target>
        </trans-unit>
        <trans-unit id="969a3c97b510dcff0a924faf9dee287a0e5d94ec" translate="yes" xml:space="preserve">
          <source>Gitweb assumes this charset when a line contains non-UTF-8 characters. The fallback decoding is used without error checking, so it can be even &quot;utf-8&quot;. The value must be a valid encoding; see the &lt;strong&gt;Encoding::Supported&lt;/strong&gt;(3pm) man page for a list. The default is &quot;latin1&quot;, aka. &quot;iso-8859-1&quot;.</source>
          <target state="translated">行に非UTF-8文字が含まれている場合、Gitwebはこの文字セットを想定します。フォールバックデコードはエラーチェックなしで使用されるため、「utf-8」の場合もあります。値は有効なエンコードである必要があります。リストについては、&lt;strong&gt;Encoding :: Supported&lt;/strong&gt;（3pm）のマニュアルページを参照してください。デフォルトは「latin1」、別名です。「iso-8859-1」。</target>
        </trans-unit>
        <trans-unit id="23aa8c44f909f60d83eed1c6ecddb35429f0603e" translate="yes" xml:space="preserve">
          <source>Gitweb can show information from one or more Git repositories. These repositories have to be all on local filesystem, and have to share common repository root, i.e. be all under a single parent repository (but see also &quot;Advanced web server setup&quot; section, &quot;Webserver configuration with multiple projects' root&quot; subsection).</source>
          <target state="translated">Gitweb は、ひとつ以上の Git リポジトリの情報を表示することができます。これらのリポジトリはすべてローカルファイルシステム上にあり、共通のリポジトリルートを共有していなければなりません。</target>
        </trans-unit>
        <trans-unit id="80e6e4e3c32d8a850e194d0e624021eac7612871" translate="yes" xml:space="preserve">
          <source>Gitweb can use path_info (component) based URLs, or it can pass all necessary information via query parameters. The typical gitweb URLs are broken down in to five components:</source>
          <target state="translated">Gitweb は path_info (コンポーネント)ベースの URL を使うこともできますし、必要な情報をすべてクエリパラメータで渡すこともできます。典型的なgitwebのURLは、5つのコンポーネントに分解されます。</target>
        </trans-unit>
        <trans-unit id="c91227cd181327062eb5ac3babb9dcdd0a92cc2a" translate="yes" xml:space="preserve">
          <source>Gitweb provides a web interface to Git repositories. Its features include:</source>
          <target state="translated">Gitweb は、Git リポジトリへのウェブインターフェースを提供します。その機能には以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="b64851fc263d72157b99e98603012bfc29c4f9ff" translate="yes" xml:space="preserve">
          <source>Gitweb reads configuration data from the following sources in the following order:</source>
          <target state="translated">Gitwebは、以下のソースから順に設定データを読み込みます。</target>
        </trans-unit>
        <trans-unit id="0b6ae99cd0fc07dd07b98d65f39c6a8d809c4979" translate="yes" xml:space="preserve">
          <source>Gitweb version, set automatically when creating gitweb.cgi from gitweb.perl. You might want to modify it if you are running modified gitweb, for example</source>
          <target state="translated">gitweb.perl から gitweb.cgi を作成する際に自動的に設定される Gitweb のバージョン。修正された gitweb を実行している場合は、これを修正したほうがいいかもしれません。</target>
        </trans-unit>
        <trans-unit id="fcc44369541727be05647a1cc4996dbc27b86060" translate="yes" xml:space="preserve">
          <source>Gitweb works with Apache and FastCGI. First you need to rename, copy or symlink gitweb.cgi to gitweb.fcgi. Let&amp;rsquo;s assume that gitweb is installed in &lt;code&gt;/usr/share/gitweb&lt;/code&gt; directory. The following Apache configuration is suitable (UNTESTED!)</source>
          <target state="translated">GitwebはApacheおよびFastCGIで動作します。まず、gitweb.cgiをgitweb.fcgiに名前変更、コピー、またはシンボリックリンクする必要があります。gitwebが &lt;code&gt;/usr/share/gitweb&lt;/code&gt; ディレクトリにインストールされていると仮定しましょう。次のApache構成が適しています（テストされていません！）</target>
        </trans-unit>
        <trans-unit id="42543af4180750540520e4da78d3e7076123fd5c" translate="yes" xml:space="preserve">
          <source>Give an object a human readable name based on an available ref</source>
          <target state="translated">利用可能な参照に基づいて、オブジェクトに人間が読める名前を与えます。</target>
        </trans-unit>
        <trans-unit id="8a08e691bc874c43f32edff7b28078841082dfd2" translate="yes" xml:space="preserve">
          <source>Give push/pull only access to developers using git-over-ssh.</source>
          <target state="translated">git-over-ssh を使っている開発者だけに push/pull のアクセス権を与えます。</target>
        </trans-unit>
        <trans-unit id="098611c3aa4062358e82cce32a6cb2188462a62d" translate="yes" xml:space="preserve">
          <source>Give the output in an easy-to-parse format for scripts. This is similar to the short output, but will remain stable across Git versions and regardless of user configuration. See below for details.</source>
          <target state="translated">スクリプト用にパースしやすい形式で出力を与えます。これは短い出力と似ていますが、Git のバージョンやユーザーの設定に関係なく安定して出力されます。詳細は以下を参照してください。</target>
        </trans-unit>
        <trans-unit id="4cab29647a0992b826e617662d099d2fa7b8c337" translate="yes" xml:space="preserve">
          <source>Give the output in the long-format. This is the default.</source>
          <target state="translated">ロングフォーマットで出力します。これがデフォルトです。</target>
        </trans-unit>
        <trans-unit id="7b3a4cfa6cfda1ef4f79bab4a1d749c9c6c5f5f0" translate="yes" xml:space="preserve">
          <source>Give the output in the short-format.</source>
          <target state="translated">短縮形式で出力してください。</target>
        </trans-unit>
        <trans-unit id="2dc950b47492cb25f78f25c843f0ed41c631283b" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;--delete&lt;/code&gt; and an additional argument, deletes the given symbolic ref.</source>
          <target state="translated">与えられた &lt;code&gt;--delete&lt;/code&gt; と追加の引数、与えられたシンボリック参照を削除します。</target>
        </trans-unit>
        <trans-unit id="e97e8a091675b0288dfc0175fdb5f7c838cea92d" translate="yes" xml:space="preserve">
          <source>Given N &amp;lt;references&amp;gt;, the first N lines are the one-line description from their commit message. The branch head that is pointed at by $GIT_DIR/HEAD is prefixed with an asterisk &lt;code&gt;*&lt;/code&gt; character while other heads are prefixed with a &lt;code&gt;!&lt;/code&gt; character.</source>
          <target state="translated">N &amp;lt;references&amp;gt;が指定されている場合、最初のN行は、コミットメッセージからの1行の説明です。$ GIT_DIR / HEADが指すブランチヘッドの前にはアスタリスク &lt;code&gt;*&lt;/code&gt; 文字が付けられ、他のヘッドには &lt;code&gt;!&lt;/code&gt; キャラクター。</target>
        </trans-unit>
        <trans-unit id="a02a332c45eb3b9cf3b89841e8aa1ca85e593c49" translate="yes" xml:space="preserve">
          <source>Given a .git/config like this:</source>
          <target state="translated">このような .git/config を指定すると</target>
        </trans-unit>
        <trans-unit id="e65ae867c8cb398abc725e8538eba217d02dbede" translate="yes" xml:space="preserve">
          <source>Given a commit, find out where it is relative to the local refs. Say somebody wrote you about that fantastic commit 33db5f4d9027a10e477ccf054b2c1ab94f74c85a. Of course, you look into the commit, but that only tells you what happened, but not the context.</source>
          <target state="translated">コミットが与えられた場合、それがローカルの参照からの相対的な位置にあるかどうかを確認してください。誰かがあなたに 33db5f4d9027a10e477ccf054b2c1ab94f74c85a という素晴らしいコミットを書いてくれたとしましょう。もちろん、あなたはそのコミットを調べますが、それは何が起こったかを教えてくれるだけで、コンテキストを教えてくれるわけではありません。</target>
        </trans-unit>
        <trans-unit id="7ce01790b46379d506c51a1991e3ea26b3a8d244" translate="yes" xml:space="preserve">
          <source>Given one argument, reads which branch head the given symbolic ref refers to and outputs its path, relative to the &lt;code&gt;.git/&lt;/code&gt; directory. Typically you would give &lt;code&gt;HEAD&lt;/code&gt; as the &amp;lt;name&amp;gt; argument to see which branch your working tree is on.</source>
          <target state="translated">1つの引数を指定すると、指定されたシンボリック参照が参照するブランチヘッドを読み取り、 &lt;code&gt;.git/&lt;/code&gt; ディレクトリからの相対パスを出力します。通常、作業ツリーがどのブランチにあるかを確認するには、&amp;lt;name&amp;gt;引数として &lt;code&gt;HEAD&lt;/code&gt; を指定します。</target>
        </trans-unit>
        <trans-unit id="ee9f44e6df9f9221a39559d12563d4ded15eb1ae" translate="yes" xml:space="preserve">
          <source>Given one or more existing commits, apply the change each one introduces, recording a new commit for each. This requires your working tree to be clean (no modifications from the HEAD commit).</source>
          <target state="translated">一つ以上の既存のコミットがあった場合、それぞれの変更を適用し、それぞれに新しいコミットを記録します。このためには、作業ツリーがクリーンである必要があります (HEAD コミットからの変更はありません)。</target>
        </trans-unit>
        <trans-unit id="49cfc78f8193ed0e67ffaf9646d690418c000a33" translate="yes" xml:space="preserve">
          <source>Given one or more existing commits, revert the changes that the related patches introduce, and record some new commits that record them. This requires your working tree to be clean (no modifications from the HEAD commit).</source>
          <target state="translated">一つ以上の既存のコミットがある場合、関連するパッチが導入した変更を元に戻し、それを記録した新しいコミットを記録します。このためには、作業ツリーがクリーンである必要があります (HEAD コミットからの変更はありません)。</target>
        </trans-unit>
        <trans-unit id="b90c39be8f3013761513d522c230779e0af0700e" translate="yes" xml:space="preserve">
          <source>Given the following noisy input with &lt;code&gt;$&lt;/code&gt; indicating the end of a line:</source>
          <target state="translated">&lt;code&gt;$&lt;/code&gt; が行の終わりを示す次のノイズの多い入力があるとします。</target>
        </trans-unit>
        <trans-unit id="9ae9c5ba5c0cae940c9ccda71b399bacf0ceae54" translate="yes" xml:space="preserve">
          <source>Given three arguments, stores the &amp;lt;newvalue&amp;gt; in the &amp;lt;ref&amp;gt;, possibly dereferencing the symbolic refs, after verifying that the current value of the &amp;lt;ref&amp;gt; matches &amp;lt;oldvalue&amp;gt;. E.g. &lt;code&gt;git update-ref refs/heads/master &amp;lt;newvalue&amp;gt; &amp;lt;oldvalue&amp;gt;&lt;/code&gt; updates the master branch head to &amp;lt;newvalue&amp;gt; only if its current value is &amp;lt;oldvalue&amp;gt;. You can specify 40 &quot;0&quot; or an empty string as &amp;lt;oldvalue&amp;gt; to make sure that the ref you are creating does not exist.</source>
          <target state="translated">3つの引数が指定された場合、&amp;lt;ref&amp;gt;の現在の値が&amp;lt;oldvalue&amp;gt;と一致することを確認した後、&amp;lt;newvalue&amp;gt;を&amp;lt;ref&amp;gt;に格納し、おそらくシンボリック参照を逆参照します。たとえば、 &lt;code&gt;git update-ref refs/heads/master &amp;lt;newvalue&amp;gt; &amp;lt;oldvalue&amp;gt;&lt;/code&gt; は、現在の値が&amp;lt;oldvalue&amp;gt;の場合にのみ、マスターブランチヘッドを&amp;lt;newvalue&amp;gt;に更新します。&amp;lt;oldvalue&amp;gt;として40 &quot;0&quot;または空の文字列を指定して、作成するrefが存在しないことを確認できます。</target>
        </trans-unit>
        <trans-unit id="4d8bb10ba2f3cfa88afc4b8727de27fb3cab8018" translate="yes" xml:space="preserve">
          <source>Given three commits &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt;, &lt;code&gt;git merge-base A B C&lt;/code&gt; will compute the merge base between &lt;code&gt;A&lt;/code&gt; and a hypothetical commit &lt;code&gt;M&lt;/code&gt;, which is a merge between &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt;. For example, with this topology:</source>
          <target state="translated">3つのコミット &lt;code&gt;A&lt;/code&gt; 、 &lt;code&gt;B&lt;/code&gt; 、および &lt;code&gt;C&lt;/code&gt; が与えられた場合、 &lt;code&gt;git merge-base A B C&lt;/code&gt; は、 &lt;code&gt;A&lt;/code&gt; と &lt;code&gt;B&lt;/code&gt; と &lt;code&gt;C&lt;/code&gt; の間のマージである架空のコミット &lt;code&gt;M&lt;/code&gt; の間のマージベースを計算します。たとえば、次のトポロジでは：</target>
        </trans-unit>
        <trans-unit id="be6c9bc842b0965134f1fb7992b74ba082dffe0f" translate="yes" xml:space="preserve">
          <source>Given two arguments, creates or updates a symbolic ref &amp;lt;name&amp;gt; to point at the given branch &amp;lt;ref&amp;gt;.</source>
          <target state="translated">2つの引数を指定すると、指定されたブランチ&amp;lt;ref&amp;gt;を指すようにシンボリックref &amp;lt;name&amp;gt;を作成または更新します。</target>
        </trans-unit>
        <trans-unit id="7cc67b58b4d717f52eb7b590f0c2ac097c83b04a" translate="yes" xml:space="preserve">
          <source>Given two arguments, stores the &amp;lt;newvalue&amp;gt; in the &amp;lt;ref&amp;gt;, possibly dereferencing the symbolic refs. E.g. &lt;code&gt;git update-ref HEAD
&amp;lt;newvalue&amp;gt;&lt;/code&gt; updates the current branch head to the new object.</source>
          <target state="translated">2つの引数を指定すると、&amp;lt;newvalue&amp;gt;を&amp;lt;ref&amp;gt;に格納し、シンボリック参照を逆参照する可能性があります。たとえば、 &lt;code&gt;git update-ref HEAD &amp;lt;newvalue&amp;gt;&lt;/code&gt; は、現在のブランチヘッドを新しいオブジェクトに更新します。</target>
        </trans-unit>
        <trans-unit id="931db30a85fe3ea596ac121ca8f065ad449ff885" translate="yes" xml:space="preserve">
          <source>Given two commits &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;git merge-base A B&lt;/code&gt; will output a commit which is reachable from both &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; through the parent relationship.</source>
          <target state="translated">2つのコミット &lt;code&gt;A&lt;/code&gt; と &lt;code&gt;B&lt;/code&gt; が与えられた場合、 &lt;code&gt;git merge-base A B&lt;/code&gt; は、 &lt;code&gt;A&lt;/code&gt; と &lt;code&gt;B&lt;/code&gt; の両方から親関係を介して到達可能なコミットを出力します。</target>
        </trans-unit>
        <trans-unit id="b0c09289dc074c18ca9574b29845f64d7cae5bc3" translate="yes" xml:space="preserve">
          <source>Gives some information about the remote &amp;lt;name&amp;gt;.</source>
          <target state="translated">リモート&amp;lt;name&amp;gt;に関する情報を提供します。</target>
        </trans-unit>
        <trans-unit id="9466e3cfe4b90da05672816c37e48d04d2b0bacb" translate="yes" xml:space="preserve">
          <source>Giving these options is an error when used with &lt;code&gt;--inetd&lt;/code&gt;; use the facility of inet daemon to achieve the same before spawning &lt;code&gt;git daemon&lt;/code&gt; if needed.</source>
          <target state="translated">&lt;code&gt;--inetd&lt;/code&gt; と一緒に使用すると、これらのオプションを指定するとエラーになります。必要に応じて &lt;code&gt;git daemon&lt;/code&gt; 前に、inetデーモンの機能を使用して同じことを達成します。</target>
        </trans-unit>
        <trans-unit id="d0ec3ae2bdc4ccb842cc8f2251da67f38c6daf5a" translate="yes" xml:space="preserve">
          <source>Glob magic is incompatible with literal magic.</source>
          <target state="translated">グローブ魔法はリテラル魔法とは相容れない。</target>
        </trans-unit>
        <trans-unit id="7427cf697be16a4ec1d916910128a59d920125e7" translate="yes" xml:space="preserve">
          <source>Glossary</source>
          <target state="translated">Glossary</target>
        </trans-unit>
        <trans-unit id="d8608c60e7a8f9d556f6c1f2aff537e2ce064bab" translate="yes" xml:space="preserve">
          <source>Go under &quot;Options&quot; in the Composer window and be sure that &quot;Word wrap&quot; is not set.</source>
          <target state="translated">コンポーザーウィンドウの「オプション」で「ワードラップ」が設定されていないことを確認してください。</target>
        </trans-unit>
        <trans-unit id="c16a49b3ce3e17532ce6e118e23e9cba92fcb23b" translate="yes" xml:space="preserve">
          <source>Graduation</source>
          <target state="translated">Graduation</target>
        </trans-unit>
        <trans-unit id="7108295a48fb4030d059842641f3ed2f16dd90ea" translate="yes" xml:space="preserve">
          <source>Grafts enables two otherwise different lines of development to be joined together by recording fake ancestry information for commits. This way you can make Git pretend the set of &lt;a href=&quot;#def_parent&quot;&gt;parents&lt;/a&gt; a &lt;a href=&quot;#def_commit&quot;&gt;commit&lt;/a&gt; has is different from what was recorded when the commit was created. Configured via the &lt;code&gt;.git/info/grafts&lt;/code&gt; file.</source>
          <target state="translated">Graftsを使用すると、コミットの偽の祖先情報を記録することにより、2つの異なる開発ラインを結合できます。このように、Git が&lt;a href=&quot;#def_commit&quot;&gt;コミット&lt;/a&gt;の&lt;a href=&quot;#def_parent&quot;&gt;親&lt;/a&gt;のセットを装うことができるので、コミットの作成時に記録されたものとは異なります。 &lt;code&gt;.git/info/grafts&lt;/code&gt; ファイルを介して構成されます。</target>
        </trans-unit>
        <trans-unit id="43addd483f6785ba3f74ca813174b30e77d7804f" translate="yes" xml:space="preserve">
          <source>Graphical alternative to git-commit</source>
          <target state="translated">git-commit のグラフィカルな代替</target>
        </trans-unit>
        <trans-unit id="7e3e6e185a96c1bddac8bacc3e22b2d8c14f25b3" translate="yes" xml:space="preserve">
          <source>Group commits based on &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt;. If no &lt;code&gt;--group&lt;/code&gt; option is specified, the default is &lt;code&gt;author&lt;/code&gt;. &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt; is one of:</source>
          <target state="translated">&lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt; に基づいてグループコミットします。 &lt;code&gt;--group&lt;/code&gt; オプションが指定されていない場合、デフォルトは作成 &lt;code&gt;author&lt;/code&gt; です。 &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt; は次のいずれかです。</target>
        </trans-unit>
        <trans-unit id="929a28d261428029e61c0f81c6161fd71ba0b2fe" translate="yes" xml:space="preserve">
          <source>Guides</source>
          <target state="translated">Guides</target>
        </trans-unit>
        <trans-unit id="7cf184f4c67ad58283ecb19349720b0cae756829" translate="yes" xml:space="preserve">
          <source>H</source>
          <target state="translated">H</target>
        </trans-unit>
        <trans-unit id="7138a51661947b19b5088da5a2bfede2876f49b9" translate="yes" xml:space="preserve">
          <source>HEAD</source>
          <target state="translated">HEAD</target>
        </trans-unit>
        <trans-unit id="f53aba93b9409d79b694657717f24476b7680a38" translate="yes" xml:space="preserve">
          <source>HEAD can also record a specific commit directly, instead of being a symref to point at the current branch. Such a state is often called &lt;code&gt;detached HEAD.&lt;/code&gt; See &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt; for details.</source>
          <target state="translated">HEADは、現在のブランチを指すsymrefではなく、特定のコミットを直接記録することもできます。そのような状態は、しばしば &lt;code&gt;detached HEAD.&lt;/code&gt; と呼ばれます。詳細については、&lt;a href=&quot;git-checkout&quot;&gt;git-checkout [1]&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="adaf1f885f4f48f7b3c5a9a2b8f4883bf35d0a07" translate="yes" xml:space="preserve">
          <source>HEAD: refers to the head of the current branch</source>
          <target state="translated">HEAD:現在のブランチのトップを指します。</target>
        </trans-unit>
        <trans-unit id="408093a274a45499420aa72e738c6e970f863fed" translate="yes" xml:space="preserve">
          <source>HEADER:</source>
          <target state="translated">HEADER:</target>
        </trans-unit>
        <trans-unit id="bd0cfe599144b530c7c9685825d1a02a5377b64e" translate="yes" xml:space="preserve">
          <source>HTML snippet to be included in the &amp;lt;head&amp;gt; section of each page. Can be set using &lt;code&gt;GITWEB_SITE_HTML_HEAD_STRING&lt;/code&gt; at build time. No default value.</source>
          <target state="translated">各ページの&amp;lt;head&amp;gt;セクションに含まれるHTMLスニペット。ビルド時に &lt;code&gt;GITWEB_SITE_HTML_HEAD_STRING&lt;/code&gt; を使用して設定できます。デフォルト値はありません。</target>
        </trans-unit>
        <trans-unit id="cc56a2df9f8b6a66c5d2a6125ab52ed375e5152b" translate="yes" xml:space="preserve">
          <source>HTTP Transport</source>
          <target state="translated">HTTPトランスポート</target>
        </trans-unit>
        <trans-unit id="d578fb1b4bb161c78cd19e50fcb2b009bf47fe3e" translate="yes" xml:space="preserve">
          <source>HTTP(S)</source>
          <target state="translated">HTTP(S)</target>
        </trans-unit>
        <trans-unit id="1ba3338bd0d397031ae85dc0347d63c94b00e5df" translate="yes" xml:space="preserve">
          <source>HTTP/1.1</source>
          <target state="translated">HTTP/1.1</target>
        </trans-unit>
        <trans-unit id="396826d4135990391d3176f7b40c9091eed2c0d3" translate="yes" xml:space="preserve">
          <source>HTTP/2</source>
          <target state="translated">HTTP/2</target>
        </trans-unit>
        <trans-unit id="80bde80e45cfc7c229d507fff6d534806b07378c" translate="yes" xml:space="preserve">
          <source>Hacking git</source>
          <target state="translated">git のハッキング</target>
        </trans-unit>
        <trans-unit id="c4b8d31a4ffcd043a96008543e3e1f5d7eaf7692" translate="yes" xml:space="preserve">
          <source>Handling Renames</source>
          <target state="translated">リネームの取り扱い</target>
        </trans-unit>
        <trans-unit id="3049c71fe9126eefc3301476201dcd8b12bbbd85" translate="yes" xml:space="preserve">
          <source>Handling of svn branches</source>
          <target state="translated">svnブランチの取り扱い</target>
        </trans-unit>
        <trans-unit id="b2bb788b2d8872820805621988d07bb34824ee87" translate="yes" xml:space="preserve">
          <source>Hard case: The changes are not the same.</source>
          <target state="translated">ハードケース。変更点が違います。</target>
        </trans-unit>
        <trans-unit id="d86493cd0a3bd6cc52c39427d91b4f3fb5f1ba0f" translate="yes" xml:space="preserve">
          <source>Has no effect if the ref does not have tracking information associated with it. All the options apart from &lt;code&gt;nobracket&lt;/code&gt; are mutually exclusive, but if used together the last option is selected.</source>
          <target state="translated">参照に関連付けられた追跡情報がない場合、効果はありません。 &lt;code&gt;nobracket&lt;/code&gt; を除くすべてのオプションは相互に排他的ですが、一緒に使用すると、最後のオプションが選択されます。</target>
        </trans-unit>
        <trans-unit id="eee44516ee4e4873c5ecfb5a6805b0f8b1007d35" translate="yes" xml:space="preserve">
          <source>Hash object as it were located at the given path. The location of file does not directly influence on the hash value, but path is used to determine what Git filters should be applied to the object before it can be placed to the object database, and, as result of applying filters, the actual blob put into the object database may differ from the given file. This option is mainly useful for hashing temporary files located outside of the working directory or files read from stdin.</source>
          <target state="translated">指定したパスにあるようにオブジェクトをハッシュします。ファイルの位置がハッシュ値に直接影響するわけではありませんが、パスはオブジェクトをオブジェクトデータベースに配置する前に Git のフィルタを適用すべきかどうかを判断するために使われます。このオプションは、主に作業ディレクトリの外にある一時ファイルや標準入力から読み込んだファイルをハッシュするのに便利です。</target>
        </trans-unit>
        <trans-unit id="100c09777204f7d9c4d9c8cca2b2ca1117efcbe1" translate="yes" xml:space="preserve">
          <source>Hash the contents as is, ignoring any input filter that would have been chosen by the attributes mechanism, including the end-of-line conversion. If the file is read from standard input then this is always implied, unless the &lt;code&gt;--path&lt;/code&gt; option is given.</source>
          <target state="translated">コンテンツをそのままハッシュし、行末変換など、属性メカニズムによって選択された入力フィルターを無視します。ファイルが標準入力から読み取られる場合、 &lt;code&gt;--path&lt;/code&gt; オプションが指定されていない限り、これは常に暗黙指定されます。</target>
        </trans-unit>
        <trans-unit id="f2ae7e4a6dc9825ef1a4868750168492eeaf6380" translate="yes" xml:space="preserve">
          <source>Have the server run as an inetd service. Implies --syslog (may be overridden with &lt;code&gt;--log-destination=&lt;/code&gt;). Incompatible with --detach, --port, --listen, --user and --group options.</source>
          <target state="translated">サーバーをinetdサービスとして実行します。--syslogを意味します（ &lt;code&gt;--log-destination=&lt;/code&gt; オーバーライドできます）。--detach、-port、-listen、-user、および--groupオプションと互換性がありません。</target>
        </trans-unit>
        <trans-unit id="db301d2890ccaa14dc974751b62b359a359b6b5c" translate="yes" xml:space="preserve">
          <source>He also uses a set of temporary branches (&quot;topic branches&quot;), each containing a logical grouping of patches.</source>
          <target state="translated">また、彼は一時的なブランチ (「トピックブランチ」)のセットを使用しており、それぞれがパッチの論理的なグループ化を含んでいます。</target>
        </trans-unit>
        <trans-unit id="c983e9a4d9daf24f5efac3a67c8f6c12bda32744" translate="yes" xml:space="preserve">
          <source>He uses two public branches:</source>
          <target state="translated">彼は2つの公的なブランチを使用しています。</target>
        </trans-unit>
        <trans-unit id="08dac5b0781534f17eedb09bc82379faeed11d4a" translate="yes" xml:space="preserve">
          <source>Header lines start with &quot;#&quot; and are added in response to specific command line arguments. Parsers should ignore headers they don&amp;rsquo;t recognize.</source>
          <target state="translated">ヘッダー行は「＃」で始まり、特定のコマンドライン引数に応じて追加されます。パーサーは、認識しないヘッダーを無視する必要があります。</target>
        </trans-unit>
        <trans-unit id="6f7a484a67443c5c4893cfcebc8516ecb7a4f1a2" translate="yes" xml:space="preserve">
          <source>Help parsing or adding &lt;code&gt;trailers&lt;/code&gt; lines, that look similar to RFC 822 e-mail headers, at the end of the otherwise free-form part of a commit message.</source>
          <target state="translated">RFC 822電子メールヘッダーに似た &lt;code&gt;trailers&lt;/code&gt; 行の解析または追加を支援します。これは、コミットメッセージのその他の自由形式の部分の最後にあります。</target>
        </trans-unit>
        <trans-unit id="f07e99c3fb43a6bcfb5e09ad2c991cc9571165ae" translate="yes" xml:space="preserve">
          <source>Helper programs to interact with remote repositories</source>
          <target state="translated">リモートリポジトリと対話するためのヘルパープログラム</target>
        </trans-unit>
        <trans-unit id="d7f00958253572e7e593fd3637f7f812370db1d4" translate="yes" xml:space="preserve">
          <source>Helper to store credentials on disk</source>
          <target state="translated">ディスクに資格情報を保存するためのヘルパー</target>
        </trans-unit>
        <trans-unit id="91ab6264d347386bb003d96ff4f148c65df714a3" translate="yes" xml:space="preserve">
          <source>Helper to temporarily store passwords in memory</source>
          <target state="translated">パスワードを一時的にメモリに保存するヘルパー</target>
        </trans-unit>
        <trans-unit id="f8801cb816506b471cd751bc46c3d753c8b27a46" translate="yes" xml:space="preserve">
          <source>Hence</source>
          <target state="translated">Hence</target>
        </trans-unit>
        <trans-unit id="8286249a7e764f5f9777c2fc17e5230ccc1ef5fe" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is any of the commit specification expressions also accepted by &lt;code&gt;from&lt;/code&gt; (see above).</source>
          <target state="translated">ここで &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; は、 &lt;code&gt;from&lt;/code&gt; でも受け入れられるコミット仕様式のいずれかです（上記を参照）。</target>
        </trans-unit>
        <trans-unit id="3fb766f6c8298c39110428f8565787238a736366" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is any of the following:</source>
          <target state="translated">ここで &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; は次のいずれかです。</target>
        </trans-unit>
        <trans-unit id="85bca9b0f87b55d545a8c945215b23dd3bdbffcb" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt; can be either a mark reference (&lt;code&gt;:&amp;lt;idnum&amp;gt;&lt;/code&gt;) set by a prior &lt;code&gt;blob&lt;/code&gt; command, or a full 40-byte SHA-1 of an existing Git blob object.</source>
          <target state="translated">ここで &lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt; は、前の &lt;code&gt;blob&lt;/code&gt; コマンドによって設定されたマーク参照（ &lt;code&gt;:&amp;lt;idnum&amp;gt;&lt;/code&gt; ）、または既存のGit blobオブジェクトの完全な40バイトのSHA-1のいずれかです。</target>
        </trans-unit>
        <trans-unit id="3f53683a6742f0030e51cf7120f8e28dba9865c5" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; is the person&amp;rsquo;s display name (for example &amp;ldquo;Com M Itter&amp;rdquo;) and &lt;code&gt;&amp;lt;email&amp;gt;&lt;/code&gt; is the person&amp;rsquo;s email address (&amp;ldquo;cm@example.com&amp;rdquo;). &lt;code&gt;LT&lt;/code&gt; and &lt;code&gt;GT&lt;/code&gt; are the literal less-than (\x3c) and greater-than (\x3e) symbols. These are required to delimit the email address from the other fields in the line. Note that &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;email&amp;gt;&lt;/code&gt; are free-form and may contain any sequence of bytes, except &lt;code&gt;LT&lt;/code&gt;, &lt;code&gt;GT&lt;/code&gt; and &lt;code&gt;LF&lt;/code&gt;. &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; is typically UTF-8 encoded.</source>
          <target state="translated">ここで、 &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; は個人の表示名（たとえば、「Com M Itter」）で、 &lt;code&gt;&amp;lt;email&amp;gt;&lt;/code&gt; は個人のメールアドレス（「cm@example.com」）です。 &lt;code&gt;LT&lt;/code&gt; および &lt;code&gt;GT&lt;/code&gt; は、リテラルの小なり（\ x3c）および大なり（\ x3e）記号です。これらは、行の他のフィールドから電子メールアドレスを区切るために必要です。ことを注意 &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; と &lt;code&gt;&amp;lt;email&amp;gt;&lt;/code&gt; 自由な形式であり、除き、任意のバイト配列を含んでいてもよい &lt;code&gt;LT&lt;/code&gt; 、 &lt;code&gt;GT&lt;/code&gt; および &lt;code&gt;LF&lt;/code&gt; 。 &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; は通常UTF-8でエンコードされています。</target>
        </trans-unit>
        <trans-unit id="88e3e34bac3d333854c449d8638faee3f973bc68" translate="yes" xml:space="preserve">
          <source>Here actual project root is passed to gitweb via &lt;code&gt;GITWEB_PROJECT_ROOT&lt;/code&gt; environment variable from a web server, so you need to put the following line in gitweb configuration file (&lt;code&gt;/etc/gitweb.conf&lt;/code&gt; in above example):</source>
          <target state="translated">ここでは、実際のプロジェクトのルートを経由してgitwebに渡され &lt;code&gt;GITWEB_PROJECT_ROOT&lt;/code&gt; の Webサーバからの環境変数、あなたはgitwebの設定ファイルに（次の行を配置する必要があり &lt;code&gt;/etc/gitweb.conf&lt;/code&gt; 上記の例では）：</target>
        </trans-unit>
        <trans-unit id="87d852c017173b91ce004ba4ee55c454ec44074f" translate="yes" xml:space="preserve">
          <source>Here again it is a good point to take a pause.</source>
          <target state="translated">ここでもまた、小休止のポイントになります。</target>
        </trans-unit>
        <trans-unit id="9d560d4da9e941f0111865584d812ed4b996ba31" translate="yes" xml:space="preserve">
          <source>Here are a handful of examples using the Loeliger illustration above, with each step in the notation&amp;rsquo;s expansion and selection carefully spelt out:</source>
          <target state="translated">上記のLoeligerの図を使用したいくつかの例を以下に示します。表記法の拡張と選択の各ステップは慎重に記述されています。</target>
        </trans-unit>
        <trans-unit id="917cc5ec6b02db542b24a5b6455b2e756b18d73b" translate="yes" xml:space="preserve">
          <source>Here are some example specifications:</source>
          <target state="translated">仕様の一例をご紹介します。</target>
        </trans-unit>
        <trans-unit id="3a6c1665b5306569c28a748694fd4e1b1e7a55db" translate="yes" xml:space="preserve">
          <source>Here are some hints on how to successfully submit patches inline using various mailers.</source>
          <target state="translated">ここでは、様々なメーラーを使ってパッチをうまくインラインで送信する方法のヒントを紹介します。</target>
        </trans-unit>
        <trans-unit id="1510576755c083f75778b41e3e15db4ef8738ed9" translate="yes" xml:space="preserve">
          <source>Here are some of the scripts that simplify all this even further.</source>
          <target state="translated">これをさらに単純化してくれるスクリプトをいくつかご紹介します。</target>
        </trans-unit>
        <trans-unit id="e7b17934614eee2f77ca3149426accc7b6e72d44" translate="yes" xml:space="preserve">
          <source>Here are the rules regarding the &quot;flags&quot; that you should follow when you are scripting Git:</source>
          <target state="translated">ここでは、Git をスクリプト化する際に守るべき「フラグ」に関するルールを紹介します。</target>
        </trans-unit>
        <trans-unit id="04cdec1fa8a31abdd551dc359504457bc39d207b" translate="yes" xml:space="preserve">
          <source>Here is a hypothetical usage of the Trace2 API showing the intended usage (without worrying about the actual Git details).</source>
          <target state="translated">ここでは、Trace2 API の仮想的な使用法を示しています (実際の Git の詳細は気にせず)。</target>
        </trans-unit>
        <trans-unit id="ffd38e59dd005a380c8a8570731f44b027a45fba" translate="yes" xml:space="preserve">
          <source>Here is a list of the facilities provided by this option parser.</source>
          <target state="translated">以下に、このオプションパーサーが提供する機能の一覧を示します。</target>
        </trans-unit>
        <trans-unit id="e4035106d997a5f9ffd025f7ed0bd5862edf3733" translate="yes" xml:space="preserve">
          <source>Here is a picture that illustrates how various pieces fit together:</source>
          <target state="translated">様々なピースがどのように組み合わされているかを説明した図がこちらです。</target>
        </trans-unit>
        <trans-unit id="303a3029ebdf1756e031ccbacc8dc586c90ed37d" translate="yes" xml:space="preserve">
          <source>Here is an ASCII art by Jon Loeliger that illustrates how various &lt;code&gt;diff-*&lt;/code&gt; commands compare things.</source>
          <target state="translated">以下は、Jon &lt;code&gt;diff-*&lt;/code&gt; よるASCIIアートで、さまざまなdiff- *コマンドがどのように比較するかを示しています。</target>
        </trans-unit>
        <trans-unit id="a1af358ae94ab7cd9ed6d1b4e51b99fcacedf212" translate="yes" xml:space="preserve">
          <source>Here is an example of a work-flow used by Andreas Ericsson:</source>
          <target state="translated">ここでは、Andreas Ericsson氏が使用しているワークフローの一例を紹介します。</target>
        </trans-unit>
        <trans-unit id="186fb29b724fc88890a2b738e2f88d967cca2e57" translate="yes" xml:space="preserve">
          <source>Here is an example script that comes slightly modified from a real world script used by Junio Hamano &lt;a href=&quot;#4&quot;&gt;[4]&lt;/a&gt;.</source>
          <target state="translated">以下は、浜野純夫が使用した実際のスクリプトから少し変更したスクリプトの例です&lt;a href=&quot;#4&quot;&gt;[4]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ea2d28e72cba49a8087ea617856210e85cc4631a" translate="yes" xml:space="preserve">
          <source>Here is an illustration, by Jon Loeliger. Both commit nodes B and C are parents of commit node A. Parent commits are ordered left-to-right.</source>
          <target state="translated">これはJon Loeliger氏によるイラストです。コミットノードBとCは両方ともコミットノードAの親です。親コミットは左から右へ順番に並べられます。</target>
        </trans-unit>
        <trans-unit id="01a0e7181fc0932a87393a13bfb324333ce2de29" translate="yes" xml:space="preserve">
          <source>Here is how you would transplant a topic branch based on one branch to another, to pretend that you forked the topic branch from the latter branch, using &lt;code&gt;rebase --onto&lt;/code&gt;.</source>
          <target state="translated">あるブランチに基づいてトピックブランチを別のブランチに移植し、 &lt;code&gt;rebase --onto&lt;/code&gt; を使用して、後者のブランチからトピックブランチを分岐したふりをする方法を次に示します。</target>
        </trans-unit>
        <trans-unit id="213d54b0bbf3a7f7afa040a26967e9f565627a3c" translate="yes" xml:space="preserve">
          <source>Here is what Ingo Molnar says about that &lt;a href=&quot;#7&quot;&gt;[7]&lt;/a&gt;:</source>
          <target state="translated">Ingo Molnarがそのことについて次のように述べています&lt;a href=&quot;#7&quot;&gt;[7]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0ace4715fac22315364196a248067a261a46ae73" translate="yes" xml:space="preserve">
          <source>Here usually &lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt; must be either a mark reference (&lt;code&gt;:&amp;lt;idnum&amp;gt;&lt;/code&gt;) set by a prior &lt;code&gt;blob&lt;/code&gt; command, or a full 40-byte SHA-1 of an existing Git blob object. If &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; is &lt;code&gt;040000`&lt;/code&gt; then &lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt; must be the full 40-byte SHA-1 of an existing Git tree object or a mark reference set with &lt;code&gt;--import-marks&lt;/code&gt;.</source>
          <target state="translated">ここで通常 &lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt; は、前の &lt;code&gt;blob&lt;/code&gt; コマンドによって設定されたマーク参照（ &lt;code&gt;:&amp;lt;idnum&amp;gt;&lt;/code&gt; ）、または既存のGit blobオブジェクトの完全な40バイトのSHA-1のいずれかでなければなりません。場合 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; である &lt;code&gt;040000`&lt;/code&gt; その後 &lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt; 完全な40バイトのSHA-1、既存のGitツリーオブジェクトまたはのマークの基準セットのなければならない &lt;code&gt;--import-marks&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2beb401ec57f79ec07666eedc396bc9251ab532b" translate="yes" xml:space="preserve">
          <source>Here we use a &lt;code&gt;test.sh&lt;/code&gt; custom script. In this script, if &lt;code&gt;make&lt;/code&gt; fails, we skip the current commit. &lt;code&gt;check_test_case.sh&lt;/code&gt; should &lt;code&gt;exit 0&lt;/code&gt; if the test case passes, and &lt;code&gt;exit 1&lt;/code&gt; otherwise.</source>
          <target state="translated">ここでは、 &lt;code&gt;test.sh&lt;/code&gt; カスタムスクリプトを使用します。このスクリプトでは、 &lt;code&gt;make&lt;/code&gt; が失敗した場合、現在のコミットをスキップします。 &lt;code&gt;check_test_case.sh&lt;/code&gt; は、テストケースに合格すると &lt;code&gt;exit 0&lt;/code&gt; で &lt;code&gt;exit 1&lt;/code&gt; 、そうでなければ1で終了します。</target>
        </trans-unit>
        <trans-unit id="4c65aa59e4c90d1dad65ae558dc71a05ca72658c" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example to make it more clear:</source>
          <target state="translated">より明確にするための例を次に示します。</target>
        </trans-unit>
        <trans-unit id="f876057ef41997694291fae2bce19c94e2c8be27" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s where things get tricky and more specific. The pruning feature doesn&amp;rsquo;t actually care about branches, instead it&amp;rsquo;ll prune local &amp;lt;&amp;rarr; remote-references as a function of the refspec of the remote (see &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; and &lt;a href=&quot;#CRTB&quot;&gt;CONFIGURED REMOTE-TRACKING BRANCHES&lt;/a&gt; above).</source>
          <target state="translated">ここでは、物事がトリッキーでより具体的になります。プルーニング機能は実際にはブランチを気にしませんが、代わりにローカルの&amp;lt;&amp;rarr;リモート参照をリモートのrefspecの関数としてプルーニングします（上記の &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; および&lt;a href=&quot;#CRTB&quot;&gt;CONFIGURED REMOTE-TRACKING BRANCHESを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="6e909debf7e14a75a50a127741701f06b0380ed1" translate="yes" xml:space="preserve">
          <source>Here, order matters, so the negative patterns are overridden by the positive patterns that appear lower in the file.</source>
          <target state="translated">ここでは、順序が重要なので、負のパターンは、ファイルの下位に表示される正のパターンによって上書きされます。</target>
        </trans-unit>
        <trans-unit id="e1c70b8a098f60c6e63dbb08701031f93ea135ff" translate="yes" xml:space="preserve">
          <source>Here, take a moment to look at the contents of &lt;code&gt;hello&lt;/code&gt;, and notice how they don&amp;rsquo;t contain the work we just did in &lt;code&gt;mybranch&lt;/code&gt; &amp;mdash; because that work hasn&amp;rsquo;t happened in the &lt;code&gt;master&lt;/code&gt; branch at all. Then do</source>
          <target state="translated">ここで、 &lt;code&gt;hello&lt;/code&gt; の内容を見てみましょう &lt;code&gt;mybranch&lt;/code&gt; で実行したばかりの作業が含まれていないことに注目してください。その作業は &lt;code&gt;master&lt;/code&gt; ブランチではまったく発生していないためです。それから</target>
        </trans-unit>
        <trans-unit id="04fe7010553ef714229d324da3944b7bef8ef4bf" translate="yes" xml:space="preserve">
          <source>Here, the merge commits &lt;code&gt;O&lt;/code&gt; and &lt;code&gt;P&lt;/code&gt; contribute extra noise, as they did not actually contribute a change to &lt;code&gt;file.txt&lt;/code&gt;. They only merged a topic that was based on an older version of &lt;code&gt;file.txt&lt;/code&gt;. This is a common issue in repositories using a workflow where many contributors work in parallel and merge their topic branches along a single trunk: manu unrelated merges appear in the &lt;code&gt;--full-history&lt;/code&gt; results.</source>
          <target state="translated">ここで、マージコミット &lt;code&gt;O&lt;/code&gt; と &lt;code&gt;P&lt;/code&gt; は、実際には &lt;code&gt;file.txt&lt;/code&gt; に変更を加えなかったため、余分なノイズを引き起こします。古いバージョンの &lt;code&gt;file.txt&lt;/code&gt; に基づいたトピックのみをマージしました。これは、多くの寄稿者が並行して作業し、トピックブランチを単一のトランクに沿ってマージするワークフローを使用するリポジトリの一般的な問題です &lt;code&gt;--full-history&lt;/code&gt; 無関係なマージが--full-historyの結果に表示されます。</target>
        </trans-unit>
        <trans-unit id="6b3155f9e3fff9d9745dcec6fcafe4ea22b8525d" translate="yes" xml:space="preserve">
          <source>Here, the merge commits &lt;code&gt;R&lt;/code&gt; and &lt;code&gt;N&lt;/code&gt; are included because they pulled the commits &lt;code&gt;X&lt;/code&gt; and &lt;code&gt;R&lt;/code&gt; into the base branch, respectively. These merges are the reason the commits &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; do not appear in the default history.</source>
          <target state="translated">ここでは、コミット &lt;code&gt;X&lt;/code&gt; と &lt;code&gt;R&lt;/code&gt; をそれぞれベースブランチにプルしたため、マージコミット &lt;code&gt;R&lt;/code&gt; と &lt;code&gt;N&lt;/code&gt; が含まれています。これらのマージは、コミット &lt;code&gt;A&lt;/code&gt; と &lt;code&gt;B&lt;/code&gt; がデフォルトの履歴に表示されない理由です。</target>
        </trans-unit>
        <trans-unit id="d77fbd432531fa44ab380c6d115f43ea2fbe9fc8" translate="yes" xml:space="preserve">
          <source>Here, we just added another line to &lt;code&gt;hello&lt;/code&gt;, and we used a shorthand for doing both &lt;code&gt;git update-index hello&lt;/code&gt; and &lt;code&gt;git commit&lt;/code&gt; by just giving the filename directly to &lt;code&gt;git commit&lt;/code&gt;, with an &lt;code&gt;-i&lt;/code&gt; flag (it tells Git to &lt;code&gt;include&lt;/code&gt; that file in addition to what you have done to the index file so far when making the commit). The &lt;code&gt;-m&lt;/code&gt; flag is to give the commit log message from the command line.</source>
          <target state="translated">ここでは、 &lt;code&gt;hello&lt;/code&gt; に別の行を追加しました。 &lt;code&gt;git update-index hello&lt;/code&gt; &lt;code&gt;-i&lt;/code&gt; フラグを付けてファイル名を &lt;code&gt;git commit&lt;/code&gt; に直接指定するだけで、git update-index helloと &lt;code&gt;git commit&lt;/code&gt; の両方を簡略化して使用しました（これにより、Gitにそのファイルを &lt;code&gt;include&lt;/code&gt; ように指示します）これまでにコミットを行うときにインデックスファイルに対して行ったことに加えて）。 &lt;code&gt;-m&lt;/code&gt; フラグは、コマンドラインからログメッセージをコミット与えることです。</target>
        </trans-unit>
        <trans-unit id="c1304382231014b423d405b863d67d13d9195107" translate="yes" xml:space="preserve">
          <source>Here, we see that the commits A and C (marked with &lt;code&gt;-&lt;/code&gt;) can be dropped from your &lt;code&gt;topic&lt;/code&gt; branch when you rebase it on top of &lt;code&gt;origin/master&lt;/code&gt;, while the commit B (marked with &lt;code&gt;+&lt;/code&gt;) still needs to be kept so that it will be sent to be applied to &lt;code&gt;origin/master&lt;/code&gt;.</source>
          <target state="translated">ここで、コミットAおよびC（ &lt;code&gt;-&lt;/code&gt; でマークされている）を &lt;code&gt;origin/master&lt;/code&gt; の上にリベースすると、 &lt;code&gt;topic&lt;/code&gt; ブランチからドロップできますが、コミットB（ &lt;code&gt;+&lt;/code&gt; でマークされている）は、 &lt;code&gt;origin/master&lt;/code&gt; に適用するために送信されます。</target>
        </trans-unit>
        <trans-unit id="0cd618d5ab553d5bba621718fb5b54666be9377a" translate="yes" xml:space="preserve">
          <source>High-level commands (porcelain)</source>
          <target state="translated">上位コマンド(磁器</target>
        </trans-unit>
        <trans-unit id="1ac4e7d9472a79a55ebc3b6988fb3cc4f954a3f4" translate="yes" xml:space="preserve">
          <source>High-level operations such as &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; and &lt;a href=&quot;git-restore&quot;&gt;git-restore[1]&lt;/a&gt; work by moving data between the working tree, the index, and the object database. Git provides low-level operations which perform each of these steps individually.</source>
          <target state="translated">&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt;や&lt;a href=&quot;git-restore&quot;&gt;git-restore [1]&lt;/a&gt;などの高レベルの操作は、作業ツリー、インデックス、オブジェクトデータベースの間でデータを移動することによって機能します。Gitは、これらの各ステップを個別に実行する低レベルの操作を提供します。</target>
        </trans-unit>
        <trans-unit id="c1ce0c926615015cc35af4d00f9f659a79fd9f67" translate="yes" xml:space="preserve">
          <source>Higher level SCMs may provide and manage additional information in the &lt;code&gt;$GIT_DIR&lt;/code&gt;.</source>
          <target state="translated">より高いレベルのSCMは、 &lt;code&gt;$GIT_DIR&lt;/code&gt; で追加情報を提供および管理する場合があります。</target>
        </trans-unit>
        <trans-unit id="dd055ea7ea783c3a5765e06b74c033615ebf91a1" translate="yes" xml:space="preserve">
          <source>Highest and slowest compression level. You can specify any number from 1 to 9 to adjust compression speed and ratio.</source>
          <target state="translated">圧縮レベルの最高値と最遅値を設定します。1~9までの任意の数値を指定して、圧縮速度と比率を調整できます。</target>
        </trans-unit>
        <trans-unit id="dca5de829f06af308665d596314f33baa6a08d8b" translate="yes" xml:space="preserve">
          <source>Highlight changed words using only colors. Implies &lt;code&gt;--color&lt;/code&gt;.</source>
          <target state="translated">変更された単語を色だけで強調表示します。意味 &lt;code&gt;--color&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d265b329d8480dd12ed84fd1552194f9ed45b640" translate="yes" xml:space="preserve">
          <source>Highlight whitespace errors in the &lt;code&gt;context&lt;/code&gt;, &lt;code&gt;old&lt;/code&gt; or &lt;code&gt;new&lt;/code&gt; lines of the diff. Multiple values are separated by comma, &lt;code&gt;none&lt;/code&gt; resets previous values, &lt;code&gt;default&lt;/code&gt; reset the list to &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;all&lt;/code&gt; is a shorthand for &lt;code&gt;old,new,context&lt;/code&gt;. The whitespace errors are colored with &lt;code&gt;color.diff.whitespace&lt;/code&gt;. The command line option &lt;code&gt;--ws-error-highlight=&amp;lt;kind&amp;gt;&lt;/code&gt; overrides this setting.</source>
          <target state="translated">エラー空白を強調表示し &lt;code&gt;context&lt;/code&gt; 、 &lt;code&gt;old&lt;/code&gt; または &lt;code&gt;new&lt;/code&gt; 差分の行。複数の値はカンマで区切られ、 &lt;code&gt;none&lt;/code&gt; 以前の値をリセットしない、 &lt;code&gt;default&lt;/code&gt; にリストをリセット &lt;code&gt;new&lt;/code&gt; および &lt;code&gt;all&lt;/code&gt; の省略形です &lt;code&gt;old,new,context&lt;/code&gt; 。空白エラーは &lt;code&gt;color.diff.whitespace&lt;/code&gt; で色分けされます。コマンドラインオプション &lt;code&gt;--ws-error-highlight=&amp;lt;kind&amp;gt;&lt;/code&gt; はこの設定を上書きします。</target>
        </trans-unit>
        <trans-unit id="ad64982f5f47504010208292cc60b059ddb2341b" translate="yes" xml:space="preserve">
          <source>Highlight whitespace errors in the &lt;code&gt;context&lt;/code&gt;, &lt;code&gt;old&lt;/code&gt; or &lt;code&gt;new&lt;/code&gt; lines of the diff. Multiple values are separated by comma, &lt;code&gt;none&lt;/code&gt; resets previous values, &lt;code&gt;default&lt;/code&gt; reset the list to &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;all&lt;/code&gt; is a shorthand for &lt;code&gt;old,new,context&lt;/code&gt;. When this option is not given, and the configuration variable &lt;code&gt;diff.wsErrorHighlight&lt;/code&gt; is not set, only whitespace errors in &lt;code&gt;new&lt;/code&gt; lines are highlighted. The whitespace errors are colored with &lt;code&gt;color.diff.whitespace&lt;/code&gt;.</source>
          <target state="translated">エラー空白を強調表示し &lt;code&gt;context&lt;/code&gt; 、 &lt;code&gt;old&lt;/code&gt; または &lt;code&gt;new&lt;/code&gt; 差分の行。複数の値はカンマで区切られ、 &lt;code&gt;none&lt;/code&gt; 以前の値をリセットしない、 &lt;code&gt;default&lt;/code&gt; にリストをリセット &lt;code&gt;new&lt;/code&gt; および &lt;code&gt;all&lt;/code&gt; の省略形です &lt;code&gt;old,new,context&lt;/code&gt; 。このオプションが指定されておらず、構成変数 &lt;code&gt;diff.wsErrorHighlight&lt;/code&gt; が設定されていない場合、 &lt;code&gt;new&lt;/code&gt; 行の空白エラーのみが強調表示されます。空白エラーは &lt;code&gt;color.diff.whitespace&lt;/code&gt; で色分けされます。</target>
        </trans-unit>
        <trans-unit id="dd523af5eca7a4658a007786700bef0bcb653aea" translate="yes" xml:space="preserve">
          <source>Historical options for selecting a type specifier. Prefer instead &lt;code&gt;--type&lt;/code&gt; (see above).</source>
          <target state="translated">タイプ指定子を選択するための履歴オプション。代わりに &lt;code&gt;--type&lt;/code&gt; を使用してください（上記を参照）。</target>
        </trans-unit>
        <trans-unit id="d2946930a6bea40f3723a867347d5f13a7e8b511" translate="yes" xml:space="preserve">
          <source>Historically we did not allow binary patch applied without an explicit permission from the user, and this flag was the way to do so. Currently we always allow binary patch application, so this is a no-op.</source>
          <target state="translated">歴史的には、ユーザーからの明示的な許可なしにバイナリパッチの適用を許可していませんでしたが、このフラグはそのようにしていました。現在は常にバイナリパッチの適用を許可していますので、このフラグは無効です。</target>
        </trans-unit>
        <trans-unit id="90ccd6497400b5576aeca1bd94af74aae1e0a250" translate="yes" xml:space="preserve">
          <source>History</source>
          <target state="translated">History</target>
        </trans-unit>
        <trans-unit id="7f2999a0b05d570915b660b4e452265d6ec70628" translate="yes" xml:space="preserve">
          <source>History Simplification</source>
          <target state="translated">歴史の単純化</target>
        </trans-unit>
        <trans-unit id="bcdd29839bed9103f5dae5291b4dd975d75a9cc7" translate="yes" xml:space="preserve">
          <source>History traversing commands such as &lt;code&gt;git log&lt;/code&gt; operate on a set of commits, not just a single commit.</source>
          <target state="translated">&lt;code&gt;git log&lt;/code&gt; などの履歴トラバースコマンドは、単一のコミットだけでなく、一連のコミットで動作します。</target>
        </trans-unit>
        <trans-unit id="173bd843bbaf623a85e5a648a6a9c500533027fc" translate="yes" xml:space="preserve">
          <source>Honor textconv filter settings.</source>
          <target state="translated">textconvフィルターの設定を尊重してください。</target>
        </trans-unit>
        <trans-unit id="be308a87ab32a83ddd6a199c65b0dc7cb4884727" translate="yes" xml:space="preserve">
          <source>Hook for submit</source>
          <target state="translated">提出用フック</target>
        </trans-unit>
        <trans-unit id="4bd8f3f03a576b2088bd73a2339d07fca1de805d" translate="yes" xml:space="preserve">
          <source>Hooks</source>
          <target state="translated">Hooks</target>
        </trans-unit>
        <trans-unit id="99dc1a330d0acc7fd52ca441a6ce9f9284dba47c" translate="yes" xml:space="preserve">
          <source>Hooks are customization scripts used by various Git commands. A handful of sample hooks are installed when &lt;code&gt;git init&lt;/code&gt; is run, but all of them are disabled by default. To enable, the &lt;code&gt;.sample&lt;/code&gt; suffix has to be removed from the filename by renaming. Read &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt; for more details about each hook. This directory is ignored if $GIT_COMMON_DIR is set and &quot;$GIT_COMMON_DIR/hooks&quot; will be used instead.</source>
          <target state="translated">フックは、さまざまなGitコマンドで使用されるカスタマイズスクリプトです。 &lt;code&gt;git init&lt;/code&gt; を実行すると、いくつかのサンプルフックがインストールされますが、デフォルトではすべて無効になっています。有効にするには、名前を変更して &lt;code&gt;.sample&lt;/code&gt; サフィックスをファイル名から削除する必要があります。読み取り&lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt;各フックの詳細については。$ GIT_COMMON_DIRが設定されており、代わりに「$ GIT_COMMON_DIR / hooks」が使用される場合、このディレクトリは無視されます。</target>
        </trans-unit>
        <trans-unit id="06a3036cbe5b8e0ded4c91cf35d4acf2e8ad8f53" translate="yes" xml:space="preserve">
          <source>Hooks are programs you can place in a hooks directory to trigger actions at certain points in git&amp;rsquo;s execution. Hooks that don&amp;rsquo;t have the executable bit set are ignored.</source>
          <target state="translated">フックは、gitの実行の特定の時点でアクションをトリガーするためにフックディレクトリに配置できるプログラムです。実行可能ビットが設定されていないフックは無視されます。</target>
        </trans-unit>
        <trans-unit id="bf9a913e0a40d8bcbb788ae480caabb75549e706" translate="yes" xml:space="preserve">
          <source>Hooks can get their arguments via the environment, command-line arguments, and stdin. See the documentation for each hook below for details.</source>
          <target state="translated">フックは環境、コマンドライン引数、stdinを介して引数を取得することができます。詳細は以下の各フックのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="ada52d2258e33812dc48261a96d9e1bee90a02e9" translate="yes" xml:space="preserve">
          <source>Hooks for submit</source>
          <target state="translated">送信用フック</target>
        </trans-unit>
        <trans-unit id="0b25ef249acb89a2076c9e4eabf85c1464e0ce20" translate="yes" xml:space="preserve">
          <source>Hooks used by Git</source>
          <target state="translated">Git が使用するフック</target>
        </trans-unit>
        <trans-unit id="16c7452920ac3fe30578ebea0bb92b7bf8bbfaa1" translate="yes" xml:space="preserve">
          <source>Host specified as an option to all p4 commands, with &lt;code&gt;-h &amp;lt;host&amp;gt;&lt;/code&gt;. The environment variable &lt;code&gt;P4HOST&lt;/code&gt; can be used instead.</source>
          <target state="translated">&lt;code&gt;-h &amp;lt;host&amp;gt;&lt;/code&gt; を使用して、すべてのp4コマンドのオプションとして指定されたホスト。代わりに、環境変数 &lt;code&gt;P4HOST&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="e3a4f74d3860a1e7164c5016083b909a49e9f48e" translate="yes" xml:space="preserve">
          <source>Host/domain name (e.g., &lt;code&gt;example.com&lt;/code&gt; in &lt;code&gt;https://example.com/&lt;/code&gt;). This field must match between the config key and the URL. It is possible to specify a &lt;code&gt;*&lt;/code&gt; as part of the host name to match all subdomains at this level. &lt;code&gt;https://*.example.com/&lt;/code&gt; for example would match &lt;code&gt;https://foo.example.com/&lt;/code&gt;, but not &lt;code&gt;https://foo.bar.example.com/&lt;/code&gt;.</source>
          <target state="translated">ホスト/ドメイン名（たとえば、 &lt;code&gt;example.com&lt;/code&gt; で &lt;code&gt;https://example.com/&lt;/code&gt; ）。このフィールドは、構成キーとURLの間で一致する必要があります。ホスト名の一部として &lt;code&gt;*&lt;/code&gt; を指定して、このレベルのすべてのサブドメインに一致させることができます。 &lt;code&gt;https://*.example.com/&lt;/code&gt; 例えばは一致し &lt;code&gt;https://foo.example.com/&lt;/code&gt; を、ではなく &lt;code&gt;https://foo.bar.example.com/&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="62bb4be23aa04882a53a58830164455da0d43aac" translate="yes" xml:space="preserve">
          <source>How Git stores objects efficiently: pack files</source>
          <target state="translated">Git がオブジェクトを効率的に保存する方法:ファイルをパックする</target>
        </trans-unit>
        <trans-unit id="fc3082d534384228eeed70dd2356631d4f563e7e" translate="yes" xml:space="preserve">
          <source>How conflicts are presented</source>
          <target state="translated">葛藤はどのように提示されるのか</target>
        </trans-unit>
        <trans-unit id="632a7344e68629673f46b61122a8d717f4af38d1" translate="yes" xml:space="preserve">
          <source>How does the merge work?</source>
          <target state="translated">マージの仕組みを教えてください。</target>
        </trans-unit>
        <trans-unit id="ee0a93def9e459d81d86f0f444af48fed200edd7" translate="yes" xml:space="preserve">
          <source>How many HTTP requests to launch in parallel. Can be overridden by the &lt;code&gt;GIT_HTTP_MAX_REQUESTS&lt;/code&gt; environment variable. Default is 5.</source>
          <target state="translated">同時に起動するHTTPリクエストの数。 &lt;code&gt;GIT_HTTP_MAX_REQUESTS&lt;/code&gt; 環境変数によってオーバーライドできます。デフォルトは5です。</target>
        </trans-unit>
        <trans-unit id="88ba6c6b51f5b68d7988ac607f3c426807b883bb" translate="yes" xml:space="preserve">
          <source>How to best handle custom GIT_TRACE_&amp;lt;key&amp;gt; messages?</source>
          <target state="translated">カスタムGIT_TRACE_ &amp;lt;key&amp;gt;メッセージを最適に処理するにはどうすればよいですか？</target>
        </trans-unit>
        <trans-unit id="e6e1af910bb5a856e3b4ead0799265f2a1064f75" translate="yes" xml:space="preserve">
          <source>How to check out a different version of a project</source>
          <target state="translated">プロジェクトの別バージョンをチェックする方法</target>
        </trans-unit>
        <trans-unit id="d2b9978a0ab6bcc1a292a13931b1286539811f55" translate="yes" xml:space="preserve">
          <source>How to get a Git repository</source>
          <target state="translated">Gitリポジトリを取得する方法</target>
        </trans-unit>
        <trans-unit id="d7d2ba06f3721900039efaca56489e6a84b511d3" translate="yes" xml:space="preserve">
          <source>How to get a Git repository with minimal history</source>
          <target state="translated">最小限の履歴でGitリポジトリを取得する方法</target>
        </trans-unit>
        <trans-unit id="d757cda7bc3ea5053c7cf45f6afca8dbb51305c3" translate="yes" xml:space="preserve">
          <source>How to handle commits that are not empty to start and are not clean cherry-picks of any upstream commit, but which become empty after rebasing (because they contain a subset of already upstream changes). With drop (the default), commits that become empty are dropped. With keep, such commits are kept. With ask (implied by --interactive), the rebase will halt when an empty commit is applied allowing you to choose whether to drop it, edit files more, or just commit the empty changes. Other options, like --exec, will use the default of drop unless -i/--interactive is explicitly specified.</source>
          <target state="translated">開始時には空になっておらず、どのような上流のコミットでもクリーンなチェリーピックではないが、リベース後に空になってしまうコミットをどのように扱うか。drop (デフォルト)を指定すると、空になったコミットは削除されます。keep を使うと、そのようなコミットは保持されます。ask (--interactive で暗示されています)を指定すると、空のコミットが適用されたときにリベースが停止します。これにより、空のコミットを削除するか、ファイルをさらに編集するか、あるいは空の変更を単にコミットするかを選択できます。他のオプション、例えば --exec は -i/--interactive が明示的に指定されていない限り、デフォルトの drop を使います。</target>
        </trans-unit>
        <trans-unit id="6a7eba29926bb4a386242f44bbf4f12c6f691a0c" translate="yes" xml:space="preserve">
          <source>How to make a commit</source>
          <target state="translated">コミットの仕方</target>
        </trans-unit>
        <trans-unit id="a8f8fd0d0e36d30f7fbe331a10b1e8f318a5f903" translate="yes" xml:space="preserve">
          <source>How to merge</source>
          <target state="translated">マージの方法</target>
        </trans-unit>
        <trans-unit id="813e8d48c24190b471043b3ab0d44e357c5f2791" translate="yes" xml:space="preserve">
          <source>How to resolve conflicts</source>
          <target state="translated">葛藤を解決する方法</target>
        </trans-unit>
        <trans-unit id="93e750cda509aa41796eb9d7a6cb3afbf2365356" translate="yes" xml:space="preserve">
          <source>How to use bisect to find a regression</source>
          <target state="translated">二分法を使って回帰を求める方法</target>
        </trans-unit>
        <trans-unit id="c54b4ab81b97a7d870be1fb485f52b39766adb14" translate="yes" xml:space="preserve">
          <source>However &amp;mdash; it&amp;rsquo;s such a common thing to &lt;code&gt;fetch&lt;/code&gt; and then immediately &lt;code&gt;merge&lt;/code&gt;, that it&amp;rsquo;s called &lt;code&gt;git pull&lt;/code&gt;, and you can simply do</source>
          <target state="translated">ただし、 &lt;code&gt;fetch&lt;/code&gt; してすぐに &lt;code&gt;merge&lt;/code&gt; ことはよくあることです。これは &lt;code&gt;git pull&lt;/code&gt; と呼ばれ、簡単に行うことができます。</target>
        </trans-unit>
        <trans-unit id="d70de578cd37f18e0cd1ccdb7488c789f08117d4" translate="yes" xml:space="preserve">
          <source>However &amp;mdash; normally you&amp;rsquo;d never use &lt;code&gt;git write-tree&lt;/code&gt; on its own, because normally you always commit a tree into a commit object using the &lt;code&gt;git commit-tree&lt;/code&gt; command. In fact, it&amp;rsquo;s easier to not actually use &lt;code&gt;git write-tree&lt;/code&gt; on its own at all, but to just pass its result in as an argument to &lt;code&gt;git commit-tree&lt;/code&gt;.</source>
          <target state="translated">ただし、通常は常に &lt;code&gt;git commit-tree&lt;/code&gt; コマンドを使用してツリーをコミットオブジェクトにコミットするため、単独で &lt;code&gt;git write-tree&lt;/code&gt; を使用することは決してありません。実際、実際に &lt;code&gt;git write-tree&lt;/code&gt; を単独で使用するのではなく、その結果を引数として &lt;code&gt;git commit-tree&lt;/code&gt; に渡す方が簡単です。</target>
        </trans-unit>
        <trans-unit id="b251a49d303741aee81dcafea3be641705e5d2d3" translate="yes" xml:space="preserve">
          <source>However repacking the repository is necessary to improve data locality and access performance. It can also take hours on extremely large projects (especially if -f and a large --window parameter is used). Since repacking is safe to run alongside readers and writers, run the repack in the background and let it finish when it finishes. There is no reason to wait to explore your new Git project!</source>
          <target state="translated">しかし、データの局所性とアクセス性能を向上させるためには、リポジトリをリパックする必要があります。また、非常に大規模なプロジェクトでは何時間もかかることもあります (特に -f と大きな --window パラメータが使われている場合)。リパックはリーダやライタと一緒に実行しても安全なので、リパックはバックグラウンドで実行し、終了したら終了させてください。新しい Git プロジェクトの探索を待つ必要はありません。</target>
        </trans-unit>
        <trans-unit id="4b948e81d3b66aa74b95ff1de52609dbf8f7d04b" translate="yes" xml:space="preserve">
          <source>However, Git does &lt;strong&gt;not&lt;/strong&gt; (and it should not) change tags behind users back. So if somebody already got the old tag, doing a &lt;code&gt;git pull&lt;/code&gt; on your tree shouldn&amp;rsquo;t just make them overwrite the old one.</source>
          <target state="translated">ただし、Gitはユーザーの背後にあるタグを変更しませ&lt;strong&gt;ん&lt;/strong&gt;（変更しないでください）。したがって、誰かがすでに古いタグを取得している場合、ツリーで &lt;code&gt;git pull&lt;/code&gt; を実行しても、古いタグが上書きされるだけではいけません。</target>
        </trans-unit>
        <trans-unit id="774132ee5dd559ea340879a21fd99f6ff4549c5d" translate="yes" xml:space="preserve">
          <source>However, an understanding of these low-level tools can be helpful if you want to understand Git&amp;rsquo;s internals.</source>
          <target state="translated">ただし、Gitの内部について理解したい場合は、これらの低レベルのツールを理解しておくと役立ちます。</target>
        </trans-unit>
        <trans-unit id="866f600e87142f901a49d55ea62ea322295c395d" translate="yes" xml:space="preserve">
          <source>However, if the --combined-all-paths option is provided, instead of a two-line from-file/to-file you get a N+1 line from-file/to-file header, where N is the number of parents in the merge commit</source>
          <target state="translated">しかし、--combined-all-paths オプションが指定されている場合は、2 行の from-file/to-file の代わりに N+1 行の from-file/to-file ヘッダが得られます。</target>
        </trans-unit>
        <trans-unit id="24c47b91e42f0b5da2ef1b1de98db109a45643ab" translate="yes" xml:space="preserve">
          <source>However, if the current branch is an ancestor of the other&amp;mdash;​so every commit present in the current branch is already contained in the other branch&amp;mdash;​then Git just performs a &quot;fast-forward&quot;; the head of the current branch is moved forward to point at the head of the merged-in branch, without any new commits being created.</source>
          <target state="translated">ただし、現在のブランチが他のブランチの祖先である場合（つまり、現在のブランチに存在するすべてのコミットがすでに他のブランチに含まれている場合）、Gitは「早送り」を実行するだけです。現在のブランチの先頭は、新しいコミットが作成されることなく、マージされたブランチの先頭を指すように前方に移動されます。</target>
        </trans-unit>
        <trans-unit id="38320aec0b4074b6ba1fc6f9446c9d65a3296509" translate="yes" xml:space="preserve">
          <source>However, if the file is absent from the tree of some commit, a simple &lt;code&gt;rm filename&lt;/code&gt; will fail for that tree and commit. Thus you may instead want to use &lt;code&gt;rm -f filename&lt;/code&gt; as the script.</source>
          <target state="translated">ただし、ファイルが一部のコミットのツリーに存在しない場合、単純な &lt;code&gt;rm filename&lt;/code&gt; はそのツリーで失敗し、コミットされます。したがって、代わりに &lt;code&gt;rm -f filename&lt;/code&gt; をスクリプトとして使用することもできます。</target>
        </trans-unit>
        <trans-unit id="083d51e29026b4e1a08bfd658353fe31999e3907" translate="yes" xml:space="preserve">
          <source>However, if you decide to jump to a new version, or check out somebody else&amp;rsquo;s version, or just restore a previous tree, you&amp;rsquo;d populate your index file with read-tree, and then you need to check out the result with</source>
          <target state="translated">ただし、新しいバージョンにジャンプしたり、他の誰かのバージョンをチェックアウトしたり、以前のツリーを復元したりする場合は、インデックスファイルにread-treeを入力し、結果をチェックアウトする必要があります。</target>
        </trans-unit>
        <trans-unit id="d73cbcd65f07eabb528955f0d408caeaef9ec132" translate="yes" xml:space="preserve">
          <source>However, if you have local changes in the working tree that would be overwritten by this merge, &lt;code&gt;git read-tree&lt;/code&gt; will refuse to run to prevent your changes from being lost.</source>
          <target state="translated">ただし、このマージによって上書きされる作業ツリーのローカル変更がある場合、変更が失われるのを防ぐために、 &lt;code&gt;git read-tree&lt;/code&gt; は実行を拒否します。</target>
        </trans-unit>
        <trans-unit id="0f801baa64ce652ffc6d36336f6a234c862e64a0" translate="yes" xml:space="preserve">
          <source>However, if you prefer to keep the history in mywork a simple series of commits without any merges, you may instead choose to use &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt;:</source>
          <target state="translated">ただし、履歴をmyworkにマージせずに単純な一連のコミットを保持したい場合は、代わりに&lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]の&lt;/a&gt;使用を選択できます。</target>
        </trans-unit>
        <trans-unit id="6a9f204773ec4f6bc12691a9ec080236d437d186" translate="yes" xml:space="preserve">
          <source>However, if you really only want to replace the line for the default proxy, i.e. the one without a &quot;for &amp;hellip;​&quot; postfix, do something like this:</source>
          <target state="translated">ただし、デフォルトのプロキシの行のみを置き換えたい場合、つまり「for&amp;hellip;」接尾辞のない行は、次のようにします。</target>
        </trans-unit>
        <trans-unit id="fe54b4a5cce25da95a527e803024815678af4c5c" translate="yes" xml:space="preserve">
          <source>However, if you skip a commit adjacent to the one you are looking for, Git will be unable to tell exactly which of those commits was the first bad one.</source>
          <target state="translated">しかし、探しているコミットに隣接しているコミットをスキップしてしまうと、Git はどのコミットが最初の悪いコミットだったのかを正確に知ることができません。</target>
        </trans-unit>
        <trans-unit id="e9adef201cc69834664c04ac9c044e6acc3b8daa" translate="yes" xml:space="preserve">
          <source>However, it is not necessary to create branches in p4 to be able to use them like branches. Because it is difficult to infer branch relationships automatically, a Git configuration setting &lt;code&gt;git-p4.branchList&lt;/code&gt; can be used to explicitly identify branch relationships. It is a list of &quot;source:destination&quot; pairs, like a simple p4 branch specification, where the &quot;source&quot; and &quot;destination&quot; are the path elements in the p4 repository. The example above relied on the presence of the p4 branch. Without p4 branches, the same result will occur with:</source>
          <target state="translated">ただし、ブランチのように使用できるようにするためにp4でブランチを作成する必要はありません。ブランチの関係を自動的に推測することは難しいため、Git構成設定 &lt;code&gt;git-p4.branchList&lt;/code&gt; を使用して、ブランチの関係を明示的に識別することができます。これは、単純なp4ブランチ仕様のような「source：destination」ペアのリストです。「source」と「destination」は、p4リポジトリ内のパス要素です。上記の例は、p4ブランチの存在に依存しています。 p4ブランチがない場合、同じ結果が次のように発生します。</target>
        </trans-unit>
        <trans-unit id="c71bf4b100c16d667a048d4524ffef40edf8598e" translate="yes" xml:space="preserve">
          <source>However, one may also want to specify other diff driver attributes. For example, you might want to use &lt;code&gt;textconv&lt;/code&gt; to convert postscript files to an ASCII representation for human viewing, but otherwise treat them as binary files. You cannot specify both &lt;code&gt;-diff&lt;/code&gt; and &lt;code&gt;diff=ps&lt;/code&gt; attributes. The solution is to use the &lt;code&gt;diff.*.binary&lt;/code&gt; config option:</source>
          <target state="translated">ただし、他の差分ドライバー属性を指定することもできます。たとえば、 &lt;code&gt;textconv&lt;/code&gt; を使用してPostScriptファイルを人間が表示できるようにASCII表現に変換し、それ以外の場合はバイナリファイルとして処理することができます。 &lt;code&gt;-diff&lt;/code&gt; 属性と &lt;code&gt;diff=ps&lt;/code&gt; 属性の両方を指定することはできません。解決策は、 &lt;code&gt;diff.*.binary&lt;/code&gt; オプションを使用することです。</target>
        </trans-unit>
        <trans-unit id="c15b1eea7ada51b9540f36c6d7433749c2518719" translate="yes" xml:space="preserve">
          <source>However, our next step is to commit the &lt;strong&gt;change&lt;/strong&gt; we did, and again, to understand what&amp;rsquo;s going on, keep in mind the difference between &quot;working tree contents&quot;, &quot;index file&quot; and &quot;committed tree&quot;. We have changes in the working tree that we want to commit, and we always have to work through the index file, so the first thing we need to do is to update the index cache:</source>
          <target state="translated">ただし、次のステップは、行った&lt;strong&gt;変更&lt;/strong&gt;をコミットする&lt;strong&gt;ことです。&lt;/strong&gt;また、何が起こっているのかを理解するために、「作業ツリーの内容」、「インデックスファイル」、「コミットされたツリー」の違いに注意してください。コミットする作業ツリーに変更があり、常にインデックスファイルを操作する必要があるため、最初に行う必要があるのはインデックスキャッシュを更新することです。</target>
        </trans-unit>
        <trans-unit id="066e262ce5d073a40098065a4bfe593a37b357ee" translate="yes" xml:space="preserve">
          <source>However, since Git knows about them, you can now start using some of the most basic Git commands to manipulate the files or look at their status.</source>
          <target state="translated">しかし、Git はそれらのことを知っているので、ファイルを操作したり、その状態を見たりするための最も基本的な Git コマンドのいくつかを使い始めることができます。</target>
        </trans-unit>
        <trans-unit id="2d4b86f86d3381add9d6753c2a6a37207cb69976" translate="yes" xml:space="preserve">
          <source>However, the &lt;a href=&quot;git-pull&quot;&gt;git-pull[1]&lt;/a&gt; command provides a way to do this in one step:</source>
          <target state="translated">ただし、&lt;a href=&quot;git-pull&quot;&gt;git-pull [1]&lt;/a&gt;コマンドは、これを1つのステップで実行する方法を提供します。</target>
        </trans-unit>
        <trans-unit id="b2062c8611299450fbfa8b88f93e46840eed9772" translate="yes" xml:space="preserve">
          <source>However, the commits do not form a simple list; Git allows lines of development to diverge and then reconverge, and the point where two lines of development reconverge is called a &quot;merge&quot;. The commit representing a merge can therefore have more than one parent, with each parent representing the most recent commit on one of the lines of development leading to that point.</source>
          <target state="translated">Git では、開発ラインが分岐してから再結合することができます。そのため、マージを表すコミットは複数の親を持つことができ、それぞれの親はそのポイントにつながる開発ラインのうちのひとつのラインの最新のコミットを表します。</target>
        </trans-unit>
        <trans-unit id="dc3c84ebe58db76ac38c1e3a6d7daded7c305410" translate="yes" xml:space="preserve">
          <source>However, the more common way to do this is to maintain a separate public repository (usually on a different host) for others to pull changes from. This is usually more convenient, and allows you to cleanly separate private work in progress from publicly visible work.</source>
          <target state="translated">しかし、これを行うより一般的な方法は、他の人が変更を引き出せるように別の公開リポジトリ(通常は別のホスト上)を管理することです。この方が通常は便利で、公開されている作業と進行中のプライベートな作業をきれいに分離することができます。</target>
        </trans-unit>
        <trans-unit id="755c039a0c20727e4839caf6deef253d613f16de" translate="yes" xml:space="preserve">
          <source>However, there are cases in which your local changes do conflict with the upstream changes, and &lt;code&gt;git pull&lt;/code&gt; refuses to overwrite your changes. In such a case, you can stash your changes away, perform a pull, and then unstash, like this:</source>
          <target state="translated">ただし、ローカルの変更が上流の変更と競合する場合があり、 &lt;code&gt;git pull&lt;/code&gt; は変更を上書きすることを拒否します。このような場合、次のように、変更を隠してプルし、次にunstashできます。</target>
        </trans-unit>
        <trans-unit id="e43d419a26518c38e69ee02a5a541b221da6c649" translate="yes" xml:space="preserve">
          <source>However, there are legitimate reasons why a developer may want to recreate merge commits: to keep the branch structure (or &quot;commit topology&quot;) when working on multiple, inter-related branches.</source>
          <target state="translated">しかし、開発者がマージコミットを再作成したいと思うのには正当な理由があります。</target>
        </trans-unit>
        <trans-unit id="89adb927099ba4a8289673a41ab8ec24ea6e4abd" translate="yes" xml:space="preserve">
          <source>However, there is a situation in which it can be useful to violate this assumption.</source>
          <target state="translated">しかし、この前提に反することが有用な場合もあります。</target>
        </trans-unit>
        <trans-unit id="b068287d80433091fc93a07d4af49d57d3676c5d" translate="yes" xml:space="preserve">
          <source>However, there is no particular reason to merge in one branch first and the other next, when what you have are a set of truly independent changes (if the order mattered, then they are not independent by definition). You could instead merge those two branches into the current branch at once. First let&amp;rsquo;s undo what we just did and start over. We would want to get the master branch before these two merges by resetting it to &lt;code&gt;master~2&lt;/code&gt;:</source>
          <target state="translated">ただし、1つのブランチを最初にマージし、次に別のブランチをマージする特別な理由はありません。実際に独立した変更のセットである場合（順序が重要な場合、それらは当然のことながら独立していません）。代わりに、これらの2つのブランチを一度に現在のブランチにマージできます。最初に、今行ったことを元に戻してやり直します。私たちは、それをリセットすることによって、これらの2つのマージする前にmasterブランチを取得したい &lt;code&gt;master~2&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="76dbad7bbd23560fcc8351e42a22aad055901cd6" translate="yes" xml:space="preserve">
          <source>However, these features fall short of a complete solution, so users who run commands concurrently have to live with some risk of corruption (which seems to be low in practice).</source>
          <target state="translated">しかし、これらの機能は完全な解決策としては不足しているので、コマンドを同時に実行しているユーザーは、ある程度の腐敗のリスクを抱えて生きていかなければなりません(実際には低いと思われます)。</target>
        </trans-unit>
        <trans-unit id="f41fcda082e8874086be41192b1abbea2d3295da" translate="yes" xml:space="preserve">
          <source>However, this is &lt;strong&gt;NOT&lt;/strong&gt; allowed for switches with an optional value, where the &lt;code&gt;stuck&lt;/code&gt; form must be used:</source>
          <target state="translated">ただし、 &lt;code&gt;stuck&lt;/code&gt; フォームを使用する必要があるオプションの値を持つスイッチの場合、これは許可され&lt;strong&gt;ません&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="4da9d9ef7c6a0e88df4192c01891a87d88664b48" translate="yes" xml:space="preserve">
          <source>However, this is only a convention, and you can name your branches anything you want, and don&amp;rsquo;t have to ever even &lt;code&gt;have&lt;/code&gt; a &lt;code&gt;master&lt;/code&gt; branch. A number of the Git tools will assume that &lt;code&gt;.git/HEAD&lt;/code&gt; is valid, though.</source>
          <target state="translated">ただし、これは単なる慣例であり、ブランチには好きな名前を付けることができ、 &lt;code&gt;master&lt;/code&gt; ブランチを用意する &lt;code&gt;have&lt;/code&gt; もありません。ただし、多くのGitツールは、 &lt;code&gt;.git/HEAD&lt;/code&gt; が有効であると想定しています。</target>
        </trans-unit>
        <trans-unit id="a7abfde622702125ddcfca8f6b53cf2f29202a6d" translate="yes" xml:space="preserve">
          <source>However, this last command can be dangerous in some cases&amp;mdash;​never throw away a commit you have already committed if that commit may itself have been merged into another branch, as doing so may confuse further merges.</source>
          <target state="translated">ただし、この最後のコマンドは危険な場合があります。そのコミット自体が別のブランチにマージされている可能性がある場合は、すでにコミットしているコミットを破棄しないでください。</target>
        </trans-unit>
        <trans-unit id="ba574b0c600bcf4947d9fc0b827ea5d5666b3028" translate="yes" xml:space="preserve">
          <source>However, when no confusion will result, we often just use the term &quot;branch&quot; both for branches and for branch heads.</source>
          <target state="translated">しかし、混乱が生じない場合には、枝と枝頭の両方に「枝」という言葉を使うことが多いです。</target>
        </trans-unit>
        <trans-unit id="2952d19c4dc617ab4a4ae6abe65c729f11b54f82" translate="yes" xml:space="preserve">
          <source>However, when you do &lt;code&gt;git read-tree&lt;/code&gt; with three trees, the &quot;stage&quot; starts out at 1.</source>
          <target state="translated">ただし、3つの &lt;code&gt;git read-tree&lt;/code&gt; でgit read-treeを実行すると、「ステージ」は1から始まります。</target>
        </trans-unit>
        <trans-unit id="28dd1f9126b301b96d86409d92ae4b0d38938148" translate="yes" xml:space="preserve">
          <source>However, while there is nothing wrong with Git&amp;rsquo;s support for shared repositories, this mode of operation is not generally recommended, simply because the mode of collaboration that Git supports&amp;mdash;​by exchanging patches and pulling from public repositories&amp;mdash;​has so many advantages over the central shared repository:</source>
          <target state="translated">ただし、Gitが共有リポジトリをサポートしていることには何の問題もありませんが、Gitがサポートするコラボレーションモード（パッチの交換とパブリックリポジトリからのプルによる）には、中央共有リポジトリ：</target>
        </trans-unit>
        <trans-unit id="6ee73f3ad469e31cc982a856f9ec909f123f7a3b" translate="yes" xml:space="preserve">
          <source>However, you already dirtied the index (i.e. your index does not match the &lt;code&gt;HEAD&lt;/code&gt; commit). But you know the pull you are going to make does not affect &lt;code&gt;frotz.c&lt;/code&gt; or &lt;code&gt;filfre.c&lt;/code&gt;, so you revert the index changes for these two files. Your changes in working tree remain there.</source>
          <target state="translated">ただし、インデックスはすでに汚れています（つまり、インデックスが &lt;code&gt;HEAD&lt;/code&gt; コミットと一致していません）。ただし、これから行うプルは &lt;code&gt;frotz.c&lt;/code&gt; または &lt;code&gt;filfre.c&lt;/code&gt; に影響を与えないため、これら2つのファイルのインデックスの変更を元に戻します。作業ツリーでの変更はそのまま残ります。</target>
        </trans-unit>
        <trans-unit id="9e2e4a0fcb3942d8a82c6a2331932351c7c8a259" translate="yes" xml:space="preserve">
          <source>However, your &quot;wrong&quot; branch and correct &quot;mytopic&quot; branch may differ in files that you have modified locally, in which case the above switch would fail like this:</source>
          <target state="translated">しかし、あなたの「間違った」ブランチと正しい「mytopic」ブランチは、ローカルで変更したファイルで異なる可能性があり、その場合、上記のスイッチはこのように失敗します。</target>
        </trans-unit>
        <trans-unit id="6a9281c350a487a356b48bdfa67abfef81982489" translate="yes" xml:space="preserve">
          <source>However, your &quot;wrong&quot; branch and correct &lt;code&gt;mytopic&lt;/code&gt; branch may differ in files that you have modified locally, in which case the above checkout would fail like this:</source>
          <target state="translated">ただし、「間違った」ブランチと正しい &lt;code&gt;mytopic&lt;/code&gt; ブランチは、ローカルで変更したファイルで異なる場合があります。その場合、上記のチェックアウトは次のように失敗します。</target>
        </trans-unit>
        <trans-unit id="eaf133288702a5baf1a98928a127236dfad5386f" translate="yes" xml:space="preserve">
          <source>I most actively use it during the merge window (when a lot of trees get merged upstream and when the influx of bugs is the highest) - and yes, there have been cases that i used it multiple times a day. My average is roughly once a day.</source>
          <target state="translated">私が最も積極的に使用しているのは、マージウィンドウ(多くのツリーが上流にマージされ、バグの流入が最も多いとき)の間で、そう、一日に何度も使用したことがあります。私の平均はだいたい一日一回です。</target>
        </trans-unit>
        <trans-unit id="27777a39e933776b5c584d121830042fbc955f15" translate="yes" xml:space="preserve">
          <source>I.e. a fast-forward of commits and tags outside &lt;code&gt;refs/{tags,heads}/*&lt;/code&gt; is allowed, even in cases where what&amp;rsquo;s being fast-forwarded is not a commit, but a tag object which happens to point to a new commit which is a fast-forward of the commit the last tag (or commit) it&amp;rsquo;s replacing. Replacing a tag with an entirely different tag is also allowed, if it points to the same commit, as well as pushing a peeled tag, i.e. pushing the commit that existing tag object points to, or a new tag object which an existing commit points to.</source>
          <target state="translated">つまり &lt;code&gt;refs/{tags,heads}/*&lt;/code&gt; 外のコミットとタグの早送りは、早送りされているものがコミットではなく、たまたま新しいコミットを指すタグオブジェクトである場合でも許可されます。置き換える最後のタグ（またはコミット）の早送り。完全に異なるタグでタグを置き換えることもできます。タグが同じコミットを指している場合、およびピールされたタグをプッシュすること、つまり既存のタグオブジェクトが指すコミット、または既存のコミットが指す新しいタグオブジェクトをプッシュすることもできます。 。</target>
        </trans-unit>
        <trans-unit id="f6dcea8e2840d6db982f7ea79204e026c88b3ea6" translate="yes" xml:space="preserve">
          <source>I.e. create a &lt;code&gt;base&lt;/code&gt; tag for versions of the upstream code that you&amp;rsquo;ve seen and are willing to overwrite, then rewrite history, and finally force push changes to &lt;code&gt;master&lt;/code&gt; if the remote version is still at &lt;code&gt;base&lt;/code&gt;, regardless of what your local &lt;code&gt;remotes/origin/master&lt;/code&gt; has been updated to in the background.</source>
          <target state="translated">つまり、これまでに確認して上書きしたいアップストリームコードのバージョンの &lt;code&gt;base&lt;/code&gt; タグを作成し、履歴を書き換えて、ローカルのリモート &lt;code&gt;remotes/origin/master&lt;/code&gt; 関係なく、リモートバージョンがまだ &lt;code&gt;base&lt;/code&gt; の場合は最後にプッシュ変更を &lt;code&gt;master&lt;/code&gt; に強制します。/ masterがバックグラウンドでに更新されました。</target>
        </trans-unit>
        <trans-unit id="d160035a43dfa655c4a6e47190220d072175392c" translate="yes" xml:space="preserve">
          <source>IOW, you can use this thing to look for likely duplicate commits.</source>
          <target state="translated">これを使って重複しそうなコミットを探すことができます。</target>
        </trans-unit>
        <trans-unit id="445867d9c88cb9ec795d4d1edb4358f7f32ed23d" translate="yes" xml:space="preserve">
          <source>ISO 8601</source>
          <target state="translated">ISO8601</target>
        </trans-unit>
        <trans-unit id="8927163ad4efa8aea54b9b8e320ebffea4053ff8" translate="yes" xml:space="preserve">
          <source>Id of a tree-ish.</source>
          <target state="translated">木のようなもののID。</target>
        </trans-unit>
        <trans-unit id="f64266dea77070f77d87b89cb3f30c2d11210170" translate="yes" xml:space="preserve">
          <source>Identifier terminology</source>
          <target state="translated">識別子の用語</target>
        </trans-unit>
        <trans-unit id="2dd468355239de3fa1d047b407c0f3c35e4315ad" translate="yes" xml:space="preserve">
          <source>Identity-specific versions of the &lt;code&gt;sendemail.*&lt;/code&gt; parameters found below, taking precedence over those when this identity is selected, through either the command-line or &lt;code&gt;sendemail.identity&lt;/code&gt;.</source>
          <target state="translated">コマンドラインまたは &lt;code&gt;sendemail.identity&lt;/code&gt; のいずれかを使用して、このアイデンティティが選択されている場合に優先される、以下にある &lt;code&gt;sendemail.*&lt;/code&gt; パラメータのアイデンティティ固有のバージョン。</target>
        </trans-unit>
        <trans-unit id="05103278665252bd3225a3f315ada6e006bd41ae" translate="yes" xml:space="preserve">
          <source>If &amp;ldquo;:&amp;lt;funcname&amp;gt;&amp;rdquo; is given in place of &amp;lt;start&amp;gt; and &amp;lt;end&amp;gt;, it is a regular expression that denotes the range from the first funcname line that matches &amp;lt;funcname&amp;gt;, up to the next funcname line. &amp;ldquo;:&amp;lt;funcname&amp;gt;&amp;rdquo; searches from the end of the previous &lt;code&gt;-L&lt;/code&gt; range, if any, otherwise from the start of file. &amp;ldquo;^:&amp;lt;funcname&amp;gt;&amp;rdquo; searches from the start of file.</source>
          <target state="translated">&amp;lt;start&amp;gt;と&amp;lt;end&amp;gt;の代わりに「：&amp;lt;funcname&amp;gt;」が指定されている場合、これは、&amp;lt;funcname&amp;gt;に一致する最初のfuncname行から次のfuncname行までの範囲を示す正規表現です。&amp;ldquo;：&amp;lt;funcname&amp;gt;&amp;rdquo;は、前の &lt;code&gt;-L&lt;/code&gt; 範囲がある場合は最後から検索し、それ以外の場合はファイルの先頭から検索します。「^：&amp;lt;funcname&amp;gt;」はファイルの先頭から検索します。</target>
        </trans-unit>
        <trans-unit id="a70081d33e7c2f9862444b9de88b6fa456d0c4eb" translate="yes" xml:space="preserve">
          <source>If &amp;lt;branch&amp;gt; is specified, &lt;code&gt;git rebase&lt;/code&gt; will perform an automatic &lt;code&gt;git switch &amp;lt;branch&amp;gt;&lt;/code&gt; before doing anything else. Otherwise it remains on the current branch.</source>
          <target state="translated">&amp;lt;branch&amp;gt;が指定されている場合、 &lt;code&gt;git rebase&lt;/code&gt; は他の処理を行う前に自動 &lt;code&gt;git switch &amp;lt;branch&amp;gt;&lt;/code&gt; を実行します。それ以外の場合は、現在のブランチに残ります。</target>
        </trans-unit>
        <trans-unit id="441a1b498aa3709837145817fb556c2b9312d349" translate="yes" xml:space="preserve">
          <source>If &amp;lt;commit-ish&amp;gt; is a branch name (call it &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt;) and is not found, and neither &lt;code&gt;-b&lt;/code&gt; nor &lt;code&gt;-B&lt;/code&gt; nor &lt;code&gt;--detach&lt;/code&gt; are used, but there does exist a tracking branch in exactly one remote (call it &lt;code&gt;&amp;lt;remote&amp;gt;&lt;/code&gt;) with a matching name, treat as equivalent to:</source>
          <target state="translated">&amp;lt;commit-ish&amp;gt;がブランチ名（ &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; と呼ぶ）であり、見つからず、 &lt;code&gt;-b&lt;/code&gt; も &lt;code&gt;-B&lt;/code&gt; も &lt;code&gt;--detach&lt;/code&gt; も使用されていないが、1つのリモートに追跡ブランチが存在する場合（これを呼び出す） &lt;code&gt;&amp;lt;remote&amp;gt;&lt;/code&gt; ）に一致する名前を付けて、以下と同等に扱います。</target>
        </trans-unit>
        <trans-unit id="a2dfa99d3d5ae08ba34d86a50dd72c99c275182b" translate="yes" xml:space="preserve">
          <source>If &amp;lt;dst&amp;gt; does not match any remote ref, either</source>
          <target state="translated">&amp;lt;dst&amp;gt;がどのリモート参照とも一致しない場合も、</target>
        </trans-unit>
        <trans-unit id="a47c4a8533ef20594cec62184911d5ccc54294bc" translate="yes" xml:space="preserve">
          <source>If &amp;lt;dst&amp;gt; doesn&amp;rsquo;t start with &lt;code&gt;refs/&lt;/code&gt; (e.g. &lt;code&gt;refs/heads/master&lt;/code&gt;) we will try to infer where in &lt;code&gt;refs/*&lt;/code&gt; on the destination &amp;lt;repository&amp;gt; it belongs based on the type of &amp;lt;src&amp;gt; being pushed and whether &amp;lt;dst&amp;gt; is ambiguous.</source>
          <target state="translated">&amp;lt;dst&amp;gt;が &lt;code&gt;refs/&lt;/code&gt; 始まっていない場合（例： &lt;code&gt;refs/heads/master&lt;/code&gt; ）、宛先の&amp;lt;repository&amp;gt;の &lt;code&gt;refs/*&lt;/code&gt; のどこにあるかを推論し、プッシュされている&amp;lt;src&amp;gt;のタイプと&amp;lt; dst&amp;gt;があいまいです。</target>
        </trans-unit>
        <trans-unit id="055e400548fbd1f8dd3a927bc48c7fba28571578" translate="yes" xml:space="preserve">
          <source>If &amp;lt;dst&amp;gt; unambiguously refers to a ref on the &amp;lt;repository&amp;gt; remote, then push to that ref.</source>
          <target state="translated">&amp;lt;dst&amp;gt;が&amp;lt;repository&amp;gt;リモート上の参照を明確に参照している場合は、その参照にプッシュします。</target>
        </trans-unit>
        <trans-unit id="2f8ca0e0f80952529303f3d2318f597064384182" translate="yes" xml:space="preserve">
          <source>If &amp;lt;src&amp;gt; resolves to a ref starting with refs/heads/ or refs/tags/, then prepend that to &amp;lt;dst&amp;gt;.</source>
          <target state="translated">&amp;lt;src&amp;gt;がrefs / heads /またはrefs / tags /で始まるrefに解決される場合は、それを&amp;lt;dst&amp;gt;に付加します。</target>
        </trans-unit>
        <trans-unit id="22f62b9091f5d458969b188b7b4383b4ee480486" translate="yes" xml:space="preserve">
          <source>If &amp;lt;start&amp;gt; or &amp;lt;end&amp;gt; is a number, it specifies an absolute line number (lines count from 1).</source>
          <target state="translated">&amp;lt;start&amp;gt;または&amp;lt;end&amp;gt;が数値の場合は、絶対行番号を指定します（行は1から数えます）。</target>
        </trans-unit>
        <trans-unit id="3dcd00aaff1f71fc43821b3cae7ba5d1996fda2a" translate="yes" xml:space="preserve">
          <source>If &amp;lt;type&amp;gt; is specified, the raw (though uncompressed) contents of the &amp;lt;object&amp;gt; will be returned.</source>
          <target state="translated">&amp;lt;type&amp;gt;が指定されている場合、&amp;lt;object&amp;gt;の未圧縮のコンテンツが返されます。</target>
        </trans-unit>
        <trans-unit id="60fbab80da041fac4b578f6b9620a6e042d89ff6" translate="yes" xml:space="preserve">
          <source>If &amp;lt;upstream&amp;gt; is given on the command line, then the default is &lt;code&gt;--no-fork-point&lt;/code&gt;, otherwise the default is &lt;code&gt;--fork-point&lt;/code&gt;.</source>
          <target state="translated">コマンドラインで&amp;lt;upstream&amp;gt;を指定した場合、デフォルトは &lt;code&gt;--no-fork-point&lt;/code&gt; です。それ以外の場合、デフォルトは &lt;code&gt;--fork-point&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="099d6bbda7b3ea83e2000830c8cd48d38a505e41" translate="yes" xml:space="preserve">
          <source>If &amp;lt;upstream&amp;gt; is not specified, the upstream configured in branch.&amp;lt;name&amp;gt;.remote and branch.&amp;lt;name&amp;gt;.merge options will be used (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for details) and the &lt;code&gt;--fork-point&lt;/code&gt; option is assumed. If you are currently not on any branch or if the current branch does not have a configured upstream, the rebase will abort.</source>
          <target state="translated">&amp;lt;upstream&amp;gt;が指定されていない場合、branch。&amp;lt;name&amp;gt; .remoteおよびbranch。&amp;lt;name&amp;gt; .mergeオプションで構成されたアップストリームが使用されます（詳細については&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;を参照）および &lt;code&gt;--fork-point&lt;/code&gt; オプション想定されます。現在どのブランチにもいない場合、または現在のブランチに設定されたアップストリームがない場合、リベースは中止されます。</target>
        </trans-unit>
        <trans-unit id="217621e5abfa606810a09d87aaa6c7fa540fc0fa" translate="yes" xml:space="preserve">
          <source>If --base-path is enabled and repo lookup fails, with this option &lt;code&gt;git daemon&lt;/code&gt; will attempt to lookup without prefixing the base path. This is useful for switching to --base-path usage, while still allowing the old paths.</source>
          <target state="translated">--base-pathが有効になっていて、リポジトリの検索が失敗した場合、このオプションを使用すると、 &lt;code&gt;git daemon&lt;/code&gt; はベースパスのプレフィックスを付けずに検索を試みます。これは、古いパスを許可しながら--base-pathの使用に切り替える場合に便利です。</target>
        </trans-unit>
        <trans-unit id="8fc1cea1e55be69663b951a920323d5b77c212cc" translate="yes" xml:space="preserve">
          <source>If --follow-symlinks is used, and a symlink in the repository points outside the repository, then &lt;code&gt;cat-file&lt;/code&gt; will ignore any custom format and print:</source>
          <target state="translated">--follow-symlinksが使用され、リポジトリ内のシンボリックリンクがリポジトリの外部を指している場合、 &lt;code&gt;cat-file&lt;/code&gt; はカスタム形式を無視して出力します。</target>
        </trans-unit>
        <trans-unit id="100e053a72420596d3d8e1af3be6193b59283565" translate="yes" xml:space="preserve">
          <source>If --follow-symlinks is used, the following error messages will be displayed:</source>
          <target state="translated">follow-symlinksを使用した場合は、以下のようなエラーメッセージが表示されます。</target>
        </trans-unit>
        <trans-unit id="5af2f9fd35f6354ba06f2224c3a1950a1f2e9539" translate="yes" xml:space="preserve">
          <source>If --no-deref is given, &amp;lt;ref&amp;gt; itself is overwritten, rather than the result of following the symbolic pointers.</source>
          <target state="translated">--no-derefが指定されている場合、シンボリックポインターをたどった結果ではなく、&amp;lt;ref&amp;gt;自体が上書きされます。</target>
        </trans-unit>
        <trans-unit id="09e3aecc968d12fb9705beff5237174e03c29bc7" translate="yes" xml:space="preserve">
          <source>If --porcelain is used, then each line of the output is of the form:</source>
          <target state="translated">もし --porcelain が使用された場合、出力の各行はその形式になります。</target>
        </trans-unit>
        <trans-unit id="f6d2b768e06f422855acdd627f6c6194c3c0ef9e" translate="yes" xml:space="preserve">
          <source>If --prune-empty is specified, sometimes empty commits are missed and left around anyway (a somewhat rare bug, but it happens&amp;hellip;​)</source>
          <target state="translated">--prune-emptyが指定されている場合、空のコミットが失われ、とにかく残ってしまうことがあります（ややまれなバグですが、発生します&amp;hellip;）</target>
        </trans-unit>
        <trans-unit id="e22868793c21cef41b42f4d8e7236df1fabd77b0" translate="yes" xml:space="preserve">
          <source>If --prune-empty is specified, then intentionally placed empty commits from before the filtering operation are also pruned instead of just pruning commits that became empty due to filtering rules.</source>
          <target state="translated">もし --prune-empty が指定された場合、フィルタリングルールによって空になったコミットを剪定するのではなく、フィルタリング操作の前から意図的に置かれた空のコミットも剪定されます。</target>
        </trans-unit>
        <trans-unit id="a5f91d56ff44d75c2f6264bd8bf6a44ba8095c27" translate="yes" xml:space="preserve">
          <source>If --prune-empty isn&amp;rsquo;t specified, then the filtering process can create hoards of confusing empty commits</source>
          <target state="translated">--prune-emptyが指定されていない場合、フィルタリングプロセスにより、混乱する空のコミットが溜まる可能性があります。</target>
        </trans-unit>
        <trans-unit id="2d1fd147af59c1bbe70034d2e19205e4683ec22e" translate="yes" xml:space="preserve">
          <source>If --refresh finds unmerged changes in the index, the default behavior is to error out. This option makes &lt;code&gt;git update-index&lt;/code&gt; continue anyway.</source>
          <target state="translated">--refreshがインデックス内のマージされていない変更を検出した場合、デフォルトの動作はエラーになります。このオプションを使用すると、 &lt;code&gt;git update-index&lt;/code&gt; が続行されます。</target>
        </trans-unit>
        <trans-unit id="a1d97a45ebe920517b85d93c5180821e570038df" translate="yes" xml:space="preserve">
          <source>If -b is used the short-format status is preceded by a line</source>
          <target state="translated">b が使用された場合は、ショートフォーマットのステータスの前に行が置かれます。</target>
        </trans-unit>
        <trans-unit id="a46e8db06d3992e975f7697afc61f277e4b431aa" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;git-tag&quot;&gt;git-tag[1]&lt;/a&gt; or &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; is not selecting the key you want it to automatically when creating a signed tag or commit, you can override the default selection with this variable. This option is passed unchanged to gpg&amp;rsquo;s --local-user parameter, so you may specify a key using any method that gpg supports.</source>
          <target state="translated">場合&lt;a href=&quot;git-tag&quot;&gt;はgit-タグ[1]&lt;/a&gt;または&lt;a href=&quot;git-commit&quot;&gt;gitのコミット[1]は&lt;/a&gt;、あなたが署名したタグを作成するか、コミットするとき、それは自動的に、あなたはこの変数にデフォルトの選択を上書きすることができますしたいキーを選択されていません。このオプションは変更されずにgpgの--local-userパラメーターに渡されるため、gpgがサポートする任意のメソッドを使用してキーを指定できます。</target>
        </trans-unit>
        <trans-unit id="2cf1a7ea3bd0bf42d7200bd0e5a09fa57461a419" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$GIT_DIR/&amp;lt;refname&amp;gt;&lt;/code&gt; exists, that is what you mean (this is usually useful only for &lt;code&gt;HEAD&lt;/code&gt;, &lt;code&gt;FETCH_HEAD&lt;/code&gt;, &lt;code&gt;ORIG_HEAD&lt;/code&gt;, &lt;code&gt;MERGE_HEAD&lt;/code&gt; and &lt;code&gt;CHERRY_PICK_HEAD&lt;/code&gt;);</source>
          <target state="translated">場合は &lt;code&gt;$GIT_DIR/&amp;lt;refname&amp;gt;&lt;/code&gt; 存在し、それはあなたが（これはのみのために、通常は有益であることを意味するものである &lt;code&gt;HEAD&lt;/code&gt; 、 &lt;code&gt;FETCH_HEAD&lt;/code&gt; 、 &lt;code&gt;ORIG_HEAD&lt;/code&gt; 、 &lt;code&gt;MERGE_HEAD&lt;/code&gt; と &lt;code&gt;CHERRY_PICK_HEAD&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="393d945c97962e065f70f0c395a4b7cc04c58275" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$GIT_DIR&lt;/code&gt; is not defined and the current directory is not detected to lie in a Git repository or work tree print a message to stderr and exit with nonzero status.</source>
          <target state="translated">場合は &lt;code&gt;$GIT_DIR&lt;/code&gt; 定義されていないと、現在のディレクトリは、ゼロ以外のステータスと標準エラー出力して終了にメッセージを印刷するGitのリポジトリまたは作業ツリーに嘘に検出されません。</target>
        </trans-unit>
        <trans-unit id="b71bb32cc72ead271cb1dd3ba713d52586ceff1b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$per_request_config&lt;/code&gt; is not a code reference, it is interpreted as boolean value. If it is true gitweb will process config files once per request, and if it is false gitweb will process config files only once, each time it is executed. True by default (set to 1).</source>
          <target state="translated">&lt;code&gt;$per_request_config&lt;/code&gt; がコード参照でない場合、ブール値として解釈されます。trueの場合、gitwebはリクエストごとに構成ファイルを1回処理し、falseの場合、gitwebは実行されるたびに1回だけ構成ファイルを処理します。デフォルトでTrue（1に設定）。</target>
        </trans-unit>
        <trans-unit id="2006fc66d73a978df057f23b3e1521f13762b146" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$projects_list&lt;/code&gt; variable is unset, gitweb will recursively scan filesystem for Git repositories. The &lt;code&gt;$project_maxdepth&lt;/code&gt; is used to limit traversing depth, relative to &lt;code&gt;$projectroot&lt;/code&gt; (starting point); it means that directories which are further from &lt;code&gt;$projectroot&lt;/code&gt; than &lt;code&gt;$project_maxdepth&lt;/code&gt; will be skipped.</source>
          <target state="translated">&lt;code&gt;$projects_list&lt;/code&gt; 変数が設定されていない場合、gitwebはファイルシステムを再帰的にスキャンしてGitリポジトリーを探します。 &lt;code&gt;$project_maxdepth&lt;/code&gt; 限界トラバース深さに対してために使用される &lt;code&gt;$projectroot&lt;/code&gt; （出発点）。それから、さらにあるディレクトリことを意味 &lt;code&gt;$projectroot&lt;/code&gt; より &lt;code&gt;$project_maxdepth&lt;/code&gt; スキップされます。</target>
        </trans-unit>
        <trans-unit id="e1a24fe330082e54d9c17c846d5ecec5993c1e30" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; is not found but there does exist a tracking branch in exactly one remote (call it &lt;code&gt;&amp;lt;remote&amp;gt;&lt;/code&gt;) with a matching name and &lt;code&gt;--no-guess&lt;/code&gt; is not specified, treat as equivalent to</source>
          <target state="translated">場合 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 見つからなかったが、（それを呼び出すリモート正確に一つで追跡ブランチが存在しない &lt;code&gt;&amp;lt;remote&amp;gt;&lt;/code&gt; マッチング名として） &lt;code&gt;--no-guess&lt;/code&gt; 、相当として御馳走を指定されていません</target>
        </trans-unit>
        <trans-unit id="8d6aaf33671aeae0467cc81ab4a876d4297a1c66" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; is not found but there does exist a tracking branch in exactly one remote (call it &lt;code&gt;&amp;lt;remote&amp;gt;&lt;/code&gt;) with a matching name, treat as equivalent to</source>
          <target state="translated">場合 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 見つからなかったが、正確に一つのリモート（それを呼び出すに追跡ブランチが存在しない &lt;code&gt;&amp;lt;remote&amp;gt;&lt;/code&gt; 一致する名前を持つ）、相当として扱います</target>
        </trans-unit>
        <trans-unit id="d5e4daa5549f785c6c9358d5ddb62b147a25d8f2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is a branch name (call it &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt;) and is not found, and neither &lt;code&gt;-b&lt;/code&gt; nor &lt;code&gt;-B&lt;/code&gt; nor &lt;code&gt;--detach&lt;/code&gt; are used, but there does exist a tracking branch in exactly one remote (call it &lt;code&gt;&amp;lt;remote&amp;gt;&lt;/code&gt;) with a matching name, treat as equivalent to:</source>
          <target state="translated">もし &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; ブランチ名である（それを呼び出す &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; ）と見られ、どちらもされていない &lt;code&gt;-b&lt;/code&gt; も &lt;code&gt;-B&lt;/code&gt; も &lt;code&gt;--detach&lt;/code&gt; が使用されているが、それを呼び出します（リモート正確に一つで追跡ブランチが存在しません &lt;code&gt;&amp;lt;remote&amp;gt;&lt;/code&gt; ）と一致する名前で、次と同等のものとして扱います。</target>
        </trans-unit>
        <trans-unit id="e34274f8acc6fb322cd63ad185064de80d714660" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is omitted and neither &lt;code&gt;-b&lt;/code&gt; nor &lt;code&gt;-B&lt;/code&gt; nor &lt;code&gt;--detach&lt;/code&gt; used, then, as a convenience, the new working tree is associated with a branch (call it &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt;) named after &lt;code&gt;$(basename &amp;lt;path&amp;gt;)&lt;/code&gt;. If &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; doesn&amp;rsquo;t exist, a new branch based on &lt;code&gt;HEAD&lt;/code&gt; is automatically created as if &lt;code&gt;-b &amp;lt;branch&amp;gt;&lt;/code&gt; was given. If &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; does exist, it will be checked out in the new working tree, if it&amp;rsquo;s not checked out anywhere else, otherwise the command will refuse to create the working tree (unless &lt;code&gt;--force&lt;/code&gt; is used).</source>
          <target state="translated">場合は &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 省略してもない &lt;code&gt;-b&lt;/code&gt; も &lt;code&gt;-B&lt;/code&gt; も &lt;code&gt;--detach&lt;/code&gt; 使用利便性として、新しい作業ツリーは枝に関連付けられている、そして、（それを呼び出す &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; ）にちなんで名付けられた &lt;code&gt;$(basename &amp;lt;path&amp;gt;)&lt;/code&gt; 。場合 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 存在しない、に基づいて、新しいブランチ &lt;code&gt;HEAD&lt;/code&gt; があるかのように自動的に作成され &lt;code&gt;-b &amp;lt;branch&amp;gt;&lt;/code&gt; 与えられました。場合 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 、それが新しい作業ツリーに存在してチェックアウトされるんそれはどこにもチェックアウトされていない場合は（場合を除き、それ以外のコマンドは作業ツリーを作成することを拒否します &lt;code&gt;--force&lt;/code&gt; が使用されています）。</target>
        </trans-unit>
        <trans-unit id="29cec940deeaa506fbdf23d2fcc19ea5029d5ef6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is omitted and neither &lt;code&gt;-b&lt;/code&gt; nor &lt;code&gt;-B&lt;/code&gt; nor &lt;code&gt;--detach&lt;/code&gt; used, then, as a convenience, the new worktree is associated with a branch (call it &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt;) named after &lt;code&gt;$(basename &amp;lt;path&amp;gt;)&lt;/code&gt;. If &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; doesn&amp;rsquo;t exist, a new branch based on HEAD is automatically created as if &lt;code&gt;-b &amp;lt;branch&amp;gt;&lt;/code&gt; was given. If &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; does exist, it will be checked out in the new worktree, if it&amp;rsquo;s not checked out anywhere else, otherwise the command will refuse to create the worktree (unless &lt;code&gt;--force&lt;/code&gt; is used).</source>
          <target state="translated">場合は &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 省略してもない &lt;code&gt;-b&lt;/code&gt; も &lt;code&gt;-B&lt;/code&gt; も &lt;code&gt;--detach&lt;/code&gt; 使用利便性として、新しいworktreeが枝に関連付けられている、そして、（それを呼び出す &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; ）にちなんで名付けられた &lt;code&gt;$(basename &amp;lt;path&amp;gt;)&lt;/code&gt; 。場合 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 存在しないかのように、HEADに基づいて、新しいブランチが自動的に作成され &lt;code&gt;-b &amp;lt;branch&amp;gt;&lt;/code&gt; 与えられました。場合 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 、それが新しいworktreeに存在してチェックアウトされるんそれはどこにもチェックアウトされていない場合は（場合を除き、それ以外のコマンドはworktreeを作成することを拒否します &lt;code&gt;--force&lt;/code&gt; が使用されています）。</target>
        </trans-unit>
        <trans-unit id="62b6dbbe2a25a278c760cd92507e0bb77e25690a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; is &lt;code&gt;auto&lt;/code&gt;, if the first paragraph of the branch description is greater than 100 bytes, then the mode will be &lt;code&gt;message&lt;/code&gt;, otherwise &lt;code&gt;subject&lt;/code&gt; will be used.</source>
          <target state="translated">場合 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; で &lt;code&gt;auto&lt;/code&gt; 分岐記述の最初の段落が100バイトよりも大きい場合、次にモードになります &lt;code&gt;message&lt;/code&gt; 、そうでなければ &lt;code&gt;subject&lt;/code&gt; 使用されます。</target>
        </trans-unit>
        <trans-unit id="563c89a3c046790f554398f75098f56ae60f56e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; is &lt;code&gt;message&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt;, the cover letter subject will be populated with placeholder text. The body of the cover letter will be populated with the branch&amp;rsquo;s description. This is the default mode when no configuration nor command line option is specified.</source>
          <target state="translated">場合は &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; ある &lt;code&gt;message&lt;/code&gt; や &lt;code&gt;default&lt;/code&gt; 、カバーレターの対象は、プレースホルダテキストが移入されます。カバーレターの本文には、ブランチの説明が入力されます。これは、構成もコマンドラインオプションも指定されていない場合のデフォルトモードです。</target>
        </trans-unit>
        <trans-unit id="768e82f3c3c3a8afb9417d73246f89dace57fcaa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; is &lt;code&gt;none&lt;/code&gt;, both the cover letter subject and body will be populated with placeholder text.</source>
          <target state="translated">&lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; が &lt;code&gt;none&lt;/code&gt; の場合、カバーレターの件名と本文の両方にプレースホルダーテキストが入力されます。</target>
        </trans-unit>
        <trans-unit id="3b18877d6ecf14744d4315ad4c41aafa8a39f64e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; is &lt;code&gt;subject&lt;/code&gt;, the first paragraph of the branch description will populate the cover letter subject. The remainder of the description will populate the body of the cover letter.</source>
          <target state="translated">&lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; が &lt;code&gt;subject&lt;/code&gt; の場合、ブランチの説明の最初の段落にカバーレターの件名が入力されます。説明の残りの部分は、カバーレターの本文に入力されます。</target>
        </trans-unit>
        <trans-unit id="5e29b380beb0930e1e749e4eaa468dd6abb12015" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;pathspec&amp;gt;&lt;/code&gt; names an active submodule and the restore location includes the working tree, the submodule will only be updated if this option is given, in which case its working tree will be restored to the commit recorded in the superproject, and any local modifications overwritten. If nothing (or &lt;code&gt;--no-recurse-submodules&lt;/code&gt;) is used, submodules working trees will not be updated. Just like &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt;, this will detach &lt;code&gt;HEAD&lt;/code&gt; of the submodule.</source>
          <target state="translated">もし &lt;code&gt;&amp;lt;pathspec&amp;gt;&lt;/code&gt; 名のアクティブサブモジュールと復元場所は作業ツリーを含み、このオプションが指定されている場合、サブモジュールのみがその作業ツリーは、親プロジェクトに記録されているコミット、およびローカル変更に復元される場合には、更新されます上書きされます。何も使用されていない場合（または &lt;code&gt;--no-recurse-submodules&lt;/code&gt; ）、サブモジュールの作業ツリーは更新されません。同じように&lt;a href=&quot;git-checkout&quot;&gt;gitのチェックアウト[1] &lt;/a&gt;、これは切り離します &lt;code&gt;HEAD&lt;/code&gt; サブモジュールのを。</target>
        </trans-unit>
        <trans-unit id="c6a4599482148106286830a5bf06a49e73c76aca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--autosquash&lt;/code&gt; is used, &quot;exec&quot; lines will not be appended for the intermediate commits, and will only appear at the end of each squash/fixup series.</source>
          <target state="translated">&lt;code&gt;--autosquash&lt;/code&gt; を使用する場合、「exec」行は中間のコミットには追加されず、各squash / fixupシリーズの最後にのみ表示されます。</target>
        </trans-unit>
        <trans-unit id="ab8e2bae185710923964a946f737935700b0fc1e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--batch&lt;/code&gt; is specified, the object information is followed by the object contents (consisting of &lt;code&gt;%(objectsize)&lt;/code&gt; bytes), followed by a newline.</source>
          <target state="translated">場合 &lt;code&gt;--batch&lt;/code&gt; が指定され、オブジェクト情報は、オブジェクトの内容（成るが続く &lt;code&gt;%(objectsize)&lt;/code&gt; バイト）、改行が続きます。</target>
        </trans-unit>
        <trans-unit id="c868d58aa72d9bce1efba44bdbf844fae93d14ed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--batch&lt;/code&gt; or &lt;code&gt;--batch-check&lt;/code&gt; is given, &lt;code&gt;cat-file&lt;/code&gt; will read objects from stdin, one per line, and print information about them. By default, the whole line is considered as an object, as if it were fed to &lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse[1]&lt;/a&gt;.</source>
          <target state="translated">場合 &lt;code&gt;--batch&lt;/code&gt; または &lt;code&gt;--batch-check&lt;/code&gt; 与えられている、 &lt;code&gt;cat-file&lt;/code&gt; 標準入力からオブジェクトを1行に1つずつ読み、それらについての情報を出力します。デフォルトでは、まるで&lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse [1]に&lt;/a&gt;供給されたかのように、行全体がオブジェクトと見なされます。</target>
        </trans-unit>
        <trans-unit id="2b49579ab9891477a433f3c4a7d881c054bf542d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--branch&lt;/code&gt; is given, a series of header lines are printed with information about the current branch.</source>
          <target state="translated">場合 &lt;code&gt;--branch&lt;/code&gt; が与えられ、ヘッダー行の一連の現在のブランチについての情報が印刷されています。</target>
        </trans-unit>
        <trans-unit id="92890e94239521769988796133cb653b32aed431" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--cached&lt;/code&gt; is specified, it allows you to ask:</source>
          <target state="translated">&lt;code&gt;--cached&lt;/code&gt; が指定されている場合、次のことを確認できます。</target>
        </trans-unit>
        <trans-unit id="cdc2c32e44cf382458d3759532d549dfd10bb0ff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--cached&lt;/code&gt; is specified, this command will instead print the SHA-1 recorded in the superproject for each submodule.</source>
          <target state="translated">&lt;code&gt;--cached&lt;/code&gt; が指定されている場合、このコマンドは代わりに、各サブモジュールのスーパープロジェクトに記録されたSHA-1を出力します。</target>
        </trans-unit>
        <trans-unit id="efe0936134ada9314d303de0a6d1675a3e22d7d9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--force&lt;/code&gt; is specified, the submodule will be checked out (using &lt;code&gt;git checkout --force&lt;/code&gt;), even if the commit specified in the index of the containing repository already matches the commit checked out in the submodule.</source>
          <target state="translated">場合は &lt;code&gt;--force&lt;/code&gt; が指定され、サブモジュールは、（使用してチェックアウトされます &lt;code&gt;git checkout --force&lt;/code&gt; ）を含むリポジトリのインデックスで指定されたコミットしても、すでにサブモジュールでチェックアウトコミット一致しました。</target>
        </trans-unit>
        <trans-unit id="b5618fac3945aa3c15ec4d6ac940c3fc88cab042" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--force&lt;/code&gt; is specified, the submodule&amp;rsquo;s working tree will be removed even if it contains local modifications.</source>
          <target state="translated">場合は &lt;code&gt;--force&lt;/code&gt; が指定され、サブモジュールの作業ツリーは、それがローカルの変更が含まれている場合でも削除されます。</target>
        </trans-unit>
        <trans-unit id="95d47c3b72d050d56bd3bb3556c38937bb16f1f0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--group&lt;/code&gt; is specified multiple times, commits are counted under each value (but again, only once per unique value in that commit). For example, &lt;code&gt;git shortlog --group=author --group=trailer:co-authored-by&lt;/code&gt; counts both authors and co-authors.</source>
          <target state="translated">&lt;code&gt;--group&lt;/code&gt; が複数回指定されている場合、コミットは各値でカウントされます（ただし、そのコミットの一意の値ごとに1回だけカウントされます）。たとえば、 &lt;code&gt;git shortlog --group=author --group=trailer:co-authored-by&lt;/code&gt; は、作成者と共同作成者の両方をカウントします。</target>
        </trans-unit>
        <trans-unit id="f2db79d4530ac333b81dd59fc3c02ca024b34411" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--index&lt;/code&gt; is not specified, then the submodule commits in the patch are ignored and only the absence or presence of the corresponding subdirectory is checked and (if possible) updated.</source>
          <target state="translated">&lt;code&gt;--index&lt;/code&gt; が指定されていない場合、パッチ内のサブモジュールのコミットは無視され、対応するサブディレクトリの不在または存在のみがチェックされ、（可能であれば）更新されます。</target>
        </trans-unit>
        <trans-unit id="ab41ddd9d49ddaff35bf4379642301cf2f1054d2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--index&lt;/code&gt; is specified (explicitly or implicitly), then the submodule commits must match the index exactly for the patch to apply. If any of the submodules are checked-out, then these check-outs are completely ignored, i.e., they are not required to be up to date or clean and they are not updated.</source>
          <target state="translated">&lt;code&gt;--index&lt;/code&gt; が（明示的または暗黙的に）指定されている場合、パッチを適用するには、サブモジュールのコミットがインデックスと正確に一致する必要があります。サブモジュールのいずれかがチェックアウトされている場合、これらのチェックアウトは完全に無視されます。つまり、それらは最新であるかクリーンである必要はなく、更新されません。</target>
        </trans-unit>
        <trans-unit id="d7cd61ae0dde953250d385a6012605e922398ec2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--list&lt;/code&gt; is given, or if there are no non-option arguments, existing branches are listed; the current branch will be highlighted in green and marked with an asterisk. Any branches checked out in linked worktrees will be highlighted in cyan and marked with a plus sign. Option &lt;code&gt;-r&lt;/code&gt; causes the remote-tracking branches to be listed, and option &lt;code&gt;-a&lt;/code&gt; shows both local and remote branches.</source>
          <target state="translated">&lt;code&gt;--list&lt;/code&gt; が指定されている場合、またはオプション以外の引数がない場合、既存のブランチがリストされます。現在のブランチは緑色で強調表示され、アスタリスクでマークされます。リンクされたワークツリーでチェックアウトされたブランチは、シアンで強調表示され、プラス記号が付けられます。オプション &lt;code&gt;-r&lt;/code&gt; を指定すると、リモート追跡ブランチがリストされ、オプション &lt;code&gt;-a&lt;/code&gt; を指定すると、ローカルブランチとリモートブランチの両方が表示されます。</target>
        </trans-unit>
        <trans-unit id="45b84e8c64b1db8d6046842947d0384f2fee755b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--log&lt;/code&gt; is specified, a shortlog of the commits being merged will be appended to the specified message.</source>
          <target state="translated">&lt;code&gt;--log&lt;/code&gt; が指定されている場合、マージされるコミットのショートログが指定されたメッセージに追加されます。</target>
        </trans-unit>
        <trans-unit id="1772a311632ebe173773fb98d78cf3669fc056b0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--max-commits=&amp;lt;M&amp;gt;&lt;/code&gt; is specified with &lt;code&gt;M&lt;/code&gt; a positive integer, and the new tip file would have more than &lt;code&gt;M&lt;/code&gt; commits, then instead merge the new tip with the previous tip.</source>
          <target state="translated">もし &lt;code&gt;--max-commits=&amp;lt;M&amp;gt;&lt;/code&gt; で指定された &lt;code&gt;M&lt;/code&gt; の正の整数を、そして新しいチップファイルは、以上のだろう &lt;code&gt;M&lt;/code&gt; のコミット、その後、代わりに前の先端に新しいチップをマージします。</target>
        </trans-unit>
        <trans-unit id="f4eab33758877fd85cebec91765014b4b92dc48c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--recursive&lt;/code&gt; is specified, this command will recurse into nested submodules, and show their status as well.</source>
          <target state="translated">&lt;code&gt;--recursive&lt;/code&gt; が指定されている場合、このコマンドはネストされたサブモジュールに再帰し、それらのステータスも表示します。</target>
        </trans-unit>
        <trans-unit id="776298c85f9bd8538095ba7ea6588e9b7e4a25e3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--recursive&lt;/code&gt; is specified, this command will recurse into the registered submodules, and sync any nested submodules within.</source>
          <target state="translated">&lt;code&gt;--recursive&lt;/code&gt; が指定されている場合、このコマンドは登録されたサブモジュールに再帰し、その中のネストされたサブモジュールを同期します。</target>
        </trans-unit>
        <trans-unit id="1ddca2ea8ce5da739445e37cd4a4048560236396" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--recursive&lt;/code&gt; is specified, this command will recurse into the registered submodules, and update any nested submodules within.</source>
          <target state="translated">&lt;code&gt;--recursive&lt;/code&gt; が指定されている場合、このコマンドは登録されたサブモジュールに再帰し、ネストされたサブモジュールを更新します。</target>
        </trans-unit>
        <trans-unit id="ccfd5529f6d32ddb692a0a0edb24e2ebd0aeb784" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--size-multiple=&amp;lt;X&amp;gt;&lt;/code&gt; is not specified, let &lt;code&gt;X&lt;/code&gt; equal 2. If the new tip file would have &lt;code&gt;N&lt;/code&gt; commits and the previous tip has &lt;code&gt;M&lt;/code&gt; commits and &lt;code&gt;X&lt;/code&gt; times &lt;code&gt;N&lt;/code&gt; is greater than &lt;code&gt;M&lt;/code&gt;, instead merge the two files into a single file.</source>
          <target state="translated">場合 &lt;code&gt;--size-multiple=&amp;lt;X&amp;gt;&lt;/code&gt; に指定されていない、聞かせて &lt;code&gt;X&lt;/code&gt; が新しいチップのファイルが持っている希望の場合2.を等しく &lt;code&gt;N&lt;/code&gt; のコミットをして、前の先端が持っている &lt;code&gt;M&lt;/code&gt; のコミットと &lt;code&gt;X&lt;/code&gt; の回数 &lt;code&gt;N&lt;/code&gt; がより大きい &lt;code&gt;M&lt;/code&gt; を代わりに2つのファイルをマージし、単一のファイル。</target>
        </trans-unit>
        <trans-unit id="769d8817aa727ff62e14daf04f7de44e2d479abb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--split=no-merge&lt;/code&gt; is specified, a merge is never performed, and the remaining options are ignored. &lt;code&gt;--split=replace&lt;/code&gt; overwrites the existing chain with a new one. A bare &lt;code&gt;--split&lt;/code&gt; defers to the remaining options. (Note that merging a chain of commit graphs replaces the existing chain with a length-1 chain where the first and only incremental holds the entire graph).</source>
          <target state="translated">場合 &lt;code&gt;--split=no-merge&lt;/code&gt; 指定されていない、マージが実行されることはありません、そして残りのオプションは無視されます。 &lt;code&gt;--split=replace&lt;/code&gt; は、既存のチェーンを新しいチェーンで上書きします。裸の &lt;code&gt;--split&lt;/code&gt; は、残りのオプションに従います。（コミットグラフのチェーンをマージすると、既存のチェーンが長さ1のチェーンに置き換えられ、最初で唯一の増分がグラフ全体を保持することに注意してください）。</target>
        </trans-unit>
        <trans-unit id="c75734f6686dc8bf756f12580f08ccb633b88773" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--stateless-rpc&lt;/code&gt; is specified together with this option then the list of refs must be in packet format (pkt-line). Each ref must be in a separate packet, and the list must end with a flush packet.</source>
          <target state="translated">場合 &lt;code&gt;--stateless-rpc&lt;/code&gt; 、このオプションと一緒に指定され、その後、引用文献のリストは、パケットフォーマット（PKT-ライン）でなければなりません。各refは個別のパケット内にある必要があり、リストはフラッシュパケットで終わる必要があります。</target>
        </trans-unit>
        <trans-unit id="d363c35441978c92ee5ead459023dfd1f9ed35c0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--verbose&lt;/code&gt; is specified, the output is a series of lines of the form:</source>
          <target state="translated">場合 &lt;code&gt;--verbose&lt;/code&gt; が指定され、出力がフォームの一連の線です。</target>
        </trans-unit>
        <trans-unit id="b441bd31aac4d2437fef46e0587314ace0da5e13" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-B&lt;/code&gt; is given, &lt;code&gt;&amp;lt;new_branch&amp;gt;&lt;/code&gt; is created if it doesn&amp;rsquo;t exist; otherwise, it is reset. This is the transactional equivalent of</source>
          <target state="translated">場合 &lt;code&gt;-B&lt;/code&gt; が与えられ、 &lt;code&gt;&amp;lt;new_branch&amp;gt;&lt;/code&gt; が存在しない場合は作成されます。それ以外の場合はリセットされます。これはトランザクションと同等です</target>
        </trans-unit>
        <trans-unit id="b749f9938784db5272ac47989617994390a95806" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-N&lt;/code&gt; is specified, removed paths are marked as intent-to-add (see &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;-N&lt;/code&gt; が指定されている場合、削除されたパスは追加意図としてマークされます（&lt;a href=&quot;git-add&quot;&gt;git-add [1]を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="0d1031ba738c1e4895034c45a671bdfc4feb8ed4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-e&lt;/code&gt; is specified, no output, unless the &amp;lt;object&amp;gt; is malformed.</source>
          <target state="translated">場合は &lt;code&gt;-e&lt;/code&gt; が指定され、出力は、&amp;lt;オブジェクト&amp;gt;しない限り、不正な形式はありません。</target>
        </trans-unit>
        <trans-unit id="b39ecbbcbddbe2e5db1df9079f165a4a73917d14" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-m &amp;lt;msg&amp;gt;&lt;/code&gt; or &lt;code&gt;-F &amp;lt;file&amp;gt;&lt;/code&gt; is given and &lt;code&gt;-a&lt;/code&gt;, &lt;code&gt;-s&lt;/code&gt;, and &lt;code&gt;-u &amp;lt;keyid&amp;gt;&lt;/code&gt; are absent, &lt;code&gt;-a&lt;/code&gt; is implied.</source>
          <target state="translated">場合は &lt;code&gt;-m &amp;lt;msg&amp;gt;&lt;/code&gt; または &lt;code&gt;-F &amp;lt;file&amp;gt;&lt;/code&gt; 与えられ、 &lt;code&gt;-a&lt;/code&gt; 、 &lt;code&gt;-s&lt;/code&gt; 、および &lt;code&gt;-u &amp;lt;keyid&amp;gt;&lt;/code&gt; 存在しない、 &lt;code&gt;-a&lt;/code&gt; が暗示されます。</target>
        </trans-unit>
        <trans-unit id="c5ab965e580c550a049049c227e584f98537d08f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-m&lt;/code&gt; is specified, &lt;code&gt;git read-tree&lt;/code&gt; can perform 3 kinds of merge, a single tree merge if only 1 tree is given, a fast-forward merge with 2 trees, or a 3-way merge if 3 or more trees are provided.</source>
          <target state="translated">&lt;code&gt;-m&lt;/code&gt; が指定されている場合、 &lt;code&gt;git read-tree&lt;/code&gt; は3種類のマージを実行できます。1つのツリーのみが指定されている場合は単一のツリーマージ、2つのツリーを含む早送りマージ、または3つ以上のツリーが提供されている場合は3ウェイマージを実行できます。 。</target>
        </trans-unit>
        <trans-unit id="1f1322547f9936fb21adaa0927130bdfd594f82e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-n&lt;/code&gt; or &lt;code&gt;--non-matching&lt;/code&gt; are specified, non-matching pathnames will also be output, in which case all fields in each output record except for &amp;lt;pathname&amp;gt; will be empty. This can be useful when running non-interactively, so that files can be incrementally streamed to STDIN of a long-running check-ignore process, and for each of these files, STDOUT will indicate whether that file matched a pattern or not. (Without this option, it would be impossible to tell whether the absence of output for a given file meant that it didn&amp;rsquo;t match any pattern, or that the output hadn&amp;rsquo;t been generated yet.)</source>
          <target state="translated">場合 &lt;code&gt;-n&lt;/code&gt; または &lt;code&gt;--non-matching&lt;/code&gt; 指定され、一致しないパス名も&amp;lt;パス名&amp;gt;を除く各出力レコードのすべてのフィールドが空になり、その場合、出力、あろう。これは、非対話的に実行する場合に役立ちます。これにより、長時間実行されるチェック無視プロセスのSTDINにファイルを段階的にストリーミングでき、これらのファイルごとに、STDOUTはそのファイルがパターンに一致したかどうかを示します。 （このオプションがないと、特定のファイルの出力がないことが、どのパターンにも一致しなかったのか、それとも出力がまだ生成されていなかったのかを判断することは不可能です。）</target>
        </trans-unit>
        <trans-unit id="bedfa7472b5b880935d5dde5c2d6b7df2dd5534d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-o&lt;/code&gt; is specified, output files are created in &amp;lt;dir&amp;gt;. Otherwise they are created in the current working directory. The default path can be set with the &lt;code&gt;format.outputDirectory&lt;/code&gt; configuration option. The &lt;code&gt;-o&lt;/code&gt; option takes precedence over &lt;code&gt;format.outputDirectory&lt;/code&gt;. To store patches in the current working directory even when &lt;code&gt;format.outputDirectory&lt;/code&gt; points elsewhere, use &lt;code&gt;-o .&lt;/code&gt;. All directory components will be created.</source>
          <target state="translated">場合 &lt;code&gt;-o&lt;/code&gt; が指定され、出力ファイルは、&amp;lt;ディレクトリ&amp;gt;に作成されます。それ以外の場合は、現在の作業ディレクトリに作成されます。デフォルトのパスは、 &lt;code&gt;format.outputDirectory&lt;/code&gt; 設定オプションで設定できます。 &lt;code&gt;-o&lt;/code&gt; オプションは、より優先されます &lt;code&gt;format.outputDirectory&lt;/code&gt; 。 &lt;code&gt;format.outputDirectory&lt;/code&gt; が別の場所を指している場合でも、現在の作業ディレクトリにパッチを保存するには、 &lt;code&gt;-o .&lt;/code&gt; 使用します。。すべてのディレクトリコンポーネントが作成されます。</target>
        </trans-unit>
        <trans-unit id="bbc0034ea645324d7719670d640dccda6b5513e5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-p&lt;/code&gt; is specified, the contents of &amp;lt;object&amp;gt; are pretty-printed.</source>
          <target state="translated">&lt;code&gt;-p&lt;/code&gt; が指定されている場合、&amp;lt;object&amp;gt;の内容がきれいに出力されます。</target>
        </trans-unit>
        <trans-unit id="49cafb1f81b012710180fa1719861bbc315bac4f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-s&lt;/code&gt; is specified, the size of the &amp;lt;object&amp;gt; in bytes.</source>
          <target state="translated">&lt;code&gt;-s&lt;/code&gt; が指定されている場合、&amp;lt;object&amp;gt;のサイズ（バイト単位）。</target>
        </trans-unit>
        <trans-unit id="859275c6340e08abbb3b87a577dd1f75bdf60296" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-t&lt;/code&gt; is specified, one of the &amp;lt;type&amp;gt;.</source>
          <target state="translated">&lt;code&gt;-t&lt;/code&gt; が指定されている場合、&amp;lt;type&amp;gt;の1つ。</target>
        </trans-unit>
        <trans-unit id="77cb52b6f5e5f8b68fe5657e97a4dba5f22808fe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-v&lt;/code&gt; is specified, the script reports what it is doing.</source>
          <target state="translated">場合は &lt;code&gt;-v&lt;/code&gt; が指定され、スクリプトはそれが何をしているか報告します。</target>
        </trans-unit>
        <trans-unit id="f7c94cac86b7d031a538f6e54d51ce5da54af947" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-z&lt;/code&gt; is specified, the pathnames in the output are delimited by the null character; if &lt;code&gt;--verbose&lt;/code&gt; is also specified then null characters are also used instead of colons and hard tabs:</source>
          <target state="translated">&lt;code&gt;-z&lt;/code&gt; が指定されている場合、出力のパス名はヌル文字で区切られます。 &lt;code&gt;--verbose&lt;/code&gt; も指定されている場合、コロンとハードタブの代わりにnull文字も使用されます。</target>
        </trans-unit>
        <trans-unit id="54b1b9cb08e8013285c455de408ae4d63672e927" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;GIT_TRACE2_BRIEF&lt;/code&gt; or &lt;code&gt;trace2.normalBrief&lt;/code&gt; is true, the &lt;code&gt;time&lt;/code&gt;, &lt;code&gt;filename&lt;/code&gt;, and &lt;code&gt;line&lt;/code&gt; fields are omitted.</source>
          <target state="translated">場合 &lt;code&gt;GIT_TRACE2_BRIEF&lt;/code&gt; または &lt;code&gt;trace2.normalBrief&lt;/code&gt; が真である、 &lt;code&gt;time&lt;/code&gt; 、 &lt;code&gt;filename&lt;/code&gt; 、および &lt;code&gt;line&lt;/code&gt; フィールドが省略されています。</target>
        </trans-unit>
        <trans-unit id="2e9a7edfc47ae5456f77e7777204d6f377e2ee4c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;GIT_TRACE2_EVENT_BRIEF&lt;/code&gt; or &lt;code&gt;trace2.eventBrief&lt;/code&gt; is true, the &lt;code&gt;file&lt;/code&gt; and &lt;code&gt;line&lt;/code&gt; fields are omitted from all events and the &lt;code&gt;time&lt;/code&gt; field is only present on the &quot;start&quot; and &quot;atexit&quot; events.</source>
          <target state="translated">場合 &lt;code&gt;GIT_TRACE2_EVENT_BRIEF&lt;/code&gt; または &lt;code&gt;trace2.eventBrief&lt;/code&gt; が trueで、 &lt;code&gt;file&lt;/code&gt; と &lt;code&gt;line&lt;/code&gt; のフィールドは、すべてのイベントから省略されていると &lt;code&gt;time&lt;/code&gt; フィールドは「開始」と「atexitを」イベントの唯一の存在です。</target>
        </trans-unit>
        <trans-unit id="1f02cbb9b13595b2ae6e45bc6f6b5fd9cfaab0a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;GIT_TRACE2_PERF_BRIEF&lt;/code&gt; or &lt;code&gt;trace2.perfBrief&lt;/code&gt; is true, the &lt;code&gt;time&lt;/code&gt;, &lt;code&gt;file&lt;/code&gt;, and &lt;code&gt;line&lt;/code&gt; fields are omitted.</source>
          <target state="translated">場合 &lt;code&gt;GIT_TRACE2_PERF_BRIEF&lt;/code&gt; または &lt;code&gt;trace2.perfBrief&lt;/code&gt; が真である、 &lt;code&gt;time&lt;/code&gt; 、 &lt;code&gt;file&lt;/code&gt; 、および &lt;code&gt;line&lt;/code&gt; フィールドが省略されています。</target>
        </trans-unit>
        <trans-unit id="ac54e4f3ca84b268e2b102a57942d2590e1ed97e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; configuration for the current branch &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; exists, that is the name of the branch at the remote site that is merged.</source>
          <target state="translated">もし &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; 現在のブランチの設定 &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; 存在している、それがマージされ、リモートサイトでブランチの名前です。</target>
        </trans-unit>
        <trans-unit id="0bbbd298acfcfe77553aeabe5dcce9895508b92f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;core.ignoreCase=true&lt;/code&gt;, then the pattern-matching algorithm will use a case-insensitive check. This corrects for case mismatched filenames in the &lt;code&gt;git sparse-checkout set&lt;/code&gt; command to reflect the expected cone in the working directory.</source>
          <target state="translated">&lt;code&gt;core.ignoreCase=true&lt;/code&gt; の場合、パターンマッチングアルゴリズムは大文字と小文字を区別しないチェックを使用します。これにより、 &lt;code&gt;git sparse-checkout set&lt;/code&gt; コマンドで大文字と小文字が一致しないファイル名が修正され、作業ディレクトリで予想されるコーンが反映されます。</target>
        </trans-unit>
        <trans-unit id="e0b5d0106d1c8675cc37e497ff6608e05f8526d9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;core.safecrlf&lt;/code&gt; is set to &quot;true&quot; or &quot;warn&quot;, Git verifies if the conversion is reversible for the current setting of &lt;code&gt;core.autocrlf&lt;/code&gt;. For &quot;true&quot;, Git rejects irreversible conversions; for &quot;warn&quot;, Git only prints a warning but accepts an irreversible conversion. The safety triggers to prevent such a conversion done to the files in the work tree, but there are a few exceptions. Even though&amp;hellip;​</source>
          <target state="translated">場合 &lt;code&gt;core.safecrlf&lt;/code&gt; は、「真」または「警告」のGit検証に設定されている変換は、現在の設定のための可逆的である場合 &lt;code&gt;core.autocrlf&lt;/code&gt; 。「true」の場合、Gitは元に戻せない変換を拒否します。「警告」の場合、Gitは警告のみを出力しますが、元に戻せない変換を受け入れます。安全性は、作業ツリー内のファイルに対して行われるこのような変換を防止するためにトリガーされますが、いくつかの例外があります。でも&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="a8fd82d7f01c8cd14090b39826adb8859d4c03b6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;core.sparseCheckoutCone=true&lt;/code&gt;, then Git will parse the sparse-checkout file expecting patterns of these types. Git will warn if the patterns do not match. If the patterns do match the expected format, then Git will use faster hash- based algorithms to compute inclusion in the sparse-checkout.</source>
          <target state="translated">場合 &lt;code&gt;core.sparseCheckoutCone=true&lt;/code&gt; の場合、Gitは、これらのタイプのパターンを期待スパース・チェックアウト・ファイルを解析します。パターンが一致しない場合、Gitは警告を出します。パターンが予想されるフォーマットと一致する場合、Gitはより高速なハッシュベースのアルゴリズムを使用して、スパースチェックアウトへの包含を計算します。</target>
        </trans-unit>
        <trans-unit id="9f2eb1f9e30347412b91990fde6d0d3118015f0c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;credential.helper&lt;/code&gt; is configured to the empty string, this resets the helper list to empty (so you may override a helper set by a lower-priority config file by configuring the empty-string helper, followed by whatever set of helpers you would like).</source>
          <target state="translated">場合 &lt;code&gt;credential.helper&lt;/code&gt; が空の文字列に設定されているあなたは、空の文字列ヘルパーを設定することによって、優先順位の低い設定ファイルによりヘルパーセットを無効にすることができるので、このリセットがヘルパーリスト（空にし、ご希望のヘルパーのどんなセットが続きます）。</target>
        </trans-unit>
        <trans-unit id="6f6bc24ce4d9cb03fd023baafceb347acba1bf38" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;git log&lt;/code&gt; and related commands will not treat the initial commit as a big creation event. Any root commits in &lt;code&gt;git log -p&lt;/code&gt; output would be shown without a diff attached. The default is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; の場合、 &lt;code&gt;git log&lt;/code&gt; および関連するコマンドは、最初のコミットを大きな作成イベントとして扱いません。 &lt;code&gt;git log -p&lt;/code&gt; の出力でのルートコミットは、diffを付けずに表示されます。デフォルトは &lt;code&gt;true&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="176a2b5b60655848aad57cb4f6f5216b8fca3bab" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;git merge-index&lt;/code&gt; is called with multiple &amp;lt;file&amp;gt;s (or -a) then it processes them in turn only stopping if merge returns a non-zero exit code.</source>
          <target state="translated">場合は &lt;code&gt;git merge-index&lt;/code&gt; 、複数の&amp;lt;ファイル&amp;gt; S（または-a）と呼ばれ、マージがゼロ以外の終了コードを返した場合、それが唯一の停止順番に処理します。</target>
        </trans-unit>
        <trans-unit id="806256aa8b91febcc951ef689b4cdbc521c56b19" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;git svn&lt;/code&gt; is configured to fetch branches (and --follow-branches is in effect), it sometimes creates multiple Git branches for one SVN branch, where the additional branches have names of the form &lt;code&gt;branchname@nnn&lt;/code&gt; (with nnn an SVN revision number). These additional branches are created if &lt;code&gt;git svn&lt;/code&gt; cannot find a parent commit for the first commit in an SVN branch, to connect the branch to the history of the other branches.</source>
          <target state="translated">場合は &lt;code&gt;git svn&lt;/code&gt; 枝フェッチするように設定されている（と--follow-枝を有効になっている）、それは時々 、追加の枝は、フォームの名前持っている1つのSVNブランチ、のために複数のGitのブランチを作成し &lt;code&gt;branchname@nnn&lt;/code&gt; （SVNのリビジョン番号NNNとの）。これらの追加ブランチは、 &lt;code&gt;git svn&lt;/code&gt; がSVNブランチの最初のコミットの親コミットを見つけられない場合に作成され、ブランチを他のブランチの履歴に接続します。</target>
        </trans-unit>
        <trans-unit id="ea83fb8f1cd42b6f4ec377884889f8ee539b7922" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;our&lt;/code&gt; version introduces whitespace changes but &lt;code&gt;their&lt;/code&gt; version includes a substantial change, &lt;code&gt;their&lt;/code&gt; version is used;</source>
          <target state="translated">場合は &lt;code&gt;our&lt;/code&gt; 変わりますが、空白バージョンの紹介 &lt;code&gt;their&lt;/code&gt; バージョンは実質的な変化が含まれ、 &lt;code&gt;their&lt;/code&gt; バージョンが使用されています。</target>
        </trans-unit>
        <trans-unit id="a540055d45818789fbb8422bbf0d3790f08d9718" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;repack.packKeptObjects&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, then any pack-files with an associated &lt;code&gt;.keep&lt;/code&gt; file will not be selected for the batch to repack.</source>
          <target state="translated">&lt;code&gt;repack.packKeptObjects&lt;/code&gt; が &lt;code&gt;false&lt;/code&gt; の場合、 &lt;code&gt;.keep&lt;/code&gt; ファイルが関連付けられているパックファイルは、バッチで再パックするために選択されません。</target>
        </trans-unit>
        <trans-unit id="9a3c5f8b5c3f8823d3bb0bf75c68202ef91e0068" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;status.submoduleSummary&lt;/code&gt; is set to a non zero number or true (identical to -1 or an unlimited number), the submodule summary will be enabled for the long format and a summary of commits for modified submodules will be shown (see --summary-limit option of &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt;). Please note that the summary output from the status command will be suppressed for all submodules when &lt;code&gt;diff.ignoreSubmodules&lt;/code&gt; is set to &lt;code&gt;all&lt;/code&gt; or only for those submodules where &lt;code&gt;submodule.&amp;lt;name&amp;gt;.ignore=all&lt;/code&gt;. To also view the summary for ignored submodules you can either use the --ignore-submodules=dirty command line option or the &lt;code&gt;git submodule summary&lt;/code&gt; command, which shows a similar output but does not honor these settings.</source>
          <target state="translated">&lt;code&gt;status.submoduleSummary&lt;/code&gt; がゼロ以外の数値またはtrue（-1または無制限の数値と同じ）に設定されている場合、サブモジュールの要約は長い形式で有効になり、変更されたサブモジュールのコミットの要約が表示されます（--summaryを参照）&lt;a href=&quot;git-submodule&quot;&gt;git-submodule [1]の&lt;/a&gt; -limitオプション）。statusコマンドからの要約出力は、 &lt;code&gt;diff.ignoreSubmodules&lt;/code&gt; が &lt;code&gt;all&lt;/code&gt; または &lt;code&gt;submodule.&amp;lt;name&amp;gt;.ignore=all&lt;/code&gt; であるサブモジュールに対してのみ設定されている場合、すべてのサブモジュールに対して抑制されることに注意してください。無視されたサブモジュールの要約も表示するには、-ignore-submodules = dirtyコマンドラインオプションまたは &lt;code&gt;git submodule summary&lt;/code&gt; 使用できます。 コマンドは、同様の出力を表示しますが、これらの設定を尊重しません。</target>
        </trans-unit>
        <trans-unit id="9e9c3270ca55bc57874ba3c8e582e2598d79892a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;subsystem&lt;/code&gt; is rebased against &lt;code&gt;master&lt;/code&gt;, the following happens:</source>
          <target state="translated">&lt;code&gt;subsystem&lt;/code&gt; 場合反対リベースされた &lt;code&gt;master&lt;/code&gt; 、次の処理が行われます。</target>
        </trans-unit>
        <trans-unit id="601fb7e577607a9227812e9cbf0586e6f099c5c2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;their&lt;/code&gt; version only introduces whitespace changes to a line, &lt;code&gt;our&lt;/code&gt; version is used;</source>
          <target state="translated">&lt;code&gt;their&lt;/code&gt; バージョンが行に空白の変更のみを導入する場合、 &lt;code&gt;our&lt;/code&gt; バージョンが使用されます。</target>
        </trans-unit>
        <trans-unit id="8afd53e5e6b34e88bd67e48774d4e9aa34d681c7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;git log&lt;/code&gt; and related commands will act as if the &lt;code&gt;--show-signature&lt;/code&gt; option was passed to them.</source>
          <target state="translated">場合は &lt;code&gt;true&lt;/code&gt; 、 &lt;code&gt;git log&lt;/code&gt; および関連コマンドがあるかのように動作します &lt;code&gt;--show-signature&lt;/code&gt; オプションが渡されたします。</target>
        </trans-unit>
        <trans-unit id="30fb3a857bee5620305914164cd0d4800cd1bf39" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;git log&lt;/code&gt; will act as if the &lt;code&gt;--follow&lt;/code&gt; option was used when a single &amp;lt;path&amp;gt; is given. This has the same limitations as &lt;code&gt;--follow&lt;/code&gt;, i.e. it cannot be used to follow multiple files and does not work well on non-linear history.</source>
          <target state="translated">場合は &lt;code&gt;true&lt;/code&gt; 、 &lt;code&gt;git log&lt;/code&gt; あるかのように動作します &lt;code&gt;--follow&lt;/code&gt; シングル&amp;lt;パス&amp;gt;が与えられたときにオプションが使用されました。これには &lt;code&gt;--follow&lt;/code&gt; と同じ制限があります。つまり、複数のファイルを追跡するために使用することはできず、非線形履歴ではうまく機能しません。</target>
        </trans-unit>
        <trans-unit id="1ee512d5daa33e9512f53b0ef8141d045d9eb4b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, indicate that the caller wants hash algorithm information to be passed back from the remote. This mode is used when fetching refs.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; の場合、呼び出し元がハッシュアルゴリズム情報をリモートから返すことを望んでいることを示します。このモードは、参照をフェッチするときに使用されます。</target>
        </trans-unit>
        <trans-unit id="e427e8f5bde6693ff553f72c72fbaf5c9a84e60f" translate="yes" xml:space="preserve">
          <source>If Alice wants to visualize what Bob did since their histories forked she can issue the following command:</source>
          <target state="translated">もしアリスがボブの歴史がフォークしてから何をしたかを可視化したい場合は、次のコマンドを実行してください。</target>
        </trans-unit>
        <trans-unit id="38d81a70b720705355c01f2f151a0b608b67e1f5" translate="yes" xml:space="preserve">
          <source>If Bob later decides to work from a different host, he can still perform clones and pulls using the ssh protocol:</source>
          <target state="translated">ボブが後で別のホストから作業することになっても、ssh プロトコルを使ってクローンやプルを実行することができます。</target>
        </trans-unit>
        <trans-unit id="906533644a5e321915983ba584ed131ee5f02be3" translate="yes" xml:space="preserve">
          <source>If X is found to be &quot;bad&quot;, then we know that its descendants are all &quot;bad&quot;, so we want to say that:</source>
          <target state="translated">Xが「悪い」と判明した場合は、その子孫がすべて「悪い」ということがわかるので、そう言いたくなります。</target>
        </trans-unit>
        <trans-unit id="585173cb924da5e21521ae8038b0882b2bd9054d" translate="yes" xml:space="preserve">
          <source>If X is found to be &quot;good&quot;, then we know that its ancestors are all &quot;good&quot;, so we want to say that:</source>
          <target state="translated">Xが「良い」と判明した場合、その先祖はすべて「良い」ということがわかっているので、そう言いたくなります。</target>
        </trans-unit>
        <trans-unit id="5b8abb6b4933866023868019ddfccc59a8fddfdf" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; is given, it is used as a shell wildcard to restrict the output to matching branches. If multiple patterns are given, a branch is shown if it matches any of the patterns.</source>
          <target state="translated">もし &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; 与えられ、マッチングブランチに出力を制限するシェルワイルドカードとして使用されます。複数のパターンが指定されている場合、いずれかのパターンに一致するとブランチが表示されます。</target>
        </trans-unit>
        <trans-unit id="9af8e725fef48828fa7bc334de43f0ec2851ec0b" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;merge&lt;/code&gt; command fails for any reason other than merge conflicts (i.e. when the merge operation did not even start), it is rescheduled immediately.</source>
          <target state="translated">もし &lt;code&gt;merge&lt;/code&gt; コマンドはマージの競合（つまり、マージ操作をしても起動しなかった場合）以外の理由で失敗し、それが即座に再スケジュールされます。</target>
        </trans-unit>
        <trans-unit id="78142494afa000f59dc94a96d37bd84306c42e5e" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;no-interactive-login&lt;/code&gt; command exists, then it is run and the interactive shell is aborted.</source>
          <target state="translated">もし &lt;code&gt;no-interactive-login&lt;/code&gt; コマンドが存在し、それが実行され、対話型シェルが中止されます。</target>
        </trans-unit>
        <trans-unit id="7f80f5447bc118a0311c9425234560dac2c0a613" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;pattern&lt;/code&gt; is given, only refs matching the given shell glob are shown. If the pattern does not contain a globbing character (&lt;code&gt;?&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, or &lt;code&gt;[&lt;/code&gt;), it is turned into a prefix match by appending &lt;code&gt;/*&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pattern&lt;/code&gt; が指定されている場合、指定されたシェルグロブに一致する参照のみが表示されます。パターンにグロビング文字（ &lt;code&gt;?&lt;/code&gt; 、 &lt;code&gt;*&lt;/code&gt; 、または &lt;code&gt;[&lt;/code&gt; ）が含まれていない場合は、追加することでプレフィックス一致に変換されます。 &lt;code&gt;/*&lt;/code&gt; をます。</target>
        </trans-unit>
        <trans-unit id="744bace39aac155f24f5426e32b134c34f641c3b" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;~/git-shell-commands&lt;/code&gt; directory is present, &lt;code&gt;git shell&lt;/code&gt; can also be run interactively (with no arguments). If a &lt;code&gt;help&lt;/code&gt; command is present in the &lt;code&gt;git-shell-commands&lt;/code&gt; directory, it is run to provide the user with an overview of allowed actions. Then a &quot;git&amp;gt; &quot; prompt is presented at which one can enter any of the commands from the &lt;code&gt;git-shell-commands&lt;/code&gt; directory, or &lt;code&gt;exit&lt;/code&gt; to close the connection.</source>
          <target state="translated">場合は &lt;code&gt;~/git-shell-commands&lt;/code&gt; ディレクトリが存在し、 &lt;code&gt;git shell&lt;/code&gt; また、（引数なしで）対話的に実行することができます。場合は &lt;code&gt;help&lt;/code&gt; コマンドが中に存在している &lt;code&gt;git-shell-commands&lt;/code&gt; ディレクトリ、許可されるアクションの概要をユーザに提供するために実行されます。次に、「git&amp;gt;」プロンプトが表示され、そこに &lt;code&gt;git-shell-commands&lt;/code&gt; ディレクトリから任意のコマンドを入力できます。または &lt;code&gt;exit&lt;/code&gt; して接続を閉じることができます。</target>
        </trans-unit>
        <trans-unit id="aa403bcc24255cf8941b29ab4148b7eee12a6185" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;~/git-shell-commands&lt;/code&gt; directory is present, &lt;code&gt;git shell&lt;/code&gt; will also handle other, custom commands by running &quot;&lt;code&gt;git-shell-commands/&amp;lt;command&amp;gt; &amp;lt;arguments&amp;gt;&lt;/code&gt;&quot; from the user&amp;rsquo;s home directory.</source>
          <target state="translated">場合は &lt;code&gt;~/git-shell-commands&lt;/code&gt; ディレクトリが存在し、 &lt;code&gt;git shell&lt;/code&gt; また、「実行することによって、他の、カスタムコマンドを処理します &lt;code&gt;git-shell-commands/&amp;lt;command&amp;gt; &amp;lt;arguments&amp;gt;&lt;/code&gt; ユーザのホームディレクトリから」。</target>
        </trans-unit>
        <trans-unit id="106b7929c0261fff657b2746b76dd80d35492e74" translate="yes" xml:space="preserve">
          <source>If a Git client that does not support the &lt;code&gt;working-tree-encoding&lt;/code&gt; attribute adds a new file &lt;code&gt;bar.ps1&lt;/code&gt;, then &lt;code&gt;bar.ps1&lt;/code&gt; will be stored &quot;as-is&quot; internally (in this example probably as UTF-16). A client with &lt;code&gt;working-tree-encoding&lt;/code&gt; support will interpret the internal contents as UTF-8 and try to convert it to UTF-16 on checkout. That operation will fail and cause an error.</source>
          <target state="translated">&lt;code&gt;working-tree-encoding&lt;/code&gt; 属性をサポートしないGitクライアントが新しいファイル &lt;code&gt;bar.ps1&lt;/code&gt; を追加すると、 &lt;code&gt;bar.ps1&lt;/code&gt; は「現状のまま」内部に格納されます（この例ではおそらくUTF-16として）。 &lt;code&gt;working-tree-encoding&lt;/code&gt; サポートするクライアントは、内部コンテンツをUTF-8として解釈し、チェックアウト時にそれをUTF-16に変換しようとします。その操作は失敗し、エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="84278502dbc74a9c4cc8dd831a2c5f189f159ac0" translate="yes" xml:space="preserve">
          <source>If a Git repository includes branches &lt;code&gt;refs/remotes/origin/p4&lt;/code&gt;, these will be fetched and consulted first during a &lt;code&gt;git p4 sync&lt;/code&gt;. Since importing directly from p4 is considerably slower than pulling changes from a Git remote, this can be useful in a multi-developer environment.</source>
          <target state="translated">Gitリポジトリにブランチ &lt;code&gt;refs/remotes/origin/p4&lt;/code&gt; が含まれている場合、これらは &lt;code&gt;git p4 sync&lt;/code&gt; 中に最初にフェッチされ、参照されます。p4から直接インポートすることは、Gitリモートから変更をプルするよりもかなり遅いので、これはマルチ開発環境で役立ちます。</target>
        </trans-unit>
        <trans-unit id="af291be12b7b5a290c76485729b6b8f4918ca983" translate="yes" xml:space="preserve">
          <source>If a command, or a guide, is given, a manual page for that command or guide is brought up. The &lt;code&gt;man&lt;/code&gt; program is used by default for this purpose, but this can be overridden by other options or configuration variables.</source>
          <target state="translated">コマンドまたはガイドを指定すると、そのコマンドまたはガイドのマニュアルページが表示されます。の &lt;code&gt;man&lt;/code&gt; プログラムは、この目的のためにデフォルトで使用されるが、これは他のオプションや設定変数で上書きすることができます。</target>
        </trans-unit>
        <trans-unit id="72743ffe0426b38cdd1755e732e28a11a9ff3a78" translate="yes" xml:space="preserve">
          <source>If a commit being cherry picked duplicates a commit already in the current history, it will become empty. By default these redundant commits cause &lt;code&gt;cherry-pick&lt;/code&gt; to stop so the user can examine the commit. This option overrides that behavior and creates an empty commit object. Implies &lt;code&gt;--allow-empty&lt;/code&gt;.</source>
          <target state="translated">チェリーピックされているコミットが現在の履歴にすでにあるコミットを複製する場合、それは空になります。デフォルトでは、これらの冗長なコミットにより &lt;code&gt;cherry-pick&lt;/code&gt; が停止するため、ユーザーはコミットを調べることができます。このオプションはその動作を上書きし、空のコミットオブジェクトを作成します。意味 &lt;code&gt;--allow-empty&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4b42bbbaf339d6cf05d45edbdf2ada972df70aa1" translate="yes" xml:space="preserve">
          <source>If a diff tool is not specified, &lt;code&gt;git difftool&lt;/code&gt; will use the configuration variable &lt;code&gt;diff.tool&lt;/code&gt;. If the configuration variable &lt;code&gt;diff.tool&lt;/code&gt; is not set, &lt;code&gt;git difftool&lt;/code&gt; will pick a suitable default.</source>
          <target state="translated">差分ツールが指定されていない場合、 &lt;code&gt;git difftool&lt;/code&gt; は設定変数 &lt;code&gt;diff.tool&lt;/code&gt; を使用します。設定変数 &lt;code&gt;diff.tool&lt;/code&gt; が設定されていない場合、 &lt;code&gt;git difftool&lt;/code&gt; は適切なデフォルトを選択します。</target>
        </trans-unit>
        <trans-unit id="a8ee98dcb134f1a2c8067ffe5665347c4c70f9e4" translate="yes" xml:space="preserve">
          <source>If a fatal error occurs, the program writes the error message to stderr and exits. The caller should expect that a suitable error message has been printed if the child closes the connection without completing a valid response for the current command.</source>
          <target state="translated">致命的なエラーが発生した場合、プログラムはエラーメッセージを stderr に書き込んで終了します。呼び出し側は、現在のコマンドに対する有効な応答を完了せずに子プロセスが接続を終了した場合、適切なエラーメッセージが出力されることを期待しなければなりません。</target>
        </trans-unit>
        <trans-unit id="571d71cd29e09f41d5c855a2a419d634cc0eecce" translate="yes" xml:space="preserve">
          <source>If a filter &lt;code&gt;must&lt;/code&gt; succeed in order to make the stored contents usable, you can declare that the filter is &lt;code&gt;required&lt;/code&gt;, in the configuration:</source>
          <target state="translated">保存されたコンテンツを使用可能にするためにフィルター &lt;code&gt;must&lt;/code&gt; 成功する &lt;code&gt;required&lt;/code&gt; 場合は、構成でフィルターが必須であることを宣言できます。</target>
        </trans-unit>
        <trans-unit id="22e70bb4ff6d3a3dd5464ffc106fa14107a4c8dc" translate="yes" xml:space="preserve">
          <source>If a git directory of a submodule is inside the submodule, move the git directory of the submodule into its superproject&amp;rsquo;s &lt;code&gt;$GIT_DIR/modules&lt;/code&gt; path and then connect the git directory and its working directory by setting the &lt;code&gt;core.worktree&lt;/code&gt; and adding a .git file pointing to the git directory embedded in the superprojects git directory.</source>
          <target state="translated">サブモジュールのgitディレクトリがサブモジュール内にある場合は、サブモジュールのgitディレクトリをスーパー &lt;code&gt;$GIT_DIR/modules&lt;/code&gt; の$ GIT_DIR / modulesパスに &lt;code&gt;core.worktree&lt;/code&gt; し、core.worktreeを設定して.gitファイルを追加することにより、gitディレクトリとその作業ディレクトリを接続します。スーパープロジェクトのgitディレクトリに埋め込まれたgitディレクトリに。</target>
        </trans-unit>
        <trans-unit id="7b7f1fa74f78e5b674bbee244bef979691bc168d" translate="yes" xml:space="preserve">
          <source>If a helper advertises &lt;code&gt;connect&lt;/code&gt;, Git will use it if possible and fall back to another capability if the helper requests so when connecting (see the &lt;code&gt;connect&lt;/code&gt; command under COMMANDS). When choosing between &lt;code&gt;fetch&lt;/code&gt; and &lt;code&gt;import&lt;/code&gt;, Git prefers &lt;code&gt;fetch&lt;/code&gt;. Other frontends may have some other order of preference.</source>
          <target state="translated">ヘルパーが &lt;code&gt;connect&lt;/code&gt; をアドバタイズした場合、Gitは可能であればそれを使用し、ヘルパーが接続時に要求した場合は別の機能にフォールバックします（COMMANDSの下の &lt;code&gt;connect&lt;/code&gt; コマンドを参照）。 &lt;code&gt;fetch&lt;/code&gt; と &lt;code&gt;import&lt;/code&gt; どちらかを選択する場合、Gitは &lt;code&gt;fetch&lt;/code&gt; 優先します。他のフロントエンドには、他の優先順位がある場合があります。</target>
        </trans-unit>
        <trans-unit id="148562d25b0603b8eee662bc94ef7dd269783449" translate="yes" xml:space="preserve">
          <source>If a helper advertises &lt;code&gt;connect&lt;/code&gt;, Git will use it if possible and fall back to another capability if the helper requests so when connecting (see the &lt;code&gt;connect&lt;/code&gt; command under COMMANDS). When choosing between &lt;code&gt;push&lt;/code&gt; and &lt;code&gt;export&lt;/code&gt;, Git prefers &lt;code&gt;push&lt;/code&gt;. Other frontends may have some other order of preference.</source>
          <target state="translated">ヘルパーが &lt;code&gt;connect&lt;/code&gt; をアドバタイズした場合、Gitは可能であればそれを使用し、ヘルパーが接続時に要求した場合は別の機能にフォールバックします（COMMANDSの下の &lt;code&gt;connect&lt;/code&gt; コマンドを参照）。 &lt;code&gt;push&lt;/code&gt; と &lt;code&gt;export&lt;/code&gt; どちらかを選択する場合、Gitは &lt;code&gt;push&lt;/code&gt; 優先しますます。他のフロントエンドには、他の優先順位がある場合があります。</target>
        </trans-unit>
        <trans-unit id="fa7f2d8c2e0ee7753a285dedc0954f30b43daa88" translate="yes" xml:space="preserve">
          <source>If a helper fails to perform the requested operation or needs to notify the user of a potential issue, it may write to stderr.</source>
          <target state="translated">ヘルパーが要求された操作の実行に失敗したり、潜在的な問題をユーザに通知する必要がある場合、標準エラーに書き込むことがあります。</target>
        </trans-unit>
        <trans-unit id="2388ab5f8918a49ad2647c3d1835f78b1fd11f78" translate="yes" xml:space="preserve">
          <source>If a helper outputs a &lt;code&gt;quit&lt;/code&gt; attribute with a value of &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt;, no further helpers will be consulted, nor will the user be prompted (if no credential has been provided, the operation will then fail).</source>
          <target state="translated">ヘルパーが &lt;code&gt;true&lt;/code&gt; または &lt;code&gt;1&lt;/code&gt; の値で &lt;code&gt;quit&lt;/code&gt; 属性を出力した場合、それ以上のヘルパーは参照されず、ユーザーにプロンプ​​トも表示されません（資格情報が提供されていない場合、操作は失敗します）。</target>
        </trans-unit>
        <trans-unit id="79eaf960175c04b54e3507607c968b768d5dc83c" translate="yes" xml:space="preserve">
          <source>If a helper receives any other operation, it should silently ignore the request. This leaves room for future operations to be added (older helpers will just ignore the new requests).</source>
          <target state="translated">ヘルパーが他の操作を受けた場合、そのリクエストを黙って無視するべきです。これは将来の操作を追加する余地を残します (古いヘルパーは新しいリクエストを無視するだけです)。</target>
        </trans-unit>
        <trans-unit id="3c8d1c4561ad329297670b7c11b5cea0c040fa93" translate="yes" xml:space="preserve">
          <source>If a line exists in both the source and destination, exists only once, and starts with this text, this algorithm attempts to prevent it from appearing as a deletion or addition in the output. It uses the &quot;patience diff&quot; algorithm internally.</source>
          <target state="translated">行がソースとデスティネーションの両方に存在し、一度だけ存在し、このテキストで始まる場合、このアルゴリズムは、それが出力の中で削除または追加として現れるのを防ごうとします。このアルゴリズムは、内部的には &quot;patience diff&quot; アルゴリズムを使用します。</target>
        </trans-unit>
        <trans-unit id="03800f18f812afe9c365f3cd10e3618c12ca274e" translate="yes" xml:space="preserve">
          <source>If a linked working tree is stored on a portable device or network share which is not always mounted, you can prevent its administrative files from being pruned by issuing the &lt;code&gt;git worktree lock&lt;/code&gt; command, optionally specifying &lt;code&gt;--reason&lt;/code&gt; to explain why the working tree is locked.</source>
          <target state="translated">リンクされた作業ツリーが、常にマウントされているわけではないポータブルデバイスまたはネットワーク共有に保存されている場合は、オプションで &lt;code&gt;--reason&lt;/code&gt; を指定して &lt;code&gt;git worktree lock&lt;/code&gt; コマンドを発行することにより、管理ファイルが整理されないようにすることができます。をて作業ツリーがロックされている理由を説明する。</target>
        </trans-unit>
        <trans-unit id="055300f804a90741eca19d86c43f3b133b4438b5" translate="yes" xml:space="preserve">
          <source>If a merge resolution program is not specified, &lt;code&gt;git mergetool&lt;/code&gt; will use the configuration variable &lt;code&gt;merge.tool&lt;/code&gt;. If the configuration variable &lt;code&gt;merge.tool&lt;/code&gt; is not set, &lt;code&gt;git mergetool&lt;/code&gt; will pick a suitable default.</source>
          <target state="translated">マージ解決プログラムが指定されていない場合、 &lt;code&gt;git mergetool&lt;/code&gt; は構成変数 &lt;code&gt;merge.tool&lt;/code&gt; を使用します。構成変数 &lt;code&gt;merge.tool&lt;/code&gt; が設定されていない場合は、 &lt;code&gt;git mergetool&lt;/code&gt; は適切なデフォルトを選択します。</target>
        </trans-unit>
        <trans-unit id="1ea5bcda19ff920edc6797065824126354674b5b" translate="yes" xml:space="preserve">
          <source>If a name is specified on stdin that cannot be resolved to an object in the repository, then &lt;code&gt;cat-file&lt;/code&gt; will ignore any custom format and print:</source>
          <target state="translated">stdinで、リポジトリ内のオブジェクトに解決できない名前が指定されている場合、 &lt;code&gt;cat-file&lt;/code&gt; はカスタム形式を無視して印刷します。</target>
        </trans-unit>
        <trans-unit id="b64d6e7bd6f81b6c41d97bf3465e33dac59a1923" translate="yes" xml:space="preserve">
          <source>If a name is specified that might refer to more than one object (an ambiguous short sha), then &lt;code&gt;cat-file&lt;/code&gt; will ignore any custom format and print:</source>
          <target state="translated">複数のオブジェクト（あいまいな短い文字）を参照する可能性がある名前が指定されている場合、 &lt;code&gt;cat-file&lt;/code&gt; 文字はカスタム形式を無視して印刷します。</target>
        </trans-unit>
        <trans-unit id="6e4b893bbe0d833def4e5b2195c3efca0abfc652" translate="yes" xml:space="preserve">
          <source>If a namespace is in use, the namespace prefix is stripped from each reference before it is matched against &lt;code&gt;transfer.hiderefs&lt;/code&gt; patterns. For example, if &lt;code&gt;refs/heads/master&lt;/code&gt; is specified in &lt;code&gt;transfer.hideRefs&lt;/code&gt; and the current namespace is &lt;code&gt;foo&lt;/code&gt;, then &lt;code&gt;refs/namespaces/foo/refs/heads/master&lt;/code&gt; is omitted from the advertisements but &lt;code&gt;refs/heads/master&lt;/code&gt; and &lt;code&gt;refs/namespaces/bar/refs/heads/master&lt;/code&gt; are still advertised as so-called &quot;have&quot; lines. In order to match refs before stripping, add a &lt;code&gt;^&lt;/code&gt; in front of the ref name. If you combine &lt;code&gt;!&lt;/code&gt; and &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;!&lt;/code&gt; must be specified first.</source>
          <target state="translated">名前空間が使用されている場合、名前空間接頭辞は &lt;code&gt;transfer.hiderefs&lt;/code&gt; パターンと照合される前に各参照から削除されます。たとえば、 &lt;code&gt;refs/heads/master&lt;/code&gt; が &lt;code&gt;transfer.hideRefs&lt;/code&gt; で指定されていて、現在のネームスペースが &lt;code&gt;foo&lt;/code&gt; の場合、 &lt;code&gt;refs/namespaces/foo/refs/heads/master&lt;/code&gt; は広告から除外されますが、 &lt;code&gt;refs/heads/master&lt;/code&gt; および &lt;code&gt;refs/namespaces/bar/refs/heads/master&lt;/code&gt; は、いわゆる「持つ」行として引き続きアドバタイズされます。ストリッピングの前に参照を照合するには、参照名の前に &lt;code&gt;^&lt;/code&gt; を追加します。組み合わせれば &lt;code&gt;!&lt;/code&gt; そして、 &lt;code&gt;^&lt;/code&gt; 、 &lt;code&gt;!&lt;/code&gt; 最初に指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="01a3979b0db1ea5ddb68d8d2296f1a14d4a19443" translate="yes" xml:space="preserve">
          <source>If a positive depth is requested, the server will compute the set of commits which are no deeper than the desired depth.</source>
          <target state="translated">正の深さが要求された場合、サーバは希望する深さよりも深くないコミットのセットを計算します。</target>
        </trans-unit>
        <trans-unit id="1af76a23a450746535be3f72c4b4bca12a2092d2" translate="yes" xml:space="preserve">
          <source>If a push would not result in a &lt;a href=&quot;#fast-forwards&quot;&gt;fast-forward&lt;/a&gt; of the remote branch, then it will fail with an error like:</source>
          <target state="translated">プッシュが&lt;a href=&quot;#fast-forwards&quot;&gt;早送りに&lt;/a&gt;ならない場合リモートブランチがようなエラーで失敗します。</target>
        </trans-unit>
        <trans-unit id="74746f4cd8d12a2fd7c6b3eb595d0f3e0b5c16c7" translate="yes" xml:space="preserve">
          <source>If a reflog entry&amp;rsquo;s predecessor is pruned, adjust its &quot;old&quot; SHA-1 to be equal to the &quot;new&quot; SHA-1 field of the entry that now precedes it.</source>
          <target state="translated">reflogエントリの前身がプルーニングされている場合は、その「古い」SHA-1を調整して、その前にあるエントリの「新しい」SHA-1フィールドと等しくなるようにします。</target>
        </trans-unit>
        <trans-unit id="335f210edb83cade21599987ff0ffeaab940885d" translate="yes" xml:space="preserve">
          <source>If a refspec is prefixed by &lt;code&gt;^&lt;/code&gt;, it will be interpreted as a negative refspec. Rather than specifying which refs to fetch or which local refs to update, such a refspec will instead specify refs to exclude. A ref will be considered to match if it matches at least one positive refspec, and does not match any negative refspec. Negative refspecs can be useful to restrict the scope of a pattern refspec so that it will not include specific refs. Negative refspecs can themselves be pattern refspecs. However, they may only contain a &amp;lt;src&amp;gt; and do not specify a &amp;lt;dst&amp;gt;. Fully spelled out hex object names are also not supported.</source>
          <target state="translated">refspecの前に &lt;code&gt;^&lt;/code&gt; が付いている場合、それは負のrefspecとして解釈されます。このようなrefspecは、フェッチする参照や更新するローカル参照を指定するのではなく、除外する参照を指定します。 refは、少なくとも1つの正のrefspecに一致し、負のrefspecに一致しない場合、一致すると見なされます。負のrefspecは、特定のrefが含まれないように、パターンrefspecのスコープを制限するのに役立ちます。負のrefspecは、それ自体がパターンrefspecである可能性があります。ただし、&amp;lt;src&amp;gt;のみを含めることができ、&amp;lt;dst&amp;gt;を指定することはできません。完全にスペルアウトされた16進オブジェクト名もサポートされていません。</target>
        </trans-unit>
        <trans-unit id="6545e25a03004b7b80ff7680d7d52c75ae528db2" translate="yes" xml:space="preserve">
          <source>If a specified file is in the index but is missing then it&amp;rsquo;s removed. Default behavior is to ignore removed file.</source>
          <target state="translated">指定したファイルがインデックスに含まれているが見つからない場合は、削除されます。デフォルトの動作では、削除されたファイルは無視されます。</target>
        </trans-unit>
        <trans-unit id="0b6d50904501e60c5730f3fc1689dbda57685832" translate="yes" xml:space="preserve">
          <source>If a specified file isn&amp;rsquo;t in the index already then it&amp;rsquo;s added. Default behaviour is to ignore new files.</source>
          <target state="translated">指定されたファイルがまだインデックスにない場合は、追加されます。デフォルトの動作では、新しいファイルを無視します。</target>
        </trans-unit>
        <trans-unit id="a14dea6ce44fe61b94cf6eca48f584619dca6981" translate="yes" xml:space="preserve">
          <source>If a subject is not found in the patch description the patch name is preserved as the 1 line subject in the Git description.</source>
          <target state="translated">もしパッチの説明文の中にサブジェクトが見つからなかった場合は、Git の説明文の中の 1 行目のサブジェクトとしてパッチ名が保存されます。</target>
        </trans-unit>
        <trans-unit id="511834d1553ad3d02aefac42a3d932c821a68c9a" translate="yes" xml:space="preserve">
          <source>If a version-1 repository specifies any &lt;code&gt;extensions.*&lt;/code&gt; keys that the running git has not implemented, the operation MUST NOT proceed. Similarly, if the value of any known key is not understood by the implementation, the operation MUST NOT proceed.</source>
          <target state="translated">バージョン1リポジトリが、実行中のgitが実装していない &lt;code&gt;extensions.*&lt;/code&gt; キーを指定している場合、操作を続行してはなりません（MUST NOT）。同様に、既知のキーの値が実装によって理解されない場合、操作を続行してはなりません（MUST NOT）。</target>
        </trans-unit>
        <trans-unit id="7fc57bcdf92fac8f6a715a452b985f9026a5a582" translate="yes" xml:space="preserve">
          <source>If a whole directory is classified as &quot;other&quot;, show just its name (with a trailing slash) and not its whole contents.</source>
          <target state="translated">ディレクトリ全体が &quot;other &quot;に分類されている場合は、そのディレクトリ名(末尾にスラッシュをつけて)だけを表示し、内容全体は表示しません。</target>
        </trans-unit>
        <trans-unit id="9069929e0dad6127e4d7686101bafb1ad2a53dfd" translate="yes" xml:space="preserve">
          <source>If a working tree is deleted without using &lt;code&gt;git worktree remove&lt;/code&gt;, then its associated administrative files, which reside in the repository (see &quot;DETAILS&quot; below), will eventually be removed automatically (see &lt;code&gt;gc.worktreePruneExpire&lt;/code&gt; in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;), or you can run &lt;code&gt;git worktree prune&lt;/code&gt; in the main or any linked working tree to clean up any stale administrative files.</source>
          <target state="translated">&lt;code&gt;git worktree remove&lt;/code&gt; を使用せずに作業ツリーを削除すると、リポジトリにある関連する管理ファイル（以下の「詳細」を参照）が最終的に自動的に削除されます（&lt;a href=&quot;git-config&quot;&gt;git-config [1]の&lt;/a&gt; &lt;code&gt;gc.worktreePruneExpire&lt;/code&gt; を参照）、または &lt;code&gt;git worktree prune&lt;/code&gt; を実行できます、メインまたはリンクされた作業ツリーでをして、古い管理ファイルをクリーンアップできます。</target>
        </trans-unit>
        <trans-unit id="601f99371e1781bbcc6e4fbcb70987193e9cb892" translate="yes" xml:space="preserve">
          <source>If a working tree is on a portable device or network share which is not always mounted, lock it to prevent its administrative files from being pruned automatically. This also prevents it from being moved or deleted. Optionally, specify a reason for the lock with &lt;code&gt;--reason&lt;/code&gt;.</source>
          <target state="translated">作業ツリーが、常にマウントされるわけではないポータブルデバイスまたはネットワーク共有上にある場合は、それをロックして、管理ファイルが自動的に整理されないようにします。これにより、移動や削除もできなくなります。オプションで、ロックの理由を &lt;code&gt;--reason&lt;/code&gt; で指定します。</target>
        </trans-unit>
        <trans-unit id="4c89355d42dbc93622cf0025bcf122df76b472f1" translate="yes" xml:space="preserve">
          <source>If advertised, indicates that any number of server specific options can be included in a request. This is done by sending each option as a &quot;server-option=&amp;lt;option&amp;gt;&quot; capability line in the capability-list section of a request.</source>
          <target state="translated">アドバタイズされている場合、サーバー固有のオプションをいくつでもリクエストに含めることができることを示します。これは、要求の機能リストセクションの「server-option = &amp;lt;option&amp;gt;」機能行として各オプションを送信することによって行われます。</target>
        </trans-unit>
        <trans-unit id="c768073bebd10b960d1a77545805ba6684f69c55" translate="yes" xml:space="preserve">
          <source>If after this parent rewriting, &lt;code&gt;C'&lt;/code&gt; is a root or merge commit (has zero or &amp;gt;1 parents), a boundary commit, or !TREESAME, it remains. Otherwise, it is replaced with its only parent.</source>
          <target state="translated">この親の書き換え後、 &lt;code&gt;C'&lt;/code&gt; がルートまたはマージコミット（親がゼロまたは&amp;gt; 1）、境界コミット、または！TREESAMEである場合、それは残ります。それ以外の場合は、唯一の親に置き換えられます。</target>
        </trans-unit>
        <trans-unit id="331241d5d1136bad0fab6978a8eab7a815b255e9" translate="yes" xml:space="preserve">
          <source>If all &amp;lt;ref&amp;gt;s can be locked with matching &amp;lt;oldvalue&amp;gt;s simultaneously, all modifications are performed. Otherwise, no modifications are performed. Note that while each individual &amp;lt;ref&amp;gt; is updated or deleted atomically, a concurrent reader may still see a subset of the modifications.</source>
          <target state="translated">すべての&amp;lt;ref&amp;gt;を一致する&amp;lt;oldvalue&amp;gt;で同時にロックできる場合、すべての変更が実行されます。それ以外の場合、変更は実行されません。個々の&amp;lt;ref&amp;gt;はアトミックに更新または削除されますが、並行読み取りでは引き続き変更のサブセットが表示される場合があります。</target>
        </trans-unit>
        <trans-unit id="f2745e08ed788856c12f02ca7a5befc54f3c9443" translate="yes" xml:space="preserve">
          <source>If all named commits are already ancestors of &lt;code&gt;HEAD&lt;/code&gt;, &lt;code&gt;git merge&lt;/code&gt; will exit early with the message &quot;Already up to date.&quot;</source>
          <target state="translated">すべての名前付きコミットがすでに &lt;code&gt;HEAD&lt;/code&gt; の祖先である場合、 &lt;code&gt;git merge&lt;/code&gt; は「Already up to date」というメッセージとともに早期に終了します。</target>
        </trans-unit>
        <trans-unit id="cf6cb5a66ab4b3c3c33160d1bdddf3e27a51bd6e" translate="yes" xml:space="preserve">
          <source>If all you really want to do is to remove from the index the files that are no longer present in the working tree (perhaps because your working tree is dirty so that you cannot use &lt;code&gt;git commit -a&lt;/code&gt;), use the following command:</source>
          <target state="translated">作業ツリーに存在しなくなったファイルをインデックスから削除するだけの場合（おそらく、作業ツリーがダーティで &lt;code&gt;git commit -a&lt;/code&gt; を使用できないため）、次のコマンドを使用します。</target>
        </trans-unit>
        <trans-unit id="232e0a33b39a8eedbea0de34207896fce9d5da1b" translate="yes" xml:space="preserve">
          <source>If an SVN revision has a property, &quot;svm:headrev&quot;, it is likely that the revision was created by SVN::Mirror (also used by SVK). The property contains a repository UUID and a revision. We want to make it look like we are mirroring the original URL, so introduce a helper function that returns the original identity URL and UUID, and use it when generating metadata in commit messages.</source>
          <target state="translated">SVN リビジョンに &quot;svm:headrev&quot; というプロパティがある場合、そのリビジョンは SVN::Mirror (SVK でも使用されている)によって作成されたものである可能性が高いです。このプロパティには、リポジトリのUUIDとリビジョンが含まれています。元のURLをミラーリングしているように見せたいので、元のID URLとUUIDを返すヘルパー関数を導入し、コミットメッセージでメタデータを生成する際に利用します。</target>
        </trans-unit>
        <trans-unit id="8ec6058ea575ab09ff2743fac6f67664b17c975f" translate="yes" xml:space="preserve">
          <source>If an alias is given, git shows the definition of the alias on standard output. To get the manual page for the aliased command, use &lt;code&gt;git COMMAND --help&lt;/code&gt;.</source>
          <target state="translated">エイリアスが指定されている場合、gitは標準出力にエイリアスの定義を表示します。エイリアスコマンドのマニュアルページを取得するには、 &lt;code&gt;git COMMAND --help&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="06b64f77884080bf4b8a1b3580804b4fc90c62bc" translate="yes" xml:space="preserve">
          <source>If an exact match was not found, &lt;code&gt;git describe&lt;/code&gt; will walk back through the commit history to locate an ancestor commit which has been tagged. The ancestor&amp;rsquo;s tag will be output along with an abbreviation of the input commit-ish&amp;rsquo;s SHA-1. If &lt;code&gt;--first-parent&lt;/code&gt; was specified then the walk will only consider the first parent of each commit.</source>
          <target state="translated">完全に一致するものが見つからなかった場合、 &lt;code&gt;git describe&lt;/code&gt; はコミット履歴をさかのぼって、タグ付けされている祖先コミットを見つけます。祖先のタグは、入力commit-ishのSHA-1の省略形とともに出力されます。場合 &lt;code&gt;--first-parent&lt;/code&gt; 指定された後、徒歩でのみ各コミットの最初の親を検討します。</target>
        </trans-unit>
        <trans-unit id="98c6f5f40e2b8ae0667cb14d2e8af19ba85f9e07" translate="yes" xml:space="preserve">
          <source>If an existing replace ref for the same object exists, it will be overwritten (instead of failing).</source>
          <target state="translated">同じオブジェクトに対する既存の置換refが存在する場合、それは上書きされます(失敗するのではなく)。</target>
        </trans-unit>
        <trans-unit id="046c10da2487af8c5911472dad4ec66653003b0a" translate="yes" xml:space="preserve">
          <source>If any &amp;lt;file&amp;gt; does not appear in the index, treat this as an error (return 1).</source>
          <target state="translated">&amp;lt;file&amp;gt;がインデックスに表示されない場合は、これをエラーとして扱います（戻り1）。</target>
        </trans-unit>
        <trans-unit id="d5c329c54100c9f229f2bd1af9a36354df219a33" translate="yes" xml:space="preserve">
          <source>If any evaluation of &amp;lt;command&amp;gt; returns a non-zero exit status, the whole operation will be aborted.</source>
          <target state="translated">&amp;lt;command&amp;gt;の評価でゼロ以外の終了ステータスが返された場合、操作全体が中止されます。</target>
        </trans-unit>
        <trans-unit id="939ada40ab0c594838b538aaf9b14ce39d17200d" translate="yes" xml:space="preserve">
          <source>If any file doesn&amp;rsquo;t begin with a From line, assume it is a single mail message instead of signaling error.</source>
          <target state="translated">From行で始まらないファイルがある場合は、エラーを通知するのではなく、単一のメールメッセージであると想定します。</target>
        </trans-unit>
        <trans-unit id="824867a2502f9c0cf53ed6a13fd4b286bb82c4ed" translate="yes" xml:space="preserve">
          <source>If any files that should not be normalized show up in &lt;code&gt;git status&lt;/code&gt;, unset their &lt;code&gt;text&lt;/code&gt; attribute before running &lt;code&gt;git add -u&lt;/code&gt;.</source>
          <target state="translated">正規化してはならないファイルが &lt;code&gt;git status&lt;/code&gt; で表示される場合は、 &lt;code&gt;git add -u&lt;/code&gt; を実行する前に、 &lt;code&gt;text&lt;/code&gt; 属性の設定を解除してください。</target>
        </trans-unit>
        <trans-unit id="8c34b6095a9c49861d2acc43610b57c3a4a36934" translate="yes" xml:space="preserve">
          <source>If any files were ever &quot;cvs import&quot;ed more than once (e.g., import of more than one vendor release) the HEAD contains the wrong content.</source>
          <target state="translated">ファイルが複数回 &quot;cvs.import&quot; されたことがある場合 (例えば、複数のベンダリリースのインポート)は、HEAD には間違った内容が含まれています。</target>
        </trans-unit>
        <trans-unit id="8a184d41ad4c8629ad4f2bce24803b0c9fa2c0bb" translate="yes" xml:space="preserve">
          <source>If any of the remote changes overlap with local uncommitted changes, the merge will be automatically canceled and the work tree untouched. It is generally best to get any local changes in working order before pulling or stash them away with &lt;a href=&quot;git-stash&quot;&gt;git-stash[1]&lt;/a&gt;.</source>
          <target state="translated">リモートの変更のいずれかがローカルのコミットされていない変更と重複する場合、マージは自動的にキャンセルされ、作業ツリーは変更されません。一般的に、&lt;a href=&quot;git-stash&quot;&gt;git-stash [1]を使用&lt;/a&gt;してプルまたはスタッシュする前に、ローカルの変更を作業順序で取得するのが最善です。</target>
        </trans-unit>
        <trans-unit id="27aabdb37af0432fadcd5ffecc44449505cac9be" translate="yes" xml:space="preserve">
          <source>If any optional &lt;code&gt;&amp;lt;path&amp;gt;...&lt;/code&gt; arguments are given, only those paths are affected.</source>
          <target state="translated">オプションの &lt;code&gt;&amp;lt;path&amp;gt;...&lt;/code&gt; 引数を指定すると、それらのパスのみが影響を受けます。</target>
        </trans-unit>
        <trans-unit id="d20da8878e924b8ea99ba5928199985d6eb45c5b" translate="yes" xml:space="preserve">
          <source>If at least one of the specified mechanisms matches the ones advertised by the SMTP server and if it is supported by the utilized SASL library, the mechanism is used for authentication. If neither &lt;code&gt;sendemail.smtpAuth&lt;/code&gt; nor &lt;code&gt;--smtp-auth&lt;/code&gt; is specified, all mechanisms supported by the SASL library can be used. The special value &lt;code&gt;none&lt;/code&gt; maybe specified to completely disable authentication independently of &lt;code&gt;--smtp-user&lt;/code&gt;</source>
          <target state="translated">指定されたメカニズムの少なくとも1つがSMTPサーバーによってアドバタイズされたメカニズムと一致し、利用されているSASLライブラリによってサポートされている場合、メカニズムは認証に使用されます。 &lt;code&gt;sendemail.smtpAuth&lt;/code&gt; も &lt;code&gt;--smtp-auth&lt;/code&gt; も指定されていない場合は、SASLライブラリでサポートされているすべてのメカニズムを使用できます。 &lt;code&gt;--smtp-user&lt;/code&gt; とは無関係に認証を完全に無効にするために、特別な値 &lt;code&gt;none&lt;/code&gt; が指定されている可能性があります</target>
        </trans-unit>
        <trans-unit id="48ca5fe331a67872cf3424cd090943cee3b1214a" translate="yes" xml:space="preserve">
          <source>If config parameter &quot;core.logAllRefUpdates&quot; is true and the ref is one under &quot;refs/heads/&quot;, &quot;refs/remotes/&quot;, &quot;refs/notes/&quot;, or a pseudoref like HEAD or ORIG_HEAD; or the file &quot;$GIT_DIR/logs/&amp;lt;ref&amp;gt;&quot; exists then &lt;code&gt;git update-ref&lt;/code&gt; will append a line to the log file &quot;$GIT_DIR/logs/&amp;lt;ref&amp;gt;&quot; (dereferencing all symbolic refs before creating the log name) describing the change in ref value. Log lines are formatted as:</source>
          <target state="translated">構成パラメーター &quot;core.logAllRefUpdates&quot;がtrueで、refが &quot;refs / heads /&quot;、 &quot;refs / remotes /&quot;、 &quot;refs / notes /&quot;の下にある場合、またはHEADやORIG_HEADなどの疑似参照。または、ファイル「$ GIT_DIR / logs / &amp;lt;ref&amp;gt;」が存在する場合、gitupdate &lt;code&gt;git update-ref&lt;/code&gt; はログファイル「$ GIT_DIR / logs / &amp;lt;ref&amp;gt;」（ログ名を作成する前にすべてのシンボリック参照を参照解除）に、参照値の変更。ログ行の形式は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="d66be204c5192d97175dc2e5a6cea91a845a9494" translate="yes" xml:space="preserve">
          <source>If config parameter &quot;core.logAllRefUpdates&quot; is true and the ref is one under &quot;refs/heads/&quot;, &quot;refs/remotes/&quot;, &quot;refs/notes/&quot;, or the symbolic ref HEAD; or the file &quot;$GIT_DIR/logs/&amp;lt;ref&amp;gt;&quot; exists then &lt;code&gt;git update-ref&lt;/code&gt; will append a line to the log file &quot;$GIT_DIR/logs/&amp;lt;ref&amp;gt;&quot; (dereferencing all symbolic refs before creating the log name) describing the change in ref value. Log lines are formatted as:</source>
          <target state="translated">構成パラメーター「core.logAllRefUpdates」がtrueで、refが「refs / heads /」、「refs / remotes /」、「refs / notes /」、またはシンボリック参照HEADの下にある場合、または、ファイル &quot;$ GIT_DIR / logs / &amp;lt;ref&amp;gt;&quot;が存在する場合、 &lt;code&gt;git update-ref&lt;/code&gt; はログファイル &quot;$ GIT_DIR / logs / &amp;lt;ref&amp;gt;&quot;に行を追加します（ログ名を作成する前にすべてのシンボリック参照を参照します）。参照値の変更。ログの行は次のような形式です。</target>
        </trans-unit>
        <trans-unit id="bb79d7b0840991ebe429aab3a3410932b975f32c" translate="yes" xml:space="preserve">
          <source>If conflicts arise and a strategy for automatically resolving conflicting notes (see the &quot;NOTES MERGE STRATEGIES&quot; section) is not given, the &quot;manual&quot; resolver is used. This resolver checks out the conflicting notes in a special worktree (&lt;code&gt;.git/NOTES_MERGE_WORKTREE&lt;/code&gt;), and instructs the user to manually resolve the conflicts there. When done, the user can either finalize the merge with &lt;code&gt;git notes merge --commit&lt;/code&gt;, or abort the merge with &lt;code&gt;git notes merge --abort&lt;/code&gt;.</source>
          <target state="translated">競合が発生し、競合するメモを自動的に解決する方法（「注意のマージ戦略」のセクションを参照）が指定されていない場合は、「手動」リゾルバーが使用されます。このリゾルバーは、特別なワークツリー（ &lt;code&gt;.git/NOTES_MERGE_WORKTREE&lt;/code&gt; ）内の競合するメモをチェックアウトし、競合を手動で解決するようユーザーに指示します。完了したら、ユーザーは &lt;code&gt;git notes merge --commit&lt;/code&gt; を使用してマージを終了するか、git notes merge --abortを使用してマージを中止 &lt;code&gt;git notes merge --abort&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="a02a69db3092fb7486e9bff9ff76c98958fe4d57" translate="yes" xml:space="preserve">
          <source>If core.commitGraph is true, the commit-graph file will also be inspected using &lt;code&gt;git commit-graph verify&lt;/code&gt;. See &lt;a href=&quot;git-commit-graph&quot;&gt;git-commit-graph[1]&lt;/a&gt;.</source>
          <target state="translated">core.commitGraphがtrueの場合、コミットグラフファイルも &lt;code&gt;git commit-graph verify&lt;/code&gt; を使用して検査されます。&lt;a href=&quot;git-commit-graph&quot;&gt;git-commit-graph [1]を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="8280fdd5ec3fb25317b497d70f747c3177f7ef0e" translate="yes" xml:space="preserve">
          <source>If disabled with &quot;--no-thread&quot;, those headers will not be added (unless specified with --in-reply-to). Default is the value of the &lt;code&gt;sendemail.thread&lt;/code&gt; configuration value; if that is unspecified, default to --thread.</source>
          <target state="translated">「--no-thread」で無効にすると、それらのヘッダーは追加されません（--in-reply-toで指定されていない場合）。デフォルトは &lt;code&gt;sendemail.thread&lt;/code&gt; 構成値の値です。これが指定されていない場合、デフォルトで--threadになります。</target>
        </trans-unit>
        <trans-unit id="f00c2d7bc0317e9cad287fad199ae73edff4a848" translate="yes" xml:space="preserve">
          <source>If either &amp;lt;upstream&amp;gt; or --root is given on the command line, then the default is &lt;code&gt;--no-fork-point&lt;/code&gt;, otherwise the default is &lt;code&gt;--fork-point&lt;/code&gt;.</source>
          <target state="translated">コマンドラインで&amp;lt;upstream&amp;gt;または--rootのいずれかが指定されている場合、デフォルトは &lt;code&gt;--no-fork-point&lt;/code&gt; です。それ以外の場合、デフォルトは &lt;code&gt;--fork-point&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="a4729a11522c55d49b0e7c329a8805975c4198d9" translate="yes" xml:space="preserve">
          <source>If either of these environment variables is set then &lt;code&gt;git fetch&lt;/code&gt; and &lt;code&gt;git push&lt;/code&gt; will use the specified command instead of &lt;code&gt;ssh&lt;/code&gt; when they need to connect to a remote system. The command-line parameters passed to the configured command are determined by the ssh variant. See &lt;code&gt;ssh.variant&lt;/code&gt; option in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for details.</source>
          <target state="translated">これらの環境変数のいずれかが設定されている場合、 &lt;code&gt;git fetch&lt;/code&gt; および &lt;code&gt;git push&lt;/code&gt; は、リモートシステムに接続する必要があるときに、 &lt;code&gt;ssh&lt;/code&gt; ではなく指定されたコマンドを使用します。設定されたコマンドに渡されるコマンドラインパラメータは、sshバリアントによって決定されます。詳細については、&lt;a href=&quot;git-config&quot;&gt;git-config [1]の&lt;/a&gt; &lt;code&gt;ssh.variant&lt;/code&gt; オプションを参照してください。</target>
        </trans-unit>
        <trans-unit id="3669ee4e6fd1ff3473f59b85f73b98bc8093a5f0" translate="yes" xml:space="preserve">
          <source>If enabled the helper should automatically fetch annotated tag objects if the object the tag points at was transferred during the fetch command. If the tag is not fetched by the helper a second fetch command will usually be sent to ask for the tag specifically. Some helpers may be able to use this option to avoid a second network connection.</source>
          <target state="translated">有効にすると、タグが指すオブジェクトがフェッチコマンドの間に転送された場合、ヘルパーは注釈付きタグオブジェクトを自動的にフェッチします。タグがヘルパーによってフェッチされなかった場合、通常、2回目のフェッチコマンドが送信され、タグを特定するように要求されます。ヘルパーによっては、2回目のネットワーク接続を避けるためにこのオプションを使用することができるかもしれません。</target>
        </trans-unit>
        <trans-unit id="27acfa87cdb69a824b9bae48206b42168ffde848" translate="yes" xml:space="preserve">
          <source>If enabled, &lt;code&gt;git p4 submit&lt;/code&gt; will attempt to cleanup RCS keywords ($Header$, etc). These would otherwise cause merge conflicts and prevent the submit going ahead. This option should be considered experimental at present.</source>
          <target state="translated">有効に &lt;code&gt;git p4 submit&lt;/code&gt; と、git p4 submitはRCSキーワード（$ Header $など）のクリーンアップを試みます。そうしないと、マージの競合が発生し、送信が続行できなくなります。このオプションは、現時点では実験的であると考える必要があります。</target>
        </trans-unit>
        <trans-unit id="551059a87916480f640c4e8b1f0ae5467d5d2b16" translate="yes" xml:space="preserve">
          <source>If everything fails, or if no viewer is configured, the viewer specified in the &lt;code&gt;GIT_MAN_VIEWER&lt;/code&gt; environment variable will be tried. If that fails too, the &lt;code&gt;man&lt;/code&gt; program will be tried anyway.</source>
          <target state="translated">すべてが失敗した場合、またはビューアーが構成されていない場合は、 &lt;code&gt;GIT_MAN_VIEWER&lt;/code&gt; 環境変数で指定されたビューアーが試行されます。それも失敗した場合は、 &lt;code&gt;man&lt;/code&gt; プログラムがとにかく試されます。</target>
        </trans-unit>
        <trans-unit id="dc951917b8a4344a8f095e91594828b8eb0d132d" translate="yes" xml:space="preserve">
          <source>If explicit refspecs were given on the command line of &lt;code&gt;git pull&lt;/code&gt;, they are all merged.</source>
          <target state="translated">&lt;code&gt;git pull&lt;/code&gt; のコマンドラインで明示的なrefspecが指定されている場合、それらはすべてマージされます。</target>
        </trans-unit>
        <trans-unit id="9f9421c37df0f080e8411a466937f35ec8c1d1a5" translate="yes" xml:space="preserve">
          <source>If false, symbolic links are checked out as small plain files that contain the link text. &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt; and &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; will not change the recorded type to regular file. Useful on filesystems like FAT that do not support symbolic links.</source>
          <target state="translated">falseの場合、シンボリックリンクは、リンクテキストを含む小さなプレーンファイルとしてチェックアウトされます。&lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]&lt;/a&gt;と&lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt;は、記録されたタイプを通常のファイルに変更しません。シンボリックリンクをサポートしないFATなどのファイルシステムで役立ちます。</target>
        </trans-unit>
        <trans-unit id="8463a48927d35802080dff1be147345270adfa9a" translate="yes" xml:space="preserve">
          <source>If false, the ctime differences between the index and the working tree are ignored; useful when the inode change time is regularly modified by something outside Git (file system crawlers and some backup systems). See &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt;. True by default.</source>
          <target state="translated">falseの場合、インデックスと作業ツリーの間のctimeの違いは無視されます。 iノードの変更時刻がGit外の何か（ファイルシステムクローラーと一部のバックアップシステム）によって定期的に変更される場合に役立ちます。&lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]を&lt;/a&gt;参照してください。デフォルトではTrue。</target>
        </trans-unit>
        <trans-unit id="c3b2c82ffccecb89175e5c1911567eb5a6cff2f5" translate="yes" xml:space="preserve">
          <source>If fast-import is supplied invalid input it will terminate with a non-zero exit status and create a crash report in the top level of the Git repository it was importing into. Crash reports contain a snapshot of the internal fast-import state as well as the most recent commands that lead up to the crash.</source>
          <target state="translated">不正な入力が与えられた場合は、ゼロ以外の終了ステータスで終了し、インポート先の Git リポジトリのトップレベルにクラッシュレポートが作成されます。クラッシュレポートには、内部の fast-import の状態のスナップショットと、それに至るまでの直近のコマンドが含まれます。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
