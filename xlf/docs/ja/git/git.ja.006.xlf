<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="git">
    <body>
      <group id="git">
        <trans-unit id="b4b929406272978e9913bc69bd98a25fedb2b075" translate="yes" xml:space="preserve">
          <source>If generating diffs, detect and report renames for each commit. For following files across renames while traversing history, see &lt;code&gt;--follow&lt;/code&gt;. If &lt;code&gt;n&lt;/code&gt; is specified, it is a threshold on the similarity index (i.e. amount of addition/deletions compared to the file&amp;rsquo;s size). For example, &lt;code&gt;-M90%&lt;/code&gt; means Git should consider a delete/add pair to be a rename if more than 90% of the file hasn&amp;rsquo;t changed. Without a &lt;code&gt;%&lt;/code&gt; sign, the number is to be read as a fraction, with a decimal point before it. I.e., &lt;code&gt;-M5&lt;/code&gt; becomes 0.5, and is thus the same as &lt;code&gt;-M50%&lt;/code&gt;. Similarly, &lt;code&gt;-M05&lt;/code&gt; is the same as &lt;code&gt;-M5%&lt;/code&gt;. To limit detection to exact renames, use &lt;code&gt;-M100%&lt;/code&gt;. The default similarity index is 50%.</source>
          <target state="translated">差分を生成する場合は、コミットごとに名前の変更を検出して報告します。履歴をトラバースしながら名前を変更してファイルを &lt;code&gt;--follow&lt;/code&gt; するには、-- followを参照してください。 &lt;code&gt;n&lt;/code&gt; が指定されている場合、それは類似性インデックス（つまり、ファイルのサイズと比較した追加/削除の量）のしきい値です。たとえば、 &lt;code&gt;-M90%&lt;/code&gt; は、ファイルの90％以上が変更されていない場合、Gitが削除/追加ペアを名前変更と見なす必要があることを意味します。 &lt;code&gt;%&lt;/code&gt; 記号を付けない場合、数値は小数部として読み取られ、その前に小数点が付きます。 &lt;code&gt;-M5&lt;/code&gt; 、-M5は0.5になるため、 &lt;code&gt;-M50%&lt;/code&gt; と同じです。同様に、 &lt;code&gt;-M05&lt;/code&gt; は &lt;code&gt;-M5%&lt;/code&gt; と同じです。検出を正確な名前変更に制限するには、次を使用します &lt;code&gt;-M100%&lt;/code&gt; を。デフォルトの類似性インデックスは50％です。</target>
        </trans-unit>
        <trans-unit id="6bf34c88ee2af8f797d0000ddc97681383ffc8ba" translate="yes" xml:space="preserve">
          <source>If git fetch fails because the new head of a branch is not a descendant of the old head, you may force the update with:</source>
          <target state="translated">ブランチの新しい先頭が古い先頭の子孫ではないという理由で git fetch が失敗した場合は、次のようにして強制的に更新することができます。</target>
        </trans-unit>
        <trans-unit id="e083719ea272a39b1421c558e4392c556db2e4ef" translate="yes" xml:space="preserve">
          <source>If given &lt;code&gt;--thread&lt;/code&gt;, &lt;code&gt;git-format-patch&lt;/code&gt; will generate &lt;code&gt;In-Reply-To&lt;/code&gt; and &lt;code&gt;References&lt;/code&gt; headers to make the second and subsequent patch mails appear as replies to the first mail; this also generates a &lt;code&gt;Message-Id&lt;/code&gt; header to reference.</source>
          <target state="translated">&lt;code&gt;--thread&lt;/code&gt; を指定した場合、 &lt;code&gt;git-format-patch&lt;/code&gt; は &lt;code&gt;In-Reply-To&lt;/code&gt; および &lt;code&gt;References&lt;/code&gt; ヘッダーを生成して、2番目以降のパッチメールを最初のメールへの返信として表示します。これにより、参照する &lt;code&gt;Message-Id&lt;/code&gt; ヘッダーも生成されます。</target>
        </trans-unit>
        <trans-unit id="b8bcbf4a83fcf4f75c98a2212241bdcbc1331a73" translate="yes" xml:space="preserve">
          <source>If given, limit the search to paths matching at least one pattern. Both leading paths match and glob(7) patterns are supported.</source>
          <target state="translated">与えられた場合は、少なくとも 1 つのパターンにマッチするパスに限定して検索します。先頭のパスがマッチするものと glob(7)パターンの両方がサポートされています。</target>
        </trans-unit>
        <trans-unit id="0f1d3c019382d162e2080cbdc28ed58b9e3bfa0a" translate="yes" xml:space="preserve">
          <source>If given, strings that substitute &lt;code&gt;%(fieldname)&lt;/code&gt; placeholders are quoted as string literals suitable for the specified host language. This is meant to produce a scriptlet that can directly be `eval`ed.</source>
          <target state="translated">指定した場合、 &lt;code&gt;%(fieldname)&lt;/code&gt; プレースホルダーを置換する文字列は、指定したホスト言語に適した文字列リテラルとして引用されます。これは、直接「評価」できるスクリプトレットを生成するためのものです。</target>
        </trans-unit>
        <trans-unit id="fbaedaa3bd6d3e9940a1f51ae6f8f8f02a814640" translate="yes" xml:space="preserve">
          <source>If history is linear and HEAD is an ancestor of next, update the working tree and advance the HEAD pointer to match next. Otherwise, apply the changes introduced by those commits that are in next but not HEAD to the current branch, creating a new commit for each new change.</source>
          <target state="translated">履歴が線形で、HEAD が next の祖先である場合、作業ツリーを更新して HEAD ポインタを next に合わせて進めます。そうでない場合は、next にあるが HEAD ではないコミットによって導入された変更を現在のブランチに適用し、新しい変更ごとに新しいコミットを作成します。</target>
        </trans-unit>
        <trans-unit id="c5f1ba7eca8a5dae95e4277b8eb6e331cbac924e" translate="yes" xml:space="preserve">
          <source>If it does not apply correctly, there can be various reasons.</source>
          <target state="translated">正しく適用されない場合は、様々な理由が考えられます。</target>
        </trans-unit>
        <trans-unit id="50113fb63d9da87174eb94266585c5426270510c" translate="yes" xml:space="preserve">
          <source>If it does not support the requested operation (e.g., a read-only store), it should silently ignore the request.</source>
          <target state="translated">要求された操作(例えば、読み取り専用のストア)をサポートしていない場合は、要求を黙って無視するべきです。</target>
        </trans-unit>
        <trans-unit id="527b079607be5b2a4ead185d633224b57d83444a" translate="yes" xml:space="preserve">
          <source>If it exits with non-zero status, then the working tree will not be committed after applying the patch.</source>
          <target state="translated">ゼロ以外の状態で終了した場合、パッチ適用後の作業ツリーはコミットされません。</target>
        </trans-unit>
        <trans-unit id="769efb2c6e10769ef0506d8fb6e30821bd41e6ea" translate="yes" xml:space="preserve">
          <source>If it happens that one merge base is bad, then the bisection process is stopped with a message like:</source>
          <target state="translated">1つのマージベースに不良が発生した場合は、次のようなメッセージで二等化処理を停止します。</target>
        </trans-unit>
        <trans-unit id="d7b7066e9f3ba640d6b7d345ddda270a80c2a559" translate="yes" xml:space="preserve">
          <source>If it is &lt;code&gt;after&lt;/code&gt;, then each new trailer will appear just after the last trailer with the same &amp;lt;token&amp;gt;.</source>
          <target state="translated">の &lt;code&gt;after&lt;/code&gt; である場合、新しい各トレーラーは、同じ&amp;lt;token&amp;gt;を持つ最後のトレーラーの直後に表示されます。</target>
        </trans-unit>
        <trans-unit id="f2bafbae3498cf1dc8b7c4f581b63d0bfa115d9a" translate="yes" xml:space="preserve">
          <source>If it is &lt;code&gt;before&lt;/code&gt;, then each new trailer will appear just before the first trailer with the same &amp;lt;token&amp;gt;.</source>
          <target state="translated">&lt;code&gt;before&lt;/code&gt; の場合、新しい各トレーラーは、同じ&amp;lt;token&amp;gt;を持つ最初のトレーラーの直前に表示されます。</target>
        </trans-unit>
        <trans-unit id="76425e0a50de1913b3cc7557f216714041d9e64a" translate="yes" xml:space="preserve">
          <source>If it is &lt;code&gt;end&lt;/code&gt;, then each new trailer will appear at the end of the existing trailers.</source>
          <target state="translated">&lt;code&gt;end&lt;/code&gt; の場合、新しいトレーラーはそれぞれ既存のトレーラーの最後に表示されます。</target>
        </trans-unit>
        <trans-unit id="df34e468f7176e0de86a55be70b61c5f69c7697c" translate="yes" xml:space="preserve">
          <source>If it is &lt;code&gt;start&lt;/code&gt;, then each new trailer will appear at the start, instead of the end, of the existing trailers.</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; の場合、新しい各トレーラーは、既存のトレーラーの最後ではなく、最初に表示されます。</target>
        </trans-unit>
        <trans-unit id="4def1637480df26c3310f2a04dde58c55a8e6a6e" translate="yes" xml:space="preserve">
          <source>If it is set to true, git-fetch-pack will check all fetched objects. See &lt;code&gt;transfer.fsckObjects&lt;/code&gt; for what&amp;rsquo;s checked. Defaults to false. If not set, the value of &lt;code&gt;transfer.fsckObjects&lt;/code&gt; is used instead.</source>
          <target state="translated">trueに設定されている場合、git-fetch-packはフェッチされたすべてのオブジェクトをチェックします。何がチェック &lt;code&gt;transfer.fsckObjects&lt;/code&gt; れるかについては、transfer.fsckObjectsを参照してください。デフォルトはfalseです。設定されていない場合は、代わりに &lt;code&gt;transfer.fsckObjects&lt;/code&gt; の値が使用されます。</target>
        </trans-unit>
        <trans-unit id="c85a90553a06232b5ee8a2aebb2a31cb696c1660" translate="yes" xml:space="preserve">
          <source>If it is set to true, git-receive-pack will check all received objects. See &lt;code&gt;transfer.fsckObjects&lt;/code&gt; for what&amp;rsquo;s checked. Defaults to false. If not set, the value of &lt;code&gt;transfer.fsckObjects&lt;/code&gt; is used instead.</source>
          <target state="translated">trueに設定すると、git-receive-packは受信したすべてのオブジェクトをチェックします。何がチェック &lt;code&gt;transfer.fsckObjects&lt;/code&gt; れるかについては、transfer.fsckObjectsを参照してください。デフォルトはfalseです。設定されていない場合は、代わりに &lt;code&gt;transfer.fsckObjects&lt;/code&gt; の値が使用されます。</target>
        </trans-unit>
        <trans-unit id="f046c10bd7462cc956529dcbe0a86de2200086ed" translate="yes" xml:space="preserve">
          <source>If it turns out whatever you have done is worth keeping, you can always create a new name for it (without switching away):</source>
          <target state="translated">あなたがしたことが何であれ、それが維持する価値があることが判明した場合、あなたは常にそれのための新しい名前を作成することができます(離れて切り替えることなく)。</target>
        </trans-unit>
        <trans-unit id="4d0ff556eb63bcc0fd849ad26a1310c3a4323d31" translate="yes" xml:space="preserve">
          <source>If it&amp;rsquo;s not set, filesystem directory&amp;rsquo;s owner is used (via GECOS field, i.e. real name field from &lt;strong&gt;getpwuid&lt;/strong&gt;(3)) if &lt;code&gt;$projects_list&lt;/code&gt; is unset (gitweb scans &lt;code&gt;$projectroot&lt;/code&gt; for repositories); if &lt;code&gt;$projects_list&lt;/code&gt; points to file with list of repositories, then project owner defaults to value from this file for given repository.</source>
          <target state="translated">これが設定されていない場合、 &lt;code&gt;$projects_list&lt;/code&gt; が設定されていなければ（GECOSフィールド、つまり&lt;strong&gt;getpwuid&lt;/strong&gt;（3）の実名フィールドを介して）ファイルシステムディレクトリの所有者が使用されます（gitwebが &lt;code&gt;$projectroot&lt;/code&gt; projectroot でリポジトリをスキャンします）; &lt;code&gt;$projects_list&lt;/code&gt; がリポジトリーのリストを含むファイルを指す場合、プロジェクト所有者はデフォルトで、指定されたリポジトリーのこのファイルからの値に設定します。</target>
        </trans-unit>
        <trans-unit id="1cadf23ffce6eccc7a87c304031ef4b8e4d3adc6" translate="yes" xml:space="preserve">
          <source>If large offsets are required, we use another list of large offsets similar to version 2 pack-indexes.</source>
          <target state="translated">大きなオフセットが必要な場合は、バージョン2のpack-indexesと同様の別の大きなオフセットのリストを使用します。</target>
        </trans-unit>
        <trans-unit id="960d179c1e161024bf740912a06839844c1002e6" translate="yes" xml:space="preserve">
          <source>If left to accumulate, these stale references might make performance worse on big and busy repos that have a lot of branch churn, and e.g. make the output of commands like &lt;code&gt;git branch -a --contains
&amp;lt;commit&amp;gt;&lt;/code&gt; needlessly verbose, as well as impacting anything else that&amp;rsquo;ll work with the complete set of known references.</source>
          <target state="translated">蓄積するために残された場合、これらの古い参照は、多くのブランチチャーンを持つ大きくて忙しいリポジトリでパフォーマンスを悪化させる可能性があります。たとえば、 &lt;code&gt;git branch -a --contains &amp;lt;commit&amp;gt;&lt;/code&gt; ようなコマンドの出力を不要にし、影響を与える既知の参照の完全なセットで動作する他のすべて。</target>
        </trans-unit>
        <trans-unit id="703f6583148f1f4b148dcc92cca37187812e5840" translate="yes" xml:space="preserve">
          <source>If merge is called without any commit argument, merge the upstream branches configured for the current branch by using their last observed values stored in their remote-tracking branches. The values of the &lt;code&gt;branch.&amp;lt;current branch&amp;gt;.merge&lt;/code&gt; that name the branches at the remote named by &lt;code&gt;branch.&amp;lt;current branch&amp;gt;.remote&lt;/code&gt; are consulted, and then they are mapped via &lt;code&gt;remote.&amp;lt;remote&amp;gt;.fetch&lt;/code&gt; to their corresponding remote-tracking branches, and the tips of these tracking branches are merged.</source>
          <target state="translated">commit引数を指定せずにmergeが呼び出された場合は、リモート追跡ブランチに格納されている最後の監視値を使用して、現在のブランチに構成されている上流ブランチをマージします。値が &lt;code&gt;branch.&amp;lt;current branch&amp;gt;.merge&lt;/code&gt; その名前リモートで命名さで枝 &lt;code&gt;branch.&amp;lt;current branch&amp;gt;.remote&lt;/code&gt; 協議され、その後、それらを経由してマッピングされ &lt;code&gt;remote.&amp;lt;remote&amp;gt;.fetch&lt;/code&gt; それらに対応するリモート-へ追跡ブランチ、およびこれらの追跡ブランチのヒントがマージされます。</target>
        </trans-unit>
        <trans-unit id="115451ca901f83782dcbbcd683a49aed658e9f54" translate="yes" xml:space="preserve">
          <source>If more than one --branches (or --tags) option was given to the &lt;code&gt;init&lt;/code&gt; or &lt;code&gt;clone&lt;/code&gt; command, you must provide the location of the branch (or tag) you wish to create in the SVN repository. &amp;lt;path&amp;gt; specifies which path to use to create the branch or tag and should match the pattern on the left-hand side of one of the configured branches or tags refspecs. You can see these refspecs with the commands</source>
          <target state="translated">&lt;code&gt;init&lt;/code&gt; コマンドまたは &lt;code&gt;clone&lt;/code&gt; コマンドに複数の--branches（または--tags）オプションが指定されている場合は、SVNリポジトリで作成するブランチ（またはタグ）の場所を指定する必要があります。&amp;lt;path&amp;gt;は、ブランチまたはタグの作成に使用するパスを指定し、構成済みのブランチまたはタグのrefspecの左側のパターンに一致する必要があります。これらのrefspecは次のコマンドで確認できます</target>
        </trans-unit>
        <trans-unit id="720d1ff370baad05fcb8565540994e450819ec63" translate="yes" xml:space="preserve">
          <source>If more than one suffixes match the same tagname, then that tagname will be sorted according to the suffix which starts at the earliest position in the tagname. If more than one different matching suffixes start at that earliest position, then that tagname will be sorted according to the longest of those suffixes. The sorting order between different suffixes is undefined if they are in multiple config files.</source>
          <target state="translated">同じタグ名に複数の接尾辞が一致する場合、そのタグ名は、タグ名の中で最も古い位置から始まる接尾辞に従ってソートされます。複数の異なる一致する接尾辞がその最も古い位置から始まる場合、そのタグ名は、それらの接尾辞の中で最も長い接尾辞に基づいてソートされます。異なるサフィックス間のソート順は、それらが複数の設定ファイルにある場合は定義されていません。</target>
        </trans-unit>
        <trans-unit id="e3ac1856f1f0f57064ddb5057de6638c24881f47" translate="yes" xml:space="preserve">
          <source>If multiple tags were found during the walk then the tag which has the fewest commits different from the input commit-ish will be selected and output. Here fewest commits different is defined as the number of commits which would be shown by &lt;code&gt;git log tag..input&lt;/code&gt; will be the smallest number of commits possible.</source>
          <target state="translated">ウォーク中に複数のタグが見つかった場合は、入力コミットとは異なるコミットが最も少ないタグが選択され、出力されます。ここで、異なる最も少ないコミットは、 &lt;code&gt;git log tag..input&lt;/code&gt; によって表示されるコミットの数として定義されます。入力は、可能な最小のコミット数になります。</target>
        </trans-unit>
        <trans-unit id="a7822ac9c32ce308a5503a1fdd5fe89ff6cb69d3" translate="yes" xml:space="preserve">
          <source>If neither of the above exist then &lt;code&gt;$XDG_CONFIG_HOME/git/gitk&lt;/code&gt; is created and used by default. If &lt;code&gt;$XDG_CONFIG_HOME&lt;/code&gt; is not set it defaults to &lt;code&gt;$HOME/.config&lt;/code&gt; in all cases.</source>
          <target state="translated">上記のどちらも存在しない場合は、デフォルトで &lt;code&gt;$XDG_CONFIG_HOME/git/gitk&lt;/code&gt; が作成され、使用されます。 &lt;code&gt;$XDG_CONFIG_HOME&lt;/code&gt; が設定されていない場合は、デフォルトですべて &lt;code&gt;$HOME/.config&lt;/code&gt; に設定されます。</target>
        </trans-unit>
        <trans-unit id="cd81c5109f07b879105adf39e250a5f3aca1a356" translate="yes" xml:space="preserve">
          <source>If neither was used, but &lt;code&gt;--date&lt;/code&gt; was given on the command line, show the timestamp in the format requested by &lt;code&gt;--date&lt;/code&gt;.</source>
          <target state="translated">どちらも使用されていないが、コマンドラインで &lt;code&gt;--date&lt;/code&gt; が指定されている場合、タイムスタンプを &lt;code&gt;--date&lt;/code&gt; で要求された形式で表示します。</target>
        </trans-unit>
        <trans-unit id="a3bb0635e00afaf46918027a40807c06a70ce207" translate="yes" xml:space="preserve">
          <source>If no &amp;lt;pathspec&amp;gt; is given when &lt;code&gt;-A&lt;/code&gt; option is used, all files in the entire working tree are updated (old versions of Git used to limit the update to the current directory and its subdirectories).</source>
          <target state="translated">&lt;code&gt;-A&lt;/code&gt; オプションを使用するときに&amp;lt;pathspec&amp;gt;を指定しないと、作業ツリー全体のすべてのファイルが更新されます（現在のディレクトリとそのサブディレクトリへの更新を制限するために使用されていたGitの古いバージョン）。</target>
        </trans-unit>
        <trans-unit id="4b6e9bfea0c02571aea512af96edfe88c9715f04" translate="yes" xml:space="preserve">
          <source>If no &amp;lt;pathspec&amp;gt; is given when &lt;code&gt;-u&lt;/code&gt; option is used, all tracked files in the entire working tree are updated (old versions of Git used to limit the update to the current directory and its subdirectories).</source>
          <target state="translated">&lt;code&gt;-u&lt;/code&gt; オプションを使用するときに&amp;lt;pathspec&amp;gt;を指定しないと、作業ツリー全体のすべての追跡ファイルが更新されます（更新を現在のディレクトリとそのサブディレクトリに制限するために使用されていたGitの古いバージョン）。</target>
        </trans-unit>
        <trans-unit id="4b6d20762b018937bfcb3d137cde943022a33140" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;--decorate-refs&lt;/code&gt; is given, pretend as if all refs were included. For each candidate, do not use it for decoration if it matches any patterns given to &lt;code&gt;--decorate-refs-exclude&lt;/code&gt; or if it doesn&amp;rsquo;t match any of the patterns given to &lt;code&gt;--decorate-refs&lt;/code&gt;.</source>
          <target state="translated">何場合 &lt;code&gt;--decorate-refs&lt;/code&gt; 与えられていないすべての引用文献が含まれているかのように、ふりをします。それが与えられた任意のパターンと一致した場合、各候補者のために、装飾のためにそれを使用していない &lt;code&gt;--decorate-refs-exclude&lt;/code&gt; するか、に与えられたパターンのいずれとも一致しない場合 &lt;code&gt;--decorate-refs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d7cc86d2479ae0db7a8477b9df1f3902cf870395" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;--decorate-refs&lt;/code&gt; is given, pretend as if all refs were included. For each candidate, do not use it for decoration if it matches any patterns given to &lt;code&gt;--decorate-refs-exclude&lt;/code&gt; or if it doesn&amp;rsquo;t match any of the patterns given to &lt;code&gt;--decorate-refs&lt;/code&gt;. The &lt;code&gt;log.excludeDecoration&lt;/code&gt; config option allows excluding refs from the decorations, but an explicit &lt;code&gt;--decorate-refs&lt;/code&gt; pattern will override a match in &lt;code&gt;log.excludeDecoration&lt;/code&gt;.</source>
          <target state="translated">何場合 &lt;code&gt;--decorate-refs&lt;/code&gt; 与えられていないすべての引用文献が含まれているかのように、ふりをします。それが与えられた任意のパターンと一致した場合、各候補者のために、装飾のためにそれを使用していない &lt;code&gt;--decorate-refs-exclude&lt;/code&gt; するか、に与えられたパターンのいずれとも一致しない場合 &lt;code&gt;--decorate-refs&lt;/code&gt; 。 &lt;code&gt;log.excludeDecoration&lt;/code&gt; の設定オプションが装飾からREFを除くことができますが、明示的な &lt;code&gt;--decorate-refs&lt;/code&gt; パターンが一致で上書きします &lt;code&gt;log.excludeDecoration&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="0c2ed2d5d960c224ec529b5f6156261c52081093" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;-b&lt;/code&gt; option is given, the name of the new branch will be derived from the remote-tracking branch, by looking at the local part of the refspec configured for the corresponding remote, and then stripping the initial part up to the &quot;*&quot;. This would tell us to use &lt;code&gt;hack&lt;/code&gt; as the local branch when branching off of &lt;code&gt;origin/hack&lt;/code&gt; (or &lt;code&gt;remotes/origin/hack&lt;/code&gt;, or even &lt;code&gt;refs/remotes/origin/hack&lt;/code&gt;). If the given name has no slash, or the above guessing results in an empty name, the guessing is aborted. You can explicitly give a name with &lt;code&gt;-b&lt;/code&gt; in such a case.</source>
          <target state="translated">&lt;code&gt;-b&lt;/code&gt; オプションが指定されていない場合、新しいブランチの名前は、対応するリモート用に構成されたrefspecのローカル部分を調べ、最初の部分を「* 」これは、 &lt;code&gt;origin/hack&lt;/code&gt; （または &lt;code&gt;remotes/origin/hack&lt;/code&gt; 、または &lt;code&gt;refs/remotes/origin/hack&lt;/code&gt; ）から分岐するときに、ローカルブランチとして &lt;code&gt;hack&lt;/code&gt; を使用するように指示します。指定された名前にスラッシュがない場合、または上記の推測で空の名前になった場合、推測は打ち切られます。このような場合は、 &lt;code&gt;-b&lt;/code&gt; を使用して明示的に名前を付けることができます。</target>
        </trans-unit>
        <trans-unit id="4b362c22d46cf3c9ce26cb952c31ebfa05896260" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;-c&lt;/code&gt; option is given, the name of the new branch will be derived from the remote-tracking branch, by looking at the local part of the refspec configured for the corresponding remote, and then stripping the initial part up to the &quot;*&quot;. This would tell us to use &lt;code&gt;hack&lt;/code&gt; as the local branch when branching off of &lt;code&gt;origin/hack&lt;/code&gt; (or &lt;code&gt;remotes/origin/hack&lt;/code&gt;, or even &lt;code&gt;refs/remotes/origin/hack&lt;/code&gt;). If the given name has no slash, or the above guessing results in an empty name, the guessing is aborted. You can explicitly give a name with &lt;code&gt;-c&lt;/code&gt; in such a case.</source>
          <target state="translated">&lt;code&gt;-c&lt;/code&gt; オプションを指定しない場合、新しいブランチの名前は、対応するリモート用に構成されたrefspecのローカル部分を調べ、最初の部分を「* 」これは、 &lt;code&gt;origin/hack&lt;/code&gt; （または &lt;code&gt;remotes/origin/hack&lt;/code&gt; 、または &lt;code&gt;refs/remotes/origin/hack&lt;/code&gt; ）から分岐するときに、ローカルブランチとして &lt;code&gt;hack&lt;/code&gt; を使用するように指示します。指定された名前にスラッシュがない場合、または上記の推測で空の名前になった場合、推測は打ち切られます。このような場合は、 &lt;code&gt;-c&lt;/code&gt; を使用して明示的に名前を付けることができます。</target>
        </trans-unit>
        <trans-unit id="f5eb9ed53cf409691a2adb1a958e7a2a354184a7" translate="yes" xml:space="preserve">
          <source>If no branch is specified and neither &lt;code&gt;-b&lt;/code&gt; nor &lt;code&gt;-B&lt;/code&gt; nor &lt;code&gt;--detach&lt;/code&gt; is used, then &lt;code&gt;git worktree add&lt;/code&gt; defaults to creating a new branch from HEAD. If &lt;code&gt;worktree.guessRemote&lt;/code&gt; is set to true, &lt;code&gt;worktree add&lt;/code&gt; tries to find a remote-tracking branch whose name uniquely matches the new branch name. If such a branch exists, it is checked out and set as &quot;upstream&quot; for the new branch. If no such match can be found, it falls back to creating a new branch from the current HEAD.</source>
          <target state="translated">ブランチが指定されておらず、 &lt;code&gt;-b&lt;/code&gt; も &lt;code&gt;-B&lt;/code&gt; も &lt;code&gt;--detach&lt;/code&gt; も使用されていない場合、 &lt;code&gt;git worktree add&lt;/code&gt; デフォルトでHEADから新しいブランチを作成します。場合 &lt;code&gt;worktree.guessRemote&lt;/code&gt; は真、に設定されている &lt;code&gt;worktree add&lt;/code&gt; 、名前が一意に新しいブランチ名と一致するリモート追跡ブランチを見つけようとします。そのようなブランチが存在する場合、チェックアウトされ、新しいブランチの「上流」として設定されます。そのような一致が見つからない場合は、現在のHEADから新しいブランチを作成することになります。</target>
        </trans-unit>
        <trans-unit id="cd840721ca4f2ba5f348ba0cdeddc96e7d47ba2a" translate="yes" xml:space="preserve">
          <source>If no command-line option is passed, the &lt;code&gt;help.format&lt;/code&gt; configuration variable will be checked. The following values are supported for this variable; they make &lt;code&gt;git help&lt;/code&gt; behave as their corresponding command- line option:</source>
          <target state="translated">コマンドラインオプションが渡されない場合、 &lt;code&gt;help.format&lt;/code&gt; 構成変数がチェックされます。この変数では、次の値がサポートされています。それらは &lt;code&gt;git help&lt;/code&gt; を対応するコマンドラインオプションとして動作させます：</target>
        </trans-unit>
        <trans-unit id="48f09dc10a5152e65a114506d3daba225636a70e" translate="yes" xml:space="preserve">
          <source>If no commit ID is found, &lt;code&gt;git get-tar-commit-id&lt;/code&gt; quietly exists with a return code of 1. This can happen if the archive had not been created using &lt;code&gt;git archive&lt;/code&gt; or if the first parameter of &lt;code&gt;git archive&lt;/code&gt; had been a tree ID instead of a commit ID or tag.</source>
          <target state="translated">コミットIDが見つかったいかなる場合には、 &lt;code&gt;git get-tar-commit-id&lt;/code&gt; 静かにアーカイブを使用して作成されていない場合は、この発生する可能性が1のリターンコードに存在しない &lt;code&gt;git archive&lt;/code&gt; かの最初のパラメータ場合は &lt;code&gt;git archive&lt;/code&gt; ツリーIDされていましたコミットIDまたはタグの代わり。</target>
        </trans-unit>
        <trans-unit id="daf3aead6a5bfcff96ae9ec0da48e9d2be49b75e" translate="yes" xml:space="preserve">
          <source>If no commit is given from the command line, merge the remote-tracking branches that the current branch is configured to use as its upstream. See also the configuration section of this manual page.</source>
          <target state="translated">コマンドラインからコミットが与えられていない場合、現在のブランチがアップストリームとして使用するように設定されているリモートトラッキングブランチをマージします。このマニュアルページの設定セクションも参照してください。</target>
        </trans-unit>
        <trans-unit id="7188b50eb220f479115e7bb7b4e8a6b937273e6f" translate="yes" xml:space="preserve">
          <source>If no format is specified, the default format is &lt;code&gt;%(objectname)
%(objecttype) %(objectsize)&lt;/code&gt;.</source>
          <target state="translated">形式が指定されていない場合、デフォルトの形式は &lt;code&gt;%(objectname) %(objecttype) %(objectsize)&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="e72375796417844d20df5e1c264d965559c3c0c9" translate="yes" xml:space="preserve">
          <source>If no further options are given, all reading options will read all of these files that are available. If the global or the system-wide configuration file are not available they will be ignored. If the repository configuration file is not available or readable, &lt;code&gt;git config&lt;/code&gt; will exit with a non-zero error code. However, in neither case will an error message be issued.</source>
          <target state="translated">追加のオプションが指定されていない場合、すべての読み取りオプションは、使用可能なこれらのファイルをすべて読み取ります。グローバルまたはシステム全体の構成ファイルが使用できない場合、それらは無視されます。リポジトリ設定ファイルが利用できない、または読み込めない場合、 &lt;code&gt;git config&lt;/code&gt; はゼロ以外のエラーコードで終了します。ただし、どちらの場合もエラーメッセージは発行されません。</target>
        </trans-unit>
        <trans-unit id="542c100edd4ea5b59ab171a7795bc617673af483" translate="yes" xml:space="preserve">
          <source>If no objects are given, &lt;code&gt;git fsck&lt;/code&gt; defaults to using the index file, all SHA-1 references in &lt;code&gt;refs&lt;/code&gt; namespace, and all reflogs (unless --no-reflogs is given) as heads.</source>
          <target state="translated">オブジェクトが指定されていない場合、 &lt;code&gt;git fsck&lt;/code&gt; はデフォルトでインデックスファイル、 &lt;code&gt;refs&lt;/code&gt; 名前空間内のすべてのSHA-1参照、およびすべてのreflog（--no-reflogsが指定されていない場合）をヘッドとして使用します。</target>
        </trans-unit>
        <trans-unit id="3ac71fd77839914951c054588c999a4a8ef138ac" translate="yes" xml:space="preserve">
          <source>If no revisions are passed on the command line and either standard input is not a terminal or there is no current branch, &lt;code&gt;git shortlog&lt;/code&gt; will output a summary of the log read from standard input, without reference to the current repository.</source>
          <target state="translated">コマンドラインでリビジョンが渡されず、標準入力が端末でないか、現在のブランチがない場合、 &lt;code&gt;git shortlog&lt;/code&gt; は、現在のリポジトリを参照せずに、標準入力から読み取ったログの概要を出力します。</target>
        </trans-unit>
        <trans-unit id="abf7234009b8e35c90eeb194fcd9fd8cfced1763" translate="yes" xml:space="preserve">
          <source>If no username is set for a network authentication, use this username by default. See credential.&amp;lt;context&amp;gt;.* below, and &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials[7]&lt;/a&gt;.</source>
          <target state="translated">ネットワーク認証にユーザー名が設定されていない場合は、デフォルトでこのユーザー名を使用します。以下のcredential。&amp;lt;context&amp;gt;。*と&lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials [7]を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="68bd2465b7813ae05686685c60e9c1221c412754" translate="yes" xml:space="preserve">
          <source>If non-zero, all packs larger than this limit are kept when &lt;code&gt;git gc&lt;/code&gt; is run. This is very similar to &lt;code&gt;--keep-base-pack&lt;/code&gt; except that all packs that meet the threshold are kept, not just the base pack. Defaults to zero. Common unit suffixes of &lt;code&gt;k&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt;, or &lt;code&gt;g&lt;/code&gt; are supported.</source>
          <target state="translated">ゼロ以外の場合、 &lt;code&gt;git gc&lt;/code&gt; の実行時に、この制限より大きいすべてのパックが保持されます。これは、 &lt;code&gt;--keep-base-pack&lt;/code&gt; だけでなく、しきい値を満たすすべてのパックが保持されることを除いて、-keep-base-packとよく似ています。デフォルトはゼロです。 &lt;code&gt;k&lt;/code&gt; 、 &lt;code&gt;m&lt;/code&gt; 、または &lt;code&gt;g&lt;/code&gt; の共通の単位サフィックスがサポートされています。</target>
        </trans-unit>
        <trans-unit id="80f929e50dc4409c5d26df44de311be2ffed8079" translate="yes" xml:space="preserve">
          <source>If none of &lt;code&gt;--stdin&lt;/code&gt;, &lt;code&gt;--all&lt;/code&gt;, or &lt;code&gt;--&lt;/code&gt; is used, the first argument will be treated as an attribute and the rest of the arguments as pathnames.</source>
          <target state="translated">いずれももし &lt;code&gt;--stdin&lt;/code&gt; 、 &lt;code&gt;--all&lt;/code&gt; 、または &lt;code&gt;--&lt;/code&gt; 使用され、最初の引数は、属性とパス名として残りの引数として扱われます。</target>
        </trans-unit>
        <trans-unit id="af13390230f0ed2d9d7a8cd452e31841984f2fea" translate="yes" xml:space="preserve">
          <source>If not set (default), it means that this feature is disabled.</source>
          <target state="translated">設定されていない場合(デフォルト)、この機能が無効になっていることを意味します。</target>
        </trans-unit>
        <trans-unit id="ffeb0befbf6f99dd0616072c3aff8f91a09da3dd" translate="yes" xml:space="preserve">
          <source>If not set explicitly with &lt;code&gt;--file&lt;/code&gt;, there are four files where &lt;code&gt;git config&lt;/code&gt; will search for configuration options:</source>
          <target state="translated">&lt;code&gt;--file&lt;/code&gt; で明示的に設定しない場合、 &lt;code&gt;git config&lt;/code&gt; が構成オプションを検索する4つのファイルがあります。</target>
        </trans-unit>
        <trans-unit id="42b0a7358d3a7018936abd1faefcf6d947a2a30c" translate="yes" xml:space="preserve">
          <source>If not set explicitly with &lt;code&gt;--file&lt;/code&gt;, there are two files where git-credential-store will search for credentials in order of precedence:</source>
          <target state="translated">&lt;code&gt;--file&lt;/code&gt; で明示的に設定しない場合、git-credential-storeが優先順位に従って認証情報を検索する2つのファイルがあります。</target>
        </trans-unit>
        <trans-unit id="7dcc101d67cdfa1a1e655970a079699595239b44" translate="yes" xml:space="preserve">
          <source>If not set in the environment, the list of notes to copy depends on the &lt;code&gt;notes.rewrite.&amp;lt;command&amp;gt;&lt;/code&gt; and &lt;code&gt;notes.rewriteRef&lt;/code&gt; settings.</source>
          <target state="translated">環境で設定されていない場合、コピーするメモのリストは &lt;code&gt;notes.rewrite.&amp;lt;command&amp;gt;&lt;/code&gt; および &lt;code&gt;notes.rewriteRef&lt;/code&gt; 設定によって異なります。</target>
        </trans-unit>
        <trans-unit id="324a704070b71849b1d4e1ca6f933c2b17a7a16e" translate="yes" xml:space="preserve">
          <source>If not specified, the contents are restored from &lt;code&gt;HEAD&lt;/code&gt; if &lt;code&gt;--staged&lt;/code&gt; is given, otherwise from the index.</source>
          <target state="translated">指定しない場合、 &lt;code&gt;--staged&lt;/code&gt; が指定されている場合は &lt;code&gt;HEAD&lt;/code&gt; から、それ以外の場合はインデックスから内容が復元されます。</target>
        </trans-unit>
        <trans-unit id="b9f85a49fbdf8e068a215ef9d6f0bd6bbfeb7a4e" translate="yes" xml:space="preserve">
          <source>If not specified, the default restore source for the working tree is the index, and the default restore source for the index is &lt;code&gt;HEAD&lt;/code&gt;. When both &lt;code&gt;--staged&lt;/code&gt; and &lt;code&gt;--worktree&lt;/code&gt; are specified, &lt;code&gt;--source&lt;/code&gt; must also be specified.</source>
          <target state="translated">指定しない場合、作業ツリーのデフォルトの復元ソースはインデックスであり、インデックスのデフォルトの復元ソースは &lt;code&gt;HEAD&lt;/code&gt; です。両方の場合は &lt;code&gt;--staged&lt;/code&gt; と &lt;code&gt;--worktree&lt;/code&gt; が指定されている、 &lt;code&gt;--source&lt;/code&gt; をも指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="56d3a4f46f938bb42b1fca6d786b8e7fc54bbe14" translate="yes" xml:space="preserve">
          <source>If nothing matches, &lt;code&gt;git show-ref&lt;/code&gt; will return an error code of 1, and in the case of verification, it will show an error message.</source>
          <target state="translated">何も一致しない場合、 &lt;code&gt;git show-ref&lt;/code&gt; はエラーコード1を返し、検証の場合はエラーメッセージを表示します。</target>
        </trans-unit>
        <trans-unit id="b1f5a8844fabfc412b2762d5d95a3c4d967624ca" translate="yes" xml:space="preserve">
          <source>If one of &lt;code&gt;-a&lt;/code&gt;, &lt;code&gt;-s&lt;/code&gt;, or &lt;code&gt;-u &amp;lt;keyid&amp;gt;&lt;/code&gt; is passed, the command creates a &lt;code&gt;tag&lt;/code&gt; object, and requires a tag message. Unless &lt;code&gt;-m &amp;lt;msg&amp;gt;&lt;/code&gt; or &lt;code&gt;-F &amp;lt;file&amp;gt;&lt;/code&gt; is given, an editor is started for the user to type in the tag message.</source>
          <target state="translated">いずれかが &lt;code&gt;-a&lt;/code&gt; 、 &lt;code&gt;-s&lt;/code&gt; 、または &lt;code&gt;-u &amp;lt;keyid&amp;gt;&lt;/code&gt; 渡され、コマンドは作成され &lt;code&gt;tag&lt;/code&gt; オブジェクトを、タグメッセージを必要とします。 &lt;code&gt;-m &amp;lt;msg&amp;gt;&lt;/code&gt; または &lt;code&gt;-F &amp;lt;file&amp;gt;&lt;/code&gt; を指定しない限り、ユーザーがタグメッセージを入力するためのエディターが起動します。</target>
        </trans-unit>
        <trans-unit id="2202ccf1357459c2102fac8580d0b9c370cb2843" translate="yes" xml:space="preserve">
          <source>If one or more &amp;lt;file&amp;gt; parameters are given, the merge tool program will be run to resolve differences on each file (skipping those without conflicts). Specifying a directory will include all unresolved files in that path. If no &amp;lt;file&amp;gt; names are specified, &lt;code&gt;git mergetool&lt;/code&gt; will run the merge tool program on every file with merge conflicts.</source>
          <target state="translated">1つ以上の&amp;lt;file&amp;gt;パラメータが指定されている場合、マージツールプログラムが実行され、各ファイルの違いが解決されます（競合のないものはスキップされます）。ディレクトリを指定すると、そのパスにあるすべての未解決のファイルが含まれます。&amp;lt;file&amp;gt;名が指定されていない場合、 &lt;code&gt;git mergetool&lt;/code&gt; は、マージの競合があるすべてのファイルに対してマージツールプログラムを実行します。</target>
        </trans-unit>
        <trans-unit id="ce7c35e9da7a7a12641957ffb2984ef7917b0e3e" translate="yes" xml:space="preserve">
          <source>If one or more patterns are given, only refs are shown that match against at least one pattern, either using fnmatch(3) or literally, in the latter case matching completely or from the beginning up to a slash.</source>
          <target state="translated">1つ以上のパターンが与えられている場合は、fnmatch(3)を使用するか、あるいは文字通り、後者の場合は完全にマッチするか、あるいは最初からスラッシュまでマッチするかのいずれかで、少なくとも1つのパターンにマッチするrefのみが表示されます。</target>
        </trans-unit>
        <trans-unit id="d335af2a37a580d9863e5a06bbfa0d646026268f" translate="yes" xml:space="preserve">
          <source>If one wishes to use the ref &lt;code&gt;ref/notes/true&lt;/code&gt;, please use that literal instead.</source>
          <target state="translated">ref &lt;code&gt;ref/notes/true&lt;/code&gt; を使用したい場合は、代わりにそのリテラルを使用してください。</target>
        </trans-unit>
        <trans-unit id="c90c8ad16602dc9d2f205c9d917c69aa3c723c01" translate="yes" xml:space="preserve">
          <source>If only &amp;lt;infd&amp;gt; is given, it is assumed to be a bidirectional socket connected to remote Git server (git-upload-pack, git-receive-pack or git-upload-archive). If both &amp;lt;infd&amp;gt; and &amp;lt;outfd&amp;gt; are given, they are assumed to be pipes connected to a remote Git server (&amp;lt;infd&amp;gt; being the inbound pipe and &amp;lt;outfd&amp;gt; being the outbound pipe.</source>
          <target state="translated">&amp;lt;infd&amp;gt;のみが指定されている場合、リモートGitサーバー（git-upload-pack、git-receive-packまたはgit-upload-archive）に接続された双方向ソケットであると想定されます。&amp;lt;infd&amp;gt;と&amp;lt;outfd&amp;gt;の両方が指定されている場合、それらはリモートGitサーバーに接続されたパイプであると想定されます（&amp;lt;infd&amp;gt;はインバウンドパイプ、&amp;lt;outfd&amp;gt;はアウトバウンドパイプです）。</target>
        </trans-unit>
        <trans-unit id="ce722a3060a9ef1801cda4fdb7cc3661d10ec67c" translate="yes" xml:space="preserve">
          <source>If only 1 tree is specified, &lt;code&gt;git read-tree&lt;/code&gt; operates as if the user did not specify &lt;code&gt;-m&lt;/code&gt;, except that if the original index has an entry for a given pathname, and the contents of the path match with the tree being read, the stat info from the index is used. (In other words, the index&amp;rsquo;s stat()s take precedence over the merged tree&amp;rsquo;s).</source>
          <target state="translated">ツリーが1つだけ指定されている場合、 &lt;code&gt;git read-tree&lt;/code&gt; は、ユーザーが &lt;code&gt;-m&lt;/code&gt; を指定しなかったかのように動作します。ただし、元のインデックスに特定のパス名のエントリがあり、パスの内容が読み取られているツリーと一致する場合は、インデックスからの統計情報が使用されます。（言い換えれば、インデックスのstat（）はマージされたツリーよりも優先されます）。</target>
        </trans-unit>
        <trans-unit id="ed44ceba40face622ee83aefe1801bafac3f799c" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;check-connectivity&lt;/code&gt; is requested, the helper must output &lt;code&gt;connectivity-ok&lt;/code&gt; if the clone is self-contained and connected.</source>
          <target state="translated">オプション &lt;code&gt;check-connectivity&lt;/code&gt; が要求された場合、クローンが自己完結型で接続されている場合、ヘルパーは &lt;code&gt;connectivity-ok&lt;/code&gt; 出力する必要があります。</target>
        </trans-unit>
        <trans-unit id="d94f0028bb24f94910f79bf2b787bad6af3cf852" translate="yes" xml:space="preserve">
          <source>If other people are pulling from your repository over dumb transport protocols (HTTP), you need to keep this repository &lt;code&gt;dumb transport friendly&lt;/code&gt;. After &lt;code&gt;git init&lt;/code&gt;, &lt;code&gt;$GIT_DIR/hooks/post-update.sample&lt;/code&gt; copied from the standard templates would contain a call to &lt;code&gt;git update-server-info&lt;/code&gt; but you need to manually enable the hook with &lt;code&gt;mv post-update.sample post-update&lt;/code&gt;. This makes sure &lt;code&gt;git update-server-info&lt;/code&gt; keeps the necessary files up to date.</source>
          <target state="translated">ダムトランスポートプロトコル（HTTP）を介して他の人がリポジトリからプルしている場合は、このリポジトリの &lt;code&gt;dumb transport friendly&lt;/code&gt; に保つ必要があります。後に &lt;code&gt;git init&lt;/code&gt; 、 &lt;code&gt;$GIT_DIR/hooks/post-update.sample&lt;/code&gt; 標準テンプレートからコピーはへの呼び出し含んでいるでしょう &lt;code&gt;git update-server-info&lt;/code&gt; しかし、あなたは手動でフックを有効にする必要があり &lt;code&gt;mv post-update.sample post-update&lt;/code&gt; 。これにより、 &lt;code&gt;git update-server-info&lt;/code&gt; が必要なファイルを最新の状態に保ちます。</target>
        </trans-unit>
        <trans-unit id="e17148a8f3d2ab81971460344696589bc00ec7fe" translate="yes" xml:space="preserve">
          <source>If provided, the results are limited to a subset of files matching one of the provided pathspecs.</source>
          <target state="translated">指定された場合、結果は指定されたパス仕様のいずれかにマッチするファイルのサブセットに限定されます。</target>
        </trans-unit>
        <trans-unit id="c6bf36e1017847984a394e553be49b7f1e0149c6" translate="yes" xml:space="preserve">
          <source>If separate &lt;code&gt;author&lt;/code&gt; and &lt;code&gt;committer&lt;/code&gt; commands are used in a &lt;code&gt;commit&lt;/code&gt; the timestamps may not match, as the system clock will be polled twice (once for each command). The only way to ensure that both author and committer identity information has the same timestamp is to omit &lt;code&gt;author&lt;/code&gt; (thus copying from &lt;code&gt;committer&lt;/code&gt;) or to use a date format other than &lt;code&gt;now&lt;/code&gt;.</source>
          <target state="translated">システムクロックが2回ポーリングされるため（コマンドごとに1回）、 &lt;code&gt;commit&lt;/code&gt; 別々の作成 &lt;code&gt;author&lt;/code&gt; コマンドと &lt;code&gt;committer&lt;/code&gt; コマンドを使用すると、タイムスタンプが一致しない場合があります。著者とコミッターの両方のID情報が同じタイムスタンプを持つことを保証する唯一の方法は、 &lt;code&gt;author&lt;/code&gt; を省略する（つまり、 &lt;code&gt;committer&lt;/code&gt; からコピーする）か、 &lt;code&gt;now&lt;/code&gt; 以外の日付形式を使用することです。</target>
        </trans-unit>
        <trans-unit id="866d5a5839fdc5ae41f48af4bbd37789bc250691" translate="yes" xml:space="preserve">
          <source>If set &lt;code&gt;--base=auto&lt;/code&gt; in cmdline, it will track base commit automatically, the base commit will be the merge base of tip commit of the remote-tracking branch and revision-range specified in cmdline. For a local branch, you need to track a remote branch by &lt;code&gt;git branch
--set-upstream-to&lt;/code&gt; before using this option.</source>
          <target state="translated">&lt;code&gt;--base=auto&lt;/code&gt; を設定すると、ベースコミットが自動的に追跡されます。ベースコミットは、リモート追跡ブランチのチップコミットとコマンドラインで指定されたリビジョン範囲のマージベースになります。ローカルブランチの場合、このオプションを使用 &lt;code&gt;git branch --set-upstream-to&lt;/code&gt; 前に、git branch --set-upstream-toでリモートブランチを追跡する必要があります。</target>
        </trans-unit>
        <trans-unit id="c4e55e2ff9b8cf62b34b50d7d6b4a09bd94fb5d9" translate="yes" xml:space="preserve">
          <source>If set to &quot;auto&quot;, &lt;code&gt;git-commit&lt;/code&gt; would select a character that is not the beginning character of any line in existing commit messages.</source>
          <target state="translated">「auto」に設定すると、 &lt;code&gt;git-commit&lt;/code&gt; は既存のコミットメッセージのどの行の開始文字でもない文字を選択します。</target>
        </trans-unit>
        <trans-unit id="3cb1da898d09757c537ab553b3fe27d9de1953ee" translate="yes" xml:space="preserve">
          <source>If set to &quot;warn&quot;, git rebase -i will print a warning if some commits are removed (e.g. a line was deleted), however the rebase will still proceed. If set to &quot;error&quot;, it will print the previous warning and stop the rebase, &lt;code&gt;git rebase --edit-todo&lt;/code&gt; can then be used to correct the error. If set to &quot;ignore&quot;, no checking is done. To drop a commit without warning or error, use the &lt;code&gt;drop&lt;/code&gt; command in the todo list. Defaults to &quot;ignore&quot;.</source>
          <target state="translated">「警告」に設定すると、git rebase -iは、一部のコミットが削除された場合（たとえば、行が削除された場合）に警告を出力しますが、リベースは続行されます。「エラー」に設定すると、前の警告を出力してリベースを停止します。次に &lt;code&gt;git rebase --edit-todo&lt;/code&gt; を使用してエラーを修正できます。「無視」に設定すると、チェックは行われません。警告やエラーなしでコミットを削除するには、ToDoリストで &lt;code&gt;drop&lt;/code&gt; コマンドを使用します。デフォルトは「無視」です。</target>
        </trans-unit>
        <trans-unit id="ac8b0270c3c47d08febdcf04811ec5325e6bcef3" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;0&lt;/code&gt;, Git will complete any requested operation without performing any optional sub-operations that require taking a lock. For example, this will prevent &lt;code&gt;git status&lt;/code&gt; from refreshing the index as a side effect. This is useful for processes running in the background which do not want to cause lock contention with other operations on the repository. Defaults to &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; に設定すると、Gitは、ロックを取得する必要があるオプションのサブ操作を実行せずに、要求された操作を完了します。たとえば、これは &lt;code&gt;git status&lt;/code&gt; が副作用としてインデックスを更新するのを防ぎます。これは、リポジトリで他の操作とのロック競合を引き起こしたくないバックグラウンドで実行されているプロセスに役立ちます。デフォルトは &lt;code&gt;1&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="9d1e5156e1d430a4750260179109e036962ca85d" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;1&lt;/code&gt;, include broken or badly named refs when iterating over lists of refs. In a normal, non-corrupted repository, this does nothing. However, enabling it may help git to detect and abort some operations in the presence of broken refs. Git sets this variable automatically when performing destructive operations like &lt;a href=&quot;git-prune&quot;&gt;git-prune[1]&lt;/a&gt;. You should not need to set it yourself unless you want to be paranoid about making sure an operation has touched every ref (e.g., because you are cloning a repository to make a backup).</source>
          <target state="translated">&lt;code&gt;1&lt;/code&gt; に設定されている場合、参照のリストを反復するときに、壊れた、または不適切な名前の参照を含めます。破損していない通常のリポジトリでは、これは何もしません。ただし、これを有効にすると、参照が壊れている場合にgitが一部の操作を検出して中止するのに役立ちます。&lt;a href=&quot;git-prune&quot;&gt;git-prune [1]の&lt;/a&gt;ような破壊的な操作を実行すると、Gitはこの変数を自動的に設定します。操作がすべての参照に影響を与えることについて偏執的になりたくない場合を除いて、自分で設定する必要はありません（たとえば、バックアップを作成するためにリポジトリを複製しているため）。</target>
        </trans-unit>
        <trans-unit id="721e268a3bbca2372f644ef6baf34d6bc14a8b54" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;false&lt;/code&gt;, behave as if the &lt;code&gt;--no-replace-objects&lt;/code&gt; option was given on the command line. See &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt; and &lt;a href=&quot;git-replace&quot;&gt;git-replace[1]&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; に設定すると、コマンドラインで &lt;code&gt;--no-replace-objects&lt;/code&gt; オプションが指定されているかのように動作します。詳細については、&lt;a href=&quot;git&quot;&gt;git [1]&lt;/a&gt;および&lt;a href=&quot;git-replace&quot;&gt;git-replace [1]&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="0f2d027bcde6fa30d6f1d075f8f588cf0e958fbb" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;git diff&lt;/code&gt; does not show changes outside of the directory and show pathnames relative to the current directory.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; に設定すると、 &lt;code&gt;git diff&lt;/code&gt; はディレクトリ外の変更を表示せず、現在のディレクトリに関連するパス名を表示します。</target>
        </trans-unit>
        <trans-unit id="5c80e3d63d134dccb3136c655fb06b3aa0219fb0" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;yes&lt;/code&gt;, print an ellipsis following an (abbreviated) SHA-1 value. This affects indications of detached HEADs (&lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt;) and the raw diff output (&lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;). Printing an ellipsis in the cases mentioned is no longer considered adequate and support for it is likely to be removed in the foreseeable future (along with the variable).</source>
          <target state="translated">&lt;code&gt;yes&lt;/code&gt; に設定すると、（省略された）SHA-1値の後に省略記号が出力されます。これは、切り離されたHEADの表示（&lt;a href=&quot;git-checkout&quot;&gt;git-checkout [1]&lt;/a&gt;）と生の差分出力（&lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt;）に影響します。言及された場合に省略記号を印刷することはもはや適切とは見なされず、それに対するサポートは予見可能な将来に（変数とともに）削除される可能性があります。</target>
        </trans-unit>
        <trans-unit id="03e97ab625ba0ca85ff94dae74e07745d32e9ba5" translate="yes" xml:space="preserve">
          <source>If set to a colon-separated list of protocols, behave as if &lt;code&gt;protocol.allow&lt;/code&gt; is set to &lt;code&gt;never&lt;/code&gt;, and each of the listed protocols has &lt;code&gt;protocol.&amp;lt;name&amp;gt;.allow&lt;/code&gt; set to &lt;code&gt;always&lt;/code&gt; (overriding any existing configuration). In other words, any protocol not mentioned will be disallowed (i.e., this is a whitelist, not a blacklist). See the description of &lt;code&gt;protocol.allow&lt;/code&gt; in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for more details.</source>
          <target state="translated">コロンで区切られたプロトコルのリストに設定されている場合は、 &lt;code&gt;protocol.allow&lt;/code&gt; が &lt;code&gt;never&lt;/code&gt; に設定されているかのように動作し、リストされている各プロトコルには &lt;code&gt;protocol.&amp;lt;name&amp;gt;.allow&lt;/code&gt; が &lt;code&gt;always&lt;/code&gt; 設定されています（既存の構成を上書きします）。つまり、言及されていないプロトコルは許可されません（つまり、これはブラックリストではなくホワイトリストです）。詳細については、&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;の &lt;code&gt;protocol.allow&lt;/code&gt; の説明を参照してください。</target>
        </trans-unit>
        <trans-unit id="3efcc8bea067f2176f4b0bb44941378607e1ec05" translate="yes" xml:space="preserve">
          <source>If set to an algorithm, indicate that the caller wants to interact with the remote side using that algorithm.</source>
          <target state="translated">アルゴリズムに設定されている場合、発呼側がそのアルゴリズムを使用してリモート側と 対話したいことを示す。</target>
        </trans-unit>
        <trans-unit id="d02bbac09e65cccb0fb85d779cd5ffdc25f0fea6" translate="yes" xml:space="preserve">
          <source>If set to either a valid &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; or a true value, moved lines in a diff are colored differently, for details of valid modes see &lt;code&gt;--color-moved&lt;/code&gt; in &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;. If simply set to true the default color mode will be used. When set to false, moved lines are not colored.</source>
          <target state="translated">有効な &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; またはtrue値のいずれかに設定されている場合、diffで移動された行は異なる色になります。有効なモードの詳細について &lt;code&gt;--color-moved&lt;/code&gt; 、&lt;a href=&quot;git-diff&quot;&gt;git-diff [1]の&lt;/a&gt;--color-movedを参照してください。単にtrueに設定した場合、デフォルトのカラーモードが使用されます。falseに設定すると、移動した線は色付けされません。</target>
        </trans-unit>
        <trans-unit id="d2017527381afe3327ef07745ea82e7ee1e2ae55" translate="yes" xml:space="preserve">
          <source>If set to true enable &lt;code&gt;--autosquash&lt;/code&gt; option by default.</source>
          <target state="translated">trueに設定した場合、デフォルトで &lt;code&gt;--autosquash&lt;/code&gt; オプションが有効になります。</target>
        </trans-unit>
        <trans-unit id="7630a0d058d7490b6c2c7394afc94b9292f8389f" translate="yes" xml:space="preserve">
          <source>If set to true enable &lt;code&gt;--follow-tags&lt;/code&gt; option by default. You may override this configuration at time of push by specifying &lt;code&gt;--no-follow-tags&lt;/code&gt;.</source>
          <target state="translated">trueに設定した場合、デフォルトで &lt;code&gt;--follow-tags&lt;/code&gt; オプションを有効にします。 &lt;code&gt;--no-follow-tags&lt;/code&gt; を指定することで、プッシュ時にこの設定をオーバーライドできます。</target>
        </trans-unit>
        <trans-unit id="64fe3b4eafd82bc5365512adbc156f5096a46d37" translate="yes" xml:space="preserve">
          <source>If set to true or &quot;refuse&quot;, git-receive-pack will deny a ref update to the currently checked out branch of a non-bare repository. Such a push is potentially dangerous because it brings the HEAD out of sync with the index and working tree. If set to &quot;warn&quot;, print a warning of such a push to stderr, but allow the push to proceed. If set to false or &quot;ignore&quot;, allow such pushes with no message. Defaults to &quot;refuse&quot;.</source>
          <target state="translated">true あるいは &quot;redirect&quot; を設定すると、git-receive-pack は非ベアリポジトリの現在チェックアウトしているブランチへの ref の更新を拒否します。このようなプッシュは、HEAD がインデックスや作業ツリーと同期していない状態になってしまうため、危険な可能性があります。warn&quot; に設定されている場合、そのようなプッシュの警告を標準エラーに表示しますが、プッシュを許可します。false または &quot;ignore&quot; に設定すると、メッセージを表示せずにプッシュを許可します。デフォルトは &quot;reject &quot;である。</target>
        </trans-unit>
        <trans-unit id="d09a3b8e56d92fdf26b71ac7a66610897ebf56ec" translate="yes" xml:space="preserve">
          <source>If set to true, .git/shallow can be updated when new refs require new shallow roots. Otherwise those refs are rejected.</source>
          <target state="translated">true に設定すると、新しい参照が新しい shallow ルートを必要としているときに .git/shallow を更新します。そうでない場合は、それらの参照は拒否されます。</target>
        </trans-unit>
        <trans-unit id="54bb951308d4910fbcee8b759c22be8fe1cad2d9" translate="yes" xml:space="preserve">
          <source>If set to true, &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; will display the number of entries currently stashed away. Defaults to false.</source>
          <target state="translated">trueに設定すると、&lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt;は現在隠されているエントリの数を表示します。デフォルトはfalseです。</target>
        </trans-unit>
        <trans-unit id="3713c634b09bf65bc394c012cee94ba42c596b9c" translate="yes" xml:space="preserve">
          <source>If set to true, &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; will insert a comment prefix before each output line (starting with &lt;code&gt;core.commentChar&lt;/code&gt;, i.e. &lt;code&gt;#&lt;/code&gt; by default). This was the behavior of &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; in Git 1.8.4 and previous. Defaults to false.</source>
          <target state="translated">trueに設定すると、&lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt;は各出力行の前にコメントプレフィックスを挿入します（ &lt;code&gt;core.commentChar&lt;/code&gt; で始まる、つまりデフォルトでは &lt;code&gt;#&lt;/code&gt; ）。これは、Git 1.8.4以前の&lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt;の動作でした。デフォルトはfalseです。</target>
        </trans-unit>
        <trans-unit id="9b89821396e7eac11e5ad2faf8d7540e7c67829b" translate="yes" xml:space="preserve">
          <source>If set to true, &lt;code&gt;git rebase&lt;/code&gt; will use abbreviated command names in the todo list resulting in something like this:</source>
          <target state="translated">trueに設定すると、 &lt;code&gt;git rebase&lt;/code&gt; はtodoリストで省略されたコマンド名を使用して、次のような結果になります。</target>
        </trans-unit>
        <trans-unit id="a871da2391e5e77cb10a7b13bd4e3a7269114ee0" translate="yes" xml:space="preserve">
          <source>If set to true, do not allow checkout of paths that would be considered equivalent to &lt;code&gt;.git&lt;/code&gt; on an HFS+ filesystem. Defaults to &lt;code&gt;true&lt;/code&gt; on Mac OS, and &lt;code&gt;false&lt;/code&gt; elsewhere.</source>
          <target state="translated">trueに設定した場合、HFS +ファイルシステムで &lt;code&gt;.git&lt;/code&gt; と同等と見なされるパスのチェックアウトを許可しません。Mac OSではデフォルトで &lt;code&gt;true&lt;/code&gt; になり、それ以外では &lt;code&gt;false&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="0b91b7e4dfffb3891da9de8dba8ed2d19154ae38" translate="yes" xml:space="preserve">
          <source>If set to true, do not allow checkout of paths that would cause problems with the NTFS filesystem, e.g. conflict with 8.3 &quot;short&quot; names. Defaults to &lt;code&gt;true&lt;/code&gt; on Windows, and &lt;code&gt;false&lt;/code&gt; elsewhere.</source>
          <target state="translated">trueに設定した場合、NTFSファイルシステムに問題を引き起こす可能性のあるパスのチェックアウトを許可しないでください（8.3の「短い」名前との競合など）。Windowsではデフォルトで &lt;code&gt;true&lt;/code&gt; になり、それ以外では &lt;code&gt;false&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="54ccdbeca4965b6fc3cb17a6075d84092d7309ba" translate="yes" xml:space="preserve">
          <source>If set to true, enable &lt;code&gt;--extended-regexp&lt;/code&gt; option by default. This option is ignored when the &lt;code&gt;grep.patternType&lt;/code&gt; option is set to a value other than &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="translated">trueに設定した場合、デフォルトで &lt;code&gt;--extended-regexp&lt;/code&gt; オプションを有効にします。 &lt;code&gt;grep.patternType&lt;/code&gt; オプションが &lt;code&gt;default&lt;/code&gt; 以外の値に設定されている場合、このオプションは無視されます。</target>
        </trans-unit>
        <trans-unit id="30887a5524c263667737b125eed1b7397b4d3c85" translate="yes" xml:space="preserve">
          <source>If set to true, enable &lt;code&gt;--full-name&lt;/code&gt; option by default.</source>
          <target state="translated">trueに設定した場合、デフォルトで &lt;code&gt;--full-name&lt;/code&gt; オプションを有効にします。</target>
        </trans-unit>
        <trans-unit id="a770bd77a59ee1eda1723cd39df7104106a40a38" translate="yes" xml:space="preserve">
          <source>If set to true, enable &lt;code&gt;-n&lt;/code&gt; option by default.</source>
          <target state="translated">trueに設定した場合、デフォルトで &lt;code&gt;-n&lt;/code&gt; オプションを有効にします。</target>
        </trans-unit>
        <trans-unit id="2ae1bc4fce8b6029e6cbb4c5d0167ebeeaacf37d" translate="yes" xml:space="preserve">
          <source>If set to true, enable the &lt;code&gt;--column&lt;/code&gt; option by default.</source>
          <target state="translated">trueに設定すると、デフォルトで &lt;code&gt;--column&lt;/code&gt; オプションが有効になります。</target>
        </trans-unit>
        <trans-unit id="1f2144fe2d27e9e20f68c9036ebab8459a790815" translate="yes" xml:space="preserve">
          <source>If set to true, fall back to git grep --no-index if git grep is executed outside of a git repository. Defaults to false.</source>
          <target state="translated">true に設定すると、git grep が git リポジトリの外で実行された場合に、git grep --no-index にフォールバックします。デフォルトは false です。</target>
        </trans-unit>
        <trans-unit id="25ad8c4a959eb80b90f95ddbc01fcd1f2b16d26e" translate="yes" xml:space="preserve">
          <source>If set to true, git-receive-pack will deny a ref update that deletes the currently checked out branch of a non-bare repository.</source>
          <target state="translated">true に設定すると、git-receive-pack は、現在チェックアウトしている非ベアリポジトリのブランチを削除する ref の更新を拒否します。</target>
        </trans-unit>
        <trans-unit id="f7f0fff426d74ea17456c56eae07f347498018a4" translate="yes" xml:space="preserve">
          <source>If set to true, git-receive-pack will deny a ref update that deletes the ref. Use this to prevent such a ref deletion via a push.</source>
          <target state="translated">true に設定すると、git-receive-pack は ref を削除するような ref の更新を拒否します。これを使用すると、プッシュによる ref の削除を防ぐことができます。</target>
        </trans-unit>
        <trans-unit id="bc6468d5687d1713aadc8dfe39af8a6b8a9b584c" translate="yes" xml:space="preserve">
          <source>If set to true, git-receive-pack will deny a ref update which is not a fast-forward. Use this to prevent such an update via a push, even if that push is forced. This configuration variable is set when initializing a shared repository.</source>
          <target state="translated">true に設定すると、git-receive-pack は早送りではない ref の更新を拒否します。これを使用すると、たとえプッシュが強制的に行われたとしても、プッシュによる更新を拒否します。この設定変数は、共有リポジトリの初期化時に設定されます。</target>
        </trans-unit>
        <trans-unit id="aa5f05e34699c4bff5b25fced7ce1653e77528d2" translate="yes" xml:space="preserve">
          <source>If set to true, git-receive-pack will run git-update-server-info after receiving data from git-push and updating refs.</source>
          <target state="translated">true に設定すると、git-receive-pack は git-push からデータを受け取って refs を更新した後に git-update-server-info を実行します。</target>
        </trans-unit>
        <trans-unit id="875b965a1988574b490477056983b56357db9a5f" translate="yes" xml:space="preserve">
          <source>If set to true, makes &lt;code&gt;git repack&lt;/code&gt; act as if &lt;code&gt;--delta-islands&lt;/code&gt; was passed. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">trueに設定すると、 &lt;code&gt;git repack&lt;/code&gt; &lt;code&gt;--delta-islands&lt;/code&gt; が渡されたかのように動作します。デフォルトは &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="3a3fff86e688774493783e955a40569a2b6cd00b" translate="yes" xml:space="preserve">
          <source>If set to true, makes &lt;code&gt;git repack&lt;/code&gt; act as if &lt;code&gt;--pack-kept-objects&lt;/code&gt; was passed. See &lt;a href=&quot;git-repack&quot;&gt;git-repack[1]&lt;/a&gt; for details. Defaults to &lt;code&gt;false&lt;/code&gt; normally, but &lt;code&gt;true&lt;/code&gt; if a bitmap index is being written (either via &lt;code&gt;--write-bitmap-index&lt;/code&gt; or &lt;code&gt;repack.writeBitmaps&lt;/code&gt;).</source>
          <target state="translated">trueに設定すると、 &lt;code&gt;git repack&lt;/code&gt; &lt;code&gt;--pack-kept-objects&lt;/code&gt; が渡されたかのように動作します。詳細については、&lt;a href=&quot;git-repack&quot;&gt;git-repack [1]&lt;/a&gt;を参照してください。デフォルトは &lt;code&gt;false&lt;/code&gt; 通常、しかし、 &lt;code&gt;true&lt;/code&gt; ビットマップ索引は、（のいずれかを介して書き込まれている場合 &lt;code&gt;--write-bitmap-index&lt;/code&gt; または &lt;code&gt;repack.writeBitmaps&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f4685adbf82f5fe84483ac0a4116dbb7a4fa6307" translate="yes" xml:space="preserve">
          <source>If set, &lt;code&gt;git diff&lt;/code&gt; does not show any source or destination prefix.</source>
          <target state="translated">設定されている場合、 &lt;code&gt;git diff&lt;/code&gt; はソースまたは宛先のプレフィックスを表示しません。</target>
        </trans-unit>
        <trans-unit id="407c23ddaf3ebfe9c20e0dd5ae2fc627eb8b4502" translate="yes" xml:space="preserve">
          <source>If set, &lt;code&gt;git diff&lt;/code&gt; uses a prefix pair that is different from the standard &quot;a/&quot; and &quot;b/&quot; depending on what is being compared. When this configuration is in effect, reverse diff output also swaps the order of the prefixes:</source>
          <target state="translated">設定されている場合、 &lt;code&gt;git diff&lt;/code&gt; は、比較対象に応じて、標準の「a /」および「b /」とは異なるプレフィックスペアを使用します。この構成が有効な場合、reverse diff出力もプレフィックスの順序を入れ替えます。</target>
        </trans-unit>
        <trans-unit id="ce70dfc2b2921383247fcc52103661d4583ff009" translate="yes" xml:space="preserve">
          <source>If set, by default &quot;git config&quot; reads from both &quot;config&quot; and &quot;config.worktree&quot; file from GIT_DIR in that order. In multiple working directory mode, &quot;config&quot; file is shared while &quot;config.worktree&quot; is per-working directory (i.e., it&amp;rsquo;s in GIT_COMMON_DIR/worktrees/&amp;lt;id&amp;gt;/config.worktree)</source>
          <target state="translated">設定されている場合、デフォルトでは、「git config」はGIT_DIRの「config」ファイルと「config.worktree」ファイルの両方からこの順序で読み取ります。複数の作業ディレクトリモードでは、「config」ファイルは共有されますが、「config.worktree」は作業ディレクトリごとに存在します（つまり、GIT_COMMON_DIR / worktrees / &amp;lt;id&amp;gt; /config.worktreeにあります）。</target>
        </trans-unit>
        <trans-unit id="8558e4c58eead00c8757e7213c096b3a4293d44c" translate="yes" xml:space="preserve">
          <source>If set, clients will attempt to communicate with a server using the specified protocol version. If the server does not support it, communication falls back to version 0. If unset, the default is &lt;code&gt;2&lt;/code&gt;. Supported versions:</source>
          <target state="translated">設定されている場合、クライアントは指定されたプロトコルバージョンを使用してサーバーとの通信を試みます。サーバーがサポートしていない場合、通信はバージョン0にフォールバックします。設定されていない場合、デフォルトは &lt;code&gt;2&lt;/code&gt; です。サポートされているバージョン：</target>
        </trans-unit>
        <trans-unit id="b176f794890668142b94887636cc924076126a16" translate="yes" xml:space="preserve">
          <source>If set, keywords at the start of the line are highlighted. The keywords are &quot;error&quot;, &quot;warning&quot;, &quot;hint&quot; and &quot;success&quot;, and are matched case-insensitively. May be set to &lt;code&gt;always&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; (or &lt;code&gt;never&lt;/code&gt;) or &lt;code&gt;auto&lt;/code&gt; (or &lt;code&gt;true&lt;/code&gt;). If unset, then the value of &lt;code&gt;color.ui&lt;/code&gt; is used (&lt;code&gt;auto&lt;/code&gt; by default).</source>
          <target state="translated">設定すると、行の先頭のキーワードが強調表示されます。キーワードは「エラー」、「警告」、「ヒント」、「成功」で、大文字と小文字を区別せずに一致します。ように設定することができる &lt;code&gt;always&lt;/code&gt; 、 &lt;code&gt;false&lt;/code&gt; （または &lt;code&gt;never&lt;/code&gt; ）または &lt;code&gt;auto&lt;/code&gt; （または &lt;code&gt;true&lt;/code&gt; ）。設定しない場合、 &lt;code&gt;color.ui&lt;/code&gt; の値が使用されます（デフォルトでは &lt;code&gt;auto&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="b183dd8c0ffee365fe58a6a334a19fb15f9512f0" translate="yes" xml:space="preserve">
          <source>If set, prints debugging information about various reads/writes.</source>
          <target state="translated">設定すると、さまざまな読み書きに関するデバッグ情報を表示します。</target>
        </trans-unit>
        <trans-unit id="b8c5d5bfb05b8eec245d869376183965da454ecd" translate="yes" xml:space="preserve">
          <source>If set, provide a user defined default policy for all protocols which don&amp;rsquo;t explicitly have a policy (&lt;code&gt;protocol.&amp;lt;name&amp;gt;.allow&lt;/code&gt;). By default, if unset, known-safe protocols (http, https, git, ssh, file) have a default policy of &lt;code&gt;always&lt;/code&gt;, known-dangerous protocols (ext) have a default policy of &lt;code&gt;never&lt;/code&gt;, and all other protocols have a default policy of &lt;code&gt;user&lt;/code&gt;. Supported policies:</source>
          <target state="translated">設定されている場合、ポリシーを明示的に持たないすべてのプロトコルに対してユーザー定義のデフォルトポリシーを提供します（ &lt;code&gt;protocol.&amp;lt;name&amp;gt;.allow&lt;/code&gt; ）。デフォルトでは、未設定の既知の安全なプロトコル（http、https、git、ssh、file）のデフォルトポリシーは &lt;code&gt;always&lt;/code&gt; であり、既知の危険なプロトコル（ext）のデフォルトポリシーは &lt;code&gt;never&lt;/code&gt; であり、他のすべてのプロトコルにはデフォルトポリシーがあります &lt;code&gt;user&lt;/code&gt; 。サポートされるポリシー：</target>
        </trans-unit>
        <trans-unit id="8d4a6e984ec5e0aad11e32a678cf60da360c5f1c" translate="yes" xml:space="preserve">
          <source>If set, specifies the outgoing SMTP server option to use. Default value can be specified by the &lt;code&gt;sendemail.smtpServerOption&lt;/code&gt; configuration option.</source>
          <target state="translated">設定されている場合、使用する送信SMTPサーバーオプションを指定します。デフォルト値は、 &lt;code&gt;sendemail.smtpServerOption&lt;/code&gt; 構成オプションで指定できます。</target>
        </trans-unit>
        <trans-unit id="0fab27431c274f5a81ff1327c3c271e3371074f0" translate="yes" xml:space="preserve">
          <source>If set, specifies the outgoing SMTP server to use (e.g. &lt;code&gt;smtp.example.com&lt;/code&gt; or a raw IP address). Alternatively it can specify a full pathname of a sendmail-like program instead; the program must support the &lt;code&gt;-i&lt;/code&gt; option. Default value can be specified by the &lt;code&gt;sendemail.smtpServer&lt;/code&gt; configuration option; the built-in default is to search for &lt;code&gt;sendmail&lt;/code&gt; in &lt;code&gt;/usr/sbin&lt;/code&gt;, &lt;code&gt;/usr/lib&lt;/code&gt; and $PATH if such program is available, falling back to &lt;code&gt;localhost&lt;/code&gt; otherwise.</source>
          <target state="translated">設定されている場合、使用する送信SMTPサーバーを指定します（例： &lt;code&gt;smtp.example.com&lt;/code&gt; または未加工のIPアドレス）。あるいは、代わりにsendmailのようなプログラムの完全パス名を指定できます。プログラムは &lt;code&gt;-i&lt;/code&gt; オプションをサポートしている必要があります。デフォルト値は &lt;code&gt;sendemail.smtpServer&lt;/code&gt; 構成オプションで指定できます。組み込みのデフォルトでは、 &lt;code&gt;/usr/sbin&lt;/code&gt; 、 &lt;code&gt;/usr/lib&lt;/code&gt; 、および$ PATH で &lt;code&gt;sendmail&lt;/code&gt; を検索し、そのようなプログラムが利用可能な場合は、そうでない場合は &lt;code&gt;localhost&lt;/code&gt; にフォールバックします。</target>
        </trans-unit>
        <trans-unit id="95132676994fa7152c54abc8928412e3414f6991" translate="yes" xml:space="preserve">
          <source>If set, store cookies received during requests to the file specified by http.cookieFile. Has no effect if http.cookieFile is unset.</source>
          <target state="translated">設定されている場合、リクエスト中に受け取ったクッキーを http.cookieFile で指定されたファイルに保存します。http.cookieFile が設定されていない場合は何の効果もありません。</target>
        </trans-unit>
        <trans-unit id="9802dde85fc0323285bb8c0402ffcc333cf47ed2" translate="yes" xml:space="preserve">
          <source>If set, the value of this variable is used as a command which will identify all files that may have changed since the requested date/time. This information is used to speed up git by avoiding unnecessary processing of files that have not changed. See the &quot;fsmonitor-watchman&quot; section of &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;.</source>
          <target state="translated">設定されている場合、この変数の値は、要求された日時以降に変更された可能性のあるすべてのファイルを識別するコマンドとして使用されます。この情報は、変更されていないファイルの不要な処理を回避することでgitを高速化するために使用されます。&lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt;の「fsmonitor-watchman」セクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="9612a7f8efdd3501a24381e7aae358082b8ef892" translate="yes" xml:space="preserve">
          <source>If some &lt;code&gt;&amp;lt;token&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; arguments are also passed on the command line, when a &lt;code&gt;trailer.&amp;lt;token&amp;gt;.command&lt;/code&gt; is configured, the command will also be executed for each of these arguments. And the &amp;lt;value&amp;gt; part of these arguments, if any, will be used to replace the &lt;code&gt;$ARG&lt;/code&gt; string in the command.</source>
          <target state="translated">コマンドラインでいくつかの &lt;code&gt;&amp;lt;token&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; 引数も渡された場合、 &lt;code&gt;trailer.&amp;lt;token&amp;gt;.command&lt;/code&gt; が構成されていると、コマンドはこれらの各引数に対しても実行されます。そして、これらの引数の&amp;lt;value&amp;gt;部分があれば、それがコマンドの &lt;code&gt;$ARG&lt;/code&gt; 文字列を置き換えるために使用されます。</target>
        </trans-unit>
        <trans-unit id="00679e1f1be4cb3b83ae3531e0f65d104df1ba84" translate="yes" xml:space="preserve">
          <source>If some files could not be added because of errors indexing them, do not abort the operation, but continue adding the others. The command shall still exit with non-zero status. The configuration variable &lt;code&gt;add.ignoreErrors&lt;/code&gt; can be set to true to make this the default behaviour.</source>
          <target state="translated">インデックス作成エラーのために一部のファイルを追加できなかった場合は、操作を中止せずに、他のファイルの追加を続行してください。コマンドは依然としてゼロ以外のステータスで終了します。構成変数 &lt;code&gt;add.ignoreErrors&lt;/code&gt; をtrueに設定して、これをデフォルトの動作にすることができます。</target>
        </trans-unit>
        <trans-unit id="02424da36361565abc928c3cd12899bb91686b1d" translate="yes" xml:space="preserve">
          <source>If some of the merge bases are skipped, then the bisection process continues, but the following message is printed for each skipped merge base:</source>
          <target state="translated">マージベースの一部がスキップされた場合、二等分処理は続行されますが、スキップされたマージベースごとに以下のメッセージが表示されます。</target>
        </trans-unit>
        <trans-unit id="c23bec329e1ab3f8ab844a76b3b2aad8e4c54310" translate="yes" xml:space="preserve">
          <source>If somebody got a release tag from you, you cannot just change the tag for them by updating your own one. This is a big security issue, in that people MUST be able to trust their tag-names. If you really want to do the insane thing, you need to just fess up to it, and tell people that you messed up. You can do that by making a very public announcement saying:</source>
          <target state="translated">誰かがあなたからリリースタグを受け取った場合、あなた自身のタグを更新することでそのタグを変更することはできません。これは大きなセキュリティ上の問題で、人々は自分のタグ名を信頼できなければなりません。もしあなたが本当に非常識なことをしたいのであれば、あなたはそれを認めて、あなたが台無しにしたことを人々に伝える必要があります。そうするには、非常に公的な発表をする必要があります。</target>
        </trans-unit>
        <trans-unit id="9c1822b09998ebb74d19f39d240afd93e64789bf" translate="yes" xml:space="preserve">
          <source>If someone else administers the server, they should tell you what directory to put the repository in, and what &lt;code&gt;git://&lt;/code&gt; URL it will appear at. You can then skip to the section &quot;&lt;a href=&quot;#pushing-changes-to-a-public-repository&quot;&gt;Pushing changes to a public repository&lt;/a&gt;&quot;, below.</source>
          <target state="translated">他の誰かがサーバーを管理している場合は、リポジトリを配置するディレクトリと、それが表示される &lt;code&gt;git://&lt;/code&gt; URL を教えてください。その後、以下の「&lt;a href=&quot;#pushing-changes-to-a-public-repository&quot;&gt;パブリックリポジトリへの変更のプッシュ&lt;/a&gt;」セクションにスキップできます。</target>
        </trans-unit>
        <trans-unit id="4199717fddcec6935af08019e365f779fa359364" translate="yes" xml:space="preserve">
          <source>If specified twice, show in addition the unified diff between what would be committed and the worktree files, i.e. the unstaged changes to tracked files.</source>
          <target state="translated">2回指定された場合、コミットされるものとワークツリーファイル間の統一された差分、つまりトラッキングファイルへの未段階の変更を表示します。</target>
        </trans-unit>
        <trans-unit id="fcf7bcff6fb66a8267ebcd9b00a7e09f8cfe6596" translate="yes" xml:space="preserve">
          <source>If that version is broken, type</source>
          <target state="translated">そのバージョンが壊れている場合は</target>
        </trans-unit>
        <trans-unit id="c26c727c738ef7a0a9fa459f5d8c7e2c7478ba23" translate="yes" xml:space="preserve">
          <source>If the &quot;pattern&quot; URL does include a path component, then this too must match exactly: the context &lt;code&gt;https://example.com/bar/baz.git&lt;/code&gt; will match a config entry for &lt;code&gt;https://example.com/bar/baz.git&lt;/code&gt; (in addition to matching the config entry for &lt;code&gt;https://example.com&lt;/code&gt;) but will not match a config entry for &lt;code&gt;https://example.com/bar&lt;/code&gt;.</source>
          <target state="translated">「パターン」URLにパスコンポーネントが含まれている場合、これも &lt;code&gt;https://example.com/bar/baz.git&lt;/code&gt; に一致する必要があります。コンテキストhttps://example.com/bar/baz.gitは、https：//example.com/bar/の構成エントリと一致し &lt;code&gt;https://example.com/bar/baz.git&lt;/code&gt; （のための設定項目のマッチングに加えて &lt;code&gt;https://example.com&lt;/code&gt; をもののための設定項目と一致しません） &lt;code&gt;https://example.com/bar&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="c4d8f312459b1b390b1c7f9b1bd219e73052861c" translate="yes" xml:space="preserve">
          <source>If the &amp;lt;value&amp;gt; part of any trailer contains only whitespace, the whole trailer will be removed from the resulting message. This applies to existing trailers as well as new trailers.</source>
          <target state="translated">トレーラーの&amp;lt;value&amp;gt;部分に空白のみが含まれている場合、トレーラー全体が結果のメッセージから削除されます。これは、既存のトレーラーと新しいトレーラーに適用されます。</target>
        </trans-unit>
        <trans-unit id="b64722d374d9ba94f59d4b75e0b20b3d04a38c9e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$GIT_DIR&lt;/code&gt; environment variable is set then it specifies a path to use instead of &lt;code&gt;./.git&lt;/code&gt; for the base of the repository.</source>
          <target state="translated">場合は &lt;code&gt;$GIT_DIR&lt;/code&gt; 環境変数が設定されている、それはの代わりに使用するパスを指定する &lt;code&gt;./.git&lt;/code&gt; リポジトリのベースのために。</target>
        </trans-unit>
        <trans-unit id="010f47d5eb5a20440d8f9779a052d1045e200486" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--anonymize&lt;/code&gt; option is given, git will attempt to remove all identifying information from the repository while still retaining enough of the original tree and history patterns to reproduce some bugs. The goal is that a git bug which is found on a private repository will persist in the anonymized repository, and the latter can be shared with git developers to help solve the bug.</source>
          <target state="translated">&lt;code&gt;--anonymize&lt;/code&gt; オプションが指定されている場合、gitは、いくつかのバグを再現するのに十分な元のツリーと履歴パターンを保持しながら、リポジトリからすべての識別情報を削除しようとします。目標は、プライベートリポジトリで見つかったgitバグが匿名化されたリポジトリに存続し、後者をgit開発者と共有してバグの解決に役立てることです。</target>
        </trans-unit>
        <trans-unit id="c4c6f80eebbd991a705883e3a7ddf7805d5a2ad9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--autosquash&lt;/code&gt; option is enabled by default using the configuration variable &lt;code&gt;rebase.autoSquash&lt;/code&gt;, this option can be used to override and disable this setting.</source>
          <target state="translated">場合 &lt;code&gt;--autosquash&lt;/code&gt; オプションは、構成変数の使用デフォルトで有効になって &lt;code&gt;rebase.autoSquash&lt;/code&gt; を、このオプションでは、この設定を上書きして無効にするために使用することができます。</target>
        </trans-unit>
        <trans-unit id="0cf1db99e3ec777fa9fc759a96b9df8702668643" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--done&lt;/code&gt; command-line option or &lt;code&gt;feature done&lt;/code&gt; command is in use, the &lt;code&gt;done&lt;/code&gt; command is mandatory and marks the end of the stream.</source>
          <target state="translated">場合 &lt;code&gt;--done&lt;/code&gt; コマンドラインオプションまたは &lt;code&gt;feature done&lt;/code&gt; コマンドを使用している、 &lt;code&gt;done&lt;/code&gt; コマンドが必須とマークストリームの終わりです。</target>
        </trans-unit>
        <trans-unit id="a0c52682314428d0b2cfaeb79c7cb6ca41bbd107" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--include-untracked&lt;/code&gt; option is used, all untracked files are also stashed and then cleaned up with &lt;code&gt;git clean&lt;/code&gt;, leaving the working directory in a very clean state. If the &lt;code&gt;--all&lt;/code&gt; option is used instead then the ignored files are stashed and cleaned in addition to the untracked files.</source>
          <target state="translated">場合 &lt;code&gt;--include-untracked&lt;/code&gt; のオプションが使用されている、すべての人跡未踏のファイルも隠し、その後でクリーンアップされている &lt;code&gt;git clean&lt;/code&gt; 非常にクリーンな状態で作業ディレクトリを残して、。場合 &lt;code&gt;--all&lt;/code&gt; オプションは、代わりに使用され、無視されたファイルは隠しと人跡未踏のファイルに加えて洗浄されます。</target>
        </trans-unit>
        <trans-unit id="bbfa929c9630d94c6f050152effe58514108dc44" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--index&lt;/code&gt; option is used, then tries to reinstate not only the working tree&amp;rsquo;s changes, but also the index&amp;rsquo;s ones. However, this can fail, when you have conflicts (which are stored in the index, where you therefore can no longer apply the changes as they were originally).</source>
          <target state="translated">場合 &lt;code&gt;--index&lt;/code&gt; オプションが使用され、その後、作業ツリーの変更が、また、インデックスのものではないだけを回復しようとします。ただし、競合がある場合、これは失敗する可能性があります（これはインデックスに格納されているため、元の変更を適用できなくなります）。</target>
        </trans-unit>
        <trans-unit id="f3433648ddba23324bfe890535ea8fba49406cc9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--keep-index&lt;/code&gt; option is used, all changes already added to the index are left intact.</source>
          <target state="translated">場合 &lt;code&gt;--keep-index&lt;/code&gt; オプションが使用され、すでにインデックスに追加されたすべての変更がそのまま残されています。</target>
        </trans-unit>
        <trans-unit id="f0b71e8c338c336264145f9c00a25064d3a5d745" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--multiple&lt;/code&gt; option was specified, the different remotes will be fetched in parallel. If multiple submodules are fetched, they will be fetched in parallel. To control them independently, use the config settings &lt;code&gt;fetch.parallel&lt;/code&gt; and &lt;code&gt;submodule.fetchJobs&lt;/code&gt; (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">場合 &lt;code&gt;--multiple&lt;/code&gt; オプションが指定された、異なるリモコンを並列にフェッチされます。複数のサブモジュールがフェッチされる場合、それらは並行してフェッチされます。それらを個別に制御するには、構成設定 &lt;code&gt;fetch.parallel&lt;/code&gt; および &lt;code&gt;submodule.fetchJobs&lt;/code&gt; を使用します（&lt;a href=&quot;git-config&quot;&gt;git-config [1]を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="86926b76e3db734e6c786d5fed43f678b858b280" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;DISPLAY&lt;/code&gt; environment variable is not set, &lt;code&gt;git log&lt;/code&gt; is used instead. You can also give command-line options such as &lt;code&gt;-p&lt;/code&gt; and &lt;code&gt;--stat&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;DISPLAY&lt;/code&gt; 環境変数が設定されていない場合は、代わりに &lt;code&gt;git log&lt;/code&gt; が使用されます。 &lt;code&gt;-p&lt;/code&gt; や &lt;code&gt;--stat&lt;/code&gt; などのコマンドラインオプションを指定することもできます。</target>
        </trans-unit>
        <trans-unit id="d759f2e991e02f3a71fd36511a7699e5f49db70c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;GIT_ASKPASS&lt;/code&gt; environment variable is set, the program specified by the variable is invoked. A suitable prompt is provided to the program on the command line, and the user&amp;rsquo;s input is read from its standard output.</source>
          <target state="translated">場合 &lt;code&gt;GIT_ASKPASS&lt;/code&gt; の環境変数が設定され、変数で指定されたプログラムが起動されます。コマンドラインで適切なプロンプトがプログラムに提供され、ユーザーの入力が標準出力から読み取られます。</target>
        </trans-unit>
        <trans-unit id="4b682e3beccdc952b131cf46cc2adb457e7b0390" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;GIT_DIR&lt;/code&gt; environment variable is set then it specifies a path to use instead of the default &lt;code&gt;.git&lt;/code&gt; for the base of the repository. The &lt;code&gt;--git-dir&lt;/code&gt; command-line option also sets this value.</source>
          <target state="translated">場合 &lt;code&gt;GIT_DIR&lt;/code&gt; の環境変数が設定されている、それはデフォルトの代わりに使用するパスを指定します &lt;code&gt;.git&lt;/code&gt; リポジトリのベースのために。 &lt;code&gt;--git-dir&lt;/code&gt; のコマンドラインオプションも、この値を設定します。</target>
        </trans-unit>
        <trans-unit id="643cae995a607334b36d06d83fbe3fb662a8bb45" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;done&lt;/code&gt; feature is not in use, treated as if EOF was read. This can be used to tell fast-import to finish early.</source>
          <target state="translated">場合 &lt;code&gt;done&lt;/code&gt; 機能が使用されていないEOFが読まれたかのように、処理されました。これを使用して、高速インポートに早期終了を指示できます。</target>
        </trans-unit>
        <trans-unit id="18aa9d79f5a644e72e69f66c98e1e834c977b6b0" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;filter&lt;/code&gt; feature is advertised, the following argument can be included in the client&amp;rsquo;s request:</source>
          <target state="translated">場合は &lt;code&gt;filter&lt;/code&gt; 機能が公示され、次の引数は、クライアントの要求に含めることができます。</target>
        </trans-unit>
        <trans-unit id="338c6269ff70e3588bd2606af346bee907c22325" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;git credential&lt;/code&gt; knew about the password, this step may not have involved the user actually typing this password (the user may have typed a password to unlock the keychain instead, or no user interaction was done if the keychain was already unlocked) before it returned &lt;code&gt;password=secr3t&lt;/code&gt;.</source>
          <target state="translated">場合は &lt;code&gt;git credential&lt;/code&gt; パスワードを知っていた、このステップは、実際にこのパスワードを入力して、ユーザーが（ユーザーが代わりにキーチェーンのロックを解除するためのパスワードを入力したこと、またはキーチェーンがすでにロック解除された場合、ユーザーとの対話は行われませんでした）が関与していない可能性があり、その前に返された &lt;code&gt;password=secr3t&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="042e7419aeefb97aea8089e7aef725093dfeada4" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;packfile-uris&lt;/code&gt; feature is advertised, the following argument can be included in the client&amp;rsquo;s request as well as the potential addition of the &lt;code&gt;packfile-uris&lt;/code&gt; section in the server&amp;rsquo;s response as explained below.</source>
          <target state="translated">場合は &lt;code&gt;packfile-uris&lt;/code&gt; 機能がアドバタイズされ、次の引数は、クライアントの要求などの潜在的な追加に含めることができます &lt;code&gt;packfile-uris&lt;/code&gt; 以下に説明するように、サーバーの応答セクション。</target>
        </trans-unit>
        <trans-unit id="1e7bad5825e1ca0d0f2641273cfd194a2b47fe7f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ref-in-want&lt;/code&gt; feature is advertised, the following argument can be included in the client&amp;rsquo;s request as well as the potential addition of the &lt;code&gt;wanted-refs&lt;/code&gt; section in the server&amp;rsquo;s response as explained below.</source>
          <target state="translated">場合は &lt;code&gt;ref-in-want&lt;/code&gt; の機能がアドバタイズされ、次の引数は、クライアントの要求などの潜在的な追加に含めることができます &lt;code&gt;wanted-refs&lt;/code&gt; 以下に説明するように、サーバーの応答セクション。</target>
        </trans-unit>
        <trans-unit id="8ee9fffd993cfbf2d4a66bab484646e0aab5c31d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;shallow&lt;/code&gt; feature is advertised the following arguments can be included in the clients request as well as the potential addition of the &lt;code&gt;shallow-info&lt;/code&gt; section in the server&amp;rsquo;s response as explained below.</source>
          <target state="translated">&lt;code&gt;shallow&lt;/code&gt; 機能がアドバタイズされている場合、以下で説明するように、サーバーの応答に &lt;code&gt;shallow-info&lt;/code&gt; セクションが追加される可能性と同様に、クライアント要求に次の引数を含めることができます。</target>
        </trans-unit>
        <trans-unit id="cc56c6c35649e4cbd1848d389261cbadfd34e234" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;sideband-all&lt;/code&gt; feature is advertised, the following argument can be included in the client&amp;rsquo;s request:</source>
          <target state="translated">場合 &lt;code&gt;sideband-all&lt;/code&gt; 機能が公示され、次の引数は、クライアントの要求に含めることができます。</target>
        </trans-unit>
        <trans-unit id="5221b8fce1b302181f6152b9a7b516c793a8424a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;text&lt;/code&gt; attribute is unspecified, Git uses the &lt;code&gt;core.autocrlf&lt;/code&gt; configuration variable to determine if the file should be converted.</source>
          <target state="translated">&lt;code&gt;text&lt;/code&gt; 属性が指定されていない場合、Gitは &lt;code&gt;core.autocrlf&lt;/code&gt; 構成変数を使用して、ファイルを変換する必要があるかどうかを判断します。</target>
        </trans-unit>
        <trans-unit id="501d792e8a9528e67beb280aae4c4f6b3a3116f1" translate="yes" xml:space="preserve">
          <source>If the Git configuration variable clean.requireForce is not set to false, &lt;code&gt;git clean&lt;/code&gt; will refuse to delete files or directories unless given -f or -i. Git will refuse to modify untracked nested git repositories (directories with a .git subdirectory) unless a second -f is given.</source>
          <target state="translated">Git構成変数clean.requireForceがfalseに設定されていない場合、-fまたは-iを指定しない限り、 &lt;code&gt;git clean&lt;/code&gt; はファイルまたはディレクトリの削除を拒否します。2番目の-fが指定されない限り、Gitは追跡されていないネストされたgitリポジトリ（.gitサブディレクトリのあるディレクトリ）の変更を拒否します。</target>
        </trans-unit>
        <trans-unit id="1a08af52d1bb96063df69a1ba9c6458415ca2e42" translate="yes" xml:space="preserve">
          <source>If the HTTP transfer speed is less than &lt;code&gt;http.lowSpeedLimit&lt;/code&gt; for longer than &lt;code&gt;http.lowSpeedTime&lt;/code&gt; seconds, the transfer is aborted. Can be overridden by the &lt;code&gt;GIT_HTTP_LOW_SPEED_LIMIT&lt;/code&gt; and &lt;code&gt;GIT_HTTP_LOW_SPEED_TIME&lt;/code&gt; environment variables.</source>
          <target state="translated">HTTP転送速度が &lt;code&gt;http.lowSpeedLimit&lt;/code&gt; よりも &lt;code&gt;http.lowSpeedTime&lt;/code&gt; 、http.lowSpeedTime秒よりも長い場合、転送は中止されます。 &lt;code&gt;GIT_HTTP_LOW_SPEED_LIMIT&lt;/code&gt; および &lt;code&gt;GIT_HTTP_LOW_SPEED_TIME&lt;/code&gt; 環境変数によってオーバーライドできます。</target>
        </trans-unit>
        <trans-unit id="6c44d5cf7886c82987c35de787d30a82008f591b" translate="yes" xml:space="preserve">
          <source>If the action is &lt;code&gt;approve&lt;/code&gt; or &lt;code&gt;reject&lt;/code&gt;, no output should be emitted.</source>
          <target state="translated">アクションが &lt;code&gt;approve&lt;/code&gt; または &lt;code&gt;reject&lt;/code&gt; の場合、出力は発行されません。</target>
        </trans-unit>
        <trans-unit id="a7a299c18f6719e8e8b963c0bc834abd5de39626" translate="yes" xml:space="preserve">
          <source>If the action is &lt;code&gt;approve&lt;/code&gt;, git-credential will send the description to any configured credential helpers, which may store the credential for later use.</source>
          <target state="translated">アクションが &lt;code&gt;approve&lt;/code&gt; の場合、git-credentialは、構成された資格情報ヘルパーに説明を送信します。ヘルパーは、後で使用するために資格情報を保存する場合があります。</target>
        </trans-unit>
        <trans-unit id="7fc4d66ebd944d4cf73c3d3a8712c0dec288c62f" translate="yes" xml:space="preserve">
          <source>If the action is &lt;code&gt;fill&lt;/code&gt;, git-credential will attempt to add &quot;username&quot; and &quot;password&quot; attributes to the description by reading config files, by contacting any configured credential helpers, or by prompting the user. The username and password attributes of the credential description are then printed to stdout together with the attributes already provided.</source>
          <target state="translated">アクションが &lt;code&gt;fill&lt;/code&gt; の場合、git-credentialは、構成ファイルを読み取るか、構成されている資格情報ヘルパーに連絡するか、ユーザーにプロンプ​​トを表示することにより、「username」属性と「password」属性を説明に追加しようとします。資格情報の説明のユーザー名とパスワードの属性は、すでに提供されている属性と一緒にstdoutに出力されます。</target>
        </trans-unit>
        <trans-unit id="194451718843bfcaf463de902599c24ff69e0de0" translate="yes" xml:space="preserve">
          <source>If the action is &lt;code&gt;reject&lt;/code&gt;, git-credential will send the description to any configured credential helpers, which may erase any stored credential matching the description.</source>
          <target state="translated">アクションが &lt;code&gt;reject&lt;/code&gt; の場合、git-credentialは、構成された資格情報ヘルパーに説明を送信します。これにより、説明に一致する格納された資格情報が消去される場合があります。</target>
        </trans-unit>
        <trans-unit id="d8fc44b68b56d1ac1b923c6197e4ad961f9ec579" translate="yes" xml:space="preserve">
          <source>If the alias expansion is prefixed with an exclamation point, it will be treated as a shell command. For example, defining &lt;code&gt;alias.new = !gitk --all --not ORIG_HEAD&lt;/code&gt;, the invocation &lt;code&gt;git new&lt;/code&gt; is equivalent to running the shell command &lt;code&gt;gitk --all --not ORIG_HEAD&lt;/code&gt;. Note that shell commands will be executed from the top-level directory of a repository, which may not necessarily be the current directory. &lt;code&gt;GIT_PREFIX&lt;/code&gt; is set as returned by running &lt;code&gt;git rev-parse --show-prefix&lt;/code&gt; from the original current directory. See &lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse[1]&lt;/a&gt;.</source>
          <target state="translated">エイリアス展開の前に感嘆符が付いている場合、それはシェルコマンドとして扱われます。たとえば、 &lt;code&gt;alias.new = !gitk --all --not ORIG_HEAD&lt;/code&gt; 定義する場合、 &lt;code&gt;git new&lt;/code&gt; の呼び出しはシェルコマンド &lt;code&gt;gitk --all --not ORIG_HEAD&lt;/code&gt; を実行することと同じです。シェルコマンドは、リポジトリの最上位ディレクトリから実行されることに注意してください。これは、必ずしも現在のディレクトリであるとは限りません。 &lt;code&gt;GIT_PREFIX&lt;/code&gt; は、元の現在のディレクトリから &lt;code&gt;git rev-parse --show-prefix&lt;/code&gt; を実行して返されるように設定されます。&lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse [1]を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="81bb3cca543b16e19f5e2adb35c917e85fde2f7d" translate="yes" xml:space="preserve">
          <source>If the amount of memory estimated for &lt;code&gt;git repack&lt;/code&gt; to run smoothly is not available and &lt;code&gt;gc.bigPackThreshold&lt;/code&gt; is not set, the largest pack will also be excluded (this is the equivalent of running &lt;code&gt;git gc&lt;/code&gt; with &lt;code&gt;--keep-base-pack&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;git repack&lt;/code&gt; &lt;code&gt;gc.bigPackThreshold&lt;/code&gt; スムーズに実行するために見積もられたメモリの量が利用できず、gc.bigPackThresholdが設定されていない場合、最大のパックも除外されます（これは &lt;code&gt;git gc&lt;/code&gt; を &lt;code&gt;--keep-base-pack&lt;/code&gt; で実行するのと同じです）。</target>
        </trans-unit>
        <trans-unit id="28ae5c748411e761b0bfb160798c17e5330bf010" translate="yes" xml:space="preserve">
          <source>If the anonymized repository shows the bug, it may be worth sharing &lt;code&gt;anon-stream&lt;/code&gt; along with a regular bug report. Note that the anonymized stream compresses very well, so gzipping it is encouraged. If you want to examine the stream to see that it does not contain any private data, you can peruse it directly before sending. You may also want to try:</source>
          <target state="translated">匿名化されたリポジトリがバグを示している場合は、通常のバグレポートとともに &lt;code&gt;anon-stream&lt;/code&gt; 共有する価値があるかもしれません。匿名化されたストリームは非常によく圧縮されるので、gzipすることをお勧めします。ストリームを調べてプライベートデータが含まれていないことを確認したい場合は、送信する前に直接閲覧できます。あなたも試してみたいかもしれません：</target>
        </trans-unit>
        <trans-unit id="723ec66f7929012c8a6ac732a23c4db7a105b505" translate="yes" xml:space="preserve">
          <source>If the attribute &lt;code&gt;export-subst&lt;/code&gt; is set for a file then Git will expand several placeholders when adding this file to an archive. The expansion depends on the availability of a commit ID, i.e., if &lt;a href=&quot;git-archive&quot;&gt;git-archive[1]&lt;/a&gt; has been given a tree instead of a commit or a tag then no replacement will be done. The placeholders are the same as those for the option &lt;code&gt;--pretty=format:&lt;/code&gt; of &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, except that they need to be wrapped like this: &lt;code&gt;$Format:PLACEHOLDERS$&lt;/code&gt; in the file. E.g. the string &lt;code&gt;$Format:%H$&lt;/code&gt; will be replaced by the commit hash.</source>
          <target state="translated">属性 &lt;code&gt;export-subst&lt;/code&gt; がファイルに設定されている場合、Gitはこのファイルをアーカイブに追加するときにいくつかのプレースホルダーを展開します。拡張は、コミットIDの可用性に依存します。つまり、&lt;a href=&quot;git-archive&quot;&gt;git-archive [1]に&lt;/a&gt;コミットまたはタグの代わりにツリーが指定されている場合、置換は行われません。プレースホルダーは、オプション &lt;code&gt;--pretty=format:&lt;/code&gt; の&lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt;のプレースホルダーと同じですが、ファイル内で &lt;code&gt;$Format:PLACEHOLDERS$&lt;/code&gt; ようにラップする必要がある点が異なります。たとえば、文字列 &lt;code&gt;$Format:%H$&lt;/code&gt; はコミットハッシュに置き換えられます。</target>
        </trans-unit>
        <trans-unit id="bd056a8735e1abbf79ce6a360a1a80c3f28cbbd6" translate="yes" xml:space="preserve">
          <source>If the attribute export-subst is set for a file then Git will expand several placeholders when adding this file to an archive. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">属性export-substがファイルに設定されている場合、Gitはこのファイルをアーカイブに追加するときにいくつかのプレースホルダーを展開します。詳細については、&lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="da80064c2ffb4013d75c1676828faa86849266b6" translate="yes" xml:space="preserve">
          <source>If the bisection process is driven manually, you can use &quot;git bisect skip&quot; to do the same thing. (In fact the special exit code 125 makes &quot;git bisect run&quot; use &quot;git bisect skip&quot; in the background.)</source>
          <target state="translated">バイセクション処理が手動で駆動されている場合は、&quot;git bisect skip &quot;を使っても同じことができます。(実際には、特別な終了コード125により、&quot;git bisect run &quot;はバックグラウンドで &quot;git bisect skip &quot;を使用するようになっています)。</target>
        </trans-unit>
        <trans-unit id="92ad120c671c36b884538f372611cf38d29a6827" translate="yes" xml:space="preserve">
          <source>If the branch exists in multiple remotes and one of them is named by the &lt;code&gt;checkout.defaultRemote&lt;/code&gt; configuration variable, we&amp;rsquo;ll use that one for the purposes of disambiguation, even if the &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; isn&amp;rsquo;t unique across all remotes. Set it to e.g. &lt;code&gt;checkout.defaultRemote=origin&lt;/code&gt; to always checkout remote branches from there if &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; is ambiguous but exists on the &lt;code&gt;origin&lt;/code&gt; remote. See also &lt;code&gt;checkout.defaultRemote&lt;/code&gt; in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">ブランチが複数のリモートに存在し、そのうちの1つが &lt;code&gt;checkout.defaultRemote&lt;/code&gt; 構成変数によって名前が付けられている場合、 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; がすべてのリモート間で一意でなくても、明確にするためにそのブランチを使用します。たとえば、 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; があいまいであるが、 &lt;code&gt;origin&lt;/code&gt; リモートに存在する場合は、 &lt;code&gt;checkout.defaultRemote=origin&lt;/code&gt; に設定して、そこからリモートブランチを常にチェックアウトします。参照してください &lt;code&gt;checkout.defaultRemote&lt;/code&gt; はに&lt;a href=&quot;git-config&quot;&gt;はgit-config設定[1] &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c39c5c03f65f2a5b7cc29c6c30fb330e225795da" translate="yes" xml:space="preserve">
          <source>If the changes are independent enough, Git will automatically complete the merge and commit the result (or reuse an existing commit in case of &lt;a href=&quot;#fast-forwards&quot;&gt;fast-forward&lt;/a&gt;, see below). On the other hand, if there are conflicts&amp;mdash;​for example, if the same file is modified in two different ways in the remote branch and the local branch&amp;mdash;​then you are warned; the output may look something like this:</source>
          <target state="translated">変更が十分に独立している場合、Gitは自動的にマージを完了して結果をコミットします（または&lt;a href=&quot;#fast-forwards&quot;&gt;fast-forwardの&lt;/a&gt;場合は既存のコミットを再利用します。以下を参照してください）。一方、リモートブランチとローカルブランチで同じファイルが2つの異なる方法で変更された場合など、競合がある場合は警告が表示されます。出力は次のようになります。</target>
        </trans-unit>
        <trans-unit id="288f48e57898c3a0706dea1db36d760600650737" translate="yes" xml:space="preserve">
          <source>If the changes don&amp;rsquo;t conflict, you&amp;rsquo;re done. If there are conflicts, markers will be left in the problematic files showing the conflict;</source>
          <target state="translated">変更が競合しない場合は、完了です。競合がある場合、マーカーは競合を示す問題のあるファイルに残されます。</target>
        </trans-unit>
        <trans-unit id="0c9dca535f00f8f010f3f51cbdf5a64ba071ad26" translate="yes" xml:space="preserve">
          <source>If the checkout is done via rebase, local submodule commits are rebased as well.</source>
          <target state="translated">チェックアウトがリベースで行われる場合、ローカルのサブモジュールのコミットもリベースされます。</target>
        </trans-unit>
        <trans-unit id="da1ce847fd50c0ebce51907161b2297389c68a97" translate="yes" xml:space="preserve">
          <source>If the command contains the &lt;code&gt;$ARG&lt;/code&gt; string, this string will be replaced with the &amp;lt;value&amp;gt; part of an existing trailer with the same &amp;lt;token&amp;gt;, if any, before the command is launched.</source>
          <target state="translated">コマンドに &lt;code&gt;$ARG&lt;/code&gt; 文字列が含まれている場合、この文字列は、コマンドが起動される前に、同じ&amp;lt;token&amp;gt;があれば、既存のトレーラーの&amp;lt;value&amp;gt;部分で置き換えられます。</target>
        </trans-unit>
        <trans-unit id="d68b3a0db25981cb416126191f5f7a8b40a5795b" translate="yes" xml:space="preserve">
          <source>If the commit is a merge commit, you must tell &lt;code&gt;git cvsexportcommit&lt;/code&gt; what parent the changeset should be done against.</source>
          <target state="translated">コミットがマージコミットの場合、変更セットを &lt;code&gt;git cvsexportcommit&lt;/code&gt; する親をgit cvsexportcommitに伝える必要があります。</target>
        </trans-unit>
        <trans-unit id="50eff6c32d5b1376396b813f799767464152ed15" translate="yes" xml:space="preserve">
          <source>If the commit is a merge, and if the pretty-format is not &lt;code&gt;oneline&lt;/code&gt;, &lt;code&gt;email&lt;/code&gt; or &lt;code&gt;raw&lt;/code&gt;, an additional line is inserted before the &lt;code&gt;Author:&lt;/code&gt; line. This line begins with &quot;Merge: &quot; and the hashes of ancestral commits are printed, separated by spaces. Note that the listed commits may not necessarily be the list of the &lt;strong&gt;direct&lt;/strong&gt; parent commits if you have limited your view of history: for example, if you are only interested in changes related to a certain directory or file.</source>
          <target state="translated">コミットがマージで、pretty-formatが &lt;code&gt;oneline&lt;/code&gt; 、 &lt;code&gt;email&lt;/code&gt; または &lt;code&gt;raw&lt;/code&gt; でない場合は、 &lt;code&gt;Author:&lt;/code&gt; 行の前に追加の行が挿入されます。この行は「Merge：」で始まり、祖先のコミットのハッシュがスペースで区切られて出力されます。履歴の表示を制限している場合、たとえば、特定のディレクトリまたはファイルに関連する変更のみに関心がある場合は、リストされているコミットが必ずしも&lt;strong&gt;直接の&lt;/strong&gt;親コミットのリストであるとは限らないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="fb562926c30c7dcdbad03cee2dab579f6b030079" translate="yes" xml:space="preserve">
          <source>If the commit is done directly by using &lt;code&gt;git&lt;/code&gt; (as opposed to using &lt;code&gt;git-cvsserver&lt;/code&gt;) the update will need to happen on the next repository access by &lt;code&gt;git-cvsserver&lt;/code&gt;, independent of access method and requested operation.</source>
          <target state="translated">コミットした場合使用して直接実行される &lt;code&gt;git&lt;/code&gt; （使用するのではなく &lt;code&gt;git-cvsserver&lt;/code&gt; 更新、次のリポジトリからのアクセスで発生する必要があります） &lt;code&gt;git-cvsserver&lt;/code&gt; 、アクセス方法に依存せず、要求された操作。</target>
        </trans-unit>
        <trans-unit id="f829bbddf6f6f452756492321328ac75e498d9d9" translate="yes" xml:space="preserve">
          <source>If the config option &lt;code&gt;uploadArchive.allowUnreachable&lt;/code&gt; is true, these rules are ignored, and clients may use arbitrary sha1 expressions. This is useful if you do not care about the privacy of unreachable objects, or if your object database is already publicly available for access via non-smart-http.</source>
          <target state="translated">構成オプション &lt;code&gt;uploadArchive.allowUnreachable&lt;/code&gt; がtrueの場合、これらのルールは無視され、クライアントは任意のsha1式を使用できます。これは、到達できないオブジェクトのプライバシーを気にしない場合、またはオブジェクトデータベースが非smart-http経由ですでにアクセスできるように公開されている場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="a1bf5bff98f507f37d5394622406355fb10d8518" translate="yes" xml:space="preserve">
          <source>If the config variable &lt;code&gt;status.relativePaths&lt;/code&gt; is set to false, then all paths shown are relative to the repository root, not to the current directory.</source>
          <target state="translated">構成変数 &lt;code&gt;status.relativePaths&lt;/code&gt; がfalseに設定されている場合、表示されるすべてのパスは、現在のディレクトリではなく、リポジトリルートからの相対パスです。</target>
        </trans-unit>
        <trans-unit id="15abc3d7884a27f6ef940ec31e7ff01ecc03f9f0" translate="yes" xml:space="preserve">
          <source>If the configuration variable &lt;code&gt;instaweb.browser&lt;/code&gt; is not set, &lt;code&gt;web.browser&lt;/code&gt; will be used instead if it is defined. See &lt;a href=&quot;git-web--browse&quot;&gt;git-web--browse[1]&lt;/a&gt; for more information about this.</source>
          <target state="translated">構成変数 &lt;code&gt;instaweb.browser&lt;/code&gt; が設定されていない場合、定義されていれば、代わりに &lt;code&gt;web.browser&lt;/code&gt; が使用されます。詳細については、&lt;a href=&quot;git-web--browse&quot;&gt;git-web--browse [1]&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="cd3ff15aa0e04d429d03e9f6131934c58fa371f6" translate="yes" xml:space="preserve">
          <source>If the configuration variable &lt;code&gt;instaweb.browser&lt;/code&gt; is not set, &lt;code&gt;web.browser&lt;/code&gt; will be used instead if it is defined. See git-web{litdd}browse[1] for more information about this.</source>
          <target state="translated">構成変数 &lt;code&gt;instaweb.browser&lt;/code&gt; が設定されていない場合、定義されていれば &lt;code&gt;web.browser&lt;/code&gt; が代わりに使用されます。これについての詳細は、git-web {litdd} browse [1]を参照してください。</target>
        </trans-unit>
        <trans-unit id="63b229ee2ee5c7c387585f3ec858739b37c09980" translate="yes" xml:space="preserve">
          <source>If the current HEAD is the same as the parent of the cherry-pick&amp;rsquo;ed commit, then a fast forward to this commit will be performed.</source>
          <target state="translated">現在のHEADがチェリーピックされたコミットの親と同じである場合、このコミットへの早送りが実行されます。</target>
        </trans-unit>
        <trans-unit id="7ca0a51612928d164dbfccc37787084c17e98850" translate="yes" xml:space="preserve">
          <source>If the custom merge tool correctly indicates the success of a merge resolution with its exit code, then the configuration variable &lt;code&gt;mergetool.&amp;lt;tool&amp;gt;.trustExitCode&lt;/code&gt; can be set to &lt;code&gt;true&lt;/code&gt;. Otherwise, &lt;code&gt;git mergetool&lt;/code&gt; will prompt the user to indicate the success of the resolution after the custom tool has exited.</source>
          <target state="translated">カスタムマージツールがその終了コードでのマージ解決の成功を正しく示している場合は、構成変数 &lt;code&gt;mergetool.&amp;lt;tool&amp;gt;.trustExitCode&lt;/code&gt; を &lt;code&gt;true&lt;/code&gt; に設定できます。それ以外の場合、 &lt;code&gt;git mergetool&lt;/code&gt; は、カスタムツールの終了後に解決の成功を示すようにユーザーに要求します。</target>
        </trans-unit>
        <trans-unit id="36390d22499feba94308c3d2a6c08dfbe3009ec3" translate="yes" xml:space="preserve">
          <source>If the exit status is non-zero, &lt;code&gt;git commit&lt;/code&gt; will abort.</source>
          <target state="translated">終了ステータスがゼロ以外の場合、 &lt;code&gt;git commit&lt;/code&gt; は中止されます。</target>
        </trans-unit>
        <trans-unit id="ffb6fc6e4737a7b7be769bd191cc211dd325235f" translate="yes" xml:space="preserve">
          <source>If the file &lt;code&gt;.mailmap&lt;/code&gt; exists at the toplevel of the repository, or at the location pointed to by the mailmap.file or mailmap.blob configuration options, it is used to map author and committer names and email addresses to canonical real names and email addresses.</source>
          <target state="translated">&lt;code&gt;.mailmap&lt;/code&gt; ファイルがリポジトリのトップレベルに存在する場合、またはmailmap.fileまたはmailmap.blob構成オプションで指定された場所に存在する場合、作成者とコミッターの名前とメールアドレスを正規の実名とメールアドレスにマッピングするために使用されます。</target>
        </trans-unit>
        <trans-unit id="7142e4ddc34f82f593252b78cfae14d3292c9524" translate="yes" xml:space="preserve">
          <source>If the file gc.log exists, then &lt;code&gt;git gc --auto&lt;/code&gt; will print its content and exit with status zero instead of running unless that file is more than &lt;code&gt;gc.logExpiry&lt;/code&gt; old. Default is &quot;1.day&quot;. See &lt;code&gt;gc.pruneExpire&lt;/code&gt; for more ways to specify its value.</source>
          <target state="translated">ファイルgc.logが存在する場合は、 &lt;code&gt;git gc --auto&lt;/code&gt; 状態ゼロの代わりに、そのファイルが複数ある場合を除き実行すると、その内容を表示し、終了します &lt;code&gt;gc.logExpiry&lt;/code&gt; 古いです。デフォルトは「1.day」です。値を指定するその他の方法については、 &lt;code&gt;gc.pruneExpire&lt;/code&gt; をご覧ください。</target>
        </trans-unit>
        <trans-unit id="7333f3457fce187a5640d74385a1bbc89a0c5a97" translate="yes" xml:space="preserve">
          <source>If the filter command (a string value) is defined via &lt;code&gt;filter.&amp;lt;driver&amp;gt;.process&lt;/code&gt; then Git can process all blobs with a single filter invocation for the entire life of a single Git command. This is achieved by using the long-running process protocol (described in technical/long-running-process-protocol.txt).</source>
          <target state="translated">フィルターコマンド（文字列値）が &lt;code&gt;filter.&amp;lt;driver&amp;gt;.process&lt;/code&gt; を介して定義されている場合、Gitは、単一のGitコマンドの存続期間全体にわたって、単一のフィルター呼び出しですべてのblobを処理できます。これは、長期実行プロセスプロトコル（technical / long-running-process-protocol.txtで説明）を使用して実現されます。</target>
        </trans-unit>
        <trans-unit id="edaaa7b77ca9e9ee284b92c3f4abf94dbe583827" translate="yes" xml:space="preserve">
          <source>If the filter dies during the communication or does not adhere to the protocol then Git will stop the filter process and restart it with the next file that needs to be processed. Depending on the &lt;code&gt;filter.&amp;lt;driver&amp;gt;.required&lt;/code&gt; flag Git will interpret that as error.</source>
          <target state="translated">通信中にフィルターが停止するか、プロトコルに準拠していない場合、Gitはフィルタープロセスを停止し、処理が必要な次のファイルからフィルターを再起動します。 &lt;code&gt;filter.&amp;lt;driver&amp;gt;.required&lt;/code&gt; フラグに応じて、Gitはそれをエラーとして解釈します。</target>
        </trans-unit>
        <trans-unit id="5e14f4a25e8ac87108268501a2fbb6eaeaabe84f" translate="yes" xml:space="preserve">
          <source>If the filter experiences an error during processing, then it can send the status &quot;error&quot; after the content was (partially or completely) sent.</source>
          <target state="translated">処理中にエラーが発生した場合、フィルタはコンテンツが (部分的または完全に)送信された後に &quot;error&quot; というステータスを送信することができます。</target>
        </trans-unit>
        <trans-unit id="4bace70b57e96bff11ceac069e6098423752b6f8" translate="yes" xml:space="preserve">
          <source>If the filter supports the &quot;delay&quot; capability then it must support the &quot;list_available_blobs&quot; command. If Git sends this command, then the filter is expected to return a list of pathnames representing blobs that have been delayed earlier and are now available. The list must be terminated with a flush packet followed by a &quot;success&quot; status that is also terminated with a flush packet. If no blobs for the delayed paths are available, yet, then the filter is expected to block the response until at least one blob becomes available. The filter can tell Git that it has no more delayed blobs by sending an empty list. As soon as the filter responds with an empty list, Git stops asking. All blobs that Git has not received at this point are considered missing and will result in an error.</source>
          <target state="translated">フィルタが &quot;delay&quot; 機能をサポートしている場合は、&quot;list_available_blobs&quot; コマンドをサポートしていなければなりません。Git がこのコマンドを送信した場合、フィルタは以前に遅延していたブロブを表すパス名のリストを返すことになります。このリストは、フラッシュパケットで終了し、その後に &quot;success&quot; ステータスで終了しなければなりません。遅延したパスのブロブがまだ利用できない場合は、少なくともひとつのブロブが利用できるようになるまで、フィルタは応答をブロックすると予想されます。フィルタは、空のリストを送ることで遅延したブロブがもうないことを Git に伝えることができます。フィルタが空のリストで応答するとすぐに、Gitは問い合わせを止めます。この時点でGitが受け取っていないブロブはすべて欠落しているとみなされ、エラーとなります。</target>
        </trans-unit>
        <trans-unit id="03052ebbe356e67d3f76578abb0f90e9da0b94ac" translate="yes" xml:space="preserve">
          <source>If the filter supports the &quot;delay&quot; capability, then Git can send the flag &quot;can-delay&quot; after the filter command and pathname. This flag denotes that the filter can delay filtering the current blob (e.g. to compensate network latencies) by responding with no content but with the status &quot;delayed&quot; and a flush packet.</source>
          <target state="translated">フィルタが &quot;delay&quot; 機能をサポートしている場合、Git はフィルタコマンドとパス名の後に &quot;can-delay&quot; フラグを送ることができます。このフラグは、フィルタが現在のブロブのフィルタリングを遅延させることができることを示します (ネットワークの遅延を補うためなど)。</target>
        </trans-unit>
        <trans-unit id="13eec1f811a3745751e3462b5df9eab594af45cb" translate="yes" xml:space="preserve">
          <source>If the format is set to &quot;auto:foo&quot; and the pager is in use, format &quot;foo&quot; will be the used for the date format. Otherwise &quot;default&quot; will be used.</source>
          <target state="translated">フォーマットが &quot;auto:foo&quot; に設定されていて、ページャーが使用されている場合、日付のフォーマットには &quot;foo&quot; が使用されます。それ以外の場合は &quot;default&quot; が使用されます。</target>
        </trans-unit>
        <trans-unit id="7402fa03babc6cbdcbdc9c0c2d38f35b3f77eedb" translate="yes" xml:space="preserve">
          <source>If the given object refers to a blob, it will be described as &lt;code&gt;&amp;lt;commit-ish&amp;gt;:&amp;lt;path&amp;gt;&lt;/code&gt;, such that the blob can be found at &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; in the &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt;, which itself describes the first commit in which this blob occurs in a reverse revision walk from HEAD.</source>
          <target state="translated">指定されたオブジェクトは、ブロブを参照する場合、それは次のように説明する &lt;code&gt;&amp;lt;commit-ish&amp;gt;:&amp;lt;path&amp;gt;&lt;/code&gt; 、ブロブがで見つけることができるように &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; で &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 自体が最初にコミット説明し、このブロブはHEADからの逆リビジョンウォークで発生します。</target>
        </trans-unit>
        <trans-unit id="5e980dfa1f5a4a3edafff4113df2abbd7d17f577" translate="yes" xml:space="preserve">
          <source>If the helper string begins with &quot;!&quot;, it is considered a shell snippet, and everything after the &quot;!&quot; becomes the command.</source>
          <target state="translated">ヘルパー文字列が&quot;!&quot;で始まる場合、それはシェルスニペットとみなされ、&quot;!&quot;以降はすべてコマンドになります。</target>
        </trans-unit>
        <trans-unit id="228c738194bda1bc3c409314b8269609d7c41e0b" translate="yes" xml:space="preserve">
          <source>If the hook exits with non-zero status, none of the refs will be updated. If the hook exits with zero, updating of individual refs can still be prevented by the &lt;a href=&quot;#update&quot;&gt;&lt;em&gt;update&lt;/em&gt;&lt;/a&gt; hook.</source>
          <target state="translated">フックがゼロ以外のステータスで終了した場合、どの参照も更新されません。フックがゼロで終了する場合でも、個々の参照の更新は、&lt;a href=&quot;#update&quot;&gt;&lt;em&gt;更新&lt;/em&gt;&lt;/a&gt;フックによって引き続き防止できます。</target>
        </trans-unit>
        <trans-unit id="8439515eb9b2d0e08bb52156ea070a5b55f21477" translate="yes" xml:space="preserve">
          <source>If the ignore-paths configuration key is set, and the command-line option is also given, both regular expressions will be used.</source>
          <target state="translated">ignore-paths 設定キーが設定されていて、コマンドラインオプションも与えられている場合は、両方の正規表現が使用されます。</target>
        </trans-unit>
        <trans-unit id="e545fa5704075d5dfeae5601c6d9858dfebf0464" translate="yes" xml:space="preserve">
          <source>If the ignore-refs configuration key is set, and the command-line option is also given, both regular expressions will be used.</source>
          <target state="translated">ignore-refs設定キーが設定されていて、コマンドラインオプションも与えられている場合は、両方の正規表現が使用されます。</target>
        </trans-unit>
        <trans-unit id="f1e0ea5f0e79a32b5a2b025af2eaf1eb5f6a9a8a" translate="yes" xml:space="preserve">
          <source>If the last path components in the working tree&amp;rsquo;s path is unique among working trees, it can be used to identify a working tree. For example if you only have two working trees, at &lt;code&gt;/abc/def/ghi&lt;/code&gt; and &lt;code&gt;/abc/def/ggg&lt;/code&gt;, then &lt;code&gt;ghi&lt;/code&gt; or &lt;code&gt;def/ghi&lt;/code&gt; is enough to point to the former working tree.</source>
          <target state="translated">作業ツリーのパスの最後のパスコンポーネントが作業ツリー間で一意である場合、それを使用して作業ツリーを識別できます。たとえば、 &lt;code&gt;/abc/def/ghi&lt;/code&gt; と &lt;code&gt;/abc/def/ggg&lt;/code&gt; の2つの作業ツリーしかない場合、 &lt;code&gt;ghi&lt;/code&gt; または &lt;code&gt;def/ghi&lt;/code&gt; で前の作業ツリーを指すことができます。</target>
        </trans-unit>
        <trans-unit id="368e2e291b26f0dca547e5b1c9de986c75896687" translate="yes" xml:space="preserve">
          <source>If the last path components in the working tree&amp;rsquo;s path is unique among working trees, it can be used to identify worktrees. For example if you only have two working trees, at &quot;/abc/def/ghi&quot; and &quot;/abc/def/ggg&quot;, then &quot;ghi&quot; or &quot;def/ghi&quot; is enough to point to the former working tree.</source>
          <target state="translated">作業ツリーのパスの最後のパスコンポーネントが作業ツリー間で一意である場合、それを使用して作業ツリーを識別できます。たとえば、 &quot;/ abc / def / ghi&quot;と &quot;/ abc / def / ggg&quot;に2つの作業ツリーしかない場合、 &quot;ghi&quot;または &quot;def / ghi&quot;で前の作業ツリーを指すことができます。</target>
        </trans-unit>
        <trans-unit id="a77fa7a1d051613196a1695412c9a05d33f69ded" translate="yes" xml:space="preserve">
          <source>If the local offset is not available in the source material, use &amp;ldquo;+0000&amp;rdquo;, or the most common local offset. For example many organizations have a CVS repository which has only ever been accessed by users who are located in the same location and time zone. In this case a reasonable offset from UTC could be assumed.</source>
          <target state="translated">ソースマテリアルでローカルオフセットが使用できない場合は、「+ 0000」または最も一般的なローカルオフセットを使用します。たとえば、多くの組織には、同じ場所とタイムゾーンにいるユーザーだけがアクセスしたCVSリポジトリがあります。この場合、UTCからの妥当なオフセットが想定されます。</target>
        </trans-unit>
        <trans-unit id="178f63f22948e35272dd2355f9864ebc5b092dbe" translate="yes" xml:space="preserve">
          <source>If the maintainer tells you that your patch no longer applies to the current upstream, you will have to rebase your topic (you cannot use a merge because you cannot format-patch merges):</source>
          <target state="translated">メンテナからパッチが現在の上流に適用されなくなったと言われた場合は、トピックをリベースする必要があります (パッチのマージをフォーマットできないため、マージを使用することはできません)。</target>
        </trans-unit>
        <trans-unit id="9b0ae610cbbc854a9104beb55038f8e674b12699" translate="yes" xml:space="preserve">
          <source>If the merge cannot be carried out automatically, the conflicts need to be resolved and the result committed separately (see &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt;). At that point, this hook will not be executed, but the &lt;code&gt;pre-commit&lt;/code&gt; hook will, if it is enabled.</source>
          <target state="translated">マージを自動的に実行できない場合は、競合を解決し、結果を個別にコミットする必要があります（&lt;a href=&quot;git-merge&quot;&gt;git-merge [1]を&lt;/a&gt;参照）。その時点では、このフックは実行されませんが、有効になっている場合は &lt;code&gt;pre-commit&lt;/code&gt; フックは実行されます。</target>
        </trans-unit>
        <trans-unit id="e1f358924aaa72264d85ec0ddf7ef92dd8191058" translate="yes" xml:space="preserve">
          <source>If the merge fails because it is not a fast-forward, then it is possible some fixes on &lt;code&gt;maint&lt;/code&gt; were missed in the feature release. This will not happen if the content of the branches was verified as described in the previous section.</source>
          <target state="translated">早送りではないためにマージが失敗した場合は、機能リリースで &lt;code&gt;maint&lt;/code&gt; 一部の修正が行われなかった可能性があります。前のセクションで説明したようにブランチのコンテンツが検証された場合、これは発生しません。</target>
        </trans-unit>
        <trans-unit id="39e28c0246f221ccbae77af3a33cb0a2f4910f1f" translate="yes" xml:space="preserve">
          <source>If the number of objects fetched over the Git native transfer is below this limit, then the objects will be unpacked into loose object files. However if the number of received objects equals or exceeds this limit then the received pack will be stored as a pack, after adding any missing delta bases. Storing the pack from a push can make the push operation complete faster, especially on slow filesystems. If not set, the value of &lt;code&gt;transfer.unpackLimit&lt;/code&gt; is used instead.</source>
          <target state="translated">Gitネイティブ転送でフェッチされたオブジェクトの数がこの制限を下回っている場合、オブジェクトはルーズオブジェクトファイルにアンパックされます。ただし、受信したオブジェクトの数がこの制限以上の場合、不足しているデルタベースを追加した後、受信したパックはパックとして保存されます。プッシュからパックを保存すると、特に遅いファイルシステムで、プッシュ操作がより速く完了する場合があります。設定しない場合、代わりに &lt;code&gt;transfer.unpackLimit&lt;/code&gt; の値が使用されます。</target>
        </trans-unit>
        <trans-unit id="ba1c0757ead2b007fd4bc7bc8fe3299d5f283bd7" translate="yes" xml:space="preserve">
          <source>If the number of objects imported by &lt;a href=&quot;git-fast-import&quot;&gt;git-fast-import[1]&lt;/a&gt; is below this limit, then the objects will be unpacked into loose object files. However if the number of imported objects equals or exceeds this limit then the pack will be stored as a pack. Storing the pack from a fast-import can make the import operation complete faster, especially on slow filesystems. If not set, the value of &lt;code&gt;transfer.unpackLimit&lt;/code&gt; is used instead.</source>
          <target state="translated">&lt;a href=&quot;git-fast-import&quot;&gt;git-fast-import [1]&lt;/a&gt;によってインポートされたオブジェクトの数がこの制限を下回っている場合、オブジェクトはルーズオブジェクトファイルにアンパックされます。ただし、インポートされたオブジェクトの数がこの制限以上の場合、パックはパックとして保存されます。高速インポートからパックを保存すると、特に低速のファイルシステムで、インポート操作がより速く完了します。設定しない場合、代わりに &lt;code&gt;transfer.unpackLimit&lt;/code&gt; の値が使用されます。</target>
        </trans-unit>
        <trans-unit id="66dbfca32684aa415437926e2128b562d1010471" translate="yes" xml:space="preserve">
          <source>If the number of objects received in a push is below this limit then the objects will be unpacked into loose object files. However if the number of received objects equals or exceeds this limit then the received pack will be stored as a pack, after adding any missing delta bases. Storing the pack from a push can make the push operation complete faster, especially on slow filesystems. If not set, the value of &lt;code&gt;transfer.unpackLimit&lt;/code&gt; is used instead.</source>
          <target state="translated">プッシュで受信したオブジェクトの数がこの制限を下回る場合、オブジェクトはルーズオブジェクトファイルにアンパックされます。ただし、受信したオブジェクトの数がこの制限以上の場合、不足しているデルタベースを追加した後、受信したパックはパックとして保存されます。プッシュからパックを保存すると、特に遅いファイルシステムで、プッシュ操作がより速く完了する場合があります。設定しない場合、代わりに &lt;code&gt;transfer.unpackLimit&lt;/code&gt; の値が使用されます。</target>
        </trans-unit>
        <trans-unit id="e5106f465347ea1c1f64d4a4e406ce8334671d0b" translate="yes" xml:space="preserve">
          <source>If the object being copied out to a temporary file is a symbolic link the content of the link will be written to a normal file. It is up to the end-user or the Porcelain to make use of this information.</source>
          <target state="translated">一時ファイルにコピーアウトされるオブジェクトがシンボリックリンクの場合、リンクの内容は通常のファイルに書き込まれます。この情報を利用するかどうかは、エンドユーザーまたはポーセラーツにかかっています。</target>
        </trans-unit>
        <trans-unit id="0199138006db8140692b7fdc79404759dcaa332d" translate="yes" xml:space="preserve">
          <source>If the object is stored as a delta on-disk, this expands to the 40-hex sha1 of the delta base object. Otherwise, expands to the null sha1 (40 zeroes). See &lt;code&gt;CAVEATS&lt;/code&gt; below.</source>
          <target state="translated">オブジェクトがディスク上のデルタとして保存されている場合、これはデルタベースオブジェクトの40 hex sha1に拡張されます。それ以外の場合は、null sha1（40個のゼロ）に展開されます。以下の &lt;code&gt;CAVEATS&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="bd902b813b2d32a3c916d53036b9b4661bcff5a2" translate="yes" xml:space="preserve">
          <source>If the object storage directory is specified via the &lt;code&gt;$GIT_OBJECT_DIRECTORY&lt;/code&gt; environment variable then the sha1 directories are created underneath - otherwise the default &lt;code&gt;$GIT_DIR/objects&lt;/code&gt; directory is used.</source>
          <target state="translated">オブジェクトストレージディレクトリが &lt;code&gt;$GIT_OBJECT_DIRECTORY&lt;/code&gt; 環境変数を介して指定されている場合、sha1ディレクトリがその下に作成されます。それ以外の場合は、デフォルトの &lt;code&gt;$GIT_DIR/objects&lt;/code&gt; ディレクトリが使用されます。</target>
        </trans-unit>
        <trans-unit id="5445d9592417f6217da69d0d0ffe49e2288619f2" translate="yes" xml:space="preserve">
          <source>If the object storage directory is specified via this environment variable then the sha1 directories are created underneath - otherwise the default &lt;code&gt;$GIT_DIR/objects&lt;/code&gt; directory is used.</source>
          <target state="translated">この環境変数を介してオブジェクトストレージディレクトリを指定すると、sha1ディレクトリがその下に作成されます。それ以外の場合は、デフォルトの &lt;code&gt;$GIT_DIR/objects&lt;/code&gt; ディレクトリが使用されます。</target>
        </trans-unit>
        <trans-unit id="5f2dc3f2759f3e631848eb5ab78d16a8be4a1f31" translate="yes" xml:space="preserve">
          <source>If the option &lt;code&gt;--all&lt;/code&gt; or &lt;code&gt;-a&lt;/code&gt; is given, all available commands are printed on the standard output.</source>
          <target state="translated">オプション &lt;code&gt;--all&lt;/code&gt; または &lt;code&gt;-a&lt;/code&gt; を指定すると、使用可能なすべてのコマンドが標準出力に出力されます。</target>
        </trans-unit>
        <trans-unit id="5db3d9ce81a9166e23fdfafcb7cf25752ff75423" translate="yes" xml:space="preserve">
          <source>If the option &lt;code&gt;--guide&lt;/code&gt; or &lt;code&gt;-g&lt;/code&gt; is given, a list of the useful Git guides is also printed on the standard output.</source>
          <target state="translated">オプション &lt;code&gt;--guide&lt;/code&gt; または &lt;code&gt;-g&lt;/code&gt; を指定すると、有用なGitガイドのリストも標準出力に出力されます。</target>
        </trans-unit>
        <trans-unit id="401de2382d11b6e27d9e64da4738d460ce293134" translate="yes" xml:space="preserve">
          <source>If the option &lt;code&gt;--guides&lt;/code&gt; or &lt;code&gt;-g&lt;/code&gt; is given, a list of the Git concept guides is also printed on the standard output.</source>
          <target state="translated">オプション &lt;code&gt;--guides&lt;/code&gt; または &lt;code&gt;-g&lt;/code&gt; を指定すると、Gitコンセプトガイドのリストも標準出力に出力されます。</target>
        </trans-unit>
        <trans-unit id="22d4a6b6cbe8c87e55028aafc6f2a3b165e3a3fa" translate="yes" xml:space="preserve">
          <source>If the patch contains any changes to submodules then &lt;code&gt;git apply&lt;/code&gt; treats these changes as follows.</source>
          <target state="translated">パッチにサブモジュールへの変更が含まれている場合、 &lt;code&gt;git apply&lt;/code&gt; はこれらの変更を次のように扱います。</target>
        </trans-unit>
        <trans-unit id="bc5f440658cbf7f8fc36476e96067d0db070086e" translate="yes" xml:space="preserve">
          <source>If the pattern does not start with either &lt;code&gt;~/&lt;/code&gt;, &lt;code&gt;./&lt;/code&gt; or &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;**/&lt;/code&gt; will be automatically prepended. For example, the pattern &lt;code&gt;foo/bar&lt;/code&gt; becomes &lt;code&gt;**/foo/bar&lt;/code&gt; and would match &lt;code&gt;/any/path/to/foo/bar&lt;/code&gt;.</source>
          <target state="translated">パターンが始まらない場合はどちらか &lt;code&gt;~/&lt;/code&gt; 、 &lt;code&gt;./&lt;/code&gt; または &lt;code&gt;/&lt;/code&gt; 、 &lt;code&gt;**/&lt;/code&gt; 自動的に先頭に追加されます。たとえば、パターン &lt;code&gt;foo/bar&lt;/code&gt; は &lt;code&gt;**/foo/bar&lt;/code&gt; になり、 &lt;code&gt;/any/path/to/foo/bar&lt;/code&gt; に一致します。</target>
        </trans-unit>
        <trans-unit id="cdf2b04ab13a298c669a989712845f14a413f23b" translate="yes" xml:space="preserve">
          <source>If the pattern ends with &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;**&lt;/code&gt; will be automatically added. For example, the pattern &lt;code&gt;foo/&lt;/code&gt; becomes &lt;code&gt;foo/**&lt;/code&gt;. In other words, it matches &quot;foo&quot; and everything inside, recursively.</source>
          <target state="translated">パターンが &lt;code&gt;/&lt;/code&gt; で終わる場合、 &lt;code&gt;**&lt;/code&gt; が自動的に追加されます。たとえば、パターン &lt;code&gt;foo/&lt;/code&gt; は &lt;code&gt;foo/**&lt;/code&gt; になります。つまり、「foo」とその中のすべてに再帰的に一致します。</target>
        </trans-unit>
        <trans-unit id="ead2b404e5878a53eb56a401706bd4f86f5cdd4b" translate="yes" xml:space="preserve">
          <source>If the pattern ends with &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;**&lt;/code&gt; will be automatically added. For example, the pattern &lt;code&gt;foo/&lt;/code&gt; becomes &lt;code&gt;foo/**&lt;/code&gt;. In other words, it matches all branches that begin with &lt;code&gt;foo/&lt;/code&gt;. This is useful if your branches are organized hierarchically and you would like to apply a configuration to all the branches in that hierarchy.</source>
          <target state="translated">パターンが &lt;code&gt;/&lt;/code&gt; で終わる場合、 &lt;code&gt;**&lt;/code&gt; が自動的に追加されます。たとえば、パターン &lt;code&gt;foo/&lt;/code&gt; は &lt;code&gt;foo/**&lt;/code&gt; になります。つまり、 &lt;code&gt;foo/&lt;/code&gt; で始まるすべてのブランチに一致します。これは、ブランチが階層的に編成されており、その階層内のすべてのブランチに構成を適用する場合に便利です。</target>
        </trans-unit>
        <trans-unit id="f1c8abd89592d50ca8ca62bbaec12c523f709263" translate="yes" xml:space="preserve">
          <source>If the pattern starts with &lt;code&gt;./&lt;/code&gt;, it is replaced with the directory containing the current config file.</source>
          <target state="translated">パターンが &lt;code&gt;./&lt;/code&gt; で始まる場合、現在の設定ファイルを含むディレクトリに置き換えられます。</target>
        </trans-unit>
        <trans-unit id="f924b2c312a1632ec51dd0f0353e6842160ab641" translate="yes" xml:space="preserve">
          <source>If the pattern starts with &lt;code&gt;~/&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt; will be substituted with the content of the environment variable &lt;code&gt;HOME&lt;/code&gt;.</source>
          <target state="translated">パターンが &lt;code&gt;~/&lt;/code&gt; で始まる場合、 &lt;code&gt;~&lt;/code&gt; は環境変数 &lt;code&gt;HOME&lt;/code&gt; の内容で置き換えられます。</target>
        </trans-unit>
        <trans-unit id="25b5ae377df44f33ba840cf2411c6edf767c0d5b" translate="yes" xml:space="preserve">
          <source>If the pre-receive hook exits with a non-zero exit status no updates will be performed, and the update, post-receive and post-update hooks will not be invoked either. This can be useful to quickly bail out if the update is not to be supported.</source>
          <target state="translated">pre-receive フックが 0 以外の終了ステータスで終了した場合、更新は実行されず、 update,post-receive,post-update フックも起動されません。これは、更新がサポートされていない場合に、迅速にベイルアウトするのに便利です。</target>
        </trans-unit>
        <trans-unit id="0131da637807c8654fda6294e521f8e5e74d9c2b" translate="yes" xml:space="preserve">
          <source>If the problematic commit is the most recent commit, and you have not yet made that commit public, then you may just &lt;a href=&quot;#undoing-a-merge&quot;&gt;destroy it using &lt;code&gt;git reset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">問題のあるコミットが最新のコミットであり、そのコミットをまだ公開していない場合は、&lt;a href=&quot;#undoing-a-merge&quot;&gt; &lt;code&gt;git reset&lt;/code&gt; &lt;/a&gt;を使用してそれを破棄するだけです。</target>
        </trans-unit>
        <trans-unit id="1f275a1769b3300733689c93e8034126052b9dd7" translate="yes" xml:space="preserve">
          <source>If the project list is taken from a file (&lt;code&gt;$projects_list&lt;/code&gt; points to a file), forks are only recognized if they are listed after the main project in that file.</source>
          <target state="translated">プロジェクトリストがファイルから取得された場合（ &lt;code&gt;$projects_list&lt;/code&gt; はファイルを指します）、フォークは、そのファイルのメインプロジェクトの後にリストされている場合にのみ認識されます。</target>
        </trans-unit>
        <trans-unit id="cabde5708a0c59fc40ce3c5aef7bb8948c87aab4" translate="yes" xml:space="preserve">
          <source>If the reference repository is on the local machine, automatically setup &lt;code&gt;.git/objects/info/alternates&lt;/code&gt; to obtain objects from the reference repository. Using an already existing repository as an alternate will require fewer objects to be copied from the repository being cloned, reducing network and local storage costs. When using the &lt;code&gt;--reference-if-able&lt;/code&gt;, a non existing directory is skipped with a warning instead of aborting the clone.</source>
          <target state="translated">参照リポジトリがローカルマシンにある場合は、 &lt;code&gt;.git/objects/info/alternates&lt;/code&gt; を自動的にセットアップして、参照リポジトリからオブジェクトを取得します。既存のリポジトリを代替として使用すると、複製するリポジトリからコピーするオブジェクトが少なくなり、ネットワークとローカルストレージのコストが削減されます。 &lt;code&gt;--reference-if-able&lt;/code&gt; を使用すると、存在しないディレクトリは、クローンを中止する代わりに警告とともにスキップされます。</target>
        </trans-unit>
        <trans-unit id="5ea9c0fb462e839210565ca58d9885017561c1be" translate="yes" xml:space="preserve">
          <source>If the refspec is a globbing one, nothing is merged.</source>
          <target state="translated">refspecがグロブの場合は何もマージされません。</target>
        </trans-unit>
        <trans-unit id="67d81d9e5d98e20a38ce258501ea936cdaf3477e" translate="yes" xml:space="preserve">
          <source>If the remote has enabled the options &lt;code&gt;uploadpack.allowTipSHA1InWant&lt;/code&gt;, &lt;code&gt;uploadpack.allowReachableSHA1InWant&lt;/code&gt;, or &lt;code&gt;uploadpack.allowAnySHA1InWant&lt;/code&gt;, they may alternatively be 40-hex sha1s present on the remote.</source>
          <target state="translated">リモートがオプション &lt;code&gt;uploadpack.allowTipSHA1InWant&lt;/code&gt; 、 &lt;code&gt;uploadpack.allowReachableSHA1InWant&lt;/code&gt; 、または &lt;code&gt;uploadpack.allowAnySHA1InWant&lt;/code&gt; を有効にしている場合、それらは代わりにリモートに存在する40進数のsha1である可能性があります。</target>
        </trans-unit>
        <trans-unit id="43fe46812af3fc1b263ad2f17ddd0dcd8b849c57" translate="yes" xml:space="preserve">
          <source>If the remote is fetched successfully, add upstream (tracking) reference, used by argument-less &lt;a href=&quot;git-pull&quot;&gt;git-pull[1]&lt;/a&gt; and other commands. For more information, see &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; and &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">リモートが正常にフェッチされた場合は、引数のない&lt;a href=&quot;git-pull&quot;&gt;git-pull [1]&lt;/a&gt;やその他のコマンドで使用されるアップストリーム（追跡）参照を追加します。詳細については、&lt;a href=&quot;git-config&quot;&gt;git-config [1]の&lt;/a&gt; &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; および &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; してください。</target>
        </trans-unit>
        <trans-unit id="6b40a2dab8bd4f0c4875755d97441dd96a4edce1" translate="yes" xml:space="preserve">
          <source>If the remote is fetched successfully, pull and add upstream (tracking) reference, used by argument-less &lt;a href=&quot;git-pull&quot;&gt;git-pull[1]&lt;/a&gt; and other commands. For more information, see &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; and &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">リモートが正常にフェッチされた場合は、引数なしの&lt;a href=&quot;git-pull&quot;&gt;git-pull [1]&lt;/a&gt;およびその他のコマンドで使用されるアップストリーム（追跡）参照をプルして追加します。詳細については、&lt;a href=&quot;git-config&quot;&gt;git-config [1]の&lt;/a&gt; &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; および &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; してください。</target>
        </trans-unit>
        <trans-unit id="dc0cb0804e07bed75e0e991fffdc9aae616f339a" translate="yes" xml:space="preserve">
          <source>If the remote side supports it, annotated tags objects will be downloaded on the same connection as the other objects if the object the tag references is downloaded. The caller must otherwise determine the tags this option made available.</source>
          <target state="translated">リモート側がそれをサポートしている場合、タグが参照するオブジェクトがダウンロードされた場合、注釈付きタグオブジェクトは他のオブジェクトと同じ接続でダウンロードされます。呼び出し元は、それ以外の場合、このオプションが利用可能にしたタグを決定しなければなりません。</target>
        </trans-unit>
        <trans-unit id="b72444ac7244fe67691159600db782df37b1532c" translate="yes" xml:space="preserve">
          <source>If the repository is bare, &lt;code&gt;--no-checkout&lt;/code&gt; is assumed.</source>
          <target state="translated">リポジトリが裸の場合、 &lt;code&gt;--no-checkout&lt;/code&gt; が想定されます。</target>
        </trans-unit>
        <trans-unit id="36e50561f165c018ae6f119c2c6f3e5164508f60" translate="yes" xml:space="preserve">
          <source>If the repository is specified as a local path (e.g., &lt;code&gt;/path/to/repo&lt;/code&gt;), this is the default, and --local is essentially a no-op. If the repository is specified as a URL, then this flag is ignored (and we never use the local optimizations). Specifying &lt;code&gt;--no-local&lt;/code&gt; will override the default when &lt;code&gt;/path/to/repo&lt;/code&gt; is given, using the regular Git transport instead.</source>
          <target state="translated">リポジトリがローカルパスとして指定されている場合（例： &lt;code&gt;/path/to/repo&lt;/code&gt; ）、これがデフォルトであり、--localは基本的に何もしません。リポジトリがURLとして指定されている場合、このフラグは無視されます（ローカルの最適化は使用されません）。 &lt;code&gt;/path/to/repo&lt;/code&gt; &lt;code&gt;--no-local&lt;/code&gt; を指定すると、/ path / to / repoが指定されたときにデフォルトが上書きされ、代わりに通常のGitトランスポートが使用されます。</target>
        </trans-unit>
        <trans-unit id="9c19da211c253af2b7a5a65c4c24c5e8a4f73309" translate="yes" xml:space="preserve">
          <source>If the result content is empty then the filter is expected to respond with a &quot;success&quot; status and a flush packet to signal the empty content.</source>
          <target state="translated">結果の内容が空の場合は、フィルタは &quot;成功&quot; ステータスと空の内容を知らせるフラッシュパケットで応答することが期待されます。</target>
        </trans-unit>
        <trans-unit id="87bdb08d6c6927271153931ec7c3dbb32bf0435b" translate="yes" xml:space="preserve">
          <source>If the server has found a suitable cut point and has decided to send a &quot;ready&quot; line, then the server can decide to (as an optimization) omit any &quot;ACK&quot; lines it would have sent during its response. This is because the server will have already determined the objects it plans to send to the client and no further negotiation is needed.</source>
          <target state="translated">サーバが適切なカットポイントを見つけ、「ready」行を送ることにした場合、サーバは(最適化のために)応答中に送ったであろう「ACK」行を省略することを決定することができる。これは、サーバがクライアントに送る予定のオブジェクトを既に決定しているため、それ以上のネゴシエーションは必要ないからです。</target>
        </trans-unit>
        <trans-unit id="b994a26dfc45bfc84fb73ef67436c3f647661961" translate="yes" xml:space="preserve">
          <source>If the size of the incoming pack stream is larger than this limit, then git-receive-pack will error out, instead of accepting the pack file. If not set or set to 0, then the size is unlimited.</source>
          <target state="translated">入力されるパックストリームのサイズがこの制限よりも大きい場合は、git-receive-pack はパックファイルを受け入れるのではなくエラーアウトします。設定されていないか 0 に設定されている場合は、サイズに制限はありません。</target>
        </trans-unit>
        <trans-unit id="ff78750ae83975fe12661694a886f60b06a8fa31" translate="yes" xml:space="preserve">
          <source>If the source material uses RFC 2822 style dates, the frontend should let fast-import handle the parsing and conversion (rather than attempting to do it itself) as the Git parser has been well tested in the wild.</source>
          <target state="translated">もしソースが RFC 2822 スタイルの日付を使用しているのであれば、フロントエンドは fast-import に解析と変換を任せるべきでしょう (自分で処理するのではなく)。</target>
        </trans-unit>
        <trans-unit id="3c8cd70e721e8a0b9cd7092e81bbbfc31a3bd8bd" translate="yes" xml:space="preserve">
          <source>If the source repository is complete, convert a shallow repository to a complete one, removing all the limitations imposed by shallow repositories.</source>
          <target state="translated">ソースリポジトリが完全なものであれば、浅いリポジトリを完全なものに変換し、浅いリポジトリに課せられた制限をすべて取り除きます。</target>
        </trans-unit>
        <trans-unit id="9e6d3a4e3136a4838fe6f50fd9653c6cb56b6d6c" translate="yes" xml:space="preserve">
          <source>If the source repository is shallow, fetch as much as possible so that the current repository has the same history as the source repository.</source>
          <target state="translated">ソースリポジトリが浅い場合は、現在のリポジトリがソースリポジトリと同じ履歴を持つように、できるだけ多くの量をフェッチします。</target>
        </trans-unit>
        <trans-unit id="de8398976a760845a7849338955a9624333ab515" translate="yes" xml:space="preserve">
          <source>If the starting point is specified as &lt;code&gt;ref@{Nth}&lt;/code&gt;, show the index format.</source>
          <target state="translated">開始点が &lt;code&gt;ref@{Nth}&lt;/code&gt; として指定されている場合は、インデックス形式を表示します。</target>
        </trans-unit>
        <trans-unit id="6a2386c7d64f544644194a06f1f15e00500df35a" translate="yes" xml:space="preserve">
          <source>If the starting point was specified as &lt;code&gt;ref@{now}&lt;/code&gt;, show the timestamp format.</source>
          <target state="translated">開始点が &lt;code&gt;ref@{now}&lt;/code&gt; として指定されている場合は、タイムスタンプ形式を表示します。</target>
        </trans-unit>
        <trans-unit id="a401b7c4a3b36e61e5b713fb185191570664ec06" translate="yes" xml:space="preserve">
          <source>If the submodule has never been initialized, this is the only place where submodule configuration is found. It serves as the last fallback to specify where to obtain the submodule from.</source>
          <target state="translated">サブモジュールが一度も初期化されていない場合は、 サブモジュールの設定が見つかるのはここだけです。これは、サブモジュールをどこから取得するかを指定する最後のフォールバックとなります。</target>
        </trans-unit>
        <trans-unit id="c93d30e9eb4c6197dacc1ad5f6b79e20616e783c" translate="yes" xml:space="preserve">
          <source>If the submodule is not yet initialized, and you just want to use the setting as stored in &lt;code&gt;.gitmodules&lt;/code&gt;, you can automatically initialize the submodule with the &lt;code&gt;--init&lt;/code&gt; option.</source>
          <target state="translated">サブモジュールがまだ初期化されて &lt;code&gt;.gitmodules&lt;/code&gt; 、.gitmodulesに保存されている設定を使用したいだけの場合は、-- &lt;code&gt;--init&lt;/code&gt; オプションを使用してサブモジュールを自動的に初期化できます。</target>
        </trans-unit>
        <trans-unit id="02845d91bbeb482c77721be199fb493e9af0747b" translate="yes" xml:space="preserve">
          <source>If the submodule is not yet initialized, then the configuration inside the submodule does not exist yet, so where to obtain the submodule from is configured here for example.</source>
          <target state="translated">サブモジュールがまだ初期化されていない場合は、サブモジュール内部の設定がまだ存在していないことになりますので、例えばここではサブモジュールをどこから取得するかを設定します。</target>
        </trans-unit>
        <trans-unit id="ae19e2f586d76eb404950c906a0e28fc48bd4144" translate="yes" xml:space="preserve">
          <source>If the target branch in refs/remotes/p4-unshelved already exists, the old one will be renamed.</source>
          <target state="translated">refs/remotes/p4-unshelved のターゲットブランチが既に存在する場合、古いブランチはリネームされます。</target>
        </trans-unit>
        <trans-unit id="2f7883dbe6de00b83ac31c035cb47ace7f18b215" translate="yes" xml:space="preserve">
          <source>If the timestamp order of different files cross the revision order within the commit matching time window the order of commits may be wrong.</source>
          <target state="translated">異なるファイルのタイムスタンプの順番がコミットマッチングのタイムウィンドウ内でリビジョンの順番と交差している場合、コミットの順番が間違っている可能性があります。</target>
        </trans-unit>
        <trans-unit id="9e02bc5f839968fa2bd55c9715c548322d410f70" translate="yes" xml:space="preserve">
          <source>If the update is done via merge, the submodule conflicts are resolved and checked out.</source>
          <target state="translated">マージ経由で更新が行われた場合、サブモジュールのコンフリクトが解決されてチェックアウトされます。</target>
        </trans-unit>
        <trans-unit id="e429444552f2f76afd93b7eab781098fd53d76ab" translate="yes" xml:space="preserve">
          <source>If the upstream branch already contains a change you have made (e.g., because you mailed a patch which was applied upstream), then that commit will be skipped. For example, running &lt;code&gt;git rebase master&lt;/code&gt; on the following history (in which &lt;code&gt;A'&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; introduce the same set of changes, but have different committer information):</source>
          <target state="translated">アップストリームブランチに既に加えた変更が含まれている場合（たとえば、アップストリームに適用されたパッチをメールで送信したため）、そのコミットはスキップされます。たとえば、次の履歴で &lt;code&gt;git rebase master&lt;/code&gt; を実行すると（ &lt;code&gt;A'&lt;/code&gt; と &lt;code&gt;A&lt;/code&gt; は同じ変更セットを導入しますが、コミッター情報は異なります）</target>
        </trans-unit>
        <trans-unit id="8dd2ebfbc7db6f2a970a9204f7e4fecacb05b440" translate="yes" xml:space="preserve">
          <source>If the user is driving it, then at each step of the search, the user will have to test the current commit and say if it is &quot;good&quot; or &quot;bad&quot; using the &quot;git bisect good&quot; or &quot;git bisect bad&quot; commands respectively that have been described above. For example:</source>
          <target state="translated">ユーザーがそれを実行している場合は、検索の各ステップで現在のコミットをテストし、それが「良い」か「悪い」かを上で説明した &quot;git bisect good&quot; あるいは &quot;git bisect bad&quot; コマンドを使って言わなければなりません。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="6929af54c2109d01f0c27eda6b64b41906b00393" translate="yes" xml:space="preserve">
          <source>If the user provides a --tag-name-filter that maps multiple tags to the same name, no warning or error is provided; git-filter-branch simply overwrites each tag in some undocumented pre-defined order resulting in only one tag at the end. (A git-filter-branch regression test requires this surprising behavior.)</source>
          <target state="translated">ユーザーが --tag-name-filter を指定して複数のタグを同じ名前にマップした場合は、警告もエラーも出ません。(git-filter-branch のリグレッションテストでは、この驚くべき挙動が求められます)。</target>
        </trans-unit>
        <trans-unit id="115afcefe8deea6713a6376b9b3612622ce5ff41" translate="yes" xml:space="preserve">
          <source>If the user running &lt;code&gt;git p4 submit&lt;/code&gt; does not exist in the p4 user map, &lt;code&gt;git p4&lt;/code&gt; exits. This option can be used to force submission regardless.</source>
          <target state="translated">&lt;code&gt;git p4 submit&lt;/code&gt; を実行しているユーザーがp4ユーザーマップに存在しない場合、 &lt;code&gt;git p4&lt;/code&gt; は終了します。このオプションを使用して、送信を強制することができます。</target>
        </trans-unit>
        <trans-unit id="4ce7fbc3c51757d8b6052ea0a42e4807120e305f" translate="yes" xml:space="preserve">
          <source>If the value is boolean, turns on or off pagination of the output of a particular Git subcommand when writing to a tty. Otherwise, turns on pagination for the subcommand using the pager specified by the value of &lt;code&gt;pager.&amp;lt;cmd&amp;gt;&lt;/code&gt;. If &lt;code&gt;--paginate&lt;/code&gt; or &lt;code&gt;--no-pager&lt;/code&gt; is specified on the command line, it takes precedence over this option. To disable pagination for all commands, set &lt;code&gt;core.pager&lt;/code&gt; or &lt;code&gt;GIT_PAGER&lt;/code&gt; to &lt;code&gt;cat&lt;/code&gt;.</source>
          <target state="translated">値がブール値の場合、ttyへの書き込み時に特定のGitサブコマンドの出力のページ分割をオンまたはオフにします。それ以外の場合は、 &lt;code&gt;pager.&amp;lt;cmd&amp;gt;&lt;/code&gt; 値で指定されたページャーを使用して、サブコマンドのページネーションをオンにします。場合 &lt;code&gt;--paginate&lt;/code&gt; または &lt;code&gt;--no-pager&lt;/code&gt; コマンドラインで指定され、それは、このオプションよりも優先されます。すべてのコマンドのページ &lt;code&gt;core.pager&lt;/code&gt; を無効にするには、core.pagerまたは &lt;code&gt;GIT_PAGER&lt;/code&gt; を &lt;code&gt;cat&lt;/code&gt; に設定します。</target>
        </trans-unit>
        <trans-unit id="d03e93ea222dab8f641cb8201b06b8ce56eb4397" translate="yes" xml:space="preserve">
          <source>If the variable is set to an integer value greater than 2 and lower than 10 (strictly) then Git will interpret this value as an open file descriptor and will try to write the trace messages into this file descriptor.</source>
          <target state="translated">変数に 2 以上 10 以下の整数値が設定されている場合 (厳密には)、Git はこの値をオープンファイル記述子と解釈し、トレースメッセージをこのファイル記述子に書き込もうとします。</target>
        </trans-unit>
        <trans-unit id="68e78b3aa184c7970e4ea72bcfa1c35c1841182d" translate="yes" xml:space="preserve">
          <source>If there are a large number of similarly-named remote repositories and you want to use a different format for them (such that the URLs you use will be rewritten into URLs that work), you can create a configuration section of the form:</source>
          <target state="translated">似たような名前のリモートリポジトリが大量にあり、それらに別のフォーマットを使用したい場合(使用するURLが動作するURLに書き換えられるような)、フォームの設定セクションを作成することができます。</target>
        </trans-unit>
        <trans-unit id="1add756b76a7c17e78b77f722a60e35881bd1c18" translate="yes" xml:space="preserve">
          <source>If there are conflicts, the user should edit the result and delete one of the alternatives. When &lt;code&gt;--ours&lt;/code&gt;, &lt;code&gt;--theirs&lt;/code&gt;, or &lt;code&gt;--union&lt;/code&gt; option is in effect, however, these conflicts are resolved favouring lines from &lt;code&gt;&amp;lt;current-file&amp;gt;&lt;/code&gt;, lines from &lt;code&gt;&amp;lt;other-file&amp;gt;&lt;/code&gt;, or lines from both respectively. The length of the conflict markers can be given with the &lt;code&gt;--marker-size&lt;/code&gt; option.</source>
          <target state="translated">競合がある場合、ユーザーは結果を編集し、代替の1つを削除する必要があります。場合 &lt;code&gt;--ours&lt;/code&gt; 、 &lt;code&gt;--theirs&lt;/code&gt; 、または &lt;code&gt;--union&lt;/code&gt; オプションが有効になっている、しかし、これらの競合は、より線有利に解決される &lt;code&gt;&amp;lt;current-file&amp;gt;&lt;/code&gt; から、行 &lt;code&gt;&amp;lt;other-file&amp;gt;&lt;/code&gt; それぞれの両方から、またはライン。競合マーカーの長さは &lt;code&gt;--marker-size&lt;/code&gt; オプションで指定できます。</target>
        </trans-unit>
        <trans-unit id="86762a48683c371a4cc7c3de1cb012419562ae87" translate="yes" xml:space="preserve">
          <source>If there are multiple branches, doing &lt;code&gt;git p4 sync&lt;/code&gt; will automatically use the &quot;BRANCH DETECTION&quot; algorithm to try to partition new changes into the right branch. This can be overridden with the &lt;code&gt;--branch&lt;/code&gt; option to specify just a single branch to update.</source>
          <target state="translated">複数のブランチがある場合、 &lt;code&gt;git p4 sync&lt;/code&gt; を実行すると、「BRANCH DETECTION」アルゴリズムを自動的に使用して、新しい変更を正しいブランチに分割しようとします。これを &lt;code&gt;--branch&lt;/code&gt; オプションでオーバーライドして、更新するブランチを1つだけ指定できます。</target>
        </trans-unit>
        <trans-unit id="618accc0d1d550b6b8ec069f55b5b09af649e985" translate="yes" xml:space="preserve">
          <source>If there are multiple instances of the &lt;code&gt;credential.helper&lt;/code&gt; configuration variable, each helper will be tried in turn, and may provide a username, password, or nothing. Once Git has acquired both a username and a password, no more helpers will be tried.</source>
          <target state="translated">&lt;code&gt;credential.helper&lt;/code&gt; 構成変数のインスタンスが複数ある場合、各ヘルパーが順番に試行され、ユーザー名、パスワードを提供するか、何も提供しない可能性があります。Gitがユーザー名とパスワードの両方を取得すると、それ以上のヘルパーは試行されません。</target>
        </trans-unit>
        <trans-unit id="af9d46d5bd3ac828de63ddb9d4effe59327aaa5a" translate="yes" xml:space="preserve">
          <source>If there are other repositories that you also use frequently, you can create similar configuration options to save typing; for example,</source>
          <target state="translated">他にも頻繁に使用するリポジトリがある場合は、同様の設定オプションを作成してタイピングの手間を省くことができます。</target>
        </trans-unit>
        <trans-unit id="591918eb06b2723ac86bd0a089445e6e294cf8c5" translate="yes" xml:space="preserve">
          <source>If there exist packfiles in the pack directory not registered in the MIDX, then those packfiles are loaded into the &lt;code&gt;packed_git&lt;/code&gt; list and &lt;code&gt;packed_git_mru&lt;/code&gt; cache.</source>
          <target state="translated">MIDXに登録されていないパックディレクトリにパックファイルが存在する場合、それらのパックファイルは &lt;code&gt;packed_git&lt;/code&gt; リストと &lt;code&gt;packed_git_mru&lt;/code&gt; キャッシュにロードされます。</target>
        </trans-unit>
        <trans-unit id="03e18f44da1b610f354ea9baeb478307ccf925f8" translate="yes" xml:space="preserve">
          <source>If there is a separator at the beginning or middle (or both) of the pattern, then the pattern is relative to the directory level of the particular &lt;code&gt;.gitignore&lt;/code&gt; file itself. Otherwise the pattern may also match at any level below the &lt;code&gt;.gitignore&lt;/code&gt; level.</source>
          <target state="translated">パターンの先頭または中央（あるいは両方）にセパレータがある場合、パターンは特定の &lt;code&gt;.gitignore&lt;/code&gt; ファイル自体のディレクトリレベルに関連しています。そうでない場合、パターンは &lt;code&gt;.gitignore&lt;/code&gt; レベルより下のどのレベルでも一致する可能性があります。</target>
        </trans-unit>
        <trans-unit id="73c5dbd4863767291eb0584c1211aa56213f1838" translate="yes" xml:space="preserve">
          <source>If there is a separator at the end of the pattern then the pattern will only match directories, otherwise the pattern can match both files and directories.</source>
          <target state="translated">パターンの最後に区切り文字がある場合、パターンはディレクトリにのみマッチし、そうでない場合はファイルとディレクトリの両方にマッチします。</target>
        </trans-unit>
        <trans-unit id="7e5e3b6d9186f0b0d9ca9ea83f70b7fee637fea2" translate="yes" xml:space="preserve">
          <source>If there is a separator, then the key will be used instead of both the &amp;lt;token&amp;gt; and the default separator when adding the trailer.</source>
          <target state="translated">セパレータがある場合、トレーラーを追加するときに、&amp;lt;token&amp;gt;とデフォルトのセパレータの両方の代わりにキーが使用されます。</target>
        </trans-unit>
        <trans-unit id="110096af5aaaf08aca8aad30cdfe6c3abec7eaf2" translate="yes" xml:space="preserve">
          <source>If there is no file or subtree at that path, &lt;code&gt;git fast-import&lt;/code&gt; will instead report</source>
          <target state="translated">そのパスにファイルまたはサブツリーがない場合、代わりに &lt;code&gt;git fast-import&lt;/code&gt; がレポートします</target>
        </trans-unit>
        <trans-unit id="1db0218c6ea3cc08d2d45a6158a3df08d714812b" translate="yes" xml:space="preserve">
          <source>If there is no parameter given by the user, use &lt;code&gt;&amp;lt;arg&amp;gt;&lt;/code&gt; instead.</source>
          <target state="translated">ユーザーが指定したパラメータがない場合は、代わりに &lt;code&gt;&amp;lt;arg&amp;gt;&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="08079a827cded7daddc3f36e473048d3482101ec" translate="yes" xml:space="preserve">
          <source>If there is only one &amp;lt;tree-ish&amp;gt; given, the commit is compared with its parents (see --stdin below).</source>
          <target state="translated">&amp;lt;tree-ish&amp;gt;が1つしか指定されていない場合、コミットはその親と比較されます（下記の--stdinを参照）。</target>
        </trans-unit>
        <trans-unit id="f3b2c7580e6489ea5e91cbe02a9f524e00ba7a5a" translate="yes" xml:space="preserve">
          <source>If there were more commits on the &lt;em&gt;master&lt;/em&gt; branch after the merge, the merge commit itself would not be shown by &lt;em&gt;git show-branch&lt;/em&gt; by default. You would need to provide &lt;code&gt;--sparse&lt;/code&gt; option to make the merge commit visible in this case.</source>
          <target state="translated">マージ後に&lt;em&gt;マスター&lt;/em&gt;ブランチにさらにコミットがあった場合、マージコミット自体はデフォルトで&lt;em&gt;git show-branch&lt;/em&gt;によって&lt;em&gt;表示&lt;/em&gt;されません。この場合、マージコミットを表示するには &lt;code&gt;--sparse&lt;/code&gt; オプションを提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="0ab64f384f8b476963c3f64ac176ef68ee6de9f2" translate="yes" xml:space="preserve">
          <source>If there were uncommitted worktree changes present when the merge started, &lt;code&gt;git merge --abort&lt;/code&gt; will in some cases be unable to reconstruct these changes. It is therefore recommended to always commit or stash your changes before running &lt;code&gt;git merge&lt;/code&gt;.</source>
          <target state="translated">マージの開始時にコミットされていないワークツリーの変更があった場合、 &lt;code&gt;git merge --abort&lt;/code&gt; はこれらの変更を再構築できない場合があります。したがって、 &lt;code&gt;git merge&lt;/code&gt; を実行する前に、常に変更をコミットまたは隠しておくことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="967d5740c3c32e83504fdb7318f7465d81e3c6cb" translate="yes" xml:space="preserve">
          <source>If this atom is used in the output string, input lines are split at the first whitespace boundary. All characters before that whitespace are considered to be the object name; characters after that first run of whitespace (i.e., the &quot;rest&quot; of the line) are output in place of the &lt;code&gt;%(rest)&lt;/code&gt; atom.</source>
          <target state="translated">このアトムが出力文字列で使用される場合、入力行は最初の空白の境界で分割されます。その空白の前のすべての文字は、オブジェクト名と見なされます。空白の最初の実行後の文字（つまり、行の「残り」）は、 &lt;code&gt;%(rest)&lt;/code&gt; アトムの代わりに出力されます。</target>
        </trans-unit>
        <trans-unit id="4b6208e01f164e5f8b5cfeffb592a9b059f78c4e" translate="yes" xml:space="preserve">
          <source>If this attribute is not set or has an invalid value, the value of the &lt;code&gt;gui.encoding&lt;/code&gt; configuration variable is used instead (See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">この属性が設定されていないか、無効な値がある場合は、代わりに &lt;code&gt;gui.encoding&lt;/code&gt; 構成変数の値が使用されます（&lt;a href=&quot;git-config&quot;&gt;git-config [1]を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="d21856ae35021bd75d04c1b344656e77c3e714d8" translate="yes" xml:space="preserve">
          <source>If this config variable is set, diff generation is not performed using the internal diff machinery, but using the given command. Can be overridden with the &amp;lsquo;GIT_EXTERNAL_DIFF&amp;rsquo; environment variable. The command is called with parameters as described under &quot;git Diffs&quot; in &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt;. Note: if you want to use an external diff program only on a subset of your files, you might want to use &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; instead.</source>
          <target state="translated">この構成変数が設定されている場合、内部の差分機構を使用してではなく、指定されたコマンドを使用して差分生成が実行されます。 'GIT_EXTERNAL_DIFF'環境変数でオーバーライドできます。&lt;a href=&quot;git&quot;&gt;git [1]の&lt;/a&gt;「git Diffs」で説明されているように、コマンドはパラメーターを指定して呼び出されます。注：ファイルのサブセットでのみ外部diffプログラムを使用する場合は、代わりに&lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt;を使用できます。</target>
        </trans-unit>
        <trans-unit id="c67dbd9b5b9d0c250d594cf0e82ea55d38dac133" translate="yes" xml:space="preserve">
          <source>If this environment variable is set to &quot;1&quot;, then commands such as &lt;code&gt;git blame&lt;/code&gt; (in incremental mode), &lt;code&gt;git rev-list&lt;/code&gt;, &lt;code&gt;git log&lt;/code&gt;, &lt;code&gt;git check-attr&lt;/code&gt; and &lt;code&gt;git check-ignore&lt;/code&gt; will force a flush of the output stream after each record have been flushed. If this variable is set to &quot;0&quot;, the output of these commands will be done using completely buffered I/O. If this environment variable is not set, Git will choose buffered or record-oriented flushing based on whether stdout appears to be redirected to a file or not.</source>
          <target state="translated">この環境変数が「1」に設定されている場合、 &lt;code&gt;git blame&lt;/code&gt; （インクリメンタルモード）、 &lt;code&gt;git rev-list&lt;/code&gt; 、 &lt;code&gt;git log&lt;/code&gt; 、 &lt;code&gt;git check-attr&lt;/code&gt; 、 &lt;code&gt;git check-ignore&lt;/code&gt; などのコマンドは、それぞれの後に出力ストリームを強制的にフラッシュします。レコードがフラッシュされました。この変数が「0」に設定されている場合、これらのコマンドの出力は、完全にバッファーされたI / Oを使用して行われます。この環境変数が設定されていない場合、Gitはstdoutがファイルにリダイレクトされているように見えるかどうかに基づいて、バッファリングまたはレコード指向のフラッシュを選択します。</target>
        </trans-unit>
        <trans-unit id="3c510f35b5c52541d7f8ff48371ed312cadc959c" translate="yes" xml:space="preserve">
          <source>If this environment variable is set to &lt;code&gt;0&lt;/code&gt;, git will not prompt on the terminal (e.g., when asking for HTTP authentication).</source>
          <target state="translated">この環境変数が &lt;code&gt;0&lt;/code&gt; に設定されている場合、gitはターミナルでプロンプトを出しません（たとえば、HTTP認証を要求するとき）。</target>
        </trans-unit>
        <trans-unit id="f0e0816f1f387058c1f2d75f7ff32a01f9295472" translate="yes" xml:space="preserve">
          <source>If this environment variable is set, it overrides Git&amp;rsquo;s autodetection whether &lt;code&gt;GIT_SSH&lt;/code&gt;/&lt;code&gt;GIT_SSH_COMMAND&lt;/code&gt;/&lt;code&gt;core.sshCommand&lt;/code&gt; refer to OpenSSH, plink or tortoiseplink. This variable overrides the config setting &lt;code&gt;ssh.variant&lt;/code&gt; that serves the same purpose.</source>
          <target state="translated">この環境変数が設定されている場合、 &lt;code&gt;GIT_SSH&lt;/code&gt; / &lt;code&gt;GIT_SSH_COMMAND&lt;/code&gt; / &lt;code&gt;core.sshCommand&lt;/code&gt; がOpenSSH、plink、またはtortoiseplinkを参照しているかどうかに関係なく、 Gitの自動検出がオーバーライドされます。この変数は、同じ目的を果たす構成設定 &lt;code&gt;ssh.variant&lt;/code&gt; をオーバーライドします。</target>
        </trans-unit>
        <trans-unit id="81f782a4dbe0e346a4da365c1a6b3a9cbeb4a6e2" translate="yes" xml:space="preserve">
          <source>If this environment variable is set, then Git commands which need to acquire passwords or passphrases (e.g. for HTTP or IMAP authentication) will call this program with a suitable prompt as command-line argument and read the password from its STDOUT. See also the &lt;code&gt;core.askPass&lt;/code&gt; option in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">この環境変数が設定されている場合、パスワードまたはパスフレーズ（HTTPまたはIMAP認証など）を取得する必要のあるGitコマンドは、適切なプロンプトをコマンドライン引数として使用してこのプログラムを呼び出し、そのSTDOUTからパスワードを読み取ります。&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;の &lt;code&gt;core.askPass&lt;/code&gt; オプションも参照してください。</target>
        </trans-unit>
        <trans-unit id="372352ecb2d8c55afffa99890c0eb497f2b1382d" translate="yes" xml:space="preserve">
          <source>If this feature is enabled, gitweb considers projects in subdirectories of project root (basename) to be forks of existing projects. For each project &lt;code&gt;$projname.git&lt;/code&gt;, projects in the &lt;code&gt;$projname/&lt;/code&gt; directory and its subdirectories will not be shown in the main projects list. Instead, a '+' mark is shown next to &lt;code&gt;$projname&lt;/code&gt;, which links to a &quot;forks&quot; view that lists all the forks (all projects in &lt;code&gt;$projname/&lt;/code&gt; subdirectory). Additionally a &quot;forks&quot; view for a project is linked from project summary page.</source>
          <target state="translated">この機能を有効にすると、gitwebはプロジェクトルート（ベース名）のサブディレクトリにあるプロジェクトを既存のプロジェクトのフォークと見なします。プロジェクト &lt;code&gt;$projname.git&lt;/code&gt; ごとに、 &lt;code&gt;$projname/&lt;/code&gt; ディレクトリとそのサブディレクトリにあるプロジェクトは、メインプロジェクトリストに表示されません。代わりに、「+」マークが &lt;code&gt;$projname&lt;/code&gt; 横に表示されます。これは、すべてのフォーク（ &lt;code&gt;$projname/&lt;/code&gt; サブディレクトリ内のすべてのプロジェクト）を一覧表示する「フォーク」ビューにリンクしています。さらに、プロジェクトの「フォーク」ビューは、プロジェクトの概要ページからリンクされています。</target>
        </trans-unit>
        <trans-unit id="728d51c620f0870eff1b0d62261ab6934369adf2" translate="yes" xml:space="preserve">
          <source>If this field has a true value then the given feature is overridable, which means that it can be configured (or enabled/disabled) on a per-repository basis.</source>
          <target state="translated">このフィールドが真の値を持つ場合、指定された機能はオーバーライド可能であり、リポジトリごとに設定(または有効/無効)できることを意味します。</target>
        </trans-unit>
        <trans-unit id="582826e66f53339e6d7b4dc6a0d6a2edeb312487" translate="yes" xml:space="preserve">
          <source>If this file exists, $GIT_COMMON_DIR (see &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt;) will be set to the path specified in this file if it is not explicitly set. If the specified path is relative, it is relative to $GIT_DIR. The repository with commondir is incomplete without the repository pointed by &quot;commondir&quot;.</source>
          <target state="translated">このファイルが存在する場合、$ GIT_COMMON_DIR（&lt;a href=&quot;git&quot;&gt;git [1]を&lt;/a&gt;参照）は、明示的に設定されていない場合、このファイルで指定されたパスに設定されます。指定されたパスが相対パスの場合、$ GIT_DIRからの相対パスです。commondirのあるリポジトリは、 &quot;commondir&quot;が指すリポジトリがないと不完全です。</target>
        </trans-unit>
        <trans-unit id="1e44552a87aaa0e818702548719ba07ebc0f8696" translate="yes" xml:space="preserve">
          <source>If this file exists, the linked working tree may be on a portable device and not available. The presence of this file prevents &lt;code&gt;worktrees/&amp;lt;id&amp;gt;&lt;/code&gt; from being pruned either automatically or manually by &lt;code&gt;git worktree prune&lt;/code&gt;. The file may contain a string explaining why the repository is locked.</source>
          <target state="translated">このファイルが存在する場合、リンクされた作業ツリーはポータブルデバイス上にあり、使用できない可能性があります。このファイルが存在すると、 &lt;code&gt;worktrees/&amp;lt;id&amp;gt;&lt;/code&gt; が &lt;code&gt;git worktree prune&lt;/code&gt; によって自動または手動でプルーニングされなくなります。ファイルには、リポジトリがロックされている理由を説明する文字列が含まれている場合があります。</target>
        </trans-unit>
        <trans-unit id="6849302064fdf0db00fe326dd1a92636c39a6d43" translate="yes" xml:space="preserve">
          <source>If this hook exits with a non-zero status, &lt;code&gt;git push&lt;/code&gt; will abort without pushing anything. Information about why the push is rejected may be sent to the user by writing to standard error.</source>
          <target state="translated">このフックがゼロ以外のステータスで終了すると、 &lt;code&gt;git push&lt;/code&gt; は何もプッシュせずに中止されます。プッシュが拒否された理由に関する情報は、標準エラーに書き込むことでユーザーに送信できます。</target>
        </trans-unit>
        <trans-unit id="9e422a5c19027398b3db2e62a2dfa8c2a2031ac5" translate="yes" xml:space="preserve">
          <source>If this is reinitialization, the repository will be moved to the specified path.</source>
          <target state="translated">これが再初期化の場合は、指定したパスにリポジトリが移動します。</target>
        </trans-unit>
        <trans-unit id="ae49e42c53a829e13a69befb7e448cbf7a3ab5aa" translate="yes" xml:space="preserve">
          <source>If this is set to code reference, it will be run once for each request. You can set parts of configuration that change per session this way. For example, one might use the following code in a gitweb configuration file</source>
          <target state="translated">これをコード参照に設定すると、リクエストごとに1回実行されます。このようにして、セッションごとに変更される設定の一部を設定することができます。たとえば、gitweb の設定ファイルで次のようなコードを使うことができます。</target>
        </trans-unit>
        <trans-unit id="2ecaf4f8ea5745cd5a451b94ab44dd28ff120dab" translate="yes" xml:space="preserve">
          <source>If this is set to true, the &lt;code&gt;git stash show&lt;/code&gt; command without an option will show diffstat of the stash entry. Defaults to true. See description of &lt;code&gt;show&lt;/code&gt; command in &lt;a href=&quot;git-stash&quot;&gt;git-stash[1]&lt;/a&gt;.</source>
          <target state="translated">これがtrueに設定されている場合、オプションを指定しない &lt;code&gt;git stash show&lt;/code&gt; コマンドは、stashエントリーのdiffstatを表示します。デフォルトはtrueです。&lt;a href=&quot;git-stash&quot;&gt;git-stash [1]&lt;/a&gt;の &lt;code&gt;show&lt;/code&gt; コマンドの説明を参照してください。</target>
        </trans-unit>
        <trans-unit id="ee4998fa7e703962f55f3297f84fc3b952ae4a7f" translate="yes" xml:space="preserve">
          <source>If this is set to true, the &lt;code&gt;git stash show&lt;/code&gt; command without an option will show the stash entry in patch form. Defaults to false. See description of &lt;code&gt;show&lt;/code&gt; command in &lt;a href=&quot;git-stash&quot;&gt;git-stash[1]&lt;/a&gt;.</source>
          <target state="translated">これがtrueに設定されている場合、オプションなしの &lt;code&gt;git stash show&lt;/code&gt; コマンドは、stashエントリーをパッチ形式で表示します。デフォルトはfalseです。&lt;a href=&quot;git-stash&quot;&gt;git-stash [1]&lt;/a&gt;の &lt;code&gt;show&lt;/code&gt; コマンドの説明を参照してください。</target>
        </trans-unit>
        <trans-unit id="7e98f4c395c1b49b1de4c0111925dea856a6d079" translate="yes" xml:space="preserve">
          <source>If this is set, add emails found in Signed-off-by: or Cc: lines to the cc list. Default is the value of &lt;code&gt;sendemail.signedoffbycc&lt;/code&gt; configuration value; if that is unspecified, default to --signed-off-by-cc.</source>
          <target state="translated">これが設定されている場合は、Signed-off-by：またはCc：行にあるメールをccリストに追加します。デフォルトは &lt;code&gt;sendemail.signedoffbycc&lt;/code&gt; 構成値の値です。これが指定されていない場合、デフォルトは--signed-off-by-ccです。</target>
        </trans-unit>
        <trans-unit id="6cf7f20765eaeb225b14832d24072d63179e161f" translate="yes" xml:space="preserve">
          <source>If this is set, do not add the From: address to the cc: list. Default is the value of &lt;code&gt;sendemail.suppressFrom&lt;/code&gt; configuration value; if that is unspecified, default to --no-suppress-from.</source>
          <target state="translated">これが設定されている場合、From：アドレスをcc：リストに追加しないでください。デフォルトは &lt;code&gt;sendemail.suppressFrom&lt;/code&gt; 構成値です。これが指定されていない場合、デフォルトで--no-suppress-fromになります。</target>
        </trans-unit>
        <trans-unit id="048d4528d0951754849879e2b4b5802f6461c9fb" translate="yes" xml:space="preserve">
          <source>If this is set, each email will be sent as a reply to the previous email sent. If disabled with &quot;--no-chain-reply-to&quot;, all emails after the first will be sent as replies to the first email sent. When using this, it is recommended that the first file given be an overview of the entire patch series. Disabled by default, but the &lt;code&gt;sendemail.chainReplyTo&lt;/code&gt; configuration variable can be used to enable it.</source>
          <target state="translated">これが設定されている場合、各メールは、送信された前のメールへの返信として送信されます。「--no-chain-reply-to」で無効にした場合、最初のメール以降のすべてのメールが、最初に送信されたメールへの返信として送信されます。これを使用する場合、最初のファイルは一連のパッチ全体の概要であることが推奨されます。デフォルトでは無効になっていますが、 &lt;code&gt;sendemail.chainReplyTo&lt;/code&gt; 構成変数を使用して有効にすることができます。</target>
        </trans-unit>
        <trans-unit id="b4073ff276c4f44294d676470e6aaaeb5a46458f" translate="yes" xml:space="preserve">
          <source>If this is set, emails found in Cc: headers in the first patch of the series (typically the cover letter) are added to the cc list for each email set. Default is the value of &lt;code&gt;sendemail.cccover&lt;/code&gt; configuration value; if that is unspecified, default to --no-cc-cover.</source>
          <target state="translated">これが設定されている場合、シリーズの最初のパッチのCc：ヘッダーで見つかった電子メール（通常はカバーレター）が各電子メールセットのccリストに追加されます。デフォルトは &lt;code&gt;sendemail.cccover&lt;/code&gt; 構成値の値です。これが指定されていない場合、デフォルトは--no-cc-coverです。</target>
        </trans-unit>
        <trans-unit id="c3505cfc9a16fb3a406321b32681f1c27b3f4828" translate="yes" xml:space="preserve">
          <source>If this is set, emails found in To: headers in the first patch of the series (typically the cover letter) are added to the to list for each email set. Default is the value of &lt;code&gt;sendemail.tocover&lt;/code&gt; configuration value; if that is unspecified, default to --no-to-cover.</source>
          <target state="translated">これが設定されている場合、シリーズの最初のパッチのTo：ヘッダーで見つかったメール（通常はカバーレター）が各メールセットのtoリストに追加されます。デフォルトは &lt;code&gt;sendemail.tocover&lt;/code&gt; 構成値です。これが指定されていない場合、デフォルトは--no-to-coverです。</target>
        </trans-unit>
        <trans-unit id="bd074611e2ce23fe3651c7c21615bc5d5c90b653" translate="yes" xml:space="preserve">
          <source>If this is set, the In-Reply-To and References headers will be added to each email sent. Whether each mail refers to the previous email (&lt;code&gt;deep&lt;/code&gt; threading per &lt;code&gt;git format-patch&lt;/code&gt; wording) or to the first email (&lt;code&gt;shallow&lt;/code&gt; threading) is governed by &quot;--[no-]chain-reply-to&quot;.</source>
          <target state="translated">これが設定されている場合、送信される各電子メールにIn-Reply-ToおよびReferencesヘッダーが追加されます。各メールが前のメール（ &lt;code&gt;git format-patch&lt;/code&gt; 表現による &lt;code&gt;deep&lt;/code&gt; スレッド）を参照するか、最初のメール（ &lt;code&gt;shallow&lt;/code&gt; スレッド）を参照するかは、「-[no-] chain-reply-to」によって管理されます。</target>
        </trans-unit>
        <trans-unit id="83fefd231faf2237df4d2ca57ddb91f5733dd174" translate="yes" xml:space="preserve">
          <source>If this option is also present in the submodules entry in .git/config of the superproject, the setting there will override the one found in .gitmodules.</source>
          <target state="translated">このオプションがスーパープロジェクトの .git/config の submodules エントリにもある場合は、.gitmodules の設定が上書きされます。</target>
        </trans-unit>
        <trans-unit id="b576cec09f399abde10801d9e3b482a3974a7942" translate="yes" xml:space="preserve">
          <source>If this option is set, &lt;code&gt;upload-pack&lt;/code&gt; will support partial clone and partial fetch object filtering.</source>
          <target state="translated">このオプションが設定されている場合、 &lt;code&gt;upload-pack&lt;/code&gt; は部分的なクローンと部分的なフェッチオブジェクトのフィルタリングをサポートします。</target>
        </trans-unit>
        <trans-unit id="46df2747ed059ec465747bf23f6d93b6698f2ce3" translate="yes" xml:space="preserve">
          <source>If this option is set, &lt;code&gt;upload-pack&lt;/code&gt; will support the &lt;code&gt;ref-in-want&lt;/code&gt; feature of the protocol version 2 &lt;code&gt;fetch&lt;/code&gt; command. This feature is intended for the benefit of load-balanced servers which may not have the same view of what OIDs their refs point to due to replication delay.</source>
          <target state="translated">このオプションが設定されている場合、 &lt;code&gt;upload-pack&lt;/code&gt; はプロトコルバージョン2の &lt;code&gt;fetch&lt;/code&gt; コマンドの &lt;code&gt;ref-in-want&lt;/code&gt; 機能をサポートします。この機能は、レプリケーションの遅延のために、参照が参照するOIDについて同じビューを持たない可能性がある負荷分散サーバーの利益を目的としています。</target>
        </trans-unit>
        <trans-unit id="3691063a71adef86ec77db2886b5e8b672228551" translate="yes" xml:space="preserve">
          <source>If this option is set, when &lt;code&gt;upload-pack&lt;/code&gt; would run &lt;code&gt;git pack-objects&lt;/code&gt; to create a packfile for a client, it will run this shell command instead. The &lt;code&gt;pack-objects&lt;/code&gt; command and arguments it &lt;code&gt;would&lt;/code&gt; have run (including the &lt;code&gt;git pack-objects&lt;/code&gt; at the beginning) are appended to the shell command. The stdin and stdout of the hook are treated as if &lt;code&gt;pack-objects&lt;/code&gt; itself was run. I.e., &lt;code&gt;upload-pack&lt;/code&gt; will feed input intended for &lt;code&gt;pack-objects&lt;/code&gt; to the hook, and expects a completed packfile on stdout.</source>
          <target state="translated">このオプションが設定されている場合、 &lt;code&gt;upload-pack&lt;/code&gt; が &lt;code&gt;git pack-objects&lt;/code&gt; を実行してクライアント用のパックファイルを作成すると、代わりにこのシェルコマンドが実行されます。 &lt;code&gt;pack-objects&lt;/code&gt; のコマンドと、それは引数 &lt;code&gt;would&lt;/code&gt; （を含む実行した &lt;code&gt;git pack-objects&lt;/code&gt; 先頭の）シェルコマンドに追加されます。フックのstdinとstdoutは、 &lt;code&gt;pack-objects&lt;/code&gt; 自体が実行されたかのように扱われます。つまり、 &lt;code&gt;upload-pack&lt;/code&gt; は &lt;code&gt;pack-objects&lt;/code&gt; を対象とする入力をフックにフィードし、stdoutに完了したpackfileを期待します。</target>
        </trans-unit>
        <trans-unit id="043d313af4e6bae8eb0dfe37d6ed595c4f6e4603" translate="yes" xml:space="preserve">
          <source>If this option is specified and &lt;code&gt;git svn&lt;/code&gt; encounters an SVN committer name that does not exist in the authors-file, &lt;code&gt;git svn&lt;/code&gt; will abort operation. The user will then have to add the appropriate entry. Re-running the previous &lt;code&gt;git svn&lt;/code&gt; command after the authors-file is modified should continue operation.</source>
          <target state="translated">このオプションが指定されていて、 &lt;code&gt;git svn&lt;/code&gt; がauthors-fileに存在しないSVNコミッター名を検出した場合、 &lt;code&gt;git svn&lt;/code&gt; は操作を中止します。その後、ユーザーは適切なエントリを追加する必要があります。authors-fileが変更された後に以前の &lt;code&gt;git svn&lt;/code&gt; コマンドを再実行すると、操作が続行されます。</target>
        </trans-unit>
        <trans-unit id="68c99ad12996bd9192637a1c1520fb2b24def75b" translate="yes" xml:space="preserve">
          <source>If this option is specified, for each SVN committer name that does not exist in the authors file, the given file is executed with the committer name as the first argument. The program is expected to return a single line of the form &quot;Name &amp;lt;email&amp;gt;&quot; or &quot;Name &amp;lt;&amp;gt;&quot;, which will be treated as if included in the authors file.</source>
          <target state="translated">このオプションを指定すると、authorsファイルに存在しないSVNコミッター名ごとに、コミッター名を最初の引数として指定されたファイルが実行されます。プログラムは、 &quot;Name &amp;lt;email&amp;gt;&quot;または &quot;Name &amp;lt;&amp;gt;&quot;という形式の1行を返すことが期待されており、authorsファイルに含まれているものとして扱われます。</target>
        </trans-unit>
        <trans-unit id="9706c1068d7b5bd67656b65aa296c50f3e651323" translate="yes" xml:space="preserve">
          <source>If this variable is not specified, it defaults to &lt;code&gt;normal&lt;/code&gt;. This variable can be overridden with the -u|--untracked-files option of &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; and &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt;.</source>
          <target state="translated">この変数が指定されていない場合、デフォルトは &lt;code&gt;normal&lt;/code&gt; です。この変数は、&lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt;および&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt;の-u | --untracked-filesオプションでオーバーライドできます。</target>
        </trans-unit>
        <trans-unit id="9b0cae3fed40383cf5d614f1da46a2c524e4930e" translate="yes" xml:space="preserve">
          <source>If this variable is set to &quot;1&quot;, &quot;2&quot; or &quot;true&quot; (comparison is case insensitive), trace messages will be printed to stderr.</source>
          <target state="translated">この変数に &quot;1&quot;、&quot;2&quot;、または &quot;true &quot;が設定されている場合(比較は大文字小文字を区別しません)、トレースメッセージが標準エラーに出力されます。</target>
        </trans-unit>
        <trans-unit id="c1357386502b4e540a41766c550326b57fc0ea56" translate="yes" xml:space="preserve">
          <source>If this variable is set to a path, non-worktree files that are normally in $GIT_DIR will be taken from this path instead. Worktree-specific files such as HEAD or index are taken from $GIT_DIR. See &lt;a href=&quot;gitrepository-layout&quot;&gt;gitrepository-layout[5]&lt;/a&gt; and &lt;a href=&quot;git-worktree&quot;&gt;git-worktree[1]&lt;/a&gt; for details. This variable has lower precedence than other path variables such as GIT_INDEX_FILE, GIT_OBJECT_DIRECTORY&amp;hellip;​</source>
          <target state="translated">この変数がパスに設定されている場合、通常$ GIT_DIRにある非ワークツリーファイルは、代わりにこのパスから取得されます。HEADやインデックスなどのワークツリー固有のファイルは、$ GIT_DIRから取得されます。詳細については、&lt;a href=&quot;gitrepository-layout&quot;&gt;gitrepository-layout [5]&lt;/a&gt;および&lt;a href=&quot;git-worktree&quot;&gt;git-worktree [1]&lt;/a&gt;を参照してください。この変数は、GIT_INDEX_FILE、GIT_OBJECT_DIRECTORY&amp;hellip;などの他のパス変数よりも優先順位が低くなります。</target>
        </trans-unit>
        <trans-unit id="8249d2ab5516fac15cd6ed908f0ba3c1a12338b5" translate="yes" xml:space="preserve">
          <source>If this variable is set, &lt;code&gt;git fetch&lt;/code&gt; and &lt;code&gt;git push&lt;/code&gt; will use the specified command instead of &lt;code&gt;ssh&lt;/code&gt; when they need to connect to a remote system. The command is in the same form as the &lt;code&gt;GIT_SSH_COMMAND&lt;/code&gt; environment variable and is overridden when the environment variable is set.</source>
          <target state="translated">この変数が設定されている場合、 &lt;code&gt;git fetch&lt;/code&gt; および &lt;code&gt;git push&lt;/code&gt; は、リモートシステムに接続する必要があるときに、 &lt;code&gt;ssh&lt;/code&gt; ではなく指定されたコマンドを使用します。コマンドは &lt;code&gt;GIT_SSH_COMMAND&lt;/code&gt; 環境変数と同じ形式であり、環境変数が設定されるとオーバーライドされます。</target>
        </trans-unit>
        <trans-unit id="e4e675f6ba8abd4a71f30087b18137ff3c23311f" translate="yes" xml:space="preserve">
          <source>If this variable is set, the default hash algorithm for new repositories will be set to this value. This value is currently ignored when cloning; the setting of the remote repository is used instead. The default is &quot;sha1&quot;. THIS VARIABLE IS EXPERIMENTAL! See &lt;code&gt;--object-format&lt;/code&gt; in &lt;a href=&quot;git-init&quot;&gt;git-init[1]&lt;/a&gt;.</source>
          <target state="translated">この変数が設定されている場合、新しいリポジトリのデフォルトのハッシュアルゴリズムはこの値に設定されます。現在、この値はクローン作成時に無視されます。代わりに、リモートリポジトリの設定が使用されます。デフォルトは「sha1」です。この変数は実験的なものです！&lt;a href=&quot;git-init&quot;&gt;git-init [1]の&lt;/a&gt; &lt;code&gt;--object-format&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="3af55b279f11e2f816fa42fab0cbda45b206e1ef" translate="yes" xml:space="preserve">
          <source>If timestamps of commits in the CVS repository are not stable enough to be used for ordering commits changes may show up in the wrong order.</source>
          <target state="translated">CVS リポジトリ内のコミットのタイムスタンプが安定していない場合、コミットの順序を決めるのに使用することができない場合、変更が間違った順序で表示される可能性があります。</target>
        </trans-unit>
        <trans-unit id="51615abc07df5f5fedb19397be1e475bae29e04c" translate="yes" xml:space="preserve">
          <source>If true (default), a single editor instance will be spawned to edit files you have to edit (patches when &lt;code&gt;--annotate&lt;/code&gt; is used, and the summary when &lt;code&gt;--compose&lt;/code&gt; is used). If false, files will be edited one after the other, spawning a new editor each time.</source>
          <target state="translated">（デフォルト）trueの場合、シングルエディタインスタンスを使用すると、編集（パッチに持って編集ファイルに生み出される &lt;code&gt;--annotate&lt;/code&gt; が使用されている、と要約 &lt;code&gt;--compose&lt;/code&gt; が使用されています）。falseの場合、ファイルは次々に編集され、毎回新しいエディターが起動されます。</target>
        </trans-unit>
        <trans-unit id="6c99dc0ffc12cab74a91d9cd9821ddfe241990c4" translate="yes" xml:space="preserve">
          <source>If true prevents displaying information about repository owner.</source>
          <target state="translated">true の場合、リポジトリの所有者に関する情報を表示しないようにします。</target>
        </trans-unit>
        <trans-unit id="fad7b766b28596874c184072e4308f81cec3bb8e" translate="yes" xml:space="preserve">
          <source>If true the web server started by &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb[1]&lt;/a&gt; will be bound to the local IP (127.0.0.1).</source>
          <target state="translated">trueの場合、&lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb [1]&lt;/a&gt;によって起動されたWebサーバーはローカルIP（127.0.0.1）にバインドされます。</target>
        </trans-unit>
        <trans-unit id="24fc21f99a5940a5b287a59503e7df044758b9be" translate="yes" xml:space="preserve">
          <source>If true this repository is assumed to be &lt;code&gt;bare&lt;/code&gt; and has no working directory associated with it. If this is the case a number of commands that require a working directory will be disabled, such as &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; or &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt;.</source>
          <target state="translated">trueの場合、このリポジトリは &lt;code&gt;bare&lt;/code&gt; と見なされ、関連付けられた作業ディレクトリはありません。この場合、&lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt;や&lt;a href=&quot;git-merge&quot;&gt;git-merge [1]&lt;/a&gt;など、作業ディレクトリを必要とする多くのコマンドが無効になります。</target>
        </trans-unit>
        <trans-unit id="18d14681f32fdc08f62b0e7a189d6a89008757fd" translate="yes" xml:space="preserve">
          <source>If true, &lt;code&gt;git gui blame&lt;/code&gt; uses &lt;code&gt;-C&lt;/code&gt; instead of &lt;code&gt;-C -C&lt;/code&gt; for original location detection. It makes blame significantly faster on huge repositories at the expense of less thorough copy detection.</source>
          <target state="translated">trueの場合、 &lt;code&gt;git gui blame&lt;/code&gt; は元の場所の検出に &lt;code&gt;-C -C&lt;/code&gt; &lt;code&gt;-C&lt;/code&gt; ではなく-C を使用します。完全なコピー検出が行われない代わりに、巨大なリポジトリでの責任が大幅に速くなります。</target>
        </trans-unit>
        <trans-unit id="a4dc06197e1e60c2601c1eee394ecb56132cf3c4" translate="yes" xml:space="preserve">
          <source>If true, Git will avoid using lstat() calls to detect if files have changed by setting the &quot;assume-unchanged&quot; bit for those tracked files which it has updated identically in both the index and working tree.</source>
          <target state="translated">true の場合、Git は lstat()コールを使用してファイルが変更されたかどうかを検出しないようにします。</target>
        </trans-unit>
        <trans-unit id="f52d8aadd1ed60dd80b38e7a96aadc385cabb931" translate="yes" xml:space="preserve">
          <source>If true, Git will warn you if the ref name you passed it is ambiguous and might match multiple refs in the repository. True by default.</source>
          <target state="translated">true にすると、渡した ref の名前が曖昧で、リポジトリ内の複数の ref と一致する可能性がある場合に警告を表示します。デフォルトでは True です。</target>
        </trans-unit>
        <trans-unit id="b4f1cbcb9d6580097e1319f75786e1aefcc4a19a" translate="yes" xml:space="preserve">
          <source>If true, allow clients to use &lt;code&gt;git archive --remote&lt;/code&gt; to request any tree, whether reachable from the ref tips or not. See the discussion in the &quot;SECURITY&quot; section of &lt;a href=&quot;git-upload-archive&quot;&gt;git-upload-archive[1]&lt;/a&gt; for more details. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">trueの場合、リファレンスヒントから到達可能かどうかに関係なく、クライアントが &lt;code&gt;git archive --remote&lt;/code&gt; を使用してツリーをリクエストできるようにします。詳細については、&lt;a href=&quot;git-upload-archive&quot;&gt;git-upload-archive [1]&lt;/a&gt;の「セキュリティ」セクションの説明をご覧ください。デフォルトは &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="9577d8134a35c2d555845d35ede1972ec309a7fc" translate="yes" xml:space="preserve">
          <source>If true, enable &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; for use by remote clients via &lt;a href=&quot;git-upload-archive&quot;&gt;git-upload-archive[1]&lt;/a&gt;. Defaults to false for user-defined formats, but true for the &quot;tar.gz&quot; and &quot;tgz&quot; formats.</source>
          <target state="translated">trueの場合、&lt;a href=&quot;git-upload-archive&quot;&gt;git-upload-archive [1]を&lt;/a&gt;介してリモートクライアントで使用できるように &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; を有効にします。ユーザー定義の形式の場合、デフォルトはfalseですが、「tar.gz」および「tgz」形式の場合はtrueです。</target>
        </trans-unit>
        <trans-unit id="5f15956c2db32b4b1b45dac474661942b8aa7008" translate="yes" xml:space="preserve">
          <source>If true, fetch will automatically behave as if the &lt;code&gt;--prune&lt;/code&gt; option was given on the command line. See also &lt;code&gt;remote.&amp;lt;name&amp;gt;.prune&lt;/code&gt; and the PRUNING section of &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;.</source>
          <target state="translated">trueの場合、fetchはコマンドラインで &lt;code&gt;--prune&lt;/code&gt; オプションが指定されているかのように自動的に動作します。 &lt;code&gt;remote.&amp;lt;name&amp;gt;.prune&lt;/code&gt; および&lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]の&lt;/a&gt; PRUNINGセクションも参照してください。</target>
        </trans-unit>
        <trans-unit id="7d985f4709f0d26edc0babef707e65f833d349aa" translate="yes" xml:space="preserve">
          <source>If true, fetch will automatically behave as if the &lt;code&gt;refs/tags/*:refs/tags/*&lt;/code&gt; refspec was provided when pruning, if not set already. This allows for setting both this option and &lt;code&gt;fetch.prune&lt;/code&gt; to maintain a 1=1 mapping to upstream refs. See also &lt;code&gt;remote.&amp;lt;name&amp;gt;.pruneTags&lt;/code&gt; and the PRUNING section of &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;.</source>
          <target state="translated">trueの場合、フェッチは、プルーニング時に &lt;code&gt;refs/tags/*:refs/tags/*&lt;/code&gt; refspecが提供されているかのように自動的に動作します（まだ設定されていない場合）。これにより、このオプションと &lt;code&gt;fetch.prune&lt;/code&gt; の両方を設定して、上流の参照への1 = 1マッピングを維持できます。 &lt;code&gt;remote.&amp;lt;name&amp;gt;.pruneTags&lt;/code&gt; および&lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]の&lt;/a&gt; PRUNINGセクションも参照してください。</target>
        </trans-unit>
        <trans-unit id="2de6ae2b37da0c5dc299e33fe86fea1c6d9d4a0f" translate="yes" xml:space="preserve">
          <source>If true, git-am will call git-mailsplit for patches in mbox format with parameter &lt;code&gt;--keep-cr&lt;/code&gt;. In this case git-mailsplit will not remove &lt;code&gt;\r&lt;/code&gt; from lines ending with &lt;code&gt;\r\n&lt;/code&gt;. Can be overridden by giving &lt;code&gt;--no-keep-cr&lt;/code&gt; from the command line. See &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt;, &lt;a href=&quot;git-mailsplit&quot;&gt;git-mailsplit[1]&lt;/a&gt;.</source>
          <target state="translated">trueの場合、git-amはmbox形式のパッチに対してgit-mailsplitをパラメーター &lt;code&gt;--keep-cr&lt;/code&gt; で呼び出します。この場合、git-mailsplitは &lt;code&gt;\r\n&lt;/code&gt; 終わる行から &lt;code&gt;\r&lt;/code&gt; を削除しません。コマンドラインから &lt;code&gt;--no-keep-cr&lt;/code&gt; を指定することで上書きできます。&lt;a href=&quot;git-am&quot;&gt;git-am [1]&lt;/a&gt;、&lt;a href=&quot;git-mailsplit&quot;&gt;git-mailsplit [1]を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="e94bf962607289b1694c70432d3fab451c61737d" translate="yes" xml:space="preserve">
          <source>If true, makes &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt;, and &lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged[1]&lt;/a&gt; assume &lt;code&gt;--abbrev-commit&lt;/code&gt;. You may override this option with &lt;code&gt;--no-abbrev-commit&lt;/code&gt;.</source>
          <target state="translated">trueの場合、&lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt;、&lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt;、および&lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged [1]で&lt;/a&gt; &lt;code&gt;--abbrev-commit&lt;/code&gt; を想定します。このオプションは &lt;code&gt;--no-abbrev-commit&lt;/code&gt; で上書きできます。</target>
        </trans-unit>
        <trans-unit id="f7c96ef3a79b38b8c56dee4db799ed4d172ce90c" translate="yes" xml:space="preserve">
          <source>If true, makes &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt;, and &lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged[1]&lt;/a&gt; assume &lt;code&gt;--show-signature&lt;/code&gt;.</source>
          <target state="translated">trueの場合、&lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt;、&lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt;、および&lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged [1]で&lt;/a&gt; &lt;code&gt;--show-signature&lt;/code&gt; を想定します。</target>
        </trans-unit>
        <trans-unit id="6cb33eaf81fb27f3c3d3ba0e81d6670ba0d0bfaf" translate="yes" xml:space="preserve">
          <source>If true, makes &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt;, and &lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged[1]&lt;/a&gt; assume &lt;code&gt;--use-mailmap&lt;/code&gt;, otherwise assume &lt;code&gt;--no-use-mailmap&lt;/code&gt;. True by default.</source>
          <target state="translated">trueの場合、&lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt;、&lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt;、および&lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged [1]&lt;/a&gt;は &lt;code&gt;--use-mailmap&lt;/code&gt; を想定し、そうでない場合は &lt;code&gt;--no-use-mailmap&lt;/code&gt; を想定します。デフォルトではTrue。</target>
        </trans-unit>
        <trans-unit id="672cef13127670a717c7a3aa65681a15ad776d1b" translate="yes" xml:space="preserve">
          <source>If true, makes &lt;a href=&quot;git-mailinfo&quot;&gt;git-mailinfo[1]&lt;/a&gt; (and therefore &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt;) act by default as if the --scissors option was provided on the command-line. When active, this features removes everything from the message body before a scissors line (i.e. consisting mainly of &quot;&amp;gt;8&quot;, &quot;8&amp;lt;&quot; and &quot;-&quot;).</source>
          <target state="translated">trueの場合、&lt;a href=&quot;git-mailinfo&quot;&gt;デフォルトでgit-mailinfo [1]&lt;/a&gt;（したがって&lt;a href=&quot;git-am&quot;&gt;git-am [1]&lt;/a&gt;）がコマンドラインで--scissorsオプションが指定されているかのように動作します。この機能をアクティブにすると、はさみの行の前にあるメッセージ本文からすべてが削除されます（つまり、「&amp;gt; 8」、「8 &amp;lt;」、および「-」で主に構成されます）。</target>
        </trans-unit>
        <trans-unit id="d25b510a17b04a17cfbdc40d0999d1586f4d5f91" translate="yes" xml:space="preserve">
          <source>If true, makes Git check if converting &lt;code&gt;CRLF&lt;/code&gt; is reversible when end-of-line conversion is active. Git will verify if a command modifies a file in the work tree either directly or indirectly. For example, committing a file followed by checking out the same file should yield the original file in the work tree. If this is not the case for the current setting of &lt;code&gt;core.autocrlf&lt;/code&gt;, Git will reject the file. The variable can be set to &quot;warn&quot;, in which case Git will only warn about an irreversible conversion but continue the operation.</source>
          <target state="translated">trueの場合、 &lt;code&gt;CRLF&lt;/code&gt; 変換がアクティブなときにCRLFの変換が元に戻せるかどうかをGitにチェックさせます。Gitは、コマンドが直接または間接的に作業ツリーのファイルを変更するかどうかを確認します。たとえば、ファイルをコミットしてから同じファイルをチェックアウトすると、作業ツリーに元のファイルが生成されます。これが &lt;code&gt;core.autocrlf&lt;/code&gt; の現在の設定に当てはまらない場合、Gitはファイルを拒否します。変数を「警告」に設定できます。その場合、Gitは不可逆的な変換についてのみ警告し、操作を続行します。</target>
        </trans-unit>
        <trans-unit id="3a6f979740fe111373346b7083b54b9e059af003" translate="yes" xml:space="preserve">
          <source>If true, omit the column with date of the most current commit on the projects list page. It can save a bit of I/O and a fork per repository.</source>
          <target state="translated">true の場合は、プロジェクト一覧ページの最新のコミットの日付のカラムを省略します。これにより、少しのI/Oとリポジトリごとのフォークを節約することができます。</target>
        </trans-unit>
        <trans-unit id="9e101a02df349b50a39b60288665a643391bcf24" translate="yes" xml:space="preserve">
          <source>If true, pushing to this remote will automatically behave as if the &lt;code&gt;--mirror&lt;/code&gt; option was given on the command line.</source>
          <target state="translated">trueの場合、このリモートへのプッシュは、コマンドラインで &lt;code&gt;--mirror&lt;/code&gt; オプションが指定されているかのように自動的に動作します。</target>
        </trans-unit>
        <trans-unit id="561edb27b58ccdfdecb1aae75865de22935f3cd3" translate="yes" xml:space="preserve">
          <source>If true, some gitweb features are disabled to prevent content in repositories from launching cross-site scripting (XSS) attacks. Set this to true if you don&amp;rsquo;t trust the content of your repositories. False by default (set to 0).</source>
          <target state="translated">trueの場合、リポジトリのコンテンツがクロスサイトスクリプティング（XSS）攻撃を開始するのを防ぐために、一部のgitweb機能が無効になります。リポジトリのコンテンツを信頼しない場合は、これをtrueに設定します。デフォルトではfalse（0に設定）。</target>
        </trans-unit>
        <trans-unit id="698e5f4a0ab76eb97600c890fa9adac3c5e93fa4" translate="yes" xml:space="preserve">
          <source>If true, the initial commit will be shown as a big creation event. This is equivalent to a diff against an empty tree. Tools like &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; or &lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged[1]&lt;/a&gt;, which normally hide the root commit will now show it. True by default.</source>
          <target state="translated">trueの場合、最初のコミットは大きな作成イベントとして表示されます。これは、空のツリーに対する差分と同じです。通常はルートコミットを非表示にする&lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt;や&lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged [1]&lt;/a&gt;などのツールで表示されるようになりました。デフォルトではTrue。</target>
        </trans-unit>
        <trans-unit id="7f4771e5273a3a0e51423699c29e2caf790623f9" translate="yes" xml:space="preserve">
          <source>If true, the server will look up the end-of-line conversion attributes for files to determine the &lt;code&gt;-k&lt;/code&gt; modes to use. If the attributes force Git to treat a file as text, the &lt;code&gt;-k&lt;/code&gt; mode will be left blank so CVS clients will treat it as text. If they suppress text conversion, the file will be set with &lt;code&gt;-kb&lt;/code&gt; mode, which suppresses any newline munging the client might otherwise do. If the attributes do not allow the file type to be determined, then &lt;code&gt;gitcvs.allBinary&lt;/code&gt; is used. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt;.</source>
          <target state="translated">trueの場合、サーバーはファイルの行末変換属性を検索して、使用する &lt;code&gt;-k&lt;/code&gt; モードを決定します。属性がGitにファイルをテキストとして扱うように強制する場合、 &lt;code&gt;-k&lt;/code&gt; モードは空白のままになり、CVSクライアントはファイルをテキストとして扱います。それらがテキスト変換を抑止する場合、ファイルは &lt;code&gt;-kb&lt;/code&gt; モードで設定されます。これにより、クライアントが改行する改行を抑止します。属性でファイルタイプを判別できない場合は、 &lt;code&gt;gitcvs.allBinary&lt;/code&gt; が使用されます。&lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="36ac6e641c359be495ff334484c92173e0b7c3c8" translate="yes" xml:space="preserve">
          <source>If true, the split-index feature of the index will be used. See &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt;. False by default.</source>
          <target state="translated">trueの場合、インデックスの分割インデックス機能が使用されます。&lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]を&lt;/a&gt;参照してください。デフォルトではfalse。</target>
        </trans-unit>
        <trans-unit id="521397cd2bc3f328c7b75df2807813cd34103bfb" translate="yes" xml:space="preserve">
          <source>If true, then gc will rewrite the commit-graph file when &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt; is run. When using &lt;code&gt;git gc --auto&lt;/code&gt; the commit-graph will be updated if housekeeping is required. Default is true. See &lt;a href=&quot;git-commit-graph&quot;&gt;git-commit-graph[1]&lt;/a&gt; for details.</source>
          <target state="translated">trueの場合、&lt;a href=&quot;git-gc&quot;&gt;git-gc [1]&lt;/a&gt;が実行されると、gcはcommit-graphファイルを書き換えます。 &lt;code&gt;git gc --auto&lt;/code&gt; を使用すると、ハウスキーピングが必要な場合にコミットグラフが更新されます。デフォルトはtrueです。詳細については、&lt;a href=&quot;git-commit-graph&quot;&gt;git-commit-graph [1]&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="902fdcf00401d2e7de222ff42ce846a756cbb163" translate="yes" xml:space="preserve">
          <source>If true, then git will read the commit-graph file (if it exists) to parse the graph structure of commits. Defaults to true. See &lt;a href=&quot;git-commit-graph&quot;&gt;git-commit-graph[1]&lt;/a&gt; for more information.</source>
          <target state="translated">trueの場合、gitはコミットグラフファイル（存在する場合）を読み取り、コミットのグラフ構造を解析します。デフォルトはtrueです。詳細については、&lt;a href=&quot;git-commit-graph&quot;&gt;git-commit-graph [1]&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="ca076926e8bbfce2f59c8069a39ed42dca4bb470" translate="yes" xml:space="preserve">
          <source>If true, then git will use the changed-path Bloom filters in the commit-graph file (if it exists, and they are present). Defaults to true. See &lt;a href=&quot;git-commit-graph&quot;&gt;git-commit-graph[1]&lt;/a&gt; for more information.</source>
          <target state="translated">trueの場合、gitはcommit-graphファイル内の変更されたパスのブルームフィルターを使用します（存在し、存在する場合）。デフォルトはtrueです。詳細については、&lt;a href=&quot;git-commit-graph&quot;&gt;git-commit-graph [1]&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="615bfb2827e0f7022b5822b60fa7f8c63365efe6" translate="yes" xml:space="preserve">
          <source>If true, this is equivalent to the --verify-signatures command line option. See &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt; for details.</source>
          <target state="translated">trueの場合、これは--verify-signaturesコマンドラインオプションと同等です。詳細については、&lt;a href=&quot;git-merge&quot;&gt;git-merge [1]&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="5ab6fd64e80cf040c0dbc59c3bda45e3cb1c29b3" translate="yes" xml:space="preserve">
          <source>If true, this remote will be skipped by default when updating using &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt; or the &lt;code&gt;update&lt;/code&gt; subcommand of &lt;a href=&quot;git-remote&quot;&gt;git-remote[1]&lt;/a&gt;.</source>
          <target state="translated">trueの場合、&lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt;または&lt;a href=&quot;git-remote&quot;&gt;git-remote [1]の&lt;/a&gt; &lt;code&gt;update&lt;/code&gt; サブコマンドを使用して更新するときに、このリモートはデフォルトでスキップされます。</target>
        </trans-unit>
        <trans-unit id="537153cdd9a230b7ef7748cee5c002a80aec5646" translate="yes" xml:space="preserve">
          <source>If we compute the following non optimal function on it:</source>
          <target state="translated">その上で以下の非最適関数を計算すると</target>
        </trans-unit>
        <trans-unit id="b2bbf437e467ca2cfec5d122277b398062cce56a" translate="yes" xml:space="preserve">
          <source>If we examined all this history together in one repository, it will look like:</source>
          <target state="translated">この歴史を一つのリポジトリでまとめて調べてみると、次のようになります。</target>
        </trans-unit>
        <trans-unit id="f77fa3523026c17c64002e6f77dd7e18ad8c7cf7" translate="yes" xml:space="preserve">
          <source>If we have moved away from commit &lt;code&gt;f&lt;/code&gt;, then we must first recover its object name (typically by using git reflog), and then we can create a reference to it. For example, to see the last two commits to which &lt;code&gt;HEAD&lt;/code&gt; referred, we can use either of these commands:</source>
          <target state="translated">コミット &lt;code&gt;f&lt;/code&gt; から離れた場合は、まずオブジェクト名を回復する必要があり（通常はgit reflogを使用して）、次にそれへの参照を作成できます。たとえば、 &lt;code&gt;HEAD&lt;/code&gt; が参照した最後の2つのコミットを確認するには、次のいずれかのコマンドを使用できます。</target>
        </trans-unit>
        <trans-unit id="1d5fb2a96e98dbf044763df4f4d84c289b1a7a1e" translate="yes" xml:space="preserve">
          <source>If we look at the way commits are created under the cover, we&amp;rsquo;ll see that there are more flexible ways creating commits.</source>
          <target state="translated">裏でコミットが作成される方法を見ると、コミットを作成するより柔軟な方法があることがわかります。</target>
        </trans-unit>
        <trans-unit id="2a7aed1833634138d2979858dc472c551054c3f5" translate="yes" xml:space="preserve">
          <source>If we need to talk about a particular commit, the character &quot;o&quot; may be replaced with another letter or number.</source>
          <target state="translated">特定のコミットについて話す必要がある場合は、&quot;o &quot;という文字を別の文字や数字に置き換えることができます。</target>
        </trans-unit>
        <trans-unit id="73117dc442919d58c7658111f0e65fc3ffc2d92d" translate="yes" xml:space="preserve">
          <source>If width is &lt;code&gt;0&lt;/code&gt; (zero) then indent the lines of the output without wrapping them.</source>
          <target state="translated">widthが &lt;code&gt;0&lt;/code&gt; （ゼロ）の場合、出力の行を折り返さずにインデントします。</target>
        </trans-unit>
        <trans-unit id="a0f8f4ea612137fd1324a3c99aa8cca8319d30d8" translate="yes" xml:space="preserve">
          <source>If you add a &lt;code&gt;+&lt;/code&gt; (plus sign) after &lt;code&gt;%&lt;/code&gt; of a placeholder, a line-feed is inserted immediately before the expansion if and only if the placeholder expands to a non-empty string.</source>
          <target state="translated">プレースホルダーの &lt;code&gt;%&lt;/code&gt; の後に &lt;code&gt;+&lt;/code&gt; （プラス記号）を追加すると、プレースホルダーが空でない文字列に展開される場合に限り、展開の直前に改行が挿入されます。</target>
        </trans-unit>
        <trans-unit id="f83e564943919127dff3b2d8ad2099402ce321cb" translate="yes" xml:space="preserve">
          <source>If you add a &lt;code&gt;-&lt;/code&gt; (minus sign) after &lt;code&gt;%&lt;/code&gt; of a placeholder, all consecutive line-feeds immediately preceding the expansion are deleted if and only if the placeholder expands to an empty string.</source>
          <target state="translated">プレースホルダーの &lt;code&gt;%&lt;/code&gt; の後に &lt;code&gt;-&lt;/code&gt; （マイナス記号）を追加すると、プレースホルダーが空の文字列に展開される場合にのみ、展開の直前の連続するすべての改行が削除されます。</target>
        </trans-unit>
        <trans-unit id="a78fb3b12f14b3649d1e2f03162a9771701e268a" translate="yes" xml:space="preserve">
          <source>If you add a ` ` (space) after &lt;code&gt;%&lt;/code&gt; of a placeholder, a space is inserted immediately before the expansion if and only if the placeholder expands to a non-empty string.</source>
          <target state="translated">プレースホルダーの &lt;code&gt;%&lt;/code&gt; の後に ``（スペース）を追加すると、プレースホルダーが空でない文字列に展開される場合にのみ、展開の直前にスペースが挿入されます。</target>
        </trans-unit>
        <trans-unit id="2c694abd299e141b455acf195b0e2c24045c8fb9" translate="yes" xml:space="preserve">
          <source>If you allow overriding for the snapshot feature, you can specify which snapshot formats are globally disabled. You can also add any command-line options you want (such as setting the compression level). For instance, you can disable Zip compressed snapshots and set &lt;strong&gt;gzip&lt;/strong&gt;(1) to run at level 6 by adding the following lines to your gitweb configuration file:</source>
          <target state="translated">スナップショット機能のオーバーライドを許可する場合は、グローバルに無効にするスナップショット形式を指定できます。必要なコマンドラインオプションを追加することもできます（圧縮レベルの設定など）。たとえば、次の行をgitweb構成ファイルに追加することで、Zip圧縮スナップショットを無効にし、&lt;strong&gt;gzip&lt;/strong&gt;（1）をレベル6で実行するように設定できます。</target>
        </trans-unit>
        <trans-unit id="1eda80bb2b9aeb620d19886733f7a0a33613b07f" translate="yes" xml:space="preserve">
          <source>If you already use &lt;code&gt;mod_userdir&lt;/code&gt; in your virtual host or you don&amp;rsquo;t want to use the '~' as first character, just comment or remove the second rewrite rule, and uncomment one of the following according to what you want.</source>
          <target state="translated">仮想ホストで既に &lt;code&gt;mod_userdir&lt;/code&gt; を使用している場合、または「〜」を最初の文字として使用したくない場合は、コメントするか、2番目の書き換えルールを削除し、必要に応じて次のいずれかをコメント解除します。</target>
        </trans-unit>
        <trans-unit id="28aab4433d981c882862a14d41ff2a1b6ecf68f5" translate="yes" xml:space="preserve">
          <source>If you also want to see complete diffs at each step, use</source>
          <target state="translated">各ステップで完全な差分を見たい場合は、次のようにします。</target>
        </trans-unit>
        <trans-unit id="cc8e02bd7d5fd8efba31a3f28960e44c003964ed" translate="yes" xml:space="preserve">
          <source>If you and the maintainer both have accounts on the same machine, then you can just pull changes from each other&amp;rsquo;s repositories directly; commands that accept repository URLs as arguments will also accept a local directory name:</source>
          <target state="translated">あなたとメンテナの両方が同じマシンにアカウントを持っている場合、お互いのリポジトリから直接変更をプルすることができます。引数としてリポジトリURLを受け入れるコマンドは、ローカルディレクトリ名も受け入れます。</target>
        </trans-unit>
        <trans-unit id="41ebdd5e935074b399d696e8dc1f4204152e3f63" translate="yes" xml:space="preserve">
          <source>If you are a contributor that sends changes upstream in the form of emails, you should use topic branches as usual (see above). Then use &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt; to generate the corresponding emails (highly recommended over manually formatting them because it makes the maintainer&amp;rsquo;s life easier).</source>
          <target state="translated">メールの形で上流に変更を送信する寄稿者である場合は、通常どおりトピックブランチを使用する必要があります（上記を参照）。次に、&lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]&lt;/a&gt;を使用して、対応するメールを生成します（手動でフォーマットするよりも、メンテナーの生活が楽になるため、強くお勧めします）。</target>
        </trans-unit>
        <trans-unit id="f7586aada4dc4dabc26450bca6e988967f6c8334" translate="yes" xml:space="preserve">
          <source>If you are a maintainer and would like to merge other people&amp;rsquo;s topic branches to the integration branches, they will typically send a request to do so by mail. Such a request looks like</source>
          <target state="translated">あなたがメンテナであり、他の人のトピックブランチを統合ブランチにマージしたい場合、彼らは通常、メールでそれを行うリクエストを送信します。このようなリクエストは次のようになります</target>
        </trans-unit>
        <trans-unit id="6a4170b1f048a116a2a20a0123a6634648180f67" translate="yes" xml:space="preserve">
          <source>If you are coming from a CVS background, the style of cooperation suggested in the previous section may be new to you. You do not have to worry. Git supports the &quot;shared public repository&quot; style of cooperation you are probably more familiar with as well.</source>
          <target state="translated">CVS出身の方は、前節で提案された協力のスタイルが新鮮に感じられるかもしれません。心配する必要はありません。Git は &quot;shared public repository&quot; スタイルの協力関係をサポートしています。</target>
        </trans-unit>
        <trans-unit id="d473d9569ed7194445a9c66a5a376371d037be9a" translate="yes" xml:space="preserve">
          <source>If you are creating a branch that you want to switch to immediately, it is easier to use the &quot;git switch&quot; command with its &lt;code&gt;-c&lt;/code&gt; option to do the same thing with a single command.</source>
          <target state="translated">すぐに切り替えたいブランチを作成している場合は、「git switch」コマンドに &lt;code&gt;-c&lt;/code&gt; オプションを付けて使用すると、1つのコマンドで同じことを行うのが簡単になります。</target>
        </trans-unit>
        <trans-unit id="882d5e43cce8c196ac8e463999e712ea9e114942" translate="yes" xml:space="preserve">
          <source>If you are following somebody else&amp;rsquo;s tree, you are most likely using remote-tracking branches (eg. &lt;code&gt;refs/remotes/origin/master&lt;/code&gt;). You usually want the tags from the other end.</source>
          <target state="translated">他人のツリーをフォローしている場合は、リモート追跡ブランチ（例： &lt;code&gt;refs/remotes/origin/master&lt;/code&gt; ）を使用している可能性があります。通常、反対側からタグを取得します。</target>
        </trans-unit>
        <trans-unit id="0f51d0b61f348c2beb156a534ba33bcb5f141385" translate="yes" xml:space="preserve">
          <source>If you are going to offer CVS access via pserver, add a line in /etc/inetd.conf like</source>
          <target state="translated">pserver経由でCVSにアクセスする場合は、/etc/inetd.confに以下のような行を追加します。</target>
        </trans-unit>
        <trans-unit id="e1c58ac4057b121c58f1f5681f07adc3f2f06c66" translate="yes" xml:space="preserve">
          <source>If you are instead primarily interested in using Git to fetch a project, for example, to test the latest version, you may prefer to start with the first two chapters of &lt;a href=&quot;user-manual&quot;&gt;The Git User&amp;rsquo;s Manual&lt;/a&gt;.</source>
          <target state="translated">代わりに、主にGitを使用してプロジェクトをフェッチする場合、たとえば、最新バージョンをテストする場合は、&lt;a href=&quot;user-manual&quot;&gt;「Gitユーザーマニュアル」の&lt;/a&gt;最初の2つの章から始めることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="9ce35cf81da423ef90a67288a1d702b7e25d4c6b" translate="yes" xml:space="preserve">
          <source>If you are interested in more details of the revision walking process, just have a look at the first implementation of &lt;code&gt;cmd_log()&lt;/code&gt;; call &lt;code&gt;git show v1.3.0&lt;sub&gt;155^2&lt;/sub&gt;4&lt;/code&gt; and scroll down to that function (note that you no longer need to call &lt;code&gt;setup_pager()&lt;/code&gt; directly).</source>
          <target state="translated">リビジョンウォーキングプロセスの詳細に興味がある場合は、 &lt;code&gt;cmd_log()&lt;/code&gt; の最初の実装をご覧ください。 &lt;code&gt;git show v1.3.0&lt;sub&gt;155^2&lt;/sub&gt;4&lt;/code&gt; を呼び出し、その関数まで下にスクロールします（ &lt;code&gt;setup_pager()&lt;/code&gt; を直接呼び出す必要はなくなりました）。</target>
        </trans-unit>
        <trans-unit id="9ac179f42cb3351e666e44e39b35f145be521392" translate="yes" xml:space="preserve">
          <source>If you are interested in more details of the revision walking process, just have a look at the first implementation of &lt;code&gt;cmd_log()&lt;/code&gt;; call &lt;code&gt;git show v1.3.0~155^2~4&lt;/code&gt; and scroll down to that function (note that you no longer need to call &lt;code&gt;setup_pager()&lt;/code&gt; directly).</source>
          <target state="translated">リビジョンウォーキングプロセスの詳細に興味がある場合は、 &lt;code&gt;cmd_log()&lt;/code&gt; の最初の実装をご覧ください。コール &lt;code&gt;git show v1.3.0~155^2~4&lt;/code&gt; 及びその機能にスクロールダウン（ノートコールへのご不要になったこと &lt;code&gt;setup_pager()&lt;/code&gt; を直接）。</target>
        </trans-unit>
        <trans-unit id="a5b0f41c084141a75721908d0d5d7971792ac89f" translate="yes" xml:space="preserve">
          <source>If you are not absolutely sure that the intermediate revisions are consistent (they compile, pass the testsuite, etc.) you should use &lt;code&gt;git stash&lt;/code&gt; to stash away the not-yet-committed changes after each commit, test, and amend the commit if fixes are necessary.</source>
          <target state="translated">中間リビジョンの一貫性が確実にわからない場合（コンパイル、テストスイートに合格するなど）、 &lt;code&gt;git stash&lt;/code&gt; を使用して、コミットごとにコミットされていない変更を隠し、テストし、修正された場合はコミットを修正します。必要です。</target>
        </trans-unit>
        <trans-unit id="f188b17d328d7a9e1b61bcc0d2e0defbbf399561" translate="yes" xml:space="preserve">
          <source>If you are only interested in changes of the currently initialized submodules with respect to the commit recorded in the index or the HEAD, &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; and &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; will provide that information too (and can also report changes to a submodule&amp;rsquo;s work tree).</source>
          <target state="translated">インデックスまたはHEADに記録されたコミットに関して現在初期化されているサブモジュールの変更のみに関心がある場合は、&lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt;と&lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt;がその情報も提供します（また、サブモジュールの作業ツリー）。</target>
        </trans-unit>
        <trans-unit id="9fb9a58a453e5ac1de19a98e53575241a40d1da0" translate="yes" xml:space="preserve">
          <source>If you are paranoid, running &lt;code&gt;git verify-pack&lt;/code&gt; command would detect if you have a corrupt pack, but do not worry too much. Our programs are always perfect ;-).</source>
          <target state="translated">偏執的である場合、 &lt;code&gt;git verify-pack&lt;/code&gt; コマンドを実行すると、破損したパックがあるかどうかが検出されますが、あまり心配する必要はありません。私たちのプログラムは常に完璧です;-)。</target>
        </trans-unit>
        <trans-unit id="277e03057ecd44d387d6f501d21982d9ff59224b" translate="yes" xml:space="preserve">
          <source>If you are repacking very old imported data (e.g. older than the last year), consider expending some extra CPU time and supplying --window=50 (or higher) when you run &lt;code&gt;git repack&lt;/code&gt;. This will take longer, but will also produce a smaller packfile. You only need to expend the effort once, and everyone using your project will benefit from the smaller repository.</source>
          <target state="translated">非常に古いインポートされたデータ（例：昨年よりも古い）を &lt;code&gt;git repack&lt;/code&gt; する場合は、git repackを実行するときに、余分なCPU時間を費やして--window = 50（またはそれ以上）を指定することを検討してください。これには時間がかかりますが、packfileも小さくなります。労力を費やす必要があるのは1回だけであり、プロジェクトを使用するすべての人が、より小さなリポジトリから恩恵を受けることができます。</target>
        </trans-unit>
        <trans-unit id="c500814f6020ec6c3d1c5a9b455910ea7fc36da1" translate="yes" xml:space="preserve">
          <source>If you are using &quot;git bisect run&quot;, you can use the same manual fix up as above, and then start another &quot;git bisect run&quot; in the special branch. Or as the &quot;git bisect&quot; man page says, the script passed to &quot;git bisect run&quot; can apply a patch before it compiles and test the software &lt;a href=&quot;#8&quot;&gt;[8]&lt;/a&gt;. The patch should turn a current untestable commits into a testable one. So the testing will result in &quot;good&quot; or &quot;bad&quot; and &quot;git bisect&quot; will be able to find the first bad commit. And the script should not forget to remove the patch once the testing is done before exiting from the script.</source>
          <target state="translated">「git bisect run」を使用している場合は、上記と同じ手動修正を使用して、特別なブランチで別の「git bisect run」を開始できます。または、「git bisect」のマニュアルページにあるように、「git bisect run」に渡されたスクリプトは、ソフトウェアをコンパイルしてテストする前にパッチを適用できます&lt;a href=&quot;#8&quot;&gt;[8]&lt;/a&gt;。パッチは現在のテスト不可能なコミットをテスト可能なものに変えるべきです。したがって、テストの結果は「良好」または「不良」となり、「git bisect」は最初の不良コミットを見つけることができます。また、スクリプトが終了する前にテストが終了したら、スクリプトはパッチを削除することを忘れないでください。</target>
        </trans-unit>
        <trans-unit id="c6c0585fbbb0e19d850e67091effac179b4cf010" translate="yes" xml:space="preserve">
          <source>If you blow the index away entirely, you generally haven&amp;rsquo;t lost any information as long as you have the name of the tree that it described.</source>
          <target state="translated">インデックスを完全に吹き飛ばしても、ツリーの名前が記述されていれば、情報は失われていません。</target>
        </trans-unit>
        <trans-unit id="2d2eeeb68a563ca60a2c585f75afbad9b4a5940e" translate="yes" xml:space="preserve">
          <source>If you both have a test suite and use git bisect, then it becomes less important to check that all tests pass after each commit. Though of course it is probably a good idea to have some checks to avoid breaking too many things because it could make bisecting other bugs more difficult.</source>
          <target state="translated">両方ともテストスイートを持っていて git bisect を使用しているのであれば、コミットのたびにすべてのテストが合格しているかどうかをチェックすることはそれほど重要ではありません。もちろん、あまり多くのものを壊さないようにするためにチェックをしておくのは良いアイデアかもしれませんが、そうすると他のバグを二分するのが難しくなってしまうからです。</target>
        </trans-unit>
        <trans-unit id="7c966eb4fc191c72371d7ddd65b21062f03ccb57" translate="yes" xml:space="preserve">
          <source>If you can do that, you can now recreate the missing object with</source>
          <target state="translated">これができれば、行方不明のオブジェクトを</target>
        </trans-unit>
        <trans-unit id="5c6e6ccfdc26bd491d9ed428be6d535f807a44d7" translate="yes" xml:space="preserve">
          <source>If you choose to wait for the repack, don&amp;rsquo;t try to run benchmarks or performance tests until repacking is completed. fast-import outputs suboptimal packfiles that are simply never seen in real use situations.</source>
          <target state="translated">再パックを待つことを選択した場合は、再パックが完了するまでベンチマークまたはパフォーマンステストを実行しないでください。fast-importは、実際の使用状況では決して見られない次善のパックファイルを出力します。</target>
        </trans-unit>
        <trans-unit id="db9a66177c2b117d0740a2ed1a511dcc1bea6811" translate="yes" xml:space="preserve">
          <source>If you decide that you&amp;rsquo;d rather see version 2.6.17, you can modify the current branch to point at v2.6.17 instead, with</source>
          <target state="translated">バージョン2.6.17を表示したい場合は、代わりに現在のブランチを変更してv2.6.17をポイントすることができます。</target>
        </trans-unit>
        <trans-unit id="c943de9e92fabf055b174eed9b10ced62cf6d401" translate="yes" xml:space="preserve">
          <source>If you decide you want the history back, you can always create a new reference pointing to it, for example, a new branch:</source>
          <target state="translated">履歴を戻したいと思ったら、いつでもその履歴を指す新しい参照を作成することができます。</target>
        </trans-unit>
        <trans-unit id="1f288af5e76ef5a4f231f5810c9960b284e03991" translate="yes" xml:space="preserve">
          <source>If you develop on a branch crazy-idea, then regret it, you can always delete the branch with</source>
          <target state="translated">ブランチの crazy-idea で開発した後に後悔した場合は、いつでもそのブランチを削除することができます。</target>
        </trans-unit>
        <trans-unit id="6d7822c644d713e2101d339a30a68a502f988e1b" translate="yes" xml:space="preserve">
          <source>If you didn&amp;rsquo;t specify the CVSROOT/CVS_SERVER directly in the checkout command, automatically saving it in your &lt;code&gt;CVS/Root&lt;/code&gt; files, then you need to set them explicitly in your environment. CVSROOT should be set as per normal, but the directory should point at the appropriate Git repo. As above, for SSH clients &lt;code&gt;not&lt;/code&gt; restricted to &lt;code&gt;git-shell&lt;/code&gt;, CVS_SERVER should be set to &lt;code&gt;git-cvsserver&lt;/code&gt;.</source>
          <target state="translated">CVSROOT / CVS_SERVERをcheckoutコマンドで直接指定せず、 &lt;code&gt;CVS/Root&lt;/code&gt; ファイルに自動的に保存した場合は、環境で明示的に設定する必要があります。CVSROOTは通常どおりに設定する必要がありますが、ディレクトリは適切なGitリポジトリを指す必要があります。上記のように、 &lt;code&gt;git-shell&lt;/code&gt; に制限されて &lt;code&gt;not&lt;/code&gt; SSHクライアントの場合、CVS_SERVERを &lt;code&gt;git-cvsserver&lt;/code&gt; に設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="467e5efa7fe7a25688df5c19177b2c4b9a971487" translate="yes" xml:space="preserve">
          <source>If you discover that you made a mistake in specifying the status of a revision, you can save the output of this command to a file, edit it to remove the incorrect entries, and then issue the following commands to return to a corrected state:</source>
          <target state="translated">リビジョンの状態の指定に誤りがあったことがわかった場合は、このコマンドの出力をファイルに保存し、編集して誤った項目を削除した後、以下のコマンドを発行して修正した状態に戻すことができます。</target>
        </trans-unit>
        <trans-unit id="fdb535b3114700ba9158b47e1cadbbb4ffee0391" translate="yes" xml:space="preserve">
          <source>If you do merge, note the following rule: &lt;code&gt;git svn dcommit&lt;/code&gt; will attempt to commit on top of the SVN commit named in</source>
          <target state="translated">マージする場合は、次のルールに注意してください： &lt;code&gt;git svn dcommit&lt;/code&gt; は、</target>
        </trans-unit>
        <trans-unit id="d7d53a76c809507d4642710878a2561fe720cf02" translate="yes" xml:space="preserve">
          <source>If you do not have &lt;code&gt;mod_rewrite&lt;/code&gt; available to match against the query string, it is sufficient to just protect &lt;code&gt;git-receive-pack&lt;/code&gt; itself, like:</source>
          <target state="translated">クエリ文字列との照合に使用できる &lt;code&gt;mod_rewrite&lt;/code&gt; がない場合は、次のように &lt;code&gt;git-receive-pack&lt;/code&gt; 自体を保護するだけで十分です。</target>
        </trans-unit>
        <trans-unit id="61817ad83cf40051c64b68562493dd77ca2fe6f8" translate="yes" xml:space="preserve">
          <source>If you do not have this configuration variable, the value of &lt;code&gt;i18n.commitEncoding&lt;/code&gt; is used instead.</source>
          <target state="translated">この構成変数がない場合は、代わりに &lt;code&gt;i18n.commitEncoding&lt;/code&gt; の値が使用されます。</target>
        </trans-unit>
        <trans-unit id="14f3fbb24beba0c7fa85b6385a5b3979968f4593" translate="yes" xml:space="preserve">
          <source>If you do not know the encoding of a file, then you can use the &lt;code&gt;file&lt;/code&gt; command to guess the encoding:</source>
          <target state="translated">ファイルのエンコーディングがわからない場合は、 &lt;code&gt;file&lt;/code&gt; コマンドを使用してエンコーディングを推測できます。</target>
        </trans-unit>
        <trans-unit id="371074e4db6e9a2527bbe63c09ef576231a57ee5" translate="yes" xml:space="preserve">
          <source>If you do not want this feature on your server just remove the second rewrite rule.</source>
          <target state="translated">サーバー上でこの機能を必要としない場合は、2番目の書き換えルールを削除してください。</target>
        </trans-unit>
        <trans-unit id="b68a865397b0b847cde7a3d94bca4e3b8a2b1c61" translate="yes" xml:space="preserve">
          <source>If you do not want to lose your work (history from X to B) or the work by the other person (history from X to A), you would need to first fetch the history from the repository, create a history that contains changes done by both parties, and push the result back.</source>
          <target state="translated">自分の作業(XからBへの履歴)や相手の作業(XからAへの履歴)を失いたくない場合は、まずリポジトリから履歴を取得し、双方が行った変更を含む履歴を作成し、その結果をプッシュバックする必要があります。</target>
        </trans-unit>
        <trans-unit id="86c596eda084e162303624098fd515841984d889" translate="yes" xml:space="preserve">
          <source>If you do this, then you should make a public announcement indicating that &lt;code&gt;next&lt;/code&gt; was rewound and rebuilt.</source>
          <target state="translated">これを行う場合は、 &lt;code&gt;next&lt;/code&gt; が巻き戻されて再構築されたことを示す公表を行う必要があります。</target>
        </trans-unit>
        <trans-unit id="325a3c2222e4d4aaa5c937ccab45f34c95352c49" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t want to continue with that right away, a few other digressions that may be interesting at this point are:</source>
          <target state="translated">すぐに続けたくない場合は、現時点で興味深い他の補足事項をいくつか示します。</target>
        </trans-unit>
        <trans-unit id="bf36326b8dfc35954574299040bce7c304964cb4" translate="yes" xml:space="preserve">
          <source>If you enable PATH_INFO usage in gitweb by putting</source>
          <target state="translated">を入れてgitwebでPATH_INFOの使用を有効にしておくと、GitwebでのPATH_INFOの使用が可能になります。</target>
        </trans-unit>
        <trans-unit id="3e267e16654424679545d579a56c2fc25a567700" translate="yes" xml:space="preserve">
          <source>If you examine the file &lt;code&gt;.git/config&lt;/code&gt;, you will see that Git has added a new stanza:</source>
          <target state="translated">ファイル &lt;code&gt;.git/config&lt;/code&gt; を調べると、Gitが新しいスタンザを追加していることがわかります。</target>
        </trans-unit>
        <trans-unit id="adaf459f23d870ce117760016108b7b8ca67ba63" translate="yes" xml:space="preserve">
          <source>If you examine the resulting commit using gitk, you will see that it has two parents, one pointing to the top of the current branch, and one to the top of the other branch.</source>
          <target state="translated">結果のコミットを gitk で調べてみると、現在のブランチの先頭を指す親と、もうひとつのブランチの先頭を指す親があることがわかります。</target>
        </trans-unit>
        <trans-unit id="f87315138be947ec0afa0ac1351920e4dfe2a0c2" translate="yes" xml:space="preserve">
          <source>If you find some reason to set this option to &lt;code&gt;false&lt;/code&gt;, other than one-off testing, you should report the behavior difference as a bug in Git (see &lt;a href=&quot;https://git-scm.com/community&quot;&gt;https://git-scm.com/community&lt;/a&gt; for details).</source>
          <target state="translated">1回限りのテスト以外に、このオプションを &lt;code&gt;false&lt;/code&gt; に設定する理由が見つかった場合は、動作の違いをGitのバグとして報告する必要があります（詳細については、&lt;a href=&quot;https://git-scm.com/community&quot;&gt;https：//git-scm.com/community&lt;/a&gt;を参照してください）。</target>
        </trans-unit>
        <trans-unit id="bbcb62743d9f0aa650833d05c94c3e3db4eb4e0d" translate="yes" xml:space="preserve">
          <source>If you find you forked off the wrong branch and want to move it &quot;back in time&quot;, use &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt;.</source>
          <target state="translated">間違ったブランチから分岐し、「時間を遡って」移動したい場合は、&lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]を&lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="12cef549aa55079a651285c652b78bc4bc8af80c" translate="yes" xml:space="preserve">
          <source>If you find you need new features from the branch &lt;code&gt;other&lt;/code&gt; to continue working on your topic, merge &lt;code&gt;other&lt;/code&gt; to &lt;code&gt;topic&lt;/code&gt;. (However, do not do this &quot;just habitually&quot;, see below.)</source>
          <target state="translated">あなたがブランチからの新しい機能を必要と判明した場合は &lt;code&gt;other&lt;/code&gt; トピックで作業を続けることが、合併 &lt;code&gt;other&lt;/code&gt; の &lt;code&gt;topic&lt;/code&gt; 。（ただし、これを「習慣的に」しないでください。以下を参照してください。）</target>
        </trans-unit>
        <trans-unit id="c89cdceb268014744fee40998409a87331a70cef" translate="yes" xml:space="preserve">
          <source>If you followed the last paragraph, you will now have many small topic branches, and occasionally wonder how they interact. Perhaps the result of merging them does not even work? But on the other hand, we want to avoid merging them anywhere &quot;stable&quot; because such merges cannot easily be undone.</source>
          <target state="translated">最後の段落をたどっていくと、今では小さなトピックの枝がたくさん出てきて、どうやって相互作用しているのだろうかと時折疑問に思うことがあります。もしかしたら、それらをマージした結果、うまくいかなくなってしまったのかもしれません。しかし、一方で、そのようなマージは簡単には元に戻せないので、「安定している」場所でのマージは避けたいところです。</target>
        </trans-unit>
        <trans-unit id="f8ccc691fa447494e794dd8643eee96c05ab0ca5" translate="yes" xml:space="preserve">
          <source>If you get stuck and decide to just give up and throw the whole mess away, you can always return to the pre-merge state with</source>
          <target state="translated">行き詰ってあきらめて全部捨ててしまった場合は、いつでも</target>
        </trans-unit>
        <trans-unit id="8d7c02e3dd22e344be3301eb8a2278c07f5b614c" translate="yes" xml:space="preserve">
          <source>If you grasp the ideas in that initial commit, you should check out a more recent version and skim &lt;code&gt;cache.h&lt;/code&gt;, &lt;code&gt;object.h&lt;/code&gt; and &lt;code&gt;commit.h&lt;/code&gt;.</source>
          <target state="translated">その最初のコミットのアイデアを理解している場合は、より新しいバージョンをチェックして、 &lt;code&gt;cache.h&lt;/code&gt; 、 &lt;code&gt;object.h&lt;/code&gt; 、commit.hを &lt;code&gt;commit.h&lt;/code&gt; 必要があります。</target>
        </trans-unit>
        <trans-unit id="b91c4875b14e285ca788a5bd5edf75dfcd9633ab" translate="yes" xml:space="preserve">
          <source>If you have a clone of git.git itself, the output of &lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog[1]&lt;/a&gt; and &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt; can show you the authors for specific parts of the project.</source>
          <target state="translated">git.git自体のクローンがある場合、&lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog [1]&lt;/a&gt;と&lt;a href=&quot;git-blame&quot;&gt;git-blame [1]&lt;/a&gt;の出力で、プロジェクトの特定の部分の作成者を確認できます。</target>
        </trans-unit>
        <trans-unit id="d76da65add1ab668fa52a438912f17a42719fc64" translate="yes" xml:space="preserve">
          <source>If you have a repository where all the branches of interest exist as subdirectories of a single depot path, you can use &lt;code&gt;--detect-branches&lt;/code&gt; when cloning or syncing to have &lt;code&gt;git p4&lt;/code&gt; automatically find subdirectories in p4, and to generate these as branches in Git.</source>
          <target state="translated">関心のあるすべてのブランチが単一の &lt;code&gt;--detect-branches&lt;/code&gt; サブディレクトリとして存在するリポジトリがある場合、クローンまたは同期時に--detect-branchesを使用して、 &lt;code&gt;git p4&lt;/code&gt; がp4のサブディレクトリを自動的に検索し、これらをGitのブランチとして生成できます。 。</target>
        </trans-unit>
        <trans-unit id="0a6081c46922db10b6bc6f47a7f76b221a6196d2" translate="yes" xml:space="preserve">
          <source>If you have a script that can tell if the current source code is good or bad, you can bisect by issuing the command:</source>
          <target state="translated">現在のソースコードが良いか悪いかを判別できるスクリプトがある場合は、コマンドを発行することで二分することができます。</target>
        </trans-unit>
        <trans-unit id="863f4e57810f45268a83fecc8614e1be7d434564" translate="yes" xml:space="preserve">
          <source>If you have added attributes to a file that cause the canonical repository format for that file to change, such as adding a clean/smudge filter or text/eol/ident attributes, merging anything where the attribute is not in place would normally cause merge conflicts.</source>
          <target state="translated">クリーン/スマッジフィルタや text/eol/ident 属性の追加など、そのファイルの標準的なリポジトリフォーマットを変更するような属性をファイルに追加した場合、その属性が存在しないところをマージすると、通常はマージコンフリクトが発生します。</target>
        </trans-unit>
        <trans-unit id="0176ab2e378e3df6f1e24b7af5113bcd1e2d5987" translate="yes" xml:space="preserve">
          <source>If you have an old Git that does not understand the version 2 &lt;code&gt;*.idx&lt;/code&gt; file, cloning or fetching over a non native protocol (e.g. &quot;http&quot;) that will copy both &lt;code&gt;*.pack&lt;/code&gt; file and corresponding &lt;code&gt;*.idx&lt;/code&gt; file from the other side may give you a repository that cannot be accessed with your older version of Git. If the &lt;code&gt;*.pack&lt;/code&gt; file is smaller than 2 GB, however, you can use &lt;a href=&quot;git-index-pack&quot;&gt;git-index-pack[1]&lt;/a&gt; on the *.pack file to regenerate the &lt;code&gt;*.idx&lt;/code&gt; file.</source>
          <target state="translated">バージョン2の &lt;code&gt;*.idx&lt;/code&gt; ファイルを理解できない古いGitがある場合、反対側から &lt;code&gt;*.pack&lt;/code&gt; ファイルと対応する &lt;code&gt;*.idx&lt;/code&gt; ファイルの両方をコピーする非ネイティブプロトコル（例： &quot;http&quot;）を介して複製またはフェッチする古いバージョンのGitではアクセスできないリポジトリが表示される場合があります。場合 &lt;code&gt;*.pack&lt;/code&gt; のファイルが2ギガバイトよりも小さい、しかし、あなたが使用することができる&lt;a href=&quot;git-index-pack&quot;&gt;のgit-インデックスパック[1]を&lt;/a&gt;再生成する* .packファイルに &lt;code&gt;*.idx&lt;/code&gt; ファイルを。</target>
        </trans-unit>
        <trans-unit id="1c4d7bfb0f77357b6cf0e14e83f75e3ad3892e2a" translate="yes" xml:space="preserve">
          <source>If you have an unfortunate branch that is named &lt;code&gt;hello.c&lt;/code&gt;, this step would be confused as an instruction to switch to that branch. You should instead write:</source>
          <target state="translated">&lt;code&gt;hello.c&lt;/code&gt; という名前の不幸なブランチがある場合、このステップはそのブランチに切り替えるための命令として混同されます。代わりに次のように書く必要があります：</target>
        </trans-unit>
        <trans-unit id="6748330dc78a7c7da8f6ed8d92c497a5f2638cdd" translate="yes" xml:space="preserve">
          <source>If you have imported some changes from another VCS and would like to add tags for major releases of your work, it is useful to be able to specify the date to embed inside of the tag object; such data in the tag object affects, for example, the ordering of tags in the gitweb interface.</source>
          <target state="translated">他の VCS から変更をインポートしていて、メジャーリリースのタグを追加したい場合は、タグオブジェクトの中に埋め込む日付を指定できると便利です。</target>
        </trans-unit>
        <trans-unit id="d87d691ee6c65f8321e66034d85f79793605b8a9" translate="yes" xml:space="preserve">
          <source>If you have local modifications to one or more files that are different between the current branch and the branch to which you are switching, the command refuses to switch branches in order to preserve your modifications in context. However, with this option, a three-way merge between the current branch, your working tree contents, and the new branch is done, and you will be on the new branch.</source>
          <target state="translated">現在のブランチと切り替え先のブランチの間で異なる変更があった場合、コマンドは変更内容をコンテキストとして保持するためにブランチの切り替えを拒否します。しかし、このオプションを使用すると、現在のブランチ、作業ツリーの内容、新しいブランチの間で 3 者間のマージが行われ、新しいブランチに移動することになります。</target>
        </trans-unit>
        <trans-unit id="8478bf298413f91bee793cf9d5101299eaa200bd" translate="yes" xml:space="preserve">
          <source>If you have multifactor authentication setup on your gmail account, you will need to generate an app-specific password for use with &lt;code&gt;git send-email&lt;/code&gt;. Visit &lt;a href=&quot;https://security.google.com/settings/security/apppasswords&quot;&gt;https://security.google.com/settings/security/apppasswords&lt;/a&gt; to create it.</source>
          <target state="translated">Gmailアカウントで多要素認証を設定している場合は、 &lt;code&gt;git send-email&lt;/code&gt; で使用するアプリ固有のパスワードを生成する必要があります。訪問&lt;a href=&quot;https://security.google.com/settings/security/apppasswords&quot;&gt;https://security.google.com/settings/security/apppasswords&lt;/a&gt;、それを作成します。</target>
        </trans-unit>
        <trans-unit id="a8709177c278b5c18333d173ba933d08e65c6841" translate="yes" xml:space="preserve">
          <source>If you have some initial content (say, a tarball):</source>
          <target state="translated">ある程度の初期コンテンツ(例えばターブル)があれば</target>
        </trans-unit>
        <trans-unit id="495e5ec3bcea1de47c24c2073588d5c3b0cf061c" translate="yes" xml:space="preserve">
          <source>If you have these three &lt;code&gt;gitattributes&lt;/code&gt; file:</source>
          <target state="translated">これら3つの &lt;code&gt;gitattributes&lt;/code&gt; ファイルがある場合：</target>
        </trans-unit>
        <trans-unit id="8c8ea948fec03c8051df6ee29e66dada48224b15" translate="yes" xml:space="preserve">
          <source>If you have uncommitted changes in your submodule working tree, &lt;code&gt;git
submodule update&lt;/code&gt; will not overwrite them. Instead, you get the usual warning about not being able switch from a dirty branch.</source>
          <target state="translated">サブモジュールの作業ツリーにコミットされていない変更がある場合、 &lt;code&gt;git submodule update&lt;/code&gt; はそれらを上書きしません。代わりに、ダーティブランチから切り替えられないという通常の警告が表示されます。</target>
        </trans-unit>
        <trans-unit id="4ccda3cb1e710a989feb173887174c1818fd9d4a" translate="yes" xml:space="preserve">
          <source>If you intend that your next commit should record all modifications of tracked files in the working tree and record all removals of files that have been removed from the working tree with &lt;code&gt;rm&lt;/code&gt; (as opposed to &lt;code&gt;git rm&lt;/code&gt;), use &lt;code&gt;git commit -a&lt;/code&gt;, as it will automatically notice and record all removals. You can also have a similar effect without committing by using &lt;code&gt;git add -u&lt;/code&gt;.</source>
          <target state="translated">次のコミットで追跡されたファイルのすべての変更を作業ツリーに記録し、作業ツリーから削除されたファイルのすべての削除を &lt;code&gt;rm&lt;/code&gt; で（ &lt;code&gt;git rm&lt;/code&gt; ではなく）記録する場合は、 &lt;code&gt;git commit -a&lt;/code&gt; を使用します。すべての削除に自動的に気づき、記録します。 &lt;code&gt;git add -u&lt;/code&gt; を使用すると、コミットせずに同様の効果を得ることができます。</target>
        </trans-unit>
        <trans-unit id="5223949abb561108f8606da60ebd3c3b78a9872c" translate="yes" xml:space="preserve">
          <source>If you intend to set up a shared public repository that all developers can read/write, or if you want to use &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver[1]&lt;/a&gt;, then you probably want to make a bare clone of the imported repository, and use the clone as the shared repository. See &lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration[7]&lt;/a&gt;.</source>
          <target state="translated">すべての開発者が読み書きできる共有パブリックリポジトリを設定する場合、または&lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver [1]&lt;/a&gt;を使用する場合は、インポートしたリポジトリのベアクローンを作成し、そのクローンを共有リポジトリ。&lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration [7]を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="1e8fe75eb0be8caf3b1c84cce78f8d98c5c3831c" translate="yes" xml:space="preserve">
          <source>If you just have a few changes, the simplest way to submit them may just be to send them as patches in email:</source>
          <target state="translated">変更点がいくつかあるだけであれば、メールでパッチとして送信するのが最も簡単な方法かもしれません。</target>
        </trans-unit>
        <trans-unit id="c3509063d9c8d28fc350d64af9974d7f7ad07d9f" translate="yes" xml:space="preserve">
          <source>If you just need to use Git as a revision control system you may prefer to start with &quot;A Tutorial Introduction to Git&quot; (&lt;a href=&quot;gittutorial&quot;&gt;gittutorial[7]&lt;/a&gt;) or &lt;a href=&quot;user-manual&quot;&gt;the Git User Manual&lt;/a&gt;.</source>
          <target state="translated">Gitをリビジョン管理システムとして使用する必要があるだけの場合は、「Gitのチュートリアル入門」（&lt;a href=&quot;gittutorial&quot;&gt;gittutorial [7]&lt;/a&gt;）または&lt;a href=&quot;user-manual&quot;&gt;Gitユーザーマニュアル&lt;/a&gt;から始めることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="6a839fbf210e306e2136c31f2a968baa357075d1" translate="yes" xml:space="preserve">
          <source>If you just want to edit the commit message for a commit, replace the command &quot;pick&quot; with the command &quot;reword&quot;.</source>
          <target state="translated">コミットのコミットメッセージを編集したいだけなら、&quot;pick &quot;コマンドを &quot;reword &quot;コマンドに置き換えてください。</target>
        </trans-unit>
        <trans-unit id="1a22bf44debddb2b1654740b48fdcb88c27e49eb" translate="yes" xml:space="preserve">
          <source>If you just want to get the newest copies of the integration branches, staying up to date is easy too:</source>
          <target state="translated">統合ブランチの最新版を入手したいだけなら、最新の状態を維持するのも簡単です。</target>
        </trans-unit>
        <trans-unit id="5a13a90084d33cb33125eb2c50fff6e07ce8c0d9" translate="yes" xml:space="preserve">
          <source>If you just want to look at an old version of the file, without modifying the working directory, you can do that with &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt;:</source>
          <target state="translated">作業ディレクトリを変更せずに、古いバージョンのファイルを見たいだけの場合は、&lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt;を使用して実行できます。</target>
        </trans-unit>
        <trans-unit id="5af7e34f55f5a635b889f9cb9a1ef742b6e402c4" translate="yes" xml:space="preserve">
          <source>If you just want to run git as if it was started in &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; then use &lt;code&gt;git -C &amp;lt;path&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; で開始されたかのようにgitを実行したい場合は、 &lt;code&gt;git -C &amp;lt;path&amp;gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="68f30cb563d71e3909ec492d5d34c92facf1030b" translate="yes" xml:space="preserve">
          <source>If you just want to verify whether a given tagged version contains a given commit, you could use &lt;a href=&quot;git-merge-base&quot;&gt;git-merge-base[1]&lt;/a&gt;:</source>
          <target state="translated">特定のタグ付きバージョンに特定のコミットが含まれているかどうかを確認するだけの場合は、&lt;a href=&quot;git-merge-base&quot;&gt;git-merge-base [1]を&lt;/a&gt;使用できます。</target>
        </trans-unit>
        <trans-unit id="d8a6261ebe4a4d52d4d9a2234a54f319605d4abc" translate="yes" xml:space="preserve">
          <source>If you keep your primary branches immediately under &lt;code&gt;refs/heads&lt;/code&gt;, and topic branches in subdirectories of it, having the following in the configuration file may help:</source>
          <target state="translated">&lt;code&gt;refs/heads&lt;/code&gt; のすぐ下にプライマリブランチを保持し、そのサブディレクトリにトピックブランチを保持する場合は、構成ファイルに以下を含めると役立つ場合があります。</target>
        </trans-unit>
        <trans-unit id="933889a0268ded50e3304543b4e7167783337a6d" translate="yes" xml:space="preserve">
          <source>If you know beforehand more than one good commit, you can narrow the bisect space down by specifying all of the good commits immediately after the bad commit when issuing the &lt;code&gt;bisect start&lt;/code&gt; command:</source>
          <target state="translated">事前に複数の適切なコミットがわかっている場合は、 &lt;code&gt;bisect start&lt;/code&gt; コマンドを発行するときに、不正なコミットの直後にすべての適切なコミットを指定することで、bisectスペースを絞り込むことができます。</target>
        </trans-unit>
        <trans-unit id="0d0efb22e26170e5f6a2a2c939fcf419b948a8aa" translate="yes" xml:space="preserve">
          <source>If you know up to what commit the intended recipient repository should have the necessary objects, you can use that knowledge to specify the basis, giving a cut-off point to limit the revisions and objects that go in the resulting bundle. The previous example used the lastR2bundle tag for this purpose, but you can use any other options that you would give to the &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; command. Here are more examples:</source>
          <target state="translated">目的の受信者リポジトリに必要なオブジェクトが含まれるコミットがわかっている場合は、その知識を使用して基礎を指定し、結果のバンドルに含まれるリビジョンとオブジェクトを制限するためのカットオフポイントを与えることができます。前の例では、この目的でlastR2bundleタグを使用しましたが、&lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt;コマンドに指定する他のオプションを使用できます。その他の例を次に示します。</target>
        </trans-unit>
        <trans-unit id="6178dcf6380091f437345048b81ae6acd9e3fdb2" translate="yes" xml:space="preserve">
          <source>If you leave out the commit name, &lt;code&gt;git grep&lt;/code&gt; will search any of the files it manages in your current directory. So</source>
          <target state="translated">コミット名を &lt;code&gt;git grep&lt;/code&gt; すると、git grepは現在のディレクトリで管理しているファイルを検索します。そう</target>
        </trans-unit>
        <trans-unit id="1d3a773743dd2af35a158be46f7bad29aaa6f592" translate="yes" xml:space="preserve">
          <source>If you like to live dangerously, you can replace &lt;strong&gt;all&lt;/strong&gt; core.gitproxy by a new one with</source>
          <target state="translated">危険な生活をしたい場合は、&lt;strong&gt;すべての&lt;/strong&gt; core.gitproxyを新しいものに置き換えることができます</target>
        </trans-unit>
        <trans-unit id="9bff9b22c3bcd9cedd5449471391b1cdf79647bb" translate="yes" xml:space="preserve">
          <source>If you make a commit and then find a mistake immediately after that, you can recover from it with &lt;code&gt;git reset&lt;/code&gt;.</source>
          <target state="translated">コミットを行った直後に間違いを見つけた場合は、 &lt;code&gt;git reset&lt;/code&gt; を使用して回復できます。</target>
        </trans-unit>
        <trans-unit id="de1cbbe8d26471b895b54a3d07b205ed1595e0f4" translate="yes" xml:space="preserve">
          <source>If you make a commit that you later wish you hadn&amp;rsquo;t, there are two fundamentally different ways to fix the problem:</source>
          <target state="translated">後で望んでいないコミットを行う場合、問題を修正するには2つの根本的に異なる方法があります。</target>
        </trans-unit>
        <trans-unit id="99ec09f13fb1346102b0f372f091bd234e630539" translate="yes" xml:space="preserve">
          <source>If you make it (very) clear that this branch is going to be deleted right after the testing, you can even publish this branch, for example to give the testers a chance to work with it, or other developers a chance to see if their in-progress work will be compatible. &lt;code&gt;git.git&lt;/code&gt; has such an official throw-away integration branch called &lt;code&gt;pu&lt;/code&gt;.</source>
          <target state="translated">このブランチがテストの直後に削除されることを（非常に）明確にした場合、たとえば、このブランチを公開して、テスターがブランチを操作する機会を与えたり、他の開発者が彼らの進行中の作業は互換性があります。 &lt;code&gt;git.git&lt;/code&gt; には、 &lt;code&gt;pu&lt;/code&gt; と呼ばれる使い捨ての公式統合ブランチがあります。</target>
        </trans-unit>
        <trans-unit id="2711d396bb29a520681068259bdc58e0b9b32fcb" translate="yes" xml:space="preserve">
          <source>If you make it (very) clear that this branch is going to be deleted right after the testing, you can even publish this branch, for example to give the testers a chance to work with it, or other developers a chance to see if their in-progress work will be compatible. &lt;code&gt;git.git&lt;/code&gt; has such an official throw-away integration branch called &lt;code&gt;seen&lt;/code&gt;.</source>
          <target state="translated">このブランチがテストの直後に削除されることを（非常に）明確にした場合、たとえば、テスターがブランチを操作する機会を与えたり、他の開発者が自分のブランチを確認する機会を与えたりするために、このブランチを公開することもできます。進行中の作業は互換性があります。 &lt;code&gt;git.git&lt;/code&gt; には、seenと呼ばれるそのような公式の使い捨て統合ブランチがあり &lt;code&gt;seen&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d532db8eaaa16fed286ca601d3c879ce0db79d29" translate="yes" xml:space="preserve">
          <source>If you make the decision to start your new branch at some other point in the history than the current &lt;code&gt;HEAD&lt;/code&gt;, you can do so by just telling &lt;code&gt;git checkout&lt;/code&gt; what the base of the checkout would be. In other words, if you have an earlier tag or branch, you&amp;rsquo;d just do</source>
          <target state="translated">現在の &lt;code&gt;HEAD&lt;/code&gt; 以外の履歴の別の時点で新しいブランチを開始することを決定した場合、チェックアウトのベースがどうなるかを &lt;code&gt;git checkout&lt;/code&gt; に伝えるだけでそれを行うことができます。つまり、以前のタグまたはブランチがある場合は、</target>
        </trans-unit>
        <trans-unit id="9f31f9c748a9e0ffbef8f11bc85a6ff4ec5b3e8d" translate="yes" xml:space="preserve">
          <source>If you make the decision to start your new branch at some other point in the history than the current &lt;code&gt;HEAD&lt;/code&gt;, you can do so by just telling &lt;code&gt;git switch&lt;/code&gt; what the base of the checkout would be. In other words, if you have an earlier tag or branch, you&amp;rsquo;d just do</source>
          <target state="translated">履歴の現在の &lt;code&gt;HEAD&lt;/code&gt; 以外の時点で新しいブランチを開始することを決定した場合は、チェックアウトのベースを &lt;code&gt;git switch&lt;/code&gt; 指示するだけで開始できます。言い換えれば、以前のタグまたはブランチがある場合は、</target>
        </trans-unit>
        <trans-unit id="ef318d408cfc2262e9ecdfec6313bac5c50bc49a" translate="yes" xml:space="preserve">
          <source>If you manually move a linked working tree, you need to update the &lt;code&gt;gitdir&lt;/code&gt; file in the entry&amp;rsquo;s directory. For example, if a linked working tree is moved to &lt;code&gt;/newpath/test-next&lt;/code&gt; and its &lt;code&gt;.git&lt;/code&gt; file points to &lt;code&gt;/path/main/.git/worktrees/test-next&lt;/code&gt;, then update &lt;code&gt;/path/main/.git/worktrees/test-next/gitdir&lt;/code&gt; to reference &lt;code&gt;/newpath/test-next&lt;/code&gt; instead.</source>
          <target state="translated">リンクされた作業ツリーを手動で移動する場合は、エントリのディレクトリにある &lt;code&gt;gitdir&lt;/code&gt; ファイルを更新する必要があります。たとえば、リンクされた作業ツリーが &lt;code&gt;/newpath/test-next&lt;/code&gt; に移動され、その &lt;code&gt;.git&lt;/code&gt; ファイルが &lt;code&gt;/path/main/.git/worktrees/test-next&lt;/code&gt; を指す場合、/ path / main / .git / worktrees /を更新し &lt;code&gt;/path/main/.git/worktrees/test-next/gitdir&lt;/code&gt; 代わりにtest-next / gitdirは &lt;code&gt;/newpath/test-next&lt;/code&gt; を参照します。</target>
        </trans-unit>
        <trans-unit id="0359d10c71e55182679347b30eaf723b449ffc8c" translate="yes" xml:space="preserve">
          <source>If you manually move a linked working tree, you need to update the &lt;code&gt;gitdir&lt;/code&gt; file in the entry&amp;rsquo;s directory. For example, if a linked working tree is moved to &lt;code&gt;/newpath/test-next&lt;/code&gt; and its &lt;code&gt;.git&lt;/code&gt; file points to &lt;code&gt;/path/main/.git/worktrees/test-next&lt;/code&gt;, then update &lt;code&gt;/path/main/.git/worktrees/test-next/gitdir&lt;/code&gt; to reference &lt;code&gt;/newpath/test-next&lt;/code&gt; instead. Better yet, run &lt;code&gt;git worktree repair&lt;/code&gt; to reestablish the connection automatically.</source>
          <target state="translated">リンクされた作業ツリーを手動で移動する場合は、エントリのディレクトリにある &lt;code&gt;gitdir&lt;/code&gt; ファイルを更新する必要があります。たとえば、リンクされた作業ツリーが &lt;code&gt;/newpath/test-next&lt;/code&gt; に移動され、その &lt;code&gt;.git&lt;/code&gt; ファイルが &lt;code&gt;/path/main/.git/worktrees/test-next&lt;/code&gt; を指している場合は、/ path / main / .git / worktrees /を更新し &lt;code&gt;/path/main/.git/worktrees/test-next/gitdir&lt;/code&gt; 、代わりに &lt;code&gt;/newpath/test-next&lt;/code&gt; を参照します。さらに良いことに、 &lt;code&gt;git worktree repair&lt;/code&gt; を実行して、接続を自動的に再確立します。</target>
        </trans-unit>
        <trans-unit id="bb87bde3a880515ee52eb5a157ecf80cef103126" translate="yes" xml:space="preserve">
          <source>If you mistakenly drop or clear stash entries, they cannot be recovered through the normal safety mechanisms. However, you can try the following incantation to get a list of stash entries that are still in your repository, but not reachable any more:</source>
          <target state="translated">スタッシュエントリを誤って落としたりクリアしたりすると、通常の安全機構では復旧できません。しかし、以下の呪文を試してみて、リポジトリにはまだ残っているが、それ以上は到達できないスタッシュエントリのリストを取得することができます。</target>
        </trans-unit>
        <trans-unit id="110b0b8058519e9efd87b798163b83180b4fd090" translate="yes" xml:space="preserve">
          <source>If you need to add &lt;code&gt;Acked-by&lt;/code&gt; lines to, say, the last 10 commits (none of which is a merge), use this command:</source>
          <target state="translated">&lt;code&gt;Acked-by&lt;/code&gt; 行を、たとえば最後の10個のコミット（どれもマージではない）に追加する必要がある場合は、次のコマンドを使用します。</target>
        </trans-unit>
        <trans-unit id="a06310bf48a43d3f06d75e4fe748345a055d13a9" translate="yes" xml:space="preserve">
          <source>If you need to amend commits from deeper in your history, you can use &lt;a href=&quot;#interactive-rebase&quot;&gt;interactive rebase&amp;rsquo;s &lt;code&gt;edit&lt;/code&gt; instruction&lt;/a&gt;.</source>
          <target state="translated">履歴のより深いところからコミットを修正する必要がある場合は、&lt;a href=&quot;#interactive-rebase&quot;&gt;インタラクティブなリベースの &lt;code&gt;edit&lt;/code&gt; 手順を&lt;/a&gt;使用できます。</target>
        </trans-unit>
        <trans-unit id="f26f13a2edb916f980bf0b233ef42611b499ae1c" translate="yes" xml:space="preserve">
          <source>If you need to make any further adjustments, do so now, and then add any newly modified content to the index. Finally, commit your changes with:</source>
          <target state="translated">追加の調整が必要な場合は、今すぐに行って、新たに変更した内容をインデックスに追加してください。最後に、変更をコミットします。</target>
        </trans-unit>
        <trans-unit id="b7346c069533043ab7106064793cec780b496e9d" translate="yes" xml:space="preserve">
          <source>If you need to pass multiple options, separate them with a comma.</source>
          <target state="translated">複数のオプションを渡す必要がある場合は、カンマで区切ってください。</target>
        </trans-unit>
        <trans-unit id="809b912a9ed5d5a0eab31e3007d95029a30a63c6" translate="yes" xml:space="preserve">
          <source>If you need to reorder or edit a number of commits in a branch, it may be easier to use &lt;code&gt;git rebase -i&lt;/code&gt;, which allows you to reorder and squash commits, as well as marking them for individual editing during the rebase. See &lt;a href=&quot;#interactive-rebase&quot;&gt;Using interactive rebases&lt;/a&gt; for details, and &lt;a href=&quot;#reordering-patch-series&quot;&gt;Reordering or selecting from a patch series&lt;/a&gt; for alternatives.</source>
          <target state="translated">ブランチ内のいくつかのコミットを並べ替えたり編集したりする必要がある場合は、 &lt;code&gt;git rebase -i&lt;/code&gt; を使用する方が簡単な場合があります。これにより、コミットの並べ替えとスカッシュ、およびリベース中に個々の編集用にマークを付けることができます。詳細については、&lt;a href=&quot;#interactive-rebase&quot;&gt;インタラクティブリベースの使用&lt;/a&gt;、および代替策について&lt;a href=&quot;#reordering-patch-series&quot;&gt;は、パッチシリーズの並べ替えまたは選択&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="653cbb8173c66cbe6d9c641e8756d2055e0c1628" translate="yes" xml:space="preserve">
          <source>If you never pushed anything out, just re-tag it. Use &quot;-f&quot; to replace the old one. And you&amp;rsquo;re done.</source>
          <target state="translated">何かを押し出したことがない場合は、タグを付け直してください。「-f」を使用して古いものを置き換えます。これで完了です。</target>
        </trans-unit>
        <trans-unit id="e0169e9e6701b28da91f9800a1f0eacd543a0e6b" translate="yes" xml:space="preserve">
          <source>If you now continue development as usual, and eventually merge &lt;code&gt;topic&lt;/code&gt; to &lt;code&gt;subsystem&lt;/code&gt;, the commits from &lt;code&gt;subsystem&lt;/code&gt; will remain duplicated forever:</source>
          <target state="translated">これで通常どおり開発を続け、最終的に &lt;code&gt;topic&lt;/code&gt; を &lt;code&gt;subsystem&lt;/code&gt; にマージすると、 &lt;code&gt;subsystem&lt;/code&gt; からのコミットは永久に複製されたままになります。</target>
        </trans-unit>
        <trans-unit id="d9ba20830393f58c8170e264c4d66d9dd0605070" translate="yes" xml:space="preserve">
          <source>If you now run</source>
          <target state="translated">今、あなたが実行した場合</target>
        </trans-unit>
        <trans-unit id="ee95c7e5ff1bbdc349787f30139d15eef70dff52" translate="yes" xml:space="preserve">
          <source>If you only want to remove the local checkout of a submodule from your work tree without committing the removal, use &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt;&lt;code&gt;deinit&lt;/code&gt; instead. Also see &lt;a href=&quot;gitsubmodules&quot;&gt;gitsubmodules[7]&lt;/a&gt; for details on submodule removal.</source>
          <target state="translated">削除をコミットせずに、 &lt;code&gt;deinit&lt;/code&gt; のローカルチェックアウトを作業ツリーから削除するだけの場合は、代わりに&lt;a href=&quot;git-submodule&quot;&gt;git-submodule [1] &lt;/a&gt;deinitを使用してください。参照してください&lt;a href=&quot;gitsubmodules&quot;&gt;gitsubmodules [7]&lt;/a&gt;サブモジュールの削除の詳細については、を。</target>
        </trans-unit>
        <trans-unit id="de4ecb2fda4e4a17fa4230cd7b06e657b6ab1e40" translate="yes" xml:space="preserve">
          <source>If you plan to publish this repository to be accessed over http, you should do &lt;code&gt;mv my-git.git/hooks/post-update.sample
my-git.git/hooks/post-update&lt;/code&gt; at this point. This makes sure that every time you push into this repository, &lt;code&gt;git update-server-info&lt;/code&gt; is run.</source>
          <target state="translated">このリポジトリをhttp経由でアクセスできるように公開する場合は、この時点で &lt;code&gt;mv my-git.git/hooks/post-update.sample my-git.git/hooks/post-update&lt;/code&gt; を実行する必要があります。これにより、このリポジトリにプッシュするたびに、 &lt;code&gt;git update-server-info&lt;/code&gt; が実行されます。</target>
        </trans-unit>
        <trans-unit id="dce58b5a972f1c023066ee29ac3c991fde1e2420" translate="yes" xml:space="preserve">
          <source>If you present all of your changes as a single patch (or commit), they may find that it is too much to digest all at once.</source>
          <target state="translated">すべての変更をひとつのパッチ (またはコミット)として提示した場合、一度にすべての変更を消化するには多すぎると感じるかもしれません。</target>
        </trans-unit>
        <trans-unit id="6e4131986cf58f7abe3d9d87945a8e4a59143945" translate="yes" xml:space="preserve">
          <source>If you present them with the entire history of your work, complete with mistakes, corrections, and dead ends, they may be overwhelmed.</source>
          <target state="translated">間違いや修正、行き詰まりを含めて、あなたの仕事の歴史全体を提示すると、彼らは圧倒されるかもしれません。</target>
        </trans-unit>
        <trans-unit id="21ee16e384bb8d43949dac71aebc6ab455b71a15" translate="yes" xml:space="preserve">
          <source>If you provide a &lt;code&gt;directory&lt;/code&gt;, the command is run inside it. If this directory does not exist, it will be created.</source>
          <target state="translated">&lt;code&gt;directory&lt;/code&gt; を指定すると、そのディレクトリ内でコマンドが実行されます。このディレクトリが存在しない場合は、作成されます。</target>
        </trans-unit>
        <trans-unit id="e318df70fba90a3c817f7eb76621f705fc69949d" translate="yes" xml:space="preserve">
          <source>If you pushed your change to a branch whose name is different from the one you have locally, e.g.</source>
          <target state="translated">ローカルにあるブランチとは異なる名前のブランチに変更をプッシュした場合。</target>
        </trans-unit>
        <trans-unit id="f36c21fb05ddb2d8eeea70a503cb3c797b4a7baa" translate="yes" xml:space="preserve">
          <source>If you really don&amp;rsquo;t want to clone it, for whatever reasons, check the following points instead (in this order). This is a very destructive approach, so &lt;strong&gt;make a backup&lt;/strong&gt; or go back to cloning it. You have been warned.</source>
          <target state="translated">どうしてもクローンしたくない場合は、何らかの理由で、代わりに以下の点を（この順序で）チェックしてください。これは非常に破壊的なアプローチなので&lt;strong&gt;、バックアップを作成する&lt;/strong&gt;か、クローンの作成に戻ります。あなたは警告されました。</target>
        </trans-unit>
        <trans-unit id="3a0d5ef629f0a421a47e2200b4c6f6985f396b8e" translate="yes" xml:space="preserve">
          <source>If you really want to remove a submodule from the repository and commit that use &lt;a href=&quot;git-rm&quot;&gt;git-rm[1]&lt;/a&gt; instead. See &lt;a href=&quot;gitsubmodules&quot;&gt;gitsubmodules[7]&lt;/a&gt; for removal options.</source>
          <target state="translated">リポジトリからサブモジュールを削除してコミットしたい場合は、代わりに&lt;a href=&quot;git-rm&quot;&gt;git-rm [1]を&lt;/a&gt;使用してください。削除オプションについては、&lt;a href=&quot;gitsubmodules&quot;&gt;gitsubmodules [7]&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="a5e65b5631472cf01bf2ff6d1fb37eb4b5d6b41d" translate="yes" xml:space="preserve">
          <source>If you really want to use &lt;code&gt;konqueror&lt;/code&gt;, then you can use something like the following:</source>
          <target state="translated">&lt;code&gt;konqueror&lt;/code&gt; を本当に使用したい場合は、次のようなものを使用できます。</target>
        </trans-unit>
        <trans-unit id="e3a8dad6f18366292640cec2d899866b39003a2b" translate="yes" xml:space="preserve">
          <source>If you receive such a patch series (as maintainer, or perhaps as a reader of the mailing list it was sent to), save the mails to files, create a new topic branch and use &lt;code&gt;git am&lt;/code&gt; to import the commits:</source>
          <target state="translated">このような一連のパッチを（メンテナとして、または送信先のメーリングリストのリーダーとして）受け取った場合は、メールをファイルに保存し、新しいトピックブランチを作成して、 &lt;code&gt;git am&lt;/code&gt; を使用してコミットをインポートします。</target>
        </trans-unit>
        <trans-unit id="8122cfb5e210d22279775f15b8524f8a454a6069" translate="yes" xml:space="preserve">
          <source>If you receive the SHA-1 name of a blob from one source, and its contents from another (possibly untrusted) source, you can still trust that those contents are correct as long as the SHA-1 name agrees. This is because the SHA-1 is designed so that it is infeasible to find different contents that produce the same hash.</source>
          <target state="translated">あるソースからブロブのSHA-1名を受け取り、別の(信頼されていない可能性のある)ソースからその内容を受け取った場合でも、SHA-1名が一致している限り、それらの内容が正しいことを信頼することができます。これは、SHA-1が、同じハッシュを生成する異なるコンテンツを見つけることができないように設計されているからです。</target>
        </trans-unit>
        <trans-unit id="72b668cfa18e4e3a824ca9d20a1fa4e3cde95d1f" translate="yes" xml:space="preserve">
          <source>If you recognize such corruption early you can easily fix it by setting the conversion type explicitly in .gitattributes. Right after committing you still have the original file in your work tree and this file is not yet corrupted. You can explicitly tell Git that this file is binary and Git will handle the file appropriately.</source>
          <target state="translated">このような破損に早期に気づいた場合は、.gitattributes で変換タイプを明示的に設定することで簡単に修正することができます。コミット直後はまだ元のファイルが作業ツリーに残っていて、このファイルはまだ破損していません。このファイルがバイナリであることを明示的にGitに伝えれば、Gitが適切に処理してくれます。</target>
        </trans-unit>
        <trans-unit id="6d44148625d48b9905fb64fc2d01c214d013573d" translate="yes" xml:space="preserve">
          <source>If you run &lt;code&gt;git branch&lt;/code&gt; at this point, you&amp;rsquo;ll see that Git has temporarily moved you in &quot;(no branch)&quot;. HEAD is now detached from any branch and points directly to a commit (with commit id 65934) that is reachable from &quot;master&quot; but not from v2.6.18. Compile and test it, and see whether it crashes. Assume it does crash. Then:</source>
          <target state="translated">この時点で &lt;code&gt;git branch&lt;/code&gt; を実行すると、Gitが一時的に「（ブランチなし）」に移動したことがわかります。HEADがブランチから切り離され、v2.6.18からではなく「マスター」から到達可能なコミット（コミットID 65934）を直接指します。コンパイルしてテストし、クラッシュするかどうかを確認します。クラッシュするとします。次に：</target>
        </trans-unit>
        <trans-unit id="e4f37857c4f0244dcc0891e65a70e27a5bbdffad" translate="yes" xml:space="preserve">
          <source>If you run &lt;code&gt;git fetch &amp;lt;remote&amp;gt;&lt;/code&gt; later, the remote-tracking branches for the named &lt;code&gt;&amp;lt;remote&amp;gt;&lt;/code&gt; will be updated.</source>
          <target state="translated">後で &lt;code&gt;git fetch &amp;lt;remote&amp;gt;&lt;/code&gt; を実行すると、指定された &lt;code&gt;&amp;lt;remote&amp;gt;&lt;/code&gt; のリモート追跡ブランチが更新されます。</target>
        </trans-unit>
        <trans-unit id="086aebbf0140fb264a45c34927db290b089af7f6" translate="yes" xml:space="preserve">
          <source>If you run &lt;code&gt;git repack&lt;/code&gt; again at this point, it will say &quot;Nothing new to pack.&quot;. Once you continue your development and accumulate the changes, running &lt;code&gt;git repack&lt;/code&gt; again will create a new pack, that contains objects created since you packed your repository the last time. We recommend that you pack your project soon after the initial import (unless you are starting your project from scratch), and then run &lt;code&gt;git repack&lt;/code&gt; every once in a while, depending on how active your project is.</source>
          <target state="translated">この時点で再度 &lt;code&gt;git repack&lt;/code&gt; を実行すると、「packに新しいものはありません」と表示されます。開発を続けて変更を蓄積したら、もう一度 &lt;code&gt;git repack&lt;/code&gt; を実行すると、前回リポジトリをパックしてから作成されたオブジェクトを含む新しいパックが作成されます。最初のインポートの直後にプロジェクトをパックすることをお勧めします（プロジェクトを最初から開始する場合を除く）。その後、プロジェクトのアクティブ度に応じて、 &lt;code&gt;git repack&lt;/code&gt; 実行します。</target>
        </trans-unit>
        <trans-unit id="f6784580fd898de2457fa8e4a33fffee5347973c" translate="yes" xml:space="preserve">
          <source>If you simply want to have CRLF line endings in your working directory regardless of the repository you are working with, you can set the config variable &quot;core.autocrlf&quot; without using any attributes.</source>
          <target state="translated">単純に、作業しているリポジトリに関係なく作業ディレクトリにCRLFの行末を入れたい場合は、属性を使わずに設定変数 &quot;core.autocrlf &quot;を設定することができます。</target>
        </trans-unit>
        <trans-unit id="7c25024f01247f9dfa8226991c206d71987ca030" translate="yes" xml:space="preserve">
          <source>If you suspect that any of these issues may apply to the repository you want to import, consider using cvs2git:</source>
          <target state="translated">これらの問題がインポートしたいリポジトリに当てはまると思われる場合は、 cvs2git の使用を検討してください。</target>
        </trans-unit>
        <trans-unit id="d4145f8caae501b7db828bb5aa5f527a21b88535" translate="yes" xml:space="preserve">
          <source>If you think you have found a git bug, you can start by exporting an anonymized stream of the whole repository:</source>
          <target state="translated">git のバグを見つけたと思ったら、リポジトリ全体の匿名ストリームをエクスポートすることから始めましょう。</target>
        </trans-unit>
        <trans-unit id="846aba2aee9d2174839c8e896f13afd75da487fc" translate="yes" xml:space="preserve">
          <source>If you tried a merge which resulted in complex conflicts and want to start over, you can recover with &lt;code&gt;git merge --abort&lt;/code&gt;.</source>
          <target state="translated">複雑な競合を引き起こしたマージを試みてやり直したい場合は、 &lt;code&gt;git merge --abort&lt;/code&gt; を使用して回復できます。</target>
        </trans-unit>
        <trans-unit id="0e65bb746f0318eba11b3455708b3d4c243b8cb3" translate="yes" xml:space="preserve">
          <source>If you tried a pull which resulted in complex conflicts and would want to start over, you can recover with &lt;code&gt;git reset&lt;/code&gt;.</source>
          <target state="translated">複雑な競合を引き起こし、やり直したいプルを試みた場合は、 &lt;code&gt;git reset&lt;/code&gt; で回復できます。</target>
        </trans-unit>
        <trans-unit id="a4f4230d5ba7e1273c96751869d78c8666680eb6" translate="yes" xml:space="preserve">
          <source>If you try and cheat and try to make git-filter-branch only work on files modified in a commit, then two things happen</source>
          <target state="translated">チートして git-filter-branch をコミット中に変更されたファイルに対してのみ動作するようにすると、ふたつのことが起こります。</target>
        </trans-unit>
        <trans-unit id="8c2ff328d40e63aa92549620e7b30dc7bd79b356" translate="yes" xml:space="preserve">
          <source>If you use any of the options marked &quot;Turns off &lt;code&gt;apply&lt;/code&gt;&quot; above, &lt;code&gt;git apply&lt;/code&gt; reads and outputs the requested information without actually applying the patch. Give this flag after those flags to also apply the patch.</source>
          <target state="translated">上記の「 &lt;code&gt;apply&lt;/code&gt; オフにする」とマークされているオプションのいずれかを使用する場合、 &lt;code&gt;git apply&lt;/code&gt; は実際にパッチを適用せずに、要求された情報を読み取って出力します。これらのフラグの後にこのフラグを指定すると、パッチも適用されます。</target>
        </trans-unit>
        <trans-unit id="9ac6e5a034fc806d1c17415da5d8566070ff7060" translate="yes" xml:space="preserve">
          <source>If you use the rewrite rules from the example you &lt;strong&gt;might&lt;/strong&gt; also need something like the following in your gitweb configuration file (&lt;code&gt;/etc/gitweb.conf&lt;/code&gt; following example):</source>
          <target state="translated">この例の書き換えルールを使用する場合は、gitweb構成ファイル（次の例の &lt;code&gt;/etc/gitweb.conf&lt;/code&gt; )に次のようなものも必要になる場合&lt;strong&gt;が&lt;/strong&gt;あります。</target>
        </trans-unit>
        <trans-unit id="7b6c2f4a6c5d4d8aeea38b5e0c4e8e111c81122f" translate="yes" xml:space="preserve">
          <source>If you want a shared repository, you will need to make a bare clone of the imported directory, as described above. Then treat the imported directory as another development clone for purposes of merging incremental imports.</source>
          <target state="translated">共有リポジトリを作成したい場合は、上記で説明したように、インポートしたディレクトリをベアクローンにする必要があります。そして、インクリメンタルインポートをマージするために、インポートされたディレクトリを別の開発用クローンとして扱います。</target>
        </trans-unit>
        <trans-unit id="f7444f839f8aa37b3a95b6650647c55221c170f1" translate="yes" xml:space="preserve">
          <source>If you want command input to still be interpreted as usual by &lt;code&gt;git rev-parse&lt;/code&gt; before the output is shell quoted, see the &lt;code&gt;--sq&lt;/code&gt; option.</source>
          <target state="translated">コマンド入力を、通常どおり、出力がシェルで引用される前に &lt;code&gt;git rev-parse&lt;/code&gt; によって解釈されるようにするには、 &lt;code&gt;--sq&lt;/code&gt; オプションを参照してください。</target>
        </trans-unit>
        <trans-unit id="54d050e248b6c4afcd2cdb81603440db07ba11e1" translate="yes" xml:space="preserve">
          <source>If you want to break the dependency of a repository cloned with &lt;code&gt;--shared&lt;/code&gt; on its source repository, you can simply run &lt;code&gt;git repack -a&lt;/code&gt; to copy all objects from the source repository into a pack in the cloned repository.</source>
          <target state="translated">ソースリポジトリで &lt;code&gt;--shared&lt;/code&gt; を使用して複製されたリポジトリの依存関係を解除する場合は、 &lt;code&gt;git repack -a&lt;/code&gt; を実行して、すべてのオブジェクトをソースリポジトリから複製されたリポジトリのパックにコピーできます。</target>
        </trans-unit>
        <trans-unit id="175eedbbcb252ccb8b65afc8343c53ee6468a326" translate="yes" xml:space="preserve">
          <source>If you want to check out &lt;code&gt;all&lt;/code&gt; C source files out of the index, you can say</source>
          <target state="translated">インデックスから &lt;code&gt;all&lt;/code&gt; Cソースファイルをチェックアウトする場合は、次のように言うことができます。</target>
        </trans-unit>
        <trans-unit id="e8498bad4ba6680850d835a14e8199fc54c7601f" translate="yes" xml:space="preserve">
          <source>If you want to delete an entry for a multivar (like core.gitproxy above), you have to provide a regex matching the value of exactly one line.</source>
          <target state="translated">(上記の core.gitproxy のような)multivar のエントリを削除したい場合は、正確に一行分の値にマッチする正規表現を指定しなければなりません。</target>
        </trans-unit>
        <trans-unit id="b6ce9e2807ee6d14a7a74a4824bf5e00e758331b" translate="yes" xml:space="preserve">
          <source>If you want to enable (or disable) this feature, it is easier to use the &lt;code&gt;core.fsmonitor&lt;/code&gt; configuration variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;) than using the &lt;code&gt;--fsmonitor&lt;/code&gt; option to &lt;code&gt;git update-index&lt;/code&gt; in each repository, especially if you want to do so across all repositories you use, because you can set the configuration variable in your &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; just once and have it affect all repositories you touch.</source>
          <target state="translated">この機能を有効（または無効）にする場合は、 &lt;code&gt;--fsmonitor&lt;/code&gt; オプションを使用して各リポジトリで &lt;code&gt;git update-index&lt;/code&gt; を実行するよりも、 &lt;code&gt;core.fsmonitor&lt;/code&gt; 構成変数（&lt;a href=&quot;git-config&quot;&gt;git-config [1]を&lt;/a&gt;参照）を使用する方が簡単です。 &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; で設定変数を一度だけ設定して、すべてのリポジトリに影響を与えることができるので、使用するすべてのリポジトリでこれを行う必要があります。</target>
        </trans-unit>
        <trans-unit id="fade353b5f9f7d0b204907810eaa983a2e094489" translate="yes" xml:space="preserve">
          <source>If you want to enable (or disable) this feature, it is easier to use the &lt;code&gt;core.untrackedCache&lt;/code&gt; configuration variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;) than using the &lt;code&gt;--untracked-cache&lt;/code&gt; option to &lt;code&gt;git update-index&lt;/code&gt; in each repository, especially if you want to do so across all repositories you use, because you can set the configuration variable to &lt;code&gt;true&lt;/code&gt; (or &lt;code&gt;false&lt;/code&gt;) in your &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; just once and have it affect all repositories you touch.</source>
          <target state="translated">この機能を有効（または無効）にする場合は、 &lt;code&gt;--untracked-cache&lt;/code&gt; オプションを使用して各リポジトリの &lt;code&gt;git update-index&lt;/code&gt; をgitで実行するよりも、 &lt;code&gt;core.untrackedCache&lt;/code&gt; 構成変数（&lt;a href=&quot;git-config&quot;&gt;git-config [1]を&lt;/a&gt;参照）を使用する方が簡単です。特に、使用するすべてのリポジトリでそうしたい場合は、 &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; 設定変数を &lt;code&gt;true&lt;/code&gt; （または &lt;code&gt;false&lt;/code&gt; ）に一度設定するだけで、すべてのリポジトリに影響を与えることができます。</target>
        </trans-unit>
        <trans-unit id="58323cdd8a68e6e1cc6d62c47524db6593349b87" translate="yes" xml:space="preserve">
          <source>If you want to ensure that text files that any contributor introduces to the repository have their line endings normalized, you can set the &lt;code&gt;text&lt;/code&gt; attribute to &quot;auto&quot; for &lt;code&gt;all&lt;/code&gt; files.</source>
          <target state="translated">寄稿者がリポジトリに導入したテキストファイルの行末が正規化されていることを確認したい場合は、 &lt;code&gt;all&lt;/code&gt; ファイルの &lt;code&gt;text&lt;/code&gt; 属性を「自動」に設定できます。</target>
        </trans-unit>
        <trans-unit id="46aa6af5bcc60a63656632720781ded6cb9a0464" translate="yes" xml:space="preserve">
          <source>If you want to fold two or more commits into one, replace the command &quot;pick&quot; for the second and subsequent commits with &quot;squash&quot; or &quot;fixup&quot;. If the commits had different authors, the folded commit will be attributed to the author of the first commit. The suggested commit message for the folded commit is the concatenation of the commit messages of the first commit and of those with the &quot;squash&quot; command, but omits the commit messages of commits with the &quot;fixup&quot; command.</source>
          <target state="translated">2つ以上のコミットを1つにまとめたい場合は、2つ目以降のコミットの &quot;pick&quot; コマンドを &quot;squash&quot; や &quot;fixup&quot; に置き換えてください。コミットの作者が異なる場合、折りたたまれたコミットは最初のコミットの作者に帰属します。折りたたまれたコミットのコミットメッセージは、最初のコミットのコミットメッセージと &quot;squash&quot; コマンドのコミットメッセージを連結したものですが、&quot;fixup&quot; コマンドのコミットメッセージは省略されています。</target>
        </trans-unit>
        <trans-unit id="a1fc176bf758306e3705a3dd88ad77db4fb55698" translate="yes" xml:space="preserve">
          <source>If you want to have one URL for both gitweb and your &lt;code&gt;http://&lt;/code&gt; repositories, you can configure Apache like this:</source>
          <target state="translated">gitwebと &lt;code&gt;http://&lt;/code&gt; リポジトリの両方に1つのURL が必要な場合は、次のようにApacheを構成できます。</target>
        </trans-unit>
        <trans-unit id="23a694ff61b56e5a1054639701ce379b6eeb6564" translate="yes" xml:space="preserve">
          <source>If you want to know all the values for a multivar, do:</source>
          <target state="translated">マルチバーのすべての値を知りたい場合は、そうしてください。</target>
        </trans-unit>
        <trans-unit id="be838b052e83d8fa0d4980781547923358bc58d3" translate="yes" xml:space="preserve">
          <source>If you want to make a change within a submodule and you have a detached head, then you should create or checkout a branch, make your changes, publish the change within the submodule, and then update the superproject to reference the new commit:</source>
          <target state="translated">サブモジュール内で変更を加えたい場合で、ヘッドが切り離されている場合は、ブランチを作成するかチェックアウトして変更を加え、サブモジュール内で変更を公開し、新しいコミットを参照するようにスーパープロジェクトを更新する必要があります。</target>
        </trans-unit>
        <trans-unit id="f02c3e1c88ba7fbd299965b88348f8af1bb2eec2" translate="yes" xml:space="preserve">
          <source>If you want to make sure that the output actually names an object in your object database and/or can be used as a specific type of object you require, you can add the &lt;code&gt;^{type}&lt;/code&gt; peeling operator to the parameter. For example, &lt;code&gt;git rev-parse &quot;$VAR^{commit}&quot;&lt;/code&gt; will make sure &lt;code&gt;$VAR&lt;/code&gt; names an existing object that is a commit-ish (i.e. a commit, or an annotated tag that points at a commit). To make sure that &lt;code&gt;$VAR&lt;/code&gt; names an existing object of any type, &lt;code&gt;git rev-parse &quot;$VAR^{object}&quot;&lt;/code&gt; can be used.</source>
          <target state="translated">出力が実際にオブジェクトデータベース内のオブジェクトを指定していること、および/または必要な特定のタイプのオブジェクトとして使用できることを確認する場合は、 &lt;code&gt;^{type}&lt;/code&gt; ピーリング演算子をパラメーターに追加できます。たとえば、 &lt;code&gt;git rev-parse &quot;$VAR^{commit}&quot;&lt;/code&gt; は、 &lt;code&gt;$VAR&lt;/code&gt; がコミットっぽい既存のオブジェクト（つまり、コミット、またはコミットを指す注釈付きタグ）を指定していることを確認します。 &lt;code&gt;$VAR&lt;/code&gt; が任意のタイプの既存のオブジェクトを指定していることを確認するには、 &lt;code&gt;git rev-parse &quot;$VAR^{object}&quot;&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="136531f3c928e37ad60b2649b3285deac4e99b46" translate="yes" xml:space="preserve">
          <source>If you want to refer to a git refspec that has characters that are not allowed by CVS, you have two options. First, it may just work to supply the git refspec directly to the appropriate CVS -r argument; some CVS clients don&amp;rsquo;t seem to do much sanity checking of the argument. Second, if that fails, you can use a special character escape mechanism that only uses characters that are valid in CVS tags. A sequence of 4 or 5 characters of the form (underscore (&lt;code&gt;&quot;_&quot;&lt;/code&gt;), dash (&lt;code&gt;&quot;-&quot;&lt;/code&gt;), one or two characters, and dash (&lt;code&gt;&quot;-&quot;&lt;/code&gt;)) can encode various characters based on the one or two letters: &lt;code&gt;&quot;s&quot;&lt;/code&gt; for slash (&lt;code&gt;&quot;/&quot;&lt;/code&gt;), &lt;code&gt;&quot;p&quot;&lt;/code&gt; for period (&lt;code&gt;&quot;.&quot;&lt;/code&gt;), &lt;code&gt;&quot;u&quot;&lt;/code&gt; for underscore (&lt;code&gt;&quot;_&quot;&lt;/code&gt;), or two hexadecimal digits for any byte value at all (typically an ASCII number, or perhaps a part of a UTF-8 encoded character).</source>
          <target state="translated">CVSで許可されていない文字を含むgit refspecを参照する場合は、2つのオプションがあります。まず、git refspecを適切なCVS -r引数に直接指定するだけで機能する場合があります。一部のCVSクライアントは、引数の妥当性チェックをあまり行っていないようです。次に、それが失敗した場合、CVSタグで有効な文字のみを使用する特殊文字エスケープメカニズムを使用できます。次の形式の4文字または5文字のシーケンス（アンダースコア（ &lt;code&gt;&quot;_&quot;&lt;/code&gt; ）、ダッシュ（ &lt;code&gt;&quot;-&quot;&lt;/code&gt; ）、1文字または2文字、およびダッシュ（ &lt;code&gt;&quot;-&quot;&lt;/code&gt; ））は、1文字または2文字に基づいてさまざまな文字をエンコードできます。 &lt;code&gt;&quot;s&quot;&lt;/code&gt; はスラッシュ（ &lt;code&gt;&quot;/&quot;&lt;/code&gt; ）、 &lt;code&gt;&quot;p&quot;&lt;/code&gt; はピリオド（ &lt;code&gt;&quot;.&quot;&lt;/code&gt; ）、 &lt;code&gt;&quot;u&quot;&lt;/code&gt; アンダースコア（ &lt;code&gt;&quot;_&quot;&lt;/code&gt; ）、またはバイト値の2桁の16進数（通常はASCII番号、またはおそらくUTF-8でエンコードされた文字の一部）。</target>
        </trans-unit>
        <trans-unit id="e8beaf63d7e0d62995b4c7a9252b3f2ea0574fab" translate="yes" xml:space="preserve">
          <source>If you want to replace many blobs, trees or commits that are part of a string of commits, you may just want to create a replacement string of commits and then only replace the commit at the tip of the target string of commits with the commit at the tip of the replacement string of commits.</source>
          <target state="translated">多くのブロブやツリー、コミットの文字列の一部であるコミットを置換したい場合は、コミットの置換文字列を作成して、対象となるコミットの文字列の先端にあるコミットだけを置換文字列の先端にあるコミットに置換するとよいでしょう。</target>
        </trans-unit>
        <trans-unit id="44f075cf045ec7b6bbf9c6b54de29b3e2085d2d6" translate="yes" xml:space="preserve">
          <source>If you want to restore &lt;code&gt;all&lt;/code&gt; C source files to match the version in the index, you can say</source>
          <target state="translated">インデックス内のバージョンと一致するように &lt;code&gt;all&lt;/code&gt; Cソースファイルを復元する場合は、次のように指定できます。</target>
        </trans-unit>
        <trans-unit id="7bbbea69a50b6a93a6b75d0ba68d2bc45319d47b" translate="yes" xml:space="preserve">
          <source>If you want to rewrite URLs for push only, you can create a configuration section of the form:</source>
          <target state="translated">プッシュ専用のURLを書き換えたい場合は、フォームの設定部分を作成します。</target>
        </trans-unit>
        <trans-unit id="295a38729bbd2cc488fb271a44e4d101d6ee7a15" translate="yes" xml:space="preserve">
          <source>If you want to show differences between binary or specially-formatted blobs in your repository, you can choose to use either an external diff command, or to use textconv to convert them to a diff-able text format. Which method you choose depends on your exact situation.</source>
          <target state="translated">リポジトリ内でバイナリや特殊フォーマットの blob の違いを表示したい場合は、外部の diff コマンドを使用するか、textconv を使用して diff 可能なテキストフォーマットに変換するかのいずれかを選択できます。どちらの方法を選択するかは、あなたの状況によります。</target>
        </trans-unit>
        <trans-unit id="e3f3cfd8a6d2a1c0d741f6415c0be4ad8848457f" translate="yes" xml:space="preserve">
          <source>If you want to show other people your bisection process, you can get a log using for example:</source>
          <target state="translated">自分の二等分の過程を他の人に見せたい場合は、例えば、ログを取得することができます。</target>
        </trans-unit>
        <trans-unit id="07b554efbcde38cd3d8cb2b2cd3fe1b74a5f9d9d" translate="yes" xml:space="preserve">
          <source>If you want to start a disconnected history that records a set of paths that is totally different from the one of &lt;code&gt;&amp;lt;start_point&amp;gt;&lt;/code&gt;, then you should clear the index and the working tree right after creating the orphan branch by running &lt;code&gt;git rm -rf .&lt;/code&gt; from the top level of the working tree. Afterwards you will be ready to prepare your new files, repopulating the working tree, by copying them from elsewhere, extracting a tarball, etc.</source>
          <target state="translated">&lt;code&gt;&amp;lt;start_point&amp;gt;&lt;/code&gt; のパスとはまったく異なるパスのセットを記録する切断された履歴を開始する場合は、 &lt;code&gt;git rm -rf .&lt;/code&gt; 実行して孤立したブランチを作成した直後に、インデックスと作業ツリーをクリアする必要があります。作業ツリーの最上位から。その後、新しいファイルを準備したり、作業ツリーに再配置したり、他の場所からファイルをコピーしたり、tarballを抽出したりする準備が整います。</target>
        </trans-unit>
        <trans-unit id="5dc24ba332edd3d8bebaa76b808aacd296106da2" translate="yes" xml:space="preserve">
          <source>If you want to start a new branch from a remote branch of the same name:</source>
          <target state="translated">同名のリモートブランチから新しいブランチを開始したい場合。</target>
        </trans-unit>
        <trans-unit id="b533f775f69c9c29e40e15bb405c24bc01b04dac" translate="yes" xml:space="preserve">
          <source>If you want to use gitweb with several project roots you can edit your Apache virtual host and gitweb configuration files in the following way.</source>
          <target state="translated">複数のプロジェクトルートでgitwebを使いたい場合は、以下の方法でApacheのバーチャルホストとgitwebの設定ファイルを編集します。</target>
        </trans-unit>
        <trans-unit id="cced0d77bb2b4a5861e7555078781fd81234d732" translate="yes" xml:space="preserve">
          <source>If you want to, you can use &lt;code&gt;git cat-file&lt;/code&gt; to look at those objects, but you&amp;rsquo;ll have to use the object name, not the filename of the object:</source>
          <target state="translated">必要に応じて、 &lt;code&gt;git cat-file&lt;/code&gt; を使用してこれらのオブジェクトを確認できますが、オブジェクトのファイル名ではなく、オブジェクト名を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="9eff57ed3284da22d90930841774b80f0270e4be" translate="yes" xml:space="preserve">
          <source>If you wish the exclude patterns to affect only certain repositories (instead of every repository for a given project), you may instead put them in a file in your repository named &lt;code&gt;.git/info/exclude&lt;/code&gt;, or in any file specified by the &lt;code&gt;core.excludesFile&lt;/code&gt; configuration variable. Some Git commands can also take exclude patterns directly on the command line. See &lt;a href=&quot;gitignore&quot;&gt;gitignore[5]&lt;/a&gt; for the details.</source>
          <target state="translated">（特定のプロジェクトのすべてのリポジトリではなく）特定のリポジトリのみに影響する除外パターンが必要な場合は、代わりにそれらを &lt;code&gt;.git/info/exclude&lt;/code&gt; という名前のリポジトリ内のファイル、または &lt;code&gt;core.excludesFile&lt;/code&gt; 指定されたファイルに配置できます。 excludesFile構成変数。一部のGitコマンドは、コマンドラインで直接除外パターンを取得することもできます。詳細は&lt;a href=&quot;gitignore&quot;&gt;gitignore [5]&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="f3a956a01313129dd0835296263e6883d7abec99" translate="yes" xml:space="preserve">
          <source>If you wish to affect only a single repository (i.e., to assign attributes to files that are particular to one user&amp;rsquo;s workflow for that repository), then attributes should be placed in the &lt;code&gt;$GIT_DIR/info/attributes&lt;/code&gt; file. Attributes which should be version-controlled and distributed to other repositories (i.e., attributes of interest to all users) should go into &lt;code&gt;.gitattributes&lt;/code&gt; files. Attributes that should affect all repositories for a single user should be placed in a file specified by the &lt;code&gt;core.attributesFile&lt;/code&gt; configuration option (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). Its default value is $XDG_CONFIG_HOME/git/attributes. If $XDG_CONFIG_HOME is either not set or empty, $HOME/.config/git/attributes is used instead. Attributes for all users on a system should be placed in the &lt;code&gt;$(prefix)/etc/gitattributes&lt;/code&gt; file.</source>
          <target state="translated">単一のリポジトリのみに影響を与える場合（つまり、そのリポジトリの1人のユーザーのワークフローに固有のファイルに属性を割り当てる場合）、属性は &lt;code&gt;$GIT_DIR/info/attributes&lt;/code&gt; ファイルに配置する必要があります。バージョン管理して他のリポジトリに配布する必要がある属性（つまり、すべてのユーザーが関心を持つ属性）は、 &lt;code&gt;.gitattributes&lt;/code&gt; ファイルに入れる必要があります。 1人のユーザーのすべてのリポジトリに影響する属性は、 &lt;code&gt;core.attributesFile&lt;/code&gt; 構成オプションで指定されたファイルに配置する必要があります（&lt;a href=&quot;git-config&quot;&gt;git-config [1]を&lt;/a&gt;参照））。そのデフォルト値は$ XDG_CONFIG_HOME / git / attributesです。$ XDG_CONFIG_HOMEが設定されていないか空の場合、代わりに$ HOME / .config / git / attributesが使用されます。システム上のすべてのユーザーの属性は、 &lt;code&gt;$(prefix)/etc/gitattributes&lt;/code&gt; ファイルに配置する必要があります。</target>
        </trans-unit>
        <trans-unit id="8bef77486a59978a04a1c46b2c068b3863595296" translate="yes" xml:space="preserve">
          <source>If you work with other people, you will need commands listed in the &lt;a href=&quot;#PARTICIPANT&quot;&gt;Individual Developer (Participant)&lt;/a&gt; section as well.</source>
          <target state="translated">他の人と作業する場合は、&lt;a href=&quot;#PARTICIPANT&quot;&gt;個人の開発者（参加者）&lt;/a&gt;セクションにもリストされているコマンドが必要です。</target>
        </trans-unit>
        <trans-unit id="4cb8198fe4b8e422fe561ded3cf681f52266950f" translate="yes" xml:space="preserve">
          <source>If you would like the daemon to exit early, forgetting all cached credentials before their timeout, you can issue an &lt;code&gt;exit&lt;/code&gt; action:</source>
          <target state="translated">デーモンを早期に終了させ、タイムアウトする前にすべてのキャッシュされた資格情報を忘れたい場合は、 &lt;code&gt;exit&lt;/code&gt; アクションを発行できます。</target>
        </trans-unit>
        <trans-unit id="6fb92003fb885c97541d201047e1ea900190bac9" translate="yes" xml:space="preserve">
          <source>If you would like to use your own terms instead of &quot;bad&quot;/&quot;good&quot; or &quot;new&quot;/&quot;old&quot;, you can choose any names you like (except existing bisect subcommands like &lt;code&gt;reset&lt;/code&gt;, &lt;code&gt;start&lt;/code&gt;, &amp;hellip;​) by starting the bisection using</source>
          <target state="translated">「悪い」/「良い」または「新しい」/「古い」の代わりに独自の用語を使用する場合は、次のコマンドを &lt;code&gt;start&lt;/code&gt; 、好きな名前を選択できます（ &lt;code&gt;reset&lt;/code&gt; 、開始などの既存のbisectサブコマンドを除く）。二等分</target>
        </trans-unit>
        <trans-unit id="ac9785fae40224d0d9d1a9569429bd18f0ceb511" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re releasing a new version of a software project, you may want to simultaneously make a changelog to include in the release announcement.</source>
          <target state="translated">ソフトウェアプロジェクトの新しいバージョンをリリースする場合は、リリースアナウンスに含める変更ログを同時に作成することができます。</target>
        </trans-unit>
        <trans-unit id="6cd2cc907ee3e17f5caea471b5027cb72158e075" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve been committing small enough changes, you may now have a good shot at reconstructing the contents of the in-between state 4b9458b.</source>
          <target state="translated">十分に小さな変更をコミットしている場合は、中間状態4b9458bのコンテンツを再構築するのに良いショットがあるかもしれません。</target>
        </trans-unit>
        <trans-unit id="5516e4c9c575f8921939c0e95aa6e39fac3c93e0" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve configured a web server that isn&amp;rsquo;t listed here for gitweb, please send in the instructions so they can be included in a future release.</source>
          <target state="translated">ここに記載されていないウェブサーバーをgitweb用に設定している場合は、将来のリリースに含めることができるように手順を送信してください。</target>
        </trans-unit>
        <trans-unit id="2ca9c9b64a14bae5a21173833d4a0e06ad289f34" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve messed up the working tree, but haven&amp;rsquo;t yet committed your mistake, you can return the entire working tree to the last committed state with</source>
          <target state="translated">作業ツリーをめちゃくちゃにしているが、まだ間違いを犯していない場合は、作業ツリー全体を最後にコミットされた状態に戻すことができます</target>
        </trans-unit>
        <trans-unit id="346e091fa815a370c1b9ad910c5cda575a1ee6ab" translate="yes" xml:space="preserve">
          <source>If your Gmail account is set to another language than English, the name of the &quot;Drafts&quot; folder will be localized.</source>
          <target state="translated">Gmailアカウントが英語以外の言語に設定されている場合、「Drafts」フォルダの名前がローカライズされます。</target>
        </trans-unit>
        <trans-unit id="7bdd278937e1b543d6e4ef46f26f74578bcd1798" translate="yes" xml:space="preserve">
          <source>If your branch was based on &amp;lt;upstream&amp;gt; but &amp;lt;upstream&amp;gt; was rewound and your branch contains commits which were dropped, this option can be used with &lt;code&gt;--keep-base&lt;/code&gt; in order to drop those commits from your branch.</source>
          <target state="translated">ブランチが&amp;lt;upstream&amp;gt;に基づいていたが、&amp;lt;upstream&amp;gt;が巻き戻され、ドロップされたコミットがブランチに含まれている場合、このオプションを &lt;code&gt;--keep-base&lt;/code&gt; とともに使用して、ブランチからそれらのコミットをドロップできます。</target>
        </trans-unit>
        <trans-unit id="862f720d820aceb82a46583ae7c2b519ed5f9115" translate="yes" xml:space="preserve">
          <source>If your editor or some other system is running &lt;code&gt;git fetch&lt;/code&gt; in the background for you a way to mitigate this is to simply set up another remote:</source>
          <target state="translated">エディターまたは他のシステムがバックグラウンドで &lt;code&gt;git fetch&lt;/code&gt; を実行している場合、これを軽減する方法は、別のリモートをセットアップすることです。</target>
        </trans-unit>
        <trans-unit id="233e7aed3c7b3f81991c7f01f9bc6c69656e4a7c" translate="yes" xml:space="preserve">
          <source>If your repository contains one or more submodules, then submodules are populated based on interactions with the &lt;code&gt;git submodule&lt;/code&gt; command. Specifically, &lt;code&gt;git submodule init -- &amp;lt;path&amp;gt;&lt;/code&gt; will ensure the submodule at &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; is present, while &lt;code&gt;git submodule deinit [-f] -- &amp;lt;path&amp;gt;&lt;/code&gt; will remove the files for the submodule at &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; (including any untracked files, uncommitted changes, and unpushed history). Similar to how sparse-checkout removes files from the working tree but still leaves entries in the index, deinitialized submodules are removed from the working directory but still have an entry in the index.</source>
          <target state="translated">リポジトリに1つ以上のサブモジュールが含まれている場合、サブモジュールは &lt;code&gt;git submodule&lt;/code&gt; コマンドとの相互作用に基づいて入力されます。具体的には、 &lt;code&gt;git submodule init -- &amp;lt;path&amp;gt;&lt;/code&gt; にサブモジュールを確実にする &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 存在し、一方、 &lt;code&gt;git submodule deinit [-f] -- &amp;lt;path&amp;gt;&lt;/code&gt; でサブモジュールのためのファイルを削除します &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; （任意追跡されていないファイルを含みます、コミットされていない変更、およびプッシュされていない履歴）。 sparse-checkoutが作業ツリーからファイルを削除し、インデックスにエントリを残す方法と同様に、初期化されていないサブモジュールは作業ディレクトリから削除されますが、インデックスにはエントリがあります。</target>
        </trans-unit>
        <trans-unit id="6fc3997d817725ac54010e2c723e5760c4e0b90b" translate="yes" xml:space="preserve">
          <source>If your repository contains one or more submodules, then those submodules will appear based on which you initialized with the &lt;code&gt;git submodule&lt;/code&gt; command. If your sparse-checkout patterns exclude an initialized submodule, then that submodule will still appear in your working directory.</source>
          <target state="translated">リポジトリに1つ以上のサブモジュールが含まれている場合、それらのサブモジュールは、 &lt;code&gt;git submodule&lt;/code&gt; コマンドで初期化したものに基づいて表示されます。スパースチェックアウトパターンが初期化されたサブモジュールを除外する場合、そのサブモジュールは引き続き作業ディレクトリに表示されます。</target>
        </trans-unit>
        <trans-unit id="17a3911595f90d594aeea889e0f0755079e1efba" translate="yes" xml:space="preserve">
          <source>If, in the middle of a bisect session, you know that the suggested revision is not a good one to test (e.g. it fails to build and you know that the failure does not have anything to do with the bug you are chasing), you can manually select a nearby commit and test that one instead.</source>
          <target state="translated">bisect セッションの途中で、提案されたリビジョンがテストに適したものではないことがわかった場合 (例えば、ビルドに失敗し、その失敗が追いかけるバグとは関係ないことがわかった場合)、近くのコミットを手動で選択して、代わりにそのコミットをテストすることができます。</target>
        </trans-unit>
        <trans-unit id="4eaf7ef623b220dfff5cf0aad12284c2791aab6b" translate="yes" xml:space="preserve">
          <source>Ignore carriage-return at the end of line when doing a comparison.</source>
          <target state="translated">比較を行う際に行末のキャリッジリターンを無視します。</target>
        </trans-unit>
        <trans-unit id="14129ef50a9ff92ecf5a9d9520de0a5438b9b27c" translate="yes" xml:space="preserve">
          <source>Ignore case differences between the patterns and the files.</source>
          <target state="translated">パターンとファイルの大文字小文字の違いを無視します。</target>
        </trans-unit>
        <trans-unit id="93adbe048de005f652abeded323ffca0e07802f9" translate="yes" xml:space="preserve">
          <source>Ignore changes in amount of whitespace. This ignores whitespace at line end, and considers all other sequences of one or more whitespace characters to be equivalent.</source>
          <target state="translated">空白量の変化を無視します。これは、行末の空白を無視し、1つ以上の空白文字の他のすべてのシーケンスを同等とみなします。</target>
        </trans-unit>
        <trans-unit id="dceba3e490b99e465dabc6c0a6eb46378a762d2c" translate="yes" xml:space="preserve">
          <source>Ignore changes in whitespace at EOL.</source>
          <target state="translated">EOL時のホワイトスペースの変更は無視してください。</target>
        </trans-unit>
        <trans-unit id="0e8a5619a2125f597eccb060c4d8cfcacf8da768" translate="yes" xml:space="preserve">
          <source>Ignore changes made by the revision when assigning blame, as if the change never happened. Lines that were changed or added by an ignored commit will be blamed on the previous commit that changed that line or nearby lines. This option may be specified multiple times to ignore more than one revision. If the &lt;code&gt;blame.markIgnoredLines&lt;/code&gt; config option is set, then lines that were changed by an ignored commit and attributed to another commit will be marked with a &lt;code&gt;?&lt;/code&gt; in the blame output. If the &lt;code&gt;blame.markUnblamableLines&lt;/code&gt; config option is set, then those lines touched by an ignored commit that we could not attribute to another revision are marked with a &lt;code&gt;*&lt;/code&gt;.</source>
          <target state="translated">非難を割り当てるとき、変更が行われなかったかのように、リビジョンによって加えられた変更を無視します。無視されたコミットによって変更または追加された行は、その行または近くの行を変更した前のコミットのせいになります。このオプションを複数回指定して、複数のリビジョンを無視することができます。場合 &lt;code&gt;blame.markIgnoredLines&lt;/code&gt; 設定オプションが設定され、その後、コミット無視され、他に起因してマークされますコミットによって変更された行こと &lt;code&gt;?&lt;/code&gt; 非難の出力で。 &lt;code&gt;blame.markUnblamableLines&lt;/code&gt; 設定オプションが設定されている場合、無視されたコミットによって変更されたために別のリビジョンに関連付けることができなかった行は、 &lt;code&gt;*&lt;/code&gt; でマークされます。</target>
        </trans-unit>
        <trans-unit id="847c383f096e8b2857c23f7df697a300205d1cde" translate="yes" xml:space="preserve">
          <source>Ignore changes to submodules in the diff generation. &amp;lt;when&amp;gt; can be either &quot;none&quot;, &quot;untracked&quot;, &quot;dirty&quot; or &quot;all&quot;, which is the default. Using &quot;none&quot; will consider the submodule modified when it either contains untracked or modified files or its HEAD differs from the commit recorded in the superproject and can be used to override any settings of the &lt;code&gt;ignore&lt;/code&gt; option in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; or &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt;. When &quot;untracked&quot; is used submodules are not considered dirty when they only contain untracked content (but they are still scanned for modified content). Using &quot;dirty&quot; ignores all changes to the work tree of submodules, only changes to the commits stored in the superproject are shown (this was the behavior until 1.7.0). Using &quot;all&quot; hides all changes to submodules.</source>
          <target state="translated">差分生成のサブモジュールへの変更を無視します。 &amp;lt;when&amp;gt;は、「none」、「untracked」、「dirty」、またはデフォルトの「all」のいずれかです。 「なし」を使用すると、追跡されていないファイルまたは変更されたファイルが含まれている場合、またはスーパープロジェクトに記録されているコミットとHEADが異なる場合に変更されたサブモジュールと見なされ、&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;または&lt;a href=&quot;gitmodules&quot;&gt;gitmodules [&lt;/a&gt;の &lt;code&gt;ignore&lt;/code&gt; オプションの設定を上書きするために使用できます。 5]。 「追跡されていない」が使用されている場合、サブモジュールは追跡されていないコンテンツのみを含む場合はダーティとは見なされません（ただし、変更されたコンテンツがスキャンされます）。 「ダーティ」を使用すると、サブモジュールの作業ツリーに対するすべての変更が無視されます。スーパープロジェクトに保存されているコミットへの変更のみが表示されます（これは1.7.0までの動作でした）。 「すべて」を使用すると、サブモジュールに対するすべての変更が非表示になります。</target>
        </trans-unit>
        <trans-unit id="0a92f8e585ade182f513a5692eb0bb44a7e837dd" translate="yes" xml:space="preserve">
          <source>Ignore changes to submodules when looking for changes. &amp;lt;when&amp;gt; can be either &quot;none&quot;, &quot;untracked&quot;, &quot;dirty&quot; or &quot;all&quot;, which is the default. Using &quot;none&quot; will consider the submodule modified when it either contains untracked or modified files or its HEAD differs from the commit recorded in the superproject and can be used to override any settings of the &lt;code&gt;ignore&lt;/code&gt; option in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; or &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt;. When &quot;untracked&quot; is used submodules are not considered dirty when they only contain untracked content (but they are still scanned for modified content). Using &quot;dirty&quot; ignores all changes to the work tree of submodules, only changes to the commits stored in the superproject are shown (this was the behavior before 1.7.0). Using &quot;all&quot; hides all changes to submodules (and suppresses the output of submodule summaries when the config option &lt;code&gt;status.submoduleSummary&lt;/code&gt; is set).</source>
          <target state="translated">変更を探すときにサブモジュールへの変更を無視します。 &amp;lt;when&amp;gt;は、「none」、「untracked」、「dirty」、またはデフォルトの「all」のいずれかです。 「なし」を使用すると、追跡されていないファイルまたは変更されたファイルが含まれている場合、またはスーパープロジェクトに記録されているコミットとHEADが異なる場合に変更されたサブモジュールと見なされ、&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt;または&lt;a href=&quot;gitmodules&quot;&gt;gitmodules [&lt;/a&gt;の &lt;code&gt;ignore&lt;/code&gt; オプションの設定を上書きするために使用できます。 5]。「追跡されていない」が使用されている場合、サブモジュールは追跡されていないコンテンツのみを含む場合はダーティとは見なされません（ただし、変更されたコンテンツがスキャンされます）。「ダーティ」を使用すると、サブモジュールの作業ツリーに対するすべての変更が無視され、スーパープロジェクトに保存されているコミットに対する変更のみが表示されます（これは1.7.0より前の動作でした）。「all」を使用すると、サブモジュールに対するすべての変更が非表示になります（構成オプション &lt;code&gt;status.submoduleSummary&lt;/code&gt; が設定されている場合は、サブモジュールの要約の出力が抑制されます）。</target>
        </trans-unit>
        <trans-unit id="f616e5a6b317fb9674ab4a6ecd11655583864222" translate="yes" xml:space="preserve">
          <source>Ignore changes whose lines are all blank.</source>
          <target state="translated">行がすべて空白の変更を無視します。</target>
        </trans-unit>
        <trans-unit id="6b93913a06aa23ba136e18a208983b558968a818" translate="yes" xml:space="preserve">
          <source>Ignore refs for branches or tags matching the Perl regular expression. A &quot;negative look-ahead assertion&quot; like &lt;code&gt;^refs/remotes/origin/(?!tags/wanted-tag|wanted-branch).*$&lt;/code&gt; can be used to allow only certain refs.</source>
          <target state="translated">Perl正規表現に一致するブランチまたはタグの参照を無視します。 &lt;code&gt;^refs/remotes/origin/(?!tags/wanted-tag|wanted-branch).*$&lt;/code&gt; ような「否定的な先読み表明」は、特定の参照のみを許可するために使用できます。</target>
        </trans-unit>
        <trans-unit id="cca615474ea8523b5665d433104181e17b949af0" translate="yes" xml:space="preserve">
          <source>Ignore revisions listed in &lt;code&gt;file&lt;/code&gt;, which must be in the same format as an &lt;code&gt;fsck.skipList&lt;/code&gt;. This option may be repeated, and these files will be processed after any files specified with the &lt;code&gt;blame.ignoreRevsFile&lt;/code&gt; config option. An empty file name, &lt;code&gt;&quot;&quot;&lt;/code&gt;, will clear the list of revs from previously processed files.</source>
          <target state="translated">&lt;code&gt;file&lt;/code&gt; にリストされているリビジョンを無視します。これは、 &lt;code&gt;fsck.skipList&lt;/code&gt; と同じ形式でなければなりません。このオプションは繰り返すことができ、これらのファイルは &lt;code&gt;blame.ignoreRevsFile&lt;/code&gt; 構成オプションで指定されたファイルの後に処理されます。空のファイル名 &lt;code&gt;&quot;&quot;&lt;/code&gt; は、以前に処理されたファイルからリビジョンのリストをクリアします。</target>
        </trans-unit>
        <trans-unit id="0cee361918756e813fbfde1e81b931c608ea0bab" translate="yes" xml:space="preserve">
          <source>Ignore revisions listed in the file, one unabbreviated object name per line, in &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt;. Whitespace and comments beginning with &lt;code&gt;#&lt;/code&gt; are ignored. This option may be repeated multiple times. Empty file names will reset the list of ignored revisions. This option will be handled before the command line option &lt;code&gt;--ignore-revs-file&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;git-blame&quot;&gt;git-blame [1]&lt;/a&gt;で、ファイルにリストされているリビジョンを無視します（1行に1つの省略されていないオブジェクト名）。 &lt;code&gt;#&lt;/code&gt; で始まる空白とコメントは無視されます。このオプションは複数回繰り返すことができます。空のファイル名は、無視されるリビジョンのリストをリセットします。このオプションは、コマンドラインオプション &lt;code&gt;--ignore-revs-file&lt;/code&gt; の前に処理されます。</target>
        </trans-unit>
        <trans-unit id="ecf2829d6b1d696605f65878628b97d7705cf8bc" translate="yes" xml:space="preserve">
          <source>Ignore scissors lines (see &lt;a href=&quot;git-mailinfo&quot;&gt;git-mailinfo[1]&lt;/a&gt;).</source>
          <target state="translated">はさみの行を無視します（&lt;a href=&quot;git-mailinfo&quot;&gt;git-mailinfo [1]を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="2348d1bd6f42459d3ee1b173782de699bb2835d4" translate="yes" xml:space="preserve">
          <source>Ignore scissors lines. Useful for overriding mailinfo.scissors settings.</source>
          <target state="translated">ハサミ線を無視します。mailinfo.scissorsの設定をオーバーライドするのに便利です。</target>
        </trans-unit>
        <trans-unit id="df44e8d5c0f3cfab7d419d47fcf746abf35ec612" translate="yes" xml:space="preserve">
          <source>Ignore whitespace differences when trying to reconcile differences. Currently, each backend implements an approximation of this behavior:</source>
          <target state="translated">違いを調整しようとするときに、空白の違いを無視します。現在のところ、各バックエンドはこの動作の近似を実装しています。</target>
        </trans-unit>
        <trans-unit id="b8c0493eeab50cd9f84c9bb7fb54695bfa5cd858" translate="yes" xml:space="preserve">
          <source>Ignore whitespace when comparing lines. This ignores differences even if one line has whitespace where the other line has none.</source>
          <target state="translated">行を比較するときに空白を無視します。これは、一方の行に空白があり、他方の行に空白がない場合でも違いを無視します。</target>
        </trans-unit>
        <trans-unit id="f41139f9e81b5ab318787773cf3063813dbcefdd" translate="yes" xml:space="preserve">
          <source>Ignore whitespace when comparing the parent&amp;rsquo;s version and the child&amp;rsquo;s to find where the lines came from.</source>
          <target state="translated">親のバージョンと子のバージョンを比較するときに空白を無視して、行がどこから来たかを見つけます。</target>
        </trans-unit>
        <trans-unit id="67259bef7d0f56e262c4cda325ae4b91dc800c88" translate="yes" xml:space="preserve">
          <source>Ignored files are not listed, unless &lt;code&gt;--ignored&lt;/code&gt; option is in effect, in which case &lt;code&gt;XY&lt;/code&gt; are &lt;code&gt;!!&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--ignored&lt;/code&gt; オプションが有効になっていない限り、無視されたファイルはリストされません。その場合、 &lt;code&gt;XY&lt;/code&gt; は &lt;code&gt;!!&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5a64e868764637ce6fa403b78bdbf74f10990fd5" translate="yes" xml:space="preserve">
          <source>Ignored items have the following format:</source>
          <target state="translated">無視された項目は、以下のような形式になります。</target>
        </trans-unit>
        <trans-unit id="fe5aad4a58f02d9cd03afd86649692db9ed515bd" translate="yes" xml:space="preserve">
          <source>Ignores missing files during a --refresh</source>
          <target state="translated">リフレッシュ中に見つからないファイルを無視します。</target>
        </trans-unit>
        <trans-unit id="87a5b84b90eaf9c6a4ea4cf7776f8cdbe987e92e" translate="yes" xml:space="preserve">
          <source>Ignoring files</source>
          <target state="translated">ファイルを無視する</target>
        </trans-unit>
        <trans-unit id="d83f269a97cfa5cb2870ace661718351e9ef1d6f" translate="yes" xml:space="preserve">
          <source>Imagine that on top of the public commit P, you applied well-known patches X, Y and Z from somebody else, and then built your three-patch series A, B, C, the history would be like:</source>
          <target state="translated">公開されているコミットPの上に、他の誰かからよく知られているパッチX、Y、Zを適用して、3つのパッチシリーズA、B、Cを作ったとします。</target>
        </trans-unit>
        <trans-unit id="220433d0f0fcbc1334d4126616d73a1ad095f039" translate="yes" xml:space="preserve">
          <source>Imagine that you built your work on your &lt;code&gt;master&lt;/code&gt; branch on top of the &lt;code&gt;v1.0&lt;/code&gt; release, and want it to be integrated to the project. First you push that change to your public repository for others to see:</source>
          <target state="translated">&lt;code&gt;v1.0&lt;/code&gt; リリースの上に &lt;code&gt;master&lt;/code&gt; ブランチで作業を構築し、それをプロジェクトに統合したいとします。最初に、他の人が見ることができるように、その変更をパブリックリポジトリにプッシュします。</target>
        </trans-unit>
        <trans-unit id="d92dfaf42e4c06410357fc423fdf173e48ba5a6c" translate="yes" xml:space="preserve">
          <source>Imagine that you have to rebase what you have already published. You will have to bypass the &quot;must fast-forward&quot; rule in order to replace the history you originally published with the rebased history. If somebody else built on top of your original history while you are rebasing, the tip of the branch at the remote may advance with her commit, and blindly pushing with &lt;code&gt;--force&lt;/code&gt; will lose her work.</source>
          <target state="translated">すでに公開しているものをリベースする必要があると想像してください。最初に公開した履歴をリベースの履歴で置き換えるには、「早送りする必要があります」ルールをバイパスする必要があります。リベース中に他の誰かが元の履歴に基づいて構築した場合、リモートのブランチの先端がコミットを進める可能性があり、盲目的に &lt;code&gt;--force&lt;/code&gt; を押すと彼女の作業が失われます。</target>
        </trans-unit>
        <trans-unit id="8a9ff0ad91f2190aebd8f7874a38eff49a81d587" translate="yes" xml:space="preserve">
          <source>Imagine this history:</source>
          <target state="translated">この歴史を想像してみてください。</target>
        </trans-unit>
        <trans-unit id="db144a77867a22b1db2aa0f495d3082ced7cfb54" translate="yes" xml:space="preserve">
          <source>Imitate &lt;code&gt;git clone&lt;/code&gt; but track only selected branches</source>
          <target state="translated">&lt;code&gt;git clone&lt;/code&gt; を模倣しますが、選択したブランチのみを追跡します</target>
        </trans-unit>
        <trans-unit id="4a694f013e1a15bee19331c0c7b9e3ce34840db9" translate="yes" xml:space="preserve">
          <source>Imitate a CVS server. See &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver[1]&lt;/a&gt;.</source>
          <target state="translated">CVSサーバーを模倣します。&lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver [1]を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="81ebe12aa11cc123fdb7f8c88133ffaff6347b23" translate="yes" xml:space="preserve">
          <source>Implementation details</source>
          <target state="translated">実施内容</target>
        </trans-unit>
        <trans-unit id="f1c03dca591efe03ac168cd03c30c9d29e88acc3" translate="yes" xml:space="preserve">
          <source>Import Now, Repack Later</source>
          <target state="translated">今すぐインポートして、後でリパック</target>
        </trans-unit>
        <trans-unit id="b3e1462f677f3a661ca64753ac202708178b3a16" translate="yes" xml:space="preserve">
          <source>Import a GNU Arch repository into Git</source>
          <target state="translated">GNU Arch リポジトリを Git にインポート</target>
        </trans-unit>
        <trans-unit id="502aadd2b2c2382144812aea24a52e335147d4a4" translate="yes" xml:space="preserve">
          <source>Import all changes from both named depot paths into a single repository. Only files below these directories are included. There is not a subdirectory in Git for each &quot;proj1&quot; and &quot;proj2&quot;. You must use the &lt;code&gt;--destination&lt;/code&gt; option when specifying more than one depot path. The revision specifier must be specified identically on each depot path. If there are files in the depot paths with the same name, the path with the most recently updated version of the file is the one that appears in Git.</source>
          <target state="translated">両方の名前付きデポパスからすべての変更を単一のリポジトリにインポートします。これらのディレクトリの下のファイルのみが含まれます。 Gitには、「proj1」と「proj2」のサブディレクトリはありません。複数の &lt;code&gt;--destination&lt;/code&gt; 指定する場合は、-destinationオプションを使用する必要があります。リビジョン指定子は、各デポパスで同じように指定する必要があります。同じ名前のファイルがデポパスにある場合、ファイルの最新バージョンが含まれるパスがGitに表示されます。</target>
        </trans-unit>
        <trans-unit id="90051e560d673faccfb0bfe61644ca104b05b719" translate="yes" xml:space="preserve">
          <source>Import all commits, including recent ones. cvsimport by default skips commits that have a timestamp less than 10 minutes ago.</source>
          <target state="translated">cvsimport はデフォルトでは、タイムスタンプが 10 分前以下のコミットをスキップします。</target>
        </trans-unit>
        <trans-unit id="3ffbc41d8e969bcf6a3014a353f6e7a2bfd3e3ba" translate="yes" xml:space="preserve">
          <source>Import at most &lt;code&gt;n&lt;/code&gt; changes, rather than the entire range of changes included in the given revision specifier. A typical usage would be use &lt;code&gt;@all&lt;/code&gt; as the revision specifier, but then to use &lt;code&gt;--max-changes 1000&lt;/code&gt; to import only the last 1000 revisions rather than the entire revision history.</source>
          <target state="translated">特定のリビジョン指定子に含まれる変更の全範囲ではなく、最大 &lt;code&gt;n&lt;/code&gt; 個の変更をインポートします。典型的な使用法は、リビジョン指定子として &lt;code&gt;@all&lt;/code&gt; を使用することですが、-- &lt;code&gt;--max-changes 1000&lt;/code&gt; を使用して、リビジョン履歴全体ではなく、最新の1000リビジョンのみをインポートします。</target>
        </trans-unit>
        <trans-unit id="a203d27ce8c09d6ab5f978bc976ed19c7da8bd29" translate="yes" xml:space="preserve">
          <source>Import changes into &amp;lt;ref&amp;gt; instead of refs/remotes/p4/master. If &amp;lt;ref&amp;gt; starts with refs/, it is used as is. Otherwise, if it does not start with p4/, that prefix is added.</source>
          <target state="translated">変更をrefs / remotes / p4 / masterではなく&amp;lt;ref&amp;gt;にインポートします。&amp;lt;ref&amp;gt;がrefs /で始まる場合は、そのまま使用されます。それ以外の場合で、p4 /で始まらない場合は、その接頭辞が追加されます。</target>
        </trans-unit>
        <trans-unit id="3446130415616c26cfbd9b0cb3b27c636fdfb1f4" translate="yes" xml:space="preserve">
          <source>Import exactly the p4 change numbers listed in &lt;code&gt;file&lt;/code&gt;, one per line. Normally, &lt;code&gt;git p4&lt;/code&gt; inspects the current p4 repository state and detects the changes it should import.</source>
          <target state="translated">&lt;code&gt;file&lt;/code&gt; にリストされているp4変更番号を1行に1つ正確にインポートします。通常、 &lt;code&gt;git p4&lt;/code&gt; は現在のp4リポジトリの状態を検査し、インポートする必要のある変更を検出します。</target>
        </trans-unit>
        <trans-unit id="051514630860e82d8e6dfeb8000cb04203f0530f" translate="yes" xml:space="preserve">
          <source>Import from and submit to Perforce repositories</source>
          <target state="translated">Perforce リポジトリからのインポートと送信</target>
        </trans-unit>
        <trans-unit id="bc1da86269dd0fa043570d9e0331c263ee1c8e9b" translate="yes" xml:space="preserve">
          <source>Import labels from p4 into Git.</source>
          <target state="translated">p4のラベルをGitにインポートします。</target>
        </trans-unit>
        <trans-unit id="01c4fe3eff92a8abc6c7acba932cff943343d8ce" translate="yes" xml:space="preserve">
          <source>Import one commit for each change in the history of that depot path.</source>
          <target state="translated">そのデポパスの履歴にある変更ごとに一つのコミットをインポートします。</target>
        </trans-unit>
        <trans-unit id="5fa6a825ca52ecc53990e4e3e6add862904fa4f4" translate="yes" xml:space="preserve">
          <source>Import one commit with all files in the &lt;code&gt;#head&lt;/code&gt; change under that tree.</source>
          <target state="translated">そのツリーの下の &lt;code&gt;#head&lt;/code&gt; 変更内のすべてのファイルを含む1つのコミットをインポートします。</target>
        </trans-unit>
        <trans-unit id="1a475e0c7f94606844ba9fa0d34742cd54c3d13c" translate="yes" xml:space="preserve">
          <source>Import only changes 1 through 6.</source>
          <target state="translated">インポートは1から6までの変更のみです。</target>
        </trans-unit>
        <trans-unit id="e9848e9219c243527c0682e352e98364329421b1" translate="yes" xml:space="preserve">
          <source>Import p4 labels into git, as per --import-labels.</source>
          <target state="translated">p4 のラベルを --import-labels のように git にインポートします。</target>
        </trans-unit>
        <trans-unit id="34d234038bf4e799d075c2933026167918f64329" translate="yes" xml:space="preserve">
          <source>Import p4 labels.</source>
          <target state="translated">p4のラベルをインポートします。</target>
        </trans-unit>
        <trans-unit id="2f4ea105dee6a1ad94ce6623f490fbb875775ee0" translate="yes" xml:space="preserve">
          <source>Import-only: don&amp;rsquo;t perform a checkout after importing. This option ensures the working directory and index remain untouched and will not create them if they do not exist.</source>
          <target state="translated">インポートのみ：インポート後にチェックアウトを実行しません。このオプションにより、作業ディレクトリとインデックスが変更されずに残り、存在しない場合は作成されません。</target>
        </trans-unit>
        <trans-unit id="4b6d6a30150a506f9b79caf45da5aecb76b0018e" translate="yes" xml:space="preserve">
          <source>Important</source>
          <target state="translated">Important</target>
        </trans-unit>
        <trans-unit id="a64c4afd3bd1cef7955450469801cfbdf061341b" translate="yes" xml:space="preserve">
          <source>Important note! If you have any local changes in these branches, then this merge will create a commit object in the history (with no local changes Git will simply do a &quot;fast-forward&quot; merge). Many people dislike the &quot;noise&quot; that this creates in the Linux history, so you should avoid doing this capriciously in the &lt;code&gt;release&lt;/code&gt; branch, as these noisy commits will become part of the permanent history when you ask Linus to pull from the release branch.</source>
          <target state="translated">重要な注意点！これらのブランチにローカルの変更がある場合、このマージは履歴にコミットオブジェクトを作成します（Gitはローカルでの変更がないため、単に「早送り」マージを実行します）。これがLinuxの歴史の中で生み出す「ノイズ」を嫌う人が多いので、Linusにリリースブランチからプルするように依頼すると、これらのノイズの多いコミットが永続的な履歴の一部になるため、 &lt;code&gt;release&lt;/code&gt; ブランチで気まぐれにこれを行うことは避けてください。</target>
        </trans-unit>
        <trans-unit id="a87b614cdbaa5301ddda5b9a1cda5205ccdf1bbc" translate="yes" xml:space="preserve">
          <source>Importing a cvs archive</source>
          <target state="translated">cvs アーカイブのインポート</target>
        </trans-unit>
        <trans-unit id="3e30801aed656938780d8d09defb05967bf70053" translate="yes" xml:space="preserve">
          <source>Importing a new project</source>
          <target state="translated">新しいプロジェクトのインポート</target>
        </trans-unit>
        <trans-unit id="7d3eb76e15d3e80f60fde0cbe9f4a9a66f1cc724" translate="yes" xml:space="preserve">
          <source>Importing or exporting patches:</source>
          <target state="translated">パッチのインポートまたはエクスポート</target>
        </trans-unit>
        <trans-unit id="8c866a3a4bff8b0052306000b7abfebb33a38b38" translate="yes" xml:space="preserve">
          <source>Importing patches to a project</source>
          <target state="translated">パッチをプロジェクトにインポートする</target>
        </trans-unit>
        <trans-unit id="19051f1cf9bd70907beeecdf5147851f44537c38" translate="yes" xml:space="preserve">
          <source>Importing these tags as-is in Git is impossible without making at least one commit which &amp;ldquo;fixes up&amp;rdquo; the files to match the content of the tag. Use fast-import&amp;rsquo;s &lt;code&gt;reset&lt;/code&gt; command to reset a dummy branch outside of your normal branch space to the base commit for the tag, then commit one or more file fixup commits, and finally tag the dummy branch.</source>
          <target state="translated">これらのタグをそのままGitにインポートすることは、タグのコンテンツと一致するようにファイルを「修正」する少なくとも1つのコミットを行わなければ不可能です。fast-importの &lt;code&gt;reset&lt;/code&gt; コマンドを使用して、通常のブランチ空間の外のダミーブランチをタグのベースコミットにリセットし、1つ以上のファイル修正コミットをコミットして、最後にダミーブランチにタグを付けます。</target>
        </trans-unit>
        <trans-unit id="ffa5110d0a0de3d5244ac22023669387afe15c4d" translate="yes" xml:space="preserve">
          <source>Imports a CVS repository into Git. It will either create a new repository, or incrementally import into an existing one.</source>
          <target state="translated">CVS リポジトリを Git にインポートします。新しいリポジトリを作成するか、既存のリポジトリにインポートします。</target>
        </trans-unit>
        <trans-unit id="189a5fab4172fe96418112b3abf1f29736c5a78f" translate="yes" xml:space="preserve">
          <source>Imports a project from one or more GNU Arch repositories. It will follow branches and repositories within the namespaces defined by the &amp;lt;archive/branch&amp;gt; parameters supplied. If it cannot find the remote branch a merge comes from it will just import it as a regular commit. If it can find it, it will mark it as a merge whenever possible (see discussion below).</source>
          <target state="translated">1つ以上のGNU Archリポジトリからプロジェクトをインポートします。提供された&amp;lt;archive / branch&amp;gt;パラメータで定義された名前空間内のブランチとリポジトリに従います。リモートブランチが見つからない場合、そこからマージが行われ、通常のコミットとしてインポートされます。見つかった場合は、可能な限りマージとしてマークします（以下の説明を参照）。</target>
        </trans-unit>
        <trans-unit id="0e7ba011d44c49f30a4b102d2d50cfa93397d28b" translate="yes" xml:space="preserve">
          <source>Imports the full contents of the head revision from the given p4 depot path into a single commit in the Git branch &lt;code&gt;refs/remotes/p4/master&lt;/code&gt;.</source>
          <target state="translated">指定されたp4デポパスからヘッドリビジョンの完全な内容をGitブランチ &lt;code&gt;refs/remotes/p4/master&lt;/code&gt; の単一のコミットにインポートします。</target>
        </trans-unit>
        <trans-unit id="bc75793944c924c387fa08f2263917093a9e6ee9" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;#def_SCM&quot;&gt;SCM&lt;/a&gt; jargon, &quot;cherry pick&quot; means to choose a subset of changes out of a series of changes (typically commits) and record them as a new series of changes on top of a different codebase. In Git, this is performed by the &quot;git cherry-pick&quot; command to extract the change introduced by an existing &lt;a href=&quot;#def_commit&quot;&gt;commit&lt;/a&gt; and to record it based on the tip of the current &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt; as a new commit.</source>
          <target state="translated">では&lt;a href=&quot;#def_SCM&quot;&gt;SCM&lt;/a&gt;専門用語、（一般的にコミット）一連の変更のうち、変更のサブセットを選択するための手段を「チェリーピック」と異なるコードベースの上に変化の新シリーズとしてそれらを記録します。Gitでは、これは「git cherry-pick」コマンドによって&lt;a href=&quot;#def_commit&quot;&gt;実行&lt;/a&gt;され、既存のコミットによって導入された変更を抽出し、現在の&lt;a href=&quot;#def_branch&quot;&gt;ブランチの&lt;/a&gt;先端に基づいて新しいコミットとして記録します。</target>
        </trans-unit>
        <trans-unit id="5a7b7bab83d67b10ed8bbe7275df22f645616a7a" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;--parseopt&lt;/code&gt; mode, &lt;code&gt;git rev-parse&lt;/code&gt; helps massaging options to bring to shell scripts the same facilities C builtins have. It works as an option normalizer (e.g. splits single switches aggregate values), a bit like &lt;code&gt;getopt(1)&lt;/code&gt; does.</source>
          <target state="translated">で &lt;code&gt;--parseopt&lt;/code&gt; モード、 &lt;code&gt;git rev-parse&lt;/code&gt; スクリプトにCの組み込みコマンドが持っている同じ施設をシェルに持って来るにオプションをマッサージするのに役立ちます。これは、 &lt;code&gt;getopt(1)&lt;/code&gt; のように、オプションノーマライザとして機能します（たとえば、単一のスイッチの集約値を分割します）。</target>
        </trans-unit>
        <trans-unit id="a61808962b5b6bb1a272b1dd2c4e90c87c42eb63" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;--sq-quote&lt;/code&gt; mode, &lt;code&gt;git rev-parse&lt;/code&gt; echoes on the standard output a single line suitable for &lt;code&gt;sh(1)&lt;/code&gt;&lt;code&gt;eval&lt;/code&gt;. This line is made by normalizing the arguments following &lt;code&gt;--sq-quote&lt;/code&gt;. Nothing other than quoting the arguments is done.</source>
          <target state="translated">で &lt;code&gt;--sq-quote&lt;/code&gt; モード、 &lt;code&gt;git rev-parse&lt;/code&gt; 標準出力に適した単一のライン上のエコー &lt;code&gt;sh(1)&lt;/code&gt; &lt;code&gt;eval&lt;/code&gt; 。この行は、 &lt;code&gt;--sq-quote&lt;/code&gt; に続く引数を正規化することによって作成されます。引数を引用する以外は何も行われません。</target>
        </trans-unit>
        <trans-unit id="02025b63af6480e186ac72d3a5a618d5536d1d9c" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;--stdin&lt;/code&gt; mode, take lines in the format</source>
          <target state="translated">で &lt;code&gt;--stdin&lt;/code&gt; モード、形式の行を取ります</target>
        </trans-unit>
        <trans-unit id="46fb44ff2c3ae3502717728ebf0f15532f206b66" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;foo&lt;/code&gt; contains just &amp;ldquo;foo&amp;rdquo;.</source>
          <target state="translated">では &lt;code&gt;A&lt;/code&gt; 、 &lt;code&gt;foo&lt;/code&gt; が単に「foo」を含んでいます。</target>
        </trans-unit>
        <trans-unit id="0e95077ff33e18325bb9215a9cc5764269fc90de" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;dbDriver&lt;/code&gt; and &lt;code&gt;dbUser&lt;/code&gt; you can use the following variables:</source>
          <target state="translated">で &lt;code&gt;dbDriver&lt;/code&gt; と &lt;code&gt;dbUser&lt;/code&gt; の次の変数を使用することができます。</target>
        </trans-unit>
        <trans-unit id="6c351c60eb0e6d6c6a7b2ff86bb73c9f63bc0dc3" translate="yes" xml:space="preserve">
          <source>In Git 1.7.0 or later, to cancel a conflicting merge, use &lt;code&gt;git reset --merge&lt;/code&gt;. &lt;strong&gt;Warning&lt;/strong&gt;: In older versions of Git, running &lt;code&gt;git pull&lt;/code&gt; with uncommitted changes is discouraged: while possible, it leaves you in a state that may be hard to back out of in the case of a conflict.</source>
          <target state="translated">Git 1.7.0以降では、競合するマージをキャンセルするには、 &lt;code&gt;git reset --merge&lt;/code&gt; を使用します。&lt;strong&gt;警告&lt;/strong&gt;：古いバージョンのGitでは、コミットされていない変更を加えて &lt;code&gt;git pull&lt;/code&gt; を実行することはお勧めしません。可能であれば、競合が発生した場合に元に戻すのが難しい状態になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="e5fbbb479d61fa23b446f30021dbc9109422a0ad" translate="yes" xml:space="preserve">
          <source>In Git like in many other Version Control Systems (VCS), the different states of the data that is managed by the system are called commits. And, as VCS are mostly used to manage software source code, sometimes &quot;interesting&quot; changes of behavior in the software are introduced in some commits.</source>
          <target state="translated">Git では、他の多くのバージョン管理システム (VCS)と同様に、システムによって管理されているデータのさまざまな状態をコミットと呼びます。そして、VCSはほとんどがソフトウェアのソースコードを管理するために使われているので、時にはソフトウェアの「興味深い」動作の変化がいくつかのコミットで紹介されることがあります。</target>
        </trans-unit>
        <trans-unit id="8b9196b57e8598c90aa9a79e64e11940ec4bed09" translate="yes" xml:space="preserve">
          <source>In Git&amp;rsquo;s context, synonym for &lt;a href=&quot;#def_object_name&quot;&gt;object name&lt;/a&gt;.</source>
          <target state="translated">Gitのコンテキストでは、&lt;a href=&quot;#def_object_name&quot;&gt;オブジェクト名の&lt;/a&gt;同義語。</target>
        </trans-unit>
        <trans-unit id="644d8f376b3ac284860f081b25e96334d4db2911" translate="yes" xml:space="preserve">
          <source>In Git, there are two kinds of tags, a &quot;light&quot; one, and an &quot;annotated tag&quot;.</source>
          <target state="translated">Gitでは、「軽い」タグと「注釈付きタグ」の2種類のタグがあります。</target>
        </trans-unit>
        <trans-unit id="1e877f57bcce771b4a2551649d22c402a8ae8603" translate="yes" xml:space="preserve">
          <source>In SVN, it is possible (though discouraged) to commit changes to a tag (because a tag is just a directory copy, thus technically the same as a branch). When cloning an SVN repository, &lt;code&gt;git svn&lt;/code&gt; cannot know if such a commit to a tag will happen in the future. Thus it acts conservatively and imports all SVN tags as branches, prefixing the tag name with &lt;code&gt;tags/&lt;/code&gt;.</source>
          <target state="translated">SVNでは、タグへの変更をコミットすることは可能です（推奨されません）（タグは単なるディレクトリコピーなので、技術的にはブランチと同じであるため）。SVNリポジトリのクローンを作成するとき、 &lt;code&gt;git svn&lt;/code&gt; は、タグへのそのようなコミットが将来発生するかどうかを知ることができません。したがって、保守的に機能し、すべてのSVNタグをブランチとしてインポートし、タグ名の前に &lt;code&gt;tags/&lt;/code&gt; を付けます。</target>
        </trans-unit>
        <trans-unit id="c215580302a5f52c2e27d45d0d7c1d84a4eccdbe" translate="yes" xml:space="preserve">
          <source>In Thunderbird 2: Edit..Preferences..Composition, wrap plain text messages at 0</source>
          <target state="translated">Thunderbird 2:編集...環境設定...構図 で、プレーンテキストメッセージを 0 で折り返す</target>
        </trans-unit>
        <trans-unit id="f440374532f0b3d43494a1b042e56f8d4bce5f5d" translate="yes" xml:space="preserve">
          <source>In Thunderbird 3: Edit..Preferences..Advanced..Config Editor. Search for &quot;mail.wrap_long_lines&quot;. Toggle it to make sure it is set to &lt;code&gt;false&lt;/code&gt;. Also, search for &quot;mailnews.wraplength&quot; and set the value to 0.</source>
          <target state="translated">Thunderbird 3の場合：Edit..Preferences..Advanced..Config Editor。「mail.wrap_long_lines」を検索します。切り替えて、 &lt;code&gt;false&lt;/code&gt; に設定されていることを確認します。また、「mailnews.wraplength」を検索して、値を0に設定します。</target>
        </trans-unit>
        <trans-unit id="17583a69f7262368825714769d6089546a690b45" translate="yes" xml:space="preserve">
          <source>In a fast-forward update from A to B, the set of commits that the original commit A built on top of is a subset of the commits the new commit B builds on top of. Hence, it does not lose any history.</source>
          <target state="translated">A から B への早送り更新では、元のコミット A の上に構築されたコミットのセットは、新しいコミット B の上に構築されたコミットのサブセットになります。したがって、履歴を失うことはありません。</target>
        </trans-unit>
        <trans-unit id="3d5b5c31f19f75af08174ee7bc83bae8bb6f0e50" translate="yes" xml:space="preserve">
          <source>In a normal repository, this tends to work automatically. The objects are mostly reachable from the branches and tags, and that&amp;rsquo;s what clients fetch. Any deltas we find on the server are likely to be between objects the client has or will have.</source>
          <target state="translated">通常のリポジトリでは、これは自動的に機能する傾向があります。オブジェクトはほとんどブランチとタグから到達可能であり、それがクライアントがフェッチするものです。サーバー上で見つかったすべてのデルタは、クライアントが持っている、または持つ予定のオブジェクト間にある可能性があります。</target>
        </trans-unit>
        <trans-unit id="8fbcefe66dafd74525f6b8ab70d285c817dc5cf1" translate="yes" xml:space="preserve">
          <source>In a repository using the traditional SHA-1, pack checksums, index checksums, and object IDs (object names) mentioned below are all computed using SHA-1. Similarly, in SHA-256 repositories, these values are computed using SHA-256.</source>
          <target state="translated">従来のSHA-1を使用したリポジトリでは、後述するパックチェックサム、インデックスチェックサム、オブジェクトID(オブジェクト名)はすべてSHA-1を使用して計算されています。同様に、SHA-256のリポジトリでは、これらの値はSHA-256で計算されます。</target>
        </trans-unit>
        <trans-unit id="566e8925a0c194716258bb9a397f522567172cf6" translate="yes" xml:space="preserve">
          <source>In a situation where topic consisted of three commits, and the maintainer applied two of them, the situation might look like:</source>
          <target state="translated">トピックが3つのコミットで構成されていて、メンテナがそのうちの2つを適用した場合、状況は次のようになるかもしれません。</target>
        </trans-unit>
        <trans-unit id="ee8b5fc930f29435d4aa076d7196ceac4e277fb2" translate="yes" xml:space="preserve">
          <source>In a workflow employing relatively long lived topic branches, the developer sometimes needs to resolve the same conflicts over and over again until the topic branches are done (either merged to the &quot;release&quot; branch, or sent out and accepted upstream).</source>
          <target state="translated">比較的長持ちするトピックブランチを使用するワークフローでは、開発者はトピックブランチが完了するまで、同じ競合を何度も解決する必要があることがあります (「リリース」ブランチにマージされるか、上流に送信して受け入れられるかのいずれか)。</target>
        </trans-unit>
        <trans-unit id="f7c91952cc20e93e498fb039cc3dfb4469b10f04" translate="yes" xml:space="preserve">
          <source>In addition there are a number of other widely deployed hosting, browsing and reviewing solutions such as:</source>
          <target state="translated">その他にも、ホスティング、ブラウジング、レビューなどのソリューションが広く展開されています。</target>
        </trans-unit>
        <trans-unit id="666628046a18a0e7af967b1de7c1a7d7baa813ae" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;--full-index&lt;/code&gt;, output a binary diff that can be applied with &lt;code&gt;git-apply&lt;/code&gt;. Implies &lt;code&gt;--patch&lt;/code&gt;.</source>
          <target state="translated">加え &lt;code&gt;--full-index&lt;/code&gt; 、出力に適用することができるバイナリ差分 &lt;code&gt;git-apply&lt;/code&gt; 。意味 &lt;code&gt;--patch&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3f6c767f6bc5922d93e508ae1661b26c77720a8f" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;-M&lt;/code&gt;, detect lines moved or copied from other files that were modified in the same commit. This is useful when you reorganize your program and move code around across files. When this option is given twice, the command additionally looks for copies from other files in the commit that creates the file. When this option is given three times, the command additionally looks for copies from other files in any commit.</source>
          <target state="translated">&lt;code&gt;-M&lt;/code&gt; に加えて、同じコミットで変更された他のファイルから移動またはコピーされた行を検出します。これは、プログラムを再編成して、ファイル間でコードを移動する場合に役立ちます。このオプションを2回指定すると、コマンドはさらに、ファイルを作成するコミットで他のファイルからのコピーを探します。このオプションが3回指定されると、コマンドはさらに、他のファイルからのコピーをコミットで探します。</target>
        </trans-unit>
        <trans-unit id="1888d5f31940dfed593ca4ff2d62ba84db0ce760" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;.gitattributes&lt;/code&gt; (per-directory) and &lt;code&gt;.git/info/attributes&lt;/code&gt;, Git looks into this file for attributes (see &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt;). Path expansions are made the same way as for &lt;code&gt;core.excludesFile&lt;/code&gt;. Its default value is &lt;code&gt;$XDG_CONFIG_HOME/git/attributes&lt;/code&gt;. If &lt;code&gt;$XDG_CONFIG_HOME&lt;/code&gt; is either not set or empty, &lt;code&gt;$HOME/.config/git/attributes&lt;/code&gt; is used instead.</source>
          <target state="translated">加えて &lt;code&gt;.gitattributes&lt;/code&gt; （ディレクトリごと）と &lt;code&gt;.git/info/attributes&lt;/code&gt; 、Gitは（参照属性について、このファイルに見えます&lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5] &lt;/a&gt;）。パスの拡張は、 &lt;code&gt;core.excludesFile&lt;/code&gt; の場合と同じ方法で行われます。そのデフォルト値は &lt;code&gt;$XDG_CONFIG_HOME/git/attributes&lt;/code&gt; 。場合は &lt;code&gt;$XDG_CONFIG_HOME&lt;/code&gt; セットまたは空にされていない、 &lt;code&gt;$HOME/.config/git/attributes&lt;/code&gt; 代わりに使用されます。</target>
        </trans-unit>
        <trans-unit id="a80ff33db6a243344cb7df3dd9b8d8d41e916e5f" translate="yes" xml:space="preserve">
          <source>In addition to HEAD, there are several other special names for commits:</source>
          <target state="translated">HEAD の他にも、commits にはいくつかの特別な名前があります。</target>
        </trans-unit>
        <trans-unit id="3d952784176d6003ec5b2f9f790384bd9b8c8247" translate="yes" xml:space="preserve">
          <source>In addition to being the staging area for new commits, the index file is also populated from the object database when checking out a branch, and is used to hold the trees involved in a merge operation. See &lt;a href=&quot;gitcore-tutorial&quot;&gt;gitcore-tutorial[7]&lt;/a&gt; and the relevant man pages for details.</source>
          <target state="translated">インデックスファイルは、新しいコミットのステージング領域であることに加えて、ブランチをチェックアウトするときにオブジェクトデータベースから読み込まれ、マージ操作に関係するツリーを保持するために使用されます。詳細については、&lt;a href=&quot;gitcore-tutorial&quot;&gt;gitcore-tutorial [7]&lt;/a&gt;および関連するmanページを参照してください。</target>
        </trans-unit>
        <trans-unit id="e26ec25b7f02c15aecd179e2dad4bd1f6afe8d5c" translate="yes" xml:space="preserve">
          <source>In addition to branch names, populate the log message with at most the specified number of one-line descriptions from the actual commits that are being merged. Defaults to false, and true is a synonym for 20.</source>
          <target state="translated">ブランチ名に加えて、マージされる実際のコミットから最大でも指定した数の 1 行の説明をログメッセージに入力します。デフォルトは false で、true は 20 と同義語です。</target>
        </trans-unit>
        <trans-unit id="c5e07d7771d3e15091a04a68ed9a697dc979376c" translate="yes" xml:space="preserve">
          <source>In addition to branch names, populate the log message with one-line descriptions from at most &amp;lt;n&amp;gt; actual commits that are being merged. See also &lt;a href=&quot;git-fmt-merge-msg&quot;&gt;git-fmt-merge-msg[1]&lt;/a&gt;.</source>
          <target state="translated">ブランチ名に加えて、マージされる最大&amp;lt;n&amp;gt;個の実際のコミットからの1行の説明をログメッセージに入力します。&lt;a href=&quot;git-fmt-merge-msg&quot;&gt;git-fmt-merge-msg [1]&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="53e8184a4fded8ffd5d3887baaffe37015550f76" translate="yes" xml:space="preserve">
          <source>In addition to branch names, populate the log message with one-line descriptions from the actual commits that are being merged. At most &amp;lt;n&amp;gt; commits from each merge parent will be used (20 if &amp;lt;n&amp;gt; is omitted). This overrides the &lt;code&gt;merge.log&lt;/code&gt; configuration variable.</source>
          <target state="translated">ブランチ名に加えて、マージされる実際のコミットからの1行の説明をログメッセージに入力します。各マージ親からの最大&amp;lt;n&amp;gt;のコミットが使用されます（&amp;lt;n&amp;gt;が省略されている場合は20）。これは、 &lt;code&gt;merge.log&lt;/code&gt; 構成変数をオーバーライドします。</target>
        </trans-unit>
        <trans-unit id="6235bcb46867554949f149e203ea63eff52ea516" translate="yes" xml:space="preserve">
          <source>In addition to branch names, populate the log message with the branch description text associated with them. Defaults to false.</source>
          <target state="translated">ブランチ名に加えて、それらに関連付けられたブランチの説明テキストをログメッセージに入力します。デフォルトは false です。</target>
        </trans-unit>
        <trans-unit id="f62e3d2f843321847fb42ac94f40312c54d52ccf" translate="yes" xml:space="preserve">
          <source>In addition to labelling blobs and commits with mark ids, also label tags. This is useful in conjunction with &lt;code&gt;--export-marks&lt;/code&gt; and &lt;code&gt;--import-marks&lt;/code&gt;, and is also useful (and necessary) for exporting of nested tags. It does not hurt other cases and would be the default, but many fast-import frontends are not prepared to accept tags with mark identifiers.</source>
          <target state="translated">マークIDを使用してBLOBとコミットにラベルを付けることに加えて、タグにもラベルを付けます。これは、-- &lt;code&gt;--import-marks&lt;/code&gt; &lt;code&gt;--export-marks&lt;/code&gt; および--import -marksと組み合わせて使用​​すると便利です。また、ネストされたタグのエクスポートにも使用できます（必要です）。他のケースを害することはなく、デフォルトになりますが、多くの高速インポートフロントエンドは、マーク識別子を持つタグを受け入れる準備ができていません。</target>
        </trans-unit>
        <trans-unit id="22782295e6ea8ee2d620246684c55c016d61141f" translate="yes" xml:space="preserve">
          <source>In addition to objects reachable from any of our references, keep objects reachable from listed &amp;lt;head&amp;gt;s.</source>
          <target state="translated">参照から到達可能なオブジェクトに加えて、リストされた&amp;lt;head&amp;gt;から到達可能なオブジェクトを保持します。</target>
        </trans-unit>
        <trans-unit id="99c28f63ba36fb0fcaa38897708f95d9a693e369" translate="yes" xml:space="preserve">
          <source>In addition to saving you keystrokes, &lt;code&gt;git pull&lt;/code&gt; also helps you by producing a default commit message documenting the branch and repository that you pulled from.</source>
          <target state="translated">キーストロークを保存するだけでなく、 &lt;code&gt;git pull&lt;/code&gt; は、プルしたブランチとリポジトリを文書化するデフォルトのコミットメッセージを生成することによっても役立ちます。</target>
        </trans-unit>
        <trans-unit id="7129d0d8ea665296c3d9391d29a173f1ab2fc5f1" translate="yes" xml:space="preserve">
          <source>In addition to searching in the tracked files in the working tree, search also in untracked files.</source>
          <target state="translated">作業ツリー内の追跡されたファイルの検索に加えて、追跡されていないファイルも検索できます。</target>
        </trans-unit>
        <trans-unit id="d5b7aa3ae2fa07bc2a7838db49f832f9fd332a95" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;=======&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; markers, it uses another &lt;code&gt;|||||||&lt;/code&gt; marker that is followed by the original text. You can tell that the original just stated a fact, and your side simply gave in to that statement and gave up, while the other side tried to have a more positive attitude. You can sometimes come up with a better resolution by viewing the original.</source>
          <target state="translated">加えて &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; 、 &lt;code&gt;=======&lt;/code&gt; 、そして &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; マーカー、それは別のものを使用しています &lt;code&gt;|||||||&lt;/code&gt; 元のテキストが後に続くマーカー。オリジナルは事実を述べただけであり、あなたの側は単にその声明に屈して断念した一方、反対側はより前向きな態度をとろうとしたことがわかります。オリジナルを表示すると、解像度が向上する場合があります。</target>
        </trans-unit>
        <trans-unit id="3a9ee73184ef3bce8e3d7aa50aca9c03ee962a97" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; listed on the command line, read them from the standard input. If a &lt;code&gt;--&lt;/code&gt; separator is seen, stop reading commits and start reading paths to limit the result.</source>
          <target state="translated">コマンドラインにリストされている &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; に加えて、それらを標準入力から読み取ります。 &lt;code&gt;--&lt;/code&gt; セパレータが表示される場合は、コミットの読み取りを停止し、パスの読み取りを開始して結果を制限します。</target>
        </trans-unit>
        <trans-unit id="e57f382f37af963780a48b9b24f281a677f73e3f" translate="yes" xml:space="preserve">
          <source>In addition to the above settings, you can change whether TREESAME affects inclusion:</source>
          <target state="translated">上記の設定に加えて、TREESAMEがインクルージョンに影響を与えるかどうかを変更することができます。</target>
        </trans-unit>
        <trans-unit id="15a1839e21183f6c87dd1989058c966575a3a5b3" translate="yes" xml:space="preserve">
          <source>In addition to the above two patterns, we also expect that all files in the root directory are included. If a recursive pattern is added, then all leading directories are added as parent patterns.</source>
          <target state="translated">上記の2つのパターンに加えて、ルートディレクトリ内のすべてのファイルが含まれていることを想定しています。再帰パターンが追加された場合、すべてのリーディングディレクトリが親パターンとして追加されます。</target>
        </trans-unit>
        <trans-unit id="5cdd7d140b9026d9dc5fc6d397fdc9a74057bb4e" translate="yes" xml:space="preserve">
          <source>In addition to the above, for commit and tag objects, the header field names (&lt;code&gt;tree&lt;/code&gt;, &lt;code&gt;parent&lt;/code&gt;, &lt;code&gt;object&lt;/code&gt;, &lt;code&gt;type&lt;/code&gt;, and &lt;code&gt;tag&lt;/code&gt;) can be used to specify the value in the header field.</source>
          <target state="translated">上記に加えて、コミットおよびタグオブジェクトの場合、ヘッダーフィールド名（ &lt;code&gt;tree&lt;/code&gt; 、 &lt;code&gt;parent&lt;/code&gt; 、 &lt;code&gt;object&lt;/code&gt; 、 &lt;code&gt;type&lt;/code&gt; 、および &lt;code&gt;tag&lt;/code&gt; ）を使用して、ヘッダーフィールドの値を指定できます。</target>
        </trans-unit>
        <trans-unit id="0cd22d754613826bc7df21407a063908e095a28b" translate="yes" xml:space="preserve">
          <source>In addition to the above, for commit and tag objects, the header field names (&lt;code&gt;tree&lt;/code&gt;, &lt;code&gt;parent&lt;/code&gt;, &lt;code&gt;object&lt;/code&gt;, &lt;code&gt;type&lt;/code&gt;, and &lt;code&gt;tag&lt;/code&gt;) can be used to specify the value in the header field. Fields &lt;code&gt;tree&lt;/code&gt; and &lt;code&gt;parent&lt;/code&gt; can also be used with modifier &lt;code&gt;:short&lt;/code&gt; and &lt;code&gt;:short=&amp;lt;length&amp;gt;&lt;/code&gt; just like &lt;code&gt;objectname&lt;/code&gt;.</source>
          <target state="translated">上記に加えて、commitおよびtagオブジェクトの場合、ヘッダーフィールド名（ &lt;code&gt;tree&lt;/code&gt; 、 &lt;code&gt;parent&lt;/code&gt; 、 &lt;code&gt;object&lt;/code&gt; 、 &lt;code&gt;type&lt;/code&gt; 、および &lt;code&gt;tag&lt;/code&gt; ）を使用して、ヘッダーフィールドの値を指定できます。フィールド &lt;code&gt;tree&lt;/code&gt; と &lt;code&gt;parent&lt;/code&gt; は、 &lt;code&gt;objectname&lt;/code&gt; と同様に、修飾子 &lt;code&gt;:short&lt;/code&gt; および &lt;code&gt;:short=&amp;lt;length&amp;gt;&lt;/code&gt; とともに使用することもできます。</target>
        </trans-unit>
        <trans-unit id="3da373db26873c5d2b59dd68ca741f2f25c73567" translate="yes" xml:space="preserve">
          <source>In addition to the commits shown in the default history, show each merge commit that is not TREESAME to its first parent but is TREESAME to a later parent.</source>
          <target state="translated">デフォルトの履歴に表示されるコミットに加えて、最初の親に対して TREESAME ではなく、後の親に対して TREESAME であるマージコミットを表示します。</target>
        </trans-unit>
        <trans-unit id="4a3a21fa25ba67eb3d7f9da7f4344fe1b071989c" translate="yes" xml:space="preserve">
          <source>In addition to the names of files that have been changed, also show the textual changes that are staged to be committed (i.e., like the output of &lt;code&gt;git diff --cached&lt;/code&gt;). If &lt;code&gt;-v&lt;/code&gt; is specified twice, then also show the changes in the working tree that have not yet been staged (i.e., like the output of &lt;code&gt;git diff&lt;/code&gt;).</source>
          <target state="translated">変更されたファイルの名前に加えて、コミットするためにステージングされたテキストによる変更も表示します（つまり、 &lt;code&gt;git diff --cached&lt;/code&gt; の出力のように）。 &lt;code&gt;-v&lt;/code&gt; が2回指定されている場合は、まだステージングされていない（つまり、 &lt;code&gt;git diff&lt;/code&gt; の出力のような）作業ツリーの変更も表示します。</target>
        </trans-unit>
        <trans-unit id="9d2884340103002807461c187c73c074fbbd3657" translate="yes" xml:space="preserve">
          <source>In addition to the object pointed by it, show the underlying ref pointed by it when showing a symbolic ref. Currently, upload-pack only shows the symref HEAD, so it will be the only one shown by ls-remote.</source>
          <target state="translated">シンボリック参照を表示する際に、そのオブジェクトが指し示すオブジェクトに加えて、そのオブジェクトが指し示す下の参照を表示します。現在、upload-pack はシンボリック参照の HEAD のみを表示しているので、ls-remote で表示されるのはこれだけになります。</target>
        </trans-unit>
        <trans-unit id="6c7a07603f44cd9719a4b680d9f7256b9473029e" translate="yes" xml:space="preserve">
          <source>In addition to the patches, generate a cover letter file containing the branch description, shortlog and the overall diffstat. You can fill in a description in the file before sending it out.</source>
          <target state="translated">パッチに加えて、ブランチの説明、ショートログ、全体のdiffstatを含むカバーレターファイルを生成します。ファイルに説明文を記入してから送信することができます。</target>
        </trans-unit>
        <trans-unit id="102ba20e10a0928862b597a4b85d8411aa7a16cb" translate="yes" xml:space="preserve">
          <source>In addition to the text-based messages available in &lt;code&gt;GIT_TRACE2&lt;/code&gt;, this setting writes a column-based format for understanding nesting regions. See &lt;code&gt;GIT_TRACE2&lt;/code&gt; for available trace output options and &lt;a href=&quot;api-trace2&quot;&gt;Trace2 documentation&lt;/a&gt; for full details.</source>
          <target state="translated">&lt;code&gt;GIT_TRACE2&lt;/code&gt; で利用可能なテキストベースのメッセージに加えて、この設定はネスト領域を理解するための列ベースのフォーマットを書き込みます。使用可能なトレース出力オプションについては &lt;code&gt;GIT_TRACE2&lt;/code&gt; を、詳細については&lt;a href=&quot;api-trace2&quot;&gt;Trace2のドキュメント&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="547bdce4dd37bfda9e1c54bdf493ad3c6de08ff9" translate="yes" xml:space="preserve">
          <source>In addition, any unrecognized string that has a &lt;code&gt;%&lt;/code&gt; in it is interpreted as if it has &lt;code&gt;tformat:&lt;/code&gt; in front of it. For example, these two are equivalent:</source>
          <target state="translated">さらに、 &lt;code&gt;%&lt;/code&gt; が含まれている認識されない文字列は、その前に &lt;code&gt;tformat:&lt;/code&gt; があるかのように解釈されます。たとえば、次の2つは同等です。</target>
        </trans-unit>
        <trans-unit id="bc74e38407c657e1d62a835de829f2a0637ff932" translate="yes" xml:space="preserve">
          <source>In addition, if the variable is set to &lt;code&gt;af_unix:[&amp;lt;socket_type&amp;gt;:]&amp;lt;absolute-pathname&amp;gt;&lt;/code&gt;, Git will try to open the path as a Unix Domain Socket. The socket type can be either &lt;code&gt;stream&lt;/code&gt; or &lt;code&gt;dgram&lt;/code&gt;.</source>
          <target state="translated">さらに、変数が &lt;code&gt;af_unix:[&amp;lt;socket_type&amp;gt;:]&amp;lt;absolute-pathname&amp;gt;&lt;/code&gt; に設定されている場合、GitはパスをUnixドメインソケットとして開こうとします。ソケットのタイプは、 &lt;code&gt;stream&lt;/code&gt; または &lt;code&gt;dgram&lt;/code&gt; のいずれかです。</target>
        </trans-unit>
        <trans-unit id="fdc73bece50193400c9954e5c33b0d5db46ea312" translate="yes" xml:space="preserve">
          <source>In addition, some Git commands (such as &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt; and &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;) can also take revision parameters which denote other objects than commits, e.g. blobs (&quot;files&quot;) or trees (&quot;directories of files&quot;).</source>
          <target state="translated">さらに、一部のGitコマンド（&lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt;や&lt;a href=&quot;git-push&quot;&gt;git-push [1]など&lt;/a&gt;）は、コミット以外のオブジェクトを示すリビジョンパラメーター（例：blob（「ファイル」）やツリー（「ファイルのディレクトリ」）も使用できます。 ）。</target>
        </trans-unit>
        <trans-unit id="9c0114752cc3965279675b92f9d509a7719a899c" translate="yes" xml:space="preserve">
          <source>In addition, the date part is accepted in the following formats: &lt;code&gt;YYYY.MM.DD&lt;/code&gt;, &lt;code&gt;MM/DD/YYYY&lt;/code&gt; and &lt;code&gt;DD.MM.YYYY&lt;/code&gt;.</source>
          <target state="translated">さらに、日付部分は、 &lt;code&gt;YYYY.MM.DD&lt;/code&gt; 、 &lt;code&gt;MM/DD/YYYY&lt;/code&gt; 、および &lt;code&gt;DD.MM.YYYY&lt;/code&gt; の形式で受け入れられます。</target>
        </trans-unit>
        <trans-unit id="b090b5874a4f9cb2a75963ffefe67f7cff33a14b" translate="yes" xml:space="preserve">
          <source>In addition, the following pairs of options are incompatible:</source>
          <target state="translated">また、以下のペアのオプションは互換性がありません。</target>
        </trans-unit>
        <trans-unit id="c9eac4f7a75d08c8d5ecd2f93cae76dbdd2c65fb" translate="yes" xml:space="preserve">
          <source>In addition, there are a number of optional keys:</source>
          <target state="translated">また、オプションキーも多数用意されています。</target>
        </trans-unit>
        <trans-unit id="3170175bde47695f8d16d1aa859fc39830538d4d" translate="yes" xml:space="preserve">
          <source>In all &quot;keep index&quot; cases, the index entry stays as in the original index file. If the entry is not up to date, &lt;code&gt;git read-tree&lt;/code&gt; keeps the copy in the work tree intact when operating under the -u flag.</source>
          <target state="translated">すべての「インデックスの保持」の場合、インデックスエントリは元のインデックスファイルのままです。エントリが最新でない場合、 &lt;code&gt;git read-tree&lt;/code&gt; は、-uフラグで操作しているときに、作業ツリー内のコピーをそのまま保持します。</target>
        </trans-unit>
        <trans-unit id="518e45973547d44ae8b0cf643cea7c8e1439a6f7" translate="yes" xml:space="preserve">
          <source>In all of these cases, the commands themselves first optionally limit the two sets of files by any pathspecs given on their command-lines, and compare corresponding paths in the two resulting sets of files.</source>
          <target state="translated">これらのすべての場合において、コマンド自体はまず、コマンドラインで与えられた任意のパス指定によって2つのファイルのセットを制限し、結果として得られる2つのファイルのセットの対応するパスを比較します。</target>
        </trans-unit>
        <trans-unit id="a976d8376129a573bbe9b45628bf2bdf5e1fe7e1" translate="yes" xml:space="preserve">
          <source>In an environment that restricts the users' access only to git commands over the wire, this hook can be used to implement access control without relying on filesystem ownership and group membership. See &lt;a href=&quot;git-shell&quot;&gt;git-shell[1]&lt;/a&gt; for how you might use the login shell to restrict the user&amp;rsquo;s access to only git commands.</source>
          <target state="translated">ユーザーのアクセスを有線のgitコマンドのみに制限する環境では、このフックを使用して、ファイルシステムの所有権やグループメンバーシップに依存せずにアクセス制御を実装できます。ログインシェルを使用してユーザーのアクセスをgitコマンドのみに制限する方法については、&lt;a href=&quot;git-shell&quot;&gt;git-shell [1]&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="9220471bbc29ec41ed13c216a79cb80f852ef698" translate="yes" xml:space="preserve">
          <source>In any case, a field name that refers to a field inapplicable to the object referred by the ref does not cause an error. It returns an empty string instead.</source>
          <target state="translated">いずれの場合でも、参照されたオブジェクトに適用できないフィールドを参照するフィールド名はエラーにはなりません。代わりに空の文字列を返します。</target>
        </trans-unit>
        <trans-unit id="3ed3c4a7faef04068c3d21c5e427f36b63dea04c" translate="yes" xml:space="preserve">
          <source>In both cases, all bytes are treated as-is (i.e., there is no quoting, and one cannot transmit a value with newline or NUL in it). The list of attributes is terminated by a blank line or end-of-file.</source>
          <target state="translated">どちらの場合も、すべてのバイトはそのまま扱われます(すなわち、クォートは行われず、改行やNULを含む値を送信することはできません)。属性のリストは空行かファイル終端で終了します。</target>
        </trans-unit>
        <trans-unit id="55cc553818c07e93d42b2d9a9da22e8f0487ba9d" translate="yes" xml:space="preserve">
          <source>In both formats &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is any of the commit specification expressions also accepted by &lt;code&gt;from&lt;/code&gt; (see above).</source>
          <target state="translated">どちらの形式でも、 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; は、 &lt;code&gt;from&lt;/code&gt; でも受け入れられる任意のコミット仕様式です（上記を参照）。</target>
        </trans-unit>
        <trans-unit id="9838d0f6a0615e5345bacba941fa3a7ae58fc03e" translate="yes" xml:space="preserve">
          <source>In both formats &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; is the type of file entry, specified in octal. Git only supports the following modes:</source>
          <target state="translated">どちらの形式でも、 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; はファイルエントリのタイプで、8進数で指定されます。Gitは次のモードのみをサポートします。</target>
        </trans-unit>
        <trans-unit id="e124f640b7099c2dfc555e83763a437b341aea9d" translate="yes" xml:space="preserve">
          <source>In both formats &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; is the complete path of the file to be added (if not already existing) or modified (if already existing).</source>
          <target state="translated">どちらの形式でも、 &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; は追加（まだ存在しない場合）または変更（既に存在する場合）するファイルの完全パスです。</target>
        </trans-unit>
        <trans-unit id="e22465a192b99fdb8a38ceb6e2163b1bb2a55eaa" translate="yes" xml:space="preserve">
          <source>In both formats RS (the record separator) is newline by default but will be the null byte if -z was passed on the command line. The temporary file names are always safe strings; they will never contain directory separators or whitespace characters. The path field is always relative to the current directory and the temporary file names are always relative to the top level directory.</source>
          <target state="translated">どちらのフォーマットでも、RS (レコードの区切り文字)はデフォルトでは改行されていますが、コマンドラインで -z が渡された場合はヌルバイトになります。一時ファイル名は常に安全な文字列で、ディレクトリ区切り文字や空白文字を含むことはありません。パスフィールドは常にカレントディレクトリからの相対パスであり、一時ファイル名は常にトップレベルディレクトリからの相対パスです。</target>
        </trans-unit>
        <trans-unit id="bbdfd88cae7c8d5fe4027454edb7c9f3a518f214" translate="yes" xml:space="preserve">
          <source>In both rename and copy detection, the same &quot;extent of changes&quot; algorithm used in diffcore-break is used to determine if two files are &quot;similar enough&quot;, and can be customized to use a similarity score different from the default of 50% by giving a number after the &quot;-M&quot; or &quot;-C&quot; option (e.g. &quot;-M8&quot; to tell it to use 8/10 = 80%).</source>
          <target state="translated">リネーム検出とコピー検出の両方において、2つのファイルが「十分に類似している」かどうかを判断するために、diffcore-breakで使用されているのと同じ「変更の程度」アルゴリズムが使用されています。</target>
        </trans-unit>
        <trans-unit id="cef1680a7a27c73f800aa2ae728f37bb9ebeed5c" translate="yes" xml:space="preserve">
          <source>In case &amp;lt;old&amp;gt; and &amp;lt;new&amp;gt; are the same, and &amp;lt;old&amp;gt; is a file under &lt;code&gt;$GIT_DIR/remotes&lt;/code&gt; or &lt;code&gt;$GIT_DIR/branches&lt;/code&gt;, the remote is converted to the configuration file format.</source>
          <target state="translated">&amp;lt;old&amp;gt;と&amp;lt;new&amp;gt;が同じで、&amp;lt;old&amp;gt;が &lt;code&gt;$GIT_DIR/remotes&lt;/code&gt; または &lt;code&gt;$GIT_DIR/branches&lt;/code&gt; 下のファイルである場合、リモートは構成ファイル形式に変換されます。</target>
        </trans-unit>
        <trans-unit id="77e55c61e61a6a73beec771303a37403de7ae828" translate="yes" xml:space="preserve">
          <source>In case (some of) these environment variables are not set, the information is taken from the configuration items &lt;code&gt;user.name&lt;/code&gt; and &lt;code&gt;user.email&lt;/code&gt;, or, if not present, the environment variable EMAIL, or, if that is not set, system user name and the hostname used for outgoing mail (taken from &lt;code&gt;/etc/mailname&lt;/code&gt; and falling back to the fully qualified hostname when that file does not exist).</source>
          <target state="translated">これらの環境変数（の一部）が設定されていない場合、情報は構成アイテム &lt;code&gt;user.name&lt;/code&gt; および &lt;code&gt;user.email&lt;/code&gt; から取得されます。存在しない場合は、環境変数EMAIL、または設定されていない場合はシステムユーザーから取得されます。送信メールに使用される名前とホスト名（ &lt;code&gt;/etc/mailname&lt;/code&gt; から取得され、そのファイルが存在しない場合は完全修飾ホスト名にフォールバックします）。</target>
        </trans-unit>
        <trans-unit id="3736cf7c9e88d8830feeb4facce5d47bac7822e0" translate="yes" xml:space="preserve">
          <source>In case (some of) these environment variables are not set, the information is taken from the configuration items user.name and user.email, or, if not present, the environment variable EMAIL, or, if that is not set, system user name and the hostname used for outgoing mail (taken from &lt;code&gt;/etc/mailname&lt;/code&gt; and falling back to the fully qualified hostname when that file does not exist).</source>
          <target state="translated">これらの環境変数（の一部）が設定されていない場合、情報は構成アイテムuser.nameおよびuser.email、または存在しない場合は環境変数EMAIL、または設定されていない場合はシステムユーザーから取得されます。送信メールに使用される名前とホスト名（ &lt;code&gt;/etc/mailname&lt;/code&gt; から取得され、そのファイルが存在しない場合は完全修飾ホスト名にフォールバックします）。</target>
        </trans-unit>
        <trans-unit id="fab172a52a0d96a15d352f159439993a534e8fe5" translate="yes" xml:space="preserve">
          <source>In case of conflict, &lt;code&gt;git rebase&lt;/code&gt; will stop at the first problematic commit and leave conflict markers in the tree. You can use &lt;code&gt;git diff&lt;/code&gt; to locate the markers (&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;) and make edits to resolve the conflict. For each file you edit, you need to tell Git that the conflict has been resolved, typically this would be done with</source>
          <target state="translated">競合が発生した場合、 &lt;code&gt;git rebase&lt;/code&gt; は問題のある最初のコミットで停止し、競合マーカーをツリーに残します。あなたは使用することができます &lt;code&gt;git diff&lt;/code&gt; （&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;）マーカーを見つけるためにと編集が競合を解決するために作ります。編集するファイルごとに、競合が解決されたことをGitに伝える必要があります。通常、これは</target>
        </trans-unit>
        <trans-unit id="8de3ddb587a19db9387af113a7f3cb72b19328d0" translate="yes" xml:space="preserve">
          <source>In case of failure in the output of &lt;a href=&quot;git-rm&quot;&gt;git-rm[1]&lt;/a&gt;, show directions on how to proceed from the current state.</source>
          <target state="translated">&lt;a href=&quot;git-rm&quot;&gt;git-rm [1]&lt;/a&gt;の出力に失敗した場合は、現在の状態から進む方法を示します。</target>
        </trans-unit>
        <trans-unit id="1ca6e2b22c66fb3bb4920e7b16e070cab433e13d" translate="yes" xml:space="preserve">
          <source>In case the filter cannot or does not want to process the content as well as any future content for the lifetime of the Git process, then it is expected to respond with an &quot;abort&quot; status at any point in the protocol.</source>
          <target state="translated">フィルタがそのコンテンツや将来のコンテンツを処理できない、あるいは処理したくない場合は、プロトコルのどの時点でも &quot;abort&quot; ステータスで応答することが予想されます。</target>
        </trans-unit>
        <trans-unit id="a44b155f3278323b322b1edffc06fec805c87137" translate="yes" xml:space="preserve">
          <source>In case the filter cannot or does not want to process the content, it is expected to respond with an &quot;error&quot; status.</source>
          <target state="translated">フィルタがコンテンツを処理できない場合や処理したくない場合には、&quot;error&quot; というステータスで応答することが期待されます。</target>
        </trans-unit>
        <trans-unit id="063d2c577358a9002bf9810cc43ec764ca0682e1" translate="yes" xml:space="preserve">
          <source>In command synopses, the word &quot;tree-ish&quot; is sometimes used to designate such an argument.</source>
          <target state="translated">コマンドのシノプシスでは、このような引数を指定するために &quot;tree-ish &quot;という言葉が使われることがあります。</target>
        </trans-unit>
        <trans-unit id="0cb56babf143d18da14e8d5b38b880de0eb432ae" translate="yes" xml:space="preserve">
          <source>In compact output mode, specified with configuration variable fetch.output, if either entire &lt;code&gt;&amp;lt;from&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;to&amp;gt;&lt;/code&gt; is found in the other string, it will be substituted with &lt;code&gt;*&lt;/code&gt; in the other string. For example, &lt;code&gt;master -&amp;gt; origin/master&lt;/code&gt; becomes &lt;code&gt;master -&amp;gt; origin/*&lt;/code&gt;.</source>
          <target state="translated">構成変数fetch.outputで指定されたコンパクト出力モードでは、 &lt;code&gt;&amp;lt;from&amp;gt;&lt;/code&gt; または &lt;code&gt;&amp;lt;to&amp;gt;&lt;/code&gt; 全体が他の文字列で見つかった場合、他の文字列で &lt;code&gt;*&lt;/code&gt; に置き換えられます。たとえば、 &lt;code&gt;master -&amp;gt; origin/master&lt;/code&gt; は &lt;code&gt;master -&amp;gt; origin/*&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="17a206b483cbd4faf3ff1c681d69d041ba456195" translate="yes" xml:space="preserve">
          <source>In contrast to a regular interactive rebase, there are &lt;code&gt;label&lt;/code&gt;, &lt;code&gt;reset&lt;/code&gt; and &lt;code&gt;merge&lt;/code&gt; commands in addition to &lt;code&gt;pick&lt;/code&gt; ones.</source>
          <target state="translated">通常のインタラクティブなリベースとは対照的に、コマンドの &lt;code&gt;pick&lt;/code&gt; に加えて、 &lt;code&gt;label&lt;/code&gt; 、 &lt;code&gt;reset&lt;/code&gt; 、および &lt;code&gt;merge&lt;/code&gt; コマンドがあります。</target>
        </trans-unit>
        <trans-unit id="a91f8ccdcda758152dfb84f7e032555a6abd0478" translate="yes" xml:space="preserve">
          <source>In contrast, a non-fast-forward update will lose history. For example, suppose you and somebody else started at the same commit X, and you built a history leading to commit B while the other person built a history leading to commit A. The history looks like this:</source>
          <target state="translated">対照的に、fast-forward ではない更新は履歴を失います。例えば、自分と他の誰かが同じコミットXから開始し、自分がコミットBにつながる履歴を作成し、他の誰かがコミットAにつながる履歴を作成したとします。履歴は次のようになります。</target>
        </trans-unit>
        <trans-unit id="732c99dfb4118d47f73ec2f7f549a4abcdf7b217" translate="yes" xml:space="preserve">
          <source>In detecting regressions introduced through the merging of a branch, the merge commit will be identified as introduction of the bug and its ancestors will be ignored.</source>
          <target state="translated">ブランチのマージによって導入されたリグレッションを検出する際には、マージコミットはバグの導入として識別され、その祖先は無視されます。</target>
        </trans-unit>
        <trans-unit id="07b2f985753911580a2527f5513df7870e7e2eaf" translate="yes" xml:space="preserve">
          <source>In editing files, git-filter-branch by design checks out each and every commit as it existed in the original repo. If your repo has 10\^5 files and 10\^5 commits, but each commit only modifies 5 files, then git-filter-branch will make you do 10\^10 modifications, despite only having (at most) 5*10^5 unique blobs.</source>
          <target state="translated">ファイルを編集する際に、git-filter-branch は設計上、元のレポに存在していたとおりにすべてのコミットをチェックアウトします。もしあなたのレポに 10 のコミットがあって、10 のコミットがあって、それぞれのコミットが 5 つのファイルを修正しただけだとしたら、git-filter-branch は (せいぜい)5*10^5 個のユニークなブロブしかないにもかかわらず、あなたに 10 の修正をさせるでしょう。</target>
        </trans-unit>
        <trans-unit id="2e3fe33f9a577c2f8225b1f2426166ec832bed24" translate="yes" xml:space="preserve">
          <source>In editing files, git-filter-branch by design checks out each and every commit as it existed in the original repo. If your repo has &lt;code&gt;10^5&lt;/code&gt; files and &lt;code&gt;10^5&lt;/code&gt; commits, but each commit only modifies five files, then git-filter-branch will make you do &lt;code&gt;10^10&lt;/code&gt; modifications, despite only having (at most) &lt;code&gt;5*10^5&lt;/code&gt; unique blobs.</source>
          <target state="translated">ファイルの編集では、設計上、git-filter-branchは、元のリポジトリに存在していたすべてのコミットをチェックアウトします。リポジトリに &lt;code&gt;10^5&lt;/code&gt; ファイルと &lt;code&gt;10^5&lt;/code&gt; コミットがあり、各コミットが5つのファイルのみを変更する場合、git-filter-branchを使用すると、（最大で） &lt;code&gt;5*10^5&lt;/code&gt; 一意であるにもかかわらず、 &lt;code&gt;10^10&lt;/code&gt; 変更を行うことができます。ブロブ。</target>
        </trans-unit>
        <trans-unit id="a532459a44f155e770ddc46e416638b81292d839" translate="yes" xml:space="preserve">
          <source>In either format, values can be specified in any form that Git recognizes as an object name. Commands in any other format or a repeated &amp;lt;ref&amp;gt; produce an error. Command meanings are:</source>
          <target state="translated">どちらの形式でも、Gitがオブジェクト名として認識する任意の形式で値を指定できます。他の形式のコマンドや&amp;lt;ref&amp;gt;を繰り返すと、エラーが発生します。コマンドの意味は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="9c49e183be0df7128f7b7d238522888866505455" translate="yes" xml:space="preserve">
          <source>In fact development teams often maintain both a development branch and a maintenance branch, and it would be quite easy for them if &quot;git bisect&quot; just worked when they want to bisect a regression on the development branch that is not on the maintenance branch. They should be able to start bisecting using:</source>
          <target state="translated">実際、開発チームは開発ブランチと保守ブランチの両方を管理していることがよくあります。開発ブランチのリグレッションを保守ブランチにはないものに分割したいときに &quot;git bisect&quot; を使えば、とても簡単に分割できるでしょう。開発ブランチ上のリグレッションをメンテナンスブランチ上ではなく、開発ブランチ上のリグレッションを二分したいときに &quot;git bisect&quot; が動作してくれれば、とても楽になるでしょう。</target>
        </trans-unit>
        <trans-unit id="49c9270dc1d07096e092a06d8107784ae1248f61" translate="yes" xml:space="preserve">
          <source>In fact it&amp;rsquo;s invaluable because there are bugs i would never even &lt;code&gt;try&lt;/code&gt; to debug if it wasn&amp;rsquo;t for git bisect. In the past there were bug patterns that were immediately hopeless for me to debug - at best i could send the crash/bug signature to lkml and hope that someone else can think of something.</source>
          <target state="translated">私もだろうバグがあるので、実際には非常に貴重です &lt;code&gt;try&lt;/code&gt; 、それはgitの二分のためではなかった場合は、デバッグには。過去には、デバッグするのにすぐに役に立たないバグパターンがありました。せいぜい、クラッシュ/バグのシグネチャをlkmlに送信して、他の誰かが何かを考えられることを願っています。</target>
        </trans-unit>
        <trans-unit id="4d0defa9e6e327fdaa3580beb798bb05e9bb4ad4" translate="yes" xml:space="preserve">
          <source>In fact it&amp;rsquo;s this last feature that &quot;sold&quot; it to the Git community, so it is now in the &quot;master&quot; branch of Git&amp;rsquo;s Git repository and it should be released in Git 1.6.5 in October or November 2009.</source>
          <target state="translated">実際、Gitコミュニティに「販売」したのはこの最後の機能なので、GitのGitリポジトリの「マスター」ブランチにあり、2009年10月または11月にGit 1.6.5でリリースされる予定です。</target>
        </trans-unit>
        <trans-unit id="a503332ebe0b76ca226cc7fab9355da1cbc846ca" translate="yes" xml:space="preserve">
          <source>In fact people are specially interested in commits that introduce a &quot;bad&quot; behavior, called a bug or a regression. They are interested in these commits because a commit (hopefully) contains a very small set of source code changes. And it&amp;rsquo;s much easier to understand and properly fix a problem when you only need to check a very small set of changes, than when you don&amp;rsquo;t know where look in the first place.</source>
          <target state="translated">実際、人々は特にバグや回帰と呼ばれる「悪い」振る舞いを導入するコミットに興味があります。コミットには（できれば）ソースコードの変更の非常に小さなセットが含まれているため、これらのコミットに関心があります。また、非常に小さな変更セットのみをチェックする必要がある場合は、最初の場所がわからない場合よりも、問題を理解して適切に修正する方がはるかに簡単です。</target>
        </trans-unit>
        <trans-unit id="ef62eb9471b68497e696b504f306bae12d5b62ac" translate="yes" xml:space="preserve">
          <source>In fact the problem is that big software often has many different configuration options and that each test case should pass for each configuration after each commit. So if you have for each release: N configurations, M commits and T test cases, you should perform:</source>
          <target state="translated">実際問題として、大規模なソフトウェアは多くの異なる設定オプションを持っていることが多く、各コミットの後に各設定に対して各テストケースが合格しなければならないことがあります。そのため、各リリースでN個の設定があり、M回のコミットとT個のテストケースがある場合、次のように実行しなければなりません。N個の設定、M個のコミット、T個のテストケースがある場合、あなたは実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="99977c45d37760acd8d4612dba46dd63b60c39cd" translate="yes" xml:space="preserve">
          <source>In fact, &lt;code&gt;git bisect&lt;/code&gt; can be used to find the commit that changed &lt;strong&gt;any&lt;/strong&gt; property of your project; e.g., the commit that fixed a bug, or the commit that caused a benchmark&amp;rsquo;s performance to improve. To support this more general usage, the terms &quot;old&quot; and &quot;new&quot; can be used in place of &quot;good&quot; and &quot;bad&quot;, or you can choose your own terms. See section &quot;Alternate terms&quot; below for more information.</source>
          <target state="translated">実際には、 &lt;code&gt;git bisect&lt;/code&gt; 変更されたことをコミット見つけるために使用することができます&lt;strong&gt;任意の&lt;/strong&gt;プロジェクトのプロパティを。たとえば、バグを修正したコミット、またはベンチマークのパフォーマンスを向上させたコミット。このより一般的な使用法をサポートするには、「古い」と「新しい」という用語を「良い」と「悪い」の代わりに使用するか、独自の用語を選択できます。詳細については、以下の「代替用語」のセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="7071f9821fe5bdd2a61f333d551d92b1d1a7cc62" translate="yes" xml:space="preserve">
          <source>In fact, &lt;code&gt;git diff-index --cached&lt;/code&gt;&lt;strong&gt;should&lt;/strong&gt; always be entirely equivalent to actually doing a &lt;code&gt;git write-tree&lt;/code&gt; and comparing that. Except this one is much nicer for the case where you just want to check where you are.</source>
          <target state="translated">実際、 &lt;code&gt;git diff-index --cached&lt;/code&gt; &lt;strong&gt;は&lt;/strong&gt;、実際に &lt;code&gt;git write-tree&lt;/code&gt; を実行してそれを比較することと常に完全に同等である&lt;strong&gt;必要&lt;/strong&gt;があります。これを除いて、あなたがあなたがどこにいるかを確認したいだけの場合には、はるかに良いです。</target>
        </trans-unit>
        <trans-unit id="4ed30cb15a7bebad154936439885b3df49088a74" translate="yes" xml:space="preserve">
          <source>In fact, as you did that, if you now look into your object directory, you&amp;rsquo;ll notice that Git will have added two new objects to the object database. If you did exactly the steps above, you should now be able to do</source>
          <target state="translated">実際、そうしたように、オブジェクトディレクトリを調べると、Gitが2つの新しいオブジェクトをオブジェクトデータベースに追加していることがわかります。上記の手順を正確に実行した場合は、次のことができるはずです</target>
        </trans-unit>
        <trans-unit id="c9492aea4e59a8249b05f0197902254019664286" translate="yes" xml:space="preserve">
          <source>In fact, if you have &lt;code&gt;master&lt;/code&gt; checked out, then this branch has been configured by &lt;code&gt;git clone&lt;/code&gt; to get changes from the HEAD branch of the origin repository. So often you can accomplish the above with just a simple</source>
          <target state="translated">実際、 &lt;code&gt;master&lt;/code&gt; チェックアウトしている場合、このブランチは &lt;code&gt;git clone&lt;/code&gt; によって設定されており、オリジンリポジトリのHEADブランチから変更を取得します。したがって、多くの場合、単純な方法で上記を達成できます</target>
        </trans-unit>
        <trans-unit id="c5bd224f8ecefe700eae1705d4f2a63ae227649f" translate="yes" xml:space="preserve">
          <source>In fact, in &lt;a href=&quot;#git-concepts&quot;&gt;Git concepts&lt;/a&gt; we shall see that everything stored in Git history, including file data and directory contents, is stored in an object with a name that is a hash of its contents.</source>
          <target state="translated">実際、&lt;a href=&quot;#git-concepts&quot;&gt;Gitの概念&lt;/a&gt;では、ファイルデータやディレクトリの内容を含め、Gitの履歴に保存されているすべてのものは、その内容のハッシュである名前を持つオブジェクトに保存されていることがわかります。</target>
        </trans-unit>
        <trans-unit id="9ce4601e5a5f52f186df099525d9504862a821c8" translate="yes" xml:space="preserve">
          <source>In fact, together with the &lt;code&gt;git rev-list&lt;/code&gt; program (which generates a list of revisions), &lt;code&gt;git diff-tree&lt;/code&gt; ends up being a veritable fount of changes. You can emulate &lt;code&gt;git log&lt;/code&gt;, &lt;code&gt;git log -p&lt;/code&gt;, etc. with a trivial script that pipes the output of &lt;code&gt;git rev-list&lt;/code&gt; to &lt;code&gt;git diff-tree --stdin&lt;/code&gt;, which was exactly how early versions of &lt;code&gt;git log&lt;/code&gt; were implemented.</source>
          <target state="translated">実際、 &lt;code&gt;git rev-list&lt;/code&gt; プログラム（リビジョンのリストを生成する）と一緒に、 &lt;code&gt;git diff-tree&lt;/code&gt; は最終的に変更の真の源となっています。 &lt;code&gt;git rev-list&lt;/code&gt; の出力を &lt;code&gt;git diff-tree --stdin&lt;/code&gt; にパイプ処理する簡単なスクリプトを &lt;code&gt;git log&lt;/code&gt; 、git log、 &lt;code&gt;git log -p&lt;/code&gt; などをエミュレートできます。これは、 &lt;code&gt;git log&lt;/code&gt; の初期バージョンが実装された方法とまったく同じです。</target>
        </trans-unit>
        <trans-unit id="da9de14a63db6e5a8e5a19a81e9a6160f95eb222" translate="yes" xml:space="preserve">
          <source>In fact, we can perform all the normal Git operations. But, let&amp;rsquo;s look at what happens when we then checkout &lt;code&gt;master&lt;/code&gt;:</source>
          <target state="translated">実際、通常のすべてのGit操作を実行できます。しかし、 &lt;code&gt;master&lt;/code&gt; をチェックアウトするとどうなるか見てみましょう。</target>
        </trans-unit>
        <trans-unit id="728d90294e037628a986d3380572564cc895d389" translate="yes" xml:space="preserve">
          <source>In future versions we may learn to support patterns containing \0 for more search backends, until then we&amp;rsquo;ll die when the pattern type in question doesn&amp;rsquo;t support them.</source>
          <target state="translated">将来のバージョンでは、より多くの検索バックエンドで\ 0を含むパターンをサポートするようになる可能性があります。それまでは、問題のパターンタイプがそれらをサポートしない場合は死にます。</target>
        </trans-unit>
        <trans-unit id="674a2666658c40a25d4cd65b3ea28af975f1fa97" translate="yes" xml:space="preserve">
          <source>In general a client can request to speak protocol v2 by sending &lt;code&gt;version=2&lt;/code&gt; through the respective side-channel for the transport being used which inevitably sets &lt;code&gt;GIT_PROTOCOL&lt;/code&gt;. More information can be found in &lt;code&gt;pack-protocol.txt&lt;/code&gt; and &lt;code&gt;http-protocol.txt&lt;/code&gt;. In all cases the response from the server is the capability advertisement.</source>
          <target state="translated">一般に、クライアントは、使用されているトランスポートのそれぞれのサイドチャネルを介して &lt;code&gt;version=2&lt;/code&gt; を送信することにより、プロトコルv2を話すように要求できます。これにより、必然的に &lt;code&gt;GIT_PROTOCOL&lt;/code&gt; が設定されます。詳細については、 &lt;code&gt;pack-protocol.txt&lt;/code&gt; および &lt;code&gt;http-protocol.txt&lt;/code&gt; を参照してください。すべての場合において、サーバーからの応答は機能通知です。</target>
        </trans-unit>
        <trans-unit id="1aaa12db7c29bdac4538baf95940db6bed82a0b8" translate="yes" xml:space="preserve">
          <source>In general, URLs contain information about the transport protocol, the address of the remote server, and the path to the repository. Depending on the transport protocol, some of this information may be absent.</source>
          <target state="translated">一般的に、URL にはトランスポートプロトコル、リモートサーバーのアドレス、リポジトリへのパスに関する情報が含まれています。トランスポートプロトコルによっては、この情報の一部が含まれていない場合があります。</target>
        </trans-unit>
        <trans-unit id="811906db3a55c059a1cd7d72b959827c93f94a02" translate="yes" xml:space="preserve">
          <source>In general, all pseudo refs are per working tree and all refs starting with &quot;refs/&quot; are shared. Pseudo refs are ones like HEAD which are directly under GIT_DIR instead of inside GIT_DIR/refs. There is one exception to this: refs inside refs/bisect and refs/worktree is not shared.</source>
          <target state="translated">一般的に、すべての擬似リファレンスは作業ツリーごとに存在し、&quot;refs/&quot;で始まるすべてのリファレンスは共有されます。擬似リファレンスとは、HEADのようにGIT_DIR/refsの中ではなく、GIT_DIRの直下にあるものを指します。これには一つの例外があります:refs/bisect や refs/worktree の中の refs は共有されません。</target>
        </trans-unit>
        <trans-unit id="c1959905d09bef6c12ae8c7983e3b002ca1126c5" translate="yes" xml:space="preserve">
          <source>In general, all pseudo refs are per working tree and all refs starting with &lt;code&gt;refs/&lt;/code&gt; are shared. Pseudo refs are ones like &lt;code&gt;HEAD&lt;/code&gt; which are directly under &lt;code&gt;$GIT_DIR&lt;/code&gt; instead of inside &lt;code&gt;$GIT_DIR/refs&lt;/code&gt;. There are exceptions, however: refs inside &lt;code&gt;refs/bisect&lt;/code&gt; and &lt;code&gt;refs/worktree&lt;/code&gt; are not shared.</source>
          <target state="translated">一般に、すべての疑似参照は作業ツリーごとにあり、 &lt;code&gt;refs/&lt;/code&gt; 始まるすべての参照は共有されます。疑似参照は、 &lt;code&gt;$GIT_DIR/refs&lt;/code&gt; 内ではなく &lt;code&gt;$GIT_DIR&lt;/code&gt; 直下にある &lt;code&gt;HEAD&lt;/code&gt; のようなものです。ただし、例外があります &lt;code&gt;refs/worktree&lt;/code&gt; &lt;code&gt;refs/bisect&lt;/code&gt; およびrefs / worktree内のrefは共有されません。</target>
        </trans-unit>
        <trans-unit id="e394e7bf320940c252fcc858f73aeff38e0e3c05" translate="yes" xml:space="preserve">
          <source>In general, it is better to enumerate existing objects with problems with &lt;code&gt;fsck.skipList&lt;/code&gt;, instead of listing the kind of breakages these problematic objects share to be ignored, as doing the latter will allow new instances of the same breakages go unnoticed.</source>
          <target state="translated">一般に、これらの問題のあるオブジェクトが共有する破損の種類を一覧表示するのではなく、既存のオブジェクトを &lt;code&gt;fsck.skipList&lt;/code&gt; で列挙する方がよいでしょう。後者を実行すると、同じ破損の新しいインスタンスが気付かれないためです。</target>
        </trans-unit>
        <trans-unit id="7dc03507399a3b4938c051e86309da2b5ba01f5b" translate="yes" xml:space="preserve">
          <source>In general, the interrogate commands do not touch the files in the working tree.</source>
          <target state="translated">一般的に、インタロゲートコマンドは作業ツリー内のファイルには触れません。</target>
        </trans-unit>
        <trans-unit id="0830c69bce9b1a4ab3ff9dbb3ca0e63e381af048" translate="yes" xml:space="preserve">
          <source>In general, using</source>
          <target state="translated">一般的には</target>
        </trans-unit>
        <trans-unit id="37034b2d8b34e79ca4767d593d59ca39d0651fd5" translate="yes" xml:space="preserve">
          <source>In here all submodules except &lt;code&gt;baz&lt;/code&gt; (foo, bar, bob) are active. &lt;code&gt;foo&lt;/code&gt; due to its own active flag and all the others due to the submodule active pathspec, which specifies that any submodule starting with &lt;code&gt;b&lt;/code&gt; except &lt;code&gt;baz&lt;/code&gt; are also active, regardless of the presence of the .url field.</source>
          <target state="translated">ここでは、 &lt;code&gt;baz&lt;/code&gt; （foo、bar、bob）を除くすべてのサブモジュールがアクティブです。.urlフィールドの存在に関係なく、 &lt;code&gt;baz&lt;/code&gt; を除いて &lt;code&gt;b&lt;/code&gt; で始まるすべてのサブモジュールもアクティブであることを指定する、独自のアクティブフラグによる &lt;code&gt;foo&lt;/code&gt; とサブモジュールのアクティブpathspecによるその他すべて。</target>
        </trans-unit>
        <trans-unit id="f129c819372eb3b42173e4b2d9e114ef285b7635" translate="yes" xml:space="preserve">
          <source>In interactive commands, allow the user to provide one-letter input with a single key (i.e., without hitting enter). Currently this is used by the &lt;code&gt;--patch&lt;/code&gt; mode of &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt;, &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt;, &lt;a href=&quot;git-restore&quot;&gt;git-restore[1]&lt;/a&gt;, &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt;, &lt;a href=&quot;git-reset&quot;&gt;git-reset[1]&lt;/a&gt;, and &lt;a href=&quot;git-stash&quot;&gt;git-stash[1]&lt;/a&gt;. Note that this setting is silently ignored if portable keystroke input is not available; requires the Perl module Term::ReadKey.</source>
          <target state="translated">対話型コマンドでは、ユーザーが単一のキーで（つまり、Enterキーを押すことなく）1文字の入力を提供できるようにします。現在、これは&lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt;、&lt;a href=&quot;git-checkout&quot;&gt;git-checkout [1]&lt;/a&gt;、&lt;a href=&quot;git-restore&quot;&gt;git-restore [1]&lt;/a&gt;、&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt;、&lt;a href=&quot;git-reset&quot;&gt;git-reset [1]&lt;/a&gt;、および&lt;a href=&quot;git-stash&quot;&gt;git-stash&lt;/a&gt;の &lt;code&gt;--patch&lt;/code&gt; モードで使用されています[1]。ポータブルキーストローク入力が利用できない場合、この設定は黙って無視されることに注意してください。 PerlモジュールTerm :: ReadKeyが必要です。</target>
        </trans-unit>
        <trans-unit id="1d1c8ed607ef3eefbb04beacb314688e02741550" translate="yes" xml:space="preserve">
          <source>In interactive mode, you can mark commits with the action &quot;edit&quot;. However, this does not necessarily mean that &lt;code&gt;git rebase&lt;/code&gt; expects the result of this edit to be exactly one commit. Indeed, you can undo the commit, or you can add other commits. This can be used to split a commit into two:</source>
          <target state="translated">対話モードでは、アクション「編集」でコミットをマークできます。ただし、これは、必ずしも &lt;code&gt;git rebase&lt;/code&gt; がこの編集の結果を1つのコミットであると想定していることを意味するわけではありません。実際、コミットを取り消すことも、他のコミットを追加することもできます。これは、コミットを2つに分割するために使用できます。</target>
        </trans-unit>
        <trans-unit id="15b1add937944ed893f52c8ec0293a4127b76c00" translate="yes" xml:space="preserve">
          <source>In its first form, the command provides the content or the type of an object in the repository. The type is required unless &lt;code&gt;-t&lt;/code&gt; or &lt;code&gt;-p&lt;/code&gt; is used to find the object type, or &lt;code&gt;-s&lt;/code&gt; is used to find the object size, or &lt;code&gt;--textconv&lt;/code&gt; or &lt;code&gt;--filters&lt;/code&gt; is used (which imply type &quot;blob&quot;).</source>
          <target state="translated">最初の形式では、コマンドはリポジトリ内のオブジェクトのコンテンツまたはタイプを提供します。 &lt;code&gt;-t&lt;/code&gt; または &lt;code&gt;-p&lt;/code&gt; を使用してオブジェクトタイプを検索するか、または &lt;code&gt;-s&lt;/code&gt; を使用してオブジェクトサイズを検索するか、または &lt;code&gt;--textconv&lt;/code&gt; または &lt;code&gt;--filters&lt;/code&gt; （「タイプ」を意味する）を使用しない限り、タイプは必須です。</target>
        </trans-unit>
        <trans-unit id="1ce9842f8f482fa7cd77bb4bd4603b72b75e4e0b" translate="yes" xml:space="preserve">
          <source>In its most compact form, this instruction only takes up one byte (0x80) with both offset and size omitted, which will have default values zero. There is another exception: size zero is automatically converted to 0x10000.</source>
          <target state="translated">最もコンパクトな形では、この命令はオフセットとサイズの両方を省略して1バイト(0x80)だけを占有し、デフォルト値はゼロになります。もう一つの例外があります:サイズゼロは自動的に0x10000に変換されます。</target>
        </trans-unit>
        <trans-unit id="ed6a0138b63bece5f8693e0a03055de4444b4006" translate="yes" xml:space="preserve">
          <source>In its simplest form, &lt;code&gt;git worktree add &amp;lt;path&amp;gt;&lt;/code&gt; automatically creates a new branch whose name is the final component of &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt;, which is convenient if you plan to work on a new topic. For instance, &lt;code&gt;git
worktree add ../hotfix&lt;/code&gt; creates new branch &lt;code&gt;hotfix&lt;/code&gt; and checks it out at path &lt;code&gt;../hotfix&lt;/code&gt;. To instead work on an existing branch in a new working tree, use &lt;code&gt;git worktree add &amp;lt;path&amp;gt; &amp;lt;branch&amp;gt;&lt;/code&gt;. On the other hand, if you just plan to make some experimental changes or do testing without disturbing existing development, it is often convenient to create a &lt;code&gt;throwaway&lt;/code&gt; working tree not associated with any branch. For instance, &lt;code&gt;git worktree add -d &amp;lt;path&amp;gt;&lt;/code&gt; creates a new working tree with a detached &lt;code&gt;HEAD&lt;/code&gt; at the same commit as the current branch.</source>
          <target state="translated">最も単純な形式では、 &lt;code&gt;git worktree add &amp;lt;path&amp;gt;&lt;/code&gt; は、名前が &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; の最後のコンポーネントである新しいブランチを自動的に作成します。これは、新しいトピックで作業する場合に便利です。たとえば、 &lt;code&gt;git worktree add ../hotfix&lt;/code&gt; は新しいブランチ &lt;code&gt;hotfix&lt;/code&gt; を作成し、パス &lt;code&gt;../hotfix&lt;/code&gt; でチェックアウトします。代わりに、新しい作業ツリーの既存のブランチで作業するには、 &lt;code&gt;git worktree add &amp;lt;path&amp;gt; &amp;lt;branch&amp;gt;&lt;/code&gt; ます。一方、既存の開発を妨げることなく、実験的な変更を加えたりテストを行ったりする場合は、ブランチに関連付けられていない &lt;code&gt;throwaway&lt;/code&gt; 作業ツリーを作成すると便利なことがよくあります。たとえば、 &lt;code&gt;git worktree add -d &amp;lt;path&amp;gt;&lt;/code&gt; 現在のブランチと同じコミットで、 &lt;code&gt;HEAD&lt;/code&gt; が切り離された新しい作業ツリーを作成します。</target>
        </trans-unit>
        <trans-unit id="70413e1dbdf33a9cdd6044f089c7e374f7b737c4" translate="yes" xml:space="preserve">
          <source>In mathematical terms, what we are looking for is some sort of a minimum cost bipartite matching; &lt;code&gt;1&lt;/code&gt; is matched to &lt;code&gt;C&lt;/code&gt; at some cost, etc. The underlying graph is in fact a complete bipartite graph; the cost we associate with every edge is the size of the diff between the two commits' patches. To explain also new commits, we introduce dummy nodes on both sides:</source>
          <target state="translated">数学的に言えば、私たちが探しているのは、ある種の最小コストの二部マッチングです。 &lt;code&gt;1&lt;/code&gt; は、なんらかのコストで &lt;code&gt;C&lt;/code&gt; と一致します。基になるグラフは、実際には完全な2部グラフです。すべてのエッジに関連するコストは、2つのコミットのパッチ間の差分のサイズです。新しいコミットについても説明するために、両側にダミーノードを導入します。</target>
        </trans-unit>
        <trans-unit id="abc4a2c282027431dbb87981bf40f5240785d9ef" translate="yes" xml:space="preserve">
          <source>In modern git, you can say this in a more direct way:</source>
          <target state="translated">現代のgitでは、もっと直接的な言い方をするとこうなります。</target>
        </trans-unit>
        <trans-unit id="1cd9dc714cc1317fe8fea12649b27b5eeab6e568" translate="yes" xml:space="preserve">
          <source>In most cases, this means the attributes given in the input will be repeated in the output, but Git may also modify the credential description, for example by removing the &lt;code&gt;path&lt;/code&gt; attribute when the protocol is HTTP(s) and &lt;code&gt;credential.useHttpPath&lt;/code&gt; is false.</source>
          <target state="translated">ほとんどの場合、これは入力で指定された属性が出力でも繰り返されることを意味しますが、Gitは、たとえばプロトコルがHTTP（s）で &lt;code&gt;credential.useHttpPath&lt;/code&gt; がfalse の場合に &lt;code&gt;path&lt;/code&gt; 属性を削除するなど、資格情報の説明を変更することもあります。</target>
        </trans-unit>
        <trans-unit id="c12479d09bff69f421dbf9e45fddc92269d1f574" translate="yes" xml:space="preserve">
          <source>In most cases, users should run &lt;em&gt;git gc&lt;/em&gt;, which calls &lt;em&gt;git prune&lt;/em&gt;. See the section &quot;NOTES&quot;, below.</source>
          <target state="translated">ほとんどの場合、ユーザーは&lt;em&gt;git prune&lt;/em&gt;を呼び出す&lt;em&gt;git &lt;/em&gt;&lt;em&gt;gc&lt;/em&gt;を実行する必要があります。以下の「注意事項」のセクションを参照してください。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6d4e8e52070be526725731839d6ade7553803d5e" translate="yes" xml:space="preserve">
          <source>In most cases, users will not need to call &lt;code&gt;git prune&lt;/code&gt; directly, but should instead call &lt;code&gt;git gc&lt;/code&gt;, which handles pruning along with many other housekeeping tasks.</source>
          <target state="translated">ほとんどの場合、ユーザーは &lt;code&gt;git prune&lt;/code&gt; を直接呼び出す必要はありませんが、代わりに他の多くのハウスキーピングタスクと一緒にプルーニングを処理する &lt;code&gt;git gc&lt;/code&gt; を呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="7de19f518cc5353753469bfb19c4e4f93734f02e" translate="yes" xml:space="preserve">
          <source>In multiple working trees, some refs may be shared between all working trees and some refs are local. One example is &lt;code&gt;HEAD&lt;/code&gt; which is different for each working tree. This section is about the sharing rules and how to access refs of one working tree from another.</source>
          <target state="translated">複数の作業ツリーでは、一部の参照はすべての作業ツリー間で共有され、一部の参照はローカルです。一例は、作業ツリーごとに異なる &lt;code&gt;HEAD&lt;/code&gt; です。このセクションでは、共有ルールと、ある作業ツリーの参照に別の作業ツリーからアクセスする方法について説明します。</target>
        </trans-unit>
        <trans-unit id="fa1d2a97ebd3bb9e2d938b11b92fc4a8e0c826fa" translate="yes" xml:space="preserve">
          <source>In multiple working trees, some refs may be shared between all working trees, some refs are local. One example is HEAD is different for all working trees. This section is about the sharing rules and how to access refs of one working tree from another.</source>
          <target state="translated">複数の作業木では、いくつかの参照はすべての作業木で共有され、いくつかの参照はローカルです。例えば、HEADはすべての作業ツリーで異なります。ここでは、共有のルールと、ある作業ツリーの参照を別の作業ツリーからアクセスする方法について説明します。</target>
        </trans-unit>
        <trans-unit id="fef9e754382e4f5002bb7f83483631df5de227e1" translate="yes" xml:space="preserve">
          <source>In older Git versions it could be easily forgotten to commit new or modified files in a submodule, which silently leads to similar problems as not pushing the submodule changes. Starting with Git 1.7.0 both &lt;code&gt;git status&lt;/code&gt; and &lt;code&gt;git diff&lt;/code&gt; in the superproject show submodules as modified when they contain new or modified files to protect against accidentally committing such a state. &lt;code&gt;git
diff&lt;/code&gt; will also add a &lt;code&gt;-dirty&lt;/code&gt; to the work tree side when generating patch output or used with the &lt;code&gt;--submodule&lt;/code&gt; option:</source>
          <target state="translated">古いGitバージョンでは、サブモジュールで新しいファイルまたは変更されたファイルをコミットすることを簡単に忘れてしまう可能性があり、サブモジュールの変更をプッシュしないと同様の問題が発生します。 Git 1.7.0以降では、スーパープロジェクトの &lt;code&gt;git status&lt;/code&gt; と &lt;code&gt;git diff&lt;/code&gt; の両方で、サブモジュールに新しいファイルまたは変更されたファイルが含まれている場合、そのような状態を誤ってコミットしないように保護するため、サブモジュールが変更されたと表示されます。 &lt;code&gt;git diff&lt;/code&gt; は、パッチ出力を生成するとき、または &lt;code&gt;--submodule&lt;/code&gt; オプションとともに使用するときに、作業ツリー側に &lt;code&gt;-dirty&lt;/code&gt; も追加します。</target>
        </trans-unit>
        <trans-unit id="cea51be0687534aeac695491ce11f4552163d8c9" translate="yes" xml:space="preserve">
          <source>In order to allow extensions that add extra data to the MIDX, we organize the body into &quot;chunks&quot; and provide a lookup table at the beginning of the body. The header includes certain length values, such as the number of packs, the number of base MIDX files, hash lengths and types.</source>
          <target state="translated">MIDXに余分なデータを追加する拡張機能を可能にするために、ボディを「チャンク」に整理し、ボディの先頭にルックアップテーブルを提供しています。ヘッダには、パックの数、ベースとなるMIDXファイルの数、ハッシュの長さ、型などの特定の長さの値が含まれています。</target>
        </trans-unit>
        <trans-unit id="f6b8f2c2e89120a466dd40e221531b6adf7a10b9" translate="yes" xml:space="preserve">
          <source>In order to determine what URL to use to fetch from, the value of the configuration &lt;code&gt;remote.&amp;lt;origin&amp;gt;.url&lt;/code&gt; is consulted and if there is not any such variable, the value on the &lt;code&gt;URL:&lt;/code&gt; line in &lt;code&gt;$GIT_DIR/remotes/&amp;lt;origin&amp;gt;&lt;/code&gt; is used.</source>
          <target state="translated">URLは、からフェッチするための設定の値を使用するかを決定するために &lt;code&gt;remote.&amp;lt;origin&amp;gt;.url&lt;/code&gt; 相談し、そのような変数が存在しない場合は、上の値であり、 &lt;code&gt;URL:&lt;/code&gt; の行 &lt;code&gt;$GIT_DIR/remotes/&amp;lt;origin&amp;gt;&lt;/code&gt; が使用されます。</target>
        </trans-unit>
        <trans-unit id="1bb65c849d69cb9e41866b99d141938531c8bf39" translate="yes" xml:space="preserve">
          <source>In order to determine what remote branches to fetch (and optionally store in the remote-tracking branches) when the command is run without any refspec parameters on the command line, values of the configuration variable &lt;code&gt;remote.&amp;lt;origin&amp;gt;.fetch&lt;/code&gt; are consulted, and if there aren&amp;rsquo;t any, &lt;code&gt;$GIT_DIR/remotes/&amp;lt;origin&amp;gt;&lt;/code&gt; is consulted and its &lt;code&gt;Pull:&lt;/code&gt; lines are used. In addition to the refspec formats described in the OPTIONS section, you can have a globbing refspec that looks like this:</source>
          <target state="translated">コマンドラインにrefspecパラメーターを指定せずにコマンドを実行したときに、フェッチするリモートブランチを決定する（およびオプションでリモートトラッキングブランチに保存する）ために、構成変数 &lt;code&gt;remote.&amp;lt;origin&amp;gt;.fetch&lt;/code&gt; が調べられます。ない場合は、 &lt;code&gt;$GIT_DIR/remotes/&amp;lt;origin&amp;gt;&lt;/code&gt; が調べられ、その &lt;code&gt;Pull:&lt;/code&gt; 行が使用されます。OPTIONSセクションで説明されているrefspec形式に加えて、次のようなグロビングrefspecを使用できます。</target>
        </trans-unit>
        <trans-unit id="b571757e7fe93a92c37f6bdbb5b1d110de433e8f" translate="yes" xml:space="preserve">
          <source>In order to ensure a current tracking branch state, &lt;code&gt;update --remote&lt;/code&gt; fetches the submodule&amp;rsquo;s remote repository before calculating the SHA-1. If you don&amp;rsquo;t want to fetch, you should use &lt;code&gt;submodule update
--remote --no-fetch&lt;/code&gt;.</source>
          <target state="translated">現在の追跡ブランチの状態を確認するために、 &lt;code&gt;update --remote&lt;/code&gt; はSHA-1を計算する前にサブモジュールのリモートリポジトリをフェッチします。フェッチしたくない場合は、 &lt;code&gt;submodule update --remote --no-fetch&lt;/code&gt; 使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="9ecc869f1231e06aba76a745114504d0b9155917" translate="yes" xml:space="preserve">
          <source>In order to have configuration specific to working trees, you can turn on &quot;worktreeConfig&quot; extension, e.g.:</source>
          <target state="translated">作業ツリーに特化した設定をするためには、&quot;worktreeConfig &quot;エクステンションを有効にすることができます。</target>
        </trans-unit>
        <trans-unit id="1e42ca6d9de6de9f8c6bfadac339f32432bf0913" translate="yes" xml:space="preserve">
          <source>In order to have configuration specific to working trees, you can turn on the &lt;code&gt;worktreeConfig&lt;/code&gt; extension, e.g.:</source>
          <target state="translated">作業ツリーに固有の構成を作成するには、 &lt;code&gt;worktreeConfig&lt;/code&gt; 拡張機能をオンにします。例：</target>
        </trans-unit>
        <trans-unit id="eb76ce16c3a3c52ec0347fc95609ba6324ad6c16" translate="yes" xml:space="preserve">
          <source>In order to protect the privacy of objects that have been removed from history but may not yet have been pruned, &lt;code&gt;git-upload-archive&lt;/code&gt; avoids serving archives for commits and trees that are not reachable from the repository&amp;rsquo;s refs. However, because calculating object reachability is computationally expensive, &lt;code&gt;git-upload-archive&lt;/code&gt; implements a stricter but easier-to-check set of rules:</source>
          <target state="translated">履歴から削除されたがまだ整理されていない可能性のあるオブジェクトのプライバシーを保護するために、 &lt;code&gt;git-upload-archive&lt;/code&gt; は、リポジトリの参照から到達できないコミットおよびツリーのアーカイブの提供を回避します。ただし、オブジェクトの到達可能性の計算には計算コストがかかるため、 &lt;code&gt;git-upload-archive&lt;/code&gt; はより厳密でありながらチェックが容易な一連のルールを実装します。</target>
        </trans-unit>
        <trans-unit id="17696fe6311cd47e2efc1108f911bdeb8c2c0989" translate="yes" xml:space="preserve">
          <source>In order to set &quot;assume unchanged&quot; bit, use &lt;code&gt;--assume-unchanged&lt;/code&gt; option. To unset, use &lt;code&gt;--no-assume-unchanged&lt;/code&gt;. To see which files have the &quot;assume unchanged&quot; bit set, use &lt;code&gt;git ls-files -v&lt;/code&gt; (see &lt;a href=&quot;git-ls-files&quot;&gt;git-ls-files[1]&lt;/a&gt;).</source>
          <target state="translated">「変更しない」ビットを設定するには、 &lt;code&gt;--assume-unchanged&lt;/code&gt; オプションを使用します。設定を解除するには、 &lt;code&gt;--no-assume-unchanged&lt;/code&gt; を使用します。どのファイルが「変更されていない」と設定されているかを確認するには、 &lt;code&gt;git ls-files -v&lt;/code&gt; を使用します（&lt;a href=&quot;git-ls-files&quot;&gt;git-ls-files [1]を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="267b1e8e9ade7b3919e26586bb280b53787cfd98" translate="yes" xml:space="preserve">
          <source>In other messages Andreas says that they also use the &quot;best practices&quot; described above: small logical commits, topic branches, no evil merge,&amp;hellip;​ These practices all improve the bisectability of the commit graph, by making it easier and more useful to bisect.</source>
          <target state="translated">他のメッセージで、Andreasは、上記の「ベストプラクティス」も使用すると述べています。小さな論理コミット、トピックブランチ、悪意のないマージなど... 。</target>
        </trans-unit>
        <trans-unit id="cbba08cd602a94910294469b1bfe69221cf43d34" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;--merge&lt;/code&gt; does something like a &lt;code&gt;git read-tree -u -m &amp;lt;commit&amp;gt;&lt;/code&gt;, but carries forward unmerged index entries.</source>
          <target state="translated">言い換えると、-- &lt;code&gt;--merge&lt;/code&gt; は &lt;code&gt;git read-tree -u -m &amp;lt;commit&amp;gt;&lt;/code&gt; のようなことを行いますが、マージされていないインデックスエントリを転送します。</target>
        </trans-unit>
        <trans-unit id="2c3347c08edbf67732cb77724b9990f6671bac50" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;git diff-files&lt;/code&gt; always shows us the difference between what is recorded in the index, and what is currently in the working tree. That&amp;rsquo;s very useful.</source>
          <target state="translated">つまり、 &lt;code&gt;git diff-files&lt;/code&gt; は常に、インデックスに記録されているものと現在作業ツリーにあるものの違いを示しています。とても便利です。</target>
        </trans-unit>
        <trans-unit id="7466e77eb24cbec56937901c0950f635d6a29d08" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;git diff-index&lt;/code&gt; normally compares a tree against the working tree, but when given the &lt;code&gt;--cached&lt;/code&gt; flag, it is told to instead compare against just the index cache contents, and ignore the current working tree state entirely. Since we just wrote the index file to HEAD, doing &lt;code&gt;git diff-index --cached -p HEAD&lt;/code&gt; should thus return an empty set of differences, and that&amp;rsquo;s exactly what it does.</source>
          <target state="translated">言い換えると、通常、 &lt;code&gt;git diff-index&lt;/code&gt; はツリーを作業ツリーと比較しますが、 &lt;code&gt;--cached&lt;/code&gt; フラグを指定すると、代わりにインデックスキャッシュの内容のみを比較し、現在の作業ツリーの状態を完全に無視するように指示されます。インデックスファイルをHEADに書き込んだばかりなので、 &lt;code&gt;git diff-index --cached -p HEAD&lt;/code&gt; を実行すると、空の差分セットが返されるはずです。それがまさにそれです。</target>
        </trans-unit>
        <trans-unit id="8c2ef787b7de3a9f3b5df9786c452fde9692465e" translate="yes" xml:space="preserve">
          <source>In other words, there is no need to worry about what exists only in the working tree. When you have local changes in a part of the project that is not involved in the merge, your changes do not interfere with the merge, and are kept intact. When they &lt;strong&gt;do&lt;/strong&gt; interfere, the merge does not even start (&lt;code&gt;git read-tree&lt;/code&gt; complains loudly and fails without modifying anything). In such a case, you can simply continue doing what you were in the middle of doing, and when your working tree is ready (i.e. you have finished your work-in-progress), attempt the merge again.</source>
          <target state="translated">つまり、作業ツリーにのみ存在するものについて心配する必要はありません。マージに関係のないプロジェクトの一部にローカルの変更がある場合、変更はマージに干渉せず、そのまま保持されます。それら&lt;strong&gt;が&lt;/strong&gt;干渉した場合、マージは開始されません（ &lt;code&gt;git read-tree&lt;/code&gt; は大声で不平を言い、何も変更せずに失敗します）。このような場合は、作業の途中で行っていた作業を続けることができ、作業ツリーの準備ができたら（つまり、作業中の作業が完了したら）マージを再試行します。</target>
        </trans-unit>
        <trans-unit id="5a674f35b2eda0a90a7f397ea7dadc5a212b7275" translate="yes" xml:space="preserve">
          <source>In other words, while a &quot;tree&quot; represents a particular directory state of a working directory, a &quot;commit&quot; represents that state in time, and explains how we got there.</source>
          <target state="translated">つまり、「ツリー」は作業ディレクトリの特定のディレクトリの状態を表しているのに対し、「コミット」はその状態を時間的に表しており、そこに至るまでの経緯を説明しています。</target>
        </trans-unit>
        <trans-unit id="857191c898a7fbefd37c145d86f76b0005dd57eb" translate="yes" xml:space="preserve">
          <source>In other words, you can easily validate a whole archive by just sending out a single email that tells the people the name (SHA-1 hash) of the top commit, and digitally sign that email using something like GPG/PGP.</source>
          <target state="translated">言い換えれば、トップコミットの名前 (SHA-1 ハッシュ)を知らせるメールを一通送信し、GPG/PGP のようなものを使って電子署名をするだけで、アーカイブ全体を簡単に検証することができます。</target>
        </trans-unit>
        <trans-unit id="e52122aac7e01b0550d02d6bfc5c4fbaa85b48ac" translate="yes" xml:space="preserve">
          <source>In our example of only two files, we did not have unchanged files so only &lt;code&gt;example&lt;/code&gt; resulted in collapsing. But in real-life large projects, when only a small number of files change in one commit, this &lt;code&gt;collapsing&lt;/code&gt; tends to trivially merge most of the paths fairly quickly, leaving only a handful of real changes in non-zero stages.</source>
          <target state="translated">ファイルが2つしかない &lt;code&gt;example&lt;/code&gt; は、変更されていないファイルはなかったため、例のみが折りたたまれました。しかし、実際の大規模なプロジェクトでは、1回のコミットで変更されるファイルの数が少ない場合、この &lt;code&gt;collapsing&lt;/code&gt; はほとんどのパスをかなり迅速にマージする傾向があり、ゼロ以外の段階ではほんの一部の実際の変更のみが残ります。</target>
        </trans-unit>
        <trans-unit id="a3569415a118c16e9c5d7e18e58096bbd8336f98" translate="yes" xml:space="preserve">
          <source>In our example, when you do the test merge, the manual resolution is recorded, and it will be reused when you do the actual merge later with the updated master and topic branch, as long as the recorded resolution is still applicable.</source>
          <target state="translated">この例では、テスト マージを行う際に手動の解決策が記録され、後で更新されたマスターブランチやトピックブランチを使用して実際のマージを行う際に、記録された解決策がまだ適用されている限り、その解決策が再利用されます。</target>
        </trans-unit>
        <trans-unit id="8e5ca17ff33890ba6e129c741e431196f019fa29" translate="yes" xml:space="preserve">
          <source>In overlay mode, the command never removes files when restoring. In no-overlay mode, tracked files that do not appear in the &lt;code&gt;--source&lt;/code&gt; tree are removed, to make them match &lt;code&gt;&amp;lt;tree&amp;gt;&lt;/code&gt; exactly. The default is no-overlay mode.</source>
          <target state="translated">オーバーレイモードでは、復元時にコマンドがファイルを削除することはありません。オーバーレイなしモードでは、追跡されたファイルは &lt;code&gt;--source&lt;/code&gt; ツリーに表示されず、 &lt;code&gt;&amp;lt;tree&amp;gt;&lt;/code&gt; と完全に一致するように削除されます。デフォルトはオーバーレイなしモードです。</target>
        </trans-unit>
        <trans-unit id="5b1c0d5c1dcebbb2369ea9f003ec30402ee8a395" translate="yes" xml:space="preserve">
          <source>In particular, let&amp;rsquo;s not even check in the two files into Git yet, we&amp;rsquo;ll start off by adding another line to &lt;code&gt;hello&lt;/code&gt; first:</source>
          <target state="translated">特に、まだ2つのファイルをGitにチェックインしないでください。最初に、 &lt;code&gt;hello&lt;/code&gt; に別の行を追加することから始めます。</target>
        </trans-unit>
        <trans-unit id="d0e454374a9a3ee3d6a441cd0674139a3f061022" translate="yes" xml:space="preserve">
          <source>In particular, the &lt;code&gt;refs&lt;/code&gt; subdirectory will contain two other subdirectories, named &lt;code&gt;heads&lt;/code&gt; and &lt;code&gt;tags&lt;/code&gt; respectively. They do exactly what their names imply: they contain references to any number of different &lt;code&gt;heads&lt;/code&gt; of development (aka &lt;code&gt;branches&lt;/code&gt;), and to any &lt;code&gt;tags&lt;/code&gt; that you have created to name specific versions in your repository.</source>
          <target state="translated">特に、 &lt;code&gt;refs&lt;/code&gt; サブディレクトリには、 &lt;code&gt;heads&lt;/code&gt; と &lt;code&gt;tags&lt;/code&gt; という名前の2つのサブディレクトリがそれぞれ含まれます。それらは、その名前が意味することを正確に実行します。それらには、開発のさまざまな &lt;code&gt;heads&lt;/code&gt; （別名 &lt;code&gt;branches&lt;/code&gt; ）への参照、およびリポジトリ内の特定のバージョンに名前を付けるために作成した &lt;code&gt;tags&lt;/code&gt; への参照が含まれます。</target>
        </trans-unit>
        <trans-unit id="2037a0a7d55894c0e552cd3905604e14aef5f5cc" translate="yes" xml:space="preserve">
          <source>In practice, you can interleave and repeat steps 1 and 2 as many times as you want: in order to keep track of what you want committed at step 3, Git maintains a snapshot of the tree&amp;rsquo;s contents in a special staging area called &quot;the index.&quot;</source>
          <target state="translated">実際には、ステップ1と2を何度でもインターリーブして繰り返すことができます。ステップ3でコミットしたい内容を追跡するために、Gitは「インデックス」と呼ばれる特別なステージング領域にツリーのコンテンツのスナップショットを保持します」</target>
        </trans-unit>
        <trans-unit id="f0e4ad3997791ffc68facd5c602055afb63229a5" translate="yes" xml:space="preserve">
          <source>In principle, a note is a regular Git blob, and any kind of (non-)format is accepted. You can binary-safely create notes from arbitrary files using &lt;code&gt;git hash-object&lt;/code&gt;:</source>
          <target state="translated">原則として、ノートは通常のGit blobであり、あらゆる種類の（非）形式が受け入れられます。 &lt;code&gt;git hash-object&lt;/code&gt; を使用して、任意のファイルからバイナリセーフにノートを作成できます。</target>
        </trans-unit>
        <trans-unit id="4601fb728bee4aeccfe338414983070eaafe0d7b" translate="yes" xml:space="preserve">
          <source>In protocol v2 communication is command oriented. When first contacting a server a list of capabilities will advertised. Some of these capabilities will be commands which a client can request be executed. Once a command has completed, a client can reuse the connection and request that other commands be executed.</source>
          <target state="translated">プロトコルv2では、通信はコマンド指向です。最初にサーバにコンタクトするとき、能力のリストがアドバタイズされます。これらの能力のいくつかは、クライアントが実行を要求できるコマンドになります。コマンドが完了すると、クライアントは接続を再利用し、他のコマンドの実行を要求することができます。</target>
        </trans-unit>
        <trans-unit id="f1e89ddf0408f3e3f9aa71b3da7906ab579cf106" translate="yes" xml:space="preserve">
          <source>In protocol v2 these special packets will have the following semantics:</source>
          <target state="translated">プロトコルv2では、これらの特別なパケットは以下のセマンティクスを持つことになります。</target>
        </trans-unit>
        <trans-unit id="0b2a25ba5b09240510379a9523ee7fbbaeebe9c6" translate="yes" xml:space="preserve">
          <source>In some cases it is possible that the new head will &lt;strong&gt;not&lt;/strong&gt; actually be a descendant of the old head. For example, the developer may have realized she made a serious mistake, and decided to backtrack, resulting in a situation like:</source>
          <target state="translated">場合によっては、新しいヘッドが実際に古いヘッドの子孫に&lt;strong&gt;ならない&lt;/strong&gt;可能性があります。たとえば、開発者は重大なミスを犯したことに気づき、バックトラックすることにしたため、次のような状況が発生した可能性があります。</target>
        </trans-unit>
        <trans-unit id="013d925394580efad8fc98d09cd78b65808be1a0" translate="yes" xml:space="preserve">
          <source>In some cases like for kernel development it can be worth developing complex scripts to be able to fully automate bisecting.</source>
          <target state="translated">カーネル開発のような場合には、複雑なスクリプトを開発して二分法を完全に自動化できるようにすることに価値があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="0a49ce3de43e8ee8d78f327f1f504c6a86228a99" translate="yes" xml:space="preserve">
          <source>In some situations the reflog may not be able to save you. For example, suppose you delete a branch, then realize you need the history it contained. The reflog is also deleted; however, if you have not yet pruned the repository, then you may still be able to find the lost commits in the dangling objects that &lt;code&gt;git fsck&lt;/code&gt; reports. See &lt;a href=&quot;#dangling-objects&quot;&gt;Dangling objects&lt;/a&gt; for the details.</source>
          <target state="translated">状況によっては、reflogで保存できない場合があります。たとえば、ブランチを削除し、そのブランチに含まれる履歴が必要であると認識したとします。reflogも削除されます。ただし、まだリポジトリをプルーニングしていない場合でも、 &lt;code&gt;git fsck&lt;/code&gt; が報告するダングリングオブジェクトで失われたコミットを見つけることができる場合があります。詳細については、&lt;a href=&quot;#dangling-objects&quot;&gt;ダングリングオブジェクト&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="4f2c24901ef5f6fa3a7b78ff609de06af9cfd2f7" translate="yes" xml:space="preserve">
          <source>In sparse checkout mode, &lt;code&gt;git checkout -- &amp;lt;paths&amp;gt;&lt;/code&gt; would update only entries matched by &lt;code&gt;&amp;lt;paths&amp;gt;&lt;/code&gt; and sparse patterns in &lt;code&gt;$GIT_DIR/info/sparse-checkout&lt;/code&gt;. This option ignores the sparse patterns and adds back any files in &lt;code&gt;&amp;lt;paths&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">スパースチェックアウトモードでは、 &lt;code&gt;git checkout -- &amp;lt;paths&amp;gt;&lt;/code&gt; にマッチしたエントリのみを更新します &lt;code&gt;&amp;lt;paths&amp;gt;&lt;/code&gt; にあるとスパースパターン &lt;code&gt;$GIT_DIR/info/sparse-checkout&lt;/code&gt; 。このオプションは、スパースパターンを無視し、 &lt;code&gt;&amp;lt;paths&amp;gt;&lt;/code&gt; 内のファイルを追加します。</target>
        </trans-unit>
        <trans-unit id="91e2068ee07240a386da6a01584d7cb7bf48667f" translate="yes" xml:space="preserve">
          <source>In sparse checkout mode, by default is to only update entries matched by &lt;code&gt;&amp;lt;pathspec&amp;gt;&lt;/code&gt; and sparse patterns in $GIT_DIR/info/sparse-checkout. This option ignores the sparse patterns and unconditionally restores any files in &lt;code&gt;&amp;lt;pathspec&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">疎チェックアウトモードでは、デフォルトで &lt;code&gt;&amp;lt;pathspec&amp;gt;&lt;/code&gt; に一致するエントリと$ GIT_DIR / info / sparse-checkoutの疎パターンのみを更新します。このオプションはスパースパターンを無視し、 &lt;code&gt;&amp;lt;pathspec&amp;gt;&lt;/code&gt; 内のファイルを無条件で復元します。</target>
        </trans-unit>
        <trans-unit id="9805e95abc4cc7297991de78ec147328f379f9f9" translate="yes" xml:space="preserve">
          <source>In such a case, &lt;code&gt;git merge-base origin/master topic&lt;/code&gt; would return the parent of B0 in the above picture, but B0^..D is &lt;strong&gt;not&lt;/strong&gt; the range of commits you would want to replay on top of B (it includes B0, which is not what you wrote; it is a commit the other side discarded when it moved its tip from B0 to B1).</source>
          <target state="translated">このような場合、 &lt;code&gt;git merge-base origin/master topic&lt;/code&gt; は上の画像のB0の親を返しますが、B0 ^ .. DはBの上で再生するコミットの範囲ではあり&lt;strong&gt;ません&lt;/strong&gt;（B0を含み、これはあなたが書いたものではありません;チップをB0からB1に移動したときに破棄された反対側のコミットです）。</target>
        </trans-unit>
        <trans-unit id="38c59b4cda1fb890b6373e0ee120752a69f46faf" translate="yes" xml:space="preserve">
          <source>In such a case, you can &quot;unwrap&quot; the tag yourself before feeding it to &lt;code&gt;git merge&lt;/code&gt;, or pass &lt;code&gt;--ff-only&lt;/code&gt; when you do not have any work on your own. e.g.</source>
          <target state="translated">このような場合、タグを &lt;code&gt;git merge&lt;/code&gt; に送る前に自分で「 &lt;code&gt;--ff-only&lt;/code&gt; 解除」するか、自分で作業を行わない場合は--ff-onlyを渡すことができます。例えば</target>
        </trans-unit>
        <trans-unit id="122c6a9f6232138a6047defa817d1eec04cb3f10" translate="yes" xml:space="preserve">
          <source>In such a case, you do not want to automatically follow the other person&amp;rsquo;s tags.</source>
          <target state="translated">そのような場合、他の人のタグを自動的にフォローしたくないでしょう。</target>
        </trans-unit>
        <trans-unit id="14b066e7c220e701d278a048087bd2ff212888b8" translate="yes" xml:space="preserve">
          <source>In such cases it can be very confusing to use the terms &quot;good&quot; and &quot;bad&quot; to refer to &quot;the state before the change&quot; and &quot;the state after the change&quot;. So instead, you can use the terms &quot;old&quot; and &quot;new&quot;, respectively, in place of &quot;good&quot; and &quot;bad&quot;. (But note that you cannot mix &quot;good&quot; and &quot;bad&quot; with &quot;old&quot; and &quot;new&quot; in a single session.)</source>
          <target state="translated">このような場合、「変化する前の状態」と「変化した後の状態」を「良い」「悪い」という言葉で表現するのは、非常に混乱を招きます。そこで、&quot;good &quot;と &quot;bad &quot;の代わりに、&quot;old &quot;と &quot;new &quot;という用語をそれぞれ使うことができます。(ただし、&quot;good &quot;と &quot;bad &quot;を &quot;old &quot;と &quot;new &quot;と混ぜて使うことはできないことに注意してください)。</target>
        </trans-unit>
        <trans-unit id="abac94a936763ce45a21b8291dbe11f8fcd73ae6" translate="yes" xml:space="preserve">
          <source>In such cases, git-cherry shows a concise summary of what has yet to be applied:</source>
          <target state="translated">そのような場合、git-cherryはまだ適用されていないものを簡潔にまとめて表示します。</target>
        </trans-unit>
        <trans-unit id="46cccce64f7cd9f50066dd3d9623630b5fee1925" translate="yes" xml:space="preserve">
          <source>In that case, &lt;code&gt;git pull&lt;/code&gt; can do the fetch and merge in one go, as follows.</source>
          <target state="translated">その場合、次のように &lt;code&gt;git pull&lt;/code&gt; でフェッチとマージを一度に実行できます。</target>
        </trans-unit>
        <trans-unit id="52b267d7dd12ef4e2f7423310ff8cbe9ef5b3665" translate="yes" xml:space="preserve">
          <source>In that case, the fix is easy because &lt;code&gt;git rebase&lt;/code&gt; knows to skip changes that are already present in the new upstream (unless &lt;code&gt;--reapply-cherry-picks&lt;/code&gt; is given). So if you say (assuming you&amp;rsquo;re on &lt;code&gt;topic&lt;/code&gt;)</source>
          <target state="translated">その場合、 &lt;code&gt;git rebase&lt;/code&gt; は新しいアップストリームにすでに存在する変更をスキップすることを知っているため、修正は簡単です（ &lt;code&gt;--reapply-cherry-picks&lt;/code&gt; が指定されていない場合）。だからあなたが言うなら（あなたが &lt;code&gt;topic&lt;/code&gt; いると仮定して）</target>
        </trans-unit>
        <trans-unit id="724c7d4dfedb54b8a53a948ec5bdabaee78995fb" translate="yes" xml:space="preserve">
          <source>In that case, the fix is easy because &lt;code&gt;git rebase&lt;/code&gt; knows to skip changes that are already present in the new upstream. So if you say (assuming you&amp;rsquo;re on &lt;code&gt;topic&lt;/code&gt;)</source>
          <target state="translated">その場合、 &lt;code&gt;git rebase&lt;/code&gt; は新しいアップストリームにすでに存在する変更をスキップすることを知っているため、修正は簡単です。だからあなたが言うなら（あなたが &lt;code&gt;topic&lt;/code&gt; いると仮定して）</target>
        </trans-unit>
        <trans-unit id="e2f5cdfecd5b61a82b453fde83701ee64b8d8237" translate="yes" xml:space="preserve">
          <source>In that case, you can still force Git to update to the new head, as described in the following section. However, note that in the situation above this may mean losing the commits labeled &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, unless you&amp;rsquo;ve already created a reference of your own pointing to them.</source>
          <target state="translated">その場合でも、次のセクションで説明するように、Gitを強制的に新しいヘッドに更新することができます。ただし、上記の状況で &lt;code&gt;a&lt;/code&gt; 、 &lt;code&gt;b&lt;/code&gt; およびbというラベルの付いたコミットを失うことを意味する場合があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="23201c1eda40e4016771870c9d54dd5324857456" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;git push&lt;/code&gt; command above we specify the name of the remote branch to update (&lt;code&gt;master&lt;/code&gt;). If we leave that out, &lt;code&gt;git push&lt;/code&gt; tries to update any branches in the remote repository that have the same name as a branch in the local repository. So the last &lt;code&gt;push&lt;/code&gt; can be done with either of:</source>
          <target state="translated">上記の &lt;code&gt;git push&lt;/code&gt; コマンドでは、更新するリモートブランチ（ &lt;code&gt;master&lt;/code&gt; ）の名前を指定します。それを省略した場合、 &lt;code&gt;git push&lt;/code&gt; はローカルリポジトリのブランチと同じ名前を持つリモートリポジトリのブランチを更新しようとします。したがって、最後の &lt;code&gt;push&lt;/code&gt; は次のいずれかで実行できます。</target>
        </trans-unit>
        <trans-unit id="090c003198124abd0a59f9db99cb23a0a9d08a0d" translate="yes" xml:space="preserve">
          <source>In the above config only the submodule &lt;code&gt;bar&lt;/code&gt; and &lt;code&gt;baz&lt;/code&gt; are active, &lt;code&gt;bar&lt;/code&gt; due to (1) and &lt;code&gt;baz&lt;/code&gt; due to (3). &lt;code&gt;foo&lt;/code&gt; is inactive because (1) takes precedence over (3)</source>
          <target state="translated">上記の設定では、サブモジュール &lt;code&gt;bar&lt;/code&gt; と &lt;code&gt;baz&lt;/code&gt; のみがアクティブで、 &lt;code&gt;bar&lt;/code&gt; は（1）のため、 &lt;code&gt;baz&lt;/code&gt; は（3）のためです。（1）が（3）よりも優先されるため、 &lt;code&gt;foo&lt;/code&gt; は非アクティブです</target>
        </trans-unit>
        <trans-unit id="f2615d435cf358760e53af78267e9744a2a4cd7e" translate="yes" xml:space="preserve">
          <source>In the above example output, the function signature was changed from both files (hence two &lt;code&gt;-&lt;/code&gt; removals from both file1 and file2, plus &lt;code&gt;++&lt;/code&gt; to mean one line that was added does not appear in either file1 or file2). Also eight other lines are the same from file1 but do not appear in file2 (hence prefixed with &lt;code&gt;+&lt;/code&gt;).</source>
          <target state="translated">上記の出力例では、関数のシグネチャは、両方のファイル（従って2から変更されました &lt;code&gt;-&lt;/code&gt; file1とfile2の両方から削除、プラス &lt;code&gt;++&lt;/code&gt; を加えた一行のいずれかFILE1またはFILE2に表示されていないを意味します）。また、他の8行はfile1と同じですが、file2には表示されません（そのため、接頭辞 &lt;code&gt;+&lt;/code&gt; が付いています）。</target>
        </trans-unit>
        <trans-unit id="236d1518399c3b158b7b503f699f9dfd06244979" translate="yes" xml:space="preserve">
          <source>In the above example we have N = 8, so this will give:</source>
          <target state="translated">上の例ではn=8なので、これで与えられます。</target>
        </trans-unit>
        <trans-unit id="4faa5ab35bd05c089c7f00cb50d40bc6a34dd151" translate="yes" xml:space="preserve">
          <source>In the case where the input consists entirely of whitespace characters, no output will be produced.</source>
          <target state="translated">入力がすべて空白文字で構成されている場合は、出力されません。</target>
        </trans-unit>
        <trans-unit id="6722ed28b0a968c96593a6b207713cd0f24f7d3a" translate="yes" xml:space="preserve">
          <source>In the check-in codepath, the worktree file is first converted with &lt;code&gt;filter&lt;/code&gt; driver (if specified and corresponding driver defined), then the result is processed with &lt;code&gt;ident&lt;/code&gt; (if specified), and then finally with &lt;code&gt;text&lt;/code&gt; (again, if specified and applicable).</source>
          <target state="translated">チェックインコードパスでは、ワークツリーファイルはまず &lt;code&gt;filter&lt;/code&gt; ドライバー（指定されていて対応するドライバーが定義されている場合）で変換され、次に &lt;code&gt;ident&lt;/code&gt; （指定されている場合）で処理され、最後に &lt;code&gt;text&lt;/code&gt; （指定されている場合は適用可能）で処理されます。 。</target>
        </trans-unit>
        <trans-unit id="41a87794ee334f48f97053e2010dfe2b224b3e78" translate="yes" xml:space="preserve">
          <source>In the check-out codepath, the blob content is first converted with &lt;code&gt;text&lt;/code&gt;, and then &lt;code&gt;ident&lt;/code&gt; and fed to &lt;code&gt;filter&lt;/code&gt;.</source>
          <target state="translated">チェックアウトコードパスでは、blobコンテンツはまず &lt;code&gt;text&lt;/code&gt; で変換され、次に &lt;code&gt;ident&lt;/code&gt; されて &lt;code&gt;filter&lt;/code&gt; 送られます。</target>
        </trans-unit>
        <trans-unit id="113fa915b38684bf235e931affc2401ec6de4a63" translate="yes" xml:space="preserve">
          <source>In the cone mode case, the &lt;code&gt;git sparse-checkout list&lt;/code&gt; subcommand will list the directories that define the recursive patterns. For the example sparse-checkout file above, the output is as follows:</source>
          <target state="translated">コーンモードの場合、 &lt;code&gt;git sparse-checkout list&lt;/code&gt; サブコマンドは、再帰的なパターンを定義するディレクトリを一覧表示します。上記のスパースチェックアウトファイルの例では、出力は次のようになります。</target>
        </trans-unit>
        <trans-unit id="50d1a515997c60c54243bae252639aa03db105b6" translate="yes" xml:space="preserve">
          <source>In the default overlay mode, &lt;code&gt;git checkout&lt;/code&gt; never removes files from the index or the working tree. When specifying &lt;code&gt;--no-overlay&lt;/code&gt;, files that appear in the index and working tree, but not in &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; are removed, to make them match &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; exactly.</source>
          <target state="translated">デフォルトのオーバーレイモードでは、 &lt;code&gt;git checkout&lt;/code&gt; がインデックスまたは作業ツリーからファイルを削除することはありません。 &lt;code&gt;--no-overlay&lt;/code&gt; を指定すると、インデックスと作業ツリーには表示されるが、 &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; には表示されないファイルは削除され、 &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; と完全に一致します。</target>
        </trans-unit>
        <trans-unit id="6cdd96542ff31058533f7beb40eadd124991c8c5" translate="yes" xml:space="preserve">
          <source>In the early days, Git (in the tradition of UNIX) was a bunch of programs which were extremely simple, and which you used in scripts, piping the output of one into another. This turned out to be good for initial development, since it was easier to test new things. However, recently many of these parts have become builtins, and some of the core has been &quot;libified&quot;, i.e. put into libgit.a for performance, portability reasons, and to avoid code duplication.</source>
          <target state="translated">初期の頃は、(UNIXの伝統の中での)Gitは非常にシンプルなプログラムの集まりで、スクリプトの中で使用し、その出力を別のものにパイプで繋いでいました。これは、新しいものをテストするのが簡単だったので、初期の開発には適していました。しかし、最近では、これらの部分の多くがビルドイン化され、コアの一部は「libified」されました。</target>
        </trans-unit>
        <trans-unit id="5c0100c9df6abb7d7f1348c7fe307c535cc01a6e" translate="yes" xml:space="preserve">
          <source>In the examples, the following &lt;code&gt;.gitattributes&lt;/code&gt; file is used:</source>
          <target state="translated">例では、次の &lt;code&gt;.gitattributes&lt;/code&gt; ファイルが使用されています。</target>
        </trans-unit>
        <trans-unit id="cc3fe53f7a76d1235b536b2f3e4aace1aeafd632" translate="yes" xml:space="preserve">
          <source>In the external editor window, read in the patch file and exit the editor normally.</source>
          <target state="translated">外部エディタのウィンドウで、パッチファイルを読み込んで、通常通りエディタを終了します。</target>
        </trans-unit>
        <trans-unit id="8ef2e6de3f32f727ff12807f3683863dc57cb535" translate="yes" xml:space="preserve">
          <source>In the first form, it renames &amp;lt;source&amp;gt;, which must exist and be either a file, symlink or directory, to &amp;lt;destination&amp;gt;. In the second form, the last argument has to be an existing directory; the given sources will be moved into this directory.</source>
          <target state="translated">最初の形式では、存在する必要があり、ファイル、シンボリックリンク、またはディレクトリのいずれかである&amp;lt;source&amp;gt;の名前を&amp;lt;destination&amp;gt;に変更します。2番目の形式では、最後の引数は既存のディレクトリでなければなりません。指定されたソースはこのディレクトリに移動されます。</target>
        </trans-unit>
        <trans-unit id="76aeefd352a6b656fb05dc49a2aa92d1acbe97ce" translate="yes" xml:space="preserve">
          <source>In the first three forms, copy entries from &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; to the index. In the last form, set the current branch head (&lt;code&gt;HEAD&lt;/code&gt;) to &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt;, optionally modifying index and working tree to match. The &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt;/&lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; defaults to &lt;code&gt;HEAD&lt;/code&gt; in all forms.</source>
          <target state="translated">最初の3つの形式で、 &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; からインデックスにエントリをコピーします。最後のフォームで、現在のブランチヘッド（ &lt;code&gt;HEAD&lt;/code&gt; ）を &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; に設定します。オプションで、インデックスと作業ツリーを一致するように変更します。 &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; / &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; にデフォルトを &lt;code&gt;HEAD&lt;/code&gt; すべてのフォームで。</target>
        </trans-unit>
        <trans-unit id="ef10a113d8afc34781099a24e1e343890650a1e1" translate="yes" xml:space="preserve">
          <source>In the following example, the developer works on a topic branch that refactors the way buttons are defined, and on another topic branch that uses that refactoring to implement a &quot;Report a bug&quot; button. The output of &lt;code&gt;git log --graph --format=%s -5&lt;/code&gt; may look like this:</source>
          <target state="translated">次の例では、開発者はボタンの定義方法をリファクタリングするトピックブランチと、そのリファクタリングを使用して「バグの報告」ボタンを実装する別のトピックブランチで作業します。 &lt;code&gt;git log --graph --format=%s -5&lt;/code&gt; の出力は次のようになります。</target>
        </trans-unit>
        <trans-unit id="e8d35f4a27576cd3ee599047c232398088d285ec" translate="yes" xml:space="preserve">
          <source>In the following, we list all defined capabilities and for each we list which commands a helper with that capability must provide.</source>
          <target state="translated">以下では、定義されたすべてのケイパビリティをリストアップし、それぞれについて、そのケイパビリティを持つヘルパーが提供しなければならないコマンドをリストアップします。</target>
        </trans-unit>
        <trans-unit id="c56abbab61e08007b56db2739d2660b32ff3baf6" translate="yes" xml:space="preserve">
          <source>In the following, we say that commit X is &quot;reachable&quot; from commit Y if commit X is an ancestor of commit Y. Equivalently, you could say that Y is a descendant of X, or that there is a chain of parents leading from commit Y to commit X.</source>
          <target state="translated">以下では、コミットXがコミットYの先祖である場合、コミットXはコミットYから「到達可能」であると言います。</target>
        </trans-unit>
        <trans-unit id="2ab0015fa4bf468aa51dfb7b06e67d10a59ee05a" translate="yes" xml:space="preserve">
          <source>In the following, we will always refer to the same example history to illustrate the differences between simplification settings. We assume that you are filtering for a file &lt;code&gt;foo&lt;/code&gt; in this commit graph:</source>
          <target state="translated">以下では、単純化設定の違いを説明するために常に同じ例の履歴を参照します。このコミットグラフでファイル &lt;code&gt;foo&lt;/code&gt; をフィルタリングしていると想定します。</target>
        </trans-unit>
        <trans-unit id="1a1825758e9c1b0f3cada9dea61b97f18e404ba1" translate="yes" xml:space="preserve">
          <source>In the ideal world, you could have realized that the earlier commit did not belong to the new topic when you created and switched to &lt;code&gt;branch2&lt;/code&gt; (i.e. &lt;code&gt;git switch -c branch2 start&lt;/code&gt;), but nobody is perfect.</source>
          <target state="translated">理想的な世界では、 &lt;code&gt;branch2&lt;/code&gt; を作成してブランチ2に切り替えたとき（つまり、 &lt;code&gt;git switch -c branch2 start&lt;/code&gt; ）、以前のコミットが新しいトピックに属していないことに気付いたかもしれませんが、誰も完璧ではありません。</target>
        </trans-unit>
        <trans-unit id="d370a0f8ed20ae4cd4e933b9beff011b3187e6ad" translate="yes" xml:space="preserve">
          <source>In the long form, the leading colon &lt;code&gt;:&lt;/code&gt; is followed by an open parenthesis &lt;code&gt;(&lt;/code&gt;, a comma-separated list of zero or more &quot;magic words&quot;, and a close parentheses &lt;code&gt;)&lt;/code&gt;, and the remainder is the pattern to match against the path.</source>
          <target state="translated">長い形式では、先頭のコロン &lt;code&gt;:&lt;/code&gt; の後に開き括弧 &lt;code&gt;(&lt;/code&gt; 、0個以上の「マジックワード」のコンマ区切りリスト、および閉じ括弧 &lt;code&gt;)&lt;/code&gt; が続き、残りはパスと照合するパターンです。</target>
        </trans-unit>
        <trans-unit id="ecbb466c633c8f376663d1974093b0b801e94fbc" translate="yes" xml:space="preserve">
          <source>In the main Thunderbird window, &lt;code&gt;before&lt;/code&gt; you open the compose window for the patch, use Tools&amp;rarr;about:config to set the following to the indicated values:</source>
          <target state="translated">Thunderbirdのメインウィンドウで、パッチの作成ウィンドウを開く &lt;code&gt;before&lt;/code&gt; 、[ツール]&amp;rarr;[about：config]を使用して、以下を指定の値に設定します。</target>
        </trans-unit>
        <trans-unit id="3f70c7e45d5c392e715fb2023b23a65e5f20b82a" translate="yes" xml:space="preserve">
          <source>In the output from &lt;code&gt;git show-branch&lt;/code&gt;, &lt;code&gt;master&lt;/code&gt; should have everything &lt;code&gt;ko/master&lt;/code&gt; has, and &lt;code&gt;next&lt;/code&gt; should have everything &lt;code&gt;ko/next&lt;/code&gt; has, etc.</source>
          <target state="translated">以下からの出力で &lt;code&gt;git show-branch&lt;/code&gt; 、 &lt;code&gt;master&lt;/code&gt; すべて持っている必要があり &lt;code&gt;ko/master&lt;/code&gt; あり、そして &lt;code&gt;next&lt;/code&gt; すべてのものが必要です &lt;code&gt;ko/next&lt;/code&gt; 持っている、など</target>
        </trans-unit>
        <trans-unit id="9fb474287214ed4886618f1399ff63bbd11f6810" translate="yes" xml:space="preserve">
          <source>In the pager (&lt;code&gt;less&lt;/code&gt;), just search for &quot;bundle&quot;, go a few lines back, and see that it is in commit 18449ab0. Now just copy this object name, and paste it into the command line</source>
          <target state="translated">ページャー（ &lt;code&gt;less&lt;/code&gt; ）で、「bundle」を検索し、数行戻って、コミット18449ab0であることを確認します。このオブジェクト名をコピーして、コマンドラインに貼り付けます</target>
        </trans-unit>
        <trans-unit id="5fc7016d20b7cd82938bb283d4d8443cc61835c8" translate="yes" xml:space="preserve">
          <source>In the past, &lt;code&gt;.git/HEAD&lt;/code&gt; was a symbolic link pointing at &lt;code&gt;refs/heads/master&lt;/code&gt;. When we wanted to switch to another branch, we did &lt;code&gt;ln -sf refs/heads/newbranch .git/HEAD&lt;/code&gt;, and when we wanted to find out which branch we are on, we did &lt;code&gt;readlink .git/HEAD&lt;/code&gt;. But symbolic links are not entirely portable, so they are now deprecated and symbolic refs (as described above) are used by default.</source>
          <target state="translated">以前は、 &lt;code&gt;.git/HEAD&lt;/code&gt; は &lt;code&gt;refs/heads/master&lt;/code&gt; を指すシンボリックリンクでした。別のブランチに切り替える場合は &lt;code&gt;ln -sf refs/heads/newbranch .git/HEAD&lt;/code&gt; を実行し、どのブランチにいるかを確認する場合は &lt;code&gt;readlink .git/HEAD&lt;/code&gt; を実行しました。ただし、シンボリックリンクは完全に移植可能ではないため、廃止され、シンボリック参照（上記のとおり）がデフォルトで使用されます。</target>
        </trans-unit>
        <trans-unit id="8dfab80b468101639bf9d627830b7559e865891a" translate="yes" xml:space="preserve">
          <source>In the previous example, when updating an existing branch, &lt;code&gt;git fetch&lt;/code&gt; checks to make sure that the most recent commit on the remote branch is a descendant of the most recent commit on your copy of the branch before updating your copy of the branch to point at the new commit. Git calls this process a &lt;a href=&quot;#fast-forwards&quot;&gt;fast-forward&lt;/a&gt;.</source>
          <target state="translated">前の例では、既存のブランチを更新する場合、 &lt;code&gt;git fetch&lt;/code&gt; は、ブランチのコピーを更新する前に、リモートブランチの最新のコミットがブランチのコピーの最新のコミットの子孫であることを確認します。新しいコミット。Gitはこのプロセスを&lt;a href=&quot;#fast-forwards&quot;&gt;早送り&lt;/a&gt;と呼びます。</target>
        </trans-unit>
        <trans-unit id="39fc6243d8461e10163ad54b5cc61dfd9c9ca8f0" translate="yes" xml:space="preserve">
          <source>In the process of undoing a previous bad change, you may find it useful to check out an older version of a particular file using &lt;a href=&quot;git-restore&quot;&gt;git-restore[1]&lt;/a&gt;. The command</source>
          <target state="translated">以前の悪い変更を元に戻す過程で、&lt;a href=&quot;git-restore&quot;&gt;git-restore [1]&lt;/a&gt;を使用して特定のファイルの古いバージョンをチェックアウトすると便利な場合があります。コマンド</target>
        </trans-unit>
        <trans-unit id="ce5a30d6d89274fe8c4b93a655981ad3cb2875fa" translate="yes" xml:space="preserve">
          <source>In the process, it may discover conflicts. In that case it will stop and allow you to fix the conflicts; after fixing conflicts, use &lt;code&gt;git add&lt;/code&gt; to update the index with those contents, and then, instead of running &lt;code&gt;git commit&lt;/code&gt;, just run</source>
          <target state="translated">その過程で、それは衝突を発見するかもしれません。その場合、停止して競合を修正できます。競合を固定した後、使用が &lt;code&gt;git add&lt;/code&gt; 代わりに実行しているのは、これらの内容にインデックスを更新すると、 &lt;code&gt;git commit&lt;/code&gt; 、単に実行を</target>
        </trans-unit>
        <trans-unit id="ecd16080120d9546efe5335b66c01332d8bc5340" translate="yes" xml:space="preserve">
          <source>In the second form, a list of objects (separated by linefeeds) is provided on stdin, and the SHA-1, type, and size of each object is printed on stdout. The output format can be overridden using the optional &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; argument. If either &lt;code&gt;--textconv&lt;/code&gt; or &lt;code&gt;--filters&lt;/code&gt; was specified, the input is expected to list the object names followed by the path name, separated by a single whitespace, so that the appropriate drivers can be determined.</source>
          <target state="translated">2番目の形式では、オブジェクトのリスト（改行で区切られた）がstdinに提供され、各オブジェクトのSHA-1、タイプ、およびサイズがstdoutに出力されます。オプションの &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; 引数を使用して、出力形式を上書きできます。 &lt;code&gt;--textconv&lt;/code&gt; または &lt;code&gt;--filters&lt;/code&gt; のいずれかが指定された場合、入力には、適切なドライバーを判別できるように、オブジェクト名の後にパス名を1つの空白で区切ってリストすることが期待されます。</target>
        </trans-unit>
        <trans-unit id="909b0b19015ead3714bd1690a7877da1cf97f4fa" translate="yes" xml:space="preserve">
          <source>In the short-format, the status of each path is shown as one of these forms</source>
          <target state="translated">ショートフォーマットでは、各パスの状態は以下のいずれかの形式で表示されます。</target>
        </trans-unit>
        <trans-unit id="abe3a521aeac4a8adcc3faf0711763fbfd40b505" translate="yes" xml:space="preserve">
          <source>In the simple form, each line in the file consists of the canonical real name of an author, whitespace, and an email address used in the commit (enclosed by &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt;) to map to the name. For example:</source>
          <target state="translated">単純な形式では、ファイルの各行は、著者の正規の本名、空白、および名前にマップするためにコミットで使用されるメールアドレス（ &lt;code&gt;&amp;lt;&lt;/code&gt; と &lt;code&gt;&amp;gt;&lt;/code&gt; で囲まれています）で構成されています。例えば：</target>
        </trans-unit>
        <trans-unit id="eecf34aeaad64fff7ea38378d33edc5335145626" translate="yes" xml:space="preserve">
          <source>In these cases you can tell Git the encoding of a file in the working directory with the &lt;code&gt;working-tree-encoding&lt;/code&gt; attribute. If a file with this attribute is added to Git, then Git re-encodes the content from the specified encoding to UTF-8. Finally, Git stores the UTF-8 encoded content in its internal data structure (called &quot;the index&quot;). On checkout the content is re-encoded back to the specified encoding.</source>
          <target state="translated">これらの場合、 &lt;code&gt;working-tree-encoding&lt;/code&gt; 属性を使用して、作業ディレクトリー内のファイルのエンコードをGitに指示できます。この属性を持つファイルがGitに追加されると、Gitは指定されたエンコーディングからUTF-8にコンテンツを再エンコードします。最後に、GitはUTF-8でエンコードされたコンテンツを内部データ構造（「インデックス」と呼ばれます）に格納します。チェックアウト時に、コンテンツは指定されたエンコーディングに再エンコードされます。</target>
        </trans-unit>
        <trans-unit id="5322604525a9aed1b9bf470c8d7df77aa5a14cc1" translate="yes" xml:space="preserve">
          <source>In these tables, &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;D&lt;/code&gt; are some different states of a file. For example, the first line of the first table means that if a file is in state &lt;code&gt;A&lt;/code&gt; in the working tree, in state &lt;code&gt;B&lt;/code&gt; in the index, in state &lt;code&gt;C&lt;/code&gt; in &lt;code&gt;HEAD&lt;/code&gt; and in state &lt;code&gt;D&lt;/code&gt; in the target, then &lt;code&gt;git reset --soft
target&lt;/code&gt; will leave the file in the working tree in state &lt;code&gt;A&lt;/code&gt; and in the index in state &lt;code&gt;B&lt;/code&gt;. It resets (i.e. moves) the &lt;code&gt;HEAD&lt;/code&gt; (i.e. the tip of the current branch, if you are on one) to &lt;code&gt;target&lt;/code&gt; (which has the file in state &lt;code&gt;D&lt;/code&gt;).</source>
          <target state="translated">これらの表では、 &lt;code&gt;A&lt;/code&gt; 、 &lt;code&gt;B&lt;/code&gt; 、 &lt;code&gt;C&lt;/code&gt; および &lt;code&gt;D&lt;/code&gt; はファイルのいくつかの異なる状態です。たとえば、最初のテーブルの最初の行は、ファイルが作業ツリーの状態 &lt;code&gt;A&lt;/code&gt; 、インデックスの状態 &lt;code&gt;B&lt;/code&gt; 、 &lt;code&gt;HEAD&lt;/code&gt; の状態 &lt;code&gt;C&lt;/code&gt; 、ターゲットの状態 &lt;code&gt;D&lt;/code&gt; にある場合、 &lt;code&gt;git reset --soft target&lt;/code&gt; は、ファイルを状態 &lt;code&gt;A&lt;/code&gt; の作業ツリーと状態 &lt;code&gt;B&lt;/code&gt; のインデックスに残します。 &lt;code&gt;HEAD&lt;/code&gt; （つまり、現在のブランチの先端（ある場合））を &lt;code&gt;target&lt;/code&gt; （ファイルの状態）にリセット（つまり移動）します。 &lt;code&gt;D&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="31d8ef3e97391069cf0655f41499162005f123c2" translate="yes" xml:space="preserve">
          <source>In these two shorthand notations, you can omit one end and let it default to HEAD. For example, &lt;code&gt;origin..&lt;/code&gt; is a shorthand for &lt;code&gt;origin..HEAD&lt;/code&gt; and asks &quot;What did I do since I forked from the origin branch?&quot; Similarly, &lt;code&gt;..origin&lt;/code&gt; is a shorthand for &lt;code&gt;HEAD..origin&lt;/code&gt; and asks &quot;What did the origin do since I forked from them?&quot; Note that &lt;code&gt;..&lt;/code&gt; would mean &lt;code&gt;HEAD..HEAD&lt;/code&gt; which is an empty range that is both reachable and unreachable from HEAD.</source>
          <target state="translated">これらの2つの省略表記では、一方の端を省略して、デフォルトでHEADにすることができます。たとえば、 &lt;code&gt;origin..&lt;/code&gt; は &lt;code&gt;origin..HEAD&lt;/code&gt; の省略形であり、「originブランチから分岐したので何をしましたか？」同様に、 &lt;code&gt;..origin&lt;/code&gt; はの省略形です &lt;code&gt;HEAD..origin&lt;/code&gt; 「私は彼らからフォークので、起源は何をしたの？」と尋ねます &lt;code&gt;..&lt;/code&gt; は &lt;code&gt;HEAD..HEAD&lt;/code&gt; を意味することに注意してください。これは、HEADから到達可能でも到達不可能でもない空の範囲です。</target>
        </trans-unit>
        <trans-unit id="fda0649080e4ad73be213a95d0150567b39a9905" translate="yes" xml:space="preserve">
          <source>In this case Git will attempt to undo the old change while leaving intact any changes made since then. If more recent changes overlap with the changes to be reverted, then you will be asked to fix conflicts manually, just as in the case of &lt;a href=&quot;#resolving-a-merge&quot;&gt;resolving a merge&lt;/a&gt;.</source>
          <target state="translated">この場合、Gitはそれ以降に加えられた変更をそのまま残しながら、古い変更を取り消そうとします。最近の変更が元に戻す変更と重複する場合&lt;a href=&quot;#resolving-a-merge&quot;&gt;、マージ&lt;/a&gt;を解決する場合と同様に、競合を手動で修正するように求められます。</target>
        </trans-unit>
        <trans-unit id="b7e31e9f418486f831893dd264d133713a86e996" translate="yes" xml:space="preserve">
          <source>In this case if you are bisecting manually, what you can do is create a special branch that starts just before the BBC. The first commit in this branch should be the BBC with the BFC squashed into it. And the other commits in the branch should be the commits between BBC and BFC rebased on the first commit of the branch and then the commit after BFC also rebased on.</source>
          <target state="translated">この場合、手動で二分するのであれば、BBC の直前に開始する特別なブランチを作成します。このブランチの最初のコミットは、BFC を押し込んだ BBC であるべきです。そして、このブランチの他のコミットは、BBC と BFC の間のコミットをブランチの最初のコミットにリベースしたものにし、BFC の後のコミットも同様にリベースしたものにします。</target>
        </trans-unit>
        <trans-unit id="717fbe628e5024a7ab31b6335fd291caf38b26b3" translate="yes" xml:space="preserve">
          <source>In this case this creates a totally new commit that is not related to anything else. Normally you do this only &lt;strong&gt;once&lt;/strong&gt; for a project ever, and all later commits will be parented on top of an earlier commit.</source>
          <target state="translated">この場合、これは何にも関係のないまったく新しいコミットを作成します。通常、プロジェクトに対してこれを行うのは一&lt;strong&gt;度&lt;/strong&gt;だけであり、それ以降のすべてのコミットは、以前のコミットの上にペアレント化されます。</target>
        </trans-unit>
        <trans-unit id="8d602afd53dc502b1f39532e44b808e7e4006de6" translate="yes" xml:space="preserve">
          <source>In this case we say that the HEAD is &quot;detached&quot;.</source>
          <target state="translated">この場合は、HEADが「離れている」と言います。</target>
        </trans-unit>
        <trans-unit id="84d70e62f46cda65cca1be0dfe61a185714e74d6" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;git fetch&lt;/code&gt; will fail, and print out a warning.</source>
          <target state="translated">この場合、 &lt;code&gt;git fetch&lt;/code&gt; は失敗し、警告が出力されます。</target>
        </trans-unit>
        <trans-unit id="ec2a36fb392a8671d4d7ad6f96adda81069f0cb4" translate="yes" xml:space="preserve">
          <source>In this case, the &lt;code&gt;git read-tree -m $H $M&lt;/code&gt; command makes sure that no local change is lost as the result of this &quot;merge&quot;. Here are the &quot;carry forward&quot; rules, where &quot;I&quot; denotes the index, &quot;clean&quot; means that index and work tree coincide, and &quot;exists&quot;/&quot;nothing&quot; refer to the presence of a path in the specified commit:</source>
          <target state="translated">この場合、 &lt;code&gt;git read-tree -m $H $M&lt;/code&gt; コマンドは、この「マージ」の結果としてローカルの変更が失われないようにします。「持ち越し」ルールは次のとおりです。「I」はインデックスを示し、「クリーン」はインデックスと作業ツリーが一致することを意味し、「存在」/「なし」は指定されたコミットにパスが存在することを示します。</target>
        </trans-unit>
        <trans-unit id="53de38de1c4937be3492ea2adad08075be0660b2" translate="yes" xml:space="preserve">
          <source>In this case, though, Git may not eventually be able to tell the first bad one between some first skipped commits and a later bad commit.</source>
          <target state="translated">しかし、この場合、Gitは結局、最初の悪い方のコミットをいくつかの最初のサボったコミットと後の悪い方のコミットを見分けることはできないかもしれません。</target>
        </trans-unit>
        <trans-unit id="cc3568a850f36cf3d79c68cf0d9db0591ec5b81e" translate="yes" xml:space="preserve">
          <source>In this case, when &lt;code&gt;git bisect run&lt;/code&gt; finishes, bisect/bad will refer to a commit that has at least one parent whose reachable graph is fully traversable in the sense required by &lt;code&gt;git pack objects&lt;/code&gt;.</source>
          <target state="translated">この場合、 &lt;code&gt;git bisect run&lt;/code&gt; が終了すると、bisect / badは、到達可能なグラフが &lt;code&gt;git pack objects&lt;/code&gt; 必要とする意味で完全にトラバース可能な親を少なくとも1つ持つコミットを参照します。</target>
        </trans-unit>
        <trans-unit id="052b0bf9d817f9d1efdbc01c640d54d8fda7ad16" translate="yes" xml:space="preserve">
          <source>In this example preload_index() was executed by the &lt;code&gt;main&lt;/code&gt; thread and started the &lt;code&gt;preload&lt;/code&gt; region. Seven threads, named &lt;code&gt;th01:preload_thread&lt;/code&gt; through &lt;code&gt;th07:preload_thread&lt;/code&gt;, were started. Events from each thread are atomically appended to the shared target stream as they occur so they may appear in random order with respect other threads. Finally, the main thread waits for the threads to finish and leaves the region.</source>
          <target state="translated">この例では、preload_index（）は &lt;code&gt;main&lt;/code&gt; スレッドによって実行され、 &lt;code&gt;preload&lt;/code&gt; 領域を開始しました。 &lt;code&gt;th01:preload_thread&lt;/code&gt; から &lt;code&gt;th07:preload_thread&lt;/code&gt; までの7つのスレッドが開始されました。各スレッドからのイベントは、発生時に共有ターゲットストリームにアトミックに追加されるため、他のスレッドに関してランダムな順序で表示される場合があります。最後に、メインスレッドは、スレッドが終了して領域を離れるのを待ちます。</target>
        </trans-unit>
        <trans-unit id="8e1c791b90ef2153c52f59ff823e2b7a9d806696" translate="yes" xml:space="preserve">
          <source>In this example, &quot;origin&quot; is called a remote repository, or &quot;remote&quot; for short. The branches of this repository are called &quot;remote branches&quot; from our point of view. The remote-tracking branches listed above were created based on the remote branches at clone time and will be updated by &lt;code&gt;git fetch&lt;/code&gt; (hence &lt;code&gt;git pull&lt;/code&gt;) and &lt;code&gt;git push&lt;/code&gt;. See &lt;a href=&quot;#Updating-a-repository-With-git-fetch&quot;&gt;Updating a repository with git fetch&lt;/a&gt; for details.</source>
          <target state="translated">この例では、「origin」はリモートリポジトリ、略して「remote」と呼ばれています。このリポジトリのブランチは、私たちの観点から「リモートブランチ」と呼ばれます。上記のリモート追跡ブランチは、クローン時のリモートブランチに基づいて作成され、 &lt;code&gt;git fetch&lt;/code&gt; （つまり &lt;code&gt;git pull&lt;/code&gt; ）と &lt;code&gt;git push&lt;/code&gt; によって更新されます。詳細については&lt;a href=&quot;#Updating-a-repository-With-git-fetch&quot;&gt;、git fetch&lt;/a&gt;を使用したリポジトリの更新を参照してください。</target>
        </trans-unit>
        <trans-unit id="888891869abe63aa603e61303e6b4eda4f092540" translate="yes" xml:space="preserve">
          <source>In this example, scanning for untracked files ran from +0.012568 to +0.027149 (since the process started) and took 0.014581 seconds.</source>
          <target state="translated">この例では、追跡されていないファイルのスキャンは、+0.012568から+0.027149(プロセスが開始されてから)まで実行され、0.014581秒かかりました。</target>
        </trans-unit>
        <trans-unit id="06524b5c41784cbbacde83bd5045f27a411dfe64" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;ko&lt;/code&gt; shorthand points at the Git maintainer&amp;rsquo;s repository at kernel.org, and looks like this:</source>
          <target state="translated">この例では、 &lt;code&gt;ko&lt;/code&gt; の省略形はkernel.orgのGitメンテナーのリポジトリを指しており、次のようになります。</target>
        </trans-unit>
        <trans-unit id="f509bc56ecf3e22348180170f4391a6c5749bec9" translate="yes" xml:space="preserve">
          <source>In this example, the preload region took 0.009122 seconds. The 7 threads took between 0.006069 and 0.008947 seconds to work on their portion of the index. Thread &quot;th01&quot; worked on 508 items at offset 0. Thread &quot;th02&quot; worked on 508 items at offset 2032. Thread &quot;th04&quot; worked on 508 items at offset 508.</source>
          <target state="translated">この例では、プリロード領域に 0.009122 秒かかりました。7 つのスレッドは、インデックスのそれぞれの部分で作業するのに 0.006069 ~ 0.008947 秒かかった。スレッド「th01」は、オフセット 0 で 508 項目を処理した。 スレッド「th02」は、オフセット 2032 で 508 項目を処理した。スレッド &quot;th04&quot; はオフセット 508 の 508 項目で作業した。</target>
        </trans-unit>
        <trans-unit id="24b2f8c33beed03671571687642648d3c34d3255" translate="yes" xml:space="preserve">
          <source>In this example, the root-level directory &lt;code&gt;/pub&lt;/code&gt; will contain a subdirectory for each virtual host IP address supported. Repositories can still be accessed by hostname though, assuming they correspond to these IP addresses.</source>
          <target state="translated">この例では、ルートレベルのディレクトリ &lt;code&gt;/pub&lt;/code&gt; に、サポートされる各仮想ホストIPアドレスのサブディレクトリが含まれます。ただし、これらのIPアドレスに対応していると仮定すると、リポジトリはホスト名でアクセスできます。</target>
        </trans-unit>
        <trans-unit id="1b3657f6aff85ab6f6a5a7f723164213b6e98109" translate="yes" xml:space="preserve">
          <source>In this example, the root-level directory &lt;code&gt;/pub&lt;/code&gt; will contain a subdirectory for each virtual host name supported. Further, both hosts advertise repositories simply as &lt;code&gt;git://www.example.com/software/repo.git&lt;/code&gt;. For pre-1.4.0 clients, a symlink from &lt;code&gt;/software&lt;/code&gt; into the appropriate default repository could be made as well.</source>
          <target state="translated">この例では、ルートレベルのディレクトリ &lt;code&gt;/pub&lt;/code&gt; に、サポートされる各仮想ホスト名のサブディレクトリが含まれます。さらに、両方のホストがリポジトリを単に &lt;code&gt;git://www.example.com/software/repo.git&lt;/code&gt; としてアドバタイズします。1.4.0より前のクライアントの場合、 &lt;code&gt;/software&lt;/code&gt; から適切なデフォルトリポジトリへのシンボリックリンクも作成できます。</target>
        </trans-unit>
        <trans-unit id="4f73381570064f6ad92295b54ae4d9111ba415e0" translate="yes" xml:space="preserve">
          <source>In this example, there are 3 old and 3 new commits, where the developer removed the 3rd, added a new one before the first two, and modified the commit message of the 2nd commit as well its diff.</source>
          <target state="translated">この例では、3つの古いコミットと3つの新しいコミットがあり、開発者は3つ目のコミットを削除し、最初の2つのコミットの前に新しいコミットを追加し、2つ目のコミットのコミットメッセージとその差分を修正しました。</target>
        </trans-unit>
        <trans-unit id="5f85b35b8b6aae26894cfdfbe33e3822a8120573" translate="yes" xml:space="preserve">
          <source>In this example, we passed &quot;grep &lt;code&gt;^SUBLEVEL = 25&lt;/code&gt; Makefile&quot; as parameter to &quot;git bisect run&quot;. This means that at each step, the grep command we passed will be launched. And if it exits with code 0 (that means success) then git bisect will mark the current state as &quot;good&quot;. If it exits with code 1 (or any code between 1 and 127 included, except the special code 125), then the current state will be marked as &quot;bad&quot;.</source>
          <target state="translated">この例では、「grep &lt;code&gt;^SUBLEVEL = 25&lt;/code&gt; Makefile」をパラメーターとして「git bisect run」に渡しました。つまり、各ステップで、渡したgrepコマンドが起動されます。そして、コード0（成功を意味する）で終了する場合、git bisectは現在の状態を「良好」としてマークします。コード1（または1から127までの任意のコードが含まれ、特別なコード125を除く）で終了する場合、現在の状態は「不良」としてマークされます。</target>
        </trans-unit>
        <trans-unit id="eee8776c9677f60ee6e97b993bed2ed1a91281bf" translate="yes" xml:space="preserve">
          <source>In this format, each line is output after a header; the header at the minimum has the first line which has:</source>
          <target state="translated">この形式では、各行はヘッダの後に出力されます。</target>
        </trans-unit>
        <trans-unit id="991df4351922c60c45e086aff27d9273fe47de49" translate="yes" xml:space="preserve">
          <source>In this format, use 40 &quot;0&quot; to specify a zero value, and use the empty string to specify a missing value.</source>
          <target state="translated">この形式では、ゼロの値を指定するには40の &quot;0 &quot;を使用し、欠落した値を指定するには空文字列を使用します。</target>
        </trans-unit>
        <trans-unit id="b4a37ae142e5dfb709dfd08bf26fc04d26f39f66" translate="yes" xml:space="preserve">
          <source>In this mode, specific configuration stays in the path pointed by &lt;code&gt;git
rev-parse --git-path config.worktree&lt;/code&gt;. You can add or update configuration in this file with &lt;code&gt;git config --worktree&lt;/code&gt;. Older Git versions will refuse to access repositories with this extension.</source>
          <target state="translated">このモードでは、特定の構成は &lt;code&gt;git rev-parse --git-path config.worktree&lt;/code&gt; 指すパスに残ります。このファイルの構成は、 &lt;code&gt;git config --worktree&lt;/code&gt; を使用して追加または更新できます。古いGitバージョンは、この拡張機能を持つリポジトリへのアクセスを拒否します。</target>
        </trans-unit>
        <trans-unit id="26cf2860c6712d39e5cbcd807f1756d9308dfdb3" translate="yes" xml:space="preserve">
          <source>In this mode, the index is split into two files, $GIT_DIR/index and $GIT_DIR/sharedindex.&amp;lt;SHA-1&amp;gt;. Changes are accumulated in $GIT_DIR/index, the split index, while the shared index file contains all index entries and stays unchanged.</source>
          <target state="translated">このモードでは、インデックスは2つのファイル、$ GIT_DIR / indexおよび$ GIT_DIR / sharedindex。&amp;lt;SHA-1&amp;gt;に分割されます。変更は$ GIT_DIR / index（分割されたインデックス）に蓄積されますが、共有インデックスファイルにはすべてのインデックスエントリが含まれ、変更されません。</target>
        </trans-unit>
        <trans-unit id="ffc9d6f506ae4dc0ef8e821987c60f58237503b7" translate="yes" xml:space="preserve">
          <source>In this mode, the server will not request authentication until the client actually starts the object negotiation phase of the push, rather than during the initial contact. For this reason, you must also enable the &lt;code&gt;http.receivepack&lt;/code&gt; config option in any repositories that should accept a push. The default behavior, if &lt;code&gt;http.receivepack&lt;/code&gt; is not set, is to reject any pushes by unauthenticated users; the initial request will therefore report &lt;code&gt;403 Forbidden&lt;/code&gt; to the client, without even giving an opportunity for authentication.</source>
          <target state="translated">このモードでは、サーバーは、クライアントが最初の連絡時ではなく、実際にプッシュのオブジェクトネゴシエーションフェーズを開始するまで、認証を要求しません。このため、プッシュを受け入れる必要があるすべてのリポジトリーで &lt;code&gt;http.receivepack&lt;/code&gt; 構成オプションも有効にする必要があります。 &lt;code&gt;http.receivepack&lt;/code&gt; が設定されていない場合のデフォルトの動作は、認証されていないユーザーによるプッシュを拒否することです。したがって、最初の要求は、認証の機会を与えることなく、 &lt;code&gt;403 Forbidden&lt;/code&gt; をクライアントに報告します。</target>
        </trans-unit>
        <trans-unit id="427d8f8d92a71761648b972f0beb3c2aad83aaaa" translate="yes" xml:space="preserve">
          <source>In this more general usage, you provide &lt;code&gt;git bisect&lt;/code&gt; with a &quot;new&quot; commit that has some property and an &quot;old&quot; commit that doesn&amp;rsquo;t have that property. Each time &lt;code&gt;git bisect&lt;/code&gt; checks out a commit, you test if that commit has the property. If it does, mark the commit as &quot;new&quot;; otherwise, mark it as &quot;old&quot;. When the bisection is done, &lt;code&gt;git bisect&lt;/code&gt; will report which commit introduced the property.</source>
          <target state="translated">このより一般的な使用法では、 &lt;code&gt;git bisect&lt;/code&gt; に、あるプロパティを持つ「新しい」コミットと、そのプロパティがない「古い」コミットを提供します。 &lt;code&gt;git bisect&lt;/code&gt; がコミットをチェックアウトするたびに、そのコミットにプロパティがあるかどうかをテストします。ある場合は、コミットを「新規」としてマークします。それ以外の場合は、「古い」とマークします。二分割が完了すると、 &lt;code&gt;git bisect&lt;/code&gt; はプロパティを導入したコミットを報告します。</target>
        </trans-unit>
        <trans-unit id="c1e29a4968fef09e4ce2211e751712b57ac5f128" translate="yes" xml:space="preserve">
          <source>In this view, we see all of the important single-parent changes from &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, and &lt;code&gt;X&lt;/code&gt;. We also see the carefully-resolved merge &lt;code&gt;M&lt;/code&gt; and the not-so-carefully-resolved merge &lt;code&gt;R&lt;/code&gt;. This is usually enough information to determine why the commits &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; &quot;disappeared&quot; from history in the default view. However, there are a few issues with this approach.</source>
          <target state="translated">このビューでは、 &lt;code&gt;A&lt;/code&gt; 、 &lt;code&gt;B&lt;/code&gt; 、および &lt;code&gt;X&lt;/code&gt; からの重要なひとり親の変更がすべて表示されます。また、慎重に解決されたマージ &lt;code&gt;M&lt;/code&gt; とそれほど慎重に解決されていないマージ &lt;code&gt;R&lt;/code&gt; も表示されます。これは通常、コミット &lt;code&gt;A&lt;/code&gt; と &lt;code&gt;B&lt;/code&gt; がデフォルトビューの履歴から「消えた」理由を判断するのに十分な情報です。ただし、このアプローチにはいくつかの問題があります。</target>
        </trans-unit>
        <trans-unit id="e6da0601a9e7aee317ec7d6d594e01f938b779c4" translate="yes" xml:space="preserve">
          <source>In unusual scenarios, you may not be able to create files larger than a certain size on your filesystem, and this option can be used to tell the command to split the output packfile into multiple independent packfiles, each not larger than the given size. The size can be suffixed with &quot;k&quot;, &quot;m&quot;, or &quot;g&quot;. The minimum size allowed is limited to 1 MiB. This option prevents the creation of a bitmap index. The default is unlimited, unless the config variable &lt;code&gt;pack.packSizeLimit&lt;/code&gt; is set.</source>
          <target state="translated">異常なシナリオでは、ファイルシステム上に特定のサイズより大きいファイルを作成できない場合があります。このオプションを使用して、出力パックファイルを複数の独立したパックファイルに分割するようにコマンドに指示できます。各パックファイルは、指定されたサイズ以下です。サイズの末尾には、「k」、「m」、または「g」を付けることができます。許可される最小サイズは1 MiBに制限されています。このオプションは、ビットマップインデックスの作成を防ぎます。構成変数 &lt;code&gt;pack.packSizeLimit&lt;/code&gt; が設定されていない限り、デフォルトは無制限です。</target>
        </trans-unit>
        <trans-unit id="4e6119784d7cd9e9e9f521473e212223da8f242e" translate="yes" xml:space="preserve">
          <source>In versions of Git before 2.23.0 patterns containing \0 would be silently considered fixed. This was never documented, there were also odd and undocumented interactions between e.g. non-ASCII patterns containing \0 and &lt;code&gt;--ignore-case&lt;/code&gt;.</source>
          <target state="translated">2.23.0より前のバージョンのGitでは、\ 0を含むパターンは暗黙のうちに修正済みと見なされます。これは文書化されたことはなく、たとえば\ 0と &lt;code&gt;--ignore-case&lt;/code&gt; を含む非ASCIIパターン間に奇妙で文書化されていない相互作用がありました。</target>
        </trans-unit>
        <trans-unit id="5da95a93eebb0b267da3b6f30d0296fee9bbc09f" translate="yes" xml:space="preserve">
          <source>Inactive branches are stored in a structure which uses 96 or 120 bytes (32 bit or 64 bit systems, respectively), plus the length of the branch name (typically under 200 bytes), per branch. fast-import will easily handle as many as 10,000 inactive branches in under 2 MiB of memory.</source>
          <target state="translated">非アクティブなブランチは、ブランチごとに96バイトまたは120バイト(それぞれ32ビットまたは64ビットシステム)とブランチ名の長さ(通常は200バイト以下)を使用する構造体に格納されます。</target>
        </trans-unit>
        <trans-unit id="40bf5b4a4e7b04d6908a8f7645b8e99e811e42d8" translate="yes" xml:space="preserve">
          <source>Include Some Progress Messages</source>
          <target state="translated">進捗状況のメッセージを含める</target>
        </trans-unit>
        <trans-unit id="d1a7a0c5683de418c5f98fc4beae70e15874a175" translate="yes" xml:space="preserve">
          <source>Include a line &amp;ldquo;log size &amp;lt;number&amp;gt;&amp;rdquo; in the output for each commit, where &amp;lt;number&amp;gt; is the length of that commit&amp;rsquo;s message in bytes. Intended to speed up tools that read log messages from &lt;code&gt;git log&lt;/code&gt; output by allowing them to allocate space in advance.</source>
          <target state="translated">各コミットの出力に「log size &amp;lt;number&amp;gt;」という行を含めます。&amp;lt;number&amp;gt;は、そのコミットのメッセージの長さ（バイト単位）です。事前にスペースを割り当てることができるようにすることで、 &lt;code&gt;git log&lt;/code&gt; 出力からログメッセージを読み取るツールを高速化することを目的としています。</target>
        </trans-unit>
        <trans-unit id="af14d11414c6ac75b39c95b283e5bcf0f4ccb002" translate="yes" xml:space="preserve">
          <source>Include additional statistics at the end of blame output.</source>
          <target state="translated">非難出力の最後に追加の統計情報を含める。</target>
        </trans-unit>
        <trans-unit id="67b90ce59db96c9a579b89f0489d7d9769ae1702" translate="yes" xml:space="preserve">
          <source>Include all commits from the default mode, but also any merge commits that are not TREESAME to the first parent but are TREESAME to a later parent. This mode is helpful for showing the merge commits that &quot;first introduced&quot; a change to a branch.</source>
          <target state="translated">デフォルトモードのすべてのコミットに加えて、最初の親に対する TREESAME ではなく、後の親に対する TREESAME であるマージコミットも含めます。このモードは、ブランチに変更を「最初に導入した」マージコミットを表示するのに便利です。</target>
        </trans-unit>
        <trans-unit id="47c5e0ca752d4a1deb14e562052c4b503ef081b0" translate="yes" xml:space="preserve">
          <source>Include commits that are reachable from &amp;lt;rev&amp;gt; (i.e. &amp;lt;rev&amp;gt; and its ancestors).</source>
          <target state="translated">&amp;lt;rev&amp;gt;（つまり、&amp;lt;rev&amp;gt;とその祖先）から到達可能なコミットを含めます。</target>
        </trans-unit>
        <trans-unit id="9605f416b0921199291f14b56df68cc8fe57350a" translate="yes" xml:space="preserve">
          <source>Include commits that are reachable from &amp;lt;rev2&amp;gt; but exclude those that are reachable from &amp;lt;rev1&amp;gt;. When either &amp;lt;rev1&amp;gt; or &amp;lt;rev2&amp;gt; is omitted, it defaults to &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">&amp;lt;rev2&amp;gt;から到達可能なコミットを含めるが、&amp;lt;rev1&amp;gt;から到達可能なコミットは除外します。&amp;lt;rev1&amp;gt;または&amp;lt;rev2&amp;gt;のいずれかを省略すると、デフォルトで &lt;code&gt;HEAD&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="ce2adffe692042c194b87264e9afec51300d7f42" translate="yes" xml:space="preserve">
          <source>Include commits that are reachable from either &amp;lt;rev1&amp;gt; or &amp;lt;rev2&amp;gt; but exclude those that are reachable from both. When either &amp;lt;rev1&amp;gt; or &amp;lt;rev2&amp;gt; is omitted, it defaults to &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">&amp;lt;rev1&amp;gt;または&amp;lt;rev2&amp;gt;から到達可能なコミットを含めますが、両方から到達可能なコミットは除外します。&amp;lt;rev1&amp;gt;または&amp;lt;rev2&amp;gt;のいずれかを省略すると、デフォルトで &lt;code&gt;HEAD&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="a1236fce64f1fb93f2ef7dcc7912c2d79c1d22c1" translate="yes" xml:space="preserve">
          <source>Include cross-references to the glossary, where appropriate.</source>
          <target state="translated">必要に応じて、用語集との相互参照を含める。</target>
        </trans-unit>
        <trans-unit id="ac12c15729a8f56d7cafe2e8c1b0d7927d0e53f1" translate="yes" xml:space="preserve">
          <source>Include debugging information related to the movement of lines between files (see &lt;code&gt;-C&lt;/code&gt;) and lines moved within a file (see &lt;code&gt;-M&lt;/code&gt;). The first number listed is the score. This is the number of alphanumeric characters detected as having been moved between or within files. This must be above a certain threshold for &lt;code&gt;git blame&lt;/code&gt; to consider those lines of code to have been moved.</source>
          <target state="translated">ファイル間の行の移動（ &lt;code&gt;-C&lt;/code&gt; を参照）およびファイル内で移動された行（ &lt;code&gt;-M&lt;/code&gt; を参照）に関連するデバッグ情報を含めます。リストされている最初の数字はスコアです。これは、ファイル間またはファイル内で移動されたことが検出された英数字の数です。これらのコード行が移動されたと &lt;code&gt;git blame&lt;/code&gt; が判断するには、これが特定のしきい値を超えている必要があります。</target>
        </trans-unit>
        <trans-unit id="eac52c02432a2a159a563ec983012928139e33b8" translate="yes" xml:space="preserve">
          <source>Include objects in &lt;code&gt;.keep&lt;/code&gt; files when repacking. Note that we still do not delete &lt;code&gt;.keep&lt;/code&gt; packs after &lt;code&gt;pack-objects&lt;/code&gt; finishes. This means that we may duplicate objects, but this makes the option safe to use when there are concurrent pushes or fetches. This option is generally only useful if you are writing bitmaps with &lt;code&gt;-b&lt;/code&gt; or &lt;code&gt;repack.writeBitmaps&lt;/code&gt;, as it ensures that the bitmapped packfile has the necessary objects.</source>
          <target state="translated">&lt;code&gt;.keep&lt;/code&gt; するときに、.keepファイルにオブジェクトを含めます。 &lt;code&gt;pack-objects&lt;/code&gt; の終了後も &lt;code&gt;.keep&lt;/code&gt; パックを削除しないことに注意してください。これは、オブジェクトを複製する可能性があることを意味しますが、これにより、同時のプッシュまたはフェッチがあるときにオプションを安全に使用できます。このオプションは通常、ビットマップをパックファイルに必要なオブジェクトが含まれるようにする &lt;code&gt;repack.writeBitmaps&lt;/code&gt; 、 &lt;code&gt;-b&lt;/code&gt; またはrepack.writeBitmapsを使用してビットマップを書き込む場合にのみ役立ちます。</target>
        </trans-unit>
        <trans-unit id="3b3acf7c7b624670bc98269d1db58c312d8f1ad9" translate="yes" xml:space="preserve">
          <source>Include patch text in the output.</source>
          <target state="translated">出力にパッチテキストを含める。</target>
        </trans-unit>
        <trans-unit id="7f58d83c9ac95ca37a657dfc92f2d025971598c2" translate="yes" xml:space="preserve">
          <source>Include the output of &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; in the commit message template when using an editor to prepare the commit message. Defaults to on, but can be used to override configuration variable commit.status.</source>
          <target state="translated">エディターを使用してコミットメッセージを準備する場合は、&lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt;の出力をコミットメッセージテンプレートに含めます。デフォルトはオンですが、構成変数commit.statusをオーバーライドするために使用できます。</target>
        </trans-unit>
        <trans-unit id="798a42403927f2977bd316b8bb1bba46f3e2c944" translate="yes" xml:space="preserve">
          <source>Include unasked-for annotated tags if the object they reference was included in the resulting packfile. This can be useful to send new tags to native Git clients.</source>
          <target state="translated">参照するオブジェクトが結果のパックファイルに含まれていた場合に、未指定の注釈付きタグを含めます。これは、ネイティブの Git クライアントに新しいタグを送る際に便利です。</target>
        </trans-unit>
        <trans-unit id="c5f574d342fa2383147936f6ccc821ddf1edb5ef" translate="yes" xml:space="preserve">
          <source>Included in a &lt;code&gt;commit&lt;/code&gt; command to add a new file or change the content of an existing file. This command has two different means of specifying the content of the file.</source>
          <target state="translated">新しいファイルを追加したり、既存のファイルの内容を変更したりするための &lt;code&gt;commit&lt;/code&gt; コマンドに含まれています。このコマンドには、ファイルの内容を指定する2つの異なる方法があります。</target>
        </trans-unit>
        <trans-unit id="8dfee16c07e63cf25f2958c656ce64f423b1c0b9" translate="yes" xml:space="preserve">
          <source>Included in a &lt;code&gt;commit&lt;/code&gt; command to remove a file or recursively delete an entire directory from the branch. If the file or directory removal makes its parent directory empty, the parent directory will be automatically removed too. This cascades up the tree until the first non-empty directory or the root is reached.</source>
          <target state="translated">ファイルを削除するか、ブランチからディレクトリ全体を再帰的に削除する &lt;code&gt;commit&lt;/code&gt; コマンドに含まれています。ファイルまたはディレクトリの削除によって親ディレクトリが空になると、親ディレクトリも自動的に削除されます。これにより、最初の空でないディレクトリまたはルートに到達するまで、ツリーがカスケードされます。</target>
        </trans-unit>
        <trans-unit id="87d365412b703101b1d281d9e93e3f278251dd0d" translate="yes" xml:space="preserve">
          <source>Included in a &lt;code&gt;commit&lt;/code&gt; command to remove all files (and also all directories) from the branch. This command resets the internal branch structure to have no files in it, allowing the frontend to subsequently add all interesting files from scratch.</source>
          <target state="translated">ブランチからすべてのファイル（およびすべてのディレクトリ）を削除する &lt;code&gt;commit&lt;/code&gt; コマンドに含まれています。このコマンドは、内部ブランチ構造をリセットして、ファイルを含まないようにします。これにより、フロントエンドが後ですべての対象ファイルを最初から追加できるようになります。</target>
        </trans-unit>
        <trans-unit id="28dccd9788a09aa2f373fa8c25c3b39e9406a080" translate="yes" xml:space="preserve">
          <source>Included in a &lt;code&gt;commit&lt;/code&gt;&lt;code&gt;&amp;lt;notes_ref&amp;gt;&lt;/code&gt; command to add a new note annotating a &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; or change this annotation contents. Internally it is similar to filemodify 100644 on &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; path (maybe split into subdirectories). It&amp;rsquo;s not advised to use any other commands to write to the &lt;code&gt;&amp;lt;notes_ref&amp;gt;&lt;/code&gt; tree except &lt;code&gt;filedeleteall&lt;/code&gt; to delete all existing notes in this tree. This command has two different means of specifying the content of the note.</source>
          <target state="translated">&lt;code&gt;commit&lt;/code&gt; &lt;code&gt;&amp;lt;notes_ref&amp;gt;&lt;/code&gt; コマンドに含まれ、 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; に注釈を付ける新しいメモを追加するか、この注釈の内容を変更します。内部的には、 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; パスのfilemodify 100644に似ています（サブディレクトリに分割される場合があります）。他のコマンドを使用して &lt;code&gt;&amp;lt;notes_ref&amp;gt;&lt;/code&gt; ツリーに書き込むことはお勧めしません。ただし、このツリー内の既存のすべてのノートを削除する &lt;code&gt;filedeleteall&lt;/code&gt; は除きます。このコマンドには、メモの内容を指定する2つの異なる方法があります。</target>
        </trans-unit>
        <trans-unit id="db54974f7f0ad531e35648ba85b9388029b4d7ef" translate="yes" xml:space="preserve">
          <source>Includes</source>
          <target state="translated">Includes</target>
        </trans-unit>
        <trans-unit id="de153f024523e4c2c467ece94c841922a681ecff" translate="yes" xml:space="preserve">
          <source>Includes one additional ancestor commit. The additional ancestry link does not change the way the tree state is built at this commit. If the &lt;code&gt;from&lt;/code&gt; command is omitted when creating a new branch, the first &lt;code&gt;merge&lt;/code&gt; commit will be the first ancestor of the current commit, and the branch will start out with no files. An unlimited number of &lt;code&gt;merge&lt;/code&gt; commands per commit are permitted by fast-import, thereby establishing an n-way merge.</source>
          <target state="translated">1つの追加の祖先コミットが含まれます。追加の祖先リンクは、このコミットでツリーの状態が構築される方法を変更しません。場合 &lt;code&gt;from&lt;/code&gt; 新しいブランチを作成するときに、コマンドが省略され、最初の &lt;code&gt;merge&lt;/code&gt; コミットは、現在の最初の祖先のコミットとなり、分岐なしのファイルでスタートします。コミットごとに無制限の数の &lt;code&gt;merge&lt;/code&gt; コマンドが高速インポートで許可されているため、n-wayマージが確立されます。</target>
        </trans-unit>
        <trans-unit id="8623cf320c015aba351966293c038ddef6f53905" translate="yes" xml:space="preserve">
          <source>Incompatible options</source>
          <target state="translated">互換性のないオプション</target>
        </trans-unit>
        <trans-unit id="9020a39adcad5a9de717e37976fa2cef184a1df6" translate="yes" xml:space="preserve">
          <source>Incorporates changes from a remote repository into the current branch. In its default mode, &lt;code&gt;git pull&lt;/code&gt; is shorthand for &lt;code&gt;git fetch&lt;/code&gt; followed by &lt;code&gt;git merge FETCH_HEAD&lt;/code&gt;.</source>
          <target state="translated">リモートリポジトリからの変更を現在のブランチに組み込みます。デフォルトモードでは、 &lt;code&gt;git pull&lt;/code&gt; は &lt;code&gt;git fetch&lt;/code&gt; の後に &lt;code&gt;git merge FETCH_HEAD&lt;/code&gt; が続く形式です。</target>
        </trans-unit>
        <trans-unit id="4d61077e89adde5af7a04457989a77b3c48490ae" translate="yes" xml:space="preserve">
          <source>Incorporates changes from the named commits (since the time their histories diverged from the current branch) into the current branch. This command is used by &lt;code&gt;git pull&lt;/code&gt; to incorporate changes from another repository and can be used by hand to merge changes from one branch into another.</source>
          <target state="translated">名前付きコミットからの変更（履歴が現在のブランチから分岐したときから）を現在のブランチに組み込みます。このコマンドは &lt;code&gt;git pull&lt;/code&gt; で別のリポジトリからの変更を組み込むために使用され、手動で1つのブランチから別のブランチへの変更をマージするために使用できます。</target>
        </trans-unit>
        <trans-unit id="709702f7f984cb3913cdb163bc5d2fe003c81b05" translate="yes" xml:space="preserve">
          <source>Incremental output</source>
          <target state="translated">インクリメンタル出力</target>
        </trans-unit>
        <trans-unit id="571937052d91a812bc84d435a3200a79bb1a0ee1" translate="yes" xml:space="preserve">
          <source>Indeed untestable commits are often untestable because a breakage was introduced at one time, and that breakage was fixed only after many other commits were introduced.</source>
          <target state="translated">実際、テスト不可能なコミットはしばしばテスト不可能なものになります。</target>
        </trans-unit>
        <trans-unit id="78699f384a94184571a61ab6b2f36f5cdf341b61" translate="yes" xml:space="preserve">
          <source>Indicate that only the objects wanted need to be fetched, not their dependents.</source>
          <target state="translated">依存関係ではなく、欲しいオブジェクトだけを取得する必要があることを示します。</target>
        </trans-unit>
        <trans-unit id="d063c49b2950871e5e846c69f89ed3fa8315be66" translate="yes" xml:space="preserve">
          <source>Indicate that these objects are being fetched from a promisor.</source>
          <target state="translated">これらのオブジェクトがプロマイザから取得されていることを示します。</target>
        </trans-unit>
        <trans-unit id="d4b8f31320c23f43d173d656edb4ca6c63551ac5" translate="yes" xml:space="preserve">
          <source>Indicates a blob object name.</source>
          <target state="translated">ブロブオブジェクトの名前を示します。</target>
        </trans-unit>
        <trans-unit id="6d441ed12cf0b86c55591d731de178963fe6c1ee" translate="yes" xml:space="preserve">
          <source>Indicates a commit object name.</source>
          <target state="translated">コミットオブジェクト名を示します。</target>
        </trans-unit>
        <trans-unit id="e89d58f77c5643f4921d84ac3c1216b6dc569e02" translate="yes" xml:space="preserve">
          <source>Indicates a commit or tag object name. A command that takes a &amp;lt;commit-ish&amp;gt; argument ultimately wants to operate on a &amp;lt;commit&amp;gt; object but automatically dereferences &amp;lt;tag&amp;gt; objects that point at a &amp;lt;commit&amp;gt;.</source>
          <target state="translated">コミットまたはタグのオブジェクト名を示します。&amp;lt;commit-ish&amp;gt;引数を取るコマンドは、最終的に&amp;lt;commit&amp;gt;オブジェクトを操作したいが、&amp;lt;commit&amp;gt;を指す&amp;lt;tag&amp;gt;オブジェクトを自動的に逆参照します。</target>
        </trans-unit>
        <trans-unit id="31963740af1f01e0807009b4b0a81e30ade64f1a" translate="yes" xml:space="preserve">
          <source>Indicates a filename - almost always relative to the root of the tree structure &lt;code&gt;GIT_INDEX_FILE&lt;/code&gt; describes.</source>
          <target state="translated">ファイル名を示します-ほとんどの場合、 &lt;code&gt;GIT_INDEX_FILE&lt;/code&gt; が記述するツリー構造のルートを基準にしています。</target>
        </trans-unit>
        <trans-unit id="c59be5c9a5ab736a07e28f031fa629ea1cac80d9" translate="yes" xml:space="preserve">
          <source>Indicates a tree object name.</source>
          <target state="translated">ツリーオブジェクト名を示します。</target>
        </trans-unit>
        <trans-unit id="0236f6573fabb077368d656582f35373ba9e33e6" translate="yes" xml:space="preserve">
          <source>Indicates a tree, commit or tag object name. A command that takes a &amp;lt;tree-ish&amp;gt; argument ultimately wants to operate on a &amp;lt;tree&amp;gt; object but automatically dereferences &amp;lt;commit&amp;gt; and &amp;lt;tag&amp;gt; objects that point at a &amp;lt;tree&amp;gt;.</source>
          <target state="translated">ツリー、コミット、またはタグのオブジェクト名を示します。&amp;lt;tree-ish&amp;gt;引数を取るコマンドは、最終的に&amp;lt;tree&amp;gt;オブジェクトを操作したいが、&amp;lt;tree&amp;gt;を指す&amp;lt;commit&amp;gt;および&amp;lt;tag&amp;gt;オブジェクトを自動的に逆参照します。</target>
        </trans-unit>
        <trans-unit id="73ecb0013f5389f15738299d7b0ca5b5c29b261f" translate="yes" xml:space="preserve">
          <source>Indicates that an object type is required. Currently one of: &lt;code&gt;blob&lt;/code&gt;, &lt;code&gt;tree&lt;/code&gt;, &lt;code&gt;commit&lt;/code&gt;, or &lt;code&gt;tag&lt;/code&gt;.</source>
          <target state="translated">オブジェクトタイプが必要であることを示します。現在、 &lt;code&gt;blob&lt;/code&gt; 、 &lt;code&gt;tree&lt;/code&gt; 、 &lt;code&gt;commit&lt;/code&gt; 、 &lt;code&gt;tag&lt;/code&gt; のいずれか。</target>
        </trans-unit>
        <trans-unit id="db4dbaff6f210d92fcd8a0947f8ffe2ad6166cf6" translate="yes" xml:space="preserve">
          <source>Indicates the object name for any type of object.</source>
          <target state="translated">任意のタイプのオブジェクトのオブジェクト名を示します。</target>
        </trans-unit>
        <trans-unit id="c66f56b69efd11f38dd2949f22030f51d42bccb8" translate="yes" xml:space="preserve">
          <source>Individual developer (participant)</source>
          <target state="translated">個人開発者(参加者</target>
        </trans-unit>
        <trans-unit id="dc704b04bf6fc4b099b66d2f7d86d56e0d061d7a" translate="yes" xml:space="preserve">
          <source>Individual developer (standalone)</source>
          <target state="translated">個人開発者(スタンドアロン</target>
        </trans-unit>
        <trans-unit id="a964b0aa320ab2176eba7cb0319b97ea34b340ac" translate="yes" xml:space="preserve">
          <source>Individually replay all rebased commits instead of fast-forwarding over the unchanged ones. This ensures that the entire history of the rebased branch is composed of new commits.</source>
          <target state="translated">変更されていないコミットを早送りするのではなく、リベースされたすべてのコミットを個別に再生します。これにより、リベースされたブランチの全履歴が新しいコミットで構成されるようになります。</target>
        </trans-unit>
        <trans-unit id="0eb5ed506e4923c28d7f4a8aa69efe99b3ad75d1" translate="yes" xml:space="preserve">
          <source>Information</source>
          <target state="translated">Information</target>
        </trans-unit>
        <trans-unit id="9bceb94c72e397fee5b7ad78b8c9312ee6319e43" translate="yes" xml:space="preserve">
          <source>Information about what is to be pushed is provided on the hook&amp;rsquo;s standard input with lines of the form:</source>
          <target state="translated">何がプッシュされるかについての情報は、次の形式の行でフックの標準入力に提供されます。</target>
        </trans-unit>
        <trans-unit id="43d35f7b76c469225469fd7a04662a08053d1e63" translate="yes" xml:space="preserve">
          <source>Initial client request</source>
          <target state="translated">初期クライアント要求</target>
        </trans-unit>
        <trans-unit id="68fa16ffd48f366e4fa8d57fea78ff03fcab0191" translate="yes" xml:space="preserve">
          <source>Initialization</source>
          <target state="translated">Initialization</target>
        </trans-unit>
        <trans-unit id="1b499097655f7a7af4711e162d7e54be3deca803" translate="yes" xml:space="preserve">
          <source>Initialization happens in &lt;code&gt;main()&lt;/code&gt;. Behind the scenes, an &lt;code&gt;atexit&lt;/code&gt; and &lt;code&gt;signal&lt;/code&gt; handler are registered.</source>
          <target state="translated">初期化は &lt;code&gt;main()&lt;/code&gt; で行われます。舞台裏では、 &lt;code&gt;atexit&lt;/code&gt; と &lt;code&gt;signal&lt;/code&gt; ハンドラが登録されています。</target>
        </trans-unit>
        <trans-unit id="42e32f1c6a8cf663f45361425590d312db136ea3" translate="yes" xml:space="preserve">
          <source>Initialize and modify the sparse-checkout</source>
          <target state="translated">スパースチェックアウトの初期化と変更</target>
        </trans-unit>
        <trans-unit id="5be83bd5256f93987e394207f3c5233baf2d713e" translate="yes" xml:space="preserve">
          <source>Initialize and modify the sparse-checkout configuration, which reduces the checkout to a set of paths given by a list of patterns.</source>
          <target state="translated">スパースチェックアウトの設定を初期化し、変更します。これにより、チェックアウトをパターンのリストで与えられたパスのセットに縮小します。</target>
        </trans-unit>
        <trans-unit id="825b58a6f65001fb659dd3ff519bf4df985a29aa" translate="yes" xml:space="preserve">
          <source>Initialize the sparse-checkout file so the working directory starts with only the files in the root of the repository. The sparse-checkout file can be modified to grow the working directory as needed.</source>
          <target state="translated">sparse-checkout ファイルを初期化して、作業ディレクトリがリポジトリのルートにあるファイルだけで始まるようにします。sparse-checkout ファイルは、必要に応じて作業ディレクトリを成長させるために修正することができます。</target>
        </trans-unit>
        <trans-unit id="9e0eca47ea83eb468f0ac7fe2e029fd23bbe773e" translate="yes" xml:space="preserve">
          <source>Initialize the submodules recorded in the index (which were added and committed elsewhere) by setting &lt;code&gt;submodule.$name.url&lt;/code&gt; in .git/config. It uses the same setting from &lt;code&gt;.gitmodules&lt;/code&gt; as a template. If the URL is relative, it will be resolved using the default remote. If there is no default remote, the current repository will be assumed to be upstream.</source>
          <target state="translated">.git / configで &lt;code&gt;submodule.$name.url&lt;/code&gt; 設定して、インデックスに記録されたサブモジュール（他の場所に追加およびコミットされたもの）を初期化します。 &lt;code&gt;.gitmodules&lt;/code&gt; と同じ設定をテンプレートとして使用します。URLが相対である場合、デフォルトのリモートを使用して解決されます。デフォルトのリモートがない場合、現在のリポジトリはアップストリームであると想定されます。</target>
        </trans-unit>
        <trans-unit id="52f8f7589ec2fc901a83216cac5106872728a87d" translate="yes" xml:space="preserve">
          <source>Initialize, update or inspect submodules</source>
          <target state="translated">サブモジュールの初期化、更新、検査</target>
        </trans-unit>
        <trans-unit id="0d880d50dc463cd4220f01bcf54c48c1f2d57098" translate="yes" xml:space="preserve">
          <source>Initializes an empty Git repository with additional metadata directories for &lt;code&gt;git svn&lt;/code&gt;. The Subversion URL may be specified as a command-line argument, or as full URL arguments to -T/-t/-b. Optionally, the target directory to operate on can be specified as a second argument. Normally this command initializes the current directory.</source>
          <target state="translated">&lt;code&gt;git svn&lt;/code&gt; の追加のメタデータディレクトリで空のGitリポジトリを初期化します。Subversion URLは、コマンドライン引数として、または-T / -t / -bへの完全なURL引数として指定できます。オプションで、操作するターゲットディレクトリを2番目の引数として指定できます。通常、このコマンドは現在のディレクトリを初期化します。</target>
        </trans-unit>
        <trans-unit id="01c2c8357a87e8a6148f1dd9a9c884aae5e4de53" translate="yes" xml:space="preserve">
          <source>Initially ignore any whitespace in the move detection, then group the moved code blocks only into a block if the change in whitespace is the same per line. This is incompatible with the other modes.</source>
          <target state="translated">最初は移動検出での空白を無視し、空白の変化が行ごとに同じであれば、移動したコードブロックのみをブロックにグループ化します。これは他のモードと互換性がありません。</target>
        </trans-unit>
        <trans-unit id="229b7991e581f774e065f13c78dfa8719c8c393f" translate="yes" xml:space="preserve">
          <source>Inline data format</source>
          <target state="translated">インラインデータ形式</target>
        </trans-unit>
        <trans-unit id="7c7935726f449ea7185a4fe42a9ddf2d1c53a2e4" translate="yes" xml:space="preserve">
          <source>Input Format</source>
          <target state="translated">入力形式</target>
        </trans-unit>
        <trans-unit id="1b77a7f4983f9ce773f466c761a7f6e9771bf925" translate="yes" xml:space="preserve">
          <source>Input format</source>
          <target state="translated">入力形式</target>
        </trans-unit>
        <trans-unit id="789cc08a97020bab893e17ca6133192d1f9f1dac" translate="yes" xml:space="preserve">
          <source>Input is of the &quot;mboxrd&quot; format and &quot;^&amp;gt;+From &quot; line escaping is reversed.</source>
          <target state="translated">入力は「mboxrd」形式で、「^&amp;gt; + From」行のエスケープが逆になります。</target>
        </trans-unit>
        <trans-unit id="26242e7bd97bd8eebf44f9f25f143aed3a9bdc4d" translate="yes" xml:space="preserve">
          <source>Input/output format</source>
          <target state="translated">入出力フォーマット</target>
        </trans-unit>
        <trans-unit id="4038e1c7ebc07b210c228498bd5816f54233b768" translate="yes" xml:space="preserve">
          <source>Insert &lt;code&gt;progress&lt;/code&gt; statements every &amp;lt;n&amp;gt; objects, to be shown by &lt;code&gt;git fast-import&lt;/code&gt; during import.</source>
          <target state="translated">&lt;code&gt;git fast-import&lt;/code&gt; 中にgit fast-importで表示される&amp;lt;n&amp;gt;オブジェクトごとに &lt;code&gt;progress&lt;/code&gt; ステートメントを挿入します。</target>
        </trans-unit>
        <trans-unit id="39c559793b49987eea00aba844e216707b6e7dcc" translate="yes" xml:space="preserve">
          <source>Insert custom links to the action bar of all project pages. This allows you to link to third-party scripts integrating into gitweb.</source>
          <target state="translated">すべてのプロジェクトページのアクションバーにカスタムリンクを挿入します。これにより、gitweb に統合されているサードパーティ製スクリプトへのリンクが可能になります。</target>
        </trans-unit>
        <trans-unit id="ce8fd02283c353dc3cacd2d3e6c1eab64a1913a3" translate="yes" xml:space="preserve">
          <source>Inside double quotes, double quote &lt;code&gt;&quot;&lt;/code&gt; and backslash &lt;code&gt;\&lt;/code&gt; characters must be escaped: use &lt;code&gt;\&quot;&lt;/code&gt; for &lt;code&gt;&quot;&lt;/code&gt; and &lt;code&gt;\\&lt;/code&gt; for &lt;code&gt;\&lt;/code&gt;.</source>
          <target state="translated">内部の二重引用符、二重引用符 &lt;code&gt;&quot;&lt;/code&gt; バックスラッシュ &lt;code&gt;\&lt;/code&gt; 文字をエスケープする必要があります使用 &lt;code&gt;\&quot;&lt;/code&gt; のために &lt;code&gt;&quot;&lt;/code&gt; と &lt;code&gt;\\&lt;/code&gt; のための &lt;code&gt;\&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="ab67c68674bb4a9f1f690fac98c95aa9c2e1e750" translate="yes" xml:space="preserve">
          <source>Inspecting changes</source>
          <target state="translated">変更点の検査</target>
        </trans-unit>
        <trans-unit id="ecf21e44dd8609734c0bc387cabc376ab485d9f8" translate="yes" xml:space="preserve">
          <source>Inspection and Comparison</source>
          <target state="translated">検査・比較</target>
        </trans-unit>
        <trans-unit id="e0c3f2780ee983978068137722cf2d423843d21f" translate="yes" xml:space="preserve">
          <source>Inspects, updates and manages submodules.</source>
          <target state="translated">サブモジュールの検査、更新、管理を行います。</target>
        </trans-unit>
        <trans-unit id="d9fb6eb12bbc11fdad6f18ee5bfa79361ddad72b" translate="yes" xml:space="preserve">
          <source>Install the Toggle Word Wrap add-on that is available from &lt;a href=&quot;https://addons.mozilla.org/thunderbird/addon/toggle-word-wrap/&quot;&gt;https://addons.mozilla.org/thunderbird/addon/toggle-word-wrap/&lt;/a&gt; It adds a menu entry &quot;Enable Word Wrap&quot; in the composer&amp;rsquo;s &quot;Options&quot; menu that you can tick off. Now you can compose the message as you otherwise do (cut + paste, &lt;code&gt;git format-patch&lt;/code&gt; | &lt;code&gt;git imap-send&lt;/code&gt;, etc), but you have to insert line breaks manually in any text that you type.</source>
          <target state="translated">&lt;a href=&quot;https://addons.mozilla.org/thunderbird/addon/toggle-word-wrap/&quot;&gt;https://addons.mozilla.org/thunderbird/addon/toggle-word-wrap/&lt;/a&gt;から入手可能なToggle Word Wrapアドオンをインストールします。これにより、作曲者の[オプション]メニューに[ワードラップを有効にする]というメニューエントリが追加されます。ティックオフできます。これで、通常どおりにメッセージを作成できます（カット+ペースト、 &lt;code&gt;git format-patch&lt;/code&gt; | &lt;code&gt;git imap-send&lt;/code&gt; など）。ただし、入力するテキストには手動で改行を挿入する必要があります。</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="7fad939655efbad1612ce7f4867922684d56913b" translate="yes" xml:space="preserve">
          <source>Instantly browse your working repository in gitweb</source>
          <target state="translated">gitweb で作業中のリポジトリを即座に閲覧</target>
        </trans-unit>
        <trans-unit id="53c902fb07156c6117155b6a0b0738c7ca12a6bf" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;git bisect visualize&lt;/code&gt; and then &lt;code&gt;git reset --hard
fb47ddb2db&lt;/code&gt;, you might just want to tell Git that you want to skip the current commit:</source>
          <target state="translated">&lt;code&gt;git bisect visualize&lt;/code&gt; を実行してから &lt;code&gt;git reset --hard fb47ddb2db&lt;/code&gt; を実行する代わりに、現在のコミットをスキップするようにGitに指示することもできます。</target>
        </trans-unit>
        <trans-unit id="483617d942bddc8b6c044cd054e06089960e1981" translate="yes" xml:space="preserve">
          <source>Instead of a commit id on the command line (which is not expected in this case), &lt;code&gt;git http-fetch&lt;/code&gt; expects lines on stdin in the format</source>
          <target state="translated">コマンドラインのコミットID（この場合は想定されていません）の代わりに、 &lt;code&gt;git http-fetch&lt;/code&gt; は次の形式のstdinの行を想定しています</target>
        </trans-unit>
        <trans-unit id="78b5184ca479cbe7999ac4fee6c0be2a7fd5b77a" translate="yes" xml:space="preserve">
          <source>Instead of a commit id on the command line (which is not expected in this case), &lt;code&gt;git http-fetch&lt;/code&gt; fetches the packfile directly at the given URL and uses index-pack to generate corresponding .idx and .keep files. The hash is used to determine the name of the temporary file and is arbitrary. The output of index-pack is printed to stdout.</source>
          <target state="translated">コマンドラインのコミットID（この場合は予期されていません）の代わりに、 &lt;code&gt;git http-fetch&lt;/code&gt; は指定されたURLで直接packfileをフェッチし、index-packを使用して対応する.idxファイルと.keepファイルを生成します。ハッシュは一時ファイルの名前を決定するために使用され、任意です。index-packの出力はstdoutに出力されます。</target>
        </trans-unit>
        <trans-unit id="978fdd37a8d1d967862cc9e916d011571d6998cf" translate="yes" xml:space="preserve">
          <source>Instead of an absolute timestamp relative timestamps work as well, e.g. 2.weeks.ago is valid to address anything older than 2 weeks.</source>
          <target state="translated">絶対的なタイムスタンプの代わりに、相対的なタイムスタンプも同様に機能します。</target>
        </trans-unit>
        <trans-unit id="ad6345e758058b67dc8e001b3a11fe48b9b5f52b" translate="yes" xml:space="preserve">
          <source>Instead of applying the patch, output a condensed summary of information obtained from git diff extended headers, such as creations, renames and mode changes. Turns off &quot;apply&quot;.</source>
          <target state="translated">パッチを適用する代わりに、作成やリネーム、モード変更など、git diff 拡張ヘッダから取得した情報を凝縮して出力します。apply&quot; をオフにします。</target>
        </trans-unit>
        <trans-unit id="5429abc21a21a789987424e6c0ab7612e06a85eb" translate="yes" xml:space="preserve">
          <source>Instead of applying the patch, output diffstat for the input. Turns off &quot;apply&quot;.</source>
          <target state="translated">パッチを適用する代わりに、入力に対してdiffstatを出力します。apply &quot;をオフにします。</target>
        </trans-unit>
        <trans-unit id="881bf52883e6605d5234b3f22aaf3b7b4afc6968" translate="yes" xml:space="preserve">
          <source>Instead of applying the patch, see if the patch is applicable to the current working tree and/or the index file and detects errors. Turns off &quot;apply&quot;.</source>
          <target state="translated">パッチを適用する代わりに、パッチが現在の作業ツリーおよび/またはインデックスファイルに適用されているかどうかを確認し、エラーを検出します。apply &quot;をオフにします。</target>
        </trans-unit>
        <trans-unit id="6e355f85b13671d925fde0c740a0dbae977bb0bc" translate="yes" xml:space="preserve">
          <source>Instead of basing a new branch on current HEAD (the default), use:</source>
          <target state="translated">新しいブランチを現在の HEAD (デフォルト)をベースにするのではなく、次のようにします。</target>
        </trans-unit>
        <trans-unit id="54f9cd044bb973ffe696d82cb4d71b8b1fd61c38" translate="yes" xml:space="preserve">
          <source>Instead of calling cvsps, read the provided cvsps output file. Useful for debugging or when cvsps is being handled outside cvsimport.</source>
          <target state="translated">cvsps を呼び出す代わりに,提供された cvsps 出力ファイルを読み込みます.デバッグや,cvsps が cvsimport の外部で処理されている場合に便利です.</target>
        </trans-unit>
        <trans-unit id="bb5ec3e62f50f37c713576e81a7468472cf1721e" translate="yes" xml:space="preserve">
          <source>Instead of checking out unmerged entries, copy out the files from named stage. &amp;lt;number&amp;gt; must be between 1 and 3. Note: --stage=all automatically implies --temp.</source>
          <target state="translated">マージされていないエントリをチェックアウトする代わりに、名前付きステージからファイルをコピーします。&amp;lt;number&amp;gt;は1から3の間でなければなりません。注：--stage = allは自動的に--tempを意味します。</target>
        </trans-unit>
        <trans-unit id="15d18d5e837d77d2ad93145197274038afcfa944" translate="yes" xml:space="preserve">
          <source>Instead of choosing a nearby commit by yourself, you can ask Git to do it for you by issuing the command:</source>
          <target state="translated">自分で近くのコミットを選ぶのではなく、コマンドを発行して Git に依頼することもできます。</target>
        </trans-unit>
        <trans-unit id="071c6c805d6df82b0ae0937a6e3d6e7d94979975" translate="yes" xml:space="preserve">
          <source>Instead of comparing with the tip of &quot;test&quot; branch, compare with the tip of the current branch, but limit the comparison to the file &quot;test&quot;.</source>
          <target state="translated">test&quot; ブランチの先端と比較するのではなく、現在のブランチの先端と比較しますが、比較対象は &quot;test&quot; ファイルに限定してください。</target>
        </trans-unit>
        <trans-unit id="17207c6e7e5006477485c406ccec2ab95d9a0907" translate="yes" xml:space="preserve">
          <source>Instead of considering only the 10 most recent tags as candidates to describe the input commit-ish consider up to &amp;lt;n&amp;gt; candidates. Increasing &amp;lt;n&amp;gt; above 10 will take slightly longer but may produce a more accurate result. An &amp;lt;n&amp;gt; of 0 will cause only exact matches to be output.</source>
          <target state="translated">最新の10個のタグのみを候補として検討する代わりに、入力コミットを説明するために、最大&amp;lt;n&amp;gt;個の候補を検討します。&amp;lt;n&amp;gt;を10より大きくすると、少し時間がかかりますが、より正確な結果が得られる場合があります。&amp;lt;n&amp;gt;が0の場合、完全一致のみが出力されます。</target>
        </trans-unit>
        <trans-unit id="3d51a8a573b601f04a9b432f10be7818f6056cab" translate="yes" xml:space="preserve">
          <source>Instead of copying the files to the working directory write the content to temporary files. The temporary name associations will be written to stdout.</source>
          <target state="translated">作業ディレクトリにファイルをコピーするのではなく、一時ファイルに内容を書き込みます。一時的な名前の関連付けは標準出力に書き込まれます。</target>
        </trans-unit>
        <trans-unit id="aece37f2a7e1b433117b2533e4c10ff1af967895" translate="yes" xml:space="preserve">
          <source>Instead of explicitly specifying which refs to update, update all heads that locally exist.</source>
          <target state="translated">更新する参照を明示的に指定するのではなく、ローカルに存在するすべてのヘッドを更新します。</target>
        </trans-unit>
        <trans-unit id="c9dd00560176cb59ca6811a38f98f0a00cea59a2" translate="yes" xml:space="preserve">
          <source>Instead of finding the tag that predates the commit, find the tag that comes after the commit, and thus contains it. Automatically implies --tags.</source>
          <target state="translated">コミット前のタグを見つけるのではなく、コミット後のタグを見つけて、それを含むタグを見つけてください。自動的に --tags を意味します。</target>
        </trans-unit>
        <trans-unit id="c3bcf62d531bd115333abb263736c08fc67412f8" translate="yes" xml:space="preserve">
          <source>Instead of having gitweb find repositories by scanning filesystem starting from $projectroot, you can provide a pre-generated list of visible projects by setting &lt;code&gt;$projects_list&lt;/code&gt; to point to a plain text file with a list of projects (with some additional info).</source>
          <target state="translated">$ projectrootから始まるファイルシステムをスキャンしてgitwebでリポジトリを検索する代わりに、 &lt;code&gt;$projects_list&lt;/code&gt; を設定して、プロジェクトのリスト（いくつかの追加情報を含む）が含まれるプレーンテキストファイルを指すようにして、表示可能なプロジェクトのリストを提供できます。</target>
        </trans-unit>
        <trans-unit id="b8a426e0ceafe99f9ee69973b04f605e2dee7cb4" translate="yes" xml:space="preserve">
          <source>Instead of incrementally packing the unpacked objects, pack everything referenced into a single pack. Especially useful when packing a repository that is used for private development. Use with &lt;code&gt;-d&lt;/code&gt;. This will clean up the objects that &lt;code&gt;git prune&lt;/code&gt; leaves behind, but &lt;code&gt;git fsck --full --dangling&lt;/code&gt; shows as dangling.</source>
          <target state="translated">アンパックされたオブジェクトを段階的にパックする代わりに、参照されているすべてのものを1つのパックにパックします。プライベート開発に使用されるリポジトリをパックするときに特に役立ちます。 &lt;code&gt;-d&lt;/code&gt; とともに使用します。これにより、 &lt;code&gt;git prune&lt;/code&gt; が残したオブジェクトがクリーンアップされますが、 &lt;code&gt;git fsck --full --dangling&lt;/code&gt; はダングリングとして表示されます。</target>
        </trans-unit>
        <trans-unit id="f1ffab5966e331d53c3cb8a3d86f241f936c7bef" translate="yes" xml:space="preserve">
          <source>Instead of initializing the repository as a directory to either &lt;code&gt;$GIT_DIR&lt;/code&gt; or &lt;code&gt;./.git/&lt;/code&gt;, create a text file there containing the path to the actual repository. This file acts as filesystem-agnostic Git symbolic link to the repository.</source>
          <target state="translated">&lt;code&gt;$GIT_DIR&lt;/code&gt; または &lt;code&gt;./.git/&lt;/code&gt; へのディレクトリとしてリポジトリを初期化する代わりに、実際のリポジトリへのパスを含むテキストファイルをそこに作成します。このファイルは、リポジトリへのファイルシステムに依存しないGitシンボリックリンクとして機能します。</target>
        </trans-unit>
        <trans-unit id="f0ef88b9adcd939e8a3f3a231e5d0c4737f1545c" translate="yes" xml:space="preserve">
          <source>Instead of leaving conflicts in the file, resolve conflicts favouring our (or their or both) side of the lines.</source>
          <target state="translated">ファイル内に競合を残すのではなく、私たちの(またはその両方の)ラインの側に有利な競合を解決します。</target>
        </trans-unit>
        <trans-unit id="ca8be3d7e71d110990923e82a424a61c61fcfea3" translate="yes" xml:space="preserve">
          <source>Instead of making a tar archive from the local repository, retrieve a tar archive from a remote repository. Note that the remote repository may place restrictions on which sha1 expressions may be allowed in &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt;. See &lt;a href=&quot;git-upload-archive&quot;&gt;git-upload-archive[1]&lt;/a&gt; for details.</source>
          <target state="translated">ローカルリポジトリからtarアーカイブを作成する代わりに、リモートリポジトリからtarアーカイブを取得します。リモートリポジトリによって、 &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; で許可されるsha1式に制限が課される場合があることに注意してください。詳細については、&lt;a href=&quot;git-upload-archive&quot;&gt;git-upload-archive [1]&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="7f9313c2b37d59bfbfa07ff3336c61ac5f242846" translate="yes" xml:space="preserve">
          <source>Instead of multiple service names, multiple commands will be supported by a single service</source>
          <target state="translated">複数のサービス名の代わりに、複数のコマンドが単一のサービスでサポートされます。</target>
        </trans-unit>
        <trans-unit id="9913e3351ae1177f0328b10cfa41d1a78100d839" translate="yes" xml:space="preserve">
          <source>Instead of naming each ref to push, specifies that all refs under &lt;code&gt;refs/&lt;/code&gt; (which includes but is not limited to &lt;code&gt;refs/heads/&lt;/code&gt;, &lt;code&gt;refs/remotes/&lt;/code&gt;, and &lt;code&gt;refs/tags/&lt;/code&gt;) be mirrored to the remote repository. Newly created local refs will be pushed to the remote end, locally updated refs will be force updated on the remote end, and deleted refs will be removed from the remote end. This is the default if the configuration option &lt;code&gt;remote.&amp;lt;remote&amp;gt;.mirror&lt;/code&gt; is set.</source>
          <target state="translated">プッシュする各参照に名前を付ける代わりに、 &lt;code&gt;refs/&lt;/code&gt; （ &lt;code&gt;refs/heads/&lt;/code&gt; 、 &lt;code&gt;refs/remotes/&lt;/code&gt; 、および &lt;code&gt;refs/tags/&lt;/code&gt; を含むがこれらに限定されない）の下のすべての参照をリモートリポジトリにミラーリングすることを指定します。新しく作成されたローカル参照はリモートエンドにプッシュされ、ローカルで更新された参照はリモートエンドで強制的に更新され、削除された参照はリモートエンドから削除されます。これは、設定オプション &lt;code&gt;remote.&amp;lt;remote&amp;gt;.mirror&lt;/code&gt; が設定されている場合のデフォルトです。</target>
        </trans-unit>
        <trans-unit id="9634150ab7e71bf3eb3f2b25ec8ede96c11d4e06" translate="yes" xml:space="preserve">
          <source>Instead of naming the commits using the path to reach them from heads (e.g. &quot;master~2&quot; to mean the grandparent of &quot;master&quot;), name them with the unique prefix of their object names.</source>
          <target state="translated">コミットの名前には、ヘッドからのパスを使って命名するのではなく (例えば &quot;master&quot; の祖父母を意味する &quot;master~2&quot; のように)、オブジェクト名のユニークな接頭辞を使って命名します。</target>
        </trans-unit>
        <trans-unit id="17b0b1c8040238e6478f5b3afd0b8cbc3b08f080" translate="yes" xml:space="preserve">
          <source>Instead of placing the cloned repository where it is supposed to be, place the cloned repository at the specified directory, then make a filesystem-agnostic Git symbolic link to there. The result is Git repository can be separated from working tree.</source>
          <target state="translated">クローン化したリポジトリをあるべき場所に置くのではなく、指定したディレクトリにクローンしたリポジトリを置き、そこにファイルシステムに依存しないGitのシンボリックリンクを作ります。その結果、Git リポジトリと作業ツリーを分離することができます。</target>
        </trans-unit>
        <trans-unit id="22fb130092ca941fcb14aff3909ae71b595afba3" translate="yes" xml:space="preserve">
          <source>Instead of pointing the newly created HEAD to the branch pointed to by the cloned repository&amp;rsquo;s HEAD, point to &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; branch instead. In a non-bare repository, this is the branch that will be checked out. &lt;code&gt;--branch&lt;/code&gt; can also take tags and detaches the HEAD at that commit in the resulting repository.</source>
          <target state="translated">新しく作成されたHEADが、複製されたリポジトリーのHEADが指すブランチを指すのではなく、代わりに &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; ブランチを指すようにします。非ベアリポジトリでは、これはチェックアウトされるブランチです。 &lt;code&gt;--branch&lt;/code&gt; はタグを取得して、結果のリポジトリのコミット時にHEADをデタッチすることもできます。</target>
        </trans-unit>
        <trans-unit id="33ebce829b735e00e4c7bea8b4f644ee8c315aa6" translate="yes" xml:space="preserve">
          <source>Instead of printing both the SHA-1 and the name, print only the name. If given with --tags the usual tag prefix of &quot;tags/&quot; is also omitted from the name, matching the output of &lt;code&gt;git-describe&lt;/code&gt; more closely.</source>
          <target state="translated">SHA-1と名前の両方を印刷する代わりに、名前のみを印刷します。--tagsを指定すると、通常のタグ接頭辞「tags /」も名前から省略され、 &lt;code&gt;git-describe&lt;/code&gt; の出力とより厳密に一致します。</target>
        </trans-unit>
        <trans-unit id="064cb6e81b93b30bcf346d10dc97336e618d6fae" translate="yes" xml:space="preserve">
          <source>Instead of printing merge bases, print a minimal subset of the supplied commits with the same ancestors. In other words, among the commits given, list those which cannot be reached from any other. This mimics the behavior of &lt;code&gt;git show-branch --independent&lt;/code&gt;.</source>
          <target state="translated">マージベースを出力する代わりに、同じ祖先を持つ提供されたコミットの最小限のサブセットを出力します。言い換えると、与えられたコミットの中で、他からは到達できないものをリストします。これは &lt;code&gt;git show-branch --independent&lt;/code&gt; の動作を模倣しています。</target>
        </trans-unit>
        <trans-unit id="323f56e14b223cf1dac7d6a09fb1d2d15675463d" translate="yes" xml:space="preserve">
          <source>Instead of printing the paths that are excluded, for each path that matches an exclude pattern, print the exclude pattern together with the path. (Matching an exclude pattern usually means the path is excluded, but if the pattern begins with &lt;code&gt;!&lt;/code&gt; then it is a negated pattern and matching it means the path is NOT excluded.)</source>
          <target state="translated">除外されたパスを印刷する代わりに、除外パターンに一致するパスごとに、パスと一緒に除外パターンを印刷します。（通常、除外パターンに一致すると、パスが除外されますが、パターンが &lt;code&gt;!&lt;/code&gt; で始まる場合、それは否定されたパターンであり、一致すると、パスは除外されません。）</target>
        </trans-unit>
        <trans-unit id="a77a1e8325cae4bfdfe406c89eaae3fe4ca07d52" translate="yes" xml:space="preserve">
          <source>Instead of reading a list of objects on stdin, perform the requested batch operation on all objects in the repository and any alternate object stores (not just reachable objects). Requires &lt;code&gt;--batch&lt;/code&gt; or &lt;code&gt;--batch-check&lt;/code&gt; be specified. Note that the objects are visited in order sorted by their hashes.</source>
          <target state="translated">stdinでオブジェクトのリストを読み取る代わりに、リポジトリ内のすべてのオブジェクトと代替オブジェクトストア（到達可能なオブジェクトだけでなく）に対して要求されたバッチ操作を実行します。 &lt;code&gt;--batch&lt;/code&gt; または &lt;code&gt;--batch-check&lt;/code&gt; を指定する必要があります。オブジェクトは、ハッシュでソートされた順序でアクセスされることに注意してください。</target>
        </trans-unit>
        <trans-unit id="d4a14000f7e28706a0e6c2e4729bb02543a4d281" translate="yes" xml:space="preserve">
          <source>Instead of reading tree object(s) into the index, just empty it.</source>
          <target state="translated">ツリーオブジェクトをインデックスに読み込むのではなく、空にしてください。</target>
        </trans-unit>
        <trans-unit id="5828d05fd5c0a35f4392daf67536f9a77ece2b90" translate="yes" xml:space="preserve">
          <source>Instead of running &lt;code&gt;git repack&lt;/code&gt; you can also run &lt;code&gt;git gc
--aggressive&lt;/code&gt;, which will also optimize other things after an import (e.g. pack loose refs). As noted in the &quot;AGGRESSIVE&quot; section in &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt; the &lt;code&gt;--aggressive&lt;/code&gt; option will find new deltas with the &lt;code&gt;-f&lt;/code&gt; option to &lt;a href=&quot;git-repack&quot;&gt;git-repack[1]&lt;/a&gt;. For the reasons elaborated on above using &lt;code&gt;--aggressive&lt;/code&gt; after a fast-import is one of the few cases where it&amp;rsquo;s known to be worthwhile.</source>
          <target state="translated">代わりに、実行中の &lt;code&gt;git repack&lt;/code&gt; あなたも実行することができます &lt;code&gt;git gc --aggressive&lt;/code&gt; （例えば緩い参考文献パック）、また、インポート後に他のものを最適化するであろうが。で「AGGRESSIVE」の項で述べたよう&lt;a href=&quot;git-gc&quot;&gt;にgit-GC [1] &lt;/a&gt; &lt;code&gt;--aggressive&lt;/code&gt; オプションは使用して新しいデルタいます &lt;code&gt;-f&lt;/code&gt; のオプション&lt;a href=&quot;git-repack&quot;&gt;はgit-再パック[1] &lt;/a&gt;。上記で詳述した理由により、高速インポート後に &lt;code&gt;--aggressive&lt;/code&gt; を使用することは、価値があることがわかっている数少ないケースの1つです。</target>
        </trans-unit>
        <trans-unit id="27d7e1d82cdbf4a022b1041bc3a4b5c02db03622" translate="yes" xml:space="preserve">
          <source>Instead of running one of the known diff tools, &lt;code&gt;git difftool&lt;/code&gt; can be customized to run an alternative program by specifying the command line to invoke in a configuration variable &lt;code&gt;difftool.&amp;lt;tool&amp;gt;.cmd&lt;/code&gt;.</source>
          <target state="translated">既知のdiffツールの1つを実行する代わりに、 &lt;code&gt;git difftool&lt;/code&gt; をカスタマイズして、構成変数 &lt;code&gt;difftool.&amp;lt;tool&amp;gt;.cmd&lt;/code&gt; 呼び出すコマンドラインを指定することにより、代替プログラムを実行できます。</target>
        </trans-unit>
        <trans-unit id="0a6ec50c9a1e350ef9a3f4f762c317cd2d6e8233" translate="yes" xml:space="preserve">
          <source>Instead of running one of the known merge tool programs, &lt;code&gt;git mergetool&lt;/code&gt; can be customized to run an alternative program by specifying the command line to invoke in a configuration variable &lt;code&gt;mergetool.&amp;lt;tool&amp;gt;.cmd&lt;/code&gt;.</source>
          <target state="translated">既知のマージツールプログラムのいずれかを実行する代わりに、 &lt;code&gt;git mergetool&lt;/code&gt; をカスタマイズして、構成変数 &lt;code&gt;mergetool.&amp;lt;tool&amp;gt;.cmd&lt;/code&gt; 呼び出すコマンドラインを指定することにより、代替プログラムを実行できます。</target>
        </trans-unit>
        <trans-unit id="09dffc4d1650e5ccccc05b0bf19a3e3e59eb7116" translate="yes" xml:space="preserve">
          <source>Instead of searching tracked files in the working tree, search blobs in the given trees.</source>
          <target state="translated">作業ツリーで追跡されたファイルを検索するのではなく、与えられたツリーでブロブを検索します。</target>
        </trans-unit>
        <trans-unit id="31ae83b44368ffd8feca3b205d3db8ea7d6a3c5c" translate="yes" xml:space="preserve">
          <source>Instead of searching tracked files in the working tree, search blobs registered in the index file.</source>
          <target state="translated">作業ツリー内の追跡ファイルを検索するのではなく、インデックスファイルに登録されているブロブを検索します。</target>
        </trans-unit>
        <trans-unit id="55e6c9aa38dceb73a0632da59bc95f69bdfc3cb4" translate="yes" xml:space="preserve">
          <source>Instead of showing every matched line, show only the names of files that contain (or do not contain) matches. For better compatibility with &lt;code&gt;git diff&lt;/code&gt;, &lt;code&gt;--name-only&lt;/code&gt; is a synonym for &lt;code&gt;--files-with-matches&lt;/code&gt;.</source>
          <target state="translated">一致したすべての行を表示する代わりに、一致を含む（または含まない）ファイルの名前のみを表示します。 &lt;code&gt;git diff&lt;/code&gt; との互換性を高めるため &lt;code&gt;--files-with-matches&lt;/code&gt; &lt;code&gt;--name-only&lt;/code&gt; は--files-with-matchesの同義語です。</target>
        </trans-unit>
        <trans-unit id="f1fdcf67f0afaa931922f6239ba4fdd53758ce0d" translate="yes" xml:space="preserve">
          <source>Instead of showing every matched line, show the number of lines that match.</source>
          <target state="translated">一致した行をすべて表示するのではなく、一致した行の数を表示します。</target>
        </trans-unit>
        <trans-unit id="9ddb49ffe2885e9ce52c33a63e80e23af2a075a9" translate="yes" xml:space="preserve">
          <source>Instead of showing the commit list, determine possible merge bases for the specified commits. All merge bases will be contained in all specified commits. This is different from how &lt;a href=&quot;git-merge-base&quot;&gt;git-merge-base[1]&lt;/a&gt; handles the case of three or more commits.</source>
          <target state="translated">コミットリストを表示する代わりに、指定されたコミットの可能なマージベースを決定します。すべてのマージベースは、指定されたすべてのコミットに含まれます。これは、&lt;a href=&quot;git-merge-base&quot;&gt;git-merge-base [1]&lt;/a&gt;が3つ以上のコミットのケースを処理する方法とは異なります。</target>
        </trans-unit>
        <trans-unit id="6ba3d7561fe60e77ce239084badd1d1856e50d97" translate="yes" xml:space="preserve">
          <source>Instead of showing the full 40-byte hexadecimal commit object name, show only a partial prefix. Non default number of digits can be specified with &quot;--abbrev=&amp;lt;n&amp;gt;&quot; (which also modifies diff output, if it is displayed).</source>
          <target state="translated">40バイトの16進数のコミットオブジェクト名全体を表示する代わりに、部分的なプレフィックスのみを表示します。デフォルト以外の桁数は、「-abbrev = &amp;lt;n&amp;gt;」で指定できます（これにより、diff出力が表示されている場合は、それも変更されます）。</target>
        </trans-unit>
        <trans-unit id="7d6a3b8755cc865088fd97c8d79f6b68eb4292bc" translate="yes" xml:space="preserve">
          <source>Instead of showing the full 40-byte hexadecimal object lines, show only a partial prefix. Non default number of digits can be specified with --abbrev=&amp;lt;n&amp;gt;.</source>
          <target state="translated">40バイトの16進数のオブジェクト行全体を表示する代わりに、部分的なプレフィックスのみを表示します。--abbrev = &amp;lt;n&amp;gt;を使用すると、デフォルト以外の桁数を指定できます。</target>
        </trans-unit>
        <trans-unit id="58ecb5df7fcdb6c0e019f4aa574b567ad3276395" translate="yes" xml:space="preserve">
          <source>Instead of showing the full 40-byte hexadecimal object name in diff-raw format output and diff-tree header lines, show only a partial prefix. In diff-patch output format, &lt;code&gt;--full-index&lt;/code&gt; takes higher precedence, i.e. if &lt;code&gt;--full-index&lt;/code&gt; is specified, full blob names will be shown regardless of &lt;code&gt;--abbrev&lt;/code&gt;. Non default number of digits can be specified with &lt;code&gt;--abbrev=&amp;lt;n&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">40バイトの16進オブジェクト名全体をdiff-raw形式の出力とdiff-treeヘッダー行に表示する代わりに、部分的なプレフィックスのみを表示します。差分パッチの出力形式では、 &lt;code&gt;--full-index&lt;/code&gt; あれば、すなわち、高い優先さ &lt;code&gt;--full-index&lt;/code&gt; 指定され、完全なブロブ名は関係なく、表示されます &lt;code&gt;--abbrev&lt;/code&gt; 。デフォルト以外の桁数は、 &lt;code&gt;--abbrev=&amp;lt;n&amp;gt;&lt;/code&gt; で指定できます。</target>
        </trans-unit>
        <trans-unit id="dcd3315e868be633e341c6b1fc6b217d4459f224" translate="yes" xml:space="preserve">
          <source>Instead of showing the full 40-byte hexadecimal object name in diff-raw format output and diff-tree header lines, show only a partial prefix. This is independent of the &lt;code&gt;--full-index&lt;/code&gt; option above, which controls the diff-patch output format. Non default number of digits can be specified with &lt;code&gt;--abbrev=&amp;lt;n&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">完全な40バイトの16進オブジェクト名をdiff-raw形式の出力とdiff-treeヘッダー行で表示する代わりに、部分的なプレフィックスのみを表示します。これは、diff-patch出力形式を制御する上記の &lt;code&gt;--full-index&lt;/code&gt; オプションとは無関係です。 &lt;code&gt;--abbrev=&amp;lt;n&amp;gt;&lt;/code&gt; を使用すると、デフォルト以外の桁数を指定できます。</target>
        </trans-unit>
        <trans-unit id="0ac504d3062e8b5bad74846fd627b7807bedc4f2" translate="yes" xml:space="preserve">
          <source>Instead of showing the path names relative to the current working directory, show the full path names.</source>
          <target state="translated">現在の作業ディレクトリからの相対パス名を表示する代わりに、フルパス名を表示します。</target>
        </trans-unit>
        <trans-unit id="5f0ed09aafafab46ef0c48e35d2b30851c21ae6a" translate="yes" xml:space="preserve">
          <source>Instead of staging files after each individual change, you can tell &lt;code&gt;git commit&lt;/code&gt; to notice the changes to the files whose contents are tracked in your working tree and do corresponding &lt;code&gt;git add&lt;/code&gt; and &lt;code&gt;git rm&lt;/code&gt; for you. That is, this example does the same as the earlier example if there is no other change in your working tree:</source>
          <target state="translated">個々の変更後にファイルをステージングする代わりに、作業ツリーで内容が追跡されているファイルへの変更を &lt;code&gt;git commit&lt;/code&gt; に通知し、対応する &lt;code&gt;git add&lt;/code&gt; および &lt;code&gt;git rm&lt;/code&gt; を実行することができます。つまり、作業ツリーに他の変更がない場合、この例は前の例と同じです。</target>
        </trans-unit>
        <trans-unit id="a675a0b8f5c03b948f0d18f87a17852f45d21abd" translate="yes" xml:space="preserve">
          <source>Instead of stopping at the first failed merge, do all of them in one shot - continue with merging even when previous merges returned errors, and only return the error code after all the merges.</source>
          <target state="translated">最初の失敗したマージで止まるのではなく、一発ですべてのマージを行う-前回のマージでエラーが出た場合でもマージを続け、すべてのマージの後にエラーコードだけを返す。</target>
        </trans-unit>
        <trans-unit id="de32bccd3ddde71a98cffd2de1232e1c99dfd513" translate="yes" xml:space="preserve">
          <source>Instead of submitting create a series of shelved changelists. After creating each shelve, the relevant files are reverted/deleted. If you have multiple commits pending multiple shelves will be created.</source>
          <target state="translated">提出する代わりに、一連の棚付き変更リストを作成してください。それぞれの棚を作成した後、関連するファイルは戻されたり削除されたりします。複数のコミットが保留されている場合は、複数の棚が作成されます。</target>
        </trans-unit>
        <trans-unit id="140c71a8b471c44c130e5b1eee8b0237e8238e05" translate="yes" xml:space="preserve">
          <source>Instead of taking list of paths from the command line, read list of paths from the standard input. Paths are separated by LF (i.e. one path per line) by default.</source>
          <target state="translated">コマンドラインからパスのリストを取得する代わりに、標準入力からパスのリストを読み込みます。デフォルトではパスは LF で区切られています (つまり 1 行に 1 パス)。</target>
        </trans-unit>
        <trans-unit id="f4ba2e4e1080efba3c28ca42286f9295fb7a6889" translate="yes" xml:space="preserve">
          <source>Instead of the commit subject, use some other information to describe each commit. &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; can be any string accepted by the &lt;code&gt;--format&lt;/code&gt; option of &lt;code&gt;git log&lt;/code&gt;, such as &lt;code&gt;* [%h] %s&lt;/code&gt;. (See the &quot;PRETTY FORMATS&quot; section of &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;.)</source>
          <target state="translated">コミットの件名の代わりに、他の情報を使用して各コミットを説明します。 &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; は、 &lt;code&gt;* [%h] %s&lt;/code&gt; など、 &lt;code&gt;git log&lt;/code&gt; の &lt;code&gt;--format&lt;/code&gt; オプションで受け入れられる任意の文字列です。（&lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt;の「PRETTY FORMATS」セクションを参照してください。）</target>
        </trans-unit>
        <trans-unit id="a4e872330a2ee34ffbac6bb806a9bf43b1d76b3c" translate="yes" xml:space="preserve">
          <source>Instead of the content, show the object size identified by &amp;lt;object&amp;gt;.</source>
          <target state="translated">コンテンツの代わりに、&amp;lt;object&amp;gt;で識別されるオブジェクトサイズを表示します。</target>
        </trans-unit>
        <trans-unit id="f066e23ab4bd2d63e94325b4a2a048945fb424e1" translate="yes" xml:space="preserve">
          <source>Instead of the content, show the object type identified by &amp;lt;object&amp;gt;.</source>
          <target state="translated">コンテンツの代わりに、&amp;lt;object&amp;gt;で識別されるオブジェクトタイプを表示します。</target>
        </trans-unit>
        <trans-unit id="01b660ce7f25b8747605b72657d7e3925704df33" translate="yes" xml:space="preserve">
          <source>Instead of the default &quot;symref&quot; format for HEAD and other symbolic reference files, use symbolic links. This is sometimes needed to work with old scripts that expect HEAD to be a symbolic link.</source>
          <target state="translated">HEAD やその他のシンボリック参照ファイルのデフォルトの &quot;symref&quot; フォーマットの代わりに、シンボリックリンクを使用してください。これは、HEAD がシンボリックリンクであることを期待している古いスクリプトで動作させるために必要になることがあります。</target>
        </trans-unit>
        <trans-unit id="f146d5682a8b5a97d10d05b37274aa1ba3a49c07" translate="yes" xml:space="preserve">
          <source>Instead of the default 4 digits with leading zeros, different precision can be specified for the generated filenames.</source>
          <target state="translated">デフォルトの4桁の先頭ゼロの代わりに、生成されるファイル名に異なる精度を指定することができます。</target>
        </trans-unit>
        <trans-unit id="e1d28ba0f9256454e559ca46e186461c224089ef" translate="yes" xml:space="preserve">
          <source>Instead of the first handful of characters, show the full pre- and post-image blob object names on the &quot;index&quot; line when generating patch format output.</source>
          <target state="translated">パッチフォーマット出力を生成する際に、最初の一握りの文字の代わりに、&quot;index &quot;行に画像前後の完全なブロブオブジェクト名を表示するようにしました。</target>
        </trans-unit>
        <trans-unit id="e3b6588aa8ce45f7528fa4adfa5f41dc47858a56" translate="yes" xml:space="preserve">
          <source>Instead of the normal operation, dump the shorthand alias names from the configured alias file(s), one per line in alphabetical order. Note, this only includes the alias name and not its expanded email addresses. See &lt;code&gt;sendemail.aliasesfile&lt;/code&gt; for more information about aliases.</source>
          <target state="translated">通常の操作の代わりに、構成されたエイリアスファイルから、アルファベット順で1行に1つずつ、省略エイリアス名をダンプします。これにはエイリアス名のみが含まれ、拡張されたメールアドレスは含まれません。エイリアスの詳細については、 &lt;code&gt;sendemail.aliasesfile&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="77a59d82290cfd961dc9ff35f15683facfa89709" translate="yes" xml:space="preserve">
          <source>Instead of the standard &lt;code&gt;[PATCH]&lt;/code&gt; prefix in the subject line, instead use &lt;code&gt;[&amp;lt;subject prefix&amp;gt;]&lt;/code&gt;. This allows for useful naming of a patch series, and can be combined with the &lt;code&gt;--numbered&lt;/code&gt; option.</source>
          <target state="translated">件名行の標準の &lt;code&gt;[PATCH]&lt;/code&gt; 接頭辞の代わりに、 &lt;code&gt;[&amp;lt;subject prefix&amp;gt;]&lt;/code&gt; を使用します。これにより、パッチシリーズに便利な名前を付けることができ、 &lt;code&gt;--numbered&lt;/code&gt; オプションと組み合わせることができます。</target>
        </trans-unit>
        <trans-unit id="440b20677cca3bad5d5589368544d09ff6997de8" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;a href=&quot;git-remote&quot;&gt;git-remote[1]&lt;/a&gt;, you can also choose just to update one branch at a time, and to store it locally under an arbitrary name:</source>
          <target state="translated">&lt;a href=&quot;git-remote&quot;&gt;git-remote [1]&lt;/a&gt;を使用する代わりに、一度に1つのブランチのみを更新して、任意の名前でローカルに保存することもできます。</target>
        </trans-unit>
        <trans-unit id="c80da0469d96c6db5cfae1c5b4b2cc65c570bdb0" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;.patch&lt;/code&gt; as the suffix for generated filenames, use specified suffix. A common alternative is &lt;code&gt;--suffix=.txt&lt;/code&gt;. Leaving this empty will remove the &lt;code&gt;.patch&lt;/code&gt; suffix.</source>
          <target state="translated">生成されたファイル名のサフィックスとして &lt;code&gt;.patch&lt;/code&gt; を使用する代わりに、指定されたサフィックスを使用してください。一般的な代替手段は &lt;code&gt;--suffix=.txt&lt;/code&gt; です。空のままにすると、 &lt;code&gt;.patch&lt;/code&gt; サフィックスが削除されます。</target>
        </trans-unit>
        <trans-unit id="f82d2e94f21038afaa9f1d66d3a9a0e365538f7c" translate="yes" xml:space="preserve">
          <source>Instead of using only the annotated tags, use any ref found in &lt;code&gt;refs/&lt;/code&gt; namespace. This option enables matching any known branch, remote-tracking branch, or lightweight tag.</source>
          <target state="translated">注釈付きタグのみを使用する代わりに、 &lt;code&gt;refs/&lt;/code&gt; 名前空間にある任意の参照を使用します。このオプションを使用すると、既知のブランチ、リモート追跡ブランチ、または軽量タグに一致させることができます。</target>
        </trans-unit>
        <trans-unit id="1177311a3949b6b80d45daef7bf2616b79441b65" translate="yes" xml:space="preserve">
          <source>Instead of using only the annotated tags, use any tag found in &lt;code&gt;refs/tags&lt;/code&gt; namespace. This option enables matching a lightweight (non-annotated) tag.</source>
          <target state="translated">注釈付きタグのみを使用する代わりに、 &lt;code&gt;refs/tags&lt;/code&gt; 名前空間にある任意のタグを使用します。このオプションを使用すると、軽量（注釈なし）タグの照合が可能になります。</target>
        </trans-unit>
        <trans-unit id="525df652b887a2877266435635ef66426239fc1d" translate="yes" xml:space="preserve">
          <source>Instead of using the author date of the original commit, use the current time as the author date of the rebased commit. This option implies &lt;code&gt;--force-rebase&lt;/code&gt;.</source>
          <target state="translated">元のコミットの作成者の日付を使用する代わりに、現在の時刻をリベースされたコミットの作成者の日付として使用します。このオプションは、 &lt;code&gt;--force-rebase&lt;/code&gt; 意味します。</target>
        </trans-unit>
        <trans-unit id="4860002e825b16be9527700d7d5e647a6362a7ef" translate="yes" xml:space="preserve">
          <source>Instead of using the current time as the committer date, use the author date of the commit being rebased as the committer date. This option implies &lt;code&gt;--force-rebase&lt;/code&gt;.</source>
          <target state="translated">現在の時刻をコミッターの日付として使用する代わりに、リベースされるコミットの作成者の日付をコミッターの日付として使用します。このオプションは、 &lt;code&gt;--force-rebase&lt;/code&gt; 意味します。</target>
        </trans-unit>
        <trans-unit id="fa50874379be0d623d79d8af182cc42f83a49b1c" translate="yes" xml:space="preserve">
          <source>Instead of using the default 7 hexadecimal digits as the abbreviated object name, use &amp;lt;n&amp;gt; digits, or as many digits as needed to form a unique object name. An &amp;lt;n&amp;gt; of 0 will suppress long format, only showing the closest tag.</source>
          <target state="translated">省略形のオブジェクト名としてデフォルトの7桁の16進数を使用する代わりに、&amp;lt;n&amp;gt;桁、または一意のオブジェクト名を形成するために必要な数の桁を使用します。&amp;lt;n&amp;gt;が0の場合、長い形式が抑制され、最も近いタグのみが表示されます。</target>
        </trans-unit>
        <trans-unit id="183487409af3884cbc9c819c550a69752622875c" translate="yes" xml:space="preserve">
          <source>Instead of using the default 7+1 hexadecimal digits as the abbreviated object name, use &amp;lt;n&amp;gt;+1 digits. Note that 1 column is used for a caret to mark the boundary commit.</source>
          <target state="translated">省略されたオブジェクト名としてデフォルトの7 + 1 16進数を使用する代わりに、&amp;lt;n&amp;gt; +1桁を使用します。キャレットが境界コミットをマークするために1列が使用されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="ee5547b5d72f6d52e84d0986cad360b6f68e956a" translate="yes" xml:space="preserve">
          <source>Instead of using the remote name &lt;code&gt;origin&lt;/code&gt; to keep track of the upstream repository, use &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">上流リポジトリを追跡するためにリモート名 &lt;code&gt;origin&lt;/code&gt; を使用する代わりに、 &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="acaf18a5ec5cac3fd2f3b3d56ba27133d9e16abf" translate="yes" xml:space="preserve">
          <source>Instead of using the tip of the current branch, compare with the tip of &quot;test&quot; branch.</source>
          <target state="translated">現在のブランチの先端を使うのではなく、&quot;test &quot;ブランチの先端と比較してみてください。</target>
        </trans-unit>
        <trans-unit id="0e0bb2a4d944b8f5531055e279607820e676a94b" translate="yes" xml:space="preserve">
          <source>Instead of walking the commit ancestry chain, walk reflog entries from the most recent one to older ones. When this option is used you cannot specify commits to exclude (that is, &lt;code&gt;^commit&lt;/code&gt;, &lt;code&gt;commit1..commit2&lt;/code&gt;, and &lt;code&gt;commit1...commit2&lt;/code&gt; notations cannot be used).</source>
          <target state="translated">コミット先祖チェーンを歩く代わりに、reflogエントリーを最新のものから古いものにウォークします。このオプションを使用すると、除外するコミットを指定できません（つまり、 &lt;code&gt;^commit&lt;/code&gt; 、 &lt;code&gt;commit1..commit2&lt;/code&gt; 、および &lt;code&gt;commit1...commit2&lt;/code&gt; 表記は使用できません）。</target>
        </trans-unit>
        <trans-unit id="00c411b0a21221afdc6e21c624bf253d7212e3a9" translate="yes" xml:space="preserve">
          <source>Instead of writing the results out to &lt;code&gt;$GIT_INDEX_FILE&lt;/code&gt;, write the resulting index in the named file. While the command is operating, the original index file is locked with the same mechanism as usual. The file must allow to be rename(2)ed into from a temporary file that is created next to the usual index file; typically this means it needs to be on the same filesystem as the index file itself, and you need write permission to the directories the index file and index output file are located in.</source>
          <target state="translated">結果を &lt;code&gt;$GIT_INDEX_FILE&lt;/code&gt; に書き込む代わりに、結果のインデックスを名前付きファイルに書き込みます。コマンドが動作している間、元のインデックスファイルは通常と同じメカニズムでロックされます。ファイルは、通常のインデックスファイルの隣に作成される一時ファイルからの名前変更（2）を許可する必要があります。通常、これはインデックスファイル自体と同じファイルシステム上にある必要があり、インデックスファイルとインデックス出力ファイルが配置されているディレクトリへの書き込み権限が必要であることを意味します。</target>
        </trans-unit>
        <trans-unit id="ef06396aed739ff032fb1ddeda938ad4cf5e4280" translate="yes" xml:space="preserve">
          <source>Instruct Git to avoid trying to guess defaults for &lt;code&gt;user.email&lt;/code&gt; and &lt;code&gt;user.name&lt;/code&gt;, and instead retrieve the values only from the configuration. For example, if you have multiple email addresses and would like to use a different one for each repository, then with this configuration option set to &lt;code&gt;true&lt;/code&gt; in the global config along with a name, Git will prompt you to set up an email before making new commits in a newly cloned repository. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;user.email&lt;/code&gt; と &lt;code&gt;user.name&lt;/code&gt; のデフォルトを推測せずに、構成からのみ値を取得するようにGitに指示します。たとえば、複数の電子メールアドレスがあり、リポジトリごとに異なるアドレスを使用する場合、この構成オプションを名前とともにグローバル構成で &lt;code&gt;true&lt;/code&gt; に設定すると、Gitは新しいメールアドレスを作成する前に電子メールを設定するように求めます新しく複製されたリポジトリでコミットします。デフォルトは &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="a592acd9f11ad3bff77a1878bfa756913e7df3fe" translate="yes" xml:space="preserve">
          <source>Instruction to add new data</source>
          <target state="translated">新しいデータを追加する命令</target>
        </trans-unit>
        <trans-unit id="c222c271406b6a5c2fcfc84ba72b7981aee6b09e" translate="yes" xml:space="preserve">
          <source>Instruction to copy from base object</source>
          <target state="translated">ベースオブジェクトからのコピー命令</target>
        </trans-unit>
        <trans-unit id="6131d2bc98a67fbf2df419d53c2a5951a56eb747" translate="yes" xml:space="preserve">
          <source>Instructs the remote helper that any subsequent input is part of a fast-import stream (generated by &lt;code&gt;git fast-export&lt;/code&gt;) containing objects which should be pushed to the remote.</source>
          <target state="translated">後続の入力は、リモートにプッシュする必要があるオブジェクトを含む &lt;code&gt;git fast-export&lt;/code&gt; インポートストリーム（git fast-exportによって生成）の一部であることをリモートヘルパーに指示します。</target>
        </trans-unit>
        <trans-unit id="563eacc97631ea8eeadfe6b54ffbd63455326490" translate="yes" xml:space="preserve">
          <source>Integer. Specifies desired depth of nested regions in the event output. Regions deeper than this value will be omitted. May be overridden by the &lt;code&gt;GIT_TRACE2_EVENT_NESTING&lt;/code&gt; environment variable. Defaults to 2.</source>
          <target state="translated">整数。イベント出力でネストされた領域の必要な深さを指定します。この値より深い領域は省略されます。 &lt;code&gt;GIT_TRACE2_EVENT_NESTING&lt;/code&gt; 環境変数によってオーバーライドされる場合があります。デフォルトは2です。</target>
        </trans-unit>
        <trans-unit id="f3e0144605c9578fc597fd7ff39de75aab2afefe" translate="yes" xml:space="preserve">
          <source>Integer. When writing trace files to a target directory, do not write additional traces if we would exceed this many files. Instead, write a sentinel file that will block further tracing to this directory. Defaults to 0, which disables this check.</source>
          <target state="translated">整数です。ターゲットディレクトリにトレースファイルを書き込む際、この数を超える場合は追加のトレースファイルを書かないようにしてください。代わりに、このディレクトリへのそれ以上のトレースをブロックするセンチネルファイルを書きます。デフォルトは 0 で、このチェックを無効にします。</target>
        </trans-unit>
        <trans-unit id="a6768cae9c51930f13c302375f3385c6c77b2104" translate="yes" xml:space="preserve">
          <source>Integrator</source>
          <target state="translated">Integrator</target>
        </trans-unit>
        <trans-unit id="e30f6e398ba3d7dd3d6ee2f7d0d8940d3116f2a5" translate="yes" xml:space="preserve">
          <source>Interacting with Others</source>
          <target state="translated">他者との交流</target>
        </trans-unit>
        <trans-unit id="e9854d76872b55831675241f09e80f37f1939cea" translate="yes" xml:space="preserve">
          <source>Interaction between checkin/checkout attributes</source>
          <target state="translated">チェックイン/チェックアウト属性間の相互作用</target>
        </trans-unit>
        <trans-unit id="0d798c0b1cd4a6d135dc1e4671cde5f33dab863b" translate="yes" xml:space="preserve">
          <source>Interactive mode</source>
          <target state="translated">インタラクティブモード</target>
        </trans-unit>
        <trans-unit id="fb0ea93fbb85b738df0bd31fcf1bc9eb5468d22b" translate="yes" xml:space="preserve">
          <source>Interactive use</source>
          <target state="translated">インタラクティブな使用</target>
        </trans-unit>
        <trans-unit id="94db97a8381d05a800daa18ce0818d37326de61f" translate="yes" xml:space="preserve">
          <source>Interactively choose hunks of patch between the index and the work tree and add them to the index. This gives the user a chance to review the difference before adding modified contents to the index.</source>
          <target state="translated">インデックスとワークツリーの間にあるパッチの塊をインタラクティブに選択し、インデックスに追加します。これにより、変更された内容をインデックスに追加する前に、ユーザーが差分を確認する機会が得られます。</target>
        </trans-unit>
        <trans-unit id="bfdd4f344b8dfb9b5f469d3e0a6945b89367454c" translate="yes" xml:space="preserve">
          <source>Interactively select hunks from the diff between HEAD and the working tree to be stashed. The stash entry is constructed such that its index state is the same as the index state of your repository, and its worktree contains only the changes you selected interactively. The selected changes are then rolled back from your worktree. See the &amp;ldquo;Interactive Mode&amp;rdquo; section of &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; to learn how to operate the &lt;code&gt;--patch&lt;/code&gt; mode.</source>
          <target state="translated">HEADと隠しておく作業ツリーの差分からハンクをインタラクティブに選択します。 stashエントリは、そのインデックス状態がリポジトリのインデックス状態と同じになるように構築され、そのワークツリーには、インタラクティブに選択した変更のみが含まれます。選択した変更は、ワークツリーからロールバックされます。 &lt;code&gt;--patch&lt;/code&gt; モードの操作方法については、&lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt;の「インタラクティブモード」セクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="942e3b50f8575a931a7b62b4970978b40b59bcee" translate="yes" xml:space="preserve">
          <source>Interactively select hunks in the difference between the &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; (or the index, if unspecified) and the working tree. The chosen hunks are then applied in reverse to the working tree (and if a &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; was specified, the index).</source>
          <target state="translated">&lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; （または、指定されていない場合はインデックス）と作業ツリーの違いから、対話的にハンクを選択します。次に、選択されたハンクが作業ツリーに逆に適用されます（ &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; が指定されている場合はインデックス）。</target>
        </trans-unit>
        <trans-unit id="6b61a0bfaba36c21326a6cc1d8076250bbb8f781" translate="yes" xml:space="preserve">
          <source>Interactively select hunks in the difference between the index and &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; (defaults to &lt;code&gt;HEAD&lt;/code&gt;). The chosen hunks are applied in reverse to the index.</source>
          <target state="translated">インデックスと &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; の違いでハンクを対話的に選択します（デフォルトは &lt;code&gt;HEAD&lt;/code&gt; です）。選択されたハンクは、逆にインデックスに適用されます。</target>
        </trans-unit>
        <trans-unit id="11c4e8d4b31fcec1faa8b21ab916ae6d7ecd6196" translate="yes" xml:space="preserve">
          <source>Interactively select hunks in the difference between the restore source and the restore location. See the &amp;ldquo;Interactive Mode&amp;rdquo; section of &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; to learn how to operate the &lt;code&gt;--patch&lt;/code&gt; mode.</source>
          <target state="translated">復元ソースと復元場所の違いにあるハンクを対話的に選択します。 &lt;code&gt;--patch&lt;/code&gt; モードの操作方法については、&lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt;の「インタラクティブモード」セクションをご覧ください。</target>
        </trans-unit>
        <trans-unit id="37d460e42c18dd6a2f67dd6cfcf736b2dc4e3735" translate="yes" xml:space="preserve">
          <source>Internal detail of implementation. What is important is that if this field is not present then per-repository override for given feature is not supported.</source>
          <target state="translated">実装の内部詳細。重要なのは、このフィールドが存在しない場合、指定された機能のリポジトリごとのオーバーライドはサポートされないということです。</target>
        </trans-unit>
        <trans-unit id="fcd742802f00593c0aa9a5d67d6ee0045ea54dd6" translate="yes" xml:space="preserve">
          <source>Internal helper commands</source>
          <target state="translated">内部ヘルパーコマンド</target>
        </trans-unit>
        <trans-unit id="99089329f972015329c6ab2c5f20f49ab1b0fb2e" translate="yes" xml:space="preserve">
          <source>Internal variable identifying the repository format and layout version.</source>
          <target state="translated">リポジトリのフォーマットとレイアウトのバージョンを識別する内部変数。</target>
        </trans-unit>
        <trans-unit id="d2a9fe262eee692f1042088fcd5412df8b02ed0e" translate="yes" xml:space="preserve">
          <source>Internal variable which enables various workarounds to enable Git to work better on filesystems that are not case sensitive, like APFS, HFS+, FAT, NTFS, etc. For example, if a directory listing finds &quot;makefile&quot; when Git expects &quot;Makefile&quot;, Git will assume it is really the same file, and continue to remember it as &quot;Makefile&quot;.</source>
          <target state="translated">APFS、HFS+、FAT、NTFS などの大文字小文字を区別しないファイルシステム上で Git がよりよく動作するようにするための様々な回避策を可能にする内部変数です。例えば、Git が &quot;Makefile&quot; を期待しているときに &quot;makefile&quot; を見つけた場合、Git はそれが本当に同じファイルであるとみなし、それを &quot;Makefile&quot; として記憶し続けます。</target>
        </trans-unit>
        <trans-unit id="fd5dd045ecadbef7edb9976d5bf76d5e7548b5a7" translate="yes" xml:space="preserve">
          <source>Interpret &amp;lt;refname&amp;gt; as a reference name pattern for a refspec (as used with remote repositories). If this option is enabled, &amp;lt;refname&amp;gt; is allowed to contain a single &lt;code&gt;*&lt;/code&gt; in the refspec (e.g., &lt;code&gt;foo/bar*/baz&lt;/code&gt; or &lt;code&gt;foo/bar*baz/&lt;/code&gt; but not &lt;code&gt;foo/bar*/baz*&lt;/code&gt;).</source>
          <target state="translated">&amp;lt;refname&amp;gt;を（リモートリポジトリで使用される）refspecの参照名パターンとして解釈します。このオプションが有効な場合、&amp;lt;refname&amp;gt;はrefspecに単一の &lt;code&gt;*&lt;/code&gt; を含めることができます（たとえば、 &lt;code&gt;foo/bar*/baz&lt;/code&gt; または &lt;code&gt;foo/bar*baz/&lt;/code&gt; が、 &lt;code&gt;foo/bar*/baz*&lt;/code&gt; は許可されません）。</target>
        </trans-unit>
        <trans-unit id="670ef7722a61e3342fef6602c3dc04b50457ccb3" translate="yes" xml:space="preserve">
          <source>Interpret all preceding arguments as attributes and all following arguments as path names.</source>
          <target state="translated">前のすべての引数を属性として、後のすべての引数をパス名として解釈します。</target>
        </trans-unit>
        <trans-unit id="c75cadb4ae816991e0dd6b40f2cda63b6ea63eb7" translate="yes" xml:space="preserve">
          <source>Interrogation commands</source>
          <target state="translated">尋問コマンド</target>
        </trans-unit>
        <trans-unit id="f1e6fa1e2ddb5fcd808e3092148f74242800360f" translate="yes" xml:space="preserve">
          <source>Interrogators:</source>
          <target state="translated">Interrogators:</target>
        </trans-unit>
        <trans-unit id="8b0b6bf2544da29702a138cd7dd487472490ccff" translate="yes" xml:space="preserve">
          <source>Interrupt transfer after &amp;lt;n&amp;gt; seconds of inactivity.</source>
          <target state="translated">非アクティブな状態が&amp;lt;n&amp;gt;秒続いた後に転送を中断します。</target>
        </trans-unit>
        <trans-unit id="fb3e70f97505597e5558a144342f8608c6471e9a" translate="yes" xml:space="preserve">
          <source>Interruptability</source>
          <target state="translated">Interruptability</target>
        </trans-unit>
        <trans-unit id="9f1df172d790d81927bf10eb32b7a53862fd94a5" translate="yes" xml:space="preserve">
          <source>Interrupted workflow</source>
          <target state="translated">ワークフローの中断</target>
        </trans-unit>
        <trans-unit id="b566252f7afe805214a7771e6b2a586b4e458c82" translate="yes" xml:space="preserve">
          <source>Introduction to &quot;git bisect&quot;</source>
          <target state="translated">git bisect」の紹介</target>
        </trans-unit>
        <trans-unit id="273a20c96a580af6e0e1fc6c4491680cd6e13de6" translate="yes" xml:space="preserve">
          <source>Intuitiveness is not the goal here. Repeatability is. The reason for the &quot;no arguments means no work&quot; behavior is that from scripts you are supposed to be able to do:</source>
          <target state="translated">直感性はここでのゴールではない。重要なのは再現性です。引数がないと仕事にならない」という動作の理由は、スクリプトからできるようになることが前提になっているからです。</target>
        </trans-unit>
        <trans-unit id="6a9b44369c96eafd66d755034e5ce80488ad8832" translate="yes" xml:space="preserve">
          <source>Invocation</source>
          <target state="translated">Invocation</target>
        </trans-unit>
        <trans-unit id="1d5f124f7b2f261867ec41e2c056658bb6e88c34" translate="yes" xml:space="preserve">
          <source>Invoke a text editor (see GIT_EDITOR in &lt;a href=&quot;git-var&quot;&gt;git-var[1]&lt;/a&gt;) to edit an introductory message for the patch series.</source>
          <target state="translated">テキストエディターを呼び出し（&lt;a href=&quot;git-var&quot;&gt;git-var [1]の&lt;/a&gt; GIT_EDITORを参照）、パッチシリーズの紹介メッセージを編集します。</target>
        </trans-unit>
        <trans-unit id="9ba2ef7b89376be98d487b046c212677da3221b4" translate="yes" xml:space="preserve">
          <source>Invoke an editor before committing successful mechanical merge to further edit the auto-generated merge message, so that the user can explain and justify the merge. The &lt;code&gt;--no-edit&lt;/code&gt; option can be used to accept the auto-generated message (this is generally discouraged).</source>
          <target state="translated">機械的なマージをコミットする前にエディターを起動して、自動生成されたマージメッセージをさらに編集し、ユーザーがマージを説明および正当化できるようにします。 &lt;code&gt;--no-edit&lt;/code&gt; オプションは、（これは一般的に推奨され）、自動生成されたメッセージを受け入れるために使用することができます。</target>
        </trans-unit>
        <trans-unit id="a978683542367bbc42f0a41dd9d11a4a00c553d9" translate="yes" xml:space="preserve">
          <source>Invoke an editor before committing successful mechanical merge to further edit the auto-generated merge message, so that the user can explain and justify the merge. The &lt;code&gt;--no-edit&lt;/code&gt; option can be used to accept the auto-generated message (this is generally discouraged). The &lt;code&gt;--edit&lt;/code&gt; (or &lt;code&gt;-e&lt;/code&gt;) option is still useful if you are giving a draft message with the &lt;code&gt;-m&lt;/code&gt; option from the command line and want to edit it in the editor.</source>
          <target state="translated">機械的なマージをコミットする前にエディターを起動して、自動生成されたマージメッセージをさらに編集し、ユーザーがマージを説明および正当化できるようにします。 &lt;code&gt;--no-edit&lt;/code&gt; オプションは、（これは一般的に推奨され）、自動生成されたメッセージを受け入れるために使用することができます。 &lt;code&gt;--edit&lt;/code&gt; （または &lt;code&gt;-e&lt;/code&gt; あなたとドラフトメッセージ与えている場合）オプションはまだ有効です &lt;code&gt;-m&lt;/code&gt; コマンドラインからオプションを、エディタで編集にそれをしたいです。</target>
        </trans-unit>
        <trans-unit id="ab51558f752b86c08b9c277e1cd35bd4f5da28bc" translate="yes" xml:space="preserve">
          <source>Invoke the sendemail-validate hook if present (see &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;).</source>
          <target state="translated">sendemail-validateフックが存在する場合はそれを呼び出します（&lt;a href=&quot;githooks&quot;&gt;githooks [5]を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="6307458f7efb25e5d4237ad7a4e972e464f2ab54" translate="yes" xml:space="preserve">
          <source>Invoked by &lt;code&gt;git archive --remote&lt;/code&gt; and sends a generated archive to the other end over the Git protocol.</source>
          <target state="translated">&lt;code&gt;git archive --remote&lt;/code&gt; によって呼び出され、生成されたアーカイブをGitプロトコルを介して相手側に送信します。</target>
        </trans-unit>
        <trans-unit id="4591feb10dd06f62e310d9c287cf3f981ce9babf" translate="yes" xml:space="preserve">
          <source>Invoked by &lt;code&gt;git fetch-pack&lt;/code&gt;, learns what objects the other side is missing, and sends them after packing.</source>
          <target state="translated">&lt;code&gt;git fetch-pack&lt;/code&gt; によって呼び出され、反対側で欠落しているオブジェクトを学習し、パッキング後に送信します。</target>
        </trans-unit>
        <trans-unit id="a7f91dd525c007f2b681e8a032a0618f9a34ea1c" translate="yes" xml:space="preserve">
          <source>Invoked by &lt;code&gt;git send-pack&lt;/code&gt; and updates the repository with the information fed from the remote end.</source>
          <target state="translated">&lt;code&gt;git send-pack&lt;/code&gt; によって呼び出され、リモートエンドから提供された情報でリポジトリを更新します。</target>
        </trans-unit>
        <trans-unit id="d65563f7b9f547034dceec39b8ac04f9c683c150" translate="yes" xml:space="preserve">
          <source>Invokes &lt;code&gt;git-receive-pack&lt;/code&gt; on a possibly remote repository, and updates it from the current repository, sending named refs.</source>
          <target state="translated">リモートのリポジトリで &lt;code&gt;git-receive-pack&lt;/code&gt; を呼び出し、現在のリポジトリからそれを更新して、名前付き参照を送信します。</target>
        </trans-unit>
        <trans-unit id="b53ca0a7337f2511de77389036559a87c502bc3d" translate="yes" xml:space="preserve">
          <source>Invokes &lt;code&gt;git-upload-pack&lt;/code&gt; on a possibly remote repository and asks it to send objects missing from this repository, to update the named heads. The list of commits available locally is found out by scanning the local refs/ hierarchy and sent to &lt;code&gt;git-upload-pack&lt;/code&gt; running on the other end.</source>
          <target state="translated">可能性のあるリモートリポジトリで &lt;code&gt;git-upload-pack&lt;/code&gt; を呼び出し、このリポジトリにないオブジェクトを送信して、名前付きヘッドを更新するように要求します。ローカルで利用可能なコミットのリストは、ローカルのrefs /階層をスキャンすることによって見つけられ、反対側で実行されている &lt;code&gt;git-upload-pack&lt;/code&gt; に送信されます。</target>
        </trans-unit>
        <trans-unit id="a31ffeaabebc608f725ad5aea0019f330d8c2ea7" translate="yes" xml:space="preserve">
          <source>Invoking &lt;code&gt;git add -e&lt;/code&gt; or selecting &lt;code&gt;e&lt;/code&gt; from the interactive hunk selector will open a patch in your editor; after the editor exits, the result is applied to the index. You are free to make arbitrary changes to the patch, but note that some changes may have confusing results, or even result in a patch that cannot be applied. If you want to abort the operation entirely (i.e., stage nothing new in the index), simply delete all lines of the patch. The list below describes some common things you may see in a patch, and which editing operations make sense on them.</source>
          <target state="translated">&lt;code&gt;git add -e&lt;/code&gt; を呼び出すか、対話型のハンクセレクターから &lt;code&gt;e&lt;/code&gt; を選択すると、エディターでパッチが開きます。エディターが終了すると、結果がインデックスに適用されます。パッチは自由に変更できますが、一部の変更では混乱を招く結果になる場合や、パッチを適用できない場合さえあることに注意してください。操作を完全に中止する場合（つまり、インデックスに新しいものをステージングしない場合）は、パッチのすべての行を削除します。以下のリストは、パッチに表示される可能性のあるいくつかの一般的なものと、それらに対してどの編集操作が意味があるかを説明しています。</target>
        </trans-unit>
        <trans-unit id="7eda501750cd6c5e49ea1b4fd74542b592feab87" translate="yes" xml:space="preserve">
          <source>Involving QA people and if possible end users</source>
          <target state="translated">QA担当者や可能であればエンドユーザーを巻き込む</target>
        </trans-unit>
        <trans-unit id="4ddb9cd693a2e162ef85f6fbfe4abc845111ebb9" translate="yes" xml:space="preserve">
          <source>Is a synonym for &lt;code&gt;zebra&lt;/code&gt;. This may change to a more sensible mode in the future.</source>
          <target state="translated">&lt;code&gt;zebra&lt;/code&gt; 同義語です。これは将来、より適切なモードに変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="4f13daaae3d7fc7ba5d15c4ccfc54188d83d267e" translate="yes" xml:space="preserve">
          <source>Is used as suggested name when creating new branches using the &lt;a href=&quot;git-gui&quot;&gt;git-gui[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;git-gui&quot;&gt;git-gui [1]&lt;/a&gt;を使用して新しいブランチを作成するときに推奨される名前として使用されます。</target>
        </trans-unit>
        <trans-unit id="6f3229278b909458bc76fcc500cf44677191a296" translate="yes" xml:space="preserve">
          <source>Islands are configured via the &lt;code&gt;pack.island&lt;/code&gt; option, which can be specified multiple times. Each value is a left-anchored regular expressions matching refnames. For example:</source>
          <target state="translated">アイランドは、複数回指定できる &lt;code&gt;pack.island&lt;/code&gt; オプションを介して構成されます。各値は、refnameに一致する左にアンカーされた正規表現です。例えば：</target>
        </trans-unit>
        <trans-unit id="30ce4cb25faae86427d8ac22e8f50a0a74f3f393" translate="yes" xml:space="preserve">
          <source>Issues</source>
          <target state="translated">Issues</target>
        </trans-unit>
        <trans-unit id="0120e142d77ed0c1102a3548e5e6ca12ae1c469b" translate="yes" xml:space="preserve">
          <source>Issues which are security relevant should be disclosed privately to the Git Security mailing list &amp;lt;&lt;a href=&quot;mailto:git-security@googlegroups.com&quot;&gt;git-security@googlegroups.com&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">セキュリティ関連の問題は、Git Securityメーリングリスト&amp;lt; &lt;a href=&quot;mailto:git-security@googlegroups.com&quot;&gt;git-security@googlegroups.com&lt;/a&gt; &amp;gt;に非公開で公開する必要があります。</target>
        </trans-unit>
        <trans-unit id="7e6ca0d89968d14a4a145a03ebcf512ab164b2cf" translate="yes" xml:space="preserve">
          <source>Issuing a &lt;code&gt;filedeleteall&lt;/code&gt; followed by the needed &lt;code&gt;filemodify&lt;/code&gt; commands to set the correct content will produce the same results as sending only the needed &lt;code&gt;filemodify&lt;/code&gt; and &lt;code&gt;filedelete&lt;/code&gt; commands. The &lt;code&gt;filedeleteall&lt;/code&gt; approach may however require fast-import to use slightly more memory per active branch (less than 1 MiB for even most large projects); so frontends that can easily obtain only the affected paths for a commit are encouraged to do so.</source>
          <target state="translated">発行 &lt;code&gt;filedeleteall&lt;/code&gt; 必要が続い &lt;code&gt;filemodify&lt;/code&gt; 正しい内容を設定するためのコマンドにのみ必要な送信と同じ結果を生成します &lt;code&gt;filemodify&lt;/code&gt; と &lt;code&gt;filedelete&lt;/code&gt; コマンドを。 &lt;code&gt;filedeleteall&lt;/code&gt; のアプローチは、しかし、（も、最も大規模なプロジェクトのために1未満MIB）能動ブランチあたりわずかに多くのメモリを使用する高速インポートを必要とするかもしれません。そのため、コミットの影響を受けるパスのみを簡単に取得できるフロントエンドは、そうすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="bdf45bc4332be1bec5eceb55b9547e5441cbefc8" translate="yes" xml:space="preserve">
          <source>It adds the submodule&amp;rsquo;s clone path to the &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt; file and adds this file to the index, ready to be committed.</source>
          <target state="translated">サブモジュールのクローンパスを&lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5]&lt;/a&gt;ファイルに追加し、このファイルをインデックスに追加して、コミットする準備が整います。</target>
        </trans-unit>
        <trans-unit id="8c81521fe76c33a9e0c12152a7126a3168cdc6bc" translate="yes" xml:space="preserve">
          <source>It adds the submodule&amp;rsquo;s current commit ID to the index, ready to be committed.</source>
          <target state="translated">サブモジュールの現在のコミットIDをインデックスに追加し、コミットする準備が整います。</target>
        </trans-unit>
        <trans-unit id="d31bfc2387ea73611500553c1004cb0667d4f160" translate="yes" xml:space="preserve">
          <source>It affects the way a change that amounts to a total rewrite of a file not as a series of deletion and insertion mixed together with a very few lines that happen to match textually as the context, but as a single deletion of everything old followed by a single insertion of everything new, and the number &lt;code&gt;m&lt;/code&gt; controls this aspect of the -B option (defaults to 60%). &lt;code&gt;-B/70%&lt;/code&gt; specifies that less than 30% of the original should remain in the result for Git to consider it a total rewrite (i.e. otherwise the resulting patch will be a series of deletion and insertion mixed together with context lines).</source>
          <target state="translated">これは、一連の削除と挿入が混合され、テキストとしてコンテキストとして一致する非常に少数の行ではなく、古いすべての単一の削除とそれに続く新しいものすべてを1回挿入すると、 &lt;code&gt;m&lt;/code&gt; という数字が-Bオプションのこの側面を制御します（デフォルトは60％）。 &lt;code&gt;-B/70%&lt;/code&gt; は、Gitがそれを完全な書き直しと見なすために、元の30％未満が結果に残る必要があることを指定します（それ以外の場合、結果のパッチは、コンテキスト行と混合された一連の削除と挿入になります）。</target>
        </trans-unit>
        <trans-unit id="3769038328418f1b146bfedf460a0d4ea1eab91b" translate="yes" xml:space="preserve">
          <source>It also allows a &quot;ref&quot; file to be a symbolic pointer to another ref file by starting with the four-byte header sequence of &quot;ref:&quot;.</source>
          <target state="translated">また、&quot;ref &quot;ファイルを、&quot;ref:&quot;の4バイトのヘッダシーケンスで始まる別のrefファイルへのシンボリックポインタにすることもできる。</target>
        </trans-unit>
        <trans-unit id="c1a8e562ae70e23b9286b736cb60f8fd411f796d" translate="yes" xml:space="preserve">
          <source>It can also be useful in scripts passed to &quot;git bisect run&quot; to &quot;exit 255&quot; if some very abnormal situation is detected.</source>
          <target state="translated">また、&quot;git bisect run&quot; に渡されたスクリプトの中で、何か非常に異常な状況が検出された場合に &quot;exit 255&quot; を実行するのにも役立ちます。</target>
        </trans-unit>
        <trans-unit id="79b5b9aab5919bae0a6145dab082f1d19cd80f67" translate="yes" xml:space="preserve">
          <source>It can be cumbersome to input the same credentials over and over. Git provides two methods to reduce this annoyance:</source>
          <target state="translated">同じ認証情報を何度も入力するのは面倒です。Git には、この煩わしさを軽減するための二つの方法が用意されています。</target>
        </trans-unit>
        <trans-unit id="4e1aaed29365e5e25e94340f3a0f563a3458fb95" translate="yes" xml:space="preserve">
          <source>It can be used to inspect the current working tree and refuse to make a commit if it does not pass certain test.</source>
          <target state="translated">これは、現在の作業ツリーを検査し、特定のテストに合格しない場合にコミットを拒否するために使用することができます。</target>
        </trans-unit>
        <trans-unit id="15367977bf1bc97e62677f2311accebdf50497b6" translate="yes" xml:space="preserve">
          <source>It can efficiently represent information about merge conflicts between different tree objects, allowing each pathname to be associated with sufficient information about the trees involved that you can create a three-way merge between them.</source>
          <target state="translated">これは、異なるツリーオブジェクト間のマージの競合に関する情報を効率的に表現することができ、各パス名を、関係するツリーに関する十分な情報と関連付けることができ、それらの間で三者間のマージを作成することができるようになります。</target>
        </trans-unit>
        <trans-unit id="61f59429096395b0e09a9585119ef97dbe0f3099" translate="yes" xml:space="preserve">
          <source>It cannot show more than 29 branches and commits at a time.</source>
          <target state="translated">一度に29以上のブランチとコミットを表示することはできません。</target>
        </trans-unit>
        <trans-unit id="84908290c2ad8351819557b635db90afccbc35f1" translate="yes" xml:space="preserve">
          <source>It clones the submodule from &lt;code&gt;&amp;lt;repo&amp;gt;&lt;/code&gt; to the given &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; under the current directory and by default checks out the master branch.</source>
          <target state="translated">サブモジュールを &lt;code&gt;&amp;lt;repo&amp;gt;&lt;/code&gt; から現在のディレクトリの下の指定された &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; に複製し、デフォルトでマスターブランチをチェックアウトします。</target>
        </trans-unit>
        <trans-unit id="d2f2a22f8382dea93b62981d5e21e0c74a8c6b46" translate="yes" xml:space="preserve">
          <source>It could also be used to log the old..new status. However, it does not know the entire set of branches, so it would end up firing one e-mail per ref when used naively, though. The &lt;a href=&quot;#post-receive&quot;&gt;&lt;em&gt;post-receive&lt;/em&gt;&lt;/a&gt; hook is more suited to that.</source>
          <target state="translated">old..newステータスのログにも使用できます。ただし、ブランチのセット全体を認識していないため、単純に使用すると、参照ごとに1つの電子メールが送信されます。&lt;a href=&quot;#post-receive&quot;&gt;&lt;em&gt;ポスト受ける&lt;/em&gt;&lt;/a&gt;フックがそれに適しています。</target>
        </trans-unit>
        <trans-unit id="784deb932c786d53caa1d9cefe7cd05964d957b0" translate="yes" xml:space="preserve">
          <source>It defaults to &lt;code&gt;blue,12 month ago,white,1 month ago,red&lt;/code&gt;, which colors everything older than one year blue, recent changes between one month and one year old are kept white, and lines introduced within the last month are colored red.</source>
          <target state="translated">デフォルトは &lt;code&gt;blue,12 month ago,white,1 month ago,red&lt;/code&gt; 、1年以上古いものはすべて青で表示されます。1か月から1年前の最近の変更は白のままで、先月に導入された線は赤で表示されます。</target>
        </trans-unit>
        <trans-unit id="91de163844ee67c93c1b1c843cc5bef0832c9f25" translate="yes" xml:space="preserve">
          <source>It does its best to do the safe thing, it will check that the files are unchanged and up to date in the CVS checkout, and it will not autocommit by default.</source>
          <target state="translated">それは安全なことをするために最善を尽くします、それはCVSチェックアウトでファイルが変更されていないことと最新の状態であることをチェックします、そしてそれはデフォルトでは自動コミットされません。</target>
        </trans-unit>
        <trans-unit id="92564150ed02a0207f639f4b1e8f897270e7157d" translate="yes" xml:space="preserve">
          <source>It does this by storing some additional data for each entry (such as the last modified time). This data is not displayed above, and is not stored in the created tree object, but it can be used to determine quickly which files in the working directory differ from what was stored in the index, and thus save Git from having to read all of the data from such files to look for changes.</source>
          <target state="translated">これは、各エントリごとに追加のデータ (最終更新時刻など)を保存することで行います。このデータは上には表示されず、作成されたツリーオブジェクトにも保存されませんが、作業ディレクトリ内のどのファイルがインデックスに保存されていたものと異なるのかを素早く判断するために使うことができます。</target>
        </trans-unit>
        <trans-unit id="af8ba1869bb0a79ae9cea38b1af5617b9069dca1" translate="yes" xml:space="preserve">
          <source>It enables git to work together with a file system monitor (see the &quot;fsmonitor-watchman&quot; section of &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;) that can inform it as to what files have been modified. This enables git to avoid having to lstat() every file to find modified files.</source>
          <target state="translated">これにより、gitはファイルシステムモニター（&lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt;の「fsmonitor-watchman」セクションを参照）と連携して、変更されたファイルを通知できるようになります。これにより、変更されたファイルを見つけるためにgitがすべてのファイルをlstat（）する必要がなくなります。</target>
        </trans-unit>
        <trans-unit id="af9f31199487ba705eebc5dd4bc13449d71955c8" translate="yes" xml:space="preserve">
          <source>It expects to be dealing with one project only. If it sees branches that have different roots, it will refuse to run. In that case, edit your &amp;lt;archive/branch&amp;gt; parameters to define clearly the scope of the import.</source>
          <target state="translated">1つのプロジェクトのみを扱うことを想定しています。異なるルートを持つブランチが見つかると、実行を拒否します。その場合は、&amp;lt;archive / branch&amp;gt;パラメータを編集して、インポートのスコープを明確に定義します。</target>
        </trans-unit>
        <trans-unit id="d015f51d5305572fa694969daaad327b702a39d6" translate="yes" xml:space="preserve">
          <source>It helps to divide these functions into groups for discussion purposes.</source>
          <target state="translated">これらの機能をグループに分けて議論の目的に役立てることができます。</target>
        </trans-unit>
        <trans-unit id="cf8815ec8cef4d3d8f9a8adf49f25148a4887929" translate="yes" xml:space="preserve">
          <source>It is &lt;code&gt;&amp;lt;unix timestamp&amp;gt; &amp;lt;time zone offset&amp;gt;&lt;/code&gt;, where &lt;code&gt;&amp;lt;unix
timestamp&amp;gt;&lt;/code&gt; is the number of seconds since the UNIX epoch. &lt;code&gt;&amp;lt;time zone offset&amp;gt;&lt;/code&gt; is a positive or negative offset from UTC. For example CET (which is 1 hour ahead of UTC) is &lt;code&gt;+0100&lt;/code&gt;.</source>
          <target state="translated">これは、 &lt;code&gt;&amp;lt;unix timestamp&amp;gt; &amp;lt;time zone offset&amp;gt;&lt;/code&gt; 。ここで、 &lt;code&gt;&amp;lt;unix timestamp&amp;gt;&lt;/code&gt; は、UNIXエポックからの秒数です。 &lt;code&gt;&amp;lt;time zone offset&amp;gt;&lt;/code&gt; は、UTCからの正または負のオフセットです。たとえば、CET（UTCより1時間進んでいる）は &lt;code&gt;+0100&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="3f4ae55d14bc9f41dc555ac55a4684de8bea2c17" translate="yes" xml:space="preserve">
          <source>It is OK to include files which have not actually changed. All changes including newly-created and deleted files should be included. When files are renamed, both the old and the new name should be included.</source>
          <target state="translated">実際には変更されていないファイルを含めても構いません。新しく作成されたファイルや削除されたファイルを含むすべての変更を含める必要があります。ファイルの名前が変更された場合は、古い名前と新しい名前の両方を含める必要があります。</target>
        </trans-unit>
        <trans-unit id="854a36265382bec82daa5a74f777ff212834a549" translate="yes" xml:space="preserve">
          <source>It is a good idea to introduce yourself to Git with your name and public email address before doing any operation. The easiest way to do so is:</source>
          <target state="translated">何か操作をする前に、自分の名前と公開メールアドレスでGitに自己紹介をしておくと良いでしょう。一番簡単な方法は</target>
        </trans-unit>
        <trans-unit id="0dc733d75bf5327e08cfc3134be1a3042cbb2515" translate="yes" xml:space="preserve">
          <source>It is a rough equivalent for:</source>
          <target state="translated">に大まかに相当します。</target>
        </trans-unit>
        <trans-unit id="95c229774b9b51315840e554d56265719cd8be5c" translate="yes" xml:space="preserve">
          <source>It is also a good idea when using any VCS to have only one small logical change in each commit.</source>
          <target state="translated">また、どのVCSを使用する場合でも、コミットごとに小さな論理的な変更が1つだけあるのは良いアイデアです。</target>
        </trans-unit>
        <trans-unit id="6c5a3acbba80472c3128c6339cb1639b4bd8a27a" translate="yes" xml:space="preserve">
          <source>It is also permitted for a notes ref to point directly to a tree object, in which case the history of the notes can be read with &lt;code&gt;git log -p -g &amp;lt;refname&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">notes refがツリーオブジェクトを直接指すことも許可されています。この場合、メモの履歴は &lt;code&gt;git log -p -g &amp;lt;refname&amp;gt;&lt;/code&gt; で読み取ることができます。</target>
        </trans-unit>
        <trans-unit id="b16dc4f2558875d3f67cc118d8aee343695acae5" translate="yes" xml:space="preserve">
          <source>It is also possible to fetch a subset of branches or tags by using a comma-separated list of names within braces. For example:</source>
          <target state="translated">中括弧内の名前をカンマで区切ったリストを使用して、ブランチやタグのサブセットを取得することも可能です。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="12b7523072e662c296ea1a80ba59ec7ed5fcb7e4" translate="yes" xml:space="preserve">
          <source>It is also possible to introduce completely new merge commits from scratch by adding a command of the form &lt;code&gt;merge &amp;lt;merge-head&amp;gt;&lt;/code&gt;. This form will generate a tentative commit message and always open an editor to let the user edit it. This can be useful e.g. when a topic branch turns out to address more than a single concern and wants to be split into two or even more topic branches. Consider this todo list:</source>
          <target state="translated">&lt;code&gt;merge &amp;lt;merge-head&amp;gt;&lt;/code&gt; の形式のコマンドを追加することにより、完全に新しいマージコミットを最初から導入することもできます。このフォームは一時的なコミットメッセージを生成し、常にエディターを開いてユーザーが編集できるようにします。これは、たとえば、トピックブランチが複数の問題に対処し、2つ以上のトピックブランチに分割したい場合に役立ちます。次のToDoリストを検討してください。</target>
        </trans-unit>
        <trans-unit id="e8d4e8a65d3b558ba4900bdd06798676f68d11ad" translate="yes" xml:space="preserve">
          <source>It is also possible to provide true CVS access to a Git repository, so that developers can still use CVS; see &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver[1]&lt;/a&gt; for details.</source>
          <target state="translated">開発者がCVSを引き続き使用できるように、Gitリポジトリへの真のCVSアクセスを提供することもできます。詳細は&lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver [1]&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="3fcb2e34d6c27144258c45911fcc9298afaeeefa" translate="yes" xml:space="preserve">
          <source>It is also possible to replace commits further back in the history, but this is an advanced topic to be left for &lt;a href=&quot;#cleaning-up-history&quot;&gt;another chapter&lt;/a&gt;.</source>
          <target state="translated">履歴をさらに遡ってコミットを置き換えることも可能ですが、これは&lt;a href=&quot;#cleaning-up-history&quot;&gt;別の章に&lt;/a&gt;残しておくべき高度なトピックです。</target>
        </trans-unit>
        <trans-unit id="14665d6ab0c5fa19cd26aec534fecd5dda3c4692" translate="yes" xml:space="preserve">
          <source>It is also run after &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt;, unless the &lt;code&gt;--no-checkout&lt;/code&gt; (&lt;code&gt;-n&lt;/code&gt;) option is used. The first parameter given to the hook is the null-ref, the second the ref of the new HEAD and the flag is always 1. Likewise for &lt;code&gt;git worktree add&lt;/code&gt; unless &lt;code&gt;--no-checkout&lt;/code&gt; is used.</source>
          <target state="translated">&lt;code&gt;--no-checkout&lt;/code&gt; （ &lt;code&gt;-n&lt;/code&gt; ）オプションが使用されていない限り、&lt;a href=&quot;git-clone&quot;&gt;git-clone [1]の&lt;/a&gt;後にも実行されます。フックに指定された最初のパラメーターはnull-refで、2番目は新しいHEADの参照であり、フラグは常に1です。同様に &lt;code&gt;--no-checkout&lt;/code&gt; が使用されない限り、 &lt;code&gt;git worktree add&lt;/code&gt; の場合も同様です。</target>
        </trans-unit>
        <trans-unit id="2bf0b4701dd5a8615d5c5a4270f19ec18f43aa49" translate="yes" xml:space="preserve">
          <source>It is an error if &amp;lt;dst&amp;gt; matches more than one remote refs.</source>
          <target state="translated">&amp;lt;dst&amp;gt;が複数のリモート参照に一致する場合、エラーになります。</target>
        </trans-unit>
        <trans-unit id="47ed8fd8a6ccf512f8dd41b7de1bb50b3d494692" translate="yes" xml:space="preserve">
          <source>It is an error if &amp;lt;src&amp;gt; does not match exactly one of the local refs.</source>
          <target state="translated">&amp;lt;src&amp;gt;がローカル参照の1つと正確に一致しない場合、エラーになります。</target>
        </trans-unit>
        <trans-unit id="08551e573ca80a9130c1ec33d2456a204ee6a838" translate="yes" xml:space="preserve">
          <source>It is an error to specify a ref that does not pass &quot;git check-ref-format&quot; scrutiny. Duplicated values are filtered.</source>
          <target state="translated">git check-ref-format&quot; の scrutiny を通らない ref を指定するとエラーになります。重複した値はフィルタリングされます。</target>
        </trans-unit>
        <trans-unit id="91dc5c05cc945b2e35d03a4d25f4568585356b02" translate="yes" xml:space="preserve">
          <source>It is assumed that any handshaking procedures have already been completed (such as sending service request for git://) before this helper is started.</source>
          <target state="translated">このヘルパーが起動される前に、ハンドシェイクの手続き (git://へのサービスリクエストの送信など)がすでに完了していることが想定されます。</target>
        </trans-unit>
        <trans-unit id="7a3002fc7973dbc26474a90f4bdcb162301b4e67" translate="yes" xml:space="preserve">
          <source>It is currently only possible to recreate the merge commits using the &lt;code&gt;recursive&lt;/code&gt; merge strategy; Different merge strategies can be used only via explicit &lt;code&gt;exec git merge -s &amp;lt;strategy&amp;gt; [...]&lt;/code&gt; commands.</source>
          <target state="translated">現在、 &lt;code&gt;recursive&lt;/code&gt; マージ戦略を使用してマージコミットを再作成することのみが可能です。異なるマージ戦略は、明示的な &lt;code&gt;exec git merge -s &amp;lt;strategy&amp;gt; [...]&lt;/code&gt; コマンドを介してのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="bd70cf0a22a7ad38ee60197dd400f891cf0d57a3" translate="yes" xml:space="preserve">
          <source>It is expected that the content of the commit object you created while following the example above generates a different SHA-1 hash than the one shown above because the commit object records the time when it was created and the name of the person performing the commit.</source>
          <target state="translated">上記の例に従って作成したコミットオブジェクトの内容は、コミットオブジェクトが作成された時刻とコミットを実行した人の名前が記録されているため、上記の内容とは異なるSHA-1ハッシュが生成されることが予想されます。</target>
        </trans-unit>
        <trans-unit id="f78a88555b80a7cb6f279e6cf8551b4ade125a2a" translate="yes" xml:space="preserve">
          <source>It is followed by one or more extended header lines (this example shows a merge with two parents):</source>
          <target state="translated">これの後には、1 つ以上の拡張ヘッダ行が続きます (この例では、2 つの親を持つマージを示しています)。</target>
        </trans-unit>
        <trans-unit id="4d181ca929d0bcae1d19e843f3c648e99a609d36" translate="yes" xml:space="preserve">
          <source>It is followed by one or more extended header lines:</source>
          <target state="translated">これには、1つ以上の拡張ヘッダ行が続きます。</target>
        </trans-unit>
        <trans-unit id="a6770fb3a63d614ebdc42bea002a81ec83ae2568" translate="yes" xml:space="preserve">
          <source>It is followed by two-line from-file/to-file header</source>
          <target state="translated">2 行の from-file/to-file ヘッダが続きます。</target>
        </trans-unit>
        <trans-unit id="31bbdf9a81fa3062a8106d3f0d5511057b4a5222" translate="yes" xml:space="preserve">
          <source>It is highly functional. However, not all methods are implemented, and for those methods that are implemented, not all switches are implemented.</source>
          <target state="translated">高機能である。ただし、すべてのメソッドが実装されているわけではなく、実装されているメソッドについては、すべてのスイッチが実装されているわけではありません。</target>
        </trans-unit>
        <trans-unit id="13209c7d424e2b65e2d35ccb5123d7d58e26c1e7" translate="yes" xml:space="preserve">
          <source>It is important to realize that at this point nothing refers to commit &lt;code&gt;f&lt;/code&gt;. Eventually commit &lt;code&gt;f&lt;/code&gt; (and by extension commit &lt;code&gt;e&lt;/code&gt;) will be deleted by the routine Git garbage collection process, unless we create a reference before that happens. If we have not yet moved away from commit &lt;code&gt;f&lt;/code&gt;, any of these will create a reference to it:</source>
          <target state="translated">この時点では、コミット &lt;code&gt;f&lt;/code&gt; は参照されていないことに注意してください。最終的にcommit &lt;code&gt;f&lt;/code&gt; （および拡張commit &lt;code&gt;e&lt;/code&gt; ）は、発生する前に参照を作成しない限り、ルーチンのGitガベージコレクションプロセスによって削除されます。まだコミット &lt;code&gt;f&lt;/code&gt; から離れていない場合、これらのいずれかがそれへの参照を作成します。</target>
        </trans-unit>
        <trans-unit id="15e77b99d56294dd4d998fab1260c89fc2b1f677" translate="yes" xml:space="preserve">
          <source>It is likely that you will be pulling from the same remote repository from time to time. As a short hand, you can store the remote repository URL in the local repository&amp;rsquo;s config file like this:</source>
          <target state="translated">場合によっては、同じリモートリポジトリからプルすることがあります。簡単に言うと、次のように、リモートリポジトリのURLをローカルリポジトリの構成ファイルに保存できます。</target>
        </trans-unit>
        <trans-unit id="e468ce82ca7a37df3e0ccb7eddd0ee514020b622" translate="yes" xml:space="preserve">
          <source>It is likely that you will be working on more than one thing at a time. It is easy to manage those more-or-less independent tasks using branches with Git.</source>
          <target state="translated">一度に複数の作業を行うこともあるでしょう。Git を使ってブランチを使えば、それらのタスクを管理するのは簡単です。</target>
        </trans-unit>
        <trans-unit id="cdfac588afc71ee687618e7ec3bc2f824e200606" translate="yes" xml:space="preserve">
          <source>It is not always easy for new developers to find their way through Git&amp;rsquo;s source code. This section gives you a little guidance to show where to start.</source>
          <target state="translated">新しい開発者がGitのソースコードを自分の道で見つけるのは必ずしも簡単ではありません。このセクションでは、どこから始めればよいかを示すための簡単なガイダンスを示します。</target>
        </trans-unit>
        <trans-unit id="deded1cb8baf6033568ee8de4cb9cb55818cb450" translate="yes" xml:space="preserve">
          <source>It is not recommended to use this feature if you intend to export changes back to CVS again later with &lt;code&gt;git cvsexportcommit&lt;/code&gt;.</source>
          <target state="translated">後で &lt;code&gt;git cvsexportcommit&lt;/code&gt; を使用して変更をCVSにエクスポートする場合は、この機能を使用することはお勧めしません。</target>
        </trans-unit>
        <trans-unit id="598d612724092a05c80fc92ca656e4e685e7e227" translate="yes" xml:space="preserve">
          <source>It is obviously a good idea not to have commits with changes that knowingly break things, even if some other commits later fix the breakage.</source>
          <target state="translated">明らかに、故意に物事を壊すような変更を加えたコミットはしない方が良いでしょう。</target>
        </trans-unit>
        <trans-unit id="8402ec5252190f6132c0772d2b1eafbec27785df" translate="yes" xml:space="preserve">
          <source>It is possible that a merge failure will prevent this process from being completely automatic. You will have to resolve any such merge failure and run &lt;code&gt;git rebase --continue&lt;/code&gt;. Another option is to bypass the commit that caused the merge failure with &lt;code&gt;git rebase --skip&lt;/code&gt;. To check out the original &amp;lt;branch&amp;gt; and remove the .git/rebase-apply working files, use the command &lt;code&gt;git rebase --abort&lt;/code&gt; instead.</source>
          <target state="translated">マージが失敗すると、このプロセスが完全に自動化されなくなる可能性があります。そのようなマージの失敗を解決し、 &lt;code&gt;git rebase --continue&lt;/code&gt; を実行する必要があります。別のオプションは、 &lt;code&gt;git rebase --skip&lt;/code&gt; でマージの失敗を引き起こしたコミットをバイパスすることです。元の&amp;lt;branch&amp;gt;をチェックアウトして.git / rebase-apply作業ファイルを削除するには、代わりにコマンド &lt;code&gt;git rebase --abort&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="2ea7f2913c3e95cfd4ae5ff1f6d8aecb190ef204" translate="yes" xml:space="preserve">
          <source>It is possible to construct these old form repositories manually.</source>
          <target state="translated">これらの古い形式のリポジトリを手動で構築することができます。</target>
        </trans-unit>
        <trans-unit id="548453998a9c855739e7eb9ec21e0581e0ed374b" translate="yes" xml:space="preserve">
          <source>It is possible to disable use of replacement references for any command using the &lt;code&gt;--no-replace-objects&lt;/code&gt; option just after &lt;code&gt;git&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git&lt;/code&gt; の直後に &lt;code&gt;--no-replace-objects&lt;/code&gt; オプションを使用すると、コマンドの置換参照の使用を無効にすることができます。</target>
        </trans-unit>
        <trans-unit id="c06956dd566d0990dc7bdbc85eb39fd34edd8452" translate="yes" xml:space="preserve">
          <source>It is preceded with a &quot;git diff&quot; header that looks like this:</source>
          <target state="translated">このような &quot;git diff &quot;ヘッダが先行しています。</target>
        </trans-unit>
        <trans-unit id="fae83443f259566d0e3ea169c2bee02ad7796585" translate="yes" xml:space="preserve">
          <source>It is preceded with a &quot;git diff&quot; header, that looks like this (when the &lt;code&gt;-c&lt;/code&gt; option is used):</source>
          <target state="translated">次のような「git diff」ヘッダーが前に付きます（ &lt;code&gt;-c&lt;/code&gt; オプションが使用されている場合）。</target>
        </trans-unit>
        <trans-unit id="41c2e2ee7c9260a90ac9d47c12dc86595dc670c7" translate="yes" xml:space="preserve">
          <source>It is purely performance optimization, originally intended for MacOS X, where recursive directory traversal is slow. Gitweb follows symbolic links, but it detects cycles, ignoring any duplicate files and directories.</source>
          <target state="translated">これは純粋にパフォーマンスを最適化するためのもので、元々はMacOS X用に作られたもので、再帰的なディレクトリ移動が遅いのが特徴です。Gitweb はシンボリックリンクに従いますが、サイクルを検出して重複したファイルやディレクトリを無視します。</target>
        </trans-unit>
        <trans-unit id="bcd29e9bb49344b0e527480d5a1209557826cefc" translate="yes" xml:space="preserve">
          <source>It is recommended that &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; always be encoded using UTF-8.</source>
          <target state="translated">&lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; は常にUTF-8を使用してエンコードすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="987c2f12e083069e2c3c6529da1c2b8427b5d901" translate="yes" xml:space="preserve">
          <source>It is safer if both &lt;code&gt;test.sh&lt;/code&gt; and &lt;code&gt;check_test_case.sh&lt;/code&gt; are outside the repository to prevent interactions between the bisect, make and test processes and the scripts.</source>
          <target state="translated">bisect、make、testプロセスとスクリプト間の相互作用を防ぐために、 &lt;code&gt;test.sh&lt;/code&gt; と &lt;code&gt;check_test_case.sh&lt;/code&gt; の両方がリポジトリの外にある場合は、より安全です。</target>
        </trans-unit>
        <trans-unit id="07dbd897b2b790cda3e0cd6c93a27be05c0967a5" translate="yes" xml:space="preserve">
          <source>It is sometimes useful to be able to checkout a commit that is not at the tip of any named branch, or even to create a new commit that is not referenced by a named branch. Let&amp;rsquo;s look at what happens when we checkout commit &lt;code&gt;b&lt;/code&gt; (here we show two ways this may be done):</source>
          <target state="translated">名前付きブランチの先端にないコミットをチェックアウトしたり、名前付きブランチによって参照されていない新しいコミットを作成したりできると便利な場合があります。commit &lt;code&gt;b&lt;/code&gt; をチェックアウトするとどうなるかを見てみましょう（ここでは、これを行う2つの方法を示します）。</target>
        </trans-unit>
        <trans-unit id="19dd47dcbbf16a9cccaac6e901efe1eb6d41c6b4" translate="yes" xml:space="preserve">
          <source>It is still your responsibility to make sure that the email message sent by your email program meets the standards of your project. Many projects do not like patches to be attached. Some mail agents will transform patches (e.g. wrap lines, send them as format=flowed) in ways that make them fail. You will get angry flames ridiculing you if you don&amp;rsquo;t check this.</source>
          <target state="translated">電子メールプログラムによって送信された電子メールメッセージがプロジェクトの基準を満たしていることを確認するのは、依然としてあなたの責任です。多くのプロジェクトは、パッチを添付することを好みません。一部のメールエージェントは、パッチを変換して（行の折り返し、format = flowedとして送信）、失敗するようにします。これをチェックしないと、怒りの炎があなたをからかいます。</target>
        </trans-unit>
        <trans-unit id="446989de9f552ff7a375d76851b391396cb21747" translate="yes" xml:space="preserve">
          <source>It is unlikely that you would have any conflicts here &amp;hellip;​ but you might if you spent a while on this step and had also pulled new versions from upstream.</source>
          <target state="translated">ここで競合が発生する可能性はほとんどありません&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="5d35217f8f6c81e1e684634a0bdd90859d19f06a" translate="yes" xml:space="preserve">
          <source>It is up to the user to ensure that no In-Reply-To header already exists when &lt;code&gt;git send-email&lt;/code&gt; is asked to add it (especially note that &lt;code&gt;git format-patch&lt;/code&gt; can be configured to do the threading itself). Failure to do so may not produce the expected result in the recipient&amp;rsquo;s MUA.</source>
          <target state="translated">追加するように &lt;code&gt;git send-email&lt;/code&gt; が要求されたときにIn-Reply-Toヘッダーが存在しないことを確認するのはユーザーの &lt;code&gt;git format-patch&lt;/code&gt; （特に、スレッド自体を実行するようにgit format-patchを構成できることに注意してください）。そうしないと、受信者のMUAで期待される結果が得られない場合があります。</target>
        </trans-unit>
        <trans-unit id="28ab82f4261b972bffcbd084fca6120764f529fe" translate="yes" xml:space="preserve">
          <source>It is useful when you&amp;rsquo;re looking for an exact block of code (like a struct), and want to know the history of that block since it first came into being: use the feature iteratively to feed the interesting block in the preimage back into &lt;code&gt;-S&lt;/code&gt;, and keep going until you get the very first version of the block.</source>
          <target state="translated">（構造体などの）コードの正確なブロックを探していて、そのブロックが最初に登場してからの履歴を知りたい場合に便利です。この機能を繰り返し使用して、プレイメージ内の興味深いブロックをフィードバックします。 &lt;code&gt;-S&lt;/code&gt; 、そしてブロックの最初のバージョンが得られるまで続けます。</target>
        </trans-unit>
        <trans-unit id="212ba732375c1f9e18ce6b37fe943bc0a79e8a67" translate="yes" xml:space="preserve">
          <source>It is very important that the basis used be held by the destination. It is okay to err on the side of caution, causing the bundle file to contain objects already in the destination, as these are ignored when unpacking at the destination.</source>
          <target state="translated">使用する基底がデスティネーションで保持されていることが非常に重要です。バンドルファイルにはすでに宛先にあるオブジェクトが含まれていても構いません。</target>
        </trans-unit>
        <trans-unit id="f89d35d0ac276c4d31876791b9f069b985ca50ec" translate="yes" xml:space="preserve">
          <source>It may well be that among networking people, they may want to exchange the tags internal to their group, but in that workflow they are most likely tracking each other&amp;rsquo;s progress by having remote-tracking branches. Again, the heuristic to automatically follow such tags is a good thing.</source>
          <target state="translated">ネットワーキングの人々の間で、グループの内部でタグを交換したいと思うかもしれませんが、そのワークフローでは、リモートトラッキングブランチを使用することで、お互いの進捗を追跡している可能性が高いです。繰り返しになりますが、このようなタグを自動的に追跡するヒューリスティックは良いことです。</target>
        </trans-unit>
        <trans-unit id="b30dde80280e412c885fe09e1718d04b65bebbd4" translate="yes" xml:space="preserve">
          <source>It must be readable in order, from beginning to end, by someone intelligent with a basic grasp of the UNIX command line, but without any special knowledge of Git. If necessary, any other prerequisites should be specifically mentioned as they arise.</source>
          <target state="translated">UNIX のコマンドラインを基本的に把握している知的な人が、Git の特別な知識がなくても最初から最後まで順番に読めるようにしなければなりません。必要であれば、その他の前提条件については、その都度具体的に言及する必要があります。</target>
        </trans-unit>
        <trans-unit id="105999ab02cc181d3d21d02fda72679e92aee0b2" translate="yes" xml:space="preserve">
          <source>It should be stressed that this hierarchy is purely &lt;strong&gt;informal&lt;/strong&gt;. There is nothing fundamental in Git that enforces the &quot;chain of patch flow&quot; this hierarchy implies. You do not have to pull from only one remote repository.</source>
          <target state="translated">この階層は純粋に&lt;strong&gt;非公式である&lt;/strong&gt;ことを強調しておく必要があります。この階層が意味する「パッチフローのチェーン」を実施するGitには基本的なものは何もありません。リモートリポジトリを1つだけプルする必要はありません。</target>
        </trans-unit>
        <trans-unit id="7beffad8901e95a09a82e88d22525a3cad3065d8" translate="yes" xml:space="preserve">
          <source>It shows that foo.png has differences from HEAD (but that is binary so line count cannot be shown) and there is no difference between indexed copy and the working tree version (if the working tree version were also different, &lt;code&gt;binary&lt;/code&gt; would have been shown in place of &lt;code&gt;nothing&lt;/code&gt;). The other file, git-add--interactive.perl, has 403 lines added and 35 lines deleted if you commit what is in the index, but working tree file has further modifications (one addition and one deletion).</source>
          <target state="translated">foo.pngにはHEADとの違いがあり（ただし、バイナリであるため行数を表示できません）、インデックス付きコピーと作業ツリーのバージョンに違いはありません（作業ツリーのバージョンも異なる場合は、 &lt;code&gt;binary&lt;/code&gt; が表示されます）。 &lt;code&gt;nothing&lt;/code&gt; 代わりに）。もう1つのファイルgit-add--interactive.perlには、インデックスにあるものをコミットすると403行が追加され、35行が削除されますが、作業ツリーファイルにはさらに変更が加えられます（1回の追加と1回の削除）。</target>
        </trans-unit>
        <trans-unit id="593ae3fc1288babccd02a202f40d492d26634f5a" translate="yes" xml:space="preserve">
          <source>It shows that foo.png has differences from HEAD (but that is binary so line count cannot be shown) and there is no difference between indexed copy and the working tree version (if the working tree version were also different, &lt;code&gt;binary&lt;/code&gt; would have been shown in place of &lt;code&gt;nothing&lt;/code&gt;). The other file, git-add{litdd}interactive.perl, has 403 lines added and 35 lines deleted if you commit what is in the index, but working tree file has further modifications (one addition and one deletion).</source>
          <target state="translated">foo.pngはHEADとは異なり（ただし、バイナリであるため行数を表示できません）、インデックス付きコピーと作業ツリーのバージョンに違いはありません（作業ツリーのバージョンも異なる場合、 &lt;code&gt;binary&lt;/code&gt; が表示されます） &lt;code&gt;nothing&lt;/code&gt; 代わりに）。もう1つのファイルgit-add {litdd} interactive.perlには、インデックス内の内容をコミットすると403行が追加され、35行が削除されますが、作業ツリーファイルにはさらに変更（1つの追加と1つの削除）があります。</target>
        </trans-unit>
        <trans-unit id="1f22531fd9489cd1b4496c81c3454037c20af1a5" translate="yes" xml:space="preserve">
          <source>It takes a variable number of parameters, each of which is the name of ref that was actually updated.</source>
          <target state="translated">これは可変数のパラメータを取り、それぞれが実際に更新された ref の名前となります。</target>
        </trans-unit>
        <trans-unit id="8d1640303505dff202eb78d383641a82298beff2" translate="yes" xml:space="preserve">
          <source>It takes on the standard input the specification of the options to parse and understand, and echoes on the standard output a string suitable for &lt;code&gt;sh(1)&lt;/code&gt;&lt;code&gt;eval&lt;/code&gt; to replace the arguments with normalized ones. In case of error, it outputs usage on the standard error stream, and exits with code 129.</source>
          <target state="translated">解析および理解するオプションの指定を標準入力に取り、標準出力に &lt;code&gt;sh(1)&lt;/code&gt; &lt;code&gt;eval&lt;/code&gt; に適した文字列をエコーし​​て、引数を正規化されたものに置き換えます。エラーが発生した場合は、標準エラーストリームの使用状況を出力し、コード129で終了します。</target>
        </trans-unit>
        <trans-unit id="9fc9d0adb73a5f351f66393e06f90ebbcd611062" translate="yes" xml:space="preserve">
          <source>It takes one to three parameters. The first is the name of the file that contains the commit log message. The second is the source of the commit message, and can be: &lt;code&gt;message&lt;/code&gt; (if a &lt;code&gt;-m&lt;/code&gt; or &lt;code&gt;-F&lt;/code&gt; option was given); &lt;code&gt;template&lt;/code&gt; (if a &lt;code&gt;-t&lt;/code&gt; option was given or the configuration option &lt;code&gt;commit.template&lt;/code&gt; is set); &lt;code&gt;merge&lt;/code&gt; (if the commit is a merge or a &lt;code&gt;.git/MERGE_MSG&lt;/code&gt; file exists); &lt;code&gt;squash&lt;/code&gt; (if a &lt;code&gt;.git/SQUASH_MSG&lt;/code&gt; file exists); or &lt;code&gt;commit&lt;/code&gt;, followed by a commit SHA-1 (if a &lt;code&gt;-c&lt;/code&gt;, &lt;code&gt;-C&lt;/code&gt; or &lt;code&gt;--amend&lt;/code&gt; option was given).</source>
          <target state="translated">1〜3つのパラメーターを使用します。1つ目は、コミットログメッセージを含むファイルの名前です。第二は、コミットメッセージのソースであり、であることができる： &lt;code&gt;message&lt;/code&gt; （場合 &lt;code&gt;-m&lt;/code&gt; または &lt;code&gt;-F&lt;/code&gt; オプションが与えられました）。 &lt;code&gt;template&lt;/code&gt; （ &lt;code&gt;-t&lt;/code&gt; オプションが指定された場合、または構成オプション &lt;code&gt;commit.template&lt;/code&gt; が設定されている場合）; &lt;code&gt;merge&lt;/code&gt; （コミットがマージであるか、 &lt;code&gt;.git/MERGE_MSG&lt;/code&gt; ファイルが存在する場合）; &lt;code&gt;squash&lt;/code&gt; （ &lt;code&gt;.git/SQUASH_MSG&lt;/code&gt; ファイルが存在する場合）; または &lt;code&gt;commit&lt;/code&gt; 、続いてcommit SHA-1（ &lt;code&gt;-c&lt;/code&gt; 、 &lt;code&gt;-C&lt;/code&gt; または &lt;code&gt;--amend&lt;/code&gt; の場合) オプションが与えられた）。</target>
        </trans-unit>
        <trans-unit id="ee62cbb1781a10ccff3a10f01577042e41951364" translate="yes" xml:space="preserve">
          <source>It tells you that it did an &quot;Automatic merge&quot;, which failed due to conflicts in &lt;code&gt;hello&lt;/code&gt;.</source>
          <target state="translated">「自動マージ」を実行したことを &lt;code&gt;hello&lt;/code&gt; ますが、helloの競合が原因で失敗しました。</target>
        </trans-unit>
        <trans-unit id="31dbee78e4c488ce29554dd490d874937eb736b5" translate="yes" xml:space="preserve">
          <source>It used to be that the command defaulted to do &lt;code&gt;-x&lt;/code&gt; described above, and &lt;code&gt;-r&lt;/code&gt; was to disable it. Now the default is not to do &lt;code&gt;-x&lt;/code&gt; so this option is a no-op.</source>
          <target state="translated">以前は、コマンドがデフォルトで上記の &lt;code&gt;-x&lt;/code&gt; を実行し、 &lt;code&gt;-r&lt;/code&gt; がそれを無効にすることでした。現在、デフォルトでは &lt;code&gt;-x&lt;/code&gt; を実行しないため、このオプションは何もしません。</target>
        </trans-unit>
        <trans-unit id="d5579126502958d7cf2a79d1e6eb0f1ab9f1fb74" translate="yes" xml:space="preserve">
          <source>It uses &lt;code&gt;showbranch.default&lt;/code&gt; multi-valued configuration items if no &amp;lt;rev&amp;gt; or &amp;lt;glob&amp;gt; is given on the command line.</source>
          <target state="translated">コマンドラインで&amp;lt;rev&amp;gt;または&amp;lt;glob&amp;gt;が指定されていない場合は、 &lt;code&gt;showbranch.default&lt;/code&gt; 多値構成項目を使用します。</target>
        </trans-unit>
        <trans-unit id="c599d3ca0dc61039dd83109e0beef002f0abd196" translate="yes" xml:space="preserve">
          <source>It verifies that the directory has the magic file &quot;git-daemon-export-ok&quot;, and it will refuse to export any Git directory that hasn&amp;rsquo;t explicitly been marked for export this way (unless the &lt;code&gt;--export-all&lt;/code&gt; parameter is specified). If you pass some directory paths as &lt;code&gt;git daemon&lt;/code&gt; arguments, you can further restrict the offers to a whitelist comprising of those.</source>
          <target state="translated">ディレクトリにマジックファイル &quot;git-daemon-export-ok&quot;があることを確認し、この方法でエクスポート用に明示的にマークされていないGitディレクトリのエクスポートを拒否します（ &lt;code&gt;--export-all&lt;/code&gt; パラメーターが指定されている場合を除く））。 &lt;code&gt;git daemon&lt;/code&gt; 引数としていくつかのディレクトリパスを渡す場合、オファーをそれらで構成されるホワイトリストにさらに制限できます。</target>
        </trans-unit>
        <trans-unit id="3fd1b09d35c94e426d7de9278697f8281d2f9b0b" translate="yes" xml:space="preserve">
          <source>It verifies that the directory has the magic file &quot;git-daemon-export-ok&quot;, and it will refuse to export any Git directory that hasn&amp;rsquo;t explicitly been marked for export this way (unless the &lt;code&gt;GIT_HTTP_EXPORT_ALL&lt;/code&gt; environmental variable is set).</source>
          <target state="translated">ディレクトリにマジックファイル「git-daemon-export-ok」があることを確認し、この方法でエクスポートするように明示的にマークされていないGitディレクトリのエクスポートを拒否します（ &lt;code&gt;GIT_HTTP_EXPORT_ALL&lt;/code&gt; 環境変数が設定されていない場合）。</target>
        </trans-unit>
        <trans-unit id="6a949f37aaca4177eee5df32a3761a98f4054a56" translate="yes" xml:space="preserve">
          <source>It was a tool of absolute last resort. I&amp;rsquo;d rather spend days looking at printk output than do a manual &lt;code&gt;patch bisection&lt;/code&gt;.</source>
          <target state="translated">それは絶対的な最後の手段でした。手動で &lt;code&gt;patch bisection&lt;/code&gt; 行うよりも、printkの出力を確認することに何日も費やしたいと思います。</target>
        </trans-unit>
        <trans-unit id="839ea1dcb179bd0fd1a734d84c9b044b60c7a423" translate="yes" xml:space="preserve">
          <source>It will be useful to have a Git repository to experiment with as you read this manual.</source>
          <target state="translated">このマニュアルを読みながら、実験用のGitリポジトリを用意しておくと便利でしょう。</target>
        </trans-unit>
        <trans-unit id="a1e588b366d6eee7b2a111ab040de25b982fdb3f" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s also possible for a push to fail in this way when other people have the right to push to the same repository. In that case, the correct solution is to retry the push after first updating your work: either by a pull, or by a fetch followed by a rebase; see the &lt;a href=&quot;#setting-up-a-shared-repository&quot;&gt;next section&lt;/a&gt; and &lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration[7]&lt;/a&gt; for more.</source>
          <target state="translated">他の人が同じリポジトリにプッシュする権利を持っている場合、プッシュがこのように失敗する可能性もあります。その場合、正しい解決策は、最初に作業を更新した後でプッシュを再試行することです。詳細については、&lt;a href=&quot;#setting-up-a-shared-repository&quot;&gt;次のセクション&lt;/a&gt;と&lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration [7]&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="c8e637a625c72275676a912327970832afbb1fc7" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s especially instructive to look at &quot;commit&quot; objects, since those tend to be small and fairly self-explanatory. In particular, if you follow the convention of having the top commit name in &lt;code&gt;.git/HEAD&lt;/code&gt;, you can do</source>
          <target state="translated">「コミット」オブジェクトは小さく、かなり自明である傾向があるため、これを確認することは特に有益です。特に、 &lt;code&gt;.git/HEAD&lt;/code&gt; でトップコミット名を持つという慣習に従っている場合、次のことができます。</target>
        </trans-unit>
        <trans-unit id="ebca6c1346b961bb4e2f8a08e1112a09cf4c4143" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s far too easy to accidentally mix up old and new history. It&amp;rsquo;s still possible with any tool, but git-filter-branch almost invites it. If lucky, the only downside is users getting frustrated that they don&amp;rsquo;t know how to shrink their repo and remove the old stuff. If unlucky, they merge old and new history and end up with multiple &quot;copies&quot; of each commit, some of which have unwanted or sensitive files and others which don&amp;rsquo;t. This comes about in multiple different ways:</source>
          <target state="translated">古い履歴と新しい履歴を誤って混同することはあまりにも簡単です。それはどのツールでもまだ可能ですが、git-filter-branchはほとんどそれを招待します。運が良ければ、唯一の欠点は、ユーザーがリポジトリを縮小して古いものを削除する方法がわからないことに不満を感じることです。運が悪いと、古い履歴と新しい履歴がマージされ、各コミットの複数の「コピー」が作成されます。その中には、不要なファイルや機密ファイルが含まれているものと、そうでないものがあります。これには複数の異なる方法があります。</target>
        </trans-unit>
        <trans-unit id="7fb3124f269af4d6382e41b308c15a44d9e7c09f" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s not safe to run &lt;code&gt;git submodule update&lt;/code&gt; if you&amp;rsquo;ve made and committed changes within a submodule without checking out a branch first. They will be silently overwritten:</source>
          <target state="translated">最初にブランチをチェックアウトせずにサブモジュール内で変更を行ってコミットした場合、 &lt;code&gt;git submodule update&lt;/code&gt; を実行するのは安全ではありません。それらは黙って上書きされます：</target>
        </trans-unit>
        <trans-unit id="199b24a07e7c4f542f5c9b6cd233e68c58c149e6" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible to push any type of object to any namespace outside of &lt;code&gt;refs/{tags,heads}/*&lt;/code&gt;. In the case of tags and commits, these will be treated as if they were the commits inside &lt;code&gt;refs/heads/*&lt;/code&gt; for the purposes of whether the update is allowed.</source>
          <target state="translated">任意のタイプのオブジェクトを &lt;code&gt;refs/{tags,heads}/*&lt;/code&gt; 外の任意の名前空間にプッシュできます。タグとコミットの場合、更新が許可されるかどうかの目的で、これらは &lt;code&gt;refs/heads/*&lt;/code&gt; 内のコミットであるかのように扱われます。</target>
        </trans-unit>
        <trans-unit id="cd25bf8e6a6252931a48d686e2c25ca4a7c9f16e" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s probably not worth it to use this option on a given repository without running tailored performance benchmarks on it. It takes a lot more time, and the resulting space/delta optimization may or may not be worth it. Not using this at all is the right trade-off for most users and their repositories.</source>
          <target state="translated">カスタマイズされたパフォーマンスベンチマークを実行せずに、特定のリポジトリでこのオプションを使用することはおそらく価値がありません。これにはさらに多くの時間がかかり、結果として生じるスペース/デルタの最適化は価値がある場合とそうでない場合があります。これをまったく使用しないことは、ほとんどのユーザーとそのリポジトリにとって適切なトレードオフです。</target>
        </trans-unit>
        <trans-unit id="6c2d9fe7b4d73e7c5f324adf6070448f4f753fb5" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s reasonable to e.g. configure &lt;code&gt;fetch.pruneTags=true&lt;/code&gt; in &lt;code&gt;~/.gitconfig&lt;/code&gt; to have tags pruned whenever &lt;code&gt;git fetch --prune&lt;/code&gt; is run, without making every invocation of &lt;code&gt;git fetch&lt;/code&gt; without &lt;code&gt;--prune&lt;/code&gt; an error.</source>
          <target state="translated">これは、例えばのconfigureに合理的だ &lt;code&gt;fetch.pruneTags=true&lt;/code&gt; で &lt;code&gt;~/.gitconfig&lt;/code&gt; たび剪定タグを持っている &lt;code&gt;git fetch --prune&lt;/code&gt; のすべての呼び出しにすることなく、実行された &lt;code&gt;git fetch&lt;/code&gt; なし &lt;code&gt;--prune&lt;/code&gt; エラー。</target>
        </trans-unit>
        <trans-unit id="b2ec8a66f406e3cd9a737fd2597d771efa24775d" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s usually much more common that you merge with somebody else than merging with your own branches, so it&amp;rsquo;s worth pointing out that Git makes that very easy too, and in fact, it&amp;rsquo;s not that different from doing a &lt;code&gt;git merge&lt;/code&gt;. In fact, a remote merge ends up being nothing more than &quot;fetch the work from a remote repository into a temporary tag&quot; followed by a &lt;code&gt;git merge&lt;/code&gt;.</source>
          <target state="translated">通常、自分のブランチとマージするよりも他の人とマージする方がはるかに一般的です。そのため、Gitを使用することも非常に簡単であり、実際には &lt;code&gt;git merge&lt;/code&gt; を実行することとそれほど変わりません。実際、リモートマージは、「リモートリポジトリから一時的なタグに作業をフェッチする」にすぎず、その後に &lt;code&gt;git merge&lt;/code&gt; 続きます。</target>
        </trans-unit>
        <trans-unit id="09aeea995eee0f7341283401be15ea3abb990fd5" translate="yes" xml:space="preserve">
          <source>Iterate over all refs that match &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; and show them according to the given &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt;, after sorting them according to the given set of &lt;code&gt;&amp;lt;key&amp;gt;&lt;/code&gt;. If &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt; is given, stop after showing that many refs. The interpolated values in &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; can optionally be quoted as string literals in the specified host language allowing their direct evaluation in that language.</source>
          <target state="translated">&lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; に一致するすべての参照を反復処理し、指定された &lt;code&gt;&amp;lt;key&amp;gt;&lt;/code&gt; のセットに従って並べ替えた後、指定された &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; に従ってそれらを表示します。 &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt; が指定されている場合は、その数の参照を表示した後に停止します。 &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; の補間値は、オプションで、指定されたホスト言語の文字列リテラルとして引用でき、その言語で直接評価できます。</target>
        </trans-unit>
        <trans-unit id="ddf6f030820afdde653bed6b6ae7f0e48144f06d" translate="yes" xml:space="preserve">
          <source>Join two or more development histories together</source>
          <target state="translated">2つ以上の開発履歴を一緒に結合する</target>
        </trans-unit>
        <trans-unit id="045fff3a75d61e019edb089792c9fca9353d7073" translate="yes" xml:space="preserve">
          <source>Just as the filesystem &lt;code&gt;.&lt;/code&gt; (period) refers to the current directory, using a &lt;code&gt;.&lt;/code&gt; as a repository name in Git (a dot-repository) is a relative path and means your current repository.</source>
          <target state="translated">ファイルシステムと同じように &lt;code&gt;.&lt;/code&gt; （ピリオド）は、を使用して現在のディレクトリを参照し &lt;code&gt;.&lt;/code&gt; Gitのリポジトリ名（ドットリポジトリ）は相対パスであり、現在のリポジトリを意味します。</target>
        </trans-unit>
        <trans-unit id="dec0baabf794bebc3957d3bc4ac6d462cd46c778" translate="yes" xml:space="preserve">
          <source>Just doing &lt;code&gt;git checkout-index&lt;/code&gt; does nothing. You probably meant &lt;code&gt;git checkout-index -a&lt;/code&gt;. And if you want to force it, you want &lt;code&gt;git checkout-index -f -a&lt;/code&gt;.</source>
          <target state="translated">ただ、やって &lt;code&gt;git checkout-index&lt;/code&gt; 何もしません。おそらく &lt;code&gt;git checkout-index -a&lt;/code&gt; を意味します。強制したい場合は、 &lt;code&gt;git checkout-index -f -a&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="4909a5e9d012cc77cb3f33966c75c24bd556a2c1" translate="yes" xml:space="preserve">
          <source>Just in case you are doing something exotic, it should be noted that all of the &amp;lt;commit&amp;gt; in the above description, except in the last two forms that use &quot;..&quot; notations, can be any &amp;lt;tree&amp;gt;.</source>
          <target state="translated">何かエキゾチックなことをしている場合に備えて、「..」表記を使用する最後の2つの形式を除いて、上記の説明のすべての&amp;lt;commit&amp;gt;は任意の&amp;lt;tree&amp;gt;であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="4be9ee55a1cb0649bc08a5f7fcba1609e56fcabe" translate="yes" xml:space="preserve">
          <source>Just like &lt;code&gt;push&lt;/code&gt;, a batch sequence of one or more &lt;code&gt;import&lt;/code&gt; is terminated with a blank line. For each batch of &lt;code&gt;import&lt;/code&gt;, the remote helper should produce a fast-import stream terminated by a &lt;code&gt;done&lt;/code&gt; command.</source>
          <target state="translated">&lt;code&gt;push&lt;/code&gt; と同様に、1つ以上の &lt;code&gt;import&lt;/code&gt; バッチシーケンスは空白行で終了します。 &lt;code&gt;import&lt;/code&gt; バッチごとに、リモートヘルパーは、 &lt;code&gt;done&lt;/code&gt; コマンドで終了する高速インポートストリームを生成する必要があります。</target>
        </trans-unit>
        <trans-unit id="586f68de6dc69eba27bb1d4e9d9bb6d0f56b4317" translate="yes" xml:space="preserve">
          <source>Just make sure to disable line wrapping in the email client (GMail&amp;rsquo;s web interface will wrap lines no matter what, so you need to use a real IMAP client).</source>
          <target state="translated">メールクライアントで行の折り返しを無効にしてください（GMailのウェブインターフェースは何があっても行を折り返すため、実際のIMAPクライアントを使用する必要があります）。</target>
        </trans-unit>
        <trans-unit id="40ff32435dadcaf90c9ed938f5946c67e774e649" translate="yes" xml:space="preserve">
          <source>Just make sure to disable line wrapping in the email client (Gmail&amp;rsquo;s web interface will wrap lines no matter what, so you need to use a real IMAP client).</source>
          <target state="translated">電子メールクライアントで行の折り返しを無効にしてください（GmailのWebインターフェイスは何があっても行を折り返すため、実際のIMAPクライアントを使用する必要があります）。</target>
        </trans-unit>
        <trans-unit id="a7ee38bb7be4fc44198cb2685d9601dcf2b9f569" translate="yes" xml:space="preserve">
          <source>K</source>
          <target state="translated">K</target>
        </trans-unit>
        <trans-unit id="b97e8895c584b11a83b65d2dacb8c53b7178dd19" translate="yes" xml:space="preserve">
          <source>KMail</source>
          <target state="translated">KMail</target>
        </trans-unit>
        <trans-unit id="2341c447151da84825db8427aea972cadd7288d2" translate="yes" xml:space="preserve">
          <source>Keep a list of repositories you work with regularly:</source>
          <target state="translated">定期的に作業するリポジトリのリストを保管しておきましょう。</target>
        </trans-unit>
        <trans-unit id="2367d7104c669108a5a4faee96aaf23e4129a768" translate="yes" xml:space="preserve">
          <source>Keep changes in working tree while discarding some previous commits</source>
          <target state="translated">以前のコミットをいくつか破棄しながら、作業ツリーの変更を保持</target>
        </trans-unit>
        <trans-unit id="efc112fed108eb2af53bef134295307559c52881" translate="yes" xml:space="preserve">
          <source>Keep downloaded pack.</source>
          <target state="translated">ダウンロードしたパックを保持します。</target>
        </trans-unit>
        <trans-unit id="9b356018df37cea79789cf69374ce84ecae93c35" translate="yes" xml:space="preserve">
          <source>Keep in mind that the &lt;code&gt;*&lt;/code&gt; (asterisk) wildcard of the local ref (right of the &lt;code&gt;:&lt;/code&gt;) &lt;strong&gt;must&lt;/strong&gt; be the farthest right path component; however the remote wildcard may be anywhere as long as it&amp;rsquo;s an independent path component (surrounded by &lt;code&gt;/&lt;/code&gt; or EOL). This type of configuration is not automatically created by &lt;code&gt;init&lt;/code&gt; and should be manually entered with a text-editor or using &lt;code&gt;git config&lt;/code&gt;.</source>
          <target state="translated">ことを覚えておいてください &lt;code&gt;*&lt;/code&gt; （右のローカル参照の（アスタリスク）ワイルドカード &lt;code&gt;:&lt;/code&gt; ）&lt;strong&gt;しなければならない&lt;/strong&gt;最右パスコンポーネントであること。ただし、リモートワイルドカードは、独立したパスコンポーネント（ &lt;code&gt;/&lt;/code&gt; またはEOLで囲まれている）であればどこでもかまいません。このタイプの構成は、 &lt;code&gt;init&lt;/code&gt; によって自動的に作成されるものではないため、テキストエディターまたは &lt;code&gt;git config&lt;/code&gt; を使用して手動で入力する必要があります。</target>
        </trans-unit>
        <trans-unit id="f28d8482458ad8eaca4da9ce6d9f18435a267b61" translate="yes" xml:space="preserve">
          <source>Keep repeating the process: compile the tree, test it, and depending on whether it is good or bad run &lt;code&gt;git bisect good&lt;/code&gt; or &lt;code&gt;git bisect bad&lt;/code&gt; to ask for the next commit that needs testing.</source>
          <target state="translated">プロセスを繰り返し続けます。ツリーをコンパイルしてテストし、それが良いか悪いかによって &lt;code&gt;git bisect good&lt;/code&gt; または &lt;code&gt;git bisect bad&lt;/code&gt; を実行して、テストが必要な次のコミットを要求します。</target>
        </trans-unit>
        <trans-unit id="4faf21022722c230f52c5287ce302764467e820e" translate="yes" xml:space="preserve">
          <source>Keep the commits that do not change anything from its parents in the result.</source>
          <target state="translated">結果的に親から何も変わらないコミットを維持します。</target>
        </trans-unit>
        <trans-unit id="ea4937dada87f98e69877594a5bd03ebc5a4fc74" translate="yes" xml:space="preserve">
          <source>Keep the current index contents, and read the contents of the named tree-ish under the directory at &lt;code&gt;&amp;lt;prefix&amp;gt;&lt;/code&gt;. The command will refuse to overwrite entries that already existed in the original index file.</source>
          <target state="translated">現在のインデックスの内容を保持し、 &lt;code&gt;&amp;lt;prefix&amp;gt;&lt;/code&gt; のディレクトリにある名前付きtree-ishの内容を読み取ります。このコマンドは、元のインデックスファイルにすでに存在するエントリの上書きを拒否します。</target>
        </trans-unit>
        <trans-unit id="d737c66ea055bf55ed844d15e52460a96096a67f" translate="yes" xml:space="preserve">
          <source>Keep the version from your branch in the work tree, but leave the path in the conflicted state for the user to sort out.</source>
          <target state="translated">ブランチのバージョンは作業ツリーに残しておきますが、パスはユーザーが整理できるように競合状態のままにしておきます。</target>
        </trans-unit>
        <trans-unit id="f9e507eaf43dc998f773c565be5cccbd49c418b4" translate="yes" xml:space="preserve">
          <source>Keep the working tree locked after creation. This is the equivalent of &lt;code&gt;git worktree lock&lt;/code&gt; after &lt;code&gt;git worktree add&lt;/code&gt;, but without a race condition.</source>
          <target state="translated">作成後は、作業ツリーをロックしたままにします。これは相当である &lt;code&gt;git worktree lock&lt;/code&gt; 後 &lt;code&gt;git worktree add&lt;/code&gt; が、競合状態なし。</target>
        </trans-unit>
        <trans-unit id="95e57eb6304d53fb35eb7b893fc3d7458db2c90c" translate="yes" xml:space="preserve">
          <source>Keep the working tree locked after creation. This is the equivalent of &lt;code&gt;git worktree lock&lt;/code&gt; after &lt;code&gt;git worktree add&lt;/code&gt;, but without race condition.</source>
          <target state="translated">作成後、作業ツリーをロックしたままにします。これは &lt;code&gt;git worktree add&lt;/code&gt; の後の &lt;code&gt;git worktree lock&lt;/code&gt; と同等ですが、競合状態はありません。</target>
        </trans-unit>
        <trans-unit id="b288ae9d082d21fcccb8cbea92de9e2fd90c35f9" translate="yes" xml:space="preserve">
          <source>Keep unreachable objects in loose form. This implies &lt;code&gt;--revs&lt;/code&gt;.</source>
          <target state="translated">到達不能な物体はゆるい形で保管してください。これは &lt;code&gt;--revs&lt;/code&gt; を意味します。</target>
        </trans-unit>
        <trans-unit id="5fef7648dce54325886b4bd2e05123b8e3f3ba8b" translate="yes" xml:space="preserve">
          <source>Keep working in your primary repository. Your changes include modifications of your own, patches you receive via e-mails, and merges resulting from pulling the &quot;public&quot; repositories of your &quot;project lead&quot; and possibly your &quot;sub-subsystem maintainers&quot;.</source>
          <target state="translated">プライマリリポジトリで作業を続けてください。あなたの変更には、あなた自身の変更、電子メールで受け取ったパッチ、あなたの &quot;プロジェクトリーダー &quot;や場合によっては &quot;サブサブシステムメンテナ &quot;の &quot;公開 &quot;リポジトリを引っ張ってきた結果のマージなどが含まれます。</target>
        </trans-unit>
        <trans-unit id="ca6eb7beb12ef44a32102578e1d606b2be688242" translate="yes" xml:space="preserve">
          <source>Keep working in your primary repository. Your changes include modifications of your own, patches you receive via e-mails, and merges resulting from pulling the &quot;public&quot; repositories of your &quot;subsystem maintainers&quot;.</source>
          <target state="translated">プライマリリポジトリで作業を続けてください。あなたの変更には、あなた自身の変更、電子メールで受け取ったパッチ、あなたの「サブシステムメンテナ」の「公開」リポジトリを引っ張ってきた結果のマージが含まれます。</target>
        </trans-unit>
        <trans-unit id="04e2360cc7b28c2ccb26642bb98ceb0fcbba2f5a" translate="yes" xml:space="preserve">
          <source>Keeping a patch series up to date using git rebase</source>
          <target state="translated">git rebase を使ってパッチシリーズを最新の状態に保つ</target>
        </trans-unit>
        <trans-unit id="b81b785228a23fa6b75a5abffb474819b40a8136" translate="yes" xml:space="preserve">
          <source>Kill keywords: will extract files with &lt;code&gt;-kk&lt;/code&gt; from the CVS archive to avoid noisy changesets. Highly recommended, but off by default to preserve compatibility with early imported trees.</source>
          <target state="translated">キーワードの削除：ノイズの多い変更セットを回避するために、CVSアーカイブから &lt;code&gt;-kk&lt;/code&gt; でファイルを抽出します。強くお勧めしますが、初期にインポートされたツリーとの互換性を維持するためにデフォルトではオフになっています。</target>
        </trans-unit>
        <trans-unit id="02658e782a0ecc008f0ca6ffc2a20f7bdbee96d7" translate="yes" xml:space="preserve">
          <source>Label for the &quot;home link&quot; at the top of all pages, leading to &lt;code&gt;$home_link&lt;/code&gt; (usually the main gitweb page, which contains the projects list). It is used as the first component of gitweb&amp;rsquo;s &quot;breadcrumb trail&quot;: &lt;code&gt;&amp;lt;home link&amp;gt; / &amp;lt;project&amp;gt; / &amp;lt;action&amp;gt;&lt;/code&gt;. Can be set at build time using the &lt;code&gt;GITWEB_HOME_LINK_STR&lt;/code&gt; variable. By default it is set to &quot;projects&quot;, as this link leads to the list of projects. Another popular choice is to set it to the name of site. Note that it is treated as raw HTML so it should not be set from untrusted sources.</source>
          <target state="translated">すべてのページの上部にある「ホームリンク」のラベル。 &lt;code&gt;$home_link&lt;/code&gt; （通常、プロジェクトリストを含むメインのgitwebページ）につながります。 gitwebの「パンくずリスト」の最初のコンポーネントとして使用されます： &lt;code&gt;&amp;lt;home link&amp;gt; / &amp;lt;project&amp;gt; / &amp;lt;action&amp;gt;&lt;/code&gt; 。ビルド時に &lt;code&gt;GITWEB_HOME_LINK_STR&lt;/code&gt; 変数を使用して設定できます。このリンクはプロジェクトのリストにつながるため、デフォルトでは「プロジェクト」に設定されています。もう1つの一般的な選択は、サイトの名前に設定することです。未加工のHTMLとして扱われるため、信頼できないソースから設定しないでください。</target>
        </trans-unit>
        <trans-unit id="f135ec40c7a65e232b6284c7eadaae14bc4ec8e7" translate="yes" xml:space="preserve">
          <source>Labelling of conflicts markers</source>
          <target state="translated">競合マーカーのラベリング</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
