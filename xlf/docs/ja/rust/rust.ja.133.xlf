<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="1eb81e5b136891ec83f03fa70901b0982c774c3e" translate="yes" xml:space="preserve">
          <source>The iterator will yield instances of &lt;a href=&quot;../io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../fs/struct.direntry&quot;&gt;&lt;code&gt;DirEntry&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. New errors may be encountered after an iterator is initially constructed.</source>
          <target state="translated">イテレータは&lt;a href=&quot;../io/type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../fs/struct.direntry&quot;&gt; &lt;code&gt;DirEntry&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; のインスタンスを生成します。イテレータが最初に作成された後、新しいエラーが発生する場合があります。</target>
        </trans-unit>
        <trans-unit id="fea22bab4e7d7d638613556e79b891a323ca2ee5" translate="yes" xml:space="preserve">
          <source>The iterator will yield instances of &lt;a href=&quot;../io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../fs/struct.direntry&quot;&gt;&lt;code&gt;fs::DirEntry&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. New errors may be encountered after an iterator is initially constructed.</source>
          <target state="translated">The iterator will yield instances of &lt;a href=&quot;../io/type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../fs/struct.direntry&quot;&gt; &lt;code&gt;fs::DirEntry&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; . New errors may be encountered after an iterator is initially constructed.</target>
        </trans-unit>
        <trans-unit id="54667f9a5f59c23223b23e9276c48f67c43aae4e" translate="yes" xml:space="preserve">
          <source>The iterator will yield instances of &lt;a href=&quot;../io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;struct.direntry&quot;&gt;&lt;code&gt;DirEntry&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. New errors may be encountered after an iterator is initially constructed.</source>
          <target state="translated">イテレータは&lt;a href=&quot;../io/type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;struct.direntry&quot;&gt; &lt;code&gt;DirEntry&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; のインスタンスを生成します。イテレータが最初に作成された後、新しいエラーが発生する場合があります。</target>
        </trans-unit>
        <trans-unit id="6720eac87f145ca4ebd08c14afcbc3e18eb5bc63" translate="yes" xml:space="preserve">
          <source>The iterator will yield the &lt;code&gt;Path&lt;/code&gt; that is returned if the &lt;a href=&quot;struct.path#method.parent&quot;&gt;&lt;code&gt;parent&lt;/code&gt;&lt;/a&gt; method is used zero or more times. That means, the iterator will yield &lt;code&gt;&amp;amp;self&lt;/code&gt;, &lt;code&gt;&amp;amp;self.parent().unwrap()&lt;/code&gt;, &lt;code&gt;&amp;amp;self.parent().unwrap().parent().unwrap()&lt;/code&gt; and so on. If the &lt;a href=&quot;struct.path#method.parent&quot;&gt;&lt;code&gt;parent&lt;/code&gt;&lt;/a&gt; method returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, the iterator will do likewise. The iterator will always yield at least one value, namely &lt;code&gt;&amp;amp;self&lt;/code&gt;.</source>
          <target state="translated">イテレータは、&lt;a href=&quot;struct.path#method.parent&quot;&gt; &lt;code&gt;parent&lt;/code&gt; &lt;/a&gt;メソッドが0回以上使用された場合に返される &lt;code&gt;Path&lt;/code&gt; を生成します。つまり、イテレータは &lt;code&gt;&amp;amp;self&lt;/code&gt; 、 &lt;code&gt;&amp;amp;self.parent().unwrap()&lt;/code&gt; 、 &lt;code&gt;&amp;amp;self.parent().unwrap().parent().unwrap()&lt;/code&gt; などを生成します。&lt;a href=&quot;struct.path#method.parent&quot;&gt; &lt;code&gt;parent&lt;/code&gt; &lt;/a&gt;メソッドが&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; を&lt;/a&gt;返す場合、イテレータも同様に行います。イテレータは常に少なくとも1つの値、つまり &lt;code&gt;&amp;amp;self&lt;/code&gt; を生成します。</target>
        </trans-unit>
        <trans-unit id="36ed296a3da7075e704c60a55541d4eefcc61a2e" translate="yes" xml:space="preserve">
          <source>The iterator yields one value if the &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; is a &lt;a href=&quot;enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt;, otherwise none.</source>
          <target state="translated">&lt;a href=&quot;enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt;が&lt;a href=&quot;enum.option#variant.Some&quot;&gt; &lt;code&gt;Some&lt;/code&gt; の&lt;/a&gt;場合、イテレータは1つの値を生成し、それ以外の場合は何も生成しません。</target>
        </trans-unit>
        <trans-unit id="33a7221657feedb4eb9bdbc29b15b1cfdbff0941" translate="yes" xml:space="preserve">
          <source>The iterator yields one value if the result is &lt;a href=&quot;../result/enum.result#Ok.v&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt;, otherwise none.</source>
          <target state="translated">イテレータは、結果が&lt;a href=&quot;../result/enum.result#Ok.v&quot;&gt; &lt;code&gt;Result::Ok&lt;/code&gt; &lt;/a&gt;場合は1つの値を生成し、それ以外の場合は何も生成しません。</target>
        </trans-unit>
        <trans-unit id="98fcd488b58bec9ba13c409525786e8e34d2f3d0" translate="yes" xml:space="preserve">
          <source>The iterator yields one value if the result is &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt;, otherwise none.</source>
          <target state="translated">The iterator yields one value if the result is &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Result::Ok&lt;/code&gt; &lt;/a&gt;, otherwise none.</target>
        </trans-unit>
        <trans-unit id="908b09e4328c560c75c00a1be9bba8fa3c1792fa" translate="yes" xml:space="preserve">
          <source>The iterator yields one value if the result is &lt;a href=&quot;enum.result#Ok.v&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt;, otherwise none.</source>
          <target state="translated">イテレータは、結果が&lt;a href=&quot;enum.result#Ok.v&quot;&gt; &lt;code&gt;Result::Ok&lt;/code&gt; &lt;/a&gt;場合は1つの値を生成し、それ以外の場合は何も生成しません。</target>
        </trans-unit>
        <trans-unit id="8fd298b9ad5df85747acb6e44bba1366e3481860" translate="yes" xml:space="preserve">
          <source>The iterator yields one value if the result is &lt;a href=&quot;enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;, otherwise none.</source>
          <target state="translated">イテレータは、結果が&lt;a href=&quot;enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; の&lt;/a&gt;場合は1つの値を生成し、それ以外の場合は何も生成しません。</target>
        </trans-unit>
        <trans-unit id="41c263ba9c3e1377bcbb306e69ddac6adfb8f150" translate="yes" xml:space="preserve">
          <source>The iterator yields one value if the result is &lt;a href=&quot;enum.result#variant.Ok&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt;, otherwise none.</source>
          <target state="translated">The iterator yields one value if the result is &lt;a href=&quot;enum.result#variant.Ok&quot;&gt; &lt;code&gt;Result::Ok&lt;/code&gt; &lt;/a&gt;, otherwise none.</target>
        </trans-unit>
        <trans-unit id="b80110840b4186388c3ebdd6fff4960efb23a3ca" translate="yes" xml:space="preserve">
          <source>The iterator yields tuples. The position is first, the &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; is second.</source>
          <target state="translated">イテレータはタプルを生成します。最初の位置、&lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;が2番目です。</target>
        </trans-unit>
        <trans-unit id="6ec1542f766c1ecbdef3897acebe4cebd30ca6ee" translate="yes" xml:space="preserve">
          <source>The iterator yields tuples. The position is first, the &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; is second.</source>
          <target state="translated">The iterator yields tuples. The position is first, the &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; is second.</target>
        </trans-unit>
        <trans-unit id="787f68c0ad38019edb27d78451a4d5831f65e4ab" translate="yes" xml:space="preserve">
          <source>The iterator yields tuples. The position is first, the &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; is second.</source>
          <target state="translated">イテレータはタプルを生成します。最初の位置、&lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;が2番目です。</target>
        </trans-unit>
        <trans-unit id="10db2a64e13645a875ad4c150b72d85dec4465d0" translate="yes" xml:space="preserve">
          <source>The iterator yields tuples. The position is first, the &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; is second.</source>
          <target state="translated">The iterator yields tuples. The position is first, the &lt;a href=&quot;primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; is second.</target>
        </trans-unit>
        <trans-unit id="6814fb791ef3836a2e395759e70c2ff3a369ee11" translate="yes" xml:space="preserve">
          <source>The job of &lt;code&gt;read_line&lt;/code&gt; is to take whatever the user types into standard input and place that into a string, so it takes that string as an argument. The string argument needs to be mutable so the method can change the string&amp;rsquo;s content by adding the user input.</source>
          <target state="translated">仕事 &lt;code&gt;read_line&lt;/code&gt; それが引数としてその文字列を取るので、その文字列の中に、標準入力や場所にかかわらず、ユーザーの種類を取ることです。メソッドがユーザー入力を追加して文字列の内容を変更できるように、文字列引数は可変である必要があります。</target>
        </trans-unit>
        <trans-unit id="41c36730094f242762fc2db352770667844d977d" translate="yes" xml:space="preserve">
          <source>The join handle will implicitly &lt;em&gt;detach&lt;/em&gt; the child thread upon being dropped. In this case, the child thread may outlive the parent (unless the parent thread is the main thread; the whole process is terminated when the main thread finishes). Additionally, the join handle provides a &lt;a href=&quot;struct.joinhandle#method.join&quot;&gt;&lt;code&gt;join&lt;/code&gt;&lt;/a&gt; method that can be used to join the child thread. If the child thread panics, &lt;a href=&quot;struct.joinhandle#method.join&quot;&gt;&lt;code&gt;join&lt;/code&gt;&lt;/a&gt; will return an &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; containing the argument given to &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">The join handle will implicitly &lt;em&gt;detach&lt;/em&gt; the child thread upon being dropped. In this case, the child thread may outlive the parent (unless the parent thread is the main thread; the whole process is terminated when the main thread finishes). Additionally, the join handle provides a &lt;a href=&quot;struct.joinhandle#method.join&quot;&gt; &lt;code&gt;join&lt;/code&gt; &lt;/a&gt; method that can be used to join the child thread. If the child thread panics, &lt;a href=&quot;struct.joinhandle#method.join&quot;&gt; &lt;code&gt;join&lt;/code&gt; &lt;/a&gt; will return an &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; containing the argument given to &lt;a href=&quot;../macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="cc7b114b0c6414134b72184594654a5acaffb577" translate="yes" xml:space="preserve">
          <source>The join handle will implicitly &lt;em&gt;detach&lt;/em&gt; the child thread upon being dropped. In this case, the child thread may outlive the parent (unless the parent thread is the main thread; the whole process is terminated when the main thread finishes). Additionally, the join handle provides a &lt;a href=&quot;struct.joinhandle#method.join&quot;&gt;&lt;code&gt;join&lt;/code&gt;&lt;/a&gt; method that can be used to join the child thread. If the child thread panics, &lt;a href=&quot;struct.joinhandle#method.join&quot;&gt;&lt;code&gt;join&lt;/code&gt;&lt;/a&gt; will return an &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; containing the argument given to &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">結合ハンドルは、ドロップされると子スレッドを暗黙的に&lt;em&gt;切り離し&lt;/em&gt;ます。この場合、子スレッドは親よりも長く存続する可能性があります（親スレッドがメインスレッドでない限り、メインスレッドが終了するとプロセス全体が終了します）。さらに、結合ハンドルは、子スレッドを結合するために使用できる&lt;a href=&quot;struct.joinhandle#method.join&quot;&gt; &lt;code&gt;join&lt;/code&gt; &lt;/a&gt;メソッドを提供します。子スレッドがパニックになると、&lt;a href=&quot;struct.joinhandle#method.join&quot;&gt; &lt;code&gt;join&lt;/code&gt; &lt;/a&gt;は&lt;a href=&quot;../macro.panic&quot;&gt; &lt;code&gt;panic&lt;/code&gt; に&lt;/a&gt;指定された引数を含む&lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;を返します。</target>
        </trans-unit>
        <trans-unit id="099a2e1e2bdb72897b42735f9f375efdb1e2c049" translate="yes" xml:space="preserve">
          <source>The key line in this error is &lt;code&gt;cannot move out of type [T], a non-copy slice&lt;/code&gt;. With our non-generic versions of the &lt;code&gt;largest&lt;/code&gt; function, we were only trying to find the largest &lt;code&gt;i32&lt;/code&gt; or &lt;code&gt;char&lt;/code&gt;. As discussed in the &lt;a href=&quot;ch04-01-what-is-ownership#stack-only-data-copy&quot;&gt;&amp;ldquo;Stack-Only Data: Copy&amp;rdquo;&lt;/a&gt; section in Chapter 4, types like &lt;code&gt;i32&lt;/code&gt; and &lt;code&gt;char&lt;/code&gt; that have a known size can be stored on the stack, so they implement the &lt;code&gt;Copy&lt;/code&gt; trait. But when we made the &lt;code&gt;largest&lt;/code&gt; function generic, it became possible for the &lt;code&gt;list&lt;/code&gt; parameter to have types in it that don&amp;rsquo;t implement the &lt;code&gt;Copy&lt;/code&gt; trait. Consequently, we wouldn&amp;rsquo;t be able to move the value out of &lt;code&gt;list[0]&lt;/code&gt; and into the &lt;code&gt;largest&lt;/code&gt; variable, resulting in this error.</source>
          <target state="translated">このエラーの重要な &lt;code&gt;cannot move out of type [T], a non-copy slice&lt;/code&gt; です。 &lt;code&gt;largest&lt;/code&gt; 関数の非ジェネリックバージョンでは、最大の &lt;code&gt;i32&lt;/code&gt; または &lt;code&gt;char&lt;/code&gt; のみを検索しようとしました。第4章の&lt;a href=&quot;ch04-01-what-is-ownership#stack-only-data-copy&quot;&gt;「スタックのみのデータ：コピー」&lt;/a&gt;セクションで説明したように、既知のサイズを持つ &lt;code&gt;i32&lt;/code&gt; や &lt;code&gt;char&lt;/code&gt; などのタイプはスタックに格納できるため、 &lt;code&gt;Copy&lt;/code&gt; トレイトを実装します。ただし、 &lt;code&gt;largest&lt;/code&gt; 関数をジェネリックにすると、 &lt;code&gt;list&lt;/code&gt; パラメーターに &lt;code&gt;Copy&lt;/code&gt; 実装しない型を含めることが可能になりました特性。その結果、値を &lt;code&gt;list[0]&lt;/code&gt; から &lt;code&gt;largest&lt;/code&gt; 変数に移動できなくなり、このエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="bceeadadeee15f4a164537fd341fe02f08db51ce" translate="yes" xml:space="preserve">
          <source>The key may be any borrowed form of the map's key type, but &lt;a href=&quot;../../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; on the borrowed form &lt;em&gt;must&lt;/em&gt; match those for the key type.</source>
          <target state="translated">キーは、マップのキータイプの任意の借用形式にすることができますが、借用フォームの&lt;a href=&quot;../../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt;は、キータイプのそれらと一致する&lt;em&gt;必要があり&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="1967c0afcde1ba185b21a2a66c76557126c2a896" translate="yes" xml:space="preserve">
          <source>The key may be any borrowed form of the map's key type, but &lt;a href=&quot;../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; on the borrowed form &lt;em&gt;must&lt;/em&gt; match those for the key type.</source>
          <target state="translated">キーは、マップのキータイプの任意の借用形式にすることができますが、借用フォームの&lt;a href=&quot;../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt;は、キータイプのそれらと一致する&lt;em&gt;必要があり&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="25f3fabcbbf37a65231d46a27fb9b7a82a76e913" translate="yes" xml:space="preserve">
          <source>The key may be any borrowed form of the map's key type, but the ordering on the borrowed form &lt;em&gt;must&lt;/em&gt; match the ordering on the key type.</source>
          <target state="translated">キーは、マップのキータイプの任意の借用形式にすることができますが、借用フォームの順序は、キータイプの順序と一致する&lt;em&gt;必要があり&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="5794a7e2452d7c2d7acdcd9ca75f9f681dde7e71" translate="yes" xml:space="preserve">
          <source>The key property of unions is that all fields of a union share common storage. As a result writes to one field of a union can overwrite its other fields, and size of a union is determined by the size of its largest field.</source>
          <target state="translated">ユニオンの重要な特性は、ユニオンのすべてのフィールドが共通のストレージを共有していることです。その結果、ユニオンの1つのフィールドへの書き込みは他のフィールドを上書きすることができ、ユニオンのサイズはその最大フィールドのサイズによって決定されます。</target>
        </trans-unit>
        <trans-unit id="af36c49ed669c54fb87fd9d4d2b45f5df4d5de97" translate="yes" xml:space="preserve">
          <source>The key property of unions is that all fields of a union share common storage. As a result, writes to one field of a union can overwrite its other fields, and size of a union is determined by the size of its largest field.</source>
          <target state="translated">ユニオンの重要な特性は、ユニオンのすべてのフィールドが共通のストレージを共有していることです。その結果、ユニオンの1つのフィールドへの書き込みは他のフィールドを上書きすることができ、ユニオンのサイズはその最大フィールドのサイズによって決定されます。</target>
        </trans-unit>
        <trans-unit id="730d38429c1bd8714c2ac7995eb67557271f3b30" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;pub&lt;/code&gt; makes any module, function, or data structure accessible from inside of external modules. The &lt;code&gt;pub&lt;/code&gt; keyword may also be used in a &lt;code&gt;use&lt;/code&gt; declaration to re-export an identifier from a namespace.</source>
          <target state="translated">The keyword &lt;code&gt;pub&lt;/code&gt; makes any module, function, or data structure accessible from inside of external modules. The &lt;code&gt;pub&lt;/code&gt; keyword may also be used in a &lt;code&gt;use&lt;/code&gt; declaration to re-export an identifier from a namespace.</target>
        </trans-unit>
        <trans-unit id="6097954d2b4ff2c7af7f3ee3f3f7074587267681" translate="yes" xml:space="preserve">
          <source>The kinds of patterns for parameters is limited to one of the following:</source>
          <target state="translated">パラメータのパターンの種類は以下のいずれかに限定されます。</target>
        </trans-unit>
        <trans-unit id="9150d911250adb9488a9891d8d1a7dd89c179545" translate="yes" xml:space="preserve">
          <source>The lack of infinite output indicates that this code didn&amp;rsquo;t create a reference cycle. We can also tell this by looking at the values we get from calling &lt;code&gt;Rc::strong_count&lt;/code&gt; and &lt;code&gt;Rc::weak_count&lt;/code&gt;.</source>
          <target state="translated">無限の出力がないことは、このコードが参照サイクルを作成しなかったことを示しています。 &lt;code&gt;Rc::strong_count&lt;/code&gt; および &lt;code&gt;Rc::weak_count&lt;/code&gt; 呼び出して取得した値を確認することでも、これを知ることができます。</target>
        </trans-unit>
        <trans-unit id="4f0cd1d95a878dd3fb3eb033669531c63a686db3" translate="yes" xml:space="preserve">
          <source>The lang attribute is intended for marking special items that are built-in to Rust itself. This includes special traits (like &lt;code&gt;Copy&lt;/code&gt; and &lt;code&gt;Sized&lt;/code&gt;) that affect how the compiler behaves, as well as special functions that may be automatically invoked (such as the handler for out-of-bounds accesses when indexing a slice).</source>
          <target state="translated">The lang attribute is intended for marking special items that are built-in to Rust itself. This includes special traits (like &lt;code&gt;Copy&lt;/code&gt; and &lt;code&gt;Sized&lt;/code&gt; ) that affect how the compiler behaves, as well as special functions that may be automatically invoked (such as the handler for out-of-bounds accesses when indexing a slice).</target>
        </trans-unit>
        <trans-unit id="60e53524d7493db6ac00628d4141587167732e22" translate="yes" xml:space="preserve">
          <source>The lang attribute is intended for marking special items that are built-in to Rust itself. This includes special traits (like &lt;code&gt;Copy&lt;/code&gt; and &lt;code&gt;Sized&lt;/code&gt;) that affect how the compiler behaves, as well as special functions that may be automatically invoked (such as the handler for out-of-bounds accesses when indexing a slice). Erroneous code example:</source>
          <target state="translated">lang属性は、Rust自体に組み込まれている特別なアイテムをマークするためのものです。これには、コンパイラーの動作に影響を与える特別な特性（ &lt;code&gt;Copy&lt;/code&gt; や &lt;code&gt;Sized&lt;/code&gt; など）と、自動的に呼び出される特別な関数（スライスにインデックスを付けるときの境界外アクセスのハンドラーなど）が含まれます。誤ったコード例：</target>
        </trans-unit>
        <trans-unit id="080a1610af4bccfcd8725cb110cddf449fbd60f7" translate="yes" xml:space="preserve">
          <source>The lang attribute was used in an invalid context.</source>
          <target state="translated">lang属性は無効なコンテキストで使用されました。</target>
        </trans-unit>
        <trans-unit id="d001aa0e948f210ef67db3ed9f1079f66965d658" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type.</source>
          <target state="translated">この整数型で表現できる最大の値。</target>
        </trans-unit>
        <trans-unit id="55a17e21fb4394b20facf75f686648a8590b11f1" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i128#associatedconstant.MAX&quot;&gt;&lt;code&gt;i128::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i128#associatedconstant.MAX&quot;&gt; &lt;code&gt;i128::MAX&lt;/code&gt; &lt;/a&gt; instead.</target>
        </trans-unit>
        <trans-unit id="b73325de7bc5986e41ec8d92ed9701ddacd280f3" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i16#associatedconstant.MAX&quot;&gt;&lt;code&gt;i16::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i16#associatedconstant.MAX&quot;&gt; &lt;code&gt;i16::MAX&lt;/code&gt; &lt;/a&gt; instead.</target>
        </trans-unit>
        <trans-unit id="f7bb87b47e7f2c22de123ec199f4be989c0dcaf2" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i32#associatedconstant.MAX&quot;&gt;&lt;code&gt;i32::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i32#associatedconstant.MAX&quot;&gt; &lt;code&gt;i32::MAX&lt;/code&gt; &lt;/a&gt; instead.</target>
        </trans-unit>
        <trans-unit id="cf18dde926e284162a660a1b1a2a30b118d1c49a" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i64#associatedconstant.MAX&quot;&gt;&lt;code&gt;i64::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i64#associatedconstant.MAX&quot;&gt; &lt;code&gt;i64::MAX&lt;/code&gt; &lt;/a&gt; instead.</target>
        </trans-unit>
        <trans-unit id="b22c4dd542e2ceff2527d706e65d0c5acc6f4d52" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i8#associatedconstant.MAX&quot;&gt;&lt;code&gt;i8::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i8#associatedconstant.MAX&quot;&gt; &lt;code&gt;i8::MAX&lt;/code&gt; &lt;/a&gt; instead.</target>
        </trans-unit>
        <trans-unit id="6a2e67766c1f950d1a3f862bddde0bc78e36aacd" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.isize#associatedconstant.MAX&quot;&gt;&lt;code&gt;isize::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.isize#associatedconstant.MAX&quot;&gt; &lt;code&gt;isize::MAX&lt;/code&gt; &lt;/a&gt; instead.</target>
        </trans-unit>
        <trans-unit id="697ca9e8dc5fcb1feb5a529df70222ec030c2428" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u128#associatedconstant.MAX&quot;&gt;&lt;code&gt;u128::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u128#associatedconstant.MAX&quot;&gt; &lt;code&gt;u128::MAX&lt;/code&gt; &lt;/a&gt; instead.</target>
        </trans-unit>
        <trans-unit id="23128039031afffa375e1d18e6f18c10d1470457" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u16#associatedconstant.MAX&quot;&gt;&lt;code&gt;u16::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u16#associatedconstant.MAX&quot;&gt; &lt;code&gt;u16::MAX&lt;/code&gt; &lt;/a&gt; instead.</target>
        </trans-unit>
        <trans-unit id="3cead8aa8b3423346a603591b8a3bb3bb38de07d" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u32#associatedconstant.MAX&quot;&gt;&lt;code&gt;u32::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u32#associatedconstant.MAX&quot;&gt; &lt;code&gt;u32::MAX&lt;/code&gt; &lt;/a&gt; instead.</target>
        </trans-unit>
        <trans-unit id="dfdca1f692589c69870c6eba29a4be248c639ebc" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u64#associatedconstant.MAX&quot;&gt;&lt;code&gt;u64::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u64#associatedconstant.MAX&quot;&gt; &lt;code&gt;u64::MAX&lt;/code&gt; &lt;/a&gt; instead.</target>
        </trans-unit>
        <trans-unit id="de1cfd44e67cca085f5a9478c1e9579b369e52ad" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u8#associatedconstant.MAX&quot;&gt;&lt;code&gt;u8::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u8#associatedconstant.MAX&quot;&gt; &lt;code&gt;u8::MAX&lt;/code&gt; &lt;/a&gt; instead.</target>
        </trans-unit>
        <trans-unit id="9c52af57b6ca83f430b64beb1abd9c9176989341" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.usize#associatedconstant.MAX&quot;&gt;&lt;code&gt;usize::MAX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">The largest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.usize#associatedconstant.MAX&quot;&gt; &lt;code&gt;usize::MAX&lt;/code&gt; &lt;/a&gt; instead.</target>
        </trans-unit>
        <trans-unit id="5bab83aeec1382113d53e6e7d14863dd49ec843d" translate="yes" xml:space="preserve">
          <source>The last change we have to make is in the assertion: to see how many items are in the inner vector, we call &lt;code&gt;borrow&lt;/code&gt; on the &lt;code&gt;RefCell&amp;lt;Vec&amp;lt;String&amp;gt;&amp;gt;&lt;/code&gt; to get an immutable reference to the vector.</source>
          <target state="translated">最後に行う必要のある変更はアサーションです。内部ベクトルにあるアイテムの数を確認するには、 &lt;code&gt;RefCell&amp;lt;Vec&amp;lt;String&amp;gt;&amp;gt;&lt;/code&gt; &lt;code&gt;borrow&lt;/code&gt; を呼び出して、ベクトルへの不変の参照を取得します。</target>
        </trans-unit>
        <trans-unit id="b92b068be4c2b594134000422ae50b8df0c8bac3" translate="yes" xml:space="preserve">
          <source>The last difference is that constants may be set only to a constant expression, not the result of a function call or any other value that could only be computed at runtime.</source>
          <target state="translated">最後の違いは、定数は定数式にのみ設定でき、関数呼び出しの結果や実行時にしか計算できなかった他の値は設定できないということです。</target>
        </trans-unit>
        <trans-unit id="293474ffe041aff8a994854d8cad3ac993cf31b4" translate="yes" xml:space="preserve">
          <source>The last element returned, if any, will contain the remainder of the slice.</source>
          <target state="translated">最後に返された要素があれば、スライスの残りの部分が含まれます。</target>
        </trans-unit>
        <trans-unit id="8d491eebdf550e16362be621e1476cb5ece9206f" translate="yes" xml:space="preserve">
          <source>The last field of &lt;code&gt;Foo&lt;/code&gt; has a type involving &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Foo&lt;/code&gt; の最後のフィールドには &lt;code&gt;T&lt;/code&gt; が関係する型があります。</target>
        </trans-unit>
        <trans-unit id="bf70627b4e81c57a3ddc9f76311bc0b01f381dcd" translate="yes" xml:space="preserve">
          <source>The last line of the output shows the location and the name of the installed binary, which in the case of &lt;code&gt;ripgrep&lt;/code&gt; is &lt;code&gt;rg&lt;/code&gt;. As long as the installation directory is in your &lt;code&gt;$PATH&lt;/code&gt;, as mentioned previously, you can then run &lt;code&gt;rg --help&lt;/code&gt; and start using a faster, rustier tool for searching files!</source>
          <target state="translated">出力の最後の行には、インストールされたバイナリの場所と名前が表示されます。 &lt;code&gt;ripgrep&lt;/code&gt; は、ripgrepの場合は &lt;code&gt;rg&lt;/code&gt; です。前述のように、インストールディレクトリが &lt;code&gt;$PATH&lt;/code&gt; にある限り、 &lt;code&gt;rg --help&lt;/code&gt; を実行して、ファイルを検索するためのより高速で信頼性の高いツールの使用を開始できます。</target>
        </trans-unit>
        <trans-unit id="3dc7b6a27a6191be06711a90615e83b643711efc" translate="yes" xml:space="preserve">
          <source>The last line shows that &lt;code&gt;&amp;amp;bar&lt;/code&gt; is not a function pointer either. Rather, it is a reference to the function-specific ZST. &lt;code&gt;&amp;amp;bar&lt;/code&gt; is basically never what you want when &lt;code&gt;bar&lt;/code&gt; is a function.</source>
          <target state="translated">The last line shows that &lt;code&gt;&amp;amp;bar&lt;/code&gt; is not a function pointer either. Rather, it is a reference to the function-specific ZST. &lt;code&gt;&amp;amp;bar&lt;/code&gt; is basically never what you want when &lt;code&gt;bar&lt;/code&gt; is a function.</target>
        </trans-unit>
        <trans-unit id="982060970609630bdcfd3dbdc543a9a98b2de24a" translate="yes" xml:space="preserve">
          <source>The last line, &lt;code&gt;[dependencies]&lt;/code&gt;, is the start of a section for you to list any of your project&amp;rsquo;s dependencies. In Rust, packages of code are referred to as &lt;em&gt;crates&lt;/em&gt;. We won&amp;rsquo;t need any other crates for this project, but we will in the first project in Chapter 2, so we&amp;rsquo;ll use this dependencies section then.</source>
          <target state="translated">最後の行 &lt;code&gt;[dependencies]&lt;/code&gt; は、プロジェクトの依存関係をリストするセクションの始まりです。Rustでは、コードのパッケージは&lt;em&gt;クレート&lt;/em&gt;と呼ばれます。このプロジェクトには他の箱は必要ありませんが、第2章の最初のプロジェクトでは、この依存関係セクションを使用します。</target>
        </trans-unit>
        <trans-unit id="c8d286da9b3987ef73f4d9e79523c9888a168257" translate="yes" xml:space="preserve">
          <source>The last of our common collections is the &lt;em&gt;hash map&lt;/em&gt;. The type &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; stores a mapping of keys of type &lt;code&gt;K&lt;/code&gt; to values of type &lt;code&gt;V&lt;/code&gt;. It does this via a &lt;em&gt;hashing function&lt;/em&gt;, which determines how it places these keys and values into memory. Many programming languages support this kind of data structure, but they often use a different name, such as hash, map, object, hash table, dictionary, or associative array, just to name a few.</source>
          <target state="translated">私たちの一般的なコレクションの最後は&lt;em&gt;ハッシュマップ&lt;/em&gt;です。タイプ &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; は、タイプ &lt;code&gt;K&lt;/code&gt; のキーのタイプ &lt;code&gt;V&lt;/code&gt; の値へのマッピングを格納します。これは、これらのキーと値をメモリに配置する方法を決定する&lt;em&gt;ハッシュ関数&lt;/em&gt;を介して行われます。多くのプログラミング言語はこの種のデータ構造をサポートしていますが、いくつか例を挙げると、ハッシュ、マップ、オブジェクト、ハッシュテーブル、ディクショナリ、連想配列などの別の名前がよく使用されます。</target>
        </trans-unit>
        <trans-unit id="e50377e1cc3271006121b6b6e503348b95075085" translate="yes" xml:space="preserve">
          <source>The last part is the HTTP version the client uses, and then the request line ends in a &lt;em&gt;CRLF sequence&lt;/em&gt;. (CRLF stands for &lt;em&gt;carriage return&lt;/em&gt; and &lt;em&gt;line feed&lt;/em&gt;, which are terms from the typewriter days!) The CRLF sequence can also be written as &lt;code&gt;\r\n&lt;/code&gt;, where &lt;code&gt;\r&lt;/code&gt; is a carriage return and &lt;code&gt;\n&lt;/code&gt; is a line feed. The CRLF sequence separates the request line from the rest of the request data. Note that when the CRLF is printed, we see a new line start rather than &lt;code&gt;\r\n&lt;/code&gt;.</source>
          <target state="translated">最後の部分はクライアントが使用するHTTPバージョンであり、リクエスト行は&lt;em&gt;CRLFシーケンスで&lt;/em&gt;終わり&lt;em&gt;ます&lt;/em&gt;。（CRLFは&lt;em&gt;キャリッジリターン&lt;/em&gt;と&lt;em&gt;ラインフィード&lt;/em&gt;を表し、タイプライターの時代の用語です！）CRLFシーケンスは &lt;code&gt;\r\n&lt;/code&gt; と書くこともできます。ここで、 &lt;code&gt;\r&lt;/code&gt; はキャリッジリターン、 &lt;code&gt;\n&lt;/code&gt; はラインフィードです。CRLFシーケンスは、要求行を残りの要求データから分離します。CRLFが出力されると、 &lt;code&gt;\r\n&lt;/code&gt; ではなく新しい行の開始が表示されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="e7f87628bb5e91d33e6ee47cc631179039d310fa" translate="yes" xml:space="preserve">
          <source>The layout of a type is its size, alignment, and the relative offsets of its fields. For enums, how the discriminant is laid out and interpreted is also part of type layout.</source>
          <target state="translated">型のレイアウトは、そのサイズ、配置、フィールドの相対的なオフセットです。enumsの場合、判別値がどのようにレイアウトされ、解釈されるかも型のレイアウトの一部です。</target>
        </trans-unit>
        <trans-unit id="bb7242c48b73507f4d4792c2cb29fe84ab3a4519" translate="yes" xml:space="preserve">
          <source>The layout of allocation request that failed</source>
          <target state="translated">失敗した割当要求のレイアウト</target>
        </trans-unit>
        <trans-unit id="d81ce81ead59e71cfd072129a8c87907148c562c" translate="yes" xml:space="preserve">
          <source>The left operand of an &lt;a href=&quot;expressions/operator-expr#assignment-expressions&quot;&gt;assignment&lt;/a&gt; or &lt;a href=&quot;expressions/operator-expr#compound-assignment-expressions&quot;&gt;compound assignment&lt;/a&gt; expression.</source>
          <target state="translated">&lt;a href=&quot;expressions/operator-expr#assignment-expressions&quot;&gt;割り当て&lt;/a&gt;または&lt;a href=&quot;expressions/operator-expr#compound-assignment-expressions&quot;&gt;複合割り当て&lt;/a&gt;式の左オペランド。</target>
        </trans-unit>
        <trans-unit id="1c0d113ddd28e543817cdc902e3988c72a15e13a" translate="yes" xml:space="preserve">
          <source>The left shift assignment operator &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt;.</source>
          <target state="translated">左シフト代入演算子 &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="553d8d3f55b49cb8907e0699dd0a3d9c13298c80" translate="yes" xml:space="preserve">
          <source>The left shift operator &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;. Note that because this trait is implemented for all integer types with multiple right-hand-side types, Rust's type checker has special handling for &lt;code&gt;_ &amp;lt;&amp;lt; _&lt;/code&gt;, setting the result type for integer operations to the type of the left-hand-side operand. This means that though &lt;code&gt;a &amp;lt;&amp;lt; b&lt;/code&gt; and &lt;code&gt;a.shl(b)&lt;/code&gt; are one and the same from an evaluation standpoint, they are different when it comes to type inference.</source>
          <target state="translated">左シフト演算子 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 。この特性は複数の右側の型を持つすべての整数型に実装されているため、Rustの型チェッカーは &lt;code&gt;_ &amp;lt;&amp;lt; _&lt;/code&gt; に対して特別な処理を行い、整数演算の結果の型を左側のオペランドの型に設定します。 。つまり、 &lt;code&gt;a &amp;lt;&amp;lt; b&lt;/code&gt; と &lt;code&gt;a.shl(b)&lt;/code&gt; は、評価の観点からはまったく同じものですが、型推論に関しては異なります。</target>
        </trans-unit>
        <trans-unit id="abb83d0dbf2481e1c0cc0aff75ee4837acd9c8fb" translate="yes" xml:space="preserve">
          <source>The left-hand side of a compound assignment expression must be a place expression. A place expression represents a memory location and includes item paths (ie, namespaced variables), dereferences, indexing expressions, and field references.</source>
          <target state="translated">複合代入式の左側は場所式でなければなりません。配置式はメモリの場所を表し、項目パス(ネームスペース変数など)、参照、インデキシング式、フィールド参照を含みます。</target>
        </trans-unit>
        <trans-unit id="9df6999a3c0f46759818b5fb8abefef29f79e559" translate="yes" xml:space="preserve">
          <source>The left-hand side of an assignment operator must be a place expression. A place expression represents a memory location and can be a variable (with optional namespacing), a dereference, an indexing expression or a field reference.</source>
          <target state="translated">代入演算子の左側は、場所式でなければなりません。場所式はメモリの場所を表し、変数(オプションで名前空間を持つ)、参照、インデックス式、フィールド参照のいずれかになります。</target>
        </trans-unit>
        <trans-unit id="e2c37a7f1d5752be8f4a3cd4c10444c370f709c8" translate="yes" xml:space="preserve">
          <source>The length is how much memory, in bytes, the contents of the &lt;code&gt;String&lt;/code&gt; is currently using. The capacity is the total amount of memory, in bytes, that the &lt;code&gt;String&lt;/code&gt; has received from the allocator. The difference between length and capacity matters, but not in this context, so for now, it&amp;rsquo;s fine to ignore the capacity.</source>
          <target state="translated">The length is how much memory, in bytes, the contents of the &lt;code&gt;String&lt;/code&gt; is currently using. The capacity is the total amount of memory, in bytes, that the &lt;code&gt;String&lt;/code&gt; has received from the allocator. The difference between length and capacity matters, but not in this context, so for now, it&amp;rsquo;s fine to ignore the capacity.</target>
        </trans-unit>
        <trans-unit id="583ea3cae577825fe984e0b2dabdc2098e762a9c" translate="yes" xml:space="preserve">
          <source>The length is how much memory, in bytes, the contents of the &lt;code&gt;String&lt;/code&gt; is currently using. The capacity is the total amount of memory, in bytes, that the &lt;code&gt;String&lt;/code&gt; has received from the operating system. The difference between length and capacity matters, but not in this context, so for now, it&amp;rsquo;s fine to ignore the capacity.</source>
          <target state="translated">長さは、 &lt;code&gt;String&lt;/code&gt; の内容が現在使用しているメモリ量（バイト単位）です。容量は、 &lt;code&gt;String&lt;/code&gt; がオペレーティングシステムから受信したメモリの総量（バイト単位）です。長さと容量の違いは重要ですが、このコンテキストでは重要ではないため、現時点では容量を無視しても問題ありません。</target>
        </trans-unit>
        <trans-unit id="bec01c75ecf9080484e0035ecb4817690e9d17fa" translate="yes" xml:space="preserve">
          <source>The length of &lt;code&gt;other&lt;/code&gt; must be the same as &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;other&lt;/code&gt; の長さは &lt;code&gt;self&lt;/code&gt; と同じでなければなりません。</target>
        </trans-unit>
        <trans-unit id="1d3c6c04d874a34e3f73cf44da542c5ee7d39510" translate="yes" xml:space="preserve">
          <source>The length of &lt;code&gt;src&lt;/code&gt; must be the same as &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; の長さは、 &lt;code&gt;self&lt;/code&gt; と同じでなければなりません。</target>
        </trans-unit>
        <trans-unit id="f5ae40e336b72c0149684750f73301547acc7603" translate="yes" xml:space="preserve">
          <source>The length of the platform-intrinsic function &lt;code&gt;simd_shuffle&lt;/code&gt; wasn't specified.</source>
          <target state="translated">The length of the platform-intrinsic function &lt;code&gt;simd_shuffle&lt;/code&gt; wasn't specified.</target>
        </trans-unit>
        <trans-unit id="65b0bfaafe677ff19be99641d06a9d0388b357ef" translate="yes" xml:space="preserve">
          <source>The length of the platform-intrinsic function &lt;code&gt;simd_shuffle&lt;/code&gt; wasn't specified. Erroneous code example:</source>
          <target state="translated">プラットフォーム固有の関数 &lt;code&gt;simd_shuffle&lt;/code&gt; の長さが指定されていませんでした。誤ったコード例：</target>
        </trans-unit>
        <trans-unit id="2e4dc711d20d353ed60fc2eb7d0105870f230a29" translate="yes" xml:space="preserve">
          <source>The length returned is that of the underlying storage used by &lt;code&gt;OsStr&lt;/code&gt;. As discussed in the &lt;a href=&quot;struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; introduction, &lt;a href=&quot;struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;OsStr&lt;/code&gt; store strings in a form best suited for cheap inter-conversion between native-platform and Rust string forms, which may differ significantly from both of them, including in storage size and encoding.</source>
          <target state="translated">The length returned is that of the underlying storage used by &lt;code&gt;OsStr&lt;/code&gt; . As discussed in the &lt;a href=&quot;struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt; introduction, &lt;a href=&quot;struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt; and &lt;code&gt;OsStr&lt;/code&gt; store strings in a form best suited for cheap inter-conversion between native-platform and Rust string forms, which may differ significantly from both of them, including in storage size and encoding.</target>
        </trans-unit>
        <trans-unit id="2fe8cad4da628228b8d9a6730b144662e5d5b147" translate="yes" xml:space="preserve">
          <source>The length returned is that of the underlying storage used by &lt;code&gt;OsStr&lt;/code&gt;; As discussed in the &lt;a href=&quot;struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; introduction, &lt;a href=&quot;struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;OsStr&lt;/code&gt; store strings in a form best suited for cheap inter-conversion between native-platform and Rust string forms, which may differ significantly from both of them, including in storage size and encoding.</source>
          <target state="translated">返される長さは、 &lt;code&gt;OsStr&lt;/code&gt; によって使用される基になるストレージの長さです。&lt;a href=&quot;struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; の概要で&lt;/a&gt;説明したように、&lt;a href=&quot;struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt;と &lt;code&gt;OsStr&lt;/code&gt; は、ネイティブプラットフォーム形式とRust文字列形式の間の安価な相互変換に最適な形式で文字列を格納します。これは、ストレージサイズやエンコーディングなど、両方の形式と大幅に異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="99a0d51daa7130da604f883d5259ae5835cb10c2" translate="yes" xml:space="preserve">
          <source>The lifetime bound for this object type cannot be deduced from context and must be specified.</source>
          <target state="translated">このオブジェクト型の寿命はコンテキストから推論することができず、指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="71866b1db7de253967c22f08d6dc545dfcd4182b" translate="yes" xml:space="preserve">
          <source>The lifetime constraint &lt;code&gt;'b&lt;/code&gt; for &lt;code&gt;bar()&lt;/code&gt; implementation does not match the trait declaration. Ensure lifetime declarations match exactly in both trait declaration and implementation. Example:</source>
          <target state="translated">The lifetime constraint &lt;code&gt;'b&lt;/code&gt; for &lt;code&gt;bar()&lt;/code&gt; implementation does not match the trait declaration. Ensure lifetime declarations match exactly in both trait declaration and implementation. Example:</target>
        </trans-unit>
        <trans-unit id="30238ceba60deefc79cfa25b4649d1a595edd0d8" translate="yes" xml:space="preserve">
          <source>The lifetime constraint &lt;code&gt;'b&lt;/code&gt; for bar() implementation does not match the trait declaration. Ensure lifetime declarations match exactly in both trait declaration and implementation. Example:</source>
          <target state="translated">bar（）実装のライフタイム制約 &lt;code&gt;'b&lt;/code&gt; は、特性宣言と一致しません。ライフタイム宣言が特性宣言と実装の両方で正確に一致するようにします。例：</target>
        </trans-unit>
        <trans-unit id="61076c57b01b556a6cbf075ae8202a67124b97eb" translate="yes" xml:space="preserve">
          <source>The lifetime elision rules require that any function signature with an elided output lifetime must either have</source>
          <target state="translated">ライフタイムエリシオンの規則では、出力のライフタイムが省略されている関数シグネチャは、次のいずれかを持たなければなりません。</target>
        </trans-unit>
        <trans-unit id="15fb2549a777717fb62ea70833166d18eb32b15d" translate="yes" xml:space="preserve">
          <source>The lifetime elision rules require that any function signature with an elided output lifetime must either have:</source>
          <target state="translated">ライフタイムエリシオンの規則は、出力のライフタイムが省略された関数シグネチャは、次のいずれかを持たなければならないことを要求します。</target>
        </trans-unit>
        <trans-unit id="7914129f994f43353c3efa7974019d9a960355fb" translate="yes" xml:space="preserve">
          <source>The lifetime for the returned slice is inferred from its usage. To prevent accidental misuse, it's suggested to tie the lifetime to whichever source lifetime is safe in the context, such as by providing a helper function taking the lifetime of a host value for the slice, or by explicit annotation.</source>
          <target state="translated">返されたスライスの寿命は、その使用法から推測されます。誤って誤用されることを防ぐために、スライスのホスト値の寿命を取るヘルパー関数を提供したり、明示的なアノテーションを行うなど、コンテキストで安全なソースの寿命に結びつけることが推奨されています。</target>
        </trans-unit>
        <trans-unit id="af0f1e1de97ff5087fa423eab95c1e381b7b3ee8" translate="yes" xml:space="preserve">
          <source>The lifetime of the returned &lt;code&gt;Cursor&lt;/code&gt; is bound to that of the &lt;code&gt;CursorMut&lt;/code&gt;, which means it cannot outlive the &lt;code&gt;CursorMut&lt;/code&gt; and that the &lt;code&gt;CursorMut&lt;/code&gt; is frozen for the lifetime of the &lt;code&gt;Cursor&lt;/code&gt;.</source>
          <target state="translated">返されるの寿命 &lt;code&gt;Cursor&lt;/code&gt; のようにバインドされ &lt;code&gt;CursorMut&lt;/code&gt; それは長生きできないことを意味し、 &lt;code&gt;CursorMut&lt;/code&gt; をしていること &lt;code&gt;CursorMut&lt;/code&gt; はの寿命のために凍結される &lt;code&gt;Cursor&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="57046a8e7fbf89990ae303fb2235f525d1c99061" translate="yes" xml:space="preserve">
          <source>The lifetime parameter declaration after &lt;code&gt;impl&lt;/code&gt; and its use after the type name are required, but we&amp;rsquo;re not required to annotate the lifetime of the reference to &lt;code&gt;self&lt;/code&gt; because of the first elision rule.</source>
          <target state="translated">&lt;code&gt;impl&lt;/code&gt; の後のライフタイムパラメータ宣言と型名の後のその使用が必要ですが、最初の省略ルールのため、参照のライフタイムに &lt;code&gt;self&lt;/code&gt; の注釈を付ける必要はありません。</target>
        </trans-unit>
        <trans-unit id="37f7629efc4022ff5cf0b561478f77607b602987" translate="yes" xml:space="preserve">
          <source>The lifetime parameters of the method do not match the trait declaration.</source>
          <target state="translated">メソッドのライフタイムパラメータが形質宣言と一致しません。</target>
        </trans-unit>
        <trans-unit id="14f07422d02861a626046c58ce643a2a52da0ac8" translate="yes" xml:space="preserve">
          <source>The line &lt;code&gt;index out of bounds: the len is 1 but the index is 1&lt;/code&gt; is an error message intended for programmers. It won&amp;rsquo;t help our end users understand what happened and what they should do instead. Let&amp;rsquo;s fix that now.</source>
          <target state="translated">&lt;code&gt;index out of bounds: the len is 1 but the index is 1&lt;/code&gt; の行インデックス：lenは1ですが、インデックスは1です。これは、プログラマー向けのエラーメッセージです。これは、エンドユーザーが何が起こったか、代わりに何をすべきかを理解するのに役立ちません。それを修正しましょう。</target>
        </trans-unit>
        <trans-unit id="5a0147b8f24f32bab15f7fb8959607d1c4391ac2" translate="yes" xml:space="preserve">
          <source>The line is:</source>
          <target state="translated">セリフは</target>
        </trans-unit>
        <trans-unit id="de1c3b88f137cbbbccea4f427174e92d6650dd55" translate="yes" xml:space="preserve">
          <source>The lines execute in the order in which they appear in the &lt;code&gt;main&lt;/code&gt; function. First, the &amp;ldquo;Hello, world!&amp;rdquo; message prints, and then &lt;code&gt;another_function&lt;/code&gt; is called and its message is printed.</source>
          <target state="translated">行は、 &lt;code&gt;main&lt;/code&gt; 関数に表示される順序で実行されます。まず、「Hello、world！」メッセージが出力され、 &lt;code&gt;another_function&lt;/code&gt; が呼び出されてそのメッセージが出力されます。</target>
        </trans-unit>
        <trans-unit id="a2f50a40f788fe52620261459fe43b43f06256a8" translate="yes" xml:space="preserve">
          <source>The linkage of the C runtime is configured to respect the &lt;code&gt;crt-static&lt;/code&gt; target feature. These target features are typically configured from the command line via flags to the compiler itself. For example to enable a static runtime you would execute:</source>
          <target state="translated">Cランタイムのリンケージは、 &lt;code&gt;crt-static&lt;/code&gt; ターゲット機能を尊重するように構成されています。これらのターゲット機能は、通常、コマンドラインからフラグを介してコンパイラー自体に構成されます。たとえば、静的ランタイムを有効にするには、次を実行します。</target>
        </trans-unit>
        <trans-unit id="efca89d0995e1ff0c39cef27089410685b77deb1" translate="yes" xml:space="preserve">
          <source>The list of derivable traits provided in this appendix is not comprehensive: libraries can implement &lt;code&gt;derive&lt;/code&gt; for their own traits, making the list of traits you can use &lt;code&gt;derive&lt;/code&gt; with truly open-ended. Implementing &lt;code&gt;derive&lt;/code&gt; involves using a procedural macro, which is covered in the &lt;a href=&quot;ch19-06-macros#macros&quot;&gt;&amp;ldquo;Macros&amp;rdquo;&lt;/a&gt; section of Chapter 19.</source>
          <target state="translated">この付録で提供されている派生可能なトレイトのリストは包括的ではありません。ライブラリは独自のトレイトの &lt;code&gt;derive&lt;/code&gt; を実装でき、使用できるトレイトのリストを完全にオープンエンドで &lt;code&gt;derive&lt;/code&gt; できます。 &lt;code&gt;derive&lt;/code&gt; 実装には、手続き型マクロの使用が含まれます。これについては、第19章の&lt;a href=&quot;ch19-06-macros#macros&quot;&gt;「マクロ」&lt;/a&gt;セクションで説明しています。</target>
        </trans-unit>
        <trans-unit id="e9a2965c85bdbd082d28a62c5ab1cef15f730b46" translate="yes" xml:space="preserve">
          <source>The list of types is:</source>
          <target state="translated">タイプの一覧です。</target>
        </trans-unit>
        <trans-unit id="91f214c30e2ceb29652b72be6f5c77765c1026b7" translate="yes" xml:space="preserve">
          <source>The literal characters &lt;code&gt;{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt; may be included in a string by preceding them with the same character. For example, the &lt;code&gt;{&lt;/code&gt; character is escaped with &lt;code&gt;{{&lt;/code&gt; and the &lt;code&gt;}&lt;/code&gt; character is escaped with &lt;code&gt;}}&lt;/code&gt;.</source>
          <target state="translated">リテラル文字 &lt;code&gt;{&lt;/code&gt; および &lt;code&gt;}&lt;/code&gt; は、それらの前に同じ文字を付けることにより、文字列に含めることができます。たとえば、 &lt;code&gt;{&lt;/code&gt; 文字は &lt;code&gt;{{&lt;/code&gt; でエスケープされ、 &lt;code&gt;}&lt;/code&gt; 文字は &lt;code&gt;}}&lt;/code&gt; でエスケープされます。</target>
        </trans-unit>
        <trans-unit id="d5be7b0512e1a505e9266eb524c4b5165ed24536" translate="yes" xml:space="preserve">
          <source>The lock could not be acquired at this time because the operation would otherwise block.</source>
          <target state="translated">この時点でロックを取得できなかったのは、操作がブロックされていたためです。</target>
        </trans-unit>
        <trans-unit id="ca27685a95f0186521159c6d95fa9cb158ac3333" translate="yes" xml:space="preserve">
          <source>The lock could not be acquired because another thread failed while holding the lock.</source>
          <target state="translated">ロックを保持中に別のスレッドが失敗したため、ロックを取得できませんでした。</target>
        </trans-unit>
        <trans-unit id="e835ab2030797bd0af68c5e546090096d0ef15ed" translate="yes" xml:space="preserve">
          <source>The lock is released when the returned lock goes out of scope. The returned guard also implements the &lt;a href=&quot;trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.bufread&quot;&gt;&lt;code&gt;BufRead&lt;/code&gt;&lt;/a&gt; traits for accessing the underlying data.</source>
          <target state="translated">返されたロックが範囲外になると、ロックは解放されます。返されたガードは、基になるデータにアクセスするための&lt;a href=&quot;trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;trait.bufread&quot;&gt; &lt;code&gt;BufRead&lt;/code&gt; &lt;/a&gt;トレイトも実装します。</target>
        </trans-unit>
        <trans-unit id="ca99507e16c078ed3bf090ad447532972842294c" translate="yes" xml:space="preserve">
          <source>The lock is released when the returned lock goes out of scope. The returned guard also implements the &lt;a href=&quot;trait.write&quot;&gt;&lt;code&gt;Write&lt;/code&gt;&lt;/a&gt; trait for writing data.</source>
          <target state="translated">The lock is released when the returned lock goes out of scope. The returned guard also implements the &lt;a href=&quot;trait.write&quot;&gt; &lt;code&gt;Write&lt;/code&gt; &lt;/a&gt; trait for writing data.</target>
        </trans-unit>
        <trans-unit id="95f3d5bdf30a84c247ddb912c9e27503ec850ddb" translate="yes" xml:space="preserve">
          <source>The lock is released when the returned lock goes out of scope. The returned guard also implements the &lt;code&gt;Write&lt;/code&gt; trait for writing data.</source>
          <target state="translated">返されたロックが範囲外になると、ロックは解放されます。返されたガードは、データを書き込むための &lt;code&gt;Write&lt;/code&gt; トレイトも実装します。</target>
        </trans-unit>
        <trans-unit id="9fbc8134425c3ce849c012cee6ed6bdb948d21a6" translate="yes" xml:space="preserve">
          <source>The logic around the &lt;code&gt;value&lt;/code&gt; field we&amp;rsquo;ve just described is defined in Listing 13-10.</source>
          <target state="translated">今説明した &lt;code&gt;value&lt;/code&gt; フィールドの周りのロジックは、リスト13-10で定義されています。</target>
        </trans-unit>
        <trans-unit id="f2cf3737106dde9e749616b8670f272a444680a9" translate="yes" xml:space="preserve">
          <source>The lower bound of the range (inclusive).</source>
          <target state="translated">範囲の下界(含む)。</target>
        </trans-unit>
        <trans-unit id="0766d14228f909fbfdac3f3dca197e2a666359ec" translate="yes" xml:space="preserve">
          <source>The lower-level cause of this error, if any.</source>
          <target state="translated">このエラーの下位レベルの原因がある場合。</target>
        </trans-unit>
        <trans-unit id="4b8803f6ab5b8d7b772e6a580f89ee4b72aef2f4" translate="yes" xml:space="preserve">
          <source>The lower-level cause of this error, if any. &lt;a href=&quot;../../error/trait.error#method.cause&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">このエラーの下位レベルの原因（ある場合）。&lt;a href=&quot;../../error/trait.error#method.cause&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5980cf0091c024091baef1d2b8180b13d7e8fb92" translate="yes" xml:space="preserve">
          <source>The lower-level cause of this error, if any. &lt;a href=&quot;../error/trait.error#method.cause&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">このエラーの下位レベルの原因（ある場合）。&lt;a href=&quot;../error/trait.error#method.cause&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f757a43bf56678673d64a896a7ea59d83e9d1668" translate="yes" xml:space="preserve">
          <source>The lower-level cause of this error, if any. &lt;a href=&quot;error/trait.error#method.cause&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">このエラーの下位レベルの原因（ある場合）。&lt;a href=&quot;error/trait.error#method.cause&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="828185ce8f6bedf0299995b3c4e9cb20b7a41ecd" translate="yes" xml:space="preserve">
          <source>The lower-level source of this error, if any.</source>
          <target state="translated">このエラーの下位レベルのソースがある場合は、その下位レベルのソース。</target>
        </trans-unit>
        <trans-unit id="ea0a6930dc7de4d466ce55f6448d31ae162ca38c" translate="yes" xml:space="preserve">
          <source>The lower-level source of this error, if any. &lt;a href=&quot;../../error/trait.error#method.source&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">このエラーの下位レベルのソース（存在する場合）。&lt;a href=&quot;../../error/trait.error#method.source&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fb0a1822fe706b0e16bb4cab78928338d81339e3" translate="yes" xml:space="preserve">
          <source>The lower-level source of this error, if any. &lt;a href=&quot;../error/trait.error#method.source&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">このエラーの下位レベルのソース（存在する場合）。&lt;a href=&quot;../error/trait.error#method.source&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bccd557ca491cf82db4f740ce89716ec64f4fabf" translate="yes" xml:space="preserve">
          <source>The lower-level source of this error, if any. &lt;a href=&quot;error/trait.error#method.source&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">このエラーの下位レベルのソース（存在する場合）。&lt;a href=&quot;error/trait.error#method.source&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f6b9226fd8ae01998a5ebc10002aa19b3691743f" translate="yes" xml:space="preserve">
          <source>The machine code for &lt;code&gt;foo::&amp;lt;u8&amp;gt;()&lt;/code&gt;, &lt;code&gt;foo::&amp;lt;bool&amp;gt;()&lt;/code&gt;, &lt;code&gt;foo::&amp;lt;String&amp;gt;()&lt;/code&gt;, or any other type substitution is different. Hence the compiler generates the implementation on-demand. If you call &lt;code&gt;foo()&lt;/code&gt; with a &lt;code&gt;bool&lt;/code&gt; parameter, the compiler will only generate code for &lt;code&gt;foo::&amp;lt;bool&amp;gt;()&lt;/code&gt;. When we have additional type parameters, the number of monomorphized implementations the compiler generates does not grow drastically, since the compiler will only generate an implementation if the function is called with unparametrized substitutions (i.e., substitutions where none of the substituted types are themselves parameterized).</source>
          <target state="translated">The machine code for &lt;code&gt;foo::&amp;lt;u8&amp;gt;()&lt;/code&gt; , &lt;code&gt;foo::&amp;lt;bool&amp;gt;()&lt;/code&gt; , &lt;code&gt;foo::&amp;lt;String&amp;gt;()&lt;/code&gt; , or any other type substitution is different. Hence the compiler generates the implementation on-demand. If you call &lt;code&gt;foo()&lt;/code&gt; with a &lt;code&gt;bool&lt;/code&gt; parameter, the compiler will only generate code for &lt;code&gt;foo::&amp;lt;bool&amp;gt;()&lt;/code&gt; . When we have additional type parameters, the number of monomorphized implementations the compiler generates does not grow drastically, since the compiler will only generate an implementation if the function is called with unparametrized substitutions (i.e., substitutions where none of the substituted types are themselves parameterized).</target>
        </trans-unit>
        <trans-unit id="9e0846c263b7366386582dfe4d412a3ad4ba7b9f" translate="yes" xml:space="preserve">
          <source>The machine code for &lt;code&gt;foo::&amp;lt;u8&amp;gt;()&lt;/code&gt;, &lt;code&gt;foo::&amp;lt;bool&amp;gt;()&lt;/code&gt;, &lt;code&gt;foo::&amp;lt;String&amp;gt;()&lt;/code&gt;, or any other type substitution is different. Hence the compiler generates the implementation on-demand. If you call &lt;code&gt;foo()&lt;/code&gt; with a &lt;code&gt;bool&lt;/code&gt; parameter, the compiler will only generate code for &lt;code&gt;foo::&amp;lt;bool&amp;gt;()&lt;/code&gt;. When we have additional type parameters, the number of monomorphized implementations the compiler generates does not grow drastically, since the compiler will only generate an implementation if the function is called with unparametrized substitutions (i.e., substitutions where none of the substituted types are themselves parametrized).</source>
          <target state="translated">&lt;code&gt;foo::&amp;lt;u8&amp;gt;()&lt;/code&gt; 、 &lt;code&gt;foo::&amp;lt;bool&amp;gt;()&lt;/code&gt; 、 &lt;code&gt;foo::&amp;lt;String&amp;gt;()&lt;/code&gt; 、またはその他の型置換のマシンコードは異なります。したがって、コンパイラーはオンデマンドで実装を生成します。 &lt;code&gt;bool&lt;/code&gt; パラメータを指定して &lt;code&gt;foo()&lt;/code&gt; を呼び出すと、コンパイラは &lt;code&gt;foo::&amp;lt;bool&amp;gt;()&lt;/code&gt; コードのみを生成します。追加の型パラメーターがある場合、関数がパラメーター化されていない置換（つまり、置換された型のいずれもパラメーター化されていない置換）を使用して呼び出された場合にのみコンパイラーが実装を生成するため、コンパイラーが生成する単形化実装の数は大幅に増加しません。 。</target>
        </trans-unit>
        <trans-unit id="ec5d54a07ee0f8ac568e82f61b376d035a168bca" translate="yes" xml:space="preserve">
          <source>The macro itself will decide how to interpret such a token and whether to produce an error or not.</source>
          <target state="translated">マクロ自体は、そのようなトークンをどのように解釈し、エラーを生成するかどうかを決定します。</target>
        </trans-unit>
        <trans-unit id="8db5958c7dabf9cedcc4db6e6fa16a59d45c2565" translate="yes" xml:space="preserve">
          <source>The macro works by using the &lt;code&gt;Debug&lt;/code&gt; implementation of the type of the given expression to print the value to &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_error_(stderr)&quot;&gt;stderr&lt;/a&gt; along with the source location of the macro invocation as well as the source code of the expression.</source>
          <target state="translated">マクロは、指定された式のタイプの &lt;code&gt;Debug&lt;/code&gt; 実装を使用して、マクロ呼び出しのソースの場所と式のソースコードとともに値を&lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_error_(stderr)&quot;&gt;stderr&lt;/a&gt;に出力することで機能します。</target>
        </trans-unit>
        <trans-unit id="9498e8eb390e83cb5dbd448b585676f4b5c37123" translate="yes" xml:space="preserve">
          <source>The macro wraps any number of static declarations and makes them thread local. Publicity and attributes for each static are allowed. Example:</source>
          <target state="translated">このマクロは、任意の数のスタティック宣言をラップしてスレッドローカルにします。各スタティックのパブリシティとアトリビュートが許可されています。例。</target>
        </trans-unit>
        <trans-unit id="2eb59c956ec6e4722a7e8cfdea3a410b913da22e" translate="yes" xml:space="preserve">
          <source>The main aim of lifetimes is to prevent dangling references, which cause a program to reference data other than the data it&amp;rsquo;s intended to reference. Consider the program in Listing 10-17, which has an outer scope and an inner scope.</source>
          <target state="translated">ライフタイムの主な目的は、プログラムが参照する予定のデータ以外のデータを参照する原因となる参照のダングリングを防ぐことです。リスト10-17のプログラムを考えてください。このプログラムには、外側のスコープと内側のスコープがあります。</target>
        </trans-unit>
        <trans-unit id="c087688652f35bf8ea7f8323996c74d4edfcf197" translate="yes" xml:space="preserve">
          <source>The main benefit of using methods instead of functions, in addition to using method syntax and not having to repeat the type of &lt;code&gt;self&lt;/code&gt; in every method&amp;rsquo;s signature, is for organization. We&amp;rsquo;ve put all the things we can do with an instance of a type in one &lt;code&gt;impl&lt;/code&gt; block rather than making future users of our code search for capabilities of &lt;code&gt;Rectangle&lt;/code&gt; in various places in the library we provide.</source>
          <target state="translated">メソッド構文を使用し、すべてのメソッドのシグネチャで &lt;code&gt;self&lt;/code&gt; のタイプを繰り返す必要がないことに加えて、関数の代わりにメソッドを使用する主な利点は、整理のためです。コードの将来のユーザーに、提供するライブラリのさまざまな場所で &lt;code&gt;Rectangle&lt;/code&gt; の機能を検索させるのではなく、型のインスタンスで実行できるすべてのことを1つの &lt;code&gt;impl&lt;/code&gt; ブロックに入れました。</target>
        </trans-unit>
        <trans-unit id="8008407990a4be341211e8be036085a004b45e43" translate="yes" xml:space="preserve">
          <source>The main error message, &amp;ldquo;mismatched types,&amp;rdquo; reveals the core issue with this code. The definition of the function &lt;code&gt;plus_one&lt;/code&gt; says that it will return an &lt;code&gt;i32&lt;/code&gt;, but statements don&amp;rsquo;t evaluate to a value, which is expressed by &lt;code&gt;()&lt;/code&gt;, an empty tuple. Therefore, nothing is returned, which contradicts the function definition and results in an error. In this output, Rust provides a message to possibly help rectify this issue: it suggests removing the semicolon, which would fix the error.</source>
          <target state="translated">主なエラーメッセージである「型の不一致」は、このコードの中心的な問題を示しています。関数 &lt;code&gt;plus_one&lt;/code&gt; の定義は、それが &lt;code&gt;i32&lt;/code&gt; を返すことを示していますが、ステートメントは、空のタプル &lt;code&gt;()&lt;/code&gt; で表される値に評価されません。したがって、何も返されず、関数定義と矛盾し、エラーが発生します。この出力では、Rustがこの問題の修正に役立つ可能性のあるメッセージを提供しています。エラーを修正するセミコロンを削除することを提案しています。</target>
        </trans-unit>
        <trans-unit id="573ea76510aaa810e82bed4691dcc0e4c2771be9" translate="yes" xml:space="preserve">
          <source>The main place you'll see &lt;code&gt;!&lt;/code&gt; used explicitly is in generic code. Consider the &lt;a href=&quot;str/trait.fromstr&quot;&gt;&lt;code&gt;FromStr&lt;/code&gt;&lt;/a&gt; trait:</source>
          <target state="translated">あなたが見るメインの場所 &lt;code&gt;!&lt;/code&gt; 明示的に使用されるのは一般的なコードです。&lt;a href=&quot;str/trait.fromstr&quot;&gt; &lt;code&gt;FromStr&lt;/code&gt; &lt;/a&gt;トレイトについて考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="3347fce894ee36b7a76776d17f6b05d7ee4e0c6f" translate="yes" xml:space="preserve">
          <source>The main thread will wait for the spawned thread to finish and then run its &lt;code&gt;for&lt;/code&gt; loop, so the output won&amp;rsquo;t be interleaved anymore, as shown here:</source>
          <target state="translated">メインスレッドは、生成されたスレッドが完了するのを待ってから、その &lt;code&gt;for&lt;/code&gt; ループを実行するため、次のように出力がインターリーブされなくなります。</target>
        </trans-unit>
        <trans-unit id="d7af4b9befadab1a133dab8d7948b44dbc8d708d" translate="yes" xml:space="preserve">
          <source>The main thread will wait with a timeout on the condvar and then leave once the boolean has been updated and notified.</source>
          <target state="translated">メインスレッドはコンドバーのタイムアウトで待機し、ブーリアンが更新されて通知されると退出します。</target>
        </trans-unit>
        <trans-unit id="2f4d9785a094ac7050147e12df1b0f82f8cae6fe" translate="yes" xml:space="preserve">
          <source>The main use case for type synonyms is to reduce repetition. For example, we might have a lengthy type like this:</source>
          <target state="translated">型同義語の主な使用例は、繰り返しを減らすことです。例えば、次のような長い型があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="e1aa73c2c8bcfa6f25fb308f2154aee4987ca459" translate="yes" xml:space="preserve">
          <source>The main way to use Boolean values is through conditionals, such as an &lt;code&gt;if&lt;/code&gt; expression. We&amp;rsquo;ll cover how &lt;code&gt;if&lt;/code&gt; expressions work in Rust in the &lt;a href=&quot;ch03-05-control-flow#control-flow&quot;&gt;&amp;ldquo;Control Flow&amp;rdquo;&lt;/a&gt; section.</source>
          <target state="translated">ブール値を使用する主な方法は、 &lt;code&gt;if&lt;/code&gt; 式などの条件を使用することです。私たちはどのように取り上げる &lt;code&gt;if&lt;/code&gt; の式はで錆で働く&lt;a href=&quot;ch03-05-control-flow#control-flow&quot;&gt;「制御フロー」&lt;/a&gt;セクション。</target>
        </trans-unit>
        <trans-unit id="67f97a592dc5c37dc58d2c3fd741d8753b33f60e" translate="yes" xml:space="preserve">
          <source>The mapping to &lt;a href=&quot;../io/enum.errorkind&quot;&gt;&lt;code&gt;ErrorKind&lt;/code&gt;&lt;/a&gt;s is not part of the compatibility contract of the function, especially the &lt;a href=&quot;../io/enum.errorkind#variant.Other&quot;&gt;&lt;code&gt;Other&lt;/code&gt;&lt;/a&gt; kind might change to more specific kinds in the future.</source>
          <target state="translated">&lt;a href=&quot;../io/enum.errorkind&quot;&gt; &lt;code&gt;ErrorKind&lt;/code&gt; &lt;/a&gt;へのマッピングは、関数の互換性規約の一部ではありません。特に、&lt;a href=&quot;../io/enum.errorkind#variant.Other&quot;&gt; &lt;code&gt;Other&lt;/code&gt; &lt;/a&gt;種類は、将来、より具体的な種類に変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="f8fda3a6ce0d45625dd9cd044a1a98a742c97014" translate="yes" xml:space="preserve">
          <source>The match condition states that the arm only matches if the value of &lt;code&gt;x&lt;/code&gt; is equal to &lt;code&gt;4&lt;/code&gt;, &lt;code&gt;5&lt;/code&gt;, or &lt;code&gt;6&lt;/code&gt;&lt;em&gt;and&lt;/em&gt; if &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. When this code runs, the pattern of the first arm matches because &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;4&lt;/code&gt;, but the match guard &lt;code&gt;if y&lt;/code&gt; is false, so the first arm is not chosen. The code moves on to the second arm, which does match, and this program prints &lt;code&gt;no&lt;/code&gt;. The reason is that the &lt;code&gt;if&lt;/code&gt; condition applies to the whole pattern &lt;code&gt;4 | 5 | 6&lt;/code&gt;, not only to the last value &lt;code&gt;6&lt;/code&gt;. In other words, the precedence of a match guard in relation to a pattern behaves like this:</source>
          <target state="translated">アームのみの値場合に一致することを一致条件状態 &lt;code&gt;x&lt;/code&gt; がに等しい &lt;code&gt;4&lt;/code&gt; 、 &lt;code&gt;5&lt;/code&gt; 、または &lt;code&gt;6&lt;/code&gt; &lt;em&gt;及び&lt;/em&gt;場合 &lt;code&gt;y&lt;/code&gt; である &lt;code&gt;true&lt;/code&gt; 。このコードを実行すると、 &lt;code&gt;x&lt;/code&gt; が &lt;code&gt;4&lt;/code&gt; であるため最初のアームのパターンは一致しますが、 &lt;code&gt;if y&lt;/code&gt; がfalseの場合は一致ガードなので、最初のアームは選択されません。コードは一致する2番目のアームに移動し、このプログラムは &lt;code&gt;no&lt;/code&gt; を出力します。その理由は、 &lt;code&gt;if&lt;/code&gt; 条件がパターン &lt;code&gt;4 | 5 | 6&lt;/code&gt; 全体に適用されるためです。5 | 6、最後の値だけでなく &lt;code&gt;6&lt;/code&gt; 。つまり、パターンに対するマッチガードの優先順位は次のようになります。</target>
        </trans-unit>
        <trans-unit id="6477b3c15cf1efd2f96aba3a277d7e0dd00d128c" translate="yes" xml:space="preserve">
          <source>The match guard &lt;code&gt;if n == y&lt;/code&gt; is not a pattern and therefore doesn&amp;rsquo;t introduce new variables. This &lt;code&gt;y&lt;/code&gt;&lt;em&gt;is&lt;/em&gt; the outer &lt;code&gt;y&lt;/code&gt; rather than a new shadowed &lt;code&gt;y&lt;/code&gt;, and we can look for a value that has the same value as the outer &lt;code&gt;y&lt;/code&gt; by comparing &lt;code&gt;n&lt;/code&gt; to &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;if n == y&lt;/code&gt; のマッチガードはパターンではないため、新しい変数は導入されません。この &lt;code&gt;y&lt;/code&gt; が&lt;em&gt;あり&lt;/em&gt;、外側 &lt;code&gt;y&lt;/code&gt; のではなく、新たな影 &lt;code&gt;y&lt;/code&gt; 、我々は外と同じ値を持つ値を探すことができ &lt;code&gt;y&lt;/code&gt; 比較することにより、 &lt;code&gt;n&lt;/code&gt; 個をする &lt;code&gt;y&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0a68bad7489889370013d2c1b380ae26eafd0a34" translate="yes" xml:space="preserve">
          <source>The matched value was assigned in a match guard.</source>
          <target state="translated">マッチした値がマッチガードで割り当てられていました。</target>
        </trans-unit>
        <trans-unit id="da4a7cee97aca95b9c65ea2bcda5404ae104d4f6" translate="yes" xml:space="preserve">
          <source>The maximum duration.</source>
          <target state="translated">最大持続時間。</target>
        </trans-unit>
        <trans-unit id="639334ee92fbc7d55384c7ec82527ac8487a080f" translate="yes" xml:space="preserve">
          <source>The maximum value of an enum was reached, so it cannot be automatically set in the next enum value.</source>
          <target state="translated">列挙型の最大値に達したため、次の列挙型の値に自動的に設定することはできません。</target>
        </trans-unit>
        <trans-unit id="444f3162cb088de418eba38f4a421be7235eea6f" translate="yes" xml:space="preserve">
          <source>The maximum value of an enum was reached, so it cannot be automatically set in the next enum value. Erroneous code example:</source>
          <target state="translated">列挙型の最大値に達したため、次の列挙型の値に自動的に設定することはできません。誤ったコード例。</target>
        </trans-unit>
        <trans-unit id="69d28668979329993270aea55163f780c2136684" translate="yes" xml:space="preserve">
          <source>The memory allocator returned an error</source>
          <target state="translated">メモリアロケータはエラーを返しました。</target>
        </trans-unit>
        <trans-unit id="f691ffd885b1cdd7c3aced4e660ea6b5f2bc5114" translate="yes" xml:space="preserve">
          <source>The memory at &lt;code&gt;buf&lt;/code&gt; needs to have been previously allocated by the same allocator the standard library uses, with a required alignment of exactly 1.</source>
          <target state="translated">The memory at &lt;code&gt;buf&lt;/code&gt; needs to have been previously allocated by the same allocator the standard library uses, with a required alignment of exactly 1.</target>
        </trans-unit>
        <trans-unit id="297bebe1d80f3b348c7c8e6094a67afc0f518766" translate="yes" xml:space="preserve">
          <source>The memory at &lt;code&gt;ptr&lt;/code&gt; needs to have been previously allocated by the same allocator the standard library uses.</source>
          <target state="translated">&lt;code&gt;ptr&lt;/code&gt; のメモリは、標準ライブラリが使用するのと同じアロケータによって事前に割り当てられている必要があります。</target>
        </trans-unit>
        <trans-unit id="533d683a4cce37c267e983c916aea2694b115c42" translate="yes" xml:space="preserve">
          <source>The memory block will contain the following contents after a successful call to &lt;code&gt;grow_zeroed&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;grow_zeroed&lt;/code&gt; の呼び出しが成功すると、メモリブロックには次の内容が含まれます。</target>
        </trans-unit>
        <trans-unit id="9f4c6be6867180c56169b0ceb625f117dffee9cb" translate="yes" xml:space="preserve">
          <source>The memory layout of a &lt;code&gt;struct&lt;/code&gt; is undefined by default to allow for compiler optimizations like field reordering, but it can be fixed with the &lt;a href=&quot;../type-layout#representations&quot;&gt;&lt;code&gt;repr&lt;/code&gt; attribute&lt;/a&gt;. In either case, fields may be given in any order in a corresponding struct &lt;em&gt;expression&lt;/em&gt;; the resulting &lt;code&gt;struct&lt;/code&gt; value will always have the same memory layout.</source>
          <target state="translated">&lt;code&gt;struct&lt;/code&gt; のメモリレイアウトは、フィールドの並べ替えなどのコンパイラの最適化を考慮して、デフォルトでは定義されていませんが、&lt;a href=&quot;../type-layout#representations&quot;&gt; &lt;code&gt;repr&lt;/code&gt; 属性で&lt;/a&gt;修正できます。どちらの場合でも、フィールドは対応する構造体&lt;em&gt;式&lt;/em&gt;で任意の順序で指定できます。結果の &lt;code&gt;struct&lt;/code&gt; 値は常に同じメモリレイアウトになります。</target>
        </trans-unit>
        <trans-unit id="613a15d193cb4b5b9d7d2448a0d26f441bad60d3" translate="yes" xml:space="preserve">
          <source>The memory layout of a &lt;code&gt;union&lt;/code&gt; is undefined by default, but the &lt;code&gt;#[repr(...)]&lt;/code&gt; attribute can be used to fix a layout.</source>
          <target state="translated">&lt;code&gt;union&lt;/code&gt; のメモリレイアウトはデフォルトでは定義されていませんが、 &lt;code&gt;#[repr(...)]&lt;/code&gt; 属性を使用してレイアウトを修正できます。</target>
        </trans-unit>
        <trans-unit id="62988640c5b4ea3199910497b4399a06d9aa4bb8" translate="yes" xml:space="preserve">
          <source>The memory must be requested from the memory allocator at runtime.</source>
          <target state="translated">実行時にメモリをメモリアロケータに要求する必要があります。</target>
        </trans-unit>
        <trans-unit id="5158117ae58dde222908d602ad3b6cfbc19fbd1b" translate="yes" xml:space="preserve">
          <source>The memory must be requested from the operating system at runtime.</source>
          <target state="translated">実行時にオペレーティングシステムからメモリを要求する必要があります。</target>
        </trans-unit>
        <trans-unit id="5fb7e987a9654eee8114bb60b92e8b3cf5d47151" translate="yes" xml:space="preserve">
          <source>The memory referenced by the returned slice must not be accessed through any other pointer (not derived from the return value) for the duration of lifetime &lt;code&gt;'a&lt;/code&gt;. Both read and write accesses are forbidden.</source>
          <target state="translated">The memory referenced by the returned slice must not be accessed through any other pointer (not derived from the return value) for the duration of lifetime &lt;code&gt;'a&lt;/code&gt; . Both read and write accesses are forbidden.</target>
        </trans-unit>
        <trans-unit id="ff115e1f60568ae547418e535b08f2a38631c573" translate="yes" xml:space="preserve">
          <source>The memory referenced by the returned slice must not be mutated for the duration of lifetime &lt;code&gt;'a&lt;/code&gt;, except inside an &lt;code&gt;UnsafeCell&lt;/code&gt;.</source>
          <target state="translated">The memory referenced by the returned slice must not be mutated for the duration of lifetime &lt;code&gt;'a&lt;/code&gt; , except inside an &lt;code&gt;UnsafeCell&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6139b94477b7472bd857c001d753b72d8df9f27e" translate="yes" xml:space="preserve">
          <source>The message can be of any (&lt;code&gt;Any + Send&lt;/code&gt;) type, not just strings.</source>
          <target state="translated">メッセージは、文字列だけでなく、任意の（ &lt;code&gt;Any + Send&lt;/code&gt; ）タイプにすることができます。</target>
        </trans-unit>
        <trans-unit id="3d782721b766f719dd5b6d817f0d6bb437eb7d6a" translate="yes" xml:space="preserve">
          <source>The message is wrapped in a &lt;code&gt;Box&amp;lt;'static + Any + Send&amp;gt;&lt;/code&gt;, which can be accessed later using &lt;a href=&quot;struct.panicinfo#method.payload&quot;&gt;&lt;code&gt;PanicInfo::payload&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">メッセージは &lt;code&gt;Box&amp;lt;'static + Any + Send&amp;gt;&lt;/code&gt; でラップされ、後で&lt;a href=&quot;struct.panicinfo#method.payload&quot;&gt; &lt;code&gt;PanicInfo::payload&lt;/code&gt; &lt;/a&gt;を使用してアクセスできます。</target>
        </trans-unit>
        <trans-unit id="c86a2a43ba3e98f03e1d643c5eb2cb7bce34d7c4" translate="yes" xml:space="preserve">
          <source>The method does no guarding against overflows, so counting elements of an iterator with more than &lt;a href=&quot;../usize/constant.max&quot;&gt;&lt;code&gt;usize::MAX&lt;/code&gt;&lt;/a&gt; elements either produces the wrong result or panics. If debug assertions are enabled, a panic is guaranteed.</source>
          <target state="translated">このメソッドはオーバーフローに対する保護を行わないため、&lt;a href=&quot;../usize/constant.max&quot;&gt; &lt;code&gt;usize::MAX&lt;/code&gt; &lt;/a&gt;要素を超えるイテレータの要素をカウントすると、誤った結果またはパニックが発生します。デバッグアサーションが有効になっている場合、パニックが保証されます。</target>
        </trans-unit>
        <trans-unit id="177a5c2ea6344ea77e9ae3a6db8fc74469cc253c" translate="yes" xml:space="preserve">
          <source>The method does no guarding against overflows, so enumerating more than &lt;a href=&quot;../usize/constant.max&quot;&gt;&lt;code&gt;usize::MAX&lt;/code&gt;&lt;/a&gt; elements either produces the wrong result or panics. If debug assertions are enabled, a panic is guaranteed.</source>
          <target state="translated">このメソッドはオーバーフローに対する保護を行わないため、&lt;a href=&quot;../usize/constant.max&quot;&gt; &lt;code&gt;usize::MAX&lt;/code&gt; &lt;/a&gt;要素以上を列挙すると、誤った結果またはパニックが発生します。デバッグアサーションが有効になっている場合、パニックが保証されます。</target>
        </trans-unit>
        <trans-unit id="3a1826392947e9b9a700c20663562183cfe20bf1" translate="yes" xml:space="preserve">
          <source>The method does no guarding against overflows, so enumerating more than &lt;code&gt;usize::MAX&lt;/code&gt; elements either produces the wrong result or panics. If debug assertions are enabled, a panic is guaranteed.</source>
          <target state="translated">このメソッドはオーバーフローに対する保護を行わないため、 &lt;code&gt;usize::MAX&lt;/code&gt; 要素以上を列挙すると、誤った結果またはパニックが発生します。デバッグアサーションが有効になっている場合、パニックが保証されます。</target>
        </trans-unit>
        <trans-unit id="19d8816b84fe470f79cf77755eeb8ee64e555da5" translate="yes" xml:space="preserve">
          <source>The method does no guarding against overflows, so if there are more than &lt;a href=&quot;../usize/constant.max&quot;&gt;&lt;code&gt;usize::MAX&lt;/code&gt;&lt;/a&gt; non-matching elements, it either produces the wrong result or panics. If debug assertions are enabled, a panic is guaranteed.</source>
          <target state="translated">このメソッドはオーバーフローに対する保護を行わないため、&lt;a href=&quot;../usize/constant.max&quot;&gt; &lt;code&gt;usize::MAX&lt;/code&gt; &lt;/a&gt;以外の一致しない要素がある場合、誤った結果が発生するか、パニックが発生します。デバッグアサーションが有効になっている場合、パニックが保証されます。</target>
        </trans-unit>
        <trans-unit id="1be550addda456adee08f228dc9b4f31db12dda4" translate="yes" xml:space="preserve">
          <source>The method will panic if the given step is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">指定されたステップが &lt;code&gt;0&lt;/code&gt; の場合、メソッドはパニックになります。</target>
        </trans-unit>
        <trans-unit id="18a6ab41791924ffc3860ab7c005689a5ace692a" translate="yes" xml:space="preserve">
          <source>The minimum alignment of a type.</source>
          <target state="translated">型の最小整列。</target>
        </trans-unit>
        <trans-unit id="d61a28fc808f2bb8277ab6d2dda14e2b5dc3214d" translate="yes" xml:space="preserve">
          <source>The minimum byte alignment for a memory block of this layout.</source>
          <target state="translated">このレイアウトのメモリブロックの最小バイトアライメント。</target>
        </trans-unit>
        <trans-unit id="e621ea6ab30e14c7bfa77e4fee05fb852bfe464d" translate="yes" xml:space="preserve">
          <source>The minimum duration.</source>
          <target state="translated">最低限の持続時間。</target>
        </trans-unit>
        <trans-unit id="5b04e5eee8d92581fabe61b454bd932d16d3b4ee" translate="yes" xml:space="preserve">
          <source>The minimum size in bytes for a memory block of this layout.</source>
          <target state="translated">このレイアウトのメモリ・ブロックの最小サイズをバイト単位で指定します。</target>
        </trans-unit>
        <trans-unit id="4650b1470ff8fe4b9a6a554cb10a84ba4229b041" translate="yes" xml:space="preserve">
          <source>The mirror use case of FFI is also done via the &lt;code&gt;extern&lt;/code&gt; keyword:</source>
          <target state="translated">FFIのミラーの使用例も、 &lt;code&gt;extern&lt;/code&gt; キーワードを介して行われます。</target>
        </trans-unit>
        <trans-unit id="a82559d5a04edc93a72fe140de851778ee358fc2" translate="yes" xml:space="preserve">
          <source>The module tree might remind you of the filesystem&amp;rsquo;s directory tree on your computer; this is a very apt comparison! Just like directories in a filesystem, you use modules to organize your code. And just like files in a directory, we need a way to find our modules.</source>
          <target state="translated">モジュールツリーは、コンピュータ上のファイルシステムのディレクトリツリーを思い出させるかもしれません。これは非常に適切な比較です！ファイルシステムのディレクトリのように、モジュールを使用してコードを整理します。ディレクトリ内のファイルと同じように、モジュールを見つける方法が必要です。</target>
        </trans-unit>
        <trans-unit id="ea4c9b3e2b6f858a3799aa18909b3e42f1061d3e" translate="yes" xml:space="preserve">
          <source>The module tree remains the same, and the function calls in &lt;code&gt;eat_at_restaurant&lt;/code&gt; will work without any modification, even though the definitions live in different files. This technique lets you move modules to new files as they grow in size.</source>
          <target state="translated">モジュールツリーは同じままで、定義が別のファイルにある場合でも、 &lt;code&gt;eat_at_restaurant&lt;/code&gt; の関数呼び出しは変更なしで機能します。この手法では、モジュールのサイズが大きくなるにつれて、モジュールを新しいファイルに移動できます。</target>
        </trans-unit>
        <trans-unit id="fb5cf295cab45b30e8f8d196e49ec369e86db99a" translate="yes" xml:space="preserve">
          <source>The monomorphized version of the code looks like the following. The generic &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; is replaced with the specific definitions created by the compiler:</source>
          <target state="translated">コードのモノモーフィングバージョンは次のようになります。一般的な &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; は、コンパイラーによって作成された特定の定義に置き換えられます。</target>
        </trans-unit>
        <trans-unit id="75cf509b67ca81925881254de671f6530c684e13" translate="yes" xml:space="preserve">
          <source>The more common inherited mutability, where one must have unique access to mutate a value, is one of the key language elements that enables Rust to reason strongly about pointer aliasing, statically preventing crash bugs. Because of that, inherited mutability is preferred, and interior mutability is something of a last resort. Since cell types enable mutation where it would otherwise be disallowed though, there are occasions when interior mutability might be appropriate, or even &lt;em&gt;must&lt;/em&gt; be used, e.g.</source>
          <target state="translated">値を変更するために一意のアクセスが必要な、より一般的な継承された可変性は、Rustがポインタのエイリアスについて強く推論できるようにする主要な言語要素の1つであり、クラッシュバグを静的に防止します。そのため、継承された可変性が優先され、内部の可変性は最後の手段の1つです。細胞型によって突然変異が可能になりますが、そうでなければ許可されないため、内部の突然変異性が適切な場合や、使用する&lt;em&gt;必要&lt;/em&gt;がある場合も&lt;em&gt;あり&lt;/em&gt;ます。たとえば、</target>
        </trans-unit>
        <trans-unit id="22b87181f4af9bcd4494ede540e86fdd7af786b7" translate="yes" xml:space="preserve">
          <source>The most basic pattern in which &lt;code&gt;collect()&lt;/code&gt; is used is to turn one collection into another. You take a collection, call &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; on it, do a bunch of transformations, and then &lt;code&gt;collect()&lt;/code&gt; at the end.</source>
          <target state="translated">&lt;code&gt;collect()&lt;/code&gt; が使用される最も基本的なパターンは、あるコレクションを別のコレクションに変換することです。コレクションを取得し、それに対して&lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;iter&lt;/code&gt; &lt;/a&gt;を呼び出し、一連の変換を実行してから、最後に &lt;code&gt;collect()&lt;/code&gt; を実行します。</target>
        </trans-unit>
        <trans-unit id="8acfa5660545764d445a8a9080882c9972414cad" translate="yes" xml:space="preserve">
          <source>The most basic usage of the keyword is &lt;code&gt;use path::to::item;&lt;/code&gt;, though a number of convenient shortcuts are supported:</source>
          <target state="translated">The most basic usage of the keyword is &lt;code&gt;use path::to::item;&lt;/code&gt; , though a number of convenient shortcuts are supported:</target>
        </trans-unit>
        <trans-unit id="524cfe2dc48693915271c90c3e4b7d15d2163d53" translate="yes" xml:space="preserve">
          <source>The most likely source of this error is using angle-bracket notation without wrapping the function argument type into a tuple, for example:</source>
          <target state="translated">このエラーの最も可能性の高い原因は、例えば関数の引数型をタプルにラップせずに角度ブラケット記法を使用していることです。</target>
        </trans-unit>
        <trans-unit id="f1fae4bef53f01c296ad8cf52cd2f776bcb2545a" translate="yes" xml:space="preserve">
          <source>The most straightforward smart pointer is a &lt;em&gt;box&lt;/em&gt;, whose type is written &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;. Boxes allow you to store data on the heap rather than the stack. What remains on the stack is the pointer to the heap data. Refer to Chapter 4 to review the difference between the stack and the heap.</source>
          <target state="translated">最も簡単なスマートポインタは&lt;em&gt;ボックスで&lt;/em&gt;、その型は &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; と書かれています。ボックスを使用すると、スタックではなくヒープにデータを格納できます。スタックに残っているのは、ヒープデータへのポインタです。スタックとヒープの違いを確認するには、第4章を参照してください。</target>
        </trans-unit>
        <trans-unit id="c84503d5e594d47f23b7b930df844dc25ee59200" translate="yes" xml:space="preserve">
          <source>The most surprising behavior occurs when &quot;the same&quot; file is reachable via multiple paths in the module system (usually using the &lt;code&gt;#[path = &quot;...&quot;]&lt;/code&gt; attribute or similar), which can cause what appears to be identical code to return differing values from this function.</source>
          <target state="translated">The most surprising behavior occurs when &quot;the same&quot; file is reachable via multiple paths in the module system (usually using the &lt;code&gt;#[path = &quot;...&quot;]&lt;/code&gt; attribute or similar), which can cause what appears to be identical code to return differing values from this function.</target>
        </trans-unit>
        <trans-unit id="224b0446b4293b35c3feb8b386382ff2882bd862" translate="yes" xml:space="preserve">
          <source>The most widely used form of macros in Rust is &lt;em&gt;declarative macros&lt;/em&gt;. These are also sometimes referred to as &amp;ldquo;macros by example,&amp;rdquo; &amp;ldquo;&lt;code&gt;macro_rules!&lt;/code&gt; macros,&amp;rdquo; or just plain &amp;ldquo;macros.&amp;rdquo; At their core, declarative macros allow you to write something similar to a Rust &lt;code&gt;match&lt;/code&gt; expression. As discussed in Chapter 6, &lt;code&gt;match&lt;/code&gt; expressions are control structures that take an expression, compare the resulting value of the expression to patterns, and then run the code associated with the matching pattern. Macros also compare a value to patterns that are associated with particular code: in this situation, the value is the literal Rust source code passed to the macro; the patterns are compared with the structure of that source code; and the code associated with each pattern, when matched, replaces the code passed to the macro. This all happens during compilation.</source>
          <target state="translated">Rustで最も広く使用されているマクロの形式は&lt;em&gt;宣言型マクロ&lt;/em&gt;です。これらは「 &lt;code&gt;macro_rules!&lt;/code&gt; マクロ」、「macro_rules！」とも呼ばれます。マクロ」または単なる「マクロ」です。基本的に、宣言型マクロを使用すると、Rustの &lt;code&gt;match&lt;/code&gt; 式に似たものを記述できます。第6章で説明したように、 &lt;code&gt;match&lt;/code&gt; 式は、式を取り、式の結果の値をパターンと比較し、一致するパターンに関連付けられたコードを実行する制御構造です。マクロはまた、特定のコードに関連付けられているパターンと値を比較します。この状況では、値はマクロに渡されるリテラルRustソースコードです。パターンはそのソースコードの構造と比較されます。各パターンに関連付けられたコードは、一致すると、マクロに渡されたコードを置き換えます。これはすべてコンパイル中に発生します。</target>
        </trans-unit>
        <trans-unit id="5c8119cbdd49364e9c5037e1b8a03abc1bccdb46" translate="yes" xml:space="preserve">
          <source>The motivation for this design is twofold:</source>
          <target state="translated">このデザインの動機は2つあります。</target>
        </trans-unit>
        <trans-unit id="6fd4e131dbce656fa77aa6dbacb12fee04853072" translate="yes" xml:space="preserve">
          <source>The multi-argument form of this macro panics with a string and has the &lt;a href=&quot;macro.format&quot;&gt;&lt;code&gt;format!&lt;/code&gt;&lt;/a&gt; syntax for building a string.</source>
          <target state="translated">このマクロの複数引数形式は文字列でパニックを起こし、&lt;a href=&quot;macro.format&quot;&gt; &lt;code&gt;format!&lt;/code&gt; &lt;/a&gt;を持っています！文字列を構築するための構文。</target>
        </trans-unit>
        <trans-unit id="ff7a3f839c4dac34de65c2bfcbc13d6c2f460e6c" translate="yes" xml:space="preserve">
          <source>The multiplication assignment operator &lt;code&gt;*=&lt;/code&gt;.</source>
          <target state="translated">乗算代入演算子 &lt;code&gt;*=&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="945e202ccc3f817f464a16a52710aeff055613cc" translate="yes" xml:space="preserve">
          <source>The multiplication operator &lt;code&gt;*&lt;/code&gt;.</source>
          <target state="translated">乗算演算子 &lt;code&gt;*&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="395bf55779b3f4b37031c67eb2f13567f6e766a4" translate="yes" xml:space="preserve">
          <source>The mutability of a pointer does not change its size. As such, &lt;code&gt;&amp;amp;T&lt;/code&gt; and &lt;code&gt;&amp;amp;mut T&lt;/code&gt; have the same size. Likewise for &lt;code&gt;*const T&lt;/code&gt; and &lt;code&gt;*mut T&lt;/code&gt;.</source>
          <target state="translated">ポインターの可変性は、そのサイズを変更しません。そのため、 &lt;code&gt;&amp;amp;T&lt;/code&gt; と &lt;code&gt;&amp;amp;mut T&lt;/code&gt; のサイズは同じです。 &lt;code&gt;*const T&lt;/code&gt; および &lt;code&gt;*mut T&lt;/code&gt; についても同様です。</target>
        </trans-unit>
        <trans-unit id="f42a8b27f0c72155ef0f3b14d7be6cafaaf62841" translate="yes" xml:space="preserve">
          <source>The mutable slice yields mutable references to the elements:</source>
          <target state="translated">変形可能なスライスは、要素への変形可能な参照を生成します。</target>
        </trans-unit>
        <trans-unit id="3c3cbd1ab17a10688ead5cf4d56f2dfc9e512608" translate="yes" xml:space="preserve">
          <source>The mutexes in this module implement a strategy called &quot;poisoning&quot; where a mutex is considered poisoned whenever a thread panics while holding the mutex. Once a mutex is poisoned, all other threads are unable to access the data by default as it is likely tainted (some invariant is not being upheld).</source>
          <target state="translated">このモジュールのミューテックスは「ポイズニング」と呼ばれる戦略を実装しており、ミューテックスを保持している間にスレッドがパニックになると、いつでもミューテックスがポイズニングされているとみなされます。いったんミューテックスがポイズニングされると、他のすべてのスレッドはデータが汚染されている可能性が高いので、デフォルトではデータにアクセスすることができません(何らかの不変量が保持されていない)。</target>
        </trans-unit>
        <trans-unit id="d8b50303b0747d7e3abc95898503b5bde7711980" translate="yes" xml:space="preserve">
          <source>The name chosen for an external crate conflicts with another external crate that has been imported into the current module.</source>
          <target state="translated">外部クレートに選択された名前が、現在のモジュールにインポートされた別の外部クレートと競合します。</target>
        </trans-unit>
        <trans-unit id="d94375d609f70bc0ddb2da1f070fd5b681c30cc1" translate="yes" xml:space="preserve">
          <source>The name for an item declaration conflicts with an external crate's name.</source>
          <target state="translated">アイテム宣言の名前が外部の木箱の名前と競合します。</target>
        </trans-unit>
        <trans-unit id="286d59804da04e407ec36eb2be39e9e0c7ff3343" translate="yes" xml:space="preserve">
          <source>The name must not contain null bytes (&lt;code&gt;\0&lt;/code&gt;).</source>
          <target state="translated">名前にnullバイト（ &lt;code&gt;\0&lt;/code&gt; ）を含めることはできません。</target>
        </trans-unit>
        <trans-unit id="6584162ced4a99e7d4548e6dfca0a1b5adbdbd8e" translate="yes" xml:space="preserve">
          <source>The need for synchronization</source>
          <target state="translated">同期化の必要性</target>
        </trans-unit>
        <trans-unit id="9491a60a88ee503552e1418886a35e38dd1f594f" translate="yes" xml:space="preserve">
          <source>The need for this type arises from the fact that:</source>
          <target state="translated">このタイプの必要性は、その事実から生じる。</target>
        </trans-unit>
        <trans-unit id="3e795b9b16f895fca00c98b1df11fc0d63c7301f" translate="yes" xml:space="preserve">
          <source>The network operation failed because it was not connected yet.</source>
          <target state="translated">まだ接続されていないため、ネットワーク操作に失敗しました。</target>
        </trans-unit>
        <trans-unit id="7c5a2cc50c7976456054417007ed08f73bfd9e80" translate="yes" xml:space="preserve">
          <source>The never type &lt;code&gt;!&lt;/code&gt; is a type with no values, representing the result of computations that never complete. Expressions of type &lt;code&gt;!&lt;/code&gt; can be coerced into any other type.</source>
          <target state="translated">決してタイプしない &lt;code&gt;!&lt;/code&gt; 値のない型で、完了しない計算の結果を表します。タイプの表現 &lt;code&gt;!&lt;/code&gt; 他のタイプに強制することができます。</target>
        </trans-unit>
        <trans-unit id="2876200ee40ea0a4251130e3bb42070db01f59e5" translate="yes" xml:space="preserve">
          <source>The never type is useful with the &lt;code&gt;panic!&lt;/code&gt; macro as well. Remember the &lt;code&gt;unwrap&lt;/code&gt; function that we call on &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; values to produce a value or panic? Here is its definition:</source>
          <target state="translated">neverタイプは &lt;code&gt;panic!&lt;/code&gt; 役立ちます！マクロも。値またはパニックを生成するために &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 値で呼び出す &lt;code&gt;unwrap&lt;/code&gt; 関数を覚えていますか？以下がその定義です。</target>
        </trans-unit>
        <trans-unit id="56b6326e5da7a2c1bad08c52fe9675cb30d6fc5f" translate="yes" xml:space="preserve">
          <source>The new test for the case-&lt;em&gt;insensitive&lt;/em&gt; search uses &lt;code&gt;&quot;rUsT&quot;&lt;/code&gt; as its query. In the &lt;code&gt;search_case_insensitive&lt;/code&gt; function we&amp;rsquo;re about to add, the query &lt;code&gt;&quot;rUsT&quot;&lt;/code&gt; should match the line containing &lt;code&gt;&quot;Rust:&quot;&lt;/code&gt; with a capital R and match the line &lt;code&gt;&quot;Trust me.&quot;&lt;/code&gt; even though both have different casing from the query. This is our failing test, and it will fail to compile because we haven&amp;rsquo;t yet defined the &lt;code&gt;search_case_insensitive&lt;/code&gt; function. Feel free to add a skeleton implementation that always returns an empty vector, similar to the way we did for the &lt;code&gt;search&lt;/code&gt; function in Listing 12-16 to see the test compile and fail.</source>
          <target state="translated">大文字と&lt;em&gt;小文字を区別しない&lt;/em&gt;検索の新しいテストでは、クエリとして &lt;code&gt;&quot;rUsT&quot;&lt;/code&gt; を使用します。追加する &lt;code&gt;search_case_insensitive&lt;/code&gt; 関数では、クエリ &lt;code&gt;&quot;rUsT&quot;&lt;/code&gt; は &lt;code&gt;&quot;Rust:&quot;&lt;/code&gt; を含む行と大文字のRを一致させ、 &lt;code&gt;&quot;Trust me.&quot;&lt;/code&gt; を一致させる必要があります。どちらもクエリとは大文字と小文字が異なります。これは失敗したテストであり、まだ &lt;code&gt;search_case_insensitive&lt;/code&gt; 関数を定義していないため、コンパイルに失敗します。リスト12-16の &lt;code&gt;search&lt;/code&gt; 関数でテストのコンパイルと失敗を確認する方法と同様に、常に空のベクトルを返すスケルトン実装を自由に追加してください。</target>
        </trans-unit>
        <trans-unit id="9a3696a40107bd6d0870f3607ce5d6e5073b6d6b" translate="yes" xml:space="preserve">
          <source>The newtype pattern is useful for tasks beyond those we&amp;rsquo;ve discussed so far, including statically enforcing that values are never confused and indicating the units of a value. You saw an example of using newtypes to indicate units in Listing 19-15: recall that the &lt;code&gt;Millimeters&lt;/code&gt; and &lt;code&gt;Meters&lt;/code&gt; structs wrapped &lt;code&gt;u32&lt;/code&gt; values in a newtype. If we wrote a function with a parameter of type &lt;code&gt;Millimeters&lt;/code&gt;, we couldn&amp;rsquo;t compile a program that accidentally tried to call that function with a value of type &lt;code&gt;Meters&lt;/code&gt; or a plain &lt;code&gt;u32&lt;/code&gt;.</source>
          <target state="translated">newtypeパターンは、値が混乱しないように静的に適用したり、値の単位を示したりするなど、これまでに説明したタスク以外のタスクに役立ちます。リスト19-15でnewtypesを使って単位を示す例を見ました： &lt;code&gt;Millimeters&lt;/code&gt; and &lt;code&gt;Meters&lt;/code&gt; structsがラップされた &lt;code&gt;u32&lt;/code&gt; 値をnewtypeで思い出したことを思い出してください。タイプ &lt;code&gt;Millimeters&lt;/code&gt; のパラメータを使用して関数を記述した場合、誤ってその関数を &lt;code&gt;Meters&lt;/code&gt; タイプの値または単純な &lt;code&gt;u32&lt;/code&gt; で呼び出そうとしたプログラムをコンパイルできませんでした。</target>
        </trans-unit>
        <trans-unit id="b591edfc8b3d018e277499297a4856c76a36dc2a" translate="yes" xml:space="preserve">
          <source>The next four lines set the configuration information Cargo needs to compile your program: the name, the version, who wrote it, and the edition of Rust to use. Cargo gets your name and email information from your environment, so if that information is not correct, fix the information now and then save the file. We&amp;rsquo;ll talk about the &lt;code&gt;edition&lt;/code&gt; key in Appendix E.</source>
          <target state="translated">次の4行は、Cargoがプログラムをコンパイルするために必要な構成情報を設定します。名前、バージョン、作成者、および使用するRustのエディションです。 Cargoは環境から名前と電子メール情報を取得するため、その情報が正しくない場合は、ここで情報を修正してからファイルを保存します。付録Eで &lt;code&gt;edition&lt;/code&gt; キーについて説明します。</target>
        </trans-unit>
        <trans-unit id="6a7a2603b03740bcea191aea3d000fd9f48ffbb9" translate="yes" xml:space="preserve">
          <source>The next logical question is which style you should choose in your own code and why: the original implementation in Listing 13-28 or the version using iterators in Listing 13-29. Most Rust programmers prefer to use the iterator style. It&amp;rsquo;s a bit tougher to get the hang of at first, but once you get a feel for the various iterator adaptors and what they do, iterators can be easier to understand. Instead of fiddling with the various bits of looping and building new vectors, the code focuses on the high-level objective of the loop. This abstracts away some of the commonplace code so it&amp;rsquo;s easier to see the concepts that are unique to this code, such as the filtering condition each element in the iterator must pass.</source>
          <target state="translated">次の論理的な質問は、独自のコードで選択するスタイルとその理由です。リスト13-28の元の実装、またはリスト13-29の反復子を使用するバージョン。ほとんどのRustプログラマは、イテレータスタイルを使用することを好みます。最初はコツをつかむのは少し難しいですが、さまざまなイテレータアダプタとその機能を理解すると、イテレータが理解しやすくなります。ループのさまざまなビットをいじって新しいベクトルを構築する代わりに、コードはループの高レベルの目的に焦点を合わせています。これにより、一般的なコードの一部が抽象化されるため、イテレータの各要素が渡す必要のあるフィルタリング条件など、このコードに固有の概念が見やすくなります。</target>
        </trans-unit>
        <trans-unit id="57f6548988daa34617ffdf2e9ca86d7e443df79f" translate="yes" xml:space="preserve">
          <source>The next note line tells us that we can set the &lt;code&gt;RUST_BACKTRACE&lt;/code&gt; environment variable to get a backtrace of exactly what happened to cause the error. A &lt;em&gt;backtrace&lt;/em&gt; is a list of all the functions that have been called to get to this point. Backtraces in Rust work as they do in other languages: the key to reading the backtrace is to start from the top and read until you see files you wrote. That&amp;rsquo;s the spot where the problem originated. The lines above the lines mentioning your files are code that your code called; the lines below are code that called your code. These lines might include core Rust code, standard library code, or crates that you&amp;rsquo;re using. Let&amp;rsquo;s try getting a backtrace by setting the &lt;code&gt;RUST_BACKTRACE&lt;/code&gt; environment variable to any value except 0. Listing 9-2 shows output similar to what you&amp;rsquo;ll see.</source>
          <target state="translated">次のメモ行は、 &lt;code&gt;RUST_BACKTRACE&lt;/code&gt; 環境変数を設定して、エラーの原因となった正確な状況のバックトレースを取得できることを示しています。&lt;em&gt;バックトレースは、&lt;/em&gt;このポイントを取得するために呼び出されたすべての関数の一覧です。 Rustのバックトレースは他の言語と同じように機能します。バックトレースを読み取るための鍵は、上から始めて、書き込んだファイルが表示されるまで読み取ることです。それが問題が発生した場所です。ファイルに言及している行の上の行は、コードが呼び出したコードです。以下の行は、コードを呼び出したコードです。これらの行には、コアRustコード、標準ライブラリコード、または使用しているクレートが含まれる場合があります。 &lt;code&gt;RUST_BACKTRACE&lt;/code&gt; を設定してバックトレースを取得してみましょう 環境変数を0以外の任意の値に設定します。リスト9-2に、表示される出力と同様の出力を示します。</target>
        </trans-unit>
        <trans-unit id="771993487043dfd3c7aa5a2390e7d9f0063dbedb" translate="yes" xml:space="preserve">
          <source>The next part of the code, &lt;code&gt;.read_line(&amp;amp;mut guess)&lt;/code&gt;, calls the &lt;a href=&quot;../std/io/struct.stdin#method.read_line&quot;&gt;&lt;code&gt;read_line&lt;/code&gt;&lt;/a&gt; method on the standard input handle to get input from the user. We&amp;rsquo;re also passing one argument to &lt;code&gt;read_line&lt;/code&gt;: &lt;code&gt;&amp;amp;mut guess&lt;/code&gt;.</source>
          <target state="translated">コードの次の部分である &lt;code&gt;.read_line(&amp;amp;mut guess)&lt;/code&gt; は、標準入力ハンドルの&lt;a href=&quot;../std/io/struct.stdin#method.read_line&quot;&gt; &lt;code&gt;read_line&lt;/code&gt; &lt;/a&gt;メソッドを呼び出して、ユーザーから入力を取得します。また、 &lt;code&gt;read_line&lt;/code&gt; に 1つの引数を渡します： &lt;code&gt;&amp;amp;mut guess&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8f3a0383282eca508bd91153f03681dc6f1973f4" translate="yes" xml:space="preserve">
          <source>The next part of the request line is &lt;em&gt;/&lt;/em&gt;, which indicates the &lt;em&gt;Uniform Resource Identifier&lt;/em&gt;&lt;em&gt;(URI)&lt;/em&gt; the client is requesting: a URI is almost, but not quite, the same as a &lt;em&gt;Uniform Resource Locator&lt;/em&gt;&lt;em&gt;(URL)&lt;/em&gt;. The difference between URIs and URLs isn&amp;rsquo;t important for our purposes in this chapter, but the HTTP spec uses the term URI, so we can just mentally substitute URL for URI here.</source>
          <target state="translated">要求行の次の部分は&lt;em&gt;/&lt;/em&gt;で、クライアントが要求しているURI &lt;em&gt;（&lt;/em&gt;&lt;em&gt;Uniform Resource Identifier &lt;/em&gt;&lt;em&gt;）を&lt;/em&gt;示します。URIは、&lt;em&gt;Uniform Resource Locator &lt;/em&gt;&lt;em&gt;（URL）&lt;/em&gt;とほとんど同じですが、まったく同じではありません。この章では、URIとURLの違いは重要ではありませんが、HTTP仕様ではURIという用語を使用しているため、ここではURIをURLの代わりに精神的に置き換えることができます。</target>
        </trans-unit>
        <trans-unit id="504232041214e8dae75346e3d17c4c0bf4814b9b" translate="yes" xml:space="preserve">
          <source>The next part of the test output, which starts with &lt;code&gt;Doc-tests adder&lt;/code&gt;, is for the results of any documentation tests. We don&amp;rsquo;t have any documentation tests yet, but Rust can compile any code examples that appear in our API documentation. This feature helps us keep our docs and our code in sync! We&amp;rsquo;ll discuss how to write documentation tests in the &lt;a href=&quot;ch14-02-publishing-to-crates-io#documentation-comments-as-tests&quot;&gt;&amp;ldquo;Documentation Comments as Tests&amp;rdquo;&lt;/a&gt; section of Chapter 14. For now, we&amp;rsquo;ll ignore the &lt;code&gt;Doc-tests&lt;/code&gt; output.</source>
          <target state="translated">&lt;code&gt;Doc-tests adder&lt;/code&gt; で始まるテスト出力の次の部分は、ドキュメントテストの結果です。ドキュメントテストはまだありませんが、RustはAPIドキュメントに表示されるコード例をコンパイルできます。この機能は、ドキュメントとコードの同期を保つのに役立ちます！ドキュメントテストの作成方法については、第14章の&lt;a href=&quot;ch14-02-publishing-to-crates-io#documentation-comments-as-tests&quot;&gt;「テストとしてのドキュメントコメント」&lt;/a&gt;セクションで説明します。ここでは、 &lt;code&gt;Doc-tests&lt;/code&gt; の出力は無視します。</target>
        </trans-unit>
        <trans-unit id="1ac4585430b879637fa9bf73df289a63ff5c8c8c" translate="yes" xml:space="preserve">
          <source>The next step is to define the procedural macro. At the time of this writing, procedural macros need to be in their own crate. Eventually, this restriction might be lifted. The convention for structuring crates and macro crates is as follows: for a crate named &lt;code&gt;foo&lt;/code&gt;, a custom derive procedural macro crate is called &lt;code&gt;foo_derive&lt;/code&gt;. Let&amp;rsquo;s start a new crate called &lt;code&gt;hello_macro_derive&lt;/code&gt; inside our &lt;code&gt;hello_macro&lt;/code&gt; project:</source>
          <target state="translated">次のステップは、手続き型マクロを定義することです。この記事の執筆時点では、手続き型マクロは独自のクレートに入れる必要があります。最終的には、この制限が解除される可能性があります。次のように構造化木箱やマクロ箱のための規則は次のとおりです。クレートという名前のために &lt;code&gt;foo&lt;/code&gt; という、カスタムは、手続きマクロクレートが呼び出される派生 &lt;code&gt;foo_derive&lt;/code&gt; 。 &lt;code&gt;hello_macro&lt;/code&gt; プロジェクト内で &lt;code&gt;hello_macro_derive&lt;/code&gt; という新しいクレートを開始しましょう。</target>
        </trans-unit>
        <trans-unit id="86c376c4d2f9126074dd6023a007174609449704" translate="yes" xml:space="preserve">
          <source>The next time you run &lt;code&gt;cargo build&lt;/code&gt;, Cargo will update the registry of crates available and reevaluate your &lt;code&gt;rand&lt;/code&gt; requirements according to the new version you have specified.</source>
          <target state="translated">次回、 &lt;code&gt;cargo build&lt;/code&gt; を実行すると、Cargoは使用可能なクレートのレジストリを更新し、指定した新しいバージョンに応じて &lt;code&gt;rand&lt;/code&gt; 要件を再評価します。</target>
        </trans-unit>
        <trans-unit id="14f1a8115e3ecc473c296ccb90a19424fd7f3781" translate="yes" xml:space="preserve">
          <source>The nightly feature &lt;a href=&quot;https://doc.rust-lang.org/unstable-book/language-features/arbitrary-self-types.html&quot;&gt;Arbitrary self types&lt;/a&gt; extends the accepted set of receiver types to also include any type that can dereference to &lt;code&gt;Self&lt;/code&gt;:</source>
          <target state="translated">The nightly feature &lt;a href=&quot;https://doc.rust-lang.org/unstable-book/language-features/arbitrary-self-types.html&quot;&gt;Arbitrary self types&lt;/a&gt; extends the accepted set of receiver types to also include any type that can dereference to &lt;code&gt;Self&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b3e15e37e03d384e681f27ce15aeb9d3bb4095a8" translate="yes" xml:space="preserve">
          <source>The node that was removed is returned as a new &lt;code&gt;LinkedList&lt;/code&gt; containing only this node. The cursor is moved to point to the next element in the current &lt;code&gt;LinkedList&lt;/code&gt;.</source>
          <target state="translated">削除されたノードは、このノードのみを含む新しい &lt;code&gt;LinkedList&lt;/code&gt; として返されます。カーソルは、現在の &lt;code&gt;LinkedList&lt;/code&gt; 内の次の要素を指すように移動されます。</target>
        </trans-unit>
        <trans-unit id="145ccdcfae9c0bd6f7e5de42ea443500c786c639" translate="yes" xml:space="preserve">
          <source>The nominal type is called the &lt;em&gt;implementing type&lt;/em&gt; and the associable items are the &lt;em&gt;associated items&lt;/em&gt; to the implementing type.</source>
          <target state="translated">公称タイプは&lt;em&gt;実装タイプ&lt;/em&gt;と呼ばれ、&lt;em&gt;関連付け可能なアイテム&lt;/em&gt;は実装タイプに&lt;em&gt;関連付けられたアイテム&lt;/em&gt;です。</target>
        </trans-unit>
        <trans-unit id="a450d39487d717bce9613fc2953a92eb80b07994" translate="yes" xml:space="preserve">
          <source>The note mentions &lt;code&gt;std::cmp::PartialOrd&lt;/code&gt;, which is a &lt;em&gt;trait&lt;/em&gt;. We&amp;rsquo;ll talk about traits in the next section. For now, this error states that the body of &lt;code&gt;largest&lt;/code&gt; won&amp;rsquo;t work for all possible types that &lt;code&gt;T&lt;/code&gt; could be. Because we want to compare values of type &lt;code&gt;T&lt;/code&gt; in the body, we can only use types whose values can be ordered. To enable comparisons, the standard library has the &lt;code&gt;std::cmp::PartialOrd&lt;/code&gt; trait that you can implement on types (see Appendix C for more on this trait). You&amp;rsquo;ll learn how to specify that a generic type has a particular trait in the &lt;a href=&quot;ch10-02-traits#traits-as-parameters&quot;&gt;&amp;ldquo;Traits as Parameters&amp;rdquo;&lt;/a&gt; section, but let&amp;rsquo;s first explore other ways of using generic type parameters.</source>
          <target state="translated">このメモでは、&lt;em&gt;特性&lt;/em&gt;である &lt;code&gt;std::cmp::PartialOrd&lt;/code&gt; について言及しています。次のセクションで特性について説明します。とりあえず、このエラーは、 &lt;code&gt;largest&lt;/code&gt; の本体が &lt;code&gt;T&lt;/code&gt; のすべての可能な型に対して機能しないことを示しています。本文では &lt;code&gt;T&lt;/code&gt; 型の値を比較するため、値を順序付けできる型のみを使用できます。比較を可能にするために、標準ライブラリには、型に実装できる &lt;code&gt;std::cmp::PartialOrd&lt;/code&gt; トレイトがあります（このトレイトの詳細については、付録Cを参照してください）。ジェネリック型が特定の特性を持つように指定する方法については、&lt;a href=&quot;ch10-02-traits#traits-as-parameters&quot;&gt;「パラメーターとしての特性」&lt;/a&gt;セクションで説明しますが、まず、ジェネリック型パラメーターを使用する他の方法について見ていきましょう。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="39a86e3fff1f9b2a932559db164eca88c47636bb" translate="yes" xml:space="preserve">
          <source>The number of arguments passed to a function must match the number of arguments specified in the function signature.</source>
          <target state="translated">関数に渡される引数の数は、関数のシグネチャで指定された引数の数と一致しなければなりません。</target>
        </trans-unit>
        <trans-unit id="1499b95664ab693551effdfbf1800a214feda909" translate="yes" xml:space="preserve">
          <source>The number of elements determines the arity of the tuple. A tuple with &lt;code&gt;n&lt;/code&gt; elements is called an &lt;code&gt;n-ary tuple&lt;/code&gt;. For example, a tuple with 2 elements is a 2-ary tuple.</source>
          <target state="translated">要素の数によって、タプルのアリティが決まります。 &lt;code&gt;n&lt;/code&gt; 個の要素を持つタプルは、 &lt;code&gt;n-ary tuple&lt;/code&gt; と呼ばれます。たとえば、2つの要素を持つタプルは2項タプルです。</target>
        </trans-unit>
        <trans-unit id="29c5008d92a3f283390aac2066e3363b4399cff1" translate="yes" xml:space="preserve">
          <source>The number of elements in an array or slice pattern differed from the number of elements in the array being matched.</source>
          <target state="translated">配列またはスライスパターンの要素数は、一致している配列の要素数とは異なっていました。</target>
        </trans-unit>
        <trans-unit id="110544a8e2a789b8a0779516d37df0cd0dba8ad5" translate="yes" xml:space="preserve">
          <source>The number of operands is the arity of the constructed tuple. Tuple expressions without operands produce the unit tuple. For other tuple expressions, the first written operand initializes the 0th element and subsequent operands initializes the next highest element. For example, in the tuple expression &lt;code&gt;('a', 'b', 'c')&lt;/code&gt;, &lt;code&gt;'a'&lt;/code&gt; initializes the value of the 0th element, &lt;code&gt;'b'&lt;/code&gt; the 1st, and &lt;code&gt;'c'&lt;/code&gt; the 2nd.</source>
          <target state="translated">オペランドの数は、構築されたタプルのアリティです。オペランドのないタプル式は、ユニットタプルを生成します。他のタプル式の場合、最初に書き込まれたオペランドは0番目の要素を初期化し、後続のオペランドは次に高い要素を初期化します。たとえば、タプル式 &lt;code&gt;('a', 'b', 'c')&lt;/code&gt; では、 &lt;code&gt;'a'&lt;/code&gt; は0番目の要素の値を初期化し、 &lt;code&gt;'b'&lt;/code&gt; は1番目、 &lt;code&gt;'c'&lt;/code&gt; は2番目の要素を初期化します。</target>
        </trans-unit>
        <trans-unit id="7202e21ed0c94540f8855e2b43b5089a13dd9685" translate="yes" xml:space="preserve">
          <source>The number of supplied arguments must exactly match the number of defined type parameters.</source>
          <target state="translated">与えられる引数の数は、定義された型パラメータの数と正確に一致しなければなりません。</target>
        </trans-unit>
        <trans-unit id="1505278c99d9fb45d4f4157fc24b25e9be942498" translate="yes" xml:space="preserve">
          <source>The offset being in bounds cannot rely on &quot;wrapping around&quot; the address space. That is, the infinite-precision sum must fit in a &lt;code&gt;usize&lt;/code&gt;.</source>
          <target state="translated">境界内にあるオフセットは、アドレス空間の「折り返し」に依存できません。つまり、無限精度の合計は &lt;code&gt;usize&lt;/code&gt; に収まる必要があります。</target>
        </trans-unit>
        <trans-unit id="eb0b1c110f4f91ff6afa42a1772303d08fd7f686" translate="yes" xml:space="preserve">
          <source>The offset being in bounds cannot rely on &quot;wrapping around&quot; the address space. That is, the infinite-precision sum must fit in a usize.</source>
          <target state="translated">オフセットが境界内にあることは、アドレス空間の「回り込み」に頼ることはできません。つまり、無限精度の和は usize に収まらなければなりません。</target>
        </trans-unit>
        <trans-unit id="dec85f2a58c1002de0f34de579c15b9ae5dcc5c3" translate="yes" xml:space="preserve">
          <source>The offset being in bounds cannot rely on &quot;wrapping around&quot; the address space. That is, the infinite-precision sum, &lt;strong&gt;in bytes&lt;/strong&gt; must fit in a usize.</source>
          <target state="translated">境界内にあるオフセットは、アドレス空間の「折り返し」に依存できません。つまり&lt;strong&gt;、バイト単位&lt;/strong&gt;の無限精度の合計がusizeに収まる必要があり&lt;strong&gt;ます&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="b405bb6eb2033937b629bd683503a6e77a48009c" translate="yes" xml:space="preserve">
          <source>The offset is expressed in number of &lt;code&gt;T&lt;/code&gt; elements, and not bytes. The value returned can be used with the &lt;code&gt;offset&lt;/code&gt; or &lt;code&gt;offset_to&lt;/code&gt; methods.</source>
          <target state="translated">オフセットは、バイトではなく、 &lt;code&gt;T&lt;/code&gt; 要素の数で表されます。返された値は、 &lt;code&gt;offset&lt;/code&gt; または &lt;code&gt;offset_to&lt;/code&gt; メソッドで使用できます。</target>
        </trans-unit>
        <trans-unit id="85ba9b2d34ef606ffd767c5e393592519fd3aa95" translate="yes" xml:space="preserve">
          <source>The offset is expressed in number of &lt;code&gt;T&lt;/code&gt; elements, and not bytes. The value returned can be used with the &lt;code&gt;wrapping_add&lt;/code&gt; method.</source>
          <target state="translated">The offset is expressed in number of &lt;code&gt;T&lt;/code&gt; elements, and not bytes. The value returned can be used with the &lt;code&gt;wrapping_add&lt;/code&gt; method.</target>
        </trans-unit>
        <trans-unit id="1be821c2089924c0d18d107c2c27f16675f5ac1c" translate="yes" xml:space="preserve">
          <source>The offset is relative to the start of the file and thus independent from the current cursor.</source>
          <target state="translated">オフセットはファイルの先頭からの相対的なもので、現在のカーソルからは独立しています。</target>
        </trans-unit>
        <trans-unit id="084e82e27a45f945c98a971924845d2bbfc865a4" translate="yes" xml:space="preserve">
          <source>The offset is relative to the start of the file and thus independent from the current cursor. The current cursor &lt;strong&gt;is&lt;/strong&gt; affected by this function, it is set to the end of the read.</source>
          <target state="translated">オフセットはファイルの先頭を基準としているため、現在のカーソルからは独立しています。現在のカーソル&lt;strong&gt;は&lt;/strong&gt;この関数の影響を受け、読み取りの最後に設定されます。</target>
        </trans-unit>
        <trans-unit id="caf802013d8abd4267e3b977c2a718d4ec2a76b7" translate="yes" xml:space="preserve">
          <source>The offset is relative to the start of the file and thus independent from the current cursor. The current cursor &lt;strong&gt;is&lt;/strong&gt; affected by this function, it is set to the end of the write.</source>
          <target state="translated">オフセットはファイルの先頭を基準としているため、現在のカーソルからは独立しています。現在のカーソル&lt;strong&gt;は&lt;/strong&gt;この関数の影響を受け、書き込みの終わりに設定されます。</target>
        </trans-unit>
        <trans-unit id="e661f5d3042445d2052a045a18f9872b66b5bc29" translate="yes" xml:space="preserve">
          <source>The old borrow checker has known soundness issues that are basically impossible to fix. The new NLL-based borrow checker is the fix.</source>
          <target state="translated">古い借用チェッカーは、基本的に修正が不可能な健全性の問題が知られています。それを修正してくれるのがNLLベースの新しい借用チェッカーです。</target>
        </trans-unit>
        <trans-unit id="ff9f5d5ca24724dc4d44a56e5f4a630aa34c4326" translate="yes" xml:space="preserve">
          <source>The one exception is the implicit &lt;code&gt;Self&lt;/code&gt; type of a trait. A trait does not have an implicit &lt;code&gt;Sized&lt;/code&gt; bound as this is incompatible with &lt;a href=&quot;../../book/ch17-02-trait-objects&quot;&gt;trait object&lt;/a&gt;s where, by definition, the trait needs to work with all possible implementors, and thus could be any size.</source>
          <target state="translated">1つの例外は、特性の暗黙の &lt;code&gt;Self&lt;/code&gt; タイプです。トレイトには暗黙の &lt;code&gt;Sized&lt;/code&gt; バウンドはありません。これは、&lt;a href=&quot;../../book/ch17-02-trait-objects&quot;&gt;トレイトオブジェクト&lt;/a&gt;と互換性がないためです。つまり、トレイトは、可能なすべてのインプリメンターと連携する必要があるため、任意のサイズにすることができます。</target>
        </trans-unit>
        <trans-unit id="251eb8c6b3ec1dc5000df1aa3f1d9769e8fc67e3" translate="yes" xml:space="preserve">
          <source>The only case where such wrapping can occur is when one divides &lt;code&gt;MIN / -1&lt;/code&gt; on a signed type (where &lt;code&gt;MIN&lt;/code&gt; is the negative minimal value for the type); this is equivalent to &lt;code&gt;-MIN&lt;/code&gt;, a positive value that is too large to represent in the type. In such a case, this function returns &lt;code&gt;MIN&lt;/code&gt; itself.</source>
          <target state="translated">このようなラッピングが発生する唯一のケースは、符号付きの型で &lt;code&gt;MIN / -1&lt;/code&gt; を除算する場合です（ &lt;code&gt;MIN&lt;/code&gt; は型の負の最小値です）。これは、タイプで表すには大きすぎる正の値 &lt;code&gt;-MIN&lt;/code&gt; と同等です。このような場合、この関数は &lt;code&gt;MIN&lt;/code&gt; 自体を返します。</target>
        </trans-unit>
        <trans-unit id="76c053c143fda09cee97a50ed7a5afba7b9b021c" translate="yes" xml:space="preserve">
          <source>The only case where such wrapping can occur is when one negates &lt;code&gt;MIN&lt;/code&gt; on a signed type (where &lt;code&gt;MIN&lt;/code&gt; is the negative minimal value for the type); this is a positive value that is too large to represent in the type. In such a case, this function returns &lt;code&gt;MIN&lt;/code&gt; itself.</source>
          <target state="translated">このような折り返しが発生する可能性があるのは、署名された型の &lt;code&gt;MIN&lt;/code&gt; を否定する場合のみです（ &lt;code&gt;MIN&lt;/code&gt; は型の負の最小値です）。これは、タイプで表すには大きすぎる正の値です。このような場合、この関数は &lt;code&gt;MIN&lt;/code&gt; 自体を返します。</target>
        </trans-unit>
        <trans-unit id="4f6de3ab26de46b22b8646658bc86041ba8f3d5e" translate="yes" xml:space="preserve">
          <source>The only case where such wrapping can occur is when one takes the absolute value of the negative minimal value for the type this is a positive value that is too large to represent in the type. In such a case, this function returns &lt;code&gt;MIN&lt;/code&gt; itself.</source>
          <target state="translated">このようなラッピングが発生する可能性がある唯一のケースは、型の負の最小値の絶対値を取る場合、これは型で表すには大きすぎる正の値です。このような場合、この関数は &lt;code&gt;MIN&lt;/code&gt; 自体を返します。</target>
        </trans-unit>
        <trans-unit id="45d6aabe4740755ea8f6332847150daa44a43b07" translate="yes" xml:space="preserve">
          <source>The only case where such wrapping can occur is when one takes the absolute value of the negative minimal value for the type; this is a positive value that is too large to represent in the type. In such a case, this function returns &lt;code&gt;MIN&lt;/code&gt; itself.</source>
          <target state="translated">The only case where such wrapping can occur is when one takes the absolute value of the negative minimal value for the type; this is a positive value that is too large to represent in the type. In such a case, this function returns &lt;code&gt;MIN&lt;/code&gt; itself.</target>
        </trans-unit>
        <trans-unit id="63e8e964be307b9ddc1a920575e78207b9d44077" translate="yes" xml:space="preserve">
          <source>The only difference between Listing 15-7 and Listing 15-6 is that here we set &lt;code&gt;y&lt;/code&gt; to be an instance of a box pointing to a copied value of &lt;code&gt;x&lt;/code&gt; rather than a reference pointing to the value of &lt;code&gt;x&lt;/code&gt;. In the last assertion, we can use the dereference operator to follow the box&amp;rsquo;s pointer in the same way that we did when &lt;code&gt;y&lt;/code&gt; was a reference. Next, we&amp;rsquo;ll explore what is special about &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; that enables us to use the dereference operator by defining our own box type.</source>
          <target state="translated">The only difference between Listing 15-7 and Listing 15-6 is that here we set &lt;code&gt;y&lt;/code&gt; to be an instance of a box pointing to a copied value of &lt;code&gt;x&lt;/code&gt; rather than a reference pointing to the value of &lt;code&gt;x&lt;/code&gt; . In the last assertion, we can use the dereference operator to follow the box&amp;rsquo;s pointer in the same way that we did when &lt;code&gt;y&lt;/code&gt; was a reference. Next, we&amp;rsquo;ll explore what is special about &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; that enables us to use the dereference operator by defining our own box type.</target>
        </trans-unit>
        <trans-unit id="51b5a7f2069f2def348d2148cbc38445c3e27f4c" translate="yes" xml:space="preserve">
          <source>The only difference between Listing 15-7 and Listing 15-6 is that here we set &lt;code&gt;y&lt;/code&gt; to be an instance of a box pointing to the value in &lt;code&gt;x&lt;/code&gt; rather than a reference pointing to the value of &lt;code&gt;x&lt;/code&gt;. In the last assertion, we can use the dereference operator to follow the box&amp;rsquo;s pointer in the same way that we did when &lt;code&gt;y&lt;/code&gt; was a reference. Next, we&amp;rsquo;ll explore what is special about &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; that enables us to use the dereference operator by defining our own box type.</source>
          <target state="translated">表15-7および表15-6との間の唯一の違いは、ここでは、設定されている &lt;code&gt;y&lt;/code&gt; 内の値を指すボックスのインスタンスであることが &lt;code&gt;x&lt;/code&gt; よりもむしろの値を指す参照 &lt;code&gt;x&lt;/code&gt; 。最後のアサーションでは、逆参照演算子を使用して、 &lt;code&gt;y&lt;/code&gt; が参照の場合と同じようにボックスのポインターを追跡できます。次に、独自のボックスタイプを定義することで間接参照演算子を使用できるようにする &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 特別な点について説明します。</target>
        </trans-unit>
        <trans-unit id="f7b8368bfb1b8c79cdb7d78152517d184d409bdd" translate="yes" xml:space="preserve">
          <source>The only functions that can be called in static or constant expressions are &lt;code&gt;const&lt;/code&gt; functions, and struct/enum constructors.</source>
          <target state="translated">The only functions that can be called in static or constant expressions are &lt;code&gt;const&lt;/code&gt; functions, and struct/enum constructors.</target>
        </trans-unit>
        <trans-unit id="aa7a3f715132d2845165ebc499ef1753bb78d047" translate="yes" xml:space="preserve">
          <source>The only functions that can be called in static or constant expressions are &lt;code&gt;const&lt;/code&gt; functions, and struct/enum constructors. &lt;code&gt;const&lt;/code&gt; functions are only available on a nightly compiler. Rust currently does not support more general compile-time function execution.</source>
          <target state="translated">静的式または定数式で呼び出すことができる関数は、 &lt;code&gt;const&lt;/code&gt; 関数、およびstruct / enumコンストラクターのみです。 &lt;code&gt;const&lt;/code&gt; 関数は、夜間コンパイラーでのみ使用できます。Rustは現在、より一般的なコンパイル時関数の実行をサポートしていません。</target>
        </trans-unit>
        <trans-unit id="f7c42c506a124c9ffe70241d1844e481774b0efe" translate="yes" xml:space="preserve">
          <source>The only lifetime allowed in a constant is &lt;code&gt;'static&lt;/code&gt;, which is the lifetime that encompasses all others in a Rust program. For example, if you wanted to define a constant string, it would look like this:</source>
          <target state="translated">定数で許可される唯一の寿命は &lt;code&gt;'static&lt;/code&gt; 。これは、Rustプログラムの他のすべてを含む寿命です。たとえば、定数文字列を定義する場合は、次のようになります。</target>
        </trans-unit>
        <trans-unit id="c90e7627a1475de1daf664c395cb8fc220c2a179" translate="yes" xml:space="preserve">
          <source>The operand of a field expression.</source>
          <target state="translated">フィールド式のオペランド。</target>
        </trans-unit>
        <trans-unit id="c815094584bba28655815f7e3484796d5b4ac295" translate="yes" xml:space="preserve">
          <source>The operand of a unary &lt;a href=&quot;expressions/operator-expr#borrow-operators&quot;&gt;borrow&lt;/a&gt; or &lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;dereference&lt;/a&gt; operator.</source>
          <target state="translated">単項&lt;a href=&quot;expressions/operator-expr#borrow-operators&quot;&gt;借用&lt;/a&gt;演算子または&lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;逆参照&lt;/a&gt;演算子のオペランド。</target>
        </trans-unit>
        <trans-unit id="cfdf71c707b06cc703ce65b9173f06d5346346a9" translate="yes" xml:space="preserve">
          <source>The operand of an extending &lt;a href=&quot;expressions/operator-expr#borrow-operators&quot;&gt;borrow expression&lt;/a&gt;.</source>
          <target state="translated">The operand of an extending &lt;a href=&quot;expressions/operator-expr#borrow-operators&quot;&gt;borrow expression&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="93f114bcdcaebb0db94cec84309f6c6e9289e758" translate="yes" xml:space="preserve">
          <source>The operand of any &lt;a href=&quot;#implicit-borrows&quot;&gt;implicit borrow&lt;/a&gt;.</source>
          <target state="translated">The operand of any &lt;a href=&quot;#implicit-borrows&quot;&gt;implicit borrow&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="8300616806da6883f068d3a939bb5817283d75af" translate="yes" xml:space="preserve">
          <source>The operand of any &lt;a href=&quot;expressions#implicit-borrows&quot;&gt;implicit borrow&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;expressions#implicit-borrows&quot;&gt;暗黙的な借用&lt;/a&gt;のオペランド。</target>
        </trans-unit>
        <trans-unit id="13205f7dcdf1bb624db42e4217ccc5c5fe9a6c93" translate="yes" xml:space="preserve">
          <source>The operand of any extending borrow expression has its temporary scope extended.</source>
          <target state="translated">拡張する借用式のオペランドは、その一時的なスコープが拡張されています。</target>
        </trans-unit>
        <trans-unit id="0018d918b5db8fa5a5c40594da4082243e89b941" translate="yes" xml:space="preserve">
          <source>The operand(s) of an extending &lt;a href=&quot;expressions/array-expr#array-expressions&quot;&gt;array&lt;/a&gt;, &lt;a href=&quot;expressions/operator-expr#type-cast-expressions&quot;&gt;cast&lt;/a&gt;, &lt;a href=&quot;expressions/struct-expr&quot;&gt;braced struct&lt;/a&gt;, or &lt;a href=&quot;expressions/tuple-expr#tuple-expressions&quot;&gt;tuple&lt;/a&gt; expression.</source>
          <target state="translated">The operand(s) of an extending &lt;a href=&quot;expressions/array-expr#array-expressions&quot;&gt;array&lt;/a&gt;, &lt;a href=&quot;expressions/operator-expr#type-cast-expressions&quot;&gt;cast&lt;/a&gt;, &lt;a href=&quot;expressions/struct-expr&quot;&gt;braced struct&lt;/a&gt;, or &lt;a href=&quot;expressions/tuple-expr#tuple-expressions&quot;&gt;tuple&lt;/a&gt; expression.</target>
        </trans-unit>
        <trans-unit id="02413f33b0997a467453e2cc175754042613115c" translate="yes" xml:space="preserve">
          <source>The operation failed because a pipe was closed.</source>
          <target state="translated">パイプが閉まっていたため、操作に失敗しました。</target>
        </trans-unit>
        <trans-unit id="e0b6b6bb05edcbe700535a8a02fd6257faeb1085" translate="yes" xml:space="preserve">
          <source>The operation lacked the necessary privileges to complete.</source>
          <target state="translated">操作に必要な特権を欠いていた。</target>
        </trans-unit>
        <trans-unit id="d56bd5ac430688946f617fddd5ff8737ea77aabc" translate="yes" xml:space="preserve">
          <source>The operation needs to block to complete, but the blocking operation was requested to not occur.</source>
          <target state="translated">操作が完了するにはブロックする必要がありますが、ブロック操作は発生しないように要求されました。</target>
        </trans-unit>
        <trans-unit id="554600e43876fa49fe1808261768a1599008a1a5" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;||&lt;/code&gt; and &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; may be applied to operands of boolean type. The &lt;code&gt;||&lt;/code&gt; operator denotes logical 'or', and the &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operator denotes logical 'and'. They differ from &lt;code&gt;|&lt;/code&gt; and &lt;code&gt;&amp;amp;&lt;/code&gt; in that the right-hand operand is only evaluated when the left-hand operand does not already determine the result of the expression. That is, &lt;code&gt;||&lt;/code&gt; only evaluates its right-hand operand when the left-hand operand evaluates to &lt;code&gt;false&lt;/code&gt;, and &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; only when it evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">演算子 &lt;code&gt;||&lt;/code&gt; そして &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; ブール型のオペランドに適用してもよいです。 &lt;code&gt;||&lt;/code&gt; 演算子は論理「または」を示し、 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 演算子は論理「および」を示します。 &lt;code&gt;|&lt;/code&gt; とは異なるそして &lt;code&gt;&amp;amp;&lt;/code&gt; 右側の点でオペランドたときだけ左に評価され、オペランドすでに式の結果を決定するものではありません。つまり、 &lt;code&gt;||&lt;/code&gt; 左側のオペランドが &lt;code&gt;false&lt;/code&gt; と評価された場合にのみ右側のオペランドを評価し、 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; と評価された場合にのみ&amp;amp;&amp;amp;を評価します。</target>
        </trans-unit>
        <trans-unit id="94a90205d7a5e5f5664d5fdcbd09052010d467f6" translate="yes" xml:space="preserve">
          <source>The optional &lt;a href=&quot;https://en.wikipedia.org/wiki/Byte_order_mark#UTF-8&quot;&gt;&lt;em&gt;UTF8 byte order mark&lt;/em&gt;&lt;/a&gt; (UTF8BOM production) indicates that the file is encoded in UTF8. It can only occur at the beginning of the file and is ignored by the compiler.</source>
          <target state="translated">オプションの&lt;a href=&quot;https://en.wikipedia.org/wiki/Byte_order_mark#UTF-8&quot;&gt;&lt;em&gt;UTF8バイトオーダーマーク&lt;/em&gt;&lt;/a&gt;（UTF8BOMプロダクション）は、ファイルがUTF8でエンコードされていることを示します。これはファイルの先頭でのみ発生し、コンパイラーによって無視されます。</target>
        </trans-unit>
        <trans-unit id="22d7081f01819ecc0a53443b4c5e3e1a4e2c048a" translate="yes" xml:space="preserve">
          <source>The optional fill character and alignment is provided normally in conjunction with the &lt;a href=&quot;#width&quot;&gt;&lt;code&gt;width&lt;/code&gt;&lt;/a&gt; parameter. It must be defined before &lt;code&gt;width&lt;/code&gt;, right after the &lt;code&gt;:&lt;/code&gt;. This indicates that if the value being formatted is smaller than &lt;code&gt;width&lt;/code&gt; some extra characters will be printed around it. Filling comes in the following variants for different alignments:</source>
          <target state="translated">The optional fill character and alignment is provided normally in conjunction with the &lt;a href=&quot;#width&quot;&gt; &lt;code&gt;width&lt;/code&gt; &lt;/a&gt; parameter. It must be defined before &lt;code&gt;width&lt;/code&gt; , right after the &lt;code&gt;:&lt;/code&gt; . This indicates that if the value being formatted is smaller than &lt;code&gt;width&lt;/code&gt; some extra characters will be printed around it. Filling comes in the following variants for different alignments:</target>
        </trans-unit>
        <trans-unit id="1ef92817d2fa5638a8f8e4bfed63d30ce997249b" translate="yes" xml:space="preserve">
          <source>The order in which this iterator returns entries is platform and filesystem dependent.</source>
          <target state="translated">このイテレータがエントリを返す順序は、プラットフォームやファイルシステムに依存します。</target>
        </trans-unit>
        <trans-unit id="60297fe01f4f2a21350a894e6ee139ac8e93f1b8" translate="yes" xml:space="preserve">
          <source>The order in which to evaluate the sub-expressions</source>
          <target state="translated">副式を評価する順番</target>
        </trans-unit>
        <trans-unit id="61bedc7c16635e05c26ee08451d7e761461ef5bb" translate="yes" xml:space="preserve">
          <source>The organizational problem of allocating responsibility for multiple tasks to the &lt;code&gt;main&lt;/code&gt; function is common to many binary projects. As a result, the Rust community has developed a process to use as a guideline for splitting the separate concerns of a binary program when &lt;code&gt;main&lt;/code&gt; starts getting large. The process has the following steps:</source>
          <target state="translated">複数のタスクの責任を &lt;code&gt;main&lt;/code&gt; 関数に割り当てるという組織上の問題は、多くのバイナリプロジェクトに共通しています。その結果、Rustコミュニティは、 &lt;code&gt;main&lt;/code&gt; が大きくなり始めたときにバイナリプログラムの個別の懸念を分割するためのガイドラインとして使用するプロセスを開発しました。このプロセスには次のステップがあります。</target>
        </trans-unit>
        <trans-unit id="41be0c260fec224b2719e05df384f73991bede1b" translate="yes" xml:space="preserve">
          <source>The other arm of the &lt;code&gt;match&lt;/code&gt; handles the case where we get an &lt;code&gt;Err&lt;/code&gt; value from &lt;code&gt;File::open&lt;/code&gt;. In this example, we&amp;rsquo;ve chosen to call the &lt;code&gt;panic!&lt;/code&gt; macro. If there&amp;rsquo;s no file named &lt;em&gt;hello.txt&lt;/em&gt; in our current directory and we run this code, we&amp;rsquo;ll see the following output from the &lt;code&gt;panic!&lt;/code&gt; macro:</source>
          <target state="translated">&lt;code&gt;match&lt;/code&gt; のもう一方のアームは、 &lt;code&gt;File::open&lt;/code&gt; から &lt;code&gt;Err&lt;/code&gt; 値を取得する場合を処理します。この例では、 &lt;code&gt;panic!&lt;/code&gt; を呼び出すことを選択しました！大きい。現在のディレクトリに&lt;em&gt;hello.txt&lt;/em&gt;という名前のファイルがなく、このコードを実行すると、 &lt;code&gt;panic!&lt;/code&gt; から次の出力が表示されます。大きい：</target>
        </trans-unit>
        <trans-unit id="a7bf4938ef9d644fa6590a14199d49f21d906882" translate="yes" xml:space="preserve">
          <source>The other difference between &lt;code&gt;mut&lt;/code&gt; and shadowing is that because we&amp;rsquo;re effectively creating a new variable when we use the &lt;code&gt;let&lt;/code&gt; keyword again, we can change the type of the value but reuse the same name. For example, say our program asks a user to show how many spaces they want between some text by inputting space characters, but we really want to store that input as a number:</source>
          <target state="translated">&lt;code&gt;mut&lt;/code&gt; とshadowing のもう 1つの違いは、 &lt;code&gt;let&lt;/code&gt; キーワードを再度使用すると新しい変数が効果的に作成されるため、値のタイプを変更して同じ名前を再利用できることです。たとえば、プログラムがユーザーにスペース文字を入力して、テキスト間のスペースをいくつ表示するかを尋ねたが、実際にはその入力を数値として保存したいとします。</target>
        </trans-unit>
        <trans-unit id="df7669a1bf85d9740015e4131e57d2cd1eb9d9d3" translate="yes" xml:space="preserve">
          <source>The other main use of the &lt;code&gt;const&lt;/code&gt; keyword is in &lt;code&gt;const fn&lt;/code&gt;. This marks a function as being callable in the body of a &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;static&lt;/code&gt; item and in array initializers (commonly called &quot;const contexts&quot;). &lt;code&gt;const fn&lt;/code&gt; are restricted in the set of operations they can perform, to ensure that they can be evaluated at compile-time. See the &lt;a href=&quot;../reference/const_eval&quot;&gt;Reference&lt;/a&gt; for more detail.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; キーワードの他の主な用途は、 &lt;code&gt;const fn&lt;/code&gt; です。これは、関数を &lt;code&gt;const&lt;/code&gt; または &lt;code&gt;static&lt;/code&gt; アイテムの本体および配列初期化子（一般に「constコンテキスト」と呼ばれる）で呼び出し可能としてマークします。 &lt;code&gt;const fn&lt;/code&gt; は、コンパイル時に評価できるように、実行できる一連の操作に制限があります。詳細については、&lt;a href=&quot;../reference/const_eval&quot;&gt;リファレンス&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="a27877809931e30e4d816c929aaf44550dc13948" translate="yes" xml:space="preserve">
          <source>The other option is to decide that pinning is &quot;structural&quot; for &lt;code&gt;field&lt;/code&gt;, meaning that if the struct is pinned then so is the field.</source>
          <target state="translated">もう1つのオプションは、固定が &lt;code&gt;field&lt;/code&gt; の「構造的」であることを決定することです。つまり、構造が固定されている場合、フィールドも固定されています。</target>
        </trans-unit>
        <trans-unit id="0642ecd58583a2694ae6dacfe0a415f63c694440" translate="yes" xml:space="preserve">
          <source>The other reason to use inheritance relates to the type system: to enable a child type to be used in the same places as the parent type. This is also called &lt;em&gt;polymorphism&lt;/em&gt;, which means that you can substitute multiple objects for each other at runtime if they share certain characteristics.</source>
          <target state="translated">継承を使用するもう1つの理由は、型システムに関連します。子型を親型と同じ場所で使用できるようにするためです。これは&lt;em&gt;ポリモーフィズム&lt;/em&gt;とも呼ばれます。つまり、複数のオブジェクトが特定の特性を共有している場合、実行時にそれらを相互に置き換えることができます。</target>
        </trans-unit>
        <trans-unit id="89dc389d4ca8b1b17999395cda6f46045ddfd179" translate="yes" xml:space="preserve">
          <source>The other use of the &lt;code&gt;impl&lt;/code&gt; keyword is in &lt;code&gt;impl Trait&lt;/code&gt; syntax, which can be seen as a shorthand for &quot;a concrete type that implements this trait&quot;. Its primary use is working with closures, which have type definitions generated at compile time that can't be simply typed out.</source>
          <target state="translated">&lt;code&gt;impl&lt;/code&gt; キーワードのもう1つの使用法は、「このトレイトを実装する具象型」の省略形と &lt;code&gt;impl Trait&lt;/code&gt; 構文です。その主な用途は、コンパイル時に生成される型定義があり、単純に型指定できないクロージャーでの作業です。</target>
        </trans-unit>
        <trans-unit id="5fa7bdd2f67d8992d16557677350c79fe148aa6f" translate="yes" xml:space="preserve">
          <source>The other way to solve this error is to make the private type public. Example:</source>
          <target state="translated">このエラーを解決するもう一つの方法は、プライベート型をpublicにすることです。例を示します。</target>
        </trans-unit>
        <trans-unit id="69b16008db0e7fefb3576376fa59c7cdb24bc4ca" translate="yes" xml:space="preserve">
          <source>The outer scope declares a variable named &lt;code&gt;r&lt;/code&gt; with no initial value, and the inner scope declares a variable named &lt;code&gt;x&lt;/code&gt; with the initial value of 5. Inside the inner scope, we attempt to set the value of &lt;code&gt;r&lt;/code&gt; as a reference to &lt;code&gt;x&lt;/code&gt;. Then the inner scope ends, and we attempt to print the value in &lt;code&gt;r&lt;/code&gt;. This code won&amp;rsquo;t compile because the value &lt;code&gt;r&lt;/code&gt; is referring to has gone out of scope before we try to use it. Here is the error message:</source>
          <target state="translated">外部スコープは初期値なしで &lt;code&gt;r&lt;/code&gt; という名前の変数を宣言し、内部スコープは初期値5で &lt;code&gt;x&lt;/code&gt; という変数を宣言します。内部スコープ内では、 &lt;code&gt;x&lt;/code&gt; への参照として &lt;code&gt;r&lt;/code&gt; の値を設定しようとします。その後、内部スコープが終了し、値を &lt;code&gt;r&lt;/code&gt; に出力しようとします。このコードは、 &lt;code&gt;r&lt;/code&gt; が参照している値が使用しようとする前にスコープ外になったため、コンパイルされません。エラーメッセージは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="ee4813584901b6edf7255c9100533eb924eb1e04" translate="yes" xml:space="preserve">
          <source>The output of a finished process.</source>
          <target state="translated">完成したプロセスの出力。</target>
        </trans-unit>
        <trans-unit id="7091d6ad7f032d028b64c465cb0226168ae0e89e" translate="yes" xml:space="preserve">
          <source>The output of this function should not be used in anything that might have security implications. For example:</source>
          <target state="translated">この関数の出力は、セキュリティに影響を与える可能性のあるものには使用してはいけません。例えば</target>
        </trans-unit>
        <trans-unit id="c978821bc364ab92333f8a77fd4cf50814193dc4" translate="yes" xml:space="preserve">
          <source>The output that the future will produce on completion.</source>
          <target state="translated">未来が完成した時に出すアウトプット。</target>
        </trans-unit>
        <trans-unit id="4e5a226f1cb2eaa0ff96072c4caeb2fee856332d" translate="yes" xml:space="preserve">
          <source>The output type returned by methods.</source>
          <target state="translated">メソッドが返す出力タイプ。</target>
        </trans-unit>
        <trans-unit id="b3fedfd8280044a357b6d9f266e6194249a97d9a" translate="yes" xml:space="preserve">
          <source>The output will be the recommended workout plan. Listing 13-2 shows the &lt;code&gt;main&lt;/code&gt; function we&amp;rsquo;ll use.</source>
          <target state="translated">出力は、推奨されるワークアウトプランになります。リスト13-2は私たちが使用する &lt;code&gt;main&lt;/code&gt; 関数を示しています。</target>
        </trans-unit>
        <trans-unit id="884c1b47c0faf2e5f38e29c6c1a9622d7629d70c" translate="yes" xml:space="preserve">
          <source>The overall goal of these requirements is to let the consumer of a pipeline use</source>
          <target state="translated">これらの要件の全体的な目標は、パイプラインの消費者が</target>
        </trans-unit>
        <trans-unit id="c750221db5bde24f0432e5395fa0e7d6b2249e8f" translate="yes" xml:space="preserve">
          <source>The ownership of &lt;code&gt;buf&lt;/code&gt; is effectively transferred to the &lt;code&gt;String&lt;/code&gt; which may then deallocate, reallocate or change the contents of memory pointed to by the pointer at will. Ensure that nothing else uses the pointer after calling this function.</source>
          <target state="translated">The ownership of &lt;code&gt;buf&lt;/code&gt; is effectively transferred to the &lt;code&gt;String&lt;/code&gt; which may then deallocate, reallocate or change the contents of memory pointed to by the pointer at will. Ensure that nothing else uses the pointer after calling this function.</target>
        </trans-unit>
        <trans-unit id="b39c88ef6b933b61e4ea4a039f34870326ac716b" translate="yes" xml:space="preserve">
          <source>The ownership of &lt;code&gt;ptr&lt;/code&gt; is effectively transferred to the &lt;code&gt;String&lt;/code&gt; which may then deallocate, reallocate or change the contents of memory pointed to by the pointer at will. Ensure that nothing else uses the pointer after calling this function.</source>
          <target state="translated">&lt;code&gt;ptr&lt;/code&gt; の所有権は効果的に &lt;code&gt;String&lt;/code&gt; に転送され、Stringは割り当てを解除、再割り当て、またはポインタが指すメモリの内容を自由に変更できます。この関数を呼び出した後は、他にポインターを使用しないようにしてください。</target>
        </trans-unit>
        <trans-unit id="0c5ac2aeb05d71a34b822c034365a66e97f5d90e" translate="yes" xml:space="preserve">
          <source>The ownership of &lt;code&gt;ptr&lt;/code&gt; is effectively transferred to the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; which may then deallocate, reallocate or change the contents of memory pointed to by the pointer at will. Ensure that nothing else uses the pointer after calling this function.</source>
          <target state="translated">&lt;code&gt;ptr&lt;/code&gt; の所有権は &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 効果的に転送され、Vec &amp;lt;T&amp;gt;は、ポインターが指すメモリーの内容の割り当てを解除、再割り当て、または変更することができます。この関数を呼び出した後は、他にポインターを使用しないようにしてください。</target>
        </trans-unit>
        <trans-unit id="459d615a7b443b2b18398d7b4e4094d21aa9904a" translate="yes" xml:space="preserve">
          <source>The ownership of a variable follows the same pattern every time: assigning a value to another variable moves it. When a variable that includes data on the heap goes out of scope, the value will be cleaned up by &lt;code&gt;drop&lt;/code&gt; unless the data has been moved to be owned by another variable.</source>
          <target state="translated">変数の所有権は毎回同じパターンに従います。別の変数に値を割り当てると、変数が移動します。ヒープ上のデータを含む変数がスコープ外になると、データが別の変数によって所有されるように移動されていない限り、値は &lt;code&gt;drop&lt;/code&gt; によってクリーンアップされます。</target>
        </trans-unit>
        <trans-unit id="8158170312c35ad0b4ff632e830474174c9789f6" translate="yes" xml:space="preserve">
          <source>The ownership rules play a vital role in message sending because they help you write safe, concurrent code. Preventing errors in concurrent programming is the advantage of thinking about ownership throughout your Rust programs. Let&amp;rsquo;s do an experiment to show how channels and ownership work together to prevent problems: we&amp;rsquo;ll try to use a &lt;code&gt;val&lt;/code&gt; value in the spawned thread &lt;em&gt;after&lt;/em&gt; we&amp;rsquo;ve sent it down the channel. Try compiling the code in Listing 16-9 to see why this code isn&amp;rsquo;t allowed:</source>
          <target state="translated">所有権ルールは、安全な並行コードの記述に役立つため、メッセージ送信において重要な役割を果たします。並行プログラミングでのエラーを防ぐことは、Rustプログラム全体の所有権について考えることの利点です。のは、チャンネルと所有権の仕事が一緒に問題を防ぐ方法を示すための実験をやってみましょう：私たちが使用しようとするでしょう &lt;code&gt;val&lt;/code&gt; 生成されたスレッドに値を&lt;em&gt;した後&lt;/em&gt;、我々は、チャネルの下にそれを送ってきました。リスト16-9のコードをコンパイルして、このコードが許可されない理由を確認してください：</target>
        </trans-unit>
        <trans-unit id="58f56a016b810f8287c744364955b1ffc32f9240" translate="yes" xml:space="preserve">
          <source>The panic hook is a global resource.</source>
          <target state="translated">パニックフックはグローバルリソースです。</target>
        </trans-unit>
        <trans-unit id="684aef30b999855f4bf1399a43d22fd82b7e6c9d" translate="yes" xml:space="preserve">
          <source>The panic hook is invoked when a thread panics, but before the panic runtime is invoked. As such, the hook will run with both the aborting and unwinding runtimes. The default hook prints a message to standard error and generates a backtrace if requested, but this behavior can be customized with the &lt;code&gt;set_hook&lt;/code&gt; and &lt;a href=&quot;fn.take_hook&quot;&gt;&lt;code&gt;take_hook&lt;/code&gt;&lt;/a&gt; functions.</source>
          <target state="translated">パニックフックは、スレッドがパニックになったとき、パニックランタイムが呼び出される前に呼び出されます。そのため、フックはアボートランタイムと巻き戻しランタイムの両方で実行されます。デフォルトのフックは、メッセージを標準エラーに出力し、要求に応じてバックトレースを生成しますが、この動作は &lt;code&gt;set_hook&lt;/code&gt; および&lt;a href=&quot;fn.take_hook&quot;&gt; &lt;code&gt;take_hook&lt;/code&gt; &lt;/a&gt;関数を使用してカスタマイズできます。</target>
        </trans-unit>
        <trans-unit id="563c97e45aeee516b45222324d4cc368e8c084ba" translate="yes" xml:space="preserve">
          <source>The parameters given to &lt;code&gt;Layout::from_size_align&lt;/code&gt; or some other &lt;code&gt;Layout&lt;/code&gt; constructor do not satisfy its documented constraints.</source>
          <target state="translated">&lt;code&gt;Layout::from_size_align&lt;/code&gt; または他の &lt;code&gt;Layout&lt;/code&gt; コンストラクターに指定されたパラメーターは、文書化された制約を満たしていません。</target>
        </trans-unit>
        <trans-unit id="3c2a54faaf19386dc2b06158bf3003e146fc0f45" translate="yes" xml:space="preserve">
          <source>The parameters of any trait method must match between a trait implementation and the trait definition.</source>
          <target state="translated">どのような形質メソッドのパラメータも、形質の実装と形質の定義の間で一致しなければなりません。</target>
        </trans-unit>
        <trans-unit id="df3b8f99f35d92ad550b740bf7dc9171d35b97ed" translate="yes" xml:space="preserve">
          <source>The parent of a statement scope is the scope of the block that contains the statement.</source>
          <target state="translated">ステートメントスコープの親は、ステートメントを含むブロックのスコープです。</target>
        </trans-unit>
        <trans-unit id="c46091b9f972d668faf65caa23b2e09a8a170568" translate="yes" xml:space="preserve">
          <source>The parent of all other scopes is the scope of the immediately enclosing expression.</source>
          <target state="translated">他のすべてのスコープの親は、すぐに囲む式のスコープです。</target>
        </trans-unit>
        <trans-unit id="e04065a98d4b38354b6e3e4d4abb130f6c621783" translate="yes" xml:space="preserve">
          <source>The parent of the arm scope is the scope of the &lt;code&gt;match&lt;/code&gt; expression that it belongs to.</source>
          <target state="translated">The parent of the arm scope is the scope of the &lt;code&gt;match&lt;/code&gt; expression that it belongs to.</target>
        </trans-unit>
        <trans-unit id="09a327800a21f08b5d4e1948e88aac172c2121be" translate="yes" xml:space="preserve">
          <source>The parent of the current &lt;a href=&quot;../reference/items/modules&quot;&gt;module&lt;/a&gt;.</source>
          <target state="translated">現在の&lt;a href=&quot;../reference/items/modules&quot;&gt;モジュール&lt;/a&gt;の親。</target>
        </trans-unit>
        <trans-unit id="529eb4e30d49293a9076afc4b5e1cde599b49562" translate="yes" xml:space="preserve">
          <source>The parent of the expression after the &lt;code&gt;=&amp;gt;&lt;/code&gt; in a &lt;code&gt;match&lt;/code&gt; expression is the scope of the arm that it's in.</source>
          <target state="translated">The parent of the expression after the &lt;code&gt;=&amp;gt;&lt;/code&gt; in a &lt;code&gt;match&lt;/code&gt; expression is the scope of the arm that it's in.</target>
        </trans-unit>
        <trans-unit id="7bf69b726f2264b18f25a14f0c4351943f8d4d50" translate="yes" xml:space="preserve">
          <source>The parent of the expression for a &lt;code&gt;match&lt;/code&gt; guard is the scope of the arm that the guard is for.</source>
          <target state="translated">The parent of the expression for a &lt;code&gt;match&lt;/code&gt; guard is the scope of the arm that the guard is for.</target>
        </trans-unit>
        <trans-unit id="10e7154b1118c2abd23aedcc36e2f4febf44487b" translate="yes" xml:space="preserve">
          <source>The parent of the expression in an expression statement is the scope of the statement.</source>
          <target state="translated">式文の中の式の親は、式文のスコープです。</target>
        </trans-unit>
        <trans-unit id="bf1edfebb91e8c5be33d3f8d00037717971d53a2" translate="yes" xml:space="preserve">
          <source>The parent of the initializer of a &lt;a href=&quot;statements#let-statements&quot;&gt;&lt;code&gt;let&lt;/code&gt; statement&lt;/a&gt; is the &lt;code&gt;let&lt;/code&gt; statement's scope.</source>
          <target state="translated">The parent of the initializer of a &lt;a href=&quot;statements#let-statements&quot;&gt; &lt;code&gt;let&lt;/code&gt; statement&lt;/a&gt; is the &lt;code&gt;let&lt;/code&gt; statement's scope.</target>
        </trans-unit>
        <trans-unit id="f7896dc490ba78587890c7c602aaea52ff1e61a5" translate="yes" xml:space="preserve">
          <source>The parent thread can also wait on the completion of the child thread; a call to &lt;a href=&quot;fn.spawn&quot;&gt;&lt;code&gt;spawn&lt;/code&gt;&lt;/a&gt; produces a &lt;a href=&quot;struct.joinhandle&quot;&gt;&lt;code&gt;JoinHandle&lt;/code&gt;&lt;/a&gt;, which provides a &lt;code&gt;join&lt;/code&gt; method for waiting:</source>
          <target state="translated">親スレッドは、子スレッドの完了を待機することもできます。&lt;a href=&quot;fn.spawn&quot;&gt; &lt;code&gt;spawn&lt;/code&gt; &lt;/a&gt;を呼び出すと、待機用の &lt;code&gt;join&lt;/code&gt; メソッドを提供する&lt;a href=&quot;struct.joinhandle&quot;&gt; &lt;code&gt;JoinHandle&lt;/code&gt; が&lt;/a&gt;生成されます。</target>
        </trans-unit>
        <trans-unit id="46e80e0e5a125dc6b093687f5b3dfa680a2d94d7" translate="yes" xml:space="preserve">
          <source>The parenthesized &lt;code&gt;inline&lt;/code&gt; attribute requires the parameter to be specified:</source>
          <target state="translated">括弧で囲まれた &lt;code&gt;inline&lt;/code&gt; 属性には、パラメーターを指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="15c1964228f17e3bf48dc3c0a27f630dfed2aef1" translate="yes" xml:space="preserve">
          <source>The parenthesized &lt;code&gt;instruction_set&lt;/code&gt; attribute requires the parameter to be specified:</source>
          <target state="translated">括弧で囲まれた &lt;code&gt;instruction_set&lt;/code&gt; 属性では、パラメーターを指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="d2172d9db47abf995cf78b6d1056e43a62f663b4" translate="yes" xml:space="preserve">
          <source>The parser used by the macro system is reasonably powerful, but it is limited in order to prevent ambiguity in current or future versions of the language. In particular, in addition to the rule about ambiguous expansions, a nonterminal matched by a metavariable must be followed by a token which has been decided can be safely used after that kind of match.</source>
          <target state="translated">マクロシステムで使用されるパーサはそれなりに強力ですが、現在のバージョンや将来のバージョンの言語での曖昧さを防ぐために制限されています。特に、曖昧な展開に関するルールに加えて、メタ変数でマッチした非終端は、その種のマッチの後に安全に使用できると判断されたトークンを続けなければなりません。</target>
        </trans-unit>
        <trans-unit id="72524139620fe5680057ec138f1bc4009c442555" translate="yes" xml:space="preserve">
          <source>The path prefix for modules is the canonical path to that module. For bare implementations, it is the canonical path of the item being implemented surrounded by angle (&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;) brackets. For &lt;a href=&quot;items/implementations#trait-implementations&quot;&gt;trait implementations&lt;/a&gt;, it is the canonical path of the item being implemented followed by &lt;code&gt;as&lt;/code&gt; followed by the canonical path to the trait all surrounded in angle (&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;) brackets.</source>
          <target state="translated">モジュールのパス接頭辞は、そのモジュールへの正規のパスです。ベア実装の場合、これは山かっこ（ &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; ）で囲まれた、実装される項目の正規のパスです。以下のために&lt;a href=&quot;items/implementations#trait-implementations&quot;&gt;形質実装&lt;/a&gt;、それが続いて実施された項目の正規のパスである &lt;code&gt;as&lt;/code&gt; 、すべての角度（で囲まれた形質に正規のパスに続く &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; ）かっこ。</target>
        </trans-unit>
        <trans-unit id="c6a4fb9e71adbfcd1bb4598c90adf218d993dcba" translate="yes" xml:space="preserve">
          <source>The path to the associated items is &lt;code&gt;&amp;lt;&lt;/code&gt; followed by a path to the implementing type followed by &lt;code&gt;as&lt;/code&gt; followed by a path to the trait followed by &lt;code&gt;&amp;gt;&lt;/code&gt; as a path component followed by the associated item's path component.</source>
          <target state="translated">関連付けられたアイテムへのパスは、 &lt;code&gt;&amp;lt;&lt;/code&gt; に続いて実装タイプへのパス、続いて &lt;code&gt;as&lt;/code&gt; に続いて特性へのパス、続いて &lt;code&gt;&amp;gt;&lt;/code&gt; がパスコンポーネントとして、関連付けられたアイテムのパスコンポーネントが続きます。</target>
        </trans-unit>
        <trans-unit id="e791bfe4c14128fe94a9448b536323c040235679" translate="yes" xml:space="preserve">
          <source>The pattern can be a &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; or a closure that determines if a character matches.</source>
          <target state="translated">パターンは、&lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;または文字が一致するかどうかを決定するクロージャーです。</target>
        </trans-unit>
        <trans-unit id="9b997b2f72267455f266b90593be72c411299620" translate="yes" xml:space="preserve">
          <source>The pattern can be a &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; or a closure that determines if a character matches.</source>
          <target state="translated">パターンは、&lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;または文字が一致するかどうかを決定するクロージャーです。</target>
        </trans-unit>
        <trans-unit id="d7a545179141a5b3642800fa8e44597af1f79a17" translate="yes" xml:space="preserve">
          <source>The pattern can be a &lt;code&gt;&amp;amp;str&lt;/code&gt;, &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, or a closure that determines if a character matches.</source>
          <target state="translated">パターンは、 &lt;code&gt;&amp;amp;str&lt;/code&gt; 、&lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;、または文字が一致するかどうかを決定するクロージャです。</target>
        </trans-unit>
        <trans-unit id="eab1bd44108e3c6ec8d1d8c6acc9fac3b5f45a9e" translate="yes" xml:space="preserve">
          <source>The pattern can be a &lt;code&gt;&amp;amp;str&lt;/code&gt;, &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, or a closure that determines if a character matches.</source>
          <target state="translated">パターンは、 &lt;code&gt;&amp;amp;str&lt;/code&gt; 、&lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;、または文字が一致するかどうかを決定するクロージャです。</target>
        </trans-unit>
        <trans-unit id="b3313c804137756973c3dae6df1f5d957a288624" translate="yes" xml:space="preserve">
          <source>The pattern can be a &lt;code&gt;&amp;amp;str&lt;/code&gt;, &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, or a closure that determines if a character matches.</source>
          <target state="translated">パターンは、 &lt;code&gt;&amp;amp;str&lt;/code&gt; 、&lt;a href=&quot;primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;、または文字が一致するかどうかを決定するクロージャです。</target>
        </trans-unit>
        <trans-unit id="bfcc6e07c89f929bc9a9b9157ac58712686768e0" translate="yes" xml:space="preserve">
          <source>The pattern can be any type that implements the Pattern trait. Notable examples are &lt;code&gt;&amp;amp;str&lt;/code&gt;, &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, and closures that determines the split.</source>
          <target state="translated">パターンは、パターントレイトを実装する任意のタイプにすることができます。注目すべき例は、 &lt;code&gt;&amp;amp;str&lt;/code&gt; 、&lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;、および分割を決定するクロージャーです。</target>
        </trans-unit>
        <trans-unit id="eb766e07c7ab39fe3b62bc217205480afe2f8cd2" translate="yes" xml:space="preserve">
          <source>The pattern can be any type that implements the Pattern trait. Notable examples are &lt;code&gt;&amp;amp;str&lt;/code&gt;, &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, and closures that determines the split. Additional libraries might provide more complex patterns like regular expressions.</source>
          <target state="translated">パターンは、パターントレイトを実装する任意のタイプにすることができます。注目すべき例は、 &lt;code&gt;&amp;amp;str&lt;/code&gt; 、&lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;、および分割を決定するクロージャーです。追加のライブラリは、正規表現のようなより複雑なパターンを提供する場合があります。</target>
        </trans-unit>
        <trans-unit id="53665fb10463c2a5a8c8a6c23b4c3d2013b572a7" translate="yes" xml:space="preserve">
          <source>The pattern can be any type that implements the Pattern trait. Notable examples are &lt;code&gt;&amp;amp;str&lt;/code&gt;, &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, and closures that determines the split.</source>
          <target state="translated">パターンは、パターントレイトを実装する任意のタイプにすることができます。注目すべき例は、 &lt;code&gt;&amp;amp;str&lt;/code&gt; 、&lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;、および分割を決定するクロージャーです。</target>
        </trans-unit>
        <trans-unit id="8059c918e0a15a39f2f09be5faf1d4cb011e74e6" translate="yes" xml:space="preserve">
          <source>The pattern can be any type that implements the Pattern trait. Notable examples are &lt;code&gt;&amp;amp;str&lt;/code&gt;, &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, and closures that determines the split. Additional libraries might provide more complex patterns like regular expressions.</source>
          <target state="translated">パターンは、パターントレイトを実装する任意のタイプにすることができます。注目すべき例は、 &lt;code&gt;&amp;amp;str&lt;/code&gt; 、&lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;、および分割を決定するクロージャーです。追加のライブラリは、正規表現のようなより複雑なパターンを提供する場合があります。</target>
        </trans-unit>
        <trans-unit id="70fe7a4be65487325b69a6e9166bdb513323e0b5" translate="yes" xml:space="preserve">
          <source>The pattern in the following example does four things:</source>
          <target state="translated">以下の例のパターンは、4つのことをしています。</target>
        </trans-unit>
        <trans-unit id="5a181811e45dbf2fc9dddcbe8e2017ec7127d78e" translate="yes" xml:space="preserve">
          <source>The pattern in the second match arm introduces a new variable named &lt;code&gt;y&lt;/code&gt; that will match any value inside a &lt;code&gt;Some&lt;/code&gt; value. Because we&amp;rsquo;re in a new scope inside the &lt;code&gt;match&lt;/code&gt; expression, this is a new &lt;code&gt;y&lt;/code&gt; variable, not the &lt;code&gt;y&lt;/code&gt; we declared at the beginning with the value 10. This new &lt;code&gt;y&lt;/code&gt; binding will match any value inside a &lt;code&gt;Some&lt;/code&gt;, which is what we have in &lt;code&gt;x&lt;/code&gt;. Therefore, this new &lt;code&gt;y&lt;/code&gt; binds to the inner value of the &lt;code&gt;Some&lt;/code&gt; in &lt;code&gt;x&lt;/code&gt;. That value is &lt;code&gt;5&lt;/code&gt;, so the expression for that arm executes and prints &lt;code&gt;Matched, y = 5&lt;/code&gt;.</source>
          <target state="translated">2番目の一致アームのパターンは、 &lt;code&gt;Some&lt;/code&gt; 値内の任意の値に一致する &lt;code&gt;y&lt;/code&gt; という名前の新しい変数を導入します。 &lt;code&gt;match&lt;/code&gt; 式内の新しいスコープにいるため、これは新しい &lt;code&gt;y&lt;/code&gt; 変数であり、最初に値10で宣言した &lt;code&gt;y&lt;/code&gt; ではありません。この新しい &lt;code&gt;y&lt;/code&gt; バインディングは、 &lt;code&gt;Some&lt;/code&gt; 内の任意の値と一致します。これは、中 &lt;code&gt;x&lt;/code&gt; 。したがって、この新しい &lt;code&gt;y&lt;/code&gt; は、 &lt;code&gt;Some&lt;/code&gt; in &lt;code&gt;x&lt;/code&gt; の内部値にバインドします。その値は &lt;code&gt;5&lt;/code&gt; なので、そのアームの式が実行され、 &lt;code&gt;Matched, y = 5&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="fd1b310fb5c60706a33dc63407dcff2f0de81ecd" translate="yes" xml:space="preserve">
          <source>The pattern is most commonly a single variable, which means no pattern matching is done and the expression given is bound to the variable. Apart from that, patterns used in &lt;code&gt;let&lt;/code&gt; bindings can be as complicated as needed, given that the pattern is exhaustive. See the &lt;a href=&quot;../book/ch06-02-match&quot;&gt;Rust book&lt;/a&gt; for more information on pattern matching. The type of the pattern is optionally given afterwards, but if left blank is automatically inferred by the compiler if possible.</source>
          <target state="translated">パターンは最も一般的には単一の変数です。つまり、パターンマッチングは行われず、指定された式は変数にバインドされます。それとは別に、 &lt;code&gt;let&lt;/code&gt; バインディングで使用されるパターンは、パターンが網羅的であることを考えると、必要に応じて複雑にすることができます。パターンマッチングの詳細については、&lt;a href=&quot;../book/ch06-02-match&quot;&gt;Rustブック&lt;/a&gt;を参照してください。パターンのタイプはオプションで後で指定できますが、空白のままにした場合は、可能であればコンパイラによって自動的に推測されます。</target>
        </trans-unit>
        <trans-unit id="c2459ac3b35f7ffa8e048896d3c16ca10cfe1608" translate="yes" xml:space="preserve">
          <source>The pattern of the first arm in the &lt;code&gt;match&lt;/code&gt; expression matches a &lt;code&gt;Message::ChangeColor&lt;/code&gt; enum variant that contains a &lt;code&gt;Color::Rgb&lt;/code&gt; variant; then the pattern binds to the three inner &lt;code&gt;i32&lt;/code&gt; values. The pattern of the second arm also matches a &lt;code&gt;Message::ChangeColor&lt;/code&gt; enum variant, but the inner enum matches the &lt;code&gt;Color::Hsv&lt;/code&gt; variant instead. We can specify these complex conditions in one &lt;code&gt;match&lt;/code&gt; expression, even though two enums are involved.</source>
          <target state="translated">&lt;code&gt;match&lt;/code&gt; 式の最初のアームのパターンは、 &lt;code&gt;Color::Rgb&lt;/code&gt; バリアントを含む &lt;code&gt;Message::ChangeColor&lt;/code&gt; enumバリアントと一致します。次に、パターンは3つの内部 &lt;code&gt;i32&lt;/code&gt; 値にバインドします。 2番目のアームのパターンも &lt;code&gt;Message::ChangeColor&lt;/code&gt; 列挙型バリアントと一致しますが、内部列挙型は &lt;code&gt;Color::Hsv&lt;/code&gt; バリアントと一致します。2つの列挙型が含まれている場合でも、1つの &lt;code&gt;match&lt;/code&gt; 式でこれらの複雑な条件を指定できます。</target>
        </trans-unit>
        <trans-unit id="a42d62f0f2bbc370e10f35406b8b10d13fb51143" translate="yes" xml:space="preserve">
          <source>The patterns programmed into Rust&amp;rsquo;s analysis of references are called the &lt;em&gt;lifetime elision rules&lt;/em&gt;. These aren&amp;rsquo;t rules for programmers to follow; they&amp;rsquo;re a set of particular cases that the compiler will consider, and if your code fits these cases, you don&amp;rsquo;t need to write the lifetimes explicitly.</source>
          <target state="translated">Rustの参照の分析にプログラムされたパターンは、&lt;em&gt;生涯省略ルール&lt;/em&gt;と呼ばれ&lt;em&gt;ます&lt;/em&gt;。これらは、プログラマが従うべき規則ではありません。これらはコンパイラが検討する特定のケースのセットであり、コードがこれらのケースに当てはまる場合は、ライフタイムを明示的に記述する必要はありません。</target>
        </trans-unit>
        <trans-unit id="012a0566d4550e7174697625c83965140d98cc31" translate="yes" xml:space="preserve">
          <source>The peer address may be set by the &lt;code&gt;connect&lt;/code&gt; method, and this method will return an error if the socket has not already been connected.</source>
          <target state="translated">ピアアドレスは、 &lt;code&gt;connect&lt;/code&gt; メソッドによって設定できます。ソケットがまだ接続されていない場合、このメソッドはエラーを返します。</target>
        </trans-unit>
        <trans-unit id="c7338ebe0eb2e257ec72f81d23df2b1d8ecc7ce7" translate="yes" xml:space="preserve">
          <source>The performance of these two features (Spoiler alert: they&amp;rsquo;re faster than you might think!)</source>
          <target state="translated">これら2つの機能のパフォーマンス（スポイラーアラート：思ったよりも高速です！）</target>
        </trans-unit>
        <trans-unit id="b42828007b197505190540700b376ffcea8793e7" translate="yes" xml:space="preserve">
          <source>The pointer is valid only if there are some strong references. The pointer may be dangling, unaligned or even &lt;a href=&quot;../ptr/fn.null&quot;&gt;&lt;code&gt;null&lt;/code&gt;&lt;/a&gt; otherwise.</source>
          <target state="translated">The pointer is valid only if there are some strong references. The pointer may be dangling, unaligned or even &lt;a href=&quot;../ptr/fn.null&quot;&gt; &lt;code&gt;null&lt;/code&gt; &lt;/a&gt; otherwise.</target>
        </trans-unit>
        <trans-unit id="3c13daf063b9e605b83028dc0feae2167ff80511" translate="yes" xml:space="preserve">
          <source>The pointer may be &lt;a href=&quot;../ptr/fn.null&quot;&gt;&lt;code&gt;null&lt;/code&gt;&lt;/a&gt; or be dangling in case the object has already been destroyed.</source>
          <target state="translated">オブジェクトがすでに破棄されている場合は、ポインタが&lt;a href=&quot;../ptr/fn.null&quot;&gt; &lt;code&gt;null&lt;/code&gt; である&lt;/a&gt;か、ぶら下がっています。</target>
        </trans-unit>
        <trans-unit id="c51f7cfe5691f3edc0397a76000e0e31815c58dc" translate="yes" xml:space="preserve">
          <source>The pointer must be &lt;a href=&quot;index#safety&quot;&gt;valid&lt;/a&gt; for reads and writes for &lt;code&gt;ptr.len() * mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; many bytes, and it must be properly aligned. This means in particular:</source>
          <target state="translated">The pointer must be &lt;a href=&quot;index#safety&quot;&gt;valid&lt;/a&gt; for reads and writes for &lt;code&gt;ptr.len() * mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; many bytes, and it must be properly aligned. This means in particular:</target>
        </trans-unit>
        <trans-unit id="2d6cc95e7b609b2c158e2115aa97ef7549141c5d" translate="yes" xml:space="preserve">
          <source>The pointer must be &lt;a href=&quot;index#safety&quot;&gt;valid&lt;/a&gt; for reads for &lt;code&gt;ptr.len() * mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; many bytes, and it must be properly aligned. This means in particular:</source>
          <target state="translated">The pointer must be &lt;a href=&quot;index#safety&quot;&gt;valid&lt;/a&gt; for reads for &lt;code&gt;ptr.len() * mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; many bytes, and it must be properly aligned. This means in particular:</target>
        </trans-unit>
        <trans-unit id="eab75a519555d7d953b751dc8250587661100bb4" translate="yes" xml:space="preserve">
          <source>The pointer must be &lt;a href=&quot;ptr/index#safety&quot;&gt;valid&lt;/a&gt; for reads and writes for &lt;code&gt;ptr.len() * mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; many bytes, and it must be properly aligned. This means in particular:</source>
          <target state="translated">The pointer must be &lt;a href=&quot;ptr/index#safety&quot;&gt;valid&lt;/a&gt; for reads and writes for &lt;code&gt;ptr.len() * mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; many bytes, and it must be properly aligned. This means in particular:</target>
        </trans-unit>
        <trans-unit id="032bd62f596d84915c186de815c7e316435955e0" translate="yes" xml:space="preserve">
          <source>The pointer must be &lt;a href=&quot;ptr/index#safety&quot;&gt;valid&lt;/a&gt; for reads for &lt;code&gt;ptr.len() * mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; many bytes, and it must be properly aligned. This means in particular:</source>
          <target state="translated">The pointer must be &lt;a href=&quot;ptr/index#safety&quot;&gt;valid&lt;/a&gt; for reads for &lt;code&gt;ptr.len() * mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; many bytes, and it must be properly aligned. This means in particular:</target>
        </trans-unit>
        <trans-unit id="ada677800eded9f5bb09a12d4c9272e1a48a79a4" translate="yes" xml:space="preserve">
          <source>The pointer must be aligned even for zero-length slices. One reason for this is that enum layout optimizations may rely on references (including slices of any length) being aligned and non-null to distinguish them from other data. You can obtain a pointer that is usable as &lt;code&gt;data&lt;/code&gt; for zero-length slices using &lt;a href=&quot;ptr/struct.nonnull#method.dangling&quot;&gt;&lt;code&gt;NonNull::dangling()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">長さがゼロのスライスの場合でも、ポインタを揃える必要があります。この理由の1つは、列挙型レイアウトの最適化では、他のデータと区別するために、参照（任意の長さのスライスを含む）が整列され、null以外であることに依存する場合があるためです。&lt;a href=&quot;ptr/struct.nonnull#method.dangling&quot;&gt; &lt;code&gt;NonNull::dangling()&lt;/code&gt; &lt;/a&gt;を使用して、長さゼロのスライスの &lt;code&gt;data&lt;/code&gt; として使用できるポインターを取得できます。</target>
        </trans-unit>
        <trans-unit id="5f6efbb545be55e13f893ac7dc6eaebbf999874a" translate="yes" xml:space="preserve">
          <source>The pointer must be aligned even for zero-length slices. One reason for this is that enum layout optimizations may rely on references (including slices of any length) being aligned and non-null to distinguish them from other data. You can obtain a pointer that is usable as &lt;code&gt;data&lt;/code&gt; for zero-length slices using &lt;a href=&quot;struct.nonnull#method.dangling&quot;&gt;&lt;code&gt;NonNull::dangling()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">長さがゼロのスライスの場合でも、ポインタを揃える必要があります。この理由の1つは、列挙型レイアウトの最適化では、他のデータと区別するために、参照（任意の長さのスライスを含む）が整列され、null以外であることに依存する場合があるためです。&lt;a href=&quot;struct.nonnull#method.dangling&quot;&gt; &lt;code&gt;NonNull::dangling()&lt;/code&gt; &lt;/a&gt;を使用して、長さゼロのスライスの &lt;code&gt;data&lt;/code&gt; として使用できるポインターを取得できます。</target>
        </trans-unit>
        <trans-unit id="7882f94a6f87dc84506e67cf6e6f86cd53b02982" translate="yes" xml:space="preserve">
          <source>The pointer must be properly aligned.</source>
          <target state="translated">ポインタは適切に配置されている必要があります。</target>
        </trans-unit>
        <trans-unit id="e3de011a05d32ff014b1d75b10f32cd8a5ceea0c" translate="yes" xml:space="preserve">
          <source>The pointer must have been obtained through &lt;code&gt;Arc::into_raw&lt;/code&gt;, and the associated &lt;code&gt;Arc&lt;/code&gt; instance must be valid (i.e. the strong count must be at least 1) for the duration of this method.</source>
          <target state="translated">ポインタは &lt;code&gt;Arc::into_raw&lt;/code&gt; を介して取得されている必要があり、関連付けられた &lt;code&gt;Arc&lt;/code&gt; インスタンスはこのメソッドの期間中有効である必要があります（つまり、ストロングカウントは少なくとも1である必要があります）。</target>
        </trans-unit>
        <trans-unit id="d97c31e45ac08eaf340466af2855c1d69a8c822f" translate="yes" xml:space="preserve">
          <source>The pointer must have been obtained through &lt;code&gt;Arc::into_raw&lt;/code&gt;, and the associated &lt;code&gt;Arc&lt;/code&gt; instance must be valid (i.e. the strong count must be at least 1) when invoking this method. This method can be used to release the final &lt;code&gt;Arc&lt;/code&gt; and backing storage, but &lt;strong&gt;should not&lt;/strong&gt; be called after the final &lt;code&gt;Arc&lt;/code&gt; has been released.</source>
          <target state="translated">ポインタは &lt;code&gt;Arc::into_raw&lt;/code&gt; を介して取得されている必要があり、このメソッドを呼び出すときは、関連付けられている &lt;code&gt;Arc&lt;/code&gt; インスタンスが有効である必要があります（つまり、ストロングカウントは少なくとも1である必要があります）。このメソッドは、最終的な &lt;code&gt;Arc&lt;/code&gt; とバッキングストレージを解放するために使用できますが、最終的な &lt;code&gt;Arc&lt;/code&gt; が解放された後に呼び出すこと&lt;strong&gt;はできません&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="15b7d63adfc51a7db20582294688b5c6c47a0e5f" translate="yes" xml:space="preserve">
          <source>The pointer must have originated from the &lt;a href=&quot;struct.weak#method.into_raw&quot;&gt;&lt;code&gt;into_raw&lt;/code&gt;&lt;/a&gt; and must still own its potential weak reference.</source>
          <target state="translated">ポインタは&lt;a href=&quot;struct.weak#method.into_raw&quot;&gt; &lt;code&gt;into_raw&lt;/code&gt; &lt;/a&gt;から発生している必要があり、潜在的な弱参照を所有している必要があります。</target>
        </trans-unit>
        <trans-unit id="561496e3426c59f66cb3091efa83ade648ff436f" translate="yes" xml:space="preserve">
          <source>The pointer must point to an initialized instance of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">ポインタは、 &lt;code&gt;T&lt;/code&gt; の初期化されたインスタンスを指している必要があります。</target>
        </trans-unit>
        <trans-unit id="d562cc44e11330190c6c67edae5c28019986b445" translate="yes" xml:space="preserve">
          <source>The pointer must represent one valid weak count. In other words, it must point to &lt;code&gt;T&lt;/code&gt; which is or &lt;em&gt;was&lt;/em&gt; managed by an &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; and the weak count of that &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; must not have reached 0. It is allowed for the strong count to be 0.</source>
          <target state="translated">ポインターは、1つの有効な弱いカウントを表す必要があります。言い換えれば、それはを指している必要があります &lt;code&gt;T&lt;/code&gt; であるか、どの&lt;em&gt;ました&lt;/em&gt;によって管理&lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt;とその弱い回数&lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt;強いカウントは0にすることが許可されて0に達していてはいけません。</target>
        </trans-unit>
        <trans-unit id="20794b93602408cab637197663bf6c675231f221" translate="yes" xml:space="preserve">
          <source>The pointer must represent one valid weak count. In other words, it must point to &lt;code&gt;T&lt;/code&gt; which is or &lt;em&gt;was&lt;/em&gt; managed by an &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; and the weak count of that &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; must not have reached 0. It is allowed for the strong count to be 0.</source>
          <target state="translated">ポインターは、1つの有効な弱いカウントを表す必要があります。言い換えれば、それはを指している必要があります &lt;code&gt;T&lt;/code&gt; であるか、&lt;em&gt;された&lt;/em&gt;ことにより、管理&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; と&lt;/a&gt;していることの弱い数&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; は&lt;/a&gt; 0であることを強くカウントに許可されて0に達していてはいけません。</target>
        </trans-unit>
        <trans-unit id="d6200eb92cc97fc1d9fec6dde1612acc6fca320f" translate="yes" xml:space="preserve">
          <source>The pointer passed to all functions inside the vtable is the &lt;code&gt;data&lt;/code&gt; pointer from the enclosing &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">vtable内のすべての関数に渡されるポインターは、囲んでいる&lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt;オブジェクトからの &lt;code&gt;data&lt;/code&gt; ポインターです。</target>
        </trans-unit>
        <trans-unit id="1edb65c05d4061d65ef7c599b48750ef7ff50704" translate="yes" xml:space="preserve">
          <source>The pointer which this function returns must be returned to Rust and reconstituted using &lt;a href=&quot;#method.from_raw&quot;&gt;&lt;code&gt;from_raw&lt;/code&gt;&lt;/a&gt; to be properly deallocated. Specifically, one should &lt;em&gt;not&lt;/em&gt; use the standard C &lt;code&gt;free()&lt;/code&gt; function to deallocate this string.</source>
          <target state="translated">この関数が返すポインタは、Rustに返され、&lt;a href=&quot;#method.from_raw&quot;&gt; &lt;code&gt;from_raw&lt;/code&gt; &lt;/a&gt;を使用して再構成されて、適切に割り当て解除される必要があります。具体的には、標準のC &lt;code&gt;free()&lt;/code&gt; 関数を使用してこの文字列の割り当てを解除し&lt;em&gt;ないで&lt;/em&gt;ください。</target>
        </trans-unit>
        <trans-unit id="80c5d8a7d931f08c90875d736c69378d02a8b64f" translate="yes" xml:space="preserve">
          <source>The pointer which this function returns must be returned to Rust and reconstituted using &lt;a href=&quot;struct.cstring#method.from_raw&quot;&gt;&lt;code&gt;CString::from_raw&lt;/code&gt;&lt;/a&gt; to be properly deallocated. Specifically, one should &lt;em&gt;not&lt;/em&gt; use the standard C &lt;code&gt;free()&lt;/code&gt; function to deallocate this string.</source>
          <target state="translated">この関数が返すポインターは、R​​ustに返され、&lt;a href=&quot;struct.cstring#method.from_raw&quot;&gt; &lt;code&gt;CString::from_raw&lt;/code&gt; &lt;/a&gt;を使用して再構成されて適切に割り当て解除される必要があります。具体的には、標準Cの &lt;code&gt;free()&lt;/code&gt; 関数を使用してこの文字列の割り当てを解除し&lt;em&gt;ないで&lt;/em&gt;ください。</target>
        </trans-unit>
        <trans-unit id="33be8edf304b61e5005625c2c6aab855fc0ce0b3" translate="yes" xml:space="preserve">
          <source>The pointer will be properly aligned and non-null.</source>
          <target state="translated">ポインタは適切に整列され、非 null になります。</target>
        </trans-unit>
        <trans-unit id="0c49a977fe21d66debc9a4c8b7d4cbbf312c9ff9" translate="yes" xml:space="preserve">
          <source>The pointer-sized signed integer type.</source>
          <target state="translated">ポインタサイズの符号付き整数型。</target>
        </trans-unit>
        <trans-unit id="aebc6996cd3e6c3ef507e0e5f263e13ad4dcb04b" translate="yes" xml:space="preserve">
          <source>The pointer-sized unsigned integer type.</source>
          <target state="translated">ポインタサイズの符号なし整数型。</target>
        </trans-unit>
        <trans-unit id="589a00e779c762d350b4058d583ec6c935c455c7" translate="yes" xml:space="preserve">
          <source>The position used for seeking with &lt;a href=&quot;enum.seekfrom#variant.Current&quot;&gt;&lt;code&gt;SeekFrom::Current&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(_)&lt;/code&gt; is the position the underlying reader would be at if the &lt;code&gt;BufReader&amp;lt;R&amp;gt;&lt;/code&gt; had no internal buffer.</source>
          <target state="translated">&lt;a href=&quot;enum.seekfrom#variant.Current&quot;&gt; &lt;code&gt;SeekFrom::Current&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(_)&lt;/code&gt; でシークするために使用される位置は、 &lt;code&gt;BufReader&amp;lt;R&amp;gt;&lt;/code&gt; 内部バッファーがない場合に基になるリーダーが存在する位置です。</target>
        </trans-unit>
        <trans-unit id="4aef48aecfebe1bd9e6f96a0939bb1d8fec84054" translate="yes" xml:space="preserve">
          <source>The position used for seeking with &lt;code&gt;SeekFrom::Current(_)&lt;/code&gt; is the position the underlying reader would be at if the &lt;code&gt;BufReader&lt;/code&gt; had no internal buffer.</source>
          <target state="translated">&lt;code&gt;SeekFrom::Current(_)&lt;/code&gt; でシークするために使用される位置は、 &lt;code&gt;BufReader&lt;/code&gt; に内部バッファーがなかった場合に、基になるリーダーが存在する位置です。</target>
        </trans-unit>
        <trans-unit id="6f1678b0e093177e7620807a9112f4ef7365e563" translate="yes" xml:space="preserve">
          <source>The positive difference of two numbers.</source>
          <target state="translated">2つの数字の正の差。</target>
        </trans-unit>
        <trans-unit id="e0a83025808dfefbef9f39106ce5fafd89bb2f1c" translate="yes" xml:space="preserve">
          <source>The practical use cases for &lt;code&gt;forget&lt;/code&gt; are rather specialized and mainly come up in unsafe or FFI code.</source>
          <target state="translated">&lt;code&gt;forget&lt;/code&gt; の実用的な使用例はかなり専門的で、主に安全でないコードまたはFFIコードで発生します。</target>
        </trans-unit>
        <trans-unit id="fb2efbc552f75b7ae8fe422ecdae2c87a030f044" translate="yes" xml:space="preserve">
          <source>The precedence of Rust operators and expressions is ordered as follows, going from strong to weak. Binary Operators at the same precedence level are grouped in the order given by their associativity.</source>
          <target state="translated">Rustの演算子や式の優先順位は、強いものから弱いものへと、以下のように順序付けされています。同じ優先度レベルのバイナリ演算子は、その連想性で与えられた順序でグループ化されています。</target>
        </trans-unit>
        <trans-unit id="5ed57a298428ca0f7395d0616c5eb17f0804c549" translate="yes" xml:space="preserve">
          <source>The precise Rust aliasing rules are somewhat in flux, but the main points are not contentious:</source>
          <target state="translated">正確なRust aliasingルールはやや流動的ですが、要点は争点にならないことです。</target>
        </trans-unit>
        <trans-unit id="b19f5cee233892caf5ddceb163f25862486da448" translate="yes" xml:space="preserve">
          <source>The precise definition is: a type &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; if and only if &lt;code&gt;&amp;amp;T&lt;/code&gt; is &lt;a href=&quot;trait.send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt;. In other words, if there is no possibility of &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;undefined behavior&lt;/a&gt; (including data races) when passing &lt;code&gt;&amp;amp;T&lt;/code&gt; references between threads.</source>
          <target state="translated">正確な定義は次のとおりです。 &lt;code&gt;&amp;amp;T&lt;/code&gt; が&lt;a href=&quot;trait.send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; である&lt;/a&gt;場合に限り、タイプ &lt;code&gt;T&lt;/code&gt; は&lt;a href=&quot;trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt;です。つまり、スレッド間で &lt;code&gt;&amp;amp;T&lt;/code&gt; 参照を渡すときに、&lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;未定義の動作&lt;/a&gt;（データの競合を含む）の可能性がない場合。</target>
        </trans-unit>
        <trans-unit id="d40bd8a03d88e20d491263cadc1752cd72c99258" translate="yes" xml:space="preserve">
          <source>The precise definition is: a type &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Sync&lt;/code&gt; if and only if &lt;code&gt;&amp;amp;T&lt;/code&gt; is &lt;a href=&quot;trait.send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt;. In other words, if there is no possibility of &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;undefined behavior&lt;/a&gt; (including data races) when passing &lt;code&gt;&amp;amp;T&lt;/code&gt; references between threads.</source>
          <target state="translated">正確な定義は次のとおりです。タイプ &lt;code&gt;T&lt;/code&gt; は、 &lt;code&gt;&amp;amp;T&lt;/code&gt; が&lt;a href=&quot;trait.send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; の&lt;/a&gt;場合にのみ &lt;code&gt;Sync&lt;/code&gt; です。つまり、スレッド間で &lt;code&gt;&amp;amp;T&lt;/code&gt; 参照を渡すときに、&lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;未定義の動作&lt;/a&gt;（データ競合を含む）の可能性がない場合。</target>
        </trans-unit>
        <trans-unit id="f47fdb8c6eff67732e48f22a8373d2422de700a9" translate="yes" xml:space="preserve">
          <source>The precise memory layout of a struct is not specified. One can specify a particular layout using the &lt;a href=&quot;../type-layout#representations&quot;&gt;&lt;code&gt;repr&lt;/code&gt; attribute&lt;/a&gt;.</source>
          <target state="translated">構造体の正確なメモリレイアウトは指定されていません。&lt;a href=&quot;../type-layout#representations&quot;&gt; &lt;code&gt;repr&lt;/code&gt; 属性&lt;/a&gt;を使用して特定のレイアウトを指定できます。</target>
        </trans-unit>
        <trans-unit id="18073d476ac74d19109a41401163857e8cd5056d" translate="yes" xml:space="preserve">
          <source>The precise rules for validity are not determined yet. The guarantees that are provided at this point are very minimal:</source>
          <target state="translated">有効性の正確なルールはまだ決定されていません。現時点で提供されている保証は非常に最小限のものです。</target>
        </trans-unit>
        <trans-unit id="4933f50236b0c7e48edc0beedb70199f13c5e285" translate="yes" xml:space="preserve">
          <source>The predicate passed to &lt;code&gt;partition()&lt;/code&gt; can return &lt;code&gt;true&lt;/code&gt;, or &lt;code&gt;false&lt;/code&gt;. &lt;code&gt;partition()&lt;/code&gt; returns a pair, all of the elements for which it returned &lt;code&gt;true&lt;/code&gt;, and all of the elements for which it returned &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;partition()&lt;/code&gt; に渡される述語は、 &lt;code&gt;true&lt;/code&gt; または &lt;code&gt;false&lt;/code&gt; を返すことができます。 &lt;code&gt;partition()&lt;/code&gt; は、ペア、 &lt;code&gt;true&lt;/code&gt; を返したすべての要素、および &lt;code&gt;false&lt;/code&gt; を返したすべての要素を返します。</target>
        </trans-unit>
        <trans-unit id="7fb4a93626b0bdb54fdbc20512bf4f76ed5cc7cd" translate="yes" xml:space="preserve">
          <source>The preferred alignment of a type.</source>
          <target state="translated">タイプの好ましい配置。</target>
        </trans-unit>
        <trans-unit id="dbc19e95dcebc744b29e267ad8d2ebfde2e212c0" translate="yes" xml:space="preserve">
          <source>The prelude can be changed to the &lt;em&gt;core prelude&lt;/em&gt; by using the &lt;code&gt;no_std&lt;/code&gt;&lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; on the root crate module. The linked crate is &lt;a href=&quot;https://doc.rust-lang.org/core/index.html&quot;&gt;&lt;code&gt;core&lt;/code&gt;&lt;/a&gt; and the prelude module is &lt;a href=&quot;https://doc.rust-lang.org/core/prelude/index.html&quot;&gt;&lt;code&gt;core::prelude::v1&lt;/code&gt;&lt;/a&gt;. Using the core prelude over the standard prelude is useful when either the crate is targeting a platform that does not support the standard library or is purposefully not using the capabilities of the standard library. Those capabilities are mainly dynamic memory allocation (e.g. &lt;code&gt;Box&lt;/code&gt; and &lt;code&gt;Vec&lt;/code&gt;) and file and network capabilities (e.g. &lt;code&gt;std::fs&lt;/code&gt; and &lt;code&gt;std::io&lt;/code&gt;).</source>
          <target state="translated">ルートクレートモジュールで &lt;code&gt;no_std&lt;/code&gt; &lt;a href=&quot;attributes&quot;&gt;属性&lt;/a&gt;を使用すると、&lt;em&gt;プレリュード&lt;/em&gt;を&lt;em&gt;コアプレリュードに&lt;/em&gt;変更できます。リンクされたクレートが&lt;a href=&quot;https://doc.rust-lang.org/core/index.html&quot;&gt; &lt;code&gt;core&lt;/code&gt; &lt;/a&gt;で、プレリュードモジュールが&lt;a href=&quot;https://doc.rust-lang.org/core/prelude/index.html&quot;&gt; &lt;code&gt;core::prelude::v1&lt;/code&gt; &lt;/a&gt;です。標準プレリュードよりもコアプレリュードを使用すると、クレートが標準ライブラリをサポートしていないプラットフォームを対象としている場合や、意図的に標準ライブラリの機能を使用していない場合に役立ちます。これらの機能は、主に動的メモリ割り当て（ &lt;code&gt;Box&lt;/code&gt; や &lt;code&gt;Vec&lt;/code&gt; など）とファイルおよびネットワーク機能（ &lt;code&gt;std::fs&lt;/code&gt; および &lt;code&gt;std::io&lt;/code&gt; ）です。</target>
        </trans-unit>
        <trans-unit id="97af9d37776d235cea4e5a19d84cc2b3492bd088" translate="yes" xml:space="preserve">
          <source>The previous Appendix D, &amp;ldquo;Macros,&amp;rdquo; has been expanded to include procedural macros and was moved to the &amp;ldquo;Macros&amp;rdquo; section in Chapter 19.</source>
          <target state="translated">以前の付録D「マクロ」は、手続き型マクロを含むように拡張され、第19章の「マクロ」セクションに移動しました。</target>
        </trans-unit>
        <trans-unit id="757bcf5f0a1b2e7c263eb1294cae88079f56068e" translate="yes" xml:space="preserve">
          <source>The previous code example fixed:</source>
          <target state="translated">前回のコード例を修正しました。</target>
        </trans-unit>
        <trans-unit id="3f0414a5a5139b7f4e08b6a8b19dea661159e39f" translate="yes" xml:space="preserve">
          <source>The previous example contains a circular dependency between two traits: &lt;code&gt;FirstTrait&lt;/code&gt; depends on &lt;code&gt;SecondTrait&lt;/code&gt; which itself depends on &lt;code&gt;FirstTrait&lt;/code&gt;.</source>
          <target state="translated">前の例には、2つの特性間の循環依存関係が含まれています &lt;code&gt;FirstTrait&lt;/code&gt; はSecondTraitに依存し、 &lt;code&gt;SecondTrait&lt;/code&gt; 自体は &lt;code&gt;FirstTrait&lt;/code&gt; に依存します。</target>
        </trans-unit>
        <trans-unit id="74a02be48083e6dc1dccc9a7d07cadacc4a53e7c" translate="yes" xml:space="preserve">
          <source>The previously duplicated code is now outside the &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; blocks and uses the &lt;code&gt;status_line&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt; variables. This makes it easier to see the difference between the two cases, and it means we have only one place to update the code if we want to change how the file reading and response writing work. The behavior of the code in Listing 20-9 will be the same as that in Listing 20-8.</source>
          <target state="translated">以前に複製されたコードは、 &lt;code&gt;if&lt;/code&gt; および &lt;code&gt;else&lt;/code&gt; ブロックの外側にあり、 &lt;code&gt;status_line&lt;/code&gt; および &lt;code&gt;filename&lt;/code&gt; 変数を使用します。これにより、2つのケースの違いを簡単に確認できます。つまり、ファイルの読み取りと応答の書き込みの動作を変更する場合、コードを更新する場所は1つだけです。コードリスト20-9のコードの動作は、コードリスト20-8と同じになります。</target>
        </trans-unit>
        <trans-unit id="3c5b34498a69e2cebc3edcacf3022a159fa0d3cf" translate="yes" xml:space="preserve">
          <source>The primary separator of path components for the current platform.</source>
          <target state="translated">現在のプラットフォームのパスコンポーネントの主なセパレータ。</target>
        </trans-unit>
        <trans-unit id="d6d94c1dd4c2a4fb7b30d949d7313e70926e43b0" translate="yes" xml:space="preserve">
          <source>The primary use for the &lt;code&gt;let&lt;/code&gt; keyword is in &lt;code&gt;let&lt;/code&gt; statements, which are used to introduce a new set of variables into the current scope, as given by a pattern.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; キーワードの主な用途は &lt;code&gt;let&lt;/code&gt; ステートメントであり、パターンで指定されたように、現在のスコープに新しい変数のセットを導入するために使用されます。</target>
        </trans-unit>
        <trans-unit id="14d97c2e9b793134fb211ba0f8484d81636a707d" translate="yes" xml:space="preserve">
          <source>The primary use of the &lt;code&gt;crate&lt;/code&gt; keyword is as a part of &lt;code&gt;extern crate&lt;/code&gt; declarations, which are used to specify a dependency on a crate external to the one it's declared in. Crates are the fundamental compilation unit of Rust code, and can be seen as libraries or projects. More can be read about crates in the &lt;a href=&quot;../reference/items/extern-crates&quot;&gt;Reference&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;crate&lt;/code&gt; キーワードの主な用途は、 &lt;code&gt;extern crate&lt;/code&gt; 宣言の一部として使用されます。これは、宣言されたものの外部にあるクレートへの依存関係を指定するために使用されます。クレートは、Rustコードの基本的なコンパイル単位であり、ライブラリと見なすことができますまたはプロジェクト。&lt;a href=&quot;../reference/items/extern-crates&quot;&gt;レファレンスで&lt;/a&gt;木箱についてもっと読むことができます。</target>
        </trans-unit>
        <trans-unit id="229057a153cb547539a5140063be86de4fd5f109" translate="yes" xml:space="preserve">
          <source>The priority policy of the lock is dependent on the underlying operating system's implementation, and this type does not guarantee that any particular policy will be used.</source>
          <target state="translated">ロックの優先度ポリシーは、基礎となるオペレーティングシステムの実装に依存しており、このタイプは特定のポリシーが使用されることを保証するものではありません。</target>
        </trans-unit>
        <trans-unit id="aa4bf60f4fab6128150a2cced20eb507a73f2223" translate="yes" xml:space="preserve">
          <source>The private address ranges are defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc1918&quot;&gt;IETF RFC 1918&lt;/a&gt; and include:</source>
          <target state="translated">プライベートアドレスの範囲は&lt;a href=&quot;https://tools.ietf.org/html/rfc1918&quot;&gt;IETF RFC 1918で&lt;/a&gt;定義されており、次のものが含まれます。</target>
        </trans-unit>
        <trans-unit id="66e536d148965eb5f5f66293b59e6e08d6c64117" translate="yes" xml:space="preserve">
          <source>The problem above can be solved by using the &lt;code&gt;ref&lt;/code&gt; keyword.</source>
          <target state="translated">上記の問題は、 &lt;code&gt;ref&lt;/code&gt; キーワードを使用して解決できます。</target>
        </trans-unit>
        <trans-unit id="a6b09f11dabd510af2bfd7f547ade1211b4999bd" translate="yes" xml:space="preserve">
          <source>The problem here is that foo is defined as accepting a parameter of type &lt;code&gt;Fn&lt;/code&gt;. Closures passed into foo will thus be inferred to be of type &lt;code&gt;Fn&lt;/code&gt;, meaning that they capture their context immutably.</source>
          <target state="translated">ここでの問題は、fooが &lt;code&gt;Fn&lt;/code&gt; 型のパラメーターを受け入れるものとして定義されていることです。したがって、fooに渡されたクロージャーは &lt;code&gt;Fn&lt;/code&gt; 型であると推測されます。つまり、コンテキストを不変にキャプチャーします。</target>
        </trans-unit>
        <trans-unit id="31cdd55efce31c6be1cacdfc4b62449817b4add1" translate="yes" xml:space="preserve">
          <source>The problem here is that if the given type or one of its fields implements the &lt;code&gt;Drop&lt;/code&gt; trait, this &lt;code&gt;Drop&lt;/code&gt; implementation cannot be called within a const context since it may run arbitrary, non-const-checked code. To prevent this issue, ensure all values with custom a custom &lt;code&gt;Drop&lt;/code&gt; implementation escape the initializer.</source>
          <target state="translated">ここでの問題は、指定されたタイプまたはそのフィールドの1つが &lt;code&gt;Drop&lt;/code&gt; 特性を実装している場合、この &lt;code&gt;Drop&lt;/code&gt; 実装は、任意の非constチェックコードを実行する可能性があるため、constコンテキスト内で呼び出すことができないことです。この問題を防ぐには、カスタムのカスタム &lt;code&gt;Drop&lt;/code&gt; 実装を持つすべての値がイニシャライザをエスケープするようにします。</target>
        </trans-unit>
        <trans-unit id="2c0a1b6d65ca057a3fdc49e919abfbdd1b60d9bd" translate="yes" xml:space="preserve">
          <source>The problem here is that the lifetime isn't contrained by any of the arguments, making it impossible to determine how long it's supposed to live.</source>
          <target state="translated">ここで問題になっているのは、その寿命がどの論法にも抵触していないことで、その寿命の長さを決めることができないということです。</target>
        </trans-unit>
        <trans-unit id="fe892e0206a6e32b9668f223826cd09ae2236ca9" translate="yes" xml:space="preserve">
          <source>The problem here is that we're attempting to take the type of X from MyTrait. Unfortunately, the type of X is not defined, because it's only made concrete in implementations of the trait. A working version of this code might look like:</source>
          <target state="translated">ここでの問題は、MyTraitからXの型を取ろうとしていることです。残念ながら、Xの型は定義されていません。このコードの動作バージョンは次のようになります。</target>
        </trans-unit>
        <trans-unit id="e5cbbff1b6bec23be456b36b8e81795c5a5d74a0" translate="yes" xml:space="preserve">
          <source>The problem is that &lt;code&gt;result&lt;/code&gt; goes out of scope and gets cleaned up at the end of the &lt;code&gt;longest&lt;/code&gt; function. We&amp;rsquo;re also trying to return a reference to &lt;code&gt;result&lt;/code&gt; from the function. There is no way we can specify lifetime parameters that would change the dangling reference, and Rust won&amp;rsquo;t let us create a dangling reference. In this case, the best fix would be to return an owned data type rather than a reference so the calling function is then responsible for cleaning up the value.</source>
          <target state="translated">問題は、 &lt;code&gt;result&lt;/code&gt; が範囲外になり、 &lt;code&gt;longest&lt;/code&gt; 関数の最後でクリーンアップされることです。また、関数からの &lt;code&gt;result&lt;/code&gt; への参照を返そうとしています。ダングリングリファレンスを変更するライフタイムパラメーターを指定する方法はありません。Rustではダングリングリファレンスを作成できません。この場合、最良の修正は、参照ではなく所有されたデータ型を返すことです。これにより、呼び出し元の関数が値をクリーンアップします。</target>
        </trans-unit>
        <trans-unit id="967a587dbf080c4427ca5b25acc74fdfbb85e443" translate="yes" xml:space="preserve">
          <source>The problem is that the first time we called &lt;code&gt;c.value&lt;/code&gt; with 1, the &lt;code&gt;Cacher&lt;/code&gt; instance saved &lt;code&gt;Some(1)&lt;/code&gt; in &lt;code&gt;self.value&lt;/code&gt;. Thereafter, no matter what we pass in to the &lt;code&gt;value&lt;/code&gt; method, it will always return 1.</source>
          <target state="translated">問題は、私たちが呼ば初めてということである &lt;code&gt;c.value&lt;/code&gt; を 1とは、 &lt;code&gt;Cacher&lt;/code&gt; インスタンスが保存された &lt;code&gt;Some(1)&lt;/code&gt; に &lt;code&gt;self.value&lt;/code&gt; 。その後、 &lt;code&gt;value&lt;/code&gt; メソッドに何を渡しても、常に1を返します。</target>
        </trans-unit>
        <trans-unit id="833738d2692abe453105a9ed609d8a8bc820fa2a" translate="yes" xml:space="preserve">
          <source>The problem is that the parameter &lt;code&gt;T&lt;/code&gt; does not appear in the implementing type (&lt;code&gt;Foo&lt;/code&gt;) of the impl. In this case, we can fix the error by moving the type parameter from the &lt;code&gt;impl&lt;/code&gt; to the method &lt;code&gt;get&lt;/code&gt;:</source>
          <target state="translated">問題は、パラメーター &lt;code&gt;T&lt;/code&gt; が実装の実装タイプ（ &lt;code&gt;Foo&lt;/code&gt; ）に表示されないことです。この場合、タイプパラメータを &lt;code&gt;impl&lt;/code&gt; からメソッド &lt;code&gt;get&lt;/code&gt; に移動することでエラーを修正できます。</target>
        </trans-unit>
        <trans-unit id="457d0fe3119f86c660d95b413dfdd79fba1ea792" translate="yes" xml:space="preserve">
          <source>The problem isn&amp;rsquo;t really with the concept but with the particular implementation. As such, Rust does not have nulls, but it does have an enum that can encode the concept of a value being present or absent. This enum is &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;, and it is &lt;a href=&quot;../std/option/enum.option&quot;&gt;defined by the standard library&lt;/a&gt; as follows:</source>
          <target state="translated">問題は、実際にはコンセプトではなく、特定の実装にあります。そのため、Rustにはnullはありませんが、存在するまたは存在しない値の概念をエンコードできる列挙型があります。この列挙型は &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; であり&lt;a href=&quot;../std/option/enum.option&quot;&gt;、標準ライブラリ&lt;/a&gt;によって次のように定義されています。</target>
        </trans-unit>
        <trans-unit id="11afe9c5b7d3b341c43395982cbb657bcfedf0f3" translate="yes" xml:space="preserve">
          <source>The problem with null values is that if you try to use a null value as a not-null value, you&amp;rsquo;ll get an error of some kind. Because this null or not-null property is pervasive, it&amp;rsquo;s extremely easy to make this kind of error.</source>
          <target state="translated">null値の問題は、null値をnot-null値として使用しようとすると、何らかのエラーが発生することです。このnullまたはnot-nullプロパティは広範囲にわたるため、この種のエラーが発生するのは非常に簡単です。</target>
        </trans-unit>
        <trans-unit id="c7ffb82b1f0d51caf9c86374d324e2fb9ccac1dd" translate="yes" xml:space="preserve">
          <source>The process lacks permissions to view the contents.</source>
          <target state="translated">このプロセスは、コンテンツを表示するための権限を欠いています。</target>
        </trans-unit>
        <trans-unit id="475777e2dbe3eb987a1fdf9f7258e8744d697a33" translate="yes" xml:space="preserve">
          <source>The process lacks permissions to view the number of hardware threads available.</source>
          <target state="translated">このプロセスには、利用可能なハードウェアスレッド数を表示する権限がありません。</target>
        </trans-unit>
        <trans-unit id="d5a1f341aa82ec15ad62b2ae6744edcef123d4a7" translate="yes" xml:space="preserve">
          <source>The process may be in a &quot;broken state&quot; if this function returns in error. For example the working directory, environment variables, signal handling settings, various user/group information, or aspects of stdio file descriptors may have changed. If a &quot;transactional spawn&quot; is required to gracefully handle errors it is recommended to use the cross-platform &lt;code&gt;spawn&lt;/code&gt; instead.</source>
          <target state="translated">この関数がエラーで戻る場合、プロセスは「壊れた状態」にある可能性があります。たとえば、作業ディレクトリ、環境変数、信号処理設定、さまざまなユーザー/グループ情報、またはstdioファイル記述子の側面が変更されている可能性があります。エラーを適切に処理するために「トランザクションスポーン」が必要な場合は、代わりにクロスプラットフォーム &lt;code&gt;spawn&lt;/code&gt; を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="68c2b04d8256c338d13f147c4eb19b87b45d4040" translate="yes" xml:space="preserve">
          <source>The programs we&amp;rsquo;ve written so far have been in one module in one file. As a project grows, you can organize code by splitting it into multiple modules and then multiple files. A package can contain multiple binary crates and optionally one library crate. As a package grows, you can extract parts into separate crates that become external dependencies. This chapter covers all these techniques. For very large projects of a set of interrelated packages that evolve together, Cargo provides workspaces, which we&amp;rsquo;ll cover in the &lt;a href=&quot;ch14-03-cargo-workspaces&quot;&gt;&amp;ldquo;Cargo Workspaces&amp;rdquo;&lt;/a&gt; section in Chapter 14.</source>
          <target state="translated">これまでに作成したプログラムは、1つのモジュールの1つのファイルに含まれています。プロジェクトが成長するにつれて、コードを複数のモジュールに分割してから複数のファイルに分割することで、コードを整理できます。パッケージには、複数のバイナリクレートと、オプションで1つのライブラリクレートを含めることができます。パッケージが大きくなると、パーツを別々のクレートに抽出して、外部依存関係にすることができます。この章では、これらすべての手法について説明します。一緒に進化する一連の相互に関連するパッケージの非常に大規模なプロジェクトに対して、Cargoはワークスペースを提供します。これについては、第14章の&lt;a href=&quot;ch14-03-cargo-workspaces&quot;&gt;「Cargoワークスペース」&lt;/a&gt;セクションで説明します。</target>
        </trans-unit>
        <trans-unit id="5cc2497d5ed1d06060f022ff65bd8b3ff66c60a9" translate="yes" xml:space="preserve">
          <source>The provided &lt;a href=&quot;struct.layout#method.size&quot;&gt;&lt;code&gt;layout.size()&lt;/code&gt;&lt;/a&gt; must fall in the range &lt;code&gt;min ..= max&lt;/code&gt;, where:</source>
          <target state="translated">提供される&lt;a href=&quot;struct.layout#method.size&quot;&gt; &lt;code&gt;layout.size()&lt;/code&gt; &lt;/a&gt;は、 &lt;code&gt;min ..= max&lt;/code&gt; 範囲内にある必要があります。ここで、</target>
        </trans-unit>
        <trans-unit id="be1cd28ce339784f890d38adb07a623811959d09" translate="yes" xml:space="preserve">
          <source>The provided &lt;code&gt;path&lt;/code&gt; doesn't exist.</source>
          <target state="translated">指定された &lt;code&gt;path&lt;/code&gt; は存在しません。</target>
        </trans-unit>
        <trans-unit id="a99e10f876c8ad74bd47e22ac1f9e01fe1760d28" translate="yes" xml:space="preserve">
          <source>The public methods &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;remove&lt;/code&gt;, and &lt;code&gt;average&lt;/code&gt; are the only ways to access or modify data in an instance of &lt;code&gt;AveragedCollection&lt;/code&gt;. When an item is added to &lt;code&gt;list&lt;/code&gt; using the &lt;code&gt;add&lt;/code&gt; method or removed using the &lt;code&gt;remove&lt;/code&gt; method, the implementations of each call the private &lt;code&gt;update_average&lt;/code&gt; method that handles updating the &lt;code&gt;average&lt;/code&gt; field as well.</source>
          <target state="translated">publicメソッド &lt;code&gt;add&lt;/code&gt; 、 &lt;code&gt;remove&lt;/code&gt; 、および &lt;code&gt;average&lt;/code&gt; は、 &lt;code&gt;AveragedCollection&lt;/code&gt; のインスタンスのデータにアクセスまたは変更する唯一の方法です。 &lt;code&gt;add&lt;/code&gt; メソッドを使用して項目を &lt;code&gt;list&lt;/code&gt; に追加するか、 &lt;code&gt;remove&lt;/code&gt; メソッドを使用して項目を削除すると、各実装は、 &lt;code&gt;average&lt;/code&gt; フィールドの更新も処理するプライベート &lt;code&gt;update_average&lt;/code&gt; メソッドを呼び出します。</target>
        </trans-unit>
        <trans-unit id="c64a2ba34c09d4f2e756bf0b0db2bf928ce82f04" translate="yes" xml:space="preserve">
          <source>The purpose of pinning is to be able to rely on the placement of some data in memory. To make this work, not just moving the data is restricted; deallocating, repurposing, or otherwise invalidating the memory used to store the data is restricted, too. Concretely, for pinned data you have to maintain the invariant that &lt;em&gt;its memory will not get invalidated or repurposed from the moment it gets pinned until when &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt; is called&lt;/em&gt;. Only once &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt; returns or panics, the memory may be reused.</source>
          <target state="translated">固定の目的は、メモリ内の一部のデータの配置に依存できるようにすることです。これを機能させるには、データの移動だけではありません。データの格納に使用されるメモリの割り当て解除、転用、または無効化も制限されます。具体的には、固定されたデータの場合、固定&lt;em&gt;された瞬間から&lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt; &lt;code&gt;drop&lt;/code&gt; &lt;/a&gt;が呼び出されるまで、そのメモリが無効化または再利用されないように&lt;/em&gt;不変条件を維持する必要があります。一度だけ&lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt; &lt;code&gt;drop&lt;/code&gt; &lt;/a&gt;リターンやパニック、メモリは再利用することができます。</target>
        </trans-unit>
        <trans-unit id="4a93f31254516d6844f82cc6e94b5893fc7d6231" translate="yes" xml:space="preserve">
          <source>The purpose of pinning is to be able to rely on the placement of some data in memory. To make this work, not just moving the data is restricted; deallocating, repurposing, or otherwise invalidating the memory used to store the data is restricted, too. Concretely, for pinned data you have to maintain the invariant that &lt;em&gt;its memory will not get invalidated or repurposed from the moment it gets pinned until when &lt;code&gt;drop&lt;/code&gt; is called&lt;/em&gt;. Memory can be invalidated by deallocation, but also by replacing a &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some(v)&lt;/code&gt;&lt;/a&gt; by &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, or calling &lt;a href=&quot;../vec/struct.vec#method.set_len&quot;&gt;&lt;code&gt;Vec::set_len&lt;/code&gt;&lt;/a&gt; to &quot;kill&quot; some elements off of a vector. It can be repurposed by using &lt;a href=&quot;../ptr/fn.write&quot;&gt;&lt;code&gt;ptr::write&lt;/code&gt;&lt;/a&gt; to overwrite it without calling the destructor first.</source>
          <target state="translated">ピン留めの目的は、メモリ内の一部のデータの配置に依存できるようにすることです。これを機能させるには、データを移動するだけでなく、データの保存に使用されるメモリの割り当て解除、転用、またはその他の方法での無効化も制限されます。具体的には、固定されたデータの場合、固定&lt;em&gt;された瞬間から &lt;code&gt;drop&lt;/code&gt; が呼び出されるまで、そのメモリが無効化または再利用されない&lt;/em&gt;という不変条件を維持する必要があります。メモリは、割り当て解除によって無効にすることができますが、&lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some(v)&lt;/code&gt; &lt;/a&gt;を&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;に置き換えるか、&lt;a href=&quot;../vec/struct.vec#method.set_len&quot;&gt; &lt;code&gt;Vec::set_len&lt;/code&gt; &lt;/a&gt;を呼び出して、ベクターからいくつかの要素を「強制終了」することによっても無効にできます。最初にデストラクタを呼び出さずにそれを上書きする&lt;a href=&quot;../ptr/fn.write&quot;&gt; &lt;code&gt;ptr::write&lt;/code&gt; &lt;/a&gt;、ptr :: writeを使用して再利用できます。</target>
        </trans-unit>
        <trans-unit id="dadde1acddaa4f2663e0f0f8fe2f53b8bd256d16" translate="yes" xml:space="preserve">
          <source>The purpose of these &lt;code&gt;Result&lt;/code&gt; types is to encode error-handling information. Values of the &lt;code&gt;Result&lt;/code&gt; type, like values of any type, have methods defined on them. An instance of &lt;code&gt;io::Result&lt;/code&gt; has an &lt;a href=&quot;../std/result/enum.result#method.expect&quot;&gt;&lt;code&gt;expect&lt;/code&gt; method&lt;/a&gt; that you can call. If this instance of &lt;code&gt;io::Result&lt;/code&gt; is an &lt;code&gt;Err&lt;/code&gt; value, &lt;code&gt;expect&lt;/code&gt; will cause the program to crash and display the message that you passed as an argument to &lt;code&gt;expect&lt;/code&gt;. If the &lt;code&gt;read_line&lt;/code&gt; method returns an &lt;code&gt;Err&lt;/code&gt;, it would likely be the result of an error coming from the underlying operating system. If this instance of &lt;code&gt;io::Result&lt;/code&gt; is an &lt;code&gt;Ok&lt;/code&gt; value, &lt;code&gt;expect&lt;/code&gt; will take the return value that &lt;code&gt;Ok&lt;/code&gt; is holding and return just that value to you so you can use it. In this case, that value is the number of bytes in what the user entered into standard input.</source>
          <target state="translated">これらの &lt;code&gt;Result&lt;/code&gt; タイプの目的は、エラー処理情報をエンコードすることです。値は &lt;code&gt;Result&lt;/code&gt; タイプは、任意の型の値のように、方法はそれらに定義されています。 &lt;code&gt;io::Result&lt;/code&gt; のインスタンスには、呼び出すことができる&lt;a href=&quot;../std/result/enum.result#method.expect&quot;&gt; &lt;code&gt;expect&lt;/code&gt; メソッド&lt;/a&gt;があります。このインスタンスならば &lt;code&gt;io::Result&lt;/code&gt; ある &lt;code&gt;Err&lt;/code&gt; 値、 &lt;code&gt;expect&lt;/code&gt; プログラムは、あなたが引数として渡されたことを示すメッセージがクラッシュして表示するようになります &lt;code&gt;expect&lt;/code&gt; 。 &lt;code&gt;read_line&lt;/code&gt; メソッドが &lt;code&gt;Err&lt;/code&gt; を返す場合、それはおそらく、基盤となるオペレーティングシステムからのエラーの結果であると考えられます。このインスタンス場合は &lt;code&gt;io::Result&lt;/code&gt; あります &lt;code&gt;Ok&lt;/code&gt; 値、 &lt;code&gt;expect&lt;/code&gt; は &lt;code&gt;Ok&lt;/code&gt; が保持している戻り値を受け取り、その値だけを返すので、使用できます。この場合、その値は、ユーザーが標準入力に入力したバイト数です。</target>
        </trans-unit>
        <trans-unit id="17a957e4dd15537d9df26e9cd567ee8ac4ab9c24" translate="yes" xml:space="preserve">
          <source>The purpose of this example is to demonstrate a situation in which some generic parameters are declared with &lt;code&gt;impl&lt;/code&gt; and some are declared with the method definition. Here, the generic parameters &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; are declared after &lt;code&gt;impl&lt;/code&gt;, because they go with the struct definition. The generic parameters &lt;code&gt;V&lt;/code&gt; and &lt;code&gt;W&lt;/code&gt; are declared after &lt;code&gt;fn mixup&lt;/code&gt;, because they&amp;rsquo;re only relevant to the method.</source>
          <target state="translated">この例の目的は、一部のジェネリックパラメーターが &lt;code&gt;impl&lt;/code&gt; で宣言され、一部がメソッド定義で宣言される状況を示すことです。ここでは、ジェネリックパラメーター &lt;code&gt;T&lt;/code&gt; と &lt;code&gt;U&lt;/code&gt; は、構造体の定義に対応しているため、 &lt;code&gt;impl&lt;/code&gt; の後に宣言されています。ジェネリックパラメーター &lt;code&gt;V&lt;/code&gt; および &lt;code&gt;W&lt;/code&gt; は、メソッドにのみ関連するため、 &lt;code&gt;fn mixup&lt;/code&gt; の後に宣言されます。</target>
        </trans-unit>
        <trans-unit id="83464f6d897f3cf3890af3a243744932372ed118" translate="yes" xml:space="preserve">
          <source>The purpose of this module is to alleviate imports of many common I/O traits by adding a glob import to the top of I/O heavy modules:</source>
          <target state="translated">このモジュールの目的は、I/Oヘビーモジュールのトップにグロブインポートを追加することで、多くの一般的なI/O形質のインポートを軽減することです。</target>
        </trans-unit>
        <trans-unit id="c5176304cb4e1480563977bff5f9fc8f29f52bf7" translate="yes" xml:space="preserve">
          <source>The purpose of trait objects is to permit &quot;late binding&quot; of methods. Calling a method on a trait object results in virtual dispatch at runtime: that is, a function pointer is loaded from the trait object vtable and invoked indirectly. The actual implementation for each vtable entry can vary on an object-by-object basis.</source>
          <target state="translated">形質オブジェクトの目的は、メソッドの「レイトバインディング」を可能にすることです。つまり、関数ポインタが trait オブジェクトの vtable からロードされ、間接的に呼び出されます。各 vtable エントリの実際の実装は、オブジェクトごとに異なります。</target>
        </trans-unit>
        <trans-unit id="f15fea39e76fdfafefd43bfce074d20361154e36" translate="yes" xml:space="preserve">
          <source>The purpose of unit tests is to test each unit of code in isolation from the rest of the code to quickly pinpoint where code is and isn&amp;rsquo;t working as expected. You&amp;rsquo;ll put unit tests in the &lt;em&gt;src&lt;/em&gt; directory in each file with the code that they&amp;rsquo;re testing. The convention is to create a module named &lt;code&gt;tests&lt;/code&gt; in each file to contain the test functions and to annotate the module with &lt;code&gt;cfg(test)&lt;/code&gt;.</source>
          <target state="translated">単体テストの目的は、コードの各ユニットを残りのコードから分離してテストし、コードが期待どおりに機能しているかどうかをすばやく特定することです。ユニットテストは、テストするコードを含む各ファイルの&lt;em&gt;src&lt;/em&gt;ディレクトリに配置します。大会は、名前のモジュールを作成することです &lt;code&gt;tests&lt;/code&gt; テスト機能を含むようにしてでモジュールに注釈を付けるために、各ファイルに &lt;code&gt;cfg(test)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="60cba1f37e61726b832a14d7f1500e4426e9a5cc" translate="yes" xml:space="preserve">
          <source>The question mark operator</source>
          <target state="translated">クエスチョンマーク演算子</target>
        </trans-unit>
        <trans-unit id="018537889ded2ab112f094946b8612c9a86b99ba" translate="yes" xml:space="preserve">
          <source>The question mark operator (&lt;code&gt;?&lt;/code&gt;) unwraps valid values or returns erroneous values, propagating them to the calling function. It is a unary postfix operator that can only be applied to the types &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; and &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">疑問符演算子（ &lt;code&gt;?&lt;/code&gt; ）は、有効な値をアンラップするか、誤った値を返し、呼び出し元の関数に伝達します。これは、タイプ &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; および &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; のみ適用できる単項後置演算子です。</target>
        </trans-unit>
        <trans-unit id="7ea5d63d0d5a319dd6d9072a4460aea03a494584" translate="yes" xml:space="preserve">
          <source>The question mark operator, &lt;code&gt;?&lt;/code&gt;</source>
          <target state="translated">疑問符演算子、 &lt;code&gt;?&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="61208bdae8b221a09aba4f839d74c11c2925c51c" translate="yes" xml:space="preserve">
          <source>The radix or base of the internal representation of &lt;code&gt;f32&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f32&lt;/code&gt; の内部表現の基数または基数。</target>
        </trans-unit>
        <trans-unit id="ea313a35fa236b37b46428fb2657491b2e33dea3" translate="yes" xml:space="preserve">
          <source>The radix or base of the internal representation of &lt;code&gt;f32&lt;/code&gt;. Use &lt;a href=&quot;../primitive.f32#associatedconstant.RADIX&quot;&gt;&lt;code&gt;f32::RADIX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;code&gt;f32&lt;/code&gt; の内部表現の基数または基数。代わりに&lt;a href=&quot;../primitive.f32#associatedconstant.RADIX&quot;&gt; &lt;code&gt;f32::RADIX&lt;/code&gt; &lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="fc170d8fddda3392ca3bbfeb02d09cfb7f6a80ce" translate="yes" xml:space="preserve">
          <source>The radix or base of the internal representation of &lt;code&gt;f64&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f64&lt;/code&gt; の内部表現の基数または基数。</target>
        </trans-unit>
        <trans-unit id="eb77af93de4b13de0ebcbd9266a033e54a3960fe" translate="yes" xml:space="preserve">
          <source>The radix or base of the internal representation of &lt;code&gt;f64&lt;/code&gt;. Use &lt;a href=&quot;../primitive.f64#associatedconstant.RADIX&quot;&gt;&lt;code&gt;f64::RADIX&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;code&gt;f64&lt;/code&gt; の内部表現の基数または基数。代わりに&lt;a href=&quot;../primitive.f64#associatedconstant.RADIX&quot;&gt; &lt;code&gt;f64::RADIX&lt;/code&gt; &lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="0b9457bd197a286afc52dbcebb942e61605b222d" translate="yes" xml:space="preserve">
          <source>The range &lt;code&gt;start..end&lt;/code&gt; contains all values with &lt;code&gt;start &amp;lt;= x &amp;lt; end&lt;/code&gt;. It is empty if &lt;code&gt;start &amp;gt;= end&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;start..end&lt;/code&gt; の範囲には、 &lt;code&gt;start &amp;lt;= x &amp;lt; end&lt;/code&gt; すべての値が含まれます。 &lt;code&gt;start &amp;gt;= end&lt;/code&gt; 場合、空です。</target>
        </trans-unit>
        <trans-unit id="510a943d569cb4f1080072d01ababcb91699bcc6" translate="yes" xml:space="preserve">
          <source>The range is empty if either side is incomparable:</source>
          <target state="translated">どちらか一方が比較不可能な場合は範囲が空になります。</target>
        </trans-unit>
        <trans-unit id="a7d43b8cf204eefd21645fceff96d69cfb297982" translate="yes" xml:space="preserve">
          <source>The raw pointer must have been previously returned by a call to &lt;a href=&quot;struct.arc#method.into_raw&quot;&gt;&lt;code&gt;Arc&amp;lt;U&amp;gt;::into_raw&lt;/code&gt;&lt;/a&gt; where &lt;code&gt;U&lt;/code&gt; must have the same size and alignment as &lt;code&gt;T&lt;/code&gt;. This is trivially true if &lt;code&gt;U&lt;/code&gt; is &lt;code&gt;T&lt;/code&gt;. Note that if &lt;code&gt;U&lt;/code&gt; is not &lt;code&gt;T&lt;/code&gt; but has the same size and alignment, this is basically like transmuting references of different types. See &lt;a href=&quot;../mem/fn.transmute&quot;&gt;&lt;code&gt;mem::transmute&lt;/code&gt;&lt;/a&gt; for more information on what restrictions apply in this case.</source>
          <target state="translated">生のポインタは、&lt;a href=&quot;struct.arc#method.into_raw&quot;&gt; &lt;code&gt;Arc&amp;lt;U&amp;gt;::into_raw&lt;/code&gt; &lt;/a&gt;呼び出しによって以前に返されている必要があります。ここで、 &lt;code&gt;U&lt;/code&gt; は &lt;code&gt;T&lt;/code&gt; と同じサイズと配置である必要があります。 &lt;code&gt;U&lt;/code&gt; が &lt;code&gt;T&lt;/code&gt; の場合、これは自明に当てはまります。 &lt;code&gt;U&lt;/code&gt; が &lt;code&gt;T&lt;/code&gt; ではないが、サイズと配置が同じである場合、これは基本的に、異なるタイプの参照を変換するようなものであることに注意してください。この場合に適用される制限の詳細については、&lt;a href=&quot;../mem/fn.transmute&quot;&gt; &lt;code&gt;mem::transmute&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="7a2067413bc1879d44bf7542436c24e1555ca1bc" translate="yes" xml:space="preserve">
          <source>The raw pointer must have been previously returned by a call to &lt;a href=&quot;struct.rc#method.into_raw&quot;&gt;&lt;code&gt;Rc&amp;lt;U&amp;gt;::into_raw&lt;/code&gt;&lt;/a&gt; where &lt;code&gt;U&lt;/code&gt; must have the same size and alignment as &lt;code&gt;T&lt;/code&gt;. This is trivially true if &lt;code&gt;U&lt;/code&gt; is &lt;code&gt;T&lt;/code&gt;. Note that if &lt;code&gt;U&lt;/code&gt; is not &lt;code&gt;T&lt;/code&gt; but has the same size and alignment, this is basically like transmuting references of different types. See &lt;a href=&quot;../mem/fn.transmute&quot;&gt;&lt;code&gt;mem::transmute&lt;/code&gt;&lt;/a&gt; for more information on what restrictions apply in this case.</source>
          <target state="translated">生のポインタは、&lt;a href=&quot;struct.rc#method.into_raw&quot;&gt; &lt;code&gt;Rc&amp;lt;U&amp;gt;::into_raw&lt;/code&gt; &lt;/a&gt;呼び出しによって以前に返されている必要があります。ここで、 &lt;code&gt;U&lt;/code&gt; は &lt;code&gt;T&lt;/code&gt; と同じサイズと配置である必要があります。 &lt;code&gt;U&lt;/code&gt; が &lt;code&gt;T&lt;/code&gt; の場合、これは自明に当てはまります。 &lt;code&gt;U&lt;/code&gt; が &lt;code&gt;T&lt;/code&gt; ではないが、サイズと配置が同じである場合、これは基本的に、異なるタイプの参照を変換するようなものであることに注意してください。この場合に適用される制限の詳細については、&lt;a href=&quot;../mem/fn.transmute&quot;&gt; &lt;code&gt;mem::transmute&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="9cc134868dea70688318900dea4fb56c096c2fce" translate="yes" xml:space="preserve">
          <source>The raw pointer must have been previously returned by a call to a &lt;a href=&quot;struct.arc#method.into_raw&quot;&gt;&lt;code&gt;Arc::into_raw&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">生のポインタは、以前に&lt;a href=&quot;struct.arc#method.into_raw&quot;&gt; &lt;code&gt;Arc::into_raw&lt;/code&gt; &lt;/a&gt;呼び出しによって返されている必要があります。</target>
        </trans-unit>
        <trans-unit id="cb442a6e9f4c3ea3ad88f7d20cbb90e50f086583" translate="yes" xml:space="preserve">
          <source>The raw pointer must have been previously returned by a call to a &lt;a href=&quot;struct.rc#method.into_raw&quot;&gt;&lt;code&gt;Rc::into_raw&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">生のポインタは、&lt;a href=&quot;struct.rc#method.into_raw&quot;&gt; &lt;code&gt;Rc::into_raw&lt;/code&gt; &lt;/a&gt;呼び出しによって以前に返されている必要があります。</target>
        </trans-unit>
        <trans-unit id="61edb86c6e775bcbcc090bf0b2354d8086752aee" translate="yes" xml:space="preserve">
          <source>The re-ordering prevented by the different ordering semantics are:</source>
          <target state="translated">異なる順序のセマンティクスによって防止される再順序化は</target>
        </trans-unit>
        <trans-unit id="db75fd7d163698847a2930407a821664ef9dc7a1" translate="yes" xml:space="preserve">
          <source>The reading portion of the &lt;a href=&quot;struct.tcpstream&quot;&gt;&lt;code&gt;TcpStream&lt;/code&gt;&lt;/a&gt; should be shut down.</source>
          <target state="translated">&lt;a href=&quot;struct.tcpstream&quot;&gt; &lt;code&gt;TcpStream&lt;/code&gt; &lt;/a&gt;の読み取り部分をシャットダウンする必要があります。</target>
        </trans-unit>
        <trans-unit id="bb2e18a8faa1f91810d19956a7143af41d8b7e9f" translate="yes" xml:space="preserve">
          <source>The reason for deprecation is that the function basically cannot be used correctly: &lt;a href=&quot;union.maybeuninit#initialization-invariant&quot;&gt;the Rust compiler assumes&lt;/a&gt; that values are properly initialized. As a consequence, calling e.g. &lt;code&gt;mem::uninitialized::&amp;lt;bool&amp;gt;()&lt;/code&gt; causes immediate undefined behavior for returning a &lt;code&gt;bool&lt;/code&gt; that is not definitely either &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. Worse, truly uninitialized memory like what gets returned here is special in that the compiler knows that it does not have a fixed value. This makes it undefined behavior to have uninitialized data in a variable even if that variable has an integer type. (Notice that the rules around uninitialized integers are not finalized yet, but until they are, it is advisable to avoid them.)</source>
          <target state="translated">非推奨の理由は、関数が基本的に正しく使用できないためです&lt;a href=&quot;union.maybeuninit#initialization-invariant&quot;&gt;。Rustコンパイラは&lt;/a&gt;、値が適切に初期化されていると想定します。結果として、たとえば &lt;code&gt;mem::uninitialized::&amp;lt;bool&amp;gt;()&lt;/code&gt; を呼び出すと、明確に &lt;code&gt;true&lt;/code&gt; または &lt;code&gt;false&lt;/code&gt; のいずれでもない &lt;code&gt;bool&lt;/code&gt; を返すための即時の未定義の動作が発生します。ここで返されるような本当に初期化されていないさらに悪いメモリは、コンパイラが固定値を持たないことを知っているという点で特別です。これにより、変数の型が整数型であっても、変数に初期化されていないデータがあることは未定義の動作になります。 （初期化されていない整数に関するルールはまだ確定されていないことに注意してください。ただし、確定されるまでは、回避することをお勧めします。）</target>
        </trans-unit>
        <trans-unit id="0a840dd2de2cd2ee34a26f979453151250b4e843" translate="yes" xml:space="preserve">
          <source>The reason for deprecation is that the function basically cannot be used correctly: it has the same effect as &lt;a href=&quot;union.maybeuninit#method.uninit&quot;&gt;&lt;code&gt;MaybeUninit::uninit().assume_init()&lt;/code&gt;&lt;/a&gt;. As the &lt;a href=&quot;union.maybeuninit#method.assume_init&quot;&gt;&lt;code&gt;assume_init&lt;/code&gt; documentation&lt;/a&gt; explains, &lt;a href=&quot;union.maybeuninit#initialization-invariant&quot;&gt;the Rust compiler assumes&lt;/a&gt; that values are properly initialized. As a consequence, calling e.g. &lt;code&gt;mem::uninitialized::&amp;lt;bool&amp;gt;()&lt;/code&gt; causes immediate undefined behavior for returning a &lt;code&gt;bool&lt;/code&gt; that is not definitely either &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. Worse, truly uninitialized memory like what gets returned here is special in that the compiler knows that it does not have a fixed value. This makes it undefined behavior to have uninitialized data in a variable even if that variable has an integer type. (Notice that the rules around uninitialized integers are not finalized yet, but until they are, it is advisable to avoid them.)</source>
          <target state="translated">非推奨の理由は、関数が基本的に正しく使用できないためです&lt;a href=&quot;union.maybeuninit#method.uninit&quot;&gt; &lt;code&gt;MaybeUninit::uninit().assume_init()&lt;/code&gt; &lt;/a&gt;と同じ効果があります。以下のよう&lt;a href=&quot;union.maybeuninit#method.assume_init&quot;&gt; &lt;code&gt;assume_init&lt;/code&gt; のドキュメントを&lt;/a&gt;説明し、&lt;a href=&quot;union.maybeuninit#initialization-invariant&quot;&gt;錆コンパイラは想定してい&lt;/a&gt;た値が正しく初期化されていること。結果として、たとえば &lt;code&gt;mem::uninitialized::&amp;lt;bool&amp;gt;()&lt;/code&gt; を呼び出すと、 &lt;code&gt;bool&lt;/code&gt; を返すための未定義の動作が即座に発生しますが、これは間違いなく &lt;code&gt;true&lt;/code&gt; または &lt;code&gt;false&lt;/code&gt; ではありません。。さらに悪いことに、ここで返されるような真に初期化されていないメモリは、コンパイラが固定値を持たないことを認識しているという点で特別です。これにより、変数が整数型であっても、変数に初期化されていないデータが含まれることは未定義の動作になります。 （初期化されていない整数に関するルールはまだ確定されていませんが、確定するまでは回避することをお勧めします。）</target>
        </trans-unit>
        <trans-unit id="d5d0c9e3177e947296d0e4cad464419f6391db88" translate="yes" xml:space="preserve">
          <source>The reason for this is that &lt;code&gt;rlib&lt;/code&gt; files do not contain any of their upstream dependencies. It wouldn't be very efficient for all &lt;code&gt;rlib&lt;/code&gt; files to contain a copy of &lt;code&gt;libstd.rlib&lt;/code&gt;!</source>
          <target state="translated">これは、 &lt;code&gt;rlib&lt;/code&gt; ファイルに上流の依存関係が含まれていないためです。すべての &lt;code&gt;rlib&lt;/code&gt; ファイルに &lt;code&gt;libstd.rlib&lt;/code&gt; のコピーを含めるのは効率的ではありません。</target>
        </trans-unit>
        <trans-unit id="f95aa7105ee4000143fc92462b837053383a52a0" translate="yes" xml:space="preserve">
          <source>The reason for this is that there are two appearances of type parameter &lt;code&gt;T&lt;/code&gt; in the &lt;code&gt;impl&lt;/code&gt; header, both as parameters for &lt;code&gt;ForeignTrait2&lt;/code&gt;. The first appearance is uncovered, and so runs afoul of the orphan rule.</source>
          <target state="translated">これは、 &lt;code&gt;impl&lt;/code&gt; ヘッダーにタイプパラメーター &lt;code&gt;T&lt;/code&gt; の外観が2つあり、どちらも &lt;code&gt;ForeignTrait2&lt;/code&gt; のパラメーターであるためです。初登場が明らかになり、孤児のルールに反する。</target>
        </trans-unit>
        <trans-unit id="ef37c27a4f0dd2645ce86c85a75eac6a77fa29d9" translate="yes" xml:space="preserve">
          <source>The reason is that types such as integers that have a known size at compile time are stored entirely on the stack, so copies of the actual values are quick to make. That means there&amp;rsquo;s no reason we would want to prevent &lt;code&gt;x&lt;/code&gt; from being valid after we create the variable &lt;code&gt;y&lt;/code&gt;. In other words, there&amp;rsquo;s no difference between deep and shallow copying here, so calling &lt;code&gt;clone&lt;/code&gt; wouldn&amp;rsquo;t do anything different from the usual shallow copying and we can leave it out.</source>
          <target state="translated">その理由は、コンパイル時に既知のサイズを持つ整数などの型は完全にスタックに格納されるため、実際の値のコピーをすばやく作成できるためです。つまり、変数 &lt;code&gt;y&lt;/code&gt; を作成した後で &lt;code&gt;x&lt;/code&gt; が有効にならないようにする理由はありません。つまり、ここではディープコピーとシャローコピーに違いはないため、 &lt;code&gt;clone&lt;/code&gt; を呼び出しても通常のシャローコピーと何も変わらないため、省略できます。</target>
        </trans-unit>
        <trans-unit id="5c1ca57165d895e7b5a9a07fb8f81dd8e653560f" translate="yes" xml:space="preserve">
          <source>The reason is that you&amp;rsquo;re missing some crucial information: a description and license are required so people will know what your crate does and under what terms they can use it. To rectify this error, you need to include this information in the &lt;em&gt;Cargo.toml&lt;/em&gt; file.</source>
          <target state="translated">その理由は、重要な情報が不足しているためです。説明とライセンスが必要なので、クレートの機能とクレートを使用できる条件を人々に知らせます。このエラーを修正するには、&lt;em&gt;Cargo.toml&lt;/em&gt;ファイルにこの情報を含める必要があります。</target>
        </trans-unit>
        <trans-unit id="87dec969a1d8a7fd52229930c681793b58499b7c" translate="yes" xml:space="preserve">
          <source>The reason is that, in the first example, there are many possible types that &lt;code&gt;!&lt;/code&gt; could coerce to, because many types implement &lt;code&gt;Add&amp;lt;u32&amp;gt;&lt;/code&gt;. However, in the second example, the &lt;code&gt;else&lt;/code&gt; branch returns a &lt;code&gt;0&lt;/code&gt;, which the compiler infers from the return type to be of type &lt;code&gt;u32&lt;/code&gt;. Since &lt;code&gt;u32&lt;/code&gt; is a concrete type, &lt;code&gt;!&lt;/code&gt; can and will be coerced to it. See issue &lt;a href=&quot;https://github.com/rust-lang/rust/issues/36375&quot;&gt;#36375&lt;/a&gt; for more information on this quirk of &lt;code&gt;!&lt;/code&gt;.</source>
          <target state="translated">その理由は、最初の例では、 &lt;code&gt;!&lt;/code&gt; 多くのタイプが &lt;code&gt;Add&amp;lt;u32&amp;gt;&lt;/code&gt; 実装しているため、強制することができます。ただし、2番目の例では、 &lt;code&gt;else&lt;/code&gt; ブランチは &lt;code&gt;0&lt;/code&gt; を返します。これは、コンパイラーが戻り値の型から &lt;code&gt;u32&lt;/code&gt; 型であると推測します。以来 &lt;code&gt;u32&lt;/code&gt; 、具体的なタイプです &lt;code&gt;!&lt;/code&gt; 強制される可能性があります。この癖の詳細については、問題&lt;a href=&quot;https://github.com/rust-lang/rust/issues/36375&quot;&gt;＃36375&lt;/a&gt;を参照してください &lt;code&gt;!&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="725753993f38910ecfb713203cf3afe96ff590f2" translate="yes" xml:space="preserve">
          <source>The reason that this matter is that the type &lt;code&gt;fn(S)&lt;/code&gt; is not specific to any particular function: it's a function &lt;em&gt;pointer&lt;/em&gt;. So calling &lt;code&gt;x()&lt;/code&gt; results in a virtual call, whereas &lt;code&gt;foo()&lt;/code&gt; is statically dispatched, because the type of &lt;code&gt;foo&lt;/code&gt; tells us precisely what function is being called.</source>
          <target state="translated">この問題の理由は、 &lt;code&gt;fn(S)&lt;/code&gt; 型が特定の関数に固有ではないことです。これは、関数&lt;em&gt;ポインター&lt;/em&gt;です。呼び出しだから、 &lt;code&gt;x()&lt;/code&gt; に対し、仮想呼び出しでの結果、 &lt;code&gt;foo()&lt;/code&gt; タイプするので、静的に、派遣された &lt;code&gt;foo&lt;/code&gt; が呼び出されている正確にどのような機能を教えてくれる。</target>
        </trans-unit>
        <trans-unit id="2f71ddaa6e32a7d6efaff9da8a4ddd4766615cbe" translate="yes" xml:space="preserve">
          <source>The reason the &lt;code&gt;deref&lt;/code&gt; method returns a reference to a value, and that the plain dereference outside the parentheses in &lt;code&gt;*(y.deref())&lt;/code&gt; is still necessary, is the ownership system. If the &lt;code&gt;deref&lt;/code&gt; method returned the value directly instead of a reference to the value, the value would be moved out of &lt;code&gt;self&lt;/code&gt;. We don&amp;rsquo;t want to take ownership of the inner value inside &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; in this case or in most cases where we use the dereference operator.</source>
          <target state="translated">その理由は、 &lt;code&gt;deref&lt;/code&gt; 方法は、値への参照を返し、そして中括弧外普通間接参照することを &lt;code&gt;*(y.deref())&lt;/code&gt; は依然として必要であり、所有権システムです。場合 &lt;code&gt;deref&lt;/code&gt; 方法は、値を直接代わりの値への参照が返され、値が外に移動される &lt;code&gt;self&lt;/code&gt; 。この場合、または逆参照演算子を使用するほとんどの場合、 &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; 内の内部値の所有権を取得したくありません。</target>
        </trans-unit>
        <trans-unit id="1d62bb1a32655921533dae07c7931836afe25a19" translate="yes" xml:space="preserve">
          <source>The reason this function compiles without lifetime annotations is historical: in early versions (pre-1.0) of Rust, this code wouldn&amp;rsquo;t have compiled because every reference needed an explicit lifetime. At that time, the function signature would have been written like this:</source>
          <target state="translated">この関数がライフタイムアノテーションなしでコンパイルする理由は歴史的です。Rustの初期バージョン（1.0より前）では、すべての参照に明示的なライフタイムが必要だったため、このコードはコンパイルされませんでした。当時、関数のシグネチャは次のように書かれているはずです。</target>
        </trans-unit>
        <trans-unit id="bedb5e3116e5d92919b43a452878e5db1b96099b" translate="yes" xml:space="preserve">
          <source>The reason we&amp;rsquo;re able to use &lt;code&gt;&amp;amp;s2&lt;/code&gt; in the call to &lt;code&gt;add&lt;/code&gt; is that the compiler can &lt;em&gt;coerce&lt;/em&gt; the &lt;code&gt;&amp;amp;String&lt;/code&gt; argument into a &lt;code&gt;&amp;amp;str&lt;/code&gt;. When we call the &lt;code&gt;add&lt;/code&gt; method, Rust uses a &lt;em&gt;deref coercion&lt;/em&gt;, which here turns &lt;code&gt;&amp;amp;s2&lt;/code&gt; into &lt;code&gt;&amp;amp;s2[..]&lt;/code&gt;. We&amp;rsquo;ll discuss deref coercion in more depth in Chapter 15. Because &lt;code&gt;add&lt;/code&gt; does not take ownership of the &lt;code&gt;s&lt;/code&gt; parameter, &lt;code&gt;s2&lt;/code&gt; will still be a valid &lt;code&gt;String&lt;/code&gt; after this operation.</source>
          <target state="translated">我々が使用することができるしている理由 &lt;code&gt;&amp;amp;s2&lt;/code&gt; への呼び出しに &lt;code&gt;add&lt;/code&gt; はコンパイラができるということです&lt;em&gt;強制&lt;/em&gt; &lt;code&gt;&amp;amp;String&lt;/code&gt; に引数を &lt;code&gt;&amp;amp;str&lt;/code&gt; 。私たちが呼び出すと &lt;code&gt;add&lt;/code&gt; 方法を、錆が使用しています&lt;em&gt;被参照強制&lt;/em&gt;ここになり、 &lt;code&gt;&amp;amp;s2&lt;/code&gt; に &lt;code&gt;&amp;amp;s2[..]&lt;/code&gt; 。ので、我々は第15章で詳しく被参照強制を説明します &lt;code&gt;add&lt;/code&gt; 所有取らない &lt;code&gt;s&lt;/code&gt; パラメータを、 &lt;code&gt;s2&lt;/code&gt; はまだ有効になります &lt;code&gt;String&lt;/code&gt; この操作の後。</target>
        </trans-unit>
        <trans-unit id="f3cfdfa90a10325648e4c2eb952b413419929140" translate="yes" xml:space="preserve">
          <source>The receiver of a method, or the current module.</source>
          <target state="translated">メソッドの受信機、または現在のモジュール。</target>
        </trans-unit>
        <trans-unit id="d73164a885c270ed79f7ee9c783984160bde564d" translate="yes" xml:space="preserve">
          <source>The receiving end of a channel has two useful methods: &lt;code&gt;recv&lt;/code&gt; and &lt;code&gt;try_recv&lt;/code&gt;. We&amp;rsquo;re using &lt;code&gt;recv&lt;/code&gt;, short for &lt;em&gt;receive&lt;/em&gt;, which will block the main thread&amp;rsquo;s execution and wait until a value is sent down the channel. Once a value is sent, &lt;code&gt;recv&lt;/code&gt; will return it in a &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;. When the sending end of the channel closes, &lt;code&gt;recv&lt;/code&gt; will return an error to signal that no more values will be coming.</source>
          <target state="translated">チャネルの受信側には、 &lt;code&gt;recv&lt;/code&gt; と &lt;code&gt;try_recv&lt;/code&gt; の 2つの便利なメソッドがあります。ここでは&lt;em&gt;receiveの&lt;/em&gt;略である &lt;code&gt;recv&lt;/code&gt; を使用しています。これはメインスレッドの実行をブロックし、値がチャネルに送信されるまで待機します。値が送信されると、 &lt;code&gt;recv&lt;/code&gt; はそれを &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 返します。チャネルの送信側が閉じると、 &lt;code&gt;recv&lt;/code&gt; はエラーを返し、これ以上値が送信されないことを通知します。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bb4caae3b66529c5330d18c3a08329f2bc2f3deb" translate="yes" xml:space="preserve">
          <source>The receiving half of Rust's &lt;a href=&quot;fn.channel&quot;&gt;&lt;code&gt;channel&lt;/code&gt;&lt;/a&gt; (or &lt;a href=&quot;fn.sync_channel&quot;&gt;&lt;code&gt;sync_channel&lt;/code&gt;&lt;/a&gt;) type. This half can only be owned by one thread.</source>
          <target state="translated">Rustの&lt;a href=&quot;fn.channel&quot;&gt; &lt;code&gt;channel&lt;/code&gt; &lt;/a&gt;（または&lt;a href=&quot;fn.sync_channel&quot;&gt; &lt;code&gt;sync_channel&lt;/code&gt; &lt;/a&gt;）タイプの受信側。この半分は1つのスレッドだけが所有できます。</target>
        </trans-unit>
        <trans-unit id="8b2bfb185407e4c60c25d227a4ff77b2cda29f86" translate="yes" xml:space="preserve">
          <source>The reference count of the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; instances in both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are 2 after we change the list in &lt;code&gt;a&lt;/code&gt; to point to &lt;code&gt;b&lt;/code&gt;. At the end of &lt;code&gt;main&lt;/code&gt;, Rust will try to drop &lt;code&gt;b&lt;/code&gt; first, which will decrease the count of the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; instance in &lt;code&gt;b&lt;/code&gt; by 1.</source>
          <target state="translated">参照カウント &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 、両方のインスタンスで &lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; 我々がリスト変更した後、2、にポイントに &lt;code&gt;b&lt;/code&gt; 。 &lt;code&gt;main&lt;/code&gt; の最後で、Rustは最初に &lt;code&gt;b&lt;/code&gt; をドロップしようとします。これにより、 &lt;code&gt;b&lt;/code&gt; の &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; インスタンスの数が1つ減ります。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0309be91bd54044d4044342a0389163de0a934e4" translate="yes" xml:space="preserve">
          <source>The region of memory beginning at &lt;code&gt;src&lt;/code&gt; with a size of &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; bytes must &lt;em&gt;not&lt;/em&gt; overlap with the region of memory beginning at &lt;code&gt;dst&lt;/code&gt; with the same size.</source>
          <target state="translated">&lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; バイトのサイズの &lt;code&gt;src&lt;/code&gt; で始まるメモリ領域は、同じサイズの &lt;code&gt;dst&lt;/code&gt; で始まるメモリ領域と重複してはなりませ&lt;em&gt;ん&lt;/em&gt;。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5dcc17f2dc1b8084d38071ff6ddcb2865d4ada36" translate="yes" xml:space="preserve">
          <source>The region of memory beginning at &lt;code&gt;x&lt;/code&gt; with a size of &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; bytes must &lt;em&gt;not&lt;/em&gt; overlap with the region of memory beginning at &lt;code&gt;y&lt;/code&gt; with the same size.</source>
          <target state="translated">&lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; バイトのサイズで &lt;code&gt;x&lt;/code&gt; で始まるメモリ領域は、同じサイズで &lt;code&gt;y&lt;/code&gt; で始まるメモリ領域と重複してはなりませ&lt;em&gt;ん&lt;/em&gt;。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6e24cbd3ed4b7a19863f8c010bc7cecf513544b8" translate="yes" xml:space="preserve">
          <source>The relative order of partitioned items is not maintained.</source>
          <target state="translated">分割された項目の相対的な順序が維持されない。</target>
        </trans-unit>
        <trans-unit id="27d262cc92a6d55445ae1cc06ba8d24d6a4bfc8a" translate="yes" xml:space="preserve">
          <source>The relevant &lt;code&gt;use&lt;/code&gt; statements</source>
          <target state="translated">関連する &lt;code&gt;use&lt;/code&gt; ステートメント</target>
        </trans-unit>
        <trans-unit id="92055677c3977ae45c2e91b99d3cb2b7bc2e7a00" translate="yes" xml:space="preserve">
          <source>The remainder assignment operator &lt;code&gt;%=&lt;/code&gt;.</source>
          <target state="translated">剰余代入演算子 &lt;code&gt;%=&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7e1e6181542061352f1920b8d99d81207a670f7f" translate="yes" xml:space="preserve">
          <source>The remainder from the division of two floats.</source>
          <target state="translated">2つの山車の分割からの残り。</target>
        </trans-unit>
        <trans-unit id="054039eee5819e5face98778f38bf1e0291c343e" translate="yes" xml:space="preserve">
          <source>The remainder has the same sign as the dividend and is computed as: &lt;code&gt;x - (x / y).trunc() * y&lt;/code&gt;.</source>
          <target state="translated">剰余は被除数と同じ符号を持ち、次のように計算されます： &lt;code&gt;x - (x / y).trunc() * y&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5654d619adf6380504b572e1ea12d7691a4525f9" translate="yes" xml:space="preserve">
          <source>The remainder operator &lt;code&gt;%&lt;/code&gt;.</source>
          <target state="translated">剰余演算子 &lt;code&gt;%&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4b313ceee14929f12b1b754da920f2c480594a9a" translate="yes" xml:space="preserve">
          <source>The remaining characters are alphanumeric or &lt;code&gt;_&lt;/code&gt;.</source>
          <target state="translated">残りの文字は英数字または &lt;code&gt;_&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="db31fc17b3b16891bdde4b2e11c17a8b55001a20" translate="yes" xml:space="preserve">
          <source>The removed element is replaced by the last element of the vector.</source>
          <target state="translated">削除された要素は、ベクトルの最後の要素に置き換えられます。</target>
        </trans-unit>
        <trans-unit id="bdcb1bbcfc5506185f4dcdac6bb92b93d0ea27b3" translate="yes" xml:space="preserve">
          <source>The repeated fragment both matches and transcribes to the specified number of the fragment, separated by the separator token. Metavariables are matched to every repetition of their corresponding fragment. For instance, the &lt;code&gt;$( $i:ident ),*&lt;/code&gt; example above matches &lt;code&gt;$i&lt;/code&gt; to all of the identifiers in the list.</source>
          <target state="translated">繰り返されるフラグメントは、セパレータトークンで区切られた、指定された数のフラグメントに一致および転記します。メタ変数は、対応するフラグメントのすべての繰り返しに一致します。たとえば、上記の &lt;code&gt;$( $i:ident ),*&lt;/code&gt; 例は、 &lt;code&gt;$i&lt;/code&gt; をリスト内のすべての識別子と照合します。</target>
        </trans-unit>
        <trans-unit id="12103d0e7fb92d8d3b9ddae239cdf39dea7eeb65" translate="yes" xml:space="preserve">
          <source>The repetition operators are:</source>
          <target state="translated">反復演算子は</target>
        </trans-unit>
        <trans-unit id="bfcbf2851f89edd4f300f9b36ba95aadb203f98e" translate="yes" xml:space="preserve">
          <source>The representation does &lt;em&gt;not&lt;/em&gt; look like Figure 4-3, which is what memory would look like if Rust instead copied the heap data as well. If Rust did this, the operation &lt;code&gt;s2 = s1&lt;/code&gt; could be very expensive in terms of runtime performance if the data on the heap were large.</source>
          <target state="translated">この表現は図4-3のように&lt;em&gt;は&lt;/em&gt;見えませ&lt;em&gt;ん&lt;/em&gt;。これは、Rustがヒープデータをコピーした場合のメモリのようになります。Rustがこれを行った場合、ヒープ上のデータが大きい場合、操作 &lt;code&gt;s2 = s1&lt;/code&gt; は実行時パフォーマンスの点で非常に高価になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="0b1df299f3611946c8ad866e3a9d4772fabb543c" translate="yes" xml:space="preserve">
          <source>The representation of a &lt;code&gt;repr(C)&lt;/code&gt; enum with fields is a &lt;code&gt;repr(C)&lt;/code&gt; struct with two fields, also called a &quot;tagged union&quot; in C:</source>
          <target state="translated">フィールドを持つ &lt;code&gt;repr(C)&lt;/code&gt; 列挙型の表現は、2つのフィールドを持つ &lt;code&gt;repr(C)&lt;/code&gt; 構造体であり、Cでは「タグ付き共用体」とも呼ばれます。</target>
        </trans-unit>
        <trans-unit id="a3948c1d71b2273d20d352ff100e99a529e9f18b" translate="yes" xml:space="preserve">
          <source>The representation of a primitive representation enum is a &lt;code&gt;repr(C)&lt;/code&gt; union of &lt;code&gt;repr(C)&lt;/code&gt; structs for each variant with a field. The first field of each struct in the union is the primitive representation version of the enum with all fields removed (&quot;the tag&quot;) and the remaining fields are the fields of that variant.</source>
          <target state="translated">プリミティブ表現列挙型の表現は、フィールドを持つ各バリアントの &lt;code&gt;repr(C)&lt;/code&gt; 構造体の &lt;code&gt;repr(C)&lt;/code&gt; 結合です。ユニオンの各構造体の最初のフィールドは、すべてのフィールドが削除された列挙型のプリミティブ表現バージョン（「タグ」）であり、残りのフィールドはそのバリアントのフィールドです。</target>
        </trans-unit>
        <trans-unit id="ef3b4092c2efea2b55e7548a736c3333a566aec1" translate="yes" xml:space="preserve">
          <source>The representation of a trait object like &lt;code&gt;&amp;amp;SomeTrait&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;amp;SomeTrait&lt;/code&gt; のような特性オブジェクトの表現。</target>
        </trans-unit>
        <trans-unit id="4110c125de481ad527206c93b01dbedc11c02bc7" translate="yes" xml:space="preserve">
          <source>The representation of a trait object like &lt;code&gt;&amp;amp;dyn SomeTrait&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;amp;dyn SomeTrait&lt;/code&gt; ような特性オブジェクトの表現。</target>
        </trans-unit>
        <trans-unit id="84fd9c512efc7dcedf9b018795fbba5c08fc5ad5" translate="yes" xml:space="preserve">
          <source>The representation of a type can be changed by applying the &lt;code&gt;repr&lt;/code&gt; attribute to it. The following example shows a struct with a &lt;code&gt;C&lt;/code&gt; representation.</source>
          <target state="translated">タイプの表現は、それに &lt;code&gt;repr&lt;/code&gt; 属性を適用することによって変更できます。次の例は、 &lt;code&gt;C&lt;/code&gt; 表現の構造体を示しています。</target>
        </trans-unit>
        <trans-unit id="5a8aa6aa295a219e257360fdb9ca2113bb7bc323" translate="yes" xml:space="preserve">
          <source>The representation of a type can change the padding between fields, but does not change the layout of the fields themselves. For example, a struct with a &lt;code&gt;C&lt;/code&gt; representation that contains a struct &lt;code&gt;Inner&lt;/code&gt; with the default representation will not change the layout of &lt;code&gt;Inner&lt;/code&gt;.</source>
          <target state="translated">タイプの表現はフィールド間のパディングを変更できますが、フィールド自体のレイアウトは変更しません。たとえば、 &lt;code&gt;C&lt;/code&gt; 表現の構造体にデフォルトの表現の構造体 &lt;code&gt;Inner&lt;/code&gt; が含まれている場合、 &lt;code&gt;Inner&lt;/code&gt; のレイアウトは変更されません。</target>
        </trans-unit>
        <trans-unit id="8de668564b1808c69c7a252869635782239a849b" translate="yes" xml:space="preserve">
          <source>The representation semantics of floating-point numbers are described in &lt;a href=&quot;types/numeric&quot;&gt;&quot;Machine Types&quot;&lt;/a&gt;.</source>
          <target state="translated">浮動小数点数の表現セマンティクスについては、&lt;a href=&quot;types/numeric&quot;&gt;「マシンタイプ」を参照してください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="568b4d39b3d684710e1069cdb58107435b4ee105" translate="yes" xml:space="preserve">
          <source>The requested ABI is unsupported by the current target.</source>
          <target state="translated">要求されたABIは現在のターゲットではサポートされていません。</target>
        </trans-unit>
        <trans-unit id="6079a0a7d416189b9655a6ad531ff1787c361185" translate="yes" xml:space="preserve">
          <source>The required alignment of the referenced value.</source>
          <target state="translated">参照される値の必要な整列。</target>
        </trans-unit>
        <trans-unit id="48f41ba31da382f1ab342b312f6ebecf708e0a4f" translate="yes" xml:space="preserve">
          <source>The required inputs are these:</source>
          <target state="translated">必要な入力はこれらです。</target>
        </trans-unit>
        <trans-unit id="f6ffffcc1dc56ad2b07c96ba04b8dfcf628fd050" translate="yes" xml:space="preserve">
          <source>The requirements for this program haven&amp;rsquo;t been agreed upon yet, and we&amp;rsquo;re pretty sure the &lt;code&gt;Hello&lt;/code&gt; text at the beginning of the greeting will change. We decided we don&amp;rsquo;t want to have to update the test when the requirements change, so instead of checking for exact equality to the value returned from the &lt;code&gt;greeting&lt;/code&gt; function, we&amp;rsquo;ll just assert that the output contains the text of the input parameter.</source>
          <target state="translated">このプログラムの要件はまだ合意されておらず、挨拶の冒頭の &lt;code&gt;Hello&lt;/code&gt; テキストが変更されることは間違いありません。要件が変更されたときにテストを更新する必要がないことを決定したので、 &lt;code&gt;greeting&lt;/code&gt; 関数から返された値と正確に等しいかどうかをチェックする代わりに、出力に入力パラメーターのテキストが含まれていると断言します。</target>
        </trans-unit>
        <trans-unit id="0cbf837e1937a12c606036644e82391851dc8756" translate="yes" xml:space="preserve">
          <source>The responsibilities that remain in the &lt;code&gt;main&lt;/code&gt; function after this process should be limited to the following:</source>
          <target state="translated">このプロセス後に &lt;code&gt;main&lt;/code&gt; 機能に残る責任は、以下に限定する必要があります。</target>
        </trans-unit>
        <trans-unit id="fb88378aaf4cdd384feeec625a8c476a227f1fe6" translate="yes" xml:space="preserve">
          <source>The rest of the traits defined in the standard library can&amp;rsquo;t be implemented on your types using &lt;code&gt;derive&lt;/code&gt;. These traits don&amp;rsquo;t have sensible default behavior, so it&amp;rsquo;s up to you to implement them in the way that makes sense for what you&amp;rsquo;re trying to accomplish.</source>
          <target state="translated">標準ライブラリで定義された形質の残りの部分は、使用して、あなたのタイプに実装することはできません &lt;code&gt;derive&lt;/code&gt; 。これらの特性には適切なデフォルトの動作がないため、達成しようとしていることに意味のある方法で実装するのは、あなた次第です。</target>
        </trans-unit>
        <trans-unit id="3a3c86e891d6ad8a6d17dd1936fd9bfccb1b62f4" translate="yes" xml:space="preserve">
          <source>The rest of this book uses commands that work in both &lt;em&gt;cmd.exe&lt;/em&gt; and PowerShell. If there are specific differences, we&amp;rsquo;ll explain which to use.</source>
          <target state="translated">この本の残りの部分では、&lt;em&gt;cmd.exe&lt;/em&gt;とPowerShellの両方で機能するコマンドを使用しています。具体的な違いがある場合は、どちらを使用するかを説明します。</target>
        </trans-unit>
        <trans-unit id="00dd9e9169ec993decc3de54bbe98c364e0e7806" translate="yes" xml:space="preserve">
          <source>The rest of this crate documentation is dedicated to pointing out notable features of The Rust Standard Library.</source>
          <target state="translated">この木枠ドキュメントの残りの部分は、The Rust Standard Library の注目すべき機能を指摘することに専念しています。</target>
        </trans-unit>
        <trans-unit id="ac1c550b13307d7f1181fa4746cc5e5943901d94" translate="yes" xml:space="preserve">
          <source>The rest pattern is always irrefutable.</source>
          <target state="translated">残りのパターンはいつも反論の余地がない。</target>
        </trans-unit>
        <trans-unit id="b0cd0ab16fb284f9bcdd09aeae886a98592a2f2d" translate="yes" xml:space="preserve">
          <source>The result can be cast to a pointer of any kind. Ensure that the access is unique (no active references, mutable or not) when casting to &lt;code&gt;&amp;amp;mut T&lt;/code&gt;, and ensure that there are no mutations or mutable aliases going on when casting to &lt;code&gt;&amp;amp;T&lt;/code&gt;.</source>
          <target state="translated">結果は、あらゆる種類のポインターにキャストできます。 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; にキャストするときは、アクセスが一意（アクティブな参照がない、変更可能かどうか）であることを確認し、 &lt;code&gt;&amp;amp;T&lt;/code&gt; にキャストするときにミューテーションまたは変更可能なエイリアスが発生していないことを確認します。</target>
        </trans-unit>
        <trans-unit id="c54e546283bfd6f5bb35e08c8e91500e43fa3efb" translate="yes" xml:space="preserve">
          <source>The result is allocated on the heap.</source>
          <target state="translated">結果はヒープに割り当てられます。</target>
        </trans-unit>
        <trans-unit id="9f60835a1f670fd1068b73e7310483f7414303f8" translate="yes" xml:space="preserve">
          <source>The result may not be correctly rounded owing to implementation details; &lt;code&gt;self.log2()&lt;/code&gt; can produce more accurate results for base 2, and &lt;code&gt;self.log10()&lt;/code&gt; can produce more accurate results for base 10.</source>
          <target state="translated">実装の詳細により、結果が正しく丸められない場合があります。 &lt;code&gt;self.log2()&lt;/code&gt; は、base 2に対してより正確な結果を生成でき、 &lt;code&gt;self.log10()&lt;/code&gt; は、base 10に対してより正確な結果を生成できます。</target>
        </trans-unit>
        <trans-unit id="c4dbebfb961a1bddcfad953b06a027b749fbba28" translate="yes" xml:space="preserve">
          <source>The result of &lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;dereferencing&lt;/a&gt; an expression with type &lt;a href=&quot;../std/boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and that can also be moved out of.</source>
          <target state="translated">&lt;a href=&quot;../std/boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;型の式の&lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;逆参照&lt;/a&gt;の結果であり、その外に移動することもできます。</target>
        </trans-unit>
        <trans-unit id="fe2526308745be82b19ed557143eb06c9172e9c2" translate="yes" xml:space="preserve">
          <source>The result of a generator resumption.</source>
          <target state="translated">発電機を再開した結果。</target>
        </trans-unit>
        <trans-unit id="d471d20c06ef14c004fab8262f7528514deaa1c4" translate="yes" xml:space="preserve">
          <source>The result of casting a reference to a pointer is valid for as long as the underlying object is live and no reference (just raw pointers) is used to access the same memory.</source>
          <target state="translated">ポインタへの参照をキャストした結果は、基礎となるオブジェクトが生きている限り有効であり、同じメモリにアクセスするために参照(単なる生ポインタ)が使用されません。</target>
        </trans-unit>
        <trans-unit id="ac56fae426229e4d543dba38661557fbee8bb52d" translate="yes" xml:space="preserve">
          <source>The result of the &lt;a href=&quot;../macro.format_args&quot;&gt;&lt;code&gt;format_args!&lt;/code&gt;&lt;/a&gt; macro is a value of type &lt;a href=&quot;struct.arguments&quot;&gt;&lt;code&gt;fmt::Arguments&lt;/code&gt;&lt;/a&gt;. This structure can then be passed to the &lt;a href=&quot;../macro.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../macro.format&quot;&gt;&lt;code&gt;format&lt;/code&gt;&lt;/a&gt; functions inside this module in order to process the format string. The goal of this macro is to even further prevent intermediate allocations when dealing with formatting strings.</source>
          <target state="translated">&lt;a href=&quot;../macro.format_args&quot;&gt; &lt;code&gt;format_args!&lt;/code&gt; &lt;/a&gt;の結果！マクロは、タイプ&lt;a href=&quot;struct.arguments&quot;&gt; &lt;code&gt;fmt::Arguments&lt;/code&gt; &lt;/a&gt;値です。次に、この構造体をこのモジュール内の&lt;a href=&quot;../macro.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;関数と&lt;a href=&quot;../macro.format&quot;&gt; &lt;code&gt;format&lt;/code&gt; &lt;/a&gt;関数に渡して、フォーマット文字列を処理できます。このマクロの目的は、フォーマット文字列を処理するときに中間割り当てをさらに防ぐことです。</target>
        </trans-unit>
        <trans-unit id="31cd246d6c4827dc128a4e9ac189ceccd07f4e85" translate="yes" xml:space="preserve">
          <source>The result of the &lt;a href=&quot;../macro.format_args&quot;&gt;&lt;code&gt;format_args!&lt;/code&gt;&lt;/a&gt; macro is a value of type &lt;a href=&quot;struct.arguments&quot;&gt;&lt;code&gt;fmt::Arguments&lt;/code&gt;&lt;/a&gt;. This structure can then be passed to the &lt;a href=&quot;fn.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fn.format&quot;&gt;&lt;code&gt;format&lt;/code&gt;&lt;/a&gt; functions inside this module in order to process the format string. The goal of this macro is to even further prevent intermediate allocations when dealing formatting strings.</source>
          <target state="translated">&lt;a href=&quot;../macro.format_args&quot;&gt; &lt;code&gt;format_args!&lt;/code&gt; &lt;/a&gt;の結果 マクロは、タイプ&lt;a href=&quot;struct.arguments&quot;&gt; &lt;code&gt;fmt::Arguments&lt;/code&gt; &lt;/a&gt;値です。この構造は、フォーマット文字列を処理するために、このモジュール内の&lt;a href=&quot;fn.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;fn.format&quot;&gt; &lt;code&gt;format&lt;/code&gt; &lt;/a&gt;関数に渡すことができます。このマクロの目的は、フォーマット文字列を処理するときの中間割り当てをさらに防ぐことです。</target>
        </trans-unit>
        <trans-unit id="1c32345d3d6f612f235d03a8cd84044465cbfeea" translate="yes" xml:space="preserve">
          <source>The result will represent the IP address &lt;code&gt;a:b:c:d:e:f:g:h&lt;/code&gt;.</source>
          <target state="translated">結果はIPアドレス &lt;code&gt;a:b:c:d:e:f:g:h&lt;/code&gt; を表します。</target>
        </trans-unit>
        <trans-unit id="99c7c63b15fc6ea4f165265a5fd114fc5db86d31" translate="yes" xml:space="preserve">
          <source>The result will represent the IP address &lt;code&gt;a&lt;/code&gt;.&lt;code&gt;b&lt;/code&gt;.&lt;code&gt;c&lt;/code&gt;.&lt;code&gt;d&lt;/code&gt;.</source>
          <target state="translated">結果はIPアドレス &lt;code&gt;a&lt;/code&gt; を表します。 &lt;code&gt;b&lt;/code&gt; 。 &lt;code&gt;c&lt;/code&gt; 。 &lt;code&gt;d&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7373e6f7caa0a9dff8d78cf60558cf221157bd80" translate="yes" xml:space="preserve">
          <source>The resulting layout will be the same as that of a C struct containing two fields with the layouts of &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;next&lt;/code&gt;, in that order.</source>
          <target state="translated">結果のレイアウトは、 &lt;code&gt;self&lt;/code&gt; と &lt;code&gt;next&lt;/code&gt; のレイアウトの2つのフィールドをこの順序で含むC構造体のレイアウトと同じになります。</target>
        </trans-unit>
        <trans-unit id="99a0997f56bdadd8bd20428a4a2ef3bbae789fac" translate="yes" xml:space="preserve">
          <source>The resulting lifetime is bound to self so this behaves &quot;as if&quot; it were actually an instance of T that is getting borrowed. If a longer (unbound) lifetime is needed, use &lt;code&gt;&amp;amp;*my_ptr.as_ptr()&lt;/code&gt;.</source>
          <target state="translated">結果として得られる有効期間は自分自身にバインドされるため、これは実際に借用されているTのインスタンスであるかのように動作します。より長い（バインドされていない）ライフタイムが必要な場合は、 &lt;code&gt;&amp;amp;*my_ptr.as_ptr()&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="f78e2e736259493757a0ced96e6b992b486267c6" translate="yes" xml:space="preserve">
          <source>The resulting lifetime is bound to self so this behaves &quot;as if&quot; it were actually an instance of T that is getting borrowed. If a longer (unbound) lifetime is needed, use &lt;code&gt;&amp;amp;mut *my_ptr.as_ptr()&lt;/code&gt;.</source>
          <target state="translated">結果として得られる有効期間は自分自身にバインドされるため、これは実際に借用されているTのインスタンスであるかのように動作します。より長い（バインドされていない）ライフタイムが必要な場合は、 &lt;code&gt;&amp;amp;mut *my_ptr.as_ptr()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9220ca335fae6d1972b4901944a1126d0f38ae8e" translate="yes" xml:space="preserve">
          <source>The resulting pointer does not need to be in bounds, but it is potentially hazardous to dereference (which requires &lt;code&gt;unsafe&lt;/code&gt;).</source>
          <target state="translated">結果のポインターは境界内にある必要はありませんが、逆参照（ &lt;code&gt;unsafe&lt;/code&gt; が必要）に潜在的に危険です。</target>
        </trans-unit>
        <trans-unit id="81b4f59283eb3ce773831a86dd58d26e19da85b4" translate="yes" xml:space="preserve">
          <source>The resulting pointer does not need to be in bounds, but it is potentially hazardous to dereference (which requires &lt;code&gt;unsafe&lt;/code&gt;). In particular, the resulting pointer may &lt;em&gt;not&lt;/em&gt; be used to access a different allocated object than the one &lt;code&gt;self&lt;/code&gt; points to. In other words, &lt;code&gt;x.wrapping_offset(y.wrapping_offset_from(x))&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; the same as &lt;code&gt;y&lt;/code&gt;, and dereferencing it is undefined behavior unless &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; point into the same allocated object.</source>
          <target state="translated">結果のポインターは境界内にある必要はありませんが、逆参照（ &lt;code&gt;unsafe&lt;/code&gt; が必要）に潜在的に危険です。特に、結果のポインタは、 &lt;code&gt;self&lt;/code&gt; 指しているものとは異なる割り当てられたオブジェクトにアクセスするために使用でき&lt;em&gt;ません&lt;/em&gt;。つまり、 &lt;code&gt;x.wrapping_offset(y.wrapping_offset_from(x))&lt;/code&gt; は &lt;code&gt;y&lt;/code&gt; と同じでは&lt;em&gt;なく&lt;/em&gt;、 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; が同じ割り当てられたオブジェクトを指す場合を除いて、それを逆参照することは未定義の動作です。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="52dcba8fc55d983793d49be111c09fcb50eb3b76" translate="yes" xml:space="preserve">
          <source>The resulting pointer will have provenance of &lt;code&gt;val&lt;/code&gt;, i.e., for a fat pointer, this operation is semantically the same as creating a new fat pointer with the data pointer value of &lt;code&gt;val&lt;/code&gt; but the metadata of &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="translated">結果のポインターは &lt;code&gt;val&lt;/code&gt; のプロバンスを持ちます。つまり、ファットポインターの場合、この操作は、 &lt;code&gt;val&lt;/code&gt; のデータポインター値で新しいファットポインターを作成するのと意味的に同じですが、 &lt;code&gt;self&lt;/code&gt; のメタデータです。</target>
        </trans-unit>
        <trans-unit id="277fa9ca5234a7d85c4310d360b586b5679536d7" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;!&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;!&lt;/code&gt; を適用した結果のタイプ オペレーター。</target>
        </trans-unit>
        <trans-unit id="e0fff7e85f4e0422c5e3edd89994815fd0fa33fe" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;%&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;%&lt;/code&gt; 演算子を適用した後の結果の型。</target>
        </trans-unit>
        <trans-unit id="bb2df529c05fcb3e3ae1db4ab5bf5c9f054fbf92" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;&amp;amp;&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;&amp;amp;&lt;/code&gt; 演算子を適用した後の結果の型。</target>
        </trans-unit>
        <trans-unit id="36522abccd158f4a83c30f6cbe7b1f733a467a76" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 演算子を適用した結果の型。</target>
        </trans-unit>
        <trans-unit id="1fe31e03010cc02b7a70dec74838acc1bf92f653" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 演算子を適用した後の結果の型。</target>
        </trans-unit>
        <trans-unit id="49f0b7e4d4d9571dc029b144b407d2d00db70bde" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;*&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; 演算子を適用した結果の型。</target>
        </trans-unit>
        <trans-unit id="5440b4202f92f92a6ad5f44ab02bb1836dc990f2" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;+&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; 演算子を適用した後の結果の型。</target>
        </trans-unit>
        <trans-unit id="4a8bf360ec637ebc225332beb0f574739bca97a7" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;-&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;-&lt;/code&gt; 演算子を適用した後の結果の型。</target>
        </trans-unit>
        <trans-unit id="541f705e1fd40afef0d79bd7f0f4268fa7398a27" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;/&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;/&lt;/code&gt; 演算子を適用した後の結果の型。</target>
        </trans-unit>
        <trans-unit id="5fff5e225b75cdf382af9bb7542d50be9c4363ed" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;^&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;^&lt;/code&gt; 演算子を適用した後の結果の型。</target>
        </trans-unit>
        <trans-unit id="fee8ba95ad793c2c7dda2e8911dcb02800ab8ed4" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;|&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;|&lt;/code&gt; を適用した後の結果の型 オペレーター。</target>
        </trans-unit>
        <trans-unit id="0473503cf115b2a975e15da3f35244db7bce3d66" translate="yes" xml:space="preserve">
          <source>The resulting type after concatenation</source>
          <target state="translated">連結後の結果の型</target>
        </trans-unit>
        <trans-unit id="dbf5bd29abfe066aae072317675dfaca543c15fe" translate="yes" xml:space="preserve">
          <source>The resulting type after dereferencing.</source>
          <target state="translated">参照を解除した後の結果の型。</target>
        </trans-unit>
        <trans-unit id="76a4c8bb9eba17c026c554fa00db407a4ed92a09" translate="yes" xml:space="preserve">
          <source>The resulting type after obtaining ownership.</source>
          <target state="translated">所有権取得後の結果型。</target>
        </trans-unit>
        <trans-unit id="04c53e531d342d2fc7cb2f6812bb0980d9b695cc" translate="yes" xml:space="preserve">
          <source>The resulting vector can be converted back into a box via &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;'s &lt;code&gt;into_boxed_slice&lt;/code&gt; method.</source>
          <target state="translated">結果のベクトルは、 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; の &lt;code&gt;into_boxed_slice&lt;/code&gt; メソッドを介してボックスに変換して戻すことができます。</target>
        </trans-unit>
        <trans-unit id="c631dfaa5b94e5b7afa0d3baba880ecf32c3c788" translate="yes" xml:space="preserve">
          <source>The return type in the desugaring is assumed to capture all lifetime parameters from the &lt;code&gt;async fn&lt;/code&gt; declaration. This can be seen in the desugared example above, which explicitly outlives, and hence captures, &lt;code&gt;'a&lt;/code&gt;.</source>
          <target state="translated">脱糖の戻り値の型は、 &lt;code&gt;async fn&lt;/code&gt; 宣言からすべてのライフタイムパラメーターをキャプチャすると想定されています。これは、上記の脱糖された例で見ることができます。これは、明示的に長生きするため、 &lt;code&gt;'a&lt;/code&gt; をキャプチャします。</target>
        </trans-unit>
        <trans-unit id="8b3c91f66fb428df18fd8a3b968cf270fb22e4f6" translate="yes" xml:space="preserve">
          <source>The return type isn&amp;rsquo;t &lt;code&gt;Self&lt;/code&gt;.</source>
          <target state="translated">戻り値の型は &lt;code&gt;Self&lt;/code&gt; ではありません。</target>
        </trans-unit>
        <trans-unit id="87f17fcd6dd95b0936e246de85107f7f76aa4067" translate="yes" xml:space="preserve">
          <source>The return type of &lt;a href=&quot;../primitive.str#method.escape_debug&quot;&gt;&lt;code&gt;str::escape_debug&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../primitive.str#method.escape_debug&quot;&gt; &lt;code&gt;str::escape_debug&lt;/code&gt; &lt;/a&gt;の戻りタイプ。</target>
        </trans-unit>
        <trans-unit id="db39743b7e18afb4b0cbc402d05c64c31d6c2284" translate="yes" xml:space="preserve">
          <source>The return type of &lt;a href=&quot;../primitive.str#method.escape_default&quot;&gt;&lt;code&gt;str::escape_default&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../primitive.str#method.escape_default&quot;&gt; &lt;code&gt;str::escape_default&lt;/code&gt; &lt;/a&gt;の戻り値の型。</target>
        </trans-unit>
        <trans-unit id="0d7f1d5c28f55e7c46b28c80bf7c947a04177ba0" translate="yes" xml:space="preserve">
          <source>The return type of &lt;a href=&quot;../primitive.str#method.escape_unicode&quot;&gt;&lt;code&gt;str::escape_unicode&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../primitive.str#method.escape_unicode&quot;&gt; &lt;code&gt;str::escape_unicode&lt;/code&gt; &lt;/a&gt;の戻りタイプ。</target>
        </trans-unit>
        <trans-unit id="46984a9d3d93237d6af0b4171b9091187f1fd40f" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;read_input()&lt;/code&gt;, &lt;a href=&quot;type.result&quot;&gt;&lt;code&gt;io::Result&amp;lt;()&amp;gt;&lt;/code&gt;&lt;/a&gt;, is a very common type for functions which don't have a 'real' return value, but do want to return errors if they happen. In this case, the only purpose of this function is to read the line and print it, so we use &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">戻り値の型 &lt;code&gt;read_input()&lt;/code&gt; 、&lt;a href=&quot;type.result&quot;&gt; &lt;code&gt;io::Result&amp;lt;()&amp;gt;&lt;/code&gt; &lt;/a&gt;、「本当の」、戻り値を持っていないが、彼らが起こる場合は、エラーを返すようにしたいん機能のための非常に一般的なタイプです。この場合、この関数の唯一の目的は行を読み取って出力することなので、 &lt;code&gt;()&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="dc8688a274902ed01a0ecc5033bf35069d5bb391" translate="yes" xml:space="preserve">
          <source>The return value is a result indicating whether the new value was written and containing the previous value. On success this value is guaranteed to be equal to &lt;code&gt;current&lt;/code&gt;.</source>
          <target state="translated">戻り値は、新しい値が書き込まれ、以前の値が含まれているかどうかを示す結果です。成功すると、この値は &lt;code&gt;current&lt;/code&gt; と等しいことが保証されます。</target>
        </trans-unit>
        <trans-unit id="6b1ea39b856b2d5fee30e6b97044d7752b536c14" translate="yes" xml:space="preserve">
          <source>The return value is always the previous value. If it is equal to &lt;code&gt;current&lt;/code&gt;, then the value was updated.</source>
          <target state="translated">戻り値は常に前の値です。それが &lt;code&gt;current&lt;/code&gt; と等しい場合、値は更新されています。</target>
        </trans-unit>
        <trans-unit id="fc0a38af017feefeb9d3ecc2b64620f7588f7e32" translate="yes" xml:space="preserve">
          <source>The return value may change depending on the compiler version and unsafe code may not rely on the result of this function for soundness. It is suggested to only use this function for performance optimizations where spurious &lt;code&gt;false&lt;/code&gt; return values by this function do not affect the outcome, but just the performance. The consequences of using this method to make runtime and compile-time code behave differently have not been explored. This method should not be used to introduce such differences, and it should also not be stabilized before we have a better understanding of this issue.</source>
          <target state="translated">戻り値はコンパイラのバージョンによって変わる可能性があり、安全でないコードは健全性のためにこの関数の結果に依存しない可能性があります。この関数は、この関数による誤った &lt;code&gt;false&lt;/code&gt; 戻り値が結果に影響を与えず、パフォーマンスにのみ影響を与えるパフォーマンスの最適化にのみ使用することをお勧めします。このメソッドを使用してランタイムコードとコンパイル時コードの動作を変えることの結果は、調査されていません。この方法は、そのような違いを導入するために使用されるべきではありません。また、この問題をよりよく理解する前に、この方法を安定させるべきではありません。</target>
        </trans-unit>
        <trans-unit id="8bec0cf03017a322224afce0dc723c8da3b1c3f8" translate="yes" xml:space="preserve">
          <source>The return value of this function has no meaning if &lt;code&gt;align&lt;/code&gt; is not a power-of-two.</source>
          <target state="translated">この関数の戻り値は、 &lt;code&gt;align&lt;/code&gt; が2のべき乗でない場合は意味がありません。</target>
        </trans-unit>
        <trans-unit id="60b397a9e27c756600834e9e8bc999da0f2e38e6" translate="yes" xml:space="preserve">
          <source>The returned 64-bit value is equivalent to a &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/minwinbase/ns-minwinbase-filetime&quot;&gt;&lt;code&gt;FILETIME&lt;/code&gt;&lt;/a&gt; struct, which represents the number of 100-nanosecond intervals since January 1, 1601 (UTC). The struct is automatically converted to a &lt;code&gt;u64&lt;/code&gt; value, as that is the recommended way to use it.</source>
          <target state="translated">返される64ビット値は、1601年1月1日（UTC）以降の100ナノ秒間隔の数を表す&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/minwinbase/ns-minwinbase-filetime&quot;&gt; &lt;code&gt;FILETIME&lt;/code&gt; &lt;/a&gt;構造体と同等です。構造体は自動的に &lt;code&gt;u64&lt;/code&gt; 値に変換されます。これは、それを使用するための推奨される方法です。</target>
        </trans-unit>
        <trans-unit id="9b9e4888166c03a2354c980d922cf25c13eb44d0" translate="yes" xml:space="preserve">
          <source>The returned 64-bit value is equivalent to a &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms724284.aspx&quot;&gt;&lt;code&gt;FILETIME&lt;/code&gt;&lt;/a&gt; struct, which represents the number of 100-nanosecond intervals since January 1, 1601 (UTC). The struct is automatically converted to a &lt;code&gt;u64&lt;/code&gt; value, as that is the recommended way to use it.</source>
          <target state="translated">返される64ビット値は&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms724284.aspx&quot;&gt; &lt;code&gt;FILETIME&lt;/code&gt; &lt;/a&gt;構造体に相当します。これは、1601年1月1日（UTC）以降の100ナノ秒間隔の数を表します。構造体は推奨される使用方法であるため、 &lt;code&gt;u64&lt;/code&gt; 値に自動的に変換されます。</target>
        </trans-unit>
        <trans-unit id="f17e579c0925b04170923132b19bbc2e328718e7" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;struct.range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; is safe to pass to &lt;a href=&quot;../primitive.slice#method.get_unchecked&quot;&gt;&lt;code&gt;slice::get_unchecked&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../primitive.slice#method.get_unchecked_mut&quot;&gt;&lt;code&gt;slice::get_unchecked_mut&lt;/code&gt;&lt;/a&gt; for slices of the given length.</source>
          <target state="translated">返された&lt;a href=&quot;struct.range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt;は、指定された長さのスライスに対して、&lt;a href=&quot;../primitive.slice#method.get_unchecked&quot;&gt; &lt;code&gt;slice::get_unchecked&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;../primitive.slice#method.get_unchecked_mut&quot;&gt; &lt;code&gt;slice::get_unchecked_mut&lt;/code&gt; &lt;/a&gt;に安全に渡すことができます。</target>
        </trans-unit>
        <trans-unit id="7e9caf07f01ab2822f3d6ed99758b9360c5c26af" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;struct.tcplistener&quot;&gt;&lt;code&gt;TcpListener&lt;/code&gt;&lt;/a&gt; is a reference to the same socket that this object references. Both handles can be used to accept incoming connections and options set on one listener will affect the other.</source>
          <target state="translated">返される&lt;a href=&quot;struct.tcplistener&quot;&gt; &lt;code&gt;TcpListener&lt;/code&gt; &lt;/a&gt;は、このオブジェクトが参照するのと同じソケットへの参照です。両方のハンドルを使用して着信接続を受け入れることができ、一方のリスナーに設定されたオプションはもう一方に影響します。</target>
        </trans-unit>
        <trans-unit id="ded74a0ee30df2ab90178bc7d8c79f6560c92452" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;struct.waittimeoutresult&quot;&gt;&lt;code&gt;WaitTimeoutResult&lt;/code&gt;&lt;/a&gt; value indicates if the timeout is known to have elapsed without the condition being met.</source>
          <target state="translated">返される&lt;a href=&quot;struct.waittimeoutresult&quot;&gt; &lt;code&gt;WaitTimeoutResult&lt;/code&gt; &lt;/a&gt;値は、条件が満たされないままタイムアウトが経過したことがわかっているかどうかを示します。</target>
        </trans-unit>
        <trans-unit id="38736111afdf682fcdb07c273e755038e1599f59" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;struct.waittimeoutresult&quot;&gt;&lt;code&gt;WaitTimeoutResult&lt;/code&gt;&lt;/a&gt; value indicates if the timeout is known to have elapsed.</source>
          <target state="translated">返される&lt;a href=&quot;struct.waittimeoutresult&quot;&gt; &lt;code&gt;WaitTimeoutResult&lt;/code&gt; &lt;/a&gt;値は、タイムアウトが経過したことがわかっているかどうかを示します。</target>
        </trans-unit>
        <trans-unit id="a4d3afc22fc51194d42ebf97c4d4c71d6cf8d193" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Read&lt;/code&gt; instance will first read all bytes from this object until EOF is encountered. Afterwards the output is equivalent to the output of &lt;code&gt;next&lt;/code&gt;.</source>
          <target state="translated">返された &lt;code&gt;Read&lt;/code&gt; インスタンスは、EOFが検出されるまで、最初にこのオブジェクトからすべてのバイトを読み取ります。その後、出力は &lt;code&gt;next&lt;/code&gt; の出力と同等になります。</target>
        </trans-unit>
        <trans-unit id="c46cae45e911aa3ffb2e82c2b8df4d3f09691f8b" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;TcpStream&lt;/code&gt; is a reference to the same stream that this object references. Both handles will read and write the same stream of data, and options set on one stream will be propagated to the other stream.</source>
          <target state="translated">返される &lt;code&gt;TcpStream&lt;/code&gt; は、このオブジェクトが参照するのと同じストリームへの参照です。両方のハンドルが同じデータストリームを読み書きし、一方のストリームに設定されたオプションがもう一方のストリームに伝播されます。</target>
        </trans-unit>
        <trans-unit id="f1bab9e66e16ee3bc6f8eaaaaca9a4320b7da4d4" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;UdpSocket&lt;/code&gt; is a reference to the same socket that this object references. Both handles will read and write the same port, and options set on one socket will be propagated to the other.</source>
          <target state="translated">返される &lt;code&gt;UdpSocket&lt;/code&gt; は、このオブジェクトが参照するのと同じソケットへの参照です。両方のハンドルが同じポートを読み書きし、一方のソケットに設定されたオプションがもう一方に伝播されます。</target>
        </trans-unit>
        <trans-unit id="c1a563924be47f2135363b13913bddb8d81845c6" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;UnixDatagram&lt;/code&gt; is a reference to the same socket that this object references. Both handles can be used to accept incoming connections and options set on one side will affect the other.</source>
          <target state="translated">返される &lt;code&gt;UnixDatagram&lt;/code&gt; は、このオブジェクトが参照するのと同じソケットへの参照です。両方のハンドルを使用して着信接続を受け入れることができ、一方の側で設定されたオプションは他方に影響します。</target>
        </trans-unit>
        <trans-unit id="3a69722b38c150ace8c17a0ad6c7500758c624a4" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;UnixListener&lt;/code&gt; is a reference to the same socket that this object references. Both handles can be used to accept incoming connections and options set on one listener will affect the other.</source>
          <target state="translated">返される &lt;code&gt;UnixListener&lt;/code&gt; は、このオブジェクトが参照するのと同じソケットへの参照です。両方のハンドルを使用して着信接続を受け入れることができ、一方のリスナーに設定されたオプションはもう一方に影響します。</target>
        </trans-unit>
        <trans-unit id="144b7ef360f6249426bb7be199321625b6985707" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;UnixStream&lt;/code&gt; is a reference to the same stream that this object references. Both handles will read and write the same stream of data, and options set on one stream will be propagated to the other stream.</source>
          <target state="translated">返される &lt;code&gt;UnixStream&lt;/code&gt; は、このオブジェクトが参照するのと同じストリームへの参照です。両方のハンドルが同じデータストリームを読み書きし、一方のストリームに設定されたオプションがもう一方のストリームに伝播されます。</target>
        </trans-unit>
        <trans-unit id="cb880b11df63d1e3077076bea22bb8b51ec8054d" translate="yes" xml:space="preserve">
          <source>The returned adaptor also implements &lt;code&gt;AllocRef&lt;/code&gt; and will simply borrow this.</source>
          <target state="translated">返されたアダプタも &lt;code&gt;AllocRef&lt;/code&gt; を実装しており、これを借用するだけです。</target>
        </trans-unit>
        <trans-unit id="e3560a746a4c0e2ffb1141c7abaa941ae137d7b4" translate="yes" xml:space="preserve">
          <source>The returned adaptor also implements &lt;code&gt;Read&lt;/code&gt; and will simply borrow this current reader.</source>
          <target state="translated">返されたアダプターも &lt;code&gt;Read&lt;/code&gt; を実装し、この現在のリーダーを借ります。</target>
        </trans-unit>
        <trans-unit id="facac298df7b4792f8b8fe4cbcbc0a4967c70852" translate="yes" xml:space="preserve">
          <source>The returned adaptor also implements &lt;code&gt;Write&lt;/code&gt; and will simply borrow this current writer.</source>
          <target state="translated">返されたアダプタも &lt;code&gt;Write&lt;/code&gt; を実装し、この現在のライターを借りるだけです。</target>
        </trans-unit>
        <trans-unit id="e389b4884c363b3fc760ebd7d93cdcb95de946c0" translate="yes" xml:space="preserve">
          <source>The returned block is suitable for passing to the &lt;code&gt;alloc&lt;/code&gt;/&lt;code&gt;realloc&lt;/code&gt; methods of this allocator.</source>
          <target state="translated">返されたブロックは、このアロケータの &lt;code&gt;alloc&lt;/code&gt; / &lt;code&gt;realloc&lt;/code&gt; メソッドに渡すのに適しています。</target>
        </trans-unit>
        <trans-unit id="c91d87a8c74843f84b212121082c194e485a54b8" translate="yes" xml:space="preserve">
          <source>The returned block may have a larger size than specified by &lt;code&gt;layout.size()&lt;/code&gt;, and may or may not have its contents initialized.</source>
          <target state="translated">返されるブロックのサイズは、 &lt;code&gt;layout.size()&lt;/code&gt; で指定されているサイズよりも大きい場合があり、内容が初期化されている場合とされていない場合があります。</target>
        </trans-unit>
        <trans-unit id="b4d367aab1faeec6de58c9c9955a240781bdbe40" translate="yes" xml:space="preserve">
          <source>The returned block of storage may or may not have its contents initialized. (Extension subtraits might restrict this behavior, e.g., to ensure initialization to particular sets of bit patterns.)</source>
          <target state="translated">返されたストレージのブロックは、その内容が初期化されている場合もあれば、されていない場合もあります(拡張減算は、特定のビットパターンのセットを確実に初期化するなど、この動作を制限する場合があります)。(拡張サブトラクションは、特定のビットパターンのセットに対する初期化を確実にするためなど、この動作を制限するかもしれません)。</target>
        </trans-unit>
        <trans-unit id="ba2ebcfc4f605284f02edd68881e9753988594f5" translate="yes" xml:space="preserve">
          <source>The returned boolean is &lt;code&gt;false&lt;/code&gt; only if the timeout is known to have elapsed.</source>
          <target state="translated">タイムアウトが経過したことがわかっている場合にのみ、返されるブール値は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="ef190a0092cd801a89bd32ca6438155668c7c711" translate="yes" xml:space="preserve">
          <source>The returned buffer does &lt;strong&gt;not&lt;/strong&gt; contain the trailing nul terminator, and it is guaranteed to not have any interior nul bytes.</source>
          <target state="translated">返されたバッファがない&lt;strong&gt;ではない&lt;/strong&gt;末尾のNULターミネータを含み、どんなインテリアNULバイトを持っていないことが保証されます。</target>
        </trans-unit>
        <trans-unit id="c21f9df3ca074ffdfcc498df18bd9b3644edeb21" translate="yes" xml:space="preserve">
          <source>The returned iterator contains a snapshot of the process's environment variables at the time of this invocation. Modifications to environment variables afterwards will not be reflected in the returned iterator.</source>
          <target state="translated">返されるイテレータには、この呼び出し時のプロセスの環境変数のスナップショットが含まれます。その後の環境変数の変更は、返されるイテレータには反映されません。</target>
        </trans-unit>
        <trans-unit id="94742684e4e1a0a940d70b49afd50e4db443fbed" translate="yes" xml:space="preserve">
          <source>The returned iterator may not actually yield any values depending on the outcome of any resolution performed.</source>
          <target state="translated">返されたイテレータは、実行された解決の結果によっては、実際には何の値も得られないかもしれません。</target>
        </trans-unit>
        <trans-unit id="2aad97e80249c67281fd50b9abdb7bf4c0bc39de" translate="yes" xml:space="preserve">
          <source>The returned iterator might panic if the to-be-returned index would overflow a &lt;a href=&quot;../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">返されるインデックスが&lt;a href=&quot;../primitive.usize&quot;&gt; &lt;code&gt;usize&lt;/code&gt; &lt;/a&gt;をオーバーフローすると、返されたイテレータがパニックになる可能性があります。</target>
        </trans-unit>
        <trans-unit id="3f6e0a2276ef2ac22ba60fa606f31e8d0538ab17" translate="yes" xml:space="preserve">
          <source>The returned iterator requires that the pattern supports a reverse search, and it will be a &lt;a href=&quot;../iter/trait.doubleendediterator&quot;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt; if a forward/reverse search yields the same elements.</source>
          <target state="translated">返されるイテレータでは、パターンが逆検索をサポートしている必要があり、順検索/逆検索で同じ要素が生成された場合は&lt;a href=&quot;../iter/trait.doubleendediterator&quot;&gt; &lt;code&gt;DoubleEndedIterator&lt;/code&gt; &lt;/a&gt;になります。</target>
        </trans-unit>
        <trans-unit id="212e83558d8f38fe873f76d6ab8c409b36c6c1ca" translate="yes" xml:space="preserve">
          <source>The returned iterator requires that the pattern supports a reverse search, and it will be a &lt;a href=&quot;iter/trait.doubleendediterator&quot;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt; if a forward/reverse search yields the same elements.</source>
          <target state="translated">返された反復子は、パターンが逆検索をサポートしていることを必要とし、順方向/逆検索が同じ要素を生成する場合、それは&lt;a href=&quot;iter/trait.doubleendediterator&quot;&gt; &lt;code&gt;DoubleEndedIterator&lt;/code&gt; &lt;/a&gt;になります。</target>
        </trans-unit>
        <trans-unit id="0a192fbaedef699058263c6cf3d017b9555c1581" translate="yes" xml:space="preserve">
          <source>The returned iterator requires that the pattern supports a reverse search, and it will be double ended if a forward/reverse search yields the same elements.</source>
          <target state="translated">返されるイテレータは、パターンが逆引き検索をサポートしていることを必要とし、順引き検索と逆引き検索で同じ要素が得られた場合はダブルエンドとなります。</target>
        </trans-unit>
        <trans-unit id="31cf06022e130c2b8e694b6f17ab8cbe9626501c" translate="yes" xml:space="preserve">
          <source>The returned iterator will be a &lt;a href=&quot;../iter/trait.doubleendediterator&quot;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt; if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, e.g., &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, but not for &lt;code&gt;&amp;amp;str&lt;/code&gt;.</source>
          <target state="translated">パターンが逆検索を許可し、順/逆検索が同じ要素を生成する場合、返されるイテレーターは&lt;a href=&quot;../iter/trait.doubleendediterator&quot;&gt; &lt;code&gt;DoubleEndedIterator&lt;/code&gt; に&lt;/a&gt;なります。これは、たとえば&lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;には当てはまりますが、 &lt;code&gt;&amp;amp;str&lt;/code&gt; には当てはまりません。</target>
        </trans-unit>
        <trans-unit id="4543e6c97747a65b55c800608ca5f7c928ee84b5" translate="yes" xml:space="preserve">
          <source>The returned iterator will be a &lt;a href=&quot;iter/trait.doubleendediterator&quot;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt; if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, e.g., &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, but not for &lt;code&gt;&amp;amp;str&lt;/code&gt;.</source>
          <target state="translated">パターンが逆方向検索を許可し、順方向/逆方向検索で同じ要素が生成される場合、返される反復子は&lt;a href=&quot;iter/trait.doubleendediterator&quot;&gt; &lt;code&gt;DoubleEndedIterator&lt;/code&gt; に&lt;/a&gt;なります。これは、たとえば&lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;には当てはまりますが、 &lt;code&gt;&amp;amp;str&lt;/code&gt; には当てはまりません。</target>
        </trans-unit>
        <trans-unit id="fcd14ee368ff1244ad97f001dc72e74042b0095f" translate="yes" xml:space="preserve">
          <source>The returned iterator will be a &lt;a href=&quot;iter/trait.doubleendediterator&quot;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt; if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, e.g., &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, but not for &lt;code&gt;&amp;amp;str&lt;/code&gt;.</source>
          <target state="translated">パターンが逆方向検索を許可し、順方向/逆方向検索で同じ要素が生成される場合、返される反復子は&lt;a href=&quot;iter/trait.doubleendediterator&quot;&gt; &lt;code&gt;DoubleEndedIterator&lt;/code&gt; に&lt;/a&gt;なります。これは、たとえば&lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;には当てはまりますが、 &lt;code&gt;&amp;amp;str&lt;/code&gt; には当てはまりません。</target>
        </trans-unit>
        <trans-unit id="fb1179f626056fe35d781c0e7e7072fe8a2697c8" translate="yes" xml:space="preserve">
          <source>The returned iterator will be a &lt;a href=&quot;iter/trait.doubleendediterator&quot;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt; if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, e.g., &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, but not for &lt;code&gt;&amp;amp;str&lt;/code&gt;.</source>
          <target state="translated">パターンが逆検索を許可し、順/逆検索が同じ要素を生成する場合、返されるイテレーターは&lt;a href=&quot;iter/trait.doubleendediterator&quot;&gt; &lt;code&gt;DoubleEndedIterator&lt;/code&gt; に&lt;/a&gt;なります。これは、たとえば&lt;a href=&quot;primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;には当てはまりますが、 &lt;code&gt;&amp;amp;str&lt;/code&gt; には当てはまりません。</target>
        </trans-unit>
        <trans-unit id="45e7ec844babb660dc32f9f713ab552f258e8f9a" translate="yes" xml:space="preserve">
          <source>The returned iterator will never return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; and will also not yield the peer's &lt;a href=&quot;enum.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt; structure. Iterating over it is equivalent to calling &lt;a href=&quot;#method.accept&quot;&gt;&lt;code&gt;accept&lt;/code&gt;&lt;/a&gt; in a loop.</source>
          <target state="translated">返された反復子は決して&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;を返さず、ピアの&lt;a href=&quot;enum.socketaddr&quot;&gt; &lt;code&gt;SocketAddr&lt;/code&gt; &lt;/a&gt;構造も生成しません。これを反復することは、ループで&lt;a href=&quot;#method.accept&quot;&gt; &lt;code&gt;accept&lt;/code&gt; &lt;/a&gt;を呼び出すことと同じです。</target>
        </trans-unit>
        <trans-unit id="40daaaf435dcc6bfd52a2f60c0016a88fb0c4d52" translate="yes" xml:space="preserve">
          <source>The returned iterator will never return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; and will also not yield the peer's &lt;a href=&quot;enum.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt; structure. Iterating over it is equivalent to calling &lt;a href=&quot;struct.tcplistener#method.accept&quot;&gt;&lt;code&gt;TcpListener::accept&lt;/code&gt;&lt;/a&gt; in a loop.</source>
          <target state="translated">返されたイテレータは&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;を返すことはなく、ピアの&lt;a href=&quot;enum.socketaddr&quot;&gt; &lt;code&gt;SocketAddr&lt;/code&gt; &lt;/a&gt;構造体も生成しません。それを繰り返すことは、ループで&lt;a href=&quot;struct.tcplistener#method.accept&quot;&gt; &lt;code&gt;TcpListener::accept&lt;/code&gt; &lt;/a&gt;を呼び出すことと同じです。</target>
        </trans-unit>
        <trans-unit id="3cacc276ab85a92453bcb875fe7d5c79fd6233ed" translate="yes" xml:space="preserve">
          <source>The returned iterator will not be double ended, because it is not efficient to support.</source>
          <target state="translated">返されたイテレータは、サポートするのは効率的ではないので、ダブルエンドにはなりません。</target>
        </trans-unit>
        <trans-unit id="6626efd84bc65ae6d8cabe4bc5b2e309e23cd9ee" translate="yes" xml:space="preserve">
          <source>The returned iterator will panic during iteration if any argument to the process is not valid unicode. If this is not desired, use the &lt;a href=&quot;fn.args_os&quot;&gt;&lt;code&gt;args_os&lt;/code&gt;&lt;/a&gt; function instead.</source>
          <target state="translated">プロセスへの引数が有効なUnicodeではない場合、返される反復子は反復中にパニックになります。これが望ましくない場合は、代わりに&lt;a href=&quot;fn.args_os&quot;&gt; &lt;code&gt;args_os&lt;/code&gt; &lt;/a&gt;関数を使用してください。</target>
        </trans-unit>
        <trans-unit id="48642a85c9b9785eaffc2d69f306f5a44a684795" translate="yes" xml:space="preserve">
          <source>The returned iterator yields only the &lt;code&gt;value&lt;/code&gt;s for which the supplied closure returns &lt;code&gt;Some(value)&lt;/code&gt;.</source>
          <target state="translated">返されたイテレータは、指定されたクロージャが &lt;code&gt;Some(value)&lt;/code&gt; を返す &lt;code&gt;value&lt;/code&gt; sのみを生成します。</target>
        </trans-unit>
        <trans-unit id="8c4abf6a88076e830a1096ad48a0fcbdcd010f5d" translate="yes" xml:space="preserve">
          <source>The returned lifetime is not guaranteed to be the actual lifetime of &lt;code&gt;ptr&lt;/code&gt;.</source>
          <target state="translated">返される有効期間は、 &lt;code&gt;ptr&lt;/code&gt; の実際の有効期間であるとは限りません。</target>
        </trans-unit>
        <trans-unit id="dd646ddea405b753233bb6eb50b8340613c5b51f" translate="yes" xml:space="preserve">
          <source>The returned listener is ready for accepting connections.</source>
          <target state="translated">返されたリスナーは、接続を受け入れる準備ができています。</target>
        </trans-unit>
        <trans-unit id="32a2e5d176a9d291f17213749b86ae928f9a79fd" translate="yes" xml:space="preserve">
          <source>The returned name refers to a source path on the compiling system, but it isn't valid to represent this directly as a &lt;code&gt;&amp;amp;Path&lt;/code&gt;. The compiled code may run on a different system with a different &lt;code&gt;Path&lt;/code&gt; implementation than the system providing the contents and this library does not currently have a different &quot;host path&quot; type.</source>
          <target state="translated">返される名前は、コンパイルシステム上のソースパスを参照していますが、これを &lt;code&gt;&amp;amp;Path&lt;/code&gt; として直接表すことは無効です。コンパイルされたコードは、コンテンツを提供するシステムとは異なる &lt;code&gt;Path&lt;/code&gt; 実装を持つ異なるシステムで実行される可能性があり、このライブラリには現在、異なる「ホストパス」タイプがありません。</target>
        </trans-unit>
        <trans-unit id="bd3776d88d1ca8845ec6b1038a3cef52ddd6c1ee" translate="yes" xml:space="preserve">
          <source>The returned object can be used for error recovery, such as re-inspecting the buffer.</source>
          <target state="translated">返されたオブジェクトは、バッファの再検査などのエラー回復に使用することができます。</target>
        </trans-unit>
        <trans-unit id="d094ca8efdcd1c477cd38db568c96ab96a8083f1" translate="yes" xml:space="preserve">
          <source>The returned pointer is read-only; writing to it (including passing it to C code that writes to it) causes undefined behavior.</source>
          <target state="translated">返されるポインタは読み取り専用で、これに書き込む(これを書き込むCコードに渡すことも含む)と未定義の動作になります。</target>
        </trans-unit>
        <trans-unit id="9b9b68320305244b712b6eba3fb78b4a32d8f345" translate="yes" xml:space="preserve">
          <source>The returned pointer will be valid for as long as &lt;code&gt;self&lt;/code&gt; is, and points to a contiguous region of memory terminated with a 0 byte to represent the end of the string.</source>
          <target state="translated">返されたポインタは、 &lt;code&gt;self&lt;/code&gt; が有効である限り有効であり、0バイトで終了する連続したメモリ領域を指し、文字列の終わりを表します。</target>
        </trans-unit>
        <trans-unit id="d1d3044eae78ae415d38e3ebb8ef901b44a28df4" translate="yes" xml:space="preserve">
          <source>The returned range is half-open, which means that the end pointer points &lt;em&gt;one past&lt;/em&gt; the last element of the slice. This way, an empty slice is represented by two equal pointers, and the difference between the two pointers represents the size of the slice.</source>
          <target state="translated">返される範囲はハーフオープンです。これは、エンドポインタがスライスの最後の要素の&lt;em&gt;1つ&lt;/em&gt;先を指していることを意味します。このように、空のスライスは2つの等しいポインターで表され、2つのポインターの差はスライスのサイズを表します。</target>
        </trans-unit>
        <trans-unit id="1c27af8743c2ff7ed690feb622313cb681b2d0e2" translate="yes" xml:space="preserve">
          <source>The returned slice can be used to fill the vector with data (e.g. by reading from a file) before marking the data as initialized using the &lt;a href=&quot;struct.vec#method.set_len&quot;&gt;&lt;code&gt;set_len&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">返されたスライスを使用して、&lt;a href=&quot;struct.vec#method.set_len&quot;&gt; &lt;code&gt;set_len&lt;/code&gt; &lt;/a&gt;メソッドを使用してデータを初期化済みとしてマークする前に、（ファイルから読み取るなどして）ベクトルをデータで埋めることができます。</target>
        </trans-unit>
        <trans-unit id="bf0c4a80af7569dc2827892f37e1cf7abb925f27" translate="yes" xml:space="preserve">
          <source>The returned slice does &lt;strong&gt;not&lt;/strong&gt; contain the trailing nul terminator, and it is guaranteed to not have any interior nul bytes. If you need the nul terminator, use &lt;a href=&quot;#method.as_bytes_with_nul&quot;&gt;&lt;code&gt;as_bytes_with_nul&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">返されたスライスはない&lt;strong&gt;ではない&lt;/strong&gt;末尾のNULターミネータを含み、どんなインテリアNULバイトを持っていないことが保証されます。nulターミネータが必要な場合は、代わりに&lt;a href=&quot;#method.as_bytes_with_nul&quot;&gt; &lt;code&gt;as_bytes_with_nul&lt;/code&gt; &lt;/a&gt;を使用してください。</target>
        </trans-unit>
        <trans-unit id="0a368474e9b2e8c2f52646dd2d7918f986464f59" translate="yes" xml:space="preserve">
          <source>The returned slice does &lt;strong&gt;not&lt;/strong&gt; contain the trailing nul terminator, and it is guaranteed to not have any interior nul bytes. If you need the nul terminator, use &lt;a href=&quot;struct.cstring#method.as_bytes_with_nul&quot;&gt;&lt;code&gt;CString::as_bytes_with_nul&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">返されたスライスはない&lt;strong&gt;ではない&lt;/strong&gt;末尾のNULターミネータを含み、どんなインテリアNULバイトを持っていないことが保証されます。nulターミネータが必要な場合は、代わりに&lt;a href=&quot;struct.cstring#method.as_bytes_with_nul&quot;&gt; &lt;code&gt;CString::as_bytes_with_nul&lt;/code&gt; &lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="23c2a4410e35e072d95d91733db13ddd5bf58ad1" translate="yes" xml:space="preserve">
          <source>The returned slice will &lt;strong&gt;not&lt;/strong&gt; contain the trailing nul terminator that this C string has.</source>
          <target state="translated">返されるスライスには、このC文字列が持つ末尾のヌルターミネータ&lt;strong&gt;は&lt;/strong&gt;含まれ&lt;strong&gt;ません&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="a46b9c2f552385dbbfeb1cece6cdbcca5271f43e" translate="yes" xml:space="preserve">
          <source>The returned string must not be considered to be a unique identifier of a type as multiple types may map to the same type name. Similarly, there is no guarantee that all parts of a type will appear in the returned string: for example, lifetime specifiers are currently not included. In addition, the output may change between versions of the compiler.</source>
          <target state="translated">複数の型が同じ型名にマッピングされる可能性があるため、返される文字列は型の一意の識別子と考えてはいけません。同様に、型のすべての部分が返される文字列に含まれるという保証はありません:例えば、寿命指定子は現在のところ含まれていません。さらに、コンパイラのバージョンによって出力が変わる可能性があります。</target>
        </trans-unit>
        <trans-unit id="ca6695d62fb3138a05ebea6941a15916ea38fd70" translate="yes" xml:space="preserve">
          <source>The returned type after indexing.</source>
          <target state="translated">インデックスを作成した後に返される型。</target>
        </trans-unit>
        <trans-unit id="323e9e5f7457b4d404421a53102d137f9784ffb2" translate="yes" xml:space="preserve">
          <source>The returned type after the call operator is used.</source>
          <target state="translated">呼び出しオペレータを使用した後の戻り値の型です。</target>
        </trans-unit>
        <trans-unit id="2d5978ed3eb5e45dd0ed7362549dedf897ab386a" translate="yes" xml:space="preserve">
          <source>The returned type implements &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; where the &lt;code&gt;Item&lt;/code&gt; is &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;, &lt;/code&gt;&lt;a href=&quot;struct.error&quot;&gt;&lt;code&gt;io::Error&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. The yielded item is &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt; if a byte was successfully read and &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; otherwise. EOF is mapped to returning &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; from this iterator.</source>
          <target state="translated">返されるタイプは、 &lt;code&gt;Item&lt;/code&gt; が&lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; &lt;code&gt;, &lt;/code&gt; &lt;a href=&quot;struct.error&quot;&gt; &lt;code&gt;io::Error&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; である&lt;a href=&quot;../iter/trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;実装します。生成されたアイテムは、バイトが正常に読み取られた場合は&lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt;、それ以外の場合は&lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;です。EOFは、このイテレータから&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;を返すようにマップされています。</target>
        </trans-unit>
        <trans-unit id="94490bb5f034be81aa72ad51da07b198637a8c28" translate="yes" xml:space="preserve">
          <source>The returned type implements &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; where the &lt;code&gt;Item&lt;/code&gt; is &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;, &lt;/code&gt;&lt;a href=&quot;struct.error&quot;&gt;&lt;code&gt;io::Error&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. The yielded item is &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt; if a byte was successfully read and &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; otherwise. EOF is mapped to returning &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; from this iterator.</source>
          <target state="translated">返される型は、 &lt;code&gt;Item&lt;/code&gt; が&lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; &lt;code&gt;, &lt;/code&gt; &lt;a href=&quot;struct.error&quot;&gt; &lt;code&gt;io::Error&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; である&lt;a href=&quot;../iter/trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; を&lt;/a&gt;実装します。生成されたアイテムは、バイトが正常に読み取られた場合は&lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt;、それ以外の場合は&lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;です。EOFは、このイテレータから&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;を返すようにマップされています。</target>
        </trans-unit>
        <trans-unit id="a0b4fa361f895a3f7a940a0df4cc75d5065e98e6" translate="yes" xml:space="preserve">
          <source>The returned value corresponds to the &lt;code&gt;atime&lt;/code&gt; field of &lt;code&gt;stat&lt;/code&gt; on Unix platforms and the &lt;code&gt;ftLastAccessTime&lt;/code&gt; field on Windows platforms.</source>
          <target state="translated">戻り値は、Unixプラットフォームでは &lt;code&gt;stat&lt;/code&gt; の &lt;code&gt;atime&lt;/code&gt; フィールドに、Windowsプラットフォームでは &lt;code&gt;ftLastAccessTime&lt;/code&gt; フィールドに対応します。</target>
        </trans-unit>
        <trans-unit id="ab7615b505b03838f921f8936a1701e974958831" translate="yes" xml:space="preserve">
          <source>The returned value corresponds to the &lt;code&gt;birthtime&lt;/code&gt; field of &lt;code&gt;stat&lt;/code&gt; on Unix platforms and the &lt;code&gt;ftCreationTime&lt;/code&gt; field on Windows platforms.</source>
          <target state="translated">戻り値は、Unixプラットフォームでは &lt;code&gt;stat&lt;/code&gt; の &lt;code&gt;birthtime&lt;/code&gt; フィールドに、Windowsプラットフォームでは &lt;code&gt;ftCreationTime&lt;/code&gt; フィールドに対応しています。</target>
        </trans-unit>
        <trans-unit id="2eef349b822dea9863943a97049788d8df72cce1" translate="yes" xml:space="preserve">
          <source>The returned value corresponds to the &lt;code&gt;btime&lt;/code&gt; field of &lt;code&gt;statx&lt;/code&gt; on Linux kernel starting from to 4.11, the &lt;code&gt;birthtime&lt;/code&gt; field of &lt;code&gt;stat&lt;/code&gt; on other Unix platforms, and the &lt;code&gt;ftCreationTime&lt;/code&gt; field on Windows platforms.</source>
          <target state="translated">返された値が対応する &lt;code&gt;btime&lt;/code&gt; 分野 &lt;code&gt;statx&lt;/code&gt; 4.11から始まるLinuxカーネル、上 &lt;code&gt;birthtime&lt;/code&gt; の分野 &lt;code&gt;stat&lt;/code&gt; 他のUNIXプラットフォームでは、と &lt;code&gt;ftCreationTime&lt;/code&gt; のWindowsプラットフォーム上のフィールド。</target>
        </trans-unit>
        <trans-unit id="c5896159de75927b2d1b622cfd587f254e9fed43" translate="yes" xml:space="preserve">
          <source>The returned value corresponds to the &lt;code&gt;mtime&lt;/code&gt; field of &lt;code&gt;stat&lt;/code&gt; on Unix platforms and the &lt;code&gt;ftLastWriteTime&lt;/code&gt; field on Windows platforms.</source>
          <target state="translated">戻り値は、Unixプラットフォームでは &lt;code&gt;stat&lt;/code&gt; の &lt;code&gt;mtime&lt;/code&gt; フィールドに、Windowsプラットフォームでは &lt;code&gt;ftLastWriteTime&lt;/code&gt; フィールドに対応します。</target>
        </trans-unit>
        <trans-unit id="a0ea9c14c32dc6d6e0d323b13279abc6935b1d15" translate="yes" xml:space="preserve">
          <source>The returned value does include the fractional (nanosecond) part of the duration.</source>
          <target state="translated">返される値には、持続時間の小数(ナノ秒)部分が含まれます。</target>
        </trans-unit>
        <trans-unit id="ff15d0950ff1afde3f0762acc64a9f002a6a04c1" translate="yes" xml:space="preserve">
          <source>The returned value does not have meaning for directories.</source>
          <target state="translated">返された値は、ディレクトリに対しては意味を持ちません。</target>
        </trans-unit>
        <trans-unit id="e8c08d63d79b2a138a0f12bb7a91ea3ec23dcec7" translate="yes" xml:space="preserve">
          <source>The returned value does not include the fractional (nanosecond) part of the duration, which can be obtained using &lt;a href=&quot;#method.subsec_nanos&quot;&gt;&lt;code&gt;subsec_nanos&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">戻り値には、期間の小数部分（ナノ秒）は含まれません。これは、&lt;a href=&quot;#method.subsec_nanos&quot;&gt; &lt;code&gt;subsec_nanos&lt;/code&gt; &lt;/a&gt;を使用して取得できます。</target>
        </trans-unit>
        <trans-unit id="1bfa4d7247e116de4261b1e09435dc9dcadacc45" translate="yes" xml:space="preserve">
          <source>The returned value does not include the fractional (nanosecond) part of the duration, which can be obtained using &lt;a href=&quot;struct.duration#method.subsec_nanos&quot;&gt;&lt;code&gt;subsec_nanos&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">戻り値には、&lt;a href=&quot;struct.duration#method.subsec_nanos&quot;&gt; &lt;code&gt;subsec_nanos&lt;/code&gt; &lt;/a&gt;を使用して取得できる期間の小数部（ナノ秒）は含まれません。</target>
        </trans-unit>
        <trans-unit id="1e5135e5751b93b5d235f37608301c3018208e63" translate="yes" xml:space="preserve">
          <source>The returned value is the number of &lt;strong&gt;elements&lt;/strong&gt;, not the number of bytes.</source>
          <target state="translated">戻り値は&lt;strong&gt;要素&lt;/strong&gt;の数であり、バイト数ではありません。</target>
        </trans-unit>
        <trans-unit id="70d2d5505f46c3741e892512e8371427a53745d7" translate="yes" xml:space="preserve">
          <source>The right shift assignment operator &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;.</source>
          <target state="translated">右シフト代入演算子 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e00fa6358174afd137529285f589695abe7555ab" translate="yes" xml:space="preserve">
          <source>The right shift operator &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;. Note that because this trait is implemented for all integer types with multiple right-hand-side types, Rust's type checker has special handling for &lt;code&gt;_ &amp;gt;&amp;gt; _&lt;/code&gt;, setting the result type for integer operations to the type of the left-hand-side operand. This means that though &lt;code&gt;a &amp;gt;&amp;gt; b&lt;/code&gt; and &lt;code&gt;a.shr(b)&lt;/code&gt; are one and the same from an evaluation standpoint, they are different when it comes to type inference.</source>
          <target state="translated">右シフト演算子 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 。この特性は複数の右側の型を持つすべての整数型に実装されているため、Rustの型チェッカーは &lt;code&gt;_ &amp;gt;&amp;gt; _&lt;/code&gt; に対して特別な処理を行い、整数演算の結果の型を左側のオペランドの型に設定します。 。つまり、 &lt;code&gt;a &amp;gt;&amp;gt; b&lt;/code&gt; と &lt;code&gt;a.shr(b)&lt;/code&gt; は、評価の観点からはまったく同じものですが、型推論に関しては異なります。</target>
        </trans-unit>
        <trans-unit id="4bed85e5cf48df182fbdc5f50e1999ffc9d50cbb" translate="yes" xml:space="preserve">
          <source>The right way to suppress the warning is to actually write error handling, but because you just want to crash this program when a problem occurs, you can use &lt;code&gt;expect&lt;/code&gt;. You&amp;rsquo;ll learn about recovering from errors in Chapter 9.</source>
          <target state="translated">警告を抑制する正しい方法は、実際にエラー処理を記述することですが、問題が発生したときにこのプログラムをクラッシュさせたいだけなので、 &lt;code&gt;expect&lt;/code&gt; を使用できます。エラーからの回復については、第9章で学習します。</target>
        </trans-unit>
        <trans-unit id="93b14b29a7aed966fc23a390a9832d3b882cc69b" translate="yes" xml:space="preserve">
          <source>The root directory component, appears after any prefix and before anything else.</source>
          <target state="translated">ルートディレクトリのコンポーネントは、任意の接頭辞の後に表示され、他の何かの前に表示されます。</target>
        </trans-unit>
        <trans-unit id="a168d72d668df499616b725b5ca80c1ff007a04a" translate="yes" xml:space="preserve">
          <source>The rules for &lt;a href=&quot;../special-types-and-traits#send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; match those for normal struct types, while &lt;a href=&quot;../special-types-and-traits#clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; behave as if &lt;a href=&quot;../attributes/derive&quot;&gt;derived&lt;/a&gt;. For &lt;a href=&quot;../special-types-and-traits#clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;, the order of cloning of the captured variables is left unspecified.</source>
          <target state="translated">&lt;a href=&quot;../special-types-and-traits#send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../special-types-and-traits#sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt;のルールは通常の構造体タイプのルールと一致しますが、&lt;a href=&quot;../special-types-and-traits#clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;../attributes/derive&quot;&gt;派生&lt;/a&gt;したかのように動作します。以下のために&lt;a href=&quot;../special-types-and-traits#clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt;、捕捉された変数のクローニングの順序が指定されていないままです。</target>
        </trans-unit>
        <trans-unit id="3563595879dbbd21c6c2906f7bd54a9b3679529d" translate="yes" xml:space="preserve">
          <source>The rust compiler cannot link to an external library if you don't give it its name. Example:</source>
          <target state="translated">外部ライブラリに名前を付けないと、rustコンパイラは外部ライブラリにリンクすることができません。例</target>
        </trans-unit>
        <trans-unit id="54065002f88e1cb544dc442e2b3686e62225bf94" translate="yes" xml:space="preserve">
          <source>The rust compiler maintains for each target a blacklist of ABIs unsupported on that target. If an ABI is present in such a list this usually means that the target / ABI combination is currently unsupported by llvm.</source>
          <target state="translated">rust コンパイラは各ターゲットに対して、そのターゲットでサポートされていない ABI のブラックリストを保持しています。このようなリストに ABI がある場合、これは通常、ターゲットと ABI の組み合わせが llvm によってサポートされていないことを意味します。</target>
        </trans-unit>
        <trans-unit id="e602506551cf00543c3919704a07e8c114c13f33" translate="yes" xml:space="preserve">
          <source>The rust compiler maintains for each target a list of unsupported ABIs on that target. If an ABI is present in such a list this usually means that the target / ABI combination is currently unsupported by llvm.</source>
          <target state="translated">rust コンパイラは各ターゲットに対して、そのターゲット上のサポートされていない ABI のリストを保持しています。このようなリストに ABI がある場合、これは通常、ターゲットと ABI の組み合わせが llvm によってサポートされていないことを意味します。</target>
        </trans-unit>
        <trans-unit id="d8dcfff8659995d9c806c4ff5bfe72343be6d124" translate="yes" xml:space="preserve">
          <source>The rustfix tool is included with Rust installations and can automatically fix some compiler warnings. If you&amp;rsquo;ve written code in Rust, you&amp;rsquo;ve probably seen compiler warnings. For example, consider this code:</source>
          <target state="translated">rustfixツールはRustインストールに含まれており、コンパイラの警告を自動的に修正できます。Rustでコードを記述したことがある場合、おそらくコンパイラの警告を見たことがあるでしょう。たとえば、次のコードを考えてみます。</target>
        </trans-unit>
        <trans-unit id="d95e676c8653714db7acc846f5781f129f187994" translate="yes" xml:space="preserve">
          <source>The safety and conciseness of &lt;code&gt;for&lt;/code&gt; loops make them the most commonly used loop construct in Rust. Even in situations in which you want to run some code a certain number of times, as in the countdown example that used a &lt;code&gt;while&lt;/code&gt; loop in Listing 3-3, most Rustaceans would use a &lt;code&gt;for&lt;/code&gt; loop. The way to do that would be to use a &lt;code&gt;Range&lt;/code&gt;, which is a type provided by the standard library that generates all numbers in sequence starting from one number and ending before another number.</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; ループの安全性と簡潔さにより、それらはRustで最も一般的に使用されるループ構造になります。コードリスト3-3の &lt;code&gt;while&lt;/code&gt; ループを使用したカウントダウンの例のように、コードを特定の回数実行したい場合でも、ほとんどのルスタシア人は &lt;code&gt;for&lt;/code&gt; ループを使用します。これを行う方法は、1つの数値から始まり別の数値の前に終わるすべての数値を順番に生成する標準ライブラリによって提供されるタイプである &lt;code&gt;Range&lt;/code&gt; を使用することです。</target>
        </trans-unit>
        <trans-unit id="34c5f02c44747e09b58d1ec500165079e9867619" translate="yes" xml:space="preserve">
          <source>The same applies to transmutes to &lt;code&gt;*mut fn()&lt;/code&gt;, which were observed in practice. Note though that use of this type is generally incorrect. The intention is typically to describe a function pointer, but just &lt;code&gt;fn()&lt;/code&gt; alone suffices for that. &lt;code&gt;*mut fn()&lt;/code&gt; is a pointer to a fn pointer. (Since these values are typically just passed to C code, however, this rarely makes a difference in practice.)</source>
          <target state="translated">同じことが、実際に観察された &lt;code&gt;*mut fn()&lt;/code&gt; への変換にも当てはまります。ただし、このタイプの使用は一般に正しくないことに注意してください。意図は通常、関数ポインターを記述することですが、 &lt;code&gt;fn()&lt;/code&gt; だけで十分です。 &lt;code&gt;*mut fn()&lt;/code&gt; はfnポインターへのポインターです。（ただし、これらの値は通常Cコードに渡されるだけなので、実際にはほとんど違いがありません。）</target>
        </trans-unit>
        <trans-unit id="a7f4b342720ddcec9a49dfb2ca6daf016843320d" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;../../../iter/trait.iterator#method.fold&quot;&gt;&lt;code&gt;fold()&lt;/code&gt;&lt;/a&gt;, but uses the first element in the iterator as the initial value, folding every subsequent element into it. If the iterator is empty, return &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;; otherwise, return the result of the fold. &lt;a href=&quot;../../../iter/trait.iterator#method.fold_first&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../../../iter/trait.iterator#method.fold&quot;&gt; &lt;code&gt;fold()&lt;/code&gt; &lt;/a&gt;と同じですが、イテレータの最初の要素を初期値として使用し、後続のすべての要素をフォールドします。イテレータが空の場合は、&lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; を&lt;/a&gt;返します。それ以外の場合は、折り畳みの結果を返します。&lt;a href=&quot;../../../iter/trait.iterator#method.fold_first&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c676ce454b9f3ef8b4d42559af1943bf2b7913d9" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;../../iter/trait.iterator#method.fold&quot;&gt;&lt;code&gt;fold()&lt;/code&gt;&lt;/a&gt;, but uses the first element in the iterator as the initial value, folding every subsequent element into it. If the iterator is empty, return &lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;; otherwise, return the result of the fold. &lt;a href=&quot;../../iter/trait.iterator#method.fold_first&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../../iter/trait.iterator#method.fold&quot;&gt; &lt;code&gt;fold()&lt;/code&gt; &lt;/a&gt;と同じですが、イテレータの最初の要素を初期値として使用し、後続のすべての要素をフォールドします。イテレータが空の場合は、&lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; を&lt;/a&gt;返します。それ以外の場合は、折り畳みの結果を返します。&lt;a href=&quot;../../iter/trait.iterator#method.fold_first&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fb7e4f0db03c726bc5bd7452fa0f56591b66e33d" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;../iter/trait.iterator#method.fold&quot;&gt;&lt;code&gt;fold()&lt;/code&gt;&lt;/a&gt;, but uses the first element in the iterator as the initial value, folding every subsequent element into it. If the iterator is empty, return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;; otherwise, return the result of the fold. &lt;a href=&quot;../iter/trait.iterator#method.fold_first&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../iter/trait.iterator#method.fold&quot;&gt; &lt;code&gt;fold()&lt;/code&gt; &lt;/a&gt;と同じですが、イテレータの最初の要素を初期値として使用し、後続のすべての要素をフォールドします。イテレータが空の場合は、&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; を&lt;/a&gt;返します。それ以外の場合は、折り畳みの結果を返します。&lt;a href=&quot;../iter/trait.iterator#method.fold_first&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dcf7a6ad9f8fb40e4ba7caca628efe6809216b4f" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;../iter/trait.iterator#method.fold&quot;&gt;&lt;code&gt;fold()&lt;/code&gt;&lt;/a&gt;, but uses the first element in the iterator as the initial value, folding every subsequent element into it. If the iterator is empty, return &lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;; otherwise, return the result of the fold. &lt;a href=&quot;../iter/trait.iterator#method.fold_first&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../iter/trait.iterator#method.fold&quot;&gt; &lt;code&gt;fold()&lt;/code&gt; &lt;/a&gt;と同じですが、イテレータの最初の要素を初期値として使用し、後続のすべての要素をフォールドします。イテレータが空の場合は、&lt;a href=&quot;enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; を&lt;/a&gt;返します。それ以外の場合は、折り畳みの結果を返します。&lt;a href=&quot;../iter/trait.iterator#method.fold_first&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f1ae9b3d116905ba91635f77fa80dd3badbdd424" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;iter/trait.iterator#method.fold&quot;&gt;&lt;code&gt;fold()&lt;/code&gt;&lt;/a&gt;, but uses the first element in the iterator as the initial value, folding every subsequent element into it. If the iterator is empty, return &lt;a href=&quot;option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;; otherwise, return the result of the fold. &lt;a href=&quot;iter/trait.iterator#method.fold_first&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;iter/trait.iterator#method.fold&quot;&gt; &lt;code&gt;fold()&lt;/code&gt; &lt;/a&gt;と同じですが、イテレータの最初の要素を初期値として使用し、後続のすべての要素をフォールドします。イテレータが空の場合は、&lt;a href=&quot;option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; を&lt;/a&gt;返します。それ以外の場合は、折り畳みの結果を返します。&lt;a href=&quot;iter/trait.iterator#method.fold_first&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3f595892b4fea20450f05cddbe7763f0e003caa0" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;trait.iterator#method.fold&quot;&gt;&lt;code&gt;fold()&lt;/code&gt;&lt;/a&gt;, but uses the first element in the iterator as the initial value, folding every subsequent element into it. If the iterator is empty, return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;; otherwise, return the result of the fold.</source>
          <target state="translated">&lt;a href=&quot;trait.iterator#method.fold&quot;&gt; &lt;code&gt;fold()&lt;/code&gt; &lt;/a&gt;と同じですが、イテレータの最初の要素を初期値として使用し、後続のすべての要素をフォールドします。イテレータが空の場合は、&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; を&lt;/a&gt;返します。それ以外の場合は、折り畳みの結果を返します。</target>
        </trans-unit>
        <trans-unit id="f5b129096713d6e93f0f6771f5a02e553c2efcf3" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;trait.iterator#method.fold&quot;&gt;&lt;code&gt;fold()&lt;/code&gt;&lt;/a&gt;, but uses the first element in the iterator as the initial value, folding every subsequent element into it. If the iterator is empty, return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;; otherwise, return the result of the fold. &lt;a href=&quot;trait.iterator#method.fold_first&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;trait.iterator#method.fold&quot;&gt; &lt;code&gt;fold()&lt;/code&gt; &lt;/a&gt;と同じですが、イテレータの最初の要素を初期値として使用し、後続のすべての要素をフォールドします。イテレータが空の場合は、&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; を&lt;/a&gt;返します。それ以外の場合は、折り畳みの結果を返します。&lt;a href=&quot;trait.iterator#method.fold_first&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="902a2b25118315948a58ef98f0d17bd457899153" translate="yes" xml:space="preserve">
          <source>The same goes for doc comments:</source>
          <target state="translated">docのコメントも同様です。</target>
        </trans-unit>
        <trans-unit id="2e8159833047b3772ef09e1ff09bc6721b1345cc" translate="yes" xml:space="preserve">
          <source>The same restrictions of accessing the target of the pointer as with &lt;a href=&quot;struct.weak#method.as_ptr&quot;&gt;&lt;code&gt;as_ptr&lt;/code&gt;&lt;/a&gt; apply.</source>
          <target state="translated">&lt;a href=&quot;struct.weak#method.as_ptr&quot;&gt; &lt;code&gt;as_ptr&lt;/code&gt; の&lt;/a&gt;場合と同じように、ポインタのターゲットにアクセスする際の制限が適用されます。</target>
        </trans-unit>
        <trans-unit id="2bc57fcef5c1050ba1f9373a34844306a6911e2e" translate="yes" xml:space="preserve">
          <source>The same restrictions of accessing the target of the pointer as with &lt;a href=&quot;struct.weak#method.as_raw&quot;&gt;&lt;code&gt;as_raw&lt;/code&gt;&lt;/a&gt; apply.</source>
          <target state="translated">&lt;a href=&quot;struct.weak#method.as_raw&quot;&gt; &lt;code&gt;as_raw&lt;/code&gt; &lt;/a&gt;と同じように、ポインターのターゲットにアクセスするのと同じ制限が適用されます。</target>
        </trans-unit>
        <trans-unit id="e53c2cdb1077121198b1a8746e267d3b3a805b0e" translate="yes" xml:space="preserve">
          <source>The scope in which the variable &lt;code&gt;s&lt;/code&gt; is valid is the same as any function parameter&amp;rsquo;s scope, but we don&amp;rsquo;t drop what the reference points to when it goes out of scope because we don&amp;rsquo;t have ownership. When functions have references as parameters instead of the actual values, we won&amp;rsquo;t need to return the values in order to give back ownership, because we never had ownership.</source>
          <target state="translated">変数 &lt;code&gt;s&lt;/code&gt; が有効なスコープは、関数パラメーターのスコープと同じですが、所有権がないため、スコープから外れたときに参照が指すものを削除しません。関数が実際の値の代わりにパラメーターとして参照を持つ場合、所有権がなかったため、所有権を返すために値を返す必要はありません。</target>
        </trans-unit>
        <trans-unit id="2c0f9db762db77543e23786689d772ed7e180cf6" translate="yes" xml:space="preserve">
          <source>The scopes of the immutable references &lt;code&gt;r1&lt;/code&gt; and &lt;code&gt;r2&lt;/code&gt; end after the &lt;code&gt;println!&lt;/code&gt; where they are last used, which is before the mutable reference &lt;code&gt;r3&lt;/code&gt; is created. These scopes don&amp;rsquo;t overlap, so this code is allowed.</source>
          <target state="translated">不変参照 &lt;code&gt;r1&lt;/code&gt; および &lt;code&gt;r2&lt;/code&gt; のスコープは、 &lt;code&gt;println!&lt;/code&gt; の後に終了します。それらが最後に使用された場所。これは、可変参照 &lt;code&gt;r3&lt;/code&gt; が作成される前です。これらのスコープは重複しないため、このコードは許可されます。</target>
        </trans-unit>
        <trans-unit id="547c47e37f57601f738482d42256219a9633dd7e" translate="yes" xml:space="preserve">
          <source>The search path to be used may be controlled by setting the &lt;code&gt;PATH&lt;/code&gt; environment variable on the Command, but this has some implementation limitations on Windows (see issue #37519).</source>
          <target state="translated">使用する検索パスは、コマンドに &lt;code&gt;PATH&lt;/code&gt; 環境変数を設定することで制御できますが、これにはWindowsでの実装上の制限があります（問題＃37519を参照）。</target>
        </trans-unit>
        <trans-unit id="3a555019f8dcc01c39b7fc4a4df1fa78e901c698" translate="yes" xml:space="preserve">
          <source>The second case example is a bit particular: the main function must always have this definition:</source>
          <target state="translated">2 番目の例は少し特殊です:メイン関数は常にこの定義を持っていなければなりません。</target>
        </trans-unit>
        <trans-unit id="02a1a4dab2732977e1598d466f79a0132530331a" translate="yes" xml:space="preserve">
          <source>The second form of macros is &lt;em&gt;procedural macros&lt;/em&gt;, which act more like functions (and are a type of procedure). Procedural macros accept some code as an input, operate on that code, and produce some code as an output rather than matching against patterns and replacing the code with other code as declarative macros do.</source>
          <target state="translated">マクロの2番目の形式は、&lt;em&gt;手続き型マクロ&lt;/em&gt;であり、関数のように機能します（手続きの一種です）。手続き型マクロは、一部のコードを入力として受け入れ、そのコードを操作して、パターンと照合して宣言型マクロのようにコードを他のコードに置き換えるのではなく、一部のコードを出力として生成します。</target>
        </trans-unit>
        <trans-unit id="014f5e70707fe70de5f920ceaf6bbf6f00b7acd7" translate="yes" xml:space="preserve">
          <source>The second half of the tuple that is returned is an &lt;a href=&quot;../option/enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. A &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; here means that either there is no known upper bound, or the upper bound is larger than &lt;a href=&quot;../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">返されるタプルの後半は&lt;a href=&quot;../option/enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../primitive.usize&quot;&gt; &lt;code&gt;usize&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; です。&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;ここにありませんが知られているいずれかのことを意味は上限ない、または上よりも大きくなっているバインド&lt;a href=&quot;../primitive.usize&quot;&gt; &lt;code&gt;usize&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4961749eb1f24345f8436cc7b35d0ebccb81384a" translate="yes" xml:space="preserve">
          <source>The second invariant says that a separated complex NT must use a separator token that is part of the predetermined follow set for the internal contents of the NT. This ensures that a legal macro definition will continue to parse an input fragment into the same delimited sequence of &lt;code&gt;tt ...&lt;/code&gt;'s, even as new syntactic forms are added to the language.</source>
          <target state="translated">2番目の不変条件は、分離された複雑なNTは、NTの内部コンテンツの事前に設定されたフォローセットの一部であるセパレータトークンを使用する必要があることを示しています。これにより、新しい構文形式が言語に追加されても、合法的なマクロ定義が入力フラグメントを &lt;code&gt;tt ...&lt;/code&gt; の同じ区切られたシーケンスに解析し続けることが保証されます。</target>
        </trans-unit>
        <trans-unit id="3069a4f51af6a3b6633b4d681ece722a85d63fa2" translate="yes" xml:space="preserve">
          <source>The second is mutable references. They can be created from &lt;code&gt;mut&lt;/code&gt; variables and must be unique: no other variables can have a mutable reference, nor a shared reference.</source>
          <target state="translated">2つ目は、変更可能な参照です。それらは &lt;code&gt;mut&lt;/code&gt; 変数から作成でき、一意である必要があります。他の変数が可変参照や共有参照を持つことはできません。</target>
        </trans-unit>
        <trans-unit id="3f2dca747a6f3fa79f2291ae843df5963e36bbc5" translate="yes" xml:space="preserve">
          <source>The second is that it is the offset in bytes between successive elements in an array with that item type.</source>
          <target state="translated">2つ目は、その項目型を持つ配列の連続する要素間のバイト単位のオフセットです。</target>
        </trans-unit>
        <trans-unit id="a1e02e9dcee081f5b8c19c27d767e65c0ff37f76" translate="yes" xml:space="preserve">
          <source>The second is to generally improve your knowledge of a facet of the language. In that case, just browse the table of contents until you see something you want to know more about, and just start reading. If a link looks interesting, click it, and read about that section.</source>
          <target state="translated">2つ目は、一般的に言語の一面に関する知識を向上させることです。その場合は、もっと知りたいことが見つかるまで目次を見て、読み始めてください。興味がありそうなリンクがあれば、それをクリックして、そのセクションについて読んでください。</target>
        </trans-unit>
        <trans-unit id="df5949936d6a2cd7eaf61fe27eb1fac54cf960fb" translate="yes" xml:space="preserve">
          <source>The second line that we added to the middle of the code prints the secret number. This is useful while we&amp;rsquo;re developing the program to be able to test it, but we&amp;rsquo;ll delete it from the final version. It&amp;rsquo;s not much of a game if the program prints the answer as soon as it starts!</source>
          <target state="translated">コードの中央に追加した2行目には、秘密の番号が出力されます。これは、プログラムをテストしてテストできるようにするときに役立ちますが、最終バージョンから削除します。プログラムが開始するとすぐに答えを出力するのは、それほど大したことではありません。</target>
        </trans-unit>
        <trans-unit id="c1f82d829df68033c418a80c29f6453df31bb3f7" translate="yes" xml:space="preserve">
          <source>The second operand of a &lt;a href=&quot;expressions/operator-expr#lazy-boolean-operators&quot;&gt;lazy boolean expression&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;expressions/operator-expr#lazy-boolean-operators&quot;&gt;怠惰なブール式&lt;/a&gt;の第2オペランド。</target>
        </trans-unit>
        <trans-unit id="57bb822113e197cd1e10145a43fbd748bc848a6a" translate="yes" xml:space="preserve">
          <source>The second problem with the current &lt;code&gt;Cacher&lt;/code&gt; implementation is that it only accepts closures that take one parameter of type &lt;code&gt;u32&lt;/code&gt; and return a &lt;code&gt;u32&lt;/code&gt;. We might want to cache the results of closures that take a string slice and return &lt;code&gt;usize&lt;/code&gt; values, for example. To fix this issue, try introducing more generic parameters to increase the flexibility of the &lt;code&gt;Cacher&lt;/code&gt; functionality.</source>
          <target state="translated">現在の第2の問題 &lt;code&gt;Cacher&lt;/code&gt; の実装は、それが唯一のタイプの一つのパラメータ取る閉鎖受け入れるということです &lt;code&gt;u32&lt;/code&gt; して返す &lt;code&gt;u32&lt;/code&gt; 。たとえば、文字列スライスを取り、 &lt;code&gt;usize&lt;/code&gt; 値を返すクロージャの結果をキャッシュしたい場合があります。この問題を修正するには、より一般的なパラメーターを導入して、 &lt;code&gt;Cacher&lt;/code&gt; 機能の柔軟性を高めてください。</target>
        </trans-unit>
        <trans-unit id="92462e612674a20cc7e3c63f701740ce5bea5c75" translate="yes" xml:space="preserve">
          <source>The second rule applies because there is exactly one input lifetime. The second rule specifies that the lifetime of the one input parameter gets assigned to the output lifetime, so the signature is now this:</source>
          <target state="translated">2番目の規則が適用されるのは、入力パラメータの寿命が正確に1つであるからです。2番目の規則は、1つの入力パラメータの寿命が出力の寿命に代入されることを指定しているので、シグネチャは次のようになります。</target>
        </trans-unit>
        <trans-unit id="66815e0776a29457690bd505c60d2e19937fa654" translate="yes" xml:space="preserve">
          <source>The second rule is if there is exactly one input lifetime parameter, that lifetime is assigned to all output lifetime parameters: &lt;code&gt;fn foo&amp;lt;'a&amp;gt;(x: &amp;amp;'a i32) -&amp;gt; &amp;amp;'a i32&lt;/code&gt;.</source>
          <target state="translated">2番目のルールは、入力存続期間パラメーターが1つだけある場合、その存続期間はすべての出力存続期間パラメーターに割り当てられます： &lt;code&gt;fn foo&amp;lt;'a&amp;gt;(x: &amp;amp;'a i32) -&amp;gt; &amp;amp;'a i32&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aedd96f8435bb44ce30001804fbe27f5473ed0ee" translate="yes" xml:space="preserve">
          <source>The second time we call &lt;code&gt;add_to_waitlist&lt;/code&gt; in &lt;code&gt;eat_at_restaurant&lt;/code&gt;, we use a relative path. The path starts with &lt;code&gt;front_of_house&lt;/code&gt;, the name of the module defined at the same level of the module tree as &lt;code&gt;eat_at_restaurant&lt;/code&gt;. Here the filesystem equivalent would be using the path &lt;code&gt;front_of_house/hosting/add_to_waitlist&lt;/code&gt;. Starting with a name means that the path is relative.</source>
          <target state="translated">2回目に &lt;code&gt;add_to_waitlist&lt;/code&gt; で &lt;code&gt;eat_at_restaurant&lt;/code&gt; を呼び出すときは、相対パスを使用します。パスが始まる &lt;code&gt;front_of_house&lt;/code&gt; としてモジュール・ツリーの同じレベルで定義されたモジュールの名前、 &lt;code&gt;eat_at_restaurant&lt;/code&gt; 。ここで同等のファイルシステムは、パス &lt;code&gt;front_of_house/hosting/add_to_waitlist&lt;/code&gt; を使用します。名前で始まるということは、パスが相対パスであることを意味します。</target>
        </trans-unit>
        <trans-unit id="6719785aa3871b4c2a2d425aeb686279358fe018" translate="yes" xml:space="preserve">
          <source>The second trait important to the smart pointer pattern is &lt;code&gt;Drop&lt;/code&gt;, which lets you customize what happens when a value is about to go out of scope. You can provide an implementation for the &lt;code&gt;Drop&lt;/code&gt; trait on any type, and the code you specify can be used to release resources like files or network connections. We&amp;rsquo;re introducing &lt;code&gt;Drop&lt;/code&gt; in the context of smart pointers because the functionality of the &lt;code&gt;Drop&lt;/code&gt; trait is almost always used when implementing a smart pointer. For example, &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; customizes &lt;code&gt;Drop&lt;/code&gt; to deallocate the space on the heap that the box points to.</source>
          <target state="translated">スマートポインターパターンにとって2番目に重要な特性は &lt;code&gt;Drop&lt;/code&gt; です。これにより、値がスコープから外れるときにどうなるかをカスタマイズできます。任意のタイプの &lt;code&gt;Drop&lt;/code&gt; トレイトの実装を提供でき、指定したコードを使用して、ファイルやネットワーク接続などのリソースを解放できます。スマートポインターを実装する場合、ほとんどの場合 &lt;code&gt;Drop&lt;/code&gt; トレイトの機能が使用されるため、スマートポインターのコンテキストで &lt;code&gt;Drop&lt;/code&gt; を導入します。たとえば、 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;code&gt;Drop&lt;/code&gt; をカスタマイズして、ボックスが指すヒープ上のスペースの割り当てを解除します。</target>
        </trans-unit>
        <trans-unit id="445effcb8001016422ef7635d91738ff3683b61e" translate="yes" xml:space="preserve">
          <source>The second trait important to the smart pointer pattern is &lt;code&gt;Drop&lt;/code&gt;, which lets you customize what happens when a value is about to go out of scope. You can provide an implementation for the &lt;code&gt;Drop&lt;/code&gt; trait on any type, and the code you specify can be used to release resources like files or network connections. We&amp;rsquo;re introducing &lt;code&gt;Drop&lt;/code&gt; in the context of smart pointers because the functionality of the &lt;code&gt;Drop&lt;/code&gt; trait is almost always used when implementing a smart pointer. For example, when a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; is dropped it will deallocate the space on the heap that the box points to.</source>
          <target state="translated">スマートポインタパターンにとって重要な2番目の特性は &lt;code&gt;Drop&lt;/code&gt; です。これにより、値がスコープから外れそうになったときに何が起こるかをカスタマイズできます。 &lt;code&gt;Drop&lt;/code&gt; 特性の実装を任意のタイプで提供でき、指定したコードを使用して、ファイルやネットワーク接続などのリソースを解放できます。 &lt;code&gt;Drop&lt;/code&gt; 特性の機能はほとんどの場合、スマートポインターを実装するときに使用されるため、スマートポインターのコンテキストで &lt;code&gt;Drop&lt;/code&gt; を導入します。たとえば、 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; をドロップすると、ボックスが指すヒープ上のスペースの割り当てが解除されます。</target>
        </trans-unit>
        <trans-unit id="b9253951b95bdbecdb3d6ee784fab1524db5c9af" translate="yes" xml:space="preserve">
          <source>The second type of operation that requires an unsafe block is calls to unsafe functions. Unsafe functions and methods look exactly like regular functions and methods, but they have an extra &lt;code&gt;unsafe&lt;/code&gt; before the rest of the definition. The &lt;code&gt;unsafe&lt;/code&gt; keyword in this context indicates the function has requirements we need to uphold when we call this function, because Rust can&amp;rsquo;t guarantee we&amp;rsquo;ve met these requirements. By calling an unsafe function within an &lt;code&gt;unsafe&lt;/code&gt; block, we&amp;rsquo;re saying that we&amp;rsquo;ve read this function&amp;rsquo;s documentation and take responsibility for upholding the function&amp;rsquo;s contracts.</source>
          <target state="translated">安全でないブロックを必要とする2番目のタイプの操作は、安全でない関数の呼び出しです。安全でない関数とメソッドは、通常の関数とメソッドとまったく同じように見えますが、残りの定義の前に、余分な &lt;code&gt;unsafe&lt;/code&gt; がありません。このコンテキストでの &lt;code&gt;unsafe&lt;/code&gt; キーワードは、Rustがこれらの要件を満たしていることを保証できないため、この関数を呼び出すときに維持する必要がある要件が関数にあることを示しています。 &lt;code&gt;unsafe&lt;/code&gt; ブロック内で安全でない関数を呼び出すことにより、この関数のドキュメントを読み、関数のコントラクトを維持する責任を負うことになります。</target>
        </trans-unit>
        <trans-unit id="3b5790cbd3c99b8bfcd34f57b9dbfe5e2b8bc741" translate="yes" xml:space="preserve">
          <source>The second-to-last line of the output shows the location and the name of the installed binary, which in the case of &lt;code&gt;ripgrep&lt;/code&gt; is &lt;code&gt;rg&lt;/code&gt;. As long as the installation directory is in your &lt;code&gt;$PATH&lt;/code&gt;, as mentioned previously, you can then run &lt;code&gt;rg --help&lt;/code&gt; and start using a faster, rustier tool for searching files!</source>
          <target state="translated">出力の最後から2番目の行には、インストールされているバイナリの場所と名前が表示されます &lt;code&gt;ripgrep&lt;/code&gt; の場合は &lt;code&gt;rg&lt;/code&gt; です。前述のように、インストールディレクトリが &lt;code&gt;$PATH&lt;/code&gt; にある限り、 &lt;code&gt;rg --help&lt;/code&gt; を実行して、ファイルを検索するためのより高速で錆びたツールの使用を開始できます。</target>
        </trans-unit>
        <trans-unit id="599ddbb55a436b4b2320e8d917bb378c0d788288" translate="yes" xml:space="preserve">
          <source>The semantics for passing a value to a function are similar to those for assigning a value to a variable. Passing a variable to a function will move or copy, just as assignment does. Listing 4-3 has an example with some annotations showing where variables go into and out of scope.</source>
          <target state="translated">関数に値を渡すときのセマンティクスは、変数に値を代入するときのセマンティクスと似ています。変数を関数に渡すことは代入が行われるのと同じように、移動もしくはコピーを行います。リスト4-3は変数がスコープに入ったりスコープ外に出たりする場所を示す注釈をつけた例を示しています。</target>
        </trans-unit>
        <trans-unit id="0ebf78e0ec598941096cd9f3613dea835a20177d" translate="yes" xml:space="preserve">
          <source>The semantics of this function are equivalent to &lt;a href=&quot;#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; except that the thread will be blocked for roughly no longer than &lt;code&gt;dur&lt;/code&gt;. This method should not be used for precise timing due to anomalies such as preemption or platform differences that may not cause the maximum amount of time waited to be precisely &lt;code&gt;dur&lt;/code&gt;.</source>
          <target state="translated">この関数のセマンティクスは、スレッドがおよそ &lt;code&gt;dur&lt;/code&gt; より長くブロックされないことを除いて、&lt;a href=&quot;#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;と同等です。この方法は、プリエンプションやプラットフォームの違いなどの異常が原因で、最大待機時間を正確に &lt;code&gt;dur&lt;/code&gt; できない可能性があるため、正確なタイミングには使用しないでください。</target>
        </trans-unit>
        <trans-unit id="9f8ab2e3b0b43343b07ba616db0d9b83ddc1ec9a" translate="yes" xml:space="preserve">
          <source>The semantics of this function are equivalent to &lt;a href=&quot;#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; except that the thread will be blocked for roughly no longer than &lt;code&gt;ms&lt;/code&gt; milliseconds. This method should not be used for precise timing due to anomalies such as preemption or platform differences that may not cause the maximum amount of time waited to be precisely &lt;code&gt;ms&lt;/code&gt;.</source>
          <target state="translated">この関数のセマンティクスは、スレッドがおよそ &lt;code&gt;ms&lt;/code&gt; ミリ秒を超えてブロックされることを除いて、&lt;a href=&quot;#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;と同等です。この方法は、プリエンプションやプラットフォームの違いなどの異常により、最大待機時間を正確に &lt;code&gt;ms&lt;/code&gt; にすることができないため、正確なタイミングには使用しないでください。</target>
        </trans-unit>
        <trans-unit id="10369644dc806ec3584f4bc1cd00c1b37924dd8f" translate="yes" xml:space="preserve">
          <source>The semantics of this function are equivalent to &lt;a href=&quot;#method.wait_until&quot;&gt;&lt;code&gt;wait_until&lt;/code&gt;&lt;/a&gt; except that the thread will be blocked for roughly no longer than &lt;code&gt;dur&lt;/code&gt;. This method should not be used for precise timing due to anomalies such as preemption or platform differences that may not cause the maximum amount of time waited to be precisely &lt;code&gt;dur&lt;/code&gt;.</source>
          <target state="translated">この関数のセマンティクスは、スレッドがおよそ &lt;code&gt;dur&lt;/code&gt; より長くブロックされることを除いて、&lt;a href=&quot;#method.wait_until&quot;&gt; &lt;code&gt;wait_until&lt;/code&gt; &lt;/a&gt;と同等です。この方法は、プリエンプションやプラットフォームの違いなどの異常が原因で、最大待機時間を正確に &lt;code&gt;dur&lt;/code&gt; できない可能性があるため、正確なタイミングには使用しないでください。</target>
        </trans-unit>
        <trans-unit id="599bdbbdba24d3dd39b2e820e78610be901175cf" translate="yes" xml:space="preserve">
          <source>The semantics of this function are equivalent to &lt;a href=&quot;fn.park&quot;&gt;&lt;code&gt;park&lt;/code&gt;&lt;/a&gt; except that the thread will be blocked for roughly no longer than &lt;code&gt;dur&lt;/code&gt;. This method should not be used for precise timing due to anomalies such as preemption or platform differences that may not cause the maximum amount of time waited to be precisely &lt;code&gt;dur&lt;/code&gt; long.</source>
          <target state="translated">この関数のセマンティクスは、スレッドがおよそ &lt;code&gt;dur&lt;/code&gt; より長くブロックされることを除いて、&lt;a href=&quot;fn.park&quot;&gt; &lt;code&gt;park&lt;/code&gt; &lt;/a&gt;と同等です。この方法は、そのような時間の最大量を正確にする待機引き起こさないプリエンプションまたはプラットフォームの違いなどの異常を正確なタイミングのために使用すべきではない &lt;code&gt;dur&lt;/code&gt; 長いです。</target>
        </trans-unit>
        <trans-unit id="9563714599dd3161cea050e5c59d88f3adc62446" translate="yes" xml:space="preserve">
          <source>The semantics of this function are equivalent to &lt;a href=&quot;fn.park&quot;&gt;&lt;code&gt;park&lt;/code&gt;&lt;/a&gt; except that the thread will be blocked for roughly no longer than &lt;code&gt;dur&lt;/code&gt;. This method should not be used for precise timing due to anomalies such as preemption or platform differences that may not cause the maximum amount of time waited to be precisely &lt;code&gt;ms&lt;/code&gt; long.</source>
          <target state="translated">この関数のセマンティクスは、スレッドがおよそ &lt;code&gt;dur&lt;/code&gt; より長くブロックされないことを除いて、&lt;a href=&quot;fn.park&quot;&gt; &lt;code&gt;park&lt;/code&gt; &lt;/a&gt;と同等です。この方法は、プリエンプションやプラットフォームの違いなどの異常により、最大待機時間を正確に &lt;code&gt;ms&lt;/code&gt; にできないため、正確なタイミングには使用しないでください。</target>
        </trans-unit>
        <trans-unit id="8ace657d10944a484e642331ec94fc1a6e6161be" translate="yes" xml:space="preserve">
          <source>The semantics of this function are equivalent to &lt;a href=&quot;struct.condvar#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; except that the thread will be blocked for roughly no longer than &lt;code&gt;dur&lt;/code&gt;. This method should not be used for precise timing due to anomalies such as preemption or platform differences that may not cause the maximum amount of time waited to be precisely &lt;code&gt;dur&lt;/code&gt;.</source>
          <target state="translated">この関数のセマンティクスは、スレッドがおよそ &lt;code&gt;dur&lt;/code&gt; より長くブロックされないことを除いて、&lt;a href=&quot;struct.condvar#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;と同等です。この方法は、プリエンプションやプラットフォームの違いなどの異常が原因で正確なタイミングをとるのに使用しないでください。これにより、最大待機時間が正確に &lt;code&gt;dur&lt;/code&gt; なることはありません。</target>
        </trans-unit>
        <trans-unit id="d3371efd221cedf557721fc9ee15bda8759a39a9" translate="yes" xml:space="preserve">
          <source>The semantics of this function are equivalent to &lt;a href=&quot;struct.condvar#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; except that the thread will be blocked for roughly no longer than &lt;code&gt;ms&lt;/code&gt; milliseconds. This method should not be used for precise timing due to anomalies such as preemption or platform differences that may not cause the maximum amount of time waited to be precisely &lt;code&gt;ms&lt;/code&gt;.</source>
          <target state="translated">この関数のセマンティクスは、スレッドがおよそ &lt;code&gt;ms&lt;/code&gt; 秒以内にブロックされることを除いて、&lt;a href=&quot;struct.condvar#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;と同等です。この方法は、プリエンプションやプラットフォームの違いなど、最大待機時間が正確に &lt;code&gt;ms&lt;/code&gt; ならない可能性があるため、正確なタイミングには使用しないでください。</target>
        </trans-unit>
        <trans-unit id="6e595d1de9f2e3618f10b608ff234b6ad2944f66" translate="yes" xml:space="preserve">
          <source>The semantics of this function are equivalent to &lt;a href=&quot;struct.condvar#method.wait_while&quot;&gt;&lt;code&gt;wait_while&lt;/code&gt;&lt;/a&gt; except that the thread will be blocked for roughly no longer than &lt;code&gt;dur&lt;/code&gt;. This method should not be used for precise timing due to anomalies such as preemption or platform differences that may not cause the maximum amount of time waited to be precisely &lt;code&gt;dur&lt;/code&gt;.</source>
          <target state="translated">この関数のセマンティクスは、スレッドがおおよそ &lt;code&gt;dur&lt;/code&gt; を超えてブロックされないことを除いて、&lt;a href=&quot;struct.condvar#method.wait_while&quot;&gt; &lt;code&gt;wait_while&lt;/code&gt; &lt;/a&gt;と同等です。この方法は、プリエンプションやプラットフォームの違いなどの異常が原因で正確なタイミングをとるのに使用しないでください。これにより、最大待機時間が正確に &lt;code&gt;dur&lt;/code&gt; なることはありません。</target>
        </trans-unit>
        <trans-unit id="9ce3d66bfcd3164df001d8c8d3ea53b374782f46" translate="yes" xml:space="preserve">
          <source>The semicolon &lt;code&gt;;&lt;/code&gt; can be used to discard the result of an expression at the end of a block, making the expression (and thus the block) evaluate to &lt;code&gt;()&lt;/code&gt;. For example,</source>
          <target state="translated">セミコロン &lt;code&gt;;&lt;/code&gt; ブロックの最後にある式の結果を破棄して、式（つまりブロック）を &lt;code&gt;()&lt;/code&gt; に評価するために使用できます。例えば、</target>
        </trans-unit>
        <trans-unit id="bb5601bddd79e71c2b7b66e9a5ead92eff60bcdd" translate="yes" xml:space="preserve">
          <source>The send and receive operations on channels will all return a &lt;a href=&quot;../../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; indicating whether the operation succeeded or not. An unsuccessful operation is normally indicative of the other half of a channel having &quot;hung up&quot; by being dropped in its corresponding thread.</source>
          <target state="translated">チャネルの送受信操作はすべて、操作が成功したかどうかを示す&lt;a href=&quot;../../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt;を返します。操作の失敗は、通常、対応するスレッドにドロップされることにより、チャネルのもう半分が「ハングアップ」したことを示しています。</target>
        </trans-unit>
        <trans-unit id="ea8d26ff0d36fb568a938927807eafbc1ae6f29d" translate="yes" xml:space="preserve">
          <source>The sending-half of Rust's asynchronous &lt;a href=&quot;fn.channel&quot;&gt;&lt;code&gt;channel&lt;/code&gt;&lt;/a&gt; type. This half can only be owned by one thread, but it can be cloned to send to other threads.</source>
          <target state="translated">Rustの非同期&lt;a href=&quot;fn.channel&quot;&gt; &lt;code&gt;channel&lt;/code&gt; &lt;/a&gt;タイプの送信側の半分。この半分は1つのスレッドのみが所有できますが、複製して他のスレッドに送信できます。</target>
        </trans-unit>
        <trans-unit id="52ce535fefd9bc68502a1a5978b6409a82fd1bcb" translate="yes" xml:space="preserve">
          <source>The sending-half of Rust's synchronous &lt;a href=&quot;fn.sync_channel&quot;&gt;&lt;code&gt;sync_channel&lt;/code&gt;&lt;/a&gt; type.</source>
          <target state="translated">Rustの同期&lt;a href=&quot;fn.sync_channel&quot;&gt; &lt;code&gt;sync_channel&lt;/code&gt; &lt;/a&gt;タイプの送信側の半分。</target>
        </trans-unit>
        <trans-unit id="937e495e6de5b225295fc788a2b8a9723c5d12e3" translate="yes" xml:space="preserve">
          <source>The sequential nature of the tuple applies to its implementations of various traits. For example, in &lt;code&gt;PartialOrd&lt;/code&gt; and &lt;code&gt;Ord&lt;/code&gt;, the elements are compared sequentially until the first non-equal set is found.</source>
          <target state="translated">タプルの順次的な性質は、さまざまな特性の実装に適用されます。たとえば、 &lt;code&gt;PartialOrd&lt;/code&gt; と &lt;code&gt;Ord&lt;/code&gt; では、最初の等しくないセットが見つかるまで、要素が順番に比較されます。</target>
        </trans-unit>
        <trans-unit id="faf864ad82a0182728e07d76ebfb5f1fdf6dc8f4" translate="yes" xml:space="preserve">
          <source>The signed two's complement integer types consist of:</source>
          <target state="translated">符号付き2の補数整数型は、以下のように構成されます。</target>
        </trans-unit>
        <trans-unit id="0a593fcbffb90fbe9434a8bd0cd231a38381ce34" translate="yes" xml:space="preserve">
          <source>The simplest Rust programs, like the one we&amp;rsquo;ve written so far, don&amp;rsquo;t have any dependencies. So if we had built the &amp;ldquo;Hello, world!&amp;rdquo; project with Cargo, it would only use the part of Cargo that handles building your code. As you write more complex Rust programs, you&amp;rsquo;ll add dependencies, and if you start a project using Cargo, adding dependencies will be much easier to do.</source>
          <target state="translated">これまでに作成したような最も単純なRustプログラムには、依存関係はありません。つまり、「Hello、world！」を構築した場合です。Cargoを使用したプロジェクトでは、コードのビルドを処理するCargoの部分のみを使用します。より複雑なRustプログラムを作成すると、依存関係が追加されます。Cargoを使用してプロジェクトを開始すると、依存関係の追加がはるかに簡単になります。</target>
        </trans-unit>
        <trans-unit id="0dca1ad1ce59bbb51cae453b849e2d3bd139c7cf" translate="yes" xml:space="preserve">
          <source>The simplest Rust programs, like the one we&amp;rsquo;ve written so far, don&amp;rsquo;t have any dependencies. So if we had built the Hello, world! project with Cargo, it would only use the part of Cargo that handles building your code. As you write more complex Rust programs, you&amp;rsquo;ll add dependencies, and if you start a project using Cargo, adding dependencies will be much easier to do.</source>
          <target state="translated">これまでに作成したような最も単純なRustプログラムには、依存関係はありません。もしもしHello、world！Cargoを使用したプロジェクトでは、コードのビルドを処理するCargoの部分のみを使用します。より複雑なRustプログラムを作成すると、依存関係が追加されます。Cargoを使用してプロジェクトを開始すると、依存関係の追加がはるかに簡単になります。</target>
        </trans-unit>
        <trans-unit id="cc9fb663ff26b10b3b0480942ea72891d7b9e8a8" translate="yes" xml:space="preserve">
          <source>The single-address property of statics is required.</source>
          <target state="translated">statics の single-address プロパティは必須です。</target>
        </trans-unit>
        <trans-unit id="019cb91a15aad53bc6628eee08e1df33b769b170" translate="yes" xml:space="preserve">
          <source>The size and offset of fields is determined by the following algorithm.</source>
          <target state="translated">フィールドのサイズとオフセットは、以下のアルゴリズムで決定されます。</target>
        </trans-unit>
        <trans-unit id="cd076db2ed4f4f71100b51cbd80768553b1f9904" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;SocketAddr&lt;/code&gt; instance may vary depending on the target operating system.</source>
          <target state="translated">&lt;code&gt;SocketAddr&lt;/code&gt; インスタンスのサイズは、ターゲットのオペレーティングシステムによって異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="36d5ae29044e3939345f3681fd2eee4951ec1d94" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;SocketAddrV4&lt;/code&gt; struct may vary depending on the target operating system.</source>
          <target state="translated">&lt;code&gt;SocketAddrV4&lt;/code&gt; 構造体のサイズは、ターゲットのオペレーティングシステムによって異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="aa0a80c41eafe63e764438582cea6579e34fa99a" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;SocketAddrV6&lt;/code&gt; struct may vary depending on the target operating system.</source>
          <target state="translated">&lt;code&gt;SocketAddrV6&lt;/code&gt; 構造体のサイズは、ターゲットのオペレーティングシステムによって異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="e8de810002bae6a69cc3fd5fc7b805d907b3e5fa" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;SystemTime&lt;/code&gt; struct may vary depending on the target operating system.</source>
          <target state="translated">&lt;code&gt;SystemTime&lt;/code&gt; 構造体のサイズは、ターゲットのオペレーティングシステムによって異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="5b0dd86b903ec8c3b54b21a61cbefcfccd34c7a3" translate="yes" xml:space="preserve">
          <source>The size of a recursive type must be finite; in other words the recursive fields of the type must be &lt;a href=&quot;types/pointer&quot;&gt;pointer types&lt;/a&gt;.</source>
          <target state="translated">再帰型のサイズは有限でなければなりません。つまり、型の再帰フィールドは&lt;a href=&quot;types/pointer&quot;&gt;ポインタ&lt;/a&gt;型でなければなりません。</target>
        </trans-unit>
        <trans-unit id="c26f5c42f6a164861e02ed67750e160fcf8f0712" translate="yes" xml:space="preserve">
          <source>The size of a symbolic link is the length of the pathname it contains, without a terminating null byte.</source>
          <target state="translated">シンボリックリンクのサイズは、それが含むパス名の長さで、終端のヌルバイトは含まれていません。</target>
        </trans-unit>
        <trans-unit id="e1eaacf69ef80cbba3a3f01cf2e10bd4a9a5fca5" translate="yes" xml:space="preserve">
          <source>The size of a type in bytes.</source>
          <target state="translated">タイプのサイズをバイト単位で指定します。</target>
        </trans-unit>
        <trans-unit id="96cd8943bd738b362434700faacd7dc900194564" translate="yes" xml:space="preserve">
          <source>The size of a union is the size of its largest field.</source>
          <target state="translated">組合の大きさは、その最大のフィールドの大きさです。</target>
        </trans-unit>
        <trans-unit id="b7e7e7e0bae0750a49867bf9a72696378b080c09" translate="yes" xml:space="preserve">
          <source>The size of a value has two definitions.</source>
          <target state="translated">値のサイズには2つの定義があります。</target>
        </trans-unit>
        <trans-unit id="5e402a67efb4a62fa553a5f1394c869ac08acac0" translate="yes" xml:space="preserve">
          <source>The size of an &lt;code&gt;Instant&lt;/code&gt; struct may vary depending on the target operating system.</source>
          <target state="translated">&lt;code&gt;Instant&lt;/code&gt; struct のサイズは、ターゲットのオペレーティングシステムによって異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="ba89d7b73eb9567f0b0c3196e6cf2e84c9f4c35c" translate="yes" xml:space="preserve">
          <source>The size of an &lt;code&gt;IpAddr&lt;/code&gt; instance may vary depending on the target operating system.</source>
          <target state="translated">&lt;code&gt;IpAddr&lt;/code&gt; インスタンスのサイズは、ターゲットのオペレーティングシステムによって異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="64ef5aa718e0f2a4fb9998a036169d75f54db6df" translate="yes" xml:space="preserve">
          <source>The size of an &lt;code&gt;Ipv4Addr&lt;/code&gt; struct may vary depending on the target operating system.</source>
          <target state="translated">&lt;code&gt;Ipv4Addr&lt;/code&gt; 構造体のサイズは、ターゲットのオペレーティングシステムによって異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="b28d6468d140c4a12bab4e35b4415d244e5f859a" translate="yes" xml:space="preserve">
          <source>The size of an &lt;code&gt;Ipv6Addr&lt;/code&gt; struct may vary depending on the target operating system.</source>
          <target state="translated">&lt;code&gt;Ipv6Addr&lt;/code&gt; 構造体のサイズは、ターゲットのオペレーティングシステムによって異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="a01d57dab257711e2df9579c72d88d59028c40dc" translate="yes" xml:space="preserve">
          <source>The size of most primitives is given in this table.</source>
          <target state="translated">ほとんどのプリミティブのサイズをこの表に示します。</target>
        </trans-unit>
        <trans-unit id="5a098a792b06569a6bb6f2b7d98cf8797dcd4ec6" translate="yes" xml:space="preserve">
          <source>The size of the referenced value in bytes.</source>
          <target state="translated">参照される値のサイズをバイト単位で指定します。</target>
        </trans-unit>
        <trans-unit id="62333b23a5b2b89de3b055144daa334820b9c575" translate="yes" xml:space="preserve">
          <source>The size of this integer type in bits.</source>
          <target state="translated">この整数型のサイズをビット単位で指定します。</target>
        </trans-unit>
        <trans-unit id="7c1fbeb1b5be430f1bc9e3a92e1dadba4b4fdb71" translate="yes" xml:space="preserve">
          <source>The size of this primitive is how many bytes it takes to reference any location in memory. For example, on a 32 bit target, this is 4 bytes and on a 64 bit target, this is 8 bytes.</source>
          <target state="translated">このプリミティブのサイズは、メモリ内の任意の場所を参照するのに必要なバイト数です。例えば、32 ビットのターゲットでは 4 バイト、64 ビットのターゲットでは 8 バイトです。</target>
        </trans-unit>
        <trans-unit id="eaea58fd5debec4469854dd4c0d7e96ee309fa5f" translate="yes" xml:space="preserve">
          <source>The slice is assumed to be partitioned according to the given predicate. This means that all elements for which the predicate returns true are at the start of the slice and all elements for which the predicate returns false are at the end. For example, [7, 15, 3, 5, 4, 12, 6] is a partitioned under the predicate x % 2 != 0 (all odd numbers are at the start, all even at the end).</source>
          <target state="translated">スライスは、与えられた述語に従って分割されると仮定されます。これは、述語が真を返すすべての要素がスライスの先頭にあり、述語が偽を返すすべての要素が末尾にあることを意味します。例えば、[7,15,3,5,4,12,6]は、x % 2 !=0という述語の下で分割されています(すべての奇数は先頭にあり、すべての偶数は末尾にあります)。</target>
        </trans-unit>
        <trans-unit id="8e51743ff7cd79535af677e289113dcff07dbe9c" translate="yes" xml:space="preserve">
          <source>The slice used to create a &lt;a href=&quot;struct.cstr&quot;&gt;&lt;code&gt;CStr&lt;/code&gt;&lt;/a&gt; must have one and only one nul byte at the end of the slice.</source>
          <target state="translated">&lt;a href=&quot;struct.cstr&quot;&gt; &lt;code&gt;CStr&lt;/code&gt; の&lt;/a&gt;作成に使用されるスライスには、スライスの最後に1つだけのNULバイトが必要です。</target>
        </trans-unit>
        <trans-unit id="06c3ab06faa47dfc08256f59e9e6b62a827af728" translate="yes" xml:space="preserve">
          <source>The slice used to create a &lt;a href=&quot;struct.cstr&quot;&gt;&lt;code&gt;CStr&lt;/code&gt;&lt;/a&gt; must have one and only one nul byte, positioned at the end.</source>
          <target state="translated">&lt;a href=&quot;struct.cstr&quot;&gt; &lt;code&gt;CStr&lt;/code&gt; の&lt;/a&gt;作成に使用されるスライスには、最後に配置された唯一のヌルバイトが必要です。</target>
        </trans-unit>
        <trans-unit id="ad56ccc65a97d6c0192795237bde8dc8a187bcc7" translate="yes" xml:space="preserve">
          <source>The slices implement &lt;code&gt;IntoIterator&lt;/code&gt;. The iterator yields references to the slice elements.</source>
          <target state="translated">スライスは &lt;code&gt;IntoIterator&lt;/code&gt; を実装します。イテレータはスライス要素への参照を生成します。</target>
        </trans-unit>
        <trans-unit id="4d54f29cfdc5fb0b14c6bc3d825908235a2d1e62" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type.</source>
          <target state="translated">この整数型で表現できる最小値。</target>
        </trans-unit>
        <trans-unit id="2ed21758c259b01204be09a1e5a970a7587f0275" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i128#associatedconstant.MIN&quot;&gt;&lt;code&gt;i128::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">この整数型で表すことができる最小値。代わりに&lt;a href=&quot;../primitive.i128#associatedconstant.MIN&quot;&gt; &lt;code&gt;i128::MIN&lt;/code&gt; &lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="b5a50b28fc392edeb96ae6e8bbc1f3f65f1879e9" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i16#associatedconstant.MIN&quot;&gt;&lt;code&gt;i16::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">この整数型で表すことができる最小値。代わりに&lt;a href=&quot;../primitive.i16#associatedconstant.MIN&quot;&gt; &lt;code&gt;i16::MIN&lt;/code&gt; &lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="fab5eaa27a5d1f357d4d2bc91b9af02383caede4" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i32#associatedconstant.MIN&quot;&gt;&lt;code&gt;i32::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">この整数型で表すことができる最小値。代わりに&lt;a href=&quot;../primitive.i32#associatedconstant.MIN&quot;&gt; &lt;code&gt;i32::MIN&lt;/code&gt; &lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="fc283863a8f984dedbdb2f90ee6338a2b682ff86" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i64#associatedconstant.MIN&quot;&gt;&lt;code&gt;i64::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">この整数型で表すことができる最小値。代わりに&lt;a href=&quot;../primitive.i64#associatedconstant.MIN&quot;&gt; &lt;code&gt;i64::MIN&lt;/code&gt; &lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="da8fcd8d47309d686d033e491c707f9a8e4582c1" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.i8#associatedconstant.MIN&quot;&gt;&lt;code&gt;i8::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">この整数型で表すことができる最小値。代わりに&lt;a href=&quot;../primitive.i8#associatedconstant.MIN&quot;&gt; &lt;code&gt;i8::MIN&lt;/code&gt; &lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="124d5af779df7e9ad406378d4ae95baeff0f8e12" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.isize#associatedconstant.MIN&quot;&gt;&lt;code&gt;isize::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">この整数型で表すことができる最小値。代わりに&lt;a href=&quot;../primitive.isize#associatedconstant.MIN&quot;&gt; &lt;code&gt;isize::MIN&lt;/code&gt; &lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="d7283dc0e8aef63acf9dd8ecc15410819b62a917" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u128#associatedconstant.MIN&quot;&gt;&lt;code&gt;u128::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">この整数型で表すことができる最小値。代わりに&lt;a href=&quot;../primitive.u128#associatedconstant.MIN&quot;&gt; &lt;code&gt;u128::MIN&lt;/code&gt; &lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="4e1d26d88d80abad9936f065a519a8e6dae555c2" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u16#associatedconstant.MIN&quot;&gt;&lt;code&gt;u16::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">この整数型で表すことができる最小値。代わりに&lt;a href=&quot;../primitive.u16#associatedconstant.MIN&quot;&gt; &lt;code&gt;u16::MIN&lt;/code&gt; &lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="3c5170dcabff61b3cd439cd574c1475742baecf6" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u32#associatedconstant.MIN&quot;&gt;&lt;code&gt;u32::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">この整数型で表すことができる最小値。代わりに&lt;a href=&quot;../primitive.u32#associatedconstant.MIN&quot;&gt; &lt;code&gt;u32::MIN&lt;/code&gt; &lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="0709e957f7976c853e280aae68478111e39066d5" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u64#associatedconstant.MIN&quot;&gt;&lt;code&gt;u64::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">この整数型で表すことができる最小値。代わりに&lt;a href=&quot;../primitive.u64#associatedconstant.MIN&quot;&gt; &lt;code&gt;u64::MIN&lt;/code&gt; &lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="fa14915f9b53a3b041d9be135f24e5f469a12ccc" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.u8#associatedconstant.MIN&quot;&gt;&lt;code&gt;u8::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">この整数型で表すことができる最小値。代わりに&lt;a href=&quot;../primitive.u8#associatedconstant.MIN&quot;&gt; &lt;code&gt;u8::MIN&lt;/code&gt; &lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="275bb49ca6506b300934116c83ccd1ff11d81477" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type. Use &lt;a href=&quot;../primitive.usize#associatedconstant.MIN&quot;&gt;&lt;code&gt;usize::MIN&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">この整数型で表すことができる最小値。代わりに&lt;a href=&quot;../primitive.usize#associatedconstant.MIN&quot;&gt; &lt;code&gt;usize::MIN&lt;/code&gt; &lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="c371b87930b46855075594aef0b191a2dcbb6afc" translate="yes" xml:space="preserve">
          <source>The smart pointer &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; is also not &lt;code&gt;Sync&lt;/code&gt; for the same reasons that it&amp;rsquo;s not &lt;code&gt;Send&lt;/code&gt;. The &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; type (which we talked about in Chapter 15) and the family of related &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; types are not &lt;code&gt;Sync&lt;/code&gt;. The implementation of borrow checking that &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; does at runtime is not thread-safe. The smart pointer &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;Sync&lt;/code&gt; and can be used to share access with multiple threads as you saw in the &lt;a href=&quot;ch16-03-shared-state#sharing-a-mutext-between-multiple-threads&quot;&gt;&amp;ldquo;Sharing a &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; Between Multiple Threads&amp;rdquo;&lt;/a&gt; section.</source>
          <target state="translated">スマートポインター &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; も、 &lt;code&gt;Send&lt;/code&gt; ではないのと同じ理由で &lt;code&gt;Sync&lt;/code&gt; ではありません。 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; （私たちは15章での話）タイプと関連の家族 &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; のタイプではありません &lt;code&gt;Sync&lt;/code&gt; 。 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; が実行時に行う借用チェックの実装は、スレッドセーフではありません。スマートポインター &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; は &lt;code&gt;Sync&lt;/code&gt; あり、&lt;a href=&quot;ch16-03-shared-state#sharing-a-mutext-between-multiple-threads&quot;&gt;「&lt;/a&gt;複数のスレッド間での &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 共有」セクションで見たように、複数のスレッドとアクセスを共有するために使用できます。</target>
        </trans-unit>
        <trans-unit id="348ea7c78b50388dc12ad8afa807cfbceb141e14" translate="yes" xml:space="preserve">
          <source>The socket will be closed when the value is dropped.</source>
          <target state="translated">値を落とすとソケットが閉じてしまいます。</target>
        </trans-unit>
        <trans-unit id="26c3406d4e79e978c77c7f71fb4706519f7ecd96" translate="yes" xml:space="preserve">
          <source>The solution here is to return the &lt;code&gt;String&lt;/code&gt; directly:</source>
          <target state="translated">ここでの解決策は、 &lt;code&gt;String&lt;/code&gt; 直接返すことです。</target>
        </trans-unit>
        <trans-unit id="b153caaa35f5e55b36f6162bb71df5061ac16716" translate="yes" xml:space="preserve">
          <source>The solution is to choose a different name that doesn't conflict with any external crate imported into the current module.</source>
          <target state="translated">解決策は、現在のモジュールにインポートされた外部のクレートと競合しない別の名前を選択することです。</target>
        </trans-unit>
        <trans-unit id="184f5f1102022e13bc531fc4c3a2f314884b9200" translate="yes" xml:space="preserve">
          <source>The solution is to coerce the array to a slice by calling a slice method:</source>
          <target state="translated">解決策は、sliceメソッドを呼び出して配列をスライスに強制することです。</target>
        </trans-unit>
        <trans-unit id="4b8f691075403fc3cc04a12f17630d0a22222627" translate="yes" xml:space="preserve">
          <source>The solution is to declare the imports at the top of the block, function, or file.</source>
          <target state="translated">解決策は、ブロック、関数、ファイルの先頭にインポートを宣言することです。</target>
        </trans-unit>
        <trans-unit id="6d341bfc87265fdb3200162c1071f84eb34afeb9" translate="yes" xml:space="preserve">
          <source>The solution to this problem is to ensure that the items that you are re-exporting are themselves marked with &lt;code&gt;pub&lt;/code&gt;:</source>
          <target state="translated">この問題の解決策は、再エクスポートするアイテム自体が &lt;code&gt;pub&lt;/code&gt; でマークされていることを確認することです。</target>
        </trans-unit>
        <trans-unit id="ca1c4540563346f3ae5ba53810b40773e7e12128" translate="yes" xml:space="preserve">
          <source>The solution to this problem is to ensure that the module that you are re-exporting is itself marked with &lt;code&gt;pub&lt;/code&gt;:</source>
          <target state="translated">この問題の解決策は、再エクスポートするモジュール自体が &lt;code&gt;pub&lt;/code&gt; でマークされていることを確認することです。</target>
        </trans-unit>
        <trans-unit id="ca9d7e79f3cd051af83e1b93c6feb0514cb1adc8" translate="yes" xml:space="preserve">
          <source>The solution to this problem is to remove the extraneous associated constant:</source>
          <target state="translated">この問題を解決するには、不要な関連定数を削除する必要があります。</target>
        </trans-unit>
        <trans-unit id="b66ecfc5844845f6ce826665530fcbac23beb458" translate="yes" xml:space="preserve">
          <source>The solution to this problem is to remove the extraneous associated type:</source>
          <target state="translated">この問題の解決策は、不要な関連型を削除することです。</target>
        </trans-unit>
        <trans-unit id="f5e669f80a825dd22d2d4e3f89464bdf72e0692e" translate="yes" xml:space="preserve">
          <source>The solution to this problem is usually to switch to using a &lt;code&gt;move&lt;/code&gt; closure. This approach moves (or copies, where possible) data into the closure, rather than taking references to it. For example:</source>
          <target state="translated">この問題の解決策は、通常、 &lt;code&gt;move&lt;/code&gt; クロージャーの使用に切り替えることです。このアプローチでは、データを参照するのではなく、クロージャーにデータを移動（または可能な場合はコピー）します。例えば：</target>
        </trans-unit>
        <trans-unit id="4bc18e7ccda6a6b48c7507cdd496e8030bd28ca8" translate="yes" xml:space="preserve">
          <source>The source files from which this book is generated can be found on &lt;a href=&quot;https://github.com/rust-lang/book/tree/master/src&quot;&gt;GitHub&lt;/a&gt;.</source>
          <target state="translated">この本の生成元であるソースファイルは、&lt;a href=&quot;https://github.com/rust-lang/book/tree/master/src&quot;&gt;GitHubにあります&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a49d6b47901cd19039274da891afacb7623398fb" translate="yes" xml:space="preserve">
          <source>The spawned thread may outlive the caller (unless the caller thread is the main thread; the whole process is terminated when the main thread finishes). The join handle can be used to block on termination of the child thread, including recovering its panics.</source>
          <target state="translated">スポーンされたスレッドは呼び出し元よりも長生きすることがあります(呼び出し元のスレッドがメインスレッドでない限り、メインスレッドが終了した時点でプロセス全体が終了します)。メインスレッドが終了するとプロセス全体が終了します。 joinハンドルは、パニックの回復を含め、子スレッドの終了をブロックするために使用できます。</target>
        </trans-unit>
        <trans-unit id="3de206631f62d211730a1cc35e89663e7062bcfa" translate="yes" xml:space="preserve">
          <source>The specified environment variable was found, but it did not contain valid unicode data. The found data is returned as a payload of this variant.</source>
          <target state="translated">指定された環境変数が見つかりましたが、有効な unicode データが含まれていませんでした。見つかったデータは、このバリアントのペイロードとして返されます。</target>
        </trans-unit>
        <trans-unit id="ea36c8e1fa9f0022c16977222444b4a3c0ab84f9" translate="yes" xml:space="preserve">
          <source>The specified environment variable was not present in the current process's environment.</source>
          <target state="translated">指定された環境変数が現在のプロセスの環境に存在しませんでした。</target>
        </trans-unit>
        <trans-unit id="9c4c268712a390c3c5b86d16dfd79086d462c7e5" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../any/fn.type_name&quot;&gt;&lt;code&gt;core::any::type_name&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込みの安定化バージョンは&lt;a href=&quot;../any/fn.type_name&quot;&gt; &lt;code&gt;core::any::type_name&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="45eb3e7f185d35fea76d0fcc8feefcf81bfa67b6" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../any/fn.type_name&quot;&gt;&lt;code&gt;crate::any::type_name&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込み関数の安定化バージョンは、&lt;a href=&quot;../any/fn.type_name&quot;&gt; &lt;code&gt;crate::any::type_name&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="89d879802905e96d1dbbee3b2bc193bcd1e8d256" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../any/struct.typeid#method.of&quot;&gt;&lt;code&gt;core::any::TypeId::of&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込み関数の安定化バージョンは、&lt;a href=&quot;../any/struct.typeid#method.of&quot;&gt; &lt;code&gt;core::any::TypeId::of&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="dd9900dab1e575f89f6a70cab38ccde57d12f174" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../any/struct.typeid#method.of&quot;&gt;&lt;code&gt;crate::any::TypeId::of&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込みの安定化バージョンは、&lt;a href=&quot;../any/struct.typeid#method.of&quot;&gt; &lt;code&gt;crate::any::TypeId::of&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="57f913c926721dcfb858ba0f49073ea9578b8b3f" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../hint/fn.unreachable_unchecked&quot;&gt;&lt;code&gt;core::hint::unreachable_unchecked&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込みの安定化バージョンは&lt;a href=&quot;../hint/fn.unreachable_unchecked&quot;&gt; &lt;code&gt;core::hint::unreachable_unchecked&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="176610383e559ab75c30b3e60918dcf39baa4491" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../hint/fn.unreachable_unchecked&quot;&gt;&lt;code&gt;crate::hint::unreachable_unchecked&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込みの安定化バージョンは&lt;a href=&quot;../hint/fn.unreachable_unchecked&quot;&gt; &lt;code&gt;crate::hint::unreachable_unchecked&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="769e7a49a82fbc73600ab216f157a9a4edfed6d2" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../hint/fn.unreachable_unchecked&quot;&gt;&lt;code&gt;std::hint::unreachable_unchecked&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込み関数の安定版は&lt;a href=&quot;../hint/fn.unreachable_unchecked&quot;&gt; &lt;code&gt;std::hint::unreachable_unchecked&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="68bf1becb5538df04aef3bc27ba3a8fc1c5f4d80" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../mem/fn.align_of&quot;&gt;&lt;code&gt;core::mem::align_of&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込みの安定化バージョンは&lt;a href=&quot;../mem/fn.align_of&quot;&gt; &lt;code&gt;core::mem::align_of&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="5f707ad710f27d4a519df162d93207b489b43663" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../mem/fn.align_of&quot;&gt;&lt;code&gt;crate::mem::align_of&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込みの安定化バージョンは&lt;a href=&quot;../mem/fn.align_of&quot;&gt; &lt;code&gt;crate::mem::align_of&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="bb235568e3ec680a5ddbb056614a4544c534c3b1" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../mem/fn.align_of_val&quot;&gt;&lt;code&gt;core::mem::align_of_val&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込みの安定化バージョンは&lt;a href=&quot;../mem/fn.align_of_val&quot;&gt; &lt;code&gt;core::mem::align_of_val&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="0bb92f5b8279175442866093e128f5cb80c5d7d4" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../mem/fn.align_of_val&quot;&gt;&lt;code&gt;crate::mem::align_of_val&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込みの安定化バージョンは&lt;a href=&quot;../mem/fn.align_of_val&quot;&gt; &lt;code&gt;crate::mem::align_of_val&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="5b63712fb966ee55e431373c44ee70e5bdcc0d5f" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../mem/fn.discriminant&quot;&gt;&lt;code&gt;core::mem::discriminant&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込みの安定化バージョンは&lt;a href=&quot;../mem/fn.discriminant&quot;&gt; &lt;code&gt;core::mem::discriminant&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="d0a9a6b3a12732480c74ccdbdd6c6cd441416852" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../mem/fn.discriminant&quot;&gt;&lt;code&gt;crate::mem::discriminant&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込み関数の安定化バージョンは、&lt;a href=&quot;../mem/fn.discriminant&quot;&gt; &lt;code&gt;crate::mem::discriminant&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="2f183bce94483cede38b2e29f8c8da04b39e389f" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../mem/fn.needs_drop&quot;&gt;&lt;code&gt;mem::needs_drop&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込みの安定化バージョンは&lt;a href=&quot;../mem/fn.needs_drop&quot;&gt; &lt;code&gt;mem::needs_drop&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="626a03e32989e459202fcca2e29d114287d2e779" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../mem/fn.needs_drop&quot;&gt;&lt;code&gt;std::mem::needs_drop&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込み関数の安定版は&lt;a href=&quot;../mem/fn.needs_drop&quot;&gt; &lt;code&gt;std::mem::needs_drop&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="cf0f4e1682c5598721794a53177e6ce27697d607" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../mem/fn.size_of&quot;&gt;&lt;code&gt;core::mem::size_of&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込みの安定化バージョンは&lt;a href=&quot;../mem/fn.size_of&quot;&gt; &lt;code&gt;core::mem::size_of&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="1b581000bfc2472e309baf4b78516cb35a337926" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../mem/fn.size_of&quot;&gt;&lt;code&gt;std::mem::size_of&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込み関数の安定化バージョンは&lt;a href=&quot;../mem/fn.size_of&quot;&gt; &lt;code&gt;std::mem::size_of&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="4df5be2153e7097fd8b00742eff3c445821681d5" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../mem/fn.size_of_val&quot;&gt;&lt;code&gt;mem::size_of_val&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込みの安定化バージョンは&lt;a href=&quot;../mem/fn.size_of_val&quot;&gt; &lt;code&gt;mem::size_of_val&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="5867b1e1c4944c1f7ed32488f5be2fa294b4986f" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../mem/fn.size_of_val&quot;&gt;&lt;code&gt;std::mem::size_of_val&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込み関数の安定化バージョンは&lt;a href=&quot;../mem/fn.size_of_val&quot;&gt; &lt;code&gt;std::mem::size_of_val&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="1746aa772dc9c98fd4e848556bc017af5d5a5814" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.abs&quot;&gt;&lt;code&gt;std::f32::abs&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">この組み込みの安定化バージョンは&lt;a href=&quot;../primitive.f32#method.abs&quot;&gt; &lt;code&gt;std::f32::abs&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bd019f674bd918f6d03e4b0946395283db961b78" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.ceil&quot;&gt;&lt;code&gt;std::f32::ceil&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">この組み込みの安定化バージョンは&lt;a href=&quot;../primitive.f32#method.ceil&quot;&gt; &lt;code&gt;std::f32::ceil&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="26bbd19c72d02740271e9c35e7a28be8dc08d048" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.copysign&quot;&gt;&lt;code&gt;std::f32::copysign&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">この組み込みの安定化バージョンは&lt;a href=&quot;../primitive.f32#method.copysign&quot;&gt; &lt;code&gt;std::f32::copysign&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="61c494ecc8ddd36d321a87c24568cbae459fddb9" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.cos&quot;&gt;&lt;code&gt;std::f32::cos&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">この組み込みの安定化バージョンは&lt;a href=&quot;../primitive.f32#method.cos&quot;&gt; &lt;code&gt;std::f32::cos&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="94b0a8ab3fca707be3b5a4c013197b6ace7d6752" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.exp&quot;&gt;&lt;code&gt;std::f32::exp&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">この組み込みの安定化バージョンは&lt;a href=&quot;../primitive.f32#method.exp&quot;&gt; &lt;code&gt;std::f32::exp&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="336a8852727ebc5c24637be3db7e37b682324956" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.exp2&quot;&gt;&lt;code&gt;std::f32::exp2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">この組み込みの安定化バージョンは&lt;a href=&quot;../primitive.f32#method.exp2&quot;&gt; &lt;code&gt;std::f32::exp2&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="46e4b0f6edf39422d28e3db71bd5ccc4aa08c8f3" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.floor&quot;&gt;&lt;code&gt;std::f32::floor&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">この組み込みの安定化バージョンは&lt;a href=&quot;../primitive.f32#method.floor&quot;&gt; &lt;code&gt;std::f32::floor&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6c54f6e18bc6b7c8320c4a68ccd5c641025d11b6" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.ln&quot;&gt;&lt;code&gt;std::f32::ln&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">この組み込み関数の安定化バージョンは&lt;a href=&quot;../primitive.f32#method.ln&quot;&gt; &lt;code&gt;std::f32::ln&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d8fbd8555b23fb5da5a31c3691aceae539093012" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.log10&quot;&gt;&lt;code&gt;std::f32::log10&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">この組み込みの安定化バージョンは&lt;a href=&quot;../primitive.f32#method.log10&quot;&gt; &lt;code&gt;std::f32::log10&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="163981a463a3f186e653d8b1d906aacc60bb507a" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.log2&quot;&gt;&lt;code&gt;std::f32::log2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">この組み込みの安定化バージョンは&lt;a href=&quot;../primitive.f32#method.log2&quot;&gt; &lt;code&gt;std::f32::log2&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="aad71542a1a997b3c3c61f5ecfa210cbb95931d8" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.max&quot;&gt;&lt;code&gt;f32::max&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">この組み込みの安定化バージョンは&lt;a href=&quot;../primitive.f32#method.max&quot;&gt; &lt;code&gt;f32::max&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="275c6f9b837c44f59265b27a725f706ea01e4d88" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.min&quot;&gt;&lt;code&gt;f32::min&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">この組み込みの安定化バージョンは&lt;a href=&quot;../primitive.f32#method.min&quot;&gt; &lt;code&gt;f32::min&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="37a1adc351bf8541ff50457503f42947d2223aa1" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.mul_add&quot;&gt;&lt;code&gt;std::f32::mul_add&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">この組み込みの安定化バージョンは&lt;a href=&quot;../primitive.f32#method.mul_add&quot;&gt; &lt;code&gt;std::f32::mul_add&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="824767dc22e0a666300f3bbc86838e9e982d5929" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.powf&quot;&gt;&lt;code&gt;std::f32::powf&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">この組み込みの安定化バージョンは&lt;a href=&quot;../primitive.f32#method.powf&quot;&gt; &lt;code&gt;std::f32::powf&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7a9c8c235c9463f3bd3c7f8d97084f0aa09a4e6b" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.powi&quot;&gt;&lt;code&gt;std::f32::powi&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">この組み込みの安定化バージョンは&lt;a href=&quot;../primitive.f32#method.powi&quot;&gt; &lt;code&gt;std::f32::powi&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2f7c21362121499d029cb16e6e1a0c1b3f1e8a1a" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.round&quot;&gt;&lt;code&gt;std::f32::round&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">この組み込みの安定化バージョンは&lt;a href=&quot;../primitive.f32#method.round&quot;&gt; &lt;code&gt;std::f32::round&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b4af107006e6e31e8e831e5d5f7bf515b2e1cc7d" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.sin&quot;&gt;&lt;code&gt;std::f32::sin&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">この組み込みの安定化バージョンは&lt;a href=&quot;../primitive.f32#method.sin&quot;&gt; &lt;code&gt;std::f32::sin&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="34b79ebb4c8dc7ee3e2e853d2ae83194460b52cd" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.sqrt&quot;&gt;&lt;code&gt;std::f32::sqrt&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">この組み込みの安定化バージョンは&lt;a href=&quot;../primitive.f32#method.sqrt&quot;&gt; &lt;code&gt;std::f32::sqrt&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5c2f3efeb8ac74af1f762963525599c78dfb84b4" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f32#method.trunc&quot;&gt;&lt;code&gt;std::f32::trunc&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">この組み込みの安定化バージョンは&lt;a href=&quot;../primitive.f32#method.trunc&quot;&gt; &lt;code&gt;std::f32::trunc&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f50e2d709a0ab57a5af9a3d0b85809c7253cdbbe" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.abs&quot;&gt;&lt;code&gt;std::f64::abs&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">この組み込みの安定化バージョンは&lt;a href=&quot;../primitive.f64#method.abs&quot;&gt; &lt;code&gt;std::f64::abs&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b8077c0447a55f70ad3a41280e7cdad8b5a596e3" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.ceil&quot;&gt;&lt;code&gt;std::f64::ceil&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">この組み込みの安定化バージョンは&lt;a href=&quot;../primitive.f64#method.ceil&quot;&gt; &lt;code&gt;std::f64::ceil&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0c784852d478dc5b87ed608a83b4485e61ffaa08" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.copysign&quot;&gt;&lt;code&gt;std::f64::copysign&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">この組み込みの安定化バージョンは&lt;a href=&quot;../primitive.f64#method.copysign&quot;&gt; &lt;code&gt;std::f64::copysign&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f3706879950fc2f859ec3405d83c39468b3d127b" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.cos&quot;&gt;&lt;code&gt;std::f64::cos&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">この組み込みの安定化バージョンは&lt;a href=&quot;../primitive.f64#method.cos&quot;&gt; &lt;code&gt;std::f64::cos&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3fe60787bdb5a14582899986ea8a8eb5151f047a" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.exp&quot;&gt;&lt;code&gt;std::f64::exp&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">この組み込みの安定化バージョンは&lt;a href=&quot;../primitive.f64#method.exp&quot;&gt; &lt;code&gt;std::f64::exp&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1d57c3217aae4fa0b39647c7df0a1a27ba3ce04c" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.exp2&quot;&gt;&lt;code&gt;std::f64::exp2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">この組み込みの安定化バージョンは&lt;a href=&quot;../primitive.f64#method.exp2&quot;&gt; &lt;code&gt;std::f64::exp2&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="06ec2f6c9475943bd6d7a554d14049a4e570f218" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.floor&quot;&gt;&lt;code&gt;std::f64::floor&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">この組み込みの安定化バージョンは&lt;a href=&quot;../primitive.f64#method.floor&quot;&gt; &lt;code&gt;std::f64::floor&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="95c322d0525dc747c93c991f848c51c52ac90096" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.ln&quot;&gt;&lt;code&gt;std::f64::ln&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">この組み込み関数の安定化バージョンは&lt;a href=&quot;../primitive.f64#method.ln&quot;&gt; &lt;code&gt;std::f64::ln&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="85342dac467b551f64948da385b26bae5ec304e2" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.log10&quot;&gt;&lt;code&gt;std::f64::log10&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">この組み込みの安定化バージョンは&lt;a href=&quot;../primitive.f64#method.log10&quot;&gt; &lt;code&gt;std::f64::log10&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e1fcf5615e4f3f284291f587c194c0ee80f02e1b" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.log2&quot;&gt;&lt;code&gt;std::f64::log2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">この組み込みの安定化バージョンは&lt;a href=&quot;../primitive.f64#method.log2&quot;&gt; &lt;code&gt;std::f64::log2&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a33d40ec03fc6fd7670da5d91bb3dff1514508d8" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.max&quot;&gt;&lt;code&gt;f64::max&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">この組み込みの安定化バージョンは&lt;a href=&quot;../primitive.f64#method.max&quot;&gt; &lt;code&gt;f64::max&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5c5caceb4a4959b387b99fbf4eb4112cfa719de9" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.min&quot;&gt;&lt;code&gt;f64::min&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">この組み込みの安定化バージョンは&lt;a href=&quot;../primitive.f64#method.min&quot;&gt; &lt;code&gt;f64::min&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="184af9c54cafa84b2f1da9d8430a1cc45e2501b8" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.mul_add&quot;&gt;&lt;code&gt;std::f64::mul_add&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">この組み込みの安定化バージョンは&lt;a href=&quot;../primitive.f64#method.mul_add&quot;&gt; &lt;code&gt;std::f64::mul_add&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f8a62ab1447e5a688dfc2804caf90414ec922c3e" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.powf&quot;&gt;&lt;code&gt;std::f64::powf&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">この組み込みの安定化バージョンは&lt;a href=&quot;../primitive.f64#method.powf&quot;&gt; &lt;code&gt;std::f64::powf&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="53fa85dcefba2eba944e099df5e0b7568320b594" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.powi&quot;&gt;&lt;code&gt;std::f64::powi&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">この組み込みの安定化バージョンは&lt;a href=&quot;../primitive.f64#method.powi&quot;&gt; &lt;code&gt;std::f64::powi&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ab11dcc6899cdf3c196ec2500a4f98d80cd92c0f" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.round&quot;&gt;&lt;code&gt;std::f64::round&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">この組み込みの安定化バージョンは&lt;a href=&quot;../primitive.f64#method.round&quot;&gt; &lt;code&gt;std::f64::round&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cbc17db1c9e9aeccadbae543736abc641bf19581" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.sin&quot;&gt;&lt;code&gt;std::f64::sin&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">この組み込みの安定化バージョンは&lt;a href=&quot;../primitive.f64#method.sin&quot;&gt; &lt;code&gt;std::f64::sin&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c9259a474b9633d2c178bcfa8945b9cf932f9b62" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.sqrt&quot;&gt;&lt;code&gt;std::f64::sqrt&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">この組み込みの安定化バージョンは&lt;a href=&quot;../primitive.f64#method.sqrt&quot;&gt; &lt;code&gt;std::f64::sqrt&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="09d46fbb4d6dd94cb20b274b64fb45bedd897ee1" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.f64#method.trunc&quot;&gt;&lt;code&gt;std::f64::trunc&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">この組み込みの安定化バージョンは&lt;a href=&quot;../primitive.f64#method.trunc&quot;&gt; &lt;code&gt;std::f64::trunc&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e24ba042f8ed9a32e5152ef40108b6331e9ff075" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.pointer#method.offset&quot;&gt;&lt;code&gt;std::pointer::offset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込み関数の安定化バージョンは、&lt;a href=&quot;../primitive.pointer#method.offset&quot;&gt; &lt;code&gt;std::pointer::offset&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="a8ef8497ee38f892bb72694c3c391e01cf452f3c" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../primitive.pointer#method.wrapping_offset&quot;&gt;&lt;code&gt;std::pointer::wrapping_offset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込み関数の安定化バージョンは、&lt;a href=&quot;../primitive.pointer#method.wrapping_offset&quot;&gt; &lt;code&gt;std::pointer::wrapping_offset&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="93a878abfa4b4b05965b5ed62c9134a4b23816af" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../process/fn.abort&quot;&gt;&lt;code&gt;std::process::abort&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">この組み込み関数の安定化バージョンは&lt;a href=&quot;../process/fn.abort&quot;&gt; &lt;code&gt;std::process::abort&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f777a2d25d61f2a8a030aed5ab4e20e176d153a8" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../ptr/fn.read_volatile&quot;&gt;&lt;code&gt;core::ptr::read_volatile&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込みの安定化バージョンは&lt;a href=&quot;../ptr/fn.read_volatile&quot;&gt; &lt;code&gt;core::ptr::read_volatile&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="dc0344746e9b397b268af814908260e075e04e91" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../ptr/fn.read_volatile&quot;&gt;&lt;code&gt;crate::ptr::read_volatile&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込みの安定化バージョンは&lt;a href=&quot;../ptr/fn.read_volatile&quot;&gt; &lt;code&gt;crate::ptr::read_volatile&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="05ad03e9160cb2408f7bd5aa45c03727935da29f" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../ptr/fn.write&quot;&gt;&lt;code&gt;core::ptr::write&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込みの安定化バージョンは&lt;a href=&quot;../ptr/fn.write&quot;&gt; &lt;code&gt;core::ptr::write&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="118ab008d64be2589235ff02dc721d1434d90f79" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../ptr/fn.write&quot;&gt;&lt;code&gt;crate::ptr::write&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込みの安定化バージョンは&lt;a href=&quot;../ptr/fn.write&quot;&gt; &lt;code&gt;crate::ptr::write&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="aac108773792d7b27741d0ad608d7eda680fdf09" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../ptr/fn.write_volatile&quot;&gt;&lt;code&gt;core::ptr::write_volatile&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込みの安定化バージョンは&lt;a href=&quot;../ptr/fn.write_volatile&quot;&gt; &lt;code&gt;core::ptr::write_volatile&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="70902b9a0728e1e3dbaf882574f3b031e91654e0" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../ptr/fn.write_volatile&quot;&gt;&lt;code&gt;crate::ptr::write_volatile&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込みの安定化バージョンは&lt;a href=&quot;../ptr/fn.write_volatile&quot;&gt; &lt;code&gt;crate::ptr::write_volatile&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="625b254ad12639bd7cf3b4b8d18b0e6a86ce6669" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;fn.needs_drop&quot;&gt;&lt;code&gt;needs_drop&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込みの安定化バージョンは&lt;a href=&quot;fn.needs_drop&quot;&gt; &lt;code&gt;needs_drop&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="4decf20d903cd057fdbbe638ed8d8e3f26c756a4" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;fn.size_of&quot;&gt;&lt;code&gt;size_of&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込み関数の安定化バージョンは&lt;a href=&quot;fn.size_of&quot;&gt; &lt;code&gt;size_of&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="e4c9dc52f1e3d1631dde7d53032bcc39a6df9f72" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;fn.size_of_val&quot;&gt;&lt;code&gt;size_of_val&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込み関数の安定化バージョンは&lt;a href=&quot;fn.size_of_val&quot;&gt; &lt;code&gt;size_of_val&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="58429d40c9c7f24b0a6d088073711682d0c11242" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available in &lt;a href=&quot;../sync/atomic/fn.compiler_fence&quot;&gt;&lt;code&gt;atomic::compiler_fence&lt;/code&gt;&lt;/a&gt; by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">この固有の安定したバージョンが利用可能である&lt;a href=&quot;../sync/atomic/fn.compiler_fence&quot;&gt; &lt;code&gt;atomic::compiler_fence&lt;/code&gt; &lt;/a&gt;渡すことによって、&lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt;として &lt;code&gt;order&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5311916c06b10b8c928d0abda98be268ace4e6d6" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available in &lt;a href=&quot;../sync/atomic/fn.compiler_fence&quot;&gt;&lt;code&gt;atomic::compiler_fence&lt;/code&gt;&lt;/a&gt; by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">この組み込み関数の安定化バージョンは、&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt;を &lt;code&gt;order&lt;/code&gt; として渡すことで&lt;a href=&quot;../sync/atomic/fn.compiler_fence&quot;&gt; &lt;code&gt;atomic::compiler_fence&lt;/code&gt; &lt;/a&gt;使用できます。</target>
        </trans-unit>
        <trans-unit id="3081645830dba10410e4d31cc6a792e5fa76abfc" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available in &lt;a href=&quot;../sync/atomic/fn.compiler_fence&quot;&gt;&lt;code&gt;atomic::compiler_fence&lt;/code&gt;&lt;/a&gt; by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">この組み込み関数の安定化バージョンは、&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt;を &lt;code&gt;order&lt;/code&gt; として渡すことにより、&lt;a href=&quot;../sync/atomic/fn.compiler_fence&quot;&gt; &lt;code&gt;atomic::compiler_fence&lt;/code&gt; &lt;/a&gt;使用できます。</target>
        </trans-unit>
        <trans-unit id="5e8d39a214853d9287e37063d7cab0006a733cdd" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available in &lt;a href=&quot;../sync/atomic/fn.compiler_fence&quot;&gt;&lt;code&gt;atomic::compiler_fence&lt;/code&gt;&lt;/a&gt; by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">この固有の安定したバージョンが利用可能である&lt;a href=&quot;../sync/atomic/fn.compiler_fence&quot;&gt; &lt;code&gt;atomic::compiler_fence&lt;/code&gt; &lt;/a&gt;渡すことによって、&lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt;として &lt;code&gt;order&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2cb2b502c2611a7e2eb731a194ab104f5f862370" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available in &lt;a href=&quot;../sync/atomic/fn.fence&quot;&gt;&lt;code&gt;atomic::fence&lt;/code&gt;&lt;/a&gt; by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">この固有の安定したバージョンが利用可能である&lt;a href=&quot;../sync/atomic/fn.fence&quot;&gt; &lt;code&gt;atomic::fence&lt;/code&gt; &lt;/a&gt;渡すことによって、&lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt;として &lt;code&gt;order&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="365e7e84eb752771b266d7d9e0c92f84d3398fe0" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available in &lt;a href=&quot;../sync/atomic/fn.fence&quot;&gt;&lt;code&gt;atomic::fence&lt;/code&gt;&lt;/a&gt; by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">この組み込み関数の安定化バージョンは、&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt;を &lt;code&gt;order&lt;/code&gt; として渡すことで&lt;a href=&quot;../sync/atomic/fn.fence&quot;&gt; &lt;code&gt;atomic::fence&lt;/code&gt; &lt;/a&gt;使用できます。</target>
        </trans-unit>
        <trans-unit id="7f323b62e22f70b85a5b00e81ad1dd75f18bb93e" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available in &lt;a href=&quot;../sync/atomic/fn.fence&quot;&gt;&lt;code&gt;atomic::fence&lt;/code&gt;&lt;/a&gt; by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">この組み込み関数の安定化バージョンは、&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt;を &lt;code&gt;order&lt;/code&gt; として渡すことで&lt;a href=&quot;../sync/atomic/fn.fence&quot;&gt; &lt;code&gt;atomic::fence&lt;/code&gt; &lt;/a&gt;使用できます。</target>
        </trans-unit>
        <trans-unit id="c1bdf72440b67a4b60d0cb051b353e1a1e5f17d8" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available in &lt;a href=&quot;../sync/atomic/fn.fence&quot;&gt;&lt;code&gt;atomic::fence&lt;/code&gt;&lt;/a&gt; by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">この固有の安定したバージョンが利用可能である&lt;a href=&quot;../sync/atomic/fn.fence&quot;&gt; &lt;code&gt;atomic::fence&lt;/code&gt; &lt;/a&gt;渡すことによって、&lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt;として &lt;code&gt;order&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dfb231858cd4689ec5627a23d29186ff8d439dec" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; signed integer types via the &lt;code&gt;fetch_max&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_max&quot;&gt;&lt;code&gt;AtomicI32::fetch_max&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この固有の安定化されたバージョンが利用可能である&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;を介して、符号付き整数型 &lt;code&gt;fetch_max&lt;/code&gt; 通すことによって方法&lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt;ように &lt;code&gt;order&lt;/code&gt; 。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_max&quot;&gt; &lt;code&gt;AtomicI32::fetch_max&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="ba45a4ad89ca37d142fe08556abef04250897691" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; signed integer types via the &lt;code&gt;fetch_max&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_max&quot;&gt;&lt;code&gt;AtomicI32::fetch_max&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込み型の安定化バージョンは、&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt;を &lt;code&gt;order&lt;/code&gt; として渡すことにより、 &lt;code&gt;fetch_max&lt;/code&gt; メソッドを介して&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;符号付き整数型で使用できます。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_max&quot;&gt; &lt;code&gt;AtomicI32::fetch_max&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="f793986afe8163ac71ccb416509b9ce1b93b28a7" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; signed integer types via the &lt;code&gt;fetch_max&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_max&quot;&gt;&lt;code&gt;AtomicI32::fetch_max&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込み型の安定化バージョンは、&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt;を &lt;code&gt;order&lt;/code&gt; として渡すことにより、 &lt;code&gt;fetch_max&lt;/code&gt; メソッドを介して&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;符号付き整数型で使用できます。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_max&quot;&gt; &lt;code&gt;AtomicI32::fetch_max&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="11f793b659028e7642830af52530c7830ca89493" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; signed integer types via the &lt;code&gt;fetch_max&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_max&quot;&gt;&lt;code&gt;AtomicI32::fetch_max&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込み型の安定化バージョンは、&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt;を &lt;code&gt;order&lt;/code&gt; として渡すことにより、 &lt;code&gt;fetch_max&lt;/code&gt; メソッドを介して&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;符号付き整数型で使用できます。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_max&quot;&gt; &lt;code&gt;AtomicI32::fetch_max&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="49aafe40a8bc9c4c0d4799be407063a6be2f80b8" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; signed integer types via the &lt;code&gt;fetch_max&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_max&quot;&gt;&lt;code&gt;AtomicI32::fetch_max&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この固有の安定化されたバージョンが利用可能である&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;を介して、符号付き整数型 &lt;code&gt;fetch_max&lt;/code&gt; 渡すことによって方法&lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt;ように &lt;code&gt;order&lt;/code&gt; 。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_max&quot;&gt; &lt;code&gt;AtomicI32::fetch_max&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="d1036b996bdd682cf46fc64099bdeb270500f551" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; signed integer types via the &lt;code&gt;fetch_min&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_min&quot;&gt;&lt;code&gt;AtomicI32::fetch_min&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この固有の安定化されたバージョンが利用可能である&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;を介して、符号付き整数型 &lt;code&gt;fetch_min&lt;/code&gt; 通すことによって方法&lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt;ように &lt;code&gt;order&lt;/code&gt; 。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_min&quot;&gt; &lt;code&gt;AtomicI32::fetch_min&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="cb8002438bcf3c0d48b47c6879f85d416ab04436" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; signed integer types via the &lt;code&gt;fetch_min&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_min&quot;&gt;&lt;code&gt;AtomicI32::fetch_min&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込み型の安定化バージョンは、&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt;を &lt;code&gt;order&lt;/code&gt; として渡すことにより、 &lt;code&gt;fetch_min&lt;/code&gt; メソッドを介して&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;符号付き整数型で使用できます。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_min&quot;&gt; &lt;code&gt;AtomicI32::fetch_min&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="0a7b18952940b9b8182e6a6746cc4d6878e30de3" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; signed integer types via the &lt;code&gt;fetch_min&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_min&quot;&gt;&lt;code&gt;AtomicI32::fetch_min&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込み型の安定化バージョンは、&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt;を &lt;code&gt;order&lt;/code&gt; として渡すことにより、 &lt;code&gt;fetch_min&lt;/code&gt; メソッドを介して&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;符号付き整数型で使用できます。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_min&quot;&gt; &lt;code&gt;AtomicI32::fetch_min&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="b2bf12a3e1dda34bbe1170fb23b2c7e3980fa2e2" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; signed integer types via the &lt;code&gt;fetch_min&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_min&quot;&gt;&lt;code&gt;AtomicI32::fetch_min&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込み型の安定化バージョンは、&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt;を &lt;code&gt;order&lt;/code&gt; として渡すことにより、 &lt;code&gt;fetch_min&lt;/code&gt; メソッドを介して&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;符号付き整数型で使用できます。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_min&quot;&gt; &lt;code&gt;AtomicI32::fetch_min&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="e9e3416a187e1174aeae58104e7efc1c7ee03ff6" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; signed integer types via the &lt;code&gt;fetch_min&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_min&quot;&gt;&lt;code&gt;AtomicI32::fetch_min&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この固有の安定化されたバージョンが利用可能である&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;を介して、符号付き整数型 &lt;code&gt;fetch_min&lt;/code&gt; 渡すことによって方法&lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt;ように &lt;code&gt;order&lt;/code&gt; 。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomici32#method.fetch_min&quot;&gt; &lt;code&gt;AtomicI32::fetch_min&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="17459feca9539df018355d8750621e9dbfee25c8" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;success&lt;/code&gt; and &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この固有の安定したバージョンで利用可能である&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;を介し種類 &lt;code&gt;compare_exchange&lt;/code&gt; の渡すことで、法&lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt;として &lt;code&gt;success&lt;/code&gt; し、&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt;など &lt;code&gt;failure&lt;/code&gt; パラメータ。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="84bb6ebc113b49007d6fcfdfafa151470c4d97fb" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;success&lt;/code&gt; and &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この固有の安定したバージョンが利用可能である&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;を介した種類 &lt;code&gt;compare_exchange&lt;/code&gt; の渡すことにより、法&lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt;として &lt;code&gt;success&lt;/code&gt; し、&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt;として &lt;code&gt;failure&lt;/code&gt; パラメータ。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b287de0c6ccb4c255ae592a699ddf51d510069e0" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as both the &lt;code&gt;success&lt;/code&gt; and &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込み関数の安定化バージョンは、 &lt;code&gt;success&lt;/code&gt; パラメーターと &lt;code&gt;failure&lt;/code&gt; パラメーターの両方として&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt;を渡すことにより、 &lt;code&gt;compare_exchange&lt;/code&gt; メソッドを介して&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;タイプで使用できます。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dc152c646978658d528a198a309e91d74e54a326" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;success&lt;/code&gt; and &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この固有の安定したバージョンが利用可能である&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;を介した種類 &lt;code&gt;compare_exchange&lt;/code&gt; の渡すことにより、法&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt;て &lt;code&gt;success&lt;/code&gt; し、&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt;として &lt;code&gt;failure&lt;/code&gt; パラメータ。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2c1db276c3b3b4fd7ceb4e380bed1da5745f7ffc" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as both the &lt;code&gt;success&lt;/code&gt; and &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込み関数の安定化バージョンは、 &lt;code&gt;success&lt;/code&gt; パラメーターと &lt;code&gt;failure&lt;/code&gt; パラメーターの両方として&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt;を渡すことにより、 &lt;code&gt;compare_exchange&lt;/code&gt; メソッドを介して&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;タイプで使用できます。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="951c50a3c5ccad37a2e3fca1e84b631f4373b483" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;success&lt;/code&gt; and &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この固有の安定したバージョンが利用可能である&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;を介した種類 &lt;code&gt;compare_exchange&lt;/code&gt; の渡すことにより、法&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt;として &lt;code&gt;success&lt;/code&gt; し、&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt;として &lt;code&gt;failure&lt;/code&gt; パラメータ。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="128d2037df6a05cf07d2834b7655c68820b3bd26" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as both the &lt;code&gt;success&lt;/code&gt; and &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込み関数の安定化バージョンは、 &lt;code&gt;success&lt;/code&gt; パラメーターと &lt;code&gt;failure&lt;/code&gt; パラメーターの両方として&lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt;を渡すことにより、 &lt;code&gt;compare_exchange&lt;/code&gt; メソッドを介して&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;タイプで使用できます。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0ab03d58d5f671c0a0db830b6b05ae77f18309c3" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;success&lt;/code&gt; and &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この固有の安定したバージョンで利用可能である&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;を介し種類 &lt;code&gt;compare_exchange&lt;/code&gt; の渡すことで、法&lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt;として &lt;code&gt;success&lt;/code&gt; し、&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt;など &lt;code&gt;failure&lt;/code&gt; パラメータ。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="88060a6c5fb7a5ab11e95c384921daa2c4d4f5bf" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;success&lt;/code&gt; and &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この固有の安定したバージョンがで提供されて&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;を介し種類 &lt;code&gt;compare_exchange&lt;/code&gt; の渡すことで、法&lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt;として &lt;code&gt;success&lt;/code&gt; し、&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt;として &lt;code&gt;failure&lt;/code&gt; パラメータ。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bd12eff27bb275374d877eb262054ae1c853f908" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange_weak&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;success&lt;/code&gt; and &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この固有の安定したバージョンで利用可能である&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;を介し種類 &lt;code&gt;compare_exchange_weak&lt;/code&gt; の渡すことで、法&lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt;として &lt;code&gt;success&lt;/code&gt; し、&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt;など &lt;code&gt;failure&lt;/code&gt; パラメータ。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="af1fc10d6447bc6c5afd961766bf358a30dcbdba" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange_weak&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;success&lt;/code&gt; and &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この固有の安定したバージョンがで提供されて&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;を介し種類 &lt;code&gt;compare_exchange_weak&lt;/code&gt; の渡すことで、法&lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt;として &lt;code&gt;success&lt;/code&gt; し、&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt;として &lt;code&gt;failure&lt;/code&gt; パラメータ。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="00f0f125817ae56a57898beaed413be79b5a5f7f" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange_weak&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as both the &lt;code&gt;success&lt;/code&gt; and &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込み関数の安定化バージョンは、 &lt;code&gt;success&lt;/code&gt; パラメーターと &lt;code&gt;failure&lt;/code&gt; パラメーターの両方として&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt;を渡すことにより、 &lt;code&gt;compare_exchange_weak&lt;/code&gt; メソッドを介して&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;タイプで使用できます。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5a4f22637924c144abe1815857665dade4d3c51b" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange_weak&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;success&lt;/code&gt; and &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この固有の安定したバージョンが利用可能である&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;を介し種類 &lt;code&gt;compare_exchange_weak&lt;/code&gt; 渡すことによって、法&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt;て &lt;code&gt;success&lt;/code&gt; し、&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt;として &lt;code&gt;failure&lt;/code&gt; パラメータ。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="862ae83bdd80acbffd544e29d0952bfef39ef310" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange_weak&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as both the &lt;code&gt;success&lt;/code&gt; and &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込み関数の安定化バージョンは、 &lt;code&gt;success&lt;/code&gt; パラメーターと &lt;code&gt;failure&lt;/code&gt; パラメーターの両方として&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt;を渡すことにより、 &lt;code&gt;compare_exchange_weak&lt;/code&gt; メソッドを介して&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;タイプで使用できます。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="301da9988d8a43a17c9bdfe746d0d24a87f91ac5" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange_weak&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;success&lt;/code&gt; and &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この固有の安定したバージョンが利用可能である&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;を介した種類 &lt;code&gt;compare_exchange_weak&lt;/code&gt; の渡すことにより、法&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt;として &lt;code&gt;success&lt;/code&gt; し、&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt;として &lt;code&gt;failure&lt;/code&gt; パラメータ。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e408b07db98e8ee6804e680f2894d658fb2f63fb" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange_weak&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as both the &lt;code&gt;success&lt;/code&gt; and &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込み関数の安定化バージョンは、 &lt;code&gt;success&lt;/code&gt; パラメーターと &lt;code&gt;failure&lt;/code&gt; パラメーターの両方として&lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt;を渡すことにより、 &lt;code&gt;compare_exchange_weak&lt;/code&gt; メソッドを介して&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;タイプで使用できます。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4d2ce54b599780814ddae4cc41ff6842ce0dffc8" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange_weak&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;success&lt;/code&gt; and &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この固有の安定したバージョンで利用可能である&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;を介し種類 &lt;code&gt;compare_exchange_weak&lt;/code&gt; の渡すことで、法&lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt;として &lt;code&gt;success&lt;/code&gt; し、&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt;など &lt;code&gt;failure&lt;/code&gt; パラメータ。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c3c44a7a6b16b40cf235a33892e670e0a8bc5178" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;compare_exchange_weak&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;success&lt;/code&gt; and &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;failure&lt;/code&gt; parameters. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt;&lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この固有の安定したバージョンがで提供されて&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;を介し種類 &lt;code&gt;compare_exchange_weak&lt;/code&gt; の渡すことで、法&lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt;として &lt;code&gt;success&lt;/code&gt; し、&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt;として &lt;code&gt;failure&lt;/code&gt; パラメータ。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.compare_exchange_weak&quot;&gt; &lt;code&gt;AtomicBool::compare_exchange_weak&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="eae6f5127b74d22ebf6510c20a59c81a3de0cdfc" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この固有の安定したバージョンが利用可能である&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;を介した種類 &lt;code&gt;fetch_add&lt;/code&gt; 渡すことによって、法&lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt;として &lt;code&gt;order&lt;/code&gt; 。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt; &lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="695ca0d01b208d0e14efcb78593ea9daca909ab8" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込み関数の安定化バージョンは、&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt;を &lt;code&gt;order&lt;/code&gt; として渡すことにより、 &lt;code&gt;fetch_add&lt;/code&gt; メソッドを介して&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;型で使用できます。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt; &lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="e4a2657e5f8e4cdd6d19f74f32446cf634f2c708" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込み関数の安定化バージョンは、&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt;を &lt;code&gt;order&lt;/code&gt; として渡すことにより、 &lt;code&gt;fetch_add&lt;/code&gt; メソッドを介して&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;型で使用できます。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt; &lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="b27a067a3ca05d7ed184ca857f007a3ba758dcd5" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込み関数の安定化バージョンは、&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt;を &lt;code&gt;order&lt;/code&gt; として渡すことにより、 &lt;code&gt;fetch_add&lt;/code&gt; メソッドを介して&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;型で使用できます。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt; &lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="6f042c7aafd7bdff469934311d53691a7a1a1045" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この固有の安定したバージョンが利用可能である&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;を介し種類 &lt;code&gt;fetch_add&lt;/code&gt; 渡すことによって、法&lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt;として &lt;code&gt;order&lt;/code&gt; 。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt; &lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="91da36591ebb40c0553e91c9f934d905043cb8a9" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_and&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt;&lt;code&gt;AtomicBool::fetch_and&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この固有の安定したバージョンが利用可能である&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;を介した種類 &lt;code&gt;fetch_and&lt;/code&gt; 渡すことによって、法&lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt;として &lt;code&gt;order&lt;/code&gt; 。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt; &lt;code&gt;AtomicBool::fetch_and&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8e00a651851675118139e87206d58986105c4eb0" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_and&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt;&lt;code&gt;AtomicBool::fetch_and&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込み関数の安定化バージョンは、&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt;を &lt;code&gt;order&lt;/code&gt; として渡すことにより、 &lt;code&gt;fetch_and&lt;/code&gt; メソッドを介して&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;タイプで使用できます。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt; &lt;code&gt;AtomicBool::fetch_and&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="18a857da52573d4e17b52a7e7c33c2b45cbcba5f" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_and&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt;&lt;code&gt;AtomicBool::fetch_and&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込み関数の安定化バージョンは、&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt;を &lt;code&gt;order&lt;/code&gt; として渡すことにより、 &lt;code&gt;fetch_and&lt;/code&gt; メソッドを介して&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;タイプで使用できます。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt; &lt;code&gt;AtomicBool::fetch_and&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="af7b5f35485a9f9923b0a484a1951a30bb3a1887" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_and&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt;&lt;code&gt;AtomicBool::fetch_and&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込み関数の安定化バージョンは、&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt;を &lt;code&gt;order&lt;/code&gt; として渡すことにより、 &lt;code&gt;fetch_and&lt;/code&gt; メソッドを介して&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;タイプで使用できます。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt; &lt;code&gt;AtomicBool::fetch_and&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="993970aa50aa2516408dfe30230dc45762d3f244" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_and&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt;&lt;code&gt;AtomicBool::fetch_and&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この固有の安定したバージョンが利用可能である&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;を介し種類 &lt;code&gt;fetch_and&lt;/code&gt; 渡すことによって、法&lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt;として &lt;code&gt;order&lt;/code&gt; 。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_and&quot;&gt; &lt;code&gt;AtomicBool::fetch_and&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="460da953958feb4d29ef7b565f8bb84fe0c27874" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_or&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt;&lt;code&gt;AtomicBool::fetch_or&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この固有の安定したバージョンが利用可能である&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;を介した種類 &lt;code&gt;fetch_or&lt;/code&gt; 渡すことによって、法&lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt;として &lt;code&gt;order&lt;/code&gt; 。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt; &lt;code&gt;AtomicBool::fetch_or&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="fe64adf45d801b3817879d281caf34973915fca3" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_or&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt;&lt;code&gt;AtomicBool::fetch_or&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込み関数の安定化バージョンは、&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt;を &lt;code&gt;order&lt;/code&gt; として渡すことにより、 &lt;code&gt;fetch_or&lt;/code&gt; メソッドを介して&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;タイプで使用できます。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt; &lt;code&gt;AtomicBool::fetch_or&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="30017d261ccaa47677175bc1d115dd370a15f192" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_or&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt;&lt;code&gt;AtomicBool::fetch_or&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込み関数の安定化バージョンは、&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt;を &lt;code&gt;order&lt;/code&gt; として渡すことにより、 &lt;code&gt;fetch_or&lt;/code&gt; メソッドを介して&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;タイプで使用できます。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt; &lt;code&gt;AtomicBool::fetch_or&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="6b88f8c0000bb8e04847190fb1bea4c60b0d2d4b" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_or&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt;&lt;code&gt;AtomicBool::fetch_or&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込み関数の安定化バージョンは、&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt;を &lt;code&gt;order&lt;/code&gt; として渡すことにより、 &lt;code&gt;fetch_or&lt;/code&gt; メソッドを介して&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;タイプで使用できます。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt; &lt;code&gt;AtomicBool::fetch_or&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="5515cfd3dce0baaa5d0933d153812410aa18e81b" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_or&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt;&lt;code&gt;AtomicBool::fetch_or&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この固有の安定したバージョンが利用可能である&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;を介し種類 &lt;code&gt;fetch_or&lt;/code&gt; 渡すことによって、法&lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt;として &lt;code&gt;order&lt;/code&gt; 。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_or&quot;&gt; &lt;code&gt;AtomicBool::fetch_or&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="94f2a12d751dc3a744709ca812719eed5be6639d" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_sub&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_sub&quot;&gt;&lt;code&gt;AtomicIsize::fetch_sub&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この固有の安定したバージョンが利用可能である&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;を介した種類 &lt;code&gt;fetch_sub&lt;/code&gt; 渡すことによって、法&lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt;として &lt;code&gt;order&lt;/code&gt; 。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_sub&quot;&gt; &lt;code&gt;AtomicIsize::fetch_sub&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="a7b08115a886002f8e0b6d94070bb4e793dcb17c" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_sub&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_sub&quot;&gt;&lt;code&gt;AtomicIsize::fetch_sub&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込み関数の安定化バージョンは、&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt;を &lt;code&gt;order&lt;/code&gt; として渡すことで &lt;code&gt;fetch_sub&lt;/code&gt; メソッドを介して&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;タイプで使用できます。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_sub&quot;&gt; &lt;code&gt;AtomicIsize::fetch_sub&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="65021746bc3a29e483b54a665e8fe3993f3b7531" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_sub&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_sub&quot;&gt;&lt;code&gt;AtomicIsize::fetch_sub&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込み関数の安定化バージョンは、&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt;を &lt;code&gt;order&lt;/code&gt; として渡すことにより、 &lt;code&gt;fetch_sub&lt;/code&gt; メソッドを介して&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;タイプで使用できます。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_sub&quot;&gt; &lt;code&gt;AtomicIsize::fetch_sub&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="9074d1309228123f0a179daab86adda956d06578" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_sub&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_sub&quot;&gt;&lt;code&gt;AtomicIsize::fetch_sub&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込み関数の安定化バージョンは、&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt;を &lt;code&gt;order&lt;/code&gt; として渡すことにより、 &lt;code&gt;fetch_sub&lt;/code&gt; メソッドを介して&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;タイプで使用できます。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_sub&quot;&gt; &lt;code&gt;AtomicIsize::fetch_sub&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="bf31a4dfb044ce9c3c11fede562f450062e8cb70" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_sub&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_sub&quot;&gt;&lt;code&gt;AtomicIsize::fetch_sub&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この固有の安定したバージョンが利用可能である&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;を介し種類 &lt;code&gt;fetch_sub&lt;/code&gt; 渡すことによって、法&lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt;として &lt;code&gt;order&lt;/code&gt; 。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_sub&quot;&gt; &lt;code&gt;AtomicIsize::fetch_sub&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="0a08ca4aeb864c545fa763c7c1bc0c6adeca1e10" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_xor&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt;&lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この固有の安定したバージョンが利用可能である&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;を介した種類 &lt;code&gt;fetch_xor&lt;/code&gt; 渡すことによって、法&lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt;として &lt;code&gt;order&lt;/code&gt; 。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt; &lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="23e04028b595d303c299af1a09560b78dc738b23" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_xor&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt;&lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込み関数の安定化バージョンは、&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt;を &lt;code&gt;order&lt;/code&gt; として渡すことにより、 &lt;code&gt;fetch_xor&lt;/code&gt; メソッドを介して&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;タイプで使用できます。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt; &lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="d03d95dd3b76208c05df63103f2a4773075d06c7" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_xor&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt;&lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込み関数の安定化バージョンは、&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt;を &lt;code&gt;order&lt;/code&gt; として渡すことにより、 &lt;code&gt;fetch_xor&lt;/code&gt; メソッドを介して&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;タイプで使用できます。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt; &lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="527ff76b4c308bdfc8590a98e3e2f36b010f0a65" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_xor&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt;&lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込み関数の安定化バージョンは、&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt;を &lt;code&gt;order&lt;/code&gt; として渡すことにより、 &lt;code&gt;fetch_xor&lt;/code&gt; メソッドを介して&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;タイプで使用できます。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt; &lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="2ecf9233457e6140afc96f591e6de39578ed746f" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;fetch_xor&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt;&lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この固有の安定したバージョンが利用可能である&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;を介し種類 &lt;code&gt;fetch_xor&lt;/code&gt; 渡すことによって、法&lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt;として &lt;code&gt;order&lt;/code&gt; 。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_xor&quot;&gt; &lt;code&gt;AtomicBool::fetch_xor&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="b72330976c1ede5cb1f5f36f1315049842fbbb63" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;load&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.load&quot;&gt;&lt;code&gt;AtomicBool::load&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込み関数の安定化バージョンは、&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt;を &lt;code&gt;order&lt;/code&gt; として渡すことにより、 &lt;code&gt;load&lt;/code&gt; メソッドを介して&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;タイプで使用できます。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.load&quot;&gt; &lt;code&gt;AtomicBool::load&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="07780502f5ae712c09c48bfbf053afbea4b8cc74" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;load&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.load&quot;&gt;&lt;code&gt;AtomicBool::load&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込み関数の安定化バージョンは、&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt;を &lt;code&gt;order&lt;/code&gt; として渡すことにより、 &lt;code&gt;load&lt;/code&gt; メソッドを介して&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;タイプで使用できます。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.load&quot;&gt; &lt;code&gt;AtomicBool::load&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="61ddb64e96ce0f4ae971acf4e42bb38eda10bc9a" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;load&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.load&quot;&gt;&lt;code&gt;AtomicBool::load&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この固有の安定したバージョンが利用可能である&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;を経由しての種類 &lt;code&gt;load&lt;/code&gt; 渡すことにより、法&lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt;として &lt;code&gt;order&lt;/code&gt; 。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.load&quot;&gt; &lt;code&gt;AtomicBool::load&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dd50153000fdd2e98065597c848234d48c5ae7ef" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;store&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.store&quot;&gt;&lt;code&gt;AtomicBool::store&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込み関数の安定化バージョンは、&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt;を &lt;code&gt;order&lt;/code&gt; として渡すことにより、 &lt;code&gt;store&lt;/code&gt; メソッドを介して&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;タイプで使用できます。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.store&quot;&gt; &lt;code&gt;AtomicBool::store&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3a6dbd5587aa433e73f8c34d35d442568a18d942" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;store&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.store&quot;&gt;&lt;code&gt;AtomicBool::store&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込み関数の安定化バージョンは、&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt;を &lt;code&gt;order&lt;/code&gt; として渡すことにより、 &lt;code&gt;store&lt;/code&gt; メソッドを介して&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;タイプで使用できます。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.store&quot;&gt; &lt;code&gt;AtomicBool::store&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="83f72e56df4940284d7926cf923d2abdf7ea9bb4" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;store&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.store&quot;&gt;&lt;code&gt;AtomicBool::store&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この固有の安定したバージョンが利用可能である&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;を介し種類 &lt;code&gt;store&lt;/code&gt; 渡すことにより、法&lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt;として &lt;code&gt;order&lt;/code&gt; 。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.store&quot;&gt; &lt;code&gt;AtomicBool::store&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="52da2c5cb5cf0d647cd3855825f192673441bdbd" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;swap&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.swap&quot;&gt;&lt;code&gt;AtomicBool::swap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この固有の安定したバージョンが利用可能である&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;を介した種類の &lt;code&gt;swap&lt;/code&gt; 渡すことにより、法&lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt;として &lt;code&gt;order&lt;/code&gt; 。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.swap&quot;&gt; &lt;code&gt;AtomicBool::swap&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="1b30bfb1f2876b5af31915eef811a342ebcdd3b6" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;swap&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.swap&quot;&gt;&lt;code&gt;AtomicBool::swap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込み関数の安定化バージョンは、&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt;を &lt;code&gt;order&lt;/code&gt; として渡すことにより、 &lt;code&gt;swap&lt;/code&gt; メソッドを介して&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;タイプで使用できます。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.swap&quot;&gt; &lt;code&gt;AtomicBool::swap&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="4382bd14df2effe7e74aa90568e6832848eea4e2" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;swap&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.swap&quot;&gt;&lt;code&gt;AtomicBool::swap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込み関数の安定化バージョンは、&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt;を &lt;code&gt;order&lt;/code&gt; として渡すことにより、 &lt;code&gt;swap&lt;/code&gt; メソッドを介して&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;タイプで使用できます。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.swap&quot;&gt; &lt;code&gt;AtomicBool::swap&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="c61255cb553ed1c231e1f72bb0423d91f01ae315" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;swap&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.swap&quot;&gt;&lt;code&gt;AtomicBool::swap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込み関数の安定化バージョンは、&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt;を &lt;code&gt;order&lt;/code&gt; として渡すことにより、 &lt;code&gt;swap&lt;/code&gt; メソッドを介して&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;タイプで使用できます。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.swap&quot;&gt; &lt;code&gt;AtomicBool::swap&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="a69be96162b6a1c17ecee094d784c23706a36adc" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; types via the &lt;code&gt;swap&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.swap&quot;&gt;&lt;code&gt;AtomicBool::swap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この固有の安定したバージョンが利用可能である&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;を経由してのタイプ &lt;code&gt;swap&lt;/code&gt; 渡すことにより、法&lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt;として &lt;code&gt;order&lt;/code&gt; 。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.swap&quot;&gt; &lt;code&gt;AtomicBool::swap&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="f289d7def13530cb2e5c5d7eaa967ea0cbc29ea7" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; unsigned integer types via the &lt;code&gt;fetch_max&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_max&quot;&gt;&lt;code&gt;AtomicU32::fetch_max&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この固有の安定化されたバージョンが利用可能である&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;を介して、符号なし整数型 &lt;code&gt;fetch_max&lt;/code&gt; 通すことによって方法&lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt;ように &lt;code&gt;order&lt;/code&gt; 。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_max&quot;&gt; &lt;code&gt;AtomicU32::fetch_max&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="4eb5f9b2cac38e545e679417e0916b9477cb828c" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; unsigned integer types via the &lt;code&gt;fetch_max&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_max&quot;&gt;&lt;code&gt;AtomicU32::fetch_max&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込み関数の安定化バージョンは、&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt;を &lt;code&gt;order&lt;/code&gt; として渡すことにより、 &lt;code&gt;fetch_max&lt;/code&gt; メソッドを介して&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;符号なし整数型で使用できます。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_max&quot;&gt; &lt;code&gt;AtomicU32::fetch_max&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="aedb9c670fb8b498f17ad50461be8607159cf171" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; unsigned integer types via the &lt;code&gt;fetch_max&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_max&quot;&gt;&lt;code&gt;AtomicU32::fetch_max&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込み関数の安定化バージョンは、&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt;を &lt;code&gt;order&lt;/code&gt; として渡すことにより、 &lt;code&gt;fetch_max&lt;/code&gt; メソッドを介して&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;符号なし整数型で使用できます。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_max&quot;&gt; &lt;code&gt;AtomicU32::fetch_max&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="044d7d27fe09f49e2ad99740d35c149e3d409936" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; unsigned integer types via the &lt;code&gt;fetch_max&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_max&quot;&gt;&lt;code&gt;AtomicU32::fetch_max&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込み関数の安定化バージョンは、&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt;を &lt;code&gt;order&lt;/code&gt; として渡すことにより、 &lt;code&gt;fetch_max&lt;/code&gt; メソッドを介して&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;符号なし整数型で使用できます。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_max&quot;&gt; &lt;code&gt;AtomicU32::fetch_max&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="0c22889aedce154435ee258d0c40e6448efdbc64" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; unsigned integer types via the &lt;code&gt;fetch_max&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_max&quot;&gt;&lt;code&gt;AtomicU32::fetch_max&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この固有の安定化されたバージョンが利用可能である&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;を介して、符号なし整数型 &lt;code&gt;fetch_max&lt;/code&gt; 通すことによって方法&lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt;ように &lt;code&gt;order&lt;/code&gt; 。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_max&quot;&gt; &lt;code&gt;AtomicU32::fetch_max&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="9a58dd280c30118ad91cca00ca18fbb4a646d3fb" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; unsigned integer types via the &lt;code&gt;fetch_min&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_min&quot;&gt;&lt;code&gt;AtomicU32::fetch_min&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この固有の安定化されたバージョンが利用可能である&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;を介して、符号なし整数型 &lt;code&gt;fetch_min&lt;/code&gt; 通すことによって方法&lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt;ように &lt;code&gt;order&lt;/code&gt; 。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_min&quot;&gt; &lt;code&gt;AtomicU32::fetch_min&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="89f1a35ffbfc66293f3ecb009316545b57e972fd" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; unsigned integer types via the &lt;code&gt;fetch_min&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_min&quot;&gt;&lt;code&gt;AtomicU32::fetch_min&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込み関数の安定化バージョンは、&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt;を &lt;code&gt;order&lt;/code&gt; として渡すことにより、 &lt;code&gt;fetch_min&lt;/code&gt; メソッドを介して&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;符号なし整数型で使用できます。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_min&quot;&gt; &lt;code&gt;AtomicU32::fetch_min&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="6f36baf03828badd5e395776499479459fdf74dd" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; unsigned integer types via the &lt;code&gt;fetch_min&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_min&quot;&gt;&lt;code&gt;AtomicU32::fetch_min&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込み関数の安定化バージョンは、&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt;を &lt;code&gt;order&lt;/code&gt; として渡すことにより、 &lt;code&gt;fetch_min&lt;/code&gt; メソッドを介して&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;符号なし整数型で使用できます。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_min&quot;&gt; &lt;code&gt;AtomicU32::fetch_min&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="d7b26c022d9640d58bf0ee1df55fea1127cc8b08" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; unsigned integer types via the &lt;code&gt;fetch_min&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_min&quot;&gt;&lt;code&gt;AtomicU32::fetch_min&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込み関数の安定化バージョンは、&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt;を &lt;code&gt;order&lt;/code&gt; として渡すことにより、 &lt;code&gt;fetch_min&lt;/code&gt; メソッドを介して&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;符号なし整数型で使用できます。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_min&quot;&gt; &lt;code&gt;AtomicU32::fetch_min&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="b715010a7a857987bd13e4e2c7860444d5f72aff" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; unsigned integer types via the &lt;code&gt;fetch_min&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_min&quot;&gt;&lt;code&gt;AtomicU32::fetch_min&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この固有の安定化されたバージョンが利用可能である&lt;a href=&quot;../sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;を介して、符号なし整数型 &lt;code&gt;fetch_min&lt;/code&gt; 通すことによって方法&lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt;ように &lt;code&gt;order&lt;/code&gt; 。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicu32#method.fetch_min&quot;&gt; &lt;code&gt;AtomicU32::fetch_min&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="d5f8d269b525f2aa0c49880dc3986476498a5a32" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/struct.atomicbool&quot;&gt;&lt;code&gt;AtomicBool&lt;/code&gt;&lt;/a&gt; type via the &lt;code&gt;fetch_nand&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt;&lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この固有の安定したバージョンがで提供されています&lt;a href=&quot;../sync/atomic/struct.atomicbool&quot;&gt; &lt;code&gt;AtomicBool&lt;/code&gt; の&lt;/a&gt;経由種類 &lt;code&gt;fetch_nand&lt;/code&gt; 渡すことによって、法&lt;a href=&quot;../sync/atomic/enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt;として &lt;code&gt;order&lt;/code&gt; 。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt; &lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="45b7d1ba04947e0d60fd8323f25d9cb851df4d45" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/struct.atomicbool&quot;&gt;&lt;code&gt;AtomicBool&lt;/code&gt;&lt;/a&gt; type via the &lt;code&gt;fetch_nand&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt;&lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この固有の安定したバージョンがで提供されています&lt;a href=&quot;../sync/atomic/struct.atomicbool&quot;&gt; &lt;code&gt;AtomicBool&lt;/code&gt; の&lt;/a&gt;経由種類 &lt;code&gt;fetch_nand&lt;/code&gt; 渡すことによって、法&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt;て &lt;code&gt;order&lt;/code&gt; 。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt; &lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="f0f46b18b5f9509f4b838f2cd1cc47b1cca4ac44" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/struct.atomicbool&quot;&gt;&lt;code&gt;AtomicBool&lt;/code&gt;&lt;/a&gt; type via the &lt;code&gt;fetch_nand&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt;&lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この固有の安定したバージョンがで提供されています&lt;a href=&quot;../sync/atomic/struct.atomicbool&quot;&gt; &lt;code&gt;AtomicBool&lt;/code&gt; の&lt;/a&gt;経由種類 &lt;code&gt;fetch_nand&lt;/code&gt; 渡すことによって、法&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Relaxed&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt;て &lt;code&gt;order&lt;/code&gt; 。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt; &lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="6eee377d6930faac324afa2f516a7fca7070547e" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/struct.atomicbool&quot;&gt;&lt;code&gt;AtomicBool&lt;/code&gt;&lt;/a&gt; type via the &lt;code&gt;fetch_nand&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt;&lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この固有の安定したバージョンがで提供されています&lt;a href=&quot;../sync/atomic/struct.atomicbool&quot;&gt; &lt;code&gt;AtomicBool&lt;/code&gt; の&lt;/a&gt;経由種類 &lt;code&gt;fetch_nand&lt;/code&gt; 渡すことによって、法&lt;a href=&quot;../sync/atomic/enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt;と &lt;code&gt;order&lt;/code&gt; 。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt; &lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="c150f5488b1c18a2f570344ce5e7e4fbf333ebdf" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is available on the &lt;a href=&quot;../sync/atomic/struct.atomicbool&quot;&gt;&lt;code&gt;AtomicBool&lt;/code&gt;&lt;/a&gt; type via the &lt;code&gt;fetch_nand&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt;&lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この固有の安定したバージョンがで提供されています&lt;a href=&quot;../sync/atomic/struct.atomicbool&quot;&gt; &lt;code&gt;AtomicBool&lt;/code&gt; の&lt;/a&gt;経由種類 &lt;code&gt;fetch_nand&lt;/code&gt; 渡すことによって、法&lt;a href=&quot;../sync/atomic/enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt;として &lt;code&gt;order&lt;/code&gt; 。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicbool#method.fetch_nand&quot;&gt; &lt;code&gt;AtomicBool::fetch_nand&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="4467e4d025c942d0e46a8d42d28e9cb70772aadf" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;count_ones&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.count_ones&quot;&gt;&lt;code&gt;u32::count_ones&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">この組み込み関数の安定化バージョンは、 &lt;code&gt;count_ones&lt;/code&gt; メソッドを介して整数プリミティブで使用できます。たとえば、&lt;a href=&quot;../primitive.u32#method.count_ones&quot;&gt; &lt;code&gt;u32::count_ones&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f49764c7bf099d11524ff3ae31ea8122bd687603" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;leading_zeros&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.leading_zeros&quot;&gt;&lt;code&gt;u32::leading_zeros&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">この組み込み関数の安定化バージョンは、 &lt;code&gt;leading_zeros&lt;/code&gt; メソッドを介して整数プリミティブで使用できます。たとえば、&lt;a href=&quot;../primitive.u32#method.leading_zeros&quot;&gt; &lt;code&gt;u32::leading_zeros&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="94453dce8a2a385d273d4c54481b7123c231b9e1" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;overflowing_add&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.overflowing_add&quot;&gt;&lt;code&gt;u32::overflowing_add&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">この組み込み関数の安定化バージョンは、 &lt;code&gt;overflowing_add&lt;/code&gt; メソッドを介して整数プリミティブで使用できます。たとえば、&lt;a href=&quot;../primitive.u32#method.overflowing_add&quot;&gt; &lt;code&gt;u32::overflowing_add&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="975a6bc8f0eb314f9e1b240024dd857b1481fb4f" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;overflowing_mul&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.overflowing_mul&quot;&gt;&lt;code&gt;u32::overflowing_mul&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">この組み込み関数の安定化バージョンは、 &lt;code&gt;overflowing_mul&lt;/code&gt; メソッドを介して整数プリミティブで使用できます。たとえば、&lt;a href=&quot;../primitive.u32#method.overflowing_mul&quot;&gt; &lt;code&gt;u32::overflowing_mul&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="05ac2c8d4649564823e71195e6e1991816e3c134" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;overflowing_sub&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.overflowing_sub&quot;&gt;&lt;code&gt;u32::overflowing_sub&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">この組み込み関数の安定化バージョンは、 &lt;code&gt;overflowing_sub&lt;/code&gt; メソッドを介して整数プリミティブで使用できます。たとえば、&lt;a href=&quot;../primitive.u32#method.overflowing_sub&quot;&gt; &lt;code&gt;u32::overflowing_sub&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cea1555efef9a893424297cca53eccdff2cb4c12" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;reverse_bits&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.reverse_bits&quot;&gt;&lt;code&gt;u32::reverse_bits&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">この組み込み関数の安定化バージョンは、 &lt;code&gt;reverse_bits&lt;/code&gt; メソッドを介して整数プリミティブで使用できます。たとえば、&lt;a href=&quot;../primitive.u32#method.reverse_bits&quot;&gt; &lt;code&gt;u32::reverse_bits&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="02b9a60eaad995a8b508e08e5f720afcfb3cdf4f" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;rotate_left&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.rotate_left&quot;&gt;&lt;code&gt;u32::rotate_left&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">この組み込み関数の安定化バージョンは、 &lt;code&gt;rotate_left&lt;/code&gt; メソッドを介して整数プリミティブで使用できます。たとえば、&lt;a href=&quot;../primitive.u32#method.rotate_left&quot;&gt; &lt;code&gt;u32::rotate_left&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a39d8d5e922a37bc7cb7a4273c351e3237285524" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;rotate_right&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.rotate_right&quot;&gt;&lt;code&gt;u32::rotate_right&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">この組み込み関数の安定化バージョンは、 &lt;code&gt;rotate_right&lt;/code&gt; メソッドを介して整数プリミティブで使用できます。たとえば、&lt;a href=&quot;../primitive.u32#method.rotate_right&quot;&gt; &lt;code&gt;u32::rotate_right&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1c9cb80ab093ca12a015c158de3a354687ef2774" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;saturating_add&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.saturating_add&quot;&gt;&lt;code&gt;u32::saturating_add&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">この組み込み関数の安定化バージョンは、 &lt;code&gt;saturating_add&lt;/code&gt; メソッドを介して整数プリミティブで使用できます。たとえば、&lt;a href=&quot;../primitive.u32#method.saturating_add&quot;&gt; &lt;code&gt;u32::saturating_add&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0dfb3fdba827a384aada0939a551d1f733164685" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;saturating_sub&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.saturating_sub&quot;&gt;&lt;code&gt;u32::saturating_sub&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">この組み込み関数の安定化バージョンは、 &lt;code&gt;saturating_sub&lt;/code&gt; メソッドを介して整数プリミティブで使用できます。たとえば、&lt;a href=&quot;../primitive.u32#method.saturating_sub&quot;&gt; &lt;code&gt;u32::saturating_sub&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7476e3eb126b1478bcad495831ba6637eb3d2b14" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;swap_bytes&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.swap_bytes&quot;&gt;&lt;code&gt;u32::swap_bytes&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">この組み込み関数の安定化バージョンは、 &lt;code&gt;swap_bytes&lt;/code&gt; メソッドを介して整数プリミティブで使用できます。たとえば、&lt;a href=&quot;../primitive.u32#method.swap_bytes&quot;&gt; &lt;code&gt;u32::swap_bytes&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e398694f9fea1333665249a1e9c25a4d94f59367" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;trailing_zeros&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.trailing_zeros&quot;&gt;&lt;code&gt;u32::trailing_zeros&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">この組み込み関数の安定化バージョンは、 &lt;code&gt;trailing_zeros&lt;/code&gt; メソッドを介して整数プリミティブで使用できます。たとえば、&lt;a href=&quot;../primitive.u32#method.trailing_zeros&quot;&gt; &lt;code&gt;u32::trailing_zeros&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7c77154ad25fdd3e2bc406487defdcb53ca75726" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;wrapping_add&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.wrapping_add&quot;&gt;&lt;code&gt;u32::wrapping_add&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">この組み込み関数の安定化バージョンは、 &lt;code&gt;wrapping_add&lt;/code&gt; メソッドを介して整数プリミティブで使用できます。たとえば、&lt;a href=&quot;../primitive.u32#method.wrapping_add&quot;&gt; &lt;code&gt;u32::wrapping_add&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fc2b20ca06dc1c8110b4d0397b1994d813ffed56" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;wrapping_mul&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.wrapping_mul&quot;&gt;&lt;code&gt;u32::wrapping_mul&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">この組み込み関数の安定化バージョンは、 &lt;code&gt;wrapping_mul&lt;/code&gt; メソッドを介して整数プリミティブで使用できます。たとえば、&lt;a href=&quot;../primitive.u32#method.wrapping_mul&quot;&gt; &lt;code&gt;u32::wrapping_mul&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="00df89161b3ee01f6671c6eedc0e25647116beb0" translate="yes" xml:space="preserve">
          <source>The stabilized versions of this intrinsic are available on the integer primitives via the &lt;code&gt;wrapping_sub&lt;/code&gt; method. For example, &lt;a href=&quot;../primitive.u32#method.wrapping_sub&quot;&gt;&lt;code&gt;u32::wrapping_sub&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">この組み込み関数の安定化バージョンは、 &lt;code&gt;wrapping_sub&lt;/code&gt; メソッドを介して整数プリミティブで使用できます。たとえば、&lt;a href=&quot;../primitive.u32#method.wrapping_sub&quot;&gt; &lt;code&gt;u32::wrapping_sub&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="07e69ca4af06caf0678a0eb7f58dbb4160ebfce9" translate="yes" xml:space="preserve">
          <source>The standard library API documentation describes methods that vectors, strings, and hash maps have that will be helpful for these exercises!</source>
          <target state="translated">標準ライブラリAPIのドキュメントには、これらの演習に役立つであろうベクトル、文字列、ハッシュマップが持つメソッドが記述されています!</target>
        </trans-unit>
        <trans-unit id="ecfac3d3b7b498f942f6cc167a3014bcca50e8db" translate="yes" xml:space="preserve">
          <source>The standard library also provides a &lt;code&gt;Wrapping&amp;lt;T&amp;gt;&lt;/code&gt; newtype which ensures all standard arithmetic operations for &lt;code&gt;T&lt;/code&gt; have wrapping semantics.</source>
          <target state="translated">標準ライブラリも提供 &lt;code&gt;Wrapping&amp;lt;T&amp;gt;&lt;/code&gt; のためのすべての標準的な演算を保証するのnewtype &lt;code&gt;T&lt;/code&gt; はラッピングセマンティクスを持っています。</target>
        </trans-unit>
        <trans-unit id="e62bb358494cb55da1b597b5302098f7179da4a8" translate="yes" xml:space="preserve">
          <source>The standard library contains additional 'smart pointer' types beyond references and raw pointers.</source>
          <target state="translated">標準ライブラリには、参照や生ポインタ以外の「スマートポインタ」型が追加されています。</target>
        </trans-unit>
        <trans-unit id="4aeb001acf27f60d5c3f4949174f0ea7b98815a0" translate="yes" xml:space="preserve">
          <source>The standard library documentation for the &lt;code&gt;env::args&lt;/code&gt; function shows that the type of the iterator it returns is &lt;code&gt;std::env::Args&lt;/code&gt;. We&amp;rsquo;ve updated the signature of the &lt;code&gt;Config::new&lt;/code&gt; function so the parameter &lt;code&gt;args&lt;/code&gt; has the type &lt;code&gt;std::env::Args&lt;/code&gt; instead of &lt;code&gt;&amp;amp;[String]&lt;/code&gt;. Because we&amp;rsquo;re taking ownership of &lt;code&gt;args&lt;/code&gt; and we&amp;rsquo;ll be mutating &lt;code&gt;args&lt;/code&gt; by iterating over it, we can add the &lt;code&gt;mut&lt;/code&gt; keyword into the specification of the &lt;code&gt;args&lt;/code&gt; parameter to make it mutable.</source>
          <target state="translated">&lt;code&gt;env::args&lt;/code&gt; 関数の標準ライブラリのドキュメントは、それが返すイテレータのタイプが &lt;code&gt;std::env::Args&lt;/code&gt; ことを示しています。 &lt;code&gt;Config::new&lt;/code&gt; 関数のシグネチャを更新して、パラメーター &lt;code&gt;args&lt;/code&gt; の型が &lt;code&gt;&amp;amp;[String]&lt;/code&gt; ではなく &lt;code&gt;std::env::Args&lt;/code&gt; ようにしました。我々はの所有権取っているので &lt;code&gt;args&lt;/code&gt; 、我々が変異することがあります &lt;code&gt;args&lt;/code&gt; 、反復処理を行うことで、我々は、追加することができます &lt;code&gt;mut&lt;/code&gt; の仕様にキーワードを &lt;code&gt;args&lt;/code&gt; それを可変にするパラメータ。</target>
        </trans-unit>
        <trans-unit id="0ac01984afb710ebee7af9fdef959461335b5771" translate="yes" xml:space="preserve">
          <source>The standard library does &lt;em&gt;not&lt;/em&gt; automatically wait on child processes (not even if the &lt;code&gt;Child&lt;/code&gt; is dropped), it is up to the application developer to do so. As a consequence, dropping &lt;code&gt;Child&lt;/code&gt; handles without waiting on them first is not recommended in long-running applications.</source>
          <target state="translated">標準ライブラリは子プロセスを自動的に待機しませ&lt;em&gt;ん&lt;/em&gt;（ &lt;code&gt;Child&lt;/code&gt; がドロップされた場合でも）。待機するかどうかはアプリケーション開発者に任されています。結果として、最初にそれらを待たずに &lt;code&gt;Child&lt;/code&gt; ハンドルをドロップすることは、長時間実行されるアプリケーションでは推奨されません。</target>
        </trans-unit>
        <trans-unit id="c3da8861a8cd359749d019429f14004546548517" translate="yes" xml:space="preserve">
          <source>The standard library exports many modules &lt;em&gt;with the same name as primitive types&lt;/em&gt;. These define additional items related to the primitive type, but not the all-important methods.</source>
          <target state="translated">標準ライブラリは&lt;em&gt;、プリミティブ型と同じ名前の&lt;/em&gt;多くのモジュール&lt;em&gt;を&lt;/em&gt;エクスポートし&lt;em&gt;ます&lt;/em&gt;。これらは、プリミティブ型に関連する追加の項目を定義しますが、重要なメソッドは定義しません。</target>
        </trans-unit>
        <trans-unit id="be570bfc11d12183d4ccfc099e5e91a1312fadce" translate="yes" xml:space="preserve">
          <source>The standard library exposes three common ways to deal with contiguous regions of memory:</source>
          <target state="translated">標準ライブラリは、メモリの連続領域を扱う3つの一般的な方法を公開しています。</target>
        </trans-unit>
        <trans-unit id="d66210e7b423f4f4e31543419e308e2c95ac4c07" translate="yes" xml:space="preserve">
          <source>The standard library has other types that provide interior mutability, such as &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt;, which is similar except that instead of giving references to the inner value, the value is copied in and out of the &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt;. There&amp;rsquo;s also &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt;, which offers interior mutability that&amp;rsquo;s safe to use across threads; we&amp;rsquo;ll discuss its use in Chapter 16. Check out the standard library docs for more details on the differences between these types.</source>
          <target state="translated">標準ライブラリには、 &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; などの内部の可変性を提供する他のタイプがあります。これは、内部値への参照を与える代わりに、値が &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; 内外にコピーされることを除いて同様です。スレッド間で安全に使用できる内部の可変性を提供する &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; もあります。これらのタイプの違いの詳細については、標準ライブラリのドキュメントを確認してください。</target>
        </trans-unit>
        <trans-unit id="a3eb5ea324c5e016fa7225e0db42ddd0287496a0" translate="yes" xml:space="preserve">
          <source>The standard library implements some I/O traits on various types which are commonly used as a buffer, like &lt;code&gt;Cursor&amp;lt;&lt;/code&gt;&lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;u8&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;Cursor&amp;lt;&lt;/code&gt;&lt;a href=&quot;../primitive.slice&quot;&gt;&lt;code&gt;&amp;amp;[u8]&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">標準ライブラリは、 &lt;code&gt;Cursor&amp;lt;&lt;/code&gt; &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;u8&amp;gt;&amp;gt;&lt;/code&gt; や &lt;code&gt;Cursor&amp;lt;&lt;/code&gt; &lt;a href=&quot;../primitive.slice&quot;&gt; &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; のように、一般的にバッファとして使用されるさまざまなタイプのI / O特性を実装しています。</target>
        </trans-unit>
        <trans-unit id="bac69e8dd1e3e493ce33a798e654cad2d62974e3" translate="yes" xml:space="preserve">
          <source>The standard library implements some I/O traits on various types which are commonly used as a buffer, like &lt;code&gt;Cursor&amp;lt;&lt;/code&gt;&lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;u8&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;Cursor&amp;lt;&lt;/code&gt;&lt;a href=&quot;../slice/index&quot;&gt;&lt;code&gt;&amp;amp;[u8]&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">標準ライブラリは、 &lt;code&gt;Cursor&amp;lt;&lt;/code&gt; &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;u8&amp;gt;&amp;gt;&lt;/code&gt; や &lt;code&gt;Cursor&amp;lt;&lt;/code&gt; &lt;a href=&quot;../slice/index&quot;&gt; &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; など、バッファとして一般的に使用されるさまざまなタイプにいくつかのI / O特性を実装しています。</target>
        </trans-unit>
        <trans-unit id="cd43fc91f30c20105f33015f4862eaa4ba469ffd" translate="yes" xml:space="preserve">
          <source>The standard library in general strives to support both statically linked and dynamically linked C runtimes for targets as appropriate. For example the &lt;code&gt;x86_64-pc-windows-msvc&lt;/code&gt; and &lt;code&gt;x86_64-unknown-linux-musl&lt;/code&gt; targets typically come with both runtimes and the user selects which one they'd like. All targets in the compiler have a default mode of linking to the C runtime. Typically targets are linked dynamically by default, but there are exceptions which are static by default such as:</source>
          <target state="translated">一般に、標準ライブラリは、静的にリンクされたCランタイムと動的にリンクされたCランタイムの両方を適切にサポートするよう努めています。たとえば、 &lt;code&gt;x86_64-pc-windows-msvc&lt;/code&gt; および &lt;code&gt;x86_64-unknown-linux-musl&lt;/code&gt; ターゲットには通常、両方のランタイムが付属しており、ユーザーはどちらを使用するかを選択します。コンパイラーのすべてのターゲットには、Cランタイムにリンクするデフォルトのモードがあります。通常、ターゲットはデフォルトで動的にリンクされますが、次のようなデフォルトで静的な例外があります。</target>
        </trans-unit>
        <trans-unit id="e62009a1ff01cf79d8a5846c788aa68bf271141c" translate="yes" xml:space="preserve">
          <source>The standard library provides an implementation of &lt;code&gt;panic_handler&lt;/code&gt; that defaults to unwinding the stack but that can be &lt;a href=&quot;../book/ch09-01-unrecoverable-errors-with-panic&quot;&gt;changed to abort the process&lt;/a&gt;. The standard library's panic behavior can be modified at runtime with the &lt;a href=&quot;../std/panic/fn.set_hook&quot;&gt;set_hook&lt;/a&gt; function.</source>
          <target state="translated">標準ライブラリは、デフォルトでスタックの巻き戻しを行う &lt;code&gt;panic_handler&lt;/code&gt; の実装を提供しますが&lt;a href=&quot;../book/ch09-01-unrecoverable-errors-with-panic&quot;&gt;、プロセスを中止&lt;/a&gt;するように変更できます。標準ライブラリのパニック動作は、&lt;a href=&quot;../std/panic/fn.set_hook&quot;&gt;set_hook&lt;/a&gt;関数を使用して実行時に変更できます。</target>
        </trans-unit>
        <trans-unit id="a6bfe00112d50ce1df3b69fa8e0f97c99e921c7e" translate="yes" xml:space="preserve">
          <source>The standard library&amp;rsquo;s &lt;code&gt;Add&lt;/code&gt; trait is an example of the second purpose: usually, you&amp;rsquo;ll add two like types, but the &lt;code&gt;Add&lt;/code&gt; trait provides the ability to customize beyond that. Using a default type parameter in the &lt;code&gt;Add&lt;/code&gt; trait definition means you don&amp;rsquo;t have to specify the extra parameter most of the time. In other words, a bit of implementation boilerplate isn&amp;rsquo;t needed, making it easier to use the trait.</source>
          <target state="translated">標準ライブラリの &lt;code&gt;Add&lt;/code&gt; トレイトは、2番目の目的の例です。通常、2つのタイプを追加しますが、 &lt;code&gt;Add&lt;/code&gt; トレイトはそれ以上にカスタマイズする機能を提供します。 &lt;code&gt;Add&lt;/code&gt; トレイト定義でデフォルトのタイプパラメータを使用すると、ほとんどの場合、追加のパラメータを指定する必要がなくなります。言い換えれば、少しボイラープレートを実装する必要がなく、トレイトを使いやすくしています。</target>
        </trans-unit>
        <trans-unit id="0eb239c2b2b429ca2fb24dfb5a68ef2028451c54" translate="yes" xml:space="preserve">
          <source>The start and end of the string (when &lt;code&gt;index == self.len()&lt;/code&gt;) are considered to be boundaries.</source>
          <target state="translated">文字列の開始と終了（ &lt;code&gt;index == self.len()&lt;/code&gt; ）は境界と見なされます。</target>
        </trans-unit>
        <trans-unit id="cc00d65ec1e11702c522241a5699948a50675d34" translate="yes" xml:space="preserve">
          <source>The starting index must come before the ending index;</source>
          <target state="translated">開始インデックスは、終了インデックスの前に来なければなりません。</target>
        </trans-unit>
        <trans-unit id="7d09dcb9f35a47d4d0374a51c368ed9570b886f1" translate="yes" xml:space="preserve">
          <source>The starting index must not exceed the ending index;</source>
          <target state="translated">開始インデックスは、終了インデックスを超えてはならない。</target>
        </trans-unit>
        <trans-unit id="71f319cd135ed3830fb0df0009e873ba0d9d3bd8" translate="yes" xml:space="preserve">
          <source>The static initializer is a &lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;constant expression&lt;/a&gt; evaluated at compile time. Static initializers may refer to other statics.</source>
          <target state="translated">静的初期化子は、コンパイル時に評価される&lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;定数式&lt;/a&gt;です。静的初期化子は、他の静的を参照する場合があります。</target>
        </trans-unit>
        <trans-unit id="37ec0e6627e56520c118b2a4c9fe270333b4a9ac" translate="yes" xml:space="preserve">
          <source>The status (exit code) of the process.</source>
          <target state="translated">プロセスの状態(終了コード)。</target>
        </trans-unit>
        <trans-unit id="2deb263189905df596d3c94b6a6e46fb7fad91f4" translate="yes" xml:space="preserve">
          <source>The status code 200 is the standard success response. The text is a tiny successful HTTP response. Let&amp;rsquo;s write this to the stream as our response to a successful request! From the &lt;code&gt;handle_connection&lt;/code&gt; function, remove the &lt;code&gt;println!&lt;/code&gt; that was printing the request data and replace it with the code in Listing 20-3.</source>
          <target state="translated">ステータスコード200は、標準の成功応答です。テキストは小さな成功したHTTP応答です。これを、成功した要求への応答としてストリームに書き込みましょう！ &lt;code&gt;handle_connection&lt;/code&gt; 関数から、 &lt;code&gt;println!&lt;/code&gt; を削除します。これはリクエストデータを出力し、リスト20-3のコードに置き換えます。</target>
        </trans-unit>
        <trans-unit id="121dc7dfe8e1f05a50f59cc42ea3919e004fbd87" translate="yes" xml:space="preserve">
          <source>The stdin handle to the child process, if any, will be closed before waiting. This helps avoid deadlock: it ensures that the child does not block waiting for input from the parent, while the parent waits for the child to exit.</source>
          <target state="translated">子プロセスへの標準入力ハンドルがある場合は、待機する前に閉じられます。これはデッドロックを回避するのに役立ちます。 親プロセスが子プロセスの終了を待っている間、子プロセスが親プロセスからの入力待ちをブロックしないようにします。</target>
        </trans-unit>
        <trans-unit id="9e925de820aa28eb2278cfb5b172897339fec44e" translate="yes" xml:space="preserve">
          <source>The stem is:</source>
          <target state="translated">ステムは</target>
        </trans-unit>
        <trans-unit id="f0b062427634e6f3b4d22b8847d4a85e632115c3" translate="yes" xml:space="preserve">
          <source>The stream of &lt;a href=&quot;enum.searchstep#variant.Match&quot;&gt;&lt;code&gt;Match&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;enum.searchstep#variant.Reject&quot;&gt;&lt;code&gt;Reject&lt;/code&gt;&lt;/a&gt; values up to a &lt;a href=&quot;enum.searchstep#variant.Done&quot;&gt;&lt;code&gt;Done&lt;/code&gt;&lt;/a&gt; will contain index ranges that are adjacent, non-overlapping, covering the whole haystack, and laying on utf8 boundaries.</source>
          <target state="translated">&lt;a href=&quot;enum.searchstep#variant.Done&quot;&gt; &lt;code&gt;Done&lt;/code&gt; &lt;/a&gt;までの&lt;a href=&quot;enum.searchstep#variant.Match&quot;&gt; &lt;code&gt;Match&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;enum.searchstep#variant.Reject&quot;&gt; &lt;code&gt;Reject&lt;/code&gt; &lt;/a&gt;値のストリームには、隣接し、重複せず、干し草の山全体をカバーし、utf8境界に配置されるインデックス範囲が含まれます。</target>
        </trans-unit>
        <trans-unit id="29cd101b0d8222a260b75e7043b8f85140377fdb" translate="yes" xml:space="preserve">
          <source>The stream of &lt;code&gt;Match&lt;/code&gt; and &lt;code&gt;Reject&lt;/code&gt; values up to a &lt;code&gt;Done&lt;/code&gt; will contain index ranges that are adjacent, non-overlapping, covering the whole haystack, and laying on utf8 boundaries.</source>
          <target state="translated">&lt;code&gt;Done&lt;/code&gt; までの &lt;code&gt;Match&lt;/code&gt; および &lt;code&gt;Reject&lt;/code&gt; 値のストリームには、隣接する重複しないインデックス範囲が含まれ、干し草全体をカバーし、utf8境界に配置されます。</target>
        </trans-unit>
        <trans-unit id="fe598c8b995968505dc48317e5f0bc507dd1c32a" translate="yes" xml:space="preserve">
          <source>The stream typically has a fixed size, allowing seeking relative to either end or the current offset.</source>
          <target state="translated">ストリームは通常、固定サイズを持ち、どちらかの端または現在のオフセットからの相対的なシークを可能にします。</target>
        </trans-unit>
        <trans-unit id="3f8a9a233edfd6e32f4b57b8721cdb5b1b1aca0a" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;s3&lt;/code&gt; will contain &lt;code&gt;Hello, world!&lt;/code&gt; as a result of this code. The reason &lt;code&gt;s1&lt;/code&gt; is no longer valid after the addition and the reason we used a reference to &lt;code&gt;s2&lt;/code&gt; has to do with the signature of the method that gets called when we use the &lt;code&gt;+&lt;/code&gt; operator. The &lt;code&gt;+&lt;/code&gt; operator uses the &lt;code&gt;add&lt;/code&gt; method, whose signature looks something like this:</source>
          <target state="translated">文字列 &lt;code&gt;s3&lt;/code&gt; には &lt;code&gt;Hello, world!&lt;/code&gt; が含まれます。このコードの結果として。理由 &lt;code&gt;s1&lt;/code&gt; はさらに、我々はを参照する使用の理由の後にはもはや有効ではない &lt;code&gt;s2&lt;/code&gt; が、我々が使用したときに呼び出されるメソッドのシグネチャに関係している &lt;code&gt;+&lt;/code&gt; の演算子を。 &lt;code&gt;+&lt;/code&gt; の演算子は、使用する &lt;code&gt;add&lt;/code&gt; その署名次のようになります方法を、：</target>
        </trans-unit>
        <trans-unit id="00f2d10e6fe0131d33ac9bca9a600be0160e329e" translate="yes" xml:space="preserve">
          <source>The string Pattern API.</source>
          <target state="translated">文字列パターンAPI。</target>
        </trans-unit>
        <trans-unit id="12fed2044893f571a9f644790505d48a15787f1f" translate="yes" xml:space="preserve">
          <source>The string is expected to be an optional &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt; sign followed by digits. Leading and trailing whitespace represent an error. Digits are a subset of these characters, depending on &lt;code&gt;radix&lt;/code&gt;:</source>
          <target state="translated">文字列は、オプションの &lt;code&gt;+&lt;/code&gt; または &lt;code&gt;-&lt;/code&gt; 記号とそれに続く数字であることが期待されます。先頭と末尾の空白はエラーを表します。数字は、 &lt;code&gt;radix&lt;/code&gt; に応じて、これらの文字のサブセットです。</target>
        </trans-unit>
        <trans-unit id="c23316acb8db6205270f951b08328de7cc2d92db" translate="yes" xml:space="preserve">
          <source>The string is expected to be an optional &lt;code&gt;+&lt;/code&gt; sign followed by digits. Leading and trailing whitespace represent an error. Digits are a subset of these characters, depending on &lt;code&gt;radix&lt;/code&gt;:</source>
          <target state="translated">文字列は、オプションの &lt;code&gt;+&lt;/code&gt; 記号とそれに続く数字であることが期待されます。先頭と末尾の空白はエラーを表します。数字は、 &lt;code&gt;radix&lt;/code&gt; に応じて、これらの文字のサブセットです。</target>
        </trans-unit>
        <trans-unit id="468f8218bbd425a57c6d5b5fde91fdb78d951a69" translate="yes" xml:space="preserve">
          <source>The string on the right-hand side is only borrowed; its contents are copied into the returned &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">右側の弦は借りただけです。その内容は、返された &lt;code&gt;String&lt;/code&gt; にコピーされます。</target>
        </trans-unit>
        <trans-unit id="86da74512bec8006d79316da49e5b54d47ae707d" translate="yes" xml:space="preserve">
          <source>The string will be able to hold exactly &lt;code&gt;capacity&lt;/code&gt; length units of other OS strings without reallocating. If &lt;code&gt;capacity&lt;/code&gt; is 0, the string will not allocate.</source>
          <target state="translated">文字列は、再割り当てすることなく、他のOS文字列の &lt;code&gt;capacity&lt;/code&gt; 長単位を正確に保持できます。場合は &lt;code&gt;capacity&lt;/code&gt; 0で、文字列が割り当てられないでしょう。</target>
        </trans-unit>
        <trans-unit id="b6f927907143ca3f662c21fec70de91f1f0df225" translate="yes" xml:space="preserve">
          <source>The struct &lt;code&gt;PointList&lt;/code&gt; cannot implement &lt;code&gt;Copy&lt;/code&gt;, because &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; is not &lt;code&gt;Copy&lt;/code&gt;. If we attempt to derive a &lt;code&gt;Copy&lt;/code&gt; implementation, we'll get an error:</source>
          <target state="translated">&lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;は &lt;code&gt;Copy&lt;/code&gt; ではないため、構造体 &lt;code&gt;PointList&lt;/code&gt; は &lt;code&gt;Copy&lt;/code&gt; を実装できません。 &lt;code&gt;Copy&lt;/code&gt; 実装を派生させようとすると、エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="5c8326afa9ea5c7b5b28789d2c040dda354125af" translate="yes" xml:space="preserve">
          <source>The struct is marked &lt;code&gt;pub&lt;/code&gt; so that other code can use it, but the fields within the struct remain private. This is important in this case because we want to ensure that whenever a value is added or removed from the list, the average is also updated. We do this by implementing &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;remove&lt;/code&gt;, and &lt;code&gt;average&lt;/code&gt; methods on the struct, as shown in Listing 17-2:</source>
          <target state="translated">他のコードが使用できるように、構造体は &lt;code&gt;pub&lt;/code&gt; とマークされていますが、構造体内のフィールドはプライベートのままです。この場合、これは重要です。値がリストに追加またはリストから削除されるたびに、平均値も更新されるようにするためです。リスト17-2で示されるように、構造体に &lt;code&gt;add&lt;/code&gt; 、 &lt;code&gt;remove&lt;/code&gt; 、および &lt;code&gt;average&lt;/code&gt; メソッドを実装することでこれを行います。</target>
        </trans-unit>
        <trans-unit id="9c1c27f7e80229e155110850a64cfa98b9973379" translate="yes" xml:space="preserve">
          <source>The struct must only be &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt; if all the structural fields are &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt;. This is the default, but &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt; is a safe trait, so as the author of the struct it is your responsibility &lt;em&gt;not&lt;/em&gt; to add something like &lt;code&gt;impl&amp;lt;T&amp;gt; Unpin for Struct&amp;lt;T&amp;gt;&lt;/code&gt;. (Notice that adding a projection operation requires unsafe code, so the fact that &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt; is a safe trait does not break the principle that you only have to worry about any of this if you use &lt;code&gt;unsafe&lt;/code&gt;.)</source>
          <target state="translated">すべての構造体フィールドが&lt;a href=&quot;../marker/trait.unpin&quot;&gt; &lt;code&gt;Unpin&lt;/code&gt; である&lt;/a&gt;場合にのみ、構造体を&lt;a href=&quot;../marker/trait.unpin&quot;&gt; &lt;code&gt;Unpin&lt;/code&gt; に&lt;/a&gt;する必要があります。これはデフォルトですが、&lt;a href=&quot;../marker/trait.unpin&quot;&gt; &lt;code&gt;Unpin&lt;/code&gt; &lt;/a&gt;は安全な特性であるため、構造体の作成者は、 &lt;code&gt;impl&amp;lt;T&amp;gt; Unpin for Struct&amp;lt;T&amp;gt;&lt;/code&gt; ようなものを追加し&lt;em&gt;ないの&lt;/em&gt;はあなたの責任です。（お知らせは、投影操作を追加すると、危険なコードを必要とするという事実ので、&lt;a href=&quot;../marker/trait.unpin&quot;&gt; &lt;code&gt;Unpin&lt;/code&gt; &lt;/a&gt;使用する場合にのみ、このいずれかを心配する必要があるという原則壊れない安全な形質である &lt;code&gt;unsafe&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="a87dba90688420e84c6cfc3a67588b540866213a" translate="yes" xml:space="preserve">
          <source>The struct must only be &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt; if all the structural fields are &lt;code&gt;Unpin&lt;/code&gt;. This is the default, but &lt;code&gt;Unpin&lt;/code&gt; is a safe trait, so as the author of the struct it is your responsibility &lt;em&gt;not&lt;/em&gt; to add something like &lt;code&gt;impl&amp;lt;T&amp;gt; Unpin for Struct&amp;lt;T&amp;gt;&lt;/code&gt;. (Notice that adding a projection operation requires unsafe code, so the fact that &lt;code&gt;Unpin&lt;/code&gt; is a safe trait does not break the principle that you only have to worry about any of this if you use &lt;code&gt;unsafe&lt;/code&gt;.)</source>
          <target state="translated">構造体は、すべての構造フィールドが &lt;code&gt;Unpin&lt;/code&gt; の場合にのみ&lt;a href=&quot;../marker/trait.unpin&quot;&gt; &lt;code&gt;Unpin&lt;/code&gt; で&lt;/a&gt;なければなりません。これがデフォルトですが、 &lt;code&gt;Unpin&lt;/code&gt; 、あなたの責任ですので、構造体の著者として、安全な形質である&lt;em&gt;ではない&lt;/em&gt;ようなものを追加する &lt;code&gt;impl&amp;lt;T&amp;gt; Unpin for Struct&amp;lt;T&amp;gt;&lt;/code&gt; 。 （プロジェクション操作を追加するには安全でないコードが必要なので、 &lt;code&gt;Unpin&lt;/code&gt; が安全な特性であるという事実は、 &lt;code&gt;unsafe&lt;/code&gt; を使用する場合にのみこれについて心配する必要があるという原則を破ることはありません。）&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a32a0dfa31f0f0289e823ec593ac2d0e0186cb3f" translate="yes" xml:space="preserve">
          <source>The structure in the &lt;code&gt;vec!&lt;/code&gt; body is similar to the structure of a &lt;code&gt;match&lt;/code&gt; expression. Here we have one arm with the pattern &lt;code&gt;( $( $x:expr ),* )&lt;/code&gt;, followed by &lt;code&gt;=&amp;gt;&lt;/code&gt; and the block of code associated with this pattern. If the pattern matches, the associated block of code will be emitted. Given that this is the only pattern in this macro, there is only one valid way to match; any other pattern will result in an error. More complex macros will have more than one arm.</source>
          <target state="translated">&lt;code&gt;vec!&lt;/code&gt; の構造！bodyは、 &lt;code&gt;match&lt;/code&gt; 式の構造に似ています。ここには、パターン &lt;code&gt;( $( $x:expr ),* )&lt;/code&gt; 後に1つのアームがあり、その後に &lt;code&gt;=&amp;gt;&lt;/code&gt; とこのパターンに関連付けられたコードのブロックが続きます。パターンが一致すると、関連するコードブロックが発行されます。これがこのマクロの唯一のパターンであることを考えると、一致する有効な方法は1つしかありません。他のパターンはエラーになります。より複雑なマクロには複数のアームがあります。</target>
        </trans-unit>
        <trans-unit id="feedd74875f823ef27b80e0ba6fe89baf9a484a0" translate="yes" xml:space="preserve">
          <source>The structure of your public API is a major consideration when publishing a crate. People who use your crate are less familiar with the structure than you are and might have difficulty finding the pieces they want to use if your crate has a large module hierarchy.</source>
          <target state="translated">パブリック API の構造は、クレートを公開する際の大きな考慮事項です。あなたのクレートを使用する人は、あなたよりも構造に慣れていないため、クレートに大きなモジュール階層がある場合、使用するピースを見つけるのに苦労するかもしれません。</target>
        </trans-unit>
        <trans-unit id="8bdec152aa7987052184ceacfeaf61672bfbc336" translate="yes" xml:space="preserve">
          <source>The subtraction assignment operator &lt;code&gt;-=&lt;/code&gt;.</source>
          <target state="translated">減算代入演算子 &lt;code&gt;-=&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9df0e8a4e443e9ee7a165601e70a6b8ea73f8885" translate="yes" xml:space="preserve">
          <source>The subtraction operator &lt;code&gt;-&lt;/code&gt;.</source>
          <target state="translated">減算演算子 &lt;code&gt;-&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="28fd4d4d9eae938e322b4e3df0e6f419cbd1966d" translate="yes" xml:space="preserve">
          <source>The summary line displays at the end: overall, our test result is &lt;code&gt;FAILED&lt;/code&gt;. We had one test pass and one test fail.</source>
          <target state="translated">要約行が最後に表示されます。全体として、テスト結果は &lt;code&gt;FAILED&lt;/code&gt; です。テストは1回成功し、1回は失敗しました。</target>
        </trans-unit>
        <trans-unit id="ee42b5387704f2d9fe3e70d6349076680fb579e8" translate="yes" xml:space="preserve">
          <source>The supplied key may be any borrowed form of the map's key type, but &lt;a href=&quot;../../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; on the borrowed form &lt;em&gt;must&lt;/em&gt; match those for the key type.</source>
          <target state="translated">提供されるキーは、マップのキータイプの任意の借用形式にすることができますが、借用フォームの&lt;a href=&quot;../../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt;は、キータイプのそれらと一致する&lt;em&gt;必要があり&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="4d0db9da1f6030ddf936168ba198ea7e2ea2a8e7" translate="yes" xml:space="preserve">
          <source>The supplied key may be any borrowed form of the map's key type, but &lt;a href=&quot;../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; on the borrowed form &lt;em&gt;must&lt;/em&gt; match those for the key type.</source>
          <target state="translated">提供されるキーは、マップのキータイプの任意の借用形式にすることができますが、借用フォームの&lt;a href=&quot;../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt;は、キータイプのそれらと一致する&lt;em&gt;必要があり&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="6157ddf403c8a4c61dced75b578898d85ccde0c2" translate="yes" xml:space="preserve">
          <source>The supplied key may be any borrowed form of the map's key type, but the ordering on the borrowed form &lt;em&gt;must&lt;/em&gt; match the ordering on the key type.</source>
          <target state="translated">提供されるキーは、マップのキータイプの任意の借用形式にすることができますが、借用フォームの順序は、キータイプの順序と一致する&lt;em&gt;必要があり&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="9a3120ffbc7b98288aabd741823275a65245701a" translate="yes" xml:space="preserve">
          <source>The symbol &lt;code&gt;^C&lt;/code&gt; represents where you pressed ctrl-c . You may or may not see the word &lt;code&gt;again!&lt;/code&gt; printed after the &lt;code&gt;^C&lt;/code&gt;, depending on where the code was in the loop when it received the interrupt signal.</source>
          <target state="translated">記号 &lt;code&gt;^C&lt;/code&gt; は、ctrl-cを押した場所を表します。あなたは &lt;code&gt;again!&lt;/code&gt; その単語を見るかもしれないし、見ないかもしれません！割り込み信号を受信したときにコードがループのどこにあったかに応じて、 &lt;code&gt;^C&lt;/code&gt; 後に出力されます。</target>
        </trans-unit>
        <trans-unit id="266a6ae6e0b1b671aa6c8cd7616208233ffe3a4b" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;..&lt;/code&gt; will expand to as many values as it needs to be. Listing 18-24 shows how to use &lt;code&gt;..&lt;/code&gt; with a tuple.</source>
          <target state="translated">構文 &lt;code&gt;..&lt;/code&gt; は、必要な数の値に展開されます。リスト18-24はタプルで &lt;code&gt;..&lt;/code&gt; を使用する方法を示しています。</target>
        </trans-unit>
        <trans-unit id="79fc3d3c405b115d38b7334d712d4081f0801fc2" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;if let&lt;/code&gt; takes a pattern and an expression separated by an equal sign. It works the same way as a &lt;code&gt;match&lt;/code&gt;, where the expression is given to the &lt;code&gt;match&lt;/code&gt; and the pattern is its first arm.</source>
          <target state="translated">&lt;code&gt;if let&lt;/code&gt; の構文は、等号で区切られたパターンと式を取ります。これは &lt;code&gt;match&lt;/code&gt; と同じように機能します。ここで、表現は &lt;code&gt;match&lt;/code&gt; 与えられ、パターンはその最初のアームです。</target>
        </trans-unit>
        <trans-unit id="751b24fbac99aa6572c9e1b012dbbe4901f9dd78" translate="yes" xml:space="preserve">
          <source>The syntax and semantics for generators is unstable and will require a further RFC for stabilization. At this time, though, the syntax is closure-like:</source>
          <target state="translated">ジェネレータの構文とセマンティクスは不安定であり、安定化のためにさらなるRFCが必要になります。しかし、現時点では、構文はクロージャのようなものです。</target>
        </trans-unit>
        <trans-unit id="f94369f4bb8ebdf54603588e1760be815601c761" translate="yes" xml:space="preserve">
          <source>The syntax for the formatting language used is drawn from other languages, so it should not be too alien. Arguments are formatted with Python-like syntax, meaning that arguments are surrounded by &lt;code&gt;{}&lt;/code&gt; instead of the C-like &lt;code&gt;%&lt;/code&gt;. The actual grammar for the formatting syntax is:</source>
          <target state="translated">使用されるフォーマット言語の構文は他の言語から抽出されているため、あまり異質であってはなりません。引数はPythonのような構文でフォーマットされます。つまり、引数はCのような &lt;code&gt;%&lt;/code&gt; ではなく &lt;code&gt;{}&lt;/code&gt; で囲まれます。フォーマット構文の実際の文法は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="b1fb2c0dcb9e4f22d10669f04073e3418ad44567" translate="yes" xml:space="preserve">
          <source>The syntax for using generics in struct definitions is similar to that used in function definitions. First, we declare the name of the type parameter inside angle brackets just after the name of the struct. Then we can use the generic type in the struct definition where we would otherwise specify concrete data types.</source>
          <target state="translated">構造体定義でジェネリックを使用する構文は、関数定義で使用する構文に似ています。まず、構造体の名前の直後にある角括弧内で型パラメータの名前を宣言します。次に、構造体定義では、具体的なデータ型を指定しない場合には汎用型を使用できます。</target>
        </trans-unit>
        <trans-unit id="be667267584bb9b3dbb1d7d6c41e7cff90529baf" translate="yes" xml:space="preserve">
          <source>The syntax given to this macro is the same syntax as the &lt;a href=&quot;../reference/conditional-compilation#the-cfg-attribute&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">このマクロに与えられる構文は、&lt;a href=&quot;../reference/conditional-compilation#the-cfg-attribute&quot;&gt; &lt;code&gt;cfg&lt;/code&gt; &lt;/a&gt;属性と同じ構文です。</target>
        </trans-unit>
        <trans-unit id="37efe90a09f5adb20955a8d29f6006705ceea1f4" translate="yes" xml:space="preserve">
          <source>The syntax is &lt;code&gt;type Name = ExistingType;&lt;/code&gt;.</source>
          <target state="translated">構文は &lt;code&gt;type Name = ExistingType;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a952c08ff986f0fd0f90d2e270d99cd3e69c17a4" translate="yes" xml:space="preserve">
          <source>The syntax is the following: &lt;code&gt;dyn BaseTrait + AutoTrait1 + ... AutoTraitN&lt;/code&gt;. Only one &lt;code&gt;BaseTrait&lt;/code&gt; can be used so this will not compile:</source>
          <target state="translated">構文は次のとおりです &lt;code&gt;dyn BaseTrait + AutoTrait1 + ... AutoTraitN&lt;/code&gt; 。使用できる &lt;code&gt;BaseTrait&lt;/code&gt; は1つだけなので、これはコンパイルされません。</target>
        </trans-unit>
        <trans-unit id="4a5b87227107115d71da53fde65c7898c2f8a55f" translate="yes" xml:space="preserve">
          <source>The tail (elements in the vector after &lt;code&gt;range&lt;/code&gt;) is empty,</source>
          <target state="translated">尾（ &lt;code&gt;range&lt;/code&gt; 内のベクトルの要素）は空です。</target>
        </trans-unit>
        <trans-unit id="018e9509238447c67e6197a11d4f5ea0ec53b22e" translate="yes" xml:space="preserve">
          <source>The tail expression of &lt;a href=&quot;expressions/block-expr&quot;&gt;block expressions&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;expressions/block-expr&quot;&gt;ブロック式&lt;/a&gt;の尻尾式。</target>
        </trans-unit>
        <trans-unit id="73007ab480751859048a54c88693df26b24125bb" translate="yes" xml:space="preserve">
          <source>The task context refers to the &lt;a href=&quot;../../std/task/struct.context&quot;&gt;&lt;code&gt;Context&lt;/code&gt;&lt;/a&gt; which was supplied to the current &lt;a href=&quot;block-expr#async-context&quot;&gt;async context&lt;/a&gt; when the async context itself was polled. Because &lt;code&gt;await&lt;/code&gt; expressions are only legal in an async context, there must be some task context available.</source>
          <target state="translated">タスクコンテキストは、非同期コンテキスト自体がポーリングされたときに現在の&lt;a href=&quot;block-expr#async-context&quot;&gt;非同期コンテキスト&lt;/a&gt;に提供された&lt;a href=&quot;../../std/task/struct.context&quot;&gt; &lt;code&gt;Context&lt;/code&gt; &lt;/a&gt;を指します。 &lt;code&gt;await&lt;/code&gt; 式は非同期コンテキストでのみ有効であるため、使用可能なタスクコンテキストが必要です。</target>
        </trans-unit>
        <trans-unit id="8066bd3121283d3517acd4ab40b658c1a009321c" translate="yes" xml:space="preserve">
          <source>The temporary scopes for expressions in &lt;code&gt;let&lt;/code&gt; statements are sometimes &lt;em&gt;extended&lt;/em&gt; to the scope of the block containing the &lt;code&gt;let&lt;/code&gt; statement. This is done when the usual temporary scope would be too small, based on certain syntactic rules. For example:</source>
          <target state="translated">表現のための一時的なスコープ &lt;code&gt;let&lt;/code&gt; 文は時々されている&lt;em&gt;拡張&lt;/em&gt;含むブロックの範囲に &lt;code&gt;let&lt;/code&gt; 文を。これは、特定の構文規則に基づいて、通常の一時スコープが小さすぎる場合に実行されます。例えば：</target>
        </trans-unit>
        <trans-unit id="c615f1f00b080ca7312a1e8d344f8e1a91bfada3" translate="yes" xml:space="preserve">
          <source>The test shows that when we call &lt;code&gt;shoes_in_my_size&lt;/code&gt;, we get back only shoes that have the same size as the value we specified.</source>
          <target state="translated">このテストでは、 &lt;code&gt;shoes_in_my_size&lt;/code&gt; を呼び出すと、指定した値と同じサイズの靴のみが返されることが示されています。</target>
        </trans-unit>
        <trans-unit id="6d51660220a74ee89098ef8ef16d38d84170be2b" translate="yes" xml:space="preserve">
          <source>The text &lt;code&gt;Dropping CustomSmartPointer with data `some data`!&lt;/code&gt; is printed between the &lt;code&gt;CustomSmartPointer created.&lt;/code&gt; and &lt;code&gt;CustomSmartPointer dropped before the end of main.&lt;/code&gt; text, showing that the &lt;code&gt;drop&lt;/code&gt; method code is called to drop &lt;code&gt;c&lt;/code&gt; at that point.</source>
          <target state="translated">テキスト &lt;code&gt;Dropping CustomSmartPointer with data `some data`!&lt;/code&gt; &lt;code&gt;CustomSmartPointer created.&lt;/code&gt; されたCustomSmartPointerの間に印刷されます。また、 &lt;code&gt;CustomSmartPointer dropped before the end of main.&lt;/code&gt; テキスト、 &lt;code&gt;drop&lt;/code&gt; メソッドコードがその時点で &lt;code&gt;c&lt;/code&gt; をドロップするために呼び出されることを示します。</target>
        </trans-unit>
        <trans-unit id="c9d885657469b7761a884865d71e05fd15d67a2e" translate="yes" xml:space="preserve">
          <source>The text of this string is stored directly in the program&amp;rsquo;s binary, which is always available. Therefore, the lifetime of all string literals is &lt;code&gt;'static&lt;/code&gt;.</source>
          <target state="translated">この文字列のテキストは、常に利用可能なプログラムのバイナリに直接保存されます。したがって、すべての文字列リテラルの有効期間は &lt;code&gt;'static&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="a2418c922b0dbbb7a6749b73d736e8d2a5be9d0c" translate="yes" xml:space="preserve">
          <source>The third argument is a function called if a panic occurs. This function takes the data pointer and a pointer to the target-specific exception object that was caught. For more information see the compiler's source as well as std's catch implementation.</source>
          <target state="translated">第3引数は、パニックが発生した場合に呼び出される関数です。この関数は、データポインタとキャッチされたターゲット固有の例外オブジェクトへのポインタを取ります。詳細については、コンパイラのソースと std の catch の実装を参照してください。</target>
        </trans-unit>
        <trans-unit id="bb9a02cbbbeece965fc06bf102b3dfcc209b80a8" translate="yes" xml:space="preserve">
          <source>The third case is trickier: Rust will also coerce a mutable reference to an immutable one. But the reverse is &lt;em&gt;not&lt;/em&gt; possible: immutable references will never coerce to mutable references. Because of the borrowing rules, if you have a mutable reference, that mutable reference must be the only reference to that data (otherwise, the program wouldn&amp;rsquo;t compile). Converting one mutable reference to one immutable reference will never break the borrowing rules. Converting an immutable reference to a mutable reference would require that the initial immutable reference is the only immutable reference to that data, but the borrowing rules don&amp;rsquo;t guarantee that. Therefore, Rust can&amp;rsquo;t make the assumption that converting an immutable reference to a mutable reference is possible.</source>
          <target state="translated">3番目のケースはよりトリッキーです。Rustは不変の参照への可変の参照も強制します。ただし、その逆は不可能です。不変の参照が変更可能な参照に強制されることはあり&lt;em&gt;ません&lt;/em&gt;。借用規則により、可変参照がある場合は、その可変参照がそのデータへの唯一の参照である必要があります（そうでない場合、プログラムはコンパイルされません）。 1つの可変参照を1つの不変参照に変換しても、借用規則に違反することはありません。不変の参照を可変の参照に変換するには、最初の不変の参照がそのデータへの唯一の不変の参照である必要がありますが、借用規則はそれを保証しません。したがって、Rustは、不変の参照を可変の参照に変換できると想定することはできません。</target>
        </trans-unit>
        <trans-unit id="f9782d2dad9c654fee52ed918f0366cbe2abfa6a" translate="yes" xml:space="preserve">
          <source>The third case is trickier: Rust will also coerce a mutable reference to an immutable one. But the reverse is &lt;em&gt;not&lt;/em&gt; possible: immutable references will never coerce to mutable references. Because of the borrowing rules, if you have a mutable reference, that mutable reference must be the only reference to that data (otherwise, the program wouldn&amp;rsquo;t compile). Converting one mutable reference to one immutable reference will never break the borrowing rules. Converting an immutable reference to a mutable reference would require that there is only one immutable reference to that data, and the borrowing rules don&amp;rsquo;t guarantee that. Therefore, Rust can&amp;rsquo;t make the assumption that converting an immutable reference to a mutable reference is possible.</source>
          <target state="translated">3番目のケースはよりトリッキーです。Rustは、不変の参照への可変参照も強制します。ただし、その逆は不可能です。不変の参照が変更可能な参照に強制されることはあり&lt;em&gt;ません&lt;/em&gt;。借用規則のため、変更可能な参照がある場合、その変更可能な参照はそのデータへの唯一の参照でなければなりません（そうしないと、プログラムはコンパイルされません）。 1つの可変参照を1つの不変参照に変換しても、借用規則に違反することはありません。不変参照を変更可能な参照に変換するには、そのデータへの不変参照が1つだけ存在する必要があり、借用ルールはそれを保証しません。したがって、Rustは、不変の参照を変更可能な参照に変換することが可能であると想定できません。</target>
        </trans-unit>
        <trans-unit id="25bc1d6b7d2fd810584a49b63e54dae85fbc7654" translate="yes" xml:space="preserve">
          <source>The third invariant says that when we have a complex NT that can match two or more copies of the same thing with no separation in between, it must be permissible for them to be placed next to each other as per the first invariant. This invariant also requires they be nonempty, which eliminates a possible ambiguity.</source>
          <target state="translated">第三の不変量は、同じものの二つ以上のコピーを分離せずに一致させることができる複雑なNTを持つとき、第一の不変量のように、それらが隣り合って配置されることが許されなければならないと言うものである。この不変量はまた、それらが非空であることを要求するので、可能性のある曖昧さを排除します。</target>
        </trans-unit>
        <trans-unit id="6858985d6a527c37bd8cd37f82674daea04d146f" translate="yes" xml:space="preserve">
          <source>The third pointer is a target-specific data pointer which is filled in with the specifics of the exception that occurred. For examples on Unix platforms this is a &lt;code&gt;*mut *mut T&lt;/code&gt; which is filled in by the compiler and on MSVC it's &lt;code&gt;*mut [usize; 2]&lt;/code&gt;. For more information see the compiler's source as well as std's catch implementation.</source>
          <target state="translated">3番目のポインターはターゲット固有のデータポインターで、発生した例外の詳細が入力されます。 Unixプラットフォームの例では、これは &lt;code&gt;*mut *mut T&lt;/code&gt; であり、コンパイラーによって入力され、MSVCでは &lt;code&gt;*mut [usize; 2]&lt;/code&gt; 。詳細については、コンパイラのソースとstdのcatch実装を参照してください。</target>
        </trans-unit>
        <trans-unit id="af84a0e541b5cb8aad0df743eb686112ab5e9865" translate="yes" xml:space="preserve">
          <source>The third problem is that we&amp;rsquo;ve used &lt;code&gt;expect&lt;/code&gt; to print an error message when reading the file fails, but the error message just prints &lt;code&gt;Something went wrong reading the file&lt;/code&gt;. Reading a file can fail in a number of ways: for example, the file could be missing, or we might not have permission to open it. Right now, regardless of the situation, we&amp;rsquo;d print the &lt;code&gt;Something went wrong reading the file&lt;/code&gt; error message, which wouldn&amp;rsquo;t give the user any information!</source>
          <target state="translated">3番目の問題は、ファイルの読み取りが失敗したときにエラーメッセージを出力 &lt;code&gt;expect&lt;/code&gt; を期待していたのに、エラーメッセージが出力されるだけで &lt;code&gt;Something went wrong reading the file&lt;/code&gt; 。ファイルの読み取りは、いくつかの点で失敗する可能性があります。たとえば、ファイルが見つからない、またはファイルを開く権限がない可能性があります。現時点では、状況に関係なく &lt;code&gt;Something went wrong reading the file&lt;/code&gt; エラーメッセージの読み取りに問題が発生したため、ユーザーに情報を提供しませんでした。</target>
        </trans-unit>
        <trans-unit id="f9f5c0bd316756e98b375cf7ab85326d6fd86b72" translate="yes" xml:space="preserve">
          <source>The third rule is if there are multiple input lifetime parameters, but one of them is &lt;code&gt;&amp;amp;self&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self&lt;/code&gt; because this is a method, the lifetime of &lt;code&gt;self&lt;/code&gt; is assigned to all output lifetime parameters. This third rule makes methods much nicer to read and write because fewer symbols are necessary.</source>
          <target state="translated">3番目のルールは、複数の入力存続期間パラメーターがあるが、それらの1つが &lt;code&gt;&amp;amp;self&lt;/code&gt; または &lt;code&gt;&amp;amp;mut self&lt;/code&gt; である場合です。これはメソッドであるため、 &lt;code&gt;self&lt;/code&gt; の存続期間はすべての出力存続期間パラメーターに割り当てられます。この3番目のルールにより、必要なシンボルが少なくなるため、メソッドの読み取りと書き込みが大幅に改善されます。</target>
        </trans-unit>
        <trans-unit id="c69636ef08912707db1c3ff91b55a817a8ac72a9" translate="yes" xml:space="preserve">
          <source>The thread may sleep longer than the duration specified due to scheduling specifics or platform-dependent functionality. It will never sleep less.</source>
          <target state="translated">スレッドは、スケジューリングの仕様やプラットフォーム依存の機能のために、指定された期間よりも長くスリープすることがあります。スレッドのスリープ時間が短くなることはありません。</target>
        </trans-unit>
        <trans-unit id="cd58c0bda6dec6815740b7eed1b811cfbd96ccbb" translate="yes" xml:space="preserve">
          <source>The thread name is provided to the OS where applicable (e.g., &lt;code&gt;pthread_setname_np&lt;/code&gt; in unix-like platforms).</source>
          <target state="translated">スレッド名は、必要に &lt;code&gt;pthread_setname_np&lt;/code&gt; てOSに提供されます（たとえば、UNIXのようなプラットフォームではpthread_setname_np）。</target>
        </trans-unit>
        <trans-unit id="3218fca211a825167101461324b25d4344214224" translate="yes" xml:space="preserve">
          <source>The threading model</source>
          <target state="translated">スレッディングモデル</target>
        </trans-unit>
        <trans-unit id="2518c4f037fbaea8573cb319d8682ea0e18ad153" translate="yes" xml:space="preserve">
          <source>The three forms of iteration</source>
          <target state="translated">イテレーションの3つの形態</target>
        </trans-unit>
        <trans-unit id="6e441e5631d84f73392a981b4df2ae8555997336" translate="yes" xml:space="preserve">
          <source>The three kinds of procedural macros (custom derive, attribute-like, and function-like) all work in a similar fashion.</source>
          <target state="translated">3種類の手続き型マクロ(カスタム派生、属性的なもの、関数的なもの)は、すべて似たような方法で動作します。</target>
        </trans-unit>
        <trans-unit id="d7a7ac48a6db407723719df4ec95a88c69119a40" translate="yes" xml:space="preserve">
          <source>The three sections of output include the unit tests, the integration test, and the doc tests. The first section for the unit tests is the same as we&amp;rsquo;ve been seeing: one line for each unit test (one named &lt;code&gt;internal&lt;/code&gt; that we added in Listing 11-12) and then a summary line for the unit tests.</source>
          <target state="translated">出力の3つのセクションには、単体テスト、統合テスト、ドキュメントテストが含まれます。ユニットテストの最初のセクションは、これまで見てきたものと同じです。各ユニットテストの1行（リスト11-12で追加した &lt;code&gt;internal&lt;/code&gt; という名前の行）と、ユニットテストの概要行です。</target>
        </trans-unit>
        <trans-unit id="779ae776bee7c2504118b220c1641bc64af7f7ac" translate="yes" xml:space="preserve">
          <source>The time complexity degrades if elements are pushed in predominantly ascending order. In the worst case, elements are pushed in ascending sorted order and the amortized cost per push is &lt;em&gt;O&lt;/em&gt;(log(&lt;em&gt;n&lt;/em&gt;)) against a heap containing &lt;em&gt;n&lt;/em&gt; elements.</source>
          <target state="translated">要素が主に昇順でプッシュされると、時間計算量が低下します。最悪の場合、要素は昇順でプッシュされ、プッシュあたりの償却コストは、&lt;em&gt;n個の&lt;/em&gt;要素を含むヒープに対して&lt;em&gt;O&lt;/em&gt;（log（&lt;em&gt;n&lt;/em&gt;））です。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6df380516e9cdddf51f2d5d2da6e443a2e517824" translate="yes" xml:space="preserve">
          <source>The time complexity degrades if elements are pushed in predominantly ascending order. In the worst case, elements are pushed in ascending sorted order and the amortized cost per push is O(log n) against a heap containing &lt;em&gt;n&lt;/em&gt; elements.</source>
          <target state="translated">要素が主に昇順でプッシュされると、時間の複雑さが低下します。最悪の場合、要素は昇順でプッシュされ、&lt;em&gt;n&lt;/em&gt;要素を含むヒープに対するプッシュあたりの償却コストはO（log n）になります。</target>
        </trans-unit>
        <trans-unit id="95e46fd08ac08fd408281a4c8d24f1d26e9263c5" translate="yes" xml:space="preserve">
          <source>The to-be-stabilized version of this intrinsic is &lt;a href=&quot;../mem/fn.variant_count&quot;&gt;&lt;code&gt;mem::variant_count&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この組み込み関数の安定化されるバージョンは&lt;a href=&quot;../mem/fn.variant_count&quot;&gt; &lt;code&gt;mem::variant_count&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="7075cd0ebc9560a0210fd04b57fb94c1b2316eda" translate="yes" xml:space="preserve">
          <source>The tokens that can begin a type are, as of this writing, {&lt;code&gt;(&lt;/code&gt;, &lt;code&gt;[&lt;/code&gt;, &lt;code&gt;!&lt;/code&gt;, &lt;code&gt;\*&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt;, lifetimes, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;::&lt;/code&gt;, any non-keyword identifier, &lt;code&gt;super&lt;/code&gt;, &lt;code&gt;self&lt;/code&gt;, &lt;code&gt;Self&lt;/code&gt;, &lt;code&gt;extern&lt;/code&gt;, &lt;code&gt;crate&lt;/code&gt;, &lt;code&gt;$crate&lt;/code&gt;, &lt;code&gt;_&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;impl&lt;/code&gt;, &lt;code&gt;fn&lt;/code&gt;, &lt;code&gt;unsafe&lt;/code&gt;, &lt;code&gt;typeof&lt;/code&gt;, &lt;code&gt;dyn&lt;/code&gt;}, although this list may not be complete because people won't always remember to update the appendix when new ones are added.</source>
          <target state="translated">タイプを開始できるトークンは、これを書いている時点で、{ &lt;code&gt;(&lt;/code&gt; 、 &lt;code&gt;[&lt;/code&gt; 、 &lt;code&gt;!&lt;/code&gt; 、 &lt;code&gt;\*&lt;/code&gt; 、 &lt;code&gt;&amp;amp;&lt;/code&gt; 、 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 、 &lt;code&gt;?&lt;/code&gt; 、ライフタイム、 &lt;code&gt;&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 、 &lt;code&gt;::&lt;/code&gt; 、非キーワード識別子、 &lt;code&gt;super&lt;/code&gt; 、 &lt;code&gt;self&lt;/code&gt; 、 &lt;code&gt;Self&lt;/code&gt; 、 &lt;code&gt;extern&lt;/code&gt; 、 &lt;code&gt;crate&lt;/code&gt; 、 &lt;code&gt;$crate&lt;/code&gt; 、 &lt;code&gt;_&lt;/code&gt; 、 &lt;code&gt;for&lt;/code&gt; 、 &lt;code&gt;impl&lt;/code&gt; 、 &lt;code&gt;fn&lt;/code&gt; 、 &lt;code&gt;unsafe&lt;/code&gt; 、 &lt;code&gt;typeof&lt;/code&gt; 、 &lt;code&gt;dyn&lt;/code&gt; }ただし、新しいリストが追加されたときに付録を更新することを常に覚えているとは限らないため、このリストは完全ではない場合があります。</target>
        </trans-unit>
        <trans-unit id="3d918eb4366eadb0401bfe8b5fc6b1b9ce9e5b76" translate="yes" xml:space="preserve">
          <source>The top-level &lt;em&gt;Cargo.lock&lt;/em&gt; now contains information about the dependency of &lt;code&gt;add-one&lt;/code&gt; on &lt;code&gt;rand&lt;/code&gt;. However, even though &lt;code&gt;rand&lt;/code&gt; is used somewhere in the workspace, we can&amp;rsquo;t use it in other crates in the workspace unless we add &lt;code&gt;rand&lt;/code&gt; to their &lt;em&gt;Cargo.toml&lt;/em&gt; files as well. For example, if we add &lt;code&gt;use rand;&lt;/code&gt; to the &lt;em&gt;adder/src/main.rs&lt;/em&gt; file for the &lt;code&gt;adder&lt;/code&gt; crate, we&amp;rsquo;ll get an error:</source>
          <target state="translated">トップレベル&lt;em&gt;Cargo.lockは&lt;/em&gt;今の依存関係に関する情報が含まれている &lt;code&gt;add-one&lt;/code&gt; 上の &lt;code&gt;rand&lt;/code&gt; 。ただし、 &lt;code&gt;rand&lt;/code&gt; がワークスペースのどこかで使用されていても、&lt;em&gt;Cargo.toml&lt;/em&gt;ファイルに &lt;code&gt;rand&lt;/code&gt; を追加しない限り、ワークスペースの他のクレートでは使用できません。たとえば、 &lt;code&gt;use rand;&lt;/code&gt; を追加すると、&lt;em&gt;加算器/ SRC / main.rsの&lt;/em&gt;ためのファイル &lt;code&gt;adder&lt;/code&gt; クレート、我々はエラーになります：&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c0d4e33f5ea540060f03c5345b86c179052a0077" translate="yes" xml:space="preserve">
          <source>The top-level &lt;em&gt;Cargo.lock&lt;/em&gt; now contains information about the dependency of &lt;code&gt;add-one&lt;/code&gt; on &lt;code&gt;rand&lt;/code&gt;. However, even though &lt;code&gt;rand&lt;/code&gt; is used somewhere in the workspace, we can&amp;rsquo;t use it in other crates in the workspace unless we add &lt;code&gt;rand&lt;/code&gt; to their &lt;em&gt;Cargo.toml&lt;/em&gt; files as well. For example, if we add &lt;code&gt;use rand;&lt;/code&gt; to the &lt;em&gt;adder/src/main.rs&lt;/em&gt; file for the &lt;code&gt;adder&lt;/code&gt; package, we&amp;rsquo;ll get an error:</source>
          <target state="translated">トップレベルの&lt;em&gt;Cargo.lockに&lt;/em&gt;は、 &lt;code&gt;add-one&lt;/code&gt; の &lt;code&gt;rand&lt;/code&gt; への依存性に関する情報が含まれるようになりました。しかし、にもかかわらず、 &lt;code&gt;rand&lt;/code&gt; 、ワークスペース内の使用済みのどこかである、我々は追加しない限り、ワークスペース内の他の木箱でそれを使用することはできません &lt;code&gt;rand&lt;/code&gt; 自分に&lt;em&gt;Cargo.tomlの&lt;/em&gt;ファイルにも。たとえば、 &lt;code&gt;use rand;&lt;/code&gt; を追加すると、 &lt;code&gt;adder&lt;/code&gt; パッケージの&lt;em&gt;adder / src / main.rs&lt;/em&gt;ファイルに、次のエラーが表示されます。</target>
        </trans-unit>
        <trans-unit id="ad3286fb14b7fd80e70223a9fcdf3dbb91a27203" translate="yes" xml:space="preserve">
          <source>The total size &lt;code&gt;len * mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; of the slice must be no larger than &lt;code&gt;isize::MAX&lt;/code&gt;. See the safety documentation of &lt;a href=&quot;../primitive.pointer#method.offset&quot;&gt;&lt;code&gt;pointer::offset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">スライスの合計サイズ &lt;code&gt;len * mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; は、 &lt;code&gt;isize::MAX&lt;/code&gt; より大きくてはなりません。&lt;a href=&quot;../primitive.pointer#method.offset&quot;&gt; &lt;code&gt;pointer::offset&lt;/code&gt; &lt;/a&gt;安全文書を参照してください。</target>
        </trans-unit>
        <trans-unit id="cb4d3d21f95395d566b73337877fe60f19b91950" translate="yes" xml:space="preserve">
          <source>The total size &lt;code&gt;ptr.len() * mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; of the slice must be no larger than &lt;code&gt;isize::MAX&lt;/code&gt;. See the safety documentation of &lt;a href=&quot;../primitive.pointer#method.offset&quot;&gt;&lt;code&gt;pointer::offset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ptr.len() * mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; の合計サイズptr.len（）* mem :: size_of :: &amp;lt;T&amp;gt;（）は、 &lt;code&gt;isize::MAX&lt;/code&gt; より大きくてはなりません。&lt;a href=&quot;../primitive.pointer#method.offset&quot;&gt; &lt;code&gt;pointer::offset&lt;/code&gt; &lt;/a&gt;安全文書を参照してください。</target>
        </trans-unit>
        <trans-unit id="f198377d0780cd2ae0fe23c39d58fa6a11c3ce1b" translate="yes" xml:space="preserve">
          <source>The total size &lt;code&gt;ptr.len() * mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; of the slice must be no larger than &lt;code&gt;isize::MAX&lt;/code&gt;. See the safety documentation of &lt;a href=&quot;primitive.pointer#method.offset&quot;&gt;&lt;code&gt;pointer::offset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ptr.len() * mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; の合計サイズptr.len（）* mem :: size_of :: &amp;lt;T&amp;gt;（）は、 &lt;code&gt;isize::MAX&lt;/code&gt; より大きくてはなりません。&lt;a href=&quot;primitive.pointer#method.offset&quot;&gt; &lt;code&gt;pointer::offset&lt;/code&gt; &lt;/a&gt;安全文書を参照してください。</target>
        </trans-unit>
        <trans-unit id="8c818e1dc9d477cbb1ce03a32e397d907f841e91" translate="yes" xml:space="preserve">
          <source>The total size of the slice must be no larger than &lt;code&gt;isize::MAX&lt;/code&gt;&lt;strong&gt;bytes&lt;/strong&gt; in memory. See the safety documentation of &lt;a href=&quot;../primitive.pointer#method.offset&quot;&gt;&lt;code&gt;pointer::offset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">スライスの合計サイズは、メモリ内の &lt;code&gt;isize::MAX&lt;/code&gt; &lt;strong&gt;バイト&lt;/strong&gt;以下でなければなりません。&lt;a href=&quot;../primitive.pointer#method.offset&quot;&gt; &lt;code&gt;pointer::offset&lt;/code&gt; &lt;/a&gt;安全性に関するドキュメントをご覧ください。</target>
        </trans-unit>
        <trans-unit id="4da1db74e1e609ac8cd961cdfb0fa46bfc3d2c9d" translate="yes" xml:space="preserve">
          <source>The trait also provides convenience methods like &lt;a href=&quot;#method.write_all&quot;&gt;&lt;code&gt;write_all&lt;/code&gt;&lt;/a&gt;, which calls &lt;code&gt;write&lt;/code&gt; in a loop until its entire input has been written.</source>
          <target state="translated">トレイトには、&lt;a href=&quot;#method.write_all&quot;&gt; &lt;code&gt;write_all&lt;/code&gt; &lt;/a&gt;などの便利なメソッドも用意されています。このメソッドは、入力全体が書き込まれるまでループ内で &lt;code&gt;write&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="903fc77fd3444aa853b4918c8904a108213ce8a6" translate="yes" xml:space="preserve">
          <source>The trait also provides convenience methods like &lt;a href=&quot;trait.write#method.write_all&quot;&gt;&lt;code&gt;write_all&lt;/code&gt;&lt;/a&gt;, which calls &lt;code&gt;write&lt;/code&gt; in a loop until its entire input has been written.</source>
          <target state="translated">このトレイトは、入力全体が書き込まれるまでループで &lt;code&gt;write&lt;/code&gt; を呼び出す&lt;a href=&quot;trait.write#method.write_all&quot;&gt; &lt;code&gt;write_all&lt;/code&gt; の&lt;/a&gt;ような便利なメソッドも提供します。</target>
        </trans-unit>
        <trans-unit id="ddef280ba8303b75d43b99adadcdec8f8b461c8f" translate="yes" xml:space="preserve">
          <source>The trait being implemented is defined in the same crate.</source>
          <target state="translated">実装されている形質は同じ木箱に定義されています。</target>
        </trans-unit>
        <trans-unit id="fe160012593c71ba4d94a64501b55cb584b3c84d" translate="yes" xml:space="preserve">
          <source>The trait cannot contain associated constants</source>
          <target state="translated">形質は、関連する定数を含むことはできません。</target>
        </trans-unit>
        <trans-unit id="f49c4617e26c7a90e7ceb5715737675232c71e5c" translate="yes" xml:space="preserve">
          <source>The trait cannot require &lt;code&gt;Self: Sized&lt;/code&gt;</source>
          <target state="translated">トレイトは &lt;code&gt;Self: Sized&lt;/code&gt; 必要としません：サイズ</target>
        </trans-unit>
        <trans-unit id="3bbcc07233474a5558580dca4726567afce0f2c1" translate="yes" xml:space="preserve">
          <source>The trait cannot use &lt;code&gt;Self&lt;/code&gt; as a type parameter in the supertrait listing</source>
          <target state="translated">トレイトは、スーパートレイトリストのタイプパラメータとして &lt;code&gt;Self&lt;/code&gt; を使用できません</target>
        </trans-unit>
        <trans-unit id="6c46ccc8f602f9dc98f8190aa7e9cb78c7a8a015" translate="yes" xml:space="preserve">
          <source>The trait implemented by builtin generator types.</source>
          <target state="translated">ビルトインジェネレーター型で実装されている形質。</target>
        </trans-unit>
        <trans-unit id="0c6838569af8d3e59a65e8aec127e2d3a1e1e919" translate="yes" xml:space="preserve">
          <source>The trait is known as the &lt;em&gt;implemented trait&lt;/em&gt;. The implementing type implements the implemented trait.</source>
          <target state="translated">トレイトは&lt;em&gt;実装されたトレイト&lt;/em&gt;として知られてい&lt;em&gt;ます&lt;/em&gt;。実装タイプは実装された特性を実装します。</target>
        </trans-unit>
        <trans-unit id="8cf3ab6548fb883dab5c1d88de8c77fdb3ccf054" translate="yes" xml:space="preserve">
          <source>The trait is marked unsafe because the indices returned by the &lt;a href=&quot;trait.searcher#tymethod.next&quot;&gt;&lt;code&gt;next()&lt;/code&gt;&lt;/a&gt; methods are required to lie on valid utf8 boundaries in the haystack. This enables consumers of this trait to slice the haystack without additional runtime checks.</source>
          <target state="translated">&lt;a href=&quot;trait.searcher#tymethod.next&quot;&gt; &lt;code&gt;next()&lt;/code&gt; &lt;/a&gt;メソッドによって返されるインデックスは、干し草の山の有効なutf8境界上にある必要があるため、この特性は安全でないとマークされます。これにより、このトレイトのコンシューマーは、追加のランタイムチェックなしで干し草の山をスライスできます。</target>
        </trans-unit>
        <trans-unit id="478884f7bada94b695fbee645bd59c060678235f" translate="yes" xml:space="preserve">
          <source>The trait is marked unsafe because the indices returned by the &lt;code&gt;next()&lt;/code&gt; methods are required to lie on valid utf8 boundaries in the haystack. This enables consumers of this trait to slice the haystack without additional runtime checks.</source>
          <target state="translated">&lt;code&gt;next()&lt;/code&gt; メソッドによって返されるインデックスは、干し草の有効なutf8境界上にある必要があるため、この特性は安全でないとマークされています。これにより、このトレイトのコンシューマーは、ランタイムチェックを追加せずに干し草の山をスライスできます。</target>
        </trans-unit>
        <trans-unit id="6d63a097c314f3198ade51464ed8a948cd1d46d3" translate="yes" xml:space="preserve">
          <source>The trait is marked unsafe in order to restrict implementors to fixed-size arrays. User of this trait can assume that implementors have the exact layout in memory of a fixed size array (for example, for unsafe initialization).</source>
          <target state="translated">この特性は,実装者を固定サイズの配列に限定するために,安全ではないとマークされています.この特性のユーザは、実装者が固定サイズの配列のメモリ上に正確なレイアウトを持っていると仮定することができます (例えば、安全ではない初期化のために)。</target>
        </trans-unit>
        <trans-unit id="6234c814e87094f91726f24487a4768fa303bb49" translate="yes" xml:space="preserve">
          <source>The trait is unsafe because implementers must uphold additional safety properties. See &lt;a href=&quot;trait.sourceiter#tymethod.as_inner&quot;&gt;&lt;code&gt;as_inner&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">実装者は追加の安全特性を維持する必要があるため、この特性は安全ではありません。詳細については、&lt;a href=&quot;trait.sourceiter#tymethod.as_inner&quot;&gt; &lt;code&gt;as_inner&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="ffd4884c0b4bf389a086599eb28e009d3c721bad" translate="yes" xml:space="preserve">
          <source>The trait itself acts as a builder for an associated &lt;a href=&quot;trait.searcher&quot;&gt;&lt;code&gt;Searcher&lt;/code&gt;&lt;/a&gt; type, which does the actual work of finding occurrences of the pattern in a string.</source>
          <target state="translated">トレイト自体は、関連付けられた&lt;a href=&quot;trait.searcher&quot;&gt; &lt;code&gt;Searcher&lt;/code&gt; &lt;/a&gt;タイプのビルダーとして機能し、文字列内のパターンの出現を見つける実際の作業を行います。</target>
        </trans-unit>
        <trans-unit id="bf58bfdb142c3e3e2fca00b9412242993f764d14" translate="yes" xml:space="preserve">
          <source>The trait itself acts as a builder for an associated &lt;code&gt;Searcher&lt;/code&gt; type, which does the actual work of finding occurrences of the pattern in a string.</source>
          <target state="translated">トレイト自体は、関連付けられた &lt;code&gt;Searcher&lt;/code&gt; タイプのビルダーとして機能し、文字列内のパターンの出現を見つける実際の作業を行います。</target>
        </trans-unit>
        <trans-unit id="4f44d782a6ca223ce6d84156fccfcf74f2f98110" translate="yes" xml:space="preserve">
          <source>The trait with a supertrait is called a &lt;strong&gt;subtrait&lt;/strong&gt; of its supertrait.</source>
          <target state="translated">スーパー特性を持つ特性は、そのスーパー&lt;strong&gt;特性のサブ&lt;/strong&gt;特性と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="d7357f4482763332c4dcdb5f743346a154d2e9c6" translate="yes" xml:space="preserve">
          <source>The traits in &lt;a href=&quot;../std/ops/index&quot;&gt;&lt;code&gt;std::ops&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../std/cmp/index&quot;&gt;&lt;code&gt;std::cmp&lt;/code&gt;&lt;/a&gt; are used to overload &lt;a href=&quot;expressions/operator-expr&quot;&gt;operators&lt;/a&gt;, &lt;a href=&quot;expressions/array-expr#array-and-slice-indexing-expressions&quot;&gt;indexing expressions&lt;/a&gt; and &lt;a href=&quot;expressions/call-expr&quot;&gt;call expressions&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../std/ops/index&quot;&gt; &lt;code&gt;std::ops&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../std/cmp/index&quot;&gt; &lt;code&gt;std::cmp&lt;/code&gt; &lt;/a&gt;の特性は、&lt;a href=&quot;expressions/operator-expr&quot;&gt;演算子&lt;/a&gt;、&lt;a href=&quot;expressions/array-expr#array-and-slice-indexing-expressions&quot;&gt;インデックス式&lt;/a&gt;、&lt;a href=&quot;expressions/call-expr&quot;&gt;呼び出し式の&lt;/a&gt;オーバーロードに使用されます。</target>
        </trans-unit>
        <trans-unit id="9ada4715a52a3666c1e6ea1e317fd6cc2974a5b0" translate="yes" xml:space="preserve">
          <source>The traits in &lt;a href=&quot;../std/ops/index&quot;&gt;&lt;code&gt;std::ops&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../std/cmp/index&quot;&gt;&lt;code&gt;std::cmp&lt;/code&gt;&lt;/a&gt; are used to overload &lt;a href=&quot;expressions/operator-expr&quot;&gt;operators&lt;/a&gt;, &lt;a href=&quot;expressions/array-expr#array-and-slice-indexing-expressions&quot;&gt;indexing expressions&lt;/a&gt;, and &lt;a href=&quot;expressions/call-expr&quot;&gt;call expressions&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../std/ops/index&quot;&gt; &lt;code&gt;std::ops&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;../std/cmp/index&quot;&gt; &lt;code&gt;std::cmp&lt;/code&gt; &lt;/a&gt;の特性は、&lt;a href=&quot;expressions/operator-expr&quot;&gt;演算子の&lt;/a&gt;オーバーロード、&lt;a href=&quot;expressions/array-expr#array-and-slice-indexing-expressions&quot;&gt;式のインデックス作成&lt;/a&gt;、および&lt;a href=&quot;expressions/call-expr&quot;&gt;式の呼び出しに&lt;/a&gt;使用されます。</target>
        </trans-unit>
        <trans-unit id="f43292c5d9ba5055790b8cc673c3ce1d90efd4b3" translate="yes" xml:space="preserve">
          <source>The traits in this module are often used as trait bounds for generic functions such that to arguments of multiple types are supported. See the documentation of each trait for examples.</source>
          <target state="translated">このモジュールの形質は、複数の型の引数への引数をサポートするような汎用関数の形質境界としてよく使用されます。例については、それぞれの特徴のドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="bbf2160d65d5756f9a6fd20c174d5b77d26006ee" translate="yes" xml:space="preserve">
          <source>The traits in this module provide a way to convert from one type to another type. Each trait serves a different purpose:</source>
          <target state="translated">このモジュールの形質は、あるタイプから別のタイプに変換する方法を提供します。それぞれの形質は異なる目的を果たします。</target>
        </trans-unit>
        <trans-unit id="be87d5e421f146f48239b20f0b61521f853fc415" translate="yes" xml:space="preserve">
          <source>The transmitting end has a &lt;code&gt;send&lt;/code&gt; method that takes the value we want to send. The &lt;code&gt;send&lt;/code&gt; method returns a &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; type, so if the receiving end has already been dropped and there&amp;rsquo;s nowhere to send a value, the send operation will return an error. In this example, we&amp;rsquo;re calling &lt;code&gt;unwrap&lt;/code&gt; to panic in case of an error. But in a real application, we would handle it properly: return to Chapter 9 to review strategies for proper error handling.</source>
          <target state="translated">送信側には、 &lt;code&gt;send&lt;/code&gt; する値を受け取るsendメソッドがあります。 &lt;code&gt;send&lt;/code&gt; メソッドが戻ると &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 種類、受信側がすでに削除されて、値を送信するためにどこにもありませんしているそうだとすれば、送信操作はエラーを返します。この例では、エラーが発生した場合にパニックを &lt;code&gt;unwrap&lt;/code&gt; するためにunwrapを呼び出しています。しかし、実際のアプリケーションでは、適切に処理します。第9章に戻って、適切なエラー処理の戦略を確認してください。</target>
        </trans-unit>
        <trans-unit id="358565a5dd8811594d3e7971e93dfbda2791693b" translate="yes" xml:space="preserve">
          <source>The tuple pattern is refutable when one of its subpatterns is refutable.</source>
          <target state="translated">タプルパターンは、そのサブパターンの1つが反論可能な場合に反論可能となります。</target>
        </trans-unit>
        <trans-unit id="8b3273a21950fc06ce8b8962828961e34d0be457" translate="yes" xml:space="preserve">
          <source>The two are compared by calling &lt;code&gt;&amp;gt;&lt;/code&gt; on their inner values.</source>
          <target state="translated">2つは、それらの内部値に対して &lt;code&gt;&amp;gt;&lt;/code&gt; を呼び出すことによって比較されます。</target>
        </trans-unit>
        <trans-unit id="de2c6ddac182efa31cffea571db9b44146fe9838" translate="yes" xml:space="preserve">
          <source>The two are compared by calling &lt;code&gt;&amp;gt;=&lt;/code&gt; on their inner values.</source>
          <target state="translated">2つは、それらの内部値で &lt;code&gt;&amp;gt;=&lt;/code&gt; を呼び出すことによって比較されます。</target>
        </trans-unit>
        <trans-unit id="9c699eaaa968f03f7073bd19cfb4a4bc4c553e9a" translate="yes" xml:space="preserve">
          <source>The two are compared by calling &lt;code&gt;&amp;lt;&lt;/code&gt; on their inner values.</source>
          <target state="translated">2つは、その内部値で &lt;code&gt;&amp;lt;&lt;/code&gt; を呼び出すことによって比較されます。</target>
        </trans-unit>
        <trans-unit id="169dd7de97da6fed33fb4c7fffa1d0926634fd12" translate="yes" xml:space="preserve">
          <source>The two are compared by calling &lt;code&gt;&amp;lt;=&lt;/code&gt; on their inner values.</source>
          <target state="translated">2つは、それらの内部値に対して &lt;code&gt;&amp;lt;=&lt;/code&gt; を呼び出すことによって比較されます。</target>
        </trans-unit>
        <trans-unit id="4559f811138e10e2014d510114ff2517b250941f" translate="yes" xml:space="preserve">
          <source>The two are compared by calling &lt;code&gt;cmp()&lt;/code&gt; on their inner values.</source>
          <target state="translated">2つは、それらの内部値に対して &lt;code&gt;cmp()&lt;/code&gt; を呼び出すことによって比較されます。</target>
        </trans-unit>
        <trans-unit id="39163b76dc0823f8bfd4c0f4a8969c804a3f8075" translate="yes" xml:space="preserve">
          <source>The two are compared by calling &lt;code&gt;partial_cmp()&lt;/code&gt; on their inner values.</source>
          <target state="translated">2つは、それらの内部値に対して &lt;code&gt;partial_cmp()&lt;/code&gt; を呼び出すことによって比較されます。</target>
        </trans-unit>
        <trans-unit id="a9f918beee4f5cf9d1253c5c05628d38cf96954a" translate="yes" xml:space="preserve">
          <source>The two configurations available are:</source>
          <target state="translated">利用可能な2つの構成があります。</target>
        </trans-unit>
        <trans-unit id="450583e125671dcb6a167d6b29518dd2bf3867fb" translate="yes" xml:space="preserve">
          <source>The two kinds of declaration statements are item declarations and &lt;code&gt;let&lt;/code&gt; statements.</source>
          <target state="translated">2種類の宣言ステートメントは、アイテム宣言と &lt;code&gt;let&lt;/code&gt; ステートメントです。</target>
        </trans-unit>
        <trans-unit id="29e11129b6c15c504dcd359f5946098de2a818e8" translate="yes" xml:space="preserve">
          <source>The two main protocols involved in web servers are the &lt;em&gt;Hypertext Transfer Protocol&lt;/em&gt;&lt;em&gt;(HTTP)&lt;/em&gt; and the &lt;em&gt;Transmission Control Protocol&lt;/em&gt;&lt;em&gt;(TCP)&lt;/em&gt;. Both protocols are &lt;em&gt;request-response&lt;/em&gt; protocols, meaning a &lt;em&gt;client&lt;/em&gt; initiates requests and a &lt;em&gt;server&lt;/em&gt; listens to the requests and provides a response to the client. The contents of those requests and responses are defined by the protocols.</source>
          <target state="translated">Webサーバーに含まれる2つの主なプロトコルは、&lt;em&gt;ハイパーテキスト転送プロトコル&lt;/em&gt;&lt;em&gt;（HTTP）&lt;/em&gt;と&lt;em&gt;伝送制御プロトコル&lt;/em&gt;&lt;em&gt;（TCP）&lt;/em&gt;です。どちらのプロトコルも&lt;em&gt;要求/応答&lt;/em&gt;プロトコルです。つまり、&lt;em&gt;クライアント&lt;/em&gt;が要求を開始し、&lt;em&gt;サーバー&lt;/em&gt;が要求をリッスンしてクライアントに応答を提供します。これらの要求と応答の内容は、プロトコルによって定義されます。</target>
        </trans-unit>
        <trans-unit id="203df10027d062d490c4fbf35780fe4d1eed13fd" translate="yes" xml:space="preserve">
          <source>The two most common ways to evaluate an iterator are to use a &lt;code&gt;for&lt;/code&gt; loop like this, or using the &lt;a href=&quot;trait.iterator#method.collect&quot;&gt;&lt;code&gt;collect&lt;/code&gt;&lt;/a&gt; method to produce a new collection.</source>
          <target state="translated">イテレータを評価する最も一般的な2つの方法は、このような &lt;code&gt;for&lt;/code&gt; ループを使用するか、&lt;a href=&quot;trait.iterator#method.collect&quot;&gt; &lt;code&gt;collect&lt;/code&gt; &lt;/a&gt;メソッドを使用して新しいコレクションを作成することです。</target>
        </trans-unit>
        <trans-unit id="f0616989ceb9af09d65c6d30395a15645c3fb4ed" translate="yes" xml:space="preserve">
          <source>The two new lines are:</source>
          <target state="translated">新たに加わった2つの路線は</target>
        </trans-unit>
        <trans-unit id="e483fee205c9c53971b14b5a333e04a44a6db99b" translate="yes" xml:space="preserve">
          <source>The two pointed-to values may overlap. If the values do overlap, then the overlapping region of memory from &lt;code&gt;x&lt;/code&gt; will be used. This is demonstrated in the second example below.</source>
          <target state="translated">2つのポイントされた値が重複する場合があります。値が重複する場合、 &lt;code&gt;x&lt;/code&gt; からのメモリの重複領域が使用されます。これは、下の2番目の例で示されています。</target>
        </trans-unit>
        <trans-unit id="7540e3538a7ee2b354c6ad5eceba51e063d25c18" translate="yes" xml:space="preserve">
          <source>The two slices returned go from the start of the string slice to &lt;code&gt;mid&lt;/code&gt;, and from &lt;code&gt;mid&lt;/code&gt; to the end of the string slice.</source>
          <target state="translated">返される2つのスライスは、文字列スライスの先頭から &lt;code&gt;mid&lt;/code&gt; まで、および &lt;code&gt;mid&lt;/code&gt; から文字列スライスの最後までです。</target>
        </trans-unit>
        <trans-unit id="643186e43b6d06589052d125f62e5365b9c9a558" translate="yes" xml:space="preserve">
          <source>The two threads continue alternating, but the main thread waits because of the call to &lt;code&gt;handle.join()&lt;/code&gt; and does not end until the spawned thread is finished.</source>
          <target state="translated">2つのスレッドは交互に継続しますが、メインスレッドは &lt;code&gt;handle.join()&lt;/code&gt; の呼び出しのために待機し、生成されたスレッドが終了するまで終了しません。</target>
        </trans-unit>
        <trans-unit id="6005b5c0e8b9fae85cf0f2f496cddef96188c2e3" translate="yes" xml:space="preserve">
          <source>The two values of the boolean type are written &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">ブール型の2つの値は、 &lt;code&gt;true&lt;/code&gt; と &lt;code&gt;false&lt;/code&gt; に書き込まれます。</target>
        </trans-unit>
        <trans-unit id="8b6bd47b4f42af9e321626a41d3ac1a949889256" translate="yes" xml:space="preserve">
          <source>The type &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; provides shared ownership of a value of type &lt;code&gt;T&lt;/code&gt;, allocated in the heap. Invoking &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; on &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; produces a new pointer to the same allocation in the heap. When the last &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointer to a given allocation is destroyed, the value stored in that allocation (often referred to as &quot;inner value&quot;) is also dropped.</source>
          <target state="translated">タイプ&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;は、ヒープに割り当てられたタイプ &lt;code&gt;T&lt;/code&gt; の値の共有所有権を提供します。&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; で&lt;/a&gt;&lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt;を呼び出すと、ヒープ内の同じ割り当てへの新しいポインターが生成されます。特定の割り当てへの最後の&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt;ポインタが破棄されると、その割り当てに格納されている値（「内部値」と呼ばれることが多い）も削除されます。</target>
        </trans-unit>
        <trans-unit id="372e682a79086a952e254015d9198d707b3497b2" translate="yes" xml:space="preserve">
          <source>The type &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; provides shared ownership of a value of type &lt;code&gt;T&lt;/code&gt;, allocated in the heap. Invoking &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; on &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; produces a new pointer to the same value in the heap. When the last &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointer to a given value is destroyed, the pointed-to value is also destroyed.</source>
          <target state="translated">型&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;は、ヒープに割り当てられた型 &lt;code&gt;T&lt;/code&gt; の値の共有所有権を提供します。&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; で&lt;/a&gt;&lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt;を呼び出すと、ヒープ内の同じ値への新しいポインターが生成されます。指定された値への最後の&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt;ポインターが破棄されると、ポイントされた値も破棄されます。</target>
        </trans-unit>
        <trans-unit id="061bd0bf671c2d672c454254d90151c86753f8be" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; provides shared ownership of a value of type &lt;code&gt;T&lt;/code&gt;, allocated in the heap. Invoking &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; on &lt;code&gt;Arc&lt;/code&gt; produces a new &lt;code&gt;Arc&lt;/code&gt; instance, which points to the same allocation on the heap as the source &lt;code&gt;Arc&lt;/code&gt;, while increasing a reference count. When the last &lt;code&gt;Arc&lt;/code&gt; pointer to a given allocation is destroyed, the value stored in that allocation (often referred to as &quot;inner value&quot;) is also dropped.</source>
          <target state="translated">タイプ &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; は、ヒープに割り当てられたタイプ &lt;code&gt;T&lt;/code&gt; の値の共有所有権を提供します。 &lt;code&gt;Arc&lt;/code&gt; で&lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt;を呼び出すと、新しい &lt;code&gt;Arc&lt;/code&gt; インスタンスが生成されます。これは、参照カウントを増やしながら、ソース &lt;code&gt;Arc&lt;/code&gt; と同じヒープ上の割り当てを指します。特定の割り当てへの最後の &lt;code&gt;Arc&lt;/code&gt; ポインターが破棄されると、その割り当てに格納されている値（「内部値」と呼ばれることが多い）も削除されます。</target>
        </trans-unit>
        <trans-unit id="6e13391af6d4685735ce2468fa0b2df950149996" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; provides shared ownership of a value of type &lt;code&gt;T&lt;/code&gt;, allocated in the heap. Invoking &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; on &lt;code&gt;Arc&lt;/code&gt; produces a new &lt;code&gt;Arc&lt;/code&gt; instance, which points to the same value on the heap as the source &lt;code&gt;Arc&lt;/code&gt;, while increasing a reference count. When the last &lt;code&gt;Arc&lt;/code&gt; pointer to a given value is destroyed, the pointed-to value is also destroyed.</source>
          <target state="translated">タイプ &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; は、ヒープに割り当てられたタイプ &lt;code&gt;T&lt;/code&gt; の値の共有所有権を提供します。 &lt;code&gt;Arc&lt;/code&gt; で&lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt;を呼び出すと、新しい &lt;code&gt;Arc&lt;/code&gt; インスタンスが生成されます。これは、参照カウントを増やしながら、ヒープ上のソース &lt;code&gt;Arc&lt;/code&gt; と同じ値を指します。指定された値への最後の &lt;code&gt;Arc&lt;/code&gt; ポインターが破棄されると、ポイントされた値も破棄されます。</target>
        </trans-unit>
        <trans-unit id="c30f5ce28986d51c472e8b2cb793889a1cf9299e" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Cow&lt;/code&gt; is a smart pointer providing clone-on-write functionality: it can enclose and provide immutable access to borrowed data, and clone the data lazily when mutation or ownership is required. The type is designed to work with general borrowed data via the &lt;code&gt;Borrow&lt;/code&gt; trait.</source>
          <target state="translated">タイプ &lt;code&gt;Cow&lt;/code&gt; は、クローンオンライト機能を提供するスマートポインターです。借用データを囲み、不変のアクセスを提供し、ミューテーションまたは所有権が必要な場合にデータをレイジーにクローンできます。タイプは、 &lt;code&gt;Borrow&lt;/code&gt; トレイトを介して一般的な借用データを処理するように設計されています。</target>
        </trans-unit>
        <trans-unit id="9f7d7514bdc86a24a5ff52dd05fe5c13a9b5c0e6" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Item&lt;/code&gt; is a placeholder type, and the &lt;code&gt;next&lt;/code&gt; method&amp;rsquo;s definition shows that it will return values of type &lt;code&gt;Option&amp;lt;Self::Item&amp;gt;&lt;/code&gt;. Implementors of the &lt;code&gt;Iterator&lt;/code&gt; trait will specify the concrete type for &lt;code&gt;Item&lt;/code&gt;, and the &lt;code&gt;next&lt;/code&gt; method will return an &lt;code&gt;Option&lt;/code&gt; containing a value of that concrete type.</source>
          <target state="translated">タイプ &lt;code&gt;Item&lt;/code&gt; はプレースホルダータイプであり、 &lt;code&gt;next&lt;/code&gt; メソッドの定義は、タイプ &lt;code&gt;Option&amp;lt;Self::Item&amp;gt;&lt;/code&gt; 値を返すことを示しています。 &lt;code&gt;Iterator&lt;/code&gt; トレイトの実装者は &lt;code&gt;Item&lt;/code&gt; の具象タイプを指定し、 &lt;code&gt;next&lt;/code&gt; メソッドはその具象タイプの値を含む &lt;code&gt;Option&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="b50c152c5140d221fbe925adaec14a20d6c4527c" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Self&lt;/code&gt; acts as an alias to the type of the current trait implementer, or &quot;receiver type&quot;. Besides the already mentioned &lt;code&gt;Self&lt;/code&gt;, &lt;code&gt;&amp;amp;Self&lt;/code&gt; and &lt;code&gt;&amp;amp;mut Self&lt;/code&gt; valid receiver types, the following are also valid: &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt;, &lt;code&gt;self: Rc&amp;lt;Self&amp;gt;&lt;/code&gt;, &lt;code&gt;self: Arc&amp;lt;Self&amp;gt;&lt;/code&gt;, and &lt;code&gt;self: Pin&amp;lt;P&amp;gt;&lt;/code&gt; (where P is one of the previous types except &lt;code&gt;Self&lt;/code&gt;). Note that &lt;code&gt;Self&lt;/code&gt; can also be the underlying implementing type, like &lt;code&gt;Foo&lt;/code&gt; in the following example:</source>
          <target state="translated">タイプ &lt;code&gt;Self&lt;/code&gt; は、現在のトレイト実装者のタイプ、つまり「レシーバータイプ」のエイリアスとして機能します。すでに述べた &lt;code&gt;Self&lt;/code&gt; 、 &lt;code&gt;&amp;amp;Self&lt;/code&gt; 、 &lt;code&gt;&amp;amp;mut Self&lt;/code&gt; の有効なレシーバータイプに加えて、次のものも有効です： &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt; 、 &lt;code&gt;self: Rc&amp;lt;Self&amp;gt;&lt;/code&gt; 、 &lt;code&gt;self: Arc&amp;lt;Self&amp;gt;&lt;/code&gt; 、 &lt;code&gt;self: Pin&amp;lt;P&amp;gt;&lt;/code&gt; （ここでPは、 &lt;code&gt;Self&lt;/code&gt; を除く以前のタイプの1つです）。次の例の &lt;code&gt;Foo&lt;/code&gt; のように、 &lt;code&gt;Self&lt;/code&gt; も基礎となる実装タイプになる可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="86f527297d32ae3d914332f31c2f8f0967b4e336" translate="yes" xml:space="preserve">
          <source>The type alias helps in two ways: it makes code easier to write &lt;em&gt;and&lt;/em&gt; it gives us a consistent interface across all of &lt;code&gt;std::io&lt;/code&gt;. Because it&amp;rsquo;s an alias, it&amp;rsquo;s just another &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;, which means we can use any methods that work on &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; with it, as well as special syntax like the &lt;code&gt;?&lt;/code&gt; operator.</source>
          <target state="translated">型エイリアスは、2つの点で役立ちます。コードを記述&lt;em&gt;し&lt;/em&gt;やすくし、すべての &lt;code&gt;std::io&lt;/code&gt; にわたって一貫したインターフェイスを提供します。それは別名なので、それはちょうど別だ &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 私たちは仕事というの任意の方法を使用できることを意味し、 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; それでだけでなく、のような特殊な構文 &lt;code&gt;?&lt;/code&gt; オペレーター。</target>
        </trans-unit>
        <trans-unit id="ea0e2aaa51d45e0a422d27f3c58e30936523ccce" translate="yes" xml:space="preserve">
          <source>The type annotation &lt;code&gt;HashMap&amp;lt;_, _&amp;gt;&lt;/code&gt; is needed here because it&amp;rsquo;s possible to &lt;code&gt;collect&lt;/code&gt; into many different data structures and Rust doesn&amp;rsquo;t know which you want unless you specify. For the parameters for the key and value types, however, we use underscores, and Rust can infer the types that the hash map contains based on the types of the data in the vectors.</source>
          <target state="translated">型注釈 &lt;code&gt;HashMap&amp;lt;_, _&amp;gt;&lt;/code&gt; が必要なのは、多くの異なるデータ構造に &lt;code&gt;collect&lt;/code&gt; ことが可能であり、Rustは指定しない限りどちらを使用するかわからないためです。ただし、キーと値の型のパラメーターにはアンダースコアを使用し、Rustはベクター内のデータの型に基づいてハッシュマップに含まれる型を推測できます。</target>
        </trans-unit>
        <trans-unit id="19887ad86a95d19b831c6b68bb5aee99f3125dcd" translate="yes" xml:space="preserve">
          <source>The type annotation &lt;code&gt;HashMap&amp;lt;_, _&amp;gt;&lt;/code&gt; is needed here because it&amp;rsquo;s possible to &lt;code&gt;collect&lt;/code&gt; into many different data structures and Rust doesn&amp;rsquo;t know which you want unless you specify. For the parameters for the key and value types, however, we use underscores, and Rust can infer the types that the hash map contains based on the types of the data in the vectors. In Listing 8-21, the key type will be &lt;code&gt;String&lt;/code&gt; and the value type will be &lt;code&gt;i32&lt;/code&gt;, just as the types were in Listing 8-20.</source>
          <target state="translated">ここでは、型アノテーション &lt;code&gt;HashMap&amp;lt;_, _&amp;gt;&lt;/code&gt; が必要です。これは、さまざまなデータ構造に &lt;code&gt;collect&lt;/code&gt; ことが可能であり、Rustは、指定しない限り、どちらが必要かわからないためです。ただし、キータイプと値タイプのパラメーターにはアンダースコアを使用し、Rustは、ベクトル内のデータのタイプに基づいて、ハッシュマップに含まれるタイプを推測できます。リスト8-21では、リスト8-20のタイプと同様に、キータイプは &lt;code&gt;String&lt;/code&gt; になり、値タイプは &lt;code&gt;i32&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="fdf52c33ab9420faf47eea0ae86189b509c83d56" translate="yes" xml:space="preserve">
          <source>The type definition contains some field whose type requires an outlives annotation. Outlives annotations (e.g., &lt;code&gt;T: 'a&lt;/code&gt;) are used to guarantee that all the data in T is valid for at least the lifetime &lt;code&gt;'a&lt;/code&gt;. This scenario most commonly arises when the type contains an associated type reference like &lt;code&gt;&amp;lt;T as SomeTrait&amp;lt;'a&amp;gt;&amp;gt;::Output&lt;/code&gt;, as shown in the previous code.</source>
          <target state="translated">タイプ定義には、タイプがoutlivesアノテーションを必要とするフィールドが含まれています。存続期間の注釈（たとえば、 &lt;code&gt;T: 'a&lt;/code&gt; ）は、T内のすべてのデータが少なくとも存続期間 &lt;code&gt;'a&lt;/code&gt; の間有効であることを保証するために使用されます。このシナリオは、前のコードに示されているように、タイプに &lt;code&gt;&amp;lt;T as SomeTrait&amp;lt;'a&amp;gt;&amp;gt;::Output&lt;/code&gt; ような関連するタイプ参照が含まれている場合に最も一般的に発生します。</target>
        </trans-unit>
        <trans-unit id="06a3cc90dfa59efcb3be0ad0da5e31c3b001a903" translate="yes" xml:space="preserve">
          <source>The type definition contains some field whose type requires an outlives annotation. Outlives annotations (e.g., &lt;code&gt;T: 'a&lt;/code&gt;) are used to guarantee that all the data in T is valid for at least the lifetime &lt;code&gt;'a&lt;/code&gt;. This scenario most commonly arises when the type contains an associated type reference like &lt;code&gt;&amp;lt;T as SomeTrait&amp;lt;'a&amp;gt;&amp;gt;::Output&lt;/code&gt;, as shown in this example:</source>
          <target state="translated">型定義には、型に存続アノテーションが必要ないくつかのフィールドが含まれています。Outlivesアノテーション（例 &lt;code&gt;T: 'a&lt;/code&gt; ）は、Tのすべてのデータが少なくともライフタイム &lt;code&gt;'a&lt;/code&gt; の間有効であることを保証するために使用されます。このシナリオは、次の例に示すように、タイプに &lt;code&gt;&amp;lt;T as SomeTrait&amp;lt;'a&amp;gt;&amp;gt;::Output&lt;/code&gt; などの関連するタイプ参照が含まれている場合に最もよく発生します。</target>
        </trans-unit>
        <trans-unit id="fc99bc0924bfaeb5da14796b8d2b7f81fb11367e" translate="yes" xml:space="preserve">
          <source>The type does not fulfill the required lifetime.</source>
          <target state="translated">このタイプは、必要な寿命を満たしていません。</target>
        </trans-unit>
        <trans-unit id="9e9c0bf21d5e45e81b33f072a97367bb2e667f29" translate="yes" xml:space="preserve">
          <source>The type must have the &lt;code&gt;Sync&lt;/code&gt; trait bound to allow thread-safe access.</source>
          <target state="translated">スレッドセーフなアクセスを可能にするには、型に &lt;code&gt;Sync&lt;/code&gt; トレイトがバインドされている必要があります。</target>
        </trans-unit>
        <trans-unit id="5761684433f543db118c22f7a347176798eaf3c5" translate="yes" xml:space="preserve">
          <source>The type name should not be considered a unique identifier of a type; multiple types may share the same type name.</source>
          <target state="translated">型名は型の一意な識別子とみなされるべきではありません;複数の型は同じ型名を共有することができます。</target>
        </trans-unit>
        <trans-unit id="8abd0fc7da623f26ad9fecceeea94f5bfc1f633a" translate="yes" xml:space="preserve">
          <source>The type name used is not in scope.</source>
          <target state="translated">使用されている型名はスコープに入っていません。</target>
        </trans-unit>
        <trans-unit id="89e2360bf1d9e23be29f6ad88e266a77e3f4f82f" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;guess&lt;/code&gt; in this code would have to be an integer &lt;em&gt;and&lt;/em&gt; a string, and Rust requires that &lt;code&gt;guess&lt;/code&gt; have only one type. So what does &lt;code&gt;continue&lt;/code&gt; return? How were we allowed to return a &lt;code&gt;u32&lt;/code&gt; from one arm and have another arm that ends with &lt;code&gt;continue&lt;/code&gt; in Listing 19-26?</source>
          <target state="translated">このコードの &lt;code&gt;guess&lt;/code&gt; のタイプは整数&lt;em&gt;と&lt;/em&gt;文字列でなければなりません。Rustは &lt;code&gt;guess&lt;/code&gt; タイプが1つだけであることを要求します。だから何をし &lt;code&gt;continue&lt;/code&gt; リターンを？リスト19-26で、あるアームから &lt;code&gt;u32&lt;/code&gt; を返し、最後に別のアームを &lt;code&gt;continue&lt;/code&gt; ことがどのように許可されましたか？</target>
        </trans-unit>
        <trans-unit id="ae6cd25ffa500de06212f0c2207844d88b02a6be" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;s&lt;/code&gt; here is &lt;code&gt;&amp;amp;str&lt;/code&gt;: it&amp;rsquo;s a slice pointing to that specific point of the binary. This is also why string literals are immutable; &lt;code&gt;&amp;amp;str&lt;/code&gt; is an immutable reference.</source>
          <target state="translated">ここで &lt;code&gt;s&lt;/code&gt; のタイプは &lt;code&gt;&amp;amp;str&lt;/code&gt; です。これは、バイナリのその特定のポイントを指すスライスです。これは、文字列リテラルが不変である理由でもあります。 &lt;code&gt;&amp;amp;str&lt;/code&gt; は不変の参照です。</target>
        </trans-unit>
        <trans-unit id="34ca2b2668ed637a52d925af5ee324f0385b2620" translate="yes" xml:space="preserve">
          <source>The type of a block is the type of the final expression, or &lt;code&gt;()&lt;/code&gt; if the final expression is omitted.</source>
          <target state="translated">ブロックのタイプは、最終式のタイプ、または最終式が省略されている場合は &lt;code&gt;()&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="04575cb944f5ba2523fe623e2ff7231ff81edabc" translate="yes" xml:space="preserve">
          <source>The type of a const parameter references other generic parameters.</source>
          <target state="translated">constパラメータの型は、他の汎用パラメータを参照します。</target>
        </trans-unit>
        <trans-unit id="ed47b86a36c39f67b1e05de4464008d8a1956f2c" translate="yes" xml:space="preserve">
          <source>The type of an &lt;em&gt;unsuffixed&lt;/em&gt; floating-point literal is determined by type inference:</source>
          <target state="translated">&lt;em&gt;接尾辞なしの&lt;/em&gt;浮動小数点リテラルの型は、型推論によって決定されます。</target>
        </trans-unit>
        <trans-unit id="6114cd343a30b85f17666d6fd494268587f7b8ea" translate="yes" xml:space="preserve">
          <source>The type of an &lt;em&gt;unsuffixed&lt;/em&gt; integer literal is determined by type inference:</source>
          <target state="translated">&lt;em&gt;接尾辞のない&lt;/em&gt;整数リテラルの型は、型推論によって決定されます。</target>
        </trans-unit>
        <trans-unit id="89c2fbc4e2ada9abaa3500c6a37ddee8522542e8" translate="yes" xml:space="preserve">
          <source>The type of the discriminant, which must satisfy the trait bounds required by &lt;code&gt;mem::Discriminant&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mem::Discriminant&lt;/code&gt; 要求する特性の範囲を満たさなければならない判別式のタイプ。</target>
        </trans-unit>
        <trans-unit id="f7d869126e3c264254879784374ee68ec03547b9" translate="yes" xml:space="preserve">
          <source>The type of the elements being iterated over.</source>
          <target state="translated">反復される要素の型。</target>
        </trans-unit>
        <trans-unit id="af8245e533db8494bb30cc9dc28768887bbb8570" translate="yes" xml:space="preserve">
          <source>The type of the value that &lt;code&gt;File::open&lt;/code&gt; returns inside the &lt;code&gt;Err&lt;/code&gt; variant is &lt;code&gt;io::Error&lt;/code&gt;, which is a struct provided by the standard library. This struct has a method &lt;code&gt;kind&lt;/code&gt; that we can call to get an &lt;code&gt;io::ErrorKind&lt;/code&gt; value. The enum &lt;code&gt;io::ErrorKind&lt;/code&gt; is provided by the standard library and has variants representing the different kinds of errors that might result from an &lt;code&gt;io&lt;/code&gt; operation. The variant we want to use is &lt;code&gt;ErrorKind::NotFound&lt;/code&gt;, which indicates the file we&amp;rsquo;re trying to open doesn&amp;rsquo;t exist yet. So we match on &lt;code&gt;f&lt;/code&gt;, but we also have an inner match on &lt;code&gt;error.kind()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Err&lt;/code&gt; バリアント内で &lt;code&gt;File::open&lt;/code&gt; が返す値のタイプは &lt;code&gt;io::Error&lt;/code&gt; 、これは標準ライブラリによって提供される構造体です。この構造体には、 &lt;code&gt;io::ErrorKind&lt;/code&gt; 値を取得するために呼び出すことができるメソッドの &lt;code&gt;kind&lt;/code&gt; があります。列挙型 &lt;code&gt;io::ErrorKind&lt;/code&gt; は標準ライブラリによって提供され、 &lt;code&gt;io&lt;/code&gt; 操作から発生する可能性のあるさまざまな種類のエラーを表すバリアントがあります。使用したいバリアントは &lt;code&gt;ErrorKind::NotFound&lt;/code&gt; 。これは、開こうとしているファイルがまだ存在しないことを示しています。したがって、 &lt;code&gt;f&lt;/code&gt; で一致しますが、 &lt;code&gt;error.kind()&lt;/code&gt; でも内部一致があります。</target>
        </trans-unit>
        <trans-unit id="545510a669763ef63063641881497bf7dd3f481a" translate="yes" xml:space="preserve">
          <source>The type of this value when viewed as failed.</source>
          <target state="translated">失敗したと見なしたときのこの値の型。</target>
        </trans-unit>
        <trans-unit id="8b60f120f0bca222851815dfc6ed07a4a0520575" translate="yes" xml:space="preserve">
          <source>The type of this value when viewed as successful.</source>
          <target state="translated">成功したと見たときのこの値のタイプ。</target>
        </trans-unit>
        <trans-unit id="bf039a86046c9f49aceed05895007223ced0c5ff" translate="yes" xml:space="preserve">
          <source>The type of value produced on completion.</source>
          <target state="translated">完成時に生み出される価値の種類。</target>
        </trans-unit>
        <trans-unit id="16751927675b4a2fde8980932985c3b025559cb0" translate="yes" xml:space="preserve">
          <source>The type of value this generator returns.</source>
          <target state="translated">このジェネレータが返す値のタイプ。</target>
        </trans-unit>
        <trans-unit id="bf293514c386bb6e45033b7b50e4549a332b83ad" translate="yes" xml:space="preserve">
          <source>The type of value this generator returns. &lt;a href=&quot;../ops/trait.generator#associatedtype.Return&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">このジェネレータが返す値のタイプ。&lt;a href=&quot;../ops/trait.generator#associatedtype.Return&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fcbd5cd653d3daa61c5d5d30831f8972d04f844c" translate="yes" xml:space="preserve">
          <source>The type of value this generator returns. &lt;a href=&quot;ops/trait.generator#associatedtype.Return&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">このジェネレータが返す値のタイプ。&lt;a href=&quot;ops/trait.generator#associatedtype.Return&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c5e0eda41ab22396cfa2f1334045d1746f855426" translate="yes" xml:space="preserve">
          <source>The type of value this generator yields.</source>
          <target state="translated">このジェネレータが生成する値のタイプ。</target>
        </trans-unit>
        <trans-unit id="b8cb8237cc8b58247dbdfe05ac4618d5ded726d1" translate="yes" xml:space="preserve">
          <source>The type of value this generator yields. &lt;a href=&quot;../ops/trait.generator#associatedtype.Yield&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">このジェネレータが生成する値のタイプ。&lt;a href=&quot;../ops/trait.generator#associatedtype.Yield&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="becf5070fa5e52c8db7c1d497d6f97d2d8cc4f48" translate="yes" xml:space="preserve">
          <source>The type of value this generator yields. &lt;a href=&quot;ops/trait.generator#associatedtype.Yield&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">このジェネレータが生成する値のタイプ。&lt;a href=&quot;ops/trait.generator#associatedtype.Yield&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="586fe8d7efe2a1acc6c511b646a3a08c88efbb26" translate="yes" xml:space="preserve">
          <source>The type parameter &lt;code&gt;T&lt;/code&gt; represents the data that this lock protects. It is required that &lt;code&gt;T&lt;/code&gt; satisfies &lt;a href=&quot;../marker/trait.send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt; to be shared across threads and &lt;a href=&quot;../marker/trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; to allow concurrent access through readers. The RAII guards returned from the locking methods implement &lt;a href=&quot;../ops/trait.deref&quot;&gt;&lt;code&gt;Deref&lt;/code&gt;&lt;/a&gt; (and &lt;a href=&quot;../ops/trait.derefmut&quot;&gt;&lt;code&gt;DerefMut&lt;/code&gt;&lt;/a&gt; for the &lt;code&gt;write&lt;/code&gt; methods) to allow access to the content of the lock.</source>
          <target state="translated">タイプパラメータ &lt;code&gt;T&lt;/code&gt; は、このロックが保護するデータを表します。 &lt;code&gt;T&lt;/code&gt; は、スレッド間で共有される&lt;a href=&quot;../marker/trait.send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt;と、リーダーを介した同時アクセスを可能にする&lt;a href=&quot;../marker/trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt;を満たす必要があります。ロックメソッドから返さRAIIガードは、実施&lt;a href=&quot;../ops/trait.deref&quot;&gt; &lt;code&gt;Deref&lt;/code&gt; &lt;/a&gt;（及び&lt;a href=&quot;../ops/trait.derefmut&quot;&gt; &lt;code&gt;DerefMut&lt;/code&gt; の&lt;/a&gt;ための &lt;code&gt;write&lt;/code&gt; ロックのコンテンツへのアクセスを許可する方法）。</target>
        </trans-unit>
        <trans-unit id="f6f9ae50a3ab94a8cf9005786a7b9af006ffe517" translate="yes" xml:space="preserve">
          <source>The type parameters can also be explicitly supplied in a trailing &lt;a href=&quot;../paths&quot;&gt;path&lt;/a&gt; component after the function name. This might be necessary if there is not sufficient context to determine the type parameters. For example, &lt;code&gt;mem::size_of::&amp;lt;u32&amp;gt;() == 4&lt;/code&gt;.</source>
          <target state="translated">型パラメーターは、関数名の後に続く&lt;a href=&quot;../paths&quot;&gt;パス&lt;/a&gt;コンポーネントで明示的に指定することもできます。これは、タイプパラメータを決定するための十分なコンテキストがない場合に必要になることがあります。たとえば、 &lt;code&gt;mem::size_of::&amp;lt;u32&amp;gt;() == 4&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="618c44497e554625efd295f7702914ef5292c792" translate="yes" xml:space="preserve">
          <source>The type placeholder &lt;code&gt;_&lt;/code&gt; can be used outside item's signature as follows:</source>
          <target state="translated">タイププレースホルダー &lt;code&gt;_&lt;/code&gt; は、アイテムの署名の外で次のように使用できます。</target>
        </trans-unit>
        <trans-unit id="ba2931173dcc6550d705628d261c402eccc53232" translate="yes" xml:space="preserve">
          <source>The type placeholder &lt;code&gt;_&lt;/code&gt; was used within a type on an item's signature.</source>
          <target state="translated">タイププレースホルダー &lt;code&gt;_&lt;/code&gt; は、アイテムの署名のタイプ内で使用されました。</target>
        </trans-unit>
        <trans-unit id="11d805f97c85ceb05a75d626e5740cb0e2204f44" translate="yes" xml:space="preserve">
          <source>The type returned by formatter methods.</source>
          <target state="translated">フォーマッタのメソッドが返す型。</target>
        </trans-unit>
        <trans-unit id="1c16d9adfa415d1c3d1e4550b932c426a82800c2" translate="yes" xml:space="preserve">
          <source>The type returned in the event of a conversion error.</source>
          <target state="translated">変換エラーが発生した場合に返される型。</target>
        </trans-unit>
        <trans-unit id="2d7863bb088ba575c630ae75df049f3bc518eb6c" translate="yes" xml:space="preserve">
          <source>The type that the &lt;code&gt;else&lt;/code&gt; blocks evaluate to must be compatible with the type that the &lt;code&gt;if&lt;/code&gt; block evaluates to.</source>
          <target state="translated">タイプの &lt;code&gt;else&lt;/code&gt; のブロックがに評価し、その型と互換性がなければならない &lt;code&gt;if&lt;/code&gt; 、ブロックが評価されます。</target>
        </trans-unit>
        <trans-unit id="f8e8d68133a2235c54df1609c3fa9dc8e972aa60" translate="yes" xml:space="preserve">
          <source>The type to return is inferred from context; this is equivalent to &lt;code&gt;Default::default()&lt;/code&gt; but shorter to type.</source>
          <target state="translated">返されるタイプはコンテキストから推測されます。これは &lt;code&gt;Default::default()&lt;/code&gt; と同等ですが、入力するのが短くなります。</target>
        </trans-unit>
        <trans-unit id="6b611879bfea657d3652c629b736393c4b650211" translate="yes" xml:space="preserve">
          <source>The type you are trying to impl &lt;code&gt;CoerceUnsized&lt;/code&gt; for is not a struct. &lt;code&gt;CoerceUnsized&lt;/code&gt; can only be implemented for a struct. Unsized types are already able to be coerced without an implementation of &lt;code&gt;CoerceUnsized&lt;/code&gt; whereas a struct containing an unsized type needs to know the unsized type field it's containing is able to be coerced. An &lt;a href=&quot;book/ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;unsized type&lt;/a&gt; is any type that the compiler doesn't know the length or alignment of at compile time. Any struct containing an unsized type is also unsized.</source>
          <target state="translated">&lt;code&gt;CoerceUnsized&lt;/code&gt; を実装しようとしている型は構造体ではありません。 &lt;code&gt;CoerceUnsized&lt;/code&gt; は、構造体に対してのみ実装できます。サイズなしの型は、CoerceUnsizedの実装なしで強制的に &lt;code&gt;CoerceUnsized&lt;/code&gt; できますが、サイズなしの型を含む構造体は、それが含むサイズなしの型フィールドを強制的に変換できる必要があります。&lt;a href=&quot;book/ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;無サイズタイプは&lt;/a&gt;、コンパイラがコンパイル時の長さや配置を知っていないことをどのようなタイプです。サイズなしの型を含む構造体もサイズなしです。</target>
        </trans-unit>
        <trans-unit id="63c27305b7150da660772855aa4571d697d89b10" translate="yes" xml:space="preserve">
          <source>The type you can compare with is controlled by &lt;code&gt;PartialEq&lt;/code&gt;'s type parameter. For example, let's tweak our previous code a bit:</source>
          <target state="translated">比較できる型は、 &lt;code&gt;PartialEq&lt;/code&gt; の型パラメーターによって制御されます。たとえば、前のコードを少し調整してみましょう。</target>
        </trans-unit>
        <trans-unit id="93ef2caad28212460c75d9146f8dc4d0899b2d98" translate="yes" xml:space="preserve">
          <source>The type-checker needed to know the type of an expression, but that type had not yet been inferred.</source>
          <target state="translated">タイプチェッカーは式のタイプを知る必要がありましたが、そのタイプはまだ推測されていませんでした。</target>
        </trans-unit>
        <trans-unit id="f584bedf990c038f22247101ab8b097fb3a593e8" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;*const T&lt;/code&gt;, &lt;code&gt;&amp;amp;T&lt;/code&gt;, &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt;, and &lt;code&gt;Option&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; all have the same size. If &lt;code&gt;T&lt;/code&gt; is Sized, all of those types have the same size as &lt;code&gt;usize&lt;/code&gt;.</source>
          <target state="translated">タイプ &lt;code&gt;*const T&lt;/code&gt; 、 &lt;code&gt;&amp;amp;T&lt;/code&gt; 、 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 、 &lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt; 、および &lt;code&gt;Option&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; すべて同じサイズです。 &lt;code&gt;T&lt;/code&gt; がSizedの場合、それらすべての型は &lt;code&gt;usize&lt;/code&gt; と同じサイズです。</target>
        </trans-unit>
        <trans-unit id="5722d857751fd92f7cd76388f248410597abc535" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;char&lt;/code&gt; and &lt;code&gt;str&lt;/code&gt; hold textual data.</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; 型と &lt;code&gt;str&lt;/code&gt; 型はテキストデータを保持します。</target>
        </trans-unit>
        <trans-unit id="99894423e354dd0b37e0c9ced81c62b48fcf23b2" translate="yes" xml:space="preserve">
          <source>The types of any associated constants in a trait implementation must match the types in the trait definition.</source>
          <target state="translated">このような場合には、「Together」を使用することで、「Together」を使用することができます。</target>
        </trans-unit>
        <trans-unit id="ff52a3715390889940af516c60b08b678feeadf3" translate="yes" xml:space="preserve">
          <source>The types of any associated constants in a trait implementation must match the types in the trait definition. This error indicates that there was a mismatch.</source>
          <target state="translated">形質実装の関連する定数の型は、形質定義の型と一致していなければなりません。このエラーは、不一致を示します。</target>
        </trans-unit>
        <trans-unit id="2a9653c2b160c32821b432c07707efaa597921f1" translate="yes" xml:space="preserve">
          <source>The typical way to obtain a &lt;code&gt;Weak&lt;/code&gt; pointer is to call &lt;a href=&quot;struct.arc#method.downgrade&quot;&gt;&lt;code&gt;Arc::downgrade&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Weak&lt;/code&gt; ポインターを取得する一般的な方法は、&lt;a href=&quot;struct.arc#method.downgrade&quot;&gt; &lt;code&gt;Arc::downgrade&lt;/code&gt; &lt;/a&gt;を呼び出すことです。</target>
        </trans-unit>
        <trans-unit id="d7670bf148a2a36a6287e0959f849df36450aeea" translate="yes" xml:space="preserve">
          <source>The typical way to obtain a &lt;code&gt;Weak&lt;/code&gt; pointer is to call &lt;a href=&quot;struct.rc#method.downgrade&quot;&gt;&lt;code&gt;Rc::downgrade&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Weak&lt;/code&gt; ポインターを取得する一般的な方法は、&lt;a href=&quot;struct.rc#method.downgrade&quot;&gt; &lt;code&gt;Rc::downgrade&lt;/code&gt; &lt;/a&gt;を呼び出すことです。</target>
        </trans-unit>
        <trans-unit id="e38264f429668f9c24babca8440ad652db0e6325" translate="yes" xml:space="preserve">
          <source>The unary logical negation operator &lt;code&gt;!&lt;/code&gt;.</source>
          <target state="translated">単項論理否定演算子 &lt;code&gt;!&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6144b29ea1cdce68ecac471463a0fdc0639b34f9" translate="yes" xml:space="preserve">
          <source>The unary negation operator &lt;code&gt;-&lt;/code&gt;.</source>
          <target state="translated">単項否定演算子 &lt;code&gt;-&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7181a66c31dbb848d4da8d3e96055db8ae78d130" translate="yes" xml:space="preserve">
          <source>The underlying &lt;a href=&quot;struct.metadata&quot;&gt;&lt;code&gt;Metadata&lt;/code&gt;&lt;/a&gt; struct needs to be retrieved with the &lt;a href=&quot;fn.symlink_metadata&quot;&gt;&lt;code&gt;fs::symlink_metadata&lt;/code&gt;&lt;/a&gt; function and not the &lt;a href=&quot;fn.metadata&quot;&gt;&lt;code&gt;fs::metadata&lt;/code&gt;&lt;/a&gt; function. The &lt;a href=&quot;fn.metadata&quot;&gt;&lt;code&gt;fs::metadata&lt;/code&gt;&lt;/a&gt; function follows symbolic links, so &lt;a href=&quot;struct.filetype#method.is_symlink&quot;&gt;&lt;code&gt;is_symlink&lt;/code&gt;&lt;/a&gt; would always return &lt;code&gt;false&lt;/code&gt; for the target file.</source>
          <target state="translated">基礎となる&lt;a href=&quot;struct.metadata&quot;&gt; &lt;code&gt;Metadata&lt;/code&gt; &lt;/a&gt;構造体は、&lt;a href=&quot;fn.symlink_metadata&quot;&gt; &lt;code&gt;fs::symlink_metadata&lt;/code&gt; &lt;/a&gt;関数ではなく、&lt;a href=&quot;fn.metadata&quot;&gt; &lt;code&gt;fs::metadata&lt;/code&gt; &lt;/a&gt;symlink_metadata関数で取得する必要があります。&lt;a href=&quot;fn.metadata&quot;&gt; &lt;code&gt;fs::metadata&lt;/code&gt; &lt;/a&gt;ので機能は、シンボリックリンクをたどり&lt;a href=&quot;struct.filetype#method.is_symlink&quot;&gt; &lt;code&gt;is_symlink&lt;/code&gt; は&lt;/a&gt;常に戻ってくる &lt;code&gt;false&lt;/code&gt; ターゲットファイルのために。</target>
        </trans-unit>
        <trans-unit id="5ba52bb287979fcbe21a62414e5cba80ede6c6c5" translate="yes" xml:space="preserve">
          <source>The underlying &lt;code&gt;RefCell&lt;/code&gt; can never be mutably borrowed from again and will always appear already immutably borrowed. It is not a good idea to leak more than a constant number of references. The &lt;code&gt;RefCell&lt;/code&gt; can be immutably borrowed again if only a smaller number of leaks have occurred in total.</source>
          <target state="translated">基になる &lt;code&gt;RefCell&lt;/code&gt; は、二度と変更可能に借用することはできず、常に不変に借用されているように見えます。一定数以上の参照をリークすることはお勧めできません。 &lt;code&gt;RefCell&lt;/code&gt; は、漏洩の唯一の小さな数は、合計で発生した場合immutably再び借りすることができます。</target>
        </trans-unit>
        <trans-unit id="16573dc48843cb6201240052d6b60dde180482de" translate="yes" xml:space="preserve">
          <source>The underlying &lt;code&gt;RefCell&lt;/code&gt; can not be borrowed from again and will always appear already mutably borrowed, making the returned reference the only to the interior.</source>
          <target state="translated">基になる &lt;code&gt;RefCell&lt;/code&gt; を再度借用することはできず、常に可変的に借用されているように見え、返された参照は内部のみになります。</target>
        </trans-unit>
        <trans-unit id="485a92064bc4fcb63908fa7e1b3b1ad970b9f88b" translate="yes" xml:space="preserve">
          <source>The underlying &lt;code&gt;RefCell&lt;/code&gt; will remain mutably borrowed until both returned &lt;code&gt;RefMut&lt;/code&gt;s go out of scope.</source>
          <target state="translated">基になる &lt;code&gt;RefCell&lt;/code&gt; は、返された両方の &lt;code&gt;RefMut&lt;/code&gt; が範囲外になるまで、可変に借用されたままになります。</target>
        </trans-unit>
        <trans-unit id="9efa2c9dbfc51e4660e725c77fd7efb185f3f6ff" translate="yes" xml:space="preserve">
          <source>The underlying value can be retrieved through the &lt;code&gt;.0&lt;/code&gt; index of the &lt;code&gt;Wrapping&lt;/code&gt; tuple.</source>
          <target state="translated">基になる値は、 &lt;code&gt;Wrapping&lt;/code&gt; タプルの &lt;code&gt;.0&lt;/code&gt; インデックスを介して取得できます。</target>
        </trans-unit>
        <trans-unit id="1be4ec15824529c7ce6527861e8c2980ac38212f" translate="yes" xml:space="preserve">
          <source>The unique, unnameable symbols are created after macro expansion so that macros may safely emit multiple references to &lt;code&gt;_&lt;/code&gt; imports. For example, the following should not produce an error:</source>
          <target state="translated">マクロが &lt;code&gt;_&lt;/code&gt; インポートへの複数の参照を安全に発行できるように、マクロ展開後に一意の名前のないシンボルが作成されます。たとえば、次の場合はエラーが発生しないはずです。</target>
        </trans-unit>
        <trans-unit id="f4f440ca9518cd96f0fe9c31f85a61d77e18e0f3" translate="yes" xml:space="preserve">
          <source>The unsafe counterpart of this macro is the &lt;a href=&quot;hint/fn.unreachable_unchecked&quot;&gt;&lt;code&gt;unreachable_unchecked&lt;/code&gt;&lt;/a&gt; function, which will cause undefined behavior if the code is reached.</source>
          <target state="translated">このマクロの安全でない対応物は&lt;a href=&quot;hint/fn.unreachable_unchecked&quot;&gt; &lt;code&gt;unreachable_unchecked&lt;/code&gt; &lt;/a&gt;関数であり、コードに到達すると未定義の動作を引き起こします。</target>
        </trans-unit>
        <trans-unit id="c1a83814a7bcbd2091dc90767bec8f24c5d3f1e3" translate="yes" xml:space="preserve">
          <source>The unsigned integer types consist of:</source>
          <target state="translated">符号なし整数型は、以下のように構成されています。</target>
        </trans-unit>
        <trans-unit id="2d2ce136339d709e77fd2d67b03ff1b69af40d44" translate="yes" xml:space="preserve">
          <source>The upper bound of the range (exclusive).</source>
          <target state="translated">範囲の上限(排他的)。</target>
        </trans-unit>
        <trans-unit id="20d82b105410f2577709f06e6539062262a0ca81" translate="yes" xml:space="preserve">
          <source>The upper bound of the range (inclusive)</source>
          <target state="translated">範囲の上限(含む</target>
        </trans-unit>
        <trans-unit id="e68185f2e9603472a1563c4f776b66b2c6a3b822" translate="yes" xml:space="preserve">
          <source>The use of the &lt;a href=&quot;keyword.impl&quot;&gt;&lt;code&gt;impl&lt;/code&gt;&lt;/a&gt; keyword in this position allows the function writer to hide the concrete type as an implementation detail which can change without breaking user's code.</source>
          <target state="translated">この位置で&lt;a href=&quot;keyword.impl&quot;&gt; &lt;code&gt;impl&lt;/code&gt; &lt;/a&gt;キーワードを使用すると、関数の作成者は、ユーザーのコードを壊すことなく変更できる実装の詳細として具象型を非表示にできます。</target>
        </trans-unit>
        <trans-unit id="39cef1794b05feb8ec892ea4cd89efe908da35c8" translate="yes" xml:space="preserve">
          <source>The user could always interrupt the program by using the keyboard shortcut ctrl-c. But there&amp;rsquo;s another way to escape this insatiable monster, as mentioned in the &lt;code&gt;parse&lt;/code&gt; discussion in &lt;a href=&quot;#comparing-the-guess-to-the-secret-number&quot;&gt;&amp;ldquo;Comparing the Guess to the Secret Number&amp;rdquo;&lt;/a&gt;: if the user enters a non-number answer, the program will crash. The user can take advantage of that in order to quit, as shown here:</source>
          <target state="translated">ユーザーは、キーボードショートカットのctrl-cを使用して、常にプログラムに割り込むことができます。しかし、&lt;a href=&quot;#comparing-the-guess-to-the-secret-number&quot;&gt;「推測と秘密の番号の比較」&lt;/a&gt;の &lt;code&gt;parse&lt;/code&gt; 述べたように、この飽くなきモンスターを脱出する別の方法があります。ユーザーが数値以外の回答を入力すると、プログラムがクラッシュします。次に示すように、ユーザーはそれを利用して終了することができます。</target>
        </trans-unit>
        <trans-unit id="e62c088fdd6cf7f93babb9263d9008d71eaadccf" translate="yes" xml:space="preserve">
          <source>The user lacks permissions to perform &lt;code&gt;metadata&lt;/code&gt; call on &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">ユーザーは、 &lt;code&gt;path&lt;/code&gt; &lt;code&gt;metadata&lt;/code&gt; 呼び出しを実行する権限がありません。</target>
        </trans-unit>
        <trans-unit id="0dc65bb53b7876e2a52ec0de6c50b31a471724ba" translate="yes" xml:space="preserve">
          <source>The user lacks permissions to remove the directory at the provided &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">ユーザーには、指定された &lt;code&gt;path&lt;/code&gt; あるディレクトリを削除する権限がありません。</target>
        </trans-unit>
        <trans-unit id="4ed8999bb1ca133f6f343fbba9eb07d31db22560" translate="yes" xml:space="preserve">
          <source>The user lacks permissions to remove the file.</source>
          <target state="translated">ユーザーはファイルを削除する権限を持っていません。</target>
        </trans-unit>
        <trans-unit id="da243dceea5f741ec03e2474a95470f701358e02" translate="yes" xml:space="preserve">
          <source>The user lacks permissions to view contents.</source>
          <target state="translated">ユーザーはコンテンツを表示する権限を持っていません。</target>
        </trans-unit>
        <trans-unit id="a0ceecf91cf3de088e4866146d667401fc9825c7" translate="yes" xml:space="preserve">
          <source>The user lacks the permission to change attributes of the file.</source>
          <target state="translated">ユーザーはファイルの属性を変更する権限を持っていません。</target>
        </trans-unit>
        <trans-unit id="0728943e3f9e2dd60ac0860b5efc3c86277bbcf8" translate="yes" xml:space="preserve">
          <source>The user of &lt;code&gt;from_raw&lt;/code&gt; has to make sure a specific value of &lt;code&gt;T&lt;/code&gt; is only dropped once.</source>
          <target state="translated">&lt;code&gt;from_raw&lt;/code&gt; のユーザーは、 &lt;code&gt;T&lt;/code&gt; の特定の値が1回だけドロップされることを確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="8bc0d661ff73b2e7b2da5a4e28c09493dbabbf98" translate="yes" xml:space="preserve">
          <source>The value &lt;code&gt;to_drop&lt;/code&gt; points to must be valid for dropping, which may mean it must uphold additional invariants - this is type-dependent.</source>
          <target state="translated">&lt;code&gt;to_drop&lt;/code&gt; が指す値は、ドロップに対して有効である必要があります。これは、追加の不変条件を保持する必要があることを意味する場合があります。これはタイプに依存します。</target>
        </trans-unit>
        <trans-unit id="9ef61ff6808c20e3aee33111c7be00b7f9eb3ce9" translate="yes" xml:space="preserve">
          <source>The value being coerced is the actual parameter, and it is coerced to the type of the formal parameter.</source>
          <target state="translated">強制されている値は実際のパラメータであり、形式パラメータの型に強制されています。</target>
        </trans-unit>
        <trans-unit id="a4543ae96f3c210a98b1abf8fa6e1fffb99a3a60" translate="yes" xml:space="preserve">
          <source>The value contained in the &lt;code&gt;Result::Err&lt;/code&gt; variant is the value the thread panicked with; that is, the argument the &lt;code&gt;panic!&lt;/code&gt; macro was called with. Unlike with normal errors, this value doesn't implement the &lt;a href=&quot;../error/trait.error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; trait.</source>
          <target state="translated">&lt;code&gt;Result::Err&lt;/code&gt; バリアントに含まれる値は、スレッドがパニックに陥った値です。つまり、議論は &lt;code&gt;panic!&lt;/code&gt; マクロはで呼び出されました。通常のエラーとは異なり、この値は&lt;a href=&quot;../error/trait.error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt;特性を実装していません。</target>
        </trans-unit>
        <trans-unit id="3a5a7553814237ff25467a69b929b269b579c5c7" translate="yes" xml:space="preserve">
          <source>The value for &lt;code&gt;push&lt;/code&gt; is an expected cost; the method documentation gives a more detailed analysis.</source>
          <target state="translated">&lt;code&gt;push&lt;/code&gt; の値は予想コストです。メソッドのドキュメントは、より詳細な分析を提供します。</target>
        </trans-unit>
        <trans-unit id="7655c33f10da48be510d779b36c1473fc0c444da" translate="yes" xml:space="preserve">
          <source>The value for the width can also be provided as a &lt;a href=&quot;../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt; in the list of parameters by adding a postfix &lt;code&gt;$&lt;/code&gt;, indicating that the second argument is a &lt;a href=&quot;../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt; specifying the width.</source>
          <target state="translated">幅の値は、2番目の引数が幅を指定する&lt;a href=&quot;../primitive.usize&quot;&gt; &lt;code&gt;usize&lt;/code&gt; である&lt;/a&gt;ことを示す接尾辞 &lt;code&gt;$&lt;/code&gt; を追加することにより、パラメーターのリストで&lt;a href=&quot;../primitive.usize&quot;&gt; &lt;code&gt;usize&lt;/code&gt; &lt;/a&gt;として提供することもできます。</target>
        </trans-unit>
        <trans-unit id="d7971e26c81d228c6b498e7c0267b27f63e3a2f0" translate="yes" xml:space="preserve">
          <source>The value for the width can also be provided as a &lt;a href=&quot;../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt; in the list of parameters by using the dollar syntax indicating that the second argument is a &lt;a href=&quot;../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt; specifying the width, for example:</source>
          <target state="translated">幅の値は、2番目の引数が幅を指定する&lt;a href=&quot;../primitive.usize&quot;&gt; &lt;code&gt;usize&lt;/code&gt; である&lt;/a&gt;ことを示すドル構文を使用して、パラメーターのリストで&lt;a href=&quot;../primitive.usize&quot;&gt; &lt;code&gt;usize&lt;/code&gt; &lt;/a&gt;として提供することもできます。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="a708656013343fb0ab99fafd8d21e4229d39b962" translate="yes" xml:space="preserve">
          <source>The value may be any borrowed form of the set's value type, but &lt;a href=&quot;../../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; on the borrowed form &lt;em&gt;must&lt;/em&gt; match those for the value type.</source>
          <target state="translated">値は、セットの値型の任意の借用形式にすることができますが、借用形式の&lt;a href=&quot;../../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt;は、値型の値と一致する&lt;em&gt;必要があり&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="6f10fa6eb368dac898013f2276c185e31dd968d4" translate="yes" xml:space="preserve">
          <source>The value may be any borrowed form of the set's value type, but &lt;a href=&quot;../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; on the borrowed form &lt;em&gt;must&lt;/em&gt; match those for the value type.</source>
          <target state="translated">値は、セットの値型の任意の借用形式にすることができますが、借用形式の&lt;a href=&quot;../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt;は、値型の値と一致する&lt;em&gt;必要があり&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="cc1bf7113b6ffebee8a5cbda9953ce0f46aa8389" translate="yes" xml:space="preserve">
          <source>The value may be any borrowed form of the set's value type, but the ordering on the borrowed form &lt;em&gt;must&lt;/em&gt; match the ordering on the value type.</source>
          <target state="translated">値はセットの値タイプの任意の借用形式にすることができますが、借用フォームの順序は値タイプの順序と一致する&lt;em&gt;必要があり&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="5386004ae808f6aad83668aa6e791c4916959b45" translate="yes" xml:space="preserve">
          <source>The value must not be zero.</source>
          <target state="translated">値はゼロであってはなりません。</target>
        </trans-unit>
        <trans-unit id="72b7ccc4c541479713442aeb6f9117133107de5e" translate="yes" xml:space="preserve">
          <source>The value must:</source>
          <target state="translated">値が必要です。</target>
        </trans-unit>
        <trans-unit id="fe1619fc66fbf6e80510234756b7616df221cbcc" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;N&lt;/code&gt; that was specified for &lt;code&gt;repr(align(N))&lt;/code&gt; was not a power of two, or was greater than 2^29.</source>
          <target state="translated">&lt;code&gt;repr(align(N))&lt;/code&gt; に指定された &lt;code&gt;N&lt;/code&gt; の値が2の累乗ではなかったか、2 ^ 29を超えていました。</target>
        </trans-unit>
        <trans-unit id="744a6000b03885b8f256f7629c96527779c5f909" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;upper_i&lt;/code&gt; here relies on the language of the text: if we're in &lt;code&gt;en-US&lt;/code&gt;, it should be &lt;code&gt;&quot;I&quot;&lt;/code&gt;, but if we're in &lt;code&gt;tr_TR&lt;/code&gt;, it should be &lt;code&gt;&quot;İ&quot;&lt;/code&gt;. &lt;code&gt;to_uppercase()&lt;/code&gt; does not take this into account, and so:</source>
          <target state="translated">ここでの &lt;code&gt;upper_i&lt;/code&gt; の値はテキストの言語に依存します &lt;code&gt;en-US&lt;/code&gt; 場合は &lt;code&gt;&quot;I&quot;&lt;/code&gt; である必要がありますが、 &lt;code&gt;tr_TR&lt;/code&gt; の場合は &lt;code&gt;&quot;İ&quot;&lt;/code&gt; である必要があります。 &lt;code&gt;to_uppercase()&lt;/code&gt; はこれを考慮しないため、次のようになります。</target>
        </trans-unit>
        <trans-unit id="5ddda6614ea7e3e67438b2aae41a24ac0eb3ff50" translate="yes" xml:space="preserve">
          <source>The value of statics and constants must be known at compile time, and they live for the entire lifetime of a program. Creating a boxed value allocates memory on the heap at runtime, and therefore cannot be done at compile time.</source>
          <target state="translated">スタティックと定数の値はコンパイル時に知っておく必要があり、それらはプログラムの寿命の間ずっと生き続けます。枠付きの値を作成すると、実行時にヒープ上のメモリが割り当てられるため、コンパイル時にはできません。</target>
        </trans-unit>
        <trans-unit id="b739d6552c67cec966b03a294f348b71a38926c7" translate="yes" xml:space="preserve">
          <source>The value of statics and constants must be known at compile time, and they live for the entire lifetime of a program. Creating a boxed value allocates memory on the heap at runtime, and therefore cannot be done at compile time. Erroneous code example:</source>
          <target state="translated">スタティックと定数の値はコンパイル時に知っておく必要があり、それらはプログラムの寿命の間ずっと生き続けます。枠付きの値を作成すると、実行時にヒープ上のメモリが割り当てられるため、コンパイル時にはできません。誤ったコード例。</target>
        </trans-unit>
        <trans-unit id="4b2ff9e347c3c08ba8e806ad69a147ed48871d42" translate="yes" xml:space="preserve">
          <source>The value returned is equivalent to &lt;code&gt;self.seek(SeekFrom::Current(0))&lt;/code&gt; but does not flush the internal buffer. Due to this optimization the function does not guarantee that calling &lt;code&gt;.into_inner()&lt;/code&gt; immediately afterwards will yield the underlying reader at the same position. Use &lt;a href=&quot;struct.bufreader#method.seek&quot;&gt;&lt;code&gt;BufReader::seek&lt;/code&gt;&lt;/a&gt; instead if you require that guarantee.</source>
          <target state="translated">返される値は &lt;code&gt;self.seek(SeekFrom::Current(0))&lt;/code&gt; と同等ですが、内部バッファーをフラッシュしません。この最適化により、関数は、直後に &lt;code&gt;.into_inner()&lt;/code&gt; を呼び出すと、基になるリーダーが同じ位置にあることを保証しません。その保証が必要な場合は、代わりに&lt;a href=&quot;struct.bufreader#method.seek&quot;&gt; &lt;code&gt;BufReader::seek&lt;/code&gt; &lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="39c061cf746d3ba8e95a5a5598de09efb58fb7b8" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;s&lt;/code&gt; has type &lt;code&gt;String&lt;/code&gt;, and its use in the guard is as a variable of type &lt;code&gt;String&lt;/code&gt;. The guard code effectively executes in a separate scope to the body of the arm, so the value would be moved into this anonymous scope and therefore becomes unavailable in the body of the arm.</source>
          <target state="translated">変数 &lt;code&gt;s&lt;/code&gt; の型は &lt;code&gt;String&lt;/code&gt; で、ガードでの使用は &lt;code&gt;String&lt;/code&gt; 型の変数としてです。ガードコードは腕の本体とは別のスコープで効果的に実行されるため、値はこの匿名スコープに移動され、腕の本体では使用できなくなります。</target>
        </trans-unit>
        <trans-unit id="8e557a8691f00e33607a16e96773df5a29940a13" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;s&lt;/code&gt; refers to a string literal, where the value of the string is hardcoded into the text of our program. The variable is valid from the point at which it&amp;rsquo;s declared until the end of the current &lt;em&gt;scope&lt;/em&gt;. Listing 4-1 has comments annotating where the variable &lt;code&gt;s&lt;/code&gt; is valid.</source>
          <target state="translated">変数 &lt;code&gt;s&lt;/code&gt; は文字列リテラルを参照します。文字列の値はプログラムのテキストにハードコードされています。変数は、宣言された時点から現在の&lt;em&gt;スコープの&lt;/em&gt;最後まで&lt;em&gt;有効&lt;/em&gt;です。リスト4-1には、変数 &lt;code&gt;s&lt;/code&gt; が有効な場所を示すコメントがあります。</target>
        </trans-unit>
        <trans-unit id="5e699bc2ac5d00c87b2c7f3b8e3a9da4a553a5d0" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;tup&lt;/code&gt; binds to the entire tuple, because a tuple is considered a single compound element. To get the individual values out of a tuple, we can use pattern matching to destructure a tuple value, like this:</source>
          <target state="translated">タプルは単一の複合要素と見なされるため、変数 &lt;code&gt;tup&lt;/code&gt; はタプル全体にバインドされます。タプルから個々の値を取得するには、次のようにパターンマッチングを使用してタプル値を分解します。</target>
        </trans-unit>
        <trans-unit id="b81aa2b0402a0e499f7595712bef15edfd23e380" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;x&lt;/code&gt; doesn&amp;rsquo;t &amp;ldquo;live long enough.&amp;rdquo; The reason is that &lt;code&gt;x&lt;/code&gt; will be out of scope when the inner scope ends on line 7. But &lt;code&gt;r&lt;/code&gt; is still valid for the outer scope; because its scope is larger, we say that it &amp;ldquo;lives longer.&amp;rdquo; If Rust allowed this code to work, &lt;code&gt;r&lt;/code&gt; would be referencing memory that was deallocated when &lt;code&gt;x&lt;/code&gt; went out of scope, and anything we tried to do with &lt;code&gt;r&lt;/code&gt; wouldn&amp;rsquo;t work correctly. So how does Rust determine that this code is invalid? It uses a borrow checker.</source>
          <target state="translated">変数 &lt;code&gt;x&lt;/code&gt; は「十分に長く存続」しません。その理由は、内側のスコープが7行目で終了すると &lt;code&gt;x&lt;/code&gt; はスコープ外になるためです。しかし、 &lt;code&gt;r&lt;/code&gt; は依然として外側のスコープに対して有効です。スコープが大きいため、「寿命が長い」と言います。錆が仕事にこのコードを許可された場合、 &lt;code&gt;r&lt;/code&gt; は時に割り当て解除されたメモリ参照されるだろう &lt;code&gt;x&lt;/code&gt; 範囲を出て行ったが、私たちはして実行しようとしました何も &lt;code&gt;r&lt;/code&gt; が正常に動作しません。では、Rustはこのコードが無効であるとどのように判断するのでしょうか。借用チェッカーを使用します。</target>
        </trans-unit>
        <trans-unit id="b4588e360f79d1cb0e5f79f31bf6e7bc2ece8336" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;x&lt;/code&gt; holds an &lt;code&gt;i32&lt;/code&gt; value, &lt;code&gt;5&lt;/code&gt;. We set &lt;code&gt;y&lt;/code&gt; equal to a reference to &lt;code&gt;x&lt;/code&gt;. We can assert that &lt;code&gt;x&lt;/code&gt; is equal to &lt;code&gt;5&lt;/code&gt;. However, if we want to make an assertion about the value in &lt;code&gt;y&lt;/code&gt;, we have to use &lt;code&gt;*y&lt;/code&gt; to follow the reference to the value it&amp;rsquo;s pointing to (hence &lt;em&gt;dereference&lt;/em&gt;). Once we dereference &lt;code&gt;y&lt;/code&gt;, we have access to the integer value &lt;code&gt;y&lt;/code&gt; is pointing to that we can compare with &lt;code&gt;5&lt;/code&gt;.</source>
          <target state="translated">変数 &lt;code&gt;x&lt;/code&gt; は &lt;code&gt;i32&lt;/code&gt; 値 &lt;code&gt;5&lt;/code&gt; を保持します。 &lt;code&gt;y&lt;/code&gt; を &lt;code&gt;x&lt;/code&gt; への参照に等しく設定します。 &lt;code&gt;x&lt;/code&gt; が &lt;code&gt;5&lt;/code&gt; に等しいと断言できます。ただし、 &lt;code&gt;y&lt;/code&gt; の値についてアサーションを作成する場合は、 &lt;code&gt;*y&lt;/code&gt; を使用して、参照先の値への参照を追跡する必要があります（したがって、&lt;em&gt;dereference&lt;/em&gt;）。 &lt;code&gt;y&lt;/code&gt; を間接参照すると、 &lt;code&gt;5&lt;/code&gt; と比較できる &lt;code&gt;y&lt;/code&gt; が指す整数値にアクセスできます。</target>
        </trans-unit>
        <trans-unit id="b7511a7213b8989f428e5bec2c5234f95d46bda2" translate="yes" xml:space="preserve">
          <source>The variables that a &lt;a href=&quot;types/closure&quot;&gt;closure&lt;/a&gt; captures by move are dropped in an unspecified order.</source>
          <target state="translated">&lt;a href=&quot;types/closure&quot;&gt;クロージャ&lt;/a&gt;が移動によってキャプチャする変数は、不特定の順序で削除されます。</target>
        </trans-unit>
        <trans-unit id="f517012aa2f18b099c9314a6c9154f5976be9a45" translate="yes" xml:space="preserve">
          <source>The variance of other &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;enum&lt;/code&gt;, &lt;code&gt;union&lt;/code&gt; and tuple types is decided by looking at the variance of the types of their fields. If the parameter is used in positions with different variances then the parameter is invariant. For example the following struct is covariant in &lt;code&gt;'a&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt; and invariant in &lt;code&gt;'b&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">他の &lt;code&gt;struct&lt;/code&gt; 、 &lt;code&gt;enum&lt;/code&gt; 、 &lt;code&gt;union&lt;/code&gt; 、およびtupleタイプの分散は、それらのフィールドのタイプの分散を見ることによって決定されます。パラメータが異なる分散の位置で使用される場合、パラメータは不変です。たとえば、次の構造体は &lt;code&gt;'a&lt;/code&gt; と &lt;code&gt;T&lt;/code&gt; では共変で、 &lt;code&gt;'b&lt;/code&gt; と &lt;code&gt;U&lt;/code&gt; では不変です。</target>
        </trans-unit>
        <trans-unit id="edea3e36560d105a970958779d2fd8e9db94e633" translate="yes" xml:space="preserve">
          <source>The variance of other &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;enum&lt;/code&gt;, &lt;code&gt;union&lt;/code&gt;, and tuple types is decided by looking at the variance of the types of their fields. If the parameter is used in positions with different variances then the parameter is invariant. For example the following struct is covariant in &lt;code&gt;'a&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt; and invariant in &lt;code&gt;'b&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">他の &lt;code&gt;struct&lt;/code&gt; 、 &lt;code&gt;enum&lt;/code&gt; 、 &lt;code&gt;union&lt;/code&gt; 、およびタプルのタイプの分散は、それらのフィールドのタイプの分散を調べることによって決定されます。パラメータが異なる分散の位置で使用される場合、パラメータは不変です。たとえば、次の構造体は &lt;code&gt;'a&lt;/code&gt; と &lt;code&gt;T&lt;/code&gt; で共変であり、 &lt;code&gt;'b&lt;/code&gt; と &lt;code&gt;U&lt;/code&gt; で不変です。</target>
        </trans-unit>
        <trans-unit id="c0eb1ade80b4414ebb3db98e5e4492d2cfa8b829" translate="yes" xml:space="preserve">
          <source>The vector used to create a &lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt; must have one and only one nul byte, positioned at the end.</source>
          <target state="translated">&lt;a href=&quot;struct.cstring&quot;&gt; &lt;code&gt;CString&lt;/code&gt; の&lt;/a&gt;作成に使用されるベクトルには、最後に配置された1つのnulバイトのみが必要です。</target>
        </trans-unit>
        <trans-unit id="a2a9da86bd97667912e395039b2e850ba36a8d1a" translate="yes" xml:space="preserve">
          <source>The vector will be able to hold exactly &lt;code&gt;capacity&lt;/code&gt; elements without reallocating. If &lt;code&gt;capacity&lt;/code&gt; is 0, the vector will not allocate.</source>
          <target state="translated">ベクトルは、再割り当てすることなく、 &lt;code&gt;capacity&lt;/code&gt; 要素を正確に保持できます。場合は &lt;code&gt;capacity&lt;/code&gt; 0である、ベクトルは割り当てません。</target>
        </trans-unit>
        <trans-unit id="4a1a063010e523349572dfe2f3d4599fdbf7faf0" translate="yes" xml:space="preserve">
          <source>The vector will not allocate until elements are pushed onto it.</source>
          <target state="translated">ベクトルは、要素がその上にプッシュされるまで確保されません。</target>
        </trans-unit>
        <trans-unit id="4d0b594b3c2a18ead8ab96882d29be04515f3b55" translate="yes" xml:space="preserve">
          <source>The version numbering scheme is explained in &lt;a href=&quot;https://www.unicode.org/versions/Unicode11.0.0/ch03.pdf#page=4&quot;&gt;Unicode 11.0 or later, Section 3.1 Versions of the Unicode Standard&lt;/a&gt;.</source>
          <target state="translated">バージョン番号付けスキームは、&lt;a href=&quot;https://www.unicode.org/versions/Unicode11.0.0/ch03.pdf#page=4&quot;&gt;Unicode11.0以降のセクション3.1Unicode標準のバージョンで&lt;/a&gt;説明されています。</target>
        </trans-unit>
        <trans-unit id="0be7c75604b320ccdf03b29c2cf5dc9816b16f93" translate="yes" xml:space="preserve">
          <source>The version of &lt;a href=&quot;http://www.unicode.org/&quot;&gt;Unicode&lt;/a&gt; that the Unicode parts of &lt;code&gt;char&lt;/code&gt; and &lt;code&gt;str&lt;/code&gt; methods are based on.</source>
          <target state="translated">バージョン&lt;a href=&quot;http://www.unicode.org/&quot;&gt;ユニコード&lt;/a&gt;のユニコード部品こと &lt;code&gt;char&lt;/code&gt; と &lt;code&gt;str&lt;/code&gt; 方法は基づいています。</target>
        </trans-unit>
        <trans-unit id="2e7d7937a98ae8b5db75096586d34257981a3b35" translate="yes" xml:space="preserve">
          <source>The version of the call operator that takes a by-value receiver.</source>
          <target state="translated">バイ値の受信機を取る呼び出しオペレータのバージョン。</target>
        </trans-unit>
        <trans-unit id="98bb0c84eb64933810db44150740704106b58e5b" translate="yes" xml:space="preserve">
          <source>The version of the call operator that takes a mutable receiver.</source>
          <target state="translated">変形可能な受信機を受け取る呼び出し演算子のバージョン。</target>
        </trans-unit>
        <trans-unit id="a10ea779af62c4002732377426c5466fd9b100f8" translate="yes" xml:space="preserve">
          <source>The version of the call operator that takes an immutable receiver.</source>
          <target state="translated">不変の受信機を取るコールオペレータのバージョン。</target>
        </trans-unit>
        <trans-unit id="69df36660018fe57f4bfd6fa17c4ad5d9397540f" translate="yes" xml:space="preserve">
          <source>The volatile intrinsics provide operations intended to act on I/O memory, which are guaranteed to not be reordered by the compiler across other volatile intrinsics. See the LLVM documentation on [&lt;a href=&quot;http://llvm.org/docs/LangRef.html#volatile-memory-accesses&quot;&gt;volatile&lt;/a&gt;].</source>
          <target state="translated">揮発性組み込み関数は、I / Oメモリで動作することを目的とした操作を提供します。これは、他の揮発性組み込み関数間でコンパイラによって並べ替えられないことが保証されています。[ &lt;a href=&quot;http://llvm.org/docs/LangRef.html#volatile-memory-accesses&quot;&gt;volatile&lt;/a&gt; ]のLLVMドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="3879e8ab569a056c97968189092bda667116aee8" translate="yes" xml:space="preserve">
          <source>The volatile parameter is set to &lt;code&gt;true&lt;/code&gt;, so it will not be optimized out unless size is equal to zero.</source>
          <target state="translated">volatileパラメーターは &lt;code&gt;true&lt;/code&gt; に設定されているため、サイズがゼロに等しくない限り、最適化されません。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
