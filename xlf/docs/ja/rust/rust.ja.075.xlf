<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="1193137c297d5cbd26cbbc2bf90d52838e50813a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;String&lt;/code&gt; can grow in size and its contents can change, just like the contents of a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, if you push more data into it. In addition, you can conveniently use the &lt;code&gt;+&lt;/code&gt; operator or the &lt;code&gt;format!&lt;/code&gt; macro to concatenate &lt;code&gt;String&lt;/code&gt; values.</source>
          <target state="translated">A &lt;code&gt;String&lt;/code&gt; だけの内容のように、大きさに成長することができ、その内容を変更することができます &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 、あなたがより多くのデータをプッシュする場合は、それに。さらに、 &lt;code&gt;+&lt;/code&gt; 演算子または &lt;code&gt;format!&lt;/code&gt; &lt;code&gt;String&lt;/code&gt; 値を連結するマクロ。</target>
        </trans-unit>
        <trans-unit id="ad2a4c35b866459c9366f5bbd3c6f621ece58985" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;String&lt;/code&gt; is a wrapper over a &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt;. Let&amp;rsquo;s look at some of our properly encoded UTF-8 example strings from Listing 8-14. First, this one:</source>
          <target state="translated">あ &lt;code&gt;String&lt;/code&gt; のラッパーである &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; 。リスト8-14の適切にエンコードされたUTF-8サンプル文字列のいくつかを見てみましょう。まず、これ：</target>
        </trans-unit>
        <trans-unit id="dcd60f52764dfb12603585382f304c29b3d891eb" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;String&lt;/code&gt; is made up of three components: a pointer to some bytes, a length, and a capacity. The pointer points to an internal buffer &lt;code&gt;String&lt;/code&gt; uses to store its data. The length is the number of bytes currently stored in the buffer, and the capacity is the size of the buffer in bytes. As such, the length will always be less than or equal to the capacity.</source>
          <target state="translated">A &lt;code&gt;String&lt;/code&gt; いくつかのバイトへのポインタ、長さ、及び容量：3つのコンポーネントで構成されています。ポインタは、 &lt;code&gt;String&lt;/code&gt; がデータを格納するために使用する内部バッファを指します。長さは現在バッファに格納されているバイト数であり、容量はバイト単位のバッファのサイズです。そのため、長さは常に容量以下になります。</target>
        </trans-unit>
        <trans-unit id="2ad19c9717a97c44c08a93976b602e0990d24669" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;SystemTimeError&lt;/code&gt; is returned from the &lt;a href=&quot;struct.systemtime#method.duration_since&quot;&gt;&lt;code&gt;SystemTime::duration_since&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.systemtime#method.elapsed&quot;&gt;&lt;code&gt;SystemTime::elapsed&lt;/code&gt;&lt;/a&gt; methods whenever the second system time represents a point later in time than the &lt;code&gt;self&lt;/code&gt; of the method call.</source>
          <target state="translated">A &lt;code&gt;SystemTimeError&lt;/code&gt; がから返され&lt;a href=&quot;struct.systemtime#method.duration_since&quot;&gt; &lt;code&gt;SystemTime::duration_since&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;struct.systemtime#method.elapsed&quot;&gt; &lt;code&gt;SystemTime::elapsed&lt;/code&gt; &lt;/a&gt;方法たびに第2のシステム時間は、後の時間よりも点を表す &lt;code&gt;self&lt;/code&gt; メソッド呼び出しの。</target>
        </trans-unit>
        <trans-unit id="2815fef167ebe8b526c9b5e3287501b1039ea114" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;SystemTimeError&lt;/code&gt; is returned from the &lt;a href=&quot;struct.systemtime#method.duration_since&quot;&gt;&lt;code&gt;duration_since&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.systemtime#method.elapsed&quot;&gt;&lt;code&gt;elapsed&lt;/code&gt;&lt;/a&gt; methods of &lt;a href=&quot;struct.systemtime&quot;&gt;&lt;code&gt;SystemTime&lt;/code&gt;&lt;/a&gt; whenever the second system time represents a point later in time than the &lt;code&gt;self&lt;/code&gt; of the method call.</source>
          <target state="translated">A &lt;code&gt;SystemTimeError&lt;/code&gt; がから返され&lt;a href=&quot;struct.systemtime#method.duration_since&quot;&gt; &lt;code&gt;duration_since&lt;/code&gt; &lt;/a&gt;及び&lt;a href=&quot;struct.systemtime#method.elapsed&quot;&gt; &lt;code&gt;elapsed&lt;/code&gt; &lt;/a&gt;の方法&lt;a href=&quot;struct.systemtime&quot;&gt; &lt;code&gt;SystemTime&lt;/code&gt; &lt;/a&gt;第2のシステム時間よりも時間的に後の時点を表すときはいつでも &lt;code&gt;self&lt;/code&gt; メソッド呼び出しのを。</target>
        </trans-unit>
        <trans-unit id="f0e9bc60c4e3276e60ae09f7f961f64e01c5bfbd" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;ThreadId&lt;/code&gt; is an opaque object that has a unique value for each thread that creates one. &lt;code&gt;ThreadId&lt;/code&gt;s are not guaranteed to correspond to a thread's system-designated identifier. A &lt;code&gt;ThreadId&lt;/code&gt; can be retrieved from the &lt;a href=&quot;struct.thread#method.id&quot;&gt;&lt;code&gt;id&lt;/code&gt;&lt;/a&gt; method on a &lt;a href=&quot;struct.thread&quot;&gt;&lt;code&gt;Thread&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">A &lt;code&gt;ThreadId&lt;/code&gt; いずれかを作成するスレッドごとに一意の値を有する不透明なオブジェクトです。 &lt;code&gt;ThreadId&lt;/code&gt; は、スレッドのシステム指定の識別子に対応しているとは限りません。A &lt;code&gt;ThreadId&lt;/code&gt; から取得でき&lt;a href=&quot;struct.thread#method.id&quot;&gt; &lt;code&gt;id&lt;/code&gt; &lt;/a&gt; Aのメソッド&lt;a href=&quot;struct.thread&quot;&gt; &lt;code&gt;Thread&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b1818d010b7b29b87c4502d46870a6345ca3ee68" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;TypeId&lt;/code&gt; is currently only available for types which ascribe to &lt;code&gt;'static&lt;/code&gt;, but this limitation may be removed in the future.</source>
          <target state="translated">A &lt;code&gt;TypeId&lt;/code&gt; 現在のどの帰タイプに対してのみ利用可能である &lt;code&gt;'static&lt;/code&gt; が、この制限は、将来的に除去することができます。</target>
        </trans-unit>
        <trans-unit id="5b2832f9ef1617c1a164688031f12174b8e5931d" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;TypeId&lt;/code&gt; represents a globally unique identifier for a type.</source>
          <target state="translated">あ &lt;code&gt;TypeId&lt;/code&gt; タイプのグローバル一意識別子を表します。</target>
        </trans-unit>
        <trans-unit id="05e63a516d556e9577522a23860139fad9899875" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Vec&lt;/code&gt; can be mutable. Slices, on the other hand, are read-only objects. To get a &lt;a href=&quot;../primitive.slice&quot;&gt;slice&lt;/a&gt;, use &lt;a href=&quot;../primitive.reference&quot;&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/a&gt;. Example:</source>
          <target state="translated">A &lt;code&gt;Vec&lt;/code&gt; とは、可変することができます。一方、スライスは読み取り専用オブジェクトです。&lt;a href=&quot;../primitive.slice&quot;&gt;スライス&lt;/a&gt;を取得するには、&lt;a href=&quot;../primitive.reference&quot;&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; を&lt;/a&gt;使用します。例：</target>
        </trans-unit>
        <trans-unit id="345e82ed2183b66aaf325e8ad24887f5dd3ff3ad" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Vec&lt;/code&gt; can be mutable. Slices, on the other hand, are read-only objects. To get a slice, use &lt;code&gt;&amp;amp;&lt;/code&gt;. Example:</source>
          <target state="translated">A &lt;code&gt;Vec&lt;/code&gt; とは、可変することができます。一方、スライスは読み取り専用オブジェクトです。スライスを取得するには、 &lt;code&gt;&amp;amp;&lt;/code&gt; を。例：</target>
        </trans-unit>
        <trans-unit id="84a3e0757f03c2cf35d8f4ee02786937e5e0845a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Waker&lt;/code&gt; is a handle for waking up a task by notifying its executor that it is ready to be run.</source>
          <target state="translated">あ &lt;code&gt;Waker&lt;/code&gt; 実行される準備ができていること、その実行者に通知することによって、タスクを起床のハンドルです。</target>
        </trans-unit>
        <trans-unit id="d9bc289fc584bbfaef86d0de4ba94863300845d3" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Weak&lt;/code&gt; pointer is useful for keeping a temporary reference to the allocation managed by &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; without preventing its inner value from being dropped. It is also used to prevent circular references between &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; pointers, since mutual owning references would never allow either &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; to be dropped. For example, a tree could have strong &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; pointers from parent nodes to children, and &lt;code&gt;Weak&lt;/code&gt; pointers from children back to their parents.</source>
          <target state="translated">&lt;code&gt;Weak&lt;/code&gt; ポインタはによって管理割り当てを一時的に参照を維持するのに有用である&lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt;落下からその内の値を妨げることなく。また、相互に所有する参照によってどちらの&lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt;も削除されないため、&lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt;ポインター間の循環参照を防ぐためにも使用されます。たとえば、ツリーには、親ノードから子への強い&lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt;ポインターと、子から親への &lt;code&gt;Weak&lt;/code&gt; ポインターが含まれる可能性があります。</target>
        </trans-unit>
        <trans-unit id="a226c54ce6028079ee3f0e935344b03753cf6ea2" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Weak&lt;/code&gt; pointer is useful for keeping a temporary reference to the allocation managed by &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; without preventing its inner value from being dropped. It is also used to prevent circular references between &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointers, since mutual owning references would never allow either &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; to be dropped. For example, a tree could have strong &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointers from parent nodes to children, and &lt;code&gt;Weak&lt;/code&gt; pointers from children back to their parents.</source>
          <target state="translated">&lt;code&gt;Weak&lt;/code&gt; ポインタはによって管理割り当てを一時的に参照を維持するのに有用である&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; とを&lt;/a&gt;落下からその内の値を妨げることなく。また、相互所有の参照ではどちらの&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt;も削除できないため、&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt;ポインター間の循環参照を防ぐためにも使用されます。たとえば、ツリーには、親ノードから子への強い&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt;ポインターと、子から親への &lt;code&gt;Weak&lt;/code&gt; ポインターが含まれる可能性があります。</target>
        </trans-unit>
        <trans-unit id="92c5425b2664515a7d6b0bd3279f583d1e16c172" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Weak&lt;/code&gt; pointer is useful for keeping a temporary reference to the value within &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; without extending its lifetime. It is also used to prevent circular references between &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; pointers, since mutual owning references would never allow either &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; to be dropped. For example, a tree could have strong &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; pointers from parent nodes to children, and &lt;code&gt;Weak&lt;/code&gt; pointers from children back to their parents.</source>
          <target state="translated">&lt;code&gt;Weak&lt;/code&gt; ポインタは、内の値を一時的に参照を保持するのに有用である&lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt;の寿命を延長することなく。また、相互に所有している参照ではどちらの&lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt;も削除できないため、&lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt;ポインタ間の循環参照を防ぐためにも使用されます。たとえば、ツリーには、親ノードから子への強い&lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt;ポインターと、子から親への &lt;code&gt;Weak&lt;/code&gt; ポインターがあります。</target>
        </trans-unit>
        <trans-unit id="c317832e61e5046de4792c85bcf63089c251292c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Weak&lt;/code&gt; pointer is useful for keeping a temporary reference to the value within &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; without extending its lifetime. It is also used to prevent circular references between &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointers, since mutual owning references would never allow either &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; to be dropped. For example, a tree could have strong &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointers from parent nodes to children, and &lt;code&gt;Weak&lt;/code&gt; pointers from children back to their parents.</source>
          <target state="translated">&lt;code&gt;Weak&lt;/code&gt; ポインタは、内の値を一時的に参照を保持するのに有用である&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; の&lt;/a&gt;寿命を延長することなく。また、相互に所有している参照ではどちらの&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt;も削除できないため、&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt;ポインター間の循環参照を防ぐためにも使用されます。たとえば、ツリーには親ノードから子への強力な&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt;ポインターがあり、 &lt;code&gt;Weak&lt;/code&gt; から子への弱いポインターがあります。</target>
        </trans-unit>
        <trans-unit id="2ab6f5c59e2d0418f87950a3ebfb26ab14b557db" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;break&lt;/code&gt; expression is normally associated with the innermost &lt;code&gt;loop&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt; or &lt;code&gt;while&lt;/code&gt; loop enclosing the &lt;code&gt;break&lt;/code&gt; expression, but a &lt;a href=&quot;#loop-labels&quot;&gt;label&lt;/a&gt; can be used to specify which enclosing loop is affected. Example:</source>
          <target state="translated">&lt;code&gt;break&lt;/code&gt; 発現は、通常、最も内側に関連している &lt;code&gt;loop&lt;/code&gt; 、 &lt;code&gt;for&lt;/code&gt; 又は &lt;code&gt;while&lt;/code&gt; ループが囲む &lt;code&gt;break&lt;/code&gt; 発現が、&lt;a href=&quot;#loop-labels&quot;&gt;ラベルが&lt;/a&gt;影響を受ける囲むループを指定するために使用することができます。例：</target>
        </trans-unit>
        <trans-unit id="4bf74475c310d76b2da5f50f50fec722f68f826f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;break&lt;/code&gt; expression is normally associated with the innermost &lt;code&gt;loop&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt; or &lt;code&gt;while&lt;/code&gt; loop enclosing the &lt;code&gt;break&lt;/code&gt; expression, but a &lt;a href=&quot;loop-expr#loop-labels&quot;&gt;label&lt;/a&gt; can be used to specify which enclosing loop is affected. Example:</source>
          <target state="translated">&lt;code&gt;break&lt;/code&gt; 発現は、通常、最も内側に関連している &lt;code&gt;loop&lt;/code&gt; 、 &lt;code&gt;for&lt;/code&gt; 又は &lt;code&gt;while&lt;/code&gt; 囲むループ &lt;code&gt;break&lt;/code&gt; 発現が、A&lt;a href=&quot;loop-expr#loop-labels&quot;&gt;ラベルが&lt;/a&gt;影響を受ける囲むループを指定するために使用することができます。例：</target>
        </trans-unit>
        <trans-unit id="dc2182d07a207a24da6c811d0b8e308ce9f0619b" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;break&lt;/code&gt; expression is only permitted in the body of a loop, and has one of the forms &lt;code&gt;break&lt;/code&gt;, &lt;code&gt;break 'label&lt;/code&gt; or (&lt;a href=&quot;#break-and-loop-values&quot;&gt;see below&lt;/a&gt;) &lt;code&gt;break EXPR&lt;/code&gt; or &lt;code&gt;break 'label EXPR&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;break&lt;/code&gt; 発現は、ループの本体で許可されており、フォームのいずれか有している &lt;code&gt;break&lt;/code&gt; 、 &lt;code&gt;break 'label&lt;/code&gt; 又は（&lt;a href=&quot;#break-and-loop-values&quot;&gt;下記参照&lt;/a&gt;） &lt;code&gt;break EXPR&lt;/code&gt; 又は &lt;code&gt;break 'label EXPR&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1929ca3782f20314772673eb1b3076f6e73f81b3" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;break&lt;/code&gt; expression is only permitted in the body of a loop, and has one of the forms &lt;code&gt;break&lt;/code&gt;, &lt;code&gt;break 'label&lt;/code&gt; or (&lt;a href=&quot;loop-expr#break-and-loop-values&quot;&gt;see below&lt;/a&gt;) &lt;code&gt;break EXPR&lt;/code&gt; or &lt;code&gt;break 'label EXPR&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;break&lt;/code&gt; 発現は、ループの本体で許可されており、フォームのいずれか有している &lt;code&gt;break&lt;/code&gt; 、 &lt;code&gt;break 'label&lt;/code&gt; 又は（&lt;a href=&quot;loop-expr#break-and-loop-values&quot;&gt;下記参照&lt;/a&gt;） &lt;code&gt;break EXPR&lt;/code&gt; 又は &lt;code&gt;break 'label EXPR&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f212565caf5ca5d26733a24ecd450094943708a5" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;break&lt;/code&gt; statement with an argument appeared in a non-&lt;code&gt;loop&lt;/code&gt; loop.</source>
          <target state="translated">引数付きの &lt;code&gt;break&lt;/code&gt; ステートメントが非 &lt;code&gt;loop&lt;/code&gt; ループに現れました。</target>
        </trans-unit>
        <trans-unit id="0719aea9e00a3f18488e8dec397e352b5e69370a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;break&lt;/code&gt; statement without a label appeared inside a labeled block.</source>
          <target state="translated">ラベルなしの &lt;code&gt;break&lt;/code&gt; ステートメントがラベル付きブロック内に表示されました。</target>
        </trans-unit>
        <trans-unit id="3cd69f4f6c3139636621e0e9a9e16305bdb70d6f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;char&lt;/code&gt; is a &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode Scalar Value&lt;/a&gt;, which means that it is a &lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt;Code Point&lt;/a&gt;, but only ones within a certain range. &lt;code&gt;MAX&lt;/code&gt; is the highest valid code point that's a valid &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode Scalar Value&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; がある&lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicodeのスカラー値&lt;/a&gt;があることを意味し、&lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt;コードポイント&lt;/a&gt;が、一定の範囲内で唯一のもの。 &lt;code&gt;MAX&lt;/code&gt; は、有効な&lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicodeスカラー値で&lt;/a&gt;ある最も高い有効なコードポイントです。</target>
        </trans-unit>
        <trans-unit id="6de9c91a3e0c1eb1015d4865a476f244ccddf52f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;const&lt;/code&gt; represents a constant value that should never change. If one takes a &lt;code&gt;&amp;amp;&lt;/code&gt; reference to the constant, then one is taking a pointer to some memory location containing the value. Normally this is perfectly fine: most values can't be changed via a shared &lt;code&gt;&amp;amp;&lt;/code&gt; pointer, but interior mutability would allow it. That is, a constant value could be mutated. On the other hand, a &lt;code&gt;static&lt;/code&gt; is explicitly a single memory location, which can be mutated at will.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; が変化することはありません一定の値を表しています。一方がかかる場合 &lt;code&gt;&amp;amp;&lt;/code&gt; 定数への参照を、次いで一つは値を含むいくつかのメモリ位置へのポインタを取っています。通常、これは完全に問題ありません。ほとんどの値は共有 &lt;code&gt;&amp;amp;&lt;/code&gt; ポインタを介して変更できませんが、内部の可変性により可能です。つまり、定数値が変更される可能性があります。一方、 &lt;code&gt;static&lt;/code&gt; は明示的に単一のメモリ位置であり、自由に変更できます。</target>
        </trans-unit>
        <trans-unit id="fcf892710236415af0f5e027b5569143cb3933af" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;for&lt;/code&gt; expression is a syntactic construct for looping over elements provided by an implementation of &lt;code&gt;std::iter::IntoIterator&lt;/code&gt;. If the iterator yields a value, that value is given the specified name and the body of the loop is executed, then control returns to the head of the &lt;code&gt;for&lt;/code&gt; loop. If the iterator is empty, the &lt;code&gt;for&lt;/code&gt; expression completes.</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; 式は、実装によって提供される要素上ループのシンタックス構造である &lt;code&gt;std::iter::IntoIterator&lt;/code&gt; 。イテレータが値を生成し、その値に指定された名前が付けられ、ループの本体が実行されると、制御は &lt;code&gt;for&lt;/code&gt; ループの先頭に戻ります。イテレータが空の場合、 &lt;code&gt;for&lt;/code&gt; 式は完了します。</target>
        </trans-unit>
        <trans-unit id="7cc2ad054c8700f44ee39d9eb760a19117e088af" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;for&lt;/code&gt; expression is a syntactic construct for looping over elements provided by an implementation of &lt;code&gt;std::iter::IntoIterator&lt;/code&gt;. If the iterator yields a value, that value is matched against the irrefutable pattern, the body of the loop is executed, and then control returns to the head of the &lt;code&gt;for&lt;/code&gt; loop. If the iterator is empty, the &lt;code&gt;for&lt;/code&gt; expression completes.</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; 式は、実装によって提供される要素上ループのシンタックス構造である &lt;code&gt;std::iter::IntoIterator&lt;/code&gt; 。イテレータが値を生成すると、その値は反駁できないパターンと照合され、ループの本体が実行されてから、制御が &lt;code&gt;for&lt;/code&gt; ループの先頭に戻ります。イテレータが空の場合、 &lt;code&gt;for&lt;/code&gt; 式は完了します。</target>
        </trans-unit>
        <trans-unit id="d73920ce8bc8796a34637626ebd1ee2bfe7e1d77" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;for&lt;/code&gt; loop expands as shown:</source>
          <target state="translated">A &lt;code&gt;for&lt;/code&gt; ループ膨張示すように：</target>
        </trans-unit>
        <trans-unit id="0dcdc530771d15a6a0db69b3817439a78d80a1af" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;loop&lt;/code&gt; expression repeats execution of its body continuously: &lt;code&gt;loop { println!(&quot;I live.&quot;); }&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;loop&lt;/code&gt; 式は、継続的にその本体の実行を繰り返し： &lt;code&gt;loop { println!(&quot;I live.&quot;); }&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d617ef5af3dab30c4c49b4baffa8bfa3c5f2ec66" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;loop&lt;/code&gt; expression without an associated &lt;code&gt;break&lt;/code&gt; expression is diverging and has type &lt;a href=&quot;../types/never&quot;&gt;&lt;code&gt;!&lt;/code&gt;&lt;/a&gt;. A &lt;code&gt;loop&lt;/code&gt; expression containing associated &lt;a href=&quot;#break-expressions&quot;&gt;&lt;code&gt;break&lt;/code&gt; expression(s)&lt;/a&gt; may terminate, and must have type compatible with the value of the &lt;code&gt;break&lt;/code&gt; expression(s).</source>
          <target state="translated">&lt;code&gt;loop&lt;/code&gt; 、関連のない表現 &lt;code&gt;break&lt;/code&gt; 式が発散して型を持ってさ&lt;a href=&quot;../types/never&quot;&gt; &lt;code&gt;!&lt;/code&gt; &lt;/a&gt;。 &lt;code&gt;loop&lt;/code&gt; 関連含む発現&lt;a href=&quot;#break-expressions&quot;&gt; &lt;code&gt;break&lt;/code&gt; 式（S）が&lt;/a&gt;終了することができる、との値と互換性が入力しておく必要があり &lt;code&gt;break&lt;/code&gt; 式（S）です。</target>
        </trans-unit>
        <trans-unit id="e36c323c7511710c9caa566121cf59ed62c95bef" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;loop&lt;/code&gt; expression without an associated &lt;code&gt;break&lt;/code&gt; expression is diverging and has type &lt;a href=&quot;../types/never&quot;&gt;&lt;code&gt;!&lt;/code&gt;&lt;/a&gt;. A &lt;code&gt;loop&lt;/code&gt; expression containing associated &lt;a href=&quot;loop-expr#break-expressions&quot;&gt;&lt;code&gt;break&lt;/code&gt; expression(s)&lt;/a&gt; may terminate, and must have type compatible with the value of the &lt;code&gt;break&lt;/code&gt; expression(s).</source>
          <target state="translated">&lt;code&gt;loop&lt;/code&gt; 、関連のない表現 &lt;code&gt;break&lt;/code&gt; 式が発散して型を持ってさ&lt;a href=&quot;../types/never&quot;&gt; &lt;code&gt;!&lt;/code&gt; &lt;/a&gt;。 &lt;code&gt;loop&lt;/code&gt; 関連含む発現&lt;a href=&quot;loop-expr#break-expressions&quot;&gt; &lt;code&gt;break&lt;/code&gt; 式（S）が&lt;/a&gt;終了することができる、との値と互換性が入力しておく必要があり &lt;code&gt;break&lt;/code&gt; 式（S）です。</target>
        </trans-unit>
        <trans-unit id="27cdf38632ff8742feaafa6612389bb67003ed19" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;match&lt;/code&gt; behaves differently depending on whether or not the scrutinee expression is a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place expression or value expression&lt;/a&gt;. If the scrutinee expression is a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;value expression&lt;/a&gt;, it is first evaluated into a temporary location, and the resulting value is sequentially compared to the patterns in the arms until a match is found. The first arm with a matching pattern is chosen as the branch target of the &lt;code&gt;match&lt;/code&gt;, any variables bound by the pattern are assigned to local variables in the arm's block, and control enters the block.</source>
          <target state="translated">&lt;code&gt;match&lt;/code&gt; scrutinee式があるかどうかに応じて、異なった動作を&lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;場所式または値式&lt;/a&gt;。 scrutinee式が&lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;value式の&lt;/a&gt;場合、最初に一時的な場所で評価され、結果の値は、一致が見つかるまで腕のパターンと順次比較されます。一致するパターンを持つ最初のアームが &lt;code&gt;match&lt;/code&gt; の分岐ターゲットとして選択され、パターンによってバインドされたすべての変数がアームのブロックのローカル変数に割り当てられ、コントロールがブロックに入ります。</target>
        </trans-unit>
        <trans-unit id="9d65cf4e1e473919c3773c077a67170ac8398876" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;match&lt;/code&gt; expression is made up of &lt;em&gt;arms&lt;/em&gt;. An arm consists of a &lt;em&gt;pattern&lt;/em&gt; and the code that should be run if the value given to the beginning of the &lt;code&gt;match&lt;/code&gt; expression fits that arm&amp;rsquo;s pattern. Rust takes the value given to &lt;code&gt;match&lt;/code&gt; and looks through each arm&amp;rsquo;s pattern in turn. The &lt;code&gt;match&lt;/code&gt; construct and patterns are powerful features in Rust that let you express a variety of situations your code might encounter and make sure that you handle them all. These features will be covered in detail in Chapter 6 and Chapter 18, respectively.</source>
          <target state="translated">&lt;code&gt;match&lt;/code&gt; 式は、で構成されている&lt;em&gt;武器&lt;/em&gt;。アームは、&lt;em&gt;パターン&lt;/em&gt;と、 &lt;code&gt;match&lt;/code&gt; 式の先頭に指定された値がそのアームのパターンに適合する場合に実行されるコードで構成されます。Rustは &lt;code&gt;match&lt;/code&gt; 指定された値を取得し、各腕のパターンを順に調べます。 &lt;code&gt;match&lt;/code&gt; 構築物およびパターンは、あなたがあなたのコードが発生し、あなたがそれらすべてを扱うことになるかもしれないさまざまな状況を表現してみましょうルスト強力な機能です。これらの機能については、それぞれ第6章と第18章で詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="2653905e02c1a5978b97c0dfd21c1d160c036b3e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;repr(transparent)&lt;/code&gt; type was also annotated with other, incompatible representation hints.</source>
          <target state="translated">&lt;code&gt;repr(transparent)&lt;/code&gt; タイプは、他の、互換性のない表現ヒントで注釈しました。</target>
        </trans-unit>
        <trans-unit id="c5a4ca7ea6b5bc0339d74f8626989e641c9a4f2a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;return&lt;/code&gt; marks the end of an execution path in a function:</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt; マーク機能で実行パスの終わり：</target>
        </trans-unit>
        <trans-unit id="d04d984159639545c2a9b782d494bbc89f68eb09" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;enum&lt;/code&gt;, or &lt;code&gt;union&lt;/code&gt; which was defined in the current crate. This is not affected by applied type arguments. &lt;code&gt;struct Foo&lt;/code&gt; is considered local, but &lt;code&gt;Vec&amp;lt;Foo&amp;gt;&lt;/code&gt; is not. &lt;code&gt;LocalType&amp;lt;ForeignType&amp;gt;&lt;/code&gt; is local. Type aliases do not affect locality.</source>
          <target state="translated">&lt;code&gt;struct&lt;/code&gt; 、 &lt;code&gt;enum&lt;/code&gt; 、または &lt;code&gt;union&lt;/code&gt; 現在のクレートに定義されました。これは、適用された型引数の影響を受けません。 &lt;code&gt;struct Foo&lt;/code&gt; はローカルと見なされますが、 &lt;code&gt;Vec&amp;lt;Foo&amp;gt;&lt;/code&gt; はローカルとは見なされません。 &lt;code&gt;LocalType&amp;lt;ForeignType&amp;gt;&lt;/code&gt; はローカルです。タイプエイリアスはローカリティに影響しません。</target>
        </trans-unit>
        <trans-unit id="0bcaf88ff1b66b63413f83d3b7d32c0a7ea7cbfe" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;struct&lt;/code&gt;&lt;em&gt;type&lt;/em&gt; is a heterogeneous product of other types, called the &lt;em&gt;fields&lt;/em&gt; of the type.&lt;sup&gt;&lt;a href=&quot;#structtype&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">&lt;code&gt;struct&lt;/code&gt; &lt;em&gt;タイプは、&lt;/em&gt;と呼ばれる他のタイプの不均一な生成物である&lt;em&gt;フィールド&lt;/em&gt;タイプの。&lt;sup&gt;&lt;a href=&quot;#structtype&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="e983e7b3d7471c078bb152c54f1d0e490ae64bff" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;struct&lt;/code&gt;&lt;em&gt;type&lt;/em&gt; is a heterogeneous product of other types, called the &lt;em&gt;fields&lt;/em&gt; of the type.&lt;sup&gt;&lt;a href=&quot;struct#structtype&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">&lt;code&gt;struct&lt;/code&gt; &lt;em&gt;タイプは、&lt;/em&gt;と呼ばれる他のタイプの不均一な生成物である&lt;em&gt;フィールド&lt;/em&gt;タイプの。&lt;sup&gt;&lt;a href=&quot;struct#structtype&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="5dc372cb983e81c62a84e7d307e5c691468779fc" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;trait&lt;/code&gt; is like an interface that data types can implement. When a type implements a trait it can be treated abstractly as that trait using generics or trait objects.</source>
          <target state="translated">&lt;code&gt;trait&lt;/code&gt; データ型が実装できるというインターフェースのようなものです。タイプがトレイトを実装する場合、ジェネリックスまたはトレイトオブジェクトを使用して、そのトレイトとして抽象的に扱うことができます。</target>
        </trans-unit>
        <trans-unit id="2ad87d3d4edf2b4861565127275e5ad1afc1a755" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;trait&lt;/code&gt; which was defined in the current crate. A trait definition is local or not independent of applied type arguments. Given &lt;code&gt;trait Foo&amp;lt;T, U&amp;gt;&lt;/code&gt;, &lt;code&gt;Foo&lt;/code&gt; is always local, regardless of the types substituted for &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;trait&lt;/code&gt; 現在クレートで定義されました。トレイト定義はローカルであるか、適用された型引数から独立していません。 &lt;code&gt;trait Foo&amp;lt;T, U&amp;gt;&lt;/code&gt; 与えられた場合、 &lt;code&gt;T&lt;/code&gt; と &lt;code&gt;U&lt;/code&gt; の代わりに使用されるタイプに関係なく、 &lt;code&gt;Foo&lt;/code&gt; は常にローカルです。</target>
        </trans-unit>
        <trans-unit id="99ab68cda9330ceba3e059532d454bd1454a3c76" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;union&lt;/code&gt; cannot have fields with destructors.</source>
          <target state="translated">&lt;code&gt;union&lt;/code&gt; デストラクタを持つフィールドを持つことはできません。</target>
        </trans-unit>
        <trans-unit id="7456e28e3269b8fcb15b4e8220467fa67683b4bd" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;union&lt;/code&gt; is similar to a &lt;code&gt;struct&lt;/code&gt;, but only one declared field is used in a particular instance at one time. Unions are primarily used to interface with unions in C code. Accessing union fields is unsafe because Rust can&amp;rsquo;t guarantee the type of the data currently being stored in the union instance. You can learn more about unions in &lt;a href=&quot;../reference/items/unions&quot;&gt;the reference&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;union&lt;/code&gt; に似ている &lt;code&gt;struct&lt;/code&gt; が、一つだけの宣言フィールドを一度に特定のインスタンスで使用されています。ユニオンは主に、Cコードのユニオンとのインターフェースに使用されます。Rustは、現在ユニオンインスタンスに格納されているデータのタイプを保証できないため、ユニオンフィールドへのアクセスは安全ではありません。ユニオンについて詳しくは&lt;a href=&quot;../reference/items/unions&quot;&gt;、リファレンスを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="d933644dc98827f86adb027ad1edada503180c92" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;union&lt;/code&gt; looks like a &lt;a href=&quot;keyword.struct&quot;&gt;&lt;code&gt;struct&lt;/code&gt;&lt;/a&gt; in terms of declaration, but all of its fields exist in the same memory, superimposed over one another. For instance, if we wanted some bits in memory that we sometimes interpret as a &lt;code&gt;u32&lt;/code&gt; and sometimes as an &lt;code&gt;f32&lt;/code&gt;, we could write:</source>
          <target state="translated">&lt;code&gt;union&lt;/code&gt; のように見える&lt;a href=&quot;keyword.struct&quot;&gt; &lt;code&gt;struct&lt;/code&gt; &lt;/a&gt;宣言の面ではなく、そのフィールドの全ては、互いに上に重ね、同じメモリ内に存在します。例えば、我々は時々として解釈することをメモリ内にいくつかのビットを望んでいた場合 &lt;code&gt;u32&lt;/code&gt; 、時にはとして &lt;code&gt;f32&lt;/code&gt; 、我々は書くことができます：</target>
        </trans-unit>
        <trans-unit id="aae4dfd16f669123c1df46acb99529aa8db4f78e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;union&lt;/code&gt; was declared with fields with destructors.</source>
          <target state="translated">&lt;code&gt;union&lt;/code&gt; デストラクタを持つフィールドで宣言されました。</target>
        </trans-unit>
        <trans-unit id="31174f5a2be478aaee87f1f4ce26d9142eeb339c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;while let&lt;/code&gt; loop is equivalent to a &lt;code&gt;loop&lt;/code&gt; expression containing a &lt;a href=&quot;match-expr&quot;&gt;&lt;code&gt;match&lt;/code&gt; expression&lt;/a&gt; as follows.</source>
          <target state="translated">&lt;code&gt;while let&lt;/code&gt; ループに相当する &lt;code&gt;loop&lt;/code&gt; を含む発現&lt;a href=&quot;match-expr&quot;&gt; &lt;code&gt;match&lt;/code&gt; 式を&lt;/a&gt;次のように。</target>
        </trans-unit>
        <trans-unit id="132dd0b4198a0332783e039cb830e80e3a95c535" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;while let&lt;/code&gt; loop is semantically similar to a &lt;code&gt;while&lt;/code&gt; loop but in place of a condition expression it expects the keyword &lt;code&gt;let&lt;/code&gt; followed by a pattern, an &lt;code&gt;=&lt;/code&gt;, a &lt;a href=&quot;../glossary#scrutinee&quot;&gt;scrutinee&lt;/a&gt; expression and a block expression. If the value of the scrutinee matches the pattern, the loop body block executes then control returns to the pattern matching statement. Otherwise, the while expression completes.</source>
          <target state="translated">A &lt;code&gt;while let&lt;/code&gt; ループと意味的に類似している &lt;code&gt;while&lt;/code&gt; ループが、それはキーワード予期条件式の代わりに &lt;code&gt;let&lt;/code&gt; 、パターンが続く &lt;code&gt;=&lt;/code&gt; 、&lt;a href=&quot;../glossary#scrutinee&quot;&gt;scrutineeの&lt;/a&gt;発現およびブロック発現。scrutineeの値がパターンに一致する場合、ループ本体ブロックが実行され、制御はパターンマッチングステートメントに戻ります。それ以外の場合、while式は完了します。</target>
        </trans-unit>
        <trans-unit id="718179093a0d6e082dbdc6f07f43775afb09f0f9" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;while&lt;/code&gt; expression is used for predicate loops. The &lt;code&gt;while&lt;/code&gt; expression runs the conditional expression before running the loop body, then runs the loop body if the conditional expression evaluates to &lt;code&gt;true&lt;/code&gt;, or exits the loop otherwise.</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt; 表現は、述語ループのために使用されます。 &lt;code&gt;while&lt;/code&gt; 式はループ本体を実行する前に条件式を実行し、条件式を評価された場合、その後にループ本体を実行し &lt;code&gt;true&lt;/code&gt; 、またはそれ以外の場合はループを抜けます。</target>
        </trans-unit>
        <trans-unit id="283fcf53585988268a7d68d52030cb117688b529" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;while&lt;/code&gt; loop begins by evaluating the boolean loop conditional expression. If the loop conditional expression evaluates to &lt;code&gt;true&lt;/code&gt;, the loop body block executes, then control returns to the loop conditional expression. If the loop conditional expression evaluates to &lt;code&gt;false&lt;/code&gt;, the &lt;code&gt;while&lt;/code&gt; expression completes.</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt; ループは、ブールループ条件式を評価することによって始まります。ループ条件式の評価が &lt;code&gt;true&lt;/code&gt; の場合、ループ本体ブロックが実行され、制御はループ条件式に戻ります。ループ条件式が &lt;code&gt;false&lt;/code&gt; と評価されると、 &lt;code&gt;while&lt;/code&gt; 式が完了します。</target>
        </trans-unit>
        <trans-unit id="9024dfdf6115f20a47566e1a178072686b644d4c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;yield&lt;/code&gt; clause was used in an &lt;code&gt;async&lt;/code&gt; context.</source>
          <target state="translated">&lt;code&gt;yield&lt;/code&gt; 句を使用した &lt;code&gt;async&lt;/code&gt; コンテキスト。</target>
        </trans-unit>
        <trans-unit id="9a98030fcb71c42d6137c8ff5fae0192e67a25d8" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;24-bit code point escape&lt;/em&gt; starts with &lt;code&gt;U+0075&lt;/code&gt; (&lt;code&gt;u&lt;/code&gt;) and is followed by up to six &lt;em&gt;hex digits&lt;/em&gt; surrounded by braces &lt;code&gt;U+007B&lt;/code&gt; (&lt;code&gt;{&lt;/code&gt;) and &lt;code&gt;U+007D&lt;/code&gt; (&lt;code&gt;}&lt;/code&gt;). It denotes the Unicode code point equal to the provided hex value.</source>
          <target state="translated">&lt;em&gt;24ビットコードポイントエスケープ&lt;/em&gt;と開始 &lt;code&gt;U+0075&lt;/code&gt; （ &lt;code&gt;u&lt;/code&gt; ）六のまで続いて&lt;em&gt;進数字が&lt;/em&gt;括弧に囲まれた &lt;code&gt;U+007B&lt;/code&gt; （ &lt;code&gt;{&lt;/code&gt; ）と &lt;code&gt;U+007D&lt;/code&gt; （ &lt;code&gt;}&lt;/code&gt; ）。これは、提供された16進値に等しいUnicodeコードポイントを示します。</target>
        </trans-unit>
        <trans-unit id="869073214f1b9edb093744ef355f142778b07763" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;7-bit code point escape&lt;/em&gt; starts with &lt;code&gt;U+0078&lt;/code&gt; (&lt;code&gt;x&lt;/code&gt;) and is followed by exactly two &lt;em&gt;hex digits&lt;/em&gt; with value up to &lt;code&gt;0x7F&lt;/code&gt;. It denotes the ASCII character with value equal to the provided hex value. Higher values are not permitted because it is ambiguous whether they mean Unicode code points or byte values.</source>
          <target state="translated">&lt;em&gt;7ビットのコードポイントエスケープが&lt;/em&gt;始まる &lt;code&gt;U+0078&lt;/code&gt; （ &lt;code&gt;x&lt;/code&gt; ）とちょうど二つ続いて&lt;em&gt;進数字&lt;/em&gt;の値までと &lt;code&gt;0x7F&lt;/code&gt; の。これは、指定された16進値に等しい値を持つASCII文字を示します。 Unicodeコードポイントを意味するのか、バイト値を意味するのかが不明確であるため、これより高い値は許可されません。</target>
        </trans-unit>
        <trans-unit id="ba5e9b49178a0e6b5d252044b97fef65592fc293" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;&lt;code&gt;let&lt;/code&gt; statement&lt;/em&gt; introduces a new set of &lt;a href=&quot;variables&quot;&gt;variables&lt;/a&gt;, given by a &lt;a href=&quot;patterns&quot;&gt;pattern&lt;/a&gt;. The pattern is followed optionally by a type annotation and then optionally by an initializer expression. When no type annotation is given, the compiler will infer the type, or signal an error if insufficient type information is available for definite inference. Any variables introduced by a variable declaration are visible from the point of declaration until the end of the enclosing block scope.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;let&lt;/code&gt; 文は、&lt;/em&gt;一連の新しい導入し&lt;a href=&quot;variables&quot;&gt;た変数&lt;/a&gt;で与えられ、&lt;a href=&quot;patterns&quot;&gt;パターンを&lt;/a&gt;。パターンの後にはオプションで型注釈が続き、オプションで初期化子式が続きます。型注釈が指定されていない場合、コンパイラーは型を推論するか、十分な型情報が明確な推論に利用できない場合はエラーを通知します。変数宣言によって導入された変数は、宣言の時点から、それを囲むブロックスコープの終わりまで表示されます。</target>
        </trans-unit>
        <trans-unit id="8ca18f2a30c6ddfd6e41efbe967d1604f354b083" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;&lt;code&gt;let&lt;/code&gt; statement&lt;/em&gt; introduces a new set of &lt;a href=&quot;variables&quot;&gt;variables&lt;/a&gt;, given by an irrefutable &lt;a href=&quot;patterns&quot;&gt;pattern&lt;/a&gt;. The pattern is followed optionally by a type annotation and then optionally by an initializer expression. When no type annotation is given, the compiler will infer the type, or signal an error if insufficient type information is available for definite inference. Any variables introduced by a variable declaration are visible from the point of declaration until the end of the enclosing block scope.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;let&lt;/code&gt; 文は、&lt;/em&gt;一連の新しい導入し&lt;a href=&quot;variables&quot;&gt;た変数&lt;/a&gt;反駁によって与えられ、&lt;a href=&quot;patterns&quot;&gt;パターンを&lt;/a&gt;。パターンの後には、オプションで型注釈が続き、オプションで初期化式が続きます。型注釈が指定されていない場合、コンパイラーは型を推論するか、明確な推論に利用できる型情報が不十分な場合はエラーを通知します。変数宣言によって導入された変数は、宣言のポイントからそれを囲むブロックスコープの終わりまで表示されます。</target>
        </trans-unit>
        <trans-unit id="4965d161e4fa0b76aa8e253a8b735c3ef6585135" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;&lt;code&gt;match&lt;/code&gt; expression&lt;/em&gt; branches on a pattern. The exact form of matching that occurs depends on the &lt;a href=&quot;../patterns&quot;&gt;pattern&lt;/a&gt;. A &lt;code&gt;match&lt;/code&gt; expression has a &lt;em&gt;&lt;a href=&quot;../glossary#scrutinee&quot;&gt;scrutinee&lt;/a&gt; expression&lt;/em&gt;, which is the value to compare to the patterns. The scrutinee expression and the patterns must have the same type.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;match&lt;/code&gt; 表現&lt;/em&gt;パターンに分岐します。発生するマッチングの正確な形式は、&lt;a href=&quot;../patterns&quot;&gt;パターン&lt;/a&gt;によって異なります。 &lt;code&gt;match&lt;/code&gt; 発現が有する&lt;em&gt;&lt;a href=&quot;../glossary#scrutinee&quot;&gt;scrutineeの&lt;/a&gt;発現&lt;/em&gt;パターンと比較する値です。scrutinee式とパターンは同じ型でなければなりません。</target>
        </trans-unit>
        <trans-unit id="58385518472acdb41b644cab1601f90a746d55aa" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;binary literal&lt;/em&gt; starts with the character sequence &lt;code&gt;U+0030&lt;/code&gt;&lt;code&gt;U+0062&lt;/code&gt; (&lt;code&gt;0b&lt;/code&gt;) and continues as any mixture (with at least one digit) of binary digits and underscores.</source>
          <target state="translated">&lt;em&gt;バイナリリテラル&lt;/em&gt;文字列で始まる &lt;code&gt;U+0030&lt;/code&gt; &lt;code&gt;U+0062&lt;/code&gt; （ &lt;code&gt;0b&lt;/code&gt; ）とは二進数字および下線の（少なくとも一桁で）任意の混合物として継続します。</target>
        </trans-unit>
        <trans-unit id="e1bc1112f211249d5a018412bd10ed929678eeda" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;block expression&lt;/em&gt;, or &lt;em&gt;block&lt;/em&gt;, is a control flow expression and anonymous namespace scope for items and variable declarations. As a control flow expression, a block sequentially executes its component non-item declaration statements and then its final optional expression. As an anonymous namespace scope, item declarations are only in scope inside the block itself and variables declared by &lt;code&gt;let&lt;/code&gt; statements are in scope from the next statement until the end of the block.</source>
          <target state="translated">&lt;em&gt;ブロック式&lt;/em&gt;、または&lt;em&gt;ブロック&lt;/em&gt;、アイテム、および変数宣言のための制御フロー式と匿名名前空間の範囲です。制御フロー式として、ブロックはそのコンポーネントの非項目宣言ステートメントを順番に実行し、次にその最後のオプションの式を実行します。匿名の名前空間スコープとして、アイテム宣言はブロック自体のスコープ内のみにあり、 &lt;code&gt;let&lt;/code&gt; ステートメントによって宣言された変数は、次のステートメントからブロックの終わりまでスコープ内にあります。</target>
        </trans-unit>
        <trans-unit id="d959096d425f9582c596a1eece69230b21ea3b75" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;byte escape&lt;/em&gt; escape starts with &lt;code&gt;U+0078&lt;/code&gt; (&lt;code&gt;x&lt;/code&gt;) and is followed by exactly two &lt;em&gt;hex digits&lt;/em&gt;. It denotes the byte equal to the provided hex value.</source>
          <target state="translated">&lt;em&gt;バイトエスケープ&lt;/em&gt;エスケープが始まる &lt;code&gt;U+0078&lt;/code&gt; （ &lt;code&gt;x&lt;/code&gt; ）とちょうど二つ続いて&lt;em&gt;進数字&lt;/em&gt;。これは、提供された16進値に等しいバイトを示します。</target>
        </trans-unit>
        <trans-unit id="08d56300cad1166d8bb2fb927ceda10d77863d64" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;byte literal&lt;/em&gt; is a single ASCII character (in the &lt;code&gt;U+0000&lt;/code&gt; to &lt;code&gt;U+007F&lt;/code&gt; range) or a single &lt;em&gt;escape&lt;/em&gt; preceded by the characters &lt;code&gt;U+0062&lt;/code&gt; (&lt;code&gt;b&lt;/code&gt;) and &lt;code&gt;U+0027&lt;/code&gt; (single-quote), and followed by the character &lt;code&gt;U+0027&lt;/code&gt;. If the character &lt;code&gt;U+0027&lt;/code&gt; is present within the literal, it must be &lt;em&gt;escaped&lt;/em&gt; by a preceding &lt;code&gt;U+005C&lt;/code&gt; (&lt;code&gt;\&lt;/code&gt;) character. It is equivalent to a &lt;code&gt;u8&lt;/code&gt; unsigned 8-bit integer &lt;em&gt;number literal&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;バイトリテラルは、&lt;/em&gt;（単一のASCII文字である &lt;code&gt;U+0000&lt;/code&gt; に &lt;code&gt;U+007F&lt;/code&gt; の範囲）またはシングル&lt;em&gt;エスケープ&lt;/em&gt;文字によって先行 &lt;code&gt;U+0062&lt;/code&gt; （ &lt;code&gt;b&lt;/code&gt; ）と &lt;code&gt;U+0027&lt;/code&gt; の文字によって（単一引用符）、及び続く &lt;code&gt;U+0027&lt;/code&gt; 。文字 &lt;code&gt;U+0027&lt;/code&gt; がリテラル内にある場合&lt;em&gt;は&lt;/em&gt;、先行する &lt;code&gt;U+005C&lt;/code&gt; （ &lt;code&gt;\&lt;/code&gt; ）文字で&lt;em&gt;エスケープ&lt;/em&gt;する必要があります。これは、 &lt;code&gt;u8&lt;/code&gt; 符号なし8ビット整数&lt;em&gt;リテラル&lt;/em&gt;と同等です。</target>
        </trans-unit>
        <trans-unit id="82cbcd824290282b86dc09637a06221aa40fcffe" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;call expression&lt;/em&gt; consists of an expression followed by a parenthesized expression-list. It invokes a function, providing zero or more input variables. If the function eventually returns, then the expression completes. For &lt;a href=&quot;../types/function-item&quot;&gt;non-function types&lt;/a&gt;, the expression f(...) uses the method on one of the &lt;a href=&quot;../../std/ops/trait.fn&quot;&gt;&lt;code&gt;std::ops::Fn&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt;&lt;code&gt;std::ops::FnMut&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../std/ops/trait.fnonce&quot;&gt;&lt;code&gt;std::ops::FnOnce&lt;/code&gt;&lt;/a&gt; traits, which differ in whether they take the type by reference, mutable reference, or take ownership respectively. An automatic borrow will be taken if needed. Rust will also automatically dereference &lt;code&gt;f&lt;/code&gt; as required. Some examples of call expressions:</source>
          <target state="translated">&lt;em&gt;呼び出し式は&lt;/em&gt;括弧で囲まれた式リストに続く表現で構成されています。関数を呼び出し、0個以上の入力変数を提供します。関数が最終的に戻ると、式は完了します。以下のための&lt;a href=&quot;../types/function-item&quot;&gt;非関数型&lt;/a&gt;、式f（...）のいずれかの方法を使用して&lt;a href=&quot;../../std/ops/trait.fn&quot;&gt; &lt;code&gt;std::ops::Fn&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt; &lt;code&gt;std::ops::FnMut&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;../../std/ops/trait.fnonce&quot;&gt; &lt;code&gt;std::ops::FnOnce&lt;/code&gt; &lt;/a&gt;かどうかが異なる特性、これらは、参照による型、変更可能な参照、または所有権をそれぞれ取得します。必要に応じて、自動借用が行われます。 Rustは、必要に応じて &lt;code&gt;f&lt;/code&gt; を自動的に逆参照します。呼び出し式の例：</target>
        </trans-unit>
        <trans-unit id="30fdc766ea9fe7cd1ba45798e3f6d282c53ef441" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;character literal&lt;/em&gt; is a single Unicode character enclosed within two &lt;code&gt;U+0027&lt;/code&gt; (single-quote) characters, with the exception of &lt;code&gt;U+0027&lt;/code&gt; itself, which must be &lt;em&gt;escaped&lt;/em&gt; by a preceding &lt;code&gt;U+005C&lt;/code&gt; character (&lt;code&gt;\&lt;/code&gt;).</source>
          <target state="translated">&lt;em&gt;文字リテラルは&lt;/em&gt; 2内に封入された単一のUnicode文字である &lt;code&gt;U+0027&lt;/code&gt; を除いて（単一引用符）文字 &lt;code&gt;U+0027&lt;/code&gt; する必要があり、それ自体、&lt;em&gt;エスケープ&lt;/em&gt;先行によって &lt;code&gt;U+005C&lt;/code&gt; の文字（ &lt;code&gt;\&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="3c6b198e97c9744354ac6c754b38292587c4fb26" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;closure expression&lt;/em&gt; defines a closure and denotes it as a value, in a single expression. A closure expression is a pipe-symbol-delimited (&lt;code&gt;|&lt;/code&gt;) list of irrefutable &lt;a href=&quot;../patterns&quot;&gt;patterns&lt;/a&gt; followed by an expression. Type annotations may optionally be added for the type of the parameters or for the return type. If there is a return type, the expression used for the body of the closure must be a normal &lt;a href=&quot;block-expr&quot;&gt;block&lt;/a&gt;. A closure expression also may begin with the &lt;code&gt;move&lt;/code&gt; keyword before the initial &lt;code&gt;|&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;閉鎖式は&lt;/em&gt;クロージャを定義し、単一式で、値として表します。クロージャ式は、式が続く反駁できない&lt;a href=&quot;../patterns&quot;&gt;パターンの&lt;/a&gt;パイプ記号区切り（ &lt;code&gt;|&lt;/code&gt; ）リストです。オプションで、型の注釈をパラメーターの型または戻り値の型に追加できます。戻り型がある場合、クロージャーの本体に使用される式は通常の&lt;a href=&quot;block-expr&quot;&gt;ブロックで&lt;/a&gt;なければなりません。クロージャ式は、最初の &lt;code&gt;|&lt;/code&gt; の前に &lt;code&gt;move&lt;/code&gt; キーワードで始まることもあります。。</target>
        </trans-unit>
        <trans-unit id="339cfc7fe9f16f898782c7f7150b6fb18b64f9c3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;closure expression&lt;/em&gt;, also know as a lambda expression or a lambda, defines a closure and denotes it as a value, in a single expression. A closure expression is a pipe-symbol-delimited (&lt;code&gt;|&lt;/code&gt;) list of irrefutable &lt;a href=&quot;../patterns&quot;&gt;patterns&lt;/a&gt; followed by an expression. Type annotations may optionally be added for the type of the parameters or for the return type. If there is a return type, the expression used for the body of the closure must be a normal &lt;a href=&quot;block-expr&quot;&gt;block&lt;/a&gt;. A closure expression also may begin with the &lt;code&gt;move&lt;/code&gt; keyword before the initial &lt;code&gt;|&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;クロージャの発現は&lt;/em&gt;、また、ラムダ式またはラムダとして知られる、クロージャを規定し、単一式で、値として表します。クロージャ式は、反駁できない&lt;a href=&quot;../patterns&quot;&gt;パターンの&lt;/a&gt;パイプ記号で区切られた（ &lt;code&gt;|&lt;/code&gt; ）リストの後に式が続きます。オプションで、パラメーターの型または戻り値の型に型注釈を追加できます。戻り値の型がある場合、クロージャーの本体に使用される式は通常の&lt;a href=&quot;block-expr&quot;&gt;ブロックである&lt;/a&gt;必要があります。クロージャ式は、最初の &lt;code&gt;|&lt;/code&gt; の前の &lt;code&gt;move&lt;/code&gt; キーワードで始まる場合もあります。。</target>
        </trans-unit>
        <trans-unit id="12a150efcf9ffb345d5ef3ddd2a2876cc8ac7c18" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;cons list&lt;/em&gt; is a data structure that comes from the Lisp programming language and its dialects. In Lisp, the &lt;code&gt;cons&lt;/code&gt; function (short for &amp;ldquo;construct function&amp;rdquo;) constructs a new pair from its two arguments, which usually are a single value and another pair. These pairs containing pairs form a list.</source>
          <target state="translated">&lt;em&gt;短所リストは&lt;/em&gt; Lispのプログラミング言語とその方言から来たデータ構造です。Lispでは、 &lt;code&gt;cons&lt;/code&gt; 関数（「構築関数」の略）は、2つの引数（通常は単一の値と別のペア）から新しいペアを構築します。ペアを含むこれらのペアはリストを形成します。</target>
        </trans-unit>
        <trans-unit id="cfba0b21b720ac42e28e2be5d6bab07c901fa318" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;const context&lt;/em&gt; is one of the following:</source>
          <target state="translated">&lt;em&gt;constのコンテキストは&lt;/em&gt;、次のいずれかになります。</target>
        </trans-unit>
        <trans-unit id="493b2f63697e56331a49f53a0195846cde72e171" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;const fn&lt;/em&gt; is a function that one is permitted to call from a const context. Declaring a function &lt;code&gt;const&lt;/code&gt; has no effect on any existing uses, it only restricts the types that arguments and the return type may use, as well as prevent various expressions from being used within it. You can freely do anything with a const function that you can do with a regular function.</source>
          <target state="translated">&lt;em&gt;CONSTのFNは、&lt;/em&gt;一方がCONSTコンテキストから呼び出すことが許可されている機能です。関数 &lt;code&gt;const&lt;/code&gt; を宣言しても、既存の使用法には影響しません。引数と戻り値の型が使用できる型を制限するだけでなく、その中でさまざまな式が使用されるのを防ぎます。 const関数では、通常の関数で実行できることなら何でも自由に実行できます。</target>
        </trans-unit>
        <trans-unit id="c36e88175514c7e87236cec6eff5e35e2ff35de3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;constant item&lt;/em&gt; is an optionally named &lt;em&gt;&lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;constant value&lt;/a&gt;&lt;/em&gt; which is not associated with a specific memory location in the program. Constants are essentially inlined wherever they are used, meaning that they are copied directly into the relevant context when used. References to the same constant are not necessarily guaranteed to refer to the same memory address.</source>
          <target state="translated">&lt;em&gt;一定の項目は&lt;/em&gt;任意に命名される&lt;em&gt;&lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;定数値&lt;/a&gt;&lt;/em&gt;プログラム内の特定のメモリ位置に関連付けられていません。定数は、使用される場所に基本的にインライン化されます。つまり、使用されると、関連するコンテキストに直接コピーされます。同じ定数への参照は、必ずしも同じメモリアドレスへの参照を保証するものではありません。</target>
        </trans-unit>
        <trans-unit id="2e06b409839c096ae71106f8baaaf9f78507004d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;constant item&lt;/em&gt; is an optionally named &lt;em&gt;&lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;constant value&lt;/a&gt;&lt;/em&gt; which is not associated with a specific memory location in the program. Constants are essentially inlined wherever they are used, meaning that they are copied directly into the relevant context when used. This includes usage of constants from external crates, and non-&lt;a href=&quot;../special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; types. References to the same constant are not necessarily guaranteed to refer to the same memory address.</source>
          <target state="translated">&lt;em&gt;一定の項目は&lt;/em&gt;任意に命名される&lt;em&gt;&lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;定数値&lt;/a&gt;&lt;/em&gt;プログラム内の特定のメモリ位置に関連付けられていません。定数は基本的に、使用される場所にインライン化されます。つまり、使用されると、関連するコンテキストに直接コピーされます。これには、外部クレートからの定数の使用、および非&lt;a href=&quot;../special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;タイプが含まれます。同じ定数への参照は、必ずしも同じメモリアドレスを参照することが保証されているわけではありません。</target>
        </trans-unit>
        <trans-unit id="f7145ab5c52684eb21ecb032f3560fae33132c02" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;crate&lt;/em&gt; is a unit of compilation and linking, as well as versioning, distribution and runtime loading. A crate contains a &lt;em&gt;tree&lt;/em&gt; of nested &lt;a href=&quot;items/modules&quot;&gt;module&lt;/a&gt; scopes. The top level of this tree is a module that is anonymous (from the point of view of paths within the module) and any item within a crate has a canonical &lt;a href=&quot;paths&quot;&gt;module path&lt;/a&gt; denoting its location within the crate's module tree.</source>
          <target state="translated">&lt;em&gt;クレートは&lt;/em&gt;、コンパイルおよびリンク、ならびにバージョニング、分布およびランタイムローディングの単位です。クレートには、ネストされた&lt;a href=&quot;items/modules&quot;&gt;モジュール&lt;/a&gt;スコープの&lt;em&gt;ツリー&lt;/em&gt;が含まれています。このツリーの最上位レベルは（モジュール内のパスの観点から）匿名のモジュールであり、クレート内のアイテムには、クレートのモジュールツリー内の位置を示す正規の&lt;a href=&quot;paths&quot;&gt;モジュールパスがあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="7dbd934a0d90b722d503e93f98eb0c64d5f9ddfa" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;crate&lt;/em&gt; is a unit of compilation and linking, as well as versioning, distribution, and runtime loading. A crate contains a &lt;em&gt;tree&lt;/em&gt; of nested &lt;a href=&quot;items/modules&quot;&gt;module&lt;/a&gt; scopes. The top level of this tree is a module that is anonymous (from the point of view of paths within the module) and any item within a crate has a canonical &lt;a href=&quot;paths&quot;&gt;module path&lt;/a&gt; denoting its location within the crate's module tree.</source>
          <target state="translated">&lt;em&gt;クレートは&lt;/em&gt;、コンパイルおよびリンク、ならびにバージョン管理、流通、およびランタイム・ローディングの単位です。クレートには、ネストされた&lt;a href=&quot;items/modules&quot;&gt;モジュール&lt;/a&gt;スコープの&lt;em&gt;ツリー&lt;/em&gt;が含まれています。このツリーの最上位は匿名のモジュールであり（モジュール内のパスの観点から）、クレート内のアイテムには、クレートのモジュールツリー内の場所を示す正規の&lt;a href=&quot;paths&quot;&gt;モジュールパスがあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="2299b04cb26521f6ac83c838a00ce161fe3ebdb6" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;decimal literal&lt;/em&gt; followed by a period character &lt;code&gt;U+002E&lt;/code&gt; (&lt;code&gt;.&lt;/code&gt;). This is optionally followed by another decimal literal, with an optional &lt;em&gt;exponent&lt;/em&gt;.</source>
          <target state="translated">A &lt;em&gt;小数リテラル&lt;/em&gt;ピリオドが続く &lt;code&gt;U+002E&lt;/code&gt; （ &lt;code&gt;.&lt;/code&gt; ）。これには、オプションで、別の10進リテラルが続き、オプションで&lt;em&gt;指数が付き&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="8945005fcfd339455451ef03bfa95bfaaedef426" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;decimal literal&lt;/em&gt; starts with a &lt;em&gt;decimal digit&lt;/em&gt; and continues with any mixture of &lt;em&gt;decimal digits&lt;/em&gt; and &lt;em&gt;underscores&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;小数リテラル&lt;/em&gt;で始まり&lt;em&gt;進数字&lt;/em&gt;との任意の混合物を継続&lt;em&gt;進数字&lt;/em&gt;と&lt;em&gt;アンダー&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="766049e827df03480f975a74379f283f50ff3914" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;declaration statement&lt;/em&gt; is one that introduces one or more &lt;em&gt;names&lt;/em&gt; into the enclosing statement block. The declared names may denote new variables or new &lt;a href=&quot;items&quot;&gt;items&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;宣言文は、&lt;/em&gt;一つ以上の紹介です&lt;em&gt;名前を&lt;/em&gt;囲む文ブロックに。宣言された名前は、新しい変数または新しい&lt;a href=&quot;items&quot;&gt;項目を&lt;/a&gt;表す場合があります。</target>
        </trans-unit>
        <trans-unit id="50530b588ed49ed96a8c5783ad73ba3e37c6ea25" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;field expression&lt;/em&gt; consists of an expression followed by a single dot and an &lt;a href=&quot;../identifiers&quot;&gt;identifier&lt;/a&gt;, when not immediately followed by a parenthesized expression-list (the latter is always a &lt;a href=&quot;method-call-expr&quot;&gt;method call expression&lt;/a&gt;). A field expression denotes a field of a &lt;a href=&quot;../items/structs&quot;&gt;struct&lt;/a&gt; or &lt;a href=&quot;../items/unions&quot;&gt;union&lt;/a&gt;. To call a function stored in a struct, parentheses are needed around the field expression.</source>
          <target state="translated">&lt;em&gt;フィールド表現は&lt;/em&gt;、単一のドットと続く発現から成る&lt;a href=&quot;../identifiers&quot;&gt;識別子&lt;/a&gt;直ちに（後者は常に括弧式リストが続かない場合、&lt;a href=&quot;method-call-expr&quot;&gt;メソッド呼び出し式&lt;/a&gt;）。フィールド式は、&lt;a href=&quot;../items/structs&quot;&gt;構造体&lt;/a&gt;または&lt;a href=&quot;../items/unions&quot;&gt;共用&lt;/a&gt;体のフィールドを示します。構造体に格納されている関数を呼び出すには、フィールド式を括弧で囲む必要があります。</target>
        </trans-unit>
        <trans-unit id="cf5014cd7ac2068f18f118543ff07241eda10fbd" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;floating-point literal&lt;/em&gt; has one of two forms:</source>
          <target state="translated">&lt;em&gt;浮動小数点リテラルは、&lt;/em&gt;二つの形式のうちの1つを有します。</target>
        </trans-unit>
        <trans-unit id="4f4b1ebbfdc25acf10623629374f684851ce4095" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;function&lt;/em&gt; consists of a &lt;a href=&quot;../expressions/block-expr&quot;&gt;block&lt;/a&gt;, along with a name and a set of parameters. Other than a name, all these are optional. Functions are declared with the keyword &lt;code&gt;fn&lt;/code&gt;. Functions may declare a set of &lt;em&gt;input&lt;/em&gt;&lt;a href=&quot;../variables&quot;&gt;&lt;em&gt;variables&lt;/em&gt;&lt;/a&gt; as parameters, through which the caller passes arguments into the function, and the &lt;em&gt;output&lt;/em&gt;&lt;a href=&quot;../types#type-expressions&quot;&gt;&lt;em&gt;type&lt;/em&gt;&lt;/a&gt; of the value the function will return to its caller on completion.</source>
          <target state="translated">&lt;em&gt;関数は、&lt;/em&gt;から成る&lt;a href=&quot;../expressions/block-expr&quot;&gt;ブロック&lt;/a&gt;名とパラメータのセットと共に、。名前を除いて、これらはすべてオプションです。関数はキーワード &lt;code&gt;fn&lt;/code&gt; で宣言されます。関数は、一連の&lt;em&gt;入力&lt;/em&gt;&lt;a href=&quot;../variables&quot;&gt;&lt;em&gt;変数&lt;/em&gt;&lt;/a&gt;をパラメーターとして宣言できます。これにより、呼び出し元は関数に引数を渡し、関数は完了時に関数が呼び出し元に返す値の&lt;em&gt;出力&lt;/em&gt;&lt;a href=&quot;../types#type-expressions&quot;&gt;&lt;em&gt;型&lt;/em&gt;&lt;/a&gt;を宣言します。</target>
        </trans-unit>
        <trans-unit id="8f85371a9c250b84e230a898102f42e92fb5ad83" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;generic function&lt;/em&gt; allows one or more &lt;em&gt;parameterized types&lt;/em&gt; to appear in its signature. Each type parameter must be explicitly declared in an angle-bracket-enclosed and comma-separated list, following the function name.</source>
          <target state="translated">&lt;em&gt;一般的な機能は、&lt;/em&gt;一つ以上のことができます&lt;em&gt;パラメータ化された型は、&lt;/em&gt;その署名に表示されます。各型パラメーターは、山かっこで囲まれ、コンマで区切られたリストで、関数名に続いて明示的に宣言する必要があります。</target>
        </trans-unit>
        <trans-unit id="e5b0c06878c29b647a5cee7cefa81c23fca43579" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;hash map&lt;/em&gt; allows you to associate a value with a particular key. It&amp;rsquo;s a particular implementation of the more general data structure called a &lt;em&gt;map&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;ハッシュマップは&lt;/em&gt;、あなたが特定のキーと値を関連付けることができます。これは、&lt;em&gt;map&lt;/em&gt;と呼ばれるより一般的なデータ構造の特定の実装です。</target>
        </trans-unit>
        <trans-unit id="d2dddac086e471872aa5bba992c51dee8e784e1c" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;hex literal&lt;/em&gt; starts with the character sequence &lt;code&gt;U+0030&lt;/code&gt;&lt;code&gt;U+0078&lt;/code&gt; (&lt;code&gt;0x&lt;/code&gt;) and continues as any mixture (with at least one digit) of hex digits and underscores.</source>
          <target state="translated">&lt;em&gt;六角リテラル&lt;/em&gt;文字列で始まる &lt;code&gt;U+0030&lt;/code&gt; &lt;code&gt;U+0078&lt;/code&gt; （ &lt;code&gt;0x&lt;/code&gt; ）と進数字と下線の（少なくとも一桁で）任意の混合物として継続します。</target>
        </trans-unit>
        <trans-unit id="9e38a4ee6fc96f56c22e46e8162db6bbee2c0881" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;literal expression&lt;/em&gt; consists of one of the &lt;a href=&quot;../tokens#literals&quot;&gt;literal&lt;/a&gt; forms described earlier. It directly describes a number, character, string, or boolean value.</source>
          <target state="translated">&lt;em&gt;リテラル式は、&lt;/em&gt;のいずれかから成る&lt;a href=&quot;../tokens#literals&quot;&gt;リテラル&lt;/a&gt;前述した形態。数値、文字、文字列、またはブール値を直接記述します。</target>
        </trans-unit>
        <trans-unit id="ad9efa9913447a56224684e0aa75e5aeea6b8381" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;local variable&lt;/em&gt; (or &lt;em&gt;stack-local&lt;/em&gt; allocation) holds a value directly, allocated within the stack's memory. The value is a part of the stack frame.</source>
          <target state="translated">&lt;em&gt;ローカル変数&lt;/em&gt;（または&lt;em&gt;スタックローカル&lt;/em&gt;割り当て）は、スタックのメモリ内に割り当てられた値を直接、保持しています。値はスタックフレームの一部です。</target>
        </trans-unit>
        <trans-unit id="5494ba7068df28e0c7f4a4e2a11fa8f85cf97050" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;match guard&lt;/em&gt; is an additional &lt;code&gt;if&lt;/code&gt; condition specified after the pattern in a &lt;code&gt;match&lt;/code&gt; arm that must also match, along with the pattern matching, for that arm to be chosen. Match guards are useful for expressing more complex ideas than a pattern alone allows.</source>
          <target state="translated">&lt;em&gt;一致ガードが&lt;/em&gt;追加され &lt;code&gt;if&lt;/code&gt; におけるパターンの後に指定された条件 &lt;code&gt;match&lt;/code&gt; そのアームを選択するためにも、パターンマッチングと共に、一致しなければならないアーム。マッチガードは、パターンだけで許可するよりも複雑なアイデアを表現するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="99824c60f6f2f15272aa4440e52b0f6ee9405ef8" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;method call&lt;/em&gt; consists of an expression (the &lt;em&gt;receiver&lt;/em&gt;) followed by a single dot, an expression path segment, and a parenthesized expression-list. Method calls are resolved to associated &lt;a href=&quot;../items/associated-items#methods&quot;&gt;methods&lt;/a&gt; on specific traits, either statically dispatching to a method if the exact &lt;code&gt;self&lt;/code&gt;-type of the left-hand-side is known, or dynamically dispatching if the left-hand-side expression is an indirect &lt;a href=&quot;../types/trait-object&quot;&gt;trait object&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;メソッド呼び出しは、&lt;/em&gt;式（から成る&lt;em&gt;受信機&lt;/em&gt;の単一のドットは、発現経路セグメント、および括弧式リストが続きます）。メソッド呼び出しは、特定の特性の関連&lt;a href=&quot;../items/associated-items#methods&quot;&gt;メソッド&lt;/a&gt;に解決されます。左側の正確な &lt;code&gt;self&lt;/code&gt; 型がわかっている場合は静的にメソッドにディスパッチされ、左側の式が間接&lt;a href=&quot;../types/trait-object&quot;&gt;特性オブジェクトの&lt;/a&gt;場合は動的にディスパッチされます。</target>
        </trans-unit>
        <trans-unit id="4326f6a26736f9868551af52753b80b0248e3c0e" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;module item&lt;/em&gt; is a module, surrounded in braces, named, and prefixed with the keyword &lt;code&gt;mod&lt;/code&gt;. A module item introduces a new, named module into the tree of modules making up a crate. Modules can nest arbitrarily.</source>
          <target state="translated">&lt;em&gt;モジュール項目は&lt;/em&gt;モジュール、括弧で囲まれた名前が付けられ、キーワードの接頭辞である &lt;code&gt;mod&lt;/code&gt; 。モジュール項目は、新しい名前の付いたモジュールをクレートを構成するモジュールのツリーに導入します。モジュールは任意にネストできます。</target>
        </trans-unit>
        <trans-unit id="4782354728434eca4d6ed0db530842093ebdfbdf" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;number literal&lt;/em&gt; is either an &lt;em&gt;integer literal&lt;/em&gt; or a &lt;em&gt;floating-point literal&lt;/em&gt;. The grammar for recognizing the two kinds of literals is mixed.</source>
          <target state="translated">&lt;em&gt;数値リテラルは、&lt;/em&gt;のいずれかである&lt;em&gt;整数リテラル&lt;/em&gt;または&lt;em&gt;浮動小数点リテラル&lt;/em&gt;。2種類のリテラルを認識するための文法が混在しています。</target>
        </trans-unit>
        <trans-unit id="7a1aa14aba61f76729922fa97eab5dfb14fd43e6" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;path&lt;/em&gt; is a sequence of one or more path segments &lt;em&gt;logically&lt;/em&gt; separated by a namespace qualifier (&lt;code&gt;::&lt;/code&gt;). If a path consists of only one segment, it refers to either an &lt;a href=&quot;items&quot;&gt;item&lt;/a&gt; or a &lt;a href=&quot;variables&quot;&gt;variable&lt;/a&gt; in a local control scope. If a path has multiple segments, it always refers to an item.</source>
          <target state="translated">&lt;em&gt;パスは、&lt;/em&gt;一つ以上の経路セグメントのシーケンスである&lt;em&gt;論理的&lt;/em&gt;名前空間修飾子（によって分離 &lt;code&gt;::&lt;/code&gt; ）。パスが1つのセグメントのみで構成されている場合、パスは、ローカルコントロールスコープ内の&lt;a href=&quot;items&quot;&gt;アイテム&lt;/a&gt;または&lt;a href=&quot;variables&quot;&gt;変数&lt;/a&gt;を参照します。パスに複数のセグメントがある場合、それは常にアイテムを参照します。</target>
        </trans-unit>
        <trans-unit id="bb92d4c241b315859972fd645fc7612b4dfc9464" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;place expression&lt;/em&gt; is an expression that represents a memory location. These expressions are &lt;a href=&quot;expressions/path-expr&quot;&gt;paths&lt;/a&gt; which refer to local variables, &lt;a href=&quot;items/static-items&quot;&gt;static variables&lt;/a&gt;, &lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;dereferences&lt;/a&gt; (&lt;code&gt;*expr&lt;/code&gt;), &lt;a href=&quot;expressions/array-expr#array-and-slice-indexing-expressions&quot;&gt;array indexing&lt;/a&gt; expressions (&lt;code&gt;expr[expr]&lt;/code&gt;), &lt;a href=&quot;expressions/field-expr&quot;&gt;field&lt;/a&gt; references (&lt;code&gt;expr.f&lt;/code&gt;) and parenthesized place expressions. All other expressions are value expressions.</source>
          <target state="translated">&lt;em&gt;場所発現は、&lt;/em&gt;メモリ位置を表す式です。これらの式は、&lt;a href=&quot;expressions/path-expr&quot;&gt;パス&lt;/a&gt;ローカル変数を参照し、&lt;a href=&quot;items/static-items&quot;&gt;静的変数&lt;/a&gt;、&lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;逆参照&lt;/a&gt;（ &lt;code&gt;*expr&lt;/code&gt; ）、&lt;a href=&quot;expressions/array-expr#array-and-slice-indexing-expressions&quot;&gt;配列のインデックスの&lt;/a&gt;式（ &lt;code&gt;expr[expr]&lt;/code&gt; ）、&lt;a href=&quot;expressions/field-expr&quot;&gt;フィールド&lt;/a&gt;参照（ &lt;code&gt;expr.f&lt;/code&gt; ）と括弧場所表現。他のすべての式は値式です。</target>
        </trans-unit>
        <trans-unit id="53e179d5349063cc7a43deec2333f4a66dd27469" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;pointer&lt;/em&gt; is a general concept for a variable that contains an address in memory. This address refers to, or &amp;ldquo;points at,&amp;rdquo; some other data. The most common kind of pointer in Rust is a reference, which you learned about in Chapter 4. References are indicated by the &lt;code&gt;&amp;amp;&lt;/code&gt; symbol and borrow the value they point to. They don&amp;rsquo;t have any special capabilities other than referring to data. Also, they don&amp;rsquo;t have any overhead and are the kind of pointer we use most often.</source>
          <target state="translated">&lt;em&gt;ポインタは、&lt;/em&gt;メモリ内のアドレスが含まれている変数のための一般的な概念です。このアドレスは、他のいくつかのデータを参照または「ポイント」します。Rustで最も一般的な種類のポインタはリファレンスです。これは、第4章で学習しました。リファレンスは &lt;code&gt;&amp;amp;&lt;/code&gt; 記号で示され、それらが指す値を借ります。データを参照する以外に特別な機能はありません。また、オーバーヘッドがなく、私たちが最もよく使用する種類のポインターです。</target>
        </trans-unit>
        <trans-unit id="7fe098911943171d28affe53c0c7d6311adf867c" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;relative path&lt;/em&gt; starts from the current module and uses &lt;code&gt;self&lt;/code&gt;, &lt;code&gt;super&lt;/code&gt;, or an identifier in the current module.</source>
          <target state="translated">&lt;em&gt;相対パスは、&lt;/em&gt;現在のモジュールから始まり、使用する &lt;code&gt;self&lt;/code&gt; 、 &lt;code&gt;super&lt;/code&gt; 、または現在のモジュール内の識別子。</target>
        </trans-unit>
        <trans-unit id="b7be095308c163f67b48127967466163200c85dc" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;scalar&lt;/em&gt; type represents a single value. Rust has four primary scalar types: integers, floating-point numbers, Booleans, and characters. You may recognize these from other programming languages. Let&amp;rsquo;s jump into how they work in Rust.</source>
          <target state="translated">&lt;em&gt;スカラー&lt;/em&gt;型は、単一の値を表します。Rustには、整数、浮動小数点数、ブール、文字の4つの主要なスカラー型があります。他のプログラミング言語からこれらを認識できます。Rustでどのように機能するかを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="5e00452619a2cd4e10d7a42ab9898d401215bca3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;statement&lt;/em&gt; is a component of a &lt;a href=&quot;expressions/block-expr&quot;&gt;block&lt;/a&gt;, which is in turn a component of an outer &lt;a href=&quot;expressions&quot;&gt;expression&lt;/a&gt; or &lt;a href=&quot;items/functions&quot;&gt;function&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;ステートメントは、&lt;/em&gt;の構成要素である&lt;a href=&quot;expressions/block-expr&quot;&gt;ブロック&lt;/a&gt;ターン外側の構成要素である、&lt;a href=&quot;expressions&quot;&gt;発現&lt;/a&gt;又は&lt;a href=&quot;items/functions&quot;&gt;機能&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9cd3832cf111028f53f6cad959deb6ad53f56ca0" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;static item&lt;/em&gt; is similar to a &lt;a href=&quot;constant-items&quot;&gt;constant&lt;/a&gt;, except that it represents a precise memory location in the program. All references to the static refer to the same memory location. Static items have the &lt;code&gt;static&lt;/code&gt; lifetime, which outlives all other lifetimes in a Rust program. Non-&lt;code&gt;mut&lt;/code&gt; static items that contain a type that is not &lt;a href=&quot;../interior-mutability&quot;&gt;interior mutable&lt;/a&gt; may be placed in read-only memory. Static items do not call &lt;a href=&quot;../destructors&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt; at the end of the program.</source>
          <target state="translated">&lt;em&gt;静的項目は&lt;/em&gt;同様である&lt;a href=&quot;constant-items&quot;&gt;定数&lt;/a&gt;、プログラムにおける正確なメモリロケーションを表すことを除いて、。 staticへのすべての参照は、同じメモリ位置を参照しています。静的アイテムには &lt;code&gt;static&lt;/code&gt; ライフタイムがあり、Rustプログラムの他のすべてのライフタイムよりも長く存続します。&lt;a href=&quot;../interior-mutability&quot;&gt;内部で可変&lt;/a&gt;でないタイプを含む非 &lt;code&gt;mut&lt;/code&gt; 静的項目は、読み取り専用メモリに配置できます。静的アイテムは、プログラムの終了時に&lt;a href=&quot;../destructors&quot;&gt; &lt;code&gt;drop&lt;/code&gt; &lt;/a&gt;を呼び出しません。</target>
        </trans-unit>
        <trans-unit id="9ed445848ff0ebfb7d1082c79316c3f0dc94cf17" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;static item&lt;/em&gt; is similar to a &lt;a href=&quot;constant-items&quot;&gt;constant&lt;/a&gt;, except that it represents a precise memory location in the program. All references to the static refer to the same memory location. Static items have the &lt;code&gt;static&lt;/code&gt; lifetime, which outlives all other lifetimes in a Rust program. Static items do not call &lt;a href=&quot;../destructors&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt; at the end of the program.</source>
          <target state="translated">&lt;em&gt;静的項目は&lt;/em&gt;同様である&lt;a href=&quot;constant-items&quot;&gt;定数&lt;/a&gt;、プログラムにおける正確なメモリロケーションを表すことを除いて、。静的へのすべての参照は、同じメモリ位置を参照します。静的アイテムには &lt;code&gt;static&lt;/code&gt; ライフタイムがあり、Rustプログラムの他のすべてのライフタイムよりも長くなります。静的アイテムは、プログラムの最後に&lt;a href=&quot;../destructors&quot;&gt; &lt;code&gt;drop&lt;/code&gt; &lt;/a&gt;を呼び出しません。</target>
        </trans-unit>
        <trans-unit id="045ded2942d599b289c8f6860ad989b955a99d7c" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;string literal&lt;/em&gt; is a sequence of any Unicode characters enclosed within two &lt;code&gt;U+0022&lt;/code&gt; (double-quote) characters, with the exception of &lt;code&gt;U+0022&lt;/code&gt; itself, which must be &lt;em&gt;escaped&lt;/em&gt; by a preceding &lt;code&gt;U+005C&lt;/code&gt; character (&lt;code&gt;\&lt;/code&gt;).</source>
          <target state="translated">&lt;em&gt;文字列リテラルは&lt;/em&gt; 2で囲まれた任意のUnicode文字のシーケンスである &lt;code&gt;U+0022&lt;/code&gt; を除いて、（二重引用符）文字 &lt;code&gt;U+0022&lt;/code&gt; する必要があり、それ自体、&lt;em&gt;エスケープ&lt;/em&gt;直前で &lt;code&gt;U+005C&lt;/code&gt; の文字（ &lt;code&gt;\&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f12122f88fa635dd2b58aa377fdb09d19aba988d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;string slice&lt;/em&gt; is a reference to part of a &lt;code&gt;String&lt;/code&gt;, and it looks like this:</source>
          <target state="translated">&lt;em&gt;文字列のスライスは、&lt;/em&gt;の一部への参照である &lt;code&gt;String&lt;/code&gt; 、それは次のようになります。</target>
        </trans-unit>
        <trans-unit id="691e369dd4289704604ecf4cd7dd7181b87971ad" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;string&lt;/em&gt; is a collection of characters. We&amp;rsquo;ve mentioned the &lt;code&gt;String&lt;/code&gt; type previously, but in this chapter we&amp;rsquo;ll talk about it in depth.</source>
          <target state="translated">&lt;em&gt;文字列は、&lt;/em&gt;文字の集合です。前に &lt;code&gt;String&lt;/code&gt; 型について説明しましたが、この章ではそれについて詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="ac2f7e212f4d47b7d6ba3c1b79c057cc109911ff" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;struct expression&lt;/em&gt; creates a struct or union value. It consists of a path to a &lt;a href=&quot;../items/structs&quot;&gt;struct&lt;/a&gt; or &lt;a href=&quot;../items/unions&quot;&gt;union&lt;/a&gt; item followed by the values for the fields of the item. There are three forms of struct expressions: struct, tuple, and unit.</source>
          <target state="translated">&lt;em&gt;構造体の式は、&lt;/em&gt;構造体または共用体の値を作成します。これは、&lt;a href=&quot;../items/structs&quot;&gt;構造体&lt;/a&gt;または&lt;a href=&quot;../items/unions&quot;&gt;共用&lt;/a&gt;体アイテムへのパスと、それに続くアイテムのフィールドの値で構成されます。構造体式には、構造体、タプル、ユニットの3つの形式があります。</target>
        </trans-unit>
        <trans-unit id="d65205e4e512b884279b051d3f883110c3677542" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;struct&lt;/em&gt; is a nominal &lt;a href=&quot;../types/struct&quot;&gt;struct type&lt;/a&gt; defined with the keyword &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;構造体は&lt;/em&gt;、公称である&lt;a href=&quot;../types/struct&quot;&gt;構造体型&lt;/a&gt;キーワードで定義された &lt;code&gt;struct&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9b38ad3b7538f97629f5686d68a34da8981cf5d0" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;struct&lt;/em&gt;, or &lt;em&gt;structure&lt;/em&gt;, is a custom data type that lets you name and package together multiple related values that make up a meaningful group. If you&amp;rsquo;re familiar with an object-oriented language, a &lt;em&gt;struct&lt;/em&gt; is like an object&amp;rsquo;s data attributes. In this chapter, we&amp;rsquo;ll compare and contrast tuples with structs, demonstrate how to use structs, and discuss how to define methods and associated functions to specify behavior associated with a struct&amp;rsquo;s data. Structs and enums (discussed in Chapter 6) are the building blocks for creating new types in your program&amp;rsquo;s domain to take full advantage of Rust&amp;rsquo;s compile time type checking.</source>
          <target state="translated">&lt;em&gt;構造体&lt;/em&gt;、または&lt;em&gt;構造は&lt;/em&gt;、あなたが意味のあるグループを構成する複数の関連値に名前を付け、一緒にパッケージ化することができますカスタムデータ型です。オブジェクト指向言語に精通している場合、&lt;em&gt;構造体&lt;/em&gt;はオブジェクトのデータ属性のようなものです。この章では、タプルと構造体を比較対照し、構造体の使用方法を示し、メソッドと関連関数を定義して、構造体のデータに関連付けられた動作を指定する方法について説明します。構造体と列挙型（第6章で説明）は、Rustのコンパイル時の型チェックを最大限に活用するためにプログラムのドメインで新しい型を作成するための構成要素です。</target>
        </trans-unit>
        <trans-unit id="c2b858ff2e5a4ed485b3e5e4a18471183d07402f" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;test double&lt;/em&gt; is the general programming concept for a type used in place of another type during testing. &lt;em&gt;Mock objects&lt;/em&gt; are specific types of test doubles that record what happens during a test so you can assert that the correct actions took place.</source>
          <target state="translated">&lt;em&gt;テストでは、二重の&lt;/em&gt;テスト中に、別のタイプの代わりに使用するタイプのための一般的なプログラミングの概念です。&lt;em&gt;モックオブジェクト&lt;/em&gt;は、テスト中に発生したことを記録する特定のタイプのテストダブルであり、正しいアクションが行われたことをアサートできます。</target>
        </trans-unit>
        <trans-unit id="9a0e24d887e877ac9c41e5667ab7a119a4c29456" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;thread pool&lt;/em&gt; is a group of spawned threads that are waiting and ready to handle a task. When the program receives a new task, it assigns one of the threads in the pool to the task, and that thread will process the task. The remaining threads in the pool are available to handle any other tasks that come in while the first thread is processing. When the first thread is done processing its task, it&amp;rsquo;s returned to the pool of idle threads, ready to handle a new task. A thread pool allows you to process connections concurrently, increasing the throughput of your server.</source>
          <target state="translated">&lt;em&gt;スレッドプールが&lt;/em&gt;待っていると、タスクを処理する準備ができている生成されたスレッドのグループです。プログラムは新しいタスクを受け取ると、プール内のスレッドの1つをタスクに割り当て、そのスレッドがタスクを処理します。プール内の残りのスレッドは、最初のスレッドの処理中に発生する他のタスクを処理するために使用できます。最初のスレッドがタスクの処理を完了すると、アイドルスレッドのプールに戻され、新しいタスクを処理する準備が整います。スレッドプールを使用すると、接続を同時に処理できるため、サーバーのスループットが向上します。</target>
        </trans-unit>
        <trans-unit id="313b18e83bc534426ba5a3363e3ef30c68738ffe" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;trait implementation&lt;/em&gt; is defined like an inherent implementation except that the optional generic type declarations is followed by a &lt;a href=&quot;traits&quot;&gt;trait&lt;/a&gt; followed by the keyword &lt;code&gt;for&lt;/code&gt;. Followed by a path to a nominal type.</source>
          <target state="translated">&lt;em&gt;形質実装は&lt;/em&gt;、オプションのジェネリック型宣言が続いていることを除いて、固有の実装のように定義され&lt;a href=&quot;traits&quot;&gt;た形質&lt;/a&gt;キーワードが続く &lt;code&gt;for&lt;/code&gt; 。公称タイプへのパスが続きます。</target>
        </trans-unit>
        <trans-unit id="61547573b3bf424e11f1f4f9cd8d9184f5546ee1" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;trait object&lt;/em&gt; is an opaque value of another type that implements a set of traits. A trait object implements all specified traits as well as their supertraits (if any).</source>
          <target state="translated">&lt;em&gt;形質オブジェクトは&lt;/em&gt;特性のセットを実装する他のタイプの不透明な値です。トレイトオブジェクトは、指定されたすべてのトレイトとそのスーパートレイト（存在する場合）を実装します。</target>
        </trans-unit>
        <trans-unit id="2ba7bca2e53443f2e59cd9b7a5cdc8e34241ae48" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;trait object&lt;/em&gt; is an opaque value of another type that implements a set of traits. The set of traits is made up of an &lt;a href=&quot;../items/traits#object-safety&quot;&gt;object safe&lt;/a&gt;&lt;em&gt;base trait&lt;/em&gt; plus any number of &lt;a href=&quot;../special-types-and-traits#auto-traits&quot;&gt;auto traits&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;形質オブジェクトは&lt;/em&gt;特性のセットを実装する他のタイプの不透明な値です。一連の特性は、&lt;a href=&quot;../items/traits#object-safety&quot;&gt;オブジェクトセーフの&lt;/a&gt;&lt;em&gt;基本特性&lt;/em&gt;と任意の数の&lt;a href=&quot;../special-types-and-traits#auto-traits&quot;&gt;自動特性で構成され&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="5df129cc6b630156d556e5813378ed108b2ab443" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;trait&lt;/em&gt; describes an abstract interface that types can implement. This interface consists of &lt;a href=&quot;associated-items&quot;&gt;associated items&lt;/a&gt;, which come in three varieties:</source>
          <target state="translated">&lt;em&gt;トレイトは&lt;/em&gt;型が実装できるという抽象インタフェースを記述します。このインターフェースは、次の3種類の&lt;a href=&quot;associated-items&quot;&gt;関連アイテム&lt;/a&gt;で構成されています。</target>
        </trans-unit>
        <trans-unit id="a413d8d80703ed47836b183924cabc19246e5f7c" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;trait&lt;/em&gt; tells the Rust compiler about functionality a particular type has and can share with other types. We can use traits to define shared behavior in an abstract way. We can use trait bounds to specify that a generic can be any type that has certain behavior.</source>
          <target state="translated">&lt;em&gt;特徴は&lt;/em&gt;、特定のタイプがあり、他のタイプと共有することができた機能について錆コンパイラに指示します。トレイトを使用して、共有される動作を抽象的な方法で定義できます。特性境界を使用して、ジェネリックが特定の動作をする任意のタイプになるように指定できます。</target>
        </trans-unit>
        <trans-unit id="9018c5e20d838075d5b138f7d86d8d8c684fb244" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;tuple index&lt;/em&gt; is either &lt;code&gt;0&lt;/code&gt;, or starts with a &lt;em&gt;non-zero decimal digit&lt;/em&gt; and continues with zero or more decimal digits. Tuple indexes are used to refer to the fields of &lt;a href=&quot;types/tuple&quot;&gt;tuples&lt;/a&gt;, &lt;a href=&quot;items/structs&quot;&gt;tuple structs&lt;/a&gt; and &lt;a href=&quot;items/enumerations&quot;&gt;tuple variants&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;タプルインデックスが&lt;/em&gt;いずれかである &lt;code&gt;0&lt;/code&gt; 、又はから始まり&lt;em&gt;ゼロでない小数の桁&lt;/em&gt;と0個以上の桁を続けます。タプルインデックスは、&lt;a href=&quot;types/tuple&quot;&gt;タプル&lt;/a&gt;、&lt;a href=&quot;items/structs&quot;&gt;タプル構造体&lt;/a&gt;、&lt;a href=&quot;items/enumerations&quot;&gt;タプルバリアント&lt;/a&gt;のフィールドを参照するために使用されます。</target>
        </trans-unit>
        <trans-unit id="c47a882c5415e255f49931b3989ce3cbb03e65f7" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;tuple struct&lt;/em&gt; is a nominal &lt;a href=&quot;../types/tuple&quot;&gt;tuple type&lt;/a&gt;, also defined with the keyword &lt;code&gt;struct&lt;/code&gt;. For example:</source>
          <target state="translated">&lt;em&gt;タプル構造体は&lt;/em&gt;、公称で&lt;a href=&quot;../types/tuple&quot;&gt;タプルタイプ&lt;/a&gt;もキーワードで定義され、 &lt;code&gt;struct&lt;/code&gt; 。例えば：</target>
        </trans-unit>
        <trans-unit id="e97b14c685e031728ecd4469c910a8f3603e601d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;tuple struct&lt;/em&gt; type is just like a struct type, except that the fields are anonymous.</source>
          <target state="translated">&lt;em&gt;タプルの構造体の&lt;/em&gt;タイプは、フィールドが匿名であること以外は、単に構造体型のようなものです。</target>
        </trans-unit>
        <trans-unit id="57b75c1dd6681cfbd15ca11a1f0f5681b515a0f3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;type alias&lt;/em&gt; defines a new name for an existing &lt;a href=&quot;../types&quot;&gt;type&lt;/a&gt;. Type aliases are declared with the keyword &lt;code&gt;type&lt;/code&gt;. Every value has a single, specific type, but may implement several different traits, or be compatible with several different type constraints.</source>
          <target state="translated">&lt;em&gt;タイプの別名は&lt;/em&gt;既存の新しい名前を定義する&lt;a href=&quot;../types&quot;&gt;タイプ&lt;/a&gt;。タイプエイリアスはキーワード &lt;code&gt;type&lt;/code&gt; 宣言されます。すべての値には単一の特定のタイプがありますが、いくつかの異なる特性を実装したり、いくつかの異なるタイプ制約と互換性がある場合があります。</target>
        </trans-unit>
        <trans-unit id="64ff4b8d7e3ee42067c7072aacfc14cd027c093c" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;type expression&lt;/em&gt; as defined in the &lt;em&gt;Type&lt;/em&gt; grammar rule above is the syntax for referring to a type. It may refer to:</source>
          <target state="translated">&lt;em&gt;型の式&lt;/em&gt;で定義されている&lt;em&gt;タイプの&lt;/em&gt;文法規則は、上記の型を参照するための構文です。以下を参照する場合があります。</target>
        </trans-unit>
        <trans-unit id="50c0af6b4bb64ca1523e3b2abba8e82a69abff5a" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;union type&lt;/em&gt; is a nominal, heterogeneous C-like union, denoted by the name of a &lt;a href=&quot;../items/unions&quot;&gt;&lt;code&gt;union&lt;/code&gt; item&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;ユニオン型は&lt;/em&gt;、公称、異種C状組合の名前で示され&lt;a href=&quot;../items/unions&quot;&gt; &lt;code&gt;union&lt;/code&gt; アイテム&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="96e68805af9609cb7109b9bd3ef8c3be60b740ca" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;unit-like struct&lt;/em&gt; is a struct without any fields, defined by leaving off the list of fields entirely. Such a struct implicitly defines a constant of its type with the same name. For example:</source>
          <target state="translated">&lt;em&gt;ユニット状の構造体は、&lt;/em&gt;全体のフィールドのリストをオフに残すことによって定義された任意のフィールドなしで構造体です。このような構造体は、同じ名前の型の定数を暗黙的に定義します。例えば：</target>
        </trans-unit>
        <trans-unit id="6075d4cd12c28e60ac874060f12974e3762a509a" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;unit-like struct&lt;/em&gt; type is like a struct type, except that it has no fields. The one value constructed by the associated &lt;a href=&quot;../expressions/struct-expr&quot;&gt;struct expression&lt;/a&gt; is the only value that inhabits such a type.</source>
          <target state="translated">&lt;em&gt;ユニット状の構造体の&lt;/em&gt;タイプは、それがフィールドを持っていないことを除いて、構造体型のようなものです。関連する&lt;a href=&quot;../expressions/struct-expr&quot;&gt;struct式&lt;/a&gt;によって構築される1つの値は、そのような型に存在する唯一の値です。</target>
        </trans-unit>
        <trans-unit id="ed7d45b3f3a4f92438f32980c894150a8a0dee9d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;use declaration&lt;/em&gt; creates one or more local name bindings synonymous with some other &lt;a href=&quot;../paths&quot;&gt;path&lt;/a&gt;. Usually a &lt;code&gt;use&lt;/code&gt; declaration is used to shorten the path required to refer to a module item. These declarations may appear in &lt;a href=&quot;modules&quot;&gt;modules&lt;/a&gt; and &lt;a href=&quot;../expressions/block-expr&quot;&gt;blocks&lt;/a&gt;, usually at the top.</source>
          <target state="translated">&lt;em&gt;使用宣言は、&lt;/em&gt;他のいくつかのと同義一つ以上のローカル名のバインディングを作成&lt;a href=&quot;../paths&quot;&gt;パスを&lt;/a&gt;。通常、 &lt;code&gt;use&lt;/code&gt; 宣言は、モジュール項目を参照するために必要なパスを短くするために使用されます。これらの宣言は、通常は上部にある&lt;a href=&quot;modules&quot;&gt;モジュール&lt;/a&gt;および&lt;a href=&quot;../expressions/block-expr&quot;&gt;ブロックに&lt;/a&gt;表示される場合があります。</target>
        </trans-unit>
        <trans-unit id="2d8a654904db4cbe04f06da827ae2d7d450774ec" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;value expression&lt;/em&gt; is an expression that represents an actual value.</source>
          <target state="translated">&lt;em&gt;値式は、&lt;/em&gt;実際の値を表す式です。</target>
        </trans-unit>
        <trans-unit id="e6fd1c9fb448dc3050e431f7efdd6fccf7fb69e9" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;variable&lt;/em&gt; is a component of a stack frame, either a named function parameter, an anonymous &lt;a href=&quot;expressions#temporaries&quot;&gt;temporary&lt;/a&gt;, or a named local variable.</source>
          <target state="translated">&lt;em&gt;変数は、&lt;/em&gt;スタックフレームの構成要素、いずれかの名前の関数のパラメータ、匿名で&lt;a href=&quot;expressions#temporaries&quot;&gt;の一時的な&lt;/a&gt;、または名前のローカル変数。</target>
        </trans-unit>
        <trans-unit id="729fdc3c2a54819bca891fd0485aedb791a49cea" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;variable&lt;/em&gt; is a component of a stack frame, either a named function parameter, an anonymous &lt;a href=&quot;expressions#temporary-lifetimes&quot;&gt;temporary&lt;/a&gt;, or a named local variable.</source>
          <target state="translated">&lt;em&gt;変数は、&lt;/em&gt;スタックフレームの構成要素、いずれかの名前の関数のパラメータ、匿名で&lt;a href=&quot;expressions#temporary-lifetimes&quot;&gt;の一時的な&lt;/a&gt;、または名前のローカル変数。</target>
        </trans-unit>
        <trans-unit id="81028e39252e1de4d0939b21f1ccc9432b693d6d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;vector&lt;/em&gt; allows you to store a variable number of values next to each other.</source>
          <target state="translated">&lt;em&gt;ベクターは、&lt;/em&gt;あなたが隣同士に値の可変数を格納することができます。</target>
        </trans-unit>
        <trans-unit id="cbf31b3f11b4472e6a3c452469774ef2fe901798" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;whitespace escape&lt;/em&gt; is one of the characters &lt;code&gt;U+006E&lt;/code&gt; (&lt;code&gt;n&lt;/code&gt;), &lt;code&gt;U+0072&lt;/code&gt; (&lt;code&gt;r&lt;/code&gt;), or &lt;code&gt;U+0074&lt;/code&gt; (&lt;code&gt;t&lt;/code&gt;), denoting the Unicode values &lt;code&gt;U+000A&lt;/code&gt; (LF), &lt;code&gt;U+000D&lt;/code&gt; (CR) or &lt;code&gt;U+0009&lt;/code&gt; (HT) respectively.</source>
          <target state="translated">&lt;em&gt;空白のエスケープは、&lt;/em&gt;文字の一つである &lt;code&gt;U+006E&lt;/code&gt; （ &lt;code&gt;n&lt;/code&gt; ）、 &lt;code&gt;U+0072&lt;/code&gt; （ &lt;code&gt;r&lt;/code&gt; ）、または &lt;code&gt;U+0074&lt;/code&gt; （ &lt;code&gt;t&lt;/code&gt; ユニコード値表す） &lt;code&gt;U+000A&lt;/code&gt; （LF）、 &lt;code&gt;U+000D&lt;/code&gt; （CR）または &lt;code&gt;U+0009&lt;/code&gt; （HT）それぞれ。</target>
        </trans-unit>
        <trans-unit id="733e62321cc2dbb502882e64ee8c595f1cf223e3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;whitespace escape&lt;/em&gt; is one of the characters &lt;code&gt;U+006E&lt;/code&gt; (&lt;code&gt;n&lt;/code&gt;), &lt;code&gt;U+0072&lt;/code&gt; (&lt;code&gt;r&lt;/code&gt;), or &lt;code&gt;U+0074&lt;/code&gt; (&lt;code&gt;t&lt;/code&gt;), denoting the bytes values &lt;code&gt;0x0A&lt;/code&gt; (ASCII LF), &lt;code&gt;0x0D&lt;/code&gt; (ASCII CR) or &lt;code&gt;0x09&lt;/code&gt; (ASCII HT) respectively.</source>
          <target state="translated">&lt;em&gt;空白のエスケープは、&lt;/em&gt;文字の一つである &lt;code&gt;U+006E&lt;/code&gt; （ &lt;code&gt;n&lt;/code&gt; ）、 &lt;code&gt;U+0072&lt;/code&gt; （ &lt;code&gt;r&lt;/code&gt; ）、または &lt;code&gt;U+0074&lt;/code&gt; （ &lt;code&gt;t&lt;/code&gt; バイト値を表す） &lt;code&gt;0x0A&lt;/code&gt; （ASCII LF）、 &lt;code&gt;0x0D&lt;/code&gt; の（ASCII CR）または &lt;code&gt;0x09&lt;/code&gt; の（ASCII HTを）それぞれ。</target>
        </trans-unit>
        <trans-unit id="17736723b13336b3d27ceb298ec5fb02952febad" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;workspace&lt;/em&gt; is a set of packages that share the same &lt;em&gt;Cargo.lock&lt;/em&gt; and output directory. Let&amp;rsquo;s make a project using a workspace&amp;mdash;we&amp;rsquo;ll use trivial code so we can concentrate on the structure of the workspace. There are multiple ways to structure a workspace; we&amp;rsquo;re going to show one common way. We&amp;rsquo;ll have a workspace containing a binary and two libraries. The binary, which will provide the main functionality, will depend on the two libraries. One library will provide an &lt;code&gt;add_one&lt;/code&gt; function, and a second library an &lt;code&gt;add_two&lt;/code&gt; function. These three crates will be part of the same workspace. We&amp;rsquo;ll start by creating a new directory for the workspace:</source>
          <target state="translated">&lt;em&gt;ワークスペースは、&lt;/em&gt;同じ共有パッケージのセットです&lt;em&gt;Cargo.lock&lt;/em&gt;と出力ディレクトリを。ワークスペースを使用してプロジェクトを作成してみましょう。簡単なコードを使用して、ワークスペースの構造に集中できるようにします。ワークスペースを構成する方法はいくつかあります。 1つの一般的な方法を示します。バイナリと2つのライブラリを含むワークスペースがあります。主な機能を提供するバイナリは、2つのライブラリに依存します。 1つのライブラリは &lt;code&gt;add_one&lt;/code&gt; 関数を提供し、2番目のライブラリは &lt;code&gt;add_two&lt;/code&gt; 関数を提供します。これらの3つの木枠は、同じワークスペースの一部になります。まず、ワークスペース用の新しいディレクトリを作成します。</target>
        </trans-unit>
        <trans-unit id="57b97a971f9a5924055674cfb5ecccdeda84f005" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;multiprocessor&lt;/strong&gt; system executing multiple hardware threads at the same time: In multi-threaded scenarios, you can use two kinds of primitives to deal with synchronization:</source>
          <target state="translated">&lt;strong&gt;マルチ&lt;/strong&gt;同時に複数のハードウェアスレッドを実行するシステムは、マルチスレッドのシナリオでは、同期化に対処するプリミティブの二種類を使用することができます。</target>
        </trans-unit>
        <trans-unit id="9915cb86be4513e2479c88bd6630c4bace88619c" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;send&lt;/strong&gt; operation can only fail if the receiving end of a channel is disconnected, implying that the data could never be received. The error contains the data being sent as a payload so it can be recovered.</source>
          <target state="translated">&lt;strong&gt;送信&lt;/strong&gt;チャネルの受信側がデータを受信することはないことができることを意味している、切断された場合の動作にのみ失敗する可能性があります。エラーには、ペイロードとして送信されるデータが含まれているため、回復できます。</target>
        </trans-unit>
        <trans-unit id="45d6b0e56e209127760ab52ba9ab193c0dce03db" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;single processor&lt;/strong&gt; executing instructions &lt;a href=&quot;https://en.wikipedia.org/wiki/Out-of-order_execution&quot;&gt;out-of-order&lt;/a&gt;: Modern CPUs are capable of &lt;a href=&quot;https://en.wikipedia.org/wiki/Superscalar_processor&quot;&gt;superscalar&lt;/a&gt; execution, i.e., multiple instructions might be executing at the same time, even though the machine code describes a sequential process.</source>
          <target state="translated">&lt;strong&gt;単一のプロセッサ&lt;/strong&gt;命令を実行する&lt;a href=&quot;https://en.wikipedia.org/wiki/Out-of-order_execution&quot;&gt;アウトオブオーダー&lt;/a&gt;：現代CPUは可能である&lt;a href=&quot;https://en.wikipedia.org/wiki/Superscalar_processor&quot;&gt;スーパースカラー&lt;/a&gt;実行、すなわち、複数の命令は、マシンコードがシーケンシャルプロセスを記述していても、同時に実行されるかもしれません。</target>
        </trans-unit>
        <trans-unit id="f80e6281478ac21b10d3f64a5db5116d11300661" translate="yes" xml:space="preserve">
          <source>A B-Tree instead makes each node contain B-1 to 2B-1 elements in a contiguous array. By doing this, we reduce the number of allocations by a factor of B, and improve cache efficiency in searches. However, this does mean that searches will have to do &lt;em&gt;more&lt;/em&gt; comparisons on average. The precise number of comparisons depends on the node search strategy used. For optimal cache efficiency, one could search the nodes linearly. For optimal comparisons, one could search the node using binary search. As a compromise, one could also perform a linear search that initially only checks every i&lt;sup&gt;th&lt;/sup&gt; element for some choice of i.</source>
          <target state="translated">代わりにBツリーは、各ノードに連続した配列のB-1から2B-1の要素を含めます。これにより、割り当て数をB倍に削減し、検索のキャッシュ効率を向上させます。ただし、これは平均して&lt;em&gt;より多くの&lt;/em&gt;比較を行う必要があることを意味します。比較の正確な数は、使用するノード検索戦略によって異なります。最適なキャッシュ効率のために、ノードを線形的に検索することができます。最適な比較のために、バイナリサーチを使用してノードを検索できます。妥協案として、iの選択について最初はすべてのi &lt;sup&gt;番目の&lt;/sup&gt;要素のみをチェックする線形検索を実行することもできます。</target>
        </trans-unit>
        <trans-unit id="4c64fcf1b73694ea8bba81897d2a64705afb1b18" translate="yes" xml:space="preserve">
          <source>A C-variadic type is used to give an undefined number of parameters to a given function (like &lt;code&gt;printf&lt;/code&gt; in C). The equivalent in Rust would be to use macros directly (like &lt;code&gt;println!&lt;/code&gt; for example).</source>
          <target state="translated">C可変個引数型は、特定の関数（Cの &lt;code&gt;printf&lt;/code&gt; など）に未定義の数のパラメーターを与えるために使用されます。Rustでの同等の機能は、マクロを直接使用することです（たとえば、 &lt;code&gt;println!&lt;/code&gt; など）。</target>
        </trans-unit>
        <trans-unit id="c719a71ad064f07814cb183dc83cacff56d42170" translate="yes" xml:space="preserve">
          <source>A Closer Look at an HTTP Request</source>
          <target state="translated">HTTP リクエストの詳細</target>
        </trans-unit>
        <trans-unit id="225f2cd7742ef94df62bae5174a9097b85507248" translate="yes" xml:space="preserve">
          <source>A Condition Variable</source>
          <target state="translated">条件変数</target>
        </trans-unit>
        <trans-unit id="e89d14f838ea1a71651772640c4009592aced676" translate="yes" xml:space="preserve">
          <source>A Rust binary or library.</source>
          <target state="translated">Rust のバイナリまたはライブラリ。</target>
        </trans-unit>
        <trans-unit id="16eac1f550799edbb7e48476dda921af52e9a679" translate="yes" xml:space="preserve">
          <source>A Rust program has identical meaning if each whitespace element is replaced with any other legal whitespace element, such as a single space character.</source>
          <target state="translated">Rust プログラムは、各ホワイトスペース要素がスペース 1 文字などの他の合法的なホワイトスペース要素で置き換えられている場合、同一の意味を持ちます。</target>
        </trans-unit>
        <trans-unit id="3436eb9d1ac524996565fc93c80cf6376e000505" translate="yes" xml:space="preserve">
          <source>A Rust source file describes a module, the name and location of which &amp;mdash; in the module tree of the current crate &amp;mdash; are defined from outside the source file: either by an explicit &lt;a href=&quot;items/modules&quot;&gt;&lt;em&gt;Module&lt;/em&gt;&lt;/a&gt; item in a referencing source file, or by the name of the crate itself. Every source file is a module, but not every module needs its own source file: &lt;a href=&quot;items/modules&quot;&gt;module definitions&lt;/a&gt; can be nested within one file.</source>
          <target state="translated">Rustソースファイルはモジュールを記述します。その名前と場所（現在のクレートのモジュールツリー内）は、ソースファイルの外部から定義されます。参照するソースファイルの明示的な&lt;a href=&quot;items/modules&quot;&gt;&lt;em&gt;Module&lt;/em&gt;&lt;/a&gt;アイテム、または木枠自体。すべてのソースファイルはモジュールですが、すべてのモジュールが独自のソースファイルを必要とするわけではありません。&lt;a href=&quot;items/modules&quot;&gt;モジュール定義&lt;/a&gt;は1つのファイル内にネストできます。</target>
        </trans-unit>
        <trans-unit id="7e4ee862d170940577240b6a363de9c90118288a" translate="yes" xml:space="preserve">
          <source>A Shortcut for Propagating Errors: the &lt;code id=&quot;a-shortcut-for-propagating-errors-the--operator&quot;&gt;?&lt;/code&gt; Operator</source>
          <target state="translated">エラーを伝播するためのショートカット： &lt;code id=&quot;a-shortcut-for-propagating-errors-the--operator&quot;&gt;?&lt;/code&gt; オペレーター</target>
        </trans-unit>
        <trans-unit id="e0701ba8496c6c0ce0663c50dfed3d1742ffe428" translate="yes" xml:space="preserve">
          <source>A TCP socket server, listening for connections.</source>
          <target state="translated">TCP ソケットサーバで、接続をリッスンします。</target>
        </trans-unit>
        <trans-unit id="18b391c1b0a22ff1e173b47c159e749d6face6b8" translate="yes" xml:space="preserve">
          <source>A TCP stream between a local and a remote socket.</source>
          <target state="translated">ローカルとリモートのソケット間の TCP ストリーム。</target>
        </trans-unit>
        <trans-unit id="14cd46b40ffb5428999e053c5d3b3c28ef9b4547" translate="yes" xml:space="preserve">
          <source>A Touch of Refactoring</source>
          <target state="translated">リファクタリングのタッチ</target>
        </trans-unit>
        <trans-unit id="f8b80e8d44eb439e0e6a949110529d41c8e00ad6" translate="yes" xml:space="preserve">
          <source>A Tour of The Rust Standard Library</source>
          <target state="translated">ラスト・スタンダード・ライブラリーを巡る</target>
        </trans-unit>
        <trans-unit id="816b40a1a34bc0276678819c021264566903408c" translate="yes" xml:space="preserve">
          <source>A UDP socket.</source>
          <target state="translated">UDP ソケットです。</target>
        </trans-unit>
        <trans-unit id="276e8a17fbe2956e663b37ba194fe05fa5a8f2c4" translate="yes" xml:space="preserve">
          <source>A UTF-8 encoded, growable string.</source>
          <target state="translated">UTF-8でエンコードされた成長可能な文字列。</target>
        </trans-unit>
        <trans-unit id="bb20973ca0b74c01c90760f89fd1e1ce6ddd0490" translate="yes" xml:space="preserve">
          <source>A Unix datagram socket.</source>
          <target state="translated">Unix データグラムソケット。</target>
        </trans-unit>
        <trans-unit id="a23c9f511bfc020ca8a27e2556501e3c327d1d73" translate="yes" xml:space="preserve">
          <source>A Unix stream socket.</source>
          <target state="translated">Unix ストリームソケット。</target>
        </trans-unit>
        <trans-unit id="3ad52f3aeb1d324427854f3ea2a73655c8ec06e9" translate="yes" xml:space="preserve">
          <source>A Use Case for Interior Mutability: Mock Objects</source>
          <target state="translated">内部変異性のユースケース モックオブジェクト</target>
        </trans-unit>
        <trans-unit id="822d2ee37fadc9a2c447d0ca642e7e4a4d011579" translate="yes" xml:space="preserve">
          <source>A Windows path prefix, e.g., &lt;code&gt;C:&lt;/code&gt; or &lt;code&gt;\\server\share&lt;/code&gt;.</source>
          <target state="translated">Windowsパスプレフィックス（例 &lt;code&gt;C:&lt;/code&gt; または &lt;code&gt;\\server\share&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="37a911d0c1b6b4316ddb2ac619c44257424a4bb3" translate="yes" xml:space="preserve">
          <source>A Windows path prefix, e.g., &lt;code&gt;C:&lt;/code&gt; or &lt;code&gt;\server\share&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;C:&lt;/code&gt; や &lt;code&gt;\server\share&lt;/code&gt; などのWindowsパスプレフィックス。</target>
        </trans-unit>
        <trans-unit id="ff93a614690d1d51c188c5129e768aec7cd0c763" translate="yes" xml:space="preserve">
          <source>A barrier enables multiple threads to synchronize the beginning of some computation.</source>
          <target state="translated">バリアは、複数のスレッドがいくつかの計算の開始を同期させることを可能にします。</target>
        </trans-unit>
        <trans-unit id="c1ac9e66093aa4ca440868ee501f91a3a0e906b0" translate="yes" xml:space="preserve">
          <source>A barrier will block &lt;code&gt;n&lt;/code&gt;-1 threads which call &lt;a href=&quot;#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; and then wake up all threads at once when the &lt;code&gt;n&lt;/code&gt;th thread calls &lt;a href=&quot;#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">バリアは、&lt;a href=&quot;#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;を呼び出す &lt;code&gt;n&lt;/code&gt; -1スレッドをブロックし、 &lt;code&gt;n&lt;/code&gt; 番目のスレッドが&lt;a href=&quot;#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; を&lt;/a&gt;呼び出すと、すべてのスレッドを一度に起動します。</target>
        </trans-unit>
        <trans-unit id="62ccc167e0423bac501b2cd57e5b7720dec15103" translate="yes" xml:space="preserve">
          <source>A barrier will block &lt;code&gt;n&lt;/code&gt;-1 threads which call &lt;a href=&quot;struct.barrier#method.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt; and then wake up all threads at once when the &lt;code&gt;n&lt;/code&gt;th thread calls &lt;a href=&quot;struct.barrier#method.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">バリアは、&lt;a href=&quot;struct.barrier#method.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt;を呼び出す &lt;code&gt;n&lt;/code&gt; -1個のスレッドをブロックし、 &lt;code&gt;n&lt;/code&gt; 番目のスレッドが&lt;a href=&quot;struct.barrier#method.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; を&lt;/a&gt;呼び出すと、すべてのスレッドを一度にウェイクアップします。</target>
        </trans-unit>
        <trans-unit id="58cdbd4e4749375a003884d9f4eb272538b31a8e" translate="yes" xml:space="preserve">
          <source>A basic example:</source>
          <target state="translated">基本的な例です。</target>
        </trans-unit>
        <trans-unit id="b427e17a0965dfac7d96b4ee22a549d95854674d" translate="yes" xml:space="preserve">
          <source>A basic string declaration of &lt;code&gt;&amp;amp;str&lt;/code&gt; type:</source>
          <target state="translated">&lt;code&gt;&amp;amp;str&lt;/code&gt; タイプの基本的な文字列宣言：</target>
        </trans-unit>
        <trans-unit id="e58e2e213f635868b8917c1f64d97bcd94087385" translate="yes" xml:space="preserve">
          <source>A binary assignment operator like &lt;code&gt;+=&lt;/code&gt; or &lt;code&gt;^=&lt;/code&gt; was applied to a type that doesn't support it.</source>
          <target state="translated">&lt;code&gt;+=&lt;/code&gt; や &lt;code&gt;^=&lt;/code&gt; ようなバイナリ代入演算子が、それをサポートしない型に適用されました。</target>
        </trans-unit>
        <trans-unit id="807a8b4172841ae84d2493b466a14c239a712c9e" translate="yes" xml:space="preserve">
          <source>A binary can only have one entry point, and by default that entry point is the &lt;code&gt;main()&lt;/code&gt; function. If there are multiple instances of this function, please rename one of them.</source>
          <target state="translated">バイナリは1つのエントリポイントしか持てません。デフォルトでは、そのエントリポイントは &lt;code&gt;main()&lt;/code&gt; 関数です。この関数のインスタンスが複数ある場合は、そのうちの1つを名前変更してください。</target>
        </trans-unit>
        <trans-unit id="5f95a7b46c7703730f6563de2663542b39249317" translate="yes" xml:space="preserve">
          <source>A binary can only have one entry point, and by default that entry point is the function &lt;code&gt;main()&lt;/code&gt;. If there are multiple such functions, please rename one.</source>
          <target state="translated">バイナリはエントリポイントを1つだけ持つことができ、デフォルトではそのエントリポイントは関数 &lt;code&gt;main()&lt;/code&gt; です。そのような機能が複数ある場合は、名前を変更してください。</target>
        </trans-unit>
        <trans-unit id="66f8440b5cbe5979ef5cd4aca43bf502a1ba0914" translate="yes" xml:space="preserve">
          <source>A binary operation was attempted on a type which doesn't support it.</source>
          <target state="translated">サポートされていない型でバイナリ操作が試みられました。</target>
        </trans-unit>
        <trans-unit id="b38f665f61e73d6f968e8571206665e15cc36346" translate="yes" xml:space="preserve">
          <source>A binary operation was attempted on a type which doesn't support it. Erroneous code example:</source>
          <target state="translated">サポートされていない型でバイナリ操作が試みられました。誤ったコード例です。</target>
        </trans-unit>
        <trans-unit id="aa172e5751306c59c090e9db789e410971427e9e" translate="yes" xml:space="preserve">
          <source>A binding shadowed something it shouldn't.</source>
          <target state="translated">縛りが何かに影を落としていた。</target>
        </trans-unit>
        <trans-unit id="2196fa2a21cb36f1296a2eab8560f7f044fc56a6" translate="yes" xml:space="preserve">
          <source>A block expression as the tail expression of another block expression.</source>
          <target state="translated">別のブロック表現の末尾表現としてのブロック表現。</target>
        </trans-unit>
        <trans-unit id="a693c9a42f3c8985b5be041d70547d78d1d2e744" translate="yes" xml:space="preserve">
          <source>A block of code can be prefixed with the &lt;code&gt;unsafe&lt;/code&gt; keyword to permit &lt;a href=&quot;../unsafety&quot;&gt;unsafe operations&lt;/a&gt;. Examples:</source>
          <target state="translated">&lt;a href=&quot;../unsafety&quot;&gt;安全でない操作&lt;/a&gt;を許可するために、コードのブロックの前に &lt;code&gt;unsafe&lt;/code&gt; キーワードを付けることができます。例：</target>
        </trans-unit>
        <trans-unit id="3f1de3ecbc17ea9a1f67c2ee7ad38362f83951f6" translate="yes" xml:space="preserve">
          <source>A block of code can be prefixed with the &lt;code&gt;unsafe&lt;/code&gt; keyword, to permit calling &lt;code&gt;unsafe&lt;/code&gt; functions or dereferencing raw pointers within a safe function.</source>
          <target state="translated">コードのブロックの前に &lt;code&gt;unsafe&lt;/code&gt; キーワードを付けると、安全で &lt;code&gt;unsafe&lt;/code&gt; 関数を呼び出したり、安全な関数内で生のポインタを逆参照したりできます。</target>
        </trans-unit>
        <trans-unit id="e2aaacb371035dfa3169004d8d112f1e5b1ca71a" translate="yes" xml:space="preserve">
          <source>A blog post starts as an empty draft.</source>
          <target state="translated">ブログ記事は空の下書きから始まります。</target>
        </trans-unit>
        <trans-unit id="beb16f573b8715d8a98aa06e002398f8060629f2" translate="yes" xml:space="preserve">
          <source>A boolean type which can be safely shared between threads.</source>
          <target state="translated">スレッド間で安全に共有できるブール型。</target>
        </trans-unit>
        <trans-unit id="eb779fca6863a6a0d358d8e696c27d09f35c87e4" translate="yes" xml:space="preserve">
          <source>A borrow of a constant containing interior mutability was attempted.</source>
          <target state="translated">内部変異性を含む定数の借用を試みた。</target>
        </trans-unit>
        <trans-unit id="3d64914b686b3e740569b7a037982d02419990a4" translate="yes" xml:space="preserve">
          <source>A borrow of a constant containing interior mutability was attempted. Erroneous code example:</source>
          <target state="translated">内部変異性を含む定数の借用が試みられました。誤ったコード例です。</target>
        </trans-unit>
        <trans-unit id="6c3704913d69bb40474f716695cc894d7bfa528c" translate="yes" xml:space="preserve">
          <source>A borrow of a thread-local variable was made inside a function which outlived the lifetime of the function.</source>
          <target state="translated">スレッドローカル変数の借用が関数内で行われましたが、その関数の寿命が切れてしまいました。</target>
        </trans-unit>
        <trans-unit id="f237c3c1919eddd418933b1a63f322a0d0d2a0eb" translate="yes" xml:space="preserve">
          <source>A borrowed value was moved out.</source>
          <target state="translated">借りた値が外に出た。</target>
        </trans-unit>
        <trans-unit id="9b2fc820fbc3d301d2c71b19ff6713c60dff7377" translate="yes" xml:space="preserve">
          <source>A borrowed variable was used by a closure.</source>
          <target state="translated">借りた変数はクロージャで使用されていました。</target>
        </trans-unit>
        <trans-unit id="c83fc1310c1c04b54cc7e1f86e92066f4da726ab" translate="yes" xml:space="preserve">
          <source>A borrowed variable was used by a closure. Example of erroneous code:</source>
          <target state="translated">借りた変数がクロージャで使用されていました。誤ったコードの例。</target>
        </trans-unit>
        <trans-unit id="b7c0d93da848c216d8d60ef97d23c6ae7dfef33f" translate="yes" xml:space="preserve">
          <source>A break expression is normally associated with the innermost loop enclosing the &lt;code&gt;break&lt;/code&gt; but a label can be used to specify which enclosing loop is affected.</source>
          <target state="translated">ブレーク式は通常、 &lt;code&gt;break&lt;/code&gt; を囲む最も内側のループに関連付けられていますが、ラベルを使用して、影響を受ける囲みループを指定できます。</target>
        </trans-unit>
        <trans-unit id="4584a71b04a4125f9586dd4d0599984c41f8d406" translate="yes" xml:space="preserve">
          <source>A broadcast address has all octets set to 255 as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc919&quot;&gt;IETF RFC 919&lt;/a&gt;.</source>
          <target state="translated">ブロードキャストアドレスでは、&lt;a href=&quot;https://tools.ietf.org/html/rfc919&quot;&gt;IETF RFC 919で&lt;/a&gt;定義されているように、すべてのオクテットが255に設定されています。</target>
        </trans-unit>
        <trans-unit id="a5ed95e144c4e88ac8aa93a227c762654f2cb478" translate="yes" xml:space="preserve">
          <source>A buffer that's too small:</source>
          <target state="translated">狭すぎるバッファ。</target>
        </trans-unit>
        <trans-unit id="4b481eff295b8689efc0884b27cfb033e7e5efe6" translate="yes" xml:space="preserve">
          <source>A buffer type used with &lt;code&gt;Read::read_vectored&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Read::read_vectored&lt;/code&gt; 使用されるバッファタイプ。</target>
        </trans-unit>
        <trans-unit id="bc33ba1a0c8fc7e0d6803cc242c896b07605dc58" translate="yes" xml:space="preserve">
          <source>A buffer type used with &lt;code&gt;Write::write_vectored&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Write::write_vectored&lt;/code&gt; 使用されるバッファタイプ。</target>
        </trans-unit>
        <trans-unit id="9634bddc5eaddedf795f81dbe84a65e742c0b750" translate="yes" xml:space="preserve">
          <source>A builder for computing where in a HashMap a key-value pair would be stored.</source>
          <target state="translated">HashMap内のキーと値のペアが格納される場所を計算するためのビルダーです。</target>
        </trans-unit>
        <trans-unit id="164e9f9ed41b273049862041cd75d7cccf4e70e8" translate="yes" xml:space="preserve">
          <source>A builder used to create directories in various manners.</source>
          <target state="translated">様々なマナーでディレクトリを作成するために使用されるビルダーです。</target>
        </trans-unit>
        <trans-unit id="d9b7dd70756681f35180b19cd1bfebd1be340c71" translate="yes" xml:space="preserve">
          <source>A builtin-macro was defined more than once.</source>
          <target state="translated">ビルトインマクロが複数回定義されていました。</target>
        </trans-unit>
        <trans-unit id="3712794ff88bfb37526db3c27354e391cdfb3531" translate="yes" xml:space="preserve">
          <source>A by-value &lt;a href=&quot;../primitive.array&quot;&gt;array&lt;/a&gt; iterator.</source>
          <target state="translated">値による&lt;a href=&quot;../primitive.array&quot;&gt;配列&lt;/a&gt;イテレータ。</target>
        </trans-unit>
        <trans-unit id="db1dde52635a5e1dfcc3c9c412ee03038fd5a1fd" translate="yes" xml:space="preserve">
          <source>A byte constant wasn't correctly ended.</source>
          <target state="translated">バイト定数が正しく終了しませんでした。</target>
        </trans-unit>
        <trans-unit id="358ac47a7f574535f0a6c2b6627900a1db482bcb" translate="yes" xml:space="preserve">
          <source>A call to &lt;code&gt;Drop::drop&lt;/code&gt; for that value, if this special &lt;code&gt;Drop&lt;/code&gt; trait is implemented for its type.</source>
          <target state="translated">この特別な &lt;code&gt;Drop&lt;/code&gt; 特性がそのタイプに実装されている場合、その値に対する &lt;code&gt;Drop::drop&lt;/code&gt; 呼び出し。</target>
        </trans-unit>
        <trans-unit id="6f6bbc745c6c0811da9c03d5975cfda20a1ec075" translate="yes" xml:space="preserve">
          <source>A call to &lt;code&gt;park&lt;/code&gt; does not guarantee that the thread will remain parked forever, and callers should be prepared for this possibility.</source>
          <target state="translated">&lt;code&gt;park&lt;/code&gt; への呼び出しは、スレッドが永久にパークされたままであることを保証するものではなく、呼び出し側はこの可能性に備える必要があります。</target>
        </trans-unit>
        <trans-unit id="068d1bfcec9a1ae7628a6bb97579dd58498f1145" translate="yes" xml:space="preserve">
          <source>A captured variable in a closure may not live long enough.</source>
          <target state="translated">クロージャ内のキャプチャされた変数は、十分に長くは生きられないかもしれません。</target>
        </trans-unit>
        <trans-unit id="87031d3ddac7dc2da2592a12784d3310334c67dd" translate="yes" xml:space="preserve">
          <source>A cast between a thin and a fat pointer was attempted.</source>
          <target state="translated">細いポインターと太いポインターの間にキャストを入れようとした。</target>
        </trans-unit>
        <trans-unit id="fa8c8681d28baf8dc8f1366a76e05505996e07da" translate="yes" xml:space="preserve">
          <source>A cast to &lt;code&gt;char&lt;/code&gt; was attempted on a type other than &lt;code&gt;u8&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; へのキャストが &lt;code&gt;u8&lt;/code&gt; 以外のタイプで試行されました。</target>
        </trans-unit>
        <trans-unit id="7d806d6a4232967c179bddb0726f09f0a0c1cae9" translate="yes" xml:space="preserve">
          <source>A cast to an unsized type was attempted.</source>
          <target state="translated">サイズのないタイプへのキャストを試みました。</target>
        </trans-unit>
        <trans-unit id="7ab45f97583623706555b717305df511d6d6755b" translate="yes" xml:space="preserve">
          <source>A channel in programming has two halves: a transmitter and a receiver. The transmitter half is the upstream location where you put rubber ducks into the river, and the receiver half is where the rubber duck ends up downstream. One part of your code calls methods on the transmitter with the data you want to send, and another part checks the receiving end for arriving messages. A channel is said to be &lt;em&gt;closed&lt;/em&gt; if either the transmitter or receiver half is dropped.</source>
          <target state="translated">プログラミングのチャネルには、送信機と受信機の2つの半分があります。トランスミッターの半分はゴム製のアヒルを川に入れる上流の場所であり、レシーバーの半分はゴム製のアヒルが下流に到達する場所です。コードの一部では、送信するデータを使用してトランスミッターのメソッドを呼び出し、別の部分では、受信側で到着メッセージを確認します。トランスミッターまたはレシーバーの半分がドロップされると、チャネルは&lt;em&gt;閉じられた&lt;/em&gt;と言います。</target>
        </trans-unit>
        <trans-unit id="9b271c9cb4969ff9e8017b48dea5ee7ea287981f" translate="yes" xml:space="preserve">
          <source>A character literal wasn't ended with a quote.</source>
          <target state="translated">文字リテラルは引用で終わらなかった。</target>
        </trans-unit>
        <trans-unit id="730c231d230d4d65e9a1cdedca314d8b69b7866c" translate="yes" xml:space="preserve">
          <source>A character type.</source>
          <target state="translated">文字の種類。</target>
        </trans-unit>
        <trans-unit id="195b8c50281f62fd27ad7158cd7ae79ac4f9afca" translate="yes" xml:space="preserve">
          <source>A classification of floating point numbers.</source>
          <target state="translated">浮動小数点数の分類。</target>
        </trans-unit>
        <trans-unit id="dea8ae8b6b70c73b2cce436aaeecb02e010d0c2b" translate="yes" xml:space="preserve">
          <source>A clobber was surrounded by braces in the &lt;code&gt;llvm_asm&lt;/code&gt; macro.</source>
          <target state="translated">&lt;code&gt;llvm_asm&lt;/code&gt; マクロでは、中括弧で囲まれています。</target>
        </trans-unit>
        <trans-unit id="52397aa21f3cbabb1bcadcab29fd5a79bd3be6ee" translate="yes" xml:space="preserve">
          <source>A clone-on-write smart pointer.</source>
          <target state="translated">クローンオンライトのスマートポインタ。</target>
        </trans-unit>
        <trans-unit id="17d70d4cf5c4adf5f0753809fb9cb729a2f8379d" translate="yes" xml:space="preserve">
          <source>A closure expression denotes a function that maps a list of parameters onto the expression that follows the parameters. Just like a &lt;a href=&quot;../statements#let-statements&quot;&gt;&lt;code&gt;let&lt;/code&gt; binding&lt;/a&gt;, the parameters are irrefutable &lt;a href=&quot;../patterns&quot;&gt;patterns&lt;/a&gt;, whose type annotation is optional and will be inferred from context if not given. Each closure expression has a unique, anonymous type.</source>
          <target state="translated">クロージャー式は、パラメーターのリストを、パラメーターに続く式にマップする関数を示します。&lt;a href=&quot;../statements#let-statements&quot;&gt; &lt;code&gt;let&lt;/code&gt; バインディング&lt;/a&gt;と同様に、パラメーターは反駁できない&lt;a href=&quot;../patterns&quot;&gt;パターン&lt;/a&gt;であり、その型注釈はオプションであり、指定されない場合はコンテキストから推測されます。各クロージャー式には、一意の匿名型があります。</target>
        </trans-unit>
        <trans-unit id="229f7ae12c2338583566d98b6347b250aaf7fe51" translate="yes" xml:space="preserve">
          <source>A closure has been used as &lt;code&gt;static&lt;/code&gt;.</source>
          <target state="translated">クロージャーは &lt;code&gt;static&lt;/code&gt; として使用されています。</target>
        </trans-unit>
        <trans-unit id="a9e518044a28e364a6d5caf649a49a37d36a9e44" translate="yes" xml:space="preserve">
          <source>A closure is &lt;a href=&quot;../special-types-and-traits#clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; if it does not capture any values by unique immutable or mutable reference, and if all values it captures by copy or move are &lt;a href=&quot;../special-types-and-traits#clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, respectively.</source>
          <target state="translated">閉鎖はある&lt;a href=&quot;../special-types-and-traits#clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;../special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;、それが独特の不変または可変参照することにより任意の値をキャプチャしていない場合は、コピーまたは移動することによって、それはキャプチャすべての値がある場合、&lt;a href=&quot;../special-types-and-traits#clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;../special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;、それぞれ。</target>
        </trans-unit>
        <trans-unit id="f47eb76e99123d39021af1de1b77a6fbf1ed2931" translate="yes" xml:space="preserve">
          <source>A closure is &lt;a href=&quot;../special-types-and-traits#send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt; if all variables captured by non-unique immutable reference are &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;, and all values captured by unique immutable or mutable reference, copy, or move are &lt;a href=&quot;../special-types-and-traits#send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">閉鎖はされて&lt;a href=&quot;../special-types-and-traits#send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt;一意でない不変の参照で撮影したすべての変数がある場合&lt;a href=&quot;../special-types-and-traits#sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt;、および独自の不変または可変の参照、コピー、または移動で撮影したすべての値がされて&lt;a href=&quot;../special-types-and-traits#send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0d261d9dcf84a04b55a505f635cb5d6d0068277d" translate="yes" xml:space="preserve">
          <source>A closure is &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; if all captured variables are &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">キャプチャーされたすべての変数が&lt;a href=&quot;../special-types-and-traits#sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; の&lt;/a&gt;場合、クロージャーは&lt;a href=&quot;../special-types-and-traits#sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="f3dcf856d438dee9833c1d37d61c6e01baf7766e" translate="yes" xml:space="preserve">
          <source>A closure or generator was constructed that references its own type.</source>
          <target state="translated">クロージャまたはジェネレータは、それ自身の型を参照するように構築されました。</target>
        </trans-unit>
        <trans-unit id="3bcd57420ec9a5b5481261d30eb81ca537f99421" translate="yes" xml:space="preserve">
          <source>A closure was used but didn't implement the expected trait.</source>
          <target state="translated">クロージャーを使用したが、期待した形質を実装していなかった。</target>
        </trans-unit>
        <trans-unit id="c9d5fcd074a946b081167d5c176a725de44ced3d" translate="yes" xml:space="preserve">
          <source>A closure which does not move out of any captured variables implements &lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt;, indicating that it can be called by mutable reference.</source>
          <target state="translated">キャプチャされた変数の外に移動しないクロージャーは&lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt; &lt;code&gt;FnMut&lt;/code&gt; を&lt;/a&gt;実装し、変更可能な参照によって呼び出せることを示します。</target>
        </trans-unit>
        <trans-unit id="cd4b51e9607f8ce4ec972f070cc5a727f780aa02" translate="yes" xml:space="preserve">
          <source>A closure which does not mutate or move out of any captured variables implements &lt;a href=&quot;../../std/ops/trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt;, indicating that it can be called by shared reference.</source>
          <target state="translated">キャプチャされた変数を変更または移動しないクロージャーは&lt;a href=&quot;../../std/ops/trait.fn&quot;&gt; &lt;code&gt;Fn&lt;/code&gt; を&lt;/a&gt;実装し、共有参照から呼び出すことができることを示します。</target>
        </trans-unit>
        <trans-unit id="e935c8f48fd175281f69484ea6d8e34c3df1f772" translate="yes" xml:space="preserve">
          <source>A coercion can only occur at certain coercion sites in a program; these are typically places where the desired type is explicit or can be derived by propagation from explicit types (without type inference). Possible coercion sites are:</source>
          <target state="translated">想定される強制の場所は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="3d399a6fb5b1366dacbcbc3c485166cb44a8fe4f" translate="yes" xml:space="preserve">
          <source>A collection of methods that are required to format a message into a stream.</source>
          <target state="translated">メッセージをストリームにフォーマットするために必要なメソッドのコレクション。</target>
        </trans-unit>
        <trans-unit id="2a7f703e336c6bdb6cbae32714276165fd6dcc43" translate="yes" xml:space="preserve">
          <source>A common example is the &lt;code&gt;collect&lt;/code&gt; method on &lt;code&gt;Iterator&lt;/code&gt;. It has a generic type parameter with a &lt;code&gt;FromIterator&lt;/code&gt; bound, which for a &lt;code&gt;char&lt;/code&gt; iterator is implemented by &lt;code&gt;Vec&lt;/code&gt; and &lt;code&gt;String&lt;/code&gt; among others. Consider the following snippet that reverses the characters of a string:</source>
          <target state="translated">一般的な例は、 &lt;code&gt;Iterator&lt;/code&gt; の &lt;code&gt;collect&lt;/code&gt; メソッドです。これには &lt;code&gt;FromIterator&lt;/code&gt; がバインドされたジェネリック型パラメーターがあり、 &lt;code&gt;char&lt;/code&gt; イテレーターの場合、 &lt;code&gt;Vec&lt;/code&gt; や &lt;code&gt;String&lt;/code&gt; などによって実装されます。文字列の文字を逆にする次のスニペットを考えてみましょう：</target>
        </trans-unit>
        <trans-unit id="e2236ceee783d907728a27d889b17b89679caa37" translate="yes" xml:space="preserve">
          <source>A common interface for a class of types.</source>
          <target state="translated">型のクラスの共通インタフェース。</target>
        </trans-unit>
        <trans-unit id="8baf44157a38997462218326dfa5b36c89567539" translate="yes" xml:space="preserve">
          <source>A common interface for a group of types.</source>
          <target state="translated">型のグループに共通のインターフェース。</target>
        </trans-unit>
        <trans-unit id="23bb5a3938b6b7101f14bfe5b204b2401bdf9250" translate="yes" xml:space="preserve">
          <source>A common mis-conception is to think that &quot;unicast link-local addresses start with &lt;code&gt;fe80::&lt;/code&gt;&quot;, but the &lt;a href=&quot;https://tools.ietf.org/html/rfc4291&quot;&gt;IETF RFC 4291&lt;/a&gt; actually defines a stricter format for these addresses:</source>
          <target state="translated">よくある誤解は、「ユニキャストリンクローカルアドレスは &lt;code&gt;fe80::&lt;/code&gt; 始まる」と考えることですが、&lt;a href=&quot;https://tools.ietf.org/html/rfc4291&quot;&gt;IETF RFC 4291は&lt;/a&gt;実際にはこれらのアドレスに対してより厳密な形式を定義しています。</target>
        </trans-unit>
        <trans-unit id="4615ae2634801f990b77ad209e23e9d53e5c0d34" translate="yes" xml:space="preserve">
          <source>A common problem with using return values to indicate errors is that it is easy to ignore the return value, thus failing to handle the error. &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; is annotated with the &lt;code&gt;#[must_use]&lt;/code&gt; attribute, which will cause the compiler to issue a warning when a Result value is ignored. This makes &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; especially useful with functions that may encounter errors but don't otherwise return a useful value.</source>
          <target state="translated">エラーを示すために戻り値を使用する際の一般的な問題は、戻り値を無視しやすいため、エラーの処理に失敗することです。&lt;a href=&quot;enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt;は &lt;code&gt;#[must_use]&lt;/code&gt; 属性で注釈が付けられます。これにより、結果値が無視されたときにコンパイラーが警告を発行します。これにより、エラーが発生する可能性があるが、それ以外の場合は有用な値を返さない関数で、&lt;a href=&quot;enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; が&lt;/a&gt;特に役立ちます。</target>
        </trans-unit>
        <trans-unit id="9e6af95ab7d6f1c50d97f5f2eb1a6e3eebe549bf" translate="yes" xml:space="preserve">
          <source>A common trait for the ability to explicitly duplicate an object.</source>
          <target state="translated">オブジェクトを明示的に複製する能力の共通の特徴。</target>
        </trans-unit>
        <trans-unit id="0f3bf37cba543ca385f5031852ec32495e2e84e3" translate="yes" xml:space="preserve">
          <source>A common use case for &lt;code&gt;spin_loop_hint&lt;/code&gt; is implementing bounded optimistic spinning in a CAS loop in synchronization primitives. To avoid problems like priority inversion, it is strongly recommended that the spin loop is terminated after a finite amount of iterations and an appropriate blocking syscall is made.</source>
          <target state="translated">&lt;code&gt;spin_loop_hint&lt;/code&gt; の一般的な使用例は、同期プリミティブのCASループに制限付きの楽観的スピニングを実装することです。優先順位の逆転などの問題を回避するために、有限の反復回数の後にスピンループを終了し、適切なブロッキングシステムコールを実行することを強くお勧めします。</target>
        </trans-unit>
        <trans-unit id="3e2c1919c7a821f5f3bf3a38d0ef8acb4190a932" translate="yes" xml:space="preserve">
          <source>A common use for &lt;code&gt;format!&lt;/code&gt; is concatenation and interpolation of strings. The same convention is used with &lt;a href=&quot;macro.print&quot;&gt;&lt;code&gt;print!&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;macro.write&quot;&gt;&lt;code&gt;write!&lt;/code&gt;&lt;/a&gt; macros, depending on the intended destination of the string.</source>
          <target state="translated">&lt;code&gt;format!&lt;/code&gt; 一般的な使用法！文字列の連結と補間です。同じ規則が&lt;a href=&quot;macro.print&quot;&gt; &lt;code&gt;print!&lt;/code&gt; &lt;/a&gt;も使用されます！そして&lt;a href=&quot;macro.write&quot;&gt; &lt;code&gt;write!&lt;/code&gt; &lt;/a&gt;文字列の目的の宛先に応じて、マクロ。</target>
        </trans-unit>
        <trans-unit id="44fea0684e72cef1ddaf4be0010340215dffbec7" translate="yes" xml:space="preserve">
          <source>A common use of this feature is to poison shared resources when writing unsafe code, by checking &lt;code&gt;panicking&lt;/code&gt; when the &lt;code&gt;drop&lt;/code&gt; is called.</source>
          <target state="translated">この機能の一般的な用途は、 &lt;code&gt;drop&lt;/code&gt; が呼び出されたときに &lt;code&gt;panicking&lt;/code&gt; をチェックすることにより、安全でないコードを記述するときに共有リソースを汚染することです。</target>
        </trans-unit>
        <trans-unit id="3016e8bc4b1ae0cb5dbf3daaacd9d48f6d65eed5" translate="yes" xml:space="preserve">
          <source>A common way to test functionality is to compare the result of the code under test to the value you expect the code to return to make sure they&amp;rsquo;re equal. You could do this using the &lt;code&gt;assert!&lt;/code&gt; macro and passing it an expression using the &lt;code&gt;==&lt;/code&gt; operator. However, this is such a common test that the standard library provides a pair of macros&amp;mdash;&lt;code&gt;assert_eq!&lt;/code&gt; and &lt;code&gt;assert_ne!&lt;/code&gt;&amp;mdash;to perform this test more conveniently. These macros compare two arguments for equality or inequality, respectively. They&amp;rsquo;ll also print the two values if the assertion fails, which makes it easier to see &lt;em&gt;why&lt;/em&gt; the test failed; conversely, the &lt;code&gt;assert!&lt;/code&gt; macro only indicates that it got a &lt;code&gt;false&lt;/code&gt; value for the &lt;code&gt;==&lt;/code&gt; expression, not the values that lead to the &lt;code&gt;false&lt;/code&gt; value.</source>
          <target state="translated">機能をテストする一般的な方法は、テスト対象のコードの結果を、コードが返すと予想される値と比較して、それらが等しいことを確認することです。 &lt;code&gt;assert!&lt;/code&gt; を使用してこれを行うことができます！マクロを使用し、 &lt;code&gt;==&lt;/code&gt; 演算子を使用して式を渡します。ただし、これは非常に一般的なテストであるため、標準ライブラリには、 &lt;code&gt;assert_eq!&lt;/code&gt; というマクロのペアが用意されています。そして &lt;code&gt;assert_ne!&lt;/code&gt; -このテストをより便利に実行するため。これらのマクロは、2つの引数が等しいか等しくないかをそれぞれ比較します。また、アサーションが失敗した場合は2つの値を出力する&lt;em&gt;ため&lt;/em&gt;、テストが失敗した&lt;em&gt;理由を&lt;/em&gt;簡単に確認できます。逆に、 &lt;code&gt;assert!&lt;/code&gt; マクロは、それが &lt;code&gt;false&lt;/code&gt; になったことのみを示します値 &lt;code&gt;==&lt;/code&gt; 表現、しないように値をリード &lt;code&gt;false&lt;/code&gt; 値。</target>
        </trans-unit>
        <trans-unit id="6f72785cb8deaf70098be764432ad287d8764020" translate="yes" xml:space="preserve">
          <source>A common way to use &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; is in combination with &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;. Recall that &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; lets you have multiple owners of some data, but it only gives immutable access to that data. If you have an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; that holds a &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, you can get a value that can have multiple owners &lt;em&gt;and&lt;/em&gt; that you can mutate!</source>
          <target state="translated">&lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; を使用する一般的な方法は、 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; と組み合わせることです。 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 使用すると、一部のデータの複数の所有者を持つことができますが、そのデータへの不変のアクセスのみが可能であることを思い出してください。 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; を保持するRc &amp;lt;T&amp;gt;がある場合、複数の所有者&lt;em&gt;を&lt;/em&gt;持つことができ、変更できる値を取得できます！&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c3a2eb5105511775d59e5e4cd686eb5579136f33" translate="yes" xml:space="preserve">
          <source>A comparison like the one above, which ignores some fields of the struct, can be dangerous. It can easily lead to an unintended violation of the requirements for a partial equivalence relation. For example, if we kept the above implementation of &lt;code&gt;PartialEq&amp;lt;Book&amp;gt;&lt;/code&gt; for &lt;code&gt;BookFormat&lt;/code&gt; and added an implementation of &lt;code&gt;PartialEq&amp;lt;Book&amp;gt;&lt;/code&gt; for &lt;code&gt;Book&lt;/code&gt; (either via a &lt;code&gt;#[derive]&lt;/code&gt; or via the manual implementation from the first example) then the result would violate transitivity:</source>
          <target state="translated">構造体の一部のフィールドを無視する上記のような比較は危険な場合があります。半同値関係の要件に意図せず違反する可能性があります。我々は上記の実装保つ場合、例えば &lt;code&gt;PartialEq&amp;lt;Book&amp;gt;&lt;/code&gt; ため &lt;code&gt;BookFormat&lt;/code&gt; の実装添加 &lt;code&gt;PartialEq&amp;lt;Book&amp;gt;&lt;/code&gt; ための &lt;code&gt;Book&lt;/code&gt; （いずれかを介して、 &lt;code&gt;#[derive]&lt;/code&gt; または第一の例からの手動実装を介して）、結果が違反推移性：</target>
        </trans-unit>
        <trans-unit id="1b20c9de094581b8f84861af4164c5552e60a2ee" translate="yes" xml:space="preserve">
          <source>A compile time error is never emitted when using this macro regardless of whether the environment variable is present or not.</source>
          <target state="translated">環境変数があるかどうかに関わらず、このマクロを使用してもコンパイル時のエラーは発生しません。</target>
        </trans-unit>
        <trans-unit id="378954a8b28d0b17cfcc628e2457199a86abdd79" translate="yes" xml:space="preserve">
          <source>A compiler memory fence.</source>
          <target state="translated">コンパイラのメモリフェンス。</target>
        </trans-unit>
        <trans-unit id="592fedd9ba4ca1ae2681effb1b9b42a165b45c38" translate="yes" xml:space="preserve">
          <source>A compiler-only memory barrier.</source>
          <target state="translated">コンパイラ専用のメモリバリア。</target>
        </trans-unit>
        <trans-unit id="5af9d265d7cc350d6c8dd5eca2e52c0984df494d" translate="yes" xml:space="preserve">
          <source>A configuration option. It is true if the option is set and false if it is unset.</source>
          <target state="translated">設定オプション。このオプションが設定されている場合は真、設定されていない場合は偽となります。</target>
        </trans-unit>
        <trans-unit id="3457f182555f50a2c7cffa76112cf04e013ed4c3" translate="yes" xml:space="preserve">
          <source>A consequence of the borrowing rules is that when you have an immutable value, you can&amp;rsquo;t borrow it mutably. For example, this code won&amp;rsquo;t compile:</source>
          <target state="translated">借用ルールの結果として、不変の値がある場合、それを可変に借用することはできません。たとえば、次のコードはコンパイルされません。</target>
        </trans-unit>
        <trans-unit id="82e92c5c9841d5d2d3e69bff0f6aeb9309a13f00" translate="yes" xml:space="preserve">
          <source>A constant item was initialized with something that is not a constant expression.</source>
          <target state="translated">定数式ではないもので定数項目が初期化されていました。</target>
        </trans-unit>
        <trans-unit id="5ce86a2e004403aa5ba6b72a885c67d143829985" translate="yes" xml:space="preserve">
          <source>A constant value failed to get evaluated.</source>
          <target state="translated">定数値の評価に失敗しました。</target>
        </trans-unit>
        <trans-unit id="2574c153f328b1e202d9e64649cb65b6702dbcde" translate="yes" xml:space="preserve">
          <source>A contiguous growable array type with heap-allocated contents, written &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; と書かれた、ヒープに割り当てられたコンテンツを含む連続した拡張可能な配列型。</target>
        </trans-unit>
        <trans-unit id="ceaa636b8440544799d1a505ee00079d04849fb0" translate="yes" xml:space="preserve">
          <source>A contiguous growable array type, written &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; but pronounced 'vector'.</source>
          <target state="translated">&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; と記述されているが「ベクトル」と発音される、連続する拡張可能な配列型。</target>
        </trans-unit>
        <trans-unit id="821a3f39751014be2886a42509e99ef71f4b3a2f" translate="yes" xml:space="preserve">
          <source>A control-flow expression was used inside a const context.</source>
          <target state="translated">コントロール・フロー式が const コンテキスト内で使用されました。</target>
        </trans-unit>
        <trans-unit id="0490b6e232133e0013be8f4fef9d50c9926445a5" translate="yes" xml:space="preserve">
          <source>A convenience function that bubbles an &lt;code&gt;io::Result&lt;/code&gt; to its caller:</source>
          <target state="translated">呼び出し側に &lt;code&gt;io::Result&lt;/code&gt; をバブリングする便利な関数：</target>
        </trans-unit>
        <trans-unit id="16d79d851ab24be5a7dea27948897afa80e31902" translate="yes" xml:space="preserve">
          <source>A convenience impl that delegates to the impl for &lt;code&gt;&amp;amp;str&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&amp;amp;str&lt;/code&gt; の実装に委任する便利な実装</target>
        </trans-unit>
        <trans-unit id="35a7bd82b1e1370c217a40362b5ca9b11be11f9d" translate="yes" xml:space="preserve">
          <source>A convenience impl that delegates to the impl for &lt;code&gt;&amp;amp;str&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;amp;str&lt;/code&gt; のimplに委任する便利なimpl 。</target>
        </trans-unit>
        <trans-unit id="0847e6a8b80cb99079b74075a954fd750b19a38b" translate="yes" xml:space="preserve">
          <source>A crate is somewhat analogous to an &lt;em&gt;assembly&lt;/em&gt; in the ECMA-335 CLI model, a &lt;em&gt;library&lt;/em&gt; in the SML/NJ Compilation Manager, a &lt;em&gt;unit&lt;/em&gt; in the Owens and Flatt module system, or a &lt;em&gt;configuration&lt;/em&gt; in Mesa.</source>
          <target state="translated">クレートは、ECMA-335 CLIモデルの&lt;em&gt;アセンブリ&lt;/em&gt;、SML / NJ Compilation Managerの&lt;em&gt;ライブラリ&lt;/em&gt;、Owens and Flattモジュールシステムの&lt;em&gt;ユニット&lt;/em&gt;、またはMesaの&lt;em&gt;構成&lt;/em&gt;に多少似てい&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="6436f7757ac841fe0b93278e071a64e419b3a404" translate="yes" xml:space="preserve">
          <source>A crate needs a global available &quot;helper module&quot; to itself, but it doesn't want to expose the helper module as a public API. To accomplish this, the root of the crate's hierarchy would have a private module which then internally has a &quot;public API&quot;. Because the entire crate is a descendant of the root, then the entire local crate can access this private module through the second case.</source>
          <target state="translated">クレートは、グローバルに利用可能な「ヘルパーモジュール」を必要としますが、そのヘルパーモジュールをパブリックAPIとして公開したくありません。これを達成するためには、クレートの階層のルートはプライベートモジュールを持ち、そのモジュールは内部的に &quot;公開API &quot;を持ちます。クレート全体がルートの子孫であるため、ローカルのクレート全体が2番目のケースでこのプライベートモジュールにアクセスすることができます。</target>
        </trans-unit>
        <trans-unit id="bc65255cb2d6b61579af61c12db502f3b72ad815" translate="yes" xml:space="preserve">
          <source>A crate that contains a &lt;code&gt;main&lt;/code&gt;&lt;a href=&quot;items/functions&quot;&gt;function&lt;/a&gt; can be compiled to an executable. If a &lt;code&gt;main&lt;/code&gt; function is present, it must take no arguments, must not declare any &lt;a href=&quot;trait-bounds&quot;&gt;trait or lifetime bounds&lt;/a&gt;, must not have any &lt;a href=&quot;items/generics#where-clauses&quot;&gt;where clauses&lt;/a&gt;, and its return type must be one of the following:</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; &lt;a href=&quot;items/functions&quot;&gt;関数&lt;/a&gt;を含むクレートは、実行可能ファイルにコンパイルできます。 &lt;code&gt;main&lt;/code&gt; 関数が存在する場合、それは引数を取ってはならず、&lt;a href=&quot;trait-bounds&quot;&gt;トレイトまたはライフタイムの境界を&lt;/a&gt;宣言してはならず、&lt;a href=&quot;items/generics#where-clauses&quot;&gt;where句&lt;/a&gt;があってはならず、戻り値の型は次のいずれかでなければなりません。</target>
        </trans-unit>
        <trans-unit id="1dd52734851cf6f3cf436dc5839dcfddfdcaf815" translate="yes" xml:space="preserve">
          <source>A crate will group related functionality together in a scope so the functionality is easy to share between multiple projects. For example, the &lt;code&gt;rand&lt;/code&gt; crate we used in &lt;a href=&quot;ch02-00-guessing-game-tutorial#generating-a-random-number&quot;&gt;Chapter 2&lt;/a&gt; provides functionality that generates random numbers. We can use that functionality in our own projects by bringing the &lt;code&gt;rand&lt;/code&gt; crate into our project&amp;rsquo;s scope. All the functionality provided by the &lt;code&gt;rand&lt;/code&gt; crate is accessible through the crate&amp;rsquo;s name, &lt;code&gt;rand&lt;/code&gt;.</source>
          <target state="translated">クレートは、関連する機能をスコープにグループ化するため、機能は複数のプロジェクト間で簡単に共有できます。たとえば、&lt;a href=&quot;ch02-00-guessing-game-tutorial#generating-a-random-number&quot;&gt;第2章で&lt;/a&gt;使用した &lt;code&gt;rand&lt;/code&gt; クレートは、乱数を生成する機能を提供します。 &lt;code&gt;rand&lt;/code&gt; クレートをプロジェクトのスコープに含めることで、この機能を自分のプロジェクトで使用できます。 &lt;code&gt;rand&lt;/code&gt; クレートが提供するすべての機能は、クレートの名前 &lt;code&gt;rand&lt;/code&gt; を介してアクセスできます。</target>
        </trans-unit>
        <trans-unit id="9489488427833bc0214d8f4c5f5a907ee47ae129" translate="yes" xml:space="preserve">
          <source>A cross-crate opt-out trait was implemented on something which wasn't a struct or enum type.</source>
          <target state="translated">構造体や列挙型ではないものにクロスクレートのオプトアウト形質が実装されていました。</target>
        </trans-unit>
        <trans-unit id="00851a5c172b45fa5d81433f76656b498876dd4d" translate="yes" xml:space="preserve">
          <source>A cross-crate opt-out trait was implemented on something which wasn't a struct or enum type. Erroneous code example:</source>
          <target state="translated">クロス ク レ イ ト の opt-out trait が、 struct 型でも enum 型でもないものに実装 さ れていました。誤ったコード例です。</target>
        </trans-unit>
        <trans-unit id="521073eb4a9d5dea34971bbf2d3b43472252d22c" translate="yes" xml:space="preserve">
          <source>A cursor over a &lt;code&gt;LinkedList&lt;/code&gt; with editing operations.</source>
          <target state="translated">編集操作を含む &lt;code&gt;LinkedList&lt;/code&gt; 上のカーソル。</target>
        </trans-unit>
        <trans-unit id="e765e383228431ae063a8d9a831d2b82107b6c73" translate="yes" xml:space="preserve">
          <source>A cursor over a &lt;code&gt;LinkedList&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LinkedList&lt;/code&gt; の上にカーソルを置きます。</target>
        </trans-unit>
        <trans-unit id="36316fe5916fd156e2a88a749ac433147a8da4cc" translate="yes" xml:space="preserve">
          <source>A cycle between &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointers will never be deallocated. For this reason, &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; is used to break cycles. For example, a tree could have strong &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointers from parent nodes to children, and &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers from children back to their parents.</source>
          <target state="translated">&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt;ポインタ間のサイクルが割り当て解除されることはありません。このため、&lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt;はサイクルを中断するために使用されます。たとえば、ツリーには、親ノードから子への強い&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt;ポインターと、子から親への&lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt;ポインターがあります。</target>
        </trans-unit>
        <trans-unit id="3b90e3c2a1d2a35888ed9e0be0c1ef31680e920a" translate="yes" xml:space="preserve">
          <source>A cycle between &lt;code&gt;Arc&lt;/code&gt; pointers will never be deallocated. For this reason, &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; is used to break cycles. For example, a tree could have strong &lt;code&gt;Arc&lt;/code&gt; pointers from parent nodes to children, and &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers from children back to their parents.</source>
          <target state="translated">&lt;code&gt;Arc&lt;/code&gt; ポインター間のサイクルが割り当て解除されることはありません。このため、&lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt;はサイクルを中断するために使用されます。たとえば、ツリーには、親ノードから子への強い &lt;code&gt;Arc&lt;/code&gt; ポインターと、子から親への&lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt;ポインターがあります。</target>
        </trans-unit>
        <trans-unit id="cd0e6a515d806f28a3a9117a215e0567225d9f11" translate="yes" xml:space="preserve">
          <source>A data structure is in a temporarily invalid state when the thread panics.</source>
          <target state="translated">スレッドがパニックになると、データ構造が一時的に無効な状態になります。</target>
        </trans-unit>
        <trans-unit id="590870896f27fcf4f2a0264dabbc0794e9042402" translate="yes" xml:space="preserve">
          <source>A default configuration can be generated using &lt;code&gt;Command::new(program)&lt;/code&gt;, where &lt;code&gt;program&lt;/code&gt; gives a path to the program to be executed. Additional builder methods allow the configuration to be changed (for example, by adding arguments) prior to spawning:</source>
          <target state="translated">デフォルトの構成は &lt;code&gt;Command::new(program)&lt;/code&gt; を使用して生成できます。ここで、 &lt;code&gt;program&lt;/code&gt; は実行するプログラムへのパスを提供します。追加のビルダーメソッドを使用すると、スポーン前に構成を変更できます（たとえば、引数を追加することで）。</target>
        </trans-unit>
        <trans-unit id="cc1e47ebf18eca6629966fd3d1126236437b08eb" translate="yes" xml:space="preserve">
          <source>A definition of a method not in the implemented trait was given in a trait implementation.</source>
          <target state="translated">実装された形質にないメソッドの定義が形質の実装で与えられました。</target>
        </trans-unit>
        <trans-unit id="74bdee4c01f0e2a5b888cedf761fad306ec9d91d" translate="yes" xml:space="preserve">
          <source>A discriminant in an &lt;code&gt;enum&lt;/code&gt; not included in the type definition.</source>
          <target state="translated">型定義に含まれていない &lt;code&gt;enum&lt;/code&gt; 型の判別式。</target>
        </trans-unit>
        <trans-unit id="1d4413773858071be2cda9c035b93d8adb5ed9c4" translate="yes" xml:space="preserve">
          <source>A discriminant value is present more than once.</source>
          <target state="translated">判別値が複数回存在する。</target>
        </trans-unit>
        <trans-unit id="e33398f8a1c82819cfc272eb4db0376550aceebc" translate="yes" xml:space="preserve">
          <source>A doc comment that is not attached to anything has been encountered.</source>
          <target state="translated">何にも添付されていないdocコメントが発生しました。</target>
        </trans-unit>
        <trans-unit id="449c61354d124e018f4ac7cc6a32776bf259e4bc" translate="yes" xml:space="preserve">
          <source>A documentation comment that doesn't document anything was found.</source>
          <target state="translated">何も文書化されていない文書コメントが見つかりました。</target>
        </trans-unit>
        <trans-unit id="b5da65d7d41e577505a8697b6d53146c919ad568" translate="yes" xml:space="preserve">
          <source>A double quote byte string (&lt;code&gt;b&quot;&lt;/code&gt;) was not terminated.</source>
          <target state="translated">二重引用符のバイト文字列（ &lt;code&gt;b&quot;&lt;/code&gt; ）は終了しませんでした。</target>
        </trans-unit>
        <trans-unit id="6c189219618ff090bbaf1c282c8ad43303eb7709" translate="yes" xml:space="preserve">
          <source>A double quote string (&lt;code&gt;&quot;&lt;/code&gt;) was not terminated.</source>
          <target state="translated">二重引用符（ &lt;code&gt;&quot;&lt;/code&gt; ）は終了しませんでした。</target>
        </trans-unit>
        <trans-unit id="844fc94f2ec6c20bbd8c3c61aa63bf0f8f4c60a0" translate="yes" xml:space="preserve">
          <source>A double-ended iterator with the direction inverted.</source>
          <target state="translated">方向を反転させたダブルエンドのイテレータ。</target>
        </trans-unit>
        <trans-unit id="9e374237ea1be12ca52873f6b8cd4c6757ef72d7" translate="yes" xml:space="preserve">
          <source>A double-ended queue implemented with a growable ring buffer.</source>
          <target state="translated">成長可能なリングバッファを用いて実装されたダブルエンドキュー。</target>
        </trans-unit>
        <trans-unit id="28050b20d2fb7eccf5c8a8ecb22f1b2923430db5" translate="yes" xml:space="preserve">
          <source>A doubly-linked list with owned nodes.</source>
          <target state="translated">所有ノードを持つ二重リンクリスト。</target>
        </trans-unit>
        <trans-unit id="7fb38950784a1933e77430becd7b735f7149cba0" translate="yes" xml:space="preserve">
          <source>A draining iterator for &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; のドレイン反復子。</target>
        </trans-unit>
        <trans-unit id="4c37906477f09b5f321b2effe6bce9b886812638" translate="yes" xml:space="preserve">
          <source>A draining iterator for &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; ドレイン反復子。</target>
        </trans-unit>
        <trans-unit id="429ad4a5f6fa96f2bca9279ba7532d1e6d671a36" translate="yes" xml:space="preserve">
          <source>A draining iterator over the elements of a &lt;code&gt;BinaryHeap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BinaryHeap&lt;/code&gt; の要素に対するドレイン反復子。</target>
        </trans-unit>
        <trans-unit id="91b15bef979787193522a6fe820b65bca6b71b6d" translate="yes" xml:space="preserve">
          <source>A draining iterator over the elements of a &lt;code&gt;VecDeque&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;VecDeque&lt;/code&gt; の要素のドレインイテレータ。</target>
        </trans-unit>
        <trans-unit id="6e8fa0dd341d84cbc1afdb686f6037ff7ef3d24c" translate="yes" xml:space="preserve">
          <source>A draining iterator over the entries of a &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; のエントリに対するドレインイテレータ。</target>
        </trans-unit>
        <trans-unit id="3f3d65aa6b0bc2c1da1319190787588eadcf2d84" translate="yes" xml:space="preserve">
          <source>A draining iterator over the items of a &lt;code&gt;HashSet&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HashSet&lt;/code&gt; の項目のドレインイテレータ。</target>
        </trans-unit>
        <trans-unit id="d0414ecefaa3523675384470efb07b95159dba45" translate="yes" xml:space="preserve">
          <source>A draining, filtering iterator over the entries of a &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; のエントリに対するドレイン、フィルタリングのイテレータ。</target>
        </trans-unit>
        <trans-unit id="bdb2903d11786dcb8b8844e91d87fb7f80657414" translate="yes" xml:space="preserve">
          <source>A draining, filtering iterator over the items of a &lt;code&gt;HashSet&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HashSet&lt;/code&gt; のアイテムに対する排出、フィルタリングのイテレータ。</target>
        </trans-unit>
        <trans-unit id="cc90bdb96c97b6e432d2ff036bf4b852213faf58" translate="yes" xml:space="preserve">
          <source>A dynamically sized type (DST) is a type without a statically known size or alignment.</source>
          <target state="translated">動的サイズ型(DST)とは、統計的に知られているサイズやアラインメントを持たない型のことです。</target>
        </trans-unit>
        <trans-unit id="211aeaeaf569d6a37ba4f9e761ab58dda09c15a6" translate="yes" xml:space="preserve">
          <source>A dynamically-sized view into a contiguous sequence, &lt;code&gt;[T]&lt;/code&gt;.</source>
          <target state="translated">連続するシーケンス &lt;code&gt;[T]&lt;/code&gt; への動的サイズのビュー。</target>
        </trans-unit>
        <trans-unit id="c9b7bf32fab7bb231166bbede96c90271ed78811" translate="yes" xml:space="preserve">
          <source>A dynamically-sized view into a contiguous sequence, &lt;code&gt;[T]&lt;/code&gt;. Contiguous here means that elements are laid out so that every element is the same distance from its neighbors.</source>
          <target state="translated">連続したシーケンスへの動的なサイズのビュー &lt;code&gt;[T]&lt;/code&gt; 。ここで隣接しているとは、すべての要素が隣接する要素から同じ距離になるように要素が配置されていることを意味します。</target>
        </trans-unit>
        <trans-unit id="31f05f23c58b03a01fb9e427108a188fcf6b07f3" translate="yes" xml:space="preserve">
          <source>A feature attribute named a feature that has been removed.</source>
          <target state="translated">削除されたフィーチャという名前のフィーチャ属性。</target>
        </trans-unit>
        <trans-unit id="dd28c7fe46ecde36f6e0a91f768af6503a5d1816" translate="yes" xml:space="preserve">
          <source>A feature attribute named a feature that was disallowed in the compiler command line flags.</source>
          <target state="translated">コンパイラのコマンドライン・フラグで禁止されていた機能の名前を付けたフィーチャ属性。</target>
        </trans-unit>
        <trans-unit id="80c1f2d8465e2f0474908b699c574231c3f93ea8" translate="yes" xml:space="preserve">
          <source>A fence 'A' which has (at least) &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; ordering semantics, synchronizes with a fence 'B' with (at least) &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; semantics, if and only if there exist operations X and Y, both operating on some atomic object 'M' such that A is sequenced before X, Y is synchronized before B and Y observes the change to M. This provides a happens-before dependence between A and B.</source>
          <target state="translated">（少なくとも）&lt;a href=&quot;enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt;順序付けセマンティクスを持つフェンス 'A'は、（少なくとも）&lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt;セマンティクスを持つフェンス 'B'と同期します。操作XとYが存在する場合にのみ、両方とも何らかのアトミックオブジェクト 'M'で動作します。つまり、AはXの前にシーケンスされ、YはBの前に同期され、YはMへの変更を観察します。これにより、AとBの間で発生前の依存関係が提供されます。</target>
        </trans-unit>
        <trans-unit id="55e68042fec783cba9aad8dce1b35e99ef85dbdf" translate="yes" xml:space="preserve">
          <source>A fence which has &lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;SeqCst&lt;/code&gt;&lt;/a&gt; ordering, in addition to having both &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; semantics, participates in the global program order of the other &lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;SeqCst&lt;/code&gt;&lt;/a&gt; operations and/or fences.</source>
          <target state="translated">&lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt;両方のセマンティクスを持つことに加えて、&lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;SeqCst&lt;/code&gt; &lt;/a&gt;順序を持つフェンスは、他の&lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;SeqCst&lt;/code&gt; &lt;/a&gt;操作またはフェンス、あるいはその両方のグローバルプログラム順序に参加します。</target>
        </trans-unit>
        <trans-unit id="1cb36d0ee361d78dbe2fa3dcfcac72e9a2dee2b5" translate="yes" xml:space="preserve">
          <source>A field access is a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place expression&lt;/a&gt; referring to the location of that field. When the subexpression is &lt;a href=&quot;../expressions#mutability&quot;&gt;mutable&lt;/a&gt;, the field expression is also mutable.</source>
          <target state="translated">フィールドアクセスは、そのフィールドの場所を参照する&lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;場所式&lt;/a&gt;です。サブ式が&lt;a href=&quot;../expressions#mutability&quot;&gt;mutableの&lt;/a&gt;場合、フィールド式も変更可能です。</target>
        </trans-unit>
        <trans-unit id="f7e446184b876f98fd13cf13bfdf4f57607ba15b" translate="yes" xml:space="preserve">
          <source>A file wasn't found for an out-of-line module.</source>
          <target state="translated">行外のモジュールにファイルが見つかりませんでした。</target>
        </trans-unit>
        <trans-unit id="730142c15726a49fe7ebbd5c1ceae068d1e76798" translate="yes" xml:space="preserve">
          <source>A final reason Rust doesn&amp;rsquo;t allow us to index into a &lt;code&gt;String&lt;/code&gt; to get a character is that indexing operations are expected to always take constant time (O(1)). But it isn&amp;rsquo;t possible to guarantee that performance with a &lt;code&gt;String&lt;/code&gt;, because Rust would have to walk through the contents from the beginning to the index to determine how many valid characters there were.</source>
          <target state="translated">Rustが &lt;code&gt;String&lt;/code&gt; にインデックスを付けて文字を取得することを許可しない最後の理由は、インデックス付け操作が常に一定の時間（O（1））を要すると予想されるためです。ただし、Rustはコンテンツを最初からインデックスまで順番に調べて、有効な文字の数を判断する必要があるため、 &lt;code&gt;String&lt;/code&gt; でそのパフォーマンスを保証することはできません。</target>
        </trans-unit>
        <trans-unit id="0106151a82df636bbbb97134363a6aef4336540d" translate="yes" xml:space="preserve">
          <source>A finite heterogeneous sequence, &lt;code&gt;(T, U, ..)&lt;/code&gt;.</source>
          <target state="translated">有限異種シーケンス &lt;code&gt;(T, U, ..)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="405c2e4c1352a9dd275d0dcf43af6465cfa06fc2" translate="yes" xml:space="preserve">
          <source>A fixed-size array, denoted &lt;code&gt;[T; N]&lt;/code&gt;, for the element type, &lt;code&gt;T&lt;/code&gt;, and the non-negative compile-time constant size, &lt;code&gt;N&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;[T; N]&lt;/code&gt; で表される固定サイズの配列 N]、要素タイプ &lt;code&gt;T&lt;/code&gt; および非負のコンパイル時定数サイズ &lt;code&gt;N&lt;/code&gt; の場合。</target>
        </trans-unit>
        <trans-unit id="01e8ae155635ffa00df108a976552eb0550b9e9b" translate="yes" xml:space="preserve">
          <source>A for loop is equivalent to the following block expression.</source>
          <target state="translated">forループは以下のブロック式と等価です。</target>
        </trans-unit>
        <trans-unit id="b694a59d19302341ecbd00f4fa0cb3b358a2f81b" translate="yes" xml:space="preserve">
          <source>A format string is required to use all of its arguments, otherwise it is a compile-time error. You may refer to the same argument more than once in the format string.</source>
          <target state="translated">フォーマット文字列はすべての引数を使用する必要があり、そうでない場合はコンパイル時エラーとなります。フォーマット文字列では、同じ引数を複数回参照することができます。</target>
        </trans-unit>
        <trans-unit id="01b7129399ded6b05b30578334c78e0c28495f39" translate="yes" xml:space="preserve">
          <source>A function annotated with the &lt;code&gt;test&lt;/code&gt; attribute can also be annotated with the &lt;code&gt;ignore&lt;/code&gt; attribute. The &lt;em&gt;&lt;code&gt;ignore&lt;/code&gt; attribute&lt;/em&gt; tells the test harness to not execute that function as a test. It will still be compiled when in test mode.</source>
          <target state="translated">&lt;code&gt;test&lt;/code&gt; 属性で注釈が付けられた関数には、 &lt;code&gt;ignore&lt;/code&gt; 属性で注釈を付けることもできます。&lt;em&gt; &lt;code&gt;ignore&lt;/code&gt; 属性が&lt;/em&gt;テストとしてその機能を実行しないようにテストハーネスを伝えます。テストモードでもコンパイルされます。</target>
        </trans-unit>
        <trans-unit id="05308286e6d20f1bc15a1d74d19f5246b35ba29f" translate="yes" xml:space="preserve">
          <source>A function annotated with the &lt;code&gt;test&lt;/code&gt; attribute that returns &lt;code&gt;()&lt;/code&gt; can also be annotated with the &lt;code&gt;should_panic&lt;/code&gt; attribute. The &lt;em&gt;&lt;code&gt;should_panic&lt;/code&gt; attribute&lt;/em&gt; makes the test only pass if it actually panics.</source>
          <target state="translated">&lt;code&gt;()&lt;/code&gt; を返す &lt;code&gt;test&lt;/code&gt; 属性で注釈が付けられた関数は、 &lt;code&gt;should_panic&lt;/code&gt; 属性で注釈を付けることもできます。&lt;em&gt; &lt;code&gt;should_panic&lt;/code&gt; &lt;/em&gt;&lt;em&gt;属性は、&lt;/em&gt;テストはそれだけであれば、実際にパニックを渡すことができます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d9fe742a8fa7d8036e041c35d1e5b1052fe5c884" translate="yes" xml:space="preserve">
          <source>A function call isn't allowed in the const's initialization expression because the expression's value must be known at compile-time. Erroneous code example:</source>
          <target state="translated">コンパイル時に式の値を知る必要があるため、const の初期化式では関数呼び出しは許可されません。誤ったコード例。</target>
        </trans-unit>
        <trans-unit id="cdbab3b7a45160aa6bbfe85128d0bf7bac272328" translate="yes" xml:space="preserve">
          <source>A function declared in an extern block is implicitly &lt;code&gt;unsafe&lt;/code&gt;. When coerced to a function pointer, a function declared in an extern block has type &lt;code&gt;unsafe extern &quot;abi&quot; for&amp;lt;'l1, ..., 'lm&amp;gt; fn(A1, ..., An) -&amp;gt; R&lt;/code&gt;, where &lt;code&gt;'l1&lt;/code&gt;, ... &lt;code&gt;'lm&lt;/code&gt; are its lifetime parameters, &lt;code&gt;A1&lt;/code&gt;, ..., &lt;code&gt;An&lt;/code&gt; are the declared types of its parameters and &lt;code&gt;R&lt;/code&gt; is the declared return type.</source>
          <target state="translated">externブロックで宣言された関数は暗黙的に &lt;code&gt;unsafe&lt;/code&gt; はありません。関数ポインターに強制型変換されると、externブロックで宣言された関数の型は &lt;code&gt;unsafe extern &quot;abi&quot; for&amp;lt;'l1, ..., 'lm&amp;gt; fn(A1, ..., An) -&amp;gt; R&lt;/code&gt; 、ここで &lt;code&gt;'l1&lt;/code&gt; 、... &lt;code&gt;'lm&lt;/code&gt; はその存続期間パラメーター、 &lt;code&gt;A1&lt;/code&gt; 、...、 &lt;code&gt;An&lt;/code&gt; はそのパラメーターの宣言されたタイプ、 &lt;code&gt;R&lt;/code&gt; は宣言された戻りタイプです。</target>
        </trans-unit>
        <trans-unit id="d0692343f061c0cd9d5ae6d4139b26c55c59ad9f" translate="yes" xml:space="preserve">
          <source>A function is using &lt;code&gt;continue&lt;/code&gt; keyword incorrectly.</source>
          <target state="translated">関数が &lt;code&gt;continue&lt;/code&gt; キーワードを誤って使用しています。</target>
        </trans-unit>
        <trans-unit id="0055fb8a733d1b0d5afb4ae44802bb8e5a0c86da" translate="yes" xml:space="preserve">
          <source>A function or function pointer.</source>
          <target state="translated">関数または関数ポインタ。</target>
        </trans-unit>
        <trans-unit id="b5bfe20067693f41e9be24910b3f1d1c865c4b39" translate="yes" xml:space="preserve">
          <source>A function signature must declare the number and type of parameters the function has. Macros, on the other hand, can take a variable number of parameters: we can call &lt;code&gt;println!(&quot;hello&quot;)&lt;/code&gt; with one argument or &lt;code&gt;println!(&quot;hello {}&quot;, name)&lt;/code&gt; with two arguments. Also, macros are expanded before the compiler interprets the meaning of the code, so a macro can, for example, implement a trait on a given type. A function can&amp;rsquo;t, because it gets called at runtime and a trait needs to be implemented at compile time.</source>
          <target state="translated">関数シグネチャは、関数が持つパラメータの数とタイプを宣言する必要があります。一方、マクロは可変数のパラメーターを取ることができます。1つの引数で &lt;code&gt;println!(&quot;hello&quot;)&lt;/code&gt; を呼び出すか、2つの引数で &lt;code&gt;println!(&quot;hello {}&quot;, name)&lt;/code&gt; を呼び出すことができます。また、マクロは、コンパイラーがコードの意味を解釈する前に展開されるため、たとえば、マクロは特定の型に特性を実装できます。関数は実行できません。実行時に呼び出され、コンパイル時に特性を実装する必要があるためです。</target>
        </trans-unit>
        <trans-unit id="cfea53bdada8b3687c10319a4dd10194cef976b7" translate="yes" xml:space="preserve">
          <source>A function that has a parameter or returns only numbers between 1 and 100 could then declare in its signature that it takes or returns a &lt;code&gt;Guess&lt;/code&gt; rather than an &lt;code&gt;i32&lt;/code&gt; and wouldn&amp;rsquo;t need to do any additional checks in its body.</source>
          <target state="translated">パラメータを持つ、または1から100までの数値のみを返す関数は、 &lt;code&gt;i32&lt;/code&gt; ではなく &lt;code&gt;Guess&lt;/code&gt; を受け取るか返すことをシグネチャで宣言でき、本体で追加のチェックを行う必要はありません。</target>
        </trans-unit>
        <trans-unit id="330c21e7bd84509b137caeeff4bed7a7da24e5b7" translate="yes" xml:space="preserve">
          <source>A function that is opaque to the optimizer, to allow benchmarks to pretend to use outputs to assist in avoiding dead-code elimination.</source>
          <target state="translated">オプティマイザに不透明な関数で、ベンチマークが出力を使用するふりをしてデッドコードの排除を回避できるようにします。</target>
        </trans-unit>
        <trans-unit id="d2ed9af48e681bbf5a9216d3deb00de57795222b" translate="yes" xml:space="preserve">
          <source>A function with the &lt;code&gt;start&lt;/code&gt; attribute was declared with type parameters.</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; 属性を持つ関数が型パラメーターで宣言されました。</target>
        </trans-unit>
        <trans-unit id="cc716e4e83b4efb34e4101d17ccb62e4b2b1eb26" translate="yes" xml:space="preserve">
          <source>A fundamental trait is one where adding an impl of it for an existing type is a breaking change. The &lt;code&gt;Fn&lt;/code&gt; traits and &lt;code&gt;Sized&lt;/code&gt; are fundamental.</source>
          <target state="translated">基本的な特性は、既存のタイプにそのimplを追加することが重大な変更であるという特性です。 &lt;code&gt;Fn&lt;/code&gt; 特性と &lt;code&gt;Sized&lt;/code&gt; 基本です。</target>
        </trans-unit>
        <trans-unit id="0649f34bf1c96947359554a4e3b1fb6bd7f77d90" translate="yes" xml:space="preserve">
          <source>A fundamental type constructor is a type where implementing a &lt;a href=&quot;#blanket-implementation&quot;&gt;blanket implementation&lt;/a&gt; over it is a breaking change. &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;&amp;amp;mut&lt;/code&gt;, &lt;code&gt;Box&lt;/code&gt;, and &lt;code&gt;Pin&lt;/code&gt; are fundamental.</source>
          <target state="translated">基本的な型コンストラクターは、その上に&lt;a href=&quot;#blanket-implementation&quot;&gt;包括的実装を実装&lt;/a&gt;することが重大な変更である型です。 &lt;code&gt;&amp;amp;&lt;/code&gt; 、 &lt;code&gt;&amp;amp;mut&lt;/code&gt; 、 &lt;code&gt;Box&lt;/code&gt; 、および &lt;code&gt;Pin&lt;/code&gt; が基本です。</target>
        </trans-unit>
        <trans-unit id="b104136e74bd26ea4949e609270e7bafb60abae9" translate="yes" xml:space="preserve">
          <source>A future is a value that may not have finished computing yet. This kind of &quot;asynchronous value&quot; makes it possible for a thread to continue doing useful work while it waits for the value to become available.</source>
          <target state="translated">未来とは、まだ計算が終わっていないかもしれない値のことです。この種の「非同期値」は、値が利用可能になるのを待つ間、スレッドが有用な作業を続けることを可能にします。</target>
        </trans-unit>
        <trans-unit id="7c377e6c372ce66665ebea21944588366ee85648" translate="yes" xml:space="preserve">
          <source>A future represents an asynchronous computation.</source>
          <target state="translated">未来は非同期計算を表します。</target>
        </trans-unit>
        <trans-unit id="c1da397a075afa74abc70c7bb33c6bfaa50fd933" translate="yes" xml:space="preserve">
          <source>A generalization of &lt;code&gt;Clone&lt;/code&gt; to borrowed data.</source>
          <target state="translated">借用データへの &lt;code&gt;Clone&lt;/code&gt; の一般化。</target>
        </trans-unit>
        <trans-unit id="851d3775359dee45f6fc12b7c593dac300677e98" translate="yes" xml:space="preserve">
          <source>A generic function must be treated similarly:</source>
          <target state="translated">ジェネリック関数も同様に扱わなければなりません。</target>
        </trans-unit>
        <trans-unit id="47dc8336e1d401035013095c768eec4aaa7de80d" translate="yes" xml:space="preserve">
          <source>A generic type was described using parentheses rather than angle brackets.</source>
          <target state="translated">角括弧ではなく、括弧を用いて汎用型を記述しました。</target>
        </trans-unit>
        <trans-unit id="b9e2cdc9d185c52c49734ce26b1038e50519630f" translate="yes" xml:space="preserve">
          <source>A generic type was described using parentheses rather than angle brackets. For example:</source>
          <target state="translated">一般的な型は、角括弧ではなく括弧を使って記述しました。例えば</target>
        </trans-unit>
        <trans-unit id="d667559155454841982582189ab274f14a49b2bf" translate="yes" xml:space="preserve">
          <source>A generic type where one or more associated types have specific assignments (e.g., &lt;code&gt;Iterator&amp;lt;Item=T&amp;gt;&lt;/code&gt;)</source>
          <target state="translated">1つ以上の関連付けられたタイプに特定の割り当てがある総称タイプ（例： &lt;code&gt;Iterator&amp;lt;Item=T&amp;gt;&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="6f0496f55807a095b66d7d51e944864622ad78d2" translate="yes" xml:space="preserve">
          <source>A ghastly note 👻👻👻</source>
          <target state="translated">ゲスい音符 👻👻👻👻</target>
        </trans-unit>
        <trans-unit id="91fcac820244ae988bc857941377bad5a84fac8d" translate="yes" xml:space="preserve">
          <source>A given matcher M maps to three sets: FIRST(M), LAST(M) and FOLLOW(M).</source>
          <target state="translated">与えられた Matcher M は 3 つの集合に写ります。FIRST(M),LAST(M),FOLLOW(M)です.</target>
        </trans-unit>
        <trans-unit id="ce503e49f8d95cbc61a21e14a3b1dd613e9d99ae" translate="yes" xml:space="preserve">
          <source>A great example of a situation where this technique is useful is with operator overloading. &lt;em&gt;Operator overloading&lt;/em&gt; is customizing the behavior of an operator (such as &lt;code&gt;+&lt;/code&gt;) in particular situations.</source>
          <target state="translated">この手法が役立つ状況の良い例は、オペレーターのオーバーロードです。&lt;em&gt;演算子のオーバーロード&lt;/em&gt;とは、特定の状況での演算子（ &lt;code&gt;+&lt;/code&gt; など）の動作をカスタマイズすることです。</target>
        </trans-unit>
        <trans-unit id="77b606312f70d0e0e8a4e81eb457af73b41943c1" translate="yes" xml:space="preserve">
          <source>A guard for unsafe functions that cannot ever be executed if &lt;code&gt;T&lt;/code&gt; does not permit zero-initialization: This will statically either panic, or do nothing.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; がゼロ初期化を許可しない場合に実行できない安全でない関数のガード：これは静的にパニックになるか、何もしません。</target>
        </trans-unit>
        <trans-unit id="73d1fa93ccd1713ed23cb21dd7e4493abed0a332" translate="yes" xml:space="preserve">
          <source>A guard for unsafe functions that cannot ever be executed if &lt;code&gt;T&lt;/code&gt; has invalid bit patterns: This will statically either panic, or do nothing.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; に無効なビットパターンがある場合に実行できない安全でない関数のガード：これは静的にパニックになるか、何もしません。</target>
        </trans-unit>
        <trans-unit id="e24815403ad3a79092fe51890734de71f5057ede" translate="yes" xml:space="preserve">
          <source>A guard for unsafe functions that cannot ever be executed if &lt;code&gt;T&lt;/code&gt; is uninhabited: This will statically either panic, or do nothing.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; が無人の場合は実行できない安全でない関数のガード：これは静的にパニックするか、何もしません。</target>
        </trans-unit>
        <trans-unit id="7a319cd7f43cac10207753e127b6908e7ad723f6" translate="yes" xml:space="preserve">
          <source>A handle to a child process's standard input (stdin).</source>
          <target state="translated">子プロセスの標準入力 (stdin)へのハンドル。</target>
        </trans-unit>
        <trans-unit id="1c0c017d7e2d5d79869d31d54d7aed18a0e39b40" translate="yes" xml:space="preserve">
          <source>A handle to a child process's standard output (stdout).</source>
          <target state="translated">子プロセスの標準出力 (stdout)へのハンドル。</target>
        </trans-unit>
        <trans-unit id="36463654df6f05a2c5f7eb7e4b2efec9b5402d6f" translate="yes" xml:space="preserve">
          <source>A handle to a child process's stderr.</source>
          <target state="translated">子プロセスの標準エラーへのハンドル。</target>
        </trans-unit>
        <trans-unit id="539b8b33fb86eae0a19eb8338bbb41567108f8bd" translate="yes" xml:space="preserve">
          <source>A handle to a thread.</source>
          <target state="translated">スレッドへのハンドル。</target>
        </trans-unit>
        <trans-unit id="e4354965858e59daba47e025f6bf432587785439" translate="yes" xml:space="preserve">
          <source>A handle to the global standard output stream of the current process.</source>
          <target state="translated">現在のプロセスのグローバル標準出力ストリームへのハンドル。</target>
        </trans-unit>
        <trans-unit id="4e5458b43a1ef2ac995209fb2fb9a0f1f086d8ff" translate="yes" xml:space="preserve">
          <source>A handle to the standard error stream of a process.</source>
          <target state="translated">プロセスの標準エラーストリームへのハンドル。</target>
        </trans-unit>
        <trans-unit id="c04e6d93f5332bb8558883edf3c0666a1ead6820" translate="yes" xml:space="preserve">
          <source>A handle to the standard input stream of a process.</source>
          <target state="translated">プロセスの標準入力ストリームへのハンドル。</target>
        </trans-unit>
        <trans-unit id="52f29960ee00cd31852f436ce3c064a63d21c4a9" translate="yes" xml:space="preserve">
          <source>A hash map implemented with linear probing and Robin Hood bucket stealing.</source>
          <target state="translated">線形プロービングとロビンフッドのバケツ盗みを用いて実装されたハッシュマップ。</target>
        </trans-unit>
        <trans-unit id="1b24fb3ba32189304beb3027b487b7bde1af7301" translate="yes" xml:space="preserve">
          <source>A hash map implemented with quadratic probing and SIMD lookup.</source>
          <target state="translated">二次プロービングとSIMDルックアップを用いて実装されたハッシュマップ。</target>
        </trans-unit>
        <trans-unit id="3236fb9d674df64208b5e1cf2d78d481f577b4f2" translate="yes" xml:space="preserve">
          <source>A hash set implemented as a &lt;code&gt;HashMap&lt;/code&gt; where the value is &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">値が &lt;code&gt;()&lt;/code&gt; である &lt;code&gt;HashMap&lt;/code&gt; として実装されたハッシュセット。</target>
        </trans-unit>
        <trans-unit id="4944fd02934cfc33b70591237170d7c0599ffebd" translate="yes" xml:space="preserve">
          <source>A hashable type.</source>
          <target state="translated">ハッシュ可能なタイプ。</target>
        </trans-unit>
        <trans-unit id="4d0ef9738cd0ca2c9edcc6b3b923fd916c2b5807" translate="yes" xml:space="preserve">
          <source>A helper struct for reverse ordering.</source>
          <target state="translated">逆順化のためのヘルパー構造体です。</target>
        </trans-unit>
        <trans-unit id="2fcfddbae21727b9845f52dbf5c24515e281ef8f" translate="yes" xml:space="preserve">
          <source>A helper trait used for indexing operations.</source>
          <target state="translated">インデックス操作に使用されるヘルパー形質。</target>
        </trans-unit>
        <trans-unit id="29862de09ef195f3021bf8c1026b55bc84123b69" translate="yes" xml:space="preserve">
          <source>A incorrectly formatted &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; will produce an error.</source>
          <target state="translated">正しくフォーマットされていない&lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/a&gt;はエラーを生成します。</target>
        </trans-unit>
        <trans-unit id="2e3f1a456a73954f3da04455c2ebc9a53acd9daf" translate="yes" xml:space="preserve">
          <source>A lang item was redefined.</source>
          <target state="translated">lang項目を再定義しました。</target>
        </trans-unit>
        <trans-unit id="6ffd27d3b6539a3465361b45b3e5461748a1b187" translate="yes" xml:space="preserve">
          <source>A large number of the structures provided by &lt;code&gt;std::io&lt;/code&gt; are for various ways of iterating over I/O. For example, &lt;a href=&quot;struct.lines&quot;&gt;&lt;code&gt;Lines&lt;/code&gt;&lt;/a&gt; is used to split over lines:</source>
          <target state="translated">&lt;code&gt;std::io&lt;/code&gt; によって提供される多数の構造は、I / Oを反復するさまざまな方法のためのものです。たとえば、&lt;a href=&quot;struct.lines&quot;&gt; &lt;code&gt;Lines&lt;/code&gt; は行&lt;/a&gt;を分割するために使用されます。</target>
        </trans-unit>
        <trans-unit id="662b6a3ff994171dfffca1e061e7e8ce70b26c02" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the difference of &lt;code&gt;BTreeSet&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;BTreeSet&lt;/code&gt; の違いで要素を生成する遅延イテレータ。</target>
        </trans-unit>
        <trans-unit id="78a980f05e3a46c3d69eb02390416d427839b9ce" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the difference of &lt;code&gt;HashSet&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;HashSet&lt;/code&gt; の違いで要素を生成する遅延イテレータ。</target>
        </trans-unit>
        <trans-unit id="b8f2ea928876732f6cdd8b20aeb46e1a07becd11" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the intersection of &lt;code&gt;BTreeSet&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;BTreeSet&lt;/code&gt; の共通部分に要素を生成する遅延イテレータ。</target>
        </trans-unit>
        <trans-unit id="298c27c033e43f06428f6ee3aa3dd406f79bfc1d" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the intersection of &lt;code&gt;HashSet&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;HashSet&lt;/code&gt; の共通部分に要素を生成する遅延イテレータ。</target>
        </trans-unit>
        <trans-unit id="5e5f0a0d812adca265e03240d1f5f96e6f3c302c" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the symmetric difference of &lt;code&gt;BTreeSet&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;BTreeSet&lt;/code&gt; の対称的な違いで要素を生成する遅延イテレータ。</target>
        </trans-unit>
        <trans-unit id="5248d39b20b8a278703de3ef71e840882448f153" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the symmetric difference of &lt;code&gt;HashSet&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;HashSet&lt;/code&gt; の対称的な違いで要素を生成する遅延イテレータ。</target>
        </trans-unit>
        <trans-unit id="0f9f2f9fdddb7747ea07bd3f3640c23d49782e5c" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the union of &lt;code&gt;BTreeSet&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;BTreeSet&lt;/code&gt; の和集合で要素を生成する遅延イテレータ。</target>
        </trans-unit>
        <trans-unit id="fc9bf6d7c1e4850a63411aee9c08fbc8782aa61a" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the union of &lt;code&gt;HashSet&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;HashSet&lt;/code&gt; の和集合で要素を生成する遅延イテレータ。</target>
        </trans-unit>
        <trans-unit id="32415c91edd2506ae578a648363d87b8a79c9954" translate="yes" xml:space="preserve">
          <source>A library developer needs to expose functionality to crates which link against their library. As a consequence of the first case, this means that anything which is usable externally must be &lt;code&gt;pub&lt;/code&gt; from the root down to the destination item. Any private item in the chain will disallow external accesses.</source>
          <target state="translated">ライブラリ開発者は、ライブラリにリンクするクレートに機能を公開する必要があります。最初のケースの結果として、これは、外部で使用できるものはすべて、ルートから宛先アイテムまでの &lt;code&gt;pub&lt;/code&gt; なければならないことを意味します。チェーン内のプライベートアイテムは、外部アクセスを許可しません。</target>
        </trans-unit>
        <trans-unit id="6ffc7aa510e5357070634b59c577ca85e2c2292b" translate="yes" xml:space="preserve">
          <source>A lifetime appears only in an associated-type binding, and not in the input types to the trait.</source>
          <target state="translated">ライフタイムは、関連付けられたタイプのバインディングでのみ表示され、形質への入力タイプでは表示されません。</target>
        </trans-unit>
        <trans-unit id="15786eaf619ace068790ae58d796d7da4d047a8c" translate="yes" xml:space="preserve">
          <source>A lifetime bound on a trait implementation was captured at an incorrect place.</source>
          <target state="translated">形質実装のライフタイム バインドが不正な場所で捕捉されました。</target>
        </trans-unit>
        <trans-unit id="7c38295bdcc0eafcba2929a676ec6ceb8e9304c9" translate="yes" xml:space="preserve">
          <source>A lifetime bound was not satisfied.</source>
          <target state="translated">ライフタイムバインドが満たされていなかった。</target>
        </trans-unit>
        <trans-unit id="f5eb99d9ba1d633f5bab932159c4263f91c6e225" translate="yes" xml:space="preserve">
          <source>A lifetime cannot be determined in the given situation.</source>
          <target state="translated">与えられた状況下では、生涯を決定することはできません。</target>
        </trans-unit>
        <trans-unit id="f5cad79ba7fd3784fc14fc3f6b2c2d3527062c63" translate="yes" xml:space="preserve">
          <source>A lifetime didn't match what was expected.</source>
          <target state="translated">一期一会は期待されていたものとは違っていた。</target>
        </trans-unit>
        <trans-unit id="f2036255cc30a38458aebc41a1b7522c2030656d" translate="yes" xml:space="preserve">
          <source>A lifetime is only present in an associated-type binding, and not in the input types to the trait.</source>
          <target state="translated">ライフタイムは、関連付けられたタイプのバインディングにのみ存在し、形質への入力タイプには存在しません。</target>
        </trans-unit>
        <trans-unit id="7b0bc06cbbd42c2c42f3c7edb056daf04c8c1022" translate="yes" xml:space="preserve">
          <source>A lifetime name cannot be declared more than once in the same scope. For example:</source>
          <target state="translated">ライフタイム名は、同じスコープ内で複数回宣言することはできません。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="315c1653fb8738d323beeedab26038fcdebdd0a1" translate="yes" xml:space="preserve">
          <source>A lifetime name is shadowing another lifetime name.</source>
          <target state="translated">終身の名前が別の終身の名前に影を落としている。</target>
        </trans-unit>
        <trans-unit id="24a3a2bd418c09a4c4c2d74fd258bdb9f00cd151" translate="yes" xml:space="preserve">
          <source>A lifetime name is shadowing another lifetime name. Erroneous code example:</source>
          <target state="translated">ライフタイム名が別のライフタイム名の影になっています。誤ったコード例です。</target>
        </trans-unit>
        <trans-unit id="60dd9352a1988e94c38ce60166a9c885adb54457" translate="yes" xml:space="preserve">
          <source>A lifetime was declared more than once in the same scope.</source>
          <target state="translated">同一の範囲内で複数回、ライフタイムを宣言していた。</target>
        </trans-unit>
        <trans-unit id="6c742ea21e8d68de6fe9c8cd053579ea9357b0ab" translate="yes" xml:space="preserve">
          <source>A link name was given with an empty name.</source>
          <target state="translated">リンク名に空の名前が付けられていました。</target>
        </trans-unit>
        <trans-unit id="e76bb7dad8b82c5bd8c5e995749d2ddcac1434e4" translate="yes" xml:space="preserve">
          <source>A link name was given with an empty name. Erroneous code example:</source>
          <target state="translated">リンク名が空の名前で与えられました。誤ったコード例です。</target>
        </trans-unit>
        <trans-unit id="7aff8ae0fa99ab18b982ebf4bf49db472c773b53" translate="yes" xml:space="preserve">
          <source>A link was used without a name parameter.</source>
          <target state="translated">名前のパラメータがないリンクが使用されていました。</target>
        </trans-unit>
        <trans-unit id="916890e2e829b39ca74b6c85b7ab19a70dff37fc" translate="yes" xml:space="preserve">
          <source>A link was used without a name parameter. Erroneous code example:</source>
          <target state="translated">name パラメータを指定せずにリンクを使用しました。誤ったコード例です。</target>
        </trans-unit>
        <trans-unit id="ac64cfd6177747480c1f0a80dd27bc3c2253949c" translate="yes" xml:space="preserve">
          <source>A lint check attribute was overruled by a &lt;code&gt;forbid&lt;/code&gt; directive set as an attribute on an enclosing scope, or on the command line with the &lt;code&gt;-F&lt;/code&gt; option.</source>
          <target state="translated">lintチェック属性は、外側のスコープまたは &lt;code&gt;-F&lt;/code&gt; オプションを指定したコマンドラインで属性として設定された &lt;code&gt;forbid&lt;/code&gt; ディレクティブによって無効にされました。</target>
        </trans-unit>
        <trans-unit id="4ec2e82a43ec2456c074c084d9bde606ea9ab3b3" translate="yes" xml:space="preserve">
          <source>A lint check names a potentially undesirable coding pattern, such as unreachable code or omitted documentation. The lint attributes &lt;code&gt;allow&lt;/code&gt;, &lt;code&gt;warn&lt;/code&gt;, &lt;code&gt;deny&lt;/code&gt;, and &lt;code&gt;forbid&lt;/code&gt; use the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListPaths&lt;/em&gt;&lt;/a&gt; syntax to specify a list of lint names to change the lint level for the entity to which the attribute applies.</source>
          <target state="translated">lintチェックは、到達できないコードや省略されたドキュメントなど、潜在的に望ましくないコーディングパターンを示します。糸くずの属性は、 &lt;code&gt;allow&lt;/code&gt; 、 &lt;code&gt;warn&lt;/code&gt; 、 &lt;code&gt;deny&lt;/code&gt; 、および &lt;code&gt;forbid&lt;/code&gt; 使用&lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListPaths&lt;/em&gt;&lt;/a&gt;属性が適用されるエンティティの糸くずのレベルを変更するために糸くず名のリストを指定する構文を。</target>
        </trans-unit>
        <trans-unit id="2f470d70068148b9c3f60f9da5c6e02f3a36f8a9" translate="yes" xml:space="preserve">
          <source>A list of available external lang items is available in &lt;code&gt;src/librustc/middle/weak_lang_items.rs&lt;/code&gt;. Example:</source>
          <target state="translated">使用可能な外部langアイテムのリストは、 &lt;code&gt;src/librustc/middle/weak_lang_items.rs&lt;/code&gt; にあります。例：</target>
        </trans-unit>
        <trans-unit id="a93ce4eba1c20223d4f7efd374435922dc780a28" translate="yes" xml:space="preserve">
          <source>A list of available external lang items is available in &lt;code&gt;src/librustc_middle/middle/weak_lang_items.rs&lt;/code&gt;. Example:</source>
          <target state="translated">利用可能な外部langアイテムのリストは、 &lt;code&gt;src/librustc_middle/middle/weak_lang_items.rs&lt;/code&gt; ます。例：</target>
        </trans-unit>
        <trans-unit id="508df8833b23d4b6921f12bfae0871fdb8efa7ce" translate="yes" xml:space="preserve">
          <source>A list specifying general categories of I/O error.</source>
          <target state="translated">I/Oエラーの一般的なカテゴリを指定したリスト。</target>
        </trans-unit>
        <trans-unit id="6afbc1cd2e7b35cec4d1c86812f59ca981f43d9f" translate="yes" xml:space="preserve">
          <source>A list with each element, i.e., &lt;code&gt;[x, y, z]&lt;/code&gt;.</source>
          <target state="translated">各要素、つまり &lt;code&gt;[x, y, z]&lt;/code&gt; のリスト。</target>
        </trans-unit>
        <trans-unit id="15c8d2d5a110eff4a4e3eff0337b45af3836ff58" translate="yes" xml:space="preserve">
          <source>A literal is an expression consisting of a single token, rather than a sequence of tokens, that immediately and directly denotes the value it evaluates to, rather than referring to it by name or some other evaluation rule. A literal is a form of &lt;a href=&quot;const_eval#constant-expressions&quot;&gt;constant expression&lt;/a&gt;, so is evaluated (primarily) at compile time.</source>
          <target state="translated">リテラルは、トークンのシーケンスではなく単一のトークンで構成される式であり、名前やその他の評価ルールで参照するのではなく、評価する値を直接かつ直接示します。リテラルは&lt;a href=&quot;const_eval#constant-expressions&quot;&gt;定数式の&lt;/a&gt;形式であるため、コンパイル時に（主に）評価されます。</target>
        </trans-unit>
        <trans-unit id="7acc2bbca8147fd009370161f8e9ac4665c257d0" translate="yes" xml:space="preserve">
          <source>A literal was used in a built-in attribute that doesn't support literals.</source>
          <target state="translated">リテラルをサポートしない組み込み属性でリテラルが使用されました。</target>
        </trans-unit>
        <trans-unit id="efa9c544d88ff2ed4857caf7a6d5b87ab71f9e34" translate="yes" xml:space="preserve">
          <source>A little reminder: a doc comment has to be placed before the item it's supposed to document. So if you want to document the &lt;code&gt;Island&lt;/code&gt; trait, you need to put a doc comment before it, not inside it. Same goes for the &lt;code&gt;lost&lt;/code&gt; method: the doc comment needs to be before it:</source>
          <target state="translated">ちょっとした注意：ドキュメントコメントは、ドキュメント化する予定のアイテムの前に配置する必要があります。したがって、 &lt;code&gt;Island&lt;/code&gt; 特性を文書化する場合は、島の内部ではなく、その前にドキュメントコメントを配置する必要があります。 &lt;code&gt;lost&lt;/code&gt; メソッドについても同じことが言えます。ドキュメントコメントはその前にある必要があります。</target>
        </trans-unit>
        <trans-unit id="8c7298eaf33d5d7b34d2bf261698fdf05d319588" translate="yes" xml:space="preserve">
          <source>A locked reference to the &lt;code&gt;Stderr&lt;/code&gt; handle.</source>
          <target state="translated">&lt;code&gt;Stderr&lt;/code&gt; ハンドルへのロックされた参照。</target>
        </trans-unit>
        <trans-unit id="e64008e4cbb40a24042f57f0ba8206541604d8ca" translate="yes" xml:space="preserve">
          <source>A locked reference to the &lt;code&gt;Stdin&lt;/code&gt; handle.</source>
          <target state="translated">&lt;code&gt;Stdin&lt;/code&gt; ハンドルへのロックされた参照。</target>
        </trans-unit>
        <trans-unit id="27f936b73151ca7329818fe3daa46cf14b38bc95" translate="yes" xml:space="preserve">
          <source>A locked reference to the &lt;code&gt;Stdout&lt;/code&gt; handle.</source>
          <target state="translated">&lt;code&gt;Stdout&lt;/code&gt; ハンドルへのロックされた参照。</target>
        </trans-unit>
        <trans-unit id="209614c8cbb6478d39bb33efacb63355ac82d199" translate="yes" xml:space="preserve">
          <source>A locked standard input implements &lt;code&gt;BufRead&lt;/code&gt;:</source>
          <target state="translated">ロックされた標準入力は &lt;code&gt;BufRead&lt;/code&gt; を実装します：</target>
        </trans-unit>
        <trans-unit id="3af527db8725fae95a62589160c6f0f2118456fd" translate="yes" xml:space="preserve">
          <source>A loop expression may optionally have a &lt;em&gt;label&lt;/em&gt;. The label is written as a lifetime preceding the loop expression, as in &lt;code&gt;'foo: loop { break 'foo; }&lt;/code&gt;, &lt;code&gt;'bar: while false {}&lt;/code&gt;, &lt;code&gt;'humbug: for _ in 0..0 {}&lt;/code&gt;. If a label is present, then labeled &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; expressions nested within this loop may exit out of this loop or return control to its head. See &lt;a href=&quot;#break-expressions&quot;&gt;break expressions&lt;/a&gt; and &lt;a href=&quot;#continue-expressions&quot;&gt;continue expressions&lt;/a&gt;.</source>
          <target state="translated">ループ式には、オプションで&lt;em&gt;ラベルを付ける&lt;/em&gt;ことができます。ラベルは、 &lt;code&gt;'foo: loop { break 'foo; }&lt;/code&gt; ように、ループ式の前の有効期間として書き込まれます。}、 &lt;code&gt;'bar: while false {}&lt;/code&gt; 、 &lt;code&gt;'humbug: for _ in 0..0 {}&lt;/code&gt; 。ラベルが存在する場合、このループ内にネストされたラベル付きの &lt;code&gt;break&lt;/code&gt; および &lt;code&gt;continue&lt;/code&gt; 式は、このループを終了するか、制御をその先頭に戻す可能性があります。&lt;a href=&quot;#break-expressions&quot;&gt;ブレーク式&lt;/a&gt;と&lt;a href=&quot;#continue-expressions&quot;&gt;コンティニュー式を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="3748fe7789bb3fdcadf97f48b577f7242f80249c" translate="yes" xml:space="preserve">
          <source>A loop expression may optionally have a &lt;em&gt;label&lt;/em&gt;. The label is written as a lifetime preceding the loop expression, as in &lt;code&gt;'foo: loop { break 'foo; }&lt;/code&gt;, &lt;code&gt;'bar: while false {}&lt;/code&gt;, &lt;code&gt;'humbug: for _ in 0..0 {}&lt;/code&gt;. If a label is present, then labeled &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; expressions nested within this loop may exit out of this loop or return control to its head. See &lt;a href=&quot;loop-expr#break-expressions&quot;&gt;break expressions&lt;/a&gt; and &lt;a href=&quot;loop-expr#continue-expressions&quot;&gt;continue expressions&lt;/a&gt;.</source>
          <target state="translated">ループ式にはオプションで&lt;em&gt;ラベルを付ける&lt;/em&gt;ことができます。ラベルは、 &lt;code&gt;'foo: loop { break 'foo; }&lt;/code&gt; ように、ループ式の前に存続期間として書き込まれます。}、 &lt;code&gt;'bar: while false {}&lt;/code&gt; 、 &lt;code&gt;'humbug: for _ in 0..0 {}&lt;/code&gt; 。ラベルが存在する場合、このループ内にネストされたラベル付きの &lt;code&gt;break&lt;/code&gt; および &lt;code&gt;continue&lt;/code&gt; 式は、このループを終了するか、制御を先頭に戻す場合があります。&lt;a href=&quot;loop-expr#break-expressions&quot;&gt;break式&lt;/a&gt;と&lt;a href=&quot;loop-expr#continue-expressions&quot;&gt;continue式を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="621a2333164d1c1ddcc3e28445c529a5edcd0f4d" translate="yes" xml:space="preserve">
          <source>A loop keyword (&lt;code&gt;break&lt;/code&gt; or &lt;code&gt;continue&lt;/code&gt;) was used inside a closure but outside of any loop.</source>
          <target state="translated">ループキーワード（ &lt;code&gt;break&lt;/code&gt; または &lt;code&gt;continue&lt;/code&gt; ）がクロージャの内側で使用されましたが、ループの外側で使用されました。</target>
        </trans-unit>
        <trans-unit id="f49094ffad160345ac5b867a45ab1d0476b39ead" translate="yes" xml:space="preserve">
          <source>A loop keyword (&lt;code&gt;break&lt;/code&gt; or &lt;code&gt;continue&lt;/code&gt;) was used outside of a loop.</source>
          <target state="translated">ループキーワード（ &lt;code&gt;break&lt;/code&gt; または &lt;code&gt;continue&lt;/code&gt; ）がループの外側で使用されました。</target>
        </trans-unit>
        <trans-unit id="511e4a1a5b552d0daef468f2387fb6edd0e92546" translate="yes" xml:space="preserve">
          <source>A lossy decoder can be obtained by replacing &lt;code&gt;Err&lt;/code&gt; results with the replacement character:</source>
          <target state="translated">非可逆デコーダーは、 &lt;code&gt;Err&lt;/code&gt; の結果を置換文字に置き換えることで取得できます。</target>
        </trans-unit>
        <trans-unit id="aaa61df7a5c37f0e9baf2b1d7a2af95d48009664" translate="yes" xml:space="preserve">
          <source>A lower range wasn't less than the upper range.</source>
          <target state="translated">下位レンジは上位レンジ以下ではありませんでした。</target>
        </trans-unit>
        <trans-unit id="d97f1261b9b58d3e3fe4caf6b3ed4e3d57f050f7" translate="yes" xml:space="preserve">
          <source>A macro invocation executes a macro at compile time and replaces the invocation with the result of the macro. Macros may be invoked in the following situations:</source>
          <target state="translated">マクロ呼び出しはコンパイル時にマクロを実行し、呼び出しをマクロの結果に置き換えます。マクロは、次のような状況で呼び出されることがあります。</target>
        </trans-unit>
        <trans-unit id="604f17220a435dfda6ce25b3286e96cae9c124f4" translate="yes" xml:space="preserve">
          <source>A macro listed for import was not found.</source>
          <target state="translated">インポート用にリストアップされたマクロが見つかりませんでした。</target>
        </trans-unit>
        <trans-unit id="2e0526607109d7012469029a56fd3ee785be2e0d" translate="yes" xml:space="preserve">
          <source>A macro to test at &lt;em&gt;runtime&lt;/em&gt; whether a CPU feature is available on x86/x86-64 platforms.</source>
          <target state="translated">CPU機能がx86 / x86-64プラットフォームで使用可能かどうかを&lt;em&gt;実行時&lt;/em&gt;にテストするマクロ。</target>
        </trans-unit>
        <trans-unit id="5b9ba25200988be7523c79ceef0a08b5dbf3a289" translate="yes" xml:space="preserve">
          <source>A major goal of the compiler is to ensure that a library never appears more than once in any artifact. For example, if dynamic libraries B and C were each statically linked to library A, then a crate could not link to B and C together because there would be two copies of A. The compiler allows mixing the rlib and dylib formats, but this restriction must be satisfied.</source>
          <target state="translated">コンパイラの主な目標は、どのような成果物でもライブラリが二度以上現れないようにすることです。例えば、ダイナミック・ライブラリ B と C がそれぞれライブラリ A に静的にリンクされている場合、A のコピーが 2 つあるため、クレートは B と C を一緒にリンクすることができません。</target>
        </trans-unit>
        <trans-unit id="416ce06261874aaff012fa6c737cea866a967092" translate="yes" xml:space="preserve">
          <source>A map based on a B-Tree.</source>
          <target state="translated">B-Treeをベースにした地図。</target>
        </trans-unit>
        <trans-unit id="f2df32e1b651fa8937f10fb914a69befa91dcf32" translate="yes" xml:space="preserve">
          <source>A marker trait representing types where a shared reference is considered unwind safe.</source>
          <target state="translated">共有参照が巻き戻しセーフとみなされる型を表すマーカー形質。</target>
        </trans-unit>
        <trans-unit id="3bc97c0d55aa2cae1126bc3f3d83ef27e23658de" translate="yes" xml:space="preserve">
          <source>A marker trait to express that a &lt;a href=&quot;trait.reversesearcher&quot;&gt;&lt;code&gt;ReverseSearcher&lt;/code&gt;&lt;/a&gt; can be used for a &lt;a href=&quot;../../iter/trait.doubleendediterator&quot;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt; implementation.</source>
          <target state="translated">ことを表現するマーカー形質&lt;a href=&quot;trait.reversesearcher&quot;&gt; &lt;code&gt;ReverseSearcher&lt;/code&gt; の&lt;/a&gt;ために使用することができる&lt;a href=&quot;../../iter/trait.doubleendediterator&quot;&gt; &lt;code&gt;DoubleEndedIterator&lt;/code&gt; の&lt;/a&gt;実装。</target>
        </trans-unit>
        <trans-unit id="ba67e3276d83805bffe74ea0a7a327593cf9467b" translate="yes" xml:space="preserve">
          <source>A marker trait to express that a &lt;code&gt;ReverseSearcher&lt;/code&gt; can be used for a &lt;code&gt;DoubleEndedIterator&lt;/code&gt; implementation.</source>
          <target state="translated">ことを表現するマーカー形質 &lt;code&gt;ReverseSearcher&lt;/code&gt; のために使用することができる &lt;code&gt;DoubleEndedIterator&lt;/code&gt; の実装。</target>
        </trans-unit>
        <trans-unit id="2f67969c6f12d96330ceaae49a9df5d58837b264" translate="yes" xml:space="preserve">
          <source>A marker trait which represents &quot;panic safe&quot; types in Rust.</source>
          <target state="translated">Rustで「パニックセーフ」タイプを表すマーカー形質。</target>
        </trans-unit>
        <trans-unit id="7c9160659faee9d41f691cb8f88f2f8a49c219c0" translate="yes" xml:space="preserve">
          <source>A marker type which does not implement &lt;code&gt;Unpin&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Unpin&lt;/code&gt; を実装しないマーカータイプ。</target>
        </trans-unit>
        <trans-unit id="2cd086d02e989df16ae8561bd2410188577f706c" translate="yes" xml:space="preserve">
          <source>A measurement of a monotonically nondecreasing clock. Opaque and useful only with &lt;code&gt;Duration&lt;/code&gt;.</source>
          <target state="translated">単調に減少しないクロックの測定値。不透明で、 &lt;code&gt;Duration&lt;/code&gt; でのみ役立ちます。</target>
        </trans-unit>
        <trans-unit id="f1b2d1acc7998286a04c3bbe416b5e64b3d2a408" translate="yes" xml:space="preserve">
          <source>A measurement of the system clock, useful for talking to external entities like the file system or other processes.</source>
          <target state="translated">システムクロックの測定値で、ファイルシステムや他のプロセスのような外部エンティティとの通信に便利です。</target>
        </trans-unit>
        <trans-unit id="ab0a8ccacb7225c2d2eaa3d61513ce8be0301515" translate="yes" xml:space="preserve">
          <source>A memory allocator that can be registered as the standard library&amp;rsquo;s default though the &lt;code&gt;#[global_allocator]&lt;/code&gt; attributes.</source>
          <target state="translated">&lt;code&gt;#[global_allocator]&lt;/code&gt; 属性を使用して標準ライブラリのデフォルトとして登録できるメモリアロケータ。</target>
        </trans-unit>
        <trans-unit id="36390b8dd6062ca0b9666a02db751bef68ddc91f" translate="yes" xml:space="preserve">
          <source>A memory allocator that can be registered as the standard library&amp;rsquo;s default through the &lt;code&gt;#[global_allocator]&lt;/code&gt; attribute.</source>
          <target state="translated">&lt;code&gt;#[global_allocator]&lt;/code&gt; 属性を介して標準ライブラリのデフォルトとして登録できるメモリアロケータ。</target>
        </trans-unit>
        <trans-unit id="f52897b7b1a254a773b596ff34aeb774856f7c04" translate="yes" xml:space="preserve">
          <source>A metavariable must appear in exactly the same number, kind, and nesting order of repetitions in the transcriber as it did in the matcher. So for the matcher &lt;code&gt;$( $i:ident ),*&lt;/code&gt;, the transcribers &lt;code&gt;=&amp;gt; { $i }&lt;/code&gt;, &lt;code&gt;=&amp;gt; { $( $( $i)* )* }&lt;/code&gt;, and &lt;code&gt;=&amp;gt; { $( $i )+ }&lt;/code&gt; are all illegal, but &lt;code&gt;=&amp;gt; { $( $i );* }&lt;/code&gt; is correct and replaces a comma-separated list of identifiers with a semicolon-separated list.</source>
          <target state="translated">メタ変数は、マッチャーで行われたのとまったく同じ数、種類、および繰り返しのネストのネスト順で出現する必要があります。したがって、マッチャー &lt;code&gt;$( $i:ident ),*&lt;/code&gt; 場合、転写者 &lt;code&gt;=&amp;gt; { $i }&lt;/code&gt; 、 &lt;code&gt;=&amp;gt; { $( $( $i)* )* }&lt;/code&gt; 、および &lt;code&gt;=&amp;gt; { $( $i )+ }&lt;/code&gt; は、 &lt;code&gt;=&amp;gt; { $( $i );* }&lt;/code&gt; はすべて不正ですが、識別子のコンマ区切りリストをセミコロン区切りリストに置き換えます。</target>
        </trans-unit>
        <trans-unit id="801757bf4a897de3dc38db9dc1b65e4429ae7c96" translate="yes" xml:space="preserve">
          <source>A method was called on a raw pointer whose inner type wasn't completely known.</source>
          <target state="translated">内部の型が完全にわかっていない生のポインタに対してメソッドが呼び出されました。</target>
        </trans-unit>
        <trans-unit id="da23ec6794439455d8bda2444d9dc191c1a91b2b" translate="yes" xml:space="preserve">
          <source>A method was called on an ambiguous numeric type.</source>
          <target state="translated">曖昧な数値型に対してメソッドが呼び出されました。</target>
        </trans-unit>
        <trans-unit id="cb6424b2d67ae2d104f32890640da913ac560f8f" translate="yes" xml:space="preserve">
          <source>A method was implemented on a primitive type.</source>
          <target state="translated">プリミティブ型にメソッドを実装しました。</target>
        </trans-unit>
        <trans-unit id="b83bd54b545ece8364d586c3e7f838baf02e8c65" translate="yes" xml:space="preserve">
          <source>A method was implemented when another trait item was expected.</source>
          <target state="translated">別の形質項目が予想される場合のメソッドを実装しました。</target>
        </trans-unit>
        <trans-unit id="0b9ba16b85d0fa75f6c2790fe89555c2da2a5ee8" translate="yes" xml:space="preserve">
          <source>A method was implemented when another trait item was expected. Erroneous code example:</source>
          <target state="translated">別の形質項目が予想される場合にメソッドが実装されました。誤ったコード例です。</target>
        </trans-unit>
        <trans-unit id="30d915c6907e57ec215e0d955c2fea0a426c859a" translate="yes" xml:space="preserve">
          <source>A module can import both &lt;code&gt;std::fmt::Write&lt;/code&gt; and &lt;code&gt;std::io::Write&lt;/code&gt; and call &lt;code&gt;write!&lt;/code&gt; on objects implementing either, as objects do not typically implement both. However, the module must import the traits qualified so their names do not conflict:</source>
          <target state="translated">モジュールは &lt;code&gt;std::fmt::Write&lt;/code&gt; と &lt;code&gt;std::io::Write&lt;/code&gt; 両方をインポートして、 &lt;code&gt;write!&lt;/code&gt; を呼び出すことができます！オブジェクトは通常両方を実装していないため、どちらかを実装しているオブジェクトに対して。ただし、モジュールは修飾された特性をインポートして、名前が競合しないようにする必要があります。</target>
        </trans-unit>
        <trans-unit id="8df0b4f7cbe7a3d63c8935c00a09e49b670eda46" translate="yes" xml:space="preserve">
          <source>A module cannot be found and therefore, the visibility cannot be determined.</source>
          <target state="translated">モジュールが見つからないため、視認性を判断できない。</target>
        </trans-unit>
        <trans-unit id="9b81303b4be9b1fd6a4b7a6468837e80d06c4579" translate="yes" xml:space="preserve">
          <source>A module for working with borrowed data.</source>
          <target state="translated">借りてきたデータを扱うためのモジュール。</target>
        </trans-unit>
        <trans-unit id="279721754abe896ed73051fc4e21afc678f9887f" translate="yes" xml:space="preserve">
          <source>A module for working with processes.</source>
          <target state="translated">プロセスを扱うためのモジュール。</target>
        </trans-unit>
        <trans-unit id="6a05a78578f1dbd0078ba611f8fe4d06c249f5a6" translate="yes" xml:space="preserve">
          <source>A module is a container for zero or more &lt;a href=&quot;../items&quot;&gt;items&lt;/a&gt;.</source>
          <target state="translated">モジュールは、0個以上の&lt;a href=&quot;../items&quot;&gt;アイテムの&lt;/a&gt;コンテナです。</target>
        </trans-unit>
        <trans-unit id="c04981413bae044ff3db488edfd9ac3f31ccdfa7" translate="yes" xml:space="preserve">
          <source>A module without a body is loaded from an external file. When the module does not have a &lt;code&gt;path&lt;/code&gt; attribute, the path to the file mirrors the logical &lt;a href=&quot;../paths&quot;&gt;module path&lt;/a&gt;. Ancestor module path components are directories, and the module's contents are in a file with the name of the module plus the &lt;code&gt;.rs&lt;/code&gt; extension. For example, the following module structure can have this corresponding filesystem structure:</source>
          <target state="translated">ボディのないモジュールは外部ファイルからロードされます。モジュールに &lt;code&gt;path&lt;/code&gt; 属性がない場合、ファイル&lt;a href=&quot;../paths&quot;&gt;へのパス&lt;/a&gt;は論理モジュールパスを反映します。祖先モジュールのパスコンポーネントはディレクトリであり、モジュールのコンテンツは、モジュールの名前と &lt;code&gt;.rs&lt;/code&gt; 拡張子が付いたファイルにあります。たとえば、次のモジュール構造は、この対応するファイルシステム構造を持つことができます。</target>
        </trans-unit>
        <trans-unit id="29558e1ce9256ba552f6d5cea0ac0d8f0b314326" translate="yes" xml:space="preserve">
          <source>A more complex example:</source>
          <target state="translated">より複雑な例。</target>
        </trans-unit>
        <trans-unit id="d3b971a729c5c72b8be0c4aea17fd6538988f22d" translate="yes" xml:space="preserve">
          <source>A more complex pattern, using a closure:</source>
          <target state="translated">クロージャーを使った、より複雑なパターン。</target>
        </trans-unit>
        <trans-unit id="3dd589b621cc1adc060715bf9a9ed158d11abe3d" translate="yes" xml:space="preserve">
          <source>A more experienced Rustacean would write the signature shown in Listing 4-9 instead because it allows us to use the same function on both &lt;code&gt;&amp;amp;String&lt;/code&gt; values and &lt;code&gt;&amp;amp;str&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;&amp;amp;String&lt;/code&gt; 値と &lt;code&gt;&amp;amp;str&lt;/code&gt; 値の両方で同じ関数を使用できるため、経験豊富なRustaceanはリスト4-9に示す署名を代わりに記述します。</target>
        </trans-unit>
        <trans-unit id="e13722d1be852ba526aeffb3cbbf03d8cad62a98" translate="yes" xml:space="preserve">
          <source>A more realistic usage of &lt;code&gt;!&lt;/code&gt; is in this code:</source>
          <target state="translated">のより現実的な使用法 &lt;code&gt;!&lt;/code&gt; このコードにあります：</target>
        </trans-unit>
        <trans-unit id="47b3111cf8992e03f361ef35402077d40b862b00" translate="yes" xml:space="preserve">
          <source>A more user-friendly and stable version of this operation is &lt;a href=&quot;../process/fn.abort&quot;&gt;&lt;code&gt;std::process::abort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この操作のよりユーザーフレンドリーで安定したバージョンは、&lt;a href=&quot;../process/fn.abort&quot;&gt; &lt;code&gt;std::process::abort&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="e80c7507fc9ff231be351f8cae94b1cf2dae1652" translate="yes" xml:space="preserve">
          <source>A multi-line (doc-)comment is unterminated.</source>
          <target state="translated">複数行(doc-)のコメントは終端がありません。</target>
        </trans-unit>
        <trans-unit id="a85c20eab8c8f59bbb7b3375434e1c4c2a5fba1b" translate="yes" xml:space="preserve">
          <source>A mutable binding, reference, or pointer.</source>
          <target state="translated">変形可能なバインディング、参照、またはポインタ。</target>
        </trans-unit>
        <trans-unit id="8cd7d09d26092ca44a3f65ffe3c3325410d6931b" translate="yes" xml:space="preserve">
          <source>A mutable iterator over a sub-range of entries in a &lt;code&gt;BTreeMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BTreeMap&lt;/code&gt; のエントリのサブ範囲に対する可変イテレータ。</target>
        </trans-unit>
        <trans-unit id="0adc791ed0f0c19141af510a4b25898187d82ab6" translate="yes" xml:space="preserve">
          <source>A mutable iterator over the elements of a &lt;code&gt;LinkedList&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LinkedList&lt;/code&gt; の要素に対する変更可能な反復子。</target>
        </trans-unit>
        <trans-unit id="ad89e0aaae2a988478ed905cd86eb0dc9435d0ff" translate="yes" xml:space="preserve">
          <source>A mutable iterator over the elements of a &lt;code&gt;VecDeque&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;VecDeque&lt;/code&gt; の要素に対する変更可能な反復子。</target>
        </trans-unit>
        <trans-unit id="79c92db5fb2c00374466341575412a72b346b96d" translate="yes" xml:space="preserve">
          <source>A mutable iterator over the entries of a &lt;code&gt;BTreeMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BTreeMap&lt;/code&gt; のエントリに対する変更可能な反復子。</target>
        </trans-unit>
        <trans-unit id="82c043e3bfeb960195491db7d3d334e90cb7714f" translate="yes" xml:space="preserve">
          <source>A mutable iterator over the entries of a &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; のエントリに対する変更可能な反復子。</target>
        </trans-unit>
        <trans-unit id="d985ac327f38804e748201a497e2781eda7b7dde" translate="yes" xml:space="preserve">
          <source>A mutable iterator over the values of a &lt;code&gt;BTreeMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BTreeMap&lt;/code&gt; の値に対する変更可能な反復子。</target>
        </trans-unit>
        <trans-unit id="3180573575f9ee53aeac5bbb0709534becff511d" translate="yes" xml:space="preserve">
          <source>A mutable iterator over the values of a &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; の値に対する変更可能な反復子。</target>
        </trans-unit>
        <trans-unit id="8b90716d837b7248d5e9906c50d0a99bd6595870" translate="yes" xml:space="preserve">
          <source>A mutable memory location with dynamically checked borrow rules</source>
          <target state="translated">動的にチェックされた借用ルールを備えた、ミュータブルなメモリロケーション</target>
        </trans-unit>
        <trans-unit id="c91e5fa32d436ead641cd9a3940ea6b760cc8d42" translate="yes" xml:space="preserve">
          <source>A mutable memory location.</source>
          <target state="translated">変形可能なメモリの位置。</target>
        </trans-unit>
        <trans-unit id="0b14b941c806b921d8ab056b2552003af1435118" translate="yes" xml:space="preserve">
          <source>A mutable reference can be created with &lt;code&gt;&amp;amp;mut&lt;/code&gt;.</source>
          <target state="translated">可変参照は &lt;code&gt;&amp;amp;mut&lt;/code&gt; で作成できます。</target>
        </trans-unit>
        <trans-unit id="aa831fb6e4681d63ec9057ce3580c443fec9edb2" translate="yes" xml:space="preserve">
          <source>A mutable reference was used in a constant.</source>
          <target state="translated">変形可能な参照が定数で使用されていました。</target>
        </trans-unit>
        <trans-unit id="7ad0f3cf407381fd22bba2cf586e95f6a6a15615" translate="yes" xml:space="preserve">
          <source>A mutable variable is used but it is already captured by a closure.</source>
          <target state="translated">変異可能な変数が使用されていますが、すでにクロージャによって捕捉されています。</target>
        </trans-unit>
        <trans-unit id="1ceef8798472360db16ce7d238d9ede4272142f3" translate="yes" xml:space="preserve">
          <source>A mutable variable, reference, or pointer.</source>
          <target state="translated">変形可能な変数、参照、またはポインタ。</target>
        </trans-unit>
        <trans-unit id="0f8c1096d067dc232cad356da19d2cbebed307a4" translate="yes" xml:space="preserve">
          <source>A mutual exclusion primitive useful for protecting shared data</source>
          <target state="translated">共有データの保護に有用な相互排除プリミティブ</target>
        </trans-unit>
        <trans-unit id="342f794408fe251ce7add66c87de4ca58808181b" translate="yes" xml:space="preserve">
          <source>A named address:</source>
          <target state="translated">名前のついた住所。</target>
        </trans-unit>
        <trans-unit id="01a291706f0b443b495b0b8c907121279cbace5d" translate="yes" xml:space="preserve">
          <source>A negative impl was made default impl.</source>
          <target state="translated">マイナスインプはデフォルトインプにしました。</target>
        </trans-unit>
        <trans-unit id="da1879858ed2ef626482e4f36f37eea0d652d696" translate="yes" xml:space="preserve">
          <source>A negative implementation is one that excludes a type from implementing a particular trait. Not being able to use a trait is always a safe operation, so negative implementations are always safe and never need to be marked as unsafe.</source>
          <target state="translated">負の実装とは、ある型が特定の形質を実装できないようにすることです。形質を使用できないことは常に安全な操作であるため、負の実装は常に安全であり、安全でないことをマークする必要はありません。</target>
        </trans-unit>
        <trans-unit id="64f76de0f189c143b75250fce4afe6feb8fa06dc" translate="yes" xml:space="preserve">
          <source>A negative implementation was marked as unsafe.</source>
          <target state="translated">ネガティブな実装は安全ではないとマークされていました。</target>
        </trans-unit>
        <trans-unit id="4ca3ab38594dcb0b01232bdbb9c6f42b411e7856" translate="yes" xml:space="preserve">
          <source>A new pipe should be arranged to connect the parent and child processes.</source>
          <target state="translated">親プロセスと子プロセスを接続するために、新しいパイプを配置する必要があります。</target>
        </trans-unit>
        <trans-unit id="9ef1ea249a1150bef2505217b3c43c59ac961084" translate="yes" xml:space="preserve">
          <source>A new thread can be configured before it is spawned via the &lt;a href=&quot;struct.builder&quot;&gt;&lt;code&gt;Builder&lt;/code&gt;&lt;/a&gt; type, which currently allows you to set the name and stack size for the child thread:</source>
          <target state="translated">新しいスレッドは、&lt;a href=&quot;struct.builder&quot;&gt; &lt;code&gt;Builder&lt;/code&gt; &lt;/a&gt;タイプを介して生成される前に構成できます。これにより、現在、子スレッドの名前とスタックサイズを設定できます。</target>
        </trans-unit>
        <trans-unit id="5e4ae553ae5846b13d461bd059795986a05e550e" translate="yes" xml:space="preserve">
          <source>A new thread can be spawned using the &lt;a href=&quot;fn.spawn&quot;&gt;&lt;code&gt;thread::spawn&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">新しいスレッドは、&lt;a href=&quot;fn.spawn&quot;&gt; &lt;code&gt;thread::spawn&lt;/code&gt; &lt;/a&gt;関数を使用して生成できます。</target>
        </trans-unit>
        <trans-unit id="012e80e619e9a75c91e5b48d3d4ff0741fba078e" translate="yes" xml:space="preserve">
          <source>A node will be able to refer to its parent node but doesn&amp;rsquo;t own its parent. In Listing 15-28, we update &lt;code&gt;main&lt;/code&gt; to use this new definition so the &lt;code&gt;leaf&lt;/code&gt; node will have a way to refer to its parent, &lt;code&gt;branch&lt;/code&gt;:</source>
          <target state="translated">ノードはその親ノードを参照できますが、その親を所有していません。リスト15-28では、 &lt;code&gt;main&lt;/code&gt; を更新してこの新しい定義を使用するため、 &lt;code&gt;leaf&lt;/code&gt; ノードは親 &lt;code&gt;branch&lt;/code&gt; を参照する方法を持っています：</target>
        </trans-unit>
        <trans-unit id="0d77bcf0653e102d2dc04011199024bd95fbb9db" translate="yes" xml:space="preserve">
          <source>A non-&lt;code&gt;'static&lt;/code&gt; lifetime was used in a const generic. This is currently not allowed.</source>
          <target state="translated">非 &lt;code&gt;'static&lt;/code&gt; ライフタイムがconstジェネリックで使用されました。現在、これは許可されていません。</target>
        </trans-unit>
        <trans-unit id="1c1956450560b920c7d29f562d8c785a2a837c6c" translate="yes" xml:space="preserve">
          <source>A non-constant value was used in a constant expression.</source>
          <target state="translated">定数式の中に非定数値が使われていました。</target>
        </trans-unit>
        <trans-unit id="1eee5bad5b1b537626b09062a59e028d86d55ec2" translate="yes" xml:space="preserve">
          <source>A non-default implementation was already made on this type so it cannot be specialized further.</source>
          <target state="translated">この型はすでにデフォルトではない実装がなされているので、これ以上の特化はできません。</target>
        </trans-unit>
        <trans-unit id="f749bb15fde0e4ed5d6ca2223f09a3999408a077" translate="yes" xml:space="preserve">
          <source>A non-default implementation was already made on this type so it cannot be specialized further. Erroneous code example:</source>
          <target state="translated">この型はすでにデフォルトではない実装がなされているので、これ以上の特化はできません。誤ったコード例です。</target>
        </trans-unit>
        <trans-unit id="945520bcba1761f9fc7afafe8dcc369bff6ec8f2" translate="yes" xml:space="preserve">
          <source>A non-final component in path is not a directory.</source>
          <target state="translated">パス内の非最終的なコンポーネントはディレクトリではありません。</target>
        </trans-unit>
        <trans-unit id="c1d61674888a79b8d093da31552849442beb0211" translate="yes" xml:space="preserve">
          <source>A non-ident or non-wildcard pattern has been used as a parameter of a function pointer type.</source>
          <target state="translated">非identまたは非ワイルドカードパターンが関数ポインタ型のパラメータとして使用されています。</target>
        </trans-unit>
        <trans-unit id="3c2d2a8d307a0d585bf4d4468aa00fb158ce3e7d" translate="yes" xml:space="preserve">
          <source>A non-mutable value was assigned a value.</source>
          <target state="translated">非可換的な値が代入されていました。</target>
        </trans-unit>
        <trans-unit id="6d5a3ee2105e8888d79910fc840ffa44f6ec8258" translate="yes" xml:space="preserve">
          <source>A non-raw &lt;em&gt;byte string literal&lt;/em&gt; is a sequence of ASCII characters and &lt;em&gt;escapes&lt;/em&gt;, preceded by the characters &lt;code&gt;U+0062&lt;/code&gt; (&lt;code&gt;b&lt;/code&gt;) and &lt;code&gt;U+0022&lt;/code&gt; (double-quote), and followed by the character &lt;code&gt;U+0022&lt;/code&gt;. If the character &lt;code&gt;U+0022&lt;/code&gt; is present within the literal, it must be &lt;em&gt;escaped&lt;/em&gt; by a preceding &lt;code&gt;U+005C&lt;/code&gt; (&lt;code&gt;\&lt;/code&gt;) character. Alternatively, a byte string literal can be a &lt;em&gt;raw byte string literal&lt;/em&gt;, defined below. The type of a byte string literal of length &lt;code&gt;n&lt;/code&gt; is &lt;code&gt;&amp;amp;'static [u8; n]&lt;/code&gt;.</source>
          <target state="translated">非raw &lt;em&gt;バイト文字列リテラル&lt;/em&gt;は、一連のASCII文字と&lt;em&gt;エスケープであり&lt;/em&gt;、先頭に文字 &lt;code&gt;U+0062&lt;/code&gt; （ &lt;code&gt;b&lt;/code&gt; ）と &lt;code&gt;U+0022&lt;/code&gt; （二重引用符）が続き、その後に文字 &lt;code&gt;U+0022&lt;/code&gt; が続きます。文字 &lt;code&gt;U+0022&lt;/code&gt; がリテラル内にある場合&lt;em&gt;は&lt;/em&gt;、先行する &lt;code&gt;U+005C&lt;/code&gt; （ &lt;code&gt;\&lt;/code&gt; ）文字で&lt;em&gt;エスケープ&lt;/em&gt;する必要があります。または、&lt;em&gt;バイト文字列リテラルは&lt;/em&gt;、以下で定義する&lt;em&gt;生のバイト文字&lt;/em&gt;列リテラルにすることもできます。長さ &lt;code&gt;n&lt;/code&gt; のバイト文字列リテラルの型は &lt;code&gt;&amp;amp;'static [u8; n]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5c51fee9eaaa31ddc4415e9556f81e14c7ecfe88" translate="yes" xml:space="preserve">
          <source>A non-root module attempts to import macros from another crate.</source>
          <target state="translated">root ではないモジュールが、別の木箱からマクロをインポートしようとします。</target>
        </trans-unit>
        <trans-unit id="0f7f88934a0864a48a1aa3e075daab332c8783a0" translate="yes" xml:space="preserve">
          <source>A non-root module tried to import macros from another crate.</source>
          <target state="translated">非 root モジュールが別の木箱からマクロをインポートしようとしました。</target>
        </trans-unit>
        <trans-unit id="84ccf07b47b66963a7e3e32486b9dba6e199bf07" translate="yes" xml:space="preserve">
          <source>A non-structural-match type was used as the type of a const generic parameter.</source>
          <target state="translated">constジェネリックパラメータの型として非構造マッチ型が使用されていました。</target>
        </trans-unit>
        <trans-unit id="2fa1a2ea6af29cff8cb26708218d5730128ed29d" translate="yes" xml:space="preserve">
          <source>A nonexistent interface was requested or the requested address was not local.</source>
          <target state="translated">存在しないインターフェイスが要求されたか、要求されたアドレスがローカルではありませんでした。</target>
        </trans-unit>
        <trans-unit id="96ce721c887ff14a23c8684eb9a885bd0450c6a3" translate="yes" xml:space="preserve">
          <source>A normal component, e.g., &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; in &lt;code&gt;a/b&lt;/code&gt;.</source>
          <target state="translated">通常の成分、例えば、及び &lt;code&gt;b&lt;/code&gt; で &lt;code&gt;a/b&lt;/code&gt; 。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5782d98ce3a8ef05d6f0d54e23bbea53e593ec4e" translate="yes" xml:space="preserve">
          <source>A note regarding zero-sized types and zero-sized layouts: many methods in the &lt;code&gt;Alloc&lt;/code&gt; trait state that allocation requests must be non-zero size, or else undefined behavior can result.</source>
          <target state="translated">サイズがゼロのタイプとサイズがゼロのレイアウトに関する注意： &lt;code&gt;Alloc&lt;/code&gt; トレイトの多くのメソッドは、割り当てリクエストがゼロ以外のサイズでなければならないことを述べています。そうしないと、未定義の動作が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="d70ff5d8ac6ec719cfc0758b679c32b46a7a0fdd" translate="yes" xml:space="preserve">
          <source>A null &lt;code&gt;fn&lt;/code&gt; pointer.</source>
          <target state="translated">ヌル &lt;code&gt;fn&lt;/code&gt; ポインタ。</target>
        </trans-unit>
        <trans-unit id="dbd524388dc48721a46df11a0e678684cddc1ff5" translate="yes" xml:space="preserve">
          <source>A number in a non-decimal base has no digits.</source>
          <target state="translated">10進数以外の数値には桁がありません。</target>
        </trans-unit>
        <trans-unit id="79055d577bd4470f262c27ac3d7f2c814ba28782" translate="yes" xml:space="preserve">
          <source>A panic upon overflow:</source>
          <target state="translated">溢れ出た時のパニック。</target>
        </trans-unit>
        <trans-unit id="7e451dc65737a3d0078f0a0cdca0352afd247852" translate="yes" xml:space="preserve">
          <source>A parameter type is missing a lifetime constraint or has a lifetime that does not live long enough.</source>
          <target state="translated">パラメータ型に寿命制約がないか、寿命が十分に長くないパラメータ型があります。</target>
        </trans-unit>
        <trans-unit id="c17681e220340a047c028939b5c9a6007c707423" translate="yes" xml:space="preserve">
          <source>A parameter type is missing an explicit lifetime bound and may not live long enough.</source>
          <target state="translated">パラメータ型に明示的な寿命の制限がないため、十分に長生きできない可能性があります。</target>
        </trans-unit>
        <trans-unit id="bd0627aebae59febc951bf56bcbbb5c77e2a3cca" translate="yes" xml:space="preserve">
          <source>A parameter was incorrect.</source>
          <target state="translated">パラメータに誤りがありました。</target>
        </trans-unit>
        <trans-unit id="8faec6289671e90add0a6793ff7c83244ee9ad52" translate="yes" xml:space="preserve">
          <source>A parent of the given path doesn't exist. (To create a directory and all its missing parents at the same time, use the &lt;a href=&quot;fn.create_dir_all&quot;&gt;&lt;code&gt;create_dir_all&lt;/code&gt;&lt;/a&gt; function.)</source>
          <target state="translated">指定されたパスの親は存在しません。（ディレクトリーとそのすべての欠落している親を同時に作成するには、&lt;a href=&quot;fn.create_dir_all&quot;&gt; &lt;code&gt;create_dir_all&lt;/code&gt; &lt;/a&gt;関数を使用します。）</target>
        </trans-unit>
        <trans-unit id="3c44a59945c31a15632dad83502ad5c534fa6460" translate="yes" xml:space="preserve">
          <source>A particular instance &lt;code&gt;RandomState&lt;/code&gt; will create the same instances of &lt;a href=&quot;../../hash/trait.hasher&quot;&gt;&lt;code&gt;Hasher&lt;/code&gt;&lt;/a&gt;, but the hashers created by two different &lt;code&gt;RandomState&lt;/code&gt; instances are unlikely to produce the same result for the same values.</source>
          <target state="translated">特定のインスタンス &lt;code&gt;RandomState&lt;/code&gt; は&lt;a href=&quot;../../hash/trait.hasher&quot;&gt; &lt;code&gt;Hasher&lt;/code&gt; &lt;/a&gt;の同じインスタンスを作成しますが、2つの異なる &lt;code&gt;RandomState&lt;/code&gt; インスタンスによって作成されたハッシャーが同じ値に対して同じ結果を生成することはほとんどありません。</target>
        </trans-unit>
        <trans-unit id="83b0cbf0a90bcfe2367c6fdcc070513f6d4d75f8" translate="yes" xml:space="preserve">
          <source>A particular pattern &lt;code&gt;_&lt;/code&gt; will match anything, but it never binds to a variable, so it&amp;rsquo;s often used in the last match arm. The &lt;code&gt;_&lt;/code&gt; pattern can be useful when you want to ignore any value not specified, for example. We&amp;rsquo;ll cover the &lt;code&gt;_&lt;/code&gt; pattern in more detail in the &lt;a href=&quot;ch18-03-pattern-syntax#ignoring-values-in-a-pattern&quot;&gt;&amp;ldquo;Ignoring Values in a Pattern&amp;rdquo;&lt;/a&gt; section later in this chapter.</source>
          <target state="translated">特定のパターン &lt;code&gt;_&lt;/code&gt; は何にでも一致しますが、変数にバインドされることはないため、最後の一致アームでよく使用されます。 &lt;code&gt;_&lt;/code&gt; あなたは、たとえば、指定されていない任意の値を無視したいときパターンが役立ちます。私たちは、取り上げる &lt;code&gt;_&lt;/code&gt; で詳細に模様&lt;a href=&quot;ch18-03-pattern-syntax#ignoring-values-in-a-pattern&quot;&gt;「のパターンで値を無視する」&lt;/a&gt;この章で後述します。</target>
        </trans-unit>
        <trans-unit id="1f72278829757d575931ca8a320129aa5f0521b4" translate="yes" xml:space="preserve">
          <source>A path can take two forms:</source>
          <target state="translated">パスは2つの形をとることができます。</target>
        </trans-unit>
        <trans-unit id="7908f4aa852c1de2737ef7d2b9796ba4b3783229" translate="yes" xml:space="preserve">
          <source>A pattern a &lt;code&gt;..=&lt;/code&gt; b must always have a &amp;le; b. It is an error to have a range pattern &lt;code&gt;10..=0&lt;/code&gt;, for example.</source>
          <target state="translated">パターンa &lt;code&gt;..=&lt;/code&gt; bは常にa&amp;le;bでなければなりません。たとえば、範囲パターン &lt;code&gt;10..=0&lt;/code&gt; するとエラーになります。</target>
        </trans-unit>
        <trans-unit id="891da3d988f6fc5238b5b4fb583d072b5a0287dc" translate="yes" xml:space="preserve">
          <source>A pattern attempted to extract an incorrect number of fields from a variant.</source>
          <target state="translated">パターンは、バリアントから誤った数のフィールドを抽出しようとしました。</target>
        </trans-unit>
        <trans-unit id="6d6b7416ed8a3ba7b4dcdc0423f76b297ea15288" translate="yes" xml:space="preserve">
          <source>A pattern binding is using the same name as one of the variants of a type.</source>
          <target state="translated">パターンバインディングは、型のバリアントの1つと同じ名前を使用しています。</target>
        </trans-unit>
        <trans-unit id="53b95bece3c7641fd29f13b871ae1a3d402281d9" translate="yes" xml:space="preserve">
          <source>A pattern for a struct fails to specify a sub-pattern for every one of the struct's fields.</source>
          <target state="translated">構造体のパターンでは、構造体のフィールドごとにサブパターンを指定することができません。</target>
        </trans-unit>
        <trans-unit id="2c3ec235405c966e5db61078265ddd06c38fdf87" translate="yes" xml:space="preserve">
          <source>A pattern guard may refer to the variables bound within the pattern they follow. Before evaluating the guard, a shared reference is taken to the part of the scrutinee the variable matches on. While evaluating the guard, this shared reference is then used when accessing the variable. Only when the guard evaluates to true is the value moved, or copied, from the scrutinee into the variable. This allows shared borrows to be used inside guards without moving out of the scrutinee in case guard fails to match. Moreover, by holding a shared reference while evaluating the guard, mutation inside guards is also prevented.</source>
          <target state="translated">パターンガードは、それらが従うパターン内にバインドされた変数を参照することができます。ガードを評価する前に、変数がマッチするスクルーティニーの部分に共有参照が取られます。ガードを評価している間、この共有参照は変数にアクセスする際に使用されます。ガードが真と評価された場合にのみ、値がスクルーティニーから変数に移動またはコピーされます。これにより、ガードがマッチしなかった場合でも、スクルーティニーの外に移動することなく、ガード内で共有参照を使用することができます。さらに、ガードを評価している間に共有参照を保持することで、ガード内部での突然変異も防止されます。</target>
        </trans-unit>
        <trans-unit id="bf85ec7c19381f75fc673dab8bb0b15ce1a79c9a" translate="yes" xml:space="preserve">
          <source>A pattern is said to be &lt;em&gt;refutable&lt;/em&gt; when it has the possibility of not being matched by the value it is being matched against. &lt;em&gt;Irrefutable&lt;/em&gt; patterns, on the other hand, always match the value they are being matched against. Examples:</source>
          <target state="translated">パターンは、照合される値によって照合されない可能性がある場合、&lt;em&gt;反駁&lt;/em&gt;可能であると言われます。一方、&lt;em&gt;反論できない&lt;/em&gt;パターンは常に、照合対象の値と一致します。例：</target>
        </trans-unit>
        <trans-unit id="50718096ba0e9d977821568bde4dc051a6527468" translate="yes" xml:space="preserve">
          <source>A pattern used to match against an enum variant must provide a sub-pattern for each field of the enum variant.</source>
          <target state="translated">列挙バリアントに対してマッチするためのパターンは、列挙バリアントの各フィールドに対してサブパターンを提供しなければなりません。</target>
        </trans-unit>
        <trans-unit id="bf12d88e1623c0c22171573d10a1573941789f14" translate="yes" xml:space="preserve">
          <source>A pattern used to match against an enum variant must provide a sub-pattern for each field of the enum variant. This error indicates that a pattern attempted to extract an incorrect number of fields from a variant.</source>
          <target state="translated">列挙バリアントに対してマッチするために使用されるパターンは、列挙バリアントの各フィールドに対してサブパターンを提供しなければなりません。このエラーは、パターンがバリアントから誤った数のフィールドを抽出しようとしたことを示します。</target>
        </trans-unit>
        <trans-unit id="27a0056206e19a4b052630f19a00fbd4710c685a" translate="yes" xml:space="preserve">
          <source>A pattern was declared as an argument in a foreign function declaration.</source>
          <target state="translated">外部関数宣言の引数としてパターンが宣言されていました。</target>
        </trans-unit>
        <trans-unit id="d00f0437e6924080d1afab40ce4328811dd1cc4e" translate="yes" xml:space="preserve">
          <source>A pinned pointer.</source>
          <target state="translated">ピン留めされたポインター。</target>
        </trans-unit>
        <trans-unit id="a57ac3109ff2b056cae1f3bd5a56c84d66c44184" translate="yes" xml:space="preserve">
          <source>A place that is valid for the duration of a program.</source>
          <target state="translated">番組の期間中に有効な場所。</target>
        </trans-unit>
        <trans-unit id="7d0a1c9d0822781050522c413844b46b3f9e19ec" translate="yes" xml:space="preserve">
          <source>A plugin/crate was declared but cannot be found.</source>
          <target state="translated">プラグイン/クレートが宣言されていますが、見つかりません。</target>
        </trans-unit>
        <trans-unit id="de1781b485888ee330b207b934e4f4c6b09830cf" translate="yes" xml:space="preserve">
          <source>A plugin/crate was declared but cannot be found. Erroneous code example:</source>
          <target state="translated">プラグイン/クレートが宣言されていますが、見つかりません。誤ったコード例です。</target>
        </trans-unit>
        <trans-unit id="2db11183c5e69392e41fbe166caeebf1df741e85" translate="yes" xml:space="preserve">
          <source>A pointer to a trait type cannot be implicitly dereferenced by a pattern. Every trait defines a type, but because the size of trait implementers isn't fixed, this type has no compile-time size. Therefore, all accesses to trait types must be through pointers. If you encounter this error you should try to avoid dereferencing the pointer.</source>
          <target state="translated">形質型へのポインタは、パターンによって暗黙的に派生させることはできません。すべての形質は型を定義しますが、形質実装者のサイズは固定されていないため、この型はコンパイル時のサイズを持ちません。したがって、形質型へのアクセスはすべてポインタを介して行わなければなりません。このエラーに遭遇した場合は、ポインタの派生を避けるようにしなければなりません。</target>
        </trans-unit>
        <trans-unit id="34017de9c0f653b0f37f4a6965f6e339b6e3eb8f" translate="yes" xml:space="preserve">
          <source>A pointer type for heap allocation.</source>
          <target state="translated">ヒープ割り当てのためのポインタ型。</target>
        </trans-unit>
        <trans-unit id="068b4756f4660015d453841abd0c47d397debbf3" translate="yes" xml:space="preserve">
          <source>A poisoned &lt;a href=&quot;struct.once&quot;&gt;&lt;code&gt;Once&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">毒された&lt;a href=&quot;struct.once&quot;&gt; &lt;code&gt;Once&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="a8f3faefa5c5d4137483f566406d69333a9e2fb7" translate="yes" xml:space="preserve">
          <source>A poisoned &lt;code&gt;Once&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Once&lt;/code&gt; 毒された：</target>
        </trans-unit>
        <trans-unit id="929b0eef10b3144f1332f3b71eafbab8eba71fe6" translate="yes" xml:space="preserve">
          <source>A poisoned mutex, however, does not prevent all access to the underlying data. The &lt;a href=&quot;struct.poisonerror&quot;&gt;&lt;code&gt;PoisonError&lt;/code&gt;&lt;/a&gt; type has an &lt;a href=&quot;struct.poisonerror#method.into_inner&quot;&gt;&lt;code&gt;into_inner&lt;/code&gt;&lt;/a&gt; method which will return the guard that would have otherwise been returned on a successful lock. This allows access to the data, despite the lock being poisoned.</source>
          <target state="translated">ただし、汚染されたミューテックスは、基礎となるデータへのすべてのアクセスを妨げるものではありません。&lt;a href=&quot;struct.poisonerror&quot;&gt; &lt;code&gt;PoisonError&lt;/code&gt; の&lt;/a&gt;タイプがあり&lt;a href=&quot;struct.poisonerror#method.into_inner&quot;&gt; &lt;code&gt;into_inner&lt;/code&gt; の&lt;/a&gt;そうでなければ成功したロックに返却されていたガードを返します方法を。これにより、ロックが無効化されていても、データにアクセスできます。</target>
        </trans-unit>
        <trans-unit id="73fd6c45e77753ba09fc6ae1f1a84a2bc4c2f7fb" translate="yes" xml:space="preserve">
          <source>A possible error value when converting a &lt;code&gt;String&lt;/code&gt; from a UTF-16 byte slice.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; をUTF-16バイトスライスから変換するときに発生する可能性のあるエラー値。</target>
        </trans-unit>
        <trans-unit id="ffac94ea92c56dd95950816abb00c940a0255f3a" translate="yes" xml:space="preserve">
          <source>A possible error value when converting a &lt;code&gt;String&lt;/code&gt; from a UTF-8 byte vector.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; をUTF-8バイトベクトルから変換するときに発生する可能性のあるエラー値。</target>
        </trans-unit>
        <trans-unit id="de325cfd40d79951f0c1e349c34b7cd70df1fbf9" translate="yes" xml:space="preserve">
          <source>A prelude for conveniently writing platform-specific code.</source>
          <target state="translated">プラットフォーム固有のコードを便利に書くための前置き。</target>
        </trans-unit>
        <trans-unit id="c5e33e24aca6a074f404567a2953c71b3f5c603f" translate="yes" xml:space="preserve">
          <source>A priority queue implemented with a binary heap.</source>
          <target state="translated">バイナリヒープで実装された優先度キュー。</target>
        </trans-unit>
        <trans-unit id="839f5fda33c60277611f831c62b151f9e603547e" translate="yes" xml:space="preserve">
          <source>A private item was used outside its scope.</source>
          <target state="translated">私物が範囲外で使用されていました。</target>
        </trans-unit>
        <trans-unit id="519be8a210afc21029c91c0c6f7917299f8dedbe" translate="yes" xml:space="preserve">
          <source>A private item was used outside of its scope.</source>
          <target state="translated">私物を範囲外で使用していました。</target>
        </trans-unit>
        <trans-unit id="b050bad5b423d40a7cbc2510e0a714043fcaa01a" translate="yes" xml:space="preserve">
          <source>A private trait was used on a public type parameter bound.</source>
          <target state="translated">パブリック型のパラメータ・バウンドでプライベートな形質が使用されていました。</target>
        </trans-unit>
        <trans-unit id="94c921f0636467349880453e7613dadeb16d5d80" translate="yes" xml:space="preserve">
          <source>A private trait was used on a public type parameter bound. Erroneous code examples:</source>
          <target state="translated">パブリック型のパラメータ・バウンドでプライベートな形質が使用されていました。誤ったコード例。</target>
        </trans-unit>
        <trans-unit id="9a0df3af8cfe7414b96a23dc7a41a25700bb086e" translate="yes" xml:space="preserve">
          <source>A private type was used in a public type signature.</source>
          <target state="translated">公開型署名でプライベート型が使用されていました。</target>
        </trans-unit>
        <trans-unit id="5e925db174af759a11ddedae27575f0f853ed111" translate="yes" xml:space="preserve">
          <source>A private type was used in a public type signature. Erroneous code example:</source>
          <target state="translated">プライベート型がパブリック型シグネチャで使用されていました。誤ったコード例です。</target>
        </trans-unit>
        <trans-unit id="c311fafb046b4454c158177c3e7c9d9343861f7d" translate="yes" xml:space="preserve">
          <source>A process builder, providing fine-grained control over how a new process should be spawned.</source>
          <target state="translated">プロセスビルダは、新しいプロセスをどのように生成するかを細かく制御することができます。</target>
        </trans-unit>
        <trans-unit id="b012d3c393a9f2ccaba1d026e4a05fd4cbe591b1" translate="yes" xml:space="preserve">
          <source>A quick refresher on memory ordering:</source>
          <target state="translated">記憶の順序を簡単に復習します。</target>
        </trans-unit>
        <trans-unit id="63343f59c96578fe01a096392dc2051b122408d3" translate="yes" xml:space="preserve">
          <source>A random number that will generate some variety in the workout plans</source>
          <target state="translated">ワークアウトプランに多様性をもたらす乱数</target>
        </trans-unit>
        <trans-unit id="72b92a764b3becb3cc5dd577eea9f2e87d42d804" translate="yes" xml:space="preserve">
          <source>A range bounded inclusively below and above (&lt;code&gt;start..=end&lt;/code&gt;).</source>
          <target state="translated">上下の境界を含む範囲（ &lt;code&gt;start..=end&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="79fc3105ea5313c5378041705247103257830779" translate="yes" xml:space="preserve">
          <source>A range only bounded exclusively above (&lt;code&gt;..end&lt;/code&gt;).</source>
          <target state="translated">上のみを境界とする範囲（ &lt;code&gt;..end&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e19446803edcf89ddaf7319d7c6427759416990d" translate="yes" xml:space="preserve">
          <source>A range only bounded inclusively above (&lt;code&gt;..=end&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;..=end&lt;/code&gt; のみを含む範囲（.. = end）。</target>
        </trans-unit>
        <trans-unit id="74324727cee50500895944c74cdd394c1b31fc07" translate="yes" xml:space="preserve">
          <source>A range only bounded inclusively below (&lt;code&gt;start..&lt;/code&gt;).</source>
          <target state="translated">下側のみを含む範囲（ &lt;code&gt;start..&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="4f00d04637794ce3f904922bdb42fa3ce7f3d5fe" translate="yes" xml:space="preserve">
          <source>A raw identifier is like a normal identifier, but prefixed by &lt;code&gt;r#&lt;/code&gt;. (Note that the &lt;code&gt;r#&lt;/code&gt; prefix is not included as part of the actual identifier.) Unlike a normal identifier, a raw identifier may be any strict or reserved keyword except the ones listed above for &lt;code&gt;RAW_IDENTIFIER&lt;/code&gt;.</source>
          <target state="translated">生の識別子は通常の識別子に似ていますが、先頭に &lt;code&gt;r#&lt;/code&gt; が付いています。（ &lt;code&gt;r#&lt;/code&gt; 接頭辞は実際の識別子の一部として含まれていないことに注意してください。）通常の識別子とは異なり、未加工の識別子は、 &lt;code&gt;RAW_IDENTIFIER&lt;/code&gt; について上記にリストしたものを除いて、任意の厳密なキーワードまたは予約済みキーワードです。</target>
        </trans-unit>
        <trans-unit id="ffc636325c67605fadec2b68ebb55669b2cd9c34" translate="yes" xml:space="preserve">
          <source>A raw pointer type which can be safely shared between threads.</source>
          <target state="translated">スレッド間で安全に共有できる生ポインタ型。</target>
        </trans-unit>
        <trans-unit id="f1f955686d561bc8208f2ce3b12ca99c3765110a" translate="yes" xml:space="preserve">
          <source>A raw string isn't correctly terminated because the trailing &lt;code&gt;#&lt;/code&gt; count doesn't match its leading &lt;code&gt;#&lt;/code&gt; count.</source>
          <target state="translated">末尾の &lt;code&gt;#&lt;/code&gt; カウントが先頭の &lt;code&gt;#&lt;/code&gt; カウントと一致しないため、生の文字列は正しく終了しません。</target>
        </trans-unit>
        <trans-unit id="20341b33140e6b08a4b41c1574d7c2c86bdc7608" translate="yes" xml:space="preserve">
          <source>A reader which is always at EOF.</source>
          <target state="translated">常にEOFにいるリーダー。</target>
        </trans-unit>
        <trans-unit id="5c0eac8aa6da425e06c685e18fd91d499e3c16f1" translate="yes" xml:space="preserve">
          <source>A reader which yields one byte over and over and over and over and over and...</source>
          <target state="translated">1バイトを何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も....</target>
        </trans-unit>
        <trans-unit id="0187c58d40ebb5aaa0b543a6b1bda48ead05f016" translate="yes" xml:space="preserve">
          <source>A reader-writer lock</source>
          <target state="translated">リーダーライターロック</target>
        </trans-unit>
        <trans-unit id="2d89d8dfb8b1c58f5d841e5165fcf975a6c55e6a" translate="yes" xml:space="preserve">
          <source>A recursive type has infinite size because it doesn't have an indirection.</source>
          <target state="translated">再帰型はインダイレクションを持たないため、サイズが無限大になります。</target>
        </trans-unit>
        <trans-unit id="414e2acfb8956698eab95c0efb754ad454841ffa" translate="yes" xml:space="preserve">
          <source>A reference has a longer lifetime than the data it references.</source>
          <target state="translated">参照は、参照するデータよりも長い寿命を持っています。</target>
        </trans-unit>
        <trans-unit id="8299c0d135b8f5441cc8858d8675b0fc5f91fcc2" translate="yes" xml:space="preserve">
          <source>A reference or &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; that is dangling, unaligned, or points to an invalid value.</source>
          <target state="translated">ぶら下がっている、位置合わせされていない、または無効な値を指している参照または &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9108b5b496b508ef46e829906b2e7b5524691e8f" translate="yes" xml:space="preserve">
          <source>A reference represents a borrow of some owned value. You can get one by using the &lt;code&gt;&amp;amp;&lt;/code&gt; or &lt;code&gt;&amp;amp;mut&lt;/code&gt; operators on a value, or by using a &lt;code&gt;ref&lt;/code&gt; or &lt;code&gt;ref mut&lt;/code&gt; pattern.</source>
          <target state="translated">参照は、ある所有価値の借用を表します。値に &lt;code&gt;&amp;amp;&lt;/code&gt; または &lt;code&gt;&amp;amp;mut&lt;/code&gt; 演算子を使用するか、 &lt;code&gt;ref&lt;/code&gt; または &lt;code&gt;ref mut&lt;/code&gt; パターンを使用して取得できます。</target>
        </trans-unit>
        <trans-unit id="def229fac786a814e540383a36be7448c81c2810" translate="yes" xml:space="preserve">
          <source>A reference to a local variable was returned.</source>
          <target state="translated">ローカル変数への参照が返されました。</target>
        </trans-unit>
        <trans-unit id="9b45e7cfae560003198e2ac81c9a7e5c60325d0a" translate="yes" xml:space="preserve">
          <source>A reference to an open file on the filesystem.</source>
          <target state="translated">ファイルシステム上で開いているファイルへの参照。</target>
        </trans-unit>
        <trans-unit id="cbf7d17da7f9b8415b894a96d3c62639060d8148" translate="yes" xml:space="preserve">
          <source>A reference to the current directory, i.e., &lt;code&gt;.&lt;/code&gt;.</source>
          <target state="translated">現在のディレクトリへの参照、つまり &lt;code&gt;.&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="54c4ba3b0f946cb73000b704747ed0cc043ef985" translate="yes" xml:space="preserve">
          <source>A reference to the parent directory, i.e., &lt;code&gt;..&lt;/code&gt;.</source>
          <target state="translated">親ディレクトリへの参照、すなわち、 &lt;code&gt;..&lt;/code&gt; .。</target>
        </trans-unit>
        <trans-unit id="b305ff2e1e8a128729de5a06db133ccf46d493cc" translate="yes" xml:space="preserve">
          <source>A reference/pointer is &quot;dangling&quot; if it is null or not all of the bytes it points to are part of the same allocation (so in particular they all have to be part of &lt;em&gt;some&lt;/em&gt; allocation). The span of bytes it points to is determined by the pointer value and the size of the pointee type (using &lt;code&gt;size_of_val&lt;/code&gt;). As a consequence, if the span is empty, &quot;dangling&quot; is the same as &quot;non-null&quot;. Note that slices and strings point to their entire range, so it is important that the length metadata is never too large. In particular, allocations and therefore slices and strings cannot be bigger than &lt;code&gt;isize::MAX&lt;/code&gt; bytes.</source>
          <target state="translated">参照/ポインタがnullであるか、それが指すすべてのバイトが同じ割り当ての一部ではない場合、参照/ポインタは「ダングリング」です（したがって、特にそれらはすべて&lt;em&gt;何らかの&lt;/em&gt;割り当ての一部で&lt;em&gt;ある&lt;/em&gt;必要があります）。それが指すバイトのスパンは、ポインター値とポインター型のサイズ（ &lt;code&gt;size_of_val&lt;/code&gt; を使用）によって決定されます。結果として、スパンが空の場合、「ぶら下がり」は「非ヌル」と同じです。スライスと文字列は範囲全体を指しているため、長さのメタデータが大きすぎないようにすることが重要です。特に、割り当て、したがってスライスと文字列は、 &lt;code&gt;isize::MAX&lt;/code&gt; バイトより大きくすることはできません。</target>
        </trans-unit>
        <trans-unit id="771deb0451fb407b0fb913d5488c53c42558785c" translate="yes" xml:space="preserve">
          <source>A regular floating point number.</source>
          <target state="translated">正規の浮動小数点数。</target>
        </trans-unit>
        <trans-unit id="cd85c1b05128e75e217b61f7154c9636692d1cea" translate="yes" xml:space="preserve">
          <source>A regular reference is a type of pointer, and one way to think of a pointer is as an arrow to a value stored somewhere else. In Listing 15-6, we create a reference to an &lt;code&gt;i32&lt;/code&gt; value and then use the dereference operator to follow the reference to the data:</source>
          <target state="translated">通常の参照はポインタの一種であり、ポインタを考える1つの方法は、別の場所に格納されている値への矢印と考えることです。リスト15-6では、 &lt;code&gt;i32&lt;/code&gt; への参照を作成します値、逆参照演算子を使用してデータへの参照を追跡しています。</target>
        </trans-unit>
        <trans-unit id="461658f899b03c712ef32df7b204d3908a10ea3a" translate="yes" xml:space="preserve">
          <source>A related concept is scope: the nested context in which code is written has a set of names that are defined as &amp;ldquo;in scope.&amp;rdquo; When reading, writing, and compiling code, programmers and compilers need to know whether a particular name at a particular spot refers to a variable, function, struct, enum, module, constant, or other item and what that item means. You can create scopes and change which names are in or out of scope. You can&amp;rsquo;t have two items with the same name in the same scope; tools are available to resolve name conflicts.</source>
          <target state="translated">関連する概念はスコープです。コードが記述されているネストされたコンテキストには、「スコープ内」として定義された一連の名前があります。コードの読み取り、書き込み、およびコンパイルを行う場合、プログラマーとコンパイラーは、特定の場所の特定の名前が変数、関数、構造体、列挙型、モジュール、定数、またはその他のアイテムを参照しているかどうか、およびそのアイテムの意味を知る必要があります。スコープを作成して、スコープ内またはスコープ外の名前を変更できます。同じスコープ内に同じ名前の2つのアイテムを含めることはできません。名前の競合を解決するためのツールが利用可能です。</target>
        </trans-unit>
        <trans-unit id="4629afc869292537f9c628724559e37eef9a2cb2" translate="yes" xml:space="preserve">
          <source>A repeat expression &lt;code&gt;[x; N]&lt;/code&gt;, which produces an array with &lt;code&gt;N&lt;/code&gt; copies of &lt;code&gt;x&lt;/code&gt;. The type of &lt;code&gt;x&lt;/code&gt; must be &lt;a href=&quot;marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">繰り返し表現 &lt;code&gt;[x; N]&lt;/code&gt; 、 &lt;code&gt;x&lt;/code&gt; の &lt;code&gt;N&lt;/code&gt; 個のコピーを持つ配列を生成します。 &lt;code&gt;x&lt;/code&gt; のタイプは&lt;a href=&quot;marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; で&lt;/a&gt;なければなりません。</target>
        </trans-unit>
        <trans-unit id="3238c87767b981c84fc407d2a6b89dd0a8979fcd" translate="yes" xml:space="preserve">
          <source>A restriction is imposed on the shebang syntax to avoid confusion with an &lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt;. The &lt;code&gt;#!&lt;/code&gt; characters must not be followed by a &lt;code&gt;[&lt;/code&gt; token, ignoring intervening &lt;a href=&quot;comments&quot;&gt;comments&lt;/a&gt; or &lt;a href=&quot;whitespace&quot;&gt;whitespace&lt;/a&gt;. If this restriction fails, then it is not treated as a shebang, but instead as the start of an attribute.</source>
          <target state="translated">&lt;a href=&quot;attributes&quot;&gt;属性&lt;/a&gt;との混同を避けるために、シバン構文に制限が課せられます。 &lt;code&gt;#!&lt;/code&gt; 間にある&lt;a href=&quot;comments&quot;&gt;コメント&lt;/a&gt;や&lt;a href=&quot;whitespace&quot;&gt;空白を&lt;/a&gt;無視して、文字の後に &lt;code&gt;[&lt;/code&gt; トークンを続けることはできません。この制限が失敗した場合、それはシバンとしてではなく、属性の開始として扱われます。</target>
        </trans-unit>
        <trans-unit id="6bdd3de922c246975bfd1cbfd244a2a660fcbad2" translate="yes" xml:space="preserve">
          <source>A return statement was found outside of a function body.</source>
          <target state="translated">return 文が関数本体の外にありました。</target>
        </trans-unit>
        <trans-unit id="80cb47a4163ef3f70e5ddff5f65587e6f1ef80e1" translate="yes" xml:space="preserve">
          <source>A reverse searcher for a string pattern.</source>
          <target state="translated">文字列パターンの逆引き検索。</target>
        </trans-unit>
        <trans-unit id="4d45eae920f51ae4fa809b8359142e43a5dccbee" translate="yes" xml:space="preserve">
          <source>A scrutinee is the expression that is matched on in &lt;code&gt;match&lt;/code&gt; expressions and similar pattern matching constructs. For example, in &lt;code&gt;match x { A =&amp;gt; 1, B =&amp;gt; 2 }&lt;/code&gt;, the expression &lt;code&gt;x&lt;/code&gt; is the scrutinee.</source>
          <target state="translated">scrutineeは、 &lt;code&gt;match&lt;/code&gt; 式および類似のパターンマッチング構成で一致する式です。たとえば、 &lt;code&gt;match x { A =&amp;gt; 1, B =&amp;gt; 2 }&lt;/code&gt; 場合、式 &lt;code&gt;x&lt;/code&gt; がスクランチです。</target>
        </trans-unit>
        <trans-unit id="090be4c47ade9f54015d614891f57e36867218e4" translate="yes" xml:space="preserve">
          <source>A searcher for a string pattern.</source>
          <target state="translated">文字列パターンの探索者。</target>
        </trans-unit>
        <trans-unit id="805b0de6f894d8345c096cc31db6d9d15c14c18a" translate="yes" xml:space="preserve">
          <source>A seek beyond the end of a stream is allowed, but behavior is defined by the implementation.</source>
          <target state="translated">ストリームの終端を越えたシークは許可されていますが、動作は実装によって定義されています。</target>
        </trans-unit>
        <trans-unit id="187cb85d876dbb3e8278047d50cee3e8447cafbc" translate="yes" xml:space="preserve">
          <source>A set based on a B-Tree.</source>
          <target state="translated">B-Treeをベースにした集合。</target>
        </trans-unit>
        <trans-unit id="89f39617bf1d1e8280f2895b2baeee66b493c8f3" translate="yes" xml:space="preserve">
          <source>A similar error is E0201. The difference is whether there is one declaration block or not. To avoid this error, you must give each &lt;code&gt;fn&lt;/code&gt; a unique name.</source>
          <target state="translated">同様のエラーはE0201です。違いは、宣言ブロックが1つあるかどうかです。このエラーを回避するには、各 &lt;code&gt;fn&lt;/code&gt; を指定する必要がありますに一意の名前を。</target>
        </trans-unit>
        <trans-unit id="6f6761295ae70019a0d2d6374dca4eaf6df07696" translate="yes" xml:space="preserve">
          <source>A similar rule exists for combining mutable and immutable references. This code results in an error:</source>
          <target state="translated">同様のルールは、ミュータブル参照とイミュータブル参照の組み合わせにも存在します。このコードはエラーになります。</target>
        </trans-unit>
        <trans-unit id="8e839688e01ba01e9dfe145feb09335f1aa963d0" translate="yes" xml:space="preserve">
          <source>A simple example:</source>
          <target state="translated">簡単な例です。</target>
        </trans-unit>
        <trans-unit id="823d579a067f8a96f5626154ea604d86f19d68ef" translate="yes" xml:space="preserve">
          <source>A simple function returning &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; might be defined and used like so:</source>
          <target state="translated">&lt;a href=&quot;enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt;返す単純な関数は、次のように定義して使用できます。</target>
        </trans-unit>
        <trans-unit id="d53eef6dd046b01cc7902a1c3902a172dad006e2" translate="yes" xml:space="preserve">
          <source>A simple spinlock:</source>
          <target state="translated">シンプルなスピンロック。</target>
        </trans-unit>
        <trans-unit id="a2f952715a286d980e4f33b8e4525dcb3eac03bb" translate="yes" xml:space="preserve">
          <source>A simple workaround is to use a helper method instead:</source>
          <target state="translated">簡単な回避策は、代わりにヘルパーメソッドを使用することです。</target>
        </trans-unit>
        <trans-unit id="054dbf6f392fa38162c0d62e6ead09a79999e53b" translate="yes" xml:space="preserve">
          <source>A simple wrapper around a type to assert that it is unwind safe.</source>
          <target state="translated">巻き戻しが安全であることを保証するための型のシンプルなラッパーです。</target>
        </trans-unit>
        <trans-unit id="b53617da96fc2eac5eec0b6bb0e92f32c47fc76e" translate="yes" xml:space="preserve">
          <source>A single (arbitrary) thread will receive a &lt;a href=&quot;struct.barrierwaitresult&quot;&gt;&lt;code&gt;BarrierWaitResult&lt;/code&gt;&lt;/a&gt; that returns &lt;code&gt;true&lt;/code&gt; from &lt;a href=&quot;struct.barrierwaitresult#method.is_leader&quot;&gt;&lt;code&gt;BarrierWaitResult::is_leader()&lt;/code&gt;&lt;/a&gt; when returning from this function, and all other threads will receive a result that will return &lt;code&gt;false&lt;/code&gt; from &lt;a href=&quot;struct.barrierwaitresult#method.is_leader&quot;&gt;&lt;code&gt;BarrierWaitResult::is_leader()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">単一の（任意の）スレッドは、この関数から戻るときに&lt;a href=&quot;struct.barrierwaitresult#method.is_leader&quot;&gt; &lt;code&gt;BarrierWaitResult::is_leader()&lt;/code&gt; &lt;/a&gt;から &lt;code&gt;true&lt;/code&gt; を返す&lt;a href=&quot;struct.barrierwaitresult&quot;&gt; &lt;code&gt;BarrierWaitResult&lt;/code&gt; &lt;/a&gt;を受け取り、他のすべてのスレッドは、&lt;a href=&quot;struct.barrierwaitresult#method.is_leader&quot;&gt; &lt;code&gt;BarrierWaitResult::is_leader()&lt;/code&gt; &lt;/a&gt;から &lt;code&gt;false&lt;/code&gt; を返す結果を受け取ります。</target>
        </trans-unit>
        <trans-unit id="cd3fd0649d54745c9dde4e2f256bda95babba9f6" translate="yes" xml:space="preserve">
          <source>A single (arbitrary) thread will receive a &lt;a href=&quot;struct.barrierwaitresult&quot;&gt;&lt;code&gt;BarrierWaitResult&lt;/code&gt;&lt;/a&gt; that returns &lt;code&gt;true&lt;/code&gt; from &lt;a href=&quot;struct.barrierwaitresult#method.is_leader&quot;&gt;&lt;code&gt;is_leader&lt;/code&gt;&lt;/a&gt; when returning from this function, and all other threads will receive a result that will return &lt;code&gt;false&lt;/code&gt; from &lt;a href=&quot;struct.barrierwaitresult#method.is_leader&quot;&gt;&lt;code&gt;is_leader&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">単一の（任意の）スレッドは、この関数から&lt;a href=&quot;struct.barrierwaitresult#method.is_leader&quot;&gt; &lt;code&gt;is_leader&lt;/code&gt; &lt;/a&gt;ときにis_leaderから &lt;code&gt;true&lt;/code&gt; を返す&lt;a href=&quot;struct.barrierwaitresult&quot;&gt; &lt;code&gt;BarrierWaitResult&lt;/code&gt; &lt;/a&gt;を受け取り、他のすべてのスレッドは&lt;a href=&quot;struct.barrierwaitresult#method.is_leader&quot;&gt; &lt;code&gt;is_leader&lt;/code&gt; &lt;/a&gt;から &lt;code&gt;false&lt;/code&gt; を返す結果を受け取ります。</target>
        </trans-unit>
        <trans-unit id="0e774847b8b17cfc775f96b4b6ba3419133c2ae2" translate="yes" xml:space="preserve">
          <source>A single &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; may be encoded as more than one byte. This method can only succeed if the entire byte sequence was successfully written, and this method will not return until all data has been written or an error occurs.</source>
          <target state="translated">1つの&lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;が複数のバイトとしてエンコードされる場合があります。このメソッドは、バイトシーケンス全体が正常に書き込まれた場合にのみ成功します。このメソッドは、すべてのデータが書き込まれるか、エラーが発生するまで戻りません。</target>
        </trans-unit>
        <trans-unit id="a7ad66dadfa2951ac2cd349b4d260c6f6b28c527" translate="yes" xml:space="preserve">
          <source>A single &lt;em&gt;decimal literal&lt;/em&gt; followed by an &lt;em&gt;exponent&lt;/em&gt;.</source>
          <target state="translated">単一の&lt;em&gt;10進リテラルと&lt;/em&gt;それに続く&lt;em&gt;指数&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="538d82224c466a3fa46957bd1dad7926fc97c926" translate="yes" xml:space="preserve">
          <source>A single component of a path.</source>
          <target state="translated">パスの単一コンポーネント。</target>
        </trans-unit>
        <trans-unit id="2286204503218f0f2c8d94ba2bb110e020e0bc00" translate="yes" xml:space="preserve">
          <source>A single-threaded reference-counting pointer. 'Rc' stands for 'Reference Counted'.</source>
          <target state="translated">シングルスレッドの参照カウントポインタ。'Rc' は 'Reference Counted' の略です。</target>
        </trans-unit>
        <trans-unit id="5b101d21362e496b89adfac2fbb37a58e0757a7e" translate="yes" xml:space="preserve">
          <source>A slice is a &lt;a href=&quot;../dynamically-sized-types&quot;&gt;dynamically sized type&lt;/a&gt; representing a 'view' into a sequence of elements of type &lt;code&gt;T&lt;/code&gt;. The slice type is written as &lt;code&gt;[T]&lt;/code&gt;.</source>
          <target state="translated">スライスは、タイプ &lt;code&gt;T&lt;/code&gt; の要素のシーケンスへの「ビュー」を表す&lt;a href=&quot;../dynamically-sized-types&quot;&gt;動的サイズのタイプ&lt;/a&gt;です。スライスタイプは &lt;code&gt;[T]&lt;/code&gt; と表記されます。ます。</target>
        </trans-unit>
        <trans-unit id="aba616073ac3de8beab95ccfac7bd633d599946d" translate="yes" xml:space="preserve">
          <source>A slice is dynamically-sized view into a contiguous sequence, written as &lt;code&gt;[T]&lt;/code&gt;.</source>
          <target state="translated">スライスは、 &lt;code&gt;[T]&lt;/code&gt; と書かれた、連続したシーケンスへの動的なサイズのビューです。</target>
        </trans-unit>
        <trans-unit id="fe635e064516decbfbc3e3d9ce043f9d25e8ca9f" translate="yes" xml:space="preserve">
          <source>A slice of a path (akin to &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">パスのスライス（&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; と&lt;/a&gt;同様）。</target>
        </trans-unit>
        <trans-unit id="2759e6b662ba691ba47b65069c920c9b980fcd79" translate="yes" xml:space="preserve">
          <source>A slice of a path (akin to &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">パスのスライス（&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt; &lt;code&gt;str&lt;/code&gt; に&lt;/a&gt;似ています）。</target>
        </trans-unit>
        <trans-unit id="11824dd936b3023e24b3affd0ef64f49ba6ed2c9" translate="yes" xml:space="preserve">
          <source>A slightly sad example of not reading anything into a buffer:</source>
          <target state="translated">バッファに何も読み込まないというちょっと悲しい例。</target>
        </trans-unit>
        <trans-unit id="45dafb0f63eaca5bfb7f56b27e11fa2b7d396e89" translate="yes" xml:space="preserve">
          <source>A socket address could not be bound because the address is already in use elsewhere.</source>
          <target state="translated">ソケットアドレスが既に他の場所で使用されているため、ソケットアドレスをバインドできなかった。</target>
        </trans-unit>
        <trans-unit id="ac2b051bc6a92539c672158c6142e1d18c98d73f" translate="yes" xml:space="preserve">
          <source>A somewhat surprising consequence of the definition is that &lt;code&gt;&amp;amp;mut T&lt;/code&gt; is &lt;code&gt;Sync&lt;/code&gt; (if &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Sync&lt;/code&gt;) even though it seems like that might provide unsynchronized mutation. The trick is that a mutable reference behind a shared reference (that is, &lt;code&gt;&amp;amp; &amp;amp;mut T&lt;/code&gt;) becomes read-only, as if it were a &lt;code&gt;&amp;amp; &amp;amp;T&lt;/code&gt;. Hence there is no risk of a data race.</source>
          <target state="translated">定義のいくぶん意外な結果は、 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; が &lt;code&gt;Sync&lt;/code&gt; である場合（ &lt;code&gt;T&lt;/code&gt; が &lt;code&gt;Sync&lt;/code&gt; の場合）、非同期のミューテーションを提供する可能性があるように見えます。トリック（つまり共有参照の後ろに可変基準点である &lt;code&gt;&amp;amp; &amp;amp;mut T&lt;/code&gt; ）読み取り専用になり、それがあたかも &lt;code&gt;&amp;amp; &amp;amp;T&lt;/code&gt; 。したがって、データ競合のリスクはありません。</target>
        </trans-unit>
        <trans-unit id="2194c015edca7318deaf09554d0cad9263a5128b" translate="yes" xml:space="preserve">
          <source>A source file can have a &lt;a href=&quot;https://en.wikipedia.org/wiki/Shebang_(Unix)&quot;&gt;&lt;em&gt;shebang&lt;/em&gt;&lt;/a&gt; (SHEBANG production), which indicates to the operating system what program to use to execute this file. It serves essentially to treat the source file as an executable script. The shebang can only occur at the beginning of the file (but after the optional &lt;em&gt;UTF8BOM&lt;/em&gt;). It is ignored by the compiler. For example:</source>
          <target state="translated">ソースファイルには&lt;a href=&quot;https://en.wikipedia.org/wiki/Shebang_(Unix)&quot;&gt;&lt;em&gt;シバン&lt;/em&gt;&lt;/a&gt;（SHEBANGプロダクション）を含めることができます。これは、このファイルの実行に使用するプログラムをオペレーティングシステムに示します。それは本質的にソースファイルを実行可能なスクリプトとして扱うのに役立ちます。シバンはファイルの先頭でのみ発生します（ただし、オプションの&lt;em&gt;UTF8BOMの&lt;/em&gt;後に発生します）。コンパイラーによって無視されます。例えば：</target>
        </trans-unit>
        <trans-unit id="5ec62fb18603ebc6519f469782df4169fc5a681f" translate="yes" xml:space="preserve">
          <source>A source stage in an iterator pipeline.</source>
          <target state="translated">イテレータ パイプラインのソース ステージ。</target>
        </trans-unit>
        <trans-unit id="3a13e4ab897112a5bbfa779986c13ffc8249c723" translate="yes" xml:space="preserve">
          <source>A specialized &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; type for I/O operations.</source>
          <target state="translated">I / O操作に特化した&lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt;タイプ。</target>
        </trans-unit>
        <trans-unit id="29c08563a92ed84161c48f32442e9c55ea57c60e" translate="yes" xml:space="preserve">
          <source>A specialized &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; type for threads.</source>
          <target state="translated">スレッド専用の&lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt;タイプ。</target>
        </trans-unit>
        <trans-unit id="c3d479aee422ab65a96675342bd98a8476bf0c50" translate="yes" xml:space="preserve">
          <source>A splicing iterator for &lt;code&gt;Vec&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Vec&lt;/code&gt; のスプライシングイテレータ。</target>
        </trans-unit>
        <trans-unit id="382d455769d00569a95a026174c2cb511f9bbb7a" translate="yes" xml:space="preserve">
          <source>A stability attribute has been used outside of the standard library.</source>
          <target state="translated">安定性属性が標準ライブラリ以外で使用されています。</target>
        </trans-unit>
        <trans-unit id="9c6a5b448820983a6050fcd10b6c3d4dd333f376" translate="yes" xml:space="preserve">
          <source>A stability attribute was used outside of the standard library.</source>
          <target state="translated">安定性属性は標準ライブラリ以外で使用されていました。</target>
        </trans-unit>
        <trans-unit id="7208bc1e59d67cb800b9b249868cce02c7e08ab0" translate="yes" xml:space="preserve">
          <source>A stability attribute was used outside of the standard library. Erroneous code example:</source>
          <target state="translated">安定性属性が標準ライブラリ以外で使用されていました。誤ったコード例。</target>
        </trans-unit>
        <trans-unit id="c28a8a30c83d119da8eeb5ad945a45667f90aa8f" translate="yes" xml:space="preserve">
          <source>A statement is the smallest standalone element of a programming language that commands a computer to perform an action.</source>
          <target state="translated">ステートメントは、コンピュータにアクションを実行するように命令するプログラミング言語の最小のスタンドアロン要素です。</target>
        </trans-unit>
        <trans-unit id="7993655a3c3f53e3aa0f9baecc01e8b1f97ae73b" translate="yes" xml:space="preserve">
          <source>A statement.</source>
          <target state="translated">声明。</target>
        </trans-unit>
        <trans-unit id="d137e324ac57303f829812294caa15b53500d48e" translate="yes" xml:space="preserve">
          <source>A static item is a value which is valid for the entire duration of your program (a &lt;code&gt;'static&lt;/code&gt; lifetime).</source>
          <target state="translated">静的アイテムは、プログラムの全期間（ &lt;code&gt;'static&lt;/code&gt; 存続期間）にわたって有効な値です。</target>
        </trans-unit>
        <trans-unit id="1525834046325d03a0ffcca63064524577af3217" translate="yes" xml:space="preserve">
          <source>A string (&lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;) is made of bytes (&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;), and a vector of bytes (&lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt;&lt;/a&gt;) is made of bytes, so this function converts between the two. Not all byte slices are valid &lt;code&gt;String&lt;/code&gt;s, however: &lt;code&gt;String&lt;/code&gt; requires that it is valid UTF-8. &lt;code&gt;from_utf8()&lt;/code&gt; checks to ensure that the bytes are valid UTF-8, and then does the conversion.</source>
          <target state="translated">文字列（&lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;）はバイト（&lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt;）で構成され、バイトのベクトル（&lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; &lt;/a&gt;）はバイトで構成されているため、この関数は2つの間で変換します。ただし、すべてのバイトスライスが有効な &lt;code&gt;String&lt;/code&gt; は限りません。 &lt;code&gt;String&lt;/code&gt; では、有効なUTF-8である必要があります。 &lt;code&gt;from_utf8()&lt;/code&gt; は、バイトが有効なUTF-8であることを確認してから、変換を実行します。</target>
        </trans-unit>
        <trans-unit id="d8b0000fb42f01e7695f858d20347ce505d823eb" translate="yes" xml:space="preserve">
          <source>A string describing the architecture of the CPU that is currently in use.</source>
          <target state="translated">現在使用しているCPUのアーキテクチャを記述した文字列。</target>
        </trans-unit>
        <trans-unit id="5df1b3a45cf6eb695745e50e624d24676a48e8a7" translate="yes" xml:space="preserve">
          <source>A string describing the specific operating system in use. Example value is &lt;code&gt;linux&lt;/code&gt;.</source>
          <target state="translated">使用中の特定のオペレーティングシステムを説明する文字列。値の例は &lt;code&gt;linux&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="8947468201a55a4ba9cd06d3d0a2f1ff1271df73" translate="yes" xml:space="preserve">
          <source>A string is a sequence of bytes. 'Left' in this context means the first position of that byte string; for a language like Arabic or Hebrew which are 'right to left' rather than 'left to right', this will be the &lt;em&gt;right&lt;/em&gt; side, not the left.</source>
          <target state="translated">文字列は一連のバイトです。このコンテキストでの「左」は、そのバイト文字列の最初の位置を意味します。「左から右」ではなく「右から左」であるアラビア語やヘブライ語のような言語の場合、これは左側ではなく&lt;em&gt;右側に&lt;/em&gt;なります。</target>
        </trans-unit>
        <trans-unit id="0bc83c493a049c765d2dfbebad0f09d82d1b6fde" translate="yes" xml:space="preserve">
          <source>A string is a sequence of bytes. 'Right' in this context means the last position of that byte string; for a language like Arabic or Hebrew which are 'right to left' rather than 'left to right', this will be the &lt;em&gt;left&lt;/em&gt; side, not the right.</source>
          <target state="translated">文字列は一連のバイトです。このコンテキストでの「右」は、そのバイト文字列の最後の位置を意味します。「右から左へ」というよりも、アラビア語やヘブライ語のような言語は「右に左」、これは次のようになります&lt;em&gt;、左&lt;/em&gt;サイド、右ではありません。</target>
        </trans-unit>
        <trans-unit id="a7d73837e1ae6f385cc7b12b321574d70650bd43" translate="yes" xml:space="preserve">
          <source>A string is a sequence of bytes. &lt;code&gt;end&lt;/code&gt; in this context means the last position of that byte string; for a left-to-right language like English or Russian, this will be right side, and for right-to-left languages like Arabic or Hebrew, this will be the left side.</source>
          <target state="translated">文字列はバイトのシーケンスです。このコンテキストでの &lt;code&gt;end&lt;/code&gt; は、そのバイト文字列の最後の位置を意味します。英語やロシア語などの左から右への言語の場合、これは右側になり、アラビア語やヘブライ語などの右から左への言語の場合、これは左側になります。</target>
        </trans-unit>
        <trans-unit id="fd472172ba3e393c6a98b65077b0a65554fdb8e3" translate="yes" xml:space="preserve">
          <source>A string is a sequence of bytes. &lt;code&gt;end&lt;/code&gt; in this context means the last position of that byte string; for a left-to-right language like English or Russian, this will be right side, and for right-to-left languages like like Arabic or Hebrew, this will be the left side.</source>
          <target state="translated">文字列は一連のバイトです。このコンテキストでの &lt;code&gt;end&lt;/code&gt; は、そのバイト文字列の最後の位置を意味します。英語やロシア語のような左から右への言語の場合はこれが右側になり、アラビア語やヘブライ語のような右から左への言語の場合はこれが左側になります。</target>
        </trans-unit>
        <trans-unit id="8add450b8d835c6c86dcce6d9f4412fe207173ed" translate="yes" xml:space="preserve">
          <source>A string is a sequence of bytes. &lt;code&gt;start&lt;/code&gt; in this context means the first position of that byte string; for a left-to-right language like English or Russian, this will be left side, and for right-to-left languages like Arabic or Hebrew, this will be the right side.</source>
          <target state="translated">文字列はバイトのシーケンスです。このコンテキストでの &lt;code&gt;start&lt;/code&gt; は、そのバイト文字列の最初の位置を意味します。英語やロシア語などの左から右への言語の場合、これは左側になり、アラビア語やヘブライ語などの右から左への言語の場合、これは右側になります。</target>
        </trans-unit>
        <trans-unit id="b8e69c41862936bd74ab07a7db3ea33fabc1421d" translate="yes" xml:space="preserve">
          <source>A string is a sequence of bytes. &lt;code&gt;start&lt;/code&gt; in this context means the first position of that byte string; for a left-to-right language like English or Russian, this will be left side, and for right-to-left languages like like Arabic or Hebrew, this will be the right side.</source>
          <target state="translated">文字列は一連のバイトです。このコンテキストでの &lt;code&gt;start&lt;/code&gt; は、そのバイト文字列の最初の位置を意味します。英語やロシア語のような左から右への言語の場合、これは左側になり、アラビア語やヘブライ語のような右から左への言語の場合、これは右側になります。</target>
        </trans-unit>
        <trans-unit id="3af90a5c6860195d31687a2b123d3690f30cc3df" translate="yes" xml:space="preserve">
          <source>A string literal is a string stored directly in the final binary, and so will be valid for the &lt;code&gt;'static&lt;/code&gt; duration.</source>
          <target state="translated">文字列リテラルは、最終的なバイナリに直接格納される文字列であるため、 &lt;code&gt;'static&lt;/code&gt; 期間」有効です。</target>
        </trans-unit>
        <trans-unit id="72d1187b478d157904cca7877538ced2b416e35f" translate="yes" xml:space="preserve">
          <source>A string pattern.</source>
          <target state="translated">文字列のパターン。</target>
        </trans-unit>
        <trans-unit id="067ff927875044f01fc32c9a4450dd787608c362" translate="yes" xml:space="preserve">
          <source>A string slice (&lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;) is made of bytes (&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;), and a byte slice (&lt;a href=&quot;../primitive.slice&quot;&gt;&lt;code&gt;&amp;amp;[u8]&lt;/code&gt;&lt;/a&gt;) is made of bytes, so this function converts between the two. Not all byte slices are valid string slices, however: &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; requires that it is valid UTF-8. &lt;code&gt;from_utf8()&lt;/code&gt; checks to ensure that the bytes are valid UTF-8, and then does the conversion.</source>
          <target state="translated">文字列スライス（&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt;）はバイト（&lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt;）で構成され、バイトスライス（&lt;a href=&quot;../primitive.slice&quot;&gt; &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; &lt;/a&gt;）はバイトで構成されているため、この関数は2つの間で変換を行います。ただし、すべてのバイトスライスが有効な文字列スライスであるとは限りません。&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt;では、有効なUTF-8である必要があります。 &lt;code&gt;from_utf8()&lt;/code&gt; は、バイトが有効なUTF-8であることを確認してから、変換を行います。</target>
        </trans-unit>
        <trans-unit id="e7464828dc4f92a12dd0ad9693849275688a2fde" translate="yes" xml:space="preserve">
          <source>A string slice (&lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;) is made of bytes (&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;), and a vector of bytes (&lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt;&lt;/a&gt;) is made of bytes, so this function converts between the two. Not all byte slices are valid &lt;code&gt;String&lt;/code&gt;s, however: &lt;code&gt;String&lt;/code&gt; requires that it is valid UTF-8. &lt;code&gt;from_utf8()&lt;/code&gt; checks to ensure that the bytes are valid UTF-8, and then does the conversion.</source>
          <target state="translated">文字列スライス（&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt;）はバイト（&lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt;）で構成され、バイトのベクトル（&lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; &lt;/a&gt;）はバイトで構成されているため、この関数はこの2つの間で変換を行います。ただし、すべてのバイトスライスが有効な &lt;code&gt;String&lt;/code&gt; であるとは限りません &lt;code&gt;String&lt;/code&gt; では、有効なUTF-8である必要があります。 &lt;code&gt;from_utf8()&lt;/code&gt; は、バイトが有効なUTF-8であることを確認してから、変換を行います。</target>
        </trans-unit>
        <trans-unit id="185b4c50dbb326aeb04eb1f2bab9a2d41dd7280a" translate="yes" xml:space="preserve">
          <source>A string slice is the most primitive string type in Rust, written as &lt;code&gt;str&lt;/code&gt;. It is often seen in its borrowed forms, either mutable or shared. The shared string slice type is &lt;code&gt;&amp;amp;str&lt;/code&gt;, while the mutable string slice type is &lt;code&gt;&amp;amp;mut str&lt;/code&gt;.</source>
          <target state="translated">文字列スライスは、Rustで最もプリミティブな文字列型であり、 &lt;code&gt;str&lt;/code&gt; として記述されます。それは、可変または共有の借用形式でよく見られます。共有文字列のスライスタイプは &lt;code&gt;&amp;amp;str&lt;/code&gt; で、可変文字列のスライスタイプは &lt;code&gt;&amp;amp;mut str&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="696c15b61497eb0b1cb08d222cb16dce5b4582da" translate="yes" xml:space="preserve">
          <source>A struct can be &lt;code&gt;Copy&lt;/code&gt;, and &lt;a href=&quot;../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;Copy&lt;/code&gt;, therefore &lt;code&gt;Point&lt;/code&gt; is eligible to be &lt;code&gt;Copy&lt;/code&gt;. By contrast, consider</source>
          <target state="translated">構造体は &lt;code&gt;Copy&lt;/code&gt; にすることができ、&lt;a href=&quot;../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt;は &lt;code&gt;Copy&lt;/code&gt; であるため、 &lt;code&gt;Point&lt;/code&gt; は &lt;code&gt;Copy&lt;/code&gt; の対象になります。対照的に、考慮</target>
        </trans-unit>
        <trans-unit id="eb9b96b59ca1189f15dc2a933aeadc425813dff3" translate="yes" xml:space="preserve">
          <source>A struct constructor with private fields was invoked.</source>
          <target state="translated">プライベート・フィールドを持つ構造体コンストラクタが呼び出されました。</target>
        </trans-unit>
        <trans-unit id="f5d13af10075668c4266bfa2af5c2d787c33d9d3" translate="yes" xml:space="preserve">
          <source>A struct constructor with private fields was invoked. Erroneous code example:</source>
          <target state="translated">プライベート フィールドを持つ構造体コンストラクタが呼び出されました。誤ったコード例です。</target>
        </trans-unit>
        <trans-unit id="d5d8cb072da62f16419c7934c8ea02767949e9d6" translate="yes" xml:space="preserve">
          <source>A struct containing information about the location of a panic.</source>
          <target state="translated">パニックの場所に関する情報を含む構造体。</target>
        </trans-unit>
        <trans-unit id="4cbc7f2982657f6ecdc97f40e8df1ad547c2b1e9" translate="yes" xml:space="preserve">
          <source>A struct expression can terminate with the syntax &lt;code&gt;..&lt;/code&gt; followed by an expression to denote a functional update. The expression following &lt;code&gt;..&lt;/code&gt; (the base) must have the same struct type as the new struct type being formed.</source>
          <target state="translated">構造体式は、構文 &lt;code&gt;..&lt;/code&gt; の後に関数の更新を示す式が続くことができます。 &lt;code&gt;..&lt;/code&gt; （ベース）に続く式は、形成される新しい構造体型と同じ構造体型でなければなりません。</target>
        </trans-unit>
        <trans-unit id="86c4b8e1d72da61f04333be84148a5de11fccd79" translate="yes" xml:space="preserve">
          <source>A struct expression with fields enclosed in curly braces allows you to specify the value for each individual field in any order. The field name is separated from its value with a colon.</source>
          <target state="translated">中括弧で囲まれたフィールドを持つ構造式では、個々のフィールドの値を任意の順序で指定することができます。フィールド名はコロンで値から分離されます。</target>
        </trans-unit>
        <trans-unit id="89ddcc2481a3b96d64219755d7c1825c0ff65c03" translate="yes" xml:space="preserve">
          <source>A struct expression with fields enclosed in parentheses constructs a tuple struct. Though it is listed here as a specific expression for completeness, it is equivalent to a &lt;a href=&quot;call-expr&quot;&gt;call expression&lt;/a&gt; to the tuple struct's constructor. For example:</source>
          <target state="translated">括弧で囲まれたフィールドを持つ構造体式は、タプル構造体を構築します。完全を期すために特定の式としてここにリストされていますが、タプル構造体のコンストラクターへの&lt;a href=&quot;call-expr&quot;&gt;呼び出し式&lt;/a&gt;と同等です。例えば：</target>
        </trans-unit>
        <trans-unit id="4a5683978535ef36d2f4a36fc97769f59882d764" translate="yes" xml:space="preserve">
          <source>A struct pattern attempted to extract a non-existent field from a struct.</source>
          <target state="translated">構造体パターンが構造体から存在しないフィールドを抽出しようとしました。</target>
        </trans-unit>
        <trans-unit id="fed041bebb665ccd5885e8c57eed09e9404a7bab" translate="yes" xml:space="preserve">
          <source>A struct pattern is refutable when one of its subpatterns is refutable.</source>
          <target state="translated">構造体パターンは、そのサブパターンの1つが再可換可能な場合に再可換可能となります。</target>
        </trans-unit>
        <trans-unit id="7845438dcb42a82b5f335b8afeff28c09f01fb02" translate="yes" xml:space="preserve">
          <source>A struct providing information about a panic.</source>
          <target state="translated">パニックに関する情報を提供する構造体。</target>
        </trans-unit>
        <trans-unit id="2e74ee410a88a7bd4dc9ec3e4439e1be7c03f52f" translate="yes" xml:space="preserve">
          <source>A struct to help with &lt;a href=&quot;trait.debug&quot;&gt;&lt;code&gt;fmt::Debug&lt;/code&gt;&lt;/a&gt; implementations.</source>
          <target state="translated">&lt;a href=&quot;trait.debug&quot;&gt; &lt;code&gt;fmt::Debug&lt;/code&gt; &lt;/a&gt;実装に役立つ構造体。</target>
        </trans-unit>
        <trans-unit id="878d9a84ea5b4c1dd0e00cf0901eb339704e2d00" translate="yes" xml:space="preserve">
          <source>A struct was declared with two fields having the same name.</source>
          <target state="translated">同じ名前を持つ 2 つのフィールドを持つ構造体が宣言されました。</target>
        </trans-unit>
        <trans-unit id="5cc6e14f7d3ffa0d43917de969f7811f2b833f5b" translate="yes" xml:space="preserve">
          <source>A struct with a single field which is accessible by dereferencing the struct.</source>
          <target state="translated">構造体を参照することでアクセス可能な単一フィールドを持つ構造体。</target>
        </trans-unit>
        <trans-unit id="804d90713791042aa7ae7163ec47b488d14fba5e" translate="yes" xml:space="preserve">
          <source>A struct with a single field which is modifiable by dereferencing the struct.</source>
          <target state="translated">構造体を参照することで変更可能な単一フィールドを持つ構造体。</target>
        </trans-unit>
        <trans-unit id="0888572f00b05df1f9ff3f22503c0dc7eb90c709" translate="yes" xml:space="preserve">
          <source>A struct with more than one field containing an unsized type cannot implement &lt;code&gt;CoerceUnsized&lt;/code&gt;. This only occurs when you are trying to coerce one of the types in your struct to another type in the struct. In this case we try to impl &lt;code&gt;CoerceUnsized&lt;/code&gt; from &lt;code&gt;T&lt;/code&gt; to &lt;code&gt;U&lt;/code&gt; which are both types that the struct takes. An &lt;a href=&quot;book/ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;unsized type&lt;/a&gt; is any type that the compiler doesn't know the length or alignment of at compile time. Any struct containing an unsized type is also unsized.</source>
          <target state="translated">無サイズタイプを含む複数のフィールドを持つ構造体を実装することはできません &lt;code&gt;CoerceUnsized&lt;/code&gt; を。これは、構造体の型の1つを構造体の別の型に強制変換しようとしている場合にのみ発生します。この場合、 &lt;code&gt;T&lt;/code&gt; から &lt;code&gt;U&lt;/code&gt; に &lt;code&gt;CoerceUnsized&lt;/code&gt; を実装しようとします。これらは両方とも、構造体が取る型です。&lt;a href=&quot;book/ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;無サイズタイプは&lt;/a&gt;、コンパイラがコンパイル時の長さや配置を知っていないことをどのようなタイプです。サイズなしの型を含む構造体もサイズなしです。</target>
        </trans-unit>
        <trans-unit id="fd90f531eb1d0ac938c6ffc13d21933bccfecc8d" translate="yes" xml:space="preserve">
          <source>A struct with the representation hint &lt;code&gt;repr(transparent)&lt;/code&gt; had zero or more than one fields that were not guaranteed to be zero-sized.</source>
          <target state="translated">表現ヒント &lt;code&gt;repr(transparent)&lt;/code&gt; を持つ構造体には、サイズがゼロであることが保証されていないゼロまたは複数のフィールドがありました。</target>
        </trans-unit>
        <trans-unit id="b1c33e6a538a3d99ccd128f7c3f5572cd613b66b" translate="yes" xml:space="preserve">
          <source>A struct without a field containing an unsized type cannot implement &lt;code&gt;CoerceUnsized&lt;/code&gt;. An &lt;a href=&quot;book/ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;unsized type&lt;/a&gt; is any type that the compiler doesn't know the length or alignment of at compile time. Any struct containing an unsized type is also unsized.</source>
          <target state="translated">無サイズタイプを含むフィールドのない構造体を実装することはできません &lt;code&gt;CoerceUnsized&lt;/code&gt; を。&lt;a href=&quot;book/ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;無サイズタイプは&lt;/a&gt;、コンパイラがコンパイル時の長さや配置を知っていないことをどのようなタイプです。サイズなしの型を含む構造体もサイズなしです。</target>
        </trans-unit>
        <trans-unit id="bfe3d05f336ffd910d212738048395d48df402c2" translate="yes" xml:space="preserve">
          <source>A struct's or struct-like enum variant's field was not provided.</source>
          <target state="translated">struct または struct ライクな enum バリアントのフィールドが提供されませんでした。</target>
        </trans-unit>
        <trans-unit id="5bcfe0f822e1b5462565a584546dacf4f3c36744" translate="yes" xml:space="preserve">
          <source>A struct's or struct-like enum variant's field was specified more than once.</source>
          <target state="translated">構造体または構造体に似たenum variantのフィールドが複数回指定されました。</target>
        </trans-unit>
        <trans-unit id="d312c16b162889c1bce1669ed072c5b476d65baa" translate="yes" xml:space="preserve">
          <source>A struct, enum, or union with the &lt;code&gt;repr(transparent)&lt;/code&gt; representation hint contains a zero-sized field that requires non-trivial alignment.</source>
          <target state="translated">&lt;code&gt;repr(transparent)&lt;/code&gt; 表現ヒントを含む構造体、列挙型、または共用体には、サイズがゼロではないフィールドが含まれています。</target>
        </trans-unit>
        <trans-unit id="87c6cf95d3e0451e702dc377209e4618399b1fa6" translate="yes" xml:space="preserve">
          <source>A structure representing a Unix domain socket server.</source>
          <target state="translated">Unix ドメインソケットサーバを表す構造体。</target>
        </trans-unit>
        <trans-unit id="369143bfa607c6bacd39b080c8d08420dc95dcbd" translate="yes" xml:space="preserve">
          <source>A structure representing a type of file with accessors for each file type. It is returned by &lt;a href=&quot;struct.metadata#method.file_type&quot;&gt;&lt;code&gt;Metadata::file_type&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">各ファイルタイプのアクセサを含むファイルのタイプを表す構造。&lt;a href=&quot;struct.metadata#method.file_type&quot;&gt; &lt;code&gt;Metadata::file_type&lt;/code&gt; &lt;/a&gt;メソッドによって返されます。</target>
        </trans-unit>
        <trans-unit id="2859b7dadbca8f1bc62c1ff5e0e2a9f89b18f533" translate="yes" xml:space="preserve">
          <source>A structure wrapping a Windows path prefix as well as its unparsed string representation.</source>
          <target state="translated">Windows のパスプレフィックスと、そのパースされていない文字列表現をラップした構造体。</target>
        </trans-unit>
        <trans-unit id="a18cd960fc14986c70aa975cf92200531a20ff48" translate="yes" xml:space="preserve">
          <source>A structure-literal syntax was used to create an item that is not a structure or enum variant.</source>
          <target state="translated">構造体リテラル構文を使用して、構造体や列挙バリアントではない項目を作成しました。</target>
        </trans-unit>
        <trans-unit id="450ed556ad629fd6ee6dd398c15074a8c129be66" translate="yes" xml:space="preserve">
          <source>A successful conversion will produce the same result as &lt;a href=&quot;struct.cstring#method.new&quot;&gt;&lt;code&gt;CString::new&lt;/code&gt;&lt;/a&gt; when called without the ending nul byte.</source>
          <target state="translated">変換が成功すると、終了nulバイトなしで呼び出されたときに&lt;a href=&quot;struct.cstring#method.new&quot;&gt; &lt;code&gt;CString::new&lt;/code&gt; &lt;/a&gt;と同じ結果が生成されます。</target>
        </trans-unit>
        <trans-unit id="d24a2a657ceada76d6bbbb3c74ce41c5696fa9c3" translate="yes" xml:space="preserve">
          <source>A successful send occurs when it is determined that the other end of the channel has not hung up already. An unsuccessful send would be one where the corresponding receiver has already been deallocated. Note that a return value of &lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; means that the data will never be received, but a return value of &lt;a href=&quot;../../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt; does &lt;em&gt;not&lt;/em&gt; mean that the data will be received. It is possible for the corresponding receiver to hang up immediately after this function returns &lt;a href=&quot;../../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">送信が成功したのは、チャネルのもう一方の端がまだハングアップしていないと判断された場合です。送信の失敗は、対応する受信者の割り当てがすでに解除されている場合です。&lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; の&lt;/a&gt;戻り値はデータが受信されないことを意味しますが、&lt;a href=&quot;../../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; の&lt;/a&gt;戻り値はデータが受信されることを意味し&lt;em&gt;ない&lt;/em&gt;ことに注意してください。この関数が&lt;a href=&quot;../../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; を&lt;/a&gt;返した直後に、対応するレシーバーが電話を切る可能性があります。</target>
        </trans-unit>
        <trans-unit id="74d74f5ba0d4e61c19c1486af3bde440292622e8" translate="yes" xml:space="preserve">
          <source>A suffix is a non-raw identifier immediately (without whitespace) following the primary part of a literal.</source>
          <target state="translated">サフィックスは、リテラルの主要部分の直後にある (空白を含まない)非表示の識別子です。</target>
        </trans-unit>
        <trans-unit id="01225be668ae4fcd869b26b266eae668b00e87f5" translate="yes" xml:space="preserve">
          <source>A super trait has been added to an auto trait.</source>
          <target state="translated">オート特性にスーパー特性が追加されました。</target>
        </trans-unit>
        <trans-unit id="fcd1d7403a3a0b004c92da849e81f0a2dc9aaf82" translate="yes" xml:space="preserve">
          <source>A synchronization primitive which can be used to run a one-time global initialization. Useful for one-time initialization for FFI or related functionality. This type can only be constructed with &lt;a href=&quot;struct.once#method.new&quot;&gt;&lt;code&gt;Once::new()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">1回限りのグローバル初期化を実行するために使用できる同期プリミティブ。FFIまたは関連機能の1回限りの初期化に役立ちます。このタイプは、&lt;a href=&quot;struct.once#method.new&quot;&gt; &lt;code&gt;Once::new()&lt;/code&gt; &lt;/a&gt;でのみ構築できます。</target>
        </trans-unit>
        <trans-unit id="a56a331926b2603c064792db84cd20c38dc32bf0" translate="yes" xml:space="preserve">
          <source>A synchronization primitive which can be used to run a one-time global initialization. Useful for one-time initialization for FFI or related functionality. This type can only be constructed with the &lt;a href=&quot;constant.once_init&quot;&gt;&lt;code&gt;ONCE_INIT&lt;/code&gt;&lt;/a&gt; value or the equivalent &lt;a href=&quot;struct.once#method.new&quot;&gt;&lt;code&gt;Once::new&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">1回限りのグローバル初期化を実行するために使用できる同期プリミティブ。FFIまたは関連機能の1回限りの初期化に役立ちます。このタイプは、&lt;a href=&quot;constant.once_init&quot;&gt; &lt;code&gt;ONCE_INIT&lt;/code&gt; &lt;/a&gt;値または同等の&lt;a href=&quot;struct.once#method.new&quot;&gt; &lt;code&gt;Once::new&lt;/code&gt; &lt;/a&gt;コンストラクターでのみ構築できます。</target>
        </trans-unit>
        <trans-unit id="ec350722ecdc068b18a23660d975deaef83608f5" translate="yes" xml:space="preserve">
          <source>A synchronous, bounded channel. The &lt;a href=&quot;fn.sync_channel&quot;&gt;&lt;code&gt;sync_channel&lt;/code&gt;&lt;/a&gt; function will return a &lt;code&gt;(SyncSender, Receiver)&lt;/code&gt; tuple where the storage for pending messages is a pre-allocated buffer of a fixed size. All sends will be &lt;strong&gt;synchronous&lt;/strong&gt; by blocking until there is buffer space available. Note that a bound of 0 is allowed, causing the channel to become a &quot;rendezvous&quot; channel where each sender atomically hands off a message to a receiver.</source>
          <target state="translated">同期の境界チャネル。&lt;a href=&quot;fn.sync_channel&quot;&gt; &lt;code&gt;sync_channel&lt;/code&gt; の&lt;/a&gt;関数は戻ります &lt;code&gt;(SyncSender, Receiver)&lt;/code&gt; 保留中のメッセージのためのストレージは、固定サイズの予め割り当てられたバッファであるタプル。すべての送信は、使用可能なバッファー・スペースができるまでブロックすることにより&lt;strong&gt;同期&lt;/strong&gt;されます。0の境界が許可されることに注意してください。これにより、チャネルは「ランデブー」チャネルになり、各送信者はメッセージを受信者にアトミックにハンドオフします。</target>
        </trans-unit>
        <trans-unit id="cba628809f9496f1476d8b33de698410511ed6a9" translate="yes" xml:space="preserve">
          <source>A syntactical production</source>
          <target state="translated">構文的な生産</target>
        </trans-unit>
        <trans-unit id="a737498d76fd77a9ff17becf5c122eff8eaa0e65" translate="yes" xml:space="preserve">
          <source>A temporary value is being dropped while a borrow is still in active use.</source>
          <target state="translated">借用中に一時的な値が削除されています。</target>
        </trans-unit>
        <trans-unit id="96826c24c299b2bf43fb19f0b4fbba10405e86b7" translate="yes" xml:space="preserve">
          <source>A thread can also return a value through its &lt;a href=&quot;struct.joinhandle&quot;&gt;&lt;code&gt;JoinHandle&lt;/code&gt;&lt;/a&gt;, you can use this to make asynchronous computations (futures might be more appropriate though).</source>
          <target state="translated">スレッドは、その&lt;a href=&quot;struct.joinhandle&quot;&gt; &lt;code&gt;JoinHandle&lt;/code&gt; &lt;/a&gt;を介して値を返すこともできます。これを使用して、非同期計算を行うことができます（ただし、将来はより適切かもしれません）。</target>
        </trans-unit>
        <trans-unit id="ca6a08446cfa59c90fd402f951ed8784aa3d5f4c" translate="yes" xml:space="preserve">
          <source>A thread local storage key which owns its contents.</source>
          <target state="translated">その内容を所有するスレッドのローカルストレージキー。</target>
        </trans-unit>
        <trans-unit id="a566c05b188249907018616799317e8f6688426e" translate="yes" xml:space="preserve">
          <source>A thread that completes without panicking is considered to exit successfully.</source>
          <target state="translated">慌てずに終了したスレッドは正常に終了したとみなされます。</target>
        </trans-unit>
        <trans-unit id="cd2f16a831072bb59e0c5fa9974e56f23c534e74" translate="yes" xml:space="preserve">
          <source>A thread-local key owns the value it contains and will destroy the value when the thread exits. It is created with the &lt;a href=&quot;../macro.thread_local&quot;&gt;&lt;code&gt;thread_local!&lt;/code&gt;&lt;/a&gt; macro and can contain any value that is &lt;code&gt;'static&lt;/code&gt; (no borrowed pointers). It provides an accessor function, &lt;a href=&quot;struct.localkey#method.with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt;, that yields a shared reference to the value to the specified closure. Thread-local keys allow only shared access to values, as there would be no way to guarantee uniqueness if mutable borrows were allowed. Most values will want to make use of some form of &lt;strong&gt;interior mutability&lt;/strong&gt; through the &lt;a href=&quot;../cell/struct.cell&quot;&gt;&lt;code&gt;Cell&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../cell/struct.refcell&quot;&gt;&lt;code&gt;RefCell&lt;/code&gt;&lt;/a&gt; types.</source>
          <target state="translated">スレッドローカルキーはそれが含む値を所有し、スレッドが終了すると値を破棄します。これは&lt;a href=&quot;../macro.thread_local&quot;&gt; &lt;code&gt;thread_local!&lt;/code&gt; &lt;/a&gt;作成されます！マクロであり、 &lt;code&gt;'static&lt;/code&gt; （借用ポインタなし）の任意の値を含めることができます。これは、アクセッサ関数を提供&lt;a href=&quot;struct.localkey#method.with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt;、収率その指定閉鎖に値への共有参照。変更可能な借用が許可されている場合、一意性を保証する方法がないため、スレッドローカルキーは値への共有アクセスのみを許可します。ほとんどの値は、&lt;a href=&quot;../cell/struct.cell&quot;&gt; &lt;code&gt;Cell&lt;/code&gt; &lt;/a&gt;型または&lt;a href=&quot;../cell/struct.refcell&quot;&gt; &lt;code&gt;RefCell&lt;/code&gt; &lt;/a&gt;型を通じて&lt;strong&gt;内部の&lt;/strong&gt;可変性のある形式を利用したいと思うでしょう。</target>
        </trans-unit>
        <trans-unit id="7c1b3e385815bb55356e10c862b54219c0c9bb61" translate="yes" xml:space="preserve">
          <source>A thread-safe reference-counting pointer. 'Arc' stands for 'Atomically Reference Counted'.</source>
          <target state="translated">スレッドセーフな参照カウントポインタ。'Arc' は 'Atomically Reference Counted' の略です。</target>
        </trans-unit>
        <trans-unit id="c20fcb5862a17955d3c9171cc540c5db72364cad" translate="yes" xml:space="preserve">
          <source>A token produced by the lexer</source>
          <target state="translated">レキサーによって生成されたトークン</target>
        </trans-unit>
        <trans-unit id="507266de8c913e006a522a90feaa72cf485f935b" translate="yes" xml:space="preserve">
          <source>A trailing slash is normalized away, &lt;code&gt;/a/b&lt;/code&gt; and &lt;code&gt;/a/b/&lt;/code&gt; are equivalent.</source>
          <target state="translated">末尾のスラッシュは正規化され、 &lt;code&gt;/a/b&lt;/code&gt; と &lt;code&gt;/a/b/&lt;/code&gt; は同等です。</target>
        </trans-unit>
        <trans-unit id="4ac633f47782fcea3e3cdbd2b28541d42f49cb1e" translate="yes" xml:space="preserve">
          <source>A trait bound on &lt;code&gt;?Sized&lt;/code&gt; is the opposite of a trait bound on &lt;code&gt;Sized&lt;/code&gt;: we would read this as &amp;ldquo;&lt;code&gt;T&lt;/code&gt; may or may not be &lt;code&gt;Sized&lt;/code&gt;.&amp;rdquo; This syntax is only available for &lt;code&gt;Sized&lt;/code&gt;, not any other traits.</source>
          <target state="translated">バインドされた形質 &lt;code&gt;?Sized&lt;/code&gt; 上に結合特性の反対で &lt;code&gt;Sized&lt;/code&gt; ：我々はこれを読んでいました「 &lt;code&gt;T&lt;/code&gt; かであってもなくてもよい &lt;code&gt;Sized&lt;/code&gt; 。」この構文は &lt;code&gt;Sized&lt;/code&gt; でのみ使用でき、他のトレイトでは使用できません。</target>
        </trans-unit>
        <trans-unit id="a7f257ac376cb00e120748ca01c24ce026b8963b" translate="yes" xml:space="preserve">
          <source>A trait can have multiple methods in its body: the method signatures are listed one per line and each line ends in a semicolon.</source>
          <target state="translated">形質は本体に複数のメソッドを持つことができます:メソッドのシグネチャは1行に1つずつ表示され、各行はセミコロンで終わります。</target>
        </trans-unit>
        <trans-unit id="9262128bd94142a9efd03c6641a2bff3a39b5b73" translate="yes" xml:space="preserve">
          <source>A trait for borrowing data.</source>
          <target state="translated">データを借りるための特徴。</target>
        </trans-unit>
        <trans-unit id="7529a2277a29d3ff854565242eed7e5e7895a272" translate="yes" xml:space="preserve">
          <source>A trait for converting a value to a &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">値を &lt;code&gt;String&lt;/code&gt; に変換するための特性。</target>
        </trans-unit>
        <trans-unit id="1e3010340eda1a0df2c156c88d0e99044a3b58ec" translate="yes" xml:space="preserve">
          <source>A trait for creating instances of &lt;a href=&quot;trait.hasher&quot;&gt;&lt;code&gt;Hasher&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;trait.hasher&quot;&gt; &lt;code&gt;Hasher&lt;/code&gt; の&lt;/a&gt;インスタンスを作成するための特性。</target>
        </trans-unit>
        <trans-unit id="c6d9b8a4582a6d812cf132a7f8cdac8ff53fc3aa" translate="yes" xml:space="preserve">
          <source>A trait for customizing the behavior of the &lt;code&gt;?&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;?&lt;/code&gt; の動作をカスタマイズするための特性 オペレーター。</target>
        </trans-unit>
        <trans-unit id="976dcd2549faab554b8e6bbecaabfc30542917fd" translate="yes" xml:space="preserve">
          <source>A trait for giving a type a useful default value.</source>
          <target state="translated">型に有用なデフォルト値を与えるための特徴。</target>
        </trans-unit>
        <trans-unit id="e18827eba48f91a1c885aefb421b9657624cb210" translate="yes" xml:space="preserve">
          <source>A trait for hashing an arbitrary stream of bytes.</source>
          <target state="translated">任意のバイトストリームをハッシュ化するための特徴。</target>
        </trans-unit>
        <trans-unit id="bdee9213c6e4170b3110b9dd5eaa365239c9d83d" translate="yes" xml:space="preserve">
          <source>A trait for implementing arbitrary return types in the &lt;code&gt;main&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; 関数に任意の戻り値の型を実装するための特性。</target>
        </trans-unit>
        <trans-unit id="20b8f1b86976a3452526ed169982978b3d0e907f" translate="yes" xml:space="preserve">
          <source>A trait for mutably borrowing data.</source>
          <target state="translated">データを変異的に借用するための形質。</target>
        </trans-unit>
        <trans-unit id="d1ed2c9d8583af1348e3be7781420c71c940ca4b" translate="yes" xml:space="preserve">
          <source>A trait for objects which are byte-oriented sinks.</source>
          <target state="translated">バイト指向のシンクであるオブジェクトの特徴。</target>
        </trans-unit>
        <trans-unit id="754c048641e5a68c7fd81cc8028cfbaf095e1cb7" translate="yes" xml:space="preserve">
          <source>A trait for objects which can be converted or resolved to one or more &lt;a href=&quot;enum.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt; values.</source>
          <target state="translated">1つ以上の&lt;a href=&quot;enum.socketaddr&quot;&gt; &lt;code&gt;SocketAddr&lt;/code&gt; &lt;/a&gt;値に変換または解決できるオブジェクトの特性。</target>
        </trans-unit>
        <trans-unit id="23adce518b9b9c7fb3e196dc3fd75bab1e5f0059" translate="yes" xml:space="preserve">
          <source>A trait implementation has stricter requirements than the trait definition.</source>
          <target state="translated">形質の実装は、形質の定義よりも厳しい要件を持っています。</target>
        </trans-unit>
        <trans-unit id="bc29685de3e170d55184516a7b3d199864139684" translate="yes" xml:space="preserve">
          <source>A trait implementation is considered incoherent if either the orphan check fails or there are overlapping implementation instances.</source>
          <target state="translated">形質の実装は、オーファンチェックが失敗するか、実装インスタンスが重複している場合、支離滅裂なものとみなされます。</target>
        </trans-unit>
        <trans-unit id="a4884230017ffb802f52c6721c470c8593e7fcd5" translate="yes" xml:space="preserve">
          <source>A trait implementation is considered incoherent if either the orphan rules check fails or there are overlapping implementation instances.</source>
          <target state="translated">形質の実装は、オーファンルールのチェックに失敗するか、実装インスタンスが重複している場合、支離滅裂なものとみなされます。</target>
        </trans-unit>
        <trans-unit id="bb0a26a692dfe7bee9af7137b27b0e076260ccbc" translate="yes" xml:space="preserve">
          <source>A trait implementation must define all non-default associated items declared by the implemented trait, may redefine default associated items defined by the implemented trait, and cannot define any other items.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0010f4426c0d6cbe2dc68d818b29e968be48db6" translate="yes" xml:space="preserve">
          <source>A trait implementation was marked as unsafe while the trait is safe.</source>
          <target state="translated">形質は安全ですが、形質の実装は安全ではないとマークされていました。</target>
        </trans-unit>
        <trans-unit id="1951065ab3447cdfa4016a3198b5e5dd606d4a6b" translate="yes" xml:space="preserve">
          <source>A trait is a language item that is used for describing the functionalities a type must provide. It allows a type to make certain promises about its behavior.</source>
          <target state="translated">形質とは、型が提供しなければならない機能を記述するために使用される言語項目です。これにより、型はその動作について特定の約束をすることができます。</target>
        </trans-unit>
        <trans-unit id="c9de8e0634dfdc7f3f2e02723351cb17b73aefe4" translate="yes" xml:space="preserve">
          <source>A trait may be implemented for &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; in the same crate as &lt;code&gt;T&lt;/code&gt;, which the &lt;a href=&quot;items/implementations#trait-implementation-coherence&quot;&gt;orphan rules&lt;/a&gt; prevent for other generic types.</source>
          <target state="translated">形質はのために実装することができる &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; と同様クレートに &lt;code&gt;T&lt;/code&gt; 、&lt;a href=&quot;items/implementations#trait-implementation-coherence&quot;&gt;孤立規則は&lt;/a&gt;、他の一般的なタイプの防止します。</target>
        </trans-unit>
        <trans-unit id="1b745de10511ea796795a51c79ea5a4b196da151" translate="yes" xml:space="preserve">
          <source>A trait method was declared const.</source>
          <target state="translated">traitメソッドがconstと宣言されました。</target>
        </trans-unit>
        <trans-unit id="c934c2073046ff60e5d7154f42129a33305f83af" translate="yes" xml:space="preserve">
          <source>A trait object is defined over a single, fully-defined trait. With a regular default parameter, this parameter can just be substituted in. However, if the default parameter is &lt;code&gt;Self&lt;/code&gt;, the trait changes for each concrete type; i.e. &lt;code&gt;i32&lt;/code&gt; will be expected to implement &lt;code&gt;A&amp;lt;i32&amp;gt;&lt;/code&gt;, &lt;code&gt;bool&lt;/code&gt; will be expected to implement &lt;code&gt;A&amp;lt;bool&amp;gt;&lt;/code&gt;, etc... These types will not share an implementation of a fully-defined trait; instead they share implementations of a trait with different parameters substituted in for each implementation. This is irreconcilable with what we need to make a trait object work, and is thus disallowed. Making the trait concrete by explicitly specifying the value of the defaulted parameter will fix this issue. Fixed example:</source>
          <target state="translated">特性オブジェクトは、完全に定義された単一の特性に対して定義されます。通常のデフォルトパラメータを使用すると、このパラメータを置き換えるだけで済みます。ただし、デフォルトパラメータが &lt;code&gt;Self&lt;/code&gt; の場合、特性は具象タイプごとに変化します。つまり、 &lt;code&gt;i32&lt;/code&gt; は &lt;code&gt;A&amp;lt;i32&amp;gt;&lt;/code&gt; を実装することが期待され、 &lt;code&gt;bool&lt;/code&gt; は &lt;code&gt;A&amp;lt;bool&amp;gt;&lt;/code&gt; を実装することが期待されます。、など...これらの型は、完全に定義された特性の実装を共有しません。代わりに、実装ごとに異なるパラメーターを使用して、特性の実装を共有します。これは、特性オブジェクトを機能させるために必要なものと一致しないため、許可されていません。デフォルトのパラメータの値を明示的に指定して特性を具体化すると、この問題が修正されます。修正例：</target>
        </trans-unit>
        <trans-unit id="09ed217e59efc6a63ebd08cd2d7fd8370e33eb53" translate="yes" xml:space="preserve">
          <source>A trait object was declared with no traits.</source>
          <target state="translated">trait オブジェクトは、trit がない状態で宣言されていました。</target>
        </trans-unit>
        <trans-unit id="16935dd0c42b10d2b4960eb5cbdc15bbae87c965" translate="yes" xml:space="preserve">
          <source>A trait to emulate dynamic typing.</source>
          <target state="translated">動的なタイピングをエミュレートするための形質。</target>
        </trans-unit>
        <trans-unit id="2977e50a37e0d1dad52d9fd5a6a043035b25bd2b" translate="yes" xml:space="preserve">
          <source>A trait to express the ability to construct an object from a raw file descriptor.</source>
          <target state="translated">生のファイル記述子からオブジェクトを構築する能力を表す形質。</target>
        </trans-unit>
        <trans-unit id="d60c5c028a11d7b4ae9ad91367b8c4ed38349307" translate="yes" xml:space="preserve">
          <source>A trait to express the ability to consume an object and acquire ownership of its raw &lt;code&gt;HANDLE&lt;/code&gt;.</source>
          <target state="translated">オブジェクトを使用し、その未加工の &lt;code&gt;HANDLE&lt;/code&gt; の所有権を取得する機能を表現する特性。</target>
        </trans-unit>
        <trans-unit id="c1f9b5c774891d37ad148a2229500ad192b8b52c" translate="yes" xml:space="preserve">
          <source>A trait to express the ability to consume an object and acquire ownership of its raw &lt;code&gt;SOCKET&lt;/code&gt;.</source>
          <target state="translated">オブジェクトを消費し、その生の所有権を取得する能力を表現する特性 &lt;code&gt;SOCKET&lt;/code&gt; の。</target>
        </trans-unit>
        <trans-unit id="a98e8ff575c7077546911de64edefa1e0d617067" translate="yes" xml:space="preserve">
          <source>A trait to express the ability to consume an object and acquire ownership of its raw file descriptor.</source>
          <target state="translated">オブジェクトを消費し、その生のファイル記述子の所有権を取得する能力を表す形質。</target>
        </trans-unit>
        <trans-unit id="25a11a87d2f4adf0083235ec32efcdd357ad1b14" translate="yes" xml:space="preserve">
          <source>A trait to extract the raw unix file descriptor from an underlying object.</source>
          <target state="translated">基底オブジェクトから生の unix ファイル記述子を抽出するための形質。</target>
        </trans-unit>
        <trans-unit id="74dfee4318a470e1c8aa720bcf48b06f65b677a2" translate="yes" xml:space="preserve">
          <source>A trait type has been dereferenced.</source>
          <target state="translated">形質型が参照されていません。</target>
        </trans-unit>
        <trans-unit id="a3b4acf36ca74c434adb6226f16d93f351b2c3d1" translate="yes" xml:space="preserve">
          <source>A trait was implemented on another which already automatically implemented it.</source>
          <target state="translated">すでに自動的に実装されている別のものに形質が実装されていました。</target>
        </trans-unit>
        <trans-unit id="1af6d624d68ca3ca313d81ebc03c7ca717454c50" translate="yes" xml:space="preserve">
          <source>A transparent struct, enum, or union is supposed to be represented exactly like the piece of data it contains. Zero-sized fields with different alignment requirements potentially conflict with this property. In the example above, &lt;code&gt;Wrapper&lt;/code&gt; would have to be aligned to 32 bytes even though &lt;code&gt;f32&lt;/code&gt; has a smaller alignment requirement.</source>
          <target state="translated">透明な構造体、列挙型、または共用体は、含まれているデータとまったく同じように表現されることになっています。配置要件が異なるサイズがゼロのフィールドは、このプロパティと競合する可能性があります。上記の例では、 &lt;code&gt;f32&lt;/code&gt; の配置要件が小さい場合でも、 &lt;code&gt;Wrapper&lt;/code&gt; を32バイトに配置する必要があります。</target>
        </trans-unit>
        <trans-unit id="490336a5e305f2d2e8d1363f03a6314c497a78fa" translate="yes" xml:space="preserve">
          <source>A tricky example, with sigma:</source>
          <target state="translated">シグマを使ったトリッキーな例。</target>
        </trans-unit>
        <trans-unit id="2d6e480d45ae2d8d8e393f568dbe81e3240a2b6b" translate="yes" xml:space="preserve">
          <source>A trivial example of the usage of &lt;code&gt;bool&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; の使い方の簡単な例、</target>
        </trans-unit>
        <trans-unit id="26204199326019f143410da0c8e1f31498a99258" translate="yes" xml:space="preserve">
          <source>A tuple &lt;em&gt;type&lt;/em&gt; is a heterogeneous product of other types, called the &lt;em&gt;elements&lt;/em&gt; of the tuple. It has no nominal name and is instead structurally typed.</source>
          <target state="translated">タプル&lt;em&gt;型&lt;/em&gt;は、タプルの&lt;em&gt;要素&lt;/em&gt;と呼ばれる他の型の異種製品です。名義はなく、構造的に型付けされています。</target>
        </trans-unit>
        <trans-unit id="e9dbb3e94f53ac8e3a8ca087dfd88ec94acc48f5" translate="yes" xml:space="preserve">
          <source>A tuple index is used to refer to the fields of &lt;a href=&quot;types/tuple&quot;&gt;tuples&lt;/a&gt;, &lt;a href=&quot;items/structs&quot;&gt;tuple structs&lt;/a&gt;, and &lt;a href=&quot;items/enumerations&quot;&gt;tuple variants&lt;/a&gt;.</source>
          <target state="translated">タプルインデックスは、&lt;a href=&quot;types/tuple&quot;&gt;タプル&lt;/a&gt;、&lt;a href=&quot;items/structs&quot;&gt;タプル構造体&lt;/a&gt;、および&lt;a href=&quot;items/enumerations&quot;&gt;タプルバリアント&lt;/a&gt;のフィールドを参照するために使用されます。</target>
        </trans-unit>
        <trans-unit id="7b0541e4cbc97c5e40f947c03ae1731aeaba596f" translate="yes" xml:space="preserve">
          <source>A tuple is a general way of grouping together a number of values with a variety of types into one compound type. Tuples have a fixed length: once declared, they cannot grow or shrink in size.</source>
          <target state="translated">タプルは、さまざまな型を持つ複数の値を1つの複合型にまとめる一般的な方法です。タプルは長さが固定されており、一度宣言するとサイズが大きくなったり小さくなったりすることはありません。</target>
        </trans-unit>
        <trans-unit id="402bd39bb6c42541595f5aba7871ff88c655396e" translate="yes" xml:space="preserve">
          <source>A tuple is a general way of grouping together some number of other values with a variety of types into one compound type. Tuples have a fixed length: once declared, they cannot grow or shrink in size.</source>
          <target state="translated">タプルは、さまざまな型を持つ他の値を1つの複合型にまとめる一般的な方法です。タプルは長さが固定されており、一度宣言するとサイズが大きくなったり小さくなったりすることはありません。</target>
        </trans-unit>
        <trans-unit id="8d3a96e70924f2a82e85cf6036b452ac805c64ec" translate="yes" xml:space="preserve">
          <source>A tuple struct or tuple variant was used in a pattern as if it were a struct or struct variant.</source>
          <target state="translated">タプル構造体やタプルバリアントが、あたかも構造体や構造体バリアントであるかのようにパターン内で使用されていました。</target>
        </trans-unit>
        <trans-unit id="1696a724c358dd0091f73a52db83c7a8082d2750" translate="yes" xml:space="preserve">
          <source>A tuple struct pattern is refutable when one of its subpatterns is refutable.</source>
          <target state="translated">タプル構造体パターンは、そのサブパターンの1つが再可換可能な場合に再可換可能となります。</target>
        </trans-unit>
        <trans-unit id="8f5d8407de99f6165aaf419c7f8aaf0ecf33a5a2" translate="yes" xml:space="preserve">
          <source>A tuple struct's element isn't a machine type when using the &lt;code&gt;#[simd]&lt;/code&gt; attribute.</source>
          <target state="translated">&lt;code&gt;#[simd]&lt;/code&gt; 属性を使用する場合、タプル構造体の要素はマシンタイプではありません。</target>
        </trans-unit>
        <trans-unit id="63c229f3f830c234653affc74d3c7117a6730da6" translate="yes" xml:space="preserve">
          <source>A type alias for &lt;a href=&quot;../convert/enum.infallible&quot;&gt;&lt;code&gt;Infallible&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../convert/enum.infallible&quot;&gt; &lt;code&gt;Infallible&lt;/code&gt; の&lt;/a&gt;タイプエイリアス。</target>
        </trans-unit>
        <trans-unit id="1009527a15bba1ad137f4f63c037795bd4a2bfe2" translate="yes" xml:space="preserve">
          <source>A type alias for the result of a lock method which can be poisoned.</source>
          <target state="translated">ポイズンされる可能性のあるロックメソッドの結果の型のエイリアス。</target>
        </trans-unit>
        <trans-unit id="aae3cf8f6eb9071486813bec542109175b1464e5" translate="yes" xml:space="preserve">
          <source>A type alias for the result of a nonblocking locking method.</source>
          <target state="translated">ノンブロッキング・ロック・メソッドの結果の型のエイリアス。</target>
        </trans-unit>
        <trans-unit id="811e3fb59c28acd0a23a2498fc25dd5079b4be0d" translate="yes" xml:space="preserve">
          <source>A type alias makes this code more manageable by reducing the repetition. In Listing 19-25, we&amp;rsquo;ve introduced an alias named &lt;code&gt;Thunk&lt;/code&gt; for the verbose type and can replace all uses of the type with the shorter alias &lt;code&gt;Thunk&lt;/code&gt;.</source>
          <target state="translated">型エイリアスを使用すると、繰り返しを減らすことでこのコードを管理しやすくなります。リスト19-25では、詳細なタイプのために &lt;code&gt;Thunk&lt;/code&gt; という名前のエイリアスを導入し、タイプのすべての使用をより短いエイリアスで置き換えることができます。 &lt;code&gt;Thunk&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="4e38a79e72762fd78e402d5747ab629fd9e3cf95" translate="yes" xml:space="preserve">
          <source>A type alias to a tuple-struct or unit-struct cannot be used to qualify that type's constructor:</source>
          <target state="translated">タプル構造体やユニット構造体への型のエイリアスは、その型のコンストラクタを修飾するためには使用できません。</target>
        </trans-unit>
        <trans-unit id="872091a52699e1a821b52be55e9443115016332c" translate="yes" xml:space="preserve">
          <source>A type alias to an enum type cannot be used to qualify the constructors:</source>
          <target state="translated">enum 型への型のエイリアスは、コンストラクタを修飾するためには使用できません。</target>
        </trans-unit>
        <trans-unit id="9e407e83d82ec15858c1c29f981a47a04ebb8636" translate="yes" xml:space="preserve">
          <source>A type annotated as &lt;code&gt;repr(transparent)&lt;/code&gt; delegates all representation concerns to another type, so adding more representation hints is contradictory. Remove either the &lt;code&gt;transparent&lt;/code&gt; hint or the other hints, like this:</source>
          <target state="translated">&lt;code&gt;repr(transparent)&lt;/code&gt; として注釈が付けられた型は、すべての表現の懸念を別の型に委譲するため、表現のヒントを追加することは矛盾します。いずれかを削除します &lt;code&gt;transparent&lt;/code&gt; ヒントまたは他のヒントを。</target>
        </trans-unit>
        <trans-unit id="cb5e8aa2faa836eb0e6e33148484b741b2f52f31" translate="yes" xml:space="preserve">
          <source>A type can also have multiple inherent implementations. An implementing type must be defined within the same crate as the original type definition.</source>
          <target state="translated">型は複数の固有の実装を持つこともできます。実装型は、元の型定義と同じ木枠内で定義されなければなりません。</target>
        </trans-unit>
        <trans-unit id="ec397cd955b41db47c056843b89f1c979b1499b9" translate="yes" xml:space="preserve">
          <source>A type can implement &lt;code&gt;Copy&lt;/code&gt; if all of its components implement &lt;code&gt;Copy&lt;/code&gt;. For example, this struct can be &lt;code&gt;Copy&lt;/code&gt;:</source>
          <target state="translated">タイプは、実装することができます &lt;code&gt;Copy&lt;/code&gt; そのすべてのコンポーネントが実装する場合は &lt;code&gt;Copy&lt;/code&gt; 。たとえば、この構造体は &lt;code&gt;Copy&lt;/code&gt; に。</target>
        </trans-unit>
        <trans-unit id="a1e5e79c85877ceec782fbfaa18c2c4e5b9b2282" translate="yes" xml:space="preserve">
          <source>A type cast expression is denoted with the binary operator &lt;code&gt;as&lt;/code&gt;.</source>
          <target state="translated">型キャスト式は二項演算子で示されます &lt;code&gt;as&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="2b97b41bd9c7eae77d5c3b940d4a5832d7e972fb" translate="yes" xml:space="preserve">
          <source>A type dependency cycle has been encountered.</source>
          <target state="translated">型依存サイクルが発生しました。</target>
        </trans-unit>
        <trans-unit id="2904374f2c0e91251791d02f72bd6378c8bccc80" translate="yes" xml:space="preserve">
          <source>A type has both &lt;code&gt;packed&lt;/code&gt; and &lt;code&gt;align&lt;/code&gt; representation hints.</source>
          <target state="translated">タイプには、 &lt;code&gt;packed&lt;/code&gt; 表現と &lt;code&gt;align&lt;/code&gt; 表現の両方のヒントがあります。</target>
        </trans-unit>
        <trans-unit id="77f0b7a28b6f2753f1d76d09de19c12454b7888f" translate="yes" xml:space="preserve">
          <source>A type has conflicting &lt;code&gt;packed&lt;/code&gt; representation hints.</source>
          <target state="translated">タイプに競合する &lt;code&gt;packed&lt;/code&gt; 表現ヒントがあります。</target>
        </trans-unit>
        <trans-unit id="995f457de088e34d1af6ab0e7cbed95033f1f938" translate="yes" xml:space="preserve">
          <source>A type implementing &lt;code&gt;Try&lt;/code&gt; is one that has a canonical way to view it in terms of a success/failure dichotomy. This trait allows both extracting those success or failure values from an existing instance and creating a new instance from a success or failure value.</source>
          <target state="translated">実装するタイプ &lt;code&gt;Try&lt;/code&gt; をは、成功/失敗の二分法に関してそれを表示するための標準的な方法を持つです。この特性により、既存のインスタンスから成功または失敗の値を抽出することと、成功または失敗の値から新しいインスタンスを作成することができます。</target>
        </trans-unit>
        <trans-unit id="f5199d6683f66f6377d3e5c541ab1e1a45f0a440" translate="yes" xml:space="preserve">
          <source>A type indicating whether a timed wait on a condition variable returned due to a time out or not.</source>
          <target state="translated">タイムアウトにより条件変数の時限待ちが返されたかどうかを示す型。</target>
        </trans-unit>
        <trans-unit id="bcb42c5f4b4345c9c33893996e574612ab86b0f7" translate="yes" xml:space="preserve">
          <source>A type is inhabited if it has constructors and therefore can be instantiated. An inhabited type is not &quot;empty&quot; in the sense that there can be values of the type. Opposite of &lt;a href=&quot;#uninhabited&quot;&gt;Uninhabited&lt;/a&gt;.</source>
          <target state="translated">型にはコンストラクターがある場合に存在するため、インスタンス化できます。居住型は、その型の値が存在する可能性があるという意味で「空」ではありません。&lt;a href=&quot;#uninhabited&quot;&gt;無人の&lt;/a&gt;反対。</target>
        </trans-unit>
        <trans-unit id="61c125cceb1922063b5ac33f0666ef79257f43a2" translate="yes" xml:space="preserve">
          <source>A type is uninhabited if it has no constructors and therefore can never be instantiated. An uninhabited type is &quot;empty&quot; in the sense that there are no values of the type. The canonical example of an uninhabited type is the &lt;a href=&quot;types/never&quot;&gt;never type&lt;/a&gt;&lt;code&gt;!&lt;/code&gt;, or an enum with no variants &lt;code&gt;enum Never { }&lt;/code&gt;. Opposite of &lt;a href=&quot;#inhabited&quot;&gt;Inhabited&lt;/a&gt;.</source>
          <target state="translated">コンストラクターがないため、インスタンス化できないタイプは無人です。無人のタイプは、タイプの値がないという意味で「空」です。無人型の標準的な例は、&lt;a href=&quot;types/never&quot;&gt;never型&lt;/a&gt; &lt;code&gt;!&lt;/code&gt; 、またはバリアントのない &lt;code&gt;enum Never { }&lt;/code&gt; 型enum Never {}。人が&lt;a href=&quot;#inhabited&quot;&gt;住んで&lt;/a&gt;いるの反対。</target>
        </trans-unit>
        <trans-unit id="d3666c5137a8c2f5bd25b41e59026d010547814d" translate="yes" xml:space="preserve">
          <source>A type mismatched an associated type of a trait.</source>
          <target state="translated">形質の関連する型と不一致した型。</target>
        </trans-unit>
        <trans-unit id="195d3e2324eafc4b95d0787028892dc2ce75ef57" translate="yes" xml:space="preserve">
          <source>A type of error which can be returned whenever a lock is acquired.</source>
          <target state="translated">ロックを取得したときに必ず返すことができるエラーの種類。</target>
        </trans-unit>
        <trans-unit id="e09ee31e80fe4ed67d90fe93645d23ccc6bd8f11" translate="yes" xml:space="preserve">
          <source>A type or lifetime parameter has been declared but is not actually used.</source>
          <target state="translated">型またはライフタイムパラメータが宣言されていますが、実際には使用されていません。</target>
        </trans-unit>
        <trans-unit id="c7fb190bd9cd84e642f9c437ffcc3a0470b68cd6" translate="yes" xml:space="preserve">
          <source>A type or module has been defined more than once.</source>
          <target state="translated">型またはモジュールが複数回定義されている。</target>
        </trans-unit>
        <trans-unit id="630bff58f7c530334c09b287d02fb5f603530515" translate="yes" xml:space="preserve">
          <source>A type parameter that is specified for &lt;code&gt;impl&lt;/code&gt; is not constrained.</source>
          <target state="translated">&lt;code&gt;impl&lt;/code&gt; に指定された型パラメーターは制約されません。</target>
        </trans-unit>
        <trans-unit id="7a60e8550db7fb8bf181c3c2af427df857c9bf7d" translate="yes" xml:space="preserve">
          <source>A type parameter was declared which shadows an existing one. An example of this error:</source>
          <target state="translated">既存のパラメータの影になる型パラメータが宣言されました。このエラーの例です。</target>
        </trans-unit>
        <trans-unit id="0e1d3a1b69ee90016db302de62e4dd15a2f4ff16" translate="yes" xml:space="preserve">
          <source>A type parameter which references &lt;code&gt;Self&lt;/code&gt; in its default value was not specified.</source>
          <target state="translated">デフォルト値で &lt;code&gt;Self&lt;/code&gt; を参照する型パラメーターが指定されていません。</target>
        </trans-unit>
        <trans-unit id="25fe9cd48afec311fa3f403a24aafba6272aeca5" translate="yes" xml:space="preserve">
          <source>A type parameter which references &lt;code&gt;Self&lt;/code&gt; in its default value was not specified. Example of erroneous code:</source>
          <target state="translated">&lt;code&gt;Self&lt;/code&gt; を参照する型パラメーターデフォルト値で指定されていません。誤ったコードの例：</target>
        </trans-unit>
        <trans-unit id="5ff8db748ed5eaad6145c2ecc683c1493e2ac732" translate="yes" xml:space="preserve">
          <source>A type parameter with default value is using forward declared identifier.</source>
          <target state="translated">デフォルト値のtypeパラメータは、前方宣言された識別子を使用しています。</target>
        </trans-unit>
        <trans-unit id="7d790d10f882d09d23c776016863815c5b3e2b81" translate="yes" xml:space="preserve">
          <source>A type representing an owned, C-compatible, nul-terminated string with no nul bytes in the middle.</source>
          <target state="translated">所有されている、C互換のヌル終端文字列を表す型で、途中にヌルバイトを含まない。</target>
        </trans-unit>
        <trans-unit id="b3b99d63ae795914f8001d38731a170b595e6b2b" translate="yes" xml:space="preserve">
          <source>A type that can be any one of several variants.</source>
          <target state="translated">いくつかのバリエーションのいずれかになるタイプ。</target>
        </trans-unit>
        <trans-unit id="090b303bdd4057540547275158d9e42939d01cec" translate="yes" xml:space="preserve">
          <source>A type that can represent owned, mutable platform-native strings, but is cheaply inter-convertible with Rust strings.</source>
          <target state="translated">プラットフォームネイティブの文字列を表現することができますが、Rustの文字列と安価に相互変換可能な型です。</target>
        </trans-unit>
        <trans-unit id="220ecc56d2012059c1d8cd78943adf0ed8ed7d8e" translate="yes" xml:space="preserve">
          <source>A type that is composed of other types.</source>
          <target state="translated">他の型で構成されている型。</target>
        </trans-unit>
        <trans-unit id="0a851afebbaf8a3f378080846c51bf756d8476cc" translate="yes" xml:space="preserve">
          <source>A type that is not a trait was used in a trait position, such as a bound or &lt;code&gt;impl&lt;/code&gt;.</source>
          <target state="translated">特性ではないタイプが、boundや &lt;code&gt;impl&lt;/code&gt; などの特性位置で使用されました。</target>
        </trans-unit>
        <trans-unit id="48dabc713e66c06bf48c0ba95cf5b1b2867095db" translate="yes" xml:space="preserve">
          <source>A type to emulate dynamic typing.</source>
          <target state="translated">動的型付けをエミュレートするための型。</target>
        </trans-unit>
        <trans-unit id="18995bad7092858c6b32d35a26167b88faf2e216" translate="yes" xml:space="preserve">
          <source>A type used to conditionally initialize buffers passed to &lt;code&gt;Read&lt;/code&gt; methods.</source>
          <target state="translated">&lt;code&gt;Read&lt;/code&gt; に渡されるバッファを条件付きで初期化するために使用されるタイプメソッドに。</target>
        </trans-unit>
        <trans-unit id="8a527d3dadad04c815571442c7e455c6295d0179" translate="yes" xml:space="preserve">
          <source>A type which does not appear as an argument to another type. For example, &lt;code&gt;T&lt;/code&gt; is uncovered, but the &lt;code&gt;T&lt;/code&gt; in &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; is covered. This is only relevant for type arguments.</source>
          <target state="translated">別のタイプへの引数として表示されないタイプ。例えば、 &lt;code&gt;T&lt;/code&gt; が発見されているが、 &lt;code&gt;T&lt;/code&gt; で &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 覆われています。これは、型引数にのみ関係します。</target>
        </trans-unit>
        <trans-unit id="48a3662dff4bc918fde00d869523d6a4f45ec09b" translate="yes" xml:space="preserve">
          <source>A type with &lt;code&gt;packed&lt;/code&gt; representation hint has a field with &lt;code&gt;align&lt;/code&gt; representation hint.</source>
          <target state="translated">&lt;code&gt;packed&lt;/code&gt; 表現ヒントを持つタイプには、 &lt;code&gt;align&lt;/code&gt; 表現ヒントを持つフィールドがあります。</target>
        </trans-unit>
        <trans-unit id="f40b2b31a159196f4517607c9d76ab5a80f0274d" translate="yes" xml:space="preserve">
          <source>A type&amp;rsquo;s behavior consists of the methods we can call on that type. Different types share the same behavior if we can call the same methods on all of those types. Trait definitions are a way to group method signatures together to define a set of behaviors necessary to accomplish some purpose.</source>
          <target state="translated">型の動作は、その型に対して呼び出すことができるメソッドで構成されています。これらのすべての型で同じメソッドを呼び出すことができる場合、異なる型は同じ動作を共有します。特性定義は、メソッドシグネチャをグループ化して、目的を達成するために必要な一連の動作を定義する方法です。</target>
        </trans-unit>
        <trans-unit id="3b6ddcc149faf5698a16d1a853b87785df3d76f9" translate="yes" xml:space="preserve">
          <source>A union access transmutes the content of the union to the type of the accessed field. Since transmutes can cause unexpected or undefined behaviour, &lt;code&gt;unsafe&lt;/code&gt; is required to read from a union field or to write to a field that doesn't implement &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">共用体アクセスは、共用体の内容をアクセスされたフィールドのタイプに変換します。変換は予期しない動作または未定義の動作を引き起こす可能性があるため、unionフィールドから読み取るか、&lt;a href=&quot;../special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; を&lt;/a&gt;実装していないフィールドに書き込むには、 &lt;code&gt;unsafe&lt;/code&gt; が必要です。</target>
        </trans-unit>
        <trans-unit id="5466b2051b7ddfaa4d58e8a7c5e165f16f139371" translate="yes" xml:space="preserve">
          <source>A union declaration uses the same syntax as a struct declaration, except with &lt;code&gt;union&lt;/code&gt; in place of &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="translated">労働組合宣言はを除いて、構造体の宣言と同じ構文を使用して &lt;code&gt;union&lt;/code&gt; の代わりに &lt;code&gt;struct&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ca484ccd859cf11dbaf1461b26fb4e6e0c1155bd" translate="yes" xml:space="preserve">
          <source>A union declared with &lt;code&gt;#[repr(C)]&lt;/code&gt; will have the same size and alignment as an equivalent C union declaration in the C language for the target platform. The union will have a size of the maximum size of all of its fields rounded to its alignment, and an alignment of the maximum alignment of all of its fields. These maximums may come from different fields.</source>
          <target state="translated">&lt;code&gt;#[repr(C)]&lt;/code&gt; で宣言された共用体ターゲットプラットフォーム用のC言語における等価C組合宣言と同じサイズと配向を有するであろう。ユニオンのサイズは、そのすべてのフィールドの最大サイズのサイズに合わせて丸められ、そのすべてのフィールドの最大サイズの位置合わせになります。これらの最大値は、さまざまなフィールドから取得される場合があります。</target>
        </trans-unit>
        <trans-unit id="a5f776fff8bd64de524df1b33719d9e03226007b" translate="yes" xml:space="preserve">
          <source>A unique identifier for a running thread.</source>
          <target state="translated">実行中のスレッドの一意の識別子。</target>
        </trans-unit>
        <trans-unit id="10b778820b33fd4a7dd6fe5ae783d38d25f8f4be" translate="yes" xml:space="preserve">
          <source>A unit struct expression is just the path to a unit struct item. This refers to the unit struct's implicit constant of its value. The unit struct value can also be constructed with a fieldless struct expression. For example:</source>
          <target state="translated">ユニット構造体の式は、ユニット構造体の項目へのパスにすぎません。これは、ユニット構造体の値の暗黙の定数を指します。単位構造体の値は、フィールドレス構造体式で構築することもできます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="e1ccfef1f9d17695dcb29cad8794e8d363ce8a2b" translate="yes" xml:space="preserve">
          <source>A unrecognized representation attribute was used.</source>
          <target state="translated">認識されていない表現属性が使用されていました。</target>
        </trans-unit>
        <trans-unit id="5b4c71cc75880bc2daa87d6294e45d4e462f56c4" translate="yes" xml:space="preserve">
          <source>A used type name is not in scope.</source>
          <target state="translated">使用済みの型名は対象外です。</target>
        </trans-unit>
        <trans-unit id="bb363e92161ec8a647cc462201572019f30fe79b" translate="yes" xml:space="preserve">
          <source>A vacant entry.</source>
          <target state="translated">空きエントリー。</target>
        </trans-unit>
        <trans-unit id="ac311baab6584071250fc9bbbfdd8d2bebd0c9e9" translate="yes" xml:space="preserve">
          <source>A value in a &lt;code&gt;char&lt;/code&gt; which is a surrogate or above &lt;code&gt;char::MAX&lt;/code&gt;.</source>
          <target state="translated">値 &lt;code&gt;char&lt;/code&gt; サロゲート以上である &lt;code&gt;char::MAX&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0cd18e9d0df56f2d91218b99bcfa24832cc2e846" translate="yes" xml:space="preserve">
          <source>A value of a &lt;a href=&quot;../items/unions&quot;&gt;union&lt;/a&gt; type can also be created using this syntax, except that it must specify exactly one field.</source>
          <target state="translated">&lt;a href=&quot;../items/unions&quot;&gt;労働組合の&lt;/a&gt;価値タイプのこの構文を使用して作成することもできますが、フィールドを1つだけ指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="9f77849f445f82a7dac2f95551cd7b942f343391" translate="yes" xml:space="preserve">
          <source>A value of a union type can be created using the same syntax that is used for struct types, except that it must specify exactly one field:</source>
          <target state="translated">ユニオン型の値は、構造体型に使用されるのと同じ構文を使用して作成することができますが、正確に 1 つのフィールドを指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="2edc0a57205327b0c616a8834c05686bc2cd3aab" translate="yes" xml:space="preserve">
          <source>A value of type &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.bool.html&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt; representing logical &lt;strong&gt;false&lt;/strong&gt;.</source>
          <target state="translated">論理&lt;strong&gt;falseを&lt;/strong&gt;表す&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.bool.html&quot;&gt; &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt;型の値。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7083e77e4fd9ce896b8de61f936c4776bbf66b89" translate="yes" xml:space="preserve">
          <source>A value of type &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.bool.html&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt; representing logical &lt;strong&gt;true&lt;/strong&gt;.</source>
          <target state="translated">論理&lt;strong&gt;trueを&lt;/strong&gt;表す&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.bool.html&quot;&gt; &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt;型の値。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c8dd18f78fe47645f4c465046226e5bceaa87924" translate="yes" xml:space="preserve">
          <source>A value of type &lt;a href=&quot;primitive.bool&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt; representing logical &lt;strong&gt;false&lt;/strong&gt;.</source>
          <target state="translated">論理&lt;strong&gt;falseを&lt;/strong&gt;表す&lt;a href=&quot;primitive.bool&quot;&gt; &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt;型の値&lt;strong&gt;&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="5f389328467f7ba3f2c3abda8662442b712ffb60" translate="yes" xml:space="preserve">
          <source>A value of type &lt;a href=&quot;primitive.bool&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt; representing logical &lt;strong&gt;true&lt;/strong&gt;.</source>
          <target state="translated">論理&lt;strong&gt;trueを&lt;/strong&gt;表す&lt;a href=&quot;primitive.bool&quot;&gt; &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt;型の値&lt;strong&gt;&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="b855bdd2c1132135fcde425660863334401f8ec6" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;char&lt;/code&gt; is a &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode scalar value&lt;/a&gt; (i.e. a code point that is not a surrogate), represented as a 32-bit unsigned word in the 0x0000 to 0xD7FF or 0xE000 to 0x10FFFF range. A &lt;code&gt;[char]&lt;/code&gt; is effectively a UCS-4 / UTF-32 string.</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; 型の値は、&lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicodeスカラー値&lt;/a&gt;（つまり、サロゲートではないコードポイント）であり、0x0000〜0xD7FFまたは0xE000〜0x10FFFFの範囲の32ビットの符号なしワードとして表されます。A &lt;code&gt;[char]&lt;/code&gt; 効果的にUCS-4 / UTF-32の文字列です。</target>
        </trans-unit>
        <trans-unit id="d1f3055da898f22398d4fbd4a38fa84ee1e65f98" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;char&lt;/code&gt; is a &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode scalar value&lt;/a&gt; (i.e. a code point that is not a surrogate), represented as a 32-bit unsigned word in the 0x0000 to 0xD7FF or 0xE000 to 0x10FFFF range. It is immediate &lt;a href=&quot;../behavior-considered-undefined&quot;&gt;Undefined Behavior&lt;/a&gt; to create a &lt;code&gt;char&lt;/code&gt; that falls outside this range. A &lt;code&gt;[char]&lt;/code&gt; is effectively a UCS-4 / UTF-32 string of length 1.</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; 型の値は、&lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicodeスカラー値&lt;/a&gt;（つまり、サロゲートではないコードポイント）であり、0x0000〜0xD7FFまたは0xE000〜0x10FFFFの範囲の32ビット符号なしワードとして表されます。この範囲外の &lt;code&gt;char&lt;/code&gt; を作成することは、即時の&lt;a href=&quot;../behavior-considered-undefined&quot;&gt;未定義の動作&lt;/a&gt;です。 &lt;code&gt;[char]&lt;/code&gt; 効果的に長さ1のUCS-4 / UTF-32の文字列です。</target>
        </trans-unit>
        <trans-unit id="59d76a5d3d80327c3f37cdc56ddfd9ab850292ae" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;str&lt;/code&gt; is a Unicode string, represented as an array of 8-bit unsigned bytes holding a sequence of UTF-8 code points. Since &lt;code&gt;str&lt;/code&gt; is a &lt;a href=&quot;../dynamically-sized-types&quot;&gt;dynamically sized type&lt;/a&gt;, it is not a &lt;em&gt;first-class&lt;/em&gt; type, but can only be instantiated through a pointer type, such as &lt;code&gt;&amp;amp;str&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 型の値はUnicode文字列であり、UTF-8コードポイントのシーケンスを保持する8ビットの符号なしバイトの配列として表されます。以来 &lt;code&gt;str&lt;/code&gt; がある&lt;a href=&quot;../dynamically-sized-types&quot;&gt;動的にサイズタイプ&lt;/a&gt;、そうではない&lt;em&gt;最初のクラスの&lt;/em&gt;型が、唯一のような、ポインタ型を介してインスタンス化することができる &lt;code&gt;&amp;amp;str&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bbb241cb793b74334bb4ee4c800e211086ca2124" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;str&lt;/code&gt; is represented the same way as &lt;code&gt;[u8]&lt;/code&gt;, it is a slice of 8-bit unsigned bytes. However, the Rust standard library makes extra assumptions about &lt;code&gt;str&lt;/code&gt;: methods working on &lt;code&gt;str&lt;/code&gt; assume and ensure that the data in there is valid UTF-8. Calling a &lt;code&gt;str&lt;/code&gt; method with a non-UTF-8 buffer can cause &lt;a href=&quot;../behavior-considered-undefined&quot;&gt;Undefined Behavior&lt;/a&gt; now or in the future.</source>
          <target state="translated">タイプ &lt;code&gt;str&lt;/code&gt; の値は、 &lt;code&gt;[u8]&lt;/code&gt; と同じ方法で表され、8ビットの符号なしバイトのスライスです。ただし、Rust標準ライブラリは &lt;code&gt;str&lt;/code&gt; について追加の仮定を行い &lt;code&gt;str&lt;/code&gt; 動作するメソッドは、そこにあるデータが有効なUTF-8であることを仮定して保証します。非UTF-8バッファを使用して &lt;code&gt;str&lt;/code&gt; メソッドを呼び出すと、現在または将来、&lt;a href=&quot;../behavior-considered-undefined&quot;&gt;未定義の動作&lt;/a&gt;が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="a63b20136e367659035b6e689b2afe4c29bd6017" translate="yes" xml:space="preserve">
          <source>A value other than &lt;code&gt;false&lt;/code&gt; (&lt;code&gt;0&lt;/code&gt;) or &lt;code&gt;true&lt;/code&gt; (&lt;code&gt;1&lt;/code&gt;) in a &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; &lt;code&gt;false&lt;/code&gt; （ &lt;code&gt;0&lt;/code&gt; ）または &lt;code&gt;true&lt;/code&gt; （ &lt;code&gt;1&lt;/code&gt; ）以外の値。</target>
        </trans-unit>
        <trans-unit id="b4cba545fd19cda1128ffaf1d3286b9b7d56cde6" translate="yes" xml:space="preserve">
          <source>A value was moved out of a non-copy fixed-size array.</source>
          <target state="translated">値がコピーされていない固定サイズの配列から移動されました。</target>
        </trans-unit>
        <trans-unit id="b42cffab7e9c15b342f66d8f5259941653a63c96" translate="yes" xml:space="preserve">
          <source>A value was moved out while it was still borrowed.</source>
          <target state="translated">借りたままの状態で値が動いた。</target>
        </trans-unit>
        <trans-unit id="82027756f29be28c79aeae3975a5766aa1d2efa8" translate="yes" xml:space="preserve">
          <source>A value was moved whose size was not known at compile time.</source>
          <target state="translated">コンパイル時にサイズがわからない値が移動されました。</target>
        </trans-unit>
        <trans-unit id="9706341e2da60c066ce6e7cf05178b38f120d103" translate="yes" xml:space="preserve">
          <source>A value was moved. However, its size was not known at compile time, and only values of a known size can be moved.</source>
          <target state="translated">値が移動されました。しかし、コンパイル時にそのサイズがわからなかったため、既知のサイズの値しか移動できません。</target>
        </trans-unit>
        <trans-unit id="44837e659d57e9e8963db42f2a8ff432184c868b" translate="yes" xml:space="preserve">
          <source>A value was used after it was mutably borrowed.</source>
          <target state="translated">値は変異的に借りた後に使用されました。</target>
        </trans-unit>
        <trans-unit id="0a9fd9c77be9db665eaa8aa09f7c11046598c96c" translate="yes" xml:space="preserve">
          <source>A value with a custom &lt;code&gt;Drop&lt;/code&gt; implementation may be dropped during const-eval.</source>
          <target state="translated">カスタム &lt;code&gt;Drop&lt;/code&gt; 実装の値は、const-eval中にドロップされる場合があります。</target>
        </trans-unit>
        <trans-unit id="ce9baf105eb065b4e2e707a1c70964d52846271c" translate="yes" xml:space="preserve">
          <source>A value, once pinned, must remain pinned forever (unless its type implements &lt;code&gt;Unpin&lt;/code&gt;).</source>
          <target state="translated">固定された値は、その型が &lt;code&gt;Unpin&lt;/code&gt; を実装しない限り、永久に固定されたままである必要があります。</target>
        </trans-unit>
        <trans-unit id="f834afc88c6404de279c7c8f515cfb4300b16ac9" translate="yes" xml:space="preserve">
          <source>A value-to-value conversion that consumes the input value. The opposite of &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">入力値を使用する値から値への変換。&lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt;の反対。</target>
        </trans-unit>
        <trans-unit id="0ec26c2f12c942e7a95c50dd2e23886df77a4d3b" translate="yes" xml:space="preserve">
          <source>A variable already borrowed as immutable was borrowed as mutable.</source>
          <target state="translated">すでに不変として借りていた変数は、変異可能として借りていました。</target>
        </trans-unit>
        <trans-unit id="e13d6f0eba74b4bdfc6f5572578b32920b145941" translate="yes" xml:space="preserve">
          <source>A variable is initialized if it has been assigned a value and hasn't since been moved from. All other memory locations are assumed to be uninitialized. Only unsafe Rust can create such a memory without initializing it.</source>
          <target state="translated">変数に値が代入されていて、それが移動されていない場合は初期化されます。他のすべてのメモリ位置は、初期化されていないものとみなされます。このようなメモリを初期化せずに作成できるのは、安全ではない Rust だけです。</target>
        </trans-unit>
        <trans-unit id="bcb706d6a23f6a1ef0d6e932c9012ea02de89d1f" translate="yes" xml:space="preserve">
          <source>A variable used inside an inner function comes from a dynamic environment.</source>
          <target state="translated">内部関数内で使用される変数は、動的環境から来ています。</target>
        </trans-unit>
        <trans-unit id="624b6ee4bba7ea4936aac9cd4851655dde5b7367" translate="yes" xml:space="preserve">
          <source>A variable was borrowed as mutable more than once.</source>
          <target state="translated">変数は複数回変異可能なものとして借用されていました。</target>
        </trans-unit>
        <trans-unit id="d671f0302da4834f34c2a582f5308578a61da28e" translate="yes" xml:space="preserve">
          <source>A variable was borrowed as mutable more than once. Erroneous code example:</source>
          <target state="translated">変数が複数回 mutable として借用されていました。誤ったコード例。</target>
        </trans-unit>
        <trans-unit id="8f68dfea86962d0e6496e5ee7e7ba76db7429014" translate="yes" xml:space="preserve">
          <source>A variable was used after its contents have been moved elsewhere.</source>
          <target state="translated">変数の内容が他の場所に移動された後に使用されました。</target>
        </trans-unit>
        <trans-unit id="7373f15283d19d70ccdc1ebdabd671b6fa35a616" translate="yes" xml:space="preserve">
          <source>A variable which requires unique access is being used in more than one closure at the same time.</source>
          <target state="translated">一意なアクセスを必要とする変数が、同時に複数のクロージャで使用されています。</target>
        </trans-unit>
        <trans-unit id="179ae2668e7ec007982c4f5de54552aaba759982" translate="yes" xml:space="preserve">
          <source>A very common source of input is standard input:</source>
          <target state="translated">非常に一般的な入力源は標準入力です。</target>
        </trans-unit>
        <trans-unit id="8fd033d78acbcd4754d1027990e8d5a9b9826bd0" translate="yes" xml:space="preserve">
          <source>A very simple implementation of a &lt;code&gt;Balance&lt;/code&gt; struct that has two sides, where each can be indexed mutably and immutably.</source>
          <target state="translated">&lt;code&gt;Balance&lt;/code&gt; 非常にシンプルな実装2つのサイドを持つ構造体のそれぞれに変更可能で不変のインデックスを付けることができます。</target>
        </trans-unit>
        <trans-unit id="97a780f793593419e0ff592febcf6977a93355f0" translate="yes" xml:space="preserve">
          <source>A view into a single entry in a map, which may either be vacant or occupied.</source>
          <target state="translated">地図上の1つの項目のビューで、空席または占有されている場合があります。</target>
        </trans-unit>
        <trans-unit id="8b25993b294c4224a4cf2b72c86b09f4a1df51e2" translate="yes" xml:space="preserve">
          <source>A view into a vacant entry in a &lt;code&gt;BTreeMap&lt;/code&gt;. It is part of the &lt;a href=&quot;enum.entry&quot;&gt;&lt;code&gt;Entry&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="translated">&lt;code&gt;BTreeMap&lt;/code&gt; の空のエントリのビュー。これは&lt;a href=&quot;enum.entry&quot;&gt; &lt;code&gt;Entry&lt;/code&gt; &lt;/a&gt;列挙型の一部です。</target>
        </trans-unit>
        <trans-unit id="7403429e7fd780dc27d8a13d9952581d4b4e445e" translate="yes" xml:space="preserve">
          <source>A view into a vacant entry in a &lt;code&gt;HashMap&lt;/code&gt;. It is part of the &lt;a href=&quot;enum.entry&quot;&gt;&lt;code&gt;Entry&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; の空のエントリのビュー。これは&lt;a href=&quot;enum.entry&quot;&gt; &lt;code&gt;Entry&lt;/code&gt; &lt;/a&gt;列挙型の一部です。</target>
        </trans-unit>
        <trans-unit id="e122826d4e223005f70614b786e8ddc75140b027" translate="yes" xml:space="preserve">
          <source>A view into a vacant entry in a &lt;code&gt;HashMap&lt;/code&gt;. It is part of the &lt;a href=&quot;enum.rawentrymut&quot;&gt;&lt;code&gt;RawEntryMut&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; の空のエントリのビュー。&lt;a href=&quot;enum.rawentrymut&quot;&gt; &lt;code&gt;RawEntryMut&lt;/code&gt; &lt;/a&gt;列挙型の一部です。</target>
        </trans-unit>
        <trans-unit id="ce99b5e5cd3ea34b7d4c0f89a8831922c382a6d4" translate="yes" xml:space="preserve">
          <source>A view into an occupied entry in a &lt;code&gt;BTreeMap&lt;/code&gt;. It is part of the &lt;a href=&quot;enum.entry&quot;&gt;&lt;code&gt;Entry&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="translated">&lt;code&gt;BTreeMap&lt;/code&gt; 内の占有されたエントリのビュー。これは&lt;a href=&quot;enum.entry&quot;&gt; &lt;code&gt;Entry&lt;/code&gt; &lt;/a&gt;列挙型の一部です。</target>
        </trans-unit>
        <trans-unit id="be269036f18f5f092608a130f8ea68df4394d390" translate="yes" xml:space="preserve">
          <source>A view into an occupied entry in a &lt;code&gt;HashMap&lt;/code&gt;. It is part of the &lt;a href=&quot;enum.entry&quot;&gt;&lt;code&gt;Entry&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; で占有されているエントリのビュー。これは&lt;a href=&quot;enum.entry&quot;&gt; &lt;code&gt;Entry&lt;/code&gt; &lt;/a&gt;列挙型の一部です。</target>
        </trans-unit>
        <trans-unit id="097a52eaa6538170318bb496b2404a2534b2fc4c" translate="yes" xml:space="preserve">
          <source>A view into an occupied entry in a &lt;code&gt;HashMap&lt;/code&gt;. It is part of the &lt;a href=&quot;enum.rawentrymut&quot;&gt;&lt;code&gt;RawEntryMut&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 内の占有されたエントリのビュー。&lt;a href=&quot;enum.rawentrymut&quot;&gt; &lt;code&gt;RawEntryMut&lt;/code&gt; の&lt;/a&gt;一部です列挙型の。</target>
        </trans-unit>
        <trans-unit id="1dcb56819c21811e53111728b70cf9c4d536f34f" translate="yes" xml:space="preserve">
          <source>A virtual function pointer table (vtable) that specifies the behavior of a &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; の&lt;/a&gt;動作を指定する仮想関数ポインターテーブル（vtable）。</target>
        </trans-unit>
        <trans-unit id="9f3a191fe5eca1034f9485c5579c98bfcc0c4efc" translate="yes" xml:space="preserve">
          <source>A visibility qualifier was used when it was unnecessary.</source>
          <target state="translated">視認性のある修飾子は、不要な場合に使用されていました。</target>
        </trans-unit>
        <trans-unit id="ac7d35f82dab2d813057ea592ffddd469b64e834" translate="yes" xml:space="preserve">
          <source>A visibility qualifier was used when it was unnecessary. Erroneous code examples:</source>
          <target state="translated">不要なときに可視性修飾子が使用されていました。誤ったコード例。</target>
        </trans-unit>
        <trans-unit id="b3fc7b3827a6fcc8a59a000c786e3c02a55a53ac" translate="yes" xml:space="preserve">
          <source>A while-let pattern attempts to match the pattern, and enters the body if the match was successful. If the match is irrefutable (when it cannot fail to match), use a regular &lt;code&gt;let&lt;/code&gt;-binding inside a &lt;code&gt;loop&lt;/code&gt; instead. For instance:</source>
          <target state="translated">while-letパターンはパターンに一致しようとし、一致が成功した場合は本文に入ります。一致に反論できない場合（一致に失敗しない場合）、代わりに &lt;code&gt;loop&lt;/code&gt; 内で通常の &lt;code&gt;let&lt;/code&gt; バインディングを使用します。例えば：</target>
        </trans-unit>
        <trans-unit id="410ed7d62125fc62e5f4dca9f96376b96589d768" translate="yes" xml:space="preserve">
          <source>A windowed iterator over a slice in overlapping chunks (&lt;code&gt;N&lt;/code&gt; elements at a time), starting at the beginning of the slice</source>
          <target state="translated">スライスの先頭から開始して、重複するチャンク（一度に &lt;code&gt;N&lt;/code&gt; 個の要素）のスライス上のウィンドウ化されたイテレータ</target>
        </trans-unit>
        <trans-unit id="fc142166b026c4503335a66425ed02745d313757" translate="yes" xml:space="preserve">
          <source>A workaround for this problem is to wrap the trait up in a struct, and implement Drop on that. An example is shown below:</source>
          <target state="translated">この問題を回避するには、形質を struct でラップし、その上に Drop を実装する方法があります。以下に例を示します。</target>
        </trans-unit>
        <trans-unit id="f617743555e205f1a8f890d184cd3c23b7f7c1f7" translate="yes" xml:space="preserve">
          <source>A workaround for this problem is to wrap the trait up in a struct, and implement Drop on that:</source>
          <target state="translated">この問題の回避策は、形質を構造体で包み込み、その上に Drop を実装することです。</target>
        </trans-unit>
        <trans-unit id="2126e0b1e41989d782fb5cb045faec8bb5419d59" translate="yes" xml:space="preserve">
          <source>A working version would be:</source>
          <target state="translated">作業用のバージョンがあるだろう。</target>
        </trans-unit>
        <trans-unit id="0d662f80f6ce134ee94f8241854c8eb7d0a73167" translate="yes" xml:space="preserve">
          <source>A wrapper for a &lt;code&gt;va_list&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;va_list&lt;/code&gt; のラッパー</target>
        </trans-unit>
        <trans-unit id="b7d2953f481ad207e80e2b4f3ea38a3fc7fdbf37" translate="yes" xml:space="preserve">
          <source>A wrapper to inhibit compiler from automatically calling &lt;code&gt;T&lt;/code&gt;&amp;rsquo;s destructor.</source>
          <target state="translated">コンパイラが &lt;code&gt;T&lt;/code&gt; を自動的に呼び出すことを禁止するラッパーのデストラクタを。</target>
        </trans-unit>
        <trans-unit id="fd107425d645d1765a8fa8c1d57cb5b2986006a8" translate="yes" xml:space="preserve">
          <source>A wrapper to inhibit compiler from automatically calling &lt;code&gt;T&lt;/code&gt;&amp;rsquo;s destructor. This wrapper is 0-cost.</source>
          <target state="translated">コンパイラが &lt;code&gt;T&lt;/code&gt; のデストラクタを自動的に呼び出さないようにするラッパー。このラッパーは0コストです。</target>
        </trans-unit>
        <trans-unit id="27e603a9954cbc24a31a5ec5bf12ad7cbfb65091" translate="yes" xml:space="preserve">
          <source>A wrapper type for a mutably borrowed value from a &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; からの可変借用値のラッパータイプ。</target>
        </trans-unit>
        <trans-unit id="76e573ae156cec07995313b0af472777485c1ac4" translate="yes" xml:space="preserve">
          <source>A wrapper type to construct uninitialized instances of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; の初期化されていないインスタンスを構築するラッパータイプ。</target>
        </trans-unit>
        <trans-unit id="4e4e6894ffe01981313c8a0bdd641986bcbb13e0" translate="yes" xml:space="preserve">
          <source>A writer which will move data into the void.</source>
          <target state="translated">データを空虚な場所に移動させるライタ。</target>
        </trans-unit>
        <trans-unit id="3c1aa63d0f65966b349901d79576dfb3a03d713a" translate="yes" xml:space="preserve">
          <source>A yank &lt;em&gt;does not&lt;/em&gt; delete any code. For example, the yank feature is not intended for deleting accidentally uploaded secrets. If that happens, you must reset those secrets immediately.</source>
          <target state="translated">ヤンク&lt;em&gt;は&lt;/em&gt;コードを削除&lt;em&gt;しません&lt;/em&gt;。たとえば、ヤンク機能は誤ってアップロードされたシークレットを削除することを目的としていません。その場合は、これらのシークレットをすぐにリセットする必要があります。</target>
        </trans-unit>
        <trans-unit id="c0f586bae86592aff79f5cdbd80a984e38bc5729" translate="yes" xml:space="preserve">
          <source>A yield expression was used outside of the generator literal.</source>
          <target state="translated">ジェネレータリテラルの外で降伏式が使用されていました。</target>
        </trans-unit>
        <trans-unit id="441d954d4dd0146ecde4bbe0bfe1d8d54e840f8a" translate="yes" xml:space="preserve">
          <source>ABI</source>
          <target state="translated">ABI</target>
        </trans-unit>
        <trans-unit id="f7f4dbec39b0ff3d85b8eb96500c85b0c6447c9c" translate="yes" xml:space="preserve">
          <source>ABI, linking, symbols, and FFI</source>
          <target state="translated">ABI、リンク、シンボル、FFI</target>
        </trans-unit>
        <trans-unit id="623cb147c595ee00f55c9bfbece2fd89256c0ca0" translate="yes" xml:space="preserve">
          <source>ARCH</source>
          <target state="translated">ARCH</target>
        </trans-unit>
        <trans-unit id="ebb42dcc0b64c9c253b3563c217764b64d93cc3b" translate="yes" xml:space="preserve">
          <source>ARM platforms like &lt;code&gt;armv5te&lt;/code&gt; that aren't for Linux do not have any atomics at all.</source>
          <target state="translated">Linux用ではない &lt;code&gt;armv5te&lt;/code&gt; のようなARMプラットフォームには、アトミックがまったくありません。</target>
        </trans-unit>
        <trans-unit id="5d8a36ef8e4b107d52ef5f736828e510925b8177" translate="yes" xml:space="preserve">
          <source>ARM targets with &lt;code&gt;thumbv6m&lt;/code&gt; do not have atomic operations at all.</source>
          <target state="translated">&lt;code&gt;thumbv6m&lt;/code&gt; を備えた ARMターゲットには、アトミック操作はまったくありません。</target>
        </trans-unit>
        <trans-unit id="bb0279d84c9ab08002a8ea7634cd21f2283a6099" translate="yes" xml:space="preserve">
          <source>ASCII :</source>
          <target state="translated">アスキー .</target>
        </trans-unit>
        <trans-unit id="317e8901215d42ccc7940d34b4ce9490884463f7" translate="yes" xml:space="preserve">
          <source>ASCII byte literal</source>
          <target state="translated">アスキーバイトリテラル</target>
        </trans-unit>
        <trans-unit id="4d8ae89e872f4c2b2dd8feb9252c9a119be50b1e" translate="yes" xml:space="preserve">
          <source>ASCII escapes</source>
          <target state="translated">アスキーエスケープ</target>
        </trans-unit>
        <trans-unit id="ca370d4b69baa6a205bc27d7c92d683f7ec62f70" translate="yes" xml:space="preserve">
          <source>ASCII letters 'A' to 'Z' are mapped to 'a' to 'z', but non-ASCII letters are unchanged.</source>
          <target state="translated">ASCII文字の「A」から「Z」は「a」から「z」にマッピングされますが、非ASCII文字は変更されません。</target>
        </trans-unit>
        <trans-unit id="2e3db4ca30bac04610a9ba330ec0d3d5c61cf4d8" translate="yes" xml:space="preserve">
          <source>ASCII letters 'a' to 'z' are mapped to 'A' to 'Z', but non-ASCII letters are unchanged.</source>
          <target state="translated">ASCII 文字 'a' から 'z' は 'A' から 'Z' にマップされますが、非 ASCII 文字は変更されません。</target>
        </trans-unit>
        <trans-unit id="958cc1148f8aff5543459cc62e998e9d661990e7" translate="yes" xml:space="preserve">
          <source>ASCII_ESCAPE :</source>
          <target state="translated">ASCII_ESCAPE .</target>
        </trans-unit>
        <trans-unit id="8d6c4817508ef1c56c15761069329bc78c08e97c" translate="yes" xml:space="preserve">
          <source>ASCII_FOR_CHAR :</source>
          <target state="translated">ASCII_FOR_CHAR .</target>
        </trans-unit>
        <trans-unit id="1e976fbca3f1cd1471746ec2b3ff6a7a5d15936f" translate="yes" xml:space="preserve">
          <source>ASCII_FOR_STRING :</source>
          <target state="translated">ASCII_FOR_STRING .</target>
        </trans-unit>
        <trans-unit id="b6453d9f657d21e7c289076ce98028e47dc7282d" translate="yes" xml:space="preserve">
          <source>ATOMIC_BOOL_INIT</source>
          <target state="translated">ATOMIC_BOOL_INIT</target>
        </trans-unit>
        <trans-unit id="2b9c513ccbb146434eeb5bd6802254d3e9319214" translate="yes" xml:space="preserve">
          <source>ATOMIC_I16_INIT</source>
          <target state="translated">ATOMIC_I16_INIT</target>
        </trans-unit>
        <trans-unit id="6eacbfe2c8c788ffc6b7a2bdbffc94fa45c82d1a" translate="yes" xml:space="preserve">
          <source>ATOMIC_I32_INIT</source>
          <target state="translated">ATOMIC_I32_INIT</target>
        </trans-unit>
        <trans-unit id="66f562d6648e128b70300462dcad7b8fc4608b4d" translate="yes" xml:space="preserve">
          <source>ATOMIC_I64_INIT</source>
          <target state="translated">ATOMIC_I64_INIT</target>
        </trans-unit>
        <trans-unit id="3fed299eb934560d34d135ac41857a8fb36ef0bf" translate="yes" xml:space="preserve">
          <source>ATOMIC_I8_INIT</source>
          <target state="translated">ATOMIC_I8_INIT</target>
        </trans-unit>
        <trans-unit id="bdb0440ba3e33135f2c764f4348aac2801df19e3" translate="yes" xml:space="preserve">
          <source>ATOMIC_ISIZE_INIT</source>
          <target state="translated">ATOMIC_ISIZE_INIT</target>
        </trans-unit>
        <trans-unit id="8666b79dcee9e5c85aa6e1517921389330c7bb56" translate="yes" xml:space="preserve">
          <source>ATOMIC_U16_INIT</source>
          <target state="translated">ATOMIC_U16_INIT</target>
        </trans-unit>
        <trans-unit id="5463cfe71666bd3cbb7e7bd93e1dea5283405daf" translate="yes" xml:space="preserve">
          <source>ATOMIC_U32_INIT</source>
          <target state="translated">ATOMIC_U32_INIT</target>
        </trans-unit>
        <trans-unit id="fee37bb8c4ae8ff95ead7263aeefbf92f4fb076f" translate="yes" xml:space="preserve">
          <source>ATOMIC_U64_INIT</source>
          <target state="translated">ATOMIC_U64_INIT</target>
        </trans-unit>
        <trans-unit id="b5fd0a39697ab3a5f13871b24404fa76ef7723d2" translate="yes" xml:space="preserve">
          <source>ATOMIC_U8_INIT</source>
          <target state="translated">ATOMIC_U8_INIT</target>
        </trans-unit>
        <trans-unit id="b775de59887a198b8bb80812de87ea9a271a97f2" translate="yes" xml:space="preserve">
          <source>ATOMIC_USIZE_INIT</source>
          <target state="translated">ATOMIC_USIZE_INIT</target>
        </trans-unit>
        <trans-unit id="931aa76f7d621b2bd9a484f56b5e9a93cf07c3f7" translate="yes" xml:space="preserve">
          <source>Abort on memory allocation error or failure.</source>
          <target state="translated">メモリ割り当てエラーまたは失敗でアボート</target>
        </trans-unit>
        <trans-unit id="df06ef34b8240a09fa9f161ea99137607ac00a56" translate="yes" xml:space="preserve">
          <source>Aborts the execution of the process.</source>
          <target state="translated">プロセスの実行を中止します。</target>
        </trans-unit>
        <trans-unit id="b619665e057a59c1a1dbdf52957bcc9212748104" translate="yes" xml:space="preserve">
          <source>Abstract return types</source>
          <target state="translated">抽象的な戻り値の型</target>
        </trans-unit>
        <trans-unit id="db7472b4d6bc69237c01f48a8b625cef374de6c1" translate="yes" xml:space="preserve">
          <source>Abstract return types (written &lt;code&gt;impl Trait&lt;/code&gt; for some trait &lt;code&gt;Trait&lt;/code&gt;) are only allowed as function and inherent impl return types.</source>
          <target state="translated">（書かれた抽象戻り値の型 &lt;code&gt;impl Trait&lt;/code&gt; いくつかの形質について &lt;code&gt;Trait&lt;/code&gt; ）のみの機能と固有のimplの戻り値の型として許可されています。</target>
        </trans-unit>
        <trans-unit id="bdd7aedb4bc31655563e1852b48c298d5ec5570e" translate="yes" xml:space="preserve">
          <source>Abstract syntax tree</source>
          <target state="translated">抽象構文木</target>
        </trans-unit>
        <trans-unit id="8a308b160b478c6d80c833cea5942381a0eb8138" translate="yes" xml:space="preserve">
          <source>Accept a new incoming connection from this listener.</source>
          <target state="translated">このリスナーからの新しい着信接続を受け入れます。</target>
        </trans-unit>
        <trans-unit id="9d161ad935c554382c0d645c53e65dd6566a4bb5" translate="yes" xml:space="preserve">
          <source>Accepting Command Line Arguments</source>
          <target state="translated">コマンドライン引数の受け入れ</target>
        </trans-unit>
        <trans-unit id="5c44c9a8bf41c1458082624764926e9e452b0f9a" translate="yes" xml:space="preserve">
          <source>Accepts &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;AcqRel&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;SeqCst&lt;/code&gt;&lt;/a&gt; orderings.</source>
          <target state="translated">&lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;AcqRel&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;SeqCst&lt;/code&gt; の&lt;/a&gt;順序を受け入れます。</target>
        </trans-unit>
        <trans-unit id="a053fb66cacbf9febf839206d8e07b27aeeb3488" translate="yes" xml:space="preserve">
          <source>Accepts a new incoming connection to this listener.</source>
          <target state="translated">このリスナーへの新しい着信接続を受け入れます。</target>
        </trans-unit>
        <trans-unit id="41aadfd41c1a6581a617dbde4d22fdb01baa3e91" translate="yes" xml:space="preserve">
          <source>Access an entry by a key and its hash.</source>
          <target state="translated">キーとそのハッシュでエントリにアクセスします。</target>
        </trans-unit>
        <trans-unit id="51a3abe326b3c0792015c0e4fe719586def474a7" translate="yes" xml:space="preserve">
          <source>Access an entry by hash.</source>
          <target state="translated">ハッシュでエントリにアクセスします。</target>
        </trans-unit>
        <trans-unit id="fab65c5f7333ea79c15d33939860036f46df2b02" translate="yes" xml:space="preserve">
          <source>Access an entry by key.</source>
          <target state="translated">キーでエントリにアクセスします。</target>
        </trans-unit>
        <trans-unit id="f8d8572e08e06ee9c752f760cd0d14aa8e2826f1" translate="yes" xml:space="preserve">
          <source>Access fields in a packed struct:</source>
          <target state="translated">パック構造体のフィールドにアクセスします。</target>
        </trans-unit>
        <trans-unit id="dcc61ae90f40e1ace5937cd1dcd9d685d9053fd4" translate="yes" xml:space="preserve">
          <source>Access fields of &lt;a href=&quot;keyword.union&quot;&gt;&lt;code&gt;union&lt;/code&gt;&lt;/a&gt;s</source>
          <target state="translated">&lt;a href=&quot;keyword.union&quot;&gt; &lt;code&gt;union&lt;/code&gt; &lt;/a&gt;のフィールドにアクセスする</target>
        </trans-unit>
        <trans-unit id="b465e0094928c80bf2ab2af5859dca5bafc8fa28" translate="yes" xml:space="preserve">
          <source>Access fields of &lt;code&gt;union&lt;/code&gt;s</source>
          <target state="translated">&lt;code&gt;union&lt;/code&gt; のフィールドにアクセスする</target>
        </trans-unit>
        <trans-unit id="9ea16fa6ced966020c4bffbd61fb4353757d0cf8" translate="yes" xml:space="preserve">
          <source>Access members of a packed struct by reference:</source>
          <target state="translated">パックされた構造体のメンバに参照でアクセスします。</target>
        </trans-unit>
        <trans-unit id="8b8e97faa7739e19473f47e07608526221b515e7" translate="yes" xml:space="preserve">
          <source>Access or modify a mutable static variable</source>
          <target state="translated">変異可能な静的変数へのアクセスまたは変更</target>
        </trans-unit>
        <trans-unit id="cd54de93b3358e522ad1a3c574f8befd63e8ca75" translate="yes" xml:space="preserve">
          <source>Access the underlying UTF-8 error that was the cause of this error.</source>
          <target state="translated">このエラーの原因となった基礎となるUTF-8エラーにアクセスします。</target>
        </trans-unit>
        <trans-unit id="46164e9a717820065d93ac43f40d916b0e4e7553" translate="yes" xml:space="preserve">
          <source>AccessError</source>
          <target state="translated">AccessError</target>
        </trans-unit>
        <trans-unit id="ce24154072e2c91b2d63af9c452a4cc41adea723" translate="yes" xml:space="preserve">
          <source>AccessError::borrow</source>
          <target state="translated">AccessError::borrow</target>
        </trans-unit>
        <trans-unit id="0cc742fcaecb2fa19742b5bc67e762feaa6f37c0" translate="yes" xml:space="preserve">
          <source>AccessError::borrow_mut</source>
          <target state="translated">AccessError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="a94e2b3363d2d1a8ced8c51a5e15ff4f96e5bb39" translate="yes" xml:space="preserve">
          <source>AccessError::fmt</source>
          <target state="translated">AccessError::fmt</target>
        </trans-unit>
        <trans-unit id="2c2380ad9f60011344ab503262723a632ed3c1d2" translate="yes" xml:space="preserve">
          <source>AccessError::from</source>
          <target state="translated">AccessError::from</target>
        </trans-unit>
        <trans-unit id="7621469337a4b2f74d2a377616bccd38326a7edd" translate="yes" xml:space="preserve">
          <source>AccessError::into</source>
          <target state="translated">AccessError::into</target>
        </trans-unit>
        <trans-unit id="57d0ff4e6d1785ba4d9a1781d3047ed655772b49" translate="yes" xml:space="preserve">
          <source>AccessError::to_string</source>
          <target state="translated">AccessError::to_string</target>
        </trans-unit>
        <trans-unit id="c9ce68542ae4f2f8f818a2b5731ce826d35da932" translate="yes" xml:space="preserve">
          <source>AccessError::try_from</source>
          <target state="translated">AccessError::try_from</target>
        </trans-unit>
        <trans-unit id="cbc880d00714a36a28ddfefa1107fb401f040376" translate="yes" xml:space="preserve">
          <source>AccessError::try_into</source>
          <target state="translated">AccessError::try_into</target>
        </trans-unit>
        <trans-unit id="f18106e890f07e143593c942859c5df6ac97bdb0" translate="yes" xml:space="preserve">
          <source>AccessError::type_id</source>
          <target state="translated">AccessError::type_id</target>
        </trans-unit>
        <trans-unit id="6260b03bb183bb1a54da2dc8ffad6ed6483c869e" translate="yes" xml:space="preserve">
          <source>Accessing Array Elements</source>
          <target state="translated">配列要素へのアクセス</target>
        </trans-unit>
        <trans-unit id="0457e6128b17f06deb434a0c2873ebd99b60eb0d" translate="yes" xml:space="preserve">
          <source>Accessing Fields of a Union</source>
          <target state="translated">ユニオンのフィールドへのアクセス</target>
        </trans-unit>
        <trans-unit id="6a8c72aa13ec7be5fc27578400a1a226881f478c" translate="yes" xml:space="preserve">
          <source>Accessing Values in a Hash Map</source>
          <target state="translated">ハッシュマップ内の値へのアクセス</target>
        </trans-unit>
        <trans-unit id="b06fec963d87626314583ae2b00b8c48fde3efce" translate="yes" xml:space="preserve">
          <source>Accessing a field of a &lt;a href=&quot;items/unions&quot;&gt;&lt;code&gt;union&lt;/code&gt;&lt;/a&gt;, other than to assign to it.</source>
          <target state="translated">&lt;a href=&quot;items/unions&quot;&gt; &lt;code&gt;union&lt;/code&gt; の&lt;/a&gt;フィールドへのアクセス以外の、フィールドへのアクセス。</target>
        </trans-unit>
        <trans-unit id="a0cd0bd48f335ea136bd217d77f1a368ccbcee58" translate="yes" xml:space="preserve">
          <source>Accessing adjacent &lt;code&gt;u8&lt;/code&gt; as &lt;code&gt;u16&lt;/code&gt;</source>
          <target state="translated">隣接するアクセス &lt;code&gt;u8&lt;/code&gt; として &lt;code&gt;u16&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6f91f22939adae86de60c33d3fdb16972e0fb724" translate="yes" xml:space="preserve">
          <source>Accessing data in the heap is slower than accessing data on the stack because you have to follow a pointer to get there. Contemporary processors are faster if they jump around less in memory. Continuing the analogy, consider a server at a restaurant taking orders from many tables. It&amp;rsquo;s most efficient to get all the orders at one table before moving on to the next table. Taking an order from table A, then an order from table B, then one from A again, and then one from B again would be a much slower process. By the same token, a processor can do its job better if it works on data that&amp;rsquo;s close to other data (as it is on the stack) rather than farther away (as it can be on the heap). Allocating a large amount of space on the heap can also take time.</source>
          <target state="translated">ヒープ内のデータへのアクセスは、スタック上のデータへのアクセスよりも遅くなります。これは、ポインタをたどってそこに到達する必要があるためです。最近のプロセッサは、メモリ内のジャンプが少ないほど高速です。類推を続けて、多くのテーブルから注文を受けるレストランのサーバーを考えてみましょう。次のテーブルに進む前に、1つのテーブルですべての注文を取得するのが最も効率的です。テーブルAからの注文、テーブルBからの注文、次にAからの注文、そしてBからの注文は、処理が非常に遅くなります。同様に、プロセッサは、（ヒープ上にある可能性があるため）遠くにあるのではなく、（スタック上にあるように）他のデータに近いデータを処理する場合に、より適切に機能します。ヒープに大量のスペースを割り当てると、時間がかかる場合があります。</target>
        </trans-unit>
        <trans-unit id="f239f31c4b24ce084fa39af1811c8d4fc4e10b36" translate="yes" xml:space="preserve">
          <source>Accessing non-&lt;a href=&quot;keyword.mut&quot;&gt;&lt;code&gt;mut&lt;/code&gt;&lt;/a&gt;&lt;code&gt;static&lt;/code&gt; items is considered safe, but some restrictions apply. Most notably, the type of a &lt;code&gt;static&lt;/code&gt; value needs to implement the &lt;a href=&quot;marker/trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; trait, ruling out interior mutability containers like &lt;a href=&quot;cell/struct.refcell&quot;&gt;&lt;code&gt;RefCell&lt;/code&gt;&lt;/a&gt;. See the &lt;a href=&quot;../reference/items/static-items&quot;&gt;Reference&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;a href=&quot;keyword.mut&quot;&gt; &lt;code&gt;mut&lt;/code&gt; &lt;/a&gt; &lt;code&gt;static&lt;/code&gt; アイテムへのアクセスは安全と見なされますが、いくつかの制限が適用されます。最も注目すべきは、 &lt;code&gt;static&lt;/code&gt; 値のタイプは&lt;a href=&quot;marker/trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt;トレイトを実装する必要があり、&lt;a href=&quot;cell/struct.refcell&quot;&gt; &lt;code&gt;RefCell&lt;/code&gt; の&lt;/a&gt;ような内部の可変性コンテナーを除外することです。詳細については、&lt;a href=&quot;../reference/items/static-items&quot;&gt;リファレンス&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="c20e5fc2ccd1b37aea7b882c463d596e55833b83" translate="yes" xml:space="preserve">
          <source>Accessing or Modifying a Mutable Static Variable</source>
          <target state="translated">Mutable 静的変数へのアクセスと変更</target>
        </trans-unit>
        <trans-unit id="f13080b643bf72eee286858a8d7c3ab06b544915" translate="yes" xml:space="preserve">
          <source>Accessing unaligned fields directly with e.g. &lt;code&gt;packed.unaligned&lt;/code&gt; is safe however.</source>
          <target state="translated">ただし、 &lt;code&gt;packed.unaligned&lt;/code&gt; などを使用して整列されていないフィールドに直接アクセスすることは安全です。</target>
        </trans-unit>
        <trans-unit id="12a3a4f498b28cbec01c44aacf0dc5e3a1b828ef" translate="yes" xml:space="preserve">
          <source>Accuracy</source>
          <target state="translated">Accuracy</target>
        </trans-unit>
        <trans-unit id="edc1ea5ed2dafd896f3493beb6ccad4cc0bfdeb7" translate="yes" xml:space="preserve">
          <source>Accurately documenting your packages will help other users know how and when to use them, so it&amp;rsquo;s worth investing the time to write documentation. In Chapter 3, we discussed how to comment Rust code using two slashes, &lt;code&gt;//&lt;/code&gt;. Rust also has a particular kind of comment for documentation, known conveniently as a &lt;em&gt;documentation comment&lt;/em&gt;, that will generate HTML documentation. The HTML displays the contents of documentation comments for public API items intended for programmers interested in knowing how to &lt;em&gt;use&lt;/em&gt; your crate as opposed to how your crate is &lt;em&gt;implemented&lt;/em&gt;.</source>
          <target state="translated">パッケージを正確に文書化すると、他のユーザーがパッケージをいつどのように使用するかを知るのに役立ちます。そのため、文書を書く時間を費やす価値があります。第3章では、2つのスラッシュ &lt;code&gt;//&lt;/code&gt; を使用してRustコードにコメントを付ける方法について説明しました。錆としても便利知らドキュメンテーションコメントの特定の種類、持っている&lt;em&gt;ドキュメンテーションコメント&lt;/em&gt; HTMLドキュメントを生成します。HTMLには、クレートの&lt;em&gt;実装&lt;/em&gt;方法ではなく、クレートの&lt;em&gt;使用&lt;/em&gt;方法を知りたいプログラマー向けのパブリックAPIアイテムのドキュメントコメントの内容が表示されます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6568c1be017add88e3d012e02f41ac58f3e66045" translate="yes" xml:space="preserve">
          <source>Acquire - a barrier for acquiring a lock. Subsequent reads and writes take place after the barrier.</source>
          <target state="translated">Acquire-ロックを取得するためのバリア。それ以降の読み書きは、バリアの後で行われます。</target>
        </trans-unit>
        <trans-unit id="af0f8ed1129c9ddf2134ed1c81b67a9bcb444f5a" translate="yes" xml:space="preserve">
          <source>Acquires a mutable reference to the owned form of the data.</source>
          <target state="translated">データの所有形態への変異可能な参照を取得します。</target>
        </trans-unit>
        <trans-unit id="ff3bc67bc303cd10ada41c07bb7edfd939dc9318" translate="yes" xml:space="preserve">
          <source>Acquires a mutex, blocking the current thread until it is able to do so.</source>
          <target state="translated">ミューテックスを取得し、現在のスレッドをブロックします。</target>
        </trans-unit>
        <trans-unit id="220a887115abad65ad7317817bfb97307bde3f84" translate="yes" xml:space="preserve">
          <source>Acquires a reference to the value in this TLS key.</source>
          <target state="translated">このTLSキーの値への参照を取得します。</target>
        </trans-unit>
        <trans-unit id="b36ce9a1808b77b91f2783ae64622ebad2a9cac9" translate="yes" xml:space="preserve">
          <source>Acquires the underlying &lt;code&gt;*mut&lt;/code&gt; pointer.</source>
          <target state="translated">基礎となる &lt;code&gt;*mut&lt;/code&gt; ポインタを取得します。</target>
        </trans-unit>
        <trans-unit id="d4158950a66bbaeb08dff05a2933261e57fba1be" translate="yes" xml:space="preserve">
          <source>Acquiring the path of the current executable is a platform-specific operation that can fail for a good number of reasons. Some errors can include, but not be limited to, filesystem operations failing or general syscall failures.</source>
          <target state="translated">現在の実行ファイルのパスを取得することは、プラットフォーム固有の操作であり、多くの理由で失敗する可能性があります。いくつかのエラーには、ファイルシステム操作の失敗や一般的なシステムコールの失敗が含まれますが、これらに限定されるものではありません。</target>
        </trans-unit>
        <trans-unit id="6d8f12c840c97a885d954c4ab3f89cfe39b2655d" translate="yes" xml:space="preserve">
          <source>Active and inert attributes</source>
          <target state="translated">アクティブ属性と不活性属性</target>
        </trans-unit>
        <trans-unit id="e07a4acdd5cdd3ab645fd0d90270662d13ac1718" translate="yes" xml:space="preserve">
          <source>Adapters</source>
          <target state="translated">Adapters</target>
        </trans-unit>
        <trans-unit id="876182ad9012a6c08f789f1f68ad82ee5e8c99b7" translate="yes" xml:space="preserve">
          <source>Adaptor to chain together two readers.</source>
          <target state="translated">2台のリーダーを連結するためのアダプター。</target>
        </trans-unit>
        <trans-unit id="61cc55aa0453184734c3fa0b621eda6fa874bd83" translate="yes" xml:space="preserve">
          <source>Add</source>
          <target state="translated">Add</target>
        </trans-unit>
        <trans-unit id="5377ba24487df148115875083e9ad3100b466293" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;'static&lt;/code&gt; requirement to fix them:</source>
          <target state="translated">それらを修正するため &lt;code&gt;'static&lt;/code&gt; 要件を追加します。</target>
        </trans-unit>
        <trans-unit id="ca240252f7070cde72a7b776f50be32f04f2fc0d" translate="yes" xml:space="preserve">
          <source>Add a &lt;code&gt;reject&lt;/code&gt; method that changes the post&amp;rsquo;s state from &lt;code&gt;PendingReview&lt;/code&gt; back to &lt;code&gt;Draft&lt;/code&gt;.</source>
          <target state="translated">投稿の状態を &lt;code&gt;PendingReview&lt;/code&gt; から &lt;code&gt;Draft&lt;/code&gt; に戻す &lt;code&gt;reject&lt;/code&gt; メソッドを追加します。</target>
        </trans-unit>
        <trans-unit id="a0a1e3ef1e8493d789dbbf3d73ecb2a795cba8db" translate="yes" xml:space="preserve">
          <source>Add a description that is just a sentence or two, because it will appear with your crate in search results. For the &lt;code&gt;license&lt;/code&gt; field, you need to give a &lt;em&gt;license identifier value&lt;/em&gt;. The &lt;a href=&quot;http://spdx.org/licenses/&quot;&gt;Linux Foundation&amp;rsquo;s Software Package Data Exchange (SPDX)&lt;/a&gt; lists the identifiers you can use for this value. For example, to specify that you&amp;rsquo;ve licensed your crate using the MIT License, add the &lt;code&gt;MIT&lt;/code&gt; identifier:</source>
          <target state="translated">検索結果にクレートとともに表示されるため、1〜2文の説明を追加してください。以下のために &lt;code&gt;license&lt;/code&gt; フィールド、あなたが与える必要がある&lt;em&gt;ライセンス識別子値を&lt;/em&gt;。&lt;a href=&quot;http://spdx.org/licenses/&quot;&gt;Linux Foundationのソフトウェアパッケージのデータ交換（SPDX）は、&lt;/a&gt;この値に使用できる識別子を示しています。たとえば、MITライセンスを使用してクレートにライセンスを付与したことを指定するには、 &lt;code&gt;MIT&lt;/code&gt; 識別子を追加します。</target>
        </trans-unit>
        <trans-unit id="c8594387539a0f2f7158c8875d4643cbc796d8e9" translate="yes" xml:space="preserve">
          <source>Add a getter function:</source>
          <target state="translated">ゲッター関数を追加します。</target>
        </trans-unit>
        <trans-unit id="c563aa838f46cc2ef90bbf765435b526485acbf0" translate="yes" xml:space="preserve">
          <source>Add constraints that must be upheld to use an item.</source>
          <target state="translated">項目を使用するために支持されなければならない制約を追加します。</target>
        </trans-unit>
        <trans-unit id="32aaebe9976898d3881c1a85d7d471c975e08486" translate="yes" xml:space="preserve">
          <source>Add more documentation to &lt;code&gt;ThreadPool&lt;/code&gt; and its public methods.</source>
          <target state="translated">&lt;code&gt;ThreadPool&lt;/code&gt; とそのパブリックメソッドにドキュメントを追加します。</target>
        </trans-unit>
        <trans-unit id="eac54db7026ed63754bb1e0481266ad4560b6f6c" translate="yes" xml:space="preserve">
          <source>Add tests of the library&amp;rsquo;s functionality.</source>
          <target state="translated">ライブラリの機能のテストを追加します。</target>
        </trans-unit>
        <trans-unit id="584510db3cf556aee671c49783907c6c03f2abe4" translate="yes" xml:space="preserve">
          <source>Add the size of the field.</source>
          <target state="translated">フィールドのサイズを追加します。</target>
        </trans-unit>
        <trans-unit id="e0ef2ba9581371a273c725b4584816d08df6e970" translate="yes" xml:space="preserve">
          <source>Add::add</source>
          <target state="translated">Add::add</target>
        </trans-unit>
        <trans-unit id="bd166591010a18220168b51497b0b5e84b157433" translate="yes" xml:space="preserve">
          <source>AddAssign</source>
          <target state="translated">AddAssign</target>
        </trans-unit>
        <trans-unit id="6eecef84103332763bac0f11d9776217926be6a9" translate="yes" xml:space="preserve">
          <source>AddAssign::add_assign</source>
          <target state="translated">AddAssign::add_assign</target>
        </trans-unit>
        <trans-unit id="47bc308a358cb72c871f66d0703a1751fa8c3e13" translate="yes" xml:space="preserve">
          <source>Adding &lt;code&gt;rand&lt;/code&gt; as a dependency in &lt;em&gt;Cargo.toml&lt;/em&gt; tells Cargo to download the &lt;code&gt;rand&lt;/code&gt; package and any dependencies from &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; and make &lt;code&gt;rand&lt;/code&gt; available to our project.</source>
          <target state="translated">追加 &lt;code&gt;rand&lt;/code&gt; 中に依存関係として&lt;em&gt;Cargo.tomlを&lt;/em&gt;ダウンロードして貨物を伝え &lt;code&gt;rand&lt;/code&gt; パッケージとの依存関係&lt;a href=&quot;https://crates.io/&quot;&gt;crates.ioを&lt;/a&gt;して作る &lt;code&gt;rand&lt;/code&gt; 私たちのプロジェクトに利用できます。</target>
        </trans-unit>
        <trans-unit id="6951b086bf1e29a4acfdba85666aa713fe81534c" translate="yes" xml:space="preserve">
          <source>Adding &lt;code&gt;use&lt;/code&gt; and a path in a scope is similar to creating a symbolic link in the filesystem. By adding &lt;code&gt;use crate::front_of_house::hosting&lt;/code&gt; in the crate root, &lt;code&gt;hosting&lt;/code&gt; is now a valid name in that scope, just as though the &lt;code&gt;hosting&lt;/code&gt; module had been defined in the crate root. Paths brought into scope with &lt;code&gt;use&lt;/code&gt; also check privacy, like any other paths.</source>
          <target state="translated">スコープに &lt;code&gt;use&lt;/code&gt; とパスを追加することは、ファイルシステムにシンボリックリンクを作成することに似ています。追加することにより &lt;code&gt;use crate::front_of_house::hosting&lt;/code&gt; クレートのルートには、 &lt;code&gt;hosting&lt;/code&gt; ちょうどかのように、今、その範囲内で有効な名前である &lt;code&gt;hosting&lt;/code&gt; モジュールはクレートのルートで定義されていました。他のパスと同様に、 &lt;code&gt;use&lt;/code&gt; 伴ってスコープに入れられたパスはプライバシーもチェックします。</target>
        </trans-unit>
        <trans-unit id="311633e0da4d8767a76b5d94813ce0272b9cb8a9" translate="yes" xml:space="preserve">
          <source>Adding Custom Failure Messages</source>
          <target state="translated">カスタムの失敗メッセージを追加する</target>
        </trans-unit>
        <trans-unit id="eb99698d7e26927ef9425258511b7fbda34cd647" translate="yes" xml:space="preserve">
          <source>Adding Metadata to a New Crate</source>
          <target state="translated">新しいクレートにメタデータを追加する</target>
        </trans-unit>
        <trans-unit id="6ff96d15a4dfd75cd1b39329a2970688120a37e4" translate="yes" xml:space="preserve">
          <source>Adding Useful Functionality with Derived Traits</source>
          <target state="translated">派生形質による有用な機能の追加</target>
        </trans-unit>
        <trans-unit id="b2524eeb321c4f1026793239c00d8c1b31c32e31" translate="yes" xml:space="preserve">
          <source>Adding a &lt;code&gt;PhantomData&amp;lt;T&amp;gt;&lt;/code&gt; field to your type tells the compiler that your type acts as though it stores a value of type &lt;code&gt;T&lt;/code&gt;, even though it doesn't really. This information is used when computing certain safety properties.</source>
          <target state="translated">型に &lt;code&gt;PhantomData&amp;lt;T&amp;gt;&lt;/code&gt; フィールドを追加すると、コンパイラは、型 &lt;code&gt;T&lt;/code&gt; の値を格納しているかのように動作することをコンパイラに通知します。この情報は、特定の安全特性を計算するときに使用されます。</target>
        </trans-unit>
        <trans-unit id="b87a48eb56569132271d6219a87c7a5229e982a0" translate="yes" xml:space="preserve">
          <source>Adding a &lt;code&gt;Self: Sized&lt;/code&gt; bound to these methods will generally make this compile.</source>
          <target state="translated">&lt;code&gt;Self: Sized&lt;/code&gt; 追加：これらのメソッドにバインドされたサイズは、通常、これをコンパイルします。</target>
        </trans-unit>
        <trans-unit id="88b9f27e251e16ee893bec092535b944c26b4aa9" translate="yes" xml:space="preserve">
          <source>Adding a Reference from a Child to Its Parent</source>
          <target state="translated">子から親への参照の追加</target>
        </trans-unit>
        <trans-unit id="23ab42376e070f08194bffa94071c8449a58479a" translate="yes" xml:space="preserve">
          <source>Adding a Test to a Workspace</source>
          <target state="translated">ワークスペースへのテストの追加</target>
        </trans-unit>
        <trans-unit id="fd0c9f4d15902bc297e9dbf8af8d2743194e970b" translate="yes" xml:space="preserve">
          <source>Adding a field of type &lt;code&gt;PhantomData&amp;lt;T&amp;gt;&lt;/code&gt; indicates that your type owns data of type &lt;code&gt;T&lt;/code&gt;. This in turn implies that when your type is dropped, it may drop one or more instances of the type &lt;code&gt;T&lt;/code&gt;. This has bearing on the Rust compiler's &lt;a href=&quot;https://doc.rust-lang.org/nomicon/dropck.html&quot;&gt;drop check&lt;/a&gt; analysis.</source>
          <target state="translated">タイプ &lt;code&gt;PhantomData&amp;lt;T&amp;gt;&lt;/code&gt; フィールドを追加すると、そのタイプがタイプ &lt;code&gt;T&lt;/code&gt; のデータを所有することを示します。これは、タイプがドロップされると、タイプ &lt;code&gt;T&lt;/code&gt; のインスタンスを1つ以上ドロップする可能性があることを意味します。これは、Rustコンパイラの&lt;a href=&quot;https://doc.rust-lang.org/nomicon/dropck.html&quot;&gt;ドロップチェック&lt;/a&gt;分析に関係しています。</target>
        </trans-unit>
        <trans-unit id="2e98bb73927df33c08944823ebcc88b767156500" translate="yes" xml:space="preserve">
          <source>Adding example code blocks in your documentation comments can help demonstrate how to use your library, and doing so has an additional bonus: running &lt;code&gt;cargo test&lt;/code&gt; will run the code examples in your documentation as tests! Nothing is better than documentation with examples. But nothing is worse than examples that don&amp;rsquo;t work because the code has changed since the documentation was written. If we run &lt;code&gt;cargo test&lt;/code&gt; with the documentation for the &lt;code&gt;add_one&lt;/code&gt; function from Listing 14-1, we will see a section in the test results like this:</source>
          <target state="translated">ドキュメントのコメントにサンプルコードブ​​ロックを追加すると、ライブラリの使用方法を示すのに役立ちます。これを行うと、さらにボーナスがあります。 &lt;code&gt;cargo test&lt;/code&gt; を実行すると、ドキュメント内のコード例がテストとして実行されます。例付きのドキュメントに勝るものはありません。しかし、ドキュメントが作成されてからコードが変更されたために機能しない例よりも悪いことはありません。リスト14-1の &lt;code&gt;add_one&lt;/code&gt; 関数のドキュメントを使用して &lt;code&gt;cargo test&lt;/code&gt; を実行すると、テスト結果に次のようなセクションが表示されます。</target>
        </trans-unit>
        <trans-unit id="ceb9b506f927db7479477e625a150623510cf2aa" translate="yes" xml:space="preserve">
          <source>Adding the &lt;code id=&quot;adding-the-approve-method-that-changes-the-behavior-of-content&quot;&gt;approve&lt;/code&gt; Method that Changes the Behavior of &lt;code&gt;content&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;content&lt;/code&gt; の動作を変更 &lt;code id=&quot;adding-the-approve-method-that-changes-the-behavior-of-content&quot;&gt;approve&lt;/code&gt; メソッドを追加する</target>
        </trans-unit>
        <trans-unit id="718d273106ffd821ac0c7d93c2d34d8556d7365d" translate="yes" xml:space="preserve">
          <source>Adding the &lt;code&gt;break&lt;/code&gt; line after &lt;code&gt;You win!&lt;/code&gt; makes the program exit the loop when the user guesses the secret number correctly. Exiting the loop also means exiting the program, because the loop is the last part of &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;You win!&lt;/code&gt; 後に &lt;code&gt;break&lt;/code&gt; ラインを追加します！ユーザーがシークレット番号を正しく推測すると、プログラムがループを終了します。ループは &lt;code&gt;main&lt;/code&gt; の最後の部分であるため、ループを終了することはプログラムを終了することも意味します。</target>
        </trans-unit>
        <trans-unit id="097cf74b7fb2e319a4766446302ea478dcd635f5" translate="yes" xml:space="preserve">
          <source>Adding the &lt;code&gt;mut&lt;/code&gt; keyword dereferences a mutable reference. The mutability must match the mutability of the reference.</source>
          <target state="translated">&lt;code&gt;mut&lt;/code&gt; キーワードを追加すると、可変参照が逆参照されます。可変性は参照の可変性と一致する必要があります。</target>
        </trans-unit>
        <trans-unit id="8e8428e85c661f03dd33db8f12b20a010ab5be5e" translate="yes" xml:space="preserve">
          <source>Addition</source>
          <target state="translated">Addition</target>
        </trans-unit>
        <trans-unit id="c8217392646c4b940c031f95cbb65a4bfa731556" translate="yes" xml:space="preserve">
          <source>Addition assignment</source>
          <target state="translated">追加課題</target>
        </trans-unit>
        <trans-unit id="b078f9f7ba47f896a06212df108079bcbb1553ff" translate="yes" xml:space="preserve">
          <source>Additional functionality for numerics.</source>
          <target state="translated">数値の追加機能。</target>
        </trans-unit>
        <trans-unit id="2ffc443f11be980490aef62083275ee8c11f674b" translate="yes" xml:space="preserve">
          <source>Additional implementors</source>
          <target state="translated">追加の実装者</target>
        </trans-unit>
        <trans-unit id="911a0b354b810ade1b41221cd419095a4767144e" translate="yes" xml:space="preserve">
          <source>Additional information</source>
          <target state="translated">追加情報</target>
        </trans-unit>
        <trans-unit id="0c05d0c23b9a6f9971368dd97467c0d0e294ca18" translate="yes" xml:space="preserve">
          <source>Additional parameters passed to &lt;code&gt;format!&lt;/code&gt; replace the &lt;code&gt;{}&lt;/code&gt;s within the formatting string in the order given unless named or positional parameters are used; see &lt;a href=&quot;fmt/index&quot;&gt;&lt;code&gt;std::fmt&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;format!&lt;/code&gt; 渡される追加パラメーター！名前付きパラメータまたは位置パラメータが使用されていない限り、指定された順序でフォーマット文字列内の &lt;code&gt;{}&lt;/code&gt; を置き換えます。詳細については、&lt;a href=&quot;fmt/index&quot;&gt; &lt;code&gt;std::fmt&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="b89443b71b82e921f27bf8622eec75e5bb710e5e" translate="yes" xml:space="preserve">
          <source>Additional parameters passed to &lt;code&gt;format!&lt;/code&gt; replace the &lt;code&gt;{}&lt;/code&gt;s within the formatting string in the order given unless named or positional parameters are used; see &lt;a href=&quot;https://doc.rust-lang.org/core/fmt/index.html&quot;&gt;&lt;code&gt;std::fmt&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;format!&lt;/code&gt; 渡される追加のパラメーター！名前付きまたは位置パラメータが使用されていない限り、フォーマット文字列内の &lt;code&gt;{}&lt;/code&gt; を指定された順序で置き換えます。詳細については、&lt;a href=&quot;https://doc.rust-lang.org/core/fmt/index.html&quot;&gt; &lt;code&gt;std::fmt&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="f5cf45e8eb3455f9aeaa5f7fa4c013c3116744f0" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;code&gt;f32&lt;/code&gt; can represent a couple of special values:</source>
          <target state="translated">さらに、 &lt;code&gt;f32&lt;/code&gt; はいくつかの特別な値を表すことができます。</target>
        </trans-unit>
        <trans-unit id="dc3992de92a20dddf33d6770f13a67c41e82f34f" translate="yes" xml:space="preserve">
          <source>Additionally, a type &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt; can implement &lt;code&gt;CoerceUnsized&amp;lt;Foo&amp;lt;U&amp;gt;&amp;gt;&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; implements &lt;code&gt;Unsize&amp;lt;U&amp;gt;&lt;/code&gt; or &lt;code&gt;CoerceUnsized&amp;lt;Foo&amp;lt;U&amp;gt;&amp;gt;&lt;/code&gt;. This allows it to provide a unsized coercion to &lt;code&gt;Foo&amp;lt;U&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">また、タイプ &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt; を実装することができる &lt;code&gt;CoerceUnsized&amp;lt;Foo&amp;lt;U&amp;gt;&amp;gt;&lt;/code&gt; とき &lt;code&gt;T&lt;/code&gt; 器具 &lt;code&gt;Unsize&amp;lt;U&amp;gt;&lt;/code&gt; または &lt;code&gt;CoerceUnsized&amp;lt;Foo&amp;lt;U&amp;gt;&amp;gt;&lt;/code&gt; 。これにより、 &lt;code&gt;Foo&amp;lt;U&amp;gt;&lt;/code&gt; サイズ変更しない強制を提供できます。</target>
        </trans-unit>
        <trans-unit id="30e7a03e650ce2c7f3e6f58657d0e770d7ebbede" translate="yes" xml:space="preserve">
          <source>Additionally, even though &lt;code&gt;$crate&lt;/code&gt; allows a macro to refer to items within its own crate when expanding, its use has no effect on visibility. An item or macro referred to must still be visible from the invocation site. In the following example, any attempt to invoke &lt;code&gt;call_foo!()&lt;/code&gt; from outside its crate will fail because &lt;code&gt;foo()&lt;/code&gt; is not public.</source>
          <target state="translated">さらに、 &lt;code&gt;$crate&lt;/code&gt; 使用すると、展開時にマクロが自身のクレート内のアイテムを参照できるようになりますが、その使用は可視性に影響を与えません。参照されるアイテムまたはマクロは、呼び出しサイトから表示されている必要があります。次の例では、 &lt;code&gt;foo()&lt;/code&gt; がパブリックでないため、クレートの外側から &lt;code&gt;call_foo!()&lt;/code&gt; を呼び出そうとしても失敗します。</target>
        </trans-unit>
        <trans-unit id="8bd65ffd560b03ecf2792061831bdc28c657f4f7" translate="yes" xml:space="preserve">
          <source>Additionally, if &lt;code&gt;T&lt;/code&gt; is not &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, using the pointed-to value after calling &lt;code&gt;drop_in_place&lt;/code&gt; can cause undefined behavior. Note that &lt;code&gt;*to_drop = foo&lt;/code&gt; counts as a use because it will cause the value to be dropped again. &lt;a href=&quot;../ptr/fn.write&quot;&gt;&lt;code&gt;write()&lt;/code&gt;&lt;/a&gt; can be used to overwrite data without causing it to be dropped.</source>
          <target state="translated">さらに、 &lt;code&gt;T&lt;/code&gt; が&lt;a href=&quot;../marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;でない場合、 &lt;code&gt;drop_in_place&lt;/code&gt; を呼び出した後にポイントされた値を使用すると、未定義の動作が発生する可能性があります。 &lt;code&gt;*to_drop = foo&lt;/code&gt; は、値が再びドロップされるため、使用としてカウントされることに注意してください。&lt;a href=&quot;../ptr/fn.write&quot;&gt; &lt;code&gt;write()&lt;/code&gt; &lt;/a&gt;を使用すると、データをドロップせずに上書きできます。</target>
        </trans-unit>
        <trans-unit id="45cbb93035ac4b5290adcbd441c337adab3295a5" translate="yes" xml:space="preserve">
          <source>Additionally, if &lt;code&gt;T&lt;/code&gt; is not &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, using the pointed-to value after calling &lt;code&gt;drop_in_place&lt;/code&gt; can cause undefined behavior. Note that &lt;code&gt;*to_drop = foo&lt;/code&gt; counts as a use because it will cause the value to be dropped again. &lt;a href=&quot;../ptr/fn.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; can be used to overwrite data without causing it to be dropped.</source>
          <target state="translated">さらに、 &lt;code&gt;T&lt;/code&gt; が&lt;a href=&quot;../marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;でない場合、 &lt;code&gt;drop_in_place&lt;/code&gt; を呼び出した後にポイント先の値を使用すると、未定義の動作が発生する可能性があります。 &lt;code&gt;*to_drop = foo&lt;/code&gt; は、値が再度ドロップされるため、使用としてカウントされることに注意してください。&lt;a href=&quot;../ptr/fn.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;を使用すると、データを削除せずにデータを上書きできます。</target>
        </trans-unit>
        <trans-unit id="4db0827a894435e479c60b5c414ff857b4d8ad46" translate="yes" xml:space="preserve">
          <source>Additionally, if &lt;code&gt;T&lt;/code&gt; is not &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, using the pointed-to value after calling &lt;code&gt;drop_in_place&lt;/code&gt; can cause undefined behavior. Note that &lt;code&gt;*to_drop = foo&lt;/code&gt; counts as a use because it will cause the value to be dropped again. &lt;a href=&quot;fn.write&quot;&gt;&lt;code&gt;write()&lt;/code&gt;&lt;/a&gt; can be used to overwrite data without causing it to be dropped.</source>
          <target state="translated">さらに、 &lt;code&gt;T&lt;/code&gt; が&lt;a href=&quot;../marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;でない場合、 &lt;code&gt;drop_in_place&lt;/code&gt; を呼び出した後にポイントされた値を使用すると、未定義の動作が発生する可能性があります。 &lt;code&gt;*to_drop = foo&lt;/code&gt; は、値が再びドロップされるため、使用としてカウントされることに注意してください。&lt;a href=&quot;fn.write&quot;&gt; &lt;code&gt;write()&lt;/code&gt; &lt;/a&gt;を使用すると、データをドロップせずに上書きできます。</target>
        </trans-unit>
        <trans-unit id="74bd1999d14b1334b93c7bef28b699b66b0d25fc" translate="yes" xml:space="preserve">
          <source>Additionally, if &lt;code&gt;T&lt;/code&gt; is not &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, using the pointed-to value after calling &lt;code&gt;drop_in_place&lt;/code&gt; can cause undefined behavior. Note that &lt;code&gt;*to_drop = foo&lt;/code&gt; counts as a use because it will cause the value to be dropped again. &lt;a href=&quot;fn.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; can be used to overwrite data without causing it to be dropped.</source>
          <target state="translated">さらに、 &lt;code&gt;T&lt;/code&gt; が&lt;a href=&quot;../marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;でない場合、 &lt;code&gt;drop_in_place&lt;/code&gt; を呼び出した後にポイント先の値を使用すると、未定義の動作が発生する可能性があります。 &lt;code&gt;*to_drop = foo&lt;/code&gt; は、値が再度ドロップされるため、使用としてカウントされることに注意してください。&lt;a href=&quot;fn.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;を使用すると、データを削除せずにデータを上書きできます。</target>
        </trans-unit>
        <trans-unit id="90a70db7c7bfc77bbf274f46c324d605b6ac9ac3" translate="yes" xml:space="preserve">
          <source>Additionally, it does not drop &lt;code&gt;src&lt;/code&gt;. Semantically, &lt;code&gt;src&lt;/code&gt; is moved into the location pointed to by &lt;code&gt;dst&lt;/code&gt;.</source>
          <target state="translated">さらに、それは &lt;code&gt;src&lt;/code&gt; を落としません。意味的には、 &lt;code&gt;src&lt;/code&gt; は &lt;code&gt;dst&lt;/code&gt; が指す場所に移動されます。</target>
        </trans-unit>
        <trans-unit id="a5ab7ed4a3b0357f6baec92b0d45381b0f7726c3" translate="yes" xml:space="preserve">
          <source>Additionally, on Unix &lt;a href=&quot;struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; implements the &lt;code&gt;std::os::unix::ffi::&lt;/code&gt;&lt;a href=&quot;../os/unix/ffi/trait.osstringext&quot;&gt;&lt;code&gt;OsStringExt&lt;/code&gt;&lt;/a&gt; trait, which provides &lt;a href=&quot;../os/unix/ffi/trait.osstringext#tymethod.from_vec&quot;&gt;&lt;code&gt;from_vec&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../os/unix/ffi/trait.osstringext#tymethod.into_vec&quot;&gt;&lt;code&gt;into_vec&lt;/code&gt;&lt;/a&gt; methods that consume their arguments, and take or produce vectors of &lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">さらに、Unixでは、&lt;a href=&quot;struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt;は &lt;code&gt;std::os::unix::ffi::&lt;/code&gt; &lt;a href=&quot;../os/unix/ffi/trait.osstringext&quot;&gt; &lt;code&gt;OsStringExt&lt;/code&gt; &lt;/a&gt;トレイトを実装します。これは、引数を消費し、&lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; の&lt;/a&gt;ベクトルを取得または生成する&lt;a href=&quot;../os/unix/ffi/trait.osstringext#tymethod.from_vec&quot;&gt; &lt;code&gt;from_vec&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;../os/unix/ffi/trait.osstringext#tymethod.into_vec&quot;&gt; &lt;code&gt;into_vec&lt;/code&gt; &lt;/a&gt;メソッドを提供します。</target>
        </trans-unit>
        <trans-unit id="1db4d415a7232a66cc30ffdbd6dbfd6bc3c496f2" translate="yes" xml:space="preserve">
          <source>Additionally, on Unix &lt;a href=&quot;struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; implements the &lt;code&gt;std::os::unix::ffi::&lt;/code&gt;&lt;a href=&quot;../os/unix/ffi/trait.osstringext&quot;&gt;&lt;code&gt;OsStringExt&lt;/code&gt;&lt;/a&gt; trait, which provides &lt;a href=&quot;../os/unix/ffi/trait.osstringext#tymethod.from_vec&quot;&gt;&lt;code&gt;from_vec&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../os/unix/ffi/trait.osstringext#tymethod.into_vec&quot;&gt;&lt;code&gt;into_vec&lt;/code&gt;&lt;/a&gt; methods that consume their arguments, and take or produce vectors of &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">また、Unix上で&lt;a href=&quot;struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt;実装 &lt;code&gt;std::os::unix::ffi::&lt;/code&gt; &lt;a href=&quot;../os/unix/ffi/trait.osstringext&quot;&gt; &lt;code&gt;OsStringExt&lt;/code&gt; の&lt;/a&gt;提供特性、&lt;a href=&quot;../os/unix/ffi/trait.osstringext#tymethod.from_vec&quot;&gt; &lt;code&gt;from_vec&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../os/unix/ffi/trait.osstringext#tymethod.into_vec&quot;&gt; &lt;code&gt;into_vec&lt;/code&gt; &lt;/a&gt;その引数を消費する方法を、と取るかの農産物ベクトル&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8bb517701cd0832c45c67c28da4b399a605014b6" translate="yes" xml:space="preserve">
          <source>Additionally, on Windows &lt;a href=&quot;struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; implements the &lt;code&gt;std::os::windows:ffi::&lt;/code&gt;&lt;a href=&quot;../os/windows/ffi/trait.osstringext&quot;&gt;&lt;code&gt;OsStringExt&lt;/code&gt;&lt;/a&gt; trait, which provides a &lt;a href=&quot;../os/windows/ffi/trait.osstringext#tymethod.from_wide&quot;&gt;&lt;code&gt;from_wide&lt;/code&gt;&lt;/a&gt; method. The result of this method is an &lt;a href=&quot;struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; which can be round-tripped to a Windows string losslessly.</source>
          <target state="translated">さらに、Windowsでは&lt;a href=&quot;struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt;は &lt;code&gt;std::os::windows:ffi::&lt;/code&gt; &lt;a href=&quot;../os/windows/ffi/trait.osstringext&quot;&gt; &lt;code&gt;OsStringExt&lt;/code&gt; &lt;/a&gt;トレイトを実装し、&lt;a href=&quot;../os/windows/ffi/trait.osstringext#tymethod.from_wide&quot;&gt; &lt;code&gt;from_wide&lt;/code&gt; &lt;/a&gt;メソッドを提供します。このメソッドの結果は、ロスレスでWindows文字列にラウンドトリップできる&lt;a href=&quot;struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="0f7d5354cdb11e461595056b1602a23178a20138" translate="yes" xml:space="preserve">
          <source>Additionally, taking a job off the channel queue involves mutating the &lt;code&gt;receiver&lt;/code&gt;, so the threads need a safe way to share and modify &lt;code&gt;receiver&lt;/code&gt;; otherwise, we might get race conditions (as covered in Chapter 16).</source>
          <target state="translated">また、チャネルキューから仕事を取ることは変異が含ま &lt;code&gt;receiver&lt;/code&gt; スレッドが共有および変更する安全な方法必要があるので、 &lt;code&gt;receiver&lt;/code&gt; 。そうしないと、競合状態になる可能性があります（第16章で説明）。</target>
        </trans-unit>
        <trans-unit id="0eb5702e98a03d052d40c8aabb340aee4d2332a4" translate="yes" xml:space="preserve">
          <source>Additionally, the &lt;code&gt;isize&lt;/code&gt; and &lt;code&gt;usize&lt;/code&gt; types depend on the kind of computer your program is running on: 64 bits if you&amp;rsquo;re on a 64-bit architecture and 32 bits if you&amp;rsquo;re on a 32-bit architecture.</source>
          <target state="translated">さらに、 &lt;code&gt;isize&lt;/code&gt; と &lt;code&gt;usize&lt;/code&gt; あなたは32ビットアーキテクチャにしている場合は、64ビットアーキテクチャおよび32ビットにしている場合は64ビット：種類は、あなたのプログラムを実行しているコンピュータの種類によって異なります。</target>
        </trans-unit>
        <trans-unit id="e3aa1d01d453f95734172c24dd2caadad96e569f" translate="yes" xml:space="preserve">
          <source>Additionally, the caller must ensure that writing &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; bytes to the given region of memory results in a valid value of &lt;code&gt;T&lt;/code&gt;. Using a region of memory typed as a &lt;code&gt;T&lt;/code&gt; that contains an invalid value of &lt;code&gt;T&lt;/code&gt; is undefined behavior.</source>
          <target state="translated">さらに、呼び出し元は、 &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; バイトをメモリの特定の領域に書き込むと、 &lt;code&gt;T&lt;/code&gt; の有効な値になることを確認する必要があります。無効な &lt;code&gt;T&lt;/code&gt; の値を含む &lt;code&gt;T&lt;/code&gt; として型指定されたメモリ領域を使用すると、動作が未定義になります。</target>
        </trans-unit>
        <trans-unit id="f3d0f5351803248ec3d677cec08967bab902a3b1" translate="yes" xml:space="preserve">
          <source>Additionally, the length of the string will be recalculated from the pointer.</source>
          <target state="translated">さらに、文字列の長さはポインタから再計算されます。</target>
        </trans-unit>
        <trans-unit id="5c93e6fb82861fecd56783e8c74a9dcd85037abd" translate="yes" xml:space="preserve">
          <source>Additionally, the lifetime &lt;code&gt;'a&lt;/code&gt; returned is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data. It is up to the caller to ensure that for the duration of this lifetime, the memory this pointer points to does not get accessed through any other pointer.</source>
          <target state="translated">また、寿命 &lt;code&gt;'a&lt;/code&gt; が返さが任意に選択され、必ずしもデータの実際の寿命を反映するものではありません。この存続期間中、このポインターが指すメモリーが他のポインターを介してアクセスされないようにするのは、呼び出し元の責任です。</target>
        </trans-unit>
        <trans-unit id="6e203e0080d407af9cc4130e8b5859f062bfa85b" translate="yes" xml:space="preserve">
          <source>Additionally, the lifetime &lt;code&gt;'a&lt;/code&gt; returned is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data. It is up to the caller to ensure that for the duration of this lifetime, the memory this pointer points to does not get written to outside of &lt;code&gt;UnsafeCell&amp;lt;U&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">また、寿命 &lt;code&gt;'a&lt;/code&gt; が返さが任意に選択され、必ずしもデータの実際の寿命を反映するものではありません。この存続期間中、このポインターが指すメモリーが &lt;code&gt;UnsafeCell&amp;lt;U&amp;gt;&lt;/code&gt; 外部に書き込まれないようにするのは、呼び出し元の責任です。</target>
        </trans-unit>
        <trans-unit id="cb09e099663e4fdfec9970e8541bfc0bbcb8c136" translate="yes" xml:space="preserve">
          <source>Additionally, the return value of this function is &lt;a href=&quot;type.result&quot;&gt;&lt;code&gt;fmt::Result&lt;/code&gt;&lt;/a&gt; which is a type alias of &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;(), &lt;/code&gt;&lt;a href=&quot;struct.error&quot;&gt;&lt;code&gt;std::fmt::Error&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. Formatting implementations should ensure that they propagate errors from the &lt;a href=&quot;struct.formatter&quot;&gt;&lt;code&gt;Formatter&lt;/code&gt;&lt;/a&gt; (e.g., when calling &lt;a href=&quot;../macro.write&quot;&gt;&lt;code&gt;write!&lt;/code&gt;&lt;/a&gt;). However, they should never return errors spuriously. That is, a formatting implementation must and may only return an error if the passed-in &lt;a href=&quot;struct.formatter&quot;&gt;&lt;code&gt;Formatter&lt;/code&gt;&lt;/a&gt; returns an error. This is because, contrary to what the function signature might suggest, string formatting is an infallible operation. This function only returns a result because writing to the underlying stream might fail and it must provide a way to propagate the fact that an error has occurred back up the stack.</source>
          <target state="translated">さらに、この関数の戻り値は&lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;(), &lt;/code&gt; &lt;a href=&quot;struct.error&quot;&gt; &lt;code&gt;std::fmt::Error&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; の型エイリアスである&lt;a href=&quot;type.result&quot;&gt; &lt;code&gt;fmt::Result&lt;/code&gt; &lt;/a&gt;です。フォーマッティング実装は、&lt;a href=&quot;struct.formatter&quot;&gt; &lt;code&gt;Formatter&lt;/code&gt; &lt;/a&gt;からのエラーを確実に伝播する必要があります（たとえば、&lt;a href=&quot;../macro.write&quot;&gt; &lt;code&gt;write!&lt;/code&gt; を&lt;/a&gt;呼び出すとき）。ただし、誤ってエラーを返すことはありません。つまり、フォーマットの実装は、渡された&lt;a href=&quot;struct.formatter&quot;&gt; &lt;code&gt;Formatter&lt;/code&gt; が&lt;/a&gt;エラーを返します。これは、関数のシグネチャが示唆するかもしれないこととは対照的に、文字列の書式設定は間違いのない操作であるためです。基になるストリームへの書き込みが失敗する可能性があるため、この関数は結果を返すだけであり、エラーがスタックで発生したという事実を伝搬する方法を提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="c51e0d7d6467942093ff85910240899ecb3312bc" translate="yes" xml:space="preserve">
          <source>Additionally, we can&amp;rsquo;t yet provide the &lt;code&gt;hello_macro&lt;/code&gt; function with default implementation that will print the name of the type the trait is implemented on: Rust doesn&amp;rsquo;t have reflection capabilities, so it can&amp;rsquo;t look up the type&amp;rsquo;s name at runtime. We need a macro to generate code at compile time.</source>
          <target state="translated">さらに、特性が実装されている型の名前を出力するデフォルトの実装を &lt;code&gt;hello_macro&lt;/code&gt; 関数に提供することはまだできません。Rustにはリフレクション機能がないため、実行時に型の名前を検索できません。コンパイル時にコードを生成するマクロが必要です。</target>
        </trans-unit>
        <trans-unit id="009b5112bedb7bc7f35022f14f637dbf23e46083" translate="yes" xml:space="preserve">
          <source>Additionally, you&amp;rsquo;ll need a linker of some kind. It&amp;rsquo;s likely one is already installed, but when you try to compile a Rust program and get errors indicating that a linker could not execute, that means a linker isn&amp;rsquo;t installed on your system and you&amp;rsquo;ll need to install one manually. C compilers usually come with the correct linker. Check your platform&amp;rsquo;s documentation for how to install a C compiler. Also, some common Rust packages depend on C code and will need a C compiler. Therefore, it might be worth installing one now.</source>
          <target state="translated">さらに、何らかのリンカーが必要になります。おそらく既にインストールされている可能性がありますが、Rustプログラムをコンパイルしようとして、リンカーが実行できなかったことを示すエラーが発生した場合は、システムにリンカーがインストールされていないため、手動でインストールする必要があります。Cコンパイラには通常、正しいリンカが付属しています。Cコンパイラのインストール方法については、プラットフォームのドキュメントを確認してください。また、一部の一般的なRustパッケージはCコードに依存しており、Cコンパイラが必要になります。したがって、今すぐインストールする価値があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="e8f6c433136e97e0a25822d00a70a971083e0df2" translate="yes" xml:space="preserve">
          <source>AddrParseError</source>
          <target state="translated">AddrParseError</target>
        </trans-unit>
        <trans-unit id="4db89e8ded7777748645ac21edd601141065b25a" translate="yes" xml:space="preserve">
          <source>AddrParseError::borrow</source>
          <target state="translated">AddrParseError::borrow</target>
        </trans-unit>
        <trans-unit id="ba5e2e5b2d73d903fb597da8809d6182f967fe26" translate="yes" xml:space="preserve">
          <source>AddrParseError::borrow_mut</source>
          <target state="translated">AddrParseError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="eec3364cb0e6e631bd766aeee8473eb3c5d8b783" translate="yes" xml:space="preserve">
          <source>AddrParseError::cause</source>
          <target state="translated">AddrParseError::cause</target>
        </trans-unit>
        <trans-unit id="c8650de9923d2b7b74fd1fb851b3c0ddd4117148" translate="yes" xml:space="preserve">
          <source>AddrParseError::clone</source>
          <target state="translated">AddrParseError::clone</target>
        </trans-unit>
        <trans-unit id="53ddfe6ad8c3351ba945f5b6cd6f647e3fa91325" translate="yes" xml:space="preserve">
          <source>AddrParseError::clone_from</source>
          <target state="translated">AddrParseError::clone_from</target>
        </trans-unit>
        <trans-unit id="08355c15003499e28a7411918357d4a2f001b709" translate="yes" xml:space="preserve">
          <source>AddrParseError::clone_into</source>
          <target state="translated">AddrParseError::clone_into</target>
        </trans-unit>
        <trans-unit id="25cb3b50c76347b7f6a85db7c339595baf0f003c" translate="yes" xml:space="preserve">
          <source>AddrParseError::description</source>
          <target state="translated">AddrParseError::description</target>
        </trans-unit>
        <trans-unit id="10b9b968cc3bf94f7c5c39dea8bf21d7dd54888c" translate="yes" xml:space="preserve">
          <source>AddrParseError::eq</source>
          <target state="translated">AddrParseError::eq</target>
        </trans-unit>
        <trans-unit id="49cf29f6a6f46e91fe5234ee3c02c53e59ab7578" translate="yes" xml:space="preserve">
          <source>AddrParseError::fmt</source>
          <target state="translated">AddrParseError::fmt</target>
        </trans-unit>
        <trans-unit id="60405d6d13708e4d85c176a98cb4377bfb7ee9d7" translate="yes" xml:space="preserve">
          <source>AddrParseError::from</source>
          <target state="translated">AddrParseError::from</target>
        </trans-unit>
        <trans-unit id="dbfcfd8a7eba25880c9888cb8208fce8e37c895d" translate="yes" xml:space="preserve">
          <source>AddrParseError::into</source>
          <target state="translated">AddrParseError::into</target>
        </trans-unit>
        <trans-unit id="81cea92a5c59d76a750c2dc91be0b6bebf9c1c4f" translate="yes" xml:space="preserve">
          <source>AddrParseError::ne</source>
          <target state="translated">AddrParseError::ne</target>
        </trans-unit>
        <trans-unit id="85b81474bbc6034c17600e25b324b8f7ff89e65b" translate="yes" xml:space="preserve">
          <source>AddrParseError::source</source>
          <target state="translated">AddrParseError::source</target>
        </trans-unit>
        <trans-unit id="ba1fd539045fde8129efbfd52fe6aba361392170" translate="yes" xml:space="preserve">
          <source>AddrParseError::to_owned</source>
          <target state="translated">AddrParseError::to_owned</target>
        </trans-unit>
        <trans-unit id="e2552e76eca8011ad4e06db73e14e51d90cd4e86" translate="yes" xml:space="preserve">
          <source>AddrParseError::to_string</source>
          <target state="translated">AddrParseError::to_string</target>
        </trans-unit>
        <trans-unit id="ff5f57540e8ea426311cdc19ccc6971134dcdb7f" translate="yes" xml:space="preserve">
          <source>AddrParseError::try_from</source>
          <target state="translated">AddrParseError::try_from</target>
        </trans-unit>
        <trans-unit id="bec376def9a1123d4f124dfc1a6840567151a145" translate="yes" xml:space="preserve">
          <source>AddrParseError::try_into</source>
          <target state="translated">AddrParseError::try_into</target>
        </trans-unit>
        <trans-unit id="26c560bba3044ee670c8f3ee436e252e0e2dad89" translate="yes" xml:space="preserve">
          <source>AddrParseError::type_id</source>
          <target state="translated">AddrParseError::type_id</target>
        </trans-unit>
        <trans-unit id="5cf7a9b41ce47d27a30e791bbfb6bec2ca816fcf" translate="yes" xml:space="preserve">
          <source>Address to pointer cast</source>
          <target state="translated">ポインタキャスト先のアドレス</target>
        </trans-unit>
        <trans-unit id="d7aa7412717eb74583761a8560faa539aaf27874" translate="yes" xml:space="preserve">
          <source>Address type can be any implementor of &lt;a href=&quot;trait.tosocketaddrs&quot;&gt;&lt;code&gt;ToSocketAddrs&lt;/code&gt;&lt;/a&gt; trait. See its documentation for concrete examples.</source>
          <target state="translated">アドレスタイプは、&lt;a href=&quot;trait.tosocketaddrs&quot;&gt; &lt;code&gt;ToSocketAddrs&lt;/code&gt; &lt;/a&gt;トレイトの任意の実装者にすることができます。具体的な例については、ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="5a1149884af3cef69504ddd9428373fea25aa2ca" translate="yes" xml:space="preserve">
          <source>Addresses returned by the operating system that are not IP addresses are silently ignored.</source>
          <target state="translated">オペレーティングシステムが返すIPアドレスではないアドレスは静かに無視されます。</target>
        </trans-unit>
        <trans-unit id="5915abc490110180d1540b6234219f020e04a70a" translate="yes" xml:space="preserve">
          <source>Adds a &lt;a href=&quot;struct.peekable#method.peek&quot;&gt;&lt;code&gt;peek&lt;/code&gt;&lt;/a&gt; method to an iterator. See its documentation for more information.</source>
          <target state="translated">&lt;a href=&quot;struct.peekable#method.peek&quot;&gt; &lt;code&gt;peek&lt;/code&gt; &lt;/a&gt;メソッドをイテレータに追加します。詳細については、ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="c870f816a116db65c4b82439ff891f426f80ff41" translate="yes" xml:space="preserve">
          <source>Adds a &lt;code&gt;usize&lt;/code&gt;, returning &lt;code&gt;None&lt;/code&gt; on overflow.</source>
          <target state="translated">&lt;code&gt;usize&lt;/code&gt; を追加し、オーバーフロー時に &lt;code&gt;None&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="31cf127eab5bb935c2abe6cc6bba90f4ae0b71a3" translate="yes" xml:space="preserve">
          <source>Adds a new entry to the list output.</source>
          <target state="translated">リスト出力に新しいエントリを追加します。</target>
        </trans-unit>
        <trans-unit id="15cb5f7efe200723c3b721e295fbebc13dfc9e31" translate="yes" xml:space="preserve">
          <source>Adds a new entry to the map output.</source>
          <target state="translated">マップ出力に新しいエントリを追加します。</target>
        </trans-unit>
        <trans-unit id="0ef3b59a4597ecf10372b8f11eb26c1a52f2f272" translate="yes" xml:space="preserve">
          <source>Adds a new entry to the set output.</source>
          <target state="translated">セット出力に新しいエントリを追加します。</target>
        </trans-unit>
        <trans-unit id="60f1cf0bd8c4a027b017ecaa893cb9c74c91f78b" translate="yes" xml:space="preserve">
          <source>Adds a new field to the generated struct output.</source>
          <target state="translated">生成された struct 出力に新しいフィールドを追加します。</target>
        </trans-unit>
        <trans-unit id="b8fafafece871a01042ed5a0ab5c6c9b2e80442c" translate="yes" xml:space="preserve">
          <source>Adds a new field to the generated tuple struct output.</source>
          <target state="translated">生成されたタプル構造体の出力に新しいフィールドを追加します。</target>
        </trans-unit>
        <trans-unit id="0b002c9af6c57cafdfe28d411ed57cf85e2ebe81" translate="yes" xml:space="preserve">
          <source>Adds a value to the set, replacing the existing value, if any, that is equal to the given one. Returns the replaced value.</source>
          <target state="translated">値をセットに追加し、指定した値と等しい値があればそれを置き換えます。置き換えた値を返します。</target>
        </trans-unit>
        <trans-unit id="82f4c899437f1a62750b1776b4b1b6599530f1e6" translate="yes" xml:space="preserve">
          <source>Adds a value to the set.</source>
          <target state="translated">セットに値を追加します。</target>
        </trans-unit>
        <trans-unit id="f1a3f6979754c5ca7c9e4122b44f7541e9636107" translate="yes" xml:space="preserve">
          <source>Adds an argument to pass to the program.</source>
          <target state="translated">プログラムに渡す引数を追加します。</target>
        </trans-unit>
        <trans-unit id="658707171b5a956fa506d45ca2578865d314c2a0" translate="yes" xml:space="preserve">
          <source>Adds an element first in the list.</source>
          <target state="translated">リストの最初に要素を追加します。</target>
        </trans-unit>
        <trans-unit id="969d7672cd1e94e2e3f766816cef88b15855a861" translate="yes" xml:space="preserve">
          <source>Adds multiple arguments to pass to the program.</source>
          <target state="translated">プログラムに渡す複数の引数を追加します。</target>
        </trans-unit>
        <trans-unit id="68adca23d26862cb362a13d5d500e729dc911a8b" translate="yes" xml:space="preserve">
          <source>Adds one to this step, returning the result.</source>
          <target state="translated">このステップに1つ追加し、結果を返します。</target>
        </trans-unit>
        <trans-unit id="0151250bd8bdb46ad8abec9aa6c7d2adc6f4d3c2" translate="yes" xml:space="preserve">
          <source>Adds or updates multiple environment variable mappings.</source>
          <target state="translated">複数の環境変数のマッピングを追加または更新します。</target>
        </trans-unit>
        <trans-unit id="c1ea158bb2722c6d5db848a523c49d2d1b4ef996" translate="yes" xml:space="preserve">
          <source>Adds support for special Unix file types such as block/character devices, pipes, and sockets.</source>
          <target state="translated">ブロック/文字デバイス、パイプ、ソケットなどの特殊な Unix ファイルタイプのサポートを追加しました。</target>
        </trans-unit>
        <trans-unit id="671bf2741316962d688bf4f15b0556af370525fd" translate="yes" xml:space="preserve">
          <source>Adds the contents of an iterator of entries to the list output.</source>
          <target state="translated">エントリのイテレータの内容をリスト出力に追加します。</target>
        </trans-unit>
        <trans-unit id="6172d9346f85a8afb18c30e9f6e11792ac6685f3" translate="yes" xml:space="preserve">
          <source>Adds the contents of an iterator of entries to the map output.</source>
          <target state="translated">エントリのイテレータの内容をマップ出力に追加します。</target>
        </trans-unit>
        <trans-unit id="45f4916d90bbb31a57ac59c642d372fc8465632a" translate="yes" xml:space="preserve">
          <source>Adds the contents of an iterator of entries to the set output.</source>
          <target state="translated">エントリのイテレータの内容をセット出力に追加します。</target>
        </trans-unit>
        <trans-unit id="525909640b425a3865879f7bf9b4776de0cbde79" translate="yes" xml:space="preserve">
          <source>Adds the key part of a new entry to the map output.</source>
          <target state="translated">新しいエントリのキー部分をマップ出力に追加します。</target>
        </trans-unit>
        <trans-unit id="82b33d8253f240296388fcf0db6ce4c17b122fb9" translate="yes" xml:space="preserve">
          <source>Adds the value part of a new entry to the map output.</source>
          <target state="translated">新しいエントリの値の部分をマップ出力に追加します。</target>
        </trans-unit>
        <trans-unit id="64dedb52a39f499be5ddacaf33bea0b6af530c2b" translate="yes" xml:space="preserve">
          <source>Adds to the current value, returning the previous value.</source>
          <target state="translated">現在の値に追加し、前の値を返します。</target>
        </trans-unit>
        <trans-unit id="fec400f1cdf6c0803479c71a8ae238f9468f9b58" translate="yes" xml:space="preserve">
          <source>Adds to the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">現在の値に加算して、前の値を返します。この固有の安定したバージョンで利用可能である &lt;code&gt;std::sync::atomic&lt;/code&gt; を介した種類 &lt;code&gt;fetch_add&lt;/code&gt; 渡すことによって、法&lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt;として &lt;code&gt;order&lt;/code&gt; 。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt; &lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="be9a5a4d4b7398c45da8fcba5bded3bbc8f71847" translate="yes" xml:space="preserve">
          <source>Adds to the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">現在の値に加算して、前の値を返します。この組み込み関数の安定化されたバージョンは、 &lt;code&gt;fetch_add&lt;/code&gt; &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt;を &lt;code&gt;order&lt;/code&gt; として渡すことにより、fetch_addメソッドを介して &lt;code&gt;std::sync::atomic&lt;/code&gt; タイプで使用できます。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt; &lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e8510188bc5ebdc1c7bffee425e4b31fab3c7278" translate="yes" xml:space="preserve">
          <source>Adds to the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">現在の値に加算して、前の値を返します。この組み込み関数の安定化バージョンは、 &lt;code&gt;fetch_add&lt;/code&gt; &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt;を &lt;code&gt;order&lt;/code&gt; として渡すことにより、fetch_addメソッドを介して &lt;code&gt;std::sync::atomic&lt;/code&gt; タイプで使用できます。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt; &lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5d050db3800c7dd71e5057e0d9def9358e61a419" translate="yes" xml:space="preserve">
          <source>Adds to the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">現在の値に加算して、前の値を返します。この組み込み関数の安定化されたバージョンは、 &lt;code&gt;fetch_add&lt;/code&gt; &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt;を &lt;code&gt;order&lt;/code&gt; として渡すことにより、fetch_addメソッドを介して &lt;code&gt;std::sync::atomic&lt;/code&gt; タイプで使用できます。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt; &lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1973476bdfd162d29c3bf0eb0f1911803377eae3" translate="yes" xml:space="preserve">
          <source>Adds to the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">現在の値に加算して、前の値を返します。この固有の安定したバージョンで利用可能である &lt;code&gt;std::sync::atomic&lt;/code&gt; を介した種類 &lt;code&gt;fetch_add&lt;/code&gt; 渡すことによって、法&lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt;として &lt;code&gt;order&lt;/code&gt; 。たとえば、&lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt; &lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="eb6c863d4412a4b55b1d93cf3d5f7516528289e4" translate="yes" xml:space="preserve">
          <source>Advance the internal cursor of the slice.</source>
          <target state="translated">スライスの内部カーソルを前進させます。</target>
        </trans-unit>
        <trans-unit id="b2ed5841682a101d798c6152b62dca74cfea4b15" translate="yes" xml:space="preserve">
          <source>Advance to the next arg.</source>
          <target state="translated">次のargに進む。</target>
        </trans-unit>
        <trans-unit id="96731dbaea6a5720dd33b64dc334ff765eec736a" translate="yes" xml:space="preserve">
          <source>Advanced Features</source>
          <target state="translated">高度な機能</target>
        </trans-unit>
        <trans-unit id="7f4668d91bf23526ef1f05a0e7de95630615e93b" translate="yes" xml:space="preserve">
          <source>Advanced Functions and Closures</source>
          <target state="translated">高度な機能とクロージャ</target>
        </trans-unit>
        <trans-unit id="d5d49bfe71b011aa5e9e308b0bd9089c84c3c245" translate="yes" xml:space="preserve">
          <source>Advanced Traits</source>
          <target state="translated">高度な特性</target>
        </trans-unit>
        <trans-unit id="ae95896c3a125d9a5e8ed95928ac9721dd8d3752" translate="yes" xml:space="preserve">
          <source>Advanced Types</source>
          <target state="translated">高度なタイプ</target>
        </trans-unit>
        <trans-unit id="9b4509b6a0eecdabec69457f9e139e56f305f9a7" translate="yes" xml:space="preserve">
          <source>Advanced functions and closures: function pointers and returning closures</source>
          <target state="translated">高度な関数とクロージャ:関数ポインタと戻り値のクロージャ</target>
        </trans-unit>
        <trans-unit id="9c622feb39e22136f98cc1cfffb6cc56c0cb6ac7" translate="yes" xml:space="preserve">
          <source>Advanced traits: associated types, default type parameters, fully qualified syntax, supertraits, and the newtype pattern in relation to traits</source>
          <target state="translated">高度な形質:関連付けられた型、デフォルトの型パラメータ、完全修飾構文、スーパー形質、形質に関連したニュータイプパターン</target>
        </trans-unit>
        <trans-unit id="d050af08a92ff2ff0056bb035493a0f2f1620de8" translate="yes" xml:space="preserve">
          <source>Advanced types: more about the newtype pattern, type aliases, the never type, and dynamically sized types</source>
          <target state="translated">高度な型:newtype パターン、型のエイリアス、never 型、動的なサイズの型についての詳細</target>
        </trans-unit>
        <trans-unit id="bc73315bb680ddc61259cb6b2cc7f603f7017af5" translate="yes" xml:space="preserve">
          <source>Advances the iterator and returns the next value.</source>
          <target state="translated">イテレータを進め、次の値を返します。</target>
        </trans-unit>
        <trans-unit id="47778efc70c16f19b03a33e09324cdfef37b8397" translate="yes" xml:space="preserve">
          <source>Advances the iterator and returns the next value. &lt;a href=&quot;../../../iter/trait.iterator#tymethod.next&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">イテレータを進め、次の値を返します。&lt;a href=&quot;../../../iter/trait.iterator#tymethod.next&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e5c10d1dad50204036d6641dc96f179feac3c880" translate="yes" xml:space="preserve">
          <source>Advances the iterator and returns the next value. &lt;a href=&quot;../../iter/trait.iterator#tymethod.next&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">イテレータを進め、次の値を返します。&lt;a href=&quot;../../iter/trait.iterator#tymethod.next&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e0d17cb524aa65c6531ab7f58b22a2915be47179" translate="yes" xml:space="preserve">
          <source>Advances the iterator and returns the next value. &lt;a href=&quot;../iter/trait.iterator#tymethod.next&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">イテレータを進め、次の値を返します。&lt;a href=&quot;../iter/trait.iterator#tymethod.next&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2af190b4bf87220daaa7fcdfebb435d1dda577b1" translate="yes" xml:space="preserve">
          <source>Advances the iterator and returns the next value. &lt;a href=&quot;iter/trait.iterator#tymethod.next&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">イテレータを進め、次の値を返します。&lt;a href=&quot;iter/trait.iterator#tymethod.next&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="75ff050bc0f28af247ba9f7e987965071e370a8f" translate="yes" xml:space="preserve">
          <source>Advances the iterator and returns the next value. &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">イテレータを進め、次の値を返します。&lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6c629d1551783824351df46023949d62af853825" translate="yes" xml:space="preserve">
          <source>Advances the iterator by &lt;code&gt;n&lt;/code&gt; elements.</source>
          <target state="translated">イテレータを &lt;code&gt;n&lt;/code&gt; 個の要素だけ進めます。</target>
        </trans-unit>
        <trans-unit id="c9fef351384b0144be153be53f79c7fc476bedfc" translate="yes" xml:space="preserve">
          <source>Advances the iterator by &lt;code&gt;n&lt;/code&gt; elements. &lt;a href=&quot;../../../iter/trait.iterator#method.advance_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">イテレータを &lt;code&gt;n&lt;/code&gt; 個の要素だけ進めます。&lt;a href=&quot;../../../iter/trait.iterator#method.advance_by&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="41de8018927ed7b54950980aec11f8f12d46606f" translate="yes" xml:space="preserve">
          <source>Advances the iterator by &lt;code&gt;n&lt;/code&gt; elements. &lt;a href=&quot;../../iter/trait.iterator#method.advance_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">イテレータを &lt;code&gt;n&lt;/code&gt; 個の要素だけ進めます。&lt;a href=&quot;../../iter/trait.iterator#method.advance_by&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="09741f9824923fbfa016237025da37c62ee69dcc" translate="yes" xml:space="preserve">
          <source>Advances the iterator by &lt;code&gt;n&lt;/code&gt; elements. &lt;a href=&quot;../iter/trait.iterator#method.advance_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">イテレータを &lt;code&gt;n&lt;/code&gt; 個の要素だけ進めます。&lt;a href=&quot;../iter/trait.iterator#method.advance_by&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5c3b9d2faa7136ddd042e31d3939c786f1c8da2c" translate="yes" xml:space="preserve">
          <source>Advances the iterator by &lt;code&gt;n&lt;/code&gt; elements. &lt;a href=&quot;iter/trait.iterator#method.advance_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">イテレータを &lt;code&gt;n&lt;/code&gt; 個の要素だけ進めます。&lt;a href=&quot;iter/trait.iterator#method.advance_by&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="74fde24899e07da847358f17c288cfcfe8ae74ea" translate="yes" xml:space="preserve">
          <source>Advances the iterator by &lt;code&gt;n&lt;/code&gt; elements. &lt;a href=&quot;trait.iterator#method.advance_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">イテレータを &lt;code&gt;n&lt;/code&gt; 個の要素だけ進めます。&lt;a href=&quot;trait.iterator#method.advance_by&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4d66799c08b5e49880157cde9e0d13d223a5c3a3" translate="yes" xml:space="preserve">
          <source>Advances the iterator from the back by &lt;code&gt;n&lt;/code&gt; elements.</source>
          <target state="translated">イテレータを後ろから &lt;code&gt;n&lt;/code&gt; 要素進めます。</target>
        </trans-unit>
        <trans-unit id="4f1f4e504d47f61c437fd02db056daa6ec47dc6c" translate="yes" xml:space="preserve">
          <source>Advances the iterator from the back by &lt;code&gt;n&lt;/code&gt; elements. &lt;a href=&quot;../../iter/trait.doubleendediterator#method.advance_back_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">イテレータを後ろから &lt;code&gt;n&lt;/code&gt; 要素進めます。&lt;a href=&quot;../../iter/trait.doubleendediterator#method.advance_back_by&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4d59517951217a4fde7238ff6227ce7834fa1b5e" translate="yes" xml:space="preserve">
          <source>Advances the iterator from the back by &lt;code&gt;n&lt;/code&gt; elements. &lt;a href=&quot;../iter/trait.doubleendediterator#method.advance_back_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">イテレータを後ろから &lt;code&gt;n&lt;/code&gt; 要素進めます。&lt;a href=&quot;../iter/trait.doubleendediterator#method.advance_back_by&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="34bb721017aea2eeaededef2c5c856023eca871d" translate="yes" xml:space="preserve">
          <source>Advances the iterator from the back by &lt;code&gt;n&lt;/code&gt; elements. &lt;a href=&quot;iter/trait.doubleendediterator#method.advance_back_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">イテレータを後ろから &lt;code&gt;n&lt;/code&gt; 要素進めます。&lt;a href=&quot;iter/trait.doubleendediterator#method.advance_back_by&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="148c4a64097476a8bb5779b8f3210d3b2962ff05" translate="yes" xml:space="preserve">
          <source>Advances the iterator from the back by &lt;code&gt;n&lt;/code&gt; elements. &lt;a href=&quot;trait.doubleendediterator#method.advance_back_by&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">イテレータを後ろから &lt;code&gt;n&lt;/code&gt; 要素進めます。&lt;a href=&quot;trait.doubleendediterator#method.advance_back_by&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fc5df98fcac936e0dd69b6d3ac4bff062078ea9f" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;#[test]&lt;/code&gt; we add the &lt;code&gt;#[ignore]&lt;/code&gt; line to the test we want to exclude. Now when we run our tests, &lt;code&gt;it_works&lt;/code&gt; runs, but &lt;code&gt;expensive_test&lt;/code&gt; doesn&amp;rsquo;t:</source>
          <target state="translated">&lt;code&gt;#[test]&lt;/code&gt; の後に、除外するテストに &lt;code&gt;#[ignore]&lt;/code&gt; 行を追加します。我々はテストを実行すると、 &lt;code&gt;it_works&lt;/code&gt; が実行されますが、 &lt;code&gt;expensive_test&lt;/code&gt; はしません。</target>
        </trans-unit>
        <trans-unit id="471c4d510c078cce605f07ee5e3b57ac50f1448c" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;crate&lt;/code&gt;, we include each of the successive modules until we make our way to &lt;code&gt;add_to_waitlist&lt;/code&gt;. You can imagine a filesystem with the same structure, and we&amp;rsquo;d specify the path &lt;code&gt;/front_of_house/hosting/add_to_waitlist&lt;/code&gt; to run the &lt;code&gt;add_to_waitlist&lt;/code&gt; program; using the &lt;code&gt;crate&lt;/code&gt; name to start from the crate root is like using &lt;code&gt;/&lt;/code&gt; to start from the filesystem root in your shell.</source>
          <target state="translated">&lt;code&gt;crate&lt;/code&gt; 後、 &lt;code&gt;add_to_waitlist&lt;/code&gt; に進むまで、連続する各モジュールを含めます。同じ構造のファイルシステムを想像できます &lt;code&gt;/front_of_house/hosting/add_to_waitlist&lt;/code&gt; &lt;code&gt;add_to_waitlist&lt;/code&gt; プログラムを実行するには、パス/ front_of_house / hosting / add_to_waitlistを指定します。 &lt;code&gt;crate&lt;/code&gt; 名を使用してクレートルートから開始するのは、 &lt;code&gt;/&lt;/code&gt; を使用してシェルのファイルシステムルートから開始するのと同じです。</target>
        </trans-unit>
        <trans-unit id="72900f50989a74635a45f599f7af957665be760a" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;false&lt;/code&gt; is returned, &lt;code&gt;skip_while()&lt;/code&gt;'s job is over, and the rest of the elements are yielded.</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; が返された後、 &lt;code&gt;skip_while()&lt;/code&gt; のジョブは終了し、残りの要素が生成されます。</target>
        </trans-unit>
        <trans-unit id="a8fe2c79e763fccf582bfde64f2cf9442ce9db7c" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;false&lt;/code&gt; is returned, &lt;code&gt;take_while()&lt;/code&gt;'s job is over, and the rest of the elements are ignored.</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; が返された後、 &lt;code&gt;take_while()&lt;/code&gt; のジョブは終了し、残りの要素は無視されます。</target>
        </trans-unit>
        <trans-unit id="d9d86d37284d13e516ed39f67cc2c963b4451b66" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;leaf&lt;/code&gt; is created, its &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; has a strong count of 1 and a weak count of 0. In the inner scope, we create &lt;code&gt;branch&lt;/code&gt; and associate it with &lt;code&gt;leaf&lt;/code&gt;, at which point when we print the counts, the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; in &lt;code&gt;branch&lt;/code&gt; will have a strong count of 1 and a weak count of 1 (for &lt;code&gt;leaf.parent&lt;/code&gt; pointing to &lt;code&gt;branch&lt;/code&gt; with a &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt;). When we print the counts in &lt;code&gt;leaf&lt;/code&gt;, we&amp;rsquo;ll see it will have a strong count of 2, because &lt;code&gt;branch&lt;/code&gt; now has a clone of the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; of &lt;code&gt;leaf&lt;/code&gt; stored in &lt;code&gt;branch.children&lt;/code&gt;, but will still have a weak count of 0.</source>
          <target state="translated">&lt;code&gt;leaf&lt;/code&gt; が作成された後、その &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; は1の強いカウントと0の弱いカウントを持ちます。内部スコープで &lt;code&gt;branch&lt;/code&gt; を作成し、それを &lt;code&gt;leaf&lt;/code&gt; に関連付けます。この時点で、カウントを出力するとき、 &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; &lt;code&gt;branch&lt;/code&gt; 内のカウントは強いカウント1と弱いカウント1になります（ &lt;code&gt;leaf.parent&lt;/code&gt; が &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; &lt;code&gt;branch&lt;/code&gt; を指している場合）。我々はカウントを印刷するとき &lt;code&gt;leaf&lt;/code&gt; 、我々はので、それは、2の強力な数を持っています表示されます &lt;code&gt;branch&lt;/code&gt; 今のクローンがある &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; の &lt;code&gt;leaf&lt;/code&gt; に保存されている &lt;code&gt;branch.children&lt;/code&gt; を、ただしカウントは0のままです。</target>
        </trans-unit>
        <trans-unit id="4cde8475e322a79219c56c165831cd534e7a6b56" translate="yes" xml:space="preserve">
          <source>After an iterator returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, future calls may or may not yield &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some(T)&lt;/code&gt;&lt;/a&gt; again. &lt;code&gt;fuse()&lt;/code&gt; adapts an iterator, ensuring that after a &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is given, it will always return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; forever.</source>
          <target state="translated">イテレータが&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; を&lt;/a&gt;返した後は、今後の呼び出しで&lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some(T)&lt;/code&gt; が&lt;/a&gt;再び生成される場合と生成されない場合があります。 &lt;code&gt;fuse()&lt;/code&gt; はイテレータを適応させ、&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;が指定された後は常に永久に&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;を返すようにします。</target>
        </trans-unit>
        <trans-unit id="568e22b9792d58baafe078fb9cf96ab4d0418d3f" translate="yes" xml:space="preserve">
          <source>After applying this closure to every element of the iterator, &lt;code&gt;fold()&lt;/code&gt; returns the accumulator.</source>
          <target state="translated">イテレータのすべての要素にこのクロージャを適用した後、 &lt;code&gt;fold()&lt;/code&gt; はアキュムレータを返します。</target>
        </trans-unit>
        <trans-unit id="c5c6fbc1d802b5c2313fc5d60dee8a9485ff2828" translate="yes" xml:space="preserve">
          <source>After applying this closure to every element of the iterator, &lt;code&gt;rfold()&lt;/code&gt; returns the accumulator.</source>
          <target state="translated">このクロージャーをイテレーターのすべてのエレメントに適用した後、 &lt;code&gt;rfold()&lt;/code&gt; はアキュムレーターを戻します。</target>
        </trans-unit>
        <trans-unit id="dbffd4bfa583f6bbb8aa4395e63df871ca521db4" translate="yes" xml:space="preserve">
          <source>After calling &lt;code&gt;v.as_mut_ptr()&lt;/code&gt; and transmitting the ownership of the data to &lt;code&gt;s&lt;/code&gt;, the &lt;code&gt;v&lt;/code&gt; value is invalid. Even when a value is just moved to &lt;code&gt;mem::forget&lt;/code&gt; (which won't inspect it), some types have strict requirements on their values that make them invalid when dangling or no longer owned. Using invalid values in any way, including passing them to or returning them from functions, constitutes undefined behavior and may break the assumptions made by the compiler.</source>
          <target state="translated">&lt;code&gt;v.as_mut_ptr()&lt;/code&gt; を呼び出し、データの所有権を &lt;code&gt;s&lt;/code&gt; に送信した後、 &lt;code&gt;v&lt;/code&gt; 値は無効です。値が &lt;code&gt;mem::forget&lt;/code&gt; （検査されない）に移動された場合でも、一部のタイプには値に厳しい要件があり、ぶら下がっているときや所有されていないときに無効になります。関数への受け渡しや関数からの返送など、何らかの方法で無効な値を使用すると、未定義の動作が構成され、コンパイラによる想定が破られる可能性があります。</target>
        </trans-unit>
        <trans-unit id="bc617f1ae4108d460b1173f3a7067fe06a8d7ed6" translate="yes" xml:space="preserve">
          <source>After calling this function, the caller is responsible for the memory previously managed by the &lt;code&gt;Box&lt;/code&gt;. In particular, the caller should properly destroy &lt;code&gt;T&lt;/code&gt; and release the memory, taking into account the &lt;a href=&quot;index#memory-layout&quot;&gt;memory layout&lt;/a&gt; used by &lt;code&gt;Box&lt;/code&gt;. The easiest way to do this is to convert the raw pointer back into a &lt;code&gt;Box&lt;/code&gt; with the &lt;a href=&quot;struct.box#method.from_raw&quot;&gt;&lt;code&gt;Box::from_raw&lt;/code&gt;&lt;/a&gt; function, allowing the &lt;code&gt;Box&lt;/code&gt; destructor to perform the cleanup.</source>
          <target state="translated">この関数を呼び出した後、呼び出し元は以前に &lt;code&gt;Box&lt;/code&gt; によって管理されていたメモリを担当します。特に、呼び出し元は、 &lt;code&gt;Box&lt;/code&gt; で使用される&lt;a href=&quot;index#memory-layout&quot;&gt;メモリレイアウト&lt;/a&gt;を考慮して、 &lt;code&gt;T&lt;/code&gt; を適切に破棄し、メモリを解放する必要があります。これを行う最も簡単な方法は、&lt;a href=&quot;struct.box#method.from_raw&quot;&gt; &lt;code&gt;Box::from_raw&lt;/code&gt; &lt;/a&gt;関数を使用して生のポインターを &lt;code&gt;Box&lt;/code&gt; に戻し、 &lt;code&gt;Box&lt;/code&gt; デストラクタがクリーンアップを実行できるようにすることです。</target>
        </trans-unit>
        <trans-unit id="47bfd04ad6639821cf514c2ef1fb0d7b6f63839d" translate="yes" xml:space="preserve">
          <source>After calling this function, the caller is responsible for the memory previously managed by the &lt;code&gt;Box&lt;/code&gt;. In particular, the caller should properly destroy &lt;code&gt;T&lt;/code&gt; and release the memory. The easiest way to do so is to convert the &lt;code&gt;NonNull&amp;lt;T&amp;gt;&lt;/code&gt; pointer into a raw pointer and back into a &lt;code&gt;Box&lt;/code&gt; with the &lt;a href=&quot;struct.box#method.from_raw&quot;&gt;&lt;code&gt;Box::from_raw&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">この関数を呼び出した後、呼び出し元は以前に &lt;code&gt;Box&lt;/code&gt; によって管理されていたメモリを担当します。特に、呼び出し元は &lt;code&gt;T&lt;/code&gt; を適切に破棄し、メモリを解放する必要があります。そうするための最も簡単な方法は、変換することである &lt;code&gt;NonNull&amp;lt;T&amp;gt;&lt;/code&gt; に生のポインタと背中にポインタ &lt;code&gt;Box&lt;/code&gt; と&lt;a href=&quot;struct.box#method.from_raw&quot;&gt; &lt;code&gt;Box::from_raw&lt;/code&gt; &lt;/a&gt;機能。</target>
        </trans-unit>
        <trans-unit id="4e43a947242c53bd7c33db133c10548b5bd4c117" translate="yes" xml:space="preserve">
          <source>After calling this function, the caller is responsible for the memory previously managed by the &lt;code&gt;String&lt;/code&gt;. The only way to do this is to convert the raw pointer, length, and capacity back into a &lt;code&gt;String&lt;/code&gt; with the &lt;a href=&quot;struct.string#method.from_raw_parts&quot;&gt;&lt;code&gt;from_raw_parts&lt;/code&gt;&lt;/a&gt; function, allowing the destructor to perform the cleanup.</source>
          <target state="translated">この関数を呼び出した後、呼び出し元は、以前に &lt;code&gt;String&lt;/code&gt; によって管理されていたメモリを担当します。これを行う唯一の方法は、&lt;a href=&quot;struct.string#method.from_raw_parts&quot;&gt; &lt;code&gt;from_raw_parts&lt;/code&gt; &lt;/a&gt;関数を使用して、生のポインター、長さ、および容量を &lt;code&gt;String&lt;/code&gt; に変換し直し、デストラクタがクリーンアップを実行できるようにすることです。</target>
        </trans-unit>
        <trans-unit id="102d1de8629b57b21dac90f6d521b49048558b05" translate="yes" xml:space="preserve">
          <source>After calling this function, the caller is responsible for the memory previously managed by the &lt;code&gt;Vec&lt;/code&gt;. The only way to do this is to convert the raw pointer, length, and capacity back into a &lt;code&gt;Vec&lt;/code&gt; with the &lt;a href=&quot;struct.vec#method.from_raw_parts&quot;&gt;&lt;code&gt;from_raw_parts&lt;/code&gt;&lt;/a&gt; function, allowing the destructor to perform the cleanup.</source>
          <target state="translated">この関数を呼び出した後、呼び出し元は以前に &lt;code&gt;Vec&lt;/code&gt; によって管理されていたメモリを担当します。これを行う唯一の方法は、&lt;a href=&quot;struct.vec#method.from_raw_parts&quot;&gt; &lt;code&gt;from_raw_parts&lt;/code&gt; &lt;/a&gt;関数を使用して生のポインター、長さ、および容量を &lt;code&gt;Vec&lt;/code&gt; に変換し直し、デストラクタがクリーンアップを実行できるようにすることです。</target>
        </trans-unit>
        <trans-unit id="3d10c7bbc7ba580c584a70857a59b76ef027af83" translate="yes" xml:space="preserve">
          <source>After calling this function, the raw pointer is owned by the resulting &lt;code&gt;Box&lt;/code&gt;. Specifically, the &lt;code&gt;Box&lt;/code&gt; destructor will call the destructor of &lt;code&gt;T&lt;/code&gt; and free the allocated memory. For this to be safe, the memory must have been allocated in accordance with the &lt;a href=&quot;index#memory-layout&quot;&gt;memory layout&lt;/a&gt; used by &lt;code&gt;Box&lt;/code&gt; .</source>
          <target state="translated">この関数を呼び出した後、生のポインタは結果の &lt;code&gt;Box&lt;/code&gt; によって所有されます。具体的には、 &lt;code&gt;Box&lt;/code&gt; デストラクタは &lt;code&gt;T&lt;/code&gt; のデストラクタを呼び出し、割り当てられたメモリを解放します。これを安全にするには、 &lt;code&gt;Box&lt;/code&gt; が使用する&lt;a href=&quot;index#memory-layout&quot;&gt;メモリレイアウト&lt;/a&gt;に従ってメモリを割り当てる必要があります。</target>
        </trans-unit>
        <trans-unit id="ef76ea7ae2deed3f017eb7251cbd0d7c334a7aaf" translate="yes" xml:space="preserve">
          <source>After changing &lt;code&gt;println!&lt;/code&gt; to &lt;code&gt;eprintln!&lt;/code&gt;, let&amp;rsquo;s run the program again in the same way, without any arguments and redirecting standard output with &lt;code&gt;&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;println!&lt;/code&gt; 変更した後！ &lt;code&gt;eprintln!&lt;/code&gt; 、引数なしで標準出力を &lt;code&gt;&amp;gt;&lt;/code&gt; でリダイレクトして、同じ方法でもう一度プログラムを実行してみましょう。</target>
        </trans-unit>
        <trans-unit id="93133f68d39862996d0135a231d1905a95e950c2" translate="yes" xml:space="preserve">
          <source>After creating a &lt;code&gt;TcpListener&lt;/code&gt; by &lt;a href=&quot;#method.bind&quot;&gt;&lt;code&gt;bind&lt;/code&gt;&lt;/a&gt;ing it to a socket address, it listens for incoming TCP connections. These can be accepted by calling &lt;a href=&quot;#method.accept&quot;&gt;&lt;code&gt;accept&lt;/code&gt;&lt;/a&gt; or by iterating over the &lt;a href=&quot;struct.incoming&quot;&gt;&lt;code&gt;Incoming&lt;/code&gt;&lt;/a&gt; iterator returned by &lt;a href=&quot;#method.incoming&quot;&gt;&lt;code&gt;incoming&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;TcpListener&lt;/code&gt; をソケットアドレスに&lt;a href=&quot;#method.bind&quot;&gt; &lt;code&gt;bind&lt;/code&gt; &lt;/a&gt;作成した後、着信TCP接続をリッスンします。これらは、&lt;a href=&quot;#method.accept&quot;&gt; &lt;code&gt;accept&lt;/code&gt; &lt;/a&gt;を呼び出すか、&lt;a href=&quot;#method.incoming&quot;&gt; &lt;code&gt;incoming&lt;/code&gt; &lt;/a&gt;によって返された&lt;a href=&quot;struct.incoming&quot;&gt; &lt;code&gt;Incoming&lt;/code&gt; &lt;/a&gt;イテレータを反復することによって受け入れることができます。</target>
        </trans-unit>
        <trans-unit id="06868983dd9010816d16a947a2feebe64fc6c151" translate="yes" xml:space="preserve">
          <source>After creating a &lt;code&gt;TcpListener&lt;/code&gt; by &lt;a href=&quot;struct.tcplistener#method.bind&quot;&gt;&lt;code&gt;bind&lt;/code&gt;&lt;/a&gt;ing it to a socket address, it listens for incoming TCP connections. These can be accepted by calling &lt;a href=&quot;struct.tcplistener#method.accept&quot;&gt;&lt;code&gt;accept&lt;/code&gt;&lt;/a&gt; or by iterating over the &lt;a href=&quot;struct.incoming&quot;&gt;&lt;code&gt;Incoming&lt;/code&gt;&lt;/a&gt; iterator returned by &lt;a href=&quot;struct.tcplistener#method.incoming&quot;&gt;&lt;code&gt;incoming&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;TcpListener&lt;/code&gt; をソケットアドレスに&lt;a href=&quot;struct.tcplistener#method.bind&quot;&gt; &lt;code&gt;bind&lt;/code&gt; &lt;/a&gt;作成した後、着信TCP接続をリッスンします。これらは、&lt;a href=&quot;struct.tcplistener#method.accept&quot;&gt; &lt;code&gt;accept&lt;/code&gt; &lt;/a&gt;を呼び出すか、&lt;a href=&quot;struct.tcplistener#method.incoming&quot;&gt; &lt;code&gt;incoming&lt;/code&gt; &lt;/a&gt;によって返された&lt;a href=&quot;struct.incoming&quot;&gt; &lt;code&gt;Incoming&lt;/code&gt; &lt;/a&gt;イテレータを反復処理することによって受け入れることができます。</target>
        </trans-unit>
        <trans-unit id="422e2b7f3798df18a9e41b4f6d8230c5f7fbaae2" translate="yes" xml:space="preserve">
          <source>After creating a &lt;code&gt;TcpStream&lt;/code&gt; by either &lt;a href=&quot;#method.connect&quot;&gt;&lt;code&gt;connect&lt;/code&gt;&lt;/a&gt;ing to a remote host or &lt;a href=&quot;struct.tcplistener#method.accept&quot;&gt;&lt;code&gt;accept&lt;/code&gt;&lt;/a&gt;ing a connection on a &lt;a href=&quot;struct.tcplistener&quot;&gt;&lt;code&gt;TcpListener&lt;/code&gt;&lt;/a&gt;, data can be transmitted by &lt;a href=&quot;../io/trait.read&quot;&gt;reading&lt;/a&gt; and &lt;a href=&quot;../io/trait.write&quot;&gt;writing&lt;/a&gt; to it.</source>
          <target state="translated">作成した後 &lt;code&gt;TcpStream&lt;/code&gt; いずれかの方法で&lt;a href=&quot;#method.connect&quot;&gt; &lt;code&gt;connect&lt;/code&gt; &lt;/a&gt;、リモートホストへのINGのか&lt;a href=&quot;struct.tcplistener#method.accept&quot;&gt; &lt;code&gt;accept&lt;/code&gt; &lt;/a&gt;の接続INGの&lt;a href=&quot;struct.tcplistener&quot;&gt; &lt;code&gt;TcpListener&lt;/code&gt; を&lt;/a&gt;、データを送信できる&lt;a href=&quot;../io/trait.read&quot;&gt;読書&lt;/a&gt;と&lt;a href=&quot;../io/trait.write&quot;&gt;書く&lt;/a&gt;ことに。</target>
        </trans-unit>
        <trans-unit id="dafc89a72358e6711ac4be0166b7dcfdffe57a68" translate="yes" xml:space="preserve">
          <source>After creating a &lt;code&gt;TcpStream&lt;/code&gt; by either &lt;a href=&quot;struct.tcpstream#method.connect&quot;&gt;&lt;code&gt;connect&lt;/code&gt;&lt;/a&gt;ing to a remote host or &lt;a href=&quot;struct.tcplistener#method.accept&quot;&gt;&lt;code&gt;accept&lt;/code&gt;&lt;/a&gt;ing a connection on a &lt;a href=&quot;struct.tcplistener&quot;&gt;&lt;code&gt;TcpListener&lt;/code&gt;&lt;/a&gt;, data can be transmitted by &lt;a href=&quot;../io/trait.read&quot;&gt;reading&lt;/a&gt; and &lt;a href=&quot;../io/trait.write&quot;&gt;writing&lt;/a&gt; to it.</source>
          <target state="translated">作成した後 &lt;code&gt;TcpStream&lt;/code&gt; いずれかの方法で&lt;a href=&quot;struct.tcpstream#method.connect&quot;&gt; &lt;code&gt;connect&lt;/code&gt; &lt;/a&gt;、リモートホストへのINGのか&lt;a href=&quot;struct.tcplistener#method.accept&quot;&gt; &lt;code&gt;accept&lt;/code&gt; &lt;/a&gt;の接続INGの&lt;a href=&quot;struct.tcplistener&quot;&gt; &lt;code&gt;TcpListener&lt;/code&gt; を&lt;/a&gt;、データを送信できる&lt;a href=&quot;../io/trait.read&quot;&gt;読書&lt;/a&gt;と&lt;a href=&quot;../io/trait.write&quot;&gt;書く&lt;/a&gt;ことに。</target>
        </trans-unit>
        <trans-unit id="b9be232588db8403f71ee1411aa554678f33dfa7" translate="yes" xml:space="preserve">
          <source>After creating a &lt;code&gt;UdpSocket&lt;/code&gt; by &lt;a href=&quot;#method.bind&quot;&gt;&lt;code&gt;bind&lt;/code&gt;&lt;/a&gt;ing it to a socket address, data can be &lt;a href=&quot;#method.send_to&quot;&gt;sent to&lt;/a&gt; and &lt;a href=&quot;#method.recv_from&quot;&gt;received from&lt;/a&gt; any other socket address.</source>
          <target state="translated">作成後 &lt;code&gt;UdpSocket&lt;/code&gt; によって&lt;a href=&quot;#method.bind&quot;&gt; &lt;code&gt;bind&lt;/code&gt; &lt;/a&gt;ソケットアドレスにINGのは、データをすることができる&lt;a href=&quot;#method.send_to&quot;&gt;に送信&lt;/a&gt;及び&lt;a href=&quot;#method.recv_from&quot;&gt;から受信した&lt;/a&gt;他のソケットアドレス。</target>
        </trans-unit>
        <trans-unit id="394b482d2eb5a6a4fcc8d7fdff6cfe2cd24f75e2" translate="yes" xml:space="preserve">
          <source>After creating a &lt;code&gt;UdpSocket&lt;/code&gt; by &lt;a href=&quot;struct.udpsocket#method.bind&quot;&gt;&lt;code&gt;bind&lt;/code&gt;&lt;/a&gt;ing it to a socket address, data can be &lt;a href=&quot;struct.udpsocket#method.send_to&quot;&gt;sent to&lt;/a&gt; and &lt;a href=&quot;struct.udpsocket#method.recv_from&quot;&gt;received from&lt;/a&gt; any other socket address.</source>
          <target state="translated">作成後 &lt;code&gt;UdpSocket&lt;/code&gt; によって&lt;a href=&quot;struct.udpsocket#method.bind&quot;&gt; &lt;code&gt;bind&lt;/code&gt; &lt;/a&gt;ソケットアドレスにINGのは、データをすることができる&lt;a href=&quot;struct.udpsocket#method.send_to&quot;&gt;に送信&lt;/a&gt;及び&lt;a href=&quot;struct.udpsocket#method.recv_from&quot;&gt;から受信した&lt;/a&gt;他のソケットアドレス。</target>
        </trans-unit>
        <trans-unit id="3fc506cb877752d66797eaa2996ad1bfc89765b7" translate="yes" xml:space="preserve">
          <source>After creating a new &lt;code&gt;Job&lt;/code&gt; instance using the closure we get in &lt;code&gt;execute&lt;/code&gt;, we send that job down the sending end of the channel. We&amp;rsquo;re calling &lt;code&gt;unwrap&lt;/code&gt; on &lt;code&gt;send&lt;/code&gt; for the case that sending fails. This might happen if, for example, we stop all our threads from executing, meaning the receiving end has stopped receiving new messages. At the moment, we can&amp;rsquo;t stop our threads from executing: our threads continue executing as long as the pool exists. The reason we use &lt;code&gt;unwrap&lt;/code&gt; is that we know the failure case won&amp;rsquo;t happen, but the compiler doesn&amp;rsquo;t know that.</source>
          <target state="translated">&lt;code&gt;execute&lt;/code&gt; で取得したクロージャーを使用して新しい &lt;code&gt;Job&lt;/code&gt; インスタンスを作成した後、そのジョブをチャネルの送信側に送信します。送信が失敗した場合のために、 &lt;code&gt;send&lt;/code&gt; に &lt;code&gt;unwrap&lt;/code&gt; を呼び出します。これは、たとえば、すべてのスレッドの実行を停止した場合、つまり受信側が新しいメッセージの受信を停止した場合に発生する可能性があります。現時点では、スレッドの実行を停止することはできません。プールが存在する限り、スレッドは実行を継続します。 &lt;code&gt;unwrap&lt;/code&gt; を使用する理由は、失敗のケースが発生しないことはわかっていますが、コンパイラはそれを知らないためです。</target>
        </trans-unit>
        <trans-unit id="458779f7008edf7b181827b22b99edf77f39bc41" translate="yes" xml:space="preserve">
          <source>After dropping the lock, we can print the mutex value and see that we were able to change the inner &lt;code&gt;i32&lt;/code&gt; to 6.</source>
          <target state="translated">ロックを削除した後、mutex値を出力して、内部の &lt;code&gt;i32&lt;/code&gt; を6 に変更できたことを確認できます。</target>
        </trans-unit>
        <trans-unit id="04760e628105c26e60bea171285ea7fc05de2cc2" translate="yes" xml:space="preserve">
          <source>After implementing the trait, we can call the methods on instances of &lt;code&gt;NewsArticle&lt;/code&gt; and &lt;code&gt;Tweet&lt;/code&gt; in the same way we call regular methods, like this:</source>
          <target state="translated">トレイトを実装した後、次のように通常のメソッドを呼び出すのと同じ方法で、 &lt;code&gt;NewsArticle&lt;/code&gt; と &lt;code&gt;Tweet&lt;/code&gt; のインスタンスのメソッドを呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="6aee078dffc9ca07e378d1b98649828937e42093" translate="yes" xml:space="preserve">
          <source>After learning about the &lt;code&gt;while let&lt;/code&gt; loop in Chapter 18, you might be wondering why we didn&amp;rsquo;t write the worker thread code as shown in Listing 20-21.</source>
          <target state="translated">第18章で &lt;code&gt;while let&lt;/code&gt; ループについて学習した後、リスト20-21に示すようにワーカースレッドコードを記述しなかった理由を疑問に思うかもしれません。</target>
        </trans-unit>
        <trans-unit id="5a81464f303d05310b655ad576139ba2eadc374a" translate="yes" xml:space="preserve">
          <source>After learning about the &lt;code&gt;while let&lt;/code&gt; loop in Chapter 18, you might be wondering why we didn&amp;rsquo;t write the worker thread code as shown in Listing 20-22.</source>
          <target state="translated">18章で &lt;code&gt;while let&lt;/code&gt; ループについて学んだ後、リスト20-22で示されるようになぜワーカースレッドコードを書かなかったのか疑問に思われるかもしれません。</target>
        </trans-unit>
        <trans-unit id="56e7d653965ec5efdfa2c953ebd2075ad09eb04a" translate="yes" xml:space="preserve">
          <source>After running the code, the precedence behavior is evident: if the match guard were applied only to the final value in the list of values specified using the &lt;code&gt;|&lt;/code&gt; operator, the arm would have matched and the program would have printed &lt;code&gt;yes&lt;/code&gt;.</source>
          <target state="translated">コードの実行後、優先順位の動作は明らかです。一致ガードが、 &lt;code&gt;|&lt;/code&gt; を使用して指定された値のリストの最後の値にのみ適用された場合 オペレータ、腕は一致し、プログラムは &lt;code&gt;yes&lt;/code&gt; を出力します。</target>
        </trans-unit>
        <trans-unit id="6918a63768fd69dd2401af6cba199a57c7c6b4f3" translate="yes" xml:space="preserve">
          <source>After some time, once Rust developers who use nightly releases have been able to try out the new feature, team members will discuss the feature, how it&amp;rsquo;s worked out on nightly, and decide if it should make it into stable Rust or not. If the decision is to move forward, the feature gate is removed, and the feature is now considered stable! It rides the trains into a new stable release of Rust.</source>
          <target state="translated">しばらくして、ナイトリーリリースを使用するRust開発者が新機能を試すことができるようになったら、チームメンバーはその機能と、その機能が毎晩どのように機能するかについて話し合い、安定したRustにするかどうかを決定します。決定が前進する場合は、機能ゲートが削除され、機能は安定していると見なされます。Rustの新しい安定版リリースに列車を乗せます。</target>
        </trans-unit>
        <trans-unit id="780f735c7776bf172259bb14b7f1d801e95b8329" translate="yes" xml:space="preserve">
          <source>After that statement, we&amp;rsquo;ve again added a temporary &lt;code&gt;println!&lt;/code&gt; statement that prints the value of &lt;code&gt;contents&lt;/code&gt; after the file is read, so we can check that the program is working so far.</source>
          <target state="translated">そのステートメントの後で、一時的な &lt;code&gt;println!&lt;/code&gt; 再び追加しました！ファイルが読み込まれた後に &lt;code&gt;contents&lt;/code&gt; の値を出力するステートメント。これにより、プログラムがこれまでに動作していることを確認できます。</target>
        </trans-unit>
        <trans-unit id="96e831200e66693625317e3844fc1e89f068a7a9" translate="yes" xml:space="preserve">
          <source>After the method signature, instead of providing an implementation within curly brackets, we use a semicolon. Each type implementing this trait must provide its own custom behavior for the body of the method. The compiler will enforce that any type that has the &lt;code&gt;Summary&lt;/code&gt; trait will have the method &lt;code&gt;summarize&lt;/code&gt; defined with this signature exactly.</source>
          <target state="translated">メソッドシグネチャの後、中かっこ内に実装を提供する代わりに、セミコロンを使用します。この特性を実装する各タイプは、メソッドの本体に独自のカスタム動作を提供する必要があります。コンパイラが有する任意のタイプのことを強制します &lt;code&gt;Summary&lt;/code&gt; 形質は、メソッドがあります &lt;code&gt;summarize&lt;/code&gt; まさにこの署名で定義します。</target>
        </trans-unit>
        <trans-unit id="fd61e6cd4b0dca5587c3bdc8b19a36c54df5d01a" translate="yes" xml:space="preserve">
          <source>After the parameters, we place curly brackets that hold the body of the closure&amp;mdash;these are optional if the closure body is a single expression. The end of the closure, after the curly brackets, needs a semicolon to complete the &lt;code&gt;let&lt;/code&gt; statement. The value returned from the last line in the closure body (&lt;code&gt;num&lt;/code&gt;) will be the value returned from the closure when it&amp;rsquo;s called, because that line doesn&amp;rsquo;t end in a semicolon; just as in function bodies.</source>
          <target state="translated">パラメーターの後に、クロージャーの本体を保持する中括弧を配置します。クロージャーの本体が単一の式である場合、これらはオプションです。中括弧の後のクロージャの終わりでは、 &lt;code&gt;let&lt;/code&gt; ステートメントを完了するためにセミコロンが必要です。クロージャー本体の最後の行（ &lt;code&gt;num&lt;/code&gt; ）から返される値は、呼び出されたときにクロージャーから返される値になります。これは、その行がセミコロンで終わっていないためです。関数本体と同じように。</target>
        </trans-unit>
        <trans-unit id="3409f581311196341ada32cc2fb23895a79e2d64" translate="yes" xml:space="preserve">
          <source>After the request line, the remaining lines starting from &lt;code&gt;Host:&lt;/code&gt; onward are headers. &lt;code&gt;GET&lt;/code&gt; requests have no body.</source>
          <target state="translated">リクエスト行の後の、 &lt;code&gt;Host:&lt;/code&gt; 以降の残りの行はヘッダーです。 &lt;code&gt;GET&lt;/code&gt; リクエストには本文がありません。</target>
        </trans-unit>
        <trans-unit id="94ada77990e54a7199b314d48e7c28b8866c26f5" translate="yes" xml:space="preserve">
          <source>After these two lines, &lt;code&gt;s&lt;/code&gt; will contain &lt;code&gt;foobar&lt;/code&gt;. The &lt;code&gt;push_str&lt;/code&gt; method takes a string slice because we don&amp;rsquo;t necessarily want to take ownership of the parameter. For example, the code in Listing 8-16 shows that it would be unfortunate if we weren&amp;rsquo;t able to use &lt;code&gt;s2&lt;/code&gt; after appending its contents to &lt;code&gt;s1&lt;/code&gt;.</source>
          <target state="translated">これらの2行の後、 &lt;code&gt;s&lt;/code&gt; には &lt;code&gt;foobar&lt;/code&gt; が含まれます。 &lt;code&gt;push_str&lt;/code&gt; の我々は、必ずしもパラメータの所有権を取得したくないので、この方法では、文字列のスライスを取ります。たとえば、リスト8-16のコードは、コンテンツを &lt;code&gt;s1&lt;/code&gt; に追加した後で &lt;code&gt;s2&lt;/code&gt; を使用できなかった場合は残念であることを示しています。</target>
        </trans-unit>
        <trans-unit id="d28bc7bf7124bb617821696b52f238bf37faf9be" translate="yes" xml:space="preserve">
          <source>After they have been consumed, the rest of the elements are yielded. Rather than overriding this method directly, instead override the &lt;code&gt;nth&lt;/code&gt; method.</source>
          <target state="translated">それらが消費された後、残りの要素が生成されます。このメソッドを直接オーバーライドするのではなく、代わりに &lt;code&gt;nth&lt;/code&gt; メソッドをオーバーライドします。</target>
        </trans-unit>
        <trans-unit id="d1a8c993e11b907a98ea3122f628acdebbd6b42e" translate="yes" xml:space="preserve">
          <source>After updating the registry, Cargo checks the &lt;code&gt;[dependencies]&lt;/code&gt; section and downloads any crates you don&amp;rsquo;t have yet. In this case, although we only listed &lt;code&gt;rand&lt;/code&gt; as a dependency, Cargo also grabbed &lt;code&gt;libc&lt;/code&gt; and &lt;code&gt;rand_core&lt;/code&gt;, because &lt;code&gt;rand&lt;/code&gt; depends on those to work. After downloading the crates, Rust compiles them and then compiles the project with the dependencies available.</source>
          <target state="translated">レジストリを更新した後、Cargoは &lt;code&gt;[dependencies]&lt;/code&gt; セクションをチェックし、まだ持っていない木枠をダウンロードします。この場合、依存関係として &lt;code&gt;rand&lt;/code&gt; のみをリストし &lt;code&gt;rand_core&lt;/code&gt; 、 &lt;code&gt;rand&lt;/code&gt; は動作するものに依存しているため、Cargoは &lt;code&gt;libc&lt;/code&gt; とrand_coreも取得しました。クレートをダウンロードした後、Rustはそれらをコンパイルし、利用可能な依存関係を使用してプロジェクトをコンパイルします。</target>
        </trans-unit>
        <trans-unit id="17378b2abc480d099ee902b5db16470e7091ec08" translate="yes" xml:space="preserve">
          <source>After updating the registry, Cargo checks the &lt;code&gt;[dependencies]&lt;/code&gt; section and downloads any crates you don&amp;rsquo;t have yet. In this case, although we only listed &lt;code&gt;rand&lt;/code&gt; as a dependency, Cargo also grabbed a copy of &lt;code&gt;libc&lt;/code&gt;, because &lt;code&gt;rand&lt;/code&gt; depends on &lt;code&gt;libc&lt;/code&gt; to work. After downloading the crates, Rust compiles them and then compiles the project with the dependencies available.</source>
          <target state="translated">レジストリを更新した後、Cargoは &lt;code&gt;[dependencies]&lt;/code&gt; セクションをチェックして、まだ持っていないクレートをダウンロードします。この場合、依存関係として &lt;code&gt;rand&lt;/code&gt; のみをリストしましたが、機能するために &lt;code&gt;rand&lt;/code&gt; は &lt;code&gt;libc&lt;/code&gt; に依存しているため、Cargoは &lt;code&gt;libc&lt;/code&gt; のコピーも取得しました。クレートをダウンロードした後、Rustはそれらをコンパイルしてから、利用可能な依存関係を使用してプロジェクトをコンパイルします。</target>
        </trans-unit>
        <trans-unit id="9d98c1489e41fbd88598871e5f8d212bbc3f78c5" translate="yes" xml:space="preserve">
          <source>After we define &lt;code&gt;summarize_author&lt;/code&gt;, we can call &lt;code&gt;summarize&lt;/code&gt; on instances of the &lt;code&gt;Tweet&lt;/code&gt; struct, and the default implementation of &lt;code&gt;summarize&lt;/code&gt; will call the definition of &lt;code&gt;summarize_author&lt;/code&gt; that we&amp;rsquo;ve provided. Because we&amp;rsquo;ve implemented &lt;code&gt;summarize_author&lt;/code&gt;, the &lt;code&gt;Summary&lt;/code&gt; trait has given us the behavior of the &lt;code&gt;summarize&lt;/code&gt; method without requiring us to write any more code.</source>
          <target state="translated">我々が定義した後 &lt;code&gt;summarize_author&lt;/code&gt; を、我々は呼び出すことができます &lt;code&gt;summarize&lt;/code&gt; のインスタンスに &lt;code&gt;Tweet&lt;/code&gt; 構造体、およびデフォルトの実装で &lt;code&gt;summarize&lt;/code&gt; の定義を呼び出します &lt;code&gt;summarize_author&lt;/code&gt; 私たちが提供したことを。私たちが実施してきたので &lt;code&gt;summarize_author&lt;/code&gt; を、 &lt;code&gt;Summary&lt;/code&gt; トレイトは、私たちの行動与えている &lt;code&gt;summarize&lt;/code&gt; いずれかのより多くのコードを書くために私たちを必要とせずに方法を。</target>
        </trans-unit>
        <trans-unit id="2556b8fd31ff1260ec94fc2ed10873de0af61a38" translate="yes" xml:space="preserve">
          <source>After we&amp;rsquo;ve acquired the lock, we can treat the return value, named &lt;code&gt;num&lt;/code&gt; in this case, as a mutable reference to the data inside. The type system ensures that we acquire a lock before using the value in &lt;code&gt;m&lt;/code&gt;: &lt;code&gt;Mutex&amp;lt;i32&amp;gt;&lt;/code&gt; is not an &lt;code&gt;i32&lt;/code&gt;, so we &lt;em&gt;must&lt;/em&gt; acquire the lock to be able to use the &lt;code&gt;i32&lt;/code&gt; value. We can&amp;rsquo;t forget; the type system won&amp;rsquo;t let us access the inner &lt;code&gt;i32&lt;/code&gt; otherwise.</source>
          <target state="translated">ロックを取得したら、戻り値（この場合は &lt;code&gt;num&lt;/code&gt; )を内部のデータへの変更可能な参照として扱うことができます。我々は、の値を使用する前にロックを取得することを型システム性を保証 &lt;code&gt;m&lt;/code&gt; ： &lt;code&gt;Mutex&amp;lt;i32&amp;gt;&lt;/code&gt; ない &lt;code&gt;i32&lt;/code&gt; 我々は、&lt;em&gt;しなければならない&lt;/em&gt;使用できるようにロックを取得 &lt;code&gt;i32&lt;/code&gt; 値。忘れられない。それ以外の場合、型システムは内部の &lt;code&gt;i32&lt;/code&gt; にアクセスできません。</target>
        </trans-unit>
        <trans-unit id="eea76bdbc5658f7fad1ad625716859e45f8c384f" translate="yes" xml:space="preserve">
          <source>After we&amp;rsquo;ve created &lt;em&gt;tests/common/mod.rs&lt;/em&gt;, we can use it from any of the integration test files as a module. Here&amp;rsquo;s an example of calling the &lt;code&gt;setup&lt;/code&gt; function from the &lt;code&gt;it_adds_two&lt;/code&gt; test in &lt;em&gt;tests/integration_test.rs&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;tests / common / mod.rs&lt;/em&gt;を作成した後、任意の統合テストファイルからそれをモジュールとして使用できます。次に示すのは、&lt;em&gt;tests / integration_test.rsの&lt;/em&gt; &lt;code&gt;it_adds_two&lt;/code&gt; テストから &lt;code&gt;setup&lt;/code&gt; 関数を呼び出す例です。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="43dc84fb12e1a579a9d73c911c37d0ab1b82a9f5" translate="yes" xml:space="preserve">
          <source>After we&amp;rsquo;ve created the lists in &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt;, we add 10 to the value in &lt;code&gt;value&lt;/code&gt;. We do this by calling &lt;code&gt;borrow_mut&lt;/code&gt; on &lt;code&gt;value&lt;/code&gt;, which uses the automatic dereferencing feature we discussed in Chapter 5 (see the section &lt;a href=&quot;ch05-03-method-syntax#wheres-the---operator&quot;&gt;&amp;ldquo;Where&amp;rsquo;s the &lt;code&gt;-&amp;gt;&lt;/code&gt; Operator?&amp;rdquo;&lt;/a&gt;) to dereference the &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; to the inner &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; value. The &lt;code&gt;borrow_mut&lt;/code&gt; method returns a &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt; smart pointer, and we use the dereference operator on it and change the inner value.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 、 &lt;code&gt;b&lt;/code&gt; 、および &lt;code&gt;c&lt;/code&gt; のリストを作成したら、valueの値に10を追加し &lt;code&gt;value&lt;/code&gt; 。私たちは、呼び出すことによってこれを行う &lt;code&gt;borrow_mut&lt;/code&gt; 上の &lt;code&gt;value&lt;/code&gt; （セクションを参照してください我々は、第5章で説明した自動逆参照機能を使用して、&lt;a href=&quot;ch05-03-method-syntax#wheres-the---operator&quot;&gt;「どこだ &lt;code&gt;-&amp;gt;&lt;/code&gt; 演算子？」&lt;/a&gt;逆参照する） &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 内部に &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 値を。 &lt;code&gt;borrow_mut&lt;/code&gt; の方法は返し &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt; スマートポインタを、私たちはそれに間接参照演算子を使用し、内側の値を変更します。</target>
        </trans-unit>
        <trans-unit id="b18bd157b258782bdf4328d729095843e56901f9" translate="yes" xml:space="preserve">
          <source>After writing a lot of Rust code, the Rust team found that Rust programmers were entering the same lifetime annotations over and over in particular situations. These situations were predictable and followed a few deterministic patterns. The developers programmed these patterns into the compiler&amp;rsquo;s code so the borrow checker could infer the lifetimes in these situations and wouldn&amp;rsquo;t need explicit annotations.</source>
          <target state="translated">多くのRustコードを記述した後、Rustチームは、Rustプログラマーが特定の状況で同じライフタイムアノテーションを何度も入力していることを発見しました。これらの状況は予測可能であり、いくつかの確定的なパターンに従っていました。開発者はこれらのパターンをコンパイラーのコードにプログラムしたので、借用チェッカーはこれらの状況で寿命を推測でき、明示的な注釈は必要ありません。</target>
        </trans-unit>
        <trans-unit id="8911f4e8942ad7726d100e32781ae750b7e4baf7" translate="yes" xml:space="preserve">
          <source>After you&amp;rsquo;ve installed Rust via &lt;code&gt;rustup&lt;/code&gt;, updating to the latest version is easy. From your shell, run the following update script:</source>
          <target state="translated">&lt;code&gt;rustup&lt;/code&gt; を使用してRustをインストールした後は、最新バージョンに簡単に更新できます。シェルから、次の更新スクリプトを実行します。</target>
        </trans-unit>
        <trans-unit id="13f2d652f70945cb85fc5562fc3600a535ffb359" translate="yes" xml:space="preserve">
          <source>After:</source>
          <target state="translated">After:</target>
        </trans-unit>
        <trans-unit id="1d0c9f96248d537407790c171b6d4f7cd1fd7157" translate="yes" xml:space="preserve">
          <source>Again, this is the simplest implementation of the &lt;code&gt;execute&lt;/code&gt; method: it does nothing, but we&amp;rsquo;re trying only to make our code compile. Let&amp;rsquo;s check it again:</source>
          <target state="translated">繰り返しますが、これは &lt;code&gt;execute&lt;/code&gt; メソッドの最も単純な実装です。何もしませんが、コードをコンパイルすることだけを試みています。もう一度確認してみましょう。</target>
        </trans-unit>
        <trans-unit id="7b6d0c4005bedf77e43140c67158dc3c2786f272" translate="yes" xml:space="preserve">
          <source>Again, we&amp;rsquo;re using &lt;code&gt;thread::spawn&lt;/code&gt; to create a new thread and then using &lt;code&gt;move&lt;/code&gt; to move &lt;code&gt;tx&lt;/code&gt; into the closure so the spawned thread owns &lt;code&gt;tx&lt;/code&gt;. The spawned thread needs to own the transmitting end of the channel to be able to send messages through the channel.</source>
          <target state="translated">ここでも、 &lt;code&gt;thread::spawn&lt;/code&gt; を使用して新しいスレッドを作成し、 &lt;code&gt;move&lt;/code&gt; を使用して &lt;code&gt;tx&lt;/code&gt; をクロージャーに移動しているため、生成されたスレッドは &lt;code&gt;tx&lt;/code&gt; を所有しています。生成されたスレッドは、チャネルを介してメッセージを送信できるように、チャネルの送信側を所有する必要があります。</target>
        </trans-unit>
        <trans-unit id="42935bf9ba7e07a25a52edfb6e2d38809a0c1bab" translate="yes" xml:space="preserve">
          <source>Again, you need not specify the full type if the compiler can infer it:</source>
          <target state="translated">繰り返しになりますが、コンパイラが推測できる場合は完全な型を指定する必要はありません。</target>
        </trans-unit>
        <trans-unit id="3cc0e9834230ccbe94275d501fa3b8e31c8d1c62" translate="yes" xml:space="preserve">
          <source>Aha! The first error message indicates that &lt;code&gt;counter&lt;/code&gt; is moved into the closure for the thread associated with &lt;code&gt;handle&lt;/code&gt;. That move is preventing us from capturing &lt;code&gt;counter&lt;/code&gt; when we try to call &lt;code&gt;lock&lt;/code&gt; on it and store the result in &lt;code&gt;num2&lt;/code&gt; in the second thread! So Rust is telling us that we can&amp;rsquo;t move ownership of &lt;code&gt;counter&lt;/code&gt; into multiple threads. This was hard to see earlier because our threads were in a loop, and Rust can&amp;rsquo;t point to different threads in different iterations of the loop. Let&amp;rsquo;s fix the compiler error with a multiple-ownership method we discussed in Chapter 15.</source>
          <target state="translated">ああ！最初のエラーメッセージは、 &lt;code&gt;counter&lt;/code&gt; が、 &lt;code&gt;handle&lt;/code&gt; に関連付けられたスレッドのクロージャーに移動したことを示しています。その移動により、 &lt;code&gt;lock&lt;/code&gt; を呼び出してその結果を2番目のスレッドの &lt;code&gt;num2&lt;/code&gt; に保存しようと &lt;code&gt;counter&lt;/code&gt; ときに、カウンターをキャプチャできなくなります。したがって、Rustは、 &lt;code&gt;counter&lt;/code&gt; の所有権を複数のスレッドに移動することはできないと言っています。私たちのスレッドはループ内にあったため、これを以前に確認することは困難でした。また、Rustはループの異なる反復で異なるスレッドを指すことができません。第15章で説明した複数所有者メソッドを使用して、コンパイラエラーを修正しましょう。</target>
        </trans-unit>
        <trans-unit id="7f8c5176c3f03b97659161923f2b6492f7de7e73" translate="yes" xml:space="preserve">
          <source>Alignment</source>
          <target state="translated">Alignment</target>
        </trans-unit>
        <trans-unit id="6c230b19ce360dc47ab1f803ec5d75221398ff9e" translate="yes" xml:space="preserve">
          <source>Alignment::borrow</source>
          <target state="translated">Alignment::borrow</target>
        </trans-unit>
        <trans-unit id="77b6c3d761057550ac535096603085a4ab21f25d" translate="yes" xml:space="preserve">
          <source>Alignment::borrow_mut</source>
          <target state="translated">Alignment::borrow_mut</target>
        </trans-unit>
        <trans-unit id="d45a68b20b4cc6114f5421add49178bf870ce27b" translate="yes" xml:space="preserve">
          <source>Alignment::fmt</source>
          <target state="translated">Alignment::fmt</target>
        </trans-unit>
        <trans-unit id="0912a9a905355e3a6df915cce4fce3e26fba4e82" translate="yes" xml:space="preserve">
          <source>Alignment::from</source>
          <target state="translated">Alignment::from</target>
        </trans-unit>
        <trans-unit id="14750a6b1eb92c0620b2d52bd702a109608e9cb3" translate="yes" xml:space="preserve">
          <source>Alignment::into</source>
          <target state="translated">Alignment::into</target>
        </trans-unit>
        <trans-unit id="b06fe916f5f193304938aca87ce9baf4fe4a81c0" translate="yes" xml:space="preserve">
          <source>Alignment::try_from</source>
          <target state="translated">Alignment::try_from</target>
        </trans-unit>
        <trans-unit id="7e4c9d31924344ef62791e3f5778cc0b64650841" translate="yes" xml:space="preserve">
          <source>Alignment::try_into</source>
          <target state="translated">Alignment::try_into</target>
        </trans-unit>
        <trans-unit id="f8d85378f8bd14502ad4a535bf35eace323f7be0" translate="yes" xml:space="preserve">
          <source>Alignment::type_id</source>
          <target state="translated">Alignment::type_id</target>
        </trans-unit>
        <trans-unit id="1f13dd31cf3795018ba8cb51097f5cee92e51d26" translate="yes" xml:space="preserve">
          <source>All &lt;a href=&quot;items&quot;&gt;item declarations&lt;/a&gt; accept outer attributes while &lt;a href=&quot;items/external-blocks&quot;&gt;external blocks&lt;/a&gt;, &lt;a href=&quot;items/functions&quot;&gt;functions&lt;/a&gt;, &lt;a href=&quot;items/implementations&quot;&gt;implementations&lt;/a&gt;, and &lt;a href=&quot;items/modules&quot;&gt;modules&lt;/a&gt; accept inner attributes.</source>
          <target state="translated">すべての&lt;a href=&quot;items&quot;&gt;項目宣言&lt;/a&gt;は外部属性を受け入れますが、&lt;a href=&quot;items/external-blocks&quot;&gt;外部ブロック&lt;/a&gt;、&lt;a href=&quot;items/functions&quot;&gt;関数&lt;/a&gt;、&lt;a href=&quot;items/implementations&quot;&gt;実装&lt;/a&gt;、および&lt;a href=&quot;items/modules&quot;&gt;モジュール&lt;/a&gt;は内部属性を受け入れます。</target>
        </trans-unit>
        <trans-unit id="e7edfb23f380c12b821737c77295267e0d55adfa" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;if&lt;/code&gt; expressions start with the keyword &lt;code&gt;if&lt;/code&gt;, which is followed by a condition. In this case, the condition checks whether or not the variable &lt;code&gt;number&lt;/code&gt; has a value less than 5. The block of code we want to execute if the condition is true is placed immediately after the condition inside curly brackets. Blocks of code associated with the conditions in &lt;code&gt;if&lt;/code&gt; expressions are sometimes called &lt;em&gt;arms&lt;/em&gt;, just like the arms in &lt;code&gt;match&lt;/code&gt; expressions that we discussed in the &lt;a href=&quot;ch02-00-guessing-game-tutorial#comparing-the-guess-to-the-secret-number&quot;&gt;&amp;ldquo;Comparing the Guess to the Secret Number&amp;rdquo;&lt;/a&gt; section of Chapter 2.</source>
          <target state="translated">すべての &lt;code&gt;if&lt;/code&gt; 式はキーワード &lt;code&gt;if&lt;/code&gt; で始まり、その後に条件が続きます。この場合、条件は変数 &lt;code&gt;number&lt;/code&gt; が5未満の値であるかどうかをチェックします。条件がtrueの場合に実行するコードのブロックは、中括弧内の条件の直後に配置されます。第2章の&lt;a href=&quot;ch02-00-guessing-game-tutorial#comparing-the-guess-to-the-secret-number&quot;&gt;「推測とシークレット番号の比較」&lt;/a&gt;セクションで説明した &lt;code&gt;match&lt;/code&gt; 表現の&lt;em&gt;腕&lt;/em&gt;と同じように、 &lt;code&gt;if&lt;/code&gt; 式がarmと呼ばれることもある条件に関連付けられたコードのブロック。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6d770608aae868ce44cc837cd9b78c8161bf1b4b" translate="yes" xml:space="preserve">
          <source>All ASCII</source>
          <target state="translated">すべてのアスキー</target>
        </trans-unit>
        <trans-unit id="941b268ba2f8b2e2bf50827de379fcc106a7ae00" translate="yes" xml:space="preserve">
          <source>All Rust compiler versions support any edition that existed prior to that compiler&amp;rsquo;s release, and they can link crates of any supported editions together. Edition changes only affect the way the compiler initially parses code. Therefore, if you&amp;rsquo;re using Rust 2015 and one of your dependencies uses Rust 2018, your project will compile and be able to use that dependency. The opposite situation, where your project uses Rust 2018 and a dependency uses Rust 2015, works as well.</source>
          <target state="translated">すべてのRustコンパイラバージョンは、そのコンパイラのリリース前に存在していたエディションをサポートし、サポートされているエディションのクレートをリンクできます。エディションの変更は、コンパイラーが最初にコードを解析する方法にのみ影響します。したがって、Rust 2015を使用していて、依存関係の1つがRust 2018を使用している場合、プロジェクトはコンパイルされ、その依存関係を使用できます。プロジェクトがRust 2018を使用し、依存関係がRust 2015を使用するという反対の状況も同様に機能します。</target>
        </trans-unit>
        <trans-unit id="7652c7eeda6497653864c68957d9fcd32bd3f053" translate="yes" xml:space="preserve">
          <source>All Unicode</source>
          <target state="translated">すべてのユニコード</target>
        </trans-unit>
        <trans-unit id="47de5609df925352bb65b1c68fe6d11ef3c5f11f" translate="yes" xml:space="preserve">
          <source>All Unicode characters contained in the raw string body represent themselves, the characters &lt;code&gt;U+0022&lt;/code&gt; (double-quote) (except when followed by at least as many &lt;code&gt;U+0023&lt;/code&gt; (&lt;code&gt;#&lt;/code&gt;) characters as were used to start the raw string literal) or &lt;code&gt;U+005C&lt;/code&gt; (&lt;code&gt;\&lt;/code&gt;) do not have any special meaning.</source>
          <target state="translated">生の文字列本体に含まれるすべてのUnicode文字は、それ自体、文字 &lt;code&gt;U+0022&lt;/code&gt; （二重引用符）（生の文字列リテラルの開始に使用されたのと同じ数以上の &lt;code&gt;U+0023&lt;/code&gt; （ &lt;code&gt;#&lt;/code&gt; ）文字が続く場合を除く）または &lt;code&gt;U+005C&lt;/code&gt; （ &lt;code&gt;\&lt;/code&gt; ）には特別な意味はありません。</target>
        </trans-unit>
        <trans-unit id="8a1ba3bb13e8cd072a280ba55ff12cd4ec0faacf" translate="yes" xml:space="preserve">
          <source>All access to a static is safe, but there are a number of restrictions on statics:</source>
          <target state="translated">スタティックへのアクセスはすべて安全ですが、スタティックにはいくつかの制限があります。</target>
        </trans-unit>
        <trans-unit id="cc4193fdbde0490cb6df1ff9fd4927655f61fac3" translate="yes" xml:space="preserve">
          <source>All access to the inner value through methods is &lt;code&gt;unsafe&lt;/code&gt;.</source>
          <target state="translated">メソッドによる内部値へのアクセスはすべて &lt;code&gt;unsafe&lt;/code&gt; はありません。</target>
        </trans-unit>
        <trans-unit id="ceb9b59e717209dd478129622af76401fc92a7ef" translate="yes" xml:space="preserve">
          <source>All accesses performed by functions in this module are &lt;em&gt;non-atomic&lt;/em&gt; in the sense of &lt;a href=&quot;../sync/atomic/index&quot;&gt;atomic operations&lt;/a&gt; used to synchronize between threads. This means it is undefined behavior to perform two concurrent accesses to the same location from different threads unless both accesses only read from memory. Notice that this explicitly includes &lt;a href=&quot;fn.read_volatile&quot;&gt;&lt;code&gt;read_volatile&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fn.write_volatile&quot;&gt;&lt;code&gt;write_volatile&lt;/code&gt;&lt;/a&gt;: Volatile accesses cannot be used for inter-thread synchronization.</source>
          <target state="translated">このモジュールの関数によって実行されるすべてのアクセスは、スレッド間の同期に使用される&lt;a href=&quot;../sync/atomic/index&quot;&gt;アトミック操作&lt;/a&gt;の意味で&lt;em&gt;非アトミック&lt;/em&gt;です。つまり、両方のアクセスがメモリからの読み取りのみでない限り、異なるスレッドから同じ場所への2つの同時アクセスを実行することは未定義の動作です。これには、&lt;a href=&quot;fn.read_volatile&quot;&gt; &lt;code&gt;read_volatile&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;fn.write_volatile&quot;&gt; &lt;code&gt;write_volatile&lt;/code&gt; が&lt;/a&gt;明示的に含まれていることに注意してください。揮発性アクセスは、スレッド間同期には使用できません。</target>
        </trans-unit>
        <trans-unit id="286be0b8b15ccf1efa39407656b792f78e80afd9" translate="yes" xml:space="preserve">
          <source>All amortized costs are for the potential need to resize when capacity is exhausted. If a resize occurs it will take &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;) time. Our collections never automatically shrink, so removal operations aren't amortized. Over a sufficiently large series of operations, the average cost per operation will deterministically equal the given cost.</source>
          <target state="translated">償却された費用はすべて、容量がなくなったときにサイズを変更する必要がある可能性があるためです。サイズ変更が発生した場合、&lt;em&gt;O&lt;/em&gt;（&lt;em&gt;n&lt;/em&gt;）時間がかかります。コレクションが自動的に縮小することはないため、削除操作は償却されません。十分に大きな一連の操作では、操作あたりの平均コストは決定論的に指定されたコストに等しくなります。</target>
        </trans-unit>
        <trans-unit id="5d3e246179e6158acb2b336b6eaaa6c3cd96b12d" translate="yes" xml:space="preserve">
          <source>All amortized costs are for the potential need to resize when capacity is exhausted. If a resize occurs it will take O(n) time. Our collections never automatically shrink, so removal operations aren't amortized. Over a sufficiently large series of operations, the average cost per operation will deterministically equal the given cost.</source>
          <target state="translated">すべての償却コストは、容量が枯渇したときにサイズ変更が必要になる可能性があるためのものです。サイズ変更が発生した場合、O(n)の時間がかかります。私たちのコレクションは自動的に縮小することはないので、除去作業は償却されません。十分に大規模な一連の作業については、作業ごとの平均コストは決定論的に与えられたコストと等しくなります。</target>
        </trans-unit>
        <trans-unit id="ad40505a1a509d19ac8713b0e6d72bf2f8406439" translate="yes" xml:space="preserve">
          <source>All associated functions must either have a &lt;code&gt;where Self: Sized&lt;/code&gt; bound, or</source>
          <target state="translated">関連するすべての関数には、 &lt;code&gt;where Self: Sized&lt;/code&gt; 境界、または</target>
        </trans-unit>
        <trans-unit id="15061bca973f1e3bdfd6bc4220f487a4d9f0fa2e" translate="yes" xml:space="preserve">
          <source>All atomic types in this module are guaranteed to be &lt;a href=&quot;https://en.wikipedia.org/wiki/Non-blocking_algorithm&quot;&gt;lock-free&lt;/a&gt; if they're available. This means they don't internally acquire a global mutex. Atomic types and operations are not guaranteed to be wait-free. This means that operations like &lt;code&gt;fetch_or&lt;/code&gt; may be implemented with a compare-and-swap loop.</source>
          <target state="translated">このモジュールのすべてのアトミック型は、利用可能であれば&lt;a href=&quot;https://en.wikipedia.org/wiki/Non-blocking_algorithm&quot;&gt;ロックフリーである&lt;/a&gt;ことが保証されています。つまり、内部的にグローバルミューテックスを取得しません。原子のタイプと操作は、待機なしであることが保証されていません。つまり、 &lt;code&gt;fetch_or&lt;/code&gt; などの操作は、比較とスワップのループを使用して実装できます。</target>
        </trans-unit>
        <trans-unit id="290ed2d52fa06b05e83bf6a12f1d4aa3dca7ba7c" translate="yes" xml:space="preserve">
          <source>All binaries installed with &lt;code&gt;cargo install&lt;/code&gt; are stored in the installation root&amp;rsquo;s &lt;em&gt;bin&lt;/em&gt; folder. If you installed Rust using &lt;em&gt;rustup.rs&lt;/em&gt; and don&amp;rsquo;t have any custom configurations, this directory will be &lt;em&gt;$HOME/.cargo/bin&lt;/em&gt;. Ensure that directory is in your &lt;code&gt;$PATH&lt;/code&gt; to be able to run programs you&amp;rsquo;ve installed with &lt;code&gt;cargo install&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;cargo install&lt;/code&gt; されるすべてのバイナリは、インストールルートの&lt;em&gt;bin&lt;/em&gt;フォルダに格納されます。&lt;em&gt;rustup.rs&lt;/em&gt;を使用してRustをインストールし、カスタム構成がない場合、このディレクトリは&lt;em&gt;$ HOME / .cargo / binになり&lt;/em&gt;ます。 &lt;code&gt;cargo install&lt;/code&gt; したプログラムを実行できるように、ディレクトリが &lt;code&gt;$PATH&lt;/code&gt; にあることを確認してください。</target>
        </trans-unit>
        <trans-unit id="33d170f2503ad727df2773d3d501af5a7c6f33f7" translate="yes" xml:space="preserve">
          <source>All boolean operators except for &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; which are banned since they are short-circuiting.</source>
          <target state="translated">&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; および &lt;code&gt;||&lt;/code&gt; を除くすべてのブール演算子 それらは短絡しているため禁止されています。</target>
        </trans-unit>
        <trans-unit id="1797e85af758baa0954345dbaa6c305b8c789f74" translate="yes" xml:space="preserve">
          <source>All bytes read from this source will be appended to the specified buffer &lt;code&gt;buf&lt;/code&gt;. This function will continuously call &lt;a href=&quot;trait.read#tymethod.read&quot;&gt;&lt;code&gt;read()&lt;/code&gt;&lt;/a&gt; to append more data to &lt;code&gt;buf&lt;/code&gt; until &lt;a href=&quot;trait.read#tymethod.read&quot;&gt;&lt;code&gt;read()&lt;/code&gt;&lt;/a&gt; returns either &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(0)&lt;/code&gt;&lt;/a&gt; or an error of non-&lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind.</source>
          <target state="translated">このソースから読み取られたすべてのバイトは、指定されたバッファー &lt;code&gt;buf&lt;/code&gt; に追加されます。この関数は、連続的に呼ぶ&lt;a href=&quot;trait.read#tymethod.read&quot;&gt; &lt;code&gt;read()&lt;/code&gt; &lt;/a&gt;ために多くのデータ追加する &lt;code&gt;buf&lt;/code&gt; をするまで&lt;a href=&quot;trait.read#tymethod.read&quot;&gt; &lt;code&gt;read()&lt;/code&gt; &lt;/a&gt;戻りいずれか&lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok(0)&lt;/code&gt; &lt;/a&gt;または非誤差&lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt;種類。</target>
        </trans-unit>
        <trans-unit id="7b662763d511d397b2cbc49f35a59edd0871bf65" translate="yes" xml:space="preserve">
          <source>All calls to &lt;a href=&quot;trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; on the returned instance will return &lt;code&gt;Ok(buf.len())&lt;/code&gt; and the contents of the buffer will not be inspected.</source>
          <target state="translated">返されたインスタンスに&lt;a href=&quot;trait.write#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;すべての呼び出しは &lt;code&gt;Ok(buf.len())&lt;/code&gt; を返し、バッファーの内容は検査されません。</target>
        </trans-unit>
        <trans-unit id="792e4e8c3b4454b76d09b3a55c5244a2a04987c6" translate="yes" xml:space="preserve">
          <source>All calls to &lt;code&gt;write&lt;/code&gt; on the returned instance will return &lt;code&gt;Ok(buf.len())&lt;/code&gt; and the contents of the buffer will not be inspected.</source>
          <target state="translated">返されたインスタンスに &lt;code&gt;write&lt;/code&gt; すべての呼び出しは &lt;code&gt;Ok(buf.len())&lt;/code&gt; を返し、バッファーの内容は検査されません。</target>
        </trans-unit>
        <trans-unit id="163ac7eae61cfe370b91ace9f314d434af91aec2" translate="yes" xml:space="preserve">
          <source>All characters contained in the raw string body represent their ASCII encoding, the characters &lt;code&gt;U+0022&lt;/code&gt; (double-quote) (except when followed by at least as many &lt;code&gt;U+0023&lt;/code&gt; (&lt;code&gt;#&lt;/code&gt;) characters as were used to start the raw string literal) or &lt;code&gt;U+005C&lt;/code&gt; (&lt;code&gt;\&lt;/code&gt;) do not have any special meaning.</source>
          <target state="translated">未加工文字列の本文に含まれるすべての文字は、ASCIIエンコーディングを表します。文字 &lt;code&gt;U+0022&lt;/code&gt; （二重引用符）（その後に、未加工文字列リテラルの開始に使用されたのと同じ数の &lt;code&gt;U+0023&lt;/code&gt; （ &lt;code&gt;#&lt;/code&gt; ）文字が続く場合を除く）または &lt;code&gt;U+005C&lt;/code&gt; （ &lt;code&gt;\&lt;/code&gt; ）には特別な意味はありません。</target>
        </trans-unit>
        <trans-unit id="43d6b6384605c36d010e25334a7b59d1666b30b5" translate="yes" xml:space="preserve">
          <source>All closure types implement &lt;a href=&quot;../special-types-and-traits#sized&quot;&gt;&lt;code&gt;Sized&lt;/code&gt;&lt;/a&gt;. Additionally, closure types implement the following traits if allowed to do so by the types of the captures it stores:</source>
          <target state="translated">すべてのクロージャタイプは&lt;a href=&quot;../special-types-and-traits#sized&quot;&gt; &lt;code&gt;Sized&lt;/code&gt; を&lt;/a&gt;実装します。さらに、クロージャタイプは、格納するキャプチャのタイプによって許可されている場合、次の特性を実装します。</target>
        </trans-unit>
        <trans-unit id="a34254512b20b7c3c4f4d4cb8623d62bc5f25917" translate="yes" xml:space="preserve">
          <source>All crates have a &lt;em&gt;prelude&lt;/em&gt; that automatically inserts names from a specific module, the &lt;em&gt;prelude module&lt;/em&gt;, into scope of each &lt;a href=&quot;items/modules&quot;&gt;module&lt;/a&gt; and an &lt;a href=&quot;items/extern-crates&quot;&gt;&lt;code&gt;extern crate&lt;/code&gt;&lt;/a&gt; into the crate root module. By default, the &lt;em&gt;standard prelude&lt;/em&gt; is used. The linked crate is &lt;a href=&quot;../std/index&quot;&gt;&lt;code&gt;std&lt;/code&gt;&lt;/a&gt; and the prelude module is &lt;a href=&quot;../std/prelude/index&quot;&gt;&lt;code&gt;std::prelude::v1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">すべてのクレートには、特定のモジュールからの名前である&lt;em&gt;プレリュードモジュール&lt;/em&gt;を各&lt;a href=&quot;items/modules&quot;&gt;モジュールの&lt;/a&gt;スコープに自動的に挿入する&lt;em&gt;プレリュード&lt;/em&gt;があり、&lt;a href=&quot;items/extern-crates&quot;&gt; &lt;code&gt;extern crate&lt;/code&gt; &lt;/a&gt;がクレートルートモジュールに挿入されます。デフォルトでは、&lt;em&gt;標準のプレリュード&lt;/em&gt;が使用されます。リンクされたクレートは&lt;a href=&quot;../std/index&quot;&gt; &lt;code&gt;std&lt;/code&gt; &lt;/a&gt;で、preludeモジュールは&lt;a href=&quot;../std/prelude/index&quot;&gt; &lt;code&gt;std::prelude::v1&lt;/code&gt; &lt;/a&gt;です。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="80e6d9f67f0a7d01f6edd0112ce6e32390cc7b99" translate="yes" xml:space="preserve">
          <source>All currently blocked and future &lt;a href=&quot;../io/trait.read&quot;&gt;reads&lt;/a&gt; will return &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(0)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">現在ブロックされているすべての&lt;a href=&quot;../io/trait.read&quot;&gt;読み取り&lt;/a&gt;と将来の読み取りは&lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok(0)&lt;/code&gt; &lt;/a&gt;を返します。</target>
        </trans-unit>
        <trans-unit id="ab960fd018156ee2b72c293b0f7c46b28b261211" translate="yes" xml:space="preserve">
          <source>All currently blocked and future &lt;a href=&quot;../io/trait.read&quot;&gt;reads&lt;/a&gt; will return &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(0)&lt;/code&gt;.</source>
          <target state="translated">現在ブロックされているすべての&lt;a href=&quot;../io/trait.read&quot;&gt;読み取り&lt;/a&gt;と将来の読み取りは&lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(0)&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="a6d40cb983863467fc229fa6f4b9f265ef62418a" translate="yes" xml:space="preserve">
          <source>All currently blocked and future &lt;a href=&quot;../io/trait.write&quot;&gt;writes&lt;/a&gt; will return an error.</source>
          <target state="translated">現在ブロックされているすべての&lt;a href=&quot;../io/trait.write&quot;&gt;書き込み&lt;/a&gt;と今後の書き込みはエラーを返します。</target>
        </trans-unit>
        <trans-unit id="c24e8493495f5eda7feccf15dd8b5779f86db545" translate="yes" xml:space="preserve">
          <source>All data stored on the stack must have a known, fixed size. Data with an unknown size at compile time or a size that might change must be stored on the heap instead. The heap is less organized: when you put data on the heap, you request a certain amount of space. The memory allocator finds an empty spot in the heap that is big enough, marks it as being in use, and returns a &lt;em&gt;pointer&lt;/em&gt;, which is the address of that location. This process is called &lt;em&gt;allocating on the heap&lt;/em&gt; and is sometimes abbreviated as just &lt;em&gt;allocating&lt;/em&gt;. Pushing values onto the stack is not considered allocating. Because the pointer is a known, fixed size, you can store the pointer on the stack, but when you want the actual data, you must follow the pointer.</source>
          <target state="translated">スタックに格納されるすべてのデータは、既知の固定サイズである必要があります。コンパイル時のサイズが不明なデータ、またはサイズが変更される可能性のあるデータは、代わりにヒープに格納する必要があります。ヒープはあまり整理されていません。ヒープにデータを配置するときは、一定量のスペースを要求します。メモリアロケータは、ヒープ内で十分な大きさの空の場所を見つけ、それを使用中であるとマークし、その場所のアドレスである&lt;em&gt;ポインタ&lt;/em&gt;を返します。このプロセスは&lt;em&gt;ヒープ&lt;/em&gt;への&lt;em&gt;割り当て&lt;/em&gt;と呼ば&lt;em&gt;れ、&lt;/em&gt;単に&lt;em&gt;割り当て&lt;/em&gt;と省略されることもあります。値をスタックにプッシュすることは、割り当てとは見なされません。ポインターは既知の固定サイズであるため、スタックにポインターを格納できますが、実際のデータが必要な場合は、ポインターに従う必要があります。</target>
        </trans-unit>
        <trans-unit id="b5ad10491502eb3084d1fb833cddef2d6e97c099" translate="yes" xml:space="preserve">
          <source>All data stored on the stack must have a known, fixed size. Data with an unknown size at compile time or a size that might change must be stored on the heap instead. The heap is less organized: when you put data on the heap, you request a certain amount of space. The operating system finds an empty spot in the heap that is big enough, marks it as being in use, and returns a &lt;em&gt;pointer&lt;/em&gt;, which is the address of that location. This process is called &lt;em&gt;allocating on the heap&lt;/em&gt; and is sometimes abbreviated as just &lt;em&gt;allocating&lt;/em&gt;. Pushing values onto the stack is not considered allocating. Because the pointer is a known, fixed size, you can store the pointer on the stack, but when you want the actual data, you must follow the pointer.</source>
          <target state="translated">スタックに格納されるすべてのデータは、既知の固定サイズでなければなりません。コンパイル時に不明なサイズまたは変更される可能性のあるサイズのデータ​​は、代わりにヒープに格納する必要があります。ヒープはあまり整理されていません。ヒープにデータを配置すると、一定量のスペースが要求されます。オペレーティングシステムは、十分な大きさのヒープ内の空の場所を見つけ、使用中としてマークし、その場所のアドレスである&lt;em&gt;ポインタ&lt;/em&gt;を返します。このプロセスは&lt;em&gt;、ヒープ&lt;/em&gt;への&lt;em&gt;割り当て&lt;/em&gt;と呼ば&lt;em&gt;れ、&lt;/em&gt;単に&lt;em&gt;割り当てる&lt;/em&gt;ことと略されることもあります。スタックに値をプッシュすることは、割り当てとは見なされません。ポインタは既知の固定サイズであるため、スタックにポインタを格納できますが、実際のデータが必要な場合は、ポインタに従う必要があります。</target>
        </trans-unit>
        <trans-unit id="c3ab61183db153bdcb93b3db49372bcfa15c64d0" translate="yes" xml:space="preserve">
          <source>All elements of arrays are always initialized, and access to an array is always bounds-checked in safe methods and operators.</source>
          <target state="translated">配列のすべての要素は常に初期化され、配列へのアクセスは常に安全なメソッドと演算子で境界チェックされます。</target>
        </trans-unit>
        <trans-unit id="7fbb5676d98408c23a91ee3e50ae6931e19803d3" translate="yes" xml:space="preserve">
          <source>All elements of slices are always initialized, and access to a slice is always bounds-checked in safe methods and operators.</source>
          <target state="translated">スライスのすべての要素は常に初期化され、スライスへのアクセスは常に安全なメソッドと演算子で境界チェックされます。</target>
        </trans-unit>
        <trans-unit id="5797b6e64335a290bd1264b10ba82cdf81409cc5" translate="yes" xml:space="preserve">
          <source>All fields in a &lt;code&gt;union&lt;/code&gt; are all at the same place in memory which means borrowing one borrows the entire &lt;code&gt;union&lt;/code&gt;, for the same lifetime:</source>
          <target state="translated">&lt;code&gt;union&lt;/code&gt; 内のすべてのフィールドは、メモリ内のすべて同じ場所にあります。つまり、1つを借りると、同じライフタイムで &lt;code&gt;union&lt;/code&gt; 全体が借りられます。</target>
        </trans-unit>
        <trans-unit id="833e88d98de8f4240c961bc71bc4ebdf6caf04e8" translate="yes" xml:space="preserve">
          <source>All five array values appear in the terminal, as expected. Even though &lt;code&gt;index&lt;/code&gt; will reach a value of &lt;code&gt;5&lt;/code&gt; at some point, the loop stops executing before trying to fetch a sixth value from the array.</source>
          <target state="translated">予想どおり、5つの配列値すべてがターミナルに表示されます。 &lt;code&gt;index&lt;/code&gt; がある時点で値 &lt;code&gt;5&lt;/code&gt; に到達しても、ループは配列から6番目の値をフェッチしようとする前に実行を停止します。</target>
        </trans-unit>
        <trans-unit id="9baa2527c7d6929ffc1c3e903b5bd7bcaaf4a17a" translate="yes" xml:space="preserve">
          <source>All four types of loop support &lt;a href=&quot;#break-expressions&quot;&gt;&lt;code&gt;break&lt;/code&gt; expressions&lt;/a&gt;, &lt;a href=&quot;#continue-expressions&quot;&gt;&lt;code&gt;continue&lt;/code&gt; expressions&lt;/a&gt;, and &lt;a href=&quot;#loop-labels&quot;&gt;labels&lt;/a&gt;. Only &lt;code&gt;loop&lt;/code&gt; supports &lt;a href=&quot;#break-and-loop-values&quot;&gt;evaluation to non-trivial values&lt;/a&gt;.</source>
          <target state="translated">4種類のループはすべて、&lt;a href=&quot;#break-expressions&quot;&gt; &lt;code&gt;break&lt;/code&gt; 式&lt;/a&gt;、&lt;a href=&quot;#continue-expressions&quot;&gt; &lt;code&gt;continue&lt;/code&gt; 式&lt;/a&gt;、および&lt;a href=&quot;#loop-labels&quot;&gt;ラベルを&lt;/a&gt;サポートしています。 &lt;code&gt;loop&lt;/code&gt; のみが&lt;a href=&quot;#break-and-loop-values&quot;&gt;重要な値への評価を&lt;/a&gt;サポートします。</target>
        </trans-unit>
        <trans-unit id="e11d83f6e553be6952611c97ac05bbc3817eeae9" translate="yes" xml:space="preserve">
          <source>All four types of loop support &lt;a href=&quot;loop-expr#break-expressions&quot;&gt;&lt;code&gt;break&lt;/code&gt; expressions&lt;/a&gt;, &lt;a href=&quot;loop-expr#continue-expressions&quot;&gt;&lt;code&gt;continue&lt;/code&gt; expressions&lt;/a&gt;, and &lt;a href=&quot;loop-expr#loop-labels&quot;&gt;labels&lt;/a&gt;. Only &lt;code&gt;loop&lt;/code&gt; supports &lt;a href=&quot;loop-expr#break-and-loop-values&quot;&gt;evaluation to non-trivial values&lt;/a&gt;.</source>
          <target state="translated">4つのタイプのループはすべて、&lt;a href=&quot;loop-expr#break-expressions&quot;&gt; &lt;code&gt;break&lt;/code&gt; 式&lt;/a&gt;、&lt;a href=&quot;loop-expr#continue-expressions&quot;&gt; &lt;code&gt;continue&lt;/code&gt; 式&lt;/a&gt;、および&lt;a href=&quot;loop-expr#loop-labels&quot;&gt;ラベルを&lt;/a&gt;サポートしています。 &lt;code&gt;loop&lt;/code&gt; のみが&lt;a href=&quot;loop-expr#break-and-loop-values&quot;&gt;重要な値への評価を&lt;/a&gt;サポートしています。</target>
        </trans-unit>
        <trans-unit id="0615d0c10f128d4e7e9a656552c9285eca738194" translate="yes" xml:space="preserve">
          <source>All function items implement &lt;a href=&quot;../../std/ops/trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../std/ops/trait.fnonce&quot;&gt;&lt;code&gt;FnOnce&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../special-types-and-traits#clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../special-types-and-traits#send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">すべての関数項目は、&lt;a href=&quot;../../std/ops/trait.fn&quot;&gt; &lt;code&gt;Fn&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../std/ops/trait.fnonce&quot;&gt; &lt;code&gt;FnOnce&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../special-types-and-traits#clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../special-types-and-traits#send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;../special-types-and-traits#sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt;実装します。</target>
        </trans-unit>
        <trans-unit id="36815ff2f54c1ef032403bd6365a096bb5c32000" translate="yes" xml:space="preserve">
          <source>All function parameters are in the scope of the entire function body, so are dropped last when evaluating the function. Each actual function parameter is dropped after any bindings introduced in that parameter's pattern.</source>
          <target state="translated">すべての関数パラメータは関数本体全体のスコープ内にあるため、関数を評価する際には最後に削除されます。各実際の関数パラメータは、そのパラメータのパターンに導入されたバインディングの後に削除されます。</target>
        </trans-unit>
        <trans-unit id="c77d0720d55ff4ece3326614a73ddde6503e3179" translate="yes" xml:space="preserve">
          <source>All implementations of &lt;code&gt;Unsize&lt;/code&gt; are provided automatically by the compiler.</source>
          <target state="translated">&lt;code&gt;Unsize&lt;/code&gt; のすべての実装は、コンパイラによって自動的に提供されます。</target>
        </trans-unit>
        <trans-unit id="94282a18d174676690037624bae4b4b406cb02ee" translate="yes" xml:space="preserve">
          <source>All iterators implement a trait named &lt;code&gt;Iterator&lt;/code&gt; that is defined in the standard library. The definition of the trait looks like this:</source>
          <target state="translated">すべての反復子は、標準ライブラリで定義されている &lt;code&gt;Iterator&lt;/code&gt; という名前の特性を実装します。トレイトの定義は次のようになります。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
