<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="2c5134e463153b73435701f263a503592ab3d53a" translate="yes" xml:space="preserve">
          <source>Go into the &lt;em&gt;hello_cargo&lt;/em&gt; directory and list the files. You&amp;rsquo;ll see that Cargo has generated two files and one directory for us: a &lt;em&gt;Cargo.toml&lt;/em&gt; file and a &lt;em&gt;src&lt;/em&gt; directory with a &lt;em&gt;main.rs&lt;/em&gt; file inside. It has also initialized a new Git repository along with a &lt;em&gt;.gitignore&lt;/em&gt; file.</source>
          <target state="translated">&lt;em&gt;hello_cargo&lt;/em&gt;ディレクトリに移動し、ファイルを一覧表示します。：あなたは、貨物が私たちのための2つのファイルとディレクトリ1生成されたことがわかります&lt;em&gt;Cargo.tomlの&lt;/em&gt;ファイルと&lt;em&gt;のsrc&lt;/em&gt;とディレクトリ&lt;em&gt;main.rsの&lt;/em&gt;ファイル内部を。また、&lt;em&gt;.gitignore&lt;/em&gt;ファイルとともに新しいGitリポジトリを初期化しました。</target>
        </trans-unit>
        <trans-unit id="50e6889164bb8054d882b924cda71582b6d6d180" translate="yes" xml:space="preserve">
          <source>Going finite with &lt;a href=&quot;trait.iterator#method.take&quot;&gt;&lt;code&gt;Iterator::take()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;trait.iterator#method.take&quot;&gt; &lt;code&gt;Iterator::take()&lt;/code&gt; &lt;/a&gt;有限化：</target>
        </trans-unit>
        <trans-unit id="b6849789947c3320fec7645aaddce84614976c34" translate="yes" xml:space="preserve">
          <source>Going finite with &lt;a href=&quot;trait.iterator#method.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;trait.iterator#method.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt;有限になる：</target>
        </trans-unit>
        <trans-unit id="62320f24d2e67e3a996b5eb69a47e8e61772abe1" translate="yes" xml:space="preserve">
          <source>Graceful Shutdown and Cleanup</source>
          <target state="translated">優雅なシャットダウンとクリーンアップ</target>
        </trans-unit>
        <trans-unit id="14b567b853879017732fc7e6b51b1225fb2590d3" translate="yes" xml:space="preserve">
          <source>Gradual initialization of an &lt;code&gt;UnsafeCell&lt;/code&gt; requires &lt;code&gt;raw_get&lt;/code&gt;, as calling &lt;code&gt;get&lt;/code&gt; would require creating a reference to uninitialized data:</source>
          <target state="translated">&lt;code&gt;UnsafeCell&lt;/code&gt; を段階的に初期化するには、raw_getが必要 &lt;code&gt;raw_get&lt;/code&gt; 、 &lt;code&gt;get&lt;/code&gt; を呼び出すと、初期化されていないデータへの参照を作成する必要があるためです。</target>
        </trans-unit>
        <trans-unit id="dd17342cb47b948d64f169d73cfeec3f8b3e3f31" translate="yes" xml:space="preserve">
          <source>Grammar</source>
          <target state="translated">Grammar</target>
        </trans-unit>
        <trans-unit id="78e61d853fc7dbe21e195185b06132c0a0b3267c" translate="yes" xml:space="preserve">
          <source>Great! The code read and then printed the contents of the file. But the code has a few flaws. The &lt;code&gt;main&lt;/code&gt; function has multiple responsibilities: generally, functions are clearer and easier to maintain if each function is responsible for only one idea. The other problem is that we&amp;rsquo;re not handling errors as well as we could. The program is still small, so these flaws aren&amp;rsquo;t a big problem, but as the program grows, it will be harder to fix them cleanly. It&amp;rsquo;s good practice to begin refactoring early on when developing a program, because it&amp;rsquo;s much easier to refactor smaller amounts of code. We&amp;rsquo;ll do that next.</source>
          <target state="translated">すごい！コードはファイルの内容を読み取って印刷しました。しかし、コードにはいくつかの欠陥があります。 &lt;code&gt;main&lt;/code&gt; 機能は、複数の役割があります。各関数は一つだけのアイデアのために責任がある場合には、一般的に、機能が明確と保守が容易です。もう1つの問題は、できる限りエラーを処理していないことです。プログラムはまだ小さいので、これらの欠陥は大きな問題ではありませんが、プログラムが大きくなるにつれて、それらをきれいに修正することが難しくなります。少量のコードをリファクタリングする方がはるかに簡単であるため、プログラムの開発時に早い段階でリファクタリングを開始することをお勧めします。次にそれを行います。</target>
        </trans-unit>
        <trans-unit id="24a6854de536fe8272a59608dce7cfe696deeaaa" translate="yes" xml:space="preserve">
          <source>Great! They passed. Now, let&amp;rsquo;s call the new &lt;code&gt;search_case_insensitive&lt;/code&gt; function from the &lt;code&gt;run&lt;/code&gt; function. First, we&amp;rsquo;ll add a configuration option to the &lt;code&gt;Config&lt;/code&gt; struct to switch between case-sensitive and case-insensitive search. Adding this field will cause compiler errors because we aren&amp;rsquo;t initializing this field anywhere yet:</source>
          <target state="translated">すごい！彼らは合格した。それでは、新しい呼びましょう &lt;code&gt;search_case_insensitive&lt;/code&gt; から関数 &lt;code&gt;run&lt;/code&gt; 機能を。最初に、大文字と小文字を区別する検索と区別しない検索を切り替えるために、 &lt;code&gt;Config&lt;/code&gt; 構造体に構成オプションを追加します。このフィールドをまだ初期化していないため、このフィールドを追加するとコンパイラエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="64d373f5a71955e4f9210539868f04851ae696bb" translate="yes" xml:space="preserve">
          <source>Great! This error tells us we need a &lt;code&gt;ThreadPool&lt;/code&gt; type or module, so we&amp;rsquo;ll build one now. Our &lt;code&gt;ThreadPool&lt;/code&gt; implementation will be independent of the kind of work our web server is doing. So, let&amp;rsquo;s switch the &lt;code&gt;hello&lt;/code&gt; crate from a binary crate to a library crate to hold our &lt;code&gt;ThreadPool&lt;/code&gt; implementation. After we change to a library crate, we could also use the separate thread pool library for any work we want to do using a thread pool, not just for serving web requests.</source>
          <target state="translated">すごい！このエラーは、 &lt;code&gt;ThreadPool&lt;/code&gt; タイプまたはモジュールが必要であることを示しているので、今すぐ作成します。私たち &lt;code&gt;ThreadPool&lt;/code&gt; の実装は、当社のウェブサーバが行っている仕事の種類とは無関係になります。それでは、 &lt;code&gt;hello&lt;/code&gt; クレートをバイナリクレートからライブラリクレートに切り替えて、 &lt;code&gt;ThreadPool&lt;/code&gt; 実装を保持しましょう。ライブラリクレートに変更した後、Webリクエストを処理するためだけでなく、スレッドプールを使用して実行したいすべての作業に別のスレッドプールライブラリを使用することもできます。</target>
        </trans-unit>
        <trans-unit id="99b891e6f196f47f49f63f0b20ce223eaba55683" translate="yes" xml:space="preserve">
          <source>Great! This output is much friendlier for our users.</source>
          <target state="translated">素晴らしい! この出力は、私たちのユーザーにとってより親しみやすいものになっています。</target>
        </trans-unit>
        <trans-unit id="2929f4d3537f13046a6a6654b391acff14ad5b53" translate="yes" xml:space="preserve">
          <source>Great, the program is working! The values of the arguments we need are being saved into the right variables. Later we&amp;rsquo;ll add some error handling to deal with certain potential erroneous situations, such as when the user provides no arguments; for now, we&amp;rsquo;ll ignore that situation and work on adding file-reading capabilities instead.</source>
          <target state="translated">プログラムは正常に機能しています。必要な引数の値は適切な変数に保存されています。後で、ユーザーが引数を指定しない場合など、特定のエラーの可能性がある状況に対処するために、いくつかのエラー処理を追加します。今のところは、この状況を無視して、代わりにファイル読み取り機能の追加に取り組みます。</target>
        </trans-unit>
        <trans-unit id="c5f93da0af9ef56fee44e82925405c317fbf7afc" translate="yes" xml:space="preserve">
          <source>Great, the test fails, exactly as we expected. Let&amp;rsquo;s get the test to pass!</source>
          <target state="translated">すばらしい、テストは予想通り失敗しました。テストに合格しましょう！</target>
        </trans-unit>
        <trans-unit id="599294f23ef04a992bc69ba465066344c3c7cf34" translate="yes" xml:space="preserve">
          <source>Greater than</source>
          <target state="translated">グレーター</target>
        </trans-unit>
        <trans-unit id="cc21fdb8f5e4e1d5b5c729ed455db20a348682c5" translate="yes" xml:space="preserve">
          <source>Greater than comparison</source>
          <target state="translated">比較よりも大きい</target>
        </trans-unit>
        <trans-unit id="a2919540599e9df0beb579ca8d46bdc142657611" translate="yes" xml:space="preserve">
          <source>Greater than or equal to</source>
          <target state="translated">以上</target>
        </trans-unit>
        <trans-unit id="17e61387621cb5a7a3632ffc26d2a8ab3f16e769" translate="yes" xml:space="preserve">
          <source>Greater than or equal to comparison</source>
          <target state="translated">比較対象となるものと同等以上</target>
        </trans-unit>
        <trans-unit id="d667800b5ed7b98aa0dde326047666b10d805fc3" translate="yes" xml:space="preserve">
          <source>Greater-than comparison for two &lt;code&gt;Arc&lt;/code&gt;s.</source>
          <target state="translated">2つの &lt;code&gt;Arc&lt;/code&gt; の大なり比較。</target>
        </trans-unit>
        <trans-unit id="3f06e7136cc69760b0d1c2aa5adb37088b0a0311" translate="yes" xml:space="preserve">
          <source>Greater-than comparison for two &lt;code&gt;Rc&lt;/code&gt;s.</source>
          <target state="translated">2つの &lt;code&gt;Rc&lt;/code&gt; の大なり比較。</target>
        </trans-unit>
        <trans-unit id="f464c4ed26773e9c5252581a89a104e8de23d490" translate="yes" xml:space="preserve">
          <source>Greek letters &quot;&amp;alpha;&quot; &quot;&amp;beta;&quot; &quot;&amp;gamma;&quot; &quot;&amp;delta;&quot; stand for potentially empty token-tree sequences. (However, the Greek letter &quot;&amp;epsilon;&quot; (epsilon) has a special role in the presentation and does not stand for a token-tree sequence.)</source>
          <target state="translated">ギリシャ文字「&amp;alpha;」「&amp;beta;」「&amp;gamma;」「&amp;delta;」は、潜在的に空のトークンツリーシーケンスを表します。（ただし、ギリシャ文字の「&amp;epsilon;」（イプシロン）はプレゼンテーションで特別な役割を果たし、トークンツリーシーケンスを表すものではありません。）</target>
        </trans-unit>
        <trans-unit id="90accf7e4de3f988bebb9b0fcc656094cc41c05f" translate="yes" xml:space="preserve">
          <source>Group expression attributes</source>
          <target state="translated">グループ式属性</target>
        </trans-unit>
        <trans-unit id="ef7a9bb1a692431ae6d8dff02418977a8053e1b7" translate="yes" xml:space="preserve">
          <source>Grouped expressions</source>
          <target state="translated">グループ化された表現</target>
        </trans-unit>
        <trans-unit id="13970f54032da4ae14dbff0318664d8c8f7ae9de" translate="yes" xml:space="preserve">
          <source>Grouped patterns</source>
          <target state="translated">グループ化されたパターン</target>
        </trans-unit>
        <trans-unit id="990b2d14bf2da723821496eca71bc9a4f287e41e" translate="yes" xml:space="preserve">
          <source>Grouping Configuration Values</source>
          <target state="translated">設定値のグループ化</target>
        </trans-unit>
        <trans-unit id="ad08922b155e0f0ecfa878359b6bdba11de6fcc5" translate="yes" xml:space="preserve">
          <source>Groups items</source>
          <target state="translated">グループ項目</target>
        </trans-unit>
        <trans-unit id="1dee13ac09a18c736a85fb7212501ca3f0535655" translate="yes" xml:space="preserve">
          <source>Gt</source>
          <target state="translated">Gt</target>
        </trans-unit>
        <trans-unit id="e72af43a28130c6f52db641d01a37aabf78c282e" translate="yes" xml:space="preserve">
          <source>Guarantees</source>
          <target state="translated">Guarantees</target>
        </trans-unit>
        <trans-unit id="643a27fb6062be0d6499f01fc4bde0f4334880b4" translate="yes" xml:space="preserve">
          <source>Guidance on which license is appropriate for your project is beyond the scope of this book. Many people in the Rust community license their projects in the same way as Rust by using a dual license of &lt;code&gt;MIT OR Apache-2.0&lt;/code&gt;. This practice demonstrates that you can also specify multiple license identifiers separated by &lt;code&gt;OR&lt;/code&gt; to have multiple licenses for your project.</source>
          <target state="translated">どのライセンスがプロジェクトに適しているかについてのガイダンスは、この本の範囲を超えています。Rustコミュニティの多くの人々は、 &lt;code&gt;MIT OR Apache-2.0&lt;/code&gt; デュアルライセンスを使用して、Rustと同じ方法でプロジェクトのライセンスを取得しています。このプラクティスは、 &lt;code&gt;OR&lt;/code&gt; で区切られた複数のライセンスIDを指定して、プロジェクトに複数のライセンスを持つこともできることを示しています。</target>
        </trans-unit>
        <trans-unit id="bf073fae640ded81eeb7a4cee70faff4a623c16c" translate="yes" xml:space="preserve">
          <source>Guide</source>
          <target state="translated">Guide</target>
        </trans-unit>
        <trans-unit id="5662999f81a9d63d43963dff643c8f2e0db48c56" translate="yes" xml:space="preserve">
          <source>Guidelines for Error Handling</source>
          <target state="translated">エラー処理のガイドライン</target>
        </trans-unit>
        <trans-unit id="0b19d1e1b8a5918571f9c9d135638b9f04547d8f" translate="yes" xml:space="preserve">
          <source>HANDLE</source>
          <target state="translated">HANDLE</target>
        </trans-unit>
        <trans-unit id="1a486ce8f36726233061ec65b3f6bda493fd48c9" translate="yes" xml:space="preserve">
          <source>HEX_DIGIT : [&lt;code&gt;0&lt;/code&gt;-&lt;code&gt;9&lt;/code&gt;&lt;code&gt;a&lt;/code&gt;-&lt;code&gt;f&lt;/code&gt;&lt;code&gt;A&lt;/code&gt;-&lt;code&gt;F&lt;/code&gt;]</source>
          <target state="translated">HEX_DIGIT：[ &lt;code&gt;0&lt;/code&gt; - &lt;code&gt;9&lt;/code&gt; - &lt;code&gt;f&lt;/code&gt; &lt;code&gt;A&lt;/code&gt; - &lt;code&gt;F&lt;/code&gt; ] &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e195a9555456bea0e92fe340c3ae06ff639810c6" translate="yes" xml:space="preserve">
          <source>HEX_DIGIT&lt;sup&gt;1..6&lt;/sup&gt;</source>
          <target state="translated">HEX_DIGIT&lt;sup&gt;1..6&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="5f9c36747e4699e63511061195cedb992801b9d3" translate="yes" xml:space="preserve">
          <source>HEX_LITERAL :</source>
          <target state="translated">HEX_LITERAL .</target>
        </trans-unit>
        <trans-unit id="85b770e7ec266276f5de99706626234eb555c7b0" translate="yes" xml:space="preserve">
          <source>HTTP is a text-based protocol, and a request takes this format:</source>
          <target state="translated">HTTPはテキストベースのプロトコルで、リクエストはこの形式をとります。</target>
        </trans-unit>
        <trans-unit id="3c47a723a85c131d97bf2d4bd392d2947fe77f70" translate="yes" xml:space="preserve">
          <source>Had &lt;code&gt;path&lt;/code&gt; contained invalid unicode, the &lt;code&gt;to_string_lossy&lt;/code&gt; call might have returned &lt;code&gt;&quot;fo�.txt&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; に無効なUnicodeが含まれていた場合、 &lt;code&gt;to_string_lossy&lt;/code&gt; 呼び出しが &lt;code&gt;&quot;fo�.txt&quot;&lt;/code&gt; 返した可能性があります。</target>
        </trans-unit>
        <trans-unit id="2ee4aa46e82881f4a75375987b71c3131634f94f" translate="yes" xml:space="preserve">
          <source>Handling Errors Returned from &lt;code id=&quot;handling-errors-returned-from-run-in-main&quot;&gt;run&lt;/code&gt; in &lt;code&gt;main&lt;/code&gt;</source>
          <target state="translated">返されたエラーの処理 &lt;code id=&quot;handling-errors-returned-from-run-in-main&quot;&gt;run&lt;/code&gt; 中に &lt;code&gt;main&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="187689d6fbeb450bd6ea4e652dae8dbfd0f10e3e" translate="yes" xml:space="preserve">
          <source>Handling I/O</source>
          <target state="translated">ハンドリングI/O</target>
        </trans-unit>
        <trans-unit id="f85b58414971efcc7eee439597523a8f745698cd" translate="yes" xml:space="preserve">
          <source>Handling Invalid Input</source>
          <target state="translated">無効入力処理</target>
        </trans-unit>
        <trans-unit id="99ae89ce9129c070f0e68c272cb53e5ebe7623fe" translate="yes" xml:space="preserve">
          <source>Handling Multiple Conditions with &lt;code id=&quot;handling-multiple-conditions-with-else-if&quot;&gt;else if&lt;/code&gt;</source>
          <target state="translated">&lt;code id=&quot;handling-multiple-conditions-with-else-if&quot;&gt;else if&lt;/code&gt; で複数の条件を処理する</target>
        </trans-unit>
        <trans-unit id="59aadebe3071fa59f50f2105cef14ad03fb21914" translate="yes" xml:space="preserve">
          <source>Handling Potential Failure with the &lt;code id=&quot;handling-potential-failure-with-the-result-type&quot;&gt;Result&lt;/code&gt; Type</source>
          <target state="translated">&lt;code id=&quot;handling-potential-failure-with-the-result-type&quot;&gt;Result&lt;/code&gt; タイプによる潜在的な障害の処理</target>
        </trans-unit>
        <trans-unit id="90b8d168f939ff8e48ed694781964a3efae61546" translate="yes" xml:space="preserve">
          <source>Handling concurrent programming safely and efficiently is another of Rust&amp;rsquo;s major goals. &lt;em&gt;Concurrent programming&lt;/em&gt;, where different parts of a program execute independently, and &lt;em&gt;parallel programming&lt;/em&gt;, where different parts of a program execute at the same time, are becoming increasingly important as more computers take advantage of their multiple processors. Historically, programming in these contexts has been difficult and error prone: Rust hopes to change that.</source>
          <target state="translated">安全かつ効率的に並行プログラミングを処理することは、Rustのもう1つの主要な目標です。&lt;em&gt;プログラムの&lt;/em&gt;さまざまな部分が独立して実行される&lt;em&gt;並行プログラミング&lt;/em&gt;や、プログラムのさまざまな部分が同時に実行される&lt;em&gt;並列プログラミング&lt;/em&gt;は、複数のプロセッサが複数のプロセッサを利用するようになるにつれて、ますます重要になっています。歴史的に、これらのコンテキストでのプログラミングは困難でエラーが発生しやすかった：Rustはそれを変えることを望んでいる。</target>
        </trans-unit>
        <trans-unit id="8f7b16e3844bb9bbaa86ba42b5bf793b3b5747f5" translate="yes" xml:space="preserve">
          <source>Handling errors (&lt;a href=&quot;ch09-00-error-handling&quot;&gt;Chapter 9&lt;/a&gt;)</source>
          <target state="translated">エラーの処理（&lt;a href=&quot;ch09-00-error-handling&quot;&gt;第9章&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="a8a516b582d8ee827caa06b852f0927dd7ea1aa9" translate="yes" xml:space="preserve">
          <source>Handling the error if &lt;code&gt;run&lt;/code&gt; returns an error</source>
          <target state="translated">&lt;code&gt;run&lt;/code&gt; がエラーを返した場合のエラーの処理</target>
        </trans-unit>
        <trans-unit id="9779c3f0bfcc6c7bd84ac8dc1d7d0faaf0886246" translate="yes" xml:space="preserve">
          <source>Has no effect and returns &lt;code&gt;None&lt;/code&gt; if the &lt;code&gt;OnceCell&lt;/code&gt; hasn't been initialized.</source>
          <target state="translated">効果はなく、 &lt;code&gt;OnceCell&lt;/code&gt; が初期化されていない場合は &lt;code&gt;None&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="59701e203928fde4afc37f856c0fe1389efbf77a" translate="yes" xml:space="preserve">
          <source>Has no effect and returns &lt;code&gt;None&lt;/code&gt; if the &lt;code&gt;SyncOnceCell&lt;/code&gt; hasn't been initialized.</source>
          <target state="translated">&lt;code&gt;SyncOnceCell&lt;/code&gt; が初期化されていない場合、効果はなく、 &lt;code&gt;None&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="605c9af0dc3550ddfefeee4d42138a7f1adc2bd1" translate="yes" xml:space="preserve">
          <source>Has the effects of both &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; together: For loads it uses &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; ordering. For stores it uses the &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; ordering.</source>
          <target state="translated">&lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt;の両方の効果があります。ロードの場合、&lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt;順序を使用します。ストアの場合、&lt;a href=&quot;enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt;順序を使用します。</target>
        </trans-unit>
        <trans-unit id="72f36c92a5a7396e8365dbdfe793e5eef4ad9431" translate="yes" xml:space="preserve">
          <source>Has the effects of both &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://llvm.org/docs/Atomics.html#release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; together: For loads it uses &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; ordering. For stores it uses the &lt;a href=&quot;https://llvm.org/docs/Atomics.html#release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; ordering.</source>
          <target state="translated">&lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;https://llvm.org/docs/Atomics.html#release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt;の両方の効果があります。ロードの場合は、&lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt;順序を使用します。ストアの場合は、&lt;a href=&quot;https://llvm.org/docs/Atomics.html#release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt;順序を使用します。</target>
        </trans-unit>
        <trans-unit id="873507a022b58de26a88deae87268cbd8d6af5b1" translate="yes" xml:space="preserve">
          <source>Hash</source>
          <target state="translated">Hash</target>
        </trans-unit>
        <trans-unit id="d16b2d08d75092ccdbc53063c23e2c3fe71d7f34" translate="yes" xml:space="preserve">
          <source>Hash Maps and Ownership</source>
          <target state="translated">ハッシュマップと所有権</target>
        </trans-unit>
        <trans-unit id="49d09ebb7291bff93c80ac3f381f55fe8a3c4cbf" translate="yes" xml:space="preserve">
          <source>Hash a raw pointer.</source>
          <target state="translated">生ポインタをハッシュします。</target>
        </trans-unit>
        <trans-unit id="6c5bfe7d7f5d3cec7864d666ab67d3faebb741c0" translate="yes" xml:space="preserve">
          <source>Hash maps are useful when you want to look up data not by using an index, as you can with vectors, but by using a key that can be of any type. For example, in a game, you could keep track of each team&amp;rsquo;s score in a hash map in which each key is a team&amp;rsquo;s name and the values are each team&amp;rsquo;s score. Given a team name, you can retrieve its score.</source>
          <target state="translated">ハッシュマップは、ベクトルのようにインデックスを使用するのではなく、任意のタイプのキーを使用してデータを検索する場合に便利です。たとえば、ゲームでは、ハッシュマップで各チームのスコアを追跡できます。各キーはチームの名前で、値は各チームのスコアです。チーム名を指定すると、そのスコアを取得できます。</target>
        </trans-unit>
        <trans-unit id="f26fb9fba1361d959b70bbd8e0907090c8a67651" translate="yes" xml:space="preserve">
          <source>Hash memoization</source>
          <target state="translated">ハッシュメモ化</target>
        </trans-unit>
        <trans-unit id="1ca569e43628039695db4d117d37cb0433c51032" translate="yes" xml:space="preserve">
          <source>Hash::hash</source>
          <target state="translated">Hash::hash</target>
        </trans-unit>
        <trans-unit id="bac71fb916a479ac2558a2194819bf301931ca8b" translate="yes" xml:space="preserve">
          <source>Hash::hash_slice</source>
          <target state="translated">Hash::hash_slice</target>
        </trans-unit>
        <trans-unit id="ba62d7b8d0b157f714c6a6132554b38789c6ada5" translate="yes" xml:space="preserve">
          <source>HashMap</source>
          <target state="translated">HashMap</target>
        </trans-unit>
        <trans-unit id="fb7d8a23eadd1e4ece9d9a20a984c6c31289cb8b" translate="yes" xml:space="preserve">
          <source>HashMap::borrow</source>
          <target state="translated">HashMap::borrow</target>
        </trans-unit>
        <trans-unit id="610c174a39c8908fe163a07919237940fc37c1ca" translate="yes" xml:space="preserve">
          <source>HashMap::borrow_mut</source>
          <target state="translated">HashMap::borrow_mut</target>
        </trans-unit>
        <trans-unit id="5b073a19c1d948d2ff7ea181c3e6faa47ac950b7" translate="yes" xml:space="preserve">
          <source>HashMap::capacity</source>
          <target state="translated">HashMap::capacity</target>
        </trans-unit>
        <trans-unit id="290ef182063e668dbc9d6f81f0f99bd696eaa3ad" translate="yes" xml:space="preserve">
          <source>HashMap::clear</source>
          <target state="translated">HashMap::clear</target>
        </trans-unit>
        <trans-unit id="4504d7762629b3f09d106b8b2c49316387f83111" translate="yes" xml:space="preserve">
          <source>HashMap::clone</source>
          <target state="translated">HashMap::clone</target>
        </trans-unit>
        <trans-unit id="755ecc8e2fe0d53bf8d40f09d15dc41f5c72dee3" translate="yes" xml:space="preserve">
          <source>HashMap::clone_from</source>
          <target state="translated">HashMap::clone_from</target>
        </trans-unit>
        <trans-unit id="18149fd5a2f0ddb0a754ee5b20ae060122824af4" translate="yes" xml:space="preserve">
          <source>HashMap::clone_into</source>
          <target state="translated">HashMap::clone_into</target>
        </trans-unit>
        <trans-unit id="c981dd589a66a9541ad1bd942f956a943a21c776" translate="yes" xml:space="preserve">
          <source>HashMap::contains_key</source>
          <target state="translated">HashMap::contains_key</target>
        </trans-unit>
        <trans-unit id="6790c064706283f72985a00fd5d63757494362ee" translate="yes" xml:space="preserve">
          <source>HashMap::default</source>
          <target state="translated">HashMap::default</target>
        </trans-unit>
        <trans-unit id="ef89e29aa59c76930b39d07bb7c27f4f62ca4bc9" translate="yes" xml:space="preserve">
          <source>HashMap::drain</source>
          <target state="translated">HashMap::drain</target>
        </trans-unit>
        <trans-unit id="5c70bb5f39da25e4a3243cd372f9722cdd0aaa06" translate="yes" xml:space="preserve">
          <source>HashMap::entry</source>
          <target state="translated">HashMap::entry</target>
        </trans-unit>
        <trans-unit id="16580b886dde904eb2189a50aaa2ec8e66754a76" translate="yes" xml:space="preserve">
          <source>HashMap::eq</source>
          <target state="translated">HashMap::eq</target>
        </trans-unit>
        <trans-unit id="006972122bed4c52275751aaa6b1a76aa26a72f6" translate="yes" xml:space="preserve">
          <source>HashMap::extend</source>
          <target state="translated">HashMap::extend</target>
        </trans-unit>
        <trans-unit id="eef27e5aeaaee7ca97ef32c4174c3b7aefbfc638" translate="yes" xml:space="preserve">
          <source>HashMap::fmt</source>
          <target state="translated">HashMap::fmt</target>
        </trans-unit>
        <trans-unit id="2bac685119eec98678bcc3e2df09e34b76b251fb" translate="yes" xml:space="preserve">
          <source>HashMap::from</source>
          <target state="translated">HashMap::from</target>
        </trans-unit>
        <trans-unit id="23702b4af8c6608c05d1fc72b700af47889b23e4" translate="yes" xml:space="preserve">
          <source>HashMap::from_iter</source>
          <target state="translated">HashMap::from_iter</target>
        </trans-unit>
        <trans-unit id="688fd04b9fb0128d305e248d2f3d8f8222392c9c" translate="yes" xml:space="preserve">
          <source>HashMap::get</source>
          <target state="translated">HashMap::get</target>
        </trans-unit>
        <trans-unit id="ecd394b5e97d505b5180c88396d32eb04f7a2ef5" translate="yes" xml:space="preserve">
          <source>HashMap::get_key_value</source>
          <target state="translated">HashMap::get_key_value</target>
        </trans-unit>
        <trans-unit id="59fd726634d31c7b61261668c05f7485bf9decb1" translate="yes" xml:space="preserve">
          <source>HashMap::get_mut</source>
          <target state="translated">HashMap::get_mut</target>
        </trans-unit>
        <trans-unit id="9e2f5e352b69c23e1f8634441216dbbc589410a2" translate="yes" xml:space="preserve">
          <source>HashMap::hasher</source>
          <target state="translated">HashMap::hasher</target>
        </trans-unit>
        <trans-unit id="977407424016d1150ed5a54f71aa720d8b5fc1e0" translate="yes" xml:space="preserve">
          <source>HashMap::index</source>
          <target state="translated">HashMap::index</target>
        </trans-unit>
        <trans-unit id="575b9b99b8b6536e98f82916772ec179324759de" translate="yes" xml:space="preserve">
          <source>HashMap::insert</source>
          <target state="translated">HashMap::insert</target>
        </trans-unit>
        <trans-unit id="4241974ff3713d57ec86ed4fb2960fb964b4c28f" translate="yes" xml:space="preserve">
          <source>HashMap::into</source>
          <target state="translated">HashMap::into</target>
        </trans-unit>
        <trans-unit id="2ee397e85e03d2df5163ed8c1f36f63a8275c934" translate="yes" xml:space="preserve">
          <source>HashMap::into_iter</source>
          <target state="translated">HashMap::into_iter</target>
        </trans-unit>
        <trans-unit id="a649d7141d86759b290a9b727d47ad161b114361" translate="yes" xml:space="preserve">
          <source>HashMap::is_empty</source>
          <target state="translated">HashMap::is_empty</target>
        </trans-unit>
        <trans-unit id="cfdbb20825a41950e4f6625ab41ffc0a12e6cfd4" translate="yes" xml:space="preserve">
          <source>HashMap::iter</source>
          <target state="translated">HashMap::iter</target>
        </trans-unit>
        <trans-unit id="2bfca7b0b17c04d487077c012bec3c640635d95c" translate="yes" xml:space="preserve">
          <source>HashMap::iter_mut</source>
          <target state="translated">HashMap::iter_mut</target>
        </trans-unit>
        <trans-unit id="15748fe38a254ba57dde931f14941b25230915de" translate="yes" xml:space="preserve">
          <source>HashMap::keys</source>
          <target state="translated">HashMap::keys</target>
        </trans-unit>
        <trans-unit id="013a2db0fc0510df2be8bb9a81336355dd6c81f5" translate="yes" xml:space="preserve">
          <source>HashMap::len</source>
          <target state="translated">HashMap::len</target>
        </trans-unit>
        <trans-unit id="bbd14da0450a45b2de193fcab5c00bb0eb5903d6" translate="yes" xml:space="preserve">
          <source>HashMap::ne</source>
          <target state="translated">HashMap::ne</target>
        </trans-unit>
        <trans-unit id="7a43b41cd29931fa0443de6420eab17418a5775e" translate="yes" xml:space="preserve">
          <source>HashMap::new</source>
          <target state="translated">HashMap::new</target>
        </trans-unit>
        <trans-unit id="292e274cb26beafe87f9986cd7a69d6e80f0d70e" translate="yes" xml:space="preserve">
          <source>HashMap::raw_entry</source>
          <target state="translated">HashMap::raw_entry</target>
        </trans-unit>
        <trans-unit id="ddac1348f5646998be5c764f10f7f59d986ae24a" translate="yes" xml:space="preserve">
          <source>HashMap::raw_entry_mut</source>
          <target state="translated">HashMap::raw_entry_mut</target>
        </trans-unit>
        <trans-unit id="eb7e68ea1cad35b4a180ddda2294c0954904ff9c" translate="yes" xml:space="preserve">
          <source>HashMap::remove</source>
          <target state="translated">HashMap::remove</target>
        </trans-unit>
        <trans-unit id="daa065a9f2946c9de97f049237fe61d1096fd3ad" translate="yes" xml:space="preserve">
          <source>HashMap::remove_entry</source>
          <target state="translated">HashMap::remove_entry</target>
        </trans-unit>
        <trans-unit id="0121bfc051e62887774fc3f9ec592514d686885b" translate="yes" xml:space="preserve">
          <source>HashMap::reserve</source>
          <target state="translated">HashMap::reserve</target>
        </trans-unit>
        <trans-unit id="88a2076f3660ecd79e0adb0243f0e9d4a8862721" translate="yes" xml:space="preserve">
          <source>HashMap::retain</source>
          <target state="translated">HashMap::retain</target>
        </trans-unit>
        <trans-unit id="f4991ea8c7797b408f7805334922bf7e0c8d10d6" translate="yes" xml:space="preserve">
          <source>HashMap::shrink_to</source>
          <target state="translated">HashMap::shrink_to</target>
        </trans-unit>
        <trans-unit id="dc8f377e69db6a1e9ed141ae6bf011880bd42c53" translate="yes" xml:space="preserve">
          <source>HashMap::shrink_to_fit</source>
          <target state="translated">HashMap::shrink_to_fit</target>
        </trans-unit>
        <trans-unit id="bab5c2ac135dfe90b9b32c652153883ceeee3b33" translate="yes" xml:space="preserve">
          <source>HashMap::to_owned</source>
          <target state="translated">HashMap::to_owned</target>
        </trans-unit>
        <trans-unit id="391acc19f610e927b497bb4e11b352a7b2af949e" translate="yes" xml:space="preserve">
          <source>HashMap::try_from</source>
          <target state="translated">HashMap::try_from</target>
        </trans-unit>
        <trans-unit id="2893c51bf9c281d2ca7aba047803684d9a1aa860" translate="yes" xml:space="preserve">
          <source>HashMap::try_into</source>
          <target state="translated">HashMap::try_into</target>
        </trans-unit>
        <trans-unit id="9e7015c3cc0d5bc1003d09ff24337d2b0ad55c7b" translate="yes" xml:space="preserve">
          <source>HashMap::try_reserve</source>
          <target state="translated">HashMap::try_reserve</target>
        </trans-unit>
        <trans-unit id="b2ebec04fba53bc16fb11b0073bb6cc66af50890" translate="yes" xml:space="preserve">
          <source>HashMap::type_id</source>
          <target state="translated">HashMap::type_id</target>
        </trans-unit>
        <trans-unit id="d17a786e030134db4f1882f47a85dce856cb6c49" translate="yes" xml:space="preserve">
          <source>HashMap::values</source>
          <target state="translated">HashMap::values</target>
        </trans-unit>
        <trans-unit id="162e585c9055d46d3b3067b924bb60d67e948304" translate="yes" xml:space="preserve">
          <source>HashMap::values_mut</source>
          <target state="translated">HashMap::values_mut</target>
        </trans-unit>
        <trans-unit id="01bde569a6ca247f70b925283ac4eabf1fae164b" translate="yes" xml:space="preserve">
          <source>HashMap::with_capacity</source>
          <target state="translated">HashMap::with_capacity</target>
        </trans-unit>
        <trans-unit id="c95ee5e43e53e6378ec649a9c2e69ab43598f8fb" translate="yes" xml:space="preserve">
          <source>HashMap::with_capacity_and_hasher</source>
          <target state="translated">HashMap::with_capacity_and_hasher</target>
        </trans-unit>
        <trans-unit id="e7c4071d4f77cdf1820942e0c1ab3de0a91ed2cf" translate="yes" xml:space="preserve">
          <source>HashMap::with_hasher</source>
          <target state="translated">HashMap::with_hasher</target>
        </trans-unit>
        <trans-unit id="cac17f9bdb6febebe0052a72f2ab8a6828d20944" translate="yes" xml:space="preserve">
          <source>HashSet</source>
          <target state="translated">HashSet</target>
        </trans-unit>
        <trans-unit id="b68646e63dfce36d83be9cbaa54a303ef6a007af" translate="yes" xml:space="preserve">
          <source>HashSet::bitand</source>
          <target state="translated">HashSet::bitand</target>
        </trans-unit>
        <trans-unit id="1ab81639812d7d4b62dc39b7419600230fdcf25f" translate="yes" xml:space="preserve">
          <source>HashSet::bitor</source>
          <target state="translated">HashSet::bitor</target>
        </trans-unit>
        <trans-unit id="8075cc2581f90ca9a8938fc5f82b21b6e3d28edf" translate="yes" xml:space="preserve">
          <source>HashSet::bitxor</source>
          <target state="translated">HashSet::bitxor</target>
        </trans-unit>
        <trans-unit id="c77b68f5068bcecde6e8ffd8572dfb041513399a" translate="yes" xml:space="preserve">
          <source>HashSet::borrow</source>
          <target state="translated">HashSet::borrow</target>
        </trans-unit>
        <trans-unit id="03d0b56c31db1f8ba8c12e20646074ec753d52c9" translate="yes" xml:space="preserve">
          <source>HashSet::borrow_mut</source>
          <target state="translated">HashSet::borrow_mut</target>
        </trans-unit>
        <trans-unit id="bdd5342708fbc173156c0ad0e7ccdcf72b87bbec" translate="yes" xml:space="preserve">
          <source>HashSet::capacity</source>
          <target state="translated">HashSet::capacity</target>
        </trans-unit>
        <trans-unit id="b496a7fc22db5dfee5a71eb5501bd54af27226af" translate="yes" xml:space="preserve">
          <source>HashSet::clear</source>
          <target state="translated">HashSet::clear</target>
        </trans-unit>
        <trans-unit id="f6f7e84776c0a1492c95ca329cccd559dae22239" translate="yes" xml:space="preserve">
          <source>HashSet::clone</source>
          <target state="translated">HashSet::clone</target>
        </trans-unit>
        <trans-unit id="ad872e535653208fd311ddac1851f60e92c27461" translate="yes" xml:space="preserve">
          <source>HashSet::clone_from</source>
          <target state="translated">HashSet::clone_from</target>
        </trans-unit>
        <trans-unit id="30071df27bb602cc36f2524cd6272f86cf175d82" translate="yes" xml:space="preserve">
          <source>HashSet::clone_into</source>
          <target state="translated">HashSet::clone_into</target>
        </trans-unit>
        <trans-unit id="e9929a76352b9c6c4517057784d174ca502e4659" translate="yes" xml:space="preserve">
          <source>HashSet::contains</source>
          <target state="translated">HashSet::contains</target>
        </trans-unit>
        <trans-unit id="ee9499c5d925a80b927374f5fc18c8cf7acba286" translate="yes" xml:space="preserve">
          <source>HashSet::default</source>
          <target state="translated">HashSet::default</target>
        </trans-unit>
        <trans-unit id="c5666651d6d13e045665faaee91da5ee35aefa99" translate="yes" xml:space="preserve">
          <source>HashSet::difference</source>
          <target state="translated">HashSet::difference</target>
        </trans-unit>
        <trans-unit id="559bf337908631f9dc2cd3ab1c34c4b7158b1609" translate="yes" xml:space="preserve">
          <source>HashSet::drain</source>
          <target state="translated">HashSet::drain</target>
        </trans-unit>
        <trans-unit id="f25e9846b65f287b930b9d456cbbec8f01e240e9" translate="yes" xml:space="preserve">
          <source>HashSet::eq</source>
          <target state="translated">HashSet::eq</target>
        </trans-unit>
        <trans-unit id="6a91f6923c3310862ee3596940ed5b097a1bf087" translate="yes" xml:space="preserve">
          <source>HashSet::extend</source>
          <target state="translated">HashSet::extend</target>
        </trans-unit>
        <trans-unit id="8be48241f0d314ab0acacea29d3d926070bb5fa9" translate="yes" xml:space="preserve">
          <source>HashSet::fmt</source>
          <target state="translated">HashSet::fmt</target>
        </trans-unit>
        <trans-unit id="b4f60277034657d60f3728ccd3956ff96b1819e2" translate="yes" xml:space="preserve">
          <source>HashSet::from</source>
          <target state="translated">HashSet::from</target>
        </trans-unit>
        <trans-unit id="60f387d38899e1b57c8d30e798c352963e26a097" translate="yes" xml:space="preserve">
          <source>HashSet::from_iter</source>
          <target state="translated">HashSet::from_iter</target>
        </trans-unit>
        <trans-unit id="33cae8d46ad9832e17073c4a9f1abb51a6504d81" translate="yes" xml:space="preserve">
          <source>HashSet::get</source>
          <target state="translated">HashSet::get</target>
        </trans-unit>
        <trans-unit id="6c7ba6a45c151f970088dcc70a1b7618e6395baf" translate="yes" xml:space="preserve">
          <source>HashSet::get_or_insert</source>
          <target state="translated">HashSet::get_or_insert</target>
        </trans-unit>
        <trans-unit id="3c9bf791b1bc89ff50ed8e094f3d77efdc799512" translate="yes" xml:space="preserve">
          <source>HashSet::get_or_insert_with</source>
          <target state="translated">HashSet::get_or_insert_with</target>
        </trans-unit>
        <trans-unit id="01c1744d870244b7145beb071040d269b906cc15" translate="yes" xml:space="preserve">
          <source>HashSet::hasher</source>
          <target state="translated">HashSet::hasher</target>
        </trans-unit>
        <trans-unit id="6f9a670d4aa69b73fdbaf199b1f0dd8253423bff" translate="yes" xml:space="preserve">
          <source>HashSet::insert</source>
          <target state="translated">HashSet::insert</target>
        </trans-unit>
        <trans-unit id="5c5bf765bc94406fc16ab265fee5caf8d4d6d147" translate="yes" xml:space="preserve">
          <source>HashSet::intersection</source>
          <target state="translated">HashSet::intersection</target>
        </trans-unit>
        <trans-unit id="1847c872f1c798ce2ed7fda1f927b3db87be02ae" translate="yes" xml:space="preserve">
          <source>HashSet::into</source>
          <target state="translated">HashSet::into</target>
        </trans-unit>
        <trans-unit id="06dc65fe61329213ae7394dadf80b120758e58bf" translate="yes" xml:space="preserve">
          <source>HashSet::into_iter</source>
          <target state="translated">HashSet::into_iter</target>
        </trans-unit>
        <trans-unit id="67c6eb738c50bfb089cc9e9dd3c556b76c5e5a19" translate="yes" xml:space="preserve">
          <source>HashSet::is_disjoint</source>
          <target state="translated">HashSet::is_disjoint</target>
        </trans-unit>
        <trans-unit id="9463f6acefaba610600eb7b086516e06a56e7415" translate="yes" xml:space="preserve">
          <source>HashSet::is_empty</source>
          <target state="translated">HashSet::is_empty</target>
        </trans-unit>
        <trans-unit id="3494ecfcdfcc0fd49b4716ada245492c590484c8" translate="yes" xml:space="preserve">
          <source>HashSet::is_subset</source>
          <target state="translated">HashSet::is_subset</target>
        </trans-unit>
        <trans-unit id="5a5bed7c64ac7bd90ff2fd3978bbf37d738addfa" translate="yes" xml:space="preserve">
          <source>HashSet::is_superset</source>
          <target state="translated">HashSet::is_superset</target>
        </trans-unit>
        <trans-unit id="d4aa44a96215a84918fccfb358fa46f4343aa9e3" translate="yes" xml:space="preserve">
          <source>HashSet::iter</source>
          <target state="translated">HashSet::iter</target>
        </trans-unit>
        <trans-unit id="e772fc3259c95bf6f1d149e4fe5b58f7beb84957" translate="yes" xml:space="preserve">
          <source>HashSet::len</source>
          <target state="translated">HashSet::len</target>
        </trans-unit>
        <trans-unit id="9d950bd82fcd2e87760e296232658decf6487907" translate="yes" xml:space="preserve">
          <source>HashSet::ne</source>
          <target state="translated">HashSet::ne</target>
        </trans-unit>
        <trans-unit id="faff6aa961e961cb5d0e5be8b0c1765f5a91c089" translate="yes" xml:space="preserve">
          <source>HashSet::new</source>
          <target state="translated">HashSet::new</target>
        </trans-unit>
        <trans-unit id="ab12b0529a6e1a5dea72839456e2d81f89fbb648" translate="yes" xml:space="preserve">
          <source>HashSet::remove</source>
          <target state="translated">HashSet::remove</target>
        </trans-unit>
        <trans-unit id="11dfa3918fa59c9dba2c405236023985e68113d1" translate="yes" xml:space="preserve">
          <source>HashSet::replace</source>
          <target state="translated">HashSet::replace</target>
        </trans-unit>
        <trans-unit id="f3111bd9bb9284dd24b994e9c70b335390828fac" translate="yes" xml:space="preserve">
          <source>HashSet::reserve</source>
          <target state="translated">HashSet::reserve</target>
        </trans-unit>
        <trans-unit id="ce64d74e2bc22c15cfa1eaba2edb312838993eda" translate="yes" xml:space="preserve">
          <source>HashSet::retain</source>
          <target state="translated">HashSet::retain</target>
        </trans-unit>
        <trans-unit id="029a9cdc9ae9ee65ed460a0ec02d113e093964b2" translate="yes" xml:space="preserve">
          <source>HashSet::shrink_to</source>
          <target state="translated">HashSet::shrink_to</target>
        </trans-unit>
        <trans-unit id="3aba29e196a563c0a26e6c5d67e4388b6713cebf" translate="yes" xml:space="preserve">
          <source>HashSet::shrink_to_fit</source>
          <target state="translated">HashSet::shrink_to_fit</target>
        </trans-unit>
        <trans-unit id="137d5ee967421f3423450e1436080f3b38640647" translate="yes" xml:space="preserve">
          <source>HashSet::sub</source>
          <target state="translated">HashSet::sub</target>
        </trans-unit>
        <trans-unit id="39cf21ce1dee41e9b1e7cb0c554d9ccf20702455" translate="yes" xml:space="preserve">
          <source>HashSet::symmetric_difference</source>
          <target state="translated">HashSet::symmetric_difference</target>
        </trans-unit>
        <trans-unit id="b78b12fa7d65d7ed557c2e12c743c86bcbc88775" translate="yes" xml:space="preserve">
          <source>HashSet::take</source>
          <target state="translated">HashSet::take</target>
        </trans-unit>
        <trans-unit id="93138236c5609c2dee4b1e913e9fcc9e3e9fdf44" translate="yes" xml:space="preserve">
          <source>HashSet::to_owned</source>
          <target state="translated">HashSet::to_owned</target>
        </trans-unit>
        <trans-unit id="96f13425b733a2e08673b87dffc523aee111609b" translate="yes" xml:space="preserve">
          <source>HashSet::try_from</source>
          <target state="translated">HashSet::try_from</target>
        </trans-unit>
        <trans-unit id="85d076b1561829592d046d057f0210cf9a4ff355" translate="yes" xml:space="preserve">
          <source>HashSet::try_into</source>
          <target state="translated">HashSet::try_into</target>
        </trans-unit>
        <trans-unit id="a9c0b3c82611415705e046ee581719e01be9eecc" translate="yes" xml:space="preserve">
          <source>HashSet::try_reserve</source>
          <target state="translated">HashSet::try_reserve</target>
        </trans-unit>
        <trans-unit id="105a18b817256119cb17af97da897c56eba29e40" translate="yes" xml:space="preserve">
          <source>HashSet::type_id</source>
          <target state="translated">HashSet::type_id</target>
        </trans-unit>
        <trans-unit id="685fa7682d344986ee2f2ae55086a7531364bc35" translate="yes" xml:space="preserve">
          <source>HashSet::union</source>
          <target state="translated">HashSet::union</target>
        </trans-unit>
        <trans-unit id="c3204331b41dcd6ae424437b8e36081a10f0c506" translate="yes" xml:space="preserve">
          <source>HashSet::with_capacity</source>
          <target state="translated">HashSet::with_capacity</target>
        </trans-unit>
        <trans-unit id="6bb25440ddefbed0a8db0d432f23f0ca38d089d8" translate="yes" xml:space="preserve">
          <source>HashSet::with_capacity_and_hasher</source>
          <target state="translated">HashSet::with_capacity_and_hasher</target>
        </trans-unit>
        <trans-unit id="550d3800dfa4eb2bdb493d733dabf4b1ffabf984" translate="yes" xml:space="preserve">
          <source>HashSet::with_hasher</source>
          <target state="translated">HashSet::with_hasher</target>
        </trans-unit>
        <trans-unit id="fc0f48d98ae0d2092a247d5cee9ccdb867d1d001" translate="yes" xml:space="preserve">
          <source>Hasher</source>
          <target state="translated">Hasher</target>
        </trans-unit>
        <trans-unit id="e9a193bcbf138ba881c64b5b1a29eba015da6009" translate="yes" xml:space="preserve">
          <source>Hasher::finish</source>
          <target state="translated">Hasher::finish</target>
        </trans-unit>
        <trans-unit id="2b1c79f133b4285e8cbe820d3b0dbaa110a81b6c" translate="yes" xml:space="preserve">
          <source>Hasher::write</source>
          <target state="translated">Hasher::write</target>
        </trans-unit>
        <trans-unit id="aea45433ea07ad24495217b0093e410e9770ebb6" translate="yes" xml:space="preserve">
          <source>Hasher::write_i128</source>
          <target state="translated">Hasher::write_i128</target>
        </trans-unit>
        <trans-unit id="f97466e2fd5ec3a618a0b518a5dd39118b1b15e0" translate="yes" xml:space="preserve">
          <source>Hasher::write_i16</source>
          <target state="translated">Hasher::write_i16</target>
        </trans-unit>
        <trans-unit id="10de8ddcd6d092ee0ae793c2f146d59545948d06" translate="yes" xml:space="preserve">
          <source>Hasher::write_i32</source>
          <target state="translated">Hasher::write_i32</target>
        </trans-unit>
        <trans-unit id="fa2e80124215b4059a687baa99ddde7e8adc899d" translate="yes" xml:space="preserve">
          <source>Hasher::write_i64</source>
          <target state="translated">Hasher::write_i64</target>
        </trans-unit>
        <trans-unit id="fe5b0947dfe31def847c17d1e11ec3d408a4124c" translate="yes" xml:space="preserve">
          <source>Hasher::write_i8</source>
          <target state="translated">Hasher::write_i8</target>
        </trans-unit>
        <trans-unit id="53164f3f3dd297fb85292187a041f87e1d16695e" translate="yes" xml:space="preserve">
          <source>Hasher::write_isize</source>
          <target state="translated">Hasher::write_isize</target>
        </trans-unit>
        <trans-unit id="e477fb5169da10ce163639bd122b949d5314f471" translate="yes" xml:space="preserve">
          <source>Hasher::write_u128</source>
          <target state="translated">Hasher::write_u128</target>
        </trans-unit>
        <trans-unit id="05c5de3720de3f253e1541c3b244cb58450b4be2" translate="yes" xml:space="preserve">
          <source>Hasher::write_u16</source>
          <target state="translated">Hasher::write_u16</target>
        </trans-unit>
        <trans-unit id="1cf90d27fda48a3335fb25c8aa60e25c50bc3767" translate="yes" xml:space="preserve">
          <source>Hasher::write_u32</source>
          <target state="translated">Hasher::write_u32</target>
        </trans-unit>
        <trans-unit id="420bdb25cc27d8fac4c5399c4359ccee510eacbd" translate="yes" xml:space="preserve">
          <source>Hasher::write_u64</source>
          <target state="translated">Hasher::write_u64</target>
        </trans-unit>
        <trans-unit id="82a921392efa7001c790d5b80024db7be281f9cb" translate="yes" xml:space="preserve">
          <source>Hasher::write_u8</source>
          <target state="translated">Hasher::write_u8</target>
        </trans-unit>
        <trans-unit id="d1a0408c2f79ae7c9f420468772c41716a5e1a04" translate="yes" xml:space="preserve">
          <source>Hasher::write_usize</source>
          <target state="translated">Hasher::write_usize</target>
        </trans-unit>
        <trans-unit id="461629db972167b8f4c1f8c130db9885c4944304" translate="yes" xml:space="preserve">
          <source>Hashing Functions</source>
          <target state="translated">ハッシュ関数</target>
        </trans-unit>
        <trans-unit id="baf48f49b04e2fe65712d113e9024e4c5a00d1bc" translate="yes" xml:space="preserve">
          <source>Haskell (GHC): typeclasses, type families</source>
          <target state="translated">Haskell (GHC):型クラス、型ファミリー</target>
        </trans-unit>
        <trans-unit id="0561de3a6257f6d36364146fd6581f1315dd2333" translate="yes" xml:space="preserve">
          <source>Having &lt;code&gt;common&lt;/code&gt; appear in the test results with &lt;code&gt;running 0 tests&lt;/code&gt; displayed for it is not what we wanted. We just wanted to share some code with the other integration test files.</source>
          <target state="translated">持つ &lt;code&gt;common&lt;/code&gt; 用いた試験結果に表示され &lt;code&gt;running 0 tests&lt;/code&gt; ことのために表示することは、我々が望んでいたものではありません。一部のコードを他の統合テストファイルと共有したかっただけです。</target>
        </trans-unit>
        <trans-unit id="11f087b15a668ce62e66a014863909ef9d55cd94" translate="yes" xml:space="preserve">
          <source>Having Multiple Owners of Mutable Data by Combining &lt;code id=&quot;having-multiple-owners-of-mutable-data-by-combining-rct-and-refcellt&quot;&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code id=&quot;having-multiple-owners-of-mutable-data-by-combining-rct-and-refcellt&quot;&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; と &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 組み合わせて、可変データの複数の所有者を持つ</target>
        </trans-unit>
        <trans-unit id="b3039ad6abf86928bcfdadaa49d3256f9e624f29" translate="yes" xml:space="preserve">
          <source>Having multiple relaxed default bounds is unsupported.</source>
          <target state="translated">緩和された複数のデフォルト境界を持つことはサポートされていません。</target>
        </trans-unit>
        <trans-unit id="6b19652c5d2b3e9984ece4975d1cc403d1ab4a0a" translate="yes" xml:space="preserve">
          <source>Having one mutable reference (&lt;code&gt;&amp;amp;mut T&lt;/code&gt;) to the object (also known as &lt;strong&gt;mutability&lt;/strong&gt;).</source>
          <target state="translated">オブジェクトへの1つの変更可能な参照（ &lt;code&gt;&amp;amp;mut T&lt;/code&gt; ）を持ちます（&lt;strong&gt;mutabilityと&lt;/strong&gt;も呼ばれます）。</target>
        </trans-unit>
        <trans-unit id="08041929016b8a695800e1c093d6357eb61d9428" translate="yes" xml:space="preserve">
          <source>Having several immutable references (&lt;code&gt;&amp;amp;T&lt;/code&gt;) to the object (also known as &lt;strong&gt;aliasing&lt;/strong&gt;).</source>
          <target state="translated">いくつかの不変参照（持つ &lt;code&gt;&amp;amp;T&lt;/code&gt; （としても知られているオブジェクトに）&lt;strong&gt;エイリアシング&lt;/strong&gt;）。</target>
        </trans-unit>
        <trans-unit id="89c8fa1c2c4d0b146e76f764a7dc959cbfc87737" translate="yes" xml:space="preserve">
          <source>Having to worry about the index in &lt;code&gt;word&lt;/code&gt; getting out of sync with the data in &lt;code&gt;s&lt;/code&gt; is tedious and error prone! Managing these indices is even more brittle if we write a &lt;code&gt;second_word&lt;/code&gt; function. Its signature would have to look like this:</source>
          <target state="translated">&lt;code&gt;word&lt;/code&gt; のインデックスが &lt;code&gt;s&lt;/code&gt; のデータと同期しなくなることを心配する必要があるのは、退屈でエラーが発生しやすいです。これらのインデックスの管理は、 &lt;code&gt;second_word&lt;/code&gt; 関数を記述した場合、さらに不安定になります。その署名は次のようになります。</target>
        </trans-unit>
        <trans-unit id="257810d9a0b57b3d3f2b083b4e88460a9ed6c299" translate="yes" xml:space="preserve">
          <source>Hello, Cargo!</source>
          <target state="translated">こんにちは、カーゴ!</target>
        </trans-unit>
        <trans-unit id="0a0a9f2a6772942557ab5355d76af442f8f65e01" translate="yes" xml:space="preserve">
          <source>Hello, World!</source>
          <target state="translated">ハロー、ワールド!</target>
        </trans-unit>
        <trans-unit id="d9d2b1e388fd73fa4e7cc0203db99342ed1255e1" translate="yes" xml:space="preserve">
          <source>Helper struct for safely printing paths with &lt;a href=&quot;../macro.format&quot;&gt;&lt;code&gt;format!&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;{}&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../macro.format&quot;&gt; &lt;code&gt;format!&lt;/code&gt; &lt;/a&gt;パスを安全に印刷するためのヘルパー構造体！および &lt;code&gt;{}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e8498955fde08da370bacddfd1434e8493282db8" translate="yes" xml:space="preserve">
          <source>Helper trait for &lt;a href=&quot;../primitive.slice#method.concat&quot;&gt;&lt;code&gt;[T]::concat&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../primitive.slice#method.concat&quot;&gt; &lt;code&gt;[T]::concat&lt;/code&gt; の&lt;/a&gt;ヘルパー特性。</target>
        </trans-unit>
        <trans-unit id="bbdd82587ac5843ce3d9f6e79bf40efba742c5a2" translate="yes" xml:space="preserve">
          <source>Helper trait for &lt;a href=&quot;../primitive.slice#method.join&quot;&gt;&lt;code&gt;[T]::join&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../primitive.slice#method.join&quot;&gt; &lt;code&gt;[T]::join&lt;/code&gt; の&lt;/a&gt;ヘルパー特性</target>
        </trans-unit>
        <trans-unit id="d8870a3f309d445b4b67cf35abad15e6e3e773d8" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;T&lt;/code&gt; is a trait object with two explicit lifetime bounds, 'a and 'b.</source>
          <target state="translated">ここで、 &lt;code&gt;T&lt;/code&gt; は、2つの明示的な有効期間の境界 'aと' bを持つ特性オブジェクトです。</target>
        </trans-unit>
        <trans-unit id="5c4fbb21f9ed5068758832ea51d122515fab93c7" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;X&lt;/code&gt; will have already been specified the discriminant 0 by the time &lt;code&gt;Y&lt;/code&gt; is encountered, so a conflict occurs.</source>
          <target state="translated">ここで、 &lt;code&gt;X&lt;/code&gt; は &lt;code&gt;Y&lt;/code&gt; に遭遇するまでに判別式0がすでに指定されているため、競合が発生します。</target>
        </trans-unit>
        <trans-unit id="b3f6e00f3163ec48a9acfd477c8ec87919fc2c8c" translate="yes" xml:space="preserve">
          <source>Here are a couple examples of this error:</source>
          <target state="translated">このエラーの例をいくつかご紹介します。</target>
        </trans-unit>
        <trans-unit id="8ff34494ac843686469f6f02e338741820201079" translate="yes" xml:space="preserve">
          <source>Here are examples of the comparison operators being used.</source>
          <target state="translated">比較演算子が使われている例を紹介します。</target>
        </trans-unit>
        <trans-unit id="bca374bff5c3dac21037ded7599cd1fe12249f7d" translate="yes" xml:space="preserve">
          <source>Here are examples of these operators being used.</source>
          <target state="translated">これらの演算子が使用されている例を紹介します。</target>
        </trans-unit>
        <trans-unit id="07272e166a1d2e40b130f94ad3a0aa3df774ca3b" translate="yes" xml:space="preserve">
          <source>Here are similar examples but now for LAST.</source>
          <target state="translated">ここに似たような例がありますが、今度はLASTの場合です。</target>
        </trans-unit>
        <trans-unit id="0a1abd5c7569db9404cdcd75f1cc6cdc0c6dca93" translate="yes" xml:space="preserve">
          <source>Here are some example of these operators</source>
          <target state="translated">以下にこれらの演算子の例を示します。</target>
        </trans-unit>
        <trans-unit id="4684b015ded3bc0731a2cef8198e5596403f6b07" translate="yes" xml:space="preserve">
          <source>Here are some examples of elision errors:</source>
          <target state="translated">エリシオンエラーの例をご紹介します。</target>
        </trans-unit>
        <trans-unit id="4bcc69e7a08f9cc053bd0cff82d93712f586660e" translate="yes" xml:space="preserve">
          <source>Here are some examples where expressions don't have extended temporary scopes:</source>
          <target state="translated">ここでは、式が拡張テンポラリスコープを持たない例をいくつか挙げます。</target>
        </trans-unit>
        <trans-unit id="c92962597dc4ffea4ff897a85b4d5e4dec6ca581" translate="yes" xml:space="preserve">
          <source>Here are some examples where expressions have extended temporary scopes:</source>
          <target state="translated">式が一時的なスコープを拡張した例をいくつか挙げます。</target>
        </trans-unit>
        <trans-unit id="0931022beea83b3afc095873234631b7243eeca4" translate="yes" xml:space="preserve">
          <source>Here are some examples:</source>
          <target state="translated">ここでは、いくつかの例をご紹介します。</target>
        </trans-unit>
        <trans-unit id="51de71d79af0f5165810b64b8288dc0e2f418033" translate="yes" xml:space="preserve">
          <source>Here are some examples: a reference to an &lt;code&gt;i32&lt;/code&gt; without a lifetime parameter, a reference to an &lt;code&gt;i32&lt;/code&gt; that has a lifetime parameter named &lt;code&gt;'a&lt;/code&gt;, and a mutable reference to an &lt;code&gt;i32&lt;/code&gt; that also has the lifetime &lt;code&gt;'a&lt;/code&gt;.</source>
          <target state="translated">参照：ここではいくつかの例であり、 &lt;code&gt;i32&lt;/code&gt; 寿命パラメータなしで、参照 &lt;code&gt;i32&lt;/code&gt; という名前の寿命パラメータがある &lt;code&gt;'a&lt;/code&gt; とし、変更可能な参照 &lt;code&gt;i32&lt;/code&gt; も寿命があること &lt;code&gt;'a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="20d5c7a1de98768721ba1e4861f1afaf92322548" translate="yes" xml:space="preserve">
          <source>Here are some of the things this module contains:</source>
          <target state="translated">このモジュールに含まれているものをいくつか紹介します。</target>
        </trans-unit>
        <trans-unit id="2a92602de41a70e7040e9f2a4fb9598c573570c2" translate="yes" xml:space="preserve">
          <source>Here are some simple examples of where you'll run into this error:</source>
          <target state="translated">このエラーが発生する場所の簡単な例をご紹介します。</target>
        </trans-unit>
        <trans-unit id="3a02d5c5d61bf51906767acca68761775d677fe8" translate="yes" xml:space="preserve">
          <source>Here are the abilities Unsafe Rust has in addition to Safe Rust:</source>
          <target state="translated">安全なラストに加えて、アンセーフラストが持っているアビリティを紹介します。</target>
        </trans-unit>
        <trans-unit id="5b8f26110eb51a4ab181ea0b693d59c927775bab" translate="yes" xml:space="preserve">
          <source>Here are the topics we&amp;rsquo;ll cover in this chapter:</source>
          <target state="translated">この章で取り上げるトピックは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="bc16616a997e1c54d6f12cfc92a13207a77b9160" translate="yes" xml:space="preserve">
          <source>Here are the two primary ways in which &lt;code&gt;entry&lt;/code&gt; is used. First, a simple example where the logic performed on the values is trivial.</source>
          <target state="translated">&lt;code&gt;entry&lt;/code&gt; が使用される2つの主な方法を次に示します。まず、値に対して実行されるロジックが簡単な簡単な例です。</target>
        </trans-unit>
        <trans-unit id="8d3de595e318046b488878fdfd592e24474accd6" translate="yes" xml:space="preserve">
          <source>Here executing &lt;code&gt;x = None&lt;/code&gt; would modify the value being matched and require us to go &quot;back in time&quot; to the &lt;code&gt;None&lt;/code&gt; arm.</source>
          <target state="translated">ここで &lt;code&gt;x = None&lt;/code&gt; を実行すると、一致する値が変更され、 &lt;code&gt;None&lt;/code&gt; アームに「戻る」必要があります。</target>
        </trans-unit>
        <trans-unit id="b54fff02e5e3fe8139f3151b798d2ca6781ef79d" translate="yes" xml:space="preserve">
          <source>Here executing &lt;code&gt;x = None&lt;/code&gt; would modify the value being matched and require us to go &quot;back in time&quot; to the &lt;code&gt;None&lt;/code&gt; arm. To fix it, change the value in the match arm:</source>
          <target state="translated">ここで &lt;code&gt;x = None&lt;/code&gt; を実行すると、一致する値が変更され、「過去にさかのぼって」 &lt;code&gt;None&lt;/code&gt; アームに戻る必要があります。これを修正するには、マッチアームの値を変更します。</target>
        </trans-unit>
        <trans-unit id="87b503ee6f76be5b3f344961161f897b4c2e8a33" translate="yes" xml:space="preserve">
          <source>Here is a basic example:</source>
          <target state="translated">基本的な例を紹介します。</target>
        </trans-unit>
        <trans-unit id="40d986bccf61bb4616c6b2d5e45138cb6f650868" translate="yes" xml:space="preserve">
          <source>Here is a recap of the reasons to choose &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;, or &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 、 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 、または &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; を選択する理由の要約は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="2fd70c4f72651018616cf4fae80bda013db29aef" translate="yes" xml:space="preserve">
          <source>Here is a variation on the previous example, showing that no further elements are taken from &lt;code&gt;iter&lt;/code&gt; after the first &lt;code&gt;Err&lt;/code&gt;.</source>
          <target state="translated">これは前の例のバリエーションで、最初の &lt;code&gt;Err&lt;/code&gt; の後に &lt;code&gt;iter&lt;/code&gt; から要素が取り出されないことを示しています。</target>
        </trans-unit>
        <trans-unit id="f2d33e000bef3fae0bc1e18459c72a6974d4c8ec" translate="yes" xml:space="preserve">
          <source>Here is a variation on the previous example, showing that no further elements are taken from &lt;code&gt;iter&lt;/code&gt; after the first &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">これは前の例のバリエーションで、最初の &lt;code&gt;None&lt;/code&gt; の後に &lt;code&gt;iter&lt;/code&gt; からそれ以上の要素が取られないことを示しています。</target>
        </trans-unit>
        <trans-unit id="64fa9f151e952c55124309eb57d3e7e04cdb27ce" translate="yes" xml:space="preserve">
          <source>Here is an example of the same &lt;code&gt;Point&lt;/code&gt; struct implementing the &lt;code&gt;Add&lt;/code&gt; trait using generics.</source>
          <target state="translated">以下は、ジェネリックを使用して &lt;code&gt;Add&lt;/code&gt; トレイトを実装する同じ &lt;code&gt;Point&lt;/code&gt; 構造体の例です。</target>
        </trans-unit>
        <trans-unit id="f4eeb15c7a7b93e1eb2dc6a8750be5fd94bbc8b2" translate="yes" xml:space="preserve">
          <source>Here is an example of the same &lt;code&gt;Point&lt;/code&gt; struct implementing the &lt;code&gt;Sub&lt;/code&gt; trait using generics.</source>
          <target state="translated">これは、ジェネリックを使用して &lt;code&gt;Sub&lt;/code&gt; トレイトを実装する同じ &lt;code&gt;Point&lt;/code&gt; 構造体の例です。</target>
        </trans-unit>
        <trans-unit id="e2a455b6868a34c4c660661290fdc27380049549" translate="yes" xml:space="preserve">
          <source>Here is an example response that uses HTTP version 1.1, has a status code of 200, an OK reason phrase, no headers, and no body:</source>
          <target state="translated">以下は、HTTP バージョン 1.1 を使用するレスポンスの例で、ステータスコードは 200、OK の理由フレーズ、ヘッダ、ボディがありません。</target>
        </trans-unit>
        <trans-unit id="8d3dccad44a11aba4a0bfd15fb7b2845992244bd" translate="yes" xml:space="preserve">
          <source>Here is an example showcasing how to soundly mutate the contents of an &lt;code&gt;UnsafeCell&amp;lt;_&amp;gt;&lt;/code&gt; despite there being multiple references aliasing the cell:</source>
          <target state="translated">セルをエイリアスする複数の参照があるにもかかわらず、 &lt;code&gt;UnsafeCell&amp;lt;_&amp;gt;&lt;/code&gt; コンテンツを適切に変更する方法を示す例を次に示します。</target>
        </trans-unit>
        <trans-unit id="f7c4ae388ef10758f9c1ee112d05af3dedb5a8c1" translate="yes" xml:space="preserve">
          <source>Here is an example that demonstrates the error:</source>
          <target state="translated">ここでは、そのエラーを示す例を示します。</target>
        </trans-unit>
        <trans-unit id="eb168180e8af601284ef4a6f97cd122e9d48a93f" translate="yes" xml:space="preserve">
          <source>Here is an example using ranges of &lt;code&gt;char&lt;/code&gt; values:</source>
          <target state="translated">以下は、 &lt;code&gt;char&lt;/code&gt; 値の範囲を使用した例です。</target>
        </trans-unit>
        <trans-unit id="2190806deeaf3eb0d2b99ddd8ded1889adb9e2dc" translate="yes" xml:space="preserve">
          <source>Here is an example where the third lifetime elision rule applies:</source>
          <target state="translated">ここでは、第三生涯のエリシオンルールが適用される例を示します。</target>
        </trans-unit>
        <trans-unit id="8be714949bc61ee0dfb58dd8b6d077f499efa300" translate="yes" xml:space="preserve">
          <source>Here is an example which increments every integer in a vector, checking for overflow:</source>
          <target state="translated">ここでは、オーバーフローがないかどうかをチェックしながら、ベクトル内のすべての整数をインクリメントする例を示します。</target>
        </trans-unit>
        <trans-unit id="b8d2a1ec18a168b45aede187d064b1d87d98387f" translate="yes" xml:space="preserve">
          <source>Here is an example which increments every integer in a vector. We use the checked variant of &lt;code&gt;add&lt;/code&gt; that returns &lt;code&gt;None&lt;/code&gt; when the calculation would result in an overflow.</source>
          <target state="translated">これは、ベクトルのすべての整数をインクリメントする例です。計算の結果がオーバーフローになる場合に &lt;code&gt;None&lt;/code&gt; を返す、checkedの &lt;code&gt;add&lt;/code&gt; バリアントを使用します。</target>
        </trans-unit>
        <trans-unit id="540ee2aaf7182c6dfc449b18e5accb694e3b0894" translate="yes" xml:space="preserve">
          <source>Here is an example:</source>
          <target state="translated">ここでは一例を紹介します。</target>
        </trans-unit>
        <trans-unit id="669e450458761957293db53fc0e8c919ba0f5a7a" translate="yes" xml:space="preserve">
          <source>Here is an unsafe function named &lt;code&gt;dangerous&lt;/code&gt; that doesn&amp;rsquo;t do anything in its body:</source>
          <target state="translated">以下は、本体で何もしない、 &lt;code&gt;dangerous&lt;/code&gt; という名前の安全でない関数です。</target>
        </trans-unit>
        <trans-unit id="d9606eca0f59289409929077841f751f72b656be" translate="yes" xml:space="preserve">
          <source>Here is another example that tries to subtract one from another list of integers, this time checking for underflow:</source>
          <target state="translated">ここでは、別の整数のリストから 1 つを減算しようとする別の例を示します。</target>
        </trans-unit>
        <trans-unit id="967e8f702b29651ccfd3eff162bdd1236f185e1b" translate="yes" xml:space="preserve">
          <source>Here is how you would define and use a &lt;code&gt;calculate_length&lt;/code&gt; function that has a reference to an object as a parameter instead of taking ownership of the value:</source>
          <target state="translated">値の所有権を取得する代わりに、オブジェクトへの参照をパラメーターとして持つ &lt;code&gt;calculate_length&lt;/code&gt; 関数を定義して使用する方法を次に示します。</target>
        </trans-unit>
        <trans-unit id="853cb0e889b6e921d08e41239a16f75171fa3cf1" translate="yes" xml:space="preserve">
          <source>Here is that same example again, with some explanatory comments:</source>
          <target state="translated">ここで再び同じ例を、いくつかの解説を交えて紹介します。</target>
        </trans-unit>
        <trans-unit id="183c940df02f2ac1c7e0b320aa5e4607c7fd14f0" translate="yes" xml:space="preserve">
          <source>Here is the error we get when we compile this code:</source>
          <target state="translated">このコードをコンパイルしたときに発生するエラーは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="20e589c1d30a718b69866f0e87eb12f8b53bb806" translate="yes" xml:space="preserve">
          <source>Here is the plan to build the web server:</source>
          <target state="translated">Webサーバーを構築するプランです。</target>
        </trans-unit>
        <trans-unit id="c50f83c6cf619c1c5fb8951e5f26cafe1c807151" translate="yes" xml:space="preserve">
          <source>Here is the previous example again, with the correct order:</source>
          <target state="translated">ここでもう一度、正しい順序で先ほどの例を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="c6b6ce6ac56caf7839b74c32ae618de3ed902bea" translate="yes" xml:space="preserve">
          <source>Here is this algorithm described in pseudocode.</source>
          <target state="translated">ここでは、このアルゴリズムを疑似コードで説明します。</target>
        </trans-unit>
        <trans-unit id="5ade7d43a649a8f35a37c5c4df50d404ac17d264" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;Apple&lt;/code&gt; variant has two fields, and should be matched against like so:</source>
          <target state="translated">ここでは、 &lt;code&gt;Apple&lt;/code&gt; バリアントには2つのフィールドがあり、次のように照合する必要があります。</target>
        </trans-unit>
        <trans-unit id="847a36b4e8f5bc18d0a990ee9501fe6c952a3db3" translate="yes" xml:space="preserve">
          <source>Here the type &lt;code&gt;T&lt;/code&gt; cannot have a relaxed bound for multiple default traits (&lt;code&gt;Sized&lt;/code&gt; and &lt;code&gt;Send&lt;/code&gt;). This can be fixed by only using one relaxed bound.</source>
          <target state="translated">ここで、タイプ &lt;code&gt;T&lt;/code&gt; は、複数のデフォルト特性（ &lt;code&gt;Sized&lt;/code&gt; および &lt;code&gt;Send&lt;/code&gt; ）に対して緩和された境界を持つことはできません。これは、1つの緩和された境界を使用するだけで修正できます。</target>
        </trans-unit>
        <trans-unit id="77492962523ab1872ec0db64f3e31206c8e37741" translate="yes" xml:space="preserve">
          <source>Here we create &lt;code&gt;Status::Value&lt;/code&gt; instances using each &lt;code&gt;u32&lt;/code&gt; value in the range that &lt;code&gt;map&lt;/code&gt; is called on by using the initializer function of &lt;code&gt;Status::Value&lt;/code&gt;. Some people prefer this style, and some people prefer to use closures. They compile to the same code, so use whichever style is clearer to you.</source>
          <target state="translated">ここでは、作成 &lt;code&gt;Status::Value&lt;/code&gt; それぞれ使用してインスタンス &lt;code&gt;u32&lt;/code&gt; こと範囲の値 &lt;code&gt;map&lt;/code&gt; の初期化関数使って、上と呼ばれている &lt;code&gt;Status::Value&lt;/code&gt; 。このスタイルを好む人もいれば、クロージャを使うことを好む人もいます。それらは同じコードにコンパイルされるので、あなたにとってより明確なスタイルを使用してください。</target>
        </trans-unit>
        <trans-unit id="ab78b83024b9be055a5f592dcee8323d7eae1a44" translate="yes" xml:space="preserve">
          <source>Here we get a warning about not using the variable &lt;code&gt;y&lt;/code&gt;, but we don&amp;rsquo;t get a warning about not using the variable preceded by the underscore.</source>
          <target state="translated">ここでは、変数 &lt;code&gt;y&lt;/code&gt; を使用しないという警告が表示されますが、アンダースコアが前に付いた変数を使用しないという警告は表示されません。</target>
        </trans-unit>
        <trans-unit id="c5caa2018a964f99eaa055d4bd09b35c0163bd0e" translate="yes" xml:space="preserve">
          <source>Here we have an addition of &lt;code&gt;d&lt;/code&gt; and &lt;code&gt;n.into()&lt;/code&gt;. Hence, &lt;code&gt;n.into()&lt;/code&gt; can return any type &lt;code&gt;T&lt;/code&gt; where &lt;code&gt;u64: Add&amp;lt;T&amp;gt;&lt;/code&gt;. On the other hand, the &lt;code&gt;into&lt;/code&gt; method can return any type where &lt;code&gt;u32: Into&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">ここでは、 &lt;code&gt;d&lt;/code&gt; と &lt;code&gt;n.into()&lt;/code&gt; が追加されています。したがって、 &lt;code&gt;n.into()&lt;/code&gt; は、 &lt;code&gt;u64: Add&amp;lt;T&amp;gt;&lt;/code&gt; である任意のタイプ &lt;code&gt;T&lt;/code&gt; を返すことができます。一方、 &lt;code&gt;into&lt;/code&gt; メソッドは、 &lt;code&gt;u32: Into&amp;lt;T&amp;gt;&lt;/code&gt; である任意の型を返すことができます。</target>
        </trans-unit>
        <trans-unit id="e6c5079a1585dd8c6aa581475ab7d948402fef68" translate="yes" xml:space="preserve">
          <source>Here we have an iterator &lt;code&gt;results&lt;/code&gt; over &lt;code&gt;Result&amp;lt;bool, ()&amp;gt;&lt;/code&gt;. Hence, &lt;code&gt;results.collect()&lt;/code&gt; can return any type implementing &lt;code&gt;FromIterator&amp;lt;Result&amp;lt;bool, ()&amp;gt;&amp;gt;&lt;/code&gt;. On the other hand, the &lt;code&gt;?&lt;/code&gt; operator can accept any type implementing &lt;code&gt;Try&lt;/code&gt;.</source>
          <target state="translated">ここでは、イテレータ持っている &lt;code&gt;results&lt;/code&gt; の上に &lt;code&gt;Result&amp;lt;bool, ()&amp;gt;&lt;/code&gt; 。したがって、 &lt;code&gt;results.collect()&lt;/code&gt; は、 &lt;code&gt;FromIterator&amp;lt;Result&amp;lt;bool, ()&amp;gt;&amp;gt;&lt;/code&gt; 実装する任意のタイプを返すことができます。一方、 &lt;code&gt;?&lt;/code&gt; オペレーターは、 &lt;code&gt;Try&lt;/code&gt; を実装する任意のタイプを受け入れることができます。</target>
        </trans-unit>
        <trans-unit id="cb5b6fe6a43391cbaff0a797a1749d4999cf682c" translate="yes" xml:space="preserve">
          <source>Here we have declared a string literal, also known as a string slice. String literals have a static lifetime, which means the string &lt;code&gt;hello_world&lt;/code&gt; is guaranteed to be valid for the duration of the entire program. We can explicitly specify &lt;code&gt;hello_world&lt;/code&gt;'s lifetime as well:</source>
          <target state="translated">ここでは、文字列リテラル（文字列スライスとも呼ばれます）を宣言しています。文字列リテラルには静的な有効期間があります。つまり、文字列 &lt;code&gt;hello_world&lt;/code&gt; はプログラム全体で有効であることが保証されています。 &lt;code&gt;hello_world&lt;/code&gt; のライフタイムも明示的に指定できます。</target>
        </trans-unit>
        <trans-unit id="4f6025ae753da089e1d8586a3532b960124e6dc6" translate="yes" xml:space="preserve">
          <source>Here we have used the &lt;code&gt;continue&lt;/code&gt; keyword incorrectly. As we have seen above that &lt;code&gt;continue&lt;/code&gt; pointing to a labeled block.</source>
          <target state="translated">ここでは、 &lt;code&gt;continue&lt;/code&gt; キーワードを誤って使用しています。上で見たように、それ &lt;code&gt;continue&lt;/code&gt; ラベル付けされたブロックを指し続けます。</target>
        </trans-unit>
        <trans-unit id="c6a5e69251fb02d97a8da5895df070cb741e7a14" translate="yes" xml:space="preserve">
          <source>Here we see that &lt;code&gt;flatten()&lt;/code&gt; does not perform a &quot;deep&quot; flatten. Instead, only one level of nesting is removed. That is, if you &lt;code&gt;flatten()&lt;/code&gt; a three-dimensional array the result will be two-dimensional and not one-dimensional. To get a one-dimensional structure, you have to &lt;code&gt;flatten()&lt;/code&gt; again.</source>
          <target state="translated">ここで、 &lt;code&gt;flatten()&lt;/code&gt; は「深い」平坦化を実行しないことがわかります。代わりに、ネストの1レベルのみが削除されます。つまり、3次元配列を &lt;code&gt;flatten()&lt;/code&gt; すると、結果は1次元ではなく2次元になります。1次元構造を取得するには、もう一度 &lt;code&gt;flatten()&lt;/code&gt; を実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="72ccb25410f6e8d0ac401f0e115875ab4db2e28c" translate="yes" xml:space="preserve">
          <source>Here we tell Rust that when the result is &lt;code&gt;Ok&lt;/code&gt;, return the inner &lt;code&gt;file&lt;/code&gt; value out of the &lt;code&gt;Ok&lt;/code&gt; variant, and we then assign that file handle value to the variable &lt;code&gt;f&lt;/code&gt;. After the &lt;code&gt;match&lt;/code&gt;, we can use the file handle for reading or writing.</source>
          <target state="translated">ここでは、結果が &lt;code&gt;Ok&lt;/code&gt; の場合、 &lt;code&gt;Ok&lt;/code&gt; バリアントから内部 &lt;code&gt;file&lt;/code&gt; 値を返し、そのファイルハンドル値を変数 &lt;code&gt;f&lt;/code&gt; に割り当てることをRustに伝えます。 &lt;code&gt;match&lt;/code&gt; 後、読み取りまたは書き込みにファイルハンドルを使用できます。</target>
        </trans-unit>
        <trans-unit id="80012795e5bb9f7fa353370133e88ca78ecd6ec8" translate="yes" xml:space="preserve">
          <source>Here we&amp;rsquo;re calling the &lt;code&gt;hello&lt;/code&gt; function with the argument &lt;code&gt;&amp;amp;m&lt;/code&gt;, which is a reference to a &lt;code&gt;MyBox&amp;lt;String&amp;gt;&lt;/code&gt; value. Because we implemented the &lt;code&gt;Deref&lt;/code&gt; trait on &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; in Listing 15-10, Rust can turn &lt;code&gt;&amp;amp;MyBox&amp;lt;String&amp;gt;&lt;/code&gt; into &lt;code&gt;&amp;amp;String&lt;/code&gt; by calling &lt;code&gt;deref&lt;/code&gt;. The standard library provides an implementation of &lt;code&gt;Deref&lt;/code&gt; on &lt;code&gt;String&lt;/code&gt; that returns a string slice, and this is in the API documentation for &lt;code&gt;Deref&lt;/code&gt;. Rust calls &lt;code&gt;deref&lt;/code&gt; again to turn the &lt;code&gt;&amp;amp;String&lt;/code&gt; into &lt;code&gt;&amp;amp;str&lt;/code&gt;, which matches the &lt;code&gt;hello&lt;/code&gt; function&amp;rsquo;s definition.</source>
          <target state="translated">ここでは、 &lt;code&gt;MyBox&amp;lt;String&amp;gt;&lt;/code&gt; 値への参照である引数 &lt;code&gt;&amp;amp;m&lt;/code&gt; を使用して &lt;code&gt;hello&lt;/code&gt; 関数を呼び出しています。我々が実装するので &lt;code&gt;Deref&lt;/code&gt; 特質上 &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; リスト15-10で、錆を変えることができます &lt;code&gt;&amp;amp;MyBox&amp;lt;String&amp;gt;&lt;/code&gt; に &lt;code&gt;&amp;amp;String&lt;/code&gt; を呼び出すことによって &lt;code&gt;deref&lt;/code&gt; 。標準ライブラリは、実装の提供 &lt;code&gt;Deref&lt;/code&gt; 上の &lt;code&gt;String&lt;/code&gt; 列のスライスを返し、これはのためのAPIドキュメントである &lt;code&gt;Deref&lt;/code&gt; 。 Rustは再び &lt;code&gt;deref&lt;/code&gt; を呼び出して &lt;code&gt;&amp;amp;String&lt;/code&gt; を &lt;code&gt;&amp;amp;str&lt;/code&gt; に変換します。これは &lt;code&gt;hello&lt;/code&gt; に一致します。 関数の定義。</target>
        </trans-unit>
        <trans-unit id="466e3552c39fe3a92c2d4c054173a56d883575cc" translate="yes" xml:space="preserve">
          <source>Here we&amp;rsquo;ve defined a struct and named it &lt;code&gt;Rectangle&lt;/code&gt;. Inside the curly brackets, we defined the fields as &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt;, both of which have type &lt;code&gt;u32&lt;/code&gt;. Then in &lt;code&gt;main&lt;/code&gt;, we created a particular instance of &lt;code&gt;Rectangle&lt;/code&gt; that has a width of 30 and a height of 50.</source>
          <target state="translated">ここでは、構造体を定義し、それに &lt;code&gt;Rectangle&lt;/code&gt; という名前を付けました。中括弧内では、フィールドを &lt;code&gt;width&lt;/code&gt; と &lt;code&gt;height&lt;/code&gt; として定義しました。どちらも &lt;code&gt;u32&lt;/code&gt; タイプです。次に &lt;code&gt;main&lt;/code&gt; で、幅が30、高さが50 の &lt;code&gt;Rectangle&lt;/code&gt; の特定のインスタンスを作成しました。</target>
        </trans-unit>
        <trans-unit id="817f9efff3a295f34cca74e6a4819cd4626be8b2" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a simple comment:</source>
          <target state="translated">ここに簡単なコメントがあります：</target>
        </trans-unit>
        <trans-unit id="539936e83a01369f912b07f9a46070e22c533c8a" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a small programming problem: write a function that takes a string and returns the first word it finds in that string. If the function doesn&amp;rsquo;t find a space in the string, the whole string must be one word, so the entire string should be returned.</source>
          <target state="translated">これが小さなプログラミング問題です。文字列を受け取り、その文字列で最初に見つかった単語を返す関数を記述します。関数が文字列内にスペースを見つけられない場合、文字列全体が1語である必要があるため、文字列全体が返されます。</target>
        </trans-unit>
        <trans-unit id="7f3b7e87f399f43770545cc13990ab6cc8dd6c83" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of a constant declaration where the constant&amp;rsquo;s name is &lt;code&gt;MAX_POINTS&lt;/code&gt; and its value is set to 100,000. (Rust&amp;rsquo;s naming convention for constants is to use all uppercase with underscores between words, and underscores can be inserted in numeric literals to improve readability):</source>
          <target state="translated">定数の名前が &lt;code&gt;MAX_POINTS&lt;/code&gt; で、値が100,000に設定されている定数宣言の例を次に示します。 （Rustの定数の命名規則は、単語間にアンダースコアを付けてすべて大文字を使用することです。読みやすくするために、数値リテラルにアンダースコアを挿入できます）：</target>
        </trans-unit>
        <trans-unit id="0e399b9c3b58dba78ca66c0c45518f8657e4f783" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of how the development and release process works: let&amp;rsquo;s assume that the Rust team is working on the release of Rust 1.5. That release happened in December of 2015, but it will provide us with realistic version numbers. A new feature is added to Rust: a new commit lands on the &lt;code&gt;master&lt;/code&gt; branch. Each night, a new nightly version of Rust is produced. Every day is a release day, and these releases are created by our release infrastructure automatically. So as time passes, our releases look like this, once a night:</source>
          <target state="translated">開発とリリースのプロセスの例を次に示します。RustチームがRust 1.5のリリースに取り組んでいると仮定します。このリリースは2015年12月に行われましたが、現実的なバージョン番号が提供されます。Rustに新しい機能が追加されました。新しいコミットは &lt;code&gt;master&lt;/code&gt; ブランチにあります。毎晩、毎晩新しいバージョンのRustが作成されます。毎日がリリース日であり、これらのリリースは当社のリリースインフラストラクチャによって自動的に作成されます。時間が経つにつれ、リリースは次のようになります。</target>
        </trans-unit>
        <trans-unit id="dd2c057fc04f01fae93788be5795a76d18a55fe9" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of the &lt;code&gt;clone&lt;/code&gt; method in action:</source>
          <target state="translated">実際の &lt;code&gt;clone&lt;/code&gt; メソッドの例を次に示します。</target>
        </trans-unit>
        <trans-unit id="01162de636320bfb3aac73f8ee64a4ca8f8b3f36" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example that shows floating-point numbers in action:</source>
          <target state="translated">以下は、浮動小数点数の動作を示す例です。</target>
        </trans-unit>
        <trans-unit id="b756692957834549ddc1e80ed843e1c05120a8e7" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s how it works: when you call a method with &lt;code&gt;object.something()&lt;/code&gt;, Rust automatically adds in &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;&amp;amp;mut&lt;/code&gt;, or &lt;code&gt;*&lt;/code&gt; so &lt;code&gt;object&lt;/code&gt; matches the signature of the method. In other words, the following are the same:</source>
          <target state="translated">動作方法は &lt;code&gt;object.something()&lt;/code&gt; を使用してメソッドを呼び出すと、Rustは自動的に &lt;code&gt;&amp;amp;&lt;/code&gt; 、 &lt;code&gt;&amp;amp;mut&lt;/code&gt; 、または &lt;code&gt;*&lt;/code&gt; を追加するため、 &lt;code&gt;object&lt;/code&gt; はメソッドのシグネチャと一致します。つまり、以下は同じです。</target>
        </trans-unit>
        <trans-unit id="bbfc2aa9173a426f43e60848a0174bac37b702fe" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the compiler error:</source>
          <target state="translated">コンパイラエラーは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="7ba4bf6763c0003ca703ce8f7299229f35cbda9a" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the error:</source>
          <target state="translated">ここにエラーがあります：</target>
        </trans-unit>
        <trans-unit id="916eb038e9d9b0f05a6d2dec1a88d2849aef616b" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the full code for reference:</source>
          <target state="translated">参照用の完全なコードは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="815ea8397604a0309cd918e79463e69ce092e31e" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the resulting compilation error:</source>
          <target state="translated">結果のコンパイルエラーは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="0221cef214e9504c84ca1c9204c7ee34f36785b0" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the scenario we&amp;rsquo;ll test: we&amp;rsquo;ll create a library that tracks a value against a maximum value and sends messages based on how close to the maximum value the current value is. This library could be used to keep track of a user&amp;rsquo;s quota for the number of API calls they&amp;rsquo;re allowed to make, for example.</source>
          <target state="translated">テストするシナリオは次のとおりです。最大値に対する値を追跡し、現在の値がどれだけ最大値に近いかに基づいてメッセージを送信するライブラリを作成します。このライブラリを使用して、たとえば、ユーザーが許可されているAPI呼び出しの数に対するユーザーの割り当てを追跡できます。</target>
        </trans-unit>
        <trans-unit id="3d29162aaec04ffdbb58bf12aa825c48d5666dd6" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s what the countdown would look like using a &lt;code&gt;for&lt;/code&gt; loop and another method we&amp;rsquo;ve not yet talked about, &lt;code&gt;rev&lt;/code&gt;, to reverse the range:</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; ループと、まだ説明していない別のメソッド &lt;code&gt;rev&lt;/code&gt; を使用して範囲を逆にするカウントダウンは次のようになります。</target>
        </trans-unit>
        <trans-unit id="d3bb7457d5469dff80002a12eb2b6537482105f8" translate="yes" xml:space="preserve">
          <source>Here's an example of a program which exemplifies the three cases outlined above:</source>
          <target state="translated">ここでは、上記の3つのケースを例示したプログラムの例を示します。</target>
        </trans-unit>
        <trans-unit id="8f4d98d4c0a8996c7a0518c8611a7d795ca5c7fb" translate="yes" xml:space="preserve">
          <source>Here's an example of a struct that has this problem:</source>
          <target state="translated">この問題がある構造体の例を示します。</target>
        </trans-unit>
        <trans-unit id="38707ff87f1d5297f1ba77c802780450fd07e571" translate="yes" xml:space="preserve">
          <source>Here's an example of how a collection might make use of &lt;code&gt;needs_drop&lt;/code&gt;:</source>
          <target state="translated">コレクションがどのように &lt;code&gt;needs_drop&lt;/code&gt; を利用するかの例です：</target>
        </trans-unit>
        <trans-unit id="6b4165c575ea75c83f4faaec0830fc7c979ed3b7" translate="yes" xml:space="preserve">
          <source>Here's an example of some in-progress code. We have a trait &lt;code&gt;Foo&lt;/code&gt;:</source>
          <target state="translated">進行中のコードの例を以下に示します。私たちは特徴 &lt;code&gt;Foo&lt;/code&gt; を持っています：</target>
        </trans-unit>
        <trans-unit id="f441ef09b0ea3aff9bb06d2bb0621baad2037ee9" translate="yes" xml:space="preserve">
          <source>Here's an example of this error:</source>
          <target state="translated">このエラーの例です。</target>
        </trans-unit>
        <trans-unit id="c9ee387ebc736d2db87034681c5da1089287c37d" translate="yes" xml:space="preserve">
          <source>Here's an example where you want to sort people by height only, disregarding &lt;code&gt;id&lt;/code&gt; and &lt;code&gt;name&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;id&lt;/code&gt; と &lt;code&gt;name&lt;/code&gt; 無視して、人を身長だけで並べ替える例を次に示します。</target>
        </trans-unit>
        <trans-unit id="51e85e4e8113fb3e1f07e1727e78d73f5f0043e6" translate="yes" xml:space="preserve">
          <source>Here's an example:</source>
          <target state="translated">一例を挙げてみます。</target>
        </trans-unit>
        <trans-unit id="4cce1c09bcbbaec9487020ee6e7f8025e34bed6b" translate="yes" xml:space="preserve">
          <source>Here's another example but here we do not try and return an expression:</source>
          <target state="translated">ここでは別の例を示しますが、ここでは式を返すようにはしていません。</target>
        </trans-unit>
        <trans-unit id="52eb68597e531c606446cb2bd5c17dccc5e369fd" translate="yes" xml:space="preserve">
          <source>Here's another example that will fail:</source>
          <target state="translated">ここにも失敗する例があります。</target>
        </trans-unit>
        <trans-unit id="cb729976f0325910542c6a857a3758115eda6f00" translate="yes" xml:space="preserve">
          <source>Here's one example of this error:</source>
          <target state="translated">このエラーの一例をご紹介します。</target>
        </trans-unit>
        <trans-unit id="4919036b58ea25eeee47e5a5bbcefebd8f5446fd" translate="yes" xml:space="preserve">
          <source>Here's the same example, but with &lt;a href=&quot;#method.filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">これは同じ例ですが、&lt;a href=&quot;#method.filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;#method.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt;を使用しています。</target>
        </trans-unit>
        <trans-unit id="f461dd8cfe66dce3c71bb1a0db34025a57dc2b4e" translate="yes" xml:space="preserve">
          <source>Here's the same example, but with &lt;a href=&quot;trait.iterator#method.filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.iterator#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">これは同じ例ですが、&lt;a href=&quot;trait.iterator#method.filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;trait.iterator#method.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt;を使用しています。</target>
        </trans-unit>
        <trans-unit id="b538038816d2b9d80e3095023dd492b1ae3c134a" translate="yes" xml:space="preserve">
          <source>Here's the same example, but with &lt;a href=&quot;trait.iterator#method.take_while&quot;&gt;&lt;code&gt;take_while&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.iterator#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">これは同じ例ですが、&lt;a href=&quot;trait.iterator#method.take_while&quot;&gt; &lt;code&gt;take_while&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;trait.iterator#method.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt;を使用しています：</target>
        </trans-unit>
        <trans-unit id="3adc3a6ab8335913c0c03d10dd56aa70986ccdbc" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;&amp;amp;mut fancy&lt;/code&gt; is mutable, but &lt;code&gt;&amp;amp;(&amp;amp;mut fancy)&lt;/code&gt; is not. Creating an immutable reference to a value borrows it immutably. There can be multiple references of type &lt;code&gt;&amp;amp;(&amp;amp;mut T)&lt;/code&gt; that point to the same value, so they must be immutable to prevent multiple mutable references to the same value.</source>
          <target state="translated">ここでは、 &lt;code&gt;&amp;amp;mut fancy&lt;/code&gt; は変更可能ですが、 &lt;code&gt;&amp;amp;(&amp;amp;mut fancy)&lt;/code&gt; は変更できません。値への不変の参照を作成すると、不変に借りられます。同じ値を指すタイプ &lt;code&gt;&amp;amp;(&amp;amp;mut T)&lt;/code&gt; の複数の参照が存在する可能性があるため、同じ値への複数の変更可能な参照を防ぐために、それらは不変でなければなりません。</target>
        </trans-unit>
        <trans-unit id="ae9903eacaebe1bfadd3100f5d35d502f8c50279" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;Grams2&lt;/code&gt; is a not equivalent to &lt;code&gt;Grams&lt;/code&gt; -- the former transparently wraps a (non-transparent) struct containing a single float, while &lt;code&gt;Grams&lt;/code&gt; is a transparent wrapper around a float. This can make a difference for the ABI.</source>
          <target state="translated">ここで、 &lt;code&gt;Grams2&lt;/code&gt; は &lt;code&gt;Grams&lt;/code&gt; と同等ではありません。前者は単一のフロートを含む（非透明）構造体を透過的にラップしますが、 &lt;code&gt;Grams&lt;/code&gt; はフロートの周りの透明なラッパーです。これは、ABIに影響を与える可能性があります。</target>
        </trans-unit>
        <trans-unit id="dc33c2bfb4ee352bfa1ddf50a16705d99896734f" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;demo&lt;/code&gt; tries to borrow the string data held within its argument &lt;code&gt;s&lt;/code&gt; and then return that borrow. However, &lt;code&gt;S&lt;/code&gt; is declared as implementing &lt;code&gt;Drop&lt;/code&gt;.</source>
          <target state="translated">ここで、 &lt;code&gt;demo&lt;/code&gt; は引数 &lt;code&gt;s&lt;/code&gt; 内に保持されている文字列データを借用し、その借用を返そうとします。ただし、 &lt;code&gt;S&lt;/code&gt; は &lt;code&gt;Drop&lt;/code&gt; の実装として宣言されています。</target>
        </trans-unit>
        <trans-unit id="d42c53fe9a57832c14dca225308392012e6122d1" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;fancy_num&lt;/code&gt; is borrowed by &lt;code&gt;fancy_ref&lt;/code&gt; and so cannot be moved into the closure &lt;code&gt;x&lt;/code&gt;. There is no way to move a value into a closure while it is borrowed, as that would invalidate the borrow.</source>
          <target state="translated">ここで、 &lt;code&gt;fancy_num&lt;/code&gt; はによって借用さ &lt;code&gt;fancy_ref&lt;/code&gt; ので、クロージャ内に移動することができない &lt;code&gt;x&lt;/code&gt; 。借用が無効になるため、借用中に値をクロージャに移動する方法はありません。</target>
        </trans-unit>
        <trans-unit id="125b181d950db988334868421de4a90fab534474" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;first&lt;/code&gt; has type &lt;code&gt;A&lt;/code&gt;, referring to &lt;code&gt;to_vec&lt;/code&gt;'s &lt;code&gt;A&lt;/code&gt; type parameter; and &lt;code&gt;rest&lt;/code&gt; has type &lt;code&gt;Vec&amp;lt;A&amp;gt;&lt;/code&gt;, a vector with element type &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">ここでは、 &lt;code&gt;first&lt;/code&gt; に型 &lt;code&gt;A&lt;/code&gt; があり、 &lt;code&gt;to_vec&lt;/code&gt; の &lt;code&gt;A&lt;/code&gt; 型パラメーターを参照しています。そして &lt;code&gt;rest&lt;/code&gt; 入力した &lt;code&gt;Vec&amp;lt;A&amp;gt;&lt;/code&gt; 、要素型とベクトル &lt;code&gt;A&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="843f8d3cb9b3a29d042bd0b638e62192879181c8" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;i32&lt;/code&gt; is the type of each element. After the semicolon, the number &lt;code&gt;5&lt;/code&gt; indicates the array contains five elements.</source>
          <target state="translated">ここで、 &lt;code&gt;i32&lt;/code&gt; は各要素のタイプです。セミコロンの後の数字 &lt;code&gt;5&lt;/code&gt; は、配列に5つの要素が含まれていることを示します。</target>
        </trans-unit>
        <trans-unit id="df5a4c41f4c7ffd30b5c670cb408c350a9013b94" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;i32&lt;/code&gt; is the type of each element. After the semicolon, the number &lt;code&gt;5&lt;/code&gt; indicates the element contains five items.</source>
          <target state="translated">ここで、 &lt;code&gt;i32&lt;/code&gt; は各要素のタイプです。セミコロンの後の &lt;code&gt;5&lt;/code&gt; は、要素に5つのアイテムが含まれていることを示します。</target>
        </trans-unit>
        <trans-unit id="1068c0619a68aa52935f67e1c63f9f6ef1422570" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;s&lt;/code&gt; will be a &lt;code&gt;&amp;amp;str&lt;/code&gt; that contains the first 4 bytes of the string. Earlier, we mentioned that each of these characters was 2 bytes, which means &lt;code&gt;s&lt;/code&gt; will be &lt;code&gt;Зд&lt;/code&gt;.</source>
          <target state="translated">ここで、 &lt;code&gt;s&lt;/code&gt; は &lt;code&gt;&amp;amp;str&lt;/code&gt; の最初の4バイトを含む＆strになります。以前、これらの文字はそれぞれ2バイトであることを述べ &lt;code&gt;Зд&lt;/code&gt; 。つまり、 &lt;code&gt;s&lt;/code&gt; はЗдになります。</target>
        </trans-unit>
        <trans-unit id="75b866d15247e93817fc99798a57f0ab2950be56" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;score&lt;/code&gt; will have the value that&amp;rsquo;s associated with the Blue team, and the result will be &lt;code&gt;Some(&amp;amp;10)&lt;/code&gt;. The result is wrapped in &lt;code&gt;Some&lt;/code&gt; because &lt;code&gt;get&lt;/code&gt; returns an &lt;code&gt;Option&amp;lt;&amp;amp;V&amp;gt;&lt;/code&gt;; if there&amp;rsquo;s no value for that key in the hash map, &lt;code&gt;get&lt;/code&gt; will return &lt;code&gt;None&lt;/code&gt;. The program will need to handle the &lt;code&gt;Option&lt;/code&gt; in one of the ways that we covered in Chapter 6.</source>
          <target state="translated">ここで、 &lt;code&gt;score&lt;/code&gt; はBlueチームに関連付けられた値を持ち、結果は &lt;code&gt;Some(&amp;amp;10)&lt;/code&gt; になります。 &lt;code&gt;get&lt;/code&gt; は &lt;code&gt;Option&amp;lt;&amp;amp;V&amp;gt;&lt;/code&gt; 返すため、結果は &lt;code&gt;Some&lt;/code&gt; にラップされます。ハッシュマップにそのキーの値がない場合、 &lt;code&gt;get&lt;/code&gt; は &lt;code&gt;None&lt;/code&gt; を返します。プログラムは、第6章で説明した方法の1つで &lt;code&gt;Option&lt;/code&gt; を処理する必要があります。</target>
        </trans-unit>
        <trans-unit id="8bd05f4a31a90f3b6414a315addec81f40aa24ad" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;x&lt;/code&gt; has the lifetime &lt;code&gt;'b&lt;/code&gt;, which in this case is larger than &lt;code&gt;'a&lt;/code&gt;. This means &lt;code&gt;r&lt;/code&gt; can reference &lt;code&gt;x&lt;/code&gt; because Rust knows that the reference in &lt;code&gt;r&lt;/code&gt; will always be valid while &lt;code&gt;x&lt;/code&gt; is valid.</source>
          <target state="translated">ここで、 &lt;code&gt;x&lt;/code&gt; は寿命有する &lt;code&gt;'b&lt;/code&gt; この場合、より大きく、 &lt;code&gt;'a&lt;/code&gt; 。これは、 &lt;code&gt;x&lt;/code&gt; が有効な間、rustは &lt;code&gt;r&lt;/code&gt; の参照が常に有効であることを認識しているため、 &lt;code&gt;r&lt;/code&gt; は &lt;code&gt;x&lt;/code&gt; を参照できることを意味します。</target>
        </trans-unit>
        <trans-unit id="e10c369ea788e27a00713fc168a85308c89bf1c9" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;y&lt;/code&gt; is bound by-value in one case and by-reference in the other.</source>
          <target state="translated">ここで、 &lt;code&gt;y&lt;/code&gt; は1つのケースでは値によってバインドされ、もう1つのケースでは参照によってバインドされます。</target>
        </trans-unit>
        <trans-unit id="7d5607669abd7c37655a986b9a8d2fca66769741" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;y&lt;/code&gt; is bound to the contents of the &lt;code&gt;Some&lt;/code&gt; and can be used within the block corresponding to the match arm. However, in case &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, we have not specified what &lt;code&gt;y&lt;/code&gt; is, and the block will use a nonexistent variable.</source>
          <target state="translated">ここで、 &lt;code&gt;y&lt;/code&gt; は &lt;code&gt;Some&lt;/code&gt; のコンテンツにバインドされ、マッチアームに対応するブロック内で使用できます。ただし、 &lt;code&gt;x&lt;/code&gt; が &lt;code&gt;None&lt;/code&gt; の場合、 &lt;code&gt;y&lt;/code&gt; が何であるかを指定していないため、ブロックは存在しない変数を使用します。</target>
        </trans-unit>
        <trans-unit id="a792c6d2920136f42b2c0328d50b11b4b1f68c36" translate="yes" xml:space="preserve">
          <source>Here, all types implementing &lt;code&gt;Foo&lt;/code&gt; must have a method &lt;code&gt;foo&amp;lt;T&amp;gt;(x: T)&lt;/code&gt; which can take any type &lt;code&gt;T&lt;/code&gt;. However, in the &lt;code&gt;impl&lt;/code&gt; for &lt;code&gt;bool&lt;/code&gt;, we have added an extra bound that &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Copy&lt;/code&gt;, which isn't compatible with the original trait.</source>
          <target state="translated">ここで、 &lt;code&gt;Foo&lt;/code&gt; を実装するすべての型には、任意の型 &lt;code&gt;T&lt;/code&gt; を取ることができるメソッド &lt;code&gt;foo&amp;lt;T&amp;gt;(x: T)&lt;/code&gt; が必要です。ただし、 &lt;code&gt;bool&lt;/code&gt; の &lt;code&gt;impl&lt;/code&gt; では、 &lt;code&gt;T&lt;/code&gt; が &lt;code&gt;Copy&lt;/code&gt; であるという追加の境界が追加されています。これは、元の特性と互換性がありません。</target>
        </trans-unit>
        <trans-unit id="e86bf62ea38db4534581f774aebf9c330891b88f" translate="yes" xml:space="preserve">
          <source>Here, even though &lt;code&gt;x&lt;/code&gt; is not one of the parameters of &lt;code&gt;equal_to_x&lt;/code&gt;, the &lt;code&gt;equal_to_x&lt;/code&gt; closure is allowed to use the &lt;code&gt;x&lt;/code&gt; variable that&amp;rsquo;s defined in the same scope that &lt;code&gt;equal_to_x&lt;/code&gt; is defined in.</source>
          <target state="translated">にもかかわらずここで、 &lt;code&gt;x&lt;/code&gt; は、のパラメータの一つではありません &lt;code&gt;equal_to_x&lt;/code&gt; 、 &lt;code&gt;equal_to_x&lt;/code&gt; 閉鎖は使用を許可されている &lt;code&gt;x&lt;/code&gt; と同じスコープで定義されています変数 &lt;code&gt;equal_to_x&lt;/code&gt; がで定義されているが。</target>
        </trans-unit>
        <trans-unit id="3efa2682153806eb1dbead68e3ef30ae590912ca" translate="yes" xml:space="preserve">
          <source>Here, even though we&amp;rsquo;ve specified a lifetime parameter &lt;code&gt;'a&lt;/code&gt; for the return type, this implementation will fail to compile because the return value lifetime is not related to the lifetime of the parameters at all. Here is the error message we get:</source>
          <target state="translated">ここでは、戻り値の型に有効期間パラメーター &lt;code&gt;'a&lt;/code&gt; を指定していますが、戻り値の有効期間はパラメーターの有効期間とはまったく関係がないため、この実装はコンパイルに失敗します。表示されるエラーメッセージは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="da2b63d2db9c34aa4fad7b681faf1cae153440c5" translate="yes" xml:space="preserve">
          <source>Here, our response has a status line with status code 404 and the reason phrase &lt;code&gt;NOT FOUND&lt;/code&gt;. We&amp;rsquo;re still not returning headers, and the body of the response will be the HTML in the file &lt;em&gt;404.html&lt;/em&gt;. You&amp;rsquo;ll need to create a &lt;em&gt;404.html&lt;/em&gt; file next to &lt;em&gt;hello.html&lt;/em&gt; for the error page; again feel free to use any HTML you want or use the example HTML in Listing 20-8.</source>
          <target state="translated">ここでは、応答にステータスコード404のステータス行と理由フレーズ &lt;code&gt;NOT FOUND&lt;/code&gt; があります。ヘッダーはまだ返されず、応答の本文は&lt;em&gt;404.html&lt;/em&gt;ファイルのHTMLになります。あなたは、作成する必要があります&lt;em&gt;404.html&lt;/em&gt;次へファイルを&lt;em&gt;hello.html&lt;/em&gt;エラーページのために、ここでも、必要に応じて任意のHTMLを使用するか、リスト20-8のサンプルHTMLを使用してかまいません。</target>
        </trans-unit>
        <trans-unit id="a2749e5eb8656bede400f4e0b8d184580a4d9adf" translate="yes" xml:space="preserve">
          <source>Here, the &lt;code&gt;BitAndAssign&lt;/code&gt; trait is implemented for a wrapper around &lt;code&gt;Vec&amp;lt;bool&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">ここでは、 &lt;code&gt;BitAndAssign&lt;/code&gt; トレイトが &lt;code&gt;Vec&amp;lt;bool&amp;gt;&lt;/code&gt; ラッパーに実装されています。</target>
        </trans-unit>
        <trans-unit id="73314800534c2c9290a895f1b2e09cd5c74b13fa" translate="yes" xml:space="preserve">
          <source>Here, the &lt;code&gt;nothing_is_true&lt;/code&gt; method takes the ownership of &lt;code&gt;self&lt;/code&gt;. However, &lt;code&gt;self&lt;/code&gt; cannot be moved because &lt;code&gt;.borrow()&lt;/code&gt; only provides an &lt;code&gt;&amp;amp;TheDarkKnight&lt;/code&gt;, which is a borrow of the content owned by the &lt;code&gt;RefCell&lt;/code&gt;. To fix this error, you have three choices:</source>
          <target state="translated">ここで、 &lt;code&gt;nothing_is_true&lt;/code&gt; メソッドは &lt;code&gt;self&lt;/code&gt; の所有権を取得します。ただし、 &lt;code&gt;.borrow()&lt;/code&gt; は &lt;code&gt;RefCell&lt;/code&gt; が所有するコンテンツの借用である &lt;code&gt;&amp;amp;TheDarkKnight&lt;/code&gt; のみを提供するため、 &lt;code&gt;self&lt;/code&gt; を移動することはできません。このエラーを修正するには、3つの選択肢があります。</target>
        </trans-unit>
        <trans-unit id="9ecdeb34514236dc334d979e1fa6dac1a4f47ca1" translate="yes" xml:space="preserve">
          <source>Here, the &lt;code&gt;yield&lt;/code&gt; keyword is used in an &lt;code&gt;async&lt;/code&gt; block, which is not yet supported.</source>
          <target state="translated">ここで、 &lt;code&gt;yield&lt;/code&gt; キーワードは、まだサポートされていない &lt;code&gt;async&lt;/code&gt; ブロックで使用されます。</target>
        </trans-unit>
        <trans-unit id="a5f1ad21d4790c6fa776cb2d79a7da13085bbb0b" translate="yes" xml:space="preserve">
          <source>Here, the code counts up through the elements in the array. It starts at index &lt;code&gt;0&lt;/code&gt;, and then loops until it reaches the final index in the array (that is, when &lt;code&gt;index &amp;lt; 5&lt;/code&gt; is no longer true). Running this code will print every element in the array:</source>
          <target state="translated">ここでは、コードは配列の要素を数え上げます。インデックス &lt;code&gt;0&lt;/code&gt; から始まり、配列の最後のインデックスに達するまで（つまり、 &lt;code&gt;index &amp;lt; 5&lt;/code&gt; がtrueでなくなったとき）ループします。このコードを実行すると、配列内のすべての要素が出力されます。</target>
        </trans-unit>
        <trans-unit id="f6e9fdb531b1a1a673e70ab403c2068ef72bf3e1" translate="yes" xml:space="preserve">
          <source>Here, the expression &lt;code&gt;&amp;amp;foo()&lt;/code&gt; is borrowing the expression &lt;code&gt;foo()&lt;/code&gt;. As &lt;code&gt;foo()&lt;/code&gt; is a call to a function, and not the name of a variable, this creates a &lt;strong&gt;temporary&lt;/strong&gt; -- that temporary stores the return value from &lt;code&gt;foo()&lt;/code&gt; so that it can be borrowed. You could imagine that &lt;code&gt;let p = bar(&amp;amp;foo());&lt;/code&gt; is equivalent to this:</source>
          <target state="translated">ここでは、表現 &lt;code&gt;&amp;amp;foo()&lt;/code&gt; 表現借りれる &lt;code&gt;foo()&lt;/code&gt; 。 &lt;code&gt;foo()&lt;/code&gt; 関数の呼び出しではなく、変数の名前、これが作成され&lt;strong&gt;、一時的に&lt;/strong&gt; -から一時的に記憶が戻り値という &lt;code&gt;foo()&lt;/code&gt; それは借りすることができますように。 &lt;code&gt;let p = bar(&amp;amp;foo());&lt;/code&gt; と想像してください。これと同等です：</target>
        </trans-unit>
        <trans-unit id="408c7fbfdfe961fb58eba63dc21b905f34fe6b5c" translate="yes" xml:space="preserve">
          <source>Here, the function &lt;code&gt;eat&lt;/code&gt; takes ownership of &lt;code&gt;x&lt;/code&gt;. However, &lt;code&gt;x&lt;/code&gt; cannot be moved because the borrow to &lt;code&gt;_ref_to_val&lt;/code&gt; needs to last till the function &lt;code&gt;borrow&lt;/code&gt;. To fix that you can do a few different things:</source>
          <target state="translated">ここで、関数 &lt;code&gt;eat&lt;/code&gt; は &lt;code&gt;x&lt;/code&gt; の所有権を取得します。ただし、 &lt;code&gt;x&lt;/code&gt; はに借りているため移動できません &lt;code&gt;_ref_to_val&lt;/code&gt; ニーズが機能まで続くと &lt;code&gt;borrow&lt;/code&gt; 。これを修正するには、いくつかの異なることを実行できます。</target>
        </trans-unit>
        <trans-unit id="34b4fc7688b4cc55dbce35a5cbba7cf5aa481597" translate="yes" xml:space="preserve">
          <source>Here, the function &lt;code&gt;foo&lt;/code&gt; returns a value of type &lt;code&gt;Cell&amp;lt;&amp;amp;'x u32&amp;gt;&lt;/code&gt;, which references the lifetime &lt;code&gt;'x&lt;/code&gt;. However, the return type is declared as &lt;code&gt;impl Trait&amp;lt;'y&amp;gt;&lt;/code&gt; -- this indicates that &lt;code&gt;foo&lt;/code&gt; returns &quot;some type that implements &lt;code&gt;Trait&amp;lt;'y&amp;gt;&lt;/code&gt;&quot;, but it also indicates that the return type &lt;strong&gt;only captures data referencing the lifetime &lt;code&gt;'y&lt;/code&gt;&lt;/strong&gt;. In this case, though, we are referencing data with lifetime &lt;code&gt;'x&lt;/code&gt;, so this function is in error.</source>
          <target state="translated">ここで、関数 &lt;code&gt;foo&lt;/code&gt; はタイプ &lt;code&gt;Cell&amp;lt;&amp;amp;'x u32&amp;gt;&lt;/code&gt; 値を返します。これは、ライフタイム &lt;code&gt;'x&lt;/code&gt; を参照します。ただし、戻り値の型は &lt;code&gt;impl Trait&amp;lt;'y&amp;gt;&lt;/code&gt; として宣言されています。これは、 &lt;code&gt;foo&lt;/code&gt; が「 &lt;code&gt;Trait&amp;lt;'y&amp;gt;&lt;/code&gt; を実装するいくつかの型」を返すことを示しますが、戻り値の型&lt;strong&gt;は、有効期間 &lt;code&gt;'y&lt;/code&gt; を&lt;/strong&gt;&lt;strong&gt;参照するデータのみをキャプチャする&lt;/strong&gt;ことも示します。ただし、この場合、ライフタイム &lt;code&gt;'x&lt;/code&gt; でデータを参照しているため、この関数はエラーになります。</target>
        </trans-unit>
        <trans-unit id="89055a364d466030b4b32dbb99ee9d2965691a35" translate="yes" xml:space="preserve">
          <source>Here, the loop never ends, so &lt;code&gt;!&lt;/code&gt; is the value of the expression. However, this wouldn&amp;rsquo;t be true if we included a &lt;code&gt;break&lt;/code&gt;, because the loop would terminate when it got to the &lt;code&gt;break&lt;/code&gt;.</source>
          <target state="translated">ここでは、ループが終了しないので、 &lt;code&gt;!&lt;/code&gt; 式の値です。私たちが含まれている場合しかし、これは真実ではないでしょう &lt;code&gt;break&lt;/code&gt; それに着いたとき、ループが終了してしまうため、 &lt;code&gt;break&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="df47ee6ed5cabbf7215bb10c59a544458415fee2" translate="yes" xml:space="preserve">
          <source>Here, the problem is that a reference type like &lt;code&gt;&amp;amp;'a T&lt;/code&gt; is only valid if all the data in T outlives the lifetime &lt;code&gt;'a&lt;/code&gt;. But this impl as written is applicable to any lifetime &lt;code&gt;'a&lt;/code&gt; and any type &lt;code&gt;T&lt;/code&gt; -- we have no guarantee that &lt;code&gt;T&lt;/code&gt; outlives &lt;code&gt;'a&lt;/code&gt;. To fix this, you can add a where clause like &lt;code&gt;where T: 'a&lt;/code&gt;.</source>
          <target state="translated">ここでの問題は、 &lt;code&gt;&amp;amp;'a T&lt;/code&gt; ような参照型は、Tのすべてのデータがライフタイム &lt;code&gt;'a&lt;/code&gt; 超えた場合にのみ有効であることです。しかし、書かれた通り、このIMPLが任意の寿命に適用可能であり &lt;code&gt;'a&lt;/code&gt; と任意の型 &lt;code&gt;T&lt;/code&gt; -私たちは、という保証がない &lt;code&gt;T&lt;/code&gt; が outlives &lt;code&gt;'a&lt;/code&gt; 。これを修正するには、 &lt;code&gt;where T: 'a&lt;/code&gt; ようなwhere句を追加します。</target>
        </trans-unit>
        <trans-unit id="d0ef28f4a5284b6e2516b2e042ed2f018d33a029" translate="yes" xml:space="preserve">
          <source>Here, the problem is that the compiler cannot be sure that the &lt;code&gt;'b&lt;/code&gt; lifetime will live longer than &lt;code&gt;'a&lt;/code&gt;, which should be mandatory in order to be sure that &lt;code&gt;Trait::Out&lt;/code&gt; will always have a reference pointing to an existing type. So in this case, we just need to tell the compiler than &lt;code&gt;'b&lt;/code&gt; must outlive &lt;code&gt;'a&lt;/code&gt;:</source>
          <target state="translated">ここで、問題は、コンパイラがいることを確認することはできませんということである &lt;code&gt;'b&lt;/code&gt; 寿命がより長く生きる &lt;code&gt;'a&lt;/code&gt; ことを確認しにするために必須であるべき、 &lt;code&gt;Trait::Out&lt;/code&gt; 常に既存の型を指す参照を持つことになります。したがって、この場合、コンパイラに &lt;code&gt;'b&lt;/code&gt; は長生き &lt;code&gt;'a&lt;/code&gt; 必要がある」と伝える必要があります。</target>
        </trans-unit>
        <trans-unit id="362d656c8582920eb1fa6e2f837dcd77621e2783" translate="yes" xml:space="preserve">
          <source>Here, the supertrait might have methods as follows:</source>
          <target state="translated">ここでは、超像には次のような方法があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="09d377b97ceff52f388bef9d69ecd4e08de82e8e" translate="yes" xml:space="preserve">
          <source>Here, the type of &lt;code&gt;bar&lt;/code&gt; isn't known; it could be a pointer to anything. Instead, specify a type for the pointer (preferably something that makes sense for the thing you're pointing to):</source>
          <target state="translated">ここでは、 &lt;code&gt;bar&lt;/code&gt; の種類は不明です。それは何かへのポインタになる可能性があります。代わりに、ポインターのタイプを指定します（できれば、ポイントしているものに対して意味のあるものを推奨します）。</target>
        </trans-unit>
        <trans-unit id="6683d46fded95c67df0b49024b3446d80dd204a6" translate="yes" xml:space="preserve">
          <source>Here, the where clause &lt;code&gt;T: 'a&lt;/code&gt; that appears on the impl is not known to be satisfied on the struct. To make this example compile, you have to add a where-clause like &lt;code&gt;T: 'a&lt;/code&gt; to the struct definition:</source>
          <target state="translated">ここで、where句 &lt;code&gt;T: 'a&lt;/code&gt; implに表示されるaが構造体で満たされているかどうかは不明です。この例をコンパイルするには、 &lt;code&gt;T: 'a&lt;/code&gt; ようなwhere節を構造体定義に追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="5f5bdb12ef17925552b810b20339fc4188e58923" translate="yes" xml:space="preserve">
          <source>Here, there's no need to allocate more memory inside the loop.</source>
          <target state="translated">ここでは、ループ内でより多くのメモリを割り当てる必要はありません。</target>
        </trans-unit>
        <trans-unit id="64f50e4beb0199dca819447bd86bfb2e950cfebb" translate="yes" xml:space="preserve">
          <source>Here, transmute is being used to convert the types of the fn arguments. This pattern is incorrect because, because the type of &lt;code&gt;foo&lt;/code&gt; is a function &lt;strong&gt;item&lt;/strong&gt; (&lt;code&gt;typeof(foo)&lt;/code&gt;), which is zero-sized, and the target type (&lt;code&gt;fn()&lt;/code&gt;) is a function pointer, which is not zero-sized. This pattern should be rewritten. There are a few possible ways to do this:</source>
          <target state="translated">ここでは、transmuteを使用してfn引数の型を変換しています。 &lt;code&gt;foo&lt;/code&gt; の型はサイズがゼロの関数&lt;strong&gt;項目&lt;/strong&gt;（ &lt;code&gt;typeof(foo)&lt;/code&gt; ）であり、ターゲットの型（ &lt;code&gt;fn()&lt;/code&gt; ）はサイズがゼロではない関数ポインターであるため、このパターンは正しくありません。このパターンは書き換える必要があります。これを行うにはいくつかの可能な方法があります。</target>
        </trans-unit>
        <trans-unit id="11f7e7a9427d5e270e6bb9180be033e23a1b7abb" translate="yes" xml:space="preserve">
          <source>Here, we are still borrowing &lt;code&gt;foo()&lt;/code&gt;, but as the borrow is assigned directly into a variable, the temporary will not be dropped until the end of the enclosing block. Similar rules apply when temporaries are stored into aggregate structures like a tuple or struct:</source>
          <target state="translated">ここでは、まだ &lt;code&gt;foo()&lt;/code&gt; を借用していますが、借用は変数に直接割り当てられるため、一時ブロックは囲んでいるブロックの終わりまで削除されません。一時がタプルや構造体などの集計構造に格納される場合も、同様のルールが適用されます。</target>
        </trans-unit>
        <trans-unit id="2fe93444419186b520c70f702a92a3495d890ab8" translate="yes" xml:space="preserve">
          <source>Here, we create a new variable &lt;code&gt;case_sensitive&lt;/code&gt;. To set its value, we call the &lt;code&gt;env::var&lt;/code&gt; function and pass it the name of the &lt;code&gt;CASE_INSENSITIVE&lt;/code&gt; environment variable. The &lt;code&gt;env::var&lt;/code&gt; function returns a &lt;code&gt;Result&lt;/code&gt; that will be the successful &lt;code&gt;Ok&lt;/code&gt; variant that contains the value of the environment variable if the environment variable is set. It will return the &lt;code&gt;Err&lt;/code&gt; variant if the environment variable is not set.</source>
          <target state="translated">ここでは、新しい変数 &lt;code&gt;case_sensitive&lt;/code&gt; を作成します。その値を設定するには、 &lt;code&gt;env::var&lt;/code&gt; 関数を呼び出して、 &lt;code&gt;CASE_INSENSITIVE&lt;/code&gt; 環境変数の名前を渡します。 &lt;code&gt;env::var&lt;/code&gt; 関数は返す &lt;code&gt;Result&lt;/code&gt; 成功する &lt;code&gt;Ok&lt;/code&gt; 、環境変数が設定されている場合、環境変数の値を含むバリアントを。環境変数が設定されていない場合は、 &lt;code&gt;Err&lt;/code&gt; バリアントが返されます。</target>
        </trans-unit>
        <trans-unit id="629de8d4fd404424f68755750d18203229995313" translate="yes" xml:space="preserve">
          <source>Here, we declare a trait using the &lt;code&gt;trait&lt;/code&gt; keyword and then the trait&amp;rsquo;s name, which is &lt;code&gt;Summary&lt;/code&gt; in this case. Inside the curly brackets, we declare the method signatures that describe the behaviors of the types that implement this trait, which in this case is &lt;code&gt;fn summarize(&amp;amp;self) -&amp;gt; String&lt;/code&gt;.</source>
          <target state="translated">ここでは、 &lt;code&gt;trait&lt;/code&gt; キーワードを使用して特性を宣言してから、特性の名前（この場合は &lt;code&gt;Summary&lt;/code&gt; ）を宣言しています。中括弧の内側で、この特性を実装する型の動作を記述するメソッドシグネチャを宣言します。この場合は、 &lt;code&gt;fn summarize(&amp;amp;self) -&amp;gt; String&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="d5d31c7a816695d5663a1af214bdd61a0f312631" translate="yes" xml:space="preserve">
          <source>Here, we first call &lt;code&gt;lock&lt;/code&gt; on the &lt;code&gt;receiver&lt;/code&gt; to acquire the mutex, and then we call &lt;code&gt;unwrap&lt;/code&gt; to panic on any errors. Acquiring a lock might fail if the mutex is in a &lt;em&gt;poisoned&lt;/em&gt; state, which can happen if some other thread panicked while holding the lock rather than releasing the lock. In this situation, calling &lt;code&gt;unwrap&lt;/code&gt; to have this thread panic is the correct action to take. Feel free to change this &lt;code&gt;unwrap&lt;/code&gt; to an &lt;code&gt;expect&lt;/code&gt; with an error message that is meaningful to you.</source>
          <target state="translated">ここでは、最初に &lt;code&gt;receiver&lt;/code&gt; &lt;code&gt;lock&lt;/code&gt; を呼び出してミューテックスを取得し、次に &lt;code&gt;unwrap&lt;/code&gt; を呼び出してエラーが発生した場合にパニックを起こします。 mutexが&lt;em&gt;ポイズニング&lt;/em&gt;状態にある場合、ロックの取得は失敗する可能性があります。これは、ロックを解放するのではなく、ロックを保持しているときに他のスレッドがパニックした場合に発生する可能性があります。この状況では、 &lt;code&gt;unwrap&lt;/code&gt; を呼び出してこのスレッドパニックを発生させるのが適切なアクションです。この &lt;code&gt;unwrap&lt;/code&gt; を、意味のあるエラーメッセージが表示される &lt;code&gt;expect&lt;/code&gt; に変更してください。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="90ed3acfd08d6add91c92898299f8f082c9b0a5d" translate="yes" xml:space="preserve">
          <source>Here, we give a description of what the &lt;code&gt;add_one&lt;/code&gt; function does, start a section with the heading &lt;code&gt;Examples&lt;/code&gt;, and then provide code that demonstrates how to use the &lt;code&gt;add_one&lt;/code&gt; function. We can generate the HTML documentation from this documentation comment by running &lt;code&gt;cargo doc&lt;/code&gt;. This command runs the &lt;code&gt;rustdoc&lt;/code&gt; tool distributed with Rust and puts the generated HTML documentation in the &lt;em&gt;target/doc&lt;/em&gt; directory.</source>
          <target state="translated">ここでは、 &lt;code&gt;add_one&lt;/code&gt; 関数の機能の説明を提供し、セクション &lt;code&gt;Examples&lt;/code&gt; でセクションを開始し、次に &lt;code&gt;add_one&lt;/code&gt; 関数の使用方法を示すコードを提供します。 &lt;code&gt;cargo doc&lt;/code&gt; 実行して、このドキュメントコメントからHTMLドキュメントを生成できます。このコマンドは、Rustと共に配布される &lt;code&gt;rustdoc&lt;/code&gt; ツールを実行し、生成されたHTMLドキュメントを&lt;em&gt;target / doc&lt;/em&gt;ディレクトリに配置します。</target>
        </trans-unit>
        <trans-unit id="509084bc1cc2854ecab3677678733d63bccc2260" translate="yes" xml:space="preserve">
          <source>Here, we have a package that only contains &lt;em&gt;src/main.rs&lt;/em&gt;, meaning it only contains a binary crate named &lt;code&gt;my-project&lt;/code&gt;. If a package contains &lt;em&gt;src/main.rs&lt;/em&gt; and &lt;em&gt;src/lib.rs&lt;/em&gt;, it has two crates: a library and a binary, both with the same name as the package. A package can have multiple binary crates by placing files in the &lt;em&gt;src/bin&lt;/em&gt; directory: each file will be a separate binary crate.</source>
          <target state="translated">ここでは、&lt;em&gt;src / main.rs&lt;/em&gt;のみを含むパッケージがあります。つまり &lt;code&gt;my-project&lt;/code&gt; という名前のバイナリクレートのみが含まれています。パッケージに&lt;em&gt;src / main.rs&lt;/em&gt;および&lt;em&gt;src / lib.rs&lt;/em&gt;が含まれている場合、パッケージにはライブラリとバイナリの2つのクレートがあり、どちらもパッケージと同じ名前です。&lt;em&gt;src / bin&lt;/em&gt;ディレクトリにファイルを配置することで、パッケージに複数のバイナリクレートを含めることができます。各ファイルは個別のバイナリクレートになります。</target>
        </trans-unit>
        <trans-unit id="214685b848acbf415bb3dbd9186c1466aa631aa7" translate="yes" xml:space="preserve">
          <source>Here, we have two parameters of type &lt;code&gt;TokenStream&lt;/code&gt;. The first is for the contents of the attribute: the &lt;code&gt;GET, &quot;/&quot;&lt;/code&gt; part. The second is the body of the item the attribute is attached to: in this case, &lt;code&gt;fn index() {}&lt;/code&gt; and the rest of the function&amp;rsquo;s body.</source>
          <target state="translated">ここでは、タイプ &lt;code&gt;TokenStream&lt;/code&gt; の 2つのパラメーターがあります。1つ目は、属性の内容（ &lt;code&gt;GET, &quot;/&quot;&lt;/code&gt; 部分）です。2番目は、属性が関連付けられているアイテムの本文です。この場合、 &lt;code&gt;fn index() {}&lt;/code&gt; と関数の残りの本文です。</target>
        </trans-unit>
        <trans-unit id="9da25d2edfbc8a834054d09a3a531a79272bf467" translate="yes" xml:space="preserve">
          <source>Here, we match a tuple against a pattern. Rust compares the value &lt;code&gt;(1, 2, 3)&lt;/code&gt; to the pattern &lt;code&gt;(x, y, z)&lt;/code&gt; and sees that the value matches the pattern, so Rust binds &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt; to &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;3&lt;/code&gt; to &lt;code&gt;z&lt;/code&gt;. You can think of this tuple pattern as nesting three individual variable patterns inside it.</source>
          <target state="translated">ここでは、タプルをパターンと照合します。Rustは値 &lt;code&gt;(1, 2, 3)&lt;/code&gt; をパターン &lt;code&gt;(x, y, z)&lt;/code&gt; と比較し、値がパターンと一致することを確認します。したがって、Rustは &lt;code&gt;1&lt;/code&gt; を &lt;code&gt;x&lt;/code&gt; に、 &lt;code&gt;2&lt;/code&gt; を &lt;code&gt;y&lt;/code&gt; に、 &lt;code&gt;3&lt;/code&gt; を &lt;code&gt;z&lt;/code&gt; にバインドします。このタプルパターンは、3つの個別の可変パターンをその中にネストすると考えることができます。</target>
        </trans-unit>
        <trans-unit id="3807aec2b6a72b122da57a852fc8dc8b9b746c8b" translate="yes" xml:space="preserve">
          <source>Here, we tried to move a field out of a struct of type &lt;code&gt;DropStruct&lt;/code&gt; which implements the &lt;code&gt;Drop&lt;/code&gt; trait. However, a struct cannot be dropped if one or more of its fields have been moved.</source>
          <target state="translated">ここでは、 &lt;code&gt;Drop&lt;/code&gt; トレイトを実装する &lt;code&gt;DropStruct&lt;/code&gt; 型の構造体からフィールドを移動しようとしました。ただし、1つ以上のフィールドが移動されている場合、構造体は削除できません。</target>
        </trans-unit>
        <trans-unit id="182fd49127f0c327471148134a76b7aecc6837c0" translate="yes" xml:space="preserve">
          <source>Here, we try to print &lt;code&gt;val&lt;/code&gt; after we&amp;rsquo;ve sent it down the channel via &lt;code&gt;tx.send&lt;/code&gt;. Allowing this would be a bad idea: once the value has been sent to another thread, that thread could modify or drop it before we try to use the value again. Potentially, the other thread&amp;rsquo;s modifications could cause errors or unexpected results due to inconsistent or nonexistent data. However, Rust gives us an error if we try to compile the code in Listing 16-9:</source>
          <target state="translated">ここでは、 &lt;code&gt;val&lt;/code&gt; を &lt;code&gt;tx.send&lt;/code&gt; を介してチャネルに送信した後で、valを出力しようとします。これを許可するのは悪い考えです。値が別のスレッドに送信されると、そのスレッドは値を再度使用する前に変更または削除する可能性があります。潜在的に、他のスレッドの変更は、データの不整合または存在しないためにエラーまたは予期しない結果を引き起こす可能性があります。ただし、リスト16-9のコードをコンパイルしようとすると、Rustからエラーが返されます。</target>
        </trans-unit>
        <trans-unit id="e6e942400049c5831b3b39dbc83c98fc061c7f27" translate="yes" xml:space="preserve">
          <source>Here, we&amp;rsquo;ll work up to a program that has one thread to generate values and send them down a channel, and another thread that will receive the values and print them out. We&amp;rsquo;ll be sending simple values between threads using a channel to illustrate the feature. Once you&amp;rsquo;re familiar with the technique, you could use channels to implement a chat system or a system where many threads perform parts of a calculation and send the parts to one thread that aggregates the results.</source>
          <target state="translated">ここでは、値を生成してチャネルに送信する1つのスレッドと、値を受信して​​出力する別のスレッドを持つプログラムを作成します。機能を説明するチャネルを使用して、スレッド間で単純な値を送信します。この手法に慣れたら、チャネルを使用して、チャットシステムまたは多くのスレッドが計算の一部を実行するシステムを実装し、その一部を結果を集約する1つのスレッドに送信できます。</target>
        </trans-unit>
        <trans-unit id="2b30624caca04c6adde1f0c4c5c0896dda9444b6" translate="yes" xml:space="preserve">
          <source>Here, we&amp;rsquo;re attempting to access the 100th element of our vector (which is at index 99 because indexing starts at zero), but it has only 3 elements. In this situation, Rust will panic. Using &lt;code&gt;[]&lt;/code&gt; is supposed to return an element, but if you pass an invalid index, there&amp;rsquo;s no element that Rust could return here that would be correct.</source>
          <target state="translated">ここでは、ベクターの100番目の要素（インデックス付けはゼロから始まるため、インデックス99）にアクセスしようとしていますが、要素は3つしかありません。この状況では、Rustはパニックになります。 &lt;code&gt;[]&lt;/code&gt; を使用すると要素が返されることが想定されていますが、無効なインデックスを渡した場合、Rustがここで返すことができる正しい要素はありません。</target>
        </trans-unit>
        <trans-unit id="5696f367dcde9c29280ed019893b8b93043b4ae3" translate="yes" xml:space="preserve">
          <source>Here, we&amp;rsquo;re calling the &lt;code&gt;do_something&lt;/code&gt; function 100 times, but we never use the variable &lt;code&gt;i&lt;/code&gt; in the body of the &lt;code&gt;for&lt;/code&gt; loop. Rust warns us about that:</source>
          <target state="translated">ここでは、 &lt;code&gt;do_something&lt;/code&gt; 関数を100回呼び出していますが、 &lt;code&gt;for&lt;/code&gt; ループの本体で変数 &lt;code&gt;i&lt;/code&gt; を使用することはありません。錆はそれについて私たちに警告します：</target>
        </trans-unit>
        <trans-unit id="0738694c0b9e33967ee0ed11850ca18af144e2e8" translate="yes" xml:space="preserve">
          <source>Here, we&amp;rsquo;re creating a new instance of the &lt;code&gt;User&lt;/code&gt; struct, which has a field named &lt;code&gt;email&lt;/code&gt;. We want to set the &lt;code&gt;email&lt;/code&gt; field&amp;rsquo;s value to the value in the &lt;code&gt;email&lt;/code&gt; parameter of the &lt;code&gt;build_user&lt;/code&gt; function. Because the &lt;code&gt;email&lt;/code&gt; field and the &lt;code&gt;email&lt;/code&gt; parameter have the same name, we only need to write &lt;code&gt;email&lt;/code&gt; rather than &lt;code&gt;email: email&lt;/code&gt;.</source>
          <target state="translated">ここでは、 &lt;code&gt;email&lt;/code&gt; という名前のフィールドを持つ &lt;code&gt;User&lt;/code&gt; 構造体の新しいインスタンスを作成しています。 &lt;code&gt;email&lt;/code&gt; フィールドの値を、 &lt;code&gt;build_user&lt;/code&gt; 関数の &lt;code&gt;email&lt;/code&gt; パラメータの値に設定したいとします。ので &lt;code&gt;email&lt;/code&gt; フィールドと &lt;code&gt;email&lt;/code&gt; パラメータが同じ名前を持って、我々は唯一の書き込みに必要な &lt;code&gt;email&lt;/code&gt; ではなく、 &lt;code&gt;email: email&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e2e907cc8b08cfb8b71a6716a55c4e7e4751a1f7" translate="yes" xml:space="preserve">
          <source>Here, we&amp;rsquo;ve annotated the lifetime of &lt;code&gt;r&lt;/code&gt; with &lt;code&gt;'a&lt;/code&gt; and the lifetime of &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;'b&lt;/code&gt;. As you can see, the inner &lt;code&gt;'b&lt;/code&gt; block is much smaller than the outer &lt;code&gt;'a&lt;/code&gt; lifetime block. At compile time, Rust compares the size of the two lifetimes and sees that &lt;code&gt;r&lt;/code&gt; has a lifetime of &lt;code&gt;'a&lt;/code&gt; but that it refers to memory with a lifetime of &lt;code&gt;'b&lt;/code&gt;. The program is rejected because &lt;code&gt;'b&lt;/code&gt; is shorter than &lt;code&gt;'a&lt;/code&gt;: the subject of the reference doesn&amp;rsquo;t live as long as the reference.</source>
          <target state="translated">ここで、我々は生涯の注釈付きまし &lt;code&gt;r&lt;/code&gt; して &lt;code&gt;'a&lt;/code&gt; との寿命 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;'b&lt;/code&gt; 。ご覧のとおり、内側の &lt;code&gt;'b&lt;/code&gt; ブロックは外側の &lt;code&gt;'a&lt;/code&gt; 寿命ブロックよりもはるかに小さくなっています。コンパイル時に、Rustは2つの有効期間のサイズを比較し、 &lt;code&gt;r&lt;/code&gt; の有効期間が &lt;code&gt;'a&lt;/code&gt; であるが、有効期間が &lt;code&gt;'b&lt;/code&gt; メモリを参照していることを確認します。ため、プログラムは拒否される &lt;code&gt;'b&lt;/code&gt; より短い &lt;code&gt;'a&lt;/code&gt; ：参照の対象を基準としていないライブ限りません。</target>
        </trans-unit>
        <trans-unit id="1d072835ae81d38506d756c212f27d937b407880" translate="yes" xml:space="preserve">
          <source>Here, we&amp;rsquo;ve defined a method named &lt;code&gt;x&lt;/code&gt; on &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; that returns a reference to the data in the field &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">ここでは、 &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; &lt;code&gt;x&lt;/code&gt; という名前のメソッドを定義し、フィールド &lt;code&gt;x&lt;/code&gt; のデータへの参照を返します。</target>
        </trans-unit>
        <trans-unit id="b22056ea03c2bfc7c7131245d47003a6d2f7232e" translate="yes" xml:space="preserve">
          <source>Here, we&amp;rsquo;ve defined a struct &lt;code&gt;IpAddr&lt;/code&gt; that has two fields: a &lt;code&gt;kind&lt;/code&gt; field that is of type &lt;code&gt;IpAddrKind&lt;/code&gt; (the enum we defined previously) and an &lt;code&gt;address&lt;/code&gt; field of type &lt;code&gt;String&lt;/code&gt;. We have two instances of this struct. The first, &lt;code&gt;home&lt;/code&gt;, has the value &lt;code&gt;IpAddrKind::V4&lt;/code&gt; as its &lt;code&gt;kind&lt;/code&gt; with associated address data of &lt;code&gt;127.0.0.1&lt;/code&gt;. The second instance, &lt;code&gt;loopback&lt;/code&gt;, has the other variant of &lt;code&gt;IpAddrKind&lt;/code&gt; as its &lt;code&gt;kind&lt;/code&gt; value, &lt;code&gt;V6&lt;/code&gt;, and has address &lt;code&gt;::1&lt;/code&gt; associated with it. We&amp;rsquo;ve used a struct to bundle the &lt;code&gt;kind&lt;/code&gt; and &lt;code&gt;address&lt;/code&gt; values together, so now the variant is associated with the value.</source>
          <target state="translated">ここでは、構造体の定義した &lt;code&gt;IpAddr&lt;/code&gt; の 2つのフィールドを持っている &lt;code&gt;kind&lt;/code&gt; のタイプであるフィールド &lt;code&gt;IpAddrKind&lt;/code&gt; （私たちは前に定義された列挙型）と &lt;code&gt;address&lt;/code&gt; タイプのフィールド &lt;code&gt;String&lt;/code&gt; 。この構造体には2つのインスタンスがあります。最初の &lt;code&gt;home&lt;/code&gt; は、 &lt;code&gt;kind&lt;/code&gt; が &lt;code&gt;IpAddrKind::V4&lt;/code&gt; で、アドレスデータが &lt;code&gt;127.0.0.1&lt;/code&gt; に関連付けられています。 2番目のインスタンス &lt;code&gt;loopback&lt;/code&gt; には、 &lt;code&gt;kind&lt;/code&gt; 値 &lt;code&gt;V6&lt;/code&gt; として &lt;code&gt;IpAddrKind&lt;/code&gt; の他のバリアントがあり、アドレス &lt;code&gt;::1&lt;/code&gt; が関連付けられています。構造体を使用して &lt;code&gt;kind&lt;/code&gt; と値を一緒に &lt;code&gt;address&lt;/code&gt; するため、バリアントは値に関連付けられます。</target>
        </trans-unit>
        <trans-unit id="046091a3f10b4e94cc5b7d93ba3518dfd24f4c0f" translate="yes" xml:space="preserve">
          <source>Here, we're saying that the implementation exists on Wrapper only when the wrapped type &lt;code&gt;T&lt;/code&gt; implements &lt;code&gt;Clone&lt;/code&gt;. The &lt;code&gt;where&lt;/code&gt; clause is important because some types will not implement &lt;code&gt;Clone&lt;/code&gt;, and thus will not get this method.</source>
          <target state="translated">ここでは、ラップされた型 &lt;code&gt;T&lt;/code&gt; が &lt;code&gt;Clone&lt;/code&gt; を実装する場合にのみ、実装がWrapperに存在すると言っています。 &lt;code&gt;where&lt;/code&gt; いくつかの種類が実装されていますので、節が重要である &lt;code&gt;Clone&lt;/code&gt; 、したがって、この方法を取得することはありません。</target>
        </trans-unit>
        <trans-unit id="84c52d06e43bddd068876e6b5771442213f18d2a" translate="yes" xml:space="preserve">
          <source>Here, you have used the inappropriate lifetime in the &lt;code&gt;impl Trait&lt;/code&gt;, The &lt;code&gt;impl Trait&lt;/code&gt; can only capture lifetimes bound at the fn or impl level.</source>
          <target state="translated">あなたが不適切な生涯を使用していたここで、 &lt;code&gt;impl Trait&lt;/code&gt; 、 &lt;code&gt;impl Trait&lt;/code&gt; FNのみまたはIMPLレベルでバインド寿命をキャプチャすることができます。</target>
        </trans-unit>
        <trans-unit id="2eb18b6c522d039c3c0dcd7089256c0ad6492059" translate="yes" xml:space="preserve">
          <source>Hex</source>
          <target state="translated">Hex</target>
        </trans-unit>
        <trans-unit id="91ed5d7ea6cd895e371f61ed45ccc686b068fc10" translate="yes" xml:space="preserve">
          <source>Hex integer</source>
          <target state="translated">六進整数</target>
        </trans-unit>
        <trans-unit id="df212c2ac8dde3b394685d24542d906c68321356" translate="yes" xml:space="preserve">
          <source>Higher-level synchronization objects</source>
          <target state="translated">高次レベルの同期オブジェクト</target>
        </trans-unit>
        <trans-unit id="7319d8cc88397a63e7ae82683fed6023e2ba482c" translate="yes" xml:space="preserve">
          <source>Higher-ranked lifetime bounds</source>
          <target state="translated">高ランクの生涯境界線</target>
        </trans-unit>
        <trans-unit id="699f2601254a23df8fa1d5fed485a0da27f47873" translate="yes" xml:space="preserve">
          <source>Higher-ranked lifetimes may also be specified just before the trait, the only difference is the scope of the lifetime parameter, which extends only to the end of the following trait instead of the whole bound. This function is equivalent to the last one.</source>
          <target state="translated">より高いランクのライフタイムを形質の直前に指定することもできますが,唯一の違いは,ライフタイムパラメータの範囲が,全境界ではなく次の形質の最後までしか拡張されないことです.この関数は,最後の関数と同等です.</target>
        </trans-unit>
        <trans-unit id="33df4c2b13cbd6c2495bdbed3c2c401ea9db0b73" translate="yes" xml:space="preserve">
          <source>Higher-ranked trait bounds</source>
          <target state="translated">より高いランクの形質の境界線</target>
        </trans-unit>
        <trans-unit id="02d9e95b138a4fba666ec5899da0c73598dfb07a" translate="yes" xml:space="preserve">
          <source>Hints to compiler that affects how code should be emitted or optimized.</source>
          <target state="translated">コードをどのようにエミットしたり最適化したりするかに影響を与えるコンパイラへのヒント。</target>
        </trans-unit>
        <trans-unit id="410abe45925442482c6a1847631462e1f9e2aa9a" translate="yes" xml:space="preserve">
          <source>Hints to compiler that affects how code should be emitted or optimized. Hints may be compile time or runtime.</source>
          <target state="translated">コードがどのようにエミットされるべきか、あるいは最適化されるべきかに影響を与えるコンパイラへのヒント。ヒントはコンパイル時とランタイムのどちらでも構いません。</target>
        </trans-unit>
        <trans-unit id="8fa3a5e1e29277a4a2b8f85784650b518cec2c19" translate="yes" xml:space="preserve">
          <source>Hints to the compiler that branch condition is likely to be false. Returns the value passed to it.</source>
          <target state="translated">分岐条件が偽である可能性が高いことをコンパイラに示唆します。渡された値を返します。</target>
        </trans-unit>
        <trans-unit id="97a557b0407c848d7b5a674a63e1f75673a72a22" translate="yes" xml:space="preserve">
          <source>Hints to the compiler that branch condition is likely to be true. Returns the value passed to it.</source>
          <target state="translated">分岐条件が真である可能性が高いことをコンパイラに示唆します。渡された値を返します。</target>
        </trans-unit>
        <trans-unit id="80fd9958e4052dae4a04ec25478352520d67b4b8" translate="yes" xml:space="preserve">
          <source>Hooray! Rust 1.5 is done! However, we&amp;rsquo;ve forgotten one thing: because the six weeks have gone by, we also need a new beta of the &lt;em&gt;next&lt;/em&gt; version of Rust, 1.6. So after &lt;code&gt;stable&lt;/code&gt; branches off of &lt;code&gt;beta&lt;/code&gt;, the next version of &lt;code&gt;beta&lt;/code&gt; branches off of &lt;code&gt;nightly&lt;/code&gt; again:</source>
          <target state="translated">やったー！Rust 1.5が完成しました！ただし、1つのことを忘れてしまいました。6週間が経過したため、Rust の&lt;em&gt;次の&lt;/em&gt;バージョン1.6の新しいベータ版も必要です。だから、後の &lt;code&gt;stable&lt;/code&gt; オフの支店 &lt;code&gt;beta&lt;/code&gt; 、次のバージョンの &lt;code&gt;beta&lt;/code&gt; オフの枝 &lt;code&gt;nightly&lt;/code&gt; 再び：</target>
        </trans-unit>
        <trans-unit id="a341da978b3cbbea425da4874e79958a3be6b854" translate="yes" xml:space="preserve">
          <source>How Deref Coercion Interacts with Mutability</source>
          <target state="translated">デレフ強制と変異性の相互作用の仕組み</target>
        </trans-unit>
        <trans-unit id="d344cc5f79b7b6e913f964dbbc4e02bc173d4e92" translate="yes" xml:space="preserve">
          <source>How can I compare two different types?</source>
          <target state="translated">2種類を比較するにはどうしたらいいですか?</target>
        </trans-unit>
        <trans-unit id="b9691dd477ecb76d1a6f3d5bbee24f86998a66d9" translate="yes" xml:space="preserve">
          <source>How can I implement &lt;code&gt;Clone&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;Clone&lt;/code&gt; を実装するにはどうすればよいですか？</target>
        </trans-unit>
        <trans-unit id="a983251965c63473a1e84135e053268152b20692" translate="yes" xml:space="preserve">
          <source>How can I implement &lt;code&gt;Copy&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;Copy&lt;/code&gt; を実装するにはどうすればよいですか？</target>
        </trans-unit>
        <trans-unit id="90084b4cc636cc9404dd416f2e580ffcac6958d2" translate="yes" xml:space="preserve">
          <source>How can I implement &lt;code&gt;Default&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;Default&lt;/code&gt; を実装するにはどうすればよいですか？</target>
        </trans-unit>
        <trans-unit id="d8e36d59adc904734a7c5575517b6fe0eeceec60" translate="yes" xml:space="preserve">
          <source>How can I implement &lt;code&gt;Eq&lt;/code&gt;?</source>
          <target state="translated">どうすれば &lt;code&gt;Eq&lt;/code&gt; を実装できますか？</target>
        </trans-unit>
        <trans-unit id="abe50871479611eca84afd8dcffaec7414f4b665" translate="yes" xml:space="preserve">
          <source>How can I implement &lt;code&gt;Ord&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;Ord&lt;/code&gt; を実装するにはどうすればよいですか？</target>
        </trans-unit>
        <trans-unit id="a86f0c480a53af07a5339e4a6426e55601cb46dc" translate="yes" xml:space="preserve">
          <source>How can I implement &lt;code&gt;PartialEq&lt;/code&gt;?</source>
          <target state="translated">どのように &lt;code&gt;PartialEq&lt;/code&gt; を実装できますか？</target>
        </trans-unit>
        <trans-unit id="a00e532c303bae49fb14eef74bc7c06484efea04" translate="yes" xml:space="preserve">
          <source>How can I implement &lt;code&gt;PartialOrd&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;PartialOrd&lt;/code&gt; を実装するにはどうすればよいですか？</target>
        </trans-unit>
        <trans-unit id="8bcb70d690260ea744efd091583de3413f03f2d0" translate="yes" xml:space="preserve">
          <source>How can we define some default values? You can use &lt;code&gt;Default&lt;/code&gt;:</source>
          <target state="translated">どうすればデフォルト値を定義できますか？ &lt;code&gt;Default&lt;/code&gt; を使用できます：</target>
        </trans-unit>
        <trans-unit id="ac97bbda97cfacdb06a7fbecfd828bfbc649940c" translate="yes" xml:space="preserve">
          <source>How do we know &lt;code&gt;File::open&lt;/code&gt; returns a &lt;code&gt;Result&lt;/code&gt;? We could look at the &lt;a href=&quot;../std/index&quot;&gt;standard library API documentation&lt;/a&gt;, or we could ask the compiler! If we give &lt;code&gt;f&lt;/code&gt; a type annotation that we know is &lt;em&gt;not&lt;/em&gt; the return type of the function and then try to compile the code, the compiler will tell us that the types don&amp;rsquo;t match. The error message will then tell us what the type of &lt;code&gt;f&lt;/code&gt;&lt;em&gt;is&lt;/em&gt;. Let&amp;rsquo;s try it! We know that the return type of &lt;code&gt;File::open&lt;/code&gt; isn&amp;rsquo;t of type &lt;code&gt;u32&lt;/code&gt;, so let&amp;rsquo;s change the &lt;code&gt;let f&lt;/code&gt; statement to this:</source>
          <target state="translated">&lt;code&gt;File::open&lt;/code&gt; が &lt;code&gt;Result&lt;/code&gt; を返すことをどうやって知るのですか？私たちは、見て可能性があり&lt;a href=&quot;../std/index&quot;&gt;、標準ライブラリのAPIドキュメント&lt;/a&gt;、または我々は、コンパイラを求めることができます！関数の戻り値の型では&lt;em&gt;ない&lt;/em&gt;ことがわかっている型注釈を &lt;code&gt;f&lt;/code&gt; に指定してコードをコンパイルしようとすると、型が一致しないことがコンパイラーから通知されます。エラーメッセージは、その後のタイプを教えます &lt;code&gt;f&lt;/code&gt; が&lt;em&gt;あります&lt;/em&gt;。試してみよう！ &lt;code&gt;File::open&lt;/code&gt; 戻り型が &lt;code&gt;u32&lt;/code&gt; 型ではないことがわかっているので、 &lt;code&gt;let f&lt;/code&gt; ステートメントを次のように変更してみましょう。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c77df57666e7d061d1c5eeb6d1b1b4663f41398a" translate="yes" xml:space="preserve">
          <source>How to Use This Book</source>
          <target state="translated">本書の使い方</target>
        </trans-unit>
        <trans-unit id="9264c72068f4a42ab4bf1cb16708fbe650c704ec" translate="yes" xml:space="preserve">
          <source>How to Write Tests</source>
          <target state="translated">テストの書き方</target>
        </trans-unit>
        <trans-unit id="fc0a5ea77505e42cd0dd485ee502c0a345de0fc4" translate="yes" xml:space="preserve">
          <source>How to Write a Custom &lt;code id=&quot;how-to-write-a-custom-derive-macro&quot;&gt;derive&lt;/code&gt; Macro</source>
          <target state="translated">カスタム &lt;code id=&quot;how-to-write-a-custom-derive-macro&quot;&gt;derive&lt;/code&gt; マクロを作成する方法</target>
        </trans-unit>
        <trans-unit id="ad4a0038f92fbf9afa07ab6d269a6a337b56f053" translate="yes" xml:space="preserve">
          <source>How to combine the sub-expressions' values to obtain the value of the expression</source>
          <target state="translated">副式の値を組み合わせて式の値を得る方法</target>
        </trans-unit>
        <trans-unit id="9a65f179439d735746c8cd2892082ebe3669f2c2" translate="yes" xml:space="preserve">
          <source>How to create threads to run multiple pieces of code at the same time</source>
          <target state="translated">複数のコードを同時に実行するためのスレッドの作成方法</target>
        </trans-unit>
        <trans-unit id="62c635e88978649a0009198984dfd524bc6937d1" translate="yes" xml:space="preserve">
          <source>How to read this documentation</source>
          <target state="translated">このドキュメントの読み方</target>
        </trans-unit>
        <trans-unit id="2ef34f8c5ce17d8eb29baa4d5f6535815ba4013f" translate="yes" xml:space="preserve">
          <source>How to use these two features to improve the I/O project in Chapter 12</source>
          <target state="translated">第12章のI/Oプロジェクトを改善するために、この2つの機能をどのように使用するか</target>
        </trans-unit>
        <trans-unit id="f5abcbd8d5f910274d31d405f70ebd71158dda69" translate="yes" xml:space="preserve">
          <source>However be careful: if you try to access an index which isn't in the &lt;code&gt;Vec&lt;/code&gt;, your software will panic! You cannot do this:</source>
          <target state="translated">ただし注意が必要です &lt;code&gt;Vec&lt;/code&gt; にないインデックスにアクセスしようとすると、ソフトウェアがパニックになります。あなたはこれを行うことができません：</target>
        </trans-unit>
        <trans-unit id="9a3761438ee9135873d2d6c4d19984a1561781e6" translate="yes" xml:space="preserve">
          <source>However be cautious: this method expects &lt;code&gt;self&lt;/code&gt; to be mutable, which is generally not the case when using a &lt;code&gt;RefCell&lt;/code&gt;. Take a look at the &lt;a href=&quot;#method.borrow_mut&quot;&gt;&lt;code&gt;borrow_mut&lt;/code&gt;&lt;/a&gt; method instead if &lt;code&gt;self&lt;/code&gt; isn't mutable.</source>
          <target state="translated">ただし、注意が必要です。このメソッドは、 &lt;code&gt;self&lt;/code&gt; が変更可能であることを期待しています。これは、 &lt;code&gt;RefCell&lt;/code&gt; を使用する場合は通常そうではありません。 &lt;code&gt;self&lt;/code&gt; が変更可能でない場合は、代わりに&lt;a href=&quot;#method.borrow_mut&quot;&gt; &lt;code&gt;borrow_mut&lt;/code&gt; &lt;/a&gt;メソッドを見てください。</target>
        </trans-unit>
        <trans-unit id="98f7e0f867227ba5004f997a2d43f7281873ef09" translate="yes" xml:space="preserve">
          <source>However it remains possible to implement the others separately for types which do not have a total order. For example, for floating point numbers, &lt;code&gt;NaN &amp;lt; 0 == false&lt;/code&gt; and &lt;code&gt;NaN &amp;gt;= 0 == false&lt;/code&gt; (cf. IEEE 754-2008 section 5.11).</source>
          <target state="translated">ただし、全体の順序を持​​たないタイプに対して、他のものを個別に実装することは引き続き可能です。たとえば、浮動小数点数の場合、 &lt;code&gt;NaN &amp;lt; 0 == false&lt;/code&gt; および &lt;code&gt;NaN &amp;gt;= 0 == false&lt;/code&gt; （IEEE 754-2008セクション5.11を参照）。</target>
        </trans-unit>
        <trans-unit id="06b5f47175aeebdf26128c567eba8d39893966c4" translate="yes" xml:space="preserve">
          <source>However programmers will usually prefer to use &lt;a href=&quot;../sync/mpsc/index&quot;&gt;&lt;code&gt;channel&lt;/code&gt;&lt;/a&gt;s, &lt;a href=&quot;../sync/struct.condvar&quot;&gt;&lt;code&gt;Condvar&lt;/code&gt;&lt;/a&gt;s, &lt;a href=&quot;../sync/struct.mutex&quot;&gt;&lt;code&gt;Mutex&lt;/code&gt;&lt;/a&gt;es or &lt;a href=&quot;struct.joinhandle#method.join&quot;&gt;&lt;code&gt;join&lt;/code&gt;&lt;/a&gt; for their synchronization routines, as they avoid thinking about thread scheduling.</source>
          <target state="translated">ただし、プログラマはスレッドスケジューリングについて考えることを避けるため、通常、同期ルーチンに&lt;a href=&quot;../sync/mpsc/index&quot;&gt; &lt;code&gt;channel&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../sync/struct.condvar&quot;&gt; &lt;code&gt;Condvar&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../sync/struct.mutex&quot;&gt; &lt;code&gt;Mutex&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;struct.joinhandle#method.join&quot;&gt; &lt;code&gt;join&lt;/code&gt; &lt;/a&gt;を使用することを好みます。</target>
        </trans-unit>
        <trans-unit id="99de4c47e704419c664802a54254a42292d00132" translate="yes" xml:space="preserve">
          <source>However remember that a type &lt;em&gt;containing&lt;/em&gt; a &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; is not necessarily the same layout; Rust does not in general guarantee that the fields of a &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt; have the same order as a &lt;code&gt;Foo&amp;lt;U&amp;gt;&lt;/code&gt; even if &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; have the same size and alignment. Furthermore because any bit value is valid for a &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; the compiler can't apply non-zero/niche-filling optimizations, potentially resulting in a larger size:</source>
          <target state="translated">ただし、 &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; &lt;em&gt;を含む&lt;/em&gt;型は必ずしも同じレイアウトであるとは限らないことに注意してください。 &lt;code&gt;T&lt;/code&gt; と &lt;code&gt;U&lt;/code&gt; のサイズと配置が同じであっても、Rustは一般に &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt; フィールドが &lt;code&gt;Foo&amp;lt;U&amp;gt;&lt;/code&gt; と同じ順序であることを保証しません。さらに、いずれのビット値も &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; に対して有効であるため、コンパイラーはゼロ以外/ニッチ充填の最適化を適用できず、サイズが大きくなる可能性があります。</target>
        </trans-unit>
        <trans-unit id="78a2c549597916b72868a0675d936d5af7b87a27" translate="yes" xml:space="preserve">
          <source>However there is one case where &lt;code&gt;!&lt;/code&gt; syntax can be used before &lt;code&gt;!&lt;/code&gt; is stabilized as a full-fledged type: in the position of a function&amp;rsquo;s return type. Specifically, it is possible implementations for two different function pointer types:</source>
          <target state="translated">ただし、 &lt;code&gt;!&lt;/code&gt; 構文は前に使用できます &lt;code&gt;!&lt;/code&gt; 関数の戻り値の型の位置で、本格的な型として安定します。具体的には、2つの異なる関数ポインタタイプの実装が可能です。</target>
        </trans-unit>
        <trans-unit id="cbb72443619bbca435164ca1a76cab29482ce889" translate="yes" xml:space="preserve">
          <source>However there is one case where &lt;code&gt;!&lt;/code&gt; syntax can be used before &lt;code&gt;!&lt;/code&gt; is stabilized as a full-fleged type: in the position of a function&amp;rsquo;s return type. Specifically, it is possible implementations for two different function pointer types:</source>
          <target state="translated">ただし、1つの場合があり &lt;code&gt;!&lt;/code&gt; 構文は前に使用できます &lt;code&gt;!&lt;/code&gt; 関数の戻り値の型の位置で、完全な型として安定化されます。具体的には、2つの異なる関数ポインタ型の実装が可能です。</target>
        </trans-unit>
        <trans-unit id="d670e0e16c2745ec16c6eaa903327038d8c0e422" translate="yes" xml:space="preserve">
          <source>However there is one caveat: prior to the 2008 version of IEEE-754, how to interpret the NaN signaling bit wasn't actually specified. Most platforms (notably x86 and ARM) picked the interpretation that was ultimately standardized in 2008, but some didn't (notably MIPS). As a result, all signaling NaNs on MIPS are quiet NaNs on x86, and vice-versa.</source>
          <target state="translated">しかし、IEEE-754の2008年版以前は、NaNシグナリングビットをどのように解釈するかについては、実際には規定されていませんでした。ほとんどのプラットフォーム(特にx86やARM)は2008年に最終的に標準化された解釈を採用していましたが、そうでないプラットフォーム(特にMIPS)もありました。その結果、MIPS上のすべてのシグナリングNaNはx86上では静かなNaNとなり、逆もまた然りです。</target>
        </trans-unit>
        <trans-unit id="0351e6925d735478389ca7fa9374b4cd22a63b09" translate="yes" xml:space="preserve">
          <source>However, &lt;a href=&quot;struct.pathbuf#method.push&quot;&gt;&lt;code&gt;push&lt;/code&gt;&lt;/a&gt; is best used for dynamic situations. This is a better way to do this when you know all of the components ahead of time:</source>
          <target state="translated">ただし、&lt;a href=&quot;struct.pathbuf#method.push&quot;&gt; &lt;code&gt;push&lt;/code&gt; &lt;/a&gt;は動的な状況に最適です。これは、事前にすべてのコンポーネントを知っている場合に、これを行うより良い方法です。</target>
        </trans-unit>
        <trans-unit id="3371f3c5522eaf5798eeaab8876eaa7be0179a80" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;dyn Trait&lt;/code&gt; is likely to produce smaller code than &lt;code&gt;impl Trait&lt;/code&gt; / generic parameters as the method won't be duplicated for each concrete type.</source>
          <target state="translated">ただし、 &lt;code&gt;dyn Trait&lt;/code&gt; は、メソッドが具象タイプごとに複製されないため、 &lt;code&gt;impl Trait&lt;/code&gt; /ジェネリックパラメーターよりも小さいコードを生成する可能性があります。</target>
        </trans-unit>
        <trans-unit id="9e9143c027c4bd572f82aee5fcf41df94d158757" translate="yes" xml:space="preserve">
          <source>However, a better solution would be using fully explicit naming of type and trait:</source>
          <target state="translated">しかし、より良い解決策は、型と形質の完全に明示的な命名を使用することでしょう。</target>
        </trans-unit>
        <trans-unit id="ee975de6dd0772652ad342b32f8653a59db9e61f" translate="yes" xml:space="preserve">
          <source>However, a single argument with a trailing comma will still not be treated as a tuple, following the convention of ignoring trailing commas in macro invocations. You can use a 1-tuple directly if you need one:</source>
          <target state="translated">しかし、マクロの呼び出しでは末尾のカンマを無視するという慣習に従って、末尾にカンマを付けた単一の引数はタプルとして扱われません。1タプルが必要な場合は、直接1タプルを使用することができます。</target>
        </trans-unit>
        <trans-unit id="b007fe5fc274829b5c0d27c599f3eea8f9ba132a" translate="yes" xml:space="preserve">
          <source>However, associated functions that are part of traits don&amp;rsquo;t have a &lt;code&gt;self&lt;/code&gt; parameter. When two types in the same scope implement that trait, Rust can&amp;rsquo;t figure out which type you mean unless you use &lt;em&gt;fully qualified syntax&lt;/em&gt;. For example, the &lt;code&gt;Animal&lt;/code&gt; trait in Listing 19-19 has the associated function &lt;code&gt;baby_name&lt;/code&gt;, the implementation of &lt;code&gt;Animal&lt;/code&gt; for the struct &lt;code&gt;Dog&lt;/code&gt;, and the associated function &lt;code&gt;baby_name&lt;/code&gt; defined on &lt;code&gt;Dog&lt;/code&gt; directly.</source>
          <target state="translated">ただし、特性の一部である関連する関数には、 &lt;code&gt;self&lt;/code&gt; パラメータがありません。同じスコープ内の2つの型がその特性を実装する場合、&lt;em&gt;完全修飾構文&lt;/em&gt;を使用しない限り、Rustはどの型を意味するのか理解できません。たとえば、リスト19-19の &lt;code&gt;Animal&lt;/code&gt; トレイトには、関連する関数 &lt;code&gt;baby_name&lt;/code&gt; 、struct &lt;code&gt;Dog&lt;/code&gt; の &lt;code&gt;Animal&lt;/code&gt; の実装、および関連する関数 &lt;code&gt;baby_name&lt;/code&gt; が &lt;code&gt;Dog&lt;/code&gt; に直接定義されています。</target>
        </trans-unit>
        <trans-unit id="a8a92146e9c361c007de32df04115100977209af" translate="yes" xml:space="preserve">
          <source>However, be careful when two types have a common associated type:</source>
          <target state="translated">ただし、2つのタイプに共通の関連タイプがある場合は注意が必要です。</target>
        </trans-unit>
        <trans-unit id="7c05de5702d4d9921eaeead5a04ffacda460142d" translate="yes" xml:space="preserve">
          <source>However, because &lt;code&gt;a&lt;/code&gt; is still referencing the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; that was in &lt;code&gt;b&lt;/code&gt;, that &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; has a count of 1 rather than 0, so the memory the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; has on the heap won&amp;rsquo;t be dropped. The memory will just sit there with a count of 1, forever. To visualize this reference cycle, we&amp;rsquo;ve created a diagram in Figure 15-4.</source>
          <target state="translated">ただし、 &lt;code&gt;a&lt;/code&gt; はまだ &lt;code&gt;b&lt;/code&gt; にあった &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; を参照しているため、 &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; のカウントは0ではなく1であるため、 &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; がヒープ上に保持しているメモリは削除されません。記憶は、カウント1で永久にそこに置かれます。この参照サイクルを視覚化するために、図15-4の図を作成しました。</target>
        </trans-unit>
        <trans-unit id="0161534a8ade8082b05e52cb4b19d957b4c686da" translate="yes" xml:space="preserve">
          <source>However, being able to represent this wide range of numbers comes at the cost of precision: floats can only represent some of the real numbers and calculation with floats round to a nearby representable number. For example, &lt;code&gt;5.0&lt;/code&gt; and &lt;code&gt;1.0&lt;/code&gt; can be exactly represented as &lt;code&gt;f32&lt;/code&gt;, but &lt;code&gt;1.0 / 5.0&lt;/code&gt; results in &lt;code&gt;0.20000000298023223876953125&lt;/code&gt; since &lt;code&gt;0.2&lt;/code&gt; cannot be exactly represented as &lt;code&gt;f32&lt;/code&gt;. Note however, that printing floats with &lt;code&gt;println&lt;/code&gt; and friends will often discard insignificant digits: &lt;code&gt;println!(&quot;{}&quot;, 1.0f32 / 5.0f32)&lt;/code&gt; will print &lt;code&gt;0.2&lt;/code&gt;.</source>
          <target state="translated">ただし、この広範囲の数値を表現できると、精度が犠牲になります。フロートは実際の数値の一部しか表現できず、フロートを使用して計算すると、近くの表現可能な数値に丸められます。たとえば、 &lt;code&gt;5.0&lt;/code&gt; と &lt;code&gt;1.0&lt;/code&gt; は &lt;code&gt;f32&lt;/code&gt; として正確に表すことができますが、 &lt;code&gt;0.2&lt;/code&gt; は &lt;code&gt;f32&lt;/code&gt; として正確に表すことができないため、 &lt;code&gt;1.0 / 5.0&lt;/code&gt; &lt;code&gt;0.20000000298023223876953125&lt;/code&gt; は0.20000000298023223876953125になります。ただし、 &lt;code&gt;println&lt;/code&gt; やその仲間と一緒にフロートを印刷すると、重要でない数字が破棄されることがよくあります &lt;code&gt;println!(&quot;{}&quot;, 1.0f32 / 5.0f32)&lt;/code&gt; は &lt;code&gt;0.2&lt;/code&gt; を出力します。</target>
        </trans-unit>
        <trans-unit id="bc86d5089c69372edd80eafac68df3ec0dbaefb7" translate="yes" xml:space="preserve">
          <source>However, being able to represent this wide range of numbers comes at the cost of precision: floats can only represent some of the real numbers and calculation with floats round to a nearby representable number. For example, &lt;code&gt;5.0&lt;/code&gt; and &lt;code&gt;1.0&lt;/code&gt; can be exactly represented as &lt;code&gt;f32&lt;/code&gt;, but &lt;code&gt;1.0 / 5.0&lt;/code&gt; results in &lt;code&gt;0.20000000298023223876953125&lt;/code&gt; since &lt;code&gt;0.2&lt;/code&gt; cannot be exactly represented as &lt;code&gt;f32&lt;/code&gt;. Note, however, that printing floats with &lt;code&gt;println&lt;/code&gt; and friends will often discard insignificant digits: &lt;code&gt;println!(&quot;{}&quot;, 1.0f32 / 5.0f32)&lt;/code&gt; will print &lt;code&gt;0.2&lt;/code&gt;.</source>
          <target state="translated">ただし、この広範囲の数値を表現できると、精度が犠牲になります。フロートは実際の数値の一部しか表現できず、フロートを使用して計算すると、近くの表現可能な数値に丸められます。たとえば、 &lt;code&gt;5.0&lt;/code&gt; と &lt;code&gt;1.0&lt;/code&gt; は &lt;code&gt;f32&lt;/code&gt; として正確に表すことができますが、 &lt;code&gt;0.2&lt;/code&gt; は &lt;code&gt;f32&lt;/code&gt; として正確に表すことができないため、 &lt;code&gt;1.0 / 5.0&lt;/code&gt; &lt;code&gt;0.20000000298023223876953125&lt;/code&gt; は0.20000000298023223876953125になります。ただし、 &lt;code&gt;println&lt;/code&gt; やその仲間と一緒にフロートを印刷すると、重要でない数字が破棄されることがよくあります &lt;code&gt;println!(&quot;{}&quot;, 1.0f32 / 5.0f32)&lt;/code&gt; は &lt;code&gt;0.2&lt;/code&gt; を出力します。</target>
        </trans-unit>
        <trans-unit id="a75f8c79454007f698be22ee125cb88b1db6c03c" translate="yes" xml:space="preserve">
          <source>However, for clients that do not wish to track the capacity returned by &lt;code&gt;alloc_excess&lt;/code&gt; locally, this method is likely to produce useful results.</source>
          <target state="translated">ただし、 &lt;code&gt;alloc_excess&lt;/code&gt; によってローカルに返された容量を追跡したくないクライアントの場合、このメソッドは有用な結果を生成する可能性があります。</target>
        </trans-unit>
        <trans-unit id="c6f1d589fbc14406ddd7e944ec737df44d57ed77" translate="yes" xml:space="preserve">
          <source>However, having lots of error checks in all of your functions would be verbose and annoying. Fortunately, you can use Rust&amp;rsquo;s type system (and thus the type checking the compiler does) to do many of the checks for you. If your function has a particular type as a parameter, you can proceed with your code&amp;rsquo;s logic knowing that the compiler has already ensured you have a valid value. For example, if you have a type rather than an &lt;code&gt;Option&lt;/code&gt;, your program expects to have &lt;em&gt;something&lt;/em&gt; rather than &lt;em&gt;nothing&lt;/em&gt;. Your code then doesn&amp;rsquo;t have to handle two cases for the &lt;code&gt;Some&lt;/code&gt; and &lt;code&gt;None&lt;/code&gt; variants: it will only have one case for definitely having a value. Code trying to pass nothing to your function won&amp;rsquo;t even compile, so your function doesn&amp;rsquo;t have to check for that case at runtime. Another example is using an unsigned integer type such as &lt;code&gt;u32&lt;/code&gt;, which ensures the parameter is never negative.</source>
          <target state="translated">ただし、すべての関数に多数のエラーチェックがあると、冗長で煩わしくなります。さいわい、Rustの型システム（およびコンパイラーが行う型チェック）を使用して、多くのチェックを行うことができます。関数に特定の型がパラメーターとして含まれている場合、コンパイラーが有効な値を持っていることをコンパイラーが既に確認していることを確認して、コードのロジックに進むことができます。たとえば、 &lt;code&gt;Option&lt;/code&gt; ではなくタイプがある場合、プログラムは&lt;em&gt;何&lt;/em&gt;も&lt;em&gt;ない&lt;/em&gt;&lt;em&gt;と&lt;/em&gt;いうよりは&lt;em&gt;何かを&lt;/em&gt;期待します。コードは、 &lt;code&gt;Some&lt;/code&gt; と &lt;code&gt;None&lt;/code&gt; の 2つのケースを処理する必要はありません。&lt;em&gt;&lt;/em&gt;バリアント：確実に値を持つケースは1つだけです。関数に何も渡そうとしないコードはコンパイルもできないため、関数は実行時にそのケースをチェックする必要はありません。別の例は、パラメーターが負にならないことを保証する &lt;code&gt;u32&lt;/code&gt; などの符号なし整数型の使用です。</target>
        </trans-unit>
        <trans-unit id="c47ddb353392208fbaf5c29553d62da521ea2e56" translate="yes" xml:space="preserve">
          <source>However, if a type implements &lt;code&gt;Copy&lt;/code&gt;, it instead has 'copy semantics':</source>
          <target state="translated">ただし、型が &lt;code&gt;Copy&lt;/code&gt; を実装している場合は、代わりに「コピーセマンティクス」があります。</target>
        </trans-unit>
        <trans-unit id="601ae6aeca914c05ec96fb8df8c9c4178c5a0a78" translate="yes" xml:space="preserve">
          <source>However, if it derives from &lt;code&gt;Super&amp;lt;Self&amp;gt;&lt;/code&gt;, even though &lt;code&gt;Super&lt;/code&gt; is object safe, the method &lt;code&gt;get_a()&lt;/code&gt; would return an object of unknown type when called on the function. &lt;code&gt;Self&lt;/code&gt; type parameters let us make object safe traits no longer safe, so they are forbidden when specifying supertraits.</source>
          <target state="translated">ただし、 &lt;code&gt;Super&amp;lt;Self&amp;gt;&lt;/code&gt; から派生した場合、 &lt;code&gt;Super&lt;/code&gt; はオブジェクトセーフですが、 &lt;code&gt;get_a()&lt;/code&gt; メソッドは、関数で呼び出されたときに不明なタイプのオブジェクトを返します。 &lt;code&gt;Self&lt;/code&gt; 型パラメーターを使用すると、オブジェクトの安全な特性を安全でなくすることができます。そのため、スーパー特性を指定する場合は禁止されます。</target>
        </trans-unit>
        <trans-unit id="7fad1dff57715fb5c533987e92e806ddbde896cc" translate="yes" xml:space="preserve">
          <source>However, if you still wish to use these types, you can achieve this by an unsafe wrapper:</source>
          <target state="translated">しかし、それでもこれらのタイプを使用したい場合は、安全ではないラッパーによってこれを達成することができます。</target>
        </trans-unit>
        <trans-unit id="2f1b0df6bf40f54deee89e8870694822d74c8932" translate="yes" xml:space="preserve">
          <source>However, if you wanted to access a field of a struct check that the field name is spelled correctly. Example:</source>
          <target state="translated">ただし、構造体のフィールドにアクセスしたい場合は、フィールド名のスペルが正しいかどうかを確認してください。例)構造体のフィールドにアクセスしたい場合は、フィールド名のスペルが正しいかどうかを確認してください。</target>
        </trans-unit>
        <trans-unit id="692ecbc0723f2163cd918161474068cb36f04e45" translate="yes" xml:space="preserve">
          <source>However, one long line is difficult to read, so it&amp;rsquo;s best to divide it. Now let&amp;rsquo;s discuss what this line does.</source>
          <target state="translated">ただし、1つの長い行は読みにくいため、分割することをお勧めします。それでは、この行の機能について説明しましょう。</target>
        </trans-unit>
        <trans-unit id="26830adb8373fabf090d221485ccd723186cf9b8" translate="yes" xml:space="preserve">
          <source>However, one long line is difficult to read, so it&amp;rsquo;s best to divide it: two lines for two method calls. Now let&amp;rsquo;s discuss what this line does.</source>
          <target state="translated">ただし、1行の長い行は読みにくいので、2行に分けて、2つのメソッド呼び出しを2行にするのが最善です。次に、この行が何を行うかについて説明します。</target>
        </trans-unit>
        <trans-unit id="dd472996f3f286211f48a487c70490ad383642d1" translate="yes" xml:space="preserve">
          <source>However, our intention in this chapter is to help you learn, not to take the easy route. Because Rust is a systems programming language, we can choose the level of abstraction we want to work with and can go to a lower level than is possible or practical in other languages. We&amp;rsquo;ll write the basic HTTP server and thread pool manually so you can learn the general ideas and techniques behind the crates you might use in the future.</source>
          <target state="translated">ただし、この章での目的は、簡単な方法ではなく、学習を支援することです。Rustはシステムプログラミング言語であるため、使用する抽象化のレベルを選択でき、他の言語で可能なまたは実用的なレベルよりも低いレベルに移動できます。基本的なHTTPサーバーとスレッドプールを手動で記述して、将来使用する可能性のあるクレートの背後にある一般的なアイデアとテクニックを学習できるようにします。</target>
        </trans-unit>
        <trans-unit id="a3c7769e69d54d27cbd8d165bbdf117ddc427c2b" translate="yes" xml:space="preserve">
          <source>However, please keep in mind that the first solution should be preferred.</source>
          <target state="translated">ただし、第一解が好ましいということを頭に入れておいてください。</target>
        </trans-unit>
        <trans-unit id="9e7ca595910d369d04059d59dd0f26ad24257742" translate="yes" xml:space="preserve">
          <source>However, some higher-level allocation methods (&lt;code&gt;alloc_one&lt;/code&gt;, &lt;code&gt;alloc_array&lt;/code&gt;) are well-defined on zero-sized types and can optionally support them: it is left up to the implementor whether to return &lt;code&gt;Err&lt;/code&gt;, or to return &lt;code&gt;Ok&lt;/code&gt; with some pointer.</source>
          <target state="translated">しかし、いくつかの高レベルの割り当て方法は、（ &lt;code&gt;alloc_one&lt;/code&gt; 、 &lt;code&gt;alloc_array&lt;/code&gt; ）ゼロサイズの種類に明確に定義されており、必要に応じてそれらをサポートすることができる：返すかどうかを実装者に任されている &lt;code&gt;Err&lt;/code&gt; 、または戻すために &lt;code&gt;Ok&lt;/code&gt; 、いくつかのポインタで。</target>
        </trans-unit>
        <trans-unit id="bb26cd270c81cacb615098ed7b7796b24ddb7cc6" translate="yes" xml:space="preserve">
          <source>However, sometimes we want our library user to be able to extend the set of types that are valid in a particular situation. To show how we might achieve this, we&amp;rsquo;ll create an example graphical user interface (GUI) tool that iterates through a list of items, calling a &lt;code&gt;draw&lt;/code&gt; method on each one to draw it to the screen&amp;mdash;a common technique for GUI tools. We&amp;rsquo;ll create a library crate called &lt;code&gt;gui&lt;/code&gt; that contains the structure of a GUI library. This crate might include some types for people to use, such as &lt;code&gt;Button&lt;/code&gt; or &lt;code&gt;TextField&lt;/code&gt;. In addition, &lt;code&gt;gui&lt;/code&gt; users will want to create their own types that can be drawn: for instance, one programmer might add an &lt;code&gt;Image&lt;/code&gt; and another might add a &lt;code&gt;SelectBox&lt;/code&gt;.</source>
          <target state="translated">ただし、特定の状況で有効なタイプのセットをライブラリユーザーが拡張できるようにしたい場合があります。これをどのように実現できるかを示すために、アイテムのリストを反復処理するサンプルのグラフィカルユーザーインターフェイス（GUI）ツールを作成し、それぞれに &lt;code&gt;draw&lt;/code&gt; メソッドを呼び出して画面に描画します。これはGUIツールの一般的な手法です。GUIライブラリの構造を含む &lt;code&gt;gui&lt;/code&gt; と呼ばれるライブラリクレートを作成します。このクレートには、 &lt;code&gt;Button&lt;/code&gt; や &lt;code&gt;TextField&lt;/code&gt; など、ユーザーが使用するいくつかのタイプが含まれる場合があります。さらに、 &lt;code&gt;gui&lt;/code&gt; ユーザーは描画可能な独自のタイプを作成する必要があります。たとえば、あるプログラマーが &lt;code&gt;Image&lt;/code&gt; を追加し、別のプログラマーが画像を追加する場合があります。 &lt;code&gt;SelectBox&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="090c640dded64692c1c679520894484188072e98" translate="yes" xml:space="preserve">
          <source>However, structural pinning comes with a few extra requirements:</source>
          <target state="translated">しかし、構造的なピン留めは、いくつかの余分な要件が付属しています。</target>
        </trans-unit>
        <trans-unit id="6446591953c7036afa44804569e6b2a76fecb194" translate="yes" xml:space="preserve">
          <source>However, suffixes on literal tokens parsed as Rust code are restricted.</source>
          <target state="translated">ただし、Rust コードとして解析されるリテラルトークンのサフィックスは制限されています。</target>
        </trans-unit>
        <trans-unit id="fd97947a4cfc6a63fedbe7991de9dd273fb032fc" translate="yes" xml:space="preserve">
          <source>However, suffixes on literal tokens parsed as Rust code are restricted. Any suffixes are rejected on non-numeric literal tokens, and numeric literal tokens are accepted only with suffixes from the list below.</source>
          <target state="translated">ただし、Rust コードとして解析されるリテラル トークンのサフィックスは制限されています。数値以外のリテラルトークンのサフィックスはすべて拒否され、数値リテラルトークンは以下のリストのサフィックスを付けてのみ受け入れられます。</target>
        </trans-unit>
        <trans-unit id="e53d985c5c53455719af4369d5bd75e2e43f4f1b" translate="yes" xml:space="preserve">
          <source>However, the &lt;code&gt;match&lt;/code&gt; expression can be a bit wordy in a situation in which we care about only &lt;em&gt;one&lt;/em&gt; of the cases. For this situation, Rust provides &lt;code&gt;if let&lt;/code&gt;.</source>
          <target state="translated">ただし、&lt;em&gt;1つ&lt;/em&gt;のケースのみを対象とする状況では、 &lt;code&gt;match&lt;/code&gt; 式が少し冗長になる可能性があります。この状況で、Rustは &lt;code&gt;if let&lt;/code&gt; 提供します。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a11b9e584ed4976bfbc4897d2baa5077bb7ad3ff" translate="yes" xml:space="preserve">
          <source>However, the code in Listing 2-4 won&amp;rsquo;t compile yet. Let&amp;rsquo;s try it:</source>
          <target state="translated">ただし、リスト2-4のコードはまだコンパイルできません。試してみよう：</target>
        </trans-unit>
        <trans-unit id="5ff36d97f387c34f0e3f89e3b84848ea32f28366" translate="yes" xml:space="preserve">
          <source>However, the concept that null is trying to express is still a useful one: a null is a value that is currently invalid or absent for some reason.</source>
          <target state="translated">しかし、NULLが表現しようとしている概念はまだ有用なものです:NULLとは、何らかの理由で現在無効な値、または存在しない値のことです。</target>
        </trans-unit>
        <trans-unit id="cda87a9e6a4c7e24911050c4147eddad9fb1a4fd" translate="yes" xml:space="preserve">
          <source>However, the pointer may not actually point to allocated memory. In particular, if you construct a &lt;code&gt;Vec&lt;/code&gt; with capacity 0 via &lt;a href=&quot;struct.vec#method.new&quot;&gt;&lt;code&gt;Vec::new&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../macro.vec&quot;&gt;&lt;code&gt;vec![]&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.vec#method.with_capacity&quot;&gt;&lt;code&gt;Vec::with_capacity(0)&lt;/code&gt;&lt;/a&gt;, or by calling &lt;a href=&quot;struct.vec#method.shrink_to_fit&quot;&gt;&lt;code&gt;shrink_to_fit&lt;/code&gt;&lt;/a&gt; on an empty Vec, it will not allocate memory. Similarly, if you store zero-sized types inside a &lt;code&gt;Vec&lt;/code&gt;, it will not allocate space for them. &lt;em&gt;Note that in this case the &lt;code&gt;Vec&lt;/code&gt; may not report a &lt;a href=&quot;struct.vec#method.capacity&quot;&gt;&lt;code&gt;capacity&lt;/code&gt;&lt;/a&gt; of 0&lt;/em&gt;. &lt;code&gt;Vec&lt;/code&gt; will allocate if and only if &lt;a href=&quot;../mem/fn.size_of&quot;&gt;&lt;code&gt;mem::size_of::&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;code&gt;() * capacity() &amp;gt; 0&lt;/code&gt;. In general, &lt;code&gt;Vec&lt;/code&gt;'s allocation details are very subtle &amp;mdash; if you intend to allocate memory using a &lt;code&gt;Vec&lt;/code&gt; and use it for something else (either to pass to unsafe code, or to build your own memory-backed collection), be sure to deallocate this memory by using &lt;code&gt;from_raw_parts&lt;/code&gt; to recover the &lt;code&gt;Vec&lt;/code&gt; and then dropping it.</source>
          <target state="translated">ただし、ポインタが実際に割り当てられたメモリを指しているとは限りません。特に、&lt;a href=&quot;struct.vec#method.new&quot;&gt; &lt;code&gt;Vec::new&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../macro.vec&quot;&gt; &lt;code&gt;vec![]&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;struct.vec#method.with_capacity&quot;&gt; &lt;code&gt;Vec::with_capacity(0)&lt;/code&gt; &lt;/a&gt;を&lt;a href=&quot;struct.vec#method.shrink_to_fit&quot;&gt; &lt;code&gt;shrink_to_fit&lt;/code&gt; &lt;/a&gt;て、または空のVecでshrink_to_fitを呼び出して、容量0の &lt;code&gt;Vec&lt;/code&gt; を構築する場合、メモリは割り当てられません。同様に、サイズがゼロの型を &lt;code&gt;Vec&lt;/code&gt; 内に格納する場合、それらにスペースは割り当てられません。&lt;em&gt;この場合、&lt;/em&gt;&lt;em&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/em&gt;&lt;em&gt;は&lt;/em&gt;&lt;em&gt;&lt;a href=&quot;struct.vec#method.capacity&quot;&gt; &lt;code&gt;capacity&lt;/code&gt; &lt;/a&gt;&lt;/em&gt;&lt;em&gt; 0を&lt;/em&gt;&lt;em&gt;報告しない&lt;/em&gt;&lt;em&gt;場合があることに注意してください&lt;/em&gt;。 &lt;code&gt;Vec&lt;/code&gt; は、&lt;a href=&quot;../mem/fn.size_of&quot;&gt; &lt;code&gt;mem::size_of::&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; &lt;code&gt;() * capacity() &amp;gt; 0&lt;/code&gt; 場合にのみ割り当てます。一般的に、 &lt;code&gt;Vec&lt;/code&gt; &lt;em&gt;&lt;/em&gt;の割り当ての詳細は非常に微妙です &lt;code&gt;Vec&lt;/code&gt; を使用してメモリを割り当て、それを別の目的で使用する場合（安全でないコードに渡すか、独自のメモリバックアップコレクションを構築する場合）、必ずこのメモリを割り当て解除してください &lt;code&gt;from_raw_parts&lt;/code&gt; を使用して &lt;code&gt;Vec&lt;/code&gt; を回復し、ドロップします。</target>
        </trans-unit>
        <trans-unit id="71a07da2ac46a34c0d6bf7a73675b61fc8ad742b" translate="yes" xml:space="preserve">
          <source>However, the reverse is not true: not all valid &lt;a href=&quot;../primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;s are valid &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s. &lt;code&gt;from_u32()&lt;/code&gt; will return &lt;code&gt;None&lt;/code&gt; if the input is not a valid value for a &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ただし、その逆は当てはまりません。有効な&lt;a href=&quot;../primitive.u32&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt;がすべて有効な&lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; である&lt;/a&gt;とは限りません。 &lt;code&gt;from_u32()&lt;/code&gt; は、入力が&lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; の&lt;/a&gt;有効な値でない場合は &lt;code&gt;None&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="627ab6996d8e9eb90f195c27a7e3d742a80e3b8e" translate="yes" xml:space="preserve">
          <source>However, the reverse is not true: not all valid &lt;a href=&quot;../primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;s are valid &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s. &lt;code&gt;from_u32_unchecked()&lt;/code&gt; will ignore this, and blindly cast to &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, possibly creating an invalid one.</source>
          <target state="translated">ただし、その逆は当てはまりません。有効な&lt;a href=&quot;../primitive.u32&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt;がすべて有効な&lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; である&lt;/a&gt;とは限りません。 &lt;code&gt;from_u32_unchecked()&lt;/code&gt; はこれを無視し、盲目的に&lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;にキャストして、無効なものを作成する可能性があります。</target>
        </trans-unit>
        <trans-unit id="3551f079ee4c6634be3812dc148413baa86b8300" translate="yes" xml:space="preserve">
          <source>However, the reverse is not true: not all valid &lt;a href=&quot;primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;s are valid &lt;code&gt;char&lt;/code&gt;s. &lt;code&gt;from_u32()&lt;/code&gt; will return &lt;code&gt;None&lt;/code&gt; if the input is not a valid value for a &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">ただし、その逆は当てはまりません。すべての有効な&lt;a href=&quot;primitive.u32&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt;が有効な &lt;code&gt;char&lt;/code&gt; とは限りません。入力が &lt;code&gt;char&lt;/code&gt; の有効な値でない場合、 &lt;code&gt;from_u32()&lt;/code&gt; は &lt;code&gt;None&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="7eb7d7f1f319fa36dc03fb6cd45ffdc556ad5b67" translate="yes" xml:space="preserve">
          <source>However, the reverse is not true: not all valid &lt;a href=&quot;primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;s are valid &lt;code&gt;char&lt;/code&gt;s. &lt;code&gt;from_u32_unchecked()&lt;/code&gt; will ignore this, and blindly cast to &lt;code&gt;char&lt;/code&gt;, possibly creating an invalid one.</source>
          <target state="translated">ただし、その逆は当てはまりません。すべての有効な&lt;a href=&quot;primitive.u32&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt;が有効な &lt;code&gt;char&lt;/code&gt; とは限りません。 &lt;code&gt;from_u32_unchecked()&lt;/code&gt; はこれを無視し、盲目的に &lt;code&gt;char&lt;/code&gt; にキャストし、無効な文字を作成する可能性があります。</target>
        </trans-unit>
        <trans-unit id="1f5612bf46edfe618e917ff01d32fb9bebb43312" translate="yes" xml:space="preserve">
          <source>However, the second part is different. In languages with a &lt;em&gt;garbage collector (GC)&lt;/em&gt;, the GC keeps track and cleans up memory that isn&amp;rsquo;t being used anymore, and we don&amp;rsquo;t need to think about it. Without a GC, it&amp;rsquo;s our responsibility to identify when memory is no longer being used and call code to explicitly return it, just as we did to request it. Doing this correctly has historically been a difficult programming problem. If we forget, we&amp;rsquo;ll waste memory. If we do it too early, we&amp;rsquo;ll have an invalid variable. If we do it twice, that&amp;rsquo;s a bug too. We need to pair exactly one &lt;code&gt;allocate&lt;/code&gt; with exactly one &lt;code&gt;free&lt;/code&gt;.</source>
          <target state="translated">ただし、2番目の部分は異なります。&lt;em&gt;ガベージコレクター（GC）&lt;/em&gt;を備えた言語では、GCは追跡し、使用されなくなったメモリをクリーンアップします。これについて考える必要はありません。 GCがなければ、メモリを使用しなくなった時期を特定し、コードを呼び出して明示的にそれを返すのは、要求したときと同じです。これを正しく行うことは歴史的に難しいプログラミング問題でした。忘れてしまうと記憶を無駄にしてしまいます。早すぎると、変数が無効になります。それを2回行うと、それもバグです。 &lt;code&gt;allocate&lt;/code&gt; を1つと &lt;code&gt;free&lt;/code&gt; 1つだけにする必要があります。</target>
        </trans-unit>
        <trans-unit id="af229bc0a48ef0630b724d21dd6f456c48e60c69" translate="yes" xml:space="preserve">
          <source>However, there are situations in which it would be useful for a value to mutate itself in its methods but appear immutable to other code. Code outside the value&amp;rsquo;s methods would not be able to mutate the value. Using &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; is one way to get the ability to have interior mutability. But &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; doesn&amp;rsquo;t get around the borrowing rules completely: the borrow checker in the compiler allows this interior mutability, and the borrowing rules are checked at runtime instead. If you violate the rules, you&amp;rsquo;ll get a &lt;code&gt;panic!&lt;/code&gt; instead of a compiler error.</source>
          <target state="translated">ただし、値がメソッド内で変化しても、他のコードでは不変に見えると便利な場合があります。値のメソッド外のコードは、値を変更できません。 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 使用は、内部で可変性を持たせるための1つの方法です。ただし、 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; は借用ルールを完全には回避しません。コンパイラの借用チェッカーはこの内部の可変性を許可し、代わりに実行時に借用ルールがチェックされます。ルールに違反すると、 &lt;code&gt;panic!&lt;/code&gt; コンパイラエラーの代わりに。</target>
        </trans-unit>
        <trans-unit id="a0d46c846b73ae9a30e6ec8307068cbd57726662" translate="yes" xml:space="preserve">
          <source>However, there is a &lt;a href=&quot;../type-coercions&quot;&gt;coercion&lt;/a&gt; from function items to &lt;a href=&quot;function-pointer&quot;&gt;function pointers&lt;/a&gt; with the same signature, which is triggered not only when a function item is used when a function pointer is directly expected, but also when different function item types with the same signature meet in different arms of the same &lt;code&gt;if&lt;/code&gt; or &lt;code&gt;match&lt;/code&gt;:</source>
          <target state="translated">ただし、関数アイテムから同じシグネチャを&lt;a href=&quot;function-pointer&quot;&gt;持つ関数ポインタ&lt;/a&gt;への&lt;a href=&quot;../type-coercions&quot;&gt;強制&lt;/a&gt;があります。これは、関数ポインタが直接期待されているときに関数アイテムが使用される場合だけでなく、同じシグネチャを持つ異なる関数アイテムタイプが異なる場合にトリガーされます。同じまたは &lt;code&gt;match&lt;/code&gt; &lt;code&gt;if&lt;/code&gt; 腕：</target>
        </trans-unit>
        <trans-unit id="a66a1dddad283613aaa962e121910c064ac30ef0" translate="yes" xml:space="preserve">
          <source>However, there&amp;rsquo;s one problem with this test, as shown here:</source>
          <target state="translated">ただし、次に示すように、このテストには1つの問題があります。</target>
        </trans-unit>
        <trans-unit id="18f90c271b4c818c9717e731f31d20c5d63240c8" translate="yes" xml:space="preserve">
          <source>However, they would need to write the implementation block for each type they wanted to use with &lt;code&gt;hello_macro&lt;/code&gt;; we want to spare them from having to do this work.</source>
          <target state="translated">ただし、 &lt;code&gt;hello_macro&lt;/code&gt; で使用するタイプごとに実装ブロックを作成する必要があります。私たちは彼らがこの仕事をしなくて済むようにしたいと思っています。</target>
        </trans-unit>
        <trans-unit id="4c27a12b4f8451e9cc5839d83f04460a9e92623c" translate="yes" xml:space="preserve">
          <source>However, this &quot;zombie&quot; value should not be exposed to safe code, and this function should not be called more than once. To use a value after it's been dropped, or drop a value multiple times, can cause Undefined Behavior (depending on what &lt;code&gt;drop&lt;/code&gt; does). This is normally prevented by the type system, but users of &lt;code&gt;ManuallyDrop&lt;/code&gt; must uphold those guarantees without assistance from the compiler.</source>
          <target state="translated">ただし、この「ゾンビ」値を安全なコードに公開したり、この関数を複数回呼び出したりしないでください。ドロップされた後に値を使用したり、値を複数回ドロップしたりすると、未定義の動作が発生する可能性があります（ &lt;code&gt;drop&lt;/code&gt; 動作によって異なります）。これは通常、型システムによって防止されますが、 &lt;code&gt;ManuallyDrop&lt;/code&gt; のユーザーは、コンパイラーの支援なしにこれらの保証を維持する必要があります。</target>
        </trans-unit>
        <trans-unit id="313fc636d6ceb50d6fb43efb8c2726a3510a1c57" translate="yes" xml:space="preserve">
          <source>However, this extra power comes with extra responsibilities: it is now up to you to ensure soundness. The &lt;code&gt;unsafe&lt;/code&gt; keyword helps by clearly marking the pieces of code that need to worry about this.</source>
          <target state="translated">ただし、この追加の権限には追加の責任が伴います。健全性を確保するのはあなた次第です。 &lt;code&gt;unsafe&lt;/code&gt; キーワードは、必要性がこのことを心配していることを明確にコードの一部をマークすることで役立ちます。</target>
        </trans-unit>
        <trans-unit id="d3b75e55302f15f6020a4b2831ab78b8a9cd134e" translate="yes" xml:space="preserve">
          <source>However, this is not an ideal solution: if it was absolutely critical that the program only operated on values between 1 and 100, and it had many functions with this requirement, having a check like this in every function would be tedious (and might impact performance).</source>
          <target state="translated">しかし、これは理想的な解決策ではありません。プログラムが1から100までの値のみで動作することが絶対的に重要で、この要件を満たす関数が多数ある場合、すべての関数でこのようなチェックを行うのは面倒です(そしてパフォーマンスに影響を与える可能性があります)。</target>
        </trans-unit>
        <trans-unit id="a824bb12ed66d349d925794b2e3920170b4c275c" translate="yes" xml:space="preserve">
          <source>However, this pattern is so common that Rust has a built-in language construct for it, called a &lt;code&gt;while&lt;/code&gt; loop. Listing 3-3 uses &lt;code&gt;while&lt;/code&gt;: the program loops three times, counting down each time, and then, after the loop, it prints another message and exits.</source>
          <target state="translated">ただし、このパターンは非常に一般的であるため、Rustには &lt;code&gt;while&lt;/code&gt; ループと呼ばれる組み込みの言語構造があります。リスト3-3は &lt;code&gt;while&lt;/code&gt; を使用しています。プログラムは3回ループし、そのたびにカウントダウンします。その後、ループの後、別のメッセージを出力して終了します。</target>
        </trans-unit>
        <trans-unit id="ada98a89852cf14a520ca2427888843bc3fd0869" translate="yes" xml:space="preserve">
          <source>However, this won't:</source>
          <target state="translated">しかし、これではダメです。</target>
        </trans-unit>
        <trans-unit id="2ba8355a99e10032076801bb58aaec6886066a15" translate="yes" xml:space="preserve">
          <source>However, two concurrency concepts are embedded in the language: the &lt;code&gt;std::marker&lt;/code&gt; traits &lt;code&gt;Sync&lt;/code&gt; and &lt;code&gt;Send&lt;/code&gt;.</source>
          <target state="translated">ただし、言語には2つの並行性の概念が組み込まれています &lt;code&gt;std::marker&lt;/code&gt; traits &lt;code&gt;Sync&lt;/code&gt; と &lt;code&gt;Send&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="0fad3453f67fa7a8abf1de710cc99507cae5f79c" translate="yes" xml:space="preserve">
          <source>However, using &lt;code&gt;..&lt;/code&gt; must be unambiguous. If it is unclear which values are intended for matching and which should be ignored, Rust will give us an error. Listing 18-25 shows an example of using &lt;code&gt;..&lt;/code&gt; ambiguously, so it will not compile.</source>
          <target state="translated">ただし、 &lt;code&gt;..&lt;/code&gt; の使用は明確でなければなりません。マッチングの対象となる値と無視する必要のある値が明確でない場合、Rustはエラーを返します。リスト18-25は &lt;code&gt;..&lt;/code&gt; を曖昧に使用する例を示しているため、コンパイルされません。</target>
        </trans-unit>
        <trans-unit id="f1a26fc372d073b9ed76f398473c3b964914605f" translate="yes" xml:space="preserve">
          <source>However, we&amp;rsquo;ve reintroduced one of the problems from Listing 13-3: we&amp;rsquo;re still calling the closure twice in the first &lt;code&gt;if&lt;/code&gt; block, which will call the expensive code twice and make the user wait twice as long as they need to. We could fix this problem by creating a variable local to that &lt;code&gt;if&lt;/code&gt; block to hold the result of calling the closure, but closures provide us with another solution. We&amp;rsquo;ll talk about that solution in a bit. But first let&amp;rsquo;s talk about why there aren&amp;rsquo;t type annotations in the closure definition and the traits involved with closures.</source>
          <target state="translated">ただし、リスト13-3の問題の1つを再導入しました。最初の &lt;code&gt;if&lt;/code&gt; ブロックでクロージャーを2回呼び出しているため、高価なコードが2回呼び出され、ユーザーは必要なだけ2倍待機します。この問題を修正するには、その &lt;code&gt;if&lt;/code&gt; ブロックにローカルな変数を作成して、クロージャーを呼び出した結果を保持しますが、クロージャーは別のソリューションを提供します。その解決策については少し後で説明します。しかし、最初に、なぜクロージャ定義に型注釈がないのか、そしてクロージャに関連する特性について話しましょう。</target>
        </trans-unit>
        <trans-unit id="aeba4f050e04fdf1cf910571a9c79d642b8343c4" translate="yes" xml:space="preserve">
          <source>However, when failure is expected, it&amp;rsquo;s more appropriate to return a &lt;code&gt;Result&lt;/code&gt; than to make a &lt;code&gt;panic!&lt;/code&gt; call. Examples include a parser being given malformed data or an HTTP request returning a status that indicates you have hit a rate limit. In these cases, returning a &lt;code&gt;Result&lt;/code&gt; indicates that failure is an expected possibility that the calling code must decide how to handle.</source>
          <target state="translated">ただし、失敗が予想される場合は、 &lt;code&gt;panic!&lt;/code&gt; を起こすよりも &lt;code&gt;Result&lt;/code&gt; を返す方が適切です。コール。たとえば、パーサーに不正な形式のデータが与えられたり、HTTPリクエストがレート制限に達したことを示すステータスを返したりします。これらの場合、 &lt;code&gt;Result&lt;/code&gt; を返すことは、失敗が呼び出しコードが処理方法を決定しなければならないことが予想される可能性であることを示しています。</target>
        </trans-unit>
        <trans-unit id="bd1b29ca1d0594e55daa86076890956a32cf494f" translate="yes" xml:space="preserve">
          <source>However, with trait objects we have to make a table containing &lt;em&gt;every&lt;/em&gt; object that implements the trait. Now, if it has type parameters, we need to add implementations for every type that implements the trait, and there could theoretically be an infinite number of types.</source>
          <target state="translated">ただし、特性オブジェクトでは、特性を実装する&lt;em&gt;すべての&lt;/em&gt;オブジェクトを含むテーブルを作成する必要があります。ここで、型パラメーターがある場合、特性を実装するすべての型の実装を追加する必要があり、理論的には無限の型が存在する可能性があります。</target>
        </trans-unit>
        <trans-unit id="c83a1e89e4828f4c8e8c03978096139099426f82" translate="yes" xml:space="preserve">
          <source>However, you can only use &lt;code&gt;impl Trait&lt;/code&gt; if you&amp;rsquo;re returning a single type. For example, this code that returns either a &lt;code&gt;NewsArticle&lt;/code&gt; or a &lt;code&gt;Tweet&lt;/code&gt; with the return type specified as &lt;code&gt;impl Summary&lt;/code&gt; wouldn&amp;rsquo;t work:</source>
          <target state="translated">ただし、単一の型を返す場合にのみ、 &lt;code&gt;impl Trait&lt;/code&gt; を使用できます。たとえば、 &lt;code&gt;impl Summary&lt;/code&gt; として指定された戻り値のタイプで &lt;code&gt;NewsArticle&lt;/code&gt; または &lt;code&gt;Tweet&lt;/code&gt; を返すこのコードは機能しません。</target>
        </trans-unit>
        <trans-unit id="e2fcea022d94a9775aabc30c1a2c51d018156b80" translate="yes" xml:space="preserve">
          <source>Hundreds of companies, large and small, use Rust in production for a variety of tasks. Those tasks include command line tools, web services, DevOps tooling, embedded devices, audio and video analysis and transcoding, cryptocurrencies, bioinformatics, search engines, Internet of Things applications, machine learning, and even major parts of the Firefox web browser.</source>
          <target state="translated">大小問わず、何百社もの企業が様々なタスクにRustを使用しています。これらのタスクには、コマンドライン ツール、ウェブ サービス、DevOps ツール、組み込みデバイス、オーディオおよびビデオの分析とトランスコーディング、暗号通貨、バイオインフォマティクス、検索エンジン、Internet of Things アプリケーション、機械学習、さらには Firefox ウェブ ブラウザの主要部分が含まれます。</target>
        </trans-unit>
        <trans-unit id="37906f8372f8c377be7b1e328309d3c4f609ea59" translate="yes" xml:space="preserve">
          <source>Hygiene</source>
          <target state="translated">Hygiene</target>
        </trans-unit>
        <trans-unit id="ad65c5b3b86039ac673217b5d774ea59d147e7b7" translate="yes" xml:space="preserve">
          <source>Hyperbolic cosine function.</source>
          <target state="translated">双曲余弦関数。</target>
        </trans-unit>
        <trans-unit id="c686c752760e59aa04f64bbe28ff2dbeca59fd00" translate="yes" xml:space="preserve">
          <source>Hyperbolic sine function.</source>
          <target state="translated">双曲線サイン関数。</target>
        </trans-unit>
        <trans-unit id="78df70baad8c07fe855fe47101a5902c14b1e359" translate="yes" xml:space="preserve">
          <source>Hyperbolic tangent function.</source>
          <target state="translated">双曲正接関数。</target>
        </trans-unit>
        <trans-unit id="bdf6cba1852f21a59de6863b8e6d7784db0851c8" translate="yes" xml:space="preserve">
          <source>I call it my billion-dollar mistake. At that time, I was designing the first comprehensive type system for references in an object-oriented language. My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldn&amp;rsquo;t resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.</source>
          <target state="translated">私はそれを10億ドルの間違いと呼んでいます。当時、オブジェクト指向言語での参照用の最初の包括的な型システムを設計していました。私の目標は、コンパイラーによって自動的に実行されるチェックにより、参照のすべての使用が絶対的に安全であることを確認することでした。しかし、実装が非常に簡単だったという理由だけで、null参照を挿入するという誘惑に抵抗できませんでした。これにより、無数のエラー、脆弱性、システムクラッシュが発生し、過去40年間で10億ドルの苦痛と損害を引き起こした可能性があります。</target>
        </trans-unit>
        <trans-unit id="e7c23cd87ff8917afb8c94f0de55718d338f0dac" translate="yes" xml:space="preserve">
          <source>IDE Integration Using the Rust Language Server</source>
          <target state="translated">Rust言語サーバーを使用したIDEの統合</target>
        </trans-unit>
        <trans-unit id="0e3b1f1fb38a7fe314d2f472da7f442366e6c3f3" translate="yes" xml:space="preserve">
          <source>IDENTIFIER</source>
          <target state="translated">IDENTIFIER</target>
        </trans-unit>
        <trans-unit id="55b1203af6cad8ae52e0d0a37f140db7910d8eda" translate="yes" xml:space="preserve">
          <source>IDENTIFIER :</source>
          <target state="translated">IDENTIFIER .</target>
        </trans-unit>
        <trans-unit id="c0fcd90425d895f40b307f4c7f56f5df18b1668f" translate="yes" xml:space="preserve">
          <source>IDENTIFIER_OR_KEYWORD :</source>
          <target state="translated">IDENTIFIER_OR_KEYWORD .</target>
        </trans-unit>
        <trans-unit id="b8dae77b24288c011d2b9b755b9a1a42811917e3" translate="yes" xml:space="preserve">
          <source>IEEE-754 very precisely specifies the bit layout of floats.</source>
          <target state="translated">IEEE-754では、floatのビットレイアウトが非常に正確に指定されています。</target>
        </trans-unit>
        <trans-unit id="1852814b8596efd4647ef533b868ea9c6f371594" translate="yes" xml:space="preserve">
          <source>IETF RFC 4291 section 2.4</source>
          <target state="translated">IETF RFC 4291 セクション 2.4</target>
        </trans-unit>
        <trans-unit id="aa0c0f5169dc17cce987a2ba8ef3419dba45ba72" translate="yes" xml:space="preserve">
          <source>IETF RFC 4291 section 2.5.6</source>
          <target state="translated">IETF RFC 4291 セクション 2.5.6</target>
        </trans-unit>
        <trans-unit id="bb6e7841dba2c83d7f4685d9f749f0a969927ab9" translate="yes" xml:space="preserve">
          <source>INFINITY</source>
          <target state="translated">INFINITY</target>
        </trans-unit>
        <trans-unit id="a1a3b8cc81502982ba95837302feb61e65dd8a3d" translate="yes" xml:space="preserve">
          <source>INNER_BLOCK_DOC :</source>
          <target state="translated">INNER_BLOCK_DOC .</target>
        </trans-unit>
        <trans-unit id="53a0430947a0edbae0af7f9e49d8f2dfe4e9afb4" translate="yes" xml:space="preserve">
          <source>INNER_LINE_DOC :</source>
          <target state="translated">INNER_LINE_DOC .</target>
        </trans-unit>
        <trans-unit id="cfbd240cfc0633423b9847728303e0a704bcd5d5" translate="yes" xml:space="preserve">
          <source>INTEGER_LITERAL</source>
          <target state="translated">INTEGER_LITERAL</target>
        </trans-unit>
        <trans-unit id="3f9135bee30f70c629387b1f17caf9d0de0eb83e" translate="yes" xml:space="preserve">
          <source>INTEGER_LITERAL :</source>
          <target state="translated">INTEGER_LITERAL .</target>
        </trans-unit>
        <trans-unit id="6371ddd611a0269a5bb8329b8b5ad2906b65b001" translate="yes" xml:space="preserve">
          <source>INTEGER_SUFFIX :</source>
          <target state="translated">INTEGER_SUFFIX .</target>
        </trans-unit>
        <trans-unit id="11cbb1f84a9535024b6452829b5548dd25b90335" translate="yes" xml:space="preserve">
          <source>IPv4 addresses are defined as 32-bit integers in &lt;a href=&quot;https://tools.ietf.org/html/rfc791&quot;&gt;IETF RFC 791&lt;/a&gt;. They are usually represented as four octets.</source>
          <target state="translated">IPv4アドレスは、&lt;a href=&quot;https://tools.ietf.org/html/rfc791&quot;&gt;IETF RFC 791&lt;/a&gt;で32ビット整数として定義されています。それらは通常4オクテットとして表されます。</target>
        </trans-unit>
        <trans-unit id="f61d67f908f166f992bd96ab7aae0433beeddddf" translate="yes" xml:space="preserve">
          <source>IPv4 socket addresses consist of an &lt;a href=&quot;struct.ipv4addr&quot;&gt;&lt;code&gt;IPv4&lt;/code&gt; address&lt;/a&gt; and a 16-bit port number, as stated in &lt;a href=&quot;https://tools.ietf.org/html/rfc793&quot;&gt;IETF RFC 793&lt;/a&gt;.</source>
          <target state="translated">IPv4ソケットアドレスは、&lt;a href=&quot;https://tools.ietf.org/html/rfc793&quot;&gt;IETF RFC 793に&lt;/a&gt;記載されているように、&lt;a href=&quot;struct.ipv4addr&quot;&gt; &lt;code&gt;IPv4&lt;/code&gt; アドレス&lt;/a&gt;と16ビットのポート番号で構成されます。</target>
        </trans-unit>
        <trans-unit id="125cc8de0dff730e4520fc003986c19a1b8554df" translate="yes" xml:space="preserve">
          <source>IPv4 socket addresses consist of an &lt;a href=&quot;struct.ipv4addr&quot;&gt;IPv4 address&lt;/a&gt; and a 16-bit port number, as stated in &lt;a href=&quot;https://tools.ietf.org/html/rfc793&quot;&gt;IETF RFC 793&lt;/a&gt;.</source>
          <target state="translated">IPv4ソケットアドレスは、&lt;a href=&quot;https://tools.ietf.org/html/rfc793&quot;&gt;IETF RFC 793で&lt;/a&gt;規定されているように、&lt;a href=&quot;struct.ipv4addr&quot;&gt;IPv4アドレス&lt;/a&gt;と16ビットのポート番号で構成されます。</target>
        </trans-unit>
        <trans-unit id="0fb594a9f230f62a93a2d236d355fee291f5f0ed" translate="yes" xml:space="preserve">
          <source>IPv6 addresses are defined as 128-bit integers in &lt;a href=&quot;https://tools.ietf.org/html/rfc4291&quot;&gt;IETF RFC 4291&lt;/a&gt;. They are usually represented as eight 16-bit segments.</source>
          <target state="translated">IPv6アドレスは、&lt;a href=&quot;https://tools.ietf.org/html/rfc4291&quot;&gt;IETF RFC 4291&lt;/a&gt;で128ビット整数として定義されています。通常、8つの16ビットセグメントとして表されます。</target>
        </trans-unit>
        <trans-unit id="9506a43966237e091295db561358da8326a23b09" translate="yes" xml:space="preserve">
          <source>IPv6 socket addresses consist of an &lt;a href=&quot;struct.ipv6addr&quot;&gt;&lt;code&gt;IPv6&lt;/code&gt; address&lt;/a&gt;, a 16-bit port number, as well as fields containing the traffic class, the flow label, and a scope identifier (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2553#section-3.3&quot;&gt;IETF RFC 2553, Section 3.3&lt;/a&gt; for more details).</source>
          <target state="translated">IPv6ソケットアドレスは、&lt;a href=&quot;struct.ipv6addr&quot;&gt; &lt;code&gt;IPv6&lt;/code&gt; アドレス&lt;/a&gt;、16ビットのポート番号、およびトラフィッククラス、フローラベル、スコープ識別子を含むフィールドで構成されます（詳細については、&lt;a href=&quot;https://tools.ietf.org/html/rfc2553#section-3.3&quot;&gt;IETF RFC 2553のセクション3.3&lt;/a&gt;を参照してください）。</target>
        </trans-unit>
        <trans-unit id="3a88c8ad7ac15b70173172e130a9df32e2c85f47" translate="yes" xml:space="preserve">
          <source>IPv6 socket addresses consist of an &lt;a href=&quot;struct.ipv6addr&quot;&gt;Ipv6 address&lt;/a&gt;, a 16-bit port number, as well as fields containing the traffic class, the flow label, and a scope identifier (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2553#section-3.3&quot;&gt;IETF RFC 2553, Section 3.3&lt;/a&gt; for more details).</source>
          <target state="translated">IPv6ソケットアドレスは、&lt;a href=&quot;struct.ipv6addr&quot;&gt;Ipv6アドレス&lt;/a&gt;、16ビットのポート番号、およびトラフィッククラス、フローラベル、スコープ識別子を含むフィールドで構成されます（詳細については、&lt;a href=&quot;https://tools.ietf.org/html/rfc2553#section-3.3&quot;&gt;IETF RFC 2553、セクション3.3&lt;/a&gt;を参照してください）。</target>
        </trans-unit>
        <trans-unit id="5e75cacea0fd3b6b14f0b4659c3bb43c233b1bc1" translate="yes" xml:space="preserve">
          <source>Identifier patterns</source>
          <target state="translated">識別パターン</target>
        </trans-unit>
        <trans-unit id="2871ae9886988ebe4584f71645f1cfa54c50fb26" translate="yes" xml:space="preserve">
          <source>Identifier patterns are irrefutable if the &lt;code&gt;@&lt;/code&gt; subpattern is irrefutable or the subpattern is not specified.</source>
          <target state="translated">&lt;code&gt;@&lt;/code&gt; サブパターンが反駁できない場合、またはサブパターンが指定されていない場合、識別子パターンは反駁できません。</target>
        </trans-unit>
        <trans-unit id="b14c125598d88502f5133a3afc5b567be6c1a2d3" translate="yes" xml:space="preserve">
          <source>Identifier patterns bind the value they match to a variable. The identifier must be unique within the pattern. The variable will shadow any variables of the same name in scope. The scope of the new binding depends on the context of where the pattern is used (such as a &lt;code&gt;let&lt;/code&gt; binding or a &lt;code&gt;match&lt;/code&gt; arm).</source>
          <target state="translated">識別子パターンは、一致する値を変数にバインドします。識別子はパターン内で一意である必要があります。変数は、スコープ内の同じ名前の変数をシャドウします。新しいバインディングのスコープは、パターンが使用されるコンテキスト（ &lt;code&gt;let&lt;/code&gt; バインディングや &lt;code&gt;match&lt;/code&gt; アームなど）によって異なります。</target>
        </trans-unit>
        <trans-unit id="649d2864df18704de32e689e69e63f2483e8b76e" translate="yes" xml:space="preserve">
          <source>Identifiers</source>
          <target state="translated">Identifiers</target>
        </trans-unit>
        <trans-unit id="a28f079910fa2727e597ae224c9f3f8cbc529307" translate="yes" xml:space="preserve">
          <source>Identify duplicate code.</source>
          <target state="translated">重複コードを識別します。</target>
        </trans-unit>
        <trans-unit id="9f0d27a694b397b392e1c0d4d2916d104a364051" translate="yes" xml:space="preserve">
          <source>If &amp;epsilon; &amp;isin; LAST(&lt;code&gt;uu ...&lt;/code&gt;), then LAST(M) = LAST(&lt;code&gt;tt&lt;/code&gt;) &amp;cup; (LAST(&lt;code&gt;uu ...&lt;/code&gt;) \ { &amp;epsilon; }).</source>
          <target state="translated">&lt;code&gt;uu ...&lt;/code&gt; （uu ...）の場合、LAST（M）= LAST（ &lt;code&gt;tt&lt;/code&gt; ）&amp;cup;（LAST（ &lt;code&gt;uu ...&lt;/code&gt; ）\ {&amp;epsilon;}）。</target>
        </trans-unit>
        <trans-unit id="96acc5da5a6cbbd203437fa84771d338d67204aa" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../struct.vecdeque#method.make_contiguous&quot;&gt;&lt;code&gt;make_contiguous&lt;/code&gt;&lt;/a&gt; was previously called, all elements of the &lt;code&gt;VecDeque&lt;/code&gt; will be in the first slice and the second slice will be empty.</source>
          <target state="translated">&lt;a href=&quot;../struct.vecdeque#method.make_contiguous&quot;&gt; &lt;code&gt;make_contiguous&lt;/code&gt; &lt;/a&gt;が以前に呼び出された場合、 &lt;code&gt;VecDeque&lt;/code&gt; のすべての要素が最初のスライスにあり、2番目のスライスは空になります。</target>
        </trans-unit>
        <trans-unit id="ed811da5d2f26e42527abd7d7393051a81f9fad7" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;struct.path#method.extension&quot;&gt;&lt;code&gt;self.extension&lt;/code&gt;&lt;/a&gt; is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, the extension is added; otherwise it is replaced.</source>
          <target state="translated">場合&lt;a href=&quot;struct.path#method.extension&quot;&gt; &lt;code&gt;self.extension&lt;/code&gt; は&lt;/a&gt;ありません&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;、拡張子が追加されます。それ以外の場合は置き換えられます。</target>
        </trans-unit>
        <trans-unit id="e801c0aa2cecddf4c1a1f7baf739c356c501f4d3" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;struct.path#method.file_name&quot;&gt;&lt;code&gt;self.file_name&lt;/code&gt;&lt;/a&gt; was &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, this is equivalent to pushing &lt;code&gt;file_name&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;struct.path#method.file_name&quot;&gt; &lt;code&gt;self.file_name&lt;/code&gt; &lt;/a&gt;が&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; の&lt;/a&gt;場合、これは &lt;code&gt;file_name&lt;/code&gt; をプッシュするのと同じです。</target>
        </trans-unit>
        <trans-unit id="534c6252638c1abdb91099e943245185bc915d7e" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;struct.pathbuf#method.extension&quot;&gt;&lt;code&gt;self.extension&lt;/code&gt;&lt;/a&gt; is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, the extension is added; otherwise it is replaced.</source>
          <target state="translated">場合&lt;a href=&quot;struct.pathbuf#method.extension&quot;&gt; &lt;code&gt;self.extension&lt;/code&gt; は&lt;/a&gt;ありません&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;、拡張子が追加されます。それ以外の場合は置き換えられます。</target>
        </trans-unit>
        <trans-unit id="01a2757701a9695cb15304f9062c5f6fe543e1d0" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;struct.pathbuf#method.file_name&quot;&gt;&lt;code&gt;self.file_name&lt;/code&gt;&lt;/a&gt; was &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, this is equivalent to pushing &lt;code&gt;file_name&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;struct.pathbuf#method.file_name&quot;&gt; &lt;code&gt;self.file_name&lt;/code&gt; &lt;/a&gt;が&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; の&lt;/a&gt;場合、これは &lt;code&gt;file_name&lt;/code&gt; をプッシュすることと同じです。</target>
        </trans-unit>
        <trans-unit id="29376b60b0b5a1ec52b8a24373266c830da3ba88" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;struct.vecdeque#method.make_contiguous&quot;&gt;&lt;code&gt;make_contiguous&lt;/code&gt;&lt;/a&gt; was previously called, all elements of the &lt;code&gt;VecDeque&lt;/code&gt; will be in the first slice and the second slice will be empty.</source>
          <target state="translated">&lt;a href=&quot;struct.vecdeque#method.make_contiguous&quot;&gt; &lt;code&gt;make_contiguous&lt;/code&gt; &lt;/a&gt;が以前に呼び出された場合、 &lt;code&gt;VecDeque&lt;/code&gt; のすべての要素が最初のスライスにあり、2番目のスライスは空になります。</target>
        </trans-unit>
        <trans-unit id="4087b2407c0523ab27c22d69edd0438fe2e50815" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;'static&lt;/code&gt; is used for any lifetime bound then &lt;code&gt;'static&lt;/code&gt; is used.</source>
          <target state="translated">ライフタイムバウンドに &lt;code&gt;'static&lt;/code&gt; が使用されて &lt;code&gt;'static&lt;/code&gt; 場合、「静的」が使用されます。</target>
        </trans-unit>
        <trans-unit id="2299b8f75754da8b24aff81fd36ddb6f9ef90ec2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;..&lt;/code&gt; is not used, it is required to match all fields:</source>
          <target state="translated">&lt;code&gt;..&lt;/code&gt; を使用しない場合は、すべてのフィールドを照合する必要があります。</target>
        </trans-unit>
        <trans-unit id="f3b5be9d19759c8147145d2b3c53249ad84a368f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;.create_new(true)&lt;/code&gt; is set, &lt;a href=&quot;#method.create&quot;&gt;&lt;code&gt;.create()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.truncate&quot;&gt;&lt;code&gt;.truncate()&lt;/code&gt;&lt;/a&gt; are ignored.</source>
          <target state="translated">場合 &lt;code&gt;.create_new(true)&lt;/code&gt; に設定され、&lt;a href=&quot;#method.create&quot;&gt; &lt;code&gt;.create()&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;#method.truncate&quot;&gt; &lt;code&gt;.truncate()&lt;/code&gt; は&lt;/a&gt;無視されます。</target>
        </trans-unit>
        <trans-unit id="29bc21e0c15798e73a6dbc2093728d2f6a268b72" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;.create_new(true)&lt;/code&gt; is set, &lt;a href=&quot;struct.openoptions#method.create&quot;&gt;&lt;code&gt;.create()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.openoptions#method.truncate&quot;&gt;&lt;code&gt;.truncate()&lt;/code&gt;&lt;/a&gt; are ignored.</source>
          <target state="translated">場合 &lt;code&gt;.create_new(true)&lt;/code&gt; に設定され、&lt;a href=&quot;struct.openoptions#method.create&quot;&gt; &lt;code&gt;.create()&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;struct.openoptions#method.truncate&quot;&gt; &lt;code&gt;.truncate()&lt;/code&gt; は&lt;/a&gt;無視されます。</target>
        </trans-unit>
        <trans-unit id="2ad0cab5b7af8f6f0d802cf376de0871197cd2fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Complete&lt;/code&gt; is returned then the generator has completely finished with the value provided. It is invalid for the generator to be resumed again.</source>
          <target state="translated">場合は &lt;code&gt;Complete&lt;/code&gt; ISが返された後、発電機は完全に提供された値で終了しました。ジェネレーターが再び再開されることは無効です。</target>
        </trans-unit>
        <trans-unit id="ac903d4e63c4f5e9053aaefd66eff84df6124016" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ForeignTrait&lt;/code&gt; is a trait defined in some external crate &lt;code&gt;foo&lt;/code&gt;, then the following trait &lt;code&gt;impl&lt;/code&gt; is an error:</source>
          <target state="translated">場合 &lt;code&gt;ForeignTrait&lt;/code&gt; は、いくつかの外部のクレートの中で定義された形質である &lt;code&gt;foo&lt;/code&gt; 、次の特性 &lt;code&gt;impl&lt;/code&gt; のエラーです：</target>
        </trans-unit>
        <trans-unit id="c1fd05b3bcfcb4d8ea20c271d94557cb3d13d52d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Hello, world!&lt;/code&gt; did print, congratulations! You&amp;rsquo;ve officially written a Rust program. That makes you a Rust programmer&amp;mdash;welcome!</source>
          <target state="translated">もし &lt;code&gt;Hello, world!&lt;/code&gt; おめでとうございます！Rustプログラムを正式に作成しました。これでRustプログラマになります。ようこそ！</target>
        </trans-unit>
        <trans-unit id="7eb14007d446b8ddd9ae89463ae1a1d31374e8ad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;N&lt;/code&gt; is greater than the size of the slice, it will return no windows.</source>
          <target state="translated">場合 &lt;code&gt;N&lt;/code&gt; はスライスのサイズよりも大きい場合、それには窓を返しません。</target>
        </trans-unit>
        <trans-unit id="11ac605f741ebf773252ac24fa49e72ab712c9a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T: Drop&lt;/code&gt;, calling &lt;a href=&quot;../std/ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;&amp;lt;T as std::ops::Drop&amp;gt;::drop&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;T: Drop&lt;/code&gt; 場合、&lt;a href=&quot;../std/ops/trait.drop#tymethod.drop&quot;&gt; &lt;code&gt;&amp;lt;T as std::ops::Drop&amp;gt;::drop&lt;/code&gt; &lt;/a&gt;呼び出します</target>
        </trans-unit>
        <trans-unit id="2c3c7b96cb91a4bbdb1b6896643ea9e9a3c22921" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; also implements &lt;code&gt;Eq&lt;/code&gt; (implying reflexivity of equality), two &lt;code&gt;Arc&lt;/code&gt;s that point to the same allocation are always equal.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; が &lt;code&gt;Eq&lt;/code&gt; （等式の再帰性を意味する）も実装する場合、同じ割り当てを指す2つの &lt;code&gt;Arc&lt;/code&gt; は常に等しくなります。</target>
        </trans-unit>
        <trans-unit id="eeac29050d6596e7248fbdb56f4b4514db570609" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; also implements &lt;code&gt;Eq&lt;/code&gt; (implying reflexivity of equality), two &lt;code&gt;Arc&lt;/code&gt;s that point to the same value are never unequal.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; が &lt;code&gt;Eq&lt;/code&gt; （等式の再帰性を意味する）も実装している場合、同じ値を指す2つの &lt;code&gt;Arc&lt;/code&gt; が等しくないことはありません。</target>
        </trans-unit>
        <trans-unit id="37e2b122febd728f5d8f178462e020b9f40dc3b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; also implements &lt;code&gt;Eq&lt;/code&gt; (implying reflexivity of equality), two &lt;code&gt;Rc&lt;/code&gt;s that point to the same allocation are always equal.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; が &lt;code&gt;Eq&lt;/code&gt; （等式の再帰性を意味する）も実装する場合、同じ割り当てを指す2つの &lt;code&gt;Rc&lt;/code&gt; は常に等しくなります。</target>
        </trans-unit>
        <trans-unit id="39a40f9d20e095dacb94b9b37bf7db5ad95d17e9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; also implements &lt;code&gt;Eq&lt;/code&gt; (implying reflexivity of equality), two &lt;code&gt;Rc&lt;/code&gt;s that point to the same allocation are never unequal.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; も &lt;code&gt;Eq&lt;/code&gt; （等式の再帰性を意味する）を実装する場合、同じ割り当てを指す2つの &lt;code&gt;Rc&lt;/code&gt; が等しくなることはありません。</target>
        </trans-unit>
        <trans-unit id="5b6043d2d9c915604d4623e46635d9a9a232a5d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; also implements &lt;code&gt;Eq&lt;/code&gt;, two &lt;code&gt;Arc&lt;/code&gt;s that point to the same value are always equal.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; が &lt;code&gt;Eq&lt;/code&gt; も実装する場合、同じ値を指す2つの &lt;code&gt;Arc&lt;/code&gt; は常に等しくなります。</target>
        </trans-unit>
        <trans-unit id="ec82a111c6092884516e8540e107bb1534de81bd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; also implements &lt;code&gt;Eq&lt;/code&gt;, two &lt;code&gt;Arc&lt;/code&gt;s that point to the same value are never unequal.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; が &lt;code&gt;Eq&lt;/code&gt; も実装する場合、同じ値を指す2つの &lt;code&gt;Arc&lt;/code&gt; が等しくなることはありません。</target>
        </trans-unit>
        <trans-unit id="21cc57c8697439642e0504b016521d59698b000c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; also implements &lt;code&gt;Eq&lt;/code&gt;, two &lt;code&gt;Rc&lt;/code&gt;s that point to the same value are always equal.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; が &lt;code&gt;Eq&lt;/code&gt; も実装する場合、同じ値を指す2つの &lt;code&gt;Rc&lt;/code&gt; は常に等しくなります。</target>
        </trans-unit>
        <trans-unit id="79dd19ff096e35ccdc8e2994890606a0f2b80c5b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; also implements &lt;code&gt;Eq&lt;/code&gt;, two &lt;code&gt;Rc&lt;/code&gt;s that point to the same value are never unequal.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; が &lt;code&gt;Eq&lt;/code&gt; も実装する場合、同じ値を指す2つの &lt;code&gt;Rc&lt;/code&gt; が等しくなることはありません。</target>
        </trans-unit>
        <trans-unit id="f0097c8e2ff22a2b90e167d6c061fa3e59f58a62" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; does not implement &lt;code&gt;Copy&lt;/code&gt;, use &lt;a href=&quot;#method.clone_from_slice&quot;&gt;&lt;code&gt;clone_from_slice&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; が &lt;code&gt;Copy&lt;/code&gt; 実装していない場合は、&lt;a href=&quot;#method.clone_from_slice&quot;&gt; &lt;code&gt;clone_from_slice&lt;/code&gt; を&lt;/a&gt;使用します。</target>
        </trans-unit>
        <trans-unit id="26c4dc3d013511006bc6b284a2d4db3c7148b968" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; implements &lt;code&gt;Copy&lt;/code&gt;, it can be more performant to use &lt;a href=&quot;#method.copy_from_slice&quot;&gt;&lt;code&gt;copy_from_slice&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; が &lt;code&gt;Copy&lt;/code&gt; を実装している場合は、&lt;a href=&quot;#method.copy_from_slice&quot;&gt; &lt;code&gt;copy_from_slice&lt;/code&gt; &lt;/a&gt;を使用するとパフォーマンスが向上する可能性があります。</target>
        </trans-unit>
        <trans-unit id="2aad32f156303fc5a2bc63ee3fa5dad5cc0ca6bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; implements &lt;code&gt;Deref&amp;lt;Target = U&amp;gt;&lt;/code&gt;, and &lt;code&gt;x&lt;/code&gt; is a value of type &lt;code&gt;T&lt;/code&gt;, then:</source>
          <target state="translated">もし &lt;code&gt;T&lt;/code&gt; の実装 &lt;code&gt;Deref&amp;lt;Target = U&amp;gt;&lt;/code&gt; 、および &lt;code&gt;x&lt;/code&gt; 型の値であり、 &lt;code&gt;T&lt;/code&gt; は、その後：</target>
        </trans-unit>
        <trans-unit id="95d72afe0884b2306850bd095670df15024528ce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; implements &lt;code&gt;DerefMut&amp;lt;Target = U&amp;gt;&lt;/code&gt;, and &lt;code&gt;x&lt;/code&gt; is a value of type &lt;code&gt;T&lt;/code&gt;, then:</source>
          <target state="translated">もし &lt;code&gt;T&lt;/code&gt; の実装 &lt;code&gt;DerefMut&amp;lt;Target = U&amp;gt;&lt;/code&gt; 、および &lt;code&gt;x&lt;/code&gt; 型の値であり、 &lt;code&gt;T&lt;/code&gt; は、その後：</target>
        </trans-unit>
        <trans-unit id="23971030fbeb1cad27f55d0399b6d51a892fe825" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Sized&lt;/code&gt;, this function is always safe to call.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; が &lt;code&gt;Sized&lt;/code&gt; 場合、この関数は常に安全に呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="8b6c90a17aa05dcdf98932b5f27171dbd2de33f3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is FFI-safe, then so is &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; がFFIセーフであれば、 &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="49964ef73f44405d2ac7053108ae2569108b6abf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is not an enum, calling this function will not result in undefined behavior, but the return value is unspecified.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; が列挙型でない場合、この関数を呼び出しても未定義の動作は発生しませんが、戻り値は不定です。</target>
        </trans-unit>
        <trans-unit id="8dca1b3ef01a1ffebdb81541f8580fb6c5190017" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is not an enum, calling this function will not result in undefined behavior, but the return value is unspecified. Equally, if &lt;code&gt;T&lt;/code&gt; is an enum with more variants than &lt;code&gt;usize::MAX&lt;/code&gt; the return value is unspecified. Uninhabited variants will be counted.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; が列挙型でない場合、この関数を呼び出しても未定義の動作は発生しませんが、戻り値は指定されていません。同様に、 &lt;code&gt;T&lt;/code&gt; が &lt;code&gt;usize::MAX&lt;/code&gt; よりも多くのバリアントを持つ列挙型である場合、戻り値は指定されていません。無人の亜種がカウントされます。</target>
        </trans-unit>
        <trans-unit id="70442d0f7a75e13703c9f3f655e0ebf8ba235584" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Ti&lt;/code&gt; can be coerced to the current target type &lt;code&gt;T_t&lt;/code&gt;, then no change is made.</source>
          <target state="translated">&lt;code&gt;Ti&lt;/code&gt; を現在のターゲットタイプ &lt;code&gt;T_t&lt;/code&gt; に強制変換できる場合、変更は行われません。</target>
        </trans-unit>
        <trans-unit id="f81fb6d8ced60b0cd6b321f060ac68460468aa0c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;addr&lt;/code&gt; yields multiple addresses, &lt;code&gt;bind&lt;/code&gt; will be attempted with each of the addresses until one succeeds and returns the listener. If none of the addresses succeed in creating a listener, the error returned from the last attempt (the last address) is returned.</source>
          <target state="translated">&lt;code&gt;addr&lt;/code&gt; が複数のアドレスを生成する場合、いずれかが成功してリスナーを返すまで、各アドレスで &lt;code&gt;bind&lt;/code&gt; が試行されます。リスナーの作成に成功したアドレスがない場合は、最後の試行から返されたエラー（最後のアドレス）が返されます。</target>
        </trans-unit>
        <trans-unit id="7f3c01a32008b38d419c728226a54e01a7d962fe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;addr&lt;/code&gt; yields multiple addresses, &lt;code&gt;bind&lt;/code&gt; will be attempted with each of the addresses until one succeeds and returns the socket. If none of the addresses succeed in creating a socket, the error returned from the last attempt (the last address) is returned.</source>
          <target state="translated">&lt;code&gt;addr&lt;/code&gt; が複数のアドレスを生成する場合、いずれかが成功してソケットを返すまで、各アドレスで &lt;code&gt;bind&lt;/code&gt; が試行されます。ソケットの作成に成功したアドレスがない場合、最後の試行（最後のアドレス）から返されたエラーが返されます。</target>
        </trans-unit>
        <trans-unit id="0c53eddc64c1e675eb29f0974efda41f4b33efd1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;addr&lt;/code&gt; yields multiple addresses, &lt;code&gt;connect&lt;/code&gt; will be attempted with each of the addresses until a connection is successful. If none of the addresses result in a successful connection, the error returned from the last connection attempt (the last address) is returned.</source>
          <target state="translated">&lt;code&gt;addr&lt;/code&gt; が複数のアドレスを生成する場合、接続が成功するまで、各アドレスで &lt;code&gt;connect&lt;/code&gt; が試行されます。どのアドレスも接続が成功しない場合は、最後の接続試行から返されたエラー（最後のアドレス）が返されます。</target>
        </trans-unit>
        <trans-unit id="07f5c20249e5fa3260da27a7df45155885f3dd08" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;addr&lt;/code&gt; yields multiple addresses, &lt;code&gt;connect&lt;/code&gt; will be attempted with each of the addresses until the underlying OS function returns no error. Note that usually, a successful &lt;code&gt;connect&lt;/code&gt; call does not specify that there is a remote server listening on the port, rather, such an error would only be detected after the first send. If the OS returns an error for each of the specified addresses, the error returned from the last connection attempt (the last address) is returned.</source>
          <target state="translated">&lt;code&gt;addr&lt;/code&gt; が複数のアドレスを生成する場合、基になるOS関数がエラーを返さなくなるまで、各アドレスで &lt;code&gt;connect&lt;/code&gt; が試行されます。通常、成功した &lt;code&gt;connect&lt;/code&gt; 呼び出しは、ポートでリッスンしているリモートサーバーがあることを指定せず、そのようなエラーは最初の送信後にのみ検出されることに注意してください。指定されたアドレスごとにOSがエラーを返す場合、最後の接続試行から返されたエラー（最後のアドレス）が返されます。</target>
        </trans-unit>
        <trans-unit id="acfc45781f88c4761baec8897c0ca4cf03d5120d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;base&lt;/code&gt; is not a prefix of &lt;code&gt;self&lt;/code&gt; (i.e., &lt;a href=&quot;#method.starts_with&quot;&gt;&lt;code&gt;starts_with&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;false&lt;/code&gt;), returns &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;base&lt;/code&gt; が &lt;code&gt;self&lt;/code&gt; プレフィックスでない場合（つまり、&lt;a href=&quot;#method.starts_with&quot;&gt; &lt;code&gt;starts_with&lt;/code&gt; &lt;/a&gt;が &lt;code&gt;false&lt;/code&gt; を返す）、&lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; を&lt;/a&gt;返します。</target>
        </trans-unit>
        <trans-unit id="c33668a2d69ed6be4cc49feb7054f832229cf3a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;base&lt;/code&gt; is not a prefix of &lt;code&gt;self&lt;/code&gt; (i.e., &lt;a href=&quot;struct.path#method.starts_with&quot;&gt;&lt;code&gt;starts_with&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;false&lt;/code&gt;), returns &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;base&lt;/code&gt; が &lt;code&gt;self&lt;/code&gt; のプレフィックスでない場合（つまり、&lt;a href=&quot;struct.path#method.starts_with&quot;&gt; &lt;code&gt;starts_with&lt;/code&gt; &lt;/a&gt;は &lt;code&gt;false&lt;/code&gt; を返します）、&lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; を&lt;/a&gt;返します。</target>
        </trans-unit>
        <trans-unit id="1b461fd46fdb1045defa6bb08692a4c2d8f4230a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; start with the bytes in &lt;code&gt;get&lt;/code&gt;, it means we&amp;rsquo;ve received some other request. We&amp;rsquo;ll add code to the &lt;code&gt;else&lt;/code&gt; block in a moment to respond to all other requests.</source>
          <target state="translated">&lt;code&gt;buffer&lt;/code&gt; が &lt;code&gt;get&lt;/code&gt; のバイトで始まってい&lt;em&gt;ない&lt;/em&gt;場合は、他のリクエストを受け取ったことを意味します。 &lt;code&gt;else&lt;/code&gt; ブロックにコードを追加して、他のすべてのリクエストに応答します。</target>
        </trans-unit>
        <trans-unit id="65de2dbca56069ac5ddb30aad7c8e3292f2e853a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; panics, the panic is propagated to the caller, and the cell remains uninitialized.</source>
          <target state="translated">場合は &lt;code&gt;f&lt;/code&gt; パニック、パニックを呼び出し側に伝播し、そして細胞が初期化されていないままです。</target>
        </trans-unit>
        <trans-unit id="f00643b3b6dd6ef6ea56050255f61c8e0b9bb9ce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;func&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; for the next value of this iterator, consume and return it. Otherwise, return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;func&lt;/code&gt; が返す &lt;code&gt;true&lt;/code&gt; 反復子の次の値のため、消費し、それを返します。それ以外の場合は、 &lt;code&gt;None&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="bb805fab8234f3a9b02923cee55ae95cc32673cc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;k&lt;/code&gt; is greater than &lt;code&gt;len()&lt;/code&gt;. Note that &lt;code&gt;k == len()&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; panic and is a no-op rotation.</source>
          <target state="translated">&lt;code&gt;k&lt;/code&gt; が &lt;code&gt;len()&lt;/code&gt; より大きい場合。 &lt;code&gt;k == len()&lt;/code&gt; はパニックに&lt;em&gt;ならず&lt;/em&gt;、何もしないローテーションであることに注意してください。</target>
        </trans-unit>
        <trans-unit id="f9e7bcd447817a79430b03e0a66dfa67f1d0816a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len&lt;/code&gt; is greater than the &lt;code&gt;VecDeque&lt;/code&gt;'s current length, this has no effect.</source>
          <target state="translated">&lt;code&gt;len&lt;/code&gt; が &lt;code&gt;VecDeque&lt;/code&gt; の現在の長さより大きい場合、これは効果がありません。</target>
        </trans-unit>
        <trans-unit id="3d4f7e3b9010f5f85b09ea6a7879139a55bd516a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len&lt;/code&gt; is greater than the vector's current length, this has no effect.</source>
          <target state="translated">&lt;code&gt;len&lt;/code&gt; がベクトルの現在の長さより大きい場合、これは効果がありません。</target>
        </trans-unit>
        <trans-unit id="1cf8419e86a3170a30c5b069909ed1f0302b608f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;mid&lt;/code&gt; is greater than &lt;code&gt;len()&lt;/code&gt;. Note that &lt;code&gt;mid == len()&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; panic and is a no-op rotation.</source>
          <target state="translated">&lt;code&gt;mid&lt;/code&gt; が &lt;code&gt;len()&lt;/code&gt; より大きい場合。 &lt;code&gt;mid == len()&lt;/code&gt; はパニックに&lt;em&gt;ならず&lt;/em&gt;、何もしないローテーションであることに注意してください。</target>
        </trans-unit>
        <trans-unit id="5a6e0913f28771cf69b8d16954b1cc061c4e770a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; substrings are returned, the last substring (the &lt;code&gt;n&lt;/code&gt;th substring) will contain the remainder of the string.</source>
          <target state="translated">場合 &lt;code&gt;n&lt;/code&gt; サブストリングが返され、最後のサブストリング（ &lt;code&gt;n&lt;/code&gt; 番目のサブストリング）は、文字列の残りの部分を含むであろう。</target>
        </trans-unit>
        <trans-unit id="705ee37ce1f2981d5872c521c36f0e77f17b6dcb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_len&lt;/code&gt; is greater than &lt;code&gt;len&lt;/code&gt;, the &lt;code&gt;Vec&lt;/code&gt; is extended by the difference, with each additional slot filled with &lt;a href=&quot;../default/trait.default#tymethod.default&quot;&gt;&lt;code&gt;Default::default()&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;new_len&lt;/code&gt; is less than &lt;code&gt;len&lt;/code&gt;, the &lt;code&gt;Vec&lt;/code&gt; is simply truncated.</source>
          <target state="translated">&lt;code&gt;new_len&lt;/code&gt; が &lt;code&gt;len&lt;/code&gt; より大きい場合、 &lt;code&gt;Vec&lt;/code&gt; はその差によって拡張され、追加の各スロットは&lt;a href=&quot;../default/trait.default#tymethod.default&quot;&gt; &lt;code&gt;Default::default()&lt;/code&gt; &lt;/a&gt;埋められます。 &lt;code&gt;new_len&lt;/code&gt; が &lt;code&gt;len&lt;/code&gt; より小さい場合、 &lt;code&gt;Vec&lt;/code&gt; は単に切り捨てられます。</target>
        </trans-unit>
        <trans-unit id="ad28de2b804b7bf236f81edae0db607218d0ac6e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_len&lt;/code&gt; is greater than &lt;code&gt;len&lt;/code&gt;, the &lt;code&gt;Vec&lt;/code&gt; is extended by the difference, with each additional slot filled with &lt;code&gt;value&lt;/code&gt;. If &lt;code&gt;new_len&lt;/code&gt; is less than &lt;code&gt;len&lt;/code&gt;, the &lt;code&gt;Vec&lt;/code&gt; is simply truncated.</source>
          <target state="translated">&lt;code&gt;new_len&lt;/code&gt; が &lt;code&gt;len&lt;/code&gt; より大きい場合、 &lt;code&gt;Vec&lt;/code&gt; は差によって拡張され、追加の各スロットは &lt;code&gt;value&lt;/code&gt; で埋められます。 &lt;code&gt;new_len&lt;/code&gt; が &lt;code&gt;len&lt;/code&gt; より小さい場合、 &lt;code&gt;Vec&lt;/code&gt; は単に切り捨てられます。</target>
        </trans-unit>
        <trans-unit id="c6a8aec540c240a392d0120d56829bf27ca15fcc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_len&lt;/code&gt; is greater than &lt;code&gt;len&lt;/code&gt;, the &lt;code&gt;Vec&lt;/code&gt; is extended by the difference, with each additional slot filled with the result of calling the closure &lt;code&gt;f&lt;/code&gt;. The return values from &lt;code&gt;f&lt;/code&gt; will end up in the &lt;code&gt;Vec&lt;/code&gt; in the order they have been generated.</source>
          <target state="translated">&lt;code&gt;new_len&lt;/code&gt; が &lt;code&gt;len&lt;/code&gt; より大きい場合、 &lt;code&gt;Vec&lt;/code&gt; はその差によって拡張され、追加の各スロットは、クロージャー &lt;code&gt;f&lt;/code&gt; を呼び出した結果で埋められます。以下からの戻り値 &lt;code&gt;f&lt;/code&gt; がでてしまいます &lt;code&gt;Vec&lt;/code&gt; を、彼らが生成された順に。</target>
        </trans-unit>
        <trans-unit id="57261354a67401e0b42f57fdd95ec00fffeda84c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_len&lt;/code&gt; is greater than the string's current length, this has no effect.</source>
          <target state="translated">&lt;code&gt;new_len&lt;/code&gt; が文字列の現在の長さより大きい場合、これは効果がありません。</target>
        </trans-unit>
        <trans-unit id="8e6148a2ee667e899f4bb89c993862e7efe20971" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_len&lt;/code&gt; is less than &lt;code&gt;len&lt;/code&gt;, the &lt;code&gt;Vec&lt;/code&gt; is simply truncated.</source>
          <target state="translated">&lt;code&gt;new_len&lt;/code&gt; が &lt;code&gt;len&lt;/code&gt; より小さい場合、 &lt;code&gt;Vec&lt;/code&gt; は単に切り捨てられます。</target>
        </trans-unit>
        <trans-unit id="abb4fe85675ce478754ece04841053fa5e5c6a3e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;num&lt;/code&gt; had been &lt;code&gt;Some(10)&lt;/code&gt; instead, the match guard in the first arm would have been false because 10 is not less than 5. Rust would then go to the second arm, which would match because the second arm doesn&amp;rsquo;t have a match guard and therefore matches any &lt;code&gt;Some&lt;/code&gt; variant.</source>
          <target state="translated">場合 &lt;code&gt;num&lt;/code&gt; がされていた &lt;code&gt;Some(10)&lt;/code&gt; の代わりに、第一のアームで一致ガードがあったであろう偽10は錆が第2アームが持っていないため、一致しており、第2のアームに行くだろうではない5未満であるため、ガードを一致させるため、 &lt;code&gt;Some&lt;/code&gt; バリアントと一致します。</target>
        </trans-unit>
        <trans-unit id="b32b62b97ea86132915f7572c0fc7127777250a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;parse&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; able to turn the string into a number, it will return an &lt;code&gt;Err&lt;/code&gt; value that contains more information about the error. The &lt;code&gt;Err&lt;/code&gt; value does not match the &lt;code&gt;Ok(num)&lt;/code&gt; pattern in the first &lt;code&gt;match&lt;/code&gt; arm, but it does match the &lt;code&gt;Err(_)&lt;/code&gt; pattern in the second arm. The underscore, &lt;code&gt;_&lt;/code&gt;, is a catchall value; in this example, we&amp;rsquo;re saying we want to match all &lt;code&gt;Err&lt;/code&gt; values, no matter what information they have inside them. So the program will execute the second arm&amp;rsquo;s code, &lt;code&gt;continue&lt;/code&gt;, which tells the program to go to the next iteration of the &lt;code&gt;loop&lt;/code&gt; and ask for another guess. So, effectively, the program ignores all errors that &lt;code&gt;parse&lt;/code&gt; might encounter!</source>
          <target state="translated">&lt;code&gt;parse&lt;/code&gt; が文字列を数値に変換でき&lt;em&gt;ない&lt;/em&gt;場合、エラーに関する詳細を含む &lt;code&gt;Err&lt;/code&gt; 値を返します。 &lt;code&gt;Err&lt;/code&gt; の値が一致しない &lt;code&gt;Ok(num)&lt;/code&gt; 最初のパターン &lt;code&gt;match&lt;/code&gt; アームを、それが一致しない &lt;code&gt;Err(_)&lt;/code&gt; 第二のアーム内にパターンを。アンダースコア &lt;code&gt;_&lt;/code&gt; は包括的な値です。この例では、内部にどんな情報があっても、すべての &lt;code&gt;Err&lt;/code&gt; 値に一致させたいと言っています。したがって、プログラムは2番目のアームのコード &lt;code&gt;continue&lt;/code&gt; を実行し、 &lt;code&gt;loop&lt;/code&gt; 次の反復に進むようにプログラムに指示しますそして別の推測を求めます。つまり、プログラムは、 &lt;code&gt;parse&lt;/code&gt; 発生する可能性のあるすべてのエラーを無視します。</target>
        </trans-unit>
        <trans-unit id="40e42a10c4724a12b9d742d659e990cc0a90590e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;parse&lt;/code&gt; is able to successfully turn the string into a number, it will return an &lt;code&gt;Ok&lt;/code&gt; value that contains the resulting number. That &lt;code&gt;Ok&lt;/code&gt; value will match the first arm&amp;rsquo;s pattern, and the &lt;code&gt;match&lt;/code&gt; expression will just return the &lt;code&gt;num&lt;/code&gt; value that &lt;code&gt;parse&lt;/code&gt; produced and put inside the &lt;code&gt;Ok&lt;/code&gt; value. That number will end up right where we want it in the new &lt;code&gt;guess&lt;/code&gt; variable we&amp;rsquo;re creating.</source>
          <target state="translated">&lt;code&gt;parse&lt;/code&gt; が文字列を数値に正常に変換できる場合、結果の数値を含む &lt;code&gt;Ok&lt;/code&gt; 値を返します。その &lt;code&gt;Ok&lt;/code&gt; 値は最初のアームのパターンに &lt;code&gt;match&lt;/code&gt; し、一致式は、 &lt;code&gt;parse&lt;/code&gt; によって生成され、 &lt;code&gt;Ok&lt;/code&gt; 値の中に置かれた &lt;code&gt;num&lt;/code&gt; 値を返すだけです。その数は、作成する新しい &lt;code&gt;guess&lt;/code&gt; 変数で必要な場所に正しく配置されます。</target>
        </trans-unit>
        <trans-unit id="a78bf9200d69e40c9e7de71399af9b041b718f05" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is absolute, it replaces the current path.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; が絶対パスの場合、現在のパスを置き換えます。</target>
        </trans-unit>
        <trans-unit id="73e4e153f655353974f6e6f2c813b5b3915ef1cc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pointer&lt;/code&gt; dereferences to an &lt;code&gt;Unpin&lt;/code&gt; type, &lt;code&gt;Pin::new&lt;/code&gt; should be used instead.</source>
          <target state="translated">&lt;code&gt;pointer&lt;/code&gt; &lt;code&gt;Unpin&lt;/code&gt; タイプを参照解除する場合は、代わりに &lt;code&gt;Pin::new&lt;/code&gt; を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="ac86606be8e832102840dbcc4086a1857a76012b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;program&lt;/code&gt; is not an absolute path, the &lt;code&gt;PATH&lt;/code&gt; will be searched in an OS-defined way.</source>
          <target state="translated">&lt;code&gt;program&lt;/code&gt; が絶対パスでない場合、 &lt;code&gt;PATH&lt;/code&gt; はOS定義の方法で検索されます。</target>
        </trans-unit>
        <trans-unit id="a98fb4db9993bb6b25528d614208eeeedcf64c3a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self &amp;lt;= other&lt;/code&gt;: &lt;code&gt;0:0&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;self &amp;lt;= other&lt;/code&gt; 場合： &lt;code&gt;0:0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="822bf36472f08b6c870c4a7eb729d5b79300c331" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self.value&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, the code calls the closure stored in &lt;code&gt;self.calculation&lt;/code&gt;, saves the result in &lt;code&gt;self.value&lt;/code&gt; for future use, and returns the value as well.</source>
          <target state="translated">場合 &lt;code&gt;self.value&lt;/code&gt; はありません &lt;code&gt;None&lt;/code&gt; 、コードがに保存されている閉鎖呼び出す &lt;code&gt;self.calculation&lt;/code&gt; を、で結果を保存し &lt;code&gt;self.value&lt;/code&gt; 、将来の使用のために、とだけでなく、値を返します。</target>
        </trans-unit>
        <trans-unit id="0f62f6b36639e7064e0402d98d3c38179c58dd42" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; already meets the prescribed alignment, then returns &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; すでに所定の配置を満たしている場合は、 &lt;code&gt;self&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="d19aaaae1a7aca6f98e6ea7cfd2e6a369fd25fbf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; is &lt;code&gt;Some(s)&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; is &lt;code&gt;Some(o)&lt;/code&gt;, this method returns &lt;code&gt;Some((s, o))&lt;/code&gt;. Otherwise, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="translated">場合 &lt;code&gt;self&lt;/code&gt; がある &lt;code&gt;Some(s)&lt;/code&gt; 及び &lt;code&gt;other&lt;/code&gt; ある &lt;code&gt;Some(o)&lt;/code&gt; 、このメソッドの戻り &lt;code&gt;Some((s, o))&lt;/code&gt; 。それ以外の場合は、 &lt;code&gt;None&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="9687d508d768393d6014b090a450d643c5917f35" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; is &lt;code&gt;Some(s)&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; is &lt;code&gt;Some(o)&lt;/code&gt;, this method returns &lt;code&gt;Some(f(s, o))&lt;/code&gt;. Otherwise, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="translated">場合 &lt;code&gt;self&lt;/code&gt; がある &lt;code&gt;Some(s)&lt;/code&gt; 及び &lt;code&gt;other&lt;/code&gt; ある &lt;code&gt;Some(o)&lt;/code&gt; 、このメソッドの戻り &lt;code&gt;Some(f(s, o))&lt;/code&gt; 。それ以外の場合は、 &lt;code&gt;None&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="14fb52988b52fdaf20fd6eb41395b17915e1caaa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; was created using &lt;a href=&quot;#method.new&quot;&gt;&lt;code&gt;Weak::new&lt;/code&gt;&lt;/a&gt;, this will return 0.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; が&lt;a href=&quot;#method.new&quot;&gt; &lt;code&gt;Weak::new&lt;/code&gt; &lt;/a&gt;を使用して作成された場合、これは0を返します。</target>
        </trans-unit>
        <trans-unit id="ffe2ed689988d142674d1aa54b3aa925c7f0ceb1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; was created using &lt;a href=&quot;#method.new&quot;&gt;&lt;code&gt;Weak::new&lt;/code&gt;&lt;/a&gt;, this will return 0. If not, the returned value is at least 1, since &lt;code&gt;self&lt;/code&gt; still points to the value.</source>
          <target state="translated">&lt;a href=&quot;#method.new&quot;&gt; &lt;code&gt;Weak::new&lt;/code&gt; &lt;/a&gt;を使用して &lt;code&gt;self&lt;/code&gt; が作成された場合、これは0を返します。 &lt;code&gt;self&lt;/code&gt; まだ値をポイントしているため、そうでない場合、返される値は少なくとも1 です。</target>
        </trans-unit>
        <trans-unit id="f7cf04a558af40a8692e8d38e72f630ad0f921d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; was created using &lt;a href=&quot;#method.new&quot;&gt;&lt;code&gt;Weak::new&lt;/code&gt;&lt;/a&gt;, this will return &lt;code&gt;None&lt;/code&gt;. If not, the returned value is at least 1, since &lt;code&gt;self&lt;/code&gt; still points to the value.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; が&lt;a href=&quot;#method.new&quot;&gt; &lt;code&gt;Weak::new&lt;/code&gt; &lt;/a&gt;を使用して作成された場合、これは &lt;code&gt;None&lt;/code&gt; を返します。そうでない場合、 &lt;code&gt;self&lt;/code&gt; まだ値を指しているため、戻り値は少なくとも1 です。</target>
        </trans-unit>
        <trans-unit id="3bc7bb1c65b4b00e05db4f8ca6614cdf9fe6dd50" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; was created using &lt;a href=&quot;struct.weak#method.new&quot;&gt;&lt;code&gt;Weak::new&lt;/code&gt;&lt;/a&gt;, or if there are no remaining strong pointers, this will return 0.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; が&lt;a href=&quot;struct.weak#method.new&quot;&gt; &lt;code&gt;Weak::new&lt;/code&gt; &lt;/a&gt;を使用して作成された場合、または強力なポインタが残っていない場合、これは0を返します。</target>
        </trans-unit>
        <trans-unit id="5cfa0b57fd172f30232192cc8919edcc309955f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; was created using &lt;a href=&quot;struct.weak#method.new&quot;&gt;&lt;code&gt;Weak::new&lt;/code&gt;&lt;/a&gt;, this will return 0.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; が&lt;a href=&quot;struct.weak#method.new&quot;&gt; &lt;code&gt;Weak::new&lt;/code&gt; &lt;/a&gt;を使用して作成された場合、これは0を返します。</target>
        </trans-unit>
        <trans-unit id="8ab90cc43346ebf820e0570ac8953d279713fad0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;some_option_value&lt;/code&gt; was a &lt;code&gt;None&lt;/code&gt; value, it would fail to match the pattern &lt;code&gt;Some(x)&lt;/code&gt;, meaning the pattern is refutable. However, the &lt;code&gt;let&lt;/code&gt; statement can only accept an irrefutable pattern because there is nothing valid the code can do with a &lt;code&gt;None&lt;/code&gt; value. At compile time, Rust will complain that we&amp;rsquo;ve tried to use a refutable pattern where an irrefutable pattern is required:</source>
          <target state="translated">場合 &lt;code&gt;some_option_value&lt;/code&gt; がいた &lt;code&gt;None&lt;/code&gt; 値、それがパターンに一致しないだろう &lt;code&gt;Some(x)&lt;/code&gt; パターンは反駁ある意味します、。ただし、コードが &lt;code&gt;None&lt;/code&gt; 値で実行できる有効なものは何もないため、 &lt;code&gt;let&lt;/code&gt; ステートメントは反駁できないパターンのみを受け入れることができます。コンパイル時に、Rustは、反駁できないパターンが必要な反駁可能なパターンを使用しようとしたことを報告します。</target>
        </trans-unit>
        <trans-unit id="7912a0b36bd857714b86c8f65975fd42323403e7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;src&lt;/code&gt; does not implement &lt;code&gt;Copy&lt;/code&gt;, use &lt;a href=&quot;#method.clone_from_slice&quot;&gt;&lt;code&gt;clone_from_slice&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; が &lt;code&gt;Copy&lt;/code&gt; を実装していない場合は、&lt;a href=&quot;#method.clone_from_slice&quot;&gt; &lt;code&gt;clone_from_slice&lt;/code&gt; を&lt;/a&gt;使用します。</target>
        </trans-unit>
        <trans-unit id="d89aaab24b69c1dc1835d5c53542bd5dee44e824" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;src&lt;/code&gt; implements &lt;code&gt;Copy&lt;/code&gt;, it can be more performant to use &lt;a href=&quot;#method.copy_from_slice&quot;&gt;&lt;code&gt;copy_from_slice&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; が &lt;code&gt;Copy&lt;/code&gt; を実装している場合、&lt;a href=&quot;#method.copy_from_slice&quot;&gt; &lt;code&gt;copy_from_slice&lt;/code&gt; &lt;/a&gt;を使用する方がパフォーマンスが高くなる可能性があります。</target>
        </trans-unit>
        <trans-unit id="f2fb513c03fabfd0da48ed321e5c2ec7c086217d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;src&lt;/code&gt; names a symbolic link, it is platform-specific whether the symbolic link is followed. On platforms where it's possible to not follow it, it is not followed, and the created hard link points to the symbolic link itself.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; がシンボリックリンクに名前を付ける場合、シンボリックリンクがたどられるかどうかはプラットフォーム固有です。従わない可能性のあるプラットフォームでは、従わず、作成されたハードリンクはシンボリックリンク自体を指します。</target>
        </trans-unit>
        <trans-unit id="e2f26bdddcd85ded44fb8dcca9f30dea327428d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; had been a &lt;code&gt;None&lt;/code&gt; value instead of &lt;code&gt;Some(5)&lt;/code&gt;, the patterns in the first two arms wouldn&amp;rsquo;t have matched, so the value would have matched to the underscore. We didn&amp;rsquo;t introduce the &lt;code&gt;x&lt;/code&gt; variable in the pattern of the underscore arm, so the &lt;code&gt;x&lt;/code&gt; in the expression is still the outer &lt;code&gt;x&lt;/code&gt; that hasn&amp;rsquo;t been shadowed. In this hypothetical case, the &lt;code&gt;match&lt;/code&gt; would print &lt;code&gt;Default case, x = None&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; が &lt;code&gt;Some(5)&lt;/code&gt; ではなく &lt;code&gt;None&lt;/code&gt; 値だった場合、最初の2つのアームのパターンは一致しなかったため、値はアンダースコアに一致しました。アンダースコアアームのパターンに &lt;code&gt;x&lt;/code&gt; 変数を導入しなかったので、式の &lt;code&gt;x&lt;/code&gt; はまだシャドウされていない外側の &lt;code&gt;x&lt;/code&gt; です。この架空のケースでは、 &lt;code&gt;match&lt;/code&gt; は &lt;code&gt;Default case, x = None&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="18bf4b6aafae989a7516ceac94bb945e71eddb6d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is 1, 2, 3, 4, or 5, the first arm will match. This syntax is more convenient than using the &lt;code&gt;|&lt;/code&gt; operator to express the same idea; instead of &lt;code&gt;1...5&lt;/code&gt;, we would have to specify &lt;code&gt;1 | 2 | 3 | 4 | 5&lt;/code&gt; if we used &lt;code&gt;|&lt;/code&gt;. Specifying a range is much shorter, especially if we want to match, say, any number between 1 and 1,000!</source>
          <target state="translated">場合 &lt;code&gt;x&lt;/code&gt; 1、2、3、4、または5であり、第一アームが一致します。この構文は、 &lt;code&gt;|&lt;/code&gt; を使用するよりも便利です。同じ考えを表現する演算子; &lt;code&gt;1...5&lt;/code&gt; 代わりに、1 &lt;code&gt;1 | 2 | 3 | 4 | 5&lt;/code&gt; を指定する必要があります。2 | 3 | 4 | 5使用した場合 &lt;code&gt;|&lt;/code&gt; 。範囲の指定は、特に、たとえば1〜1,000の任意の数値に一致させたい場合は、はるかに短くなります。</target>
        </trans-unit>
        <trans-unit id="03b71537ced2e70a9ffd0edf12930fd86baf512b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is 1, 2, 3, 4, or 5, the first arm will match. This syntax is more convenient than using the &lt;code&gt;|&lt;/code&gt; operator to express the same idea; instead of &lt;code&gt;1..=5&lt;/code&gt;, we would have to specify &lt;code&gt;1 | 2 | 3 | 4 | 5&lt;/code&gt; if we used &lt;code&gt;|&lt;/code&gt;. Specifying a range is much shorter, especially if we want to match, say, any number between 1 and 1,000!</source>
          <target state="translated">場合 &lt;code&gt;x&lt;/code&gt; 1、2、3、4、または5であり、第一アームが一致します。この構文は、 &lt;code&gt;|&lt;/code&gt; を使用するよりも便利です。同じ考えを表現する演算子。 &lt;code&gt;1..=5&lt;/code&gt; 代わりに、1 &lt;code&gt;1 | 2 | 3 | 4 | 5&lt;/code&gt; を指定する必要があります。2 | 3 | 4 | 5使用した場合 &lt;code&gt;|&lt;/code&gt; 。範囲の指定ははるかに短くなります。特に、たとえば1から1,000までの任意の数値に一致させたい場合はそうです。</target>
        </trans-unit>
        <trans-unit id="0dff0302c86fb6267157aaf01cdfa14adc4d52ab" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;main.rs&lt;/em&gt; was your &amp;ldquo;Hello, world!&amp;rdquo; program, this line would print &lt;code&gt;Hello, world!&lt;/code&gt; to your terminal.</source>
          <target state="translated">&lt;em&gt;main.rs&lt;/em&gt;が「Hello、world！」だった場合 プログラムの場合、この行は &lt;code&gt;Hello, world!&lt;/code&gt; あなたの端末に。</target>
        </trans-unit>
        <trans-unit id="cb2cf548505fabb01a736215a09d7eb4359e58a1" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;main.rs&lt;/em&gt; was your Hello, world! program, this line would print &lt;code&gt;Hello, world!&lt;/code&gt; to your terminal.</source>
          <target state="translated">&lt;em&gt;main.rs&lt;/em&gt;がHello、world！だった場合 プログラムでは、この行は &lt;code&gt;Hello, world!&lt;/code&gt; あなたの端末に。</target>
        </trans-unit>
        <trans-unit id="d9079a0efb2b14490cdc2479436c152fdb5fa1c2" translate="yes" xml:space="preserve">
          <source>If Rust code &lt;em&gt;does&lt;/em&gt; need to look into those strings, it can convert them to valid UTF-8, possibly lossily, by substituting invalid sequences with &lt;a href=&quot;../../../char/constant.replacement_character&quot;&gt;&lt;code&gt;U+FFFD REPLACEMENT CHARACTER&lt;/code&gt;&lt;/a&gt;, as is conventionally done in other Rust APIs that deal with string encodings.</source>
          <target state="translated">Rustコード&lt;em&gt;が&lt;/em&gt;これらの文字列を調べる必要&lt;em&gt;が&lt;/em&gt;ある場合、文字列エンコーディングを処理する他のRust APIで従来行われているように、&lt;a href=&quot;../../../char/constant.replacement_character&quot;&gt; &lt;code&gt;U+FFFD REPLACEMENT CHARACTER&lt;/code&gt; &lt;/a&gt;で無効なシーケンスを置き換えることにより、それらを有効なUTF-8に変換することができます。</target>
        </trans-unit>
        <trans-unit id="197312fbd3b9939e66c78499e206ee75ae2c0258" translate="yes" xml:space="preserve">
          <source>If Rust didn&amp;rsquo;t implement deref coercion, we would have to write the code in Listing 15-13 instead of the code in Listing 15-12 to call &lt;code&gt;hello&lt;/code&gt; with a value of type &lt;code&gt;&amp;amp;MyBox&amp;lt;String&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Rustがderef型強制を実装していない場合、リスト15-12のコードの代わりにリスト15-13のコードを記述して、 &lt;code&gt;&amp;amp;MyBox&amp;lt;String&amp;gt;&lt;/code&gt; 型の値で &lt;code&gt;hello&lt;/code&gt; を呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="6b87cf1a5022226b7cc21cca4d2b0d16ec46dac6" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Read&lt;/code&gt;er does not override the default &lt;code&gt;read_vectored&lt;/code&gt; implementation, code using it may want to avoid the method all together and coalesce writes into a single buffer for higher performance.</source>
          <target state="translated">場合 &lt;code&gt;Read&lt;/code&gt; ERは、デフォルトでは無効にしません &lt;code&gt;read_vectored&lt;/code&gt; 実装を、それを使用してコードは、すべて一緒に方法を避けたいことと合体は、より高いパフォーマンスのための単一のバッファに書き込みます。</target>
        </trans-unit>
        <trans-unit id="56ff52226d48b491c91c2959c2741fe1a5e96b46" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Read&lt;/code&gt;er guarantees that it can work properly with uninitialized memory, it should call &lt;a href=&quot;struct.initializer#method.nop&quot;&gt;&lt;code&gt;Initializer::nop()&lt;/code&gt;&lt;/a&gt;. See the documentation for &lt;a href=&quot;struct.initializer&quot;&gt;&lt;code&gt;Initializer&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;Read&lt;/code&gt; erが初期化されていないメモリで正しく動作することが保証されている場合は、&lt;a href=&quot;struct.initializer#method.nop&quot;&gt; &lt;code&gt;Initializer::nop()&lt;/code&gt; &lt;/a&gt;呼び出す必要があります。詳細については、&lt;a href=&quot;struct.initializer&quot;&gt; &lt;code&gt;Initializer&lt;/code&gt; &lt;/a&gt;のドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="6f382719afa245fe22b4489961298212f0dd9d4d" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;String&lt;/code&gt; has enough capacity, adding elements to it will not re-allocate. For example, consider this program:</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; に十分な容量がある場合、それに要素を追加しても再割り当てされません。たとえば、次のプログラムについて考えてみます。</target>
        </trans-unit>
        <trans-unit id="9fa35bc4f2bce6280405afd54339a1d6674f6de7" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Vacant(entry)&lt;/code&gt; is yielded, then the key &lt;em&gt;was not&lt;/em&gt; found. In this case the only valid operation is to &lt;code&gt;insert&lt;/code&gt; a value into the entry. When this is done, the vacant entry is consumed and converted into a mutable reference to the value that was inserted. This allows for further manipulation of the value beyond the lifetime of the search itself. This is useful if complex logic needs to be performed on the value regardless of whether the value was just inserted.</source>
          <target state="translated">場合は &lt;code&gt;Vacant(entry)&lt;/code&gt; 得られたが、その後、キーが&lt;em&gt;されなかった&lt;/em&gt;発見しました。この場合、有効な操作は、エントリに値を &lt;code&gt;insert&lt;/code&gt; することだけです。これが行われると、空のエントリが消費され、挿入された値への可変参照に変換されます。これにより、検索自体の有効期間を超えて値をさらに操作できます。これは、値が挿入されたかどうかに関係なく、値に対して複雑なロジックを実行する必要がある場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="cda87c5518b5b9027cd10d7cda1ac0257185a449" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Vec&lt;/code&gt;&lt;em&gt;has&lt;/em&gt; allocated memory, then the memory it points to is on the heap (as defined by the allocator Rust is configured to use by default), and its pointer points to &lt;a href=&quot;struct.vec#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; initialized, contiguous elements in order (what you would see if you coerced it to a slice), followed by &lt;a href=&quot;struct.vec#method.capacity&quot;&gt;&lt;code&gt;capacity&lt;/code&gt;&lt;/a&gt;&lt;code&gt;-&lt;/code&gt;&lt;a href=&quot;struct.vec#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; logically uninitialized, contiguous elements.</source>
          <target state="translated">&lt;code&gt;Vec&lt;/code&gt; &lt;em&gt;が&lt;/em&gt;メモリ&lt;em&gt;を&lt;/em&gt;割り当て&lt;em&gt;ている&lt;/em&gt;場合、それが指すメモリはヒープ上にあり（アロケータで定義されているように、Rustはデフォルトで使用するように構成されています）、そのポインタは&lt;a href=&quot;struct.vec#method.len&quot;&gt; &lt;code&gt;len&lt;/code&gt; の&lt;/a&gt;初期化された連続する要素を順番に指します（あなたは、続い）スライスにそれを強制的&lt;a href=&quot;struct.vec#method.capacity&quot;&gt; &lt;code&gt;capacity&lt;/code&gt; &lt;/a&gt; &lt;code&gt;-&lt;/code&gt; &lt;a href=&quot;struct.vec#method.len&quot;&gt; &lt;code&gt;len&lt;/code&gt; を&lt;/a&gt;論理的に初期化されていない、連続する要素。</target>
        </trans-unit>
        <trans-unit id="dd0874f4a42c7a12d138cfaedb4f719f3af9227c" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Write&lt;/code&gt;er does not override the default &lt;a href=&quot;trait.write#method.write_vectored&quot;&gt;&lt;code&gt;write_vectored&lt;/code&gt;&lt;/a&gt; implementation, code using it may want to avoid the method all together and coalesce writes into a single buffer for higher performance.</source>
          <target state="translated">場合は &lt;code&gt;Write&lt;/code&gt; ERはデフォルトオーバーライドしない&lt;a href=&quot;trait.write#method.write_vectored&quot;&gt; &lt;code&gt;write_vectored&lt;/code&gt; &lt;/a&gt;実装を、それを使用してコードは、すべて一緒に方法を避けたいことと合体は、より高いパフォーマンスのための単一のバッファに書き込みます。</target>
        </trans-unit>
        <trans-unit id="887bcf39fbff642c3b328187978b79bee02328d7" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;const&lt;/code&gt; item contains some type that does not implement this trait, then that type either (1.) does not implement &lt;code&gt;PartialEq&lt;/code&gt; (which means the constant will not provide that comparison method, which code generation assumes is available), or (2.) it implements &lt;em&gt;its own&lt;/em&gt; version of &lt;code&gt;PartialEq&lt;/code&gt; (which we assume does not conform to a structural-equality comparison).</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; アイテムにこの特性を実装しない型が含まれている場合、その型は（1.） &lt;code&gt;PartialEq&lt;/code&gt; を実装しません（つまり、定数は、コード生成が使用可能であると想定する比較メソッドを提供しません）、または（2。 ）それは &lt;code&gt;PartialEq&lt;/code&gt; の&lt;em&gt;独自の&lt;/em&gt;バージョンを実装&lt;em&gt;し&lt;/em&gt;ます（これは構造的同等性の比較に準拠していないと想定しています）。</target>
        </trans-unit>
        <trans-unit id="7756c2df57a46e8ffe41d330e37036f813dca05f" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;static&lt;/code&gt; item is declared with the &lt;a href=&quot;keyword.mut&quot;&gt;&lt;code&gt;mut&lt;/code&gt;&lt;/a&gt; keyword, then it is allowed to be modified by the program. However, accessing mutable &lt;code&gt;static&lt;/code&gt;s can cause undefined behavior in a number of ways, for example due to data races in a multithreaded context. As such, all accesses to mutable &lt;code&gt;static&lt;/code&gt;s require an &lt;a href=&quot;keyword.unsafe&quot;&gt;&lt;code&gt;unsafe&lt;/code&gt;&lt;/a&gt; block.</source>
          <target state="translated">場合は &lt;code&gt;static&lt;/code&gt; 項目がで宣言され&lt;a href=&quot;keyword.mut&quot;&gt; &lt;code&gt;mut&lt;/code&gt; &lt;/a&gt;キーワード、プログラムによって変更することが許可されています。ただし、可変 &lt;code&gt;static&lt;/code&gt; にアクセスすると、マルチスレッドコンテキストでのデータ競合など、さまざまな方法で未定義の動作が発生する可能性があります。そのため、可変 &lt;code&gt;static&lt;/code&gt; へのすべてのアクセスには、&lt;a href=&quot;keyword.unsafe&quot;&gt; &lt;code&gt;unsafe&lt;/code&gt; &lt;/a&gt;ブロックが必要です。</target>
        </trans-unit>
        <trans-unit id="8c0ce05d92f7c594a3a90bea8f233df56be2f1d6" translate="yes" xml:space="preserve">
          <source>If a &lt;em&gt;new&lt;/em&gt; file is created because it does not yet exist and &lt;code&gt;.create(true)&lt;/code&gt; or &lt;code&gt;.create_new(true)&lt;/code&gt; are specified, the new file is given the attributes declared with &lt;code&gt;.attributes()&lt;/code&gt;.</source>
          <target state="translated">場合は&lt;em&gt;、新しい&lt;/em&gt;ファイルが作成され、それはまだ存在していないため、 &lt;code&gt;.create(true)&lt;/code&gt; または &lt;code&gt;.create_new(true)&lt;/code&gt; 指定され、新しいファイルが属性を与えていると宣言した &lt;code&gt;.attributes()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="16c8daede20373077d8ff711c94e64a0b59b67bb" translate="yes" xml:space="preserve">
          <source>If a binding pattern does not explicitly have &lt;code&gt;ref&lt;/code&gt;, &lt;code&gt;ref mut&lt;/code&gt;, or &lt;code&gt;mut&lt;/code&gt;, then it uses the &lt;em&gt;default binding mode&lt;/em&gt; to determine how the variable is bound. The default binding mode starts in &quot;move&quot; mode which uses move semantics. When matching a pattern, the compiler starts from the outside of the pattern and works inwards. Each time a reference is matched using a non-reference pattern, it will automatically dereference the value and update the default binding mode. References will set the default binding mode to &lt;code&gt;ref&lt;/code&gt;. Mutable references will set the mode to &lt;code&gt;ref mut&lt;/code&gt; unless the mode is already &lt;code&gt;ref&lt;/code&gt; in which case it remains &lt;code&gt;ref&lt;/code&gt;. If the automatically dereferenced value is still a reference, it is dereferenced and this process repeats.</source>
          <target state="translated">バインディングパターンに &lt;code&gt;ref&lt;/code&gt; 、 &lt;code&gt;ref mut&lt;/code&gt; 、または &lt;code&gt;mut&lt;/code&gt; が明示的に指定されていない場合は、&lt;em&gt;デフォルトのバインディングモード&lt;/em&gt;を使用して、変数のバインド方法を決定します。デフォルトのバインディングモードは、移動セマンティクスを使用する「移動」モードで始まります。パターンに一致する場合、コンパイラーはパターンの外側から開始して内側に向かって動作します。非参照パターンを使用して参照が照合されるたびに、値は自動的に逆参照され、デフォルトのバインディングモードが更新されます。参照は、デフォルトのバインディングモードを &lt;code&gt;ref&lt;/code&gt; に設定します。可変参照は、モードが &lt;code&gt;ref mut&lt;/code&gt; に設定されます。ただし、モードがすでに &lt;code&gt;ref&lt;/code&gt; である場合は、 &lt;code&gt;ref&lt;/code&gt; のままです。。自動的に逆参照された値が依然として参照である場合、その値は逆参照され、このプロセスが繰り返されます。</target>
        </trans-unit>
        <trans-unit id="9479998c1b13e05b48032e25e7379b48f06d377a" translate="yes" xml:space="preserve">
          <source>If a borrow, dereference, field, or tuple indexing expression has an extended temporary scope then so does its operand. If an indexing expression has an extended temporary scope then the indexed expression also has an extended temporary scope.</source>
          <target state="translated">このような場合は、この関数は、この関数を使用することで、この関数を使用することができるようになります。インデックス式が拡張された一時的なスコープを持つ場合、インデックス式も拡張された一時的なスコープを持ちます。</target>
        </trans-unit>
        <trans-unit id="7cce383f10beb57ed085cf340ccb835736dad8de" translate="yes" xml:space="preserve">
          <source>If a character does not have a lowercase equivalent, the same character will be returned back by the iterator.</source>
          <target state="translated">小文字に相当する文字がない場合は、同じ文字がイテレータによって返されます。</target>
        </trans-unit>
        <trans-unit id="ef2f005976fec5c6467e7bb3fc454eb0cb7f06ed" translate="yes" xml:space="preserve">
          <source>If a character does not have an uppercase equivalent, the same character will be returned back by the iterator.</source>
          <target state="translated">大文字に相当する文字がない場合は、同じ文字がイテレータによって返されます。</target>
        </trans-unit>
        <trans-unit id="d0d13af4b33d582574dec6432db47608e7a6fcac" translate="yes" xml:space="preserve">
          <source>If a clean shutdown is needed it is recommended to only call this function at a known point where there are no more destructors left to run.</source>
          <target state="translated">クリーンなシャットダウンが必要な場合は、デストラクタを実行する必要がなくなった時点でのみこの関数を呼び出すことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="90545bafc06a46b5933ce2daa0969b441705a55d" translate="yes" xml:space="preserve">
          <source>If a const function is called outside a &lt;a href=&quot;../const_eval#const-context&quot;&gt;const context&lt;/a&gt;, it is indistinguishable from any other function. You can freely do anything with a const function that you can do with a regular function.</source>
          <target state="translated">const関数が&lt;a href=&quot;../const_eval#const-context&quot;&gt;constコンテキストの&lt;/a&gt;外で呼び出された場合、他の関数と区別できません。通常の関数で実行できるconst関数を使用して、何でも自由に実行できます。</target>
        </trans-unit>
        <trans-unit id="ba510c5879ea4cc171f31422ae04de034d50983c" translate="yes" xml:space="preserve">
          <source>If a destructor must be run manually, such as when implementing your own smart pointer, &lt;a href=&quot;../std/ptr/fn.drop_in_place&quot;&gt;&lt;code&gt;std::ptr::drop_in_place&lt;/code&gt;&lt;/a&gt; can be used.</source>
          <target state="translated">独自のスマートポインタを実装する場合など、デストラクタを手動で実行する必要がある場合は、&lt;a href=&quot;../std/ptr/fn.drop_in_place&quot;&gt; &lt;code&gt;std::ptr::drop_in_place&lt;/code&gt; &lt;/a&gt;を使用できます。</target>
        </trans-unit>
        <trans-unit id="aac87c21fcf6474549d65e03ca36c8ec59d12740" translate="yes" xml:space="preserve">
          <source>If a dynamic library or an executable that is being dynamically linked is being produced, then the compiler will attempt to reconcile the available dependencies in either the rlib or dylib format to create a final product.</source>
          <target state="translated">動的ライブラリまたは動的にリンクされている実行ファイルが生成される場合、コンパイラは利用可能な依存関係を rlib または dylib 形式で調整して最終製品を作成しようとします。</target>
        </trans-unit>
        <trans-unit id="5cf3f34eab79e2589477387981185c179654267a" translate="yes" xml:space="preserve">
          <source>If a file is opened with both read and append access, beware that after opening, and after every write, the position for reading may be set at the end of the file. So, before writing, save the current position (using &lt;a href=&quot;../io/trait.seek#tymethod.seek&quot;&gt;&lt;code&gt;seek&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&lt;/code&gt;&lt;a href=&quot;../io/enum.seekfrom&quot;&gt;&lt;code&gt;SeekFrom&lt;/code&gt;&lt;/a&gt;&lt;code&gt;::&lt;/code&gt;&lt;a href=&quot;../io/enum.seekfrom#variant.Current&quot;&gt;&lt;code&gt;Current&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(0))&lt;/code&gt;), and restore it before the next read.</source>
          <target state="translated">読み取りアクセスと追加アクセスの両方でファイルを開く場合は、開いた後、およびすべての書き込み後に、読み取りの位置がファイルの最後に設定される場合があることに注意してください。したがって、書き込む前に、現在の位置を保存し（&lt;a href=&quot;../io/trait.seek#tymethod.seek&quot;&gt; &lt;code&gt;seek&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&lt;/code&gt; &lt;a href=&quot;../io/enum.seekfrom&quot;&gt; &lt;code&gt;SeekFrom&lt;/code&gt; &lt;/a&gt; &lt;code&gt;::&lt;/code&gt; &lt;a href=&quot;../io/enum.seekfrom#variant.Current&quot;&gt; &lt;code&gt;Current&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(0))&lt;/code&gt; を使用）、次の読み取りの前に復元します。</target>
        </trans-unit>
        <trans-unit id="b25b09268442abcdc7a1f9b2c36f533d27627828" translate="yes" xml:space="preserve">
          <source>If a file is opened with both read and append access, beware that after opening, and after every write, the position for reading may be set at the end of the file. So, before writing, save the current position (using &lt;a href=&quot;struct.file#method.seek&quot;&gt;&lt;code&gt;seek&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&lt;/code&gt;&lt;a href=&quot;../io/enum.seekfrom&quot;&gt;&lt;code&gt;SeekFrom&lt;/code&gt;&lt;/a&gt;&lt;code&gt;::&lt;/code&gt;&lt;a href=&quot;../io/enum.seekfrom#variant.Current&quot;&gt;&lt;code&gt;Current&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(0))&lt;/code&gt;), and restore it before the next read.</source>
          <target state="translated">ファイルを読み取りアクセスと追加アクセスの両方で開いた場合、開いた後、および書き込みのたびに、読み取りの位置がファイルの末尾に設定される場合があることに注意してください。したがって、書き込む前に、現在の位置を保存し（&lt;a href=&quot;struct.file#method.seek&quot;&gt; &lt;code&gt;seek&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&lt;/code&gt; &lt;a href=&quot;../io/enum.seekfrom&quot;&gt; &lt;code&gt;SeekFrom&lt;/code&gt; &lt;/a&gt; &lt;code&gt;::&lt;/code&gt; &lt;a href=&quot;../io/enum.seekfrom#variant.Current&quot;&gt; &lt;code&gt;Current&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(0))&lt;/code&gt; を使用）、次の読み取りの前にそれを復元します。</target>
        </trans-unit>
        <trans-unit id="7ae8e9b37b3fae0e90c2e27255beba504df5f00d" translate="yes" xml:space="preserve">
          <source>If a file is successfully opened with this option set it will truncate the file to 0 length if it already exists.</source>
          <target state="translated">このオプションが設定されている状態でファイルが正常に開かれた場合、既に存在する場合にはファイルの長さを0に切り詰めます。</target>
        </trans-unit>
        <trans-unit id="d0abbc43e6eb90b8c51d1b76b304256ddf0362aa" translate="yes" xml:space="preserve">
          <source>If a floating-point type can be &lt;em&gt;uniquely&lt;/em&gt; determined from the surrounding program context, the unsuffixed floating-point literal has that type.</source>
          <target state="translated">浮動小数点型が周囲のプログラムコンテキストから&lt;em&gt;一意に&lt;/em&gt;決定できる場合、接尾辞のない浮動小数点リテラルはその型を持ちます。</target>
        </trans-unit>
        <trans-unit id="04efa2d88cc29b968e806cf715e0ee4d0b695c80" translate="yes" xml:space="preserve">
          <source>If a language must have inheritance to be an object-oriented language, then Rust is not one. There is no way to define a struct that inherits the parent struct&amp;rsquo;s fields and method implementations. However, if you&amp;rsquo;re used to having inheritance in your programming toolbox, you can use other solutions in Rust, depending on your reason for reaching for inheritance in the first place.</source>
          <target state="translated">言語がオブジェクト指向言語であるために継承が必要な場合、Rustは継承ではありません。親構造体のフィールドとメソッド実装を継承する構造体を定義する方法はありません。ただし、プログラミングツールボックスに継承があることに慣れている場合は、最初に継承を求める理由に応じて、Rustで他のソリューションを使用できます。</target>
        </trans-unit>
        <trans-unit id="442a02939139d9c59cef162a2647bac06f4e1997" translate="yes" xml:space="preserve">
          <source>If a method call fails in a test, you&amp;rsquo;d want the whole test to fail, even if that method isn&amp;rsquo;t the functionality under test. Because &lt;code&gt;panic!&lt;/code&gt; is how a test is marked as a failure, calling &lt;code&gt;unwrap&lt;/code&gt; or &lt;code&gt;expect&lt;/code&gt; is exactly what should happen.</source>
          <target state="translated">メソッドの呼び出しがテストで失敗した場合、そのメソッドがテスト対象の機能ではない場合でも、テスト全体が失敗するようにします。ので &lt;code&gt;panic!&lt;/code&gt; テストが失敗としてマークされる方法です &lt;code&gt;unwrap&lt;/code&gt; または &lt;code&gt;expect&lt;/code&gt; を呼び出すと、まさに何が起こるかがわかります。</target>
        </trans-unit>
        <trans-unit id="9d96dca6a8141f4e31a24310383d3fa9b46a981c" translate="yes" xml:space="preserve">
          <source>If a new file is created as part of a &lt;code&gt;File::open_opts&lt;/code&gt; call then this specified &lt;code&gt;mode&lt;/code&gt; will be used as the permission bits for the new file. If no &lt;code&gt;mode&lt;/code&gt; is set, the default of &lt;code&gt;0o666&lt;/code&gt; will be used. The operating system masks out bits with the systems &lt;code&gt;umask&lt;/code&gt;, to produce the final permissions.</source>
          <target state="translated">&lt;code&gt;File::open_opts&lt;/code&gt; 呼び出しの一部として新しいファイルが作成された場合、この指定された &lt;code&gt;mode&lt;/code&gt; が新しいファイルの許可ビットとして使用されます。 &lt;code&gt;mode&lt;/code&gt; が設定されていない場合、デフォルトの &lt;code&gt;0o666&lt;/code&gt; が使用されます。オペレーティングシステムは、システムの &lt;code&gt;umask&lt;/code&gt; を使用してビットをマスクし、最終的な権限を生成します。</target>
        </trans-unit>
        <trans-unit id="29baa09d14f6cfea0e9d752b0246ef9148a54b0e" translate="yes" xml:space="preserve">
          <source>If a new file is created as part of an &lt;code&gt;OpenOptions::open&lt;/code&gt; call then this specified &lt;code&gt;mode&lt;/code&gt; will be used as the permission bits for the new file. If no &lt;code&gt;mode&lt;/code&gt; is set, the default of &lt;code&gt;0o666&lt;/code&gt; will be used. The operating system masks out bits with the system's &lt;code&gt;umask&lt;/code&gt;, to produce the final permissions.</source>
          <target state="translated">&lt;code&gt;OpenOptions::open&lt;/code&gt; 呼び出しの一部として新しいファイルが作成された場合、この指定された &lt;code&gt;mode&lt;/code&gt; が新しいファイルの許可ビットとして使用されます。 &lt;code&gt;mode&lt;/code&gt; が設定されていない場合、デフォルトの &lt;code&gt;0o666&lt;/code&gt; が使用されます。オペレーティングシステムは、システムの &lt;code&gt;umask&lt;/code&gt; でビットをマスクして、最終的なアクセス許可を生成します。</target>
        </trans-unit>
        <trans-unit id="58a088dab2a65affaf69dc6a26afc8c56ddf7d23" translate="yes" xml:space="preserve">
          <source>If a nul byte is present and not the last element or no nul bytes is present, an error will be returned.</source>
          <target state="translated">nul バイトが存在し、最後の要素ではない場合、または nul バイトが存在しない場合は、エラーが返されます。</target>
        </trans-unit>
        <trans-unit id="edf29e89879313dc8e8b20d286c6fbf984a0c2ff" translate="yes" xml:space="preserve">
          <source>If a panic occurs in a named thread, the thread name will be printed in the panic message.</source>
          <target state="translated">指定されたスレッドでパニックが発生した場合、そのスレッド名がパニックメッセージに表示されます。</target>
        </trans-unit>
        <trans-unit id="ae66f71517007a8faed7e8f14069d9743a8fc1d6" translate="yes" xml:space="preserve">
          <source>If a program contains arithmetic overflow, the programmer has made an error. In the following discussion, we maintain a distinction between arithmetic overflow and wrapping arithmetic. The first is erroneous, while the second is intentional.</source>
          <target state="translated">プログラムに算術オーバーフローが含まれている場合、プログラマーはエラーを犯したことになります。以下の議論では、算術オーバーフローとラッピング算術の区別を維持します。前者は誤りですが、後者は意図的なものです。</target>
        </trans-unit>
        <trans-unit id="9ed92fa5e7088a3110b1cc9346594a14bbfacbbf" translate="yes" xml:space="preserve">
          <source>If a static item is declared with the &lt;code&gt;mut&lt;/code&gt; keyword, then it is allowed to be modified by the program. One of Rust's goals is to make concurrency bugs hard to run into, and this is obviously a very large source of race conditions or other bugs. For this reason, an &lt;code&gt;unsafe&lt;/code&gt; block is required when either reading or writing a mutable static variable. Care should be taken to ensure that modifications to a mutable static are safe with respect to other threads running in the same process.</source>
          <target state="translated">静的アイテムが &lt;code&gt;mut&lt;/code&gt; キーワードで宣言されている場合、プログラムによって変更できます。Rustの目標の1つは、同時実行バグを実行しにくくすることであり、これは明らかに競合状態や他のバグの非常に大きな原因です。このため、変更可能な静的変数の読み取りまたは書き込みを行う場合は、 &lt;code&gt;unsafe&lt;/code&gt; ブロックが必要です。同じプロセスで実行されている他のスレッドに対して、変更可能なstaticへの変更が安全であることを確認するように注意する必要があります。</target>
        </trans-unit>
        <trans-unit id="a1766ce77343ee3ad45def8d871224ac057e5320" translate="yes" xml:space="preserve">
          <source>If a static library is being produced, all upstream dependencies are required to be available in &lt;code&gt;rlib&lt;/code&gt; formats. This requirement stems from the reason that a dynamic library cannot be converted into a static format.</source>
          <target state="translated">静的ライブラリが作成されている場合、すべての上流の依存関係が &lt;code&gt;rlib&lt;/code&gt; 形式で利用可能である必要があります。この要件は、動的ライブラリを静的形式に変換できないという理由から生じています。</target>
        </trans-unit>
        <trans-unit id="7bac0e8b6805f499b0c443af2ab6fa54c5aa649c" translate="yes" xml:space="preserve">
          <source>If a step is reached where there is more than one possible method, such as where generic methods or traits are considered the same, then it is a compiler error. These cases require a &lt;a href=&quot;call-expr#disambiguating-function-calls&quot;&gt;disambiguating function call syntax&lt;/a&gt; for method and function invocation.</source>
          <target state="translated">ジェネリックメソッドまたは特性が同じと見なされる場合など、複数の可能なメソッドがあるステップに到達した場合、それはコンパイラエラーです。これらのケースでは、メソッドと関数を呼び出すための&lt;a href=&quot;call-expr#disambiguating-function-calls&quot;&gt;明確な関数呼び出し構文&lt;/a&gt;が必要です。</target>
        </trans-unit>
        <trans-unit id="7f3fff7995601b35f7065fae1e640e2f2eeb6214" translate="yes" xml:space="preserve">
          <source>If a string contains multiple contiguous separators, you will end up with empty strings in the output:</source>
          <target state="translated">文字列に複数の連続する区切り文字が含まれている場合は、出力に空の文字列が含まれることになります。</target>
        </trans-unit>
        <trans-unit id="4ab14222518e8fb43884627c81d597c32a8700e2" translate="yes" xml:space="preserve">
          <source>If a type &lt;code&gt;Item&lt;/code&gt; has an associated type &lt;code&gt;Assoc&lt;/code&gt; from a trait &lt;code&gt;Trait&lt;/code&gt;, then &lt;code&gt;&amp;lt;Item as Trait&amp;gt;::Assoc&lt;/code&gt; is a type that is an alias of the type specified in the associated type definition. Furthermore, if &lt;code&gt;Item&lt;/code&gt; is a type parameter, then &lt;code&gt;Item::Assoc&lt;/code&gt; can be used in type parameters.</source>
          <target state="translated">型の場合 &lt;code&gt;Item&lt;/code&gt; 関連するタイプ有する &lt;code&gt;Assoc&lt;/code&gt; 形質から &lt;code&gt;Trait&lt;/code&gt; 、その後 &lt;code&gt;&amp;lt;Item as Trait&amp;gt;::Assoc&lt;/code&gt; 関連するタイプの定義で指定された型の別名であるタイプです。さらに、 &lt;code&gt;Item&lt;/code&gt; が型パラメーターの場合、 &lt;code&gt;Item::Assoc&lt;/code&gt; を型パラメーターで使用できます。</target>
        </trans-unit>
        <trans-unit id="98ce79152874ad30a4163310f54c79462c6fb1d7" translate="yes" xml:space="preserve">
          <source>If a type contains a &lt;code&gt;PhantomPinned&lt;/code&gt;, it will not implement &lt;code&gt;Unpin&lt;/code&gt; by default.</source>
          <target state="translated">タイプが含まれている場合は &lt;code&gt;PhantomPinned&lt;/code&gt; を、それが実現しません &lt;code&gt;Unpin&lt;/code&gt; 、デフォルトで。</target>
        </trans-unit>
        <trans-unit id="1433c5d355e130cd227bc3635eea7b7161e572f3" translate="yes" xml:space="preserve">
          <source>If all goes well, &lt;code&gt;Hello, world!&lt;/code&gt; should print to the terminal. Running &lt;code&gt;cargo build&lt;/code&gt; for the first time also causes Cargo to create a new file at the top level: &lt;em&gt;Cargo.lock&lt;/em&gt;. This file keeps track of the exact versions of dependencies in your project. This project doesn&amp;rsquo;t have dependencies, so the file is a bit sparse. You won&amp;rsquo;t ever need to change this file manually; Cargo manages its contents for you.</source>
          <target state="translated">すべてがうまく &lt;code&gt;Hello, world!&lt;/code&gt; ば、こんにちは、世界！端末に出力する必要があります。 &lt;code&gt;cargo build&lt;/code&gt; を初めて実行すると、カーゴは最上位に新しいファイル&lt;em&gt;Cargo.lock&lt;/em&gt;を作成します。このファイルは、プロジェクト内の依存関係の正確なバージョンを追跡します。このプロジェクトには依存関係がないため、ファイルは少し疎です。このファイルを手動で変更する必要はありません。貨物はあなたのためにその内容を管理します。</target>
        </trans-unit>
        <trans-unit id="5ace79993641886b01cac522412b514b142053ea" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;Alloc&lt;/code&gt; implementation chooses to return &lt;code&gt;Ok&lt;/code&gt; in this case (i.e., the pointer denotes a zero-sized inaccessible block) then that returned pointer must be considered &quot;currently allocated&quot;. On such an allocator, &lt;em&gt;all&lt;/em&gt; methods that take currently-allocated pointers as inputs must accept these zero-sized pointers, &lt;em&gt;without&lt;/em&gt; causing undefined behavior.</source>
          <target state="translated">この場合、 &lt;code&gt;Alloc&lt;/code&gt; 実装が &lt;code&gt;Ok&lt;/code&gt; を返すことを選択した場合（つまり、ポインターが0サイズのアクセスできないブロックを示す）、その返されたポインターは「現在割り当てられている」と見なす必要があります。そのようなアロケーターでは、現在割り当てられているポインターを入力として受け取る&lt;em&gt;すべての&lt;/em&gt;メソッドは、未定義の動作&lt;em&gt;を&lt;/em&gt;引き起こす&lt;em&gt;ことなく&lt;/em&gt;、これらのサイズがゼロのポインターを受け入れる必要があります。</target>
        </trans-unit>
        <trans-unit id="766a342529319b1e212f056deacbe904859bc648" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;Err(e)&lt;/code&gt; result is returned, the value &lt;code&gt;e&lt;/code&gt; will be &quot;wrapped&quot; in the return type of the enclosing scope (which must itself implement &lt;code&gt;Try&lt;/code&gt;). Specifically, the value &lt;code&gt;X::from_error(From::from(e))&lt;/code&gt; is returned, where &lt;code&gt;X&lt;/code&gt; is the return type of the enclosing function.</source>
          <target state="translated">場合 &lt;code&gt;Err(e)&lt;/code&gt; 結果が返され、値 &lt;code&gt;e&lt;/code&gt; （自身が実装しなければならない囲むスコープの戻り値の型に「ラップ」され &lt;code&gt;Try&lt;/code&gt; ）。具体的には、値 &lt;code&gt;X::from_error(From::from(e))&lt;/code&gt; が返されます &lt;code&gt;X&lt;/code&gt; は、囲んでいる関数の戻り値の型です。</target>
        </trans-unit>
        <trans-unit id="d07fb8a7b5eba0666b8e8c43c71f4a92c4cff59d" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;Occupied(entry)&lt;/code&gt; is yielded, then the key &lt;em&gt;was&lt;/em&gt; found. In this case, the user has several options: they can &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;insert&lt;/code&gt; or &lt;code&gt;remove&lt;/code&gt; the value of the occupied entry. Additionally, they can convert the occupied entry into a mutable reference to its value, providing symmetry to the vacant &lt;code&gt;insert&lt;/code&gt; case.</source>
          <target state="translated">場合 &lt;code&gt;Occupied(entry)&lt;/code&gt; 得、次いで、キーを&lt;em&gt;した&lt;/em&gt;が見つかりました。この場合、ユーザーにはいくつかのオプションがあります。占有されているエントリの値を &lt;code&gt;get&lt;/code&gt; 、 &lt;code&gt;insert&lt;/code&gt; または &lt;code&gt;remove&lt;/code&gt; できます。さらに、占有エントリをその値への可変参照に変換して、空の &lt;code&gt;insert&lt;/code&gt; ケースに対称性を提供できます。</target>
        </trans-unit>
        <trans-unit id="6496ceefd96285c8c2e145eb325b81df30982dd9" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;rlib&lt;/code&gt; file is being produced, then there are no restrictions on what format the upstream dependencies are available in. It is simply required that all upstream dependencies be available for reading metadata from.</source>
          <target state="translated">&lt;code&gt;rlib&lt;/code&gt; ファイルが作成されている場合、上流の依存関係がどの形式で使用できるかについての制限はありません。メタデータを読み取るためにすべての上流の依存関係を使用できることが必要です。</target>
        </trans-unit>
        <trans-unit id="c8e60161efc2f2d7cfcdc0d31414bc493321f65f" translate="yes" xml:space="preserve">
          <source>If an &lt;em&gt;existing&lt;/em&gt; file is opened with &lt;code&gt;.create(true).truncate(true)&lt;/code&gt;, its existing attributes are preserved and combined with the ones declared with &lt;code&gt;.attributes()&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;既存の&lt;/em&gt;ファイルが &lt;code&gt;.create(true).truncate(true)&lt;/code&gt; で開かれた場合、その既存の属性は保持され、 &lt;code&gt;.attributes()&lt;/code&gt; で宣言された属性と結合されます。</target>
        </trans-unit>
        <trans-unit id="f270e545d597563858cae4afcff9e37ad4508d2c" translate="yes" xml:space="preserve">
          <source>If an I/O error is encountered then all bytes read so far will be present in &lt;code&gt;buf&lt;/code&gt; and its length will have been adjusted appropriately.</source>
          <target state="translated">I / Oエラーが発生した場合、これまでに読み込まれたすべてのバイトは &lt;code&gt;buf&lt;/code&gt; に存在し、その長さは適切に調整されています。</target>
        </trans-unit>
        <trans-unit id="ace1a7d9bf9ec54c3308257f201a03fece98ab35" translate="yes" xml:space="preserve">
          <source>If an executable is being produced and the &lt;code&gt;-C prefer-dynamic&lt;/code&gt; flag is not specified, then dependencies are first attempted to be found in the &lt;code&gt;rlib&lt;/code&gt; format. If some dependencies are not available in an rlib format, then dynamic linking is attempted (see below).</source>
          <target state="translated">実行可能ファイルが作成されていて、 &lt;code&gt;-C prefer-dynamic&lt;/code&gt; フラグが指定されていない場合、依存関係は最初に &lt;code&gt;rlib&lt;/code&gt; 形式で検索されます。rlib形式で使用できない依存関係がある場合は、動的リンクが試行されます（以下を参照）。</target>
        </trans-unit>
        <trans-unit id="45d869ce1ba972ba36ff54baa74eb31c5112c34d" translate="yes" xml:space="preserve">
          <source>If an executor supports a cheaper way to wake without consuming the waker, it should override this method. By default, it clones the &lt;a href=&quot;../sync/struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; and calls &lt;code&gt;wake&lt;/code&gt; on the clone.</source>
          <target state="translated">エグゼキュータがウェイカーを消費せずにウェイクするためのより安価な方法をサポートしている場合は、このメソッドをオーバーライドする必要があります。デフォルトでは、&lt;a href=&quot;../sync/struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt;のクローンを作成し、クローンで &lt;code&gt;wake&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="246eecf3cfe47d66c6f45d4fd6c99d8afcbf27a5" translate="yes" xml:space="preserve">
          <source>If an impl has a generic parameter with the &lt;code&gt;#[may_dangle]&lt;/code&gt; attribute, then that impl must be declared as an &lt;code&gt;unsafe impl&lt;/code&gt;.</source>
          <target state="translated">implに &lt;code&gt;#[may_dangle]&lt;/code&gt; 属性を持つジェネリックパラメーターがある場合、そのimplは &lt;code&gt;unsafe impl&lt;/code&gt; として宣言する必要があります。</target>
        </trans-unit>
        <trans-unit id="5e13abdce3cf8ba0eee5f3efa1352739a357002e" translate="yes" xml:space="preserve">
          <source>If an impl has a generic parameter with the &lt;code&gt;#[may_dangle]&lt;/code&gt; attribute, then that impl must be declared as an `unsafe impl.</source>
          <target state="translated">implに &lt;code&gt;#[may_dangle]&lt;/code&gt; 属性を持つジェネリックパラメーターがある場合、そのimplは`安全でないimplとして宣言する必要があります。</target>
        </trans-unit>
        <trans-unit id="11945bca4b49d81520c3d9de6a4cbb63f81941bb" translate="yes" xml:space="preserve">
          <source>If an integer type can be &lt;em&gt;uniquely&lt;/em&gt; determined from the surrounding program context, the unsuffixed integer literal has that type.</source>
          <target state="translated">整数型が周囲のプログラムコンテキストから&lt;em&gt;一意に&lt;/em&gt;決定できる場合、接尾辞のない整数リテラルはその型を持ちます。</target>
        </trans-unit>
        <trans-unit id="8e63390dbf4949c326a2cfedfadab303b53fa34d" translate="yes" xml:space="preserve">
          <source>If an intrinsic is supposed to be used from a &lt;code&gt;const fn&lt;/code&gt; with a &lt;code&gt;rustc_const_stable&lt;/code&gt; attribute, the intrinsic's attribute must be &lt;code&gt;rustc_const_stable&lt;/code&gt;, too. Such a change should not be done without T-lang consultation, because it bakes a feature into the language that cannot be replicated in user code without compiler support.</source>
          <target state="translated">固有のから使用することを想定している場合は &lt;code&gt;const fn&lt;/code&gt; と &lt;code&gt;rustc_const_stable&lt;/code&gt; 属性、固有の属性がなければなりません &lt;code&gt;rustc_const_stable&lt;/code&gt; も。このような変更は、コンパイラのサポートなしではユーザーコードで複製できない機能を言語に組み込むため、T-langの協議なしに行うべきではありません。</target>
        </trans-unit>
        <trans-unit id="39805e5d14d8cab59f3ec2eabeee9744560e1fb2" translate="yes" xml:space="preserve">
          <source>If an item is private, it may be accessed by the current module and its descendants.</source>
          <target state="translated">アイテムが非公開の場合、現在のモジュールとその子孫がアクセスすることができます。</target>
        </trans-unit>
        <trans-unit id="727527b77e366466861dd6da815129cfeb9a9374" translate="yes" xml:space="preserve">
          <source>If an item is public, then it can be accessed externally from some module &lt;code&gt;m&lt;/code&gt; if you can access all the item's ancestor modules from &lt;code&gt;m&lt;/code&gt;. You can also potentially be able to name the item through re-exports. See below.</source>
          <target state="translated">アイテムが公開されている場合、それはいくつかのモジュールから外部にアクセスすることができます &lt;code&gt;m&lt;/code&gt; あなたからすべてのアイテムの祖先モジュールにアクセスできるかどう &lt;code&gt;m&lt;/code&gt; 。また、再エクスポートを通じてアイテムに名前を付けることができる可能性もあります。下記参照。</target>
        </trans-unit>
        <trans-unit id="07080131ca18f6d9e5b13a9d88dcf93cd9dc48cd" translate="yes" xml:space="preserve">
          <source>If an item is public, then it can be accessed externally from some module &lt;code&gt;m&lt;/code&gt; if you can access all the item's parent modules from &lt;code&gt;m&lt;/code&gt;. You can also potentially be able to name the item through re-exports. See below.</source>
          <target state="translated">アイテムがパブリックである場合、そのアイテムのすべての親モジュールに &lt;code&gt;m&lt;/code&gt; からアクセスできれば、モジュール &lt;code&gt;m&lt;/code&gt; から外部からアクセスできます。また、再エクスポートによってアイテムに名前を付けることもできます。下記参照。</target>
        </trans-unit>
        <trans-unit id="d8864aae63bb3ba2da5620b13b08d971e5c9ff9b" translate="yes" xml:space="preserve">
          <source>If an iterator adapter panics, the iterator will be in an unspecified (but memory safe) state. This state is also not guaranteed to stay the same across versions of Rust, so you should avoid relying on the exact values returned by an iterator which panicked.</source>
          <target state="translated">イテレータアダプタがパニックに陥った場合、イテレータは不特定の (しかしメモリセーフな)状態になります。この状態は、Rust のバージョン間でも同じ状態を保つことが保証されていないため、パニックに陥ったイテレータが返す正確な値に依存することは避けるべきです。</target>
        </trans-unit>
        <trans-unit id="63585324ac753447dc7a54f44e90a00d790fca2c" translate="yes" xml:space="preserve">
          <source>If another thread is active, the lock can still become poisoned at any time. You should not trust a &lt;code&gt;false&lt;/code&gt; value for program correctness without additional synchronization.</source>
          <target state="translated">別のスレッドがアクティブな場合でも、ロックはいつでも汚染される可能性があります。追加の同期を行わずに、プログラムの正確さについて &lt;code&gt;false&lt;/code&gt; 値を信頼しないでください。</target>
        </trans-unit>
        <trans-unit id="109588b2017fbb996d88327d5cc6be15dd8d4ba0" translate="yes" xml:space="preserve">
          <source>If another thread is active, the mutex can still become poisoned at any time. You should not trust a &lt;code&gt;false&lt;/code&gt; value for program correctness without additional synchronization.</source>
          <target state="translated">別のスレッドがアクティブな場合でも、ミューテックスはいつでも汚染される可能性があります。追加の同期を行わずに、プログラムの正確さについて &lt;code&gt;false&lt;/code&gt; 値を信頼しないでください。</target>
        </trans-unit>
        <trans-unit id="78ea9516ec8ea7a6ed978cbfe197fc08ae18d0c1" translate="yes" xml:space="preserve">
          <source>If another user of this mutex panicked while holding the mutex, then this call will return an error if the mutex would otherwise be acquired.</source>
          <target state="translated">このミューテックスを保持している間にこのミューテックスの他のユーザがパニックに陥った場合、この呼び出しは、そうでなければミューテックスが取得されていた場合にエラーを返します。</target>
        </trans-unit>
        <trans-unit id="e8114d3ac34051321d85f9acd763dd0f154fb356" translate="yes" xml:space="preserve">
          <source>If another user of this mutex panicked while holding the mutex, then this call will return an error instead.</source>
          <target state="translated">このミューテックスを保持している間にこのミューテックスの他のユーザがパニックに陥った場合、この呼び出しは代わりにエラーを返します。</target>
        </trans-unit>
        <trans-unit id="937c1840433dcebbb1b2c20629e7140489485c5e" translate="yes" xml:space="preserve">
          <source>If another user of this mutex panicked while holding the mutex, then this call will return an error once the mutex is acquired.</source>
          <target state="translated">このミューテックスを保持している間にこのミューテックスの他のユーザがパニックに陥った場合、この呼び出しはミューテックスを取得した後にエラーを返します。</target>
        </trans-unit>
        <trans-unit id="94a8b260ae2fd91c20d30826f0ac290f20d42663" translate="yes" xml:space="preserve">
          <source>If another user of this mutex panicked while holding the mutex, then this call will return failure if the mutex would otherwise be acquired.</source>
          <target state="translated">このミューテックスを保持している間にこのミューテックスの他のユーザがパニックに陥った場合、この呼び出しは、そうでなければミューテックスを取得することができた場合に失敗を返します。</target>
        </trans-unit>
        <trans-unit id="b8a9fd6020c6344c3b4ec789d5cdc75685b6c76f" translate="yes" xml:space="preserve">
          <source>If any directory in the path specified by &lt;code&gt;path&lt;/code&gt; does not already exist and it could not be created otherwise. The specific error conditions for when a directory is being created (after it is determined to not exist) are outlined by &lt;a href=&quot;fn.create_dir&quot;&gt;&lt;code&gt;fs::create_dir&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">pathで指定された &lt;code&gt;path&lt;/code&gt; 内のディレクトリがまだ存在せず、それ以外の場合は作成できなかった場合。ディレクトリーが作成されているとき（存在しないと判別された後）の特定のエラー条件は、&lt;a href=&quot;fn.create_dir&quot;&gt; &lt;code&gt;fs::create_dir&lt;/code&gt; &lt;/a&gt;によって概説されています。</target>
        </trans-unit>
        <trans-unit id="8c9733a4a8648c17f076f404425858c19e3e7e60" translate="yes" xml:space="preserve">
          <source>If any of the following conditions are violated, the result is Undefined Behavior:</source>
          <target state="translated">以下の条件のいずれかに違反した場合、結果は未定義の動作となります。</target>
        </trans-unit>
        <trans-unit id="abfc6e25813ef681d155e66f1a056df288816b17" translate="yes" xml:space="preserve">
          <source>If any other read error is encountered then this function immediately returns. Any bytes which have already been read will be appended to &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">他の読み取りエラーが発生した場合、この関数はすぐに戻ります。すでに読み取られたバイトは &lt;code&gt;buf&lt;/code&gt; に追加されます。</target>
        </trans-unit>
        <trans-unit id="dc672b538a09f0d8b7133f8175c1bdde7ae9dbbb" translate="yes" xml:space="preserve">
          <source>If any other read error is encountered then this function immediately returns. The contents of &lt;code&gt;buf&lt;/code&gt; are unspecified in this case.</source>
          <target state="translated">他の読み取りエラーが発生した場合、この関数はすぐに戻ります。この場合、 &lt;code&gt;buf&lt;/code&gt; の内容は指定されていません。</target>
        </trans-unit>
        <trans-unit id="c60fca22bff6a233bf25c6e3874996a91aad3287" translate="yes" xml:space="preserve">
          <source>If both do not exist, &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/userenv/nf-userenv-getuserprofiledirectorya&quot;&gt;&lt;code&gt;GetUserProfileDirectory&lt;/code&gt;&lt;/a&gt; is used to return the path.</source>
          <target state="translated">両方が存在しない場合は、&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/userenv/nf-userenv-getuserprofiledirectorya&quot;&gt; &lt;code&gt;GetUserProfileDirectory&lt;/code&gt; &lt;/a&gt;を使用してパスを返します。</target>
        </trans-unit>
        <trans-unit id="ddacadc60603d21344f24b6aa894045e4936178f" translate="yes" xml:space="preserve">
          <source>If both do not exist, &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/bb762280(v=vs.85).aspx&quot;&gt;&lt;code&gt;GetUserProfileDirectory&lt;/code&gt;&lt;/a&gt; is used to return the path.</source>
          <target state="translated">両方が存在しない場合は、&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/bb762280(v=vs.85).aspx&quot;&gt; &lt;code&gt;GetUserProfileDirectory&lt;/code&gt; &lt;/a&gt;を使用してパスを返します。</target>
        </trans-unit>
        <trans-unit id="7fce57c290d26a88e07f0e0c3e4758aa4174e90c" translate="yes" xml:space="preserve">
          <source>If compiled as a dylib, the resulting .so could then be linked to from a C library, and the function could be used as if it was from any other library.</source>
          <target state="translated">dylibとしてコンパイルされた場合、結果として得られる.soはCライブラリからリンクされ、他のライブラリからのものであるかのように関数を使用することができます。</target>
        </trans-unit>
        <trans-unit id="e7b59b345b11e01a4787fa859ca6ad581aae3ad3" translate="yes" xml:space="preserve">
          <source>If either iterator returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; from the zipped iterator will return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;. If the first iterator returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;zip&lt;/code&gt; will short-circuit and &lt;code&gt;next&lt;/code&gt; will not be called on the second iterator.</source>
          <target state="translated">どちらかのイテレータが&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; を&lt;/a&gt;返す場合、&lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt;圧縮されたイテレータから&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;が返されます。最初のイテレーターが&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; を&lt;/a&gt;返す場合、 &lt;code&gt;zip&lt;/code&gt; は短絡し、2番目のイテレーターで &lt;code&gt;next&lt;/code&gt; は呼び出されません。</target>
        </trans-unit>
        <trans-unit id="84103f8a5cb4506a8862655c59a4b3682ff15678" translate="yes" xml:space="preserve">
          <source>If enabled, multicast packets will be looped back to the local socket. Note that this may not have any affect on IPv6 sockets.</source>
          <target state="translated">有効にすると、マルチキャストパケットはローカルソケットにループバックされます。これはIPv6ソケットには影響しない可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="2ee8e080132486e2d1085bc2a52cb053b7cbc535" translate="yes" xml:space="preserve">
          <source>If enabled, multicast packets will be looped back to the local socket. Note that this may not have any effect on IPv6 sockets.</source>
          <target state="translated">有効にすると、マルチキャストパケットはローカルソケットにループバックされます。これはIPv6ソケットには影響しない可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="0fb4d55515faf0167f284803093db70ba6bdf600" translate="yes" xml:space="preserve">
          <source>If encapsulation is a required aspect for a language to be considered object oriented, then Rust meets that requirement. The option to use &lt;code&gt;pub&lt;/code&gt; or not for different parts of code enables encapsulation of implementation details.</source>
          <target state="translated">カプセル化が言語がオブジェクト指向と見なされるために必要な側面である場合、Rustはその要件を満たします。コードのさまざまな部分に &lt;code&gt;pub&lt;/code&gt; を使用するかどうかを選択するオプションにより、実装の詳細をカプセル化できます。</target>
        </trans-unit>
        <trans-unit id="f88c3e80e7b4d154c2577f1e634c78e02c1c42d5" translate="yes" xml:space="preserve">
          <source>If every type inside a tuple implements one of the following traits, then a tuple itself also implements it.</source>
          <target state="translated">タプル内のすべての型が以下の形質のいずれかを実装している場合、タプル自体もそれを実装していることになります。</target>
        </trans-unit>
        <trans-unit id="b8129e0ab4f408174bb11267c05f089405b50c77" translate="yes" xml:space="preserve">
          <source>If generic code merely needs to work for all types that can provide a reference to related type &lt;code&gt;T&lt;/code&gt;, it is often better to use &lt;a href=&quot;../convert/trait.asref&quot;&gt;&lt;code&gt;AsRef&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; as more types can safely implement it.</source>
          <target state="translated">一般的なコードが、関連する型 &lt;code&gt;T&lt;/code&gt; への参照を提供できるすべての型に対して機能する必要があるだけの場合、より多くの型が安全に実装できるため、&lt;a href=&quot;../convert/trait.asref&quot;&gt; &lt;code&gt;AsRef&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;を使用する方がよい場合がよくあります。</target>
        </trans-unit>
        <trans-unit id="281313906bc5aa3fa055587412d6aee7b2eda929" translate="yes" xml:space="preserve">
          <source>If generic code merely needs to work for all types that can provide a reference to related type &lt;code&gt;T&lt;/code&gt;, it is often better to use [&lt;code&gt;AsRef&amp;lt;T&amp;gt;&lt;/code&gt;] as more types can safely implement it.</source>
          <target state="translated">ジェネリックコードが、関連するタイプ &lt;code&gt;T&lt;/code&gt; への参照を提供できるすべてのタイプに対して機能する必要があるだけの場合は、より多くのタイプが安全に実装できるため、[ &lt;code&gt;AsRef&amp;lt;T&amp;gt;&lt;/code&gt; ]を使用する方がよい場合がよくあります。</target>
        </trans-unit>
        <trans-unit id="57c986c219a8db1074aab149e63ad254d155df91" translate="yes" xml:space="preserve">
          <source>If given a position, returns a reference to the element at that position or &lt;code&gt;None&lt;/code&gt; if out of bounds.</source>
          <target state="translated">位置を指定すると、その位置にある要素への参照を返します。範囲外の場合は &lt;code&gt;None&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="0807d56f2c6d8607e36641ca45b2207a499de182" translate="yes" xml:space="preserve">
          <source>If given a range, returns the subslice corresponding to that range, or &lt;code&gt;None&lt;/code&gt; if out of bounds.</source>
          <target state="translated">範囲を指定すると、その範囲に対応するサブスライスを返します。範囲外の場合は &lt;code&gt;None&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="dfe4ffb9dd92d20a6a4139ebde5c4444a81b450b" translate="yes" xml:space="preserve">
          <source>If interpreted as the number of actual hardware threads, it may undercount on Windows systems with more than 64 hardware threads. If interpreted as the available concurrency for that process, it may overcount on Windows systems when limited by a process wide affinity mask or job object limitations, and it may overcount on Linux systems when limited by a process wide affinity mask or affected by cgroups limits.</source>
          <target state="translated">実際のハードウェア・スレッドの数として解釈された場合、64 以上のハードウェア・スレッドを持つ Windows システムでは過小にカウントされる可能性があります。そのプロセスの利用可能な同時実行数として解釈された場合、プロセス幅の広いアフィニティマスクやジョブオブジェクトの制限によって制限されている場合は、Windows システムではカウントオーバーになる可能性があり、プロセス幅の広いアフィニティマスクによって制限されている場合や cgroups の制限の影響を受けている場合は、Linux システムではカウントオーバーになる可能性があります。</target>
        </trans-unit>
        <trans-unit id="c78c81075548342c17a3cb41f1d7c207afd16e82" translate="yes" xml:space="preserve">
          <source>If it does, add it to the list of values we&amp;rsquo;re returning.</source>
          <target state="translated">含まれている場合は、返される値のリストに追加します。</target>
        </trans-unit>
        <trans-unit id="6eb8349ae4604f3200e1b12d72175fa1292b930e" translate="yes" xml:space="preserve">
          <source>If it doesn&amp;rsquo;t, do nothing.</source>
          <target state="translated">そうでない場合は、何もしません。</target>
        </trans-unit>
        <trans-unit id="77f0c7f8e7e8804708118486c51110234f91b9ca" translate="yes" xml:space="preserve">
          <source>If it is not possible to align the pointer, the implementation returns &lt;code&gt;usize::MAX&lt;/code&gt;. It is permissible for the implementation to &lt;em&gt;always&lt;/em&gt; return &lt;code&gt;usize::MAX&lt;/code&gt;. Only your algorithm's performance can depend on getting a usable offset here, not its correctness.</source>
          <target state="translated">ポインタを揃えることができない場合、実装は &lt;code&gt;usize::MAX&lt;/code&gt; 返します。実装が&lt;em&gt;常に&lt;/em&gt; &lt;code&gt;usize::MAX&lt;/code&gt; 返すことは許容されます。アルゴリズムのパフォーマンスのみが、その正確さではなく、ここで使用可能なオフセットを取得することに依存する可能性があります。</target>
        </trans-unit>
        <trans-unit id="9651a04b746a289895c0ff4ac7dbbd9c6c4bd1d9" translate="yes" xml:space="preserve">
          <source>If it is not possible to align the pointer, the implementation returns &lt;code&gt;usize::max_value()&lt;/code&gt;.</source>
          <target state="translated">ポインタを揃えることができない場合、実装は &lt;code&gt;usize::max_value()&lt;/code&gt; 返します。</target>
        </trans-unit>
        <trans-unit id="36c410707c8ca092b792e6807c748e0afad6b271" translate="yes" xml:space="preserve">
          <source>If it's possible, hand-monomorphize the code by writing the function for each possible type substitution. It's possible to use traits to do this cleanly, for example:</source>
          <target state="translated">可能であれば、可能な型置換ごとに関数を記述することでコードをハンドモモーフィングします。これをきれいに行うには、例えば形質を使用することが可能です。</target>
        </trans-unit>
        <trans-unit id="8fae40cdb468d4e5d03de42a624dd09250a5c8c7" translate="yes" xml:space="preserve">
          <source>If less than &lt;code&gt;n&lt;/code&gt; elements are available, &lt;code&gt;take&lt;/code&gt; will limit itself to the size of the underlying iterator:</source>
          <target state="translated">使用可能な要素が &lt;code&gt;n&lt;/code&gt; 未満の場合、 &lt;code&gt;take&lt;/code&gt; は基になるイテレーターのサイズに制限されます。</target>
        </trans-unit>
        <trans-unit id="c0e5a61966add37320ef9414096df3e05db3ac2b" translate="yes" xml:space="preserve">
          <source>If more code were added between the construction of &lt;code&gt;String&lt;/code&gt; and the invocation of &lt;code&gt;mem::forget()&lt;/code&gt;, a panic within it would cause a double free because the same memory is handled by both &lt;code&gt;v&lt;/code&gt; and &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; の構築と &lt;code&gt;mem::forget()&lt;/code&gt; 呼び出しの間にコードが追加された場合、同じメモリが &lt;code&gt;v&lt;/code&gt; と &lt;code&gt;s&lt;/code&gt; の両方で処理されるため、コード内でパニックが発生すると、ダブルフリーが発生します。</target>
        </trans-unit>
        <trans-unit id="9fbc54548355fd2192a8ba719e27f659cd206c5b" translate="yes" xml:space="preserve">
          <source>If multiple patterns are used in the same arm for a &lt;code&gt;match&lt;/code&gt; expression, then an unspecified pattern will be used to determine the drop order.</source>
          <target state="translated">&lt;code&gt;match&lt;/code&gt; 式の同じアームで複数のパターンが使用されている場合、不特定のパターンがドロップ順序の決定に使用されます。</target>
        </trans-unit>
        <trans-unit id="8c4391f80fe19e3beba14af1b68f867a8deafde6" translate="yes" xml:space="preserve">
          <source>If necessary, you can circumvent this check using custom target specifications.</source>
          <target state="translated">必要に応じて、カスタムターゲット仕様を使用してこのチェックを回避することができます。</target>
        </trans-unit>
        <trans-unit id="7c94321a1ed561693d40d9b66f1f46aeaaecd3c4" translate="yes" xml:space="preserve">
          <source>If neither of the above env vars are set, then &lt;code&gt;Backtrace::capture&lt;/code&gt; will be disabled.</source>
          <target state="translated">上記の環境変数のいずれも設定されていない場合、 &lt;code&gt;Backtrace::capture&lt;/code&gt; は無効になります。</target>
        </trans-unit>
        <trans-unit id="b8e62341b0bd62d9e8cebd223a1dae7b6e2b460b" translate="yes" xml:space="preserve">
          <source>If neither of those rules apply, then the bounds on the trait are used:</source>
          <target state="translated">どちらのルールも適用されない場合は、形質の境界線が使用されます。</target>
        </trans-unit>
        <trans-unit id="f04e4c83d03462bae231d396fbd6bc133f04e581" translate="yes" xml:space="preserve">
          <source>If no custom hook is registered, the default hook will be returned.</source>
          <target state="translated">カスタムフックが登録されていない場合は、デフォルトフックが返されます。</target>
        </trans-unit>
        <trans-unit id="3ea6cae08b251d423319bdb503b4761220cd47ba" translate="yes" xml:space="preserve">
          <source>If no explicit implementation or negative implementation is written out for an auto trait for a given type, then the compiler implements it automatically according to the following rules:</source>
          <target state="translated">指定された型の自動形質に対して明示的な実装や否定的な実装が書き出されていない場合、コンパイラは以下のルールに従って自動的に実装します。</target>
        </trans-unit>
        <trans-unit id="5d4b1cf8f992f711595955dfbd04de1463c70def" translate="yes" xml:space="preserve">
          <source>If no strong pointers remain, this will return zero.</source>
          <target state="translated">強力なポインタが残っていない場合、これはゼロを返します。</target>
        </trans-unit>
        <trans-unit id="8f530d6d6508b49e7ed96395312e1b09be42668f" translate="yes" xml:space="preserve">
          <source>If not, just run closures one at a time:</source>
          <target state="translated">そうでない場合は、クローズを一つずつ実行すればいいだけです。</target>
        </trans-unit>
        <trans-unit id="6f7fa92522a250a6d3be880c3209e2e00d855d4b" translate="yes" xml:space="preserve">
          <source>If not, try to compute a mutual supertype of &lt;code&gt;T_t&lt;/code&gt; and &lt;code&gt;Ti&lt;/code&gt;, which will become the new target type.</source>
          <target state="translated">そうでない場合は、 &lt;code&gt;T_t&lt;/code&gt; と &lt;code&gt;Ti&lt;/code&gt; の相互スーパータイプを計算してみてください。これが新しいターゲットタイプになります。</target>
        </trans-unit>
        <trans-unit id="902fe9b3f2f74127ecf6007749394b452c7a24b7" translate="yes" xml:space="preserve">
          <source>If one of the arguments is NaN, then the other argument is returned.</source>
          <target state="translated">引数の一方がNaNであれば、もう一方の引数が返されます。</target>
        </trans-unit>
        <trans-unit id="fd66bf5358b1619dbf93c578d3488d32d0c0fca1" translate="yes" xml:space="preserve">
          <source>If one sequence is a prefix of another, the shorter sequence is lexicographically less than the other.</source>
          <target state="translated">あるシーケンスが他のシーケンスの接頭辞である場合、短いシーケンスは語彙的に他のシーケンスよりも少ない。</target>
        </trans-unit>
        <trans-unit id="7ae9dd3ada03870a6668bdcb11d4ca3933501dde" translate="yes" xml:space="preserve">
          <source>If only some methods aren't object-safe, you can add a &lt;code&gt;where Self: Sized&lt;/code&gt; bound on them to mark them as explicitly unavailable to trait objects. The functionality will still be available to all other implementers, including &lt;code&gt;Box&amp;lt;Trait&amp;gt;&lt;/code&gt; which is itself sized (assuming you &lt;code&gt;impl Trait for Box&amp;lt;Trait&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">一部のメソッドだけがオブジェクトセーフでない場合は、 &lt;code&gt;where Self: Sized&lt;/code&gt; をそれらにバインドして、トレイトオブジェクトに明示的に使用できないようにマークを付けることができます。機能はまだ含め、他のすべての実装に利用できるようになります &lt;code&gt;Box&amp;lt;Trait&amp;gt;&lt;/code&gt; （あなたと仮定自体はサイズのある &lt;code&gt;impl Trait for Box&amp;lt;Trait&amp;gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="df3400bc60a85af8ff3ace18e07d7c2d1864912a" translate="yes" xml:space="preserve">
          <source>If our project is a binary crate that only contains a &lt;em&gt;src/main.rs&lt;/em&gt; file and doesn&amp;rsquo;t have a &lt;em&gt;src/lib.rs&lt;/em&gt; file, we can&amp;rsquo;t create integration tests in the &lt;em&gt;tests&lt;/em&gt; directory and bring functions defined in the &lt;em&gt;src/main.rs&lt;/em&gt; file into scope with a &lt;code&gt;use&lt;/code&gt; statement. Only library crates expose functions that other crates can use; binary crates are meant to be run on their own.</source>
          <target state="translated">私たちのプロジェクトにのみ含まれているバイナリクレートの場合&lt;em&gt;はsrc / main.rsの&lt;/em&gt;ファイルをしていない&lt;em&gt;のsrc / lib.rsの&lt;/em&gt;ファイルを、私たちが統合テストを作成することはできません&lt;em&gt;テストの&lt;/em&gt;ディレクトリとで定義された関数をもたらす&lt;em&gt;のsrc /メインを.rs&lt;/em&gt;ファイルは、 &lt;code&gt;use&lt;/code&gt; ステートメントを使用してスコープにファイルします。ライブラリクレートのみが他のクレートが使用できる関数を公開します。バイナリクレートは、自分で実行するためのものです。</target>
        </trans-unit>
        <trans-unit id="e6324fa8ddd04d1618f1aebd83b3f76a15a2cd28" translate="yes" xml:space="preserve">
          <source>If our requirements change, and we also need to be able to traverse from &lt;code&gt;Owner&lt;/code&gt; to &lt;code&gt;Gadget&lt;/code&gt;, we will run into problems. An &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointer from &lt;code&gt;Owner&lt;/code&gt; to &lt;code&gt;Gadget&lt;/code&gt; introduces a cycle between the values. This means that their reference counts can never reach 0, and the values will remain allocated forever: a memory leak. In order to get around this, we can use &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers.</source>
          <target state="translated">要件が変更され、 &lt;code&gt;Owner&lt;/code&gt; から &lt;code&gt;Gadget&lt;/code&gt; にトラバースできるようにする必要がある場合、問題が発生します。 &lt;code&gt;Owner&lt;/code&gt; から &lt;code&gt;Gadget&lt;/code&gt; への&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt;ポインタは、値の間の循環を導入します。つまり、それらの参照カウントが0になることはなく、値は永久に割り当てられたままになります。つまり、メモリリークです。これを回避するために、&lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt;ポインタを使用できます。</target>
        </trans-unit>
        <trans-unit id="921a182084c11bc25c06cdc6fb33da8acc45c85b" translate="yes" xml:space="preserve">
          <source>If our requirements change, and we also need to be able to traverse from &lt;code&gt;Owner&lt;/code&gt; to &lt;code&gt;Gadget&lt;/code&gt;, we will run into problems. An &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointer from &lt;code&gt;Owner&lt;/code&gt; to &lt;code&gt;Gadget&lt;/code&gt; introduces a cycle. This means that their reference counts can never reach 0, and the allocation will never be destroyed: a memory leak. In order to get around this, we can use &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers.</source>
          <target state="translated">要件が変更され、 &lt;code&gt;Owner&lt;/code&gt; から &lt;code&gt;Gadget&lt;/code&gt; に移動できるようにする必要がある場合、問題が発生します。 &lt;code&gt;Owner&lt;/code&gt; から &lt;code&gt;Gadget&lt;/code&gt; への&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt;ポインターは、サイクルを導入します。これは、参照カウントが0に達することはなく、割り当てが破棄されることはないことを意味します。つまり、メモリリークです。これを回避するために、&lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt;ポインタを使用できます。</target>
        </trans-unit>
        <trans-unit id="9b786199b10d931840d1086948f15c121bb97b51" translate="yes" xml:space="preserve">
          <source>If parsing succeeds, return the value inside &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;, otherwise when the string is ill-formatted return an error specific to the inside &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt;. The error type is specific to implementation of the trait.</source>
          <target state="translated">解析が成功した場合は、&lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt;内の値を返します。それ以外の場合は、文字列の形式が正しくない場合、内部の&lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; に&lt;/a&gt;固有のエラーを返します。エラータイプは、トレイトの実装に固有です。</target>
        </trans-unit>
        <trans-unit id="1260ea15bf2742af82873380ef5cdc057469a6e9" translate="yes" xml:space="preserve">
          <source>If set, this option disables the Nagle algorithm. This means that segments are always sent as soon as possible, even if there is only a small amount of data. When not set, data is buffered until there is a sufficient amount to send out, thereby avoiding the frequent sending of small packets.</source>
          <target state="translated">設定されている場合、このオプションはNagleアルゴリズムを無効にします。これは、たとえ少量のデータしかなくても、セグメントは常に可能な限り早く送信されることを意味します。設定されていない場合は、送信するのに十分な量があるまでデータがバッファリングされるため、小さなパケットの頻繁な送信を避けることができます。</target>
        </trans-unit>
        <trans-unit id="0161295a4165e472097a556bd12e3cb8153ce739" translate="yes" xml:space="preserve">
          <source>If several elements are equally maximum, the last element is returned. If the iterator is empty, &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">複数の要素が最大の場合、最後の要素が返されます。イテレータが空の場合、&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;が返されます。</target>
        </trans-unit>
        <trans-unit id="949e58f9ba98c6ec3b36a7ff32fc3bb4b305461a" translate="yes" xml:space="preserve">
          <source>If several elements are equally minimum, the first element is returned. If the iterator is empty, &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">複数の要素が同等に最小の場合、最初の要素が返されます。イテレータが空の場合、&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;が返されます。</target>
        </trans-unit>
        <trans-unit id="b831b3eb60862f2e083acd74777a5de0ed02dd83" translate="yes" xml:space="preserve">
          <source>If someone calls your code and passes in values that don&amp;rsquo;t make sense, the best choice might be to call &lt;code&gt;panic!&lt;/code&gt; and alert the person using your library to the bug in their code so they can fix it during development. Similarly, &lt;code&gt;panic!&lt;/code&gt; is often appropriate if you&amp;rsquo;re calling external code that is out of your control and it returns an invalid state that you have no way of fixing.</source>
          <target state="translated">誰かがあなたのコードを呼び出し、意味のない値を渡す場合、最良の選択は &lt;code&gt;panic!&lt;/code&gt; を呼び出すことかもしれません！ライブラリを使用している人にコードのバグを警告して、開発中に修正できるようにします。同様に、 &lt;code&gt;panic!&lt;/code&gt; 制御できない外部コードを呼び出しており、修正の方法がない無効な状態を返す場合は、多くの場合適切です。</target>
        </trans-unit>
        <trans-unit id="acb94f3e0ba146c655ce1db4be8cf7e52d6ff088" translate="yes" xml:space="preserve">
          <source>If someone using our library decides to implement a &lt;code&gt;SelectBox&lt;/code&gt; struct that has &lt;code&gt;width&lt;/code&gt;, &lt;code&gt;height&lt;/code&gt;, and &lt;code&gt;options&lt;/code&gt; fields, they implement the &lt;code&gt;Draw&lt;/code&gt; trait on the &lt;code&gt;SelectBox&lt;/code&gt; type as well, as shown in Listing 17-8:</source>
          <target state="translated">ライブラリを使用する誰かが &lt;code&gt;width&lt;/code&gt; 、 &lt;code&gt;height&lt;/code&gt; 、および &lt;code&gt;options&lt;/code&gt; フィールドを持つ &lt;code&gt;SelectBox&lt;/code&gt; 構造体を実装することを決定した場合、リスト17-8に示すように、 &lt;code&gt;SelectBox&lt;/code&gt; タイプにも &lt;code&gt;Draw&lt;/code&gt; トレイトを実装します。</target>
        </trans-unit>
        <trans-unit id="c3e301e4e887fd636487b5cc6eb192ded20f6d8f" translate="yes" xml:space="preserve">
          <source>If successful, &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&lt;/code&gt;&lt;a href=&quot;struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt; is returned where the duration represents the amount of time elapsed from the specified measurement to this one.</source>
          <target state="translated">成功した場合、&lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&lt;/code&gt; &lt;a href=&quot;struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; &lt;code&gt;)&lt;/code&gt; が返されます。期間は、指定された測定からこの測定までに経過した時間を表します。</target>
        </trans-unit>
        <trans-unit id="89f232794c16a32779f42828429fca7b54b7471f" translate="yes" xml:space="preserve">
          <source>If successful, this function returns the number of bytes which were read and appended to &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">成功した場合、この関数は読み取られて &lt;code&gt;buf&lt;/code&gt; に追加されたバイト数を返します。</target>
        </trans-unit>
        <trans-unit id="dbb9443efd5c60b83bc142aff81add19921534e6" translate="yes" xml:space="preserve">
          <source>If successful, this function will return the total number of bytes read.</source>
          <target state="translated">成功した場合、この関数は読み込んだバイト数の合計を返します。</target>
        </trans-unit>
        <trans-unit id="8f3b4d7781f3d86f3d03470464550aa348524451" translate="yes" xml:space="preserve">
          <source>If taking ownership is not an option, using indices can work too:</source>
          <target state="translated">所有権を取得することがオプションではない場合は、インデックスを使用することもできます。</target>
        </trans-unit>
        <trans-unit id="bf999049465c29583e4954eb5930504df7197d78" translate="yes" xml:space="preserve">
          <source>If that field has type &lt;code&gt;Bar&amp;lt;T&amp;gt;&lt;/code&gt;, then &lt;code&gt;Bar&amp;lt;T&amp;gt;&lt;/code&gt; implements &lt;code&gt;Unsized&amp;lt;Bar&amp;lt;U&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">そのフィールドのタイプが &lt;code&gt;Bar&amp;lt;T&amp;gt;&lt;/code&gt; 場合、 &lt;code&gt;Bar&amp;lt;T&amp;gt;&lt;/code&gt; は &lt;code&gt;Unsized&amp;lt;Bar&amp;lt;U&amp;gt;&amp;gt;&lt;/code&gt; 実装します。</target>
        </trans-unit>
        <trans-unit id="9156e468bccd98925a16dabd42948c9bf77880b3" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;struct.receiver&quot;&gt;&lt;code&gt;Receiver&lt;/code&gt;&lt;/a&gt; is disconnected while trying to &lt;a href=&quot;struct.sender#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; with the &lt;a href=&quot;struct.sender&quot;&gt;&lt;code&gt;Sender&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;struct.sender#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; method will return a &lt;a href=&quot;struct.senderror&quot;&gt;&lt;code&gt;SendError&lt;/code&gt;&lt;/a&gt;. Similarly, if the &lt;a href=&quot;struct.sender&quot;&gt;&lt;code&gt;Sender&lt;/code&gt;&lt;/a&gt; is disconnected while trying to &lt;a href=&quot;struct.receiver#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;struct.receiver#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt; method will return a &lt;a href=&quot;struct.recverror&quot;&gt;&lt;code&gt;RecvError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">場合は&lt;a href=&quot;struct.receiver&quot;&gt; &lt;code&gt;Receiver&lt;/code&gt; &lt;/a&gt;しようとしているときに切断された&lt;a href=&quot;struct.sender#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt;で&lt;a href=&quot;struct.sender&quot;&gt; &lt;code&gt;Sender&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;struct.sender#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt;方法が返されます&lt;a href=&quot;struct.senderror&quot;&gt; &lt;code&gt;SendError&lt;/code&gt; &lt;/a&gt;。場合同様、&lt;a href=&quot;struct.sender&quot;&gt; &lt;code&gt;Sender&lt;/code&gt; &lt;/a&gt;にしようとしたときに切断され&lt;a href=&quot;struct.receiver#method.recv&quot;&gt; &lt;code&gt;recv&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;struct.receiver#method.recv&quot;&gt; &lt;code&gt;recv&lt;/code&gt; &lt;/a&gt;方法が返され&lt;a href=&quot;struct.recverror&quot;&gt; &lt;code&gt;RecvError&lt;/code&gt; を&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="84c875b11ce397c9d5300f965f6f873d7aacf46f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;documentation&lt;/code&gt; environment variable is not defined, you'll get the following error:</source>
          <target state="translated">&lt;code&gt;documentation&lt;/code&gt; 環境変数が定義されていない場合、次のエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="772ba2d0efb42bb291361897234d8c41bb1fcad0" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;move&lt;/code&gt; keyword is used, then all captures are by move or, for &lt;code&gt;Copy&lt;/code&gt; types, by copy, regardless of whether a borrow would work. The &lt;code&gt;move&lt;/code&gt; keyword is usually used to allow the closure to outlive the captured values, such as if the closure is being returned or used to spawn a new thread.</source>
          <target state="translated">&lt;code&gt;move&lt;/code&gt; キーワードを使用する場合、借用が機能するかどうかに関係なく、すべてのキャプチャは移動によるか、 &lt;code&gt;Copy&lt;/code&gt; タイプの場合はコピーによるものです。 &lt;code&gt;move&lt;/code&gt; キーワードは通常閉鎖は、閉鎖を返すか、新しいスレッドを生成するために使用されているかのように取り込まれた値を、より長生きすることを可能にするために使用されます。</target>
        </trans-unit>
        <trans-unit id="9d0e8d596c36d8fd761ca63dbd3e067a9bd6e058" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;panic!&lt;/code&gt; macro from the &lt;code&gt;core&lt;/code&gt; crate (not from &lt;code&gt;std&lt;/code&gt;) was used with a formatting string and some additional arguments, returns that message ready to be used for example with &lt;a href=&quot;../fmt/fn.write&quot;&gt;&lt;code&gt;fmt::write&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;panic!&lt;/code&gt; なら！ &lt;code&gt;core&lt;/code&gt; クレートからのマクロ（ &lt;code&gt;std&lt;/code&gt; からではなく）がフォーマット文字列といくつかの追加の引数と共に使用され、たとえば&lt;a href=&quot;../fmt/fn.write&quot;&gt; &lt;code&gt;fmt::write&lt;/code&gt; &lt;/a&gt;で使用する準備ができているメッセージを返します</target>
        </trans-unit>
        <trans-unit id="1aa7728f06aa3a7a4db7dd1c33587c7078d8308d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;push_str&lt;/code&gt; method took ownership of &lt;code&gt;s2&lt;/code&gt;, we wouldn&amp;rsquo;t be able to print its value on the last line. However, this code works as we&amp;rsquo;d expect!</source>
          <target state="translated">&lt;code&gt;push_str&lt;/code&gt; メソッドが &lt;code&gt;s2&lt;/code&gt; の所有権を取得した場合、その値を最終行に出力できません。ただし、このコードは期待どおりに機能します。</target>
        </trans-unit>
        <trans-unit id="dced1236ce3e008b86324aaba64ac8eb311fb832" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;self&lt;/code&gt; parameter is prefixed with &lt;code&gt;mut&lt;/code&gt;, it becomes a mutable variable, similar to regular parameters using a &lt;code&gt;mut&lt;/code&gt;&lt;a href=&quot;../patterns#identifier-patterns&quot;&gt;identifier pattern&lt;/a&gt;. For example:</source>
          <target state="translated">場合 &lt;code&gt;self&lt;/code&gt; パラメータが付いている &lt;code&gt;mut&lt;/code&gt; は、使用規則的なパラメータと同様変更可能な変数となる &lt;code&gt;mut&lt;/code&gt; &lt;a href=&quot;../patterns#identifier-patterns&quot;&gt;識別子パターン&lt;/a&gt;。例えば：</target>
        </trans-unit>
        <trans-unit id="7d8f23d79fbc7e291c341b29a3b5a67aa2ad2d40" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;size&lt;/code&gt; is less than the current file's size, then the file will be shrunk. If it is greater than the current file's size, then the file will be extended to &lt;code&gt;size&lt;/code&gt; and have all of the intermediate data filled in with 0s.</source>
          <target state="translated">場合は &lt;code&gt;size&lt;/code&gt; 小さい、現在のファイルのサイズよりも、そのファイルが縮小されます。現在のファイルのサイズより大きい場合、ファイルは &lt;code&gt;size&lt;/code&gt; まで拡張され、すべての中間データが0で埋められます。</target>
        </trans-unit>
        <trans-unit id="d57ee1700b4eb4f8d7a231756f83fc0d2f0976ae" translate="yes" xml:space="preserve">
          <source>If the access could not be granted at this time, then &lt;code&gt;Err&lt;/code&gt; is returned. Otherwise, an RAII guard is returned which will release the shared access when it is dropped.</source>
          <target state="translated">この時点でアクセスを許可できなかった場合は、 &lt;code&gt;Err&lt;/code&gt; が返されます。それ以外の場合、RAIIガードが返され、ドロップされたときに共有アクセスが解放されます。</target>
        </trans-unit>
        <trans-unit id="21bd5a18cb6b77fd8278b94aa3db19219a263b12" translate="yes" xml:space="preserve">
          <source>If the actual type neither requires drop glue nor implements &lt;code&gt;Copy&lt;/code&gt;, then may return &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">実際の型がドロップグルーを必要としないか、 &lt;code&gt;Copy&lt;/code&gt; を実装していない場合、 &lt;code&gt;true&lt;/code&gt; または &lt;code&gt;false&lt;/code&gt; を返すことがあります。</target>
        </trans-unit>
        <trans-unit id="b0291a87b80d4892b3b8beac10c94678155d9e30" translate="yes" xml:space="preserve">
          <source>If the actual type neither requires drop glue nor implements &lt;code&gt;Copy&lt;/code&gt;, then the return value of this function is unspecified.</source>
          <target state="translated">実際の型がドロップグルーを必要とせず、 &lt;code&gt;Copy&lt;/code&gt; 実装していない場合、この関数の戻り値は指定されていません。</target>
        </trans-unit>
        <trans-unit id="fc42b30b1c7732695b4b3457f14e9c116c60ba57" translate="yes" xml:space="preserve">
          <source>If the address different between the two pointers is not a multiple of &lt;code&gt;mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; then the result of the division is rounded towards zero.</source>
          <target state="translated">2つのポインター間で異なるアドレスが &lt;code&gt;mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; 倍数でない場合、除算の結果はゼロに向かって丸められます。</target>
        </trans-unit>
        <trans-unit id="521a07de2e3c6e68db23d9d0aa394b57d65a9c91" translate="yes" xml:space="preserve">
          <source>If the array has 32 or fewer elements (see above), you can also use the array reference's &lt;a href=&quot;iter/trait.intoiterator&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt; implementation:</source>
          <target state="translated">配列の要素数が32以下の場合（上記を参照）、配列参照の&lt;a href=&quot;iter/trait.intoiterator&quot;&gt; &lt;code&gt;IntoIterator&lt;/code&gt; &lt;/a&gt;実装を使用することもできます。</target>
        </trans-unit>
        <trans-unit id="cfb58ffddaf17c8830de11935999affae3277e66" translate="yes" xml:space="preserve">
          <source>If the author information that Cargo obtained from your environment is not correct, fix that in the file and save it again.</source>
          <target state="translated">カーゴが自分の環境から取得した著者情報が間違っている場合は、ファイル内で修正し、再度保存してください。</target>
        </trans-unit>
        <trans-unit id="ff4681586c0fae7d47f1330c0decf48c60236eb4" translate="yes" xml:space="preserve">
          <source>If the buffer contains no data, this will never call &lt;a href=&quot;trait.write#method.write_vectored&quot;&gt;&lt;code&gt;write_vectored&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">バッファにデータが含まれていない場合、これは&lt;a href=&quot;trait.write#method.write_vectored&quot;&gt; &lt;code&gt;write_vectored&lt;/code&gt; を&lt;/a&gt;呼び出すことはありません。</target>
        </trans-unit>
        <trans-unit id="9e707e84e6d9e2a09dcbe7b44964291bac9543c0" translate="yes" xml:space="preserve">
          <source>If the buffer contains no data, this will never call &lt;a href=&quot;trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">バッファにデータが含まれていない場合、これは&lt;a href=&quot;trait.write#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; を&lt;/a&gt;呼び出すことはありません。</target>
        </trans-unit>
        <trans-unit id="2baf63139a4a500a73ca143a78e4d4794de4fa4c" translate="yes" xml:space="preserve">
          <source>If the call to &lt;code&gt;poll&lt;/code&gt; returns &lt;a href=&quot;../../std/task/enum.poll#variant.Pending&quot;&gt;&lt;code&gt;Poll::Pending&lt;/code&gt;&lt;/a&gt;, then the future returns &lt;code&gt;Poll::Pending&lt;/code&gt;, suspending its state so that, when the surrounding async context is re-polled, execution returns to step 2;</source>
          <target state="translated">&lt;code&gt;poll&lt;/code&gt; の呼び出しが&lt;a href=&quot;../../std/task/enum.poll#variant.Pending&quot;&gt; &lt;code&gt;Poll::Pending&lt;/code&gt; &lt;/a&gt;返す場合、futureは &lt;code&gt;Poll::Pending&lt;/code&gt; 返し、その状態を一時停止して、周囲の非同期コンテキストが再ポーリングされたときに実行がステップ2に戻るようにします。</target>
        </trans-unit>
        <trans-unit id="65f8dad0e6e0ed1617e67254f63f3538d64e8eee" translate="yes" xml:space="preserve">
          <source>If the capacity overflows &lt;code&gt;usize&lt;/code&gt;, or the allocator reports a failure, then an error is returned.</source>
          <target state="translated">容量が &lt;code&gt;usize&lt;/code&gt; をオーバーフローした場合、またはアロケータが障害を報告した場合、エラーが返されます。</target>
        </trans-unit>
        <trans-unit id="a413f73c6a00e8ec27d7656a64c0041d810a18fb" translate="yes" xml:space="preserve">
          <source>If the capacity overflows, or the allocator reports a failure, then an error is returned.</source>
          <target state="translated">容量がオーバーフローした場合、またはアロケータが失敗を報告した場合、エラーが返されます。</target>
        </trans-unit>
        <trans-unit id="d22b2ac0a0ad8bf3c9d2af95eda6c6dcbfb7f5e8" translate="yes" xml:space="preserve">
          <source>If the child has exited, then &lt;code&gt;Ok(Some(status))&lt;/code&gt; is returned. If the exit status is not available at this time then &lt;code&gt;Ok(None)&lt;/code&gt; is returned. If an error occurs, then that error is returned.</source>
          <target state="translated">子が終了した場合、 &lt;code&gt;Ok(Some(status))&lt;/code&gt; が返されます。この時点で終了ステータスを取得できない場合、 &lt;code&gt;Ok(None)&lt;/code&gt; が返されます。エラーが発生すると、そのエラーが返されます。</target>
        </trans-unit>
        <trans-unit id="1f183ab05bb99521927fd36b3e847b7c523cd3b5" translate="yes" xml:space="preserve">
          <source>If the child thread panics, &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned with the parameter given to &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">子スレッドがパニックになると、&lt;a href=&quot;../macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt;指定されたパラメーターとともに&lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;が返されます。。</target>
        </trans-unit>
        <trans-unit id="c11de405bba2eb95a67f5ddf98e8d367a826811a" translate="yes" xml:space="preserve">
          <source>If the child thread panics, &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned with the parameter given to &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">子スレッドがパニックになると、&lt;a href=&quot;../macro.panic&quot;&gt; &lt;code&gt;panic&lt;/code&gt; に&lt;/a&gt;指定されたパラメーターとともに&lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;が返されます。</target>
        </trans-unit>
        <trans-unit id="611996f7840618a761ac96c392b8f31568d8ec31" translate="yes" xml:space="preserve">
          <source>If the closure can't outlive the value being moved, try using a reference rather than moving:</source>
          <target state="translated">クロージャが移動される値を長持ちさせることができない場合は、移動ではなく参照を使用してみてください。</target>
        </trans-unit>
        <trans-unit id="0f3013a1be5e1908d0fd59aee1eeb2a1559501d9" translate="yes" xml:space="preserve">
          <source>If the closure returns &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some(element)&lt;/code&gt;&lt;/a&gt;, then that element is returned.</source>
          <target state="translated">クロージャが&lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some(element)&lt;/code&gt; を&lt;/a&gt;返す場合、その要素が返されます。</target>
        </trans-unit>
        <trans-unit id="1cc29c4e531aec77355dc3263edbde0e02717ace" translate="yes" xml:space="preserve">
          <source>If the closure returns true, the element is removed from the map and yielded. If the closure returns false, or panics, the element remains in the map and will not be yielded.</source>
          <target state="translated">閉鎖が true を返す場合、要素はマップから削除され、生成されます。閉鎖が false を返すか、パニックに陥った場合、要素はマップ内に残り、生成されません。</target>
        </trans-unit>
        <trans-unit id="bb67b7c500cdec79f1ce3d7841c806209783608e" translate="yes" xml:space="preserve">
          <source>If the closure returns true, then the element is removed and yielded. If the closure returns false, the element will remain in the list and will not be yielded by the iterator.</source>
          <target state="translated">クロージャが真を返す場合、要素は削除されて降伏します。クロージャが false を返した場合、その要素はリストに残り、イテレータによって生成されません。</target>
        </trans-unit>
        <trans-unit id="6dd010d31dbb3764b4ed75ed86f6e32953c1d0d8" translate="yes" xml:space="preserve">
          <source>If the closure returns true, then the element is removed and yielded. If the closure returns false, the element will remain in the vector and will not be yielded by the iterator.</source>
          <target state="translated">クロージャが真を返す場合、要素は削除されて降伏します。クロージャが false を返した場合、要素はベクトル内に残り、イテレータによって生成されません。</target>
        </trans-unit>
        <trans-unit id="2a139e146ec9f48fd19a95af86148618a4801924" translate="yes" xml:space="preserve">
          <source>If the closure returns true, then the value is removed and yielded. If the closure returns false, the value will remain in the list and will not be yielded by the iterator.</source>
          <target state="translated">クロージャが真を返した場合、値は削除されて降伏します。クロージャが false を返した場合、値はリストに残り、イテレータによって生成されません。</target>
        </trans-unit>
        <trans-unit id="214ba23b863f161492d3f9635dec38066733211c" translate="yes" xml:space="preserve">
          <source>If the contents of the &lt;code&gt;CStr&lt;/code&gt; are valid UTF-8 data, this function will return a &lt;a href=&quot;../borrow/enum.cow&quot;&gt;&lt;code&gt;Cow&lt;/code&gt;&lt;/a&gt;&lt;code&gt;::&lt;/code&gt;&lt;a href=&quot;../borrow/enum.cow#variant.Borrowed&quot;&gt;&lt;code&gt;Borrowed&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&lt;/code&gt;&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt; with the corresponding &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; slice. Otherwise, it will replace any invalid UTF-8 sequences with &lt;a href=&quot;../char/constant.replacement_character&quot;&gt;&lt;code&gt;U+FFFD REPLACEMENT CHARACTER&lt;/code&gt;&lt;/a&gt; and return a &lt;a href=&quot;../borrow/enum.cow&quot;&gt;&lt;code&gt;Cow&lt;/code&gt;&lt;/a&gt;&lt;code&gt;::&lt;/code&gt;&lt;a href=&quot;../borrow/enum.cow#variant.Owned&quot;&gt;&lt;code&gt;Owned&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&lt;/code&gt;&lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt; with the result.</source>
          <target state="translated">&lt;code&gt;CStr&lt;/code&gt; の内容が有効なUTF-8データである場合、この関数は、対応する&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt;スライスとともに&lt;a href=&quot;../borrow/enum.cow&quot;&gt; &lt;code&gt;Cow&lt;/code&gt; &lt;/a&gt; &lt;code&gt;::&lt;/code&gt; &lt;a href=&quot;../borrow/enum.cow#variant.Borrowed&quot;&gt; &lt;code&gt;Borrowed&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&lt;/code&gt; &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; &lt;code&gt;)&lt;/code&gt; を返します。それ以外の場合は、無効なUTF-8シーケンスを&lt;a href=&quot;../char/constant.replacement_character&quot;&gt; &lt;code&gt;U+FFFD REPLACEMENT CHARACTER&lt;/code&gt; に置き換え&lt;/a&gt;、結果とともに&lt;a href=&quot;../borrow/enum.cow&quot;&gt; &lt;code&gt;Cow&lt;/code&gt; &lt;/a&gt; &lt;code&gt;::&lt;/code&gt; &lt;a href=&quot;../borrow/enum.cow#variant.Owned&quot;&gt; &lt;code&gt;Owned&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&lt;/code&gt; &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; &lt;code&gt;)&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="31dba64d7d22c597dfce03fd7cdb2b9f96c2ab94" translate="yes" xml:space="preserve">
          <source>If the contents of the &lt;code&gt;CStr&lt;/code&gt; are valid UTF-8 data, this function will return a &lt;a href=&quot;../borrow/enum.cow&quot;&gt;&lt;code&gt;Cow&lt;/code&gt;&lt;/a&gt;&lt;code&gt;::&lt;/code&gt;&lt;a href=&quot;../borrow/enum.cow#variant.Borrowed&quot;&gt;&lt;code&gt;Borrowed&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&lt;/code&gt;[&lt;code&gt;&amp;amp;str&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt; with the corresponding [&lt;code&gt;&amp;amp;str&lt;/code&gt;] slice. Otherwise, it will replace any invalid UTF-8 sequences with &lt;a href=&quot;../char/constant.replacement_character&quot;&gt;&lt;code&gt;U+FFFD REPLACEMENT CHARACTER&lt;/code&gt;&lt;/a&gt; and return a &lt;a href=&quot;../borrow/enum.cow&quot;&gt;&lt;code&gt;Cow&lt;/code&gt;&lt;/a&gt;&lt;code&gt;::&lt;/code&gt;&lt;a href=&quot;../borrow/enum.cow#variant.Owned&quot;&gt;&lt;code&gt;Owned&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&lt;/code&gt;&lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt; with the result.</source>
          <target state="translated">&lt;code&gt;CStr&lt;/code&gt; の内容が有効なUTF-8データである場合、この関数は、対応する[ &lt;code&gt;&amp;amp;str&lt;/code&gt; ]スライスを持つ&lt;a href=&quot;../borrow/enum.cow&quot;&gt; &lt;code&gt;Cow&lt;/code&gt; &lt;/a&gt; &lt;code&gt;::&lt;/code&gt; &lt;a href=&quot;../borrow/enum.cow#variant.Borrowed&quot;&gt; &lt;code&gt;Borrowed&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&lt;/code&gt; [ &lt;code&gt;&amp;amp;str&lt;/code&gt; ] &lt;code&gt;)&lt;/code&gt; を返します。それ以外の場合は、無効なUTF-8シーケンスを&lt;a href=&quot;../char/constant.replacement_character&quot;&gt; &lt;code&gt;U+FFFD REPLACEMENT CHARACTER&lt;/code&gt; &lt;/a&gt;で置き換え、&lt;a href=&quot;../borrow/enum.cow&quot;&gt; &lt;code&gt;Cow&lt;/code&gt; &lt;/a&gt; &lt;code&gt;::&lt;/code&gt; &lt;a href=&quot;../borrow/enum.cow#variant.Owned&quot;&gt; &lt;code&gt;Owned&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&lt;/code&gt; &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; &lt;code&gt;)&lt;/code&gt; を結果とともに返します。</target>
        </trans-unit>
        <trans-unit id="db9461413b5ee9b4f01c463f0ad906b75913f24c" translate="yes" xml:space="preserve">
          <source>If the contents of the &lt;code&gt;CStr&lt;/code&gt; are valid UTF-8 data, this function will return the corresponding &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; slice. Otherwise, it will return an error with details of where UTF-8 validation failed.</source>
          <target state="translated">&lt;code&gt;CStr&lt;/code&gt; の内容が有効なUTF-8データである場合、この関数は対応する&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt;スライスを返します。それ以外の場合は、UTF-8検証が失敗した場所の詳細を含むエラーを返します。</target>
        </trans-unit>
        <trans-unit id="baae7bb665c0286cfaf2cbea5e20bdf6cf34d67d" translate="yes" xml:space="preserve">
          <source>If the contents of the &lt;code&gt;CStr&lt;/code&gt; are valid UTF-8 data, this function will return the corresponding &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; slice. Otherwise, it will return an error with details of where UTF-8 validation failed.</source>
          <target state="translated">&lt;code&gt;CStr&lt;/code&gt; の内容が有効なUTF-8データである場合、この関数は対応する&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt;スライスを返します。それ以外の場合は、UTF-8検証が失敗した場所の詳細を含むエラーが返されます。</target>
        </trans-unit>
        <trans-unit id="99bd91603a025b03597fd1f9cbdd0b5e23a815bb" translate="yes" xml:space="preserve">
          <source>If the corresponding &lt;a href=&quot;struct.sender&quot;&gt;&lt;code&gt;Sender&lt;/code&gt;&lt;/a&gt; has disconnected, or it disconnects while this call is blocking, this call will wake up and return &lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; to indicate that no more messages can ever be received on this channel. However, since channels are buffered, messages sent before the disconnect will still be properly received.</source>
          <target state="translated">対応する&lt;a href=&quot;struct.sender&quot;&gt; &lt;code&gt;Sender&lt;/code&gt; &lt;/a&gt;が切断された場合、またはこの呼び出しがブロックされている間に切断された場合、この呼び出しはウェイクアップし、このチャネルでこれ以上メッセージを受信できないことを示す&lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;を返します。ただし、チャネルはバッファリングされるため、切断前に送信されたメッセージは引き続き適切に受信されます。</target>
        </trans-unit>
        <trans-unit id="91ebc4eb9040370bb60e1b55cb245ed551a2b766" translate="yes" xml:space="preserve">
          <source>If the cursor is currently pointing to the &quot;ghost&quot; non-element then no element is removed and &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="translated">カーソルが現在「ゴースト」非要素を指している場合、要素は削除されず、 &lt;code&gt;None&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="4624b3463b579ff38cd7090e939e0664781afc4a" translate="yes" xml:space="preserve">
          <source>If the cursor is pointing at the &quot;ghost&quot; non-element then the entire contents of the &lt;code&gt;LinkedList&lt;/code&gt; are moved.</source>
          <target state="translated">カーソルが「ゴースト」非要素を指している場合、 &lt;code&gt;LinkedList&lt;/code&gt; のコンテンツ全体が移動されます。</target>
        </trans-unit>
        <trans-unit id="d335a3b2bd9233a3fbdf7c96e469f75d1c5e365d" translate="yes" xml:space="preserve">
          <source>If the cursor is pointing at the &quot;ghost&quot; non-element then the new element is inserted at the end of the &lt;code&gt;LinkedList&lt;/code&gt;.</source>
          <target state="translated">カーソルが「ゴースト」非要素を指している場合、新しい要素は &lt;code&gt;LinkedList&lt;/code&gt; の最後に挿入されます。</target>
        </trans-unit>
        <trans-unit id="31375a5dbf525938d61772845c72aab093fab9cf" translate="yes" xml:space="preserve">
          <source>If the cursor is pointing at the &quot;ghost&quot; non-element then the new element is inserted at the front of the &lt;code&gt;LinkedList&lt;/code&gt;.</source>
          <target state="translated">カーソルが「ゴースト」非要素を指している場合、新しい要素が &lt;code&gt;LinkedList&lt;/code&gt; の先頭に挿入されます。</target>
        </trans-unit>
        <trans-unit id="58963dd2948fd819f86fd5e461e02e99ecc3a20a" translate="yes" xml:space="preserve">
          <source>If the cursor is pointing at the &quot;ghost&quot; non-element then the new elements are inserted at the end of the &lt;code&gt;LinkedList&lt;/code&gt;.</source>
          <target state="translated">カーソルが「ゴースト」非要素を指している場合、新しい要素は &lt;code&gt;LinkedList&lt;/code&gt; の最後に挿入されます。</target>
        </trans-unit>
        <trans-unit id="6f945e6d3050ed5d918eb8a5e109487061da86ff" translate="yes" xml:space="preserve">
          <source>If the cursor is pointing at the &quot;ghost&quot; non-element then the new elements are inserted at the start of the &lt;code&gt;LinkedList&lt;/code&gt;.</source>
          <target state="translated">カーソルが「ゴースト」非要素を指している場合、新しい要素は &lt;code&gt;LinkedList&lt;/code&gt; の先頭に挿入されます。</target>
        </trans-unit>
        <trans-unit id="9708432e377fc3315ff2743a227e5ee6ae976fb7" translate="yes" xml:space="preserve">
          <source>If the cursor is pointing to the &quot;ghost&quot; non-element then this returns the first element of the &lt;code&gt;LinkedList&lt;/code&gt;. If it is pointing to the last element of the &lt;code&gt;LinkedList&lt;/code&gt; then this returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">カーソルが「ゴースト」非要素を指している場合、これは &lt;code&gt;LinkedList&lt;/code&gt; の最初の要素を返します。 &lt;code&gt;LinkedList&lt;/code&gt; の最後の要素を指している場合、これは &lt;code&gt;None&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="a515e2eb729ab1875351c8ecfe7942b25cd004cc" translate="yes" xml:space="preserve">
          <source>If the cursor is pointing to the &quot;ghost&quot; non-element then this returns the last element of the &lt;code&gt;LinkedList&lt;/code&gt;. If it is pointing to the first element of the &lt;code&gt;LinkedList&lt;/code&gt; then this returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">カーソルが「ゴースト」非要素を指している場合、これは &lt;code&gt;LinkedList&lt;/code&gt; の最後の要素を返します。 &lt;code&gt;LinkedList&lt;/code&gt; の最初の要素を指している場合、これは &lt;code&gt;None&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="a4bf96ffdc655962850c81ce839b17c859f11a67" translate="yes" xml:space="preserve">
          <source>If the cursor is pointing to the &quot;ghost&quot; non-element then this will move it to the first element of the &lt;code&gt;LinkedList&lt;/code&gt;. If it is pointing to the last element of the &lt;code&gt;LinkedList&lt;/code&gt; then this will move it to the &quot;ghost&quot; non-element.</source>
          <target state="translated">カーソルが「ゴースト」非要素を指している場合、これにより、カーソルが &lt;code&gt;LinkedList&lt;/code&gt; の最初の要素に移動します。 &lt;code&gt;LinkedList&lt;/code&gt; の最後の要素を指している場合、これはそれを「ゴースト」非要素に移動します。</target>
        </trans-unit>
        <trans-unit id="825c50dec4e26dcdffad5ec9a6866af450b9f9e9" translate="yes" xml:space="preserve">
          <source>If the cursor is pointing to the &quot;ghost&quot; non-element then this will move it to the last element of the &lt;code&gt;LinkedList&lt;/code&gt;. If it is pointing to the first element of the &lt;code&gt;LinkedList&lt;/code&gt; then this will move it to the &quot;ghost&quot; non-element.</source>
          <target state="translated">カーソルが「ゴースト」非要素を指している場合、これにより、カーソルは &lt;code&gt;LinkedList&lt;/code&gt; の最後の要素に移動します。 &lt;code&gt;LinkedList&lt;/code&gt; の最初の要素を指している場合、これはそれを「ゴースト」非要素に移動します。</target>
        </trans-unit>
        <trans-unit id="c9097bc3fc6399fb3bc83c93071781dffb279d65" translate="yes" xml:space="preserve">
          <source>If the data in this stream is &lt;em&gt;not&lt;/em&gt; valid UTF-8 then an error is returned and &lt;code&gt;buf&lt;/code&gt; is unchanged.</source>
          <target state="translated">このストリームのデータが有効なUTF-8で&lt;em&gt;ない&lt;/em&gt;場合、エラーが返され、 &lt;code&gt;buf&lt;/code&gt; は変更されません。</target>
        </trans-unit>
        <trans-unit id="10754b248a576fdba9d5228dc71f26ade299f007" translate="yes" xml:space="preserve">
          <source>If the definition of &lt;code&gt;foo&lt;/code&gt; is under your control, the simplest solution is to capture the data mutably. This can be done by defining &lt;code&gt;foo&lt;/code&gt; to take FnMut rather than Fn:</source>
          <target state="translated">&lt;code&gt;foo&lt;/code&gt; の定義がユーザーの管理下にある場合、最も簡単な解決策は、データを変更可能にキャプチャーすることです。これは、FnではなくFnMutを取るように &lt;code&gt;foo&lt;/code&gt; を定義することで実行できます。</target>
        </trans-unit>
        <trans-unit id="42bdc1ae118555b88ae881099abace5a191c0219" translate="yes" xml:space="preserve">
          <source>If the destination type is not part of the current crate then you can't implement &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; directly. For example, take this code:</source>
          <target state="translated">宛先タイプが現在のクレートの一部でない場合、&lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; を&lt;/a&gt;直接実装することはできません。たとえば、次のコードを見てください。</target>
        </trans-unit>
        <trans-unit id="587511482f256e8f952acfee186e5aefae6cf9ca" translate="yes" xml:space="preserve">
          <source>If the determination that the code is unreachable proves incorrect, the program immediately terminates with a &lt;a href=&quot;macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">コードに到達できないという決定が正しくない場合、プログラムはすぐに&lt;a href=&quot;macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt;終了します！。</target>
        </trans-unit>
        <trans-unit id="4c5ab8621c8a741eb7e90c657432848573f050ef" translate="yes" xml:space="preserve">
          <source>If the element type of the iterator you need does not implement &lt;code&gt;Clone&lt;/code&gt;, or if you do not want to keep the repeated element in memory, you can instead use the &lt;a href=&quot;fn.repeat_with&quot;&gt;&lt;code&gt;repeat_with()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">必要なイテレータの要素タイプが &lt;code&gt;Clone&lt;/code&gt; を実装していない場合、または繰り返される要素をメモリに保持したくない場合は、代わりに&lt;a href=&quot;fn.repeat_with&quot;&gt; &lt;code&gt;repeat_with()&lt;/code&gt; &lt;/a&gt;関数を使用できます。</target>
        </trans-unit>
        <trans-unit id="480ada98c1c5ece146ecdc077a3e40775d89fd0e" translate="yes" xml:space="preserve">
          <source>If the element type of the iterator you need does not implement &lt;code&gt;Clone&lt;/code&gt;, or if you do not want to keep the repeated element in memory, you can instead use the &lt;a href=&quot;fn.repeat_with&quot;&gt;&lt;code&gt;repeat_with&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">必要なイテレータの要素型が &lt;code&gt;Clone&lt;/code&gt; を実装していない場合、または繰り返し要素をメモリに保持したくない場合は、代わりに&lt;a href=&quot;fn.repeat_with&quot;&gt; &lt;code&gt;repeat_with&lt;/code&gt; &lt;/a&gt;関数を使用できます。</target>
        </trans-unit>
        <trans-unit id="156fcf0995b1088c12c501a80ad16ba6aab2c6f4" translate="yes" xml:space="preserve">
          <source>If the element type of the iterator you need implements &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;, and it is OK to keep the source element in memory, you should instead use the &lt;a href=&quot;fn.repeat&quot;&gt;&lt;code&gt;repeat()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">必要なイテレータの要素タイプが&lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; を&lt;/a&gt;実装していて、ソース要素をメモリに保持しても問題がない場合は、代わりに&lt;a href=&quot;fn.repeat&quot;&gt; &lt;code&gt;repeat()&lt;/code&gt; &lt;/a&gt;関数を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="3b5563e722ef79a66827ad237de3ff713088f72a" translate="yes" xml:space="preserve">
          <source>If the element type of the iterator you need implements &lt;code&gt;Clone&lt;/code&gt;, and it is OK to keep the source element in memory, you should instead use the &lt;a href=&quot;fn.repeat&quot;&gt;&lt;code&gt;repeat&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">必要なイテレータの要素タイプが &lt;code&gt;Clone&lt;/code&gt; を実装し、ソース要素をメモリに保持しても問題がない場合は、代わりに&lt;a href=&quot;fn.repeat&quot;&gt; &lt;code&gt;repeat&lt;/code&gt; &lt;/a&gt;関数を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="fdfbdf49a01ecb81ac4dd4acab163dbc68e7e8c0" translate="yes" xml:space="preserve">
          <source>If the environment variable is not defined, then a compilation error will be emitted. To not emit a compile error, use the &lt;a href=&quot;macro.option_env&quot;&gt;&lt;code&gt;option_env!&lt;/code&gt;&lt;/a&gt; macro instead.</source>
          <target state="translated">環境変数が定義されていない場合、コンパイルエラーが発生します。コンパイルエラーを出さないようにするには、&lt;a href=&quot;macro.option_env&quot;&gt; &lt;code&gt;option_env!&lt;/code&gt; &lt;/a&gt;代わりにマクロ。</target>
        </trans-unit>
        <trans-unit id="6e8972418288b27e60b8fafe88d7c99a7d59e984" translate="yes" xml:space="preserve">
          <source>If the executable was invoked through a symbolic link, some platforms will return the path of the symbolic link and other platforms will return the path of the symbolic link&amp;rsquo;s target.</source>
          <target state="translated">実行可能ファイルがシンボリックリンクを介して呼び出された場合、一部のプラットフォームはシンボリックリンクのパスを返し、他のプラットフォームはシンボリックリンクのターゲットのパスを返します。</target>
        </trans-unit>
        <trans-unit id="fd55e486394dd1866434bdc5faf39742bfb2a2d4" translate="yes" xml:space="preserve">
          <source>If the expression in one of these coercion sites is a coercion-propagating expression, then the relevant sub-expressions in that expression are also coercion sites. Propagation recurses from these new coercion sites. Propagating expressions and their relevant sub-expressions are:</source>
          <target state="translated">このように、このようにして得られた発現のうちの1つが強制伝播性の発現である場合には、その発現の関連するサブ発現も強制伝播性の発現である。そのためには、そのような情報が必要とされる。</target>
        </trans-unit>
        <trans-unit id="da06749df21ae19d99c10837b4fef8698354acfb" translate="yes" xml:space="preserve">
          <source>If the feature is accepted, an issue is opened on the Rust repository, and someone can implement it. The person who implements it very well may not be the person who proposed the feature in the first place! When the implementation is ready, it lands on the &lt;code&gt;master&lt;/code&gt; branch behind a feature gate, as we discussed in the &lt;a href=&quot;#unstable-features&quot;&gt;&amp;ldquo;Unstable Features&amp;rdquo;&lt;/a&gt; section.</source>
          <target state="translated">機能が受け入れられると、Rustリポジトリで問題が開かれ、誰かがそれを実装できます。それをうまく実装する人は、そもそも機能を提案した人ではないかもしれません！実装の準備ができると、&lt;a href=&quot;#unstable-features&quot;&gt;「不安定な機能」&lt;/a&gt;セクションで説明したように、機能ゲートの背後の &lt;code&gt;master&lt;/code&gt; ブランチに配置されます。</target>
        </trans-unit>
        <trans-unit id="3414a33407bd3dac73209f0f3c8c87238661b1ca" translate="yes" xml:space="preserve">
          <source>If the file already exists, any write calls on it will overwrite its contents, without truncating it.</source>
          <target state="translated">ファイルが既に存在している場合、そのファイルへの書き込み呼び出しは、ファイルを切り捨てずにその内容を上書きします。</target>
        </trans-unit>
        <trans-unit id="9132b3e3ab7219a34cb586c6f14321ce888d6773" translate="yes" xml:space="preserve">
          <source>If the first element is matched, an empty slice will be the first item returned by the iterator. Similarly, if the last element in the slice is matched, an empty slice will be the last item returned by the iterator:</source>
          <target state="translated">最初の要素がマッチした場合、空のスライスがイテレータによって返される最初の項目になります。同様に、スライスの最後の要素が一致した場合、空のスライスがイテレータによって返される最後の項目となります。</target>
        </trans-unit>
        <trans-unit id="a3fd11d96e62e4df934fdc1fa4662261ba86625c" translate="yes" xml:space="preserve">
          <source>If the given capacity is &lt;code&gt;0&lt;/code&gt;, no allocation will occur, and this method is identical to the &lt;a href=&quot;#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">指定された容量が &lt;code&gt;0&lt;/code&gt; の場合、割り当ては行われず、この方法は&lt;a href=&quot;#method.new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt;方法と同じです。</target>
        </trans-unit>
        <trans-unit id="c71e4086428a9289ae6841638f980514baf4e1e2" translate="yes" xml:space="preserve">
          <source>If the given capacity is &lt;code&gt;0&lt;/code&gt;, no allocation will occur, and this method is identical to the &lt;a href=&quot;struct.string#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">指定された容量が &lt;code&gt;0&lt;/code&gt; の場合、割り当ては発生せず、この方法は&lt;a href=&quot;struct.string#method.new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt;方法と同じです。</target>
        </trans-unit>
        <trans-unit id="c23f42fcc2aeb440c3d587979f6b3a221b95c0ef" translate="yes" xml:space="preserve">
          <source>If the given closure recursively invokes &lt;code&gt;call_once&lt;/code&gt; on the same &lt;a href=&quot;struct.once&quot;&gt;&lt;code&gt;Once&lt;/code&gt;&lt;/a&gt; instance the exact behavior is not specified, allowed outcomes are a panic or a deadlock.</source>
          <target state="translated">指定されたクロージャが同じ&lt;a href=&quot;struct.once&quot;&gt; &lt;code&gt;Once&lt;/code&gt; &lt;/a&gt;インスタンスで &lt;code&gt;call_once&lt;/code&gt; を再帰的に呼び出す場合、正確な動作が指定されていない場合、許可される結果はパニックまたはデッドロックです。</target>
        </trans-unit>
        <trans-unit id="3e650fcb37c79e73b248840291059fa9ab82facc" translate="yes" xml:space="preserve">
          <source>If the given closure recursively invokes &lt;code&gt;call_once&lt;/code&gt; on the same &lt;code&gt;Once&lt;/code&gt; instance the exact behavior is not specified, allowed outcomes are a panic or a deadlock.</source>
          <target state="translated">特定のクロージャーが同じ &lt;code&gt;Once&lt;/code&gt; インスタンスで &lt;code&gt;call_once&lt;/code&gt; を再帰的に呼び出す場合、正確な動作が指定されていない場合、許可される結果はパニックまたはデッドロックです。</target>
        </trans-unit>
        <trans-unit id="82cd743013a3edab20be44d34d8b246c9798bdd1" translate="yes" xml:space="preserve">
          <source>If the input isn't NaN, then there is no portability concern.</source>
          <target state="translated">入力がNaNでなければ、移植性の心配はありません。</target>
        </trans-unit>
        <trans-unit id="678a91cbb4ec06d73442b77832f91bad809fe51b" translate="yes" xml:space="preserve">
          <source>If the item is a function, you may use a closure:</source>
          <target state="translated">項目が関数の場合は、クロージャを使用することができます。</target>
        </trans-unit>
        <trans-unit id="3955594d420a5299baca31b21b74e398d9cdcfd9" translate="yes" xml:space="preserve">
          <source>If the item is modified then the worst case time complexity is &lt;em&gt;O&lt;/em&gt;(log(&lt;em&gt;n&lt;/em&gt;)), otherwise it's &lt;em&gt;O&lt;/em&gt;(1).</source>
          <target state="translated">アイテムが変更された場合、最悪の場合の時間計算量は&lt;em&gt;O&lt;/em&gt;（log（&lt;em&gt;n&lt;/em&gt;））であり、それ以外の場合は&lt;em&gt;O&lt;/em&gt;（1）です。</target>
        </trans-unit>
        <trans-unit id="4e29e02642c9eb9601c44c59f05b7d126f43b3f4" translate="yes" xml:space="preserve">
          <source>If the item is not defined in the current module, it must be imported using a &lt;code&gt;use&lt;/code&gt; statement, like so:</source>
          <target state="translated">アイテムが現在のモジュールで定義されていない場合は、次のように、 &lt;code&gt;use&lt;/code&gt; ステートメントを使用してインポートする必要があります。</target>
        </trans-unit>
        <trans-unit id="5030e30e9a190114fd41d37b0c1ba92d9eec8bbd" translate="yes" xml:space="preserve">
          <source>If the item you are importing is not defined in some super-module of the current module, then it must also be declared as public (e.g., &lt;code&gt;pub fn&lt;/code&gt;).</source>
          <target state="translated">インポートするアイテムが現在のモジュールのスーパーモジュールで定義されていない場合は、パブリックとしても宣言する必要があります（例： &lt;code&gt;pub fn&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="719a1576fd9e7210e99462a559c7958169595ce7" translate="yes" xml:space="preserve">
          <source>If the iterator is only partially consumed or not consumed at all, each of the remaining elements will still be subjected to the closure and removed and dropped if it returns true.</source>
          <target state="translated">イテレータが部分的にしか消費されなかったり、全く消費されなかったりした場合でも、残りの要素のそれぞれがクロージャの対象となり、それが真を返す場合は削除されてドロップされます。</target>
        </trans-unit>
        <trans-unit id="e4d63a01b8d322a8870de0053bcaa4759ed12bae" translate="yes" xml:space="preserve">
          <source>If the iterator is only partially consumed or not consumed at all, each of the remaining values will still be subjected to the closure and removed and dropped if it returns true.</source>
          <target state="translated">イテレータが部分的にしか消費されなかったり、全く消費されなかったりした場合でも、残りの値のそれぞれがクロージャの対象となり、それが真を返す場合には削除されてドロップされます。</target>
        </trans-unit>
        <trans-unit id="fc64622999ffaef4c074c0b3f6d2b93d8dbc840b" translate="yes" xml:space="preserve">
          <source>If the last element of the slice is matched, that element will be considered the terminator of the preceding slice. That slice will be the last item returned by the iterator.</source>
          <target state="translated">スライスの最後の要素がマッチした場合、その要素は前のスライスの終端とみなされます。そのスライスは、イテレータによって返された最後の項目となります。</target>
        </trans-unit>
        <trans-unit id="46e75edbffb14b1f9cbe211ae39152c93cbfb5b3" translate="yes" xml:space="preserve">
          <source>If the last element of the string is matched, that element will be considered the terminator of the preceding substring. That substring will be the last item returned by the iterator.</source>
          <target state="translated">文字列の最後の要素がマッチした場合、その要素は先行する部分文字列の終端とみなされます。その部分文字列は、イテレータによって返される最後の項目となります。</target>
        </trans-unit>
        <trans-unit id="6c2eb24f388c4f9da46dc55e06c2973845737ad4" translate="yes" xml:space="preserve">
          <source>If the length doesn't match, the input comes back in &lt;code&gt;Err&lt;/code&gt;:</source>
          <target state="translated">長さが一致しない場合、入力は &lt;code&gt;Err&lt;/code&gt; に戻ります。</target>
        </trans-unit>
        <trans-unit id="c7f0b78af6a1f2b8da54724cc60c89fb090afb8c" translate="yes" xml:space="preserve">
          <source>If the lifetime of a reference isn't enough, such as in the case of threading, consider using an &lt;code&gt;Arc&lt;/code&gt; to create a reference-counted value:</source>
          <target state="translated">スレッドの場合など、参照の有効期間が十分でない場合は、 &lt;code&gt;Arc&lt;/code&gt; を使用して参照カウント値を作成することを検討してください。</target>
        </trans-unit>
        <trans-unit id="0e305a8484a9cd9dc5c8361f54c572219ec9804c" translate="yes" xml:space="preserve">
          <source>If the lock could not be acquired at this time, then &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned. Otherwise, an RAII guard is returned. The lock will be unlocked when the guard is dropped.</source>
          <target state="translated">この時点でロックを取得できなかった場合は、&lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;が返されます。それ以外の場合、RAIIガードが返されます。ガードが下がるとロックが解除されます。</target>
        </trans-unit>
        <trans-unit id="f8b222d65f3e5a011a407bdb03d5df29adfec456" translate="yes" xml:space="preserve">
          <source>If the lock could not be acquired at this time, then &lt;code&gt;Err&lt;/code&gt; is returned. Otherwise, an RAII guard is returned which will release the lock when it is dropped.</source>
          <target state="translated">この時点でロックを取得できなかった場合は、 &lt;code&gt;Err&lt;/code&gt; が返されます。それ以外の場合、RAIIガードが返され、ドロップするとロックが解除されます。</target>
        </trans-unit>
        <trans-unit id="ecf781a8afe2a0c63a1d40b96befbc6c4dce088d" translate="yes" xml:space="preserve">
          <source>If the main thread panics it will terminate all your threads and end your program with code &lt;code&gt;101&lt;/code&gt;.</source>
          <target state="translated">メインスレッドがパニックになると、すべてのスレッドが終了し、プログラムがコード &lt;code&gt;101&lt;/code&gt; で終了します。</target>
        </trans-unit>
        <trans-unit id="fedf3b811ad1f7726933bad19dd231acecc809fc" translate="yes" xml:space="preserve">
          <source>If the map did have this key present, the value is updated, and the old value is returned. The key is not updated, though; this matters for types that can be &lt;code&gt;==&lt;/code&gt; without being identical. See the &lt;a href=&quot;../index#insert-and-complex-keys&quot;&gt;module-level documentation&lt;/a&gt; for more.</source>
          <target state="translated">マップにこのキーが存在する場合、値が更新され、古い値が返されます。ただし、キーは更新されません。これは、同一でなくても &lt;code&gt;==&lt;/code&gt; になる可能性のあるタイプにとって重要です。詳細については、&lt;a href=&quot;../index#insert-and-complex-keys&quot;&gt;モジュールレベルのドキュメント&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="d96d894c9cb755e3982e02a5fa557e27c759b559" translate="yes" xml:space="preserve">
          <source>If the map did have this key present, the value is updated, and the old value is returned. The key is not updated, though; this matters for types that can be &lt;code&gt;==&lt;/code&gt; without being identical. See the &lt;a href=&quot;index#insert-and-complex-keys&quot;&gt;module-level documentation&lt;/a&gt; for more.</source>
          <target state="translated">マップにこのキーが存在した場合、値が更新され、古い値が返されます。ただし、キーは更新されません。これは、同一でなくても &lt;code&gt;==&lt;/code&gt; になる可能性のある型にとって重要です。詳細については、&lt;a href=&quot;index#insert-and-complex-keys&quot;&gt;モジュールレベルのドキュメント&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="a660d0d730c1d18357284ffbb42b24c56c1fea09" translate="yes" xml:space="preserve">
          <source>If the map did not have this key present, &lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">マップにこのキーが存在しない場合、&lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;が返されます。</target>
        </trans-unit>
        <trans-unit id="22fc8ad8eb7527fa9d4557d1bcf87a2d2bd7edcb" translate="yes" xml:space="preserve">
          <source>If the map did not have this key present, &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">マップにこのキーが存在しない場合、&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;が返されます。</target>
        </trans-unit>
        <trans-unit id="ce6ece3326d8becac91cb49d0dcc5a346e703bba" translate="yes" xml:space="preserve">
          <source>If the map did not have this key present, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="translated">マップにこのキーが存在しない場合、 &lt;code&gt;None&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="c00b93ea8ff90e66022ac61d150c9d932705572a" translate="yes" xml:space="preserve">
          <source>If the named environment variable is present at compile time, this will expand into an expression of type &lt;code&gt;Option&amp;lt;&amp;amp;'static str&amp;gt;&lt;/code&gt; whose value is &lt;code&gt;Some&lt;/code&gt; of the value of the environment variable. If the environment variable is not present, then this will expand to &lt;code&gt;None&lt;/code&gt;. See &lt;a href=&quot;option/enum.option&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; for more information on this type.</source>
          <target state="translated">名前の環境変数はコンパイル時に存在している場合、これは、型の表現に展開されます &lt;code&gt;Option&amp;lt;&amp;amp;'static str&amp;gt;&lt;/code&gt; 値である &lt;code&gt;Some&lt;/code&gt; 環境変数の値の。環境変数が存在しない場合、これは &lt;code&gt;None&lt;/code&gt; に展開されます。このタイプの詳細については、&lt;a href=&quot;option/enum.option&quot;&gt; &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="a6575b526f3c9f6ff8f51c0abc90eb128dc80c26" translate="yes" xml:space="preserve">
          <source>If the number of elements in the pattern doesn&amp;rsquo;t match the number of elements in the tuple, the overall type won&amp;rsquo;t match and we&amp;rsquo;ll get a compiler error. For example, Listing 18-5 shows an attempt to destructure a tuple with three elements into two variables, which won&amp;rsquo;t work.</source>
          <target state="translated">パターンの要素の数がタプルの要素の数と一致しない場合、全体の型が一致せず、コンパイラエラーが発生します。たとえば、リスト18-5は、3つの要素を持つタプルを2つの変数に分解する試みを示していますが、これは機能しません。</target>
        </trans-unit>
        <trans-unit id="0d2c1202b42295052cad83d3a70ac58e5c8cc86e" translate="yes" xml:space="preserve">
          <source>If the number of hardware threads is not known for the target platform.</source>
          <target state="translated">ターゲットプラットフォームのハードウェアスレッド数がわからない場合。</target>
        </trans-unit>
        <trans-unit id="d5f255ea3f66f81885c9b2fd50418cdf94440a9b" translate="yes" xml:space="preserve">
          <source>If the number of nanoseconds is greater than 1 billion (the number of nanoseconds in a second), then it will carry over into the seconds provided.</source>
          <target state="translated">ナノ秒数が10億(1秒間のナノ秒数)を超える場合は、提供された秒数に繰り越されます。</target>
        </trans-unit>
        <trans-unit id="c7b893dcc899fca09569911e017ff49f116f8bab" translate="yes" xml:space="preserve">
          <source>If the option already contains a value, the old value is dropped.</source>
          <target state="translated">オプシ ョ ンに既に値が含まれている場合は、 古い値は削除されます。</target>
        </trans-unit>
        <trans-unit id="7587948fbc56d5936df283dc95c30a87905bc378" translate="yes" xml:space="preserve">
          <source>If the path is a normal file, this is the file name. If it's the path of a directory, this is the directory name.</source>
          <target state="translated">パスが通常のファイルの場合は、これがファイル名になります。ディレクトリのパスであれば、これはディレクトリ名です。</target>
        </trans-unit>
        <trans-unit id="a7ef120bc4e6081962026d321af347e6c4f9a831" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;#method.rmatch_indices&quot;&gt;&lt;code&gt;rmatch_indices&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">パターンで逆検索が可能であるが、その結果が順方向検索と異なる場合は、&lt;a href=&quot;#method.rmatch_indices&quot;&gt; &lt;code&gt;rmatch_indices&lt;/code&gt; &lt;/a&gt;メソッドを使用できます。</target>
        </trans-unit>
        <trans-unit id="04680e781abdf689365df53a980b052d9694289c" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;#method.rmatches&quot;&gt;&lt;code&gt;rmatches&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">パターンが逆方向検索を許可しているが、その結果が順方向検索と異なる場合は、&lt;a href=&quot;#method.rmatches&quot;&gt; &lt;code&gt;rmatches&lt;/code&gt; &lt;/a&gt;メソッドを使用できます。</target>
        </trans-unit>
        <trans-unit id="fdde1b4f273f0ed1e791a6fe885f57ab847c6655" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;#method.rsplit&quot;&gt;&lt;code&gt;rsplit&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">パターンが逆方向検索を許可しているが、その結果が順方向検索と異なる場合は、&lt;a href=&quot;#method.rsplit&quot;&gt; &lt;code&gt;rsplit&lt;/code&gt; &lt;/a&gt;メソッドを使用できます。</target>
        </trans-unit>
        <trans-unit id="7628f0f92ea01c70ac165a6fae25950d70760fc1" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;#method.rsplit_terminator&quot;&gt;&lt;code&gt;rsplit_terminator&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">パターンで逆検索が可能であるが、その結果が順方向検索と異なる場合は、&lt;a href=&quot;#method.rsplit_terminator&quot;&gt; &lt;code&gt;rsplit_terminator&lt;/code&gt; &lt;/a&gt;メソッドを使用できます。</target>
        </trans-unit>
        <trans-unit id="7b1dfc3434853d3f01995d02cf2021fd9cea4f38" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;../primitive.str#method.match_indices&quot;&gt;&lt;code&gt;rmatch_indices&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">パターンで逆検索が許可されているが、その結果が順検索と異なる場合は、&lt;a href=&quot;../primitive.str#method.match_indices&quot;&gt; &lt;code&gt;rmatch_indices&lt;/code&gt; &lt;/a&gt;メソッドを使用できます。</target>
        </trans-unit>
        <trans-unit id="ec2b2d41067456cd5ce092b8da0d00cd9c018667" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;../primitive.str#method.matches&quot;&gt;&lt;code&gt;rmatches&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">パターンで逆検索が許可されているが、その結果が順検索と異なる場合は、&lt;a href=&quot;../primitive.str#method.matches&quot;&gt; &lt;code&gt;rmatches&lt;/code&gt; &lt;/a&gt;メソッドを使用できます。</target>
        </trans-unit>
        <trans-unit id="aa780fe3ad5330a6d715d8c1d30bd41ddfacfc03" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;../primitive.str#method.rsplit&quot;&gt;&lt;code&gt;rsplit&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">パターンで逆検索が許可されているが、その結果が順検索と異なる場合は、&lt;a href=&quot;../primitive.str#method.rsplit&quot;&gt; &lt;code&gt;rsplit&lt;/code&gt; &lt;/a&gt;メソッドを使用できます。</target>
        </trans-unit>
        <trans-unit id="4b8ae88e59c6bfa2a36b4a334a350ee9f55b8244" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;../primitive.str#method.rsplit_terminator&quot;&gt;&lt;code&gt;rsplit_terminator&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">パターンで逆検索が許可されているが、その結果が順検索と異なる場合は、&lt;a href=&quot;../primitive.str#method.rsplit_terminator&quot;&gt; &lt;code&gt;rsplit_terminator&lt;/code&gt; &lt;/a&gt;メソッドを使用できます。</target>
        </trans-unit>
        <trans-unit id="8bcaec8982083667c5c84f44fc799e4d051fed01" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;primitive.str#method.match_indices&quot;&gt;&lt;code&gt;rmatch_indices&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">パターンで逆検索が許可されているが、その結果が順検索と異なる場合は、&lt;a href=&quot;primitive.str#method.match_indices&quot;&gt; &lt;code&gt;rmatch_indices&lt;/code&gt; &lt;/a&gt;メソッドを使用できます。</target>
        </trans-unit>
        <trans-unit id="e9c97ecf08e8a57f300f06fbed8336fddc8673ad" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;primitive.str#method.matches&quot;&gt;&lt;code&gt;rmatches&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">パターンで逆検索が許可されているが、その結果が順検索と異なる場合は、&lt;a href=&quot;primitive.str#method.matches&quot;&gt; &lt;code&gt;rmatches&lt;/code&gt; &lt;/a&gt;メソッドを使用できます。</target>
        </trans-unit>
        <trans-unit id="8b3f51e25e82602ab5224623c59019342d6d26f3" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;primitive.str#method.rsplit&quot;&gt;&lt;code&gt;rsplit&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">パターンで逆検索が許可されているが、その結果が順検索と異なる場合は、&lt;a href=&quot;primitive.str#method.rsplit&quot;&gt; &lt;code&gt;rsplit&lt;/code&gt; &lt;/a&gt;メソッドを使用できます。</target>
        </trans-unit>
        <trans-unit id="75ae87480dd359d1fa21ebc1f6510a38a90b5d25" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;primitive.str#method.rsplit_terminator&quot;&gt;&lt;code&gt;rsplit_terminator&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">パターンで逆検索が許可されているが、その結果が順検索と異なる場合は、&lt;a href=&quot;primitive.str#method.rsplit_terminator&quot;&gt; &lt;code&gt;rsplit_terminator&lt;/code&gt; &lt;/a&gt;メソッドを使用できます。</target>
        </trans-unit>
        <trans-unit id="02eda760b5bfe240d7c8b8f222a4d4b7100d666e" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search, the &lt;a href=&quot;#method.rsplitn&quot;&gt;&lt;code&gt;rsplitn&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">パターンで逆検索が許可されている場合は、&lt;a href=&quot;#method.rsplitn&quot;&gt; &lt;code&gt;rsplitn&lt;/code&gt; &lt;/a&gt;メソッドを使用できます。</target>
        </trans-unit>
        <trans-unit id="13381a81af44ee23cac490ae25db16aaac796d46" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search, the &lt;a href=&quot;../primitive.str#method.rsplitn&quot;&gt;&lt;code&gt;rsplitn&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">パターンで逆検索が許可されている場合は、&lt;a href=&quot;../primitive.str#method.rsplitn&quot;&gt; &lt;code&gt;rsplitn&lt;/code&gt; &lt;/a&gt;メソッドを使用できます。</target>
        </trans-unit>
        <trans-unit id="a0dc4aae442a85b53102b885d478be980f7d8acb" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search, the &lt;a href=&quot;primitive.str#method.rsplitn&quot;&gt;&lt;code&gt;rsplitn&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">パターンで逆検索が許可されている場合は、&lt;a href=&quot;primitive.str#method.rsplitn&quot;&gt; &lt;code&gt;rsplitn&lt;/code&gt; &lt;/a&gt;メソッドを使用できます。</target>
        </trans-unit>
        <trans-unit id="41f3c654ebe17619521d5571a243149ab252e55c" translate="yes" xml:space="preserve">
          <source>If the pattern in a &lt;code&gt;let&lt;/code&gt; statement is an extending pattern then the temporary scope of the initializer expression is extended.</source>
          <target state="translated">で、パターン場合 &lt;code&gt;let&lt;/code&gt; 文が拡張パターンであり、その後初期化子式の一時的な範囲が拡張されます。</target>
        </trans-unit>
        <trans-unit id="a9d4003e7c8cd37da9426d5d4d889d3aaff32c4e" translate="yes" xml:space="preserve">
          <source>If the predicate is true, the thing is rewritten to not have the &lt;code&gt;cfg&lt;/code&gt; attribute on it. If the predicate is false, the thing is removed from the source code.</source>
          <target state="translated">述語が真の場合、事物は &lt;code&gt;cfg&lt;/code&gt; 属性を持たないように書き直されます。述語が偽の場合、ソースコードから削除されます。</target>
        </trans-unit>
        <trans-unit id="9ddbcce981c839ba50c36650f18e74f28c3996cc" translate="yes" xml:space="preserve">
          <source>If the process was terminated by a signal, returns that signal.</source>
          <target state="translated">シグナルによってプロセスが終了した場合、そのシグナルを返します。</target>
        </trans-unit>
        <trans-unit id="12b3054a5c2c9f1f42244cb5633baa4905430f09" translate="yes" xml:space="preserve">
          <source>If the program context over-constrains the type, it is considered a static type error.</source>
          <target state="translated">プログラムコンテキストが型を過度に制約している場合は、静的型エラーとみなされます。</target>
        </trans-unit>
        <trans-unit id="0342ae828ad12df97309a477cf872adf919b1902" translate="yes" xml:space="preserve">
          <source>If the program context under-constrains the type, it defaults to &lt;code&gt;f64&lt;/code&gt;.</source>
          <target state="translated">プログラムコンテキストが型を制約し &lt;code&gt;f64&lt;/code&gt; と、デフォルトでf64になります。</target>
        </trans-unit>
        <trans-unit id="9c5273dc0a13c7cc0e077b4b3fa98da50edca969" translate="yes" xml:space="preserve">
          <source>If the program context under-constrains the type, it defaults to the signed 32-bit integer &lt;code&gt;i32&lt;/code&gt;.</source>
          <target state="translated">プログラムコンテキストが型を制約しすぎると、デフォルトで符号付き32ビット整数 &lt;code&gt;i32&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="46f99ab4b433b6230008eadc71e11c58b7b1e70b" translate="yes" xml:space="preserve">
          <source>If the program path is relative (e.g., &lt;code&gt;&quot;./script.sh&quot;&lt;/code&gt;), it's ambiguous whether it should be interpreted relative to the parent's working directory or relative to &lt;code&gt;current_dir&lt;/code&gt;. The behavior in this case is platform specific and unstable, and it's recommended to use &lt;a href=&quot;../fs/fn.canonicalize&quot;&gt;&lt;code&gt;canonicalize&lt;/code&gt;&lt;/a&gt; to get an absolute program path instead.</source>
          <target state="translated">プログラムのパスが相対パス（例： &lt;code&gt;&quot;./script.sh&quot;&lt;/code&gt; ）の場合、親の作業ディレクトリを基準に解釈するか、 &lt;code&gt;current_dir&lt;/code&gt; を基準に解釈するかは不明確です。この場合の動作はプラットフォーム固有で不安定であり、代わりに&lt;a href=&quot;../fs/fn.canonicalize&quot;&gt; &lt;code&gt;canonicalize&lt;/code&gt; &lt;/a&gt;を使用して絶対プログラムパスを取得することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="5f463c42ca012031b77b1b6ba6bda1bbf7d242ce" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.recv_from&quot;&gt;&lt;code&gt;recv_from&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">指定された値が&lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; の&lt;/a&gt;場合、&lt;a href=&quot;#method.recv&quot;&gt; &lt;code&gt;recv&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;#method.recv_from&quot;&gt; &lt;code&gt;recv_from&lt;/code&gt; &lt;/a&gt;呼び出しは無期限にブロックされます。アン&lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;ゼロの場合に返される&lt;a href=&quot;../../../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt;、このメソッドに渡されます。</target>
        </trans-unit>
        <trans-unit id="27457ae3a7ce774b0ba53e72b68851ec71f67265" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.send_to&quot;&gt;&lt;code&gt;send_to&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#Err.v&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">指定された値が&lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; の&lt;/a&gt;場合、&lt;a href=&quot;#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;#method.send_to&quot;&gt; &lt;code&gt;send_to&lt;/code&gt; &lt;/a&gt;呼び出しは無期限にブロックされます。アン&lt;a href=&quot;../../../result/enum.result#Err.v&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;ゼロの場合に返される&lt;a href=&quot;../../../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt;、このメソッドに渡されます。</target>
        </trans-unit>
        <trans-unit id="a1795e7946ced7825121511cc106a9015fd798ec" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../../../io/trait.read#tymethod.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">指定された値が&lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; の&lt;/a&gt;場合、&lt;a href=&quot;../../../io/trait.read#tymethod.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt;呼び出しは無期限にブロックされます。アン&lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;ゼロの場合に返される&lt;a href=&quot;../../../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt;、このメソッドに渡されます。</target>
        </trans-unit>
        <trans-unit id="e1ea6f1309304cb111df61243a566c96b67b3b82" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../../../io/trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">指定された値が&lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; の&lt;/a&gt;場合、&lt;a href=&quot;../../../io/trait.write#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;呼び出しは無期限にブロックされます。アン&lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;ゼロの場合に返される&lt;a href=&quot;../../../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt;、このメソッドに渡されます。</target>
        </trans-unit>
        <trans-unit id="3030eaafa081102fe45631b54a8872f8838c162b" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../../../macro.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">指定された値が&lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; の&lt;/a&gt;場合、&lt;a href=&quot;../../../macro.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;呼び出しは無期限にブロックされます。アン&lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;ゼロの場合に返される&lt;a href=&quot;../../../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt;、このメソッドに渡されます。</target>
        </trans-unit>
        <trans-unit id="8e6460df1e81820998680e8eea34159effdca0c0" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;struct.unixdatagram#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.unixdatagram#method.recv_from&quot;&gt;&lt;code&gt;recv_from&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">指定された値が&lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; の&lt;/a&gt;場合、&lt;a href=&quot;struct.unixdatagram#method.recv&quot;&gt; &lt;code&gt;recv&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;struct.unixdatagram#method.recv_from&quot;&gt; &lt;code&gt;recv_from&lt;/code&gt; &lt;/a&gt;呼び出しは無期限にブロックされます。アン&lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;ゼロの場合に返される&lt;a href=&quot;../../../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt;、このメソッドに渡されます。</target>
        </trans-unit>
        <trans-unit id="6ee71bcd622cfb4833d8d1ba25909dd1554f21bc" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;struct.unixdatagram#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.unixdatagram#method.send_to&quot;&gt;&lt;code&gt;send_to&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">指定された値が&lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; の&lt;/a&gt;場合、&lt;a href=&quot;struct.unixdatagram#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;struct.unixdatagram#method.send_to&quot;&gt; &lt;code&gt;send_to&lt;/code&gt; &lt;/a&gt;呼び出しは無期限にブロックされます。アン&lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;ゼロの場合に返される&lt;a href=&quot;../../../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt;、このメソッドに渡されます。</target>
        </trans-unit>
        <trans-unit id="02ca5c816748f7e2bf4c21dd7d1f2eac8980aece" translate="yes" xml:space="preserve">
          <source>If the receiver has type &lt;code&gt;&amp;amp;Self&lt;/code&gt; or &lt;code&gt;&amp;amp;mut Self&lt;/code&gt;, then the lifetime of that reference to &lt;code&gt;Self&lt;/code&gt; is assigned to all elided output lifetime parameters.</source>
          <target state="translated">レシーバーのタイプが &lt;code&gt;&amp;amp;Self&lt;/code&gt; または &lt;code&gt;&amp;amp;mut Self&lt;/code&gt; の場合、 &lt;code&gt;Self&lt;/code&gt; へのその参照の存続期間は、省略されたすべての出力存続期間パラメーターに割り当てられます。</target>
        </trans-unit>
        <trans-unit id="87acaebec96dcd891a49b70723f561ac4a00a2ef" translate="yes" xml:space="preserve">
          <source>If the repetition can match zero times (&lt;code&gt;*&lt;/code&gt; or &lt;code&gt;?&lt;/code&gt;), then whatever comes after must be able to follow whatever comes before.</source>
          <target state="translated">繰り返しがゼロ回（ &lt;code&gt;*&lt;/code&gt; または &lt;code&gt;?&lt;/code&gt; ）に一致する可能性がある場合、その後に来るものは前に来るものに続くことができなければなりません。</target>
        </trans-unit>
        <trans-unit id="0c4e89c7ed58ca57a531d68235db3f5dd485fb44" translate="yes" xml:space="preserve">
          <source>If the repetition can repeat multiple times (&lt;code&gt;*&lt;/code&gt; or &lt;code&gt;+&lt;/code&gt;), then the contents must be able to follow themselves.</source>
          <target state="translated">繰り返しが複数回（ &lt;code&gt;*&lt;/code&gt; または &lt;code&gt;+&lt;/code&gt; ）繰り返される可能性がある場合、コンテンツはそれ自体をたどることができなければなりません。</target>
        </trans-unit>
        <trans-unit id="f0a7f9f74244abd35ce8e1d2208c1f4bd4a178de" translate="yes" xml:space="preserve">
          <source>If the repetition includes a separator, that separator must be able to follow the contents of the repetition.</source>
          <target state="translated">繰り返しに区切り文字が含まれている場合、その区切り文字は繰り返しの内容に従うことができなければなりません。</target>
        </trans-unit>
        <trans-unit id="93fda8c7280ac97a010f00a3edbfb2871f7e4163" translate="yes" xml:space="preserve">
          <source>If the results of this method are only manipulated by the same architecture that produced them, then there is no portability concern.</source>
          <target state="translated">この方法の結果が、その結果を生成したのと同じアーキテクチャでしか操作できないのであれば、移植性の懸念はありません。</target>
        </trans-unit>
        <trans-unit id="2714df80ed99e7f5046c9baa63d90d1d03b47084" translate="yes" xml:space="preserve">
          <source>If the return value is &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(n)&lt;/code&gt;&lt;/a&gt; then it must be guaranteed that &lt;code&gt;0 &amp;lt;= n &amp;lt;= buf.len()&lt;/code&gt;. A return value of &lt;code&gt;0&lt;/code&gt; typically means that the underlying object is no longer able to accept bytes and will likely not be able to in the future as well, or that the buffer provided is empty.</source>
          <target state="translated">戻り値が&lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok(n)&lt;/code&gt; の&lt;/a&gt;場合、 &lt;code&gt;0 &amp;lt;= n &amp;lt;= buf.len()&lt;/code&gt; ことが保証されている必要があります。通常、戻り値 &lt;code&gt;0&lt;/code&gt; は、基になるオブジェクトがバイトを受け入れることができなくなり、将来も同様に受け入れることができなくなるか、提供されたバッファーが空であることを意味します。</target>
        </trans-unit>
        <trans-unit id="d3bffaa154919c3b8c559f95a11e7d99a1c962cc" translate="yes" xml:space="preserve">
          <source>If the return value is &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(n)&lt;/code&gt;&lt;/a&gt; then it must be guaranteed that &lt;code&gt;n &amp;lt;= buf.len()&lt;/code&gt;. A return value of &lt;code&gt;0&lt;/code&gt; typically means that the underlying object is no longer able to accept bytes and will likely not be able to in the future as well, or that the buffer provided is empty.</source>
          <target state="translated">戻り値が&lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok(n)&lt;/code&gt; の&lt;/a&gt;場合、 &lt;code&gt;n &amp;lt;= buf.len()&lt;/code&gt; ことが保証されている必要があります。戻り値 &lt;code&gt;0&lt;/code&gt; は通常、基になるオブジェクトがバイトを受け入れることができなくなり、将来も受け入れることができなくなる可能性があること、または提供されたバッファーが空であることを意味します。</target>
        </trans-unit>
        <trans-unit id="3d8a15b3b50cba05982491cd9452366b174a6982" translate="yes" xml:space="preserve">
          <source>If the return value of this method is &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(n)&lt;/code&gt;&lt;/a&gt;, then it must be guaranteed that &lt;code&gt;0 &amp;lt;= n &amp;lt;= buf.len()&lt;/code&gt;. A nonzero &lt;code&gt;n&lt;/code&gt; value indicates that the buffer &lt;code&gt;buf&lt;/code&gt; has been filled in with &lt;code&gt;n&lt;/code&gt; bytes of data from this source. If &lt;code&gt;n&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;, then it can indicate one of two scenarios:</source>
          <target state="translated">このメソッドの戻り値が&lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok(n)&lt;/code&gt; の&lt;/a&gt;場合、 &lt;code&gt;0 &amp;lt;= n &amp;lt;= buf.len()&lt;/code&gt; ことが保証されている必要があります。ゼロ以外の &lt;code&gt;n&lt;/code&gt; 値は、バッファー &lt;code&gt;buf&lt;/code&gt; がこのソースからの &lt;code&gt;n&lt;/code&gt; バイトのデータで埋められたことを示します。 &lt;code&gt;n&lt;/code&gt; が &lt;code&gt;0&lt;/code&gt; の場合、次の2つのシナリオのいずれかを示します。</target>
        </trans-unit>
        <trans-unit id="ded67fe7a6c072a895832d05a296084ac3d461ad" translate="yes" xml:space="preserve">
          <source>If the seek operation completed successfully, this method returns the new position from the start of the stream. That position can be used later with &lt;a href=&quot;enum.seekfrom#variant.Start&quot;&gt;&lt;code&gt;SeekFrom::Start&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">シーク操作が正常に完了した場合、このメソッドはストリームの先頭からの新しい位置を返します。その位置は、後で&lt;a href=&quot;enum.seekfrom#variant.Start&quot;&gt; &lt;code&gt;SeekFrom::Start&lt;/code&gt; &lt;/a&gt;使用できます。</target>
        </trans-unit>
        <trans-unit id="40a290f3a15c2cd192fbe0ef4a0681d5f1afa2a2" translate="yes" xml:space="preserve">
          <source>If the set did have this value present, &lt;code&gt;false&lt;/code&gt; is returned, and the entry is not updated. See the &lt;a href=&quot;index#insert-and-complex-keys&quot;&gt;module-level documentation&lt;/a&gt; for more.</source>
          <target state="translated">セットにこの値が存在する場合、 &lt;code&gt;false&lt;/code&gt; が返され、エントリは更新されません。詳細については、&lt;a href=&quot;index#insert-and-complex-keys&quot;&gt;モジュールレベルのドキュメント&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="94e9a109c03e48a1d66a80ba76a8cd1667e1c88c" translate="yes" xml:space="preserve">
          <source>If the set did have this value present, &lt;code&gt;false&lt;/code&gt; is returned.</source>
          <target state="translated">セットにこの値が存在する場合、 &lt;code&gt;false&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="3bf8ca60d7471ccc5d2a042445134f6d59f07692" translate="yes" xml:space="preserve">
          <source>If the set did not have this value present, &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="translated">セットにこの値が存在しない場合、 &lt;code&gt;true&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="6f392e4742f25190cbf5e3351752daf379a0be61" translate="yes" xml:space="preserve">
          <source>If the slice does not end with &lt;code&gt;suffix&lt;/code&gt;, returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">スライスが &lt;code&gt;suffix&lt;/code&gt; で終わっていない場合は、 &lt;code&gt;None&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="d43a87008e53f4a6466f036fda4975d20f3ad011" translate="yes" xml:space="preserve">
          <source>If the slice does not start with &lt;code&gt;prefix&lt;/code&gt;, returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">スライスが &lt;code&gt;prefix&lt;/code&gt; で始まらない場合は、 &lt;code&gt;None&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="2ad3d774a6e0ccaa727d17e721cc10badd0ba8e6" translate="yes" xml:space="preserve">
          <source>If the slice ends with &lt;code&gt;suffix&lt;/code&gt;, returns the subslice before the suffix, wrapped in &lt;code&gt;Some&lt;/code&gt;. If &lt;code&gt;suffix&lt;/code&gt; is empty, simply returns the original slice.</source>
          <target state="translated">スライスが &lt;code&gt;suffix&lt;/code&gt; で終わる場合は、 &lt;code&gt;Some&lt;/code&gt; でラップされたサフィックスの前のサブスライスを返します。 &lt;code&gt;suffix&lt;/code&gt; が空の場合は、元のスライスを返すだけです。</target>
        </trans-unit>
        <trans-unit id="f83ff10b230425401b084d2888a7c546a452e490" translate="yes" xml:space="preserve">
          <source>If the slice is shorter than &lt;code&gt;size&lt;/code&gt;:</source>
          <target state="translated">スライスが &lt;code&gt;size&lt;/code&gt; より短い場合：</target>
        </trans-unit>
        <trans-unit id="1412fa3c4897cefe27e1dd8f5c2bdb81e3843fe2" translate="yes" xml:space="preserve">
          <source>If the slice is sorted, the first returned slice contains no duplicates.</source>
          <target state="translated">スライスがソートされている場合、最初に返されたスライスには重複がありません。</target>
        </trans-unit>
        <trans-unit id="c27d8278e5200cca20b3d013d5698cf10c18fe2f" translate="yes" xml:space="preserve">
          <source>If the slice starts with &lt;code&gt;prefix&lt;/code&gt;, returns the subslice after the prefix, wrapped in &lt;code&gt;Some&lt;/code&gt;. If &lt;code&gt;prefix&lt;/code&gt; is empty, simply returns the original slice.</source>
          <target state="translated">スライスが &lt;code&gt;prefix&lt;/code&gt; で始まる場合、 &lt;code&gt;Some&lt;/code&gt; でラップされたプレフィックスの後のサブスライスを返します。 &lt;code&gt;prefix&lt;/code&gt; が空の場合は、元のスライスを返すだけです。</target>
        </trans-unit>
        <trans-unit id="a7500b2ee92288b054ccbb9cf159239611040c00" translate="yes" xml:space="preserve">
          <source>If the socket isn't connected, it will return a &lt;a href=&quot;../io/enum.errorkind#variant.NotConnected&quot;&gt;&lt;code&gt;NotConnected&lt;/code&gt;&lt;/a&gt; error.</source>
          <target state="translated">ソケットが接続されていない場合は、&lt;a href=&quot;../io/enum.errorkind#variant.NotConnected&quot;&gt; &lt;code&gt;NotConnected&lt;/code&gt; &lt;/a&gt;エラーが返されます。</target>
        </trans-unit>
        <trans-unit id="49c9a191f32deb0b74107f0ae0391ae8d0b43b7a" translate="yes" xml:space="preserve">
          <source>If the source and destination will &lt;em&gt;never&lt;/em&gt; overlap, &lt;a href=&quot;../ptr/fn.copy_nonoverlapping&quot;&gt;&lt;code&gt;copy_nonoverlapping&lt;/code&gt;&lt;/a&gt; can be used instead.</source>
          <target state="translated">ソースと宛先が重複し&lt;em&gt;ない&lt;/em&gt;場合は、代わりに&lt;a href=&quot;../ptr/fn.copy_nonoverlapping&quot;&gt; &lt;code&gt;copy_nonoverlapping&lt;/code&gt; &lt;/a&gt;を使用できます。</target>
        </trans-unit>
        <trans-unit id="78527ed1205c7d745b52b60ade93722ffae3f052" translate="yes" xml:space="preserve">
          <source>If the source and destination will &lt;em&gt;never&lt;/em&gt; overlap, &lt;a href=&quot;fn.copy_nonoverlapping&quot;&gt;&lt;code&gt;copy_nonoverlapping&lt;/code&gt;&lt;/a&gt; can be used instead.</source>
          <target state="translated">&lt;a href=&quot;fn.copy_nonoverlapping&quot;&gt; &lt;code&gt;copy_nonoverlapping&lt;/code&gt; &lt;/a&gt;元とコピー先が&lt;em&gt;決して&lt;/em&gt;重なら&lt;em&gt;ない&lt;/em&gt;場合は、代わりにcopy_nonoverlappingを使用できます。</target>
        </trans-unit>
        <trans-unit id="4361232c2009840823276ea8357ba262f43a3b14" translate="yes" xml:space="preserve">
          <source>If the string does not end with &lt;code&gt;suffix&lt;/code&gt;, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="translated">文字列が &lt;code&gt;suffix&lt;/code&gt; で終わっていない場合、 &lt;code&gt;None&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="00699a6c688425007189014e64bb10c087e7cc42" translate="yes" xml:space="preserve">
          <source>If the string does not end with &lt;code&gt;suffix&lt;/code&gt;, returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">文字列が &lt;code&gt;suffix&lt;/code&gt; で終わっていない場合は、 &lt;code&gt;None&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="5fd5dbdb681a59cb1a332e76b0649dd3b10de31e" translate="yes" xml:space="preserve">
          <source>If the string does not start with &lt;code&gt;prefix&lt;/code&gt;, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="translated">文字列が &lt;code&gt;prefix&lt;/code&gt; で始まらない場合、 &lt;code&gt;None&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="b4c5d3aa960799aefa6afdc31361ee8f07d50151" translate="yes" xml:space="preserve">
          <source>If the string does not start with &lt;code&gt;prefix&lt;/code&gt;, returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">文字列が &lt;code&gt;prefix&lt;/code&gt; で始まらない場合は、 &lt;code&gt;None&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="39245347359d8114b8b3a102418b227e0b5a250d" translate="yes" xml:space="preserve">
          <source>If the string ends with the pattern &lt;code&gt;suffix&lt;/code&gt;, &lt;code&gt;Some&lt;/code&gt; is returned with the substring where the suffix is removed. Unlike &lt;code&gt;trim_end_matches&lt;/code&gt;, this method removes the suffix exactly once.</source>
          <target state="translated">文字列がパターン &lt;code&gt;suffix&lt;/code&gt; で終わる場合、サフィックスが削除されたサブストリングとともに &lt;code&gt;Some&lt;/code&gt; が返されます。 &lt;code&gt;trim_end_matches&lt;/code&gt; とは異なり、このメソッドはサフィックスを1回だけ削除します。</target>
        </trans-unit>
        <trans-unit id="73e6ef23293e24078530c7881fe300a2cd50dbd2" translate="yes" xml:space="preserve">
          <source>If the string ends with the pattern &lt;code&gt;suffix&lt;/code&gt;, returns the substring before the suffix, wrapped in &lt;code&gt;Some&lt;/code&gt;. Unlike &lt;code&gt;trim_end_matches&lt;/code&gt;, this method removes the suffix exactly once.</source>
          <target state="translated">文字列がパターン &lt;code&gt;suffix&lt;/code&gt; で終わる場合、 &lt;code&gt;Some&lt;/code&gt; でラップされたサフィックスの前の部分文字列を返します。 &lt;code&gt;trim_end_matches&lt;/code&gt; とは異なり、このメソッドはサフィックスを1回だけ削除します。</target>
        </trans-unit>
        <trans-unit id="daa8bca77eb9444573d0ec6c5903975dcf9aaa55" translate="yes" xml:space="preserve">
          <source>If the string starts with the pattern &lt;code&gt;prefix&lt;/code&gt;, &lt;code&gt;Some&lt;/code&gt; is returned with the substring where the prefix is removed. Unlike &lt;code&gt;trim_start_matches&lt;/code&gt;, this method removes the prefix exactly once.</source>
          <target state="translated">文字列がパターン &lt;code&gt;prefix&lt;/code&gt; で始まる場合、 &lt;code&gt;Some&lt;/code&gt; はプレフィックスが削除された部分文字列とともに返されます。 &lt;code&gt;trim_start_matches&lt;/code&gt; とは異なり、このメソッドはプレフィックスを1回だけ削除します。</target>
        </trans-unit>
        <trans-unit id="b2971983ae4e5fda25d513b0c8f02476f9d89865" translate="yes" xml:space="preserve">
          <source>If the string starts with the pattern &lt;code&gt;prefix&lt;/code&gt;, returns substring after the prefix, wrapped in &lt;code&gt;Some&lt;/code&gt;. Unlike &lt;code&gt;trim_start_matches&lt;/code&gt;, this method removes the prefix exactly once.</source>
          <target state="translated">文字列がパターン &lt;code&gt;prefix&lt;/code&gt; で始まる場合、 &lt;code&gt;Some&lt;/code&gt; でラップされたプレフィックスの後に部分文字列を返します。 &lt;code&gt;trim_start_matches&lt;/code&gt; とは異なり、このメソッドはプレフィックスを1回だけ削除します。</target>
        </trans-unit>
        <trans-unit id="ddcbef4bcc4007d5bd1893bc755dafa184d9df1c" translate="yes" xml:space="preserve">
          <source>If the timeout is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../io/trait.read#tymethod.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; calls will block indefinitely.</source>
          <target state="translated">タイムアウトがない場合は&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;、その後、&lt;a href=&quot;../io/trait.read#tymethod.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt;の呼び出しが無期限にブロックします。</target>
        </trans-unit>
        <trans-unit id="071f9fdeaf91e92bcf2267f9e0f60277f6bcc97e" translate="yes" xml:space="preserve">
          <source>If the timeout is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../io/trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; calls will block indefinitely.</source>
          <target state="translated">タイムアウトがない場合は&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;、その後、&lt;a href=&quot;../io/trait.write#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;の呼び出しが無期限にブロックします。</target>
        </trans-unit>
        <trans-unit id="86ffa0ca9fede5aea50d7e731aa1e556c2cfcb06" translate="yes" xml:space="preserve">
          <source>If the trait &lt;code&gt;Foo&lt;/code&gt; was deriving from something like &lt;code&gt;Super&amp;lt;String&amp;gt;&lt;/code&gt; or &lt;code&gt;Super&amp;lt;T&amp;gt;&lt;/code&gt; (where &lt;code&gt;Foo&lt;/code&gt; itself is &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt;), this is okay, because given a type &lt;code&gt;get_a()&lt;/code&gt; will definitely return an object of that type.</source>
          <target state="translated">特性 &lt;code&gt;Foo&lt;/code&gt; が &lt;code&gt;Super&amp;lt;String&amp;gt;&lt;/code&gt; または &lt;code&gt;Super&amp;lt;T&amp;gt;&lt;/code&gt; （ &lt;code&gt;Foo&lt;/code&gt; 自体は &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt; ）などから派生している場合、これは問題あり &lt;code&gt;get_a()&lt;/code&gt; これは、get_a（）型が指定されると、その型のオブジェクトが確実に返されるためです。</target>
        </trans-unit>
        <trans-unit id="59d15c0755f3a894e4c73cfbee908b72296e216e" translate="yes" xml:space="preserve">
          <source>If the trait &lt;code&gt;Trait&lt;/code&gt; was deriving from something like &lt;code&gt;Super&amp;lt;String&amp;gt;&lt;/code&gt; or &lt;code&gt;Super&amp;lt;T&amp;gt;&lt;/code&gt; (where &lt;code&gt;Foo&lt;/code&gt; itself is &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt;), this is okay, because given a type &lt;code&gt;get_a()&lt;/code&gt; will definitely return an object of that type.</source>
          <target state="translated">&lt;code&gt;Trait&lt;/code&gt; が &lt;code&gt;Super&amp;lt;String&amp;gt;&lt;/code&gt; や &lt;code&gt;Super&amp;lt;T&amp;gt;&lt;/code&gt; （ &lt;code&gt;Foo&lt;/code&gt; 自体は &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt; ）のようなものから派生している場合、これは問題あり &lt;code&gt;get_a()&lt;/code&gt; タイプを指定すると、get_a（）は間違いなくそのタイプのオブジェクトを返すからです。</target>
        </trans-unit>
        <trans-unit id="f3977c8ff69bc736e667f7951c5a2e7ce42dc78b" translate="yes" xml:space="preserve">
          <source>If the trait has no lifetime bounds, then the lifetime is inferred in expressions and is &lt;code&gt;'static&lt;/code&gt; outside of expressions.</source>
          <target state="translated">特性に存続期間の境界がない場合、存続期間は式で推論され、 &lt;code&gt;'static&lt;/code&gt; 式の外では静的です。</target>
        </trans-unit>
        <trans-unit id="91f2e745c85e0029a493a85d365496779bca0a85" translate="yes" xml:space="preserve">
          <source>If the trait is defined with a single lifetime &lt;em&gt;bound&lt;/em&gt; then that bound is used.</source>
          <target state="translated">特性が単一のライフタイム&lt;em&gt;バウンドで&lt;/em&gt;定義されている場合、そのバウンドが使用されます。</target>
        </trans-unit>
        <trans-unit id="357e0325de10f1713bb7e2ce24ee991bac9ba465" translate="yes" xml:space="preserve">
          <source>If the trait object is used as a type argument of a generic type then the containing type is first used to try to infer a bound.</source>
          <target state="translated">形質オブジェクトが汎用型の型の引数として使用されている場合は、まず、含まれている型がバインドを推測するために使用されます。</target>
        </trans-unit>
        <trans-unit id="560d3597e83d956d002972f4abc002a7d2adb557" translate="yes" xml:space="preserve">
          <source>If the type of the &lt;code&gt;self&lt;/code&gt; parameter is specified, it is limited to one of the following types:</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; パラメーターのタイプが指定されている場合、それは以下のタイプのいずれかに限定されます。</target>
        </trans-unit>
        <trans-unit id="9d09dbe4faca02efaba3f848374123e962d67442" translate="yes" xml:space="preserve">
          <source>If the type of the &lt;code&gt;self&lt;/code&gt; parameter is specified, it is limited to types resolving to one generated by the following grammar (where &lt;code&gt;'lt&lt;/code&gt; denotes some arbitrary lifetime):</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; パラメーターのタイプが指定されている場合、次の文法によって生成されたタイプに解決されるタイプに制限されます（ &lt;code&gt;'lt&lt;/code&gt; は任意の存続期間を示します）。</target>
        </trans-unit>
        <trans-unit id="ce48e604713fdd5d1a45036f133935186dfa1172" translate="yes" xml:space="preserve">
          <source>If the type parameter was included by mistake, this error can be fixed by simply removing the type parameter, as shown below:</source>
          <target state="translated">間違ってtypeパラメータが含まれていた場合は、以下のようにtypeパラメータを削除するだけでこのエラーを修正することができます。</target>
        </trans-unit>
        <trans-unit id="518ddacd66d25987845bcd6f93021680b5c6a782" translate="yes" xml:space="preserve">
          <source>If the underlying data is &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#method.into_inner&quot;&gt;&lt;code&gt;Pin::into_inner&lt;/code&gt;&lt;/a&gt; should be used instead.</source>
          <target state="translated">基礎となるデータがある場合は&lt;a href=&quot;../marker/trait.unpin&quot;&gt; &lt;code&gt;Unpin&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#method.into_inner&quot;&gt; &lt;code&gt;Pin::into_inner&lt;/code&gt; &lt;/a&gt;代わりに使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="d7db2f45fba2c01ea8e6f00a55427c1ac62329ce" translate="yes" xml:space="preserve">
          <source>If the underlying data is &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.pin#method.into_inner&quot;&gt;&lt;code&gt;Pin::into_inner&lt;/code&gt;&lt;/a&gt; should be used instead.</source>
          <target state="translated">基礎となるデータがある場合は&lt;a href=&quot;../marker/trait.unpin&quot;&gt; &lt;code&gt;Unpin&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;struct.pin#method.into_inner&quot;&gt; &lt;code&gt;Pin::into_inner&lt;/code&gt; &lt;/a&gt;代わりに使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="d6a64661df18427c960804044729f48ac301ae02" translate="yes" xml:space="preserve">
          <source>If the underlying data is &lt;code&gt;Unpin&lt;/code&gt;, &lt;code&gt;Pin::get_mut&lt;/code&gt; should be used instead.</source>
          <target state="translated">基礎となるデータがある場合は &lt;code&gt;Unpin&lt;/code&gt; 、 &lt;code&gt;Pin::get_mut&lt;/code&gt; 代わりに使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="8405b8ad332b999aa219670b74caa5f46b181830" translate="yes" xml:space="preserve">
          <source>If the underlying filesystem does not support creation time, the returned value is 0.</source>
          <target state="translated">基盤となるファイルシステムが作成時間をサポートしていない場合、返される値は0です。</target>
        </trans-unit>
        <trans-unit id="413f9b68289dcc8297528df41e0f0feb6ddb8349" translate="yes" xml:space="preserve">
          <source>If the underlying filesystem does not support last access time, the returned value is 0.</source>
          <target state="translated">基盤となるファイルシステムが最終アクセス時刻をサポートしていない場合、返される値は0です。</target>
        </trans-unit>
        <trans-unit id="fb7130f0e0ffc326e8ffb3bb43790b19856655f3" translate="yes" xml:space="preserve">
          <source>If the underlying filesystem does not support the last write time, the returned value is 0.</source>
          <target state="translated">基盤となるファイルシステムが最後の書き込み時間をサポートしていない場合、返される値は0です。</target>
        </trans-unit>
        <trans-unit id="4282d187fb807509a1857f1a4d0e25b41883c729" translate="yes" xml:space="preserve">
          <source>If the unsized tail of &lt;code&gt;T&lt;/code&gt; is:</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; のサイズのないテールが次の場合：</target>
        </trans-unit>
        <trans-unit id="2800f0b4e13fb2d5eedd5490b06177fdb31e9a98" translate="yes" xml:space="preserve">
          <source>If the user specifies a favorite color, that color is the background color. If today is Tuesday, the background color is green. If the user specifies their age as a string and we can parse it as a number successfully, the color is either purple or orange depending on the value of the number. If none of these conditions apply, the background color is blue.</source>
          <target state="translated">ユーザーが好きな色を指定した場合、その色が背景色となります。今日が火曜日の場合、背景色は緑になります。ユーザーが年齢を文字列で指定し、それを数値として解析できた場合、数値の値に応じて紫色かオレンジ色になります。これらの条件のいずれにも当てはまらない場合、背景色は青になります。</target>
        </trans-unit>
        <trans-unit id="e4dd9bc072921d826fb4feb5e2064cc014699b96" translate="yes" xml:space="preserve">
          <source>If the user wants a high-intensity workout, there&amp;rsquo;s some additional logic: if the value of the random number generated by the app happens to be 3, the app will recommend a break and hydration. If not, the user will get a number of minutes of running based on the complex algorithm.</source>
          <target state="translated">ユーザーが高強度のトレーニングを望んでいる場合、いくつかの追加ロジックがあります。アプリによって生成された乱数の値がたまたま3の場合、アプリは休憩と水分補給を推奨します。そうでない場合、ユーザーは複雑なアルゴリズムに基づいて実行の分数を取得します。</target>
        </trans-unit>
        <trans-unit id="de326f90242f044e38821476a3f1590bb4fba9d2" translate="yes" xml:space="preserve">
          <source>If the value has to be borrowed and then moved, try limiting the lifetime of the borrow using a scoped block:</source>
          <target state="translated">値を借りて移動しなければならない場合は、スコープ付きのブロックを使用して、借入の寿命を制限してみてください。</target>
        </trans-unit>
        <trans-unit id="439bfb205198efd0a4754651bf5aae96ad735451" translate="yes" xml:space="preserve">
          <source>If the value has to be borrowed, try limiting the lifetime of the borrow using a scoped block:</source>
          <target state="translated">値を借りる必要がある場合は、スコープされたブロックを使用して寿命を制限してみてください。</target>
        </trans-unit>
        <trans-unit id="f9c557d25b585efde62c6ddbcee6fee7ec33bf65" translate="yes" xml:space="preserve">
          <source>If the value is found then &lt;a href=&quot;../../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt; is returned, containing the index of the matching element. If there are multiple matches, then any one of the matches could be returned. If the value is not found then &lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Result::Err&lt;/code&gt;&lt;/a&gt; is returned, containing the index where a matching element could be inserted while maintaining sorted order.</source>
          <target state="translated">値が見つかった場合は、一致する要素のインデックスを含む&lt;a href=&quot;../../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Result::Ok&lt;/code&gt; &lt;/a&gt;が返されます。複数の一致がある場合、一致のいずれか1つが返される可能性があります。値が見つからない場合は、&lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Result::Err&lt;/code&gt; &lt;/a&gt;が返されます。これには、ソートされた順序を維持しながら、一致する要素を挿入できるインデックスが含まれます。</target>
        </trans-unit>
        <trans-unit id="8d1fe880a09ab231c6fd293521ee6addfe1a6459" translate="yes" xml:space="preserve">
          <source>If the value is found then &lt;a href=&quot;../result/enum.result#Ok.v&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt; is returned, containing the index of the matching element. If there are multiple matches, then any one of the matches could be returned. If the value is not found then &lt;a href=&quot;../result/enum.result#Err.v&quot;&gt;&lt;code&gt;Result::Err&lt;/code&gt;&lt;/a&gt; is returned, containing the index where a matching element could be inserted while maintaining sorted order.</source>
          <target state="translated">値が見つかった場合、一致する要素のインデックスを含む&lt;a href=&quot;../result/enum.result#Ok.v&quot;&gt; &lt;code&gt;Result::Ok&lt;/code&gt; &lt;/a&gt;が返されます。複数の一致がある場合、一致のいずれかが返される可能性があります。値が見つからない場合は、&lt;a href=&quot;../result/enum.result#Err.v&quot;&gt; &lt;code&gt;Result::Err&lt;/code&gt; &lt;/a&gt;が返されます。これには、ソート順を維持しながら一致する要素を挿入できるインデックスが含まれています。</target>
        </trans-unit>
        <trans-unit id="cf626e78bb4fbb4f09006ad988abe5836977b7bd" translate="yes" xml:space="preserve">
          <source>If the value is found then &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt; is returned, containing the index of the matching element. If there are multiple matches, then any one of the matches could be returned. If the value is not found then &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Result::Err&lt;/code&gt;&lt;/a&gt; is returned, containing the index where a matching element could be inserted while maintaining sorted order.</source>
          <target state="translated">値が見つかった場合は、一致する要素のインデックスを含む&lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Result::Ok&lt;/code&gt; &lt;/a&gt;が返されます。複数の一致がある場合、一致のいずれかが返される可能性があります。値が見つからない場合は、&lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Result::Err&lt;/code&gt; &lt;/a&gt;が返されます。これには、並べ替えられた順序を維持しながら、一致する要素を挿入できるインデックスが含まれます。</target>
        </trans-unit>
        <trans-unit id="50a46bb743147d3eacb03edd963a4e09c15c1d2d" translate="yes" xml:space="preserve">
          <source>If the value is found then &lt;a href=&quot;result/enum.result#Ok.v&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt; is returned, containing the index of the matching element. If there are multiple matches, then any one of the matches could be returned. If the value is not found then &lt;a href=&quot;result/enum.result#Err.v&quot;&gt;&lt;code&gt;Result::Err&lt;/code&gt;&lt;/a&gt; is returned, containing the index where a matching element could be inserted while maintaining sorted order.</source>
          <target state="translated">値が見つかった場合、一致する要素のインデックスを含む&lt;a href=&quot;result/enum.result#Ok.v&quot;&gt; &lt;code&gt;Result::Ok&lt;/code&gt; &lt;/a&gt;が返されます。複数の一致がある場合、一致のいずれかが返される可能性があります。値が見つからない場合は、&lt;a href=&quot;result/enum.result#Err.v&quot;&gt; &lt;code&gt;Result::Err&lt;/code&gt; &lt;/a&gt;が返されます。これには、ソート順を維持しながら一致する要素を挿入できるインデックスが含まれています。</target>
        </trans-unit>
        <trans-unit id="d91c83f96183a0d83c776c950c730bfea58d4c7b" translate="yes" xml:space="preserve">
          <source>If the value is found then &lt;a href=&quot;result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt; is returned, containing the index of the matching element. If there are multiple matches, then any one of the matches could be returned. If the value is not found then &lt;a href=&quot;result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Result::Err&lt;/code&gt;&lt;/a&gt; is returned, containing the index where a matching element could be inserted while maintaining sorted order.</source>
          <target state="translated">値が見つかった場合は、一致する要素のインデックスを含む&lt;a href=&quot;result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Result::Ok&lt;/code&gt; &lt;/a&gt;が返されます。複数の一致がある場合、一致のいずれかが返される可能性があります。値が見つからない場合は、&lt;a href=&quot;result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Result::Err&lt;/code&gt; &lt;/a&gt;が返されます。これには、並べ替えられた順序を維持しながら、一致する要素を挿入できるインデックスが含まれます。</target>
        </trans-unit>
        <trans-unit id="3d22ef5ff5dbc4cc40b70616ba2e0f0190b53527" translate="yes" xml:space="preserve">
          <source>If the value specified is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../io/trait.read#tymethod.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">指定された値が&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; の&lt;/a&gt;場合、&lt;a href=&quot;../io/trait.read#tymethod.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt;呼び出しは無期限にブロックされます。アン&lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;ゼロの場合に返される&lt;a href=&quot;../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt;、このメソッドに渡されます。</target>
        </trans-unit>
        <trans-unit id="29067101ad21459828f0c00fe18eef137fbe68c7" translate="yes" xml:space="preserve">
          <source>If the value specified is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../io/trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">指定された値が&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; の&lt;/a&gt;場合、&lt;a href=&quot;../io/trait.write#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;呼び出しは無期限にブロックされます。アン&lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;ゼロの場合に返される&lt;a href=&quot;../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt;、このメソッドに渡されます。</target>
        </trans-unit>
        <trans-unit id="181ed969af7558ba19cf6745f45eb52729d76a52" translate="yes" xml:space="preserve">
          <source>If the value will be consumed in the pattern guard, using its clone will not move its ownership, so the code works.</source>
          <target state="translated">値がパターンガードで消費される場合、そのクローンを使用しても所有権は移動しないので、コードは動作します。</target>
        </trans-unit>
        <trans-unit id="fcea84573a8b7607a7187659bdbb55dd1d39b19b" translate="yes" xml:space="preserve">
          <source>If the vector is sorted, this removes all duplicates.</source>
          <target state="translated">ベクトルがソートされている場合、これはすべての重複を削除します。</target>
        </trans-unit>
        <trans-unit id="cef9f1c43befa45dbf980aee6fe9d718a1e963db" translate="yes" xml:space="preserve">
          <source>If there are multiple types involved, the only way you care to interact with them is through the trait's interface, and having to rely on dynamic dispatch is acceptable, then you can use &lt;a href=&quot;book/ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;trait objects&lt;/a&gt; with &lt;code&gt;Box&lt;/code&gt;, or other container types like &lt;code&gt;Rc&lt;/code&gt; or &lt;code&gt;Arc&lt;/code&gt;:</source>
          <target state="translated">複数のタイプが関係している場合、それらと対話する唯一の方法はトレイトのインターフェースを介することであり、動的ディスパッチに依存する必要が&lt;a href=&quot;book/ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;ある場合は&lt;/a&gt;、 &lt;code&gt;Box&lt;/code&gt; 、または &lt;code&gt;Rc&lt;/code&gt; や &lt;code&gt;Arc&lt;/code&gt; などの他のコンテナータイプでトレイトオブジェクトを使用できます。</target>
        </trans-unit>
        <trans-unit id="abef88012cadeaf10ba437a95f5fb3e15155b1f7" translate="yes" xml:space="preserve">
          <source>If there are no other &lt;code&gt;Rc&lt;/code&gt; pointers to this allocation, then &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers to this allocation will be disassociated.</source>
          <target state="translated">この割り当てへの他の &lt;code&gt;Rc&lt;/code&gt; ポインターがない場合、この割り当てへの&lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt;ポインターは関連付けが解除されます。</target>
        </trans-unit>
        <trans-unit id="ff03d8563fa4e1bf22eab63535da2e3b71548d3f" translate="yes" xml:space="preserve">
          <source>If there are no other &lt;code&gt;Rc&lt;/code&gt; pointers to this value, then &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers to this value will be dissassociated.</source>
          <target state="translated">この値への他の &lt;code&gt;Rc&lt;/code&gt; ポインターがない場合、この値への&lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt;ポインターは関連付けが解除されます。</target>
        </trans-unit>
        <trans-unit id="95b57c72705e9580ae96b3d9b9bde30bb6b6ab81" translate="yes" xml:space="preserve">
          <source>If there are other &lt;code&gt;Arc&lt;/code&gt; or &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers to the same allocation, then &lt;code&gt;make_mut&lt;/code&gt; will create a new allocation and invoke &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; on the inner value to ensure unique ownership. This is also referred to as clone-on-write.</source>
          <target state="translated">If there are other &lt;code&gt;Arc&lt;/code&gt; or &lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; pointers to the same allocation, then &lt;code&gt;make_mut&lt;/code&gt; will create a new allocation and invoke &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt; on the inner value to ensure unique ownership. This is also referred to as clone-on-write.</target>
        </trans-unit>
        <trans-unit id="4f600b6c8aaa0b5d77a10aa7a739f040bbc9e0c6" translate="yes" xml:space="preserve">
          <source>If there are other &lt;code&gt;Arc&lt;/code&gt; or &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers to the same value, then &lt;code&gt;make_mut&lt;/code&gt; will invoke &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; on the inner value to ensure unique ownership. This is also referred to as clone-on-write.</source>
          <target state="translated">同じ値への他の &lt;code&gt;Arc&lt;/code&gt; または&lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt;ポインターがある場合、 &lt;code&gt;make_mut&lt;/code&gt; は一意の所有権を確保するために内部値で&lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt;を呼び出します。これはクローンオンライトとも呼ばれます。</target>
        </trans-unit>
        <trans-unit id="0fe3cddf6aeb04744aa2425c22a909112782196d" translate="yes" xml:space="preserve">
          <source>If there are other &lt;code&gt;Rc&lt;/code&gt; pointers to the same allocation, then &lt;code&gt;make_mut&lt;/code&gt; will &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; the inner value to a new allocation to ensure unique ownership. This is also referred to as clone-on-write.</source>
          <target state="translated">If there are other &lt;code&gt;Rc&lt;/code&gt; pointers to the same allocation, then &lt;code&gt;make_mut&lt;/code&gt; will &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt; the inner value to a new allocation to ensure unique ownership. This is also referred to as clone-on-write.</target>
        </trans-unit>
        <trans-unit id="f863941a685dbb092b44959406a2b7b73529caaa" translate="yes" xml:space="preserve">
          <source>If there are other &lt;code&gt;Rc&lt;/code&gt; pointers to the same value, then &lt;code&gt;make_mut&lt;/code&gt; will &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; the inner value to ensure unique ownership. This is also referred to as clone-on-write.</source>
          <target state="translated">同じ値を指す他の &lt;code&gt;Rc&lt;/code&gt; ポインターがある場合、 &lt;code&gt;make_mut&lt;/code&gt; は内部の値を&lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt;、固有の所有権を確保します。これはクローンオンライトとも呼ばれます。</target>
        </trans-unit>
        <trans-unit id="dea40bb57bee20622d3883c554a725db6e6aee3b" translate="yes" xml:space="preserve">
          <source>If there is a blocked thread on this condition variable, then it will be woken up from its call to &lt;a href=&quot;#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#method.wait_timeout&quot;&gt;&lt;code&gt;wait_timeout&lt;/code&gt;&lt;/a&gt;. Calls to &lt;code&gt;notify_one&lt;/code&gt; are not buffered in any way.</source>
          <target state="translated">この条件変数にブロックされたスレッドがある場合、それは&lt;a href=&quot;#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;#method.wait_timeout&quot;&gt; &lt;code&gt;wait_timeout&lt;/code&gt; &lt;/a&gt;への呼び出しから起こされます。 &lt;code&gt;notify_one&lt;/code&gt; の呼び出しは、バッファリングされません。</target>
        </trans-unit>
        <trans-unit id="e0a267348680246d2e17aaf9a40bcf577009d4e9" translate="yes" xml:space="preserve">
          <source>If there is a blocked thread on this condition variable, then it will be woken up from its call to &lt;a href=&quot;struct.condvar#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.condvar#method.wait_timeout&quot;&gt;&lt;code&gt;wait_timeout&lt;/code&gt;&lt;/a&gt;. Calls to &lt;code&gt;notify_one&lt;/code&gt; are not buffered in any way.</source>
          <target state="translated">If there is a blocked thread on this condition variable, then it will be woken up from its call to &lt;a href=&quot;struct.condvar#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; or &lt;a href=&quot;struct.condvar#method.wait_timeout&quot;&gt; &lt;code&gt;wait_timeout&lt;/code&gt; &lt;/a&gt;. Calls to &lt;code&gt;notify_one&lt;/code&gt; are not buffered in any way.</target>
        </trans-unit>
        <trans-unit id="985d82ded8f795b4c5a05301fea06f8c8f8410be" translate="yes" xml:space="preserve">
          <source>If there is a single type involved, you can use &lt;a href=&quot;book/ch10-02-traits#returning-types-that-implement-traits&quot;&gt;&lt;code&gt;impl Trait&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">If there is a single type involved, you can use &lt;a href=&quot;book/ch10-02-traits#returning-types-that-implement-traits&quot;&gt; &lt;code&gt;impl Trait&lt;/code&gt; &lt;/a&gt;:</target>
        </trans-unit>
        <trans-unit id="bee2363bd2a2c8c97c0aa8c6f834b6380ae23a5d" translate="yes" xml:space="preserve">
          <source>If there is a unique bound from the containing type then that is the default</source>
          <target state="translated">含む型からの一意のバウンドがある場合は、それがデフォルトの</target>
        </trans-unit>
        <trans-unit id="352f58ee146eece567c530e6f6054aff283c53ea" translate="yes" xml:space="preserve">
          <source>If there is exactly one lifetime used in the parameters (elided or not), that lifetime is assigned to &lt;em&gt;all&lt;/em&gt; elided output lifetimes.</source>
          <target state="translated">パラメータで使用されているライフタイムが1つだけある場合（省略されているかどうかに関係なく）、そのライフタイムは省略されている&lt;em&gt;すべての&lt;/em&gt;出力ライフタイムに割り当てられます。</target>
        </trans-unit>
        <trans-unit id="05c8d9cff8b4cacded32e768ce8c1fe1b9bf7b05" translate="yes" xml:space="preserve">
          <source>If there is more than one bound from the containing type then an explicit bound must be specified</source>
          <target state="translated">含む型から複数のバインドがある場合は,明示的なバインドを指定しなければなりません.</target>
        </trans-unit>
        <trans-unit id="3635b90aa1ac5e9d56b967f455ea5a68c64aa12a" translate="yes" xml:space="preserve">
          <source>If there is no data attached to &lt;em&gt;any&lt;/em&gt; of the variants of an enumeration, then the discriminant can be directly chosen and accessed.</source>
          <target state="translated">列挙型のバリアントの&lt;em&gt;いずれにも&lt;/em&gt;データが添付されていない場合は、判別式を直接選択してアクセスできます。</target>
        </trans-unit>
        <trans-unit id="5a74422fbdc8c963cd6dd0e8d60bffef84d0d7d1" translate="yes" xml:space="preserve">
          <source>If there's still a partial line in the buffer when the &lt;code&gt;LineWriter&lt;/code&gt; is dropped, it will flush those contents.</source>
          <target state="translated">&lt;code&gt;LineWriter&lt;/code&gt; がドロップされたときにバッファーにまだ部分的な行がある場合、それらの内容はフラッシュされます。</target>
        </trans-unit>
        <trans-unit id="e49a0ab914289e14797d67f14458c53775df1443" translate="yes" xml:space="preserve">
          <source>If this &lt;a href=&quot;struct.error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; was constructed via &lt;a href=&quot;struct.error#method.last_os_error&quot;&gt;&lt;code&gt;last_os_error&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.error#method.from_raw_os_error&quot;&gt;&lt;code&gt;from_raw_os_error&lt;/code&gt;&lt;/a&gt;, then this function will return &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt;, otherwise it will return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If this &lt;a href=&quot;struct.error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; was constructed via &lt;a href=&quot;struct.error#method.last_os_error&quot;&gt; &lt;code&gt;last_os_error&lt;/code&gt; &lt;/a&gt; or &lt;a href=&quot;struct.error#method.from_raw_os_error&quot;&gt; &lt;code&gt;from_raw_os_error&lt;/code&gt; &lt;/a&gt;, then this function will return &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some&lt;/code&gt; &lt;/a&gt;, otherwise it will return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="8eaa98dea050ef5ef34b38731584cb22e203de6c" translate="yes" xml:space="preserve">
          <source>If this &lt;a href=&quot;struct.error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; was constructed via &lt;a href=&quot;struct.error#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; then this function will return &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt;, otherwise it will return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If this &lt;a href=&quot;struct.error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; was constructed via &lt;a href=&quot;struct.error#method.new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt; then this function will return &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some&lt;/code&gt; &lt;/a&gt;, otherwise it will return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="abb98d91de395055f4edd70094a7b8dcc7dd5d8b" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Error&lt;/code&gt; was constructed via &lt;code&gt;last_os_error&lt;/code&gt; or &lt;code&gt;from_raw_os_error&lt;/code&gt;, then this function will return &lt;code&gt;Some&lt;/code&gt;, otherwise it will return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">この &lt;code&gt;Error&lt;/code&gt; が &lt;code&gt;last_os_error&lt;/code&gt; または &lt;code&gt;from_raw_os_error&lt;/code&gt; を介して作成された場合、この関数は &lt;code&gt;Some&lt;/code&gt; を返し、それ以外の場合は &lt;code&gt;None&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="d6ffccf610cd6b37d68c88255675f6191805f967" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Error&lt;/code&gt; was constructed via &lt;code&gt;new&lt;/code&gt; then this function will return &lt;code&gt;Some&lt;/code&gt;, otherwise it will return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">この &lt;code&gt;Error&lt;/code&gt; が &lt;code&gt;new&lt;/code&gt; を介して作成された場合、この関数は &lt;code&gt;Some&lt;/code&gt; を返し、それ以外の場合は &lt;code&gt;None&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="972ece54d9b74d11c408e1f298396f497ba6449a" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;char&lt;/code&gt; does not have a lowercase mapping, the iterator yields the same &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">If this &lt;code&gt;char&lt;/code&gt; does not have a lowercase mapping, the iterator yields the same &lt;code&gt;char&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="58c79af0f9cc118b1977a59ee7eda23560b0caa9" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;char&lt;/code&gt; does not have a uppercase mapping, the iterator yields the same &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">If this &lt;code&gt;char&lt;/code&gt; does not have a uppercase mapping, the iterator yields the same &lt;code&gt;char&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="829eac6176dbda0779cc96fbc600b1df90d4e4bc" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;char&lt;/code&gt; has a one-to-one lowercase mapping given by the &lt;a href=&quot;https://www.unicode.org/reports/tr44/&quot;&gt;Unicode Character Database&lt;/a&gt;&lt;a href=&quot;https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt&quot;&gt;&lt;code&gt;UnicodeData.txt&lt;/code&gt;&lt;/a&gt;, the iterator yields that &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">If this &lt;code&gt;char&lt;/code&gt; has a one-to-one lowercase mapping given by the &lt;a href=&quot;https://www.unicode.org/reports/tr44/&quot;&gt;Unicode Character Database&lt;/a&gt;&lt;a href=&quot;https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt&quot;&gt; &lt;code&gt;UnicodeData.txt&lt;/code&gt; &lt;/a&gt;, the iterator yields that &lt;code&gt;char&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8172678f4c99b3f0dc7b848aa7a176d18218ceb4" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;char&lt;/code&gt; has a one-to-one uppercase mapping given by the &lt;a href=&quot;https://www.unicode.org/reports/tr44/&quot;&gt;Unicode Character Database&lt;/a&gt;&lt;a href=&quot;https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt&quot;&gt;&lt;code&gt;UnicodeData.txt&lt;/code&gt;&lt;/a&gt;, the iterator yields that &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">If this &lt;code&gt;char&lt;/code&gt; has a one-to-one uppercase mapping given by the &lt;a href=&quot;https://www.unicode.org/reports/tr44/&quot;&gt;Unicode Character Database&lt;/a&gt;&lt;a href=&quot;https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt&quot;&gt; &lt;code&gt;UnicodeData.txt&lt;/code&gt; &lt;/a&gt;, the iterator yields that &lt;code&gt;char&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="89a8c0c082c5779306df0c22e5cf142b946f6c4e" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;char&lt;/code&gt; requires special considerations (e.g. multiple &lt;code&gt;char&lt;/code&gt;s) the iterator yields the &lt;code&gt;char&lt;/code&gt;(s) given by &lt;a href=&quot;https://www.unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt&quot;&gt;&lt;code&gt;SpecialCasing.txt&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If this &lt;code&gt;char&lt;/code&gt; requires special considerations (e.g. multiple &lt;code&gt;char&lt;/code&gt; s) the iterator yields the &lt;code&gt;char&lt;/code&gt; (s) given by &lt;a href=&quot;https://www.unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt&quot;&gt; &lt;code&gt;SpecialCasing.txt&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="548965be0bbc95fe2de47e9f63883d2758d88ca6" translate="yes" xml:space="preserve">
          <source>If this chapter has piqued your interest and you want to implement your own smart pointers, check out &lt;a href=&quot;https://doc.rust-lang.org/nomicon/index.html&quot;&gt;&amp;ldquo;The Rustonomicon&amp;rdquo;&lt;/a&gt; for more useful information.</source>
          <target state="translated">If this chapter has piqued your interest and you want to implement your own smart pointers, check out &lt;a href=&quot;https://doc.rust-lang.org/nomicon/index.html&quot;&gt;&amp;ldquo;The Rustonomicon&amp;rdquo;&lt;/a&gt; for more useful information.</target>
        </trans-unit>
        <trans-unit id="b584e3b971153b633a07eca679cded17a1c1b693" translate="yes" xml:space="preserve">
          <source>If this chapter has piqued your interest and you want to implement your own smart pointers, check out &lt;a href=&quot;https://doc.rust-lang.org/stable/nomicon/index.html&quot;&gt;&amp;ldquo;The Rustonomicon&amp;rdquo;&lt;/a&gt; for more useful information.</source>
          <target state="translated">この章で興味をそそられ、独自のスマートポインタを実装したい場合は、&lt;a href=&quot;https://doc.rust-lang.org/stable/nomicon/index.html&quot;&gt;「The Rustonomicon」&lt;/a&gt;で詳細な情報を確認してください。</target>
        </trans-unit>
        <trans-unit id="0ddae77e0fadbaabd5b7dbc95fb35e2d525819bd" translate="yes" xml:space="preserve">
          <source>If this function encounters an &quot;end of file&quot; before completely filling the buffer, it returns an error of the kind &lt;a href=&quot;../../../io/enum.errorkind#variant.UnexpectedEof&quot;&gt;&lt;code&gt;ErrorKind::UnexpectedEof&lt;/code&gt;&lt;/a&gt;. The contents of &lt;code&gt;buf&lt;/code&gt; are unspecified in this case.</source>
          <target state="translated">この関数は、バッファーを完全に満たす前に「ファイルの終わり」に遭遇すると、種類&lt;a href=&quot;../../../io/enum.errorkind#variant.UnexpectedEof&quot;&gt; &lt;code&gt;ErrorKind::UnexpectedEof&lt;/code&gt; &lt;/a&gt;エラーを返します。この場合、 &lt;code&gt;buf&lt;/code&gt; の内容は指定されていません。</target>
        </trans-unit>
        <trans-unit id="dd91d7afe70f171b1effa9750344f0fa576225f4" translate="yes" xml:space="preserve">
          <source>If this function encounters an &quot;end of file&quot; before completely filling the buffer, it returns an error of the kind &lt;a href=&quot;../../../io/enum.errorkind#variant.UnexpectedEof&quot;&gt;&lt;code&gt;io::ErrorKind::UnexpectedEof&lt;/code&gt;&lt;/a&gt;. The contents of &lt;code&gt;buf&lt;/code&gt; are unspecified in this case.</source>
          <target state="translated">If this function encounters an &quot;end of file&quot; before completely filling the buffer, it returns an error of the kind &lt;a href=&quot;../../../io/enum.errorkind#variant.UnexpectedEof&quot;&gt; &lt;code&gt;io::ErrorKind::UnexpectedEof&lt;/code&gt; &lt;/a&gt;. The contents of &lt;code&gt;buf&lt;/code&gt; are unspecified in this case.</target>
        </trans-unit>
        <trans-unit id="38d7508026f8cac220a71afe0772cc2be9708eb8" translate="yes" xml:space="preserve">
          <source>If this function encounters an &quot;end of file&quot; before completely filling the buffer, it returns an error of the kind &lt;a href=&quot;enum.errorkind#variant.UnexpectedEof&quot;&gt;&lt;code&gt;ErrorKind::UnexpectedEof&lt;/code&gt;&lt;/a&gt;. The contents of &lt;code&gt;buf&lt;/code&gt; are unspecified in this case.</source>
          <target state="translated">この関数は、バッファーを完全に満たす前に「ファイルの終わり」に遭遇すると、種類&lt;a href=&quot;enum.errorkind#variant.UnexpectedEof&quot;&gt; &lt;code&gt;ErrorKind::UnexpectedEof&lt;/code&gt; &lt;/a&gt;エラーを返します。この場合、 &lt;code&gt;buf&lt;/code&gt; の内容は指定されていません。</target>
        </trans-unit>
        <trans-unit id="bb4e1045443cca4084567ed8afb7d4a2bc6c922a" translate="yes" xml:space="preserve">
          <source>If this function encounters an error of the kind &lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; then the error is ignored and the operation will continue.</source>
          <target state="translated">この関数で&lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt;の種類のエラーが発生した場合、エラーは無視され、操作が続行されます。</target>
        </trans-unit>
        <trans-unit id="a8875047b32226ad3b08a483cfff719e7d61c887" translate="yes" xml:space="preserve">
          <source>If this function encounters an error of the kind &lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;io::ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; then the error is ignored and the operation will continue.</source>
          <target state="translated">If this function encounters an error of the kind &lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;io::ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt; then the error is ignored and the operation will continue.</target>
        </trans-unit>
        <trans-unit id="3b6df35b215478f7f7741d3182fb05937f86e727" translate="yes" xml:space="preserve">
          <source>If this function encounters an error of the kind &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; then the error is ignored and the operation will continue.</source>
          <target state="translated">この関数で&lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt;の種類のエラーが発生した場合、エラーは無視され、操作が続行されます。</target>
        </trans-unit>
        <trans-unit id="14f9d7ca930e810af603a93101162a569a3ddf35" translate="yes" xml:space="preserve">
          <source>If this function encounters any form of I/O or other error, an error variant will be returned. If an error is returned then it must be guaranteed that no bytes were read.</source>
          <target state="translated">この関数が何らかの形で I/O やその他のエラーに遭遇した場合、エラー・バリアントが返されます。エラーが返された場合は、バイトが読み込まれなかったことを保証しなければなりません。</target>
        </trans-unit>
        <trans-unit id="a8d408c5e61a9b54abca8856c432fb48776f9a75" translate="yes" xml:space="preserve">
          <source>If this function returns &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(0)&lt;/code&gt;&lt;/a&gt;, the stream has reached EOF.</source>
          <target state="translated">If this function returns &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok(0)&lt;/code&gt; &lt;/a&gt;, the stream has reached EOF.</target>
        </trans-unit>
        <trans-unit id="c8a07da1b0668efaf930a01d9ed7e8496400a4f8" translate="yes" xml:space="preserve">
          <source>If this function returns &lt;code&gt;Ok(0)&lt;/code&gt;, the stream has reached EOF.</source>
          <target state="translated">この関数が &lt;code&gt;Ok(0)&lt;/code&gt; を返す場合、ストリームはEOFに達しています。</target>
        </trans-unit>
        <trans-unit id="32100a1ba4be6bddcd14becf4ad19ac4def99416" translate="yes" xml:space="preserve">
          <source>If this function returns an error, it is unspecified how many bytes it has read, but it will never read more than would be necessary to completely fill the buffer.</source>
          <target state="translated">この関数がエラーを返した場合、何バイト読んだかは不定ですが、バッファを完全に埋めるのに必要なバイト数以上は決して読み込まれません。</target>
        </trans-unit>
        <trans-unit id="87d71722719a13aad250b3e972be1f6616e469cd" translate="yes" xml:space="preserve">
          <source>If this is a buffered channel, then the buffer is full at this time. If this is not a buffered channel, then there is no &lt;a href=&quot;struct.receiver&quot;&gt;&lt;code&gt;Receiver&lt;/code&gt;&lt;/a&gt; available to acquire the data.</source>
          <target state="translated">これがバッファリングされたチャネルの場合、この時点でバッファはいっぱいです。これがバッファリングされたチャネルでない場合、データを取得するために利用可能な&lt;a href=&quot;struct.receiver&quot;&gt; &lt;code&gt;Receiver&lt;/code&gt; &lt;/a&gt;がありません。</target>
        </trans-unit>
        <trans-unit id="91184bf48d3bff1e231691842c160f41d0aa37b7" translate="yes" xml:space="preserve">
          <source>If this is not an option, consider replacing the type parameter with another trait object (e.g., if &lt;code&gt;T: OtherTrait&lt;/code&gt;, use &lt;code&gt;on: Box&amp;lt;OtherTrait&amp;gt;&lt;/code&gt;). If the number of types you intend to feed to this method is limited, consider manually listing out the methods of different types.</source>
          <target state="translated">これがオプションでない場合は、typeパラメータを別の特性オブジェクトで置き換えることを検討してください（たとえば、 &lt;code&gt;T: OtherTrait&lt;/code&gt; 場合、 &lt;code&gt;on: Box&amp;lt;OtherTrait&amp;gt;&lt;/code&gt; で使用します）。このメソッドにフィードするタイプの数が限られている場合は、さまざまなタイプのメソッドを手動でリストすることを検討してください。</target>
        </trans-unit>
        <trans-unit id="5c02bd6638372b67d88f3ddd5d1f383f3787bce7" translate="yes" xml:space="preserve">
          <source>If this is your first time, the documentation for the standard library is written to be casually perused. Clicking on interesting things should generally lead you to interesting places. Still, there are important bits you don't want to miss, so read on for a tour of the standard library and its documentation!</source>
          <target state="translated">初めての方は、標準ライブラリのドキュメントは何気なく目を通すように書かれています。おもしろいものをクリックすると、たいていはおもしろいところにたどり着けるはずです。しかし、見逃したくない重要な部分もありますので、標準ライブラリとそのドキュメントのツアーを読んでみてください。</target>
        </trans-unit>
        <trans-unit id="9676dae75a055d60a25e6ce7412236743ae6ea02" translate="yes" xml:space="preserve">
          <source>If this method returns &lt;code&gt;Err&lt;/code&gt;, then ownership of the memory block has not been transferred to this allocator, and the contents of the memory block are unaltered.</source>
          <target state="translated">このメソッドが &lt;code&gt;Err&lt;/code&gt; を返す場合、メモリブロックの所有権はこのアロケータに転送されておらず、メモリブロックの内容は変更されていません。</target>
        </trans-unit>
        <trans-unit id="01b48a2a055f0e9e221863ae53b5df15b8890a45" translate="yes" xml:space="preserve">
          <source>If this method returns an &lt;code&gt;Ok(addr)&lt;/code&gt;, then the &lt;code&gt;addr&lt;/code&gt; returned will be non-null address pointing to a block of storage suitable for holding an instance of &lt;code&gt;layout&lt;/code&gt;.</source>
          <target state="translated">このメソッドが &lt;code&gt;Ok(addr)&lt;/code&gt; を返す場合、返される &lt;code&gt;addr&lt;/code&gt; は、 &lt;code&gt;layout&lt;/code&gt; インスタンスを保持するのに適したストレージのブロックを指すnull以外のアドレスになります。</target>
        </trans-unit>
        <trans-unit id="57431fcdddc5fa976aeed322cde258661b0155ef" translate="yes" xml:space="preserve">
          <source>If this method returns null, then ownership of the memory block has not been transferred to this allocator, and the contents of the memory block are unaltered.</source>
          <target state="translated">このメソッドが NULL を返した場合、メモリ・ブロックの所有権はこのアロケータに移されておらず、メモリ・ブロックの内容は変更されていません。</target>
        </trans-unit>
        <trans-unit id="0ffa302b9d10d74aa11c3e8a0d25a30c1712822c" translate="yes" xml:space="preserve">
          <source>If this results in multiple possible candidates, then it is an error, and the receiver must be &lt;a href=&quot;call-expr#disambiguating-function-calls&quot;&gt;converted&lt;/a&gt; to an appropriate receiver type to make the method call.</source>
          <target state="translated">これが複数の候補となる可能性がある場合はエラーであり、メソッド呼び出しを行うには、レシーバーを適切なレシーバータイプに&lt;a href=&quot;call-expr#disambiguating-function-calls&quot;&gt;変換&lt;/a&gt;する必要があります。</target>
        </trans-unit>
        <trans-unit id="09145f758f25c9eb35661be01cc46455e17d7df0" translate="yes" xml:space="preserve">
          <source>If this returns &lt;code&gt;Err&lt;/code&gt;, then the memory block is considered to still represent the original (larger) &lt;code&gt;layout&lt;/code&gt;. None of the block has been carved off for reuse elsewhere, ownership of the memory block has not been transferred, and the contents of the memory block are unaltered.</source>
          <target state="translated">これが &lt;code&gt;Err&lt;/code&gt; を返した場合、メモリブロックは元の（より大きな） &lt;code&gt;layout&lt;/code&gt; を引き続き表していると見なされます。他の場所での再利用のために切り分けられたブロックはなく、メモリブロックの所有権は転送されておらず、メモリブロックの内容は変更されていません。</target>
        </trans-unit>
        <trans-unit id="7b6bef076ebe49dc4a2edbad684a0b757b358554" translate="yes" xml:space="preserve">
          <source>If this returns &lt;code&gt;Ok&lt;/code&gt;, then ownership of the memory block referenced by &lt;code&gt;ptr&lt;/code&gt; has been transferred to this allocator. The memory may or may not have been freed, and should be considered unusable (unless of course it was transferred back to the caller again via the return value of this method).</source>
          <target state="translated">これが &lt;code&gt;Ok&lt;/code&gt; を返す場合、 &lt;code&gt;ptr&lt;/code&gt; によって参照されるメモリブロックの所有権はこのアロケータに転送されています。メモリは解放されている場合とされていない場合があり、使用不可と見なされます（もちろん、このメソッドの戻り値を介して呼び出し元に再度転送された場合を除きます）。</target>
        </trans-unit>
        <trans-unit id="d418fdb16ac3dec6f2998c32246199d93bd8ccd1" translate="yes" xml:space="preserve">
          <source>If this returns &lt;code&gt;Ok&lt;/code&gt;, then ownership of the memory block referenced by &lt;code&gt;ptr&lt;/code&gt; has been transferred to this allocator. The memory may or may not have been freed, and should be considered unusable unless it was transferred back to the caller again via the return value of this method.</source>
          <target state="translated">これが &lt;code&gt;Ok&lt;/code&gt; を返す場合、 &lt;code&gt;ptr&lt;/code&gt; によって参照されるメモリブロックの所有権はこのアロケータに転送されています。メモリは解放されている場合とされていない場合があり、このメソッドの戻り値を介して呼び出し元に再度転送されない限り、使用不可と見なす必要があります。</target>
        </trans-unit>
        <trans-unit id="b07b65f6bada4aa52d604e0c09ea706a071d0221" translate="yes" xml:space="preserve">
          <source>If this returns &lt;code&gt;Ok&lt;/code&gt;, then the allocator has asserted that the memory block referenced by &lt;code&gt;ptr&lt;/code&gt; now fits &lt;code&gt;new_size&lt;/code&gt;, and thus can be used to carry data of a layout of that size and same alignment as &lt;code&gt;layout&lt;/code&gt;. (The allocator is allowed to expend effort to accomplish this, such as extending the memory block to include successor blocks, or virtual memory tricks.)</source>
          <target state="translated">これが &lt;code&gt;Ok&lt;/code&gt; を返す場合、アロケータは、 &lt;code&gt;ptr&lt;/code&gt; によって参照されるメモリブロックが &lt;code&gt;new_size&lt;/code&gt; に適合することをアサートしているため、そのサイズのレイアウトのデータを運ぶために使用でき、layoutと同じ配置になり &lt;code&gt;layout&lt;/code&gt; 。（アロケーターは、メモリブロックを拡張して後続のブロックや仮想メモリトリックを含めるなど、これを達成するための労力を費やすことができます。）</target>
        </trans-unit>
        <trans-unit id="265c1e3719888af4af19b397644a5084b5b82f03" translate="yes" xml:space="preserve">
          <source>If this returns &lt;code&gt;Ok&lt;/code&gt;, then the allocator has asserted that the memory block referenced by &lt;code&gt;ptr&lt;/code&gt; now fits &lt;code&gt;new_size&lt;/code&gt;, and thus can only be used to carry data of that smaller layout. (The allocator is allowed to take advantage of this, carving off portions of the block for reuse elsewhere.) The truncated contents of the block within the smaller layout are unaltered, and ownership of block has not been transferred.</source>
          <target state="translated">これが &lt;code&gt;Ok&lt;/code&gt; を返す場合、アロケータは、 &lt;code&gt;ptr&lt;/code&gt; によって参照されるメモリブロックが &lt;code&gt;new_size&lt;/code&gt; に適合することを表明しているため、そのより小さなレイアウトのデータを運ぶためにのみ使用できます。（アロケーターはこれを利用して、ブロックの一部を切り取って他の場所で再利用できます。）小さいレイアウト内のブロックの切り捨てられた内容は変更されず、ブロックの所有権は転送されていません。</target>
        </trans-unit>
        <trans-unit id="1e21899c81274a7e69e0d33ce177abd176697388" translate="yes" xml:space="preserve">
          <source>If this returns a non-null pointer, then ownership of the memory block referenced by &lt;code&gt;ptr&lt;/code&gt; has been transferred to this allocator. The memory may or may not have been deallocated, and should be considered unusable (unless of course it was transferred back to the caller again via the return value of this method).</source>
          <target state="translated">これがnull以外のポインタを返す場合、 &lt;code&gt;ptr&lt;/code&gt; によって参照されるメモリブロックの所有権はこのアロケータに転送されています。メモリは割り当て解除されている場合とされていない場合があり、使用不可と見なされます（もちろん、このメソッドの戻り値を介して呼び出し元に再度転送された場合を除く）。</target>
        </trans-unit>
        <trans-unit id="8d4043cdbda910f0ad6a1a1cd5c98aae741eec3c" translate="yes" xml:space="preserve">
          <source>If this returns a non-null pointer, then ownership of the memory block referenced by &lt;code&gt;ptr&lt;/code&gt; has been transferred to this allocator. The memory may or may not have been deallocated, and should be considered unusable (unless of course it was transferred back to the caller again via the return value of this method). The new memory block is allocated with &lt;code&gt;layout&lt;/code&gt;, but with the &lt;code&gt;size&lt;/code&gt; updated to &lt;code&gt;new_size&lt;/code&gt;.</source>
          <target state="translated">If this returns a non-null pointer, then ownership of the memory block referenced by &lt;code&gt;ptr&lt;/code&gt; has been transferred to this allocator. The memory may or may not have been deallocated, and should be considered unusable (unless of course it was transferred back to the caller again via the return value of this method). The new memory block is allocated with &lt;code&gt;layout&lt;/code&gt; , but with the &lt;code&gt;size&lt;/code&gt; updated to &lt;code&gt;new_size&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d52bbe20c5aac68705e76e7c5e6b2bad9de5e10" translate="yes" xml:space="preserve">
          <source>If this slice is not partitioned, the returned result is unspecified and meaningless, as this method performs a kind of binary search.</source>
          <target state="translated">このスライスが分割されていない場合、このメソッドは一種のバイナリ検索を行うため、返される結果は不特定で意味がありません。</target>
        </trans-unit>
        <trans-unit id="2533e7aaf9faf4802db49c2aac243e2b2261233a" translate="yes" xml:space="preserve">
          <source>If this syntax is used, then the number of characters to print precedes the actual object being formatted, and the number of characters must have the type &lt;a href=&quot;../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この構文を使用する場合、印刷する文字数は、フォーマットされる実際のオブジェクトの前にあり、文字数のタイプは&lt;a href=&quot;../primitive.usize&quot;&gt; &lt;code&gt;usize&lt;/code&gt; で&lt;/a&gt;なければなりません。</target>
        </trans-unit>
        <trans-unit id="64b179337be99298379500e406a343560aae2c69" translate="yes" xml:space="preserve">
          <source>If this would overflow the range of values supported by &lt;code&gt;Self&lt;/code&gt;, returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">If this would overflow the range of values supported by &lt;code&gt;Self&lt;/code&gt; , returns &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4b27728b02e3e78c5d0c38db43dde768cdde4959" translate="yes" xml:space="preserve">
          <source>If this would overflow the range of values supported by &lt;code&gt;Self&lt;/code&gt;, this function is allowed to panic, wrap, or saturate. The suggested behavior is to panic when debug assertions are enabled, and to wrap or saturate otherwise.</source>
          <target state="translated">If this would overflow the range of values supported by &lt;code&gt;Self&lt;/code&gt; , this function is allowed to panic, wrap, or saturate. The suggested behavior is to panic when debug assertions are enabled, and to wrap or saturate otherwise.</target>
        </trans-unit>
        <trans-unit id="d0df7d71ccb9fef6722d0478c8d5e8fc86939d3f" translate="yes" xml:space="preserve">
          <source>If two matched elements are directly adjacent, an empty slice will be present between them:</source>
          <target state="translated">マッチした2つの要素が直接隣接している場合、その間には空のスライスが存在します。</target>
        </trans-unit>
        <trans-unit id="aba72b6261d8cf54f8817ecf4602e9f657125528" translate="yes" xml:space="preserve">
          <source>If two sequence have equivalent elements and are of the same length, then the sequences are lexicographically equal.</source>
          <target state="translated">2つの配列が等価な要素を持ち、同じ長さである場合、その配列は語彙的に等しい。</target>
        </trans-unit>
        <trans-unit id="e3d45eebf9b7ed122af4ed423facfc2fe8966ab8" translate="yes" xml:space="preserve">
          <source>If we &lt;em&gt;do&lt;/em&gt; want to deeply copy the heap data of the &lt;code&gt;String&lt;/code&gt;, not just the stack data, we can use a common method called &lt;code&gt;clone&lt;/code&gt;. We&amp;rsquo;ll discuss method syntax in Chapter 5, but because methods are a common feature in many programming languages, you&amp;rsquo;ve probably seen them before.</source>
          <target state="translated">スタックデータだけでなく、 &lt;code&gt;String&lt;/code&gt; のヒープデータを深くコピー&lt;em&gt;し&lt;/em&gt;たい場合は、 &lt;code&gt;clone&lt;/code&gt; と呼ばれる一般的なメソッドを使用できます。メソッド構文については第5章で説明しますが、メソッドは多くのプログラミング言語で共通の機能であるため、おそらく以前に見たことがあるでしょう。</target>
        </trans-unit>
        <trans-unit id="401dbe72f6e067cf29a630716f3d3b23f7eb7742" translate="yes" xml:space="preserve">
          <source>If we compile this code right now, we&amp;rsquo;ll get this error:</source>
          <target state="translated">このコードを今すぐコンパイルすると、次のエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="47e134e66136b075454568cd0131337b49150e26" translate="yes" xml:space="preserve">
          <source>If we continue reading the errors, we&amp;rsquo;ll find this helpful note:</source>
          <target state="translated">エラーを読み続けると、次の役立つメモが見つかります。</target>
        </trans-unit>
        <trans-unit id="d42c7d1da5d982e675dccc0a9e2a41b79cecc88f" translate="yes" xml:space="preserve">
          <source>If we control the definition of a type, we can implement &lt;code&gt;Clone&lt;/code&gt; on it ourselves with &lt;code&gt;#[derive(Clone)]&lt;/code&gt;.</source>
          <target state="translated">型の定義を制御する場合、 &lt;code&gt;#[derive(Clone)]&lt;/code&gt; を使用して自分で &lt;code&gt;Clone&lt;/code&gt; を実装できます。</target>
        </trans-unit>
        <trans-unit id="87e3953b2e8c7c5293b9804529d84ebcbc0b39fd" translate="yes" xml:space="preserve">
          <source>If we don&amp;rsquo;t add the type annotation here, Rust will display the following error, which means the compiler needs more information from us to know which type we want to use:</source>
          <target state="translated">ここで型注釈を追加しない場合、Rustは次のエラーを表示します。これは、使用する型を知るために、コンパイラーがさらに情報を必要とすることを意味します。</target>
        </trans-unit>
        <trans-unit id="64f181d4acc8150a490f15e9bd18aaaa910dbc02" translate="yes" xml:space="preserve">
          <source>If we don&amp;rsquo;t want to restrict the &lt;code&gt;largest&lt;/code&gt; function to the types that implement the &lt;code&gt;Copy&lt;/code&gt; trait, we could specify that &lt;code&gt;T&lt;/code&gt; has the trait bound &lt;code&gt;Clone&lt;/code&gt; instead of &lt;code&gt;Copy&lt;/code&gt;. Then we could clone each value in the slice when we want the &lt;code&gt;largest&lt;/code&gt; function to have ownership. Using the &lt;code&gt;clone&lt;/code&gt; function means we&amp;rsquo;re potentially making more heap allocations in the case of types that own heap data like &lt;code&gt;String&lt;/code&gt;, and heap allocations can be slow if we&amp;rsquo;re working with large amounts of data.</source>
          <target state="translated">&lt;code&gt;largest&lt;/code&gt; 関数を &lt;code&gt;Copy&lt;/code&gt; トレイトを実装する型に制限したくない場合は、 &lt;code&gt;T&lt;/code&gt; が &lt;code&gt;Copy&lt;/code&gt; ではなく &lt;code&gt;Clone&lt;/code&gt; トレイトにバインドされていることを指定できます。次に、 &lt;code&gt;largest&lt;/code&gt; 関数に所有権を持たせたい場合は、スライスの各値を複製できます。 &lt;code&gt;clone&lt;/code&gt; 関数を使用するということは、 &lt;code&gt;String&lt;/code&gt; のようなヒープデータを所有する型の場合、より多くのヒープ割り当てを行う可能性があることを意味します。大量のデータを処理している場合、ヒープ割り当てが遅くなる可能性があります。</target>
        </trans-unit>
        <trans-unit id="9f4e2a91ce5b3d093909a51433f578b35d100485" translate="yes" xml:space="preserve">
          <source>If we forget the lifetime annotations and try to compile this function, we&amp;rsquo;ll get this error:</source>
          <target state="translated">ライフタイムアノテーションを忘れてこの関数をコンパイルしようとすると、次のエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="d50142aed73fdab3ce99830192ece11c222bce36" translate="yes" xml:space="preserve">
          <source>If we get the lock on the mutex, we call &lt;code&gt;recv&lt;/code&gt; to receive a &lt;code&gt;Job&lt;/code&gt; from the channel. A final &lt;code&gt;unwrap&lt;/code&gt; moves past any errors here as well, which might occur if the thread holding the sending side of the channel has shut down, similar to how the &lt;code&gt;send&lt;/code&gt; method returns &lt;code&gt;Err&lt;/code&gt; if the receiving side shuts down.</source>
          <target state="translated">mutexでロックを取得したら、 &lt;code&gt;recv&lt;/code&gt; を呼び出してチャネルから &lt;code&gt;Job&lt;/code&gt; を受信します。最後の &lt;code&gt;unwrap&lt;/code&gt; は、ここでもエラーを通過します。これは、チャネルの送信側を保持するスレッドがシャットダウンした場合に発生する可能性があります。これは、受信側がシャットダウンした場合に &lt;code&gt;send&lt;/code&gt; メソッドが &lt;code&gt;Err&lt;/code&gt; を返すのと同様です。</target>
        </trans-unit>
        <trans-unit id="0fca700376fa2044b0a30ebcc11fb4a985b05812" translate="yes" xml:space="preserve">
          <source>If we hadn&amp;rsquo;t listed the &lt;code&gt;use std::io&lt;/code&gt; line at the beginning of the program, we could have written this function call as &lt;code&gt;std::io::stdin&lt;/code&gt;. The &lt;code&gt;stdin&lt;/code&gt; function returns an instance of &lt;a href=&quot;../std/io/struct.stdin&quot;&gt;&lt;code&gt;std::io::Stdin&lt;/code&gt;&lt;/a&gt;, which is a type that represents a handle to the standard input for your terminal.</source>
          <target state="translated">プログラムの最初に &lt;code&gt;use std::io&lt;/code&gt; 行をリストしていなかった場合は、この関数呼び出しを &lt;code&gt;std::io::stdin&lt;/code&gt; として記述できます。 &lt;code&gt;stdin&lt;/code&gt; 関数は、のインスタンスを返す&lt;a href=&quot;../std/io/struct.stdin&quot;&gt; &lt;code&gt;std::io::Stdin&lt;/code&gt; &lt;/a&gt;お使いの端末の標準入力へのハンドルを表しタイプです。</target>
        </trans-unit>
        <trans-unit id="04a189966ad80f06981ca07607a5760233b03d38" translate="yes" xml:space="preserve">
          <source>If we hadn&amp;rsquo;t put the &lt;code&gt;use std::io&lt;/code&gt; line at the beginning of the program, we could have written this function call as &lt;code&gt;std::io::stdin&lt;/code&gt;. The &lt;code&gt;stdin&lt;/code&gt; function returns an instance of &lt;a href=&quot;../std/io/struct.stdin&quot;&gt;&lt;code&gt;std::io::Stdin&lt;/code&gt;&lt;/a&gt;, which is a type that represents a handle to the standard input for your terminal.</source>
          <target state="translated">If we hadn&amp;rsquo;t put the &lt;code&gt;use std::io&lt;/code&gt; line at the beginning of the program, we could have written this function call as &lt;code&gt;std::io::stdin&lt;/code&gt; . The &lt;code&gt;stdin&lt;/code&gt; function returns an instance of &lt;a href=&quot;../std/io/struct.stdin&quot;&gt; &lt;code&gt;std::io::Stdin&lt;/code&gt; &lt;/a&gt;, which is a type that represents a handle to the standard input for your terminal.</target>
        </trans-unit>
        <trans-unit id="86bab42cdbe16f85be0625509956004f41556e40" translate="yes" xml:space="preserve">
          <source>If we have a more complex key, calls to &lt;code&gt;insert&lt;/code&gt; will not update the value of the key. For example:</source>
          <target state="translated">より複雑なキーがある場合、 &lt;code&gt;insert&lt;/code&gt; を呼び出してもキーの値は更新されません。例えば：</target>
        </trans-unit>
        <trans-unit id="3e6f59e85b3f49aeec8c0c885c1d87959b650a9b" translate="yes" xml:space="preserve">
          <source>If we have a string slice, we can pass that directly. If we have a &lt;code&gt;String&lt;/code&gt;, we can pass a slice of the entire &lt;code&gt;String&lt;/code&gt;. Defining a function to take a string slice instead of a reference to a &lt;code&gt;String&lt;/code&gt; makes our API more general and useful without losing any functionality:</source>
          <target state="translated">文字列スライスがある場合は、直接渡すことができます。我々が持っている場合は &lt;code&gt;String&lt;/code&gt; 、我々は全体のスライス渡すことができます &lt;code&gt;String&lt;/code&gt; 。代わりに参照の文字列スライス取るように関数を定義する &lt;code&gt;String&lt;/code&gt; 任意の機能を失うことなく、当社のAPIがより一般的で有用なものにします：</target>
        </trans-unit>
        <trans-unit id="ac138ffa3b0aa3b072eefcab1045b74eb7d1fd32" translate="yes" xml:space="preserve">
          <source>If we insert a key and a value into a hash map and then insert that same key with a different value, the value associated with that key will be replaced. Even though the code in Listing 8-24 calls &lt;code&gt;insert&lt;/code&gt; twice, the hash map will only contain one key/value pair because we&amp;rsquo;re inserting the value for the Blue team&amp;rsquo;s key both times.</source>
          <target state="translated">キーと値をハッシュマップに挿入してから、同じキーを異なる値で挿入すると、そのキーに関連付けられている値が置き換えられます。リスト8-24のコードは &lt;code&gt;insert&lt;/code&gt; を 2回実行していますが、Blueチームのキーの値を両方とも挿入しているため、ハッシュマップにはキーと値のペアが1つしか含まれていません。</target>
        </trans-unit>
        <trans-unit id="543a3a170d1010f43b117fa4c1442ab0b46b4495" translate="yes" xml:space="preserve">
          <source>If we insert references to values into the hash map, the values won&amp;rsquo;t be moved into the hash map. The values that the references point to must be valid for at least as long as the hash map is valid. We&amp;rsquo;ll talk more about these issues in the &lt;a href=&quot;ch10-03-lifetime-syntax#validating-references-with-lifetimes&quot;&gt;&amp;ldquo;Validating References with Lifetimes&amp;rdquo;&lt;/a&gt; section in Chapter 10.</source>
          <target state="translated">ハッシュマップに値への参照を挿入しても、値はハッシュマップに移動されません。参照が指す値は、少なくともハッシュマップが有効である限り有効である必要があります。これらの問題については、第10章の&lt;a href=&quot;ch10-03-lifetime-syntax#validating-references-with-lifetimes&quot;&gt;「有効期間による参照の検証」&lt;/a&gt;セクションで詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="48b30993a53ec7ab3753fc22f9cfc6b10c4026a3" translate="yes" xml:space="preserve">
          <source>If we look at the Hindi word &amp;ldquo;नमस्ते&amp;rdquo; written in the Devanagari script, it is stored as a vector of &lt;code&gt;u8&lt;/code&gt; values that looks like this:</source>
          <target state="translated">Devanagariスクリプトで書かれたヒンディー語の「नमस्ते」を見ると、次のような &lt;code&gt;u8&lt;/code&gt; 値のベクトルとして格納されています。</target>
        </trans-unit>
        <trans-unit id="ceefcf2e8fb61a92a19892547650cfb486bbbfbc" translate="yes" xml:space="preserve">
          <source>If we need to concatenate multiple strings, the behavior of the &lt;code&gt;+&lt;/code&gt; operator gets unwieldy:</source>
          <target state="translated">複数の文字列を連結する必要がある場合、 &lt;code&gt;+&lt;/code&gt; 演算子の動作は扱いにくくなります。</target>
        </trans-unit>
        <trans-unit id="bef4e363e9355203a78ff831eeab87691d89132c" translate="yes" xml:space="preserve">
          <source>If we run the tests without passing any arguments, as we saw earlier, all the tests will run in parallel:</source>
          <target state="translated">先ほど見たように、引数を渡さずにテストを実行すると、すべてのテストが並行して実行されます。</target>
        </trans-unit>
        <trans-unit id="ef6509c394cc9b5a25c62c835728d6447e229bde" translate="yes" xml:space="preserve">
          <source>If we run this code without a &lt;em&gt;hello.txt&lt;/em&gt; file, we&amp;rsquo;ll see an error message from the &lt;code&gt;panic!&lt;/code&gt; call that the &lt;code&gt;unwrap&lt;/code&gt; method makes:</source>
          <target state="translated">&lt;em&gt;hello.txt&lt;/em&gt;ファイルなしでこのコードを実行すると、 &lt;code&gt;panic!&lt;/code&gt; からのエラーメッセージが表示されます。 &lt;code&gt;unwrap&lt;/code&gt; メソッドが行う呼び出し：</target>
        </trans-unit>
        <trans-unit id="411b71603dc821df269f0168d402fe39b58175ea" translate="yes" xml:space="preserve">
          <source>If we run this code, we get an error message like this:</source>
          <target state="translated">このコードを実行すると、このようなエラーメッセージが表示されます。</target>
        </trans-unit>
        <trans-unit id="9a30a99adbc91389f388f95d8ce88be5cc567df1" translate="yes" xml:space="preserve">
          <source>If we tried to use &lt;code&gt;s&lt;/code&gt; after the call to &lt;code&gt;takes_ownership&lt;/code&gt;, Rust would throw a compile-time error. These static checks protect us from mistakes. Try adding code to &lt;code&gt;main&lt;/code&gt; that uses &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; to see where you can use them and where the ownership rules prevent you from doing so.</source>
          <target state="translated">&lt;code&gt;takes_ownership&lt;/code&gt; の呼び出し後に &lt;code&gt;s&lt;/code&gt; を使用しようとすると、Rustはコンパイル時エラーをスローします。これらの静的チェックはミスから私たちを守ります。 &lt;code&gt;s&lt;/code&gt; と &lt;code&gt;x&lt;/code&gt; を使用するコードを &lt;code&gt;main&lt;/code&gt; に追加して、それらをどこで使用できるか、また所有権のルールによってどこで使用できないかを確認してください。</target>
        </trans-unit>
        <trans-unit id="5b3d2369c0d31316ed024d7ec48406786e9f748a" translate="yes" xml:space="preserve">
          <source>If we tried to write &lt;code&gt;assert_eq!(5, y);&lt;/code&gt; instead, we would get this compilation error:</source>
          <target state="translated">&lt;code&gt;assert_eq!(5, y);&lt;/code&gt; を書こうとした場合 代わりに、次のコンパイルエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="d0808380a836c64109f92b188e2221162883a939" translate="yes" xml:space="preserve">
          <source>If we try to access the parent of &lt;code&gt;leaf&lt;/code&gt; after the end of the scope, we&amp;rsquo;ll get &lt;code&gt;None&lt;/code&gt; again. At the end of the program, the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; in &lt;code&gt;leaf&lt;/code&gt; has a strong count of 1 and a weak count of 0, because the variable &lt;code&gt;leaf&lt;/code&gt; is now the only reference to the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; again.</source>
          <target state="translated">スコープの終了後に &lt;code&gt;leaf&lt;/code&gt; の親にアクセスしようとすると、再び &lt;code&gt;None&lt;/code&gt; が返されます。プログラムの終了時に、 &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; で &lt;code&gt;leaf&lt;/code&gt; 可変のため、1の強力な数と0の弱い数を持っている &lt;code&gt;leaf&lt;/code&gt; 、今への参照のみである &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; もう一度。</target>
        </trans-unit>
        <trans-unit id="dbfc404f11392f04791b1e2ab5a9b874585793ff" translate="yes" xml:space="preserve">
          <source>If we try to call the &lt;code&gt;Drop&lt;/code&gt; trait&amp;rsquo;s &lt;code&gt;drop&lt;/code&gt; method manually by modifying the &lt;code&gt;main&lt;/code&gt; function from Listing 15-14, as shown in Listing 15-15, we&amp;rsquo;ll get a compiler error:</source>
          <target state="translated">リスト15-15に示すように、リスト15-14の &lt;code&gt;main&lt;/code&gt; 関数を変更して &lt;code&gt;Drop&lt;/code&gt; トレイトの &lt;code&gt;drop&lt;/code&gt; メソッドを手動で呼び出そうとすると、コンパイラエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="508b7cd6a86a635fd3e7f2924e5c92cb610d409e" translate="yes" xml:space="preserve">
          <source>If we try to compile the code in Listing 15-3, we get the error shown in Listing 15-4:</source>
          <target state="translated">リスト15-3のコードをコンパイルしようとすると、リスト15-4で示されるようなエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="356aa3ddcc40c463be6fae51bd6d2da9e98de1a0" translate="yes" xml:space="preserve">
          <source>If we try to implement the &lt;code&gt;longest&lt;/code&gt; function as shown in Listing 10-21, it won&amp;rsquo;t compile.</source>
          <target state="translated">リスト10-21で示されるように &lt;code&gt;longest&lt;/code&gt; 関数を実装しようとすると、コンパイルされません。</target>
        </trans-unit>
        <trans-unit id="4115f2934de822135b29f8084e1ef304be3b3698" translate="yes" xml:space="preserve">
          <source>If we try to violate these rules, rather than getting a compiler error as we would with references, the implementation of &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; will panic at runtime. Listing 15-23 shows a modification of the implementation of &lt;code&gt;send&lt;/code&gt; in Listing 15-22. We&amp;rsquo;re deliberately trying to create two mutable borrows active for the same scope to illustrate that &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; prevents us from doing this at runtime.</source>
          <target state="translated">これらのルールに違反しようとすると、参照の場合のようにコンパイラエラーが発生するのではなく、 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 実装が実行時にパニックになります。リスト15-23はリスト15-22 の &lt;code&gt;send&lt;/code&gt; の実装の修正を示しています。 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; が実行時にこれを実行できないようにするために、同じスコープに対してアクティブな2つの可変借入を意図的に作成しようとしています。</target>
        </trans-unit>
        <trans-unit id="33490125b250fc49578a0df8c40853722c24e45b" translate="yes" xml:space="preserve">
          <source>If we use &lt;code&gt;None&lt;/code&gt; rather than &lt;code&gt;Some&lt;/code&gt;, we need to tell Rust what type of &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; we have, because the compiler can&amp;rsquo;t infer the type that the &lt;code&gt;Some&lt;/code&gt; variant will hold by looking only at a &lt;code&gt;None&lt;/code&gt; value.</source>
          <target state="translated">&lt;code&gt;Some&lt;/code&gt; ではなく &lt;code&gt;None&lt;/code&gt; を使用する場合は、コンパイラーが &lt;code&gt;None&lt;/code&gt; の値だけを見て &lt;code&gt;Some&lt;/code&gt; バリアントが保持する型を推測できないため、Rustにどのタイプの &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; があるかを通知する必要があります。</target>
        </trans-unit>
        <trans-unit id="db89280f9463246331f861bb20b0b44756cbd59b" translate="yes" xml:space="preserve">
          <source>If we want to access each element in a vector in turn, we can iterate through all of the elements rather than use indices to access one at a time. Listing 8-8 shows how to use a &lt;code&gt;for&lt;/code&gt; loop to get immutable references to each element in a vector of &lt;code&gt;i32&lt;/code&gt; values and print them.</source>
          <target state="translated">ベクトルの各要素に順番にアクセスする場合は、インデックスを使用して一度に1つずつアクセスするのではなく、すべての要素を反復処理できます。リスト8-8は、 &lt;code&gt;for&lt;/code&gt; ループを使用して &lt;code&gt;i32&lt;/code&gt; 値のベクトルの各要素への不変の参照を取得し、それらを出力する方法を示しています。</target>
        </trans-unit>
        <trans-unit id="59b1ce32c14325e5555ecb1473306e5c2ee4df8e" translate="yes" xml:space="preserve">
          <source>If we want to bring &lt;em&gt;all&lt;/em&gt; public items defined in a path into scope, we can specify that path followed by &lt;code&gt;*&lt;/code&gt;, the glob operator:</source>
          <target state="translated">私たちが持参したい場合は&lt;em&gt;、すべての&lt;/em&gt;スコープにパスで定義されている公共のアイテムを、私たちはそのパスを指定することができますが続く &lt;code&gt;*&lt;/code&gt; 、グロブ演算子：</target>
        </trans-unit>
        <trans-unit id="ecacd2ec61672bd426d468428f535112c37b0728" translate="yes" xml:space="preserve">
          <source>If we want to see printed values for passing tests as well, we can disable the output capture behavior by using the &lt;code&gt;--nocapture&lt;/code&gt; flag:</source>
          <target state="translated">テストに合格するための出力値も確認したい場合は、 &lt;code&gt;--nocapture&lt;/code&gt; フラグを使用して出力キャプチャ動作を無効にすることができます。</target>
        </trans-unit>
        <trans-unit id="05c7ba5ef2e7723af5524e8b4d89c5b4dc32b80d" translate="yes" xml:space="preserve">
          <source>If we want to see printed values for passing tests as well, we can tell Rust to also show the output of successful tests at the end with &lt;code&gt;--show-output&lt;/code&gt;.</source>
          <target state="translated">If we want to see printed values for passing tests as well, we can tell Rust to also show the output of successful tests at the end with &lt;code&gt;--show-output&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8a582928a24dff1951656692ced5e56692b89dd3" translate="yes" xml:space="preserve">
          <source>If we wanted this function to allow &lt;code&gt;item1&lt;/code&gt; and &lt;code&gt;item2&lt;/code&gt; to have different types, using &lt;code&gt;impl Trait&lt;/code&gt; would be appropriate (as long as both types implement &lt;code&gt;Summary&lt;/code&gt;). If we wanted to force both parameters to have the same type, that&amp;rsquo;s only possible to express using a trait bound, like this:</source>
          <target state="translated">この関数で &lt;code&gt;item1&lt;/code&gt; と &lt;code&gt;item2&lt;/code&gt; に異なるタイプを許可したい場合、（両方のタイプが &lt;code&gt;Summary&lt;/code&gt; を実装している限り） &lt;code&gt;impl Trait&lt;/code&gt; を使用するのが適切です。両方のパラメーターに同じ型を強制したい場合は、次のように、特性の境界を使用してのみ表現できます。</target>
        </trans-unit>
        <trans-unit id="081b049808c06cb466640ee9a7514dc2c103759d" translate="yes" xml:space="preserve">
          <source>If we wanted to ignore one or more of the values in the tuple, we could use &lt;code&gt;_&lt;/code&gt; or &lt;code&gt;..&lt;/code&gt;, as you&amp;rsquo;ll see in the &lt;a href=&quot;ch18-03-pattern-syntax#ignoring-values-in-a-pattern&quot;&gt;&amp;ldquo;Ignoring Values in a Pattern&amp;rdquo;&lt;/a&gt; section. If the problem is that we have too many variables in the pattern, the solution is to make the types match by removing variables so the number of variables equals the number of elements in the tuple.</source>
          <target state="translated">タプルの1つ以上の値を無視する場合は、&lt;a href=&quot;ch18-03-pattern-syntax#ignoring-values-in-a-pattern&quot;&gt;「パターンの値を無視する」&lt;/a&gt;セクションで説明するように、 &lt;code&gt;_&lt;/code&gt; または &lt;code&gt;..&lt;/code&gt; を使用できます。問題がパターン内の変数が多すぎることである場合、解決策は、変数を削除して型を一致させ、変数の数がタプル内の要素の数と等しくなるようにすることです。</target>
        </trans-unit>
        <trans-unit id="43509b2eb6e52b66cb9ff0f7f464bfc498c6c385" translate="yes" xml:space="preserve">
          <source>If we were allowed to run this code, there&amp;rsquo;s a possibility the spawned thread would be immediately put in the background without running at all. The spawned thread has a reference to &lt;code&gt;v&lt;/code&gt; inside, but the main thread immediately drops &lt;code&gt;v&lt;/code&gt;, using the &lt;code&gt;drop&lt;/code&gt; function we discussed in Chapter 15. Then, when the spawned thread starts to execute, &lt;code&gt;v&lt;/code&gt; is no longer valid, so a reference to it is also invalid. Oh no!</source>
          <target state="translated">このコードの実行が許可されている場合、生成されたスレッドはまったく実行されずにすぐにバックグラウンドに置かれる可能性があります。生成されたスレッドは内部で &lt;code&gt;v&lt;/code&gt; への参照を持っていますが、メインスレッドは、第15章で説明した &lt;code&gt;drop&lt;/code&gt; 関数を使用してすぐに &lt;code&gt;v&lt;/code&gt; を削除します。その後、生成されたスレッドが実行を開始すると、 &lt;code&gt;v&lt;/code&gt; は無効になるため、その参照はまた無効です。大野！</target>
        </trans-unit>
        <trans-unit id="800a58868e2237c8fac619c4b8e2c0a22bb50724" translate="yes" xml:space="preserve">
          <source>If we were to call &lt;code&gt;value_in_cents(Coin::Quarter(UsState::Alaska))&lt;/code&gt;, &lt;code&gt;coin&lt;/code&gt; would be &lt;code&gt;Coin::Quarter(UsState::Alaska)&lt;/code&gt;. When we compare that value with each of the match arms, none of them match until we reach &lt;code&gt;Coin::Quarter(state)&lt;/code&gt;. At that point, the binding for &lt;code&gt;state&lt;/code&gt; will be the value &lt;code&gt;UsState::Alaska&lt;/code&gt;. We can then use that binding in the &lt;code&gt;println!&lt;/code&gt; expression, thus getting the inner state value out of the &lt;code&gt;Coin&lt;/code&gt; enum variant for &lt;code&gt;Quarter&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;value_in_cents(Coin::Quarter(UsState::Alaska))&lt;/code&gt; を呼び出すと、 &lt;code&gt;coin&lt;/code&gt; は &lt;code&gt;Coin::Quarter(UsState::Alaska)&lt;/code&gt; ます。その値を各マッチアームと比較すると、 &lt;code&gt;Coin::Quarter(state)&lt;/code&gt; 到達するまで、どのマッチアームも一致しません。その時点で、 &lt;code&gt;state&lt;/code&gt; のバインディングは値 &lt;code&gt;UsState::Alaska&lt;/code&gt; ます。その後、そのバインディングを &lt;code&gt;println!&lt;/code&gt; で使用できます！式、つまり &lt;code&gt;Quarter&lt;/code&gt; の &lt;code&gt;Coin&lt;/code&gt; enumバリアントから内部状態値を取得します。</target>
        </trans-unit>
        <trans-unit id="24bb7707d39d3c3128c279561fde2df4d9c496d5" translate="yes" xml:space="preserve">
          <source>If we were to create an alternative implementation that didn&amp;rsquo;t use the state pattern, we might instead use &lt;code&gt;match&lt;/code&gt; expressions in the methods on &lt;code&gt;Post&lt;/code&gt; or even in the &lt;code&gt;main&lt;/code&gt; code that checks the state of the post and changes behavior in those places. That would mean we would have to look in several places to understand all the implications of a post being in the published state! This would only increase the more states we added: each of those &lt;code&gt;match&lt;/code&gt; expressions would need another arm.</source>
          <target state="translated">状態パターンを使用しない代替実装を作成する場合、代わりに &lt;code&gt;Post&lt;/code&gt; のメソッドで、または投稿の状態をチェックしてそれらの場所の動作を変更する &lt;code&gt;main&lt;/code&gt; コードで、 &lt;code&gt;match&lt;/code&gt; 式を使用する場合があります。つまり、投稿が公開済みであることのすべての影響を理解するには、いくつかの場所を調べる必要があります。これにより、追加した状態が増えるだけです。これらの &lt;code&gt;match&lt;/code&gt; 式のそれぞれに別のアームが必要になります。</target>
        </trans-unit>
        <trans-unit id="75317df9fc9654e5dff79b3ede765cb275596098" translate="yes" xml:space="preserve">
          <source>If we&amp;rsquo;re using multiple items defined in the same crate or same module, listing each item on its own line can take up a lot of vertical space in our files. For example, these two &lt;code&gt;use&lt;/code&gt; statements we had in the Guessing Game in Listing 2-4 bring items from &lt;code&gt;std&lt;/code&gt; into scope:</source>
          <target state="translated">If we&amp;rsquo;re using multiple items defined in the same crate or same module, listing each item on its own line can take up a lot of vertical space in our files. For example, these two &lt;code&gt;use&lt;/code&gt; statements we had in the Guessing Game in Listing 2-4 bring items from &lt;code&gt;std&lt;/code&gt; into scope:</target>
        </trans-unit>
        <trans-unit id="8c510fe09c79d935a20cfb821edcb59eeece4e5e" translate="yes" xml:space="preserve">
          <source>If we&amp;rsquo;re using multiple items defined in the same package or same module, listing each item on its own line can take up a lot of vertical space in our files. For example, these two &lt;code&gt;use&lt;/code&gt; statements we had in Listing 2-4 in the Guessing Game bring items from &lt;code&gt;std&lt;/code&gt; into scope:</source>
          <target state="translated">同じパッケージまたは同じモジュールで定義された複数のアイテムを使用している場合、各アイテムを1行にリストすると、ファイル内で多くの垂直方向のスペースを占める可能性があります。たとえば、ゲスティングゲームのリスト2-4にある次の2つの &lt;code&gt;use&lt;/code&gt; ステートメントは、アイテムを &lt;code&gt;std&lt;/code&gt; からスコープに持ってきます。</target>
        </trans-unit>
        <trans-unit id="1e5c7c085207b2b3646e21a3cf1669e6a93ba6f6" translate="yes" xml:space="preserve">
          <source>If you &lt;em&gt;do&lt;/em&gt; write that in Rust, the compiler will give you a warning (by default, controlled by the &lt;code&gt;unused_must_use&lt;/code&gt; lint).</source>
          <target state="translated">あなたは場合に&lt;em&gt;行う&lt;/em&gt;ルーストに、コンパイラはあなたに（によって制御デフォルトでは、警告与えることを書き込み &lt;code&gt;unused_must_use&lt;/code&gt; の糸くずを）。</target>
        </trans-unit>
        <trans-unit id="0b6f4208cc3cd5d0efb30ee565f817f70bd28255" translate="yes" xml:space="preserve">
          <source>If you already know the name of what you are looking for, the fastest way to find it is to use the search bar at the top of the page.</source>
          <target state="translated">すでにお探しのものの名前がわかっている場合は、ページ上部の検索バーを利用するのが一番手っ取り早いです。</target>
        </trans-unit>
        <trans-unit id="6ecce765aae2c5dfe3bf74974f6a9aa5e5412c0c" translate="yes" xml:space="preserve">
          <source>If you are defining your own smart pointer type and would like to enable conversion from a sized to an unsized type with the &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0982-dst-coercion.md&quot;&gt;DST coercion system&lt;/a&gt;, use &lt;a href=&quot;std/ops/trait.coerceunsized&quot;&gt;&lt;code&gt;CoerceUnsized&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">独自のスマートポインター型を定義していて、&lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0982-dst-coercion.md&quot;&gt;DST強制システム&lt;/a&gt;を使用してサイズ付き型からサイズなし型への変換を有効にする&lt;a href=&quot;std/ops/trait.coerceunsized&quot;&gt; &lt;code&gt;CoerceUnsized&lt;/code&gt; &lt;/a&gt;代わりにCoerceUnsizedを使用してください。</target>
        </trans-unit>
        <trans-unit id="66477a0847de02b7542626d1278a3f568234bcb5" translate="yes" xml:space="preserve">
          <source>If you are good at thinking in types, you can think of &lt;code&gt;map()&lt;/code&gt; like this: If you have an iterator that gives you elements of some type &lt;code&gt;A&lt;/code&gt;, and you want an iterator of some other type &lt;code&gt;B&lt;/code&gt;, you can use &lt;code&gt;map()&lt;/code&gt;, passing a closure that takes an &lt;code&gt;A&lt;/code&gt; and returns a &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">タイプを考えるのが得意であれば、 &lt;code&gt;map()&lt;/code&gt; を次のように考えることができます。あるタイプ &lt;code&gt;A&lt;/code&gt; のエレメントを提供するイテレーターがあり、他のタイプ &lt;code&gt;B&lt;/code&gt; のイテレーターが必要な場合は、 &lt;code&gt;map()&lt;/code&gt; を使用できます。、 &lt;code&gt;A&lt;/code&gt; を受け取り、 &lt;code&gt;B&lt;/code&gt; を返すクロージャーを渡します。</target>
        </trans-unit>
        <trans-unit id="3dcd4a0e63a2a163e2870bf93d8878778590c39f" translate="yes" xml:space="preserve">
          <source>If you are sure that the byte slice is valid UTF-8, and you don't want to incur the overhead of the conversion, there is an unsafe version of this function, &lt;a href=&quot;struct.string#method.from_utf8_unchecked&quot;&gt;&lt;code&gt;from_utf8_unchecked&lt;/code&gt;&lt;/a&gt;, which has the same behavior but skips the checks.</source>
          <target state="translated">バイトスライスが有効なUTF-8であることが確実で、変換のオーバーヘッドを発生させたくない場合は、この関数の安全ではないバージョン&lt;a href=&quot;struct.string#method.from_utf8_unchecked&quot;&gt; &lt;code&gt;from_utf8_unchecked&lt;/code&gt; &lt;/a&gt;があります。これは同じ動作をしますが、チェックをスキップします。</target>
        </trans-unit>
        <trans-unit id="70a26cf07cad3d4651db91a560fa471c2d93cbb7" translate="yes" xml:space="preserve">
          <source>If you are sure that the byte slice is valid UTF-8, and you don't want to incur the overhead of the validity check, there is an unsafe version of this function, &lt;a href=&quot;fn.from_utf8_unchecked&quot;&gt;&lt;code&gt;from_utf8_unchecked&lt;/code&gt;&lt;/a&gt;, which has the same behavior but skips the check.</source>
          <target state="translated">バイトスライスが有効なUTF-8であることを確認し、有効性チェックのオーバーヘッドを発生させたくない場合は、この関数の安全でないバージョン&lt;a href=&quot;fn.from_utf8_unchecked&quot;&gt; &lt;code&gt;from_utf8_unchecked&lt;/code&gt; &lt;/a&gt;があります。これは同じ動作をしますが、チェックをスキップします。</target>
        </trans-unit>
        <trans-unit id="72764b3fde213adc88d425dd4be37c972ecfcc18" translate="yes" xml:space="preserve">
          <source>If you are sure that the byte slice is valid UTF-8, and you don't want to incur the overhead of the validity check, there is an unsafe version of this function, &lt;a href=&quot;struct.string#method.from_utf8_unchecked&quot;&gt;&lt;code&gt;from_utf8_unchecked&lt;/code&gt;&lt;/a&gt;, which has the same behavior but skips the check.</source>
          <target state="translated">バイトスライスが有効なUTF-8であることを確認し、有効性チェックのオーバーヘッドを発生させたくない場合は、この関数の安全でないバージョン&lt;a href=&quot;struct.string#method.from_utf8_unchecked&quot;&gt; &lt;code&gt;from_utf8_unchecked&lt;/code&gt; &lt;/a&gt;があります。これは同じ動作をしますが、チェックをスキップします。</target>
        </trans-unit>
        <trans-unit id="ec9b3e217ed7bc91bb00c80e7f9d1bd56da37e45" translate="yes" xml:space="preserve">
          <source>If you are sure the pointer can never be null and are looking for some kind of &lt;code&gt;as_mut_unchecked&lt;/code&gt; that returns the &lt;code&gt;&amp;amp;mut T&lt;/code&gt; instead of &lt;code&gt;Option&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt;, know that you can dereference the pointer directly.</source>
          <target state="translated">If you are sure the pointer can never be null and are looking for some kind of &lt;code&gt;as_mut_unchecked&lt;/code&gt; that returns the &lt;code&gt;&amp;amp;mut T&lt;/code&gt; instead of &lt;code&gt;Option&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt; , know that you can dereference the pointer directly.</target>
        </trans-unit>
        <trans-unit id="4e4c7437a6a564088a56f1865abca59f4d577976" translate="yes" xml:space="preserve">
          <source>If you are sure the pointer can never be null and are looking for some kind of &lt;code&gt;as_ref_unchecked&lt;/code&gt; that returns the &lt;code&gt;&amp;amp;T&lt;/code&gt; instead of &lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt;, know that you can dereference the pointer directly.</source>
          <target state="translated">ポインターがnullになり得ないことが確実で、 &lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt; ではなく &lt;code&gt;&amp;amp;T&lt;/code&gt; を返す何らかの &lt;code&gt;as_ref_unchecked&lt;/code&gt; を探している場合は、ポインターを直接逆参照できることを確認してください。</target>
        </trans-unit>
        <trans-unit id="a8aa6751d5dba0ca9b5b9835bc110d6acd1e850e" translate="yes" xml:space="preserve">
          <source>If you are trying to cast a numeric type to a bool, you can compare it with zero instead:</source>
          <target state="translated">数値型をboolにキャストしようとしている場合は、代わりにゼロと比較することができます。</target>
        </trans-unit>
        <trans-unit id="d1b515d34e658e3eaec145f92af8986a5d9085c3" translate="yes" xml:space="preserve">
          <source>If you are using shorthand field patterns but want to refer to the struct field by a different name, you should rename it explicitly.</source>
          <target state="translated">短縮フィールドパターンを使用しているが、構造体フィールドを別の名前で参照したい場合は、明示的に名前を変更する必要があります。</target>
        </trans-unit>
        <trans-unit id="667b81601454358fbbba0b10884eb54779935f54" translate="yes" xml:space="preserve">
          <source>If you are using shorthand field patterns but want to refer to the struct field by a different name, you should rename it explicitly. Struct fields are identified by the name used before the colon &lt;code&gt;:&lt;/code&gt; so struct patterns should resemble the declaration of the struct type being matched.</source>
          <target state="translated">If you are using shorthand field patterns but want to refer to the struct field by a different name, you should rename it explicitly. Struct fields are identified by the name used before the colon &lt;code&gt;:&lt;/code&gt; so struct patterns should resemble the declaration of the struct type being matched.</target>
        </trans-unit>
        <trans-unit id="52d98e4ed274b2f1754b60874045cd81c4a04b5d" translate="yes" xml:space="preserve">
          <source>If you are writing a program that will process an existing file format, check what that format's definition of whitespace is before using this function.</source>
          <target state="translated">既存のファイルフォーマットを処理するプログラムを書いている場合は、この関数を使用する前に、そのフォーマットの空白の定義を確認してください。</target>
        </trans-unit>
        <trans-unit id="3049570361a92b7df46a925de03339dbac72cca9" translate="yes" xml:space="preserve">
          <source>If you cannot access the directory containing the file, e.g., because of a permission error, this will return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">パーミッションエラーなどでファイルを含むディレクトリにアクセスできない場合、 &lt;code&gt;false&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="458a7fb4ac06186fc13af81b6a29de1ace17f81e" translate="yes" xml:space="preserve">
          <source>If you cannot use the &lt;code&gt;derive&lt;/code&gt; strategy, specify that your type implements &lt;code&gt;Eq&lt;/code&gt;, which has no methods:</source>
          <target state="translated">&lt;code&gt;derive&lt;/code&gt; 戦略を使用できない場合は、型がメソッドを持たない &lt;code&gt;Eq&lt;/code&gt; を実装することを指定します。</target>
        </trans-unit>
        <trans-unit id="d0466a77e31d18684a221949891d87548a998d3f" translate="yes" xml:space="preserve">
          <source>If you create a safe reference with lifetime &lt;code&gt;'a&lt;/code&gt; (either a &lt;code&gt;&amp;amp;T&lt;/code&gt; or &lt;code&gt;&amp;amp;mut T&lt;/code&gt; reference) that is accessible by safe code (for example, because you returned it), then you must not access the data in any way that contradicts that reference for the remainder of &lt;code&gt;'a&lt;/code&gt;. For example, this means that if you take the &lt;code&gt;*mut T&lt;/code&gt; from an &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; and cast it to an &lt;code&gt;&amp;amp;T&lt;/code&gt;, then the data in &lt;code&gt;T&lt;/code&gt; must remain immutable (modulo any &lt;code&gt;UnsafeCell&lt;/code&gt; data found within &lt;code&gt;T&lt;/code&gt;, of course) until that reference's lifetime expires. Similarly, if you create a &lt;code&gt;&amp;amp;mut T&lt;/code&gt; reference that is released to safe code, then you must not access the data within the &lt;code&gt;UnsafeCell&lt;/code&gt; until that reference expires.</source>
          <target state="translated">ライフタイム &lt;code&gt;'a&lt;/code&gt; （ &lt;code&gt;&amp;amp;T&lt;/code&gt; または &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 参照）を使用して、安全なコードからアクセスできる安全な参照を作成した場合（たとえば、それを返したため）、その参照と矛盾する方法でデータにアクセスしてはなりません。 &lt;code&gt;'a&lt;/code&gt; の残りの部分。あなたが取る場合にたとえば、これは手段 &lt;code&gt;*mut T&lt;/code&gt; から &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; し、それをキャスト &lt;code&gt;&amp;amp;T&lt;/code&gt; 、その後のデータ &lt;code&gt;T&lt;/code&gt; は不変のままでなければならない（モジュロ任意の &lt;code&gt;UnsafeCell&lt;/code&gt; のデータは、内で見つかった &lt;code&gt;T&lt;/code&gt; もちろん、）その参照の寿命まで期限切れ。同様に、 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 安全なコードにリリースされた参照の場合、その参照が期限切れになるまで &lt;code&gt;UnsafeCell&lt;/code&gt; 内のデータにアクセスしてはなりません。</target>
        </trans-unit>
        <trans-unit id="0185ed1fba59b251fe1857608aaa4660006fe514" translate="yes" xml:space="preserve">
          <source>If you create a variable but don&amp;rsquo;t use it anywhere, Rust will usually issue a warning because that could be a bug. But sometimes it&amp;rsquo;s useful to create a variable you won&amp;rsquo;t use yet, such as when you&amp;rsquo;re prototyping or just starting a project. In this situation, you can tell Rust not to warn you about the unused variable by starting the name of the variable with an underscore. In Listing 18-20, we create two unused variables, but when we run this code, we should only get a warning about one of them.</source>
          <target state="translated">変数を作成し、それをどこでも使用しない場合、バグである可能性があるため、Rustは通常警告を発行します。ただし、プロトタイプを作成しているときやプロジェクトを開始するときなど、まだ使用しない変数を作成すると便利な場合があります。この状況では、アンダースコアで変数名を開始することにより、未使用の変数について警告しないようにRustに指示できます。リスト18-20では、2つの未使用の変数を作成していますが、このコードを実行すると、そのうちの1つについてのみ警告が表示されます。</target>
        </trans-unit>
        <trans-unit id="53d962e32cf41eea1b88858329905f991b93fcaa" translate="yes" xml:space="preserve">
          <source>If you decide to use trait objects, be aware that these rely on &lt;a href=&quot;book/ch17-02-trait-objects#trait-objects-perform-dynamic-dispatch&quot;&gt;dynamic dispatch&lt;/a&gt;, which has performance implications, as the compiler needs to emit code that will figure out which method to call &lt;em&gt;at runtime&lt;/em&gt; instead of during compilation. Using trait objects we are trading flexibility for performance.</source>
          <target state="translated">If you decide to use trait objects, be aware that these rely on &lt;a href=&quot;book/ch17-02-trait-objects#trait-objects-perform-dynamic-dispatch&quot;&gt;dynamic dispatch&lt;/a&gt;, which has performance implications, as the compiler needs to emit code that will figure out which method to call &lt;em&gt;at runtime&lt;/em&gt; instead of during compilation. Using trait objects we are trading flexibility for performance.</target>
        </trans-unit>
        <trans-unit id="495358664585a670e9065e75b0da97e6c9808c60" translate="yes" xml:space="preserve">
          <source>If you do not have an &lt;code&gt;&amp;amp;T&lt;/code&gt;, but just an &lt;code&gt;&amp;amp;U&lt;/code&gt; such that &lt;code&gt;T: Borrow&amp;lt;U&amp;gt;&lt;/code&gt; (e.g. &lt;code&gt;String: Borrow&amp;lt;str&amp;gt;&lt;/code&gt;), you can use &lt;code&gt;iter().any&lt;/code&gt;:</source>
          <target state="translated">If you do not have an &lt;code&gt;&amp;amp;T&lt;/code&gt; , but just an &lt;code&gt;&amp;amp;U&lt;/code&gt; such that &lt;code&gt;T: Borrow&amp;lt;U&amp;gt;&lt;/code&gt; (e.g. &lt;code&gt;String: Borrow&amp;lt;str&amp;gt;&lt;/code&gt; ), you can use &lt;code&gt;iter().any&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="05624f4cd79d0d50c7459fc7a7809ab013e516d2" translate="yes" xml:space="preserve">
          <source>If you do not want this &quot;at least&quot; behavior, see the &lt;a href=&quot;struct.string#method.reserve_exact&quot;&gt;&lt;code&gt;reserve_exact&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">この「少なくとも」動作が必要ない場合は、&lt;a href=&quot;struct.string#method.reserve_exact&quot;&gt; &lt;code&gt;reserve_exact&lt;/code&gt; &lt;/a&gt;メソッドを参照してください。</target>
        </trans-unit>
        <trans-unit id="3fa75551a6e58e68f711ab2f03a9cc21a66d738a" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t call &lt;code&gt;expect&lt;/code&gt;, the program will compile, but you&amp;rsquo;ll get a warning:</source>
          <target state="translated">&lt;code&gt;expect&lt;/code&gt; を呼び出さないと、プログラムはコンパイルされますが、警告が表示されます。</target>
        </trans-unit>
        <trans-unit id="aa9b352f2a9ad676e75ebea1e09ea589739aa744" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t want to run the tests in parallel or if you want more fine-grained control over the number of threads used, you can send the &lt;code&gt;--test-threads&lt;/code&gt; flag and the number of threads you want to use to the test binary. Take a look at the following example:</source>
          <target state="translated">テストを並行して実行したくない場合、または使用するスレッドの数をより細かく制御したい場合は、 &lt;code&gt;--test-threads&lt;/code&gt; フラグと使用するスレッドの数をテストに送信できます。バイナリ。次の例を見てください。</target>
        </trans-unit>
        <trans-unit id="8dc704dcbb9c3ebe8a328db6c83f459b5ea12df0" translate="yes" xml:space="preserve">
          <source>If you don't care about signaling-ness (very likely), then there is no portability concern.</source>
          <target state="translated">シグナリング性を気にしない(可能性が高い)のであれば、移植性の心配はありません。</target>
        </trans-unit>
        <trans-unit id="03f408e5bb66764d7ffd1cc87bf60d44d2f11a95" translate="yes" xml:space="preserve">
          <source>If you don't care about signalingness (very likely), then there is no portability concern.</source>
          <target state="translated">シグナル性を気にしない(可能性が高い)のであれば、移植性の心配はありません。</target>
        </trans-unit>
        <trans-unit id="eccfed5b1fccd97fad68aa10ed7d3af7af7893a9" translate="yes" xml:space="preserve">
          <source>If you don't know the basics of Rust, you can go look to the Rust Book to get started: https://doc.rust-lang.org/book/</source>
          <target state="translated">Rust の基本を知らない場合は、Rust Book を参照してください:https://doc.rust-lang.org/book/。</target>
        </trans-unit>
        <trans-unit id="e26edf9b7f412dd5926032771fa72456da3e35ef" translate="yes" xml:space="preserve">
          <source>If you don't know the basics of Rust, you can look at the &lt;a href=&quot;index&quot;&gt;Rust Book&lt;/a&gt; to get started.</source>
          <target state="translated">If you don't know the basics of Rust, you can look at the &lt;a href=&quot;index&quot;&gt;Rust Book&lt;/a&gt; to get started.</target>
        </trans-unit>
        <trans-unit id="bf6d5abeee91a58bb08b86aab21ccdd70a1f28d4" translate="yes" xml:space="preserve">
          <source>If you don't qualify the names, the code will bind new variables named &quot;GET&quot; and &quot;POST&quot; instead. This behavior is likely not what you want, so &lt;code&gt;rustc&lt;/code&gt; warns when that happens.</source>
          <target state="translated">名前を修飾しない場合、コードは代わりに「GET」および「POST」という名前の新しい変数をバインドします。この動作はおそらく望んでいるものではないので、それが発生すると &lt;code&gt;rustc&lt;/code&gt; が警告します。</target>
        </trans-unit>
        <trans-unit id="30e1c43099f6397f247562dd2f5b6571eda814ad" translate="yes" xml:space="preserve">
          <source>If you encounter this error you must alter your patterns so that every possible value of the input type is matched. For types with a small number of variants (like enums) you should probably cover all cases explicitly. Alternatively, the underscore &lt;code&gt;_&lt;/code&gt; wildcard pattern can be added after all other patterns to match &quot;anything else&quot;. Example:</source>
          <target state="translated">このエラーが発生した場合は、入力タイプのすべての可能な値が一致するようにパターンを変更する必要があります。列挙型などのバリアントの数が少ない型の場合は、すべてのケースを明示的にカバーする必要があります。または、アンダースコア &lt;code&gt;_&lt;/code&gt; ワイルドカードパターンを他のすべてのパターンの後に追加して、「その他」に一致させることができます。例：</target>
        </trans-unit>
        <trans-unit id="c99fe79ebb0d8c77c7785b8167d26f6b602a1b29" translate="yes" xml:space="preserve">
          <source>If you encounter this error you probably need to use a &lt;code&gt;match&lt;/code&gt; or &lt;code&gt;if let&lt;/code&gt; to deal with the possibility of failure. Example:</source>
          <target state="translated">このエラーが発生した場合、あなたはおそらく使用する必要が &lt;code&gt;match&lt;/code&gt; または &lt;code&gt;if let&lt;/code&gt; 故障の可能性に対処します。例：</target>
        </trans-unit>
        <trans-unit id="289fc8ad6bfff7525b7f4a843265b14e717b2af6" translate="yes" xml:space="preserve">
          <source>If you have a C or C++ background, you&amp;rsquo;ll notice that this is similar to &lt;code&gt;gcc&lt;/code&gt; or &lt;code&gt;clang&lt;/code&gt;. After compiling successfully, Rust outputs a binary executable.</source>
          <target state="translated">CまたはC ++のバックグラウンドがある場合、これは &lt;code&gt;gcc&lt;/code&gt; または &lt;code&gt;clang&lt;/code&gt; に似ていることに気付くでしょう。正常にコンパイルされた後、Rustはバイナリ実行可能ファイルを出力します。</target>
        </trans-unit>
        <trans-unit id="49d7cea9bb89d7aa1e9d9d998c1c8d8fd8ff2825" translate="yes" xml:space="preserve">
          <source>If you have a list of &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt;s, you can use &lt;code&gt;collect()&lt;/code&gt; to see if any of them failed:</source>
          <target state="translated">&lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; &lt;/a&gt;のリストがある場合、 &lt;code&gt;collect()&lt;/code&gt; を使用して、それらのいずれかが失敗したかどうかを確認できます。</target>
        </trans-unit>
        <trans-unit id="dbb6609dcc94bde15a6614f094acb0b0abfc28f2" translate="yes" xml:space="preserve">
          <source>If you have a reference &lt;code&gt;&amp;amp;SomeStruct&lt;/code&gt;, then normally in Rust all fields of &lt;code&gt;SomeStruct&lt;/code&gt; are immutable. The compiler makes optimizations based on the knowledge that &lt;code&gt;&amp;amp;T&lt;/code&gt; is not mutably aliased or mutated, and that &lt;code&gt;&amp;amp;mut T&lt;/code&gt; is unique. &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; is the only core language feature to work around the restriction that &lt;code&gt;&amp;amp;T&lt;/code&gt; may not be mutated. All other types that allow internal mutability, such as &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, use &lt;code&gt;UnsafeCell&lt;/code&gt; to wrap their internal data. There is &lt;em&gt;no&lt;/em&gt; legal way to obtain aliasing &lt;code&gt;&amp;amp;mut&lt;/code&gt;, not even with &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">If you have a reference &lt;code&gt;&amp;amp;SomeStruct&lt;/code&gt; , then normally in Rust all fields of &lt;code&gt;SomeStruct&lt;/code&gt; are immutable. The compiler makes optimizations based on the knowledge that &lt;code&gt;&amp;amp;T&lt;/code&gt; is not mutably aliased or mutated, and that &lt;code&gt;&amp;amp;mut T&lt;/code&gt; is unique. &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; is the only core language feature to work around the restriction that &lt;code&gt;&amp;amp;T&lt;/code&gt; may not be mutated. All other types that allow internal mutability, such as &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; , use &lt;code&gt;UnsafeCell&lt;/code&gt; to wrap their internal data. There is &lt;em&gt;no&lt;/em&gt; legal way to obtain aliasing &lt;code&gt;&amp;amp;mut&lt;/code&gt; , not even with &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="603c68300fca461a298a423a92a14317f38dd713" translate="yes" xml:space="preserve">
          <source>If you have a reference &lt;code&gt;&amp;amp;SomeStruct&lt;/code&gt;, then normally in Rust all fields of &lt;code&gt;SomeStruct&lt;/code&gt; are immutable. The compiler makes optimizations based on the knowledge that &lt;code&gt;&amp;amp;T&lt;/code&gt; is not mutably aliased or mutated, and that &lt;code&gt;&amp;amp;mut T&lt;/code&gt; is unique. &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; is the only core language feature to work around this restriction. All other types that allow internal mutability, such as &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, use &lt;code&gt;UnsafeCell&lt;/code&gt; to wrap their internal data.</source>
          <target state="translated">&lt;code&gt;&amp;amp;SomeStruct&lt;/code&gt; への参照がある場合、Rustでは通常、 &lt;code&gt;SomeStruct&lt;/code&gt; のすべてのフィールドが不変です。コンパイラーは、 &lt;code&gt;&amp;amp;T&lt;/code&gt; が別名でエイリアスまたは変更されておらず、 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; が一意であるという知識に基づいて最適化を行います。 &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; は、この制限を回避する唯一のコア言語機能です。 &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; や &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; など、内部の &lt;code&gt;UnsafeCell&lt;/code&gt; を許可する他のすべての型は、UnsafeCellを使用して内部データをラップします。</target>
        </trans-unit>
        <trans-unit id="edf1169c29b5f18e94ef5bfa0ce80d44e6e0e706" translate="yes" xml:space="preserve">
          <source>If you have a situation in which your program has logic that is too verbose to express using a &lt;code&gt;match&lt;/code&gt;, remember that &lt;code&gt;if let&lt;/code&gt; is in your Rust toolbox as well.</source>
          <target state="translated">プログラムに、 &lt;code&gt;match&lt;/code&gt; を使用して表現するには冗長すぎるロジックがある状況がある &lt;code&gt;if let&lt;/code&gt; は、letがRustツールボックスにも含まれていることを覚えておいてください。</target>
        </trans-unit>
        <trans-unit id="4d514f69487626541e99f2f08d0b5ef4bda3e112" translate="yes" xml:space="preserve">
          <source>If you have a vector of UTF-8 bytes, you can create a &lt;code&gt;String&lt;/code&gt; from it with the &lt;a href=&quot;#method.from_utf8&quot;&gt;&lt;code&gt;from_utf8&lt;/code&gt;&lt;/a&gt; method:</source>
          <target state="translated">UTF-8バイトのベクターがある場合は、&lt;a href=&quot;#method.from_utf8&quot;&gt; &lt;code&gt;from_utf8&lt;/code&gt; &lt;/a&gt;メソッドを使用してそのベクターから &lt;code&gt;String&lt;/code&gt; を作成できます。</target>
        </trans-unit>
        <trans-unit id="628f5229655ec7d34ffefb0c482b9ec478191d5b" translate="yes" xml:space="preserve">
          <source>If you have a vector of UTF-8 bytes, you can create a &lt;code&gt;String&lt;/code&gt; from it with the &lt;a href=&quot;struct.string#method.from_utf8&quot;&gt;&lt;code&gt;from_utf8&lt;/code&gt;&lt;/a&gt; method:</source>
          <target state="translated">If you have a vector of UTF-8 bytes, you can create a &lt;code&gt;String&lt;/code&gt; from it with the &lt;a href=&quot;struct.string#method.from_utf8&quot;&gt; &lt;code&gt;from_utf8&lt;/code&gt; &lt;/a&gt; method:</target>
        </trans-unit>
        <trans-unit id="594422b6f37e612f2fe4809f8c9021e17bddb83c" translate="yes" xml:space="preserve">
          <source>If you have a vector of valid UTF-8 bytes, you can make a &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; out of it. You can do the reverse too.</source>
          <target state="translated">有効なUTF-8バイトのベクトルがある場合、それから&lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;を作成できます。あなたも逆を行うことができます。</target>
        </trans-unit>
        <trans-unit id="09514694f23f12c4005f6c9a94a1355114b933e9" translate="yes" xml:space="preserve">
          <source>If you have ownership of the &lt;code&gt;MaybeUninit&lt;/code&gt;, you can use &lt;a href=&quot;union.maybeuninit#method.assume_init&quot;&gt;&lt;code&gt;assume_init&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">If you have ownership of the &lt;code&gt;MaybeUninit&lt;/code&gt; , you can use &lt;a href=&quot;union.maybeuninit#method.assume_init&quot;&gt; &lt;code&gt;assume_init&lt;/code&gt; &lt;/a&gt; instead.</target>
        </trans-unit>
        <trans-unit id="f6ce7a19cbb44d746f329213322cf181c479880e" translate="yes" xml:space="preserve">
          <source>If you have ownership of the container, you can use &lt;a href=&quot;#method.into_inner&quot;&gt;&lt;code&gt;ManuallyDrop::into_inner&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">コンテナの所有権がある場合は、代わりに&lt;a href=&quot;#method.into_inner&quot;&gt; &lt;code&gt;ManuallyDrop::into_inner&lt;/code&gt; &lt;/a&gt;使用できます。</target>
        </trans-unit>
        <trans-unit id="25db03dcaf36d059be68f895db3dece722d76812" translate="yes" xml:space="preserve">
          <source>If you have ownership of the value, you can use &lt;a href=&quot;#method.into_inner&quot;&gt;&lt;code&gt;ManuallyDrop::into_inner&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">値の所有権がある場合は、代わりに&lt;a href=&quot;#method.into_inner&quot;&gt; &lt;code&gt;ManuallyDrop::into_inner&lt;/code&gt; &lt;/a&gt;使用できます。</target>
        </trans-unit>
        <trans-unit id="b2ef31901106431a912012e61b6ed669627013f2" translate="yes" xml:space="preserve">
          <source>If you have ownership of the value, you can use &lt;a href=&quot;struct.manuallydrop#method.into_inner&quot;&gt;&lt;code&gt;ManuallyDrop::into_inner&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">If you have ownership of the value, you can use &lt;a href=&quot;struct.manuallydrop#method.into_inner&quot;&gt; &lt;code&gt;ManuallyDrop::into_inner&lt;/code&gt; &lt;/a&gt; instead.</target>
        </trans-unit>
        <trans-unit id="cbcd3198f789fbc8cbdd096a8ff06c5c6dfc54d9" translate="yes" xml:space="preserve">
          <source>If you have something that implements &lt;a href=&quot;trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt;, you can use the &lt;a href=&quot;struct.bufreader&quot;&gt;&lt;code&gt;BufReader&lt;/code&gt; type&lt;/a&gt; to turn it into a &lt;code&gt;BufRead&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt;を実装するものがある場合は、&lt;a href=&quot;struct.bufreader&quot;&gt; &lt;code&gt;BufReader&lt;/code&gt; 型&lt;/a&gt;を使用してそれを &lt;code&gt;BufRead&lt;/code&gt; に変換できます。</target>
        </trans-unit>
        <trans-unit id="26025a7b33e21d0ed3af5941205257def877195b" translate="yes" xml:space="preserve">
          <source>If you immediately run &lt;code&gt;cargo build&lt;/code&gt; again without making any changes, you won&amp;rsquo;t get any output aside from the &lt;code&gt;Finished&lt;/code&gt; line. Cargo knows it has already downloaded and compiled the dependencies, and you haven&amp;rsquo;t changed anything about them in your &lt;em&gt;Cargo.toml&lt;/em&gt; file. Cargo also knows that you haven&amp;rsquo;t changed anything about your code, so it doesn&amp;rsquo;t recompile that either. With nothing to do, it simply exits.</source>
          <target state="translated">変更を加えずにすぐに &lt;code&gt;cargo build&lt;/code&gt; 再度実行すると、 &lt;code&gt;Finished&lt;/code&gt; 行以外の出力は得られません。Cargoは、依存関係が既にダウンロードおよびコンパイルされていることを認識しており、&lt;em&gt;Cargo.toml&lt;/em&gt;ファイルでそれらについて何も変更していません。Cargoは、コードについて何も変更していないことも認識しているため、再コンパイルもしません。何もすることなく、単に終了します。</target>
        </trans-unit>
        <trans-unit id="aead6d9073f2963585c85964dbd5fd9f72b085e1" translate="yes" xml:space="preserve">
          <source>If you need a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; instead of a &lt;code&gt;String&lt;/code&gt;, consider &lt;a href=&quot;../str/fn.from_utf8&quot;&gt;&lt;code&gt;str::from_utf8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; ではなく&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt;が必要な場合は、&lt;a href=&quot;../str/fn.from_utf8&quot;&gt; &lt;code&gt;str::from_utf8&lt;/code&gt; &lt;/a&gt;検討してください。</target>
        </trans-unit>
        <trans-unit id="fadf8ed3eb8dc56d2e21bd202aa9d97fad2da2e5" translate="yes" xml:space="preserve">
          <source>If you need a &lt;code&gt;&amp;amp;[&lt;/code&gt;&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;]&lt;/code&gt; slice &lt;em&gt;with&lt;/em&gt; the nul terminator, you can use &lt;a href=&quot;#method.as_bytes_with_nul&quot;&gt;&lt;code&gt;as_bytes_with_nul&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">あなたが必要な場合 &lt;code&gt;&amp;amp;[&lt;/code&gt; &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; &lt;code&gt;]&lt;/code&gt; スライス&lt;em&gt;で&lt;/em&gt; NULターミネータは、使用することができます&lt;a href=&quot;#method.as_bytes_with_nul&quot;&gt; &lt;code&gt;as_bytes_with_nul&lt;/code&gt; &lt;/a&gt;代わりに。</target>
        </trans-unit>
        <trans-unit id="8859e0e13ac4a2988b7250ce45ef124efe28cd7a" translate="yes" xml:space="preserve">
          <source>If you need a &lt;code&gt;&amp;amp;[&lt;/code&gt;&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;]&lt;/code&gt; slice &lt;em&gt;with&lt;/em&gt; the nul terminator, you can use &lt;a href=&quot;struct.cstring#method.as_bytes_with_nul&quot;&gt;&lt;code&gt;CString::as_bytes_with_nul&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">If you need a &lt;code&gt;&amp;amp;[&lt;/code&gt; &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; &lt;code&gt;]&lt;/code&gt; slice &lt;em&gt;with&lt;/em&gt; the nul terminator, you can use &lt;a href=&quot;struct.cstring#method.as_bytes_with_nul&quot;&gt; &lt;code&gt;CString::as_bytes_with_nul&lt;/code&gt; &lt;/a&gt; instead.</target>
        </trans-unit>
        <trans-unit id="7efefa0d5ccda958764237a619135366f98b28d8" translate="yes" xml:space="preserve">
          <source>If you need a &lt;code&gt;String&lt;/code&gt; instead of a &lt;code&gt;&amp;amp;str&lt;/code&gt;, consider &lt;a href=&quot;../string/struct.string#method.from_utf8&quot;&gt;&lt;code&gt;String::from_utf8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;amp;str&lt;/code&gt; ではなく &lt;code&gt;String&lt;/code&gt; が必要な場合は、&lt;a href=&quot;../string/struct.string#method.from_utf8&quot;&gt; &lt;code&gt;String::from_utf8&lt;/code&gt; &lt;/a&gt;検討してください。</target>
        </trans-unit>
        <trans-unit id="45013794627f8d7d5a958593854bff018239ef49" translate="yes" xml:space="preserve">
          <source>If you need a reference to the &lt;code&gt;OccupiedEntry&lt;/code&gt; that may outlive the destruction of the &lt;code&gt;Entry&lt;/code&gt; value, see &lt;a href=&quot;#method.into_mut&quot;&gt;&lt;code&gt;into_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Entry&lt;/code&gt; 値の破棄よりも&lt;a href=&quot;#method.into_mut&quot;&gt; &lt;code&gt;into_mut&lt;/code&gt; &lt;/a&gt; &lt;code&gt;OccupiedEntry&lt;/code&gt; への参照が必要な場合は、into_mutを参照してください。</target>
        </trans-unit>
        <trans-unit id="219941c8b5f5991f98f925058a19ec303a64916f" translate="yes" xml:space="preserve">
          <source>If you need a reference to the &lt;code&gt;OccupiedEntry&lt;/code&gt; that may outlive the destruction of the &lt;code&gt;Entry&lt;/code&gt; value, see &lt;a href=&quot;struct.occupiedentry#method.into_mut&quot;&gt;&lt;code&gt;into_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If you need a reference to the &lt;code&gt;OccupiedEntry&lt;/code&gt; that may outlive the destruction of the &lt;code&gt;Entry&lt;/code&gt; value, see &lt;a href=&quot;struct.occupiedentry#method.into_mut&quot;&gt; &lt;code&gt;into_mut&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="76f640be80a9e8c1bdad2ee8c022f44a0a1aaaf8" translate="yes" xml:space="preserve">
          <source>If you need a reference to the &lt;code&gt;OccupiedEntry&lt;/code&gt; which may outlive the destruction of the &lt;code&gt;Entry&lt;/code&gt; value, see &lt;a href=&quot;#method.into_mut&quot;&gt;&lt;code&gt;into_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Entry&lt;/code&gt; 値の破棄よりも&lt;a href=&quot;#method.into_mut&quot;&gt; &lt;code&gt;into_mut&lt;/code&gt; &lt;/a&gt;な &lt;code&gt;OccupiedEntry&lt;/code&gt; への参照が必要な場合は、into_mutを参照してください。</target>
        </trans-unit>
        <trans-unit id="0102aa221685138b4538e7bcf99473f525d3ae0b" translate="yes" xml:space="preserve">
          <source>If you need a reference to the &lt;code&gt;OccupiedEntry&lt;/code&gt; which may outlive the destruction of the &lt;code&gt;Entry&lt;/code&gt; value, see &lt;a href=&quot;struct.occupiedentry#method.into_mut&quot;&gt;&lt;code&gt;into_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If you need a reference to the &lt;code&gt;OccupiedEntry&lt;/code&gt; which may outlive the destruction of the &lt;code&gt;Entry&lt;/code&gt; value, see &lt;a href=&quot;struct.occupiedentry#method.into_mut&quot;&gt; &lt;code&gt;into_mut&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="a60e3312521d167a8398684f23a8bda2cd769f2d" translate="yes" xml:space="preserve">
          <source>If you need more control over how a value is hashed, you can of course implement the &lt;code&gt;Hash&lt;/code&gt; trait yourself:</source>
          <target state="translated">値のハッシュ方法をさらに制御する必要がある場合は、もちろん自分で &lt;code&gt;Hash&lt;/code&gt; トレイトを実装できます。</target>
        </trans-unit>
        <trans-unit id="efc0a9fb0d5d442c54eae5e0575801419c0ddc5b" translate="yes" xml:space="preserve">
          <source>If you need more control over how a value is hashed, you need to implement the &lt;a href=&quot;trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; trait:</source>
          <target state="translated">値のハッシュ方法をさらに制御する必要がある場合は、&lt;a href=&quot;trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt;トレイトを実装する必要があります。</target>
        </trans-unit>
        <trans-unit id="0241681a3d3ab7483e993964ada28ea51777d3f5" translate="yes" xml:space="preserve">
          <source>If you need multiple references to the &lt;code&gt;OccupiedEntry&lt;/code&gt;, see &lt;a href=&quot;#method.get_mut&quot;&gt;&lt;code&gt;get_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;OccupiedEntry&lt;/code&gt; への複数の参照が必要な場合は、&lt;a href=&quot;#method.get_mut&quot;&gt; &lt;code&gt;get_mut&lt;/code&gt; を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="c038d740f3ac229d9b9c028c5b74e72acefec36c" translate="yes" xml:space="preserve">
          <source>If you need multiple references to the &lt;code&gt;OccupiedEntry&lt;/code&gt;, see &lt;a href=&quot;struct.occupiedentry#method.get_mut&quot;&gt;&lt;code&gt;get_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If you need multiple references to the &lt;code&gt;OccupiedEntry&lt;/code&gt; , see &lt;a href=&quot;struct.occupiedentry#method.get_mut&quot;&gt; &lt;code&gt;get_mut&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="40ade792259bb48c52c18a2f2d1b3c073ea1c7a1" translate="yes" xml:space="preserve">
          <source>If you need the feature, make sure to use a nightly release of the compiler (but be warned that the feature may be removed or altered in the future).</source>
          <target state="translated">この機能が必要な場合は、必ず毎晩リリースされるコンパイラを使うようにしてください(ただし、将来的にこの機能が削除されたり変更されたりする可能性があるので注意してください)。</target>
        </trans-unit>
        <trans-unit id="8d959103a15d2de9826ef517fc6c5926c4dc9c0f" translate="yes" xml:space="preserve">
          <source>If you need this, there's a good chance you're doing something wrong. Keep in mind that Rust doesn't guarantee much about the layout of different structs (even two structs with identical declarations may have different layouts). If there is a solution that avoids the transmute entirely, try it instead.</source>
          <target state="translated">これが必要な場合は、何か間違ったことをしている可能性が高いです。Rust は、異なる構造体のレイアウトについてはあまり保証していないことを覚えておいてください (同じ宣言を持つ 2 つの構造体であっても、異なるレイアウトを持つ可能性があります)。もし transmute を完全に回避する方法があるならば、それを試してみてください。</target>
        </trans-unit>
        <trans-unit id="18db342a00e23c3779573ca28794a36c6f8d6e91" translate="yes" xml:space="preserve">
          <source>If you need to cross object boundaries, cast the pointer to an integer and do the arithmetic there.</source>
          <target state="translated">オブジェクトの境界を越える必要がある場合は、ポインタを整数にキャストしてそこで演算を行います。</target>
        </trans-unit>
        <trans-unit id="5d12ddc464aa8618d85b99bead398fd46eff9e38" translate="yes" xml:space="preserve">
          <source>If you need to obtain the length of &lt;em&gt;many&lt;/em&gt; streams and you don't care about the seek position afterwards, you can reduce the number of seek operations by simply calling &lt;code&gt;seek(SeekFrom::End(0))&lt;/code&gt; and using its return value (it is also the stream length).</source>
          <target state="translated">&lt;em&gt;多くの&lt;/em&gt;ストリームの長さを取得する必要があり、後でシーク位置を気にしない場合は、単純に &lt;code&gt;seek(SeekFrom::End(0))&lt;/code&gt; を呼び出し、その戻り値（それを使用する）によってシーク操作の数を減らすことができます。はストリームの長さでもあります）。</target>
        </trans-unit>
        <trans-unit id="35592f144aa64ae5ca74cce00e23680445e57820" translate="yes" xml:space="preserve">
          <source>If you need to perform operations on individual Unicode scalar values, the best way to do so is to use the &lt;code&gt;chars&lt;/code&gt; method. Calling &lt;code&gt;chars&lt;/code&gt; on &amp;ldquo;नमस्ते&amp;rdquo; separates out and returns six values of type &lt;code&gt;char&lt;/code&gt;, and you can iterate over the result to access each element:</source>
          <target state="translated">個々のUnicodeスカラー値に対して操作を実行する必要がある場合、そのための最善の方法は、 &lt;code&gt;chars&lt;/code&gt; メソッドを使用することです。「नमस्ते」で &lt;code&gt;chars&lt;/code&gt; を呼び出すと、 &lt;code&gt;char&lt;/code&gt; 型の6つの値が分離されて返されます。結果を繰り返し処理して、各要素にアクセスできます。</target>
        </trans-unit>
        <trans-unit id="601e2909b73af510ea23340b158c3431ac0b2075" translate="yes" xml:space="preserve">
          <source>If you only want to import the namespace, do so directly:</source>
          <target state="translated">名前空間だけをインポートしたい場合は、直接インポートしてください。</target>
        </trans-unit>
        <trans-unit id="f0344a16618dba921a326e3422d6b25ac64c22ba" translate="yes" xml:space="preserve">
          <source>If you open up the &lt;em&gt;src/main.rs&lt;/em&gt; file, make a trivial change, and then save it and build again, you&amp;rsquo;ll only see two lines of output:</source>
          <target state="translated">&lt;em&gt;src / main.rs&lt;/em&gt;ファイルを開いて、ささいな変更を加えてから、保存して再度ビルドすると、2行の出力しか表示されません。</target>
        </trans-unit>
        <trans-unit id="acc3c2bbba4fb91bf96f0af82ae7667a7148e8e6" translate="yes" xml:space="preserve">
          <source>If you prefer, feel free to download the script and inspect it before running it.</source>
          <target state="translated">ご希望であれば、スクリプトをダウンロードして、実行する前に検査してみてください。</target>
        </trans-unit>
        <trans-unit id="b0bfb1242185bbb2e23ce66c3dc2f4aa29788236" translate="yes" xml:space="preserve">
          <source>If you publish the crates in the workspace to &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt;, each crate in the workspace will need to be published separately. The &lt;code&gt;cargo publish&lt;/code&gt; command does not have an &lt;code&gt;--all&lt;/code&gt; flag or a &lt;code&gt;-p&lt;/code&gt; flag, so you must change to each crate&amp;rsquo;s directory and run &lt;code&gt;cargo publish&lt;/code&gt; on each crate in the workspace to publish the crates.</source>
          <target state="translated">ワークスペース内のクレートを&lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt;に公開する場合、ワークスペース内の各クレートを個別に公開する必要があります。 &lt;code&gt;cargo publish&lt;/code&gt; コマンドはありません &lt;code&gt;--all&lt;/code&gt; フラグまたは &lt;code&gt;-p&lt;/code&gt; あなたは、各クレートのディレクトリと実行に変更しなければならないので、フラグを &lt;code&gt;cargo publish&lt;/code&gt; 箱を公開するために、ワークスペース内の各クレートに。</target>
        </trans-unit>
        <trans-unit id="f1a5e7e0b8234558c676e94b23a0846e7e9f1bdc" translate="yes" xml:space="preserve">
          <source>If you really want global mutable state, try using &lt;code&gt;static mut&lt;/code&gt; or a global &lt;code&gt;UnsafeCell&lt;/code&gt;.</source>
          <target state="translated">本当にグローバルな変更可能な状態が必要な場合は、 &lt;code&gt;static mut&lt;/code&gt; またはグローバルな &lt;code&gt;UnsafeCell&lt;/code&gt; を使用してみてください。</target>
        </trans-unit>
        <trans-unit id="62a69dfd70472a3083a61e19bd21f1bf21495b51" translate="yes" xml:space="preserve">
          <source>If you run this code and only see output from the main thread, or don&amp;rsquo;t see any overlap, try increasing the numbers in the ranges to create more opportunities for the operating system to switch between the threads.</source>
          <target state="translated">このコードを実行してメインスレッドからの出力のみが表示される場合、またはオーバーラップが表示されない場合は、範囲内の数値を増やして、オペレーティングシステムがスレッドを切り替える機会を増やしてください。</target>
        </trans-unit>
        <trans-unit id="9b13bcfddcd9ed188e7606569deda5313f2555de" translate="yes" xml:space="preserve">
          <source>If you see a version number, you have it! If you see an error, such as &lt;code&gt;command not found&lt;/code&gt;, look at the documentation for your method of installation to determine how to install Cargo separately.</source>
          <target state="translated">バージョン番号が表示されている場合は、それを持っています！ &lt;code&gt;command not found&lt;/code&gt; などのエラーが発生した場合は、インストール方法のドキュメントを参照して、Cargoを個別にインストールする方法を確認してください。</target>
        </trans-unit>
        <trans-unit id="ca1a3838ab344cfca748fd158d2f145d4ad1816e" translate="yes" xml:space="preserve">
          <source>If you see this information, you have installed Rust successfully! If you don&amp;rsquo;t see this information and you&amp;rsquo;re on Windows, check that Rust is in your &lt;code&gt;%PATH%&lt;/code&gt; system variable. If that&amp;rsquo;s all correct and Rust still isn&amp;rsquo;t working, there are a number of places you can get help. The easiest is the #beginners channel on &lt;a href=&quot;https://discord.gg/rust-lang&quot;&gt;the official Rust Discord&lt;/a&gt;. There, you can chat with other Rustaceans (a silly nickname we call ourselves) who can help you out. Other great resources include &lt;a href=&quot;https://users.rust-lang.org/&quot;&gt;the Users forum&lt;/a&gt; and &lt;a href=&quot;http://stackoverflow.com/questions/tagged/rust&quot;&gt;Stack Overflow&lt;/a&gt;.</source>
          <target state="translated">この情報が表示されれば、Rustは正常にインストールされています。この情報が表示されず、Windowsを使用している場合は、Rustが &lt;code&gt;%PATH%&lt;/code&gt; システム変数にあることを確認してください。それでも問題がなく、Rustがまだ機能しない場合は、サポートを受けることができる場所がいくつかあります。最も簡単なのは、&lt;a href=&quot;https://discord.gg/rust-lang&quot;&gt;公式のRust Discordの&lt;/a&gt; #beginnersチャンネルです。そこでは、あなたを助けることができる他のRustaceans（私たち自身と呼ぶばかげたニックネーム）とチャットすることができます。その他の優れたリソースには&lt;a href=&quot;https://users.rust-lang.org/&quot;&gt;、ユーザーフォーラム&lt;/a&gt;や&lt;a href=&quot;http://stackoverflow.com/questions/tagged/rust&quot;&gt;スタックオーバーフローがあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="af95d793530f81bcda528d6176e0d39ead994b28" translate="yes" xml:space="preserve">
          <source>If you see this information, you have installed Rust successfully! If you don&amp;rsquo;t see this information and you&amp;rsquo;re on Windows, check that Rust is in your &lt;code&gt;%PATH%&lt;/code&gt; system variable. If that&amp;rsquo;s all correct and Rust still isn&amp;rsquo;t working, there are a number of places you can get help. The easiest is the #beginners channel on &lt;a href=&quot;https://discord.gg/rust-lang&quot;&gt;the official Rust Discord&lt;/a&gt;. There, you can chat with other Rustaceans (a silly nickname we call ourselves) who can help you out. Other great resources include &lt;a href=&quot;https://users.rust-lang.org/&quot;&gt;the Users forum&lt;/a&gt; and &lt;a href=&quot;https://stackoverflow.com/questions/tagged/rust&quot;&gt;Stack Overflow&lt;/a&gt;.</source>
          <target state="translated">If you see this information, you have installed Rust successfully! If you don&amp;rsquo;t see this information and you&amp;rsquo;re on Windows, check that Rust is in your &lt;code&gt;%PATH%&lt;/code&gt; system variable. If that&amp;rsquo;s all correct and Rust still isn&amp;rsquo;t working, there are a number of places you can get help. The easiest is the #beginners channel on &lt;a href=&quot;https://discord.gg/rust-lang&quot;&gt;the official Rust Discord&lt;/a&gt;. There, you can chat with other Rustaceans (a silly nickname we call ourselves) who can help you out. Other great resources include &lt;a href=&quot;https://users.rust-lang.org/&quot;&gt;the Users forum&lt;/a&gt; and &lt;a href=&quot;https://stackoverflow.com/questions/tagged/rust&quot;&gt;Stack Overflow&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="a0b39f9cc59d35c45bd9b2beb8d8d98394272d63" translate="yes" xml:space="preserve">
          <source>If you started a project that doesn&amp;rsquo;t use Cargo, as we did with the &amp;ldquo;Hello, world!&amp;rdquo; project, you can convert it to a project that does use Cargo. Move the project code into the &lt;em&gt;src&lt;/em&gt; directory and create an appropriate &lt;em&gt;Cargo.toml&lt;/em&gt; file.</source>
          <target state="translated">If you started a project that doesn&amp;rsquo;t use Cargo, as we did with the &amp;ldquo;Hello, world!&amp;rdquo; project, you can convert it to a project that does use Cargo. Move the project code into the &lt;em&gt;src&lt;/em&gt; directory and create an appropriate &lt;em&gt;Cargo.toml&lt;/em&gt; file.</target>
        </trans-unit>
        <trans-unit id="6d31b977744193df180d9786073117d4f248efa6" translate="yes" xml:space="preserve">
          <source>If you started a project that doesn&amp;rsquo;t use Cargo, as we did with the Hello, world! project, you can convert it to a project that does use Cargo. Move the project code into the &lt;em&gt;src&lt;/em&gt; directory and create an appropriate &lt;em&gt;Cargo.toml&lt;/em&gt; file.</source>
          <target state="translated">Hello、world！で行ったように、Cargoを使用しないプロジェクトを開始した場合。プロジェクトでは、Cargoを使用するプロジェクトに変換できます。プロジェクトコードを&lt;em&gt;src&lt;/em&gt;ディレクトリに移動し、適切な&lt;em&gt;Cargo.toml&lt;/em&gt;ファイルを作成します。</target>
        </trans-unit>
        <trans-unit id="eb46c5a7ea5d3810ebecfc87299120cce00be773" translate="yes" xml:space="preserve">
          <source>If you still want to implement &lt;code&gt;Default&lt;/code&gt; on your enum, you'll have to do it &quot;by hand&quot;:</source>
          <target state="translated">If you still want to implement &lt;code&gt;Default&lt;/code&gt; on your enum, you'll have to do it &quot;by hand&quot;:</target>
        </trans-unit>
        <trans-unit id="f5c951c0594854e5d5c8e44057a2f94e7bdb34b3" translate="yes" xml:space="preserve">
          <source>If you tried to compile this code, you&amp;rsquo;d get the following error:</source>
          <target state="translated">このコードをコンパイルしようとすると、次のエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="5cf70a0009bb0e1db5e453e3370fec24dd9aef5e" translate="yes" xml:space="preserve">
          <source>If you tried to use a module from an external crate and are using Rust 2015, you may have missed the &lt;code&gt;extern crate&lt;/code&gt; declaration (which is usually placed in the crate root):</source>
          <target state="translated">If you tried to use a module from an external crate and are using Rust 2015, you may have missed the &lt;code&gt;extern crate&lt;/code&gt; declaration (which is usually placed in the crate root):</target>
        </trans-unit>
        <trans-unit id="8f1e8e43bae6ab3a4aca1d32515bf332a0c95245" translate="yes" xml:space="preserve">
          <source>If you try to implement &lt;code&gt;Copy&lt;/code&gt; on a struct or enum containing non-&lt;code&gt;Copy&lt;/code&gt; data, you will get the error &lt;a href=&quot;../../error-index#E0204&quot;&gt;E0204&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Copy&lt;/code&gt; データを含む構造体または列挙型に &lt;code&gt;Copy&lt;/code&gt; を実装しようとすると、エラー&lt;a href=&quot;../../error-index#E0204&quot;&gt;E0204&lt;/a&gt;が発生します。</target>
        </trans-unit>
        <trans-unit id="9a662d7b675ef788169c5956b5c9a92931774165" translate="yes" xml:space="preserve">
          <source>If you uncomment the last &lt;code&gt;println!&lt;/code&gt; and run the program, Rust will try to print this cycle with &lt;code&gt;a&lt;/code&gt; pointing to &lt;code&gt;b&lt;/code&gt; pointing to &lt;code&gt;a&lt;/code&gt; and so forth until it overflows the stack.</source>
          <target state="translated">最後の &lt;code&gt;println!&lt;/code&gt; コメントを外した場合！そして、プログラムを実行し、錆がでこのサイクルを印刷しようとするポインティング &lt;code&gt;b&lt;/code&gt; を指し、それがスタックをオーバーフローするまで、などと。 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a14a926ed132d09c491a177cd2b2d9e55f1e2bdf" translate="yes" xml:space="preserve">
          <source>If you want different behavior from that provided by the &lt;code&gt;derive&lt;/code&gt; attribute, consult the &lt;a href=&quot;../std/index&quot;&gt;standard library documentation&lt;/a&gt; for each trait for details of how to manually implement them.</source>
          <target state="translated">&lt;code&gt;derive&lt;/code&gt; 属性によって提供される動作とは異なる動作が必要な場合は、各特性の&lt;a href=&quot;../std/index&quot;&gt;標準ライブラリのドキュメント&lt;/a&gt;を参照して、それらを手動で実装する方法の詳細を確認してください。</target>
        </trans-unit>
        <trans-unit id="da45b590331746dc88457283dc0cfa0a00ed8210" translate="yes" xml:space="preserve">
          <source>If you want others to be able to import variants from your module directly, use &lt;code&gt;pub use&lt;/code&gt;:</source>
          <target state="translated">他のユーザーがモジュールからバリアントを直接インポートできるようにするには、 &lt;code&gt;pub use&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="25e1ad087ce44bfb4ab6681d137bc6701595a370" translate="yes" xml:space="preserve">
          <source>If you want to access this field, you have two options:</source>
          <target state="translated">このフィールドにアクセスするには、2つのオプションがあります。</target>
        </trans-unit>
        <trans-unit id="e54440276aac79fc98a847cf2428e9933e1917a0" translate="yes" xml:space="preserve">
          <source>If you want to dispose of a value properly, running its destructor, see &lt;a href=&quot;fn.drop&quot;&gt;&lt;code&gt;mem::drop&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">値を適切に破棄したい場合は、そのデストラクタを実行して、&lt;a href=&quot;fn.drop&quot;&gt; &lt;code&gt;mem::drop&lt;/code&gt; &lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="9768a2ab3e4f7c290cb7e9ced37ea2ca5de6e479" translate="yes" xml:space="preserve">
          <source>If you want to force the closure to take ownership of the values it uses in the environment, you can use the &lt;code&gt;move&lt;/code&gt; keyword before the parameter list. This technique is mostly useful when passing a closure to a new thread to move the data so it&amp;rsquo;s owned by the new thread.</source>
          <target state="translated">クロージャーが環境で使用する値の所有権を取得するように強制したい場合は、パラメーターリストの前に &lt;code&gt;move&lt;/code&gt; キーワードを使用できます。この手法は、クロージャーを新しいスレッドに渡してデータを移動し、新しいスレッドが所有するようにする場合に最も役立ちます。</target>
        </trans-unit>
        <trans-unit id="80acd43e0370273ccef8254a4e57d1f60b0bc413" translate="yes" xml:space="preserve">
          <source>If you want to get command-line arguments, use &lt;code&gt;std::env::args&lt;/code&gt;. To exit with a specified exit code, use &lt;code&gt;std::process::exit&lt;/code&gt;.</source>
          <target state="translated">コマンドライン引数を取得したい場合は、 &lt;code&gt;std::env::args&lt;/code&gt; 。指定した終了コードで終了するには、 &lt;code&gt;std::process::exit&lt;/code&gt; 使用します。</target>
        </trans-unit>
        <trans-unit id="9c9a2ec635fa6b00d5880ff9292416d8dca9a7fc" translate="yes" xml:space="preserve">
          <source>If you want to insert an item to a sorted &lt;code&gt;VecDeque&lt;/code&gt;, while maintaining sort order:</source>
          <target state="translated">並べ替え順序を維持しながら、並べ替えられた &lt;code&gt;VecDeque&lt;/code&gt; にアイテムを挿入する場合：</target>
        </trans-unit>
        <trans-unit id="0acc8dd0f308905dd135a12c1b3dd9fcb9493376" translate="yes" xml:space="preserve">
          <source>If you want to insert an item to a sorted vector, while maintaining sort order:</source>
          <target state="translated">ソート順を維持したまま、ソートされたベクトルに項目を挿入したい場合。</target>
        </trans-unit>
        <trans-unit id="9b0f51a38399c4a2f70e6ceafe1a91c955b3ae7a" translate="yes" xml:space="preserve">
          <source>If you want to keep using the first &lt;code&gt;String&lt;/code&gt;, you can clone it and append to the clone instead:</source>
          <target state="translated">最初の &lt;code&gt;String&lt;/code&gt; を使い続ける場合は、それを複製して、代わりにその複製に追加できます。</target>
        </trans-unit>
        <trans-unit id="61d387167097c227de2b74d46c810a6f48988800" translate="yes" xml:space="preserve">
          <source>If you want to leak memory, see &lt;a href=&quot;../boxed/struct.box#method.leak&quot;&gt;&lt;code&gt;Box::leak&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">メモリをリークしたい場合は、&lt;a href=&quot;../boxed/struct.box#method.leak&quot;&gt; &lt;code&gt;Box::leak&lt;/code&gt; &lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="96909eb09d644dffe9876e98f5676019fe4cca01" translate="yes" xml:space="preserve">
          <source>If you want to match against a &lt;code&gt;static&lt;/code&gt;, consider using a guard instead:</source>
          <target state="translated">&lt;code&gt;static&lt;/code&gt; と照合する場合は、代わりにガードを使用することを検討してください：</target>
        </trans-unit>
        <trans-unit id="5dd2ed8224f86c5b9637dc361ab843ced67e5d10" translate="yes" xml:space="preserve">
          <source>If you want to match against a value returned by a method, you need to bind the value first:</source>
          <target state="translated">メソッドが返す値とマッチさせたい場合は、まずその値をバインドする必要があります。</target>
        </trans-unit>
        <trans-unit id="2d1a047e7f9af156ca480104309f128f398877a3" translate="yes" xml:space="preserve">
          <source>If you want to obtain a raw pointer to the memory, see &lt;a href=&quot;../boxed/struct.box#method.into_raw&quot;&gt;&lt;code&gt;Box::into_raw&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">メモリへの生のポインタを取得したい場合は、&lt;a href=&quot;../boxed/struct.box#method.into_raw&quot;&gt; &lt;code&gt;Box::into_raw&lt;/code&gt; &lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="af2b12bea50ff4e3f56fd90fac941705dc1d40f8" translate="yes" xml:space="preserve">
          <source>If you want to obtain the maximum value in one step, you can use the following:</source>
          <target state="translated">最大値を1ステップで取得したい場合は</target>
        </trans-unit>
        <trans-unit id="aa75a1d98c5a72deacc062c764e53ed6e0e651fd" translate="yes" xml:space="preserve">
          <source>If you want to obtain the minimum value in one step, you can use the following:</source>
          <target state="translated">最小値を1ステップで取得したい場合は</target>
        </trans-unit>
        <trans-unit id="cfd0b8d443659aca7120d5cc8d6a3c8166b35c1d" translate="yes" xml:space="preserve">
          <source>If you want to omit the current error and only use its sources, use &lt;code&gt;skip(1)&lt;/code&gt;.</source>
          <target state="translated">If you want to omit the current error and only use its sources, use &lt;code&gt;skip(1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="926fba741a818eca51e737d7fa3523921dbd4a71" translate="yes" xml:space="preserve">
          <source>If you want to omit the initial error and only process its sources, use &lt;code&gt;skip(1)&lt;/code&gt;.</source>
          <target state="translated">初期エラーを省略してそのソースのみを処理する場合は、 &lt;code&gt;skip(1)&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="1e4b997d351ad9a525cf19f543e85c5da006d9c7" translate="yes" xml:space="preserve">
          <source>If you want to override a particular option, but still retain the other defaults:</source>
          <target state="translated">特定のオプションを上書きしても他のデフォルトを保持したい場合。</target>
        </trans-unit>
        <trans-unit id="651cc5caec5314245c67d0f62c5870f23101d920" translate="yes" xml:space="preserve">
          <source>If you want to replace the values of two variables, see &lt;a href=&quot;fn.swap&quot;&gt;&lt;code&gt;swap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If you want to replace the values of two variables, see &lt;a href=&quot;fn.swap&quot;&gt; &lt;code&gt;swap&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="c6af86f0661e2c9a64c8c625b38f0956d4f284ae" translate="yes" xml:space="preserve">
          <source>If you want to replace with a default value, see &lt;a href=&quot;fn.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If you want to replace with a default value, see &lt;a href=&quot;fn.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="6bfdbf254f5b63f82b216ed7084a2deb7f3dca85" translate="yes" xml:space="preserve">
          <source>If you want to replace with a passed value instead of the default value, see &lt;a href=&quot;fn.replace&quot;&gt;&lt;code&gt;replace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If you want to replace with a passed value instead of the default value, see &lt;a href=&quot;fn.replace&quot;&gt; &lt;code&gt;replace&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="1373af912652b0c7e66f623e887c5b41f2472fcc" translate="yes" xml:space="preserve">
          <source>If you want to swap with a default or dummy value, see &lt;a href=&quot;fn.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If you want to swap with a default or dummy value, see &lt;a href=&quot;fn.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="efa2ff7053e1b87144c40e113ce37c56691cc7f2" translate="yes" xml:space="preserve">
          <source>If you want to swap with a passed value, returning the old value, see &lt;a href=&quot;fn.replace&quot;&gt;&lt;code&gt;replace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If you want to swap with a passed value, returning the old value, see &lt;a href=&quot;fn.replace&quot;&gt; &lt;code&gt;replace&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="18f006db9a3676ab2ada8ccb85ca3e9d0996d340" translate="yes" xml:space="preserve">
          <source>If you want to use a license that doesn&amp;rsquo;t appear in the SPDX, you need to place the text of that license in a file, include the file in your project, and then use &lt;code&gt;license-file&lt;/code&gt; to specify the name of that file instead of using the &lt;code&gt;license&lt;/code&gt; key.</source>
          <target state="translated">SPDXに表示されないライセンスを使用する場合は、そのライセンスのテキストをファイルに配置し、そのファイルをプロジェクトに含めてから、 &lt;code&gt;license-file&lt;/code&gt; を使用してそのファイルの名前を指定する必要があります &lt;code&gt;license&lt;/code&gt; キーを使用する。</target>
        </trans-unit>
        <trans-unit id="9090aa9e8ad232d87792cb945b3e00a6429cd6aa" translate="yes" xml:space="preserve">
          <source>If you want to use a method, add &lt;code&gt;()&lt;/code&gt; after it:</source>
          <target state="translated">メソッドを使用する場合は、メソッドの後に &lt;code&gt;()&lt;/code&gt; を追加します。</target>
        </trans-unit>
        <trans-unit id="51277c9215e04719281555a263f500118558534d" translate="yes" xml:space="preserve">
          <source>If you wanted to use &lt;code&gt;rand&lt;/code&gt; version &lt;code&gt;0.4.0&lt;/code&gt; or any version in the &lt;code&gt;0.4.x&lt;/code&gt; series, you&amp;rsquo;d have to update the &lt;em&gt;Cargo.toml&lt;/em&gt; file to look like this instead:</source>
          <target state="translated">&lt;code&gt;rand&lt;/code&gt; バージョン &lt;code&gt;0.4.0&lt;/code&gt; または &lt;code&gt;0.4.x&lt;/code&gt; シリーズのいずれかのバージョンを使用したい場合は、代わりに&lt;em&gt;Cargo.toml&lt;/em&gt;ファイルを次のように更新する&lt;em&gt;必要があり&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="8c50d781b9647450248f78ab145ade0f4a366fe2" translate="yes" xml:space="preserve">
          <source>If you wanted to use &lt;code&gt;rand&lt;/code&gt; version &lt;code&gt;0.6.0&lt;/code&gt; or any version in the &lt;code&gt;0.6.x&lt;/code&gt; series, you&amp;rsquo;d have to update the &lt;em&gt;Cargo.toml&lt;/em&gt; file to look like this instead:</source>
          <target state="translated">If you wanted to use &lt;code&gt;rand&lt;/code&gt; version &lt;code&gt;0.6.0&lt;/code&gt; or any version in the &lt;code&gt;0.6.x&lt;/code&gt; series, you&amp;rsquo;d have to update the &lt;em&gt;Cargo.toml&lt;/em&gt; file to look like this instead:</target>
        </trans-unit>
        <trans-unit id="1701a67103b86d7651d634397fe65d313d58f55d" translate="yes" xml:space="preserve">
          <source>If you wish to apply this attribute to all methods in an impl, manually annotate each method; it is not possible to annotate the entire impl with an &lt;code&gt;#[inline]&lt;/code&gt; attribute.</source>
          <target state="translated">この属性を実装内のすべてのメソッドに適用する場合は、各メソッドに手動で注釈を付けます。実装全体に &lt;code&gt;#[inline]&lt;/code&gt; 属性で注釈を付けることはできません。</target>
        </trans-unit>
        <trans-unit id="5d397e83dcd0f1559792d3e0a89cf887adf0bfaa" translate="yes" xml:space="preserve">
          <source>If you wish to learn more about ownership in Rust, start with the &lt;a href=&quot;book/ch04-00-understanding-ownership&quot;&gt;Understanding Ownership&lt;/a&gt; chapter in the Book.</source>
          <target state="translated">If you wish to learn more about ownership in Rust, start with the &lt;a href=&quot;book/ch04-00-understanding-ownership&quot;&gt;Understanding Ownership&lt;/a&gt; chapter in the Book.</target>
        </trans-unit>
        <trans-unit id="87899c4a4d606a4f4020452b11cba149b8345c16" translate="yes" xml:space="preserve">
          <source>If you wish to learn more about ownership in Rust, start with the chapter in the Book:</source>
          <target state="translated">Rustの所有権について詳しく知りたい場合は、この本の章から始めてください。</target>
        </trans-unit>
        <trans-unit id="3e41aae8d663fd217f0f3e9bae5f0ce51dac4bca" translate="yes" xml:space="preserve">
          <source>If you work with Windows API, you may wish to convert &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;Vec&amp;lt;u16&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">If you work with Windows API, you may wish to convert &lt;a href=&quot;../ffi/struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; &lt;/a&gt; to &lt;code&gt;Vec&amp;lt;u16&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="78eac0234db79506b991eda9c4b9c36157e1c9b6" translate="yes" xml:space="preserve">
          <source>If you would like to import all exported macros, write &lt;code&gt;macro_use&lt;/code&gt; with no arguments.</source>
          <target state="translated">エクスポートされたすべてのマクロをインポートする場合は、引数なしで &lt;code&gt;macro_use&lt;/code&gt; を記述します。</target>
        </trans-unit>
        <trans-unit id="ed1dda05d27b4d27cb9305c801cdb5137665995d" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re more familiar with a dynamic language, such as Ruby, Python, or JavaScript, you might not be used to compiling and running a program as separate steps. Rust is an &lt;em&gt;ahead-of-time compiled&lt;/em&gt; language, meaning you can compile a program and give the executable to someone else, and they can run it even without having Rust installed. If you give someone a &lt;em&gt;.rb&lt;/em&gt;, &lt;em&gt;.py&lt;/em&gt;, or &lt;em&gt;.js&lt;/em&gt; file, they need to have a Ruby, Python, or JavaScript implementation installed (respectively). But in those languages, you only need one command to compile and run your program. Everything is a trade-off in language design.</source>
          <target state="translated">Ruby、Python、JavaScriptなどの動的言語に精通している場合は、プログラムを個別のステップとしてコンパイルおよび実行することに慣れていない可能性があります。Rustは&lt;em&gt;事前にコンパイルされた&lt;/em&gt;言語です。つまり、プログラムをコンパイルして実行可能ファイルを他の人に渡すことができ、Rustがインストールされていなくても実行できます。誰かに&lt;em&gt;.rb&lt;/em&gt;、&lt;em&gt;.py&lt;/em&gt;、または&lt;em&gt;.js&lt;/em&gt;ファイルを与える場合、それらは（それぞれ）Ruby、Python、またはJavaScript実装をインストールする必要があります。しかし、これらの言語では、プログラムをコンパイルして実行するために必要なコマンドは1つだけです。すべては言語設計のトレードオフです。</target>
        </trans-unit>
        <trans-unit id="7e490007e6b65d7d7858801f6aacf713c1c91404" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re up for a challenge, try implementing these changes on your own before looking at the code in Listing 20-15.</source>
          <target state="translated">課題がある場合は、リスト20-15のコードを見る前に、これらの変更を自分で実装してみてください。</target>
        </trans-unit>
        <trans-unit id="503925e7f62154ea6178c580b761e23a80e387e3" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using Linux or macOS, open a terminal and enter the following command:</source>
          <target state="translated">LinuxまたはmacOSを使用している場合は、ターミナルを開いて次のコマンドを入力します。</target>
        </trans-unit>
        <trans-unit id="98942c95131204f993cffde6931d1582fa280610" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using PowerShell, you will need to set the environment variable and run the program in two commands rather than one:</source>
          <target state="translated">PowerShellを使用している場合は、環境変数を設定し、1つではなく2つのコマンドでプログラムを実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="10222b367fb9120d22d60ff135277a5cc297aae4" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using a beta or stable release of Rust, you can&amp;rsquo;t use any feature flags. This is the key that allows us to get practical use with new features before we declare them stable forever. Those who wish to opt into the bleeding edge can do so, and those who want a rock-solid experience can stick with stable and know that their code won&amp;rsquo;t break. Stability without stagnation.</source>
          <target state="translated">Rustのベータ版または安定版リリースを使用している場合は、機能フラグを使用できません。これは、新しい機能を永遠に安定であると宣言する前に、実際に使用できるようにするための鍵です。最先端をオプトインしたい人はそうすることができ、堅実な体験をしたい人は安定版にこだわり、コードが壊れないことを知っています。停滞のない安定性。</target>
        </trans-unit>
        <trans-unit id="da77f918478283fad1f198de108fa4f8ef398fc0" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re wanting to copy the contents of one file to another and you&amp;rsquo;re working with &lt;a href=&quot;struct.file&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt;s, see the &lt;a href=&quot;../io/fn.copy&quot;&gt;&lt;code&gt;io::copy&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">あるファイルの内容を別のファイルにコピーする必要があり、&lt;a href=&quot;struct.file&quot;&gt; &lt;code&gt;File&lt;/code&gt; を&lt;/a&gt;使用している場合は、&lt;a href=&quot;../io/fn.copy&quot;&gt; &lt;code&gt;io::copy&lt;/code&gt; &lt;/a&gt;関数を参照してください。</target>
        </trans-unit>
        <trans-unit id="2a58c6f07d04f7dc7feddd58a27cebcc6f22ddd7" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re wanting to copy the contents of one file to another and you&amp;rsquo;re working with filesystem paths, see the &lt;a href=&quot;../fs/fn.copy&quot;&gt;&lt;code&gt;fs::copy&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">あるファイルの内容を別のファイルにコピーする必要があり、ファイルシステムパスを操作している場合は、&lt;a href=&quot;../fs/fn.copy&quot;&gt; &lt;code&gt;fs::copy&lt;/code&gt; &lt;/a&gt;関数を参照してください。</target>
        </trans-unit>
        <trans-unit id="6ecddb0b505fd4dff9fe47fcf13cd242249940e4" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve heard the terms &lt;em&gt;shallow copy&lt;/em&gt; and &lt;em&gt;deep copy&lt;/em&gt; while working with other languages, the concept of copying the pointer, length, and capacity without copying the data probably sounds like making a shallow copy. But because Rust also invalidates the first variable, instead of being called a shallow copy, it&amp;rsquo;s known as a &lt;em&gt;move&lt;/em&gt;. In this example, we would say that &lt;code&gt;s1&lt;/code&gt; was &lt;em&gt;moved&lt;/em&gt; into &lt;code&gt;s2&lt;/code&gt;. So what actually happens is shown in Figure 4-4.</source>
          <target state="translated">他の言語で&lt;em&gt;浅いコピー&lt;/em&gt;と&lt;em&gt;深いコピー&lt;/em&gt;という用語を聞いた場合、データをコピーせずにポインター、長さ、および容量をコピーするという概念は、おそらく浅いコピーを作成するように聞こえます。しかし、Rustは最初の変数も無効にするため、シャローコピーと呼ばれるのではなく、&lt;em&gt;moveと&lt;/em&gt;呼ばれます。この例では、 &lt;code&gt;s1&lt;/code&gt; が &lt;code&gt;s2&lt;/code&gt; に&lt;em&gt;移動&lt;/em&gt;されたと言えます。したがって、実際に何が起こるかを図4-4に示します。</target>
        </trans-unit>
        <trans-unit id="7a247142750d6b996e14a5e30ade8f9e7fae56a4" translate="yes" xml:space="preserve">
          <source>If you'd like explicitly call the destructor of a value, &lt;a href=&quot;../mem/fn.drop&quot;&gt;&lt;code&gt;mem::drop&lt;/code&gt;&lt;/a&gt; can be used instead.</source>
          <target state="translated">If you'd like explicitly call the destructor of a value, &lt;a href=&quot;../mem/fn.drop&quot;&gt; &lt;code&gt;mem::drop&lt;/code&gt; &lt;/a&gt; can be used instead.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
