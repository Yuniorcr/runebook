<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="74ec56d1bf817c0befd406275e3cdc68acd63801" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.Unknown.field.cmsg_level&quot;&gt;&lt;code&gt;cmsg_level:&amp;nbsp;&lt;a href=&quot;../../../primitive.i32&quot;&gt;i32&lt;/a&gt;&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.Unknown.field.cmsg_level&quot;&gt;&lt;code&gt;cmsg_level:&amp;nbsp;&lt;a href=&quot;../../../primitive.i32&quot;&gt;i32&lt;/a&gt;&lt;/code&gt;&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="9f752b0935e93abaf0f9500cbb548195f26e0793" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.Unknown.field.cmsg_type&quot;&gt;&lt;code&gt;cmsg_type:&amp;nbsp;&lt;a href=&quot;../../../primitive.i32&quot;&gt;i32&lt;/a&gt;&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.Unknown.field.cmsg_type&quot;&gt;&lt;code&gt;cmsg_type:&amp;nbsp;&lt;a href=&quot;../../../primitive.i32&quot;&gt;i32&lt;/a&gt;&lt;/code&gt;&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="a8dd251a1207d4e11e3d10d61c6d014b2646ff37" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.V4&quot;&gt;&lt;code id=&quot;V4.v&quot;&gt;V4(&lt;a href=&quot;struct.ipv4addr&quot;&gt;Ipv4Addr&lt;/a&gt;)&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.V4&quot;&gt;&lt;code id=&quot;V4.v&quot;&gt;V4(&lt;a href=&quot;struct.ipv4addr&quot;&gt;Ipv4Addr&lt;/a&gt;)&lt;/code&gt;&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="900d145487fbb075cf35b7f31871559fc4e06aea" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.V4&quot;&gt;&lt;code id=&quot;V4.v&quot;&gt;V4(&lt;a href=&quot;struct.socketaddrv4&quot;&gt;SocketAddrV4&lt;/a&gt;)&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.V4&quot;&gt;&lt;code id=&quot;V4.v&quot;&gt;V4(&lt;a href=&quot;struct.socketaddrv4&quot;&gt;SocketAddrV4&lt;/a&gt;)&lt;/code&gt;&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="ccd5990162f9019755ca0861aec17eeb838635c5" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.V6&quot;&gt;&lt;code id=&quot;V6.v&quot;&gt;V6(&lt;a href=&quot;struct.ipv6addr&quot;&gt;Ipv6Addr&lt;/a&gt;)&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.V6&quot;&gt;&lt;code id=&quot;V6.v&quot;&gt;V6(&lt;a href=&quot;struct.ipv6addr&quot;&gt;Ipv6Addr&lt;/a&gt;)&lt;/code&gt;&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="df27b63255e5ca4dd10ee3931d89a214cb7a79e8" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.V6&quot;&gt;&lt;code id=&quot;V6.v&quot;&gt;V6(&lt;a href=&quot;struct.socketaddrv6&quot;&gt;SocketAddrV6&lt;/a&gt;)&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.V6&quot;&gt;&lt;code id=&quot;V6.v&quot;&gt;V6(&lt;a href=&quot;struct.socketaddrv6&quot;&gt;SocketAddrV6&lt;/a&gt;)&lt;/code&gt;&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="b1ea069ef9327f5c3a1a861557ea04c82575ae3c" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.Vacant&quot;&gt;&lt;code id=&quot;Vacant.v&quot;&gt;Vacant(&lt;a href=&quot;struct.rawvacantentrymut&quot;&gt;RawVacantEntryMut&lt;/a&gt;&amp;lt;'a, K, V, S&amp;gt;)&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.Vacant&quot;&gt; &lt;code id=&quot;Vacant.v&quot;&gt;Vacant(&lt;a href=&quot;struct.rawvacantentrymut&quot;&gt;RawVacantEntryMut&lt;/a&gt;&amp;lt;'a, K, V, S&amp;gt;)&lt;/code&gt; &lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="a3f52e8e92525a9484f9ea21a413660d15607c54" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.Vacant&quot;&gt;&lt;code id=&quot;Vacant.v&quot;&gt;Vacant(&lt;a href=&quot;struct.vacantentry&quot;&gt;VacantEntry&lt;/a&gt;&amp;lt;'a, K, V&amp;gt;)&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.Vacant&quot;&gt; &lt;code id=&quot;Vacant.v&quot;&gt;Vacant(&lt;a href=&quot;struct.vacantentry&quot;&gt;VacantEntry&lt;/a&gt;&amp;lt;'a, K, V&amp;gt;)&lt;/code&gt; &lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="cc590a03de1082f370b8b404e093e91ac5cb0306" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.Verbatim&quot;&gt;&lt;code id=&quot;Verbatim.v&quot;&gt;Verbatim(&amp;amp;'a &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;OsStr&lt;/a&gt;)&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.Verbatim&quot;&gt; &lt;code id=&quot;Verbatim.v&quot;&gt;Verbatim(&amp;amp;'a &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;OsStr&lt;/a&gt;)&lt;/code&gt; &lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="5aa296add133e61d06a6d4259d1fb0881eb7bd39" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.VerbatimDisk&quot;&gt;&lt;code id=&quot;VerbatimDisk.v&quot;&gt;VerbatimDisk(&lt;a href=&quot;../primitive.u8&quot;&gt;u8&lt;/a&gt;)&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.VerbatimDisk&quot;&gt;&lt;code id=&quot;VerbatimDisk.v&quot;&gt;VerbatimDisk(&lt;a href=&quot;../primitive.u8&quot;&gt;u8&lt;/a&gt;)&lt;/code&gt;&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="f6b929546a75faa42e8181de8ca57bcfbd173f85" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.VerbatimUNC&quot;&gt;&lt;code id=&quot;VerbatimUNC.v&quot;&gt;VerbatimUNC(&amp;amp;'a &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;OsStr&lt;/a&gt;,&amp;nbsp;&amp;amp;'a &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;OsStr&lt;/a&gt;)&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.VerbatimUNC&quot;&gt; &lt;code id=&quot;VerbatimUNC.v&quot;&gt;VerbatimUNC(&amp;amp;'a &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;OsStr&lt;/a&gt;,&amp;nbsp;&amp;amp;'a &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;OsStr&lt;/a&gt;)&lt;/code&gt; &lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="9cd9ad739de8cce934db346fc40fc958c8b3429e" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.WouldBlock&quot;&gt;&lt;code id=&quot;WouldBlock.v&quot;&gt;WouldBlock&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.WouldBlock&quot;&gt;&lt;code id=&quot;WouldBlock.v&quot;&gt;WouldBlock&lt;/code&gt;&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="31c97026aa6d07f6414185d909730c36779144a9" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.Write&quot;&gt;&lt;code id=&quot;Write.v&quot;&gt;Write&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.Write&quot;&gt;&lt;code id=&quot;Write.v&quot;&gt;Write&lt;/code&gt;&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="61e6c90d5de31882b090799d674e61ef0d0f389c" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.WriteZero&quot;&gt;&lt;code id=&quot;WriteZero.v&quot;&gt;WriteZero&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.WriteZero&quot;&gt;&lt;code id=&quot;WriteZero.v&quot;&gt;WriteZero&lt;/code&gt;&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="dc8ede49b45bb296751c2a5d3ace189c5a80e69c" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.Yielded&quot;&gt;&lt;code id=&quot;Yielded.v&quot;&gt;Yielded(Y)&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.Yielded&quot;&gt;&lt;code id=&quot;Yielded.v&quot;&gt;Yielded(Y)&lt;/code&gt;&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="6b8f56e3c79b5975e1be195dd3734989bee366c7" translate="yes" xml:space="preserve">
          <source>&lt;span id=&quot;variant.Zero&quot;&gt;&lt;code id=&quot;Zero.v&quot;&gt;Zero&lt;/code&gt;&lt;/span&gt;</source>
          <target state="translated">&lt;span id=&quot;variant.Zero&quot;&gt;&lt;code id=&quot;Zero.v&quot;&gt;Zero&lt;/code&gt;&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="8d30ecbd2f33931b54af81e7b1473f6ce8c0ba0d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/issues/10184&quot;&gt;NOTE: currently this will cause Undefined Behavior if the rounded value cannot be represented by the target integer type&lt;/a&gt;&lt;/strong&gt;. This includes Inf and NaN. This is a bug and will be fixed.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/issues/10184&quot;&gt;注：現在、丸められた値がターゲット整数型で表現できない場合、これにより未定義の動作が発生し&lt;/a&gt;&lt;/strong&gt;ます。これにはInfとNaNが含まれます。これはバグであり、修正される予定です。</target>
        </trans-unit>
        <trans-unit id="92971d62fe3186475f026398e7a0174099738633" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/issues/15536&quot;&gt;NOTE: currently this will cause Undefined Behavior if the value is finite but larger or smaller than the largest or smallest finite value representable by f32&lt;/a&gt;&lt;/strong&gt;. This is a bug and will be fixed.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/issues/15536&quot;&gt;注：現在、値が有限であるがf32で表現可能な最大または最小の有限値よりも大きいまたは小さい場合、これにより未定義の動作が発生します&lt;/a&gt;&lt;/strong&gt;。これはバグであり、修正される予定です。</target>
        </trans-unit>
        <trans-unit id="1afbb08e18a2a8950ebdff5b3534ae0f7e3fd83f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Note&lt;/em&gt;&lt;/strong&gt;: The &lt;code&gt;rustc&lt;/code&gt; compiler automatically inlines functions based on internal heuristics. Incorrectly inlining functions can make the program slower, so this attribute should be used with care.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;注&lt;/em&gt;&lt;/strong&gt;： &lt;code&gt;rustc&lt;/code&gt; コンパイラーは、内部ヒューリスティックに基づいて関数を自動的にインライン化します。関数を誤ってインライン化するとプログラムが遅くなる可能性があるため、この属性の使用には注意が必要です。</target>
        </trans-unit>
        <trans-unit id="52af196e2df7d6d1d70d4b20971e00ada5feef77" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Warning:&lt;/em&gt;&lt;/strong&gt; Dereferencing an unaligned pointer is &lt;a href=&quot;behavior-considered-undefined&quot;&gt;undefined behavior&lt;/a&gt; and it is possible to &lt;a href=&quot;https://github.com/rust-lang/rust/issues/27060&quot;&gt;safely create unaligned pointers to &lt;code&gt;packed&lt;/code&gt; fields&lt;/a&gt;. Like all ways to create undefined behavior in safe Rust, this is a bug.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;警告：&lt;/em&gt;&lt;/strong&gt;非境界整列ポインターの逆参照は&lt;a href=&quot;behavior-considered-undefined&quot;&gt;未定義の動作で&lt;/a&gt;あり&lt;a href=&quot;https://github.com/rust-lang/rust/issues/27060&quot;&gt;、 &lt;code&gt;packed&lt;/code&gt; フィールドへの非境界整列ポインターを安全に作成する&lt;/a&gt;ことが可能です。Safe Rustで未定義の動作を作成するすべての方法と同様に、これはバグです。</target>
        </trans-unit>
        <trans-unit id="641eae7d16c8e6d62bab0c62010b11532ce2de80" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Warning:&lt;/em&gt;&lt;/strong&gt; For &lt;a href=&quot;../types/trait-object&quot;&gt;trait objects&lt;/a&gt;, if there is an inherent method of the same name as a trait method, it will give a compiler error when trying to call the method in a method call expression. Instead, you can call the method using &lt;a href=&quot;call-expr#disambiguating-function-calls&quot;&gt;disambiguating function call syntax&lt;/a&gt;, in which case it calls the trait method, not the inherent method. There is no way to call the inherent method. Just don't define inherent methods on trait objects with the same name a trait method and you'll be fine.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;警告：&lt;/em&gt;&lt;/strong&gt;について&lt;a href=&quot;../types/trait-object&quot;&gt;形質がオブジェクト&lt;/a&gt;形質メソッドと同じ名前の固有の方法がある場合は、メソッド呼び出し式でメソッドを呼び出すしようとしたとき、それはコンパイラのエラーになります。代わりに、&lt;a href=&quot;call-expr#disambiguating-function-calls&quot;&gt;明確な関数呼び出し構文&lt;/a&gt;を使用してメソッドを呼び出すことができます。この場合、固有のメソッドではなく特性メソッドを呼び出します。固有のメソッドを呼び出す方法はありません。トレイトメソッドと同じ名前のトレイトオブジェクトに固有のメソッドを定義しないでください。</target>
        </trans-unit>
        <trans-unit id="14f5badea1be2736539096eaf684db8c5d26b01b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Warning:&lt;/em&gt;&lt;/strong&gt; The following list is not exhaustive. There is no formal model of Rust's semantics for what is and is not allowed in unsafe code, so there may be more behavior considered unsafe. The following list is just what we know for sure is undefined behavior. Please read the &lt;a href=&quot;https://doc.rust-lang.org/nomicon/index.html&quot;&gt;Rustonomicon&lt;/a&gt; before writing unsafe code.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;警告：&lt;/em&gt;&lt;/strong&gt;次のリストは完全ではありません。安全ではないコードで許可されているものと許可されていないものについて、Rustのセマンティクスの正式なモデルはないため、安全でないと見なされる動作が増える可能性があります。次のリストは、未定義の動作であることを確認したものです。安全でないコードを書く前に、&lt;a href=&quot;https://doc.rust-lang.org/nomicon/index.html&quot;&gt; Rustonomiconを&lt;/a&gt;読んでください。</target>
        </trans-unit>
        <trans-unit id="0029a09af0cc0f5afc1611697c9ad1ed7b7d0cfc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Warning:&lt;/em&gt;&lt;/strong&gt; With two trait object types, even when the complete set of traits is the same, if the base traits differ, the type is different. For example, &lt;code&gt;dyn Send + Sync&lt;/code&gt; is a different type from &lt;code&gt;dyn Sync + Send&lt;/code&gt;. See &lt;a href=&quot;https://github.com/rust-lang/rust/issues/33140&quot;&gt;issue 33140&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;警告：&lt;/em&gt;&lt;/strong&gt; 2つの特性オブジェクトタイプでは、特性の完全なセットが同じであっても、基本特性が異なる場合、タイプは異なります。たとえば、 &lt;code&gt;dyn Send + Sync&lt;/code&gt; は &lt;code&gt;dyn Sync + Send&lt;/code&gt; とは異なるタイプです。&lt;a href=&quot;https://github.com/rust-lang/rust/issues/33140&quot;&gt;問題33140を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="ee107fe206809602998471109ca3cf88bae2bbb4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;sup&gt;Lexer 2015&lt;/sup&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;sup&gt;レクサー2015&lt;/sup&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="086e314e305cc39ba4d4b327b89e5d7a0d8c6f03" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;sup&gt;Lexer 2018+&lt;/sup&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;sup&gt;レクサー2018+&lt;/sup&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="32563aa7feb766e8d7e65307f8bc48e47003b702" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;sup&gt;Lexer:&lt;/sup&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;sup&gt;Lexer:&lt;/sup&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a3ac7aad80402b534d708e407025f17f7772a4ae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;sup&gt;Lexer&lt;/sup&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;sup&gt;Lexer&lt;/sup&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="13ea811ecc594e94181b24eb80a75c60e5e29672" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;sup&gt;Syntax:&lt;/sup&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;sup&gt;Syntax:&lt;/sup&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4284bd4d709ac711e8c06bbdaf51939ae42316ff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;sup&gt;Syntax&lt;/sup&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;sup&gt;Syntax&lt;/sup&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="04d38a540329625df538c94f4f56761b0074d0fa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Character size&lt;/strong&gt; - C strings may use &lt;code&gt;char&lt;/code&gt; or &lt;code&gt;wchar_t&lt;/code&gt;-sized characters; please &lt;strong&gt;note&lt;/strong&gt; that C's &lt;code&gt;char&lt;/code&gt; is different from Rust's. The C standard leaves the actual sizes of those types open to interpretation, but defines different APIs for strings made up of each character type. Rust strings are always UTF-8, so different Unicode characters will be encoded in a variable number of bytes each. The Rust type &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; represents a '&lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode scalar value&lt;/a&gt;', which is similar to, but not the same as, a '&lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt;Unicode code point&lt;/a&gt;'.</source>
          <target state="translated">&lt;strong&gt;文字サイズ&lt;/strong&gt; -C文字列は &lt;code&gt;char&lt;/code&gt; または &lt;code&gt;wchar_t&lt;/code&gt; サイズの文字を使用できます。Cの &lt;code&gt;char&lt;/code&gt; はRustのcharとは異なることに&lt;strong&gt;注意し&lt;/strong&gt;てください。C標準では、これらの型の実際のサイズは解釈の自由になっていますが、各文字型で構成される文字列に対して異なるAPIを定義しています。Rust文字列は常にUTF-8であるため、さまざまなUnicode文字がそれぞれ可変バイト数でエンコードされます。Rust型の&lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;は、 ' &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicodeスカラー値&lt;/a&gt; 'を表します。これは、 ' &lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt;Unicodeコードポイント&lt;/a&gt; ' と似ていますが、同じではありません。</target>
        </trans-unit>
        <trans-unit id="0ce042add186ebd327aa00b3f56f494c53302773" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Character size&lt;/strong&gt; - C strings may use &lt;code&gt;char&lt;/code&gt; or &lt;code&gt;wchar_t&lt;/code&gt;-sized characters; please &lt;strong&gt;note&lt;/strong&gt; that C's &lt;code&gt;char&lt;/code&gt; is different from Rust's. The C standard leaves the actual sizes of those types open to interpretation, but defines different APIs for strings made up of each character type. Rust strings are always UTF-8, so different Unicode characters will be encoded in a variable number of bytes each. The Rust type &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.char.html&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; represents a '&lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode scalar value&lt;/a&gt;', which is similar to, but not the same as, a '&lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt;Unicode code point&lt;/a&gt;'.</source>
          <target state="translated">&lt;strong&gt;文字サイズ&lt;/strong&gt;-C文字列は &lt;code&gt;char&lt;/code&gt; または &lt;code&gt;wchar_t&lt;/code&gt; サイズの文字を使用できます。Cの &lt;code&gt;char&lt;/code&gt; はRustの文字とは異なることに&lt;strong&gt;注意し&lt;/strong&gt;てください。C標準では、これらのタイプの実際のサイズは自由に解釈できますが、各文字タイプで構成される文字列に対して異なるAPIを定義しています。Rust文字列は常にUTF-8であるため、異なるUnicode文字がそれぞれ可変バイト数でエンコードされます。Rust型&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.char.html&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;は、「&lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicodeスカラー値&lt;/a&gt;」を表します。これは「&lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt;Unicodeコードポイント&lt;/a&gt;」と似ていますが、同じではありません。</target>
        </trans-unit>
        <trans-unit id="c1da5390166def59a905c5a3bf23d0d789eae735" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Character size&lt;/strong&gt; - C strings may use &lt;code&gt;char&lt;/code&gt; or &lt;code&gt;wchar_t&lt;/code&gt;-sized characters; please &lt;strong&gt;note&lt;/strong&gt; that C's &lt;code&gt;char&lt;/code&gt; is different from Rust's. The C standard leaves the actual sizes of those types open to interpretation, but defines different APIs for strings made up of each character type. Rust strings are always UTF-8, so different Unicode characters will be encoded in a variable number of bytes each. The Rust type &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.char.html&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; represents a '&lt;a href=&quot;https://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode scalar value&lt;/a&gt;', which is similar to, but not the same as, a '&lt;a href=&quot;https://www.unicode.org/glossary/#code_point&quot;&gt;Unicode code point&lt;/a&gt;'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="700eaca40cee125f38cc4d75b02d62979fde8825" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Crates:&lt;/strong&gt; A tree of modules that produces a library or executable</source>
          <target state="translated">&lt;strong&gt;クレート：&lt;/strong&gt;ライブラリまたは実行可能ファイルを生成するモジュールのツリー</target>
        </trans-unit>
        <trans-unit id="e782bb6068e1aacf17c4b0b3ec1d9875e47c4925" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Disclaimer:&lt;/strong&gt; These system calls might change over time.</source>
          <target state="translated">&lt;strong&gt;免責事項：&lt;/strong&gt;これらのシステムコールは時間の経過とともに変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="6b8b3462b6d6c541b754f0aec381f7e706c421ab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edition Differences&lt;/strong&gt;: In the 2015 Edition, the crate root contains a variety of different items, including external crates, default crates such as &lt;code&gt;std&lt;/code&gt; and &lt;code&gt;core&lt;/code&gt;, and items in the top level of the crate (including &lt;code&gt;use&lt;/code&gt; imports).</source>
          <target state="translated">&lt;strong&gt;エディションの違い&lt;/strong&gt;：2015エディションでは、クレートのルートには、外部クレート、 &lt;code&gt;std&lt;/code&gt; や &lt;code&gt;core&lt;/code&gt; などのデフォルトのクレート、クレートの最上位レベルのアイテム（ &lt;code&gt;use&lt;/code&gt; インポートを含む）など、さまざまなアイテムが含まれています。</target>
        </trans-unit>
        <trans-unit id="e088bfe5ad018353c64bdbb01968dcde42ba3d14" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edition Differences&lt;/strong&gt;: In the 2015 edition, &lt;code&gt;use&lt;/code&gt; paths also allow accessing items in the crate root. Using the example above, the following &lt;code&gt;use&lt;/code&gt; paths work in 2015 but not 2018:</source>
          <target state="translated">&lt;strong&gt;エディションの違い&lt;/strong&gt;：2015エディションでは、 &lt;code&gt;use&lt;/code&gt; パスを使用してクレートルート内のアイテムにアクセスすることもできます。上記の例を使用すると、次の &lt;code&gt;use&lt;/code&gt; パスは2015では機能しますが、2018では機能しません。</target>
        </trans-unit>
        <trans-unit id="627f712f9b93a0a851f59c926530c05272107ff4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edition Differences&lt;/strong&gt;: In the 2015 edition, crates in the extern prelude cannot be referenced via &lt;a href=&quot;use-declarations&quot;&gt;use declarations&lt;/a&gt;, so it is generally standard practice to include &lt;code&gt;extern crate&lt;/code&gt; declarations to bring them into scope.</source>
          <target state="translated">&lt;strong&gt;エディションの違い&lt;/strong&gt;：2015版では、externプレリュード内のクレートは&lt;a href=&quot;use-declarations&quot;&gt;use宣言&lt;/a&gt;で参照できないため、 &lt;code&gt;extern crate&lt;/code&gt; 宣言を含めてスコープに含めるのが一般的な標準的な方法です。</target>
        </trans-unit>
        <trans-unit id="f5085a0b269138950b893252f1966657953ef4b0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edition Differences&lt;/strong&gt;: In the 2015 edition, if the first bound of the trait object is a path that starts with &lt;code&gt;::&lt;/code&gt;, then the &lt;code&gt;dyn&lt;/code&gt; will be treated as a part of the path. The first path can be put in parenthesis to get around this. As such, if you want a trait object with the trait &lt;code&gt;::your_module::Trait&lt;/code&gt;, you should write it as &lt;code&gt;dyn (::your_module::Trait)&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;エディションの違い&lt;/strong&gt;：2015版では、特性オブジェクトの最初の境界が &lt;code&gt;::&lt;/code&gt; で始まるパスである場合、 &lt;code&gt;dyn&lt;/code&gt; はパスの一部として扱われます。これを回避するために、最初のパスを括弧で囲むことができます。そのため、特性 &lt;code&gt;::your_module::Trait&lt;/code&gt; 持つ特性オブジェクトが必要な場合は、それを &lt;code&gt;dyn (::your_module::Trait)&lt;/code&gt; として記述する必要があります。</target>
        </trans-unit>
        <trans-unit id="d876e32afa65f2d220b1dd922c7a25c124ae5c8d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edition Differences&lt;/strong&gt;: In the 2015 edition, it is possible to declare trait methods with anonymous parameters (e.g. &lt;code&gt;fn foo(u8)&lt;/code&gt;). This is deprecated and an error as of the 2018 edition. All parameters must have an argument name.</source>
          <target state="translated">&lt;strong&gt;エディションの違い&lt;/strong&gt;：2015エディションでは、匿名パラメーター（例： &lt;code&gt;fn foo(u8)&lt;/code&gt; ）を使用して特性メソッドを宣言できます。これは非推奨であり、2018年版の時点ではエラーです。すべてのパラメーターには引数名が必要です。</target>
        </trans-unit>
        <trans-unit id="d8a4eb3a8ecd26bd2a8200c1aa407e7c962a47c5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edition Differences&lt;/strong&gt;: In the 2015 edition, this syntax is valid that is disallowed as of the 2018 edition.</source>
          <target state="translated">&lt;strong&gt;エディションの違い&lt;/strong&gt;：2015エディションでは、この構文は有効ですが、2018エディションでは許可されていません。</target>
        </trans-unit>
        <trans-unit id="e6c48e95dbd2c5b344112038b2d6d28be512c6e3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edition Differences&lt;/strong&gt;: Starting with the 2018 edition, paths for &lt;code&gt;pub(in path)&lt;/code&gt; must start with &lt;code&gt;crate&lt;/code&gt;, &lt;code&gt;self&lt;/code&gt;, or &lt;code&gt;super&lt;/code&gt;. The 2015 edition may also use paths starting with &lt;code&gt;::&lt;/code&gt; or modules from the crate root.</source>
          <target state="translated">&lt;strong&gt;エディションの違い&lt;/strong&gt;：2018エディション以降、 &lt;code&gt;pub(in path)&lt;/code&gt; のパスは &lt;code&gt;crate&lt;/code&gt; 、 &lt;code&gt;self&lt;/code&gt; 、または &lt;code&gt;super&lt;/code&gt; で始まる必要があります。2015版では、 &lt;code&gt;::&lt;/code&gt; で始まるパス、またはクレートルートからのモジュールも使用できます。</target>
        </trans-unit>
        <trans-unit id="62a6b70d43483dfe4d5b7b6c6b58326793ee331d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edition differences&lt;/strong&gt;: Async blocks are only available beginning with Rust 2018.</source>
          <target state="translated">&lt;strong&gt;エディションの違い&lt;/strong&gt;：非同期ブロックは、Rust2018以降でのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="2ffeac211f4d5959ca339c3909c25a46b1449c9d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edition differences&lt;/strong&gt;: Async functions are only available beginning with Rust 2018.</source>
          <target state="translated">&lt;strong&gt;エディションの違い&lt;/strong&gt;：非同期機能は、Rust2018以降でのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="fbba24256158782afff4e1bf3667267a636ed2ef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edition differences&lt;/strong&gt;: Await expressions are only available beginning with Rust 2018.</source>
          <target state="translated">&lt;strong&gt;エディションの違い&lt;/strong&gt;：Await式は、Rust2018以降でのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="2bd803d8196215afbdb722ca42ff6863ebfdce05" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Encodings&lt;/strong&gt; - Rust strings are UTF-8, but C strings may use other encodings. If you are using a string from C, you should check its encoding explicitly, rather than just assuming that it is UTF-8 like you can do in Rust.</source>
          <target state="translated">&lt;strong&gt;エンコーディング&lt;/strong&gt; -Rust文字列はUTF-8ですが、C文字列は他のエンコーディングを使用する場合があります。Cの文字列を使用している場合は、RustのようにUTF-8であると想定するのではなく、そのエンコーディングを明示的に確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="c4744b4de56ac84ab4967b9e79393a7382d93137" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Errors&lt;/strong&gt;: If the function returns a &lt;code&gt;Result&lt;/code&gt;, describing the kinds of errors that might occur and what conditions might cause those errors to be returned can be helpful to callers so they can write code to handle the different kinds of errors in different ways.</source>
          <target state="translated">&lt;strong&gt;エラー&lt;/strong&gt;：関数が &lt;code&gt;Result&lt;/code&gt; を返す場合、発生する可能性のあるエラーの種類とそれらのエラーが返される原因となる可能性のある条件を説明すると、さまざまな種類のエラーをさまざまな方法で処理するコードを記述できるようになります。</target>
        </trans-unit>
        <trans-unit id="ab2c858e00d5352d65014ede49ecfd4f78f2629f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;From C to Rust:&lt;/strong&gt;&lt;a href=&quot;struct.cstr&quot;&gt;&lt;code&gt;CStr&lt;/code&gt;&lt;/a&gt; represents a borrowed C string; it is what you would use to wrap a raw &lt;code&gt;*const &lt;/code&gt;&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt; that you got from a C function. A &lt;a href=&quot;struct.cstr&quot;&gt;&lt;code&gt;CStr&lt;/code&gt;&lt;/a&gt; is guaranteed to be a nul-terminated array of bytes. Once you have a &lt;a href=&quot;struct.cstr&quot;&gt;&lt;code&gt;CStr&lt;/code&gt;&lt;/a&gt;, you can convert it to a Rust &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; if it's valid UTF-8, or lossily convert it by adding replacement characters.</source>
          <target state="translated">&lt;strong&gt;CからRustへ：&lt;/strong&gt;&lt;a href=&quot;struct.cstr&quot;&gt; &lt;code&gt;CStr&lt;/code&gt; &lt;/a&gt;は借用されたC文字列を表します。これは、C関数から取得した生の &lt;code&gt;*const &lt;/code&gt; &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt;をラップするために使用するものです。A &lt;a href=&quot;struct.cstr&quot;&gt; &lt;code&gt;CStr&lt;/code&gt; 関数は、&lt;/a&gt;バイトのNULで終わる配列であることが保証されます。あなたが持ってたら&lt;a href=&quot;struct.cstr&quot;&gt; &lt;code&gt;CStr&lt;/code&gt; 関数を&lt;/a&gt;、あなたは錆に変換することができます&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt;、それが有効なUTF-8だ場合、または非可逆置換文字を追加することによって、それを変換します。</target>
        </trans-unit>
        <trans-unit id="be0edd96752d258e24714cab9620512785d60bc1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;From C to Rust:&lt;/strong&gt;&lt;a href=&quot;struct.cstr&quot;&gt;&lt;code&gt;CStr&lt;/code&gt;&lt;/a&gt; represents a borrowed C string; it is what you would use to wrap a raw &lt;code&gt;*const &lt;/code&gt;&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt; that you got from a C function. A &lt;a href=&quot;struct.cstr&quot;&gt;&lt;code&gt;CStr&lt;/code&gt;&lt;/a&gt; is guaranteed to be a nul-terminated array of bytes. Once you have a &lt;a href=&quot;struct.cstr&quot;&gt;&lt;code&gt;CStr&lt;/code&gt;&lt;/a&gt;, you can convert it to a Rust &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; if it's valid UTF-8, or lossily convert it by adding replacement characters.</source>
          <target state="translated">&lt;strong&gt;CからRustへ：&lt;/strong&gt;&lt;a href=&quot;struct.cstr&quot;&gt; &lt;code&gt;CStr&lt;/code&gt; &lt;/a&gt;は借用したC文字列を表します。これは、C関数から取得した生の &lt;code&gt;*const &lt;/code&gt; &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt;をラップするために使用するものです。A &lt;a href=&quot;struct.cstr&quot;&gt; &lt;code&gt;CStr&lt;/code&gt; 関数は、&lt;/a&gt;バイトのNULで終わる配列であることが保証されます。あなたが持ってたら&lt;a href=&quot;struct.cstr&quot;&gt; &lt;code&gt;CStr&lt;/code&gt; 関数を&lt;/a&gt;、あなたは錆に変換することができます&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt;、それが有効なUTF-8だ場合、または非可逆置換文字を追加することによって、それを変換します。</target>
        </trans-unit>
        <trans-unit id="6a880c7c09fd0c1f69a3098a3095ef95bac0a546" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;From Rust to C:&lt;/strong&gt;&lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt; represents an owned, C-friendly string: it is nul-terminated, and has no internal nul characters. Rust code can create a &lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt; out of a normal string (provided that the string doesn't have nul characters in the middle), and then use a variety of methods to obtain a raw &lt;code&gt;*mut &lt;/code&gt;&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt; that can then be passed as an argument to functions which use the C conventions for strings.</source>
          <target state="translated">&lt;strong&gt;RustからCへ：&lt;/strong&gt;&lt;a href=&quot;struct.cstring&quot;&gt; &lt;code&gt;CString&lt;/code&gt; &lt;/a&gt;は所有されたCフレンドリーな文字列を表します。これはNULで終了し、内部のNUL文字はありません。Rustコードは、通常の文字列から&lt;a href=&quot;struct.cstring&quot;&gt; &lt;code&gt;CString&lt;/code&gt; &lt;/a&gt;を作成し（文字列の中央にヌル文字がない場合）、さまざまなメソッドを使用して、引数として渡される生の &lt;code&gt;*mut &lt;/code&gt; &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt;を取得できます。文字列にCの規則を使用する関数。</target>
        </trans-unit>
        <trans-unit id="aae173511f045be6a9f0dfcffd69891dd82a8b0b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;From Rust to C:&lt;/strong&gt;&lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt; represents an owned, C-friendly string: it is nul-terminated, and has no internal nul characters. Rust code can create a &lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt; out of a normal string (provided that the string doesn't have nul characters in the middle), and then use a variety of methods to obtain a raw &lt;code&gt;*mut &lt;/code&gt;&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt; that can then be passed as an argument to functions which use the C conventions for strings.</source>
          <target state="translated">&lt;strong&gt;RustからCへ：&lt;/strong&gt;&lt;a href=&quot;struct.cstring&quot;&gt; &lt;code&gt;CString&lt;/code&gt; &lt;/a&gt;は、所有されているCフレンドリーな文字列を表します。これは、ヌル文字で終了し、内部ヌル文字はありません。 Rustコードは、通常の文字列から&lt;a href=&quot;struct.cstring&quot;&gt; &lt;code&gt;CString&lt;/code&gt; &lt;/a&gt;を作成し（文字列の途中にヌル文字がない場合）、さまざまなメソッドを使用して生の &lt;code&gt;*mut &lt;/code&gt; &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt;を取得し、これを引数としてに渡すことができます。文字列にC規則を使用する関数。</target>
        </trans-unit>
        <trans-unit id="c2238adb64a05e56adbe151507af6c19abcbbbc4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;From a Rust string&lt;/strong&gt;: &lt;code&gt;OsString&lt;/code&gt; implements &lt;a href=&quot;../convert/trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;, so you can use &lt;code&gt;my_string.from&lt;/code&gt; to create an &lt;code&gt;OsString&lt;/code&gt; from a normal Rust string.</source>
          <target state="translated">&lt;strong&gt;Rust文字列から&lt;/strong&gt;： &lt;code&gt;OsString&lt;/code&gt; は&lt;a href=&quot;../convert/trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; を実装するため、 &lt;code&gt;OsString&lt;/code&gt; を使用して通常のRust文字列から &lt;code&gt;my_string.from&lt;/code&gt; を作成できます。</target>
        </trans-unit>
        <trans-unit id="a856fdf688afa04d2bd84181c6260aaef0048cb5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;From slices:&lt;/strong&gt; Just like you can start with an empty Rust &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and then &lt;a href=&quot;../string/struct.string#method.push_str&quot;&gt;&lt;code&gt;String::push_str&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt; sub-string slices into it, you can create an empty &lt;code&gt;OsString&lt;/code&gt; with the &lt;a href=&quot;struct.osstring#method.new&quot;&gt;&lt;code&gt;OsString::new&lt;/code&gt;&lt;/a&gt; method and then push string slices into it with the &lt;a href=&quot;struct.osstring#method.push&quot;&gt;&lt;code&gt;OsString::push&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;strong&gt;：スライスから&lt;/strong&gt;ちょうどあなたが空の錆を開始することができますように&lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;、次に&lt;a href=&quot;../string/struct.string#method.push_str&quot;&gt; &lt;code&gt;String::push_str&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; のそれに部分文字列のスライス、あなたが空に作成することができます &lt;code&gt;OsString&lt;/code&gt; と&lt;a href=&quot;struct.osstring#method.new&quot;&gt; &lt;code&gt;OsString::new&lt;/code&gt; &lt;/a&gt;方法をし、その後でそれに文字列スライスを押す&lt;a href=&quot;struct.osstring#method.push&quot;&gt; &lt;code&gt;OsString::push&lt;/code&gt; &lt;/a&gt;メソッド。</target>
        </trans-unit>
        <trans-unit id="adfbc9f4c9b7bf87cce69244480b633a8de2c39f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;From slices:&lt;/strong&gt; Just like you can start with an empty Rust &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and then &lt;a href=&quot;../string/struct.string#method.push_str&quot;&gt;&lt;code&gt;push_str&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt; sub-string slices into it, you can create an empty &lt;code&gt;OsString&lt;/code&gt; with the &lt;a href=&quot;#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; method and then push string slices into it with the &lt;a href=&quot;#method.push&quot;&gt;&lt;code&gt;push&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;strong&gt;スライスから：&lt;/strong&gt;空のRust &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;から始めて、&lt;a href=&quot;../string/struct.string#method.push_str&quot;&gt; &lt;code&gt;push_str&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; サブ文字列スライスを &lt;code&gt;OsString&lt;/code&gt; できるように、&lt;a href=&quot;#method.new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt;メソッドで空のOsStringを作成し、&lt;a href=&quot;#method.push&quot;&gt; &lt;code&gt;push&lt;/code&gt; &lt;/a&gt;メソッドで文字列スライスをプッシュできます。</target>
        </trans-unit>
        <trans-unit id="5663223157e2b3d6031e4a48c107b41038aa63b5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Important.&lt;/strong&gt; At least at present, you should avoid using &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; types for functions that are defined in C but invoked from Rust. In those cases, you should directly mirror the C types as closely as possible. Using types like &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; where the C definition is just using &lt;code&gt;T*&lt;/code&gt; can lead to undefined behavior, as described in &lt;a href=&quot;https://github.com/rust-lang/unsafe-code-guidelines/issues/198&quot;&gt;rust-lang/unsafe-code-guidelines#198&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;重要。&lt;/strong&gt;少なくとも現時点では、Cで定義されているが、Rustから呼び出される関数に &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; タイプを使用することは避けてください。そのような場合は、Cタイプを可能な限り直接ミラーリングする必要があります。&lt;a href=&quot;https://github.com/rust-lang/unsafe-code-guidelines/issues/198&quot;&gt;rust-lang / unsafe-code-guidelines＃198で&lt;/a&gt;説明されているように、C定義が &lt;code&gt;T*&lt;/code&gt; を使用している &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; ようなタイプを使用すると、未定義の動作が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="629ec911ccd79d718629d3b5e11521368319be97" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Internal nul characters&lt;/strong&gt; - When C strings have a nul terminator character, this usually means that they cannot have nul characters in the middle &amp;mdash; a nul character would essentially truncate the string. Rust strings &lt;em&gt;can&lt;/em&gt; have nul characters in the middle, because nul does not have to mark the end of the string in Rust.</source>
          <target state="translated">&lt;strong&gt;内部ヌル文字&lt;/strong&gt; -C文字列にヌルターミネーター文字がある場合、これは通常、中央にヌル文字を含めることができないことを意味します。ヌル文字は基本的に文字列を切り捨てます。Rustの文字列の終わりをnulでマークする必要がないため、Rust文字列の中央にnul文字を含める&lt;em&gt;こと&lt;/em&gt;が&lt;em&gt;でき&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="b41d1a37bb22ed7e91444167c781b032f81cc870" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Modules&lt;/strong&gt; and &lt;strong&gt;use:&lt;/strong&gt; Let you control the organization, scope, and privacy of paths</source>
          <target state="translated">&lt;strong&gt;モジュール&lt;/strong&gt;と&lt;strong&gt;使用：&lt;/strong&gt;パスの編成、スコープ、プライバシーを制御できます</target>
        </trans-unit>
        <trans-unit id="41c40dd8ed6820329fca0f856e36989c1fdbd2b5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NB.&lt;/strong&gt; The never type was expected to be stabilized in 1.41, but due to some last minute regressions detected the stabilization was temporarily reverted. The &lt;code&gt;!&lt;/code&gt; type can only appear in function return types presently. See &lt;a href=&quot;https://github.com/rust-lang/rust/issues/35121&quot;&gt;the tracking issue&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;strong&gt;注意。&lt;/strong&gt;neverタイプは、1.41で安定化すると予想されていましたが、直前の回帰が検出されたため、安定化が一時的に元に戻されました。 &lt;code&gt;!&lt;/code&gt; 現在、型は関数の戻り値の型にのみ表示できます。詳細について&lt;a href=&quot;https://github.com/rust-lang/rust/issues/35121&quot;&gt;は、追跡の問題&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="060d89d923956472cc05e7319b76fa9d50a7e876" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE: The third invariant is currently unenforced due to historical oversight and significant reliance on the behaviour. It is currently undecided what to do about this going forward. Macros that do not respect the behaviour may become invalid in a future edition of Rust. See the &lt;a href=&quot;https://github.com/rust-lang/rust/issues/56575&quot;&gt;tracking issue&lt;/a&gt;.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;注：3番目の不変条件は、履歴の監視と動作への大幅な依存により、現在は適用されていません。現在、これについてどうするかは未定です。この動作を尊重しないマクロは、Rustの将来のエディションでは無効になる可能性があります。&lt;a href=&quot;https://github.com/rust-lang/rust/issues/56575&quot;&gt;追跡の問題を&lt;/a&gt;ご覧ください。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="379a60c8e2b4b827557b233553a6bc6c82683fa1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: If a parent of the given path doesn't exist, this function will return an error. To create a directory and all its missing parents at the same time, use the &lt;a href=&quot;fn.create_dir_all&quot;&gt;&lt;code&gt;create_dir_all&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;：指定されたパスの親が存在しない場合、この関数はエラーを返します。ディレクトリとそのすべての欠落している親を同時に作成するには、&lt;a href=&quot;fn.create_dir_all&quot;&gt; &lt;code&gt;create_dir_all&lt;/code&gt; &lt;/a&gt;関数を使用します。</target>
        </trans-unit>
        <trans-unit id="c177380835dd615160771cec4b0171b325482499" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;No matter what, Safe Rust can't cause Undefined Behavior&lt;/strong&gt;. This is referred to as &lt;a href=&quot;https://rust-lang.github.io/unsafe-code-guidelines/glossary.html#soundness-of-code--of-a-library&quot;&gt;soundness&lt;/a&gt;: a well-typed program actually has the desired properties. The &lt;a href=&quot;https://doc.rust-lang.org/nomicon/safe-unsafe-meaning.html&quot;&gt;Nomicon&lt;/a&gt; has a more detailed explanation on the subject.</source>
          <target state="translated">&lt;strong&gt;何があっても、SafeRustは未定義の振る舞いを引き起こすことはできません&lt;/strong&gt;。これは&lt;a href=&quot;https://rust-lang.github.io/unsafe-code-guidelines/glossary.html#soundness-of-code--of-a-library&quot;&gt;健全性&lt;/a&gt;と呼ばれます。適切に入力されたプログラムには、実際に必要なプロパティがあります。&lt;a href=&quot;https://doc.rust-lang.org/nomicon/safe-unsafe-meaning.html&quot;&gt;Nomiconに&lt;/a&gt;は、このテーマに関するより詳細な説明があります。</target>
        </trans-unit>
        <trans-unit id="6558cd07ee1a59a066bae7f1a7d1d4e7129c19ab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note: This trait must not fail&lt;/strong&gt;. If the conversion can fail, use &lt;a href=&quot;trait.tryfrom&quot;&gt;&lt;code&gt;TryFrom&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注：この特性は失敗してはなりません&lt;/strong&gt;。変換が失敗する可能性がある場合は、&lt;a href=&quot;trait.tryfrom&quot;&gt; &lt;code&gt;TryFrom&lt;/code&gt; を&lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="fc7fd5e949a51b13efc359ef4faae3bf584089ed" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note: This trait must not fail&lt;/strong&gt;. If the conversion can fail, use &lt;a href=&quot;trait.tryinto&quot;&gt;&lt;code&gt;TryInto&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注：この特性は失敗してはなりません&lt;/strong&gt;。変換が失敗する可能性がある場合は、&lt;a href=&quot;trait.tryinto&quot;&gt; &lt;code&gt;TryInto&lt;/code&gt; を&lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="a5b6ef596678a6ec7ac86f37d73d853ca889a37a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note: This trait must not fail&lt;/strong&gt;. If the conversion can fail, use a dedicated method which returns an &lt;a href=&quot;../option/enum.option&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注：この特性は失敗してはなりません&lt;/strong&gt;。変換が失敗する可能性がある場合は、&lt;a href=&quot;../option/enum.option&quot;&gt; &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; &lt;/a&gt;を返す専用メソッドを使用します。</target>
        </trans-unit>
        <trans-unit id="9f7d81ecf2a6b96e00a858ce77d080e3c485f5c1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; If you need to borrow a string that was allocated by foreign code, use &lt;a href=&quot;struct.cstr&quot;&gt;&lt;code&gt;CStr&lt;/code&gt;&lt;/a&gt;. If you need to take ownership of a string that was allocated by foreign code, you will need to make your own provisions for freeing it appropriately, likely with the foreign code's API to do that.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt;外部コードによって割り当てられた文字列を借用する必要がある場合は、&lt;a href=&quot;struct.cstr&quot;&gt; &lt;code&gt;CStr&lt;/code&gt; を&lt;/a&gt;使用してください。外部コードによって割り当てられた文字列の所有権を取得する必要がある場合は、外部コードのAPIを使用して適切に解放するための独自の準備を行う必要があります。</target>
        </trans-unit>
        <trans-unit id="64f82543ebfb5e0c22f3304371c4e50429156fcf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The future type that rustc generates is roughly equivalent to an enum with one variant per &lt;code&gt;await&lt;/code&gt; point, where each variant stores the data needed to resume from its corresponding point.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt; rustcが生成する未来型あたりの一の変形例と列挙とほぼ同等である &lt;code&gt;await&lt;/code&gt; 点、その対応点から再開するのに必要な各バリアントデータを記憶します。</target>
        </trans-unit>
        <trans-unit id="d2eeefa40f9901be73a381ca76c97ef76a1ea8ba" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This function is only available on targets where &lt;code&gt;i16&lt;/code&gt; has an alignment of 2 bytes.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt;この関数は、 &lt;code&gt;i16&lt;/code&gt; の配置が2バイトのターゲットでのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="4c2293fd49da6801b825298bc259cec03257c7fa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This function is only available on targets where &lt;code&gt;i32&lt;/code&gt; has an alignment of 4 bytes.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt;この関数は、 &lt;code&gt;i32&lt;/code&gt; の配置が4バイトのターゲットでのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="7b262d56cf8e8f408dcc17fe9b8801b4eb3fadab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This function is only available on targets where &lt;code&gt;i64&lt;/code&gt; has an alignment of 8 bytes.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt;この関数は、 &lt;code&gt;i64&lt;/code&gt; のアラインメントが8バイトのターゲットでのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="16b9eed4ac2d21cb27e6a0debb93f9f3a3bcc5a6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This function is only available on targets where &lt;code&gt;isize&lt;/code&gt; has an alignment of 8 bytes.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt;この関数は、 &lt;code&gt;isize&lt;/code&gt; のアラインメントが8バイトのターゲットでのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="44eefe3185a3db0f5cea7158f26fe463c75dc726" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This function is only available on targets where &lt;code&gt;u16&lt;/code&gt; has an alignment of 2 bytes.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt;この関数は、 &lt;code&gt;u16&lt;/code&gt; の配置が2バイトのターゲットでのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="eb1fea0129a87e0a989b444fe1258f62a320490b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This function is only available on targets where &lt;code&gt;u32&lt;/code&gt; has an alignment of 4 bytes.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt;この関数は、 &lt;code&gt;u32&lt;/code&gt; のアラインメントが4バイトのターゲットでのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="28e50b005c31c5d32ebfdba7f184b17a96b48b58" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This function is only available on targets where &lt;code&gt;u64&lt;/code&gt; has an alignment of 8 bytes.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt;この関数は、 &lt;code&gt;u64&lt;/code&gt; のアラインメントが8バイトのターゲットでのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="1bc61ff9f0824102bc626b9c7cdffa39c424b522" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This function is only available on targets where &lt;code&gt;usize&lt;/code&gt; has an alignment of 8 bytes.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt;この関数は、 &lt;code&gt;usize&lt;/code&gt; が8バイトのアラインメントを持つターゲットでのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="7305f68e95514e24a7c95d0883b00ea54e7a5611" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This method is only available on platforms that support atomic operations on &lt;code&gt;u8&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt;このメソッドは、 &lt;code&gt;u8&lt;/code&gt; でのアトミック操作をサポートするプラットフォームでのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="3f9beca619923587f1e53345a612ee54183accda" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This method is only available on platforms that support atomic operations on pointers.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt;このメソッドは、ポインターのアトミック操作をサポートするプラットフォームでのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="b4637566695ac5a54cd62243b48c42f9fc2ba5a3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This syntax only adds another restriction to the visibility of an item. It does not guarantee that the item is visible within all parts of the specified scope. To access an item, all of its parent items up to the current scope must still be visible as well.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt;この構文は、アイテムの表示に別の制限を追加するだけです。指定されたスコープのすべての部分にアイテムが表示されることを保証するものではありません。アイテムにアクセスするには、現在のスコープまでのすべての親アイテムも引き続き表示されている必要があります。</target>
        </trans-unit>
        <trans-unit id="133699edea54cc02f638b728f6d305bf0c4eb4aa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This type is only available on platforms that support atomic loads and stores of &lt;a href=&quot;../../primitive.i16&quot;&gt;&lt;code&gt;i16&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt;このタイプは、&lt;a href=&quot;../../primitive.i16&quot;&gt; &lt;code&gt;i16&lt;/code&gt; の&lt;/a&gt;アトミックロードとストアをサポートするプラットフォームでのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="24d47c135cd7e9598aabb084d4e238fb2da1f926" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This type is only available on platforms that support atomic loads and stores of &lt;a href=&quot;../../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt;このタイプは、&lt;a href=&quot;../../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; の&lt;/a&gt;アトミックロードとストアをサポートするプラットフォームでのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="f12df48c2a5ede4cad5f196c278170c76aa69b27" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This type is only available on platforms that support atomic loads and stores of &lt;a href=&quot;../../primitive.i64&quot;&gt;&lt;code&gt;i64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt;このタイプは、&lt;a href=&quot;../../primitive.i64&quot;&gt; &lt;code&gt;i64&lt;/code&gt; の&lt;/a&gt;アトミックロードとストアをサポートするプラットフォームでのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="770d30f50039965c0a80bc18afb0f57006c8ecf7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This type is only available on platforms that support atomic loads and stores of &lt;a href=&quot;../../primitive.i8&quot;&gt;&lt;code&gt;i8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt;このタイプは、&lt;a href=&quot;../../primitive.i8&quot;&gt; &lt;code&gt;i8&lt;/code&gt; の&lt;/a&gt;アトミック・ロードおよびストアをサポートするプラットフォームでのみ使用可能です。</target>
        </trans-unit>
        <trans-unit id="3770fb7d89c845d66075484dac6af6613879c5c0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This type is only available on platforms that support atomic loads and stores of &lt;a href=&quot;../../primitive.isize&quot;&gt;&lt;code&gt;isize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt;このタイプは、アトミックロードと&lt;a href=&quot;../../primitive.isize&quot;&gt; &lt;code&gt;isize&lt;/code&gt; の&lt;/a&gt;ストアをサポートするプラットフォームでのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="eb007ca7675d599d0fd1022828e893745c373c65" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This type is only available on platforms that support atomic loads and stores of &lt;a href=&quot;../../primitive.u16&quot;&gt;&lt;code&gt;u16&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt;このタイプは、&lt;a href=&quot;../../primitive.u16&quot;&gt; &lt;code&gt;u16&lt;/code&gt; の&lt;/a&gt;アトミックロードとストアをサポートするプラットフォームでのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="3cf286238fb78dad77f34b185f05fcd2ccdeabb1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This type is only available on platforms that support atomic loads and stores of &lt;a href=&quot;../../primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt;このタイプは、&lt;a href=&quot;../../primitive.u32&quot;&gt; &lt;code&gt;u32&lt;/code&gt; の&lt;/a&gt;アトミックロードとストアをサポートするプラットフォームでのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="6e3460e7cb91ab667e7a2edc5f99bef2b41f79b4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This type is only available on platforms that support atomic loads and stores of &lt;a href=&quot;../../primitive.u64&quot;&gt;&lt;code&gt;u64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt;このタイプは、&lt;a href=&quot;../../primitive.u64&quot;&gt; &lt;code&gt;u64&lt;/code&gt; の&lt;/a&gt;アトミックロードとストアをサポートするプラットフォームでのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="fe0118a9443b5848b0cf822fd3a311a3f6ce113f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This type is only available on platforms that support atomic loads and stores of &lt;a href=&quot;../../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt;このタイプは、&lt;a href=&quot;../../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; の&lt;/a&gt;アトミックロードとストアをサポートするプラットフォームでのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="de09eea9ef2bf2d098a984258c71927e3c4b2b70" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This type is only available on platforms that support atomic loads and stores of &lt;a href=&quot;../../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt;このタイプは、アトミックロードと&lt;a href=&quot;../../primitive.usize&quot;&gt; &lt;code&gt;usize&lt;/code&gt; の&lt;/a&gt;ストアをサポートするプラットフォームでのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="1bc278c534e3be01a1f5e2970b2fd676ed81d535" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Uninitialized memory is also implicitly invalid for any type that has a restricted set of valid values. In other words, the only cases in which reading uninitialized memory is permitted are inside &lt;code&gt;union&lt;/code&gt;s and in &quot;padding&quot; (the gaps between the fields/elements of a type).</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt;初期化されていないメモリは、有効な値のセットが制限されているタイプに対しても暗黙的に無効です。言い換えると、初期化されていないメモリの読み取りが許可されるのは、 &lt;code&gt;union&lt;/code&gt; 内と「パディング」（タイプのフィールド/要素間のギャップ）のみです。</target>
        </trans-unit>
        <trans-unit id="2bb5d63cdf94e5456c6918112042bd1091e5e9f7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: &lt;a href=&quot;variables&quot;&gt;variables&lt;/a&gt;, function parameters, &lt;a href=&quot;items/constant-items&quot;&gt;const&lt;/a&gt; items, and &lt;a href=&quot;items/static-items&quot;&gt;static&lt;/a&gt; items must be &lt;code&gt;Sized&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;：&lt;a href=&quot;variables&quot;&gt;変数&lt;/a&gt;、関数パラメーター、&lt;a href=&quot;items/constant-items&quot;&gt;const&lt;/a&gt;アイテム、および&lt;a href=&quot;items/static-items&quot;&gt;静的&lt;/a&gt;アイテムは &lt;code&gt;Sized&lt;/code&gt; する必要があります。</target>
        </trans-unit>
        <trans-unit id="1d46ac6d8774740d98a4009a231d2213aeed2a7c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: &lt;code&gt;rustc&lt;/code&gt; achieves this with the unstable &lt;code&gt;rustc_layout_scalar_valid_range_*&lt;/code&gt; attributes.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;： &lt;code&gt;rustc&lt;/code&gt; は、不安定な &lt;code&gt;rustc_layout_scalar_valid_range_*&lt;/code&gt; 属性を使用してこれを実現します。</target>
        </trans-unit>
        <trans-unit id="c50c739d9eb5da5613037181f561652a032953a8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Additional crates that ship with &lt;code&gt;rustc&lt;/code&gt;, such as &lt;a href=&quot;https://doc.rust-lang.org/alloc/index.html&quot;&gt;&lt;code&gt;alloc&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://doc.rust-lang.org/test/index.html&quot;&gt;&lt;code&gt;test&lt;/code&gt;&lt;/a&gt;, are not automatically included with the &lt;code&gt;--extern&lt;/code&gt; flag when using Cargo. They must be brought into scope with an &lt;code&gt;extern crate&lt;/code&gt; declaration, even in the 2018 edition.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;：Cargoを使用する場合、&lt;a href=&quot;https://doc.rust-lang.org/alloc/index.html&quot;&gt; &lt;code&gt;alloc&lt;/code&gt; &lt;/a&gt;や&lt;a href=&quot;https://doc.rust-lang.org/test/index.html&quot;&gt; &lt;code&gt;test&lt;/code&gt; &lt;/a&gt;などの &lt;code&gt;rustc&lt;/code&gt; に付属する追加のクレートは、 &lt;code&gt;--extern&lt;/code&gt; フラグに自動的に含まれません。2018年版であっても、 &lt;code&gt;extern crate&lt;/code&gt; 宣言を使用してスコープに含める必要があります。</target>
        </trans-unit>
        <trans-unit id="bf68398fddb94f0a1abd51db31ce0b9347bd8495" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Additional crates that ship with &lt;code&gt;rustc&lt;/code&gt;, such as &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/index.html&quot;&gt;&lt;code&gt;proc_macro&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/alloc/index.html&quot;&gt;&lt;code&gt;alloc&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://doc.rust-lang.org/test/index.html&quot;&gt;&lt;code&gt;test&lt;/code&gt;&lt;/a&gt;, are not automatically included with the &lt;code&gt;--extern&lt;/code&gt; flag when using Cargo. They must be brought into scope with an &lt;code&gt;extern crate&lt;/code&gt; declaration, even in the 2018 edition.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;：を有する船こと追加クレート &lt;code&gt;rustc&lt;/code&gt; など、&lt;a href=&quot;https://doc.rust-lang.org/proc_macro/index.html&quot;&gt; &lt;code&gt;proc_macro&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://doc.rust-lang.org/alloc/index.html&quot;&gt; &lt;code&gt;alloc&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;https://doc.rust-lang.org/test/index.html&quot;&gt; &lt;code&gt;test&lt;/code&gt; &lt;/a&gt;、自動的に含まれていない &lt;code&gt;--extern&lt;/code&gt; 貨物を使用する場合、フラグ。それらは、2018年版であっても、 &lt;code&gt;extern crate&lt;/code&gt; 宣言で対象範囲に含める必要があります。</target>
        </trans-unit>
        <trans-unit id="d2b504e0a31dcf2bae64d03c73c728e13b4132f7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Configuration options with the key &lt;code&gt;feature&lt;/code&gt; are a convention used by &lt;a href=&quot;https://doc.rust-lang.org/cargo/reference/features.html&quot;&gt;Cargo&lt;/a&gt; for specifying compile-time options and optional dependencies.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;：主要な &lt;code&gt;feature&lt;/code&gt; 備えた構成オプションは、コンパイル時オプションとオプションの依存関係を指定するために&lt;a href=&quot;https://doc.rust-lang.org/cargo/reference/features.html&quot;&gt;Cargo&lt;/a&gt;が使用する規則です。</target>
        </trans-unit>
        <trans-unit id="f8381d4f5be828c7771e48194e3784bf6556e9d2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: For &lt;code&gt;rustc&lt;/code&gt;, arbitrary-set configuration options are set using the &lt;a href=&quot;https://doc.rust-lang.org/rustc/command-line-arguments.html#--cfg-configure-the-compilation-environment&quot;&gt;&lt;code&gt;--cfg&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;： &lt;code&gt;rustc&lt;/code&gt; の場合、任意に設定された構成オプションは&lt;a href=&quot;https://doc.rust-lang.org/rustc/command-line-arguments.html#--cfg-configure-the-compilation-environment&quot;&gt; &lt;code&gt;--cfg&lt;/code&gt; &lt;/a&gt;フラグを使用して設定されます。</target>
        </trans-unit>
        <trans-unit id="0e534aae954895e78357179a1ac94a40dd8cf86b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: For &lt;code&gt;rustc&lt;/code&gt;, arbitrary-set configuration options are set using the &lt;a href=&quot;https://doc.rust-lang.org/rustc/command-line-arguments.html#a--cfg-configure-the-compilation-environment&quot;&gt;&lt;code&gt;--cfg&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;： &lt;code&gt;rustc&lt;/code&gt; の場合、任意設定の構成オプションは&lt;a href=&quot;https://doc.rust-lang.org/rustc/command-line-arguments.html#a--cfg-configure-the-compilation-environment&quot;&gt; &lt;code&gt;--cfg&lt;/code&gt; &lt;/a&gt;フラグを使用して設定されます。</target>
        </trans-unit>
        <trans-unit id="c424a34ea4d877226958104553992541e3787ae9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: In the past, the Rust community used the terms &quot;Unambiguous Function Call Syntax&quot;, &quot;Universal Function Call Syntax&quot;, or &quot;UFCS&quot;, in documentation, issues, RFCs, and other community writings. However, the term lacks descriptive power and potentially confuses the issue at hand. We mention it here for searchability's sake.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;：以前、Rustコミュニティは、ドキュメント、問題、RFC、およびその他のコミュニティの執筆で、「あいまいでない関数呼び出し構文」、「ユニバーサル関数呼び出し構文」、または「UFCS」という用語を使用していました。ただし、この用語には説明力がなく、問題を混乱させる可能性があります。ここでは検索性のために言及します。</target>
        </trans-unit>
        <trans-unit id="7e4168c7dfa2ff3fb21bdd3b2ee7e059ab5726bf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Lifetimes can be, and usually are, elided with this shorthand.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;：寿命は、この省略形で省略でき、通常は省略できます。</target>
        </trans-unit>
        <trans-unit id="bccc13cc797f7b85b663c8c0720dcbb028e2999f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Many pieces of Rust code may assume that pointers, &lt;code&gt;usize&lt;/code&gt;, and &lt;code&gt;isize&lt;/code&gt; are either 32-bit or 64-bit. As a consequence, 16-bit pointer support is limited and may require explicit care and acknowledgment from a library to support.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;：Rustコードの多くの部分では、ポインター、 &lt;code&gt;usize&lt;/code&gt; 、および &lt;code&gt;isize&lt;/code&gt; が32ビットまたは64ビットのいずれかであると想定している場合があります。結果として、16ビットポインタのサポートは制限されており、サポートするにはライブラリからの明示的な注意と確認が必要になる場合があります。</target>
        </trans-unit>
        <trans-unit id="2ee6a6f44b42148913ce05336e8333f03b878a8a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: On platforms that do not support receiving spin-loop hints this function does not do anything at all.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;：スピンループヒントの受信をサポートしていないプラットフォームでは、この関数は何もしません。</target>
        </trans-unit>
        <trans-unit id="3cd7dc42d46fc1a7eaf8316e86e18b4771b7a37c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Previous to &lt;code&gt;rustc&lt;/code&gt; 1.30, using &lt;code&gt;mod.rs&lt;/code&gt; files was the way to load a module with nested children. It is encouraged to use the new naming convention as it is more consistent, and avoids having many files named &lt;code&gt;mod.rs&lt;/code&gt; within a project.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;： &lt;code&gt;rustc&lt;/code&gt; 1.30 以前は、ネストされた子を持つモジュールをロードする方法として &lt;code&gt;mod.rs&lt;/code&gt; ファイルを使用していました。より一貫性があり、プロジェクト内で &lt;code&gt;mod.rs&lt;/code&gt; という名前の多くのファイルを使用することを避けるため、新しい命名規則を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="09dbeb2a0b5b6ab350517ca73457c241b60699f0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The &lt;code&gt;cfg_attr&lt;/code&gt; can expand to another &lt;code&gt;cfg_attr&lt;/code&gt;. For example, &lt;code&gt;#[cfg_attr(linux, cfg_attr(feature = &quot;multithreaded&quot;, some_other_attribute))&lt;/code&gt; is valid. This example would be equivalent to &lt;code&gt;#[cfg_attr(all(linux, feature =&quot;multithreaded&quot;), some_other_attribute)]&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;： &lt;code&gt;cfg_attr&lt;/code&gt; は別の &lt;code&gt;cfg_attr&lt;/code&gt; に拡張できます。たとえば、 &lt;code&gt;#[cfg_attr(linux, cfg_attr(feature = &quot;multithreaded&quot;, some_other_attribute))&lt;/code&gt; は有効です。この例は、 &lt;code&gt;#[cfg_attr(all(linux, feature =&quot;multithreaded&quot;), some_other_attribute)]&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="48afce94d3f617db585b69f838ac8fa2fe7c7c45" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The &lt;code&gt;cfg_attr&lt;/code&gt; can expand to another &lt;code&gt;cfg_attr&lt;/code&gt;. For example, &lt;code&gt;#[cfg_attr(target_os = &quot;linux&quot;, cfg_attr(feature = &quot;multithreaded&quot;, some_other_attribute))]&lt;/code&gt; is valid. This example would be equivalent to &lt;code&gt;#[cfg_attr(all(target_os = &quot;linux&quot;, feature =&quot;multithreaded&quot;), some_other_attribute)]&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;： &lt;code&gt;cfg_attr&lt;/code&gt; は別の &lt;code&gt;cfg_attr&lt;/code&gt; に展開できます。たとえば、 &lt;code&gt;#[cfg_attr(target_os = &quot;linux&quot;, cfg_attr(feature = &quot;multithreaded&quot;, some_other_attribute))]&lt;/code&gt; は有効です。この例は、 &lt;code&gt;#[cfg_attr(all(target_os = &quot;linux&quot;, feature =&quot;multithreaded&quot;), some_other_attribute)]&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="542e5e434f17a5e7fe96f177447ca260c03e5782" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The &lt;code&gt;rustc&lt;/code&gt; test harness supports the &lt;code&gt;--include-ignored&lt;/code&gt; flag to force ignored tests to be run.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;： &lt;code&gt;rustc&lt;/code&gt; テストハーネスは、無視するテストを強制的に実行する &lt;code&gt;--include-ignored&lt;/code&gt; フラグをサポートしています。</target>
        </trans-unit>
        <trans-unit id="ee8746d1970619c1573d4cba9ddf4d37981ddfcf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The LLVM backend of the &lt;code&gt;rustc&lt;/code&gt; implementation aborts the process by executing an illegal instruction.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;： &lt;code&gt;rustc&lt;/code&gt; 実装のLLVMバックエンドは、不正な命令を実行することによってプロセスを中止します。</target>
        </trans-unit>
        <trans-unit id="0b6a9b1648330a6c400057a929b0e006d7b0e3f7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The exact rules for temporary lifetime extension are subject to change. This is describing the current behavior only.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;：一時的な有効期間延長の正確なルールは変更される可能性があります。これは、現在の動作のみを説明しています。</target>
        </trans-unit>
        <trans-unit id="9663ac595985a9b26dbb960d0c43b0ba63112b12" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The tuple index may include an &lt;code&gt;INTEGER_SUFFIX&lt;/code&gt;, but this is not intended to be valid, and may be removed in a future version. See &lt;a href=&quot;https://github.com/rust-lang/rust/issues/60210&quot;&gt;https://github.com/rust-lang/rust/issues/60210&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;：タプルインデックスには &lt;code&gt;INTEGER_SUFFIX&lt;/code&gt; が含まれる場合がありますが、これは有効であることが意図されておらず、将来のバージョンで削除される可能性があります。詳細については、&lt;a href=&quot;https://github.com/rust-lang/rust/issues/60210&quot;&gt;https：//github.com/rust-lang/rust/issues/60210&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="2e578eea7529dc499f5ab70e8ee02f1a3a04f7e6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This function returns an array of length 2, 4 or 8 bytes depending on the target pointer size.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;：この関数は、ターゲットポインターのサイズに応じて、長さが2、4、または8バイトの配列を返します。</target>
        </trans-unit>
        <trans-unit id="204f556d6eb284d02edf2bf12e7415dff429dcbd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This function takes an array of length 2, 4 or 8 bytes depending on the target pointer size.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;：この関数は、ターゲットポインターのサイズに応じて、長さが2、4、または8バイトの配列を取ります。</target>
        </trans-unit>
        <trans-unit id="205669dd54e34ac0f225ea4e8c1e039e92861b84" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This is an example note.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;：これは&lt;strong&gt;メモ&lt;/strong&gt;の例です。</target>
        </trans-unit>
        <trans-unit id="4f8175ab0b6ced026c78c226ce62e4e0326a00cb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This method is currently implemented as a 0-cost cast, but it is planned to alter its definition in the future to perform the length calculation whenever this method is called.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;：このメソッドは現在、0コストのキャストとして実装されていますが、このメソッドが呼び出されるたびに長さの計算を実行するように、将来その定義を変更する予定です。</target>
        </trans-unit>
        <trans-unit id="9364ca407d4e4789b372b4d12ec8ebcdd47debe7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This method is currently implemented as a constant-time cast, but it is planned to alter its definition in the future to perform the length calculation whenever this method is called.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;：このメソッドは現在、一定時間キャストとして実装されていますが、このメソッドが呼び出されるたびに長さの計算を実行するように、将来その定義を変更する予定です。</target>
        </trans-unit>
        <trans-unit id="9acff81794f805a2a107dfa5d332d79517391aa9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This method is currently implemented to check for validity after a constant-time cast, but it is planned to alter its definition in the future to perform the length calculation in addition to the UTF-8 check whenever this method is called.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;：このメソッドは現在、一定時間キャスト後に有効性をチェックするために実装されていますが、このメソッドが呼び出されるたびに、UTF-8チェックに加えて長さ計算を実行するように将来的に定義を変更する予定です。</target>
        </trans-unit>
        <trans-unit id="77e80de2eb59d874ef66f952f67864f1b6680268" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This method is only available on platforms that support atomic operations on &lt;a href=&quot;../../primitive.i16&quot;&gt;&lt;code&gt;i16&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;：このメソッドは、&lt;a href=&quot;../../primitive.i16&quot;&gt; &lt;code&gt;i16&lt;/code&gt; での&lt;/a&gt;アトミック操作をサポートするプラットフォームでのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="416612bbf1909b1aaf73c8e8594ced2ad9b5958a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This method is only available on platforms that support atomic operations on &lt;a href=&quot;../../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;：このメソッドは、&lt;a href=&quot;../../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; での&lt;/a&gt;アトミック操作をサポートするプラットフォームでのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="798babd1633ffc3445fb72738f51aaf665f2e799" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This method is only available on platforms that support atomic operations on &lt;a href=&quot;../../primitive.i64&quot;&gt;&lt;code&gt;i64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;：このメソッドは、&lt;a href=&quot;../../primitive.i64&quot;&gt; &lt;code&gt;i64&lt;/code&gt; での&lt;/a&gt;アトミック操作をサポートするプラットフォームでのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="969f814fd42a6f3586c98e8e6d74c5e1cf0d998f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This method is only available on platforms that support atomic operations on &lt;a href=&quot;../../primitive.i8&quot;&gt;&lt;code&gt;i8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;：このメソッドは、&lt;a href=&quot;../../primitive.i8&quot;&gt; &lt;code&gt;i8&lt;/code&gt; での&lt;/a&gt;アトミック操作をサポートするプラットフォームでのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="c3a8e7d995f2b7f517cfd0675f44c74f193e4d3d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This method is only available on platforms that support atomic operations on &lt;a href=&quot;../../primitive.isize&quot;&gt;&lt;code&gt;isize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;：このメソッドは、&lt;a href=&quot;../../primitive.isize&quot;&gt; &lt;code&gt;isize&lt;/code&gt; での&lt;/a&gt;アトミック操作をサポートするプラットフォームでのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="1a7cf4f75cf7c1494a07e470c8288c8e67f0a8a5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This method is only available on platforms that support atomic operations on &lt;a href=&quot;../../primitive.u16&quot;&gt;&lt;code&gt;u16&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;：このメソッドは、&lt;a href=&quot;../../primitive.u16&quot;&gt; &lt;code&gt;u16&lt;/code&gt; での&lt;/a&gt;アトミック操作をサポートするプラットフォームでのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="902c1326c59de40d4ee4bf24e303fa8f00886b0f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This method is only available on platforms that support atomic operations on &lt;a href=&quot;../../primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;：このメソッドは、&lt;a href=&quot;../../primitive.u32&quot;&gt; &lt;code&gt;u32&lt;/code&gt; での&lt;/a&gt;アトミック操作をサポートするプラットフォームでのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="b49fa7c747b4b2f8fc4c2e1fee0ddd570ecece9b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This method is only available on platforms that support atomic operations on &lt;a href=&quot;../../primitive.u64&quot;&gt;&lt;code&gt;u64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;：このメソッドは、&lt;a href=&quot;../../primitive.u64&quot;&gt; &lt;code&gt;u64&lt;/code&gt; での&lt;/a&gt;アトミック操作をサポートするプラットフォームでのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="c60105950473e3de294db7b21f197086831cb667" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This method is only available on platforms that support atomic operations on &lt;a href=&quot;../../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;：このメソッドは、&lt;a href=&quot;../../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; での&lt;/a&gt;アトミック操作をサポートするプラットフォームでのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="7be6463d1fafa0db1e322e03e3852c3a451379a5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This method is only available on platforms that support atomic operations on &lt;a href=&quot;../../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;：このメソッドは、&lt;a href=&quot;../../primitive.usize&quot;&gt; &lt;code&gt;usize&lt;/code&gt; での&lt;/a&gt;アトミック操作をサポートするプラットフォームでのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="d5c5be5853f961e5512f727adc94106859254411" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This operation is intended to be a 0-cost cast but it is currently implemented with an up-front calculation of the length of the string. This is not guaranteed to always be the case.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;：この操作は0コストのキャストを対象としていますが、現在は文字列の長さの事前計算で実装されています。これは常に当てはまるとは限りません。</target>
        </trans-unit>
        <trans-unit id="669d4b633ce688c467334ac7653c165183f2e3ba" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This section is incomplete.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;：このセクションは不完全です。</target>
        </trans-unit>
        <trans-unit id="543aaedbc9a3d7322ce93678b22b0281abf794f1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This type is only available on platforms that support atomic loads and stores of &lt;code&gt;u8&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;：このタイプは、 &lt;code&gt;u8&lt;/code&gt; のアトミックロードとストアをサポートするプラットフォームでのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="245a6aeba0c030e92193a51c1b871f48d851f54f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This type is only available on platforms that support atomic loads and stores of pointers. Its size depends on the target pointer's size.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;：このタイプは、アトミックロードとポインターのストアをサポートするプラットフォームでのみ使用できます。そのサイズは、ターゲットポインタのサイズによって異なります。</target>
        </trans-unit>
        <trans-unit id="f5df3103e6447e1ad2ce9490f42afb19650917b3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Undefined behavior affects the entire program. For example, calling a function in C that exhibits undefined behavior of C means your entire program contains undefined behaviour that can also affect the Rust code. And vice versa, undefined behavior in Rust can cause adverse affects on code executed by any FFI calls to other languages.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;：未定義の動作はプログラム全体に影響します。たとえば、Cで未定義の動作を示す関数をCで呼び出すと、Rustコードに影響する可能性のある未定義の動作がプログラム全体に含まれます。また、逆の場合、Rustでの未定義の動作は、他の言語へのFFI呼び出しによって実行されるコードに悪影響を与える可能性があります。</target>
        </trans-unit>
        <trans-unit id="9b1e7bb136e3f88a33c4a3167dcad6a39cd6165d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Unlike field access expressions, tuple index expressions can be the function operand of a &lt;a href=&quot;call-expr&quot;&gt;call expression&lt;/a&gt; as it cannot be confused with a method call since method names cannot be numbers.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;：フィールドアクセス式とは異なり、タプルインデックス式は、メソッド名を数値にすることはできないため、メソッド呼び出しと混同できないため、&lt;a href=&quot;call-expr&quot;&gt;呼び出し式の&lt;/a&gt;関数オペランドにすることができます。</target>
        </trans-unit>
        <trans-unit id="9bf566863d0e6c1f93fa47ff736f9ade81dd38c3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: When using Cargo, Procedural macro crates are defined with the &lt;code&gt;proc-macro&lt;/code&gt; key in your manifest:</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;：Cargoを使用する場合、手続き型マクロクレートはマニフェストの &lt;code&gt;proc-macro&lt;/code&gt; キーで定義されます。</target>
        </trans-unit>
        <trans-unit id="a7f8ef7c18d1ebc911a4b8802c9c294409605f53" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Whitespace around the &lt;code&gt;=&lt;/code&gt; is ignored. &lt;code&gt;foo=&quot;bar&quot;&lt;/code&gt; and &lt;code&gt;foo = &quot;bar&quot;&lt;/code&gt; are equivalent configuration options.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;： &lt;code&gt;=&lt;/code&gt; の前後の空白は無視されます。 &lt;code&gt;foo=&quot;bar&quot;&lt;/code&gt; と &lt;code&gt;foo = &quot;bar&quot;&lt;/code&gt; は同等の設定オプションです。</target>
        </trans-unit>
        <trans-unit id="c47f0cd1f3859cc5bbc515bae176883c35a2e5e8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: that the outer &lt;code&gt;match&lt;/code&gt; is used to ensure that any &lt;a href=&quot;../expressions#temporaries&quot;&gt;temporary values&lt;/a&gt; in &lt;code&gt;iter_expr&lt;/code&gt; don't get dropped before the loop is finished. &lt;code&gt;next&lt;/code&gt; is declared before being assigned because it results in types being inferred correctly more often.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;：外側の &lt;code&gt;match&lt;/code&gt; は、ループが終了する前に &lt;code&gt;iter_expr&lt;/code&gt; の&lt;a href=&quot;../expressions#temporaries&quot;&gt;一時値&lt;/a&gt;が削除されないようにするために使用されることに&lt;strong&gt;注意してください&lt;/strong&gt;。 &lt;code&gt;next&lt;/code&gt; は、型がより頻繁に正しく推測される結果になるため、割り当てられる前に宣言されます。</target>
        </trans-unit>
        <trans-unit id="ca0b8f99436f4b7d93b7e3e4bd936fecc9cacde1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: that the outer &lt;code&gt;match&lt;/code&gt; is used to ensure that any &lt;a href=&quot;../expressions#temporary-lifetimes&quot;&gt;temporary values&lt;/a&gt; in &lt;code&gt;iter_expr&lt;/code&gt; don't get dropped before the loop is finished. &lt;code&gt;next&lt;/code&gt; is declared before being assigned because it results in types being inferred correctly more often.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;：外側の &lt;code&gt;match&lt;/code&gt; は、ループが終了する前に &lt;code&gt;iter_expr&lt;/code&gt; の&lt;a href=&quot;../expressions#temporary-lifetimes&quot;&gt;一時的な値&lt;/a&gt;が削除されないようにするために使用されます。 &lt;code&gt;next&lt;/code&gt; は、型がより頻繁に正しく推論される結果となるため、割り当てられる前に宣言されます。</target>
        </trans-unit>
        <trans-unit id="3d08b1d0d9771f64d914289f8a909594611ec769" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: this list is more restrictive than what you can write in regular constants</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;：このリストは、通常の定数で記述できるものよりも制限されています</target>
        </trans-unit>
        <trans-unit id="ff87edb614dc63eb552a33d527babfe470e595e1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: this module is unstable and is designed in &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/2504-fix-error.md&quot;&gt;RFC 2504&lt;/a&gt;, and you can learn more about its status in the &lt;a href=&quot;https://github.com/rust-lang/rust/issues/53487&quot;&gt;tracking issue&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;：このモジュールは不安定で、&lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/2504-fix-error.md&quot;&gt;RFC 2504&lt;/a&gt;で設計されています。このモジュールのステータスについて詳しくは、&lt;a href=&quot;https://github.com/rust-lang/rust/issues/53487&quot;&gt;追跡の問題を&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="f69af187844f3307c7ac46ebb6a50af4199d0748" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Notes&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Notes&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="b0d06bb798430870d22a876657b39e78b6fbe0c8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Nul terminators and implicit string lengths&lt;/strong&gt; - Often, C strings are nul-terminated, i.e., they have a &lt;code&gt;\0&lt;/code&gt; character at the end. The length of a string buffer is not stored, but has to be calculated; to compute the length of a string, C code must manually call a function like &lt;code&gt;strlen()&lt;/code&gt; for &lt;code&gt;char&lt;/code&gt;-based strings, or &lt;code&gt;wcslen()&lt;/code&gt; for &lt;code&gt;wchar_t&lt;/code&gt;-based ones. Those functions return the number of characters in the string excluding the nul terminator, so the buffer length is really &lt;code&gt;len+1&lt;/code&gt; characters. Rust strings don't have a nul terminator; their length is always stored and does not need to be calculated. While in Rust accessing a string's length is a &lt;code&gt;O(1)&lt;/code&gt; operation (because the length is stored); in C it is an &lt;code&gt;O(length)&lt;/code&gt; operation because the length needs to be computed by scanning the string for the nul terminator.</source>
          <target state="translated">&lt;strong&gt;ヌルターミネータと暗黙の文字列長&lt;/strong&gt;-多くの場合、C文字列はヌル文字で終了します。つまり、末尾に &lt;code&gt;\0&lt;/code&gt; 文字があります。文字列バッファの長さは保存されませんが、計算する必要があります。以下のような文字列の長さを計算するために、Cコードは、手動で関数を呼び出す必要があり &lt;code&gt;strlen()&lt;/code&gt; のための &lt;code&gt;char&lt;/code&gt; 列、またはベース &lt;code&gt;wcslen()&lt;/code&gt; 用 &lt;code&gt;wchar_t&lt;/code&gt; ベースのもの。これらの関数は、nulターミネータを除く文字列の文字数を返すため、バッファ長は実際には &lt;code&gt;len+1&lt;/code&gt; 文字です。さび文字列にはヌルターミネータがありません。それらの長さは常に保存され、計算する必要はありません。 Rustにいる間、文字列の長さにアクセスするのは &lt;code&gt;O(1)&lt;/code&gt; です操作（長さが格納されているため）; Cでは、文字列をスキャンしてnulターミネータを探すことによって長さを計算する必要があるため、これは &lt;code&gt;O(length)&lt;/code&gt; 演算です。</target>
        </trans-unit>
        <trans-unit id="484956955d43e1da5356d63148d3bf3ffefed245" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Nul terminators and implicit string lengths&lt;/strong&gt; - Often, C strings are nul-terminated, i.e., they have a &lt;code&gt;\0&lt;/code&gt; character at the end. The length of a string buffer is not stored, but has to be calculated; to compute the length of a string, C code must manually call a function like &lt;code&gt;strlen()&lt;/code&gt; for &lt;code&gt;char&lt;/code&gt;-based strings, or &lt;code&gt;wcslen()&lt;/code&gt; for &lt;code&gt;wchar_t&lt;/code&gt;-based ones. Those functions return the number of characters in the string excluding the nul terminator, so the buffer length is really &lt;code&gt;len+1&lt;/code&gt; characters. Rust strings don't have a nul terminator; their length is always stored and does not need to be calculated. While in Rust accessing a string's length is a O(1) operation (because the length is stored); in C it is an O(length) operation because the length needs to be computed by scanning the string for the nul terminator.</source>
          <target state="translated">&lt;strong&gt;NULターミネータと暗黙の文字列長&lt;/strong&gt; -多くの場合、C文字列はNULで終了します。つまり、末尾に &lt;code&gt;\0&lt;/code&gt; 文字があります。文字列バッファの長さは保存されませんが、計算する必要があります。以下のような文字列の長さを計算するために、Cコードは、手動で関数を呼び出す必要があり &lt;code&gt;strlen()&lt;/code&gt; のための &lt;code&gt;char&lt;/code&gt; 列、またはベース &lt;code&gt;wcslen()&lt;/code&gt; 用 &lt;code&gt;wchar_t&lt;/code&gt; ベースのもの。これらの関数は、nulターミネーターを除く文字列の文字数を返すため、バッファー長は実際には &lt;code&gt;len+1&lt;/code&gt; です。文字。Rust文字列にはNULターミネータはありません。それらの長さは常に保存され、計算する必要はありません。Rustでは、文字列の長さにアクセスするのはO（1）操作です（長さが保存されるため）。Cでは、長さはNULターミネーターの文字列をスキャンして計算する必要があるため、O（長さ）操作です。</target>
        </trans-unit>
        <trans-unit id="b3a55015f9b574b249377781d35ad1256b26e09a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Packages:&lt;/strong&gt; A Cargo feature that lets you build, test, and share crates</source>
          <target state="translated">&lt;strong&gt;パッケージ：&lt;/strong&gt;木箱を作成、テスト、共有できるCargo機能</target>
        </trans-unit>
        <trans-unit id="b9614e48c420558746aa5a195f1ca3514d9bdb89" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Panics&lt;/strong&gt;: The scenarios in which the function being documented could panic. Callers of the function who don&amp;rsquo;t want their programs to panic should make sure they don&amp;rsquo;t call the function in these situations.</source>
          <target state="translated">&lt;strong&gt;パニック&lt;/strong&gt;：文書化されている機能がパニックになる可能性があるシナリオ。プログラムにパニックを起こさせたくない関数の呼び出し元は、これらの状況で関数を呼び出さないようにする必要があります。</target>
        </trans-unit>
        <trans-unit id="48ddec251d4b93c950c826aa556ff50e924f3f09" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Paths:&lt;/strong&gt; A way of naming an item, such as a struct, function, or module</source>
          <target state="translated">&lt;strong&gt;パス：&lt;/strong&gt;構造体、関数、モジュールなどのアイテムに名前を付ける方法</target>
        </trans-unit>
        <trans-unit id="481513e92d2c79e9922e6fdaeaecbe26904d2dbb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Safety&lt;/strong&gt;: If the function is &lt;code&gt;unsafe&lt;/code&gt; to call (we discuss unsafety in Chapter 19), there should be a section explaining why the function is unsafe and covering the invariants that the function expects callers to uphold.</source>
          <target state="translated">&lt;strong&gt;安全性&lt;/strong&gt;：関数の呼び出しが &lt;code&gt;unsafe&lt;/code&gt; 場合（第19章で安全性について説明します）、関数が安全でない理由を説明し、関数が呼び出し元が保持すると期待する不変条件をカバーするセクションが必要です。</target>
        </trans-unit>
        <trans-unit id="f938faca9bb27bfed4287077e548ce31cbf39365" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Stability note:&lt;/strong&gt; This impl does not yet exist, but we are &quot;reserving space&quot; to add it in the future. See &lt;a href=&quot;https://github.com/rust-lang/rust/issues/64715&quot;&gt;rust-lang/rust#64715&lt;/a&gt; for details.</source>
          <target state="translated">&lt;strong&gt;安定性に関する注意：&lt;/strong&gt;このimplはまだ存在していませんが、将来追加するために「スペースを予約」しています。詳細については、&lt;a href=&quot;https://github.com/rust-lang/rust/issues/64715&quot;&gt;rust-lang / rust＃64715&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="7e43e997b28aeec3b9c71554f3cb60497761adcd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Supertraits&lt;/strong&gt; are traits that are required to be implemented for a type to implement a specific trait. Furthermore, anywhere a &lt;a href=&quot;generics&quot;&gt;generic&lt;/a&gt; or &lt;a href=&quot;../types/trait-object&quot;&gt;trait object&lt;/a&gt; is bounded by a trait, it has access to the associated items of its supertraits.</source>
          <target state="translated">&lt;strong&gt;スーパートレイト&lt;/strong&gt;トレイトは、型が特定のトレイトを実装するために実装する必要があるトレイトです。さらに、&lt;a href=&quot;generics&quot;&gt;ジェネリック&lt;/a&gt;&lt;a href=&quot;../types/trait-object&quot;&gt;オブジェクト&lt;/a&gt;またはトレイトオブジェクトがトレイトに囲まれている場合は、そのスーパートレイトの関連アイテムにアクセスできます。</target>
        </trans-unit>
        <trans-unit id="b38548e4d26b2038d4463b0d5471fd35986ae8ac" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This function is deprecated.&lt;/strong&gt; Use &lt;a href=&quot;union.maybeuninit&quot;&gt;&lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;strong&gt;この関数は非推奨です。&lt;/strong&gt;代わりに&lt;a href=&quot;union.maybeuninit&quot;&gt; &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="8f3ae627337dcbcd948c51fd96893635d151265e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This functon is deprecated.&lt;/strong&gt; Use &lt;a href=&quot;union.maybeuninit&quot;&gt;&lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;strong&gt;この機能は廃止されました。&lt;/strong&gt;代わりに&lt;a href=&quot;union.maybeuninit&quot;&gt; &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="90d5331accb6d1f759b6d533c2ffbb7485074384" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This method is soft-deprecated.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;このメソッドは、非推奨です。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c2492dfd60adc66b908569e7ad4f918b77633047" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Type coercions&lt;/strong&gt; are implicit operations that change the type of a value. They happen automatically at specific locations and are highly restricted in what types actually coerce.</source>
          <target state="translated">&lt;strong&gt;型強制&lt;/strong&gt;は、値の型を変更する暗黙の操作です。それらは特定の場所で自動的に発生し、実際に強制するタイプが非常に制限されています。</target>
        </trans-unit>
        <trans-unit id="7cd5055ffa46d984c313532603ca78647862a3d6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Unix&lt;/strong&gt;: On Unix-like platforms, it is unlikely that all 32 bits of &lt;code&gt;exit&lt;/code&gt; will be visible to a parent process inspecting the exit code. On most Unix-like platforms, only the eight least-significant bits are considered.</source>
          <target state="translated">&lt;strong&gt;Unix&lt;/strong&gt;：Unixライクなプラットフォームでは、32ビットの &lt;code&gt;exit&lt;/code&gt; がすべて親プロセスから見えて、終了コードを検査することはほとんどありません。ほとんどのUnixライクなプラットフォームでは、最下位8ビットのみが考慮されます。</target>
        </trans-unit>
        <trans-unit id="4c1aa9b3c8e196e8c2b0242b80db4f7600ac8956" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Version &amp;amp; Edition Differences&lt;/strong&gt;: Prior to Rust 1.30, &lt;code&gt;$crate&lt;/code&gt; and &lt;code&gt;local_inner_macros&lt;/code&gt; (below) were unsupported. They were added alongside path-based imports of macros (described above), to ensure that helper macros did not need to be manually imported by users of a macro-exporting crate. Crates written for earlier versions of Rust that use helper macros need to be modified to use &lt;code&gt;$crate&lt;/code&gt; or &lt;code&gt;local_inner_macros&lt;/code&gt; to work well with path-based imports.</source>
          <target state="translated">&lt;strong&gt;バージョンとエディションの違い&lt;/strong&gt;：Rust 1.30より前の&lt;strong&gt;バージョンでは&lt;/strong&gt;、 &lt;code&gt;$crate&lt;/code&gt; &lt;code&gt;local_inner_macros&lt;/code&gt; およびlocal_inner_macros（以下）はサポートされていませんでした。これらは、マクロのパスベースのインポート（上記を参照）とともに追加され、マクロをエクスポートするクレートのユーザーがヘルパーマクロを手動でインポートする必要がないようにしました。ヘルパーマクロを使用するRustの以前のバージョン用に記述された &lt;code&gt;$crate&lt;/code&gt; は、$ crateを使用するように変更する必要があります、パスベースのインポートで &lt;code&gt;local_inner_macros&lt;/code&gt; に機能 crateまたはlocal_inner_macrosを。</target>
        </trans-unit>
        <trans-unit id="a61fe7dcc9b944b7aa4bb3863418ae332c93ffba" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WARNING&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;WARNING&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="70d92d3e972f8d8fddf85474fbc20df429ca9e9a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: While various forms of this were discussed in &lt;a href=&quot;https://github.com/rust-lang/rfcs/pull/1937&quot;&gt;RFC #1937&lt;/a&gt;, it was ultimately cut from that RFC, and thus this type is more subject to change even than the usual unstable item churn.</source>
          <target state="translated">&lt;strong&gt;警告&lt;/strong&gt;：これのさまざまな形式が&lt;a href=&quot;https://github.com/rust-lang/rfcs/pull/1937&quot;&gt;RFC＃1937&lt;/a&gt;で説明されていましたが、最終的にはそのRFCからカットされたため、このタイプは通常の不安定なアイテムのチャーンよりも変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="430cf372e21694405a7f29b4ea7aae36bbc30335" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;1&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;1&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="0a5afaa9ee5bac968c87333877722aa1495b952b" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;2&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;2&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="488963209bc6867c0591ac82a1cb9c1a6a118fd7" translate="yes" xml:space="preserve">
          <source>A &quot;meta item&quot; is the syntax used for the &lt;em&gt;Attr&lt;/em&gt; rule by most &lt;a href=&quot;#built-in-attributes-index&quot;&gt;built-in attributes&lt;/a&gt;. It has the following grammar:</source>
          <target state="translated">「メタアイテム」は、ほとんどの&lt;a href=&quot;#built-in-attributes-index&quot;&gt;組み込み属性&lt;/a&gt;によって&lt;em&gt;Attr&lt;/em&gt;ルールに使用される構文です。次の文法があります。</target>
        </trans-unit>
        <trans-unit id="a4ab7f7217b5214e279ea052fb2ed3cfbd58c8f2" translate="yes" xml:space="preserve">
          <source>A &quot;meta item&quot; is the syntax used for the &lt;em&gt;Attr&lt;/em&gt; rule by most &lt;a href=&quot;attributes#built-in-attributes-index&quot;&gt;built-in attributes&lt;/a&gt; and the &lt;a href=&quot;macros-by-example&quot;&gt;&lt;code&gt;meta&lt;/code&gt; macro fragment specifier&lt;/a&gt;. It has the following grammar:</source>
          <target state="translated">「メタアイテム」は、ほとんどの&lt;a href=&quot;attributes#built-in-attributes-index&quot;&gt;組み込み属性&lt;/a&gt;と&lt;a href=&quot;macros-by-example&quot;&gt; &lt;code&gt;meta&lt;/code&gt; &lt;/a&gt;によって&lt;em&gt;Attr&lt;/em&gt;ルールに使用される構文ですマクロフラグメント指定子です。次の文法があります。</target>
        </trans-unit>
        <trans-unit id="22d3a6ec1e16d0b77c16e420bbe8e26c33c2811f" translate="yes" xml:space="preserve">
          <source>A &quot;stack allocated string&quot;:</source>
          <target state="translated">スタック割り当て文字列」。</target>
        </trans-unit>
        <trans-unit id="b64a876ef415d016ec9dc92ffaf76e9ab89ca04f" translate="yes" xml:space="preserve">
          <source>A 'radix' here is sometimes also called a 'base'. A radix of two indicates a binary number, a radix of ten, decimal, and a radix of sixteen, hexadecimal, to give some common values. Arbitrary radices are supported.</source>
          <target state="translated">ここでの「基数」は「基数」と呼ばれることもあります。2の基数は2進数、10の基数は10進数、16の基数は16進数を示し、いくつかの共通の値を与えます。任意の基数をサポートしています。</target>
        </trans-unit>
        <trans-unit id="41c53bc2a64d3e62babdedd9c3047a7e08995ee3" translate="yes" xml:space="preserve">
          <source>A (half-open) range bounded inclusively below and exclusively above (&lt;code&gt;start..end&lt;/code&gt;).</source>
          <target state="translated">（半分開いた）範囲の上限と下限（上限は上限）（ &lt;code&gt;start..end&lt;/code&gt; ）上と下 start..end）。</target>
        </trans-unit>
        <trans-unit id="e85a39e82a0e6ccf8c895d65c91fa1d7ce99d7cb" translate="yes" xml:space="preserve">
          <source>A 32-bit floating point type (specifically, the &quot;binary32&quot; type defined in IEEE 754-2008).</source>
          <target state="translated">32ビット浮動小数点型(具体的にはIEEE 754-2008で定義されている &quot;binary32 &quot;型)。</target>
        </trans-unit>
        <trans-unit id="10239381d11a9cda1bbf8cfa43daeb6653a356ab" translate="yes" xml:space="preserve">
          <source>A 64-bit floating point type (specifically, the &quot;binary64&quot; type defined in IEEE 754-2008).</source>
          <target state="translated">64ビット浮動小数点型(具体的にはIEEE 754-2008で定義されている &quot;binary64 &quot;型)。</target>
        </trans-unit>
        <trans-unit id="3a791c9e3c1b8c3cb3ad7090a3f0956b3498d4ea" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#infinite-loops&quot;&gt;&lt;code&gt;loop&lt;/code&gt; expression&lt;/a&gt; denotes an infinite loop.</source>
          <target state="translated">&lt;a href=&quot;#infinite-loops&quot;&gt; &lt;code&gt;loop&lt;/code&gt; 式は、&lt;/a&gt;無限ループを示しています。</target>
        </trans-unit>
        <trans-unit id="c403143d347d88d290407287e086a1c24df257de" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#iterator-loops&quot;&gt;&lt;code&gt;for&lt;/code&gt; expression&lt;/a&gt; extracts values from an iterator, looping until the iterator is empty.</source>
          <target state="translated">A&lt;a href=&quot;#iterator-loops&quot;&gt; &lt;code&gt;for&lt;/code&gt; の発現&lt;/a&gt;イテレータから抽出値、イテレータが空になるまでループします。</target>
        </trans-unit>
        <trans-unit id="3523931588ba19ab3285934f4c9625ad5b0ff3e8" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#predicate-loops&quot;&gt;&lt;code&gt;while&lt;/code&gt; expression&lt;/a&gt; loops until a predicate is false.</source>
          <target state="translated">A&lt;a href=&quot;#predicate-loops&quot;&gt; &lt;code&gt;while&lt;/code&gt; 式は&lt;/a&gt;述語が偽になるまでループします。</target>
        </trans-unit>
        <trans-unit id="43257c2bbdee41f14d8f6aab49394bf581fd3e4e" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#predicate-pattern-loops&quot;&gt;&lt;code&gt;while let&lt;/code&gt; expression&lt;/a&gt; tests a pattern.</source>
          <target state="translated">&lt;a href=&quot;#predicate-pattern-loops&quot;&gt; &lt;code&gt;while let&lt;/code&gt; 式は&lt;/a&gt;パターンをテストします。</target>
        </trans-unit>
        <trans-unit id="c1847a494c164bc5812c67ca50bfe2768f6e254d" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../expressions/closure-expr&quot;&gt;closure expression&lt;/a&gt; produces a closure value with a unique, anonymous type that cannot be written out. A closure type is approximately equivalent to a struct which contains the captured variables. For instance, the following closure:</source>
          <target state="translated">あ &lt;a href=&quot;../expressions/closure-expr&quot;&gt;閉鎖式は&lt;/a&gt;書き出すことができないユニークな、匿名型と閉鎖値を生成します。クロージャ型は、キャプチャされた変数を含む構造体とほぼ同等です。たとえば、次のクロージャ：</target>
        </trans-unit>
        <trans-unit id="3cfb72d2748a10ee8855d86ad887d39ff3f43dfe" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../paths&quot;&gt;path&lt;/a&gt; used as an expression context denotes either a local variable or an item. Path expressions that resolve to local or static variables are &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place expressions&lt;/a&gt;, other paths are &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;value expressions&lt;/a&gt;. Using a &lt;a href=&quot;../items/static-items#mutable-statics&quot;&gt;&lt;code&gt;static mut&lt;/code&gt;&lt;/a&gt; variable requires an &lt;a href=&quot;block-expr#unsafe-blocks&quot;&gt;&lt;code&gt;unsafe&lt;/code&gt; block&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../paths&quot;&gt;パス&lt;/a&gt;式コンテキストとして使用されるローカル変数または項目のいずれかを意味します。ローカル変数または静的変数に解決されるパス式は&lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;場所式であり&lt;/a&gt;、他のパスは&lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;値式&lt;/a&gt;です。&lt;a href=&quot;../items/static-items#mutable-statics&quot;&gt; &lt;code&gt;static mut&lt;/code&gt; &lt;/a&gt;変数を使用すると、&lt;a href=&quot;block-expr#unsafe-blocks&quot;&gt; &lt;code&gt;unsafe&lt;/code&gt; ブロック&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="8c135626ccc454eee440ccf3a13f0ec15be919ba" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; is a &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode Scalar Value&lt;/a&gt;, which means that it is a &lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt;Code Point&lt;/a&gt;, but only ones within a certain range. &lt;code&gt;MAX&lt;/code&gt; is the highest valid code point that's a valid &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode Scalar Value&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; が&lt;/a&gt;ある&lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicodeのスカラー値&lt;/a&gt;があることを意味し、&lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt;コードポイント&lt;/a&gt;が、一定の範囲内で唯一のもの。 &lt;code&gt;MAX&lt;/code&gt; は有効な最高の有効なコードポイントです&lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt; Unicodeスカラー値で&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e348847ccb660c7b0b5c01ab1a1ba0e9112a0d13" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; is a &lt;a href=&quot;https://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode Scalar Value&lt;/a&gt;, which means that it is a &lt;a href=&quot;https://www.unicode.org/glossary/#code_point&quot;&gt;Code Point&lt;/a&gt;, but only ones within a certain range. &lt;code&gt;MAX&lt;/code&gt; is the highest valid code point that's a valid &lt;a href=&quot;https://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode Scalar Value&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc3502c112d8c240016de6db9fd46c1abe533f18" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; without structural pinning could &lt;code&gt;impl&amp;lt;T&amp;gt; Unpin for Vec&amp;lt;T&amp;gt;&lt;/code&gt;, because the contents are never pinned and the &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; itself is fine with being moved as well. At that point pinning just has no effect on the vector at all.</source>
          <target state="translated">A &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;構造ピンニング無し可能性 &lt;code&gt;impl&amp;lt;T&amp;gt; Unpin for Vec&amp;lt;T&amp;gt;&lt;/code&gt; 、内容が固定、決してされているので&lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;それ自体がよくとして移動されると結構です。その時点で、ピン留めはベクトルにまったく影響を与えません。</target>
        </trans-unit>
        <trans-unit id="3bd0f4f45a9992b5e83d00a801ad1d124dd353bf" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;enum.searchstep#variant.Match&quot;&gt;&lt;code&gt;Match&lt;/code&gt;&lt;/a&gt; result needs to contain the whole matched pattern, however &lt;a href=&quot;enum.searchstep#variant.Reject&quot;&gt;&lt;code&gt;Reject&lt;/code&gt;&lt;/a&gt; results may be split up into arbitrary many adjacent fragments. Both ranges may have zero length.</source>
          <target state="translated">A&lt;a href=&quot;enum.searchstep#variant.Match&quot;&gt; &lt;code&gt;Match&lt;/code&gt; &lt;/a&gt;の結果は、しかし、全体マッチしたパターンが含まれている必要が&lt;a href=&quot;enum.searchstep#variant.Reject&quot;&gt; &lt;code&gt;Reject&lt;/code&gt; &lt;/a&gt;の結果は、任意の多くの隣接する断片に分割することができます。両方の範囲の長さがゼロの場合があります。</target>
        </trans-unit>
        <trans-unit id="817aefb1123a860203996fe1bc087199cf9a9301" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;fn.null&quot;&gt;null&lt;/a&gt; pointer is &lt;em&gt;never&lt;/em&gt; valid, not even for accesses of &lt;a href=&quot;https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts&quot;&gt;size zero&lt;/a&gt;.</source>
          <target state="translated">のアクセスであっても、&lt;a href=&quot;fn.null&quot;&gt;null&lt;/a&gt;ポインタは&lt;em&gt;決して&lt;/em&gt;有効ではありません&lt;a href=&quot;https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts&quot;&gt;サイズのゼロ&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="64470c49d997c71e612fbbb1108517461ba5028e" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;items/associated-items#methods&quot;&gt;method&lt;/a&gt; defined in an &lt;a href=&quot;items/implementations#inherent-implementations&quot;&gt;inherent implementation&lt;/a&gt;, not in a trait implementation.</source>
          <target state="translated">で定義された&lt;a href=&quot;items/associated-items#methods&quot;&gt;メソッド&lt;/a&gt;&lt;a href=&quot;items/implementations#inherent-implementations&quot;&gt;固有の実装&lt;/a&gt;ない形質実装では、。</target>
        </trans-unit>
        <trans-unit id="2929c70726dc937049a9f5950f13c4723ad1c193" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;loop-expr#infinite-loops&quot;&gt;&lt;code&gt;loop&lt;/code&gt; expression&lt;/a&gt; denotes an infinite loop.</source>
          <target state="translated">&lt;a href=&quot;loop-expr#infinite-loops&quot;&gt; &lt;code&gt;loop&lt;/code&gt; 表現&lt;/a&gt;無限ループを示しています。</target>
        </trans-unit>
        <trans-unit id="e86e93a58bbbbc71c44b9b885a659ff826ce9490" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;loop-expr#iterator-loops&quot;&gt;&lt;code&gt;for&lt;/code&gt; expression&lt;/a&gt; extracts values from an iterator, looping until the iterator is empty.</source>
          <target state="translated">A &lt;a href=&quot;loop-expr#iterator-loops&quot;&gt; &lt;code&gt;for&lt;/code&gt; の発現&lt;/a&gt;イテレータから抽出値、イテレータが空になるまでループします。</target>
        </trans-unit>
        <trans-unit id="78d2df8a50ce969bca66a5211eeeb6570b3f1784" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;loop-expr#predicate-loops&quot;&gt;&lt;code&gt;while&lt;/code&gt; expression&lt;/a&gt; loops until a predicate is false.</source>
          <target state="translated">A &lt;a href=&quot;loop-expr#predicate-loops&quot;&gt; &lt;code&gt;while&lt;/code&gt; 式は&lt;/a&gt;述語が偽になるまでループします。</target>
        </trans-unit>
        <trans-unit id="506fd8c66fe2c3330ab3ababc69a27680d58db08" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;loop-expr#predicate-pattern-loops&quot;&gt;&lt;code&gt;while let&lt;/code&gt; expression&lt;/a&gt; tests a pattern.</source>
          <target state="translated">&lt;a href=&quot;loop-expr#predicate-pattern-loops&quot;&gt; &lt;code&gt;while let&lt;/code&gt; 式は&lt;/a&gt;パターンをテストします。</target>
        </trans-unit>
        <trans-unit id="33cacd9cafdfaf3ef4cf01b5b7dfb994c4cd9727" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;patterns#struct-patterns&quot;&gt;struct&lt;/a&gt;, &lt;a href=&quot;patterns#tuple-patterns&quot;&gt;tuple&lt;/a&gt;, &lt;a href=&quot;patterns#tuple-struct-patterns&quot;&gt;tuple struct&lt;/a&gt;, or &lt;a href=&quot;patterns#slice-patterns&quot;&gt;slice&lt;/a&gt; pattern where at least one of the direct subpatterns is a extending pattern.</source>
          <target state="translated">&lt;a href=&quot;patterns#struct-patterns&quot;&gt;構造体&lt;/a&gt;、&lt;a href=&quot;patterns#tuple-patterns&quot;&gt;タプル&lt;/a&gt;、&lt;a href=&quot;patterns#tuple-struct-patterns&quot;&gt;タプル構造体&lt;/a&gt;、または&lt;a href=&quot;patterns#slice-patterns&quot;&gt;スライス&lt;/a&gt;直接サブパターンの少なくとも一つのパターンが延在するパターンです。</target>
        </trans-unit>
        <trans-unit id="8b1f2559cf32a60aeffbe295d8dcc8b7d2d1bc74" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt; might contain non-Unicode data. This &lt;code&gt;struct&lt;/code&gt; implements the &lt;a href=&quot;../fmt/trait.display&quot;&gt;&lt;code&gt;Display&lt;/code&gt;&lt;/a&gt; trait in a way that mitigates that. It is created by the &lt;a href=&quot;struct.path#method.display&quot;&gt;&lt;code&gt;display&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt;非Unicodeデータが含まれる可能性があります。この &lt;code&gt;struct&lt;/code&gt; は、それを軽減する方法で&lt;a href=&quot;../fmt/trait.display&quot;&gt; &lt;code&gt;Display&lt;/code&gt; &lt;/a&gt;トレイトを実装します。&lt;a href=&quot;struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt;の&lt;a href=&quot;struct.path#method.display&quot;&gt; &lt;code&gt;display&lt;/code&gt; &lt;/a&gt;メソッドで作成されます。</target>
        </trans-unit>
        <trans-unit id="8ad6cb9fb2de3ff94c9692c27c57c7195ec6d6cb" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt;&lt;/a&gt; ensures that the pointee of any pointer type &lt;code&gt;P&lt;/code&gt; has a stable location in memory, meaning it cannot be moved elsewhere and its memory cannot be deallocated until it gets dropped. We say that the pointee is &quot;pinned&quot;.</source>
          <target state="translated">A &lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; &lt;/a&gt;確実に任意のポインタ型のポインタの指示 &lt;code&gt;P&lt;/code&gt; は、それが他の場所に移動させることができず、それがドロップされるまで、そのメモリを割り当て解除することができない意味、メモリ内の安定した位置を有しています。指示先は「固定」されていると言います。</target>
        </trans-unit>
        <trans-unit id="a15e8cc8aa6158fcb3389cfdaf6e7e84bacae80c" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;struct.sender&quot;&gt;&lt;code&gt;Sender&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.syncsender&quot;&gt;&lt;code&gt;SyncSender&lt;/code&gt;&lt;/a&gt; is used to send data to a &lt;a href=&quot;struct.receiver&quot;&gt;&lt;code&gt;Receiver&lt;/code&gt;&lt;/a&gt;. Both senders are clone-able (multi-producer) such that many threads can send simultaneously to one receiver (single-consumer).</source>
          <target state="translated">&lt;a href=&quot;struct.sender&quot;&gt; &lt;code&gt;Sender&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;struct.syncsender&quot;&gt; &lt;code&gt;SyncSender&lt;/code&gt; は&lt;/a&gt;にデータを送信するために使用される&lt;a href=&quot;struct.receiver&quot;&gt; &lt;code&gt;Receiver&lt;/code&gt; &lt;/a&gt;。両方の送信者は、多くのスレッドが1つの受信者（単一の消費者）に同時に送信できるように、クローン可能（マルチプロデューサー）です。</target>
        </trans-unit>
        <trans-unit id="e878b6c48911644ea2ee908e204d14d9ba8414f3" translate="yes" xml:space="preserve">
          <source>A &lt;code id=&quot;a-worker-struct-responsible-for-sending-code-from-the-threadpool-to-a-thread&quot;&gt;Worker&lt;/code&gt; Struct Responsible for Sending Code from the &lt;code&gt;ThreadPool&lt;/code&gt; to a Thread</source>
          <target state="translated">&lt;code&gt;ThreadPool&lt;/code&gt; からコードを送信する &lt;code id=&quot;a-worker-struct-responsible-for-sending-code-from-the-threadpool-to-a-thread&quot;&gt;Worker&lt;/code&gt; 構造体からスレッドへの</target>
        </trans-unit>
        <trans-unit id="f340f8a1c0de4fb7863ae5c6dacd93b470ac42d8" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;!&lt;/code&gt; (all values are invalid for this type).</source>
          <target state="translated">A &lt;code&gt;!&lt;/code&gt; （このタイプではすべての値が無効です）。</target>
        </trans-unit>
        <trans-unit id="cb1329292e0705741bc6efb49bebc4980736dafb" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;#![feature]&lt;/code&gt; attribute was declared for a feature that is stable in the current edition, but not in all editions.</source>
          <target state="translated">&lt;code&gt;#![feature]&lt;/code&gt; 属性は、現在の版ではなく、すべてのエディションで安定している機能のために宣言されました。</target>
        </trans-unit>
        <trans-unit id="aaa8a708af81269c0b5576d02729333db199fa1d" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;#![feature]&lt;/code&gt; attribute was declared multiple times.</source>
          <target state="translated">&lt;code&gt;#![feature]&lt;/code&gt; 属性が複数回宣言されました。</target>
        </trans-unit>
        <trans-unit id="871ef5c0f72000286445ffa6aeaeb13201eef94a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;#[lang = &quot;..&quot;]&lt;/code&gt; attribute was placed on the wrong item type.</source>
          <target state="translated">&lt;code&gt;#[lang = &quot;..&quot;]&lt;/code&gt; 属性が間違った項目の種類に置かれました。</target>
        </trans-unit>
        <trans-unit id="12a617fa960129a71a59055ffc0553333e4d1938" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;#[marker]&lt;/code&gt; trait contained an associated item.</source>
          <target state="translated">&lt;code&gt;#[marker]&lt;/code&gt; 形質は、関連するアイテムを含んでいました。</target>
        </trans-unit>
        <trans-unit id="9dfceb8cd31c1c51915cc559ef8cce0d369c7062" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;#[repr(..)]&lt;/code&gt; attribute was placed on an unsupported item.</source>
          <target state="translated">&lt;code&gt;#[repr(..)]&lt;/code&gt; 属性は、サポートされていないアイテムの上に置きました。</target>
        </trans-unit>
        <trans-unit id="0a9d6b916ce0da508f854e05a1feec7e0befaef9" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;#[repr(inttype)]&lt;/code&gt; must be provided on an &lt;code&gt;enum&lt;/code&gt; if it has a non-unit variant with a discriminant, or where there are both unit variants with discriminants and non-unit variants. This restriction ensures that there is a well-defined way to extract a variant's discriminant from a value; for instance:</source>
          <target state="translated">&lt;code&gt;#[repr(inttype)]&lt;/code&gt; 上に提供されなければならない &lt;code&gt;enum&lt;/code&gt; が判別非ユニットの変異体を有する場合、または両方のユニットは、判別式と非ユニット変異を有する変異体があります。この制限により、値からバリアントの判別式を抽出する明確に定義された方法があることが保証されます。例えば：</target>
        </trans-unit>
        <trans-unit id="b12f48dd90abc9841d426a5fab9c2ec4ff61214a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;#[simd]&lt;/code&gt; attribute was applied to an empty tuple struct.</source>
          <target state="translated">&lt;code&gt;#[simd]&lt;/code&gt; 属性が空のタプル構造体に適用しました。</target>
        </trans-unit>
        <trans-unit id="c012898141fc2cec018c7c222ae43346e5dd5f44" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&amp;amp;T&lt;/code&gt; reference can be released to safe code and there it can co-exist with other &lt;code&gt;&amp;amp;T&lt;/code&gt; references, but not with a &lt;code&gt;&amp;amp;mut T&lt;/code&gt;</source>
          <target state="translated">A &lt;code&gt;&amp;amp;T&lt;/code&gt; の参照は、安全なコードに解放することができ、それはそこに共存することができ、他のと &lt;code&gt;&amp;amp;T&lt;/code&gt; ではないと、リファレンス &lt;code&gt;&amp;amp;mut T&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3ec5710ef1f0b84eb29b3c1cc1f924e822fb56fa" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&amp;amp;mut T&lt;/code&gt; reference may be released to safe code provided neither other &lt;code&gt;&amp;amp;mut T&lt;/code&gt; nor &lt;code&gt;&amp;amp;T&lt;/code&gt; co-exist with it. A &lt;code&gt;&amp;amp;mut T&lt;/code&gt; must always be unique.</source>
          <target state="translated">A &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 参照はいずれも、他の提供安全コードを解放することができる &lt;code&gt;&amp;amp;mut T&lt;/code&gt; も &lt;code&gt;&amp;amp;T&lt;/code&gt; はそれと共存。A &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 常に一意である必要があります。</target>
        </trans-unit>
        <trans-unit id="40585fc29df20c1219babfcdddcfc95974719e32" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&amp;amp;str&lt;/code&gt; is made up of two components: a pointer to some bytes, and a length. You can look at these with the &lt;a href=&quot;#method.as_ptr&quot;&gt;&lt;code&gt;as_ptr&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; methods:</source>
          <target state="translated">A &lt;code&gt;&amp;amp;str&lt;/code&gt; いくつかのバイトへのポインタ、および長さの2つのコンポーネントで構成されています。これらは、&lt;a href=&quot;#method.as_ptr&quot;&gt; &lt;code&gt;as_ptr&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;#method.len&quot;&gt; &lt;code&gt;len&lt;/code&gt; &lt;/a&gt;メソッドで確認できます。</target>
        </trans-unit>
        <trans-unit id="96eae277d841da5acce951109ccad7e43958c9c5" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&amp;amp;str&lt;/code&gt; is made up of two components: a pointer to some bytes, and a length. You can look at these with the &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html#method.as_ptr&quot;&gt;&lt;code&gt;as_ptr&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; methods:</source>
          <target state="translated">A &lt;code&gt;&amp;amp;str&lt;/code&gt; 一部バイトへのポインタ、および長さ：二つの成分で構成されています。&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html#method.as_ptr&quot;&gt; &lt;code&gt;as_ptr&lt;/code&gt; &lt;/a&gt;メソッドと&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html#method.len&quot;&gt; &lt;code&gt;len&lt;/code&gt; &lt;/a&gt;メソッドを使用してこれらを確認できます。</target>
        </trans-unit>
        <trans-unit id="d26915dade1d3ce3c223fcfcc944e12fb9d06d42" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;BarrierWaitResult&lt;/code&gt; is returned by &lt;a href=&quot;struct.barrier#method.wait&quot;&gt;&lt;code&gt;Barrier::wait()&lt;/code&gt;&lt;/a&gt; when all threads in the &lt;a href=&quot;struct.barrier&quot;&gt;&lt;code&gt;Barrier&lt;/code&gt;&lt;/a&gt; have rendezvoused.</source>
          <target state="translated">A &lt;code&gt;BarrierWaitResult&lt;/code&gt; がで返される&lt;a href=&quot;struct.barrier#method.wait&quot;&gt; &lt;code&gt;Barrier::wait()&lt;/code&gt; &lt;/a&gt;内のすべてのスレッドとき&lt;a href=&quot;struct.barrier&quot;&gt; &lt;code&gt;Barrier&lt;/code&gt; &lt;/a&gt;ランデブーしています。</target>
        </trans-unit>
        <trans-unit id="35fb8d8640dfbea523c47310a34e3d854229d236" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;BarrierWaitResult&lt;/code&gt; is returned by &lt;a href=&quot;struct.barrier#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; when all threads in the &lt;a href=&quot;struct.barrier&quot;&gt;&lt;code&gt;Barrier&lt;/code&gt;&lt;/a&gt; have rendezvoused.</source>
          <target state="translated">A &lt;code&gt;BarrierWaitResult&lt;/code&gt; がで返され&lt;a href=&quot;struct.barrier#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;中のすべてのスレッド時に&lt;a href=&quot;struct.barrier&quot;&gt; &lt;code&gt;Barrier&lt;/code&gt; &lt;/a&gt;ランデブーしています。</target>
        </trans-unit>
        <trans-unit id="a33fe1ab5786729bf200982553a4a40b28677c12" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;BufRead&lt;/code&gt; is a type of &lt;code&gt;Read&lt;/code&gt;er which has an internal buffer, allowing it to perform extra ways of reading.</source>
          <target state="translated">A &lt;code&gt;BufRead&lt;/code&gt; はのタイプで &lt;code&gt;Read&lt;/code&gt; 、それが読書の余分な方法を実行することができ、内部バッファを持っている小胞体。</target>
        </trans-unit>
        <trans-unit id="c2a7d564e1881467808b1da26fc7f621d550ac35" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;BuildHasher&lt;/code&gt; is typically used (e.g., by &lt;a href=&quot;../collections/struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;) to create &lt;a href=&quot;trait.hasher&quot;&gt;&lt;code&gt;Hasher&lt;/code&gt;&lt;/a&gt;s for each key such that they are hashed independently of one another, since &lt;a href=&quot;trait.hasher&quot;&gt;&lt;code&gt;Hasher&lt;/code&gt;&lt;/a&gt;s contain state.</source>
          <target state="translated">A &lt;code&gt;BuildHasher&lt;/code&gt; は、典型的に（により、例えば、使用される&lt;a href=&quot;../collections/struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;作成する）&lt;a href=&quot;trait.hasher&quot;&gt; &lt;code&gt;Hasher&lt;/code&gt; &lt;/a&gt;それらがので、互いに独立してハッシュされること、各キーようなに対するSを&lt;a href=&quot;trait.hasher&quot;&gt; &lt;code&gt;Hasher&lt;/code&gt; &lt;/a&gt;の状態を含みます。</target>
        </trans-unit>
        <trans-unit id="5ac6d9ca4b25b818aa6f9cb17715ea50c25bf2ef" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;CString&lt;/code&gt; is created from either a byte slice or a byte vector, or anything that implements &lt;a href=&quot;../convert/trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; (for example, you can build a &lt;code&gt;CString&lt;/code&gt; straight out of a &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;, since both implement that trait).</source>
          <target state="translated">A &lt;code&gt;CString&lt;/code&gt; バイトのスライスやバイトベクタ、または何かのいずれかから作成された道具&lt;a href=&quot;../convert/trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; と&lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; （たとえば、あなたが構築できる &lt;code&gt;CString&lt;/code&gt; まっすぐの&lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; の&lt;/a&gt;両方その形質を実装しているので、）。</target>
        </trans-unit>
        <trans-unit id="a976b86b7133ebd168dd44069ca430099fb11fcd" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;CString&lt;/code&gt; is created from either a byte slice or a byte vector, or anything that implements &lt;a href=&quot;../convert/trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; (for example, you can build a &lt;code&gt;CString&lt;/code&gt; straight out of a &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;, since both implement that trait).</source>
          <target state="translated">A &lt;code&gt;CString&lt;/code&gt; バイトのスライスやバイトベクタ、または何かのいずれかから作成された道具&lt;a href=&quot;../convert/trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; と&lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; （たとえば、あなたが構築できる &lt;code&gt;CString&lt;/code&gt; まっすぐの&lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; の&lt;/a&gt;両方その形質を実装しているので、）。</target>
        </trans-unit>
        <trans-unit id="bef22157720da42f049eda44831ae9039ff96672" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Component&lt;/code&gt; roughly corresponds to a substring between path separators (&lt;code&gt;/&lt;/code&gt; or ).</source>
          <target state="translated">A &lt;code&gt;Component&lt;/code&gt; おおよそパスセパレータ（間のサブストリングに相当 &lt;code&gt;/&lt;/code&gt; 又は）。</target>
        </trans-unit>
        <trans-unit id="00d5a6a3fb8d035432bd26a66264da1cd9fcfcb1" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Component&lt;/code&gt; roughly corresponds to a substring between path separators (&lt;code&gt;/&lt;/code&gt; or &lt;code&gt;\&lt;/code&gt;).</source>
          <target state="translated">A &lt;code&gt;Component&lt;/code&gt; 略パスセパレータとの間のサブストリングに対応する（ &lt;code&gt;/&lt;/code&gt; または &lt;code&gt;\&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f8dc93d165313d1d53fe035b20236e511c258009" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Cursor&lt;/code&gt; is like an iterator, except that it can freely seek back-and-forth, and can safely mutate the list during iteration. This is because the lifetime of its yielded references is tied to its own lifetime, instead of just the underlying list. This means cursors cannot yield multiple elements at once.</source>
          <target state="translated">A &lt;code&gt;Cursor&lt;/code&gt; それが自由に前後求めることができ、かつ安全に反復中にリストを変異させることができますことを除いて、イテレータのようなものです。これは、生成された参照の有効期間が、基になるリストだけでなく、それ自体の有効期間に関連付けられているためです。これは、カーソルが一度に複数の要素を生成できないことを意味します。</target>
        </trans-unit>
        <trans-unit id="d1edbc893c845d675ae565c5adc4b48af73fbd0b" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Cursor&lt;/code&gt; is like an iterator, except that it can freely seek back-and-forth.</source>
          <target state="translated">A &lt;code&gt;Cursor&lt;/code&gt; それが自由に前後求めることができますことを除いて、イテレータのようなものです。</target>
        </trans-unit>
        <trans-unit id="592f6bf36d948cda2dbd34364696113591fa1887" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Cursor&lt;/code&gt; wraps an in-memory buffer and provides it with a &lt;a href=&quot;trait.seek&quot;&gt;&lt;code&gt;Seek&lt;/code&gt;&lt;/a&gt; implementation.</source>
          <target state="translated">A &lt;code&gt;Cursor&lt;/code&gt; インメモリバッファをラップし、それを提供する&lt;a href=&quot;trait.seek&quot;&gt; &lt;code&gt;Seek&lt;/code&gt; &lt;/a&gt;実装。</target>
        </trans-unit>
        <trans-unit id="a89cb140638fa3cd771cb02496374d776ad6d007" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Duration&lt;/code&gt; type to represent a span of time, typically used for system timeouts.</source>
          <target state="translated">&lt;code&gt;Duration&lt;/code&gt; タイプは、典型的には、システム・タイムアウトのために使用される時間のスパンを表現します。</target>
        </trans-unit>
        <trans-unit id="e39d340a59cb5b2bb2e11548f7d50ffd50cdcaa5" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Formatter&lt;/code&gt; represents various options related to formatting. Users do not construct &lt;code&gt;Formatter&lt;/code&gt;s directly; a mutable reference to one is passed to the &lt;code&gt;fmt&lt;/code&gt; method of all formatting traits, like &lt;a href=&quot;trait.debug&quot;&gt;&lt;code&gt;Debug&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.display&quot;&gt;&lt;code&gt;Display&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">A &lt;code&gt;Formatter&lt;/code&gt; 、フォーマットに関連するさまざまなオプションを表します。ユーザーは &lt;code&gt;Formatter&lt;/code&gt; を直接作成しません。1つへの変更可能な参照は、&lt;a href=&quot;trait.debug&quot;&gt; &lt;code&gt;Debug&lt;/code&gt; &lt;/a&gt;や&lt;a href=&quot;trait.display&quot;&gt; &lt;code&gt;Display&lt;/code&gt; &lt;/a&gt;などのすべてのフォーマット特性の &lt;code&gt;fmt&lt;/code&gt; メソッドに渡されます。</target>
        </trans-unit>
        <trans-unit id="921821ce37ee7be55d1f4cd9ec14a09989a7422f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;HashMap&lt;/code&gt; with fixed list of elements can be initialized from an array:</source>
          <target state="translated">要素の固定リストを持つ &lt;code&gt;HashMap&lt;/code&gt; は、配列から初期化できます。</target>
        </trans-unit>
        <trans-unit id="9e3e7578434780dbd4d9d999f38a9955ea8f8204" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;HashSet&lt;/code&gt; with fixed list of elements can be initialized from an array:</source>
          <target state="translated">要素の固定リストを持つ &lt;code&gt;HashSet&lt;/code&gt; は、配列から初期化できます。</target>
        </trans-unit>
        <trans-unit id="9b7c01af6b5011fee801753cdfcb67030ddd18ba" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;JoinHandle&lt;/code&gt;&lt;em&gt;detaches&lt;/em&gt; the associated thread when it is dropped, which means that there is no longer any handle to thread and no way to &lt;code&gt;join&lt;/code&gt; on it.</source>
          <target state="translated">あ &lt;code&gt;JoinHandle&lt;/code&gt; は&lt;em&gt;切り離し&lt;/em&gt;、もはやスレッドに任意のハンドルとする方法はありませんがあることを、どの手段を落としていない場合に、関連するスレッドを &lt;code&gt;join&lt;/code&gt; ことにします。</target>
        </trans-unit>
        <trans-unit id="134a2452be93d4c2cdb1b9f1f0542b4b65ecae3d" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;LocalKey&lt;/code&gt;'s initializer cannot recursively depend on itself, and using a &lt;code&gt;LocalKey&lt;/code&gt; in this way will cause the initializer to infinitely recurse on the first call to &lt;code&gt;with&lt;/code&gt;.</source>
          <target state="translated">A &lt;code&gt;LocalKey&lt;/code&gt; の初期化子は、再帰的に自分自身に依存することはできませんし、使用して &lt;code&gt;LocalKey&lt;/code&gt; をこのようにすることへの最初の呼び出しに無限再帰に初期化子が発生します &lt;code&gt;with&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c72c40c2b2da09870992c3f25ebf2fd884c3cef5" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Match&lt;/code&gt; result needs to contain the whole matched pattern, however &lt;code&gt;Reject&lt;/code&gt; results may be split up into arbitrary many adjacent fragments. Both ranges may have zero length.</source>
          <target state="translated">あ &lt;code&gt;Match&lt;/code&gt; の結果は、しかし、全体マッチしたパターンが含まれている必要が &lt;code&gt;Reject&lt;/code&gt; の結果は、任意の多くの隣接する断片に分割することができます。両方の範囲の長さがゼロの場合があります。</target>
        </trans-unit>
        <trans-unit id="14d52da7769e774ed02f1e53e420687489f136bc" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Pattern&amp;lt;'a&amp;gt;&lt;/code&gt; expresses that the implementing type can be used as a string pattern for searching in a &lt;a href=&quot;../../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;'a str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Pattern&amp;lt;'a&amp;gt;&lt;/code&gt; 実装タイプがで検索するための文字列パターンとして使用することができることを表して&lt;a href=&quot;../../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;'a str&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5668f2d21fa477474ed4b8f6c89c068e50ff97ac" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Pattern&amp;lt;'a&amp;gt;&lt;/code&gt; expresses that the implementing type can be used as a string pattern for searching in a &lt;code&gt;&amp;amp;'a str&lt;/code&gt;.</source>
          <target state="translated">あ &lt;code&gt;Pattern&amp;lt;'a&amp;gt;&lt;/code&gt; 実装タイプがで検索するための文字列パターンとして使用することができることを表して &lt;code&gt;&amp;amp;'a str&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb85096bf6f841f9bc42b20ab21fbdaddee5e86c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;RawWaker&lt;/code&gt; allows the implementor of a task executor to create a &lt;a href=&quot;struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt; which provides customized wakeup behavior.</source>
          <target state="translated">A &lt;code&gt;RawWaker&lt;/code&gt; タスクエグゼキュータの実装を作成することができ&lt;a href=&quot;struct.waker&quot;&gt; &lt;code&gt;Waker&lt;/code&gt; &lt;/a&gt;カスタマイズウェークアップ動作を提供します。</target>
        </trans-unit>
        <trans-unit id="1193137c297d5cbd26cbbc2bf90d52838e50813a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;String&lt;/code&gt; can grow in size and its contents can change, just like the contents of a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, if you push more data into it. In addition, you can conveniently use the &lt;code&gt;+&lt;/code&gt; operator or the &lt;code&gt;format!&lt;/code&gt; macro to concatenate &lt;code&gt;String&lt;/code&gt; values.</source>
          <target state="translated">A &lt;code&gt;String&lt;/code&gt; だけの内容のように、大きさに成長することができ、その内容を変更することができます &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 、あなたがより多くのデータをプッシュする場合は、それに。さらに、 &lt;code&gt;+&lt;/code&gt; 演算子または &lt;code&gt;format!&lt;/code&gt; &lt;code&gt;String&lt;/code&gt; 値を連結するマクロ。</target>
        </trans-unit>
        <trans-unit id="ad2a4c35b866459c9366f5bbd3c6f621ece58985" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;String&lt;/code&gt; is a wrapper over a &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt;. Let&amp;rsquo;s look at some of our properly encoded UTF-8 example strings from Listing 8-14. First, this one:</source>
          <target state="translated">あ &lt;code&gt;String&lt;/code&gt; のラッパーである &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; 。リスト8-14の適切にエンコードされたUTF-8サンプル文字列のいくつかを見てみましょう。まず、これ：</target>
        </trans-unit>
        <trans-unit id="dcd60f52764dfb12603585382f304c29b3d891eb" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;String&lt;/code&gt; is made up of three components: a pointer to some bytes, a length, and a capacity. The pointer points to an internal buffer &lt;code&gt;String&lt;/code&gt; uses to store its data. The length is the number of bytes currently stored in the buffer, and the capacity is the size of the buffer in bytes. As such, the length will always be less than or equal to the capacity.</source>
          <target state="translated">A &lt;code&gt;String&lt;/code&gt; いくつかのバイトへのポインタ、長さ、及び容量：3つのコンポーネントで構成されています。ポインタは、 &lt;code&gt;String&lt;/code&gt; がデータを格納するために使用する内部バッファを指します。長さは現在バッファに格納されているバイト数であり、容量はバイト単位のバッファのサイズです。そのため、長さは常に容量以下になります。</target>
        </trans-unit>
        <trans-unit id="2ad19c9717a97c44c08a93976b602e0990d24669" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;SystemTimeError&lt;/code&gt; is returned from the &lt;a href=&quot;struct.systemtime#method.duration_since&quot;&gt;&lt;code&gt;SystemTime::duration_since&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.systemtime#method.elapsed&quot;&gt;&lt;code&gt;SystemTime::elapsed&lt;/code&gt;&lt;/a&gt; methods whenever the second system time represents a point later in time than the &lt;code&gt;self&lt;/code&gt; of the method call.</source>
          <target state="translated">A &lt;code&gt;SystemTimeError&lt;/code&gt; がから返され&lt;a href=&quot;struct.systemtime#method.duration_since&quot;&gt; &lt;code&gt;SystemTime::duration_since&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;struct.systemtime#method.elapsed&quot;&gt; &lt;code&gt;SystemTime::elapsed&lt;/code&gt; &lt;/a&gt;方法たびに第2のシステム時間は、後の時間よりも点を表す &lt;code&gt;self&lt;/code&gt; メソッド呼び出しの。</target>
        </trans-unit>
        <trans-unit id="2815fef167ebe8b526c9b5e3287501b1039ea114" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;SystemTimeError&lt;/code&gt; is returned from the &lt;a href=&quot;struct.systemtime#method.duration_since&quot;&gt;&lt;code&gt;duration_since&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.systemtime#method.elapsed&quot;&gt;&lt;code&gt;elapsed&lt;/code&gt;&lt;/a&gt; methods of &lt;a href=&quot;struct.systemtime&quot;&gt;&lt;code&gt;SystemTime&lt;/code&gt;&lt;/a&gt; whenever the second system time represents a point later in time than the &lt;code&gt;self&lt;/code&gt; of the method call.</source>
          <target state="translated">A &lt;code&gt;SystemTimeError&lt;/code&gt; がから返され&lt;a href=&quot;struct.systemtime#method.duration_since&quot;&gt; &lt;code&gt;duration_since&lt;/code&gt; &lt;/a&gt;及び&lt;a href=&quot;struct.systemtime#method.elapsed&quot;&gt; &lt;code&gt;elapsed&lt;/code&gt; &lt;/a&gt;の方法&lt;a href=&quot;struct.systemtime&quot;&gt; &lt;code&gt;SystemTime&lt;/code&gt; &lt;/a&gt;第2のシステム時間よりも時間的に後の時点を表すときはいつでも &lt;code&gt;self&lt;/code&gt; メソッド呼び出しのを。</target>
        </trans-unit>
        <trans-unit id="f0e9bc60c4e3276e60ae09f7f961f64e01c5bfbd" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;ThreadId&lt;/code&gt; is an opaque object that has a unique value for each thread that creates one. &lt;code&gt;ThreadId&lt;/code&gt;s are not guaranteed to correspond to a thread's system-designated identifier. A &lt;code&gt;ThreadId&lt;/code&gt; can be retrieved from the &lt;a href=&quot;struct.thread#method.id&quot;&gt;&lt;code&gt;id&lt;/code&gt;&lt;/a&gt; method on a &lt;a href=&quot;struct.thread&quot;&gt;&lt;code&gt;Thread&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">A &lt;code&gt;ThreadId&lt;/code&gt; いずれかを作成するスレッドごとに一意の値を有する不透明なオブジェクトです。 &lt;code&gt;ThreadId&lt;/code&gt; は、スレッドのシステム指定の識別子に対応しているとは限りません。A &lt;code&gt;ThreadId&lt;/code&gt; から取得でき&lt;a href=&quot;struct.thread#method.id&quot;&gt; &lt;code&gt;id&lt;/code&gt; &lt;/a&gt; Aのメソッド&lt;a href=&quot;struct.thread&quot;&gt; &lt;code&gt;Thread&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b1818d010b7b29b87c4502d46870a6345ca3ee68" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;TypeId&lt;/code&gt; is currently only available for types which ascribe to &lt;code&gt;'static&lt;/code&gt;, but this limitation may be removed in the future.</source>
          <target state="translated">A &lt;code&gt;TypeId&lt;/code&gt; 現在のどの帰タイプに対してのみ利用可能である &lt;code&gt;'static&lt;/code&gt; が、この制限は、将来的に除去することができます。</target>
        </trans-unit>
        <trans-unit id="5b2832f9ef1617c1a164688031f12174b8e5931d" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;TypeId&lt;/code&gt; represents a globally unique identifier for a type.</source>
          <target state="translated">あ &lt;code&gt;TypeId&lt;/code&gt; タイプのグローバル一意識別子を表します。</target>
        </trans-unit>
        <trans-unit id="05e63a516d556e9577522a23860139fad9899875" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Vec&lt;/code&gt; can be mutable. Slices, on the other hand, are read-only objects. To get a &lt;a href=&quot;../primitive.slice&quot;&gt;slice&lt;/a&gt;, use &lt;a href=&quot;../primitive.reference&quot;&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/a&gt;. Example:</source>
          <target state="translated">A &lt;code&gt;Vec&lt;/code&gt; とは、可変することができます。一方、スライスは読み取り専用オブジェクトです。&lt;a href=&quot;../primitive.slice&quot;&gt;スライス&lt;/a&gt;を取得するには、&lt;a href=&quot;../primitive.reference&quot;&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; を&lt;/a&gt;使用します。例：</target>
        </trans-unit>
        <trans-unit id="345e82ed2183b66aaf325e8ad24887f5dd3ff3ad" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Vec&lt;/code&gt; can be mutable. Slices, on the other hand, are read-only objects. To get a slice, use &lt;code&gt;&amp;amp;&lt;/code&gt;. Example:</source>
          <target state="translated">A &lt;code&gt;Vec&lt;/code&gt; とは、可変することができます。一方、スライスは読み取り専用オブジェクトです。スライスを取得するには、 &lt;code&gt;&amp;amp;&lt;/code&gt; を。例：</target>
        </trans-unit>
        <trans-unit id="84a3e0757f03c2cf35d8f4ee02786937e5e0845a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Waker&lt;/code&gt; is a handle for waking up a task by notifying its executor that it is ready to be run.</source>
          <target state="translated">あ &lt;code&gt;Waker&lt;/code&gt; 実行される準備ができていること、その実行者に通知することによって、タスクを起床のハンドルです。</target>
        </trans-unit>
        <trans-unit id="d9bc289fc584bbfaef86d0de4ba94863300845d3" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Weak&lt;/code&gt; pointer is useful for keeping a temporary reference to the allocation managed by &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; without preventing its inner value from being dropped. It is also used to prevent circular references between &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; pointers, since mutual owning references would never allow either &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; to be dropped. For example, a tree could have strong &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; pointers from parent nodes to children, and &lt;code&gt;Weak&lt;/code&gt; pointers from children back to their parents.</source>
          <target state="translated">&lt;code&gt;Weak&lt;/code&gt; ポインタはによって管理割り当てを一時的に参照を維持するのに有用である&lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt;落下からその内の値を妨げることなく。また、相互に所有する参照によってどちらの&lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt;も削除されないため、&lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt;ポインター間の循環参照を防ぐためにも使用されます。たとえば、ツリーには、親ノードから子への強い&lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt;ポインターと、子から親への &lt;code&gt;Weak&lt;/code&gt; ポインターが含まれる可能性があります。</target>
        </trans-unit>
        <trans-unit id="a226c54ce6028079ee3f0e935344b03753cf6ea2" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Weak&lt;/code&gt; pointer is useful for keeping a temporary reference to the allocation managed by &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; without preventing its inner value from being dropped. It is also used to prevent circular references between &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointers, since mutual owning references would never allow either &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; to be dropped. For example, a tree could have strong &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointers from parent nodes to children, and &lt;code&gt;Weak&lt;/code&gt; pointers from children back to their parents.</source>
          <target state="translated">&lt;code&gt;Weak&lt;/code&gt; ポインタはによって管理割り当てを一時的に参照を維持するのに有用である&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; とを&lt;/a&gt;落下からその内の値を妨げることなく。また、相互所有の参照ではどちらの&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt;も削除できないため、&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt;ポインター間の循環参照を防ぐためにも使用されます。たとえば、ツリーには、親ノードから子への強い&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt;ポインターと、子から親への &lt;code&gt;Weak&lt;/code&gt; ポインターが含まれる可能性があります。</target>
        </trans-unit>
        <trans-unit id="92c5425b2664515a7d6b0bd3279f583d1e16c172" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Weak&lt;/code&gt; pointer is useful for keeping a temporary reference to the value within &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; without extending its lifetime. It is also used to prevent circular references between &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; pointers, since mutual owning references would never allow either &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; to be dropped. For example, a tree could have strong &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; pointers from parent nodes to children, and &lt;code&gt;Weak&lt;/code&gt; pointers from children back to their parents.</source>
          <target state="translated">&lt;code&gt;Weak&lt;/code&gt; ポインタは、内の値を一時的に参照を保持するのに有用である&lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt;の寿命を延長することなく。また、相互に所有している参照ではどちらの&lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt;も削除できないため、&lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt;ポインタ間の循環参照を防ぐためにも使用されます。たとえば、ツリーには、親ノードから子への強い&lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt;ポインターと、子から親への &lt;code&gt;Weak&lt;/code&gt; ポインターがあります。</target>
        </trans-unit>
        <trans-unit id="c317832e61e5046de4792c85bcf63089c251292c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Weak&lt;/code&gt; pointer is useful for keeping a temporary reference to the value within &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; without extending its lifetime. It is also used to prevent circular references between &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointers, since mutual owning references would never allow either &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; to be dropped. For example, a tree could have strong &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointers from parent nodes to children, and &lt;code&gt;Weak&lt;/code&gt; pointers from children back to their parents.</source>
          <target state="translated">&lt;code&gt;Weak&lt;/code&gt; ポインタは、内の値を一時的に参照を保持するのに有用である&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; の&lt;/a&gt;寿命を延長することなく。また、相互に所有している参照ではどちらの&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt;も削除できないため、&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt;ポインター間の循環参照を防ぐためにも使用されます。たとえば、ツリーには親ノードから子への強力な&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt;ポインターがあり、 &lt;code&gt;Weak&lt;/code&gt; から子への弱いポインターがあります。</target>
        </trans-unit>
        <trans-unit id="2ab6f5c59e2d0418f87950a3ebfb26ab14b557db" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;break&lt;/code&gt; expression is normally associated with the innermost &lt;code&gt;loop&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt; or &lt;code&gt;while&lt;/code&gt; loop enclosing the &lt;code&gt;break&lt;/code&gt; expression, but a &lt;a href=&quot;#loop-labels&quot;&gt;label&lt;/a&gt; can be used to specify which enclosing loop is affected. Example:</source>
          <target state="translated">&lt;code&gt;break&lt;/code&gt; 発現は、通常、最も内側に関連している &lt;code&gt;loop&lt;/code&gt; 、 &lt;code&gt;for&lt;/code&gt; 又は &lt;code&gt;while&lt;/code&gt; ループが囲む &lt;code&gt;break&lt;/code&gt; 発現が、&lt;a href=&quot;#loop-labels&quot;&gt;ラベルが&lt;/a&gt;影響を受ける囲むループを指定するために使用することができます。例：</target>
        </trans-unit>
        <trans-unit id="4bf74475c310d76b2da5f50f50fec722f68f826f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;break&lt;/code&gt; expression is normally associated with the innermost &lt;code&gt;loop&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt; or &lt;code&gt;while&lt;/code&gt; loop enclosing the &lt;code&gt;break&lt;/code&gt; expression, but a &lt;a href=&quot;loop-expr#loop-labels&quot;&gt;label&lt;/a&gt; can be used to specify which enclosing loop is affected. Example:</source>
          <target state="translated">&lt;code&gt;break&lt;/code&gt; 発現は、通常、最も内側に関連している &lt;code&gt;loop&lt;/code&gt; 、 &lt;code&gt;for&lt;/code&gt; 又は &lt;code&gt;while&lt;/code&gt; 囲むループ &lt;code&gt;break&lt;/code&gt; 発現が、A&lt;a href=&quot;loop-expr#loop-labels&quot;&gt;ラベルが&lt;/a&gt;影響を受ける囲むループを指定するために使用することができます。例：</target>
        </trans-unit>
        <trans-unit id="dc2182d07a207a24da6c811d0b8e308ce9f0619b" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;break&lt;/code&gt; expression is only permitted in the body of a loop, and has one of the forms &lt;code&gt;break&lt;/code&gt;, &lt;code&gt;break 'label&lt;/code&gt; or (&lt;a href=&quot;#break-and-loop-values&quot;&gt;see below&lt;/a&gt;) &lt;code&gt;break EXPR&lt;/code&gt; or &lt;code&gt;break 'label EXPR&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;break&lt;/code&gt; 発現は、ループの本体で許可されており、フォームのいずれか有している &lt;code&gt;break&lt;/code&gt; 、 &lt;code&gt;break 'label&lt;/code&gt; 又は（&lt;a href=&quot;#break-and-loop-values&quot;&gt;下記参照&lt;/a&gt;） &lt;code&gt;break EXPR&lt;/code&gt; 又は &lt;code&gt;break 'label EXPR&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1929ca3782f20314772673eb1b3076f6e73f81b3" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;break&lt;/code&gt; expression is only permitted in the body of a loop, and has one of the forms &lt;code&gt;break&lt;/code&gt;, &lt;code&gt;break 'label&lt;/code&gt; or (&lt;a href=&quot;loop-expr#break-and-loop-values&quot;&gt;see below&lt;/a&gt;) &lt;code&gt;break EXPR&lt;/code&gt; or &lt;code&gt;break 'label EXPR&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;break&lt;/code&gt; 発現は、ループの本体で許可されており、フォームのいずれか有している &lt;code&gt;break&lt;/code&gt; 、 &lt;code&gt;break 'label&lt;/code&gt; 又は（&lt;a href=&quot;loop-expr#break-and-loop-values&quot;&gt;下記参照&lt;/a&gt;） &lt;code&gt;break EXPR&lt;/code&gt; 又は &lt;code&gt;break 'label EXPR&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f212565caf5ca5d26733a24ecd450094943708a5" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;break&lt;/code&gt; statement with an argument appeared in a non-&lt;code&gt;loop&lt;/code&gt; loop.</source>
          <target state="translated">引数付きの &lt;code&gt;break&lt;/code&gt; ステートメントが非 &lt;code&gt;loop&lt;/code&gt; ループに現れました。</target>
        </trans-unit>
        <trans-unit id="0719aea9e00a3f18488e8dec397e352b5e69370a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;break&lt;/code&gt; statement without a label appeared inside a labeled block.</source>
          <target state="translated">ラベルなしの &lt;code&gt;break&lt;/code&gt; ステートメントがラベル付きブロック内に表示されました。</target>
        </trans-unit>
        <trans-unit id="3cd69f4f6c3139636621e0e9a9e16305bdb70d6f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;char&lt;/code&gt; is a &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode Scalar Value&lt;/a&gt;, which means that it is a &lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt;Code Point&lt;/a&gt;, but only ones within a certain range. &lt;code&gt;MAX&lt;/code&gt; is the highest valid code point that's a valid &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode Scalar Value&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; がある&lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicodeのスカラー値&lt;/a&gt;があることを意味し、&lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt;コードポイント&lt;/a&gt;が、一定の範囲内で唯一のもの。 &lt;code&gt;MAX&lt;/code&gt; は、有効な&lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicodeスカラー値で&lt;/a&gt;ある最も高い有効なコードポイントです。</target>
        </trans-unit>
        <trans-unit id="e8ee25848e86a1b5a5cc249fddb42f44e3d6d658" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;char&lt;/code&gt; is a &lt;a href=&quot;https://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode Scalar Value&lt;/a&gt;, which means that it is a &lt;a href=&quot;https://www.unicode.org/glossary/#code_point&quot;&gt;Code Point&lt;/a&gt;, but only ones within a certain range. &lt;code&gt;MAX&lt;/code&gt; is the highest valid code point that's a valid &lt;a href=&quot;https://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode Scalar Value&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6de9c91a3e0c1eb1015d4865a476f244ccddf52f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;const&lt;/code&gt; represents a constant value that should never change. If one takes a &lt;code&gt;&amp;amp;&lt;/code&gt; reference to the constant, then one is taking a pointer to some memory location containing the value. Normally this is perfectly fine: most values can't be changed via a shared &lt;code&gt;&amp;amp;&lt;/code&gt; pointer, but interior mutability would allow it. That is, a constant value could be mutated. On the other hand, a &lt;code&gt;static&lt;/code&gt; is explicitly a single memory location, which can be mutated at will.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; が変化することはありません一定の値を表しています。一方がかかる場合 &lt;code&gt;&amp;amp;&lt;/code&gt; 定数への参照を、次いで一つは値を含むいくつかのメモリ位置へのポインタを取っています。通常、これは完全に問題ありません。ほとんどの値は共有 &lt;code&gt;&amp;amp;&lt;/code&gt; ポインタを介して変更できませんが、内部の可変性により可能です。つまり、定数値が変更される可能性があります。一方、 &lt;code&gt;static&lt;/code&gt; は明示的に単一のメモリ位置であり、自由に変更できます。</target>
        </trans-unit>
        <trans-unit id="fcf892710236415af0f5e027b5569143cb3933af" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;for&lt;/code&gt; expression is a syntactic construct for looping over elements provided by an implementation of &lt;code&gt;std::iter::IntoIterator&lt;/code&gt;. If the iterator yields a value, that value is given the specified name and the body of the loop is executed, then control returns to the head of the &lt;code&gt;for&lt;/code&gt; loop. If the iterator is empty, the &lt;code&gt;for&lt;/code&gt; expression completes.</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; 式は、実装によって提供される要素上ループのシンタックス構造である &lt;code&gt;std::iter::IntoIterator&lt;/code&gt; 。イテレータが値を生成し、その値に指定された名前が付けられ、ループの本体が実行されると、制御は &lt;code&gt;for&lt;/code&gt; ループの先頭に戻ります。イテレータが空の場合、 &lt;code&gt;for&lt;/code&gt; 式は完了します。</target>
        </trans-unit>
        <trans-unit id="7cc2ad054c8700f44ee39d9eb760a19117e088af" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;for&lt;/code&gt; expression is a syntactic construct for looping over elements provided by an implementation of &lt;code&gt;std::iter::IntoIterator&lt;/code&gt;. If the iterator yields a value, that value is matched against the irrefutable pattern, the body of the loop is executed, and then control returns to the head of the &lt;code&gt;for&lt;/code&gt; loop. If the iterator is empty, the &lt;code&gt;for&lt;/code&gt; expression completes.</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; 式は、実装によって提供される要素上ループのシンタックス構造である &lt;code&gt;std::iter::IntoIterator&lt;/code&gt; 。イテレータが値を生成すると、その値は反駁できないパターンと照合され、ループの本体が実行されてから、制御が &lt;code&gt;for&lt;/code&gt; ループの先頭に戻ります。イテレータが空の場合、 &lt;code&gt;for&lt;/code&gt; 式は完了します。</target>
        </trans-unit>
        <trans-unit id="d73920ce8bc8796a34637626ebd1ee2bfe7e1d77" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;for&lt;/code&gt; loop expands as shown:</source>
          <target state="translated">A &lt;code&gt;for&lt;/code&gt; ループ膨張示すように：</target>
        </trans-unit>
        <trans-unit id="0dcdc530771d15a6a0db69b3817439a78d80a1af" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;loop&lt;/code&gt; expression repeats execution of its body continuously: &lt;code&gt;loop { println!(&quot;I live.&quot;); }&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;loop&lt;/code&gt; 式は、継続的にその本体の実行を繰り返し： &lt;code&gt;loop { println!(&quot;I live.&quot;); }&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d617ef5af3dab30c4c49b4baffa8bfa3c5f2ec66" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;loop&lt;/code&gt; expression without an associated &lt;code&gt;break&lt;/code&gt; expression is diverging and has type &lt;a href=&quot;../types/never&quot;&gt;&lt;code&gt;!&lt;/code&gt;&lt;/a&gt;. A &lt;code&gt;loop&lt;/code&gt; expression containing associated &lt;a href=&quot;#break-expressions&quot;&gt;&lt;code&gt;break&lt;/code&gt; expression(s)&lt;/a&gt; may terminate, and must have type compatible with the value of the &lt;code&gt;break&lt;/code&gt; expression(s).</source>
          <target state="translated">&lt;code&gt;loop&lt;/code&gt; 、関連のない表現 &lt;code&gt;break&lt;/code&gt; 式が発散して型を持ってさ&lt;a href=&quot;../types/never&quot;&gt; &lt;code&gt;!&lt;/code&gt; &lt;/a&gt;。 &lt;code&gt;loop&lt;/code&gt; 関連含む発現&lt;a href=&quot;#break-expressions&quot;&gt; &lt;code&gt;break&lt;/code&gt; 式（S）が&lt;/a&gt;終了することができる、との値と互換性が入力しておく必要があり &lt;code&gt;break&lt;/code&gt; 式（S）です。</target>
        </trans-unit>
        <trans-unit id="e36c323c7511710c9caa566121cf59ed62c95bef" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;loop&lt;/code&gt; expression without an associated &lt;code&gt;break&lt;/code&gt; expression is diverging and has type &lt;a href=&quot;../types/never&quot;&gt;&lt;code&gt;!&lt;/code&gt;&lt;/a&gt;. A &lt;code&gt;loop&lt;/code&gt; expression containing associated &lt;a href=&quot;loop-expr#break-expressions&quot;&gt;&lt;code&gt;break&lt;/code&gt; expression(s)&lt;/a&gt; may terminate, and must have type compatible with the value of the &lt;code&gt;break&lt;/code&gt; expression(s).</source>
          <target state="translated">&lt;code&gt;loop&lt;/code&gt; 、関連のない表現 &lt;code&gt;break&lt;/code&gt; 式が発散して型を持ってさ&lt;a href=&quot;../types/never&quot;&gt; &lt;code&gt;!&lt;/code&gt; &lt;/a&gt;。 &lt;code&gt;loop&lt;/code&gt; 関連含む発現&lt;a href=&quot;loop-expr#break-expressions&quot;&gt; &lt;code&gt;break&lt;/code&gt; 式（S）が&lt;/a&gt;終了することができる、との値と互換性が入力しておく必要があり &lt;code&gt;break&lt;/code&gt; 式（S）です。</target>
        </trans-unit>
        <trans-unit id="27cdf38632ff8742feaafa6612389bb67003ed19" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;match&lt;/code&gt; behaves differently depending on whether or not the scrutinee expression is a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place expression or value expression&lt;/a&gt;. If the scrutinee expression is a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;value expression&lt;/a&gt;, it is first evaluated into a temporary location, and the resulting value is sequentially compared to the patterns in the arms until a match is found. The first arm with a matching pattern is chosen as the branch target of the &lt;code&gt;match&lt;/code&gt;, any variables bound by the pattern are assigned to local variables in the arm's block, and control enters the block.</source>
          <target state="translated">&lt;code&gt;match&lt;/code&gt; scrutinee式があるかどうかに応じて、異なった動作を&lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;場所式または値式&lt;/a&gt;。 scrutinee式が&lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;value式の&lt;/a&gt;場合、最初に一時的な場所で評価され、結果の値は、一致が見つかるまで腕のパターンと順次比較されます。一致するパターンを持つ最初のアームが &lt;code&gt;match&lt;/code&gt; の分岐ターゲットとして選択され、パターンによってバインドされたすべての変数がアームのブロックのローカル変数に割り当てられ、コントロールがブロックに入ります。</target>
        </trans-unit>
        <trans-unit id="9d65cf4e1e473919c3773c077a67170ac8398876" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;match&lt;/code&gt; expression is made up of &lt;em&gt;arms&lt;/em&gt;. An arm consists of a &lt;em&gt;pattern&lt;/em&gt; and the code that should be run if the value given to the beginning of the &lt;code&gt;match&lt;/code&gt; expression fits that arm&amp;rsquo;s pattern. Rust takes the value given to &lt;code&gt;match&lt;/code&gt; and looks through each arm&amp;rsquo;s pattern in turn. The &lt;code&gt;match&lt;/code&gt; construct and patterns are powerful features in Rust that let you express a variety of situations your code might encounter and make sure that you handle them all. These features will be covered in detail in Chapter 6 and Chapter 18, respectively.</source>
          <target state="translated">&lt;code&gt;match&lt;/code&gt; 式は、で構成されている&lt;em&gt;武器&lt;/em&gt;。アームは、&lt;em&gt;パターン&lt;/em&gt;と、 &lt;code&gt;match&lt;/code&gt; 式の先頭に指定された値がそのアームのパターンに適合する場合に実行されるコードで構成されます。Rustは &lt;code&gt;match&lt;/code&gt; 指定された値を取得し、各腕のパターンを順に調べます。 &lt;code&gt;match&lt;/code&gt; 構築物およびパターンは、あなたがあなたのコードが発生し、あなたがそれらすべてを扱うことになるかもしれないさまざまな状況を表現してみましょうルスト強力な機能です。これらの機能については、それぞれ第6章と第18章で詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="2653905e02c1a5978b97c0dfd21c1d160c036b3e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;repr(transparent)&lt;/code&gt; type was also annotated with other, incompatible representation hints.</source>
          <target state="translated">&lt;code&gt;repr(transparent)&lt;/code&gt; タイプは、他の、互換性のない表現ヒントで注釈しました。</target>
        </trans-unit>
        <trans-unit id="c5a4ca7ea6b5bc0339d74f8626989e641c9a4f2a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;return&lt;/code&gt; marks the end of an execution path in a function:</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt; マーク機能で実行パスの終わり：</target>
        </trans-unit>
        <trans-unit id="d04d984159639545c2a9b782d494bbc89f68eb09" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;enum&lt;/code&gt;, or &lt;code&gt;union&lt;/code&gt; which was defined in the current crate. This is not affected by applied type arguments. &lt;code&gt;struct Foo&lt;/code&gt; is considered local, but &lt;code&gt;Vec&amp;lt;Foo&amp;gt;&lt;/code&gt; is not. &lt;code&gt;LocalType&amp;lt;ForeignType&amp;gt;&lt;/code&gt; is local. Type aliases do not affect locality.</source>
          <target state="translated">&lt;code&gt;struct&lt;/code&gt; 、 &lt;code&gt;enum&lt;/code&gt; 、または &lt;code&gt;union&lt;/code&gt; 現在のクレートに定義されました。これは、適用された型引数の影響を受けません。 &lt;code&gt;struct Foo&lt;/code&gt; はローカルと見なされますが、 &lt;code&gt;Vec&amp;lt;Foo&amp;gt;&lt;/code&gt; はローカルとは見なされません。 &lt;code&gt;LocalType&amp;lt;ForeignType&amp;gt;&lt;/code&gt; はローカルです。タイプエイリアスはローカリティに影響しません。</target>
        </trans-unit>
        <trans-unit id="0bcaf88ff1b66b63413f83d3b7d32c0a7ea7cbfe" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;struct&lt;/code&gt;&lt;em&gt;type&lt;/em&gt; is a heterogeneous product of other types, called the &lt;em&gt;fields&lt;/em&gt; of the type.&lt;sup&gt;&lt;a href=&quot;#structtype&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">&lt;code&gt;struct&lt;/code&gt; &lt;em&gt;タイプは、&lt;/em&gt;と呼ばれる他のタイプの不均一な生成物である&lt;em&gt;フィールド&lt;/em&gt;タイプの。&lt;sup&gt;&lt;a href=&quot;#structtype&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="e983e7b3d7471c078bb152c54f1d0e490ae64bff" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;struct&lt;/code&gt;&lt;em&gt;type&lt;/em&gt; is a heterogeneous product of other types, called the &lt;em&gt;fields&lt;/em&gt; of the type.&lt;sup&gt;&lt;a href=&quot;struct#structtype&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">&lt;code&gt;struct&lt;/code&gt; &lt;em&gt;タイプは、&lt;/em&gt;と呼ばれる他のタイプの不均一な生成物である&lt;em&gt;フィールド&lt;/em&gt;タイプの。&lt;sup&gt;&lt;a href=&quot;struct#structtype&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="5dc372cb983e81c62a84e7d307e5c691468779fc" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;trait&lt;/code&gt; is like an interface that data types can implement. When a type implements a trait it can be treated abstractly as that trait using generics or trait objects.</source>
          <target state="translated">&lt;code&gt;trait&lt;/code&gt; データ型が実装できるというインターフェースのようなものです。タイプがトレイトを実装する場合、ジェネリックスまたはトレイトオブジェクトを使用して、そのトレイトとして抽象的に扱うことができます。</target>
        </trans-unit>
        <trans-unit id="2ad87d3d4edf2b4861565127275e5ad1afc1a755" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;trait&lt;/code&gt; which was defined in the current crate. A trait definition is local or not independent of applied type arguments. Given &lt;code&gt;trait Foo&amp;lt;T, U&amp;gt;&lt;/code&gt;, &lt;code&gt;Foo&lt;/code&gt; is always local, regardless of the types substituted for &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;trait&lt;/code&gt; 現在クレートで定義されました。トレイト定義はローカルであるか、適用された型引数から独立していません。 &lt;code&gt;trait Foo&amp;lt;T, U&amp;gt;&lt;/code&gt; 与えられた場合、 &lt;code&gt;T&lt;/code&gt; と &lt;code&gt;U&lt;/code&gt; の代わりに使用されるタイプに関係なく、 &lt;code&gt;Foo&lt;/code&gt; は常にローカルです。</target>
        </trans-unit>
        <trans-unit id="99ab68cda9330ceba3e059532d454bd1454a3c76" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;union&lt;/code&gt; cannot have fields with destructors.</source>
          <target state="translated">&lt;code&gt;union&lt;/code&gt; デストラクタを持つフィールドを持つことはできません。</target>
        </trans-unit>
        <trans-unit id="7456e28e3269b8fcb15b4e8220467fa67683b4bd" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;union&lt;/code&gt; is similar to a &lt;code&gt;struct&lt;/code&gt;, but only one declared field is used in a particular instance at one time. Unions are primarily used to interface with unions in C code. Accessing union fields is unsafe because Rust can&amp;rsquo;t guarantee the type of the data currently being stored in the union instance. You can learn more about unions in &lt;a href=&quot;../reference/items/unions&quot;&gt;the reference&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;union&lt;/code&gt; に似ている &lt;code&gt;struct&lt;/code&gt; が、一つだけの宣言フィールドを一度に特定のインスタンスで使用されています。ユニオンは主に、Cコードのユニオンとのインターフェースに使用されます。Rustは、現在ユニオンインスタンスに格納されているデータのタイプを保証できないため、ユニオンフィールドへのアクセスは安全ではありません。ユニオンについて詳しくは&lt;a href=&quot;../reference/items/unions&quot;&gt;、リファレンスを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="d933644dc98827f86adb027ad1edada503180c92" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;union&lt;/code&gt; looks like a &lt;a href=&quot;keyword.struct&quot;&gt;&lt;code&gt;struct&lt;/code&gt;&lt;/a&gt; in terms of declaration, but all of its fields exist in the same memory, superimposed over one another. For instance, if we wanted some bits in memory that we sometimes interpret as a &lt;code&gt;u32&lt;/code&gt; and sometimes as an &lt;code&gt;f32&lt;/code&gt;, we could write:</source>
          <target state="translated">&lt;code&gt;union&lt;/code&gt; のように見える&lt;a href=&quot;keyword.struct&quot;&gt; &lt;code&gt;struct&lt;/code&gt; &lt;/a&gt;宣言の面ではなく、そのフィールドの全ては、互いに上に重ね、同じメモリ内に存在します。例えば、我々は時々として解釈することをメモリ内にいくつかのビットを望んでいた場合 &lt;code&gt;u32&lt;/code&gt; 、時にはとして &lt;code&gt;f32&lt;/code&gt; 、我々は書くことができます：</target>
        </trans-unit>
        <trans-unit id="aae4dfd16f669123c1df46acb99529aa8db4f78e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;union&lt;/code&gt; was declared with fields with destructors.</source>
          <target state="translated">&lt;code&gt;union&lt;/code&gt; デストラクタを持つフィールドで宣言されました。</target>
        </trans-unit>
        <trans-unit id="31174f5a2be478aaee87f1f4ce26d9142eeb339c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;while let&lt;/code&gt; loop is equivalent to a &lt;code&gt;loop&lt;/code&gt; expression containing a &lt;a href=&quot;match-expr&quot;&gt;&lt;code&gt;match&lt;/code&gt; expression&lt;/a&gt; as follows.</source>
          <target state="translated">&lt;code&gt;while let&lt;/code&gt; ループに相当する &lt;code&gt;loop&lt;/code&gt; を含む発現&lt;a href=&quot;match-expr&quot;&gt; &lt;code&gt;match&lt;/code&gt; 式を&lt;/a&gt;次のように。</target>
        </trans-unit>
        <trans-unit id="132dd0b4198a0332783e039cb830e80e3a95c535" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;while let&lt;/code&gt; loop is semantically similar to a &lt;code&gt;while&lt;/code&gt; loop but in place of a condition expression it expects the keyword &lt;code&gt;let&lt;/code&gt; followed by a pattern, an &lt;code&gt;=&lt;/code&gt;, a &lt;a href=&quot;../glossary#scrutinee&quot;&gt;scrutinee&lt;/a&gt; expression and a block expression. If the value of the scrutinee matches the pattern, the loop body block executes then control returns to the pattern matching statement. Otherwise, the while expression completes.</source>
          <target state="translated">A &lt;code&gt;while let&lt;/code&gt; ループと意味的に類似している &lt;code&gt;while&lt;/code&gt; ループが、それはキーワード予期条件式の代わりに &lt;code&gt;let&lt;/code&gt; 、パターンが続く &lt;code&gt;=&lt;/code&gt; 、&lt;a href=&quot;../glossary#scrutinee&quot;&gt;scrutineeの&lt;/a&gt;発現およびブロック発現。scrutineeの値がパターンに一致する場合、ループ本体ブロックが実行され、制御はパターンマッチングステートメントに戻ります。それ以外の場合、while式は完了します。</target>
        </trans-unit>
        <trans-unit id="718179093a0d6e082dbdc6f07f43775afb09f0f9" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;while&lt;/code&gt; expression is used for predicate loops. The &lt;code&gt;while&lt;/code&gt; expression runs the conditional expression before running the loop body, then runs the loop body if the conditional expression evaluates to &lt;code&gt;true&lt;/code&gt;, or exits the loop otherwise.</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt; 表現は、述語ループのために使用されます。 &lt;code&gt;while&lt;/code&gt; 式はループ本体を実行する前に条件式を実行し、条件式を評価された場合、その後にループ本体を実行し &lt;code&gt;true&lt;/code&gt; 、またはそれ以外の場合はループを抜けます。</target>
        </trans-unit>
        <trans-unit id="283fcf53585988268a7d68d52030cb117688b529" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;while&lt;/code&gt; loop begins by evaluating the boolean loop conditional expression. If the loop conditional expression evaluates to &lt;code&gt;true&lt;/code&gt;, the loop body block executes, then control returns to the loop conditional expression. If the loop conditional expression evaluates to &lt;code&gt;false&lt;/code&gt;, the &lt;code&gt;while&lt;/code&gt; expression completes.</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt; ループは、ブールループ条件式を評価することによって始まります。ループ条件式の評価が &lt;code&gt;true&lt;/code&gt; の場合、ループ本体ブロックが実行され、制御はループ条件式に戻ります。ループ条件式が &lt;code&gt;false&lt;/code&gt; と評価されると、 &lt;code&gt;while&lt;/code&gt; 式が完了します。</target>
        </trans-unit>
        <trans-unit id="9024dfdf6115f20a47566e1a178072686b644d4c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;yield&lt;/code&gt; clause was used in an &lt;code&gt;async&lt;/code&gt; context.</source>
          <target state="translated">&lt;code&gt;yield&lt;/code&gt; 句を使用した &lt;code&gt;async&lt;/code&gt; コンテキスト。</target>
        </trans-unit>
        <trans-unit id="9a98030fcb71c42d6137c8ff5fae0192e67a25d8" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;24-bit code point escape&lt;/em&gt; starts with &lt;code&gt;U+0075&lt;/code&gt; (&lt;code&gt;u&lt;/code&gt;) and is followed by up to six &lt;em&gt;hex digits&lt;/em&gt; surrounded by braces &lt;code&gt;U+007B&lt;/code&gt; (&lt;code&gt;{&lt;/code&gt;) and &lt;code&gt;U+007D&lt;/code&gt; (&lt;code&gt;}&lt;/code&gt;). It denotes the Unicode code point equal to the provided hex value.</source>
          <target state="translated">&lt;em&gt;24ビットコードポイントエスケープ&lt;/em&gt;と開始 &lt;code&gt;U+0075&lt;/code&gt; （ &lt;code&gt;u&lt;/code&gt; ）六のまで続いて&lt;em&gt;進数字が&lt;/em&gt;括弧に囲まれた &lt;code&gt;U+007B&lt;/code&gt; （ &lt;code&gt;{&lt;/code&gt; ）と &lt;code&gt;U+007D&lt;/code&gt; （ &lt;code&gt;}&lt;/code&gt; ）。これは、提供された16進値に等しいUnicodeコードポイントを示します。</target>
        </trans-unit>
        <trans-unit id="869073214f1b9edb093744ef355f142778b07763" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;7-bit code point escape&lt;/em&gt; starts with &lt;code&gt;U+0078&lt;/code&gt; (&lt;code&gt;x&lt;/code&gt;) and is followed by exactly two &lt;em&gt;hex digits&lt;/em&gt; with value up to &lt;code&gt;0x7F&lt;/code&gt;. It denotes the ASCII character with value equal to the provided hex value. Higher values are not permitted because it is ambiguous whether they mean Unicode code points or byte values.</source>
          <target state="translated">&lt;em&gt;7ビットのコードポイントエスケープが&lt;/em&gt;始まる &lt;code&gt;U+0078&lt;/code&gt; （ &lt;code&gt;x&lt;/code&gt; ）とちょうど二つ続いて&lt;em&gt;進数字&lt;/em&gt;の値までと &lt;code&gt;0x7F&lt;/code&gt; の。これは、指定された16進値に等しい値を持つASCII文字を示します。 Unicodeコードポイントを意味するのか、バイト値を意味するのかが不明確であるため、これより高い値は許可されません。</target>
        </trans-unit>
        <trans-unit id="ba5e9b49178a0e6b5d252044b97fef65592fc293" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;&lt;code&gt;let&lt;/code&gt; statement&lt;/em&gt; introduces a new set of &lt;a href=&quot;variables&quot;&gt;variables&lt;/a&gt;, given by a &lt;a href=&quot;patterns&quot;&gt;pattern&lt;/a&gt;. The pattern is followed optionally by a type annotation and then optionally by an initializer expression. When no type annotation is given, the compiler will infer the type, or signal an error if insufficient type information is available for definite inference. Any variables introduced by a variable declaration are visible from the point of declaration until the end of the enclosing block scope.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;let&lt;/code&gt; 文は、&lt;/em&gt;一連の新しい導入し&lt;a href=&quot;variables&quot;&gt;た変数&lt;/a&gt;で与えられ、&lt;a href=&quot;patterns&quot;&gt;パターンを&lt;/a&gt;。パターンの後にはオプションで型注釈が続き、オプションで初期化子式が続きます。型注釈が指定されていない場合、コンパイラーは型を推論するか、十分な型情報が明確な推論に利用できない場合はエラーを通知します。変数宣言によって導入された変数は、宣言の時点から、それを囲むブロックスコープの終わりまで表示されます。</target>
        </trans-unit>
        <trans-unit id="8ca18f2a30c6ddfd6e41efbe967d1604f354b083" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;&lt;code&gt;let&lt;/code&gt; statement&lt;/em&gt; introduces a new set of &lt;a href=&quot;variables&quot;&gt;variables&lt;/a&gt;, given by an irrefutable &lt;a href=&quot;patterns&quot;&gt;pattern&lt;/a&gt;. The pattern is followed optionally by a type annotation and then optionally by an initializer expression. When no type annotation is given, the compiler will infer the type, or signal an error if insufficient type information is available for definite inference. Any variables introduced by a variable declaration are visible from the point of declaration until the end of the enclosing block scope.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;let&lt;/code&gt; 文は、&lt;/em&gt;一連の新しい導入し&lt;a href=&quot;variables&quot;&gt;た変数&lt;/a&gt;反駁によって与えられ、&lt;a href=&quot;patterns&quot;&gt;パターンを&lt;/a&gt;。パターンの後には、オプションで型注釈が続き、オプションで初期化式が続きます。型注釈が指定されていない場合、コンパイラーは型を推論するか、明確な推論に利用できる型情報が不十分な場合はエラーを通知します。変数宣言によって導入された変数は、宣言のポイントからそれを囲むブロックスコープの終わりまで表示されます。</target>
        </trans-unit>
        <trans-unit id="4965d161e4fa0b76aa8e253a8b735c3ef6585135" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;&lt;code&gt;match&lt;/code&gt; expression&lt;/em&gt; branches on a pattern. The exact form of matching that occurs depends on the &lt;a href=&quot;../patterns&quot;&gt;pattern&lt;/a&gt;. A &lt;code&gt;match&lt;/code&gt; expression has a &lt;em&gt;&lt;a href=&quot;../glossary#scrutinee&quot;&gt;scrutinee&lt;/a&gt; expression&lt;/em&gt;, which is the value to compare to the patterns. The scrutinee expression and the patterns must have the same type.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;match&lt;/code&gt; 表現&lt;/em&gt;パターンに分岐します。発生するマッチングの正確な形式は、&lt;a href=&quot;../patterns&quot;&gt;パターン&lt;/a&gt;によって異なります。 &lt;code&gt;match&lt;/code&gt; 発現が有する&lt;em&gt;&lt;a href=&quot;../glossary#scrutinee&quot;&gt;scrutineeの&lt;/a&gt;発現&lt;/em&gt;パターンと比較する値です。scrutinee式とパターンは同じ型でなければなりません。</target>
        </trans-unit>
        <trans-unit id="58385518472acdb41b644cab1601f90a746d55aa" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;binary literal&lt;/em&gt; starts with the character sequence &lt;code&gt;U+0030&lt;/code&gt;&lt;code&gt;U+0062&lt;/code&gt; (&lt;code&gt;0b&lt;/code&gt;) and continues as any mixture (with at least one digit) of binary digits and underscores.</source>
          <target state="translated">&lt;em&gt;バイナリリテラル&lt;/em&gt;文字列で始まる &lt;code&gt;U+0030&lt;/code&gt; &lt;code&gt;U+0062&lt;/code&gt; （ &lt;code&gt;0b&lt;/code&gt; ）とは二進数字および下線の（少なくとも一桁で）任意の混合物として継続します。</target>
        </trans-unit>
        <trans-unit id="e1bc1112f211249d5a018412bd10ed929678eeda" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;block expression&lt;/em&gt;, or &lt;em&gt;block&lt;/em&gt;, is a control flow expression and anonymous namespace scope for items and variable declarations. As a control flow expression, a block sequentially executes its component non-item declaration statements and then its final optional expression. As an anonymous namespace scope, item declarations are only in scope inside the block itself and variables declared by &lt;code&gt;let&lt;/code&gt; statements are in scope from the next statement until the end of the block.</source>
          <target state="translated">&lt;em&gt;ブロック式&lt;/em&gt;、または&lt;em&gt;ブロック&lt;/em&gt;、アイテム、および変数宣言のための制御フロー式と匿名名前空間の範囲です。制御フロー式として、ブロックはそのコンポーネントの非項目宣言ステートメントを順番に実行し、次にその最後のオプションの式を実行します。匿名の名前空間スコープとして、アイテム宣言はブロック自体のスコープ内のみにあり、 &lt;code&gt;let&lt;/code&gt; ステートメントによって宣言された変数は、次のステートメントからブロックの終わりまでスコープ内にあります。</target>
        </trans-unit>
        <trans-unit id="d959096d425f9582c596a1eece69230b21ea3b75" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;byte escape&lt;/em&gt; escape starts with &lt;code&gt;U+0078&lt;/code&gt; (&lt;code&gt;x&lt;/code&gt;) and is followed by exactly two &lt;em&gt;hex digits&lt;/em&gt;. It denotes the byte equal to the provided hex value.</source>
          <target state="translated">&lt;em&gt;バイトエスケープ&lt;/em&gt;エスケープが始まる &lt;code&gt;U+0078&lt;/code&gt; （ &lt;code&gt;x&lt;/code&gt; ）とちょうど二つ続いて&lt;em&gt;進数字&lt;/em&gt;。これは、提供された16進値に等しいバイトを示します。</target>
        </trans-unit>
        <trans-unit id="08d56300cad1166d8bb2fb927ceda10d77863d64" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;byte literal&lt;/em&gt; is a single ASCII character (in the &lt;code&gt;U+0000&lt;/code&gt; to &lt;code&gt;U+007F&lt;/code&gt; range) or a single &lt;em&gt;escape&lt;/em&gt; preceded by the characters &lt;code&gt;U+0062&lt;/code&gt; (&lt;code&gt;b&lt;/code&gt;) and &lt;code&gt;U+0027&lt;/code&gt; (single-quote), and followed by the character &lt;code&gt;U+0027&lt;/code&gt;. If the character &lt;code&gt;U+0027&lt;/code&gt; is present within the literal, it must be &lt;em&gt;escaped&lt;/em&gt; by a preceding &lt;code&gt;U+005C&lt;/code&gt; (&lt;code&gt;\&lt;/code&gt;) character. It is equivalent to a &lt;code&gt;u8&lt;/code&gt; unsigned 8-bit integer &lt;em&gt;number literal&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;バイトリテラルは、&lt;/em&gt;（単一のASCII文字である &lt;code&gt;U+0000&lt;/code&gt; に &lt;code&gt;U+007F&lt;/code&gt; の範囲）またはシングル&lt;em&gt;エスケープ&lt;/em&gt;文字によって先行 &lt;code&gt;U+0062&lt;/code&gt; （ &lt;code&gt;b&lt;/code&gt; ）と &lt;code&gt;U+0027&lt;/code&gt; の文字によって（単一引用符）、及び続く &lt;code&gt;U+0027&lt;/code&gt; 。文字 &lt;code&gt;U+0027&lt;/code&gt; がリテラル内にある場合&lt;em&gt;は&lt;/em&gt;、先行する &lt;code&gt;U+005C&lt;/code&gt; （ &lt;code&gt;\&lt;/code&gt; ）文字で&lt;em&gt;エスケープ&lt;/em&gt;する必要があります。これは、 &lt;code&gt;u8&lt;/code&gt; 符号なし8ビット整数&lt;em&gt;リテラル&lt;/em&gt;と同等です。</target>
        </trans-unit>
        <trans-unit id="82cbcd824290282b86dc09637a06221aa40fcffe" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;call expression&lt;/em&gt; consists of an expression followed by a parenthesized expression-list. It invokes a function, providing zero or more input variables. If the function eventually returns, then the expression completes. For &lt;a href=&quot;../types/function-item&quot;&gt;non-function types&lt;/a&gt;, the expression f(...) uses the method on one of the &lt;a href=&quot;../../std/ops/trait.fn&quot;&gt;&lt;code&gt;std::ops::Fn&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt;&lt;code&gt;std::ops::FnMut&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../std/ops/trait.fnonce&quot;&gt;&lt;code&gt;std::ops::FnOnce&lt;/code&gt;&lt;/a&gt; traits, which differ in whether they take the type by reference, mutable reference, or take ownership respectively. An automatic borrow will be taken if needed. Rust will also automatically dereference &lt;code&gt;f&lt;/code&gt; as required. Some examples of call expressions:</source>
          <target state="translated">&lt;em&gt;呼び出し式は&lt;/em&gt;括弧で囲まれた式リストに続く表現で構成されています。関数を呼び出し、0個以上の入力変数を提供します。関数が最終的に戻ると、式は完了します。以下のための&lt;a href=&quot;../types/function-item&quot;&gt;非関数型&lt;/a&gt;、式f（...）のいずれかの方法を使用して&lt;a href=&quot;../../std/ops/trait.fn&quot;&gt; &lt;code&gt;std::ops::Fn&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt; &lt;code&gt;std::ops::FnMut&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;../../std/ops/trait.fnonce&quot;&gt; &lt;code&gt;std::ops::FnOnce&lt;/code&gt; &lt;/a&gt;かどうかが異なる特性、これらは、参照による型、変更可能な参照、または所有権をそれぞれ取得します。必要に応じて、自動借用が行われます。 Rustは、必要に応じて &lt;code&gt;f&lt;/code&gt; を自動的に逆参照します。呼び出し式の例：</target>
        </trans-unit>
        <trans-unit id="30fdc766ea9fe7cd1ba45798e3f6d282c53ef441" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;character literal&lt;/em&gt; is a single Unicode character enclosed within two &lt;code&gt;U+0027&lt;/code&gt; (single-quote) characters, with the exception of &lt;code&gt;U+0027&lt;/code&gt; itself, which must be &lt;em&gt;escaped&lt;/em&gt; by a preceding &lt;code&gt;U+005C&lt;/code&gt; character (&lt;code&gt;\&lt;/code&gt;).</source>
          <target state="translated">&lt;em&gt;文字リテラルは&lt;/em&gt; 2内に封入された単一のUnicode文字である &lt;code&gt;U+0027&lt;/code&gt; を除いて（単一引用符）文字 &lt;code&gt;U+0027&lt;/code&gt; する必要があり、それ自体、&lt;em&gt;エスケープ&lt;/em&gt;先行によって &lt;code&gt;U+005C&lt;/code&gt; の文字（ &lt;code&gt;\&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="3c6b198e97c9744354ac6c754b38292587c4fb26" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;closure expression&lt;/em&gt; defines a closure and denotes it as a value, in a single expression. A closure expression is a pipe-symbol-delimited (&lt;code&gt;|&lt;/code&gt;) list of irrefutable &lt;a href=&quot;../patterns&quot;&gt;patterns&lt;/a&gt; followed by an expression. Type annotations may optionally be added for the type of the parameters or for the return type. If there is a return type, the expression used for the body of the closure must be a normal &lt;a href=&quot;block-expr&quot;&gt;block&lt;/a&gt;. A closure expression also may begin with the &lt;code&gt;move&lt;/code&gt; keyword before the initial &lt;code&gt;|&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;閉鎖式は&lt;/em&gt;クロージャを定義し、単一式で、値として表します。クロージャ式は、式が続く反駁できない&lt;a href=&quot;../patterns&quot;&gt;パターンの&lt;/a&gt;パイプ記号区切り（ &lt;code&gt;|&lt;/code&gt; ）リストです。オプションで、型の注釈をパラメーターの型または戻り値の型に追加できます。戻り型がある場合、クロージャーの本体に使用される式は通常の&lt;a href=&quot;block-expr&quot;&gt;ブロックで&lt;/a&gt;なければなりません。クロージャ式は、最初の &lt;code&gt;|&lt;/code&gt; の前に &lt;code&gt;move&lt;/code&gt; キーワードで始まることもあります。。</target>
        </trans-unit>
        <trans-unit id="339cfc7fe9f16f898782c7f7150b6fb18b64f9c3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;closure expression&lt;/em&gt;, also know as a lambda expression or a lambda, defines a closure and denotes it as a value, in a single expression. A closure expression is a pipe-symbol-delimited (&lt;code&gt;|&lt;/code&gt;) list of irrefutable &lt;a href=&quot;../patterns&quot;&gt;patterns&lt;/a&gt; followed by an expression. Type annotations may optionally be added for the type of the parameters or for the return type. If there is a return type, the expression used for the body of the closure must be a normal &lt;a href=&quot;block-expr&quot;&gt;block&lt;/a&gt;. A closure expression also may begin with the &lt;code&gt;move&lt;/code&gt; keyword before the initial &lt;code&gt;|&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;クロージャの発現は&lt;/em&gt;、また、ラムダ式またはラムダとして知られる、クロージャを規定し、単一式で、値として表します。クロージャ式は、反駁できない&lt;a href=&quot;../patterns&quot;&gt;パターンの&lt;/a&gt;パイプ記号で区切られた（ &lt;code&gt;|&lt;/code&gt; ）リストの後に式が続きます。オプションで、パラメーターの型または戻り値の型に型注釈を追加できます。戻り値の型がある場合、クロージャーの本体に使用される式は通常の&lt;a href=&quot;block-expr&quot;&gt;ブロックである&lt;/a&gt;必要があります。クロージャ式は、最初の &lt;code&gt;|&lt;/code&gt; の前の &lt;code&gt;move&lt;/code&gt; キーワードで始まる場合もあります。。</target>
        </trans-unit>
        <trans-unit id="12a150efcf9ffb345d5ef3ddd2a2876cc8ac7c18" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;cons list&lt;/em&gt; is a data structure that comes from the Lisp programming language and its dialects. In Lisp, the &lt;code&gt;cons&lt;/code&gt; function (short for &amp;ldquo;construct function&amp;rdquo;) constructs a new pair from its two arguments, which usually are a single value and another pair. These pairs containing pairs form a list.</source>
          <target state="translated">&lt;em&gt;短所リストは&lt;/em&gt; Lispのプログラミング言語とその方言から来たデータ構造です。Lispでは、 &lt;code&gt;cons&lt;/code&gt; 関数（「構築関数」の略）は、2つの引数（通常は単一の値と別のペア）から新しいペアを構築します。ペアを含むこれらのペアはリストを形成します。</target>
        </trans-unit>
        <trans-unit id="cfba0b21b720ac42e28e2be5d6bab07c901fa318" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;const context&lt;/em&gt; is one of the following:</source>
          <target state="translated">&lt;em&gt;constのコンテキストは&lt;/em&gt;、次のいずれかになります。</target>
        </trans-unit>
        <trans-unit id="493b2f63697e56331a49f53a0195846cde72e171" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;const fn&lt;/em&gt; is a function that one is permitted to call from a const context. Declaring a function &lt;code&gt;const&lt;/code&gt; has no effect on any existing uses, it only restricts the types that arguments and the return type may use, as well as prevent various expressions from being used within it. You can freely do anything with a const function that you can do with a regular function.</source>
          <target state="translated">&lt;em&gt;CONSTのFNは、&lt;/em&gt;一方がCONSTコンテキストから呼び出すことが許可されている機能です。関数 &lt;code&gt;const&lt;/code&gt; を宣言しても、既存の使用法には影響しません。引数と戻り値の型が使用できる型を制限するだけでなく、その中でさまざまな式が使用されるのを防ぎます。 const関数では、通常の関数で実行できることなら何でも自由に実行できます。</target>
        </trans-unit>
        <trans-unit id="c36e88175514c7e87236cec6eff5e35e2ff35de3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;constant item&lt;/em&gt; is an optionally named &lt;em&gt;&lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;constant value&lt;/a&gt;&lt;/em&gt; which is not associated with a specific memory location in the program. Constants are essentially inlined wherever they are used, meaning that they are copied directly into the relevant context when used. References to the same constant are not necessarily guaranteed to refer to the same memory address.</source>
          <target state="translated">&lt;em&gt;一定の項目は&lt;/em&gt;任意に命名される&lt;em&gt;&lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;定数値&lt;/a&gt;&lt;/em&gt;プログラム内の特定のメモリ位置に関連付けられていません。定数は、使用される場所に基本的にインライン化されます。つまり、使用されると、関連するコンテキストに直接コピーされます。同じ定数への参照は、必ずしも同じメモリアドレスへの参照を保証するものではありません。</target>
        </trans-unit>
        <trans-unit id="2e06b409839c096ae71106f8baaaf9f78507004d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;constant item&lt;/em&gt; is an optionally named &lt;em&gt;&lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;constant value&lt;/a&gt;&lt;/em&gt; which is not associated with a specific memory location in the program. Constants are essentially inlined wherever they are used, meaning that they are copied directly into the relevant context when used. This includes usage of constants from external crates, and non-&lt;a href=&quot;../special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; types. References to the same constant are not necessarily guaranteed to refer to the same memory address.</source>
          <target state="translated">&lt;em&gt;一定の項目は&lt;/em&gt;任意に命名される&lt;em&gt;&lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;定数値&lt;/a&gt;&lt;/em&gt;プログラム内の特定のメモリ位置に関連付けられていません。定数は基本的に、使用される場所にインライン化されます。つまり、使用されると、関連するコンテキストに直接コピーされます。これには、外部クレートからの定数の使用、および非&lt;a href=&quot;../special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;タイプが含まれます。同じ定数への参照は、必ずしも同じメモリアドレスを参照することが保証されているわけではありません。</target>
        </trans-unit>
        <trans-unit id="f7145ab5c52684eb21ecb032f3560fae33132c02" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;crate&lt;/em&gt; is a unit of compilation and linking, as well as versioning, distribution and runtime loading. A crate contains a &lt;em&gt;tree&lt;/em&gt; of nested &lt;a href=&quot;items/modules&quot;&gt;module&lt;/a&gt; scopes. The top level of this tree is a module that is anonymous (from the point of view of paths within the module) and any item within a crate has a canonical &lt;a href=&quot;paths&quot;&gt;module path&lt;/a&gt; denoting its location within the crate's module tree.</source>
          <target state="translated">&lt;em&gt;クレートは&lt;/em&gt;、コンパイルおよびリンク、ならびにバージョニング、分布およびランタイムローディングの単位です。クレートには、ネストされた&lt;a href=&quot;items/modules&quot;&gt;モジュール&lt;/a&gt;スコープの&lt;em&gt;ツリー&lt;/em&gt;が含まれています。このツリーの最上位レベルは（モジュール内のパスの観点から）匿名のモジュールであり、クレート内のアイテムには、クレートのモジュールツリー内の位置を示す正規の&lt;a href=&quot;paths&quot;&gt;モジュールパスがあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="7dbd934a0d90b722d503e93f98eb0c64d5f9ddfa" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;crate&lt;/em&gt; is a unit of compilation and linking, as well as versioning, distribution, and runtime loading. A crate contains a &lt;em&gt;tree&lt;/em&gt; of nested &lt;a href=&quot;items/modules&quot;&gt;module&lt;/a&gt; scopes. The top level of this tree is a module that is anonymous (from the point of view of paths within the module) and any item within a crate has a canonical &lt;a href=&quot;paths&quot;&gt;module path&lt;/a&gt; denoting its location within the crate's module tree.</source>
          <target state="translated">&lt;em&gt;クレートは&lt;/em&gt;、コンパイルおよびリンク、ならびにバージョン管理、流通、およびランタイム・ローディングの単位です。クレートには、ネストされた&lt;a href=&quot;items/modules&quot;&gt;モジュール&lt;/a&gt;スコープの&lt;em&gt;ツリー&lt;/em&gt;が含まれています。このツリーの最上位は匿名のモジュールであり（モジュール内のパスの観点から）、クレート内のアイテムには、クレートのモジュールツリー内の場所を示す正規の&lt;a href=&quot;paths&quot;&gt;モジュールパスがあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="2299b04cb26521f6ac83c838a00ce161fe3ebdb6" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;decimal literal&lt;/em&gt; followed by a period character &lt;code&gt;U+002E&lt;/code&gt; (&lt;code&gt;.&lt;/code&gt;). This is optionally followed by another decimal literal, with an optional &lt;em&gt;exponent&lt;/em&gt;.</source>
          <target state="translated">A &lt;em&gt;小数リテラル&lt;/em&gt;ピリオドが続く &lt;code&gt;U+002E&lt;/code&gt; （ &lt;code&gt;.&lt;/code&gt; ）。これには、オプションで、別の10進リテラルが続き、オプションで&lt;em&gt;指数が付き&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="8945005fcfd339455451ef03bfa95bfaaedef426" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;decimal literal&lt;/em&gt; starts with a &lt;em&gt;decimal digit&lt;/em&gt; and continues with any mixture of &lt;em&gt;decimal digits&lt;/em&gt; and &lt;em&gt;underscores&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;小数リテラル&lt;/em&gt;で始まり&lt;em&gt;進数字&lt;/em&gt;との任意の混合物を継続&lt;em&gt;進数字&lt;/em&gt;と&lt;em&gt;アンダー&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="766049e827df03480f975a74379f283f50ff3914" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;declaration statement&lt;/em&gt; is one that introduces one or more &lt;em&gt;names&lt;/em&gt; into the enclosing statement block. The declared names may denote new variables or new &lt;a href=&quot;items&quot;&gt;items&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;宣言文は、&lt;/em&gt;一つ以上の紹介です&lt;em&gt;名前を&lt;/em&gt;囲む文ブロックに。宣言された名前は、新しい変数または新しい&lt;a href=&quot;items&quot;&gt;項目を&lt;/a&gt;表す場合があります。</target>
        </trans-unit>
        <trans-unit id="50530b588ed49ed96a8c5783ad73ba3e37c6ea25" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;field expression&lt;/em&gt; consists of an expression followed by a single dot and an &lt;a href=&quot;../identifiers&quot;&gt;identifier&lt;/a&gt;, when not immediately followed by a parenthesized expression-list (the latter is always a &lt;a href=&quot;method-call-expr&quot;&gt;method call expression&lt;/a&gt;). A field expression denotes a field of a &lt;a href=&quot;../items/structs&quot;&gt;struct&lt;/a&gt; or &lt;a href=&quot;../items/unions&quot;&gt;union&lt;/a&gt;. To call a function stored in a struct, parentheses are needed around the field expression.</source>
          <target state="translated">&lt;em&gt;フィールド表現は&lt;/em&gt;、単一のドットと続く発現から成る&lt;a href=&quot;../identifiers&quot;&gt;識別子&lt;/a&gt;直ちに（後者は常に括弧式リストが続かない場合、&lt;a href=&quot;method-call-expr&quot;&gt;メソッド呼び出し式&lt;/a&gt;）。フィールド式は、&lt;a href=&quot;../items/structs&quot;&gt;構造体&lt;/a&gt;または&lt;a href=&quot;../items/unions&quot;&gt;共用&lt;/a&gt;体のフィールドを示します。構造体に格納されている関数を呼び出すには、フィールド式を括弧で囲む必要があります。</target>
        </trans-unit>
        <trans-unit id="cf5014cd7ac2068f18f118543ff07241eda10fbd" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;floating-point literal&lt;/em&gt; has one of two forms:</source>
          <target state="translated">&lt;em&gt;浮動小数点リテラルは、&lt;/em&gt;二つの形式のうちの1つを有します。</target>
        </trans-unit>
        <trans-unit id="4f4b1ebbfdc25acf10623629374f684851ce4095" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;function&lt;/em&gt; consists of a &lt;a href=&quot;../expressions/block-expr&quot;&gt;block&lt;/a&gt;, along with a name and a set of parameters. Other than a name, all these are optional. Functions are declared with the keyword &lt;code&gt;fn&lt;/code&gt;. Functions may declare a set of &lt;em&gt;input&lt;/em&gt;&lt;a href=&quot;../variables&quot;&gt;&lt;em&gt;variables&lt;/em&gt;&lt;/a&gt; as parameters, through which the caller passes arguments into the function, and the &lt;em&gt;output&lt;/em&gt;&lt;a href=&quot;../types#type-expressions&quot;&gt;&lt;em&gt;type&lt;/em&gt;&lt;/a&gt; of the value the function will return to its caller on completion.</source>
          <target state="translated">&lt;em&gt;関数は、&lt;/em&gt;から成る&lt;a href=&quot;../expressions/block-expr&quot;&gt;ブロック&lt;/a&gt;名とパラメータのセットと共に、。名前を除いて、これらはすべてオプションです。関数はキーワード &lt;code&gt;fn&lt;/code&gt; で宣言されます。関数は、一連の&lt;em&gt;入力&lt;/em&gt;&lt;a href=&quot;../variables&quot;&gt;&lt;em&gt;変数&lt;/em&gt;&lt;/a&gt;をパラメーターとして宣言できます。これにより、呼び出し元は関数に引数を渡し、関数は完了時に関数が呼び出し元に返す値の&lt;em&gt;出力&lt;/em&gt;&lt;a href=&quot;../types#type-expressions&quot;&gt;&lt;em&gt;型&lt;/em&gt;&lt;/a&gt;を宣言します。</target>
        </trans-unit>
        <trans-unit id="8f85371a9c250b84e230a898102f42e92fb5ad83" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;generic function&lt;/em&gt; allows one or more &lt;em&gt;parameterized types&lt;/em&gt; to appear in its signature. Each type parameter must be explicitly declared in an angle-bracket-enclosed and comma-separated list, following the function name.</source>
          <target state="translated">&lt;em&gt;一般的な機能は、&lt;/em&gt;一つ以上のことができます&lt;em&gt;パラメータ化された型は、&lt;/em&gt;その署名に表示されます。各型パラメーターは、山かっこで囲まれ、コンマで区切られたリストで、関数名に続いて明示的に宣言する必要があります。</target>
        </trans-unit>
        <trans-unit id="e5b0c06878c29b647a5cee7cefa81c23fca43579" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;hash map&lt;/em&gt; allows you to associate a value with a particular key. It&amp;rsquo;s a particular implementation of the more general data structure called a &lt;em&gt;map&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;ハッシュマップは&lt;/em&gt;、あなたが特定のキーと値を関連付けることができます。これは、&lt;em&gt;map&lt;/em&gt;と呼ばれるより一般的なデータ構造の特定の実装です。</target>
        </trans-unit>
        <trans-unit id="d2dddac086e471872aa5bba992c51dee8e784e1c" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;hex literal&lt;/em&gt; starts with the character sequence &lt;code&gt;U+0030&lt;/code&gt;&lt;code&gt;U+0078&lt;/code&gt; (&lt;code&gt;0x&lt;/code&gt;) and continues as any mixture (with at least one digit) of hex digits and underscores.</source>
          <target state="translated">&lt;em&gt;六角リテラル&lt;/em&gt;文字列で始まる &lt;code&gt;U+0030&lt;/code&gt; &lt;code&gt;U+0078&lt;/code&gt; （ &lt;code&gt;0x&lt;/code&gt; ）と進数字と下線の（少なくとも一桁で）任意の混合物として継続します。</target>
        </trans-unit>
        <trans-unit id="9e38a4ee6fc96f56c22e46e8162db6bbee2c0881" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;literal expression&lt;/em&gt; consists of one of the &lt;a href=&quot;../tokens#literals&quot;&gt;literal&lt;/a&gt; forms described earlier. It directly describes a number, character, string, or boolean value.</source>
          <target state="translated">&lt;em&gt;リテラル式は、&lt;/em&gt;のいずれかから成る&lt;a href=&quot;../tokens#literals&quot;&gt;リテラル&lt;/a&gt;前述した形態。数値、文字、文字列、またはブール値を直接記述します。</target>
        </trans-unit>
        <trans-unit id="ad9efa9913447a56224684e0aa75e5aeea6b8381" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;local variable&lt;/em&gt; (or &lt;em&gt;stack-local&lt;/em&gt; allocation) holds a value directly, allocated within the stack's memory. The value is a part of the stack frame.</source>
          <target state="translated">&lt;em&gt;ローカル変数&lt;/em&gt;（または&lt;em&gt;スタックローカル&lt;/em&gt;割り当て）は、スタックのメモリ内に割り当てられた値を直接、保持しています。値はスタックフレームの一部です。</target>
        </trans-unit>
        <trans-unit id="5494ba7068df28e0c7f4a4e2a11fa8f85cf97050" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;match guard&lt;/em&gt; is an additional &lt;code&gt;if&lt;/code&gt; condition specified after the pattern in a &lt;code&gt;match&lt;/code&gt; arm that must also match, along with the pattern matching, for that arm to be chosen. Match guards are useful for expressing more complex ideas than a pattern alone allows.</source>
          <target state="translated">&lt;em&gt;一致ガードが&lt;/em&gt;追加され &lt;code&gt;if&lt;/code&gt; におけるパターンの後に指定された条件 &lt;code&gt;match&lt;/code&gt; そのアームを選択するためにも、パターンマッチングと共に、一致しなければならないアーム。マッチガードは、パターンだけで許可するよりも複雑なアイデアを表現するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="99824c60f6f2f15272aa4440e52b0f6ee9405ef8" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;method call&lt;/em&gt; consists of an expression (the &lt;em&gt;receiver&lt;/em&gt;) followed by a single dot, an expression path segment, and a parenthesized expression-list. Method calls are resolved to associated &lt;a href=&quot;../items/associated-items#methods&quot;&gt;methods&lt;/a&gt; on specific traits, either statically dispatching to a method if the exact &lt;code&gt;self&lt;/code&gt;-type of the left-hand-side is known, or dynamically dispatching if the left-hand-side expression is an indirect &lt;a href=&quot;../types/trait-object&quot;&gt;trait object&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;メソッド呼び出しは、&lt;/em&gt;式（から成る&lt;em&gt;受信機&lt;/em&gt;の単一のドットは、発現経路セグメント、および括弧式リストが続きます）。メソッド呼び出しは、特定の特性の関連&lt;a href=&quot;../items/associated-items#methods&quot;&gt;メソッド&lt;/a&gt;に解決されます。左側の正確な &lt;code&gt;self&lt;/code&gt; 型がわかっている場合は静的にメソッドにディスパッチされ、左側の式が間接&lt;a href=&quot;../types/trait-object&quot;&gt;特性オブジェクトの&lt;/a&gt;場合は動的にディスパッチされます。</target>
        </trans-unit>
        <trans-unit id="4326f6a26736f9868551af52753b80b0248e3c0e" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;module item&lt;/em&gt; is a module, surrounded in braces, named, and prefixed with the keyword &lt;code&gt;mod&lt;/code&gt;. A module item introduces a new, named module into the tree of modules making up a crate. Modules can nest arbitrarily.</source>
          <target state="translated">&lt;em&gt;モジュール項目は&lt;/em&gt;モジュール、括弧で囲まれた名前が付けられ、キーワードの接頭辞である &lt;code&gt;mod&lt;/code&gt; 。モジュール項目は、新しい名前の付いたモジュールをクレートを構成するモジュールのツリーに導入します。モジュールは任意にネストできます。</target>
        </trans-unit>
        <trans-unit id="4782354728434eca4d6ed0db530842093ebdfbdf" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;number literal&lt;/em&gt; is either an &lt;em&gt;integer literal&lt;/em&gt; or a &lt;em&gt;floating-point literal&lt;/em&gt;. The grammar for recognizing the two kinds of literals is mixed.</source>
          <target state="translated">&lt;em&gt;数値リテラルは、&lt;/em&gt;のいずれかである&lt;em&gt;整数リテラル&lt;/em&gt;または&lt;em&gt;浮動小数点リテラル&lt;/em&gt;。2種類のリテラルを認識するための文法が混在しています。</target>
        </trans-unit>
        <trans-unit id="7a1aa14aba61f76729922fa97eab5dfb14fd43e6" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;path&lt;/em&gt; is a sequence of one or more path segments &lt;em&gt;logically&lt;/em&gt; separated by a namespace qualifier (&lt;code&gt;::&lt;/code&gt;). If a path consists of only one segment, it refers to either an &lt;a href=&quot;items&quot;&gt;item&lt;/a&gt; or a &lt;a href=&quot;variables&quot;&gt;variable&lt;/a&gt; in a local control scope. If a path has multiple segments, it always refers to an item.</source>
          <target state="translated">&lt;em&gt;パスは、&lt;/em&gt;一つ以上の経路セグメントのシーケンスである&lt;em&gt;論理的&lt;/em&gt;名前空間修飾子（によって分離 &lt;code&gt;::&lt;/code&gt; ）。パスが1つのセグメントのみで構成されている場合、パスは、ローカルコントロールスコープ内の&lt;a href=&quot;items&quot;&gt;アイテム&lt;/a&gt;または&lt;a href=&quot;variables&quot;&gt;変数&lt;/a&gt;を参照します。パスに複数のセグメントがある場合、それは常にアイテムを参照します。</target>
        </trans-unit>
        <trans-unit id="bb92d4c241b315859972fd645fc7612b4dfc9464" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;place expression&lt;/em&gt; is an expression that represents a memory location. These expressions are &lt;a href=&quot;expressions/path-expr&quot;&gt;paths&lt;/a&gt; which refer to local variables, &lt;a href=&quot;items/static-items&quot;&gt;static variables&lt;/a&gt;, &lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;dereferences&lt;/a&gt; (&lt;code&gt;*expr&lt;/code&gt;), &lt;a href=&quot;expressions/array-expr#array-and-slice-indexing-expressions&quot;&gt;array indexing&lt;/a&gt; expressions (&lt;code&gt;expr[expr]&lt;/code&gt;), &lt;a href=&quot;expressions/field-expr&quot;&gt;field&lt;/a&gt; references (&lt;code&gt;expr.f&lt;/code&gt;) and parenthesized place expressions. All other expressions are value expressions.</source>
          <target state="translated">&lt;em&gt;場所発現は、&lt;/em&gt;メモリ位置を表す式です。これらの式は、&lt;a href=&quot;expressions/path-expr&quot;&gt;パス&lt;/a&gt;ローカル変数を参照し、&lt;a href=&quot;items/static-items&quot;&gt;静的変数&lt;/a&gt;、&lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;逆参照&lt;/a&gt;（ &lt;code&gt;*expr&lt;/code&gt; ）、&lt;a href=&quot;expressions/array-expr#array-and-slice-indexing-expressions&quot;&gt;配列のインデックスの&lt;/a&gt;式（ &lt;code&gt;expr[expr]&lt;/code&gt; ）、&lt;a href=&quot;expressions/field-expr&quot;&gt;フィールド&lt;/a&gt;参照（ &lt;code&gt;expr.f&lt;/code&gt; ）と括弧場所表現。他のすべての式は値式です。</target>
        </trans-unit>
        <trans-unit id="53e179d5349063cc7a43deec2333f4a66dd27469" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;pointer&lt;/em&gt; is a general concept for a variable that contains an address in memory. This address refers to, or &amp;ldquo;points at,&amp;rdquo; some other data. The most common kind of pointer in Rust is a reference, which you learned about in Chapter 4. References are indicated by the &lt;code&gt;&amp;amp;&lt;/code&gt; symbol and borrow the value they point to. They don&amp;rsquo;t have any special capabilities other than referring to data. Also, they don&amp;rsquo;t have any overhead and are the kind of pointer we use most often.</source>
          <target state="translated">&lt;em&gt;ポインタは、&lt;/em&gt;メモリ内のアドレスが含まれている変数のための一般的な概念です。このアドレスは、他のいくつかのデータを参照または「ポイント」します。Rustで最も一般的な種類のポインタはリファレンスです。これは、第4章で学習しました。リファレンスは &lt;code&gt;&amp;amp;&lt;/code&gt; 記号で示され、それらが指す値を借ります。データを参照する以外に特別な機能はありません。また、オーバーヘッドがなく、私たちが最もよく使用する種類のポインターです。</target>
        </trans-unit>
        <trans-unit id="7fe098911943171d28affe53c0c7d6311adf867c" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;relative path&lt;/em&gt; starts from the current module and uses &lt;code&gt;self&lt;/code&gt;, &lt;code&gt;super&lt;/code&gt;, or an identifier in the current module.</source>
          <target state="translated">&lt;em&gt;相対パスは、&lt;/em&gt;現在のモジュールから始まり、使用する &lt;code&gt;self&lt;/code&gt; 、 &lt;code&gt;super&lt;/code&gt; 、または現在のモジュール内の識別子。</target>
        </trans-unit>
        <trans-unit id="b7be095308c163f67b48127967466163200c85dc" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;scalar&lt;/em&gt; type represents a single value. Rust has four primary scalar types: integers, floating-point numbers, Booleans, and characters. You may recognize these from other programming languages. Let&amp;rsquo;s jump into how they work in Rust.</source>
          <target state="translated">&lt;em&gt;スカラー&lt;/em&gt;型は、単一の値を表します。Rustには、整数、浮動小数点数、ブール、文字の4つの主要なスカラー型があります。他のプログラミング言語からこれらを認識できます。Rustでどのように機能するかを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="5e00452619a2cd4e10d7a42ab9898d401215bca3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;statement&lt;/em&gt; is a component of a &lt;a href=&quot;expressions/block-expr&quot;&gt;block&lt;/a&gt;, which is in turn a component of an outer &lt;a href=&quot;expressions&quot;&gt;expression&lt;/a&gt; or &lt;a href=&quot;items/functions&quot;&gt;function&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;ステートメントは、&lt;/em&gt;の構成要素である&lt;a href=&quot;expressions/block-expr&quot;&gt;ブロック&lt;/a&gt;ターン外側の構成要素である、&lt;a href=&quot;expressions&quot;&gt;発現&lt;/a&gt;又は&lt;a href=&quot;items/functions&quot;&gt;機能&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9cd3832cf111028f53f6cad959deb6ad53f56ca0" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;static item&lt;/em&gt; is similar to a &lt;a href=&quot;constant-items&quot;&gt;constant&lt;/a&gt;, except that it represents a precise memory location in the program. All references to the static refer to the same memory location. Static items have the &lt;code&gt;static&lt;/code&gt; lifetime, which outlives all other lifetimes in a Rust program. Non-&lt;code&gt;mut&lt;/code&gt; static items that contain a type that is not &lt;a href=&quot;../interior-mutability&quot;&gt;interior mutable&lt;/a&gt; may be placed in read-only memory. Static items do not call &lt;a href=&quot;../destructors&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt; at the end of the program.</source>
          <target state="translated">&lt;em&gt;静的項目は&lt;/em&gt;同様である&lt;a href=&quot;constant-items&quot;&gt;定数&lt;/a&gt;、プログラムにおける正確なメモリロケーションを表すことを除いて、。 staticへのすべての参照は、同じメモリ位置を参照しています。静的アイテムには &lt;code&gt;static&lt;/code&gt; ライフタイムがあり、Rustプログラムの他のすべてのライフタイムよりも長く存続します。&lt;a href=&quot;../interior-mutability&quot;&gt;内部で可変&lt;/a&gt;でないタイプを含む非 &lt;code&gt;mut&lt;/code&gt; 静的項目は、読み取り専用メモリに配置できます。静的アイテムは、プログラムの終了時に&lt;a href=&quot;../destructors&quot;&gt; &lt;code&gt;drop&lt;/code&gt; &lt;/a&gt;を呼び出しません。</target>
        </trans-unit>
        <trans-unit id="9ed445848ff0ebfb7d1082c79316c3f0dc94cf17" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;static item&lt;/em&gt; is similar to a &lt;a href=&quot;constant-items&quot;&gt;constant&lt;/a&gt;, except that it represents a precise memory location in the program. All references to the static refer to the same memory location. Static items have the &lt;code&gt;static&lt;/code&gt; lifetime, which outlives all other lifetimes in a Rust program. Static items do not call &lt;a href=&quot;../destructors&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt; at the end of the program.</source>
          <target state="translated">&lt;em&gt;静的項目は&lt;/em&gt;同様である&lt;a href=&quot;constant-items&quot;&gt;定数&lt;/a&gt;、プログラムにおける正確なメモリロケーションを表すことを除いて、。静的へのすべての参照は、同じメモリ位置を参照します。静的アイテムには &lt;code&gt;static&lt;/code&gt; ライフタイムがあり、Rustプログラムの他のすべてのライフタイムよりも長くなります。静的アイテムは、プログラムの最後に&lt;a href=&quot;../destructors&quot;&gt; &lt;code&gt;drop&lt;/code&gt; &lt;/a&gt;を呼び出しません。</target>
        </trans-unit>
        <trans-unit id="045ded2942d599b289c8f6860ad989b955a99d7c" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;string literal&lt;/em&gt; is a sequence of any Unicode characters enclosed within two &lt;code&gt;U+0022&lt;/code&gt; (double-quote) characters, with the exception of &lt;code&gt;U+0022&lt;/code&gt; itself, which must be &lt;em&gt;escaped&lt;/em&gt; by a preceding &lt;code&gt;U+005C&lt;/code&gt; character (&lt;code&gt;\&lt;/code&gt;).</source>
          <target state="translated">&lt;em&gt;文字列リテラルは&lt;/em&gt; 2で囲まれた任意のUnicode文字のシーケンスである &lt;code&gt;U+0022&lt;/code&gt; を除いて、（二重引用符）文字 &lt;code&gt;U+0022&lt;/code&gt; する必要があり、それ自体、&lt;em&gt;エスケープ&lt;/em&gt;直前で &lt;code&gt;U+005C&lt;/code&gt; の文字（ &lt;code&gt;\&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f12122f88fa635dd2b58aa377fdb09d19aba988d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;string slice&lt;/em&gt; is a reference to part of a &lt;code&gt;String&lt;/code&gt;, and it looks like this:</source>
          <target state="translated">&lt;em&gt;文字列のスライスは、&lt;/em&gt;の一部への参照である &lt;code&gt;String&lt;/code&gt; 、それは次のようになります。</target>
        </trans-unit>
        <trans-unit id="691e369dd4289704604ecf4cd7dd7181b87971ad" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;string&lt;/em&gt; is a collection of characters. We&amp;rsquo;ve mentioned the &lt;code&gt;String&lt;/code&gt; type previously, but in this chapter we&amp;rsquo;ll talk about it in depth.</source>
          <target state="translated">&lt;em&gt;文字列は、&lt;/em&gt;文字の集合です。前に &lt;code&gt;String&lt;/code&gt; 型について説明しましたが、この章ではそれについて詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="ac2f7e212f4d47b7d6ba3c1b79c057cc109911ff" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;struct expression&lt;/em&gt; creates a struct or union value. It consists of a path to a &lt;a href=&quot;../items/structs&quot;&gt;struct&lt;/a&gt; or &lt;a href=&quot;../items/unions&quot;&gt;union&lt;/a&gt; item followed by the values for the fields of the item. There are three forms of struct expressions: struct, tuple, and unit.</source>
          <target state="translated">&lt;em&gt;構造体の式は、&lt;/em&gt;構造体または共用体の値を作成します。これは、&lt;a href=&quot;../items/structs&quot;&gt;構造体&lt;/a&gt;または&lt;a href=&quot;../items/unions&quot;&gt;共用&lt;/a&gt;体アイテムへのパスと、それに続くアイテムのフィールドの値で構成されます。構造体式には、構造体、タプル、ユニットの3つの形式があります。</target>
        </trans-unit>
        <trans-unit id="d65205e4e512b884279b051d3f883110c3677542" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;struct&lt;/em&gt; is a nominal &lt;a href=&quot;../types/struct&quot;&gt;struct type&lt;/a&gt; defined with the keyword &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;構造体は&lt;/em&gt;、公称である&lt;a href=&quot;../types/struct&quot;&gt;構造体型&lt;/a&gt;キーワードで定義された &lt;code&gt;struct&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9b38ad3b7538f97629f5686d68a34da8981cf5d0" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;struct&lt;/em&gt;, or &lt;em&gt;structure&lt;/em&gt;, is a custom data type that lets you name and package together multiple related values that make up a meaningful group. If you&amp;rsquo;re familiar with an object-oriented language, a &lt;em&gt;struct&lt;/em&gt; is like an object&amp;rsquo;s data attributes. In this chapter, we&amp;rsquo;ll compare and contrast tuples with structs, demonstrate how to use structs, and discuss how to define methods and associated functions to specify behavior associated with a struct&amp;rsquo;s data. Structs and enums (discussed in Chapter 6) are the building blocks for creating new types in your program&amp;rsquo;s domain to take full advantage of Rust&amp;rsquo;s compile time type checking.</source>
          <target state="translated">&lt;em&gt;構造体&lt;/em&gt;、または&lt;em&gt;構造は&lt;/em&gt;、あなたが意味のあるグループを構成する複数の関連値に名前を付け、一緒にパッケージ化することができますカスタムデータ型です。オブジェクト指向言語に精通している場合、&lt;em&gt;構造体&lt;/em&gt;はオブジェクトのデータ属性のようなものです。この章では、タプルと構造体を比較対照し、構造体の使用方法を示し、メソッドと関連関数を定義して、構造体のデータに関連付けられた動作を指定する方法について説明します。構造体と列挙型（第6章で説明）は、Rustのコンパイル時の型チェックを最大限に活用するためにプログラムのドメインで新しい型を作成するための構成要素です。</target>
        </trans-unit>
        <trans-unit id="c2b858ff2e5a4ed485b3e5e4a18471183d07402f" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;test double&lt;/em&gt; is the general programming concept for a type used in place of another type during testing. &lt;em&gt;Mock objects&lt;/em&gt; are specific types of test doubles that record what happens during a test so you can assert that the correct actions took place.</source>
          <target state="translated">&lt;em&gt;テストでは、二重の&lt;/em&gt;テスト中に、別のタイプの代わりに使用するタイプのための一般的なプログラミングの概念です。&lt;em&gt;モックオブジェクト&lt;/em&gt;は、テスト中に発生したことを記録する特定のタイプのテストダブルであり、正しいアクションが行われたことをアサートできます。</target>
        </trans-unit>
        <trans-unit id="9a0e24d887e877ac9c41e5667ab7a119a4c29456" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;thread pool&lt;/em&gt; is a group of spawned threads that are waiting and ready to handle a task. When the program receives a new task, it assigns one of the threads in the pool to the task, and that thread will process the task. The remaining threads in the pool are available to handle any other tasks that come in while the first thread is processing. When the first thread is done processing its task, it&amp;rsquo;s returned to the pool of idle threads, ready to handle a new task. A thread pool allows you to process connections concurrently, increasing the throughput of your server.</source>
          <target state="translated">&lt;em&gt;スレッドプールが&lt;/em&gt;待っていると、タスクを処理する準備ができている生成されたスレッドのグループです。プログラムは新しいタスクを受け取ると、プール内のスレッドの1つをタスクに割り当て、そのスレッドがタスクを処理します。プール内の残りのスレッドは、最初のスレッドの処理中に発生する他のタスクを処理するために使用できます。最初のスレッドがタスクの処理を完了すると、アイドルスレッドのプールに戻され、新しいタスクを処理する準備が整います。スレッドプールを使用すると、接続を同時に処理できるため、サーバーのスループットが向上します。</target>
        </trans-unit>
        <trans-unit id="313b18e83bc534426ba5a3363e3ef30c68738ffe" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;trait implementation&lt;/em&gt; is defined like an inherent implementation except that the optional generic type declarations is followed by a &lt;a href=&quot;traits&quot;&gt;trait&lt;/a&gt; followed by the keyword &lt;code&gt;for&lt;/code&gt;. Followed by a path to a nominal type.</source>
          <target state="translated">&lt;em&gt;形質実装は&lt;/em&gt;、オプションのジェネリック型宣言が続いていることを除いて、固有の実装のように定義され&lt;a href=&quot;traits&quot;&gt;た形質&lt;/a&gt;キーワードが続く &lt;code&gt;for&lt;/code&gt; 。公称タイプへのパスが続きます。</target>
        </trans-unit>
        <trans-unit id="61547573b3bf424e11f1f4f9cd8d9184f5546ee1" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;trait object&lt;/em&gt; is an opaque value of another type that implements a set of traits. A trait object implements all specified traits as well as their supertraits (if any).</source>
          <target state="translated">&lt;em&gt;形質オブジェクトは&lt;/em&gt;特性のセットを実装する他のタイプの不透明な値です。トレイトオブジェクトは、指定されたすべてのトレイトとそのスーパートレイト（存在する場合）を実装します。</target>
        </trans-unit>
        <trans-unit id="2ba7bca2e53443f2e59cd9b7a5cdc8e34241ae48" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;trait object&lt;/em&gt; is an opaque value of another type that implements a set of traits. The set of traits is made up of an &lt;a href=&quot;../items/traits#object-safety&quot;&gt;object safe&lt;/a&gt;&lt;em&gt;base trait&lt;/em&gt; plus any number of &lt;a href=&quot;../special-types-and-traits#auto-traits&quot;&gt;auto traits&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;形質オブジェクトは&lt;/em&gt;特性のセットを実装する他のタイプの不透明な値です。一連の特性は、&lt;a href=&quot;../items/traits#object-safety&quot;&gt;オブジェクトセーフの&lt;/a&gt;&lt;em&gt;基本特性&lt;/em&gt;と任意の数の&lt;a href=&quot;../special-types-and-traits#auto-traits&quot;&gt;自動特性で構成され&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="5df129cc6b630156d556e5813378ed108b2ab443" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;trait&lt;/em&gt; describes an abstract interface that types can implement. This interface consists of &lt;a href=&quot;associated-items&quot;&gt;associated items&lt;/a&gt;, which come in three varieties:</source>
          <target state="translated">&lt;em&gt;トレイトは&lt;/em&gt;型が実装できるという抽象インタフェースを記述します。このインターフェースは、次の3種類の&lt;a href=&quot;associated-items&quot;&gt;関連アイテム&lt;/a&gt;で構成されています。</target>
        </trans-unit>
        <trans-unit id="a413d8d80703ed47836b183924cabc19246e5f7c" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;trait&lt;/em&gt; tells the Rust compiler about functionality a particular type has and can share with other types. We can use traits to define shared behavior in an abstract way. We can use trait bounds to specify that a generic can be any type that has certain behavior.</source>
          <target state="translated">&lt;em&gt;特徴は&lt;/em&gt;、特定のタイプがあり、他のタイプと共有することができた機能について錆コンパイラに指示します。トレイトを使用して、共有される動作を抽象的な方法で定義できます。特性境界を使用して、ジェネリックが特定の動作をする任意のタイプになるように指定できます。</target>
        </trans-unit>
        <trans-unit id="9018c5e20d838075d5b138f7d86d8d8c684fb244" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;tuple index&lt;/em&gt; is either &lt;code&gt;0&lt;/code&gt;, or starts with a &lt;em&gt;non-zero decimal digit&lt;/em&gt; and continues with zero or more decimal digits. Tuple indexes are used to refer to the fields of &lt;a href=&quot;types/tuple&quot;&gt;tuples&lt;/a&gt;, &lt;a href=&quot;items/structs&quot;&gt;tuple structs&lt;/a&gt; and &lt;a href=&quot;items/enumerations&quot;&gt;tuple variants&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;タプルインデックスが&lt;/em&gt;いずれかである &lt;code&gt;0&lt;/code&gt; 、又はから始まり&lt;em&gt;ゼロでない小数の桁&lt;/em&gt;と0個以上の桁を続けます。タプルインデックスは、&lt;a href=&quot;types/tuple&quot;&gt;タプル&lt;/a&gt;、&lt;a href=&quot;items/structs&quot;&gt;タプル構造体&lt;/a&gt;、&lt;a href=&quot;items/enumerations&quot;&gt;タプルバリアント&lt;/a&gt;のフィールドを参照するために使用されます。</target>
        </trans-unit>
        <trans-unit id="c47a882c5415e255f49931b3989ce3cbb03e65f7" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;tuple struct&lt;/em&gt; is a nominal &lt;a href=&quot;../types/tuple&quot;&gt;tuple type&lt;/a&gt;, also defined with the keyword &lt;code&gt;struct&lt;/code&gt;. For example:</source>
          <target state="translated">&lt;em&gt;タプル構造体は&lt;/em&gt;、公称で&lt;a href=&quot;../types/tuple&quot;&gt;タプルタイプ&lt;/a&gt;もキーワードで定義され、 &lt;code&gt;struct&lt;/code&gt; 。例えば：</target>
        </trans-unit>
        <trans-unit id="e97b14c685e031728ecd4469c910a8f3603e601d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;tuple struct&lt;/em&gt; type is just like a struct type, except that the fields are anonymous.</source>
          <target state="translated">&lt;em&gt;タプルの構造体の&lt;/em&gt;タイプは、フィールドが匿名であること以外は、単に構造体型のようなものです。</target>
        </trans-unit>
        <trans-unit id="57b75c1dd6681cfbd15ca11a1f0f5681b515a0f3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;type alias&lt;/em&gt; defines a new name for an existing &lt;a href=&quot;../types&quot;&gt;type&lt;/a&gt;. Type aliases are declared with the keyword &lt;code&gt;type&lt;/code&gt;. Every value has a single, specific type, but may implement several different traits, or be compatible with several different type constraints.</source>
          <target state="translated">&lt;em&gt;タイプの別名は&lt;/em&gt;既存の新しい名前を定義する&lt;a href=&quot;../types&quot;&gt;タイプ&lt;/a&gt;。タイプエイリアスはキーワード &lt;code&gt;type&lt;/code&gt; 宣言されます。すべての値には単一の特定のタイプがありますが、いくつかの異なる特性を実装したり、いくつかの異なるタイプ制約と互換性がある場合があります。</target>
        </trans-unit>
        <trans-unit id="64ff4b8d7e3ee42067c7072aacfc14cd027c093c" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;type expression&lt;/em&gt; as defined in the &lt;em&gt;Type&lt;/em&gt; grammar rule above is the syntax for referring to a type. It may refer to:</source>
          <target state="translated">&lt;em&gt;型の式&lt;/em&gt;で定義されている&lt;em&gt;タイプの&lt;/em&gt;文法規則は、上記の型を参照するための構文です。以下を参照する場合があります。</target>
        </trans-unit>
        <trans-unit id="50c0af6b4bb64ca1523e3b2abba8e82a69abff5a" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;union type&lt;/em&gt; is a nominal, heterogeneous C-like union, denoted by the name of a &lt;a href=&quot;../items/unions&quot;&gt;&lt;code&gt;union&lt;/code&gt; item&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;ユニオン型は&lt;/em&gt;、公称、異種C状組合の名前で示され&lt;a href=&quot;../items/unions&quot;&gt; &lt;code&gt;union&lt;/code&gt; アイテム&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="96e68805af9609cb7109b9bd3ef8c3be60b740ca" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;unit-like struct&lt;/em&gt; is a struct without any fields, defined by leaving off the list of fields entirely. Such a struct implicitly defines a constant of its type with the same name. For example:</source>
          <target state="translated">&lt;em&gt;ユニット状の構造体は、&lt;/em&gt;全体のフィールドのリストをオフに残すことによって定義された任意のフィールドなしで構造体です。このような構造体は、同じ名前の型の定数を暗黙的に定義します。例えば：</target>
        </trans-unit>
        <trans-unit id="6075d4cd12c28e60ac874060f12974e3762a509a" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;unit-like struct&lt;/em&gt; type is like a struct type, except that it has no fields. The one value constructed by the associated &lt;a href=&quot;../expressions/struct-expr&quot;&gt;struct expression&lt;/a&gt; is the only value that inhabits such a type.</source>
          <target state="translated">&lt;em&gt;ユニット状の構造体の&lt;/em&gt;タイプは、それがフィールドを持っていないことを除いて、構造体型のようなものです。関連する&lt;a href=&quot;../expressions/struct-expr&quot;&gt;struct式&lt;/a&gt;によって構築される1つの値は、そのような型に存在する唯一の値です。</target>
        </trans-unit>
        <trans-unit id="ed7d45b3f3a4f92438f32980c894150a8a0dee9d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;use declaration&lt;/em&gt; creates one or more local name bindings synonymous with some other &lt;a href=&quot;../paths&quot;&gt;path&lt;/a&gt;. Usually a &lt;code&gt;use&lt;/code&gt; declaration is used to shorten the path required to refer to a module item. These declarations may appear in &lt;a href=&quot;modules&quot;&gt;modules&lt;/a&gt; and &lt;a href=&quot;../expressions/block-expr&quot;&gt;blocks&lt;/a&gt;, usually at the top.</source>
          <target state="translated">&lt;em&gt;使用宣言は、&lt;/em&gt;他のいくつかのと同義一つ以上のローカル名のバインディングを作成&lt;a href=&quot;../paths&quot;&gt;パスを&lt;/a&gt;。通常、 &lt;code&gt;use&lt;/code&gt; 宣言は、モジュール項目を参照するために必要なパスを短くするために使用されます。これらの宣言は、通常は上部にある&lt;a href=&quot;modules&quot;&gt;モジュール&lt;/a&gt;および&lt;a href=&quot;../expressions/block-expr&quot;&gt;ブロックに&lt;/a&gt;表示される場合があります。</target>
        </trans-unit>
        <trans-unit id="2d8a654904db4cbe04f06da827ae2d7d450774ec" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;value expression&lt;/em&gt; is an expression that represents an actual value.</source>
          <target state="translated">&lt;em&gt;値式は、&lt;/em&gt;実際の値を表す式です。</target>
        </trans-unit>
        <trans-unit id="e6fd1c9fb448dc3050e431f7efdd6fccf7fb69e9" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;variable&lt;/em&gt; is a component of a stack frame, either a named function parameter, an anonymous &lt;a href=&quot;expressions#temporaries&quot;&gt;temporary&lt;/a&gt;, or a named local variable.</source>
          <target state="translated">&lt;em&gt;変数は、&lt;/em&gt;スタックフレームの構成要素、いずれかの名前の関数のパラメータ、匿名で&lt;a href=&quot;expressions#temporaries&quot;&gt;の一時的な&lt;/a&gt;、または名前のローカル変数。</target>
        </trans-unit>
        <trans-unit id="729fdc3c2a54819bca891fd0485aedb791a49cea" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;variable&lt;/em&gt; is a component of a stack frame, either a named function parameter, an anonymous &lt;a href=&quot;expressions#temporary-lifetimes&quot;&gt;temporary&lt;/a&gt;, or a named local variable.</source>
          <target state="translated">&lt;em&gt;変数は、&lt;/em&gt;スタックフレームの構成要素、いずれかの名前の関数のパラメータ、匿名で&lt;a href=&quot;expressions#temporary-lifetimes&quot;&gt;の一時的な&lt;/a&gt;、または名前のローカル変数。</target>
        </trans-unit>
        <trans-unit id="81028e39252e1de4d0939b21f1ccc9432b693d6d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;vector&lt;/em&gt; allows you to store a variable number of values next to each other.</source>
          <target state="translated">&lt;em&gt;ベクターは、&lt;/em&gt;あなたが隣同士に値の可変数を格納することができます。</target>
        </trans-unit>
        <trans-unit id="cbf31b3f11b4472e6a3c452469774ef2fe901798" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;whitespace escape&lt;/em&gt; is one of the characters &lt;code&gt;U+006E&lt;/code&gt; (&lt;code&gt;n&lt;/code&gt;), &lt;code&gt;U+0072&lt;/code&gt; (&lt;code&gt;r&lt;/code&gt;), or &lt;code&gt;U+0074&lt;/code&gt; (&lt;code&gt;t&lt;/code&gt;), denoting the Unicode values &lt;code&gt;U+000A&lt;/code&gt; (LF), &lt;code&gt;U+000D&lt;/code&gt; (CR) or &lt;code&gt;U+0009&lt;/code&gt; (HT) respectively.</source>
          <target state="translated">&lt;em&gt;空白のエスケープは、&lt;/em&gt;文字の一つである &lt;code&gt;U+006E&lt;/code&gt; （ &lt;code&gt;n&lt;/code&gt; ）、 &lt;code&gt;U+0072&lt;/code&gt; （ &lt;code&gt;r&lt;/code&gt; ）、または &lt;code&gt;U+0074&lt;/code&gt; （ &lt;code&gt;t&lt;/code&gt; ユニコード値表す） &lt;code&gt;U+000A&lt;/code&gt; （LF）、 &lt;code&gt;U+000D&lt;/code&gt; （CR）または &lt;code&gt;U+0009&lt;/code&gt; （HT）それぞれ。</target>
        </trans-unit>
        <trans-unit id="733e62321cc2dbb502882e64ee8c595f1cf223e3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;whitespace escape&lt;/em&gt; is one of the characters &lt;code&gt;U+006E&lt;/code&gt; (&lt;code&gt;n&lt;/code&gt;), &lt;code&gt;U+0072&lt;/code&gt; (&lt;code&gt;r&lt;/code&gt;), or &lt;code&gt;U+0074&lt;/code&gt; (&lt;code&gt;t&lt;/code&gt;), denoting the bytes values &lt;code&gt;0x0A&lt;/code&gt; (ASCII LF), &lt;code&gt;0x0D&lt;/code&gt; (ASCII CR) or &lt;code&gt;0x09&lt;/code&gt; (ASCII HT) respectively.</source>
          <target state="translated">&lt;em&gt;空白のエスケープは、&lt;/em&gt;文字の一つである &lt;code&gt;U+006E&lt;/code&gt; （ &lt;code&gt;n&lt;/code&gt; ）、 &lt;code&gt;U+0072&lt;/code&gt; （ &lt;code&gt;r&lt;/code&gt; ）、または &lt;code&gt;U+0074&lt;/code&gt; （ &lt;code&gt;t&lt;/code&gt; バイト値を表す） &lt;code&gt;0x0A&lt;/code&gt; （ASCII LF）、 &lt;code&gt;0x0D&lt;/code&gt; の（ASCII CR）または &lt;code&gt;0x09&lt;/code&gt; の（ASCII HTを）それぞれ。</target>
        </trans-unit>
        <trans-unit id="17736723b13336b3d27ceb298ec5fb02952febad" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;workspace&lt;/em&gt; is a set of packages that share the same &lt;em&gt;Cargo.lock&lt;/em&gt; and output directory. Let&amp;rsquo;s make a project using a workspace&amp;mdash;we&amp;rsquo;ll use trivial code so we can concentrate on the structure of the workspace. There are multiple ways to structure a workspace; we&amp;rsquo;re going to show one common way. We&amp;rsquo;ll have a workspace containing a binary and two libraries. The binary, which will provide the main functionality, will depend on the two libraries. One library will provide an &lt;code&gt;add_one&lt;/code&gt; function, and a second library an &lt;code&gt;add_two&lt;/code&gt; function. These three crates will be part of the same workspace. We&amp;rsquo;ll start by creating a new directory for the workspace:</source>
          <target state="translated">&lt;em&gt;ワークスペースは、&lt;/em&gt;同じ共有パッケージのセットです&lt;em&gt;Cargo.lock&lt;/em&gt;と出力ディレクトリを。ワークスペースを使用してプロジェクトを作成してみましょう。簡単なコードを使用して、ワークスペースの構造に集中できるようにします。ワークスペースを構成する方法はいくつかあります。 1つの一般的な方法を示します。バイナリと2つのライブラリを含むワークスペースがあります。主な機能を提供するバイナリは、2つのライブラリに依存します。 1つのライブラリは &lt;code&gt;add_one&lt;/code&gt; 関数を提供し、2番目のライブラリは &lt;code&gt;add_two&lt;/code&gt; 関数を提供します。これらの3つの木枠は、同じワークスペースの一部になります。まず、ワークスペース用の新しいディレクトリを作成します。</target>
        </trans-unit>
        <trans-unit id="57b97a971f9a5924055674cfb5ecccdeda84f005" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;multiprocessor&lt;/strong&gt; system executing multiple hardware threads at the same time: In multi-threaded scenarios, you can use two kinds of primitives to deal with synchronization:</source>
          <target state="translated">&lt;strong&gt;マルチ&lt;/strong&gt;同時に複数のハードウェアスレッドを実行するシステムは、マルチスレッドのシナリオでは、同期化に対処するプリミティブの二種類を使用することができます。</target>
        </trans-unit>
        <trans-unit id="9915cb86be4513e2479c88bd6630c4bace88619c" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;send&lt;/strong&gt; operation can only fail if the receiving end of a channel is disconnected, implying that the data could never be received. The error contains the data being sent as a payload so it can be recovered.</source>
          <target state="translated">&lt;strong&gt;送信&lt;/strong&gt;チャネルの受信側がデータを受信することはないことができることを意味している、切断された場合の動作にのみ失敗する可能性があります。エラーには、ペイロードとして送信されるデータが含まれているため、回復できます。</target>
        </trans-unit>
        <trans-unit id="45d6b0e56e209127760ab52ba9ab193c0dce03db" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;single processor&lt;/strong&gt; executing instructions &lt;a href=&quot;https://en.wikipedia.org/wiki/Out-of-order_execution&quot;&gt;out-of-order&lt;/a&gt;: Modern CPUs are capable of &lt;a href=&quot;https://en.wikipedia.org/wiki/Superscalar_processor&quot;&gt;superscalar&lt;/a&gt; execution, i.e., multiple instructions might be executing at the same time, even though the machine code describes a sequential process.</source>
          <target state="translated">&lt;strong&gt;単一のプロセッサ&lt;/strong&gt;命令を実行する&lt;a href=&quot;https://en.wikipedia.org/wiki/Out-of-order_execution&quot;&gt;アウトオブオーダー&lt;/a&gt;：現代CPUは可能である&lt;a href=&quot;https://en.wikipedia.org/wiki/Superscalar_processor&quot;&gt;スーパースカラー&lt;/a&gt;実行、すなわち、複数の命令は、マシンコードがシーケンシャルプロセスを記述していても、同時に実行されるかもしれません。</target>
        </trans-unit>
        <trans-unit id="f80e6281478ac21b10d3f64a5db5116d11300661" translate="yes" xml:space="preserve">
          <source>A B-Tree instead makes each node contain B-1 to 2B-1 elements in a contiguous array. By doing this, we reduce the number of allocations by a factor of B, and improve cache efficiency in searches. However, this does mean that searches will have to do &lt;em&gt;more&lt;/em&gt; comparisons on average. The precise number of comparisons depends on the node search strategy used. For optimal cache efficiency, one could search the nodes linearly. For optimal comparisons, one could search the node using binary search. As a compromise, one could also perform a linear search that initially only checks every i&lt;sup&gt;th&lt;/sup&gt; element for some choice of i.</source>
          <target state="translated">代わりにBツリーは、各ノードに連続した配列のB-1から2B-1の要素を含めます。これにより、割り当て数をB倍に削減し、検索のキャッシュ効率を向上させます。ただし、これは平均して&lt;em&gt;より多くの&lt;/em&gt;比較を行う必要があることを意味します。比較の正確な数は、使用するノード検索戦略によって異なります。最適なキャッシュ効率のために、ノードを線形的に検索することができます。最適な比較のために、バイナリサーチを使用してノードを検索できます。妥協案として、iの選択について最初はすべてのi &lt;sup&gt;番目の&lt;/sup&gt;要素のみをチェックする線形検索を実行することもできます。</target>
        </trans-unit>
        <trans-unit id="4c64fcf1b73694ea8bba81897d2a64705afb1b18" translate="yes" xml:space="preserve">
          <source>A C-variadic type is used to give an undefined number of parameters to a given function (like &lt;code&gt;printf&lt;/code&gt; in C). The equivalent in Rust would be to use macros directly (like &lt;code&gt;println!&lt;/code&gt; for example).</source>
          <target state="translated">C可変個引数型は、特定の関数（Cの &lt;code&gt;printf&lt;/code&gt; など）に未定義の数のパラメーターを与えるために使用されます。Rustでの同等の機能は、マクロを直接使用することです（たとえば、 &lt;code&gt;println!&lt;/code&gt; など）。</target>
        </trans-unit>
        <trans-unit id="c719a71ad064f07814cb183dc83cacff56d42170" translate="yes" xml:space="preserve">
          <source>A Closer Look at an HTTP Request</source>
          <target state="translated">HTTP リクエストの詳細</target>
        </trans-unit>
        <trans-unit id="225f2cd7742ef94df62bae5174a9097b85507248" translate="yes" xml:space="preserve">
          <source>A Condition Variable</source>
          <target state="translated">条件変数</target>
        </trans-unit>
        <trans-unit id="e89d14f838ea1a71651772640c4009592aced676" translate="yes" xml:space="preserve">
          <source>A Rust binary or library.</source>
          <target state="translated">Rust のバイナリまたはライブラリ。</target>
        </trans-unit>
        <trans-unit id="16eac1f550799edbb7e48476dda921af52e9a679" translate="yes" xml:space="preserve">
          <source>A Rust program has identical meaning if each whitespace element is replaced with any other legal whitespace element, such as a single space character.</source>
          <target state="translated">Rust プログラムは、各ホワイトスペース要素がスペース 1 文字などの他の合法的なホワイトスペース要素で置き換えられている場合、同一の意味を持ちます。</target>
        </trans-unit>
        <trans-unit id="3436eb9d1ac524996565fc93c80cf6376e000505" translate="yes" xml:space="preserve">
          <source>A Rust source file describes a module, the name and location of which &amp;mdash; in the module tree of the current crate &amp;mdash; are defined from outside the source file: either by an explicit &lt;a href=&quot;items/modules&quot;&gt;&lt;em&gt;Module&lt;/em&gt;&lt;/a&gt; item in a referencing source file, or by the name of the crate itself. Every source file is a module, but not every module needs its own source file: &lt;a href=&quot;items/modules&quot;&gt;module definitions&lt;/a&gt; can be nested within one file.</source>
          <target state="translated">Rustソースファイルはモジュールを記述します。その名前と場所（現在のクレートのモジュールツリー内）は、ソースファイルの外部から定義されます。参照するソースファイルの明示的な&lt;a href=&quot;items/modules&quot;&gt;&lt;em&gt;Module&lt;/em&gt;&lt;/a&gt;アイテム、または木枠自体。すべてのソースファイルはモジュールですが、すべてのモジュールが独自のソースファイルを必要とするわけではありません。&lt;a href=&quot;items/modules&quot;&gt;モジュール定義&lt;/a&gt;は1つのファイル内にネストできます。</target>
        </trans-unit>
        <trans-unit id="7e4ee862d170940577240b6a363de9c90118288a" translate="yes" xml:space="preserve">
          <source>A Shortcut for Propagating Errors: the &lt;code id=&quot;a-shortcut-for-propagating-errors-the--operator&quot;&gt;?&lt;/code&gt; Operator</source>
          <target state="translated">エラーを伝播するためのショートカット： &lt;code id=&quot;a-shortcut-for-propagating-errors-the--operator&quot;&gt;?&lt;/code&gt; オペレーター</target>
        </trans-unit>
        <trans-unit id="e0701ba8496c6c0ce0663c50dfed3d1742ffe428" translate="yes" xml:space="preserve">
          <source>A TCP socket server, listening for connections.</source>
          <target state="translated">TCP ソケットサーバで、接続をリッスンします。</target>
        </trans-unit>
        <trans-unit id="18b391c1b0a22ff1e173b47c159e749d6face6b8" translate="yes" xml:space="preserve">
          <source>A TCP stream between a local and a remote socket.</source>
          <target state="translated">ローカルとリモートのソケット間の TCP ストリーム。</target>
        </trans-unit>
        <trans-unit id="14cd46b40ffb5428999e053c5d3b3c28ef9b4547" translate="yes" xml:space="preserve">
          <source>A Touch of Refactoring</source>
          <target state="translated">リファクタリングのタッチ</target>
        </trans-unit>
        <trans-unit id="f8b80e8d44eb439e0e6a949110529d41c8e00ad6" translate="yes" xml:space="preserve">
          <source>A Tour of The Rust Standard Library</source>
          <target state="translated">ラスト・スタンダード・ライブラリーを巡る</target>
        </trans-unit>
        <trans-unit id="816b40a1a34bc0276678819c021264566903408c" translate="yes" xml:space="preserve">
          <source>A UDP socket.</source>
          <target state="translated">UDP ソケットです。</target>
        </trans-unit>
        <trans-unit id="276e8a17fbe2956e663b37ba194fe05fa5a8f2c4" translate="yes" xml:space="preserve">
          <source>A UTF-8 encoded, growable string.</source>
          <target state="translated">UTF-8でエンコードされた成長可能な文字列。</target>
        </trans-unit>
        <trans-unit id="9de745a43beb358e074abd87790ad347e9b21ca2" translate="yes" xml:space="preserve">
          <source>A UTF-8&amp;ndash;encoded, growable string.</source>
          <target state="translated">UTF-8でエンコードされた拡張可能な文字列。</target>
        </trans-unit>
        <trans-unit id="bb20973ca0b74c01c90760f89fd1e1ce6ddd0490" translate="yes" xml:space="preserve">
          <source>A Unix datagram socket.</source>
          <target state="translated">Unix データグラムソケット。</target>
        </trans-unit>
        <trans-unit id="735c3a01ab88f3b77275bbda413fc5d0f8e00e4c" translate="yes" xml:space="preserve">
          <source>A Unix socket Ancillary data struct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a23c9f511bfc020ca8a27e2556501e3c327d1d73" translate="yes" xml:space="preserve">
          <source>A Unix stream socket.</source>
          <target state="translated">Unix ストリームソケット。</target>
        </trans-unit>
        <trans-unit id="3ad52f3aeb1d324427854f3ea2a73655c8ec06e9" translate="yes" xml:space="preserve">
          <source>A Use Case for Interior Mutability: Mock Objects</source>
          <target state="translated">内部変異性のユースケース モックオブジェクト</target>
        </trans-unit>
        <trans-unit id="822d2ee37fadc9a2c447d0ca642e7e4a4d011579" translate="yes" xml:space="preserve">
          <source>A Windows path prefix, e.g., &lt;code&gt;C:&lt;/code&gt; or &lt;code&gt;\\server\share&lt;/code&gt;.</source>
          <target state="translated">Windowsパスプレフィックス（例 &lt;code&gt;C:&lt;/code&gt; または &lt;code&gt;\\server\share&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="37a911d0c1b6b4316ddb2ac619c44257424a4bb3" translate="yes" xml:space="preserve">
          <source>A Windows path prefix, e.g., &lt;code&gt;C:&lt;/code&gt; or &lt;code&gt;\server\share&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;C:&lt;/code&gt; や &lt;code&gt;\server\share&lt;/code&gt; などのWindowsパスプレフィックス。</target>
        </trans-unit>
        <trans-unit id="41a63844a54d0452136942153b7bfc3f9e8d7950" translate="yes" xml:space="preserve">
          <source>A backtrace has been captured and the &lt;code&gt;Backtrace&lt;/code&gt; should print reasonable information when rendered.</source>
          <target state="translated">バックトレースがキャプチャされており、 &lt;code&gt;Backtrace&lt;/code&gt; レンダリングされたときに、合理的な情報を印刷しなければなりません。</target>
        </trans-unit>
        <trans-unit id="063c41d44c26a8e514637789567756dedf001744" translate="yes" xml:space="preserve">
          <source>A backtrace is typically quite handy to attach to errors (e.g. types implementing &lt;code&gt;std::error::Error&lt;/code&gt;) to get a causal chain of where an error was generated.</source>
          <target state="translated">バックトレースは通常、エラー（たとえば、 &lt;code&gt;std::error::Error&lt;/code&gt; 実装するタイプ）にアタッチして、エラーが生成された場所の因果関係を取得するのに非常に便利です。</target>
        </trans-unit>
        <trans-unit id="ff93a614690d1d51c188c5129e768aec7cd0c763" translate="yes" xml:space="preserve">
          <source>A barrier enables multiple threads to synchronize the beginning of some computation.</source>
          <target state="translated">バリアは、複数のスレッドがいくつかの計算の開始を同期させることを可能にします。</target>
        </trans-unit>
        <trans-unit id="c1ac9e66093aa4ca440868ee501f91a3a0e906b0" translate="yes" xml:space="preserve">
          <source>A barrier will block &lt;code&gt;n&lt;/code&gt;-1 threads which call &lt;a href=&quot;#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; and then wake up all threads at once when the &lt;code&gt;n&lt;/code&gt;th thread calls &lt;a href=&quot;#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">バリアは、&lt;a href=&quot;#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;を呼び出す &lt;code&gt;n&lt;/code&gt; -1スレッドをブロックし、 &lt;code&gt;n&lt;/code&gt; 番目のスレッドが&lt;a href=&quot;#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; を&lt;/a&gt;呼び出すと、すべてのスレッドを一度に起動します。</target>
        </trans-unit>
        <trans-unit id="62ccc167e0423bac501b2cd57e5b7720dec15103" translate="yes" xml:space="preserve">
          <source>A barrier will block &lt;code&gt;n&lt;/code&gt;-1 threads which call &lt;a href=&quot;struct.barrier#method.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt; and then wake up all threads at once when the &lt;code&gt;n&lt;/code&gt;th thread calls &lt;a href=&quot;struct.barrier#method.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">バリアは、&lt;a href=&quot;struct.barrier#method.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt;を呼び出す &lt;code&gt;n&lt;/code&gt; -1個のスレッドをブロックし、 &lt;code&gt;n&lt;/code&gt; 番目のスレッドが&lt;a href=&quot;struct.barrier#method.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; を&lt;/a&gt;呼び出すと、すべてのスレッドを一度にウェイクアップします。</target>
        </trans-unit>
        <trans-unit id="58cdbd4e4749375a003884d9f4eb272538b31a8e" translate="yes" xml:space="preserve">
          <source>A basic example:</source>
          <target state="translated">基本的な例です。</target>
        </trans-unit>
        <trans-unit id="b427e17a0965dfac7d96b4ee22a549d95854674d" translate="yes" xml:space="preserve">
          <source>A basic string declaration of &lt;code&gt;&amp;amp;str&lt;/code&gt; type:</source>
          <target state="translated">&lt;code&gt;&amp;amp;str&lt;/code&gt; タイプの基本的な文字列宣言：</target>
        </trans-unit>
        <trans-unit id="e58e2e213f635868b8917c1f64d97bcd94087385" translate="yes" xml:space="preserve">
          <source>A binary assignment operator like &lt;code&gt;+=&lt;/code&gt; or &lt;code&gt;^=&lt;/code&gt; was applied to a type that doesn't support it.</source>
          <target state="translated">&lt;code&gt;+=&lt;/code&gt; や &lt;code&gt;^=&lt;/code&gt; ようなバイナリ代入演算子が、それをサポートしない型に適用されました。</target>
        </trans-unit>
        <trans-unit id="807a8b4172841ae84d2493b466a14c239a712c9e" translate="yes" xml:space="preserve">
          <source>A binary can only have one entry point, and by default that entry point is the &lt;code&gt;main()&lt;/code&gt; function. If there are multiple instances of this function, please rename one of them.</source>
          <target state="translated">バイナリは1つのエントリポイントしか持てません。デフォルトでは、そのエントリポイントは &lt;code&gt;main()&lt;/code&gt; 関数です。この関数のインスタンスが複数ある場合は、そのうちの1つを名前変更してください。</target>
        </trans-unit>
        <trans-unit id="5f95a7b46c7703730f6563de2663542b39249317" translate="yes" xml:space="preserve">
          <source>A binary can only have one entry point, and by default that entry point is the function &lt;code&gt;main()&lt;/code&gt;. If there are multiple such functions, please rename one.</source>
          <target state="translated">バイナリはエントリポイントを1つだけ持つことができ、デフォルトではそのエントリポイントは関数 &lt;code&gt;main()&lt;/code&gt; です。そのような機能が複数ある場合は、名前を変更してください。</target>
        </trans-unit>
        <trans-unit id="66f8440b5cbe5979ef5cd4aca43bf502a1ba0914" translate="yes" xml:space="preserve">
          <source>A binary operation was attempted on a type which doesn't support it.</source>
          <target state="translated">サポートされていない型でバイナリ操作が試みられました。</target>
        </trans-unit>
        <trans-unit id="b38f665f61e73d6f968e8571206665e15cc36346" translate="yes" xml:space="preserve">
          <source>A binary operation was attempted on a type which doesn't support it. Erroneous code example:</source>
          <target state="translated">サポートされていない型でバイナリ操作が試みられました。誤ったコード例です。</target>
        </trans-unit>
        <trans-unit id="aa172e5751306c59c090e9db789e410971427e9e" translate="yes" xml:space="preserve">
          <source>A binding shadowed something it shouldn't.</source>
          <target state="translated">縛りが何かに影を落としていた。</target>
        </trans-unit>
        <trans-unit id="2196fa2a21cb36f1296a2eab8560f7f044fc56a6" translate="yes" xml:space="preserve">
          <source>A block expression as the tail expression of another block expression.</source>
          <target state="translated">別のブロック表現の末尾表現としてのブロック表現。</target>
        </trans-unit>
        <trans-unit id="a693c9a42f3c8985b5be041d70547d78d1d2e744" translate="yes" xml:space="preserve">
          <source>A block of code can be prefixed with the &lt;code&gt;unsafe&lt;/code&gt; keyword to permit &lt;a href=&quot;../unsafety&quot;&gt;unsafe operations&lt;/a&gt;. Examples:</source>
          <target state="translated">&lt;a href=&quot;../unsafety&quot;&gt;安全でない操作&lt;/a&gt;を許可するために、コードのブロックの前に &lt;code&gt;unsafe&lt;/code&gt; キーワードを付けることができます。例：</target>
        </trans-unit>
        <trans-unit id="3f1de3ecbc17ea9a1f67c2ee7ad38362f83951f6" translate="yes" xml:space="preserve">
          <source>A block of code can be prefixed with the &lt;code&gt;unsafe&lt;/code&gt; keyword, to permit calling &lt;code&gt;unsafe&lt;/code&gt; functions or dereferencing raw pointers within a safe function.</source>
          <target state="translated">コードのブロックの前に &lt;code&gt;unsafe&lt;/code&gt; キーワードを付けると、安全で &lt;code&gt;unsafe&lt;/code&gt; 関数を呼び出したり、安全な関数内で生のポインタを逆参照したりできます。</target>
        </trans-unit>
        <trans-unit id="e2aaacb371035dfa3169004d8d112f1e5b1ca71a" translate="yes" xml:space="preserve">
          <source>A blog post starts as an empty draft.</source>
          <target state="translated">ブログ記事は空の下書きから始まります。</target>
        </trans-unit>
        <trans-unit id="beb16f573b8715d8a98aa06e002398f8060629f2" translate="yes" xml:space="preserve">
          <source>A boolean type which can be safely shared between threads.</source>
          <target state="translated">スレッド間で安全に共有できるブール型。</target>
        </trans-unit>
        <trans-unit id="eb779fca6863a6a0d358d8e696c27d09f35c87e4" translate="yes" xml:space="preserve">
          <source>A borrow of a constant containing interior mutability was attempted.</source>
          <target state="translated">内部変異性を含む定数の借用を試みた。</target>
        </trans-unit>
        <trans-unit id="3d64914b686b3e740569b7a037982d02419990a4" translate="yes" xml:space="preserve">
          <source>A borrow of a constant containing interior mutability was attempted. Erroneous code example:</source>
          <target state="translated">内部変異性を含む定数の借用が試みられました。誤ったコード例です。</target>
        </trans-unit>
        <trans-unit id="6c3704913d69bb40474f716695cc894d7bfa528c" translate="yes" xml:space="preserve">
          <source>A borrow of a thread-local variable was made inside a function which outlived the lifetime of the function.</source>
          <target state="translated">スレッドローカル変数の借用が関数内で行われましたが、その関数の寿命が切れてしまいました。</target>
        </trans-unit>
        <trans-unit id="f237c3c1919eddd418933b1a63f322a0d0d2a0eb" translate="yes" xml:space="preserve">
          <source>A borrowed value was moved out.</source>
          <target state="translated">借りた値が外に出た。</target>
        </trans-unit>
        <trans-unit id="9b2fc820fbc3d301d2c71b19ff6713c60dff7377" translate="yes" xml:space="preserve">
          <source>A borrowed variable was used by a closure.</source>
          <target state="translated">借りた変数はクロージャで使用されていました。</target>
        </trans-unit>
        <trans-unit id="c83fc1310c1c04b54cc7e1f86e92066f4da726ab" translate="yes" xml:space="preserve">
          <source>A borrowed variable was used by a closure. Example of erroneous code:</source>
          <target state="translated">借りた変数がクロージャで使用されていました。誤ったコードの例。</target>
        </trans-unit>
        <trans-unit id="b7c0d93da848c216d8d60ef97d23c6ae7dfef33f" translate="yes" xml:space="preserve">
          <source>A break expression is normally associated with the innermost loop enclosing the &lt;code&gt;break&lt;/code&gt; but a label can be used to specify which enclosing loop is affected.</source>
          <target state="translated">ブレーク式は通常、 &lt;code&gt;break&lt;/code&gt; を囲む最も内側のループに関連付けられていますが、ラベルを使用して、影響を受ける囲みループを指定できます。</target>
        </trans-unit>
        <trans-unit id="4584a71b04a4125f9586dd4d0599984c41f8d406" translate="yes" xml:space="preserve">
          <source>A broadcast address has all octets set to 255 as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc919&quot;&gt;IETF RFC 919&lt;/a&gt;.</source>
          <target state="translated">ブロードキャストアドレスでは、&lt;a href=&quot;https://tools.ietf.org/html/rfc919&quot;&gt;IETF RFC 919で&lt;/a&gt;定義されているように、すべてのオクテットが255に設定されています。</target>
        </trans-unit>
        <trans-unit id="a5ed95e144c4e88ac8aa93a227c762654f2cb478" translate="yes" xml:space="preserve">
          <source>A buffer that's too small:</source>
          <target state="translated">狭すぎるバッファ。</target>
        </trans-unit>
        <trans-unit id="4b481eff295b8689efc0884b27cfb033e7e5efe6" translate="yes" xml:space="preserve">
          <source>A buffer type used with &lt;code&gt;Read::read_vectored&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Read::read_vectored&lt;/code&gt; 使用されるバッファタイプ。</target>
        </trans-unit>
        <trans-unit id="bc33ba1a0c8fc7e0d6803cc242c896b07605dc58" translate="yes" xml:space="preserve">
          <source>A buffer type used with &lt;code&gt;Write::write_vectored&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Write::write_vectored&lt;/code&gt; 使用されるバッファタイプ。</target>
        </trans-unit>
        <trans-unit id="9634bddc5eaddedf795f81dbe84a65e742c0b750" translate="yes" xml:space="preserve">
          <source>A builder for computing where in a HashMap a key-value pair would be stored.</source>
          <target state="translated">HashMap内のキーと値のペアが格納される場所を計算するためのビルダーです。</target>
        </trans-unit>
        <trans-unit id="164e9f9ed41b273049862041cd75d7cccf4e70e8" translate="yes" xml:space="preserve">
          <source>A builder used to create directories in various manners.</source>
          <target state="translated">様々なマナーでディレクトリを作成するために使用されるビルダーです。</target>
        </trans-unit>
        <trans-unit id="d9b7dd70756681f35180b19cd1bfebd1be340c71" translate="yes" xml:space="preserve">
          <source>A builtin-macro was defined more than once.</source>
          <target state="translated">ビルトインマクロが複数回定義されていました。</target>
        </trans-unit>
        <trans-unit id="3712794ff88bfb37526db3c27354e391cdfb3531" translate="yes" xml:space="preserve">
          <source>A by-value &lt;a href=&quot;../primitive.array&quot;&gt;array&lt;/a&gt; iterator.</source>
          <target state="translated">値による&lt;a href=&quot;../primitive.array&quot;&gt;配列&lt;/a&gt;イテレータ。</target>
        </trans-unit>
        <trans-unit id="db1dde52635a5e1dfcc3c9c412ee03038fd5a1fd" translate="yes" xml:space="preserve">
          <source>A byte constant wasn't correctly ended.</source>
          <target state="translated">バイト定数が正しく終了しませんでした。</target>
        </trans-unit>
        <trans-unit id="358ac47a7f574535f0a6c2b6627900a1db482bcb" translate="yes" xml:space="preserve">
          <source>A call to &lt;code&gt;Drop::drop&lt;/code&gt; for that value, if this special &lt;code&gt;Drop&lt;/code&gt; trait is implemented for its type.</source>
          <target state="translated">この特別な &lt;code&gt;Drop&lt;/code&gt; 特性がそのタイプに実装されている場合、その値に対する &lt;code&gt;Drop::drop&lt;/code&gt; 呼び出し。</target>
        </trans-unit>
        <trans-unit id="6f6bbc745c6c0811da9c03d5975cfda20a1ec075" translate="yes" xml:space="preserve">
          <source>A call to &lt;code&gt;park&lt;/code&gt; does not guarantee that the thread will remain parked forever, and callers should be prepared for this possibility.</source>
          <target state="translated">&lt;code&gt;park&lt;/code&gt; への呼び出しは、スレッドが永久にパークされたままであることを保証するものではなく、呼び出し側はこの可能性に備える必要があります。</target>
        </trans-unit>
        <trans-unit id="310114efe1d071325aac9ee697835f3fab748547" translate="yes" xml:space="preserve">
          <source>A captured OS thread stack backtrace.</source>
          <target state="translated">キャプチャされた OS スレッドスタックのバックトレース。</target>
        </trans-unit>
        <trans-unit id="068d1bfcec9a1ae7628a6bb97579dd58498f1145" translate="yes" xml:space="preserve">
          <source>A captured variable in a closure may not live long enough.</source>
          <target state="translated">クロージャ内のキャプチャされた変数は、十分に長くは生きられないかもしれません。</target>
        </trans-unit>
        <trans-unit id="87031d3ddac7dc2da2592a12784d3310334c67dd" translate="yes" xml:space="preserve">
          <source>A cast between a thin and a fat pointer was attempted.</source>
          <target state="translated">細いポインターと太いポインターの間にキャストを入れようとした。</target>
        </trans-unit>
        <trans-unit id="fa8c8681d28baf8dc8f1366a76e05505996e07da" translate="yes" xml:space="preserve">
          <source>A cast to &lt;code&gt;char&lt;/code&gt; was attempted on a type other than &lt;code&gt;u8&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; へのキャストが &lt;code&gt;u8&lt;/code&gt; 以外のタイプで試行されました。</target>
        </trans-unit>
        <trans-unit id="7d806d6a4232967c179bddb0726f09f0a0c1cae9" translate="yes" xml:space="preserve">
          <source>A cast to an unsized type was attempted.</source>
          <target state="translated">サイズのないタイプへのキャストを試みました。</target>
        </trans-unit>
        <trans-unit id="8ca946f31b782b50520401ae5f6d2242f47dbf2a" translate="yes" xml:space="preserve">
          <source>A cell which can be written to only once.</source>
          <target state="translated">一度だけ書き込めるセル。</target>
        </trans-unit>
        <trans-unit id="7ab45f97583623706555b717305df511d6d6755b" translate="yes" xml:space="preserve">
          <source>A channel in programming has two halves: a transmitter and a receiver. The transmitter half is the upstream location where you put rubber ducks into the river, and the receiver half is where the rubber duck ends up downstream. One part of your code calls methods on the transmitter with the data you want to send, and another part checks the receiving end for arriving messages. A channel is said to be &lt;em&gt;closed&lt;/em&gt; if either the transmitter or receiver half is dropped.</source>
          <target state="translated">プログラミングのチャネルには、送信機と受信機の2つの半分があります。トランスミッターの半分はゴム製のアヒルを川に入れる上流の場所であり、レシーバーの半分はゴム製のアヒルが下流に到達する場所です。コードの一部では、送信するデータを使用してトランスミッターのメソッドを呼び出し、別の部分では、受信側で到着メッセージを確認します。トランスミッターまたはレシーバーの半分がドロップされると、チャネルは&lt;em&gt;閉じられた&lt;/em&gt;と言います。</target>
        </trans-unit>
        <trans-unit id="9b271c9cb4969ff9e8017b48dea5ee7ea287981f" translate="yes" xml:space="preserve">
          <source>A character literal wasn't ended with a quote.</source>
          <target state="translated">文字リテラルは引用で終わらなかった。</target>
        </trans-unit>
        <trans-unit id="730c231d230d4d65e9a1cdedca314d8b69b7866c" translate="yes" xml:space="preserve">
          <source>A character type.</source>
          <target state="translated">文字の種類。</target>
        </trans-unit>
        <trans-unit id="195b8c50281f62fd27ad7158cd7ae79ac4f9afca" translate="yes" xml:space="preserve">
          <source>A classification of floating point numbers.</source>
          <target state="translated">浮動小数点数の分類。</target>
        </trans-unit>
        <trans-unit id="dea8ae8b6b70c73b2cce436aaeecb02e010d0c2b" translate="yes" xml:space="preserve">
          <source>A clobber was surrounded by braces in the &lt;code&gt;llvm_asm&lt;/code&gt; macro.</source>
          <target state="translated">&lt;code&gt;llvm_asm&lt;/code&gt; マクロでは、中括弧で囲まれています。</target>
        </trans-unit>
        <trans-unit id="52397aa21f3cbabb1bcadcab29fd5a79bd3be6ee" translate="yes" xml:space="preserve">
          <source>A clone-on-write smart pointer.</source>
          <target state="translated">クローンオンライトのスマートポインタ。</target>
        </trans-unit>
        <trans-unit id="17d70d4cf5c4adf5f0753809fb9cb729a2f8379d" translate="yes" xml:space="preserve">
          <source>A closure expression denotes a function that maps a list of parameters onto the expression that follows the parameters. Just like a &lt;a href=&quot;../statements#let-statements&quot;&gt;&lt;code&gt;let&lt;/code&gt; binding&lt;/a&gt;, the parameters are irrefutable &lt;a href=&quot;../patterns&quot;&gt;patterns&lt;/a&gt;, whose type annotation is optional and will be inferred from context if not given. Each closure expression has a unique, anonymous type.</source>
          <target state="translated">クロージャー式は、パラメーターのリストを、パラメーターに続く式にマップする関数を示します。&lt;a href=&quot;../statements#let-statements&quot;&gt; &lt;code&gt;let&lt;/code&gt; バインディング&lt;/a&gt;と同様に、パラメーターは反駁できない&lt;a href=&quot;../patterns&quot;&gt;パターン&lt;/a&gt;であり、その型注釈はオプションであり、指定されない場合はコンテキストから推測されます。各クロージャー式には、一意の匿名型があります。</target>
        </trans-unit>
        <trans-unit id="229f7ae12c2338583566d98b6347b250aaf7fe51" translate="yes" xml:space="preserve">
          <source>A closure has been used as &lt;code&gt;static&lt;/code&gt;.</source>
          <target state="translated">クロージャーは &lt;code&gt;static&lt;/code&gt; として使用されています。</target>
        </trans-unit>
        <trans-unit id="a9e518044a28e364a6d5caf649a49a37d36a9e44" translate="yes" xml:space="preserve">
          <source>A closure is &lt;a href=&quot;../special-types-and-traits#clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; if it does not capture any values by unique immutable or mutable reference, and if all values it captures by copy or move are &lt;a href=&quot;../special-types-and-traits#clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, respectively.</source>
          <target state="translated">閉鎖はある&lt;a href=&quot;../special-types-and-traits#clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;../special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;、それが独特の不変または可変参照することにより任意の値をキャプチャしていない場合は、コピーまたは移動することによって、それはキャプチャすべての値がある場合、&lt;a href=&quot;../special-types-and-traits#clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;../special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;、それぞれ。</target>
        </trans-unit>
        <trans-unit id="f47eb76e99123d39021af1de1b77a6fbf1ed2931" translate="yes" xml:space="preserve">
          <source>A closure is &lt;a href=&quot;../special-types-and-traits#send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt; if all variables captured by non-unique immutable reference are &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;, and all values captured by unique immutable or mutable reference, copy, or move are &lt;a href=&quot;../special-types-and-traits#send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">閉鎖はされて&lt;a href=&quot;../special-types-and-traits#send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt;一意でない不変の参照で撮影したすべての変数がある場合&lt;a href=&quot;../special-types-and-traits#sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt;、および独自の不変または可変の参照、コピー、または移動で撮影したすべての値がされて&lt;a href=&quot;../special-types-and-traits#send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0d261d9dcf84a04b55a505f635cb5d6d0068277d" translate="yes" xml:space="preserve">
          <source>A closure is &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; if all captured variables are &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">キャプチャーされたすべての変数が&lt;a href=&quot;../special-types-and-traits#sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; の&lt;/a&gt;場合、クロージャーは&lt;a href=&quot;../special-types-and-traits#sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="f3dcf856d438dee9833c1d37d61c6e01baf7766e" translate="yes" xml:space="preserve">
          <source>A closure or generator was constructed that references its own type.</source>
          <target state="translated">クロージャまたはジェネレータは、それ自身の型を参照するように構築されました。</target>
        </trans-unit>
        <trans-unit id="3bcd57420ec9a5b5481261d30eb81ca537f99421" translate="yes" xml:space="preserve">
          <source>A closure was used but didn't implement the expected trait.</source>
          <target state="translated">クロージャーを使用したが、期待した形質を実装していなかった。</target>
        </trans-unit>
        <trans-unit id="c9d5fcd074a946b081167d5c176a725de44ced3d" translate="yes" xml:space="preserve">
          <source>A closure which does not move out of any captured variables implements &lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt;, indicating that it can be called by mutable reference.</source>
          <target state="translated">キャプチャされた変数の外に移動しないクロージャーは&lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt; &lt;code&gt;FnMut&lt;/code&gt; を&lt;/a&gt;実装し、変更可能な参照によって呼び出せることを示します。</target>
        </trans-unit>
        <trans-unit id="cd4b51e9607f8ce4ec972f070cc5a727f780aa02" translate="yes" xml:space="preserve">
          <source>A closure which does not mutate or move out of any captured variables implements &lt;a href=&quot;../../std/ops/trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt;, indicating that it can be called by shared reference.</source>
          <target state="translated">キャプチャされた変数を変更または移動しないクロージャーは&lt;a href=&quot;../../std/ops/trait.fn&quot;&gt; &lt;code&gt;Fn&lt;/code&gt; を&lt;/a&gt;実装し、共有参照から呼び出すことができることを示します。</target>
        </trans-unit>
        <trans-unit id="e935c8f48fd175281f69484ea6d8e34c3df1f772" translate="yes" xml:space="preserve">
          <source>A coercion can only occur at certain coercion sites in a program; these are typically places where the desired type is explicit or can be derived by propagation from explicit types (without type inference). Possible coercion sites are:</source>
          <target state="translated">想定される強制の場所は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="3d399a6fb5b1366dacbcbc3c485166cb44a8fe4f" translate="yes" xml:space="preserve">
          <source>A collection of methods that are required to format a message into a stream.</source>
          <target state="translated">メッセージをストリームにフォーマットするために必要なメソッドのコレクション。</target>
        </trans-unit>
        <trans-unit id="2a7f703e336c6bdb6cbae32714276165fd6dcc43" translate="yes" xml:space="preserve">
          <source>A common example is the &lt;code&gt;collect&lt;/code&gt; method on &lt;code&gt;Iterator&lt;/code&gt;. It has a generic type parameter with a &lt;code&gt;FromIterator&lt;/code&gt; bound, which for a &lt;code&gt;char&lt;/code&gt; iterator is implemented by &lt;code&gt;Vec&lt;/code&gt; and &lt;code&gt;String&lt;/code&gt; among others. Consider the following snippet that reverses the characters of a string:</source>
          <target state="translated">一般的な例は、 &lt;code&gt;Iterator&lt;/code&gt; の &lt;code&gt;collect&lt;/code&gt; メソッドです。これには &lt;code&gt;FromIterator&lt;/code&gt; がバインドされたジェネリック型パラメーターがあり、 &lt;code&gt;char&lt;/code&gt; イテレーターの場合、 &lt;code&gt;Vec&lt;/code&gt; や &lt;code&gt;String&lt;/code&gt; などによって実装されます。文字列の文字を逆にする次のスニペットを考えてみましょう：</target>
        </trans-unit>
        <trans-unit id="e2236ceee783d907728a27d889b17b89679caa37" translate="yes" xml:space="preserve">
          <source>A common interface for a class of types.</source>
          <target state="translated">型のクラスの共通インタフェース。</target>
        </trans-unit>
        <trans-unit id="8baf44157a38997462218326dfa5b36c89567539" translate="yes" xml:space="preserve">
          <source>A common interface for a group of types.</source>
          <target state="translated">型のグループに共通のインターフェース。</target>
        </trans-unit>
        <trans-unit id="23bb5a3938b6b7101f14bfe5b204b2401bdf9250" translate="yes" xml:space="preserve">
          <source>A common mis-conception is to think that &quot;unicast link-local addresses start with &lt;code&gt;fe80::&lt;/code&gt;&quot;, but the &lt;a href=&quot;https://tools.ietf.org/html/rfc4291&quot;&gt;IETF RFC 4291&lt;/a&gt; actually defines a stricter format for these addresses:</source>
          <target state="translated">よくある誤解は、「ユニキャストリンクローカルアドレスは &lt;code&gt;fe80::&lt;/code&gt; 始まる」と考えることですが、&lt;a href=&quot;https://tools.ietf.org/html/rfc4291&quot;&gt;IETF RFC 4291は&lt;/a&gt;実際にはこれらのアドレスに対してより厳密な形式を定義しています。</target>
        </trans-unit>
        <trans-unit id="4615ae2634801f990b77ad209e23e9d53e5c0d34" translate="yes" xml:space="preserve">
          <source>A common problem with using return values to indicate errors is that it is easy to ignore the return value, thus failing to handle the error. &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; is annotated with the &lt;code&gt;#[must_use]&lt;/code&gt; attribute, which will cause the compiler to issue a warning when a Result value is ignored. This makes &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; especially useful with functions that may encounter errors but don't otherwise return a useful value.</source>
          <target state="translated">エラーを示すために戻り値を使用する際の一般的な問題は、戻り値を無視しやすいため、エラーの処理に失敗することです。&lt;a href=&quot;enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt;は &lt;code&gt;#[must_use]&lt;/code&gt; 属性で注釈が付けられます。これにより、結果値が無視されたときにコンパイラーが警告を発行します。これにより、エラーが発生する可能性があるが、それ以外の場合は有用な値を返さない関数で、&lt;a href=&quot;enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; が&lt;/a&gt;特に役立ちます。</target>
        </trans-unit>
        <trans-unit id="9e6af95ab7d6f1c50d97f5f2eb1a6e3eebe549bf" translate="yes" xml:space="preserve">
          <source>A common trait for the ability to explicitly duplicate an object.</source>
          <target state="translated">オブジェクトを明示的に複製する能力の共通の特徴。</target>
        </trans-unit>
        <trans-unit id="f3fcc76ff39756ffd2b4cb1d33e25cb209dbe4a4" translate="yes" xml:space="preserve">
          <source>A common use case for &lt;code&gt;spin_loop&lt;/code&gt; is implementing bounded optimistic spinning in a CAS loop in synchronization primitives. To avoid problems like priority inversion, it is strongly recommended that the spin loop is terminated after a finite amount of iterations and an appropriate blocking syscall is made.</source>
          <target state="translated">&lt;code&gt;spin_loop&lt;/code&gt; の一般的な使用例は、同期プリミティブのCASループに制限付きオプティミスティックスピニングを実装することです。優先順位の逆転などの問題を回避するために、有限の反復回数の後にスピンループを終了し、適切なブロッキングシステムコールを実行することを強くお勧めします。</target>
        </trans-unit>
        <trans-unit id="0f3bf37cba543ca385f5031852ec32495e2e84e3" translate="yes" xml:space="preserve">
          <source>A common use case for &lt;code&gt;spin_loop_hint&lt;/code&gt; is implementing bounded optimistic spinning in a CAS loop in synchronization primitives. To avoid problems like priority inversion, it is strongly recommended that the spin loop is terminated after a finite amount of iterations and an appropriate blocking syscall is made.</source>
          <target state="translated">&lt;code&gt;spin_loop_hint&lt;/code&gt; の一般的な使用例は、同期プリミティブのCASループに制限付きの楽観的スピニングを実装することです。優先順位の逆転などの問題を回避するために、有限の反復回数の後にスピンループを終了し、適切なブロッキングシステムコールを実行することを強くお勧めします。</target>
        </trans-unit>
        <trans-unit id="3e2c1919c7a821f5f3bf3a38d0ef8acb4190a932" translate="yes" xml:space="preserve">
          <source>A common use for &lt;code&gt;format!&lt;/code&gt; is concatenation and interpolation of strings. The same convention is used with &lt;a href=&quot;macro.print&quot;&gt;&lt;code&gt;print!&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;macro.write&quot;&gt;&lt;code&gt;write!&lt;/code&gt;&lt;/a&gt; macros, depending on the intended destination of the string.</source>
          <target state="translated">&lt;code&gt;format!&lt;/code&gt; 一般的な使用法！文字列の連結と補間です。同じ規則が&lt;a href=&quot;macro.print&quot;&gt; &lt;code&gt;print!&lt;/code&gt; &lt;/a&gt;も使用されます！そして&lt;a href=&quot;macro.write&quot;&gt; &lt;code&gt;write!&lt;/code&gt; &lt;/a&gt;文字列の目的の宛先に応じて、マクロ。</target>
        </trans-unit>
        <trans-unit id="44fea0684e72cef1ddaf4be0010340215dffbec7" translate="yes" xml:space="preserve">
          <source>A common use of this feature is to poison shared resources when writing unsafe code, by checking &lt;code&gt;panicking&lt;/code&gt; when the &lt;code&gt;drop&lt;/code&gt; is called.</source>
          <target state="translated">この機能の一般的な用途は、 &lt;code&gt;drop&lt;/code&gt; が呼び出されたときに &lt;code&gt;panicking&lt;/code&gt; をチェックすることにより、安全でないコードを記述するときに共有リソースを汚染することです。</target>
        </trans-unit>
        <trans-unit id="3016e8bc4b1ae0cb5dbf3daaacd9d48f6d65eed5" translate="yes" xml:space="preserve">
          <source>A common way to test functionality is to compare the result of the code under test to the value you expect the code to return to make sure they&amp;rsquo;re equal. You could do this using the &lt;code&gt;assert!&lt;/code&gt; macro and passing it an expression using the &lt;code&gt;==&lt;/code&gt; operator. However, this is such a common test that the standard library provides a pair of macros&amp;mdash;&lt;code&gt;assert_eq!&lt;/code&gt; and &lt;code&gt;assert_ne!&lt;/code&gt;&amp;mdash;to perform this test more conveniently. These macros compare two arguments for equality or inequality, respectively. They&amp;rsquo;ll also print the two values if the assertion fails, which makes it easier to see &lt;em&gt;why&lt;/em&gt; the test failed; conversely, the &lt;code&gt;assert!&lt;/code&gt; macro only indicates that it got a &lt;code&gt;false&lt;/code&gt; value for the &lt;code&gt;==&lt;/code&gt; expression, not the values that lead to the &lt;code&gt;false&lt;/code&gt; value.</source>
          <target state="translated">機能をテストする一般的な方法は、テスト対象のコードの結果を、コードが返すと予想される値と比較して、それらが等しいことを確認することです。 &lt;code&gt;assert!&lt;/code&gt; を使用してこれを行うことができます！マクロを使用し、 &lt;code&gt;==&lt;/code&gt; 演算子を使用して式を渡します。ただし、これは非常に一般的なテストであるため、標準ライブラリには、 &lt;code&gt;assert_eq!&lt;/code&gt; というマクロのペアが用意されています。そして &lt;code&gt;assert_ne!&lt;/code&gt; -このテストをより便利に実行するため。これらのマクロは、2つの引数が等しいか等しくないかをそれぞれ比較します。また、アサーションが失敗した場合は2つの値を出力する&lt;em&gt;ため&lt;/em&gt;、テストが失敗した&lt;em&gt;理由を&lt;/em&gt;簡単に確認できます。逆に、 &lt;code&gt;assert!&lt;/code&gt; マクロは、それが &lt;code&gt;false&lt;/code&gt; になったことのみを示します値 &lt;code&gt;==&lt;/code&gt; 表現、しないように値をリード &lt;code&gt;false&lt;/code&gt; 値。</target>
        </trans-unit>
        <trans-unit id="6f72785cb8deaf70098be764432ad287d8764020" translate="yes" xml:space="preserve">
          <source>A common way to use &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; is in combination with &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;. Recall that &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; lets you have multiple owners of some data, but it only gives immutable access to that data. If you have an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; that holds a &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, you can get a value that can have multiple owners &lt;em&gt;and&lt;/em&gt; that you can mutate!</source>
          <target state="translated">&lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; を使用する一般的な方法は、 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; と組み合わせることです。 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 使用すると、一部のデータの複数の所有者を持つことができますが、そのデータへの不変のアクセスのみが可能であることを思い出してください。 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; を保持するRc &amp;lt;T&amp;gt;がある場合、複数の所有者&lt;em&gt;を&lt;/em&gt;持つことができ、変更できる値を取得できます！&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c3a2eb5105511775d59e5e4cd686eb5579136f33" translate="yes" xml:space="preserve">
          <source>A comparison like the one above, which ignores some fields of the struct, can be dangerous. It can easily lead to an unintended violation of the requirements for a partial equivalence relation. For example, if we kept the above implementation of &lt;code&gt;PartialEq&amp;lt;Book&amp;gt;&lt;/code&gt; for &lt;code&gt;BookFormat&lt;/code&gt; and added an implementation of &lt;code&gt;PartialEq&amp;lt;Book&amp;gt;&lt;/code&gt; for &lt;code&gt;Book&lt;/code&gt; (either via a &lt;code&gt;#[derive]&lt;/code&gt; or via the manual implementation from the first example) then the result would violate transitivity:</source>
          <target state="translated">構造体の一部のフィールドを無視する上記のような比較は危険な場合があります。半同値関係の要件に意図せず違反する可能性があります。我々は上記の実装保つ場合、例えば &lt;code&gt;PartialEq&amp;lt;Book&amp;gt;&lt;/code&gt; ため &lt;code&gt;BookFormat&lt;/code&gt; の実装添加 &lt;code&gt;PartialEq&amp;lt;Book&amp;gt;&lt;/code&gt; ための &lt;code&gt;Book&lt;/code&gt; （いずれかを介して、 &lt;code&gt;#[derive]&lt;/code&gt; または第一の例からの手動実装を介して）、結果が違反推移性：</target>
        </trans-unit>
        <trans-unit id="1b20c9de094581b8f84861af4164c5552e60a2ee" translate="yes" xml:space="preserve">
          <source>A compile time error is never emitted when using this macro regardless of whether the environment variable is present or not.</source>
          <target state="translated">環境変数があるかどうかに関わらず、このマクロを使用してもコンパイル時のエラーは発生しません。</target>
        </trans-unit>
        <trans-unit id="378954a8b28d0b17cfcc628e2457199a86abdd79" translate="yes" xml:space="preserve">
          <source>A compiler memory fence.</source>
          <target state="translated">コンパイラのメモリフェンス。</target>
        </trans-unit>
        <trans-unit id="592fedd9ba4ca1ae2681effb1b9b42a165b45c38" translate="yes" xml:space="preserve">
          <source>A compiler-only memory barrier.</source>
          <target state="translated">コンパイラ専用のメモリバリア。</target>
        </trans-unit>
        <trans-unit id="5af9d265d7cc350d6c8dd5eca2e52c0984df494d" translate="yes" xml:space="preserve">
          <source>A configuration option. It is true if the option is set and false if it is unset.</source>
          <target state="translated">設定オプション。このオプションが設定されている場合は真、設定されていない場合は偽となります。</target>
        </trans-unit>
        <trans-unit id="3457f182555f50a2c7cffa76112cf04e013ed4c3" translate="yes" xml:space="preserve">
          <source>A consequence of the borrowing rules is that when you have an immutable value, you can&amp;rsquo;t borrow it mutably. For example, this code won&amp;rsquo;t compile:</source>
          <target state="translated">借用ルールの結果として、不変の値がある場合、それを可変に借用することはできません。たとえば、次のコードはコンパイルされません。</target>
        </trans-unit>
        <trans-unit id="82e92c5c9841d5d2d3e69bff0f6aeb9309a13f00" translate="yes" xml:space="preserve">
          <source>A constant item was initialized with something that is not a constant expression.</source>
          <target state="translated">定数式ではないもので定数項目が初期化されていました。</target>
        </trans-unit>
        <trans-unit id="5ce86a2e004403aa5ba6b72a885c67d143829985" translate="yes" xml:space="preserve">
          <source>A constant value failed to get evaluated.</source>
          <target state="translated">定数値の評価に失敗しました。</target>
        </trans-unit>
        <trans-unit id="2574c153f328b1e202d9e64649cb65b6702dbcde" translate="yes" xml:space="preserve">
          <source>A contiguous growable array type with heap-allocated contents, written &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; と書かれた、ヒープに割り当てられたコンテンツを含む連続した拡張可能な配列型。</target>
        </trans-unit>
        <trans-unit id="ceaa636b8440544799d1a505ee00079d04849fb0" translate="yes" xml:space="preserve">
          <source>A contiguous growable array type, written &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; but pronounced 'vector'.</source>
          <target state="translated">&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; と記述されているが「ベクトル」と発音される、連続する拡張可能な配列型。</target>
        </trans-unit>
        <trans-unit id="821a3f39751014be2886a42509e99ef71f4b3a2f" translate="yes" xml:space="preserve">
          <source>A control-flow expression was used inside a const context.</source>
          <target state="translated">コントロール・フロー式が const コンテキスト内で使用されました。</target>
        </trans-unit>
        <trans-unit id="0490b6e232133e0013be8f4fef9d50c9926445a5" translate="yes" xml:space="preserve">
          <source>A convenience function that bubbles an &lt;code&gt;io::Result&lt;/code&gt; to its caller:</source>
          <target state="translated">呼び出し側に &lt;code&gt;io::Result&lt;/code&gt; をバブリングする便利な関数：</target>
        </trans-unit>
        <trans-unit id="16d79d851ab24be5a7dea27948897afa80e31902" translate="yes" xml:space="preserve">
          <source>A convenience impl that delegates to the impl for &lt;code&gt;&amp;amp;str&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&amp;amp;str&lt;/code&gt; の実装に委任する便利な実装</target>
        </trans-unit>
        <trans-unit id="35a7bd82b1e1370c217a40362b5ca9b11be11f9d" translate="yes" xml:space="preserve">
          <source>A convenience impl that delegates to the impl for &lt;code&gt;&amp;amp;str&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;amp;str&lt;/code&gt; のimplに委任する便利なimpl 。</target>
        </trans-unit>
        <trans-unit id="c5815609ea9bdc6c8447adfe133c418ba6a0e628" translate="yes" xml:space="preserve">
          <source>A correct implementation could look like:</source>
          <target state="translated">正しい実装は次のようになります。</target>
        </trans-unit>
        <trans-unit id="0847e6a8b80cb99079b74075a954fd750b19a38b" translate="yes" xml:space="preserve">
          <source>A crate is somewhat analogous to an &lt;em&gt;assembly&lt;/em&gt; in the ECMA-335 CLI model, a &lt;em&gt;library&lt;/em&gt; in the SML/NJ Compilation Manager, a &lt;em&gt;unit&lt;/em&gt; in the Owens and Flatt module system, or a &lt;em&gt;configuration&lt;/em&gt; in Mesa.</source>
          <target state="translated">クレートは、ECMA-335 CLIモデルの&lt;em&gt;アセンブリ&lt;/em&gt;、SML / NJ Compilation Managerの&lt;em&gt;ライブラリ&lt;/em&gt;、Owens and Flattモジュールシステムの&lt;em&gt;ユニット&lt;/em&gt;、またはMesaの&lt;em&gt;構成&lt;/em&gt;に多少似てい&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="6436f7757ac841fe0b93278e071a64e419b3a404" translate="yes" xml:space="preserve">
          <source>A crate needs a global available &quot;helper module&quot; to itself, but it doesn't want to expose the helper module as a public API. To accomplish this, the root of the crate's hierarchy would have a private module which then internally has a &quot;public API&quot;. Because the entire crate is a descendant of the root, then the entire local crate can access this private module through the second case.</source>
          <target state="translated">クレートは、グローバルに利用可能な「ヘルパーモジュール」を必要としますが、そのヘルパーモジュールをパブリックAPIとして公開したくありません。これを達成するためには、クレートの階層のルートはプライベートモジュールを持ち、そのモジュールは内部的に &quot;公開API &quot;を持ちます。クレート全体がルートの子孫であるため、ローカルのクレート全体が2番目のケースでこのプライベートモジュールにアクセスすることができます。</target>
        </trans-unit>
        <trans-unit id="bc65255cb2d6b61579af61c12db502f3b72ad815" translate="yes" xml:space="preserve">
          <source>A crate that contains a &lt;code&gt;main&lt;/code&gt;&lt;a href=&quot;items/functions&quot;&gt;function&lt;/a&gt; can be compiled to an executable. If a &lt;code&gt;main&lt;/code&gt; function is present, it must take no arguments, must not declare any &lt;a href=&quot;trait-bounds&quot;&gt;trait or lifetime bounds&lt;/a&gt;, must not have any &lt;a href=&quot;items/generics#where-clauses&quot;&gt;where clauses&lt;/a&gt;, and its return type must be one of the following:</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; &lt;a href=&quot;items/functions&quot;&gt;関数&lt;/a&gt;を含むクレートは、実行可能ファイルにコンパイルできます。 &lt;code&gt;main&lt;/code&gt; 関数が存在する場合、それは引数を取ってはならず、&lt;a href=&quot;trait-bounds&quot;&gt;トレイトまたはライフタイムの境界を&lt;/a&gt;宣言してはならず、&lt;a href=&quot;items/generics#where-clauses&quot;&gt;where句&lt;/a&gt;があってはならず、戻り値の型は次のいずれかでなければなりません。</target>
        </trans-unit>
        <trans-unit id="1dd52734851cf6f3cf436dc5839dcfddfdcaf815" translate="yes" xml:space="preserve">
          <source>A crate will group related functionality together in a scope so the functionality is easy to share between multiple projects. For example, the &lt;code&gt;rand&lt;/code&gt; crate we used in &lt;a href=&quot;ch02-00-guessing-game-tutorial#generating-a-random-number&quot;&gt;Chapter 2&lt;/a&gt; provides functionality that generates random numbers. We can use that functionality in our own projects by bringing the &lt;code&gt;rand&lt;/code&gt; crate into our project&amp;rsquo;s scope. All the functionality provided by the &lt;code&gt;rand&lt;/code&gt; crate is accessible through the crate&amp;rsquo;s name, &lt;code&gt;rand&lt;/code&gt;.</source>
          <target state="translated">クレートは、関連する機能をスコープにグループ化するため、機能は複数のプロジェクト間で簡単に共有できます。たとえば、&lt;a href=&quot;ch02-00-guessing-game-tutorial#generating-a-random-number&quot;&gt;第2章で&lt;/a&gt;使用した &lt;code&gt;rand&lt;/code&gt; クレートは、乱数を生成する機能を提供します。 &lt;code&gt;rand&lt;/code&gt; クレートをプロジェクトのスコープに含めることで、この機能を自分のプロジェクトで使用できます。 &lt;code&gt;rand&lt;/code&gt; クレートが提供するすべての機能は、クレートの名前 &lt;code&gt;rand&lt;/code&gt; を介してアクセスできます。</target>
        </trans-unit>
        <trans-unit id="9489488427833bc0214d8f4c5f5a907ee47ae129" translate="yes" xml:space="preserve">
          <source>A cross-crate opt-out trait was implemented on something which wasn't a struct or enum type.</source>
          <target state="translated">構造体や列挙型ではないものにクロスクレートのオプトアウト形質が実装されていました。</target>
        </trans-unit>
        <trans-unit id="00851a5c172b45fa5d81433f76656b498876dd4d" translate="yes" xml:space="preserve">
          <source>A cross-crate opt-out trait was implemented on something which wasn't a struct or enum type. Erroneous code example:</source>
          <target state="translated">クロス ク レ イ ト の opt-out trait が、 struct 型でも enum 型でもないものに実装 さ れていました。誤ったコード例です。</target>
        </trans-unit>
        <trans-unit id="521073eb4a9d5dea34971bbf2d3b43472252d22c" translate="yes" xml:space="preserve">
          <source>A cursor over a &lt;code&gt;LinkedList&lt;/code&gt; with editing operations.</source>
          <target state="translated">編集操作を含む &lt;code&gt;LinkedList&lt;/code&gt; 上のカーソル。</target>
        </trans-unit>
        <trans-unit id="e765e383228431ae063a8d9a831d2b82107b6c73" translate="yes" xml:space="preserve">
          <source>A cursor over a &lt;code&gt;LinkedList&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LinkedList&lt;/code&gt; の上にカーソルを置きます。</target>
        </trans-unit>
        <trans-unit id="36316fe5916fd156e2a88a749ac433147a8da4cc" translate="yes" xml:space="preserve">
          <source>A cycle between &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointers will never be deallocated. For this reason, &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; is used to break cycles. For example, a tree could have strong &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointers from parent nodes to children, and &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers from children back to their parents.</source>
          <target state="translated">&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt;ポインタ間のサイクルが割り当て解除されることはありません。このため、&lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt;はサイクルを中断するために使用されます。たとえば、ツリーには、親ノードから子への強い&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt;ポインターと、子から親への&lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt;ポインターがあります。</target>
        </trans-unit>
        <trans-unit id="3b90e3c2a1d2a35888ed9e0be0c1ef31680e920a" translate="yes" xml:space="preserve">
          <source>A cycle between &lt;code&gt;Arc&lt;/code&gt; pointers will never be deallocated. For this reason, &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; is used to break cycles. For example, a tree could have strong &lt;code&gt;Arc&lt;/code&gt; pointers from parent nodes to children, and &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers from children back to their parents.</source>
          <target state="translated">&lt;code&gt;Arc&lt;/code&gt; ポインター間のサイクルが割り当て解除されることはありません。このため、&lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt;はサイクルを中断するために使用されます。たとえば、ツリーには、親ノードから子への強い &lt;code&gt;Arc&lt;/code&gt; ポインターと、子から親への&lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt;ポインターがあります。</target>
        </trans-unit>
        <trans-unit id="cd0e6a515d806f28a3a9117a215e0567225d9f11" translate="yes" xml:space="preserve">
          <source>A data structure is in a temporarily invalid state when the thread panics.</source>
          <target state="translated">スレッドがパニックになると、データ構造が一時的に無効な状態になります。</target>
        </trans-unit>
        <trans-unit id="590870896f27fcf4f2a0264dabbc0794e9042402" translate="yes" xml:space="preserve">
          <source>A default configuration can be generated using &lt;code&gt;Command::new(program)&lt;/code&gt;, where &lt;code&gt;program&lt;/code&gt; gives a path to the program to be executed. Additional builder methods allow the configuration to be changed (for example, by adding arguments) prior to spawning:</source>
          <target state="translated">デフォルトの構成は &lt;code&gt;Command::new(program)&lt;/code&gt; を使用して生成できます。ここで、 &lt;code&gt;program&lt;/code&gt; は実行するプログラムへのパスを提供します。追加のビルダーメソッドを使用すると、スポーン前に構成を変更できます（たとえば、引数を追加することで）。</target>
        </trans-unit>
        <trans-unit id="cc1e47ebf18eca6629966fd3d1126236437b08eb" translate="yes" xml:space="preserve">
          <source>A definition of a method not in the implemented trait was given in a trait implementation.</source>
          <target state="translated">実装された形質にないメソッドの定義が形質の実装で与えられました。</target>
        </trans-unit>
        <trans-unit id="74bdee4c01f0e2a5b888cedf761fad306ec9d91d" translate="yes" xml:space="preserve">
          <source>A discriminant in an &lt;code&gt;enum&lt;/code&gt; not included in the type definition.</source>
          <target state="translated">型定義に含まれていない &lt;code&gt;enum&lt;/code&gt; 型の判別式。</target>
        </trans-unit>
        <trans-unit id="1d4413773858071be2cda9c035b93d8adb5ed9c4" translate="yes" xml:space="preserve">
          <source>A discriminant value is present more than once.</source>
          <target state="translated">判別値が複数回存在する。</target>
        </trans-unit>
        <trans-unit id="e33398f8a1c82819cfc272eb4db0376550aceebc" translate="yes" xml:space="preserve">
          <source>A doc comment that is not attached to anything has been encountered.</source>
          <target state="translated">何にも添付されていないdocコメントが発生しました。</target>
        </trans-unit>
        <trans-unit id="449c61354d124e018f4ac7cc6a32776bf259e4bc" translate="yes" xml:space="preserve">
          <source>A documentation comment that doesn't document anything was found.</source>
          <target state="translated">何も文書化されていない文書コメントが見つかりました。</target>
        </trans-unit>
        <trans-unit id="b5da65d7d41e577505a8697b6d53146c919ad568" translate="yes" xml:space="preserve">
          <source>A double quote byte string (&lt;code&gt;b&quot;&lt;/code&gt;) was not terminated.</source>
          <target state="translated">二重引用符のバイト文字列（ &lt;code&gt;b&quot;&lt;/code&gt; ）は終了しませんでした。</target>
        </trans-unit>
        <trans-unit id="6c189219618ff090bbaf1c282c8ad43303eb7709" translate="yes" xml:space="preserve">
          <source>A double quote string (&lt;code&gt;&quot;&lt;/code&gt;) was not terminated.</source>
          <target state="translated">二重引用符（ &lt;code&gt;&quot;&lt;/code&gt; ）は終了しませんでした。</target>
        </trans-unit>
        <trans-unit id="844fc94f2ec6c20bbd8c3c61aa63bf0f8f4c60a0" translate="yes" xml:space="preserve">
          <source>A double-ended iterator with the direction inverted.</source>
          <target state="translated">方向を反転させたダブルエンドのイテレータ。</target>
        </trans-unit>
        <trans-unit id="9e374237ea1be12ca52873f6b8cd4c6757ef72d7" translate="yes" xml:space="preserve">
          <source>A double-ended queue implemented with a growable ring buffer.</source>
          <target state="translated">成長可能なリングバッファを用いて実装されたダブルエンドキュー。</target>
        </trans-unit>
        <trans-unit id="28050b20d2fb7eccf5c8a8ecb22f1b2923430db5" translate="yes" xml:space="preserve">
          <source>A doubly-linked list with owned nodes.</source>
          <target state="translated">所有ノードを持つ二重リンクリスト。</target>
        </trans-unit>
        <trans-unit id="7fb38950784a1933e77430becd7b735f7149cba0" translate="yes" xml:space="preserve">
          <source>A draining iterator for &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; のドレイン反復子。</target>
        </trans-unit>
        <trans-unit id="4c37906477f09b5f321b2effe6bce9b886812638" translate="yes" xml:space="preserve">
          <source>A draining iterator for &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; ドレイン反復子。</target>
        </trans-unit>
        <trans-unit id="429ad4a5f6fa96f2bca9279ba7532d1e6d671a36" translate="yes" xml:space="preserve">
          <source>A draining iterator over the elements of a &lt;code&gt;BinaryHeap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BinaryHeap&lt;/code&gt; の要素に対するドレイン反復子。</target>
        </trans-unit>
        <trans-unit id="91b15bef979787193522a6fe820b65bca6b71b6d" translate="yes" xml:space="preserve">
          <source>A draining iterator over the elements of a &lt;code&gt;VecDeque&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;VecDeque&lt;/code&gt; の要素のドレインイテレータ。</target>
        </trans-unit>
        <trans-unit id="6e8fa0dd341d84cbc1afdb686f6037ff7ef3d24c" translate="yes" xml:space="preserve">
          <source>A draining iterator over the entries of a &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; のエントリに対するドレインイテレータ。</target>
        </trans-unit>
        <trans-unit id="3f3d65aa6b0bc2c1da1319190787588eadcf2d84" translate="yes" xml:space="preserve">
          <source>A draining iterator over the items of a &lt;code&gt;HashSet&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HashSet&lt;/code&gt; の項目のドレインイテレータ。</target>
        </trans-unit>
        <trans-unit id="d0414ecefaa3523675384470efb07b95159dba45" translate="yes" xml:space="preserve">
          <source>A draining, filtering iterator over the entries of a &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; のエントリに対するドレイン、フィルタリングのイテレータ。</target>
        </trans-unit>
        <trans-unit id="bdb2903d11786dcb8b8844e91d87fb7f80657414" translate="yes" xml:space="preserve">
          <source>A draining, filtering iterator over the items of a &lt;code&gt;HashSet&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HashSet&lt;/code&gt; のアイテムに対する排出、フィルタリングのイテレータ。</target>
        </trans-unit>
        <trans-unit id="c40d5a17630e0b8c5262cd5da85143e19cf981ab" translate="yes" xml:space="preserve">
          <source>A duration of zero time.</source>
          <target state="translated">ゼロタイムの持続時間。</target>
        </trans-unit>
        <trans-unit id="cc90bdb96c97b6e432d2ff036bf4b852213faf58" translate="yes" xml:space="preserve">
          <source>A dynamically sized type (DST) is a type without a statically known size or alignment.</source>
          <target state="translated">動的サイズ型(DST)とは、統計的に知られているサイズやアラインメントを持たない型のことです。</target>
        </trans-unit>
        <trans-unit id="211aeaeaf569d6a37ba4f9e761ab58dda09c15a6" translate="yes" xml:space="preserve">
          <source>A dynamically-sized view into a contiguous sequence, &lt;code&gt;[T]&lt;/code&gt;.</source>
          <target state="translated">連続するシーケンス &lt;code&gt;[T]&lt;/code&gt; への動的サイズのビュー。</target>
        </trans-unit>
        <trans-unit id="c9b7bf32fab7bb231166bbede96c90271ed78811" translate="yes" xml:space="preserve">
          <source>A dynamically-sized view into a contiguous sequence, &lt;code&gt;[T]&lt;/code&gt;. Contiguous here means that elements are laid out so that every element is the same distance from its neighbors.</source>
          <target state="translated">連続したシーケンスへの動的なサイズのビュー &lt;code&gt;[T]&lt;/code&gt; 。ここで隣接しているとは、すべての要素が隣接する要素から同じ距離になるように要素が配置されていることを意味します。</target>
        </trans-unit>
        <trans-unit id="31f05f23c58b03a01fb9e427108a188fcf6b07f3" translate="yes" xml:space="preserve">
          <source>A feature attribute named a feature that has been removed.</source>
          <target state="translated">削除されたフィーチャという名前のフィーチャ属性。</target>
        </trans-unit>
        <trans-unit id="dd28c7fe46ecde36f6e0a91f768af6503a5d1816" translate="yes" xml:space="preserve">
          <source>A feature attribute named a feature that was disallowed in the compiler command line flags.</source>
          <target state="translated">コンパイラのコマンドライン・フラグで禁止されていた機能の名前を付けたフィーチャ属性。</target>
        </trans-unit>
        <trans-unit id="7d16601ad6554f548eab3701b5a36e77bca297da" translate="yes" xml:space="preserve">
          <source>A feature name is missing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80c1f2d8465e2f0474908b699c574231c3f93ea8" translate="yes" xml:space="preserve">
          <source>A fence 'A' which has (at least) &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; ordering semantics, synchronizes with a fence 'B' with (at least) &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; semantics, if and only if there exist operations X and Y, both operating on some atomic object 'M' such that A is sequenced before X, Y is synchronized before B and Y observes the change to M. This provides a happens-before dependence between A and B.</source>
          <target state="translated">（少なくとも）&lt;a href=&quot;enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt;順序付けセマンティクスを持つフェンス 'A'は、（少なくとも）&lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt;セマンティクスを持つフェンス 'B'と同期します。操作XとYが存在する場合にのみ、両方とも何らかのアトミックオブジェクト 'M'で動作します。つまり、AはXの前にシーケンスされ、YはBの前に同期され、YはMへの変更を観察します。これにより、AとBの間で発生前の依存関係が提供されます。</target>
        </trans-unit>
        <trans-unit id="55e68042fec783cba9aad8dce1b35e99ef85dbdf" translate="yes" xml:space="preserve">
          <source>A fence which has &lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;SeqCst&lt;/code&gt;&lt;/a&gt; ordering, in addition to having both &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; semantics, participates in the global program order of the other &lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;SeqCst&lt;/code&gt;&lt;/a&gt; operations and/or fences.</source>
          <target state="translated">&lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt;両方のセマンティクスを持つことに加えて、&lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;SeqCst&lt;/code&gt; &lt;/a&gt;順序を持つフェンスは、他の&lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;SeqCst&lt;/code&gt; &lt;/a&gt;操作またはフェンス、あるいはその両方のグローバルプログラム順序に参加します。</target>
        </trans-unit>
        <trans-unit id="1cb36d0ee361d78dbe2fa3dcfcac72e9a2dee2b5" translate="yes" xml:space="preserve">
          <source>A field access is a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place expression&lt;/a&gt; referring to the location of that field. When the subexpression is &lt;a href=&quot;../expressions#mutability&quot;&gt;mutable&lt;/a&gt;, the field expression is also mutable.</source>
          <target state="translated">フィールドアクセスは、そのフィールドの場所を参照する&lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;場所式&lt;/a&gt;です。サブ式が&lt;a href=&quot;../expressions#mutability&quot;&gt;mutableの&lt;/a&gt;場合、フィールド式も変更可能です。</target>
        </trans-unit>
        <trans-unit id="f7e446184b876f98fd13cf13bfdf4f57607ba15b" translate="yes" xml:space="preserve">
          <source>A file wasn't found for an out-of-line module.</source>
          <target state="translated">行外のモジュールにファイルが見つかりませんでした。</target>
        </trans-unit>
        <trans-unit id="730142c15726a49fe7ebbd5c1ceae068d1e76798" translate="yes" xml:space="preserve">
          <source>A final reason Rust doesn&amp;rsquo;t allow us to index into a &lt;code&gt;String&lt;/code&gt; to get a character is that indexing operations are expected to always take constant time (O(1)). But it isn&amp;rsquo;t possible to guarantee that performance with a &lt;code&gt;String&lt;/code&gt;, because Rust would have to walk through the contents from the beginning to the index to determine how many valid characters there were.</source>
          <target state="translated">Rustが &lt;code&gt;String&lt;/code&gt; にインデックスを付けて文字を取得することを許可しない最後の理由は、インデックス付け操作が常に一定の時間（O（1））を要すると予想されるためです。ただし、Rustはコンテンツを最初からインデックスまで順番に調べて、有効な文字の数を判断する必要があるため、 &lt;code&gt;String&lt;/code&gt; でそのパフォーマンスを保証することはできません。</target>
        </trans-unit>
        <trans-unit id="0106151a82df636bbbb97134363a6aef4336540d" translate="yes" xml:space="preserve">
          <source>A finite heterogeneous sequence, &lt;code&gt;(T, U, ..)&lt;/code&gt;.</source>
          <target state="translated">有限異種シーケンス &lt;code&gt;(T, U, ..)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="405c2e4c1352a9dd275d0dcf43af6465cfa06fc2" translate="yes" xml:space="preserve">
          <source>A fixed-size array, denoted &lt;code&gt;[T; N]&lt;/code&gt;, for the element type, &lt;code&gt;T&lt;/code&gt;, and the non-negative compile-time constant size, &lt;code&gt;N&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;[T; N]&lt;/code&gt; で表される固定サイズの配列 N]、要素タイプ &lt;code&gt;T&lt;/code&gt; および非負のコンパイル時定数サイズ &lt;code&gt;N&lt;/code&gt; の場合。</target>
        </trans-unit>
        <trans-unit id="01e8ae155635ffa00df108a976552eb0550b9e9b" translate="yes" xml:space="preserve">
          <source>A for loop is equivalent to the following block expression.</source>
          <target state="translated">forループは以下のブロック式と等価です。</target>
        </trans-unit>
        <trans-unit id="b694a59d19302341ecbd00f4fa0cb3b358a2f81b" translate="yes" xml:space="preserve">
          <source>A format string is required to use all of its arguments, otherwise it is a compile-time error. You may refer to the same argument more than once in the format string.</source>
          <target state="translated">フォーマット文字列はすべての引数を使用する必要があり、そうでない場合はコンパイル時エラーとなります。フォーマット文字列では、同じ引数を複数回参照することができます。</target>
        </trans-unit>
        <trans-unit id="01b7129399ded6b05b30578334c78e0c28495f39" translate="yes" xml:space="preserve">
          <source>A function annotated with the &lt;code&gt;test&lt;/code&gt; attribute can also be annotated with the &lt;code&gt;ignore&lt;/code&gt; attribute. The &lt;em&gt;&lt;code&gt;ignore&lt;/code&gt; attribute&lt;/em&gt; tells the test harness to not execute that function as a test. It will still be compiled when in test mode.</source>
          <target state="translated">&lt;code&gt;test&lt;/code&gt; 属性で注釈が付けられた関数には、 &lt;code&gt;ignore&lt;/code&gt; 属性で注釈を付けることもできます。&lt;em&gt; &lt;code&gt;ignore&lt;/code&gt; 属性が&lt;/em&gt;テストとしてその機能を実行しないようにテストハーネスを伝えます。テストモードでもコンパイルされます。</target>
        </trans-unit>
        <trans-unit id="05308286e6d20f1bc15a1d74d19f5246b35ba29f" translate="yes" xml:space="preserve">
          <source>A function annotated with the &lt;code&gt;test&lt;/code&gt; attribute that returns &lt;code&gt;()&lt;/code&gt; can also be annotated with the &lt;code&gt;should_panic&lt;/code&gt; attribute. The &lt;em&gt;&lt;code&gt;should_panic&lt;/code&gt; attribute&lt;/em&gt; makes the test only pass if it actually panics.</source>
          <target state="translated">&lt;code&gt;()&lt;/code&gt; を返す &lt;code&gt;test&lt;/code&gt; 属性で注釈が付けられた関数は、 &lt;code&gt;should_panic&lt;/code&gt; 属性で注釈を付けることもできます。&lt;em&gt; &lt;code&gt;should_panic&lt;/code&gt; &lt;/em&gt;&lt;em&gt;属性は、&lt;/em&gt;テストはそれだけであれば、実際にパニックを渡すことができます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d9fe742a8fa7d8036e041c35d1e5b1052fe5c884" translate="yes" xml:space="preserve">
          <source>A function call isn't allowed in the const's initialization expression because the expression's value must be known at compile-time. Erroneous code example:</source>
          <target state="translated">コンパイル時に式の値を知る必要があるため、const の初期化式では関数呼び出しは許可されません。誤ったコード例。</target>
        </trans-unit>
        <trans-unit id="cdbab3b7a45160aa6bbfe85128d0bf7bac272328" translate="yes" xml:space="preserve">
          <source>A function declared in an extern block is implicitly &lt;code&gt;unsafe&lt;/code&gt;. When coerced to a function pointer, a function declared in an extern block has type &lt;code&gt;unsafe extern &quot;abi&quot; for&amp;lt;'l1, ..., 'lm&amp;gt; fn(A1, ..., An) -&amp;gt; R&lt;/code&gt;, where &lt;code&gt;'l1&lt;/code&gt;, ... &lt;code&gt;'lm&lt;/code&gt; are its lifetime parameters, &lt;code&gt;A1&lt;/code&gt;, ..., &lt;code&gt;An&lt;/code&gt; are the declared types of its parameters and &lt;code&gt;R&lt;/code&gt; is the declared return type.</source>
          <target state="translated">externブロックで宣言された関数は暗黙的に &lt;code&gt;unsafe&lt;/code&gt; はありません。関数ポインターに強制型変換されると、externブロックで宣言された関数の型は &lt;code&gt;unsafe extern &quot;abi&quot; for&amp;lt;'l1, ..., 'lm&amp;gt; fn(A1, ..., An) -&amp;gt; R&lt;/code&gt; 、ここで &lt;code&gt;'l1&lt;/code&gt; 、... &lt;code&gt;'lm&lt;/code&gt; はその存続期間パラメーター、 &lt;code&gt;A1&lt;/code&gt; 、...、 &lt;code&gt;An&lt;/code&gt; はそのパラメーターの宣言されたタイプ、 &lt;code&gt;R&lt;/code&gt; は宣言された戻りタイプです。</target>
        </trans-unit>
        <trans-unit id="d0692343f061c0cd9d5ae6d4139b26c55c59ad9f" translate="yes" xml:space="preserve">
          <source>A function is using &lt;code&gt;continue&lt;/code&gt; keyword incorrectly.</source>
          <target state="translated">関数が &lt;code&gt;continue&lt;/code&gt; キーワードを誤って使用しています。</target>
        </trans-unit>
        <trans-unit id="0055fb8a733d1b0d5afb4ae44802bb8e5a0c86da" translate="yes" xml:space="preserve">
          <source>A function or function pointer.</source>
          <target state="translated">関数または関数ポインタ。</target>
        </trans-unit>
        <trans-unit id="b5bfe20067693f41e9be24910b3f1d1c865c4b39" translate="yes" xml:space="preserve">
          <source>A function signature must declare the number and type of parameters the function has. Macros, on the other hand, can take a variable number of parameters: we can call &lt;code&gt;println!(&quot;hello&quot;)&lt;/code&gt; with one argument or &lt;code&gt;println!(&quot;hello {}&quot;, name)&lt;/code&gt; with two arguments. Also, macros are expanded before the compiler interprets the meaning of the code, so a macro can, for example, implement a trait on a given type. A function can&amp;rsquo;t, because it gets called at runtime and a trait needs to be implemented at compile time.</source>
          <target state="translated">関数シグネチャは、関数が持つパラメータの数とタイプを宣言する必要があります。一方、マクロは可変数のパラメーターを取ることができます。1つの引数で &lt;code&gt;println!(&quot;hello&quot;)&lt;/code&gt; を呼び出すか、2つの引数で &lt;code&gt;println!(&quot;hello {}&quot;, name)&lt;/code&gt; を呼び出すことができます。また、マクロは、コンパイラーがコードの意味を解釈する前に展開されるため、たとえば、マクロは特定の型に特性を実装できます。関数は実行できません。実行時に呼び出され、コンパイル時に特性を実装する必要があるためです。</target>
        </trans-unit>
        <trans-unit id="cfea53bdada8b3687c10319a4dd10194cef976b7" translate="yes" xml:space="preserve">
          <source>A function that has a parameter or returns only numbers between 1 and 100 could then declare in its signature that it takes or returns a &lt;code&gt;Guess&lt;/code&gt; rather than an &lt;code&gt;i32&lt;/code&gt; and wouldn&amp;rsquo;t need to do any additional checks in its body.</source>
          <target state="translated">パラメータを持つ、または1から100までの数値のみを返す関数は、 &lt;code&gt;i32&lt;/code&gt; ではなく &lt;code&gt;Guess&lt;/code&gt; を受け取るか返すことをシグネチャで宣言でき、本体で追加のチェックを行う必要はありません。</target>
        </trans-unit>
        <trans-unit id="330c21e7bd84509b137caeeff4bed7a7da24e5b7" translate="yes" xml:space="preserve">
          <source>A function that is opaque to the optimizer, to allow benchmarks to pretend to use outputs to assist in avoiding dead-code elimination.</source>
          <target state="translated">オプティマイザに不透明な関数で、ベンチマークが出力を使用するふりをしてデッドコードの排除を回避できるようにします。</target>
        </trans-unit>
        <trans-unit id="d2ed9af48e681bbf5a9216d3deb00de57795222b" translate="yes" xml:space="preserve">
          <source>A function with the &lt;code&gt;start&lt;/code&gt; attribute was declared with type parameters.</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; 属性を持つ関数が型パラメーターで宣言されました。</target>
        </trans-unit>
        <trans-unit id="cc716e4e83b4efb34e4101d17ccb62e4b2b1eb26" translate="yes" xml:space="preserve">
          <source>A fundamental trait is one where adding an impl of it for an existing type is a breaking change. The &lt;code&gt;Fn&lt;/code&gt; traits and &lt;code&gt;Sized&lt;/code&gt; are fundamental.</source>
          <target state="translated">基本的な特性は、既存のタイプにそのimplを追加することが重大な変更であるという特性です。 &lt;code&gt;Fn&lt;/code&gt; 特性と &lt;code&gt;Sized&lt;/code&gt; 基本です。</target>
        </trans-unit>
        <trans-unit id="0649f34bf1c96947359554a4e3b1fb6bd7f77d90" translate="yes" xml:space="preserve">
          <source>A fundamental type constructor is a type where implementing a &lt;a href=&quot;#blanket-implementation&quot;&gt;blanket implementation&lt;/a&gt; over it is a breaking change. &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;&amp;amp;mut&lt;/code&gt;, &lt;code&gt;Box&lt;/code&gt;, and &lt;code&gt;Pin&lt;/code&gt; are fundamental.</source>
          <target state="translated">基本的な型コンストラクターは、その上に&lt;a href=&quot;#blanket-implementation&quot;&gt;包括的実装を実装&lt;/a&gt;することが重大な変更である型です。 &lt;code&gt;&amp;amp;&lt;/code&gt; 、 &lt;code&gt;&amp;amp;mut&lt;/code&gt; 、 &lt;code&gt;Box&lt;/code&gt; 、および &lt;code&gt;Pin&lt;/code&gt; が基本です。</target>
        </trans-unit>
        <trans-unit id="b104136e74bd26ea4949e609270e7bafb60abae9" translate="yes" xml:space="preserve">
          <source>A future is a value that may not have finished computing yet. This kind of &quot;asynchronous value&quot; makes it possible for a thread to continue doing useful work while it waits for the value to become available.</source>
          <target state="translated">未来とは、まだ計算が終わっていないかもしれない値のことです。この種の「非同期値」は、値が利用可能になるのを待つ間、スレッドが有用な作業を続けることを可能にします。</target>
        </trans-unit>
        <trans-unit id="7c377e6c372ce66665ebea21944588366ee85648" translate="yes" xml:space="preserve">
          <source>A future represents an asynchronous computation.</source>
          <target state="translated">未来は非同期計算を表します。</target>
        </trans-unit>
        <trans-unit id="c1da397a075afa74abc70c7bb33c6bfaa50fd933" translate="yes" xml:space="preserve">
          <source>A generalization of &lt;code&gt;Clone&lt;/code&gt; to borrowed data.</source>
          <target state="translated">借用データへの &lt;code&gt;Clone&lt;/code&gt; の一般化。</target>
        </trans-unit>
        <trans-unit id="851d3775359dee45f6fc12b7c593dac300677e98" translate="yes" xml:space="preserve">
          <source>A generic function must be treated similarly:</source>
          <target state="translated">ジェネリック関数も同様に扱わなければなりません。</target>
        </trans-unit>
        <trans-unit id="47dc8336e1d401035013095c768eec4aaa7de80d" translate="yes" xml:space="preserve">
          <source>A generic type was described using parentheses rather than angle brackets.</source>
          <target state="translated">角括弧ではなく、括弧を用いて汎用型を記述しました。</target>
        </trans-unit>
        <trans-unit id="b9e2cdc9d185c52c49734ce26b1038e50519630f" translate="yes" xml:space="preserve">
          <source>A generic type was described using parentheses rather than angle brackets. For example:</source>
          <target state="translated">一般的な型は、角括弧ではなく括弧を使って記述しました。例えば</target>
        </trans-unit>
        <trans-unit id="d667559155454841982582189ab274f14a49b2bf" translate="yes" xml:space="preserve">
          <source>A generic type where one or more associated types have specific assignments (e.g., &lt;code&gt;Iterator&amp;lt;Item=T&amp;gt;&lt;/code&gt;)</source>
          <target state="translated">1つ以上の関連付けられたタイプに特定の割り当てがある総称タイプ（例： &lt;code&gt;Iterator&amp;lt;Item=T&amp;gt;&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="6f0496f55807a095b66d7d51e944864622ad78d2" translate="yes" xml:space="preserve">
          <source>A ghastly note 👻👻👻</source>
          <target state="translated">ゲスい音符 👻👻👻👻</target>
        </trans-unit>
        <trans-unit id="91fcac820244ae988bc857941377bad5a84fac8d" translate="yes" xml:space="preserve">
          <source>A given matcher M maps to three sets: FIRST(M), LAST(M) and FOLLOW(M).</source>
          <target state="translated">与えられた Matcher M は 3 つの集合に写ります。FIRST(M),LAST(M),FOLLOW(M)です.</target>
        </trans-unit>
        <trans-unit id="ce503e49f8d95cbc61a21e14a3b1dd613e9d99ae" translate="yes" xml:space="preserve">
          <source>A great example of a situation where this technique is useful is with operator overloading. &lt;em&gt;Operator overloading&lt;/em&gt; is customizing the behavior of an operator (such as &lt;code&gt;+&lt;/code&gt;) in particular situations.</source>
          <target state="translated">この手法が役立つ状況の良い例は、オペレーターのオーバーロードです。&lt;em&gt;演算子のオーバーロード&lt;/em&gt;とは、特定の状況での演算子（ &lt;code&gt;+&lt;/code&gt; など）の動作をカスタマイズすることです。</target>
        </trans-unit>
        <trans-unit id="77b606312f70d0e0e8a4e81eb457af73b41943c1" translate="yes" xml:space="preserve">
          <source>A guard for unsafe functions that cannot ever be executed if &lt;code&gt;T&lt;/code&gt; does not permit zero-initialization: This will statically either panic, or do nothing.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; がゼロ初期化を許可しない場合に実行できない安全でない関数のガード：これは静的にパニックになるか、何もしません。</target>
        </trans-unit>
        <trans-unit id="73d1fa93ccd1713ed23cb21dd7e4493abed0a332" translate="yes" xml:space="preserve">
          <source>A guard for unsafe functions that cannot ever be executed if &lt;code&gt;T&lt;/code&gt; has invalid bit patterns: This will statically either panic, or do nothing.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; に無効なビットパターンがある場合に実行できない安全でない関数のガード：これは静的にパニックになるか、何もしません。</target>
        </trans-unit>
        <trans-unit id="e24815403ad3a79092fe51890734de71f5057ede" translate="yes" xml:space="preserve">
          <source>A guard for unsafe functions that cannot ever be executed if &lt;code&gt;T&lt;/code&gt; is uninhabited: This will statically either panic, or do nothing.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; が無人の場合は実行できない安全でない関数のガード：これは静的にパニックするか、何もしません。</target>
        </trans-unit>
        <trans-unit id="7a319cd7f43cac10207753e127b6908e7ad723f6" translate="yes" xml:space="preserve">
          <source>A handle to a child process's standard input (stdin).</source>
          <target state="translated">子プロセスの標準入力 (stdin)へのハンドル。</target>
        </trans-unit>
        <trans-unit id="1c0c017d7e2d5d79869d31d54d7aed18a0e39b40" translate="yes" xml:space="preserve">
          <source>A handle to a child process's standard output (stdout).</source>
          <target state="translated">子プロセスの標準出力 (stdout)へのハンドル。</target>
        </trans-unit>
        <trans-unit id="36463654df6f05a2c5f7eb7e4b2efec9b5402d6f" translate="yes" xml:space="preserve">
          <source>A handle to a child process's stderr.</source>
          <target state="translated">子プロセスの標準エラーへのハンドル。</target>
        </trans-unit>
        <trans-unit id="539b8b33fb86eae0a19eb8338bbb41567108f8bd" translate="yes" xml:space="preserve">
          <source>A handle to a thread.</source>
          <target state="translated">スレッドへのハンドル。</target>
        </trans-unit>
        <trans-unit id="e4354965858e59daba47e025f6bf432587785439" translate="yes" xml:space="preserve">
          <source>A handle to the global standard output stream of the current process.</source>
          <target state="translated">現在のプロセスのグローバル標準出力ストリームへのハンドル。</target>
        </trans-unit>
        <trans-unit id="4e5458b43a1ef2ac995209fb2fb9a0f1f086d8ff" translate="yes" xml:space="preserve">
          <source>A handle to the standard error stream of a process.</source>
          <target state="translated">プロセスの標準エラーストリームへのハンドル。</target>
        </trans-unit>
        <trans-unit id="c04e6d93f5332bb8558883edf3c0666a1ead6820" translate="yes" xml:space="preserve">
          <source>A handle to the standard input stream of a process.</source>
          <target state="translated">プロセスの標準入力ストリームへのハンドル。</target>
        </trans-unit>
        <trans-unit id="52f29960ee00cd31852f436ce3c064a63d21c4a9" translate="yes" xml:space="preserve">
          <source>A hash map implemented with linear probing and Robin Hood bucket stealing.</source>
          <target state="translated">線形プロービングとロビンフッドのバケツ盗みを用いて実装されたハッシュマップ。</target>
        </trans-unit>
        <trans-unit id="1b24fb3ba32189304beb3027b487b7bde1af7301" translate="yes" xml:space="preserve">
          <source>A hash map implemented with quadratic probing and SIMD lookup.</source>
          <target state="translated">二次プロービングとSIMDルックアップを用いて実装されたハッシュマップ。</target>
        </trans-unit>
        <trans-unit id="3236fb9d674df64208b5e1cf2d78d481f577b4f2" translate="yes" xml:space="preserve">
          <source>A hash set implemented as a &lt;code&gt;HashMap&lt;/code&gt; where the value is &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">値が &lt;code&gt;()&lt;/code&gt; である &lt;code&gt;HashMap&lt;/code&gt; として実装されたハッシュセット。</target>
        </trans-unit>
        <trans-unit id="4944fd02934cfc33b70591237170d7c0599ffebd" translate="yes" xml:space="preserve">
          <source>A hashable type.</source>
          <target state="translated">ハッシュ可能なタイプ。</target>
        </trans-unit>
        <trans-unit id="4d0ef9738cd0ca2c9edcc6b3b923fd916c2b5807" translate="yes" xml:space="preserve">
          <source>A helper struct for reverse ordering.</source>
          <target state="translated">逆順化のためのヘルパー構造体です。</target>
        </trans-unit>
        <trans-unit id="2fcfddbae21727b9845f52dbf5c24515e281ef8f" translate="yes" xml:space="preserve">
          <source>A helper trait used for indexing operations.</source>
          <target state="translated">インデックス操作に使用されるヘルパー形質。</target>
        </trans-unit>
        <trans-unit id="29862de09ef195f3021bf8c1026b55bc84123b69" translate="yes" xml:space="preserve">
          <source>A incorrectly formatted &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; will produce an error.</source>
          <target state="translated">正しくフォーマットされていない&lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/a&gt;はエラーを生成します。</target>
        </trans-unit>
        <trans-unit id="2e3f1a456a73954f3da04455c2ebc9a53acd9daf" translate="yes" xml:space="preserve">
          <source>A lang item was redefined.</source>
          <target state="translated">lang項目を再定義しました。</target>
        </trans-unit>
        <trans-unit id="6ffd27d3b6539a3465361b45b3e5461748a1b187" translate="yes" xml:space="preserve">
          <source>A large number of the structures provided by &lt;code&gt;std::io&lt;/code&gt; are for various ways of iterating over I/O. For example, &lt;a href=&quot;struct.lines&quot;&gt;&lt;code&gt;Lines&lt;/code&gt;&lt;/a&gt; is used to split over lines:</source>
          <target state="translated">&lt;code&gt;std::io&lt;/code&gt; によって提供される多数の構造は、I / Oを反復するさまざまな方法のためのものです。たとえば、&lt;a href=&quot;struct.lines&quot;&gt; &lt;code&gt;Lines&lt;/code&gt; は行&lt;/a&gt;を分割するために使用されます。</target>
        </trans-unit>
        <trans-unit id="662b6a3ff994171dfffca1e061e7e8ce70b26c02" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the difference of &lt;code&gt;BTreeSet&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;BTreeSet&lt;/code&gt; の違いで要素を生成する遅延イテレータ。</target>
        </trans-unit>
        <trans-unit id="78a980f05e3a46c3d69eb02390416d427839b9ce" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the difference of &lt;code&gt;HashSet&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;HashSet&lt;/code&gt; の違いで要素を生成する遅延イテレータ。</target>
        </trans-unit>
        <trans-unit id="b8f2ea928876732f6cdd8b20aeb46e1a07becd11" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the intersection of &lt;code&gt;BTreeSet&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;BTreeSet&lt;/code&gt; の共通部分に要素を生成する遅延イテレータ。</target>
        </trans-unit>
        <trans-unit id="298c27c033e43f06428f6ee3aa3dd406f79bfc1d" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the intersection of &lt;code&gt;HashSet&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;HashSet&lt;/code&gt; の共通部分に要素を生成する遅延イテレータ。</target>
        </trans-unit>
        <trans-unit id="5e5f0a0d812adca265e03240d1f5f96e6f3c302c" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the symmetric difference of &lt;code&gt;BTreeSet&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;BTreeSet&lt;/code&gt; の対称的な違いで要素を生成する遅延イテレータ。</target>
        </trans-unit>
        <trans-unit id="5248d39b20b8a278703de3ef71e840882448f153" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the symmetric difference of &lt;code&gt;HashSet&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;HashSet&lt;/code&gt; の対称的な違いで要素を生成する遅延イテレータ。</target>
        </trans-unit>
        <trans-unit id="0f9f2f9fdddb7747ea07bd3f3640c23d49782e5c" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the union of &lt;code&gt;BTreeSet&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;BTreeSet&lt;/code&gt; の和集合で要素を生成する遅延イテレータ。</target>
        </trans-unit>
        <trans-unit id="fc9bf6d7c1e4850a63411aee9c08fbc8782aa61a" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the union of &lt;code&gt;HashSet&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;HashSet&lt;/code&gt; の和集合で要素を生成する遅延イテレータ。</target>
        </trans-unit>
        <trans-unit id="32415c91edd2506ae578a648363d87b8a79c9954" translate="yes" xml:space="preserve">
          <source>A library developer needs to expose functionality to crates which link against their library. As a consequence of the first case, this means that anything which is usable externally must be &lt;code&gt;pub&lt;/code&gt; from the root down to the destination item. Any private item in the chain will disallow external accesses.</source>
          <target state="translated">ライブラリ開発者は、ライブラリにリンクするクレートに機能を公開する必要があります。最初のケースの結果として、これは、外部で使用できるものはすべて、ルートから宛先アイテムまでの &lt;code&gt;pub&lt;/code&gt; なければならないことを意味します。チェーン内のプライベートアイテムは、外部アクセスを許可しません。</target>
        </trans-unit>
        <trans-unit id="6ffc7aa510e5357070634b59c577ca85e2c2292b" translate="yes" xml:space="preserve">
          <source>A lifetime appears only in an associated-type binding, and not in the input types to the trait.</source>
          <target state="translated">ライフタイムは、関連付けられたタイプのバインディングでのみ表示され、形質への入力タイプでは表示されません。</target>
        </trans-unit>
        <trans-unit id="15786eaf619ace068790ae58d796d7da4d047a8c" translate="yes" xml:space="preserve">
          <source>A lifetime bound on a trait implementation was captured at an incorrect place.</source>
          <target state="translated">形質実装のライフタイム バインドが不正な場所で捕捉されました。</target>
        </trans-unit>
        <trans-unit id="7c38295bdcc0eafcba2929a676ec6ceb8e9304c9" translate="yes" xml:space="preserve">
          <source>A lifetime bound was not satisfied.</source>
          <target state="translated">ライフタイムバインドが満たされていなかった。</target>
        </trans-unit>
        <trans-unit id="f5eb99d9ba1d633f5bab932159c4263f91c6e225" translate="yes" xml:space="preserve">
          <source>A lifetime cannot be determined in the given situation.</source>
          <target state="translated">与えられた状況下では、生涯を決定することはできません。</target>
        </trans-unit>
        <trans-unit id="f5cad79ba7fd3784fc14fc3f6b2c2d3527062c63" translate="yes" xml:space="preserve">
          <source>A lifetime didn't match what was expected.</source>
          <target state="translated">一期一会は期待されていたものとは違っていた。</target>
        </trans-unit>
        <trans-unit id="f2036255cc30a38458aebc41a1b7522c2030656d" translate="yes" xml:space="preserve">
          <source>A lifetime is only present in an associated-type binding, and not in the input types to the trait.</source>
          <target state="translated">ライフタイムは、関連付けられたタイプのバインディングにのみ存在し、形質への入力タイプには存在しません。</target>
        </trans-unit>
        <trans-unit id="7b0bc06cbbd42c2c42f3c7edb056daf04c8c1022" translate="yes" xml:space="preserve">
          <source>A lifetime name cannot be declared more than once in the same scope. For example:</source>
          <target state="translated">ライフタイム名は、同じスコープ内で複数回宣言することはできません。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="315c1653fb8738d323beeedab26038fcdebdd0a1" translate="yes" xml:space="preserve">
          <source>A lifetime name is shadowing another lifetime name.</source>
          <target state="translated">終身の名前が別の終身の名前に影を落としている。</target>
        </trans-unit>
        <trans-unit id="24a3a2bd418c09a4c4c2d74fd258bdb9f00cd151" translate="yes" xml:space="preserve">
          <source>A lifetime name is shadowing another lifetime name. Erroneous code example:</source>
          <target state="translated">ライフタイム名が別のライフタイム名の影になっています。誤ったコード例です。</target>
        </trans-unit>
        <trans-unit id="60dd9352a1988e94c38ce60166a9c885adb54457" translate="yes" xml:space="preserve">
          <source>A lifetime was declared more than once in the same scope.</source>
          <target state="translated">同一の範囲内で複数回、ライフタイムを宣言していた。</target>
        </trans-unit>
        <trans-unit id="6c742ea21e8d68de6fe9c8cd053579ea9357b0ab" translate="yes" xml:space="preserve">
          <source>A link name was given with an empty name.</source>
          <target state="translated">リンク名に空の名前が付けられていました。</target>
        </trans-unit>
        <trans-unit id="e76bb7dad8b82c5bd8c5e995749d2ddcac1434e4" translate="yes" xml:space="preserve">
          <source>A link name was given with an empty name. Erroneous code example:</source>
          <target state="translated">リンク名が空の名前で与えられました。誤ったコード例です。</target>
        </trans-unit>
        <trans-unit id="7aff8ae0fa99ab18b982ebf4bf49db472c773b53" translate="yes" xml:space="preserve">
          <source>A link was used without a name parameter.</source>
          <target state="translated">名前のパラメータがないリンクが使用されていました。</target>
        </trans-unit>
        <trans-unit id="916890e2e829b39ca74b6c85b7ab19a70dff37fc" translate="yes" xml:space="preserve">
          <source>A link was used without a name parameter. Erroneous code example:</source>
          <target state="translated">name パラメータを指定せずにリンクを使用しました。誤ったコード例です。</target>
        </trans-unit>
        <trans-unit id="ac64cfd6177747480c1f0a80dd27bc3c2253949c" translate="yes" xml:space="preserve">
          <source>A lint check attribute was overruled by a &lt;code&gt;forbid&lt;/code&gt; directive set as an attribute on an enclosing scope, or on the command line with the &lt;code&gt;-F&lt;/code&gt; option.</source>
          <target state="translated">lintチェック属性は、外側のスコープまたは &lt;code&gt;-F&lt;/code&gt; オプションを指定したコマンドラインで属性として設定された &lt;code&gt;forbid&lt;/code&gt; ディレクティブによって無効にされました。</target>
        </trans-unit>
        <trans-unit id="4ec2e82a43ec2456c074c084d9bde606ea9ab3b3" translate="yes" xml:space="preserve">
          <source>A lint check names a potentially undesirable coding pattern, such as unreachable code or omitted documentation. The lint attributes &lt;code&gt;allow&lt;/code&gt;, &lt;code&gt;warn&lt;/code&gt;, &lt;code&gt;deny&lt;/code&gt;, and &lt;code&gt;forbid&lt;/code&gt; use the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListPaths&lt;/em&gt;&lt;/a&gt; syntax to specify a list of lint names to change the lint level for the entity to which the attribute applies.</source>
          <target state="translated">lintチェックは、到達できないコードや省略されたドキュメントなど、潜在的に望ましくないコーディングパターンを示します。糸くずの属性は、 &lt;code&gt;allow&lt;/code&gt; 、 &lt;code&gt;warn&lt;/code&gt; 、 &lt;code&gt;deny&lt;/code&gt; 、および &lt;code&gt;forbid&lt;/code&gt; 使用&lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListPaths&lt;/em&gt;&lt;/a&gt;属性が適用されるエンティティの糸くずのレベルを変更するために糸くず名のリストを指定する構文を。</target>
        </trans-unit>
        <trans-unit id="2f470d70068148b9c3f60f9da5c6e02f3a36f8a9" translate="yes" xml:space="preserve">
          <source>A list of available external lang items is available in &lt;code&gt;src/librustc/middle/weak_lang_items.rs&lt;/code&gt;. Example:</source>
          <target state="translated">使用可能な外部langアイテムのリストは、 &lt;code&gt;src/librustc/middle/weak_lang_items.rs&lt;/code&gt; にあります。例：</target>
        </trans-unit>
        <trans-unit id="a93ce4eba1c20223d4f7efd374435922dc780a28" translate="yes" xml:space="preserve">
          <source>A list of available external lang items is available in &lt;code&gt;src/librustc_middle/middle/weak_lang_items.rs&lt;/code&gt;. Example:</source>
          <target state="translated">利用可能な外部langアイテムのリストは、 &lt;code&gt;src/librustc_middle/middle/weak_lang_items.rs&lt;/code&gt; ます。例：</target>
        </trans-unit>
        <trans-unit id="508df8833b23d4b6921f12bfae0871fdb8efa7ce" translate="yes" xml:space="preserve">
          <source>A list specifying general categories of I/O error.</source>
          <target state="translated">I/Oエラーの一般的なカテゴリを指定したリスト。</target>
        </trans-unit>
        <trans-unit id="6afbc1cd2e7b35cec4d1c86812f59ca981f43d9f" translate="yes" xml:space="preserve">
          <source>A list with each element, i.e., &lt;code&gt;[x, y, z]&lt;/code&gt;.</source>
          <target state="translated">各要素、つまり &lt;code&gt;[x, y, z]&lt;/code&gt; のリスト。</target>
        </trans-unit>
        <trans-unit id="15c8d2d5a110eff4a4e3eff0337b45af3836ff58" translate="yes" xml:space="preserve">
          <source>A literal is an expression consisting of a single token, rather than a sequence of tokens, that immediately and directly denotes the value it evaluates to, rather than referring to it by name or some other evaluation rule. A literal is a form of &lt;a href=&quot;const_eval#constant-expressions&quot;&gt;constant expression&lt;/a&gt;, so is evaluated (primarily) at compile time.</source>
          <target state="translated">リテラルは、トークンのシーケンスではなく単一のトークンで構成される式であり、名前やその他の評価ルールで参照するのではなく、評価する値を直接かつ直接示します。リテラルは&lt;a href=&quot;const_eval#constant-expressions&quot;&gt;定数式の&lt;/a&gt;形式であるため、コンパイル時に（主に）評価されます。</target>
        </trans-unit>
        <trans-unit id="1857afd88875f6678401e5a6388b40ec5e076688" translate="yes" xml:space="preserve">
          <source>A literal value was used inside &lt;code&gt;#[derive]&lt;/code&gt;.</source>
          <target state="translated">リテラル値が &lt;code&gt;#[derive]&lt;/code&gt; 内で使用されました。</target>
        </trans-unit>
        <trans-unit id="7acc2bbca8147fd009370161f8e9ac4665c257d0" translate="yes" xml:space="preserve">
          <source>A literal was used in a built-in attribute that doesn't support literals.</source>
          <target state="translated">リテラルをサポートしない組み込み属性でリテラルが使用されました。</target>
        </trans-unit>
        <trans-unit id="efa9c544d88ff2ed4857caf7a6d5b87ab71f9e34" translate="yes" xml:space="preserve">
          <source>A little reminder: a doc comment has to be placed before the item it's supposed to document. So if you want to document the &lt;code&gt;Island&lt;/code&gt; trait, you need to put a doc comment before it, not inside it. Same goes for the &lt;code&gt;lost&lt;/code&gt; method: the doc comment needs to be before it:</source>
          <target state="translated">ちょっとした注意：ドキュメントコメントは、ドキュメント化する予定のアイテムの前に配置する必要があります。したがって、 &lt;code&gt;Island&lt;/code&gt; 特性を文書化する場合は、島の内部ではなく、その前にドキュメントコメントを配置する必要があります。 &lt;code&gt;lost&lt;/code&gt; メソッドについても同じことが言えます。ドキュメントコメントはその前にある必要があります。</target>
        </trans-unit>
        <trans-unit id="8c7298eaf33d5d7b34d2bf261698fdf05d319588" translate="yes" xml:space="preserve">
          <source>A locked reference to the &lt;code&gt;Stderr&lt;/code&gt; handle.</source>
          <target state="translated">&lt;code&gt;Stderr&lt;/code&gt; ハンドルへのロックされた参照。</target>
        </trans-unit>
        <trans-unit id="e64008e4cbb40a24042f57f0ba8206541604d8ca" translate="yes" xml:space="preserve">
          <source>A locked reference to the &lt;code&gt;Stdin&lt;/code&gt; handle.</source>
          <target state="translated">&lt;code&gt;Stdin&lt;/code&gt; ハンドルへのロックされた参照。</target>
        </trans-unit>
        <trans-unit id="27f936b73151ca7329818fe3daa46cf14b38bc95" translate="yes" xml:space="preserve">
          <source>A locked reference to the &lt;code&gt;Stdout&lt;/code&gt; handle.</source>
          <target state="translated">&lt;code&gt;Stdout&lt;/code&gt; ハンドルへのロックされた参照。</target>
        </trans-unit>
        <trans-unit id="209614c8cbb6478d39bb33efacb63355ac82d199" translate="yes" xml:space="preserve">
          <source>A locked standard input implements &lt;code&gt;BufRead&lt;/code&gt;:</source>
          <target state="translated">ロックされた標準入力は &lt;code&gt;BufRead&lt;/code&gt; を実装します：</target>
        </trans-unit>
        <trans-unit id="3af527db8725fae95a62589160c6f0f2118456fd" translate="yes" xml:space="preserve">
          <source>A loop expression may optionally have a &lt;em&gt;label&lt;/em&gt;. The label is written as a lifetime preceding the loop expression, as in &lt;code&gt;'foo: loop { break 'foo; }&lt;/code&gt;, &lt;code&gt;'bar: while false {}&lt;/code&gt;, &lt;code&gt;'humbug: for _ in 0..0 {}&lt;/code&gt;. If a label is present, then labeled &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; expressions nested within this loop may exit out of this loop or return control to its head. See &lt;a href=&quot;#break-expressions&quot;&gt;break expressions&lt;/a&gt; and &lt;a href=&quot;#continue-expressions&quot;&gt;continue expressions&lt;/a&gt;.</source>
          <target state="translated">ループ式には、オプションで&lt;em&gt;ラベルを付ける&lt;/em&gt;ことができます。ラベルは、 &lt;code&gt;'foo: loop { break 'foo; }&lt;/code&gt; ように、ループ式の前の有効期間として書き込まれます。}、 &lt;code&gt;'bar: while false {}&lt;/code&gt; 、 &lt;code&gt;'humbug: for _ in 0..0 {}&lt;/code&gt; 。ラベルが存在する場合、このループ内にネストされたラベル付きの &lt;code&gt;break&lt;/code&gt; および &lt;code&gt;continue&lt;/code&gt; 式は、このループを終了するか、制御をその先頭に戻す可能性があります。&lt;a href=&quot;#break-expressions&quot;&gt;ブレーク式&lt;/a&gt;と&lt;a href=&quot;#continue-expressions&quot;&gt;コンティニュー式を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="3748fe7789bb3fdcadf97f48b577f7242f80249c" translate="yes" xml:space="preserve">
          <source>A loop expression may optionally have a &lt;em&gt;label&lt;/em&gt;. The label is written as a lifetime preceding the loop expression, as in &lt;code&gt;'foo: loop { break 'foo; }&lt;/code&gt;, &lt;code&gt;'bar: while false {}&lt;/code&gt;, &lt;code&gt;'humbug: for _ in 0..0 {}&lt;/code&gt;. If a label is present, then labeled &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; expressions nested within this loop may exit out of this loop or return control to its head. See &lt;a href=&quot;loop-expr#break-expressions&quot;&gt;break expressions&lt;/a&gt; and &lt;a href=&quot;loop-expr#continue-expressions&quot;&gt;continue expressions&lt;/a&gt;.</source>
          <target state="translated">ループ式にはオプションで&lt;em&gt;ラベルを付ける&lt;/em&gt;ことができます。ラベルは、 &lt;code&gt;'foo: loop { break 'foo; }&lt;/code&gt; ように、ループ式の前に存続期間として書き込まれます。}、 &lt;code&gt;'bar: while false {}&lt;/code&gt; 、 &lt;code&gt;'humbug: for _ in 0..0 {}&lt;/code&gt; 。ラベルが存在する場合、このループ内にネストされたラベル付きの &lt;code&gt;break&lt;/code&gt; および &lt;code&gt;continue&lt;/code&gt; 式は、このループを終了するか、制御を先頭に戻す場合があります。&lt;a href=&quot;loop-expr#break-expressions&quot;&gt;break式&lt;/a&gt;と&lt;a href=&quot;loop-expr#continue-expressions&quot;&gt;continue式を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="621a2333164d1c1ddcc3e28445c529a5edcd0f4d" translate="yes" xml:space="preserve">
          <source>A loop keyword (&lt;code&gt;break&lt;/code&gt; or &lt;code&gt;continue&lt;/code&gt;) was used inside a closure but outside of any loop.</source>
          <target state="translated">ループキーワード（ &lt;code&gt;break&lt;/code&gt; または &lt;code&gt;continue&lt;/code&gt; ）がクロージャの内側で使用されましたが、ループの外側で使用されました。</target>
        </trans-unit>
        <trans-unit id="f49094ffad160345ac5b867a45ab1d0476b39ead" translate="yes" xml:space="preserve">
          <source>A loop keyword (&lt;code&gt;break&lt;/code&gt; or &lt;code&gt;continue&lt;/code&gt;) was used outside of a loop.</source>
          <target state="translated">ループキーワード（ &lt;code&gt;break&lt;/code&gt; または &lt;code&gt;continue&lt;/code&gt; ）がループの外側で使用されました。</target>
        </trans-unit>
        <trans-unit id="511e4a1a5b552d0daef468f2387fb6edd0e92546" translate="yes" xml:space="preserve">
          <source>A lossy decoder can be obtained by replacing &lt;code&gt;Err&lt;/code&gt; results with the replacement character:</source>
          <target state="translated">非可逆デコーダーは、 &lt;code&gt;Err&lt;/code&gt; の結果を置換文字に置き換えることで取得できます。</target>
        </trans-unit>
        <trans-unit id="aaa61df7a5c37f0e9baf2b1d7a2af95d48009664" translate="yes" xml:space="preserve">
          <source>A lower range wasn't less than the upper range.</source>
          <target state="translated">下位レンジは上位レンジ以下ではありませんでした。</target>
        </trans-unit>
        <trans-unit id="d97f1261b9b58d3e3fe4caf6b3ed4e3d57f050f7" translate="yes" xml:space="preserve">
          <source>A macro invocation executes a macro at compile time and replaces the invocation with the result of the macro. Macros may be invoked in the following situations:</source>
          <target state="translated">マクロ呼び出しはコンパイル時にマクロを実行し、呼び出しをマクロの結果に置き換えます。マクロは、次のような状況で呼び出されることがあります。</target>
        </trans-unit>
        <trans-unit id="604f17220a435dfda6ce25b3286e96cae9c124f4" translate="yes" xml:space="preserve">
          <source>A macro listed for import was not found.</source>
          <target state="translated">インポート用にリストアップされたマクロが見つかりませんでした。</target>
        </trans-unit>
        <trans-unit id="2e0526607109d7012469029a56fd3ee785be2e0d" translate="yes" xml:space="preserve">
          <source>A macro to test at &lt;em&gt;runtime&lt;/em&gt; whether a CPU feature is available on x86/x86-64 platforms.</source>
          <target state="translated">CPU機能がx86 / x86-64プラットフォームで使用可能かどうかを&lt;em&gt;実行時&lt;/em&gt;にテストするマクロ。</target>
        </trans-unit>
        <trans-unit id="5b9ba25200988be7523c79ceef0a08b5dbf3a289" translate="yes" xml:space="preserve">
          <source>A major goal of the compiler is to ensure that a library never appears more than once in any artifact. For example, if dynamic libraries B and C were each statically linked to library A, then a crate could not link to B and C together because there would be two copies of A. The compiler allows mixing the rlib and dylib formats, but this restriction must be satisfied.</source>
          <target state="translated">コンパイラの主な目標は、どのような成果物でもライブラリが二度以上現れないようにすることです。例えば、ダイナミック・ライブラリ B と C がそれぞれライブラリ A に静的にリンクされている場合、A のコピーが 2 つあるため、クレートは B と C を一緒にリンクすることができません。</target>
        </trans-unit>
        <trans-unit id="416ce06261874aaff012fa6c737cea866a967092" translate="yes" xml:space="preserve">
          <source>A map based on a B-Tree.</source>
          <target state="translated">B-Treeをベースにした地図。</target>
        </trans-unit>
        <trans-unit id="f2df32e1b651fa8937f10fb914a69befa91dcf32" translate="yes" xml:space="preserve">
          <source>A marker trait representing types where a shared reference is considered unwind safe.</source>
          <target state="translated">共有参照が巻き戻しセーフとみなされる型を表すマーカー形質。</target>
        </trans-unit>
        <trans-unit id="3bc97c0d55aa2cae1126bc3f3d83ef27e23658de" translate="yes" xml:space="preserve">
          <source>A marker trait to express that a &lt;a href=&quot;trait.reversesearcher&quot;&gt;&lt;code&gt;ReverseSearcher&lt;/code&gt;&lt;/a&gt; can be used for a &lt;a href=&quot;../../iter/trait.doubleendediterator&quot;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt; implementation.</source>
          <target state="translated">ことを表現するマーカー形質&lt;a href=&quot;trait.reversesearcher&quot;&gt; &lt;code&gt;ReverseSearcher&lt;/code&gt; の&lt;/a&gt;ために使用することができる&lt;a href=&quot;../../iter/trait.doubleendediterator&quot;&gt; &lt;code&gt;DoubleEndedIterator&lt;/code&gt; の&lt;/a&gt;実装。</target>
        </trans-unit>
        <trans-unit id="ba67e3276d83805bffe74ea0a7a327593cf9467b" translate="yes" xml:space="preserve">
          <source>A marker trait to express that a &lt;code&gt;ReverseSearcher&lt;/code&gt; can be used for a &lt;code&gt;DoubleEndedIterator&lt;/code&gt; implementation.</source>
          <target state="translated">ことを表現するマーカー形質 &lt;code&gt;ReverseSearcher&lt;/code&gt; のために使用することができる &lt;code&gt;DoubleEndedIterator&lt;/code&gt; の実装。</target>
        </trans-unit>
        <trans-unit id="2f67969c6f12d96330ceaae49a9df5d58837b264" translate="yes" xml:space="preserve">
          <source>A marker trait which represents &quot;panic safe&quot; types in Rust.</source>
          <target state="translated">Rustで「パニックセーフ」タイプを表すマーカー形質。</target>
        </trans-unit>
        <trans-unit id="7c9160659faee9d41f691cb8f88f2f8a49c219c0" translate="yes" xml:space="preserve">
          <source>A marker type which does not implement &lt;code&gt;Unpin&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Unpin&lt;/code&gt; を実装しないマーカータイプ。</target>
        </trans-unit>
        <trans-unit id="2cd086d02e989df16ae8561bd2410188577f706c" translate="yes" xml:space="preserve">
          <source>A measurement of a monotonically nondecreasing clock. Opaque and useful only with &lt;code&gt;Duration&lt;/code&gt;.</source>
          <target state="translated">単調に減少しないクロックの測定値。不透明で、 &lt;code&gt;Duration&lt;/code&gt; でのみ役立ちます。</target>
        </trans-unit>
        <trans-unit id="f1b2d1acc7998286a04c3bbe416b5e64b3d2a408" translate="yes" xml:space="preserve">
          <source>A measurement of the system clock, useful for talking to external entities like the file system or other processes.</source>
          <target state="translated">システムクロックの測定値で、ファイルシステムや他のプロセスのような外部エンティティとの通信に便利です。</target>
        </trans-unit>
        <trans-unit id="ab0a8ccacb7225c2d2eaa3d61513ce8be0301515" translate="yes" xml:space="preserve">
          <source>A memory allocator that can be registered as the standard library&amp;rsquo;s default though the &lt;code&gt;#[global_allocator]&lt;/code&gt; attributes.</source>
          <target state="translated">&lt;code&gt;#[global_allocator]&lt;/code&gt; 属性を使用して標準ライブラリのデフォルトとして登録できるメモリアロケータ。</target>
        </trans-unit>
        <trans-unit id="36390b8dd6062ca0b9666a02db751bef68ddc91f" translate="yes" xml:space="preserve">
          <source>A memory allocator that can be registered as the standard library&amp;rsquo;s default through the &lt;code&gt;#[global_allocator]&lt;/code&gt; attribute.</source>
          <target state="translated">&lt;code&gt;#[global_allocator]&lt;/code&gt; 属性を介して標準ライブラリのデフォルトとして登録できるメモリアロケータ。</target>
        </trans-unit>
        <trans-unit id="f52897b7b1a254a773b596ff34aeb774856f7c04" translate="yes" xml:space="preserve">
          <source>A metavariable must appear in exactly the same number, kind, and nesting order of repetitions in the transcriber as it did in the matcher. So for the matcher &lt;code&gt;$( $i:ident ),*&lt;/code&gt;, the transcribers &lt;code&gt;=&amp;gt; { $i }&lt;/code&gt;, &lt;code&gt;=&amp;gt; { $( $( $i)* )* }&lt;/code&gt;, and &lt;code&gt;=&amp;gt; { $( $i )+ }&lt;/code&gt; are all illegal, but &lt;code&gt;=&amp;gt; { $( $i );* }&lt;/code&gt; is correct and replaces a comma-separated list of identifiers with a semicolon-separated list.</source>
          <target state="translated">メタ変数は、マッチャーで行われたのとまったく同じ数、種類、および繰り返しのネストのネスト順で出現する必要があります。したがって、マッチャー &lt;code&gt;$( $i:ident ),*&lt;/code&gt; 場合、転写者 &lt;code&gt;=&amp;gt; { $i }&lt;/code&gt; 、 &lt;code&gt;=&amp;gt; { $( $( $i)* )* }&lt;/code&gt; 、および &lt;code&gt;=&amp;gt; { $( $i )+ }&lt;/code&gt; は、 &lt;code&gt;=&amp;gt; { $( $i );* }&lt;/code&gt; はすべて不正ですが、識別子のコンマ区切りリストをセミコロン区切りリストに置き換えます。</target>
        </trans-unit>
        <trans-unit id="8b9a4a11c65ef071b5b26c72c1c0d6cc7317036f" translate="yes" xml:space="preserve">
          <source>A method or constant was implemented on a primitive type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="801757bf4a897de3dc38db9dc1b65e4429ae7c96" translate="yes" xml:space="preserve">
          <source>A method was called on a raw pointer whose inner type wasn't completely known.</source>
          <target state="translated">内部の型が完全にわかっていない生のポインタに対してメソッドが呼び出されました。</target>
        </trans-unit>
        <trans-unit id="da23ec6794439455d8bda2444d9dc191c1a91b2b" translate="yes" xml:space="preserve">
          <source>A method was called on an ambiguous numeric type.</source>
          <target state="translated">曖昧な数値型に対してメソッドが呼び出されました。</target>
        </trans-unit>
        <trans-unit id="cb6424b2d67ae2d104f32890640da913ac560f8f" translate="yes" xml:space="preserve">
          <source>A method was implemented on a primitive type.</source>
          <target state="translated">プリミティブ型にメソッドを実装しました。</target>
        </trans-unit>
        <trans-unit id="b83bd54b545ece8364d586c3e7f838baf02e8c65" translate="yes" xml:space="preserve">
          <source>A method was implemented when another trait item was expected.</source>
          <target state="translated">別の形質項目が予想される場合のメソッドを実装しました。</target>
        </trans-unit>
        <trans-unit id="0b9ba16b85d0fa75f6c2790fe89555c2da2a5ee8" translate="yes" xml:space="preserve">
          <source>A method was implemented when another trait item was expected. Erroneous code example:</source>
          <target state="translated">別の形質項目が予想される場合にメソッドが実装されました。誤ったコード例です。</target>
        </trans-unit>
        <trans-unit id="30d915c6907e57ec215e0d955c2fea0a426c859a" translate="yes" xml:space="preserve">
          <source>A module can import both &lt;code&gt;std::fmt::Write&lt;/code&gt; and &lt;code&gt;std::io::Write&lt;/code&gt; and call &lt;code&gt;write!&lt;/code&gt; on objects implementing either, as objects do not typically implement both. However, the module must import the traits qualified so their names do not conflict:</source>
          <target state="translated">モジュールは &lt;code&gt;std::fmt::Write&lt;/code&gt; と &lt;code&gt;std::io::Write&lt;/code&gt; 両方をインポートして、 &lt;code&gt;write!&lt;/code&gt; を呼び出すことができます！オブジェクトは通常両方を実装していないため、どちらかを実装しているオブジェクトに対して。ただし、モジュールは修飾された特性をインポートして、名前が競合しないようにする必要があります。</target>
        </trans-unit>
        <trans-unit id="8df0b4f7cbe7a3d63c8935c00a09e49b670eda46" translate="yes" xml:space="preserve">
          <source>A module cannot be found and therefore, the visibility cannot be determined.</source>
          <target state="translated">モジュールが見つからないため、視認性を判断できない。</target>
        </trans-unit>
        <trans-unit id="9b81303b4be9b1fd6a4b7a6468837e80d06c4579" translate="yes" xml:space="preserve">
          <source>A module for working with borrowed data.</source>
          <target state="translated">借りてきたデータを扱うためのモジュール。</target>
        </trans-unit>
        <trans-unit id="279721754abe896ed73051fc4e21afc678f9887f" translate="yes" xml:space="preserve">
          <source>A module for working with processes.</source>
          <target state="translated">プロセスを扱うためのモジュール。</target>
        </trans-unit>
        <trans-unit id="6a05a78578f1dbd0078ba611f8fe4d06c249f5a6" translate="yes" xml:space="preserve">
          <source>A module is a container for zero or more &lt;a href=&quot;../items&quot;&gt;items&lt;/a&gt;.</source>
          <target state="translated">モジュールは、0個以上の&lt;a href=&quot;../items&quot;&gt;アイテムの&lt;/a&gt;コンテナです。</target>
        </trans-unit>
        <trans-unit id="c04981413bae044ff3db488edfd9ac3f31ccdfa7" translate="yes" xml:space="preserve">
          <source>A module without a body is loaded from an external file. When the module does not have a &lt;code&gt;path&lt;/code&gt; attribute, the path to the file mirrors the logical &lt;a href=&quot;../paths&quot;&gt;module path&lt;/a&gt;. Ancestor module path components are directories, and the module's contents are in a file with the name of the module plus the &lt;code&gt;.rs&lt;/code&gt; extension. For example, the following module structure can have this corresponding filesystem structure:</source>
          <target state="translated">ボディのないモジュールは外部ファイルからロードされます。モジュールに &lt;code&gt;path&lt;/code&gt; 属性がない場合、ファイル&lt;a href=&quot;../paths&quot;&gt;へのパス&lt;/a&gt;は論理モジュールパスを反映します。祖先モジュールのパスコンポーネントはディレクトリであり、モジュールのコンテンツは、モジュールの名前と &lt;code&gt;.rs&lt;/code&gt; 拡張子が付いたファイルにあります。たとえば、次のモジュール構造は、この対応するファイルシステム構造を持つことができます。</target>
        </trans-unit>
        <trans-unit id="29558e1ce9256ba552f6d5cea0ac0d8f0b314326" translate="yes" xml:space="preserve">
          <source>A more complex example:</source>
          <target state="translated">より複雑な例。</target>
        </trans-unit>
        <trans-unit id="d3b971a729c5c72b8be0c4aea17fd6538988f22d" translate="yes" xml:space="preserve">
          <source>A more complex pattern, using a closure:</source>
          <target state="translated">クロージャーを使った、より複雑なパターン。</target>
        </trans-unit>
        <trans-unit id="3dd589b621cc1adc060715bf9a9ed158d11abe3d" translate="yes" xml:space="preserve">
          <source>A more experienced Rustacean would write the signature shown in Listing 4-9 instead because it allows us to use the same function on both &lt;code&gt;&amp;amp;String&lt;/code&gt; values and &lt;code&gt;&amp;amp;str&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;&amp;amp;String&lt;/code&gt; 値と &lt;code&gt;&amp;amp;str&lt;/code&gt; 値の両方で同じ関数を使用できるため、経験豊富なRustaceanはリスト4-9に示す署名を代わりに記述します。</target>
        </trans-unit>
        <trans-unit id="e13722d1be852ba526aeffb3cbbf03d8cad62a98" translate="yes" xml:space="preserve">
          <source>A more realistic usage of &lt;code&gt;!&lt;/code&gt; is in this code:</source>
          <target state="translated">のより現実的な使用法 &lt;code&gt;!&lt;/code&gt; このコードにあります：</target>
        </trans-unit>
        <trans-unit id="47b3111cf8992e03f361ef35402077d40b862b00" translate="yes" xml:space="preserve">
          <source>A more user-friendly and stable version of this operation is &lt;a href=&quot;../process/fn.abort&quot;&gt;&lt;code&gt;std::process::abort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この操作のよりユーザーフレンドリーで安定したバージョンは、&lt;a href=&quot;../process/fn.abort&quot;&gt; &lt;code&gt;std::process::abort&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="e80c7507fc9ff231be351f8cae94b1cf2dae1652" translate="yes" xml:space="preserve">
          <source>A multi-line (doc-)comment is unterminated.</source>
          <target state="translated">複数行(doc-)のコメントは終端がありません。</target>
        </trans-unit>
        <trans-unit id="a85c20eab8c8f59bbb7b3375434e1c4c2a5fba1b" translate="yes" xml:space="preserve">
          <source>A mutable binding, reference, or pointer.</source>
          <target state="translated">変形可能なバインディング、参照、またはポインタ。</target>
        </trans-unit>
        <trans-unit id="8cd7d09d26092ca44a3f65ffe3c3325410d6931b" translate="yes" xml:space="preserve">
          <source>A mutable iterator over a sub-range of entries in a &lt;code&gt;BTreeMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BTreeMap&lt;/code&gt; のエントリのサブ範囲に対する可変イテレータ。</target>
        </trans-unit>
        <trans-unit id="0adc791ed0f0c19141af510a4b25898187d82ab6" translate="yes" xml:space="preserve">
          <source>A mutable iterator over the elements of a &lt;code&gt;LinkedList&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LinkedList&lt;/code&gt; の要素に対する変更可能な反復子。</target>
        </trans-unit>
        <trans-unit id="ad89e0aaae2a988478ed905cd86eb0dc9435d0ff" translate="yes" xml:space="preserve">
          <source>A mutable iterator over the elements of a &lt;code&gt;VecDeque&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;VecDeque&lt;/code&gt; の要素に対する変更可能な反復子。</target>
        </trans-unit>
        <trans-unit id="79c92db5fb2c00374466341575412a72b346b96d" translate="yes" xml:space="preserve">
          <source>A mutable iterator over the entries of a &lt;code&gt;BTreeMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BTreeMap&lt;/code&gt; のエントリに対する変更可能な反復子。</target>
        </trans-unit>
        <trans-unit id="82c043e3bfeb960195491db7d3d334e90cb7714f" translate="yes" xml:space="preserve">
          <source>A mutable iterator over the entries of a &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; のエントリに対する変更可能な反復子。</target>
        </trans-unit>
        <trans-unit id="d985ac327f38804e748201a497e2781eda7b7dde" translate="yes" xml:space="preserve">
          <source>A mutable iterator over the values of a &lt;code&gt;BTreeMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BTreeMap&lt;/code&gt; の値に対する変更可能な反復子。</target>
        </trans-unit>
        <trans-unit id="3180573575f9ee53aeac5bbb0709534becff511d" translate="yes" xml:space="preserve">
          <source>A mutable iterator over the values of a &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; の値に対する変更可能な反復子。</target>
        </trans-unit>
        <trans-unit id="8b90716d837b7248d5e9906c50d0a99bd6595870" translate="yes" xml:space="preserve">
          <source>A mutable memory location with dynamically checked borrow rules</source>
          <target state="translated">動的にチェックされた借用ルールを備えた、ミュータブルなメモリロケーション</target>
        </trans-unit>
        <trans-unit id="c91e5fa32d436ead641cd9a3940ea6b760cc8d42" translate="yes" xml:space="preserve">
          <source>A mutable memory location.</source>
          <target state="translated">変形可能なメモリの位置。</target>
        </trans-unit>
        <trans-unit id="0b14b941c806b921d8ab056b2552003af1435118" translate="yes" xml:space="preserve">
          <source>A mutable reference can be created with &lt;code&gt;&amp;amp;mut&lt;/code&gt;.</source>
          <target state="translated">可変参照は &lt;code&gt;&amp;amp;mut&lt;/code&gt; で作成できます。</target>
        </trans-unit>
        <trans-unit id="aa831fb6e4681d63ec9057ce3580c443fec9edb2" translate="yes" xml:space="preserve">
          <source>A mutable reference was used in a constant.</source>
          <target state="translated">変形可能な参照が定数で使用されていました。</target>
        </trans-unit>
        <trans-unit id="7ad0f3cf407381fd22bba2cf586e95f6a6a15615" translate="yes" xml:space="preserve">
          <source>A mutable variable is used but it is already captured by a closure.</source>
          <target state="translated">変異可能な変数が使用されていますが、すでにクロージャによって捕捉されています。</target>
        </trans-unit>
        <trans-unit id="1ceef8798472360db16ce7d238d9ede4272142f3" translate="yes" xml:space="preserve">
          <source>A mutable variable, reference, or pointer.</source>
          <target state="translated">変形可能な変数、参照、またはポインタ。</target>
        </trans-unit>
        <trans-unit id="0f8c1096d067dc232cad356da19d2cbebed307a4" translate="yes" xml:space="preserve">
          <source>A mutual exclusion primitive useful for protecting shared data</source>
          <target state="translated">共有データの保護に有用な相互排除プリミティブ</target>
        </trans-unit>
        <trans-unit id="342f794408fe251ce7add66c87de4ca58808181b" translate="yes" xml:space="preserve">
          <source>A named address:</source>
          <target state="translated">名前のついた住所。</target>
        </trans-unit>
        <trans-unit id="01a291706f0b443b495b0b8c907121279cbace5d" translate="yes" xml:space="preserve">
          <source>A negative impl was made default impl.</source>
          <target state="translated">マイナスインプはデフォルトインプにしました。</target>
        </trans-unit>
        <trans-unit id="da1879858ed2ef626482e4f36f37eea0d652d696" translate="yes" xml:space="preserve">
          <source>A negative implementation is one that excludes a type from implementing a particular trait. Not being able to use a trait is always a safe operation, so negative implementations are always safe and never need to be marked as unsafe.</source>
          <target state="translated">負の実装とは、ある型が特定の形質を実装できないようにすることです。形質を使用できないことは常に安全な操作であるため、負の実装は常に安全であり、安全でないことをマークする必要はありません。</target>
        </trans-unit>
        <trans-unit id="64f76de0f189c143b75250fce4afe6feb8fa06dc" translate="yes" xml:space="preserve">
          <source>A negative implementation was marked as unsafe.</source>
          <target state="translated">ネガティブな実装は安全ではないとマークされていました。</target>
        </trans-unit>
        <trans-unit id="4ca3ab38594dcb0b01232bdbb9c6f42b411e7856" translate="yes" xml:space="preserve">
          <source>A new pipe should be arranged to connect the parent and child processes.</source>
          <target state="translated">親プロセスと子プロセスを接続するために、新しいパイプを配置する必要があります。</target>
        </trans-unit>
        <trans-unit id="9ef1ea249a1150bef2505217b3c43c59ac961084" translate="yes" xml:space="preserve">
          <source>A new thread can be configured before it is spawned via the &lt;a href=&quot;struct.builder&quot;&gt;&lt;code&gt;Builder&lt;/code&gt;&lt;/a&gt; type, which currently allows you to set the name and stack size for the child thread:</source>
          <target state="translated">新しいスレッドは、&lt;a href=&quot;struct.builder&quot;&gt; &lt;code&gt;Builder&lt;/code&gt; &lt;/a&gt;タイプを介して生成される前に構成できます。これにより、現在、子スレッドの名前とスタックサイズを設定できます。</target>
        </trans-unit>
        <trans-unit id="5e4ae553ae5846b13d461bd059795986a05e550e" translate="yes" xml:space="preserve">
          <source>A new thread can be spawned using the &lt;a href=&quot;fn.spawn&quot;&gt;&lt;code&gt;thread::spawn&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">新しいスレッドは、&lt;a href=&quot;fn.spawn&quot;&gt; &lt;code&gt;thread::spawn&lt;/code&gt; &lt;/a&gt;関数を使用して生成できます。</target>
        </trans-unit>
        <trans-unit id="012e80e619e9a75c91e5b48d3d4ff0741fba078e" translate="yes" xml:space="preserve">
          <source>A node will be able to refer to its parent node but doesn&amp;rsquo;t own its parent. In Listing 15-28, we update &lt;code&gt;main&lt;/code&gt; to use this new definition so the &lt;code&gt;leaf&lt;/code&gt; node will have a way to refer to its parent, &lt;code&gt;branch&lt;/code&gt;:</source>
          <target state="translated">ノードはその親ノードを参照できますが、その親を所有していません。リスト15-28では、 &lt;code&gt;main&lt;/code&gt; を更新してこの新しい定義を使用するため、 &lt;code&gt;leaf&lt;/code&gt; ノードは親 &lt;code&gt;branch&lt;/code&gt; を参照する方法を持っています：</target>
        </trans-unit>
        <trans-unit id="0d77bcf0653e102d2dc04011199024bd95fbb9db" translate="yes" xml:space="preserve">
          <source>A non-&lt;code&gt;'static&lt;/code&gt; lifetime was used in a const generic. This is currently not allowed.</source>
          <target state="translated">非 &lt;code&gt;'static&lt;/code&gt; ライフタイムがconstジェネリックで使用されました。現在、これは許可されていません。</target>
        </trans-unit>
        <trans-unit id="1c1956450560b920c7d29f562d8c785a2a837c6c" translate="yes" xml:space="preserve">
          <source>A non-constant value was used in a constant expression.</source>
          <target state="translated">定数式の中に非定数値が使われていました。</target>
        </trans-unit>
        <trans-unit id="1eee5bad5b1b537626b09062a59e028d86d55ec2" translate="yes" xml:space="preserve">
          <source>A non-default implementation was already made on this type so it cannot be specialized further.</source>
          <target state="translated">この型はすでにデフォルトではない実装がなされているので、これ以上の特化はできません。</target>
        </trans-unit>
        <trans-unit id="f749bb15fde0e4ed5d6ca2223f09a3999408a077" translate="yes" xml:space="preserve">
          <source>A non-default implementation was already made on this type so it cannot be specialized further. Erroneous code example:</source>
          <target state="translated">この型はすでにデフォルトではない実装がなされているので、これ以上の特化はできません。誤ったコード例です。</target>
        </trans-unit>
        <trans-unit id="945520bcba1761f9fc7afafe8dcc369bff6ec8f2" translate="yes" xml:space="preserve">
          <source>A non-final component in path is not a directory.</source>
          <target state="translated">パス内の非最終的なコンポーネントはディレクトリではありません。</target>
        </trans-unit>
        <trans-unit id="c1d61674888a79b8d093da31552849442beb0211" translate="yes" xml:space="preserve">
          <source>A non-ident or non-wildcard pattern has been used as a parameter of a function pointer type.</source>
          <target state="translated">非identまたは非ワイルドカードパターンが関数ポインタ型のパラメータとして使用されています。</target>
        </trans-unit>
        <trans-unit id="3c2d2a8d307a0d585bf4d4468aa00fb158ce3e7d" translate="yes" xml:space="preserve">
          <source>A non-mutable value was assigned a value.</source>
          <target state="translated">非可換的な値が代入されていました。</target>
        </trans-unit>
        <trans-unit id="6d5a3ee2105e8888d79910fc840ffa44f6ec8258" translate="yes" xml:space="preserve">
          <source>A non-raw &lt;em&gt;byte string literal&lt;/em&gt; is a sequence of ASCII characters and &lt;em&gt;escapes&lt;/em&gt;, preceded by the characters &lt;code&gt;U+0062&lt;/code&gt; (&lt;code&gt;b&lt;/code&gt;) and &lt;code&gt;U+0022&lt;/code&gt; (double-quote), and followed by the character &lt;code&gt;U+0022&lt;/code&gt;. If the character &lt;code&gt;U+0022&lt;/code&gt; is present within the literal, it must be &lt;em&gt;escaped&lt;/em&gt; by a preceding &lt;code&gt;U+005C&lt;/code&gt; (&lt;code&gt;\&lt;/code&gt;) character. Alternatively, a byte string literal can be a &lt;em&gt;raw byte string literal&lt;/em&gt;, defined below. The type of a byte string literal of length &lt;code&gt;n&lt;/code&gt; is &lt;code&gt;&amp;amp;'static [u8; n]&lt;/code&gt;.</source>
          <target state="translated">非raw &lt;em&gt;バイト文字列リテラル&lt;/em&gt;は、一連のASCII文字と&lt;em&gt;エスケープであり&lt;/em&gt;、先頭に文字 &lt;code&gt;U+0062&lt;/code&gt; （ &lt;code&gt;b&lt;/code&gt; ）と &lt;code&gt;U+0022&lt;/code&gt; （二重引用符）が続き、その後に文字 &lt;code&gt;U+0022&lt;/code&gt; が続きます。文字 &lt;code&gt;U+0022&lt;/code&gt; がリテラル内にある場合&lt;em&gt;は&lt;/em&gt;、先行する &lt;code&gt;U+005C&lt;/code&gt; （ &lt;code&gt;\&lt;/code&gt; ）文字で&lt;em&gt;エスケープ&lt;/em&gt;する必要があります。または、&lt;em&gt;バイト文字列リテラルは&lt;/em&gt;、以下で定義する&lt;em&gt;生のバイト文字&lt;/em&gt;列リテラルにすることもできます。長さ &lt;code&gt;n&lt;/code&gt; のバイト文字列リテラルの型は &lt;code&gt;&amp;amp;'static [u8; n]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5c51fee9eaaa31ddc4415e9556f81e14c7ecfe88" translate="yes" xml:space="preserve">
          <source>A non-root module attempts to import macros from another crate.</source>
          <target state="translated">root ではないモジュールが、別の木箱からマクロをインポートしようとします。</target>
        </trans-unit>
        <trans-unit id="0f7f88934a0864a48a1aa3e075daab332c8783a0" translate="yes" xml:space="preserve">
          <source>A non-root module tried to import macros from another crate.</source>
          <target state="translated">非 root モジュールが別の木箱からマクロをインポートしようとしました。</target>
        </trans-unit>
        <trans-unit id="84ccf07b47b66963a7e3e32486b9dba6e199bf07" translate="yes" xml:space="preserve">
          <source>A non-structural-match type was used as the type of a const generic parameter.</source>
          <target state="translated">constジェネリックパラメータの型として非構造マッチ型が使用されていました。</target>
        </trans-unit>
        <trans-unit id="2fa1a2ea6af29cff8cb26708218d5730128ed29d" translate="yes" xml:space="preserve">
          <source>A nonexistent interface was requested or the requested address was not local.</source>
          <target state="translated">存在しないインターフェイスが要求されたか、要求されたアドレスがローカルではありませんでした。</target>
        </trans-unit>
        <trans-unit id="96ce721c887ff14a23c8684eb9a885bd0450c6a3" translate="yes" xml:space="preserve">
          <source>A normal component, e.g., &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; in &lt;code&gt;a/b&lt;/code&gt;.</source>
          <target state="translated">通常の成分、例えば、及び &lt;code&gt;b&lt;/code&gt; で &lt;code&gt;a/b&lt;/code&gt; 。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5782d98ce3a8ef05d6f0d54e23bbea53e593ec4e" translate="yes" xml:space="preserve">
          <source>A note regarding zero-sized types and zero-sized layouts: many methods in the &lt;code&gt;Alloc&lt;/code&gt; trait state that allocation requests must be non-zero size, or else undefined behavior can result.</source>
          <target state="translated">サイズがゼロのタイプとサイズがゼロのレイアウトに関する注意： &lt;code&gt;Alloc&lt;/code&gt; トレイトの多くのメソッドは、割り当てリクエストがゼロ以外のサイズでなければならないことを述べています。そうしないと、未定義の動作が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="d70ff5d8ac6ec719cfc0758b679c32b46a7a0fdd" translate="yes" xml:space="preserve">
          <source>A null &lt;code&gt;fn&lt;/code&gt; pointer.</source>
          <target state="translated">ヌル &lt;code&gt;fn&lt;/code&gt; ポインタ。</target>
        </trans-unit>
        <trans-unit id="dbd524388dc48721a46df11a0e678684cddc1ff5" translate="yes" xml:space="preserve">
          <source>A number in a non-decimal base has no digits.</source>
          <target state="translated">10進数以外の数値には桁がありません。</target>
        </trans-unit>
        <trans-unit id="79055d577bd4470f262c27ac3d7f2c814ba28782" translate="yes" xml:space="preserve">
          <source>A panic upon overflow:</source>
          <target state="translated">溢れ出た時のパニック。</target>
        </trans-unit>
        <trans-unit id="7e451dc65737a3d0078f0a0cdca0352afd247852" translate="yes" xml:space="preserve">
          <source>A parameter type is missing a lifetime constraint or has a lifetime that does not live long enough.</source>
          <target state="translated">パラメータ型に寿命制約がないか、寿命が十分に長くないパラメータ型があります。</target>
        </trans-unit>
        <trans-unit id="c17681e220340a047c028939b5c9a6007c707423" translate="yes" xml:space="preserve">
          <source>A parameter type is missing an explicit lifetime bound and may not live long enough.</source>
          <target state="translated">パラメータ型に明示的な寿命の制限がないため、十分に長生きできない可能性があります。</target>
        </trans-unit>
        <trans-unit id="bd0627aebae59febc951bf56bcbbb5c77e2a3cca" translate="yes" xml:space="preserve">
          <source>A parameter was incorrect.</source>
          <target state="translated">パラメータに誤りがありました。</target>
        </trans-unit>
        <trans-unit id="8faec6289671e90add0a6793ff7c83244ee9ad52" translate="yes" xml:space="preserve">
          <source>A parent of the given path doesn't exist. (To create a directory and all its missing parents at the same time, use the &lt;a href=&quot;fn.create_dir_all&quot;&gt;&lt;code&gt;create_dir_all&lt;/code&gt;&lt;/a&gt; function.)</source>
          <target state="translated">指定されたパスの親は存在しません。（ディレクトリーとそのすべての欠落している親を同時に作成するには、&lt;a href=&quot;fn.create_dir_all&quot;&gt; &lt;code&gt;create_dir_all&lt;/code&gt; &lt;/a&gt;関数を使用します。）</target>
        </trans-unit>
        <trans-unit id="3c44a59945c31a15632dad83502ad5c534fa6460" translate="yes" xml:space="preserve">
          <source>A particular instance &lt;code&gt;RandomState&lt;/code&gt; will create the same instances of &lt;a href=&quot;../../hash/trait.hasher&quot;&gt;&lt;code&gt;Hasher&lt;/code&gt;&lt;/a&gt;, but the hashers created by two different &lt;code&gt;RandomState&lt;/code&gt; instances are unlikely to produce the same result for the same values.</source>
          <target state="translated">特定のインスタンス &lt;code&gt;RandomState&lt;/code&gt; は&lt;a href=&quot;../../hash/trait.hasher&quot;&gt; &lt;code&gt;Hasher&lt;/code&gt; &lt;/a&gt;の同じインスタンスを作成しますが、2つの異なる &lt;code&gt;RandomState&lt;/code&gt; インスタンスによって作成されたハッシャーが同じ値に対して同じ結果を生成することはほとんどありません。</target>
        </trans-unit>
        <trans-unit id="83b0cbf0a90bcfe2367c6fdcc070513f6d4d75f8" translate="yes" xml:space="preserve">
          <source>A particular pattern &lt;code&gt;_&lt;/code&gt; will match anything, but it never binds to a variable, so it&amp;rsquo;s often used in the last match arm. The &lt;code&gt;_&lt;/code&gt; pattern can be useful when you want to ignore any value not specified, for example. We&amp;rsquo;ll cover the &lt;code&gt;_&lt;/code&gt; pattern in more detail in the &lt;a href=&quot;ch18-03-pattern-syntax#ignoring-values-in-a-pattern&quot;&gt;&amp;ldquo;Ignoring Values in a Pattern&amp;rdquo;&lt;/a&gt; section later in this chapter.</source>
          <target state="translated">特定のパターン &lt;code&gt;_&lt;/code&gt; は何にでも一致しますが、変数にバインドされることはないため、最後の一致アームでよく使用されます。 &lt;code&gt;_&lt;/code&gt; あなたは、たとえば、指定されていない任意の値を無視したいときパターンが役立ちます。私たちは、取り上げる &lt;code&gt;_&lt;/code&gt; で詳細に模様&lt;a href=&quot;ch18-03-pattern-syntax#ignoring-values-in-a-pattern&quot;&gt;「のパターンで値を無視する」&lt;/a&gt;この章で後述します。</target>
        </trans-unit>
        <trans-unit id="1f72278829757d575931ca8a320129aa5f0521b4" translate="yes" xml:space="preserve">
          <source>A path can take two forms:</source>
          <target state="translated">パスは2つの形をとることができます。</target>
        </trans-unit>
        <trans-unit id="7908f4aa852c1de2737ef7d2b9796ba4b3783229" translate="yes" xml:space="preserve">
          <source>A pattern a &lt;code&gt;..=&lt;/code&gt; b must always have a &amp;le; b. It is an error to have a range pattern &lt;code&gt;10..=0&lt;/code&gt;, for example.</source>
          <target state="translated">パターンa &lt;code&gt;..=&lt;/code&gt; bは常にa&amp;le;bでなければなりません。たとえば、範囲パターン &lt;code&gt;10..=0&lt;/code&gt; するとエラーになります。</target>
        </trans-unit>
        <trans-unit id="891da3d988f6fc5238b5b4fb583d072b5a0287dc" translate="yes" xml:space="preserve">
          <source>A pattern attempted to extract an incorrect number of fields from a variant.</source>
          <target state="translated">パターンは、バリアントから誤った数のフィールドを抽出しようとしました。</target>
        </trans-unit>
        <trans-unit id="6d6b7416ed8a3ba7b4dcdc0423f76b297ea15288" translate="yes" xml:space="preserve">
          <source>A pattern binding is using the same name as one of the variants of a type.</source>
          <target state="translated">パターンバインディングは、型のバリアントの1つと同じ名前を使用しています。</target>
        </trans-unit>
        <trans-unit id="53b95bece3c7641fd29f13b871ae1a3d402281d9" translate="yes" xml:space="preserve">
          <source>A pattern for a struct fails to specify a sub-pattern for every one of the struct's fields.</source>
          <target state="translated">構造体のパターンでは、構造体のフィールドごとにサブパターンを指定することができません。</target>
        </trans-unit>
        <trans-unit id="2c3ec235405c966e5db61078265ddd06c38fdf87" translate="yes" xml:space="preserve">
          <source>A pattern guard may refer to the variables bound within the pattern they follow. Before evaluating the guard, a shared reference is taken to the part of the scrutinee the variable matches on. While evaluating the guard, this shared reference is then used when accessing the variable. Only when the guard evaluates to true is the value moved, or copied, from the scrutinee into the variable. This allows shared borrows to be used inside guards without moving out of the scrutinee in case guard fails to match. Moreover, by holding a shared reference while evaluating the guard, mutation inside guards is also prevented.</source>
          <target state="translated">パターンガードは、それらが従うパターン内にバインドされた変数を参照することができます。ガードを評価する前に、変数がマッチするスクルーティニーの部分に共有参照が取られます。ガードを評価している間、この共有参照は変数にアクセスする際に使用されます。ガードが真と評価された場合にのみ、値がスクルーティニーから変数に移動またはコピーされます。これにより、ガードがマッチしなかった場合でも、スクルーティニーの外に移動することなく、ガード内で共有参照を使用することができます。さらに、ガードを評価している間に共有参照を保持することで、ガード内部での突然変異も防止されます。</target>
        </trans-unit>
        <trans-unit id="bf85ec7c19381f75fc673dab8bb0b15ce1a79c9a" translate="yes" xml:space="preserve">
          <source>A pattern is said to be &lt;em&gt;refutable&lt;/em&gt; when it has the possibility of not being matched by the value it is being matched against. &lt;em&gt;Irrefutable&lt;/em&gt; patterns, on the other hand, always match the value they are being matched against. Examples:</source>
          <target state="translated">パターンは、照合される値によって照合されない可能性がある場合、&lt;em&gt;反駁&lt;/em&gt;可能であると言われます。一方、&lt;em&gt;反論できない&lt;/em&gt;パターンは常に、照合対象の値と一致します。例：</target>
        </trans-unit>
        <trans-unit id="50718096ba0e9d977821568bde4dc051a6527468" translate="yes" xml:space="preserve">
          <source>A pattern used to match against an enum variant must provide a sub-pattern for each field of the enum variant.</source>
          <target state="translated">列挙バリアントに対してマッチするためのパターンは、列挙バリアントの各フィールドに対してサブパターンを提供しなければなりません。</target>
        </trans-unit>
        <trans-unit id="bf12d88e1623c0c22171573d10a1573941789f14" translate="yes" xml:space="preserve">
          <source>A pattern used to match against an enum variant must provide a sub-pattern for each field of the enum variant. This error indicates that a pattern attempted to extract an incorrect number of fields from a variant.</source>
          <target state="translated">列挙バリアントに対してマッチするために使用されるパターンは、列挙バリアントの各フィールドに対してサブパターンを提供しなければなりません。このエラーは、パターンがバリアントから誤った数のフィールドを抽出しようとしたことを示します。</target>
        </trans-unit>
        <trans-unit id="27a0056206e19a4b052630f19a00fbd4710c685a" translate="yes" xml:space="preserve">
          <source>A pattern was declared as an argument in a foreign function declaration.</source>
          <target state="translated">外部関数宣言の引数としてパターンが宣言されていました。</target>
        </trans-unit>
        <trans-unit id="d00f0437e6924080d1afab40ce4328811dd1cc4e" translate="yes" xml:space="preserve">
          <source>A pinned pointer.</source>
          <target state="translated">ピン留めされたポインター。</target>
        </trans-unit>
        <trans-unit id="a57ac3109ff2b056cae1f3bd5a56c84d66c44184" translate="yes" xml:space="preserve">
          <source>A place that is valid for the duration of a program.</source>
          <target state="translated">番組の期間中に有効な場所。</target>
        </trans-unit>
        <trans-unit id="7d0a1c9d0822781050522c413844b46b3f9e19ec" translate="yes" xml:space="preserve">
          <source>A plugin/crate was declared but cannot be found.</source>
          <target state="translated">プラグイン/クレートが宣言されていますが、見つかりません。</target>
        </trans-unit>
        <trans-unit id="de1781b485888ee330b207b934e4f4c6b09830cf" translate="yes" xml:space="preserve">
          <source>A plugin/crate was declared but cannot be found. Erroneous code example:</source>
          <target state="translated">プラグイン/クレートが宣言されていますが、見つかりません。誤ったコード例です。</target>
        </trans-unit>
        <trans-unit id="2db11183c5e69392e41fbe166caeebf1df741e85" translate="yes" xml:space="preserve">
          <source>A pointer to a trait type cannot be implicitly dereferenced by a pattern. Every trait defines a type, but because the size of trait implementers isn't fixed, this type has no compile-time size. Therefore, all accesses to trait types must be through pointers. If you encounter this error you should try to avoid dereferencing the pointer.</source>
          <target state="translated">形質型へのポインタは、パターンによって暗黙的に派生させることはできません。すべての形質は型を定義しますが、形質実装者のサイズは固定されていないため、この型はコンパイル時のサイズを持ちません。したがって、形質型へのアクセスはすべてポインタを介して行わなければなりません。このエラーに遭遇した場合は、ポインタの派生を避けるようにしなければなりません。</target>
        </trans-unit>
        <trans-unit id="34017de9c0f653b0f37f4a6965f6e339b6e3eb8f" translate="yes" xml:space="preserve">
          <source>A pointer type for heap allocation.</source>
          <target state="translated">ヒープ割り当てのためのポインタ型。</target>
        </trans-unit>
        <trans-unit id="068b4756f4660015d453841abd0c47d397debbf3" translate="yes" xml:space="preserve">
          <source>A poisoned &lt;a href=&quot;struct.once&quot;&gt;&lt;code&gt;Once&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">毒された&lt;a href=&quot;struct.once&quot;&gt; &lt;code&gt;Once&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="a8f3faefa5c5d4137483f566406d69333a9e2fb7" translate="yes" xml:space="preserve">
          <source>A poisoned &lt;code&gt;Once&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Once&lt;/code&gt; 毒された：</target>
        </trans-unit>
        <trans-unit id="929b0eef10b3144f1332f3b71eafbab8eba71fe6" translate="yes" xml:space="preserve">
          <source>A poisoned mutex, however, does not prevent all access to the underlying data. The &lt;a href=&quot;struct.poisonerror&quot;&gt;&lt;code&gt;PoisonError&lt;/code&gt;&lt;/a&gt; type has an &lt;a href=&quot;struct.poisonerror#method.into_inner&quot;&gt;&lt;code&gt;into_inner&lt;/code&gt;&lt;/a&gt; method which will return the guard that would have otherwise been returned on a successful lock. This allows access to the data, despite the lock being poisoned.</source>
          <target state="translated">ただし、汚染されたミューテックスは、基礎となるデータへのすべてのアクセスを妨げるものではありません。&lt;a href=&quot;struct.poisonerror&quot;&gt; &lt;code&gt;PoisonError&lt;/code&gt; の&lt;/a&gt;タイプがあり&lt;a href=&quot;struct.poisonerror#method.into_inner&quot;&gt; &lt;code&gt;into_inner&lt;/code&gt; の&lt;/a&gt;そうでなければ成功したロックに返却されていたガードを返します方法を。これにより、ロックが無効化されていても、データにアクセスできます。</target>
        </trans-unit>
        <trans-unit id="73fd6c45e77753ba09fc6ae1f1a84a2bc4c2f7fb" translate="yes" xml:space="preserve">
          <source>A possible error value when converting a &lt;code&gt;String&lt;/code&gt; from a UTF-16 byte slice.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; をUTF-16バイトスライスから変換するときに発生する可能性のあるエラー値。</target>
        </trans-unit>
        <trans-unit id="ffac94ea92c56dd95950816abb00c940a0255f3a" translate="yes" xml:space="preserve">
          <source>A possible error value when converting a &lt;code&gt;String&lt;/code&gt; from a UTF-8 byte vector.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; をUTF-8バイトベクトルから変換するときに発生する可能性のあるエラー値。</target>
        </trans-unit>
        <trans-unit id="de325cfd40d79951f0c1e349c34b7cd70df1fbf9" translate="yes" xml:space="preserve">
          <source>A prelude for conveniently writing platform-specific code.</source>
          <target state="translated">プラットフォーム固有のコードを便利に書くための前置き。</target>
        </trans-unit>
        <trans-unit id="c5e33e24aca6a074f404567a2953c71b3f5c603f" translate="yes" xml:space="preserve">
          <source>A priority queue implemented with a binary heap.</source>
          <target state="translated">バイナリヒープで実装された優先度キュー。</target>
        </trans-unit>
        <trans-unit id="839f5fda33c60277611f831c62b151f9e603547e" translate="yes" xml:space="preserve">
          <source>A private item was used outside its scope.</source>
          <target state="translated">私物が範囲外で使用されていました。</target>
        </trans-unit>
        <trans-unit id="519be8a210afc21029c91c0c6f7917299f8dedbe" translate="yes" xml:space="preserve">
          <source>A private item was used outside of its scope.</source>
          <target state="translated">私物を範囲外で使用していました。</target>
        </trans-unit>
        <trans-unit id="b050bad5b423d40a7cbc2510e0a714043fcaa01a" translate="yes" xml:space="preserve">
          <source>A private trait was used on a public type parameter bound.</source>
          <target state="translated">パブリック型のパラメータ・バウンドでプライベートな形質が使用されていました。</target>
        </trans-unit>
        <trans-unit id="94c921f0636467349880453e7613dadeb16d5d80" translate="yes" xml:space="preserve">
          <source>A private trait was used on a public type parameter bound. Erroneous code examples:</source>
          <target state="translated">パブリック型のパラメータ・バウンドでプライベートな形質が使用されていました。誤ったコード例。</target>
        </trans-unit>
        <trans-unit id="9a0df3af8cfe7414b96a23dc7a41a25700bb086e" translate="yes" xml:space="preserve">
          <source>A private type was used in a public type signature.</source>
          <target state="translated">公開型署名でプライベート型が使用されていました。</target>
        </trans-unit>
        <trans-unit id="5e925db174af759a11ddedae27575f0f853ed111" translate="yes" xml:space="preserve">
          <source>A private type was used in a public type signature. Erroneous code example:</source>
          <target state="translated">プライベート型がパブリック型シグネチャで使用されていました。誤ったコード例です。</target>
        </trans-unit>
        <trans-unit id="c311fafb046b4454c158177c3e7c9d9343861f7d" translate="yes" xml:space="preserve">
          <source>A process builder, providing fine-grained control over how a new process should be spawned.</source>
          <target state="translated">プロセスビルダは、新しいプロセスをどのように生成するかを細かく制御することができます。</target>
        </trans-unit>
        <trans-unit id="b012d3c393a9f2ccaba1d026e4a05fd4cbe591b1" translate="yes" xml:space="preserve">
          <source>A quick refresher on memory ordering:</source>
          <target state="translated">記憶の順序を簡単に復習します。</target>
        </trans-unit>
        <trans-unit id="63343f59c96578fe01a096392dc2051b122408d3" translate="yes" xml:space="preserve">
          <source>A random number that will generate some variety in the workout plans</source>
          <target state="translated">ワークアウトプランに多様性をもたらす乱数</target>
        </trans-unit>
        <trans-unit id="72b92a764b3becb3cc5dd577eea9f2e87d42d804" translate="yes" xml:space="preserve">
          <source>A range bounded inclusively below and above (&lt;code&gt;start..=end&lt;/code&gt;).</source>
          <target state="translated">上下の境界を含む範囲（ &lt;code&gt;start..=end&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="79fc3105ea5313c5378041705247103257830779" translate="yes" xml:space="preserve">
          <source>A range only bounded exclusively above (&lt;code&gt;..end&lt;/code&gt;).</source>
          <target state="translated">上のみを境界とする範囲（ &lt;code&gt;..end&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e19446803edcf89ddaf7319d7c6427759416990d" translate="yes" xml:space="preserve">
          <source>A range only bounded inclusively above (&lt;code&gt;..=end&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;..=end&lt;/code&gt; のみを含む範囲（.. = end）。</target>
        </trans-unit>
        <trans-unit id="74324727cee50500895944c74cdd394c1b31fc07" translate="yes" xml:space="preserve">
          <source>A range only bounded inclusively below (&lt;code&gt;start..&lt;/code&gt;).</source>
          <target state="translated">下側のみを含む範囲（ &lt;code&gt;start..&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="4f00d04637794ce3f904922bdb42fa3ce7f3d5fe" translate="yes" xml:space="preserve">
          <source>A raw identifier is like a normal identifier, but prefixed by &lt;code&gt;r#&lt;/code&gt;. (Note that the &lt;code&gt;r#&lt;/code&gt; prefix is not included as part of the actual identifier.) Unlike a normal identifier, a raw identifier may be any strict or reserved keyword except the ones listed above for &lt;code&gt;RAW_IDENTIFIER&lt;/code&gt;.</source>
          <target state="translated">生の識別子は通常の識別子に似ていますが、先頭に &lt;code&gt;r#&lt;/code&gt; が付いています。（ &lt;code&gt;r#&lt;/code&gt; 接頭辞は実際の識別子の一部として含まれていないことに注意してください。）通常の識別子とは異なり、未加工の識別子は、 &lt;code&gt;RAW_IDENTIFIER&lt;/code&gt; について上記にリストしたものを除いて、任意の厳密なキーワードまたは予約済みキーワードです。</target>
        </trans-unit>
        <trans-unit id="ffc636325c67605fadec2b68ebb55669b2cd9c34" translate="yes" xml:space="preserve">
          <source>A raw pointer type which can be safely shared between threads.</source>
          <target state="translated">スレッド間で安全に共有できる生ポインタ型。</target>
        </trans-unit>
        <trans-unit id="f1f955686d561bc8208f2ce3b12ca99c3765110a" translate="yes" xml:space="preserve">
          <source>A raw string isn't correctly terminated because the trailing &lt;code&gt;#&lt;/code&gt; count doesn't match its leading &lt;code&gt;#&lt;/code&gt; count.</source>
          <target state="translated">末尾の &lt;code&gt;#&lt;/code&gt; カウントが先頭の &lt;code&gt;#&lt;/code&gt; カウントと一致しないため、生の文字列は正しく終了しません。</target>
        </trans-unit>
        <trans-unit id="20341b33140e6b08a4b41c1574d7c2c86bdc7608" translate="yes" xml:space="preserve">
          <source>A reader which is always at EOF.</source>
          <target state="translated">常にEOFにいるリーダー。</target>
        </trans-unit>
        <trans-unit id="5c0eac8aa6da425e06c685e18fd91d499e3c16f1" translate="yes" xml:space="preserve">
          <source>A reader which yields one byte over and over and over and over and over and...</source>
          <target state="translated">1バイトを何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も何度も....</target>
        </trans-unit>
        <trans-unit id="0187c58d40ebb5aaa0b543a6b1bda48ead05f016" translate="yes" xml:space="preserve">
          <source>A reader-writer lock</source>
          <target state="translated">リーダーライターロック</target>
        </trans-unit>
        <trans-unit id="2d89d8dfb8b1c58f5d841e5165fcf975a6c55e6a" translate="yes" xml:space="preserve">
          <source>A recursive type has infinite size because it doesn't have an indirection.</source>
          <target state="translated">再帰型はインダイレクションを持たないため、サイズが無限大になります。</target>
        </trans-unit>
        <trans-unit id="414e2acfb8956698eab95c0efb754ad454841ffa" translate="yes" xml:space="preserve">
          <source>A reference has a longer lifetime than the data it references.</source>
          <target state="translated">参照は、参照するデータよりも長い寿命を持っています。</target>
        </trans-unit>
        <trans-unit id="8299c0d135b8f5441cc8858d8675b0fc5f91fcc2" translate="yes" xml:space="preserve">
          <source>A reference or &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; that is dangling, unaligned, or points to an invalid value.</source>
          <target state="translated">ぶら下がっている、位置合わせされていない、または無効な値を指している参照または &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9108b5b496b508ef46e829906b2e7b5524691e8f" translate="yes" xml:space="preserve">
          <source>A reference represents a borrow of some owned value. You can get one by using the &lt;code&gt;&amp;amp;&lt;/code&gt; or &lt;code&gt;&amp;amp;mut&lt;/code&gt; operators on a value, or by using a &lt;code&gt;ref&lt;/code&gt; or &lt;code&gt;ref mut&lt;/code&gt; pattern.</source>
          <target state="translated">参照は、ある所有価値の借用を表します。値に &lt;code&gt;&amp;amp;&lt;/code&gt; または &lt;code&gt;&amp;amp;mut&lt;/code&gt; 演算子を使用するか、 &lt;code&gt;ref&lt;/code&gt; または &lt;code&gt;ref mut&lt;/code&gt; パターンを使用して取得できます。</target>
        </trans-unit>
        <trans-unit id="def229fac786a814e540383a36be7448c81c2810" translate="yes" xml:space="preserve">
          <source>A reference to a local variable was returned.</source>
          <target state="translated">ローカル変数への参照が返されました。</target>
        </trans-unit>
        <trans-unit id="9b45e7cfae560003198e2ac81c9a7e5c60325d0a" translate="yes" xml:space="preserve">
          <source>A reference to an open file on the filesystem.</source>
          <target state="translated">ファイルシステム上で開いているファイルへの参照。</target>
        </trans-unit>
        <trans-unit id="cbf7d17da7f9b8415b894a96d3c62639060d8148" translate="yes" xml:space="preserve">
          <source>A reference to the current directory, i.e., &lt;code&gt;.&lt;/code&gt;.</source>
          <target state="translated">現在のディレクトリへの参照、つまり &lt;code&gt;.&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="54c4ba3b0f946cb73000b704747ed0cc043ef985" translate="yes" xml:space="preserve">
          <source>A reference to the parent directory, i.e., &lt;code&gt;..&lt;/code&gt;.</source>
          <target state="translated">親ディレクトリへの参照、すなわち、 &lt;code&gt;..&lt;/code&gt; .。</target>
        </trans-unit>
        <trans-unit id="b305ff2e1e8a128729de5a06db133ccf46d493cc" translate="yes" xml:space="preserve">
          <source>A reference/pointer is &quot;dangling&quot; if it is null or not all of the bytes it points to are part of the same allocation (so in particular they all have to be part of &lt;em&gt;some&lt;/em&gt; allocation). The span of bytes it points to is determined by the pointer value and the size of the pointee type (using &lt;code&gt;size_of_val&lt;/code&gt;). As a consequence, if the span is empty, &quot;dangling&quot; is the same as &quot;non-null&quot;. Note that slices and strings point to their entire range, so it is important that the length metadata is never too large. In particular, allocations and therefore slices and strings cannot be bigger than &lt;code&gt;isize::MAX&lt;/code&gt; bytes.</source>
          <target state="translated">参照/ポインタがnullであるか、それが指すすべてのバイトが同じ割り当ての一部ではない場合、参照/ポインタは「ダングリング」です（したがって、特にそれらはすべて&lt;em&gt;何らかの&lt;/em&gt;割り当ての一部で&lt;em&gt;ある&lt;/em&gt;必要があります）。それが指すバイトのスパンは、ポインター値とポインター型のサイズ（ &lt;code&gt;size_of_val&lt;/code&gt; を使用）によって決定されます。結果として、スパンが空の場合、「ぶら下がり」は「非ヌル」と同じです。スライスと文字列は範囲全体を指しているため、長さのメタデータが大きすぎないようにすることが重要です。特に、割り当て、したがってスライスと文字列は、 &lt;code&gt;isize::MAX&lt;/code&gt; バイトより大きくすることはできません。</target>
        </trans-unit>
        <trans-unit id="771deb0451fb407b0fb913d5488c53c42558785c" translate="yes" xml:space="preserve">
          <source>A regular floating point number.</source>
          <target state="translated">正規の浮動小数点数。</target>
        </trans-unit>
        <trans-unit id="cd85c1b05128e75e217b61f7154c9636692d1cea" translate="yes" xml:space="preserve">
          <source>A regular reference is a type of pointer, and one way to think of a pointer is as an arrow to a value stored somewhere else. In Listing 15-6, we create a reference to an &lt;code&gt;i32&lt;/code&gt; value and then use the dereference operator to follow the reference to the data:</source>
          <target state="translated">通常の参照はポインタの一種であり、ポインタを考える1つの方法は、別の場所に格納されている値への矢印と考えることです。リスト15-6では、 &lt;code&gt;i32&lt;/code&gt; への参照を作成します値、逆参照演算子を使用してデータへの参照を追跡しています。</target>
        </trans-unit>
        <trans-unit id="461658f899b03c712ef32df7b204d3908a10ea3a" translate="yes" xml:space="preserve">
          <source>A related concept is scope: the nested context in which code is written has a set of names that are defined as &amp;ldquo;in scope.&amp;rdquo; When reading, writing, and compiling code, programmers and compilers need to know whether a particular name at a particular spot refers to a variable, function, struct, enum, module, constant, or other item and what that item means. You can create scopes and change which names are in or out of scope. You can&amp;rsquo;t have two items with the same name in the same scope; tools are available to resolve name conflicts.</source>
          <target state="translated">関連する概念はスコープです。コードが記述されているネストされたコンテキストには、「スコープ内」として定義された一連の名前があります。コードの読み取り、書き込み、およびコンパイルを行う場合、プログラマーとコンパイラーは、特定の場所の特定の名前が変数、関数、構造体、列挙型、モジュール、定数、またはその他のアイテムを参照しているかどうか、およびそのアイテムの意味を知る必要があります。スコープを作成して、スコープ内またはスコープ外の名前を変更できます。同じスコープ内に同じ名前の2つのアイテムを含めることはできません。名前の競合を解決するためのツールが利用可能です。</target>
        </trans-unit>
        <trans-unit id="4629afc869292537f9c628724559e37eef9a2cb2" translate="yes" xml:space="preserve">
          <source>A repeat expression &lt;code&gt;[x; N]&lt;/code&gt;, which produces an array with &lt;code&gt;N&lt;/code&gt; copies of &lt;code&gt;x&lt;/code&gt;. The type of &lt;code&gt;x&lt;/code&gt; must be &lt;a href=&quot;marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">繰り返し表現 &lt;code&gt;[x; N]&lt;/code&gt; 、 &lt;code&gt;x&lt;/code&gt; の &lt;code&gt;N&lt;/code&gt; 個のコピーを持つ配列を生成します。 &lt;code&gt;x&lt;/code&gt; のタイプは&lt;a href=&quot;marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; で&lt;/a&gt;なければなりません。</target>
        </trans-unit>
        <trans-unit id="3238c87767b981c84fc407d2a6b89dd0a8979fcd" translate="yes" xml:space="preserve">
          <source>A restriction is imposed on the shebang syntax to avoid confusion with an &lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt;. The &lt;code&gt;#!&lt;/code&gt; characters must not be followed by a &lt;code&gt;[&lt;/code&gt; token, ignoring intervening &lt;a href=&quot;comments&quot;&gt;comments&lt;/a&gt; or &lt;a href=&quot;whitespace&quot;&gt;whitespace&lt;/a&gt;. If this restriction fails, then it is not treated as a shebang, but instead as the start of an attribute.</source>
          <target state="translated">&lt;a href=&quot;attributes&quot;&gt;属性&lt;/a&gt;との混同を避けるために、シバン構文に制限が課せられます。 &lt;code&gt;#!&lt;/code&gt; 間にある&lt;a href=&quot;comments&quot;&gt;コメント&lt;/a&gt;や&lt;a href=&quot;whitespace&quot;&gt;空白を&lt;/a&gt;無視して、文字の後に &lt;code&gt;[&lt;/code&gt; トークンを続けることはできません。この制限が失敗した場合、それはシバンとしてではなく、属性の開始として扱われます。</target>
        </trans-unit>
        <trans-unit id="6bdd3de922c246975bfd1cbfd244a2a660fcbad2" translate="yes" xml:space="preserve">
          <source>A return statement was found outside of a function body.</source>
          <target state="translated">return 文が関数本体の外にありました。</target>
        </trans-unit>
        <trans-unit id="80cb47a4163ef3f70e5ddff5f65587e6f1ef80e1" translate="yes" xml:space="preserve">
          <source>A reverse searcher for a string pattern.</source>
          <target state="translated">文字列パターンの逆引き検索。</target>
        </trans-unit>
        <trans-unit id="4d45eae920f51ae4fa809b8359142e43a5dccbee" translate="yes" xml:space="preserve">
          <source>A scrutinee is the expression that is matched on in &lt;code&gt;match&lt;/code&gt; expressions and similar pattern matching constructs. For example, in &lt;code&gt;match x { A =&amp;gt; 1, B =&amp;gt; 2 }&lt;/code&gt;, the expression &lt;code&gt;x&lt;/code&gt; is the scrutinee.</source>
          <target state="translated">scrutineeは、 &lt;code&gt;match&lt;/code&gt; 式および類似のパターンマッチング構成で一致する式です。たとえば、 &lt;code&gt;match x { A =&amp;gt; 1, B =&amp;gt; 2 }&lt;/code&gt; 場合、式 &lt;code&gt;x&lt;/code&gt; がスクランチです。</target>
        </trans-unit>
        <trans-unit id="090be4c47ade9f54015d614891f57e36867218e4" translate="yes" xml:space="preserve">
          <source>A searcher for a string pattern.</source>
          <target state="translated">文字列パターンの探索者。</target>
        </trans-unit>
        <trans-unit id="805b0de6f894d8345c096cc31db6d9d15c14c18a" translate="yes" xml:space="preserve">
          <source>A seek beyond the end of a stream is allowed, but behavior is defined by the implementation.</source>
          <target state="translated">ストリームの終端を越えたシークは許可されていますが、動作は実装によって定義されています。</target>
        </trans-unit>
        <trans-unit id="187cb85d876dbb3e8278047d50cee3e8447cafbc" translate="yes" xml:space="preserve">
          <source>A set based on a B-Tree.</source>
          <target state="translated">B-Treeをベースにした集合。</target>
        </trans-unit>
        <trans-unit id="89f39617bf1d1e8280f2895b2baeee66b493c8f3" translate="yes" xml:space="preserve">
          <source>A similar error is E0201. The difference is whether there is one declaration block or not. To avoid this error, you must give each &lt;code&gt;fn&lt;/code&gt; a unique name.</source>
          <target state="translated">同様のエラーはE0201です。違いは、宣言ブロックが1つあるかどうかです。このエラーを回避するには、各 &lt;code&gt;fn&lt;/code&gt; を指定する必要がありますに一意の名前を。</target>
        </trans-unit>
        <trans-unit id="6f6761295ae70019a0d2d6374dca4eaf6df07696" translate="yes" xml:space="preserve">
          <source>A similar rule exists for combining mutable and immutable references. This code results in an error:</source>
          <target state="translated">同様のルールは、ミュータブル参照とイミュータブル参照の組み合わせにも存在します。このコードはエラーになります。</target>
        </trans-unit>
        <trans-unit id="8e839688e01ba01e9dfe145feb09335f1aa963d0" translate="yes" xml:space="preserve">
          <source>A simple example:</source>
          <target state="translated">簡単な例です。</target>
        </trans-unit>
        <trans-unit id="823d579a067f8a96f5626154ea604d86f19d68ef" translate="yes" xml:space="preserve">
          <source>A simple function returning &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; might be defined and used like so:</source>
          <target state="translated">&lt;a href=&quot;enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt;返す単純な関数は、次のように定義して使用できます。</target>
        </trans-unit>
        <trans-unit id="d53eef6dd046b01cc7902a1c3902a172dad006e2" translate="yes" xml:space="preserve">
          <source>A simple spinlock:</source>
          <target state="translated">シンプルなスピンロック。</target>
        </trans-unit>
        <trans-unit id="a2f952715a286d980e4f33b8e4525dcb3eac03bb" translate="yes" xml:space="preserve">
          <source>A simple workaround is to use a helper method instead:</source>
          <target state="translated">簡単な回避策は、代わりにヘルパーメソッドを使用することです。</target>
        </trans-unit>
        <trans-unit id="054dbf6f392fa38162c0d62e6ead09a79999e53b" translate="yes" xml:space="preserve">
          <source>A simple wrapper around a type to assert that it is unwind safe.</source>
          <target state="translated">巻き戻しが安全であることを保証するための型のシンプルなラッパーです。</target>
        </trans-unit>
        <trans-unit id="b53617da96fc2eac5eec0b6bb0e92f32c47fc76e" translate="yes" xml:space="preserve">
          <source>A single (arbitrary) thread will receive a &lt;a href=&quot;struct.barrierwaitresult&quot;&gt;&lt;code&gt;BarrierWaitResult&lt;/code&gt;&lt;/a&gt; that returns &lt;code&gt;true&lt;/code&gt; from &lt;a href=&quot;struct.barrierwaitresult#method.is_leader&quot;&gt;&lt;code&gt;BarrierWaitResult::is_leader()&lt;/code&gt;&lt;/a&gt; when returning from this function, and all other threads will receive a result that will return &lt;code&gt;false&lt;/code&gt; from &lt;a href=&quot;struct.barrierwaitresult#method.is_leader&quot;&gt;&lt;code&gt;BarrierWaitResult::is_leader()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">単一の（任意の）スレッドは、この関数から戻るときに&lt;a href=&quot;struct.barrierwaitresult#method.is_leader&quot;&gt; &lt;code&gt;BarrierWaitResult::is_leader()&lt;/code&gt; &lt;/a&gt;から &lt;code&gt;true&lt;/code&gt; を返す&lt;a href=&quot;struct.barrierwaitresult&quot;&gt; &lt;code&gt;BarrierWaitResult&lt;/code&gt; &lt;/a&gt;を受け取り、他のすべてのスレッドは、&lt;a href=&quot;struct.barrierwaitresult#method.is_leader&quot;&gt; &lt;code&gt;BarrierWaitResult::is_leader()&lt;/code&gt; &lt;/a&gt;から &lt;code&gt;false&lt;/code&gt; を返す結果を受け取ります。</target>
        </trans-unit>
        <trans-unit id="cd3fd0649d54745c9dde4e2f256bda95babba9f6" translate="yes" xml:space="preserve">
          <source>A single (arbitrary) thread will receive a &lt;a href=&quot;struct.barrierwaitresult&quot;&gt;&lt;code&gt;BarrierWaitResult&lt;/code&gt;&lt;/a&gt; that returns &lt;code&gt;true&lt;/code&gt; from &lt;a href=&quot;struct.barrierwaitresult#method.is_leader&quot;&gt;&lt;code&gt;is_leader&lt;/code&gt;&lt;/a&gt; when returning from this function, and all other threads will receive a result that will return &lt;code&gt;false&lt;/code&gt; from &lt;a href=&quot;struct.barrierwaitresult#method.is_leader&quot;&gt;&lt;code&gt;is_leader&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">単一の（任意の）スレッドは、この関数から&lt;a href=&quot;struct.barrierwaitresult#method.is_leader&quot;&gt; &lt;code&gt;is_leader&lt;/code&gt; &lt;/a&gt;ときにis_leaderから &lt;code&gt;true&lt;/code&gt; を返す&lt;a href=&quot;struct.barrierwaitresult&quot;&gt; &lt;code&gt;BarrierWaitResult&lt;/code&gt; &lt;/a&gt;を受け取り、他のすべてのスレッドは&lt;a href=&quot;struct.barrierwaitresult#method.is_leader&quot;&gt; &lt;code&gt;is_leader&lt;/code&gt; &lt;/a&gt;から &lt;code&gt;false&lt;/code&gt; を返す結果を受け取ります。</target>
        </trans-unit>
        <trans-unit id="0e774847b8b17cfc775f96b4b6ba3419133c2ae2" translate="yes" xml:space="preserve">
          <source>A single &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; may be encoded as more than one byte. This method can only succeed if the entire byte sequence was successfully written, and this method will not return until all data has been written or an error occurs.</source>
          <target state="translated">1つの&lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;が複数のバイトとしてエンコードされる場合があります。このメソッドは、バイトシーケンス全体が正常に書き込まれた場合にのみ成功します。このメソッドは、すべてのデータが書き込まれるか、エラーが発生するまで戻りません。</target>
        </trans-unit>
        <trans-unit id="a7ad66dadfa2951ac2cd349b4d260c6f6b28c527" translate="yes" xml:space="preserve">
          <source>A single &lt;em&gt;decimal literal&lt;/em&gt; followed by an &lt;em&gt;exponent&lt;/em&gt;.</source>
          <target state="translated">単一の&lt;em&gt;10進リテラルと&lt;/em&gt;それに続く&lt;em&gt;指数&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="538d82224c466a3fa46957bd1dad7926fc97c926" translate="yes" xml:space="preserve">
          <source>A single component of a path.</source>
          <target state="translated">パスの単一コンポーネント。</target>
        </trans-unit>
        <trans-unit id="2286204503218f0f2c8d94ba2bb110e020e0bc00" translate="yes" xml:space="preserve">
          <source>A single-threaded reference-counting pointer. 'Rc' stands for 'Reference Counted'.</source>
          <target state="translated">シングルスレッドの参照カウントポインタ。'Rc' は 'Reference Counted' の略です。</target>
        </trans-unit>
        <trans-unit id="5b101d21362e496b89adfac2fbb37a58e0757a7e" translate="yes" xml:space="preserve">
          <source>A slice is a &lt;a href=&quot;../dynamically-sized-types&quot;&gt;dynamically sized type&lt;/a&gt; representing a 'view' into a sequence of elements of type &lt;code&gt;T&lt;/code&gt;. The slice type is written as &lt;code&gt;[T]&lt;/code&gt;.</source>
          <target state="translated">スライスは、タイプ &lt;code&gt;T&lt;/code&gt; の要素のシーケンスへの「ビュー」を表す&lt;a href=&quot;../dynamically-sized-types&quot;&gt;動的サイズのタイプ&lt;/a&gt;です。スライスタイプは &lt;code&gt;[T]&lt;/code&gt; と表記されます。ます。</target>
        </trans-unit>
        <trans-unit id="aba616073ac3de8beab95ccfac7bd633d599946d" translate="yes" xml:space="preserve">
          <source>A slice is dynamically-sized view into a contiguous sequence, written as &lt;code&gt;[T]&lt;/code&gt;.</source>
          <target state="translated">スライスは、 &lt;code&gt;[T]&lt;/code&gt; と書かれた、連続したシーケンスへの動的なサイズのビューです。</target>
        </trans-unit>
        <trans-unit id="fe635e064516decbfbc3e3d9ce043f9d25e8ca9f" translate="yes" xml:space="preserve">
          <source>A slice of a path (akin to &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">パスのスライス（&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; と&lt;/a&gt;同様）。</target>
        </trans-unit>
        <trans-unit id="2759e6b662ba691ba47b65069c920c9b980fcd79" translate="yes" xml:space="preserve">
          <source>A slice of a path (akin to &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">パスのスライス（&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt; &lt;code&gt;str&lt;/code&gt; に&lt;/a&gt;似ています）。</target>
        </trans-unit>
        <trans-unit id="11824dd936b3023e24b3affd0ef64f49ba6ed2c9" translate="yes" xml:space="preserve">
          <source>A slightly sad example of not reading anything into a buffer:</source>
          <target state="translated">バッファに何も読み込まないというちょっと悲しい例。</target>
        </trans-unit>
        <trans-unit id="45dafb0f63eaca5bfb7f56b27e11fa2b7d396e89" translate="yes" xml:space="preserve">
          <source>A socket address could not be bound because the address is already in use elsewhere.</source>
          <target state="translated">ソケットアドレスが既に他の場所で使用されているため、ソケットアドレスをバインドできなかった。</target>
        </trans-unit>
        <trans-unit id="ac2b051bc6a92539c672158c6142e1d18c98d73f" translate="yes" xml:space="preserve">
          <source>A somewhat surprising consequence of the definition is that &lt;code&gt;&amp;amp;mut T&lt;/code&gt; is &lt;code&gt;Sync&lt;/code&gt; (if &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Sync&lt;/code&gt;) even though it seems like that might provide unsynchronized mutation. The trick is that a mutable reference behind a shared reference (that is, &lt;code&gt;&amp;amp; &amp;amp;mut T&lt;/code&gt;) becomes read-only, as if it were a &lt;code&gt;&amp;amp; &amp;amp;T&lt;/code&gt;. Hence there is no risk of a data race.</source>
          <target state="translated">定義のいくぶん意外な結果は、 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; が &lt;code&gt;Sync&lt;/code&gt; である場合（ &lt;code&gt;T&lt;/code&gt; が &lt;code&gt;Sync&lt;/code&gt; の場合）、非同期のミューテーションを提供する可能性があるように見えます。トリック（つまり共有参照の後ろに可変基準点である &lt;code&gt;&amp;amp; &amp;amp;mut T&lt;/code&gt; ）読み取り専用になり、それがあたかも &lt;code&gt;&amp;amp; &amp;amp;T&lt;/code&gt; 。したがって、データ競合のリスクはありません。</target>
        </trans-unit>
        <trans-unit id="2194c015edca7318deaf09554d0cad9263a5128b" translate="yes" xml:space="preserve">
          <source>A source file can have a &lt;a href=&quot;https://en.wikipedia.org/wiki/Shebang_(Unix)&quot;&gt;&lt;em&gt;shebang&lt;/em&gt;&lt;/a&gt; (SHEBANG production), which indicates to the operating system what program to use to execute this file. It serves essentially to treat the source file as an executable script. The shebang can only occur at the beginning of the file (but after the optional &lt;em&gt;UTF8BOM&lt;/em&gt;). It is ignored by the compiler. For example:</source>
          <target state="translated">ソースファイルには&lt;a href=&quot;https://en.wikipedia.org/wiki/Shebang_(Unix)&quot;&gt;&lt;em&gt;シバン&lt;/em&gt;&lt;/a&gt;（SHEBANGプロダクション）を含めることができます。これは、このファイルの実行に使用するプログラムをオペレーティングシステムに示します。それは本質的にソースファイルを実行可能なスクリプトとして扱うのに役立ちます。シバンはファイルの先頭でのみ発生します（ただし、オプションの&lt;em&gt;UTF8BOMの&lt;/em&gt;後に発生します）。コンパイラーによって無視されます。例えば：</target>
        </trans-unit>
        <trans-unit id="5ec62fb18603ebc6519f469782df4169fc5a681f" translate="yes" xml:space="preserve">
          <source>A source stage in an iterator pipeline.</source>
          <target state="translated">イテレータ パイプラインのソース ステージ。</target>
        </trans-unit>
        <trans-unit id="3a13e4ab897112a5bbfa779986c13ffc8249c723" translate="yes" xml:space="preserve">
          <source>A specialized &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; type for I/O operations.</source>
          <target state="translated">I / O操作に特化した&lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt;タイプ。</target>
        </trans-unit>
        <trans-unit id="29c08563a92ed84161c48f32442e9c55ea57c60e" translate="yes" xml:space="preserve">
          <source>A specialized &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; type for threads.</source>
          <target state="translated">スレッド専用の&lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt;タイプ。</target>
        </trans-unit>
        <trans-unit id="c3d479aee422ab65a96675342bd98a8476bf0c50" translate="yes" xml:space="preserve">
          <source>A splicing iterator for &lt;code&gt;Vec&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Vec&lt;/code&gt; のスプライシングイテレータ。</target>
        </trans-unit>
        <trans-unit id="382d455769d00569a95a026174c2cb511f9bbb7a" translate="yes" xml:space="preserve">
          <source>A stability attribute has been used outside of the standard library.</source>
          <target state="translated">安定性属性が標準ライブラリ以外で使用されています。</target>
        </trans-unit>
        <trans-unit id="9c6a5b448820983a6050fcd10b6c3d4dd333f376" translate="yes" xml:space="preserve">
          <source>A stability attribute was used outside of the standard library.</source>
          <target state="translated">安定性属性は標準ライブラリ以外で使用されていました。</target>
        </trans-unit>
        <trans-unit id="7208bc1e59d67cb800b9b249868cce02c7e08ab0" translate="yes" xml:space="preserve">
          <source>A stability attribute was used outside of the standard library. Erroneous code example:</source>
          <target state="translated">安定性属性が標準ライブラリ以外で使用されていました。誤ったコード例。</target>
        </trans-unit>
        <trans-unit id="c28a8a30c83d119da8eeb5ad945a45667f90aa8f" translate="yes" xml:space="preserve">
          <source>A statement is the smallest standalone element of a programming language that commands a computer to perform an action.</source>
          <target state="translated">ステートメントは、コンピュータにアクションを実行するように命令するプログラミング言語の最小のスタンドアロン要素です。</target>
        </trans-unit>
        <trans-unit id="7993655a3c3f53e3aa0f9baecc01e8b1f97ae73b" translate="yes" xml:space="preserve">
          <source>A statement.</source>
          <target state="translated">声明。</target>
        </trans-unit>
        <trans-unit id="d137e324ac57303f829812294caa15b53500d48e" translate="yes" xml:space="preserve">
          <source>A static item is a value which is valid for the entire duration of your program (a &lt;code&gt;'static&lt;/code&gt; lifetime).</source>
          <target state="translated">静的アイテムは、プログラムの全期間（ &lt;code&gt;'static&lt;/code&gt; 存続期間）にわたって有効な値です。</target>
        </trans-unit>
        <trans-unit id="1525834046325d03a0ffcca63064524577af3217" translate="yes" xml:space="preserve">
          <source>A string (&lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;) is made of bytes (&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;), and a vector of bytes (&lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt;&lt;/a&gt;) is made of bytes, so this function converts between the two. Not all byte slices are valid &lt;code&gt;String&lt;/code&gt;s, however: &lt;code&gt;String&lt;/code&gt; requires that it is valid UTF-8. &lt;code&gt;from_utf8()&lt;/code&gt; checks to ensure that the bytes are valid UTF-8, and then does the conversion.</source>
          <target state="translated">文字列（&lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;）はバイト（&lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt;）で構成され、バイトのベクトル（&lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; &lt;/a&gt;）はバイトで構成されているため、この関数は2つの間で変換します。ただし、すべてのバイトスライスが有効な &lt;code&gt;String&lt;/code&gt; は限りません。 &lt;code&gt;String&lt;/code&gt; では、有効なUTF-8である必要があります。 &lt;code&gt;from_utf8()&lt;/code&gt; は、バイトが有効なUTF-8であることを確認してから、変換を実行します。</target>
        </trans-unit>
        <trans-unit id="d8b0000fb42f01e7695f858d20347ce505d823eb" translate="yes" xml:space="preserve">
          <source>A string describing the architecture of the CPU that is currently in use.</source>
          <target state="translated">現在使用しているCPUのアーキテクチャを記述した文字列。</target>
        </trans-unit>
        <trans-unit id="5df1b3a45cf6eb695745e50e624d24676a48e8a7" translate="yes" xml:space="preserve">
          <source>A string describing the specific operating system in use. Example value is &lt;code&gt;linux&lt;/code&gt;.</source>
          <target state="translated">使用中の特定のオペレーティングシステムを説明する文字列。値の例は &lt;code&gt;linux&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="8947468201a55a4ba9cd06d3d0a2f1ff1271df73" translate="yes" xml:space="preserve">
          <source>A string is a sequence of bytes. 'Left' in this context means the first position of that byte string; for a language like Arabic or Hebrew which are 'right to left' rather than 'left to right', this will be the &lt;em&gt;right&lt;/em&gt; side, not the left.</source>
          <target state="translated">文字列は一連のバイトです。このコンテキストでの「左」は、そのバイト文字列の最初の位置を意味します。「左から右」ではなく「右から左」であるアラビア語やヘブライ語のような言語の場合、これは左側ではなく&lt;em&gt;右側に&lt;/em&gt;なります。</target>
        </trans-unit>
        <trans-unit id="0bc83c493a049c765d2dfbebad0f09d82d1b6fde" translate="yes" xml:space="preserve">
          <source>A string is a sequence of bytes. 'Right' in this context means the last position of that byte string; for a language like Arabic or Hebrew which are 'right to left' rather than 'left to right', this will be the &lt;em&gt;left&lt;/em&gt; side, not the right.</source>
          <target state="translated">文字列は一連のバイトです。このコンテキストでの「右」は、そのバイト文字列の最後の位置を意味します。「右から左へ」というよりも、アラビア語やヘブライ語のような言語は「右に左」、これは次のようになります&lt;em&gt;、左&lt;/em&gt;サイド、右ではありません。</target>
        </trans-unit>
        <trans-unit id="a7d73837e1ae6f385cc7b12b321574d70650bd43" translate="yes" xml:space="preserve">
          <source>A string is a sequence of bytes. &lt;code&gt;end&lt;/code&gt; in this context means the last position of that byte string; for a left-to-right language like English or Russian, this will be right side, and for right-to-left languages like Arabic or Hebrew, this will be the left side.</source>
          <target state="translated">文字列はバイトのシーケンスです。このコンテキストでの &lt;code&gt;end&lt;/code&gt; は、そのバイト文字列の最後の位置を意味します。英語やロシア語などの左から右への言語の場合、これは右側になり、アラビア語やヘブライ語などの右から左への言語の場合、これは左側になります。</target>
        </trans-unit>
        <trans-unit id="fd472172ba3e393c6a98b65077b0a65554fdb8e3" translate="yes" xml:space="preserve">
          <source>A string is a sequence of bytes. &lt;code&gt;end&lt;/code&gt; in this context means the last position of that byte string; for a left-to-right language like English or Russian, this will be right side, and for right-to-left languages like like Arabic or Hebrew, this will be the left side.</source>
          <target state="translated">文字列は一連のバイトです。このコンテキストでの &lt;code&gt;end&lt;/code&gt; は、そのバイト文字列の最後の位置を意味します。英語やロシア語のような左から右への言語の場合はこれが右側になり、アラビア語やヘブライ語のような右から左への言語の場合はこれが左側になります。</target>
        </trans-unit>
        <trans-unit id="8add450b8d835c6c86dcce6d9f4412fe207173ed" translate="yes" xml:space="preserve">
          <source>A string is a sequence of bytes. &lt;code&gt;start&lt;/code&gt; in this context means the first position of that byte string; for a left-to-right language like English or Russian, this will be left side, and for right-to-left languages like Arabic or Hebrew, this will be the right side.</source>
          <target state="translated">文字列はバイトのシーケンスです。このコンテキストでの &lt;code&gt;start&lt;/code&gt; は、そのバイト文字列の最初の位置を意味します。英語やロシア語などの左から右への言語の場合、これは左側になり、アラビア語やヘブライ語などの右から左への言語の場合、これは右側になります。</target>
        </trans-unit>
        <trans-unit id="b8e69c41862936bd74ab07a7db3ea33fabc1421d" translate="yes" xml:space="preserve">
          <source>A string is a sequence of bytes. &lt;code&gt;start&lt;/code&gt; in this context means the first position of that byte string; for a left-to-right language like English or Russian, this will be left side, and for right-to-left languages like like Arabic or Hebrew, this will be the right side.</source>
          <target state="translated">文字列は一連のバイトです。このコンテキストでの &lt;code&gt;start&lt;/code&gt; は、そのバイト文字列の最初の位置を意味します。英語やロシア語のような左から右への言語の場合、これは左側になり、アラビア語やヘブライ語のような右から左への言語の場合、これは右側になります。</target>
        </trans-unit>
        <trans-unit id="3af90a5c6860195d31687a2b123d3690f30cc3df" translate="yes" xml:space="preserve">
          <source>A string literal is a string stored directly in the final binary, and so will be valid for the &lt;code&gt;'static&lt;/code&gt; duration.</source>
          <target state="translated">文字列リテラルは、最終的なバイナリに直接格納される文字列であるため、 &lt;code&gt;'static&lt;/code&gt; 期間」有効です。</target>
        </trans-unit>
        <trans-unit id="72d1187b478d157904cca7877538ced2b416e35f" translate="yes" xml:space="preserve">
          <source>A string pattern.</source>
          <target state="translated">文字列のパターン。</target>
        </trans-unit>
        <trans-unit id="067ff927875044f01fc32c9a4450dd787608c362" translate="yes" xml:space="preserve">
          <source>A string slice (&lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;) is made of bytes (&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;), and a byte slice (&lt;a href=&quot;../primitive.slice&quot;&gt;&lt;code&gt;&amp;amp;[u8]&lt;/code&gt;&lt;/a&gt;) is made of bytes, so this function converts between the two. Not all byte slices are valid string slices, however: &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; requires that it is valid UTF-8. &lt;code&gt;from_utf8()&lt;/code&gt; checks to ensure that the bytes are valid UTF-8, and then does the conversion.</source>
          <target state="translated">文字列スライス（&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt;）はバイト（&lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt;）で構成され、バイトスライス（&lt;a href=&quot;../primitive.slice&quot;&gt; &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; &lt;/a&gt;）はバイトで構成されているため、この関数は2つの間で変換を行います。ただし、すべてのバイトスライスが有効な文字列スライスであるとは限りません。&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt;では、有効なUTF-8である必要があります。 &lt;code&gt;from_utf8()&lt;/code&gt; は、バイトが有効なUTF-8であることを確認してから、変換を行います。</target>
        </trans-unit>
        <trans-unit id="e7464828dc4f92a12dd0ad9693849275688a2fde" translate="yes" xml:space="preserve">
          <source>A string slice (&lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;) is made of bytes (&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;), and a vector of bytes (&lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt;&lt;/a&gt;) is made of bytes, so this function converts between the two. Not all byte slices are valid &lt;code&gt;String&lt;/code&gt;s, however: &lt;code&gt;String&lt;/code&gt; requires that it is valid UTF-8. &lt;code&gt;from_utf8()&lt;/code&gt; checks to ensure that the bytes are valid UTF-8, and then does the conversion.</source>
          <target state="translated">文字列スライス（&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt;）はバイト（&lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt;）で構成され、バイトのベクトル（&lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; &lt;/a&gt;）はバイトで構成されているため、この関数はこの2つの間で変換を行います。ただし、すべてのバイトスライスが有効な &lt;code&gt;String&lt;/code&gt; であるとは限りません &lt;code&gt;String&lt;/code&gt; では、有効なUTF-8である必要があります。 &lt;code&gt;from_utf8()&lt;/code&gt; は、バイトが有効なUTF-8であることを確認してから、変換を行います。</target>
        </trans-unit>
        <trans-unit id="185b4c50dbb326aeb04eb1f2bab9a2d41dd7280a" translate="yes" xml:space="preserve">
          <source>A string slice is the most primitive string type in Rust, written as &lt;code&gt;str&lt;/code&gt;. It is often seen in its borrowed forms, either mutable or shared. The shared string slice type is &lt;code&gt;&amp;amp;str&lt;/code&gt;, while the mutable string slice type is &lt;code&gt;&amp;amp;mut str&lt;/code&gt;.</source>
          <target state="translated">文字列スライスは、Rustで最もプリミティブな文字列型であり、 &lt;code&gt;str&lt;/code&gt; として記述されます。それは、可変または共有の借用形式でよく見られます。共有文字列のスライスタイプは &lt;code&gt;&amp;amp;str&lt;/code&gt; で、可変文字列のスライスタイプは &lt;code&gt;&amp;amp;mut str&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="696c15b61497eb0b1cb08d222cb16dce5b4582da" translate="yes" xml:space="preserve">
          <source>A struct can be &lt;code&gt;Copy&lt;/code&gt;, and &lt;a href=&quot;../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;Copy&lt;/code&gt;, therefore &lt;code&gt;Point&lt;/code&gt; is eligible to be &lt;code&gt;Copy&lt;/code&gt;. By contrast, consider</source>
          <target state="translated">構造体は &lt;code&gt;Copy&lt;/code&gt; にすることができ、&lt;a href=&quot;../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt;は &lt;code&gt;Copy&lt;/code&gt; であるため、 &lt;code&gt;Point&lt;/code&gt; は &lt;code&gt;Copy&lt;/code&gt; の対象になります。対照的に、考慮</target>
        </trans-unit>
        <trans-unit id="eb9b96b59ca1189f15dc2a933aeadc425813dff3" translate="yes" xml:space="preserve">
          <source>A struct constructor with private fields was invoked.</source>
          <target state="translated">プライベート・フィールドを持つ構造体コンストラクタが呼び出されました。</target>
        </trans-unit>
        <trans-unit id="f5d13af10075668c4266bfa2af5c2d787c33d9d3" translate="yes" xml:space="preserve">
          <source>A struct constructor with private fields was invoked. Erroneous code example:</source>
          <target state="translated">プライベート フィールドを持つ構造体コンストラクタが呼び出されました。誤ったコード例です。</target>
        </trans-unit>
        <trans-unit id="d5d8cb072da62f16419c7934c8ea02767949e9d6" translate="yes" xml:space="preserve">
          <source>A struct containing information about the location of a panic.</source>
          <target state="translated">パニックの場所に関する情報を含む構造体。</target>
        </trans-unit>
        <trans-unit id="4cbc7f2982657f6ecdc97f40e8df1ad547c2b1e9" translate="yes" xml:space="preserve">
          <source>A struct expression can terminate with the syntax &lt;code&gt;..&lt;/code&gt; followed by an expression to denote a functional update. The expression following &lt;code&gt;..&lt;/code&gt; (the base) must have the same struct type as the new struct type being formed.</source>
          <target state="translated">構造体式は、構文 &lt;code&gt;..&lt;/code&gt; の後に関数の更新を示す式が続くことができます。 &lt;code&gt;..&lt;/code&gt; （ベース）に続く式は、形成される新しい構造体型と同じ構造体型でなければなりません。</target>
        </trans-unit>
        <trans-unit id="86c4b8e1d72da61f04333be84148a5de11fccd79" translate="yes" xml:space="preserve">
          <source>A struct expression with fields enclosed in curly braces allows you to specify the value for each individual field in any order. The field name is separated from its value with a colon.</source>
          <target state="translated">中括弧で囲まれたフィールドを持つ構造式では、個々のフィールドの値を任意の順序で指定することができます。フィールド名はコロンで値から分離されます。</target>
        </trans-unit>
        <trans-unit id="89ddcc2481a3b96d64219755d7c1825c0ff65c03" translate="yes" xml:space="preserve">
          <source>A struct expression with fields enclosed in parentheses constructs a tuple struct. Though it is listed here as a specific expression for completeness, it is equivalent to a &lt;a href=&quot;call-expr&quot;&gt;call expression&lt;/a&gt; to the tuple struct's constructor. For example:</source>
          <target state="translated">括弧で囲まれたフィールドを持つ構造体式は、タプル構造体を構築します。完全を期すために特定の式としてここにリストされていますが、タプル構造体のコンストラクターへの&lt;a href=&quot;call-expr&quot;&gt;呼び出し式&lt;/a&gt;と同等です。例えば：</target>
        </trans-unit>
        <trans-unit id="4a5683978535ef36d2f4a36fc97769f59882d764" translate="yes" xml:space="preserve">
          <source>A struct pattern attempted to extract a non-existent field from a struct.</source>
          <target state="translated">構造体パターンが構造体から存在しないフィールドを抽出しようとしました。</target>
        </trans-unit>
        <trans-unit id="fed041bebb665ccd5885e8c57eed09e9404a7bab" translate="yes" xml:space="preserve">
          <source>A struct pattern is refutable when one of its subpatterns is refutable.</source>
          <target state="translated">構造体パターンは、そのサブパターンの1つが再可換可能な場合に再可換可能となります。</target>
        </trans-unit>
        <trans-unit id="7845438dcb42a82b5f335b8afeff28c09f01fb02" translate="yes" xml:space="preserve">
          <source>A struct providing information about a panic.</source>
          <target state="translated">パニックに関する情報を提供する構造体。</target>
        </trans-unit>
        <trans-unit id="2e74ee410a88a7bd4dc9ec3e4439e1be7c03f52f" translate="yes" xml:space="preserve">
          <source>A struct to help with &lt;a href=&quot;trait.debug&quot;&gt;&lt;code&gt;fmt::Debug&lt;/code&gt;&lt;/a&gt; implementations.</source>
          <target state="translated">&lt;a href=&quot;trait.debug&quot;&gt; &lt;code&gt;fmt::Debug&lt;/code&gt; &lt;/a&gt;実装に役立つ構造体。</target>
        </trans-unit>
        <trans-unit id="878d9a84ea5b4c1dd0e00cf0901eb339704e2d00" translate="yes" xml:space="preserve">
          <source>A struct was declared with two fields having the same name.</source>
          <target state="translated">同じ名前を持つ 2 つのフィールドを持つ構造体が宣言されました。</target>
        </trans-unit>
        <trans-unit id="5cc6e14f7d3ffa0d43917de969f7811f2b833f5b" translate="yes" xml:space="preserve">
          <source>A struct with a single field which is accessible by dereferencing the struct.</source>
          <target state="translated">構造体を参照することでアクセス可能な単一フィールドを持つ構造体。</target>
        </trans-unit>
        <trans-unit id="804d90713791042aa7ae7163ec47b488d14fba5e" translate="yes" xml:space="preserve">
          <source>A struct with a single field which is modifiable by dereferencing the struct.</source>
          <target state="translated">構造体を参照することで変更可能な単一フィールドを持つ構造体。</target>
        </trans-unit>
        <trans-unit id="0888572f00b05df1f9ff3f22503c0dc7eb90c709" translate="yes" xml:space="preserve">
          <source>A struct with more than one field containing an unsized type cannot implement &lt;code&gt;CoerceUnsized&lt;/code&gt;. This only occurs when you are trying to coerce one of the types in your struct to another type in the struct. In this case we try to impl &lt;code&gt;CoerceUnsized&lt;/code&gt; from &lt;code&gt;T&lt;/code&gt; to &lt;code&gt;U&lt;/code&gt; which are both types that the struct takes. An &lt;a href=&quot;book/ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;unsized type&lt;/a&gt; is any type that the compiler doesn't know the length or alignment of at compile time. Any struct containing an unsized type is also unsized.</source>
          <target state="translated">無サイズタイプを含む複数のフィールドを持つ構造体を実装することはできません &lt;code&gt;CoerceUnsized&lt;/code&gt; を。これは、構造体の型の1つを構造体の別の型に強制変換しようとしている場合にのみ発生します。この場合、 &lt;code&gt;T&lt;/code&gt; から &lt;code&gt;U&lt;/code&gt; に &lt;code&gt;CoerceUnsized&lt;/code&gt; を実装しようとします。これらは両方とも、構造体が取る型です。&lt;a href=&quot;book/ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;無サイズタイプは&lt;/a&gt;、コンパイラがコンパイル時の長さや配置を知っていないことをどのようなタイプです。サイズなしの型を含む構造体もサイズなしです。</target>
        </trans-unit>
        <trans-unit id="fd90f531eb1d0ac938c6ffc13d21933bccfecc8d" translate="yes" xml:space="preserve">
          <source>A struct with the representation hint &lt;code&gt;repr(transparent)&lt;/code&gt; had zero or more than one fields that were not guaranteed to be zero-sized.</source>
          <target state="translated">表現ヒント &lt;code&gt;repr(transparent)&lt;/code&gt; を持つ構造体には、サイズがゼロであることが保証されていないゼロまたは複数のフィールドがありました。</target>
        </trans-unit>
        <trans-unit id="b1c33e6a538a3d99ccd128f7c3f5572cd613b66b" translate="yes" xml:space="preserve">
          <source>A struct without a field containing an unsized type cannot implement &lt;code&gt;CoerceUnsized&lt;/code&gt;. An &lt;a href=&quot;book/ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;unsized type&lt;/a&gt; is any type that the compiler doesn't know the length or alignment of at compile time. Any struct containing an unsized type is also unsized.</source>
          <target state="translated">無サイズタイプを含むフィールドのない構造体を実装することはできません &lt;code&gt;CoerceUnsized&lt;/code&gt; を。&lt;a href=&quot;book/ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;無サイズタイプは&lt;/a&gt;、コンパイラがコンパイル時の長さや配置を知っていないことをどのようなタイプです。サイズなしの型を含む構造体もサイズなしです。</target>
        </trans-unit>
        <trans-unit id="bfe3d05f336ffd910d212738048395d48df402c2" translate="yes" xml:space="preserve">
          <source>A struct's or struct-like enum variant's field was not provided.</source>
          <target state="translated">struct または struct ライクな enum バリアントのフィールドが提供されませんでした。</target>
        </trans-unit>
        <trans-unit id="5bcfe0f822e1b5462565a584546dacf4f3c36744" translate="yes" xml:space="preserve">
          <source>A struct's or struct-like enum variant's field was specified more than once.</source>
          <target state="translated">構造体または構造体に似たenum variantのフィールドが複数回指定されました。</target>
        </trans-unit>
        <trans-unit id="d312c16b162889c1bce1669ed072c5b476d65baa" translate="yes" xml:space="preserve">
          <source>A struct, enum, or union with the &lt;code&gt;repr(transparent)&lt;/code&gt; representation hint contains a zero-sized field that requires non-trivial alignment.</source>
          <target state="translated">&lt;code&gt;repr(transparent)&lt;/code&gt; 表現ヒントを含む構造体、列挙型、または共用体には、サイズがゼロではないフィールドが含まれています。</target>
        </trans-unit>
        <trans-unit id="87c6cf95d3e0451e702dc377209e4618399b1fa6" translate="yes" xml:space="preserve">
          <source>A structure representing a Unix domain socket server.</source>
          <target state="translated">Unix ドメインソケットサーバを表す構造体。</target>
        </trans-unit>
        <trans-unit id="369143bfa607c6bacd39b080c8d08420dc95dcbd" translate="yes" xml:space="preserve">
          <source>A structure representing a type of file with accessors for each file type. It is returned by &lt;a href=&quot;struct.metadata#method.file_type&quot;&gt;&lt;code&gt;Metadata::file_type&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">各ファイルタイプのアクセサを含むファイルのタイプを表す構造。&lt;a href=&quot;struct.metadata#method.file_type&quot;&gt; &lt;code&gt;Metadata::file_type&lt;/code&gt; &lt;/a&gt;メソッドによって返されます。</target>
        </trans-unit>
        <trans-unit id="2859b7dadbca8f1bc62c1ff5e0e2a9f89b18f533" translate="yes" xml:space="preserve">
          <source>A structure wrapping a Windows path prefix as well as its unparsed string representation.</source>
          <target state="translated">Windows のパスプレフィックスと、そのパースされていない文字列表現をラップした構造体。</target>
        </trans-unit>
        <trans-unit id="a18cd960fc14986c70aa975cf92200531a20ff48" translate="yes" xml:space="preserve">
          <source>A structure-literal syntax was used to create an item that is not a structure or enum variant.</source>
          <target state="translated">構造体リテラル構文を使用して、構造体や列挙バリアントではない項目を作成しました。</target>
        </trans-unit>
        <trans-unit id="450ed556ad629fd6ee6dd398c15074a8c129be66" translate="yes" xml:space="preserve">
          <source>A successful conversion will produce the same result as &lt;a href=&quot;struct.cstring#method.new&quot;&gt;&lt;code&gt;CString::new&lt;/code&gt;&lt;/a&gt; when called without the ending nul byte.</source>
          <target state="translated">変換が成功すると、終了nulバイトなしで呼び出されたときに&lt;a href=&quot;struct.cstring#method.new&quot;&gt; &lt;code&gt;CString::new&lt;/code&gt; &lt;/a&gt;と同じ結果が生成されます。</target>
        </trans-unit>
        <trans-unit id="d24a2a657ceada76d6bbbb3c74ce41c5696fa9c3" translate="yes" xml:space="preserve">
          <source>A successful send occurs when it is determined that the other end of the channel has not hung up already. An unsuccessful send would be one where the corresponding receiver has already been deallocated. Note that a return value of &lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; means that the data will never be received, but a return value of &lt;a href=&quot;../../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt; does &lt;em&gt;not&lt;/em&gt; mean that the data will be received. It is possible for the corresponding receiver to hang up immediately after this function returns &lt;a href=&quot;../../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">送信が成功したのは、チャネルのもう一方の端がまだハングアップしていないと判断された場合です。送信の失敗は、対応する受信者の割り当てがすでに解除されている場合です。&lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; の&lt;/a&gt;戻り値はデータが受信されないことを意味しますが、&lt;a href=&quot;../../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; の&lt;/a&gt;戻り値はデータが受信されることを意味し&lt;em&gt;ない&lt;/em&gt;ことに注意してください。この関数が&lt;a href=&quot;../../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; を&lt;/a&gt;返した直後に、対応するレシーバーが電話を切る可能性があります。</target>
        </trans-unit>
        <trans-unit id="74d74f5ba0d4e61c19c1486af3bde440292622e8" translate="yes" xml:space="preserve">
          <source>A suffix is a non-raw identifier immediately (without whitespace) following the primary part of a literal.</source>
          <target state="translated">サフィックスは、リテラルの主要部分の直後にある (空白を含まない)非表示の識別子です。</target>
        </trans-unit>
        <trans-unit id="01225be668ae4fcd869b26b266eae668b00e87f5" translate="yes" xml:space="preserve">
          <source>A super trait has been added to an auto trait.</source>
          <target state="translated">オート特性にスーパー特性が追加されました。</target>
        </trans-unit>
        <trans-unit id="fcd1d7403a3a0b004c92da849e81f0a2dc9aaf82" translate="yes" xml:space="preserve">
          <source>A synchronization primitive which can be used to run a one-time global initialization. Useful for one-time initialization for FFI or related functionality. This type can only be constructed with &lt;a href=&quot;struct.once#method.new&quot;&gt;&lt;code&gt;Once::new()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">1回限りのグローバル初期化を実行するために使用できる同期プリミティブ。FFIまたは関連機能の1回限りの初期化に役立ちます。このタイプは、&lt;a href=&quot;struct.once#method.new&quot;&gt; &lt;code&gt;Once::new()&lt;/code&gt; &lt;/a&gt;でのみ構築できます。</target>
        </trans-unit>
        <trans-unit id="a56a331926b2603c064792db84cd20c38dc32bf0" translate="yes" xml:space="preserve">
          <source>A synchronization primitive which can be used to run a one-time global initialization. Useful for one-time initialization for FFI or related functionality. This type can only be constructed with the &lt;a href=&quot;constant.once_init&quot;&gt;&lt;code&gt;ONCE_INIT&lt;/code&gt;&lt;/a&gt; value or the equivalent &lt;a href=&quot;struct.once#method.new&quot;&gt;&lt;code&gt;Once::new&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">1回限りのグローバル初期化を実行するために使用できる同期プリミティブ。FFIまたは関連機能の1回限りの初期化に役立ちます。このタイプは、&lt;a href=&quot;constant.once_init&quot;&gt; &lt;code&gt;ONCE_INIT&lt;/code&gt; &lt;/a&gt;値または同等の&lt;a href=&quot;struct.once#method.new&quot;&gt; &lt;code&gt;Once::new&lt;/code&gt; &lt;/a&gt;コンストラクターでのみ構築できます。</target>
        </trans-unit>
        <trans-unit id="7ae033712f05c69a86c1b61d9806f301efbdf2ee" translate="yes" xml:space="preserve">
          <source>A synchronization primitive which can be written to only once.</source>
          <target state="translated">一度だけ書き込める同期プリミティブ。</target>
        </trans-unit>
        <trans-unit id="ec350722ecdc068b18a23660d975deaef83608f5" translate="yes" xml:space="preserve">
          <source>A synchronous, bounded channel. The &lt;a href=&quot;fn.sync_channel&quot;&gt;&lt;code&gt;sync_channel&lt;/code&gt;&lt;/a&gt; function will return a &lt;code&gt;(SyncSender, Receiver)&lt;/code&gt; tuple where the storage for pending messages is a pre-allocated buffer of a fixed size. All sends will be &lt;strong&gt;synchronous&lt;/strong&gt; by blocking until there is buffer space available. Note that a bound of 0 is allowed, causing the channel to become a &quot;rendezvous&quot; channel where each sender atomically hands off a message to a receiver.</source>
          <target state="translated">同期の境界チャネル。&lt;a href=&quot;fn.sync_channel&quot;&gt; &lt;code&gt;sync_channel&lt;/code&gt; の&lt;/a&gt;関数は戻ります &lt;code&gt;(SyncSender, Receiver)&lt;/code&gt; 保留中のメッセージのためのストレージは、固定サイズの予め割り当てられたバッファであるタプル。すべての送信は、使用可能なバッファー・スペースができるまでブロックすることにより&lt;strong&gt;同期&lt;/strong&gt;されます。0の境界が許可されることに注意してください。これにより、チャネルは「ランデブー」チャネルになり、各送信者はメッセージを受信者にアトミックにハンドオフします。</target>
        </trans-unit>
        <trans-unit id="cba628809f9496f1476d8b33de698410511ed6a9" translate="yes" xml:space="preserve">
          <source>A syntactical production</source>
          <target state="translated">構文的な生産</target>
        </trans-unit>
        <trans-unit id="a737498d76fd77a9ff17becf5c122eff8eaa0e65" translate="yes" xml:space="preserve">
          <source>A temporary value is being dropped while a borrow is still in active use.</source>
          <target state="translated">借用中に一時的な値が削除されています。</target>
        </trans-unit>
        <trans-unit id="96826c24c299b2bf43fb19f0b4fbba10405e86b7" translate="yes" xml:space="preserve">
          <source>A thread can also return a value through its &lt;a href=&quot;struct.joinhandle&quot;&gt;&lt;code&gt;JoinHandle&lt;/code&gt;&lt;/a&gt;, you can use this to make asynchronous computations (futures might be more appropriate though).</source>
          <target state="translated">スレッドは、その&lt;a href=&quot;struct.joinhandle&quot;&gt; &lt;code&gt;JoinHandle&lt;/code&gt; &lt;/a&gt;を介して値を返すこともできます。これを使用して、非同期計算を行うことができます（ただし、将来はより適切かもしれません）。</target>
        </trans-unit>
        <trans-unit id="ca6a08446cfa59c90fd402f951ed8784aa3d5f4c" translate="yes" xml:space="preserve">
          <source>A thread local storage key which owns its contents.</source>
          <target state="translated">その内容を所有するスレッドのローカルストレージキー。</target>
        </trans-unit>
        <trans-unit id="a566c05b188249907018616799317e8f6688426e" translate="yes" xml:space="preserve">
          <source>A thread that completes without panicking is considered to exit successfully.</source>
          <target state="translated">慌てずに終了したスレッドは正常に終了したとみなされます。</target>
        </trans-unit>
        <trans-unit id="cd2f16a831072bb59e0c5fa9974e56f23c534e74" translate="yes" xml:space="preserve">
          <source>A thread-local key owns the value it contains and will destroy the value when the thread exits. It is created with the &lt;a href=&quot;../macro.thread_local&quot;&gt;&lt;code&gt;thread_local!&lt;/code&gt;&lt;/a&gt; macro and can contain any value that is &lt;code&gt;'static&lt;/code&gt; (no borrowed pointers). It provides an accessor function, &lt;a href=&quot;struct.localkey#method.with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt;, that yields a shared reference to the value to the specified closure. Thread-local keys allow only shared access to values, as there would be no way to guarantee uniqueness if mutable borrows were allowed. Most values will want to make use of some form of &lt;strong&gt;interior mutability&lt;/strong&gt; through the &lt;a href=&quot;../cell/struct.cell&quot;&gt;&lt;code&gt;Cell&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../cell/struct.refcell&quot;&gt;&lt;code&gt;RefCell&lt;/code&gt;&lt;/a&gt; types.</source>
          <target state="translated">スレッドローカルキーはそれが含む値を所有し、スレッドが終了すると値を破棄します。これは&lt;a href=&quot;../macro.thread_local&quot;&gt; &lt;code&gt;thread_local!&lt;/code&gt; &lt;/a&gt;作成されます！マクロであり、 &lt;code&gt;'static&lt;/code&gt; （借用ポインタなし）の任意の値を含めることができます。これは、アクセッサ関数を提供&lt;a href=&quot;struct.localkey#method.with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt;、収率その指定閉鎖に値への共有参照。変更可能な借用が許可されている場合、一意性を保証する方法がないため、スレッドローカルキーは値への共有アクセスのみを許可します。ほとんどの値は、&lt;a href=&quot;../cell/struct.cell&quot;&gt; &lt;code&gt;Cell&lt;/code&gt; &lt;/a&gt;型または&lt;a href=&quot;../cell/struct.refcell&quot;&gt; &lt;code&gt;RefCell&lt;/code&gt; &lt;/a&gt;型を通じて&lt;strong&gt;内部の&lt;/strong&gt;可変性のある形式を利用したいと思うでしょう。</target>
        </trans-unit>
        <trans-unit id="7c1b3e385815bb55356e10c862b54219c0c9bb61" translate="yes" xml:space="preserve">
          <source>A thread-safe reference-counting pointer. 'Arc' stands for 'Atomically Reference Counted'.</source>
          <target state="translated">スレッドセーフな参照カウントポインタ。'Arc' は 'Atomically Reference Counted' の略です。</target>
        </trans-unit>
        <trans-unit id="c20fcb5862a17955d3c9171cc540c5db72364cad" translate="yes" xml:space="preserve">
          <source>A token produced by the lexer</source>
          <target state="translated">レキサーによって生成されたトークン</target>
        </trans-unit>
        <trans-unit id="507266de8c913e006a522a90feaa72cf485f935b" translate="yes" xml:space="preserve">
          <source>A trailing slash is normalized away, &lt;code&gt;/a/b&lt;/code&gt; and &lt;code&gt;/a/b/&lt;/code&gt; are equivalent.</source>
          <target state="translated">末尾のスラッシュは正規化され、 &lt;code&gt;/a/b&lt;/code&gt; と &lt;code&gt;/a/b/&lt;/code&gt; は同等です。</target>
        </trans-unit>
        <trans-unit id="4ac633f47782fcea3e3cdbd2b28541d42f49cb1e" translate="yes" xml:space="preserve">
          <source>A trait bound on &lt;code&gt;?Sized&lt;/code&gt; is the opposite of a trait bound on &lt;code&gt;Sized&lt;/code&gt;: we would read this as &amp;ldquo;&lt;code&gt;T&lt;/code&gt; may or may not be &lt;code&gt;Sized&lt;/code&gt;.&amp;rdquo; This syntax is only available for &lt;code&gt;Sized&lt;/code&gt;, not any other traits.</source>
          <target state="translated">バインドされた形質 &lt;code&gt;?Sized&lt;/code&gt; 上に結合特性の反対で &lt;code&gt;Sized&lt;/code&gt; ：我々はこれを読んでいました「 &lt;code&gt;T&lt;/code&gt; かであってもなくてもよい &lt;code&gt;Sized&lt;/code&gt; 。」この構文は &lt;code&gt;Sized&lt;/code&gt; でのみ使用でき、他のトレイトでは使用できません。</target>
        </trans-unit>
        <trans-unit id="a7f257ac376cb00e120748ca01c24ce026b8963b" translate="yes" xml:space="preserve">
          <source>A trait can have multiple methods in its body: the method signatures are listed one per line and each line ends in a semicolon.</source>
          <target state="translated">形質は本体に複数のメソッドを持つことができます:メソッドのシグネチャは1行に1つずつ表示され、各行はセミコロンで終わります。</target>
        </trans-unit>
        <trans-unit id="9262128bd94142a9efd03c6641a2bff3a39b5b73" translate="yes" xml:space="preserve">
          <source>A trait for borrowing data.</source>
          <target state="translated">データを借りるための特徴。</target>
        </trans-unit>
        <trans-unit id="7529a2277a29d3ff854565242eed7e5e7895a272" translate="yes" xml:space="preserve">
          <source>A trait for converting a value to a &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">値を &lt;code&gt;String&lt;/code&gt; に変換するための特性。</target>
        </trans-unit>
        <trans-unit id="1e3010340eda1a0df2c156c88d0e99044a3b58ec" translate="yes" xml:space="preserve">
          <source>A trait for creating instances of &lt;a href=&quot;trait.hasher&quot;&gt;&lt;code&gt;Hasher&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;trait.hasher&quot;&gt; &lt;code&gt;Hasher&lt;/code&gt; の&lt;/a&gt;インスタンスを作成するための特性。</target>
        </trans-unit>
        <trans-unit id="c6d9b8a4582a6d812cf132a7f8cdac8ff53fc3aa" translate="yes" xml:space="preserve">
          <source>A trait for customizing the behavior of the &lt;code&gt;?&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;?&lt;/code&gt; の動作をカスタマイズするための特性 オペレーター。</target>
        </trans-unit>
        <trans-unit id="976dcd2549faab554b8e6bbecaabfc30542917fd" translate="yes" xml:space="preserve">
          <source>A trait for giving a type a useful default value.</source>
          <target state="translated">型に有用なデフォルト値を与えるための特徴。</target>
        </trans-unit>
        <trans-unit id="e18827eba48f91a1c885aefb421b9657624cb210" translate="yes" xml:space="preserve">
          <source>A trait for hashing an arbitrary stream of bytes.</source>
          <target state="translated">任意のバイトストリームをハッシュ化するための特徴。</target>
        </trans-unit>
        <trans-unit id="bdee9213c6e4170b3110b9dd5eaa365239c9d83d" translate="yes" xml:space="preserve">
          <source>A trait for implementing arbitrary return types in the &lt;code&gt;main&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; 関数に任意の戻り値の型を実装するための特性。</target>
        </trans-unit>
        <trans-unit id="20b8f1b86976a3452526ed169982978b3d0e907f" translate="yes" xml:space="preserve">
          <source>A trait for mutably borrowing data.</source>
          <target state="translated">データを変異的に借用するための形質。</target>
        </trans-unit>
        <trans-unit id="d1ed2c9d8583af1348e3be7781420c71c940ca4b" translate="yes" xml:space="preserve">
          <source>A trait for objects which are byte-oriented sinks.</source>
          <target state="translated">バイト指向のシンクであるオブジェクトの特徴。</target>
        </trans-unit>
        <trans-unit id="754c048641e5a68c7fd81cc8028cfbaf095e1cb7" translate="yes" xml:space="preserve">
          <source>A trait for objects which can be converted or resolved to one or more &lt;a href=&quot;enum.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt; values.</source>
          <target state="translated">1つ以上の&lt;a href=&quot;enum.socketaddr&quot;&gt; &lt;code&gt;SocketAddr&lt;/code&gt; &lt;/a&gt;値に変換または解決できるオブジェクトの特性。</target>
        </trans-unit>
        <trans-unit id="20da43414d9faf5772a30fd6329b8b6d3aa3e3b4" translate="yes" xml:space="preserve">
          <source>A trait for writing or formatting into Unicode-accepting buffers or streams.</source>
          <target state="translated">ユニコードを受け入れるバッファやストリームへの書き込みやフォーマットの特徴。</target>
        </trans-unit>
        <trans-unit id="23adce518b9b9c7fb3e196dc3fd75bab1e5f0059" translate="yes" xml:space="preserve">
          <source>A trait implementation has stricter requirements than the trait definition.</source>
          <target state="translated">形質の実装は、形質の定義よりも厳しい要件を持っています。</target>
        </trans-unit>
        <trans-unit id="bc29685de3e170d55184516a7b3d199864139684" translate="yes" xml:space="preserve">
          <source>A trait implementation is considered incoherent if either the orphan check fails or there are overlapping implementation instances.</source>
          <target state="translated">形質の実装は、オーファンチェックが失敗するか、実装インスタンスが重複している場合、支離滅裂なものとみなされます。</target>
        </trans-unit>
        <trans-unit id="a4884230017ffb802f52c6721c470c8593e7fcd5" translate="yes" xml:space="preserve">
          <source>A trait implementation is considered incoherent if either the orphan rules check fails or there are overlapping implementation instances.</source>
          <target state="translated">形質の実装は、オーファンルールのチェックに失敗するか、実装インスタンスが重複している場合、支離滅裂なものとみなされます。</target>
        </trans-unit>
        <trans-unit id="bb0a26a692dfe7bee9af7137b27b0e076260ccbc" translate="yes" xml:space="preserve">
          <source>A trait implementation must define all non-default associated items declared by the implemented trait, may redefine default associated items defined by the implemented trait, and cannot define any other items.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0010f4426c0d6cbe2dc68d818b29e968be48db6" translate="yes" xml:space="preserve">
          <source>A trait implementation was marked as unsafe while the trait is safe.</source>
          <target state="translated">形質は安全ですが、形質の実装は安全ではないとマークされていました。</target>
        </trans-unit>
        <trans-unit id="1951065ab3447cdfa4016a3198b5e5dd606d4a6b" translate="yes" xml:space="preserve">
          <source>A trait is a language item that is used for describing the functionalities a type must provide. It allows a type to make certain promises about its behavior.</source>
          <target state="translated">形質とは、型が提供しなければならない機能を記述するために使用される言語項目です。これにより、型はその動作について特定の約束をすることができます。</target>
        </trans-unit>
        <trans-unit id="c9de8e0634dfdc7f3f2e02723351cb17b73aefe4" translate="yes" xml:space="preserve">
          <source>A trait may be implemented for &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; in the same crate as &lt;code&gt;T&lt;/code&gt;, which the &lt;a href=&quot;items/implementations#trait-implementation-coherence&quot;&gt;orphan rules&lt;/a&gt; prevent for other generic types.</source>
          <target state="translated">形質はのために実装することができる &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; と同様クレートに &lt;code&gt;T&lt;/code&gt; 、&lt;a href=&quot;items/implementations#trait-implementation-coherence&quot;&gt;孤立規則は&lt;/a&gt;、他の一般的なタイプの防止します。</target>
        </trans-unit>
        <trans-unit id="1b745de10511ea796795a51c79ea5a4b196da151" translate="yes" xml:space="preserve">
          <source>A trait method was declared const.</source>
          <target state="translated">traitメソッドがconstと宣言されました。</target>
        </trans-unit>
        <trans-unit id="c934c2073046ff60e5d7154f42129a33305f83af" translate="yes" xml:space="preserve">
          <source>A trait object is defined over a single, fully-defined trait. With a regular default parameter, this parameter can just be substituted in. However, if the default parameter is &lt;code&gt;Self&lt;/code&gt;, the trait changes for each concrete type; i.e. &lt;code&gt;i32&lt;/code&gt; will be expected to implement &lt;code&gt;A&amp;lt;i32&amp;gt;&lt;/code&gt;, &lt;code&gt;bool&lt;/code&gt; will be expected to implement &lt;code&gt;A&amp;lt;bool&amp;gt;&lt;/code&gt;, etc... These types will not share an implementation of a fully-defined trait; instead they share implementations of a trait with different parameters substituted in for each implementation. This is irreconcilable with what we need to make a trait object work, and is thus disallowed. Making the trait concrete by explicitly specifying the value of the defaulted parameter will fix this issue. Fixed example:</source>
          <target state="translated">特性オブジェクトは、完全に定義された単一の特性に対して定義されます。通常のデフォルトパラメータを使用すると、このパラメータを置き換えるだけで済みます。ただし、デフォルトパラメータが &lt;code&gt;Self&lt;/code&gt; の場合、特性は具象タイプごとに変化します。つまり、 &lt;code&gt;i32&lt;/code&gt; は &lt;code&gt;A&amp;lt;i32&amp;gt;&lt;/code&gt; を実装することが期待され、 &lt;code&gt;bool&lt;/code&gt; は &lt;code&gt;A&amp;lt;bool&amp;gt;&lt;/code&gt; を実装することが期待されます。、など...これらの型は、完全に定義された特性の実装を共有しません。代わりに、実装ごとに異なるパラメーターを使用して、特性の実装を共有します。これは、特性オブジェクトを機能させるために必要なものと一致しないため、許可されていません。デフォルトのパラメータの値を明示的に指定して特性を具体化すると、この問題が修正されます。修正例：</target>
        </trans-unit>
        <trans-unit id="09ed217e59efc6a63ebd08cd2d7fd8370e33eb53" translate="yes" xml:space="preserve">
          <source>A trait object was declared with no traits.</source>
          <target state="translated">trait オブジェクトは、trit がない状態で宣言されていました。</target>
        </trans-unit>
        <trans-unit id="16935dd0c42b10d2b4960eb5cbdc15bbae87c965" translate="yes" xml:space="preserve">
          <source>A trait to emulate dynamic typing.</source>
          <target state="translated">動的なタイピングをエミュレートするための形質。</target>
        </trans-unit>
        <trans-unit id="2977e50a37e0d1dad52d9fd5a6a043035b25bd2b" translate="yes" xml:space="preserve">
          <source>A trait to express the ability to construct an object from a raw file descriptor.</source>
          <target state="translated">生のファイル記述子からオブジェクトを構築する能力を表す形質。</target>
        </trans-unit>
        <trans-unit id="d60c5c028a11d7b4ae9ad91367b8c4ed38349307" translate="yes" xml:space="preserve">
          <source>A trait to express the ability to consume an object and acquire ownership of its raw &lt;code&gt;HANDLE&lt;/code&gt;.</source>
          <target state="translated">オブジェクトを使用し、その未加工の &lt;code&gt;HANDLE&lt;/code&gt; の所有権を取得する機能を表現する特性。</target>
        </trans-unit>
        <trans-unit id="c1f9b5c774891d37ad148a2229500ad192b8b52c" translate="yes" xml:space="preserve">
          <source>A trait to express the ability to consume an object and acquire ownership of its raw &lt;code&gt;SOCKET&lt;/code&gt;.</source>
          <target state="translated">オブジェクトを消費し、その生の所有権を取得する能力を表現する特性 &lt;code&gt;SOCKET&lt;/code&gt; の。</target>
        </trans-unit>
        <trans-unit id="a98e8ff575c7077546911de64edefa1e0d617067" translate="yes" xml:space="preserve">
          <source>A trait to express the ability to consume an object and acquire ownership of its raw file descriptor.</source>
          <target state="translated">オブジェクトを消費し、その生のファイル記述子の所有権を取得する能力を表す形質。</target>
        </trans-unit>
        <trans-unit id="25a11a87d2f4adf0083235ec32efcdd357ad1b14" translate="yes" xml:space="preserve">
          <source>A trait to extract the raw unix file descriptor from an underlying object.</source>
          <target state="translated">基底オブジェクトから生の unix ファイル記述子を抽出するための形質。</target>
        </trans-unit>
        <trans-unit id="74dfee4318a470e1c8aa720bcf48b06f65b677a2" translate="yes" xml:space="preserve">
          <source>A trait type has been dereferenced.</source>
          <target state="translated">形質型が参照されていません。</target>
        </trans-unit>
        <trans-unit id="a3b4acf36ca74c434adb6226f16d93f351b2c3d1" translate="yes" xml:space="preserve">
          <source>A trait was implemented on another which already automatically implemented it.</source>
          <target state="translated">すでに自動的に実装されている別のものに形質が実装されていました。</target>
        </trans-unit>
        <trans-unit id="1af6d624d68ca3ca313d81ebc03c7ca717454c50" translate="yes" xml:space="preserve">
          <source>A transparent struct, enum, or union is supposed to be represented exactly like the piece of data it contains. Zero-sized fields with different alignment requirements potentially conflict with this property. In the example above, &lt;code&gt;Wrapper&lt;/code&gt; would have to be aligned to 32 bytes even though &lt;code&gt;f32&lt;/code&gt; has a smaller alignment requirement.</source>
          <target state="translated">透明な構造体、列挙型、または共用体は、含まれているデータとまったく同じように表現されることになっています。配置要件が異なるサイズがゼロのフィールドは、このプロパティと競合する可能性があります。上記の例では、 &lt;code&gt;f32&lt;/code&gt; の配置要件が小さい場合でも、 &lt;code&gt;Wrapper&lt;/code&gt; を32バイトに配置する必要があります。</target>
        </trans-unit>
        <trans-unit id="490336a5e305f2d2e8d1363f03a6314c497a78fa" translate="yes" xml:space="preserve">
          <source>A tricky example, with sigma:</source>
          <target state="translated">シグマを使ったトリッキーな例。</target>
        </trans-unit>
        <trans-unit id="2d6e480d45ae2d8d8e393f568dbe81e3240a2b6b" translate="yes" xml:space="preserve">
          <source>A trivial example of the usage of &lt;code&gt;bool&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; の使い方の簡単な例、</target>
        </trans-unit>
        <trans-unit id="26204199326019f143410da0c8e1f31498a99258" translate="yes" xml:space="preserve">
          <source>A tuple &lt;em&gt;type&lt;/em&gt; is a heterogeneous product of other types, called the &lt;em&gt;elements&lt;/em&gt; of the tuple. It has no nominal name and is instead structurally typed.</source>
          <target state="translated">タプル&lt;em&gt;型&lt;/em&gt;は、タプルの&lt;em&gt;要素&lt;/em&gt;と呼ばれる他の型の異種製品です。名義はなく、構造的に型付けされています。</target>
        </trans-unit>
        <trans-unit id="e9dbb3e94f53ac8e3a8ca087dfd88ec94acc48f5" translate="yes" xml:space="preserve">
          <source>A tuple index is used to refer to the fields of &lt;a href=&quot;types/tuple&quot;&gt;tuples&lt;/a&gt;, &lt;a href=&quot;items/structs&quot;&gt;tuple structs&lt;/a&gt;, and &lt;a href=&quot;items/enumerations&quot;&gt;tuple variants&lt;/a&gt;.</source>
          <target state="translated">タプルインデックスは、&lt;a href=&quot;types/tuple&quot;&gt;タプル&lt;/a&gt;、&lt;a href=&quot;items/structs&quot;&gt;タプル構造体&lt;/a&gt;、および&lt;a href=&quot;items/enumerations&quot;&gt;タプルバリアント&lt;/a&gt;のフィールドを参照するために使用されます。</target>
        </trans-unit>
        <trans-unit id="7b0541e4cbc97c5e40f947c03ae1731aeaba596f" translate="yes" xml:space="preserve">
          <source>A tuple is a general way of grouping together a number of values with a variety of types into one compound type. Tuples have a fixed length: once declared, they cannot grow or shrink in size.</source>
          <target state="translated">タプルは、さまざまな型を持つ複数の値を1つの複合型にまとめる一般的な方法です。タプルは長さが固定されており、一度宣言するとサイズが大きくなったり小さくなったりすることはありません。</target>
        </trans-unit>
        <trans-unit id="402bd39bb6c42541595f5aba7871ff88c655396e" translate="yes" xml:space="preserve">
          <source>A tuple is a general way of grouping together some number of other values with a variety of types into one compound type. Tuples have a fixed length: once declared, they cannot grow or shrink in size.</source>
          <target state="translated">タプルは、さまざまな型を持つ他の値を1つの複合型にまとめる一般的な方法です。タプルは長さが固定されており、一度宣言するとサイズが大きくなったり小さくなったりすることはありません。</target>
        </trans-unit>
        <trans-unit id="8d3a96e70924f2a82e85cf6036b452ac805c64ec" translate="yes" xml:space="preserve">
          <source>A tuple struct or tuple variant was used in a pattern as if it were a struct or struct variant.</source>
          <target state="translated">タプル構造体やタプルバリアントが、あたかも構造体や構造体バリアントであるかのようにパターン内で使用されていました。</target>
        </trans-unit>
        <trans-unit id="1696a724c358dd0091f73a52db83c7a8082d2750" translate="yes" xml:space="preserve">
          <source>A tuple struct pattern is refutable when one of its subpatterns is refutable.</source>
          <target state="translated">タプル構造体パターンは、そのサブパターンの1つが再可換可能な場合に再可換可能となります。</target>
        </trans-unit>
        <trans-unit id="8f5d8407de99f6165aaf419c7f8aaf0ecf33a5a2" translate="yes" xml:space="preserve">
          <source>A tuple struct's element isn't a machine type when using the &lt;code&gt;#[simd]&lt;/code&gt; attribute.</source>
          <target state="translated">&lt;code&gt;#[simd]&lt;/code&gt; 属性を使用する場合、タプル構造体の要素はマシンタイプではありません。</target>
        </trans-unit>
        <trans-unit id="63c229f3f830c234653affc74d3c7117a6730da6" translate="yes" xml:space="preserve">
          <source>A type alias for &lt;a href=&quot;../convert/enum.infallible&quot;&gt;&lt;code&gt;Infallible&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../convert/enum.infallible&quot;&gt; &lt;code&gt;Infallible&lt;/code&gt; の&lt;/a&gt;タイプエイリアス。</target>
        </trans-unit>
        <trans-unit id="1009527a15bba1ad137f4f63c037795bd4a2bfe2" translate="yes" xml:space="preserve">
          <source>A type alias for the result of a lock method which can be poisoned.</source>
          <target state="translated">ポイズンされる可能性のあるロックメソッドの結果の型のエイリアス。</target>
        </trans-unit>
        <trans-unit id="aae3cf8f6eb9071486813bec542109175b1464e5" translate="yes" xml:space="preserve">
          <source>A type alias for the result of a nonblocking locking method.</source>
          <target state="translated">ノンブロッキング・ロック・メソッドの結果の型のエイリアス。</target>
        </trans-unit>
        <trans-unit id="811e3fb59c28acd0a23a2498fc25dd5079b4be0d" translate="yes" xml:space="preserve">
          <source>A type alias makes this code more manageable by reducing the repetition. In Listing 19-25, we&amp;rsquo;ve introduced an alias named &lt;code&gt;Thunk&lt;/code&gt; for the verbose type and can replace all uses of the type with the shorter alias &lt;code&gt;Thunk&lt;/code&gt;.</source>
          <target state="translated">型エイリアスを使用すると、繰り返しを減らすことでこのコードを管理しやすくなります。リスト19-25では、詳細なタイプのために &lt;code&gt;Thunk&lt;/code&gt; という名前のエイリアスを導入し、タイプのすべての使用をより短いエイリアスで置き換えることができます。 &lt;code&gt;Thunk&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="4e38a79e72762fd78e402d5747ab629fd9e3cf95" translate="yes" xml:space="preserve">
          <source>A type alias to a tuple-struct or unit-struct cannot be used to qualify that type's constructor:</source>
          <target state="translated">タプル構造体やユニット構造体への型のエイリアスは、その型のコンストラクタを修飾するためには使用できません。</target>
        </trans-unit>
        <trans-unit id="872091a52699e1a821b52be55e9443115016332c" translate="yes" xml:space="preserve">
          <source>A type alias to an enum type cannot be used to qualify the constructors:</source>
          <target state="translated">enum 型への型のエイリアスは、コンストラクタを修飾するためには使用できません。</target>
        </trans-unit>
        <trans-unit id="9e407e83d82ec15858c1c29f981a47a04ebb8636" translate="yes" xml:space="preserve">
          <source>A type annotated as &lt;code&gt;repr(transparent)&lt;/code&gt; delegates all representation concerns to another type, so adding more representation hints is contradictory. Remove either the &lt;code&gt;transparent&lt;/code&gt; hint or the other hints, like this:</source>
          <target state="translated">&lt;code&gt;repr(transparent)&lt;/code&gt; として注釈が付けられた型は、すべての表現の懸念を別の型に委譲するため、表現のヒントを追加することは矛盾します。いずれかを削除します &lt;code&gt;transparent&lt;/code&gt; ヒントまたは他のヒントを。</target>
        </trans-unit>
        <trans-unit id="cb5e8aa2faa836eb0e6e33148484b741b2f52f31" translate="yes" xml:space="preserve">
          <source>A type can also have multiple inherent implementations. An implementing type must be defined within the same crate as the original type definition.</source>
          <target state="translated">型は複数の固有の実装を持つこともできます。実装型は、元の型定義と同じ木枠内で定義されなければなりません。</target>
        </trans-unit>
        <trans-unit id="ec397cd955b41db47c056843b89f1c979b1499b9" translate="yes" xml:space="preserve">
          <source>A type can implement &lt;code&gt;Copy&lt;/code&gt; if all of its components implement &lt;code&gt;Copy&lt;/code&gt;. For example, this struct can be &lt;code&gt;Copy&lt;/code&gt;:</source>
          <target state="translated">タイプは、実装することができます &lt;code&gt;Copy&lt;/code&gt; そのすべてのコンポーネントが実装する場合は &lt;code&gt;Copy&lt;/code&gt; 。たとえば、この構造体は &lt;code&gt;Copy&lt;/code&gt; に。</target>
        </trans-unit>
        <trans-unit id="a1e5e79c85877ceec782fbfaa18c2c4e5b9b2282" translate="yes" xml:space="preserve">
          <source>A type cast expression is denoted with the binary operator &lt;code&gt;as&lt;/code&gt;.</source>
          <target state="translated">型キャスト式は二項演算子で示されます &lt;code&gt;as&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="2b97b41bd9c7eae77d5c3b940d4a5832d7e972fb" translate="yes" xml:space="preserve">
          <source>A type dependency cycle has been encountered.</source>
          <target state="translated">型依存サイクルが発生しました。</target>
        </trans-unit>
        <trans-unit id="2904374f2c0e91251791d02f72bd6378c8bccc80" translate="yes" xml:space="preserve">
          <source>A type has both &lt;code&gt;packed&lt;/code&gt; and &lt;code&gt;align&lt;/code&gt; representation hints.</source>
          <target state="translated">タイプには、 &lt;code&gt;packed&lt;/code&gt; 表現と &lt;code&gt;align&lt;/code&gt; 表現の両方のヒントがあります。</target>
        </trans-unit>
        <trans-unit id="77f0b7a28b6f2753f1d76d09de19c12454b7888f" translate="yes" xml:space="preserve">
          <source>A type has conflicting &lt;code&gt;packed&lt;/code&gt; representation hints.</source>
          <target state="translated">タイプに競合する &lt;code&gt;packed&lt;/code&gt; 表現ヒントがあります。</target>
        </trans-unit>
        <trans-unit id="995f457de088e34d1af6ab0e7cbed95033f1f938" translate="yes" xml:space="preserve">
          <source>A type implementing &lt;code&gt;Try&lt;/code&gt; is one that has a canonical way to view it in terms of a success/failure dichotomy. This trait allows both extracting those success or failure values from an existing instance and creating a new instance from a success or failure value.</source>
          <target state="translated">実装するタイプ &lt;code&gt;Try&lt;/code&gt; をは、成功/失敗の二分法に関してそれを表示するための標準的な方法を持つです。この特性により、既存のインスタンスから成功または失敗の値を抽出することと、成功または失敗の値から新しいインスタンスを作成することができます。</target>
        </trans-unit>
        <trans-unit id="f5199d6683f66f6377d3e5c541ab1e1a45f0a440" translate="yes" xml:space="preserve">
          <source>A type indicating whether a timed wait on a condition variable returned due to a time out or not.</source>
          <target state="translated">タイムアウトにより条件変数の時限待ちが返されたかどうかを示す型。</target>
        </trans-unit>
        <trans-unit id="bcb42c5f4b4345c9c33893996e574612ab86b0f7" translate="yes" xml:space="preserve">
          <source>A type is inhabited if it has constructors and therefore can be instantiated. An inhabited type is not &quot;empty&quot; in the sense that there can be values of the type. Opposite of &lt;a href=&quot;#uninhabited&quot;&gt;Uninhabited&lt;/a&gt;.</source>
          <target state="translated">型にはコンストラクターがある場合に存在するため、インスタンス化できます。居住型は、その型の値が存在する可能性があるという意味で「空」ではありません。&lt;a href=&quot;#uninhabited&quot;&gt;無人の&lt;/a&gt;反対。</target>
        </trans-unit>
        <trans-unit id="61c125cceb1922063b5ac33f0666ef79257f43a2" translate="yes" xml:space="preserve">
          <source>A type is uninhabited if it has no constructors and therefore can never be instantiated. An uninhabited type is &quot;empty&quot; in the sense that there are no values of the type. The canonical example of an uninhabited type is the &lt;a href=&quot;types/never&quot;&gt;never type&lt;/a&gt;&lt;code&gt;!&lt;/code&gt;, or an enum with no variants &lt;code&gt;enum Never { }&lt;/code&gt;. Opposite of &lt;a href=&quot;#inhabited&quot;&gt;Inhabited&lt;/a&gt;.</source>
          <target state="translated">コンストラクターがないため、インスタンス化できないタイプは無人です。無人のタイプは、タイプの値がないという意味で「空」です。無人型の標準的な例は、&lt;a href=&quot;types/never&quot;&gt;never型&lt;/a&gt; &lt;code&gt;!&lt;/code&gt; 、またはバリアントのない &lt;code&gt;enum Never { }&lt;/code&gt; 型enum Never {}。人が&lt;a href=&quot;#inhabited&quot;&gt;住んで&lt;/a&gt;いるの反対。</target>
        </trans-unit>
        <trans-unit id="d3666c5137a8c2f5bd25b41e59026d010547814d" translate="yes" xml:space="preserve">
          <source>A type mismatched an associated type of a trait.</source>
          <target state="translated">形質の関連する型と不一致した型。</target>
        </trans-unit>
        <trans-unit id="195d3e2324eafc4b95d0787028892dc2ce75ef57" translate="yes" xml:space="preserve">
          <source>A type of error which can be returned whenever a lock is acquired.</source>
          <target state="translated">ロックを取得したときに必ず返すことができるエラーの種類。</target>
        </trans-unit>
        <trans-unit id="e09ee31e80fe4ed67d90fe93645d23ccc6bd8f11" translate="yes" xml:space="preserve">
          <source>A type or lifetime parameter has been declared but is not actually used.</source>
          <target state="translated">型またはライフタイムパラメータが宣言されていますが、実際には使用されていません。</target>
        </trans-unit>
        <trans-unit id="c7fb190bd9cd84e642f9c437ffcc3a0470b68cd6" translate="yes" xml:space="preserve">
          <source>A type or module has been defined more than once.</source>
          <target state="translated">型またはモジュールが複数回定義されている。</target>
        </trans-unit>
        <trans-unit id="630bff58f7c530334c09b287d02fb5f603530515" translate="yes" xml:space="preserve">
          <source>A type parameter that is specified for &lt;code&gt;impl&lt;/code&gt; is not constrained.</source>
          <target state="translated">&lt;code&gt;impl&lt;/code&gt; に指定された型パラメーターは制約されません。</target>
        </trans-unit>
        <trans-unit id="7a60e8550db7fb8bf181c3c2af427df857c9bf7d" translate="yes" xml:space="preserve">
          <source>A type parameter was declared which shadows an existing one. An example of this error:</source>
          <target state="translated">既存のパラメータの影になる型パラメータが宣言されました。このエラーの例です。</target>
        </trans-unit>
        <trans-unit id="0e1d3a1b69ee90016db302de62e4dd15a2f4ff16" translate="yes" xml:space="preserve">
          <source>A type parameter which references &lt;code&gt;Self&lt;/code&gt; in its default value was not specified.</source>
          <target state="translated">デフォルト値で &lt;code&gt;Self&lt;/code&gt; を参照する型パラメーターが指定されていません。</target>
        </trans-unit>
        <trans-unit id="25fe9cd48afec311fa3f403a24aafba6272aeca5" translate="yes" xml:space="preserve">
          <source>A type parameter which references &lt;code&gt;Self&lt;/code&gt; in its default value was not specified. Example of erroneous code:</source>
          <target state="translated">&lt;code&gt;Self&lt;/code&gt; を参照する型パラメーターデフォルト値で指定されていません。誤ったコードの例：</target>
        </trans-unit>
        <trans-unit id="5ff8db748ed5eaad6145c2ecc683c1493e2ac732" translate="yes" xml:space="preserve">
          <source>A type parameter with default value is using forward declared identifier.</source>
          <target state="translated">デフォルト値のtypeパラメータは、前方宣言された識別子を使用しています。</target>
        </trans-unit>
        <trans-unit id="7d790d10f882d09d23c776016863815c5b3e2b81" translate="yes" xml:space="preserve">
          <source>A type representing an owned, C-compatible, nul-terminated string with no nul bytes in the middle.</source>
          <target state="translated">所有されている、C互換のヌル終端文字列を表す型で、途中にヌルバイトを含まない。</target>
        </trans-unit>
        <trans-unit id="b3b99d63ae795914f8001d38731a170b595e6b2b" translate="yes" xml:space="preserve">
          <source>A type that can be any one of several variants.</source>
          <target state="translated">いくつかのバリエーションのいずれかになるタイプ。</target>
        </trans-unit>
        <trans-unit id="090b303bdd4057540547275158d9e42939d01cec" translate="yes" xml:space="preserve">
          <source>A type that can represent owned, mutable platform-native strings, but is cheaply inter-convertible with Rust strings.</source>
          <target state="translated">プラットフォームネイティブの文字列を表現することができますが、Rustの文字列と安価に相互変換可能な型です。</target>
        </trans-unit>
        <trans-unit id="220ecc56d2012059c1d8cd78943adf0ed8ed7d8e" translate="yes" xml:space="preserve">
          <source>A type that is composed of other types.</source>
          <target state="translated">他の型で構成されている型。</target>
        </trans-unit>
        <trans-unit id="0a851afebbaf8a3f378080846c51bf756d8476cc" translate="yes" xml:space="preserve">
          <source>A type that is not a trait was used in a trait position, such as a bound or &lt;code&gt;impl&lt;/code&gt;.</source>
          <target state="translated">特性ではないタイプが、boundや &lt;code&gt;impl&lt;/code&gt; などの特性位置で使用されました。</target>
        </trans-unit>
        <trans-unit id="48dabc713e66c06bf48c0ba95cf5b1b2867095db" translate="yes" xml:space="preserve">
          <source>A type to emulate dynamic typing.</source>
          <target state="translated">動的型付けをエミュレートするための型。</target>
        </trans-unit>
        <trans-unit id="18995bad7092858c6b32d35a26167b88faf2e216" translate="yes" xml:space="preserve">
          <source>A type used to conditionally initialize buffers passed to &lt;code&gt;Read&lt;/code&gt; methods.</source>
          <target state="translated">&lt;code&gt;Read&lt;/code&gt; に渡されるバッファを条件付きで初期化するために使用されるタイプメソッドに。</target>
        </trans-unit>
        <trans-unit id="8a527d3dadad04c815571442c7e455c6295d0179" translate="yes" xml:space="preserve">
          <source>A type which does not appear as an argument to another type. For example, &lt;code&gt;T&lt;/code&gt; is uncovered, but the &lt;code&gt;T&lt;/code&gt; in &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; is covered. This is only relevant for type arguments.</source>
          <target state="translated">別のタイプへの引数として表示されないタイプ。例えば、 &lt;code&gt;T&lt;/code&gt; が発見されているが、 &lt;code&gt;T&lt;/code&gt; で &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 覆われています。これは、型引数にのみ関係します。</target>
        </trans-unit>
        <trans-unit id="48a3662dff4bc918fde00d869523d6a4f45ec09b" translate="yes" xml:space="preserve">
          <source>A type with &lt;code&gt;packed&lt;/code&gt; representation hint has a field with &lt;code&gt;align&lt;/code&gt; representation hint.</source>
          <target state="translated">&lt;code&gt;packed&lt;/code&gt; 表現ヒントを持つタイプには、 &lt;code&gt;align&lt;/code&gt; 表現ヒントを持つフィールドがあります。</target>
        </trans-unit>
        <trans-unit id="f40b2b31a159196f4517607c9d76ab5a80f0274d" translate="yes" xml:space="preserve">
          <source>A type&amp;rsquo;s behavior consists of the methods we can call on that type. Different types share the same behavior if we can call the same methods on all of those types. Trait definitions are a way to group method signatures together to define a set of behaviors necessary to accomplish some purpose.</source>
          <target state="translated">型の動作は、その型に対して呼び出すことができるメソッドで構成されています。これらのすべての型で同じメソッドを呼び出すことができる場合、異なる型は同じ動作を共有します。特性定義は、メソッドシグネチャをグループ化して、目的を達成するために必要な一連の動作を定義する方法です。</target>
        </trans-unit>
        <trans-unit id="3b6ddcc149faf5698a16d1a853b87785df3d76f9" translate="yes" xml:space="preserve">
          <source>A union access transmutes the content of the union to the type of the accessed field. Since transmutes can cause unexpected or undefined behaviour, &lt;code&gt;unsafe&lt;/code&gt; is required to read from a union field or to write to a field that doesn't implement &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">共用体アクセスは、共用体の内容をアクセスされたフィールドのタイプに変換します。変換は予期しない動作または未定義の動作を引き起こす可能性があるため、unionフィールドから読み取るか、&lt;a href=&quot;../special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; を&lt;/a&gt;実装していないフィールドに書き込むには、 &lt;code&gt;unsafe&lt;/code&gt; が必要です。</target>
        </trans-unit>
        <trans-unit id="5466b2051b7ddfaa4d58e8a7c5e165f16f139371" translate="yes" xml:space="preserve">
          <source>A union declaration uses the same syntax as a struct declaration, except with &lt;code&gt;union&lt;/code&gt; in place of &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="translated">労働組合宣言はを除いて、構造体の宣言と同じ構文を使用して &lt;code&gt;union&lt;/code&gt; の代わりに &lt;code&gt;struct&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ca484ccd859cf11dbaf1461b26fb4e6e0c1155bd" translate="yes" xml:space="preserve">
          <source>A union declared with &lt;code&gt;#[repr(C)]&lt;/code&gt; will have the same size and alignment as an equivalent C union declaration in the C language for the target platform. The union will have a size of the maximum size of all of its fields rounded to its alignment, and an alignment of the maximum alignment of all of its fields. These maximums may come from different fields.</source>
          <target state="translated">&lt;code&gt;#[repr(C)]&lt;/code&gt; で宣言された共用体ターゲットプラットフォーム用のC言語における等価C組合宣言と同じサイズと配向を有するであろう。ユニオンのサイズは、そのすべてのフィールドの最大サイズのサイズに合わせて丸められ、そのすべてのフィールドの最大サイズの位置合わせになります。これらの最大値は、さまざまなフィールドから取得される場合があります。</target>
        </trans-unit>
        <trans-unit id="a5f776fff8bd64de524df1b33719d9e03226007b" translate="yes" xml:space="preserve">
          <source>A unique identifier for a running thread.</source>
          <target state="translated">実行中のスレッドの一意の識別子。</target>
        </trans-unit>
        <trans-unit id="10b778820b33fd4a7dd6fe5ae783d38d25f8f4be" translate="yes" xml:space="preserve">
          <source>A unit struct expression is just the path to a unit struct item. This refers to the unit struct's implicit constant of its value. The unit struct value can also be constructed with a fieldless struct expression. For example:</source>
          <target state="translated">ユニット構造体の式は、ユニット構造体の項目へのパスにすぎません。これは、ユニット構造体の値の暗黙の定数を指します。単位構造体の値は、フィールドレス構造体式で構築することもできます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="e1ccfef1f9d17695dcb29cad8794e8d363ce8a2b" translate="yes" xml:space="preserve">
          <source>A unrecognized representation attribute was used.</source>
          <target state="translated">認識されていない表現属性が使用されていました。</target>
        </trans-unit>
        <trans-unit id="5b4c71cc75880bc2daa87d6294e45d4e462f56c4" translate="yes" xml:space="preserve">
          <source>A used type name is not in scope.</source>
          <target state="translated">使用済みの型名は対象外です。</target>
        </trans-unit>
        <trans-unit id="bb363e92161ec8a647cc462201572019f30fe79b" translate="yes" xml:space="preserve">
          <source>A vacant entry.</source>
          <target state="translated">空きエントリー。</target>
        </trans-unit>
        <trans-unit id="ac311baab6584071250fc9bbbfdd8d2bebd0c9e9" translate="yes" xml:space="preserve">
          <source>A value in a &lt;code&gt;char&lt;/code&gt; which is a surrogate or above &lt;code&gt;char::MAX&lt;/code&gt;.</source>
          <target state="translated">値 &lt;code&gt;char&lt;/code&gt; サロゲート以上である &lt;code&gt;char::MAX&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0cd18e9d0df56f2d91218b99bcfa24832cc2e846" translate="yes" xml:space="preserve">
          <source>A value of a &lt;a href=&quot;../items/unions&quot;&gt;union&lt;/a&gt; type can also be created using this syntax, except that it must specify exactly one field.</source>
          <target state="translated">&lt;a href=&quot;../items/unions&quot;&gt;労働組合の&lt;/a&gt;価値タイプのこの構文を使用して作成することもできますが、フィールドを1つだけ指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="9f77849f445f82a7dac2f95551cd7b942f343391" translate="yes" xml:space="preserve">
          <source>A value of a union type can be created using the same syntax that is used for struct types, except that it must specify exactly one field:</source>
          <target state="translated">ユニオン型の値は、構造体型に使用されるのと同じ構文を使用して作成することができますが、正確に 1 つのフィールドを指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="2edc0a57205327b0c616a8834c05686bc2cd3aab" translate="yes" xml:space="preserve">
          <source>A value of type &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.bool.html&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt; representing logical &lt;strong&gt;false&lt;/strong&gt;.</source>
          <target state="translated">論理&lt;strong&gt;falseを&lt;/strong&gt;表す&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.bool.html&quot;&gt; &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt;型の値。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7083e77e4fd9ce896b8de61f936c4776bbf66b89" translate="yes" xml:space="preserve">
          <source>A value of type &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.bool.html&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt; representing logical &lt;strong&gt;true&lt;/strong&gt;.</source>
          <target state="translated">論理&lt;strong&gt;trueを&lt;/strong&gt;表す&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.bool.html&quot;&gt; &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt;型の値。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c8dd18f78fe47645f4c465046226e5bceaa87924" translate="yes" xml:space="preserve">
          <source>A value of type &lt;a href=&quot;primitive.bool&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt; representing logical &lt;strong&gt;false&lt;/strong&gt;.</source>
          <target state="translated">論理&lt;strong&gt;falseを&lt;/strong&gt;表す&lt;a href=&quot;primitive.bool&quot;&gt; &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt;型の値&lt;strong&gt;&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="5f389328467f7ba3f2c3abda8662442b712ffb60" translate="yes" xml:space="preserve">
          <source>A value of type &lt;a href=&quot;primitive.bool&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt; representing logical &lt;strong&gt;true&lt;/strong&gt;.</source>
          <target state="translated">論理&lt;strong&gt;trueを&lt;/strong&gt;表す&lt;a href=&quot;primitive.bool&quot;&gt; &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt;型の値&lt;strong&gt;&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="b855bdd2c1132135fcde425660863334401f8ec6" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;char&lt;/code&gt; is a &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode scalar value&lt;/a&gt; (i.e. a code point that is not a surrogate), represented as a 32-bit unsigned word in the 0x0000 to 0xD7FF or 0xE000 to 0x10FFFF range. A &lt;code&gt;[char]&lt;/code&gt; is effectively a UCS-4 / UTF-32 string.</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; 型の値は、&lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicodeスカラー値&lt;/a&gt;（つまり、サロゲートではないコードポイント）であり、0x0000〜0xD7FFまたは0xE000〜0x10FFFFの範囲の32ビットの符号なしワードとして表されます。A &lt;code&gt;[char]&lt;/code&gt; 効果的にUCS-4 / UTF-32の文字列です。</target>
        </trans-unit>
        <trans-unit id="d1f3055da898f22398d4fbd4a38fa84ee1e65f98" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;char&lt;/code&gt; is a &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode scalar value&lt;/a&gt; (i.e. a code point that is not a surrogate), represented as a 32-bit unsigned word in the 0x0000 to 0xD7FF or 0xE000 to 0x10FFFF range. It is immediate &lt;a href=&quot;../behavior-considered-undefined&quot;&gt;Undefined Behavior&lt;/a&gt; to create a &lt;code&gt;char&lt;/code&gt; that falls outside this range. A &lt;code&gt;[char]&lt;/code&gt; is effectively a UCS-4 / UTF-32 string of length 1.</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; 型の値は、&lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicodeスカラー値&lt;/a&gt;（つまり、サロゲートではないコードポイント）であり、0x0000〜0xD7FFまたは0xE000〜0x10FFFFの範囲の32ビット符号なしワードとして表されます。この範囲外の &lt;code&gt;char&lt;/code&gt; を作成することは、即時の&lt;a href=&quot;../behavior-considered-undefined&quot;&gt;未定義の動作&lt;/a&gt;です。 &lt;code&gt;[char]&lt;/code&gt; 効果的に長さ1のUCS-4 / UTF-32の文字列です。</target>
        </trans-unit>
        <trans-unit id="3e06926f845b74d33c5ef28adb8bb299e3388cd7" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;char&lt;/code&gt; is a &lt;a href=&quot;https://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode scalar value&lt;/a&gt; (i.e. a code point that is not a surrogate), represented as a 32-bit unsigned word in the 0x0000 to 0xD7FF or 0xE000 to 0x10FFFF range. It is immediate &lt;a href=&quot;../behavior-considered-undefined&quot;&gt;Undefined Behavior&lt;/a&gt; to create a &lt;code&gt;char&lt;/code&gt; that falls outside this range. A &lt;code&gt;[char]&lt;/code&gt; is effectively a UCS-4 / UTF-32 string of length 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59d76a5d3d80327c3f37cdc56ddfd9ab850292ae" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;str&lt;/code&gt; is a Unicode string, represented as an array of 8-bit unsigned bytes holding a sequence of UTF-8 code points. Since &lt;code&gt;str&lt;/code&gt; is a &lt;a href=&quot;../dynamically-sized-types&quot;&gt;dynamically sized type&lt;/a&gt;, it is not a &lt;em&gt;first-class&lt;/em&gt; type, but can only be instantiated through a pointer type, such as &lt;code&gt;&amp;amp;str&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 型の値はUnicode文字列であり、UTF-8コードポイントのシーケンスを保持する8ビットの符号なしバイトの配列として表されます。以来 &lt;code&gt;str&lt;/code&gt; がある&lt;a href=&quot;../dynamically-sized-types&quot;&gt;動的にサイズタイプ&lt;/a&gt;、そうではない&lt;em&gt;最初のクラスの&lt;/em&gt;型が、唯一のような、ポインタ型を介してインスタンス化することができる &lt;code&gt;&amp;amp;str&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bbb241cb793b74334bb4ee4c800e211086ca2124" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;str&lt;/code&gt; is represented the same way as &lt;code&gt;[u8]&lt;/code&gt;, it is a slice of 8-bit unsigned bytes. However, the Rust standard library makes extra assumptions about &lt;code&gt;str&lt;/code&gt;: methods working on &lt;code&gt;str&lt;/code&gt; assume and ensure that the data in there is valid UTF-8. Calling a &lt;code&gt;str&lt;/code&gt; method with a non-UTF-8 buffer can cause &lt;a href=&quot;../behavior-considered-undefined&quot;&gt;Undefined Behavior&lt;/a&gt; now or in the future.</source>
          <target state="translated">タイプ &lt;code&gt;str&lt;/code&gt; の値は、 &lt;code&gt;[u8]&lt;/code&gt; と同じ方法で表され、8ビットの符号なしバイトのスライスです。ただし、Rust標準ライブラリは &lt;code&gt;str&lt;/code&gt; について追加の仮定を行い &lt;code&gt;str&lt;/code&gt; 動作するメソッドは、そこにあるデータが有効なUTF-8であることを仮定して保証します。非UTF-8バッファを使用して &lt;code&gt;str&lt;/code&gt; メソッドを呼び出すと、現在または将来、&lt;a href=&quot;../behavior-considered-undefined&quot;&gt;未定義の動作&lt;/a&gt;が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="a63b20136e367659035b6e689b2afe4c29bd6017" translate="yes" xml:space="preserve">
          <source>A value other than &lt;code&gt;false&lt;/code&gt; (&lt;code&gt;0&lt;/code&gt;) or &lt;code&gt;true&lt;/code&gt; (&lt;code&gt;1&lt;/code&gt;) in a &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; &lt;code&gt;false&lt;/code&gt; （ &lt;code&gt;0&lt;/code&gt; ）または &lt;code&gt;true&lt;/code&gt; （ &lt;code&gt;1&lt;/code&gt; ）以外の値。</target>
        </trans-unit>
        <trans-unit id="b4cba545fd19cda1128ffaf1d3286b9b7d56cde6" translate="yes" xml:space="preserve">
          <source>A value was moved out of a non-copy fixed-size array.</source>
          <target state="translated">値がコピーされていない固定サイズの配列から移動されました。</target>
        </trans-unit>
        <trans-unit id="b42cffab7e9c15b342f66d8f5259941653a63c96" translate="yes" xml:space="preserve">
          <source>A value was moved out while it was still borrowed.</source>
          <target state="translated">借りたままの状態で値が動いた。</target>
        </trans-unit>
        <trans-unit id="82027756f29be28c79aeae3975a5766aa1d2efa8" translate="yes" xml:space="preserve">
          <source>A value was moved whose size was not known at compile time.</source>
          <target state="translated">コンパイル時にサイズがわからない値が移動されました。</target>
        </trans-unit>
        <trans-unit id="9706341e2da60c066ce6e7cf05178b38f120d103" translate="yes" xml:space="preserve">
          <source>A value was moved. However, its size was not known at compile time, and only values of a known size can be moved.</source>
          <target state="translated">値が移動されました。しかし、コンパイル時にそのサイズがわからなかったため、既知のサイズの値しか移動できません。</target>
        </trans-unit>
        <trans-unit id="44837e659d57e9e8963db42f2a8ff432184c868b" translate="yes" xml:space="preserve">
          <source>A value was used after it was mutably borrowed.</source>
          <target state="translated">値は変異的に借りた後に使用されました。</target>
        </trans-unit>
        <trans-unit id="a269a1265b9da40e02988ddb4b935f3e57685c81" translate="yes" xml:space="preserve">
          <source>A value which is initialized on the first access.</source>
          <target state="translated">最初のアクセス時に初期化される値。</target>
        </trans-unit>
        <trans-unit id="0a9fd9c77be9db665eaa8aa09f7c11046598c96c" translate="yes" xml:space="preserve">
          <source>A value with a custom &lt;code&gt;Drop&lt;/code&gt; implementation may be dropped during const-eval.</source>
          <target state="translated">カスタム &lt;code&gt;Drop&lt;/code&gt; 実装の値は、const-eval中にドロップされる場合があります。</target>
        </trans-unit>
        <trans-unit id="ce9baf105eb065b4e2e707a1c70964d52846271c" translate="yes" xml:space="preserve">
          <source>A value, once pinned, must remain pinned forever (unless its type implements &lt;code&gt;Unpin&lt;/code&gt;).</source>
          <target state="translated">固定された値は、その型が &lt;code&gt;Unpin&lt;/code&gt; を実装しない限り、永久に固定されたままである必要があります。</target>
        </trans-unit>
        <trans-unit id="f834afc88c6404de279c7c8f515cfb4300b16ac9" translate="yes" xml:space="preserve">
          <source>A value-to-value conversion that consumes the input value. The opposite of &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">入力値を使用する値から値への変換。&lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt;の反対。</target>
        </trans-unit>
        <trans-unit id="0ec26c2f12c942e7a95c50dd2e23886df77a4d3b" translate="yes" xml:space="preserve">
          <source>A variable already borrowed as immutable was borrowed as mutable.</source>
          <target state="translated">すでに不変として借りていた変数は、変異可能として借りていました。</target>
        </trans-unit>
        <trans-unit id="e13d6f0eba74b4bdfc6f5572578b32920b145941" translate="yes" xml:space="preserve">
          <source>A variable is initialized if it has been assigned a value and hasn't since been moved from. All other memory locations are assumed to be uninitialized. Only unsafe Rust can create such a memory without initializing it.</source>
          <target state="translated">変数に値が代入されていて、それが移動されていない場合は初期化されます。他のすべてのメモリ位置は、初期化されていないものとみなされます。このようなメモリを初期化せずに作成できるのは、安全ではない Rust だけです。</target>
        </trans-unit>
        <trans-unit id="bcb706d6a23f6a1ef0d6e932c9012ea02de89d1f" translate="yes" xml:space="preserve">
          <source>A variable used inside an inner function comes from a dynamic environment.</source>
          <target state="translated">内部関数内で使用される変数は、動的環境から来ています。</target>
        </trans-unit>
        <trans-unit id="624b6ee4bba7ea4936aac9cd4851655dde5b7367" translate="yes" xml:space="preserve">
          <source>A variable was borrowed as mutable more than once.</source>
          <target state="translated">変数は複数回変異可能なものとして借用されていました。</target>
        </trans-unit>
        <trans-unit id="d671f0302da4834f34c2a582f5308578a61da28e" translate="yes" xml:space="preserve">
          <source>A variable was borrowed as mutable more than once. Erroneous code example:</source>
          <target state="translated">変数が複数回 mutable として借用されていました。誤ったコード例。</target>
        </trans-unit>
        <trans-unit id="8f68dfea86962d0e6496e5ee7e7ba76db7429014" translate="yes" xml:space="preserve">
          <source>A variable was used after its contents have been moved elsewhere.</source>
          <target state="translated">変数の内容が他の場所に移動された後に使用されました。</target>
        </trans-unit>
        <trans-unit id="7373f15283d19d70ccdc1ebdabd671b6fa35a616" translate="yes" xml:space="preserve">
          <source>A variable which requires unique access is being used in more than one closure at the same time.</source>
          <target state="translated">一意なアクセスを必要とする変数が、同時に複数のクロージャで使用されています。</target>
        </trans-unit>
        <trans-unit id="179ae2668e7ec007982c4f5de54552aaba759982" translate="yes" xml:space="preserve">
          <source>A very common source of input is standard input:</source>
          <target state="translated">非常に一般的な入力源は標準入力です。</target>
        </trans-unit>
        <trans-unit id="8fd033d78acbcd4754d1027990e8d5a9b9826bd0" translate="yes" xml:space="preserve">
          <source>A very simple implementation of a &lt;code&gt;Balance&lt;/code&gt; struct that has two sides, where each can be indexed mutably and immutably.</source>
          <target state="translated">&lt;code&gt;Balance&lt;/code&gt; 非常にシンプルな実装2つのサイドを持つ構造体のそれぞれに変更可能で不変のインデックスを付けることができます。</target>
        </trans-unit>
        <trans-unit id="97a780f793593419e0ff592febcf6977a93355f0" translate="yes" xml:space="preserve">
          <source>A view into a single entry in a map, which may either be vacant or occupied.</source>
          <target state="translated">地図上の1つの項目のビューで、空席または占有されている場合があります。</target>
        </trans-unit>
        <trans-unit id="8b25993b294c4224a4cf2b72c86b09f4a1df51e2" translate="yes" xml:space="preserve">
          <source>A view into a vacant entry in a &lt;code&gt;BTreeMap&lt;/code&gt;. It is part of the &lt;a href=&quot;enum.entry&quot;&gt;&lt;code&gt;Entry&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="translated">&lt;code&gt;BTreeMap&lt;/code&gt; の空のエントリのビュー。これは&lt;a href=&quot;enum.entry&quot;&gt; &lt;code&gt;Entry&lt;/code&gt; &lt;/a&gt;列挙型の一部です。</target>
        </trans-unit>
        <trans-unit id="7403429e7fd780dc27d8a13d9952581d4b4e445e" translate="yes" xml:space="preserve">
          <source>A view into a vacant entry in a &lt;code&gt;HashMap&lt;/code&gt;. It is part of the &lt;a href=&quot;enum.entry&quot;&gt;&lt;code&gt;Entry&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; の空のエントリのビュー。これは&lt;a href=&quot;enum.entry&quot;&gt; &lt;code&gt;Entry&lt;/code&gt; &lt;/a&gt;列挙型の一部です。</target>
        </trans-unit>
        <trans-unit id="e122826d4e223005f70614b786e8ddc75140b027" translate="yes" xml:space="preserve">
          <source>A view into a vacant entry in a &lt;code&gt;HashMap&lt;/code&gt;. It is part of the &lt;a href=&quot;enum.rawentrymut&quot;&gt;&lt;code&gt;RawEntryMut&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; の空のエントリのビュー。&lt;a href=&quot;enum.rawentrymut&quot;&gt; &lt;code&gt;RawEntryMut&lt;/code&gt; &lt;/a&gt;列挙型の一部です。</target>
        </trans-unit>
        <trans-unit id="ce99b5e5cd3ea34b7d4c0f89a8831922c382a6d4" translate="yes" xml:space="preserve">
          <source>A view into an occupied entry in a &lt;code&gt;BTreeMap&lt;/code&gt;. It is part of the &lt;a href=&quot;enum.entry&quot;&gt;&lt;code&gt;Entry&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="translated">&lt;code&gt;BTreeMap&lt;/code&gt; 内の占有されたエントリのビュー。これは&lt;a href=&quot;enum.entry&quot;&gt; &lt;code&gt;Entry&lt;/code&gt; &lt;/a&gt;列挙型の一部です。</target>
        </trans-unit>
        <trans-unit id="be269036f18f5f092608a130f8ea68df4394d390" translate="yes" xml:space="preserve">
          <source>A view into an occupied entry in a &lt;code&gt;HashMap&lt;/code&gt;. It is part of the &lt;a href=&quot;enum.entry&quot;&gt;&lt;code&gt;Entry&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; で占有されているエントリのビュー。これは&lt;a href=&quot;enum.entry&quot;&gt; &lt;code&gt;Entry&lt;/code&gt; &lt;/a&gt;列挙型の一部です。</target>
        </trans-unit>
        <trans-unit id="097a52eaa6538170318bb496b2404a2534b2fc4c" translate="yes" xml:space="preserve">
          <source>A view into an occupied entry in a &lt;code&gt;HashMap&lt;/code&gt;. It is part of the &lt;a href=&quot;enum.rawentrymut&quot;&gt;&lt;code&gt;RawEntryMut&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 内の占有されたエントリのビュー。&lt;a href=&quot;enum.rawentrymut&quot;&gt; &lt;code&gt;RawEntryMut&lt;/code&gt; の&lt;/a&gt;一部です列挙型の。</target>
        </trans-unit>
        <trans-unit id="1dcb56819c21811e53111728b70cf9c4d536f34f" translate="yes" xml:space="preserve">
          <source>A virtual function pointer table (vtable) that specifies the behavior of a &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; の&lt;/a&gt;動作を指定する仮想関数ポインターテーブル（vtable）。</target>
        </trans-unit>
        <trans-unit id="9f3a191fe5eca1034f9485c5579c98bfcc0c4efc" translate="yes" xml:space="preserve">
          <source>A visibility qualifier was used when it was unnecessary.</source>
          <target state="translated">視認性のある修飾子は、不要な場合に使用されていました。</target>
        </trans-unit>
        <trans-unit id="ac7d35f82dab2d813057ea592ffddd469b64e834" translate="yes" xml:space="preserve">
          <source>A visibility qualifier was used when it was unnecessary. Erroneous code examples:</source>
          <target state="translated">不要なときに可視性修飾子が使用されていました。誤ったコード例。</target>
        </trans-unit>
        <trans-unit id="b3fc7b3827a6fcc8a59a000c786e3c02a55a53ac" translate="yes" xml:space="preserve">
          <source>A while-let pattern attempts to match the pattern, and enters the body if the match was successful. If the match is irrefutable (when it cannot fail to match), use a regular &lt;code&gt;let&lt;/code&gt;-binding inside a &lt;code&gt;loop&lt;/code&gt; instead. For instance:</source>
          <target state="translated">while-letパターンはパターンに一致しようとし、一致が成功した場合は本文に入ります。一致に反論できない場合（一致に失敗しない場合）、代わりに &lt;code&gt;loop&lt;/code&gt; 内で通常の &lt;code&gt;let&lt;/code&gt; バインディングを使用します。例えば：</target>
        </trans-unit>
        <trans-unit id="410ed7d62125fc62e5f4dca9f96376b96589d768" translate="yes" xml:space="preserve">
          <source>A windowed iterator over a slice in overlapping chunks (&lt;code&gt;N&lt;/code&gt; elements at a time), starting at the beginning of the slice</source>
          <target state="translated">スライスの先頭から開始して、重複するチャンク（一度に &lt;code&gt;N&lt;/code&gt; 個の要素）のスライス上のウィンドウ化されたイテレータ</target>
        </trans-unit>
        <trans-unit id="fc142166b026c4503335a66425ed02745d313757" translate="yes" xml:space="preserve">
          <source>A workaround for this problem is to wrap the trait up in a struct, and implement Drop on that. An example is shown below:</source>
          <target state="translated">この問題を回避するには、形質を struct でラップし、その上に Drop を実装する方法があります。以下に例を示します。</target>
        </trans-unit>
        <trans-unit id="f617743555e205f1a8f890d184cd3c23b7f7c1f7" translate="yes" xml:space="preserve">
          <source>A workaround for this problem is to wrap the trait up in a struct, and implement Drop on that:</source>
          <target state="translated">この問題の回避策は、形質を構造体で包み込み、その上に Drop を実装することです。</target>
        </trans-unit>
        <trans-unit id="2126e0b1e41989d782fb5cb045faec8bb5419d59" translate="yes" xml:space="preserve">
          <source>A working version would be:</source>
          <target state="translated">作業用のバージョンがあるだろう。</target>
        </trans-unit>
        <trans-unit id="0d662f80f6ce134ee94f8241854c8eb7d0a73167" translate="yes" xml:space="preserve">
          <source>A wrapper for a &lt;code&gt;va_list&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;va_list&lt;/code&gt; のラッパー</target>
        </trans-unit>
        <trans-unit id="b7d2953f481ad207e80e2b4f3ea38a3fc7fdbf37" translate="yes" xml:space="preserve">
          <source>A wrapper to inhibit compiler from automatically calling &lt;code&gt;T&lt;/code&gt;&amp;rsquo;s destructor.</source>
          <target state="translated">コンパイラが &lt;code&gt;T&lt;/code&gt; を自動的に呼び出すことを禁止するラッパーのデストラクタを。</target>
        </trans-unit>
        <trans-unit id="fd107425d645d1765a8fa8c1d57cb5b2986006a8" translate="yes" xml:space="preserve">
          <source>A wrapper to inhibit compiler from automatically calling &lt;code&gt;T&lt;/code&gt;&amp;rsquo;s destructor. This wrapper is 0-cost.</source>
          <target state="translated">コンパイラが &lt;code&gt;T&lt;/code&gt; のデストラクタを自動的に呼び出さないようにするラッパー。このラッパーは0コストです。</target>
        </trans-unit>
        <trans-unit id="27e603a9954cbc24a31a5ec5bf12ad7cbfb65091" translate="yes" xml:space="preserve">
          <source>A wrapper type for a mutably borrowed value from a &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; からの可変借用値のラッパータイプ。</target>
        </trans-unit>
        <trans-unit id="76e573ae156cec07995313b0af472777485c1ac4" translate="yes" xml:space="preserve">
          <source>A wrapper type to construct uninitialized instances of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; の初期化されていないインスタンスを構築するラッパータイプ。</target>
        </trans-unit>
        <trans-unit id="4e4e6894ffe01981313c8a0bdd641986bcbb13e0" translate="yes" xml:space="preserve">
          <source>A writer which will move data into the void.</source>
          <target state="translated">データを空虚な場所に移動させるライタ。</target>
        </trans-unit>
        <trans-unit id="3c1aa63d0f65966b349901d79576dfb3a03d713a" translate="yes" xml:space="preserve">
          <source>A yank &lt;em&gt;does not&lt;/em&gt; delete any code. For example, the yank feature is not intended for deleting accidentally uploaded secrets. If that happens, you must reset those secrets immediately.</source>
          <target state="translated">ヤンク&lt;em&gt;は&lt;/em&gt;コードを削除&lt;em&gt;しません&lt;/em&gt;。たとえば、ヤンク機能は誤ってアップロードされたシークレットを削除することを目的としていません。その場合は、これらのシークレットをすぐにリセットする必要があります。</target>
        </trans-unit>
        <trans-unit id="c0f586bae86592aff79f5cdbd80a984e38bc5729" translate="yes" xml:space="preserve">
          <source>A yield expression was used outside of the generator literal.</source>
          <target state="translated">ジェネレータリテラルの外で降伏式が使用されていました。</target>
        </trans-unit>
        <trans-unit id="441d954d4dd0146ecde4bbe0bfe1d8d54e840f8a" translate="yes" xml:space="preserve">
          <source>ABI</source>
          <target state="translated">ABI</target>
        </trans-unit>
        <trans-unit id="f7f4dbec39b0ff3d85b8eb96500c85b0c6447c9c" translate="yes" xml:space="preserve">
          <source>ABI, linking, symbols, and FFI</source>
          <target state="translated">ABI、リンク、シンボル、FFI</target>
        </trans-unit>
        <trans-unit id="6984d7f2e63fc7e0a74bddee5e62b9dd8e8c052e" translate="yes" xml:space="preserve">
          <source>API not fully fleshed out and ready to be stabilized</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="711248439308ea2477b7d1f8ab4f7bd34663bf23" translate="yes" xml:space="preserve">
          <source>APIs like &lt;code&gt;try_for_each&lt;/code&gt; don't need values with &lt;code&gt;Break&lt;/code&gt;, so this provides a way to avoid typing &lt;code&gt;(())&lt;/code&gt;, if you prefer it.</source>
          <target state="translated">&lt;code&gt;try_for_each&lt;/code&gt; のようなAPIは、 &lt;code&gt;Break&lt;/code&gt; で値を必要としないため、必要に応じて、 &lt;code&gt;(())&lt;/code&gt; の入力を回避する方法を提供します。</target>
        </trans-unit>
        <trans-unit id="623cb147c595ee00f55c9bfbece2fd89256c0ca0" translate="yes" xml:space="preserve">
          <source>ARCH</source>
          <target state="translated">ARCH</target>
        </trans-unit>
        <trans-unit id="ebb42dcc0b64c9c253b3563c217764b64d93cc3b" translate="yes" xml:space="preserve">
          <source>ARM platforms like &lt;code&gt;armv5te&lt;/code&gt; that aren't for Linux do not have any atomics at all.</source>
          <target state="translated">Linux用ではない &lt;code&gt;armv5te&lt;/code&gt; のようなARMプラットフォームには、アトミックがまったくありません。</target>
        </trans-unit>
        <trans-unit id="9c08db2a34e8bae40e385191593c075648426189" translate="yes" xml:space="preserve">
          <source>ARM platforms like &lt;code&gt;armv5te&lt;/code&gt; that aren't for Linux only provide &lt;code&gt;load&lt;/code&gt; and &lt;code&gt;store&lt;/code&gt; operations, and do not support Compare and Swap (CAS) operations, such as &lt;code&gt;swap&lt;/code&gt;, &lt;code&gt;fetch_add&lt;/code&gt;, etc. Additionally on Linux, these CAS operations are implemented via &lt;a href=&quot;https://www.kernel.org/doc/Documentation/arm/kernel_user_helpers.txt&quot;&gt;operating system support&lt;/a&gt;, which may come with a performance penalty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d8a36ef8e4b107d52ef5f736828e510925b8177" translate="yes" xml:space="preserve">
          <source>ARM targets with &lt;code&gt;thumbv6m&lt;/code&gt; do not have atomic operations at all.</source>
          <target state="translated">&lt;code&gt;thumbv6m&lt;/code&gt; を備えた ARMターゲットには、アトミック操作はまったくありません。</target>
        </trans-unit>
        <trans-unit id="f34ee041311ae3f08813e81fbedc2a8cd4a047c6" translate="yes" xml:space="preserve">
          <source>ARM targets with &lt;code&gt;thumbv6m&lt;/code&gt; only provide &lt;code&gt;load&lt;/code&gt; and &lt;code&gt;store&lt;/code&gt; operations, and do not support Compare and Swap (CAS) operations, such as &lt;code&gt;swap&lt;/code&gt;, &lt;code&gt;fetch_add&lt;/code&gt;, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb0279d84c9ab08002a8ea7634cd21f2283a6099" translate="yes" xml:space="preserve">
          <source>ASCII :</source>
          <target state="translated">アスキー .</target>
        </trans-unit>
        <trans-unit id="317e8901215d42ccc7940d34b4ce9490884463f7" translate="yes" xml:space="preserve">
          <source>ASCII byte literal</source>
          <target state="translated">アスキーバイトリテラル</target>
        </trans-unit>
        <trans-unit id="4d8ae89e872f4c2b2dd8feb9252c9a119be50b1e" translate="yes" xml:space="preserve">
          <source>ASCII escapes</source>
          <target state="translated">アスキーエスケープ</target>
        </trans-unit>
        <trans-unit id="ca370d4b69baa6a205bc27d7c92d683f7ec62f70" translate="yes" xml:space="preserve">
          <source>ASCII letters 'A' to 'Z' are mapped to 'a' to 'z', but non-ASCII letters are unchanged.</source>
          <target state="translated">ASCII文字の「A」から「Z」は「a」から「z」にマッピングされますが、非ASCII文字は変更されません。</target>
        </trans-unit>
        <trans-unit id="2e3db4ca30bac04610a9ba330ec0d3d5c61cf4d8" translate="yes" xml:space="preserve">
          <source>ASCII letters 'a' to 'z' are mapped to 'A' to 'Z', but non-ASCII letters are unchanged.</source>
          <target state="translated">ASCII 文字 'a' から 'z' は 'A' から 'Z' にマップされますが、非 ASCII 文字は変更されません。</target>
        </trans-unit>
        <trans-unit id="958cc1148f8aff5543459cc62e998e9d661990e7" translate="yes" xml:space="preserve">
          <source>ASCII_ESCAPE :</source>
          <target state="translated">ASCII_ESCAPE .</target>
        </trans-unit>
        <trans-unit id="8d6c4817508ef1c56c15761069329bc78c08e97c" translate="yes" xml:space="preserve">
          <source>ASCII_FOR_CHAR :</source>
          <target state="translated">ASCII_FOR_CHAR .</target>
        </trans-unit>
        <trans-unit id="1e976fbca3f1cd1471746ec2b3ff6a7a5d15936f" translate="yes" xml:space="preserve">
          <source>ASCII_FOR_STRING :</source>
          <target state="translated">ASCII_FOR_STRING .</target>
        </trans-unit>
        <trans-unit id="b6453d9f657d21e7c289076ce98028e47dc7282d" translate="yes" xml:space="preserve">
          <source>ATOMIC_BOOL_INIT</source>
          <target state="translated">ATOMIC_BOOL_INIT</target>
        </trans-unit>
        <trans-unit id="2b9c513ccbb146434eeb5bd6802254d3e9319214" translate="yes" xml:space="preserve">
          <source>ATOMIC_I16_INIT</source>
          <target state="translated">ATOMIC_I16_INIT</target>
        </trans-unit>
        <trans-unit id="6eacbfe2c8c788ffc6b7a2bdbffc94fa45c82d1a" translate="yes" xml:space="preserve">
          <source>ATOMIC_I32_INIT</source>
          <target state="translated">ATOMIC_I32_INIT</target>
        </trans-unit>
        <trans-unit id="66f562d6648e128b70300462dcad7b8fc4608b4d" translate="yes" xml:space="preserve">
          <source>ATOMIC_I64_INIT</source>
          <target state="translated">ATOMIC_I64_INIT</target>
        </trans-unit>
        <trans-unit id="3fed299eb934560d34d135ac41857a8fb36ef0bf" translate="yes" xml:space="preserve">
          <source>ATOMIC_I8_INIT</source>
          <target state="translated">ATOMIC_I8_INIT</target>
        </trans-unit>
        <trans-unit id="bdb0440ba3e33135f2c764f4348aac2801df19e3" translate="yes" xml:space="preserve">
          <source>ATOMIC_ISIZE_INIT</source>
          <target state="translated">ATOMIC_ISIZE_INIT</target>
        </trans-unit>
        <trans-unit id="8666b79dcee9e5c85aa6e1517921389330c7bb56" translate="yes" xml:space="preserve">
          <source>ATOMIC_U16_INIT</source>
          <target state="translated">ATOMIC_U16_INIT</target>
        </trans-unit>
        <trans-unit id="5463cfe71666bd3cbb7e7bd93e1dea5283405daf" translate="yes" xml:space="preserve">
          <source>ATOMIC_U32_INIT</source>
          <target state="translated">ATOMIC_U32_INIT</target>
        </trans-unit>
        <trans-unit id="fee37bb8c4ae8ff95ead7263aeefbf92f4fb076f" translate="yes" xml:space="preserve">
          <source>ATOMIC_U64_INIT</source>
          <target state="translated">ATOMIC_U64_INIT</target>
        </trans-unit>
        <trans-unit id="b5fd0a39697ab3a5f13871b24404fa76ef7723d2" translate="yes" xml:space="preserve">
          <source>ATOMIC_U8_INIT</source>
          <target state="translated">ATOMIC_U8_INIT</target>
        </trans-unit>
        <trans-unit id="b775de59887a198b8bb80812de87ea9a271a97f2" translate="yes" xml:space="preserve">
          <source>ATOMIC_USIZE_INIT</source>
          <target state="translated">ATOMIC_USIZE_INIT</target>
        </trans-unit>
        <trans-unit id="931aa76f7d621b2bd9a484f56b5e9a93cf07c3f7" translate="yes" xml:space="preserve">
          <source>Abort on memory allocation error or failure.</source>
          <target state="translated">メモリ割り当てエラーまたは失敗でアボート</target>
        </trans-unit>
        <trans-unit id="df06ef34b8240a09fa9f161ea99137607ac00a56" translate="yes" xml:space="preserve">
          <source>Aborts the execution of the process.</source>
          <target state="translated">プロセスの実行を中止します。</target>
        </trans-unit>
        <trans-unit id="b619665e057a59c1a1dbdf52957bcc9212748104" translate="yes" xml:space="preserve">
          <source>Abstract return types</source>
          <target state="translated">抽象的な戻り値の型</target>
        </trans-unit>
        <trans-unit id="db7472b4d6bc69237c01f48a8b625cef374de6c1" translate="yes" xml:space="preserve">
          <source>Abstract return types (written &lt;code&gt;impl Trait&lt;/code&gt; for some trait &lt;code&gt;Trait&lt;/code&gt;) are only allowed as function and inherent impl return types.</source>
          <target state="translated">（書かれた抽象戻り値の型 &lt;code&gt;impl Trait&lt;/code&gt; いくつかの形質について &lt;code&gt;Trait&lt;/code&gt; ）のみの機能と固有のimplの戻り値の型として許可されています。</target>
        </trans-unit>
        <trans-unit id="bdd7aedb4bc31655563e1852b48c298d5ec5570e" translate="yes" xml:space="preserve">
          <source>Abstract syntax tree</source>
          <target state="translated">抽象構文木</target>
        </trans-unit>
        <trans-unit id="8a308b160b478c6d80c833cea5942381a0eb8138" translate="yes" xml:space="preserve">
          <source>Accept a new incoming connection from this listener.</source>
          <target state="translated">このリスナーからの新しい着信接続を受け入れます。</target>
        </trans-unit>
        <trans-unit id="9d161ad935c554382c0d645c53e65dd6566a4bb5" translate="yes" xml:space="preserve">
          <source>Accepting Command Line Arguments</source>
          <target state="translated">コマンドライン引数の受け入れ</target>
        </trans-unit>
        <trans-unit id="5c44c9a8bf41c1458082624764926e9e452b0f9a" translate="yes" xml:space="preserve">
          <source>Accepts &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;AcqRel&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;SeqCst&lt;/code&gt;&lt;/a&gt; orderings.</source>
          <target state="translated">&lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;AcqRel&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;SeqCst&lt;/code&gt; の&lt;/a&gt;順序を受け入れます。</target>
        </trans-unit>
        <trans-unit id="a053fb66cacbf9febf839206d8e07b27aeeb3488" translate="yes" xml:space="preserve">
          <source>Accepts a new incoming connection to this listener.</source>
          <target state="translated">このリスナーへの新しい着信接続を受け入れます。</target>
        </trans-unit>
        <trans-unit id="41aadfd41c1a6581a617dbde4d22fdb01baa3e91" translate="yes" xml:space="preserve">
          <source>Access an entry by a key and its hash.</source>
          <target state="translated">キーとそのハッシュでエントリにアクセスします。</target>
        </trans-unit>
        <trans-unit id="51a3abe326b3c0792015c0e4fe719586def474a7" translate="yes" xml:space="preserve">
          <source>Access an entry by hash.</source>
          <target state="translated">ハッシュでエントリにアクセスします。</target>
        </trans-unit>
        <trans-unit id="fab65c5f7333ea79c15d33939860036f46df2b02" translate="yes" xml:space="preserve">
          <source>Access an entry by key.</source>
          <target state="translated">キーでエントリにアクセスします。</target>
        </trans-unit>
        <trans-unit id="f8d8572e08e06ee9c752f760cd0d14aa8e2826f1" translate="yes" xml:space="preserve">
          <source>Access fields in a packed struct:</source>
          <target state="translated">パック構造体のフィールドにアクセスします。</target>
        </trans-unit>
        <trans-unit id="dcc61ae90f40e1ace5937cd1dcd9d685d9053fd4" translate="yes" xml:space="preserve">
          <source>Access fields of &lt;a href=&quot;keyword.union&quot;&gt;&lt;code&gt;union&lt;/code&gt;&lt;/a&gt;s</source>
          <target state="translated">&lt;a href=&quot;keyword.union&quot;&gt; &lt;code&gt;union&lt;/code&gt; &lt;/a&gt;のフィールドにアクセスする</target>
        </trans-unit>
        <trans-unit id="b465e0094928c80bf2ab2af5859dca5bafc8fa28" translate="yes" xml:space="preserve">
          <source>Access fields of &lt;code&gt;union&lt;/code&gt;s</source>
          <target state="translated">&lt;code&gt;union&lt;/code&gt; のフィールドにアクセスする</target>
        </trans-unit>
        <trans-unit id="9ea16fa6ced966020c4bffbd61fb4353757d0cf8" translate="yes" xml:space="preserve">
          <source>Access members of a packed struct by reference:</source>
          <target state="translated">パックされた構造体のメンバに参照でアクセスします。</target>
        </trans-unit>
        <trans-unit id="8b8e97faa7739e19473f47e07608526221b515e7" translate="yes" xml:space="preserve">
          <source>Access or modify a mutable static variable</source>
          <target state="translated">変異可能な静的変数へのアクセスまたは変更</target>
        </trans-unit>
        <trans-unit id="cd54de93b3358e522ad1a3c574f8befd63e8ca75" translate="yes" xml:space="preserve">
          <source>Access the underlying UTF-8 error that was the cause of this error.</source>
          <target state="translated">このエラーの原因となった基礎となるUTF-8エラーにアクセスします。</target>
        </trans-unit>
        <trans-unit id="46164e9a717820065d93ac43f40d916b0e4e7553" translate="yes" xml:space="preserve">
          <source>AccessError</source>
          <target state="translated">AccessError</target>
        </trans-unit>
        <trans-unit id="ce24154072e2c91b2d63af9c452a4cc41adea723" translate="yes" xml:space="preserve">
          <source>AccessError::borrow</source>
          <target state="translated">AccessError::borrow</target>
        </trans-unit>
        <trans-unit id="0cc742fcaecb2fa19742b5bc67e762feaa6f37c0" translate="yes" xml:space="preserve">
          <source>AccessError::borrow_mut</source>
          <target state="translated">AccessError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="a94e2b3363d2d1a8ced8c51a5e15ff4f96e5bb39" translate="yes" xml:space="preserve">
          <source>AccessError::fmt</source>
          <target state="translated">AccessError::fmt</target>
        </trans-unit>
        <trans-unit id="2c2380ad9f60011344ab503262723a632ed3c1d2" translate="yes" xml:space="preserve">
          <source>AccessError::from</source>
          <target state="translated">AccessError::from</target>
        </trans-unit>
        <trans-unit id="7621469337a4b2f74d2a377616bccd38326a7edd" translate="yes" xml:space="preserve">
          <source>AccessError::into</source>
          <target state="translated">AccessError::into</target>
        </trans-unit>
        <trans-unit id="57d0ff4e6d1785ba4d9a1781d3047ed655772b49" translate="yes" xml:space="preserve">
          <source>AccessError::to_string</source>
          <target state="translated">AccessError::to_string</target>
        </trans-unit>
        <trans-unit id="c9ce68542ae4f2f8f818a2b5731ce826d35da932" translate="yes" xml:space="preserve">
          <source>AccessError::try_from</source>
          <target state="translated">AccessError::try_from</target>
        </trans-unit>
        <trans-unit id="cbc880d00714a36a28ddfefa1107fb401f040376" translate="yes" xml:space="preserve">
          <source>AccessError::try_into</source>
          <target state="translated">AccessError::try_into</target>
        </trans-unit>
        <trans-unit id="f18106e890f07e143593c942859c5df6ac97bdb0" translate="yes" xml:space="preserve">
          <source>AccessError::type_id</source>
          <target state="translated">AccessError::type_id</target>
        </trans-unit>
        <trans-unit id="6260b03bb183bb1a54da2dc8ffad6ed6483c869e" translate="yes" xml:space="preserve">
          <source>Accessing Array Elements</source>
          <target state="translated">配列要素へのアクセス</target>
        </trans-unit>
        <trans-unit id="0457e6128b17f06deb434a0c2873ebd99b60eb0d" translate="yes" xml:space="preserve">
          <source>Accessing Fields of a Union</source>
          <target state="translated">ユニオンのフィールドへのアクセス</target>
        </trans-unit>
        <trans-unit id="6a8c72aa13ec7be5fc27578400a1a226881f478c" translate="yes" xml:space="preserve">
          <source>Accessing Values in a Hash Map</source>
          <target state="translated">ハッシュマップ内の値へのアクセス</target>
        </trans-unit>
        <trans-unit id="b06fec963d87626314583ae2b00b8c48fde3efce" translate="yes" xml:space="preserve">
          <source>Accessing a field of a &lt;a href=&quot;items/unions&quot;&gt;&lt;code&gt;union&lt;/code&gt;&lt;/a&gt;, other than to assign to it.</source>
          <target state="translated">&lt;a href=&quot;items/unions&quot;&gt; &lt;code&gt;union&lt;/code&gt; の&lt;/a&gt;フィールドへのアクセス以外の、フィールドへのアクセス。</target>
        </trans-unit>
        <trans-unit id="a0cd0bd48f335ea136bd217d77f1a368ccbcee58" translate="yes" xml:space="preserve">
          <source>Accessing adjacent &lt;code&gt;u8&lt;/code&gt; as &lt;code&gt;u16&lt;/code&gt;</source>
          <target state="translated">隣接するアクセス &lt;code&gt;u8&lt;/code&gt; として &lt;code&gt;u16&lt;/code&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
