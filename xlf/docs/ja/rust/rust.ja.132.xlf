<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="8c62b63ef24786f929500cd4f0e354183f51728d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Copy&lt;/code&gt; trait is rarely required; types that implement &lt;code&gt;Copy&lt;/code&gt; have optimizations available, meaning you don&amp;rsquo;t have to call &lt;code&gt;clone&lt;/code&gt;, which makes the code more concise.</source>
          <target state="translated">&lt;code&gt;Copy&lt;/code&gt; 形質はめったに必要ありません。 &lt;code&gt;Copy&lt;/code&gt; を実装する型は最適化を利用できます。つまり、 &lt;code&gt;clone&lt;/code&gt; を呼び出す必要がないため、コードがより簡潔になります。</target>
        </trans-unit>
        <trans-unit id="19e60de5e2cec4f66ffc273d83b18ba133a29961" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Copy&lt;/code&gt; trait was implemented on a type which contains a field that doesn't implement the &lt;code&gt;Copy&lt;/code&gt; trait.</source>
          <target state="translated">&lt;code&gt;Copy&lt;/code&gt; が実装されていないフィールドが含まタイプに実装されました形質の &lt;code&gt;Copy&lt;/code&gt; 形質を。</target>
        </trans-unit>
        <trans-unit id="5bc1853088c8596ec738b63d0b306b0f2a10680d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Copy&lt;/code&gt; trait was implemented on a type which is neither a struct nor an enum.</source>
          <target state="translated">&lt;code&gt;Copy&lt;/code&gt; 形質は構造体でも列挙でもないタイプに実装されました。</target>
        </trans-unit>
        <trans-unit id="23cc8d6ab49e3b2451486ee83ff4fdc2f0dab312" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Copy&lt;/code&gt; trait was implemented on a type with a &lt;code&gt;Drop&lt;/code&gt; implementation.</source>
          <target state="translated">&lt;code&gt;Copy&lt;/code&gt; 形質が付きタイプに実装された &lt;code&gt;Drop&lt;/code&gt; 実装。</target>
        </trans-unit>
        <trans-unit id="7a2c2f0333db2747594fc8c5736d8f8e947ab10e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Counter&lt;/code&gt; struct has one field named &lt;code&gt;count&lt;/code&gt;. This field holds a &lt;code&gt;u32&lt;/code&gt; value that will keep track of where we are in the process of iterating from 1 to 5. The &lt;code&gt;count&lt;/code&gt; field is private because we want the implementation of &lt;code&gt;Counter&lt;/code&gt; to manage its value. The &lt;code&gt;new&lt;/code&gt; function enforces the behavior of always starting new instances with a value of 0 in the &lt;code&gt;count&lt;/code&gt; field.</source>
          <target state="translated">&lt;code&gt;Counter&lt;/code&gt; 構造体は、一つのフィールドを指名した &lt;code&gt;count&lt;/code&gt; 。このフィールドには、保持している &lt;code&gt;u32&lt;/code&gt; 我々は1から5まで反復の過程のどこにいるのを追跡します値 &lt;code&gt;count&lt;/code&gt; 我々は実装したいので、プライベートでフィールドを &lt;code&gt;Counter&lt;/code&gt; 、その値を管理すること。 &lt;code&gt;new&lt;/code&gt; 機能は、常に0の値を持つ新しいインスタンスを開始する行動強制 &lt;code&gt;count&lt;/code&gt; フィールドを。</target>
        </trans-unit>
        <trans-unit id="e402bbce82e84dd539cf1e138daa2856a0613786" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Debug&lt;/code&gt; trait allows you to print instances of a type for debugging purposes, so you and other programmers using your type can inspect an instance at a particular point in a program&amp;rsquo;s execution.</source>
          <target state="translated">&lt;code&gt;Debug&lt;/code&gt; トレイトは、あなたとあなたのタイプを使用して他のプログラマは、プログラムの実行中に特定のポイントでのインスタンスを検査することができますので、あなたは、デバッグ目的型のインスタンスを印刷することができます。</target>
        </trans-unit>
        <trans-unit id="853b42f22ba0be46a6e5cd03ba34756814292e76" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Debug&lt;/code&gt; trait enables debug formatting in format strings, which you indicate by adding &lt;code&gt;:?&lt;/code&gt; within &lt;code&gt;{}&lt;/code&gt; placeholders.</source>
          <target state="translated">&lt;code&gt;Debug&lt;/code&gt; トレイトを使用すると、追加して示すフォーマット文字列で書式設定のデバッグを可能にしますか &lt;code&gt;:?&lt;/code&gt; &lt;code&gt;{}&lt;/code&gt; プレースホルダー内。</target>
        </trans-unit>
        <trans-unit id="6967ae462b0a2a18036d993e8418edd4a969bd40" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Debug&lt;/code&gt; trait is required, for example, in use of the &lt;code&gt;assert_eq!&lt;/code&gt; macro. This macro prints the values of instances given as arguments if the equality assertion fails so programmers can see why the two instances weren&amp;rsquo;t equal.</source>
          <target state="translated">&lt;code&gt;Debug&lt;/code&gt; 形質が使用中で、例えば、必要とされる &lt;code&gt;assert_eq!&lt;/code&gt; 大きい。このマクロは、等しいアサーションが失敗した場合に引数として指定されたインスタンスの値を出力するので、プログラマは2つのインスタンスが等しくなかった理由を確認できます。</target>
        </trans-unit>
        <trans-unit id="aba43f90e22e0dfd98100913cb543e02752ca675" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Default::default&lt;/code&gt; function is commonly used in combination with the struct update syntax discussed in the &lt;a href=&quot;ch05-01-defining-structs#creating-instances-from-other-instances-with-struct-update-syntax&quot;&gt;&amp;ldquo;Creating Instances From Other Instances With Struct Update Syntax&amp;rdquo;&lt;/a&gt; section in Chapter 5. You can customize a few fields of a struct and then set and use a default value for the rest of the fields by using &lt;code&gt;..Default::default()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Default::default&lt;/code&gt; 機能は、一般的に議論したstruct更新構文と組み合わせて使用される&lt;a href=&quot;ch05-01-defining-structs#creating-instances-from-other-instances-with-struct-update-syntax&quot;&gt;「構造体の更新構文を持つ他のインスタンスからのインスタンスの作成」&lt;/a&gt;に設定して使用するA、あなたは構造体のいくつかのフィールドをカスタマイズすることができます第5章でセクションと &lt;code&gt;..Default::default()&lt;/code&gt; を使用して、残りのフィールドのデフォルト値。</target>
        </trans-unit>
        <trans-unit id="4f7be30b5dee7044de3817ca4c87b66ab54682e4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Default&lt;/code&gt; cannot be derived on an enum for the simple reason that the compiler doesn't know which value to pick by default whereas it can for a struct as long as all its fields implement the &lt;code&gt;Default&lt;/code&gt; trait as well.</source>
          <target state="translated">&lt;code&gt;Default&lt;/code&gt; コンパイラはそれができるのに対し、長いすべてのフィールドが実装としてとして構造体のために、デフォルトで選択する値を知っていないという単純な理由のために列挙型に導くことができない &lt;code&gt;Default&lt;/code&gt; にも形質を。</target>
        </trans-unit>
        <trans-unit id="155c03f436324748d5a47629042098342e63a6ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Default&lt;/code&gt; trait allows you to create a default value for a type. Deriving &lt;code&gt;Default&lt;/code&gt; implements the &lt;code&gt;default&lt;/code&gt; function. The derived implementation of the &lt;code&gt;default&lt;/code&gt; function calls the &lt;code&gt;default&lt;/code&gt; function on each part of the type, meaning all fields or values in the type must also implement &lt;code&gt;Default&lt;/code&gt; to derive &lt;code&gt;Default&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Default&lt;/code&gt; 特性を使用して、型のデフォルト値を作成することができます。 &lt;code&gt;Default&lt;/code&gt; 導出すると、 &lt;code&gt;default&lt;/code&gt; 関数が実装されます。派生実装 &lt;code&gt;default&lt;/code&gt; 機能を呼び出し &lt;code&gt;default&lt;/code&gt; も実装しなければならないタイプのすべてのフィールドまたは値を意味し、タイプの各部分の機能を &lt;code&gt;Default&lt;/code&gt; 導出する &lt;code&gt;Default&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="417d240e17ea189069372338520fb02d077b097b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Default&lt;/code&gt; trait for types which may have meaningful default values.</source>
          <target state="translated">意味のあるデフォルト値を持つタイプの &lt;code&gt;Default&lt;/code&gt; 特性。</target>
        </trans-unit>
        <trans-unit id="e9ffe8630d56067e177ef382279c1fa4ad4f3ea3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Default&lt;/code&gt; trait is required when you use the method &lt;code&gt;unwrap_or_default&lt;/code&gt; on &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; instances, for example. If the &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, the method &lt;code&gt;unwrap_or_default&lt;/code&gt; will return the result of &lt;code&gt;Default::default&lt;/code&gt; for the type &lt;code&gt;T&lt;/code&gt; stored in the &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Default&lt;/code&gt; あなたがメソッドの使用時に特性が要求される &lt;code&gt;unwrap_or_default&lt;/code&gt; の &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 例えばインスタンスを、。場合 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; ありません &lt;code&gt;None&lt;/code&gt; 、メソッド &lt;code&gt;unwrap_or_default&lt;/code&gt; は、結果が返されます &lt;code&gt;Default::default&lt;/code&gt; タイプのための &lt;code&gt;T&lt;/code&gt; に保存された &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="faec1eafc86ec050669e657d677254ae1cc5eb09" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Default&lt;/code&gt; trait was derived on an enum.</source>
          <target state="translated">&lt;code&gt;Default&lt;/code&gt; 形質は列挙型に導出しました。</target>
        </trans-unit>
        <trans-unit id="3bac5d0a36fa049d2b9d797796c56dde34fe6945" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DispatchFromDyn&lt;/code&gt; trait currently can only be implemented for builtin pointer types and structs that are newtype wrappers around them &amp;mdash; that is, the struct must have only one field (except for&lt;code&gt;PhantomData&lt;/code&gt;), and that field must itself implement &lt;code&gt;DispatchFromDyn&lt;/code&gt;.</source>
          <target state="translated">現在、 &lt;code&gt;DispatchFromDyn&lt;/code&gt; トレイトは、組み込みのポインター型とその周りのnewtypeラッパーである構造体に対してのみ実装できます。つまり、構造体は1つのフィールド（ &lt;code&gt;PhantomData&lt;/code&gt; を除く）のみを持ち、そのフィールド自体が &lt;code&gt;DispatchFromDyn&lt;/code&gt; を実装する必要があります。</target>
        </trans-unit>
        <trans-unit id="f4511d27b8bd2f5f7b72a8b815a18a15df561075" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DispatchFromDyn&lt;/code&gt; trait was implemented on something which is not a pointer or a newtype wrapper around a pointer.</source>
          <target state="translated">&lt;code&gt;DispatchFromDyn&lt;/code&gt; の形質はポインタやポインタ周りのnewtypeラッパーではない何かに実装されました。</target>
        </trans-unit>
        <trans-unit id="b6986e696b5a0b081bb4012a05eb9e1b65dcc35b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DraftPost&lt;/code&gt; struct has an &lt;code&gt;add_text&lt;/code&gt; method, so we can add text to &lt;code&gt;content&lt;/code&gt; as before, but note that &lt;code&gt;DraftPost&lt;/code&gt; does not have a &lt;code&gt;content&lt;/code&gt; method defined! So now the program ensures all posts start as draft posts, and draft posts don&amp;rsquo;t have their content available for display. Any attempt to get around these constraints will result in a compiler error.</source>
          <target state="translated">&lt;code&gt;DraftPost&lt;/code&gt; の構造体があり &lt;code&gt;add_text&lt;/code&gt; の我々はにテキストを追加することができますので、この方法を &lt;code&gt;content&lt;/code&gt; 以前のように、しかし、そのノート &lt;code&gt;DraftPost&lt;/code&gt; が持っていない &lt;code&gt;content&lt;/code&gt; 方法が定義されました！したがって、プログラムはすべての投稿がドラフト投稿として開始することを保証し、ドラフト投稿はコンテンツを表示することができません。これらの制約を回避しようとすると、コンパイラエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="b1de117663cb2f27f8306ea33629038001aac2df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Drop&lt;/code&gt; trait is included in the prelude, so we don&amp;rsquo;t need to bring it into scope. We implement the &lt;code&gt;Drop&lt;/code&gt; trait on &lt;code&gt;CustomSmartPointer&lt;/code&gt; and provide an implementation for the &lt;code&gt;drop&lt;/code&gt; method that calls &lt;code&gt;println!&lt;/code&gt;. The body of the &lt;code&gt;drop&lt;/code&gt; function is where you would place any logic that you wanted to run when an instance of your type goes out of scope. We&amp;rsquo;re printing some text here to demonstrate when Rust will call &lt;code&gt;drop&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Drop&lt;/code&gt; 我々はスコープにそれを持参する必要はありませんので、形質は、前奏曲に含まれています。 &lt;code&gt;CustomSmartPointer&lt;/code&gt; に &lt;code&gt;Drop&lt;/code&gt; トレイトを実装し、 &lt;code&gt;println!&lt;/code&gt; を呼び出す &lt;code&gt;drop&lt;/code&gt; メソッドの実装を提供します！。 &lt;code&gt;drop&lt;/code&gt; 関数の本体は、タイプのインスタンスがスコープから外れたときに実行したいロジックを配置する場所です。 Rustが &lt;code&gt;drop&lt;/code&gt; を呼び出すタイミングを示すために、ここにテキストをいくつか印刷しています。</target>
        </trans-unit>
        <trans-unit id="a67a7efec93a37792cb31993e146b2f7a5f7bc09" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Eq&lt;/code&gt; trait has no methods. Its purpose is to signal that for every value of the annotated type, the value is equal to itself. The &lt;code&gt;Eq&lt;/code&gt; trait can only be applied to types that also implement &lt;code&gt;PartialEq&lt;/code&gt;, although not all types that implement &lt;code&gt;PartialEq&lt;/code&gt; can implement &lt;code&gt;Eq&lt;/code&gt;. One example of this is floating point number types: the implementation of floating point numbers states that two instances of the not-a-number (&lt;code&gt;NaN&lt;/code&gt;) value are not equal to each other.</source>
          <target state="translated">&lt;code&gt;Eq&lt;/code&gt; トレイトはメソッドを持っていません。その目的は、注釈付きタイプのすべての値について、値がそれ自体と等しいことを通知することです。 &lt;code&gt;Eq&lt;/code&gt; 特性だけでも実装する型に適用することができ &lt;code&gt;PartialEq&lt;/code&gt; を実装するすべてのタイプではないが、 &lt;code&gt;PartialEq&lt;/code&gt; を実装することができ &lt;code&gt;Eq&lt;/code&gt; 。この1つの例は、浮動小数点数型です。浮動小数点数の実装は、非数（ &lt;code&gt;NaN&lt;/code&gt; ）値の2つのインスタンスが互いに等しくないことを示しています。</target>
        </trans-unit>
        <trans-unit id="339e508d8f9f4467a3c3de396b4c7c19141c661f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;F&lt;/code&gt; type parameter also has the trait bound &lt;code&gt;Send&lt;/code&gt; and the lifetime bound &lt;code&gt;'static&lt;/code&gt;, which are useful in our situation: we need &lt;code&gt;Send&lt;/code&gt; to transfer the closure from one thread to another and &lt;code&gt;'static&lt;/code&gt; because we don&amp;rsquo;t know how long the thread will take to execute. Let&amp;rsquo;s create an &lt;code&gt;execute&lt;/code&gt; method on &lt;code&gt;ThreadPool&lt;/code&gt; that will take a generic parameter of type &lt;code&gt;F&lt;/code&gt; with these bounds:</source>
          <target state="translated">&lt;code&gt;F&lt;/code&gt; の型パラメータもトレイト結合した &lt;code&gt;Send&lt;/code&gt; され、結合寿命 &lt;code&gt;'static&lt;/code&gt; 我々の状況において有用である、：我々は必要が &lt;code&gt;Send&lt;/code&gt; 別と1つのスレッドから閉鎖を転送する &lt;code&gt;'static&lt;/code&gt; 我々は知らないので、どのくらいのスレッドがします実行します。これらの境界を持つタイプ &lt;code&gt;F&lt;/code&gt; のジェネリックパラメーターを取る &lt;code&gt;ThreadPool&lt;/code&gt; の &lt;code&gt;execute&lt;/code&gt; メソッドを作成してみましょう。</target>
        </trans-unit>
        <trans-unit id="44f286163600e21778b5e8ddc538f3f66c2c5215" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;F&lt;/code&gt; type parameter is the one we&amp;rsquo;re concerned with here; the &lt;code&gt;T&lt;/code&gt; type parameter is related to the return value, and we&amp;rsquo;re not concerned with that. We can see that &lt;code&gt;spawn&lt;/code&gt; uses &lt;code&gt;FnOnce&lt;/code&gt; as the trait bound on &lt;code&gt;F&lt;/code&gt;. This is probably what we want as well, because we&amp;rsquo;ll eventually pass the argument we get in &lt;code&gt;execute&lt;/code&gt; to &lt;code&gt;spawn&lt;/code&gt;. We can be further confident that &lt;code&gt;FnOnce&lt;/code&gt; is the trait we want to use because the thread for running a request will only execute that request&amp;rsquo;s closure one time, which matches the &lt;code&gt;Once&lt;/code&gt; in &lt;code&gt;FnOnce&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;F&lt;/code&gt; の型パラメータは、私たちがここに関係しているものです。 &lt;code&gt;T&lt;/code&gt; の型パラメータは、戻り値に関連している、と我々はそれに関係していません。 &lt;code&gt;spawn&lt;/code&gt; が &lt;code&gt;F&lt;/code&gt; にバインドされた特性として &lt;code&gt;FnOnce&lt;/code&gt; を使用していることがわかります。これはおそらく私たちが望んでいることでもあります。最終的には、 &lt;code&gt;execute&lt;/code&gt; で取得した引数を &lt;code&gt;spawn&lt;/code&gt; に渡すからです。私たちは、ことをさらに確信することができ &lt;code&gt;FnOnce&lt;/code&gt; は我々が要求を実行するためのスレッドが唯一の一致する要求の閉鎖1時間、実行されますので、使用したい形質である &lt;code&gt;Once&lt;/code&gt; で &lt;code&gt;FnOnce&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="2cc0c55739bb91f91d10f706c9cab70e100723e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Fn&lt;/code&gt; traits are provided by the standard library. All closures implement at least one of the traits: &lt;code&gt;Fn&lt;/code&gt;, &lt;code&gt;FnMut&lt;/code&gt;, or &lt;code&gt;FnOnce&lt;/code&gt;. We&amp;rsquo;ll discuss the difference between these traits in the &lt;a href=&quot;#capturing-the-environment-with-closures&quot;&gt;&amp;ldquo;Capturing the Environment with Closures&amp;rdquo;&lt;/a&gt; section; in this example, we can use the &lt;code&gt;Fn&lt;/code&gt; trait.</source>
          <target state="translated">&lt;code&gt;Fn&lt;/code&gt; 形質は、標準ライブラリで提供されています。すべてのクロージャーは、 &lt;code&gt;Fn&lt;/code&gt; 、 &lt;code&gt;FnMut&lt;/code&gt; 、または &lt;code&gt;FnOnce&lt;/code&gt; の少なくとも1つの特性を実装します。これらの特性の違いについては、&lt;a href=&quot;#capturing-the-environment-with-closures&quot;&gt;「クロージャーで環境をキャプチャする」&lt;/a&gt;セクションで説明します。この例では、 &lt;code&gt;Fn&lt;/code&gt; トレイトを使用できます。</target>
        </trans-unit>
        <trans-unit id="851722264534e1910cdc1ef4f424b4a4414f9688" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;From&lt;/code&gt; is also very useful when performing error handling. When constructing a function that is capable of failing, the return type will generally be of the form &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;. The &lt;code&gt;From&lt;/code&gt; trait simplifies error handling by allowing a function to return a single error type that encapsulate multiple error types. See the &quot;Examples&quot; section and &lt;a href=&quot;../../book/ch09-00-error-handling&quot;&gt;the book&lt;/a&gt; for more details.</source>
          <target state="translated">エラー処理を実行する際にも非常に便利です。失敗する可能性のある関数を作成する場合、戻り値の型は通常、 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 形式になります。機能は、複数のエラータイプをカプセル化する単一のエラー型を返すすることを可能にすることによって、形質簡素化エラー処理。詳細については、「例」セクションと&lt;a href=&quot;../../book/ch09-00-error-handling&quot;&gt;本&lt;/a&gt;を参照してください。 &lt;code&gt;From&lt;/code&gt; &lt;code&gt;From&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="924c96483cec1214b829647e918270a4c12cbe49" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GeneratorState&lt;/code&gt; enum returned from this function indicates what state the generator is in upon returning. If the &lt;code&gt;Yielded&lt;/code&gt; variant is returned then the generator has reached a suspension point and a value has been yielded out. Generators in this state are available for resumption at a later point.</source>
          <target state="translated">&lt;code&gt;GeneratorState&lt;/code&gt; のこの関数から返される列挙型は、発電機が戻る際にある状態かを示します。場合に &lt;code&gt;Yielded&lt;/code&gt; 変異体は、次に返されるジェネレータは、サスペンションポイントに達し、値がアウトもたらしてきました。この状態のジェネレーターは、後で再開できるようになります。</target>
        </trans-unit>
        <trans-unit id="93144a0b07feb0dfc814fce370a7ec1878fc8518" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GlobalAlloc&lt;/code&gt; trait is an &lt;code&gt;unsafe&lt;/code&gt; trait for a number of reasons, and implementors must ensure that they adhere to these contracts:</source>
          <target state="translated">&lt;code&gt;GlobalAlloc&lt;/code&gt; 特色ある &lt;code&gt;unsafe&lt;/code&gt; 多くの理由のために、形質、および実装者は、彼らがこれらの契約に準拠していることを確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="ac746bf118e800d6204d1b9be35a781fccfa8fc0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Hash&lt;/code&gt; trait allows you to take an instance of a type of arbitrary size and map that instance to a value of fixed size using a hash function. Deriving &lt;code&gt;Hash&lt;/code&gt; implements the &lt;code&gt;hash&lt;/code&gt; method. The derived implementation of the &lt;code&gt;hash&lt;/code&gt; method combines the result of calling &lt;code&gt;hash&lt;/code&gt; on each of the parts of the type, meaning all fields or values must also implement &lt;code&gt;Hash&lt;/code&gt; to derive &lt;code&gt;Hash&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Hash&lt;/code&gt; トレイトを使用すると、任意のサイズの型のインスタンスを取得し、ハッシュ関数を使用して、固定サイズの値にそのインスタンスをマッピングすることができます。派生 &lt;code&gt;Hash&lt;/code&gt; は、 &lt;code&gt;hash&lt;/code&gt; 方式を実装します。派生実装 &lt;code&gt;hash&lt;/code&gt; 法は、呼び出しの結果兼ね備えた &lt;code&gt;hash&lt;/code&gt; も実装しなければならないすべてのフィールドまたは値を意味し、タイプの各部分に &lt;code&gt;Hash&lt;/code&gt; 導出する &lt;code&gt;Hash&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc2c322c74118357f702bcbb43acd3519194cb4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Iterator&lt;/code&gt; trait has a number of different methods with default implementations provided by the standard library; you can find out about these methods by looking in the standard library API documentation for the &lt;code&gt;Iterator&lt;/code&gt; trait. Some of these methods call the &lt;code&gt;next&lt;/code&gt; method in their definition, which is why you&amp;rsquo;re required to implement the &lt;code&gt;next&lt;/code&gt; method when implementing the &lt;code&gt;Iterator&lt;/code&gt; trait.</source>
          <target state="translated">&lt;code&gt;Iterator&lt;/code&gt; 標準ライブラリによって提供されるデフォルトの実装を持つ多数の異なる方法を有する形質。これらのメソッドについては、 &lt;code&gt;Iterator&lt;/code&gt; トレイトの標準ライブラリAPIドキュメントをご覧ください。これらのメソッドの一部は、定義内の &lt;code&gt;next&lt;/code&gt; メソッドを呼び出します。そのため、 &lt;code&gt;Iterator&lt;/code&gt; トレイトを実装するときに &lt;code&gt;next&lt;/code&gt; メソッドを実装する必要があります。</target>
        </trans-unit>
        <trans-unit id="d7674b68a4f6af8a05d48508e05e8b51cf5d1646" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Iterator&lt;/code&gt; trait only requires implementors to define one method: the &lt;code&gt;next&lt;/code&gt; method, which returns one item of the iterator at a time wrapped in &lt;code&gt;Some&lt;/code&gt; and, when iteration is over, returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Iterator&lt;/code&gt; 1つのだけの方法を定義するために実装する必要がトレイト &lt;code&gt;next&lt;/code&gt; に包まれた時に、イテレータの一つのアイテムを返すメソッド、 &lt;code&gt;Some&lt;/code&gt; 反復が終わった時に返さないと、 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f9025083930c31cf7871ed20937306b52f26761a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LinkedList&lt;/code&gt; allows pushing and popping elements at either end in constant time.</source>
          <target state="translated">&lt;code&gt;LinkedList&lt;/code&gt; のは、一定の時間内にどちらかの端にある要素をプッシュしてポップできます。</target>
        </trans-unit>
        <trans-unit id="4baf38aed9bf1ffe36a931bbfb0cb77e6aa0a43b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LowerExp&lt;/code&gt; trait should format its output in scientific notation with a lower-case &lt;code&gt;e&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LowerExp&lt;/code&gt; の形質は小文字で科学的表記法でその出力をフォーマットする必要があり &lt;code&gt;e&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dc66d9062a365376bc4e9ff4cb202550c7cc32a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LowerHex&lt;/code&gt; trait should format its output as a number in hexadecimal, with &lt;code&gt;a&lt;/code&gt; through &lt;code&gt;f&lt;/code&gt; in lower case.</source>
          <target state="translated">&lt;code&gt;LowerHex&lt;/code&gt; の形質を用いて、16進数としての出力をフォーマットする必要がありスルー &lt;code&gt;f&lt;/code&gt; 小文字。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3b321c2a56af633f328bf4b8ba254ce361d7a954" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Octal&lt;/code&gt; trait should format its output as a number in base-8.</source>
          <target state="translated">&lt;code&gt;Octal&lt;/code&gt; 形質は、ベース8の数値として、その出力をフォーマットしなければなりません。</target>
        </trans-unit>
        <trans-unit id="eb10a578affd8a62e12f3ef265b344e167e3dcf6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; enum is so useful that it&amp;rsquo;s even included in the prelude; you don&amp;rsquo;t need to bring it into scope explicitly. In addition, so are its variants: you can use &lt;code&gt;Some&lt;/code&gt; and &lt;code&gt;None&lt;/code&gt; directly without the &lt;code&gt;Option::&lt;/code&gt; prefix. The &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; enum is still just a regular enum, and &lt;code&gt;Some(T)&lt;/code&gt; and &lt;code&gt;None&lt;/code&gt; are still variants of type &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 列挙型は、それがさえ前奏曲に含まれていることにとても便利です。明示的にスコープに入れる必要はありません。さらに、そのバリアントも同様です &lt;code&gt;Option::&lt;/code&gt; 接頭辞なしで、 &lt;code&gt;Some&lt;/code&gt; および &lt;code&gt;None&lt;/code&gt; を直接使用できます。 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 列挙型はまだ普通の列挙型であり、 &lt;code&gt;Some(T)&lt;/code&gt; と &lt;code&gt;None&lt;/code&gt; まだ型の変異体ではない &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="757a8b38147115f7267a95ffaa6fac00dcad6a55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Option&lt;/code&gt; type. See &lt;a href=&quot;index&quot;&gt;the module level documentation&lt;/a&gt; for more.</source>
          <target state="translated">&lt;code&gt;Option&lt;/code&gt; タイプ。詳細について&lt;a href=&quot;index&quot;&gt;は、モジュールレベルのドキュメント&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="6ec87aec96d36200bb49beb7ba67c5c626bb7aad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Ord&lt;/code&gt; trait allows you to know that for any two values of the annotated type, a valid ordering will exist. The &lt;code&gt;Ord&lt;/code&gt; trait implements the &lt;code&gt;cmp&lt;/code&gt; method, which returns an &lt;code&gt;Ordering&lt;/code&gt; rather than an &lt;code&gt;Option&amp;lt;Ordering&amp;gt;&lt;/code&gt; because a valid ordering will always be possible. You can only apply the &lt;code&gt;Ord&lt;/code&gt; trait to types that also implement &lt;code&gt;PartialOrd&lt;/code&gt; and &lt;code&gt;Eq&lt;/code&gt; (and &lt;code&gt;Eq&lt;/code&gt; requires &lt;code&gt;PartialEq&lt;/code&gt;). When derived on structs and enums, &lt;code&gt;cmp&lt;/code&gt; behaves the same way as the derived implementation for &lt;code&gt;partial_cmp&lt;/code&gt; does with &lt;code&gt;PartialOrd&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Ord&lt;/code&gt; 特性を使用すると、注釈付きのタイプのいずれか2つの値のために、有効な順序が存在することを知ることができます。 &lt;code&gt;Ord&lt;/code&gt; 実装に特色 &lt;code&gt;cmp&lt;/code&gt; 返すメソッド、 &lt;code&gt;Ordering&lt;/code&gt; するのではなく &lt;code&gt;Option&amp;lt;Ordering&amp;gt;&lt;/code&gt; 有効な順序が常に可能になりますので。 &lt;code&gt;Ord&lt;/code&gt; トレイトは、 &lt;code&gt;PartialOrd&lt;/code&gt; と &lt;code&gt;Eq&lt;/code&gt; も実装する型にのみ適用できます（ &lt;code&gt;Eq&lt;/code&gt; には &lt;code&gt;PartialEq&lt;/code&gt; が必要です）。構造体および列挙型で派生した場合、 &lt;code&gt;cmp&lt;/code&gt; は &lt;code&gt;PartialOrd&lt;/code&gt; での &lt;code&gt;partial_cmp&lt;/code&gt; の派生実装と同じように動作します。</target>
        </trans-unit>
        <trans-unit id="711a8eb9ad73721345ff8b7d5d49057eb05ba2c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Orphan Check&lt;/code&gt; states that every trait implementation must meet either of the following conditions:</source>
          <target state="translated">&lt;code&gt;Orphan Check&lt;/code&gt; すべての特性の実装は以下のいずれかの条件を満たさなければならないと述べました：</target>
        </trans-unit>
        <trans-unit id="c00d178bf6b2317cc12ea4871792b476ee2d6ac7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PartialEq&lt;/code&gt; trait allows you to compare instances of a type to check for equality and enables use of the &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; operators.</source>
          <target state="translated">&lt;code&gt;PartialEq&lt;/code&gt; トレイトを使用すると、等価性をチェックするために型のインスタンスを比較することができますし、使用可能 &lt;code&gt;==&lt;/code&gt; と &lt;code&gt;!=&lt;/code&gt; 演算子を。</target>
        </trans-unit>
        <trans-unit id="43e89dc3eb492904f3da074b02b2cf97b105430c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PartialEq&lt;/code&gt; trait is required, for example, with the use of the &lt;code&gt;assert_eq!&lt;/code&gt; macro, which needs to be able to compare two instances of a type for equality.</source>
          <target state="translated">&lt;code&gt;PartialEq&lt;/code&gt; の形質はを使用して、例えば、必要とされる &lt;code&gt;assert_eq!&lt;/code&gt; マクロ。型の2つのインスタンスが等しいかどうかを比較できる必要があります。</target>
        </trans-unit>
        <trans-unit id="a3b5763e3772b503d126748c966660daf7b02e86" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PartialOrd&lt;/code&gt; trait allows you to compare instances of a type for sorting purposes. A type that implements &lt;code&gt;PartialOrd&lt;/code&gt; can be used with the &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, and &lt;code&gt;&amp;gt;=&lt;/code&gt; operators. You can only apply the &lt;code&gt;PartialOrd&lt;/code&gt; trait to types that also implement &lt;code&gt;PartialEq&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;PartialOrd&lt;/code&gt; の特性を使用すると、ソートするために型のインスタンスを比較することができます。 &lt;code&gt;PartialOrd&lt;/code&gt; を実装する型は、 &lt;code&gt;&amp;lt;&lt;/code&gt; 、 &lt;code&gt;&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;=&lt;/code&gt; 、および &lt;code&gt;&amp;gt;=&lt;/code&gt; 演算子で使用できます。あなただけ適用することができます &lt;code&gt;PartialOrd&lt;/code&gt; のも実装する型に形質を &lt;code&gt;PartialEq&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="d44604638bc3e14fe0790aae9645322a35831c38" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PartialOrd&lt;/code&gt; trait is required, for example, for the &lt;code&gt;gen_range&lt;/code&gt; method from the &lt;code&gt;rand&lt;/code&gt; crate that generates a random value in the range specified by a low value and a high value.</source>
          <target state="translated">&lt;code&gt;PartialOrd&lt;/code&gt; の形質がため、例えば、必要とされる &lt;code&gt;gen_range&lt;/code&gt; のから方法 &lt;code&gt;rand&lt;/code&gt; 低い値と高い値で指定された範囲内のランダム値を生成するクレート。</target>
        </trans-unit>
        <trans-unit id="aa9b33d349ddf99a4aba8a405103bf7fb4c6e253" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Pointer&lt;/code&gt; trait should format its output as a memory location. This is commonly presented as hexadecimal.</source>
          <target state="translated">&lt;code&gt;Pointer&lt;/code&gt; 形質はメモリ場所としてその出力をフォーマットしなければなりません。これは通常、16進数として表示されます。</target>
        </trans-unit>
        <trans-unit id="ab8bbad2b08fc48ec0e5ed2730d22da62501a267" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Range&lt;/code&gt;&lt;code&gt;start..end&lt;/code&gt; contains all values with &lt;code&gt;x &amp;gt;= start&lt;/code&gt; and &lt;code&gt;x &amp;lt; end&lt;/code&gt;. It is empty unless &lt;code&gt;start &amp;lt; end&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Range&lt;/code&gt; &lt;code&gt;start..end&lt;/code&gt; を持つすべての値が含まれ &lt;code&gt;x &amp;gt;= start&lt;/code&gt; および &lt;code&gt;x &amp;lt; end&lt;/code&gt; 。 &lt;code&gt;start &amp;lt; end&lt;/code&gt; ない限り、空です。</target>
        </trans-unit>
        <trans-unit id="b2aa0761be84214baf72bdc665e4aaa54d88ab96" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RangeFrom&lt;/code&gt;&lt;code&gt;start..&lt;/code&gt; contains all values with &lt;code&gt;x &amp;gt;= start&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;RangeFrom&lt;/code&gt; は &lt;code&gt;start..&lt;/code&gt; とすべての値が含まれている &lt;code&gt;x &amp;gt;= start&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="73c149dd90366bce823890f694cf867f1bb0a225" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RangeInclusive&lt;/code&gt;&lt;code&gt;start..=end&lt;/code&gt; contains all values with &lt;code&gt;x &amp;gt;= start&lt;/code&gt; and &lt;code&gt;x &amp;lt;= end&lt;/code&gt;. It is empty unless &lt;code&gt;start &amp;lt;= end&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;RangeInclusive&lt;/code&gt; &lt;code&gt;start..=end&lt;/code&gt; 持つすべての値が含まれ &lt;code&gt;x &amp;gt;= start&lt;/code&gt; および &lt;code&gt;x &amp;lt;= end&lt;/code&gt; 。 &lt;code&gt;start &amp;lt;= end&lt;/code&gt; ない限り、空です。</target>
        </trans-unit>
        <trans-unit id="0cec61b7c44a745e689ab10fff029089cd54c5d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RangeTo&lt;/code&gt;&lt;code&gt;..end&lt;/code&gt; contains all values with &lt;code&gt;x &amp;lt; end&lt;/code&gt;. It cannot serve as an &lt;a href=&quot;../iter/trait.intoiterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; because it doesn't have a starting point.</source>
          <target state="translated">&lt;code&gt;RangeTo&lt;/code&gt; の &lt;code&gt;..end&lt;/code&gt; を持つすべての値が含まれ &lt;code&gt;x &amp;lt; end&lt;/code&gt; 。開始点がないため、&lt;a href=&quot;../iter/trait.intoiterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;として機能できません。</target>
        </trans-unit>
        <trans-unit id="0de78a1c773797166ef937a052ccd5e9331c867f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RangeTo&lt;/code&gt;&lt;code&gt;..end&lt;/code&gt; contains all values with &lt;code&gt;x &amp;lt; end&lt;/code&gt;. It cannot serve as an &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; because it doesn't have a starting point.</source>
          <target state="translated">&lt;code&gt;RangeTo&lt;/code&gt; の &lt;code&gt;..end&lt;/code&gt; を持つすべての値が含まれ &lt;code&gt;x &amp;lt; end&lt;/code&gt; 。開始点がないため、&lt;a href=&quot;../iter/trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;として機能することはできません。</target>
        </trans-unit>
        <trans-unit id="8e2d4326e8450b1f620c09e80702de680708776b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RangeToInclusive&lt;/code&gt;&lt;code&gt;..=end&lt;/code&gt; contains all values with &lt;code&gt;x &amp;lt;= end&lt;/code&gt;. It cannot serve as an &lt;a href=&quot;../iter/trait.intoiterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; because it doesn't have a starting point.</source>
          <target state="translated">&lt;code&gt;RangeToInclusive&lt;/code&gt; &lt;code&gt;..=end&lt;/code&gt; 持つすべての値が含まれている &lt;code&gt;x &amp;lt;= end&lt;/code&gt; 。開始点がないため、&lt;a href=&quot;../iter/trait.intoiterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;として機能できません。</target>
        </trans-unit>
        <trans-unit id="0729997e88bb0119e0af233dfbcdefc61396cf4d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RangeToInclusive&lt;/code&gt;&lt;code&gt;..=end&lt;/code&gt; contains all values with &lt;code&gt;x &amp;lt;= end&lt;/code&gt;. It cannot serve as an &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; because it doesn't have a starting point.</source>
          <target state="translated">&lt;code&gt;RangeToInclusive&lt;/code&gt; &lt;code&gt;..=end&lt;/code&gt; 持つすべての値が含まれている &lt;code&gt;x &amp;lt;= end&lt;/code&gt; 。開始点がないため、&lt;a href=&quot;../iter/trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;として機能することはできません。</target>
        </trans-unit>
        <trans-unit id="ebdc80637c460a3fe51040149db057ee546f653a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Rc::clone(&amp;amp;from)&lt;/code&gt; syntax is the most idiomatic because it conveys more explicitly the meaning of the code. In the example above, this syntax makes it easier to see that this code is creating a new reference rather than copying the whole content of foo.</source>
          <target state="translated">&lt;code&gt;Rc::clone(&amp;amp;from)&lt;/code&gt; 、それがより明確にコードの意味を伝えるための構文は、最も慣用的です。上記の例では、この構文により、このコードがfooのコンテンツ全体をコピーするのではなく、新しい参照を作成していることが簡単にわかります。</target>
        </trans-unit>
        <trans-unit id="d18566a4555f118c35b2f7296c41294a80e62f05" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Read&lt;/code&gt; trait allows for reading bytes from a source.</source>
          <target state="translated">&lt;code&gt;Read&lt;/code&gt; トレイトは、ソースからバイトを読み込むすることができます。</target>
        </trans-unit>
        <trans-unit id="167de79249a0cb690644cc2f30f26fd674ac84c4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; keeps track of how many &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt; smart pointers are currently active. Every time we call &lt;code&gt;borrow&lt;/code&gt;, the &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; increases its count of how many immutable borrows are active. When a &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt; value goes out of scope, the count of immutable borrows goes down by one. Just like the compile-time borrowing rules, &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; lets us have many immutable borrows or one mutable borrow at any point in time.</source>
          <target state="translated">&lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; を追跡しますどのように多く &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt; と &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt; スマートポインタが現在アクティブです。 &lt;code&gt;borrow&lt;/code&gt; を呼び出すたびに、 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; は、アクティブな不変のボローの数を増やします。ときに &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt; 値がスコープ外になる、不変借りのカウントが1でダウンしました。コンパイル時の借用ルールと &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 、RefCell &amp;lt;T&amp;gt;を使用すると、いつでも多くの不変な借用または1つの変更可能な借用を行うことができます。</target>
        </trans-unit>
        <trans-unit id="2e6771afd6b14e03fc38f6d16106ee1f97bd4cbd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RefCell&lt;/code&gt; is already immutably borrowed, so this cannot fail.</source>
          <target state="translated">&lt;code&gt;RefCell&lt;/code&gt; はすでにimmutably借りているので、これは失敗することはできません。</target>
        </trans-unit>
        <trans-unit id="c305974ea6149ae71e2c43fcd219e993594dd96e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RefCell&lt;/code&gt; is already mutably borrowed, so this cannot fail.</source>
          <target state="translated">&lt;code&gt;RefCell&lt;/code&gt; はすでにmutably借りているので、これは失敗することはできません。</target>
        </trans-unit>
        <trans-unit id="52b1edfc20b8e3433cc429a2a34dab08626e2ce2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Result&amp;lt;..., Error&amp;gt;&lt;/code&gt; is repeated a lot. As such, &lt;code&gt;std::io&lt;/code&gt; has this type of alias declaration:</source>
          <target state="translated">&lt;code&gt;Result&amp;lt;..., Error&amp;gt;&lt;/code&gt; 多くのことを繰り返しています。そのため、 &lt;code&gt;std::io&lt;/code&gt; は次のタイプのエイリアス宣言があります。</target>
        </trans-unit>
        <trans-unit id="1e71572578c618ddeccc701e84d14574b4552896" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Result&lt;/code&gt; enum is generic over two types, &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;E&lt;/code&gt;, and has two variants: &lt;code&gt;Ok&lt;/code&gt;, which holds a value of type &lt;code&gt;T&lt;/code&gt;, and &lt;code&gt;Err&lt;/code&gt;, which holds a value of type &lt;code&gt;E&lt;/code&gt;. This definition makes it convenient to use the &lt;code&gt;Result&lt;/code&gt; enum anywhere we have an operation that might succeed (return a value of some type &lt;code&gt;T&lt;/code&gt;) or fail (return an error of some type &lt;code&gt;E&lt;/code&gt;). In fact, this is what we used to open a file in Listing 9-3, where &lt;code&gt;T&lt;/code&gt; was filled in with the type &lt;code&gt;std::fs::File&lt;/code&gt; when the file was opened successfully and &lt;code&gt;E&lt;/code&gt; was filled in with the type &lt;code&gt;std::io::Error&lt;/code&gt; when there were problems opening the file.</source>
          <target state="translated">&lt;code&gt;Result&lt;/code&gt; 列挙型の2種類、オーバー総称である &lt;code&gt;T&lt;/code&gt; と &lt;code&gt;E&lt;/code&gt; 、および2つのバリエーションがあります。 &lt;code&gt;Ok&lt;/code&gt; 型の値を保持、 &lt;code&gt;T&lt;/code&gt; 、および &lt;code&gt;Err&lt;/code&gt; 型の値を保持し、 &lt;code&gt;E&lt;/code&gt; を。この定義により、成功（ &lt;code&gt;T&lt;/code&gt; 型の値を返す）または失敗（ &lt;code&gt;E&lt;/code&gt; 型のエラーを返す）できる操作がある場合は、どこでも &lt;code&gt;Result&lt;/code&gt; enum を使用するのが便利になります。実際、これはリスト9-3でファイルを開くために使用したものです。ファイルが正常に開かれたときに &lt;code&gt;T&lt;/code&gt; に &lt;code&gt;std::fs::File&lt;/code&gt; タイプが入力され、 &lt;code&gt;E&lt;/code&gt; タイプ &lt;code&gt;std::io::Error&lt;/code&gt; が入力されましたが、ファイルを開くときに問題が発生しました。</target>
        </trans-unit>
        <trans-unit id="67d17ec2155cc71f4cbd159b4631b04d17855080" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Result&lt;/code&gt; types are &lt;a href=&quot;ch06-00-enums&quot;&gt;&lt;em&gt;enumerations&lt;/em&gt;&lt;/a&gt;, often referred to as &lt;em&gt;enums&lt;/em&gt;. An enumeration is a type that can have a fixed set of values, and those values are called the enum&amp;rsquo;s &lt;em&gt;variants&lt;/em&gt;. Chapter 6 will cover enums in more detail.</source>
          <target state="translated">&lt;code&gt;Result&lt;/code&gt; タイプがあります&lt;a href=&quot;ch06-00-enums&quot;&gt;&lt;em&gt;列挙型&lt;/em&gt;&lt;/a&gt;が多いと呼ばれる、&lt;em&gt;列挙型&lt;/em&gt;。列挙型は、固定された値のセットを持つことができるタイプであり、それらの値は列挙型の&lt;em&gt;バリアント&lt;/em&gt;と呼ばれ&lt;em&gt;ます&lt;/em&gt;。第6章では、列挙型についてさらに詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="64d4c779a9a53da0609d26369514238e751f0a8e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Seek&lt;/code&gt; trait provides a cursor which can be moved within a stream of bytes.</source>
          <target state="translated">&lt;code&gt;Seek&lt;/code&gt; 形質はバイトストリーム内で移動することができるカーソルを提供します。</target>
        </trans-unit>
        <trans-unit id="45132395a8da1a9af17f15db9b29d073d0c74c5d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Self&lt;/code&gt; keyword is an alias for the type we&amp;rsquo;re implementing the traits or methods on. Trait objects must be object safe because once you&amp;rsquo;ve used a trait object, Rust no longer knows the concrete type that&amp;rsquo;s implementing that trait. If a trait method returns the concrete &lt;code&gt;Self&lt;/code&gt; type, but a trait object forgets the exact type that &lt;code&gt;Self&lt;/code&gt; is, there is no way the method can use the original concrete type. The same is true of generic type parameters that are filled in with concrete type parameters when the trait is used: the concrete types become part of the type that implements the trait. When the type is forgotten through the use of a trait object, there is no way to know what types to fill in the generic type parameters with.</source>
          <target state="translated">&lt;code&gt;Self&lt;/code&gt; キーワードは、我々は上の特性やメソッドを実装しているタイプの別名です。いったんトレイトオブジェクトを使用すると、Rustはそのトレイトを実装している具象型を認識できなくなるため、トレイトオブジェクトはオブジェクトセーフである必要があります。トレイトメソッドが具体的な &lt;code&gt;Self&lt;/code&gt; タイプを返すが、トレイトオブジェクトが &lt;code&gt;Self&lt;/code&gt; の正確なタイプを忘れた場合、メソッドが元の具体的なタイプを使用する方法はありません。特性が使用されるときに具象型パラメーターで埋められるジェネリック型パラメーターにも同じことが当てはまります。具象型は、特性を実装する型の一部になります。特性オブジェクトを使用して型を忘れた場合、ジェネリック型パラメーターに入力する型を知る方法はありません。</target>
        </trans-unit>
        <trans-unit id="90a76b71efb75f391d26231783f81feb6c797a7f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Self&lt;/code&gt; keyword represents the current type, which explains why it can only be used inside an impl, trait, or type definition. It gives access to the associated items of a type:</source>
          <target state="translated">&lt;code&gt;Self&lt;/code&gt; キーワードは、それが唯一のimpl、特性、または型定義の内部で使用することができる理由を説明し、現在のタイプを表します。タイプの関連アイテムへのアクセスを提供します。</target>
        </trans-unit>
        <trans-unit id="a02332e854d71300403fa93482ff8605d97eadb6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Self&lt;/code&gt; keyword was used outside an impl, trait, or type definition.</source>
          <target state="translated">&lt;code&gt;Self&lt;/code&gt; キーワードはIMPL、特性、または型定義外で使用されました。</target>
        </trans-unit>
        <trans-unit id="6a3c6ecd1deb9539342b4b667c8f7da5207114d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Self&lt;/code&gt; term can be replaced with the type being implemented.</source>
          <target state="translated">&lt;code&gt;Self&lt;/code&gt; 用語は、型が実装されていると交換することができます。</target>
        </trans-unit>
        <trans-unit id="268068ec98ee8d589f1d0d25a4fa87cb52fefae1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Self&lt;/code&gt; terminal in this grammar denotes a type resolving to the implementing type. This can also include the contextual type alias &lt;code&gt;Self&lt;/code&gt;, other type aliases, or associated type projections resolving to the implementing type.</source>
          <target state="translated">この文法の &lt;code&gt;Self&lt;/code&gt; ターミナルは、実装タイプに解決されるタイプを示します。これには、コンテキストタイプエイリアス &lt;code&gt;Self&lt;/code&gt; 、他のタイプエイリアス、または実装タイプに解決される関連タイププロジェクションを含めることもできます。</target>
        </trans-unit>
        <trans-unit id="5d50619fe26b234beecf764a55ec164440b77b3f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Send&lt;/code&gt; marker trait indicates that ownership of the type implementing &lt;code&gt;Send&lt;/code&gt; can be transferred between threads. Almost every Rust type is &lt;code&gt;Send&lt;/code&gt;, but there are some exceptions, including &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;: this cannot be &lt;code&gt;Send&lt;/code&gt; because if you cloned an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; value and tried to transfer ownership of the clone to another thread, both threads might update the reference count at the same time. For this reason, &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; is implemented for use in single-threaded situations where you don&amp;rsquo;t want to pay the thread-safe performance penalty.</source>
          <target state="translated">&lt;code&gt;Send&lt;/code&gt; タイプ実装の所有権を示し形質マーカー &lt;code&gt;Send&lt;/code&gt; スレッド間で転送することができます。ほぼすべての錆タイプがされて &lt;code&gt;Send&lt;/code&gt; ますが、を含むいくつかの例外がある &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; ：これはできません &lt;code&gt;Send&lt;/code&gt; ますが、クローン化された場合ので、 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 値と別のスレッドへのクローンの転送所有しようとしたが、両方のスレッドが更新かもしれません同時に参照カウント。このため、 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; は、スレッドセーフなパフォーマンスのペナルティを支払う必要がないシングルスレッドの状況で使用するために実装されています。</target>
        </trans-unit>
        <trans-unit id="da7504f8cf4ba12a9f166abe295fe49d0cc29f7f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Sized&lt;/code&gt; trait is a special trait built-in to the compiler for types with a constant size known at compile-time. This trait is automatically implemented for types as needed by the compiler, and it is currently disallowed to explicitly implement it for a type.</source>
          <target state="translated">&lt;code&gt;Sized&lt;/code&gt; 特色は、ビルトインタイプのためのコンパイラにコンパイル時に知られている一定の大きさで、特別な形質です。この特性は、コンパイラによって必要に応じて型に対して自動的に実装されます。現在、型に対して明示的に実装することは許可されていません。</target>
        </trans-unit>
        <trans-unit id="faed9283b4f09789ea3439cf47c62be8b01765b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Sized&lt;/code&gt; trait was implemented explicitly.</source>
          <target state="translated">&lt;code&gt;Sized&lt;/code&gt; 特徴は、明示的に実装されました。</target>
        </trans-unit>
        <trans-unit id="57ed07b6ec3a8248f3dbedbfe819f564dab9a89c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Some(5)&lt;/code&gt; value doesn&amp;rsquo;t match the pattern &lt;code&gt;None&lt;/code&gt;, so we continue to the next arm.</source>
          <target state="translated">&lt;code&gt;Some(5)&lt;/code&gt; 値は、パターンと一致しません &lt;code&gt;None&lt;/code&gt; 、我々は次の腕に続けて、。</target>
        </trans-unit>
        <trans-unit id="5cf7d1bcd1b02d8684f384aeb150bd3c1fada36f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;State&lt;/code&gt; trait defines the behavior shared by different post states, and the &lt;code&gt;Draft&lt;/code&gt;, &lt;code&gt;PendingReview&lt;/code&gt;, and &lt;code&gt;Published&lt;/code&gt; states will all implement the &lt;code&gt;State&lt;/code&gt; trait. For now, the trait doesn&amp;rsquo;t have any methods, and we&amp;rsquo;ll start by defining just the &lt;code&gt;Draft&lt;/code&gt; state because that is the state we want a post to start in.</source>
          <target state="translated">&lt;code&gt;State&lt;/code&gt; 特色は、異なるポスト状態で共有する動作を定義し、 &lt;code&gt;Draft&lt;/code&gt; 、 &lt;code&gt;PendingReview&lt;/code&gt; 、および &lt;code&gt;Published&lt;/code&gt; 状態がすべて実装する &lt;code&gt;State&lt;/code&gt; 形質を。今のところ、トレイトにはメソッドがありません。投稿を開始する状態であるため、 &lt;code&gt;Draft&lt;/code&gt; 状態のみを定義することから始めます。</target>
        </trans-unit>
        <trans-unit id="a99c80ac2ff235e2978574f670cbd4660bb61703" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;String&lt;/code&gt; type implements the &lt;code&gt;Clone&lt;/code&gt; trait, and when we call the &lt;code&gt;clone&lt;/code&gt; method on an instance of &lt;code&gt;String&lt;/code&gt; we get back an instance of &lt;code&gt;String&lt;/code&gt;. Similarly, if we call &lt;code&gt;clone&lt;/code&gt; on an instance of &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, we get back an instance of &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;. The signature of &lt;code&gt;clone&lt;/code&gt; needs to know what type will stand in for &lt;code&gt;Self&lt;/code&gt;, because that&amp;rsquo;s the return type.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 型実装 &lt;code&gt;Clone&lt;/code&gt; 特性、そして私たちが呼ぶ &lt;code&gt;clone&lt;/code&gt; のインスタンス上のメソッド &lt;code&gt;String&lt;/code&gt; 我々はのインスタンス取り戻す &lt;code&gt;String&lt;/code&gt; 。私たちが呼ぶならば同様に、 &lt;code&gt;clone&lt;/code&gt; のインスタンスに &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 、我々はのインスタンス取り戻す &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 。 &lt;code&gt;clone&lt;/code&gt; のシグネチャは、 &lt;code&gt;Self&lt;/code&gt; の代わりになるタイプを知る必要があります。これは、それが戻り値のタイプだからです。</target>
        </trans-unit>
        <trans-unit id="ce3a0f98cdb5c97fe7ff53bab286ef96b0a0614f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;String&lt;/code&gt; type is the most common string type that has ownership over the contents of the string. It has a close relationship with its borrowed counterpart, the primitive &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; タイプは、文字列の内容以上の所有権を持っている最も一般的な文字列型です。これは、借用した対応するプリミティブ&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt;と密接な関係があります。</target>
        </trans-unit>
        <trans-unit id="75cb7ba1e6deab5f4a0c4ef1dddcb7ea6d8d2520" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;String&lt;/code&gt; type, which is provided by Rust&amp;rsquo;s standard library rather than coded into the core language, is a growable, mutable, owned, UTF-8 encoded string type. When Rustaceans refer to &amp;ldquo;strings&amp;rdquo; in Rust, they usually mean the &lt;code&gt;String&lt;/code&gt; and the string slice &lt;code&gt;&amp;amp;str&lt;/code&gt; types, not just one of those types. Although this section is largely about &lt;code&gt;String&lt;/code&gt;, both types are used heavily in Rust&amp;rsquo;s standard library, and both &lt;code&gt;String&lt;/code&gt; and string slices are UTF-8 encoded.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; コア言語に錆の標準ライブラリによって提供されるよりもむしろ符号化されたタイプは、拡張可能な、変更可能な、所有、UTF-8でエンコードされた文字列型です。RustaceansがRustで「文字列」を参照する場合、それらは通常、 &lt;code&gt;String&lt;/code&gt; と文字列スライスの &lt;code&gt;&amp;amp;str&lt;/code&gt; タイプであり、これらのタイプの1つだけではありません。このセクションでは主に &lt;code&gt;String&lt;/code&gt; について説明していますが、どちらのタイプもRustの標準ライブラリで頻繁に使用されており、 &lt;code&gt;String&lt;/code&gt; とstringスライスの両方がUTF-8でエンコードされています。</target>
        </trans-unit>
        <trans-unit id="e2f29f1c300ba36b21c6a01062d991f47ee83fd6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Sync&lt;/code&gt; and &lt;code&gt;Send&lt;/code&gt; traits, which extend Rust&amp;rsquo;s concurrency guarantees to user-defined types as well as types provided by the standard library</source>
          <target state="translated">&lt;code&gt;Sync&lt;/code&gt; と &lt;code&gt;Send&lt;/code&gt; の標準ライブラリで提供されたユーザー定義型などのタイプに錆の同時実行性の保証を拡張する特性、</target>
        </trans-unit>
        <trans-unit id="546dfd59f5dde2a2d3bad5396a6d76cbe9696aee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Sync&lt;/code&gt; marker trait indicates that it is safe for the type implementing &lt;code&gt;Sync&lt;/code&gt; to be referenced from multiple threads. In other words, any type &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Sync&lt;/code&gt; if &lt;code&gt;&amp;amp;T&lt;/code&gt; (a reference to &lt;code&gt;T&lt;/code&gt;) is &lt;code&gt;Send&lt;/code&gt;, meaning the reference can be sent safely to another thread. Similar to &lt;code&gt;Send&lt;/code&gt;, primitive types are &lt;code&gt;Sync&lt;/code&gt;, and types composed entirely of types that are &lt;code&gt;Sync&lt;/code&gt; are also &lt;code&gt;Sync&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Sync&lt;/code&gt; マーカ特徴は、それが実装タイプのために安全であることを示している &lt;code&gt;Sync&lt;/code&gt; を複数のスレッドから参照されます。つまり、 &lt;code&gt;&amp;amp;T&lt;/code&gt; （ &lt;code&gt;T&lt;/code&gt; への参照）が &lt;code&gt;Send&lt;/code&gt; の場合、タイプ &lt;code&gt;T&lt;/code&gt; はすべて &lt;code&gt;Sync&lt;/code&gt; です。つまり、参照を別のスレッドに安全に送信できます。同様に &lt;code&gt;Send&lt;/code&gt; 、原始的な種類があり &lt;code&gt;Sync&lt;/code&gt; 、および完全にされている種類で構成されるタイプの &lt;code&gt;Sync&lt;/code&gt; またある &lt;code&gt;Sync&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="646e9a46a3198e5aae6cea0647712ac157d7125f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;E&lt;/code&gt; are generic type parameters: we&amp;rsquo;ll discuss generics in more detail in Chapter 10. What you need to know right now is that &lt;code&gt;T&lt;/code&gt; represents the type of the value that will be returned in a success case within the &lt;code&gt;Ok&lt;/code&gt; variant, and &lt;code&gt;E&lt;/code&gt; represents the type of the error that will be returned in a failure case within the &lt;code&gt;Err&lt;/code&gt; variant. Because &lt;code&gt;Result&lt;/code&gt; has these generic type parameters, we can use the &lt;code&gt;Result&lt;/code&gt; type and the functions that the standard library has defined on it in many different situations where the successful value and error value we want to return may differ.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; と &lt;code&gt;E&lt;/code&gt; は、ジェネリック型パラメータです：私たちは、あなたが今知っている必要がありますどのような第10章でより詳細にジェネリックを説明しますということである &lt;code&gt;T&lt;/code&gt; は、内の成功事例に返される値の型を表す &lt;code&gt;Ok&lt;/code&gt; 、バリアントをそして &lt;code&gt;E&lt;/code&gt; は、内故障の場合に返されるエラーの種類を表し &lt;code&gt;Err&lt;/code&gt; バリアント。ので &lt;code&gt;Result&lt;/code&gt; これらのジェネリック型パラメータを持って、我々は使用することができる &lt;code&gt;Result&lt;/code&gt; 標準ライブラリは、我々は返すようにしたい成功した値との誤差値が異なる可能性があり、多くの異なる状況で、それに定義されていることをタイプと機能を。</target>
        </trans-unit>
        <trans-unit id="cb756122c49feafba4692e36792c9ec503818ac1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Thread&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;Thread&lt;/code&gt; タイプ</target>
        </trans-unit>
        <trans-unit id="fadb7c71117e778367444a0d18f0442e8249124b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ThreadPool&lt;/code&gt; will create a channel and hold on to the sending side of the channel.</source>
          <target state="translated">&lt;code&gt;ThreadPool&lt;/code&gt; のは、チャンネルを作成して、チャネルの送信側を保持します。</target>
        </trans-unit>
        <trans-unit id="e48c39ae08cbb88aef00b305b9017512b2fc007b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UnsafeCell&lt;/code&gt; API itself is technically very simple: &lt;a href=&quot;struct.unsafecell#method.get&quot;&gt;&lt;code&gt;.get()&lt;/code&gt;&lt;/a&gt; gives you a raw pointer &lt;code&gt;*mut T&lt;/code&gt; to its contents. It is up to &lt;em&gt;you&lt;/em&gt; as the abstraction designer to use that raw pointer correctly.</source>
          <target state="translated">&lt;code&gt;UnsafeCell&lt;/code&gt; のAPI自体は技術的に非常に単純です：&lt;a href=&quot;struct.unsafecell#method.get&quot;&gt; &lt;code&gt;.get()&lt;/code&gt; &lt;/a&gt;あなたの生のポインタを与える &lt;code&gt;*mut T&lt;/code&gt; その内容に。それは、最大である&lt;em&gt;あなた&lt;/em&gt;が正しくその生のポインタを使用するように抽象化デザイナーとして。</target>
        </trans-unit>
        <trans-unit id="6a5cd0207b32d758dbbf9a6159c66155c77acce0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UnsafeCell&lt;/code&gt; API itself is technically very simple: it gives you a raw pointer &lt;code&gt;*mut T&lt;/code&gt; to its contents. It is up to &lt;em&gt;you&lt;/em&gt; as the abstraction designer to use that raw pointer correctly.</source>
          <target state="translated">&lt;code&gt;UnsafeCell&lt;/code&gt; の API自体は技術的に非常に単純です：それはあなたの生のポインタを与える &lt;code&gt;*mut T&lt;/code&gt; その内容に。生のポインタを正しく使用する&lt;em&gt;かどうか&lt;/em&gt;は、抽象デザイナーの責任です。</target>
        </trans-unit>
        <trans-unit id="0a41c6aadefabb63fa74ac6fccd4136ec47ca08f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UpperExp&lt;/code&gt; trait should format its output in scientific notation with an upper-case &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;UpperExp&lt;/code&gt; の形質は、大文字と科学的表記法でその出力をフォーマットしなければならない &lt;code&gt;E&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c532f0150ba601cb070b0fc006c6b873d809aeda" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UpperHex&lt;/code&gt; trait should format its output as a number in hexadecimal, with &lt;code&gt;A&lt;/code&gt; through &lt;code&gt;F&lt;/code&gt; in upper case.</source>
          <target state="translated">&lt;code&gt;UpperHex&lt;/code&gt; の形質を持つ16進数としての出力、フォーマットする必要があり &lt;code&gt;A&lt;/code&gt; を介して &lt;code&gt;F&lt;/code&gt; を大文字で。</target>
        </trans-unit>
        <trans-unit id="1692dc51a2dd0859a66b3a15d1e8df4859265ffa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Vec&lt;/code&gt; type allows to access values by index, because it implements the &lt;a href=&quot;../ops/trait.index&quot;&gt;&lt;code&gt;Index&lt;/code&gt;&lt;/a&gt; trait. An example will be more explicit:</source>
          <target state="translated">&lt;code&gt;Vec&lt;/code&gt; をする、それが実装しているため種類は、インデックスによるアクセス値にできます&lt;a href=&quot;../ops/trait.index&quot;&gt; &lt;code&gt;Index&lt;/code&gt; &lt;/a&gt;形質を。例はより明確になります：</target>
        </trans-unit>
        <trans-unit id="fdf15f1d79f5be8a81ff6d7d469c446ffbe09215" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;_&lt;/code&gt; pattern will match any value. By putting it after our other arms, the &lt;code&gt;_&lt;/code&gt; will match all the possible cases that aren&amp;rsquo;t specified before it. The &lt;code&gt;()&lt;/code&gt; is just the unit value, so nothing will happen in the &lt;code&gt;_&lt;/code&gt; case. As a result, we can say that we want to do nothing for all the possible values that we don&amp;rsquo;t list before the &lt;code&gt;_&lt;/code&gt; placeholder.</source>
          <target state="translated">&lt;code&gt;_&lt;/code&gt; パターンは任意の値と一致します。他の武器の後に置くことで、 &lt;code&gt;_&lt;/code&gt; はその前に指定されていないすべての可能なケースに一致します。 &lt;code&gt;()&lt;/code&gt; 何もして起こりませんので、ちょうど単位の値である &lt;code&gt;_&lt;/code&gt; ケース。その結果、 &lt;code&gt;_&lt;/code&gt; プレースホルダーの前にリストされていない可能性のあるすべての値に対しては何もしたくないと言えます。</target>
        </trans-unit>
        <trans-unit id="d4f623218e4e907b6db896a6ba8ba2e0737f6051" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;abort&lt;/code&gt; function terminates the process, so the destructor will not get run on the example below:</source>
          <target state="translated">&lt;code&gt;abort&lt;/code&gt; 機能は、処理を終了するので、デストラクタは、以下の例で実行し得ることはありません。</target>
        </trans-unit>
        <trans-unit id="1da31d2d7b88dbadae1ea02224cc02bf279c6b4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;add&lt;/code&gt; method adds the &lt;code&gt;x&lt;/code&gt; values of two &lt;code&gt;Point&lt;/code&gt; instances and the &lt;code&gt;y&lt;/code&gt; values of two &lt;code&gt;Point&lt;/code&gt; instances to create a new &lt;code&gt;Point&lt;/code&gt;. The &lt;code&gt;Add&lt;/code&gt; trait has an associated type named &lt;code&gt;Output&lt;/code&gt; that determines the type returned from the &lt;code&gt;add&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;add&lt;/code&gt; 方法は、追加 &lt;code&gt;x&lt;/code&gt; 2つの値 &lt;code&gt;Point&lt;/code&gt; インスタンスと &lt;code&gt;y&lt;/code&gt; の 2つの値 &lt;code&gt;Point&lt;/code&gt; 新しい作成するために、インスタンスを &lt;code&gt;Point&lt;/code&gt; 。 &lt;code&gt;Add&lt;/code&gt; 形質が名前の関連するタイプがある &lt;code&gt;Output&lt;/code&gt; から返される型を決定する &lt;code&gt;add&lt;/code&gt; 方法を。</target>
        </trans-unit>
        <trans-unit id="6b4f66cfe4d8578da648c05ce2a1d295046eb19d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;add_text&lt;/code&gt; method takes a mutable reference to &lt;code&gt;self&lt;/code&gt;, because we&amp;rsquo;re changing the &lt;code&gt;Post&lt;/code&gt; instance that we&amp;rsquo;re calling &lt;code&gt;add_text&lt;/code&gt; on. We then call &lt;code&gt;push_str&lt;/code&gt; on the &lt;code&gt;String&lt;/code&gt; in &lt;code&gt;content&lt;/code&gt; and pass the &lt;code&gt;text&lt;/code&gt; argument to add to the saved &lt;code&gt;content&lt;/code&gt;. This behavior doesn&amp;rsquo;t depend on the state the post is in, so it&amp;rsquo;s not part of the state pattern. The &lt;code&gt;add_text&lt;/code&gt; method doesn&amp;rsquo;t interact with the &lt;code&gt;state&lt;/code&gt; field at all, but it is part of the behavior we want to support.</source>
          <target state="translated">&lt;code&gt;add_text&lt;/code&gt; の方法は、への変更可能な参照取る &lt;code&gt;self&lt;/code&gt; 我々が変更しているので、 &lt;code&gt;Post&lt;/code&gt; 我々が呼んでいるというインスタンスを &lt;code&gt;add_text&lt;/code&gt; を上。次に、 &lt;code&gt;content&lt;/code&gt; 内の &lt;code&gt;String&lt;/code&gt; &lt;code&gt;push_str&lt;/code&gt; を呼び出し、保存された &lt;code&gt;content&lt;/code&gt; に追加する &lt;code&gt;text&lt;/code&gt; 引数を渡します。この動作は投稿の状態に依存しないため、状態パターンの一部ではありません。 &lt;code&gt;add_text&lt;/code&gt; の方法はと相互作用しない &lt;code&gt;state&lt;/code&gt; すべてのフィールドが、それは我々がサポートしたい行動の一部です。</target>
        </trans-unit>
        <trans-unit id="2c3ad15ad6826ff34548cd3374a6a4eed3efc204" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;align&lt;/code&gt; and &lt;code&gt;packed&lt;/code&gt; modifiers can be used to respectively raise or lower the alignment of &lt;code&gt;struct&lt;/code&gt;s and &lt;code&gt;union&lt;/code&gt;s. &lt;code&gt;packed&lt;/code&gt; may also alter the padding between fields.</source>
          <target state="translated">&lt;code&gt;align&lt;/code&gt; と &lt;code&gt;packed&lt;/code&gt; 改質剤は、アラインメント上げる又は下げるそれぞれに使用することができる &lt;code&gt;struct&lt;/code&gt; Sと &lt;code&gt;union&lt;/code&gt; 秒。 &lt;code&gt;packed&lt;/code&gt; はフィールド間のパディングを変更する場合があります。</target>
        </trans-unit>
        <trans-unit id="0e0634e43790fec0970517f968c2cdaea9942a64" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;align&lt;/code&gt; and &lt;code&gt;packed&lt;/code&gt; modifiers cannot be applied on the same type and a &lt;code&gt;packed&lt;/code&gt; type cannot transitively contain another &lt;code&gt;align&lt;/code&gt;ed type. &lt;code&gt;align&lt;/code&gt; and &lt;code&gt;packed&lt;/code&gt; may only be applied to the &lt;a href=&quot;#the-default-representation&quot;&gt;default&lt;/a&gt; and &lt;a href=&quot;#the-c-representation&quot;&gt;&lt;code&gt;C&lt;/code&gt;&lt;/a&gt; representations.</source>
          <target state="translated">&lt;code&gt;align&lt;/code&gt; と &lt;code&gt;packed&lt;/code&gt; 修飾子は、同じタイプに適用することはできませんし、 &lt;code&gt;packed&lt;/code&gt; タイプが推移別含めることはできません &lt;code&gt;align&lt;/code&gt; EDタイプを。 &lt;code&gt;align&lt;/code&gt; および &lt;code&gt;packed&lt;/code&gt; は、&lt;a href=&quot;#the-default-representation&quot;&gt;デフォルト&lt;/a&gt;および&lt;a href=&quot;#the-c-representation&quot;&gt; &lt;code&gt;C&lt;/code&gt; &lt;/a&gt;表現にのみ適用できます。</target>
        </trans-unit>
        <trans-unit id="ba365c1b081658cee386344e9e2a04962a51bb04" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;align&lt;/code&gt; and &lt;code&gt;packed&lt;/code&gt; modifiers cannot be applied on the same type and a &lt;code&gt;packed&lt;/code&gt; type cannot transitively contain another &lt;code&gt;align&lt;/code&gt;ed type. &lt;code&gt;align&lt;/code&gt; and &lt;code&gt;packed&lt;/code&gt; may only be applied to the &lt;a href=&quot;type-layout#the-default-representation&quot;&gt;default&lt;/a&gt; and &lt;a href=&quot;type-layout#the-c-representation&quot;&gt;&lt;code&gt;C&lt;/code&gt;&lt;/a&gt; representations.</source>
          <target state="translated">&lt;code&gt;align&lt;/code&gt; と &lt;code&gt;packed&lt;/code&gt; 修飾子は、同じタイプに適用することはできませんし、 &lt;code&gt;packed&lt;/code&gt; タイプが推移別含めることはできません &lt;code&gt;align&lt;/code&gt; EDタイプを。 &lt;code&gt;align&lt;/code&gt; と &lt;code&gt;packed&lt;/code&gt; は、&lt;a href=&quot;type-layout#the-default-representation&quot;&gt;デフォルト&lt;/a&gt;と&lt;a href=&quot;type-layout#the-c-representation&quot;&gt; &lt;code&gt;C&lt;/code&gt; の&lt;/a&gt;表現にのみ適用できます。</target>
        </trans-unit>
        <trans-unit id="53e65577e1cfa4684ae0b49bee71e8da03a67fa1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;align&lt;/code&gt; modifier can also be applied on an &lt;code&gt;enum&lt;/code&gt;. When it is, the effect on the &lt;code&gt;enum&lt;/code&gt;'s alignment is the same as if the &lt;code&gt;enum&lt;/code&gt; was wrapped in a newtype &lt;code&gt;struct&lt;/code&gt; with the same &lt;code&gt;align&lt;/code&gt; modifier.</source>
          <target state="translated">&lt;code&gt;align&lt;/code&gt; 調整剤はまた、上に適用することができる &lt;code&gt;enum&lt;/code&gt; 。その場合、 &lt;code&gt;enum&lt;/code&gt; の配置への影響は、 &lt;code&gt;enum&lt;/code&gt; が同じ &lt;code&gt;align&lt;/code&gt; 修飾子でnewtype &lt;code&gt;struct&lt;/code&gt; にラップされた場合と同じです。</target>
        </trans-unit>
        <trans-unit id="6ad8df46a380899eaf26791f29aae33e2b0b76bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;amt&lt;/code&gt; must be &lt;code&gt;&amp;lt;=&lt;/code&gt; the number of bytes in the buffer returned by &lt;a href=&quot;#tymethod.fill_buf&quot;&gt;&lt;code&gt;fill_buf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;amt&lt;/code&gt; である必要があります &lt;code&gt;&amp;lt;=&lt;/code&gt; によって返されるバッファのバイト数&lt;a href=&quot;#tymethod.fill_buf&quot;&gt; &lt;code&gt;fill_buf&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6cdd430203e5d1bc8171135295b8e6a12c3f9ccb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;amt&lt;/code&gt; must be &lt;code&gt;&amp;lt;=&lt;/code&gt; the number of bytes in the buffer returned by &lt;a href=&quot;trait.bufread#tymethod.fill_buf&quot;&gt;&lt;code&gt;fill_buf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;amt&lt;/code&gt; である必要があります &lt;code&gt;&amp;lt;=&lt;/code&gt; によって返されるバッファのバイト数&lt;a href=&quot;trait.bufread#tymethod.fill_buf&quot;&gt; &lt;code&gt;fill_buf&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="45b714d09b6da61ea117e3601d5d1e5fd89a8774" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;approve&lt;/code&gt; method will be similar to the &lt;code&gt;request_review&lt;/code&gt; method: it will set &lt;code&gt;state&lt;/code&gt; to the value that the current state says it should have when that state is approved, as shown in Listing 17-16:</source>
          <target state="translated">&lt;code&gt;approve&lt;/code&gt; 方法は次のようになります &lt;code&gt;request_review&lt;/code&gt; の方法：それが設定されます &lt;code&gt;state&lt;/code&gt; リスト17-16のように現在の状態が、それはその状態が承認されたときに持つべきであると言うことを値に：</target>
        </trans-unit>
        <trans-unit id="0d99e2697c98f4ee00d53c8602d75f85424ebe1a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;area&lt;/code&gt; function accesses the &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; fields of the &lt;code&gt;Rectangle&lt;/code&gt; instance. Our function signature for &lt;code&gt;area&lt;/code&gt; now says exactly what we mean: calculate the area of &lt;code&gt;Rectangle&lt;/code&gt;, using its &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; fields. This conveys that the width and height are related to each other, and it gives descriptive names to the values rather than using the tuple index values of &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt;. This is a win for clarity.</source>
          <target state="translated">&lt;code&gt;area&lt;/code&gt; 機能は、アクセス &lt;code&gt;width&lt;/code&gt; と &lt;code&gt;height&lt;/code&gt; のフィールド &lt;code&gt;Rectangle&lt;/code&gt; インスタンス。 &lt;code&gt;area&lt;/code&gt; の関数シグネチャは、私たちが正確に言っているとおりです。 &lt;code&gt;width&lt;/code&gt; と &lt;code&gt;height&lt;/code&gt; フィールドを使用して、 &lt;code&gt;Rectangle&lt;/code&gt; の面積を計算します。これは、幅と高さが相互に関連していることを示し、タプルインデックス値 &lt;code&gt;0&lt;/code&gt; および &lt;code&gt;1&lt;/code&gt; を使用するのではなく、値にわかりやすい名前を付けます。これは明快さのための勝利です。</target>
        </trans-unit>
        <trans-unit id="f0f4d5c245d843fc107cb0d995f1cc0cbaafe380" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;area&lt;/code&gt; function is supposed to calculate the area of one rectangle, but the function we wrote has two parameters. The parameters are related, but that&amp;rsquo;s not expressed anywhere in our program. It would be more readable and more manageable to group width and height together. We&amp;rsquo;ve already discussed one way we might do that in &lt;a href=&quot;ch03-02-data-types#the-tuple-type&quot;&gt;&amp;ldquo;The Tuple Type&amp;rdquo;&lt;/a&gt; section of Chapter 3: by using tuples.</source>
          <target state="translated">&lt;code&gt;area&lt;/code&gt; 機能は、一つの長方形の面積を算出することになって、私たちが書いた関数は、2つのパラメータがあります。パラメータは関連していますが、プログラムではどこにも表現されていません。幅と高さをグループ化すると、読みやすく、管理しやすくなります。その方法の1つについては、第3章の&lt;a href=&quot;ch03-02-data-types#the-tuple-type&quot;&gt;「タプルタイプ」&lt;/a&gt;セクションでタプルを使用してすでに説明しました。</target>
        </trans-unit>
        <trans-unit id="03663b761515431ad66c10f38033078682c6e595" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;art&lt;/code&gt; crate users can still see and use the internal structure from Listing 14-3 as demonstrated in Listing 14-4, or they can use the more convenient structure in Listing 14-5, as shown in Listing 14-6:</source>
          <target state="translated">&lt;code&gt;art&lt;/code&gt; クレートのユーザーがまだ見て、リスト14-4で示されるように、リスト14-3から内部構造を使用し、または14-6のリストに示すように、彼らは、リスト14-5でより便利な構造を使用することができますすることができます：</target>
        </trans-unit>
        <trans-unit id="e825da57c4a60047ea61533b7c1bd5bca8251591" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;as&lt;/code&gt; keyword can be used to change what the crate is referred to as in your project. If a crate name includes a dash, it is implicitly imported with the dashes replaced by underscores.</source>
          <target state="translated">&lt;code&gt;as&lt;/code&gt; のキーワードは、クレートは、プロジェクト内と呼ばれるものを変更するために使用することができます。クレート名にダッシュが含まれている場合、ダッシュはアンダースコアに置き換えられて暗黙的にインポートされます。</target>
        </trans-unit>
        <trans-unit id="2dd2463e89570fe4f3bb6f6203a6c56b03267f94" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;assert!&lt;/code&gt; macro, provided by the standard library, is useful when you want to ensure that some condition in a test evaluates to &lt;code&gt;true&lt;/code&gt;. We give the &lt;code&gt;assert!&lt;/code&gt; macro an argument that evaluates to a Boolean. If the value is &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;assert!&lt;/code&gt; does nothing and the test passes. If the value is &lt;code&gt;false&lt;/code&gt;, the &lt;code&gt;assert!&lt;/code&gt; macro calls the &lt;code&gt;panic!&lt;/code&gt; macro, which causes the test to fail. Using the &lt;code&gt;assert!&lt;/code&gt; macro helps us check that our code is functioning in the way we intend.</source>
          <target state="translated">&lt;code&gt;assert!&lt;/code&gt; 標準ライブラリによって提供されるマクロは、テスト内のある条件が &lt;code&gt;true&lt;/code&gt; と評価されることを確認したい場合に役立ちます。私たちは与える &lt;code&gt;assert!&lt;/code&gt; マクロはブール値に評価される引数です。値が &lt;code&gt;true&lt;/code&gt; の場合、 &lt;code&gt;assert!&lt;/code&gt; 何もせず、テストに合格します。値が &lt;code&gt;false&lt;/code&gt; の場合、 &lt;code&gt;assert!&lt;/code&gt; マクロは &lt;code&gt;panic!&lt;/code&gt; 呼び出します！テストを失敗させるマクロ。 &lt;code&gt;assert!&lt;/code&gt; を使用して！マクロは、コードが意図したとおりに機能していることを確認するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="95f1355f51c209910ea66191ec2fc57f92344bfc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;assert_ne!&lt;/code&gt; macro will pass if the two values we give it are not equal and fail if they&amp;rsquo;re equal. This macro is most useful for cases when we&amp;rsquo;re not sure what a value &lt;em&gt;will&lt;/em&gt; be, but we know what the value definitely &lt;em&gt;won&amp;rsquo;t&lt;/em&gt; be if our code is functioning as we intend. For example, if we&amp;rsquo;re testing a function that is guaranteed to change its input in some way, but the way in which the input is changed depends on the day of the week that we run our tests, the best thing to assert might be that the output of the function is not equal to the input.</source>
          <target state="translated">&lt;code&gt;assert_ne!&lt;/code&gt; マクロは、指定した2つの値が等しくない場合は通過し、等しい場合は失敗します。このマクロは、値&lt;em&gt;が&lt;/em&gt;どのように&lt;em&gt;なる&lt;/em&gt;かわからない場合に最も役立ちます&lt;em&gt;が&lt;/em&gt;、コードが意図したとおりに機能している場合、値が確実にどうなるかはわかり&lt;em&gt;ません&lt;/em&gt;。たとえば、なんらかの方法で入力が変更されることが保証されている関数をテストしているが、入力が変更される方法がテストを実行する曜日によって異なる場合、アサートするのに最適なものは次のようになります。関数の出力が入力と等しくないこと。</target>
        </trans-unit>
        <trans-unit id="bf35e012d7004404479ddec49cb6abc4ee90bc1a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bind&lt;/code&gt; function in this scenario works like the &lt;code&gt;new&lt;/code&gt; function in that it will return a new &lt;code&gt;TcpListener&lt;/code&gt; instance. The reason the function is called &lt;code&gt;bind&lt;/code&gt; is that in networking, connecting to a port to listen to is known as &amp;ldquo;binding to a port.&amp;rdquo;</source>
          <target state="translated">このシナリオの &lt;code&gt;bind&lt;/code&gt; 関数は、新しい &lt;code&gt;TcpListener&lt;/code&gt; インスタンスを返すという点で、 &lt;code&gt;new&lt;/code&gt; 関数のように機能します。この機能が &lt;code&gt;bind&lt;/code&gt; と呼ばれるのは、ネットワークでは、リッスンするポートに接続することを「ポートへのバインド」といいます。</target>
        </trans-unit>
        <trans-unit id="3a9db4154e7cfc914c7af74a70f78787dc149e27" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bind&lt;/code&gt; function returns a &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;, which indicates that binding might fail. For example, connecting to port 80 requires administrator privileges (nonadministrators can listen only on ports higher than 1024), so if we tried to connect to port 80 without being an administrator, binding wouldn&amp;rsquo;t work. As another example, binding wouldn&amp;rsquo;t work if we ran two instances of our program and so had two programs listening to the same port. Because we&amp;rsquo;re writing a basic server just for learning purposes, we won&amp;rsquo;t worry about handling these kinds of errors; instead, we use &lt;code&gt;unwrap&lt;/code&gt; to stop the program if errors happen.</source>
          <target state="translated">&lt;code&gt;bind&lt;/code&gt; 関数が返す &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 、結合が失敗する可能性があることを示しています。たとえば、ポート80に接続するには管理者権限が必要です（非管理者は1024を超えるポートでのみリッスンできます）。したがって、管理者でなくてもポート80に接続しようとした場合、バインドは機能しません。別の例として、プログラムの2つのインスタンスを実行し、2つのプログラムが同じポートをリッスンしている場合、バインディングは機能しません。学習目的で基本的なサーバーを作成しているため、この種のエラーの処理について心配する必要はありません。代わりに、エラーが発生した場合は、 &lt;code&gt;unwrap&lt;/code&gt; を使用してプログラムを停止します。</target>
        </trans-unit>
        <trans-unit id="86e869ec27553a2645d530ee9b57e980ad085326" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bool&lt;/code&gt; represents a value, which could only be either &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. If you cast a &lt;code&gt;bool&lt;/code&gt; into an integer, &lt;code&gt;true&lt;/code&gt; will be 1 and &lt;code&gt;false&lt;/code&gt; will be 0.</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; のみのいずれかである値で表し、 &lt;code&gt;true&lt;/code&gt; または &lt;code&gt;false&lt;/code&gt; 。 &lt;code&gt;bool&lt;/code&gt; を整数にキャストした場合、 &lt;code&gt;true&lt;/code&gt; は1、 &lt;code&gt;false&lt;/code&gt; は0になります。</target>
        </trans-unit>
        <trans-unit id="d4311662fb8a13303491e364af26bcbe8200bef8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bool&lt;/code&gt; type is a datatype which can be either &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. The boolean type uses one byte of memory. It is used in comparisons and bitwise operations like &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, and &lt;code&gt;!&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; 型がいずれかになりますデータ型である &lt;code&gt;true&lt;/code&gt; または &lt;code&gt;false&lt;/code&gt; 。ブール型は1バイトのメモリを使用します。 &lt;code&gt;&amp;amp;&lt;/code&gt; 、 &lt;code&gt;|&lt;/code&gt; などの比較やビット単位の演算で使用されます。、そして &lt;code&gt;!&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="71b45beaeed4f4e8bb8cb42d1eee7255c7dfda23" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;break&lt;/code&gt; statement can take an argument (which will be the value of the loop expression if the &lt;code&gt;break&lt;/code&gt; statement is executed) in &lt;code&gt;loop&lt;/code&gt; loops, but not &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, or &lt;code&gt;while let&lt;/code&gt; loops.</source>
          <target state="translated">&lt;code&gt;break&lt;/code&gt; ステートメントは、（あればループ式の値になります引数取ることができ &lt;code&gt;break&lt;/code&gt; に文が実行される）を &lt;code&gt;loop&lt;/code&gt; ではなく、ループ &lt;code&gt;for&lt;/code&gt; 、 &lt;code&gt;while&lt;/code&gt; 、または &lt;code&gt;while let&lt;/code&gt; ループ。</target>
        </trans-unit>
        <trans-unit id="d4fc4821431bbe2f5d7ca950ef58b031fb001379" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bytes&lt;/code&gt; method returns each raw byte, which might be appropriate for your domain:</source>
          <target state="translated">&lt;code&gt;bytes&lt;/code&gt; の方法は、あなたのドメインに適切であるかもしれないそれぞれの生のバイトを返します：</target>
        </trans-unit>
        <trans-unit id="0c67d48bb9bf16df95a3dc50a92dbdfe313c2a09" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;can_hold&lt;/code&gt; method returns a Boolean, which means it&amp;rsquo;s a perfect use case for the &lt;code&gt;assert!&lt;/code&gt; macro. In Listing 11-6, we write a test that exercises the &lt;code&gt;can_hold&lt;/code&gt; method by creating a &lt;code&gt;Rectangle&lt;/code&gt; instance that has a width of 8 and a height of 7 and asserting that it can hold another &lt;code&gt;Rectangle&lt;/code&gt; instance that has a width of 5 and a height of 1.</source>
          <target state="translated">&lt;code&gt;can_hold&lt;/code&gt; メソッドはブール値を返します。つまり、 &lt;code&gt;assert!&lt;/code&gt; 完全なユースケースです。大きい。リスト11-6において、我々は、行使テスト書き込み &lt;code&gt;can_hold&lt;/code&gt; の作成方法を &lt;code&gt;Rectangle&lt;/code&gt; 8の幅と7の高さを有するインスタンスを、それが別の保持することができると主張 &lt;code&gt;Rectangle&lt;/code&gt; 5の幅と高さを有するインスタンスを1。</target>
        </trans-unit>
        <trans-unit id="5a25b55443c783de850a8f716e7e98dd68745de2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cargo install&lt;/code&gt; command allows you to install and use binary crates locally. This isn&amp;rsquo;t intended to replace system packages; it&amp;rsquo;s meant to be a convenient way for Rust developers to install tools that others have shared on &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt;. Note that you can only install packages that have binary targets. A &lt;em&gt;binary target&lt;/em&gt; is the runnable program that is created if the crate has a &lt;em&gt;src/main.rs&lt;/em&gt; file or another file specified as a binary, as opposed to a library target that isn&amp;rsquo;t runnable on its own but is suitable for including within other programs. Usually, crates have information in the &lt;em&gt;README&lt;/em&gt; file about whether a crate is a library, has a binary target, or both.</source>
          <target state="translated">&lt;code&gt;cargo install&lt;/code&gt; コマンドを使用すると、ローカルバイナリ木箱をインストールして使用することができます。これは、システムパッケージを置き換えることを意図したものではありません。これは、Rust開発者が他の人が&lt;a href=&quot;https://crates.io/&quot;&gt;crates.ioで&lt;/a&gt;共有しているツールをインストールするための便利な方法であることを意図しています。バイナリターゲットを持つパッケージのみをインストールできることに注意してください。&lt;em&gt;バイナリターゲットは&lt;/em&gt;クレートがある場合に作成される実行可能なプログラムであり、&lt;em&gt;SRC / main.rsの&lt;/em&gt;自分自身で実行可能ではありませんが、他の中に含めるために適しているライブラリのターゲットとは反対に、ファイルまたはバイナリとして指定された別のファイルをプログラム。通常、クレートの&lt;em&gt;README&lt;/em&gt;ファイルには、クレートがライブラリであるか、バイナリターゲットであるか、またはその両方に関する情報が含まれています。</target>
        </trans-unit>
        <trans-unit id="2664dcbe5273c6722a5b153d876b9b792f2ada2f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cargo test&lt;/code&gt; command runs all tests in our project, as shown in Listing 11-2.</source>
          <target state="translated">&lt;code&gt;cargo test&lt;/code&gt; リスト11-2に示すように、コマンドは、私たちのプロジェクトのすべてのテストを実行します。</target>
        </trans-unit>
        <trans-unit id="375baaee400dee61b2707b887bd9af56fe2bc128" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;cfg&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="3c6c79dbe0366f164760e8fbd149ca95e0429eec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg&lt;/code&gt; attribute is allowed anywhere attributes are allowed.</source>
          <target state="translated">&lt;code&gt;cfg&lt;/code&gt; 属性は、どこかの属性が許可されている許可されています。</target>
        </trans-unit>
        <trans-unit id="c1be4a466f7709a98c138b8664fae5693d56dd2b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg&lt;/code&gt; attribute supports only three kinds of predicates:</source>
          <target state="translated">&lt;code&gt;cfg&lt;/code&gt; 属性がサポートする述語の唯一の三種類：</target>
        </trans-unit>
        <trans-unit id="28422790bd7081a79bb025fb9d66e378219a525d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg&lt;/code&gt; macro</source>
          <target state="translated">&lt;code&gt;cfg&lt;/code&gt; マクロ</target>
        </trans-unit>
        <trans-unit id="fde18a15c12045ccc5f862ad4d07ffff9bb790a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg&lt;/code&gt;&lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; conditionally includes the thing it is attached to based on a configuration predicate.</source>
          <target state="translated">&lt;code&gt;cfg&lt;/code&gt; &lt;a href=&quot;attributes&quot;&gt;属性は&lt;/a&gt;条件付きでそれが設定述語に基づいに接続されているものを含んでいます。</target>
        </trans-unit>
        <trans-unit id="2223835f7d8034d74bbb5846af6ec97de49a67f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg_attr&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;cfg_attr&lt;/code&gt; の属性</target>
        </trans-unit>
        <trans-unit id="76546526e7489be649c0d74ada78ee80e5e85965" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg_attr&lt;/code&gt; attribute is allowed anywhere attributes are allowed.</source>
          <target state="translated">&lt;code&gt;cfg_attr&lt;/code&gt; の属性は、どこかの属性が許可されている許可されています。</target>
        </trans-unit>
        <trans-unit id="548a83f876de36acae9e81967a808fe451cf7938" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg_attr&lt;/code&gt;&lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; conditionally includes &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt; based on a configuration predicate.</source>
          <target state="translated">&lt;code&gt;cfg_attr&lt;/code&gt; の&lt;a href=&quot;attributes&quot;&gt;属性は、&lt;/a&gt;条件付きで含まれる&lt;a href=&quot;attributes&quot;&gt;属性&lt;/a&gt;の設定述語に基づいています。</target>
        </trans-unit>
        <trans-unit id="85a19bbf37eb56f0525c8c2436505adedd691250" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;char&lt;/code&gt; type represents a single character. More specifically, since 'character' isn't a well-defined concept in Unicode, &lt;code&gt;char&lt;/code&gt; is a '&lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode scalar value&lt;/a&gt;', which is similar to, but not the same as, a '&lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt;Unicode code point&lt;/a&gt;'.</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; 型のタイプは、単一の文字を表します。より具体的には、「文字」はUnicodeで明確に定義された概念ではないため、 &lt;code&gt;char&lt;/code&gt; は「&lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicodeスカラー値&lt;/a&gt;」であり、「&lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt;Unicodeコードポイント&lt;/a&gt;」に似ていますが、同じではありません。</target>
        </trans-unit>
        <trans-unit id="b73bedd4705331ddde92b218ee42ae14fd783b1a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cold&lt;/code&gt; and &lt;code&gt;inline&lt;/code&gt;&lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; give suggestions to generate code in a way that may be faster than what it would do without the hint. The attributes are only hints, and may be ignored.</source>
          <target state="translated">&lt;code&gt;cold&lt;/code&gt; と &lt;code&gt;inline&lt;/code&gt; &lt;a href=&quot;../attributes&quot;&gt;属性は、&lt;/a&gt;より速く、それがヒントなしでどうなるのかよりかもしれ方法でコードを生成するための提案を与えます。属性は単なるヒントであり、無視してもかまいません。</target>
        </trans-unit>
        <trans-unit id="5e443e8933fc7022a9fff52a5391c70d8fc736a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cold&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;cold&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="f187d03d0870d5f7cf8d911158a2ad4bf8bfb1f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;const&lt;/code&gt; keyword is also used in raw pointers in combination with &lt;code&gt;mut&lt;/code&gt;, as seen in &lt;code&gt;*const T&lt;/code&gt; and &lt;code&gt;*mut T&lt;/code&gt;. More about &lt;code&gt;const&lt;/code&gt; as used in raw pointers can be read at the Rust docs for the &lt;a href=&quot;primitive.pointer&quot;&gt;pointer primitive&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; のキーワードはまた、との組み合わせで、生のポインタで使用され &lt;code&gt;mut&lt;/code&gt; に見られるように、 &lt;code&gt;*const T&lt;/code&gt; と &lt;code&gt;*mut T&lt;/code&gt; 。生のポインターで使用される &lt;code&gt;const&lt;/code&gt; の詳細については、&lt;a href=&quot;primitive.pointer&quot;&gt;ポインタープリミティブの&lt;/a&gt;Rustドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="c647cbb39e778e9b3fee3b9f221a846f5e10198a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;const&lt;/code&gt; keyword is also used in raw pointers in combination with &lt;code&gt;mut&lt;/code&gt;, as seen in &lt;code&gt;*const T&lt;/code&gt; and &lt;code&gt;*mut T&lt;/code&gt;. More about that can be read at the &lt;a href=&quot;primitive.pointer&quot;&gt;pointer&lt;/a&gt; primitive part of the Rust docs.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; のキーワードはまた、との組み合わせで、生のポインタで使用され &lt;code&gt;mut&lt;/code&gt; に見られるように、 &lt;code&gt;*const T&lt;/code&gt; と &lt;code&gt;*mut T&lt;/code&gt; 。その詳細については、Rustドキュメントの&lt;a href=&quot;primitive.pointer&quot;&gt;ポインタ&lt;/a&gt;プリミティブ部分を参照してください。</target>
        </trans-unit>
        <trans-unit id="90ef70a34f1bf7aa0febc79627f67bbce0e1d9d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;core&lt;/code&gt; crate is always added to the extern prelude. The &lt;code&gt;std&lt;/code&gt; crate is added as long as the &lt;a href=&quot;../crates-and-source-files#preludes-and-no_std&quot;&gt;&lt;code&gt;no_std&lt;/code&gt;&lt;/a&gt; attribute is not specified in the crate root.</source>
          <target state="translated">&lt;code&gt;core&lt;/code&gt; クレートは、常にはexternプレリュードに追加されます。 &lt;code&gt;std&lt;/code&gt; クレートは限りとして追加され&lt;a href=&quot;../crates-and-source-files#preludes-and-no_std&quot;&gt; &lt;code&gt;no_std&lt;/code&gt; &lt;/a&gt;属性はクレートのルートに指定されていません。</target>
        </trans-unit>
        <trans-unit id="38acae0d6ab176e191a45e1f1b54faccd4c7f448" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crate_name&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;crate_name&lt;/code&gt; の属性</target>
        </trans-unit>
        <trans-unit id="ef2c8badee302cb0baefa21db745a07eb79b3acf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; pointer can be used to store arbitrary data as required by the executor. This could be e.g. a type-erased pointer to an &lt;code&gt;Arc&lt;/code&gt; that is associated with the task. The value of this poiner will get passed to all functions that are part of the &lt;code&gt;vtable&lt;/code&gt; as the first parameter.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; ポインタは、エグゼキュータによって要求される任意のデータを格納するために使用することができます。これは、たとえば、タスクに関連付けられている &lt;code&gt;Arc&lt;/code&gt; への型消去されたポインターである可能性があります。このpoinerの値は、最初のパラメーターとして &lt;code&gt;vtable&lt;/code&gt; の一部であるすべての関数に渡されます。</target>
        </trans-unit>
        <trans-unit id="9e90fa7bb07af3f80ba061dbc0af88db5a79ba76" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; pointer can be used to store arbitrary data as required by the executor. This could be e.g. a type-erased pointer to an &lt;code&gt;Arc&lt;/code&gt; that is associated with the task. The value of this pointer will get passed to all functions that are part of the &lt;code&gt;vtable&lt;/code&gt; as the first parameter.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; ポインタは、エグゼキュータによって要求される任意のデータを格納するために使用することができます。これは、たとえば、タスクに関連付けられている &lt;code&gt;Arc&lt;/code&gt; へのタイプ消去されたポインタである可能性があります。このポインターの値は、最初のパラメーターとして &lt;code&gt;vtable&lt;/code&gt; の一部であるすべての関数に渡されます。</target>
        </trans-unit>
        <trans-unit id="a7af61314557c2255ce30f13387bf574343b8476" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dbg!(..)&lt;/code&gt; macro moves the input:</source>
          <target state="translated">&lt;code&gt;dbg!(..)&lt;/code&gt; マクロ移動入力：</target>
        </trans-unit>
        <trans-unit id="b7a4dd4c094bb75a82ed633489f0ec96c82a6296" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dbg!&lt;/code&gt; macro works exactly the same in release builds. This is useful when debugging issues that only occur in release builds or when debugging in release mode is significantly faster.</source>
          <target state="translated">&lt;code&gt;dbg!&lt;/code&gt; マクロはリリースビルドでもまったく同じように機能します。これは、リリースビルドでのみ発生する問題をデバッグする場合、またはリリースモードでのデバッグが大幅に速い場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="5a03c825d089a243f66f60fd9869adfb4b5c6857" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;deprecated&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="8b0ffc1f78b8eb9694b4e7509ecdd919acc0c0cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute can only be present &lt;strong&gt;once&lt;/strong&gt; on an item.</source>
          <target state="translated">&lt;code&gt;deprecated&lt;/code&gt; 属性が唯一存在することができ&lt;strong&gt;、一度&lt;/strong&gt;アイテムに。</target>
        </trans-unit>
        <trans-unit id="4c348bd3f38f8d7b286030ed2d1f972d4a02706b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute has several forms:</source>
          <target state="translated">&lt;code&gt;deprecated&lt;/code&gt; 属性は、いくつかの形式があります。</target>
        </trans-unit>
        <trans-unit id="44c311ce3d12b2d5a8a0632c6cd020f999b4ee16" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute may be applied to any &lt;a href=&quot;../items&quot;&gt;item&lt;/a&gt;, &lt;a href=&quot;../items/traits&quot;&gt;trait item&lt;/a&gt;, &lt;a href=&quot;../items/enumerations&quot;&gt;enum variant&lt;/a&gt;, &lt;a href=&quot;../items/structs&quot;&gt;struct field&lt;/a&gt;, &lt;a href=&quot;../items/external-blocks&quot;&gt;external block item&lt;/a&gt;, or &lt;a href=&quot;../macros-by-example&quot;&gt;macro definition&lt;/a&gt;. It cannot be applied to &lt;a href=&quot;../items/implementations#trait-implementations&quot;&gt;trait implementation items&lt;/a&gt;. When applied to an item containing other items, such as a &lt;a href=&quot;../items/modules&quot;&gt;module&lt;/a&gt; or &lt;a href=&quot;../items/implementations&quot;&gt;implementation&lt;/a&gt;, all child items inherit the deprecation attribute.</source>
          <target state="translated">&lt;code&gt;deprecated&lt;/code&gt; 属性は、いずれにも適用することができる&lt;a href=&quot;../items&quot;&gt;アイテム&lt;/a&gt;、&lt;a href=&quot;../items/traits&quot;&gt;形質項目&lt;/a&gt;、&lt;a href=&quot;../items/enumerations&quot;&gt;列挙変異体&lt;/a&gt;、&lt;a href=&quot;../items/structs&quot;&gt;構造体フィールド&lt;/a&gt;、&lt;a href=&quot;../items/external-blocks&quot;&gt;外部ブロック・アイテム&lt;/a&gt;、または&lt;a href=&quot;../macros-by-example&quot;&gt;マクロ定義&lt;/a&gt;。&lt;a href=&quot;../items/implementations#trait-implementations&quot;&gt;トレイト実装アイテムには&lt;/a&gt;適用できません。&lt;a href=&quot;../items/modules&quot;&gt;モジュール&lt;/a&gt;や&lt;a href=&quot;../items/implementations&quot;&gt;実装&lt;/a&gt;など、他のアイテムを含むアイテムに適用されると、すべての子アイテムは非推奨属性を継承します。</target>
        </trans-unit>
        <trans-unit id="f1d23eb4050e4bb4bd6008dd3e0216cd81ba2cd1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute may be applied to any &lt;a href=&quot;../items&quot;&gt;item&lt;/a&gt;, &lt;a href=&quot;../items/traits&quot;&gt;trait item&lt;/a&gt;, &lt;a href=&quot;../items/enumerations&quot;&gt;enum variant&lt;/a&gt;, &lt;a href=&quot;../items/structs&quot;&gt;struct field&lt;/a&gt;, or &lt;a href=&quot;../items/external-blocks&quot;&gt;external block item&lt;/a&gt;. It cannot be applied to &lt;a href=&quot;../items/implementations#trait-implementations&quot;&gt;trait implementation items&lt;/a&gt;. When applied to an item containing other items, such as a &lt;a href=&quot;../items/modules&quot;&gt;module&lt;/a&gt; or &lt;a href=&quot;../items/implementations&quot;&gt;implementation&lt;/a&gt;, all child items inherit the deprecation attribute.</source>
          <target state="translated">&lt;code&gt;deprecated&lt;/code&gt; 属性は、いずれにも適用することができる&lt;a href=&quot;../items&quot;&gt;アイテム&lt;/a&gt;、&lt;a href=&quot;../items/traits&quot;&gt;形質項目&lt;/a&gt;、&lt;a href=&quot;../items/enumerations&quot;&gt;列挙変異体&lt;/a&gt;、&lt;a href=&quot;../items/structs&quot;&gt;構造体のフィールド&lt;/a&gt;、または&lt;a href=&quot;../items/external-blocks&quot;&gt;外部ブロック・アイテム&lt;/a&gt;。&lt;a href=&quot;../items/implementations#trait-implementations&quot;&gt;トレイト実装アイテムには&lt;/a&gt;適用できません。&lt;a href=&quot;../items/modules&quot;&gt;モジュール&lt;/a&gt;や&lt;a href=&quot;../items/implementations&quot;&gt;実装&lt;/a&gt;など、他のアイテムを含むアイテムに適用すると、すべての子アイテムは非推奨属性を継承します。</target>
        </trans-unit>
        <trans-unit id="6e7f4030e080734f98683be5c8344d101d0992db" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dev&lt;/code&gt; and &lt;code&gt;release&lt;/code&gt; shown in this build output indicate that the compiler is using different profiles.</source>
          <target state="translated">&lt;code&gt;dev&lt;/code&gt; と &lt;code&gt;release&lt;/code&gt; このビルド出力に示されているが、コンパイラが異なるプロファイルを使用していることを示しています。</target>
        </trans-unit>
        <trans-unit id="2bcbec4aff44a7472a393bc8eca9c7c00034401d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;drop&lt;/code&gt; method is called when &lt;code&gt;_x&lt;/code&gt; goes out of scope, and therefore &lt;code&gt;main&lt;/code&gt; prints &lt;code&gt;Dropping!&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;drop&lt;/code&gt; 時にメソッドが呼び出され &lt;code&gt;_x&lt;/code&gt; がスコープ外に出るので、 &lt;code&gt;main&lt;/code&gt; プリントが &lt;code&gt;Dropping!&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aa3edbdb8ad85c4d37e55b2e809f2f18d6f4e045" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dst&lt;/code&gt; path will be a directory symbolic link pointing to the &lt;code&gt;src&lt;/code&gt; path.</source>
          <target state="translated">&lt;code&gt;dst&lt;/code&gt; パスを指し、ディレクトリのシンボリックリンクとなる &lt;code&gt;src&lt;/code&gt; パス。</target>
        </trans-unit>
        <trans-unit id="f8ab040b8a001ca82f66534b2d20a3b8892fd2dc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dst&lt;/code&gt; path will be a file symbolic link pointing to the &lt;code&gt;src&lt;/code&gt; path.</source>
          <target state="translated">&lt;code&gt;dst&lt;/code&gt; パスを指し、ファイルのシンボリックリンクとなる &lt;code&gt;src&lt;/code&gt; パス。</target>
        </trans-unit>
        <trans-unit id="f0ecd1a2ccd0de8765e1ce7cbb8fab53800f6ce6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dst&lt;/code&gt; path will be a link pointing to the &lt;code&gt;src&lt;/code&gt; path. Note that systems often require these two paths to both be located on the same filesystem.</source>
          <target state="translated">&lt;code&gt;dst&lt;/code&gt; パスはへのリンクになります &lt;code&gt;src&lt;/code&gt; パス。多くの場合、システムではこれらの2つのパスを両方とも同じファイルシステムに配置する必要があります。</target>
        </trans-unit>
        <trans-unit id="b0f3651131fc6e4c0e98108eb60e32485bb1899b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dst&lt;/code&gt; path will be a symbolic link pointing to the &lt;code&gt;src&lt;/code&gt; path.</source>
          <target state="translated">&lt;code&gt;dst&lt;/code&gt; パスを指すシンボリックリンクとなる &lt;code&gt;src&lt;/code&gt; パス。</target>
        </trans-unit>
        <trans-unit id="3c07e52fcb5c94a3c499bbc6e95804ccd5a8bfc6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dst&lt;/code&gt; path will be a symbolic link pointing to the &lt;code&gt;src&lt;/code&gt; path. On Windows, this will be a file symlink, not a directory symlink; for this reason, the platform-specific &lt;a href=&quot;../os/unix/fs/fn.symlink&quot;&gt;&lt;code&gt;std::os::unix::fs::symlink&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../os/windows/fs/fn.symlink_file&quot;&gt;&lt;code&gt;std::os::windows::fs::symlink_file&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../os/windows/fs/fn.symlink_dir&quot;&gt;&lt;code&gt;symlink_dir&lt;/code&gt;&lt;/a&gt; should be used instead to make the intent explicit.</source>
          <target state="translated">&lt;code&gt;dst&lt;/code&gt; パスを指すシンボリックリンクとなる &lt;code&gt;src&lt;/code&gt; パス。Windowsでは、これはディレクトリのシンボリックリンクではなく、ファイルのシンボリックリンクになります。このため、プラットフォーム固有の&lt;a href=&quot;../os/unix/fs/fn.symlink&quot;&gt; &lt;code&gt;std::os::unix::fs::symlink&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;../os/windows/fs/fn.symlink_file&quot;&gt; &lt;code&gt;std::os::windows::fs::symlink_file&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;../os/windows/fs/fn.symlink_dir&quot;&gt; &lt;code&gt;symlink_dir&lt;/code&gt; &lt;/a&gt;を使用して、意図を明示的にする必要があります。</target>
        </trans-unit>
        <trans-unit id="fce5aa6e4c6fe0d2a117a0ec0a2f7f52bfd2748e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dyn&lt;/code&gt; keyword is used to highlight that calls to methods on the associated &lt;code&gt;Trait&lt;/code&gt; are dynamically dispatched. To use the trait this way, it must be 'object safe'.</source>
          <target state="translated">&lt;code&gt;dyn&lt;/code&gt; キーワードは、関連のメソッドをコールすることを強調するために使用される &lt;code&gt;Trait&lt;/code&gt; 、動的に派遣されています。この特性を使用するには、「オブジェクトセーフ」である必要があります。</target>
        </trans-unit>
        <trans-unit id="f31eeeb70d8a71f4b93bd89156c38bf0e5709ff2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;edition&lt;/code&gt; key in &lt;em&gt;Cargo.toml&lt;/em&gt; indicates which edition the compiler should use for your code. If the key doesn&amp;rsquo;t exist, Rust uses &lt;code&gt;2015&lt;/code&gt; as the edition value for backward compatibility reasons.</source>
          <target state="translated">&lt;em&gt;Cargo.toml&lt;/em&gt;の &lt;code&gt;edition&lt;/code&gt; キーは、コンパイラがコードに使用するエディションを示します。キーが存在しない場合、Rustは下位互換性のために &lt;code&gt;2015&lt;/code&gt; をエディション値として使用します。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d4302d0f2edafc20c30c1bca4c608a973532a107" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;else&lt;/code&gt; block of an &lt;code&gt;if&lt;/code&gt; expression.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 式の &lt;code&gt;else&lt;/code&gt; ブロック。</target>
        </trans-unit>
        <trans-unit id="25d57c60dcf697c3f5bb61f1ff343393baeeb72f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;entry&lt;/code&gt; API is intended to provide an efficient mechanism for manipulating the contents of a map conditionally on the presence of a key or not. The primary motivating use case for this is to provide efficient accumulator maps. For instance, if one wishes to maintain a count of the number of times each key has been seen, they will have to perform some conditional logic on whether this is the first time the key has been seen or not. Normally, this would require a &lt;code&gt;find&lt;/code&gt; followed by an &lt;code&gt;insert&lt;/code&gt;, effectively duplicating the search effort on each insertion.</source>
          <target state="translated">&lt;code&gt;entry&lt;/code&gt; APIは、キーやないの存在に条件付きでマップの内容を操作するための効率的なメカニズムを提供することを意図しています。これの動機となる主なユースケースは、効率的なアキュムレータマップを提供することです。たとえば、各キーが表示された回数のカウントを維持したい場合、キーが初めて表示されたかどうかについて、条件付きロジックを実行する必要があります。通常、これには、 &lt;code&gt;find&lt;/code&gt; 後に &lt;code&gt;insert&lt;/code&gt; が必要であり、挿入ごとに検索作業を効果的に複製します。</target>
        </trans-unit>
        <trans-unit id="f625c5b9aa8efa15984a630e2609a8460845d869" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;enum&lt;/code&gt; type is analogous to a &lt;code&gt;data&lt;/code&gt; constructor declaration in ML, or a &lt;em&gt;pick ADT&lt;/em&gt; in Limbo.</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt; タイプに類似して &lt;code&gt;data&lt;/code&gt; MLにおけるコンストラクタ宣言、又は&lt;em&gt;ピックADT&lt;/em&gt;リンボです。</target>
        </trans-unit>
        <trans-unit id="a4c06e2ed2dc5ac68975592625d2fc4a6fa31065" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;env::args&lt;/code&gt; function returns an iterator! Rather than collecting the iterator values into a vector and then passing a slice to &lt;code&gt;Config::new&lt;/code&gt;, now we&amp;rsquo;re passing ownership of the iterator returned from &lt;code&gt;env::args&lt;/code&gt; to &lt;code&gt;Config::new&lt;/code&gt; directly.</source>
          <target state="translated">&lt;code&gt;env::args&lt;/code&gt; 関数は、イテレータを返します！むしろベクターにイテレータ値を収集し、その後にスライスを渡すよりも &lt;code&gt;Config::new&lt;/code&gt; 、今から返されたイテレータの所有権を渡している &lt;code&gt;env::args&lt;/code&gt; に &lt;code&gt;Config::new&lt;/code&gt; 直接。</target>
        </trans-unit>
        <trans-unit id="8c4edba08b3e0cbdebf585d9d18019162245f0c1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;execute&lt;/code&gt; method will send the job it wants to execute down the sending side of the channel.</source>
          <target state="translated">&lt;code&gt;execute&lt;/code&gt; 方法は、それは、チャネルの送信側を下に実行したいジョブを送信します。</target>
        </trans-unit>
        <trans-unit id="f04efaa242b2b0657b1281616eed7892b34b84f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expensive_test&lt;/code&gt; function is listed as &lt;code&gt;ignored&lt;/code&gt;. If we want to run only the ignored tests, we can use &lt;code&gt;cargo test -- --ignored&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;expensive_test&lt;/code&gt; としての機能が一覧表示され &lt;code&gt;ignored&lt;/code&gt; 。無視されたテストのみを実行する場合は、 &lt;code&gt;cargo test -- --ignored&lt;/code&gt; 使用できます。</target>
        </trans-unit>
        <trans-unit id="b3f7670e25e83de589c198657dfe09fdc1e175dc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;export_name&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;export_name&lt;/code&gt; の属性</target>
        </trans-unit>
        <trans-unit id="71ce9eba53db805fddc2d08a297018a65234c4f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extern&lt;/code&gt; function qualifier allows providing function &lt;em&gt;definitions&lt;/em&gt; that can be called with a particular ABI:</source>
          <target state="translated">&lt;code&gt;extern&lt;/code&gt; 関数提供することができます修飾子機能&lt;em&gt;の定義&lt;/em&gt;、特定のABIで呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="40efbff38e084ea29f3140f45238b8f3a1480902" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extern&lt;/code&gt; keyword is used in two places in Rust. One is in conjunction with the &lt;a href=&quot;index&quot;&gt;&lt;code&gt;crate&lt;/code&gt;&lt;/a&gt; keyword to make your Rust code aware of other Rust crates in your project, i.e., &lt;code&gt;extern crate lazy_static;&lt;/code&gt;. The other use is in foreign function interfaces (FFI).</source>
          <target state="translated">&lt;code&gt;extern&lt;/code&gt; キーワードは、ラストで2つの場所で使用されています。 1つは、&lt;a href=&quot;index&quot;&gt; &lt;code&gt;crate&lt;/code&gt; &lt;/a&gt;キーワードと組み合わせて、Rustコードにプロジェクト内の他のRustクレートを認識させること &lt;code&gt;extern crate lazy_static;&lt;/code&gt; つまり、extern crate lazy_static;。もう1つの用途は、外部関数インターフェース（FFI）です。</target>
        </trans-unit>
        <trans-unit id="e4b4130d453476128e8ae98130baa92b7675ca5c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extern&lt;/code&gt; keyword is used in two places in Rust. One is in conjunction with the &lt;a href=&quot;keyword.crate&quot;&gt;&lt;code&gt;crate&lt;/code&gt;&lt;/a&gt; keyword to make your Rust code aware of other Rust crates in your project, i.e., &lt;code&gt;extern crate lazy_static;&lt;/code&gt;. The other use is in foreign function interfaces (FFI).</source>
          <target state="translated">&lt;code&gt;extern&lt;/code&gt; キーワードは、ラストで2つの場所で使用されています。一つは、と連携している&lt;a href=&quot;keyword.crate&quot;&gt; &lt;code&gt;crate&lt;/code&gt; &lt;/a&gt;つまり、プロジェクト内の他の錆の木枠のあなたの錆コードを認識させるためにキーワード &lt;code&gt;extern crate lazy_static;&lt;/code&gt; 。他の用途は、外部関数インターフェース（FFI）です。</target>
        </trans-unit>
        <trans-unit id="80a6e01d93b27f65515594890e0091001ba7b217" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;feature&lt;/code&gt; attribute only accept a &quot;feature flag&quot; and can only be used on nightly. Example:</source>
          <target state="translated">&lt;code&gt;feature&lt;/code&gt; 属性は、「機能フラグ」を受け入れ、唯一、夜間に使用することができます。例：</target>
        </trans-unit>
        <trans-unit id="36584ecca666e59936c11f071bcfcb0da92fd4b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;feature&lt;/code&gt; attribute was badly formed.</source>
          <target state="translated">&lt;code&gt;feature&lt;/code&gt; 属性がひどく形成されました。</target>
        </trans-unit>
        <trans-unit id="424a7adcc55a187f305df277831d5dda5afa7154" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ffi_const&lt;/code&gt; attribute can only be used on foreign function declarations which have no side effects except for their return value:</source>
          <target state="translated">&lt;code&gt;ffi_const&lt;/code&gt; 属性は、その戻り値以外は副作用を持たない外部関数の宣言に使用することができます。</target>
        </trans-unit>
        <trans-unit id="f9fac3c8fa0259e175ffb5e9aab803c7bd9140ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ffi_const&lt;/code&gt; attribute was used on something other than a foreign function declaration.</source>
          <target state="translated">&lt;code&gt;ffi_const&lt;/code&gt; 属性は、外部関数の宣言以外の何かに使用されました。</target>
        </trans-unit>
        <trans-unit id="bfe6d270783e8b73023767bbcd8ed3a773bacf0d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ffi_pure&lt;/code&gt; attribute can only be used on foreign functions which do not have side effects or infinite loops:</source>
          <target state="translated">&lt;code&gt;ffi_pure&lt;/code&gt; の属性は、副作用や無限ループを持っていない外国の機能に使用することができます。</target>
        </trans-unit>
        <trans-unit id="883b8dfd3c5fc179185e1d061b052f5f3e0fb52a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ffi_pure&lt;/code&gt; attribute was used on a non-foreign function.</source>
          <target state="translated">&lt;code&gt;ffi_pure&lt;/code&gt; 属性は、非外部関数で使用されました。</target>
        </trans-unit>
        <trans-unit id="e96870e73ec5eb32cc1bdf8256711d63dccde7e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fix_incorrect_order&lt;/code&gt; function is in the &lt;code&gt;back_of_house&lt;/code&gt; module, so we can use &lt;code&gt;super&lt;/code&gt; to go to the parent module of &lt;code&gt;back_of_house&lt;/code&gt;, which in this case is &lt;code&gt;crate&lt;/code&gt;, the root. From there, we look for &lt;code&gt;serve_order&lt;/code&gt; and find it. Success! We think the &lt;code&gt;back_of_house&lt;/code&gt; module and the &lt;code&gt;serve_order&lt;/code&gt; function are likely to stay in the same relationship to each other and get moved together should we decide to reorganize the crate&amp;rsquo;s module tree. Therefore, we used &lt;code&gt;super&lt;/code&gt; so we&amp;rsquo;ll have fewer places to update code in the future if this code gets moved to a different module.</source>
          <target state="translated">&lt;code&gt;fix_incorrect_order&lt;/code&gt; の機能はである &lt;code&gt;back_of_house&lt;/code&gt; の我々が使用できるように、モジュール &lt;code&gt;super&lt;/code&gt; の親モジュールに行き &lt;code&gt;back_of_house&lt;/code&gt; この場合で、 &lt;code&gt;crate&lt;/code&gt; 、ルート。そこから &lt;code&gt;serve_order&lt;/code&gt; を探して見つけます。成功！クレートのモジュールツリーを再編成すると、 &lt;code&gt;back_of_house&lt;/code&gt; モジュールと &lt;code&gt;serve_order&lt;/code&gt; 関数は互いに同じ関係を保ち、一緒に移動する可能性が高いと考えています。したがって、このコードを別のモジュールに移動した場合にコードを更新する場所が少なくなるように、 &lt;code&gt;super&lt;/code&gt; を使用しました。</target>
        </trans-unit>
        <trans-unit id="8941a23b194692ed51f3b950de07285880e660a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fn&lt;/code&gt; syntax declares a new function, the parentheses, &lt;code&gt;()&lt;/code&gt;, indicate there are no parameters, and the curly bracket, &lt;code&gt;{&lt;/code&gt;, starts the body of the function.</source>
          <target state="translated">&lt;code&gt;fn&lt;/code&gt; 構文は、新しい機能、かっこ、宣言 &lt;code&gt;()&lt;/code&gt; 、パラメータがない示し、中括弧を、 &lt;code&gt;{&lt;/code&gt; 、関数の本体を開始します。</target>
        </trans-unit>
        <trans-unit id="2ec5406eba98b65177f08bb6b301125802a344f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt; keyword is used in many syntactic locations:</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; キーワードは、多くの構文の場所で使用されます。</target>
        </trans-unit>
        <trans-unit id="f09d76fe1ac31bb0c6ea4013cf20271ea27e1d4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt; loop variable is now named &lt;code&gt;_i&lt;/code&gt;, and the warning no longer appears.</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; ループ変数は、現在の名前はありません &lt;code&gt;_i&lt;/code&gt; 、警告が表示されなくなります。</target>
        </trans-unit>
        <trans-unit id="05236db55a3c27bea79ddd94d4c11b4238339e3a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;forbid&lt;/code&gt; lint setting, like &lt;code&gt;deny&lt;/code&gt;, turns the corresponding compiler warning into a hard error. Unlike &lt;code&gt;deny&lt;/code&gt;, &lt;code&gt;forbid&lt;/code&gt; prevents itself from being overridden by inner attributes.</source>
          <target state="translated">&lt;code&gt;forbid&lt;/code&gt; 糸くずの設定、などの &lt;code&gt;deny&lt;/code&gt; 、ハードエラーに対応したコンパイラの警告をオンにします。 &lt;code&gt;deny&lt;/code&gt; とは異なり、 &lt;code&gt;forbid&lt;/code&gt; はそれ自体が内部属性によって上書きされるのを防ぎます。</target>
        </trans-unit>
        <trans-unit id="4235fdb48267c248121e84a51ecfc4901ad84de8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;format&lt;/code&gt; function takes an &lt;a href=&quot;struct.arguments&quot;&gt;&lt;code&gt;Arguments&lt;/code&gt;&lt;/a&gt; struct and returns the resulting formatted string.</source>
          <target state="translated">&lt;code&gt;format&lt;/code&gt; 関数がとる&lt;a href=&quot;struct.arguments&quot;&gt; &lt;code&gt;Arguments&lt;/code&gt; &lt;/a&gt;構造体を、得られたフォーマットされた文字列を返します。</target>
        </trans-unit>
        <trans-unit id="d0e2c1abc11834d5ec0f9413abedb6a8d1f2b1d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;from&lt;/code&gt; file does not exist.</source>
          <target state="translated">&lt;code&gt;from&lt;/code&gt; ファイルが存在しません。</target>
        </trans-unit>
        <trans-unit id="0c95afec6a5645bced705f13162ada21e2af597c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;from&lt;/code&gt; path is not a file.</source>
          <target state="translated">&lt;code&gt;from&lt;/code&gt; パスはファイルではありません。</target>
        </trans-unit>
        <trans-unit id="6acb8d35118f04b02cccbeee4ae943f064bc37b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;global_allocator&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;global_allocator&lt;/code&gt; の属性</target>
        </trans-unit>
        <trans-unit id="ae2c6463795dadd5e649f9eb12f49008495df3a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hash_builder&lt;/code&gt; passed should implement the &lt;a href=&quot;../../hash/trait.buildhasher&quot;&gt;&lt;code&gt;BuildHasher&lt;/code&gt;&lt;/a&gt; trait for the HashMap to be useful, see its documentation for details.</source>
          <target state="translated">&lt;code&gt;hash_builder&lt;/code&gt; 実装する必要が渡さ&lt;a href=&quot;../../hash/trait.buildhasher&quot;&gt; &lt;code&gt;BuildHasher&lt;/code&gt; の&lt;/a&gt;に有用であることがHashMapのための特性は、詳細については、そのマニュアルを参照してください。</target>
        </trans-unit>
        <trans-unit id="5b0ca98b2928cdd13f0ccd74c40e39e4e68ec9cc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hash_builder&lt;/code&gt; passed should implement the &lt;a href=&quot;../hash/trait.buildhasher&quot;&gt;&lt;code&gt;BuildHasher&lt;/code&gt;&lt;/a&gt; trait for the HashMap to be useful, see its documentation for details.</source>
          <target state="translated">&lt;code&gt;hash_builder&lt;/code&gt; 実装する必要が渡さ&lt;a href=&quot;../hash/trait.buildhasher&quot;&gt; &lt;code&gt;BuildHasher&lt;/code&gt; の&lt;/a&gt;に有用であることがHashMapのための特性は、詳細については、そのマニュアルを参照してください。</target>
        </trans-unit>
        <trans-unit id="c35c9498a5a0a48423b3c0138b12569234cd1c61" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hello_macro_derive&lt;/code&gt; function first converts the &lt;code&gt;input&lt;/code&gt; from a &lt;code&gt;TokenStream&lt;/code&gt; to a data structure that we can then interpret and perform operations on. This is where &lt;code&gt;syn&lt;/code&gt; comes into play. The &lt;code&gt;parse&lt;/code&gt; function in &lt;code&gt;syn&lt;/code&gt; takes a &lt;code&gt;TokenStream&lt;/code&gt; and returns a &lt;code&gt;DeriveInput&lt;/code&gt; struct representing the parsed Rust code. Listing 19-32 shows the relevant parts of the &lt;code&gt;DeriveInput&lt;/code&gt; struct we get from parsing the &lt;code&gt;struct Pancakes;&lt;/code&gt; string:</source>
          <target state="translated">&lt;code&gt;hello_macro_derive&lt;/code&gt; 関数最初の変換 &lt;code&gt;input&lt;/code&gt; から &lt;code&gt;TokenStream&lt;/code&gt; 我々はその後の操作を解釈して実行することができるデータ構造に関する。ここで &lt;code&gt;syn&lt;/code&gt; が登場します。 &lt;code&gt;parse&lt;/code&gt; 関数 &lt;code&gt;syn&lt;/code&gt; かかり &lt;code&gt;TokenStream&lt;/code&gt; 戻る &lt;code&gt;DeriveInput&lt;/code&gt; の解析されたさびコードを表す構造体を。リスト19-32は、 &lt;code&gt;struct Pancakes;&lt;/code&gt; を解析して得られる &lt;code&gt;DeriveInput&lt;/code&gt; 構造体の関連部分を示しています。ストリング：</target>
        </trans-unit>
        <trans-unit id="004c835aa77c1c8e124a5716a58b7a6bffdd04f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hello_macro_derive&lt;/code&gt; function will be called when a user of our library specifies &lt;code&gt;#[derive(HelloMacro)]&lt;/code&gt; on a type. This is possible because we&amp;rsquo;ve annotated the &lt;code&gt;hello_macro_derive&lt;/code&gt; function here with &lt;code&gt;proc_macro_derive&lt;/code&gt; and specified the name, &lt;code&gt;HelloMacro&lt;/code&gt;, which matches our trait name; this is the convention most procedural macros follow.</source>
          <target state="translated">&lt;code&gt;hello_macro_derive&lt;/code&gt; 関数が呼び出されますとき、私たちのライブラリを指定のユーザー &lt;code&gt;#[derive(HelloMacro)]&lt;/code&gt; タイプに。我々は注釈を付けてきたので、これは可能です &lt;code&gt;hello_macro_derive&lt;/code&gt; ここで関数を &lt;code&gt;proc_macro_derive&lt;/code&gt; 、名前、指定 &lt;code&gt;HelloMacro&lt;/code&gt; 当社の特色名と一致します; これは、ほとんどの手続き型マクロが従う規則です。</target>
        </trans-unit>
        <trans-unit id="f6187e2c81223b9029c3a44a9c821bc39754afaa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if let&lt;/code&gt; syntax lets you combine &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt; into a less verbose way to handle values that match one pattern while ignoring the rest. Consider the program in Listing 6-6 that matches on an &lt;code&gt;Option&amp;lt;u8&amp;gt;&lt;/code&gt; value but only wants to execute code if the value is 3.</source>
          <target state="translated">&lt;code&gt;if let&lt;/code&gt; 構文はあなたが結合することができます &lt;code&gt;if&lt;/code&gt; と &lt;code&gt;let&lt;/code&gt; 、残りを無視してのマッチ1パターンというハンドル値への道VERBOSE以下に。リスト6-6の &lt;code&gt;Option&amp;lt;u8&amp;gt;&lt;/code&gt; 値に一致するが、値が3の場合にのみコードを実行するプログラムを考えてみます。</target>
        </trans-unit>
        <trans-unit id="4dd0a50c18a24fd3e6c3d1653fdf8d2add1e5c54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; condition evaluates to a value of &lt;code&gt;3&lt;/code&gt; this time, and Rust throws an error:</source>
          <target state="translated">今回は &lt;code&gt;if&lt;/code&gt; 条件が &lt;code&gt;3&lt;/code&gt; の値に評価され、Rustはエラーをスローします。</target>
        </trans-unit>
        <trans-unit id="3b97788abf2717f652bd87cae2841d2689fe301c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; expression checks whether our value is out of range, tells the user about the problem, and calls &lt;code&gt;continue&lt;/code&gt; to start the next iteration of the loop and ask for another guess. After the &lt;code&gt;if&lt;/code&gt; expression, we can proceed with the comparisons between &lt;code&gt;guess&lt;/code&gt; and the secret number knowing that &lt;code&gt;guess&lt;/code&gt; is between 1 and 100.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 私たちの値が範囲外であるかどうかを表現チェックし、問題をユーザーに伝え、通話は &lt;code&gt;continue&lt;/code&gt; ループの次の反復を開始し、別の推測をお願いします。後 &lt;code&gt;if&lt;/code&gt; 表現、我々は間の比較を進めることができます &lt;code&gt;guess&lt;/code&gt; していることを知っている秘密の数 &lt;code&gt;guess&lt;/code&gt; 1と100の間です。</target>
        </trans-unit>
        <trans-unit id="21d4200f741c0e5d495167ba918e66c0fa127463" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; keyword is used in one other place in Rust, namely as a part of pattern matching itself, allowing patterns such as &lt;code&gt;Some(x) if x &amp;gt; 200&lt;/code&gt; to be used.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; キーワードは、次のようなパターンせる、すなわちそれ自体をパターンマッチングの一部として、錆に一つの他の場所で使用される &lt;code&gt;Some(x) if x &amp;gt; 200&lt;/code&gt; 使用します。</target>
        </trans-unit>
        <trans-unit id="60fa964e136b0f0fd7616e520f7abaf2ebfa7111" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ignore&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;ignore&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="1f363aa597e809eee39b1326a49009f8ed22190d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ignore&lt;/code&gt; attribute may optionally be written with the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to specify a reason why the test is ignored.</source>
          <target state="translated">&lt;code&gt;ignore&lt;/code&gt; 属性が任意に書き込むことができ&lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStrの&lt;/em&gt;&lt;/a&gt;テストは無視される理由を指定する構文。</target>
        </trans-unit>
        <trans-unit id="db8fdc6685b8fc701d318f4f3dec52f0b9a4e868" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;impl Trait&lt;/code&gt; return type captures lifetime parameters that do not appear within the &lt;code&gt;impl Trait&lt;/code&gt; itself.</source>
          <target state="translated">&lt;code&gt;impl Trait&lt;/code&gt; 内に表示されていない戻り値の型キャプチャ寿命パラメータ &lt;code&gt;impl Trait&lt;/code&gt; そのもの。</target>
        </trans-unit>
        <trans-unit id="c9150ca2fdc92a2e0f4ccf4f986d692afa5493d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;impl Trait&lt;/code&gt; syntax is convenient and makes for more concise code in simple cases. The trait bound syntax can express more complexity in other cases. For example, we can have two parameters that implement &lt;code&gt;Summary&lt;/code&gt;. Using the &lt;code&gt;impl Trait&lt;/code&gt; syntax looks like this:</source>
          <target state="translated">&lt;code&gt;impl Trait&lt;/code&gt; 構文が便利であり、簡単な例では、より簡潔なコードになります。特性にバインドされた構文は、他のケースではより複雑になる可能性があります。たとえば、 &lt;code&gt;Summary&lt;/code&gt; を実装する2つのパラメーターを持つことができます。 &lt;code&gt;impl Trait&lt;/code&gt; 構文を使用すると、次のようになります。</target>
        </trans-unit>
        <trans-unit id="778ea7a6b81f5bfa7d87e34cfb75fde414639934" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;impl Trait&lt;/code&gt; syntax works for straightforward cases but is actually syntax sugar for a longer form, which is called a &lt;em&gt;trait bound&lt;/em&gt;; it looks like this:</source>
          <target state="translated">&lt;code&gt;impl Trait&lt;/code&gt; 構文は簡単な例のために動作しますが、実際に呼び出される長いフォーム、シンタックスシュガーで&lt;em&gt;拘束さトレイト&lt;/em&gt;。次のようになります。</target>
        </trans-unit>
        <trans-unit id="2ffdcc0f4b373da2777f00eb0b778b9205836471" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;impl&lt;/code&gt; keyword is primarily used to define implementations on types. Inherent implementations are standalone, while trait implementations are used to implement traits for types, or other traits.</source>
          <target state="translated">&lt;code&gt;impl&lt;/code&gt; のキーワードは、主なタイプの実装を定義するために使用されます。固有の実装はスタンドアロンですが、特性の実装は型の特性またはその他の特性を実装するために使用されます。</target>
        </trans-unit>
        <trans-unit id="49b529510ff41b8ce0e4f03d01af2d0795d82946" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;incoming&lt;/code&gt; method on &lt;code&gt;TcpListener&lt;/code&gt; returns an iterator that gives us a sequence of streams (more specifically, streams of type &lt;code&gt;TcpStream&lt;/code&gt;). A single &lt;em&gt;stream&lt;/em&gt; represents an open connection between the client and the server. A &lt;em&gt;connection&lt;/em&gt; is the name for the full request and response process in which a client connects to the server, the server generates a response, and the server closes the connection. As such, &lt;code&gt;TcpStream&lt;/code&gt; will read from itself to see what the client sent and then allow us to write our response to the stream. Overall, this &lt;code&gt;for&lt;/code&gt; loop will process each connection in turn and produce a series of streams for us to handle.</source>
          <target state="translated">&lt;code&gt;TcpListener&lt;/code&gt; の &lt;code&gt;incoming&lt;/code&gt; メソッドは、一連のストリーム（より具体的には、 &lt;code&gt;TcpStream&lt;/code&gt; タイプのストリーム）を提供するイテレータを返します。単一の&lt;em&gt;ストリーム&lt;/em&gt;は、クライアントとサーバー間のオープン接続を表します。&lt;em&gt;接続は、&lt;/em&gt;クライアントがサーバに接続し、サーバーが応答を生成し、サーバーが接続を閉じるには、完全な要求と応答プロセスの名前です。そのため、 &lt;code&gt;TcpStream&lt;/code&gt; はそれ自体から読み取り、クライアントが送信したものを確認してから、ストリームへの応答を書き込むことができます。全体として、この &lt;code&gt;for&lt;/code&gt; ループは各接続を順番に処理し、処理する一連のストリームを生成します。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3ae3f99054fefa43fcfe679af5b3d84ea2c62ac1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inline&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;inline&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="f0d784eef56974f3daef0d597995f18b5e5f8afb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inline&lt;/code&gt; attribute only supports two arguments:</source>
          <target state="translated">&lt;code&gt;inline&lt;/code&gt; 属性は二つの引数をサポートしています。</target>
        </trans-unit>
        <trans-unit id="bc1a141c850728d98b956fd0716ebc10f9ffb6e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inline&lt;/code&gt; attribute was malformed.</source>
          <target state="translated">&lt;code&gt;inline&lt;/code&gt; 属性の形式が正しくありません。</target>
        </trans-unit>
        <trans-unit id="91c34dfeac33c0fc72de6d1c1ac619e7a9084ef1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;instruction_set&lt;/code&gt; attribute only supports two arguments currently:</source>
          <target state="translated">現在、 &lt;code&gt;instruction_set&lt;/code&gt; 属性は2つの引数のみをサポートしています。</target>
        </trans-unit>
        <trans-unit id="65492eab1824c51df92e478cb44c3823042f292f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;instruction_set&lt;/code&gt; attribute was malformed.</source>
          <target state="translated">&lt;code&gt;instruction_set&lt;/code&gt; の属性が不正な形式でした。</target>
        </trans-unit>
        <trans-unit id="4788ad11ac891125e5295255c9d02cd7b36750e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;isize&lt;/code&gt; type is a signed integer type with the same number of bits as the platform's pointer type. The theoretical upper bound on object and array size is the maximum &lt;code&gt;isize&lt;/code&gt; value. This ensures that &lt;code&gt;isize&lt;/code&gt; can be used to calculate differences between pointers into an object or array and can address every byte within an object along with one byte past the end.</source>
          <target state="translated">&lt;code&gt;isize&lt;/code&gt; タイプは、プラットフォームのポインタ型と同じビット数を有する符号付き整数型です。オブジェクトと配列サイズの理論上の上限は、最大 &lt;code&gt;isize&lt;/code&gt; 値です。これにより、 &lt;code&gt;isize&lt;/code&gt; を使用してオブジェクトまたは配列へのポインター間の差を計算し、オブジェクト内のすべてのバイトを最後の1バイトとともに処理できるようになります。</target>
        </trans-unit>
        <trans-unit id="7d599bd6c4aa9e941662680b3c4cf55e952c7777" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;it_works&lt;/code&gt; function now has a return type, &lt;code&gt;Result&amp;lt;(), String&amp;gt;&lt;/code&gt;. In the body of the function, rather than calling the &lt;code&gt;assert_eq!&lt;/code&gt; macro, we return &lt;code&gt;Ok(())&lt;/code&gt; when the test passes and an &lt;code&gt;Err&lt;/code&gt; with a &lt;code&gt;String&lt;/code&gt; inside when the test fails.</source>
          <target state="translated">&lt;code&gt;it_works&lt;/code&gt; は今、戻り値の型を持つ関数、 &lt;code&gt;Result&amp;lt;(), String&amp;gt;&lt;/code&gt; 。関数の本文では、 &lt;code&gt;assert_eq!&lt;/code&gt; マクロは、我々が戻り &lt;code&gt;Ok(())&lt;/code&gt; 試験を通過したとき &lt;code&gt;Err&lt;/code&gt; と &lt;code&gt;String&lt;/code&gt; テストが失敗したときに内部。</target>
        </trans-unit>
        <trans-unit id="d7cf351f8d0a069e43102c73f4dd09e2f7958bd2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;largest&lt;/code&gt; function has a parameter called &lt;code&gt;list&lt;/code&gt;, which represents any concrete slice of &lt;code&gt;i32&lt;/code&gt; values that we might pass into the function. As a result, when we call the function, the code runs on the specific values that we pass in.</source>
          <target state="translated">&lt;code&gt;largest&lt;/code&gt; 機能は、というパラメータがある &lt;code&gt;list&lt;/code&gt; のいずれかの具体的なスライスを表し、 &lt;code&gt;i32&lt;/code&gt; 我々は関数に渡すかもしれないという値を。その結果、関数を呼び出すと、渡した特定の値に対してコードが実行されます。</target>
        </trans-unit>
        <trans-unit id="29c272390da5b69d23c340bb06b514ca355b63f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;largest_i32&lt;/code&gt; function is the one we extracted in Listing 10-3 that finds the largest &lt;code&gt;i32&lt;/code&gt; in a slice. The &lt;code&gt;largest_char&lt;/code&gt; function finds the largest &lt;code&gt;char&lt;/code&gt; in a slice. The function bodies have the same code, so let&amp;rsquo;s eliminate the duplication by introducing a generic type parameter in a single function.</source>
          <target state="translated">&lt;code&gt;largest_i32&lt;/code&gt; の機能は、最大見つけた私たちは、リスト10-3で抽出されたものです &lt;code&gt;i32&lt;/code&gt; スライスして。 &lt;code&gt;largest_char&lt;/code&gt; の機能は、最大見つかっ &lt;code&gt;char&lt;/code&gt; スライス中を。関数本体のコードは同じなので、単一の関数にジェネリック型パラメーターを導入して重複を排除しましょう。</target>
        </trans-unit>
        <trans-unit id="d1c6673a10646101d9e252f3f63c9d87dc9cd482" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;len&lt;/code&gt; argument is the number of &lt;strong&gt;elements&lt;/strong&gt;, not the number of bytes.</source>
          <target state="translated">&lt;code&gt;len&lt;/code&gt; の引数は数ある&lt;strong&gt;要素&lt;/strong&gt;ではなく、バイト数。</target>
        </trans-unit>
        <trans-unit id="eabd24b648d02186aedafa8c6e64a26cd4789b21" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;let y = 6&lt;/code&gt; statement does not return a value, so there isn&amp;rsquo;t anything for &lt;code&gt;x&lt;/code&gt; to bind to. This is different from what happens in other languages, such as C and Ruby, where the assignment returns the value of the assignment. In those languages, you can write &lt;code&gt;x = y = 6&lt;/code&gt; and have both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; have the value &lt;code&gt;6&lt;/code&gt;; that is not the case in Rust.</source>
          <target state="translated">&lt;code&gt;let y = 6&lt;/code&gt; の文は、値を返さないので、何のために存在しない &lt;code&gt;x&lt;/code&gt; がバインドします。これは、割り当てが割り当ての値を返すCやRubyなどの他の言語で行われる処理とは異なります。これらの言語では、 &lt;code&gt;x = y = 6&lt;/code&gt; と記述して、 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; の両方の値を &lt;code&gt;6&lt;/code&gt; にすることができます。Rustではそうではありません。</target>
        </trans-unit>
        <trans-unit id="38e40fe06999fccdbadcd0aed2907afe5c6e93b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lines&lt;/code&gt; method returns an iterator. We&amp;rsquo;ll talk about iterators in depth in &lt;a href=&quot;ch13-02-iterators&quot;&gt;Chapter 13&lt;/a&gt;, but recall that you saw this way of using an iterator in &lt;a href=&quot;ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt;Listing 3-5&lt;/a&gt;, where we used a &lt;code&gt;for&lt;/code&gt; loop with an iterator to run some code on each item in a collection.</source>
          <target state="translated">&lt;code&gt;lines&lt;/code&gt; 方式は、イテレータを返します。イテレータについては&lt;a href=&quot;ch13-02-iterators&quot;&gt;第13章&lt;/a&gt;で詳しく説明しますが、&lt;a href=&quot;ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt;リスト3-5&lt;/a&gt;でイテレータを使用するこの方法を見たことを思い出してください。ここでは、イテレータで &lt;code&gt;for&lt;/code&gt; ループを使用して、コレクション内の各アイテムでコードを実行しました。</target>
        </trans-unit>
        <trans-unit id="eb368f642161e00040244b9fcf42bf09c020466c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lines&lt;/code&gt; method returns an iterator. We&amp;rsquo;ll talk about iterators in depth in [Chapter 13][ch13], but recall that you saw this way of using an iterator in &lt;a href=&quot;ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt;Listing 3-5&lt;/a&gt;, where we used a &lt;code&gt;for&lt;/code&gt; loop with an iterator to run some code on each item in a collection.</source>
          <target state="translated">&lt;code&gt;lines&lt;/code&gt; 方式は、イテレータを返します。[第13章] [ch13]でイテレータについて詳しく説明しますが、イテレータを使用した &lt;code&gt;for&lt;/code&gt; ループを使用して各項目でコードを実行する&lt;a href=&quot;ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt;リスト3-5で&lt;/a&gt;、イテレータを使用するこの方法を見たことを思い出してください。コレクション内。</target>
        </trans-unit>
        <trans-unit id="eb1d841506acd030675c6922085c83e81e995a8f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;link&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;link&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="49ce3813b3cc29f6621eed5040dfcafe494f7af6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;link_name&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;link_name&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="affa85dfaaac9c19595e178102133ab86d473f6f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;link_name&lt;/code&gt; attribute may be specified on declarations inside an &lt;code&gt;extern&lt;/code&gt; block to indicate the symbol to import for the given function or static. It uses the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to specify the name of the symbol.</source>
          <target state="translated">&lt;code&gt;link_name&lt;/code&gt; 属性は、内部の宣言で指定することができる &lt;code&gt;extern&lt;/code&gt; 所与の機能または静的ためインポートする記号を示すためにブロック。&lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt;構文を使用して、シンボルの名前を指定します。</target>
        </trans-unit>
        <trans-unit id="76e0be66315f639652150dfe37a31422ede56b88" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;link_section&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;link_section&lt;/code&gt; の属性</target>
        </trans-unit>
        <trans-unit id="5d3ac97ce0e51b7500958397678a0747500d6a86" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;locality&lt;/code&gt; argument must be a constant integer and is a temporal locality specifier ranging from (0) - no locality, to (3) - extremely local keep in cache</source>
          <target state="translated">&lt;code&gt;locality&lt;/code&gt; 引数は、一定の整数でなければならず、時間的局所指定子は（0）からの範囲である-キャッシュ内極めてローカルキープ- （3）に、無産地</target>
        </trans-unit>
        <trans-unit id="08d3f68a2cf00952341cb92b2cabeabf4f7aad60" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;locality&lt;/code&gt; argument must be a constant integer and is a temporal locality specifier ranging from (0) - no locality, to (3) - extremely local keep in cache.</source>
          <target state="translated">&lt;code&gt;locality&lt;/code&gt; 引数は定数整数でと（0）に至るまで時間的局所指定子である必要があります- （3）にノー地域、 -キャッシュ内極めてローカルキープ。</target>
        </trans-unit>
        <trans-unit id="ef1c91d4a25bd321565ee99def8880c9e7e661ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;loop&lt;/code&gt; keyword creates an infinite loop. We&amp;rsquo;ll add that now to give users more chances at guessing the number:</source>
          <target state="translated">&lt;code&gt;loop&lt;/code&gt; キーワードは、無限ループを作成します。これを追加して、ユーザーが数字を推測できるようにします。</target>
        </trans-unit>
        <trans-unit id="ebe9e1bcc2f0843b5208a2b5109915be71857732" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;loop&lt;/code&gt; keyword tells Rust to execute a block of code over and over again forever or until you explicitly tell it to stop.</source>
          <target state="translated">&lt;code&gt;loop&lt;/code&gt; キーワードは永遠か、明示的に停止するように指示されるまで何度も何度もコードのブロックを実行するために錆を伝えます。</target>
        </trans-unit>
        <trans-unit id="9910971bdcb643aec0b768364519db2f99d5aff4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;macro_use&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;macro_use&lt;/code&gt; の属性</target>
        </trans-unit>
        <trans-unit id="c25fb9655125d01a5a1e9d67f7f0780bc361281a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;main&lt;/code&gt; function here creates an instance of the &lt;code&gt;ImportantExcerpt&lt;/code&gt; struct that holds a reference to the first sentence of the &lt;code&gt;String&lt;/code&gt; owned by the variable &lt;code&gt;novel&lt;/code&gt;. The data in &lt;code&gt;novel&lt;/code&gt; exists before the &lt;code&gt;ImportantExcerpt&lt;/code&gt; instance is created. In addition, &lt;code&gt;novel&lt;/code&gt; doesn&amp;rsquo;t go out of scope until after the &lt;code&gt;ImportantExcerpt&lt;/code&gt; goes out of scope, so the reference in the &lt;code&gt;ImportantExcerpt&lt;/code&gt; instance is valid.</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; 機能は、ここでのインスタンス作成 &lt;code&gt;ImportantExcerpt&lt;/code&gt; 用の最初の文を参照保持構造体 &lt;code&gt;String&lt;/code&gt; 変数が所有 &lt;code&gt;novel&lt;/code&gt; 。 &lt;code&gt;novel&lt;/code&gt; のデータは、 &lt;code&gt;ImportantExcerpt&lt;/code&gt; インスタンスが作成される前に存在します。さらに、 &lt;code&gt;novel&lt;/code&gt; は &lt;code&gt;ImportantExcerpt&lt;/code&gt; がスコープ外になるまでスコープ外に出ないので、 &lt;code&gt;ImportantExcerpt&lt;/code&gt; インスタンスの参照は有効です。</target>
        </trans-unit>
        <trans-unit id="db5fe1609c8c74f709a4f1880a24bb8f27550e1d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;main&lt;/code&gt; function is special, and there are restrictions on what its return type must be. One valid return type for main is &lt;code&gt;()&lt;/code&gt;, and conveniently, another valid return type is &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;, as shown here:</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; 機能は特別であり、その戻り値の型でなければなりません何に制限があります。次に示すように、mainの1つの有効な戻り値の型は &lt;code&gt;()&lt;/code&gt; であり、別の有効な戻り値の型は &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="df8be9695315286ea699a84bc57bf274e0dcbb5a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;main&lt;/code&gt; function prototype should never take arguments. Example:</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; 関数のプロトタイプは引数を取ることはありません。例：</target>
        </trans-unit>
        <trans-unit id="db6afd48cca2e467a026116d5334792843766266" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;main&lt;/code&gt; function was defined with generic parameters.</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; 機能は、一般的なパラメータで定義されました。</target>
        </trans-unit>
        <trans-unit id="b77f7c754f9c38d3041a1e299a31ef7eeecfa144" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;main&lt;/code&gt; function was incorrectly declared.</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; 機能は、間違って宣言されました。</target>
        </trans-unit>
        <trans-unit id="43e2fa6b27c55d262177050d71a4a20b71217bb8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;move&lt;/code&gt; closure is often used alongside &lt;code&gt;thread::spawn&lt;/code&gt; because it allows you to use data from one thread in another thread.</source>
          <target state="translated">&lt;code&gt;move&lt;/code&gt; 閉鎖はしばしば一緒に使用されている &lt;code&gt;thread::spawn&lt;/code&gt; 、それはあなたが別のスレッド内の1つのスレッドからのデータを使用することができますので。</target>
        </trans-unit>
        <trans-unit id="619f2d182d04cd2437b9280f0034a655e725227f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mpsc::channel&lt;/code&gt; function returns a tuple, the first element of which is the sending end and the second element is the receiving end. The abbreviations &lt;code&gt;tx&lt;/code&gt; and &lt;code&gt;rx&lt;/code&gt; are traditionally used in many fields for &lt;em&gt;transmitter&lt;/em&gt; and &lt;em&gt;receiver&lt;/em&gt; respectively, so we name our variables as such to indicate each end. We&amp;rsquo;re using a &lt;code&gt;let&lt;/code&gt; statement with a pattern that destructures the tuples; we&amp;rsquo;ll discuss the use of patterns in &lt;code&gt;let&lt;/code&gt; statements and destructuring in Chapter 18. Using a &lt;code&gt;let&lt;/code&gt; statement this way is a convenient approach to extract the pieces of the tuple returned by &lt;code&gt;mpsc::channel&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mpsc::channel&lt;/code&gt; 機能は、送信端部および第2の要素である最初の要素は、受信端であり、タプルを返します。短縮形の &lt;code&gt;tx&lt;/code&gt; と &lt;code&gt;rx&lt;/code&gt; は、伝統的にそれぞれ&lt;em&gt;送信機&lt;/em&gt;と&lt;em&gt;受信機の&lt;/em&gt;多くのフィールドで使用されているため、それぞれの終わりを示すために変数に名前を付けています。タプルを分解するパターンを持つ &lt;code&gt;let&lt;/code&gt; ステートメントを使用しています。 &lt;code&gt;let&lt;/code&gt; ステートメントでのパターンの使用と構造化については、第18章で説明します。このように &lt;code&gt;let&lt;/code&gt; ステートメントを使用すると、 &lt;code&gt;mpsc::channel&lt;/code&gt; によって返されるタプルの断片を抽出するのに便利です。</target>
        </trans-unit>
        <trans-unit id="0a5adaf35abd6fb52abc875dfd1ff8ace4487057" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;must_use&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;must_use&lt;/code&gt; の属性</target>
        </trans-unit>
        <trans-unit id="4dc21fbdabdadeb25794ca5fcb0a8eb690cc55f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;must_use&lt;/code&gt; attribute may include a message by using the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax such as &lt;code&gt;#[must_use = &quot;example message&quot;]&lt;/code&gt;. The message will be given alongside the warning.</source>
          <target state="translated">&lt;code&gt;must_use&lt;/code&gt; の属性を使用してメッセージを含んでいてもよい&lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt;構文など &lt;code&gt;#[must_use = &quot;example message&quot;]&lt;/code&gt; 。メッセージは警告とともに表示されます。</target>
        </trans-unit>
        <trans-unit id="fa08dd7bde9ed9336c6bf68b835c76ace5a2b281" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name&lt;/code&gt; key must be included if &lt;code&gt;kind&lt;/code&gt; is specified.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 場合はキーが含まれていなければならない &lt;code&gt;kind&lt;/code&gt; 指定されています。</target>
        </trans-unit>
        <trans-unit id="4f5d61c5238b80d1372117cdc9301f7c5a015909" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_builtins&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;no_builtins&lt;/code&gt; の属性</target>
        </trans-unit>
        <trans-unit id="0e25b9ca8aa17342df965438e7d8b3912387ac96" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_link&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;no_link&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="4c0b9a2602cdb8c2f59fe6476a9d0299ede88a3c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_main&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;no_main&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="63ed748c3f1f47aec501358b0494a62e8e33119a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_mangle&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;no_mangle&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="3db3cdb5f8ea826a09ba97c6a8d286d70aec5a65" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;non_exhaustive&lt;/code&gt; attribute uses the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaWord&lt;/em&gt;&lt;/a&gt; syntax and thus does not take any inputs.</source>
          <target state="translated">&lt;code&gt;non_exhaustive&lt;/code&gt; 属性は使用しています&lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaWordの&lt;/em&gt;&lt;/a&gt;構文を、したがって、任意の入力を取ることはありません。</target>
        </trans-unit>
        <trans-unit id="f6746e3c0ec6ce06b907e0392a7e5f26c1647e02" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;not&lt;/code&gt; cfg-predicate was malformed.</source>
          <target state="translated">&lt;code&gt;not&lt;/code&gt; CFG-述語の形式が正しくありません。</target>
        </trans-unit>
        <trans-unit id="522f2fe5c8ca134ded384cd8e598baad904cbb06" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;not&lt;/code&gt; predicate expects one cfg-pattern. Example:</source>
          <target state="translated">&lt;code&gt;not&lt;/code&gt; 述語を期待1つのCFG-パターン。例：</target>
        </trans-unit>
        <trans-unit id="b32d84af66b0734455999894598a8249aed66fbb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;number&lt;/code&gt; variable will be bound to a value based on the outcome of the &lt;code&gt;if&lt;/code&gt; expression. Run this code to see what happens:</source>
          <target state="translated">&lt;code&gt;number&lt;/code&gt; 変数は、の結果に基づいた値にバインドされる &lt;code&gt;if&lt;/code&gt; 表現。このコードを実行して、何が起こるかを確認します。</target>
        </trans-unit>
        <trans-unit id="60fb1fa966c95caff6ec3f67558fb81ff746c1d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;op_string_ref&lt;/code&gt; binding has type &lt;code&gt;&amp;amp;Option&amp;lt;&amp;amp;String&amp;gt;&lt;/code&gt; in both cases.</source>
          <target state="translated">&lt;code&gt;op_string_ref&lt;/code&gt; 結合はタイプがある &lt;code&gt;&amp;amp;Option&amp;lt;&amp;amp;String&amp;gt;&lt;/code&gt; 両方のケースでは。</target>
        </trans-unit>
        <trans-unit id="2d0c9a8f467995322cb26a15b43a2ed10bd928bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;opt-level&lt;/code&gt; setting controls the number of optimizations Rust will apply to your code, with a range of 0 to 3. Applying more optimizations extends compiling time, so if you&amp;rsquo;re in development and compiling your code often, you&amp;rsquo;ll want faster compiling even if the resulting code runs slower. That is the reason the default &lt;code&gt;opt-level&lt;/code&gt; for &lt;code&gt;dev&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;. When you&amp;rsquo;re ready to release your code, it&amp;rsquo;s best to spend more time compiling. You&amp;rsquo;ll only compile in release mode once, but you&amp;rsquo;ll run the compiled program many times, so release mode trades longer compile time for code that runs faster. That is why the default &lt;code&gt;opt-level&lt;/code&gt; for the &lt;code&gt;release&lt;/code&gt; profile is &lt;code&gt;3&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;opt-level&lt;/code&gt; あなたが開発中だと、多くの場合、あなたのコードをコンパイルした場合ので、あなたがより速くたいと思う、錆がより多くの最適化を適用するに0〜3の範囲で、あなたのコードに適用される最適化の数が時間をコンパイルする拡張コントロールを設定します結果のコードの実行速度が遅くてもコンパイルします。これはデフォルトの理由である &lt;code&gt;opt-level&lt;/code&gt; のための &lt;code&gt;dev&lt;/code&gt; ある &lt;code&gt;0&lt;/code&gt; 。コードをリリースする準備ができたら、コンパイルにより多くの時間を費やすのが最善です。リリースモードでコンパイルするのは1回だけですが、コンパイルしたプログラムを何度も実行するため、リリースモードではコンパイル時間が長くなり、コードの実行速度が速くなります。そのため、 &lt;code&gt;release&lt;/code&gt; プロファイルのデフォルトの &lt;code&gt;opt-level&lt;/code&gt; は &lt;code&gt;3&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="6a0e04095b896f42634e32e5783ee8a2f1b36521" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;or_insert&lt;/code&gt; method on &lt;code&gt;Entry&lt;/code&gt; is defined to return a mutable reference to the value for the corresponding &lt;code&gt;Entry&lt;/code&gt; key if that key exists, and if not, inserts the parameter as the new value for this key and returns a mutable reference to the new value. This technique is much cleaner than writing the logic ourselves and, in addition, plays more nicely with the borrow checker.</source>
          <target state="translated">&lt;code&gt;Entry&lt;/code&gt; の &lt;code&gt;or_insert&lt;/code&gt; メソッドは、対応する &lt;code&gt;Entry&lt;/code&gt; キーの値への変更可能な参照を返すように定義されています（存在する場合）。そのキーが存在する場合は、このキーの新しい値としてパラメーターを挿入し、新しい値への変更可能な参照を返します。この手法は、自分でロジックを記述するよりもはるかにクリーンであり、さらに、借用チェッカーでよりうまく機能します。</target>
        </trans-unit>
        <trans-unit id="6774c9469b6011fbcb32c16aad7d03e8b6f6c4d5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;panic_handler&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;panic_handler&lt;/code&gt; の属性</target>
        </trans-unit>
        <trans-unit id="a6291890b4261d452b074ebd1ea09861364cf569" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;path&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="eca9cdb5a96c8de323e434d012e339f61d08ae9a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;path&lt;/code&gt; points at a non-directory file.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 非ディレクトリファイルのポイント。</target>
        </trans-unit>
        <trans-unit id="34ed0df01305ce0f75ec5fd43922003af97a525e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;poll&lt;/code&gt; function is not called repeatedly in a tight loop -- instead, it should only be called when the future indicates that it is ready to make progress (by calling &lt;code&gt;wake()&lt;/code&gt;). If you're familiar with the &lt;code&gt;poll(2)&lt;/code&gt; or &lt;code&gt;select(2)&lt;/code&gt; syscalls on Unix it's worth noting that futures typically do &lt;em&gt;not&lt;/em&gt; suffer the same problems of &quot;all wakeups must poll all events&quot;; they are more like &lt;code&gt;epoll(4)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;poll&lt;/code&gt; 機能がタイトループ内で繰り返し呼び出されていない-代わりに、それは唯一と呼ばれるべき将来は進歩を遂げる準備ができていることを示している場合（呼び出すことによって &lt;code&gt;wake()&lt;/code&gt; ）。Unixでの &lt;code&gt;poll(2)&lt;/code&gt; または &lt;code&gt;select(2)&lt;/code&gt; の syscallsに精通している場合、フューチャーは通常、「すべてのウェイクアップですべてのイベントをポーリングする必要がある」という同じ問題に悩まされ&lt;em&gt;ない&lt;/em&gt;ことに注意してください。それらは &lt;code&gt;epoll(4)&lt;/code&gt; に似ています。</target>
        </trans-unit>
        <trans-unit id="a4cdf57409266ff4ceaefa41a5aa6a9d06ca0f60" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;poll&lt;/code&gt; method</source>
          <target state="translated">&lt;code&gt;poll&lt;/code&gt; 方法</target>
        </trans-unit>
        <trans-unit id="f69f8390bb6f3d4deb2545de4fdfa29877369556" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prefetch&lt;/code&gt; intrinsic is a hint to the code generator to insert a prefetch instruction if supported; otherwise, it is a no-op. Prefetches have no effect on the behavior of the program but can change its performance characteristics.</source>
          <target state="translated">&lt;code&gt;prefetch&lt;/code&gt; 真性はサポートされている場合、プリフェッチ命令を挿入するコードジェネレータへのヒントです。それ以外の場合は、何もしません。プリフェッチはプログラムの動作には影響しませんが、パフォーマンス特性を変更する可能性があります。</target>
        </trans-unit>
        <trans-unit id="fa7fa9cd2241a28cad4fa12a2f135f7ef3c12daf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;println!&lt;/code&gt; function is only capable of printing to standard output, so we have to use something else to print to standard error.</source>
          <target state="translated">&lt;code&gt;println!&lt;/code&gt; 関数は標準出力にのみ出力できるため、標準エラーに出力するには別のものを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="f554c0d8cd003f0dac64077248339772aef74465" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;println!&lt;/code&gt; macro can do many kinds of formatting, and by default, the curly brackets tell &lt;code&gt;println!&lt;/code&gt; to use formatting known as &lt;code&gt;Display&lt;/code&gt;: output intended for direct end user consumption. The primitive types we&amp;rsquo;ve seen so far implement &lt;code&gt;Display&lt;/code&gt; by default, because there&amp;rsquo;s only one way you&amp;rsquo;d want to show a &lt;code&gt;1&lt;/code&gt; or any other primitive type to a user. But with structs, the way &lt;code&gt;println!&lt;/code&gt; should format the output is less clear because there are more display possibilities: Do you want commas or not? Do you want to print the curly brackets? Should all the fields be shown? Due to this ambiguity, Rust doesn&amp;rsquo;t try to guess what we want, and structs don&amp;rsquo;t have a provided implementation of &lt;code&gt;Display&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;println!&lt;/code&gt; マクロは多くの種類のフォーマットを行うことができ、デフォルトでは、中括弧は &lt;code&gt;println!&lt;/code&gt; &lt;code&gt;Display&lt;/code&gt; と呼ばれるフォーマットを使用するには、直接エンドユーザーが使用することを目的とした出力。これまで見てきたプリミティブ型は、デフォルトで &lt;code&gt;Display&lt;/code&gt; を実装します。これは、ユーザーに &lt;code&gt;1&lt;/code&gt; またはその他のプリミティブ型を表示する方法が1つしかないためです。しかし、構造体では、方法 &lt;code&gt;println!&lt;/code&gt; より多くの表示の可能性があるため、出力のフォーマットはあまり明確ではないはずです：コンマが必要かどうか？中かっこを印刷しますか？すべてのフィールドを表示する必要がありますか？このあいまいさのため、Rustは私たちが何を望んでいるかを推測しようとせず、構造体には提供された実装がありません &lt;code&gt;Display&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="02931ec361bbc5f61952272ead50c2b1cc721cb3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;println!&lt;/code&gt; macro is only capable of printing to standard output, so we have to use something else to print to standard error.</source>
          <target state="translated">&lt;code&gt;println!&lt;/code&gt; マクロは標準出力にしか印刷できないため、標準エラーに印刷するには別のものを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="df3a7253c874e9c54aed370b97b0410e823ccbd2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;proc_macro&lt;/code&gt; crate</source>
          <target state="translated">&lt;code&gt;proc_macro&lt;/code&gt; クレート</target>
        </trans-unit>
        <trans-unit id="0ebc19fdeafa41e303e045832093f26b01f1011c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pub&lt;/code&gt; keyword was used inside a function.</source>
          <target state="translated">&lt;code&gt;pub&lt;/code&gt; キーワードは、関数の内部で使用されました。</target>
        </trans-unit>
        <trans-unit id="a4aeb159d9e69df04b16b32d0a540b4e48d1c2ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pub&lt;/code&gt; keyword was used inside a function. Erroneous code example:</source>
          <target state="translated">&lt;code&gt;pub&lt;/code&gt; キーワードは、関数の内部で使用されました。誤ったコード例：</target>
        </trans-unit>
        <trans-unit id="b670fe1e664ec6db0ea27f497b8f300d96565afa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pub&lt;/code&gt; keyword was used inside a public enum.</source>
          <target state="translated">&lt;code&gt;pub&lt;/code&gt; キーワードは、パブリック列挙型の内部で使用されました。</target>
        </trans-unit>
        <trans-unit id="d36ebedc5c61f3368fb308364706ea53f77e634b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pub&lt;/code&gt; keyword was used inside a public enum. Erroneous code example:</source>
          <target state="translated">&lt;code&gt;pub&lt;/code&gt; キーワードは、パブリック列挙型の内部で使用されました。誤ったコード例：</target>
        </trans-unit>
        <trans-unit id="855c30613293c5803da1be19530bcff46d089f73" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;push&lt;/code&gt; method takes a single character as a parameter and adds it to the &lt;code&gt;String&lt;/code&gt;. Listing 8-17 shows code that adds the letter &lt;em&gt;l&lt;/em&gt; to a &lt;code&gt;String&lt;/code&gt; using the &lt;code&gt;push&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;push&lt;/code&gt; メソッドは、パラメータとして単一の文字を取り、それを追加します &lt;code&gt;String&lt;/code&gt; 。リスト8-17は、 &lt;code&gt;push&lt;/code&gt; メソッドを使用して文字&lt;em&gt;l&lt;/em&gt;を &lt;code&gt;String&lt;/code&gt; 追加するコードを示しています。</target>
        </trans-unit>
        <trans-unit id="e7c0b086ee3b65e9ef7299c70cf8f6fd0c56999e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;quote!&lt;/code&gt; macro also provides some very cool templating mechanics: we can enter &lt;code&gt;#name&lt;/code&gt;, and &lt;code&gt;quote!&lt;/code&gt; will replace it with the value in the variable &lt;code&gt;name&lt;/code&gt;. You can even do some repetition similar to the way regular macros work. Check out &lt;a href=&quot;https://docs.rs/quote&quot;&gt;the &lt;code&gt;quote&lt;/code&gt; crate&amp;rsquo;s docs&lt;/a&gt; for a thorough introduction.</source>
          <target state="translated">&lt;code&gt;quote!&lt;/code&gt; マクロは、いくつかの非常に優れたテンプレートメカニズムも提供し &lt;code&gt;quote!&lt;/code&gt; &lt;code&gt;#name&lt;/code&gt; を入力して、引用することができます！変数 &lt;code&gt;name&lt;/code&gt; 値に置き換えます。通常のマクロと同じように、繰り返しを行うこともできます。チェックアウト&lt;a href=&quot;https://docs.rs/quote&quot;&gt; &lt;code&gt;quote&lt;/code&gt; &lt;/a&gt;クレートのドキュメントを徹底的に紹介するために。</target>
        </trans-unit>
        <trans-unit id="62ab310a7862369bfdb3998e805adaae0cd4f2e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;quote!&lt;/code&gt; macro lets us define the Rust code that we want to return. The compiler expects something different to the direct result of the &lt;code&gt;quote!&lt;/code&gt; macro&amp;rsquo;s execution, so we need to convert it to a &lt;code&gt;TokenStream&lt;/code&gt;. We do this by calling the &lt;code&gt;into&lt;/code&gt; method, which consumes this intermediate representation and returns a value of the required &lt;code&gt;TokenStream&lt;/code&gt; type.</source>
          <target state="translated">&lt;code&gt;quote!&lt;/code&gt; マクロを使用すると、返すRustコードを定義できます。コンパイラは、 &lt;code&gt;quote!&lt;/code&gt; 直接の結果とは異なるものを期待しています！マクロの実行なので、それを &lt;code&gt;TokenStream&lt;/code&gt; に変換する必要があります。これを行うには、 &lt;code&gt;into&lt;/code&gt; メソッドを呼び出します。これにより、この中間表現が消費され、必要な &lt;code&gt;TokenStream&lt;/code&gt; タイプの値が返されます。</target>
        </trans-unit>
        <trans-unit id="53ae9c1c1e33423bee13e403e332e75689959214" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ready!&lt;/code&gt; call expands to:</source>
          <target state="translated">&lt;code&gt;ready!&lt;/code&gt; 呼び出しは次のように展開されます。</target>
        </trans-unit>
        <trans-unit id="b83941e960f12671a681a1df28d6d59cb442a02e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;recursion_limit&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;recursion_limit&lt;/code&gt; の属性</target>
        </trans-unit>
        <trans-unit id="7fd3ec074e9dd99ae0db784fdf399ea43dd43516" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ref&lt;/code&gt; and/or &lt;code&gt;mut&lt;/code&gt;&lt;em&gt;IDENTIFIER&lt;/em&gt; syntax matches any value and binds it to a variable with the same name as the given field.</source>
          <target state="translated">&lt;code&gt;ref&lt;/code&gt; および/または &lt;code&gt;mut&lt;/code&gt; &lt;em&gt;IDENTIFIERの&lt;/em&gt;構文は、指定されたフィールドと同じ名前の変数に任意の値とバインドそれにマッチします。</target>
        </trans-unit>
        <trans-unit id="a07e646920bfd0169ef8462620bb6bf857e50545" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;repeat()&lt;/code&gt; function repeats a single value over and over again.</source>
          <target state="translated">&lt;code&gt;repeat()&lt;/code&gt; 関数は、何度も何度も単一の値を繰り返します。</target>
        </trans-unit>
        <trans-unit id="ca6b7fab269378f975039696a9d029f43743fe55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;repeat_with()&lt;/code&gt; function calls the repeater over and over again.</source>
          <target state="translated">&lt;code&gt;repeat_with()&lt;/code&gt; 関数は、何度も何度もリピーターを呼び出します。</target>
        </trans-unit>
        <trans-unit id="203b4d4e0f959a4e516770bf1c8acd411f9645d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;request_review&lt;/code&gt; and &lt;code&gt;approve&lt;/code&gt; methods take ownership of &lt;code&gt;self&lt;/code&gt;, thus consuming the &lt;code&gt;DraftPost&lt;/code&gt; and &lt;code&gt;PendingReviewPost&lt;/code&gt; instances and transforming them into a &lt;code&gt;PendingReviewPost&lt;/code&gt; and a published &lt;code&gt;Post&lt;/code&gt;, respectively. This way, we won&amp;rsquo;t have any lingering &lt;code&gt;DraftPost&lt;/code&gt; instances after we&amp;rsquo;ve called &lt;code&gt;request_review&lt;/code&gt; on them, and so forth. The &lt;code&gt;PendingReviewPost&lt;/code&gt; struct doesn&amp;rsquo;t have a &lt;code&gt;content&lt;/code&gt; method defined on it, so attempting to read its content results in a compiler error, as with &lt;code&gt;DraftPost&lt;/code&gt;. Because the only way to get a published &lt;code&gt;Post&lt;/code&gt; instance that does have a &lt;code&gt;content&lt;/code&gt; method defined is to call the &lt;code&gt;approve&lt;/code&gt; method on a &lt;code&gt;PendingReviewPost&lt;/code&gt;, and the only way to get a &lt;code&gt;PendingReviewPost&lt;/code&gt; is to call the &lt;code&gt;request_review&lt;/code&gt; method on a &lt;code&gt;DraftPost&lt;/code&gt;, we&amp;rsquo;ve now encoded the blog post workflow into the type system.</source>
          <target state="translated">&lt;code&gt;request_review&lt;/code&gt; および &lt;code&gt;approve&lt;/code&gt; 方法は、所有権の取る &lt;code&gt;self&lt;/code&gt; このように消費し、 &lt;code&gt;DraftPost&lt;/code&gt; と &lt;code&gt;PendingReviewPost&lt;/code&gt; インスタンスをとにそれらを変換 &lt;code&gt;PendingReviewPost&lt;/code&gt; し、公表 &lt;code&gt;Post&lt;/code&gt; 、それぞれ。このようにして、 &lt;code&gt;request_review&lt;/code&gt; を呼び出した後に、 &lt;code&gt;DraftPost&lt;/code&gt; インスタンスが残っていることはありません。 &lt;code&gt;PendingReviewPost&lt;/code&gt; の構造体は持っていない &lt;code&gt;content&lt;/code&gt; そうと同様に、コンパイラエラーでそのコンテンツの結果を読み取ろうとし、その上で定義されたメソッドを &lt;code&gt;DraftPost&lt;/code&gt; 。公開された &lt;code&gt;Post&lt;/code&gt; を取得する唯一の方法は &lt;code&gt;content&lt;/code&gt; メソッドが定義されているインスタンスは、 &lt;code&gt;PendingReviewPost&lt;/code&gt; で &lt;code&gt;approve&lt;/code&gt; メソッドを呼び出すことであり、 &lt;code&gt;PendingReviewPost&lt;/code&gt; を取得する唯一の方法は、 &lt;code&gt;DraftPost&lt;/code&gt; で &lt;code&gt;request_review&lt;/code&gt; メソッドを呼び出すことです。これで、ブログ投稿ワークフローを型システムにエンコードしました。</target>
        </trans-unit>
        <trans-unit id="14e654a0e6edb832d7ec2e9f01e2cec2e8fc8293" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;request_review&lt;/code&gt; method on &lt;code&gt;Draft&lt;/code&gt; needs to return a new, boxed instance of a new &lt;code&gt;PendingReview&lt;/code&gt; struct, which represents the state when a post is waiting for a review. The &lt;code&gt;PendingReview&lt;/code&gt; struct also implements the &lt;code&gt;request_review&lt;/code&gt; method but doesn&amp;rsquo;t do any transformations. Rather, it returns itself, because when we request a review on a post already in the &lt;code&gt;PendingReview&lt;/code&gt; state, it should stay in the &lt;code&gt;PendingReview&lt;/code&gt; state.</source>
          <target state="translated">&lt;code&gt;Draft&lt;/code&gt; の &lt;code&gt;request_review&lt;/code&gt; メソッドは、新しい &lt;code&gt;PendingReview&lt;/code&gt; 構造体の新しいボックス化されたインスタンスを返す必要があります。これは、投稿がレビューを待っているときの状態を表します。 &lt;code&gt;PendingReview&lt;/code&gt; の構造体はまた、実装 &lt;code&gt;request_review&lt;/code&gt; の方法をが、任意の変換を行いません。我々はすでにポストに審査を要求したときのでむしろ、それは、自分自身を返し &lt;code&gt;PendingReview&lt;/code&gt; の状態、それが中にとどまるべき &lt;code&gt;PendingReview&lt;/code&gt; の状態。</target>
        </trans-unit>
        <trans-unit id="e74e1506742074d3eac6be2b7d8e21235520da47" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;run&lt;/code&gt; command comes in handy when you need to rapidly iterate on a project, as we&amp;rsquo;ll do in this game, quickly testing each iteration before moving on to the next one.</source>
          <target state="translated">&lt;code&gt;run&lt;/code&gt; あなたは、私たちはすぐに次の1に移動する前に各反復をテストし、このゲームでやるように急速、プロジェクトに反復処理する必要がある場合、コマンドは便利です。</target>
        </trans-unit>
        <trans-unit id="46e85b1a08cc19eee77379933feec0b53082268f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;run&lt;/code&gt; function definition</source>
          <target state="translated">&lt;code&gt;run&lt;/code&gt; 関数の定義</target>
        </trans-unit>
        <trans-unit id="5e5f409e03a8829700c6b7a5a46ab61b65379877" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;run&lt;/code&gt; function now contains all the remaining logic from &lt;code&gt;main&lt;/code&gt;, starting from reading the file. The &lt;code&gt;run&lt;/code&gt; function takes the &lt;code&gt;Config&lt;/code&gt; instance as an argument.</source>
          <target state="translated">&lt;code&gt;run&lt;/code&gt; 機能は、今から残りのすべてのロジックが含まれている &lt;code&gt;main&lt;/code&gt; ファイルの読み込みから始め、。 &lt;code&gt;run&lt;/code&gt; 機能は取り &lt;code&gt;Config&lt;/code&gt; 引数としてインスタンスを。</target>
        </trans-unit>
        <trans-unit id="6fc1541b8f6585c0ffe5cd745827dfb79f574e45" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rustfmt&lt;/code&gt; tool reformats your code according to the community code style. Many collaborative projects use &lt;code&gt;rustfmt&lt;/code&gt; to prevent arguments about which style to use when writing Rust: everyone formats their code using the tool.</source>
          <target state="translated">&lt;code&gt;rustfmt&lt;/code&gt; のツールは、コミュニティのコードスタイルに応じて、あなたのコードを再フォーマットします。多くの共同プロジェクトは &lt;code&gt;rustfmt&lt;/code&gt; を使用して、Rustの作成時に使用するスタイルに関する引数を防止しています。誰もがツールを使用してコードをフォーマットしています。</target>
        </trans-unit>
        <trans-unit id="f41fbdae4087d677734daccb36bd68168ac22c54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;same_bucket&lt;/code&gt; function is passed references to two elements from the slice and must determine if the elements compare equal. The elements are passed in opposite order from their order in the slice, so if &lt;code&gt;same_bucket(a, b)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt; is moved at the end of the slice.</source>
          <target state="translated">&lt;code&gt;same_bucket&lt;/code&gt; の機能は、スライスからの二つの要素への参照を渡され、要素が等しい比較するかどうかを決定しなければなりません。要素はスライス内の順序とは逆の順序で渡されるため、 &lt;code&gt;same_bucket(a, b)&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; を返す場合、 &lt;code&gt;a&lt;/code&gt; はスライスの最後に移動します。</target>
        </trans-unit>
        <trans-unit id="51106981f7e1a09193991d8a2ebd9672888c0e0a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;same_bucket&lt;/code&gt; function is passed references to two elements from the vector and must determine if the elements compare equal. The elements are passed in opposite order from their order in the slice, so if &lt;code&gt;same_bucket(a, b)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt; is removed.</source>
          <target state="translated">&lt;code&gt;same_bucket&lt;/code&gt; の機能は、ベクターからの二つの要素への参照を渡され、要素が等しい比較するかどうかを決定しなければなりません。要素はスライス内の順序とは逆の順序で渡されるため、 &lt;code&gt;same_bucket(a, b)&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; を返す場合、 &lt;code&gt;a&lt;/code&gt; は削除されます。</target>
        </trans-unit>
        <trans-unit id="a14ee345d1496dff6fbc5e218ae3b33c17f09dd5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;search_case_insensitive&lt;/code&gt; function, shown in Listing 12-21, will be almost the same as the &lt;code&gt;search&lt;/code&gt; function. The only difference is that we&amp;rsquo;ll lowercase the &lt;code&gt;query&lt;/code&gt; and each &lt;code&gt;line&lt;/code&gt; so whatever the case of the input arguments, they&amp;rsquo;ll be the same case when we check whether the line contains the query.</source>
          <target state="translated">&lt;code&gt;search_case_insensitive&lt;/code&gt; リスト12-21で示される機能は、ほぼ同じになり &lt;code&gt;search&lt;/code&gt; 機能。唯一の違いは、我々は小文字だろうということで &lt;code&gt;query&lt;/code&gt; 、各 &lt;code&gt;line&lt;/code&gt; どんな入力引数の場合ので、我々は行がクエリが含まれているかどうかを確認するとき、彼らは同じケースになるでしょう。</target>
        </trans-unit>
        <trans-unit id="bbcc387564e51cca06178b88f2766991af78a4d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; crate may be imported which creates a binding to the current crate. In this case the &lt;code&gt;as&lt;/code&gt; clause must be used to specify the name to bind it to.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; クレート現在クレートへの結合を作成するインポートすることができます。この場合、 &lt;code&gt;as&lt;/code&gt; 句を使用して、バインド先の名前を指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="5df3512b09c8677b58f509f70a4092543dbb8630" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; import appears more than once in the list.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; インポートは、リスト内の複数回表示されます。</target>
        </trans-unit>
        <trans-unit id="776137337eaf5141c6cf75f1ef731869806d23fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; keyword can only be used inside methods, which are associated functions (functions defined inside of a &lt;code&gt;trait&lt;/code&gt; or &lt;code&gt;impl&lt;/code&gt; block) that have a &lt;code&gt;self&lt;/code&gt; receiver as its first parameter, like &lt;code&gt;self&lt;/code&gt;, &lt;code&gt;&amp;amp;self&lt;/code&gt;, &lt;code&gt;&amp;amp;mut self&lt;/code&gt; or &lt;code&gt;self: &amp;amp;mut Pin&amp;lt;Self&amp;gt;&lt;/code&gt; (this last one is an example of an &lt;a href=&quot;https://github.com/rust-lang/rust/issues/44874&quot;&gt;&quot;abitrary &lt;code&gt;self&lt;/code&gt; type&quot;&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; キーワードのみ機能（の内部定義された関数関連付けられているメソッド、内部で使用することができる &lt;code&gt;trait&lt;/code&gt; または &lt;code&gt;impl&lt;/code&gt; 有するブロック）を &lt;code&gt;self&lt;/code&gt; のように、最初のパラメータとしての受信機を &lt;code&gt;self&lt;/code&gt; 、 &lt;code&gt;&amp;amp;self&lt;/code&gt; 、 &lt;code&gt;&amp;amp;mut self&lt;/code&gt; 又は &lt;code&gt;self: &amp;amp;mut Pin&amp;lt;Self&amp;gt;&lt;/code&gt; （この最後のものは例である&lt;a href=&quot;https://github.com/rust-lang/rust/issues/44874&quot;&gt;「abitrary &lt;code&gt;self&lt;/code&gt; タイプ」&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="31848a0c1be52494be53b5a9553dbe8630cef51b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; keyword can only be used inside methods, which are associated functions (functions defined inside of a &lt;code&gt;trait&lt;/code&gt; or &lt;code&gt;impl&lt;/code&gt; block) that have a &lt;code&gt;self&lt;/code&gt; receiver as its first parameter, like &lt;code&gt;self&lt;/code&gt;, &lt;code&gt;&amp;amp;self&lt;/code&gt;, &lt;code&gt;&amp;amp;mut self&lt;/code&gt; or &lt;code&gt;self: &amp;amp;mut Pin&amp;lt;Self&amp;gt;&lt;/code&gt; (this last one is an example of an &lt;a href=&quot;https://github.com/rust-lang/rust/issues/44874&quot;&gt;&quot;arbitrary &lt;code&gt;self&lt;/code&gt; type&quot;&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; キーワードのみ機能（の内部定義された関数関連付けられているメソッド、内部で使用することができる &lt;code&gt;trait&lt;/code&gt; または &lt;code&gt;impl&lt;/code&gt; 有するブロック）を &lt;code&gt;self&lt;/code&gt; のように、最初のパラメータとしての受信機を &lt;code&gt;self&lt;/code&gt; 、 &lt;code&gt;&amp;amp;self&lt;/code&gt; 、 &lt;code&gt;&amp;amp;mut self&lt;/code&gt; 又は &lt;code&gt;self: &amp;amp;mut Pin&amp;lt;Self&amp;gt;&lt;/code&gt; （この最後のものは&lt;a href=&quot;https://github.com/rust-lang/rust/issues/44874&quot;&gt;「任意の &lt;code&gt;self&lt;/code&gt; タイプ」の&lt;/a&gt;例です）。</target>
        </trans-unit>
        <trans-unit id="ca20974e52a0607307348bb19d0d894eb2389060" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; keyword cannot appear alone as the last segment in a &lt;code&gt;use&lt;/code&gt; declaration.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; キーワードはで最後のセグメントとして単独で表示することはできません &lt;code&gt;use&lt;/code&gt; 宣言。</target>
        </trans-unit>
        <trans-unit id="3baa95a2b4735c8ad9eb06f47e895376f593ffa3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; keyword was used in a static method.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; キーワードは静的メソッドで使用されました。</target>
        </trans-unit>
        <trans-unit id="a9568dcdfe3a23be1dee117543923d717013ab13" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; keyword was used inside of an associated function without a &quot;&lt;code&gt;self&lt;/code&gt; receiver&quot; parameter.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; キーワードは「なし関連する機能の内部を使用した &lt;code&gt;self&lt;/code&gt; 受信機」パラメータ。</target>
        </trans-unit>
        <trans-unit id="f67620c2fbc5330097742f848b2b9886ad0ef4ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; parameter in a method has an invalid &quot;receiver type&quot;.</source>
          <target state="translated">メソッドの &lt;code&gt;self&lt;/code&gt; パラメーターに無効な「レシーバータイプ」があります。</target>
        </trans-unit>
        <trans-unit id="71e55d8484323ba680a4d79f359c6a8e4726809e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sent_messages&lt;/code&gt; field is now of type &lt;code&gt;RefCell&amp;lt;Vec&amp;lt;String&amp;gt;&amp;gt;&lt;/code&gt; instead of &lt;code&gt;Vec&amp;lt;String&amp;gt;&lt;/code&gt;. In the &lt;code&gt;new&lt;/code&gt; function, we create a new &lt;code&gt;RefCell&amp;lt;Vec&amp;lt;String&amp;gt;&amp;gt;&lt;/code&gt; instance around the empty vector.</source>
          <target state="translated">&lt;code&gt;sent_messages&lt;/code&gt; のフィールドは今のタイプである &lt;code&gt;RefCell&amp;lt;Vec&amp;lt;String&amp;gt;&amp;gt;&lt;/code&gt; の代わりに &lt;code&gt;Vec&amp;lt;String&amp;gt;&lt;/code&gt; 。では &lt;code&gt;new&lt;/code&gt; 機能は、我々は新しい作成 &lt;code&gt;RefCell&amp;lt;Vec&amp;lt;String&amp;gt;&amp;gt;&lt;/code&gt; 空のベクターの周りのインスタンスを。</target>
        </trans-unit>
        <trans-unit id="337c62942744e545dcf717c6319edbedc18f313b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shoes_in_my_size&lt;/code&gt; function takes ownership of a vector of shoes and a shoe size as parameters. It returns a vector containing only shoes of the specified size.</source>
          <target state="translated">&lt;code&gt;shoes_in_my_size&lt;/code&gt; の関数は、パラメータとして靴のベクトルと靴のサイズの所有権を取得します。指定されたサイズの靴のみを含むベクトルを返します。</target>
        </trans-unit>
        <trans-unit id="16a60caa064b42a78f27eb4d74ff02e2b3b32b36" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;should_panic&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;should_panic&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="639f1b128b2e8340c54ba2df925fcc505b0aa67b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;should_panic&lt;/code&gt; attribute may optionally take an input string that must appear within the panic message. If the string is not found in the message, then the test will fail. The string may be passed using the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax or the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListNameValueStr&lt;/em&gt;&lt;/a&gt; syntax with an &lt;code&gt;expected&lt;/code&gt; field.</source>
          <target state="translated">&lt;code&gt;should_panic&lt;/code&gt; 属性は、必要に応じてパニックメッセージの中に表示される必要があり、入力文字列がかかる場合があります。メッセージに文字列が見つからない場合、テストは失敗します。文字列は、使用して渡すことができ&lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStrの&lt;/em&gt;&lt;/a&gt;構文や&lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListNameValueStrの&lt;/em&gt;&lt;/a&gt;で構文を &lt;code&gt;expected&lt;/code&gt; 分野。</target>
        </trans-unit>
        <trans-unit id="47db49dacc0e9fe0c5ab4b84de0a525fbcc167ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;simd_shuffle&lt;/code&gt; function needs the length of the array passed as last parameter in its name. Example:</source>
          <target state="translated">&lt;code&gt;simd_shuffle&lt;/code&gt; 機能は、その名の最後のパラメータとして渡された配列の長さを必要とします。例：</target>
        </trans-unit>
        <trans-unit id="1728894948cd279e5a554b1af44ad631d3c73ca8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;spawn&lt;/code&gt; function returns a &lt;code&gt;JoinHandle&amp;lt;T&amp;gt;&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is the type that the closure returns. Let&amp;rsquo;s try using &lt;code&gt;JoinHandle&lt;/code&gt; too and see what happens. In our case, the closures we&amp;rsquo;re passing to the thread pool will handle the connection and not return anything, so &lt;code&gt;T&lt;/code&gt; will be the unit type &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;spawn&lt;/code&gt; 関数リターン &lt;code&gt;JoinHandle&amp;lt;T&amp;gt;&lt;/code&gt; 、 &lt;code&gt;T&lt;/code&gt; は閉鎖戻り、そのタイプです。 &lt;code&gt;JoinHandle&lt;/code&gt; も使用して、何が起こるか見てみましょう。今回の場合、スレッドプールに渡すクロージャーは接続を処理し、何も返さないため、 &lt;code&gt;T&lt;/code&gt; はユニットタイプ &lt;code&gt;()&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="566807adf1a1b2e0676b75e750b724f0403f4cce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;src&lt;/code&gt; path is not a file or doesn't exist.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; パスはファイルではありませんか、存在しません。</target>
        </trans-unit>
        <trans-unit id="8b80b9ca4d5b5301222f74ba4e7cb474c1a9b0c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start..&lt;/code&gt; syntax is a &lt;code&gt;RangeFrom&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;start..&lt;/code&gt; 構文は次のとおりです &lt;code&gt;RangeFrom&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="d29bbe16c04fa990f15f7ad6e1fd231be48fb8e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start..=end&lt;/code&gt; syntax is a &lt;code&gt;RangeInclusive&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;start..=end&lt;/code&gt; 構文は次のとおりです &lt;code&gt;RangeInclusive&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="f551a983bf25bb9ca332d4bf79a3c5ffe5eff531" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start..end&lt;/code&gt; syntax is a &lt;code&gt;Range&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;start..end&lt;/code&gt; の構文は次のとおりです。 &lt;code&gt;Range&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="07635229348f3268d25fca1958c374b441ce892b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start&lt;/code&gt; function was defined with a where clause.</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; 機能は、where句で定義されました。</target>
        </trans-unit>
        <trans-unit id="a73480c4afd7847e00e31fe3aafec20a20c54b25" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;static&lt;/code&gt; keyword, on the other hand, guarantees a fixed location in memory. This does not always mean that the value is constant. For example, a global mutex can be declared &lt;code&gt;static&lt;/code&gt; as well.</source>
          <target state="translated">&lt;code&gt;static&lt;/code&gt; キーワードは、他方で、メモリ内の固定位置を保証します。これは常に値が一定であることを意味しません。たとえば、グローバルmutexも &lt;code&gt;static&lt;/code&gt; として宣言できます。</target>
        </trans-unit>
        <trans-unit id="d33afa111381148e1c91bd2523fbea89118180e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;std::env&lt;/code&gt; module contains many more useful features for dealing with environment variables: check out its documentation to see what is available.</source>
          <target state="translated">&lt;code&gt;std::env&lt;/code&gt; モジュールの環境変数を扱うためのより多くの便利な機能が含まれています。利用可能であるかを確認するために、そのドキュメントをチェックしてください。</target>
        </trans-unit>
        <trans-unit id="bcaf28a16adceb8447193d5235bef5d8bd3335ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;std::io&lt;/code&gt; module contains a number of common things you'll need when doing input and output. The most core part of this module is the &lt;a href=&quot;trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.write&quot;&gt;&lt;code&gt;Write&lt;/code&gt;&lt;/a&gt; traits, which provide the most general interface for reading and writing input and output.</source>
          <target state="translated">&lt;code&gt;std::io&lt;/code&gt; モジュールは、入力および出力を行うときに必要になります一般的なものの数が含まれています。このモジュールの最も中心的な部分は、入出力の&lt;a href=&quot;trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;trait.write&quot;&gt; &lt;code&gt;Write&lt;/code&gt; &lt;/a&gt;ための最も一般的なインターフェイスを提供する読み取りおよび書き込み特性です。</target>
        </trans-unit>
        <trans-unit id="4a54af6bd4d1bf95ed93c13cd61787ff3a49ae58" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;std::mem::drop&lt;/code&gt; function is different from the &lt;code&gt;drop&lt;/code&gt; method in the &lt;code&gt;Drop&lt;/code&gt; trait. We call it by passing the value we want to force to be dropped early as an argument. The function is in the prelude, so we can modify &lt;code&gt;main&lt;/code&gt; in Listing 15-15 to call the &lt;code&gt;drop&lt;/code&gt; function, as shown in Listing 15-16:</source>
          <target state="translated">&lt;code&gt;std::mem::drop&lt;/code&gt; 機能が異なっている &lt;code&gt;drop&lt;/code&gt; のメソッド &lt;code&gt;Drop&lt;/code&gt; 特色。強制的に早期に削除する値を引数として渡すことで、それを呼び出します。この関数はプレリュードにあるため、リスト15-16に示すように、リスト15-15の &lt;code&gt;main&lt;/code&gt; を変更して &lt;code&gt;drop&lt;/code&gt; 関数を呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="964c58feb2d7a0e4b6c63c315388a37636bb2ffa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;steps_between&lt;/code&gt; function provides a way to efficiently compare two &lt;code&gt;Step&lt;/code&gt; objects.</source>
          <target state="translated">&lt;code&gt;steps_between&lt;/code&gt; 機能は、効率的に2つの比較する方法を提供 &lt;code&gt;Step&lt;/code&gt; オブジェクトを。</target>
        </trans-unit>
        <trans-unit id="3d6948e046aa3d769d70c7d7f5831db7b61d283e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;str&lt;/code&gt; type, also called a 'string slice', is the most primitive string type. It is usually seen in its borrowed form, &lt;code&gt;&amp;amp;str&lt;/code&gt;. It is also the type of string literals, &lt;code&gt;&amp;amp;'static str&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; も、「文字列スライス」と呼ばれるタイプは、最も原始的な文字列型です。通常は、借用された形式 &lt;code&gt;&amp;amp;str&lt;/code&gt; で表示されます。また、文字列リテラルのタイプ &lt;code&gt;&amp;amp;'static str&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4ea4c33d08beaf7c17c84c4930138d5a7a1f80fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;stringify!&lt;/code&gt; macro used here is built into Rust. It takes a Rust expression, such as &lt;code&gt;1 + 2&lt;/code&gt;, and at compile time turns the expression into a string literal, such as &lt;code&gt;&quot;1 + 2&quot;&lt;/code&gt;. This is different than &lt;code&gt;format!&lt;/code&gt; or &lt;code&gt;println!&lt;/code&gt;, macros which evaluate the expression and then turn the result into a &lt;code&gt;String&lt;/code&gt;. There is a possibility that the &lt;code&gt;#name&lt;/code&gt; input might be an expression to print literally, so we use &lt;code&gt;stringify!&lt;/code&gt;. Using &lt;code&gt;stringify!&lt;/code&gt; also saves an allocation by converting &lt;code&gt;#name&lt;/code&gt; to a string literal at compile time.</source>
          <target state="translated">&lt;code&gt;stringify!&lt;/code&gt; ここで使用するマクロはRustに組み込まれています。 &lt;code&gt;1 + 2&lt;/code&gt; などのRust式を受け取り、コンパイル時に式を &lt;code&gt;&quot;1 + 2&quot;&lt;/code&gt; などの文字列リテラルに変換します。これは &lt;code&gt;format!&lt;/code&gt; とは異なります！または &lt;code&gt;println!&lt;/code&gt; 、式を評価して結果を &lt;code&gt;String&lt;/code&gt; に変換するマクロ。 &lt;code&gt;#name&lt;/code&gt; 入力が文字通り出力する式である可能性があるため、stringifyを使用します &lt;code&gt;stringify!&lt;/code&gt; 。 &lt;code&gt;stringify!&lt;/code&gt; 使用！また、コンパイル時に &lt;code&gt;#name&lt;/code&gt; を文字列リテラルに変換することで割り当てを保存します。</target>
        </trans-unit>
        <trans-unit id="5e2bbf89c9d53502f02966909193300b8b8e39a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;syn&lt;/code&gt; crate parses Rust code from a string into a data structure that we can perform operations on. The &lt;code&gt;quote&lt;/code&gt; crate turns &lt;code&gt;syn&lt;/code&gt; data structures back into Rust code. These crates make it much simpler to parse any sort of Rust code we might want to handle: writing a full parser for Rust code is no simple task.</source>
          <target state="translated">&lt;code&gt;syn&lt;/code&gt; クレートは、我々が上で操作を実行できるようなデータ構造に文字列から錆コードを解析します。 &lt;code&gt;quote&lt;/code&gt; クレートターン &lt;code&gt;syn&lt;/code&gt; データ構造は錆コードに戻します。これらのクレートを使用すると、処理したいあらゆる種類のRustコードを解析することがはるかに簡単になります。Rustコードの完全なパーサーを作成するのは簡単な作業ではありません。</target>
        </trans-unit>
        <trans-unit id="4c2f6cfbefda1dc3521b2af3bf1923ea6ba12d89" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;take&lt;/code&gt; method is defined in the &lt;code&gt;Iterator&lt;/code&gt; trait and limits the iteration to the first two items at most. The &lt;code&gt;ThreadPool&lt;/code&gt; will go out of scope at the end of &lt;code&gt;main&lt;/code&gt;, and the &lt;code&gt;drop&lt;/code&gt; implementation will run.</source>
          <target state="translated">&lt;code&gt;take&lt;/code&gt; 方法は、で定義されている &lt;code&gt;Iterator&lt;/code&gt; 形質と多くとも最初の2つの項目を反復を制限します。 &lt;code&gt;ThreadPool&lt;/code&gt; のはの終わりでスコープの外に行く &lt;code&gt;main&lt;/code&gt; 、および &lt;code&gt;drop&lt;/code&gt; 実装が実行されます。</target>
        </trans-unit>
        <trans-unit id="f4261b148ae0a22c8791698e09a2d9939e795de1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;target_feature&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;target_feature&lt;/code&gt; の属性</target>
        </trans-unit>
        <trans-unit id="0bfa2ee4e02addd4c71ab19bd1f7c85cc21dadfe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;test&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;test&lt;/code&gt; の属性</target>
        </trans-unit>
        <trans-unit id="c6b28a9d1db605fca4af25fdaf7d2f63f3f4ff7d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;track_caller&lt;/code&gt; attribute may be applied to any function with &lt;a href=&quot;../items/external-blocks#abi&quot;&gt;&lt;code&gt;&quot;Rust&quot;&lt;/code&gt; ABI&lt;/a&gt; with the exception of the entry point &lt;code&gt;fn main&lt;/code&gt;. When applied to functions and methods in trait declarations, the attribute applies to all implementations. If the trait provides a default implementation with the attribute, then the attribute also applies to override implementations.</source>
          <target state="translated">&lt;code&gt;track_caller&lt;/code&gt; の属性を持つ任意の関数に適用することができる&lt;a href=&quot;../items/external-blocks#abi&quot;&gt; &lt;code&gt;&quot;Rust&quot;&lt;/code&gt; ABI&lt;/a&gt;エントリポイントを除いて &lt;code&gt;fn main&lt;/code&gt; 。トレイト宣言の関数とメソッドに適用される場合、属性はすべての実装に適用されます。トレイトが属性を持つデフォルトの実装を提供する場合、属性はオーバーライド実装にも適用されます。</target>
        </trans-unit>
        <trans-unit id="dbbce8f10ed8de46d53a88134091400a4cad8f24" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;transparent&lt;/code&gt; Representation</source>
          <target state="translated">&lt;code&gt;transparent&lt;/code&gt; 表現</target>
        </trans-unit>
        <trans-unit id="16cfac7d668a26094fafdea930dd55dadb7672de" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;transparent&lt;/code&gt; representation can only be used on &lt;code&gt;struct&lt;/code&gt;s that have a single non-zero sized field and any number of zero-sized fields, including &lt;a href=&quot;special-types-and-traits#phantomdatat&quot;&gt;&lt;code&gt;PhantomData&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;transparent&lt;/code&gt; 表現のみで使用することができる &lt;code&gt;struct&lt;/code&gt; 単一の非ゼロサイズフィールドとを含むゼロサイズフィールド、任意の数有するS &lt;a href=&quot;special-types-and-traits#phantomdatat&quot;&gt; &lt;code&gt;PhantomData&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="811b48cd1ea2c8f7773b17e401a6ef4a6664ee6e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;transparent&lt;/code&gt; representation can only be used on a &lt;a href=&quot;items/structs&quot;&gt;&lt;code&gt;struct&lt;/code&gt;&lt;/a&gt; or an &lt;a href=&quot;items/enumerations&quot;&gt;&lt;code&gt;enum&lt;/code&gt;&lt;/a&gt; with a single variant that has:</source>
          <target state="translated">&lt;code&gt;transparent&lt;/code&gt; 表現のみで使用することができる&lt;a href=&quot;items/structs&quot;&gt; &lt;code&gt;struct&lt;/code&gt; &lt;/a&gt;、または&lt;a href=&quot;items/enumerations&quot;&gt; &lt;code&gt;enum&lt;/code&gt; &lt;/a&gt;有する単一変異を有します。</target>
        </trans-unit>
        <trans-unit id="01d7d7afaf943b9e9b10757db03a01818240c2c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;try_recv&lt;/code&gt; method doesn&amp;rsquo;t block, but will instead return a &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; immediately: an &lt;code&gt;Ok&lt;/code&gt; value holding a message if one is available and an &lt;code&gt;Err&lt;/code&gt; value if there aren&amp;rsquo;t any messages this time. Using &lt;code&gt;try_recv&lt;/code&gt; is useful if this thread has other work to do while waiting for messages: we could write a loop that calls &lt;code&gt;try_recv&lt;/code&gt; every so often, handles a message if one is available, and otherwise does other work for a little while until checking again.</source>
          <target state="translated">&lt;code&gt;try_recv&lt;/code&gt; の方法はブロックしませんが、その代わりに戻ります &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; すぐに： &lt;code&gt;Ok&lt;/code&gt; 1が利用可能な場合は、メッセージを保持する値と &lt;code&gt;Err&lt;/code&gt; 値を任意のメッセージがこの時間がない場合。使用 &lt;code&gt;try_recv&lt;/code&gt; は、このスレッドがメッセージを待っている間に行うには他の仕事を持っている場合に便利です：私たちは、呼び出しがそのループを書くことができ &lt;code&gt;try_recv&lt;/code&gt; 1が利用可能な場合、すべてがそう頻繁に、メッセージを処理し、再びチェックまでしながら、それ以外の場合は少しのために他の作業を行います。</target>
        </trans-unit>
        <trans-unit id="1c06a34327e19720b6fdb343c408e7c55dd84e16" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type Target = T;&lt;/code&gt; syntax defines an associated type for the &lt;code&gt;Deref&lt;/code&gt; trait to use. Associated types are a slightly different way of declaring a generic parameter, but you don&amp;rsquo;t need to worry about them for now; we&amp;rsquo;ll cover them in more detail in Chapter 19.</source>
          <target state="translated">&lt;code&gt;type Target = T;&lt;/code&gt; 構文は、使用する &lt;code&gt;Deref&lt;/code&gt; トレイトの関連タイプを定義します。関連付けられた型は、ジェネリックパラメーターを宣言する方法が少し異なりますが、今のところそれらについて心配する必要はありません。これらについては、第19章で詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="ed8f6c9e0893fd91a5e6d611722172ed9ef6f6c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type_length_limit&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;type_length_limit&lt;/code&gt; の属性</target>
        </trans-unit>
        <trans-unit id="88b76f9ce33c0af8e240ed6b37ada9e83ea43da5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;typeof&lt;/code&gt; keyword is currently reserved but unimplemented.</source>
          <target state="translated">&lt;code&gt;typeof&lt;/code&gt; 演算のキーワードは、現在予約が、実装されていません。</target>
        </trans-unit>
        <trans-unit id="7495ddf8e7dd908218ee8fe0115f879a8fb5ec94" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;typeof&lt;/code&gt; keyword is currently reserved but unimplemented. Erroneous code example:</source>
          <target state="translated">&lt;code&gt;typeof&lt;/code&gt; 演算のキーワードは、現在予約が、実装されていません。誤ったコード例：</target>
        </trans-unit>
        <trans-unit id="dd3cfc211f63708e7ec9409ea2198c30928717cb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unsafe&lt;/code&gt; keyword has two uses: to declare the existence of contracts the compiler can't check (&lt;code&gt;unsafe fn&lt;/code&gt; and &lt;code&gt;unsafe trait&lt;/code&gt;), and to declare that a programmer has checked that these contracts have been upheld (&lt;code&gt;unsafe {}&lt;/code&gt; and &lt;code&gt;unsafe impl&lt;/code&gt;, but also &lt;code&gt;unsafe fn&lt;/code&gt; -- see below). They are not mutually exclusive, as can be seen in &lt;code&gt;unsafe fn&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;unsafe&lt;/code&gt; 2つの用途がありますキーワード：コンパイラは（チェックすることができない契約の存在を宣言するために &lt;code&gt;unsafe fn&lt;/code&gt; と &lt;code&gt;unsafe trait&lt;/code&gt; ）、とプログラマはこれらの契約が守られていることを確認したことを宣言するために（ &lt;code&gt;unsafe {}&lt;/code&gt; と &lt;code&gt;unsafe impl&lt;/code&gt; が、また、 &lt;code&gt;unsafe fn&lt;/code&gt; 以下を参照）。 &lt;code&gt;unsafe fn&lt;/code&gt; でないfnに見られるように、これらは相互に排他的ではありません。</target>
        </trans-unit>
        <trans-unit id="b3bcdab50b34b5e5716db8fd4a0ee45ad2abea8d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unsafe&lt;/code&gt; keyword is syntactically allowed to appear before the &lt;code&gt;extern&lt;/code&gt; keyword, but it is rejected at a semantic level. This allows macros to consume the syntax and make use of the &lt;code&gt;unsafe&lt;/code&gt; keyword, before removing it from the token stream.</source>
          <target state="translated">&lt;code&gt;unsafe&lt;/code&gt; キーワードは、構文的に前に表示されるように許可されている &lt;code&gt;extern&lt;/code&gt; キーワード、それは意味的な水準で棄却されます。これにより、マクロは、トークンストリームから削除する前に、構文を消費し、 &lt;code&gt;unsafe&lt;/code&gt; キーワードを利用できます。</target>
        </trans-unit>
        <trans-unit id="205e3b2923533eb22d4e09801e3f784e668f24fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unsafe&lt;/code&gt; keyword is syntactically allowed to appear before the &lt;code&gt;mod&lt;/code&gt; keyword, but it is rejected at a semantic level. This allows macros to consume the syntax and make use of the &lt;code&gt;unsafe&lt;/code&gt; keyword, before removing it from the token stream.</source>
          <target state="translated">&lt;code&gt;unsafe&lt;/code&gt; キーワードは、構文的に前に表示されるように許可されている &lt;code&gt;mod&lt;/code&gt; のキーワード、それは意味的な水準で棄却されます。これにより、マクロは、トークンストリームから削除する前に、構文を消費し、 &lt;code&gt;unsafe&lt;/code&gt; キーワードを利用できます。</target>
        </trans-unit>
        <trans-unit id="a346e1081bfa2911e1aa0fde6117ab4a081928a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unsafe&lt;/code&gt; qualifier indicates that the type's value is an &lt;a href=&quot;../unsafe-functions&quot;&gt;unsafe function&lt;/a&gt;, and the &lt;code&gt;extern&lt;/code&gt; qualifier indicates it is an &lt;a href=&quot;../items/functions#extern-function-qualifier&quot;&gt;extern function&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;unsafe&lt;/code&gt; 修飾子は、型の値があることを示し&lt;a href=&quot;../unsafe-functions&quot;&gt;、安全でない機能&lt;/a&gt;、および &lt;code&gt;extern&lt;/code&gt; 修飾子は、それがあることを示し&lt;a href=&quot;../items/functions#extern-function-qualifier&quot;&gt;EXTERN機能&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="994e471fd3da940319d1417edcfca60d6a3db828" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unsafe&lt;/code&gt; qualifier indicates that the type's value is an &lt;a href=&quot;../unsafe-functions&quot;&gt;unsafe function&lt;/a&gt;, and the &lt;code&gt;extern&lt;/code&gt; qualifier indicates it is an &lt;a href=&quot;../items/functions#extern-functions&quot;&gt;extern function&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;unsafe&lt;/code&gt; 修飾子は、型の値があることを示し&lt;a href=&quot;../unsafe-functions&quot;&gt;、安全でない機能&lt;/a&gt;、および &lt;code&gt;extern&lt;/code&gt; 修飾子は、それがあることを示し&lt;a href=&quot;../items/functions#extern-functions&quot;&gt;EXTERN機能&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="78ba9e0cc65cc7840eaadd16f98f7cca440cd4f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unwind&lt;/code&gt; attribute was malformed.</source>
          <target state="translated">&lt;code&gt;unwind&lt;/code&gt; 属性が不正な形式でした。</target>
        </trans-unit>
        <trans-unit id="a60fd78a94b551f1746c4a391dd52899994edd99" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;used&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;used&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="762cbbe7d454d7148fa1b85ecdd6dd222c5646ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;usize&lt;/code&gt; type is an unsigned integer type with the same number of bits as the platform's pointer type. It can represent every memory address in the process.</source>
          <target state="translated">&lt;code&gt;usize&lt;/code&gt; タイプは、プラットフォームのポインタ型と同じビット数を有する符号なし整数型です。プロセス内のすべてのメモリアドレスを表すことができます。</target>
        </trans-unit>
        <trans-unit id="ca7074c2679596c96e2d40f1a9e7060f1f83b71a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;value&lt;/code&gt; field is of type &lt;code&gt;Option&amp;lt;u32&amp;gt;&lt;/code&gt;. Before we execute the closure, &lt;code&gt;value&lt;/code&gt; will be &lt;code&gt;None&lt;/code&gt;. When code using a &lt;code&gt;Cacher&lt;/code&gt; asks for the &lt;em&gt;result&lt;/em&gt; of the closure, the &lt;code&gt;Cacher&lt;/code&gt; will execute the closure at that time and store the result within a &lt;code&gt;Some&lt;/code&gt; variant in the &lt;code&gt;value&lt;/code&gt; field. Then if the code asks for the result of the closure again, instead of executing the closure again, the &lt;code&gt;Cacher&lt;/code&gt; will return the result held in the &lt;code&gt;Some&lt;/code&gt; variant.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; フィールドは、型のある &lt;code&gt;Option&amp;lt;u32&amp;gt;&lt;/code&gt; 。クロージャーを実行する前の &lt;code&gt;value&lt;/code&gt; は &lt;code&gt;None&lt;/code&gt; になります。 &lt;code&gt;Cacher&lt;/code&gt; を使用するコードがクロージャの&lt;em&gt;結果&lt;/em&gt;を要求すると、 &lt;code&gt;Cacher&lt;/code&gt; はその時点でクロージャを実行し、結果を &lt;code&gt;value&lt;/code&gt; フィールドの &lt;code&gt;Some&lt;/code&gt; バリアント内に格納します。次に、コードがクロージャーの結果を再度要求した場合、クロージャーを再度実行する代わりに、 &lt;code&gt;Cacher&lt;/code&gt; は &lt;code&gt;Some&lt;/code&gt; バリアントに保持されている結果を返します。</target>
        </trans-unit>
        <trans-unit id="5defa2a7e24b93d29be444c6bce3655062b73aee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vtable&lt;/code&gt; customizes the behavior of a &lt;code&gt;Waker&lt;/code&gt; which gets created from a &lt;code&gt;RawWaker&lt;/code&gt;. For each operation on the &lt;code&gt;Waker&lt;/code&gt;, the associated function in the &lt;code&gt;vtable&lt;/code&gt; of the underlying &lt;code&gt;RawWaker&lt;/code&gt; will be called.</source>
          <target state="translated">&lt;code&gt;vtable&lt;/code&gt; のはの行動カスタマイズ &lt;code&gt;Waker&lt;/code&gt; から作成されます &lt;code&gt;RawWaker&lt;/code&gt; を。 &lt;code&gt;Waker&lt;/code&gt; の操作ごとに、基になる &lt;code&gt;RawWaker&lt;/code&gt; の &lt;code&gt;vtable&lt;/code&gt; 内の関連する関数が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="58deddf572f1c05716c0aff255109ee68c618f77" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;wasm_import_module&lt;/code&gt; key may be used to specify the &lt;a href=&quot;https://webassembly.github.io/spec/core/syntax/modules.html&quot;&gt;WebAssembly module&lt;/a&gt; name for the items within an &lt;code&gt;extern&lt;/code&gt; block when importing symbols from the host environment. The default module name is &lt;code&gt;env&lt;/code&gt; if &lt;code&gt;wasm_import_module&lt;/code&gt; is not specified.</source>
          <target state="translated">&lt;code&gt;wasm_import_module&lt;/code&gt; のキーを指定するために使用することができる&lt;a href=&quot;https://webassembly.github.io/spec/core/syntax/modules.html&quot;&gt;WebAssemblyモジュール&lt;/a&gt;内のアイテムの名前を &lt;code&gt;extern&lt;/code&gt; ホスト環境からシンボルをインポートするときにブロック。 &lt;code&gt;wasm_import_module&lt;/code&gt; が指定されていない場合、デフォルトのモジュール名は &lt;code&gt;env&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="03b2e1ae71fdcbd9ffac8eca408ab8d4e8472f94" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;width&lt;/code&gt;, &lt;code&gt;height&lt;/code&gt;, and &lt;code&gt;label&lt;/code&gt; fields on &lt;code&gt;Button&lt;/code&gt; will differ from the fields on other components, such as a &lt;code&gt;TextField&lt;/code&gt; type, that might have those fields plus a &lt;code&gt;placeholder&lt;/code&gt; field instead. Each of the types we want to draw on the screen will implement the &lt;code&gt;Draw&lt;/code&gt; trait but will use different code in the &lt;code&gt;draw&lt;/code&gt; method to define how to draw that particular type, as &lt;code&gt;Button&lt;/code&gt; has here (without the actual GUI code, which is beyond the scope of this chapter). The &lt;code&gt;Button&lt;/code&gt; type, for instance, might have an additional &lt;code&gt;impl&lt;/code&gt; block containing methods related to what happens when a user clicks the button. These kinds of methods won&amp;rsquo;t apply to types like &lt;code&gt;TextField&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Button&lt;/code&gt; の &lt;code&gt;width&lt;/code&gt; 、 &lt;code&gt;height&lt;/code&gt; 、および &lt;code&gt;label&lt;/code&gt; フィールドは、 &lt;code&gt;TextField&lt;/code&gt; タイプなどの他のコンポーネントのフィールドとは異なり、これらのフィールドと &lt;code&gt;placeholder&lt;/code&gt; フィールドが代わりにある場合があります。画面に描画する各タイプは、 &lt;code&gt;Draw&lt;/code&gt; トレイトを実装しますが、 &lt;code&gt;draw&lt;/code&gt; メソッドで異なるコードを使用して、特定のタイプを描画する方法を定義します。これは、 &lt;code&gt;Button&lt;/code&gt; のように（実際のGUIコードなしで、スコープを超えています）この章の）。 &lt;code&gt;Button&lt;/code&gt; 種類は、例えば、追加の可能性があります &lt;code&gt;impl&lt;/code&gt; ユーザーがボタンをクリックしたときに何が起こるかに関するメソッドを含むブロック。これらの種類のメソッドは、 &lt;code&gt;TextField&lt;/code&gt; のような型には適用されません。</target>
        </trans-unit>
        <trans-unit id="49fef96b0756f10c5fd5c7fedcccb9ee963b501d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;windows_subsystem&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;windows_subsystem&lt;/code&gt; の属性</target>
        </trans-unit>
        <trans-unit id="fe674a5495eedc22d7ae598194abec96fa238a33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;write&lt;/code&gt; function takes an output stream, and an &lt;code&gt;Arguments&lt;/code&gt; struct that can be precompiled with the &lt;code&gt;format_args!&lt;/code&gt; macro.</source>
          <target state="translated">&lt;code&gt;write&lt;/code&gt; 機能は、出力ストリームをとり、 &lt;code&gt;Arguments&lt;/code&gt; をプリコンパイルすることができ、構造体 &lt;code&gt;format_args!&lt;/code&gt; 大きい。</target>
        </trans-unit>
        <trans-unit id="5644d7245fdec36266e15ee66f56202b01bc587d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;x&lt;/code&gt; part is a pattern! As we did with &lt;code&gt;let&lt;/code&gt;, we could match a tuple in a function&amp;rsquo;s arguments to the pattern. Listing 18-7 splits the values in a tuple as we pass it to a function.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 部分がパターンです！我々が行ったように &lt;code&gt;let&lt;/code&gt; 、我々はパターンに関数の引数にタプルを一致させることができます。リスト18-7は、関数に渡すときにタプルの値を分割します。</target>
        </trans-unit>
        <trans-unit id="90c7cb6860c6df5927660a73f110e2f9166750a3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;x&lt;/code&gt; value is moved into the closure when the closure is defined, because we added the &lt;code&gt;move&lt;/code&gt; keyword. The closure then has ownership of &lt;code&gt;x&lt;/code&gt;, and &lt;code&gt;main&lt;/code&gt; isn&amp;rsquo;t allowed to use &lt;code&gt;x&lt;/code&gt; anymore in the &lt;code&gt;println!&lt;/code&gt; statement. Removing &lt;code&gt;println!&lt;/code&gt; will fix this example.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; クロージャが定義されている場合、我々は追加ため値は、閉鎖に移動する &lt;code&gt;move&lt;/code&gt; キーワード。閉鎖は、その後の所有している &lt;code&gt;x&lt;/code&gt; 、そして &lt;code&gt;main&lt;/code&gt; 使用を許可されていません &lt;code&gt;x&lt;/code&gt; はでもう &lt;code&gt;println!&lt;/code&gt; ステートメント。 &lt;code&gt;println!&lt;/code&gt; 削除しています！この例を修正します。</target>
        </trans-unit>
        <trans-unit id="693d3b957625a8e3df8f4384a832c7be5cfa15d0" translate="yes" xml:space="preserve">
          <source>The &lt;em id=&quot;the-tests-directory&quot;&gt;tests&lt;/em&gt; Directory</source>
          <target state="translated">&lt;em id=&quot;the-tests-directory&quot;&gt;テストの&lt;/em&gt;ディレクトリ</target>
        </trans-unit>
        <trans-unit id="2382217293f35827ef839ef57a6e0636f3faa56f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;automatically_derived&lt;/code&gt; attribute&lt;/em&gt; is automatically added to &lt;a href=&quot;../items/implementations&quot;&gt;implementations&lt;/a&gt; created by the &lt;code&gt;derive&lt;/code&gt; attribute for built-in traits. It has no direct effect, but it may be used by tools and diagnostic lints to detect these automatically generated implementations.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;automatically_derived&lt;/code&gt; 属性が&lt;/em&gt;自動的に追加された&lt;a href=&quot;../items/implementations&quot;&gt;実装&lt;/a&gt;によって作成された &lt;code&gt;derive&lt;/code&gt; ビルトイン形質の属性。直接的な影響はありませんが、ツールや診断リントがこれらの自動生成された実装を検出するために使用する場合があります。</target>
        </trans-unit>
        <trans-unit id="7d372f8b0a676dc2ae354b920b56c31e1ed0230f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;cold&lt;/code&gt; &lt;a href=&quot;../attributes&quot;&gt;attribute&lt;/a&gt;&lt;/em&gt; suggests that the attributed function is unlikely to be called.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;cold&lt;/code&gt; &lt;a href=&quot;../attributes&quot;&gt;属性は、&lt;/a&gt;&lt;/em&gt;帰属関数が呼び出されることはほとんどありませんことを示唆しています。</target>
        </trans-unit>
        <trans-unit id="c8dd94fd6bb692bd54e04ee95744533de367bad8" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;crate_name&lt;/code&gt; &lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt;&lt;/em&gt; may be applied at the crate level to specify the name of the crate with the &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;crate_name&lt;/code&gt; の &lt;a href=&quot;attributes&quot;&gt;属性は&lt;/a&gt;&lt;/em&gt;とクレートの名前を指定するには、クレートレベルで適用することができる&lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStrの&lt;/em&gt;&lt;/a&gt;構文。</target>
        </trans-unit>
        <trans-unit id="2db8e6439808a243c5fa24e648c2e0fab8ef4d83" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;deprecated&lt;/code&gt; attribute&lt;/em&gt; marks an item as deprecated. &lt;code&gt;rustc&lt;/code&gt; will issue warnings on usage of &lt;code&gt;#[deprecated]&lt;/code&gt; items. &lt;code&gt;rustdoc&lt;/code&gt; will show item deprecation, including the &lt;code&gt;since&lt;/code&gt; version and &lt;code&gt;note&lt;/code&gt;, if available.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;deprecated&lt;/code&gt; 属性&lt;/em&gt;マーク非推奨としてアイテム。 &lt;code&gt;rustc&lt;/code&gt; は &lt;code&gt;#[deprecated]&lt;/code&gt; アイテムの使用に関する警告を発行します。 &lt;code&gt;rustdoc&lt;/code&gt; は、利用可能であれば、それ &lt;code&gt;since&lt;/code&gt; バージョンと &lt;code&gt;note&lt;/code&gt; を含む、アイテムの非推奨を表示します。</target>
        </trans-unit>
        <trans-unit id="fa15bab6a083f19d9ae9cd7eaa338e697eaf4832" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;derive&lt;/code&gt; attribute&lt;/em&gt; allows new &lt;a href=&quot;../items&quot;&gt;items&lt;/a&gt; to be automatically generated for data structures. It uses the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListPaths&lt;/em&gt;&lt;/a&gt; syntax to specify a list of traits to implement or paths to &lt;a href=&quot;../procedural-macros#derive-macros&quot;&gt;derive macros&lt;/a&gt; to process.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;derive&lt;/code&gt; 属性は、&lt;/em&gt;新しいことができます&lt;a href=&quot;../items&quot;&gt;アイテムが&lt;/a&gt;自動的にデータ構造のために生成されます。&lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListPaths&lt;/em&gt;&lt;/a&gt;構文を使用して、実装する特性のリストまたは処理&lt;a href=&quot;../procedural-macros#derive-macros&quot;&gt;するマクロ&lt;/a&gt;を派生させるパスを指定します。</target>
        </trans-unit>
        <trans-unit id="a97c3213ab817ab892d8f6e5c3157736e74b3b32" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;export_name&lt;/code&gt; attribute&lt;/em&gt; specifies the name of the symbol that will be exported on a &lt;a href=&quot;items/functions&quot;&gt;function&lt;/a&gt; or &lt;a href=&quot;items/static-items&quot;&gt;static&lt;/a&gt;. It uses the &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to specify the symbol name.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;export_name&lt;/code&gt; の属性は、&lt;/em&gt;上でエクスポートされるシンボルの名前を指定する&lt;a href=&quot;items/functions&quot;&gt;機能&lt;/a&gt;または&lt;a href=&quot;items/static-items&quot;&gt;静的を&lt;/a&gt;。&lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt;構文を使用して、シンボル名を指定します。</target>
        </trans-unit>
        <trans-unit id="9d1fbcf19af41adeefc0b92335ae4b007c4dadfa" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;global_allocator&lt;/code&gt; attribute&lt;/em&gt; is used on a &lt;a href=&quot;items/static-items&quot;&gt;static item&lt;/a&gt; implementing the &lt;a href=&quot;https://doc.rust-lang.org/alloc/alloc/trait.GlobalAlloc.html&quot;&gt;&lt;code&gt;GlobalAlloc&lt;/code&gt;&lt;/a&gt; trait to set the global allocator.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;global_allocator&lt;/code&gt; の属性は&lt;/em&gt;上で使用される&lt;a href=&quot;items/static-items&quot;&gt;静的項目&lt;/a&gt;実装&lt;a href=&quot;https://doc.rust-lang.org/alloc/alloc/trait.GlobalAlloc.html&quot;&gt; &lt;code&gt;GlobalAlloc&lt;/code&gt; &lt;/a&gt;グローバルアロケータを設定する形質を。</target>
        </trans-unit>
        <trans-unit id="eb4af8649334dd85e9ba7979a0a444e3961c900a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;inline&lt;/code&gt; &lt;a href=&quot;../attributes&quot;&gt;attribute&lt;/a&gt;&lt;/em&gt; suggests that a copy of the attributed function should be placed in the caller, rather than generating code to call the function where it is defined.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;inline&lt;/code&gt; &lt;a href=&quot;../attributes&quot;&gt;属性は、&lt;/a&gt;&lt;/em&gt;帰属関数のコピーではなく、それが定義されている関数を呼び出すコードを生成するよりも、呼び出し側に配置されるべきであることを示唆しています。</target>
        </trans-unit>
        <trans-unit id="1d9a7b1456b98dca1d8fed53edde3318db90e4c5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;link&lt;/code&gt; attribute&lt;/em&gt; specifies the name of a native library that the compiler should link with for the items within an &lt;code&gt;extern&lt;/code&gt; block. It uses the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to specify its inputs. The &lt;code&gt;name&lt;/code&gt; key is the name of the native library to link. The &lt;code&gt;kind&lt;/code&gt; key is an optional value which specifies the kind of library with the following possible values:</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;link&lt;/code&gt; 属性は、&lt;/em&gt;コンパイラは、内のアイテムのためにリンクする必要があることネイティブライブラリの名前を指定する &lt;code&gt;extern&lt;/code&gt; ブロックを。&lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListNameValueStr&lt;/em&gt;&lt;/a&gt;構文を使用して、入力を指定します。 &lt;code&gt;name&lt;/code&gt; キーはリンクにネイティブライブラリの名前です。 &lt;code&gt;kind&lt;/code&gt; のキーは、以下の値を持つライブラリの種類を指定するオプション値です。</target>
        </trans-unit>
        <trans-unit id="6603167a8a5aa9df2deb989c68e33b760144ac17" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;link_section&lt;/code&gt; attribute&lt;/em&gt; specifies the section of the object file that a &lt;a href=&quot;items/functions&quot;&gt;function&lt;/a&gt; or &lt;a href=&quot;items/static-items&quot;&gt;static&lt;/a&gt;'s content will be placed into. It uses the &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to specify the section name.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;link_section&lt;/code&gt; の属性は、&lt;/em&gt;そのオブジェクトファイルのセクションを指定する&lt;a href=&quot;items/functions&quot;&gt;機能&lt;/a&gt;または&lt;a href=&quot;items/static-items&quot;&gt;静的&lt;/a&gt;のコンテンツがに置かれますが。&lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt;構文を使用してセクション名を指定します。</target>
        </trans-unit>
        <trans-unit id="806935dfacd2a07be8b57f073dcdf39509c2b1f7" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;macro_use&lt;/code&gt; attribute&lt;/em&gt; has two purposes. First, it can be used to make a module's macro scope not end when the module is closed, by applying it to a module:</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;macro_use&lt;/code&gt; の属性には&lt;/em&gt; 2つの目的があります。まず、モジュールに適用することにより、モジュールが閉じられたときにモジュールのマクロスコープが終了しないようにするために使用できます。</target>
        </trans-unit>
        <trans-unit id="05f0042fe91a37001bd65ea0d74fd9143e55659c" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;must_use&lt;/code&gt; attribute&lt;/em&gt; is used to issue a diagnostic warning when a value is not &quot;used&quot;. It can be applied to user-defined composite types (&lt;a href=&quot;../items/structs&quot;&gt;&lt;code&gt;struct&lt;/code&gt;s&lt;/a&gt;, &lt;a href=&quot;../items/enumerations&quot;&gt;&lt;code&gt;enum&lt;/code&gt;s&lt;/a&gt;, and &lt;a href=&quot;../items/unions&quot;&gt;&lt;code&gt;union&lt;/code&gt;s&lt;/a&gt;), &lt;a href=&quot;../items/functions&quot;&gt;functions&lt;/a&gt;, and &lt;a href=&quot;../items/traits&quot;&gt;traits&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;must_use&lt;/code&gt; の属性は、&lt;/em&gt;値が「使用」されていない場合、診断警告を発行するために使用されます。これは、（ユーザ定義の複合型に適用することができる&lt;a href=&quot;../items/structs&quot;&gt; &lt;code&gt;struct&lt;/code&gt; の&lt;/a&gt;、&lt;a href=&quot;../items/enumerations&quot;&gt; &lt;code&gt;enum&lt;/code&gt; S&lt;/a&gt;、及び&lt;a href=&quot;../items/unions&quot;&gt; &lt;code&gt;union&lt;/code&gt; S&lt;/a&gt;）、&lt;a href=&quot;../items/functions&quot;&gt;関数は&lt;/a&gt;、および&lt;a href=&quot;../items/traits&quot;&gt;形質&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="df0d5b935c63e0d5d09ad34649237d79db006af9" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;no_builtins&lt;/code&gt; &lt;a href=&quot;../attributes&quot;&gt;attribute&lt;/a&gt;&lt;/em&gt; may be applied at the crate level to disable optimizing certain code patterns to invocations of library functions that are assumed to exist.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;no_builtins&lt;/code&gt; の &lt;a href=&quot;../attributes&quot;&gt;属性が&lt;/a&gt;&lt;/em&gt;存在すると仮定されているライブラリ関数の呼び出しに無効に最適化する特定のコードパターンにクレートレベルで適用することができます。</target>
        </trans-unit>
        <trans-unit id="1c5fb5c17e1ae5e93c491f3ff3864f7cf3700a82" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;no_link&lt;/code&gt; attribute&lt;/em&gt; may be specified on an &lt;code&gt;extern crate&lt;/code&gt; item to prevent linking the crate into the output. This is commonly used to load a crate to access only its macros.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;no_link&lt;/code&gt; 属性&lt;/em&gt;で指定することができる &lt;code&gt;extern crate&lt;/code&gt; 出力にクレートを連結防止するアイテム。これは通常、クレートをロードしてそのマクロのみにアクセスするために使用されます。</target>
        </trans-unit>
        <trans-unit id="a894d89850015842793e60fc8f351c2309ee5ef4" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;no_main&lt;/code&gt; &lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt;&lt;/em&gt; may be applied at the crate level to disable emitting the &lt;code&gt;main&lt;/code&gt; symbol for an executable binary. This is useful when some other object being linked to defines &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;no_main&lt;/code&gt; &lt;a href=&quot;attributes&quot;&gt;属性を&lt;/a&gt;&lt;/em&gt;クレートレベルで適用して、実行可能バイナリの &lt;code&gt;main&lt;/code&gt; シンボルの&lt;em&gt;発行&lt;/em&gt;を無効にすることができます。これは、リンクされている他のオブジェクトが &lt;code&gt;main&lt;/code&gt; を定義している場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="f3bcfb88f5c979d523b3f1a38c5f5b56a611b895" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;no_mangle&lt;/code&gt; attribute&lt;/em&gt; may be used on any &lt;a href=&quot;items&quot;&gt;item&lt;/a&gt; to disable standard symbol name mangling. The symbol for the item will be the identifier of the item's name.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;no_mangle&lt;/code&gt; 属性は&lt;/em&gt;いずれにも使用することができる&lt;a href=&quot;items&quot;&gt;項目&lt;/a&gt;を無効標準のシンボルの名前の符号化に。アイテムのシンボルは、アイテムの名前の識別子になります。</target>
        </trans-unit>
        <trans-unit id="0bb656555b55ed7c2f8a3087c34efb6ed0ed4cf4" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;non_exhaustive&lt;/code&gt; attribute&lt;/em&gt; indicates that a type or variant may have more fields or variants added in the future. It can be applied to &lt;a href=&quot;../items/structs&quot;&gt;&lt;code&gt;struct&lt;/code&gt;s&lt;/a&gt;, &lt;a href=&quot;../items/enumerations&quot;&gt;&lt;code&gt;enum&lt;/code&gt;s&lt;/a&gt;, and &lt;code&gt;enum&lt;/code&gt; variants.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;non_exhaustive&lt;/code&gt; 属性は&lt;/em&gt;タイプまたは変異体は、複数のフィールドまたは将来的に追加の変種を有することができることを示しています。これは、&lt;a href=&quot;../items/structs&quot;&gt; &lt;code&gt;struct&lt;/code&gt; s&lt;/a&gt;、&lt;a href=&quot;../items/enumerations&quot;&gt; &lt;code&gt;enum&lt;/code&gt; s&lt;/a&gt;、および &lt;code&gt;enum&lt;/code&gt; バリアントに適用できます。</target>
        </trans-unit>
        <trans-unit id="53a982d72d2f0894ccb0ac1653ff149a9b51224c" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;panic_handler&lt;/code&gt; attribute&lt;/em&gt; can only be applied to a function with signature &lt;code&gt;fn(&amp;amp;PanicInfo) -&amp;gt; !&lt;/code&gt;. The function marked with this &lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; defines the behavior of panics. The &lt;a href=&quot;https://doc.rust-lang.org/core/panic/struct.PanicInfo.html&quot;&gt;&lt;code&gt;PanicInfo&lt;/code&gt;&lt;/a&gt; struct contains information about the location of the panic. There must be a single &lt;code&gt;panic_handler&lt;/code&gt; function in the dependency graph of a binary, dylib or cdylib crate.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;panic_handler&lt;/code&gt; の属性が&lt;/em&gt;唯一の署名で関数に適用することができ &lt;code&gt;fn(&amp;amp;PanicInfo) -&amp;gt; !&lt;/code&gt; 。この&lt;a href=&quot;attributes&quot;&gt;属性で&lt;/a&gt;マークされた関数は、パニックの動作を定義します。&lt;a href=&quot;https://doc.rust-lang.org/core/panic/struct.PanicInfo.html&quot;&gt; &lt;code&gt;PanicInfo&lt;/code&gt; の&lt;/a&gt;構造体は、パニックの場所に関する情報が含まれています。バイナリ、dylib、またはcdylibクレートの依存関係グラフには、単一の &lt;code&gt;panic_handler&lt;/code&gt; 関数が必要です。</target>
        </trans-unit>
        <trans-unit id="12cdf01a779d8c77135d5a609c4b4e6849f40d6f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;recursion_limit&lt;/code&gt; attribute&lt;/em&gt; may be applied at the &lt;a href=&quot;../crates-and-source-files&quot;&gt;crate&lt;/a&gt; level to set the maximum depth for potentially infinitely-recursive compile-time operations like macro expansion or auto-dereference. It uses the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to specify the recursion depth.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;recursion_limit&lt;/code&gt; の属性&lt;/em&gt;に適用することができる&lt;a href=&quot;../crates-and-source-files&quot;&gt;クレート&lt;/a&gt;マクロ展開または自動逆参照様潜在的に無限に再帰コンパイル時の動作のための最大深さを設定するレベル。&lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt;構文を使用して、再帰の深さを指定します。</target>
        </trans-unit>
        <trans-unit id="a7c71f7f4ce5a08ecec5e3cb423add9b9986d9b2" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;target_feature&lt;/code&gt; &lt;a href=&quot;../attributes&quot;&gt;attribute&lt;/a&gt;&lt;/em&gt; may be applied to an &lt;a href=&quot;../unsafe-functions&quot;&gt;unsafe function&lt;/a&gt; to enable code generation of that function for specific platform architecture features. It uses the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListNameValueStr&lt;/em&gt;&lt;/a&gt; syntax with a single key of &lt;code&gt;enable&lt;/code&gt; whose value is a string of comma-separated feature names to enable.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;target_feature&lt;/code&gt; の &lt;a href=&quot;../attributes&quot;&gt;属性は、&lt;/a&gt;&lt;/em&gt;に適用することができる&lt;a href=&quot;../unsafe-functions&quot;&gt;安全でない機能&lt;/a&gt;特定のプラットフォームアーキテクチャの機能のために、その関数のコード生成を有効にします。&lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListNameValueStr&lt;/em&gt;&lt;/a&gt;構文を使用して、 &lt;code&gt;enable&lt;/code&gt; する単一のキーを有効にします。そのキーの値は、有効にするコンマ区切りの機能名の文字列です。</target>
        </trans-unit>
        <trans-unit id="3aa1c2ce8a0a269a928c5414e9b6749a40da4909" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;test&lt;/code&gt; attribute&lt;/em&gt; marks a function to be executed as a test. These functions are only compiled when in test mode. Test functions must be free, monomorphic functions that take no arguments, and the return type must be one of the following:</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;test&lt;/code&gt; 属性&lt;/em&gt;マークテストとして実行する機能。これらの関数は、テストモードでのみコンパイルされます。テスト関数は、引数を取らない無料の単相関数でなければならず、戻り値の型は次のいずれかでなければなりません。</target>
        </trans-unit>
        <trans-unit id="8e32e2a7306abe757340b9bbe77da987dbdce7fd" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;type_length_limit&lt;/code&gt; attribute&lt;/em&gt; limits the maximum number of type substitutions made when constructing a concrete type during monomorphization. It is applied at the &lt;a href=&quot;../crates-and-source-files&quot;&gt;crate&lt;/a&gt; level, and uses the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to set the limit based on the number of type substitutions.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;type_length_limit&lt;/code&gt; の属性は&lt;/em&gt; monomorphization中コンクリートタイプを構築するときに行われるタイプの置換の最大数を制限します。これは&lt;a href=&quot;../crates-and-source-files&quot;&gt;クレート&lt;/a&gt;レベルで適用され、&lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt;構文を使用して、タイプ置換の数に基づいて制限を設定します。</target>
        </trans-unit>
        <trans-unit id="6e74f839ef9f1efad1a8f9c7c9bbeff2f9cc5cae" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;used&lt;/code&gt; attribute&lt;/em&gt; can only be applied to &lt;a href=&quot;items/static-items&quot;&gt;&lt;code&gt;static&lt;/code&gt; items&lt;/a&gt;. This &lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; forces the compiler to keep the variable in the output object file (.o, .rlib, etc. excluding final binaries) even if the variable is not used, or referenced, by any other item in the crate. However, the linker is still free to remove such an item.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;used&lt;/code&gt; 属性が&lt;/em&gt;唯一に適用することができ&lt;a href=&quot;items/static-items&quot;&gt; &lt;code&gt;static&lt;/code&gt; アイテム&lt;/a&gt;。この&lt;a href=&quot;attributes&quot;&gt;属性&lt;/a&gt;は、変数がクレート内の他のアイテムによって使用または参照されていない場合でも、コンパイラーに出力オブジェクトファイル（最終バイナリを除く.o、.rlibなど）に変数を保持するように強制します。ただし、リンカはそのようなアイテムを自由に削除できます。</target>
        </trans-unit>
        <trans-unit id="f9f3929d821839852e44df6684413a39c02b618f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;used&lt;/code&gt; attribute&lt;/em&gt; can only be applied to &lt;a href=&quot;items/static-items&quot;&gt;&lt;code&gt;static&lt;/code&gt; items&lt;/a&gt;. This &lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; forces the compiler to keep the variable in the output object file (.o, .rlib, etc.) even if the variable is not used, or referenced, by any other item in the crate.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;used&lt;/code&gt; 属性が&lt;/em&gt;唯一に適用することができ&lt;a href=&quot;items/static-items&quot;&gt; &lt;code&gt;static&lt;/code&gt; アイテム&lt;/a&gt;。この&lt;a href=&quot;attributes&quot;&gt;属性&lt;/a&gt;は、変数がクレート内の他のアイテムによって使用または参照されていない場合でも、コンパイラーに変数を出力オブジェクトファイル（.o、.rlibなど）に保持することを強制します。</target>
        </trans-unit>
        <trans-unit id="cabd9dd1fe1f065b8657354c25edb014ad53f468" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;windows_subsystem&lt;/code&gt; attribute&lt;/em&gt; may be applied at the crate level to set the &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/fcc1zstk.aspx&quot;&gt;subsystem&lt;/a&gt; when linking on a Windows target. It uses the &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to specify the subsystem with a value of either &lt;code&gt;console&lt;/code&gt; or &lt;code&gt;windows&lt;/code&gt;. This attribute is ignored on non-Windows targets, and for non-&lt;code&gt;bin&lt;/code&gt;&lt;a href=&quot;linkage&quot;&gt;crate types&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;windows_subsystem&lt;/code&gt; の属性が&lt;/em&gt;設定するクレートレベルで適用することができる&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/fcc1zstk.aspx&quot;&gt;サブシステムを&lt;/a&gt;、Windowsのターゲットにリンクするとき。&lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt;構文を使用して、 &lt;code&gt;console&lt;/code&gt; または &lt;code&gt;windows&lt;/code&gt; のいずれかの値でサブシステムを指定します。この属性は、Windows以外のターゲット、および &lt;code&gt;bin&lt;/code&gt; &lt;a href=&quot;linkage&quot;&gt;箱タイプで&lt;/a&gt;は無視されます。</target>
        </trans-unit>
        <trans-unit id="637d9dddc1ad4617a0c58ddffc3922ae87e9baab" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;alignment&lt;/em&gt; of a value specifies what addresses are valid to store the value at. A value of alignment &lt;code&gt;n&lt;/code&gt; must only be stored at an address that is a multiple of n. For example, a value with an alignment of 2 must be stored at an even address, while a value with an alignment of 1 can be stored at any address. Alignment is measured in bytes, and must be at least 1, and always a power of 2. The alignment of a value can be checked with the &lt;a href=&quot;../std/mem/fn.align_of_val&quot;&gt;&lt;code&gt;align_of_val&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">値の&lt;em&gt;配置&lt;/em&gt;は、値を格納するために有効なアドレスを指定します。アライメント &lt;code&gt;n&lt;/code&gt; の値は、nの倍数であるアドレスにのみ格納する必要があります。たとえば、アラインメントが2の値は偶数アドレスに格納する必要がありますが、アラインメントが1の値は任意のアドレスに格納できます。アラインメントはバイト単位で測定され、少なくとも1、常に2の累乗でなければなりません。値のアラインメントは、&lt;a href=&quot;../std/mem/fn.align_of_val&quot;&gt; &lt;code&gt;align_of_val&lt;/code&gt; &lt;/a&gt;関数で確認できます。</target>
        </trans-unit>
        <trans-unit id="caa4287ee2eae29f4b7097731528e2f984499328" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;at&lt;/em&gt; operator (&lt;code&gt;@&lt;/code&gt;) lets us create a variable that holds a value at the same time we&amp;rsquo;re testing that value to see whether it matches a pattern. Listing 18-29 shows an example where we want to test that a &lt;code&gt;Message::Hello&lt;/code&gt;&lt;code&gt;id&lt;/code&gt; field is within the range &lt;code&gt;3...7&lt;/code&gt;. But we also want to bind the value to the variable &lt;code&gt;id_variable&lt;/code&gt; so we can use it in the code associated with the arm. We could name this variable &lt;code&gt;id&lt;/code&gt;, the same as the field, but for this example we&amp;rsquo;ll use a different name.</source>
          <target state="translated">&lt;em&gt;で、&lt;/em&gt;オペレータは、（ &lt;code&gt;@&lt;/code&gt; ）私たちは、それがパターンに一致するかどうかを確認するために、その値をテストしていると同時に、値を保持する変数を作成することができます。リスト18-29は、 &lt;code&gt;Message::Hello&lt;/code&gt; &lt;code&gt;id&lt;/code&gt; フィールドが &lt;code&gt;3...7&lt;/code&gt; 範囲内にあることをテストしたい例を示しています。しかし、値を変数 &lt;code&gt;id_variable&lt;/code&gt; にバインドして、armに関連付けられたコードで使用できるようにする必要もあります。私たちは、この変数名可能性が &lt;code&gt;id&lt;/code&gt; 、フィールドと同じですが、この例のために、私たちは別の名前を使用します。</target>
        </trans-unit>
        <trans-unit id="6fe3095ea3510353b505863afd4ade90995e4e2e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;at&lt;/em&gt; operator (&lt;code&gt;@&lt;/code&gt;) lets us create a variable that holds a value at the same time we&amp;rsquo;re testing that value to see whether it matches a pattern. Listing 18-29 shows an example where we want to test that a &lt;code&gt;Message::Hello&lt;/code&gt;&lt;code&gt;id&lt;/code&gt; field is within the range &lt;code&gt;3..=7&lt;/code&gt;. But we also want to bind the value to the variable &lt;code&gt;id_variable&lt;/code&gt; so we can use it in the code associated with the arm. We could name this variable &lt;code&gt;id&lt;/code&gt;, the same as the field, but for this example we&amp;rsquo;ll use a different name.</source>
          <target state="translated">&lt;em&gt;で、&lt;/em&gt;オペレータは、（ &lt;code&gt;@&lt;/code&gt; ）私たちは、それがパターンに一致するかどうかを確認するために、その値をテストしていると同時に、値を保持する変数を作成することができます。リスト18-29は、 &lt;code&gt;Message::Hello&lt;/code&gt; &lt;code&gt;id&lt;/code&gt; フィールドが &lt;code&gt;3..=7&lt;/code&gt; 範囲内にあることをテストする例を示しています。ただし、値を変数 &lt;code&gt;id_variable&lt;/code&gt; にバインドして、armに関連付けられたコードで使用できるようにする必要もあります。この変数 &lt;code&gt;id&lt;/code&gt; には、フィールドと同じ名前を付けることができますが、この例では別の名前を使用します。</target>
        </trans-unit>
        <trans-unit id="491e011fde2c63e7287e5968a958f99a0e0608ea" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;backslash escape&lt;/em&gt; is the character &lt;code&gt;U+005C&lt;/code&gt; (&lt;code&gt;\&lt;/code&gt;) which must be escaped in order to denote its ASCII encoding &lt;code&gt;0x5C&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;バックスラッシュエスケープは、&lt;/em&gt;文字である &lt;code&gt;U+005C&lt;/code&gt; （ &lt;code&gt;\&lt;/code&gt; そのASCIIエンコード示すためにエスケープする必要があります） &lt;code&gt;0x5C&lt;/code&gt; をします。</target>
        </trans-unit>
        <trans-unit id="e78bebf05e1ce9e264a960c4a634448ed6a163c1" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;backslash escape&lt;/em&gt; is the character &lt;code&gt;U+005C&lt;/code&gt; (&lt;code&gt;\&lt;/code&gt;) which must be escaped in order to denote itself.</source>
          <target state="translated">&lt;em&gt;バックスラッシュエスケープは、&lt;/em&gt;文字である &lt;code&gt;U+005C&lt;/code&gt; （ &lt;code&gt;\&lt;/code&gt; そのものを表すためにエスケープする必要があります）。</target>
        </trans-unit>
        <trans-unit id="863e56925d2ff8675a4dd9c4a460d825a809b69e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;heap&lt;/em&gt; is a general term that describes boxes. The lifetime of an allocation in the heap depends on the lifetime of the box values pointing to it. Since box values may themselves be passed in and out of frames, or stored in the heap, heap allocations may outlive the frame they are allocated within. An allocation in the heap is guaranteed to reside at a single location in the heap for the whole lifetime of the allocation - it will never be relocated as a result of moving a box value.</source>
          <target state="translated">&lt;em&gt;ヒープは&lt;/em&gt;ボックスについて説明し、一般的な用語です。ヒープ内の割り当ての有効期間は、それを指すボックス値の有効期間に依存します。ボックスの値自体がフレームの内外に渡されるか、ヒープに格納されるため、ヒープの割り当ては、それらが割り当てられたフレームよりも長く存続する場合があります。ヒープ内の割り当ては、割り当ての存続期間全体にわたってヒープ内の1つの場所に存在することが保証されています。ボックスの値を移動した結果として、再配置されることはありません。</target>
        </trans-unit>
        <trans-unit id="21ffe4f08baa3ee5d8fcae0ac2b2640039bc170b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;items&lt;/em&gt; of a program are those functions, modules and types that have their value calculated at compile-time and stored uniquely in the memory image of the rust process. Items are neither dynamically allocated nor freed.</source>
          <target state="translated">プログラムの&lt;em&gt;項目&lt;/em&gt;は、コンパイル時に計算され、rustプロセスのメモリイメージに一意に格納される関数、モジュール、およびタイプです。アイテムは動的に割り当てられることも解放されることもありません。</target>
        </trans-unit>
        <trans-unit id="7f297b31862071391a99da1af535c50f23bb4ea5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;items&lt;/em&gt; of a program are those functions, modules, and types that have their value calculated at compile-time and stored uniquely in the memory image of the rust process. Items are neither dynamically allocated nor freed.</source>
          <target state="translated">プログラムの&lt;em&gt;項目&lt;/em&gt;は、コンパイル時に値が計算され、rustプロセスのメモリイメージに一意に格納される関数、モジュール、およびタイプです。アイテムは動的に割り当ても解放もされません。</target>
        </trans-unit>
        <trans-unit id="867bacda5c963969dd78331f878c031b22f73cbb" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;null escape&lt;/em&gt; is the character &lt;code&gt;U+0030&lt;/code&gt; (&lt;code&gt;0&lt;/code&gt;) and denotes the Unicode value &lt;code&gt;U+0000&lt;/code&gt; (NUL).</source>
          <target state="translated">&lt;em&gt;ヌルエスケープは&lt;/em&gt;文字である &lt;code&gt;U+0030&lt;/code&gt; （ &lt;code&gt;0&lt;/code&gt; ）とUnicode値意味 &lt;code&gt;U+0000&lt;/code&gt; （NUL）を。</target>
        </trans-unit>
        <trans-unit id="c0460a3f4832868522908bad2876d5f8fef36d49" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;null escape&lt;/em&gt; is the character &lt;code&gt;U+0030&lt;/code&gt; (&lt;code&gt;0&lt;/code&gt;) and denotes the byte value &lt;code&gt;0x00&lt;/code&gt; (ASCII NUL).</source>
          <target state="translated">&lt;em&gt;ヌルエスケープは&lt;/em&gt;文字である &lt;code&gt;U+0030&lt;/code&gt; （ &lt;code&gt;0&lt;/code&gt; ）とバイト値意味 &lt;code&gt;0x00&lt;/code&gt; （ASCII NUL）を。</target>
        </trans-unit>
        <trans-unit id="b4b356718e399f8a05dc4012731a26a28084f252" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;prelude&lt;/em&gt; is the list of things that Rust automatically imports into every Rust program. It's kept as small as possible, and is focused on things, particularly traits, which are used in almost every single Rust program.</source>
          <target state="translated">&lt;em&gt;前奏曲は&lt;/em&gt;、すべての錆プログラムに錆が自動的に輸入もののリストです。それは可能な限り小さく保たれ、ほとんどすべてのRustプログラムで使用されるもの、特に特性に焦点が当てられています。</target>
        </trans-unit>
        <trans-unit id="c5fc79bf9688aa8e786959c2742e411818e5d89a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;primitive representations&lt;/em&gt; are the representations with the same names as the primitive integer types. That is: &lt;code&gt;u8&lt;/code&gt;, &lt;code&gt;u16&lt;/code&gt;, &lt;code&gt;u32&lt;/code&gt;, &lt;code&gt;u64&lt;/code&gt;, &lt;code&gt;u128&lt;/code&gt;, &lt;code&gt;usize&lt;/code&gt;, &lt;code&gt;i8&lt;/code&gt;, &lt;code&gt;i16&lt;/code&gt;, &lt;code&gt;i32&lt;/code&gt;, &lt;code&gt;i64&lt;/code&gt;, &lt;code&gt;i128&lt;/code&gt;, and &lt;code&gt;isize&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;プリミティブ表現は&lt;/em&gt;、プリミティブ整数型と同じ名前の表現です。つまり、 &lt;code&gt;u8&lt;/code&gt; 、 &lt;code&gt;u16&lt;/code&gt; 、 &lt;code&gt;u32&lt;/code&gt; 、 &lt;code&gt;u64&lt;/code&gt; 、 &lt;code&gt;u128&lt;/code&gt; 、 &lt;code&gt;usize&lt;/code&gt; 、 &lt;code&gt;i8&lt;/code&gt; 、 &lt;code&gt;i16&lt;/code&gt; 、 &lt;code&gt;i32&lt;/code&gt; 、 &lt;code&gt;i64&lt;/code&gt; 、 &lt;code&gt;i128&lt;/code&gt; 、 &lt;code&gt;isize&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="a3ce8f949608b1daede8105623fa327eab5c410b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;rest pattern&lt;/em&gt; (the &lt;code&gt;..&lt;/code&gt; token) acts as a variable-length pattern which matches zero or more elements that haven't been matched already before and after. It may only be used in &lt;a href=&quot;#tuple-patterns&quot;&gt;tuple&lt;/a&gt;, &lt;a href=&quot;#tuple-struct-patterns&quot;&gt;tuple struct&lt;/a&gt;, and &lt;a href=&quot;#slice-patterns&quot;&gt;slice&lt;/a&gt; patterns, and may only appear once as one of the elements in those patterns. It is also allowed in an &lt;a href=&quot;#identifier-patterns&quot;&gt;identifier pattern&lt;/a&gt; for &lt;a href=&quot;#slice-patterns&quot;&gt;slice patterns&lt;/a&gt; only.</source>
          <target state="translated">&lt;em&gt;静止パターン&lt;/em&gt;（ &lt;code&gt;..&lt;/code&gt; トークン）が前後に既に一致していないゼロ個以上の要素と一致する可変長パターンとして機能します。それだけで使用することができる&lt;a href=&quot;#tuple-patterns&quot;&gt;タプル&lt;/a&gt;、&lt;a href=&quot;#tuple-struct-patterns&quot;&gt;タプル構造体&lt;/a&gt;、及び&lt;a href=&quot;#slice-patterns&quot;&gt;スライス&lt;/a&gt;パターン、およびのみパターンの要素の一つとして一度に表示されてもよいです。また、&lt;a href=&quot;#slice-patterns&quot;&gt;スライスパターンの&lt;/a&gt;&lt;a href=&quot;#identifier-patterns&quot;&gt;識別子パターン&lt;/a&gt;でも許可されます。</target>
        </trans-unit>
        <trans-unit id="4971362f3b5f40470a74c81b64c44c61022c0ae5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;size&lt;/em&gt; of a value is the offset in bytes between successive elements in an array with that item type including alignment padding. The size of a value is always a multiple of its alignment. The size of a value can be checked with the &lt;a href=&quot;../std/mem/fn.size_of_val&quot;&gt;&lt;code&gt;size_of_val&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">値の&lt;em&gt;サイズ&lt;/em&gt;は、配列のパディングを含むその項目タイプの配列内の連続する要素間のバイト単位のオフセットです。値のサイズは常にその配置の倍数です。値のサイズは、&lt;a href=&quot;../std/mem/fn.size_of_val&quot;&gt; &lt;code&gt;size_of_val&lt;/code&gt; &lt;/a&gt;関数で確認できます。</target>
        </trans-unit>
        <trans-unit id="608607007d0795edd59e30f51aeabc80ca46b5f6" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;state pattern&lt;/em&gt; is an object-oriented design pattern. The crux of the pattern is that a value has some internal state, which is represented by a set of &lt;em&gt;state objects&lt;/em&gt;, and the value&amp;rsquo;s behavior changes based on the internal state. The state objects share functionality: in Rust, of course, we use structs and traits rather than objects and inheritance. Each state object is responsible for its own behavior and for governing when it should change into another state. The value that holds a state object knows nothing about the different behavior of the states or when to transition between states.</source>
          <target state="translated">&lt;em&gt;状態パターンは、&lt;/em&gt;オブジェクト指向のデザインパターンです。パターンの要点は、値に一連の&lt;em&gt;状態オブジェクト&lt;/em&gt;で表される内部状態があり、値の動作が内部状態に基づいて変化することです。状態オブジェクトは機能を共有します。もちろん、Rustでは、オブジェクトと継承ではなく、構造体と特性を使用します。各状態オブジェクトは、それ自体の動作と、いつ別の状態に変化するかを管理します。状態オブジェクトを保持する値は、状態のさまざまな動作や状態間の遷移のタイミングについて何も知りません。</target>
        </trans-unit>
        <trans-unit id="ec835310b404eed2cb3a60731c66a0fc7069cf96" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;successor&lt;/em&gt; operation moves towards values that compare greater. The &lt;em&gt;predecessor&lt;/em&gt; operation moves towards values that compare lesser.</source>
          <target state="translated">&lt;em&gt;後継&lt;/em&gt;大きい比較値に向かって操作動きます。&lt;em&gt;先行&lt;/em&gt;少ない比較値に向かって操作動きます。</target>
        </trans-unit>
        <trans-unit id="71b31d9fd96bdd059ab3da8b882ee0c455f89891" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;temporary scope&lt;/em&gt; of an expression is the scope that is used for the temporary variable that holds the result of that expression when used in a &lt;a href=&quot;expressions#place-expressions-and-value-expressions&quot;&gt;place context&lt;/a&gt;, unless it is &lt;a href=&quot;destructors#constant-promotion&quot;&gt;promoted&lt;/a&gt;.</source>
          <target state="translated">式の&lt;em&gt;一時スコープ&lt;/em&gt;は、&lt;a href=&quot;destructors#constant-promotion&quot;&gt;プロモート&lt;/a&gt;されていない限り、&lt;a href=&quot;expressions#place-expressions-and-value-expressions&quot;&gt;プレイスコンテキスト&lt;/a&gt;で使用されたときにその式の結果を保持する一時変数に使用されるスコープです。</target>
        </trans-unit>
        <trans-unit id="da892b01ccbdf152bb00bb5fb34ad8db3069d651" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;tuple type&lt;/em&gt; is a structural type&lt;sup&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; for heterogeneous lists of other types. Each entry in the list is an &lt;em&gt;element&lt;/em&gt;&lt;sup&gt;&lt;a href=&quot;#2&quot;&gt;2&lt;/a&gt;&lt;/sup&gt; of the tuple. The position of the element makes it the &lt;em&gt;nth element&lt;/em&gt; using zero (&lt;code&gt;0&lt;/code&gt;) as the initial index.</source>
          <target state="translated">&lt;em&gt;タプルタイプは&lt;/em&gt;構造タイプである&lt;sup&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;、他のタイプの不均一リストの。リストの各エントリは、タプルの&lt;em&gt;要素&lt;/em&gt;&lt;sup&gt;&lt;a href=&quot;#2&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;です。要素の位置は、初期インデックスとしてゼロ（ &lt;code&gt;0&lt;/code&gt; ）を使用する&lt;em&gt;n番目の要素になり&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="50c8131f661492ad3eb04d5338d01ccf9f429562" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;wildcard pattern&lt;/em&gt; (an underscore symbol) matches any value. It is used to ignore values when they don't matter. Inside other patterns it matches a single data field (as opposed to the &lt;code&gt;..&lt;/code&gt; which matches the remaining fields). Unlike identifier patterns, it does not copy, move or borrow the value it matches.</source>
          <target state="translated">&lt;em&gt;ワイルドカードパターン&lt;/em&gt;（下線記号）は、任意の値と一致します。値が重要でない場合に値を無視するために使用されます。他のパターン内では、単一のデータフィールドに一致します（残りのフィールドに一致する &lt;code&gt;..&lt;/code&gt; とは対照的です）。識別子パターンとは異なり、一致する値をコピー、移動、または借用しません。</target>
        </trans-unit>
        <trans-unit id="2c707e6c38639fd82e39cc81120827bce74e177e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;wildcard pattern&lt;/em&gt; matches any value. It is used to ignore values when they don't matter. Inside other patterns it matches a single data field (as opposed to the &lt;code&gt;..&lt;/code&gt; which matches the remaining fields). Unlike identifier patterns, it does not copy, move or borrow the value it matches.</source>
          <target state="translated">&lt;em&gt;ワイルドカードパターンは&lt;/em&gt;任意の値に一致します。値が重要ではない場合に無視するために使用されます。他のパターン内では、単一のデータフィールドに一致します（残りのフィールドに一致する &lt;code&gt;..&lt;/code&gt; とは対照的です）。識別子パターンとは異なり、一致する値をコピー、移動、または借用しません。</target>
        </trans-unit>
        <trans-unit id="75f0595163c83b48141e476739787cd1006a8d33" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;channel&lt;/strong&gt;'s sending half has become disconnected, and there will never be any more data received on it.</source>
          <target state="translated">&lt;strong&gt;チャネル&lt;/strong&gt;の送信の半分が切断になってきた、そしてそれを受け、それ以上のデータがあることはありません。</target>
        </trans-unit>
        <trans-unit id="7d020769b0b6d90680db8e09c6dc6e9b663dc909" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;compiler&lt;/strong&gt; reordering instructions: If the compiler can issue an instruction at an earlier point, it will try to do so. For example, it might hoist memory loads at the top of a code block, so that the CPU can start &lt;a href=&quot;https://en.wikipedia.org/wiki/Cache_prefetching&quot;&gt;prefetching&lt;/a&gt; the values from memory.</source>
          <target state="translated">&lt;strong&gt;コンパイラ&lt;/strong&gt;の指示を並べ替え：コンパイラは、以前の時点で指示を出すことができれば、それはそうしようとします。たとえば、CPUがメモリからの値の&lt;a href=&quot;https://en.wikipedia.org/wiki/Cache_prefetching&quot;&gt;プリフェッチ&lt;/a&gt;を開始できるように、メモリブロックをコードブロックの先頭で引き上げる場合があります。</target>
        </trans-unit>
        <trans-unit id="314b68cd7b660a21edb44d2117cd4a156ae245a5" translate="yes" xml:space="preserve">
          <source>The API documentation that &lt;code&gt;cargo doc&lt;/code&gt; generates for this crate will now list and link re-exports on the front page, as shown in Figure 14-4, making the &lt;code&gt;PrimaryColor&lt;/code&gt; and &lt;code&gt;SecondaryColor&lt;/code&gt; types and the &lt;code&gt;mix&lt;/code&gt; function easier to find.</source>
          <target state="translated">図14-4に示すように、 &lt;code&gt;cargo doc&lt;/code&gt; がこのクレートに対して生成するAPIドキュメントは、フロントページに再エクスポートをリストおよびリンクし、 &lt;code&gt;PrimaryColor&lt;/code&gt; および &lt;code&gt;SecondaryColor&lt;/code&gt; タイプと &lt;code&gt;mix&lt;/code&gt; 関数を見つけやすくします。</target>
        </trans-unit>
        <trans-unit id="fe97d53a4341ff985473c7759453c7f0b6f51809" translate="yes" xml:space="preserve">
          <source>The API is typically used by acquiring a handle to the current thread, placing that handle in a shared data structure so that other threads can find it, and then &lt;code&gt;park&lt;/code&gt;ing in a loop. When some desired condition is met, another thread calls &lt;a href=&quot;struct.thread#method.unpark&quot;&gt;&lt;code&gt;unpark&lt;/code&gt;&lt;/a&gt; on the handle.</source>
          <target state="translated">APIは、典型的には、他のスレッドがそれを見つけることができるように、共有データ構造で、そのハンドルを配置し、現在のスレッドへのハンドルを取得することで使用して、さ &lt;code&gt;park&lt;/code&gt; ループにする。必要な条件が満たされると、別のスレッドがハンドルの&lt;a href=&quot;struct.thread#method.unpark&quot;&gt; &lt;code&gt;unpark&lt;/code&gt; &lt;/a&gt;を呼び出します。</target>
        </trans-unit>
        <trans-unit id="bdef16eb0aad1c8443510daaf0eaf64f22da449f" translate="yes" xml:space="preserve">
          <source>The API of &lt;code id=&quot;the-api-of-mutext&quot;&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code id=&quot;the-api-of-mutext&quot;&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; のAPI</target>
        </trans-unit>
        <trans-unit id="da2fca5419425bb1dfeff3a19e5e6b522b71b9f7" translate="yes" xml:space="preserve">
          <source>The Anatomy of a Test Function</source>
          <target state="translated">テスト機能の解剖学</target>
        </trans-unit>
        <trans-unit id="6ff9dd46af7ebe72f506f56aea2ffd15b7f82cfe" translate="yes" xml:space="preserve">
          <source>The Array Type</source>
          <target state="translated">配列型</target>
        </trans-unit>
        <trans-unit id="4c7fdb8a442bced7fcc6b743d86e4b178b1bc140" translate="yes" xml:space="preserve">
          <source>The Boolean Type</source>
          <target state="translated">ブール型</target>
        </trans-unit>
        <trans-unit id="7a47e0b8b6b1bfa40f74993b9ed02984c335782d" translate="yes" xml:space="preserve">
          <source>The Boolean type, &lt;code&gt;bool&lt;/code&gt;, with values &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">ブール型 &lt;code&gt;bool&lt;/code&gt; で、値は &lt;code&gt;true&lt;/code&gt; と &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="d554fe4c508301c7dd79586706f031038650a679" translate="yes" xml:space="preserve">
          <source>The Borrow Checker</source>
          <target state="translated">借り入れチェッカー</target>
        </trans-unit>
        <trans-unit id="706bc5bdd045092d3c34365727a87c607d4ff3a3" translate="yes" xml:space="preserve">
          <source>The C side must &lt;strong&gt;not&lt;/strong&gt; modify the length of the string (by writing a &lt;code&gt;NULL&lt;/code&gt; somewhere inside the string or removing the final one) before it makes it back into Rust using &lt;a href=&quot;struct.cstring#method.from_raw&quot;&gt;&lt;code&gt;CString::from_raw&lt;/code&gt;&lt;/a&gt;. See the safety section in &lt;a href=&quot;struct.cstring#method.from_raw&quot;&gt;&lt;code&gt;CString::from_raw&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">C側は、&lt;a href=&quot;struct.cstring#method.from_raw&quot;&gt; &lt;code&gt;CString::from_raw&lt;/code&gt; &lt;/a&gt;を使用してRustに戻す前に、文字列の長さを変更してはなりませ&lt;strong&gt;ん&lt;/strong&gt;（文字列内のどこかに &lt;code&gt;NULL&lt;/code&gt; を書き込むか、最後の文字列を削除します）。&lt;a href=&quot;struct.cstring#method.from_raw&quot;&gt; &lt;code&gt;CString::from_raw&lt;/code&gt; &lt;/a&gt;安全セクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="096fc2c3eb95fb5d0ee6aa092c0689c069929e6f" translate="yes" xml:space="preserve">
          <source>The C-main function only supports to return integers as return type. So, every type implementing the &lt;code&gt;Termination&lt;/code&gt; trait has to be converted to an integer.</source>
          <target state="translated">C-main関数は、戻り値の型として整数を返すことのみをサポートしています。したがって、 &lt;code&gt;Termination&lt;/code&gt; 特性を実装するすべてのタイプは整数に変換する必要があります。</target>
        </trans-unit>
        <trans-unit id="da6976366f57ccb20ad430117c89098f7fb1348a" translate="yes" xml:space="preserve">
          <source>The C-variadic type &lt;code&gt;...&lt;/code&gt; has been nested inside another type.</source>
          <target state="translated">C可変個引数型 &lt;code&gt;...&lt;/code&gt; は別の型の中にネストされています。</target>
        </trans-unit>
        <trans-unit id="86641abf85c69d8c4f7c9c71c79144e3a2832005" translate="yes" xml:space="preserve">
          <source>The Character Type</source>
          <target state="translated">文字タイプ</target>
        </trans-unit>
        <trans-unit id="35e39875eebfabcb5b0b8cd30288767fc0b6add8" translate="yes" xml:space="preserve">
          <source>The Clippy tool is a collection of lints to analyze your code so you can catch common mistakes and improve your Rust code.</source>
          <target state="translated">Clippy ツールは、コードを分析するための lints のコレクションで、よくある間違いを見つけて Rust コードを改善することができます。</target>
        </trans-unit>
        <trans-unit id="bb08bad287d0caba2752b58d322b62f2942d38e6" translate="yes" xml:space="preserve">
          <source>The Default Representation</source>
          <target state="translated">デフォルトの表現</target>
        </trans-unit>
        <trans-unit id="f9e1a59444e395f067802b105261ac31a11eac66" translate="yes" xml:space="preserve">
          <source>The Difference Between Macros and Functions</source>
          <target state="translated">マクロと関数の違い</target>
        </trans-unit>
        <trans-unit id="7241096a248faf0667959dae2f7e6a0390d29dce" translate="yes" xml:space="preserve">
          <source>The GID part of the peer credential. This is the effective GID of the process at the domain socket's endpoint.</source>
          <target state="translated">ピアクレデンシャルの GID 部分。これは、ドメインソケットのエンドポイントのプロセスの有効なGIDである。</target>
        </trans-unit>
        <trans-unit id="47f6987535ee435e225cb875fe024ba6f3b75e49" translate="yes" xml:space="preserve">
          <source>The Glob Operator</source>
          <target state="translated">Globオペレータ</target>
        </trans-unit>
        <trans-unit id="a0a1aaf98c3bce57246183f1baadfe83da9b49cd" translate="yes" xml:space="preserve">
          <source>The HTML format is available online at &lt;a href=&quot;https://doc.rust-lang.org/stable/book/index.html&quot;&gt;https://doc.rust-lang.org/stable/book/&lt;/a&gt; and offline with installations of Rust made with &lt;code&gt;rustup&lt;/code&gt;; run &lt;code&gt;rustup docs --book&lt;/code&gt; to open.</source>
          <target state="translated">HTML形式は、&lt;a href=&quot;https://doc.rust-lang.org/stable/book/index.html&quot;&gt;https：&lt;/a&gt; &lt;code&gt;rustup&lt;/code&gt; でオンラインで、rustupで作成されたRustをインストールするとオフラインで利用できます。 &lt;code&gt;rustup docs --book&lt;/code&gt; を実行して開きます。</target>
        </trans-unit>
        <trans-unit id="00df77514c97d921fca4a972435309219a163a06" translate="yes" xml:space="preserve">
          <source>The I/O Prelude</source>
          <target state="translated">I/Oプレリュード</target>
        </trans-unit>
        <trans-unit id="6979c051972c7d2da3658847fabbf6a31d84bdb5" translate="yes" xml:space="preserve">
          <source>The I/O operation's timeout expired, causing it to be canceled.</source>
          <target state="translated">I/O操作のタイムアウトが切れたため、キャンセルされました。</target>
        </trans-unit>
        <trans-unit id="dc9c14a7eb4854c512e7ed69d5ba6a43f9c253aa" translate="yes" xml:space="preserve">
          <source>The IEEE 754-2008 &quot;binary32&quot; and &quot;binary64&quot; floating-point types are &lt;code&gt;f32&lt;/code&gt; and &lt;code&gt;f64&lt;/code&gt;, respectively.</source>
          <target state="translated">IEEE 754-2008の「binary32」と「binary64」の浮動小数点型は、それぞれ &lt;code&gt;f32&lt;/code&gt; と &lt;code&gt;f64&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="a46bc695392f8c742f4e678a79ed2375790074cb" translate="yes" xml:space="preserve">
          <source>The Matcher Invariants</source>
          <target state="translated">マッチャ不変量</target>
        </trans-unit>
        <trans-unit id="5eece4981b24083c68ecabd071b66fe17ba1ce62" translate="yes" xml:space="preserve">
          <source>The Never Type that Never Returns</source>
          <target state="translated">絶対に返ってこないネバータイプ</target>
        </trans-unit>
        <trans-unit id="388566f1f9117600ae22e2ebff51f82d448e95e2" translate="yes" xml:space="preserve">
          <source>The PID part of the peer credential. This field is optional because the PID part of the peer credentials is not supported on every platform. On platforms where the mechanism to discover the PID exists, this field will be populated to the PID of the process at the domain socket's endpoint. Otherwise, it will be set to None.</source>
          <target state="translated">ピア・クレデンシャルの PID 部分。このフィールドは、すべてのプラットフォームでピアクレデンシャルの PID 部分がサポートされているわけではないため、オプションである。PID を検出するメカニズムが存在するプラットフォームでは、このフィールドにはドメインソケットのエンドポイントのプロセスの PID が入力される。それ以外の場合は None に設定される。</target>
        </trans-unit>
        <trans-unit id="41b8e7692f976fe91f0cb8053dcf33a7090a4f8c" translate="yes" xml:space="preserve">
          <source>The Pattern API provides a generic mechanism for using different pattern types when searching through a string.</source>
          <target state="translated">パターンAPIは、文字列を検索する際に異なるパターンタイプを使用するための一般的なメカニズムを提供します。</target>
        </trans-unit>
        <trans-unit id="ba8021c95f458659340856b34b5ce555bddda300" translate="yes" xml:space="preserve">
          <source>The RFC Process and Teams</source>
          <target state="translated">RFCのプロセスとチーム</target>
        </trans-unit>
        <trans-unit id="667bd8e20b1ba8153f27c9ff6c220024562a73c6" translate="yes" xml:space="preserve">
          <source>The Rules of References</source>
          <target state="translated">参考文献のルール</target>
        </trans-unit>
        <trans-unit id="161ef3f14aee5229baf3e48cdbbdab5a784349b3" translate="yes" xml:space="preserve">
          <source>The Rust Language Server powers Integrated Development Environment (IDE) integration for code completion and inline error messages.</source>
          <target state="translated">Rust Language Server は、コード補完とインライン エラー メッセージのための統合開発環境 (IDE)を提供します。</target>
        </trans-unit>
        <trans-unit id="efbadde43b4ea2876af269fef5bbeff660435dad" translate="yes" xml:space="preserve">
          <source>The Rust Prelude</source>
          <target state="translated">サビの前奏曲</target>
        </trans-unit>
        <trans-unit id="1e47c327d13b68cc315d8c0718500294854d4bd4" translate="yes" xml:space="preserve">
          <source>The Rust Prelude.</source>
          <target state="translated">ラストの前奏曲。</target>
        </trans-unit>
        <trans-unit id="64d4853b323b63d9ca56f4771bf913212d9ace7a" translate="yes" xml:space="preserve">
          <source>The Rust Programming Language</source>
          <target state="translated">Rust プログラミング言語</target>
        </trans-unit>
        <trans-unit id="0bb645ae646711df91105c5e5d03daf9c88ee91b" translate="yes" xml:space="preserve">
          <source>The Rust Standard Library</source>
          <target state="translated">ラスト標準ライブラリ</target>
        </trans-unit>
        <trans-unit id="9c789ddc154274d796ddc2e963326017f63c2958" translate="yes" xml:space="preserve">
          <source>The Rust Standard Library is the foundation of portable Rust software, a set of minimal and battle-tested shared abstractions for the &lt;a href=&quot;https://crates.io&quot;&gt;broader Rust ecosystem&lt;/a&gt;. It offers core types, like &lt;a href=&quot;vec/index&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;option/enum.option&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, library-defined &lt;a href=&quot;#primitives&quot;&gt;operations on language primitives&lt;/a&gt;, &lt;a href=&quot;#macros&quot;&gt;standard macros&lt;/a&gt;, &lt;a href=&quot;io/index&quot;&gt;I/O&lt;/a&gt; and &lt;a href=&quot;thread/index&quot;&gt;multithreading&lt;/a&gt;, among &lt;a href=&quot;#what-is-in-the-standard-library-documentation&quot;&gt;many other things&lt;/a&gt;.</source>
          <target state="translated">Rust標準ライブラリは、ポータブルRustソフトウェアの基盤であり、&lt;a href=&quot;https://crates.io&quot;&gt;幅広いRustエコシステム&lt;/a&gt;向けの最小限の、かつテスト済みの共有抽象化のセットです。それは次のように、コアの種類を提供しています&lt;a href=&quot;vec/index&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;option/enum.option&quot;&gt; &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;、ライブラリーに定義された&lt;a href=&quot;#primitives&quot;&gt;言語のプリミティブ上の操作&lt;/a&gt;、&lt;a href=&quot;#macros&quot;&gt;標準マクロ&lt;/a&gt;、&lt;a href=&quot;io/index&quot;&gt;I / O&lt;/a&gt;や&lt;a href=&quot;thread/index&quot;&gt;マルチスレッド&lt;/a&gt;の中で、&lt;a href=&quot;#what-is-in-the-standard-library-documentation&quot;&gt;他の多くのもの&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4d3f2d23ee5d88e5e35ea9e8e79bcbc0fd6e3b11" translate="yes" xml:space="preserve">
          <source>The Rust Standard Library is the foundation of portable Rust software, a set of minimal and battle-tested shared abstractions for the &lt;a href=&quot;https://crates.io&quot;&gt;broader Rust ecosystem&lt;/a&gt;. It offers core types, like &lt;a href=&quot;vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;option/enum.option&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, library-defined &lt;a href=&quot;#primitives&quot;&gt;operations on language primitives&lt;/a&gt;, &lt;a href=&quot;#macros&quot;&gt;standard macros&lt;/a&gt;, &lt;a href=&quot;io/index&quot;&gt;I/O&lt;/a&gt; and &lt;a href=&quot;thread/index&quot;&gt;multithreading&lt;/a&gt;, among &lt;a href=&quot;#what-is-in-the-standard-library-documentation&quot;&gt;many other things&lt;/a&gt;.</source>
          <target state="translated">Rust Standard Libraryは、ポータブルRustソフトウェアの基盤であり、&lt;a href=&quot;https://crates.io&quot;&gt;より広範なRustエコシステム&lt;/a&gt;向けの最小限の戦闘テスト済みの共有抽象化のセットです。それは次のように、コアの種類を提供しています&lt;a href=&quot;vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;option/enum.option&quot;&gt; &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;、ライブラリーに定義された&lt;a href=&quot;#primitives&quot;&gt;言語のプリミティブ上の操作&lt;/a&gt;、&lt;a href=&quot;#macros&quot;&gt;標準マクロ&lt;/a&gt;、&lt;a href=&quot;io/index&quot;&gt;I / O&lt;/a&gt;や&lt;a href=&quot;thread/index&quot;&gt;マルチスレッド&lt;/a&gt;の中で、&lt;a href=&quot;#what-is-in-the-standard-library-documentation&quot;&gt;他の多くのもの&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5c3853d774e4956749b7c91653db336f2eec58d4" translate="yes" xml:space="preserve">
          <source>The Rust compiler does not consider the following behaviors &lt;em&gt;unsafe&lt;/em&gt;, though a programmer may (should) find them undesirable, unexpected, or erroneous.</source>
          <target state="translated">Rustコンパイラーは、以下の動作を&lt;em&gt;安全&lt;/em&gt;でないと見なしませんが、プログラマーはそれらを望ましくない、予期しない、または誤ったものと見なす可能性があります（すべきです）。</target>
        </trans-unit>
        <trans-unit id="21b3dd0203ec587beb1963c1f4feb0c5c3e73b91" translate="yes" xml:space="preserve">
          <source>The Rust compiler has a &lt;em&gt;borrow checker&lt;/em&gt; that compares scopes to determine whether all borrows are valid. Listing 10-18 shows the same code as Listing 10-17 but with annotations showing the lifetimes of the variables.</source>
          <target state="translated">Rustコンパイラには、スコープを比較してすべての借用が有効かどうかを判断する&lt;em&gt;借用チェッカー&lt;/em&gt;があります。リスト10-18はリスト10-17と同じコードを示していますが、変数の寿命を示す注釈が付いています。</target>
        </trans-unit>
        <trans-unit id="bac79421ac7e7f4a69670a43a87279fa1ea360c9" translate="yes" xml:space="preserve">
          <source>The Rust compiler is always invoked with a single source file as input, and always produces a single output crate. The processing of that source file may result in other source files being loaded as modules. Source files have the extension &lt;code&gt;.rs&lt;/code&gt;.</source>
          <target state="translated">Rustコンパイラーは、常に単一のソースファイルを入力として呼び出され、常に単一の出力クレートを生成します。そのソースファイルの処理により、他のソースファイルがモジュールとしてロードされる場合があります。ソースファイルの拡張子は &lt;code&gt;.rs&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="edecdb50208b6b73bf12c25a96c41ebd3a559a66" translate="yes" xml:space="preserve">
          <source>The Rust language and compiler have a six-week release cycle, meaning users get a constant stream of new features. Other programming languages release larger changes less often; Rust releases smaller updates more frequently. After a while, all of these tiny changes add up. But from release to release, it can be difficult to look back and say, &amp;ldquo;Wow, between Rust 1.10 and Rust 1.31, Rust has changed a lot!&amp;rdquo;</source>
          <target state="translated">Rust言語とコンパイラには6週間のリリースサイクルがあります。つまり、ユーザーは常に新しい機能を利用できます。他のプログラミング言語では、大きな変更がリリースされる頻度が低くなっています。 Rustは小さな更新をより頻繁にリリースします。しばらくすると、これらの小さな変更がすべて追加されます。しかし、リリースごとに振り返って「Rust 1.10とRust 1.31の間で、Rustは大幅に変更されました！」と言うのは難しい場合があります。</target>
        </trans-unit>
        <trans-unit id="bb670b9e802863986c803bc2c279a2c3ad127d26" translate="yes" xml:space="preserve">
          <source>The Rust language has a set of &lt;em&gt;keywords&lt;/em&gt; that are reserved for use by the language only, much as in other languages. Keep in mind that you cannot use these words as names of variables or functions. Most of the keywords have special meanings, and you&amp;rsquo;ll be using them to do various tasks in your Rust programs; a few have no current functionality associated with them but have been reserved for functionality that might be added to Rust in the future. You can find a list of the keywords in &lt;a href=&quot;appendix-01-keywords&quot;&gt;Appendix A&lt;/a&gt;.</source>
          <target state="translated">Rust言語には、他の言語と同様に、その言語でのみ使用するために予約されている一連の&lt;em&gt;キーワード&lt;/em&gt;があります。これらの単語を変数または関数の名前として使用することはできないことに注意してください。ほとんどのキーワードには特別な意味があり、Rustプログラムでさまざまなタスクを実行するためにそれらを使用します。現在の機能が関連付けられていないものもありますが、将来Rustに追加される可能性のある機能のために予約されています。キーワードのリストは&lt;a href=&quot;appendix-01-keywords&quot;&gt;付録Aにあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="4db8a730c896d57ac8ae13218ced391891bc4c9e" translate="yes" xml:space="preserve">
          <source>The Rust language has a set of &lt;em&gt;keywords&lt;/em&gt; that are reserved for use by the language only, much as in other languages. Keep in mind that you cannot use these words as names of variables or functions. Most of the keywords have special meanings, and you&amp;rsquo;ll be using them to do various tasks in your Rust programs; a few have no current functionality associated with them but have been reserved for functionality that might be added to Rust in the future. You can find a list of the keywords in Appendix A.</source>
          <target state="translated">Rust言語には、他の言語と同様に、その言語でのみ使用するために予約されている&lt;em&gt;キーワードの&lt;/em&gt;セットがあります。これらの単語を変数または関数の名前として使用することはできません。ほとんどのキーワードには特別な意味があり、Rustプログラムでさまざまなタスクを実行するために使用します。現在の機能に関連付けられていないものもありますが、将来的にRustに追加される可能性のある機能のために予約されているものもあります。付録Aにキーワードのリストがあります。</target>
        </trans-unit>
        <trans-unit id="5c421a36adf32e1316c136776ce05dd83536c6c8" translate="yes" xml:space="preserve">
          <source>The Rust language hopes to support many other users as well; those mentioned here are merely some of the biggest stakeholders. Overall, Rust&amp;rsquo;s greatest ambition is to eliminate the trade-offs that programmers have accepted for decades by providing safety &lt;em&gt;and&lt;/em&gt; productivity, speed &lt;em&gt;and&lt;/em&gt; ergonomics. Give Rust a try and see if its choices work for you.</source>
          <target state="translated">Rust言語は、他の多くのユーザーもサポートしたいと考えています。ここで言及されているものは、最大の利害関係者の一部にすぎません。全体として、Rustの最大の目標は、安全性&lt;em&gt;と&lt;/em&gt;生産性、速度&lt;em&gt;、および&lt;/em&gt;人間工学を提供することにより、プログラマーが数十年にわたって受け入れてきたトレードオフを排除することです。 Rustを試して、その選択がうまくいくかどうかを確認してください。</target>
        </trans-unit>
        <trans-unit id="596e2b7dbc791cd3cfc77236ae00a927665967e2" translate="yes" xml:space="preserve">
          <source>The Rust runtime</source>
          <target state="translated">Rust ランタイム</target>
        </trans-unit>
        <trans-unit id="6be65bd73ad861e62f3888e1cc3672c017c1636b" translate="yes" xml:space="preserve">
          <source>The Rust standard library provides channels for message passing and smart pointer types, such as &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt;, that are safe to use in concurrent contexts. The type system and the borrow checker ensure that the code using these solutions won&amp;rsquo;t end up with data races or invalid references. Once you get your code to compile, you can rest assured that it will happily run on multiple threads without the kinds of hard-to-track-down bugs common in other languages. Concurrent programming is no longer a concept to be afraid of: go forth and make your programs concurrent, fearlessly!</source>
          <target state="translated">Rust標準ライブラリは、同時コンテキストで安全に使用できる、 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; や &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; などのメッセージ受け渡しとスマートポインタ型のチャネルを提供します。型システムと借用チェッカーは、これらのソリューションを使用するコードがデータ競合や無効な参照で終了しないことを保証します。コードをコンパイルしたら、他の言語で一般的な追跡が困難な種類のバグがなく、複数のスレッドで問題なく実行できることを確信できます。並行プログラミングはもはや恐れるべき概念ではありません：恐れずにプログラムを並行にしてください！</target>
        </trans-unit>
        <trans-unit id="ca0e948d58962dbdfe194b991ab15a2f509a074c" translate="yes" xml:space="preserve">
          <source>The Rust type system has some features that we&amp;rsquo;ve mentioned in this book but haven&amp;rsquo;t yet discussed. We&amp;rsquo;ll start by discussing newtypes in general as we examine why newtypes are useful as types. Then we&amp;rsquo;ll move on to type aliases, a feature similar to newtypes but with slightly different semantics. We&amp;rsquo;ll also discuss the &lt;code&gt;!&lt;/code&gt; type and dynamically sized types.</source>
          <target state="translated">Rust型システムには、この本で言及したがまだ説明していない機能がいくつかあります。newtypesが型として有用である理由を調べる際には、まずnewtypesについて説明します。次に、タイプエイリアスに移ります。これは、newtypeに似ていますが、セマンティクスが少し異なります。についても説明し &lt;code&gt;!&lt;/code&gt; タイプと動的サイズのタイプ。</target>
        </trans-unit>
        <trans-unit id="1e24d83679bf4a662ce93151d4c79beb7bc3d976" translate="yes" xml:space="preserve">
          <source>The Slice Type</source>
          <target state="translated">スライスタイプ</target>
        </trans-unit>
        <trans-unit id="b60a9b411326be4b7b78e74a3c2736078d2cb936" translate="yes" xml:space="preserve">
          <source>The Stack and the Heap</source>
          <target state="translated">スタックとヒープ</target>
        </trans-unit>
        <trans-unit id="ea9187c27f13ce2d0fda228c7804b1eacb2a7df4" translate="yes" xml:space="preserve">
          <source>The Static Lifetime</source>
          <target state="translated">静的寿命</target>
        </trans-unit>
        <trans-unit id="dcc1bdcf64d9ba08b8c546b48a03373f9d896f1a" translate="yes" xml:space="preserve">
          <source>The Tests Module and &lt;code id=&quot;the-tests-module-and-cfgtest&quot;&gt;#[cfg(test)]&lt;/code&gt;</source>
          <target state="translated">テストモジュールと &lt;code id=&quot;the-tests-module-and-cfgtest&quot;&gt;#[cfg(test)]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="43d375d205a43568d44e006351aba054a3a6df0e" translate="yes" xml:space="preserve">
          <source>The Trade-Offs of Using &lt;code id=&quot;the-trade-offs-of-using-clone&quot;&gt;clone&lt;/code&gt;</source>
          <target state="translated">&lt;code id=&quot;the-trade-offs-of-using-clone&quot;&gt;clone&lt;/code&gt; 使用のトレードオフ</target>
        </trans-unit>
        <trans-unit id="874f680f597dff734725c0edb8d1cdbdc1c687fb" translate="yes" xml:space="preserve">
          <source>The Transmission Control Protocol is specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc793&quot;&gt;IETF RFC 793&lt;/a&gt;.</source>
          <target state="translated">伝送制御プロトコルは、&lt;a href=&quot;https://tools.ietf.org/html/rfc793&quot;&gt;IETF RFC 793で&lt;/a&gt;指定されています。</target>
        </trans-unit>
        <trans-unit id="6d2bc0207cf3386e89a8ff90f2a45c74d008dd6b" translate="yes" xml:space="preserve">
          <source>The Tuple Type</source>
          <target state="translated">タプル型</target>
        </trans-unit>
        <trans-unit id="a1fe62622ad4944befb6b7cd3fbf5afe74512445" translate="yes" xml:space="preserve">
          <source>The UID part of the peer credential. This is the effective UID of the process at the domain socket's endpoint.</source>
          <target state="translated">ピアクレデンシャルの UID 部分。これは、ドメインソケットのエンドポイントでのプロセスの有効なUIDである。</target>
        </trans-unit>
        <trans-unit id="720acae72ae852d88680bc6199aaf2a3185402bd" translate="yes" xml:space="preserve">
          <source>The Unsize trait should not be implemented directly. All implementations of Unsize are provided automatically by the compiler.</source>
          <target state="translated">Unsizeの特徴は直接実装されるべきではありません。Unsizeのすべての実装はコンパイラによって自動的に提供されます。</target>
        </trans-unit>
        <trans-unit id="9d8c2343fd3b49fd50014f949ed7698cf46aba4f" translate="yes" xml:space="preserve">
          <source>The ability to return a type that is only specified by the trait it implements is especially useful in the context of closures and iterators, which we cover in Chapter 13. Closures and iterators create types that only the compiler knows or types that are very long to specify. The &lt;code&gt;impl Trait&lt;/code&gt; syntax lets you concisely specify that a function returns some type that implements the &lt;code&gt;Iterator&lt;/code&gt; trait without needing to write out a very long type.</source>
          <target state="translated">実装するトレイトによってのみ指定される型を返す機能は、第13章で説明するクロージャとイテレータのコンテキストで特に役立ちます。クロージャとイテレータは、コンパイラだけが知っている型または非常に長い型を作成します指定します。 &lt;code&gt;impl Trait&lt;/code&gt; 構文は簡潔機能は、いくつかのタイプを返すように指定することができますその実装 &lt;code&gt;Iterator&lt;/code&gt; 非常に長いタイプを書き出すために必要とせず、形質。</target>
        </trans-unit>
        <trans-unit id="8344955111fdc074c9729e11010ee2eab0af03c1" translate="yes" xml:space="preserve">
          <source>The above example can be resolved by either reducing the number of lifetime bounds to one or by making the trait object lifetime explicit, like so:</source>
          <target state="translated">上記の例は、ライフタイム境界の数を1つに減らすか、以下のように形質オブジェクトのライフタイムを明示的にすることで解決することができます。</target>
        </trans-unit>
        <trans-unit id="cde40ac9fea8ec2f55d9ca0d422fc89008496087" translate="yes" xml:space="preserve">
          <source>The above indirection is the additional runtime cost of calling a function on a &lt;code&gt;dyn Trait&lt;/code&gt;. Methods called by dynamic dispatch generally cannot be inlined by the compiler.</source>
          <target state="translated">上記の間接参照は、 &lt;code&gt;dyn Trait&lt;/code&gt; 関数を呼び出すための追加の実行時コストです。動的ディスパッチによって呼び出されるメソッドは、通常、コンパイラーによってインライン化できません。</target>
        </trans-unit>
        <trans-unit id="deb20b7d624d1708cb7603af7f7d5931910cd966" translate="yes" xml:space="preserve">
          <source>The above is &lt;em&gt;still&lt;/em&gt; an expression but it will always evaluate to &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">上記は&lt;em&gt;まだ&lt;/em&gt;式ですが、常に &lt;code&gt;()&lt;/code&gt; に評価されます。</target>
        </trans-unit>
        <trans-unit id="ede9c72b891dfc1d92b0b9fffc4f21007f9ae902" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i128::MIN&lt;/code&gt; cannot be represented as an &lt;code&gt;i128&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i128::MIN&lt;/code&gt; without a panic.</source>
          <target state="translated">絶対値 &lt;code&gt;i128::MIN&lt;/code&gt; として表すことができない &lt;code&gt;i128&lt;/code&gt; 、およびそれを計算しようとすると、オーバーフローが発生します。これは、デバッグモードのコードがこの場合にパニックを引き起こし、最適化されたコードがパニックなしで &lt;code&gt;i128::MIN&lt;/code&gt; を返すことを意味します。</target>
        </trans-unit>
        <trans-unit id="e4ff7b2880604f74445f905b71fdee96836fc628" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i128::min_value()&lt;/code&gt; cannot be represented as an &lt;code&gt;i128&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i128::min_value()&lt;/code&gt; without a panic.</source>
          <target state="translated">絶対値 &lt;code&gt;i128::min_value()&lt;/code&gt; のように表すことができない &lt;code&gt;i128&lt;/code&gt; 、及びそれを計算しようとすると、オーバーフローが発生します。つまり、デバッグモードのコードはこの場合パニックをトリガーし、最適化されたコードはパニックなしで &lt;code&gt;i128::min_value()&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="68e6f1c95dcf27a099d3d4e155f55896bf8faf93" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i16::MIN&lt;/code&gt; cannot be represented as an &lt;code&gt;i16&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i16::MIN&lt;/code&gt; without a panic.</source>
          <target state="translated">絶対値 &lt;code&gt;i16::MIN&lt;/code&gt; として表すことができない &lt;code&gt;i16&lt;/code&gt; 、およびそれを計算しようとすると、オーバーフローが発生します。これは、デバッグモードのコードがこの場合にパニックを引き起こし、最適化されたコードがパニックなしで &lt;code&gt;i16::MIN&lt;/code&gt; を返すことを意味します。</target>
        </trans-unit>
        <trans-unit id="c6634b50eb0aa3afe906f4e13b4800cc26454c92" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i16::min_value()&lt;/code&gt; cannot be represented as an &lt;code&gt;i16&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i16::min_value()&lt;/code&gt; without a panic.</source>
          <target state="translated">絶対値 &lt;code&gt;i16::min_value()&lt;/code&gt; のように表すことができない &lt;code&gt;i16&lt;/code&gt; 、及びそれを計算しようとすると、オーバーフローが発生します。つまり、デバッグモードのコードはこの場合パニックをトリガーし、最適化されたコードはパニックなしで &lt;code&gt;i16::min_value()&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="37e2f0833c2e3fce2e0d86c6e578d1435f9c3b8f" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i32::MIN&lt;/code&gt; cannot be represented as an &lt;code&gt;i32&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i32::MIN&lt;/code&gt; without a panic.</source>
          <target state="translated">絶対値 &lt;code&gt;i32::MIN&lt;/code&gt; として表すことができない &lt;code&gt;i32&lt;/code&gt; 、およびそれを計算しようとすると、オーバーフローが発生します。これは、デバッグモードのコードがこの場合にパニックを引き起こし、最適化されたコードがパニックなしで &lt;code&gt;i32::MIN&lt;/code&gt; を返すことを意味します。</target>
        </trans-unit>
        <trans-unit id="91a991a9b7dce7a35eefa5dff81ee4a280a7e4f1" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i32::min_value()&lt;/code&gt; cannot be represented as an &lt;code&gt;i32&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i32::min_value()&lt;/code&gt; without a panic.</source>
          <target state="translated">絶対値 &lt;code&gt;i32::min_value()&lt;/code&gt; のように表すことができない &lt;code&gt;i32&lt;/code&gt; 、及びそれを計算しようとすると、オーバーフローが発生します。つまり、デバッグモードのコードはこの場合パニックをトリガーし、最適化されたコードはパニックなしで &lt;code&gt;i32::min_value()&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="2ddae722d1b9330d37bd61655516374aae130695" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i64::MIN&lt;/code&gt; cannot be represented as an &lt;code&gt;i64&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i64::MIN&lt;/code&gt; without a panic.</source>
          <target state="translated">絶対値 &lt;code&gt;i64::MIN&lt;/code&gt; として表すことができない &lt;code&gt;i64&lt;/code&gt; 、およびそれを計算しようとすると、オーバーフローが発生します。これは、デバッグモードのコードがこの場合にパニックを引き起こし、最適化されたコードがパニックなしで &lt;code&gt;i64::MIN&lt;/code&gt; を返すことを意味します。</target>
        </trans-unit>
        <trans-unit id="4c50c4d71fa72eabc1e0818c0a858ae1903c1c3c" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i64::min_value()&lt;/code&gt; cannot be represented as an &lt;code&gt;i64&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i64::min_value()&lt;/code&gt; without a panic.</source>
          <target state="translated">絶対値 &lt;code&gt;i64::min_value()&lt;/code&gt; のように表すことができない &lt;code&gt;i64&lt;/code&gt; 、及びそれを計算しようとすると、オーバーフローが発生します。つまり、デバッグモードのコードはこの場合パニックをトリガーし、最適化されたコードはパニックなしで &lt;code&gt;i64::min_value()&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="94540f2ba32a8d4e2123f1b683b0ff15f6511fa8" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i8::MIN&lt;/code&gt; cannot be represented as an &lt;code&gt;i8&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i8::MIN&lt;/code&gt; without a panic.</source>
          <target state="translated">絶対値 &lt;code&gt;i8::MIN&lt;/code&gt; として表すことができない &lt;code&gt;i8&lt;/code&gt; 、それを計算しようとすると、オーバーフローが発生します。これは、デバッグモードのコードがこの場合にパニックを引き起こし、最適化されたコードがパニックなしで &lt;code&gt;i8::MIN&lt;/code&gt; を返すことを意味します。</target>
        </trans-unit>
        <trans-unit id="5adbbbaac9cedf98e39759b8920bdb3431d04107" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i8::min_value()&lt;/code&gt; cannot be represented as an &lt;code&gt;i8&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i8::min_value()&lt;/code&gt; without a panic.</source>
          <target state="translated">絶対値 &lt;code&gt;i8::min_value()&lt;/code&gt; のように表すことができない &lt;code&gt;i8&lt;/code&gt; 、及びそれを計算しようとすると、オーバーフローが発生します。つまり、デバッグモードのコードはこの場合パニックをトリガーし、最適化されたコードはパニックなしで &lt;code&gt;i8::min_value()&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="f3616827787c274826d0feb8bc695ca0f90e8398" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;isize::MIN&lt;/code&gt; cannot be represented as an &lt;code&gt;isize&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;isize::MIN&lt;/code&gt; without a panic.</source>
          <target state="translated">絶対値 &lt;code&gt;isize::MIN&lt;/code&gt; として表すことができない &lt;code&gt;isize&lt;/code&gt; 、それを計算しようとすると、オーバーフローが発生します。これは、デバッグモードのコードがこの場合にパニックを引き起こし、最適化されたコードがパニックなしで &lt;code&gt;isize::MIN&lt;/code&gt; を返すことを意味します。</target>
        </trans-unit>
        <trans-unit id="5fa62dd0a50bd4c5554cb57272ae5164c2e1f601" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;isize::min_value()&lt;/code&gt; cannot be represented as an &lt;code&gt;isize&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;isize::min_value()&lt;/code&gt; without a panic.</source>
          <target state="translated">絶対値 &lt;code&gt;isize::min_value()&lt;/code&gt; のように表すことができない &lt;code&gt;isize&lt;/code&gt; 、及びそれを計算しようとすると、オーバーフローが発生します。つまり、デバッグモードのコードはこの場合パニックをトリガーし、最適化されたコードはパニックなしで &lt;code&gt;isize::min_value()&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="409fd764bcabc3595ffe004849ff8f4e30564756" translate="yes" xml:space="preserve">
          <source>The actual desugaring is more complex:</source>
          <target state="translated">実際の脱穀はもっと複雑です。</target>
        </trans-unit>
        <trans-unit id="88133b615f1381b0a02c487a3edbc253bc8ee09f" translate="yes" xml:space="preserve">
          <source>The actual stack size may be greater than this value if the platform specifies a minimal stack size.</source>
          <target state="translated">プラットフォームが最小スタックサイズを指定している場合、実際のスタックサイズはこの値よりも大きくなる可能性があります。</target>
        </trans-unit>
        <trans-unit id="e09eb4195a6425d3d0a7b968cb406d8968af9926" translate="yes" xml:space="preserve">
          <source>The addition assignment operator &lt;code&gt;+=&lt;/code&gt;.</source>
          <target state="translated">加算代入演算子 &lt;code&gt;+=&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="097ca9dd7ade97007d85b522a25e6d04cefa5c67" translate="yes" xml:space="preserve">
          <source>The addition operator &lt;code&gt;+&lt;/code&gt;.</source>
          <target state="translated">加算演算子 &lt;code&gt;+&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="161b60a028315218a44d6ebb4a0a56ea64addb73" translate="yes" xml:space="preserve">
          <source>The address of temporary value was taken.</source>
          <target state="translated">一時値のアドレスが取られていました。</target>
        </trans-unit>
        <trans-unit id="67b3b3b11425c46c946b0ed067dfaec63ac739cb" translate="yes" xml:space="preserve">
          <source>The address type can be any implementor of &lt;a href=&quot;trait.tosocketaddrs&quot;&gt;&lt;code&gt;ToSocketAddrs&lt;/code&gt;&lt;/a&gt; trait. See its documentation for concrete examples.</source>
          <target state="translated">アドレスタイプは、&lt;a href=&quot;trait.tosocketaddrs&quot;&gt; &lt;code&gt;ToSocketAddrs&lt;/code&gt; &lt;/a&gt;トレイトの任意の実装者にすることができます。具体的な例については、そのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="554a0871d5bd274c4e9a4646e480108243a7e12e" translate="yes" xml:space="preserve">
          <source>The advantage of checking the borrowing rules at runtime instead is that certain memory-safe scenarios are then allowed, whereas they are disallowed by the compile-time checks. Static analysis, like the Rust compiler, is inherently conservative. Some properties of code are impossible to detect by analyzing the code: the most famous example is the Halting Problem, which is beyond the scope of this book but is an interesting topic to research.</source>
          <target state="translated">実行時に借用ルールをチェックすることの利点は、コンパイル時のチェックでは禁止されているのに対し、特定のメモリセーフなシナリオが許可されることです。スタティック解析は、Rust コンパイラのように、本質的に保守的です。コードの特性の中には、コードを解析しても検出できないものもあります。最も有名な例としては、ハルティング問題があります。</target>
        </trans-unit>
        <trans-unit id="cf97cfec24f32bdc09751ee8bbb19e7117656381" translate="yes" xml:space="preserve">
          <source>The advantage of using trait objects and Rust&amp;rsquo;s type system to write code similar to code using duck typing is that we never have to check whether a value implements a particular method at runtime or worry about getting errors if a value doesn&amp;rsquo;t implement a method but we call it anyway. Rust won&amp;rsquo;t compile our code if the values don&amp;rsquo;t implement the traits that the trait objects need.</source>
          <target state="translated">特性オブジェクトとRustの型システムを使用して、ダックタイピングを使用するコードと同様のコードを作成する利点は、値が実行時に特定のメソッドを実装するかどうかを確認したり、値がメソッドを実装していない場合にエラーが発生することを心配したりする必要がないことです。とにかくそれを呼び出します。特性オブジェクトが必要とする特性を値が実装していない場合、Rustはコードをコンパイルしません。</target>
        </trans-unit>
        <trans-unit id="1f36aabbacdf9ecb5c08c91a08fabb8510a201b8" translate="yes" xml:space="preserve">
          <source>The advantages of checking the borrowing rules at compile time are that errors will be caught sooner in the development process, and there is no impact on runtime performance because all the analysis is completed beforehand. For those reasons, checking the borrowing rules at compile time is the best choice in the majority of cases, which is why this is Rust&amp;rsquo;s default.</source>
          <target state="translated">コンパイル時に借用ルールを確認することの利点は、開発プロセスでエラーがより早く検出され、すべての分析が事前に完了しているため、実行時のパフォーマンスに影響を与えないことです。これらの理由により、大部分の場合、コンパイル時に借用ルールをチェックするのが最良の選択です。これがRustのデフォルトである理由です。</target>
        </trans-unit>
        <trans-unit id="802cd88adc867c6ed95af7c7632a5b9312da114b" translate="yes" xml:space="preserve">
          <source>The alignment is specified as an integer parameter in the form of &lt;code&gt;#[repr(align(x))]&lt;/code&gt; or &lt;code&gt;#[repr(packed(x))]&lt;/code&gt;. The alignment value must be a power of two from 1 up to 2&lt;sup&gt;29&lt;/sup&gt;. For &lt;code&gt;packed&lt;/code&gt;, if no value is given, as in &lt;code&gt;#[repr(packed)]&lt;/code&gt;, then the value is 1.</source>
          <target state="translated">位置合わせは、 &lt;code&gt;#[repr(align(x))]&lt;/code&gt; または &lt;code&gt;#[repr(packed(x))]&lt;/code&gt; の形式の整数パラメーターとして指定されます。アライメント値は、1から2 &lt;sup&gt;29&lt;/sup&gt;までの2のべき乗でなければなりません。以下のために &lt;code&gt;packed&lt;/code&gt; 、値が指定されていない場合、のよう &lt;code&gt;#[repr(packed)]&lt;/code&gt; 、値は1です。</target>
        </trans-unit>
        <trans-unit id="4210b5f1c3a4d7626a8282b8b0091e3127367f26" translate="yes" xml:space="preserve">
          <source>The alignment may be raised or lowered with the &lt;code&gt;align&lt;/code&gt; and &lt;code&gt;packed&lt;/code&gt; modifiers respectively. They alter the representation specified in the attribute. If no representation is specified, the default one is altered.</source>
          <target state="translated">配置は、 &lt;code&gt;align&lt;/code&gt; 修飾子と &lt;code&gt;packed&lt;/code&gt; 修飾子でそれぞれ上げたり下げたりできます。属性で指定された表現を変更します。表現が指定されていない場合、デフォルトの表現が変更されます。</target>
        </trans-unit>
        <trans-unit id="0bbd4814e74e1731ea096a3e29eb0e49a6112a9b" translate="yes" xml:space="preserve">
          <source>The alignment modifiers</source>
          <target state="translated">アライメント修飾子</target>
        </trans-unit>
        <trans-unit id="9a801ec59d9d78b1342286bf3c47cdf72d8754c9" translate="yes" xml:space="preserve">
          <source>The alignment of a value specifies what addresses values are preferred to start at. Always a power of two. References to a value must be aligned. &lt;a href=&quot;type-layout#size-and-alignment&quot;&gt;More&lt;/a&gt;.</source>
          <target state="translated">値の配置は、どのアドレス値から始めるのが好ましいかを指定します。常に2の累乗です。値への参照は整列させる必要があります。&lt;a href=&quot;type-layout#size-and-alignment&quot;&gt;もっと&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d7d8131883a9466d9495401638572f0f7002cb80" translate="yes" xml:space="preserve">
          <source>The alignment of the struct is the alignment of the most-aligned field in it.</source>
          <target state="translated">構造体のアラインメントは、その構造体の中で最もアラインメントの高いフィールドのアラインメントです。</target>
        </trans-unit>
        <trans-unit id="cb2d786ce814f96269971824a7ca8c85b85a4a91" translate="yes" xml:space="preserve">
          <source>The allocated block of memory may or may not be initialized.</source>
          <target state="translated">メモリの割り当てられたブロックは、初期化されていても、されていなくてもよい。</target>
        </trans-unit>
        <trans-unit id="a853460caf9660ad50bba38269de71834329efaf" translate="yes" xml:space="preserve">
          <source>The allocation error hook is a global resource.</source>
          <target state="translated">割り当てエラーフックはグローバルリソースです。</target>
        </trans-unit>
        <trans-unit id="dd622480c0a0d020ad0c83e155629929c531f8bd" translate="yes" xml:space="preserve">
          <source>The allocation error hook is invoked when an infallible memory allocation fails, before the runtime aborts. The default hook prints a message to standard error, but this behavior can be customized with the &lt;a href=&quot;fn.set_alloc_error_hook&quot;&gt;&lt;code&gt;set_alloc_error_hook&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fn.take_alloc_error_hook&quot;&gt;&lt;code&gt;take_alloc_error_hook&lt;/code&gt;&lt;/a&gt; functions.</source>
          <target state="translated">割り当てエラーフックは、ランタイムが中止される前に、確実なメモリ割り当てが失敗したときに呼び出されます。デフォルトのフックはメッセージを標準エラーに出力しますが、この動作は&lt;a href=&quot;fn.set_alloc_error_hook&quot;&gt; &lt;code&gt;set_alloc_error_hook&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;fn.take_alloc_error_hook&quot;&gt; &lt;code&gt;take_alloc_error_hook&lt;/code&gt; &lt;/a&gt;関数でカスタマイズできます。</target>
        </trans-unit>
        <trans-unit id="460b0be997a504bd93f9a5f2102be17a4fe4f237" translate="yes" xml:space="preserve">
          <source>The alternate flag, &lt;code&gt;#&lt;/code&gt;, adds a &lt;code&gt;0b&lt;/code&gt; in front of the output.</source>
          <target state="translated">代替フラグ &lt;code&gt;#&lt;/code&gt; は、出力の前に &lt;code&gt;0b&lt;/code&gt; を追加します。</target>
        </trans-unit>
        <trans-unit id="b053ed1e6052a16bbf0f4a89d40e16ee9bf6a88d" translate="yes" xml:space="preserve">
          <source>The alternate flag, &lt;code&gt;#&lt;/code&gt;, adds a &lt;code&gt;0o&lt;/code&gt; in front of the output.</source>
          <target state="translated">代替フラグ &lt;code&gt;#&lt;/code&gt; は、出力の前に &lt;code&gt;0o&lt;/code&gt; を追加します。</target>
        </trans-unit>
        <trans-unit id="1a67677d2b4895bdc1fb6847161bf39c61cb99f4" translate="yes" xml:space="preserve">
          <source>The alternate flag, &lt;code&gt;#&lt;/code&gt;, adds a &lt;code&gt;0x&lt;/code&gt; in front of the output.</source>
          <target state="translated">代替フラグ &lt;code&gt;#&lt;/code&gt; は、出力の前に &lt;code&gt;0x&lt;/code&gt; を追加します。</target>
        </trans-unit>
        <trans-unit id="11ba8acfe40883baf3a25418d4023d5eeae6eb43" translate="yes" xml:space="preserve">
          <source>The answer to this problem is the &lt;em&gt;Cargo.lock&lt;/em&gt; file, which was created the first time you ran &lt;code&gt;cargo build&lt;/code&gt; and is now in your &lt;em&gt;guessing_game&lt;/em&gt; directory. When you build a project for the first time, Cargo figures out all the versions of the dependencies that fit the criteria and then writes them to the &lt;em&gt;Cargo.lock&lt;/em&gt; file. When you build your project in the future, Cargo will see that the &lt;em&gt;Cargo.lock&lt;/em&gt; file exists and use the versions specified there rather than doing all the work of figuring out versions again. This lets you have a reproducible build automatically. In other words, your project will remain at &lt;code&gt;0.3.14&lt;/code&gt; until you explicitly upgrade, thanks to the &lt;em&gt;Cargo.lock&lt;/em&gt; file.</source>
          <target state="translated">この問題に対する答えは、&lt;em&gt;Cargo.lock&lt;/em&gt;ファイルです。これは、初めて &lt;code&gt;cargo build&lt;/code&gt; を実行したときに作成され、現在は&lt;em&gt;guessing_game&lt;/em&gt;ディレクトリにあります。プロジェクトを初めてビルドするとき、Cargoは基準に適合する依存関係のすべてのバージョンを&lt;em&gt;計算&lt;/em&gt;し、それらを&lt;em&gt;Cargo.lock&lt;/em&gt;ファイルに書き込みます。将来プロジェクトをビルドするとき、Cargoは&lt;em&gt;Cargo.lock&lt;/em&gt;ファイルが存在することを確認し、バージョンを特定する作業をすべて行うのではなく、そこで指定されたバージョンを使用します。これにより、再現可能なビルドを自動的に作成できます。つまり、&lt;em&gt;Cargo.lockの&lt;/em&gt;おかげで、明示的にアップグレードするまで、プロジェクトは &lt;code&gt;0.3.14&lt;/code&gt; のままになります。&lt;em&gt;&lt;/em&gt; ファイル。</target>
        </trans-unit>
        <trans-unit id="8fb95ccc8cbb2b44a80d4d0a731ecb5bea70e713" translate="yes" xml:space="preserve">
          <source>The answer to this problem is the &lt;em&gt;Cargo.lock&lt;/em&gt; file, which was created the first time you ran &lt;code&gt;cargo build&lt;/code&gt; and is now in your &lt;em&gt;guessing_game&lt;/em&gt; directory. When you build a project for the first time, Cargo figures out all the versions of the dependencies that fit the criteria and then writes them to the &lt;em&gt;Cargo.lock&lt;/em&gt; file. When you build your project in the future, Cargo will see that the &lt;em&gt;Cargo.lock&lt;/em&gt; file exists and use the versions specified there rather than doing all the work of figuring out versions again. This lets you have a reproducible build automatically. In other words, your project will remain at &lt;code&gt;0.5.5&lt;/code&gt; until you explicitly upgrade, thanks to the &lt;em&gt;Cargo.lock&lt;/em&gt; file.</source>
          <target state="translated">この問題への答えは&lt;em&gt;Cargo.lockの&lt;/em&gt;あなたが走った初めて作成されたファイル、 &lt;code&gt;cargo build&lt;/code&gt; し、あなたに今ある&lt;em&gt;guessing_gameの&lt;/em&gt;ディレクトリ。初めてプロジェクトをビルドするとき、Cargoは基準に一致する依存関係のすべてのバージョンを&lt;em&gt;把握&lt;/em&gt;し、それらを&lt;em&gt;Cargo.lock&lt;/em&gt;ファイルに書き込みます。将来プロジェクトをビルドするとき、Cargoは&lt;em&gt;Cargo.lock&lt;/em&gt;ファイルが存在することを確認し、バージョンを再把握するすべての作業を行うのではなく、そこで指定されたバージョンを使用します。これにより、再現可能なビルドを自動的に作成できます。言い換えれば、あなたのプロジェクトがのままになります &lt;code&gt;0.5.5&lt;/code&gt; 、明示的にアップグレードするまでのおかげ&lt;em&gt;Cargo.lockを&lt;/em&gt; ファイル。</target>
        </trans-unit>
        <trans-unit id="c50839f5b75ebf2449202c65bd78e83e2a04633c" translate="yes" xml:space="preserve">
          <source>The argument order should be changed to match the parameter declaration order, as in the following:</source>
          <target state="translated">引数の順番は、以下のようにパラメータの宣言順に合わせて変更する必要があります。</target>
        </trans-unit>
        <trans-unit id="ff3b9111423732cd0796ed3af4340d1aeaddff87" translate="yes" xml:space="preserve">
          <source>The argument to the &lt;code&gt;llvm_asm&lt;/code&gt; macro is not well-formed.</source>
          <target state="translated">&lt;code&gt;llvm_asm&lt;/code&gt; マクロへの引数は整形式ではありません。</target>
        </trans-unit>
        <trans-unit id="0d5e37bb48121061d7a9d1253e50cf299206b8ed" translate="yes" xml:space="preserve">
          <source>The argument, &lt;code&gt;mid&lt;/code&gt;, should be a byte offset from the start of the string. It must also be on the boundary of a UTF-8 code point.</source>
          <target state="translated">引数 &lt;code&gt;mid&lt;/code&gt; は、文字列の先頭からのバイトオフセットでなければなりません。また、UTF-8コードポイントの境界上にある必要があります。</target>
        </trans-unit>
        <trans-unit id="843c167795952476fd4949d773d09e67f37bae5c" translate="yes" xml:space="preserve">
          <source>The arguments will be formatted according to the specified format string into the output stream provided.</source>
          <target state="translated">引数は、指定されたフォーマット文字列に従って、指定された出力ストリームにフォーマットされます。</target>
        </trans-unit>
        <trans-unit id="47d8ae2e6d2ad4b4b9256e9f4136431f5f0ee17f" translate="yes" xml:space="preserve">
          <source>The array index expression can be implemented for types other than arrays and slices by implementing the &lt;a href=&quot;../../std/ops/trait.index&quot;&gt;Index&lt;/a&gt; and &lt;a href=&quot;../../std/ops/trait.indexmut&quot;&gt;IndexMut&lt;/a&gt; traits.</source>
          <target state="translated">配列のインデックス式は、&lt;a href=&quot;../../std/ops/trait.index&quot;&gt;Index&lt;/a&gt;と&lt;a href=&quot;../../std/ops/trait.indexmut&quot;&gt;IndexMut&lt;/a&gt;トレイトを実装することで、配列とスライス以外のタイプに実装できます。</target>
        </trans-unit>
        <trans-unit id="43b42b264d53f00eb4d50d966bdebfe503d9e502" translate="yes" xml:space="preserve">
          <source>The array named &lt;code&gt;a&lt;/code&gt; will contain &lt;code&gt;5&lt;/code&gt; elements that will all be set to the value &lt;code&gt;3&lt;/code&gt; initially. This is the same as writing &lt;code&gt;let a = [3, 3, 3, 3, 3];&lt;/code&gt; but in a more concise way.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; という名前の配列には、最初はすべて値 &lt;code&gt;3&lt;/code&gt; に設定される &lt;code&gt;5&lt;/code&gt; つの要素が含まれます。これは &lt;code&gt;let a = [3, 3, 3, 3, 3];&lt;/code&gt; と同じです。しかし、より簡潔な方法で。</target>
        </trans-unit>
        <trans-unit id="bda6f38466d2f9f90243514e2e1d1d622e872f82" translate="yes" xml:space="preserve">
          <source>The associated error which can be returned from parsing.</source>
          <target state="translated">解析から返される関連するエラー。</target>
        </trans-unit>
        <trans-unit id="264397f1a1d81bc0bfb862d1058ae5d080545332" translate="yes" xml:space="preserve">
          <source>The associated type used was not defined in the trait.</source>
          <target state="translated">使用されている関連する型が形質で定義されていませんでした。</target>
        </trans-unit>
        <trans-unit id="95b071fe52a22a379b9072dba9b8116f1e91d5e0" translate="yes" xml:space="preserve">
          <source>The assumed lifetime of references held by a &lt;a href=&quot;types/trait-object&quot;&gt;trait object&lt;/a&gt; is called its &lt;em&gt;default object lifetime bound&lt;/em&gt;. These were defined in &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0599-default-object-bound.md&quot;&gt;RFC 599&lt;/a&gt; and amended in &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md&quot;&gt;RFC 1156&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;types/trait-object&quot;&gt;特性オブジェクト&lt;/a&gt;によって保持される参照の想定される存続期間は、その&lt;em&gt;デフォルトのオブジェクト存続期間限界&lt;/em&gt;と呼ばれ&lt;em&gt;ます&lt;/em&gt;。これらは&lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0599-default-object-bound.md&quot;&gt;RFC 599で&lt;/a&gt;定義され、&lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md&quot;&gt;RFC 1156で&lt;/a&gt;修正されました。</target>
        </trans-unit>
        <trans-unit id="4a633a670846190d4e317682018f539e771650d4" translate="yes" xml:space="preserve">
          <source>The atomic intrinsics provide common atomic operations on machine words, with multiple possible memory orderings. They obey the same semantics as C++11. See the LLVM documentation on [&lt;a href=&quot;http://llvm.org/docs/Atomics.html&quot;&gt;atomics&lt;/a&gt;].</source>
          <target state="translated">アトミック組み込み関数は、複数の可能なメモリ順序で、マシンワードに対する一般的なアトミック操作を提供します。C ++ 11と同じセマンティクスに従います。[ &lt;a href=&quot;http://llvm.org/docs/Atomics.html&quot;&gt;atomics&lt;/a&gt; ] に関するLLVMのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="4eacfc8c255cb1ef132a6a65b58c2019ebea9baf" translate="yes" xml:space="preserve">
          <source>The atomic types in this module may not be available on all platforms. The atomic types here are all widely available, however, and can generally be relied upon existing. Some notable exceptions are:</source>
          <target state="translated">このモジュールの原子型は、すべてのプラットフォームで利用できるわけではありません。しかし、ここで紹介する原子型はすべて広く利用可能であり、一般的には既存のものに頼ることができます。いくつかの顕著な例外があります。</target>
        </trans-unit>
        <trans-unit id="71cc0f45759d249e1ba21744ede7b9ef7445260e" translate="yes" xml:space="preserve">
          <source>The attribute consists of a path to the attribute, followed by an optional delimited token tree whose interpretation is defined by the attribute. Attributes other than macro attributes also allow the input to be an equals sign (&lt;code&gt;=&lt;/code&gt;) followed by a literal expression. See the &lt;a href=&quot;#meta-item-attribute-syntax&quot;&gt;meta item syntax&lt;/a&gt; below for more details.</source>
          <target state="translated">属性は、属性へのパスと、それに続く、属性によって解釈が定義されるオプションの区切られたトークンツリーで構成されます。マクロ属性以外の属性でも、入力を等号（ &lt;code&gt;=&lt;/code&gt; ）の後にリテラル式にすることができます。詳細については、以下の&lt;a href=&quot;#meta-item-attribute-syntax&quot;&gt;メタアイテム構文を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="c5f89ad9ce66636388cf7509f930392e52eeb867" translate="yes" xml:space="preserve">
          <source>The attribute consists of a path to the attribute, followed by an optional delimited token tree whose interpretation is defined by the attribute. Attributes other than macro attributes also allow the input to be an equals sign (&lt;code&gt;=&lt;/code&gt;) followed by a literal expression. See the &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;meta item syntax&lt;/a&gt; below for more details.</source>
          <target state="translated">属性は、属性へのパスと、その後に続く属性で定義されたオプションの区切りトークンツリーで構成されます。マクロ属性以外の属性でも、入力は等号（ &lt;code&gt;=&lt;/code&gt; ）の後にリテラル式を続けることができます。詳細については、以下の&lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;メタアイテムの構文を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="b79be106b3314bbccaaacf6171952db704c5419b" translate="yes" xml:space="preserve">
          <source>The attribute is used on a &lt;code&gt;static&lt;/code&gt; item whose type implements the &lt;a href=&quot;https://doc.rust-lang.org/core/alloc/trait.GlobalAlloc.html&quot;&gt;&lt;code&gt;GlobalAlloc&lt;/code&gt;&lt;/a&gt; trait. This type can be provided by an external library:</source>
          <target state="translated">この属性は、タイプが&lt;a href=&quot;https://doc.rust-lang.org/core/alloc/trait.GlobalAlloc.html&quot;&gt; &lt;code&gt;GlobalAlloc&lt;/code&gt; &lt;/a&gt;特性を実装する &lt;code&gt;static&lt;/code&gt; アイテムで使用されます。このタイプは、外部ライブラリによって提供できます。</target>
        </trans-unit>
        <trans-unit id="638938ad1b96ca367b1ad29ad316e67748e69b45" translate="yes" xml:space="preserve">
          <source>The attribute is used on a &lt;code&gt;static&lt;/code&gt; item whose type implements the &lt;a href=&quot;trait.globalalloc&quot;&gt;&lt;code&gt;GlobalAlloc&lt;/code&gt;&lt;/a&gt; trait. This type can be provided by an external library:</source>
          <target state="translated">この属性は、タイプが&lt;a href=&quot;trait.globalalloc&quot;&gt; &lt;code&gt;GlobalAlloc&lt;/code&gt; &lt;/a&gt;トレイトを実装する &lt;code&gt;static&lt;/code&gt; アイテムで使用されます。このタイプは、外部ライブラリによって提供できます。</target>
        </trans-unit>
        <trans-unit id="07001b94d9ec08710a57474a9ab6a5a7c57ed031" translate="yes" xml:space="preserve">
          <source>The attributes that have meaning on a block expression are &lt;a href=&quot;../conditional-compilation&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;the lint check attributes&lt;/a&gt;.</source>
          <target state="translated">ブロック式で意味を持つ属性は、&lt;a href=&quot;../conditional-compilation&quot;&gt; &lt;code&gt;cfg&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;lintチェック属性です&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="db84623389bc5fe968094b478ac6446a9f7cd32b" translate="yes" xml:space="preserve">
          <source>The attributes that have meaning on a function are &lt;a href=&quot;../conditional-compilation&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt;&lt;code&gt;deprecated&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt;&lt;code&gt;doc&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../abi#the-export_name-attribute&quot;&gt;&lt;code&gt;export_name&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../abi#the-link_section-attribute&quot;&gt;&lt;code&gt;link_section&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../abi#the-no_mangle-attribute&quot;&gt;&lt;code&gt;no_mangle&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;the lint check attributes&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#the-must_use-attribute&quot;&gt;&lt;code&gt;must_use&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../procedural-macros&quot;&gt;the procedural macro attributes&lt;/a&gt;, &lt;a href=&quot;../attributes/testing&quot;&gt;the testing attributes&lt;/a&gt;, and &lt;a href=&quot;../attributes/codegen#optimization-hints&quot;&gt;the optimization hint attributes&lt;/a&gt;. Functions also accept attributes macros.</source>
          <target state="translated">関数で意味を持つ属性は、&lt;a href=&quot;../conditional-compilation&quot;&gt; &lt;code&gt;cfg&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt; &lt;code&gt;deprecated&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt; &lt;code&gt;doc&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../abi#the-export_name-attribute&quot;&gt; &lt;code&gt;export_name&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../abi#the-link_section-attribute&quot;&gt; &lt;code&gt;link_section&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../abi#the-no_mangle-attribute&quot;&gt; &lt;code&gt;no_mangle&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;lintチェック属性&lt;/a&gt;、&lt;a href=&quot;../attributes/diagnostics#the-must_use-attribute&quot;&gt; &lt;code&gt;must_use&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../procedural-macros&quot;&gt;手続き型マクロ属性&lt;/a&gt;、&lt;a href=&quot;../attributes/testing&quot;&gt;テスト属性&lt;/a&gt;、および&lt;a href=&quot;../attributes/codegen#optimization-hints&quot;&gt;最適化ヒント属性です&lt;/a&gt;。関数は属性マクロも受け入れます。</target>
        </trans-unit>
        <trans-unit id="622c3bad6ebce7dda9ab10b347056427bd42a746" translate="yes" xml:space="preserve">
          <source>The attributes that have meaning on a function are &lt;a href=&quot;../conditional-compilation#the-cfg-attribute&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../conditional-compilation#the-cfg_attr-attribute&quot;&gt;&lt;code&gt;cfg_attr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt;&lt;code&gt;deprecated&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt;&lt;code&gt;doc&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../abi#the-export_name-attribute&quot;&gt;&lt;code&gt;export_name&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../abi#the-link_section-attribute&quot;&gt;&lt;code&gt;link_section&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../abi#the-no_mangle-attribute&quot;&gt;&lt;code&gt;no_mangle&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;the lint check attributes&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#the-must_use-attribute&quot;&gt;&lt;code&gt;must_use&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../procedural-macros&quot;&gt;the procedural macro attributes&lt;/a&gt;, &lt;a href=&quot;../attributes/testing&quot;&gt;the testing attributes&lt;/a&gt;, and &lt;a href=&quot;../attributes/codegen#optimization-hints&quot;&gt;the optimization hint attributes&lt;/a&gt;. Functions also accept attributes macros.</source>
          <target state="translated">関数で意味を持つ属性は、&lt;a href=&quot;../conditional-compilation#the-cfg-attribute&quot;&gt; &lt;code&gt;cfg&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../conditional-compilation#the-cfg_attr-attribute&quot;&gt; &lt;code&gt;cfg_attr&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt; &lt;code&gt;deprecated&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt; &lt;code&gt;doc&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../abi#the-export_name-attribute&quot;&gt; &lt;code&gt;export_name&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../abi#the-link_section-attribute&quot;&gt; &lt;code&gt;link_section&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../abi#the-no_mangle-attribute&quot;&gt; &lt;code&gt;no_mangle&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;lint check属性&lt;/a&gt;、&lt;a href=&quot;../attributes/diagnostics#the-must_use-attribute&quot;&gt; &lt;code&gt;must_use&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../procedural-macros&quot;&gt;手続き型マクロ属性&lt;/a&gt;、&lt;a href=&quot;../attributes/testing&quot;&gt;テスト属性&lt;/a&gt;、および&lt;a href=&quot;../attributes/codegen#optimization-hints&quot;&gt;最適化ヒント属性です&lt;/a&gt;。関数は属性マクロも受け入れます。</target>
        </trans-unit>
        <trans-unit id="a9286c2061446f78d1eb0dacb8ad2bed2198b3a3" translate="yes" xml:space="preserve">
          <source>The author of the code in Listing 14-4, which uses the &lt;code&gt;art&lt;/code&gt; crate, had to figure out that &lt;code&gt;PrimaryColor&lt;/code&gt; is in the &lt;code&gt;kinds&lt;/code&gt; module and &lt;code&gt;mix&lt;/code&gt; is in the &lt;code&gt;utils&lt;/code&gt; module. The module structure of the &lt;code&gt;art&lt;/code&gt; crate is more relevant to developers working on the &lt;code&gt;art&lt;/code&gt; crate than to developers using the &lt;code&gt;art&lt;/code&gt; crate. The internal structure that organizes parts of the crate into the &lt;code&gt;kinds&lt;/code&gt; module and the &lt;code&gt;utils&lt;/code&gt; module doesn&amp;rsquo;t contain any useful information for someone trying to understand how to use the &lt;code&gt;art&lt;/code&gt; crate. Instead, the &lt;code&gt;art&lt;/code&gt; crate&amp;rsquo;s module structure causes confusion because developers have to figure out where to look, and the structure is inconvenient because developers must specify the module names in the &lt;code&gt;use&lt;/code&gt; statements.</source>
          <target state="translated">使用して、リスト14-4のコードの作者 &lt;code&gt;art&lt;/code&gt; クレートは、ということを理解しなければならなかった &lt;code&gt;PrimaryColor&lt;/code&gt; である &lt;code&gt;kinds&lt;/code&gt; モジュールと &lt;code&gt;mix&lt;/code&gt; している &lt;code&gt;utils&lt;/code&gt; モジュール。モジュール構造 &lt;code&gt;art&lt;/code&gt; クレートは、に取り組んで開発者により関連性のある &lt;code&gt;art&lt;/code&gt; よりも使用して開発者にクレート &lt;code&gt;art&lt;/code&gt; クレートを。クレートの部分を整理した内部構造 &lt;code&gt;kinds&lt;/code&gt; モジュールと &lt;code&gt;utils&lt;/code&gt; モジュールを使用する方法を理解しようとしている誰かのために有用な情報が含まれていない &lt;code&gt;art&lt;/code&gt; クレートを。代わりに、 &lt;code&gt;art&lt;/code&gt; クレートのモジュール構造は、開発者がどこを見なければならないかを理解する必要があるため混乱を引き起こし、開発者は &lt;code&gt;use&lt;/code&gt; ステートメントでモジュール名を指定する必要があるため、構造が不便です。</target>
        </trans-unit>
        <trans-unit id="d8ebf8e3de6c2376fc1a32c2614c0e8023f7f60e" translate="yes" xml:space="preserve">
          <source>The author of this code probably wants &lt;code&gt;collect()&lt;/code&gt; to return a &lt;code&gt;Result&amp;lt;Vec&amp;lt;bool&amp;gt;, ()&amp;gt;&lt;/code&gt;, but the compiler can't be sure that there isn't another type &lt;code&gt;T&lt;/code&gt; implementing both &lt;code&gt;Try&lt;/code&gt; and &lt;code&gt;FromIterator&amp;lt;Result&amp;lt;bool, ()&amp;gt;&amp;gt;&lt;/code&gt; in scope such that &lt;code&gt;T::Ok == Vec&amp;lt;bool&amp;gt;&lt;/code&gt;. Hence, this code is ambiguous and an error is returned.</source>
          <target state="translated">このコードの作成者は、おそらく &lt;code&gt;collect()&lt;/code&gt; が &lt;code&gt;Result&amp;lt;Vec&amp;lt;bool&amp;gt;, ()&amp;gt;&lt;/code&gt; を返すことを望んでいますが、コンパイラは、 &lt;code&gt;Try&lt;/code&gt; と &lt;code&gt;FromIterator&amp;lt;Result&amp;lt;bool, ()&amp;gt;&amp;gt;&lt;/code&gt; 両方を実装する別の型 &lt;code&gt;T&lt;/code&gt; がないことを確認できません。 （）&amp;gt;&amp;gt;スコープ内の &lt;code&gt;T::Ok == Vec&amp;lt;bool&amp;gt;&lt;/code&gt; 。したがって、このコードがあいまいであり、エラーが返されます。</target>
        </trans-unit>
        <trans-unit id="938569367b830c27a570a475e7cb23644f96b802" translate="yes" xml:space="preserve">
          <source>The author of this code probably wants &lt;code&gt;into()&lt;/code&gt; to return a &lt;code&gt;u64&lt;/code&gt;, but the compiler can't be sure that there isn't another type &lt;code&gt;T&lt;/code&gt; where both &lt;code&gt;u32: Into&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;u64: Add&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">このコードの作成者は、おそらく &lt;code&gt;into()&lt;/code&gt; が &lt;code&gt;u64&lt;/code&gt; を返すことを望んでいますが、コンパイラーは、 &lt;code&gt;u32: Into&amp;lt;T&amp;gt;&lt;/code&gt; と &lt;code&gt;u64: Add&amp;lt;T&amp;gt;&lt;/code&gt; 両方である別のタイプ &lt;code&gt;T&lt;/code&gt; がないことを確認できません。</target>
        </trans-unit>
        <trans-unit id="946c3c8468dffe1ee08b57091aa458b31b356f72" translate="yes" xml:space="preserve">
          <source>The automatically generated &quot;drop glue&quot; which recursively calls the destructors of the all fields of this value.</source>
          <target state="translated">この値の全フィールドのデストラクタを再帰的に呼び出す、自動的に生成された &quot;drop glue&quot;。</target>
        </trans-unit>
        <trans-unit id="442e142fa9a496c6c2ff3a02ee78aa50e228d6e4" translate="yes" xml:space="preserve">
          <source>The bad state is not something that&amp;rsquo;s &lt;em&gt;expected&lt;/em&gt; to happen occasionally.</source>
          <target state="translated">悪い状態は、たまに起こると&lt;em&gt;予想される&lt;/em&gt;ものではありません。</target>
        </trans-unit>
        <trans-unit id="1030d03bed1910f08091eb456180338b656dc0aa" translate="yes" xml:space="preserve">
          <source>The base of a &lt;a href=&quot;expressions/struct-expr#functional-update-syntax&quot;&gt;functional update&lt;/a&gt; struct expression.</source>
          <target state="translated">&lt;a href=&quot;expressions/struct-expr#functional-update-syntax&quot;&gt;機能更新&lt;/a&gt;構造体式のベース。</target>
        </trans-unit>
        <trans-unit id="1da424ed8fd790e722f71cc50f820022f89f696b" translate="yes" xml:space="preserve">
          <source>The behavior of the returned &lt;code&gt;Waker&lt;/code&gt; is undefined if the contract defined in &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt;'s and &lt;a href=&quot;struct.rawwakervtable&quot;&gt;&lt;code&gt;RawWakerVTable&lt;/code&gt;&lt;/a&gt;'s documentation is not upheld. Therefore this method is unsafe.</source>
          <target state="translated">&lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;struct.rawwakervtable&quot;&gt; &lt;code&gt;RawWakerVTable&lt;/code&gt; &lt;/a&gt;のドキュメントで定義されているコントラクトが守られていない場合、返される &lt;code&gt;Waker&lt;/code&gt; の動作は未定義です。したがって、この方法は安全ではありません。</target>
        </trans-unit>
        <trans-unit id="c7f5bfcda53c0f0ccac4fbf04091f03de55bc719" translate="yes" xml:space="preserve">
          <source>The behavior of this method must be independent of the state of the &lt;code&gt;Read&lt;/code&gt;er - the method only takes &lt;code&gt;&amp;amp;self&lt;/code&gt; so that it can be used through trait objects.</source>
          <target state="translated">このメソッドの動作は、 &lt;code&gt;Read&lt;/code&gt; erの状態とは無関係である必要があります。このメソッドは、特性オブジェクトを通じて使用できるように &lt;code&gt;&amp;amp;self&lt;/code&gt; のみを受け取ります。</target>
        </trans-unit>
        <trans-unit id="92a385c5078364ae9300fa907e25a19462c00810" translate="yes" xml:space="preserve">
          <source>The benefit of having this restriction is that Rust can prevent data races at compile time. A &lt;em&gt;data race&lt;/em&gt; is similar to a race condition and happens when these three behaviors occur:</source>
          <target state="translated">この制限があることの利点は、Rustがコンパイル時にデータ競合を防止できることです。&lt;em&gt;データレースは&lt;/em&gt;、レースの条件に似ており、これら三つの行動が発生したときに起こります。</target>
        </trans-unit>
        <trans-unit id="94345eda8bccf9faca124acc23e9dfc7f68245ec" translate="yes" xml:space="preserve">
          <source>The bits that define the access mode are masked out with &lt;code&gt;O_ACCMODE&lt;/code&gt;, to ensure they do not interfere with the access mode set by Rusts options.</source>
          <target state="translated">アクセスモードを定義するビットは &lt;code&gt;O_ACCMODE&lt;/code&gt; でマスクされ、Rustsオプションで設定されたアクセスモードと干渉しないようにします。</target>
        </trans-unit>
        <trans-unit id="eaa8e0a3053148a58d441c5d948ef0afd09016e9" translate="yes" xml:space="preserve">
          <source>The bitwise AND assignment operator &lt;code&gt;&amp;amp;=&lt;/code&gt;.</source>
          <target state="translated">ビットごとのAND代入演算子 &lt;code&gt;&amp;amp;=&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1dd8ef8a8d73fdf98095248d6c0b2047cb203cf0" translate="yes" xml:space="preserve">
          <source>The bitwise AND operator &lt;code&gt;&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">ビットごとのAND演算子 &lt;code&gt;&amp;amp;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2bfdab4f43dd337afc8fc0552897bf0d88f4fb0e" translate="yes" xml:space="preserve">
          <source>The bitwise OR assignment operator &lt;code&gt;|=&lt;/code&gt;.</source>
          <target state="translated">ビットごとのOR代入演算子 &lt;code&gt;|=&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a78ed80e19856e33ead5257328ef19e1b110eb08" translate="yes" xml:space="preserve">
          <source>The bitwise OR operator &lt;code&gt;|&lt;/code&gt;.</source>
          <target state="translated">ビットごとのOR演算子 &lt;code&gt;|&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eafeed4a6ad02f43abd1d07f62b4dea554b3a79c" translate="yes" xml:space="preserve">
          <source>The bitwise XOR assignment operator &lt;code&gt;^=&lt;/code&gt;.</source>
          <target state="translated">ビットごとのXOR代入演算子 &lt;code&gt;^=&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e805a1bbc089611af418b7bd9e638939dac553c5" translate="yes" xml:space="preserve">
          <source>The bitwise XOR operator &lt;code&gt;^&lt;/code&gt;.</source>
          <target state="translated">ビットごとのXOR演算子 &lt;code&gt;^&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c9231fb12ba981aafd28f24ac7946a833b22a70e" translate="yes" xml:space="preserve">
          <source>The block must be allocated with the same alignment as &lt;a href=&quot;struct.layout#method.align&quot;&gt;&lt;code&gt;layout.align()&lt;/code&gt;&lt;/a&gt;, and</source>
          <target state="translated">ブロックは、同じ配向で割り当てなければならない&lt;a href=&quot;struct.layout#method.align&quot;&gt; &lt;code&gt;layout.align()&lt;/code&gt; &lt;/a&gt;、及び</target>
        </trans-unit>
        <trans-unit id="423b8775203e06b0ca354c4f4e97825a7d00a713" translate="yes" xml:space="preserve">
          <source>The block of a function is conceptually wrapped in a block that binds the argument patterns and then &lt;code&gt;return&lt;/code&gt;s the value of the function's block. This means that the tail expression of the block, if evaluated, ends up being returned to the caller. As usual, an explicit return expression within the body of the function will short-cut that implicit return, if reached.</source>
          <target state="translated">関数のブロックは、概念的には引数パターンをバインドし、関数のブロックの値を &lt;code&gt;return&lt;/code&gt; ブロックにラップされています。つまり、ブロックの末尾の式は、評価された場合、最終的に呼び出し元に返されます。いつものように、関数の本体内の明示的なreturn式は、到達した場合、その暗黙の戻りをショートカットします。</target>
        </trans-unit>
        <trans-unit id="761ca0a326eb25085e5f1ebfbcef3b94f323b7c7" translate="yes" xml:space="preserve">
          <source>The block's size must fall in the range &lt;code&gt;[use_min, use_max]&lt;/code&gt;, where:</source>
          <target state="translated">ブロックのサイズは &lt;code&gt;[use_min, use_max]&lt;/code&gt; 範囲内でなければなりません。ここで、</target>
        </trans-unit>
        <trans-unit id="0d55dd5d42feb75840d81a2ee396cf125ff6a36f" translate="yes" xml:space="preserve">
          <source>The block's starting address must be aligned to &lt;code&gt;layout.align()&lt;/code&gt;.</source>
          <target state="translated">ブロックの開始アドレスは、 &lt;code&gt;layout.align()&lt;/code&gt; に揃える必要があります。</target>
        </trans-unit>
        <trans-unit id="6fb5efe10f486c51a18bce4f54350dd31c9d18ad" translate="yes" xml:space="preserve">
          <source>The bodies of the &lt;code&gt;if let&lt;/code&gt; and the &lt;code&gt;unwrap_or_else&lt;/code&gt; functions are the same in both cases: we print the error and exit.</source>
          <target state="translated">&lt;code&gt;if let&lt;/code&gt; 関数と &lt;code&gt;unwrap_or_else&lt;/code&gt; 関数の本体はどちらの場合も同じです。エラーを出力して終了します。</target>
        </trans-unit>
        <trans-unit id="a084bd821dcd5af3bead7d20966da99b85c8d3d6" translate="yes" xml:space="preserve">
          <source>The body of a &lt;a href=&quot;expressions/if-expr#if-expressions&quot;&gt;&lt;code&gt;if&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;expressions/loop-expr#predicate-loops&quot;&gt;&lt;code&gt;while&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;expressions/loop-expr#infinite-loops&quot;&gt;&lt;code&gt;loop&lt;/code&gt;&lt;/a&gt; expression.</source>
          <target state="translated">&lt;a href=&quot;expressions/if-expr#if-expressions&quot;&gt; &lt;code&gt;if&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;expressions/loop-expr#predicate-loops&quot;&gt; &lt;code&gt;while&lt;/code&gt; 、&lt;/a&gt;または&lt;a href=&quot;expressions/loop-expr#infinite-loops&quot;&gt; &lt;code&gt;loop&lt;/code&gt; &lt;/a&gt;式の本体。</target>
        </trans-unit>
        <trans-unit id="8d22837f9a0a24391528e1a0b3b2365c1d2579bc" translate="yes" xml:space="preserve">
          <source>The body of the function starts by calling the &lt;code&gt;File::open&lt;/code&gt; function. Then we handle the &lt;code&gt;Result&lt;/code&gt; value returned with a &lt;code&gt;match&lt;/code&gt; similar to the &lt;code&gt;match&lt;/code&gt; in Listing 9-4, only instead of calling &lt;code&gt;panic!&lt;/code&gt; in the &lt;code&gt;Err&lt;/code&gt; case, we return early from this function and pass the error value from &lt;code&gt;File::open&lt;/code&gt; back to the calling code as this function&amp;rsquo;s error value. If &lt;code&gt;File::open&lt;/code&gt; succeeds, we store the file handle in the variable &lt;code&gt;f&lt;/code&gt; and continue.</source>
          <target state="translated">関数の本体は、 &lt;code&gt;File::open&lt;/code&gt; 関数を呼び出すことから始まります。その後、我々はハンドル &lt;code&gt;Result&lt;/code&gt; で返された値 &lt;code&gt;match&lt;/code&gt; に似た &lt;code&gt;match&lt;/code&gt; のみの代わりに呼び出しのリスト9-4で、 &lt;code&gt;panic!&lt;/code&gt; &lt;code&gt;Err&lt;/code&gt; 場合、我々は早期にこの関数から戻ってからエラー値を渡す &lt;code&gt;File::open&lt;/code&gt; 呼び出し元のコードに戻って、この関数のエラー値として。 &lt;code&gt;File::open&lt;/code&gt; が成功した場合、ファイルハンドルを変数 &lt;code&gt;f&lt;/code&gt; に格納して続行します。</target>
        </trans-unit>
        <trans-unit id="9ba4d0e4523a23a56b57272682f48b03a790c657" translate="yes" xml:space="preserve">
          <source>The body of the method would use &lt;code&gt;self&lt;/code&gt; to get the value that we called the method on. In this example, we&amp;rsquo;ve created a variable &lt;code&gt;m&lt;/code&gt; that has the value &lt;code&gt;Message::Write(String::from(&quot;hello&quot;))&lt;/code&gt;, and that is what &lt;code&gt;self&lt;/code&gt; will be in the body of the &lt;code&gt;call&lt;/code&gt; method when &lt;code&gt;m.call()&lt;/code&gt; runs.</source>
          <target state="translated">メソッドの本体は &lt;code&gt;self&lt;/code&gt; を使用して、メソッドを呼び出した値を取得します。この例では、変数の作成した &lt;code&gt;m&lt;/code&gt; 値の持つ &lt;code&gt;Message::Write(String::from(&quot;hello&quot;))&lt;/code&gt; 、そしてそれは何である &lt;code&gt;self&lt;/code&gt; の身体になります &lt;code&gt;call&lt;/code&gt; たときに方法 &lt;code&gt;m.call()&lt;/code&gt; 実行します。</target>
        </trans-unit>
        <trans-unit id="9c00fd6128e2bdd1cc90bd415df84de85499f4fb" translate="yes" xml:space="preserve">
          <source>The book &lt;em&gt;Design Patterns: Elements of Reusable Object-Oriented Software&lt;/em&gt; by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides (Addison-Wesley Professional, 1994) colloquially referred to as &lt;em&gt;The Gang of Four&lt;/em&gt; book, is a catalog of object-oriented design patterns. It defines OOP this way:</source>
          <target state="translated">本の&lt;em&gt;デザインパターン：再利用可能なオブジェクト指向ソフトウェアの要素（&lt;/em&gt; Erich Gamma、Richard Helm、Ralph Johnson、およびJohn Vlissides（Addison-Wesley Professional、1994））は、通称&lt;em&gt;「ギャングオブフォー&lt;/em&gt;」と呼ばれ、オブジェクト指向のカタログです。デザインパターン。次のようにOOPを定義します。</target>
        </trans-unit>
        <trans-unit id="0ab81c05a8d6cbaec3e9dfb9c8caa2a16dab19bf" translate="yes" xml:space="preserve">
          <source>The boolean type.</source>
          <target state="translated">ブール型です。</target>
        </trans-unit>
        <trans-unit id="06283747a377154700dbba912c9e77d60011a87e" translate="yes" xml:space="preserve">
          <source>The borrow lasts until the returned &lt;code&gt;Ref&lt;/code&gt; exits scope. Multiple immutable borrows can be taken out at the same time.</source>
          <target state="translated">借用は、返された &lt;code&gt;Ref&lt;/code&gt; がスコープを出るまで続きます。複数の不変の借用を同時に取り出すことができます。</target>
        </trans-unit>
        <trans-unit id="45376451530857b96a10ec4a5e20bb51cfc0ed12" translate="yes" xml:space="preserve">
          <source>The borrow lasts until the returned &lt;code&gt;RefMut&lt;/code&gt; or all &lt;code&gt;RefMut&lt;/code&gt;s derived from it exit scope. The value cannot be borrowed while this borrow is active.</source>
          <target state="translated">借用は、返された &lt;code&gt;RefMut&lt;/code&gt; またはそれから派生したすべての &lt;code&gt;RefMut&lt;/code&gt; がスコープを出るまで続きます。この借用がアクティブな間、値を借用することはできません。</target>
        </trans-unit>
        <trans-unit id="f968733bf846dacfb002493e18e27a27864a5d95" translate="yes" xml:space="preserve">
          <source>The buffer is written out before returning the writer.</source>
          <target state="translated">ライターを返す前にバッファを書き出します。</target>
        </trans-unit>
        <trans-unit id="8d2f5c9c4df44bd26200b02c526dd9675a0b62ea" translate="yes" xml:space="preserve">
          <source>The buffer specified was 0 bytes in length.</source>
          <target state="translated">指定されたバッファの長さは0バイトでした。</target>
        </trans-unit>
        <trans-unit id="aac2e47b3535d051db39f7a14fa1dba18fc6a121" translate="yes" xml:space="preserve">
          <source>The built-in &lt;code&gt;cfg&lt;/code&gt; macro takes in a single configuration predicate and evaluates to the &lt;code&gt;true&lt;/code&gt; literal when the predicate is true and the &lt;code&gt;false&lt;/code&gt; literal when it is false.</source>
          <target state="translated">組み込みの &lt;code&gt;cfg&lt;/code&gt; マクロは、単一の構成述語を取り込んで、述語が真の場合は &lt;code&gt;true&lt;/code&gt; リテラルに評価され、 &lt;code&gt;false&lt;/code&gt; の場合は偽のリテラルに評価されます。</target>
        </trans-unit>
        <trans-unit id="87ae881f172e3eab463a1dba119d942ed8deaed7" translate="yes" xml:space="preserve">
          <source>The built-in attributes that have meaning on a function are &lt;a href=&quot;../conditional-compilation&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt;&lt;code&gt;deprecated&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt;&lt;code&gt;doc&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;the lint check attributes&lt;/a&gt;, &lt;code&gt;path&lt;/code&gt;, and &lt;code&gt;no_implicit_prelude&lt;/code&gt;. Modules also accept macro attributes.</source>
          <target state="translated">関数に意味のある組み込み属性は、&lt;a href=&quot;../conditional-compilation&quot;&gt; &lt;code&gt;cfg&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt; &lt;code&gt;deprecated&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt; &lt;code&gt;doc&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;lintチェック属性&lt;/a&gt;、 &lt;code&gt;path&lt;/code&gt; 、および &lt;code&gt;no_implicit_prelude&lt;/code&gt; です。モジュールはマクロ属性も受け入れます。</target>
        </trans-unit>
        <trans-unit id="0658caeac4e6cc6250807a10a1d1127da8f7b8cb" translate="yes" xml:space="preserve">
          <source>The built-in attributes that have meaning on a module are &lt;a href=&quot;../conditional-compilation&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt;&lt;code&gt;deprecated&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt;&lt;code&gt;doc&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;the lint check attributes&lt;/a&gt;, &lt;code&gt;path&lt;/code&gt;, and &lt;code&gt;no_implicit_prelude&lt;/code&gt;. Modules also accept macro attributes.</source>
          <target state="translated">モジュールで意味を持つ組み込み属性は、&lt;a href=&quot;../conditional-compilation&quot;&gt; &lt;code&gt;cfg&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt; &lt;code&gt;deprecated&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt; &lt;code&gt;doc&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;lintチェック属性&lt;/a&gt;、 &lt;code&gt;path&lt;/code&gt; 、および &lt;code&gt;no_implicit_prelude&lt;/code&gt; です。モジュールはマクロ属性も受け入れます。</target>
        </trans-unit>
        <trans-unit id="7917b1e20d5567c345241cec71cc654edebdd434" translate="yes" xml:space="preserve">
          <source>The built-in function traits are generic over a tuple of the function arguments. If one uses angle-bracket notation (&lt;code&gt;Fn&amp;lt;(T,), Output=U&amp;gt;&lt;/code&gt;) instead of parentheses (&lt;code&gt;Fn(T) -&amp;gt; U&lt;/code&gt;) to denote the function trait, the type parameter should be a tuple. Otherwise function call notation cannot be used and the trait will not be implemented by closures.</source>
          <target state="translated">組み込み関数の特性は、関数の引数のタプルよりも一般的です。括弧（ &lt;code&gt;Fn(T) -&amp;gt; U&lt;/code&gt; ）ではなく山括弧表記（ &lt;code&gt;Fn&amp;lt;(T,), Output=U&amp;gt;&lt;/code&gt; ）を使用して関数の特性を示す場合、typeパラメーターはタプルである必要があります。それ以外の場合、関数呼び出し表記は使用できず、トレイトはクロージャーによって実装されません。</target>
        </trans-unit>
        <trans-unit id="a9e1ef14ad9c5016cccb06e0dae0b41ca0441837" translate="yes" xml:space="preserve">
          <source>The c-main function only supports to return integers as return type. So, every type implementing the &lt;code&gt;Termination&lt;/code&gt; trait has to be converted to an integer.</source>
          <target state="translated">c-main関数は、戻り値の型として整数を返すことのみをサポートしています。したがって、 &lt;code&gt;Termination&lt;/code&gt; 特性を実装するすべての型は整数に変換する必要があります。</target>
        </trans-unit>
        <trans-unit id="98a1e057ef0866ad400391fbf23a2daa11b28012" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;lock&lt;/code&gt; would fail if another thread holding the lock panicked. In that case, no one would ever be able to get the lock, so we&amp;rsquo;ve chosen to &lt;code&gt;unwrap&lt;/code&gt; and have this thread panic if we&amp;rsquo;re in that situation.</source>
          <target state="translated">&lt;code&gt;lock&lt;/code&gt; を保持している別のスレッドがパニックした場合、ロックの呼び出しは失敗します。その場合、誰もロックを取得することができないため、その状況にある場合は、 &lt;code&gt;unwrap&lt;/code&gt; してこのスレッドをパニックにすることを選択しました。</target>
        </trans-unit>
        <trans-unit id="a399c55a0729e88865a33bb045bf002d26006429" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;panic!&lt;/code&gt; causes the error message contained in the last two lines. The first line shows our panic message and the place in our source code where the panic occurred: &lt;em&gt;src/main.rs:2:5&lt;/em&gt; indicates that it&amp;rsquo;s the second line, fifth character of our &lt;em&gt;src/main.rs&lt;/em&gt; file.</source>
          <target state="translated">&lt;code&gt;panic!&lt;/code&gt; への呼びかけ！最後の2行に含まれるエラーメッセージが表示されます。1行目は、パニックメッセージと、パニックが発生したソースコード内の場所を示しています&lt;em&gt;。src/ main.rs：2：5&lt;/em&gt;は、2行目、&lt;em&gt;つまりsrc / main.rs&lt;/em&gt;ファイルの5番目の文字であることを示しています。</target>
        </trans-unit>
        <trans-unit id="76991560cfa9d5bcd0a2eea05c7ac9259a741680" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;parse&lt;/code&gt; could easily cause an error. If, for example, the string contained &lt;code&gt;A👍%&lt;/code&gt;, there would be no way to convert that to a number. Because it might fail, the &lt;code&gt;parse&lt;/code&gt; method returns a &lt;code&gt;Result&lt;/code&gt; type, much as the &lt;code&gt;read_line&lt;/code&gt; method does (discussed earlier in &lt;a href=&quot;#handling-potential-failure-with-the-result-type&quot;&gt;&amp;ldquo;Handling Potential Failure with the &lt;code&gt;Result&lt;/code&gt; Type&amp;rdquo;&lt;/a&gt;). We&amp;rsquo;ll treat this &lt;code&gt;Result&lt;/code&gt; the same way by using the &lt;code&gt;expect&lt;/code&gt; method again. If &lt;code&gt;parse&lt;/code&gt; returns an &lt;code&gt;Err&lt;/code&gt;&lt;code&gt;Result&lt;/code&gt; variant because it couldn&amp;rsquo;t create a number from the string, the &lt;code&gt;expect&lt;/code&gt; call will crash the game and print the message we give it. If &lt;code&gt;parse&lt;/code&gt; can successfully convert the string to a number, it will return the &lt;code&gt;Ok&lt;/code&gt; variant of &lt;code&gt;Result&lt;/code&gt;, and &lt;code&gt;expect&lt;/code&gt; will return the number that we want from the &lt;code&gt;Ok&lt;/code&gt; value.</source>
          <target state="translated">&lt;code&gt;parse&lt;/code&gt; を呼び出すと、簡単にエラーが発生する可能性があります。たとえば、文字列に &lt;code&gt;A👍%&lt;/code&gt; が含まれている場合、それを数値に変換する方法はありません。 &lt;code&gt;parse&lt;/code&gt; メソッドは失敗する可能性があるため、 &lt;code&gt;read_line&lt;/code&gt; メソッドと同じように &lt;code&gt;Result&lt;/code&gt; 型を返します（&lt;a href=&quot;#handling-potential-failure-with-the-result-type&quot;&gt;「&lt;/a&gt; &lt;code&gt;Result&lt;/code&gt; 型による潜在的な障害の処理」で前に説明しました）。この &lt;code&gt;Result&lt;/code&gt; は、 &lt;code&gt;expect&lt;/code&gt; メソッドを再度使用することで同じように扱います。文字列から数値を作成できなかったために &lt;code&gt;parse&lt;/code&gt; が &lt;code&gt;Err&lt;/code&gt; &lt;code&gt;Result&lt;/code&gt; バリアントを返す場合、 &lt;code&gt;expect&lt;/code&gt; 呼び出しはゲームをクラッシュさせ、私たちが与えるメッセージを出力します。場合は &lt;code&gt;parse&lt;/code&gt; 成功した文字列を数値に変換することができ、それが返されます &lt;code&gt;Ok&lt;/code&gt; のバリアント &lt;code&gt;Result&lt;/code&gt; 、と &lt;code&gt;expect&lt;/code&gt; から私たちが望むことの数を返します &lt;code&gt;Ok&lt;/code&gt; 値。</target>
        </trans-unit>
        <trans-unit id="7b69e26d39a3f8839842ab3c559f82019ca9b310" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;recv&lt;/code&gt; blocks, so if there is no job yet, the current thread will wait until a job becomes available. The &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; ensures that only one &lt;code&gt;Worker&lt;/code&gt; thread at a time is trying to request a job.</source>
          <target state="translated">&lt;code&gt;recv&lt;/code&gt; の呼び出しはブロックされるため、ジョブがない場合、現在のスレッドはジョブが使用可能になるまで待機します。 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 唯一性を保証 &lt;code&gt;Worker&lt;/code&gt; 時にスレッドが仕事を依頼しようとしています。</target>
        </trans-unit>
        <trans-unit id="8993444f4968db6cec0c3f76e82220cf7def7574" translate="yes" xml:space="preserve">
          <source>The caller has to ensure that no references in the supplied thread closure or its return type can outlive the spawned thread's lifetime. This can be guaranteed in two ways:</source>
          <target state="translated">呼び出し元は、供給されたスレッドクロージャやその戻り値の型の中にある参照が、 スポーンされたスレッドの寿命を超えないようにしなければなりません。これは二つの方法で保証されます。</target>
        </trans-unit>
        <trans-unit id="093036972d7bffcd0b16a57c6e2ba75deeb1dca1" translate="yes" xml:space="preserve">
          <source>The caller must also ensure that the memory the pointer (non-transitively) points to is never written to (except inside an &lt;code&gt;UnsafeCell&lt;/code&gt;) using this pointer or any pointer derived from it. If you need to mutate the contents of the slice, use &lt;a href=&quot;#method.as_mut_ptr&quot;&gt;&lt;code&gt;as_mut_ptr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">呼び出し元は、ポインタ（非推移的）が指すメモリが、このポインタまたはそこから派生したポインタを使用して（ &lt;code&gt;UnsafeCell&lt;/code&gt; 内を除いて）決して書き込まれないようにする必要もあります。スライスの内容を変更する必要がある場合は、&lt;a href=&quot;#method.as_mut_ptr&quot;&gt; &lt;code&gt;as_mut_ptr&lt;/code&gt; を&lt;/a&gt;使用します。</target>
        </trans-unit>
        <trans-unit id="fbd8e378206e5ebe48537e21894c0d0196aa5c37" translate="yes" xml:space="preserve">
          <source>The caller must also ensure that the memory the pointer (non-transitively) points to is never written to (except inside an &lt;code&gt;UnsafeCell&lt;/code&gt;) using this pointer or any pointer derived from it. If you need to mutate the contents of the slice, use &lt;a href=&quot;struct.vec#method.as_mut_ptr&quot;&gt;&lt;code&gt;as_mut_ptr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">呼び出し元は、このポインターまたはそこから派生したポインターを使用して、ポインターが（非推移的に）指すメモリーが（ &lt;code&gt;UnsafeCell&lt;/code&gt; 内を除いて）書き込まれないようにする必要もあります。スライスの内容を変更する必要がある場合は、&lt;a href=&quot;struct.vec#method.as_mut_ptr&quot;&gt; &lt;code&gt;as_mut_ptr&lt;/code&gt; を&lt;/a&gt;使用します。</target>
        </trans-unit>
        <trans-unit id="2daa4ea0adccac77e0ee2e5186b78bccb935a23d" translate="yes" xml:space="preserve">
          <source>The caller must ensure that the content of the slice is valid UTF-8 before the borrow ends and the underlying &lt;code&gt;str&lt;/code&gt; is used.</source>
          <target state="translated">呼び出し元は、借用が終了して基になる &lt;code&gt;str&lt;/code&gt; が使用される前に、スライスのコンテンツが有効なUTF-8であることを確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="ac3ada34e0728cb1a740ac35a9a92bd4109e42c8" translate="yes" xml:space="preserve">
          <source>The caller must ensure that the returned pointer is never written to. If you need to mutate the contents of the string slice, use &lt;a href=&quot;#method.as_mut_ptr&quot;&gt;&lt;code&gt;as_mut_ptr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">呼び出し元は、返されたポインタが決して書き込まれないようにする必要があります。文字列スライスの内容を変更する必要がある場合は、&lt;a href=&quot;#method.as_mut_ptr&quot;&gt; &lt;code&gt;as_mut_ptr&lt;/code&gt; を&lt;/a&gt;使用します。</target>
        </trans-unit>
        <trans-unit id="0c95ecf028004da1510b460935745006e917bea1" translate="yes" xml:space="preserve">
          <source>The caller must ensure that the returned pointer is never written to. If you need to mutate the contents of the string slice, use &lt;a href=&quot;../primitive.str#method.as_mut_ptr&quot;&gt;&lt;code&gt;as_mut_ptr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">呼び出し元は、返されたポインタが決して書き込まれないようにする必要があります。文字列スライスの内容を変更する必要がある場合は、&lt;a href=&quot;../primitive.str#method.as_mut_ptr&quot;&gt; &lt;code&gt;as_mut_ptr&lt;/code&gt; を&lt;/a&gt;使用します。</target>
        </trans-unit>
        <trans-unit id="de2dba4a5088d0450aaa1d7584230c3882b4aa0e" translate="yes" xml:space="preserve">
          <source>The caller must ensure that the returned pointer is never written to. If you need to mutate the contents of the string slice, use &lt;a href=&quot;primitive.str#method.as_mut_ptr&quot;&gt;&lt;code&gt;as_mut_ptr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">呼び出し元は、返されたポインタが決して書き込まれないようにする必要があります。文字列スライスの内容を変更する必要がある場合は、&lt;a href=&quot;primitive.str#method.as_mut_ptr&quot;&gt; &lt;code&gt;as_mut_ptr&lt;/code&gt; を&lt;/a&gt;使用します。</target>
        </trans-unit>
        <trans-unit id="0392a3d2bc79f7cc36923d474ab5bb48f657c119" translate="yes" xml:space="preserve">
          <source>The caller must ensure that the slice outlives the pointer this function returns, or else it will end up pointing to garbage.</source>
          <target state="translated">呼び出し元は、この関数が返すポインタよりもスライスが長持ちするようにしなければなりません。</target>
        </trans-unit>
        <trans-unit id="bf480a8080607d02f4b53d9ea9e935964787c02b" translate="yes" xml:space="preserve">
          <source>The caller must ensure that the vector outlives the pointer this function returns, or else it will end up pointing to garbage. Modifying the vector may cause its buffer to be reallocated, which would also make any pointers to it invalid.</source>
          <target state="translated">呼び出し元はベクトルがこの関数が返すポインタよりも長持ちするようにしなければなりません。ベクトルを変更すると,そのバッファが再割り当てされる可能性があります.</target>
        </trans-unit>
        <trans-unit id="09005f0066a1b73d30e33e09129bf20aee61c736" translate="yes" xml:space="preserve">
          <source>The calling thread will be blocked until there are no more writers which hold the lock. There may be other readers currently inside the lock when this method returns. This method does not provide any guarantees with respect to the ordering of whether contentious readers or writers will acquire the lock first.</source>
          <target state="translated">呼び出したスレッドは、ロックを保持しているライターがなくなるまでブロックされます。このメソッドが戻ってきたときには、現在ロックの中に他のリーダがいるかもしれません。このメソッドは、競合するリーダやライタが最初にロックを取得するかどうかの順序については何ら保証しません。</target>
        </trans-unit>
        <trans-unit id="4c684d1da6df1a86528a2f3d33b0bb20fea3d352" translate="yes" xml:space="preserve">
          <source>The calls to &lt;code&gt;thread::sleep&lt;/code&gt; force a thread to stop its execution for a short duration, allowing a different thread to run. The threads will probably take turns, but that isn&amp;rsquo;t guaranteed: it depends on how your operating system schedules the threads. In this run, the main thread printed first, even though the print statement from the spawned thread appears first in the code. And even though we told the spawned thread to print until &lt;code&gt;i&lt;/code&gt; is 9, it only got to 5 before the main thread shut down.</source>
          <target state="translated">&lt;code&gt;thread::sleep&lt;/code&gt; の呼び出しは、スレッドにその実行を短時間停止させ、別のスレッドの実行を許可します。スレッドは交互に実行される可能性がありますが、保証はありません。オペレーティングシステムがスレッドをスケジュールする方法によって異なります。この実行では、生成されたスレッドの印刷ステートメントがコードの最初に表示されていても、メインスレッドが最初に印刷されました。そして、生成されたスレッドに &lt;code&gt;i&lt;/code&gt; が9になるまで印刷するように指示したにもかかわらず、メインスレッドがシャットダウンする前に5にしか到達しませんでした。</target>
        </trans-unit>
        <trans-unit id="c7560eebffb8ae3cdb259698d7be211bc4620b7e" translate="yes" xml:space="preserve">
          <source>The canonical ExitCode for successful termination on this platform.</source>
          <target state="translated">このプラットフォーム上で正常に終了するための標準的なExitCode。</target>
        </trans-unit>
        <trans-unit id="8f6ef1b9ea50b970966541a96ea6f822d628893b" translate="yes" xml:space="preserve">
          <source>The canonical ExitCode for unsuccessful termination on this platform.</source>
          <target state="translated">このプラットフォーム上で失敗して終了した場合の標準的なExitCode。</target>
        </trans-unit>
        <trans-unit id="edfe5292e463236ad7502b40af63d1dc3846bebd" translate="yes" xml:space="preserve">
          <source>The canonical path is only meaningful within a given crate. There is no global namespace across crates; an item's canonical path merely identifies it within the crate.</source>
          <target state="translated">このような場合には、「このプロジェクトは、このプロジェクトに含まれていない」ということになります。このような場合には、このような情報を使用することはできません。</target>
        </trans-unit>
        <trans-unit id="42b8d1ea1b4247711765802c026fc2d790b1362d" translate="yes" xml:space="preserve">
          <source>The canonical safe use of &lt;code&gt;mem::forget&lt;/code&gt; is to circumvent a value's destructor implemented by the &lt;code&gt;Drop&lt;/code&gt; trait. For example, this will leak a &lt;code&gt;File&lt;/code&gt;, i.e. reclaim the space taken by the variable but never close the underlying system resource:</source>
          <target state="translated">&lt;code&gt;mem::forget&lt;/code&gt; の標準的な安全な使用法は、 &lt;code&gt;Drop&lt;/code&gt; トレイトによって実装された値のデストラクタを回避することです。たとえば、これは &lt;code&gt;File&lt;/code&gt; をリークします。つまり、変数が使用するスペースを再利用しますが、基になるシステムリソースを閉じることはありません。</target>
        </trans-unit>
        <trans-unit id="1aa3ddcbed06fec001e59bb6f3f1f1da2ef18ef6" translate="yes" xml:space="preserve">
          <source>The capacity may be increased by more than &lt;code&gt;additional&lt;/code&gt; bytes if it chooses, to prevent frequent reallocations.</source>
          <target state="translated">容量は、必要に応じて &lt;code&gt;additional&lt;/code&gt; バイトよりも多くして、頻繁な再割り当てを防ぐことができます。</target>
        </trans-unit>
        <trans-unit id="4e527152d8f3ca4ddc869842d5ee9ae2a46a82fb" translate="yes" xml:space="preserve">
          <source>The capacity of a vector is the amount of space allocated for any future elements that will be added onto the vector. This is not to be confused with the &lt;em&gt;length&lt;/em&gt; of a vector, which specifies the number of actual elements within the vector. If a vector's length exceeds its capacity, its capacity will automatically be increased, but its elements will have to be reallocated.</source>
          <target state="translated">ベクターの容量は、ベクターに追加される将来の要素に割り当てられるスペースの量です。これは、ベクトル内の実際の要素の数を指定するベクトルの&lt;em&gt;長さ&lt;/em&gt;と混同しないでください。ベクトルの長さがその容量を超えると、その容量は自動的に増加しますが、その要素を再割り当てする必要があります。</target>
        </trans-unit>
        <trans-unit id="a70fb21498dabd7b592b7614b4af0ad2efc52b05" translate="yes" xml:space="preserve">
          <source>The capacity will remain at least as large as both the length and the supplied value.</source>
          <target state="translated">容量は、少なくとも長さと供給値の両方と同じくらいの大きさを維持します。</target>
        </trans-unit>
        <trans-unit id="f2f4d42ff0e5eed287aac391d229f38ad7615e31" translate="yes" xml:space="preserve">
          <source>The captured values of a &lt;a href=&quot;types/closure&quot;&gt;closure&lt;/a&gt; are dropped in an unspecified order.</source>
          <target state="translated">キャプチャされた&lt;a href=&quot;types/closure&quot;&gt;クロージャの&lt;/a&gt;値は、不特定の順序で削除されます。</target>
        </trans-unit>
        <trans-unit id="138edd42fa740c68b92f8f2886d9a7cfd608a2f8" translate="yes" xml:space="preserve">
          <source>The changes we needed to make to &lt;code&gt;main&lt;/code&gt; to reassign &lt;code&gt;post&lt;/code&gt; mean that this implementation doesn&amp;rsquo;t quite follow the object-oriented state pattern anymore: the transformations between the states are no longer encapsulated entirely within the &lt;code&gt;Post&lt;/code&gt; implementation. However, our gain is that invalid states are now impossible because of the type system and the type checking that happens at compile time! This ensures that certain bugs, such as display of the content of an unpublished post, will be discovered before they make it to production.</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; に &lt;code&gt;post&lt;/code&gt; を再割り当てするために必要な変更は、この実装がオブジェクト指向の状態パターンに完全に従わないことを意味します。状態間の変換は、 &lt;code&gt;Post&lt;/code&gt; 実装内に完全にカプセル化されなくなりました。ただし、型システムと型チェックがコンパイル時に行われるため、無効な状態は不可能になりました。これにより、非公開の投稿のコンテンツの表示など、特定のバグが本番環境に移行する前に確実に発見されます。</target>
        </trans-unit>
        <trans-unit id="7c6978553f5d9c2a253b6007e164ab1e1253e787" translate="yes" xml:space="preserve">
          <source>The character represented by this escape</source>
          <target state="translated">このエスケープで表される文字</target>
        </trans-unit>
        <trans-unit id="444f11cad1e3ea489affb1093e4cfe00aec033b8" translate="yes" xml:space="preserve">
          <source>The character type, &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">文字タイプ &lt;code&gt;char&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a2ab8aadbe1c6203ddb8254dc62679ad2d0d6a50" translate="yes" xml:space="preserve">
          <source>The child inherits from the corresponding parent descriptor.</source>
          <target state="translated">子は対応する親ディスクリプタを継承します。</target>
        </trans-unit>
        <trans-unit id="57f64da60a0aae4c7ca65b39d52634b157698777" translate="yes" xml:space="preserve">
          <source>The chunks are array references and do not overlap. If &lt;code&gt;N&lt;/code&gt; does not divide the length of the slice, then the last up to &lt;code&gt;N-1&lt;/code&gt; elements will be omitted and can be retrieved from the &lt;code&gt;remainder&lt;/code&gt; function of the iterator.</source>
          <target state="translated">チャンクは配列参照であり、重複しません。 &lt;code&gt;N&lt;/code&gt; がスライスの長さを分割しない場合、最後の最大 &lt;code&gt;N-1&lt;/code&gt; 個の要素が省略され、イテレーターの &lt;code&gt;remainder&lt;/code&gt; 関数から取得できます。</target>
        </trans-unit>
        <trans-unit id="15fa38fbe64a63fe95b52b94271d4ba554613043" translate="yes" xml:space="preserve">
          <source>The chunks are mutable array references and do not overlap. If &lt;code&gt;N&lt;/code&gt; does not divide the length of the slice, then the last up to &lt;code&gt;N-1&lt;/code&gt; elements will be omitted and can be retrieved from the &lt;code&gt;into_remainder&lt;/code&gt; function of the iterator.</source>
          <target state="translated">チャンクは可変配列参照であり、重複しません。 &lt;code&gt;N&lt;/code&gt; がスライスの長さを分割しない場合、最後の最大 &lt;code&gt;N-1&lt;/code&gt; 個の要素が省略され、イテレータの &lt;code&gt;into_remainder&lt;/code&gt; 関数から取得できます。</target>
        </trans-unit>
        <trans-unit id="22f36eeee32622c7a505cef344bfce71a990d798" translate="yes" xml:space="preserve">
          <source>The chunks are mutable slices, and do not overlap. If &lt;code&gt;chunk_size&lt;/code&gt; does not divide the length of the slice, then the last chunk will not have length &lt;code&gt;chunk_size&lt;/code&gt;.</source>
          <target state="translated">チャンクは変更可能なスライスであり、重複しません。 &lt;code&gt;chunk_size&lt;/code&gt; がスライスの長さを分割しない場合、最後のチャンクの長さは &lt;code&gt;chunk_size&lt;/code&gt; になりません。</target>
        </trans-unit>
        <trans-unit id="a56cc46096f73dcb9c3581ef24840c1b8a52d3e3" translate="yes" xml:space="preserve">
          <source>The chunks are mutable slices, and do not overlap. If &lt;code&gt;chunk_size&lt;/code&gt; does not divide the length of the slice, then the last up to &lt;code&gt;chunk_size-1&lt;/code&gt; elements will be omitted and can be retrieved from the &lt;code&gt;into_remainder&lt;/code&gt; function of the iterator.</source>
          <target state="translated">チャンクは変更可能なスライスであり、重複しません。 &lt;code&gt;chunk_size&lt;/code&gt; がスライスの長さを分割しない場合、 &lt;code&gt;into_remainder&lt;/code&gt; &lt;code&gt;chunk_size-1&lt;/code&gt; までの最後の要素は省略され、イテレータのinto_remainder関数から取得できます。</target>
        </trans-unit>
        <trans-unit id="b9b82e1f955649f5c987c92e4ad59440a3cb7655" translate="yes" xml:space="preserve">
          <source>The chunks are slices and do not overlap. If &lt;code&gt;chunk_size&lt;/code&gt; does not divide the length of the slice, then the last chunk will not have length &lt;code&gt;chunk_size&lt;/code&gt;.</source>
          <target state="translated">チャンクはスライスであり、重複しません。 &lt;code&gt;chunk_size&lt;/code&gt; がスライスの長さを分割しない場合、最後のチャンクの長さは &lt;code&gt;chunk_size&lt;/code&gt; になりません。</target>
        </trans-unit>
        <trans-unit id="93ee6025794c31565e33ecdc52225cb4e18501bf" translate="yes" xml:space="preserve">
          <source>The chunks are slices and do not overlap. If &lt;code&gt;chunk_size&lt;/code&gt; does not divide the length of the slice, then the last up to &lt;code&gt;chunk_size-1&lt;/code&gt; elements will be omitted and can be retrieved from the &lt;code&gt;remainder&lt;/code&gt; function of the iterator.</source>
          <target state="translated">チャンクはスライスであり、重複しません。 &lt;code&gt;chunk_size&lt;/code&gt; がスライスの長さを分割しない場合、最後の &lt;code&gt;chunk_size-1&lt;/code&gt; までの要素は省略され、反復子の &lt;code&gt;remainder&lt;/code&gt; 関数から取得できます。</target>
        </trans-unit>
        <trans-unit id="5ab8cfd0030cc999866ad155de372dfc9a291653" translate="yes" xml:space="preserve">
          <source>The closure &lt;code&gt;f&lt;/code&gt; is yielded a &lt;a href=&quot;struct.oncestate&quot;&gt;&lt;code&gt;OnceState&lt;/code&gt;&lt;/a&gt; structure which can be used to query the poison status of the &lt;a href=&quot;struct.once&quot;&gt;&lt;code&gt;Once&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">クロージャー &lt;code&gt;f&lt;/code&gt; は、&lt;a href=&quot;struct.once&quot;&gt; &lt;code&gt;Once&lt;/code&gt; の&lt;/a&gt;ポイズンステータスを照会するために使用できる&lt;a href=&quot;struct.oncestate&quot;&gt; &lt;code&gt;OnceState&lt;/code&gt; &lt;/a&gt;構造体を生成します。</target>
        </trans-unit>
        <trans-unit id="8464cb339a91ac7f9edf87e86826287afbdde678" translate="yes" xml:space="preserve">
          <source>The closure &lt;code&gt;f&lt;/code&gt; is yielded a &lt;a href=&quot;struct.oncestate&quot;&gt;&lt;code&gt;OnceState&lt;/code&gt;&lt;/a&gt; structure which can be used to query the poison status of the &lt;code&gt;Once&lt;/code&gt;.</source>
          <target state="translated">クロージャ &lt;code&gt;f&lt;/code&gt; は、 &lt;code&gt;Once&lt;/code&gt; のポイズンステータスのクエリに使用できる&lt;a href=&quot;struct.oncestate&quot;&gt; &lt;code&gt;OnceState&lt;/code&gt; &lt;/a&gt;構造を生成します。</target>
        </trans-unit>
        <trans-unit id="6122336d1e3dc25f0e6a48ca5c6617d72884ddeb" translate="yes" xml:space="preserve">
          <source>The closure &lt;code&gt;f&lt;/code&gt; will only be executed once if this is called concurrently amongst many threads. If that closure panics, however, then it will &lt;em&gt;poison&lt;/em&gt; this &lt;a href=&quot;struct.once&quot;&gt;&lt;code&gt;Once&lt;/code&gt;&lt;/a&gt; instance, causing all future invocations of &lt;code&gt;call_once&lt;/code&gt; to also panic.</source>
          <target state="translated">クロージャー &lt;code&gt;f&lt;/code&gt; は、これが多くのスレッド間で同時に呼び出された場合に1回だけ実行されます。その閉鎖パニックが発生した場合は、しかし、それがされます&lt;em&gt;毒&lt;/em&gt;、この&lt;a href=&quot;struct.once&quot;&gt; &lt;code&gt;Once&lt;/code&gt; &lt;/a&gt;のすべての将来の呼び出し引き起こし、インスタンスを &lt;code&gt;call_once&lt;/code&gt; もパニックに。</target>
        </trans-unit>
        <trans-unit id="1151c6060a40c30d933870c684e8f8c1c9ce7a79" translate="yes" xml:space="preserve">
          <source>The closure &lt;code&gt;f&lt;/code&gt; will only be executed once if this is called concurrently amongst many threads. If that closure panics, however, then it will &lt;em&gt;poison&lt;/em&gt; this &lt;code&gt;Once&lt;/code&gt; instance, causing all future invocations of &lt;code&gt;call_once&lt;/code&gt; to also panic.</source>
          <target state="translated">クロージャー &lt;code&gt;f&lt;/code&gt; は、これが多数のスレッド間で同時に呼び出された場合に1回だけ実行されます。その閉鎖パニックが発生した場合は、しかし、それがされます&lt;em&gt;毒&lt;/em&gt;、この &lt;code&gt;Once&lt;/code&gt; のすべての将来の呼び出し引き起こし、インスタンスを &lt;code&gt;call_once&lt;/code&gt; もパニックに。</target>
        </trans-unit>
        <trans-unit id="9a9ae7f6f31f6430eeec94354c414e42d745c712" translate="yes" xml:space="preserve">
          <source>The closure can use captures and its environment to track state across iterations. Depending on how the iterator is used, this may require specifying the &lt;a href=&quot;../keyword.move&quot;&gt;&lt;code&gt;move&lt;/code&gt;&lt;/a&gt; keyword on the closure.</source>
          <target state="translated">クロージャーは、キャプチャとその環境を使用して、反復全体の状態を追跡できます。イテレータの使用方法によっては、クロージャで&lt;a href=&quot;../keyword.move&quot;&gt; &lt;code&gt;move&lt;/code&gt; &lt;/a&gt;キーワードを指定する必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="cbba645c0f92459c3e584dd2aad4e56b6422ddeb" translate="yes" xml:space="preserve">
          <source>The closure can use captures and its environment to track state across iterations. Depending on how the iterator is used, this may require specifying the &lt;code&gt;move&lt;/code&gt; keyword on the closure.</source>
          <target state="translated">クロージャーは、キャプチャーとその環境を使用して、反復全体の状態を追跡できます。イテレーターの使用方法によっては、クロージャーで &lt;code&gt;move&lt;/code&gt; キーワードを指定する必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="8e57e2087c6fad9eaa8a18bdb745b2ddd95bd84c" translate="yes" xml:space="preserve">
          <source>The closure captures the &lt;code&gt;shoe_size&lt;/code&gt; parameter from the environment and compares the value with each shoe&amp;rsquo;s size, keeping only shoes of the size specified. Finally, calling &lt;code&gt;collect&lt;/code&gt; gathers the values returned by the adapted iterator into a vector that&amp;rsquo;s returned by the function.</source>
          <target state="translated">クロージャーは、環境から &lt;code&gt;shoe_size&lt;/code&gt; パラメーターを取り込み、その値を各靴のサイズと比較して、指定されたサイズの靴のみを保持します。最後に、 &lt;code&gt;collect&lt;/code&gt; を呼び出すと、適応イテレータによって返された値が、関数によって返されるベクトルに収集されます。</target>
        </trans-unit>
        <trans-unit id="0112db2feb7312ad3c6512257c24783293514225" translate="yes" xml:space="preserve">
          <source>The closure definition comes after the &lt;code&gt;=&lt;/code&gt; to assign it to the variable &lt;code&gt;expensive_closure&lt;/code&gt;. To define a closure, we start with a pair of vertical pipes (&lt;code&gt;|&lt;/code&gt;), inside which we specify the parameters to the closure; this syntax was chosen because of its similarity to closure definitions in Smalltalk and Ruby. This closure has one parameter named &lt;code&gt;num&lt;/code&gt;: if we had more than one parameter, we would separate them with commas, like &lt;code&gt;|param1, param2|&lt;/code&gt;.</source>
          <target state="translated">クロージャーの定義は、変数 &lt;code&gt;expensive_closure&lt;/code&gt; クロージャーに割り当てるために &lt;code&gt;=&lt;/code&gt; の後に来ます。クロージャを定義するには、1組の垂直パイプ（ &lt;code&gt;|&lt;/code&gt; ）から始め、その中でクロージャへのパラメータを指定します。この構文が選択されたのは、SmalltalkおよびRubyでのクロージャ定義との類似性のためです。このクロージャには &lt;code&gt;num&lt;/code&gt; という名前のパラメータが1つあります。複数のパラメータがある場合は、 &lt;code&gt;|param1, param2|&lt;/code&gt; ようにコンマで区切ります。。</target>
        </trans-unit>
        <trans-unit id="1b467eb6733245bc29dea650b68390c954774c96" translate="yes" xml:space="preserve">
          <source>The closure is allowed to return an I/O error whose OS error code will be communicated back to the parent and returned as an error from when the spawn was requested.</source>
          <target state="translated">クロージャは、OS のエラーコードが親に通信され、スポーンが要求されたときのエラーとして返される I/O エラーを返すことが許されています。</target>
        </trans-unit>
        <trans-unit id="2d07950c5510607459c97a1e9bf4b42e15a155b7" translate="yes" xml:space="preserve">
          <source>The closure must return &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. &lt;code&gt;filter()&lt;/code&gt; creates an iterator which calls this closure on each element. If the closure returns &lt;code&gt;true&lt;/code&gt;, then the element is returned. If the closure returns &lt;code&gt;false&lt;/code&gt;, it will try again, and call the closure on the next element, seeing if it passes the test.</source>
          <target state="translated">クロージャは &lt;code&gt;true&lt;/code&gt; または &lt;code&gt;false&lt;/code&gt; を返す必要があります。 &lt;code&gt;filter()&lt;/code&gt; は、各要素でこのクロージャを呼び出すイテレータを作成します。クロージャが &lt;code&gt;true&lt;/code&gt; を返す場合、要素が返されます。クロージャが &lt;code&gt;false&lt;/code&gt; を返した場合、再試行して、次の要素でクロージャを呼び出し、テストに合格したかどうかを確認します。</target>
        </trans-unit>
        <trans-unit id="0dfbb8ddc807c0ec7e308a6bcf0502df62203387" translate="yes" xml:space="preserve">
          <source>The closure must return an &lt;a href=&quot;../option/enum.option&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;filter_map&lt;/code&gt; creates an iterator which calls this closure on each element. If the closure returns &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some(element)&lt;/code&gt;&lt;/a&gt;, then that element is returned. If the closure returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, it will try again, and call the closure on the next element, seeing if it will return &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">クロージャは&lt;a href=&quot;../option/enum.option&quot;&gt; &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;返す必要があります。 &lt;code&gt;filter_map&lt;/code&gt; は、各要素でこのクロージャを呼び出すイテレータを作成します。クロージャが&lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some(element)&lt;/code&gt; を&lt;/a&gt;返す場合、その要素が返されます。クロージャが&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; を&lt;/a&gt;返した場合、再試行して次の要素のクロージャを呼び出し、&lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some&lt;/code&gt; &lt;/a&gt;を返すかどうかを確認します。</target>
        </trans-unit>
        <trans-unit id="7a4c6af8980cc5834794f8ba584bb6cebd16567c" translate="yes" xml:space="preserve">
          <source>The closure provided is required to adhere to the &lt;a href=&quot;trait.unwindsafe&quot;&gt;&lt;code&gt;UnwindSafe&lt;/code&gt;&lt;/a&gt; trait to ensure that all captured variables are safe to cross this boundary. The purpose of this bound is to encode the concept of &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1236-stabilize-catch-panic.md&quot;&gt;exception safety&lt;/a&gt; in the type system. Most usage of this function should not need to worry about this bound as programs are naturally unwind safe without &lt;code&gt;unsafe&lt;/code&gt; code. If it becomes a problem the &lt;a href=&quot;struct.assertunwindsafe&quot;&gt;&lt;code&gt;AssertUnwindSafe&lt;/code&gt;&lt;/a&gt; wrapper struct can be used to quickly assert that the usage here is indeed unwind safe.</source>
          <target state="translated">提供されるクロージャは、&lt;a href=&quot;trait.unwindsafe&quot;&gt; &lt;code&gt;UnwindSafe&lt;/code&gt; &lt;/a&gt;トレイトに準拠して、キャプチャされたすべての変数がこの境界を越えても安全であることを保証するために必要です。この境界の目的は、型システムの&lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1236-stabilize-catch-panic.md&quot;&gt;例外安全性&lt;/a&gt;の概念をエンコードすることです。プログラムは安全で &lt;code&gt;unsafe&lt;/code&gt; コードなしで自然に巻き戻されるので、この関数のほとんどの使用法はこの境界について心配する必要はありません。これが問題になる場合、&lt;a href=&quot;struct.assertunwindsafe&quot;&gt; &lt;code&gt;AssertUnwindSafe&lt;/code&gt; &lt;/a&gt;ラッパー構造体を使用して、ここでの使用が本当にアンワインドセーフであることをすばやくアサートできます。</target>
        </trans-unit>
        <trans-unit id="1db2515eb35827d3b48808ed11db89506d167098" translate="yes" xml:space="preserve">
          <source>The closure uses &lt;code&gt;v&lt;/code&gt;, so it will capture &lt;code&gt;v&lt;/code&gt; and make it part of the closure&amp;rsquo;s environment. Because &lt;code&gt;thread::spawn&lt;/code&gt; runs this closure in a new thread, we should be able to access &lt;code&gt;v&lt;/code&gt; inside that new thread. But when we compile this example, we get the following error:</source>
          <target state="translated">閉鎖用途は &lt;code&gt;v&lt;/code&gt; それがキャプチャされますので、 &lt;code&gt;v&lt;/code&gt; その閉鎖の環境の一部にします。 &lt;code&gt;thread::spawn&lt;/code&gt; はこのクロージャーを新しいスレッドで実行するので、その新しいスレッド内の &lt;code&gt;v&lt;/code&gt; にアクセスできるはずです。しかし、この例をコンパイルすると、次のエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="d7aca11a6ac0f9ea5173acf1c9757981e77e687c" translate="yes" xml:space="preserve">
          <source>The code associated with each arm is an expression, and the resulting value of the expression in the matching arm is the value that gets returned for the entire &lt;code&gt;match&lt;/code&gt; expression.</source>
          <target state="translated">各アームに関連付けられたコードは式であり、一致するアームの式の結果の値は、 &lt;code&gt;match&lt;/code&gt; 式全体に対して返される値です。</target>
        </trans-unit>
        <trans-unit id="86ec55efa28e5ccc120a1f5241fba708e750dd58" translate="yes" xml:space="preserve">
          <source>The code in Listing 13-17 doesn&amp;rsquo;t do anything; the closure we&amp;rsquo;ve specified never gets called. The warning reminds us why: iterator adaptors are lazy, and we need to consume the iterator here.</source>
          <target state="translated">リスト13-17のコードは何もしません。指定したクロージャーが呼び出されることはありません。警告は、理由を思い出させます。イテレータアダプタが遅延しているため、ここでイテレータを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="27595e3e42c890c6fdee5b82c7f1d2b1399713f0" translate="yes" xml:space="preserve">
          <source>The code in Listing 13-3 has multiple calls to the slow calculation function. The first &lt;code&gt;if&lt;/code&gt; block calls &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; twice, the &lt;code&gt;if&lt;/code&gt; inside the outer &lt;code&gt;else&lt;/code&gt; doesn&amp;rsquo;t call it at all, and the code inside the second &lt;code&gt;else&lt;/code&gt; case calls it once.</source>
          <target state="translated">リスト13-3のコードは遅い計算関数への複数の呼び出しを持っています。最初の &lt;code&gt;if&lt;/code&gt; ブロックの呼び出しは &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; 二回、 &lt;code&gt;if&lt;/code&gt; 、外側の内側に &lt;code&gt;else&lt;/code&gt; すべてでそれを呼び出すことはありません、第二の内部コード &lt;code&gt;else&lt;/code&gt; 場合は、一度それを呼び出します。</target>
        </trans-unit>
        <trans-unit id="984f7b754ab17440aa0c07b718b002aed1594b7a" translate="yes" xml:space="preserve">
          <source>The code in Listing 16-1 not only stops the spawned thread prematurely most of the time due to the main thread ending, but also can&amp;rsquo;t guarantee that the spawned thread will get to run at all. The reason is that there is no guarantee on the order in which threads run!</source>
          <target state="translated">コードリスト16-1のコードは、メインスレッドの終了が原因でほとんどの場合、発生したスレッドを途中で停止するだけでなく、発生したスレッドがまったく実行されることも保証できません。その理由は、スレッドの実行順序が保証されていないためです。</target>
        </trans-unit>
        <trans-unit id="4d5adfd375cd377b4763e2eeee96a84687acf4e5" translate="yes" xml:space="preserve">
          <source>The code in Listing 16-8 compiled and ran, but it didn&amp;rsquo;t clearly show us that two separate threads were talking to each other over the channel. In Listing 16-10 we&amp;rsquo;ve made some modifications that will prove the code in Listing 16-8 is running concurrently: the spawned thread will now send multiple messages and pause for a second between each message.</source>
          <target state="translated">リスト16-8のコードはコンパイルされて実行されましたが、2つの別々のスレッドがチャネルを介して互いに通信していることを明確に示していませんでした。リスト16-10では、リスト16-8のコードが同時に実行されていることを証明するいくつかの変更を加えました。生成されたスレッドは複数のメッセージを送信し、各メッセージの間で1秒間休止します。</target>
        </trans-unit>
        <trans-unit id="9e7e0566bf3de2c83a460b61c17bb70770c4b1c5" translate="yes" xml:space="preserve">
          <source>The code in Listing 18-1 shows a series of checks for several conditions that decide what the background color should be. For this example, we&amp;rsquo;ve created variables with hardcoded values that a real program might receive from user input.</source>
          <target state="translated">コードリスト18-1のコードは、背景色を決定するいくつかの条件の一連のチェックを示しています。この例では、実際のプログラムがユーザー入力から受け取る可能性のあるハードコードされた値を持つ変数を作成しました。</target>
        </trans-unit>
        <trans-unit id="c12405c78a2c0d83f529e2201871e22f52a8474e" translate="yes" xml:space="preserve">
          <source>The code in Listing 18-3 will print the following:</source>
          <target state="translated">リスト18-3のコードは次のように表示されます。</target>
        </trans-unit>
        <trans-unit id="efe51698d475c0b9864955b57e12d5b79c9bbf35" translate="yes" xml:space="preserve">
          <source>The code in Listing 20-14 will compile but doesn&amp;rsquo;t create any threads yet. We&amp;rsquo;ve changed the definition of &lt;code&gt;ThreadPool&lt;/code&gt; to hold a vector of &lt;code&gt;thread::JoinHandle&amp;lt;()&amp;gt;&lt;/code&gt; instances, initialized the vector with a capacity of &lt;code&gt;size&lt;/code&gt;, set up a &lt;code&gt;for&lt;/code&gt; loop that will run some code to create the threads, and returned a &lt;code&gt;ThreadPool&lt;/code&gt; instance containing them.</source>
          <target state="translated">リスト20-14のコードはコンパイルされますが、まだスレッドを作成しません。 &lt;code&gt;ThreadPool&lt;/code&gt; の定義を変更して、 &lt;code&gt;thread::JoinHandle&amp;lt;()&amp;gt;&lt;/code&gt; インスタンスのベクターを保持し、ベクターを &lt;code&gt;size&lt;/code&gt; の容量で初期化し、スレッドを作成するコードを実行する &lt;code&gt;for&lt;/code&gt; ループを設定して、それらを含む &lt;code&gt;ThreadPool&lt;/code&gt; インスタンス。</target>
        </trans-unit>
        <trans-unit id="d3a6f7dff2487d4bcc7b7e0489bef3c4a5207416" translate="yes" xml:space="preserve">
          <source>The code in Listing 20-20 is responding to requests asynchronously through the use of a thread pool, as we intended. We get some warnings about the &lt;code&gt;workers&lt;/code&gt;, &lt;code&gt;id&lt;/code&gt;, and &lt;code&gt;thread&lt;/code&gt; fields that we&amp;rsquo;re not using in a direct way that reminds us we&amp;rsquo;re not cleaning up anything. When we use the less elegant ctrl-c method to halt the main thread, all other threads are stopped immediately as well, even if they&amp;rsquo;re in the middle of serving a request.</source>
          <target state="translated">リスト20-20のコードは、意図したとおり、スレッドプールを使用して非同期的に要求に応答しています。直接使用していない &lt;code&gt;workers&lt;/code&gt; 、 &lt;code&gt;id&lt;/code&gt; 、および &lt;code&gt;thread&lt;/code&gt; フィールドについていくつかの警告が表示され、何もクリーンアップしていないことを思い出させます。あまり洗練されていないctrl-cメソッドを使用してメインスレッドを停止すると、リクエストを処理している最中であっても、他のすべてのスレッドもすぐに停止します。</target>
        </trans-unit>
        <trans-unit id="b9b3fdc249a44ebef0cd41734527cea5bbbbc841" translate="yes" xml:space="preserve">
          <source>The code in Listing 20-21 is responding to requests asynchronously through the use of a thread pool, as we intended. We get some warnings about the &lt;code&gt;workers&lt;/code&gt;, &lt;code&gt;id&lt;/code&gt;, and &lt;code&gt;thread&lt;/code&gt; fields that we&amp;rsquo;re not using in a direct way that reminds us we&amp;rsquo;re not cleaning up anything. When we use the less elegant ctrl-c method to halt the main thread, all other threads are stopped immediately as well, even if they&amp;rsquo;re in the middle of serving a request.</source>
          <target state="translated">リスト20-21のコードは、意図したとおり、スレッドプールを使用して非同期的にリクエストに応答しています。私たちは何もクリーンアップしていないことを思い出させる直接的な方法で使用していない、 &lt;code&gt;workers&lt;/code&gt; 、 &lt;code&gt;id&lt;/code&gt; 、および &lt;code&gt;thread&lt;/code&gt; フィールドに関するいくつかの警告を受け取ります。あまり洗練されていないctrl-cメソッドを使用してメインスレッドを停止すると、他のすべてのスレッドも、要求を処理している途中であっても、すぐに停止されます。</target>
        </trans-unit>
        <trans-unit id="af00e0657ebb48c72ab0e8023da460e28c0f23c3" translate="yes" xml:space="preserve">
          <source>The code in Listing 5-7 also creates an instance in &lt;code&gt;user2&lt;/code&gt; that has a different value for &lt;code&gt;email&lt;/code&gt; and &lt;code&gt;username&lt;/code&gt; but has the same values for the &lt;code&gt;active&lt;/code&gt; and &lt;code&gt;sign_in_count&lt;/code&gt; fields from &lt;code&gt;user1&lt;/code&gt;.</source>
          <target state="translated">リスト5-7のコードはまた、インスタンスを作成し &lt;code&gt;user2&lt;/code&gt; のために異なる値持ち &lt;code&gt;email&lt;/code&gt; と &lt;code&gt;username&lt;/code&gt; しかし同じ値がある &lt;code&gt;active&lt;/code&gt; と &lt;code&gt;sign_in_count&lt;/code&gt; からフィールド &lt;code&gt;user1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0531b3f098e465468fd76e222f809f69ed8edfae" translate="yes" xml:space="preserve">
          <source>The code in Listing 8-7 might look like it should work: why should a reference to the first element care about what changes at the end of the vector? This error is due to the way vectors work: adding a new element onto the end of the vector might require allocating new memory and copying the old elements to the new space, if there isn&amp;rsquo;t enough room to put all the elements next to each other where the vector currently is. In that case, the reference to the first element would be pointing to deallocated memory. The borrowing rules prevent programs from ending up in that situation.</source>
          <target state="translated">リスト8-7のコードは機能するように見えるかもしれません：なぜ最初の要素への参照はベクターの終わりで何が変わるのかを気にする必要があるのですか？このエラーはベクターの動作によるものです。ベクターの最後に新しい要素を追加するには、すべての要素をそれぞれの隣に配置するための十分なスペースがない場合、新しいメモリを割り当て、古い要素を新しいスペースにコピーする必要がありますベクターが現在あるその他の場所。その場合、最初の要素への参照は、割り当て解除されたメモリを指しています。借入ルールは、プログラムがそのような状況になることを防ぎます。</target>
        </trans-unit>
        <trans-unit id="94cc2f51904c3f9ddd0cfd3520b820c4eb301ad4" translate="yes" xml:space="preserve">
          <source>The code in Listing 9-4 will &lt;code&gt;panic!&lt;/code&gt; no matter why &lt;code&gt;File::open&lt;/code&gt; failed. What we want to do instead is take different actions for different failure reasons: if &lt;code&gt;File::open&lt;/code&gt; failed because the file doesn&amp;rsquo;t exist, we want to create the file and return the handle to the new file. If &lt;code&gt;File::open&lt;/code&gt; failed for any other reason&amp;mdash;for example, because we didn&amp;rsquo;t have permission to open the file&amp;mdash;we still want the code to &lt;code&gt;panic!&lt;/code&gt; in the same way as it did in Listing 9-4. Look at Listing 9-5, which adds an inner &lt;code&gt;match&lt;/code&gt; expression.</source>
          <target state="translated">リスト9-4のコードは &lt;code&gt;panic!&lt;/code&gt; なぜ &lt;code&gt;File::open&lt;/code&gt; 失敗したかは関係ありません。代わりに、さまざまな失敗の理由でさまざまなアクションを実行する必要があります。ファイルが存在しないために &lt;code&gt;File::open&lt;/code&gt; 失敗した場合は、ファイルを作成し、ハンドルを新しいファイルに返します。 &lt;code&gt;File::open&lt;/code&gt; が他の理由で失敗した場合（たとえば、ファイルを開く権限がなかったため）でも、コードに &lt;code&gt;panic!&lt;/code&gt; リスト9-4で行ったのと同じ方法で。内部 &lt;code&gt;match&lt;/code&gt; 式を追加するリスト9-5を見てください。</target>
        </trans-unit>
        <trans-unit id="e95fa13e369d6a99c35a00c2091e07ffadc180a6" translate="yes" xml:space="preserve">
          <source>The code is trying to pass &lt;code&gt;receiver&lt;/code&gt; to multiple &lt;code&gt;Worker&lt;/code&gt; instances. This won&amp;rsquo;t work, as you&amp;rsquo;ll recall from Chapter 16: the channel implementation that Rust provides is multiple &lt;em&gt;producer&lt;/em&gt;, single &lt;em&gt;consumer&lt;/em&gt;. This means we can&amp;rsquo;t just clone the consuming end of the channel to fix this code. Even if we could, that is not the technique we would want to use; instead, we want to distribute the jobs across threads by sharing the single &lt;code&gt;receiver&lt;/code&gt; among all the workers.</source>
          <target state="translated">コードは &lt;code&gt;receiver&lt;/code&gt; を複数の &lt;code&gt;Worker&lt;/code&gt; インスタンスに渡そうとしています。第16章で思い出すように、これは機能しません。Rustが提供するチャネル実装は、複数の&lt;em&gt;プロデューサー&lt;/em&gt;、単一の&lt;em&gt;コンシューマー&lt;/em&gt;です。つまり、このコードを修正するために、チャネルの使用側を複製するだけでは不十分です。たとえできたとしても、それは私たちが使いたいと思う手法ではありません。代わりに、すべてのワーカー間で単一の &lt;code&gt;receiver&lt;/code&gt; 共有することにより、スレッド間でジョブを分散させます。</target>
        </trans-unit>
        <trans-unit id="404cdeaf9f9f5734a0b6eb5da98e14aed6b8934d" translate="yes" xml:space="preserve">
          <source>The code refers to a trait that is not in scope.</source>
          <target state="translated">コードは範囲外の形質を指しています。</target>
        </trans-unit>
        <trans-unit id="f585d5dc0ef34cc30960f293fe10c97e69068fe3" translate="yes" xml:space="preserve">
          <source>The code that calls this code will then handle getting either an &lt;code&gt;Ok&lt;/code&gt; value that contains a username or an &lt;code&gt;Err&lt;/code&gt; value that contains an &lt;code&gt;io::Error&lt;/code&gt;. We don&amp;rsquo;t know what the calling code will do with those values. If the calling code gets an &lt;code&gt;Err&lt;/code&gt; value, it could call &lt;code&gt;panic!&lt;/code&gt; and crash the program, use a default username, or look up the username from somewhere other than a file, for example. We don&amp;rsquo;t have enough information on what the calling code is actually trying to do, so we propagate all the success or error information upward for it to handle appropriately.</source>
          <target state="translated">このコードを呼び出すコードは、ユーザー名を含む &lt;code&gt;Ok&lt;/code&gt; 値または &lt;code&gt;io::Error&lt;/code&gt; を含む &lt;code&gt;Err&lt;/code&gt; 値の取得を処理します。呼び出し元のコードがこれらの値で何を行うかはわかりません。呼び出しコードが &lt;code&gt;Err&lt;/code&gt; 値を取得すると、 &lt;code&gt;panic!&lt;/code&gt; 呼び出す可能性があります。たとえば、プログラムをクラッシュさせたり、デフォルトのユーザー名を使用したり、ファイル以外の場所からユーザー名を検索したりします。呼び出し元のコードが実際に何を実行しようとしているのかに関する十分な情報がないため、成功またはエラー情報をすべて上に伝播して、適切に処理します。</target>
        </trans-unit>
        <trans-unit id="cfac4f190729188f4689af6ae5b0042be7b9afad" translate="yes" xml:space="preserve">
          <source>The collection may reserve more space to avoid frequent reallocations.</source>
          <target state="translated">コレクションは頻繁な再割り当てを避けるために、より多くのスペースを確保することができます。</target>
        </trans-unit>
        <trans-unit id="a921d34f1378e463d6297235d9b237b6a37c1373" translate="yes" xml:space="preserve">
          <source>The comma following &lt;code&gt;$()&lt;/code&gt; indicates that a literal comma separator character could optionally appear after the code that matches the code in &lt;code&gt;$()&lt;/code&gt;. The &lt;code&gt;*&lt;/code&gt; specifies that the pattern matches zero or more of whatever precedes the &lt;code&gt;*&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$()&lt;/code&gt; に続くコンマは、リテラルのコンマ区切り文字が &lt;code&gt;$()&lt;/code&gt; のコードと一致するコードの後に​​オプションで表示される可能性があることを示します。 &lt;code&gt;*&lt;/code&gt; パターンが先行し何のゼロ個以上の一致するように指定します &lt;code&gt;*&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="1bacb24582ff767b21e31f4cc1ad3d6012f25a0b" translate="yes" xml:space="preserve">
          <source>The command downloads a script and starts the installation of the &lt;code&gt;rustup&lt;/code&gt; tool, which installs the latest stable version of Rust. You might be prompted for your password. If the install is successful, the following line will appear:</source>
          <target state="translated">このコマンドはスクリプトをダウンロードし、 &lt;code&gt;rustup&lt;/code&gt; ツールのインストールを開始します。これにより、Rustの最新の安定したバージョンがインストールされます。パスワードの入力を求められる場合があります。インストールが成功すると、次の行が表示されます。</target>
        </trans-unit>
        <trans-unit id="73b43b32097905758197f28a5b18a2fd54ae6279" translate="yes" xml:space="preserve">
          <source>The common part of these two paths is &lt;code&gt;std::io&lt;/code&gt;, and that&amp;rsquo;s the complete first path. To merge these two paths into one &lt;code&gt;use&lt;/code&gt; statement, we can use &lt;code&gt;self&lt;/code&gt; in the nested path, as shown in Listing 7-20.</source>
          <target state="translated">これら2つのパスの共通部分は &lt;code&gt;std::io&lt;/code&gt; であり、これが完全な最初のパスです。これらの2つのパスを1つの &lt;code&gt;use&lt;/code&gt; ステートメントにマージするには、リスト7-20に示すように、ネストされたパスで &lt;code&gt;self&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="3e8778a56f7c16d517be41bfd502f5b861a15290" translate="yes" xml:space="preserve">
          <source>The comparator function must define a total ordering for the elements in the slice. If the ordering is not total, the order of the elements is unspecified. An order is a total order if it is (for all &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;):</source>
          <target state="translated">コンパレーター関数は、スライス内の要素の全体的な順序を定義する必要があります。順序が合計でない場合、要素の順序は指定されていません。注文は、それが（ &lt;code&gt;a&lt;/code&gt; 、 &lt;code&gt;b&lt;/code&gt; 、および &lt;code&gt;c&lt;/code&gt; のすべてに対して）である場合、合計注文です。</target>
        </trans-unit>
        <trans-unit id="aebc23a2aec802159973c4b13320302322bbb426" translate="yes" xml:space="preserve">
          <source>The comparator function must define a total ordering for the elements in the slice. If the ordering is not total, the order of the elements is unspecified. An order is a total order if it is (for all a, b and c):</source>
          <target state="translated">コンパレータ関数は、スライス内の要素の合計順序を定義する必要があります。順序が合計でない場合、要素の順序は指定されません。次数は、(すべてのa,b,cに対して)であれば合計次数です。</target>
        </trans-unit>
        <trans-unit id="25646f45d8bc733d7759e265f95a900ae5f85f26" translate="yes" xml:space="preserve">
          <source>The comparator function should implement an order consistent with the sort order of the underlying &lt;code&gt;VecDeque&lt;/code&gt;, returning an order code that indicates whether its argument is &lt;code&gt;Less&lt;/code&gt;, &lt;code&gt;Equal&lt;/code&gt; or &lt;code&gt;Greater&lt;/code&gt; than the desired target.</source>
          <target state="translated">比較関数は、下のソート順と一致する順序実装する必要 &lt;code&gt;VecDeque&lt;/code&gt; 引数があるかどうかを示すためのコード戻り、 &lt;code&gt;Less&lt;/code&gt; 、 &lt;code&gt;Equal&lt;/code&gt; 又は &lt;code&gt;Greater&lt;/code&gt; 所望の標的よりもあります。</target>
        </trans-unit>
        <trans-unit id="92ccf3fc61c0a63453fa6ca42d0beca2274f875f" translate="yes" xml:space="preserve">
          <source>The comparator function should implement an order consistent with the sort order of the underlying slice, returning an order code that indicates whether its argument is &lt;code&gt;Less&lt;/code&gt;, &lt;code&gt;Equal&lt;/code&gt; or &lt;code&gt;Greater&lt;/code&gt; the desired target.</source>
          <target state="translated">コンパレーター関数は、基になるスライスの並べ替え順序と一致する順序を実装し、その引数が目的のターゲット &lt;code&gt;Less&lt;/code&gt; も &lt;code&gt;Equal&lt;/code&gt; か、等しいか、 &lt;code&gt;Greater&lt;/code&gt; かを示す順序コードを返します。</target>
        </trans-unit>
        <trans-unit id="45e688bbffc9733765a7b6aca03992e2d5e377a5" translate="yes" xml:space="preserve">
          <source>The comparison must satisfy, for all &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;:</source>
          <target state="translated">比較は、すべての &lt;code&gt;a&lt;/code&gt; 、 &lt;code&gt;b&lt;/code&gt; および &lt;code&gt;c&lt;/code&gt; について満たす必要があります。</target>
        </trans-unit>
        <trans-unit id="0c2765074489dd525efeb165a25dbc97454a652e" translate="yes" xml:space="preserve">
          <source>The compilation didn&amp;rsquo;t produce any errors, but the program resulted in a &lt;em&gt;runtime&lt;/em&gt; error and didn&amp;rsquo;t exit successfully. When you attempt to access an element using indexing, Rust will check that the index you&amp;rsquo;ve specified is less than the array length. If the index is greater than or equal to the array length, Rust will panic.</source>
          <target state="translated">コンパイルはエラーを生成しませんでしたが、プログラムは&lt;em&gt;実行時&lt;/em&gt;エラーとなり、正常に終了しませんでした。インデックスを使用して要素にアクセスしようとすると、Rustは指定したインデックスが配列の長さよりも短いことを確認します。インデックスが配列の長さ以上の場合、Rustはパニックになります。</target>
        </trans-unit>
        <trans-unit id="0a0cf1febd61e4c4aeb0165c7c721394953162c8" translate="yes" xml:space="preserve">
          <source>The compilation model centers on artifacts called &lt;em&gt;crates&lt;/em&gt;. Each compilation processes a single crate in source form, and if successful, produces a single crate in binary form: either an executable or some sort of library.&lt;sup&gt;&lt;a href=&quot;#cratesourcefile&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">コンパイルモデルは、&lt;em&gt;クレート&lt;/em&gt;と呼ばれるアーティファクトを中心としています。各コンパイルは、ソース形式の単一のクレートを処理し、成功した場合は、実行可能ファイルまたはある種のライブラリのいずれかのバイナリ形式の単一のクレートを生成します。&lt;sup&gt;&lt;a href=&quot;#cratesourcefile&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="25f0592827e30de97cacdd81a110584696dcea70" translate="yes" xml:space="preserve">
          <source>The compilation model centers on artifacts called &lt;em&gt;crates&lt;/em&gt;. Each compilation processes a single crate in source form, and if successful, produces a single crate in binary form: either an executable or some sort of library.&lt;sup&gt;&lt;a href=&quot;crates-and-source-files#cratesourcefile&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">コンパイルモデルは、&lt;em&gt;クレート&lt;/em&gt;と呼ばれるアーティファクトを中心としています。各コンパイルは、ソース形式の単一のクレートを処理し、成功した場合は、バイナリ形式の単一のクレート（実行可能ファイルまたは何らかのライブラリ）を生成します。&lt;sup&gt;&lt;a href=&quot;crates-and-source-files#cratesourcefile&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="90596055b20c856dc417525ea133e8b1049b15fa" translate="yes" xml:space="preserve">
          <source>The compiler and standard library generally tries to ensure allocations never reach a size where an offset is a concern. For instance, &lt;code&gt;Vec&lt;/code&gt; and &lt;code&gt;Box&lt;/code&gt; ensure they never allocate more than &lt;code&gt;isize::MAX&lt;/code&gt; bytes, so &lt;code&gt;vec.as_ptr().add(vec.len()).sub(vec.len())&lt;/code&gt; is always safe.</source>
          <target state="translated">コンパイラと標準ライブラリは通常、オフセットが問題となるサイズに割り当てが到達しないようにします。たとえば、 &lt;code&gt;Vec&lt;/code&gt; と &lt;code&gt;Box&lt;/code&gt; は &lt;code&gt;isize::MAX&lt;/code&gt; バイトを超えて割り当てないことを保証するため、 &lt;code&gt;vec.as_ptr().add(vec.len()).sub(vec.len())&lt;/code&gt; は常に安全です。</target>
        </trans-unit>
        <trans-unit id="59cbb1cc8a088f98671593c9041c2587a34ab70d" translate="yes" xml:space="preserve">
          <source>The compiler and standard library generally tries to ensure allocations never reach a size where an offset is a concern. For instance, &lt;code&gt;Vec&lt;/code&gt; and &lt;code&gt;Box&lt;/code&gt; ensure they never allocate more than &lt;code&gt;isize::MAX&lt;/code&gt; bytes, so &lt;code&gt;vec.as_ptr().add(vec.len())&lt;/code&gt; is always safe.</source>
          <target state="translated">コンパイラと標準ライブラリは通常、オフセットが問題となるサイズに割り当てが到達しないようにします。たとえば、 &lt;code&gt;Vec&lt;/code&gt; と &lt;code&gt;Box&lt;/code&gt; は &lt;code&gt;isize::MAX&lt;/code&gt; バイトを超えて割り当てないことを保証するため、 &lt;code&gt;vec.as_ptr().add(vec.len())&lt;/code&gt; は常に安全です。</target>
        </trans-unit>
        <trans-unit id="5647f6303a746120d1bc013678162600f20688f8" translate="yes" xml:space="preserve">
          <source>The compiler and standard library generally try to ensure allocations never reach a size where an offset is a concern. For instance, &lt;code&gt;Vec&lt;/code&gt; and &lt;code&gt;Box&lt;/code&gt; ensure they never allocate more than &lt;code&gt;isize::MAX&lt;/code&gt; bytes, so &lt;code&gt;ptr_into_vec.offset_from(vec.as_ptr())&lt;/code&gt; is always safe.</source>
          <target state="translated">コンパイラと標準ライブラリは通常、オフセットが問題となるサイズに割り当てが到達しないようにします。たとえば、 &lt;code&gt;Vec&lt;/code&gt; と &lt;code&gt;Box&lt;/code&gt; は &lt;code&gt;isize::MAX&lt;/code&gt; バイトを超えて割り当てないことを保証するため、 &lt;code&gt;ptr_into_vec.offset_from(vec.as_ptr())&lt;/code&gt; は常に安全です。</target>
        </trans-unit>
        <trans-unit id="d1adc5111740e7a8d58bceec3601a6e3d4ef92d4" translate="yes" xml:space="preserve">
          <source>The compiler could not infer a type and asked for a type annotation.</source>
          <target state="translated">コンパイラは型を推論できず、型アノテーションを要求しました。</target>
        </trans-unit>
        <trans-unit id="030993899960155dfaeaf56819f76523f90d8c36" translate="yes" xml:space="preserve">
          <source>The compiler currently implements no method of hinting what format a library should be linked with. When dynamically linking, the compiler will attempt to maximize dynamic dependencies while still allowing some dependencies to be linked in via an rlib.</source>
          <target state="translated">コンパイラは現在のところ、ライブラリがどの形式でリンクされるべきかを示唆する方法を実装していません。動的にリンクする場合、コンパイラは動的な依存関係を最大化しつつ、いくつかの依存関係を rlib 経由でリンクできるようにします。</target>
        </trans-unit>
        <trans-unit id="fe8298a5d8326c70ef926aa1826e7331454f6a26" translate="yes" xml:space="preserve">
          <source>The compiler doesn't know what method to call because more than one method has the same prototype.</source>
          <target state="translated">複数のメソッドが同じプロトタイプを持っているため、コンパイラはどのメソッドを呼べばよいかわかりません。</target>
        </trans-unit>
        <trans-unit id="1821ca1d85d61b39565f6e9976cc18b3afce261c" translate="yes" xml:space="preserve">
          <source>The compiler doesn't know what method to call because more than one method has the same prototype. Erroneous code example:</source>
          <target state="translated">複数のメソッドが同じプロトタイプを持っているため、コンパイラはどのメソッドを呼び出すべきかわかりません。誤ったコード例です。</target>
        </trans-unit>
        <trans-unit id="1be1361775707ec1fbdcf50e883b1d7b1bdb5f0d" translate="yes" xml:space="preserve">
          <source>The compiler error is as follows:</source>
          <target state="translated">コンパイラのエラーは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="b5655bf28c5aee029b50ebff36ecbfc08852001c" translate="yes" xml:space="preserve">
          <source>The compiler even reminds us that this only works with closures!</source>
          <target state="translated">コンパイラは、これはクロージャでしか動作しないことを思い出させてくれます!</target>
        </trans-unit>
        <trans-unit id="b0cba35bf39af6cdfd6b56d4dbe10dbaf77ed516" translate="yes" xml:space="preserve">
          <source>The compiler found a function whose body contains a &lt;code&gt;return;&lt;/code&gt; statement but whose return type is not &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">コンパイラーは、本体に &lt;code&gt;return;&lt;/code&gt; が含まれている関数を見つけました。ステートメントですが、戻り値の型が &lt;code&gt;()&lt;/code&gt; ではありません。</target>
        </trans-unit>
        <trans-unit id="b08f603159dc0eecd0f21f28c07166cefeb69847" translate="yes" xml:space="preserve">
          <source>The compiler found a function whose body contains a &lt;code&gt;return;&lt;/code&gt; statement but whose return type is not &lt;code&gt;()&lt;/code&gt;. An example of this is:</source>
          <target state="translated">コンパイラーは、本体に &lt;code&gt;return;&lt;/code&gt; が含まれている関数を検出しました。ステートメントですが、戻り値の型は &lt;code&gt;()&lt;/code&gt; ではありません。この例は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="3e4713e81e1fe06044671ee83362a3b9a0f5ad86" translate="yes" xml:space="preserve">
          <source>The compiler gives us this error:</source>
          <target state="translated">コンパイラはこのようなエラーを出します。</target>
        </trans-unit>
        <trans-unit id="b01feef52238a9b5f1daf51373c75b238f421fe8" translate="yes" xml:space="preserve">
          <source>The compiler is allowed to perform any combination of these optimizations, as long as the final optimized code, when executed, produces the same results as the one without optimizations.</source>
          <target state="translated">コンパイラは、最終的に最適化されたコードを実行したときに、最適化されていないコードと同じ結果が得られる限り、これらの最適化を任意に組み合わせて実行することができます。</target>
        </trans-unit>
        <trans-unit id="ec5c1119f8e1ac4ec1c89254831939480c03edd7" translate="yes" xml:space="preserve">
          <source>The compiler may allow attributes for external tools where each tool resides in its own namespace. The first segment of the attribute path is the name of the tool, with one or more additional segments whose interpretation is up to the tool.</source>
          <target state="translated">コンパイラは、各ツールが独自の名前空間に存在する外部ツールの属性を許可することができます。属性パスの最初のセグメントはツールの名前であり、1つ以上のセグメントが追加され、その解釈はツールに任されます。</target>
        </trans-unit>
        <trans-unit id="a7720aa4345b4147bab4d25831f37466e57d1fcc" translate="yes" xml:space="preserve">
          <source>The compiler prefers to capture a closed-over variable by immutable borrow, followed by unique immutable borrow (see below), by mutable borrow, and finally by move. It will pick the first choice of these that allows the closure to compile. The choice is made only with regards to the contents of the closure expression; the compiler does not take into account surrounding code, such as the lifetimes of involved variables.</source>
          <target state="translated">コンパイラは、クローズドオーバー変数をイミュータブル・ロウイング、ユニーク・イミュータブル・ロウイング(後述)、ミューータブル・ロウイング、そして最後にムーブで捕捉することを好みます。コンパイラは、これらの中から最初に選択したものを選択して、クロージャをコンパイルします。この選択はクロージャ式の内容に関してのみ行われ、コンパイラは関与する変数の寿命などの周囲のコードを考慮しません。</target>
        </trans-unit>
        <trans-unit id="5212bd9f30887e16d9c074bb9450838a12a0be2d" translate="yes" xml:space="preserve">
          <source>The compiler shouldn't change the relative order or number of volatile memory operations. However, volatile memory operations on zero-sized types (e.g., if a zero-sized type is passed to &lt;code&gt;read_volatile&lt;/code&gt;) are noops and may be ignored.</source>
          <target state="translated">コンパイラは、揮発性メモリ操作の相対的な順序や数を変更しないでください。ただし、サイズがゼロのタイプの揮発性メモリ操作（たとえば、サイズがゼロのタイプが &lt;code&gt;read_volatile&lt;/code&gt; に渡された場合）は何もしないので無視できます。</target>
        </trans-unit>
        <trans-unit id="955e9c25a8bb7d2a1fb8b16fdbf5d5e19b107461" translate="yes" xml:space="preserve">
          <source>The compiler shouldn't change the relative order or number of volatile memory operations. However, volatile memory operations on zero-sized types (e.g., if a zero-sized type is passed to &lt;code&gt;write_volatile&lt;/code&gt;) are noops and may be ignored.</source>
          <target state="translated">コンパイラは、揮発性メモリ操作の相対的な順序や数を変更しないでください。ただし、サイズがゼロのタイプの揮発性メモリ操作（たとえば、サイズがゼロのタイプが &lt;code&gt;write_volatile&lt;/code&gt; に渡された場合）は何もしないので無視できます。</target>
        </trans-unit>
        <trans-unit id="d348a40c0a7a1bd0e6bae37a48c29f90fc773ea5" translate="yes" xml:space="preserve">
          <source>The compiler supports various methods to link crates together both statically and dynamically. This section will explore the various methods to link crates together, and more information about native libraries can be found in the &lt;a href=&quot;https://doc.rust-lang.org/book/ffi.html&quot;&gt;FFI section of the book&lt;/a&gt;.</source>
          <target state="translated">コンパイラーは、静的と動的の両方でクレートをリンクするさまざまな方法をサポートしています。このセクションでは、クレートをリンクするさまざまな方法について説明します。ネイティブライブラリの詳細について&lt;a href=&quot;https://doc.rust-lang.org/book/ffi.html&quot;&gt;は、本のFFIセクションを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="e6a5c185d40ba65d2c0863bc15ff86b37643834d" translate="yes" xml:space="preserve">
          <source>The compiler then knows to not make any incorrect assumptions or optimizations on this code.</source>
          <target state="translated">コンパイラは、このコードで間違った仮定や最適化を行わないようにします。</target>
        </trans-unit>
        <trans-unit id="4f49b0710fee284944c10fc8dd575c9f675cc65d" translate="yes" xml:space="preserve">
          <source>The compiler uses three rules to figure out what lifetimes references have when there aren&amp;rsquo;t explicit annotations. The first rule applies to input lifetimes, and the second and third rules apply to output lifetimes. If the compiler gets to the end of the three rules and there are still references for which it can&amp;rsquo;t figure out lifetimes, the compiler will stop with an error. These rules apply to &lt;code&gt;fn&lt;/code&gt; definitions as well as &lt;code&gt;impl&lt;/code&gt; blocks.</source>
          <target state="translated">コンパイラは3つのルールを使用して、明示的な注釈がない場合の参照のライフタイムを把握します。最初のルールは入力ライフタイムに適用され、2番目と3番目のルールは出力ライフタイムに適用されます。コンパイラーが3つのルールの終わりに達しても、存続期間を計算できない参照がまだある場合、コンパイラーはエラーで停止します。これらのルールは、 &lt;code&gt;fn&lt;/code&gt; 定義と &lt;code&gt;impl&lt;/code&gt; ブロックに適用されます。</target>
        </trans-unit>
        <trans-unit id="433b36c96c38bd66008e924fa1864ced83fcb794" translate="yes" xml:space="preserve">
          <source>The compiler will complain that it needs lifetime specifiers:</source>
          <target state="translated">コンパイラはライフタイム指定子が必要だと文句を言います。</target>
        </trans-unit>
        <trans-unit id="572859abb18057fb674dd21429d06414b40c8275" translate="yes" xml:space="preserve">
          <source>The compiler will determine which of the &lt;a href=&quot;../types/closure#call-traits-and-coercions&quot;&gt;closure traits&lt;/a&gt; the closure's type will implement by how it acts on its captured variables. The closure will also implement &lt;a href=&quot;../special-types-and-traits#send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt; and/or &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; if all of its captured types do. These traits allow functions to accept closures using generics, even though the exact types can't be named.</source>
          <target state="translated">コンパイラーは、キャプチャーされた変数にどのように作用するかによって、クロージャーのタイプがどの&lt;a href=&quot;../types/closure#call-traits-and-coercions&quot;&gt;クロージャー特性&lt;/a&gt;を実装するかを決定します。クロージャーは、キャプチャーされたすべてのタイプがそうである場合、&lt;a href=&quot;../special-types-and-traits#send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt;および/または&lt;a href=&quot;../special-types-and-traits#sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt;も実装します。これらの特性により、正確な型に名前を付けることができない場合でも、関数はジェネリックを使用してクロージャを受け入れることができます。</target>
        </trans-unit>
        <trans-unit id="948f1a92a83b2e1e3378ae6b818bd73449ba504b" translate="yes" xml:space="preserve">
          <source>The compiler will indicate when you&amp;rsquo;re trying to do something that violates the rules of object safety in regard to trait objects. For example, let&amp;rsquo;s say we tried to implement the &lt;code&gt;Screen&lt;/code&gt; struct in Listing 17-4 to hold types that implement the &lt;code&gt;Clone&lt;/code&gt; trait instead of the &lt;code&gt;Draw&lt;/code&gt; trait, like this:</source>
          <target state="translated">コンパイラーは、トレイトオブジェクトに関してオブジェクトの安全性のルールに違反することを実行しようとしていることを示します。たとえば、次のように、 &lt;code&gt;Draw&lt;/code&gt; トレイトの代わりに &lt;code&gt;Clone&lt;/code&gt; トレイトを実装する型を保持するために、リスト17-4の &lt;code&gt;Screen&lt;/code&gt; 構造体を実装しようとしたとします。</target>
        </trans-unit>
        <trans-unit id="0946476a608603480a8c85b783bae37331306e67" translate="yes" xml:space="preserve">
          <source>The compiler, in general, assumes that a variable is properly initialized according to the requirements of the variable's type. For example, a variable of reference type must be aligned and non-NULL. This is an invariant that must &lt;em&gt;always&lt;/em&gt; be upheld, even in unsafe code. As a consequence, zero-initializing a variable of reference type causes instantaneous &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;undefined behavior&lt;/a&gt;, no matter whether that reference ever gets used to access memory:</source>
          <target state="translated">一般に、コンパイラは、変数の型の要件に従って変数が適切に初期化されることを前提としています。たとえば、参照型の変数は整列され、NULL以外である必要があります。これは不変条件であり、安全でないコードであっても&lt;em&gt;常に&lt;/em&gt;維持する必要&lt;em&gt;が&lt;/em&gt;あります。結果として、参照型の変数をゼロで初期化すると、その参照がメモリへのアクセスに使用されるかどうかに関係なく、瞬時に&lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;未定義の動作&lt;/a&gt;が発生します。</target>
        </trans-unit>
        <trans-unit id="a84c7a7769bfd766452d6377b59bc8d2e574c64c" translate="yes" xml:space="preserve">
          <source>The compiler, in general, assumes that variables are properly initialized at their respective type. For example, a variable of reference type must be aligned and non-NULL. This is an invariant that must &lt;em&gt;always&lt;/em&gt; be upheld, even in unsafe code. As a consequence, zero-initializing a variable of reference type causes instantaneous &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;undefined behavior&lt;/a&gt;, no matter whether that reference ever gets used to access memory:</source>
          <target state="translated">一般に、コンパイラーは、変数がそれぞれの型で適切に初期化されていることを前提としています。たとえば、参照型の変数は整列され、NULL以外である必要があります。これは、安全ではないコードであっても&lt;em&gt;常に&lt;/em&gt;守らなければならない不変条件です。結果として、参照型の変数をゼロ初期化すると、その参照がメモリへのアクセスに使用されるかどうかに関係なく、&lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;定義されていない動作&lt;/a&gt;が瞬時に発生します。</target>
        </trans-unit>
        <trans-unit id="4ed049edf6523bee71aa6c2cc8dac47d3acb83f3" translate="yes" xml:space="preserve">
          <source>The computed offset cannot exceed &lt;code&gt;isize::MAX&lt;/code&gt;&lt;strong&gt;bytes&lt;/strong&gt;.</source>
          <target state="translated">計算されたオフセットは &lt;code&gt;isize::MAX&lt;/code&gt; &lt;strong&gt;バイトを&lt;/strong&gt;超えることはできません。</target>
        </trans-unit>
        <trans-unit id="4f78f76fdf78ce465bd63ef1c725533fd764ba85" translate="yes" xml:space="preserve">
          <source>The computed offset, &lt;strong&gt;in bytes&lt;/strong&gt;, cannot overflow an &lt;code&gt;isize&lt;/code&gt;.</source>
          <target state="translated">計算されたオフセット（&lt;strong&gt;バイト単位&lt;/strong&gt;）は &lt;code&gt;isize&lt;/code&gt; をオーバーフローできません。</target>
        </trans-unit>
        <trans-unit id="63f5ab3561e8fa530abb7afbb885243679cbd27d" translate="yes" xml:space="preserve">
          <source>The concatenation &amp;alpha; &amp;beta; &amp;gamma; &amp;delta; is a parseable Rust program.</source>
          <target state="translated">連結&amp;alpha;&amp;beta;&amp;gamma;&amp;delta;は解析可能なRustプログラムです。</target>
        </trans-unit>
        <trans-unit id="026ad0f5294d67f94938651fe3bfaacf62c15a89" translate="yes" xml:space="preserve">
          <source>The concept of lifetimes is somewhat different from tools in other programming languages, arguably making lifetimes Rust&amp;rsquo;s most distinctive feature. Although we won&amp;rsquo;t cover lifetimes in their entirety in this chapter, we&amp;rsquo;ll discuss common ways you might encounter lifetime syntax so you can become familiar with the concepts.</source>
          <target state="translated">ライフタイムの概念は他のプログラミング言語のツールとは多少異なり、おそらくライフタイムをRustの最も特徴的な機能にしています。この章ではライフタイム全体を取り上げませんが、コンセプトに慣れるために、ライフタイム構文に遭遇する一般的な方法について説明します。</target>
        </trans-unit>
        <trans-unit id="bf8b3cea5648a2c56269d845203de953f7dc58d3" translate="yes" xml:space="preserve">
          <source>The concepts of ownership, borrowing, and slices ensure memory safety in Rust programs at compile time. The Rust language gives you control over your memory usage in the same way as other systems programming languages, but having the owner of data automatically clean up that data when the owner goes out of scope means you don&amp;rsquo;t have to write and debug extra code to get this control.</source>
          <target state="translated">所有権、借用、およびスライスの概念は、コンパイル時にRustプログラムのメモリの安全性を保証します。Rust言語を使用すると、他のシステムプログラミング言語と同じようにメモリ使用量を制御できますが、データの所有者がスコープ外に出たときにデータの所有者が自動的にクリーンアップするため、追加のコードを記述してデバッグする必要がありません。このコントロールを取得します。</target>
        </trans-unit>
        <trans-unit id="5484608e7530a94c46507f1fbbbe29684e230d84" translate="yes" xml:space="preserve">
          <source>The condition can use variables created in the pattern. Listing 18-26 shows a &lt;code&gt;match&lt;/code&gt; where the first arm has the pattern &lt;code&gt;Some(x)&lt;/code&gt; and also has a match guard of &lt;code&gt;if x &amp;lt; 5&lt;/code&gt;.</source>
          <target state="translated">条件には、パターンで作成された変数を使用できます。18-26番組リスト &lt;code&gt;match&lt;/code&gt; 最初アームパターン有する &lt;code&gt;Some(x)&lt;/code&gt; 、またの一致ガード有する &lt;code&gt;if x &amp;lt; 5&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c47359692fd118dbc5a64f61c4a95c135750d6d3" translate="yes" xml:space="preserve">
          <source>The condition expression of an &lt;code&gt;if&lt;/code&gt; or &lt;code&gt;while&lt;/code&gt; expression, or a &lt;code&gt;match&lt;/code&gt; guard.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; または &lt;code&gt;while&lt;/code&gt; 式の条件式、または &lt;code&gt;match&lt;/code&gt; ガード。</target>
        </trans-unit>
        <trans-unit id="095096dc5e2804946ad94bae4f75159f2bd38855" translate="yes" xml:space="preserve">
          <source>The condition in an &lt;a href=&quot;keyword.if&quot;&gt;&lt;code&gt;if&lt;/code&gt;&lt;/a&gt; expression must be of type &lt;code&gt;bool&lt;/code&gt;. Whenever that condition evaluates to &lt;strong&gt;true&lt;/strong&gt;, the &lt;code&gt;if&lt;/code&gt; expression takes on the value of the first block. If however, the condition evaluates to &lt;code&gt;false&lt;/code&gt;, the expression takes on value of the &lt;code&gt;else&lt;/code&gt; block if there is one.</source>
          <target state="translated">&lt;a href=&quot;keyword.if&quot;&gt; &lt;code&gt;if&lt;/code&gt; &lt;/a&gt;式の条件は &lt;code&gt;bool&lt;/code&gt; 型でなければなりません。その条件が&lt;strong&gt;true&lt;/strong&gt;と評価されるときはいつでも、 &lt;code&gt;if&lt;/code&gt; 式は最初のブロックの値を取ります。ただし、条件が &lt;code&gt;false&lt;/code&gt; と評価された場合、式は &lt;code&gt;else&lt;/code&gt; ブロックがあればその値を取ります。</target>
        </trans-unit>
        <trans-unit id="75d37ae80df9e59cac39010c72ed606ee381207c" translate="yes" xml:space="preserve">
          <source>The condition we want to check in the inner match is whether the value returned by &lt;code&gt;error.kind()&lt;/code&gt; is the &lt;code&gt;NotFound&lt;/code&gt; variant of the &lt;code&gt;ErrorKind&lt;/code&gt; enum. If it is, we try to create the file with &lt;code&gt;File::create&lt;/code&gt;. However, because &lt;code&gt;File::create&lt;/code&gt; could also fail, we need a second arm in the inner &lt;code&gt;match&lt;/code&gt; expression. When the file can&amp;rsquo;t be created, a different error message is printed. The second arm of the outer &lt;code&gt;match&lt;/code&gt; stays the same, so the program panics on any error besides the missing file error.</source>
          <target state="translated">私たちは、内側試合にチェックしたい条件がで返される値であるかどうかを &lt;code&gt;error.kind()&lt;/code&gt; である &lt;code&gt;NotFound&lt;/code&gt; のバリアント &lt;code&gt;ErrorKind&lt;/code&gt; を列挙。もしそうなら、 &lt;code&gt;File::create&lt;/code&gt; でファイルを作成しようとします。ただし、 &lt;code&gt;File::create&lt;/code&gt; も失敗する可能性があるため、内側の &lt;code&gt;match&lt;/code&gt; 式に2つ目のアームが必要です。ファイルを作成できない場合は、別のエラーメッセージが出力されます。外側の &lt;code&gt;match&lt;/code&gt; の2番目のアームは同じままなので、プログラムはファイルが見つからないエラー以外のエラーでパニックになります。</target>
        </trans-unit>
        <trans-unit id="6c5b1587da56cf50f7a60ae4167ed8ca12fc4a83" translate="yes" xml:space="preserve">
          <source>The conditions in which you&amp;rsquo;re allowed or not allowed to implement the trait</source>
          <target state="translated">トレイトの実装が許可または禁止されている条件</target>
        </trans-unit>
        <trans-unit id="1fd449b5671c0c531048bf228bce50b5745274bb" translate="yes" xml:space="preserve">
          <source>The connection was aborted (terminated) by the remote server.</source>
          <target state="translated">接続はリモートサーバによって中断(終了)されました。</target>
        </trans-unit>
        <trans-unit id="394cd4f1c44fd561007d2b956b477de854f22ebc" translate="yes" xml:space="preserve">
          <source>The connection was refused by the remote server.</source>
          <target state="translated">接続はリモートサーバーによって拒否されました。</target>
        </trans-unit>
        <trans-unit id="ee9eafc82d73396db6a743b750893f5328ee460c" translate="yes" xml:space="preserve">
          <source>The connection was reset by the remote server.</source>
          <target state="translated">接続はリモートサーバーによってリセットされました。</target>
        </trans-unit>
        <trans-unit id="c5c0b8221782b43e8764b446a2f5d5156fcf8b34" translate="yes" xml:space="preserve">
          <source>The connection will be closed when the value is dropped. The reading and writing portions of the connection can also be shut down individually with the &lt;a href=&quot;#method.shutdown&quot;&gt;&lt;code&gt;shutdown&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">値が削除されると、接続は閉じられます。接続の読み取り部分と書き込み部分も、&lt;a href=&quot;#method.shutdown&quot;&gt; &lt;code&gt;shutdown&lt;/code&gt; &lt;/a&gt;メソッドを使用して個別にシャットダウンできます。</target>
        </trans-unit>
        <trans-unit id="ee6719cfaf61adca10461f2b171bde13e23a4a41" translate="yes" xml:space="preserve">
          <source>The connection will be closed when the value is dropped. The reading and writing portions of the connection can also be shut down individually with the &lt;a href=&quot;struct.tcpstream#method.shutdown&quot;&gt;&lt;code&gt;shutdown&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">値が削除されると、接続は閉じられます。接続の読み取り部分と書き込み部分は、&lt;a href=&quot;struct.tcpstream#method.shutdown&quot;&gt; &lt;code&gt;shutdown&lt;/code&gt; &lt;/a&gt;メソッドを使用して個別にシャットダウンすることもできます。</target>
        </trans-unit>
        <trans-unit id="98a1585e2f9a061b72de9d4f949a75a416a4fb56" translate="yes" xml:space="preserve">
          <source>The cons function concept has made its way into more general functional programming jargon: &amp;ldquo;to cons &lt;em&gt;x&lt;/em&gt; onto &lt;em&gt;y&lt;/em&gt;&amp;rdquo; informally means to construct a new container instance by putting the element &lt;em&gt;x&lt;/em&gt; at the start of this new container, followed by the container &lt;em&gt;y&lt;/em&gt;.</source>
          <target state="translated">cons関数の概念は、より一般的な関数型プログラミング用語になりました。「cons &lt;em&gt;x&lt;/em&gt; on &lt;em&gt;y&lt;/em&gt;」とは、非公式に、要素&lt;em&gt;x&lt;/em&gt;をこの新しいコンテナーの先頭に置き、その後にコンテナー&lt;em&gt;yを&lt;/em&gt;置くことによって、新しいコンテナーインスタンスを構築することを意味します。</target>
        </trans-unit>
        <trans-unit id="3946118b0e2f7f5ec1675cedbf82ccd7c8d576ce" translate="yes" xml:space="preserve">
          <source>The contents of &lt;em&gt;src/lib.rs&lt;/em&gt; should have the signatures shown in Listing 12-13 (we&amp;rsquo;ve omitted the bodies of the functions for brevity). Note that this won&amp;rsquo;t compile until we modify &lt;em&gt;src/main.rs&lt;/em&gt; in Listing 12-14.</source>
          <target state="translated">&lt;em&gt;src / lib.rs&lt;/em&gt;の内容には、リスト12-13に示すシグネチャが必要です（簡潔にするため、関数の本体は省略しています）。リスト12-14で&lt;em&gt;src / main.rs&lt;/em&gt;を変更するまで、これはコンパイルされないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="4fb4cd20ff2b04a7f8f088847ce2546308d2b8ce" translate="yes" xml:space="preserve">
          <source>The contents of the &lt;em&gt;src/lib.rs&lt;/em&gt; file in your &lt;code&gt;adder&lt;/code&gt; library should look like Listing 11-1.</source>
          <target state="translated">&lt;code&gt;adder&lt;/code&gt; ライブラリの&lt;em&gt;src / lib.rs&lt;/em&gt;ファイルの内容は、リスト11-1のようになります。</target>
        </trans-unit>
        <trans-unit id="1735f7c56c57e86fb0b029da9024a55f63cc6d92" translate="yes" xml:space="preserve">
          <source>The contents of the repetition must be able to follow whatever comes before, and whatever comes after must be able to follow the contents of the repetition.</source>
          <target state="translated">繰り返しの内容は、その前に来るものは何であれ、その後に来るものは何であれ、繰り返しの内容を追いかけることができなければなりません。</target>
        </trans-unit>
        <trans-unit id="33e5fb5d650df50a2e77352564f0bccccceac217" translate="yes" xml:space="preserve">
          <source>The contents of the returned &lt;a href=&quot;../raw/struct.stat&quot;&gt;&lt;code&gt;stat&lt;/code&gt;&lt;/a&gt; are &lt;strong&gt;not&lt;/strong&gt; consistent across Unix platforms. The &lt;code&gt;os::unix::fs::MetadataExt&lt;/code&gt; trait contains the cross-Unix abstractions contained within the raw stat.</source>
          <target state="translated">返された内容&lt;a href=&quot;../raw/struct.stat&quot;&gt; &lt;code&gt;stat&lt;/code&gt; &lt;/a&gt;あり&lt;strong&gt;ません&lt;/strong&gt; Unixプラットフォーム間で一貫。 &lt;code&gt;os::unix::fs::MetadataExt&lt;/code&gt; 特徴は、生のstat内に含まれるクロスUnixの抽象化が含まれています。</target>
        </trans-unit>
        <trans-unit id="0770383d0616ee4e47049d055237250b7b2bfaef" translate="yes" xml:space="preserve">
          <source>The conversion allocates on the heap and moves &lt;code&gt;t&lt;/code&gt; from the stack into it.</source>
          <target state="translated">変換はヒープに割り当てられ、 &lt;code&gt;t&lt;/code&gt; をスタックからスタックに移動します。</target>
        </trans-unit>
        <trans-unit id="66e8c9afb284902c1e321d76aa570359994fd792" translate="yes" xml:space="preserve">
          <source>The conversion consumes the &lt;a href=&quot;../ffi/struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt;, and removes the terminating NUL byte.</source>
          <target state="translated">変換は&lt;a href=&quot;../ffi/struct.cstring&quot;&gt; &lt;code&gt;CString&lt;/code&gt; を&lt;/a&gt;消費し、終端のNULバイトを削除します。</target>
        </trans-unit>
        <trans-unit id="b49f9ee7f1f30037339c1daa1d1e1cd395843299" translate="yes" xml:space="preserve">
          <source>The conversion consumes the &lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt;, and removes the terminating NUL byte.</source>
          <target state="translated">変換は&lt;a href=&quot;struct.cstring&quot;&gt; &lt;code&gt;CString&lt;/code&gt; を&lt;/a&gt;消費し、終端のNULバイトを削除します。</target>
        </trans-unit>
        <trans-unit id="9ff60369ad0f3cbf8d85443d93a8bb4f7f1f7686" translate="yes" xml:space="preserve">
          <source>The conversion copies the data, and includes an allocation on the heap.</source>
          <target state="translated">変換はデータをコピーし,ヒープ上の割り当てを含む。</target>
        </trans-unit>
        <trans-unit id="cbdea02b60597ccd54b5d9dbad9b3681336b3420" translate="yes" xml:space="preserve">
          <source>The core method of future, &lt;code&gt;poll&lt;/code&gt;, &lt;em&gt;attempts&lt;/em&gt; to resolve the future into a final value. This method does not block if the value is not ready. Instead, the current task is scheduled to be woken up when it's possible to make further progress by &lt;code&gt;poll&lt;/code&gt;ing again. The &lt;code&gt;context&lt;/code&gt; passed to the &lt;code&gt;poll&lt;/code&gt; method can provide a &lt;a href=&quot;../task/struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt;, which is a handle for waking up the current task.</source>
          <target state="translated">futureのコアメソッドである &lt;code&gt;poll&lt;/code&gt; は、futureを最終的な値に解決&lt;em&gt;しようと&lt;/em&gt;します。値の準備ができていない場合、このメソッドはブロックしません。代わりに、現在のタスクは、再度 &lt;code&gt;poll&lt;/code&gt; することでさらに進行できるときにウェイクアップされるようにスケジュールされています。 &lt;code&gt;context&lt;/code&gt; に渡された &lt;code&gt;poll&lt;/code&gt; 方法が提供できる&lt;a href=&quot;../task/struct.waker&quot;&gt; &lt;code&gt;Waker&lt;/code&gt; &lt;/a&gt;現在のタスクを覚ますためのハンドルです。</target>
        </trans-unit>
        <trans-unit id="af0586e1698754134d6653d1c35d55045868b007" translate="yes" xml:space="preserve">
          <source>The core method of future, &lt;code&gt;poll&lt;/code&gt;, &lt;em&gt;attempts&lt;/em&gt; to resolve the future into a final value. This method does not block if the value is not ready. Instead, the current task is scheduled to be woken up when it's possible to make further progress by &lt;code&gt;poll&lt;/code&gt;ing again. The &lt;code&gt;context&lt;/code&gt; passed to the &lt;code&gt;poll&lt;/code&gt; method can provide a &lt;code&gt;Waker&lt;/code&gt;, which is a handle for waking up the current task.</source>
          <target state="translated">futureのコアメソッドである &lt;code&gt;poll&lt;/code&gt; は、未来を最終的な値に解決&lt;em&gt;しようと&lt;/em&gt;します。値の準備ができていない場合、このメソッドはブロックしません。代わりに、現在のタスクは、再度 &lt;code&gt;poll&lt;/code&gt; することでさらに先に進むことが可能なときに起こされるようにスケジュールされています。 &lt;code&gt;context&lt;/code&gt; に渡された &lt;code&gt;poll&lt;/code&gt; 方法が提供できる &lt;code&gt;Waker&lt;/code&gt; 現在のタスクを覚ますためのハンドルです。</target>
        </trans-unit>
        <trans-unit id="7cb53e3d2cc08f8c1b0d6306a44e9e0ab47f9511" translate="yes" xml:space="preserve">
          <source>The core of the error states that there are &lt;em&gt;mismatched types&lt;/em&gt;. Rust has a strong, static type system. However, it also has type inference. When we wrote &lt;code&gt;let mut guess = String::new()&lt;/code&gt;, Rust was able to infer that &lt;code&gt;guess&lt;/code&gt; should be a &lt;code&gt;String&lt;/code&gt; and didn&amp;rsquo;t make us write the type. The &lt;code&gt;secret_number&lt;/code&gt;, on the other hand, is a number type. A few number types can have a value between 1 and 100: &lt;code&gt;i32&lt;/code&gt;, a 32-bit number; &lt;code&gt;u32&lt;/code&gt;, an unsigned 32-bit number; &lt;code&gt;i64&lt;/code&gt;, a 64-bit number; as well as others. Rust defaults to an &lt;code&gt;i32&lt;/code&gt;, which is the type of &lt;code&gt;secret_number&lt;/code&gt; unless you add type information elsewhere that would cause Rust to infer a different numerical type. The reason for the error is that Rust cannot compare a string and a number type.</source>
          <target state="translated">エラーの中心は、&lt;em&gt;不一致のタイプ&lt;/em&gt;がある&lt;em&gt;ことを示しています&lt;/em&gt;。 Rustには強力な静的型システムがあります。ただし、型推論もあります。 &lt;code&gt;let mut guess = String::new()&lt;/code&gt; 書いたとき、Rustは &lt;code&gt;guess&lt;/code&gt; が &lt;code&gt;String&lt;/code&gt; べきであると推測でき、型を記述しませんでした。 &lt;code&gt;secret_number&lt;/code&gt; は、一方で、数値型です。いくつかの数値タイプは、1から100までの値を持つことができます &lt;code&gt;i32&lt;/code&gt; は32ビットの数値です。 &lt;code&gt;u32&lt;/code&gt; 、符号なし32ビット数。 &lt;code&gt;i64&lt;/code&gt; 、64ビットの数値。他の人と同様に。 Rustのデフォルトは &lt;code&gt;i32&lt;/code&gt; で、これは &lt;code&gt;secret_number&lt;/code&gt; のタイプですRustが別の数値型を推測する原因となるような場所に型情報を追加しない限り。エラーの理由は、Rustが文字列と数値型を比較できないためです。</target>
        </trans-unit>
        <trans-unit id="ddff64ad7c369ce0737f5b8b0b3f4b7511787cca" translate="yes" xml:space="preserve">
          <source>The core primitive for interior mutability in Rust.</source>
          <target state="translated">Rust の内部変異性のためのコアプリミティブ。</target>
        </trans-unit>
        <trans-unit id="e23a80c74457fb7f3e04241567981840f6b6a5f0" translate="yes" xml:space="preserve">
          <source>The corresponding definitions are in &lt;code&gt;compiler/rustc_codegen_llvm/src/intrinsic.rs&lt;/code&gt;. The corresponding const implementations are in &lt;code&gt;compiler/rustc_mir/src/interpret/intrinsics.rs&lt;/code&gt;</source>
          <target state="translated">対応する定義は、 &lt;code&gt;compiler/rustc_codegen_llvm/src/intrinsic.rs&lt;/code&gt; ます。対応するconst実装は、 &lt;code&gt;compiler/rustc_mir/src/interpret/intrinsics.rs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="159b3bf04af466ed5bc13962fe870a560dd18283" translate="yes" xml:space="preserve">
          <source>The corresponding definitions are in &lt;code&gt;librustc_codegen_llvm/intrinsic.rs&lt;/code&gt;.</source>
          <target state="translated">対応する定義は &lt;code&gt;librustc_codegen_llvm/intrinsic.rs&lt;/code&gt; にあります。</target>
        </trans-unit>
        <trans-unit id="46698ed84aa8c683839a27c0dd70bde9fa62d21c" translate="yes" xml:space="preserve">
          <source>The counts are not affected in any way and the &lt;code&gt;Arc&lt;/code&gt; is not consumed. The pointer is valid for as long as there are strong counts in the &lt;code&gt;Arc&lt;/code&gt;.</source>
          <target state="translated">カウントはまったく影響を受けず、 &lt;code&gt;Arc&lt;/code&gt; は消費されません。ポインタは、 &lt;code&gt;Arc&lt;/code&gt; 強いカウントがある限り有効です。</target>
        </trans-unit>
        <trans-unit id="77f706694dca621192d20fdc480b2fbc8fb70f49" translate="yes" xml:space="preserve">
          <source>The counts are not affected in any way and the &lt;code&gt;Rc&lt;/code&gt; is not consumed. The pointer is valid for as long there are strong counts in the &lt;code&gt;Rc&lt;/code&gt;.</source>
          <target state="translated">カウントはまったく影響を受けず、 &lt;code&gt;Rc&lt;/code&gt; は消費されません。ポインタは、 &lt;code&gt;Rc&lt;/code&gt; に強いカウントがある限り有効です。</target>
        </trans-unit>
        <trans-unit id="5d69c16c8fa846f1af610002036c48591d43f28f" translate="yes" xml:space="preserve">
          <source>The crate name must not be empty, and must only contain &lt;a href=&quot;../std/primitive.char#method.is_alphanumeric&quot;&gt;Unicode alphanumeric&lt;/a&gt; or &lt;code&gt;-&lt;/code&gt; (U+002D) characters.</source>
          <target state="translated">クレート名は空にできません。また、&lt;a href=&quot;../std/primitive.char#method.is_alphanumeric&quot;&gt;Unicodeの英数字&lt;/a&gt;または &lt;code&gt;-&lt;/code&gt; （U + 002D）文字のみを含める必要があります。</target>
        </trans-unit>
        <trans-unit id="be4dd5125e77acafd163c79956b21bce0b41caf8" translate="yes" xml:space="preserve">
          <source>The created map has the default initial capacity.</source>
          <target state="translated">作成されたマップは、デフォルトの初期容量を持っています。</target>
        </trans-unit>
        <trans-unit id="a9c04b6351b379cccf29eab61f8204218529d934" translate="yes" xml:space="preserve">
          <source>The current algorithm is an adaptive, iterative merge sort inspired by &lt;a href=&quot;https://en.wikipedia.org/wiki/Timsort&quot;&gt;timsort&lt;/a&gt;. It is designed to be very fast in cases where the slice is nearly sorted, or consists of two or more sorted sequences concatenated one after another.</source>
          <target state="translated">現在のアルゴリズムは、&lt;a href=&quot;https://en.wikipedia.org/wiki/Timsort&quot;&gt;timsortに&lt;/a&gt;触発された適応型の反復マージソートです。スライスがほぼソートされている場合、または2つ以上のソートされたシーケンスが次々に連結されている場合に、非常に高速になるように設計されています。</target>
        </trans-unit>
        <trans-unit id="bf4d84cfe0f7a72eb4a521a3a9fe9d6ec790d19e" translate="yes" xml:space="preserve">
          <source>The current algorithm is based on &lt;a href=&quot;https://github.com/orlp/pdqsort&quot;&gt;pattern-defeating quicksort&lt;/a&gt; by Orson Peters, which combines the fast average case of randomized quicksort with the fast worst case of heapsort, while achieving linear time on slices with certain patterns. It uses some randomization to avoid degenerate cases, but with a fixed seed to always provide deterministic behavior.</source>
          <target state="translated">現在のアルゴリズムは、Orson Petersによる&lt;a href=&quot;https://github.com/orlp/pdqsort&quot;&gt;パターンを無効にするクイックソートに&lt;/a&gt;基づいています。これは、ランダム化されたクイックソートの高速平均ケースとヒープソートの高速最悪ケースを組み合わせながら、特定のパターンのスライスで線形時間を実現します。いくつかのランダム化を使用して、縮退したケースを回避しますが、固定されたシードを使用して、常に確定的な動作を提供します。</target>
        </trans-unit>
        <trans-unit id="17185ac0ce099c141b9827d28f04ee4d12e294f8" translate="yes" xml:space="preserve">
          <source>The current algorithm is based on the quickselect portion of the same quicksort algorithm used for &lt;a href=&quot;#method.sort_unstable&quot;&gt;&lt;code&gt;sort_unstable&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">現在のアルゴリズムは、&lt;a href=&quot;#method.sort_unstable&quot;&gt; &lt;code&gt;sort_unstable&lt;/code&gt; に&lt;/a&gt;使用されているのと同じクイックソートアルゴリズムのクイック選択部分に基づいています。</target>
        </trans-unit>
        <trans-unit id="593e3fc1b65f7b6d06f9c45167b067a1a762655b" translate="yes" xml:space="preserve">
          <source>The current file cursor is not affected by this function.</source>
          <target state="translated">現在のファイルカーソルはこの機能の影響を受けません。</target>
        </trans-unit>
        <trans-unit id="b3777ab23f3b1144c9a96d550ee493d6bc6e2d44" translate="yes" xml:space="preserve">
          <source>The current implementation uses the same infrastructure as compiler diagnostics and debuginfo, but this is not guaranteed.</source>
          <target state="translated">現在の実装では、コンパイラ診断やdebuginfoと同じインフラストラクチャを使用していますが、これは保証されていません。</target>
        </trans-unit>
        <trans-unit id="3346ba5eca8038cde57805738abeaa90cd6a63c6" translate="yes" xml:space="preserve">
          <source>The current module path can be thought of as the hierarchy of modules leading back up to the crate root. The first component of the path returned is the name of the crate currently being compiled.</source>
          <target state="translated">現在のモジュールパスは、クレートのルートに至るモジュールの階層と考えることができます。返されるパスの最初の要素は、現在コンパイルされているクレートの名前です。</target>
        </trans-unit>
        <trans-unit id="bdf915fa340c78bb10eee5926542917da6f9a74d" translate="yes" xml:space="preserve">
          <source>The current process does not have the permission rights to access &lt;code&gt;from&lt;/code&gt; or write &lt;code&gt;to&lt;/code&gt;.</source>
          <target state="translated">現在のプロセスがアクセス権限権がない &lt;code&gt;from&lt;/code&gt; か、書き込み &lt;code&gt;to&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1b9c6f166ff606296d138016ea8392f66f7ed63a" translate="yes" xml:space="preserve">
          <source>The current status of a backtrace, indicating whether it was captured or whether it is empty for some other reason.</source>
          <target state="translated">バックトレースの現在の状態を示し、捕捉されたかどうか、あるいは何らかの理由で空になっているかどうかを示します。</target>
        </trans-unit>
        <trans-unit id="aa1cdfe5525c9cd270fc9b5826bff19009fb273e" translate="yes" xml:space="preserve">
          <source>The current version of the prelude (version 1) lives in &lt;a href=&quot;v1/index&quot;&gt;&lt;code&gt;std::prelude::v1&lt;/code&gt;&lt;/a&gt;, and re-exports the following.</source>
          <target state="translated">プレリュードの現在のバージョン（バージョン1）は&lt;a href=&quot;v1/index&quot;&gt; &lt;code&gt;std::prelude::v1&lt;/code&gt; &lt;/a&gt;にあり、以下を再エクスポートします。</target>
        </trans-unit>
        <trans-unit id="912528c0cfbd7646c08850f1e407245a6bf7145e" translate="yes" xml:space="preserve">
          <source>The cursor is pointing to the &quot;ghost&quot; non-element if the list is empty.</source>
          <target state="translated">リストが空の場合、カーソルは &quot;ゴースト &quot;以外の要素を指しています。</target>
        </trans-unit>
        <trans-unit id="b9ad03e9a3edaaa56118f6fc3f2871f3d642b3c0" translate="yes" xml:space="preserve">
          <source>The data could not be sent on the &lt;a href=&quot;fn.sync_channel&quot;&gt;&lt;code&gt;sync_channel&lt;/code&gt;&lt;/a&gt; because it would require that the callee block to send the data.</source>
          <target state="translated">呼び出し先ブロックがデータを送信する必要があるため、&lt;a href=&quot;fn.sync_channel&quot;&gt; &lt;code&gt;sync_channel&lt;/code&gt; で&lt;/a&gt;データを送信できませんでした。</target>
        </trans-unit>
        <trans-unit id="caac8e332d6bed98dbe6a446c232bbf7ded49130" translate="yes" xml:space="preserve">
          <source>The data members that this trait exposes correspond to the members of the &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/fileapi/ns-fileapi-by_handle_file_information&quot;&gt;&lt;code&gt;BY_HANDLE_FILE_INFORMATION&lt;/code&gt;&lt;/a&gt; structure.</source>
          <target state="translated">このトレイトが公開するデータメンバーは、&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/fileapi/ns-fileapi-by_handle_file_information&quot;&gt; &lt;code&gt;BY_HANDLE_FILE_INFORMATION&lt;/code&gt; &lt;/a&gt;構造体のメンバーに対応します。</target>
        </trans-unit>
        <trans-unit id="113312da9f41c00330f3f6a2627f87633cf51181" translate="yes" xml:space="preserve">
          <source>The data members that this trait exposes correspond to the members of the &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa363788.aspx&quot;&gt;&lt;code&gt;BY_HANDLE_FILE_INFORMATION&lt;/code&gt;&lt;/a&gt; structure.</source>
          <target state="translated">この特性が公開するデータメンバーは、&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa363788.aspx&quot;&gt; &lt;code&gt;BY_HANDLE_FILE_INFORMATION&lt;/code&gt; &lt;/a&gt;構造体のメンバーに対応します。</target>
        </trans-unit>
        <trans-unit id="c9421f388aa0f6bda7993e70317be2c01ffcdb74" translate="yes" xml:space="preserve">
          <source>The data protected by the mutex can be accessed through this guard via its &lt;a href=&quot;../ops/trait.deref&quot;&gt;&lt;code&gt;Deref&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../ops/trait.derefmut&quot;&gt;&lt;code&gt;DerefMut&lt;/code&gt;&lt;/a&gt; implementations.</source>
          <target state="translated">ミューテックスによって保護されたデータは、その介してこのガードを介してアクセスすることができ&lt;a href=&quot;../ops/trait.deref&quot;&gt; &lt;code&gt;Deref&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../ops/trait.derefmut&quot;&gt; &lt;code&gt;DerefMut&lt;/code&gt; &lt;/a&gt;実装。</target>
        </trans-unit>
        <trans-unit id="a8b69bce2135d478ffa031311b309f0dc7de4fc2" translate="yes" xml:space="preserve">
          <source>The data that the process wrote to stderr.</source>
          <target state="translated">プロセスが標準エラーに書き込んだデータ。</target>
        </trans-unit>
        <trans-unit id="5ad3bfb524d0ca744c539d652ec4054ab0b9dc35" translate="yes" xml:space="preserve">
          <source>The data that the process wrote to stdout.</source>
          <target state="translated">プロセスが標準出力に書き込んだデータ。</target>
        </trans-unit>
        <trans-unit id="f0f62565562b0bbca1d9e555b1c167c8869cc294" translate="yes" xml:space="preserve">
          <source>The declaration of &lt;code&gt;another_function&lt;/code&gt; has one parameter named &lt;code&gt;x&lt;/code&gt;. The type of &lt;code&gt;x&lt;/code&gt; is specified as &lt;code&gt;i32&lt;/code&gt;. When &lt;code&gt;5&lt;/code&gt; is passed to &lt;code&gt;another_function&lt;/code&gt;, the &lt;code&gt;println!&lt;/code&gt; macro puts &lt;code&gt;5&lt;/code&gt; where the pair of curly brackets were in the format string.</source>
          <target state="translated">&lt;code&gt;another_function&lt;/code&gt; の宣言には、 &lt;code&gt;x&lt;/code&gt; という名前のパラメーターが1つあります。 &lt;code&gt;x&lt;/code&gt; のタイプは &lt;code&gt;i32&lt;/code&gt; として指定されます。とき &lt;code&gt;5&lt;/code&gt; に渡され &lt;code&gt;another_function&lt;/code&gt; 、 &lt;code&gt;println!&lt;/code&gt; マクロは、中括弧のペアがフォーマット文字列内にあった場所に &lt;code&gt;5&lt;/code&gt; を置きます。</target>
        </trans-unit>
        <trans-unit id="f3e2b77707e4042bb7d326cf080f9fda22d6fd02" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;#fillalignment&quot;&gt;fill/alignment&lt;/a&gt; for non-numerics is a space and left-aligned. The default for numeric formatters is also a space character but with right-alignment. If the &lt;code&gt;0&lt;/code&gt; flag (see below) is specified for numerics, then the implicit fill character is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">非数値のデフォルトの&lt;a href=&quot;#fillalignment&quot;&gt;塗りつぶし/配置&lt;/a&gt;はスペースで、左揃えです。数値フォーマッタのデフォルトもスペース文字ですが、右揃えです。場合は &lt;code&gt;0&lt;/code&gt; フラグが（下記参照）数値に指定され、その後、暗黙のフィル文字です &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6a4c3f3e9f4bf073db3de78ffdfd8f78a08679d0" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;#fillalignment&quot;&gt;fill/alignment&lt;/a&gt; for non-numerics is a space and left-aligned. The defaults for numeric formatters is also a space but with right-alignment. If the &lt;code&gt;0&lt;/code&gt; flag is specified for numerics, then the implicit fill character is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">非数値のデフォルトの&lt;a href=&quot;#fillalignment&quot;&gt;塗りつぶし/配置&lt;/a&gt;はスペースであり、左揃えです。数値フォーマッターのデフォルトもスペースですが、右寄せされます。場合は &lt;code&gt;0&lt;/code&gt; フラグが数値に指定され、その後、暗黙のフィル文字です &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e71d3da519e1259cb4d0ff052a4082fe544273e4" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;../../hash/trait.hasher&quot;&gt;&lt;code&gt;Hasher&lt;/code&gt;&lt;/a&gt; used by &lt;a href=&quot;struct.randomstate&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;struct.randomstate&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; で&lt;/a&gt;使用されるデフォルトの&lt;a href=&quot;../../hash/trait.hasher&quot;&gt; &lt;code&gt;Hasher&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="81a33ca44ce969a6a0433a7aff9f0392c46b2e52" translate="yes" xml:space="preserve">
          <source>The default behavior of this function is to print a message to standard error and abort the process. It can be replaced with &lt;a href=&quot;fn.set_alloc_error_hook&quot;&gt;&lt;code&gt;set_alloc_error_hook&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fn.take_alloc_error_hook&quot;&gt;&lt;code&gt;take_alloc_error_hook&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この関数のデフォルトの動作は、メッセージを標準エラーに出力してプロセスを中止することです。&lt;a href=&quot;fn.set_alloc_error_hook&quot;&gt; &lt;code&gt;set_alloc_error_hook&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;fn.take_alloc_error_hook&quot;&gt; &lt;code&gt;take_alloc_error_hook&lt;/code&gt; で&lt;/a&gt;置き換えることができます。</target>
        </trans-unit>
        <trans-unit id="1fe48c8009742af8ee8a3efe0842a923bc01bf9d" translate="yes" xml:space="preserve">
          <source>The default generic type in this code is within the &lt;code&gt;Add&lt;/code&gt; trait. Here is its definition:</source>
          <target state="translated">このコードのデフォルトのジェネリック型は &lt;code&gt;Add&lt;/code&gt; トレイト内にあります。以下がその定義です。</target>
        </trans-unit>
        <trans-unit id="697b922437171b9fe1e8c84494c4b161d6fd03d3" translate="yes" xml:space="preserve">
          <source>The default hashing algorithm is currently SipHash 1-3, though this is subject to change at any point in the future. While its performance is very competitive for medium sized keys, other hashing algorithms will outperform it for small keys such as integers as well as large keys such as long strings, though those algorithms will typically &lt;em&gt;not&lt;/em&gt; protect against attacks such as HashDoS.</source>
          <target state="translated">デフォルトのハッシュアルゴリズムは現在SipHash 1〜3ですが、これは将来いつでも変更される可能性があります。そのパフォーマンスは中規模のキーに対して非常に競争力がありますが、他のハッシュアルゴリズムは、整数などの小さなキーや長い文字列などの大きなキーに対してパフォーマンスが優れていますが、これらのアルゴリズムは通常、HashDoSなどの攻撃から保護し&lt;em&gt;ません&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="80e587164750efd5907b562bcc2c0ec8621ca1dc" translate="yes" xml:space="preserve">
          <source>The default implementation calls &lt;a href=&quot;trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; with either the first nonempty buffer provided, or an empty one if none exists.</source>
          <target state="translated">デフォルトの実装では、最初に空でないバッファーを指定して、または空のバッファーが存在しない場合は空のバッファーを使用して&lt;a href=&quot;trait.write#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;を呼び出します。</target>
        </trans-unit>
        <trans-unit id="73b38e69c912c9cd2a1d35da9b4cb8282e56833f" translate="yes" xml:space="preserve">
          <source>The default implementation calls &lt;code&gt;read&lt;/code&gt; with either the first nonempty buffer provided, or an empty one if none exists.</source>
          <target state="translated">デフォルトの実装は、最初の空でないバッファを提供するか、存在しない場合は空のバッファを使用して &lt;code&gt;read&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="2e19ee8802e471056a9e27a45d3086893e133973" translate="yes" xml:space="preserve">
          <source>The default implementation calls &lt;code&gt;write&lt;/code&gt; with either the first nonempty buffer provided, or an empty one if none exists.</source>
          <target state="translated">デフォルトの実装では、提供された最初の空でないバッファ、または存在しない場合は空のバッファを使用して &lt;code&gt;write&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="917b792910290b9f104f9e9bb1c1c376f6e62a1b" translate="yes" xml:space="preserve">
          <source>The default implementation does nothing.</source>
          <target state="translated">デフォルトの実装では何もしません。</target>
        </trans-unit>
        <trans-unit id="cda4f183b9995aecf4b0037179612271bde1f6bd" translate="yes" xml:space="preserve">
          <source>The default implementation returns &lt;code&gt;(0, &lt;/code&gt;&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt; which is correct for any iterator.</source>
          <target state="translated">デフォルトの実装は &lt;code&gt;(0, &lt;/code&gt; &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; &lt;code&gt;)&lt;/code&gt; を返します。これはどのイテレータにとっても正しいものです。</target>
        </trans-unit>
        <trans-unit id="e33ad58e76bb269caa1c45076544afb93bb1e40d" translate="yes" xml:space="preserve">
          <source>The default implementation returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">デフォルトの実装は &lt;code&gt;false&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="969fb25f2024192b2aecf3ee3a177be1b86acfb5" translate="yes" xml:space="preserve">
          <source>The default implementation returns an initializer which will zero buffers.</source>
          <target state="translated">デフォルトの実装では、バッファをゼロにするイニシャライザを返します。</target>
        </trans-unit>
        <trans-unit id="bb3d803ebf5acd8c1abc49ce5f1cae9b36493095" translate="yes" xml:space="preserve">
          <source>The default implementations are returning &lt;code&gt;libc::EXIT_SUCCESS&lt;/code&gt; to indicate a successful execution. In case of a failure, &lt;code&gt;libc::EXIT_FAILURE&lt;/code&gt; is returned.</source>
          <target state="translated">デフォルトの実装は &lt;code&gt;libc::EXIT_SUCCESS&lt;/code&gt; を返し、実行が成功したことを示します。失敗した場合は、 &lt;code&gt;libc::EXIT_FAILURE&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="31cdcfae6f2b31eff3f08e0d9f029eeb9ec7bee1" translate="yes" xml:space="preserve">
          <source>The default is chosen with a bias toward producing literals that are legal in a variety of languages, including C++11 and similar C-family languages. The exact rules are:</source>
          <target state="translated">デフ ォル ト は、 C++11 や類似の C 系言語を含む、 さ ま ざ ま な言語で合法な リ テ ラ ルを生成す る こ と に偏っ て選択 さ れています。正確なルールは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="b02cae987658ffb74f03215f87762f2599f0c7eb" translate="yes" xml:space="preserve">
          <source>The default memory allocator provided by the operating system.</source>
          <target state="translated">オペレーティングシステムが提供するデフォルトのメモリアロケータ。</target>
        </trans-unit>
        <trans-unit id="1dd4678ade75055f3987aad761b36a01d2353c9f" translate="yes" xml:space="preserve">
          <source>The default stack size for spawned threads is 2 MiB, though this particular stack size is subject to change in the future. There are two ways to manually specify the stack size for spawned threads:</source>
          <target state="translated">スポーンされるスレッドのデフォルトのスタックサイズは 2 MiB ですが、この特定のスタックサイズは将来的に変更される可能性があります。スポーンされたスレッドのスタックサイズを手動で指定するには 2 つの方法があります。</target>
        </trans-unit>
        <trans-unit id="0f91c7ab56b392b9e17d4e1e13452f2f412a7407" translate="yes" xml:space="preserve">
          <source>The definition for complex NTs deserves some justification. SEP_SET(M) defines the possibility that the separator could be a valid first token for M, which happens when there is a separator defined and the repeated fragment could be empty. ALPHA_SET(M) defines the possibility that the complex NT could be empty, meaning that M's valid first tokens are those of the following token-tree sequences &lt;code&gt;&amp;alpha;&lt;/code&gt;. This occurs when either &lt;code&gt;\*&lt;/code&gt; or &lt;code&gt;?&lt;/code&gt; is used, in which case there could be zero repetitions. In theory, this could also occur if &lt;code&gt;+&lt;/code&gt; was used with a potentially-empty repeating fragment, but this is forbidden by the third invariant.</source>
          <target state="translated">複雑なNTの定義は、ある程度の正当化に値します。SEP_SET（M）は、セパレーターがMの有効な最初のトークンになる可能性を定義します。これは、セパレーターが定義されていて、繰り返しフラグメントが空である可能性がある場合に発生します。ALPHA_SET（M）は、複雑なNTが空になる可能性を定義します。つまり、Mの有効な最初のトークンは、次のトークンツリーシーケンス &lt;code&gt;&amp;alpha;&lt;/code&gt; のトークンです。これは、 &lt;code&gt;\*&lt;/code&gt; または &lt;code&gt;?&lt;/code&gt; が使用されます。その場合、繰り返しはゼロになる可能性があります。理論的には、 &lt;code&gt;+&lt;/code&gt; が潜在的に空の繰り返しフラグメントと共に使用された場合にもこれが発生する可能性がありますが、これは3番目の不変式によって禁止されています。</target>
        </trans-unit>
        <trans-unit id="985a8049c57bbba61492d3048826a9b3471b56f7" translate="yes" xml:space="preserve">
          <source>The definition of &lt;code&gt;Config&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Config&lt;/code&gt; の定義</target>
        </trans-unit>
        <trans-unit id="830ab684e6b9340db4f9c07a73c12e27ccb95977" translate="yes" xml:space="preserve">
          <source>The dereference operator</source>
          <target state="translated">参照解除演算子</target>
        </trans-unit>
        <trans-unit id="75ad44a3ef91af0a45f2841a370dda11b833e07f" translate="yes" xml:space="preserve">
          <source>The desired behavior of the &lt;code&gt;generate_workout&lt;/code&gt; function is to first check whether the user wants a low-intensity workout (indicated by a number less than 25) or a high-intensity workout (a number of 25 or greater).</source>
          <target state="translated">&lt;code&gt;generate_workout&lt;/code&gt; 関数の望ましい動作は、ユーザーが低強度のワークアウト（25未満の数値で示される）または高強度のワークアウト（25以上の数値で示される）を希望しているかどうかを最初に確認することです。</target>
        </trans-unit>
        <trans-unit id="f11d06267e33f3ae0370e1b473dace96a1d49d65" translate="yes" xml:space="preserve">
          <source>The destructor of a type &lt;code&gt;T&lt;/code&gt; consists of:</source>
          <target state="translated">タイプ &lt;code&gt;T&lt;/code&gt; のデストラクタは、次のもので構成されます。</target>
        </trans-unit>
        <trans-unit id="be2c8573e9de352b5e8e680cfa4b055e97512426" translate="yes" xml:space="preserve">
          <source>The destructor of a type consists of</source>
          <target state="translated">型のデストラクタは、次のように構成されます。</target>
        </trans-unit>
        <trans-unit id="c9c60944e1a21001c2063c93ac3b0f4cb46946e2" translate="yes" xml:space="preserve">
          <source>The destructor of the struct must not move structural fields out of its argument. This is the exact point that was raised in the &lt;a href=&quot;#drop-implementation&quot;&gt;previous section&lt;/a&gt;: &lt;code&gt;drop&lt;/code&gt; takes &lt;code&gt;&amp;amp;mut self&lt;/code&gt;, but the struct (and hence its fields) might have been pinned before. You have to guarantee that you do not move a field inside your &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt; implementation. In particular, as explained previously, this means that your struct must &lt;em&gt;not&lt;/em&gt; be &lt;code&gt;#[repr(packed)]&lt;/code&gt;. See that section for how to write &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt; in a way that the compiler can help you not accidentally break pinning.</source>
          <target state="translated">構造体のデストラクタは、構造体フィールドを引数から移動してはなりません。これはで育った正確なポイントで&lt;a href=&quot;#drop-implementation&quot;&gt;、前のセクション&lt;/a&gt;： &lt;code&gt;drop&lt;/code&gt; かかる &lt;code&gt;&amp;amp;mut self&lt;/code&gt; が、構造体（ひいてはそのフィールド）が前に固定されている場合があります。&lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt; &lt;code&gt;Drop&lt;/code&gt; &lt;/a&gt;実装内でフィールドを移動しないことを保証する必要があります。特に、前に説明したように、これは構造体が &lt;code&gt;#[repr(packed)]&lt;/code&gt; であってはなら&lt;em&gt;ない&lt;/em&gt;ことを意味します。コンパイラが誤ってピン留めを壊さないように&lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt; &lt;code&gt;drop&lt;/code&gt; &lt;/a&gt;を書き込む方法については、そのセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="30054f3bf420ad868745eedcb4cc73a1da34e82c" translate="yes" xml:space="preserve">
          <source>The destructor of the struct must not move structural fields out of its argument. This is the exact point that was raised in the &lt;a href=&quot;#drop-implementation&quot;&gt;previous section&lt;/a&gt;: &lt;code&gt;drop&lt;/code&gt; takes &lt;code&gt;&amp;amp;mut self&lt;/code&gt;, but the struct (and hence its fields) might have been pinned before. You have to guarantee that you do not move a field inside your &lt;code&gt;Drop&lt;/code&gt; implementation. In particular, as explained previously, this means that your struct must &lt;em&gt;not&lt;/em&gt; be &lt;code&gt;#[repr(packed)]&lt;/code&gt;. See that section for how to write &lt;code&gt;drop&lt;/code&gt; in a way that the compiler can help you not accidentally break pinning.</source>
          <target state="translated">構造体のデストラクタは、構造化フィールドをその引数の外に移動してはなりません。これはで育った正確なポイントで&lt;a href=&quot;#drop-implementation&quot;&gt;、前のセクション&lt;/a&gt;： &lt;code&gt;drop&lt;/code&gt; かかる &lt;code&gt;&amp;amp;mut self&lt;/code&gt; が、構造体（ひいてはそのフィールド）が前に固定されている場合があります。 &lt;code&gt;Drop&lt;/code&gt; 実装内でフィールドを移動しないことを保証する必要があります。特に、前に説明したように、これは構造体が &lt;code&gt;#[repr(packed)]&lt;/code&gt; であってはなら&lt;em&gt;ない&lt;/em&gt;ことを意味します。コンパイラーが誤ってピン止めを解除しないように &lt;code&gt;drop&lt;/code&gt; を作成する方法については、そのセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="f85efc5c824a33e7773d4a9703af1abcf28610ef" translate="yes" xml:space="preserve">
          <source>The difference between 'the prelude' and these other preludes is that they are not automatically &lt;code&gt;use&lt;/code&gt;'d, and must be imported manually. This is still easier than importing all of their constituent components.</source>
          <target state="translated">「プレリュード」とこれらの他のプレリュードの違いは、「d」が自動的に &lt;code&gt;use&lt;/code&gt; れず、手動でインポートする必要があることです。これは、構成要素をすべてインポートするよりも簡単です。</target>
        </trans-unit>
        <trans-unit id="505a24f6c966bf30ebbdd0623555d0248f90c11b" translate="yes" xml:space="preserve">
          <source>The difference between &lt;a href=&quot;macro.unimplemented&quot;&gt;&lt;code&gt;unimplemented!&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;todo!&lt;/code&gt; is that while &lt;code&gt;todo!&lt;/code&gt; conveys an intent of implementing the functionality later and the message is &quot;not yet implemented&quot;, &lt;code&gt;unimplemented!&lt;/code&gt; makes no such claims. Its message is &quot;not implemented&quot;. Also some IDEs will mark &lt;code&gt;todo!&lt;/code&gt;s.</source>
          <target state="translated">&lt;a href=&quot;macro.unimplemented&quot;&gt; &lt;code&gt;unimplemented!&lt;/code&gt; &lt;/a&gt;の違い！そして &lt;code&gt;todo!&lt;/code&gt; それは &lt;code&gt;todo!&lt;/code&gt; 後で機能を実装する意図を伝え、メッセージは「まだ実装されていません」、 &lt;code&gt;unimplemented!&lt;/code&gt; されていません。そのような主張はしません。そのメッセージは「実装されていません」です。また、一部のIDEは &lt;code&gt;todo!&lt;/code&gt; をマークします！s。</target>
        </trans-unit>
        <trans-unit id="03297ced74ba958f935a37ee67580ef54eeb9a79" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;unimplemented!&lt;/code&gt; and &lt;a href=&quot;macro.todo&quot;&gt;&lt;code&gt;todo!&lt;/code&gt;&lt;/a&gt; is that while &lt;code&gt;todo!&lt;/code&gt; conveys an intent of implementing the functionality later and the message is &quot;not yet implemented&quot;, &lt;code&gt;unimplemented!&lt;/code&gt; makes no such claims. Its message is &quot;not implemented&quot;. Also some IDEs will mark &lt;code&gt;todo!&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;unimplemented!&lt;/code&gt; の違い！そして&lt;a href=&quot;macro.todo&quot;&gt; &lt;code&gt;todo!&lt;/code&gt; &lt;/a&gt;それは &lt;code&gt;todo!&lt;/code&gt; 後で機能を実装する意図を伝え、メッセージは「まだ実装されていません」、 &lt;code&gt;unimplemented!&lt;/code&gt; されていません。そのような主張はしません。そのメッセージは「実装されていません」です。また、一部のIDEは &lt;code&gt;todo!&lt;/code&gt; をマークします！s。</target>
        </trans-unit>
        <trans-unit id="3d53ebfe9f22c1eb14437a5afaa7bab7ac81b640" translate="yes" xml:space="preserve">
          <source>The difference is that when using generics, as in Listing 19-13, we must annotate the types in each implementation; because we can also implement &lt;code&gt;Iterator&amp;lt;String&amp;gt; for Counter&lt;/code&gt; or any other type, we could have multiple implementations of &lt;code&gt;Iterator&lt;/code&gt; for &lt;code&gt;Counter&lt;/code&gt;. In other words, when a trait has a generic parameter, it can be implemented for a type multiple times, changing the concrete types of the generic type parameters each time. When we use the &lt;code&gt;next&lt;/code&gt; method on &lt;code&gt;Counter&lt;/code&gt;, we would have to provide type annotations to indicate which implementation of &lt;code&gt;Iterator&lt;/code&gt; we want to use.</source>
          <target state="translated">違いは、リスト19-13のようにジェネリックを使用する場合、各実装で型に注釈を付ける必要があることです。我々はまた、実装することができますので、 &lt;code&gt;Iterator&amp;lt;String&amp;gt; for Counter&lt;/code&gt; 、または任意の他のタイプ、我々は複数の実装可能性があり &lt;code&gt;Iterator&lt;/code&gt; のための &lt;code&gt;Counter&lt;/code&gt; 。つまり、トレイトにジェネリックパラメータがある場合、そのタイプに対して複数回実装して、ジェネリックタイプパラメータの具象タイプを毎回変更することができます。 &lt;code&gt;Counter&lt;/code&gt; で &lt;code&gt;next&lt;/code&gt; メソッドを使用する場合、使用する &lt;code&gt;Iterator&lt;/code&gt; の実装を示す型注釈を提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="5d4f5e1a47f10d66452650a5f161fd164ebd410d" translate="yes" xml:space="preserve">
          <source>The differences about paths and the &lt;code&gt;use&lt;/code&gt; keyword between the 2015 and 2018 editions can also be found in the &lt;a href=&quot;../reference/items/use-declarations&quot;&gt;Reference&lt;/a&gt;.</source>
          <target state="translated">2015年版と2018年版のパスと &lt;code&gt;use&lt;/code&gt; キーワードの違いは、&lt;a href=&quot;../reference/items/use-declarations&quot;&gt;リファレンスに&lt;/a&gt;も記載されています。</target>
        </trans-unit>
        <trans-unit id="d9b61b2f901725762b56d16bf06bea0055df6804" translate="yes" xml:space="preserve">
          <source>The different behavior of files in the &lt;em&gt;tests&lt;/em&gt; directory is most noticeable when you have a set of helper functions that would be useful in multiple integration test files and you try to follow the steps in the &lt;a href=&quot;ch07-05-separating-modules-into-different-files&quot;&gt;&amp;ldquo;Separating Modules into Different Files&amp;rdquo;&lt;/a&gt; section of Chapter 7 to extract them into a common module. For example, if we create &lt;em&gt;tests/common.rs&lt;/em&gt; and place a function named &lt;code&gt;setup&lt;/code&gt; in it, we can add some code to &lt;code&gt;setup&lt;/code&gt; that we want to call from multiple test functions in multiple test files:</source>
          <target state="translated">&lt;em&gt;テスト&lt;/em&gt;ディレクトリ内のファイルのさまざまな動作は、複数の統合テストファイルで役立つ一連のヘルパー関数があり、第7章の&lt;a href=&quot;ch07-05-separating-modules-into-different-files&quot;&gt;「モジュールをさまざまなファイルに分割する」&lt;/a&gt;セクションの手順に従ってみると最も顕著になります。それらを共通モジュールに抽出します。たとえば、&lt;em&gt;tests / common.rs&lt;/em&gt;を作成し、その中に &lt;code&gt;setup&lt;/code&gt; という名前の関数を配置した場合、複数のテストファイルの複数のテスト関数から呼び出すコードを &lt;code&gt;setup&lt;/code&gt; に追加できます。</target>
        </trans-unit>
        <trans-unit id="d5be1c02c26fe5ef598a5696a274160d696e7977" translate="yes" xml:space="preserve">
          <source>The different meanings of &lt;code&gt;unsafe&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;unsafe&lt;/code&gt; でないことのさまざまな意味</target>
        </trans-unit>
        <trans-unit id="1fd895f49df6ac41f021206eb05bd5dfbc8e5ada" translate="yes" xml:space="preserve">
          <source>The directories and files used for loading external file modules can be influenced with the &lt;code&gt;path&lt;/code&gt; attribute.</source>
          <target state="translated">外部ファイルモジュールのロードに使用されるディレクトリとファイルは、 &lt;code&gt;path&lt;/code&gt; 属性の影響を受ける可能性があります。</target>
        </trans-unit>
        <trans-unit id="1e92ecf8e1ea3e2a6e4c02654c525e112d825547" translate="yes" xml:space="preserve">
          <source>The directory isn't empty.</source>
          <target state="translated">ディレクトリが空ではありません。</target>
        </trans-unit>
        <trans-unit id="8e9718c5436468359091854f47e29ace6b258c73" translate="yes" xml:space="preserve">
          <source>The discriminant enum from the example &lt;a href=&quot;#reprc-enums-with-fields&quot;&gt;earlier&lt;/a&gt; then becomes:</source>
          <target state="translated">&lt;a href=&quot;#reprc-enums-with-fields&quot;&gt;前&lt;/a&gt;の例の判別列挙型は次のようになります。</target>
        </trans-unit>
        <trans-unit id="5406bf9928b412a24605eecb2ec809ade9b2bfca" translate="yes" xml:space="preserve">
          <source>The discriminant of an enum variant may change if the enum definition changes. A discriminant of some variant will not change between compilations with the same compiler.</source>
          <target state="translated">enum の定義が変更された場合、enum の variant の判別子は変更される可能性があります。同じコンパイラでコンパイルしても、あるバリアントの判別子は変化しません。</target>
        </trans-unit>
        <trans-unit id="e1e71495d678a5d4be21061931a65d8862bd4e7e" translate="yes" xml:space="preserve">
          <source>The distance being in bounds cannot rely on &quot;wrapping around&quot; the address space.</source>
          <target state="translated">距離が境界内にあることは、アドレス空間の「回り込み」に頼ることはできません。</target>
        </trans-unit>
        <trans-unit id="6c785ac664fd8d2346ca1bb482fcd8b5593d6af3" translate="yes" xml:space="preserve">
          <source>The distance between the pointers, &lt;strong&gt;in bytes&lt;/strong&gt;, cannot overflow an &lt;code&gt;isize&lt;/code&gt;.</source>
          <target state="translated">ポインター間の距離&lt;strong&gt;（バイト単位&lt;/strong&gt;）は、 &lt;code&gt;isize&lt;/code&gt; をオーバーフローできません。</target>
        </trans-unit>
        <trans-unit id="bd1487c3b6f63cdfefd3896403e040d0a14037e5" translate="yes" xml:space="preserve">
          <source>The distance between the pointers, in bytes, must be an exact multiple of the size of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">ポインター間の距離（バイト単位）は、 &lt;code&gt;T&lt;/code&gt; のサイズの正確な倍数でなければなりません。</target>
        </trans-unit>
        <trans-unit id="c85eee3f8fcb1e3d7acfa8c71113a8ed01e9b6ce" translate="yes" xml:space="preserve">
          <source>The division assignment operator &lt;code&gt;/=&lt;/code&gt;.</source>
          <target state="translated">除算代入演算子 &lt;code&gt;/=&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fac0cbbb13a4ae4385140ac3ccea99961d57c224" translate="yes" xml:space="preserve">
          <source>The division operator &lt;code&gt;/&lt;/code&gt;.</source>
          <target state="translated">除算演算子 &lt;code&gt;/&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d4bae769945be3db52fcb8fef6b0f5ad9c54eef4" translate="yes" xml:space="preserve">
          <source>The documentation for this keyword is &lt;a href=&quot;https://github.com/rust-lang/rust/issues/34601&quot;&gt;not yet complete&lt;/a&gt;. Pull requests welcome!</source>
          <target state="translated">このキーワードのドキュメント&lt;a href=&quot;https://github.com/rust-lang/rust/issues/34601&quot;&gt;はまだ完全で&lt;/a&gt;はありません。プルリクエストは大歓迎です！</target>
        </trans-unit>
        <trans-unit id="7092af2bcd91c441c2dfc4c8d572a11dfce60e91" translate="yes" xml:space="preserve">
          <source>The double colon (&lt;code&gt;::&lt;/code&gt;) is an operator that allows us to namespace this particular &lt;code&gt;from&lt;/code&gt; function under the &lt;code&gt;String&lt;/code&gt; type rather than using some sort of name like &lt;code&gt;string_from&lt;/code&gt;. We&amp;rsquo;ll discuss this syntax more in the &lt;a href=&quot;ch05-03-method-syntax#method-syntax&quot;&gt;&amp;ldquo;Method Syntax&amp;rdquo;&lt;/a&gt; section of Chapter 5 and when we talk about namespacing with modules in &lt;a href=&quot;ch07-03-paths-for-referring-to-an-item-in-the-module-tree&quot;&gt;&amp;ldquo;Paths for Referring to an Item in the Module Tree&amp;rdquo;&lt;/a&gt; in Chapter 7.</source>
          <target state="translated">二重コロン（ &lt;code&gt;::&lt;/code&gt; :）は、 &lt;code&gt;string_from&lt;/code&gt; のような名前を使用するのではなく、 &lt;code&gt;String&lt;/code&gt; タイプの下でこの特定の &lt;code&gt;from&lt;/code&gt; 関数の名前空間を作成できるようにする演算子です。この構文については、第5章の&lt;a href=&quot;ch05-03-method-syntax#method-syntax&quot;&gt;「メソッド構文」&lt;/a&gt;セクションと、第7章の&lt;a href=&quot;ch07-03-paths-for-referring-to-an-item-in-the-module-tree&quot;&gt;「モジュールツリーでアイテムを参照するためのパス」&lt;/a&gt;でモジュールの名前空間について説明するときに詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="27b2d1743e157ab144583c8c6b85ea9ad0092f0b" translate="yes" xml:space="preserve">
          <source>The downside of using &lt;code&gt;if let&lt;/code&gt; expressions is that the compiler doesn&amp;rsquo;t check exhaustiveness, whereas with &lt;code&gt;match&lt;/code&gt; expressions it does. If we omitted the last &lt;code&gt;else&lt;/code&gt; block and therefore missed handling some cases, the compiler would not alert us to the possible logic bug.</source>
          <target state="translated">&lt;code&gt;if let&lt;/code&gt; 式を使用することの欠点は、コンパイラが網羅性をチェックしないのに対し、 &lt;code&gt;match&lt;/code&gt; 式ではチェックすることです。最後の &lt;code&gt;else&lt;/code&gt; ブロックを省略したために一部のケースを処理しなかった場合、コンパイラーはロジックバグの可能性について警告しません。</target>
        </trans-unit>
        <trans-unit id="e387e6a833f24807236bb7fd7266c18e39a1df6d" translate="yes" xml:space="preserve">
          <source>The downside of using this technique is that &lt;code&gt;Wrapper&lt;/code&gt; is a new type, so it doesn&amp;rsquo;t have the methods of the value it&amp;rsquo;s holding. We would have to implement all the methods of &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; directly on &lt;code&gt;Wrapper&lt;/code&gt; such that the methods delegate to &lt;code&gt;self.0&lt;/code&gt;, which would allow us to treat &lt;code&gt;Wrapper&lt;/code&gt; exactly like a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;. If we wanted the new type to have every method the inner type has, implementing the &lt;code&gt;Deref&lt;/code&gt; trait (discussed in Chapter 15 in the &lt;a href=&quot;ch15-02-deref#treating-smart-pointers-like-regular-references-with-the-deref-trait&quot;&gt;&amp;ldquo;Treating Smart Pointers Like Regular References with the &lt;code&gt;Deref&lt;/code&gt; Trait&amp;rdquo;&lt;/a&gt; section) on the &lt;code&gt;Wrapper&lt;/code&gt; to return the inner type would be a solution. If we don&amp;rsquo;t want the &lt;code&gt;Wrapper&lt;/code&gt; type to have all the methods of the inner type&amp;mdash;for example, to restrict the &lt;code&gt;Wrapper&lt;/code&gt; type&amp;rsquo;s behavior&amp;mdash;we would have to implement just the methods we do want manually.</source>
          <target state="translated">この手法を使用することの欠点は、 &lt;code&gt;Wrapper&lt;/code&gt; が新しい型であるため、保持する値のメソッドがないことです。我々は、すべてのメソッドを実装する必要があります &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 直接の &lt;code&gt;Wrapper&lt;/code&gt; メソッドがに委譲するように &lt;code&gt;self.0&lt;/code&gt; 私たちが治療できるようになる、 &lt;code&gt;Wrapper&lt;/code&gt; 正確に同じよう &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 。私たちは、インナータイプが持つすべてのメソッド、実装持っている新しいタイプのを望んでいた場合は &lt;code&gt;Deref&lt;/code&gt; 形質を（で第15章で説明する&lt;a href=&quot;ch15-02-deref#treating-smart-pointers-like-regular-references-with-the-deref-trait&quot;&gt;「で処理するスマートポインタのような正規参照 &lt;code&gt;Deref&lt;/code&gt; 形質」&lt;/a&gt;のセクション） &lt;code&gt;Wrapper&lt;/code&gt; 内部の型を返すことは解決策でしょう。 &lt;code&gt;Wrapper&lt;/code&gt; タイプに内部タイプのすべてのメソッドを持たせたくない場合（たとえば、 &lt;code&gt;Wrapper&lt;/code&gt; タイプの動作を制限するため）、必要なメソッドのみを手動で実装する必要があります。</target>
        </trans-unit>
        <trans-unit id="0e7aa88c59ccdb8f5ae43f1abe07297a4d7ace58" translate="yes" xml:space="preserve">
          <source>The downside to implementing a macro instead of a function is that macro definitions are more complex than function definitions because you&amp;rsquo;re writing Rust code that writes Rust code. Due to this indirection, macro definitions are generally more difficult to read, understand, and maintain than function definitions.</source>
          <target state="translated">関数ではなくマクロを実装することの欠点は、Rustコードを記述するRustコードを記述しているため、マクロ定義が関数定義よりも複雑になることです。この間接的な理由により、マクロ定義は一般に、関数定義よりも読み取り、理解、維持が困難です。</target>
        </trans-unit>
        <trans-unit id="719fc8d49d59015d6dffe7ccc55e5816d1966b0e" translate="yes" xml:space="preserve">
          <source>The duration of one microsecond.</source>
          <target state="translated">1マイクロ秒の持続時間。</target>
        </trans-unit>
        <trans-unit id="e68beeeb11183a3ff18abb9e6896356e66b6200f" translate="yes" xml:space="preserve">
          <source>The duration of one millisecond.</source>
          <target state="translated">1ミリ秒の持続時間。</target>
        </trans-unit>
        <trans-unit id="e9d186359c1c80de39171fea4281a767f86db9c5" translate="yes" xml:space="preserve">
          <source>The duration of one nanosecond.</source>
          <target state="translated">1ナノ秒の持続時間。</target>
        </trans-unit>
        <trans-unit id="926b58a37c99c224d9cf0ad023e9e79f2bae5af3" translate="yes" xml:space="preserve">
          <source>The duration of one second.</source>
          <target state="translated">1秒の持続時間。</target>
        </trans-unit>
        <trans-unit id="51e82336197f20c9062a20d4490259f940ada0fe" translate="yes" xml:space="preserve">
          <source>The easiest fix is to rewrite your closure into a top-level function, or into a method. In some cases, you may also be able to have your closure call itself by capturing a &lt;code&gt;&amp;amp;Fn()&lt;/code&gt; object or &lt;code&gt;fn()&lt;/code&gt; pointer that refers to itself. That is permitting, since the closure would be invoking itself via a virtual call, and hence does not directly reference its own &lt;em&gt;type&lt;/em&gt;.</source>
          <target state="translated">最も簡単な修正は、クロージャをトップレベルの関数またはメソッドに書き直すことです。場合によっては、 &lt;code&gt;&amp;amp;Fn()&lt;/code&gt; オブジェクトまたはそれ自体を参照する &lt;code&gt;fn()&lt;/code&gt; ポインターをキャプチャーすることにより、クロージャー自体を呼び出すこともできます。クロージャは仮想呼び出しを介してそれ自体を呼び出すため、それ自体は許可されています。したがって、クロージャはそれ自体の&lt;em&gt;タイプを&lt;/em&gt;直接参照しません。</target>
        </trans-unit>
        <trans-unit id="8b90152377c4d2fa6a58836b95414b3c64c66683" translate="yes" xml:space="preserve">
          <source>The easiest way to use &lt;code&gt;HashMap&lt;/code&gt; with a custom key type is to derive &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt;. We must also derive &lt;a href=&quot;../../cmp/trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">カスタムキータイプで &lt;code&gt;HashMap&lt;/code&gt; を使用する最も簡単な方法は、&lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt;を派生させることです。&lt;a href=&quot;../../cmp/trait.partialeq&quot;&gt; &lt;code&gt;PartialEq&lt;/code&gt; &lt;/a&gt;も導出する必要があります。</target>
        </trans-unit>
        <trans-unit id="8fdc4a2a7876216a8a5156bcc124c1c5c1d13c54" translate="yes" xml:space="preserve">
          <source>The easiest way to use &lt;code&gt;HashMap&lt;/code&gt; with a custom key type is to derive &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt;. We must also derive &lt;a href=&quot;../cmp/trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">カスタムキータイプで &lt;code&gt;HashMap&lt;/code&gt; を使用する最も簡単な方法は、&lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt;を派生させることです。&lt;a href=&quot;../cmp/trait.partialeq&quot;&gt; &lt;code&gt;PartialEq&lt;/code&gt; &lt;/a&gt;も導出する必要があります。</target>
        </trans-unit>
        <trans-unit id="2b835cd73ddea2cd4aee637c4f9c2cd855ee696f" translate="yes" xml:space="preserve">
          <source>The easiest way to use &lt;code&gt;HashSet&lt;/code&gt; with a custom type is to derive &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt;. We must also derive &lt;a href=&quot;../../cmp/trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;, this will in the future be implied by &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">カスタムタイプで &lt;code&gt;HashSet&lt;/code&gt; を使用する最も簡単な方法は、&lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt;を派生させることです。&lt;a href=&quot;../../cmp/trait.partialeq&quot;&gt; &lt;code&gt;PartialEq&lt;/code&gt; &lt;/a&gt;も導出する必要があります。これは、将来&lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt;によって暗示される予定です。</target>
        </trans-unit>
        <trans-unit id="bcd32a61d8029373ce3811b4c81b01b04e2fcd8a" translate="yes" xml:space="preserve">
          <source>The easiest way to use &lt;code&gt;HashSet&lt;/code&gt; with a custom type is to derive &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt;. We must also derive &lt;a href=&quot;../cmp/trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;, this will in the future be implied by &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">カスタムタイプで &lt;code&gt;HashSet&lt;/code&gt; を使用する最も簡単な方法は、&lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt;を派生させることです。&lt;a href=&quot;../cmp/trait.partialeq&quot;&gt; &lt;code&gt;PartialEq&lt;/code&gt; &lt;/a&gt;も導出する必要があります。これは、将来&lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt;によって暗示される予定です。</target>
        </trans-unit>
        <trans-unit id="4abca09eae529f079207e693c4204e4240160458" translate="yes" xml:space="preserve">
          <source>The element range is removed even if the iterator is not consumed until the end.</source>
          <target state="translated">最後までイテレータが消費されない場合でも、要素範囲は削除されます。</target>
        </trans-unit>
        <trans-unit id="857f1367d5858bf310bc19ad475cfec76822e623" translate="yes" xml:space="preserve">
          <source>The element that was removed is returned, and the cursor is moved to point to the next element in the &lt;code&gt;LinkedList&lt;/code&gt;.</source>
          <target state="translated">削除された要素が返され、カーソルが &lt;code&gt;LinkedList&lt;/code&gt; 内の次の要素を指すように移動されます。</target>
        </trans-unit>
        <trans-unit id="17d488f8279ef9d0e051cac2f43dff0a68f18b2b" translate="yes" xml:space="preserve">
          <source>The elements are removed in arbitrary order.</source>
          <target state="translated">要素は任意の順番で削除されます。</target>
        </trans-unit>
        <trans-unit id="5fe5f813b6a2f233abc73bad03a94ec158695239" translate="yes" xml:space="preserve">
          <source>The elements at &lt;code&gt;old_len..new_len&lt;/code&gt; must be initialized.</source>
          <target state="translated">&lt;code&gt;old_len..new_len&lt;/code&gt; の要素を初期化する必要があります。</target>
        </trans-unit>
        <trans-unit id="2bafc31dee9d33ba4d10ed67ef0f71ab38bfff69" translate="yes" xml:space="preserve">
          <source>The elements of an &lt;a href=&quot;types/array&quot;&gt;array&lt;/a&gt; or owned &lt;a href=&quot;types/array&quot;&gt;slice&lt;/a&gt; are dropped from the first element to the last. *</source>
          <target state="translated">&lt;a href=&quot;types/array&quot;&gt;配列&lt;/a&gt;または所有されている&lt;a href=&quot;types/array&quot;&gt;スライス&lt;/a&gt;の要素は、最初の要素から最後の要素にドロップされます。*</target>
        </trans-unit>
        <trans-unit id="1e3e69cc26857f9c1293b40c529b047e54164338" translate="yes" xml:space="preserve">
          <source>The elements of an &lt;a href=&quot;types/array&quot;&gt;array&lt;/a&gt; or owned &lt;a href=&quot;types/slice&quot;&gt;slice&lt;/a&gt; are dropped from the first element to the last.</source>
          <target state="translated">&lt;a href=&quot;types/array&quot;&gt;配列&lt;/a&gt;または所有&lt;a href=&quot;types/slice&quot;&gt;スライス&lt;/a&gt;の要素は、最初の要素から最後の要素にドロップされます。</target>
        </trans-unit>
        <trans-unit id="2aa9bb19de05cfdf90da669db74c8f4ff87b16d5" translate="yes" xml:space="preserve">
          <source>The elements yielded by &lt;code&gt;DoubleEndedIterator&lt;/code&gt;'s methods may differ from the ones yielded by &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;'s methods:</source>
          <target state="translated">得られた要素 &lt;code&gt;DoubleEndedIterator&lt;/code&gt; の方法は、により得られたものと異なる場合があり&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;のメソッド'：</target>
        </trans-unit>
        <trans-unit id="88efd616f1a1b2e8d8f2dcc3a848a8c623471404" translate="yes" xml:space="preserve">
          <source>The elision rules don&amp;rsquo;t provide full inference. If Rust deterministically applies the rules but there is still ambiguity as to what lifetimes the references have, the compiler won&amp;rsquo;t guess what the lifetime of the remaining references should be. In this case, instead of guessing, the compiler will give you an error that you can resolve by adding the lifetime annotations that specify how the references relate to each other.</source>
          <target state="translated">省略ルールは完全な推論を提供しません。Rustがルールを確定的に適用しても、参照のライフタイムについてあいまいさが残っている場合、コンパイラーは残りの参照のライフタイムを推測しません。この場合、推測する代わりに、コンパイラーは、参照が相互にどのように関連するかを指定する存続期間アノテーションを追加することで解決できるエラーを提供します。</target>
        </trans-unit>
        <trans-unit id="3e3b658969dac70797ae99e22406a5919df5b0c6" translate="yes" xml:space="preserve">
          <source>The entire expression uses the given values for the fields that were specified and moves or copies the remaining fields from the base expression. As with all struct expressions, all of the fields of the struct must be &lt;a href=&quot;../visibility-and-privacy&quot;&gt;visible&lt;/a&gt;, even those not explicitly named.</source>
          <target state="translated">式全体では、指定されたフィールドに指定された値を使用し、残りのフィールドを基本式から移動またはコピーします。すべての構造体式と同様に、明示的に名前が付けられていないフィールドであっても、構造体のすべてのフィールドが&lt;a href=&quot;../visibility-and-privacy&quot;&gt;可視&lt;/a&gt;でなければなりません。</target>
        </trans-unit>
        <trans-unit id="a0574dfce03935016b1e7370699d140878e68385" translate="yes" xml:space="preserve">
          <source>The entire file name if the file name begins with &lt;code&gt;.&lt;/code&gt; and has no other &lt;code&gt;.&lt;/code&gt;s within;</source>
          <target state="translated">ファイル名がで始まる場合は、ファイル名全体 &lt;code&gt;.&lt;/code&gt; 他にありません &lt;code&gt;.&lt;/code&gt; s内;</target>
        </trans-unit>
        <trans-unit id="e83cf0228defdcd6e7afea0984d3278d36eab74c" translate="yes" xml:space="preserve">
          <source>The entire file name if there is no embedded &lt;code&gt;.&lt;/code&gt;;</source>
          <target state="translated">埋め込まれていない場合はファイル名全体 &lt;code&gt;.&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="3fa274546f438640798ab62aae39ac18398db5cc" translate="yes" xml:space="preserve">
          <source>The entire function</source>
          <target state="translated">全体の機能</target>
        </trans-unit>
        <trans-unit id="8a5d709e7f69a77cb8061cae38e47a941e97332f" translate="yes" xml:space="preserve">
          <source>The entire function body.</source>
          <target state="translated">機能体全体のこと。</target>
        </trans-unit>
        <trans-unit id="5c15c39c685d0906fec325e3d5c2bea1c6eb708a" translate="yes" xml:space="preserve">
          <source>The entire function scope is the outer most scope.</source>
          <target state="translated">関数スコープ全体が最も外側のスコープになります。</target>
        </trans-unit>
        <trans-unit id="9b8eedec31f30287b3b74ad1f2675a525e2c3cf5" translate="yes" xml:space="preserve">
          <source>The entire hash map is generic over a key type &lt;code&gt;K&lt;/code&gt;. Because these keys are stored with the hash map, this type has to own the key&amp;rsquo;s data. When inserting a key-value pair, the map is given such a &lt;code&gt;K&lt;/code&gt; and needs to find the correct hash bucket and check if the key is already present based on that &lt;code&gt;K&lt;/code&gt;. It therefore requires &lt;code&gt;K: Hash + Eq&lt;/code&gt;.</source>
          <target state="translated">ハッシュマップ全体は、キータイプ &lt;code&gt;K&lt;/code&gt; について総称です。これらのキーはハッシュマップと共に格納されるため、このタイプはキーのデータを所有する必要があります。キーと値のペアを挿入すると、マップにはそのような &lt;code&gt;K&lt;/code&gt; が与えられ、正しいハッシュバケットを見つけて、その &lt;code&gt;K&lt;/code&gt; に基づいてキーがすでに存在するかどうかを確認する必要があります。したがって、 &lt;code&gt;K: Hash + Eq&lt;/code&gt; が必要です。</target>
        </trans-unit>
        <trans-unit id="0297c1c788a21e67f6b7fde15406ec3888485937" translate="yes" xml:space="preserve">
          <source>The entire memory range of this slice must be contained within a single allocated object! Slices can never span across multiple allocated objects.</source>
          <target state="translated">このスライスのメモリ範囲全体が単一の割り当てられたオブジェクトに含まれていなければなりません。スライスが複数の割り当てられたオブジェクトにまたがることはありません。</target>
        </trans-unit>
        <trans-unit id="d250d768cfabd095635656557072ab76a1e3cbad" translate="yes" xml:space="preserve">
          <source>The entire memory range of this slice must be contained within a single allocated object! Slices can never span across multiple allocated objects. See &lt;a href=&quot;#incorrect-usage&quot;&gt;below&lt;/a&gt; for an example incorrectly not taking this into account.</source>
          <target state="translated">このスライスのメモリ範囲全体は、割り当てられた単一のオブジェクト内に含まれている必要があります。スライスは、割り当てられた複数のオブジェクトにまたがることはできません。これを誤って考慮していない例については、&lt;a href=&quot;#incorrect-usage&quot;&gt;以下&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="97dea0260f138033ef7cf2f5ca57a634d6eea616" translate="yes" xml:space="preserve">
          <source>The entry point of the program was marked as &lt;code&gt;async&lt;/code&gt;.</source>
          <target state="translated">プログラムのエントリポイントは &lt;code&gt;async&lt;/code&gt; としてマークされました。</target>
        </trans-unit>
        <trans-unit id="82f98df6718e5a9d6fd411d1cc853597af7467ed" translate="yes" xml:space="preserve">
          <source>The error and the note tell the story: Rust strings don&amp;rsquo;t support indexing. But why not? To answer that question, we need to discuss how Rust stores strings in memory.</source>
          <target state="translated">エラーとメモが物語を物語っています：Rust文字列はインデックス作成をサポートしていません。しかし、なぜですか？その質問に答えるために、Rustが文字列をメモリに格納する方法について説明する必要があります。</target>
        </trans-unit>
        <trans-unit id="41a72aa86a9d9e55bed7f9841f1b9fdc25696e6c" translate="yes" xml:space="preserve">
          <source>The error happens on numeric literals and on numeric bindings without an identified concrete type:</source>
          <target state="translated">このエラーは、数値リテラルと、識別された具象型のない数値バインディングで発生します。</target>
        </trans-unit>
        <trans-unit id="1decc58ff466451824639b9b2033b046dfa94fee" translate="yes" xml:space="preserve">
          <source>The error happens on numeric literals:</source>
          <target state="translated">このエラーは数値リテラルで発生します。</target>
        </trans-unit>
        <trans-unit id="39121a17de405ba30c8238c549d55b70becaf449" translate="yes" xml:space="preserve">
          <source>The error indicates that Rust expected a &lt;code&gt;bool&lt;/code&gt; but got an integer. Unlike languages such as Ruby and JavaScript, Rust will not automatically try to convert non-Boolean types to a Boolean. You must be explicit and always provide &lt;code&gt;if&lt;/code&gt; with a Boolean as its condition. If we want the &lt;code&gt;if&lt;/code&gt; code block to run only when a number is not equal to &lt;code&gt;0&lt;/code&gt;, for example, we can change the &lt;code&gt;if&lt;/code&gt; expression to the following:</source>
          <target state="translated">このエラーは、Rustが &lt;code&gt;bool&lt;/code&gt; 期待していたが整数を取得したことを示しています。RubyやJavaScriptなどの言語とは異なり、Rustは非ブール型をブール型に自動的に変換しようとしません。明示的である必要があり、条件としてブール値を使用する &lt;code&gt;if&lt;/code&gt; は常に提供する必要があります。たとえば、数値が &lt;code&gt;0&lt;/code&gt; でない場合にのみ &lt;code&gt;if&lt;/code&gt; コードブロックを実行する場合は、 &lt;code&gt;if&lt;/code&gt; 式を次のように変更できます。</target>
        </trans-unit>
        <trans-unit id="82fe814b563c83c1ad42c2a44464d60e45abeb59" translate="yes" xml:space="preserve">
          <source>The error message indicates that the cause of the error is that you &lt;code&gt;cannot assign twice to immutable variable x&lt;/code&gt;, because you tried to assign a second value to the immutable &lt;code&gt;x&lt;/code&gt; variable.</source>
          <target state="translated">エラーメッセージは、エラーの原因は、あなたがいることであることを示し &lt;code&gt;cannot assign twice to immutable variable x&lt;/code&gt; あなたは不変に第2の値を割り当てようとしましたので、 &lt;code&gt;x&lt;/code&gt; 変数。</target>
        </trans-unit>
        <trans-unit id="1acd99d552c691a91137d21fedf0cc394ac8a4d0" translate="yes" xml:space="preserve">
          <source>The error message states that the &lt;code&gt;counter&lt;/code&gt; value is moved into the closure and then captured when we call &lt;code&gt;lock&lt;/code&gt;. That description sounds like what we wanted, but it&amp;rsquo;s not allowed!</source>
          <target state="translated">エラーメッセージは、 &lt;code&gt;counter&lt;/code&gt; 値がクロージャーに移動され、 &lt;code&gt;lock&lt;/code&gt; を呼び出すときにキャプチャされることを示しています。その説明は私たちが望んでいたように聞こえますが、許可されていません！</target>
        </trans-unit>
        <trans-unit id="5bb7a0ad71457e0f1d6ce226ce7b55ec5697ceba" translate="yes" xml:space="preserve">
          <source>The error message states that the &lt;code&gt;counter&lt;/code&gt; value was moved in the previous iteration of the loop. So Rust is telling us that we can&amp;rsquo;t move the ownership of lock &lt;code&gt;counter&lt;/code&gt; into multiple threads. Let&amp;rsquo;s fix the compiler error with a multiple-ownership method we discussed in Chapter 15.</source>
          <target state="translated">エラーメッセージは、 &lt;code&gt;counter&lt;/code&gt; 値がループの前の反復で移動されたことを示しています。したがって、Rustは、ロック &lt;code&gt;counter&lt;/code&gt; の所有権を複数のスレッドに移動することはできないと言っています。第15章で説明した複数所有権メソッドを使用してコンパイラエラーを修正しましょう。</target>
        </trans-unit>
        <trans-unit id="6326b5d7f5ddab487c6090e5e84a18d25a0a3db6" translate="yes" xml:space="preserve">
          <source>The error messages say that module &lt;code&gt;hosting&lt;/code&gt; is private. In other words, we have the correct paths for the &lt;code&gt;hosting&lt;/code&gt; module and the &lt;code&gt;add_to_waitlist&lt;/code&gt; function, but Rust won&amp;rsquo;t let us use them because it doesn&amp;rsquo;t have access to the private sections.</source>
          <target state="translated">エラーメッセージは、モジュール &lt;code&gt;hosting&lt;/code&gt; がプライベートであることを示しています。つまり、 &lt;code&gt;hosting&lt;/code&gt; モジュールと &lt;code&gt;add_to_waitlist&lt;/code&gt; 関数の正しいパスがありますが、Rustはプライベートセクションにアクセスできないため、それらを使用できません。</target>
        </trans-unit>
        <trans-unit id="8eb6e3e38ad85be87f507639136fdec21b108288" translate="yes" xml:space="preserve">
          <source>The error occurs because &lt;code&gt;foo&lt;/code&gt; accepts a closure that takes an &lt;code&gt;i32&lt;/code&gt; argument, but in &lt;code&gt;main&lt;/code&gt;, it is passed a closure with a &lt;code&gt;&amp;amp;str&lt;/code&gt; argument.</source>
          <target state="translated">このエラーは、 &lt;code&gt;foo&lt;/code&gt; が &lt;code&gt;i32&lt;/code&gt; 引数を取るクロージャを受け入れるために発生しますが、 &lt;code&gt;main&lt;/code&gt; では、 &lt;code&gt;&amp;amp;str&lt;/code&gt; 引数を持つクロージャが渡されます。</target>
        </trans-unit>
        <trans-unit id="4df536d23e48c26eec2d844083fbc5169ab15de6" translate="yes" xml:space="preserve">
          <source>The error occurs because keyword &lt;code&gt;yield&lt;/code&gt; can only be used inside the generator literal. This can be fixed by constructing the generator correctly.</source>
          <target state="translated">キーワード &lt;code&gt;yield&lt;/code&gt; はジェネレータリテラル内でのみ使用できるため、エラーが発生します。これは、ジェネレーターを正しく構築することで修正できます。</target>
        </trans-unit>
        <trans-unit id="5bce45a967fbcca42003bd3fc6c351711632526a" translate="yes" xml:space="preserve">
          <source>The error references the &lt;code&gt;Sized&lt;/code&gt; trait again! Rust doesn&amp;rsquo;t know how much space it will need to store the closure. We saw a solution to this problem earlier. We can use a trait object:</source>
          <target state="translated">エラーは再び &lt;code&gt;Sized&lt;/code&gt; トレイトを参照しています！Rustは、クロージャーを保管するために必要なスペースを知りません。この問題の解決策は先に見ました。トレイトオブジェクトを使用できます。</target>
        </trans-unit>
        <trans-unit id="687172b839a6f9ace430c7922b4119fecbbc273c" translate="yes" xml:space="preserve">
          <source>The error says we&amp;rsquo;re not allowed to mutate a variable&amp;rsquo;s type:</source>
          <target state="translated">エラーは、変数の型を変更することが許可されていないことを示しています。</target>
        </trans-unit>
        <trans-unit id="4c799801c95c3499262c7f795808c56dd04d3f03" translate="yes" xml:space="preserve">
          <source>The error shows that for &lt;code&gt;result&lt;/code&gt; to be valid for the &lt;code&gt;println!&lt;/code&gt; statement, &lt;code&gt;string2&lt;/code&gt; would need to be valid until the end of the outer scope. Rust knows this because we annotated the lifetimes of the function parameters and return values using the same lifetime parameter &lt;code&gt;'a&lt;/code&gt;.</source>
          <target state="translated">エラーは、 &lt;code&gt;result&lt;/code&gt; が &lt;code&gt;println!&lt;/code&gt; に対して有効であることを示しています！ステートメント、 &lt;code&gt;string2&lt;/code&gt; は、外部スコープの終わりまで有効である必要があります。関数のパラメーターのライフタイムに注釈を付け、同じライフタイムパラメーター &lt;code&gt;'a&lt;/code&gt; を使用して値を返すため、Rustはこれを知っています。</target>
        </trans-unit>
        <trans-unit id="81dd6345e63f7b9b970ec324dc927c2a78ce87e8" translate="yes" xml:space="preserve">
          <source>The error shows that you can&amp;rsquo;t use the keyword &lt;code&gt;match&lt;/code&gt; as the function identifier. To use &lt;code&gt;match&lt;/code&gt; as a function name, you need to use the raw identifier syntax, like this:</source>
          <target state="translated">エラーは、関数 &lt;code&gt;match&lt;/code&gt; としてキーワードマッチを使用できないことを示しています。使用に &lt;code&gt;match&lt;/code&gt; 関数名として、あなたはこのように、生の識別子の構文を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="17031b6288809d4b66c77a71348fe05200b2e1e5" translate="yes" xml:space="preserve">
          <source>The error shows this type &amp;ldquo;has infinite size.&amp;rdquo; The reason is that we&amp;rsquo;ve defined &lt;code&gt;List&lt;/code&gt; with a variant that is recursive: it holds another value of itself directly. As a result, Rust can&amp;rsquo;t figure out how much space it needs to store a &lt;code&gt;List&lt;/code&gt; value. Let&amp;rsquo;s break down why we get this error a bit. First, let&amp;rsquo;s look at how Rust decides how much space it needs to store a value of a non-recursive type.</source>
          <target state="translated">エラーは、このタイプが「無限のサイズを持っている」ことを示しています。その理由は、再帰的なバリアントを使用して &lt;code&gt;List&lt;/code&gt; を定義したためです。それは、それ自体の別の値を直接保持します。その結果、Rustは &lt;code&gt;List&lt;/code&gt; 値を格納するために必要なスペースを把握できません。このエラーが少し発生する理由を分析してみましょう。最初に、Rustが非再帰型の値を格納するために必要なスペースをどのように決定するかを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="ddd69ec9cc85fcc63997c43bed364cf16ee6b3f9" translate="yes" xml:space="preserve">
          <source>The error tells us we can&amp;rsquo;t call &lt;code&gt;join&lt;/code&gt; because we only have a mutable borrow of each &lt;code&gt;worker&lt;/code&gt; and &lt;code&gt;join&lt;/code&gt; takes ownership of its argument. To solve this issue, we need to move the thread out of the &lt;code&gt;Worker&lt;/code&gt; instance that owns &lt;code&gt;thread&lt;/code&gt; so &lt;code&gt;join&lt;/code&gt; can consume the thread. We did this in Listing 17-15: if &lt;code&gt;Worker&lt;/code&gt; holds an &lt;code&gt;Option&amp;lt;thread::JoinHandle&amp;lt;()&amp;gt;&amp;gt;&lt;/code&gt; instead, we can call the &lt;code&gt;take&lt;/code&gt; method on the &lt;code&gt;Option&lt;/code&gt; to move the value out of the &lt;code&gt;Some&lt;/code&gt; variant and leave a &lt;code&gt;None&lt;/code&gt; variant in its place. In other words, a &lt;code&gt;Worker&lt;/code&gt; that is running will have a &lt;code&gt;Some&lt;/code&gt; variant in &lt;code&gt;thread&lt;/code&gt;, and when we want to clean up a &lt;code&gt;Worker&lt;/code&gt;, we&amp;rsquo;ll replace &lt;code&gt;Some&lt;/code&gt; with &lt;code&gt;None&lt;/code&gt; so the &lt;code&gt;Worker&lt;/code&gt; doesn&amp;rsquo;t have a thread to run.</source>
          <target state="translated">エラーは、各 &lt;code&gt;worker&lt;/code&gt; 変更可能な借用のみがあり、 &lt;code&gt;join&lt;/code&gt; がその引数の所有権を取得 &lt;code&gt;join&lt;/code&gt; ため、joinを呼び出すことができないことを示しています。この問題を解決するために、我々は外にスレッドを移動する必要がある &lt;code&gt;Worker&lt;/code&gt; 所有しているインスタンス &lt;code&gt;thread&lt;/code&gt; そう &lt;code&gt;join&lt;/code&gt; スレッドを消費することができます。私たちは、リスト17-15でこれをやった次の場合 &lt;code&gt;Worker&lt;/code&gt; 保持している &lt;code&gt;Option&amp;lt;thread::JoinHandle&amp;lt;()&amp;gt;&amp;gt;&lt;/code&gt; 代わりに、我々は呼び出すことができ &lt;code&gt;take&lt;/code&gt; のメソッド &lt;code&gt;Option&lt;/code&gt; の値を移動するには &lt;code&gt;Some&lt;/code&gt; 変種と残し &lt;code&gt;None&lt;/code&gt; でバリアントをその場所。つまり、 &lt;code&gt;Worker&lt;/code&gt; その実行 &lt;code&gt;Some&lt;/code&gt; は &lt;code&gt;thread&lt;/code&gt; にSomeバリアントがあり、 &lt;code&gt;Worker&lt;/code&gt; をクリーンアップする場合は、 &lt;code&gt;Some&lt;/code&gt; を &lt;code&gt;None&lt;/code&gt; に置き換えて、 &lt;code&gt;Worker&lt;/code&gt; が実行するスレッドがないようにします。</target>
        </trans-unit>
        <trans-unit id="58b8d8f068cf467e7f55c896bbdf137f3a755bf5" translate="yes" xml:space="preserve">
          <source>The error type for &lt;code&gt;try_reserve&lt;/code&gt; methods.</source>
          <target state="translated">&lt;code&gt;try_reserve&lt;/code&gt; メソッドのエラータイプ。</target>
        </trans-unit>
        <trans-unit id="458fb320b83d2d5563146d6c64a5e9086c1cdbe5" translate="yes" xml:space="preserve">
          <source>The error type for I/O operations of the &lt;a href=&quot;trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;trait.write&quot;&gt;&lt;code&gt;Write&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;trait.seek&quot;&gt;&lt;code&gt;Seek&lt;/code&gt;&lt;/a&gt;, and associated traits.</source>
          <target state="translated">&lt;a href=&quot;trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;trait.write&quot;&gt; &lt;code&gt;Write&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;trait.seek&quot;&gt; &lt;code&gt;Seek&lt;/code&gt; &lt;/a&gt;、および関連するトレイトのI / O操作のエラータイプ。</target>
        </trans-unit>
        <trans-unit id="3e8c3a7432541c640c48492379ea610ecb40f6ae" translate="yes" xml:space="preserve">
          <source>The error type for errors that can never happen.</source>
          <target state="translated">絶対に起こらないエラーのエラータイプです。</target>
        </trans-unit>
        <trans-unit id="fdb319ec59d1f1964ec642ac851b7301cdf60e57" translate="yes" xml:space="preserve">
          <source>The error type for operations interacting with environment variables. Possibly returned from &lt;a href=&quot;fn.var&quot;&gt;&lt;code&gt;env::var()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">環境変数と相互作用する操作のエラータイプ。&lt;a href=&quot;fn.var&quot;&gt; &lt;code&gt;env::var()&lt;/code&gt; &lt;/a&gt;から返される可能性があります。</target>
        </trans-unit>
        <trans-unit id="751842d7baf0779231030e01a15db69a4f03c6bc" translate="yes" xml:space="preserve">
          <source>The error type for operations interacting with environment variables. Possibly returned from the &lt;a href=&quot;fn.var&quot;&gt;&lt;code&gt;env::var&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">環境変数と相互作用する操作のエラータイプ。&lt;a href=&quot;fn.var&quot;&gt; &lt;code&gt;env::var&lt;/code&gt; &lt;/a&gt;関数から返された可能性があります。</target>
        </trans-unit>
        <trans-unit id="11ea1ae6c021101c095eab4ba4b755be8b16c063" translate="yes" xml:space="preserve">
          <source>The error type for operations on the &lt;code&gt;PATH&lt;/code&gt; variable. Possibly returned from &lt;a href=&quot;fn.join_paths&quot;&gt;&lt;code&gt;env::join_paths()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;PATH&lt;/code&gt; 変数に対する操作のエラータイプ。&lt;a href=&quot;fn.join_paths&quot;&gt; &lt;code&gt;env::join_paths()&lt;/code&gt; &lt;/a&gt;から返される可能性があります。</target>
        </trans-unit>
        <trans-unit id="04e8342895bd312f045a40780238aabb9ef5de36" translate="yes" xml:space="preserve">
          <source>The error type for operations on the &lt;code&gt;PATH&lt;/code&gt; variable. Possibly returned from the &lt;a href=&quot;fn.join_paths&quot;&gt;&lt;code&gt;env::join_paths&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;code&gt;PATH&lt;/code&gt; 変数に対する操作のエラータイプ。&lt;a href=&quot;fn.join_paths&quot;&gt; &lt;code&gt;env::join_paths&lt;/code&gt; &lt;/a&gt;関数から返された可能性があります。</target>
        </trans-unit>
        <trans-unit id="92c7e92ce900890826a3bdc04f0bdb6f93a2ae4e" translate="yes" xml:space="preserve">
          <source>The error type returned when a checked integral type conversion fails.</source>
          <target state="translated">チェック済みの積分型変換に失敗した場合に返されるエラー型です。</target>
        </trans-unit>
        <trans-unit id="7c03030b0922657a2b23ad871594bf872bfa86e8" translate="yes" xml:space="preserve">
          <source>The error type returned when a conversion from a slice to an array fails.</source>
          <target state="translated">スライスから配列への変換に失敗した場合に返されるエラータイプです。</target>
        </trans-unit>
        <trans-unit id="5bd755e234651b9d8db0dad82d899820eb73c1c6" translate="yes" xml:space="preserve">
          <source>The error type returned when a conversion from u32 to char fails.</source>
          <target state="translated">u32からcharへの変換に失敗した場合に返されるエラータイプです。</target>
        </trans-unit>
        <trans-unit id="74bd671788812266d70e1e6379cd71d68b83bdd8" translate="yes" xml:space="preserve">
          <source>The error type that results from applying the try operator (&lt;code&gt;?&lt;/code&gt;) to a &lt;code&gt;None&lt;/code&gt; value. If you wish to allow &lt;code&gt;x?&lt;/code&gt; (where &lt;code&gt;x&lt;/code&gt; is an &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;) to be converted into your error type, you can implement &lt;code&gt;impl From&amp;lt;NoneError&amp;gt;&lt;/code&gt; for &lt;code&gt;YourErrorType&lt;/code&gt;. In that case, &lt;code&gt;x?&lt;/code&gt; within a function that returns &lt;code&gt;Result&amp;lt;_, YourErrorType&amp;gt;&lt;/code&gt; will translate a &lt;code&gt;None&lt;/code&gt; value into an &lt;code&gt;Err&lt;/code&gt; result.</source>
          <target state="translated">&lt;code&gt;None&lt;/code&gt; 値にtry演算子（ &lt;code&gt;?&lt;/code&gt; ）を適用した結果のエラータイプ。 &lt;code&gt;x?&lt;/code&gt; を許可したい場合？（ &lt;code&gt;x&lt;/code&gt; は &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; ）エラータイプに変換するには、 &lt;code&gt;impl From&amp;lt;NoneError&amp;gt;&lt;/code&gt; を &lt;code&gt;YourErrorType&lt;/code&gt; ます。その場合、 &lt;code&gt;x?&lt;/code&gt; &lt;code&gt;Result&amp;lt;_, YourErrorType&amp;gt;&lt;/code&gt; を返す関数内で、YourErrorType&amp;gt;は &lt;code&gt;None&lt;/code&gt; 値を &lt;code&gt;Err&lt;/code&gt; 結果に変換します。</target>
        </trans-unit>
        <trans-unit id="620e9e66f647e7af133c1492023ad78f941762d1" translate="yes" xml:space="preserve">
          <source>The error type which is returned from formatting a message into a stream.</source>
          <target state="translated">メッセージをストリームにフォーマットした際に返されるエラータイプ。</target>
        </trans-unit>
        <trans-unit id="d4672a685f085da2d7d7f62486ff4649fbce70a5" translate="yes" xml:space="preserve">
          <source>The errors in Listing 7-6 say that the &lt;code&gt;add_to_waitlist&lt;/code&gt; function is private. The privacy rules apply to structs, enums, functions, and methods as well as modules.</source>
          <target state="translated">リスト7-6のエラーは、 &lt;code&gt;add_to_waitlist&lt;/code&gt; 関数がプライベートであることを示しています。プライバシールールは、構造体、列挙型、関数、メソッド、およびモジュールに適用されます。</target>
        </trans-unit>
        <trans-unit id="5c9b02894ffaf56c3eee190bd9f4d3e5a18ff962" translate="yes" xml:space="preserve">
          <source>The exact behavior on locking a mutex in the thread which already holds the lock is left unspecified. However, this function will not return on the second call (it might panic or deadlock, for example).</source>
          <target state="translated">既にロックを保持しているスレッドでミューテックスをロックする際の正確な動作は未定義のままです。しかし、この関数は2回目の呼び出しでは戻りません(例えば、パニックやデッドロックになるかもしれません)。</target>
        </trans-unit>
        <trans-unit id="ec573024d9a369fea8772d4967a09d1e972fae0a" translate="yes" xml:space="preserve">
          <source>The exact character(s)</source>
          <target state="translated">正確な文字</target>
        </trans-unit>
        <trans-unit id="df2f57248767dbedd045941faa73ddbe53944b27" translate="yes" xml:space="preserve">
          <source>The exact order may be useful for tracking external state, like an index.</source>
          <target state="translated">正確な順序は、インデックスのような外部の状態を追跡するのに便利かもしれません。</target>
        </trans-unit>
        <trans-unit id="8fe495e6414bd43e7bea5f0003cca50741a5b59b" translate="yes" xml:space="preserve">
          <source>The exact output printed by this macro should not be relied upon and is subject to future changes.</source>
          <target state="translated">このマクロによって出力される正確な出力は、信頼できるものではなく、将来的に変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="469498f0144088c9a82cccca15de67704811a8dd" translate="yes" xml:space="preserve">
          <source>The exact text, of course, depends on what files you have in &lt;code&gt;.&lt;/code&gt;.</source>
          <target state="translated">もちろん、正確なテキストは、にあるファイルによって異なります &lt;code&gt;.&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="395c851d3758c4daf594b9f6b458c5ca4cd7434f" translate="yes" xml:space="preserve">
          <source>The example in Listing 13-14 separates the creation of the iterator from the use of the iterator in the &lt;code&gt;for&lt;/code&gt; loop. The iterator is stored in the &lt;code&gt;v1_iter&lt;/code&gt; variable, and no iteration takes place at that time. When the &lt;code&gt;for&lt;/code&gt; loop is called using the iterator in &lt;code&gt;v1_iter&lt;/code&gt;, each element in the iterator is used in one iteration of the loop, which prints out each value.</source>
          <target state="translated">コードリスト13-14の例では、イテレータの作成と &lt;code&gt;for&lt;/code&gt; ループでのイテレータの使用を分けています。イテレーターは &lt;code&gt;v1_iter&lt;/code&gt; 変数に保管され、その時点では反復は行われません。 &lt;code&gt;v1_iter&lt;/code&gt; の反復子を使用して &lt;code&gt;for&lt;/code&gt; ループが呼び出されると、反復子の各要素がループの1回の反復で使用され、各値が出力されます。</target>
        </trans-unit>
        <trans-unit id="e88d69a7ee7e1056409be12e179c7703287290b1" translate="yes" xml:space="preserve">
          <source>The exception to this idiom is if we&amp;rsquo;re bringing two items with the same name into scope with &lt;code&gt;use&lt;/code&gt; statements, because Rust doesn&amp;rsquo;t allow that. Listing 7-15 shows how to bring two &lt;code&gt;Result&lt;/code&gt; types into scope that have the same name but different parent modules and how to refer to them.</source>
          <target state="translated">このイディオムの例外は、Rustでは許可されていないため、 &lt;code&gt;use&lt;/code&gt; ステートメントを使用して同じ名前の2つのアイテムをスコープに入れる場合です。リスト7-15は、名前が同じで親モジュールが異なる2つの &lt;code&gt;Result&lt;/code&gt; 型をスコープに取り込む方法と、それらを参照する方法を示しています。</target>
        </trans-unit>
        <trans-unit id="f9ff06ceaf161b4f26d0944c142b9739231935eb" translate="yes" xml:space="preserve">
          <source>The exception to this is the unit tuple (&lt;code&gt;()&lt;/code&gt;) which is guaranteed as a zero-sized type to have a size of 0 and an alignment of 1.</source>
          <target state="translated">これの例外は、サイズが0で型が1であることがゼロサイズタイプとして保証されているユニットタプル（ &lt;code&gt;()&lt;/code&gt; ）です。</target>
        </trans-unit>
        <trans-unit id="3dc57cf649d183700b8e68c720c692cad27e1162" translate="yes" xml:space="preserve">
          <source>The expanded expression has type &lt;code&gt;&amp;amp;'static str&lt;/code&gt;, and the returned file is not the invocation of the &lt;code&gt;file!&lt;/code&gt; macro itself, but rather the first macro invocation leading up to the invocation of the &lt;code&gt;file!&lt;/code&gt; macro.</source>
          <target state="translated">展開された式のタイプは &lt;code&gt;&amp;amp;'static str&lt;/code&gt; であり、返されたファイルはファイルの呼び出しではありません &lt;code&gt;file!&lt;/code&gt; マクロ自体ですが、 &lt;code&gt;file!&lt;/code&gt; 呼び出しにつながる最初のマクロ呼び出しです！大きい。</target>
        </trans-unit>
        <trans-unit id="2027bedff965dc7817b0dd952d1fc211920c5f6d" translate="yes" xml:space="preserve">
          <source>The expanded expression has type &lt;code&gt;u32&lt;/code&gt; and is 1-based, so the first column in each line evaluates to 1, the second to 2, etc. This is consistent with error messages by common compilers or popular editors. The returned column is &lt;em&gt;not necessarily&lt;/em&gt; the line of the &lt;code&gt;column!&lt;/code&gt; invocation itself, but rather the first macro invocation leading up to the invocation of the &lt;code&gt;column!&lt;/code&gt; macro.</source>
          <target state="translated">拡張式のタイプは &lt;code&gt;u32&lt;/code&gt; で、1から始まるため、各行の最初の列は1、2番目は2などと評価されます。これは、一般的なコンパイラまたは一般的なエディタによるエラーメッセージと一致します。返される列は&lt;em&gt;、必ずしも&lt;/em&gt;列の行で&lt;em&gt;ある&lt;/em&gt;とは&lt;em&gt;限りません&lt;/em&gt; &lt;code&gt;column!&lt;/code&gt; 呼び出し自体ですが、 &lt;code&gt;column!&lt;/code&gt; 呼び出しに至るまでの最初のマクロ呼び出しです！大きい。</target>
        </trans-unit>
        <trans-unit id="b0b06f58ec99c372d86a17a34c7166fa5de08c27" translate="yes" xml:space="preserve">
          <source>The expanded expression has type &lt;code&gt;u32&lt;/code&gt; and is 1-based, so the first line in each file evaluates to 1, the second to 2, etc. This is consistent with error messages by common compilers or popular editors. The returned line is &lt;em&gt;not necessarily&lt;/em&gt; the line of the &lt;code&gt;line!&lt;/code&gt; invocation itself, but rather the first macro invocation leading up to the invocation of the &lt;code&gt;line!&lt;/code&gt; macro.</source>
          <target state="translated">拡張式のタイプは &lt;code&gt;u32&lt;/code&gt; で、1から始まるため、各ファイルの最初の行は1、2番目は2などと評価されます。これは、一般的なコンパイラまたは一般的なエディタによるエラーメッセージと一致します。返された行は、&lt;em&gt;必ずしもではない&lt;/em&gt;の行 &lt;code&gt;line!&lt;/code&gt; 呼び出し自体ですが、 &lt;code&gt;line!&lt;/code&gt; 呼び出しに至るまでの最初のマクロ呼び出しです！大きい。</target>
        </trans-unit>
        <trans-unit id="6dec360ada9c00c421ed26b5b352f032e17122ed" translate="yes" xml:space="preserve">
          <source>The expected cost of &lt;code&gt;push&lt;/code&gt;, averaged over every possible ordering of the elements being pushed, and over a sufficiently large number of pushes, is &lt;em&gt;O&lt;/em&gt;(1). This is the most meaningful cost metric when pushing elements that are &lt;em&gt;not&lt;/em&gt; already in any sorted pattern.</source>
          <target state="translated">&lt;code&gt;push&lt;/code&gt; される要素のすべての可能な順序、および十分に多数のプッシュにわたって平均される、プッシュの予想コストは&lt;em&gt;O&lt;/em&gt;（1）です。これは、まだソートされたパターンになってい&lt;em&gt;ない&lt;/em&gt;要素をプッシュする場合の最も意味のあるコストメトリックです。</target>
        </trans-unit>
        <trans-unit id="606b0f6565bb5e33a7e793c7978e5b02d8b8d28b" translate="yes" xml:space="preserve">
          <source>The expected cost of &lt;code&gt;push&lt;/code&gt;, averaged over every possible ordering of the elements being pushed, and over a sufficiently large number of pushes, is O(1). This is the most meaningful cost metric when pushing elements that are &lt;em&gt;not&lt;/em&gt; already in any sorted pattern.</source>
          <target state="translated">&lt;code&gt;push&lt;/code&gt; される要素の考えられるすべての順序で平均化されたプッシュの予想コストは、十分な数のプッシュでO（1）です。これは、まだソートされたパターンに&lt;em&gt;ない&lt;/em&gt;要素をプッシュする場合に最も意味のあるコストメトリックです。</target>
        </trans-unit>
        <trans-unit id="a72ec7eef34f0a8ffd7d99e9cfce2da0536188e2" translate="yes" xml:space="preserve">
          <source>The expression above creates a value of type &lt;code&gt;MyUnion&lt;/code&gt; and initializes the storage using field &lt;code&gt;f1&lt;/code&gt;. The union can be accessed using the same syntax as struct fields:</source>
          <target state="translated">上記の式は、タイプ &lt;code&gt;MyUnion&lt;/code&gt; の値を作成し、フィールド &lt;code&gt;f1&lt;/code&gt; を使用してストレージを初期化します。共用体には、構造体フィールドと同じ構文を使用してアクセスできます。</target>
        </trans-unit>
        <trans-unit id="b5fa765f11cc060019641c8e75e38c695bdb1bda" translate="yes" xml:space="preserve">
          <source>The expression cannot be a &lt;a href=&quot;operator-expr#lazy-boolean-operators&quot;&gt;lazy boolean operator expression&lt;/a&gt;. Use of a lazy boolean operator is ambiguous with a planned feature change of the language (the implementation of if-let chains - see &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/2497-if-let-chains.md#rollout-plan-and-transitioning-to-rust-2018&quot;&gt;eRFC 2947&lt;/a&gt;). When lazy boolean operator expression is desired, this can be achieved by using parenthesis as below:</source>
          <target state="translated">式を&lt;a href=&quot;operator-expr#lazy-boolean-operators&quot;&gt;遅延ブール演算子式に&lt;/a&gt;することはできません。遅延ブール演算子の使用は、言語の計画された機能変更（if-letチェーンの実装&lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/2497-if-let-chains.md#rollout-plan-and-transitioning-to-rust-2018&quot;&gt;-eRFC 2947を&lt;/a&gt;参照）があいまいです。遅延ブール演算子式が必要な場合は、次のように括弧を使用してこれを実現できます。</target>
        </trans-unit>
        <trans-unit id="a608f321648c235bb5c3f09a506a153d6d9a7fa1" translate="yes" xml:space="preserve">
          <source>The expression for a match arm.</source>
          <target state="translated">マッチアームの表現。</target>
        </trans-unit>
        <trans-unit id="edc402eeeb9a7639cb3c026b59f168e6cd732965" translate="yes" xml:space="preserve">
          <source>The expression immediately following &lt;code&gt;in&lt;/code&gt; must implement the &lt;a href=&quot;../book/ch13-04-performance&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt; trait.</source>
          <target state="translated">すぐに次の式 &lt;code&gt;in&lt;/code&gt; 実装する必要があります&lt;a href=&quot;../book/ch13-04-performance&quot;&gt; &lt;code&gt;IntoIterator&lt;/code&gt; の&lt;/a&gt;形質を。</target>
        </trans-unit>
        <trans-unit id="64c3c13114c938924165b32b931fcfa0929a3dad" translate="yes" xml:space="preserve">
          <source>The expression in the &lt;code&gt;if&lt;/code&gt; block evaluates to an integer, and the expression in the &lt;code&gt;else&lt;/code&gt; block evaluates to a string. This won&amp;rsquo;t work because variables must have a single type. Rust needs to know at compile time what type the &lt;code&gt;number&lt;/code&gt; variable is, definitively, so it can verify at compile time that its type is valid everywhere we use &lt;code&gt;number&lt;/code&gt;. Rust wouldn&amp;rsquo;t be able to do that if the type of &lt;code&gt;number&lt;/code&gt; was only determined at runtime; the compiler would be more complex and would make fewer guarantees about the code if it had to keep track of multiple hypothetical types for any variable.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; ブロックの式は整数に評価され、 &lt;code&gt;else&lt;/code&gt; ブロックの式は文字列に評価されます。変数は単一の型でなければならないため、これは機能しません。 Rustは、コンパイル時に &lt;code&gt;number&lt;/code&gt; 変数の型を正確に知る必要があるため、コンパイル時に、その型が &lt;code&gt;number&lt;/code&gt; を使用するすべての場所で有効であることを検証できます。 &lt;code&gt;number&lt;/code&gt; のタイプが実行時にのみ決定された場合、Rustはそれを行うことができません。変数の複数の仮説型を追跡する必要がある場合、コンパイラーはより複雑になり、コードに関する保証が少なくなります。</target>
        </trans-unit>
        <trans-unit id="7947155b0fa5fdbbf2d84b0fb9bff1298adf4bf1" translate="yes" xml:space="preserve">
          <source>The extension is:</source>
          <target state="translated">その延長線上にあるのが</target>
        </trans-unit>
        <trans-unit id="ea39e7727f6084ef5165d4f9b888542528c3cc1d" translate="yes" xml:space="preserve">
          <source>The external crate is resolved to a specific &lt;code&gt;soname&lt;/code&gt; at compile time, and a runtime linkage requirement to that &lt;code&gt;soname&lt;/code&gt; is passed to the linker for loading at runtime. The &lt;code&gt;soname&lt;/code&gt; is resolved at compile time by scanning the compiler's library path and matching the optional &lt;code&gt;crateid&lt;/code&gt; provided against the &lt;code&gt;crateid&lt;/code&gt; attributes that were declared on the external crate when it was compiled. If no &lt;code&gt;crateid&lt;/code&gt; is provided, a default &lt;code&gt;name&lt;/code&gt; attribute is assumed, equal to the &lt;a href=&quot;../identifiers&quot;&gt;identifier&lt;/a&gt; given in the &lt;code&gt;extern crate&lt;/code&gt; declaration.</source>
          <target state="translated">外部クレートはコンパイル時に特定の &lt;code&gt;soname&lt;/code&gt; に解決され、その &lt;code&gt;soname&lt;/code&gt; への実行時リンケージ要件が実行時にロードするためにリンカーに渡されます。 &lt;code&gt;soname&lt;/code&gt; 、コンパイラのライブラリパスをスキャンし、オプションのマッチングによって、コンパイル時に解決される &lt;code&gt;crateid&lt;/code&gt; に対して提供 &lt;code&gt;crateid&lt;/code&gt; それがコンパイルされたとき、外部クレートに宣言された属性を。 &lt;code&gt;crateid&lt;/code&gt; が指定されていない場合は、 &lt;code&gt;extern crate&lt;/code&gt; 宣言で指定された&lt;a href=&quot;../identifiers&quot;&gt;識別子&lt;/a&gt;に等しいデフォルトの &lt;code&gt;name&lt;/code&gt; 属性が想定されます。</target>
        </trans-unit>
        <trans-unit id="2d4ff9b9a673e6ef5c73fd0d74de95c1584abb9d" translate="yes" xml:space="preserve">
          <source>The failure message indicates that this test did indeed panic as we expected, but the panic message did not include the expected string &lt;code&gt;'Guess value must be less than or equal to 100'&lt;/code&gt;. The panic message that we did get in this case was &lt;code&gt;Guess value must be greater than or equal to 1, got 200.&lt;/code&gt; Now we can start figuring out where our bug is!</source>
          <target state="translated">失敗メッセージは、このテストが実際に予想どおりパニックになったことを示していますが、パニックメッセージには予期された文字列 &lt;code&gt;'Guess value must be less than or equal to 100'&lt;/code&gt; 含まれていませんでした。この場合に得られたパニックメッセージは、 &lt;code&gt;Guess value must be greater than or equal to 1, got 200.&lt;/code&gt; でした。200になりました。これで、バグの場所を特定できるようになりました。</target>
        </trans-unit>
        <trans-unit id="1264d4255ef5d1877747639a91dce97d95706422" translate="yes" xml:space="preserve">
          <source>The family of the operating system. Example value is &lt;code&gt;unix&lt;/code&gt;.</source>
          <target state="translated">オペレーティングシステムのファミリ。値の例は &lt;code&gt;unix&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="1f19a750b2fcc57343d113fae5c2d35cbbeabd61" translate="yes" xml:space="preserve">
          <source>The field names can be decimal integer values to specify indices for constructing tuple structs. This can be used with base structs to fill out the remaining indices not specified:</source>
          <target state="translated">フィールド名には 10 進整数値を指定して、タプル構造体を構築するためのインデックスを指定することができます。これは、指定されていない残りのインデックスを埋めるためにベース構造体と一緒に使用することができます。</target>
        </trans-unit>
        <trans-unit id="0bbc5c6747805ec7b206ff1d7bd4fc19a67e98d4" translate="yes" xml:space="preserve">
          <source>The fields of a &lt;a href=&quot;types/struct&quot;&gt;struct&lt;/a&gt; are dropped in declaration order.</source>
          <target state="translated">&lt;a href=&quot;types/struct&quot;&gt;構造体&lt;/a&gt;のフィールドは、宣言順に削除されます。</target>
        </trans-unit>
        <trans-unit id="c1e05fef4f32d53e63c8251d9d852a226e0b9d94" translate="yes" xml:space="preserve">
          <source>The fields of a &lt;a href=&quot;types/struct&quot;&gt;struct&lt;/a&gt;, &lt;a href=&quot;types/tuple&quot;&gt;tuple&lt;/a&gt; or &lt;a href=&quot;types/enum&quot;&gt;enum variant&lt;/a&gt; are dropped in declaration order. *</source>
          <target state="translated">&lt;a href=&quot;types/struct&quot;&gt;struct&lt;/a&gt;、&lt;a href=&quot;types/tuple&quot;&gt;tuple、&lt;/a&gt;または&lt;a href=&quot;types/enum&quot;&gt;enumバリアント&lt;/a&gt;のフィールドは宣言順にドロップされます。*</target>
        </trans-unit>
        <trans-unit id="ad3f74fe8b6e787f7b7254796fcea650c623bbf0" translate="yes" xml:space="preserve">
          <source>The fields of a &lt;a href=&quot;types/tuple&quot;&gt;tuple&lt;/a&gt; are dropped in order.</source>
          <target state="translated">&lt;a href=&quot;types/tuple&quot;&gt;タプル&lt;/a&gt;のフィールドは順番に削除されます。</target>
        </trans-unit>
        <trans-unit id="985befbf65bb726fbdc7e8fa5788956f4d2e4bf1" translate="yes" xml:space="preserve">
          <source>The fields of a &lt;code&gt;struct&lt;/code&gt; may be qualified by &lt;a href=&quot;../visibility-and-privacy&quot;&gt;visibility modifiers&lt;/a&gt;, to allow access to data in a struct outside a module.</source>
          <target state="translated">フィールド &lt;code&gt;struct&lt;/code&gt; によって修飾することができる&lt;a href=&quot;../visibility-and-privacy&quot;&gt;視認性改質&lt;/a&gt;モジュールの外部構造体中のデータへのアクセスを許可します。</target>
        </trans-unit>
        <trans-unit id="d44253ff03665f86e16760d6d12a49f11125c4e2" translate="yes" xml:space="preserve">
          <source>The fields of the active &lt;a href=&quot;types/enum&quot;&gt;enum variant&lt;/a&gt; are dropped in declaration order.</source>
          <target state="translated">アクティブな&lt;a href=&quot;types/enum&quot;&gt;列挙型バリアント&lt;/a&gt;のフィールドは、宣言順に削除されます。</target>
        </trans-unit>
        <trans-unit id="40ccc036f7a6ce305846dd9b315fdf1f96b15a3b" translate="yes" xml:space="preserve">
          <source>The fields of this struct show that the Rust code we&amp;rsquo;ve parsed is a unit struct with the &lt;code&gt;ident&lt;/code&gt; (identifier, meaning the name) of &lt;code&gt;Pancakes&lt;/code&gt;. There are more fields on this struct for describing all sorts of Rust code; check the &lt;a href=&quot;https://docs.rs/syn/0.14.4/syn/struct.DeriveInput.html&quot;&gt;&lt;code&gt;syn&lt;/code&gt; documentation for &lt;code&gt;DeriveInput&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">この構造体のフィールドは、解析したRustコードが、 &lt;code&gt;Pancakes&lt;/code&gt; の &lt;code&gt;ident&lt;/code&gt; （識別子、名前を意味する）を持つユニット構造体であることを示しています。この構造体には、あらゆる種類のRustコードを記述するためのフィールドがあります。チェック&lt;a href=&quot;https://docs.rs/syn/0.14.4/syn/struct.DeriveInput.html&quot;&gt; &lt;code&gt;syn&lt;/code&gt; &lt;/a&gt;のドキュメント &lt;code&gt;DeriveInput&lt;/code&gt; の詳細については。</target>
        </trans-unit>
        <trans-unit id="b0794c80e766c7ef30098e79990a99a126d86062" translate="yes" xml:space="preserve">
          <source>The fields of this struct show that the Rust code we&amp;rsquo;ve parsed is a unit struct with the &lt;code&gt;ident&lt;/code&gt; (identifier, meaning the name) of &lt;code&gt;Pancakes&lt;/code&gt;. There are more fields on this struct for describing all sorts of Rust code; check the &lt;a href=&quot;https://docs.rs/syn/1.0/syn/struct.DeriveInput.html&quot;&gt;&lt;code&gt;syn&lt;/code&gt; documentation for &lt;code&gt;DeriveInput&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">この構造体のフィールドは、解析したRustコードが &lt;code&gt;Pancakes&lt;/code&gt; の &lt;code&gt;ident&lt;/code&gt; （識別子、名前を意味する）を持つユニット構造体であることを示しています。この構造体には、あらゆる種類のRustコードを記述するためのフィールドがさらにあります。詳細については&lt;a href=&quot;https://docs.rs/syn/1.0/syn/struct.DeriveInput.html&quot;&gt;、&lt;/a&gt; &lt;code&gt;DeriveInput&lt;/code&gt; の &lt;code&gt;syn&lt;/code&gt; ドキュメントを確認してください。</target>
        </trans-unit>
        <trans-unit id="41f21e4814cce1d92447f83c7dd9a65499d60626" translate="yes" xml:space="preserve">
          <source>The file doesn't exist.</source>
          <target state="translated">ファイルが存在しません。</target>
        </trans-unit>
        <trans-unit id="c618b2bfdd921c07e86f2a30b8c3ccd4f98ae789" translate="yes" xml:space="preserve">
          <source>The file is located relative to the current file (similarly to how modules are found).</source>
          <target state="translated">ファイルは現在のファイルからの相対的な位置にあります(モジュールの見つけ方と同様)。</target>
        </trans-unit>
        <trans-unit id="0630128fbb4da19cb239333b356fc43bbab7e18f" translate="yes" xml:space="preserve">
          <source>The file is located relative to the current file (similarly to how modules are found). The provided path is interpreted in a platform-specific way at compile time. So, for instance, an invocation with a Windows path containing backslashes &lt;code&gt;\&lt;/code&gt; would not compile correctly on Unix.</source>
          <target state="translated">ファイルは、現在のファイルを基準にして配置されます（モジュールの検索方法と同様）。提供されたパスは、コンパイル時にプラットフォーム固有の方法で解釈されます。したがって、たとえば、バックスラッシュ &lt;code&gt;\&lt;/code&gt; を含むWindowsパスを使用した呼び出しは、Unixでは正しくコンパイルされません。</target>
        </trans-unit>
        <trans-unit id="a1df7519bc8cdda06f6336bd152ecc0e5b1b6c7c" translate="yes" xml:space="preserve">
          <source>The file is located relative to the current file. (similarly to how modules are found)</source>
          <target state="translated">現在のファイルから相対的に配置されます。(モジュールの見つけ方と似ています)</target>
        </trans-unit>
        <trans-unit id="d6c5af6a5c60f4fa56d05a0fa81955ff57e694aa" translate="yes" xml:space="preserve">
          <source>The file must be opened with write access for truncate to work.</source>
          <target state="translated">truncate を動作させるためには、ファイルを書き込みアクセスで開く必要があります。</target>
        </trans-unit>
        <trans-unit id="b64dc47988604588017060c77446efa88568cbbc" translate="yes" xml:space="preserve">
          <source>The file must be opened with write or append access in order to create a new file.</source>
          <target state="translated">新規ファイルを作成するためには、書き込みアクセスまたは追加アクセスでファイルを開く必要があります。</target>
        </trans-unit>
        <trans-unit id="55a4d79c2d543091872b4da347b5d4b201da5902" translate="yes" xml:space="preserve">
          <source>The file's cursor isn't changed. In particular, if the cursor was at the end and the file is shrunk using this operation, the cursor will now be past the end.</source>
          <target state="translated">ファイルのカーソルは変更されません。特に、カーソルが末尾にあった場合、この操作でファイルを縮小した場合、カーソルは末尾を過ぎたところになります。</target>
        </trans-unit>
        <trans-unit id="6c8ba754d920c70b815c96a59ae89e2ab19e9615" translate="yes" xml:space="preserve">
          <source>The fill character is provided normally in conjunction with the &lt;a href=&quot;#width&quot;&gt;&lt;code&gt;width&lt;/code&gt;&lt;/a&gt; parameter. This indicates that if the value being formatted is smaller than &lt;code&gt;width&lt;/code&gt; some extra characters will be printed around it. The extra characters are specified by &lt;code&gt;fill&lt;/code&gt;, and the alignment can be one of the following options:</source>
          <target state="translated">フィル文字は通常、&lt;a href=&quot;#width&quot;&gt; &lt;code&gt;width&lt;/code&gt; &lt;/a&gt;パラメーターと組み合わせて提供されます。これは、フォーマットされている値が &lt;code&gt;width&lt;/code&gt; よりも小さい場合、その周りに余分な文字が印刷されることを示しています。余分な文字は &lt;code&gt;fill&lt;/code&gt; によって指定され、配置は次のオプションのいずれかになります。</target>
        </trans-unit>
        <trans-unit id="93dbdf12316da4d04bf621e9eb356e67a9dd2780" translate="yes" xml:space="preserve">
          <source>The final action that works only with &lt;code&gt;unsafe&lt;/code&gt; is implementing an unsafe trait. A trait is unsafe when at least one of its methods has some invariant that the compiler can&amp;rsquo;t verify. We can declare that a trait is &lt;code&gt;unsafe&lt;/code&gt; by adding the &lt;code&gt;unsafe&lt;/code&gt; keyword before &lt;code&gt;trait&lt;/code&gt; and marking the implementation of the trait as &lt;code&gt;unsafe&lt;/code&gt; too, as shown in Listing 19-11.</source>
          <target state="translated">&lt;code&gt;unsafe&lt;/code&gt; でない場合にのみ機能する最後のアクションは、安全でない特性を実装することです。少なくとも1つのメソッドにコンパイラが検証できない不変条件がある場合、その特性は安全ではありません。リスト19-11に示すように、トレイトの前に &lt;code&gt;unsafe&lt;/code&gt; キーワードを追加し、 &lt;code&gt;trait&lt;/code&gt; の実装も &lt;code&gt;unsafe&lt;/code&gt; とマークすることで、トレイトが &lt;code&gt;unsafe&lt;/code&gt; ことを宣言できます。</target>
        </trans-unit>
        <trans-unit id="49a4f7cf0e0e66e3c555d75f0978be5130fe5dec" translate="yes" xml:space="preserve">
          <source>The final expression of any extending &lt;a href=&quot;expressions/block-expr&quot;&gt;block expression&lt;/a&gt;.</source>
          <target state="translated">拡張&lt;a href=&quot;expressions/block-expr&quot;&gt;ブロック式&lt;/a&gt;の最終式。</target>
        </trans-unit>
        <trans-unit id="5d305704a4fbc5372e6355348bdb324639855c0b" translate="yes" xml:space="preserve">
          <source>The final line ending is optional.</source>
          <target state="translated">最後の行末は任意です。</target>
        </trans-unit>
        <trans-unit id="7bcad5659fa398bc4723e1a1e4ec534359f32934" translate="yes" xml:space="preserve">
          <source>The final line ending is optional. A string that ends with a final line ending will return the same lines as an otherwise identical string without a final line ending.</source>
          <target state="translated">最終行の末尾はオプションです。最終行で終わる文字列は、最終行のない同一の文字列と同じ行を返します。</target>
        </trans-unit>
        <trans-unit id="d405e4ac4031d3643938bc829210c93b1a171c2a" translate="yes" xml:space="preserve">
          <source>The final line ending isn't required:</source>
          <target state="translated">最後の行末は必要ありません。</target>
        </trans-unit>
        <trans-unit id="c5271e27e91796af655967c8ffbfa429a17a75cb" translate="yes" xml:space="preserve">
          <source>The final result could be determined just by looking at the code at compile time, so &lt;a href=&quot;https://en.wikipedia.org/wiki/Constant_folding&quot;&gt;constant folding&lt;/a&gt; might turn the whole block into a simple &lt;code&gt;println!(&quot;7 4 4&quot;)&lt;/code&gt;.</source>
          <target state="translated">最終結果は、コンパイル時にコードを調べるだけで決定できるため、&lt;a href=&quot;https://en.wikipedia.org/wiki/Constant_folding&quot;&gt;定数の折りたたみ&lt;/a&gt;により、ブロック全体が単純な &lt;code&gt;println!(&quot;7 4 4&quot;)&lt;/code&gt; になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="4e59d9d4ed7f661f21e1daf6cf7e1143fd8d7bfa" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;Cons&lt;/code&gt; value holds &lt;code&gt;1&lt;/code&gt; and another &lt;code&gt;List&lt;/code&gt; value. This &lt;code&gt;List&lt;/code&gt; value is another &lt;code&gt;Cons&lt;/code&gt; value that holds &lt;code&gt;2&lt;/code&gt; and another &lt;code&gt;List&lt;/code&gt; value. This &lt;code&gt;List&lt;/code&gt; value is one more &lt;code&gt;Cons&lt;/code&gt; value that holds &lt;code&gt;3&lt;/code&gt; and a &lt;code&gt;List&lt;/code&gt; value, which is finally &lt;code&gt;Nil&lt;/code&gt;, the non-recursive variant that signals the end of the list.</source>
          <target state="translated">最初の &lt;code&gt;Cons&lt;/code&gt; 値は &lt;code&gt;1&lt;/code&gt; を保持し、別の &lt;code&gt;List&lt;/code&gt; 値を保持します。この &lt;code&gt;List&lt;/code&gt; 値は、 &lt;code&gt;2&lt;/code&gt; と別の &lt;code&gt;List&lt;/code&gt; 値を保持する別の &lt;code&gt;Cons&lt;/code&gt; 値です。この &lt;code&gt;List&lt;/code&gt; 値は、 &lt;code&gt;3&lt;/code&gt; を保持するもう1つの &lt;code&gt;Cons&lt;/code&gt; 値と、最後に &lt;code&gt;Nil&lt;/code&gt; である &lt;code&gt;List&lt;/code&gt; 値です。これは、リストの終わりを示す非再帰的なバリアントです。</target>
        </trans-unit>
        <trans-unit id="b8427aa75fccc52f421b7262b47d3cb66ca8ba99" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;length&lt;/code&gt; bytes at &lt;code&gt;buf&lt;/code&gt; need to be valid UTF-8.</source>
          <target state="translated">&lt;code&gt;buf&lt;/code&gt; の最初の &lt;code&gt;length&lt;/code&gt; バイトは、有効なUTF-8である必要があります。</target>
        </trans-unit>
        <trans-unit id="b2f6ee38297963ecf451ec169c5ecff0bb88450f" translate="yes" xml:space="preserve">
          <source>The first argument &lt;code&gt;format!&lt;/code&gt; receives is a format string. This must be a string literal. The power of the formatting string is in the &lt;code&gt;{}&lt;/code&gt;s contained.</source>
          <target state="translated">最初の引数の &lt;code&gt;format!&lt;/code&gt; receiveはフォーマット文字列です。これは文字列リテラルでなければなりません。書式設定文字列の機能は、含まれている &lt;code&gt;{}&lt;/code&gt; にあります。</target>
        </trans-unit>
        <trans-unit id="172d64775742c02b6a5a5317561d4368b0242e63" translate="yes" xml:space="preserve">
          <source>The first argument we gave to the &lt;code&gt;assert_eq!&lt;/code&gt; macro, &lt;code&gt;4&lt;/code&gt;, is equal to the result of calling &lt;code&gt;add_two(2)&lt;/code&gt;. The line for this test is &lt;code&gt;test tests::it_adds_two ... ok&lt;/code&gt;, and the &lt;code&gt;ok&lt;/code&gt; text indicates that our test passed!</source>
          <target state="translated">&lt;code&gt;assert_eq!&lt;/code&gt; 与えた最初の引数！マクロ &lt;code&gt;4&lt;/code&gt; は、 &lt;code&gt;add_two(2)&lt;/code&gt; を呼び出した結果と同じです。このテストの行は &lt;code&gt;test tests::it_adds_two ... ok&lt;/code&gt; で、 &lt;code&gt;ok&lt;/code&gt; テキストはテストに合格したことを示しています。</target>
        </trans-unit>
        <trans-unit id="3de15e9c98b000a8208779afdf2f678b58acd245" translate="yes" xml:space="preserve">
          <source>The first arm will match any point that lies on the &lt;code&gt;x&lt;/code&gt; axis by specifying that the &lt;code&gt;y&lt;/code&gt; field matches if its value matches the literal &lt;code&gt;0&lt;/code&gt;. The pattern still creates an &lt;code&gt;x&lt;/code&gt; variable that we can use in the code for this arm.</source>
          <target state="translated">最初のアームは、値がリテラル &lt;code&gt;0&lt;/code&gt; と一致する場合に &lt;code&gt;y&lt;/code&gt; フィールドが一致することを指定することにより、 &lt;code&gt;x&lt;/code&gt; 軸上にある任意のポイントと一致します。このパターンでも、このアームのコードで使用できる &lt;code&gt;x&lt;/code&gt; 変数が作成されます。</target>
        </trans-unit>
        <trans-unit id="0d5278ef07d533df9f2058795a528bf65f8762b5" translate="yes" xml:space="preserve">
          <source>The first character is &lt;code&gt;_&lt;/code&gt;.</source>
          <target state="translated">最初の文字は &lt;code&gt;_&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="6995348ce355253fb2b3997cb5b666e8341177e1" translate="yes" xml:space="preserve">
          <source>The first character is a letter.</source>
          <target state="translated">最初の一文字が文字になっています。</target>
        </trans-unit>
        <trans-unit id="a8c76b012fc5c6ec5d1d2757128af41ec43b821f" translate="yes" xml:space="preserve">
          <source>The first collection type we&amp;rsquo;ll look at is &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, also known as a &lt;em&gt;vector&lt;/em&gt;. Vectors allow you to store more than one value in a single data structure that puts all the values next to each other in memory. Vectors can only store values of the same type. They are useful when you have a list of items, such as the lines of text in a file or the prices of items in a shopping cart.</source>
          <target state="translated">最初に &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; コレクション型はVec &amp;lt;T&amp;gt;で、これは&lt;em&gt;vector&lt;/em&gt;とも呼ばれます。ベクトルを使用すると、単一のデータ構造に複数の値を格納して、すべての値をメモリ内で隣同士に配置できます。ベクトルは同じタイプの値のみを保存できます。ファイル内のテキスト行やショッピングカート内のアイテムの価格など、アイテムのリストがある場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="428cb6a8ac810de3963e02d4205a82867bb3d81a" translate="yes" xml:space="preserve">
          <source>The first command creates a new directory called &lt;em&gt;hello_cargo&lt;/em&gt;. We&amp;rsquo;ve named our project &lt;em&gt;hello_cargo&lt;/em&gt;, and Cargo creates its files in a directory of the same name.</source>
          <target state="translated">最初のコマンドは、&lt;em&gt;hello_cargo&lt;/em&gt;という新しいディレクトリを作成します。プロジェクトに&lt;em&gt;hello_cargo&lt;/em&gt;という名前を付け、Cargoは同じ名前のディレクトリにファイルを作成します。</target>
        </trans-unit>
        <trans-unit id="63eaa7d21eca5ee74b5e72e48aed31081f441d50" translate="yes" xml:space="preserve">
          <source>The first command, &lt;code&gt;cargo new&lt;/code&gt;, takes the name of the project (&lt;code&gt;guessing_game&lt;/code&gt;) as the first argument. The second command changes to the new project&amp;rsquo;s directory.</source>
          <target state="translated">最初のコマンド、 &lt;code&gt;cargo new&lt;/code&gt; は、最初の引数としてプロジェクトの名前（ &lt;code&gt;guessing_game&lt;/code&gt; ）を取ります。2番目のコマンドは、新しいプロジェクトのディレクトリに移動します。</target>
        </trans-unit>
        <trans-unit id="0041dd0d29e2c266e11aba3af3bc7df1a46ad21b" translate="yes" xml:space="preserve">
          <source>The first element is traditionally the path of the executable, but it can be set to arbitrary text, and it may not even exist, so this property should not be relied upon for security purposes.</source>
          <target state="translated">最初の要素は伝統的に実行ファイルのパスですが、任意のテキストに設定することもできますし、存在しない場合もあります。</target>
        </trans-unit>
        <trans-unit id="d1fd88a9bd4f9b97a6544f441d40f72dd7a6a337" translate="yes" xml:space="preserve">
          <source>The first element is traditionally the path of the executable, but it can be set to arbitrary text, and may not even exist. This means this property should not be relied upon for security purposes.</source>
          <target state="translated">最初の要素は伝統的には実行ファイルのパスですが、任意のテキストに設定することができ、存在しない場合もあります。つまり、このプロパティはセキュリティの目的のために頼るべきではないということです。</target>
        </trans-unit>
        <trans-unit id="57c13dc1f835e54c634e0d373f7f324807f9c426" translate="yes" xml:space="preserve">
          <source>The first element was moved out of the array, but this is not possible because &lt;code&gt;NonCopy&lt;/code&gt; does not implement the &lt;code&gt;Copy&lt;/code&gt; trait.</source>
          <target state="translated">最初の要素は配列の外に移動されましたが、 &lt;code&gt;NonCopy&lt;/code&gt; は &lt;code&gt;Copy&lt;/code&gt; トレイトを実装していないため、これは不可能です。</target>
        </trans-unit>
        <trans-unit id="7e08bb0a99fdc3cd6e428394eb70ec134e104b16" translate="yes" xml:space="preserve">
          <source>The first enum shown is the usual kind of enum you'd find in a C-style language. The second shows off a hypothetical example of something storing location data, with &lt;code&gt;Coord&lt;/code&gt; being any other type that's needed, for example a struct. The third example demonstrates the kind of data a variant can store, ranging from nothing, to a tuple, to an anonymous struct.</source>
          <target state="translated">表示される最初の列挙型は、Cスタイル言語で見つかる通常の列挙型です。2番目は、位置データを格納する架空の例を示しています &lt;code&gt;Coord&lt;/code&gt; は、構造体など、必要なその他のタイプです。3番目の例は、バリアントが保存できるデータの種類を示しています。</target>
        </trans-unit>
        <trans-unit id="356931433c23df443c1df1a79c8ba26a23e35bf5" translate="yes" xml:space="preserve">
          <source>The first error is in our &lt;code&gt;Drop&lt;/code&gt; implementation. We mentioned earlier that we intended to call &lt;code&gt;take&lt;/code&gt; on the &lt;code&gt;Option&lt;/code&gt; value to move &lt;code&gt;thread&lt;/code&gt; out of &lt;code&gt;worker&lt;/code&gt;. The following changes will do so:</source>
          <target state="translated">最初のエラーは、 &lt;code&gt;Drop&lt;/code&gt; の実装にあります。 &lt;code&gt;thread&lt;/code&gt; を &lt;code&gt;worker&lt;/code&gt; の外に移動するために &lt;code&gt;Option&lt;/code&gt; 値で &lt;code&gt;take&lt;/code&gt; を呼び出すつもりであると前述しました。以下の変更がそうします：</target>
        </trans-unit>
        <trans-unit id="65b1330f4d7e9b563ff90a9ab4bea0daa6bb9857" translate="yes" xml:space="preserve">
          <source>The first invariant says that whatever actual token that comes after a matcher, if any, must be somewhere in the predetermined follow set. This ensures that a legal macro definition will continue to assign the same determination as to where &lt;code&gt;... tt&lt;/code&gt; ends and &lt;code&gt;uu ...&lt;/code&gt; begins, even as new syntactic forms are added to the language.</source>
          <target state="translated">最初の不変式は、マッチャーの後に続く実際のトークンは、もしあれば、所定のフォローセットのどこかになければならないことを示しています。これにより、新しい構文形式が言語に追加されても、正当なマクロ定義が &lt;code&gt;... tt&lt;/code&gt; 終了し、 &lt;code&gt;uu ...&lt;/code&gt; が開始する場所と同じ決定を割り当て続けることが保証されます。</target>
        </trans-unit>
        <trans-unit id="5f19def176a50d6a90af45519ada69ee7f97eb7e" translate="yes" xml:space="preserve">
          <source>The first is that it is how much memory must be allocated to store that value.</source>
          <target state="translated">1つ目は、その値を格納するためにどれだけのメモリを確保しなければならないかということです。</target>
        </trans-unit>
        <trans-unit id="beaa6fcb1bf59defe3de830f4f2763f9980dd889" translate="yes" xml:space="preserve">
          <source>The first is to answer a specific question. If you know which chapter answers that question, you can jump to that chapter in the table of contents. Otherwise, you can press &lt;code&gt;s&lt;/code&gt; or the click the magnifying glass on the top bar to search for keywords related to your question. For example, say you wanted to know when a temporary value created in a let statement is dropped. If you didn't already know that the &lt;a href=&quot;expressions#temporaries&quot;&gt;lifetime of temporaries&lt;/a&gt; is defined in the &lt;a href=&quot;expressions&quot;&gt;expressions chapter&lt;/a&gt;, you could search &quot;temporary let&quot; and the first search result will take you to that section.</source>
          <target state="translated">1つ目は、特定の質問に答えることです。どの章がその質問に答えているかがわかっている場合は、目次のその章にジャンプできます。それ以外の場合は、 &lt;code&gt;s&lt;/code&gt; を押すか、トップバーの虫眼鏡をクリックして、質問に関連するキーワードを検索できます。たとえば、letステートメントで作成された一時的な値がいつドロップされるかを知りたいとします。&lt;a href=&quot;expressions#temporaries&quot;&gt;一時的な&lt;/a&gt;ものの存続期間が&lt;a href=&quot;expressions&quot;&gt;式の章&lt;/a&gt;で定義されていることをまだ知らなかった場合は、「一時的なレット」を検索すると、最初の検索結果でそのセクションに移動します。</target>
        </trans-unit>
        <trans-unit id="6fc0f539a4da8814ced28ee34b9432e35dbaf3f6" translate="yes" xml:space="preserve">
          <source>The first is to answer a specific question. If you know which chapter answers that question, you can jump to that chapter in the table of contents. Otherwise, you can press &lt;code&gt;s&lt;/code&gt; or the click the magnifying glass on the top bar to search for keywords related to your question. For example, say you wanted to know when a temporary value created in a let statement is dropped. If you didn't already know that the &lt;a href=&quot;expressions#temporary-lifetimes&quot;&gt;lifetime of temporaries&lt;/a&gt; is defined in the &lt;a href=&quot;expressions&quot;&gt;expressions chapter&lt;/a&gt;, you could search &quot;temporary let&quot; and the first search result will take you to that section.</source>
          <target state="translated">最初は特定の質問に答えることです。どの章がその質問に答えるかがわかっている場合は、目次でその章にジャンプできます。それ以外の場合は、 &lt;code&gt;s&lt;/code&gt; を押すか、上部バーの虫眼鏡をクリックして、質問に関連するキーワードを検索できます。たとえば、letステートメントで作成された一時的な値がいつ削除されたかを知りたいとします。&lt;a href=&quot;expressions#temporary-lifetimes&quot;&gt;一時&lt;/a&gt;の存続期間が&lt;a href=&quot;expressions&quot;&gt;式の章&lt;/a&gt;で定義されていることをまだ知らない場合は、「temporary let」を検索すると、最初の検索結果でそのセクションに移動します。</target>
        </trans-unit>
        <trans-unit id="9d5da3096efb5359ed9929a25c1646ef8f4d3a16" translate="yes" xml:space="preserve">
          <source>The first line is a &lt;em&gt;status line&lt;/em&gt; that contains the HTTP version used in the response, a numeric status code that summarizes the result of the request, and a reason phrase that provides a text description of the status code. After the CRLF sequence are any headers, another CRLF sequence, and the body of the response.</source>
          <target state="translated">最初の行は、&lt;em&gt;ステータスライン&lt;/em&gt;応答に使用されるHTTPバージョン、要求の結果を要約する数値ステータスコード、およびステータスコードのテキスト説明を提供する理由フレーズを含んでいます。CRLFシーケンスの後には、ヘッダー、別のCRLFシーケンス、および応答の本文があります。</target>
        </trans-unit>
        <trans-unit id="f9ee7ff7ce4ca8fcacdd1bbbd80ae645db3e5b9c" translate="yes" xml:space="preserve">
          <source>The first line is the &lt;em&gt;request line&lt;/em&gt; that holds information about what the client is requesting. The first part of the request line indicates the &lt;em&gt;method&lt;/em&gt; being used, such as &lt;code&gt;GET&lt;/code&gt; or &lt;code&gt;POST&lt;/code&gt;, which describes how the client is making this request. Our client used a &lt;code&gt;GET&lt;/code&gt; request.</source>
          <target state="translated">最初の行は、クライアントが要求しているものに関する情報を保持する&lt;em&gt;要求行&lt;/em&gt;です。リクエスト行の最初の部分は、クライアントがこのリクエストをどのように行っているかを示す &lt;code&gt;GET&lt;/code&gt; や &lt;code&gt;POST&lt;/code&gt; などの使用されている&lt;em&gt;メソッドを&lt;/em&gt;示しています。クライアントは &lt;code&gt;GET&lt;/code&gt; リクエストを使用しました。</target>
        </trans-unit>
        <trans-unit id="81a313a5dc649f34279e079a51051be71d71d911" translate="yes" xml:space="preserve">
          <source>The first line shows a function definition, and the second line shows a fully annotated closure definition. The third line removes the type annotations from the closure definition, and the fourth line removes the brackets, which are optional because the closure body has only one expression. These are all valid definitions that will produce the same behavior when they&amp;rsquo;re called.</source>
          <target state="translated">1行目は関数定義を示し、2行目は完全に注釈が付けられたクロージャ定義を示しています。3行目はクロージャー定義から型注釈を削除し、4行目はブラケットを削除します。これは、クロージャー本体に式が1つしかないためオプションです。これらはすべて呼び出されたときに同じ動作を生成する有効な定義です。</target>
        </trans-unit>
        <trans-unit id="ee8e9ca51bced15f598c9116a158790ff9d282d7" translate="yes" xml:space="preserve">
          <source>The first line shows a function definition, and the second line shows a fully annotated closure definition. The third line removes the type annotations from the closure definition, and the fourth line removes the brackets, which are optional because the closure body has only one expression. These are all valid definitions that will produce the same behavior when they&amp;rsquo;re called. Calling the closures is required for &lt;code&gt;add_one_v3&lt;/code&gt; and &lt;code&gt;add_one_v4&lt;/code&gt; to be able to compile because the types will be inferred from their usage.</source>
          <target state="translated">最初の行は関数定義を示し、2行目は完全に注釈が付けられたクロージャ定義を示しています。 3行目は、クロージャー定義から型注釈を削除し、4行目はブラケットを削除します。これは、クロージャー本体に1つの式しかないため、オプションです。これらはすべて有効な定義であり、呼び出されたときに同じ動作を生成します。型はそれらの使用法から推測されるため、 &lt;code&gt;add_one_v3&lt;/code&gt; と &lt;code&gt;add_one_v4&lt;/code&gt; をコンパイルできるようにするには、クロージャを呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="98148895ad25eccad7c245ba3595f3571d1d992c" translate="yes" xml:space="preserve">
          <source>The first line, &lt;code&gt;[package]&lt;/code&gt;, is a section heading that indicates that the following statements are configuring a package. As we add more information to this file, we&amp;rsquo;ll add other sections.</source>
          <target state="translated">最初の行 &lt;code&gt;[package]&lt;/code&gt; は、次のステートメントがパッケージを構成していることを示すセクション見出しです。このファイルにさらに情報を追加すると、他のセクションが追加されます。</target>
        </trans-unit>
        <trans-unit id="b65c034b9a1653c1664e07497c1d14736ba472ab" translate="yes" xml:space="preserve">
          <source>The first mismatching element defines which sequence is lexicographically less or greater than the other.</source>
          <target state="translated">最初のミスマッチ要素は、語彙的にどのシーケンスが他のシーケンスより小さいか大きいかを定義します。</target>
        </trans-unit>
        <trans-unit id="8b310676b3019d119c9c467f577a365e7a655455" translate="yes" xml:space="preserve">
          <source>The first new bit here is another &lt;code&gt;use&lt;/code&gt; statement, bringing a type called &lt;code&gt;std::cmp::Ordering&lt;/code&gt; into scope from the standard library. Like &lt;code&gt;Result&lt;/code&gt;, &lt;code&gt;Ordering&lt;/code&gt; is another enum, but the variants for &lt;code&gt;Ordering&lt;/code&gt; are &lt;code&gt;Less&lt;/code&gt;, &lt;code&gt;Greater&lt;/code&gt;, and &lt;code&gt;Equal&lt;/code&gt;. These are the three outcomes that are possible when you compare two values.</source>
          <target state="translated">ここでの最初の新しいビットは、 &lt;code&gt;std::cmp::Ordering&lt;/code&gt; と呼ばれる型を標準ライブラリからスコープに導入する別の &lt;code&gt;use&lt;/code&gt; ステートメントです。 &lt;code&gt;Result&lt;/code&gt; と同様に、 &lt;code&gt;Ordering&lt;/code&gt; も別の列挙型ですが、 &lt;code&gt;Ordering&lt;/code&gt; のバリアントは &lt;code&gt;Less&lt;/code&gt; 、 &lt;code&gt;Greater&lt;/code&gt; 、 &lt;code&gt;Equal&lt;/code&gt; です。これらは、2つの値を比較したときに可能な3つの結果です。</target>
        </trans-unit>
        <trans-unit id="cc86c6e2624cc3af0cff65094ba89e9de1e68ebb" translate="yes" xml:space="preserve">
          <source>The first new line defines the &lt;code&gt;response&lt;/code&gt; variable that holds the success message&amp;rsquo;s data. Then we call &lt;code&gt;as_bytes&lt;/code&gt; on our &lt;code&gt;response&lt;/code&gt; to convert the string data to bytes. The &lt;code&gt;write&lt;/code&gt; method on &lt;code&gt;stream&lt;/code&gt; takes a &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; and sends those bytes directly down the connection.</source>
          <target state="translated">最初の新しい行は、成功メッセージのデータを保持する &lt;code&gt;response&lt;/code&gt; 変数を定義します。次に、 &lt;code&gt;response&lt;/code&gt; &lt;code&gt;as_bytes&lt;/code&gt; を呼び出して、文字列データをバイトに変換します。 &lt;code&gt;stream&lt;/code&gt; の &lt;code&gt;write&lt;/code&gt; メソッドは &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; を取り、それらのバイトを接続を介して直接送信します。</target>
        </trans-unit>
        <trans-unit id="155e4331405457b07f19de5018b6f05e551344c8" translate="yes" xml:space="preserve">
          <source>The first one looks much cleaner. This automatic referencing behavior works because methods have a clear receiver&amp;mdash;the type of &lt;code&gt;self&lt;/code&gt;. Given the receiver and name of a method, Rust can figure out definitively whether the method is reading (&lt;code&gt;&amp;amp;self&lt;/code&gt;), mutating (&lt;code&gt;&amp;amp;mut self&lt;/code&gt;), or consuming (&lt;code&gt;self&lt;/code&gt;). The fact that Rust makes borrowing implicit for method receivers is a big part of making ownership ergonomic in practice.</source>
          <target state="translated">最初のものはずっときれいに見えます。この自動参照動作は、メソッドに明確なレシーバー（ &lt;code&gt;self&lt;/code&gt; のタイプ）があるため機能します。メソッドの受信者と名前を指定すると、Rustはメソッドが読み取り（ &lt;code&gt;&amp;amp;self&lt;/code&gt; ）、変更（ &lt;code&gt;&amp;amp;mut self&lt;/code&gt; ）、または消費（ &lt;code&gt;self&lt;/code&gt; ）のいずれであるかを明確に把握できます。Rustがメソッドレシーバーの借用を暗黙的に行うという事実は、所有権を実際に人間工学的にする上で重要な部分です。</target>
        </trans-unit>
        <trans-unit id="69774098a6b4b7c12621ff37f51e96103a8b7208" translate="yes" xml:space="preserve">
          <source>The first part of the guessing game program will ask for user input, process that input, and check that the input is in the expected form. To start, we&amp;rsquo;ll allow the player to input a guess. Enter the code in Listing 2-1 into &lt;em&gt;src/main.rs&lt;/em&gt;.</source>
          <target state="translated">推測ゲームプログラムの最初の部分は、ユーザー入力を要求し、その入力を処理し、入力が予期した形式であることを確認します。まず、プレイヤーが推測を入力できるようにします。コードリスト2-1のコードを&lt;em&gt;src / main.rsに&lt;/em&gt;入力します。</target>
        </trans-unit>
        <trans-unit id="2750d61c6d5f6fdb7cf8539aba812571a959c619" translate="yes" xml:space="preserve">
          <source>The first parts of the module system we&amp;rsquo;ll cover are packages and crates. A crate is a binary or library. The &lt;em&gt;crate root&lt;/em&gt; is a source file that the Rust compiler starts from and makes up the root module of your crate (we&amp;rsquo;ll explain modules in depth in the &lt;a href=&quot;ch07-02-defining-modules-to-control-scope-and-privacy&quot;&gt;&amp;ldquo;Defining Modules to Control Scope and Privacy&amp;rdquo;&lt;/a&gt; section). A &lt;em&gt;package&lt;/em&gt; is one or more crates that provide a set of functionality. A package contains a &lt;em&gt;Cargo.toml&lt;/em&gt; file that describes how to build those crates.</source>
          <target state="translated">ここで取り上げるモジュールシステムの最初の部分は、パッケージと木枠です。クレートはバイナリまたはライブラリです。&lt;em&gt;クレートルートは&lt;/em&gt;錆コンパイラから始まり、あなたのクレートのルートモジュールを構成することをソースファイルである（私たちは中に深さのモジュールを説明しましょう&lt;a href=&quot;ch07-02-defining-modules-to-control-scope-and-privacy&quot;&gt;「の定義モジュールのコントロールへの適用範囲とプライバシー」&lt;/a&gt;を参照）。&lt;em&gt;パッケージは、&lt;/em&gt;一連の機能を提供する1つ以上の木箱です。パッケージには、これらのクレートを作成する方法を説明する&lt;em&gt;Cargo.toml&lt;/em&gt;ファイルが含まれて&lt;em&gt;い&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="84c014079631c14ba610d8bbfcba357c51089179" translate="yes" xml:space="preserve">
          <source>The first parts of the module system we&amp;rsquo;ll cover are packages and crates. A crate is a binary or library. The &lt;em&gt;crate root&lt;/em&gt; is a source file that the Rust compiler starts from and makes up the root module of your crate (we&amp;rsquo;ll explain modules in depth in the &lt;a href=&quot;ch07-02-defining-modules-to-control-scope-and-privacy&quot;&gt;&amp;ldquo;Defining Modules to Control Scope and Privacy&amp;rdquo;&lt;/a&gt;) section. A &lt;em&gt;package&lt;/em&gt; is one or more crates that provide a set of functionality. A package contains a &lt;em&gt;Cargo.toml&lt;/em&gt; file that describes how to build those crates.</source>
          <target state="translated">ここで取り上げるモジュールシステムの最初の部分は、パッケージとクレートです。クレートはバイナリまたはライブラリです。&lt;em&gt;クレートのルートは、&lt;/em&gt;錆のコンパイラは（我々は深さのモジュールを説明しますから始まり、あなたのクレートのルートモジュールを構成することをソースファイルである&lt;a href=&quot;ch07-02-defining-modules-to-control-scope-and-privacy&quot;&gt;「の定義モジュールのコントロールへの適用範囲とプライバシー」&lt;/a&gt;セクションを）。&lt;em&gt;パッケージは、&lt;/em&gt;一連の機能を提供する1つ以上の木箱です。パッケージには、これらの箱を構築する方法を説明する&lt;em&gt;Cargo.toml&lt;/em&gt;ファイルが含まれて&lt;em&gt;い&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="af7ae34fc30a5ff985eeb202b31d100b9995dad4" translate="yes" xml:space="preserve">
          <source>The first problem is that a &lt;code&gt;Cacher&lt;/code&gt; instance assumes it will always get the same value for the parameter &lt;code&gt;arg&lt;/code&gt; to the &lt;code&gt;value&lt;/code&gt; method. That is, this test of &lt;code&gt;Cacher&lt;/code&gt; will fail:</source>
          <target state="translated">最初の問題は、ということである &lt;code&gt;Cacher&lt;/code&gt; インスタンスは、それは常に、パラメータの同じ値を取得します想定して &lt;code&gt;arg&lt;/code&gt; に &lt;code&gt;value&lt;/code&gt; 方法を。つまり、この &lt;code&gt;Cacher&lt;/code&gt; のテストは失敗します。</target>
        </trans-unit>
        <trans-unit id="dafa36fcdade4f5ce81d7dee337248690a10ae6d" translate="yes" xml:space="preserve">
          <source>The first purpose is similar to the second but in reverse: if you want to add a type parameter to an existing trait, you can give it a default to allow extension of the functionality of the trait without breaking the existing implementation code.</source>
          <target state="translated">既存の形質に型パラメータを追加したい場合、既存の実装コードを壊すことなく形質の機能を拡張できるようにデフォルト値を与えることができます。</target>
        </trans-unit>
        <trans-unit id="5f5a900754c112ed82386f584763afdd02db421d" translate="yes" xml:space="preserve">
          <source>The first rule is that each parameter that is a reference gets its own lifetime parameter. In other words, a function with one parameter gets one lifetime parameter: &lt;code&gt;fn foo&amp;lt;'a&amp;gt;(x: &amp;amp;'a i32)&lt;/code&gt;; a function with two parameters gets two separate lifetime parameters: &lt;code&gt;fn foo&amp;lt;'a, 'b&amp;gt;(x: &amp;amp;'a i32, y: &amp;amp;'b i32)&lt;/code&gt;; and so on.</source>
          <target state="translated">最初のルールは、参照である各パラメーターが独自の有効期間パラメーターを取得することです。つまり、1つのパラメーターを持つ関数は、1つの有効期間パラメーターを取得します &lt;code&gt;fn foo&amp;lt;'a&amp;gt;(x: &amp;amp;'a i32)&lt;/code&gt; ; 2つのパラメーターを持つ関数は、2つの別個の有効期間パラメーターを取得します &lt;code&gt;fn foo&amp;lt;'a, 'b&amp;gt;(x: &amp;amp;'a i32, y: &amp;amp;'b i32)&lt;/code&gt; ;等々。</target>
        </trans-unit>
        <trans-unit id="d13f338beec8e6c884aee47f7c30a9f0bc21c5c9" translate="yes" xml:space="preserve">
          <source>The first section of the output shows that the &lt;code&gt;it_works&lt;/code&gt; test in the &lt;code&gt;add-one&lt;/code&gt; crate passed. The next section shows that zero tests were found in the &lt;code&gt;adder&lt;/code&gt; crate, and then the last section shows zero documentation tests were found in the &lt;code&gt;add-one&lt;/code&gt; crate. Running &lt;code&gt;cargo test&lt;/code&gt; in a workspace structured like this one will run the tests for all the crates in the workspace.</source>
          <target state="translated">出力の最初のセクションは、 &lt;code&gt;add-one&lt;/code&gt; クレートの &lt;code&gt;it_works&lt;/code&gt; テストに合格したことを示しています。ゼロのテストがで発見されたことを、次のセクションショー &lt;code&gt;adder&lt;/code&gt; クレート、及び最後のセクションショーゼロドキュメントテストはで発見された &lt;code&gt;add-one&lt;/code&gt; クレート。実行中の &lt;code&gt;cargo test&lt;/code&gt; この1のような構造のワークスペースでは、ワークスペース内のすべての箱のためのテストを実行します。</target>
        </trans-unit>
        <trans-unit id="1aa6d921fdf65cd84a902ac9021b32a10817790a" translate="yes" xml:space="preserve">
          <source>The first step is to build a list of candidate receiver types. Obtain these by repeatedly &lt;a href=&quot;operator-expr#the-dereference-operator&quot;&gt;dereferencing&lt;/a&gt; the receiver expression's type, adding each type encountered to the list, then finally attempting an &lt;a href=&quot;../type-coercions#unsized-coercions&quot;&gt;unsized coercion&lt;/a&gt; at the end, and adding the result type if that is successful. Then, for each candidate &lt;code&gt;T&lt;/code&gt;, add &lt;code&gt;&amp;amp;T&lt;/code&gt; and &lt;code&gt;&amp;amp;mut T&lt;/code&gt; to the list immediately after &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">最初のステップは、候補となるレシーバータイプのリストを作成することです。レシーバーの式の型を繰り返し&lt;a href=&quot;operator-expr#the-dereference-operator&quot;&gt;逆参照し&lt;/a&gt;、遭遇した各型をリストに追加し、最後に&lt;a href=&quot;../type-coercions#unsized-coercions&quot;&gt;サイズなしの強制&lt;/a&gt;を試み、それが成功した場合は結果の型を追加して、これらを取得します。次に、候補 &lt;code&gt;T&lt;/code&gt; ごとに、 &lt;code&gt;&amp;amp;T&lt;/code&gt; および &lt;code&gt;&amp;amp;mut T&lt;/code&gt; を &lt;code&gt;T&lt;/code&gt; の直後のリストに追加します。</target>
        </trans-unit>
        <trans-unit id="7046b8e80cd49555b791ba84b08e3a496f0ebd34" translate="yes" xml:space="preserve">
          <source>The first step is to install Rust. We&amp;rsquo;ll download Rust through &lt;code&gt;rustup&lt;/code&gt;, a command line tool for managing Rust versions and associated tools. You&amp;rsquo;ll need an internet connection for the download.</source>
          <target state="translated">最初のステップは、Rustをインストールすることです。Rustのバージョンと関連ツールを管理するためのコマンドラインツールである &lt;code&gt;rustup&lt;/code&gt; からRustをダウンロードします。ダウンロードにはインターネット接続が必要です。</target>
        </trans-unit>
        <trans-unit id="50ad5f65969d8efb886424560b9363334f047aa4" translate="yes" xml:space="preserve">
          <source>The first store to &lt;code&gt;C&lt;/code&gt; might be moved before the store to &lt;code&gt;A&lt;/code&gt; or &lt;code&gt;B&lt;/code&gt;, &lt;em&gt;as if&lt;/em&gt; we had written &lt;code&gt;C = 4; A = 3; B = 4&lt;/code&gt;.</source>
          <target state="translated">最初の店舗 &lt;code&gt;C&lt;/code&gt; は、に格納する前に移動されるかもしれない &lt;code&gt;A&lt;/code&gt; または &lt;code&gt;B&lt;/code&gt; 、&lt;em&gt;かのように&lt;/em&gt;我々が書いた &lt;code&gt;C = 4; A = 3; B = 4&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0a6ba14d6296fbc087c2dbd538a2ed25e14b36c1" translate="yes" xml:space="preserve">
          <source>The first task is to make &lt;code&gt;minigrep&lt;/code&gt; accept its two command line arguments: the filename and a string to search for. That is, we want to be able to run our program with &lt;code&gt;cargo run&lt;/code&gt;, a string to search for, and a path to a file to search in, like so:</source>
          <target state="translated">最初のタスクは、 &lt;code&gt;minigrep&lt;/code&gt; に 2つのコマンドライン引数（ファイル名と検索する文字列）を受け入れさせることです。つまり、 &lt;code&gt;cargo run&lt;/code&gt; 、検索する文字列、検索するファイルへのパスを使用して、次のようにプログラムを実行できるようにします。</target>
        </trans-unit>
        <trans-unit id="31729bd9aa0c04461ab01bb63b4c75c53baddad1" translate="yes" xml:space="preserve">
          <source>The first time we call &lt;code&gt;example_closure&lt;/code&gt; with the &lt;code&gt;String&lt;/code&gt; value, the compiler infers the type of &lt;code&gt;x&lt;/code&gt; and the return type of the closure to be &lt;code&gt;String&lt;/code&gt;. Those types are then locked in to the closure in &lt;code&gt;example_closure&lt;/code&gt;, and we get a type error if we try to use a different type with the same closure.</source>
          <target state="translated">我々は呼んで初めて &lt;code&gt;example_closure&lt;/code&gt; をして &lt;code&gt;String&lt;/code&gt; 値は、コンパイラの推論のタイプ &lt;code&gt;x&lt;/code&gt; とクロージャの戻り値の型があることを &lt;code&gt;String&lt;/code&gt; 。これらの型は &lt;code&gt;example_closure&lt;/code&gt; のクロージャーにロックされ、同じクロージャーで異なる型を使用しようとすると型エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="bd2776b4ba26113bcf03f01d82d4cc2a793fc112" translate="yes" xml:space="preserve">
          <source>The first time we call the &lt;code&gt;add_to_waitlist&lt;/code&gt; function in &lt;code&gt;eat_at_restaurant&lt;/code&gt;, we use an absolute path. The &lt;code&gt;add_to_waitlist&lt;/code&gt; function is defined in the same crate as &lt;code&gt;eat_at_restaurant&lt;/code&gt;, which means we can use the &lt;code&gt;crate&lt;/code&gt; keyword to start an absolute path.</source>
          <target state="translated">我々は呼んで初めて &lt;code&gt;add_to_waitlist&lt;/code&gt; の中の関数 &lt;code&gt;eat_at_restaurant&lt;/code&gt; は、我々は絶対パスを使用します。 &lt;code&gt;add_to_waitlist&lt;/code&gt; の機能は同じクレートに定義され &lt;code&gt;eat_at_restaurant&lt;/code&gt; 我々が使用できることを意味し、 &lt;code&gt;crate&lt;/code&gt; 絶対パスを開始するキーワード。</target>
        </trans-unit>
        <trans-unit id="fcbd8f43979f6a3f91b2e8d0489ac836799ae483" translate="yes" xml:space="preserve">
          <source>The first two cases are the same except for mutability. The first case states that if you have a &lt;code&gt;&amp;amp;T&lt;/code&gt;, and &lt;code&gt;T&lt;/code&gt; implements &lt;code&gt;Deref&lt;/code&gt; to some type &lt;code&gt;U&lt;/code&gt;, you can get a &lt;code&gt;&amp;amp;U&lt;/code&gt; transparently. The second case states that the same deref coercion happens for mutable references.</source>
          <target state="translated">最初の2つのケースは、可変性を除いて同じです。最初のケースは、 &lt;code&gt;&amp;amp;T&lt;/code&gt; があり、 &lt;code&gt;T&lt;/code&gt; が何らかのタイプ &lt;code&gt;U&lt;/code&gt; に &lt;code&gt;Deref&lt;/code&gt; を実装している場合、 &lt;code&gt;&amp;amp;U&lt;/code&gt; を透過的に取得できることを示しています。2番目のケースは、変更可能な参照に対して同じderef強制が発生することを示しています。</target>
        </trans-unit>
        <trans-unit id="286885295f7366f4af40320e50ad88bb3b1732e7" translate="yes" xml:space="preserve">
          <source>The first version of the prelude of The Rust Standard Library.</source>
          <target state="translated">ラスト・スタンダード・ライブラリー』の前奏曲の第一弾。</target>
        </trans-unit>
        <trans-unit id="2833ddd57d8c251f327110ae65b75e17455b9bb3" translate="yes" xml:space="preserve">
          <source>The first will contain all indices from &lt;code&gt;[0, mid)&lt;/code&gt; (excluding the index &lt;code&gt;mid&lt;/code&gt; itself) and the second will contain all indices from &lt;code&gt;[mid, len)&lt;/code&gt; (excluding the index &lt;code&gt;len&lt;/code&gt; itself).</source>
          <target state="translated">1つ目は &lt;code&gt;[0, mid)&lt;/code&gt; からのすべてのインデックス（インデックス &lt;code&gt;mid&lt;/code&gt; 自体を除く）を含み、2つ目は &lt;code&gt;[mid, len)&lt;/code&gt; からのすべてのインデックスを含みます（インデックス &lt;code&gt;len&lt;/code&gt; 自体を除く）。</target>
        </trans-unit>
        <trans-unit id="d13813ed09799c4deb40bb4b4bb042ae0365adde" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; affect compile-time limits.</source>
          <target state="translated">次の&lt;a href=&quot;../attributes&quot;&gt;属性は&lt;/a&gt;、コンパイル時の制限に影響します。</target>
        </trans-unit>
        <trans-unit id="1c0907607a038e19917ef67594e99ddd26567897" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; are used for changing how a type can be used.</source>
          <target state="translated">次の&lt;a href=&quot;../attributes&quot;&gt;属性&lt;/a&gt;は、タイプの使用方法を変更するために使用されます。</target>
        </trans-unit>
        <trans-unit id="53b431e371001b409fc98d06f983cdb135709c0f" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; are used for controlling code generation.</source>
          <target state="translated">次の&lt;a href=&quot;../attributes&quot;&gt;属性&lt;/a&gt;は、コード生成の制御に使用されます。</target>
        </trans-unit>
        <trans-unit id="26da618b938f5c0f34421c8ac509923a988969a6" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; are used for controlling or generating diagnostic messages during compilation.</source>
          <target state="translated">次の&lt;a href=&quot;../attributes&quot;&gt;属性&lt;/a&gt;は、コンパイル中に診断メッセージを制御または生成するために使用されます。</target>
        </trans-unit>
        <trans-unit id="a094c614790975d250927975ec0fe6928fcd7c3a" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; are used for specifying functions for performing tests. Compiling a crate in &quot;test&quot; mode enables building the test functions along with a test harness for executing the tests. Enabling the test mode also enables the &lt;a href=&quot;../conditional-compilation#test&quot;&gt;&lt;code&gt;test&lt;/code&gt; conditional compilation option&lt;/a&gt;.</source>
          <target state="translated">次の&lt;a href=&quot;../attributes&quot;&gt;属性&lt;/a&gt;は、テストを実行するための関数を指定するために使用されます。「テスト」モードでクレートをコンパイルすると、テストを実行するためのテストハーネスとともにテスト機能を構築できます。テストモードを有効にすると、&lt;a href=&quot;../conditional-compilation#test&quot;&gt; &lt;code&gt;test&lt;/code&gt; 条件付きコンパイルオプション&lt;/a&gt;も有効になります。</target>
        </trans-unit>
        <trans-unit id="c6bd6f609f21755a5a941e395bd92f148b7a32a4" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; control the behavior of external blocks.</source>
          <target state="translated">次の&lt;a href=&quot;../attributes&quot;&gt;属性&lt;/a&gt;は、外部ブロックの動作を制御します。</target>
        </trans-unit>
        <trans-unit id="e4c3204613b4a8b1aeaa7e0d193d03d0b636c5e8" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;join_slices&lt;/code&gt; function is &lt;strong&gt;unsound&lt;/strong&gt; ⚠️</source>
          <target state="translated">次 &lt;code&gt;join_slices&lt;/code&gt; の関数である&lt;strong&gt;不健全&lt;/strong&gt;⚠️</target>
        </trans-unit>
        <trans-unit id="34e28a9dda5b8f30dd258681b177c05e512cb9ec" translate="yes" xml:space="preserve">
          <source>The following are examples of struct expressions:</source>
          <target state="translated">以下に構造体表現の例を示します。</target>
        </trans-unit>
        <trans-unit id="0cfa813f73eeb4b3df6024040cdcdc9bf704edb3" translate="yes" xml:space="preserve">
          <source>The following code tries to return a closure directly, but it won&amp;rsquo;t compile:</source>
          <target state="translated">次のコードはクロージャーを直接返そうとしますが、コンパイルされません。</target>
        </trans-unit>
        <trans-unit id="9fdd790090c328b0bac332ac3bf94fd48a22d310" translate="yes" xml:space="preserve">
          <source>The following coercions are called &lt;code&gt;unsized coercions&lt;/code&gt;, since they relate to converting sized types to unsized types, and are permitted in a few cases where other coercions are not, as described above. They can still happen anywhere else a coercion can occur.</source>
          <target state="translated">次の型変換は、サイズ付き型からサイズなし型への変換に関連しているため、サイズなし型 &lt;code&gt;unsized coercions&lt;/code&gt; と呼ばれ、上記のように、他の型変換ができないいくつかの場合に許可されます。彼らはまだ他の場所で強制が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="5faa68338d0213add2f9ec4c067dc00f82eb825f" translate="yes" xml:space="preserve">
          <source>The following contexts are &lt;em&gt;place expression&lt;/em&gt; contexts:</source>
          <target state="translated">次のコンテキストは、&lt;em&gt;場所式の&lt;/em&gt;コンテキストです。</target>
        </trans-unit>
        <trans-unit id="a03f434198c8f12dc538595d512c2779094f1534" translate="yes" xml:space="preserve">
          <source>The following example contains a circular dependency between two traits:</source>
          <target state="translated">次の例では、2つの形質間の循環依存関係が含まれています。</target>
        </trans-unit>
        <trans-unit id="19cc88ac0ce4f5388077204fb21e73c4ffb89f2d" translate="yes" xml:space="preserve">
          <source>The following example implements &lt;code&gt;Index&lt;/code&gt; on a read-only &lt;code&gt;NucleotideCount&lt;/code&gt; container, enabling individual counts to be retrieved with index syntax.</source>
          <target state="translated">次の例では、読み取り専用の &lt;code&gt;NucleotideCount&lt;/code&gt; コンテナに &lt;code&gt;Index&lt;/code&gt; を実装し、個々のカウントをインデックス構文で取得できるようにします。</target>
        </trans-unit>
        <trans-unit id="1e6d78aaf2b8415e3caf24e2fa8603dbd9c8a54c" translate="yes" xml:space="preserve">
          <source>The following example showcases the fact that exclusive access to an &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; implies exclusive access to its &lt;code&gt;T&lt;/code&gt;:</source>
          <target state="translated">The following example showcases the fact that exclusive access to an &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; implies exclusive access to its &lt;code&gt;T&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b79316b13dbff6d7faf92f7fbb6c36c3b4504a1c" translate="yes" xml:space="preserve">
          <source>The following example uses &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; to create an optional box of &lt;a href=&quot;../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt;. Notice that in order to use the inner &lt;a href=&quot;../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt; value first, the &lt;code&gt;check_optional&lt;/code&gt; function needs to use pattern matching to determine whether the box has a value (i.e., it is &lt;a href=&quot;enum.option#variant.Some&quot;&gt;&lt;code&gt;Some(...)&lt;/code&gt;&lt;/a&gt;) or not (&lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">次の例では、&lt;a href=&quot;enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt;を使用して&lt;a href=&quot;../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; の&lt;/a&gt;オプションボックスを作成しています。最初に内部の&lt;a href=&quot;../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt;値を使用するために、 &lt;code&gt;check_optional&lt;/code&gt; 関数はパターンマッチングを使用して、ボックスに値がある（つまり、&lt;a href=&quot;enum.option#variant.Some&quot;&gt; &lt;code&gt;Some(...)&lt;/code&gt; である&lt;/a&gt;）かどうかを判断する必要があることに注意してください（&lt;a href=&quot;enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="0098b757352995332c14af09f0677dc80f9a0b00" translate="yes" xml:space="preserve">
          <source>The following expressions are constant expressions, so long as any operands are also constant expressions and do not cause any &lt;a href=&quot;destructors&quot;&gt;&lt;code&gt;Drop::drop&lt;/code&gt;&lt;/a&gt; calls to be run.</source>
          <target state="translated">次の式は、オペランドも定数式であり、&lt;a href=&quot;destructors&quot;&gt; &lt;code&gt;Drop::drop&lt;/code&gt; &lt;/a&gt;呼び出しが実行されない限り、定数式です。</target>
        </trans-unit>
        <trans-unit id="a4fd2c18c35c909a948ecc39653105d7e64c5323" translate="yes" xml:space="preserve">
          <source>The following expressions are equivalent.</source>
          <target state="translated">以下の表現は等価です。</target>
        </trans-unit>
        <trans-unit id="f79e25578dbebf348320c4abf5b91615c4d5d3bd" translate="yes" xml:space="preserve">
          <source>The following expressions can be mutable place expression contexts:</source>
          <target state="translated">以下の式は、変異可能な場所式コンテキストにすることができます。</target>
        </trans-unit>
        <trans-unit id="0e8e60bb585909210311dad5aced6fb1ca9a2411" translate="yes" xml:space="preserve">
          <source>The following illustrates how tokens can be directly matched after matching a &lt;code&gt;tt&lt;/code&gt; fragment:</source>
          <target state="translated">次の例は、 &lt;code&gt;tt&lt;/code&gt; フラグメントの照合後にトークンを直接照合する方法を示しています。</target>
        </trans-unit>
        <trans-unit id="4cba4cc8b1a51987e47e31e5a3e9298ced934caa" translate="yes" xml:space="preserve">
          <source>The following is a list of the available feature names.</source>
          <target state="translated">利用可能な機能名は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="7bfbc404b57ece9100ac4d9b168ae9cc179de313" translate="yes" xml:space="preserve">
          <source>The following is an example of a derive macro. Instead of doing anything useful with its input, it just appends a function &lt;code&gt;answer&lt;/code&gt;.</source>
          <target state="translated">以下は、派生マクロの例です。入力に対して有用な処理を行うのではなく、関数 &lt;code&gt;answer&lt;/code&gt; を追加するだけです。</target>
        </trans-unit>
        <trans-unit id="cb90a0db80f40417302eef01e3aacf14fbc10a30" translate="yes" xml:space="preserve">
          <source>The following is an example of declaring &lt;code&gt;Shape&lt;/code&gt; to be a supertrait of &lt;code&gt;Circle&lt;/code&gt;.</source>
          <target state="translated">以下は、 &lt;code&gt;Shape&lt;/code&gt; を &lt;code&gt;Circle&lt;/code&gt; の上位特性として宣言する例です。</target>
        </trans-unit>
        <trans-unit id="0bc86808e703044cc02c714fea381b5d6b4eb104" translate="yes" xml:space="preserve">
          <source>The following is an index of all built-in attributes.</source>
          <target state="translated">以下は、すべての組み込み属性のインデックスです。</target>
        </trans-unit>
        <trans-unit id="7cc1fc6a380ba45eaa1f4f2110280733486f387c" translate="yes" xml:space="preserve">
          <source>The following is an overview of the available synchronization objects:</source>
          <target state="translated">利用可能な同期オブジェクトの概要は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="e77d4cd3fb5ca40ba38b2400787449b1eb8f401a" translate="yes" xml:space="preserve">
          <source>The following keywords are reserved beginning in the 2018 edition.</source>
          <target state="translated">2018年版からは以下のキーワードを予約しています。</target>
        </trans-unit>
        <trans-unit id="88a73d4d23e456f05faa46221aa0e7b9298c7349" translate="yes" xml:space="preserve">
          <source>The following keywords currently have the functionality described.</source>
          <target state="translated">現在、以下のキーワードには機能が記載されています。</target>
        </trans-unit>
        <trans-unit id="b5d973323cad12bb72185383671304dcd5ab9469" translate="yes" xml:space="preserve">
          <source>The following keywords do not have any functionality but are reserved by Rust for potential future use.</source>
          <target state="translated">以下のキーワードには機能はありませんが、将来的な使用の可能性を考慮してRustによって予約されています。</target>
        </trans-unit>
        <trans-unit id="e441a28a0807978c7d9ce6b3cf8c4bd39296d4e8" translate="yes" xml:space="preserve">
          <source>The following keywords were added beginning in the 2018 edition.</source>
          <target state="translated">2018年版から以下のキーワードが追加されました。</target>
        </trans-unit>
        <trans-unit id="7de22ffd047d06a2d94087f0583e69c5de3c8513" translate="yes" xml:space="preserve">
          <source>The following language level features cannot be used in the safe subset of Rust:</source>
          <target state="translated">以下の言語レベルの機能は、Rust の安全なサブセットでは使用できません。</target>
        </trans-unit>
        <trans-unit id="fa4bbe49e1fb3a478a935beaddada675b665b643" translate="yes" xml:space="preserve">
          <source>The following list contains all non-letters that don&amp;rsquo;t function as operators; that is, they don&amp;rsquo;t behave like a function or method call.</source>
          <target state="translated">次のリストには、演算子として機能しないすべての非文字が含まれています。つまり、関数やメソッドの呼び出しのようには動作しません。</target>
        </trans-unit>
        <trans-unit id="35b04ccb391eee75aac9df7cb7f1bfc81254ebee" translate="yes" xml:space="preserve">
          <source>The following list contains keywords that are reserved for current or future use by the Rust language. As such, they cannot be used as identifiers (except as raw identifiers as we&amp;rsquo;ll discuss in the &amp;ldquo;&lt;a href=&quot;#raw-identifiers&quot;&gt;Raw Identifiers&lt;/a&gt;&amp;rdquo; section), including names of functions, variables, parameters, struct fields, modules, crates, constants, macros, static values, attributes, types, traits, or lifetimes.</source>
          <target state="translated">次のリストには、Rust言語が現在または将来使用するために予約されているキーワードが含まれています。そのため、関数の名前、変数、パラメーター、構造体フィールド、モジュール、クレート、定数、マクロ、静的値など、識別子（「&lt;a href=&quot;#raw-identifiers&quot;&gt;未加工識別子&lt;/a&gt;」セクションで説明する未加工識別子を除く）として使用することはできません。、属性、タイプ、特性、またはライフタイム。</target>
        </trans-unit>
        <trans-unit id="92af89abc5b10810cac2bde7c4403090edbb5361" translate="yes" xml:space="preserve">
          <source>The following notations are used by the &lt;em&gt;Lexer&lt;/em&gt; and &lt;em&gt;Syntax&lt;/em&gt; grammar snippets:</source>
          <target state="translated">次の表記は、&lt;em&gt;レクサー&lt;/em&gt;と&lt;em&gt;構文の&lt;/em&gt;文法スニペットで使用されます。</target>
        </trans-unit>
        <trans-unit id="6c611de22c83326f1c10498c47d838ad78c2827b" translate="yes" xml:space="preserve">
          <source>The following return &lt;a href=&quot;../primitive.bool&quot;&gt;&lt;code&gt;false&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">次は&lt;a href=&quot;../primitive.bool&quot;&gt; &lt;code&gt;false&lt;/code&gt; を&lt;/a&gt;返します：</target>
        </trans-unit>
        <trans-unit id="1c03f7174ac895e9b31fae2f8cfc928f6b6b192e" translate="yes" xml:space="preserve">
          <source>The following return &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.bool.html&quot;&gt;&lt;code&gt;false&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">The following return &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.bool.html&quot;&gt; &lt;code&gt;false&lt;/code&gt; &lt;/a&gt;:</target>
        </trans-unit>
        <trans-unit id="452576d6c51a73e57d8181671d67361d1616b8f6" translate="yes" xml:space="preserve">
          <source>The following return false:</source>
          <target state="translated">以下はfalseを返します。</target>
        </trans-unit>
        <trans-unit id="b857efb8bb558af5cdfcfd53ef42f4d49fe84301" translate="yes" xml:space="preserve">
          <source>The following rewritten version of &lt;code&gt;another_function&lt;/code&gt; shows what parameters look like in Rust:</source>
          <target state="translated">次の書き直した &lt;code&gt;another_function&lt;/code&gt; のバージョンは、Rustでのパラメーターの外観を示しています。</target>
        </trans-unit>
        <trans-unit id="7befecdaf697f20709a802fcb20813e2f422fba6" translate="yes" xml:space="preserve">
          <source>The following sections contain reference material you may find useful in your Rust journey.</source>
          <target state="translated">以下のセクションには、Rustの旅で役立つ参考資料が掲載されています。</target>
        </trans-unit>
        <trans-unit id="5d4dd709d05236da16b69a96983ce9c67ce45124" translate="yes" xml:space="preserve">
          <source>The following steps install the latest stable version of the Rust compiler. Rust&amp;rsquo;s stability guarantees ensure that all the examples in the book that compile will continue to compile with newer Rust versions. The output might differ slightly between versions, because Rust often improves error messages and warnings. In other words, any newer, stable version of Rust you install using these steps should work as expected with the content of this book.</source>
          <target state="translated">次の手順では、Rustコンパイラの最新の安定バージョンをインストールします。Rustの安定性の保証により、コンパイルされる本のすべての例は、新しいRustバージョンで引き続きコンパイルされます。Rustは多くの場合エラーメッセージと警告を改善するため、出力はバージョン間で若干異なる場合があります。つまり、これらの手順を使用してインストールしたRustの新しい安定したバージョンは、この本の内容で期待どおりに機能するはずです。</target>
        </trans-unit>
        <trans-unit id="d23c37bf8f18aef980fb1fbefe90db0a500a0719" translate="yes" xml:space="preserve">
          <source>The following table gives the size for primitives.</source>
          <target state="translated">以下の表は、プリミティブのサイズを示しています。</target>
        </trans-unit>
        <trans-unit id="3bc9c0126109b1bad1345c2a1d2c68127ed67d67" translate="yes" xml:space="preserve">
          <source>The following traits are implemented for all &lt;code&gt;&amp;amp;T&lt;/code&gt;, regardless of the type of its referent:</source>
          <target state="translated">次の特性は、その参照先のタイプに関係なく、すべての &lt;code&gt;&amp;amp;T&lt;/code&gt; に実装されています。</target>
        </trans-unit>
        <trans-unit id="3e9fcf457a5e9ecd7495ab63bfd0f41db2476290" translate="yes" xml:space="preserve">
          <source>The following traits are implemented on &lt;code&gt;&amp;amp;T&lt;/code&gt; references if the underlying &lt;code&gt;T&lt;/code&gt; also implements that trait:</source>
          <target state="translated">以下の特性は、基礎となる &lt;code&gt;T&lt;/code&gt; もその特性を実装する場合、 &lt;code&gt;&amp;amp;T&lt;/code&gt; 参照に実装されます。</target>
        </trans-unit>
        <trans-unit id="be48c1df52265e0b68ec35bc1f2481219af6ad7a" translate="yes" xml:space="preserve">
          <source>The following will print &quot;Custom panic hook&quot;:</source>
          <target state="translated">以下は「カスタムパニックフック」と印刷されます。</target>
        </trans-unit>
        <trans-unit id="882019462e8fd74a5df1bf54582eb004918743ba" translate="yes" xml:space="preserve">
          <source>The following will print &quot;Normal panic&quot;:</source>
          <target state="translated">以下は「通常のパニック」と表示されます。</target>
        </trans-unit>
        <trans-unit id="7ed71896f2a34a4014ac80c7f9efbde1c744961e" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;(..)&lt;/code&gt; with a single &lt;a href=&quot;#rest-patterns&quot;&gt;&lt;em&gt;RestPattern&lt;/em&gt;&lt;/a&gt; is a special form that does not require a comma, and matches a tuple of any size.</source>
          <target state="translated">The form &lt;code&gt;(..)&lt;/code&gt; with a single &lt;a href=&quot;#rest-patterns&quot;&gt;&lt;em&gt;RestPattern&lt;/em&gt;&lt;/a&gt; is a special form that does not require a comma, and matches a tuple of any size.</target>
        </trans-unit>
        <trans-unit id="2a310cc6ed2f47da18129871732d4b9900992d6f" translate="yes" xml:space="preserve">
          <source>The formal way of describing this behavior is that expressions of type &lt;code&gt;!&lt;/code&gt; can be coerced into any other type. We&amp;rsquo;re allowed to end this &lt;code&gt;match&lt;/code&gt; arm with &lt;code&gt;continue&lt;/code&gt; because &lt;code&gt;continue&lt;/code&gt; doesn&amp;rsquo;t return a value; instead, it moves control back to the top of the loop, so in the &lt;code&gt;Err&lt;/code&gt; case, we never assign a value to &lt;code&gt;guess&lt;/code&gt;.</source>
          <target state="translated">この動作を正式に説明する方法は、型の式 &lt;code&gt;!&lt;/code&gt; 他のタイプに強制することができます。 &lt;code&gt;continue&lt;/code&gt; は値を返さないため、この &lt;code&gt;match&lt;/code&gt; アームを &lt;code&gt;continue&lt;/code&gt; で終了できます。代わりに、制御をループの先頭に戻します。そのため、 &lt;code&gt;Err&lt;/code&gt; の場合、 &lt;code&gt;guess&lt;/code&gt; に値を割り当てません。</target>
        </trans-unit>
        <trans-unit id="99bcb45d13b51e9ae5259463fdd2a32bb1c9a90e" translate="yes" xml:space="preserve">
          <source>The full circle constant (&amp;tau;)</source>
          <target state="translated">The full circle constant (&amp;tau;)</target>
        </trans-unit>
        <trans-unit id="cd8574fedd8387c0dcc9c1aeee32062dd23e8095" translate="yes" xml:space="preserve">
          <source>The full path is created by joining the original path to &lt;code&gt;read_dir&lt;/code&gt; with the filename of this entry.</source>
          <target state="translated">フルパスは、 &lt;code&gt;read_dir&lt;/code&gt; への元のパスをこのエントリのファイル名と結合することによって作成されます。</target>
        </trans-unit>
        <trans-unit id="32f32b59c17ac39e46a137b79b14f93e65ff40c1" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;inner_drop&lt;/code&gt; has the type that &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt;&lt;em&gt;should&lt;/em&gt; have, so this makes sure that you do not accidentally use &lt;code&gt;self&lt;/code&gt;/&lt;code&gt;this&lt;/code&gt; in a way that is in conflict with pinning.</source>
          <target state="translated">The function &lt;code&gt;inner_drop&lt;/code&gt; has the type that &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt; &lt;code&gt;drop&lt;/code&gt; &lt;/a&gt;&lt;em&gt;should&lt;/em&gt; have, so this makes sure that you do not accidentally use &lt;code&gt;self&lt;/code&gt; / &lt;code&gt;this&lt;/code&gt; in a way that is in conflict with pinning.</target>
        </trans-unit>
        <trans-unit id="41bd7d7e62e02a905d152c2bd99a0375a7ed8226" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;inner_drop&lt;/code&gt; has the type that &lt;code&gt;drop&lt;/code&gt;&lt;em&gt;should&lt;/em&gt; have, so this makes sure that you do not accidentally use &lt;code&gt;self&lt;/code&gt;/&lt;code&gt;this&lt;/code&gt; in a way that is in conflict with pinning.</source>
          <target state="translated">関数 &lt;code&gt;inner_drop&lt;/code&gt; は、 &lt;code&gt;drop&lt;/code&gt; &lt;em&gt;が&lt;/em&gt;持つ&lt;em&gt;べき&lt;/em&gt;型を持っているので、固定と競合する方法で誤って &lt;code&gt;self&lt;/code&gt; / &lt;code&gt;this&lt;/code&gt; を使用しないようにします。</target>
        </trans-unit>
        <trans-unit id="cf14d5d5cd860e1137527a26dcf1970a6fdcd6cb" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; is unsafe because it takes a raw pointer and must trust that this pointer is valid. The &lt;code&gt;add&lt;/code&gt; method on raw pointers is also unsafe, because it must trust that the offset location is also a valid pointer. Therefore, we had to put an &lt;code&gt;unsafe&lt;/code&gt; block around our calls to &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; and &lt;code&gt;add&lt;/code&gt; so we could call them. By looking at the code and by adding the assertion that &lt;code&gt;mid&lt;/code&gt; must be less than or equal to &lt;code&gt;len&lt;/code&gt;, we can tell that all the raw pointers used within the &lt;code&gt;unsafe&lt;/code&gt; block will be valid pointers to data within the slice. This is an acceptable and appropriate use of &lt;code&gt;unsafe&lt;/code&gt;.</source>
          <target state="translated">The function &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; is unsafe because it takes a raw pointer and must trust that this pointer is valid. The &lt;code&gt;add&lt;/code&gt; method on raw pointers is also unsafe, because it must trust that the offset location is also a valid pointer. Therefore, we had to put an &lt;code&gt;unsafe&lt;/code&gt; block around our calls to &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; and &lt;code&gt;add&lt;/code&gt; so we could call them. By looking at the code and by adding the assertion that &lt;code&gt;mid&lt;/code&gt; must be less than or equal to &lt;code&gt;len&lt;/code&gt; , we can tell that all the raw pointers used within the &lt;code&gt;unsafe&lt;/code&gt; block will be valid pointers to data within the slice. This is an acceptable and appropriate use of &lt;code&gt;unsafe&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bcc8f276c3240e55b6476f93fee8521728c232e7" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; is unsafe because it takes a raw pointer and must trust that this pointer is valid. The &lt;code&gt;offset&lt;/code&gt; method on raw pointers is also unsafe, because it must trust that the offset location is also a valid pointer. Therefore, we had to put an &lt;code&gt;unsafe&lt;/code&gt; block around our calls to &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt; so we could call them. By looking at the code and by adding the assertion that &lt;code&gt;mid&lt;/code&gt; must be less than or equal to &lt;code&gt;len&lt;/code&gt;, we can tell that all the raw pointers used within the &lt;code&gt;unsafe&lt;/code&gt; block will be valid pointers to data within the slice. This is an acceptable and appropriate use of &lt;code&gt;unsafe&lt;/code&gt;.</source>
          <target state="translated">関数 &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; は生のポインタを受け取り、このポインタが有効であることを信頼する必要があるため、安全ではありません。生のポインタの &lt;code&gt;offset&lt;/code&gt; メソッドも、オフセットの場所も有効なポインタであると信頼する必要があるため、安全ではありません。したがって、 &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; と &lt;code&gt;offset&lt;/code&gt; の呼び出しの周りに &lt;code&gt;unsafe&lt;/code&gt; ブロックを配置して、それらを呼び出せるようにする必要がありました。コードを見て、 &lt;code&gt;mid&lt;/code&gt; が &lt;code&gt;len&lt;/code&gt; 以下でなければならないというアサーションを追加することにより、 &lt;code&gt;unsafe&lt;/code&gt; ブロック内で使用されるすべての未加工ポインターは、スライス内のデータへの有効なポインターであることがわかります。これは許容できる適切な使用法です &lt;code&gt;unsafe&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9e2ea4196275fb1f06fa7661da10e384c365aa9f" translate="yes" xml:space="preserve">
          <source>The function body block is contained within the scope of the entire function.</source>
          <target state="translated">関数本体ブロックは、関数全体のスコープ内に含まれています。</target>
        </trans-unit>
        <trans-unit id="2cd654b546be7671958f348149444656b0175877" translate="yes" xml:space="preserve">
          <source>The function body uses the &lt;code&gt;assert_eq!&lt;/code&gt; macro to assert that 2 + 2 equals 4. This assertion serves as an example of the format for a typical test. Let&amp;rsquo;s run it to see that this test passes.</source>
          <target state="translated">関数本体は &lt;code&gt;assert_eq!&lt;/code&gt; を使用します。2 + 2が4に等しいことをアサートするマクロ。このアサーションは、一般的なテストのフォーマットの例として機能します。それを実行して、このテストに合格することを確認しましょう。</target>
        </trans-unit>
        <trans-unit id="fce36fec5fc1977be02dde267db493eca3e79d7a" translate="yes" xml:space="preserve">
          <source>The function must be called with valid byte array &lt;code&gt;buf&lt;/code&gt; of sufficient size to hold the message bytes. If a message is too long to fit in the supplied buffer, excess bytes may be discarded.</source>
          <target state="translated">関数は、メッセージバイトを保持するのに十分なサイズの有効なバイト配列 &lt;code&gt;buf&lt;/code&gt; を使用して呼び出す必要があります。メッセージが長すぎて提供されたバッファに収まらない場合、余分なバイトが破棄されることがあります。</target>
        </trans-unit>
        <trans-unit id="e529ccf733a9b5ef8b1c476a20d42d70328c6fe4" translate="yes" xml:space="preserve">
          <source>The function panics if &lt;code&gt;align&lt;/code&gt; is not a power-of-two.</source>
          <target state="translated">&lt;code&gt;align&lt;/code&gt; が2のべき乗でない場合、関数はパニックになります。</target>
        </trans-unit>
        <trans-unit id="3c4c57538d04834ae5173c38a3f23dea7037d387" translate="yes" xml:space="preserve">
          <source>The function signature now tells Rust that for some lifetime &lt;code&gt;'a&lt;/code&gt;, the function takes two parameters, both of which are string slices that live at least as long as lifetime &lt;code&gt;'a&lt;/code&gt;. The function signature also tells Rust that the string slice returned from the function will live at least as long as lifetime &lt;code&gt;'a&lt;/code&gt;. In practice, it means that the lifetime of the reference returned by the &lt;code&gt;longest&lt;/code&gt; function is the same as the smaller of the lifetimes of the references passed in. These constraints are what we want Rust to enforce. Remember, when we specify the lifetime parameters in this function signature, we&amp;rsquo;re not changing the lifetimes of any values passed in or returned. Rather, we&amp;rsquo;re specifying that the borrow checker should reject any values that don&amp;rsquo;t adhere to these constraints. Note that the &lt;code&gt;longest&lt;/code&gt; function doesn&amp;rsquo;t need to know exactly how long &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; will live, only that some scope can be substituted for &lt;code&gt;'a&lt;/code&gt; that will satisfy this signature.</source>
          <target state="translated">関数のシグネチャは、あるライフタイム &lt;code&gt;'a&lt;/code&gt; に対して、関数が2つのパラメーターを取ることをRustに伝えます。これらのパラメーターは両方とも、少なくともライフタイム &lt;code&gt;'a&lt;/code&gt; 同じ長さの文字列スライスです。関数のシグネチャは、関数から返された文字列スライスが少なくともライフタイム &lt;code&gt;'a&lt;/code&gt; と同じ長さになることをRustに伝えます。実際には、参照の有効期間が &lt;code&gt;longest&lt;/code&gt; 返されることを意味します関数は、渡された参照の有効期間の短い方と同じです。これらの制約は、Rustに適用させたいものです。この関数のシグネチャでライフタイムパラメータを指定しても、渡されたり返されたりする値のライフタイムは変更されません。むしろ、借用チェッカーがこれらの制約に準拠していない値を拒否するように指定しています。 &lt;code&gt;longest&lt;/code&gt; 関数は、 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; がどれだけ長く存続するかを正確に知る必要がないことに注意してください。このシグネチャを満たす &lt;code&gt;'a&lt;/code&gt; の代わりに、いくつかのスコープを使用できます。</target>
        </trans-unit>
        <trans-unit id="bdcb7a1c11baa13711e61ba40d7e28572f624f97" translate="yes" xml:space="preserve">
          <source>The function that defines a procedural macro takes a &lt;code&gt;TokenStream&lt;/code&gt; as an input and produces a &lt;code&gt;TokenStream&lt;/code&gt; as an output. The &lt;code&gt;TokenStream&lt;/code&gt; type is defined by the &lt;code&gt;proc_macro&lt;/code&gt; crate that is included with Rust and represents a sequence of tokens. This is the core of the macro: the source code that the macro is operating on makes up the input &lt;code&gt;TokenStream&lt;/code&gt;, and the code the macro produces is the output &lt;code&gt;TokenStream&lt;/code&gt;. The function also has an attribute attached to it that specifies which kind of procedural macro we&amp;rsquo;re creating. We can have multiple kinds of procedural macros in the same crate.</source>
          <target state="translated">手続きマクロを定義する関数がかかり &lt;code&gt;TokenStream&lt;/code&gt; を入力とし、生成 &lt;code&gt;TokenStream&lt;/code&gt; を出力として。 &lt;code&gt;TokenStream&lt;/code&gt; のタイプは、によって定義さ &lt;code&gt;proc_macro&lt;/code&gt; 錆に含まれており、トークンのシーケンスを示しているクレート。これがマクロのコアです。マクロが操作しているソースコードが入力 &lt;code&gt;TokenStream&lt;/code&gt; を構成し、マクロが生成するコードが出力 &lt;code&gt;TokenStream&lt;/code&gt; です。この関数には、作成する手続き型マクロの種類を指定する属性も付加されています。同じクレートに複数の種類の手続きマクロを含めることができます。</target>
        </trans-unit>
        <trans-unit id="bf36f24b39c35b8342b2a6251cb9fb9f153537b5" translate="yes" xml:space="preserve">
          <source>The function will never return and will immediately terminate the current process in a platform specific &quot;abnormal&quot; manner.</source>
          <target state="translated">この関数は決して戻りませんし、プラットフォーム固有の「異常」な方法で現在のプロセスを即座に終了させます。</target>
        </trans-unit>
        <trans-unit id="0c78d2fcec6d6debbe4ef0124bd9c3f517852fce" translate="yes" xml:space="preserve">
          <source>The functional record update syntax is only allowed for structs (struct-like enum variants don't qualify, for example). To fix the previous code, rewrite the expression without functional record update syntax:</source>
          <target state="translated">関数レコード更新構文は構造体に対してのみ許可されています (例えば、構造体のような enum バリアントは資格がありません)。先ほどのコードを修正するには、関数的レコード更新構文を使わずに式を書き換えます。</target>
        </trans-unit>
        <trans-unit id="4265d286c4ebab2fa68494c58f7e5472bec6ff8e" translate="yes" xml:space="preserve">
          <source>The functional record update syntax is only allowed for structs. (Struct-like enum variants don't qualify, for example.)</source>
          <target state="translated">関数レコード更新構文は構造体に対してのみ許可されています。(例えば、構造体のような列挙型のバリアントは適格ではありません)。</target>
        </trans-unit>
        <trans-unit id="771371fc3674c285662522a3ce8c91121a8eb8d5" translate="yes" xml:space="preserve">
          <source>The functional record update syntax was used on something other than a struct.</source>
          <target state="translated">関数レコード更新構文が struct 以外のもので使用されました。</target>
        </trans-unit>
        <trans-unit id="3064e7a399dc1562d735ddcb75b4d1c141aa6d18" translate="yes" xml:space="preserve">
          <source>The functionality and syntax of Rust can be extended with custom definitions called macros. They are given names, and invoked through a consistent syntax:&lt;code&gt;some_extension!(...)&lt;/code&gt;.</source>
          <target state="translated">Rustの機能と構文は、マクロと呼ばれるカスタム定義で拡張できます。それらには名前が付けられ、一貫した構文 &lt;code&gt;some_extension!(...)&lt;/code&gt; を通じて呼び出されます。</target>
        </trans-unit>
        <trans-unit id="90f6e5d380880e28cc22176bc452d0a2cfb51f5f" translate="yes" xml:space="preserve">
          <source>The functions inside this struct are only intended be called on the &lt;code&gt;data&lt;/code&gt; pointer of a properly constructed &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; object from inside the &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; implementation. Calling one of the contained functions using any other &lt;code&gt;data&lt;/code&gt; pointer will cause undefined behavior.</source>
          <target state="translated">この構造体内の関数は、&lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt;実装内から適切に構築された&lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt;オブジェクトの &lt;code&gt;data&lt;/code&gt; ポインターでのみ呼び出されることを目的としています。他の &lt;code&gt;data&lt;/code&gt; ポインターを使用して含まれている関数の1つを呼び出すと、未定義の動作が発生します。</target>
        </trans-unit>
        <trans-unit id="5d3fe931a60678fe761ffe2bfb5b03361ca50257" translate="yes" xml:space="preserve">
          <source>The functions inside this struct are only intended to be called on the &lt;code&gt;data&lt;/code&gt; pointer of a properly constructed &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; object from inside the &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; implementation. Calling one of the contained functions using any other &lt;code&gt;data&lt;/code&gt; pointer will cause undefined behavior.</source>
          <target state="translated">The functions inside this struct are only intended to be called on the &lt;code&gt;data&lt;/code&gt; pointer of a properly constructed &lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt; object from inside the &lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt; implementation. Calling one of the contained functions using any other &lt;code&gt;data&lt;/code&gt; pointer will cause undefined behavior.</target>
        </trans-unit>
        <trans-unit id="df0966ed788f9044d3bbbf28ed214b74382d234e" translate="yes" xml:space="preserve">
          <source>The general case</source>
          <target state="translated">一般的なケース</target>
        </trans-unit>
        <trans-unit id="44389c2bb8540f5071dbf79b16d89782c82ab1a7" translate="yes" xml:space="preserve">
          <source>The general categories for numbers (&lt;code&gt;Nd&lt;/code&gt; for decimal digits, &lt;code&gt;Nl&lt;/code&gt; for letter-like numeric characters, and &lt;code&gt;No&lt;/code&gt; for other numeric characters) are specified in the &lt;a href=&quot;https://www.unicode.org/reports/tr44/&quot;&gt;Unicode Character Database&lt;/a&gt;&lt;a href=&quot;https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt&quot;&gt;&lt;code&gt;UnicodeData.txt&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">The general categories for numbers ( &lt;code&gt;Nd&lt;/code&gt; for decimal digits, &lt;code&gt;Nl&lt;/code&gt; for letter-like numeric characters, and &lt;code&gt;No&lt;/code&gt; for other numeric characters) are specified in the &lt;a href=&quot;https://www.unicode.org/reports/tr44/&quot;&gt;Unicode Character Database&lt;/a&gt;&lt;a href=&quot;https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt&quot;&gt; &lt;code&gt;UnicodeData.txt&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="3a1ceefd46a3c1a3651802a4204c4c589bc3c7f6" translate="yes" xml:space="preserve">
          <source>The generated &lt;code&gt;impl&lt;/code&gt; for &lt;code&gt;PartialEq&lt;/code&gt; is equivalent to</source>
          <target state="translated">&lt;code&gt;PartialEq&lt;/code&gt; に対して生成された &lt;code&gt;impl&lt;/code&gt; は、次と同等です。</target>
        </trans-unit>
        <trans-unit id="b683f5ed135731413c6d034116ca989acf594401" translate="yes" xml:space="preserve">
          <source>The generator completed with a return value.</source>
          <target state="translated">ジェネレーターは戻り値で完了しました。</target>
        </trans-unit>
        <trans-unit id="156bc757a593c6f0753b493e20c7157ef75917ae" translate="yes" xml:space="preserve">
          <source>The generator suspended with a value.</source>
          <target state="translated">値で吊り下げられたジェネレーター。</target>
        </trans-unit>
        <trans-unit id="cd45c192be4dc3d892b1ef2f0b632aaff12d6653" translate="yes" xml:space="preserve">
          <source>The generic type &lt;code&gt;T&lt;/code&gt; specified as the type of the &lt;code&gt;item1&lt;/code&gt; and &lt;code&gt;item2&lt;/code&gt; parameters constrains the function such that the concrete type of the value passed as an argument for &lt;code&gt;item1&lt;/code&gt; and &lt;code&gt;item2&lt;/code&gt; must be the same.</source>
          <target state="translated">ジェネリック型 &lt;code&gt;T&lt;/code&gt; をタイプとして指定 &lt;code&gt;item1&lt;/code&gt; と &lt;code&gt;item2&lt;/code&gt; 値の具体的なタイプは、の引数として渡されるように、パラメータ制約関数 &lt;code&gt;item1&lt;/code&gt; と &lt;code&gt;item2&lt;/code&gt; 同じでなければなりません。</target>
        </trans-unit>
        <trans-unit id="1bc01fb3a417f3ff749e03a42ff1490b6833bd43" translate="yes" xml:space="preserve">
          <source>The generic type has to be a SIMD type. Example:</source>
          <target state="translated">汎用型はSIMD型でなければなりません。例を挙げておきます。</target>
        </trans-unit>
        <trans-unit id="e58faf99c3204433210564e65725762b8514494f" translate="yes" xml:space="preserve">
          <source>The given &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt;&lt;strong&gt;must&lt;/strong&gt; have one nul byte as its last element. This means it cannot be empty nor have any other nul byte anywhere else.</source>
          <target state="translated">The given &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/a&gt;&lt;strong&gt;must&lt;/strong&gt; have one nul byte as its last element. This means it cannot be empty nor have any other nul byte anywhere else.</target>
        </trans-unit>
        <trans-unit id="b25fdf4b8d15b07b7d25cece8768d803831d5b3d" translate="yes" xml:space="preserve">
          <source>The given block must have been produced by this allocator, and must be suitable for storing a &lt;code&gt;T&lt;/code&gt; (in terms of alignment as well as minimum and maximum size); otherwise yields undefined behavior.</source>
          <target state="translated">指定されたブロックは、このアロケータによって生成されたものである必要があり、 &lt;code&gt;T&lt;/code&gt; を格納するのに適している必要があります（配置および最小サイズと最大サイズに関して）。そうしないと、未定義の動作が発生します。</target>
        </trans-unit>
        <trans-unit id="3ef7afeafd2e9737676d96a4cbd3c7dc2e9ffdbc" translate="yes" xml:space="preserve">
          <source>The glob operator is often used when testing to bring everything under test into the &lt;code&gt;tests&lt;/code&gt; module; we&amp;rsquo;ll talk about that in the &lt;a href=&quot;ch11-01-writing-tests#how-to-write-tests&quot;&gt;&amp;ldquo;How to Write Tests&amp;rdquo;&lt;/a&gt; section in Chapter 11. The glob operator is also sometimes used as part of the prelude pattern: see &lt;a href=&quot;../std/prelude/index#other-preludes&quot;&gt;the standard library documentation&lt;/a&gt; for more information on that pattern.</source>
          <target state="translated">テスト中のすべてのものを持ってテストするときグロブ演算子は、多くの場合、使用されている &lt;code&gt;tests&lt;/code&gt; モジュール。これについては、第11章の&lt;a href=&quot;ch11-01-writing-tests#how-to-write-tests&quot;&gt;「テストの&lt;/a&gt;記述方法」で説明します。glob演算子は、プレリュードパターンの一部として使用されることもあります。そのパターンの詳細について&lt;a href=&quot;../std/prelude/index#other-preludes&quot;&gt;は、標準ライブラリのドキュメント&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="edae830710bf3e8598def4042b918afe98bc10c2" translate="yes" xml:space="preserve">
          <source>The global memory allocator.</source>
          <target state="translated">グローバルメモリアロケータです。</target>
        </trans-unit>
        <trans-unit id="ec4646ba1a1fdd24f47203209a1bde5837e4ed73" translate="yes" xml:space="preserve">
          <source>The good news is that if the structure &lt;em&gt;isn&amp;rsquo;t&lt;/em&gt; convenient for others to use from another library, you don&amp;rsquo;t have to rearrange your internal organization: instead, you can re-export items to make a public structure that&amp;rsquo;s different from your private structure by using &lt;code&gt;pub use&lt;/code&gt;. Re-exporting takes a public item in one location and makes it public in another location, as if it were defined in the other location instead.</source>
          <target state="translated">良いニュースは、構造&lt;em&gt;が&lt;/em&gt;他のライブラリから他の人が使用するのに都合が悪い場合は、内部組織を再配置する必要がないことです。代わりに、アイテムを再エクスポートして、プライベート構造とは異なるパブリック構造を作成できます。使用して &lt;code&gt;pub use&lt;/code&gt; 。再エクスポートでは、1つの場所でパブリックアイテムを取得し、別の場所で定義されているかのように、別の場所でパブリックアイテムを公開します。</target>
        </trans-unit>
        <trans-unit id="9e529cd967841dc9eed1fc815f3a4e6b886e5b38" translate="yes" xml:space="preserve">
          <source>The grammar and lexical structure is in blockquotes with either &quot;Lexer&quot; or &quot;Syntax&quot; in &lt;sup&gt;&lt;strong&gt;bold superscript&lt;/strong&gt;&lt;/sup&gt; as the first line.</source>
          <target state="translated">文法と字句構造は、「Lexer」または「Syntax」のいずれかを&lt;sup&gt;&lt;strong&gt;太字の上付き文字&lt;/strong&gt;&lt;/sup&gt;で最初の行としてブロック引用符で囲んでいます。</target>
        </trans-unit>
        <trans-unit id="1f36df1235888018fbfcd5153ebfed60de89aef3" translate="yes" xml:space="preserve">
          <source>The grammar production for reference patterns has to match the token &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; to match a reference to a reference because it is a token by itself, not two &lt;code&gt;&amp;amp;&lt;/code&gt; tokens.</source>
          <target state="translated">参照パターンの文法生成では、トークン &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; を参照への参照と照合する必要があります。これは、2つの &lt;code&gt;&amp;amp;&lt;/code&gt; トークンではなく、それ自体がトークンであるためです。</target>
        </trans-unit>
        <trans-unit id="ecdb2fc042ccb9955819301d5b939d1fbe330ddf" translate="yes" xml:space="preserve">
          <source>The green-threading M:N model requires a larger language runtime to manage threads. As such, the Rust standard library only provides an implementation of 1:1 threading. Because Rust is such a low-level language, there are crates that implement M:N threading if you would rather trade overhead for aspects such as more control over which threads run when and lower costs of context switching, for example.</source>
          <target state="translated">グリーン スレッディングの M:N モデルでは、スレッドを管理するために、より大きな言語ランタイムが必要です。そのため、Rust 標準ライブラリは 1:1 スレッディングの実装しか提供していません。Rustはそのような低レベルの言語であるため、どのスレッドがいつ実行されるかの制御やコンテキスト切り替えのコスト削減などのオーバーヘッドと交換したい場合は、M:N スレッディングを実装するクレートがあります。</target>
        </trans-unit>
        <trans-unit id="ebee4d45f3971e13391e35d52c5a14b0340c1efd" translate="yes" xml:space="preserve">
          <source>The handle for reading from the child's standard error (stderr), if it has been captured.</source>
          <target state="translated">子の標準エラー (stderr)がキャプチャされている場合に、その子の標準エラー (stderr)から読み出すためのハンドル。</target>
        </trans-unit>
        <trans-unit id="71a4cc891c9774ed993ea2778e2ec4e78d46aa4f" translate="yes" xml:space="preserve">
          <source>The handle for reading from the child's standard error (stderr), if it has been captured. You might find it helpful to do</source>
          <target state="translated">子の標準エラー(stderr)がキャプチャされている場合に、その子の標準エラー(stderr)から読み出すためのハンドル。を実行すると便利かもしれません。</target>
        </trans-unit>
        <trans-unit id="fbdaac9b24bb1d15aadc721c15a3031cb1337d9a" translate="yes" xml:space="preserve">
          <source>The handle for reading from the child's standard output (stdout), if it has been captured.</source>
          <target state="translated">子の標準出力 (stdout)がキャプチャされている場合に、その子の標準出力から読み出すためのハンドル。</target>
        </trans-unit>
        <trans-unit id="5b65d5fd43c0bfac48d483d2399323a0f40fd595" translate="yes" xml:space="preserve">
          <source>The handle for reading from the child's standard output (stdout), if it has been captured. You might find it helpful to do</source>
          <target state="translated">子の標準出力 (stdout)がキャプチャされている場合に、その子の標準出力から読み出すためのハンドル。を実行すると便利かもしれません。</target>
        </trans-unit>
        <trans-unit id="d208573c971bb153ba34475100ea53bd4242537e" translate="yes" xml:space="preserve">
          <source>The handle for writing to the child's standard input (stdin), if it has been captured.</source>
          <target state="translated">子の標準入力 (stdin)に書き込むためのハンドル (キャプチャされている場合)。</target>
        </trans-unit>
        <trans-unit id="1008f723c1fd717a94e8a77d7bc5c5ff92ef4700" translate="yes" xml:space="preserve">
          <source>The handle for writing to the child's standard input (stdin), if it has been captured. To avoid partially moving the &lt;code&gt;child&lt;/code&gt; and thus blocking yourself from calling functions on &lt;code&gt;child&lt;/code&gt; while using &lt;code&gt;stdin&lt;/code&gt;, you might find it helpful:</source>
          <target state="translated">The handle for writing to the child's standard input (stdin), if it has been captured. To avoid partially moving the &lt;code&gt;child&lt;/code&gt; and thus blocking yourself from calling functions on &lt;code&gt;child&lt;/code&gt; while using &lt;code&gt;stdin&lt;/code&gt; , you might find it helpful:</target>
        </trans-unit>
        <trans-unit id="a9febcaaba526b722c76a7ab2b805ffd862b6652" translate="yes" xml:space="preserve">
          <source>The hash map is initially created with a capacity of 0, so it will not allocate until it is first inserted into.</source>
          <target state="translated">ハッシュマップは最初は容量0で作成されるので、最初に挿入されるまでは割り当てられません。</target>
        </trans-unit>
        <trans-unit id="ee8ffcf3c4827d14350f3675ea8e7360ee55ee19" translate="yes" xml:space="preserve">
          <source>The hash map will be able to hold at least &lt;code&gt;capacity&lt;/code&gt; elements without reallocating. If &lt;code&gt;capacity&lt;/code&gt; is 0, the hash map will not allocate.</source>
          <target state="translated">ハッシュマップは、再割り当てすることなく、少なくとも &lt;code&gt;capacity&lt;/code&gt; 要素を保持できます。場合は &lt;code&gt;capacity&lt;/code&gt; 0で、ハッシュマップは割り当てません。</target>
        </trans-unit>
        <trans-unit id="0b56c1bdca2b1b95316afe0ecdd6afdabfe66713" translate="yes" xml:space="preserve">
          <source>The hash set is also created with the default initial capacity.</source>
          <target state="translated">ハッシュセットもデフォルトの初期容量で作成されます。</target>
        </trans-unit>
        <trans-unit id="b637bd7a31fb790788f10cfb96ebb867cfd6151d" translate="yes" xml:space="preserve">
          <source>The hash set is initially created with a capacity of 0, so it will not allocate until it is first inserted into.</source>
          <target state="translated">ハッシュセットは最初は容量0で作成されるので、最初に挿入されるまでは割り当てられません。</target>
        </trans-unit>
        <trans-unit id="7b099ba43b1ded8417cfcd0145835bc5cf64881f" translate="yes" xml:space="preserve">
          <source>The hash set will be able to hold at least &lt;code&gt;capacity&lt;/code&gt; elements without reallocating. If &lt;code&gt;capacity&lt;/code&gt; is 0, the hash set will not allocate.</source>
          <target state="translated">ハッシュセットは、再割り当てすることなく、少なくとも &lt;code&gt;capacity&lt;/code&gt; 要素を保持できます。場合は &lt;code&gt;capacity&lt;/code&gt; 0で、ハッシュセットは割り当てません。</target>
        </trans-unit>
        <trans-unit id="d8a4e0ea14c5f027cfeb61abdb7d26fe519f8ab6" translate="yes" xml:space="preserve">
          <source>The hash table implementation is a Rust port of Google's &lt;a href=&quot;https://abseil.io/blog/20180927-swisstables&quot;&gt;SwissTable&lt;/a&gt;. The original C++ version of SwissTable can be found &lt;a href=&quot;https://github.com/abseil/abseil-cpp/blob/master/absl/container/internal/raw_hash_set.h&quot;&gt;here&lt;/a&gt;, and this &lt;a href=&quot;https://www.youtube.com/watch?v=ncHmEUmJZf4&quot;&gt;CppCon talk&lt;/a&gt; gives an overview of how the algorithm works.</source>
          <target state="translated">ハッシュテーブルの実装は、Googleの&lt;a href=&quot;https://abseil.io/blog/20180927-swisstables&quot;&gt;SwissTableの&lt;/a&gt; Rustポートです。元のC ++バージョンのSwissTableは&lt;a href=&quot;https://github.com/abseil/abseil-cpp/blob/master/absl/container/internal/raw_hash_set.h&quot;&gt;こちら&lt;/a&gt;にあります。この&lt;a href=&quot;https://www.youtube.com/watch?v=ncHmEUmJZf4&quot;&gt;CppConの講演で&lt;/a&gt;は、アルゴリズムのしくみの概要を説明しています。</target>
        </trans-unit>
        <trans-unit id="415bb7e03ead8b051422fe277c860425b7ebbf61" translate="yes" xml:space="preserve">
          <source>The hashing algorithm can be replaced on a per-&lt;code&gt;HashMap&lt;/code&gt; basis using the &lt;a href=&quot;#method.default&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#method.with_hasher&quot;&gt;&lt;code&gt;with_hasher&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#method.with_capacity_and_hasher&quot;&gt;&lt;code&gt;with_capacity_and_hasher&lt;/code&gt;&lt;/a&gt; methods. Many alternative algorithms are available on crates.io, such as the &lt;a href=&quot;https://crates.io/crates/fnv&quot;&gt;&lt;code&gt;fnv&lt;/code&gt;&lt;/a&gt; crate.</source>
          <target state="translated">ハッシュアルゴリズムは、&lt;a href=&quot;#method.default&quot;&gt; &lt;code&gt;default&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#method.with_hasher&quot;&gt; &lt;code&gt;with_hasher&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;#method.with_capacity_and_hasher&quot;&gt; &lt;code&gt;with_capacity_and_hasher&lt;/code&gt; &lt;/a&gt;メソッドを使用して、 &lt;code&gt;HashMap&lt;/code&gt; ごとに置き換えることができます。多くの代替アルゴリズムは、次のような、crates.io上で利用可能な&lt;a href=&quot;https://crates.io/crates/fnv&quot;&gt; &lt;code&gt;fnv&lt;/code&gt; &lt;/a&gt;木箱。</target>
        </trans-unit>
        <trans-unit id="142488b9261462c1e559bf3f2ad49337e31e2ac1" translate="yes" xml:space="preserve">
          <source>The hashing algorithm can be replaced on a per-&lt;code&gt;HashMap&lt;/code&gt; basis using the &lt;a href=&quot;../../default/trait.default#tymethod.default&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../struct.hashmap#method.with_hasher&quot;&gt;&lt;code&gt;with_hasher&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../struct.hashmap#method.with_capacity_and_hasher&quot;&gt;&lt;code&gt;with_capacity_and_hasher&lt;/code&gt;&lt;/a&gt; methods. Many alternative algorithms are available on crates.io, such as the &lt;a href=&quot;https://crates.io/crates/fnv&quot;&gt;&lt;code&gt;fnv&lt;/code&gt;&lt;/a&gt; crate.</source>
          <target state="translated">The hashing algorithm can be replaced on a per- &lt;code&gt;HashMap&lt;/code&gt; basis using the &lt;a href=&quot;../../default/trait.default#tymethod.default&quot;&gt; &lt;code&gt;default&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;../struct.hashmap#method.with_hasher&quot;&gt; &lt;code&gt;with_hasher&lt;/code&gt; &lt;/a&gt;, and &lt;a href=&quot;../struct.hashmap#method.with_capacity_and_hasher&quot;&gt; &lt;code&gt;with_capacity_and_hasher&lt;/code&gt; &lt;/a&gt; methods. Many alternative algorithms are available on crates.io, such as the &lt;a href=&quot;https://crates.io/crates/fnv&quot;&gt; &lt;code&gt;fnv&lt;/code&gt; &lt;/a&gt; crate.</target>
        </trans-unit>
        <trans-unit id="417d67f06aec820d5f0416a0fabba770f0ab5392" translate="yes" xml:space="preserve">
          <source>The hashing algorithm can be replaced on a per-&lt;code&gt;HashMap&lt;/code&gt; basis using the &lt;a href=&quot;../default/trait.default#tymethod.default&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.hashmap#method.with_hasher&quot;&gt;&lt;code&gt;with_hasher&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;struct.hashmap#method.with_capacity_and_hasher&quot;&gt;&lt;code&gt;with_capacity_and_hasher&lt;/code&gt;&lt;/a&gt; methods. Many alternative algorithms are available on crates.io, such as the &lt;a href=&quot;https://crates.io/crates/fnv&quot;&gt;&lt;code&gt;fnv&lt;/code&gt;&lt;/a&gt; crate.</source>
          <target state="translated">The hashing algorithm can be replaced on a per- &lt;code&gt;HashMap&lt;/code&gt; basis using the &lt;a href=&quot;../default/trait.default#tymethod.default&quot;&gt; &lt;code&gt;default&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;struct.hashmap#method.with_hasher&quot;&gt; &lt;code&gt;with_hasher&lt;/code&gt; &lt;/a&gt;, and &lt;a href=&quot;struct.hashmap#method.with_capacity_and_hasher&quot;&gt; &lt;code&gt;with_capacity_and_hasher&lt;/code&gt; &lt;/a&gt; methods. Many alternative algorithms are available on crates.io, such as the &lt;a href=&quot;https://crates.io/crates/fnv&quot;&gt; &lt;code&gt;fnv&lt;/code&gt; &lt;/a&gt; crate.</target>
        </trans-unit>
        <trans-unit id="36e2055f1b7671fa46f87316bf9cf49547025536" translate="yes" xml:space="preserve">
          <source>The heart and soul of this module is the &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; trait. The core of &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; looks like this:</source>
          <target state="translated">このモジュールの中心となるのは、&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;特性です。&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;のコアは次のようになります。</target>
        </trans-unit>
        <trans-unit id="f7cf9da11ff393d577012f24f0fd7f9d800c440a" translate="yes" xml:space="preserve">
          <source>The heart of the change is that where &lt;code&gt;&amp;amp;'a Box&amp;lt;SomeTrait&amp;gt;&lt;/code&gt; used to default to &lt;code&gt;&amp;amp;'a Box&amp;lt;SomeTrait+'a&amp;gt;&lt;/code&gt;, it now defaults to &lt;code&gt;&amp;amp;'a Box&amp;lt;SomeTrait+'static&amp;gt;&lt;/code&gt; (here, &lt;code&gt;SomeTrait&lt;/code&gt; is the name of some trait type). Note that the only types which are affected are references to boxes, like &lt;code&gt;&amp;amp;Box&amp;lt;SomeTrait&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;amp;[Box&amp;lt;SomeTrait&amp;gt;]&lt;/code&gt;. More common types like &lt;code&gt;&amp;amp;SomeTrait&lt;/code&gt; or &lt;code&gt;Box&amp;lt;SomeTrait&amp;gt;&lt;/code&gt; are unaffected.</source>
          <target state="translated">変更の中心は、 &lt;code&gt;&amp;amp;'a Box&amp;lt;SomeTrait&amp;gt;&lt;/code&gt; がデフォルトで &lt;code&gt;&amp;amp;'a Box&amp;lt;SomeTrait+'a&amp;gt;&lt;/code&gt; に使用されていた場所でしたが、現在はデフォルトで &lt;code&gt;&amp;amp;'a Box&amp;lt;SomeTrait+'static&amp;gt;&lt;/code&gt; （ここで、 &lt;code&gt;SomeTrait&lt;/code&gt; は一部の特性タイプ）。影響を受けるのは、 &lt;code&gt;&amp;amp;Box&amp;lt;SomeTrait&amp;gt;&lt;/code&gt; や &lt;code&gt;&amp;amp;[Box&amp;lt;SomeTrait&amp;gt;]&lt;/code&gt; などのボックスへの参照のみです。 &lt;code&gt;&amp;amp;SomeTrait&lt;/code&gt; や &lt;code&gt;Box&amp;lt;SomeTrait&amp;gt;&lt;/code&gt; などのより一般的なタイプは影響を受けません。</target>
        </trans-unit>
        <trans-unit id="8b80292943879aaefba4fcd89176f25fb4fe681b" translate="yes" xml:space="preserve">
          <source>The help text reveals that the return type needs a generic lifetime parameter on it because Rust can&amp;rsquo;t tell whether the reference being returned refers to &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt;. Actually, we don&amp;rsquo;t know either, because the &lt;code&gt;if&lt;/code&gt; block in the body of this function returns a reference to &lt;code&gt;x&lt;/code&gt; and the &lt;code&gt;else&lt;/code&gt; block returns a reference to &lt;code&gt;y&lt;/code&gt;!</source>
          <target state="translated">Rustは返された参照が &lt;code&gt;x&lt;/code&gt; を参照しているか &lt;code&gt;y&lt;/code&gt; を参照しているかを判別できないため、ヘルプテキストから、戻り値の型にはジェネリックライフタイムパラメーターが必要であることがわかります。この関数の本体の &lt;code&gt;if&lt;/code&gt; ブロックは &lt;code&gt;x&lt;/code&gt; への参照を返し、 &lt;code&gt;else&lt;/code&gt; ブロックは &lt;code&gt;y&lt;/code&gt; への参照を返すため、実際にはどちらもわかりません。</target>
        </trans-unit>
        <trans-unit id="d58a9f4bf1938432cc316db1e69ad2bfca3de5d4" translate="yes" xml:space="preserve">
          <source>The highest valid code point a &lt;code&gt;char&lt;/code&gt; can have.</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; が持つことができる最も高い有効なコードポイント。</target>
        </trans-unit>
        <trans-unit id="2c0d414ff9adc0b33c0f3d50d800e4ef1b9ec6d2" translate="yes" xml:space="preserve">
          <source>The hook is provided with a &lt;code&gt;Layout&lt;/code&gt; struct which contains information about the allocation that failed.</source>
          <target state="translated">フックには、失敗した割り当てに関する情報を含む &lt;code&gt;Layout&lt;/code&gt; 構造体が付属しています。</target>
        </trans-unit>
        <trans-unit id="c05a8db594383eaa649c0ea9f1230d31e2d9d207" translate="yes" xml:space="preserve">
          <source>The hook is provided with a &lt;code&gt;PanicInfo&lt;/code&gt; struct which contains information about the origin of the panic, including the payload passed to &lt;code&gt;panic!&lt;/code&gt; and the source code location from which the panic originated.</source>
          <target state="translated">フックには、パニックに渡されたペイロードを含む、パニックの発生元に関する情報を含む &lt;code&gt;PanicInfo&lt;/code&gt; 構造体が用意されています &lt;code&gt;panic!&lt;/code&gt; パニックが発生したソースコードの場所。</target>
        </trans-unit>
        <trans-unit id="c5e73d7bf13606a783c42b98ca4eecc2c703d2de" translate="yes" xml:space="preserve">
          <source>The identifier is more than one character. &lt;code&gt;_&lt;/code&gt; alone is not an identifier.</source>
          <target state="translated">識別子が複数の文字です。 &lt;code&gt;_&lt;/code&gt; だけでは識別子ではありません。</target>
        </trans-unit>
        <trans-unit id="714243f838efe98c2e10bdbb7f1411daa3ecd7a0" translate="yes" xml:space="preserve">
          <source>The identifier is the name of the constant used in the path. The type is the type that the definition has to implement.</source>
          <target state="translated">識別子はパスで使用される定数の名前です。typeは定義が実装しなければならない型です。</target>
        </trans-unit>
        <trans-unit id="3a2c9033b8c31ad61606f019cbc00c4420b891b9" translate="yes" xml:space="preserve">
          <source>The identifier is the name of the declared type alias. The optional trait bounds must be fulfilled by the implementations of the type alias.</source>
          <target state="translated">識別子は宣言された型のエイリアスの名前です。オプションの trait バウンズは、型エイリアスの実装によって満たされなければなりません。</target>
        </trans-unit>
        <trans-unit id="1c83f053af5e622145b3145a7189cafa0c9167a0" translate="yes" xml:space="preserve">
          <source>The identifier is the name of the function. The generics, parameter list, return type, and where clause of the associated function must be the same as the associated function declarations's.</source>
          <target state="translated">識別子は関数名です。関連する関数のジェネリック、パラメータリスト、戻り値の型、そしてwhere節は、関連する関数の宣言と同じでなければなりません。</target>
        </trans-unit>
        <trans-unit id="c54b94a826db4a7c6ce8d411476041b69555f1aa" translate="yes" xml:space="preserve">
          <source>The identity function.</source>
          <target state="translated">アイデンティティ関数。</target>
        </trans-unit>
        <trans-unit id="a0f93995f216b848984f480fd53d07ae2b2c30e6" translate="yes" xml:space="preserve">
          <source>The idiomatic way to write a &lt;a href=&quot;trait.iterator#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; for its side effects is to use a &lt;code&gt;for&lt;/code&gt; loop instead:</source>
          <target state="translated">副作用の&lt;a href=&quot;trait.iterator#method.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt;を書く慣用的な方法は、代わりに &lt;code&gt;for&lt;/code&gt; ループを使用することです。</target>
        </trans-unit>
        <trans-unit id="20b4ace5ebaf142e4e8addc0656248d8010dca32" translate="yes" xml:space="preserve">
          <source>The idiomatic way to write a &lt;a href=&quot;trait.iterator#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; for its side effects is to use a &lt;code&gt;for&lt;/code&gt; loop or call the &lt;a href=&quot;trait.iterator#method.for_each&quot;&gt;&lt;code&gt;for_each&lt;/code&gt;&lt;/a&gt; method:</source>
          <target state="translated">The idiomatic way to write a &lt;a href=&quot;trait.iterator#method.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt; for its side effects is to use a &lt;code&gt;for&lt;/code&gt; loop or call the &lt;a href=&quot;trait.iterator#method.for_each&quot;&gt; &lt;code&gt;for_each&lt;/code&gt; &lt;/a&gt; method:</target>
        </trans-unit>
        <trans-unit id="1dc3122c538d92098d293869587f4b3a0100941a" translate="yes" xml:space="preserve">
          <source>The implementation ensures that the iterator will return exactly &lt;code&gt;len()&lt;/code&gt; more times a &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some(T)&lt;/code&gt;&lt;/a&gt; value, before returning &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;. This method has a default implementation, so you usually should not implement it directly. However, if you can provide a more efficient implementation, you can do so. See the &lt;a href=&quot;trait.exactsizeiterator&quot;&gt;trait-level&lt;/a&gt; docs for an example.</source>
          <target state="translated">The implementation ensures that the iterator will return exactly &lt;code&gt;len()&lt;/code&gt; more times a &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some(T)&lt;/code&gt; &lt;/a&gt; value, before returning &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;. This method has a default implementation, so you usually should not implement it directly. However, if you can provide a more efficient implementation, you can do so. See the &lt;a href=&quot;trait.exactsizeiterator&quot;&gt;trait-level&lt;/a&gt; docs for an example.</target>
        </trans-unit>
        <trans-unit id="a17be86477c61cc7613b2ed105a5af337a27c206" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;code&gt;Display&lt;/code&gt; uses &lt;code&gt;self.0&lt;/code&gt; to access the inner &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, because &lt;code&gt;Wrapper&lt;/code&gt; is a tuple struct and &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; is the item at index 0 in the tuple. Then we can use the functionality of the &lt;code&gt;Display&lt;/code&gt; type on &lt;code&gt;Wrapper&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Wrapper&lt;/code&gt; はタプル構造体であり、 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; はタプルのインデックス0にあるアイテムであるため、 &lt;code&gt;Display&lt;/code&gt; の実装は &lt;code&gt;self.0&lt;/code&gt; を使用して内部 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; にアクセスします。次に、 &lt;code&gt;Wrapper&lt;/code&gt; で &lt;code&gt;Display&lt;/code&gt; タイプの機能を使用できます。</target>
        </trans-unit>
        <trans-unit id="64d2ca9bc84ea7c438a453f8d81beffdb2cea48b" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;code&gt;get&lt;/code&gt; relies in particular on identical implementations of &lt;code&gt;Hash&lt;/code&gt; by determining the key&amp;rsquo;s hash bucket by calling &lt;code&gt;Hash::hash&lt;/code&gt; on the &lt;code&gt;Q&lt;/code&gt; value even though it inserted the key based on the hash value calculated from the &lt;code&gt;K&lt;/code&gt; value.</source>
          <target state="translated">&lt;code&gt;get&lt;/code&gt; の実装は、特に、 &lt;code&gt;K&lt;/code&gt; 値から計算されたハッシュ値に基づいてキーを挿入した場合でも、 &lt;code&gt;Q&lt;/code&gt; 値に対して &lt;code&gt;Hash::hash&lt;/code&gt; を呼び出してキーのハッシュバケットを決定することにより、 &lt;code&gt;Hash&lt;/code&gt; 同一の実装に依存しています。</target>
        </trans-unit>
        <trans-unit id="9ddcc339944cbb72b0b66f63ad73cbbefd5f13bf" translate="yes" xml:space="preserve">
          <source>The implementation of this function must make sure to release any resources that are associated with this instance of a &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; and associated task.</source>
          <target state="translated">この関数の実装は、&lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; の&lt;/a&gt;このインスタンスと関連付けられたタスクに関連付けられているすべてのリソースを確実に解放する必要があります。</target>
        </trans-unit>
        <trans-unit id="b2b66f02783344ac4bc18a2fce3954484c2ba8e0" translate="yes" xml:space="preserve">
          <source>The implementation of this function must retain all resources that are required for this additional instance of a &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; and associated task. Calling &lt;code&gt;wake&lt;/code&gt; on the resulting &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; should result in a wakeup of the same task that would have been awoken by the original &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この関数の実装は、&lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; の&lt;/a&gt;この追加インスタンスと関連タスクに必要なすべてのリソースを保持する必要があります。結果の&lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; で&lt;/a&gt; &lt;code&gt;wake&lt;/code&gt; を呼び出すと、元の&lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt;によって起こされたものと同じタスクが起動されます。</target>
        </trans-unit>
        <trans-unit id="497d98f3948b6fc88a56b8970a7685389e682fb3" translate="yes" xml:space="preserve">
          <source>The implementation of waking a task on an executor.</source>
          <target state="translated">実行者にタスクを覚醒させる実装。</target>
        </trans-unit>
        <trans-unit id="d439e7f4f40d7bfe18d46ea25d8affbdc7117648" translate="yes" xml:space="preserve">
          <source>The implementation using the state pattern is easy to extend to add more functionality. To see the simplicity of maintaining code that uses the state pattern, try a few of these suggestions:</source>
          <target state="translated">状態パターンを使用した実装は、より多くの機能を追加するために拡張するのが簡単です。状態パターンを使用したコードのメンテナンスの簡単さを確認するには、これらの提案のいくつかを試してみてください。</target>
        </trans-unit>
        <trans-unit id="57e5372af92c8ddd71806b33dbda4afe86f48e3e" translate="yes" xml:space="preserve">
          <source>The implementing type within a &lt;a href=&quot;keyword.trait&quot;&gt;&lt;code&gt;trait&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;keyword.impl&quot;&gt;&lt;code&gt;impl&lt;/code&gt;&lt;/a&gt; block, or the current type within a type definition.</source>
          <target state="translated">内部実装型&lt;a href=&quot;keyword.trait&quot;&gt; &lt;code&gt;trait&lt;/code&gt; &lt;/a&gt;又は&lt;a href=&quot;keyword.impl&quot;&gt; &lt;code&gt;impl&lt;/code&gt; &lt;/a&gt;ブロック、またはタイプ定義内電流型。</target>
        </trans-unit>
        <trans-unit id="9972687dbff5abd8f4ecb962303ef66ce3678542" translate="yes" xml:space="preserve">
          <source>The index ranges returned by this trait are not required to exactly match those of the forward search in reverse.</source>
          <target state="translated">この形質によって返されるインデックス範囲は、逆方向の順方向検索のインデックス範囲と完全に一致する必要はありません。</target>
        </trans-unit>
        <trans-unit id="fb8e7f22599fed31a57edfd5bc4f1d4fe1de7766" translate="yes" xml:space="preserve">
          <source>The indexed operand of an array indexing expression.</source>
          <target state="translated">配列の添字式の添字オペランド。</target>
        </trans-unit>
        <trans-unit id="8a276159145a3d291ba8902040d397309a6a3910" translate="yes" xml:space="preserve">
          <source>The inferred type asks the compiler to infer the type if possible based on the surrounding information available. It cannot be used in item signatures. It is often used in generic arguments:</source>
          <target state="translated">inferred type は、利用可能な周囲の情報に基づいて可能な限り型を推論するようにコンパイラに要求します。これはアイテムシグネチャでは使用できません。一般的な引数で使用されることが多いです。</target>
        </trans-unit>
        <trans-unit id="1b63924c7210ee52ef50642e7b6012f573489c1d" translate="yes" xml:space="preserve">
          <source>The inherent methods of &lt;code&gt;Rc&lt;/code&gt; are all associated functions, which means that you have to call them as e.g., &lt;a href=&quot;#method.get_mut&quot;&gt;&lt;code&gt;Rc::get_mut(&amp;amp;mut value)&lt;/code&gt;&lt;/a&gt; instead of &lt;code&gt;value.get_mut()&lt;/code&gt;. This avoids conflicts with methods of the inner type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">固有の方法 &lt;code&gt;Rc&lt;/code&gt; は、すべてあなたが例えば、としてそれらを呼び出す必要があることを意味関連する機能、ある&lt;a href=&quot;#method.get_mut&quot;&gt; &lt;code&gt;Rc::get_mut(&amp;amp;mut value)&lt;/code&gt; &lt;/a&gt;の代わりに &lt;code&gt;value.get_mut()&lt;/code&gt; 。これにより、内部型 &lt;code&gt;T&lt;/code&gt; のメソッドとの競合が回避されます。</target>
        </trans-unit>
        <trans-unit id="cdd48be31dd031602338fabd7f9987080846befd" translate="yes" xml:space="preserve">
          <source>The inherent methods of &lt;code&gt;Rc&lt;/code&gt; are all associated functions, which means that you have to call them as e.g., &lt;a href=&quot;struct.rc#method.get_mut&quot;&gt;&lt;code&gt;Rc::get_mut(&amp;amp;mut value)&lt;/code&gt;&lt;/a&gt; instead of &lt;code&gt;value.get_mut()&lt;/code&gt;. This avoids conflicts with methods of the inner type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Rc&lt;/code&gt; の固有のメソッドはすべて関連する関数です。 &lt;code&gt;value.get_mut()&lt;/code&gt; 、value.get_mut（）ではなく&lt;a href=&quot;struct.rc#method.get_mut&quot;&gt; &lt;code&gt;Rc::get_mut(&amp;amp;mut value)&lt;/code&gt; &lt;/a&gt;ように呼び出す必要があります。これにより、内部タイプ &lt;code&gt;T&lt;/code&gt; のメソッドとの競合が回避されます。</target>
        </trans-unit>
        <trans-unit id="e9a135c5b11a6bdd25cebdf7bee36ffe6f4a888e" translate="yes" xml:space="preserve">
          <source>The initial value is the value the accumulator will have on the first call.</source>
          <target state="translated">初期値は、最初の呼び出し時にアキュムレータが持つ値です。</target>
        </trans-unit>
        <trans-unit id="05cd051eb5f45770d700d15bc2c291712fe7349d" translate="yes" xml:space="preserve">
          <source>The initial value is the value the accumulator will have on the first call. If applying the closure succeeded against every element of the iterator, &lt;code&gt;try_fold()&lt;/code&gt; returns the final accumulator as success.</source>
          <target state="translated">初期値は、アキュムレータが最初の呼び出しで持つ値です。イテレータのすべての要素に対してクロージャの適用が成功した場合、 &lt;code&gt;try_fold()&lt;/code&gt; は最後のアキュムレータを成功として返します。</target>
        </trans-unit>
        <trans-unit id="3215ce085488e89e5b23ed55a5028caf27292850" translate="yes" xml:space="preserve">
          <source>The initializer expression.</source>
          <target state="translated">イニシャライザ式。</target>
        </trans-unit>
        <trans-unit id="005959a16886789f6cb716c2b5dc5bbb0daa12f9" translate="yes" xml:space="preserve">
          <source>The initializer of</source>
          <target state="translated">のイニシャライザは</target>
        </trans-unit>
        <trans-unit id="37009e2d28047124f91d44e005708dbff225d4db" translate="yes" xml:space="preserve">
          <source>The initializer of a &lt;a href=&quot;statements#let-statements&quot;&gt;let statement&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;statements#let-statements&quot;&gt;letステートメント&lt;/a&gt;の初期化子。</target>
        </trans-unit>
        <trans-unit id="b9db1fa1a8ca22dc3f22f48be8f2cc5fef02b51c" translate="yes" xml:space="preserve">
          <source>The input &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; is the token stream of the item that has the &lt;code&gt;derive&lt;/code&gt; attribute on it. The output &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; must be a set of items that are then appended to the &lt;a href=&quot;items/modules&quot;&gt;module&lt;/a&gt; or &lt;a href=&quot;expressions/block-expr&quot;&gt;block&lt;/a&gt; that the item from the input &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; is in.</source>
          <target state="translated">入力&lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt;は、 &lt;code&gt;derive&lt;/code&gt; 属性を持つアイテムのトークンストリームです。出力&lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt;は、入力&lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt;からのアイテムが存在する&lt;a href=&quot;items/modules&quot;&gt;モジュール&lt;/a&gt;または&lt;a href=&quot;expressions/block-expr&quot;&gt;ブロックに&lt;/a&gt;追加される一連のアイテムである必要があります。</target>
        </trans-unit>
        <trans-unit id="3584f2f431d39b47066e06bb0ba2d085c77c3d1e" translate="yes" xml:space="preserve">
          <source>The input iterator &lt;code&gt;replace_with&lt;/code&gt; is only consumed when the &lt;code&gt;Splice&lt;/code&gt; value is dropped.</source>
          <target state="translated">入力イテレーター &lt;code&gt;replace_with&lt;/code&gt; は、 &lt;code&gt;Splice&lt;/code&gt; 値がドロップされたときにのみ消費されます。</target>
        </trans-unit>
        <trans-unit id="5b45dbdf7cc3adb9c8ff29ad732df76183eebf5c" translate="yes" xml:space="preserve">
          <source>The installation of Rust also includes a copy of the documentation locally, so you can read it offline. Run &lt;code&gt;rustup doc&lt;/code&gt; to open the local documentation in your browser.</source>
          <target state="translated">The installation of Rust also includes a copy of the documentation locally, so you can read it offline. Run &lt;code&gt;rustup doc&lt;/code&gt; to open the local documentation in your browser.</target>
        </trans-unit>
        <trans-unit id="c198c64d60547785c3da652e9852896f77fa00d7" translate="yes" xml:space="preserve">
          <source>The installation script automatically adds Rust to your system PATH after your next login. If you want to start using Rust right away instead of restarting your terminal, run the following command in your shell to add Rust to your system PATH manually:</source>
          <target state="translated">インストールスクリプトは、次回のログイン後、自動的にシステムのPATHにRustを追加します。ターミナルを再起動せずにすぐにRustの使用を開始したい場合は、以下のコマンドをシェルで実行して、システムのPATHにRustを手動で追加してください。</target>
        </trans-unit>
        <trans-unit id="a382c15195dddde8bba4823548e75c4adc802c3c" translate="yes" xml:space="preserve">
          <source>The installer also includes a copy of the documentation locally, so you can read it offline. Run &lt;code&gt;rustup doc&lt;/code&gt; to open the local documentation in your browser.</source>
          <target state="translated">インストーラーにはドキュメントのコピーもローカルに含まれているため、オフラインで読むことができます。 &lt;code&gt;rustup doc&lt;/code&gt; を実行して、ブラウザでローカルドキュメントを開きます。</target>
        </trans-unit>
        <trans-unit id="eb4481a6d93414e0e2ed7586ff1e0910b51585be" translate="yes" xml:space="preserve">
          <source>The integral types provide inherent methods to allow programmers explicitly to perform wrapping arithmetic. For example, &lt;code&gt;i32::wrapping_add&lt;/code&gt; provides two's complement, wrapping addition.</source>
          <target state="translated">整数型は、プログラマーが明示的に折り返し演算を実行できるようにする固有のメソッドを提供します。たとえば、 &lt;code&gt;i32::wrapping_add&lt;/code&gt; は2の補数であるラッピング加算を提供します。</target>
        </trans-unit>
        <trans-unit id="a2f153ef163d784268a26bcb041875def3bd700b" translate="yes" xml:space="preserve">
          <source>The integration tests section starts with the line &lt;code&gt;Running target/debug/deps/integration_test-ce99bcc2479f4607&lt;/code&gt; (the hash at the end of your output will be different). Next, there is a line for each test function in that integration test and a summary line for the results of the integration test just before the &lt;code&gt;Doc-tests adder&lt;/code&gt; section starts.</source>
          <target state="translated">統合テストのセクションは、 &lt;code&gt;Running target/debug/deps/integration_test-ce99bcc2479f4607&lt;/code&gt; という行で始まります（出力の最後のハッシュは異なります）。次に、その統合テストの各テスト関数の行と、 &lt;code&gt;Doc-tests adder&lt;/code&gt; セクションが始まる直前の統合テストの結果の要約行があります。</target>
        </trans-unit>
        <trans-unit id="9c8b39dac0f0603ab0205cf2bfd1df712c7506c4" translate="yes" xml:space="preserve">
          <source>The intention is that the underlying data is only valid for the lifetime &lt;code&gt;'a&lt;/code&gt;, so &lt;code&gt;Slice&lt;/code&gt; should not outlive &lt;code&gt;'a&lt;/code&gt;. However, this intent is not expressed in the code, since there are no uses of the lifetime &lt;code&gt;'a&lt;/code&gt; and hence it is not clear what data it applies to. We can correct this by telling the compiler to act &lt;em&gt;as if&lt;/em&gt; the &lt;code&gt;Slice&lt;/code&gt; struct contained a reference &lt;code&gt;&amp;amp;'a T&lt;/code&gt;:</source>
          <target state="translated">その意図は、基礎となるデータは、寿命のためにのみ有効であるということである &lt;code&gt;'a&lt;/code&gt; ので、 &lt;code&gt;Slice&lt;/code&gt; すべきで長生きありません &lt;code&gt;'a&lt;/code&gt; 。ただし、この意図はコードでは表現されません。これは、ライフタイム &lt;code&gt;'a&lt;/code&gt; は使用されないため、適用されるデータが明確ではないためです。これを修正&lt;em&gt;するに&lt;/em&gt;は、 &lt;code&gt;Slice&lt;/code&gt; 構造体に参照 &lt;code&gt;&amp;amp;'a T&lt;/code&gt; 含ま&lt;em&gt;れているかのよう&lt;/em&gt;に動作する&lt;em&gt;よう&lt;/em&gt;コンパイラーに指示します。</target>
        </trans-unit>
        <trans-unit id="c6ec3ee71b429b0c861d2949630c53c1d4103ef2" translate="yes" xml:space="preserve">
          <source>The internal algorithm is not specified, and so it and its hashes should not be relied upon over releases.</source>
          <target state="translated">内部アルゴリズムは指定されていないので、それとそのハッシュはリリースに依存すべきではありません。</target>
        </trans-unit>
        <trans-unit id="c411eb080c209397146b14ba5a4bb34e75cec138" translate="yes" xml:space="preserve">
          <source>The internal buffer is written out before returning the writer.</source>
          <target state="translated">内部バッファを書き出してからライターを返す。</target>
        </trans-unit>
        <trans-unit id="06716cd4a735b362271ebfeb2853eaa89b39ee1b" translate="yes" xml:space="preserve">
          <source>The internal iterator over the argument has not been advanced by the time the first &lt;code&gt;{}&lt;/code&gt; is seen, so it prints the first argument. Then upon reaching the second &lt;code&gt;{}&lt;/code&gt;, the iterator has advanced forward to the second argument. Essentially, parameters that explicitly name their argument do not affect parameters that do not name an argument in terms of positional specifiers.</source>
          <target state="translated">The internal iterator over the argument has not been advanced by the time the first &lt;code&gt;{}&lt;/code&gt; is seen, so it prints the first argument. Then upon reaching the second &lt;code&gt;{}&lt;/code&gt; , the iterator has advanced forward to the second argument. Essentially, parameters that explicitly name their argument do not affect parameters that do not name an argument in terms of positional specifiers.</target>
        </trans-unit>
        <trans-unit id="ce78ff22afeda7a6f00a6ca8444175752d52c4ff" translate="yes" xml:space="preserve">
          <source>The internal iterator over the argument has not been advanced by the time the first &lt;code&gt;{}&lt;/code&gt; is seen, so it prints the first argument. Then upon reaching the second &lt;code&gt;{}&lt;/code&gt;, the iterator has advanced forward to the second argument. Essentially, parameters which explicitly name their argument do not affect parameters which do not name an argument in terms of positional specifiers.</source>
          <target state="translated">引数に対する内部イテレータは、最初の &lt;code&gt;{}&lt;/code&gt; が見つかるまでには進んでいないため、最初の引数を出力します。次に、2番目の &lt;code&gt;{}&lt;/code&gt; に到達すると、イテレータは2番目の引数に進みます。基本的に、引数に明示的に名前を付けるパラメーターは、位置指定子に関して引数に名前を付けないパラメーターには影響しません。</target>
        </trans-unit>
        <trans-unit id="2c46dda1624f616f75baf2894d6d6e54ab12f317" translate="yes" xml:space="preserve">
          <source>The inverse of this method is &lt;a href=&quot;#method.from_utf8&quot;&gt;&lt;code&gt;from_utf8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">このメソッドの逆は&lt;a href=&quot;#method.from_utf8&quot;&gt; &lt;code&gt;from_utf8&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="dbc762f2fb2ae9279c20887c42fbcb66ef8ed68d" translate="yes" xml:space="preserve">
          <source>The inverse of this method is &lt;a href=&quot;struct.string#method.as_bytes&quot;&gt;&lt;code&gt;as_bytes&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">このメソッドの逆は&lt;a href=&quot;struct.string#method.as_bytes&quot;&gt; &lt;code&gt;as_bytes&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="2ef5a2c8bf418a538796f28bdc7b3ed8b4214bec" translate="yes" xml:space="preserve">
          <source>The inverse of this method is &lt;a href=&quot;struct.string#method.from_utf8&quot;&gt;&lt;code&gt;from_utf8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">The inverse of this method is &lt;a href=&quot;struct.string#method.from_utf8&quot;&gt; &lt;code&gt;from_utf8&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="00033d91f205bb0450cf7878d82bad2da288007b" translate="yes" xml:space="preserve">
          <source>The inverse of this method is &lt;a href=&quot;struct.string#method.into_bytes&quot;&gt;&lt;code&gt;into_bytes&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">The inverse of this method is &lt;a href=&quot;struct.string#method.into_bytes&quot;&gt; &lt;code&gt;into_bytes&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="0d5754a49ec3bccb9874e0108120d01b2fee9ec9" translate="yes" xml:space="preserve">
          <source>The issue can be resolved by changing the associated type:</source>
          <target state="translated">この問題は、関連するタイプを変更することで解決できます。</target>
        </trans-unit>
        <trans-unit id="2057c4ad17ebd71c1902c8394bd83a7474bbd6d5" translate="yes" xml:space="preserve">
          <source>The issue in this case is that &lt;code&gt;foo&lt;/code&gt; is defined as accepting a &lt;code&gt;Fn&lt;/code&gt; with one argument of type &lt;code&gt;String&lt;/code&gt;, but the closure we attempted to pass to it requires one arguments of type &lt;code&gt;usize&lt;/code&gt;.</source>
          <target state="translated">この場合の問題は、 &lt;code&gt;foo&lt;/code&gt; が &lt;code&gt;String&lt;/code&gt; 型の引数を1つ持つ &lt;code&gt;Fn&lt;/code&gt; を受け入れるものとして定義されていることですが、それに渡そうとしたクロージャには &lt;code&gt;usize&lt;/code&gt; 型の引数が1つ必要です。</target>
        </trans-unit>
        <trans-unit id="c02789dc84a563007f1b001c6388d43c1756fd64" translate="yes" xml:space="preserve">
          <source>The issue with the tuple code in Listing 4-5 is that we have to return the &lt;code&gt;String&lt;/code&gt; to the calling function so we can still use the &lt;code&gt;String&lt;/code&gt; after the call to &lt;code&gt;calculate_length&lt;/code&gt;, because the &lt;code&gt;String&lt;/code&gt; was moved into &lt;code&gt;calculate_length&lt;/code&gt;.</source>
          <target state="translated">リスト4-5のタプルコードの問題は、私たちが返す必要があることである &lt;code&gt;String&lt;/code&gt; 、我々はまだ使用できるように呼び出す関数に &lt;code&gt;String&lt;/code&gt; 呼び出し後 &lt;code&gt;calculate_length&lt;/code&gt; ので、 &lt;code&gt;String&lt;/code&gt; の中に移動された &lt;code&gt;calculate_length&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1013a496d8eb9ca295e23a82f7ffaec17e1ba13a" translate="yes" xml:space="preserve">
          <source>The issue with this code is evident in the signature of &lt;code&gt;area&lt;/code&gt;:</source>
          <target state="translated">このコードの問題は、 &lt;code&gt;area&lt;/code&gt; の署名で明らかです：</target>
        </trans-unit>
        <trans-unit id="e382444929f7f8a00ff868439efd08f11891e2df" translate="yes" xml:space="preserve">
          <source>The items of marker traits cannot be overridden, so there's no need to have them when they cannot be changed per-type anyway. If you wanted them for ergonomic reasons, consider making an extension trait instead.</source>
          <target state="translated">マーカー形質の項目はオーバーライドできないので、どうせ型ごとに変更できないのであれば持つ必要はありません。人間工学的な理由でそれらが欲しかったのであれば、代わりに拡張形質を作ることを検討してください。</target>
        </trans-unit>
        <trans-unit id="5e506ce8ee681f90bb70782d8bb4d2dad5bd0685" translate="yes" xml:space="preserve">
          <source>The iterator element type is &lt;a href=&quot;../path/struct.pathbuf&quot;&gt;&lt;code&gt;PathBuf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">イテレータ要素のタイプは&lt;a href=&quot;../path/struct.pathbuf&quot;&gt; &lt;code&gt;PathBuf&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="6824e2e2ab7393d35f45cbd58638289d41c35be1" translate="yes" xml:space="preserve">
          <source>The iterator must produce exactly the number of elements it reported or diverge before reaching the end.</source>
          <target state="translated">イテレータは、報告された要素の数を正確に生成するか、終了に到達する前に発散しなければなりません。</target>
        </trans-unit>
        <trans-unit id="857086b346b7dd5e8adf55ad86cbe1dbbf8cbe54" translate="yes" xml:space="preserve">
          <source>The iterator pattern allows you to perform some task on a sequence of items in turn. An iterator is responsible for the logic of iterating over each item and determining when the sequence has finished. When you use iterators, you don&amp;rsquo;t have to reimplement that logic yourself.</source>
          <target state="translated">イテレータパターンを使用すると、一連の項目に対していくつかのタスクを順番に実行できます。イテレータは、各アイテムを反復し、シーケンスがいつ終了したかを判断するロジックを担当します。イテレータを使用する場合、そのロジックを自分で再実装する必要はありません。</target>
        </trans-unit>
        <trans-unit id="6db07328b493618fb3fe592624d4f327dc32ce7b" translate="yes" xml:space="preserve">
          <source>The iterator reports a size hint where it is either exact (lower bound is equal to upper bound), or the upper bound is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;. The upper bound must only be &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if the actual iterator length is larger than &lt;a href=&quot;../usize/constant.max&quot;&gt;&lt;code&gt;usize::MAX&lt;/code&gt;&lt;/a&gt;. In that case, the lower bound must be &lt;a href=&quot;../usize/constant.max&quot;&gt;&lt;code&gt;usize::MAX&lt;/code&gt;&lt;/a&gt;, resulting in a &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt;&lt;code&gt;.size_hint&lt;/code&gt;&lt;/a&gt; of &lt;code&gt;(usize::MAX, None)&lt;/code&gt;.</source>
          <target state="translated">イテレータは、サイズヒントが正確である（下限が上限と等しい）か、上限が&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;であるかを報告します。実際のイテレータの長さが&lt;a href=&quot;../usize/constant.max&quot;&gt; &lt;code&gt;usize::MAX&lt;/code&gt; &lt;/a&gt;よりも大きい場合にのみ、上限を&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; に&lt;/a&gt;する必要があります。その場合、下限は&lt;a href=&quot;../usize/constant.max&quot;&gt; &lt;code&gt;usize::MAX&lt;/code&gt; &lt;/a&gt;でなければならず、結果として&lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt; &lt;code&gt;.size_hint&lt;/code&gt; &lt;/a&gt;は &lt;code&gt;(usize::MAX, None)&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="761f99bb11c75b1d69af8441ba4ad3812f9ffc53" translate="yes" xml:space="preserve">
          <source>The iterator reports a size hint where it is either exact (lower bound is equal to upper bound), or the upper bound is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;. The upper bound must only be &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if the actual iterator length is larger than &lt;a href=&quot;../usize/constant.max&quot;&gt;&lt;code&gt;usize::MAX&lt;/code&gt;&lt;/a&gt;. In that case, the lower bound must be &lt;a href=&quot;../usize/constant.max&quot;&gt;&lt;code&gt;usize::MAX&lt;/code&gt;&lt;/a&gt;, resulting in a &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt;&lt;code&gt;Iterator::size_hint()&lt;/code&gt;&lt;/a&gt; of &lt;code&gt;(usize::MAX, None)&lt;/code&gt;.</source>
          <target state="translated">The iterator reports a size hint where it is either exact (lower bound is equal to upper bound), or the upper bound is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;. The upper bound must only be &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; if the actual iterator length is larger than &lt;a href=&quot;../usize/constant.max&quot;&gt; &lt;code&gt;usize::MAX&lt;/code&gt; &lt;/a&gt;. In that case, the lower bound must be &lt;a href=&quot;../usize/constant.max&quot;&gt; &lt;code&gt;usize::MAX&lt;/code&gt; &lt;/a&gt;, resulting in a &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt; &lt;code&gt;Iterator::size_hint()&lt;/code&gt; &lt;/a&gt; of &lt;code&gt;(usize::MAX, None)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f5b68d7a8101dc216e0d59f65c1ebaa471e720b2" translate="yes" xml:space="preserve">
          <source>The iterator returned from this function will return instances of &lt;a href=&quot;type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. Each vector returned will &lt;em&gt;not&lt;/em&gt; have the delimiter byte at the end.</source>
          <target state="translated">イテレータは、のインスタンスを返します。この関数から返された&lt;a href=&quot;type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; &lt;/a&gt;。 &lt;code&gt;&amp;gt;&lt;/code&gt; 返される各ベクトルの末尾に区切りバイトはあり&lt;em&gt;ません&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="43d518530c9a6385f97f5ea0cf3b95e6447ddfae" translate="yes" xml:space="preserve">
          <source>The iterator returned from this function will yield instances of &lt;a href=&quot;type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. Each string returned will &lt;em&gt;not&lt;/em&gt; have a newline byte (the 0xA byte) or CRLF (0xD, 0xA bytes) at the end.</source>
          <target state="translated">この関数から返される反復子は、&lt;a href=&quot;type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; のインスタンスを生成します。返される各文字列の最後には、改行バイト（0xAバイト）またはCRLF（0xD、0xAバイト）はあり&lt;em&gt;ません&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="11be39dc954e81f8e71f68fa0b756ad22ee17df7" translate="yes" xml:space="preserve">
          <source>The iterator returned from this function will yield instances of &lt;a href=&quot;type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. Each string returned will &lt;em&gt;not&lt;/em&gt; have a newline byte (the &lt;code&gt;0xA&lt;/code&gt; byte) or &lt;code&gt;CRLF&lt;/code&gt; (&lt;code&gt;0xD&lt;/code&gt;, &lt;code&gt;0xA&lt;/code&gt; bytes) at the end.</source>
          <target state="translated">The iterator returned from this function will yield instances of &lt;a href=&quot;type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; . Each string returned will &lt;em&gt;not&lt;/em&gt; have a newline byte (the &lt;code&gt;0xA&lt;/code&gt; byte) or &lt;code&gt;CRLF&lt;/code&gt; ( &lt;code&gt;0xD&lt;/code&gt; , &lt;code&gt;0xA&lt;/code&gt; bytes) at the end.</target>
        </trans-unit>
        <trans-unit id="d98222c90db1c99a084846a0ad925665e5230738" translate="yes" xml:space="preserve">
          <source>The iterator returned will return string slices that are sub-slices of the original string slice, separated by any amount of ASCII whitespace.</source>
          <target state="translated">返されるイテレータは、元の文字列スライスのサブスライスである文字列スライスを、任意の量の ASCII ホワイトスペースで区切って返します。</target>
        </trans-unit>
        <trans-unit id="406100c150ec04008e29a14c30e99aed0f63af21" translate="yes" xml:space="preserve">
          <source>The iterator returned will return string slices that are sub-slices of the original string slice, separated by any amount of whitespace.</source>
          <target state="translated">返されるイテレータは、元の文字列スライスのサブスライスである文字列スライスを、任意の量の空白で区切って返します。</target>
        </trans-unit>
        <trans-unit id="4221546e7793ded4aa41dc1718c0ee56c99339b5" translate="yes" xml:space="preserve">
          <source>The iterator returned yields pairs &lt;code&gt;(i, val)&lt;/code&gt;, where &lt;code&gt;i&lt;/code&gt; is the current index of iteration and &lt;code&gt;val&lt;/code&gt; is the value returned by the iterator.</source>
          <target state="translated">返される反復子はペア &lt;code&gt;(i, val)&lt;/code&gt; 生成します。ここで、 &lt;code&gt;i&lt;/code&gt; は反復の現在のインデックス、 &lt;code&gt;val&lt;/code&gt; は反復子によって返される値です。</target>
        </trans-unit>
        <trans-unit id="0d65a2fef7d4c6664fcfb9659495ac349d06a758" translate="yes" xml:space="preserve">
          <source>The iterator starts with the given first item (if any) and calls the given &lt;code&gt;FnMut(&amp;amp;T) -&amp;gt; Option&amp;lt;T&amp;gt;&lt;/code&gt; closure to compute each item&amp;rsquo;s successor.</source>
          <target state="translated">イテレーターは、指定された最初の項目（存在する場合）から &lt;code&gt;FnMut(&amp;amp;T) -&amp;gt; Option&amp;lt;T&amp;gt;&lt;/code&gt; 、指定されたFnMut（＆T）-&amp;gt; Option &amp;lt;T&amp;gt;クロージャーを呼び出して、各項目の後続を計算します。</target>
        </trans-unit>
        <trans-unit id="fe7ef8d083d96a8372351bad5e0da1e04819839b" translate="yes" xml:space="preserve">
          <source>The iterator version was slightly faster! We won&amp;rsquo;t explain the benchmark code here, because the point is not to prove that the two versions are equivalent but to get a general sense of how these two implementations compare performance-wise.</source>
          <target state="translated">イテレータのバージョンは少し高速でした！ここではベンチマークコードについては説明しません。2つのバージョンが同等であることを証明することではなく、これらの2つの実装がパフォーマンスに関してどのように比較するかについての一般的な理解を得ることです。</target>
        </trans-unit>
        <trans-unit id="40a9eac2c27490989d9bce69b525d51e8393ef6d" translate="yes" xml:space="preserve">
          <source>The iterator will never return &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; and will also not yield the peer's &lt;a href=&quot;struct.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt; structure.</source>
          <target state="translated">イテレータは&lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;を返すことはなく、ピアの&lt;a href=&quot;struct.socketaddr&quot;&gt; &lt;code&gt;SocketAddr&lt;/code&gt; &lt;/a&gt;構造を生成しません。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
