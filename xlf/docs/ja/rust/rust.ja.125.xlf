<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="f18ea48cefb527612333927e42f98b5493e80a96" translate="yes" xml:space="preserve">
          <source>Ancestors::try_from</source>
          <target state="translated">Ancestors::try_from</target>
        </trans-unit>
        <trans-unit id="f07951de2fcfeba585ae159316c166c38d8606b4" translate="yes" xml:space="preserve">
          <source>Ancestors::try_into</source>
          <target state="translated">Ancestors::try_into</target>
        </trans-unit>
        <trans-unit id="0008829b37e7881a29a429bd8ff5a7a5ef753374" translate="yes" xml:space="preserve">
          <source>Ancestors::type_id</source>
          <target state="translated">Ancestors::type_id</target>
        </trans-unit>
        <trans-unit id="04f137aff1969f866b7d2666a9252de9e0efa21b" translate="yes" xml:space="preserve">
          <source>Ancestors::unzip</source>
          <target state="translated">Ancestors::unzip</target>
        </trans-unit>
        <trans-unit id="55dbfc2c3d770eaac08b3c73d87bccce57c4f78d" translate="yes" xml:space="preserve">
          <source>Ancestors::zip</source>
          <target state="translated">Ancestors::zip</target>
        </trans-unit>
        <trans-unit id="49a40db56fe6180d9e3eb242542f45d2d3173d4f" translate="yes" xml:space="preserve">
          <source>AncillaryData</source>
          <target state="translated">AncillaryData</target>
        </trans-unit>
        <trans-unit id="8c3f77779f46bdbd3940ac1fe6a4e53f4cdfa790" translate="yes" xml:space="preserve">
          <source>AncillaryError</source>
          <target state="translated">AncillaryError</target>
        </trans-unit>
        <trans-unit id="a01e33f4dcdb6ba1ae9f34a97cf8f6deeedf1a8d" translate="yes" xml:space="preserve">
          <source>And</source>
          <target state="translated">And</target>
        </trans-unit>
        <trans-unit id="42b71964be13234f4cbc3e386af8045e5f37b66e" translate="yes" xml:space="preserve">
          <source>And &lt;em&gt;src/front_of_house.rs&lt;/em&gt; gets the definitions from the body of the &lt;code&gt;front_of_house&lt;/code&gt; module, as shown in Listing 7-22.</source>
          <target state="translated">そして、&lt;em&gt;SRC / front_of_house.rsは、&lt;/em&gt;本体から定義を取得 &lt;code&gt;front_of_house&lt;/code&gt; のリスト7-22に示すように、モジュール。</target>
        </trans-unit>
        <trans-unit id="a66dda047400c5c52222e76fafe04295868d79a8" translate="yes" xml:space="preserve">
          <source>And a very common source of output is standard output:</source>
          <target state="translated">そして、ごく一般的な出力源は標準出力です。</target>
        </trans-unit>
        <trans-unit id="5cd52670a2b07449cbe1bd4abb403c682ccaf168" translate="yes" xml:space="preserve">
          <source>And finally, for the last example, only &lt;code&gt;Box&amp;lt;Self&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;amp;Self&lt;/code&gt;, &lt;code&gt;Self&lt;/code&gt;, or &lt;code&gt;&amp;amp;mut Self&lt;/code&gt; work as explicit self parameters. Example:</source>
          <target state="translated">そして最後に、最後の例では、 &lt;code&gt;Box&amp;lt;Self&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;amp;Self&lt;/code&gt; 、 &lt;code&gt;Self&lt;/code&gt; 、または &lt;code&gt;&amp;amp;mut Self&lt;/code&gt; のみが明示的な自己パラメーターとして機能します。例：</target>
        </trans-unit>
        <trans-unit id="b91a984e8eba980f8ed5afc44476d8d32720a1d5" translate="yes" xml:space="preserve">
          <source>And finally, let&amp;rsquo;s make sure that we don&amp;rsquo;t get any lines when we search for a word that isn&amp;rsquo;t anywhere in the poem, such as &amp;ldquo;monomorphization&amp;rdquo;:</source>
          <target state="translated">そして最後に、詩のどこにもない単語を検索するときに、「モノモーフィゼーション」などのように、行を取得しないようにします。</target>
        </trans-unit>
        <trans-unit id="8ddbbced7930dcaf198948383ed803d74e9323cf" translate="yes" xml:space="preserve">
          <source>And finally, the standard library exports a number of standard macros, and &lt;a href=&quot;#macros&quot;&gt;lists them on this page&lt;/a&gt; (technically, not all of the standard macros are defined by the standard library - some are defined by the compiler - but they are documented here the same). Like the prelude, the standard macros are imported by default into all crates.</source>
          <target state="translated">そして最後に、標準ライブラリはいくつかの標準マクロをエクスポート&lt;a href=&quot;#macros&quot;&gt;し、このページにリストします&lt;/a&gt;（技術的には、すべての標準マクロが標準ライブラリによって定義されているわけではありません-一部はコンパイラによって定義されています-それらはここでも同じようにドキュメント化されています）。 。プレリュードと同様に、標準マクロはデフォルトですべてのクレートにインポートされます。</target>
        </trans-unit>
        <trans-unit id="01c604c6cbed200d9271efd93c6961cdbaa99ebc" translate="yes" xml:space="preserve">
          <source>And now let's give working examples:</source>
          <target state="translated">そして、ここでは実際に働いている例を挙げてみましょう。</target>
        </trans-unit>
        <trans-unit id="076add01b447af4a01e4ff6b95c8cd6d23f8bbbe" translate="yes" xml:space="preserve">
          <source>And now some working examples:</source>
          <target state="translated">そして今、いくつかの作業例をご紹介します。</target>
        </trans-unit>
        <trans-unit id="3e0adb51e88db164baaa3fd268ad64b534eb5476" translate="yes" xml:space="preserve">
          <source>And so on.</source>
          <target state="translated">といった感じで。</target>
        </trans-unit>
        <trans-unit id="965c5135f65b1edbef655afbf975cd109690bf20" translate="yes" xml:space="preserve">
          <source>And so, our final result, &lt;code&gt;6&lt;/code&gt;.</source>
          <target state="translated">そして、最終的な結果は &lt;code&gt;6&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="8576d009cd19a7310431c770ccd6d0477a9a38f5" translate="yes" xml:space="preserve">
          <source>And the expected output would look like the following, because both dimensions of &lt;code&gt;rect2&lt;/code&gt; are smaller than the dimensions of &lt;code&gt;rect1&lt;/code&gt; but &lt;code&gt;rect3&lt;/code&gt; is wider than &lt;code&gt;rect1&lt;/code&gt;:</source>
          <target state="translated">両方の寸法いるためと予想される出力は、次のようになり &lt;code&gt;rect2&lt;/code&gt; の寸法よりも小さい &lt;code&gt;rect1&lt;/code&gt; が、 &lt;code&gt;rect3&lt;/code&gt; がより広くなっている &lt;code&gt;rect1&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="304a9abb7c8dbb46b1cac5f34e7d81eb70527d19" translate="yes" xml:space="preserve">
          <source>And the following is the same example, except using &lt;a href=&quot;generics#where-clauses&quot;&gt;where clauses&lt;/a&gt;.</source>
          <target state="translated">また、次の例も同じですが、&lt;a href=&quot;generics#where-clauses&quot;&gt;where句&lt;/a&gt;を使用しています。</target>
        </trans-unit>
        <trans-unit id="913d407459e0226b150e7a70e74b4001bb096c87" translate="yes" xml:space="preserve">
          <source>And then usage on the derive macro on a struct:</source>
          <target state="translated">そして、構造体上での派生マクロの使用法。</target>
        </trans-unit>
        <trans-unit id="16869e8d4badcf1212b889f654db64e52cba8e49" translate="yes" xml:space="preserve">
          <source>And then using said derive macro:</source>
          <target state="translated">そして、その導出マクロを使って</target>
        </trans-unit>
        <trans-unit id="fde456d658fb04a2082b8789148df9b0dd8dabdb" translate="yes" xml:space="preserve">
          <source>And then we use it a binary crate to print &quot;42&quot; to standard output.</source>
          <target state="translated">そして、それをバイナリクレートにして「42」を標準出力に出力しています。</target>
        </trans-unit>
        <trans-unit id="57be02e986031e930e9bf37db6620140ea92c664" translate="yes" xml:space="preserve">
          <source>And then we use it in a binary crate to print &quot;42&quot; to standard output.</source>
          <target state="translated">そして、それをバイナリークレートで使って「42」を標準出力に出力しています。</target>
        </trans-unit>
        <trans-unit id="843c5d94071a4fae0f20d3e75ea70e29673c03d4" translate="yes" xml:space="preserve">
          <source>And we can call this function with either variant:</source>
          <target state="translated">そして、この関数をどちらかのバリアントで呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="406aea8920a159db743c7e055df50170c501f68e" translate="yes" xml:space="preserve">
          <source>And we&amp;rsquo;re done&amp;mdash;all of Listing 17-11 now works! We&amp;rsquo;ve implemented the state pattern with the rules of the blog post workflow. The logic related to the rules lives in the state objects rather than being scattered throughout &lt;code&gt;Post&lt;/code&gt;.</source>
          <target state="translated">これで完了です。リスト17-11のすべてが機能するようになりました。ブログ投稿ワークフローのルールを使用して状態パターンを実装しました。ルールに関連するロジックは、 &lt;code&gt;Post&lt;/code&gt; 全体に分散するのではなく、状態オブジェクトに存在します。</target>
        </trans-unit>
        <trans-unit id="d71a2256704824ddf84d5c0504e7d9d40555e056" translate="yes" xml:space="preserve">
          <source>And you make a hard link of the program:</source>
          <target state="translated">そして、プログラムのハードリンクを作るんですね。</target>
        </trans-unit>
        <trans-unit id="1a652f499d8171d97dc8db68df0dbf0a99d7c3f2" translate="yes" xml:space="preserve">
          <source>AndAnd</source>
          <target state="translated">AndAnd</target>
        </trans-unit>
        <trans-unit id="bcffbb2710fb4ff9f2236988e5b2ed04ecff3723" translate="yes" xml:space="preserve">
          <source>AndEq</source>
          <target state="translated">AndEq</target>
        </trans-unit>
        <trans-unit id="c4af9f801ba386b4d95b5962fd0aee793823a0c6" translate="yes" xml:space="preserve">
          <source>Anonymous type parameters</source>
          <target state="translated">匿名型パラメータ</target>
        </trans-unit>
        <trans-unit id="f739dc0ff02bf7ebdbbaf543c53bc8d5f32aa9b9" translate="yes" xml:space="preserve">
          <source>Another aspect commonly associated with OOP is the idea of &lt;em&gt;encapsulation&lt;/em&gt;, which means that the implementation details of an object aren&amp;rsquo;t accessible to code using that object. Therefore, the only way to interact with an object is through its public API; code using the object shouldn&amp;rsquo;t be able to reach into the object&amp;rsquo;s internals and change data or behavior directly. This enables the programmer to change and refactor an object&amp;rsquo;s internals without needing to change the code that uses the object.</source>
          <target state="translated">一般にOOPに関連するもう1つの側面は、&lt;em&gt;カプセル化&lt;/em&gt;の概念です。つまり、オブジェクトの実装の詳細には、そのオブジェクトを使用するコードからアクセスできません。したがって、オブジェクトと対話する唯一の方法は、そのパブリックAPIを使用することです。オブジェクトを使用するコードは、オブジェクトの内部に到達して、データや動作を直接変更できないようにする必要があります。これにより、プログラマは、オブジェクトを使用するコードを変更する必要なく、オブジェクトの内部を変更およびリファクタリングできます。</target>
        </trans-unit>
        <trans-unit id="3244c196f26eb3ebda5753ab0aa6df5308b053cc" translate="yes" xml:space="preserve">
          <source>Another case that causes this error is when a type is imported into a parent module. To fix this, you can follow the suggestion and use File directly or &lt;code&gt;use super::File;&lt;/code&gt; which will import the types from the parent namespace. An example that causes this error is below:</source>
          <target state="translated">このエラーの原因となるもう1つのケースは、型が親モジュールにインポートされた場合です。これを修正するには、提案に従ってFileを直接 &lt;code&gt;use super::File;&lt;/code&gt; するか、super :: Fileを使用します。親名前空間から型をインポートします。このエラーの原因となる例を以下に示します。</target>
        </trans-unit>
        <trans-unit id="f5177285c1540f1a230a9212d6ad08c740059bb0" translate="yes" xml:space="preserve">
          <source>Another case where this error is emitted is when a value is expected, but something else is found:</source>
          <target state="translated">このエラーが出るもう一つのケースは、値が期待されていたのに何か別のものが見つかった場合です。</target>
        </trans-unit>
        <trans-unit id="583bae5ce904e4cf097b6105871c304a4243a347" translate="yes" xml:space="preserve">
          <source>Another common use case for hash maps is to look up a key&amp;rsquo;s value and then update it based on the old value. For instance, Listing 8-26 shows code that counts how many times each word appears in some text. We use a hash map with the words as keys and increment the value to keep track of how many times we&amp;rsquo;ve seen that word. If it&amp;rsquo;s the first time we&amp;rsquo;ve seen a word, we&amp;rsquo;ll first insert the value 0.</source>
          <target state="translated">ハッシュマップのもう1つの一般的な使用例は、キーの値を検索し、古い値に基づいて更新することです。たとえば、リスト8-26は、各単語がテキストに出現する回数をカウントするコードを示しています。単語をキーとしてハッシュマップを使用し、値を増分して、その単語を何回目にしたかを追跡します。単語を初めて見た場合は、最初に値0を挿入します。</target>
        </trans-unit>
        <trans-unit id="6faac33ab3de2071db8e2f1ae3893ca39a492717" translate="yes" xml:space="preserve">
          <source>Another common way to evaluate an iterator is to use the &lt;a href=&quot;trait.iterator#method.collect&quot;&gt;&lt;code&gt;collect&lt;/code&gt;&lt;/a&gt; method to produce a new collection.</source>
          <target state="translated">イテレータを評価するもう1つの一般的な方法は、&lt;a href=&quot;trait.iterator#method.collect&quot;&gt; &lt;code&gt;collect&lt;/code&gt; &lt;/a&gt;メソッドを使用して新しいコレクションを作成することです。</target>
        </trans-unit>
        <trans-unit id="dc4154c9de58b2e0fcab49a95a24b663a485fc7b" translate="yes" xml:space="preserve">
          <source>Another crate that depends on this library would need &lt;code&gt;use&lt;/code&gt; statements that bring the items from &lt;code&gt;art&lt;/code&gt; into scope, specifying the module structure that&amp;rsquo;s currently defined. Listing 14-4 shows an example of a crate that uses the &lt;code&gt;PrimaryColor&lt;/code&gt; and &lt;code&gt;mix&lt;/code&gt; items from the &lt;code&gt;art&lt;/code&gt; crate:</source>
          <target state="translated">このライブラリに依存する別のクレートでは、 &lt;code&gt;art&lt;/code&gt; のアイテムをスコープに入れ、現在定義されているモジュール構造を指定 &lt;code&gt;use&lt;/code&gt; ステートメントを使用する必要があります。リスト14-4は、 &lt;code&gt;PrimaryColor&lt;/code&gt; と &lt;code&gt;art&lt;/code&gt; クレートの &lt;code&gt;mix&lt;/code&gt; アイテムを使用するクレートの例を示しています。</target>
        </trans-unit>
        <trans-unit id="36e9fb79f8131b77a6b5deaea1a5127794ef21b6" translate="yes" xml:space="preserve">
          <source>Another data type that does not have ownership is the &lt;em&gt;slice&lt;/em&gt;. Slices let you reference a contiguous sequence of elements in a collection rather than the whole collection.</source>
          <target state="translated">所有権を持たないもう1つのデータ型は&lt;em&gt;スライス&lt;/em&gt;です。スライスを使用すると、コレクション全体ではなく、コレクション内の連続した要素のシーケンスを参照できます。</target>
        </trans-unit>
        <trans-unit id="2188fdee49af653aee0e28e4ac63dee8849194f0" translate="yes" xml:space="preserve">
          <source>Another detail to note is that Rust can&amp;rsquo;t protect you from all kinds of logic errors when you use &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt;. Recall in Chapter 15 that using &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; came with the risk of creating reference cycles, where two &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; values refer to each other, causing memory leaks. Similarly, &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; comes with the risk of creating &lt;em&gt;deadlocks&lt;/em&gt;. These occur when an operation needs to lock two resources and two threads have each acquired one of the locks, causing them to wait for each other forever. If you&amp;rsquo;re interested in deadlocks, try creating a Rust program that has a deadlock; then research deadlock mitigation strategies for mutexes in any language and have a go at implementing them in Rust. The standard library API documentation for &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;MutexGuard&lt;/code&gt; offers useful information.</source>
          <target state="translated">もう1つ注意すべき点は、Ruteは &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; を使用する場合、あらゆる種類の論理エラーから保護できるわけではないということです。第15章で、 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; を使用すると、2つの &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 値が相互に参照し、メモリリークを引き起こす参照サイクルが作成されるリスクがあったことを思い出してください。同様に、 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; は&lt;em&gt;デッドロックが発生&lt;/em&gt;するリスクがあります。&lt;em&gt;&lt;/em&gt;。これらは、操作が2つのリソースをロックする必要があり、2つのスレッドがそれぞれロックの1つを取得している場合に発生します。デッドロックに興味がある場合は、デッドロックを持つRustプログラムを作成してみてください。次に、ミューテックスのデッドロック緩和戦略を任意の言語で調査し、それらをRustに実装します。 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; および &lt;code&gt;MutexGuard&lt;/code&gt; の標準ライブラリAPIドキュメントには、役立つ情報が含まれています。</target>
        </trans-unit>
        <trans-unit id="a89f510396bf7e7d6ce47105d5094f9ffdc43c0a" translate="yes" xml:space="preserve">
          <source>Another difference between constants and static variables is that static variables can be mutable. Accessing and modifying mutable static variables is &lt;em&gt;unsafe&lt;/em&gt;. Listing 19-10 shows how to declare, access, and modify a mutable static variable named &lt;code&gt;COUNTER&lt;/code&gt;.</source>
          <target state="translated">定数と静的変数のもう1つの違いは、静的変数が変更可能になる可能性があることです。変更可能な静的変数へのアクセスと変更は&lt;em&gt;安全で&lt;/em&gt;はあり&lt;em&gt;ません&lt;/em&gt;。リスト19-10は、 &lt;code&gt;COUNTER&lt;/code&gt; という名前の変更可能な静的変数を宣言、アクセス、変更する方法を示しています。</target>
        </trans-unit>
        <trans-unit id="7e6b390982d432e5d51ecddfefa741ac598bed4a" translate="yes" xml:space="preserve">
          <source>Another downside is that we&amp;rsquo;ve duplicated some logic. To eliminate some of the duplication, we might try to make default implementations for the &lt;code&gt;request_review&lt;/code&gt; and &lt;code&gt;approve&lt;/code&gt; methods on the &lt;code&gt;State&lt;/code&gt; trait that return &lt;code&gt;self&lt;/code&gt;; however, this would violate object safety, because the trait doesn&amp;rsquo;t know what the concrete &lt;code&gt;self&lt;/code&gt; will be exactly. We want to be able to use &lt;code&gt;State&lt;/code&gt; as a trait object, so we need its methods to be object safe.</source>
          <target state="translated">もう1つの欠点は、ロジックが重複していることです。重複の一部を排除するために、 &lt;code&gt;request_review&lt;/code&gt; のデフォルト実装を作成し、 &lt;code&gt;State&lt;/code&gt; トレイトで &lt;code&gt;self&lt;/code&gt; を返すメソッドを &lt;code&gt;approve&lt;/code&gt; しようとする場合があります。ただし、特性は具体的な &lt;code&gt;self&lt;/code&gt; が正確に何であるかを知らないため、これはオブジェクトの安全性に違反します。 &lt;code&gt;State&lt;/code&gt; を特性オブジェクトとして使用できるようにしたいので、そのメソッドはオブジェクトセーフである必要があります。</target>
        </trans-unit>
        <trans-unit id="0b90ca84780d33c44fc3e74f14be69eb7fd048f1" translate="yes" xml:space="preserve">
          <source>Another erroneous code example:</source>
          <target state="translated">別の誤ったコード例です。</target>
        </trans-unit>
        <trans-unit id="b9c6fc1e93014c21a06c17d750322f830024d1b0" translate="yes" xml:space="preserve">
          <source>Another example of a complex NT is &lt;code&gt;$(hi $e:expr ;)+&lt;/code&gt;, which matches any fragment of the form &lt;code&gt;hi &amp;lt;expr&amp;gt;; hi &amp;lt;expr&amp;gt;; ...&lt;/code&gt; where &lt;code&gt;hi &amp;lt;expr&amp;gt;;&lt;/code&gt; occurs at least once. Note that this complex NT does not have a dedicated separator token.</source>
          <target state="translated">複雑なNTのもう1つの例は &lt;code&gt;$(hi $e:expr ;)+&lt;/code&gt; 、これは &lt;code&gt;hi &amp;lt;expr&amp;gt;; hi &amp;lt;expr&amp;gt;; ...&lt;/code&gt; 形式のフラグメントに一致します。こんにちは&amp;lt;expr&amp;gt;; ...ここで &lt;code&gt;hi &amp;lt;expr&amp;gt;;&lt;/code&gt; 少なくとも1回発生します。この複雑なNTには専用の分離トークンがないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="7ec0f590b55aa6269d2b833239d2434dfe2c8db0" translate="yes" xml:space="preserve">
          <source>Another example of a non-&lt;code&gt;Sync&lt;/code&gt; type is the reference-counting pointer &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt;. Given any reference &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;&amp;amp;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, you can clone a new &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, modifying the reference counts in a non-atomic way.</source>
          <target state="translated">&lt;code&gt;Sync&lt;/code&gt; タイプの別の例は、参照カウントポインタ&lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt;です。任意の参照&lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;&amp;amp;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;与えられると、新しい&lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;クローンを作成して、非アトミックな方法で参照カウントを変更できます。</target>
        </trans-unit>
        <trans-unit id="93c5ab10f51e34387707bf7df6173ca28d162973" translate="yes" xml:space="preserve">
          <source>Another example of a non-&lt;code&gt;Sync&lt;/code&gt; type is the reference-counting pointer &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;rc::Rc&lt;/code&gt;&lt;/a&gt;. Given any reference &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;&amp;amp;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, you can clone a new &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, modifying the reference counts in a non-atomic way.</source>
          <target state="translated">&lt;code&gt;Sync&lt;/code&gt; タイプの別の例は、参照カウントポインター&lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;rc::Rc&lt;/code&gt; &lt;/a&gt;です。参照&lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;&amp;amp;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;を指定すると、新しい&lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;複製して、非アトミックな方法で参照カウントを変更できます。</target>
        </trans-unit>
        <trans-unit id="5d9b32be0b7923daf9aadae8867f04bd738917c6" translate="yes" xml:space="preserve">
          <source>Another example showing how to keep &lt;code&gt;Cow&lt;/code&gt; in a struct:</source>
          <target state="translated">&lt;code&gt;Cow&lt;/code&gt; を構造体に保つ方法を示す別の例：</target>
        </trans-unit>
        <trans-unit id="dedf5ccdeb6bf446ef7cfb01d8db4c4b042b2078" translate="yes" xml:space="preserve">
          <source>Another example:</source>
          <target state="translated">別の例です。</target>
        </trans-unit>
        <trans-unit id="73dbef5057ac390e03a6e177bceb38dfa0e2cca7" translate="yes" xml:space="preserve">
          <source>Another implication of the 4-byte fixed size of a &lt;code&gt;char&lt;/code&gt; is that per-&lt;code&gt;char&lt;/code&gt; processing can end up using a lot more memory:</source>
          <target state="translated">4バイトの固定サイズの別の意味合い &lt;code&gt;char&lt;/code&gt; がパーということである &lt;code&gt;char&lt;/code&gt; 型の処理がより多くのメモリを使用して終了することができます：</target>
        </trans-unit>
        <trans-unit id="8ab43d76c6773436cfee7acbc8b6406943d7ca07" translate="yes" xml:space="preserve">
          <source>Another important difference between macros and functions is that you must define macros or bring them into scope &lt;em&gt;before&lt;/em&gt; you call them in a file, as opposed to functions you can define anywhere and call anywhere.</source>
          <target state="translated">マクロと関数のもう1つの重要な違いは、どこにでも定義してどこにでも呼び出すことができる関数とは対照的に、ファイルで呼び出す&lt;em&gt;前に&lt;/em&gt;マクロを定義するか、マクロをスコープ&lt;em&gt;に&lt;/em&gt;入れる必要があることです。</target>
        </trans-unit>
        <trans-unit id="6f8bbe73702fb41924bac262bfb8595f3c660f2c" translate="yes" xml:space="preserve">
          <source>Another indicator that shows there&amp;rsquo;s room for improvement is the &lt;code&gt;config&lt;/code&gt; part of &lt;code&gt;parse_config&lt;/code&gt;, which implies that the two values we return are related and are both part of one configuration value. We&amp;rsquo;re not currently conveying this meaning in the structure of the data other than by grouping the two values into a tuple; we could put the two values into one struct and give each of the struct fields a meaningful name. Doing so will make it easier for future maintainers of this code to understand how the different values relate to each other and what their purpose is.</source>
          <target state="translated">改善の余地があります示すことが別の指標である &lt;code&gt;config&lt;/code&gt; の一部 &lt;code&gt;parse_config&lt;/code&gt; 我々は戻り二つの値が関連しており、一つの構成値の両方の一部であることを意味します。現在のところ、2つの値をタプルにグループ化する以外の方法では、データの構造でこの意味を伝えていません。 2つの値を1つの構造体に入れ、各構造体フィールドに意味のある名前を付けることができます。そうすることで、このコードの将来のメンテナーが、異なる値が互いにどのように関連しているか、そしてそれらの目的が何であるかを理解しやすくなります。</target>
        </trans-unit>
        <trans-unit id="00e0685682ab1fea96a488f384eaf2fdca89f82c" translate="yes" xml:space="preserve">
          <source>Another kind of generic that we&amp;rsquo;ve already been using is called &lt;em&gt;lifetimes&lt;/em&gt;. Rather than ensuring that a type has the behavior we want, lifetimes ensure that references are valid as long as we need them to be. Let&amp;rsquo;s look at how lifetimes do that.</source>
          <target state="translated">私たちがすでに使用している別の種類のジェネリックは、&lt;em&gt;ライフタイム&lt;/em&gt;と呼ばれています。ライフタイムは、型が希望する動作をすることを保証するのではなく、必要な限り参照が有効であることを保証します。生涯がどのようにそれを行うか見てみましょう。</target>
        </trans-unit>
        <trans-unit id="310cbb5c9fbbbdff4450ff99ffebe8e97470ef1e" translate="yes" xml:space="preserve">
          <source>Another method, &lt;code&gt;expect&lt;/code&gt;, which is similar to &lt;code&gt;unwrap&lt;/code&gt;, lets us also choose the &lt;code&gt;panic!&lt;/code&gt; error message. Using &lt;code&gt;expect&lt;/code&gt; instead of &lt;code&gt;unwrap&lt;/code&gt; and providing good error messages can convey your intent and make tracking down the source of a panic easier. The syntax of &lt;code&gt;expect&lt;/code&gt; looks like this:</source>
          <target state="translated">&lt;code&gt;unwrap&lt;/code&gt; に類似した別の方法である &lt;code&gt;expect&lt;/code&gt; は、 &lt;code&gt;panic!&lt;/code&gt; も選択できるようにします！エラーメッセージ。 &lt;code&gt;unwrap&lt;/code&gt; の代わりに &lt;code&gt;expect&lt;/code&gt; を使用して適切なエラーメッセージを提供すると、意図が伝わり、パニックの原因を追跡しやすくなります。 &lt;code&gt;expect&lt;/code&gt; の構文は次のようになります。</target>
        </trans-unit>
        <trans-unit id="f5499cba2c47a56c76648e5bfb00e8274cd4700a" translate="yes" xml:space="preserve">
          <source>Another point about UTF-8 is that there are actually three relevant ways to look at strings from Rust&amp;rsquo;s perspective: as bytes, scalar values, and grapheme clusters (the closest thing to what we would call &lt;em&gt;letters&lt;/em&gt;).</source>
          <target state="translated">UTF-8のもう1つのポイントは、Rustの観点から文字列を見るには、実際には3つの関連する方法があることです：バイト、スカラー値、および書記素クラスター（&lt;em&gt;文字&lt;/em&gt;と呼ばれるものに最も近いもの）。</target>
        </trans-unit>
        <trans-unit id="81bb35319cfe55cae7a1b6f8b640c268f984543f" translate="yes" xml:space="preserve">
          <source>Another problem you might be facing is this: suppose you've overloaded the &lt;code&gt;+&lt;/code&gt; operator for some type &lt;code&gt;Foo&lt;/code&gt; by implementing the &lt;code&gt;std::ops::Add&lt;/code&gt; trait for &lt;code&gt;Foo&lt;/code&gt;, but you find that using &lt;code&gt;+=&lt;/code&gt; does not work, as in this example:</source>
          <target state="translated">あなたが直面するかもしれないもう一つの問題はこれです：あなたが過負荷にきたと仮定 &lt;code&gt;+&lt;/code&gt; のいくつかのタイプのためにオペレータ &lt;code&gt;Foo&lt;/code&gt; 実装することにより、 &lt;code&gt;std::ops::Add&lt;/code&gt; するために形質を &lt;code&gt;Foo&lt;/code&gt; のが、あなたが使用していることを見つける &lt;code&gt;+=&lt;/code&gt; は、この例のように、仕事をしません：</target>
        </trans-unit>
        <trans-unit id="aac5c18dffed07c8f0aa7695dfba8d6c18e4b19b" translate="yes" xml:space="preserve">
          <source>Another reason Rust has an unsafe alter ego is that the underlying computer hardware is inherently unsafe. If Rust didn&amp;rsquo;t let you do unsafe operations, you couldn&amp;rsquo;t do certain tasks. Rust needs to allow you to do low-level systems programming, such as directly interacting with the operating system or even writing your own operating system. Working with low-level systems programming is one of the goals of the language. Let&amp;rsquo;s explore what we can do with unsafe Rust and how to do it.</source>
          <target state="translated">Rustが安全でない代替エゴを持っているもう1つの理由は、基盤となるコンピューターハードウェアが本質的に安全でないためです。 Rustが安全でない操作を許可していない場合、特定のタスクを実行できません。 Rustは、オペレーティングシステムと直接対話したり、独自のオペレーティングシステムを作成したりするなど、低レベルのシステムプログラミングを実行できるようにする必要があります。低レベルシステムプログラミングでの作業は、言語の目標の1つです。安全でないRustで何ができるか、そしてそれをどのように行うかを探りましょう。</target>
        </trans-unit>
        <trans-unit id="ea0e4d862c74d436d68a36a2f5a91a9f7ba71ea8" translate="yes" xml:space="preserve">
          <source>Another shortcut for struct instantiation is available, used when you need to make a new struct that has the same values as most of a previous struct of the same type, called struct update syntax:</source>
          <target state="translated">構造体のインスタンス化のための別のショートカットがあり、構造体更新構文と呼ばれる、同じ型の以前の構造体のほとんどと同じ値を持つ新しい構造体を作成する必要がある場合に使用されます。</target>
        </trans-unit>
        <trans-unit id="f3ef4925d92f67dd0f9c6ef4b106d217ff19945f" translate="yes" xml:space="preserve">
          <source>Another situation where this might be encountered is when spawning threads:</source>
          <target state="translated">もう一つの状況は、スレッドをスポーンするときに発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="34208ffcc5dda542066ff03ecbdd472bf7d5f1c2" translate="yes" xml:space="preserve">
          <source>Another solution for avoiding reference cycles is reorganizing your data structures so that some references express ownership and some references don&amp;rsquo;t. As a result, you can have cycles made up of some ownership relationships and some non-ownership relationships, and only the ownership relationships affect whether or not a value can be dropped. In Listing 15-25, we always want &lt;code&gt;Cons&lt;/code&gt; variants to own their list, so reorganizing the data structure isn&amp;rsquo;t possible. Let&amp;rsquo;s look at an example using graphs made up of parent nodes and child nodes to see when non-ownership relationships are an appropriate way to prevent reference cycles.</source>
          <target state="translated">参照サイクルを回避するための別のソリューションは、一部の参照が所有権を表し、一部の参照が所有権を表さないようにデータ構造を再編成することです。その結果、いくつかの所有関係といくつかの非所有関係で構成されるサイクルがあり、値を削除できるかどうかには所有関係のみが影響します。リスト15-25では、常に &lt;code&gt;Cons&lt;/code&gt; のバリアントがリストを所有するようにしたいので、データ構造を再編成することは不可能です。親ノードと子ノードで構成されるグラフを使用した例を見て、所有権以外の関係が参照循環を防ぐ適切な方法であるかどうかを確認してみましょう。</target>
        </trans-unit>
        <trans-unit id="561d97b6164c78f724fabd7e84d16f2ca6a5f05e" translate="yes" xml:space="preserve">
          <source>Another style of doc comment, &lt;code&gt;//!&lt;/code&gt;, adds documentation to the item that contains the comments rather than adding documentation to the items following the comments. We typically use these doc comments inside the crate root file (&lt;em&gt;src/lib.rs&lt;/em&gt; by convention) or inside a module to document the crate or the module as a whole.</source>
          <target state="translated">別のスタイルのドキュメントコメント、 &lt;code&gt;//!&lt;/code&gt; 、コメントに続くアイテムにドキュメントを追加するのではなく、コメントを含むアイテムにドキュメントを追加します。通常、これらのdocコメントは、クレートのルートファイル（&lt;em&gt;慣例&lt;/em&gt;により&lt;em&gt;src / lib.rs&lt;/em&gt;）内またはモジュール内で使用して、クレートまたはモジュール全体を文書化します。</target>
        </trans-unit>
        <trans-unit id="7c509361e45630a3070d0b558a9e089279230886" translate="yes" xml:space="preserve">
          <source>Another use case for &lt;code&gt;unsafe&lt;/code&gt; is implementing an unsafe trait. A trait is unsafe when at least one of its methods has some invariant that the compiler can&amp;rsquo;t verify. We can declare that a trait is &lt;code&gt;unsafe&lt;/code&gt; by adding the &lt;code&gt;unsafe&lt;/code&gt; keyword before &lt;code&gt;trait&lt;/code&gt; and marking the implementation of the trait as &lt;code&gt;unsafe&lt;/code&gt; too, as shown in Listing 19-11.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfe5186a552091b0c590be070139e735a13d8759" translate="yes" xml:space="preserve">
          <source>Another use of the newtype pattern is in abstracting away some implementation details of a type: the new type can expose a public API that is different from the API of the private inner type if we used the new type directly to restrict the available functionality, for example.</source>
          <target state="translated">newtypeパターンのもう一つの用途は、型の実装の詳細を抽象化することです。例えば、利用可能な機能を制限するためにnewtypeを直接使用した場合、newtypeはプライベート内部型のAPIとは異なるパブリックAPIを公開することができます。</target>
        </trans-unit>
        <trans-unit id="5796386c80b53dfd4fee86ac2eb96a8dcc028b10" translate="yes" xml:space="preserve">
          <source>Another useful feature of &lt;code&gt;impl&lt;/code&gt; blocks is that we&amp;rsquo;re allowed to define functions within &lt;code&gt;impl&lt;/code&gt; blocks that &lt;em&gt;don&amp;rsquo;t&lt;/em&gt; take &lt;code&gt;self&lt;/code&gt; as a parameter. These are called &lt;em&gt;associated functions&lt;/em&gt; because they&amp;rsquo;re associated with the struct. They&amp;rsquo;re still functions, not methods, because they don&amp;rsquo;t have an instance of the struct to work with. You&amp;rsquo;ve already used the &lt;code&gt;String::from&lt;/code&gt; associated function.</source>
          <target state="translated">別の便利な機能 &lt;code&gt;impl&lt;/code&gt; ブロックは、我々は内の関数を定義することが許されているということです &lt;code&gt;impl&lt;/code&gt; ブロック&lt;em&gt;しません&lt;/em&gt;取る &lt;code&gt;self&lt;/code&gt; パラメータとして。これらは、構造体に関連付けられているため、&lt;em&gt;関連関数&lt;/em&gt;と呼ばれます。機能する構造体のインスタンスがないので、メソッドではなく関数のままです。 &lt;code&gt;String::from&lt;/code&gt; 関連関数をすでに使用しています。</target>
        </trans-unit>
        <trans-unit id="30235cc37ef7579d4a5373609eca2f1e91e01f9f" translate="yes" xml:space="preserve">
          <source>Another useful feature of match arms is that they can bind to the parts of the values that match the pattern. This is how we can extract values out of enum variants.</source>
          <target state="translated">マッチアームのもう一つの便利な機能は、パターンにマッチした値の部分にバインドできることです。このようにして、列挙バリアントから値を抽出することができます。</target>
        </trans-unit>
        <trans-unit id="03644769062de97f25c38104b0372355c4a77983" translate="yes" xml:space="preserve">
          <source>Another way is to do away with the associated type in &lt;code&gt;Maker&lt;/code&gt; and use an input type parameter instead:</source>
          <target state="translated">もう1つの方法は、 &lt;code&gt;Maker&lt;/code&gt; で関連する型を取り除き、代わりに入力型パラメーターを使用することです。</target>
        </trans-unit>
        <trans-unit id="6f7bb901bc2f8efc6ca57a7f109d4ad53f1c9e20" translate="yes" xml:space="preserve">
          <source>Another way of constructing a hash map is by using iterators and the &lt;code&gt;collect&lt;/code&gt; method on a vector of tuples, where each tuple consists of a key and its value. We&amp;rsquo;ll be going into more detail about iterators and their associated methods in the &lt;a href=&quot;ch13-02-iterators&quot;&gt;&amp;rdquo;Processing a Series of Items with Iterators&amp;rdquo; section of Chapter 13&lt;/a&gt;. The &lt;code&gt;collect&lt;/code&gt; method gathers data into a number of collection types, including &lt;code&gt;HashMap&lt;/code&gt;. For example, if we had the team names and initial scores in two separate vectors, we could use the &lt;code&gt;zip&lt;/code&gt; method to create a vector of tuples where &amp;ldquo;Blue&amp;rdquo; is paired with 10, and so forth. Then we could use the &lt;code&gt;collect&lt;/code&gt; method to turn that vector of tuples into a hash map, as shown in Listing 8-21.</source>
          <target state="translated">ハッシュマップを作成する別の方法は、タプルのベクトルに対してイテレーターと &lt;code&gt;collect&lt;/code&gt; メソッドを使用することです。ここで、各タプルはキーとその値で構成されます。イテレータとそれに関連するメソッドについて&lt;a href=&quot;ch13-02-iterators&quot;&gt;は、第13章の「イテレータを使用した一連のアイテムの処理」セクションで&lt;/a&gt;詳しく説明します。 &lt;code&gt;collect&lt;/code&gt; 方法は、以下を含むコレクション・タイプの数、にデータを収集し &lt;code&gt;HashMap&lt;/code&gt; 。たとえば、チーム名と初期スコアが2つの別々のベクトルにある場合、 &lt;code&gt;zip&lt;/code&gt; メソッドを使用して、「青」が10とペアになっているタプルのベクトルを作成できます。次に、リスト8-21に示すように、 &lt;code&gt;collect&lt;/code&gt; メソッドを使用して、タプルのベクトルをハッシュマップに変換できます。</target>
        </trans-unit>
        <trans-unit id="ccc69aa411fffd31870708506663671f3a6766b5" translate="yes" xml:space="preserve">
          <source>Another way of constructing a hash map is by using the &lt;code&gt;collect&lt;/code&gt; method on a vector of tuples, where each tuple consists of a key and its value. The &lt;code&gt;collect&lt;/code&gt; method gathers data into a number of collection types, including &lt;code&gt;HashMap&lt;/code&gt;. For example, if we had the team names and initial scores in two separate vectors, we could use the &lt;code&gt;zip&lt;/code&gt; method to create a vector of tuples where &amp;ldquo;Blue&amp;rdquo; is paired with 10, and so forth. Then we could use the &lt;code&gt;collect&lt;/code&gt; method to turn that vector of tuples into a hash map, as shown in Listing 8-21.</source>
          <target state="translated">ハッシュマップを作成する別の方法は、タプルのベクトルに対して &lt;code&gt;collect&lt;/code&gt; メソッドを使用することです。この場合、各タプルはキーとその値で構成されます。 &lt;code&gt;collect&lt;/code&gt; 方法は、以下を含むコレクション・タイプの数、にデータを収集し &lt;code&gt;HashMap&lt;/code&gt; 。たとえば、チーム名と初期スコアが2つの別々のベクトルにある場合、 &lt;code&gt;zip&lt;/code&gt; を使用できますメソッドを使用して、「Blue」が10とペアになっているタプルのベクトルを作成。次に、リスト8-21に示すように、 &lt;code&gt;collect&lt;/code&gt; メソッドを使用して、タプルのベクトルをハッシュマップに変換します。</target>
        </trans-unit>
        <trans-unit id="56bc825abe2ef1255ee87da2e4f261c23258e491" translate="yes" xml:space="preserve">
          <source>Another way of thinking about &lt;code&gt;flat_map()&lt;/code&gt;: &lt;a href=&quot;#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;'s closure returns one item for each element, and &lt;code&gt;flat_map()&lt;/code&gt;'s closure returns an iterator for each element.</source>
          <target state="translated">&lt;code&gt;flat_map()&lt;/code&gt; についての別の考え方：&lt;a href=&quot;#method.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt;のクロージャーは、要素ごとに1つのアイテムを返します。 &lt;code&gt;flat_map()&lt;/code&gt; のクロージャは各要素に対してイテレータを返します。</target>
        </trans-unit>
        <trans-unit id="d1f28d9b77a5082f5c9d67a87d7ff9fdc9ab88db" translate="yes" xml:space="preserve">
          <source>Another way of thinking about &lt;code&gt;flat_map()&lt;/code&gt;: &lt;a href=&quot;trait.iterator#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;'s closure returns one item for each element, and &lt;code&gt;flat_map()&lt;/code&gt;'s closure returns an iterator for each element.</source>
          <target state="translated">&lt;code&gt;flat_map()&lt;/code&gt; についての別の考え方：&lt;a href=&quot;trait.iterator#method.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt;のクロージャは要素ごとに1つのアイテムを返し、 &lt;code&gt;flat_map()&lt;/code&gt; のクロージャは要素ごとにイテレータを返します。</target>
        </trans-unit>
        <trans-unit id="590fe2daae703b4f29d9d514cb7fe9863489ba23" translate="yes" xml:space="preserve">
          <source>Another way to access union fields is to use pattern matching. Pattern matching on union fields uses the same syntax as struct patterns, except that the pattern must specify exactly one field. Since pattern matching is like reading the union with a particular field, it has to be placed in &lt;code&gt;unsafe&lt;/code&gt; blocks as well.</source>
          <target state="translated">ユニオンフィールドにアクセスする別の方法は、パターンマッチングを使用することです。ユニオンフィールドのパターンマッチングでは、構造体パターンと同じ構文を使用します。ただし、パターンはフィールドを1つだけ指定する必要があります。パターンマッチングは特定のフィールドとの共用体を読み取るようなものなので、次の場所に配置する必要があります &lt;code&gt;unsafe&lt;/code&gt; ブロックあります。</target>
        </trans-unit>
        <trans-unit id="1b9e5f7972ceab35649387701cac506db165c92f" translate="yes" xml:space="preserve">
          <source>Another way to have a collection of multiple values is with an &lt;em&gt;array&lt;/em&gt;. Unlike a tuple, every element of an array must have the same type. Arrays in Rust are different from arrays in some other languages because arrays in Rust have a fixed length, like tuples.</source>
          <target state="translated">複数の値のコレクションを取得する別の方法は、 &lt;em&gt;配列を使用すること&lt;/em&gt;です。タプルとは異なり、配列のすべての要素は同じ型でなければなりません。Rustの配列はタプルのように固定長であるため、Rustの配列は他のいくつかの言語の配列とは異なります。</target>
        </trans-unit>
        <trans-unit id="6b16dbbf7d35ba29c07c44408e5ca0fc777803bb" translate="yes" xml:space="preserve">
          <source>Another way to provide the compiler with enough information, is to specify the generic type parameter:</source>
          <target state="translated">コンパイラに十分な情報を提供するもう一つの方法は、汎用型パラメータを指定することです。</target>
        </trans-unit>
        <trans-unit id="9b14c4635b7e156ee560ca02ddafb5c338efe01a" translate="yes" xml:space="preserve">
          <source>Another way we could implement &lt;code&gt;largest&lt;/code&gt; is for the function to return a reference to a &lt;code&gt;T&lt;/code&gt; value in the slice. If we change the return type to &lt;code&gt;&amp;amp;T&lt;/code&gt; instead of &lt;code&gt;T&lt;/code&gt;, thereby changing the body of the function to return a reference, we wouldn&amp;rsquo;t need the &lt;code&gt;Clone&lt;/code&gt; or &lt;code&gt;Copy&lt;/code&gt; trait bounds and we could avoid heap allocations. Try implementing these alternate solutions on your own!</source>
          <target state="translated">&lt;code&gt;largest&lt;/code&gt; 値を実装できるもう1つの方法は、関数がスライス内の &lt;code&gt;T&lt;/code&gt; 値への参照を返すことです。我々は戻り値の型を変更した場合は &lt;code&gt;&amp;amp;T&lt;/code&gt; の代わりに &lt;code&gt;T&lt;/code&gt; これにより、参照を返すように関数の本体を変更し、我々は必要はありません &lt;code&gt;Clone&lt;/code&gt; または &lt;code&gt;Copy&lt;/code&gt; 形質境界を、私たちは、ヒープ割り当てを避けることができます。これらの代替ソリューションを自分で実装してみてください！</target>
        </trans-unit>
        <trans-unit id="322444d3bb52c341f429ca0454f292dc242f315b" translate="yes" xml:space="preserve">
          <source>Any</source>
          <target state="translated">Any</target>
        </trans-unit>
        <trans-unit id="28a9dd9802c2f2d457b2df1a706228a0fe1e9650" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;BuildHasherDefault&lt;/code&gt; is &lt;a href=&quot;https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts&quot;&gt;zero-sized&lt;/a&gt;. It can be created with &lt;a href=&quot;#method.default&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt;. When using &lt;code&gt;BuildHasherDefault&lt;/code&gt; with &lt;a href=&quot;../collections/struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../collections/struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt;, this doesn't need to be done, since they implement appropriate &lt;a href=&quot;../default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; instances themselves.</source>
          <target state="translated">どれ &lt;code&gt;BuildHasherDefault&lt;/code&gt; はある&lt;a href=&quot;https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts&quot;&gt;ゼロ・サイズ&lt;/a&gt;。&lt;a href=&quot;#method.default&quot;&gt; &lt;code&gt;default&lt;/code&gt; &lt;/a&gt;で作成できます。 &lt;code&gt;BuildHasherDefault&lt;/code&gt; を&lt;a href=&quot;../collections/struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;../collections/struct.hashset&quot;&gt; &lt;code&gt;HashSet&lt;/code&gt; &lt;/a&gt;で使用する場合、適切な&lt;a href=&quot;../default/trait.default&quot;&gt; &lt;code&gt;Default&lt;/code&gt; &lt;/a&gt;インスタンス自体を実装するため、これを行う必要はありません。</target>
        </trans-unit>
        <trans-unit id="39acf470f03d64f751336d22936382dc10cf66e8" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;BuildHasherDefault&lt;/code&gt; is &lt;a href=&quot;https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts&quot;&gt;zero-sized&lt;/a&gt;. It can be created with &lt;a href=&quot;struct.buildhasherdefault#method.default&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt;. When using &lt;code&gt;BuildHasherDefault&lt;/code&gt; with &lt;a href=&quot;../collections/struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../collections/struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt;, this doesn't need to be done, since they implement appropriate &lt;a href=&quot;../default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; instances themselves.</source>
          <target state="translated">&lt;code&gt;BuildHasherDefault&lt;/code&gt; はすべて&lt;a href=&quot;https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts&quot;&gt;ゼロサイズ&lt;/a&gt;です。&lt;a href=&quot;struct.buildhasherdefault#method.default&quot;&gt; &lt;code&gt;default&lt;/code&gt; &lt;/a&gt;で作成できます。 &lt;code&gt;BuildHasherDefault&lt;/code&gt; を&lt;a href=&quot;../collections/struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;../collections/struct.hashset&quot;&gt; &lt;code&gt;HashSet&lt;/code&gt; &lt;/a&gt;とともに使用する場合、適切な&lt;a href=&quot;../default/trait.default&quot;&gt; &lt;code&gt;Default&lt;/code&gt; &lt;/a&gt;インスタンスを実装するため、これを行う必要はありません。</target>
        </trans-unit>
        <trans-unit id="61c0cc711bc6806236220ae14adf5485763a3373" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;enum&lt;/code&gt; value consumes as much memory as the largest variant for its corresponding &lt;code&gt;enum&lt;/code&gt; type, as well as the size needed to store a discriminant.</source>
          <target state="translated">任意の &lt;code&gt;enum&lt;/code&gt; それに対応するための最大の変種として多くのメモリとしての価値が消費 &lt;code&gt;enum&lt;/code&gt; タイプと同様に、判別式を格納するのに必要なサイズ。</target>
        </trans-unit>
        <trans-unit id="6ab54097a9523b84f57f773009ba255a131e3917" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;with_capacity&lt;/code&gt; constructor will instruct the collection to allocate enough space for the specified number of elements. Ideally this will be for exactly that many elements, but some implementation details may prevent this. See collection-specific documentation for details. In general, use &lt;code&gt;with_capacity&lt;/code&gt; when you know exactly how many elements will be inserted, or at least have a reasonable upper-bound on that number.</source>
          <target state="translated">どれ &lt;code&gt;with_capacity&lt;/code&gt; のコンストラクタは、要素の指定された数のための十分なスペースを割り当てるコレクションを指示します。理想的には、これはまさにその多くの要素に対するものですが、実装の詳細によってはこれを妨げる場合があります。詳細については、コレクション固有のドキュメントを参照してください。一般的には、 &lt;code&gt;with_capacity&lt;/code&gt; 挿入される要素の数が正確にわかっている場合、または少なくともその数に適切な上限がある場合は with_capacityをします。</target>
        </trans-unit>
        <trans-unit id="0b673eb46a7f5984769da2ecfe123198574739d4" translate="yes" xml:space="preserve">
          <source>Any I/O error not part of this list.</source>
          <target state="translated">このリストに含まれない任意の I/O エラー。</target>
        </trans-unit>
        <trans-unit id="49edcccea744a8f077751ea25c38d4fc4cfa0fe8" translate="yes" xml:space="preserve">
          <source>Any IP address can be either a version four or a version six address, but not both at the same time. That property of IP addresses makes the enum data structure appropriate, because enum values can only be one of its variants. Both version four and version six addresses are still fundamentally IP addresses, so they should be treated as the same type when the code is handling situations that apply to any kind of IP address.</source>
          <target state="translated">どのIPアドレスもバージョン4またはバージョン6のアドレスになりますが、同時に両方のアドレスになることはありません。IP アドレスのこの性質は、列挙型データ構造を適切なものにしています。バージョン4もバージョン6も基本的にはIPアドレスなので、コードがどのような種類のIPアドレスにも適用される状況を扱う場合には、それらは同じ型として扱われるべきです。</target>
        </trans-unit>
        <trans-unit id="6867ac894a456ea99c7c6870f309c422acaaf4df" translate="yes" xml:space="preserve">
          <source>Any IP address can be either a version four or a version six address, but not both at the same time. That property of IP addresses makes the enum data structure appropriate, because enum values can only be one of the variants. Both version four and version six addresses are still fundamentally IP addresses, so they should be treated as the same type when the code is handling situations that apply to any kind of IP address.</source>
          <target state="translated">どのIPアドレスもバージョン4かバージョン6のどちらかになりますが、同時に両方になることはありません。IP アドレスのこの性質は enum データ構造を適切なものにしています。バージョン4もバージョン6も基本的にはIPアドレスなので、コードがどのような種類のIPアドレスにも適用される状況を扱う場合には、それらは同じ型として扱われるべきです。</target>
        </trans-unit>
        <trans-unit id="771cc11d8125e00769bce8eb3a9472fcb3c21cb2" translate="yes" xml:space="preserve">
          <source>Any character in the 'printable ASCII' range &lt;code&gt;0x20&lt;/code&gt; .. &lt;code&gt;0x7e&lt;/code&gt; inclusive is not escaped.</source>
          <target state="translated">「印刷可能なASCII」の範囲内の任意の文字 &lt;code&gt;0x20&lt;/code&gt; .. &lt;code&gt;0x7e&lt;/code&gt; 含むはエスケープされません。</target>
        </trans-unit>
        <trans-unit id="3e6eb82cfd1ccce10703d68820085fb1a0e36401" translate="yes" xml:space="preserve">
          <source>Any characters, except this sequence</source>
          <target state="translated">このシーケンス以外の任意の文字</target>
        </trans-unit>
        <trans-unit id="4cd23fb2001ef303a1bdb9cc4bb51ec0898b0bb8" translate="yes" xml:space="preserve">
          <source>Any characters, except those listed</source>
          <target state="translated">記載されている文字以外の任意の文字</target>
        </trans-unit>
        <trans-unit id="cf63f064edae30139fdd89fa67002f6be993edd6" translate="yes" xml:space="preserve">
          <source>Any conversions allowed by coercion can also be explicitly performed by the &lt;a href=&quot;expressions/operator-expr#type-cast-expressions&quot;&gt;type cast operator&lt;/a&gt;, &lt;code&gt;as&lt;/code&gt;.</source>
          <target state="translated">強制によって許可された任意の変換も明示することにより行うことができる&lt;a href=&quot;expressions/operator-expr#type-cast-expressions&quot;&gt;タイプのキャスト演算子&lt;/a&gt;、 &lt;code&gt;as&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="de99d379f5705cbf09c5d5e30200a62d7427ee91" translate="yes" xml:space="preserve">
          <source>Any excess capacity is removed:</source>
          <target state="translated">余った容量は削除されます。</target>
        </trans-unit>
        <trans-unit id="cfff92a36bb4f2aba0bfefa3df53467014699fa5" translate="yes" xml:space="preserve">
          <source>Any implementation where a type appears &lt;a href=&quot;#uncovered-type&quot;&gt;uncovered&lt;/a&gt;. &lt;code&gt;impl&amp;lt;T&amp;gt; Foo for T&lt;/code&gt;, &lt;code&gt;impl&amp;lt;T&amp;gt; Bar&amp;lt;T&amp;gt; for T&lt;/code&gt;, &lt;code&gt;impl&amp;lt;T&amp;gt; Bar&amp;lt;Vec&amp;lt;T&amp;gt;&amp;gt; for T&lt;/code&gt;, and &lt;code&gt;impl&amp;lt;T&amp;gt; Bar&amp;lt;T&amp;gt; for Vec&amp;lt;T&amp;gt;&lt;/code&gt; are considered blanket impls. However, &lt;code&gt;impl&amp;lt;T&amp;gt; Bar&amp;lt;Vec&amp;lt;T&amp;gt;&amp;gt; for Vec&amp;lt;T&amp;gt;&lt;/code&gt; is not a blanket impl, as all instances of &lt;code&gt;T&lt;/code&gt; which appear in this &lt;code&gt;impl&lt;/code&gt; are covered by &lt;code&gt;Vec&lt;/code&gt;.</source>
          <target state="translated">タイプが&lt;a href=&quot;#uncovered-type&quot;&gt;カバーされていない&lt;/a&gt;ように見える実装。 &lt;code&gt;impl&amp;lt;T&amp;gt; Foo for T&lt;/code&gt; 、 &lt;code&gt;impl&amp;lt;T&amp;gt; Bar&amp;lt;T&amp;gt; for T&lt;/code&gt; 、 &lt;code&gt;impl&amp;lt;T&amp;gt; Bar&amp;lt;Vec&amp;lt;T&amp;gt;&amp;gt; for T&lt;/code&gt; 、と &lt;code&gt;impl&amp;lt;T&amp;gt; Bar&amp;lt;T&amp;gt; for Vec&amp;lt;T&amp;gt;&lt;/code&gt; 毛布と考えられていますimpls。ただし、 &lt;code&gt;impl&amp;lt;T&amp;gt; Bar&amp;lt;Vec&amp;lt;T&amp;gt;&amp;gt; for Vec&amp;lt;T&amp;gt;&lt;/code&gt; 、この &lt;code&gt;impl&lt;/code&gt; に表示される &lt;code&gt;T&lt;/code&gt; のすべてのインスタンスが &lt;code&gt;Vec&lt;/code&gt; でカバーされているため、包括的なimplではありません。</target>
        </trans-unit>
        <trans-unit id="4eba9dcc5c9c9c3a4fc6d9f7d5233af8a7847a24" translate="yes" xml:space="preserve">
          <source>Any kind of aggregate constructor (array, &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;enum&lt;/code&gt;, tuple, ...)</source>
          <target state="translated">あらゆる種類の集約コンストラクター（配列、 &lt;code&gt;struct&lt;/code&gt; 、 &lt;code&gt;enum&lt;/code&gt; 、タプルなど）</target>
        </trans-unit>
        <trans-unit id="a2d418110b6f755d1311536fe4acdfee5af1facd" translate="yes" xml:space="preserve">
          <source>Any kind of literal (string, integer, etc) with any suffix is valid as a token, and can be passed to a macro without producing an error.</source>
          <target state="translated">任意のサフィックスを持つリテラル (文字列、整数など)はトークンとして有効であり、エラーを発生させることなくマクロに渡すことができます。</target>
        </trans-unit>
        <trans-unit id="6f537d5097da9afc6f346b4806da2a5f2a4e11dd" translate="yes" xml:space="preserve">
          <source>Any kind of literal (string, integer, etc) with any suffix is valid as a token, and can be passed to a macro without producing an error. The macro itself will decide how to interpret such a token and whether to produce an error or not.</source>
          <target state="translated">任意のサフィックスを持つ任意の種類のリテラル(文字列、整数など)はトークンとして有効であり、エラーを発生させることなくマクロに渡すことができます。マクロ自身がそのようなトークンをどのように解釈し、エラーを発生させるかどうかを決定します。</target>
        </trans-unit>
        <trans-unit id="4cbac428240bad16fb03767cc5cca3e5e71622e2" translate="yes" xml:space="preserve">
          <source>Any non-Unicode sequences are replaced with &lt;a href=&quot;../char/constant.replacement_character&quot;&gt;&lt;code&gt;U+FFFD REPLACEMENT CHARACTER&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">非Unicodeシーケンスは&lt;a href=&quot;../char/constant.replacement_character&quot;&gt; &lt;code&gt;U+FFFD REPLACEMENT CHARACTER&lt;/code&gt; &lt;/a&gt;置換文字に置き換えられますます。</target>
        </trans-unit>
        <trans-unit id="3df46fe98310c858bb458ed2bc6017d791596b12" translate="yes" xml:space="preserve">
          <source>Any of the characters in the range</source>
          <target state="translated">範囲内の任意の文字</target>
        </trans-unit>
        <trans-unit id="df4bb3c1fbc6102d5b31f44ab7298372090f0684" translate="yes" xml:space="preserve">
          <source>Any of the characters listed</source>
          <target state="translated">記載されているキャラクターのいずれか</target>
        </trans-unit>
        <trans-unit id="e1fe17e124adf671f41a6bcdb30bc09a9767a019" translate="yes" xml:space="preserve">
          <source>Any of the methods provided by a &lt;a href=&quot;../visibility-and-privacy&quot;&gt;visible&lt;/a&gt; trait implemented by &lt;code&gt;T&lt;/code&gt;. If &lt;code&gt;T&lt;/code&gt; is a type parameter, methods provided by trait bounds on &lt;code&gt;T&lt;/code&gt; are looked up first. Then all remaining methods in scope are looked up.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; によって実装される&lt;a href=&quot;../visibility-and-privacy&quot;&gt;目に見える&lt;/a&gt;特性によって提供されるメソッドのいずれか。場合 &lt;code&gt;T&lt;/code&gt; は、タイプパラメータである、上で形質境界によって提供される方法 &lt;code&gt;T&lt;/code&gt; は、最初に検索されます。次に、スコープ内の残りのすべてのメソッドが検索されます。</target>
        </trans-unit>
        <trans-unit id="5c8d97ac8cad3dfb222e1fcec0cd986d681f1547" translate="yes" xml:space="preserve">
          <source>Any other &lt;code&gt;Arc&lt;/code&gt; or &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers to the same allocation must not be dereferenced for the duration of the returned borrow. This is trivially the case if no such pointers exist, for example immediately after &lt;code&gt;Arc::new&lt;/code&gt;.</source>
          <target state="translated">同じ割り当てへの他の &lt;code&gt;Arc&lt;/code&gt; または&lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt;ポインターは、返された借用の期間中、逆参照されてはなりません。これは、たとえば &lt;code&gt;Arc::new&lt;/code&gt; 直後など、そのようなポインタが存在しない場合は簡単に当てはまります。</target>
        </trans-unit>
        <trans-unit id="0c05e8f1c6956f4765a713498f6a6547d98317e6" translate="yes" xml:space="preserve">
          <source>Any other &lt;code&gt;Rc&lt;/code&gt; or &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers to the same allocation must not be dereferenced for the duration of the returned borrow. This is trivially the case if no such pointers exist, for example immediately after &lt;code&gt;Rc::new&lt;/code&gt;.</source>
          <target state="translated">同じ割り当てへの他の &lt;code&gt;Rc&lt;/code&gt; または&lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt;ポインターは、返された借用の期間中、逆参照されてはなりません。これは、たとえば &lt;code&gt;Rc::new&lt;/code&gt; 直後など、そのようなポインタが存在しない場合は簡単に当てはまります。</target>
        </trans-unit>
        <trans-unit id="e19f15fb75a4bf5f47bda7e931808400dd6bf097" translate="yes" xml:space="preserve">
          <source>Any other changes attempted on a post should have no effect. For example, if we try to approve a draft blog post before we&amp;rsquo;ve requested a review, the post should remain an unpublished draft.</source>
          <target state="translated">投稿に対して行われたその他の変更は影響を与えません。たとえば、レビューをリクエストする前に下書きのブログ投稿を承認しようとした場合、その投稿は未公開の下書きのままにしておく必要があります。</target>
        </trans-unit>
        <trans-unit id="d6894150447e47d12e66ba741e1dc8f000de5b10" translate="yes" xml:space="preserve">
          <source>Any other chars are given hex escapes of the form '\xNN'.</source>
          <target state="translated">他の文字は '\xNN' という形式のヘックスエスケープが与えられます。</target>
        </trans-unit>
        <trans-unit id="c7e7ce7ad0344363614031d689f8048423505a67" translate="yes" xml:space="preserve">
          <source>Any resources the value manages, such as heap memory or a file handle, will linger forever in an unreachable state. However, it does not guarantee that pointers to this memory will remain valid.</source>
          <target state="translated">ヒープメモリやファイルハンドルなど、値が管理するリソースは、到達不可能な状態で永遠に残ります。しかし、このメモリへのポインタが有効なままであることを保証するものではありません。</target>
        </trans-unit>
        <trans-unit id="4582f1278b61140a4c03b6946eaab9c9e43377c3" translate="yes" xml:space="preserve">
          <source>Any suffixes are rejected on non-numeric literal tokens, and numeric literal tokens are accepted only with suffixes from the list below.</source>
          <target state="translated">数値以外のリテラルトークンにはサフィックスを付けることはできません。</target>
        </trans-unit>
        <trans-unit id="31bced9874925b40b1709b82b080279f57f95fc4" translate="yes" xml:space="preserve">
          <source>Any time a type &lt;code&gt;T&lt;/code&gt; is considered &lt;a href=&quot;#local-type&quot;&gt;local&lt;/a&gt;, &lt;code&gt;&amp;amp;T&lt;/code&gt;, &lt;code&gt;&amp;amp;mut T&lt;/code&gt;, &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;, and &lt;code&gt;Pin&amp;lt;T&amp;gt;&lt;/code&gt; are also considered local. Fundamental type constructors cannot &lt;a href=&quot;#uncovered-type&quot;&gt;cover&lt;/a&gt; other types. Any time the term &quot;covered type&quot; is used, the &lt;code&gt;T&lt;/code&gt; in &lt;code&gt;&amp;amp;T&lt;/code&gt;, &lt;code&gt;&amp;amp;mut T&lt;/code&gt;, &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;, and &lt;code&gt;Pin&amp;lt;T&amp;gt;&lt;/code&gt; is not considered covered.</source>
          <target state="translated">タイプ &lt;code&gt;T&lt;/code&gt; が&lt;a href=&quot;#local-type&quot;&gt;ローカル&lt;/a&gt;と見なされるときはいつでも、 &lt;code&gt;&amp;amp;T&lt;/code&gt; 、 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 、 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 、および &lt;code&gt;Pin&amp;lt;T&amp;gt;&lt;/code&gt; もローカルと見なされます。基本的な型コンストラクターは他の型を&lt;a href=&quot;#uncovered-type&quot;&gt;カバー&lt;/a&gt;できません。「タイプをカバーした」いつでも用語は、使用されている &lt;code&gt;T&lt;/code&gt; で &lt;code&gt;&amp;amp;T&lt;/code&gt; 、 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 、 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 、および &lt;code&gt;Pin&amp;lt;T&amp;gt;&lt;/code&gt; カバーされたと見なされていません。</target>
        </trans-unit>
        <trans-unit id="972a6afc1089fd19efd410e0369cd9e91a4ef0f3" translate="yes" xml:space="preserve">
          <source>Any time a type or function is provided by the standard library and you&amp;rsquo;re not sure what it does or how to use it, use the application programming interface (API) documentation to find out!</source>
          <target state="translated">タイプまたは関数が標準ライブラリによって提供されていて、その機能や使用方法がわからない場合は、アプリケーションプログラミングインターフェイス（API）のドキュメントを使用して調べてください。</target>
        </trans-unit>
        <trans-unit id="76deb7250dd43b06f05ef65522ed5c978849b0e5" translate="yes" xml:space="preserve">
          <source>Any type composed entirely of &lt;code&gt;Send&lt;/code&gt; types is automatically marked as &lt;code&gt;Send&lt;/code&gt; as well. Almost all primitive types are &lt;code&gt;Send&lt;/code&gt;, aside from raw pointers, which we&amp;rsquo;ll discuss in Chapter 19.</source>
          <target state="translated">完全に &lt;code&gt;Send&lt;/code&gt; タイプで構成されるタイプは、自動的に &lt;code&gt;Send&lt;/code&gt; としてもマークされます。ほとんどすべてのプリミティブ型は &lt;code&gt;Send&lt;/code&gt; 、これは19章で説明する生のポインタを除きます。</target>
        </trans-unit>
        <trans-unit id="af69a2cb47235b6ee090b2e8285120ce18b240b2" translate="yes" xml:space="preserve">
          <source>Any type parameter or lifetime parameter of an &lt;code&gt;impl&lt;/code&gt; must meet at least one of the following criteria:</source>
          <target state="translated">&lt;code&gt;impl&lt;/code&gt; のタイプパラメータまたはライフタイムパラメータは、次の基準の少なくとも1つを満たす必要があります。</target>
        </trans-unit>
        <trans-unit id="4b06ed0f2a9b9712d1ad4ec6082f1ea5cba3b543" translate="yes" xml:space="preserve">
          <source>Any type parameter parameter of an &lt;code&gt;impl&lt;/code&gt; must meet at least one of the following criteria:</source>
          <target state="translated">&lt;code&gt;impl&lt;/code&gt; の型パラメーターパラメーターは、次の基準の少なくとも1つを満たす必要があります。</target>
        </trans-unit>
        <trans-unit id="f149c09f36db068ab34499979d351f1c8d5f7f1e" translate="yes" xml:space="preserve">
          <source>Any type that derives &lt;code&gt;Eq&lt;/code&gt; automatically implements this trait, &lt;em&gt;regardless&lt;/em&gt; of whether its type parameters implement &lt;code&gt;Eq&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="788cf861093b3924fc04a0b5f4dac3cbdc3bb2d9" translate="yes" xml:space="preserve">
          <source>Any type that derives &lt;code&gt;Eq&lt;/code&gt; automatically implements this trait, &lt;em&gt;regardless&lt;/em&gt; of whether its type-parameters implement &lt;code&gt;Eq&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Eq&lt;/code&gt; を導出する型は、その型パラメーターが &lt;code&gt;Eq&lt;/code&gt; を実装するかどうかに&lt;em&gt;関係なく&lt;/em&gt;、この特性を自動的に実装します。</target>
        </trans-unit>
        <trans-unit id="cfadd00c3ae966bd61c993066771bfd5d6d8d45d" translate="yes" xml:space="preserve">
          <source>Any type that derives &lt;code&gt;PartialEq&lt;/code&gt; automatically implements this trait, &lt;em&gt;regardless&lt;/em&gt; of whether its type-parameters implement &lt;code&gt;Eq&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;PartialEq&lt;/code&gt; を派生させる型は、その型パラメーターが &lt;code&gt;Eq&lt;/code&gt; を実装するかどうかに&lt;em&gt;関係なく&lt;/em&gt;、この特性を自動的に実装します。</target>
        </trans-unit>
        <trans-unit id="07027ef0df88ca520ae158040613bfcdb04fbd90" translate="yes" xml:space="preserve">
          <source>Any types with interior mutability must also use the &lt;a href=&quot;../cell/struct.unsafecell&quot;&gt;&lt;code&gt;cell::UnsafeCell&lt;/code&gt;&lt;/a&gt; wrapper around the value(s) which can be mutated through a shared reference. Failing to doing this is &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;undefined behavior&lt;/a&gt;. For example, &lt;a href=&quot;../mem/fn.transmute&quot;&gt;&lt;code&gt;transmute&lt;/code&gt;&lt;/a&gt;-ing from &lt;code&gt;&amp;amp;T&lt;/code&gt; to &lt;code&gt;&amp;amp;mut T&lt;/code&gt; is invalid.</source>
          <target state="translated">内部で変更可能なタイプでは、共有参照を介して変更できる値の周りに&lt;a href=&quot;../cell/struct.unsafecell&quot;&gt; &lt;code&gt;cell::UnsafeCell&lt;/code&gt; &lt;/a&gt;ラッパーも使用する必要があります。これを実行し&lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;ない&lt;/a&gt;と、未定義の動作になります。例えば、&lt;a href=&quot;../mem/fn.transmute&quot;&gt; &lt;code&gt;transmute&lt;/code&gt; &lt;/a&gt;から-ing &lt;code&gt;&amp;amp;T&lt;/code&gt; の &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 無効です。</target>
        </trans-unit>
        <trans-unit id="4098bab2016a26a2da921c6a4c090c6509eb5934" translate="yes" xml:space="preserve">
          <source>Any use other than with &lt;code&gt;if&lt;/code&gt; statements will probably not have an effect.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 以外の用途ステートメントは、おそらく効果がありません。</target>
        </trans-unit>
        <trans-unit id="910dd93279c47bcced2d261d2b21071bc5cf465a" translate="yes" xml:space="preserve">
          <source>Any::downcast_mut</source>
          <target state="translated">Any::downcast_mut</target>
        </trans-unit>
        <trans-unit id="3142933cd2ff31b31d3f631fe20ea508e96ad05b" translate="yes" xml:space="preserve">
          <source>Any::downcast_ref</source>
          <target state="translated">Any::downcast_ref</target>
        </trans-unit>
        <trans-unit id="47853f41e226da1c34d9eedcdb8b975ed79ec7bc" translate="yes" xml:space="preserve">
          <source>Any::fmt</source>
          <target state="translated">Any::fmt</target>
        </trans-unit>
        <trans-unit id="63f0fc770b243d87075e5d22567fc12df96b560f" translate="yes" xml:space="preserve">
          <source>Any::is</source>
          <target state="translated">Any::is</target>
        </trans-unit>
        <trans-unit id="153b1345e60af7ce7872d3438b64b0f7f8addb2c" translate="yes" xml:space="preserve">
          <source>Any::type_id</source>
          <target state="translated">Any::type_id</target>
        </trans-unit>
        <trans-unit id="4cde3fadbf976f0b359d3c2a1968c555ccde759f" translate="yes" xml:space="preserve">
          <source>Anyone can write RFCs to improve Rust, and the proposals are reviewed and discussed by the Rust team, which is comprised of many topic subteams. There&amp;rsquo;s a full list of the teams &lt;a href=&quot;https://www.rust-lang.org/governance&quot;&gt;on Rust&amp;rsquo;s website&lt;/a&gt;, which includes teams for each area of the project: language design, compiler implementation, infrastructure, documentation, and more. The appropriate team reads the proposal and the comments, writes some comments of their own, and eventually, there&amp;rsquo;s consensus to accept or reject the feature.</source>
          <target state="translated">Rustを改善するために誰でもRFCを作成できます。提案は、多くのトピックサブチームで構成されるRustチームによってレビューおよび議論されます。&lt;a href=&quot;https://www.rust-lang.org/governance&quot;&gt;RustのWebサイトには&lt;/a&gt;、言語設計、コンパイラーの実装、インフラストラクチャ、ドキュメントなど、プロジェクトの各領域のチームを含むチームの完全なリストがあります。適切なチームが提案とコメントを読み、独自のコメントをいくつか書き込みます。最終的には、機能を受け入れるか拒否するかについてのコンセンサスがあります。</target>
        </trans-unit>
        <trans-unit id="53fc70bfdc4b06ea1c2fe17e53fbb9c43726838e" translate="yes" xml:space="preserve">
          <source>Apart from a method or function with a generic type parameter, this error can occur when a type parameter of a struct or trait cannot be inferred. In that case it is not always possible to use a type annotation, because all candidates have the same return type. For instance:</source>
          <target state="translated">一般的な型パラメータを持つメソッドや関数とは別に、構造体や形質の型パラメータが推論できない場合に、このエラーが発生することがあります。その場合、すべての候補が同じ戻り値の型を持っているため、型アノテーションを使用することができない場合があります。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="b813c448dbc23e1f367ecbf1266f8f07cadc0bab" translate="yes" xml:space="preserve">
          <source>Apart from lifetime extension, the temporary scope of an expression is the smallest scope that contains the expression and is for one of the following:</source>
          <target state="translated">寿命の延長とは別に、式の一時的なスコープは、式を含む最小のスコープであり、以下のいずれかのためのものです。</target>
        </trans-unit>
        <trans-unit id="73973cfd168d40bb8277e2f6044ecdb605409c4e" translate="yes" xml:space="preserve">
          <source>Appendices</source>
          <target state="translated">Appendices</target>
        </trans-unit>
        <trans-unit id="56e2c591df0fef929570597dca64284006730141" translate="yes" xml:space="preserve">
          <source>Appending to a String with &lt;code id=&quot;appending-to-a-string-with-push_str-and-push&quot;&gt;push_str&lt;/code&gt; and &lt;code&gt;push&lt;/code&gt;</source>
          <target state="translated">&lt;code id=&quot;appending-to-a-string-with-push_str-and-push&quot;&gt;push_str&lt;/code&gt; と &lt;code&gt;push&lt;/code&gt; を使用して文字列に追加する</target>
        </trans-unit>
        <trans-unit id="f3f60044b06335eb6c4230e3c39f5e0218445878" translate="yes" xml:space="preserve">
          <source>Appendix</source>
          <target state="translated">Appendix</target>
        </trans-unit>
        <trans-unit id="4c40c194c9cdc4d680691d4aa8fa1913dc98b2c3" translate="yes" xml:space="preserve">
          <source>Appendix A, &amp;ldquo;Keywords,&amp;rdquo; also explains the new raw identifiers feature that enables code written in the 2015 Edition and the 2018 Edition to interoperate.</source>
          <target state="translated">付録A「キーワード」では、2015年版と2018年版で記述されたコードの相互運用を可能にする新しい未加工識別子機能についても説明します。</target>
        </trans-unit>
        <trans-unit id="8415247b515164394b09f1335fc5dabc83b9e17a" translate="yes" xml:space="preserve">
          <source>Appendix A: Keywords</source>
          <target state="translated">付録A:キーワード</target>
        </trans-unit>
        <trans-unit id="540243de89d6ff78feccd1151f1eeb23d45eae75" translate="yes" xml:space="preserve">
          <source>Appendix B: Operators and Symbols</source>
          <target state="translated">付録B:オペレータと記号</target>
        </trans-unit>
        <trans-unit id="e440a4e5c41dd9d1d57a9a1afc26c19786ef345a" translate="yes" xml:space="preserve">
          <source>Appendix C: Derivable Traits</source>
          <target state="translated">付録C:派生形質</target>
        </trans-unit>
        <trans-unit id="41116b5529dd9b48afe443e282c8edc6aed9a707" translate="yes" xml:space="preserve">
          <source>Appendix D - Useful Development Tools</source>
          <target state="translated">付録D-便利な開発ツール</target>
        </trans-unit>
        <trans-unit id="707523bd94a1c061f370a00dc35452edc4f5ca2b" translate="yes" xml:space="preserve">
          <source>Appendix D is now titled &amp;ldquo;Useful Development Tools&amp;rdquo; and covers recently released tools that help you write Rust code.</source>
          <target state="translated">付録Dのタイトルは「便利な開発ツール」になり、Rustコードの記述に役立つ最近リリースされたツールについて説明しています。</target>
        </trans-unit>
        <trans-unit id="e50a67316708bcdc8cd3a1c83a15ee617b6e1717" translate="yes" xml:space="preserve">
          <source>Appendix E - Editions</source>
          <target state="translated">付録E-エディション</target>
        </trans-unit>
        <trans-unit id="db95e2a46f6e17f889e1ec8cb84b232b2ac6a554" translate="yes" xml:space="preserve">
          <source>Appendix F: Translations of the Book</source>
          <target state="translated">付録F:本の翻訳</target>
        </trans-unit>
        <trans-unit id="cd9cd2e1d4c917e818f77ba2a0d93ffcdf7874d2" translate="yes" xml:space="preserve">
          <source>Appendix G - How Rust is Made and &amp;ldquo;Nightly Rust&amp;rdquo;</source>
          <target state="translated">付録G-錆の発生方法と「夜間に錆びる」</target>
        </trans-unit>
        <trans-unit id="7ea8d3526ea6b8af40ac97da94b0ad40d6cea127" translate="yes" xml:space="preserve">
          <source>Appendix chapters providing rationale and references to languages that influenced the design.</source>
          <target state="translated">デザインに影響を与えた言語の根拠と参照を提供する付録の章。</target>
        </trans-unit>
        <trans-unit id="0d6a0bfa8816321ae3291d75b6bf84f8077fe48b" translate="yes" xml:space="preserve">
          <source>Appendix: Macro Follow-Set Ambiguity Formal Specification</source>
          <target state="translated">付録 マクロフォローセットの曖昧さ 形式的な仕様</target>
        </trans-unit>
        <trans-unit id="54e814d184dccc0b7473b24d35812b283adff9c0" translate="yes" xml:space="preserve">
          <source>Appends a given string slice onto the end of this &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">指定された文字列スライスをこの &lt;code&gt;String&lt;/code&gt; の最後に追加します。</target>
        </trans-unit>
        <trans-unit id="bd5ef47a12f2696c33dc462f202e22f6e229647a" translate="yes" xml:space="preserve">
          <source>Appends an element to the back of a collection.</source>
          <target state="translated">コレクションの後ろに要素を追加します。</target>
        </trans-unit>
        <trans-unit id="ddf4cf8edbc5fa033e85502f0a84bfe8b2914aec" translate="yes" xml:space="preserve">
          <source>Appends an element to the back of a list.</source>
          <target state="translated">リストの後ろに要素を追加します。</target>
        </trans-unit>
        <trans-unit id="9427717eceb820f7ae4720310e1343f09df153f2" translate="yes" xml:space="preserve">
          <source>Appends an element to the back of the &lt;code&gt;VecDeque&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;VecDeque&lt;/code&gt; の後ろに要素を追加します。</target>
        </trans-unit>
        <trans-unit id="373311f9bb46882cd119d03cfc2b6fa19fdf5ba3" translate="yes" xml:space="preserve">
          <source>Appends the given &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; to the end of this &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">指定された&lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;をこの &lt;code&gt;String&lt;/code&gt; の最後に追加します。</target>
        </trans-unit>
        <trans-unit id="f88d43733a3d3b030bf7286e9ed4c303cc3a7d2b" translate="yes" xml:space="preserve">
          <source>Application Binary Interface (ABI)</source>
          <target state="translated">アプリケーションバイナリインタフェース(ABI)</target>
        </trans-unit>
        <trans-unit id="9a4440ced79c9610e5a61ec32030ae30f58d9a8c" translate="yes" xml:space="preserve">
          <source>Applies a function to the contained value (if &lt;a href=&quot;enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;), or returns the provided default (if &lt;a href=&quot;enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">含まれている値に関数を適用するか（&lt;a href=&quot;enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; の&lt;/a&gt;場合）、提供されたデフォルトを返します（&lt;a href=&quot;enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; の&lt;/a&gt;場合）。</target>
        </trans-unit>
        <trans-unit id="bed8e79e380caf3902110314a704f53a22b3ecbe" translate="yes" xml:space="preserve">
          <source>Applies a function to the contained value (if any), or computes a default (if not).</source>
          <target state="translated">含まれている値に関数を適用し(あれば)、デフォルト値を計算します(なければ)。</target>
        </trans-unit>
        <trans-unit id="ef8795473614177b83e201e3db900beeef41c1e2" translate="yes" xml:space="preserve">
          <source>Applies a function to the contained value (if any), or returns the provided default (if not).</source>
          <target state="translated">含まれる値に関数を適用し(あれば)、指定されたデフォルト値を返します(なければ)。</target>
        </trans-unit>
        <trans-unit id="a6be2123eb22e6f1506885d0c1439a3655475eac" translate="yes" xml:space="preserve">
          <source>Applies function to the elements of iterator and returns the first non-none result.</source>
          <target state="translated">イテレータの要素に関数を適用し、最初の非ゼロの結果を返します。</target>
        </trans-unit>
        <trans-unit id="2f579750efee0b6f5e959f71ab15df216a9fb1b9" translate="yes" xml:space="preserve">
          <source>Applies function to the elements of iterator and returns the first non-none result. &lt;a href=&quot;../../../iter/trait.iterator#method.find_map&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">イテレータの要素に関数を適用し、最初のnone以外の結果を返します。&lt;a href=&quot;../../../iter/trait.iterator#method.find_map&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7da1899028718ec8a07b6c08455d63f4e3489b90" translate="yes" xml:space="preserve">
          <source>Applies function to the elements of iterator and returns the first non-none result. &lt;a href=&quot;../../iter/trait.iterator#method.find_map&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">イテレータの要素に関数を適用し、最初のnone以外の結果を返します。&lt;a href=&quot;../../iter/trait.iterator#method.find_map&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0f3002a1274a5209b380bd8bf18387ed22cf040f" translate="yes" xml:space="preserve">
          <source>Applies function to the elements of iterator and returns the first non-none result. &lt;a href=&quot;../iter/trait.iterator#method.find_map&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">イテレータの要素に関数を適用し、最初のnone以外の結果を返します。&lt;a href=&quot;../iter/trait.iterator#method.find_map&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="67cbbc3631a3803076e70ec9a10a8358879f6e02" translate="yes" xml:space="preserve">
          <source>Applies function to the elements of iterator and returns the first non-none result. &lt;a href=&quot;iter/trait.iterator#method.find_map&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">イテレータの要素に関数を適用し、最初のnone以外の結果を返します。&lt;a href=&quot;iter/trait.iterator#method.find_map&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8819d96feaef2f02cd8965c68d9eb2580ebfc977" translate="yes" xml:space="preserve">
          <source>Applies function to the elements of iterator and returns the first non-none result. &lt;a href=&quot;trait.iterator#method.find_map&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">イテレータの要素に関数を適用し、最初のnone以外の結果を返します。&lt;a href=&quot;trait.iterator#method.find_map&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c71f5fd4b8bc9dae7fc6bb52c696f533ce8ed924" translate="yes" xml:space="preserve">
          <source>Applies function to the elements of iterator and returns the first true result or the first error.</source>
          <target state="translated">イテレータの要素に関数を適用し、最初の真の結果または最初のエラーを返します。</target>
        </trans-unit>
        <trans-unit id="fd078bc0e6ebca661ba36b845bc2f34f79671219" translate="yes" xml:space="preserve">
          <source>Applies function to the elements of iterator and returns the first true result or the first error. &lt;a href=&quot;../../../iter/trait.iterator#method.try_find&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">イテレータの要素に関数を適用し、最初の真の結果または最初のエラーを返します。&lt;a href=&quot;../../../iter/trait.iterator#method.try_find&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="13f3965e6fc53b243d5a7c2dc2282a44cca3805a" translate="yes" xml:space="preserve">
          <source>Applies function to the elements of iterator and returns the first true result or the first error. &lt;a href=&quot;../../iter/trait.iterator#method.try_find&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">イテレータの要素に関数を適用し、最初の真の結果または最初のエラーを返します。&lt;a href=&quot;../../iter/trait.iterator#method.try_find&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ddb07d601f2efbf0db36543c96f74916e4858345" translate="yes" xml:space="preserve">
          <source>Applies function to the elements of iterator and returns the first true result or the first error. &lt;a href=&quot;../iter/trait.iterator#method.try_find&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">イテレータの要素に関数を適用し、最初の真の結果または最初のエラーを返します。&lt;a href=&quot;../iter/trait.iterator#method.try_find&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cfe6a04d1d11293ba9f6db79767b686fae8501d1" translate="yes" xml:space="preserve">
          <source>Applies function to the elements of iterator and returns the first true result or the first error. &lt;a href=&quot;iter/trait.iterator#method.try_find&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">イテレータの要素に関数を適用し、最初の真の結果または最初のエラーを返します。&lt;a href=&quot;iter/trait.iterator#method.try_find&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="813b671e50d44d7d39a003bdb093dc2cdbf235f8" translate="yes" xml:space="preserve">
          <source>Applies function to the elements of iterator and returns the first true result or the first error. &lt;a href=&quot;trait.iterator#method.try_find&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">イテレータの要素に関数を適用し、最初の真の結果または最初のエラーを返します。&lt;a href=&quot;trait.iterator#method.try_find&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1ff8e99aa0f8295d1776562bee993cb0a364606b" translate="yes" xml:space="preserve">
          <source>Applies the &quot;?&quot; operator. A return of &lt;code&gt;Ok(t)&lt;/code&gt; means that the execution should continue normally, and the result of &lt;code&gt;?&lt;/code&gt; is the value &lt;code&gt;t&lt;/code&gt;. A return of &lt;code&gt;Err(e)&lt;/code&gt; means that execution should branch to the innermost enclosing &lt;code&gt;catch&lt;/code&gt;, or return from the function.</source>
          <target state="translated">「？」を適用します オペレーター。 &lt;code&gt;Ok(t)&lt;/code&gt; の戻り値は、実行が正常に継続する必要があることを意味し、 &lt;code&gt;?&lt;/code&gt; 値 &lt;code&gt;t&lt;/code&gt; です。 &lt;code&gt;Err(e)&lt;/code&gt; の戻り値は、実行が最も内側の囲んでいる &lt;code&gt;catch&lt;/code&gt; に分岐することを意味しますか、関数から戻るます。</target>
        </trans-unit>
        <trans-unit id="d771dbfeb7c050dea75fe4d6749833e3ae20e4ae" translate="yes" xml:space="preserve">
          <source>Applies the &quot;?&quot; operator. A return of &lt;code&gt;Ok(t)&lt;/code&gt; means that the execution should continue normally, and the result of &lt;code&gt;?&lt;/code&gt; is the value &lt;code&gt;t&lt;/code&gt;. A return of &lt;code&gt;Err(e)&lt;/code&gt; means that execution should branch to the innermost enclosing &lt;code&gt;catch&lt;/code&gt;, or return from the function. &lt;a href=&quot;../ops/trait.try#tymethod.into_result&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">「？」を適用します オペレーター。 &lt;code&gt;Ok(t)&lt;/code&gt; の戻り値は、実行が正常に継続する必要があることを意味し、 &lt;code&gt;?&lt;/code&gt; 値 &lt;code&gt;t&lt;/code&gt; です。 &lt;code&gt;Err(e)&lt;/code&gt; の戻り値は、実行が最も内側の外側の &lt;code&gt;catch&lt;/code&gt; に分岐するか、関数から戻る必要があることを意味します。&lt;a href=&quot;../ops/trait.try#tymethod.into_result&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="84c127ccde0ff66daa4ff755926ef467d8ab1d62" translate="yes" xml:space="preserve">
          <source>Applies the &quot;?&quot; operator. A return of &lt;code&gt;Ok(t)&lt;/code&gt; means that the execution should continue normally, and the result of &lt;code&gt;?&lt;/code&gt; is the value &lt;code&gt;t&lt;/code&gt;. A return of &lt;code&gt;Err(e)&lt;/code&gt; means that execution should branch to the innermost enclosing &lt;code&gt;catch&lt;/code&gt;, or return from the function. &lt;a href=&quot;trait.try#tymethod.into_result&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">「？」を適用します オペレーター。 &lt;code&gt;Ok(t)&lt;/code&gt; が返されるということは、実行が正常に続行されることを意味し、 &lt;code&gt;?&lt;/code&gt; の結果は？は値 &lt;code&gt;t&lt;/code&gt; です。 &lt;code&gt;Err(e)&lt;/code&gt; の戻りは、実行が最も内側の囲み &lt;code&gt;catch&lt;/code&gt; 分岐するか、関数から戻る必要があることを意味します。&lt;a href=&quot;trait.try#tymethod.into_result&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6233fb9390747dc2f23a28899738d6cc6a72590f" translate="yes" xml:space="preserve">
          <source>Applying the attribute to a function &lt;code&gt;f&lt;/code&gt; allows code within &lt;code&gt;f&lt;/code&gt; to get a hint of the &lt;a href=&quot;https://doc.rust-lang.org/core/panic/struct.Location.html&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt; of the &quot;topmost&quot; tracked call that led to &lt;code&gt;f&lt;/code&gt;'s invocation. At the point of observation, an implementation behaves as if it walks up the stack from &lt;code&gt;f&lt;/code&gt;'s frame to find the nearest frame of an &lt;em&gt;unattributed&lt;/em&gt; function &lt;code&gt;outer&lt;/code&gt;, and it returns the &lt;a href=&quot;https://doc.rust-lang.org/core/panic/struct.Location.html&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt; of the tracked call in &lt;code&gt;outer&lt;/code&gt;.</source>
          <target state="translated">関数に属性を適用する &lt;code&gt;f&lt;/code&gt; 内のコードができます &lt;code&gt;f&lt;/code&gt; はのヒントを得るために&lt;a href=&quot;https://doc.rust-lang.org/core/panic/struct.Location.html&quot;&gt; &lt;code&gt;Location&lt;/code&gt; &lt;/a&gt;につながったことを「最上位」追跡コールの &lt;code&gt;f&lt;/code&gt; の呼び出しを。観測点で、実施振る舞うことからスタックを歩くかのように &lt;code&gt;f&lt;/code&gt; の最も近いフレーム見つけるためのフレームを&lt;em&gt;アトリビューションのない&lt;/em&gt;機能の &lt;code&gt;outer&lt;/code&gt; 、それは戻り&lt;a href=&quot;https://doc.rust-lang.org/core/panic/struct.Location.html&quot;&gt; &lt;code&gt;Location&lt;/code&gt; &lt;/a&gt;で追跡コールを &lt;code&gt;outer&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8404e9317204d7715d2f49a56717841155af3a5d" translate="yes" xml:space="preserve">
          <source>Approximate desugaring</source>
          <target state="translated">おおよその脱菅</target>
        </trans-unit>
        <trans-unit id="7e15c6fd69af4acca9c9f459c798f3ae0c37890f" translate="yes" xml:space="preserve">
          <source>Approximate number of significant digits in base 10.</source>
          <target state="translated">ベース10の有効数字のおおよその数。</target>
        </trans-unit>
        <trans-unit id="741aa1a23115e831e460da0298845488131bda9a" translate="yes" xml:space="preserve">
          <source>Approximate number of significant digits in base 10. Use &lt;a href=&quot;../primitive.f32#associatedconstant.DIGITS&quot;&gt;&lt;code&gt;f32::DIGITS&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">基数10の有効桁数のおおよその数。代わりに&lt;a href=&quot;../primitive.f32#associatedconstant.DIGITS&quot;&gt; &lt;code&gt;f32::DIGITS&lt;/code&gt; &lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="d8912ed7e59aeef6ce8c4355dd3b80515ddbd4f1" translate="yes" xml:space="preserve">
          <source>Approximate number of significant digits in base 10. Use &lt;a href=&quot;../primitive.f64#associatedconstant.DIGITS&quot;&gt;&lt;code&gt;f64::DIGITS&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">基数10の有効桁数のおおよその数。代わりに&lt;a href=&quot;../primitive.f64#associatedconstant.DIGITS&quot;&gt; &lt;code&gt;f64::DIGITS&lt;/code&gt; &lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="853a983f6b8abdb9ecba43da2ceda1641c9d519f" translate="yes" xml:space="preserve">
          <source>Arc</source>
          <target state="translated">Arc</target>
        </trans-unit>
        <trans-unit id="59cfa485c658b8f9969a88c2eb92540fdf722cfd" translate="yes" xml:space="preserve">
          <source>Arc::as_ref</source>
          <target state="translated">Arc::as_ref</target>
        </trans-unit>
        <trans-unit id="2f1c5ec3613e810179b1dde9e1ff629a07f45de3" translate="yes" xml:space="preserve">
          <source>Arc::borrow</source>
          <target state="translated">Arc::borrow</target>
        </trans-unit>
        <trans-unit id="e6381920a9fbe9f6076603c436d6eef9b74e1f24" translate="yes" xml:space="preserve">
          <source>Arc::borrow_mut</source>
          <target state="translated">Arc::borrow_mut</target>
        </trans-unit>
        <trans-unit id="de0c16869f1a3fad5d726dc3e3fba2293f156861" translate="yes" xml:space="preserve">
          <source>Arc::clamp</source>
          <target state="translated">Arc::clamp</target>
        </trans-unit>
        <trans-unit id="9fa492e8fa6e20e1b52a4de7403dbe55ec1b79bf" translate="yes" xml:space="preserve">
          <source>Arc::clone</source>
          <target state="translated">Arc::clone</target>
        </trans-unit>
        <trans-unit id="39cf0d205cd739521ce28938f9a2250155c1bac4" translate="yes" xml:space="preserve">
          <source>Arc::clone_from</source>
          <target state="translated">Arc::clone_from</target>
        </trans-unit>
        <trans-unit id="773d06cfd159d4606ff3014fee5f9931067cf220" translate="yes" xml:space="preserve">
          <source>Arc::clone_into</source>
          <target state="translated">Arc::clone_into</target>
        </trans-unit>
        <trans-unit id="7561059135cbd0c5fbb5238091fd429a9e1b09c1" translate="yes" xml:space="preserve">
          <source>Arc::cmp</source>
          <target state="translated">Arc::cmp</target>
        </trans-unit>
        <trans-unit id="b73ea8e602ed4ab4007a418f3f6cee6a05a73996" translate="yes" xml:space="preserve">
          <source>Arc::default</source>
          <target state="translated">Arc::default</target>
        </trans-unit>
        <trans-unit id="cdd18aaa5e1ccdcb1656e6b3c539ea6dd22d2613" translate="yes" xml:space="preserve">
          <source>Arc::deref</source>
          <target state="translated">Arc::deref</target>
        </trans-unit>
        <trans-unit id="3d5ef1d21d6636272bbb1c82a7af354e776cadde" translate="yes" xml:space="preserve">
          <source>Arc::downcast</source>
          <target state="translated">Arc::downcast</target>
        </trans-unit>
        <trans-unit id="8f4a9849100a7720ad47a02d98c3cc428143986f" translate="yes" xml:space="preserve">
          <source>Arc::downgrade</source>
          <target state="translated">Arc::downgrade</target>
        </trans-unit>
        <trans-unit id="4d05d06001426353e874710f4e01911168266628" translate="yes" xml:space="preserve">
          <source>Arc::drop</source>
          <target state="translated">Arc::drop</target>
        </trans-unit>
        <trans-unit id="d616628ce7e2e600feb8196c85f5e01fa37ae824" translate="yes" xml:space="preserve">
          <source>Arc::eq</source>
          <target state="translated">Arc::eq</target>
        </trans-unit>
        <trans-unit id="541daae394114016fc018c7425373988b033cde5" translate="yes" xml:space="preserve">
          <source>Arc::fmt</source>
          <target state="translated">Arc::fmt</target>
        </trans-unit>
        <trans-unit id="c5939b1aa685e46bfb67eeb83668be8ab9a5dab1" translate="yes" xml:space="preserve">
          <source>Arc::from</source>
          <target state="translated">Arc::from</target>
        </trans-unit>
        <trans-unit id="dea799f19377ba936fa669465a1dea313ae3aa7a" translate="yes" xml:space="preserve">
          <source>Arc::from_raw</source>
          <target state="translated">Arc::from_raw</target>
        </trans-unit>
        <trans-unit id="6910e0ecb20317c068e1ba9e8ebf007d417f95a2" translate="yes" xml:space="preserve">
          <source>Arc::ge</source>
          <target state="translated">Arc::ge</target>
        </trans-unit>
        <trans-unit id="7e24d2d9f75e2ea02439ac0bd0d3b07ceaa736e4" translate="yes" xml:space="preserve">
          <source>Arc::get_mut</source>
          <target state="translated">Arc::get_mut</target>
        </trans-unit>
        <trans-unit id="e94b486a276abc7bcb5888a4d6fc97a6fa8eebaa" translate="yes" xml:space="preserve">
          <source>Arc::gt</source>
          <target state="translated">Arc::gt</target>
        </trans-unit>
        <trans-unit id="f233cce03a62c687a1d4be5e670e3be37d179359" translate="yes" xml:space="preserve">
          <source>Arc::hash</source>
          <target state="translated">Arc::hash</target>
        </trans-unit>
        <trans-unit id="963937d635066d272a6f67596279f6b16956abdb" translate="yes" xml:space="preserve">
          <source>Arc::hash_slice</source>
          <target state="translated">Arc::hash_slice</target>
        </trans-unit>
        <trans-unit id="2b8954f29938fa3429d664d59b2922996301d34a" translate="yes" xml:space="preserve">
          <source>Arc::into</source>
          <target state="translated">Arc::into</target>
        </trans-unit>
        <trans-unit id="24e83cc9b0b264818fc7b3695d912fc8e4d9e845" translate="yes" xml:space="preserve">
          <source>Arc::into_raw</source>
          <target state="translated">Arc::into_raw</target>
        </trans-unit>
        <trans-unit id="921d5aa53e181c2612da9bf23381db35c63bd321" translate="yes" xml:space="preserve">
          <source>Arc::into_raw_non_null</source>
          <target state="translated">Arc::into_raw_non_null</target>
        </trans-unit>
        <trans-unit id="f3473006930ab6b55f7aef32c93c0af0f87e7790" translate="yes" xml:space="preserve">
          <source>Arc::le</source>
          <target state="translated">Arc::le</target>
        </trans-unit>
        <trans-unit id="34b95793d03cc8c6cef222cea98c6e99dc74e9e2" translate="yes" xml:space="preserve">
          <source>Arc::lt</source>
          <target state="translated">Arc::lt</target>
        </trans-unit>
        <trans-unit id="eab1ca96353cac811bc765a502fbbe1723278950" translate="yes" xml:space="preserve">
          <source>Arc::make_mut</source>
          <target state="translated">Arc::make_mut</target>
        </trans-unit>
        <trans-unit id="0a9a2e87881627fae4b58af4ea1e4cdaa0c36395" translate="yes" xml:space="preserve">
          <source>Arc::max</source>
          <target state="translated">Arc::max</target>
        </trans-unit>
        <trans-unit id="431ba8a8a73b16f867d8367c027605d9a9f25a4e" translate="yes" xml:space="preserve">
          <source>Arc::min</source>
          <target state="translated">Arc::min</target>
        </trans-unit>
        <trans-unit id="a700586ffae96fc24dca7f29fd88b64a47bae03d" translate="yes" xml:space="preserve">
          <source>Arc::ne</source>
          <target state="translated">Arc::ne</target>
        </trans-unit>
        <trans-unit id="1311cfe952a5208cf9ab108dab2eb693395bbca1" translate="yes" xml:space="preserve">
          <source>Arc::new</source>
          <target state="translated">Arc::new</target>
        </trans-unit>
        <trans-unit id="2c2d4efc7b27aae2edec462666037bcaf500cae7" translate="yes" xml:space="preserve">
          <source>Arc::partial_cmp</source>
          <target state="translated">Arc::partial_cmp</target>
        </trans-unit>
        <trans-unit id="41a523a445899356c297537c4b72fff018176305" translate="yes" xml:space="preserve">
          <source>Arc::pin</source>
          <target state="translated">Arc::pin</target>
        </trans-unit>
        <trans-unit id="1d09dbe8f647daf2ca429c9d36141d61d7d2799f" translate="yes" xml:space="preserve">
          <source>Arc::ptr_eq</source>
          <target state="translated">Arc::ptr_eq</target>
        </trans-unit>
        <trans-unit id="ec8427607c6875d57c1cbb7ae116c8a1b2bc9f8b" translate="yes" xml:space="preserve">
          <source>Arc::strong_count</source>
          <target state="translated">Arc::strong_count</target>
        </trans-unit>
        <trans-unit id="12f7dc5817d10cbbabc6ff3c697a1ca67ff339d5" translate="yes" xml:space="preserve">
          <source>Arc::to_owned</source>
          <target state="translated">Arc::to_owned</target>
        </trans-unit>
        <trans-unit id="dd1da4e8925e8953dfb4aef0354dd388c867af08" translate="yes" xml:space="preserve">
          <source>Arc::to_string</source>
          <target state="translated">Arc::to_string</target>
        </trans-unit>
        <trans-unit id="b36b4607ae74c4708612a87739b787ab550df768" translate="yes" xml:space="preserve">
          <source>Arc::try_from</source>
          <target state="translated">Arc::try_from</target>
        </trans-unit>
        <trans-unit id="450b59e4892b86614294b44b39674630d4067a1f" translate="yes" xml:space="preserve">
          <source>Arc::try_into</source>
          <target state="translated">Arc::try_into</target>
        </trans-unit>
        <trans-unit id="8cc0a8e7a4fa3ddf0be44f0e2f8210b7538bff4d" translate="yes" xml:space="preserve">
          <source>Arc::try_unwrap</source>
          <target state="translated">Arc::try_unwrap</target>
        </trans-unit>
        <trans-unit id="e60b417105d1b796fbb9108c579b5a5a3f60ab78" translate="yes" xml:space="preserve">
          <source>Arc::type_id</source>
          <target state="translated">Arc::type_id</target>
        </trans-unit>
        <trans-unit id="6623270e41b383306513b26dd0972d02a62dabdc" translate="yes" xml:space="preserve">
          <source>Arc::weak_count</source>
          <target state="translated">Arc::weak_count</target>
        </trans-unit>
        <trans-unit id="bcef6163f2366764b97712c1e02d4e8de8728060" translate="yes" xml:space="preserve">
          <source>Archimedes' constant (&amp;pi;)</source>
          <target state="translated">アルキメデスの定数（&amp;pi;）</target>
        </trans-unit>
        <trans-unit id="02d36a6ada7ba4a678771b24dc19a1d26e06d584" translate="yes" xml:space="preserve">
          <source>Are allowed to be null</source>
          <target state="translated">nullであることが許されています。</target>
        </trans-unit>
        <trans-unit id="7bcd778277bf4c00f69bda3256c3718425635b4a" translate="yes" xml:space="preserve">
          <source>Are allowed to ignore the borrowing rules by having both immutable and mutable pointers or multiple mutable pointers to the same location</source>
          <target state="translated">同じ場所への不変型と変異型の両方のポインタ、または複数の変異型ポインタを持つことで、借用ルールを無視することができます。</target>
        </trans-unit>
        <trans-unit id="79232b3ded8b7d0b1c86ea5d989ec5b302602c26" translate="yes" xml:space="preserve">
          <source>Aren&amp;rsquo;t guaranteed to point to valid memory</source>
          <target state="translated">有効なメモリを指すことが保証されていません</target>
        </trans-unit>
        <trans-unit id="4bf0024c4bc943f998126635e2b2826496ec8582" translate="yes" xml:space="preserve">
          <source>Args</source>
          <target state="translated">Args</target>
        </trans-unit>
        <trans-unit id="11997e344b54f51ca26eed6c34abb35c17719846" translate="yes" xml:space="preserve">
          <source>Args::all</source>
          <target state="translated">Args::all</target>
        </trans-unit>
        <trans-unit id="834e48f2681bde9c6de2a1d6fe4ea459480940da" translate="yes" xml:space="preserve">
          <source>Args::any</source>
          <target state="translated">Args::any</target>
        </trans-unit>
        <trans-unit id="852de3f0c6270398ac654986a4377df5f50c393c" translate="yes" xml:space="preserve">
          <source>Args::borrow</source>
          <target state="translated">Args::borrow</target>
        </trans-unit>
        <trans-unit id="8aa2c84655d80e6196471b5bce3e6eb8f9d79f61" translate="yes" xml:space="preserve">
          <source>Args::borrow_mut</source>
          <target state="translated">Args::borrow_mut</target>
        </trans-unit>
        <trans-unit id="6235293cd6910b3c74977e8687ec90afadb03077" translate="yes" xml:space="preserve">
          <source>Args::by_ref</source>
          <target state="translated">Args::by_ref</target>
        </trans-unit>
        <trans-unit id="4438640d50dfd08974f7aac6bf0d2aecb461c3f5" translate="yes" xml:space="preserve">
          <source>Args::chain</source>
          <target state="translated">Args::chain</target>
        </trans-unit>
        <trans-unit id="fd443c43e63db2a659b5f263c42823b6b670bd44" translate="yes" xml:space="preserve">
          <source>Args::cloned</source>
          <target state="translated">Args::cloned</target>
        </trans-unit>
        <trans-unit id="46277936c8445a042e94cc3a26942468f91253e9" translate="yes" xml:space="preserve">
          <source>Args::cmp</source>
          <target state="translated">Args::cmp</target>
        </trans-unit>
        <trans-unit id="48dd95fc8d6a07728f5a1cf7809d55524bf20034" translate="yes" xml:space="preserve">
          <source>Args::collect</source>
          <target state="translated">Args::collect</target>
        </trans-unit>
        <trans-unit id="9d0c9a3a72db97b3f6cab2b952f231796f20a50c" translate="yes" xml:space="preserve">
          <source>Args::copied</source>
          <target state="translated">Args::copied</target>
        </trans-unit>
        <trans-unit id="4fbeb4376f2e8b5f2155e6dbdec8f0740c8c04c9" translate="yes" xml:space="preserve">
          <source>Args::count</source>
          <target state="translated">Args::count</target>
        </trans-unit>
        <trans-unit id="4a06de4989ebe4016d146a0bb3c59a627e816965" translate="yes" xml:space="preserve">
          <source>Args::cycle</source>
          <target state="translated">Args::cycle</target>
        </trans-unit>
        <trans-unit id="dbd2a1eb1e566bd90b7919caa38a19ccb4685bdf" translate="yes" xml:space="preserve">
          <source>Args::enumerate</source>
          <target state="translated">Args::enumerate</target>
        </trans-unit>
        <trans-unit id="d22f2ebcc4f66631a8b99dffd5e42317b95a23c3" translate="yes" xml:space="preserve">
          <source>Args::eq</source>
          <target state="translated">Args::eq</target>
        </trans-unit>
        <trans-unit id="825fef0560348f1a6b9c4b27b6c58018c4f453ef" translate="yes" xml:space="preserve">
          <source>Args::filter</source>
          <target state="translated">Args::filter</target>
        </trans-unit>
        <trans-unit id="ab08ac4972fbd0c43add6cedcff53d5b9d40bc35" translate="yes" xml:space="preserve">
          <source>Args::filter_map</source>
          <target state="translated">Args::filter_map</target>
        </trans-unit>
        <trans-unit id="86056472eedb8eee7dbef63077919c7204cfa67b" translate="yes" xml:space="preserve">
          <source>Args::find</source>
          <target state="translated">Args::find</target>
        </trans-unit>
        <trans-unit id="e877bf0f63fb53fe48a38a7b49bdba91724d4dc9" translate="yes" xml:space="preserve">
          <source>Args::find_map</source>
          <target state="translated">Args::find_map</target>
        </trans-unit>
        <trans-unit id="09774b60a814c8b4104b1538a3d2232fe023f569" translate="yes" xml:space="preserve">
          <source>Args::flat_map</source>
          <target state="translated">Args::flat_map</target>
        </trans-unit>
        <trans-unit id="5eeb63d240af1b2ec0ce621fdcebe38dd652ee35" translate="yes" xml:space="preserve">
          <source>Args::flatten</source>
          <target state="translated">Args::flatten</target>
        </trans-unit>
        <trans-unit id="2824f41303961ce133138bbb9cdb7c73c49c034e" translate="yes" xml:space="preserve">
          <source>Args::fmt</source>
          <target state="translated">Args::fmt</target>
        </trans-unit>
        <trans-unit id="bdc321df53c7563363bb091073cc745371fec866" translate="yes" xml:space="preserve">
          <source>Args::fold</source>
          <target state="translated">Args::fold</target>
        </trans-unit>
        <trans-unit id="0bfb713bd78f482e7b1b8ccad2fb85c3059b45d0" translate="yes" xml:space="preserve">
          <source>Args::for_each</source>
          <target state="translated">Args::for_each</target>
        </trans-unit>
        <trans-unit id="bf62c774de1d7877320ea0fd8f640a1da6f668ae" translate="yes" xml:space="preserve">
          <source>Args::from</source>
          <target state="translated">Args::from</target>
        </trans-unit>
        <trans-unit id="4b2d02be4c99f1b285f809b3bada4d6e1d5de2c4" translate="yes" xml:space="preserve">
          <source>Args::fuse</source>
          <target state="translated">Args::fuse</target>
        </trans-unit>
        <trans-unit id="e9d47e65f07958eb4c539e9aa4794d4c91301d74" translate="yes" xml:space="preserve">
          <source>Args::ge</source>
          <target state="translated">Args::ge</target>
        </trans-unit>
        <trans-unit id="41716a498dc92ecead97571d6a7701faab3446af" translate="yes" xml:space="preserve">
          <source>Args::gt</source>
          <target state="translated">Args::gt</target>
        </trans-unit>
        <trans-unit id="ffe407b598fd64603f4cdfacf4c22332227c8373" translate="yes" xml:space="preserve">
          <source>Args::inspect</source>
          <target state="translated">Args::inspect</target>
        </trans-unit>
        <trans-unit id="4982b89e7bce55b901b94270e4e00a5ac09ba3e0" translate="yes" xml:space="preserve">
          <source>Args::into</source>
          <target state="translated">Args::into</target>
        </trans-unit>
        <trans-unit id="2fc7d02ccfe30c7d6decfb090f0a5dcabb2e0c43" translate="yes" xml:space="preserve">
          <source>Args::into_iter</source>
          <target state="translated">Args::into_iter</target>
        </trans-unit>
        <trans-unit id="0cc324954d5e5cfc9f0640a45fd39c06463171c8" translate="yes" xml:space="preserve">
          <source>Args::is_empty</source>
          <target state="translated">Args::is_empty</target>
        </trans-unit>
        <trans-unit id="9320ccfba6fb85da2cd8f4ea07146d9e90d55e69" translate="yes" xml:space="preserve">
          <source>Args::is_sorted</source>
          <target state="translated">Args::is_sorted</target>
        </trans-unit>
        <trans-unit id="18a7ac322b2479e407afbb8da7a0d6e559099523" translate="yes" xml:space="preserve">
          <source>Args::is_sorted_by</source>
          <target state="translated">Args::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="8d806d23a84355aca10dbfd0171313e44075d284" translate="yes" xml:space="preserve">
          <source>Args::is_sorted_by_key</source>
          <target state="translated">Args::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="c6efefb9b080afb608e934c39e299c62aaaa6fc0" translate="yes" xml:space="preserve">
          <source>Args::last</source>
          <target state="translated">Args::last</target>
        </trans-unit>
        <trans-unit id="04a547ce59955db8d408e3c98a9edc55fc1c82e5" translate="yes" xml:space="preserve">
          <source>Args::le</source>
          <target state="translated">Args::le</target>
        </trans-unit>
        <trans-unit id="f88c3621988f7c3fdb34fd16f1e9ea82cfbcea71" translate="yes" xml:space="preserve">
          <source>Args::len</source>
          <target state="translated">Args::len</target>
        </trans-unit>
        <trans-unit id="01c7bcbbd63e3d113fbbd64d77442cb638b835d1" translate="yes" xml:space="preserve">
          <source>Args::lt</source>
          <target state="translated">Args::lt</target>
        </trans-unit>
        <trans-unit id="039581be23b84f6e55f8a2add1bc6bfa811639f2" translate="yes" xml:space="preserve">
          <source>Args::map</source>
          <target state="translated">Args::map</target>
        </trans-unit>
        <trans-unit id="994f671b6e95e4ae34dd6e2c082281ea8ea61313" translate="yes" xml:space="preserve">
          <source>Args::max</source>
          <target state="translated">Args::max</target>
        </trans-unit>
        <trans-unit id="74a4e2d3f00af26f6a0ad2245e073d3b5a0cd3d2" translate="yes" xml:space="preserve">
          <source>Args::max_by</source>
          <target state="translated">Args::max_by</target>
        </trans-unit>
        <trans-unit id="deb310f6f85b56ebc7fe38e266f44493563fc6cf" translate="yes" xml:space="preserve">
          <source>Args::max_by_key</source>
          <target state="translated">Args::max_by_key</target>
        </trans-unit>
        <trans-unit id="dde4047d67a5b16733c51e9703c57fbdf575a4e4" translate="yes" xml:space="preserve">
          <source>Args::min</source>
          <target state="translated">Args::min</target>
        </trans-unit>
        <trans-unit id="403ed2480b700e9a65c715919e29b948e24f4b97" translate="yes" xml:space="preserve">
          <source>Args::min_by</source>
          <target state="translated">Args::min_by</target>
        </trans-unit>
        <trans-unit id="61041884b34bb5182aa5504e5448d5bac7a830ec" translate="yes" xml:space="preserve">
          <source>Args::min_by_key</source>
          <target state="translated">Args::min_by_key</target>
        </trans-unit>
        <trans-unit id="254900be5bd6dab1a3e1e8f2d8135ce517862048" translate="yes" xml:space="preserve">
          <source>Args::ne</source>
          <target state="translated">Args::ne</target>
        </trans-unit>
        <trans-unit id="d7cb929a8cedef153a932b274a4aba45b153fd66" translate="yes" xml:space="preserve">
          <source>Args::next</source>
          <target state="translated">Args::next</target>
        </trans-unit>
        <trans-unit id="2dcb9f5424d93dea8b755e44bed8488448308f48" translate="yes" xml:space="preserve">
          <source>Args::next_back</source>
          <target state="translated">Args::next_back</target>
        </trans-unit>
        <trans-unit id="7117eeb7949ae721ac3782d5eedc483a09ccac61" translate="yes" xml:space="preserve">
          <source>Args::nth</source>
          <target state="translated">Args::nth</target>
        </trans-unit>
        <trans-unit id="920bfede689288166976e1de3db01783fca343a2" translate="yes" xml:space="preserve">
          <source>Args::nth_back</source>
          <target state="translated">Args::nth_back</target>
        </trans-unit>
        <trans-unit id="827560f3761313e8fff14e1e90ac372f2bcfaccc" translate="yes" xml:space="preserve">
          <source>Args::partial_cmp</source>
          <target state="translated">Args::partial_cmp</target>
        </trans-unit>
        <trans-unit id="7fd69506fed5f2e3f675c8f01ed77c7a8573ed9f" translate="yes" xml:space="preserve">
          <source>Args::partition</source>
          <target state="translated">Args::partition</target>
        </trans-unit>
        <trans-unit id="0f80b2cd77c5343960cc6f37513564b206a6f770" translate="yes" xml:space="preserve">
          <source>Args::peekable</source>
          <target state="translated">Args::peekable</target>
        </trans-unit>
        <trans-unit id="d35d46b1d259e3d81a7c87e03f05934ae588d4a7" translate="yes" xml:space="preserve">
          <source>Args::position</source>
          <target state="translated">Args::position</target>
        </trans-unit>
        <trans-unit id="4ed9e8e605899d2c4c96340af8f07ac7b263210f" translate="yes" xml:space="preserve">
          <source>Args::product</source>
          <target state="translated">Args::product</target>
        </trans-unit>
        <trans-unit id="eb295f32cccde70f35d8df7df01c50708f27bd93" translate="yes" xml:space="preserve">
          <source>Args::rev</source>
          <target state="translated">Args::rev</target>
        </trans-unit>
        <trans-unit id="98d2de96a420de7658219d3f9bda5b24ca2443f7" translate="yes" xml:space="preserve">
          <source>Args::rfind</source>
          <target state="translated">Args::rfind</target>
        </trans-unit>
        <trans-unit id="3cc34e3e8eb1da327b82585d5a13fd8b2bb5890e" translate="yes" xml:space="preserve">
          <source>Args::rfold</source>
          <target state="translated">Args::rfold</target>
        </trans-unit>
        <trans-unit id="3a7a7236e75fdfae5572db48f2aad6e6378da2eb" translate="yes" xml:space="preserve">
          <source>Args::rposition</source>
          <target state="translated">Args::rposition</target>
        </trans-unit>
        <trans-unit id="9fc0f79d5cd6405747d8f5be32af5064749f81b9" translate="yes" xml:space="preserve">
          <source>Args::scan</source>
          <target state="translated">Args::scan</target>
        </trans-unit>
        <trans-unit id="12148001c865165a5de07ba3c727c97aab92c761" translate="yes" xml:space="preserve">
          <source>Args::size_hint</source>
          <target state="translated">Args::size_hint</target>
        </trans-unit>
        <trans-unit id="1189df09a529d4be32c97dfca9793d84611fd824" translate="yes" xml:space="preserve">
          <source>Args::skip</source>
          <target state="translated">Args::skip</target>
        </trans-unit>
        <trans-unit id="764acccc052619da2c47813fd259dab289d9bd67" translate="yes" xml:space="preserve">
          <source>Args::skip_while</source>
          <target state="translated">Args::skip_while</target>
        </trans-unit>
        <trans-unit id="904035ea6ead93ad6bd21ffe6010b797797cfccb" translate="yes" xml:space="preserve">
          <source>Args::step_by</source>
          <target state="translated">Args::step_by</target>
        </trans-unit>
        <trans-unit id="d5a7f219c1fc0a0f719ef62e5e91b056ae17a132" translate="yes" xml:space="preserve">
          <source>Args::sum</source>
          <target state="translated">Args::sum</target>
        </trans-unit>
        <trans-unit id="27af1223e3252d8316e5510ef65c11dd18e7e048" translate="yes" xml:space="preserve">
          <source>Args::take</source>
          <target state="translated">Args::take</target>
        </trans-unit>
        <trans-unit id="70510b85e050ccfd0ca156b8552398d830c8ca29" translate="yes" xml:space="preserve">
          <source>Args::take_while</source>
          <target state="translated">Args::take_while</target>
        </trans-unit>
        <trans-unit id="29671ebf88bfe467b330af20810dd95f14bee716" translate="yes" xml:space="preserve">
          <source>Args::try_fold</source>
          <target state="translated">Args::try_fold</target>
        </trans-unit>
        <trans-unit id="11314668861a5fe3812661a0778a42dd4d60ecc6" translate="yes" xml:space="preserve">
          <source>Args::try_for_each</source>
          <target state="translated">Args::try_for_each</target>
        </trans-unit>
        <trans-unit id="a3e7a43251306d98977b3648cb61a36b6b67f71f" translate="yes" xml:space="preserve">
          <source>Args::try_from</source>
          <target state="translated">Args::try_from</target>
        </trans-unit>
        <trans-unit id="ea7b4151424c750739941030cbfa813500f83861" translate="yes" xml:space="preserve">
          <source>Args::try_into</source>
          <target state="translated">Args::try_into</target>
        </trans-unit>
        <trans-unit id="a09bc59807578d3bfcb3f5e6f7f7b11ca71a5fda" translate="yes" xml:space="preserve">
          <source>Args::try_rfold</source>
          <target state="translated">Args::try_rfold</target>
        </trans-unit>
        <trans-unit id="ef5ea75da51804787206df18b378f5490fe6418b" translate="yes" xml:space="preserve">
          <source>Args::type_id</source>
          <target state="translated">Args::type_id</target>
        </trans-unit>
        <trans-unit id="3e828aa1b5449d683bef869c26ce0986ec45e670" translate="yes" xml:space="preserve">
          <source>Args::unzip</source>
          <target state="translated">Args::unzip</target>
        </trans-unit>
        <trans-unit id="468f2b4280fd073d79df60860923a06807813556" translate="yes" xml:space="preserve">
          <source>Args::zip</source>
          <target state="translated">Args::zip</target>
        </trans-unit>
        <trans-unit id="08a635e24e7197ec936245f74886d0fae256f6f3" translate="yes" xml:space="preserve">
          <source>ArgsOs</source>
          <target state="translated">ArgsOs</target>
        </trans-unit>
        <trans-unit id="1699d7288d57eee287607a5a8cf4daa06cbf36b5" translate="yes" xml:space="preserve">
          <source>ArgsOs::all</source>
          <target state="translated">ArgsOs::all</target>
        </trans-unit>
        <trans-unit id="1845d364695de9046a1a2e308d836950518c8379" translate="yes" xml:space="preserve">
          <source>ArgsOs::any</source>
          <target state="translated">ArgsOs::any</target>
        </trans-unit>
        <trans-unit id="b88db8b95877207b42c5e88cfc5b222b32d38f42" translate="yes" xml:space="preserve">
          <source>ArgsOs::borrow</source>
          <target state="translated">ArgsOs::borrow</target>
        </trans-unit>
        <trans-unit id="6883c744eb4014b5c2b448f2adc1b25a04e5fc9e" translate="yes" xml:space="preserve">
          <source>ArgsOs::borrow_mut</source>
          <target state="translated">ArgsOs::borrow_mut</target>
        </trans-unit>
        <trans-unit id="54a7160bba6f31fb20a2a3b6f79944613335629e" translate="yes" xml:space="preserve">
          <source>ArgsOs::by_ref</source>
          <target state="translated">ArgsOs::by_ref</target>
        </trans-unit>
        <trans-unit id="45e9d062b28c81d2586823abf5265cf79f0f53c3" translate="yes" xml:space="preserve">
          <source>ArgsOs::chain</source>
          <target state="translated">ArgsOs::chain</target>
        </trans-unit>
        <trans-unit id="06a86328c3295b9577a55fd6532e3d512a4376ad" translate="yes" xml:space="preserve">
          <source>ArgsOs::cloned</source>
          <target state="translated">ArgsOs::cloned</target>
        </trans-unit>
        <trans-unit id="aa33a26c7a85d39e633ece2b7ab215364fa8c21f" translate="yes" xml:space="preserve">
          <source>ArgsOs::cmp</source>
          <target state="translated">ArgsOs::cmp</target>
        </trans-unit>
        <trans-unit id="4444bf776c1fcbbef6e3005b548a29289b32ecc4" translate="yes" xml:space="preserve">
          <source>ArgsOs::collect</source>
          <target state="translated">ArgsOs::collect</target>
        </trans-unit>
        <trans-unit id="efa527796ad53e7b95c87dfbab81f527bd59777a" translate="yes" xml:space="preserve">
          <source>ArgsOs::copied</source>
          <target state="translated">ArgsOs::copied</target>
        </trans-unit>
        <trans-unit id="cf8617f607b90e848c8eda2dcecf733646bd740b" translate="yes" xml:space="preserve">
          <source>ArgsOs::count</source>
          <target state="translated">ArgsOs::count</target>
        </trans-unit>
        <trans-unit id="9774f0ee5373559d8ebaf6e270d32276c2460f0f" translate="yes" xml:space="preserve">
          <source>ArgsOs::cycle</source>
          <target state="translated">ArgsOs::cycle</target>
        </trans-unit>
        <trans-unit id="0c42cc7e9e0e5f5dcbc76f351e7fb1817634bb40" translate="yes" xml:space="preserve">
          <source>ArgsOs::enumerate</source>
          <target state="translated">ArgsOs::enumerate</target>
        </trans-unit>
        <trans-unit id="d5b0b5b450101b6daed6089615021285ab2aa9bc" translate="yes" xml:space="preserve">
          <source>ArgsOs::eq</source>
          <target state="translated">ArgsOs::eq</target>
        </trans-unit>
        <trans-unit id="22ebb6f40c3d512ac39613bf4969beaa463bb89c" translate="yes" xml:space="preserve">
          <source>ArgsOs::filter</source>
          <target state="translated">ArgsOs::filter</target>
        </trans-unit>
        <trans-unit id="ec9b19d64b96da14ed417d0d212d3d54ea4a4759" translate="yes" xml:space="preserve">
          <source>ArgsOs::filter_map</source>
          <target state="translated">ArgsOs::filter_map</target>
        </trans-unit>
        <trans-unit id="f90d91bcb86730d9c77f4746181813b55b242a5f" translate="yes" xml:space="preserve">
          <source>ArgsOs::find</source>
          <target state="translated">ArgsOs::find</target>
        </trans-unit>
        <trans-unit id="8c42c2da49296751bd09d90e62d79798dd8f5449" translate="yes" xml:space="preserve">
          <source>ArgsOs::find_map</source>
          <target state="translated">ArgsOs::find_map</target>
        </trans-unit>
        <trans-unit id="8ae8230900a56717520df737b9d2946aa58958f4" translate="yes" xml:space="preserve">
          <source>ArgsOs::flat_map</source>
          <target state="translated">ArgsOs::flat_map</target>
        </trans-unit>
        <trans-unit id="582b0a8882844e707b1b16686981fe8a3215c0f7" translate="yes" xml:space="preserve">
          <source>ArgsOs::flatten</source>
          <target state="translated">ArgsOs::flatten</target>
        </trans-unit>
        <trans-unit id="42a3165a3645e00a5c082e56522288eb3545955a" translate="yes" xml:space="preserve">
          <source>ArgsOs::fmt</source>
          <target state="translated">ArgsOs::fmt</target>
        </trans-unit>
        <trans-unit id="c973a490f8d75776d7cc21ebc26d8640412d8da5" translate="yes" xml:space="preserve">
          <source>ArgsOs::fold</source>
          <target state="translated">ArgsOs::fold</target>
        </trans-unit>
        <trans-unit id="521243a10a5ee6932b3c00a38bb64a1066346423" translate="yes" xml:space="preserve">
          <source>ArgsOs::for_each</source>
          <target state="translated">ArgsOs::for_each</target>
        </trans-unit>
        <trans-unit id="b3beb1c32ac134bd58a5525cb75b6818caadc2e7" translate="yes" xml:space="preserve">
          <source>ArgsOs::from</source>
          <target state="translated">ArgsOs::from</target>
        </trans-unit>
        <trans-unit id="0467b6e7a5907960746adb88f1797855273e5e38" translate="yes" xml:space="preserve">
          <source>ArgsOs::fuse</source>
          <target state="translated">ArgsOs::fuse</target>
        </trans-unit>
        <trans-unit id="8d918573a70aed631b8ef7e464f6978aeac45512" translate="yes" xml:space="preserve">
          <source>ArgsOs::ge</source>
          <target state="translated">ArgsOs::ge</target>
        </trans-unit>
        <trans-unit id="ed7bd18154ad5939e8306b095fe2d6551d9c5960" translate="yes" xml:space="preserve">
          <source>ArgsOs::gt</source>
          <target state="translated">ArgsOs::gt</target>
        </trans-unit>
        <trans-unit id="f6ab996f18c666c657723e3d6b826e9d4f34afa4" translate="yes" xml:space="preserve">
          <source>ArgsOs::inspect</source>
          <target state="translated">ArgsOs::inspect</target>
        </trans-unit>
        <trans-unit id="118a0e4c62985069de5d564f7e5aeaefdb4f3eee" translate="yes" xml:space="preserve">
          <source>ArgsOs::into</source>
          <target state="translated">ArgsOs::into</target>
        </trans-unit>
        <trans-unit id="6fe469f351f3d71c45f5b8b8a01a85ba417f2962" translate="yes" xml:space="preserve">
          <source>ArgsOs::into_iter</source>
          <target state="translated">ArgsOs::into_iter</target>
        </trans-unit>
        <trans-unit id="52e21117a73746309084ded1b85082f14e2f4f3c" translate="yes" xml:space="preserve">
          <source>ArgsOs::is_empty</source>
          <target state="translated">ArgsOs::is_empty</target>
        </trans-unit>
        <trans-unit id="bc22f51d728c32072e58dab02dc3f74a273221da" translate="yes" xml:space="preserve">
          <source>ArgsOs::is_sorted</source>
          <target state="translated">ArgsOs::is_sorted</target>
        </trans-unit>
        <trans-unit id="6ce480c601285e3d630fdd46e557dfb3c792fc47" translate="yes" xml:space="preserve">
          <source>ArgsOs::is_sorted_by</source>
          <target state="translated">ArgsOs::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="1bd6484be8e79119af4f357c6727e9cce127bfb7" translate="yes" xml:space="preserve">
          <source>ArgsOs::is_sorted_by_key</source>
          <target state="translated">ArgsOs::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="2960d55410634dcaa01ebfd4efb87d3210b4b30b" translate="yes" xml:space="preserve">
          <source>ArgsOs::last</source>
          <target state="translated">ArgsOs::last</target>
        </trans-unit>
        <trans-unit id="49cd1005a59ab868a13fc3b698fa037af9e3cc25" translate="yes" xml:space="preserve">
          <source>ArgsOs::le</source>
          <target state="translated">ArgsOs::le</target>
        </trans-unit>
        <trans-unit id="9662bed516b84aec77303964e4aba365d517a6ce" translate="yes" xml:space="preserve">
          <source>ArgsOs::len</source>
          <target state="translated">ArgsOs::len</target>
        </trans-unit>
        <trans-unit id="a4fd3a509313cc726b4eb5e364e66dd0311cbccc" translate="yes" xml:space="preserve">
          <source>ArgsOs::lt</source>
          <target state="translated">ArgsOs::lt</target>
        </trans-unit>
        <trans-unit id="b4ee6f488be886ab0828730edfa187e1158ffbf4" translate="yes" xml:space="preserve">
          <source>ArgsOs::map</source>
          <target state="translated">ArgsOs::map</target>
        </trans-unit>
        <trans-unit id="ae8b8dee55299bdeb6e240152d7d260302e580f0" translate="yes" xml:space="preserve">
          <source>ArgsOs::max</source>
          <target state="translated">ArgsOs::max</target>
        </trans-unit>
        <trans-unit id="f393dc70d5755703ad87bcd703e01acde42fd52e" translate="yes" xml:space="preserve">
          <source>ArgsOs::max_by</source>
          <target state="translated">ArgsOs::max_by</target>
        </trans-unit>
        <trans-unit id="c3d12b23ad084b94bc1bb5877f3a0e669b6dcbe5" translate="yes" xml:space="preserve">
          <source>ArgsOs::max_by_key</source>
          <target state="translated">ArgsOs::max_by_key</target>
        </trans-unit>
        <trans-unit id="1877909fb92070e732d578d5a61015d6567d1c05" translate="yes" xml:space="preserve">
          <source>ArgsOs::min</source>
          <target state="translated">ArgsOs::min</target>
        </trans-unit>
        <trans-unit id="1b9560ee3684ef678a7f2060396e14192ebd977a" translate="yes" xml:space="preserve">
          <source>ArgsOs::min_by</source>
          <target state="translated">ArgsOs::min_by</target>
        </trans-unit>
        <trans-unit id="ce07e6453a52864ecbf5f176d284c9622c84c927" translate="yes" xml:space="preserve">
          <source>ArgsOs::min_by_key</source>
          <target state="translated">ArgsOs::min_by_key</target>
        </trans-unit>
        <trans-unit id="77abc8099c1b361ea642538729c1cfa9c4ad2af8" translate="yes" xml:space="preserve">
          <source>ArgsOs::ne</source>
          <target state="translated">ArgsOs::ne</target>
        </trans-unit>
        <trans-unit id="94df206ce16974feea2fee745eeb9bededb98233" translate="yes" xml:space="preserve">
          <source>ArgsOs::next</source>
          <target state="translated">ArgsOs::next</target>
        </trans-unit>
        <trans-unit id="0b4bd6a54c1bdb1cb1c37909c4bbdf8ee8eedba4" translate="yes" xml:space="preserve">
          <source>ArgsOs::next_back</source>
          <target state="translated">ArgsOs::next_back</target>
        </trans-unit>
        <trans-unit id="32001a37fe7fa6c38a9dab6e3ccac83215a6af0b" translate="yes" xml:space="preserve">
          <source>ArgsOs::nth</source>
          <target state="translated">ArgsOs::nth</target>
        </trans-unit>
        <trans-unit id="eed0fe5e0346646ed8f493e45f87707e6ef665d0" translate="yes" xml:space="preserve">
          <source>ArgsOs::nth_back</source>
          <target state="translated">ArgsOs::nth_back</target>
        </trans-unit>
        <trans-unit id="76d2262b3586a0b114f133d396c15e36cdbd64ee" translate="yes" xml:space="preserve">
          <source>ArgsOs::partial_cmp</source>
          <target state="translated">ArgsOs::partial_cmp</target>
        </trans-unit>
        <trans-unit id="c88ee3f44d1aaf87a7e7075664272abea7e57c22" translate="yes" xml:space="preserve">
          <source>ArgsOs::partition</source>
          <target state="translated">ArgsOs::partition</target>
        </trans-unit>
        <trans-unit id="b772163bfba047ed1ad9679588037cc0b2a982a9" translate="yes" xml:space="preserve">
          <source>ArgsOs::peekable</source>
          <target state="translated">ArgsOs::peekable</target>
        </trans-unit>
        <trans-unit id="28f42c15452e45ff29cd38077309d81cd1bf23ef" translate="yes" xml:space="preserve">
          <source>ArgsOs::position</source>
          <target state="translated">ArgsOs::position</target>
        </trans-unit>
        <trans-unit id="9c54799fe9d66e9fe809d53c0ad35f91d0345b2d" translate="yes" xml:space="preserve">
          <source>ArgsOs::product</source>
          <target state="translated">ArgsOs::product</target>
        </trans-unit>
        <trans-unit id="24d0c67c7635532e04027af92577d329d52e0d8d" translate="yes" xml:space="preserve">
          <source>ArgsOs::rev</source>
          <target state="translated">ArgsOs::rev</target>
        </trans-unit>
        <trans-unit id="9a893fd65a1fd7e4f90c4c16dad18ae09e1e6440" translate="yes" xml:space="preserve">
          <source>ArgsOs::rfind</source>
          <target state="translated">ArgsOs::rfind</target>
        </trans-unit>
        <trans-unit id="2473c6d05109d83b7921dc7c8d9e3fd3e1540366" translate="yes" xml:space="preserve">
          <source>ArgsOs::rfold</source>
          <target state="translated">ArgsOs::rfold</target>
        </trans-unit>
        <trans-unit id="61e2d2493b8b480b1c184877bc7c4508f85f3e68" translate="yes" xml:space="preserve">
          <source>ArgsOs::rposition</source>
          <target state="translated">ArgsOs::rposition</target>
        </trans-unit>
        <trans-unit id="f7c9d7d4183c0e1185d8f756359b7aa52e99dec6" translate="yes" xml:space="preserve">
          <source>ArgsOs::scan</source>
          <target state="translated">ArgsOs::scan</target>
        </trans-unit>
        <trans-unit id="be9f72e6896d64043f92118bf0351dd06875451e" translate="yes" xml:space="preserve">
          <source>ArgsOs::size_hint</source>
          <target state="translated">ArgsOs::size_hint</target>
        </trans-unit>
        <trans-unit id="dfcbf514097e12c73f97a48d644499d52e01f449" translate="yes" xml:space="preserve">
          <source>ArgsOs::skip</source>
          <target state="translated">ArgsOs::skip</target>
        </trans-unit>
        <trans-unit id="b5cea38564a840936b5adf617a54cb9e1705e9a4" translate="yes" xml:space="preserve">
          <source>ArgsOs::skip_while</source>
          <target state="translated">ArgsOs::skip_while</target>
        </trans-unit>
        <trans-unit id="bd31eff15f1513280f3660b278f44b8403fe5bb7" translate="yes" xml:space="preserve">
          <source>ArgsOs::step_by</source>
          <target state="translated">ArgsOs::step_by</target>
        </trans-unit>
        <trans-unit id="b896b50f4e9946df9f811558add55e6c7f4d9c0e" translate="yes" xml:space="preserve">
          <source>ArgsOs::sum</source>
          <target state="translated">ArgsOs::sum</target>
        </trans-unit>
        <trans-unit id="55f7ee9ef7a277d1da50d3847c5267d10c02f3d6" translate="yes" xml:space="preserve">
          <source>ArgsOs::take</source>
          <target state="translated">ArgsOs::take</target>
        </trans-unit>
        <trans-unit id="67ae1d83993d54c201cebc7e961a4745875403a9" translate="yes" xml:space="preserve">
          <source>ArgsOs::take_while</source>
          <target state="translated">ArgsOs::take_while</target>
        </trans-unit>
        <trans-unit id="6feaa7bb16a2f86b2de35c4152c898840e5c73a7" translate="yes" xml:space="preserve">
          <source>ArgsOs::try_fold</source>
          <target state="translated">ArgsOs::try_fold</target>
        </trans-unit>
        <trans-unit id="4de4927e12902d929342841a0f0a05adc02a2b88" translate="yes" xml:space="preserve">
          <source>ArgsOs::try_for_each</source>
          <target state="translated">ArgsOs::try_for_each</target>
        </trans-unit>
        <trans-unit id="ef2e8777c2c6780af369e18d8923c4a5b07b73cc" translate="yes" xml:space="preserve">
          <source>ArgsOs::try_from</source>
          <target state="translated">ArgsOs::try_from</target>
        </trans-unit>
        <trans-unit id="dde21f1986a82cfe6d32ebda71aaf8cffb865725" translate="yes" xml:space="preserve">
          <source>ArgsOs::try_into</source>
          <target state="translated">ArgsOs::try_into</target>
        </trans-unit>
        <trans-unit id="752061f583e2a023f82e25f293fbc12638874e24" translate="yes" xml:space="preserve">
          <source>ArgsOs::try_rfold</source>
          <target state="translated">ArgsOs::try_rfold</target>
        </trans-unit>
        <trans-unit id="9cea18d9f52cf4e66c35caae6f3a3d7426f8ebf1" translate="yes" xml:space="preserve">
          <source>ArgsOs::type_id</source>
          <target state="translated">ArgsOs::type_id</target>
        </trans-unit>
        <trans-unit id="dcc7a51ed1d3dac6d37f7b6f7415fe425b54aac1" translate="yes" xml:space="preserve">
          <source>ArgsOs::unzip</source>
          <target state="translated">ArgsOs::unzip</target>
        </trans-unit>
        <trans-unit id="0477d6e4f174e07114d3143d029569031152c407" translate="yes" xml:space="preserve">
          <source>ArgsOs::zip</source>
          <target state="translated">ArgsOs::zip</target>
        </trans-unit>
        <trans-unit id="bd7faaad666e01c1bc85c0559542193db97f87bb" translate="yes" xml:space="preserve">
          <source>Argument and element separator</source>
          <target state="translated">引数と要素のセパレータ</target>
        </trans-unit>
        <trans-unit id="0e653d9296c0f3183cfcfa59576a82649ae7862d" translate="yes" xml:space="preserve">
          <source>Argument types</source>
          <target state="translated">引数の種類</target>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="a3115a849e9a8fd08f66c020b31248aefac3bb62" translate="yes" xml:space="preserve">
          <source>Arguments for function calls</source>
          <target state="translated">関数呼び出しの引数</target>
        </trans-unit>
        <trans-unit id="599f9cef30e51c86c0307365f585d93f4615d4d0" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;map_or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;enum.option#method.map_or_else&quot;&gt;&lt;code&gt;map_or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="translated">&lt;code&gt;map_or&lt;/code&gt; に渡された引数は、熱心に評価されます。関数呼び出しの結果を渡す場合は、遅延評価される&lt;a href=&quot;enum.option#method.map_or_else&quot;&gt; &lt;code&gt;map_or_else&lt;/code&gt; &lt;/a&gt;を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="f0b13e1e9de1f734ef5d809e601926031419d1d8" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;map_or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;enum.result#method.map_or_else&quot;&gt;&lt;code&gt;map_or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="translated">&lt;code&gt;map_or&lt;/code&gt; に渡された引数は、熱心に評価されます。関数呼び出しの結果を渡す場合は、遅延評価される&lt;a href=&quot;enum.result#method.map_or_else&quot;&gt; &lt;code&gt;map_or_else&lt;/code&gt; &lt;/a&gt;を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="60b48e4141151169e113485ecab80a4bb3c30bdc" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;ok_or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;#method.ok_or_else&quot;&gt;&lt;code&gt;ok_or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="translated">&lt;code&gt;ok_or&lt;/code&gt; に渡される引数は熱心に評価されます。関数呼び出しの結果を渡す場合は、&lt;a href=&quot;#method.ok_or_else&quot;&gt; &lt;code&gt;ok_or_else&lt;/code&gt; &lt;/a&gt;を使用することをお勧めしますは、遅延評価される。</target>
        </trans-unit>
        <trans-unit id="c72e63e8acf76e2210299bb8523a4d987e02e598" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;ok_or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;enum.option#method.ok_or_else&quot;&gt;&lt;code&gt;ok_or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="translated">&lt;code&gt;ok_or&lt;/code&gt; に渡された引数は、熱心に評価されます。関数呼び出しの結果を渡す場合は、遅延評価される&lt;a href=&quot;enum.option#method.ok_or_else&quot;&gt; &lt;code&gt;ok_or_else&lt;/code&gt; &lt;/a&gt;を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="b34ba4a25e5cb9253c52e9c96f12b4a3b5b442c1" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;#method.or_else&quot;&gt;&lt;code&gt;or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="translated">渡された、 &lt;code&gt;or&lt;/code&gt; 熱心に評価される引数。関数呼び出しの結果を渡す場合は、遅延評価される&lt;a href=&quot;#method.or_else&quot;&gt; &lt;code&gt;or_else&lt;/code&gt; &lt;/a&gt;を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="e8e3ad3f9d440f41a4bced3ec981aa2d05bd534c" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;enum.option#method.or_else&quot;&gt;&lt;code&gt;or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="translated">渡された、 &lt;code&gt;or&lt;/code&gt; 熱心に評価された引数。関数呼び出しの結果を渡す場合は、遅延評価される&lt;a href=&quot;enum.option#method.or_else&quot;&gt; &lt;code&gt;or_else&lt;/code&gt; &lt;/a&gt;を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="3fb2e5d47e33897712d4dff15280a3a0c997b492" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;enum.result#method.or_else&quot;&gt;&lt;code&gt;or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="translated">渡された、 &lt;code&gt;or&lt;/code&gt; 熱心に評価された引数。関数呼び出しの結果を渡す場合は、遅延評価される&lt;a href=&quot;enum.result#method.or_else&quot;&gt; &lt;code&gt;or_else&lt;/code&gt; &lt;/a&gt;を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="81e7e0f40306bc29fb2793ce221652d077995d0b" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;unwrap_or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;#method.unwrap_or_else&quot;&gt;&lt;code&gt;unwrap_or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="translated">&lt;code&gt;unwrap_or&lt;/code&gt; に渡される引数は熱心に評価されます。関数呼び出しの結果を渡す場合は、遅延評価される&lt;a href=&quot;#method.unwrap_or_else&quot;&gt; &lt;code&gt;unwrap_or_else&lt;/code&gt; &lt;/a&gt;を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="15ac6e3ce55f8f212059dc3a36cc981d9be8aca1" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;unwrap_or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;enum.option#method.unwrap_or_else&quot;&gt;&lt;code&gt;unwrap_or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="translated">&lt;code&gt;unwrap_or&lt;/code&gt; に渡された引数は、熱心に評価されます。関数呼び出しの結果を渡す場合は、遅延評価される&lt;a href=&quot;enum.option#method.unwrap_or_else&quot;&gt; &lt;code&gt;unwrap_or_else&lt;/code&gt; &lt;/a&gt;を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="935c37b281819663d093edd0e6a0df21fc148074" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;unwrap_or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;enum.result#method.unwrap_or_else&quot;&gt;&lt;code&gt;unwrap_or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="translated">&lt;code&gt;unwrap_or&lt;/code&gt; に渡された引数は、熱心に評価されます。関数呼び出しの結果を渡す場合は、遅延評価される&lt;a href=&quot;enum.result#method.unwrap_or_else&quot;&gt; &lt;code&gt;unwrap_or_else&lt;/code&gt; &lt;/a&gt;を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="ca682bb604cd951faf7e687e9dc577ccfb4ccbcc" translate="yes" xml:space="preserve">
          <source>Arguments::borrow</source>
          <target state="translated">Arguments::borrow</target>
        </trans-unit>
        <trans-unit id="02b0d59380fa1adbbfa0a4e488839d014c6a84b9" translate="yes" xml:space="preserve">
          <source>Arguments::borrow_mut</source>
          <target state="translated">Arguments::borrow_mut</target>
        </trans-unit>
        <trans-unit id="beee63977406683694c63c877a281368e8498185" translate="yes" xml:space="preserve">
          <source>Arguments::clone</source>
          <target state="translated">Arguments::clone</target>
        </trans-unit>
        <trans-unit id="9b4336ed72fcc8790d465ff622f1ee33ef64dd5f" translate="yes" xml:space="preserve">
          <source>Arguments::clone_from</source>
          <target state="translated">Arguments::clone_from</target>
        </trans-unit>
        <trans-unit id="9f534ce31b28796358e33f058c8f30771441c413" translate="yes" xml:space="preserve">
          <source>Arguments::clone_into</source>
          <target state="translated">Arguments::clone_into</target>
        </trans-unit>
        <trans-unit id="e2264984672013569ff3cb5667d1fb059d3a9aff" translate="yes" xml:space="preserve">
          <source>Arguments::fmt</source>
          <target state="translated">Arguments::fmt</target>
        </trans-unit>
        <trans-unit id="e6967e42010df585387f1e1ee0a1ddd2861644a6" translate="yes" xml:space="preserve">
          <source>Arguments::from</source>
          <target state="translated">Arguments::from</target>
        </trans-unit>
        <trans-unit id="f7110cbfaa9d19f7a1a5d2f96c337419907bb156" translate="yes" xml:space="preserve">
          <source>Arguments::into</source>
          <target state="translated">Arguments::into</target>
        </trans-unit>
        <trans-unit id="f71fad745c8ecba4adbbf940ce0a934c1bbb9409" translate="yes" xml:space="preserve">
          <source>Arguments::to_owned</source>
          <target state="translated">Arguments::to_owned</target>
        </trans-unit>
        <trans-unit id="2f1106daf75575ebf9ff5096d88d4bd32bee8e3a" translate="yes" xml:space="preserve">
          <source>Arguments::to_string</source>
          <target state="translated">Arguments::to_string</target>
        </trans-unit>
        <trans-unit id="44514fad8f521c67acba588fe00d7592016a908f" translate="yes" xml:space="preserve">
          <source>Arguments::try_from</source>
          <target state="translated">Arguments::try_from</target>
        </trans-unit>
        <trans-unit id="8bb902c723ba932ded5aa3da8d68330e0bd8dfdd" translate="yes" xml:space="preserve">
          <source>Arguments::try_into</source>
          <target state="translated">Arguments::try_into</target>
        </trans-unit>
        <trans-unit id="93c384146f511c59251c10079f21618fcc345340" translate="yes" xml:space="preserve">
          <source>Arguments::type_id</source>
          <target state="translated">Arguments::type_id</target>
        </trans-unit>
        <trans-unit id="52ed5399cec328eed1c4d10b234f6d54945d8379" translate="yes" xml:space="preserve">
          <source>Arithmetic addition</source>
          <target state="translated">算術加算</target>
        </trans-unit>
        <trans-unit id="b6a2b173c28c2d32e0f07c5865706f1a0af1dc82" translate="yes" xml:space="preserve">
          <source>Arithmetic addition and assignment</source>
          <target state="translated">算数の足し算と代入</target>
        </trans-unit>
        <trans-unit id="481206dd7e4055d67971a43266f17dd6c8acf74d" translate="yes" xml:space="preserve">
          <source>Arithmetic and Logical Binary Operators</source>
          <target state="translated">算術演算子と論理二項演算子</target>
        </trans-unit>
        <trans-unit id="ba8c163933eb964b78854dfa7b1e1313a4ece109" translate="yes" xml:space="preserve">
          <source>Arithmetic and comparison operators on integers</source>
          <target state="translated">整数上の算術演算子と比較演算子</target>
        </trans-unit>
        <trans-unit id="3a2ccea0b8aef06fcf5a90ab7c705782be897b40" translate="yes" xml:space="preserve">
          <source>Arithmetic division</source>
          <target state="translated">算術分割</target>
        </trans-unit>
        <trans-unit id="dfc8f592565726eb9a5251995ebe9c35af2683f2" translate="yes" xml:space="preserve">
          <source>Arithmetic division and assignment</source>
          <target state="translated">算術の除算と代入</target>
        </trans-unit>
        <trans-unit id="5e0f6d1b7afc18895e08ec06673e25445eca9bd9" translate="yes" xml:space="preserve">
          <source>Arithmetic multiplication</source>
          <target state="translated">算術の掛け算</target>
        </trans-unit>
        <trans-unit id="aed641007b737ba787b84c11db1a76f81a7265ec" translate="yes" xml:space="preserve">
          <source>Arithmetic multiplication and assignment</source>
          <target state="translated">算数の掛け算と代入</target>
        </trans-unit>
        <trans-unit id="9501694b83625ba1c4c32e0300c7e3ef0ea5895a" translate="yes" xml:space="preserve">
          <source>Arithmetic negation</source>
          <target state="translated">算術否定</target>
        </trans-unit>
        <trans-unit id="4b7e345ffd8cb02b4c25248f3c2916dd526e2269" translate="yes" xml:space="preserve">
          <source>Arithmetic remainder</source>
          <target state="translated">算術残数</target>
        </trans-unit>
        <trans-unit id="4af14fe332c2fec7e550537a659d27f7672cf52b" translate="yes" xml:space="preserve">
          <source>Arithmetic remainder and assignment</source>
          <target state="translated">算術の余白と代入</target>
        </trans-unit>
        <trans-unit id="54604a8945847efcfbb8925458787851115f9296" translate="yes" xml:space="preserve">
          <source>Arithmetic subtraction</source>
          <target state="translated">算術減算</target>
        </trans-unit>
        <trans-unit id="40c2d180ceb1daebfda27a7dc052bf6e18437123" translate="yes" xml:space="preserve">
          <source>Arithmetic subtraction and assignment</source>
          <target state="translated">算数の引き算と代入</target>
        </trans-unit>
        <trans-unit id="9d9b31e17e60151ad825cdde7693ca0fcca238c9" translate="yes" xml:space="preserve">
          <source>Arity</source>
          <target state="translated">Arity</target>
        </trans-unit>
        <trans-unit id="1fd516c87a7c389dccca9649a7b656d2f047d85d" translate="yes" xml:space="preserve">
          <source>Arity refers to the number of arguments a function or operator takes. For some examples, &lt;code&gt;f(2, 3)&lt;/code&gt; and &lt;code&gt;g(4, 6)&lt;/code&gt; have arity 2, while &lt;code&gt;h(8, 2, 6)&lt;/code&gt; has arity 3. The &lt;code&gt;!&lt;/code&gt; operator has arity 1.</source>
          <target state="translated">アリティは、関数または演算子が取る引数の数を指します。いくつかの例として、 &lt;code&gt;f(2, 3)&lt;/code&gt; 及び &lt;code&gt;g(4, 6)&lt;/code&gt; しながら、アリティ2を持っている &lt;code&gt;h(8, 2, 6)&lt;/code&gt; アリティ3.有します &lt;code&gt;!&lt;/code&gt; オペレーターはアリティ1を持っています。</target>
        </trans-unit>
        <trans-unit id="107004472b7ba4e5e31f3082ee1fb5a1239eec61" translate="yes" xml:space="preserve">
          <source>Array</source>
          <target state="translated">Array</target>
        </trans-unit>
        <trans-unit id="e88a1d916bd09fa0781281dd0639410541b1c200" translate="yes" xml:space="preserve">
          <source>Array Layout</source>
          <target state="translated">配列レイアウト</target>
        </trans-unit>
        <trans-unit id="811e7deb41b753134a124c771bc129d2aad4f69f" translate="yes" xml:space="preserve">
          <source>Array and array index expressions</source>
          <target state="translated">配列と配列インデックス式</target>
        </trans-unit>
        <trans-unit id="0844515b5a634fa1753332ae502ec5bc059c9bf4" translate="yes" xml:space="preserve">
          <source>Array and slice indexing expressions</source>
          <target state="translated">配列とスライスのインデキシング式</target>
        </trans-unit>
        <trans-unit id="1c901b7185d5b71317418dac8afa7a9edb10a639" translate="yes" xml:space="preserve">
          <source>Array expression attributes</source>
          <target state="translated">配列式の属性</target>
        </trans-unit>
        <trans-unit id="ff659441b84e2964045ca09a8c18a08d44b84a61" translate="yes" xml:space="preserve">
          <source>Array expressions</source>
          <target state="translated">配列表現</target>
        </trans-unit>
        <trans-unit id="b4a857fc21bf592938e9dd2ec1d467878b6cf83e" translate="yes" xml:space="preserve">
          <source>Array literal</source>
          <target state="translated">配列リテラル</target>
        </trans-unit>
        <trans-unit id="4935b8502c9911035c4038af29553fcfde8b5706" translate="yes" xml:space="preserve">
          <source>Array literal containing &lt;code&gt;len&lt;/code&gt; copies of &lt;code&gt;expr&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;expr&lt;/code&gt; の &lt;code&gt;len&lt;/code&gt; 個のコピーを含む配列リテラル</target>
        </trans-unit>
        <trans-unit id="235f924c7c3818aed78845bd2de8791d4d3ba101" translate="yes" xml:space="preserve">
          <source>Array literals with repeating syntax, where the array has type &lt;code&gt;[U; n]&lt;/code&gt;. The repeated sub-expression is a coercion site for coercion to type &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">構文が繰り返される配列リテラル &lt;code&gt;[U; n]&lt;/code&gt; 配列のタイプは[U; n]。繰り返される部分式は、タイプ &lt;code&gt;U&lt;/code&gt; への強制型変換の強制型サイトです。</target>
        </trans-unit>
        <trans-unit id="41d08ca772cf664e0e365d09949f5835931ea185" translate="yes" xml:space="preserve">
          <source>Array literals, where the array has type &lt;code&gt;[U; n]&lt;/code&gt;. Each sub-expression in the array literal is a coercion site for coercion to type &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">配列リテラル &lt;code&gt;[U; n]&lt;/code&gt; 配列のタイプは[U; n]。配列リテラルの各部分式は、 &lt;code&gt;U&lt;/code&gt; 型を強制する強制サイトです。</target>
        </trans-unit>
        <trans-unit id="5de52c0cb2ce4e0eb71f0c098408cbd13a499a61" translate="yes" xml:space="preserve">
          <source>Array repeat length expressions</source>
          <target state="translated">配列の繰り返し長の式</target>
        </trans-unit>
        <trans-unit id="ea9dbd560327931c17a47c31880f0fcea2d052f4" translate="yes" xml:space="preserve">
          <source>Array to pointer cast</source>
          <target state="translated">ポインタキャスト先の配列</target>
        </trans-unit>
        <trans-unit id="45de270a590c4d4b0320d8105310eb72bc4364df" translate="yes" xml:space="preserve">
          <source>Array type containing &lt;code&gt;len&lt;/code&gt; instances of &lt;code&gt;type&lt;/code&gt;</source>
          <target state="translated">含むアレイ型 &lt;code&gt;len&lt;/code&gt; のインスタンス &lt;code&gt;type&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="51a7c3ed1d5f017cc725067fca3064cb604b7344" translate="yes" xml:space="preserve">
          <source>Array type length expressions</source>
          <target state="translated">配列型の長さ表現</target>
        </trans-unit>
        <trans-unit id="ee988191e1f320445ced1a772858430505143153" translate="yes" xml:space="preserve">
          <source>Array types</source>
          <target state="translated">配列型</target>
        </trans-unit>
        <trans-unit id="51fa61d38d898a29b7f71e858ac412133bb4aa78" translate="yes" xml:space="preserve">
          <source>Array types, for all sizes, if the item type also implements &lt;code&gt;Clone&lt;/code&gt; (e.g., &lt;code&gt;[i32; 123456]&lt;/code&gt;)</source>
          <target state="translated">項目タイプも &lt;code&gt;Clone&lt;/code&gt; を実装する場合、すべてのサイズの配列タイプ（例： &lt;code&gt;[i32; 123456]&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="c11c5b2f8cc2056c662bde9d8e7265077775fda2" translate="yes" xml:space="preserve">
          <source>Array types, for all sizes, if the item type also implements &lt;code&gt;Copy&lt;/code&gt; (e.g., &lt;code&gt;[i32; 123456]&lt;/code&gt;)</source>
          <target state="translated">すべてのサイズの配列タイプ（項目タイプも &lt;code&gt;Copy&lt;/code&gt; 実装している場合（例： &lt;code&gt;[i32; 123456]&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="95c5c33f29f0547a430b0665b6ac583648900bd6" translate="yes" xml:space="preserve">
          <source>ArrayChunks</source>
          <target state="translated">ArrayChunks</target>
        </trans-unit>
        <trans-unit id="5d42cc662a1c24ca3713c4fbd65f30d1d4685e7c" translate="yes" xml:space="preserve">
          <source>ArrayChunksMut</source>
          <target state="translated">ArrayChunksMut</target>
        </trans-unit>
        <trans-unit id="f83b691df0418afaddc970026f4eccfa1541c51f" translate="yes" xml:space="preserve">
          <source>ArrayWindows</source>
          <target state="translated">ArrayWindows</target>
        </trans-unit>
        <trans-unit id="aa557f1be66399eaf12f2be07d75660861cacf56" translate="yes" xml:space="preserve">
          <source>Arrays are laid out so that the &lt;code&gt;nth&lt;/code&gt; element of the array is offset from the start of the array by &lt;code&gt;n * the size of the type&lt;/code&gt; bytes. An array of &lt;code&gt;[T; n]&lt;/code&gt; has a size of &lt;code&gt;size_of::&amp;lt;T&amp;gt;() * n&lt;/code&gt; and the same alignment of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">配列は、配列の &lt;code&gt;nth&lt;/code&gt; 要素が配列の先頭から &lt;code&gt;n * the size of the type&lt;/code&gt; バイトのサイズだけオフセットされるようにレイアウトされます。 &lt;code&gt;[T; n]&lt;/code&gt; の配列 n]のサイズは &lt;code&gt;size_of::&amp;lt;T&amp;gt;() * n&lt;/code&gt; で、 &lt;code&gt;T&lt;/code&gt; と同じ配置です。</target>
        </trans-unit>
        <trans-unit id="02fe2a892020ef77103f56bebff06ee9353b3385" translate="yes" xml:space="preserve">
          <source>Arrays are useful when you want your data allocated on the stack rather than the heap (we will discuss the stack and the heap more in Chapter 4) or when you want to ensure you always have a fixed number of elements. An array isn&amp;rsquo;t as flexible as the vector type, though. A vector is a similar collection type provided by the standard library that &lt;em&gt;is&lt;/em&gt; allowed to grow or shrink in size. If you&amp;rsquo;re unsure whether to use an array or a vector, you should probably use a vector. Chapter 8 discusses vectors in more detail.</source>
          <target state="translated">配列は、ヒープではなくスタックにデータを割り当てたい場合（スタックとヒープについては第4章で詳しく説明します）、または常に固定数の要素があることを確認する場合に便利です。ただし、配列はベクトル型ほど柔軟ではありません。ベクターは、標準ライブラリで提供同様のコレクション型である&lt;em&gt;されて&lt;/em&gt;サイズが拡大または縮小することができました。配列とベクトルのどちらを使用するかわからない場合は、おそらくベクトルを使用する必要があります。第8章では、ベクトルについて詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="3b3785f54b6fb9b400ea9ab57c87c42e59186241" translate="yes" xml:space="preserve">
          <source>Arrays coerce to &lt;a href=&quot;primitive.slice&quot;&gt;slices (&lt;code&gt;[T]&lt;/code&gt;)&lt;/a&gt;, so a slice method may be called on an array. Indeed, this provides most of the API for working with arrays. Slices have a dynamic size and do not coerce to arrays.</source>
          <target state="translated">配列は&lt;a href=&quot;primitive.slice&quot;&gt;スライス（ &lt;code&gt;[T]&lt;/code&gt; ）&lt;/a&gt;に強制変換されるため、配列に対してスライスメソッドを呼び出すことができます。実際、これは配列を操作するためのほとんどのAPIを提供します。スライスは動的なサイズを持ち、配列に強制されません。</target>
        </trans-unit>
        <trans-unit id="a5463b6c378c5a1ce536679177693788d8a488ef" translate="yes" xml:space="preserve">
          <source>Arrays of &lt;em&gt;any&lt;/em&gt; size are &lt;a href=&quot;marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; if the element type is &lt;a href=&quot;marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; if the element type is &lt;a href=&quot;clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;. This works because &lt;a href=&quot;marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; traits are specially known to the compiler.</source>
          <target state="translated">配列&lt;em&gt;任意の&lt;/em&gt;サイズは、&lt;a href=&quot;marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;要素の型である場合、&lt;a href=&quot;marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;や&lt;a href=&quot;clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt;要素の型がある場合は&lt;a href=&quot;clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt;。これは、&lt;a href=&quot;marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt;特性がコンパイラーに特に知られているために機能します。</target>
        </trans-unit>
        <trans-unit id="44fcd591dcf7f314f13f655158af04cf8a3c0c81" translate="yes" xml:space="preserve">
          <source>Arrays of &lt;em&gt;any&lt;/em&gt; size implement the following traits if the element type allows it:</source>
          <target state="translated">要素タイプで許可されている場合、&lt;em&gt;任意の&lt;/em&gt;サイズの配列は次の特性を実装します。</target>
        </trans-unit>
        <trans-unit id="6563ac44bbb67213c7a3f6f4eeedf9dc732e3220" translate="yes" xml:space="preserve">
          <source>Arrays of sizes from 0 to 32 (inclusive) implement &lt;a href=&quot;default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; trait if the element type allows it. As a stopgap, trait implementations are statically generated up to size 32.</source>
          <target state="translated">0から32（両端を含む）のサイズの配列は、要素タイプで許可されている場合、&lt;a href=&quot;default/trait.default&quot;&gt; &lt;code&gt;Default&lt;/code&gt; &lt;/a&gt;特性を実装します。一時的なものとして、トレイトの実装はサイズ32まで静的に生成されます。</target>
        </trans-unit>
        <trans-unit id="4f9eb669ece946f30cfd95add30aac8bad032e42" translate="yes" xml:space="preserve">
          <source>Arrays of sizes from 0 to 32 (inclusive) implement the &lt;a href=&quot;default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; trait if the element type allows it. As a stopgap, trait implementations are statically generated up to size 32.</source>
          <target state="translated">0から32（両端を含む）のサイズの配列は、要素タイプで許可されている場合、&lt;a href=&quot;default/trait.default&quot;&gt; &lt;code&gt;Default&lt;/code&gt; &lt;/a&gt;特性を実装します。一時的なものとして、トレイトの実装はサイズ32まで静的に生成されます。</target>
        </trans-unit>
        <trans-unit id="e22eb391f81362ae0eac8c4cd60b81a4562599d8" translate="yes" xml:space="preserve">
          <source>Arrays of sizes from 0 to 32 (inclusive) implement the following traits if the element type allows it:</source>
          <target state="translated">0 から 32 までのサイズ(含む)の配列は、要素の型が許可している場合には、以下の特性を実装します。</target>
        </trans-unit>
        <trans-unit id="3520f70ba3a61ccc1286dbddd33fb0815248aa0b" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;if&lt;/code&gt; expressions have their pattern matching variant in &lt;code&gt;if let&lt;/code&gt;, so too do &lt;code&gt;while&lt;/code&gt; expressions with &lt;code&gt;while let&lt;/code&gt;. The &lt;code&gt;while let&lt;/code&gt; expression matches the pattern against the expression, then runs the loop body if pattern matching succeeds, or exits the loop otherwise. We can use &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; in &lt;code&gt;while let&lt;/code&gt; expressions just like in &lt;code&gt;while&lt;/code&gt;.</source>
          <target state="translated">通り &lt;code&gt;if&lt;/code&gt; 式はで彼らのパターンマッチングのバリアントを持っている &lt;code&gt;if let&lt;/code&gt; 、これもそう &lt;code&gt;while&lt;/code&gt; と表現 &lt;code&gt;while let&lt;/code&gt; 。 &lt;code&gt;while let&lt;/code&gt; 式は、その後、表現に対するパターンに一致するパターンマッチングが成功した場合にループ本体を実行し、またはそうでなければループを抜けます。我々は使用することができます &lt;code&gt;break&lt;/code&gt; し、 &lt;code&gt;continue&lt;/code&gt; して &lt;code&gt;while let&lt;/code&gt; だけのように表現 &lt;code&gt;while&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2be2422a9ce4d7fe654319fa259c94897e3e7b46" translate="yes" xml:space="preserve">
          <source>As IANA assigns new addresses, this method will be updated. This may result in non-reserved addresses being treated as reserved in code that relies on an outdated version of this method.</source>
          <target state="translated">IANAが新しいアドレスを割り当てると、このメソッドは更新されます。これにより、このメソッドの古いバージョンに依存しているコードでは、予約されていないアドレスが予約されたものとして扱われる可能性があります。</target>
        </trans-unit>
        <trans-unit id="204e461bb880d4d3e097aeac5f123e90d90ae7f0" translate="yes" xml:space="preserve">
          <source>As Rust automatically calls the destructors of all contained fields, you don't have to implement &lt;code&gt;Drop&lt;/code&gt; in most cases. But there are some cases where it is useful, for example for types which directly manage a resource. That resource may be memory, it may be a file descriptor, it may be a network socket. Once a value of that type is no longer going to be used, it should &quot;clean up&quot; its resource by freeing the memory or closing the file or socket. This is the job of a destructor, and therefore the job of &lt;code&gt;Drop::drop&lt;/code&gt;.</source>
          <target state="translated">Rustは含まれているすべてのフィールドのデストラクタを自動的に呼び出すため、ほとんどの場合、 &lt;code&gt;Drop&lt;/code&gt; を実装する必要はありません。ただし、リソースを直接管理するタイプなど、便利な場合もあります。そのリソースはメモリ、ファイル記述子、ネットワークソケットの場合があります。そのタイプの値が使用されなくなると、メモリを解放するか、ファイルまたはソケットを閉じることによって、リソースを「クリーンアップ」する必要があります。これはデストラクタの仕事であり、したがって &lt;code&gt;Drop::drop&lt;/code&gt; 仕事です。</target>
        </trans-unit>
        <trans-unit id="0e9f144fd6603397ae748bc2c2b95fde2038ac9c" translate="yes" xml:space="preserve">
          <source>As a companion to &lt;a href=&quot;trait.borrow&quot;&gt;&lt;code&gt;Borrow&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; this trait allows a type to borrow as an underlying type by providing a mutable reference. See &lt;a href=&quot;trait.borrow&quot;&gt;&lt;code&gt;Borrow&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; for more information on borrowing as another type.</source>
          <target state="translated">&lt;a href=&quot;trait.borrow&quot;&gt; &lt;code&gt;Borrow&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;コンパニオンとして、このトレイトは、変更可能な参照を提供することにより、型が基になる型として借用できるようにします。別のタイプとしての借用の詳細については、&lt;a href=&quot;trait.borrow&quot;&gt; &lt;code&gt;Borrow&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="f044338e83e2522cd461ee6d84f7c5ea2e52e486" translate="yes" xml:space="preserve">
          <source>As a consequence, the hash map breaks if a &lt;code&gt;K&lt;/code&gt; wrapping a &lt;code&gt;Q&lt;/code&gt; value produces a different hash than &lt;code&gt;Q&lt;/code&gt;. For instance, imagine you have a type that wraps a string but compares ASCII letters ignoring their case:</source>
          <target state="translated">その結果、もしハッシュマップブレーク &lt;code&gt;K&lt;/code&gt; ラップ &lt;code&gt;Q&lt;/code&gt; 値がより異なるハッシュ生成 &lt;code&gt;Q&lt;/code&gt; を。たとえば、文字列をラップするが大文字と小文字を区別せずにASCII文字を比較する型があるとします。</target>
        </trans-unit>
        <trans-unit id="21e6ec20b4bccf73414453b9c7ceac9ffa2614a2" translate="yes" xml:space="preserve">
          <source>As a data collection, &lt;a href=&quot;../collections/struct.hashmap&quot;&gt;&lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt;&lt;/a&gt; owns both keys and values. If the key&amp;rsquo;s actual data is wrapped in a managing type of some kind, it should, however, still be possible to search for a value using a reference to the key&amp;rsquo;s data. For instance, if the key is a string, then it is likely stored with the hash map as a &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;, while it should be possible to search using a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;. Thus, &lt;code&gt;insert&lt;/code&gt; needs to operate on a &lt;code&gt;String&lt;/code&gt; while &lt;code&gt;get&lt;/code&gt; needs to be able to use a &lt;code&gt;&amp;amp;str&lt;/code&gt;.</source>
          <target state="translated">データコレクションとして、&lt;a href=&quot;../collections/struct.hashmap&quot;&gt; &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; &lt;/a&gt;はキーと値の両方を所有します。ただし、キーの実際のデータが何らかの管理タイプにラップされている場合でも、キーのデータへの参照を使用して値を検索することは可能です。たとえば、キーが文字列の場合、ハッシュマップとともに&lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;として格納される可能性がありますが、&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt;を使用して検索することは可能です。したがって、 &lt;code&gt;insert&lt;/code&gt; は &lt;code&gt;String&lt;/code&gt; を操作する必要があり、 &lt;code&gt;get&lt;/code&gt; は &lt;code&gt;&amp;amp;str&lt;/code&gt; を使用できる必要があります。</target>
        </trans-unit>
        <trans-unit id="72b018e0e36049ad8edb2d9275fa43ffbd253ac2" translate="yes" xml:space="preserve">
          <source>As a first example of ownership, we&amp;rsquo;ll look at the &lt;em&gt;scope&lt;/em&gt; of some variables. A scope is the range within a program for which an item is valid. Let&amp;rsquo;s say we have a variable that looks like this:</source>
          <target state="translated">所有権の最初の例として、いくつかの変数の&lt;em&gt;スコープ&lt;/em&gt;を見てみましょう。スコープは、アイテムが有効であるプログラム内の範囲です。次のような変数があるとします。</target>
        </trans-unit>
        <trans-unit id="ec757385247cd107e43eba2a3f4a658f211a87a6" translate="yes" xml:space="preserve">
          <source>As a hack to work around this, we use two separate traits injected by each of the two derives (&lt;code&gt;#[derive(PartialEq)]&lt;/code&gt; and &lt;code&gt;#[derive(Eq)]&lt;/code&gt;) and check that both of them are present as part of structural-match checking.</source>
          <target state="translated">これを回避するためのハックとして、2つの派生物（ &lt;code&gt;#[derive(PartialEq)]&lt;/code&gt; と &lt;code&gt;#[derive(Eq)]&lt;/code&gt; derive （Eq）]）のそれぞれによって注入された2つの別々の特性を使用し、両方が構造の一部として存在することを確認します-一致チェック。</target>
        </trans-unit>
        <trans-unit id="0024a0a24aed0a7ac58334f18eea8263ecf48ec1" translate="yes" xml:space="preserve">
          <source>As a language, Rust cares a &lt;em&gt;lot&lt;/em&gt; about the stability of your code. We want Rust to be a rock-solid foundation you can build on, and if things were constantly changing, that would be impossible. At the same time, if we can&amp;rsquo;t experiment with new features, we may not find out important flaws until after their release, when we can no longer change things.</source>
          <target state="translated">言語としては、錆が気に&lt;em&gt;多くのことを&lt;/em&gt;あなたのコードの安定性について。私たちは、Rustをあなたが構築できる強固な基盤にしたいと考えています。物事が絶えず変化している場合、それは不可能です。同時に、新しい機能を試すことができない場合は、リリース後になって変更を加えることができなくなるまで、重要な欠陥を見つけられない可能性があります。</target>
        </trans-unit>
        <trans-unit id="c7163ba6f2bf3417c3c81c5ac8d3af7e28902510" translate="yes" xml:space="preserve">
          <source>As a library author, you should always prefer implementing &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.tryfrom&quot;&gt;&lt;code&gt;TryFrom&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; rather than &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&amp;lt;U&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.tryinto&quot;&gt;&lt;code&gt;TryInto&amp;lt;U&amp;gt;&lt;/code&gt;&lt;/a&gt;, as &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.tryfrom&quot;&gt;&lt;code&gt;TryFrom&lt;/code&gt;&lt;/a&gt; provide greater flexibility and offer equivalent &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.tryinto&quot;&gt;&lt;code&gt;TryInto&lt;/code&gt;&lt;/a&gt; implementations for free, thanks to a blanket implementation in the standard library. Only implement &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.tryinto&quot;&gt;&lt;code&gt;TryInto&lt;/code&gt;&lt;/a&gt; when a conversion to a type outside the current crate is required.</source>
          <target state="translated">ライブラリの作者として、あなたは常に実装好むはずです&lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;trait.tryfrom&quot;&gt; &lt;code&gt;TryFrom&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;ではなく&lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&amp;lt;U&amp;gt;&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;trait.tryinto&quot;&gt; &lt;code&gt;TryInto&amp;lt;U&amp;gt;&lt;/code&gt; &lt;/a&gt;、など&lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;trait.tryfrom&quot;&gt; &lt;code&gt;TryFrom&lt;/code&gt; &lt;/a&gt;より大きな柔軟性を提供し、同等の提供&lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;trait.tryinto&quot;&gt; &lt;code&gt;TryInto&lt;/code&gt; &lt;/a&gt;自由のための実装を、感謝します標準ライブラリの包括的な実装。現在のクレート外の型への変換が必要な場合にのみ、&lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;trait.tryinto&quot;&gt; &lt;code&gt;TryInto&lt;/code&gt; を&lt;/a&gt;実装します。</target>
        </trans-unit>
        <trans-unit id="c688289e645266d022bd25b11abee98bf47d494f" translate="yes" xml:space="preserve">
          <source>As a library author, you should always prefer implementing &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.tryfrom&quot;&gt;&lt;code&gt;TryFrom&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; rather than &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&amp;lt;U&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.tryinto&quot;&gt;&lt;code&gt;TryInto&amp;lt;U&amp;gt;&lt;/code&gt;&lt;/a&gt;, as &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.tryfrom&quot;&gt;&lt;code&gt;TryFrom&lt;/code&gt;&lt;/a&gt; provide greater flexibility and offer equivalent &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.tryinto&quot;&gt;&lt;code&gt;TryInto&lt;/code&gt;&lt;/a&gt; implementations for free, thanks to a blanket implementation in the standard library. When targeting a version prior to Rust 1.41, it may be necessary to implement &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.tryinto&quot;&gt;&lt;code&gt;TryInto&lt;/code&gt;&lt;/a&gt; directly when converting to a type outside the current crate.</source>
          <target state="translated">ライブラリの作者として、あなたは常に実装好むはずです&lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;trait.tryfrom&quot;&gt; &lt;code&gt;TryFrom&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;ではなく&lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&amp;lt;U&amp;gt;&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;trait.tryinto&quot;&gt; &lt;code&gt;TryInto&amp;lt;U&amp;gt;&lt;/code&gt; &lt;/a&gt;、など&lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;trait.tryfrom&quot;&gt; &lt;code&gt;TryFrom&lt;/code&gt; &lt;/a&gt;より大きな柔軟性を提供し、同等の提供&lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;trait.tryinto&quot;&gt; &lt;code&gt;TryInto&lt;/code&gt; &lt;/a&gt;自由のための実装を、感謝します標準ライブラリの包括的な実装。 Rust 1.41より前のバージョンをターゲットにする場合、現在のクレート外のタイプに変換するときに、&lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;trait.tryinto&quot;&gt; &lt;code&gt;TryInto&lt;/code&gt; を&lt;/a&gt;直接実装する必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="ff562238e6519efc127fd0f82f8c3d4cbe94172e" translate="yes" xml:space="preserve">
          <source>As a more concise alternative, you can use a &lt;code&gt;for&lt;/code&gt; loop and execute some code for each item in a collection. A &lt;code&gt;for&lt;/code&gt; loop looks like the code in Listing 3-5.</source>
          <target state="translated">より簡潔な代替手段として、 &lt;code&gt;for&lt;/code&gt; ループを使用して、コレクション内の各アイテムに対していくつかのコードを実行できます。 &lt;code&gt;for&lt;/code&gt; コードリスト3-5のコードのようなループに見えます。</target>
        </trans-unit>
        <trans-unit id="4b5b050c97f5fa423f8a999dca4b012b9c78134c" translate="yes" xml:space="preserve">
          <source>As a result of this code, &lt;code&gt;s&lt;/code&gt; will contain &lt;code&gt;lol&lt;/code&gt;.</source>
          <target state="translated">このコードの結果として、 &lt;code&gt;s&lt;/code&gt; には &lt;code&gt;lol&lt;/code&gt; が含まれます。</target>
        </trans-unit>
        <trans-unit id="b710b8f0107d2ffba9437950b5808cd39ab806b4" translate="yes" xml:space="preserve">
          <source>As a result, this method consider addresses such as &lt;code&gt;fe80:0:0:1::&lt;/code&gt; or &lt;code&gt;fe81::&lt;/code&gt; to be unicast link-local addresses, whereas &lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local_strict&quot;&gt;&lt;code&gt;Ipv6Addr::is_unicast_link_local_strict()&lt;/code&gt;&lt;/a&gt; does not. If you need a strict validation fully compliant with the RFC, use &lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local_strict&quot;&gt;&lt;code&gt;Ipv6Addr::is_unicast_link_local_strict()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">その結果、このメソッドは &lt;code&gt;fe80:0:0:1::&lt;/code&gt; や &lt;code&gt;fe81::&lt;/code&gt; アドレスをユニキャストリンクローカルアドレスと&lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local_strict&quot;&gt; &lt;code&gt;Ipv6Addr::is_unicast_link_local_strict()&lt;/code&gt; &lt;/a&gt;ますが、Ipv6Addr :: is_unicast_link_local_strict（）はそうではありません。RFCに完全に準拠した厳密な検証が必要な場合は、代わりに&lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local_strict&quot;&gt; &lt;code&gt;Ipv6Addr::is_unicast_link_local_strict()&lt;/code&gt; &lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="0f98a89f1abd2dd1d5bfe499fd5b56372a5800c2" translate="yes" xml:space="preserve">
          <source>As a result, this method consider addresses such as &lt;code&gt;fe80:0:0:1::&lt;/code&gt; or &lt;code&gt;fe81::&lt;/code&gt; to be unicast link-local addresses, whereas &lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local_strict&quot;&gt;&lt;code&gt;is_unicast_link_local_strict()&lt;/code&gt;&lt;/a&gt; does not. If you need a strict validation fully compliant with the RFC, use &lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local_strict&quot;&gt;&lt;code&gt;is_unicast_link_local_strict()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">その結果、このメソッドは &lt;code&gt;fe80:0:0:1::&lt;/code&gt; または &lt;code&gt;fe81::&lt;/code&gt; アドレスをユニキャストリンクローカルアドレスと&lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local_strict&quot;&gt; &lt;code&gt;is_unicast_link_local_strict()&lt;/code&gt; &lt;/a&gt;ますが、is_unicast_link_local_strict（）はそうではありません。RFCに完全に準拠した厳密な検証が必要な場合は、&lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local_strict&quot;&gt; &lt;code&gt;is_unicast_link_local_strict()&lt;/code&gt; を&lt;/a&gt;使用します。</target>
        </trans-unit>
        <trans-unit id="486c7c23286a7b0e1299ccac2ee0a869b3e82ee5" translate="yes" xml:space="preserve">
          <source>As a string slice consists of a sequence of bytes, we can iterate through a string slice by byte. This method returns such an iterator.</source>
          <target state="translated">文字列スライスはバイト列で構成されているので、バイト単位で文字列スライスを反復処理することができます。このメソッドはそのようなイテレータを返します。</target>
        </trans-unit>
        <trans-unit id="13230333554cf4f41cab6ad4fc5190eeee2538f2" translate="yes" xml:space="preserve">
          <source>As a string slice consists of valid UTF-8, we can iterate through a string slice by &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. This method returns an iterator of both these &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s, as well as their byte positions.</source>
          <target state="translated">文字列スライスは有効なUTF-8で構成されているため、文字列スライスを&lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; で&lt;/a&gt;反復できます。このメソッドは、これらの&lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;の反復子とそれらのバイト位置を返します。</target>
        </trans-unit>
        <trans-unit id="437cfa80202d923ee25f6cf5ad0fd2f02cfb01ea" translate="yes" xml:space="preserve">
          <source>As a string slice consists of valid UTF-8, we can iterate through a string slice by &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. This method returns such an iterator.</source>
          <target state="translated">文字列スライスは有効なUTF-8で構成されているため、文字列スライスを&lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; で&lt;/a&gt;反復できます。このメソッドは、そのようなイテレータを返します。</target>
        </trans-unit>
        <trans-unit id="5e4e8ad23ff47badf3452433750942f67bdc2881" translate="yes" xml:space="preserve">
          <source>As a string slice consists of valid UTF-8, we can iterate through a string slice by &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. This method returns an iterator of both these &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s, as well as their byte positions.</source>
          <target state="translated">文字列スライスは有効なUTF-8で構成されているため、&lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; で&lt;/a&gt;文字列スライスを反復処理できます。このメソッドは、これらの&lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;とそれらのバイト位置の両方のイテレータを返します。</target>
        </trans-unit>
        <trans-unit id="b276d81f1ebeb72ef92a468ba3b31b82b8dbf57a" translate="yes" xml:space="preserve">
          <source>As a string slice consists of valid UTF-8, we can iterate through a string slice by &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. This method returns such an iterator.</source>
          <target state="translated">文字列スライスは有効なUTF-8で構成されているため、&lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; で&lt;/a&gt;文字列スライスを反復処理できます。このメソッドはそのようなイテレータを返します。</target>
        </trans-unit>
        <trans-unit id="fb40adb4e231d6bdd9f0bd0f9320f4357a2e82ae" translate="yes" xml:space="preserve">
          <source>As a string slice consists of valid UTF-8, we can iterate through a string slice by &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. This method returns an iterator of both these &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s, as well as their byte positions.</source>
          <target state="translated">文字列スライスは有効なUTF-8で構成されているため、文字列スライスを&lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; で&lt;/a&gt;反復できます。このメソッドは、これらの&lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;の反復子とそれらのバイト位置を返します。</target>
        </trans-unit>
        <trans-unit id="bf66f1c269d4394c9cb4445fd4fd600e640f2992" translate="yes" xml:space="preserve">
          <source>As a string slice consists of valid UTF-8, we can iterate through a string slice by &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. This method returns such an iterator.</source>
          <target state="translated">文字列スライスは有効なUTF-8で構成されているため、文字列スライスを&lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; で&lt;/a&gt;反復できます。このメソッドは、そのようなイテレータを返します。</target>
        </trans-unit>
        <trans-unit id="047a0a2f69f724c14716efaa0063a5ea83e459c4" translate="yes" xml:space="preserve">
          <source>As a string slice consists of valid UTF-8, we can iterate through a string slice by &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. This method returns an iterator of both these &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s, as well as their byte positions.</source>
          <target state="translated">文字列スライスは有効なUTF-8で構成されているため、&lt;a href=&quot;primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; で&lt;/a&gt;文字列スライスを反復処理できます。このメソッドは、これらの&lt;a href=&quot;primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;とそれらのバイト位置の両方のイテレータを返します。</target>
        </trans-unit>
        <trans-unit id="6d408364fefca0ab968a9b16914cf4b387f8e95e" translate="yes" xml:space="preserve">
          <source>As a string slice consists of valid UTF-8, we can iterate through a string slice by &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. This method returns such an iterator.</source>
          <target state="translated">文字列スライスは有効なUTF-8で構成されているため、&lt;a href=&quot;primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; で&lt;/a&gt;文字列スライスを反復処理できます。このメソッドはそのようなイテレータを返します。</target>
        </trans-unit>
        <trans-unit id="b4d78aa978dc16456ba4fafe0a526ad6183e3881" translate="yes" xml:space="preserve">
          <source>As always, remember that a human intuition for 'character' may not map to Unicode's definitions. For example, despite looking similar, the '&amp;eacute;' character is one Unicode code point while 'é' is two Unicode code points:</source>
          <target state="translated">いつものように、「文字」に対する人間の直感は、Unicodeの定義にマッピングされない場合があることを覚えておいてください。たとえば、似ているように見えますが、「&amp;eacute;」文字は1つのUnicodeコードポイントであり、「&amp;eacute;」は2つのUnicodeコードポイントです。</target>
        </trans-unit>
        <trans-unit id="8d82369403176e5c690373478594ff76e764a9ef" translate="yes" xml:space="preserve">
          <source>As always, we can use curly brackets to create a new scope, allowing for multiple mutable references, just not &lt;em&gt;simultaneous&lt;/em&gt; ones:</source>
          <target state="translated">いつものように、中かっこを使用して新しいスコープを作成できます。これにより、&lt;em&gt;同時&lt;/em&gt;参照ではなく、複数の可変参照を使用できます。</target>
        </trans-unit>
        <trans-unit id="c5be02ef05f525885a914931855842d0bd0941ea" translate="yes" xml:space="preserve">
          <source>As an example of how to use a mutex, let&amp;rsquo;s start by using a mutex in a single-threaded context, as shown in Listing 16-12:</source>
          <target state="translated">mutexの使用方法の例として、リスト16-12に示すように、シングルスレッドコンテキストでmutexを使用することから始めましょう。</target>
        </trans-unit>
        <trans-unit id="0a2b1532710f708a62d9bd14aa059c7176218c09" translate="yes" xml:space="preserve">
          <source>As an example of methods on a trait, consider the following:</source>
          <target state="translated">形質に関するメソッドの例として、次のように考えてみてください。</target>
        </trans-unit>
        <trans-unit id="46ce22c9bcccaee92580f06aedfeeb7db04850fe" translate="yes" xml:space="preserve">
          <source>As an example of where you could use either a closure defined inline or a named function, let&amp;rsquo;s look at a use of &lt;code&gt;map&lt;/code&gt;. To use the &lt;code&gt;map&lt;/code&gt; function to turn a vector of numbers into a vector of strings, we could use a closure, like this:</source>
          <target state="translated">インラインで定義されたクロージャーまたは名前付き関数を使用できる例として、 &lt;code&gt;map&lt;/code&gt; の使用法を見てみましょう。 &lt;code&gt;map&lt;/code&gt; 関数を使用して数値のベクトルを文字列のベクトルに変換するには、次のようにクロージャを使用できます。</target>
        </trans-unit>
        <trans-unit id="37540a09808abda7d1579f892bfd40fb102faf8d" translate="yes" xml:space="preserve">
          <source>As an example, Listing 11-10 has a silly function that prints the value of its parameter and returns 10, as well as a test that passes and a test that fails.</source>
          <target state="translated">例として、リスト11-10にはパラメータの値を表示して10を返すおバカな関数のほかに、テストが合格した場合と失敗した場合のテストがあります。</target>
        </trans-unit>
        <trans-unit id="53691b327422875e6972393627946b878398498e" translate="yes" xml:space="preserve">
          <source>As an example, a macro matcher like &lt;code&gt;$i:expr [ , ]&lt;/code&gt; could in theory be accepted in Rust today, since &lt;code&gt;[,]&lt;/code&gt; cannot be part of a legal expression and therefore the parse would always be unambiguous. However, because &lt;code&gt;[&lt;/code&gt; can start trailing expressions, &lt;code&gt;[&lt;/code&gt; is not a character which can safely be ruled out as coming after an expression. If &lt;code&gt;[,]&lt;/code&gt; were accepted in a later version of Rust, this matcher would become ambiguous or would misparse, breaking working code. Matchers like &lt;code&gt;$i:expr,&lt;/code&gt; or &lt;code&gt;$i:expr;&lt;/code&gt; would be legal, however, because &lt;code&gt;,&lt;/code&gt; and &lt;code&gt;;&lt;/code&gt; are legal expression separators. The specific rules are:</source>
          <target state="translated">一例として、のようなマクロマッチャー &lt;code&gt;$i:expr [ , ]&lt;/code&gt; 理論的には今日ルーストに受け入れられる可能性は、以来、 &lt;code&gt;[,]&lt;/code&gt; 、法的表現の一部にすることはできませんので、解析は、常に明確なことでしょう。ただし、 &lt;code&gt;[&lt;/code&gt; は後続の式を開始できるため、 &lt;code&gt;[&lt;/code&gt; は式の後に来ると安全に除外できる文字ではありません。 &lt;code&gt;[,]&lt;/code&gt; がRustの以降のバージョンで受け入れられた場合、このマッチャーはあいまいになるか、誤って解析され、機能するコードが壊れます。などのマッチャ &lt;code&gt;$i:expr,&lt;/code&gt; または &lt;code&gt;$i:expr;&lt;/code&gt; なぜなら、しかし、法的になり &lt;code&gt;,&lt;/code&gt; と &lt;code&gt;;&lt;/code&gt; 正当な式の区切り文字です。具体的なルールは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="3c5226f2d8790540dbbe88f9ad68f2409b55a32e" translate="yes" xml:space="preserve">
          <source>As an example, change the &lt;em&gt;src/main.rs&lt;/em&gt; file in your &lt;em&gt;loops&lt;/em&gt; directory to look like this:</source>
          <target state="translated">例として、&lt;em&gt;loops&lt;/em&gt;ディレクトリの&lt;em&gt;src / main.rs&lt;/em&gt;ファイルを&lt;em&gt;次の&lt;/em&gt;ように変更します。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7f0fd43eedc8fb375dd6813798e9b7e3996a0f09" translate="yes" xml:space="preserve">
          <source>As an example, let&amp;rsquo;s change one of our enum variants to hold data inside it. From 1999 through 2008, the United States minted quarters with different designs for each of the 50 states on one side. No other coins got state designs, so only quarters have this extra value. We can add this information to our &lt;code&gt;enum&lt;/code&gt; by changing the &lt;code&gt;Quarter&lt;/code&gt; variant to include a &lt;code&gt;UsState&lt;/code&gt; value stored inside it, which we&amp;rsquo;ve done here in Listing 6-4.</source>
          <target state="translated">例として、列挙型バリアントの1つを変更して、その中にデータを保持するようにします。米国は、1999年から2008年まで、一方の50州のそれぞれに異なるデザインの区画を作りました。他のコインには州のデザインがありません。そのため、この追加の価値を持つのは四半期のみです。リスト6-4で行ったように、 &lt;code&gt;Quarter&lt;/code&gt; バリアントを変更して内部に格納されている &lt;code&gt;UsState&lt;/code&gt; 値を含めることで、この情報を &lt;code&gt;enum&lt;/code&gt; 追加できます。</target>
        </trans-unit>
        <trans-unit id="d430493784bb7c38b9bfd2132c640f18ef8a2cfc" translate="yes" xml:space="preserve">
          <source>As an example, let&amp;rsquo;s say we want to implement &lt;code&gt;Display&lt;/code&gt; on &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, which the orphan rule prevents us from doing directly because the &lt;code&gt;Display&lt;/code&gt; trait and the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; type are defined outside our crate. We can make a &lt;code&gt;Wrapper&lt;/code&gt; struct that holds an instance of &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;; then we can implement &lt;code&gt;Display&lt;/code&gt; on &lt;code&gt;Wrapper&lt;/code&gt; and use the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; value, as shown in Listing 19-23.</source>
          <target state="translated">例として、我々は実装したいとしましょう &lt;code&gt;Display&lt;/code&gt; に &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; ので、直接やってから孤児がルール防止たちを、 &lt;code&gt;Display&lt;/code&gt; 特性と &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 型は、当社のクレートの外部で定義されています。 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; インスタンスを保持する &lt;code&gt;Wrapper&lt;/code&gt; 構造体を作成できます。次に、リスト19-23に示すように、 &lt;code&gt;Wrapper&lt;/code&gt; に &lt;code&gt;Display&lt;/code&gt; を実装し、 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 値を使用できます。</target>
        </trans-unit>
        <trans-unit id="0a293358ddd19b42df03eeb78c691469d4c0e122" translate="yes" xml:space="preserve">
          <source>As an example, let&amp;rsquo;s write a library crate that provides the functionality of a restaurant. We&amp;rsquo;ll define the signatures of functions but leave their bodies empty to concentrate on the organization of the code, rather than actually implement a restaurant in code.</source>
          <target state="translated">例として、レストランの機能を提供する図書館の箱を書いてみましょう。関数のシグネチャを定義しますが、実際にコードにレストランを実装するのではなく、コードの構成に集中するために、それらの本体を空のままにします。</target>
        </trans-unit>
        <trans-unit id="5e1d4bdb076d3e495d340c82a90a7bc9edd4704c" translate="yes" xml:space="preserve">
          <source>As an example, rather than using a list whose items know only about the next item, we&amp;rsquo;ll create a tree whose items know about their children items &lt;em&gt;and&lt;/em&gt; their parent items.</source>
          <target state="translated">例として、次のアイテムのみを知っているアイテムのリストを使用するのではなく、アイテムが子アイテム&lt;em&gt;と&lt;/em&gt;親アイテムを知っているツリーを作成します。</target>
        </trans-unit>
        <trans-unit id="84057f7bc04baf2d73dfbd111ea89a20d0d17089" translate="yes" xml:space="preserve">
          <source>As an example, recall the &lt;code&gt;Sync&lt;/code&gt; and &lt;code&gt;Send&lt;/code&gt; marker traits we discussed in the &lt;a href=&quot;ch16-04-extensible-concurrency-sync-and-send#extensible-concurrency-with-the-sync-and-send-traits&quot;&gt;&amp;ldquo;Extensible Concurrency with the &lt;code&gt;Sync&lt;/code&gt; and &lt;code&gt;Send&lt;/code&gt; Traits&amp;rdquo;&lt;/a&gt; section in Chapter 16: the compiler implements these traits automatically if our types are composed entirely of &lt;code&gt;Send&lt;/code&gt; and &lt;code&gt;Sync&lt;/code&gt; types. If we implement a type that contains a type that is not &lt;code&gt;Send&lt;/code&gt; or &lt;code&gt;Sync&lt;/code&gt;, such as raw pointers, and we want to mark that type as &lt;code&gt;Send&lt;/code&gt; or &lt;code&gt;Sync&lt;/code&gt;, we must use &lt;code&gt;unsafe&lt;/code&gt;. Rust can&amp;rsquo;t verify that our type upholds the guarantees that it can be safely sent across threads or accessed from multiple threads; therefore, we need to do those checks manually and indicate as such with &lt;code&gt;unsafe&lt;/code&gt;.</source>
          <target state="translated">例として、リコール &lt;code&gt;Sync&lt;/code&gt; をし、 &lt;code&gt;Send&lt;/code&gt; 私たちが議論マーカー特徴&lt;a href=&quot;ch16-04-extensible-concurrency-sync-and-send#extensible-concurrency-with-the-sync-and-send-traits&quot;&gt;「で拡張可能な同時実行 &lt;code&gt;Sync&lt;/code&gt; と &lt;code&gt;Send&lt;/code&gt; 済みの特徴」&lt;/a&gt;第16章でセクション：私たちの種類が完全に構成されている場合、自動的にコンパイラの実装これらの特徴を &lt;code&gt;Send&lt;/code&gt; し、 &lt;code&gt;Sync&lt;/code&gt; タイプを。rawポインターなど、 &lt;code&gt;Send&lt;/code&gt; または &lt;code&gt;Sync&lt;/code&gt; ではない型を含む型を実装し、その型を &lt;code&gt;Send&lt;/code&gt; または &lt;code&gt;Sync&lt;/code&gt; としてマークする場合は、 &lt;code&gt;unsafe&lt;/code&gt; ないものを使用する必要があります。 Rustは、私たちのタイプが、スレッド間で安全に送信できる、または複数のスレッドからアクセスできるという保証が守られていることを確認できません。したがって、これらのチェックを手動で実行し、そのように &lt;code&gt;unsafe&lt;/code&gt; で示す必要があります。</target>
        </trans-unit>
        <trans-unit id="38a88a1bad47211ae1a10e5bfcee84726e1f325e" translate="yes" xml:space="preserve">
          <source>As an example, say we write a function called &lt;code&gt;add_two&lt;/code&gt; that adds 2 to whatever number is passed to it. This function&amp;rsquo;s signature accepts an integer as a parameter and returns an integer as a result. When we implement and compile that function, Rust does all the type checking and borrow checking that you&amp;rsquo;ve learned so far to ensure that, for instance, we aren&amp;rsquo;t passing a &lt;code&gt;String&lt;/code&gt; value or an invalid reference to this function. But Rust &lt;em&gt;can&amp;rsquo;t&lt;/em&gt; check that this function will do precisely what we intend, which is return the parameter plus 2 rather than, say, the parameter plus 10 or the parameter minus 50! That&amp;rsquo;s where tests come in.</source>
          <target state="translated">例として、渡された数値に2を加算する &lt;code&gt;add_two&lt;/code&gt; という関数を作成するとします。この関数のシグネチャは、整数をパラメータとして受け入れ、整数を結果として返します。この関数を実装してコンパイルするとき、Rustはこれまでに学んだすべての型チェックと借用チェックを実行して、たとえば、この関数に &lt;code&gt;String&lt;/code&gt; 値や無効な参照を渡していないことを確認します。しかし、Rust &lt;em&gt;は&lt;/em&gt;、この関数が意図したとおりに機能することを確認&lt;em&gt;できません&lt;/em&gt;。たとえば、パラメータープラス10またはパラメーターマイナス50ではなく、パラメータープラス2を返します。それがテストの出番です。</target>
        </trans-unit>
        <trans-unit id="0c46b40f3e5f774d5bd6d946904f04146f347849" translate="yes" xml:space="preserve">
          <source>As an example, the pattern &lt;code&gt;&quot;aaa&quot;&lt;/code&gt; and the haystack &lt;code&gt;&quot;cbaaaaab&quot;&lt;/code&gt; might produce the stream &lt;code&gt;[Reject(0, 1), Reject(1, 2), Match(2, 5), Reject(5, 8)]&lt;/code&gt;</source>
          <target state="translated">例として、パターン &lt;code&gt;&quot;aaa&quot;&lt;/code&gt; と干し草 &lt;code&gt;&quot;cbaaaaab&quot;&lt;/code&gt; は、ストリーム &lt;code&gt;[Reject(0, 1), Reject(1, 2), Match(2, 5), Reject(5, 8)]&lt;/code&gt; 2、5 ）、Reject（5、8）]を生成する可能性があります。</target>
        </trans-unit>
        <trans-unit id="f6b604f8510907ca9fe9178dfcf2a6874e95e6b5" translate="yes" xml:space="preserve">
          <source>As an example, the pattern &lt;code&gt;&quot;aaa&quot;&lt;/code&gt; and the haystack &lt;code&gt;&quot;cbaaaaab&quot;&lt;/code&gt; might produce the stream &lt;code&gt;[Reject(7, 8), Match(4, 7), Reject(1, 4), Reject(0, 1)]&lt;/code&gt;</source>
          <target state="translated">例として、パターン &lt;code&gt;&quot;aaa&quot;&lt;/code&gt; と干し草の &lt;code&gt;&quot;cbaaaaab&quot;&lt;/code&gt; は、ストリーム &lt;code&gt;[Reject(7, 8), Match(4, 7), Reject(1, 4), Reject(0, 1)]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4bbd3fe41e9f9da754b12e58c1b62e309d7fedd0" translate="yes" xml:space="preserve">
          <source>As an example, the pattern &lt;code&gt;&quot;aaa&quot;&lt;/code&gt; and the haystack &lt;code&gt;&quot;cbaaaaab&quot;&lt;/code&gt; might produce the stream &lt;code&gt;[Reject(7, 8), Match(4, 7), Reject(1, 4), Reject(0, 1)]&lt;/code&gt;.</source>
          <target state="translated">例として、パターン &lt;code&gt;&quot;aaa&quot;&lt;/code&gt; と干し草の &lt;code&gt;&quot;cbaaaaab&quot;&lt;/code&gt; は、ストリーム &lt;code&gt;[Reject(7, 8), Match(4, 7), Reject(1, 4), Reject(0, 1)]&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="877bff60769fbc36114e44fb0843def0fdaa302f" translate="yes" xml:space="preserve">
          <source>As an iterator:</source>
          <target state="translated">イテレータとして</target>
        </trans-unit>
        <trans-unit id="04b8526b20e002ad597cb978c8868c4ab1a90f67" translate="yes" xml:space="preserve">
          <source>As another example, suppose we have a &lt;code&gt;Maker&lt;/code&gt; trait and want to establish a type &lt;code&gt;FooMaker&lt;/code&gt; that makes &lt;code&gt;Foo&lt;/code&gt;s:</source>
          <target state="translated">別の例として、 &lt;code&gt;Maker&lt;/code&gt; トレイトがあり、 &lt;code&gt;Foo&lt;/code&gt; を sにするタイプ &lt;code&gt;FooMaker&lt;/code&gt; を確立するとします。</target>
        </trans-unit>
        <trans-unit id="5213c1c4f3b10c9c56042b19c8c0157b715adba7" translate="yes" xml:space="preserve">
          <source>As another example, the following code is taken from an audio decoder. The decoding algorithm uses the linear prediction mathematical operation to estimate future values based on a linear function of the previous samples. This code uses an iterator chain to do some math on three variables in scope: a &lt;code&gt;buffer&lt;/code&gt; slice of data, an array of 12 &lt;code&gt;coefficients&lt;/code&gt;, and an amount by which to shift data in &lt;code&gt;qlp_shift&lt;/code&gt;. We&amp;rsquo;ve declared the variables within this example but not given them any values; although this code doesn&amp;rsquo;t have much meaning outside of its context, it&amp;rsquo;s still a concise, real-world example of how Rust translates high-level ideas to low-level code.</source>
          <target state="translated">別の例として、次のコードはオーディオデコーダーから取得されます。デコードアルゴリズムは、線形予測の数学演算を使用して、以前のサンプルの線形関数に基づいて将来の値を推定します。このコードは、反復子チェーンを使用して、スコープ内の3つの変数（データの &lt;code&gt;buffer&lt;/code&gt; スライス、12個の &lt;code&gt;coefficients&lt;/code&gt; 配列、および &lt;code&gt;qlp_shift&lt;/code&gt; でデータをシフトする量）についていくつかの計算を行います。この例では変数を宣言していますが、値は指定していません。このコードはコンテキスト外ではあまり意味がありませんが、Rustが高レベルのアイデアを低レベルのコードに変換する方法の簡潔で現実的な例です。</target>
        </trans-unit>
        <trans-unit id="50430e10a27b5bcf53132a5539fdc175dfb8f896" translate="yes" xml:space="preserve">
          <source>As can be seen below, &lt;code&gt;else&lt;/code&gt; must be followed by either: &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;if let&lt;/code&gt;, or a block &lt;code&gt;{}&lt;/code&gt; and it will return the value of that expression.</source>
          <target state="translated">以下に示すように、 &lt;code&gt;else&lt;/code&gt; の後には、 &lt;code&gt;if&lt;/code&gt; 、 &lt;code&gt;if let&lt;/code&gt; 、またはブロック &lt;code&gt;{}&lt;/code&gt; のいずれかを続ける必要があり、その式の値を返します。</target>
        </trans-unit>
        <trans-unit id="ceca2c634722fa77d0d672657c5578a7251142a0" translate="yes" xml:space="preserve">
          <source>As described, &lt;a href=&quot;../i32/index&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt; implements &lt;code&gt;TryFrom&amp;lt;i64&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">説明したように、&lt;a href=&quot;../i32/index&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt;は &lt;code&gt;TryFrom&amp;lt;i64&amp;gt;&lt;/code&gt; 実装します。</target>
        </trans-unit>
        <trans-unit id="7af5c30f33f1fda6dc417defcc8e46844e2584e3" translate="yes" xml:space="preserve">
          <source>As described, &lt;a href=&quot;../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt; implements &lt;code&gt;TryFrom&amp;lt;&lt;/code&gt;&lt;a href=&quot;../primitive.i64&quot;&gt;&lt;code&gt;i64&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">説明したように、&lt;a href=&quot;../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt;は &lt;code&gt;TryFrom&amp;lt;&lt;/code&gt; &lt;a href=&quot;../primitive.i64&quot;&gt; &lt;code&gt;i64&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; を実装します。</target>
        </trans-unit>
        <trans-unit id="0958482afe9fd3c8317c6c0d343e311be75015c7" translate="yes" xml:space="preserve">
          <source>As discussed in Chapter 10, to implement a trait, we need to provide implementations for the trait&amp;rsquo;s required methods. The &lt;code&gt;Deref&lt;/code&gt; trait, provided by the standard library, requires us to implement one method named &lt;code&gt;deref&lt;/code&gt; that borrows &lt;code&gt;self&lt;/code&gt; and returns a reference to the inner data. Listing 15-10 contains an implementation of &lt;code&gt;Deref&lt;/code&gt; to add to the definition of &lt;code&gt;MyBox&lt;/code&gt;:</source>
          <target state="translated">第10章で説明したように、トレイトを実装するには、トレイトに必要なメソッドの実装を提供する必要があります。 &lt;code&gt;Deref&lt;/code&gt; トレイト、標準ライブラリで提供さは、1つのという名前のメソッドを実装するために私たちを必要と &lt;code&gt;deref&lt;/code&gt; 借りていること &lt;code&gt;self&lt;/code&gt; を返す内部のデータを参照します。 15-10のリストの実装が含まれ &lt;code&gt;Deref&lt;/code&gt; 定義に追加する &lt;code&gt;MyBox&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="d5f5ed3e00ea3332f0559aed11908528d1ba499a" translate="yes" xml:space="preserve">
          <source>As discussed in Chapter 17, the &lt;code&gt;take&lt;/code&gt; method on &lt;code&gt;Option&lt;/code&gt; takes the &lt;code&gt;Some&lt;/code&gt; variant out and leaves &lt;code&gt;None&lt;/code&gt; in its place. We&amp;rsquo;re using &lt;code&gt;if let&lt;/code&gt; to destructure the &lt;code&gt;Some&lt;/code&gt; and get the thread; then we call &lt;code&gt;join&lt;/code&gt; on the thread. If a worker&amp;rsquo;s thread is already &lt;code&gt;None&lt;/code&gt;, we know that worker has already had its thread cleaned up, so nothing happens in that case.</source>
          <target state="translated">第17章で説明した &lt;code&gt;take&lt;/code&gt; 、 &lt;code&gt;Option&lt;/code&gt; のtakeメソッドは、 &lt;code&gt;Some&lt;/code&gt; バリアントを &lt;code&gt;None&lt;/code&gt; し、代わりにNoneを残します。私たちは、使用している &lt;code&gt;if let&lt;/code&gt; destructureする &lt;code&gt;Some&lt;/code&gt; スレッドを取得します。次に、スレッドで &lt;code&gt;join&lt;/code&gt; を呼び出します。ワーカーのスレッドがすでに &lt;code&gt;None&lt;/code&gt; である場合、ワーカーは既にそのスレッドをクリーンアップしているため、その場合は何も起こりません。</target>
        </trans-unit>
        <trans-unit id="9fd5d9a215556134ab45028a161d57190ff678d3" translate="yes" xml:space="preserve">
          <source>As discussed in Chapter 6, we use patterns in the arms of &lt;code&gt;match&lt;/code&gt; expressions. Formally, &lt;code&gt;match&lt;/code&gt; expressions are defined as the keyword &lt;code&gt;match&lt;/code&gt;, a value to match on, and one or more match arms that consist of a pattern and an expression to run if the value matches that arm&amp;rsquo;s pattern, like this:</source>
          <target state="translated">第6章で説明したように、 &lt;code&gt;match&lt;/code&gt; 式のアームではパターンを使用します。正式には、 &lt;code&gt;match&lt;/code&gt; 式は、キーワード &lt;code&gt;match&lt;/code&gt; 、一致する値、およびパターンと、値がそのアームのパターンに一致する場合に実行される式で構成される1つ以上の一致アームとして定義されます。</target>
        </trans-unit>
        <trans-unit id="b597a68d9b285f7d308e42a0c9a8b37ad1bf7193" translate="yes" xml:space="preserve">
          <source>As for what happens behind the scenes, when optimizations are enabled the final generated machine code might look very different from the code:</source>
          <target state="translated">裏で何が起こっているかについては、最適化を有効にすると、最終的に生成されたマシンコードはコードとは大きく異なるものに見えるかもしれません。</target>
        </trans-unit>
        <trans-unit id="e7061cd66862cc7d4e84cb20891d413f4dbad19d" translate="yes" xml:space="preserve">
          <source>As functions, they must either return syntax, panic, or loop endlessly. Returned syntax either replaces or adds the syntax depending on the kind of procedural macro. Panics are caught by the compiler and are turned into a compiler error. Endless loops are not caught by the compiler which hangs the compiler.</source>
          <target state="translated">関数としては、構文を返すか、パニックになるか、無限にループする必要があります。返される構文は、手続き的なマクロの種類に応じて、構文を置き換えるか、追加します。パニックはコンパイラによって捕捉され、コンパイラ エラーになります。エンドレスループはコンパイラによって捕捉されず、コンパイラがハングアップします。</target>
        </trans-unit>
        <trans-unit id="fd8f9685a0be8d16b4d260e66976648f0f435f12" translate="yes" xml:space="preserve">
          <source>As humans, we can look at this code and see that &lt;code&gt;string1&lt;/code&gt; is longer than &lt;code&gt;string2&lt;/code&gt; and therefore &lt;code&gt;result&lt;/code&gt; will contain a reference to &lt;code&gt;string1&lt;/code&gt;. Because &lt;code&gt;string1&lt;/code&gt; has not gone out of scope yet, a reference to &lt;code&gt;string1&lt;/code&gt; will still be valid for the &lt;code&gt;println!&lt;/code&gt; statement. However, the compiler can&amp;rsquo;t see that the reference is valid in this case. We&amp;rsquo;ve told Rust that the lifetime of the reference returned by the &lt;code&gt;longest&lt;/code&gt; function is the same as the smaller of the lifetimes of the references passed in. Therefore, the borrow checker disallows the code in Listing 10-24 as possibly having an invalid reference.</source>
          <target state="translated">人間として、このコードを見ると、 &lt;code&gt;string1&lt;/code&gt; が &lt;code&gt;string2&lt;/code&gt; よりも長いため、 &lt;code&gt;result&lt;/code&gt; には &lt;code&gt;string1&lt;/code&gt; への参照が含まれていることがわかります。ので &lt;code&gt;string1&lt;/code&gt; のはまだ範囲を出ていない、参照 &lt;code&gt;string1&lt;/code&gt; がまだのために有効になります &lt;code&gt;println!&lt;/code&gt; ステートメント。ただし、この場合、コンパイラは参照が有効であることを認識できません。 &lt;code&gt;longest&lt;/code&gt; 関数によって返される参照の有効期間は、渡される参照の有効期間の短い方と同じであることをRustに伝えました。したがって、借用チェッカーは、リスト10-24のコードが無効な参照である可能性があることを許可しません。</target>
        </trans-unit>
        <trans-unit id="6d9f4910be4026effcf198634df42e1c4041dff1" translate="yes" xml:space="preserve">
          <source>As in most other programming languages, a Boolean type in Rust has two possible values: &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;. Booleans are one byte in size. The Boolean type in Rust is specified using &lt;code&gt;bool&lt;/code&gt;. For example:</source>
          <target state="translated">他のほとんどのプログラミング言語と同様に、Rustのブール型には &lt;code&gt;true&lt;/code&gt; と &lt;code&gt;false&lt;/code&gt; の 2つの値があります。ブール値のサイズは1バイトです。Rustのブール型は &lt;code&gt;bool&lt;/code&gt; を使用して指定されます。例えば：</target>
        </trans-unit>
        <trans-unit id="45c7aa166fa09685143658300364b92158ea06fe" translate="yes" xml:space="preserve">
          <source>As is the case in &lt;a href=&quot;if-expr#if-let-expressions&quot;&gt;&lt;code&gt;if let&lt;/code&gt; expressions&lt;/a&gt;, the scrutinee cannot be a &lt;a href=&quot;operator-expr#lazy-boolean-operators&quot;&gt;lazy boolean operator expression&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;if-expr#if-let-expressions&quot;&gt; &lt;code&gt;if let&lt;/code&gt; 式の&lt;/a&gt;場合と同様に、scrutineeを&lt;a href=&quot;operator-expr#lazy-boolean-operators&quot;&gt;怠惰なブール演算子式に&lt;/a&gt;することはできません。</target>
        </trans-unit>
        <trans-unit id="118d39ec67253c2f49ef6f0a1ef21526ef7b61b3" translate="yes" xml:space="preserve">
          <source>As it turns out, though, most traits can have an &lt;code&gt;impl&lt;/code&gt; for &lt;code&gt;!&lt;/code&gt;. Take &lt;a href=&quot;fmt/trait.debug&quot;&gt;&lt;code&gt;Debug&lt;/code&gt;&lt;/a&gt; for example:</source>
          <target state="translated">結局のところ、しかし、ほとんどの特徴は持つことができる &lt;code&gt;impl&lt;/code&gt; のために &lt;code&gt;!&lt;/code&gt; 。&lt;a href=&quot;fmt/trait.debug&quot;&gt; &lt;code&gt;Debug&lt;/code&gt; &lt;/a&gt;を例にとってみましょう。</target>
        </trans-unit>
        <trans-unit id="a025b290deb94845050bfa62909fd15fe5ae74be" translate="yes" xml:space="preserve">
          <source>As long as your command line parsing logic is small, it can remain in &lt;em&gt;main.rs&lt;/em&gt;.</source>
          <target state="translated">コマンドライン解析ロジックが小さい限り、&lt;em&gt;main.rsに&lt;/em&gt;残すことができます。</target>
        </trans-unit>
        <trans-unit id="8323a3696731d93f0a84dafc08f2d32df5ef0903" translate="yes" xml:space="preserve">
          <source>As mentioned at the start of the chapter, testing is a complex discipline, and different people use different terminology and organization. The Rust community thinks about tests in terms of two main categories: &lt;em&gt;unit tests&lt;/em&gt; and &lt;em&gt;integration tests&lt;/em&gt;. Unit tests are small and more focused, testing one module in isolation at a time, and can test private interfaces. Integration tests are entirely external to your library and use your code in the same way any other external code would, using only the public interface and potentially exercising multiple modules per test.</source>
          <target state="translated">この章の冒頭で述べたように、テストは複雑な分野であり、人によって使用する用語や構成は異なります。 Rustコミュニティは、テストを2つの主要なカテゴリ（&lt;em&gt;ユニットテスト&lt;/em&gt;と&lt;em&gt;統合テスト）の&lt;/em&gt;観点から考えてい&lt;em&gt;ます&lt;/em&gt;。単体テストは小規模で集中的で、一度に1つのモジュールを分離してテストし、プライベートインターフェイスをテストできます。統合テストは完全にライブラリの外部にあり、他の外部コードと同じようにコードを使用します。パブリックインターフェイスのみを使用し、テストごとに複数のモジュールを実行する可能性があります。</target>
        </trans-unit>
        <trans-unit id="10eda87545057c2aa683c0bbfe8990122953ece6" translate="yes" xml:space="preserve">
          <source>As mentioned before, trait objects contain pointers to method tables. So, if we have:</source>
          <target state="translated">前述したように、 trait オブジェクトにはメソッドテーブルへのポインタが含まれています。ですから、もしあれば</target>
        </trans-unit>
        <trans-unit id="4761017ad6dee318134842b138bc05d35199a594" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, &lt;code&gt;read_line&lt;/code&gt; puts what the user types into the string we&amp;rsquo;re passing it, but it also returns a value&amp;mdash;in this case, an &lt;a href=&quot;../std/io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;. Rust has a number of types named &lt;code&gt;Result&lt;/code&gt; in its standard library: a generic &lt;a href=&quot;../std/result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; as well as specific versions for submodules, such as &lt;code&gt;io::Result&lt;/code&gt;.</source>
          <target state="translated">前述のように、 &lt;code&gt;read_line&lt;/code&gt; は、ユーザーが入力した文字列を渡した文字列に入れますが、値（この場合は&lt;a href=&quot;../std/io/type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt;も返します。Rustの標準ライブラリには、 &lt;code&gt;Result&lt;/code&gt; という名前のタイプがいくつかあります。一般的な&lt;a href=&quot;../std/result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt;と、 &lt;code&gt;io::Result&lt;/code&gt; などのサブモジュールの特定のバージョンです。</target>
        </trans-unit>
        <trans-unit id="3f7435a393907a8b1c4a2fc1b69a43772076a5c5" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, because very little of how Rust handles concurrency is part of the language, many concurrency solutions are implemented as crates. These evolve more quickly than the standard library, so be sure to search online for the current, state-of-the-art crates to use in multithreaded situations.</source>
          <target state="translated">前述したように、Rust が並行処理を処理する方法のほとんどが言語の一部であるため、多くの並行処理ソリューションはクレートとして実装されています。これらのクレートは標準ライブラリよりも急速に進化していますので、マルチスレッドの状況で使用するための最新のクレートをオンラインで検索するようにしてください。</target>
        </trans-unit>
        <trans-unit id="a6f8e14141b394aeafb54cb0af5563e56c04e70c" translate="yes" xml:space="preserve">
          <source>As mentioned in Chapter 2, by default variables are immutable. This is one of many nudges Rust gives you to write your code in a way that takes advantage of the safety and easy concurrency that Rust offers. However, you still have the option to make your variables mutable. Let&amp;rsquo;s explore how and why Rust encourages you to favor immutability and why sometimes you might want to opt out.</source>
          <target state="translated">第2章で述べたように、デフォルトでは変数は不変です。これは、Rustが提供する安全性と同時実行性を活用した方法でコードを記述するためにRustが提供する多くのナッジの1つです。ただし、変数を変更可能にするオプションはまだあります。どのようにそしてなぜRustが不変性を支持することを勧めるのか、なぜオプトアウトしたいのかを探りましょう。</target>
        </trans-unit>
        <trans-unit id="7641c8a38df92f9203220e805ba01b7f30732a0c" translate="yes" xml:space="preserve">
          <source>As mentioned in the module documentation, threads are usually made to communicate using &lt;a href=&quot;../sync/mpsc/index&quot;&gt;&lt;code&gt;channels&lt;/code&gt;&lt;/a&gt;, here is how it usually looks.</source>
          <target state="translated">モジュールのドキュメントで述べられているように、スレッドは通常、&lt;a href=&quot;../sync/mpsc/index&quot;&gt; &lt;code&gt;channels&lt;/code&gt; &lt;/a&gt;を使用して通信するように作られています。</target>
        </trans-unit>
        <trans-unit id="fad7d9a9d62e3d2756844c471849a76502954355" translate="yes" xml:space="preserve">
          <source>As non-Rust calling conventions do not support unwinding, unwinding past the end of an extern function will cause the process to abort. In LLVM, this is implemented by executing an illegal instruction.</source>
          <target state="translated">非Rustの呼び出し規約はアンワインドをサポートしていないため、外部関数の終わりを過ぎたアンワインドは、プロセスを中止させる原因となります。LLVMでは、これは不正な命令を実行することで実装されています。</target>
        </trans-unit>
        <trans-unit id="10482a83c62e485259adbe51b49060ecef064cde" translate="yes" xml:space="preserve">
          <source>As noted above, coercions mean that most code doesn't have to be concerned with this distinction. However, you can tell the difference when using &lt;strong&gt;transmute&lt;/strong&gt; to convert a fn item into a fn pointer.</source>
          <target state="translated">上記のように、強制とは、ほとんどのコードがこの区別に関係する必要がないことを意味します。ただし、&lt;strong&gt;transmute&lt;/strong&gt;を使用してfnアイテムをfnポインターに変換するときに違いを確認できます。</target>
        </trans-unit>
        <trans-unit id="a5cb1839eab079676f60d9f52ac6387e18acb792" translate="yes" xml:space="preserve">
          <source>As noted in the documentation for the type itself, it is essentially an opaque ID, but is guaranteed to be unique for each thread. The returned value is entirely opaque -- only equality testing is stable. Note that it is not guaranteed which values new threads will return, and this may change across Rust versions.</source>
          <target state="translated">この型自体のドキュメントに記載されているように、基本的には不透明な ID ですが、スレッドごとに一意であることが保証されています。返される値は完全に不透明です。新しいスレッドがどの値を返すかは保証されていないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="f7018b1edbbce45316477bb25e1ffd907f9a0adb" translate="yes" xml:space="preserve">
          <source>As one would expect, primitive types like &lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../primitive.f64&quot;&gt;&lt;code&gt;f64&lt;/code&gt;&lt;/a&gt; are all &lt;a href=&quot;trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;, and so are simple aggregate types containing them, like tuples, structs and enums. More examples of basic &lt;a href=&quot;trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; types include &quot;immutable&quot; types like &lt;code&gt;&amp;amp;T&lt;/code&gt;, and those with simple inherited mutability, such as &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and most other collection types. (Generic parameters need to be &lt;a href=&quot;trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; for their container to be &lt;a href=&quot;trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">&lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt;、u8や&lt;a href=&quot;../primitive.f64&quot;&gt; &lt;code&gt;f64&lt;/code&gt; &lt;/a&gt;などのプリミティブ型はすべて&lt;a href=&quot;trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt;であり、タプル、構造体、列挙型など、それらを含む単純な集約型も同様です。基本的な&lt;a href=&quot;trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt;タイプのその他の例には、 &lt;code&gt;&amp;amp;T&lt;/code&gt; などの「不変」タイプや、&lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;、その他のほとんどのコレクションタイプなどの単純な継承された可変性を持つタイプが含まれます。（ジェネリックパラメータは、する必要が&lt;a href=&quot;trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt;であることを彼らのコンテナの&lt;a href=&quot;trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="78cffef75c7264e29f3831c1d70df7b7db90b085" translate="yes" xml:space="preserve">
          <source>As one would expect, primitive types like &lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../primitive.f64&quot;&gt;&lt;code&gt;f64&lt;/code&gt;&lt;/a&gt; are all &lt;code&gt;Sync&lt;/code&gt;, and so are simple aggregate types containing them, like tuples, structs and enums. More examples of basic &lt;code&gt;Sync&lt;/code&gt; types include &quot;immutable&quot; types like &lt;code&gt;&amp;amp;T&lt;/code&gt;, and those with simple inherited mutability, such as &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and most other collection types. (Generic parameters need to be &lt;code&gt;Sync&lt;/code&gt; for their container to be &lt;code&gt;Sync&lt;/code&gt;.)</source>
          <target state="translated">ご&lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt;、u8や&lt;a href=&quot;../primitive.f64&quot;&gt; &lt;code&gt;f64&lt;/code&gt; &lt;/a&gt;などのプリミティブ型はすべて &lt;code&gt;Sync&lt;/code&gt; であり、タプル、構造体、列挙型などのそれらを含む単純な集約型も同様です。基本的な &lt;code&gt;Sync&lt;/code&gt; タイプのその他の例には、 &lt;code&gt;&amp;amp;T&lt;/code&gt; のような「不変」タイプや、&lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;、およびその他のほとんどのコレクションタイプなど、単純に継承された可変性のタイプがあります。（ジェネリックパラメータは、する必要が &lt;code&gt;Sync&lt;/code&gt; であることを彼らのコンテナの &lt;code&gt;Sync&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="e3262fa97dd64c6174eeff7f6dc1bf92e0938ab9" translate="yes" xml:space="preserve">
          <source>As per &lt;a href=&quot;https://tools.ietf.org/html/rfc3879&quot;&gt;RFC 3879&lt;/a&gt;, the whole &lt;code&gt;FEC0::/10&lt;/code&gt; prefix is deprecated. New software must not support site-local addresses.</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc3879&quot;&gt;RFC 3879&lt;/a&gt;に従って、 &lt;code&gt;FEC0::/10&lt;/code&gt; プレフィックス全体が非推奨になりました。新しいソフトウェアはサイトローカルアドレスをサポートしてはなりません。</target>
        </trans-unit>
        <trans-unit id="a8a04accdf6a8ca9fa81bf61cc029868f206046f" translate="yes" xml:space="preserve">
          <source>As said above, the &lt;code&gt;derive&lt;/code&gt; attribute is only allowed on structs, unions or enums:</source>
          <target state="translated">上記のように、 &lt;code&gt;derive&lt;/code&gt; 属性は構造体、共用体、または列挙型でのみ許可されます。</target>
        </trans-unit>
        <trans-unit id="51aa8d67495f62b66ef894735fcf63e6606dac28" translate="yes" xml:space="preserve">
          <source>As shown in the example above, &lt;code&gt;for&lt;/code&gt; loops (along with all other loops) can be tagged, using similar syntax to lifetimes (only visually similar, entirely distinct in practice). Giving the same tag to &lt;code&gt;break&lt;/code&gt; breaks the tagged loop, which is useful for inner loops. It is definitely not a goto.</source>
          <target state="translated">上記の例に示すように、 &lt;code&gt;for&lt;/code&gt; ループは（他のすべてのループと同様に）ライフタイムと同様の構文を使用してタグ付けできます（視覚的にのみ類似しており、実際には完全に異なります）。同じタグを &lt;code&gt;break&lt;/code&gt; 与えると、タグ付きループが壊れます。これは、内部ループに役立ちます。確かに後藤ではありません。</target>
        </trans-unit>
        <trans-unit id="ea3901788f56444df8cfba46d8496b7c3ef215ae" translate="yes" xml:space="preserve">
          <source>As slices store the length of the sequence they refer to, they have twice the size of pointers to &lt;a href=&quot;marker/trait.sized&quot;&gt;&lt;code&gt;Sized&lt;/code&gt;&lt;/a&gt; types. Also see the reference on &lt;a href=&quot;../reference/dynamically-sized-types&quot;&gt;dynamically sized types&lt;/a&gt;.</source>
          <target state="translated">スライスは、彼らが参照シーケンスの長さを格納したように、彼らはへのポインタの2倍の大き持っている&lt;a href=&quot;marker/trait.sized&quot;&gt; &lt;code&gt;Sized&lt;/code&gt; &lt;/a&gt;種類を。&lt;a href=&quot;../reference/dynamically-sized-types&quot;&gt;動的サイズのタイプ&lt;/a&gt;に関するリファレンスも参照してください。</target>
        </trans-unit>
        <trans-unit id="c276f971f322ddf36b0d0a39caeff0e860e6ee88" translate="yes" xml:space="preserve">
          <source>As stated in the User Datagram Protocol's specification in &lt;a href=&quot;https://tools.ietf.org/html/rfc768&quot;&gt;IETF RFC 768&lt;/a&gt;, UDP is an unordered, unreliable protocol; refer to &lt;a href=&quot;struct.tcplistener&quot;&gt;&lt;code&gt;TcpListener&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.tcpstream&quot;&gt;&lt;code&gt;TcpStream&lt;/code&gt;&lt;/a&gt; for TCP primitives.</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc768&quot;&gt;IETF RFC 768&lt;/a&gt;のUser Datagram Protocolの仕様で述べられているように、UDPは順序付けされておらず、信頼性が低いプロトコルです。TCPプリミティブについては、&lt;a href=&quot;struct.tcplistener&quot;&gt; &lt;code&gt;TcpListener&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;struct.tcpstream&quot;&gt; &lt;code&gt;TcpStream&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="5379cc453111a9586b0e6132f3432e2017bb8946" translate="yes" xml:space="preserve">
          <source>As string slices are a slice of bytes, the raw pointer points to a &lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;. This pointer will be pointing to the first byte of the string slice.</source>
          <target state="translated">文字列スライスはバイトのスライスであるため、生のポインタは&lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; を指し&lt;/a&gt;ます。このポインタは、文字列スライスの最初のバイトを指します。</target>
        </trans-unit>
        <trans-unit id="54d4fd727ce2657161522c6ae3a06633673c9cbd" translate="yes" xml:space="preserve">
          <source>As string slices are a slice of bytes, the raw pointer points to a &lt;a href=&quot;primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;. This pointer will be pointing to the first byte of the string slice.</source>
          <target state="translated">文字列スライスはバイトのスライスなので、生のポインタは&lt;a href=&quot;primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; を指し&lt;/a&gt;ます。このポインターは、文字列スライスの最初のバイトを指します。</target>
        </trans-unit>
        <trans-unit id="b757bf93c530db10fdab40d9aeca4c3f17d50ad1" translate="yes" xml:space="preserve">
          <source>As such, the &lt;code&gt;from_utf8&lt;/code&gt; family of functions and methods for both &lt;a href=&quot;../string/struct.string#method.from_utf8&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;s and &lt;a href=&quot;fn.from_utf8&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;s make use of this error, for example.</source>
          <target state="translated">そのため、 &lt;code&gt;from_utf8&lt;/code&gt; &lt;a href=&quot;../string/struct.string#method.from_utf8&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;fn.from_utf8&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt;の両方のfrom_utf8ファミリの関数とメソッドは、このエラーを利用します。</target>
        </trans-unit>
        <trans-unit id="a7bae3aa148344b33c64086da16dba6a42474602" translate="yes" xml:space="preserve">
          <source>As the author of a data structure you get to decide for each field whether pinning &quot;propagates&quot; to this field or not. Pinning that propagates is also called &quot;structural&quot;, because it follows the structure of the type. In the following subsections, we describe the considerations that have to be made for either choice.</source>
          <target state="translated">データ構造体の作成者として、各フィールドに対してピン留めを「伝播」するかどうかを決定することができます。伝搬するピン留めは、型の構造に従うので、「構造的」とも呼ばれます。以下の小節では、どちらを選択するかについての考慮事項を説明します。</target>
        </trans-unit>
        <trans-unit id="0b86e5cf0a558c007bb8a3eed83a07619a169108" translate="yes" xml:space="preserve">
          <source>As the error message indicates, only &lt;code&gt;u8&lt;/code&gt; can be cast into &lt;code&gt;char&lt;/code&gt;. Example:</source>
          <target state="translated">エラーメッセージが示すように、 &lt;code&gt;u8&lt;/code&gt; のみを &lt;code&gt;char&lt;/code&gt; にキャストできます。例：</target>
        </trans-unit>
        <trans-unit id="6c037f01ab1e44c1b49068f96530e00f210988e8" translate="yes" xml:space="preserve">
          <source>As the target platform's native endianness is used, portable code likely wants to use &lt;a href=&quot;#method.from_be_bytes&quot;&gt;&lt;code&gt;from_be_bytes&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#method.from_le_bytes&quot;&gt;&lt;code&gt;from_le_bytes&lt;/code&gt;&lt;/a&gt;, as appropriate instead.</source>
          <target state="translated">ターゲットプラットフォームのネイティブエンディアンが使用されているため、ポータブルコードでは、代わりに適切に&lt;a href=&quot;#method.from_be_bytes&quot;&gt; &lt;code&gt;from_be_bytes&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;#method.from_le_bytes&quot;&gt; &lt;code&gt;from_le_bytes&lt;/code&gt; &lt;/a&gt;を使用する可能性があります。</target>
        </trans-unit>
        <trans-unit id="1c8bfefec8dafcbb055c2ea433ad31a56feecccd" translate="yes" xml:space="preserve">
          <source>As the target platform's native endianness is used, portable code should use &lt;a href=&quot;#method.to_be_bytes&quot;&gt;&lt;code&gt;to_be_bytes&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#method.to_le_bytes&quot;&gt;&lt;code&gt;to_le_bytes&lt;/code&gt;&lt;/a&gt;, as appropriate, instead.</source>
          <target state="translated">ターゲットプラットフォームのネイティブエンディアンが使用されているため、移植可能なコードでは、代わりに&lt;a href=&quot;#method.to_be_bytes&quot;&gt; &lt;code&gt;to_be_bytes&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;#method.to_le_bytes&quot;&gt; &lt;code&gt;to_le_bytes&lt;/code&gt; &lt;/a&gt;を適切に使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="c2aae14d23e6b4a7f032b38d8e95a4d1b336b019" translate="yes" xml:space="preserve">
          <source>As this is the only method for this trait, the &lt;a href=&quot;trait.extend&quot;&gt;trait-level&lt;/a&gt; docs contain more details.</source>
          <target state="translated">これはこの特性の唯一の方法であるため、&lt;a href=&quot;trait.extend&quot;&gt;特性レベルの&lt;/a&gt;ドキュメントには詳細が含まれています。</target>
        </trans-unit>
        <trans-unit id="3b3bf99d81b548977e24e38bef4df0cf86423b5b" translate="yes" xml:space="preserve">
          <source>As this is the only required method for this trait, the &lt;a href=&quot;trait.extend&quot;&gt;trait-level&lt;/a&gt; docs contain more details.</source>
          <target state="translated">これがこのトレイトに必要な唯一の方法であるため、&lt;a href=&quot;trait.extend&quot;&gt;トレイトレベルの&lt;/a&gt;ドキュメントには詳細が含まれています。</target>
        </trans-unit>
        <trans-unit id="f292830332806677ad0b0527bf74ceadc350e53c" translate="yes" xml:space="preserve">
          <source>As usual, this output tells us exactly what has gone wrong.</source>
          <target state="translated">いつものように、この出力は何が間違っていたのかを正確に教えてくれます。</target>
        </trans-unit>
        <trans-unit id="6d6b5c58bde3c21428520a679924eb54e0901d4d" translate="yes" xml:space="preserve">
          <source>As we did with structs, we can define enums to hold generic data types in their variants. Let&amp;rsquo;s take another look at the &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; enum that the standard library provides, which we used in Chapter 6:</source>
          <target state="translated">構造体で行ったように、列挙型を定義して、バリアントに汎用データ型を保持できます。第6章で使用した、標準ライブラリが提供する &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 列挙型をもう一度見てみましょう。</target>
        </trans-unit>
        <trans-unit id="c9b62e53d822366f9040eaf9632aa096cd8d407c" translate="yes" xml:space="preserve">
          <source>As we saw when we printed the vector, the program&amp;rsquo;s name takes up the first value in the vector at &lt;code&gt;args[0]&lt;/code&gt;, so we&amp;rsquo;re starting at index &lt;code&gt;1&lt;/code&gt;. The first argument &lt;code&gt;minigrep&lt;/code&gt; takes is the string we&amp;rsquo;re searching for, so we put a reference to the first argument in the variable &lt;code&gt;query&lt;/code&gt;. The second argument will be the filename, so we put a reference to the second argument in the variable &lt;code&gt;filename&lt;/code&gt;.</source>
          <target state="translated">ベクトルを出力したときに見たように、プログラムの名前は &lt;code&gt;args[0]&lt;/code&gt; にあるベクトルの最初の値を占めるため、インデックス &lt;code&gt;1&lt;/code&gt; から始めます。 &lt;code&gt;minigrep&lt;/code&gt; が取る最初の引数は、検索する文字列なので、変数 &lt;code&gt;query&lt;/code&gt; に最初の引数への参照を置きます。2番目の引数はファイル名になるため、2番目の引数への参照を変数 &lt;code&gt;filename&lt;/code&gt; に入れます。</target>
        </trans-unit>
        <trans-unit id="387526bcd86a3d932ce8d276666fe3de9ea36fb2" translate="yes" xml:space="preserve">
          <source>As well as overloading the unary &lt;code&gt;*&lt;/code&gt; operator, &lt;a href=&quot;../std/ops/trait.deref&quot;&gt;&lt;code&gt;Deref&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../std/ops/trait.derefmut&quot;&gt;&lt;code&gt;DerefMut&lt;/code&gt;&lt;/a&gt; are also used in &lt;a href=&quot;expressions/method-call-expr&quot;&gt;method resolution&lt;/a&gt; and &lt;a href=&quot;type-coercions#coercion-types&quot;&gt;deref coercions&lt;/a&gt;.</source>
          <target state="translated">同様に単項オーバーロードとして &lt;code&gt;*&lt;/code&gt; 演算子を、&lt;a href=&quot;../std/ops/trait.deref&quot;&gt; &lt;code&gt;Deref&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../std/ops/trait.derefmut&quot;&gt; &lt;code&gt;DerefMut&lt;/code&gt; は&lt;/a&gt;またで使用されている&lt;a href=&quot;expressions/method-call-expr&quot;&gt;方法の分解能&lt;/a&gt;及び&lt;a href=&quot;type-coercions#coercion-types&quot;&gt;DEREF型変換&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="00f0078e7027bdd5fb06a3cdb9f947f1a54e08c1" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;#method.as_ref&quot;&gt;&lt;code&gt;as_ref&lt;/code&gt;&lt;/a&gt;, this is unsafe because it cannot verify the validity of the returned pointer, nor can it ensure that the lifetime &lt;code&gt;'a&lt;/code&gt; returned is indeed a valid lifetime for the contained data.</source>
          <target state="translated">&lt;a href=&quot;#method.as_ref&quot;&gt; &lt;code&gt;as_ref&lt;/code&gt; &lt;/a&gt;と同様に、返されたポインタの有効性を検証できず &lt;code&gt;'a&lt;/code&gt; 返された有効期間が実際に含まれているデータの有効な有効期間であることを保証できないため、これは安全ではありません。</target>
        </trans-unit>
        <trans-unit id="700b249dcaa7ad65d8fbe7b2f99bd14fed03c63b" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;../mem/union.maybeuninit#method.assume_init&quot;&gt;&lt;code&gt;MaybeUninit::assume_init&lt;/code&gt;&lt;/a&gt;, it is up to the caller to guarantee that the inner value really is in an initialized state. Calling this when the content is not yet fully initialized causes immediate undefined behavior.</source>
          <target state="translated">&lt;a href=&quot;../mem/union.maybeuninit#method.assume_init&quot;&gt; &lt;code&gt;MaybeUninit::assume_init&lt;/code&gt; &lt;/a&gt;と同様に、内部値が実際に初期化された状態にあることを保証するのは呼び出し元の責任です。コンテンツがまだ完全に初期化されていないときにこれを呼び出すと、すぐに未定義の動作が発生します。</target>
        </trans-unit>
        <trans-unit id="b569f01826b7a489e1b0df46d3df2feea0987b31" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;../mem/union.maybeuninit#method.assume_init&quot;&gt;&lt;code&gt;MaybeUninit::assume_init&lt;/code&gt;&lt;/a&gt;, it is up to the caller to guarantee that the value really is in an initialized state. Calling this when the content is not yet fully initialized causes immediate undefined behavior.</source>
          <target state="translated">&lt;a href=&quot;../mem/union.maybeuninit#method.assume_init&quot;&gt; &lt;code&gt;MaybeUninit::assume_init&lt;/code&gt; &lt;/a&gt;と同様に、値が実際に初期化された状態にあることを保証するのは呼び出し元の責任です。コンテンツがまだ完全に初期化されていないときにこれを呼び出すと、すぐに未定義の動作が発生します。</target>
        </trans-unit>
        <trans-unit id="b5a160954fc2e5db9027a60b41aea2242946a496" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;../mem/union.maybeuninit#method.assume_init&quot;&gt;&lt;code&gt;MaybeUninit::assume_init&lt;/code&gt;&lt;/a&gt;, it is up to the caller to guarantee that the values really are in an initialized state. Calling this when the content is not yet fully initialized causes immediate undefined behavior.</source>
          <target state="translated">&lt;a href=&quot;../mem/union.maybeuninit#method.assume_init&quot;&gt; &lt;code&gt;MaybeUninit::assume_init&lt;/code&gt; &lt;/a&gt;と同様に、値が実際に初期化された状態にあることを保証するのは呼び出し元の責任です。コンテンツがまだ完全に初期化されていないときにこれを呼び出すと、すぐに未定義の動作が発生します。</target>
        </trans-unit>
        <trans-unit id="e824f1a2f05ba862631703f190681d4c2dd2b70b" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;use-declarations#underscore-imports&quot;&gt;underscore imports&lt;/a&gt;, macros may safely emit the same unnamed constant in the same scope more than once. For example, the following should not produce an error:</source>
          <target state="translated">&lt;a href=&quot;use-declarations#underscore-imports&quot;&gt;アンダースコアのインポート&lt;/a&gt;と同様に、マクロは同じスコープ内で同じ名前のない定数を複数回安全に発行できます。たとえば、次の場合はエラーが発生しないはずです。</target>
        </trans-unit>
        <trans-unit id="4c083e9f314596dd1da24d21de9af221cdf99253" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;let&lt;/code&gt; bindings, function arguments are irrefutable &lt;a href=&quot;../patterns&quot;&gt;patterns&lt;/a&gt;, so any pattern that is valid in a let binding is also valid as an argument:</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; バインディングと同様に、関数の引数は反駁できない&lt;a href=&quot;../patterns&quot;&gt;パターン&lt;/a&gt;であるため、letバインディングで有効なパターンはすべて引数としても有効です。</target>
        </trans-unit>
        <trans-unit id="021860f0b9c701b01e24f471ef9064ff787c7fc6" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;split()&lt;/code&gt;, if the first or last element is matched, an empty slice will be the first (or last) item returned by the iterator.</source>
          <target state="translated">同様に &lt;code&gt;split()&lt;/code&gt; 最初または最後の要素が一致した場合、空のスライスが反復子によって返される最初（または最後）の項目であろう。</target>
        </trans-unit>
        <trans-unit id="a311c5a68716dfa8ec04c201fd72e1f6bf20977d" translate="yes" xml:space="preserve">
          <source>As with any variable, if we want to be able to change its value, we need to make it mutable using the &lt;code&gt;mut&lt;/code&gt; keyword, as discussed in Chapter 3. The numbers we place inside are all of type &lt;code&gt;i32&lt;/code&gt;, and Rust infers this from the data, so we don&amp;rsquo;t need the &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; annotation.</source>
          <target state="translated">他の変数と同様に、その値を変更できるようにするには、第3章で説明したように、 &lt;code&gt;mut&lt;/code&gt; キーワードを使用して変数を可変にする必要があります。内部に配置する数値はすべて &lt;code&gt;i32&lt;/code&gt; 型であり、Rustはこれをデータなので、 &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; アノテーションは必要ありません。</target>
        </trans-unit>
        <trans-unit id="4275e8a23f25e311b7879f2ca06bcf06be2ae3c3" translate="yes" xml:space="preserve">
          <source>As with many types, we create a &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; using the associated function &lt;code&gt;new&lt;/code&gt;. To access the data inside the mutex, we use the &lt;code&gt;lock&lt;/code&gt; method to acquire the lock. This call will block the current thread so it can&amp;rsquo;t do any work until it&amp;rsquo;s our turn to have the lock.</source>
          <target state="translated">多くの型と同様に、関連する関数 &lt;code&gt;new&lt;/code&gt; を使用して &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; を作成します。mutex内のデータにアクセスするには、 &lt;code&gt;lock&lt;/code&gt; メソッドを使用してロックを取得します。この呼び出しは現在のスレッドをブロックするので、ロックを取得する番になるまで、スレッドは何もできません。</target>
        </trans-unit>
        <trans-unit id="35a5907e5dda02884b0d94275e42a50fca56e187" translate="yes" xml:space="preserve">
          <source>As with regular variables, we specify mutability using the &lt;code&gt;mut&lt;/code&gt; keyword. Any code that reads or writes from &lt;code&gt;COUNTER&lt;/code&gt; must be within an &lt;code&gt;unsafe&lt;/code&gt; block. This code compiles and prints &lt;code&gt;COUNTER: 3&lt;/code&gt; as we would expect because it&amp;rsquo;s single threaded. Having multiple threads access &lt;code&gt;COUNTER&lt;/code&gt; would likely result in data races.</source>
          <target state="translated">通常の変数と同様に、 &lt;code&gt;mut&lt;/code&gt; キーワードを使用して可変性を指定します。 &lt;code&gt;COUNTER&lt;/code&gt; から読み取りまたは書き込みを行うコードは、 &lt;code&gt;unsafe&lt;/code&gt; ブロック内にある必要があります。このコードは、シングルスレッドであるため、予想どおり &lt;code&gt;COUNTER: 3&lt;/code&gt; をコンパイルして出力します。複数のスレッドが &lt;code&gt;COUNTER&lt;/code&gt; にアクセスすると、データの競合が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="d8272d2e249bc06a5d6f6ca737f5c0ac8a4d70c5" translate="yes" xml:space="preserve">
          <source>As with the &lt;a href=&quot;../hash_map/struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; type, a &lt;code&gt;HashSet&lt;/code&gt; requires that the elements implement the &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; traits. This can frequently be achieved by using &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt;. If you implement these yourself, it is important that the following property holds:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3db9d1e08dae612689e0b7adf381cac76d2a83bc" translate="yes" xml:space="preserve">
          <source>As with the &lt;a href=&quot;../struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; type, a &lt;code&gt;HashSet&lt;/code&gt; requires that the elements implement the &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; traits. This can frequently be achieved by using &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt;. If you implement these yourself, it is important that the following property holds:</source>
          <target state="translated">同様&lt;a href=&quot;../struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;タイプ、 &lt;code&gt;HashSet&lt;/code&gt; のは、要素が実装する必要&lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt;特性を。これは、 &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt; を使用することで頻繁に実現できます。これらを自分で実装する場合は、次のプロパティが成り立つことが重要です。</target>
        </trans-unit>
        <trans-unit id="484bca70aea1a557734e7bf929079e6ee00fa7d3" translate="yes" xml:space="preserve">
          <source>As with the &lt;a href=&quot;hash_map/struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; type, a &lt;code&gt;HashSet&lt;/code&gt; requires that the elements implement the &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; traits. This can frequently be achieved by using &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt;. If you implement these yourself, it is important that the following property holds:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fb7b19ef9483e218deb8b0d1a3f5269874b86ed" translate="yes" xml:space="preserve">
          <source>As with the &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; type, a &lt;code&gt;HashSet&lt;/code&gt; requires that the elements implement the &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; traits. This can frequently be achieved by using &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt;. If you implement these yourself, it is important that the following property holds:</source>
          <target state="translated">同様&lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;タイプ、 &lt;code&gt;HashSet&lt;/code&gt; のは、要素が実装する必要&lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt;特性を。これは、 &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt; を使用して頻繁に実現できます。これらを自分で実装する場合、次のプロパティが保持されていることが重要です。</target>
        </trans-unit>
        <trans-unit id="c568bda8aab01e836f5470185110a68fb4739aa1" translate="yes" xml:space="preserve">
          <source>As with the &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; type, a &lt;code&gt;HashSet&lt;/code&gt; requires that the elements implement the &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; traits. This can frequently be achieved by using &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt;. If you implement these yourself, it is important that the following property holds:</source>
          <target state="translated">同様&lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt;タイプ、 &lt;code&gt;HashSet&lt;/code&gt; のは、要素が実装する必要&lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt;特性を。これは、 &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt; を使用して頻繁に実現できます。これらを自分で実装する場合、次のプロパティが保持されていることが重要です。</target>
        </trans-unit>
        <trans-unit id="ae28ea4c57639b6218be246b12eabdfb50b7b74a" translate="yes" xml:space="preserve">
          <source>As with variables, we can add type annotations if we want to increase explicitness and clarity at the cost of being more verbose than is strictly necessary. Annotating the types for the closure we defined in Listing 13-5 would look like the definition shown in Listing 13-7.</source>
          <target state="translated">変数の場合と同じように、厳密に必要以上に冗長であることを犠牲にして明示性と明快さを高めたい場合、型のアノテーションを追加できます。リスト13-5で定義したクロージャのための型のアノテーションはリスト13-7で示される定義のようになります。</target>
        </trans-unit>
        <trans-unit id="96c2069203f702eae6427926792a296cebb74618" translate="yes" xml:space="preserve">
          <source>As you add more integration tests, you might want to make more than one file in the &lt;em&gt;tests&lt;/em&gt; directory to help organize them; for example, you can group the test functions by the functionality they&amp;rsquo;re testing. As mentioned earlier, each file in the &lt;em&gt;tests&lt;/em&gt; directory is compiled as its own separate crate.</source>
          <target state="translated">統合テストを追加する場合、それらを整理するために、&lt;em&gt;tests&lt;/em&gt;ディレクトリに複数のファイルを作成することができます。たとえば、テストする機能ごとにテスト関数をグループ化できます。前述のように、&lt;em&gt;tests&lt;/em&gt;ディレクトリの各ファイルは、独自のクレートとしてコンパイルされます。</target>
        </trans-unit>
        <trans-unit id="064638b9138d50bf7a76d4f1fb8907e6d00d4af4" translate="yes" xml:space="preserve">
          <source>As you also learned in Chapter 1, &lt;code&gt;println!&lt;/code&gt; is a macro that prints a string to the screen:</source>
          <target state="translated">第1章でも学習したように、 &lt;code&gt;println!&lt;/code&gt; 画面に文字列を出力するマクロです：</target>
        </trans-unit>
        <trans-unit id="cfbf1a7efc3caed67bc7e41bd453d7589ffb22d8" translate="yes" xml:space="preserve">
          <source>As you can see in the signature of &lt;code&gt;spawn&lt;/code&gt; there are two constraints on both the closure given to &lt;code&gt;spawn&lt;/code&gt; and its return value, let's explain them:</source>
          <target state="translated">あなたはの署名で見ることができるように &lt;code&gt;spawn&lt;/code&gt; に与えられたクロージャの両方に2つの制約がある &lt;code&gt;spawn&lt;/code&gt; し、その戻り値は、のは、それらを説明しましょう：</target>
        </trans-unit>
        <trans-unit id="0420fe0c9530d1e1d147961f14b139b3fe83e9e2" translate="yes" xml:space="preserve">
          <source>As you can see, the stable toolchain is the default. Most Rust users use stable most of the time. You might want to use stable most of the time, but use nightly on a specific project, because you care about a cutting-edge feature. To do so, you can use &lt;code&gt;rustup override&lt;/code&gt; in that project&amp;rsquo;s directory to set the nightly toolchain as the one &lt;code&gt;rustup&lt;/code&gt; should use when you&amp;rsquo;re in that directory:</source>
          <target state="translated">ご覧のとおり、安定したツールチェーンがデフォルトです。ほとんどのRustユーザーは、ほとんどの場合、安定版を使用しています。ほとんどの場合は安定版を使用することをお勧めしますが、最先端の機能に関心があるため、特定のプロジェクトでは毎晩使用します。これを行うには、そのプロジェクトのディレクトリで &lt;code&gt;rustup override&lt;/code&gt; を使用して、そのディレクトリにいるときに &lt;code&gt;rustup&lt;/code&gt; が使用する必要があるナイトリーツールチェーンを設定します。</target>
        </trans-unit>
        <trans-unit id="9d87736b18e618ced4be36c042766a61a7024b14" translate="yes" xml:space="preserve">
          <source>As you can see, this will return the expected, valid items.</source>
          <target state="translated">ご覧のように、これは期待された有効なアイテムを返します。</target>
        </trans-unit>
        <trans-unit id="2afcd0df9449bfb1b32a67c779124a1b65363260" translate="yes" xml:space="preserve">
          <source>As you can see, using the parent modules distinguishes the two &lt;code&gt;Result&lt;/code&gt; types. If instead we specified &lt;code&gt;use std::fmt::Result&lt;/code&gt; and &lt;code&gt;use std::io::Result&lt;/code&gt;, we&amp;rsquo;d have two &lt;code&gt;Result&lt;/code&gt; types in the same scope and Rust wouldn&amp;rsquo;t know which one we meant when we used &lt;code&gt;Result&lt;/code&gt;.</source>
          <target state="translated">ご覧のとおり、親モジュールを使用すると、2つの &lt;code&gt;Result&lt;/code&gt; タイプが区別されます。代わりに &lt;code&gt;use std::fmt::Result&lt;/code&gt; と &lt;code&gt;use std::io::Result&lt;/code&gt; を指定した場合、同じスコープ内に2つの &lt;code&gt;Result&lt;/code&gt; タイプがあり、Rustは &lt;code&gt;Result&lt;/code&gt; を使用したときにどちらが意図されているかを認識しません。</target>
        </trans-unit>
        <trans-unit id="20722bacbfbb971e3e58847f05a0049adb3a009e" translate="yes" xml:space="preserve">
          <source>As you can see, we&amp;rsquo;ve moved everything into a loop from the guess input prompt onward. Be sure to indent the lines inside the loop another four spaces each and run the program again. Notice that there is a new problem because the program is doing exactly what we told it to do: ask for another guess forever! It doesn&amp;rsquo;t seem like the user can quit!</source>
          <target state="translated">ご覧のとおり、すべてを推測入力プロンプトからループに移動しています。ループ内の行をそれぞれ4つずつインデントして、プログラムを再度実行してください。プログラムが実行するように指示したとおりにプログラムが実行しているため、新しい問題があることに注意してください。永遠に別の推測を求めてください！ユーザーが終了できるようではありません！</target>
        </trans-unit>
        <trans-unit id="ac1ee84193bb1d8e87992969494a2311a45eebb9" translate="yes" xml:space="preserve">
          <source>As you can see, you can specify type parameters in curly braces for substitution with the actual types (using the regular format string syntax) in a given situation. Furthermore, &lt;code&gt;{Self}&lt;/code&gt; will substitute to the type (in this case, &lt;code&gt;bool&lt;/code&gt;) that we tried to use.</source>
          <target state="translated">ご覧のとおり、特定の状況で（通常のフォーマット文字列構文を使用して）実際の型で置換するために、中括弧で型パラメーターを指定できます。さらに、 &lt;code&gt;{Self}&lt;/code&gt; は、使用しようとしたタイプ（この場合は &lt;code&gt;bool&lt;/code&gt; ）に置き換えられます。</target>
        </trans-unit>
        <trans-unit id="b2e9ae4479b0983efbf6a5f5ed8ba7b27ba6777d" translate="yes" xml:space="preserve">
          <source>As you could see, in many aspects (except for layouts, safety and ownership) unions behave exactly like structs, largely as a consequence of inheriting their syntactic shape from structs. This is also true for many unmentioned aspects of Rust language (such as privacy, name resolution, type inference, generics, trait implementations, inherent implementations, coherence, pattern checking, etc etc etc).</source>
          <target state="translated">ご覧のように、(レイアウト、安全性、所有権を除いて)組合は多くの面で構造体と全く同じように動作します。これは、Rust言語の多くの未言及の側面(プライバシー、名前解決、型推論、ジェネリック、形質実装、固有の実装、コヒーレンス、パターンチェックなど)にも当てはまります。</target>
        </trans-unit>
        <trans-unit id="82fa816a0b7088673d7a49e7db89040e62362916" translate="yes" xml:space="preserve">
          <source>As you could see, in many aspects (except for layouts, safety, and ownership) unions behave exactly like structs, largely as a consequence of inheriting their syntactic shape from structs. This is also true for many unmentioned aspects of Rust language (such as privacy, name resolution, type inference, generics, trait implementations, inherent implementations, coherence, pattern checking, etc etc etc).</source>
          <target state="translated">ご覧のように、多くの面で(レイアウト、安全性、所有権を除いて)組合は構造体と全く同じように動作します。これは、Rust言語の多くの未言及の側面(プライバシー、名前解決、型推論、ジェネリック、形質実装、固有の実装、コヒーレンス、パターンチェックなど)にも当てはまります。</target>
        </trans-unit>
        <trans-unit id="b701fb6519447ef85d48d0e79a042ed086034a11" translate="yes" xml:space="preserve">
          <source>As you learned in Chapter 16, &lt;code&gt;thread::spawn&lt;/code&gt; will create a new thread and then run the code in the closure in the new thread. If you run this code and load &lt;em&gt;/sleep&lt;/em&gt; in your browser, then &lt;em&gt;/&lt;/em&gt; in two more browser tabs, you&amp;rsquo;ll indeed see that the requests to &lt;em&gt;/&lt;/em&gt; don&amp;rsquo;t have to wait for &lt;em&gt;/sleep&lt;/em&gt; to finish. But as we mentioned, this will eventually overwhelm the system because you&amp;rsquo;d be making new threads without any limit.</source>
          <target state="translated">第16章で学習したように、 &lt;code&gt;thread::spawn&lt;/code&gt; は新しいスレッドを作成し、その新しいスレッドのクロージャーでコードを実行します。あなたはこのコードとロード実行した場合&lt;em&gt;/睡眠を&lt;/em&gt;お使いのブラウザで、その後&lt;em&gt;/&lt;/em&gt; 2以上のブラウザのタブで、あなたは確かに要求することを確認できます&lt;em&gt;/&lt;/em&gt;を待つ必要はありません&lt;em&gt;/スリープ&lt;/em&gt;仕上げにします。しかし、前述したように、制限なく新しいスレッドを作成するため、これは最終的にシステムを圧倒します。</target>
        </trans-unit>
        <trans-unit id="f4d2e2ae7d1d7339cbe38cf89981448ff9804651" translate="yes" xml:space="preserve">
          <source>As you might have guessed, &lt;code&gt;continue&lt;/code&gt; has a &lt;code&gt;!&lt;/code&gt; value. That is, when Rust computes the type of &lt;code&gt;guess&lt;/code&gt;, it looks at both match arms, the former with a value of &lt;code&gt;u32&lt;/code&gt; and the latter with a &lt;code&gt;!&lt;/code&gt; value. Because &lt;code&gt;!&lt;/code&gt; can never have a value, Rust decides that the type of &lt;code&gt;guess&lt;/code&gt; is &lt;code&gt;u32&lt;/code&gt;.</source>
          <target state="translated">ご想像のとおり、 &lt;code&gt;continue&lt;/code&gt; には &lt;code&gt;!&lt;/code&gt; 値。つまり、Rustが &lt;code&gt;guess&lt;/code&gt; のタイプを計算するときに、両方のマッチアームを調べます。前者は &lt;code&gt;u32&lt;/code&gt; の値で、後者は &lt;code&gt;!&lt;/code&gt; 値。なぜなら &lt;code&gt;!&lt;/code&gt; Rustは決して値を持つことができないため、 &lt;code&gt;guess&lt;/code&gt; のタイプは &lt;code&gt;u32&lt;/code&gt; であると判断します。</target>
        </trans-unit>
        <trans-unit id="467cfe4dd8e4d010791398ae5c6bd0fbee6d53ca" translate="yes" xml:space="preserve">
          <source>As you might suspect, &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; is a smart pointer. More accurately, the call to &lt;code&gt;lock&lt;/code&gt;&lt;em&gt;returns&lt;/em&gt; a smart pointer called &lt;code&gt;MutexGuard&lt;/code&gt;, wrapped in a &lt;code&gt;LockResult&lt;/code&gt; that we handled with the call to &lt;code&gt;unwrap&lt;/code&gt;. The &lt;code&gt;MutexGuard&lt;/code&gt; smart pointer implements &lt;code&gt;Deref&lt;/code&gt; to point at our inner data; the smart pointer also has a &lt;code&gt;Drop&lt;/code&gt; implementation that releases the lock automatically when a &lt;code&gt;MutexGuard&lt;/code&gt; goes out of scope, which happens at the end of the inner scope in Listing 16-12. As a result, we don&amp;rsquo;t risk forgetting to release the lock and blocking the mutex from being used by other threads because the lock release happens automatically.</source>
          <target state="translated">ご &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; とおり、Mutex &amp;lt;T&amp;gt;はスマートポインターです。より正確には、への呼び出し &lt;code&gt;lock&lt;/code&gt; &lt;em&gt;返す&lt;/em&gt;と呼ばれるスマートポインタ &lt;code&gt;MutexGuard&lt;/code&gt; に包まれ、 &lt;code&gt;LockResult&lt;/code&gt; 我々はへの呼び出しで処理することを &lt;code&gt;unwrap&lt;/code&gt; 。 &lt;code&gt;MutexGuard&lt;/code&gt; スマートポインタを実装 &lt;code&gt;Deref&lt;/code&gt; 私たちの内部データを指すように。スマートポインターには、 &lt;code&gt;MutexGuard&lt;/code&gt; の実行時にロックを自動的に解放する &lt;code&gt;Drop&lt;/code&gt; 実装もあります。リスト16-12の内部スコープの最後で発生するスコープ外。その結果、ロックの解放が自動的に行われるため、ロックの解放を忘れて他のスレッドによるミューテックスの使用をブロックするリスクがありません。</target>
        </trans-unit>
        <trans-unit id="e4e495363e711b35cf1aef444d4c023b03ec561b" translate="yes" xml:space="preserve">
          <source>As you saw in Chapter 1, &lt;code&gt;cargo new&lt;/code&gt; generates a &amp;ldquo;Hello, world!&amp;rdquo; program for you. Check out the &lt;em&gt;src/main.rs&lt;/em&gt; file:</source>
          <target state="translated">第1章で見たように、 &lt;code&gt;cargo new&lt;/code&gt; は「Hello、world！」を生成します。あなたのためのプログラム。&lt;em&gt;src / main.rs&lt;/em&gt;ファイルを確認します。</target>
        </trans-unit>
        <trans-unit id="acce671b7472bf5e5eaabe31a3ccfe6aca667c9d" translate="yes" xml:space="preserve">
          <source>As you saw in Chapter 1, the &lt;code&gt;main&lt;/code&gt; function is the entry point into the program:</source>
          <target state="translated">第1章で見たように、 &lt;code&gt;main&lt;/code&gt; 機能はプログラムへのエントリポイントです。</target>
        </trans-unit>
        <trans-unit id="1b995f5c38439d41d9506c07ed8d2188c4fc0f99" translate="yes" xml:space="preserve">
          <source>As you saw in Chapter 6, you can match patterns against literals directly. The following code gives some examples:</source>
          <target state="translated">第6章で見たように、パターンとリテラルを直接一致させることができます。次のコードはいくつかの例を示しています。</target>
        </trans-unit>
        <trans-unit id="fa0b472a10784179b99aa6fee609e3cfddb9cc55" translate="yes" xml:space="preserve">
          <source>As you saw in Listing 17-15, we can write methods that use the syntax &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt;, which allows the method to take ownership of a &lt;code&gt;Self&lt;/code&gt; value stored in a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;. That&amp;rsquo;s exactly what we want to do here, but unfortunately Rust won&amp;rsquo;t let us: the part of Rust that implements behavior when a closure is called isn&amp;rsquo;t implemented using &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt;. So Rust doesn&amp;rsquo;t yet understand that it could use &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt; in this situation to take ownership of the closure and move the closure out of the &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">リスト17-15で見たように、構文 &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt; を使用するメソッドを書くことができます。これにより、メソッドは &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 格納されている &lt;code&gt;Self&lt;/code&gt; 値の所有権を取得できます。これがまさにここでしたいことですが、残念ながらRustは許可しません。Rustのクロージャーが呼び出されたときに動作を実装する部分は、 &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt; を使用して実装されていません。そのため、Rustは、この状況でクロージャの所有権を取得してクロージャを &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; から移動するために &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt; を使用できることをまだ理解していません。</target>
        </trans-unit>
        <trans-unit id="5d8ebbcc7fc2cf4e602d0e1985852befad2da85e" translate="yes" xml:space="preserve">
          <source>As you saw in the guessing game tutorial in the &lt;a href=&quot;ch02-00-guessing-game-tutorial#comparing-the-guess-to-the-secret-number&quot;&gt;&amp;ldquo;Comparing the Guess to the Secret Number&amp;rdquo;&lt;/a&gt; section in Chapter 2, you can declare a new variable with the same name as a previous variable, and the new variable shadows the previous variable. Rustaceans say that the first variable is &lt;em&gt;shadowed&lt;/em&gt; by the second, which means that the second variable&amp;rsquo;s value is what appears when the variable is used. We can shadow a variable by using the same variable&amp;rsquo;s name and repeating the use of the &lt;code&gt;let&lt;/code&gt; keyword as follows:</source>
          <target state="translated">第2章の&lt;a href=&quot;ch02-00-guessing-game-tutorial#comparing-the-guess-to-the-secret-number&quot;&gt;「推測と秘密の番号の比較」&lt;/a&gt;セクションの推測ゲームチュートリアルで見たように、以前の変数と同じ名前で新しい変数を宣言でき、新しい変数は以前の変数をシャドウします。錆びた人は、最初の変数が2番目の変数によって&lt;em&gt;隠さ&lt;/em&gt;れていると言います。つまり、2番目の変数の値は、変数が使用されたときに表示されるものです。同じ変数の名前を使用し、次のように &lt;code&gt;let&lt;/code&gt; キーワードの使用を繰り返すことで、変数をシャドウできます。</target>
        </trans-unit>
        <trans-unit id="c47b398566173be1e06632198f7039025f10ae00" translate="yes" xml:space="preserve">
          <source>As you write large programs, organizing your code will be important because keeping track of your entire program in your head will become impossible. By grouping related functionality and separating code with distinct features, you&amp;rsquo;ll clarify where to find code that implements a particular feature and where to go to change how a feature works.</source>
          <target state="translated">大規模なプログラムを作成する場合、プログラム全体を頭の中で追跡することが不可能になるため、コードを編成することが重要になります。関連する機能をグループ化し、個別の機能を持つコードを分離することで、特定の機能を実装するコードの場所と、機能の動作を変更する場所を明確にします。</target>
        </trans-unit>
        <trans-unit id="a48835105e35976d30850d6478e3e8cb37ac0bc5" translate="yes" xml:space="preserve">
          <source>As your project grows, consider using a workspace: it&amp;rsquo;s easier to understand smaller, individual components than one big blob of code. Furthermore, keeping the crates in a workspace can make coordination between them easier if they are often changed at the same time.</source>
          <target state="translated">プロジェクトが成長するにつれて、ワークスペースの使用を検討してください。1つの大きなコードの塊よりも小さな個々のコンポーネントを理解する方が簡単です。さらに、ワークスペースにクレートを保持すると、同時に頻繁に変更される場合に、クレート間の調整が容易になります。</target>
        </trans-unit>
        <trans-unit id="db2e27ecee3ef7df382d73da5185cf2c81a313eb" translate="yes" xml:space="preserve">
          <source>AsMut</source>
          <target state="translated">AsMut</target>
        </trans-unit>
        <trans-unit id="9dee5144fa49d1023659054cfeb7b935d110f729" translate="yes" xml:space="preserve">
          <source>AsMut::as_mut</source>
          <target state="translated">AsMut::as_mut</target>
        </trans-unit>
        <trans-unit id="fa6cbff29c8fee2a75af18139d6ec5d8bb30e951" translate="yes" xml:space="preserve">
          <source>AsRawFd</source>
          <target state="translated">AsRawFd</target>
        </trans-unit>
        <trans-unit id="bf4b7b3bd11f76d54ac78e508bf69a1df97a73ab" translate="yes" xml:space="preserve">
          <source>AsRawHandle</source>
          <target state="translated">AsRawHandle</target>
        </trans-unit>
        <trans-unit id="bcb7263b347977861cfead462a0183ddbacb93a0" translate="yes" xml:space="preserve">
          <source>AsRawSocket</source>
          <target state="translated">AsRawSocket</target>
        </trans-unit>
        <trans-unit id="ecb4ad32c0bbcb0030bdba05dd0126fda307a2ef" translate="yes" xml:space="preserve">
          <source>AsRef</source>
          <target state="translated">AsRef</target>
        </trans-unit>
        <trans-unit id="ce713a708d26f349ef9d3da2c64c32c52ede1f28" translate="yes" xml:space="preserve">
          <source>AsRef::as_ref</source>
          <target state="translated">AsRef::as_ref</target>
        </trans-unit>
        <trans-unit id="a4ef661b82f652f581223b25a6824dec40ae544d" translate="yes" xml:space="preserve">
          <source>AsciiExt</source>
          <target state="translated">AsciiExt</target>
        </trans-unit>
        <trans-unit id="46e0dda46ad92722f1539fd012c3778f39c3b187" translate="yes" xml:space="preserve">
          <source>AsciiExt::eq_ignore_ascii_case</source>
          <target state="translated">AsciiExt::eq_ignore_ascii_case</target>
        </trans-unit>
        <trans-unit id="afaf433bc6efc0517fc1bdeb6f7c5eafce3e74d4" translate="yes" xml:space="preserve">
          <source>AsciiExt::is_ascii</source>
          <target state="translated">AsciiExt::is_ascii</target>
        </trans-unit>
        <trans-unit id="a117348e90cbeb6580ea282ea76b737d649c0ce2" translate="yes" xml:space="preserve">
          <source>AsciiExt::make_ascii_lowercase</source>
          <target state="translated">AsciiExt::make_ascii_lowercase</target>
        </trans-unit>
        <trans-unit id="014f8e9aa886e527dbae3bd8a29a0232814779eb" translate="yes" xml:space="preserve">
          <source>AsciiExt::make_ascii_uppercase</source>
          <target state="translated">AsciiExt::make_ascii_uppercase</target>
        </trans-unit>
        <trans-unit id="ac47518e69af0774bb76855d1ba4fd45ba076dbb" translate="yes" xml:space="preserve">
          <source>AsciiExt::to_ascii_lowercase</source>
          <target state="translated">AsciiExt::to_ascii_lowercase</target>
        </trans-unit>
        <trans-unit id="e04741744413a75fb42c855cb8f9068dc93b7a29" translate="yes" xml:space="preserve">
          <source>AsciiExt::to_ascii_uppercase</source>
          <target state="translated">AsciiExt::to_ascii_uppercase</target>
        </trans-unit>
        <trans-unit id="1b3c2291de90fba8268fb52f3659391950c3a127" translate="yes" xml:space="preserve">
          <source>Aside from the closing curly bracket, there&amp;rsquo;s only one more line to discuss in the code added so far, which is the following:</source>
          <target state="translated">閉じ中括弧を除いて、これまでに追加されたコードで説明する行はあと1行だけです。これは、次のとおりです。</target>
        </trans-unit>
        <trans-unit id="f99c599e0e3924b919cda05ade321af8f7909739" translate="yes" xml:space="preserve">
          <source>Aside from the closing curly brackets, there&amp;rsquo;s only one more line to discuss in the code added so far, which is the following:</source>
          <target state="translated">閉じ中かっこを除いて、これまでに追加したコードで説明する行は次の1つだけです。</target>
        </trans-unit>
        <trans-unit id="ccfa1ea33000ed1fdc5e32d6d85a1f23b351c53c" translate="yes" xml:space="preserve">
          <source>Asked how long the string is, you might say 12. However, Rust&amp;rsquo;s answer is 24: that&amp;rsquo;s the number of bytes it takes to encode &amp;ldquo;Здравствуйте&amp;rdquo; in UTF-8, because each Unicode scalar value in that string takes 2 bytes of storage. Therefore, an index into the string&amp;rsquo;s bytes will not always correlate to a valid Unicode scalar value. To demonstrate, consider this invalid Rust code:</source>
          <target state="translated">文字列の長さを尋ねると、12と言うかもしれません。ただし、Rustの答えは24です。これは、UTF-8で「Здравствуйте」をエンコードするのにかかるバイト数です。その文字列の各Unicodeスカラー値は2バイトのストレージを必要とするためです。したがって、文字列のバイトへのインデックスは、常に有効なUnicodeスカラー値と相関するとは限りません。実例として、次の無効なRustコードを検討してください。</target>
        </trans-unit>
        <trans-unit id="e7689cb162bee3d282a7b39ef7b90263d73428fa" translate="yes" xml:space="preserve">
          <source>Assert the results are what you expect.</source>
          <target state="translated">結果は期待通りだと断言します。</target>
        </trans-unit>
        <trans-unit id="14ec22b40bdfb6faadf461156fa13c1003c498f7" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe</source>
          <target state="translated">AssertUnwindSafe</target>
        </trans-unit>
        <trans-unit id="b22e5cc4bce8496592970be5b25d370d67581697" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::borrow</source>
          <target state="translated">AssertUnwindSafe::borrow</target>
        </trans-unit>
        <trans-unit id="e9b2629172195580950a107f4837fef269c6587e" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::borrow_mut</source>
          <target state="translated">AssertUnwindSafe::borrow_mut</target>
        </trans-unit>
        <trans-unit id="65951f8f36689c68821ae0439274d4a0186d7055" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::call_once</source>
          <target state="translated">AssertUnwindSafe::call_once</target>
        </trans-unit>
        <trans-unit id="846bd763b3f520ae6051ff0597c886f310c2c6ea" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::deref</source>
          <target state="translated">AssertUnwindSafe::deref</target>
        </trans-unit>
        <trans-unit id="0f7f2436811897e328934158a966a543668732f9" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::deref_mut</source>
          <target state="translated">AssertUnwindSafe::deref_mut</target>
        </trans-unit>
        <trans-unit id="df50057fe584f587876a9e064fa1ae0b0acfbda2" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::fmt</source>
          <target state="translated">AssertUnwindSafe::fmt</target>
        </trans-unit>
        <trans-unit id="d34a0fd3c126015a7f7ea1d7a1780f16da8c0c7f" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::from</source>
          <target state="translated">AssertUnwindSafe::from</target>
        </trans-unit>
        <trans-unit id="bc1f4df4473c05cd44c2d50adf3e2f9062513d4c" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::into</source>
          <target state="translated">AssertUnwindSafe::into</target>
        </trans-unit>
        <trans-unit id="3b850d0a322410d738f80adc8cf728ee8170ee1d" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::poll</source>
          <target state="translated">AssertUnwindSafe::poll</target>
        </trans-unit>
        <trans-unit id="daed5606c5d5daf7eeeb4806493948f969bf4f99" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::try_from</source>
          <target state="translated">AssertUnwindSafe::try_from</target>
        </trans-unit>
        <trans-unit id="eb82a427dc920b4169ca7e00269601d2ac319ce2" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::try_into</source>
          <target state="translated">AssertUnwindSafe::try_into</target>
        </trans-unit>
        <trans-unit id="9f7d994301cc07488a1ff2b7d4c3da5dab748286" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::type_id</source>
          <target state="translated">AssertUnwindSafe::type_id</target>
        </trans-unit>
        <trans-unit id="caf84242142f24165f73b39c5c6b3d3bc20e5c26" translate="yes" xml:space="preserve">
          <source>Assertions are always checked in both debug and release builds, and cannot be disabled. See &lt;a href=&quot;macro.debug_assert&quot;&gt;&lt;code&gt;debug_assert!&lt;/code&gt;&lt;/a&gt; for assertions that are not enabled in release builds by default.</source>
          <target state="translated">アサーションは常にデバッグビルドとリリースビルドの両方でチェックされ、無効にすることはできません。&lt;a href=&quot;macro.debug_assert&quot;&gt; &lt;code&gt;debug_assert!&lt;/code&gt; &lt;/a&gt;参照してください！デフォルトではリリースビルドで有効になっていないアサーション用。</target>
        </trans-unit>
        <trans-unit id="e17cdfab7869a902dcf07cf1a4cdf602ea080d95" translate="yes" xml:space="preserve">
          <source>Asserts that a boolean expression is &lt;code&gt;true&lt;/code&gt; at runtime.</source>
          <target state="translated">実行時にブール式が &lt;code&gt;true&lt;/code&gt; であることを表明します。</target>
        </trans-unit>
        <trans-unit id="2cab5457990719d367e9e18b69d1f9cf567a9ba6" translate="yes" xml:space="preserve">
          <source>Asserts that two expressions are equal to each other (using &lt;a href=&quot;cmp/trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">2つの式が互いに等しいことを表明します（&lt;a href=&quot;cmp/trait.partialeq&quot;&gt; &lt;code&gt;PartialEq&lt;/code&gt; &lt;/a&gt;を使用）。</target>
        </trans-unit>
        <trans-unit id="ebf68c5dd99f7adc415f813d7cd9a9965b251c70" translate="yes" xml:space="preserve">
          <source>Asserts that two expressions are equal to each other.</source>
          <target state="translated">2つの式が互いに等しいことを主張する。</target>
        </trans-unit>
        <trans-unit id="c856365534a0e73e93b9d798530cb553f48e1b9c" translate="yes" xml:space="preserve">
          <source>Asserts that two expressions are not equal to each other (using &lt;a href=&quot;cmp/trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">2つの式が互いに等しくないことを表明します（&lt;a href=&quot;cmp/trait.partialeq&quot;&gt; &lt;code&gt;PartialEq&lt;/code&gt; &lt;/a&gt;を使用）。</target>
        </trans-unit>
        <trans-unit id="4b3283be054a95811542a229062df29f52cd4b0a" translate="yes" xml:space="preserve">
          <source>Asserts that two expressions are not equal to each other.</source>
          <target state="translated">2つの式が互いに等しくないことを主張する。</target>
        </trans-unit>
        <trans-unit id="6a70c6eb716321451f69851e0a0b3e6de46cfe0a" translate="yes" xml:space="preserve">
          <source>Assignment expressions</source>
          <target state="translated">代入表現</target>
        </trans-unit>
        <trans-unit id="db7b4a247e0cd4b439f9a236f4dd17ca687d0c37" translate="yes" xml:space="preserve">
          <source>Assignment of &lt;code&gt;A + B&lt;/code&gt; to &lt;code&gt;A&lt;/code&gt; might be removed, since the sum can be stored in a temporary location until it gets printed, with the global variable never getting updated.</source>
          <target state="translated">割り当て &lt;code&gt;A + B&lt;/code&gt; の &lt;code&gt;A&lt;/code&gt; は、それが印刷されるまでの合計は決して更新しないばかりグローバル変数で、一時的な場所に保存することができるので、削除される可能性があります。</target>
        </trans-unit>
        <trans-unit id="fb5a2f19ac5c2fbe53a27d32c54a5315d8390b9c" translate="yes" xml:space="preserve">
          <source>Assignment/equivalence</source>
          <target state="translated">Assignment/equivalence</target>
        </trans-unit>
        <trans-unit id="1ec71ff0ba20c7a0026ccba467326b673793511e" translate="yes" xml:space="preserve">
          <source>Assignments are not allowed in pattern guards, because matching cannot have side effects. Side effects could alter the matched object or the environment on which the match depends in such a way, that the match would not be exhaustive. For instance, the following would not match any arm if assignments were allowed:</source>
          <target state="translated">マッチングに副作用を持たせることはできないため、パターンガードでは代入は許可されていません。副作用は、マッチしたオブジェクトやマッチが依存する環境を変更する可能性があり、マッチが完全ではありません。例えば、以下のようなものは、割り当てが許可されている場合、どのアームにもマッチしません。</target>
        </trans-unit>
        <trans-unit id="681eeaa9b3a793bf0806817da80c3be3c3a0567b" translate="yes" xml:space="preserve">
          <source>Assigns a new value to the memory behind the pinned reference.</source>
          <target state="translated">固定された参照の後ろのメモリに新しい値を割り当てます。</target>
        </trans-unit>
        <trans-unit id="b443e8292f53b80a70f9ceabc76037bb4e254686" translate="yes" xml:space="preserve">
          <source>Associated Constants</source>
          <target state="translated">関連する定数</target>
        </trans-unit>
        <trans-unit id="aea3ba1170590168c2a8d38c0934f41a1081bd96" translate="yes" xml:space="preserve">
          <source>Associated Constants Examples</source>
          <target state="translated">関連定数の例</target>
        </trans-unit>
        <trans-unit id="eb724e00631164f5e2c7a1805aa66c501706a7b7" translate="yes" xml:space="preserve">
          <source>Associated Functions</source>
          <target state="translated">関連機能</target>
        </trans-unit>
        <trans-unit id="b9d6b786d3dce88371ca3fec1b3f0f5dcc494947" translate="yes" xml:space="preserve">
          <source>Associated Items</source>
          <target state="translated">関連項目</target>
        </trans-unit>
        <trans-unit id="26904b659cb34afa59632d8007e5d7c3c1f7672c" translate="yes" xml:space="preserve">
          <source>Associated Types</source>
          <target state="translated">関連するタイプ</target>
        </trans-unit>
        <trans-unit id="d854ee9b0fbbb41a1a8293a522b3a7fd759f3935" translate="yes" xml:space="preserve">
          <source>Associated Types Container Example</source>
          <target state="translated">関連づけられたタイプ コンテナの例</target>
        </trans-unit>
        <trans-unit id="6176d44495c67b15b26948f8a03f37c611fcd9c1" translate="yes" xml:space="preserve">
          <source>Associated constants, functions, and types</source>
          <target state="translated">関連する定数、関数、型</target>
        </trans-unit>
        <trans-unit id="bf8fe32d8bff33aaf1adf4d6ce640603da967659" translate="yes" xml:space="preserve">
          <source>Associated functions and methods</source>
          <target state="translated">関連する機能とメソッド</target>
        </trans-unit>
        <trans-unit id="ca7658fbd81144f975e114c63e67d2067128142d" translate="yes" xml:space="preserve">
          <source>Associated functions are often used for constructors that will return a new instance of the struct. For example, we could provide an associated function that would have one dimension parameter and use that as both width and height, thus making it easier to create a square &lt;code&gt;Rectangle&lt;/code&gt; rather than having to specify the same value twice:</source>
          <target state="translated">関連する関数は、構造体の新しいインスタンスを返すコンストラクターによく使用されます。たとえば、1つの寸法パラメーターを持つ関連関数を提供し、それを幅と高さの両方として使用できるため、同じ値を2回指定する必要がなく、正方形の &lt;code&gt;Rectangle&lt;/code&gt; 簡単に作成できます。</target>
        </trans-unit>
        <trans-unit id="1d8027bfb0422adf6fa755c7366da969f12a3f99" translate="yes" xml:space="preserve">
          <source>Associated functions whose first parameter is named &lt;code&gt;self&lt;/code&gt; are called &lt;em&gt;methods&lt;/em&gt; and may be invoked using the &lt;a href=&quot;../expressions/method-call-expr&quot;&gt;method call operator&lt;/a&gt;, for example, &lt;code&gt;x.foo()&lt;/code&gt;, as well as the usual function call notation.</source>
          <target state="translated">その最初のパラメータと命名された関連機能 &lt;code&gt;self&lt;/code&gt; 呼び出される&lt;em&gt;方法&lt;/em&gt;と使用して呼び出すことができる&lt;a href=&quot;../expressions/method-call-expr&quot;&gt;メソッド呼び出しオペレータ&lt;/a&gt;、例えば、 &lt;code&gt;x.foo()&lt;/code&gt; 、ならびに通常の関数呼び出し表記。</target>
        </trans-unit>
        <trans-unit id="50f4dee25317e303fd0eeee4d556e246ef57db0b" translate="yes" xml:space="preserve">
          <source>Associated item</source>
          <target state="translated">関連項目</target>
        </trans-unit>
        <trans-unit id="4627f0f1df7ed7ad7efce2d0583317bf3d8df511" translate="yes" xml:space="preserve">
          <source>Associated item for a type that cannot be directly named (e.g., &lt;code&gt;&amp;lt;&amp;amp;T&amp;gt;::...&lt;/code&gt;, &lt;code&gt;&amp;lt;[T]&amp;gt;::...&lt;/code&gt;, etc.)</source>
          <target state="translated">直接名前を付けることができないタイプに関連付けられたアイテム（例： &lt;code&gt;&amp;lt;&amp;amp;T&amp;gt;::...&lt;/code&gt; 、 &lt;code&gt;&amp;lt;[T]&amp;gt;::...&lt;/code&gt; など）</target>
        </trans-unit>
        <trans-unit id="f0dda5ab7ff2aba410ad872aa8c289173200dd02" translate="yes" xml:space="preserve">
          <source>Associated items are useful when the associated item logically is related to the associating item. For example, the &lt;code&gt;is_some&lt;/code&gt; method on &lt;code&gt;Option&lt;/code&gt; is intrinsically related to Options, so should be associated.</source>
          <target state="translated">関連アイテムは、関連アイテムが関連アイテムに論理的に関連付けられている場合に役立ちます。たとえば、 &lt;code&gt;Option&lt;/code&gt; の &lt;code&gt;is_some&lt;/code&gt; メソッドは本質的にOptionsに関連しているため、関連付ける必要があります。</target>
        </trans-unit>
        <trans-unit id="13ba4a748e2d8dab765ce941e0df6910e63030e1" translate="yes" xml:space="preserve">
          <source>Associated searcher for this pattern</source>
          <target state="translated">このパターンに関連する検索者</target>
        </trans-unit>
        <trans-unit id="ce35cedae86fe81ca2cf2bcb725660816d309811" translate="yes" xml:space="preserve">
          <source>Associated type for &lt;code&gt;&amp;lt;&amp;amp;[char] as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;&amp;amp;[char] as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt; られた型としてのPattern &amp;lt;'a &amp;gt;&amp;gt; :: Searcher。</target>
        </trans-unit>
        <trans-unit id="e195d76e814dc3f6b09416fe019701da4141e61f" translate="yes" xml:space="preserve">
          <source>Associated type for &lt;code&gt;&amp;lt;&amp;amp;str as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;&amp;amp;str as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt; 関連タイプ。</target>
        </trans-unit>
        <trans-unit id="da9f3600b580da18821fb0932aa55c1e82dc8484" translate="yes" xml:space="preserve">
          <source>Associated type for &lt;code&gt;&amp;lt;F as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;F as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt; 関連タイプ。</target>
        </trans-unit>
        <trans-unit id="470b87bc44e9aa3c27db7ff27c851ded51a493f4" translate="yes" xml:space="preserve">
          <source>Associated type for &lt;code&gt;&amp;lt;char as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;char as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt; 関連タイプ。</target>
        </trans-unit>
        <trans-unit id="4b2aeb71be1e33f6aef873e1957563d04f8d17e0" translate="yes" xml:space="preserve">
          <source>Associated types from &lt;code&gt;Trait&lt;/code&gt; can be used.</source>
          <target state="translated">&lt;code&gt;Trait&lt;/code&gt; 関連タイプを使用できます。</target>
        </trans-unit>
        <trans-unit id="b94fe8e8235a5eac0ea7986a3bc24833e5f55164" translate="yes" xml:space="preserve">
          <source>Associated types might seem like a similar concept to generics, in that the latter allow us to define a function without specifying what types it can handle. So why use associated types?</source>
          <target state="translated">関連づけられた型はジェネリックと似たような概念のように思われるかもしれませんが、後者では、関数が扱える型を指定せずに関数を定義することができます。ではなぜ連想型を使うのでしょうか?</target>
        </trans-unit>
        <trans-unit id="d20b5a26a1cdf631954b50a5206246dff93d9c8a" translate="yes" xml:space="preserve">
          <source>Associativity</source>
          <target state="translated">Associativity</target>
        </trans-unit>
        <trans-unit id="434de15a9f2e5951652f37ae43c858535ba0b678" translate="yes" xml:space="preserve">
          <source>Assume there are two files in the same directory with the following contents:</source>
          <target state="translated">同じディレクトリに以下の内容のファイルが2つあるとします。</target>
        </trans-unit>
        <trans-unit id="a7203654194ae4db3f1b4a3c121163c9fc8267f3" translate="yes" xml:space="preserve">
          <source>Assumes that the &lt;code&gt;VecDeque&lt;/code&gt; is sorted by the key, for instance with &lt;a href=&quot;#method.make_contiguous&quot;&gt;&lt;code&gt;make_contiguous().sort_by_key()&lt;/code&gt;&lt;/a&gt; using the same key extraction function.</source>
          <target state="translated">VecDequeがキーによってソートされていると &lt;code&gt;VecDeque&lt;/code&gt; します&lt;a href=&quot;#method.make_contiguous&quot;&gt; &lt;code&gt;make_contiguous().sort_by_key()&lt;/code&gt; &lt;/a&gt;、同じキー抽出関数を使用するmake_contiguous（）。sort_by_key（）を使用します。</target>
        </trans-unit>
        <trans-unit id="9c07290f30084dee9d612cccf40372822beeda08" translate="yes" xml:space="preserve">
          <source>Assumes that the slice is sorted by the key, for instance with &lt;a href=&quot;#method.sort_by_key&quot;&gt;&lt;code&gt;sort_by_key&lt;/code&gt;&lt;/a&gt; using the same key extraction function.</source>
          <target state="translated">たとえば、同じキー抽出関数を使用して&lt;a href=&quot;#method.sort_by_key&quot;&gt; &lt;code&gt;sort_by_key&lt;/code&gt; &lt;/a&gt;を使用して、スライスがキーでソートされていると仮定します。</target>
        </trans-unit>
        <trans-unit id="7da83b920d859bea1ef24ff98129cc3f739b791b" translate="yes" xml:space="preserve">
          <source>Assuming all the elements are initialized, get a mutable slice to them.</source>
          <target state="translated">すべての要素が初期化されていると仮定して、それらの要素に変異可能なスライスを取得します。</target>
        </trans-unit>
        <trans-unit id="0d70f82d569a6dc638a5854fc3e366cb50b91e26" translate="yes" xml:space="preserve">
          <source>Assuming all the elements are initialized, get a slice to them.</source>
          <target state="translated">すべての要素が初期化されていると仮定して、それらの要素にスライスを取得します。</target>
        </trans-unit>
        <trans-unit id="c924c9518b3ab961e095e1c3fb8fc583399ec253" translate="yes" xml:space="preserve">
          <source>Assuming there&amp;rsquo;s a file named &lt;code&gt;foo.txt&lt;/code&gt; with contents &lt;code&gt;abcdef\n&lt;/code&gt;, create two handles, seek one of them, and read the remaining bytes from the other handle:</source>
          <target state="translated">内容が &lt;code&gt;abcdef\n&lt;/code&gt; &lt;code&gt;foo.txt&lt;/code&gt; という名前のファイルがあると想定して、2つのハンドルを作成し、そのうちの1つを探し、残りのバイトを他のハンドルから読み取ります。</target>
        </trans-unit>
        <trans-unit id="31936e0a0d8572ee4060f19296edebc34a7f6f8c" translate="yes" xml:space="preserve">
          <source>Asterisk glob imports will import items imported with &lt;code&gt;_&lt;/code&gt; in their unnameable form.</source>
          <target state="translated">アスタリスクglobインポートは、名前が &lt;code&gt;_&lt;/code&gt; でインポートされたアイテムを名前のない形式でインポートします。</target>
        </trans-unit>
        <trans-unit id="940e0ca02bfde86559dac73ad0f3397300f703e1" translate="yes" xml:space="preserve">
          <source>Async blocks act like a function boundary, much like closures. Therefore, the &lt;code&gt;?&lt;/code&gt; operator and &lt;code&gt;return&lt;/code&gt; expressions both affect the output of the future, not the enclosing function or other context. That is, &lt;code&gt;return &amp;lt;expr&amp;gt;&lt;/code&gt; from within a closure will return the result of &lt;code&gt;&amp;lt;expr&amp;gt;&lt;/code&gt; as the output of the future. Similarly, if &lt;code&gt;&amp;lt;expr&amp;gt;?&lt;/code&gt; propagates an error, that error is propagated as the result of the future.</source>
          <target state="translated">非同期ブロックは、クロージャのように、関数の境界のように機能します。したがって、 &lt;code&gt;?&lt;/code&gt; 演算子式と &lt;code&gt;return&lt;/code&gt; 式はどちらも、囲んでいる関数やその他のコンテキストではなく、futureの出力に影響します。つまり、クロージャ内から &lt;code&gt;return &amp;lt;expr&amp;gt;&lt;/code&gt; を返すと、futureの出力として &lt;code&gt;&amp;lt;expr&amp;gt;&lt;/code&gt; の結果が返されます。同様に、 &lt;code&gt;&amp;lt;expr&amp;gt;?&lt;/code&gt; エラーを伝播し、そのエラーは将来の結果として伝播されます。</target>
        </trans-unit>
        <trans-unit id="214d7973c7382a6a34b11e3f97cf5442c859fb3e" translate="yes" xml:space="preserve">
          <source>Async blocks capture variables from their environment using the same &lt;a href=&quot;../types/closure#capture-modes&quot;&gt;capture modes&lt;/a&gt; as closures. Like closures, when written &lt;code&gt;async { .. }&lt;/code&gt; the capture mode for each variable will be inferred from the content of the block. &lt;code&gt;async move { .. }&lt;/code&gt; blocks however will move all referenced variables into the resulting future.</source>
          <target state="translated">非同期ブロックは、クロージャーと同じ&lt;a href=&quot;../types/closure#capture-modes&quot;&gt;キャプチャモード&lt;/a&gt;を使用して、環境から変数をキャプチャします。クロージャと同様に、 &lt;code&gt;async { .. }&lt;/code&gt; 記述されると、各変数のキャプチャモードはブロックのコンテンツから推測されます。ただし、 &lt;code&gt;async move { .. }&lt;/code&gt; ブロックは、参照されるすべての変数を結果のfutureに移動します。</target>
        </trans-unit>
        <trans-unit id="57f9a16fc928066d87c71b1e0690e9ad26edea0a" translate="yes" xml:space="preserve">
          <source>Async context</source>
          <target state="translated">非同期コンテキスト</target>
        </trans-unit>
        <trans-unit id="5ef2ec7c086db048016785067a80b5c302021dc3" translate="yes" xml:space="preserve">
          <source>Async functions</source>
          <target state="translated">非同期関数</target>
        </trans-unit>
        <trans-unit id="99471e2fa36e20e9d7193c5529dfbf6f52a711a2" translate="yes" xml:space="preserve">
          <source>Async functions do no work when called: instead, they capture their arguments into a future. When polled, that future will execute the function's body.</source>
          <target state="translated">非同期関数は呼ばれても何もしません:代わりに、引数を未来に取り込みます。ポーリングされると、その未来は関数の本体を実行します。</target>
        </trans-unit>
        <trans-unit id="c318095156a540e68b8cc7d9ad9ab72fce83a154" translate="yes" xml:space="preserve">
          <source>Asynchronous values.</source>
          <target state="translated">非同期の値。</target>
        </trans-unit>
        <trans-unit id="0855009c46728a5c8cb9aa53860e3b38d932c17a" translate="yes" xml:space="preserve">
          <source>At</source>
          <target state="translated">At</target>
        </trans-unit>
        <trans-unit id="6aa8b3387e6ffd75791adbf0065888a4924635f2" translate="yes" xml:space="preserve">
          <source>At a high level, a &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt;&lt;/a&gt; ensures that the pointee of any pointer type &lt;code&gt;P&lt;/code&gt; has a stable location in memory, meaning it cannot be moved elsewhere and its memory cannot be deallocated until it gets dropped. We say that the pointee is &quot;pinned&quot;. Things get more subtle when discussing types that combine pinned with non-pinned data; &lt;a href=&quot;#projections-and-structural-pinning&quot;&gt;see below&lt;/a&gt; for more details.</source>
          <target state="translated">高レベルでは、&lt;a href=&quot;struct.pin&quot;&gt; &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; &lt;/a&gt;は、任意のポインタタイプ &lt;code&gt;P&lt;/code&gt; のポインタがメモリ内で安定した位置にあることを保証します。つまり、他の場所に移動したり、メモリがドロップされるまでメモリの割り当てを解除したりすることはできません。ポインティは「固定」されていると言います。固定されたデータと固定されていないデータを組み合わせるタイプについて議論するとき、物事はより微妙になります。&lt;a href=&quot;#projections-and-structural-pinning&quot;&gt;詳細については、以下&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="d9cacf1832e8829a2c65089757588eeeacfc9330" translate="yes" xml:space="preserve">
          <source>At all times, you must avoid data races. If multiple threads have access to the same &lt;code&gt;UnsafeCell&lt;/code&gt;, then any writes must have a proper happens-before relation to all other accesses (or use atomics).</source>
          <target state="translated">常に、データの競合を回避する必要があります。複数のスレッドが同じ &lt;code&gt;UnsafeCell&lt;/code&gt; にアクセスできる場合、すべての書き込みは他のすべてのアクセスと適切に発生する前に関係している（またはアトミックを使用する）必要があります。</target>
        </trans-unit>
        <trans-unit id="c68169e0fac1472856a75bc093cd4e904a65d3b5" translate="yes" xml:space="preserve">
          <source>At any given time, you can have &lt;em&gt;either&lt;/em&gt; (but not both of) one mutable reference or any number of immutable references.</source>
          <target state="translated">任意の時点で、あなたが持つことができる&lt;em&gt;のいずれか&lt;/em&gt;（両方のではなく）1つの不定参照または不変参照の任意の数を。</target>
        </trans-unit>
        <trans-unit id="97c27bc0fbd95b57400fcf731e3e7a7d89c5cf2f" translate="yes" xml:space="preserve">
          <source>At any given time, you can have &lt;em&gt;either&lt;/em&gt; one mutable reference &lt;em&gt;or&lt;/em&gt; any number of immutable references.</source>
          <target state="translated">いつでも&lt;em&gt;、&lt;/em&gt; 1つの変更可能な参照&lt;em&gt;または&lt;/em&gt;任意の数の不変の参照を持つことができます。</target>
        </trans-unit>
        <trans-unit id="b790d9edc1873ab13071956060a912cd284deda5" translate="yes" xml:space="preserve">
          <source>At compile time each implementation of &lt;code&gt;Trait&lt;/code&gt; will produce a table containing the various methods (and other items) related to the implementation.</source>
          <target state="translated">コンパイル時に、 &lt;code&gt;Trait&lt;/code&gt; の各実装は、実装に関連するさまざまなメソッド（およびその他の項目）を含むテーブルを生成します。</target>
        </trans-unit>
        <trans-unit id="26e37b1b35b52ad10610ea1ef12403fe61f658c6" translate="yes" xml:space="preserve">
          <source>At compile time, Rust needs to know how much space a type takes up. One type whose size can&amp;rsquo;t be known at compile time is a &lt;em&gt;recursive type&lt;/em&gt;, where a value can have as part of itself another value of the same type. Because this nesting of values could theoretically continue infinitely, Rust doesn&amp;rsquo;t know how much space a value of a recursive type needs. However, boxes have a known size, so by inserting a box in a recursive type definition, you can have recursive types.</source>
          <target state="translated">コンパイル時に、Rustは型が占めるスペースを知る必要があります。コンパイル時にサイズがわからない1つの型は、&lt;em&gt;再帰&lt;/em&gt;型です。値は、それ自体の一部として同じ型の別の値を持つことができます。この値のネストは理論的には無限に続く可能性があるため、Rustは再帰型の値に必要なスペースの量を知りません。ただし、ボックスには既知のサイズがあるため、再帰型定義にボックスを挿入することにより、再帰型を使用できます。</target>
        </trans-unit>
        <trans-unit id="b2f9b5afe99b75e0f39f01ec88be93443b074a9d" translate="yes" xml:space="preserve">
          <source>At each point in the program where the reference count changes, we print the reference count, which we can get by calling the &lt;code&gt;Rc::strong_count&lt;/code&gt; function. This function is named &lt;code&gt;strong_count&lt;/code&gt; rather than &lt;code&gt;count&lt;/code&gt; because the &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; type also has a &lt;code&gt;weak_count&lt;/code&gt;; we&amp;rsquo;ll see what &lt;code&gt;weak_count&lt;/code&gt; is used for in the &lt;a href=&quot;ch15-06-reference-cycles#preventing-reference-cycles-turning-an-rct-into-a-weakt&quot;&gt;&amp;ldquo;Preventing Reference Cycles: Turning an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; into a &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt;&amp;rdquo;&lt;/a&gt; section.</source>
          <target state="translated">参照カウントが変更されるプログラムの各ポイントで、参照カウントを &lt;code&gt;Rc::strong_count&lt;/code&gt; ます。これは、Rc :: strong_count関数を呼び出すことで取得できます。この関数は、指定され &lt;code&gt;strong_count&lt;/code&gt; ではなく &lt;code&gt;count&lt;/code&gt; ので、 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; タイプもあり &lt;code&gt;weak_count&lt;/code&gt; を。&lt;a href=&quot;ch15-06-reference-cycles#preventing-reference-cycles-turning-an-rct-into-a-weakt&quot;&gt;「参照サイクルの防止：&lt;/a&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; を &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; 変える」セクションで、 &lt;code&gt;weak_count&lt;/code&gt; の使用目的を確認します。</target>
        </trans-unit>
        <trans-unit id="f2afe7e487c0f1c732676abe97c30fdb7bfd5600" translate="yes" xml:space="preserve">
          <source>At first, we have no memory allocated at all, but as we append to the string, it increases its capacity appropriately. If we instead use the &lt;a href=&quot;#method.with_capacity&quot;&gt;&lt;code&gt;with_capacity&lt;/code&gt;&lt;/a&gt; method to allocate the correct capacity initially:</source>
          <target state="translated">最初はメモリがまったく割り当てられていませんが、文字列に追加すると、容量が適切に増加します。代わりに&lt;a href=&quot;#method.with_capacity&quot;&gt; &lt;code&gt;with_capacity&lt;/code&gt; &lt;/a&gt;メソッドを使用して、最初に正しい容量を割り当てる場合：</target>
        </trans-unit>
        <trans-unit id="dc05814fc863fd7b76fdcfe7f779c72f9533e270" translate="yes" xml:space="preserve">
          <source>At first, we have no memory allocated at all, but as we append to the string, it increases its capacity appropriately. If we instead use the &lt;a href=&quot;struct.string#method.with_capacity&quot;&gt;&lt;code&gt;with_capacity&lt;/code&gt;&lt;/a&gt; method to allocate the correct capacity initially:</source>
          <target state="translated">最初はメモリがまったく割り当てられていませんが、文字列に追加すると、容量が適切に増加します。代わりに&lt;a href=&quot;struct.string#method.with_capacity&quot;&gt; &lt;code&gt;with_capacity&lt;/code&gt; &lt;/a&gt;メソッドを使用して、最初に正しい容量を割り当てる場合：</target>
        </trans-unit>
        <trans-unit id="0295e56a89c227419234a744fcdff39f54bbbd31" translate="yes" xml:space="preserve">
          <source>At its simplest, a test in Rust is a function that&amp;rsquo;s annotated with the &lt;code&gt;test&lt;/code&gt; attribute. Attributes are metadata about pieces of Rust code; one example is the &lt;code&gt;derive&lt;/code&gt; attribute we used with structs in Chapter 5. To change a function into a test function, add &lt;code&gt;#[test]&lt;/code&gt; on the line before &lt;code&gt;fn&lt;/code&gt;. When you run your tests with the &lt;code&gt;cargo test&lt;/code&gt; command, Rust builds a test runner binary that runs the functions annotated with the &lt;code&gt;test&lt;/code&gt; attribute and reports on whether each test function passes or fails.</source>
          <target state="translated">最も簡単に言うと、Rustの &lt;code&gt;test&lt;/code&gt; はtest属性で注釈が付けられた関数です。属性は、Rustコードの断片に関するメタデータです。1つの例は、第5章の構造体で使用した &lt;code&gt;derive&lt;/code&gt; 属性です。関数をテスト関数に変更するには、 &lt;code&gt;fn&lt;/code&gt; の前の行に &lt;code&gt;#[test]&lt;/code&gt; を追加します。Rustは、 &lt;code&gt;cargo test&lt;/code&gt; コマンドを使用してテストを実行すると、 &lt;code&gt;test&lt;/code&gt; 属性で注釈が付けられた関数を実行するテストランナーバイナリを構築し、各テスト関数が成功したか失敗したかを報告します。</target>
        </trans-unit>
        <trans-unit id="37583ea386b39553438667ee1326a11884d8ac4d" translate="yes" xml:space="preserve">
          <source>At least one of either &lt;code&gt;Self&lt;/code&gt; or a generic type parameter of the trait must meet the following grammar, where &lt;code&gt;C&lt;/code&gt; is a nominal type defined within the containing crate:</source>
          <target state="translated">&lt;code&gt;Self&lt;/code&gt; または特性のジェネリック型パラメーターの少なくとも1つは、次の文法を満たしている必要があります &lt;code&gt;C&lt;/code&gt; は、含まれているクレート内で定義されている名義型です。</target>
        </trans-unit>
        <trans-unit id="6340eab1a988a949757faf0b3ab2c9f1d577f929" translate="yes" xml:space="preserve">
          <source>At least one of the pointers is being used to write to the data.</source>
          <target state="translated">ポインタのうち少なくとも1つは、データへの書き込みに使用されています。</target>
        </trans-unit>
        <trans-unit id="5724aa0694940a76277017d916e0999814aa1912" translate="yes" xml:space="preserve">
          <source>At least one of the types &lt;code&gt;T0..=Tn&lt;/code&gt; must be a &lt;a href=&quot;../glossary#local-type&quot;&gt;local type&lt;/a&gt;. Let &lt;code&gt;Ti&lt;/code&gt; be the first such type.</source>
          <target state="translated">タイプ &lt;code&gt;T0..=Tn&lt;/code&gt; 少なくとも1つは、&lt;a href=&quot;../glossary#local-type&quot;&gt;ローカルタイプである&lt;/a&gt;必要があります。してみましょう &lt;code&gt;Ti&lt;/code&gt; はまず、このようなタイプです。</target>
        </trans-unit>
        <trans-unit id="e87e525060c2b4080d7c34755a062916a4109c19" translate="yes" xml:space="preserve">
          <source>At least one of the types &lt;code&gt;T0..=Tn&lt;/code&gt; must be a local type. Let &lt;code&gt;Ti&lt;/code&gt; be the first such type.</source>
          <target state="translated">タイプ &lt;code&gt;T0..=Tn&lt;/code&gt; 少なくとも1つは、ローカルタイプである必要があります。してみましょう &lt;code&gt;Ti&lt;/code&gt; はまず、このようなタイプです。</target>
        </trans-unit>
        <trans-unit id="a139025cd9d3b2fee71807f78a3b49ac15b212ef" translate="yes" xml:space="preserve">
          <source>At present few predefined ABI's (like Rust, C, system, etc.) can be used in Rust. Verify that the ABI is predefined. For example you can replace the given ABI from 'Rust'.</source>
          <target state="translated">現在のところ、Rustで使用できる定義済みのABIはほとんどありません(Rust、C、systemなど)。ABIが定義済みであることを確認してください。例えば、与えられたABIを'Rust'から置き換えることができます。</target>
        </trans-unit>
        <trans-unit id="e2c9357843faff292144d5026ce32c57e9298ff6" translate="yes" xml:space="preserve">
          <source>At present, it is not permitted to have a yield that occurs while a borrow is still in scope. To resolve this error, the borrow must either be &quot;contained&quot; to a smaller scope that does not overlap the yield or else eliminated in another way. So, for example, we might resolve the previous example by removing the borrow and just storing the integer by value:</source>
          <target state="translated">現在のところ、借方がスコープ内にある間に発生したイールドを持つことは許されていません。このエラーを解決するためには、borrowをイールドと重ならない小さなスコープに「含める」か、別の方法で削除しなければなりません。そのため、例えば、先ほどの例では借用を削除して整数を値で格納することで解決することができます。</target>
        </trans-unit>
        <trans-unit id="c58aa6f87c5fb2f5db7b812c6bc9a21b048e36a1" translate="yes" xml:space="preserve">
          <source>At present, it is not permitted to pass more than one explicit parameter for a generator.This can be fixed by using at most 1 parameter for the generator. For example, we might resolve the previous example by passing only one parameter.</source>
          <target state="translated">現在のところ、ジェネレータに2つ以上の明示的なパラメータを渡すことは許されていません。例えば、先ほどの例を1つのパラメータだけを渡すことで解決することができます。</target>
        </trans-unit>
        <trans-unit id="4e36fb08191e884058237321d264d01b5dc6a45f" translate="yes" xml:space="preserve">
          <source>At run-time, when a method needs to be called on the &lt;code&gt;dyn Trait&lt;/code&gt;, the vtable is consulted to get the function pointer and then that function pointer is called.</source>
          <target state="translated">実行時に、 &lt;code&gt;dyn Trait&lt;/code&gt; でメソッドを呼び出す必要がある場合、vtableを参照して関数ポインターを取得してから、その関数ポインターが呼び出されます。</target>
        </trans-unit>
        <trans-unit id="acf3e76f07038198aca7a45dd9300fbaa0a3ed8a" translate="yes" xml:space="preserve">
          <source>At runtime this function behaves like &lt;code&gt;self != other&lt;/code&gt;. However, in some contexts (e.g., compile-time evaluation), it is not always possible to determine the inequality of two pointers, so this function may spuriously return &lt;code&gt;false&lt;/code&gt; for pointers that later actually turn out to be unequal. But when it returns &lt;code&gt;true&lt;/code&gt;, the pointers are guaranteed to be unequal.</source>
          <target state="translated">実行時、この関数は &lt;code&gt;self != other&lt;/code&gt; ように動作します。ただし、状況によっては（コンパイル時の評価など）、2つのポインターの不等式を判別できるとは限らないため、この関数は、後で実際に等しくないことが &lt;code&gt;false&lt;/code&gt; したポインターに対して誤ってfalseを返す場合があります。ただし、 &lt;code&gt;true&lt;/code&gt; が返されると、ポインターは等しくないことが保証されます。</target>
        </trans-unit>
        <trans-unit id="3ddac349169d1a744bfbed1eee12e4790040330f" translate="yes" xml:space="preserve">
          <source>At runtime this function behaves like &lt;code&gt;self == other&lt;/code&gt;. However, in some contexts (e.g., compile-time evaluation), it is not always possible to determine equality of two pointers, so this function may spuriously return &lt;code&gt;false&lt;/code&gt; for pointers that later actually turn out to be equal. But when it returns &lt;code&gt;true&lt;/code&gt;, the pointers are guaranteed to be equal.</source>
          <target state="translated">実行時、この関数は &lt;code&gt;self == other&lt;/code&gt; ように動作します。ただし、一部のコンテキスト（コンパイル時の評価など）では、2つのポインターが等しいかどうかを常に判断できるとは限らないため、この関数は、後で実際に等しいことが &lt;code&gt;false&lt;/code&gt; したポインターに対して誤ってfalseを返す場合があります。ただし、 &lt;code&gt;true&lt;/code&gt; を返す場合、ポインタは等しいことが保証されます。</target>
        </trans-unit>
        <trans-unit id="880cb1d1611d41944fc45c1105942f35a2cea331" translate="yes" xml:space="preserve">
          <source>At the beginning of this chapter, we said that vectors can only store values that are the same type. This can be inconvenient; there are definitely use cases for needing to store a list of items of different types. Fortunately, the variants of an enum are defined under the same enum type, so when we need to store elements of a different type in a vector, we can define and use an enum!</source>
          <target state="translated">この章の最初に、ベクターは同じ型の値しか格納できないと述べました。これは不便な場合があります。幸いなことに、列挙型のバリアントは同じ列挙型の下で定義されているので、異なる型の要素をベクトルに格納する必要があるときは、列挙型を定義して使用することができます!</target>
        </trans-unit>
        <trans-unit id="b0f9f410d4d3f041a8bbac0598dae49519ac5a0f" translate="yes" xml:space="preserve">
          <source>At the moment the &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; blocks have a lot of repetition: they&amp;rsquo;re both reading files and writing the contents of the files to the stream. The only differences are the status line and the filename. Let&amp;rsquo;s make the code more concise by pulling out those differences into separate &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; lines that will assign the values of the status line and the filename to variables; we can then use those variables unconditionally in the code to read the file and write the response. Listing 20-9 shows the resulting code after replacing the large &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; blocks.</source>
          <target state="translated">現時点では、 &lt;code&gt;if&lt;/code&gt; ブロックと &lt;code&gt;else&lt;/code&gt; ブロックには多くの繰り返しがあります。これらは両方とも、ファイルの読み取りとファイルのコンテンツのストリームへの書き込みを行っています。唯一の違いは、ステータス行とファイル名です。コード別々にそれらの違いを引き出すことにより、より簡潔にしてみましょう &lt;code&gt;if&lt;/code&gt; と &lt;code&gt;else&lt;/code&gt; ステータス行や変数にファイル名の値を代入します行を。次に、コード内でこれらの変数を無条件に使用して、ファイルを読み取り、応答を書き込みます。リスト20-9は、大きな &lt;code&gt;if&lt;/code&gt; ブロックと &lt;code&gt;else&lt;/code&gt; ブロックを置き換えた後の結果のコードを示しています。</target>
        </trans-unit>
        <trans-unit id="b1fe5f0e39ec55eb0cd362275db96ad9cd1656e2" translate="yes" xml:space="preserve">
          <source>At the moment, &lt;code&gt;for&lt;/code&gt; loops, &lt;code&gt;.await&lt;/code&gt;, and the &lt;code&gt;Try&lt;/code&gt; operator (&lt;code&gt;?&lt;/code&gt;) are forbidden inside a &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;static&lt;/code&gt;, or &lt;code&gt;const fn&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="929c7d4e23e7e49a6c726514ca62a32c23fbe8e1" translate="yes" xml:space="preserve">
          <source>At the moment, &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;match&lt;/code&gt;, as well as the looping constructs &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, and &lt;code&gt;loop&lt;/code&gt;, are forbidden inside a &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;static&lt;/code&gt;, or &lt;code&gt;const fn&lt;/code&gt;.</source>
          <target state="translated">現時点では、 &lt;code&gt;if&lt;/code&gt; と &lt;code&gt;match&lt;/code&gt; 、および、 &lt;code&gt;while&lt;/code&gt; 、 &lt;code&gt;loop&lt;/code&gt; のループ構造 &lt;code&gt;for&lt;/code&gt; 、 &lt;code&gt;const&lt;/code&gt; 、 &lt;code&gt;static&lt;/code&gt; 、または &lt;code&gt;const fn&lt;/code&gt; 内で禁止されています。</target>
        </trans-unit>
        <trans-unit id="1f16df13b8f4c863b823dc86f56453377891952c" translate="yes" xml:space="preserve">
          <source>At the moment, we&amp;rsquo;re writing all of our output to the terminal using the &lt;code&gt;println!&lt;/code&gt; function. Most terminals provide two kinds of output: &lt;em&gt;standard output&lt;/em&gt; (&lt;code&gt;stdout&lt;/code&gt;) for general information and &lt;em&gt;standard error&lt;/em&gt; (&lt;code&gt;stderr&lt;/code&gt;) for error messages. This distinction enables users to choose to direct the successful output of a program to a file but still print error messages to the screen.</source>
          <target state="translated">現時点では、 &lt;code&gt;println!&lt;/code&gt; を使用してすべての出力をターミナルに書き込んでいます！関数。ほとんどの端末は2種類の出力を提供します。一般情報の&lt;em&gt;標準出力&lt;/em&gt;（ &lt;code&gt;stdout&lt;/code&gt; ）とエラーメッセージの&lt;em&gt;標準エラー&lt;/em&gt;（ &lt;code&gt;stderr&lt;/code&gt; ）です。この区別により、ユーザーはプログラムの正常な出力をファイルに送信することを選択しながら、エラーメッセージを画面に出力することができます。</target>
        </trans-unit>
        <trans-unit id="8d5aa8f95e2e92d8aada8f026371cf7b990b2775" translate="yes" xml:space="preserve">
          <source>At the moment, we&amp;rsquo;re writing all of our output to the terminal using the &lt;code&gt;println!&lt;/code&gt; macro. Most terminals provide two kinds of output: &lt;em&gt;standard output&lt;/em&gt; (&lt;code&gt;stdout&lt;/code&gt;) for general information and &lt;em&gt;standard error&lt;/em&gt; (&lt;code&gt;stderr&lt;/code&gt;) for error messages. This distinction enables users to choose to direct the successful output of a program to a file but still print error messages to the screen.</source>
          <target state="translated">現時点では、 &lt;code&gt;println!&lt;/code&gt; を使用してすべての出力を端末に書き込んでいます。大きい。ほとんどの端末は、一般情報用の&lt;em&gt;標準出力&lt;/em&gt;（ &lt;code&gt;stdout&lt;/code&gt; ）とエラーメッセージ用の&lt;em&gt;標準エラー&lt;/em&gt;（ &lt;code&gt;stderr&lt;/code&gt; ）の2種類の出力を提供します。この区別により、ユーザーはプログラムの正常な出力をファイルに送信することを選択できますが、それでもエラーメッセージを画面に出力できます。</target>
        </trans-unit>
        <trans-unit id="3818ff95eb637709816bb6cd777c917a43bae444" translate="yes" xml:space="preserve">
          <source>At the time of this writing, an automatic formatter tool called &lt;code&gt;rustfmt&lt;/code&gt; is under development. If you want to stick to a standard style across Rust projects, &lt;code&gt;rustfmt&lt;/code&gt; will format your code in a particular style. The Rust team plans to eventually include this tool with the standard Rust distribution, like &lt;code&gt;rustc&lt;/code&gt;. So depending on when you read this book, it might already be installed on your computer! Check the online documentation for more details.</source>
          <target state="translated">この記事の執筆時点では、 &lt;code&gt;rustfmt&lt;/code&gt; と呼ばれる自動フォーマッターツールが開発中です。Rustプロジェクト全体で標準スタイルに固執する場合、 &lt;code&gt;rustfmt&lt;/code&gt; は特定のスタイルでコードをフォーマットします。Rustチームは、このツールを &lt;code&gt;rustc&lt;/code&gt; のような標準のRustディストリビューションに含める予定です。したがって、この本をいつ読むかによっては、すでにコンピュータにインストールされている場合があります。詳細については、オンラインドキュメントを確認してください。</target>
        </trans-unit>
        <trans-unit id="1eca2e64861fbf60436be0df95a81ecf4dd4db51" translate="yes" xml:space="preserve">
          <source>At the time of this writing, two Rust editions are available: Rust 2015 and Rust 2018. This book is written using Rust 2018 edition idioms.</source>
          <target state="translated">この記事を書いている時点では、2つのRust版があります。Rust 2015版とRust 2018版です。本書はRust 2018版の熟語を使って書かれています。</target>
        </trans-unit>
        <trans-unit id="d0b83ac2e98214df1ca34576f6616d27aede53ff" translate="yes" xml:space="preserve">
          <source>At the time, we said not to worry about the inefficient &lt;code&gt;clone&lt;/code&gt; calls because we would remove them in the future. Well, that time is now!</source>
          <target state="translated">現時点では、非効率的な &lt;code&gt;clone&lt;/code&gt; 呼び出しについては将来削除する予定なので、心配しないでください。さて、その時は今です！</target>
        </trans-unit>
        <trans-unit id="bf023d508177d86413d3379134e446a32a09142c" translate="yes" xml:space="preserve">
          <source>At the time, we skipped over some details in this code. In Chapter 6 in &lt;a href=&quot;ch06-02-match#the-match-control-flow-operator&quot;&gt;&amp;ldquo;The &lt;code&gt;match&lt;/code&gt; Control Flow Operator&amp;rdquo;&lt;/a&gt; section, we discussed that &lt;code&gt;match&lt;/code&gt; arms must all return the same type. So, for example, the following code doesn&amp;rsquo;t work:</source>
          <target state="translated">現時点では、このコードの一部の詳細はスキップしました。第6章&lt;a href=&quot;ch06-02-match#the-match-control-flow-operator&quot;&gt;「 &lt;code&gt;match&lt;/code&gt; 制御フロー演算子」&lt;/a&gt;セクションで、 &lt;code&gt;match&lt;/code&gt; アームはすべて同じ型を返す必要があることを説明しました。したがって、たとえば、次のコードは機能しません。</target>
        </trans-unit>
        <trans-unit id="7ade322c88e63df6a4a8c865c0fa8c7d63812d90" translate="yes" xml:space="preserve">
          <source>At this point, &lt;code&gt;cargo build&lt;/code&gt; should complete successfully in both &lt;code&gt;hello_macro&lt;/code&gt; and &lt;code&gt;hello_macro_derive&lt;/code&gt;. Let&amp;rsquo;s hook up these crates to the code in Listing 19-30 to see the procedural macro in action! Create a new binary project in your &lt;em&gt;projects&lt;/em&gt; directory using &lt;code&gt;cargo new pancakes&lt;/code&gt;. We need to add &lt;code&gt;hello_macro&lt;/code&gt; and &lt;code&gt;hello_macro_derive&lt;/code&gt; as dependencies in the &lt;code&gt;pancakes&lt;/code&gt; crate&amp;rsquo;s &lt;em&gt;Cargo.toml&lt;/em&gt;. If you&amp;rsquo;re publishing your versions of &lt;code&gt;hello_macro&lt;/code&gt; and &lt;code&gt;hello_macro_derive&lt;/code&gt; to &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt;, they would be regular dependencies; if not, you can specify them as &lt;code&gt;path&lt;/code&gt; dependencies as follows:</source>
          <target state="translated">この時点で、 &lt;code&gt;cargo build&lt;/code&gt; は &lt;code&gt;hello_macro&lt;/code&gt; と &lt;code&gt;hello_macro_derive&lt;/code&gt; の両方で正常に完了するはずです。これらのクレートをリスト19-30のコードに接続して、手続き型マクロの動作を見てみましょう！ &lt;code&gt;cargo new pancakes&lt;/code&gt; を使用して、&lt;em&gt;プロジェクト&lt;/em&gt;ディレクトリに新しいバイナリプロジェクトを作成します。 &lt;code&gt;pancakes&lt;/code&gt; クレートの&lt;em&gt;Cargo.tomlの&lt;/em&gt;依存関係として &lt;code&gt;hello_macro&lt;/code&gt; と &lt;code&gt;hello_macro_derive&lt;/code&gt; を追加する必要があります。あなたがあなたのバージョンの公開している場合 &lt;code&gt;hello_macro&lt;/code&gt; と &lt;code&gt;hello_macro_derive&lt;/code&gt; に&lt;a href=&quot;https://crates.io/&quot;&gt;crates.ioを&lt;/a&gt;、彼らは定期的な依存関係になります。そうでない場合は、次のように指定できます&lt;em&gt;&lt;/em&gt; &lt;code&gt;path&lt;/code&gt; 依存関係は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="b945ef4a755c9f52a155f619e7f39f1e0b11da63" translate="yes" xml:space="preserve">
          <source>At this point, &lt;code&gt;s&lt;/code&gt; will be &lt;code&gt;tic-tac-toe&lt;/code&gt;. With all of the &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;&quot;&lt;/code&gt; characters, it&amp;rsquo;s difficult to see what&amp;rsquo;s going on. For more complicated string combining, we can use the &lt;code&gt;format!&lt;/code&gt; macro:</source>
          <target state="translated">この時点で、 &lt;code&gt;s&lt;/code&gt; は &lt;code&gt;tic-tac-toe&lt;/code&gt; になります。 &lt;code&gt;+&lt;/code&gt; と &lt;code&gt;&quot;&lt;/code&gt; の文字がすべてあると、何が起こっているのかを確認するのが難しくなります。より複雑な文字列の組み合わせには、 &lt;code&gt;format!&lt;/code&gt; マクロを使用できます。</target>
        </trans-unit>
        <trans-unit id="bad906bb2d4d513518792ef63a17dbb628e284cd" translate="yes" xml:space="preserve">
          <source>At this point, the first part of the game is done: we&amp;rsquo;re getting input from the keyboard and then printing it.</source>
          <target state="translated">この時点で、ゲームの最初の部分が完了しました。キーボードから入力を取得して、それを印刷しています。</target>
        </trans-unit>
        <trans-unit id="645fa0bc97b2e92b8b41b6c72b5e6804e2731419" translate="yes" xml:space="preserve">
          <source>At this point, the relationship between scopes and when variables are valid is similar to that in other programming languages. Now we&amp;rsquo;ll build on top of this understanding by introducing the &lt;code&gt;String&lt;/code&gt; type.</source>
          <target state="translated">この時点で、スコープと変数が有効なときの関係は、他のプログラミング言語と同様です。次に、 &lt;code&gt;String&lt;/code&gt; 型を導入することで、この理解に基づいて構築します。</target>
        </trans-unit>
        <trans-unit id="440b2812ba3e248d39262c445df6cb473f1a4cf8" translate="yes" xml:space="preserve">
          <source>At this point, we can build the workspace by running &lt;code&gt;cargo build&lt;/code&gt;. The files in your &lt;em&gt;add&lt;/em&gt; directory should look like this:</source>
          <target state="translated">この時点で、 &lt;code&gt;cargo build&lt;/code&gt; を実行してワークスペースを構築できます。&lt;em&gt;追加&lt;/em&gt;ディレクトリ内のファイルは次のようになります。</target>
        </trans-unit>
        <trans-unit id="f644530959c577881d3641aeacacd055e0614725" translate="yes" xml:space="preserve">
          <source>At this point, we could consider opportunities for refactoring the implementation of the search function while keeping the tests passing to maintain the same functionality. The code in the search function isn&amp;rsquo;t too bad, but it doesn&amp;rsquo;t take advantage of some useful features of iterators. We&amp;rsquo;ll return to this example in &lt;a href=&quot;ch13-02-iterators&quot;&gt;Chapter 13&lt;/a&gt;, where we&amp;rsquo;ll explore iterators in detail, and look at how to improve it.</source>
          <target state="translated">この時点で、同じ機能を維持するためにテストに合格したまま、検索機能の実装をリファクタリングする機会を検討できます。検索関数のコードはそれほど悪くはありませんが、イテレーターのいくつかの便利な機能を利用していません。&lt;a href=&quot;ch13-02-iterators&quot;&gt;第13章で&lt;/a&gt;この例に戻り、イテレータを詳細に調べて、それを改善する方法を見ていきます。</target>
        </trans-unit>
        <trans-unit id="7be13e6f2293ee19341faecbce38cbce6581638c" translate="yes" xml:space="preserve">
          <source>At this point, we could consider opportunities for refactoring the implementation of the search function while keeping the tests passing to maintain the same functionality. The code in the search function isn&amp;rsquo;t too bad, but it doesn&amp;rsquo;t take advantage of some useful features of iterators. We&amp;rsquo;ll return to this example in [Chapter 13][ch13], where we&amp;rsquo;ll explore iterators in detail, and look at how to improve it.</source>
          <target state="translated">この時点で、同じ機能を維持するためにテストに合格したまま、検索機能の実装をリファクタリングする機会を検討できます。検索機能のコードはそれほど悪くはありませんが、反復子のいくつかの便利な機能を利用していません。[Chapter 13] [ch13]でこの例に戻り、イテレータを詳細に検討し、それを改善する方法を見ていきます。</target>
        </trans-unit>
        <trans-unit id="12d2e7392939d54c75dd7be38b3f433458f57624" translate="yes" xml:space="preserve">
          <source>At this point, when we call &lt;code&gt;content&lt;/code&gt; on the &lt;code&gt;&amp;amp;Box&amp;lt;dyn State&amp;gt;&lt;/code&gt;, deref coercion will take effect on the &lt;code&gt;&amp;amp;&lt;/code&gt; and the &lt;code&gt;Box&lt;/code&gt; so the &lt;code&gt;content&lt;/code&gt; method will ultimately be called on the type that implements the &lt;code&gt;State&lt;/code&gt; trait. That means we need to add &lt;code&gt;content&lt;/code&gt; to the &lt;code&gt;State&lt;/code&gt; trait definition, and that is where we&amp;rsquo;ll put the logic for what content to return depending on which state we have, as shown in Listing 17-18:</source>
          <target state="translated">この時点で、 &lt;code&gt;&amp;amp;Box&amp;lt;dyn State&amp;gt;&lt;/code&gt; で &lt;code&gt;content&lt;/code&gt; を呼び出すと、deref強制が &lt;code&gt;&amp;amp;&lt;/code&gt; と &lt;code&gt;Box&lt;/code&gt; で有効になるため、 &lt;code&gt;content&lt;/code&gt; メソッドは最終的に &lt;code&gt;State&lt;/code&gt; トレイトを実装する型で呼び出されます。つまり、リスト17-18に示すように、 &lt;code&gt;State&lt;/code&gt; トレイト定義に &lt;code&gt;content&lt;/code&gt; を追加する必要があることを意味します。ここに、どのステートに応じてどのコンテンツを返すかというロジックを配置します。</target>
        </trans-unit>
        <trans-unit id="41d03c60eead1f80179e902c1b4d9814280d6245" translate="yes" xml:space="preserve">
          <source>At this point, when we try to get a reference to the parent of &lt;code&gt;leaf&lt;/code&gt; by using the &lt;code&gt;upgrade&lt;/code&gt; method, we get a &lt;code&gt;None&lt;/code&gt; value. We see this in the output from the first &lt;code&gt;println!&lt;/code&gt; statement:</source>
          <target state="translated">この時点で、 &lt;code&gt;upgrade&lt;/code&gt; メソッドを使用して &lt;code&gt;leaf&lt;/code&gt; の親への参照を取得しようとすると、 &lt;code&gt;None&lt;/code&gt; 値が取得されます。これは、最初の &lt;code&gt;println!&lt;/code&gt; 出力で確認できます。ステートメント：</target>
        </trans-unit>
        <trans-unit id="3822c3ca41678f3e73f1513ee4103e0d10a48e3d" translate="yes" xml:space="preserve">
          <source>At this point, you would also notice a change in your &lt;em&gt;Cargo.lock&lt;/em&gt; file noting that the version of the &lt;code&gt;rand&lt;/code&gt; crate you are now using is &lt;code&gt;0.3.15&lt;/code&gt;.</source>
          <target state="translated">この時点で、&lt;em&gt;Cargo.lock&lt;/em&gt;ファイルが変更されていることが &lt;code&gt;0.3.15&lt;/code&gt; ます。これは、現在使用している &lt;code&gt;rand&lt;/code&gt; クレートのバージョンが0.3.15であることを示しています。</target>
        </trans-unit>
        <trans-unit id="980ca773a0cc1c507c75dc787b2ebd61a83c58ee" translate="yes" xml:space="preserve">
          <source>At this point, you would also notice a change in your &lt;em&gt;Cargo.lock&lt;/em&gt; file noting that the version of the &lt;code&gt;rand&lt;/code&gt; crate you are now using is &lt;code&gt;0.5.6&lt;/code&gt;.</source>
          <target state="translated">この時点で、あなたもあなたの変化に気づくでしょう&lt;em&gt;Cargo.lockの&lt;/em&gt;バージョンのことを指摘したファイル &lt;code&gt;rand&lt;/code&gt; あなたが今使っているクレートがある &lt;code&gt;0.5.6&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="ace63d2aec4c0fa2eb5be485664adddc5d8c8911" translate="yes" xml:space="preserve">
          <source>At this point, you&amp;rsquo;ve seen several ways of using patterns, but patterns don&amp;rsquo;t work the same in every place we can use them. In some places, the patterns must be irrefutable; in other circumstances, they can be refutable. We&amp;rsquo;ll discuss these two concepts next.</source>
          <target state="translated">この時点で、パターンを使用するいくつかの方法を見てきましたが、パターンは、使用できるすべての場所で同じように機能するわけではありません。一部の場所では、パターンは反駁できないものでなければなりません。他の状況では、彼らは反駁することができます。次に、これらの2つの概念について説明します。</target>
        </trans-unit>
        <trans-unit id="e19eb30ab901969b293ab5f50d80d0816b9dd309" translate="yes" xml:space="preserve">
          <source>At this point, you&amp;rsquo;ve successfully built the guessing game. Congratulations!</source>
          <target state="translated">この時点で、推測ゲームの構築に成功しました。おめでとう！</target>
        </trans-unit>
        <trans-unit id="632731832807bd949f8afaff185b846c11bff1a6" translate="yes" xml:space="preserve">
          <source>Atomic Reference Counting with &lt;code id=&quot;atomic-reference-counting-with-arct&quot;&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code id=&quot;atomic-reference-counting-with-arct&quot;&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; による原子参照カウント</target>
        </trans-unit>
        <trans-unit id="81578fbf1ea44596108fd645f27e6431bf82318a" translate="yes" xml:space="preserve">
          <source>Atomic memory orderings</source>
          <target state="translated">原子記憶の順序付け</target>
        </trans-unit>
        <trans-unit id="7d5338021e809e34d20a6b06646a458b5152b9dc" translate="yes" xml:space="preserve">
          <source>Atomic operations may be implemented at the instruction layer with larger-size atomics. For example some platforms use 4-byte atomic instructions to implement &lt;code&gt;AtomicI8&lt;/code&gt;. Note that this emulation should not have an impact on correctness of code, it's just something to be aware of.</source>
          <target state="translated">アトミック操作は、より大きなサイズのアトミックで命令層に実装できます。たとえば、一部のプラットフォームでは、4バイトのアトミック命令を使用して &lt;code&gt;AtomicI8&lt;/code&gt; を実装しています。このエミュレーションはコードの正確さに影響を与えるべきではないことに注意してください。これは注意すべきことです。</target>
        </trans-unit>
        <trans-unit id="8e24008909c0fc6f23ca4f4f874bb53512815caa" translate="yes" xml:space="preserve">
          <source>Atomic operations with &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; semantics can also synchronize with a fence.</source>
          <target state="translated">&lt;a href=&quot;enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt;セマンティクスによるアトミック操作もフェンスと同期できます。</target>
        </trans-unit>
        <trans-unit id="6bd53298c2672a3d3501c1b3d668970f3f55e051" translate="yes" xml:space="preserve">
          <source>Atomic types</source>
          <target state="translated">原子型</target>
        </trans-unit>
        <trans-unit id="bd540eaa28be66ef79bdb0e6dc9e7f21a135c077" translate="yes" xml:space="preserve">
          <source>Atomic types may be stored in static variables, initialized using the constant initializers like &lt;a href=&quot;struct.atomicbool#method.new&quot;&gt;&lt;code&gt;AtomicBool::new&lt;/code&gt;&lt;/a&gt;. Atomic statics are often used for lazy global initialization.</source>
          <target state="translated">原子型は静的変数に格納され、&lt;a href=&quot;struct.atomicbool#method.new&quot;&gt; &lt;code&gt;AtomicBool::new&lt;/code&gt; &lt;/a&gt;ような定数初期化子を使用して初期化されます。原子統計は、遅延グローバル初期化によく使用されます。</target>
        </trans-unit>
        <trans-unit id="af8191cce263e5511ffa70b9167ccc44038ee579" translate="yes" xml:space="preserve">
          <source>Atomic types provide primitive shared-memory communication between threads, and are the building blocks of other concurrent types.</source>
          <target state="translated">アトミック型は、スレッド間のプリミティブな共有メモリ通信を提供し、他の並行型の構成要素となります。</target>
        </trans-unit>
        <trans-unit id="489ec10910f60409e46dc7b2401064ba30bfb22a" translate="yes" xml:space="preserve">
          <source>Atomic variables are safe to share between threads (they implement &lt;a href=&quot;../../marker/trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;) but they do not themselves provide the mechanism for sharing and follow the &lt;a href=&quot;../../thread/index#the-threading-model&quot;&gt;threading model&lt;/a&gt; of Rust. The most common way to share an atomic variable is to put it into an &lt;a href=&quot;../struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; (an atomically-reference-counted shared pointer).</source>
          <target state="translated">アトミック変数はスレッド間で安全に共有できますが（&lt;a href=&quot;../../marker/trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt;を実装します）、それら自体は共有するためのメカニズムを提供せず、Rustの&lt;a href=&quot;../../thread/index#the-threading-model&quot;&gt;スレッドモデル&lt;/a&gt;に従います。アトミック変数を共有する最も一般的な方法は、それを&lt;a href=&quot;../struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt;（アトミック参照カウントされた共有ポインター）に配置することです。</target>
        </trans-unit>
        <trans-unit id="bdcc7b682e49710ce243d11d666d0605dd24412a" translate="yes" xml:space="preserve">
          <source>Atomic variables are safe to share between threads (they implement &lt;a href=&quot;../../marker/trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;) but they do not themselves provide the mechanism for sharing and follow the &lt;a href=&quot;../../thread/index#the-threading-model&quot;&gt;threading model&lt;/a&gt; of rust. The most common way to share an atomic variable is to put it into an &lt;a href=&quot;../struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; (an atomically-reference-counted shared pointer).</source>
          <target state="translated">原子変数はスレッド間で安全に共有できます（それらは&lt;a href=&quot;../../marker/trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt;を実装します）が、それら自体は共有のメカニズムを提供せず、錆の&lt;a href=&quot;../../thread/index#the-threading-model&quot;&gt;スレッドモデル&lt;/a&gt;に従っています。アトミック変数を共有する最も一般的な方法は、それを&lt;a href=&quot;../struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt;（アトミック参照でカウントされる共有ポインター）に配置することです。</target>
        </trans-unit>
        <trans-unit id="6674d00db7a2e69964175c1325e3eccae698e4d3" translate="yes" xml:space="preserve">
          <source>AtomicBool</source>
          <target state="translated">AtomicBool</target>
        </trans-unit>
        <trans-unit id="c3f581e842f52532b7b151cdbc4ce7233b954e8c" translate="yes" xml:space="preserve">
          <source>AtomicI16</source>
          <target state="translated">AtomicI16</target>
        </trans-unit>
        <trans-unit id="29b774c369d481cc7134a7a13427afa21b7fc9cd" translate="yes" xml:space="preserve">
          <source>AtomicI32</source>
          <target state="translated">AtomicI32</target>
        </trans-unit>
        <trans-unit id="d734b8bd0031516fdc53fb6831e8dec9b067b165" translate="yes" xml:space="preserve">
          <source>AtomicI64</source>
          <target state="translated">AtomicI64</target>
        </trans-unit>
        <trans-unit id="e94562e900680db9e18fda42ce322ce7a5e558bf" translate="yes" xml:space="preserve">
          <source>AtomicI8</source>
          <target state="translated">AtomicI8</target>
        </trans-unit>
        <trans-unit id="c2cc2ca63393294d4014028c732f15eca926e7a2" translate="yes" xml:space="preserve">
          <source>AtomicIsize</source>
          <target state="translated">AtomicIsize</target>
        </trans-unit>
        <trans-unit id="7bc45caa3c8c7a6bbad87dd4b67403e414361ce1" translate="yes" xml:space="preserve">
          <source>AtomicPtr</source>
          <target state="translated">AtomicPtr</target>
        </trans-unit>
        <trans-unit id="17a70c0c14e8b2c47d91d2253122896320428148" translate="yes" xml:space="preserve">
          <source>AtomicU16</source>
          <target state="translated">AtomicU16</target>
        </trans-unit>
        <trans-unit id="8840103173e424948e002b5ffec50c44e404d250" translate="yes" xml:space="preserve">
          <source>AtomicU32</source>
          <target state="translated">AtomicU32</target>
        </trans-unit>
        <trans-unit id="32ac2d92ec899ed90a2638fc480a4297cef99b45" translate="yes" xml:space="preserve">
          <source>AtomicU64</source>
          <target state="translated">AtomicU64</target>
        </trans-unit>
        <trans-unit id="a496370705e1f84302673bc11932128de26a2fea" translate="yes" xml:space="preserve">
          <source>AtomicU8</source>
          <target state="translated">AtomicU8</target>
        </trans-unit>
        <trans-unit id="9d9469a55330492f15842defa35b0f1ef07cac12" translate="yes" xml:space="preserve">
          <source>AtomicUsize</source>
          <target state="translated">AtomicUsize</target>
        </trans-unit>
        <trans-unit id="48c5fb201c75414dd3666a318d954dd873099b2d" translate="yes" xml:space="preserve">
          <source>Atomically makes the handle's token available if it is not already.</source>
          <target state="translated">ハンドルのトークンがまだ存在しない場合は、そのトークンを利用可能な状態にします。</target>
        </trans-unit>
        <trans-unit id="22cd0cbd81dee9dcd227285a4fb456261af24ea4" translate="yes" xml:space="preserve">
          <source>Atomics</source>
          <target state="translated">Atomics</target>
        </trans-unit>
        <trans-unit id="fe4c2e56ace1dd5cd16118bb6ad5e5256c61db83" translate="yes" xml:space="preserve">
          <source>Attempt to downcast the &lt;code&gt;Arc&amp;lt;dyn Any + Send + Sync&amp;gt;&lt;/code&gt; to a concrete type.</source>
          <target state="translated">&lt;code&gt;Arc&amp;lt;dyn Any + Send + Sync&amp;gt;&lt;/code&gt; を具象タイプにダウンキャストしてみます。</target>
        </trans-unit>
        <trans-unit id="92df3d44a91e7d67c064d6d725fec8b2e940cc64" translate="yes" xml:space="preserve">
          <source>Attempt to downcast the &lt;code&gt;Rc&amp;lt;dyn Any&amp;gt;&lt;/code&gt; to a concrete type.</source>
          <target state="translated">&lt;code&gt;Rc&amp;lt;dyn Any&amp;gt;&lt;/code&gt; を具象型にダウンキャストしてみます。</target>
        </trans-unit>
        <trans-unit id="886d23c3fa7b51635fa7bbdd282f2babcd6cb45c" translate="yes" xml:space="preserve">
          <source>Attempt to downcast the box to a concrete type.</source>
          <target state="translated">箱をコンクリートタイプにダウンキャストしてみます。</target>
        </trans-unit>
        <trans-unit id="175cf296f94bed8278b4e811c5245f622f67f97c" translate="yes" xml:space="preserve">
          <source>Attempt to resolve the future to a final value, registering the current task for wakeup if the value is not yet available.</source>
          <target state="translated">値がまだ利用可能でない場合、現在のタスクをウェイクアップ用に登録して、未来を最終的な値に解決しようとします。</target>
        </trans-unit>
        <trans-unit id="0b1794f780a4845e82f1aa618849777a9e5b6e42" translate="yes" xml:space="preserve">
          <source>Attempt to resolve the future to a final value, registering the current task for wakeup if the value is not yet available. &lt;a href=&quot;../future/trait.future#tymethod.poll&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">将来を最終的な値に解決することを試み、値がまだ利用できない場合は、現在のタスクをウェイクアップに登録します。&lt;a href=&quot;../future/trait.future#tymethod.poll&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="55136df45140cab2915451715291fdde1ced9b25" translate="yes" xml:space="preserve">
          <source>Attempt to resolve the future to a final value, registering the current task for wakeup if the value is not yet available. &lt;a href=&quot;future/trait.future#tymethod.poll&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">将来を最終的な値に解決することを試み、値がまだ利用できない場合は、現在のタスクをウェイクアップに登録します。&lt;a href=&quot;future/trait.future#tymethod.poll&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a9dc2a85c8ec42aea412c46625d0258c82f5009a" translate="yes" xml:space="preserve">
          <source>Attempt to resolve the future to a final value, registering the current task for wakeup if the value is not yet available. &lt;a href=&quot;trait.future#tymethod.poll&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">値がまだ利用できない場合は、ウェイクアップのために現在のタスクを登録して、将来を最終値に解決しようとします。&lt;a href=&quot;trait.future#tymethod.poll&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="856e8b63203e04805b09dd95b9d3481ff3097c22" translate="yes" xml:space="preserve">
          <source>Attempt was made to import an item whereas an extern crate with this name has already been imported.</source>
          <target state="translated">この名前の外部クレートが既にインポートされているアイテムをインポートしようとしました。</target>
        </trans-unit>
        <trans-unit id="5fc738aa7f6254311ae3614b150f4fe1cec8fe27" translate="yes" xml:space="preserve">
          <source>Attempt was made to import an unimportable value. This can happen when trying to import a method from a trait.</source>
          <target state="translated">重要でない値をインポートしようとしました。これは、形質からメソッドをインポートしようとしたときに起こる可能性があります。</target>
        </trans-unit>
        <trans-unit id="2c61d256e7903ca5ede61e01fd8467962bbb349b" translate="yes" xml:space="preserve">
          <source>Attempted to access a field on a primitive type.</source>
          <target state="translated">プリミティブ型のフィールドにアクセスしようとしました。</target>
        </trans-unit>
        <trans-unit id="a54332e7df630f85a467d7ec89246d77c007b643" translate="yes" xml:space="preserve">
          <source>Attempted to access a method like a field.</source>
          <target state="translated">フィールドのようなメソッドにアクセスしようとしました。</target>
        </trans-unit>
        <trans-unit id="48f28400d9c83d5af115ff62dc11ba5e26ca8457" translate="yes" xml:space="preserve">
          <source>Attempted to access a non-existent field in a struct.</source>
          <target state="translated">構造体に存在しないフィールドにアクセスしようとしました。</target>
        </trans-unit>
        <trans-unit id="03b41486da885815831596a9c99e4264efdf5d06" translate="yes" xml:space="preserve">
          <source>Attempted to access a private field on a struct.</source>
          <target state="translated">構造体のプライベート・フィールドにアクセスしようとしました。</target>
        </trans-unit>
        <trans-unit id="a1ad3c1a31bd1ae534677401ea798535b99a38e5" translate="yes" xml:space="preserve">
          <source>Attempted to call something which isn't a function nor a method.</source>
          <target state="translated">関数でもメソッドでもないものを呼ぼうとしました。</target>
        </trans-unit>
        <trans-unit id="19e440b538f0d8907b6a787acfc5bb52be0236f7" translate="yes" xml:space="preserve">
          <source>Attempted to cast to/from a pointer with an unknown kind.</source>
          <target state="translated">種類が不明なポインタからのキャストを試みました。</target>
        </trans-unit>
        <trans-unit id="eef4156ee856f3204829c854633733e0594d2319" translate="yes" xml:space="preserve">
          <source>Attempted to dereference a variable which cannot be dereferenced.</source>
          <target state="translated">参照元にできない変数を参照元に戻そうとしました。</target>
        </trans-unit>
        <trans-unit id="1372db0ea32a319cb23e92d2e2d51b6cd2d1a4fb" translate="yes" xml:space="preserve">
          <source>Attempted to pass an invalid type of variable into a variadic function.</source>
          <target state="translated">無効な型の変数を可変関数に渡そうとしました。</target>
        </trans-unit>
        <trans-unit id="7adfef6b18f86865559fc727494e616e0b3f7f80" translate="yes" xml:space="preserve">
          <source>Attempting to compile now gives us the following output:</source>
          <target state="translated">コンパイルしようとすると、以下のような出力が得られます。</target>
        </trans-unit>
        <trans-unit id="e83036683d0914f18e7de7ebbb8a14c9db8b6c5c" translate="yes" xml:space="preserve">
          <source>Attempting to compile this code results in this type error:</source>
          <target state="translated">このコードをコンパイルしようとすると、このタイプのエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="71aec9a6c07f86af18ab65ed514253e4a11e1117" translate="yes" xml:space="preserve">
          <source>Attempting to create a &lt;a href=&quot;enum.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt; iterator from an improperly formatted socket address &lt;code&gt;&amp;amp;str&lt;/code&gt; (missing the port):</source>
          <target state="translated">不適切にフォーマットされたソケットアドレス &lt;code&gt;&amp;amp;str&lt;/code&gt; （ポートがない）から&lt;a href=&quot;enum.socketaddr&quot;&gt; &lt;code&gt;SocketAddr&lt;/code&gt; &lt;/a&gt;イテレータを作成しようとしています：</target>
        </trans-unit>
        <trans-unit id="ef35b76897ce014407ed31f4f40475dbcd2bb582" translate="yes" xml:space="preserve">
          <source>Attempting to create a raw pointer to an &lt;code&gt;unaligned&lt;/code&gt; struct field with an expression such as &lt;code&gt;&amp;amp;packed.unaligned as *const FieldType&lt;/code&gt; creates an intermediate unaligned reference before converting that to a raw pointer. That this reference is temporary and immediately cast is inconsequential as the compiler always expects references to be properly aligned. As a result, using &lt;code&gt;&amp;amp;packed.unaligned as *const FieldType&lt;/code&gt; causes immediate &lt;em&gt;undefined behavior&lt;/em&gt; in your program.</source>
          <target state="translated">&lt;code&gt;&amp;amp;packed.unaligned as *const FieldType&lt;/code&gt; などの式を使用して、 &lt;code&gt;unaligned&lt;/code&gt; れていない構造体フィールドへの生のポインターを作成しようとすると、生のポインターに変換する前に、中間の整列されていない参照が作成されます。この参照が一時的であり、すぐにキャストされることは、コンパイラが常に参照が適切に整列されることを期待しているため、重要ではありません。その結果、 &lt;code&gt;&amp;amp;packed.unaligned as *const FieldType&lt;/code&gt; 使用すると、プログラムで即座に&lt;em&gt;未定義の動作&lt;/em&gt;が発生します。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="baf8e0e513c1e7d75d1c56986d1f69437e36903e" translate="yes" xml:space="preserve">
          <source>Attempting to create a trait object for a non object-safe trait will trigger this error.</source>
          <target state="translated">オブジェクトセーフでない形質に対して形質オブジェクトを作成しようとすると、このエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="fcaf285fe223ac76c6b6f3a248ca791f9480d826" translate="yes" xml:space="preserve">
          <source>Attempts to acquire this lock.</source>
          <target state="translated">このロックを取得しようとします。</target>
        </trans-unit>
        <trans-unit id="ed9809bcb2ab4f39482ae3c8ecc3990c35b19e02" translate="yes" xml:space="preserve">
          <source>Attempts to acquire this rwlock with shared read access.</source>
          <target state="translated">共有読み取りアクセスでこの rwlock を取得しようとします。</target>
        </trans-unit>
        <trans-unit id="60ca78e1d1551297af7765e326760c4a38aa394c" translate="yes" xml:space="preserve">
          <source>Attempts to allocate a block of memory.</source>
          <target state="translated">メモリブロックの割り当てを試みます。</target>
        </trans-unit>
        <trans-unit id="943f34bb668f31f44c32b4ace4e03989407198f9" translate="yes" xml:space="preserve">
          <source>Attempts to allocate a block of memory. &lt;a href=&quot;alloc/trait.allocator#tymethod.allocate&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="855d837817da86285b7a962a1f7fe2fb0ca3b0f2" translate="yes" xml:space="preserve">
          <source>Attempts to allocate a block of memory. &lt;a href=&quot;alloc/trait.allocref#tymethod.alloc&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">メモリのブロックを割り当てようとします。&lt;a href=&quot;alloc/trait.allocref#tymethod.alloc&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1c43d8666b34161b53b0b2ccf4916af8bde88930" translate="yes" xml:space="preserve">
          <source>Attempts to allocate a block of memory. &lt;a href=&quot;trait.allocator#tymethod.allocate&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cba17f171bdff89eb9e4d13d3205c5589ee7c0ea" translate="yes" xml:space="preserve">
          <source>Attempts to allocate a block of memory. &lt;a href=&quot;trait.allocref#tymethod.alloc&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">メモリのブロックを割り当てようとします。&lt;a href=&quot;trait.allocref#tymethod.alloc&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="aa06f6d37e15f994598953d5d55e85873c353cbb" translate="yes" xml:space="preserve">
          <source>Attempts to collect the exit status of the child if it has already exited.</source>
          <target state="translated">子プロセスが既に終了している場合に、その子プロセスの終了状況を収集しようとします。</target>
        </trans-unit>
        <trans-unit id="c1be452e1098fe5e2ba823c663805fe4f191d856" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI128&lt;/code&gt; to &lt;code&gt;NonZeroI16&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI128&lt;/code&gt; を &lt;code&gt;NonZeroI16&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="e0f700a71652c58da7326026511c609bb65c78a5" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI128&lt;/code&gt; to &lt;code&gt;NonZeroI32&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI128&lt;/code&gt; を &lt;code&gt;NonZeroI32&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="a1b8bfe658e12622625c1e875a019db8830b0989" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI128&lt;/code&gt; to &lt;code&gt;NonZeroI64&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI128&lt;/code&gt; を &lt;code&gt;NonZeroI64&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="66a76479bea9155fc85828e929db52c84fd63e6c" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI128&lt;/code&gt; to &lt;code&gt;NonZeroI8&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI128&lt;/code&gt; を &lt;code&gt;NonZeroI8&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="b97a798e91eb0541c3e3c246eb5e2ac5797cb455" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI128&lt;/code&gt; to &lt;code&gt;NonZeroIsize&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI128&lt;/code&gt; を &lt;code&gt;NonZeroIsize&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="ed691c14807b35b2f2548e2bc752f978c9b573b3" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI128&lt;/code&gt; to &lt;code&gt;NonZeroU128&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI128&lt;/code&gt; を &lt;code&gt;NonZeroU128&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="468a506dd2d83e7c4d19f2315c61b797dc6e4d81" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI128&lt;/code&gt; to &lt;code&gt;NonZeroU16&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI128&lt;/code&gt; を &lt;code&gt;NonZeroU16&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="501645681c486dcfde763f239c9dbc39c9a89e74" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI128&lt;/code&gt; to &lt;code&gt;NonZeroU32&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI128&lt;/code&gt; を &lt;code&gt;NonZeroU32&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="e87e26b0a7cd242115748e46f0ec96044936078e" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI128&lt;/code&gt; to &lt;code&gt;NonZeroU64&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI128&lt;/code&gt; を &lt;code&gt;NonZeroU64&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="8a0d914b6e10991069d8605388d14c2b1ca592cd" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI128&lt;/code&gt; to &lt;code&gt;NonZeroU8&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI128&lt;/code&gt; を &lt;code&gt;NonZeroU8&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="958ed88b5c4639ba37034945d4fa7653d11ec14d" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI128&lt;/code&gt; to &lt;code&gt;NonZeroUsize&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI128&lt;/code&gt; を &lt;code&gt;NonZeroUsize&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="be612cdd6f48c673bcc19746b3317e990d42bddc" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI16&lt;/code&gt; to &lt;code&gt;NonZeroI8&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI16&lt;/code&gt; を &lt;code&gt;NonZeroI8&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="3c356c6158c8679c2d029abe3620f468bf5b9b89" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI16&lt;/code&gt; to &lt;code&gt;NonZeroU128&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI16&lt;/code&gt; を &lt;code&gt;NonZeroU128&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="42ea0a6247bb234c0382208391062366c8d45afa" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI16&lt;/code&gt; to &lt;code&gt;NonZeroU16&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI16&lt;/code&gt; を &lt;code&gt;NonZeroU16&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="de4b3bab90d338dc97a29e174b6ac89affad0eee" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI16&lt;/code&gt; to &lt;code&gt;NonZeroU32&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI16&lt;/code&gt; を &lt;code&gt;NonZeroU32&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="3306b6d8338537145c4e522fa6d3095a838e24ed" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI16&lt;/code&gt; to &lt;code&gt;NonZeroU64&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI16&lt;/code&gt; を &lt;code&gt;NonZeroU64&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="1b8c226a4f3a2e9faf3bd2edc42cfa8c056aa1dc" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI16&lt;/code&gt; to &lt;code&gt;NonZeroU8&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI16&lt;/code&gt; を &lt;code&gt;NonZeroU8&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="2350a1a3377e42242cdfb3bcc58bf4230d39faee" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI16&lt;/code&gt; to &lt;code&gt;NonZeroUsize&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI16&lt;/code&gt; を &lt;code&gt;NonZeroUsize&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="616abf596e103379ba7981d5f1e76f05a2ea5666" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI32&lt;/code&gt; to &lt;code&gt;NonZeroI16&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI32&lt;/code&gt; を &lt;code&gt;NonZeroI16&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="f894e5fc7159364d10324e42a2aabd76a1311686" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI32&lt;/code&gt; to &lt;code&gt;NonZeroI8&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI32&lt;/code&gt; を &lt;code&gt;NonZeroI8&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="e0ae0dea78c18426532483b357c55d9190d0c56e" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI32&lt;/code&gt; to &lt;code&gt;NonZeroIsize&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI32&lt;/code&gt; を &lt;code&gt;NonZeroIsize&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="1ef3839c406eb138bd48f980d20053dec4a89576" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI32&lt;/code&gt; to &lt;code&gt;NonZeroU128&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI32&lt;/code&gt; を &lt;code&gt;NonZeroU128&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="18c41b12b6a5c51bf92010b091987428554830e8" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI32&lt;/code&gt; to &lt;code&gt;NonZeroU16&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI32&lt;/code&gt; を &lt;code&gt;NonZeroU16&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="5448bf065e3955c9eea9670b86f542b60f1a0d99" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI32&lt;/code&gt; to &lt;code&gt;NonZeroU32&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI32&lt;/code&gt; を &lt;code&gt;NonZeroU32&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="0c5994e4c20d71914f91892cc5ecb435c7068406" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI32&lt;/code&gt; to &lt;code&gt;NonZeroU64&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI32&lt;/code&gt; を &lt;code&gt;NonZeroU64&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="c142214aae8a432d7a06e49f1095d64d5abcf8e1" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI32&lt;/code&gt; to &lt;code&gt;NonZeroU8&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI32&lt;/code&gt; を &lt;code&gt;NonZeroU8&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="6debd548d7dfbbbf4dd441963174cff21d7cdf02" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI32&lt;/code&gt; to &lt;code&gt;NonZeroUsize&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI32&lt;/code&gt; を &lt;code&gt;NonZeroUsize&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="e5bd3db3824015309ca5994329cb635606bb61e3" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI64&lt;/code&gt; to &lt;code&gt;NonZeroI16&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI64&lt;/code&gt; を &lt;code&gt;NonZeroI16&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="c9e3ad073d959cecc0ef2f46909df5654f941abe" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI64&lt;/code&gt; to &lt;code&gt;NonZeroI32&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI64&lt;/code&gt; を &lt;code&gt;NonZeroI32&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="27970ce49dac2a260596044481b8209701cc6df9" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI64&lt;/code&gt; to &lt;code&gt;NonZeroI8&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI64&lt;/code&gt; を &lt;code&gt;NonZeroI8&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="5cc731c548e3edd60d482acb352eb954334d827f" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI64&lt;/code&gt; to &lt;code&gt;NonZeroIsize&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI64&lt;/code&gt; を &lt;code&gt;NonZeroIsize&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="eaf1693e06446e1b570049dea824ca2f5de4f983" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI64&lt;/code&gt; to &lt;code&gt;NonZeroU128&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI64&lt;/code&gt; を &lt;code&gt;NonZeroU128&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="fbf21f7180107143b1c2df0ada7adb608ce576f5" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI64&lt;/code&gt; to &lt;code&gt;NonZeroU16&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI64&lt;/code&gt; を &lt;code&gt;NonZeroU16&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="933cccb563bf70c8384b3537cf5d53af66522f2f" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI64&lt;/code&gt; to &lt;code&gt;NonZeroU32&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI64&lt;/code&gt; を &lt;code&gt;NonZeroU32&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="8b1923808fa8774e72e6b98f0d83b066dadba4e2" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI64&lt;/code&gt; to &lt;code&gt;NonZeroU64&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI64&lt;/code&gt; を &lt;code&gt;NonZeroU64&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="354ab0355cf5bb942ae945004201e3e00a7b805c" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI64&lt;/code&gt; to &lt;code&gt;NonZeroU8&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI64&lt;/code&gt; を &lt;code&gt;NonZeroU8&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="e1efb3585f71154fa405501c22aeb01a824f8ab1" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI64&lt;/code&gt; to &lt;code&gt;NonZeroUsize&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI64&lt;/code&gt; を &lt;code&gt;NonZeroUsize&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="c157007b3ce40ab86f83ee061270c2516fbee74c" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI8&lt;/code&gt; to &lt;code&gt;NonZeroU128&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI8&lt;/code&gt; を &lt;code&gt;NonZeroU128&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="8a3363ae51b3ea763ca696b60555078ab17bcbb4" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI8&lt;/code&gt; to &lt;code&gt;NonZeroU16&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI8&lt;/code&gt; を &lt;code&gt;NonZeroU16&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="74c1a1e7cdabd9277cf3f6090aec0cbb69fbae9d" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI8&lt;/code&gt; to &lt;code&gt;NonZeroU32&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI8&lt;/code&gt; を &lt;code&gt;NonZeroU32&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="a1fa909a8d07ec9bebd2c3a4ba3244aa21e756ab" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI8&lt;/code&gt; to &lt;code&gt;NonZeroU64&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI8&lt;/code&gt; を &lt;code&gt;NonZeroU64&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="4fc706f3890ff34068fa3987549fc9e943e12ee7" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI8&lt;/code&gt; to &lt;code&gt;NonZeroU8&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI8&lt;/code&gt; を &lt;code&gt;NonZeroU8&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="9406edc100eab7a11042f495f5605472cde3da93" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroI8&lt;/code&gt; to &lt;code&gt;NonZeroUsize&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroI8&lt;/code&gt; を &lt;code&gt;NonZeroUsize&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="9302879ee5829e1588c324186708b8a56fd80bf6" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroIsize&lt;/code&gt; to &lt;code&gt;NonZeroI128&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroIsize&lt;/code&gt; を &lt;code&gt;NonZeroI128&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="b776a75cae811bf723255d190f55f89b79a29f17" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroIsize&lt;/code&gt; to &lt;code&gt;NonZeroI16&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroIsize&lt;/code&gt; を &lt;code&gt;NonZeroI16&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="332b91f901664ebad9ee86d115e69f5a7a3b4d2e" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroIsize&lt;/code&gt; to &lt;code&gt;NonZeroI32&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroIsize&lt;/code&gt; を &lt;code&gt;NonZeroI32&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="d9f1ac4806f54fa95041af1e83978837424908c0" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroIsize&lt;/code&gt; to &lt;code&gt;NonZeroI64&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroIsize&lt;/code&gt; を &lt;code&gt;NonZeroI64&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="9382ddfacff70da4aaa8665a550fdda9aeffbdbe" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroIsize&lt;/code&gt; to &lt;code&gt;NonZeroI8&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroIsize&lt;/code&gt; を &lt;code&gt;NonZeroI8&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="30cfff31cec5836c2d435b155797b06f97a88b5a" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroIsize&lt;/code&gt; to &lt;code&gt;NonZeroU128&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroIsize&lt;/code&gt; を &lt;code&gt;NonZeroU128&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="79e1a0344dcbdab94d2a5a137db0b6fe3077cc05" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroIsize&lt;/code&gt; to &lt;code&gt;NonZeroU16&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroIsize&lt;/code&gt; を &lt;code&gt;NonZeroU16&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="4b5d4e575e612dc8137f25de68e1c8c2bca6bb80" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroIsize&lt;/code&gt; to &lt;code&gt;NonZeroU32&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroIsize&lt;/code&gt; を &lt;code&gt;NonZeroU32&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="0813f21e382c2efbc0af883a820eed2568b9960b" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroIsize&lt;/code&gt; to &lt;code&gt;NonZeroU64&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroIsize&lt;/code&gt; を &lt;code&gt;NonZeroU64&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="93fb19758341f597fd85cf5eff51cea75139832f" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroIsize&lt;/code&gt; to &lt;code&gt;NonZeroU8&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroIsize&lt;/code&gt; を &lt;code&gt;NonZeroU8&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="8ec588e739f156798bddcb79b1a4f397464f2ee1" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroIsize&lt;/code&gt; to &lt;code&gt;NonZeroUsize&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroIsize&lt;/code&gt; を &lt;code&gt;NonZeroUsize&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="f9cb3c9348ff015679d375f740e5de8691a989ad" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU128&lt;/code&gt; to &lt;code&gt;NonZeroI128&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU128&lt;/code&gt; を &lt;code&gt;NonZeroI128&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="78453501b58efe0df37ba60dce757e854979bf0b" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU128&lt;/code&gt; to &lt;code&gt;NonZeroI16&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU128&lt;/code&gt; を &lt;code&gt;NonZeroI16&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="1754f440af8e327e3628892e889e890ca0fdfa7a" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU128&lt;/code&gt; to &lt;code&gt;NonZeroI32&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU128&lt;/code&gt; を &lt;code&gt;NonZeroI32&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="04f7b535be0370cddd62901980eb0ddf9e3fbcef" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU128&lt;/code&gt; to &lt;code&gt;NonZeroI64&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU128&lt;/code&gt; を &lt;code&gt;NonZeroI64&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="e99899bbe257c97c7294c60c8cbb6dcdaba0937c" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU128&lt;/code&gt; to &lt;code&gt;NonZeroI8&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU128&lt;/code&gt; を &lt;code&gt;NonZeroI8&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="50ffacd53f0d563c90eca54db4e3068e8ac7bc58" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU128&lt;/code&gt; to &lt;code&gt;NonZeroIsize&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU128&lt;/code&gt; を &lt;code&gt;NonZeroIsize&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="c32f0af0599976a74621043264a001a3e32ccab3" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU128&lt;/code&gt; to &lt;code&gt;NonZeroU16&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU128&lt;/code&gt; を &lt;code&gt;NonZeroU16&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="99847ce375f1c7bf52ad9dbf9cbe8ebc71c7e0d1" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU128&lt;/code&gt; to &lt;code&gt;NonZeroU32&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU128&lt;/code&gt; を &lt;code&gt;NonZeroU32&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="5abc78a9982271a77eb82cbdd6f2e2a5c397b7e8" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU128&lt;/code&gt; to &lt;code&gt;NonZeroU64&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU128&lt;/code&gt; を &lt;code&gt;NonZeroU64&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="2c394131db124e9071401792a8209e92dd32cde6" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU128&lt;/code&gt; to &lt;code&gt;NonZeroU8&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU128&lt;/code&gt; を &lt;code&gt;NonZeroU8&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="f0859484eecde175859b2793704416213e22b608" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU128&lt;/code&gt; to &lt;code&gt;NonZeroUsize&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU128&lt;/code&gt; を &lt;code&gt;NonZeroUsize&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="72fdb2a4fa84fd42a73a35812e8216884b62fceb" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU16&lt;/code&gt; to &lt;code&gt;NonZeroI16&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU16&lt;/code&gt; を &lt;code&gt;NonZeroI16&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="06fdd2383cf95915cfbafeedd94c6cf3ece1cda1" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU16&lt;/code&gt; to &lt;code&gt;NonZeroI8&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU16&lt;/code&gt; を &lt;code&gt;NonZeroI8&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="4b8ba1870526b34b3010dfda32d9e6ef25b46c3d" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU16&lt;/code&gt; to &lt;code&gt;NonZeroIsize&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU16&lt;/code&gt; を &lt;code&gt;NonZeroIsize&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="609415cf60341744050aa964021a2dbc6757bce9" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU16&lt;/code&gt; to &lt;code&gt;NonZeroU8&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU16&lt;/code&gt; を &lt;code&gt;NonZeroU8&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="1e3cfcd25580562f26787f2a4ece451df14e3410" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU32&lt;/code&gt; to &lt;code&gt;NonZeroI16&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU32&lt;/code&gt; を &lt;code&gt;NonZeroI16&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="22e09395ec650cc77cefa22bbdfa6829f42f4235" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU32&lt;/code&gt; to &lt;code&gt;NonZeroI32&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU32&lt;/code&gt; を &lt;code&gt;NonZeroI32&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="8d6c92d747eecea95deef0df11e2de577f89b584" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU32&lt;/code&gt; to &lt;code&gt;NonZeroI8&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU32&lt;/code&gt; を &lt;code&gt;NonZeroI8&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="bd6a16a046a47e51b8dbbc17c05fb83363da4079" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU32&lt;/code&gt; to &lt;code&gt;NonZeroIsize&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU32&lt;/code&gt; を &lt;code&gt;NonZeroIsize&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="681e0c5dd009397d090a42219e25007f044800b1" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU32&lt;/code&gt; to &lt;code&gt;NonZeroU16&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU32&lt;/code&gt; を &lt;code&gt;NonZeroU16&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="fbde01dde5e3f3012cf4334646a7f5ef28b672b2" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU32&lt;/code&gt; to &lt;code&gt;NonZeroU8&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU32&lt;/code&gt; を &lt;code&gt;NonZeroU8&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="ac4a8de77e7ee61e1fc27cc89dab1a66ef82bc93" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU32&lt;/code&gt; to &lt;code&gt;NonZeroUsize&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU32&lt;/code&gt; を &lt;code&gt;NonZeroUsize&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="09ce329fa4a9ee415c158ac8a1274f6e57fb2e20" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU64&lt;/code&gt; to &lt;code&gt;NonZeroI16&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU64&lt;/code&gt; を &lt;code&gt;NonZeroI16&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="1abe67a3e4364a619efb676e5daa3d020ddb2d3f" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU64&lt;/code&gt; to &lt;code&gt;NonZeroI32&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU64&lt;/code&gt; を &lt;code&gt;NonZeroI32&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="d9bf65adb8592efb46990546bc8cbe35b0283a56" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU64&lt;/code&gt; to &lt;code&gt;NonZeroI64&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU64&lt;/code&gt; を &lt;code&gt;NonZeroI64&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="5b6551a1616534f8c2d695ae7db8375e577d6398" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU64&lt;/code&gt; to &lt;code&gt;NonZeroI8&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU64&lt;/code&gt; を &lt;code&gt;NonZeroI8&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="08c2cbaf513eb994bd548c282a61f57637c77f67" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU64&lt;/code&gt; to &lt;code&gt;NonZeroIsize&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU64&lt;/code&gt; を &lt;code&gt;NonZeroIsize&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="6d6851d41e88cb2aaa40c97ac167640ba1262eb3" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU64&lt;/code&gt; to &lt;code&gt;NonZeroU16&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU64&lt;/code&gt; を &lt;code&gt;NonZeroU16&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="35ddc3e3dfd9a428705e36e86a5e0594a1b9eff7" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU64&lt;/code&gt; to &lt;code&gt;NonZeroU32&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU64&lt;/code&gt; を &lt;code&gt;NonZeroU32&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="60905ee844e93f0259575760c3d1354fd6ee0145" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU64&lt;/code&gt; to &lt;code&gt;NonZeroU8&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU64&lt;/code&gt; を &lt;code&gt;NonZeroU8&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="34b553e368c520708ccfbe33c562a7aac19b19ea" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU64&lt;/code&gt; to &lt;code&gt;NonZeroUsize&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU64&lt;/code&gt; を &lt;code&gt;NonZeroUsize&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="2bbbce1f0f87a53359eb132f6a57b8badd4665c5" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroU8&lt;/code&gt; to &lt;code&gt;NonZeroI8&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroU8&lt;/code&gt; を &lt;code&gt;NonZeroI8&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="adc18f3bf4b5cd397ebe0fa08f9b0234fe5f4691" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroUsize&lt;/code&gt; to &lt;code&gt;NonZeroI128&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroUsize&lt;/code&gt; を &lt;code&gt;NonZeroI128&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="3a8feff95241828b618a9f8f2cedee35cf34dbc2" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroUsize&lt;/code&gt; to &lt;code&gt;NonZeroI16&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroUsize&lt;/code&gt; を &lt;code&gt;NonZeroI16&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="39ef28f0274fbbc17ccd2ed7051a33a172b5845b" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroUsize&lt;/code&gt; to &lt;code&gt;NonZeroI32&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroUsize&lt;/code&gt; を &lt;code&gt;NonZeroI32&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="6bee2c6e9925f66c4b7aa5fa6a1b124e2eb59e5e" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroUsize&lt;/code&gt; to &lt;code&gt;NonZeroI64&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroUsize&lt;/code&gt; を &lt;code&gt;NonZeroI64&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="1f97a59c56e1d9e1b3d6440f468bdeaa5169d29a" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroUsize&lt;/code&gt; to &lt;code&gt;NonZeroI8&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroUsize&lt;/code&gt; を &lt;code&gt;NonZeroI8&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="915108f700cb0a82a36eec28483bf51e615c31a7" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroUsize&lt;/code&gt; to &lt;code&gt;NonZeroIsize&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroUsize&lt;/code&gt; を &lt;code&gt;NonZeroIsize&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="f9d60598f796fd4c7d2797827f8cc377d4829f91" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroUsize&lt;/code&gt; to &lt;code&gt;NonZeroU128&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroUsize&lt;/code&gt; を &lt;code&gt;NonZeroU128&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="5a888711092f4db9142baf49d1d094a1588d95bc" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroUsize&lt;/code&gt; to &lt;code&gt;NonZeroU16&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroUsize&lt;/code&gt; を &lt;code&gt;NonZeroU16&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="96596905fbde7e740d6654a8d248b25e64e80725" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroUsize&lt;/code&gt; to &lt;code&gt;NonZeroU32&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroUsize&lt;/code&gt; を &lt;code&gt;NonZeroU32&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="a42cd22a3bffa9bab2837c2ad66ee139ebc73564" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroUsize&lt;/code&gt; to &lt;code&gt;NonZeroU64&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroUsize&lt;/code&gt; を &lt;code&gt;NonZeroU64&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="94d1fb95e25a0fa6c34caf0d382246658d283ed6" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;NonZeroUsize&lt;/code&gt; to &lt;code&gt;NonZeroU8&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonZeroUsize&lt;/code&gt; を &lt;code&gt;NonZeroU8&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="2ba2351b2e57e9559c0f3714a76ac923ea85c4c4" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;i128&lt;/code&gt; to &lt;code&gt;NonZeroI128&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;i128&lt;/code&gt; を &lt;code&gt;NonZeroI128&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="2730452bbdf6d0154f196dd3387e5268fcbaae6d" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;i16&lt;/code&gt; to &lt;code&gt;NonZeroI16&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;i16&lt;/code&gt; を &lt;code&gt;NonZeroI16&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="89a676b16e76690126c8c689d7093c8a36a6dc3d" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;i32&lt;/code&gt; to &lt;code&gt;NonZeroI32&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;i32&lt;/code&gt; を &lt;code&gt;NonZeroI32&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="af2f75ee1f964bb69b3471df2010cd26d4f8b3c4" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;i64&lt;/code&gt; to &lt;code&gt;NonZeroI64&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;i64&lt;/code&gt; を &lt;code&gt;NonZeroI64&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="c93de3bc4194ab8f5cef5b860227606b9963f2e3" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;i8&lt;/code&gt; to &lt;code&gt;NonZeroI8&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;i8&lt;/code&gt; を &lt;code&gt;NonZeroI8&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="6042fa62c1123d272cfaedcf34e40785b595efa5" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;isize&lt;/code&gt; to &lt;code&gt;NonZeroIsize&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;isize&lt;/code&gt; を &lt;code&gt;NonZeroIsize&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="d44685c697bf86bf627255f318a92026c3067b36" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;u128&lt;/code&gt; to &lt;code&gt;NonZeroU128&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;u128&lt;/code&gt; を &lt;code&gt;NonZeroU128&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="83f6c21bb3f0a85bb02b720c0facffc143df545d" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;u16&lt;/code&gt; to &lt;code&gt;NonZeroU16&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;u16&lt;/code&gt; を &lt;code&gt;NonZeroU16&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="4f25fe04e2aca5c5faadb4cc9021f2c2472cc8a3" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;u32&lt;/code&gt; to &lt;code&gt;NonZeroU32&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;u32&lt;/code&gt; を &lt;code&gt;NonZeroU32&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="dbf97d063f75afad6228d1db287eb0de45a1ab04" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;u64&lt;/code&gt; to &lt;code&gt;NonZeroU64&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;u64&lt;/code&gt; を &lt;code&gt;NonZeroU64&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="89d08d408000b79c0c0f0951f917eed73ebef3a3" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;u8&lt;/code&gt; to &lt;code&gt;NonZeroU8&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;u8&lt;/code&gt; を &lt;code&gt;NonZeroU8&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="8cee9eaea9548154103d038cde6240ee1cc68830" translate="yes" xml:space="preserve">
          <source>Attempts to convert &lt;code&gt;usize&lt;/code&gt; to &lt;code&gt;NonZeroUsize&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;usize&lt;/code&gt; を &lt;code&gt;NonZeroUsize&lt;/code&gt; に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="2d9e42b5d35e242781f009f21f3c5ea257d9b8d7" translate="yes" xml:space="preserve">
          <source>Attempts to converts a &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;u8&amp;gt;&lt;/code&gt; to a &lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;u8&amp;gt;&lt;/code&gt; を&lt;a href=&quot;struct.cstring&quot;&gt; &lt;code&gt;CString&lt;/code&gt; &lt;/a&gt;に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="8d17c0e55fb5767927f25b2be2aaccc4cffbef7d" translate="yes" xml:space="preserve">
          <source>Attempts to downcast the box to a concrete type.</source>
          <target state="translated">ボックスをコンクリートタイプにダウンキャストしようとします。</target>
        </trans-unit>
        <trans-unit id="2067ade47b4e19fcd748b5622bcd5a578000fa70" translate="yes" xml:space="preserve">
          <source>Attempts to extend the allocation referenced by &lt;code&gt;ptr&lt;/code&gt; to fit &lt;code&gt;new_size&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;new_size&lt;/code&gt; に合うように、 &lt;code&gt;ptr&lt;/code&gt; によって参照される割り当てを拡張しようとします。</target>
        </trans-unit>
        <trans-unit id="1f0524b8bf45261cb2e5192b808b5a4a85102e03" translate="yes" xml:space="preserve">
          <source>Attempts to extend the allocation referenced by &lt;code&gt;ptr&lt;/code&gt; to fit &lt;code&gt;new_size&lt;/code&gt;. &lt;a href=&quot;trait.alloc#method.grow_in_place&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;new_size&lt;/code&gt; に合うように、 &lt;code&gt;ptr&lt;/code&gt; によって参照される割り当てを拡張しようとします。&lt;a href=&quot;trait.alloc#method.grow_in_place&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="610fb844291f2a525fe83689f6eb20dc7f8fe95f" translate="yes" xml:space="preserve">
          <source>Attempts to extend the memory block.</source>
          <target state="translated">メモリブロックの拡張を試みます。</target>
        </trans-unit>
        <trans-unit id="6aa5063683af7571841f72f0953d587299850850" translate="yes" xml:space="preserve">
          <source>Attempts to extend the memory block. &lt;a href=&quot;alloc/trait.allocator#method.grow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27c873a148fefc84fd64a13dc7df4ae1e7fa3719" translate="yes" xml:space="preserve">
          <source>Attempts to extend the memory block. &lt;a href=&quot;alloc/trait.allocref#method.grow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">メモリブロックを拡張しようとします。&lt;a href=&quot;alloc/trait.allocref#method.grow&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="54633b194aa39ce8f38436cb1feb8f160a116984" translate="yes" xml:space="preserve">
          <source>Attempts to extend the memory block. &lt;a href=&quot;trait.allocator#method.grow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adef0a0225d086130a40a297ad3ad900429332c4" translate="yes" xml:space="preserve">
          <source>Attempts to extend the memory block. &lt;a href=&quot;trait.allocref#method.grow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">メモリブロックを拡張しようとします。&lt;a href=&quot;trait.allocref#method.grow&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="14aa482507a26cdd1d3724ec04b0d14909b4ce76" translate="yes" xml:space="preserve">
          <source>Attempts to lock this rwlock with exclusive write access.</source>
          <target state="translated">この rwlock を排他的な書き込みアクセスでロックしようとします。</target>
        </trans-unit>
        <trans-unit id="3e149a02e4c5943a78110a9fe37e7dfdc1377a23" translate="yes" xml:space="preserve">
          <source>Attempts to open a file in read-only mode.</source>
          <target state="translated">読み取り専用モードでファイルを開こうとします。</target>
        </trans-unit>
        <trans-unit id="ce00391cd1170f4f9f1ed2dc7adb3e45ca14e46a" translate="yes" xml:space="preserve">
          <source>Attempts to return a pending value on this receiver without blocking.</source>
          <target state="translated">ブロッキングせずに、この受信機で保留中の値を返そうとする。</target>
        </trans-unit>
        <trans-unit id="88500c10aaa3c7978ed8857be5643440673d4380" translate="yes" xml:space="preserve">
          <source>Attempts to send a value on this channel without blocking.</source>
          <target state="translated">ブロックせずにこのチャンネルに値を送信しようとします。</target>
        </trans-unit>
        <trans-unit id="44fed3b4d1c2db46234c4d30a1056c0ccd124c87" translate="yes" xml:space="preserve">
          <source>Attempts to send a value on this channel, returning it back if it could not be sent.</source>
          <target state="translated">このチャネルに値を送信しようとし、送信できなかった場合はそれを返します。</target>
        </trans-unit>
        <trans-unit id="6da3e262b2372fb386666634b5d39f9d3f7bb80a" translate="yes" xml:space="preserve">
          <source>Attempts to shrink the allocation referenced by &lt;code&gt;ptr&lt;/code&gt; to fit &lt;code&gt;new_size&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;new_size&lt;/code&gt; に合うように、 &lt;code&gt;ptr&lt;/code&gt; が参照する割り当てを縮小しようとします。</target>
        </trans-unit>
        <trans-unit id="d9dd72c543bd49d83f78f0fdf1367b07147238f9" translate="yes" xml:space="preserve">
          <source>Attempts to shrink the allocation referenced by &lt;code&gt;ptr&lt;/code&gt; to fit &lt;code&gt;new_size&lt;/code&gt;. &lt;a href=&quot;trait.alloc#method.shrink_in_place&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;new_size&lt;/code&gt; に合うように、 &lt;code&gt;ptr&lt;/code&gt; が参照する割り当てを縮小しようとします。&lt;a href=&quot;trait.alloc#method.shrink_in_place&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="08f5853268ae278f691eb7a82a1231c55496e49d" translate="yes" xml:space="preserve">
          <source>Attempts to shrink the memory block.</source>
          <target state="translated">メモリブロックの縮小を試みます。</target>
        </trans-unit>
        <trans-unit id="c648c706ee8142ae651a14916b0ab8f1c626c9d5" translate="yes" xml:space="preserve">
          <source>Attempts to shrink the memory block. &lt;a href=&quot;alloc/trait.allocator#method.shrink&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b70a3bb894ec313a60c83cc036390a2df8753cb7" translate="yes" xml:space="preserve">
          <source>Attempts to shrink the memory block. &lt;a href=&quot;alloc/trait.allocref#method.shrink&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">メモリブロックを縮小しようとします。&lt;a href=&quot;alloc/trait.allocref#method.shrink&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8b1e6da2468f6f1396385de5f3580dfdb6c5c166" translate="yes" xml:space="preserve">
          <source>Attempts to shrink the memory block. &lt;a href=&quot;trait.allocator#method.shrink&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96e65f083a95479e0e7fff8e23938d5ab69fdc1f" translate="yes" xml:space="preserve">
          <source>Attempts to shrink the memory block. &lt;a href=&quot;trait.allocref#method.shrink&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">メモリブロックを縮小しようとします。&lt;a href=&quot;trait.allocref#method.shrink&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d431ee47732f5fda5d822308d953fb6c4ab546af" translate="yes" xml:space="preserve">
          <source>Attempts to sync all OS-internal metadata to disk.</source>
          <target state="translated">OS内部のすべてのメタデータをディスクに同期しようとします。</target>
        </trans-unit>
        <trans-unit id="bd1357cf9c16c8860cced8547ac6ac2266fff48b" translate="yes" xml:space="preserve">
          <source>Attempts to upgrade the &lt;code&gt;Weak&lt;/code&gt; pointer to an &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt;, delaying dropping of the inner value if successful.</source>
          <target state="translated">&lt;code&gt;Weak&lt;/code&gt; ポインタを&lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt;にアップグレードしようとします。成功した場合は、内部値の削除を遅らせます。</target>
        </trans-unit>
        <trans-unit id="e1a28bf0ca8943d3102fb17a5f930dbd42c32e93" translate="yes" xml:space="preserve">
          <source>Attempts to upgrade the &lt;code&gt;Weak&lt;/code&gt; pointer to an &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt;, extending the lifetime of the value if successful.</source>
          <target state="translated">&lt;code&gt;Weak&lt;/code&gt; ポインターを&lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt;にアップグレードし、成功した場合は値の存続期間を延長しようとします。</target>
        </trans-unit>
        <trans-unit id="3f7dd7ca12e8b115613fa365887978f9fb146c24" translate="yes" xml:space="preserve">
          <source>Attempts to upgrade the &lt;code&gt;Weak&lt;/code&gt; pointer to an &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt;, delaying dropping of the inner value if successful.</source>
          <target state="translated">&lt;code&gt;Weak&lt;/code&gt; ポインタを&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt;にアップグレードしようとし、成功した場合は内部値の削除を遅らせます。</target>
        </trans-unit>
        <trans-unit id="c10f653d6058260dd8df6597f6fc625f0e90a7a2" translate="yes" xml:space="preserve">
          <source>Attempts to upgrade the &lt;code&gt;Weak&lt;/code&gt; pointer to an &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt;, extending the lifetime of the value if successful.</source>
          <target state="translated">&lt;code&gt;Weak&lt;/code&gt; ポインターを&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt;にアップグレードし、成功した場合は値の有効期間を延長しようとします。</target>
        </trans-unit>
        <trans-unit id="4ed9981b4c97d4946f7cc66f3d69625251a285c0" translate="yes" xml:space="preserve">
          <source>Attempts to wait for a value on this receiver, returning an error if the corresponding channel has hung up, or if &lt;code&gt;deadline&lt;/code&gt; is reached.</source>
          <target state="translated">このレシーバーの値を待機しようとし、対応するチャネルがハングアップした場合、または &lt;code&gt;deadline&lt;/code&gt; に達した場合にエラーを返します。</target>
        </trans-unit>
        <trans-unit id="eea7708f089d17a724b4fe150c8a5b22b7b7cd15" translate="yes" xml:space="preserve">
          <source>Attempts to wait for a value on this receiver, returning an error if the corresponding channel has hung up, or if it waits more than &lt;code&gt;timeout&lt;/code&gt;.</source>
          <target state="translated">このレシーバーの値を待機しようとし、対応するチャネルがハングアップした場合、または &lt;code&gt;timeout&lt;/code&gt; を超えて待機した場合はエラーを返します。</target>
        </trans-unit>
        <trans-unit id="c5624ed9b3f4c32e9214ed479d11bee18fe54f2a" translate="yes" xml:space="preserve">
          <source>Attempts to wait for a value on this receiver, returning an error if the corresponding channel has hung up.</source>
          <target state="translated">この受信機で値の待ち受けを試み、対応するチャンネルがハングアップした場合はエラーを返します。</target>
        </trans-unit>
        <trans-unit id="66681ba198baa628940b6e0e8d1d21d555ae1a8d" translate="yes" xml:space="preserve">
          <source>Attempts to write an entire buffer into this writer.</source>
          <target state="translated">バッファ全体をこのライタに書き込もうとします。</target>
        </trans-unit>
        <trans-unit id="50c44c33216c75388385c7158cbb2db3b18cd276" translate="yes" xml:space="preserve">
          <source>Attempts to write an entire buffer into this writer. &lt;a href=&quot;../../../io/trait.write#method.write_all&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">バッファ全体をこのライターに書き込もうとします。&lt;a href=&quot;../../../io/trait.write#method.write_all&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cb65a661c9940f60efcdfd42e570120d00134516" translate="yes" xml:space="preserve">
          <source>Attempts to write an entire buffer into this writer. &lt;a href=&quot;../io/trait.write#method.write_all&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">バッファ全体をこのライターに書き込もうとします。&lt;a href=&quot;../io/trait.write#method.write_all&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7537ca8f100350d628ddd2455b7d2b9261e91786" translate="yes" xml:space="preserve">
          <source>Attempts to write an entire buffer into this writer. &lt;a href=&quot;io/trait.write#method.write_all&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">バッファ全体をこのライターに書き込もうとします。&lt;a href=&quot;io/trait.write#method.write_all&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c4a079954569cfca76bb04671c6eef0de6f2845b" translate="yes" xml:space="preserve">
          <source>Attempts to write an entire buffer into this writer. &lt;a href=&quot;trait.write#method.write_all&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">バッファ全体をこのライターに書き込もうとします。&lt;a href=&quot;trait.write#method.write_all&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3a4550331cd75411aa797d05589ea44d59948931" translate="yes" xml:space="preserve">
          <source>Attempts to write an entire buffer starting from a given offset.</source>
          <target state="translated">指定したオフセットから始まるバッファ全体の書き込みを試みます。</target>
        </trans-unit>
        <trans-unit id="bd08d9b38e39a23845ecac7733a7135e68b5844b" translate="yes" xml:space="preserve">
          <source>Attempts to write an entire buffer starting from a given offset. &lt;a href=&quot;../os/unix/fs/trait.fileext#method.write_all_at&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">指定されたオフセットから開始してバッファー全体を書き込もうとします。&lt;a href=&quot;../os/unix/fs/trait.fileext#method.write_all_at&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3cd154a661d834b07894c77674ab8ed918e6d062" translate="yes" xml:space="preserve">
          <source>Attempts to write multiple buffers into this writer.</source>
          <target state="translated">このライターに複数のバッファを書き込もうとする。</target>
        </trans-unit>
        <trans-unit id="fc422df0d6aeefc153e9d11191c7acdab0fee066" translate="yes" xml:space="preserve">
          <source>Attempts to write multiple buffers into this writer. &lt;a href=&quot;../../../io/trait.write#method.write_all_vectored&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">このライターに複数のバッファーを書き込もうとします。&lt;a href=&quot;../../../io/trait.write#method.write_all_vectored&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ef049b1e411811d76553b0e75329cbd0d79e8485" translate="yes" xml:space="preserve">
          <source>Attempts to write multiple buffers into this writer. &lt;a href=&quot;../io/trait.write#method.write_all_vectored&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">このライターに複数のバッファーを書き込もうとします。&lt;a href=&quot;../io/trait.write#method.write_all_vectored&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="59af638438e522a4fe5eaeba810e068e6c90b8b0" translate="yes" xml:space="preserve">
          <source>Attempts to write multiple buffers into this writer. &lt;a href=&quot;io/trait.write#method.write_all_vectored&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">このライターに複数のバッファーを書き込もうとします。&lt;a href=&quot;io/trait.write#method.write_all_vectored&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4d6a58aa82ce87e3367d27cafec071fe08afba77" translate="yes" xml:space="preserve">
          <source>Attempts to write multiple buffers into this writer. &lt;a href=&quot;trait.write#method.write_all_vectored&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">このライターに複数のバッファーを書き込もうとします。&lt;a href=&quot;trait.write#method.write_all_vectored&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="63578c033690b22f88448dc9020fc65119c91cf5" translate="yes" xml:space="preserve">
          <source>Attribute contains same meta item more than once.</source>
          <target state="translated">属性に同じメタ項目が複数回含まれています。</target>
        </trans-unit>
        <trans-unit id="645ef54c5f28a9cf578382e9466764d3ebe4899c" translate="yes" xml:space="preserve">
          <source>Attribute macros</source>
          <target state="translated">属性マクロ</target>
        </trans-unit>
        <trans-unit id="1a7e3b192d591463acc213e348e2d3be95158e41" translate="yes" xml:space="preserve">
          <source>Attribute macros are defined by a &lt;a href=&quot;visibility-and-privacy&quot;&gt;public&lt;/a&gt;&lt;a href=&quot;items/functions&quot;&gt;function&lt;/a&gt; with the &lt;code&gt;proc_macro_attribute&lt;/code&gt;&lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; that has a signature of &lt;code&gt;(TokenStream, TokenStream) -&amp;gt; TokenStream&lt;/code&gt;. The first &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; is the delimited token tree following the attribute's name, not including the outer delimiters. If the attribute is written as a bare attribute name, the attribute &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; is empty. The second &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; is the rest of the &lt;a href=&quot;items&quot;&gt;item&lt;/a&gt; including other &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt; on the &lt;a href=&quot;items&quot;&gt;item&lt;/a&gt;. The returned &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; replaces the &lt;a href=&quot;items&quot;&gt;item&lt;/a&gt; with an arbitrary number of &lt;a href=&quot;items&quot;&gt;items&lt;/a&gt;.</source>
          <target state="translated">属性マクロは以下のように定義されている&lt;a href=&quot;visibility-and-privacy&quot;&gt;公共の&lt;/a&gt;&lt;a href=&quot;items/functions&quot;&gt;機能&lt;/a&gt;を &lt;code&gt;proc_macro_attribute&lt;/code&gt; の&lt;a href=&quot;attributes&quot;&gt;属性&lt;/a&gt;の署名がある &lt;code&gt;(TokenStream, TokenStream) -&amp;gt; TokenStream&lt;/code&gt; 。最初の&lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt;は、属性の名前に続く区切られたトークンツリーであり、外側の区切り文字は含まれません。属性が裸の属性名として記述されている場合、属性&lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt;は空です。二&lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; は&lt;/a&gt;、残りのある&lt;a href=&quot;items&quot;&gt;項目&lt;/a&gt;他を含む&lt;a href=&quot;attributes&quot;&gt;属性&lt;/a&gt;の&lt;a href=&quot;items&quot;&gt;項目&lt;/a&gt;。返された&lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt;は、&lt;a href=&quot;items&quot;&gt;アイテム&lt;/a&gt;を任意の数の&lt;a href=&quot;items&quot;&gt;アイテム&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="859156ebbcd8a20df68582e72c9cb8ebb2f8d6d9" translate="yes" xml:space="preserve">
          <source>Attribute macros are defined by a &lt;a href=&quot;visibility-and-privacy&quot;&gt;public&lt;/a&gt;&lt;a href=&quot;items/functions&quot;&gt;function&lt;/a&gt; with the &lt;code&gt;proc_macro_attribute&lt;/code&gt;&lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; that has a signature of &lt;code&gt;(TokenStream, TokenStream) -&amp;gt; TokenStream&lt;/code&gt;. The first &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; is the delimited token tree following the attribute's name, not including the outer delimiters. If the attribute is written as a bare attribute name, the attribute &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; is empty. The second &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; is the rest of the &lt;a href=&quot;items&quot;&gt;item&lt;/a&gt; including other &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt; on the &lt;a href=&quot;items&quot;&gt;item&lt;/a&gt;. The returned &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; replaces the &lt;a href=&quot;items&quot;&gt;item&lt;/a&gt; with an arbitrary number of &lt;a href=&quot;items&quot;&gt;items&lt;/a&gt;. These macros cannot expand to syntax that defines new &lt;code&gt;macro_rules&lt;/code&gt; style macros.</source>
          <target state="translated">属性マクロは以下のように定義されている&lt;a href=&quot;visibility-and-privacy&quot;&gt;公共の&lt;/a&gt;&lt;a href=&quot;items/functions&quot;&gt;機能&lt;/a&gt;を &lt;code&gt;proc_macro_attribute&lt;/code&gt; の&lt;a href=&quot;attributes&quot;&gt;属性&lt;/a&gt;の署名がある &lt;code&gt;(TokenStream, TokenStream) -&amp;gt; TokenStream&lt;/code&gt; 。最初の&lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt;は、属性名に続く区切りのトークンツリーです。外側の区切り文字は含まれません。属性がベア属性名として記述されている場合、属性&lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt;は空です。 2番目の&lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt;は、&lt;a href=&quot;items&quot;&gt;アイテムの&lt;/a&gt;他の&lt;a href=&quot;attributes&quot;&gt;属性&lt;/a&gt;を含む残りの&lt;a href=&quot;items&quot;&gt;アイテム&lt;/a&gt;です。返された&lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt;は、&lt;a href=&quot;items&quot;&gt;アイテム&lt;/a&gt;を任意の数に置き換えます&lt;a href=&quot;items&quot;&gt;アイテム&lt;/a&gt;。これらのマクロは、新しい &lt;code&gt;macro_rules&lt;/code&gt; スタイルのマクロを定義する構文に拡張できません。</target>
        </trans-unit>
        <trans-unit id="e9cdb4472ce392123fa434d8e8286aab92c7c80b" translate="yes" xml:space="preserve">
          <source>Attribute-like macros</source>
          <target state="translated">属性に似たマクロ</target>
        </trans-unit>
        <trans-unit id="59290a10bc07737a4a9b4b98cbfa7a104e8da35e" translate="yes" xml:space="preserve">
          <source>Attribute-like macros are similar to custom derive macros, but instead of generating code for the &lt;code&gt;derive&lt;/code&gt; attribute, they allow you to create new attributes. They&amp;rsquo;re also more flexible: &lt;code&gt;derive&lt;/code&gt; only works for structs and enums; attributes can be applied to other items as well, such as functions. Here&amp;rsquo;s an example of using an attribute-like macro: say you have an attribute named &lt;code&gt;route&lt;/code&gt; that annotates functions when using a web application framework:</source>
          <target state="translated">属性のようなマクロは、カスタムの派生マクロに似ていますが、 &lt;code&gt;derive&lt;/code&gt; 属性のコードを生成する代わりに、新しい属性を作成できます。彼らはまた、より柔軟だ： &lt;code&gt;derive&lt;/code&gt; だけ構造体や列挙型のために動作します。属性は、関数などの他のアイテムにも適用できます。これは、属性のようなマクロの使用例です。Webアプリケーションフレームワークを使用するときに関数に注釈を付ける &lt;code&gt;route&lt;/code&gt; という名前の属性があるとします。</target>
        </trans-unit>
        <trans-unit id="ec087a512ee5c8fbe6233f1c1cc119ebd6524585" translate="yes" xml:space="preserve">
          <source>Attribute-like macros that define custom attributes usable on any item</source>
          <target state="translated">任意のアイテムで使用可能なカスタム属性を定義する属性ライクなマクロ</target>
        </trans-unit>
        <trans-unit id="a6652617f2c799eb11ee727b16c5646c48af6905" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Attributes</target>
        </trans-unit>
        <trans-unit id="873679be0cfb954acbd8355a7b353607aec111e8" translate="yes" xml:space="preserve">
          <source>Attributes can be classified into the following kinds:</source>
          <target state="translated">属性は以下の種類に分類することができます。</target>
        </trans-unit>
        <trans-unit id="f75246581fb116635159a5829418eadb80ff6d3d" translate="yes" xml:space="preserve">
          <source>Attributes may be applied to many things in the language:</source>
          <target state="translated">属性は、言語の多くのものに適用される可能性があります。</target>
        </trans-unit>
        <trans-unit id="54528912cd579e0bc00be1a8a68e351287624bb1" translate="yes" xml:space="preserve">
          <source>Attributes on Implementations</source>
          <target state="translated">実装に関する属性</target>
        </trans-unit>
        <trans-unit id="37b3e9d71f1e2b7a16d851acde890909a1eeac05" translate="yes" xml:space="preserve">
          <source>Attributes on Modules</source>
          <target state="translated">モジュールの属性</target>
        </trans-unit>
        <trans-unit id="bd970fc906dcf4e6b3d5342f7f8f7b6b3fc07d29" translate="yes" xml:space="preserve">
          <source>Attributes on Statements</source>
          <target state="translated">ステートメントの属性</target>
        </trans-unit>
        <trans-unit id="002821d69ecf6475cc851545267b8d3000e1ad75" translate="yes" xml:space="preserve">
          <source>Attributes on block expressions</source>
          <target state="translated">ブロック式の属性</target>
        </trans-unit>
        <trans-unit id="9c665fd3a622574987a78d02ed515c34731bae9e" translate="yes" xml:space="preserve">
          <source>Attributes on closure parameters</source>
          <target state="translated">クロージャパラメータの属性</target>
        </trans-unit>
        <trans-unit id="9b9724999b0840379dc53e44bc7f9fc3b9f933c5" translate="yes" xml:space="preserve">
          <source>Attributes on closure parameters follow the same rules and restrictions as &lt;a href=&quot;../items/functions#attributes-on-function-parameters&quot;&gt;regular function parameters&lt;/a&gt;.</source>
          <target state="translated">クロージャパラメーターの属性は、&lt;a href=&quot;../items/functions#attributes-on-function-parameters&quot;&gt;通常の関数パラメーター&lt;/a&gt;と同じ規則と制限に従います。</target>
        </trans-unit>
        <trans-unit id="ceeb23e9fab4cfc5da27d608e1b53f610954cf73" translate="yes" xml:space="preserve">
          <source>Attributes on extern blocks</source>
          <target state="translated">外部ブロックの属性</target>
        </trans-unit>
        <trans-unit id="2b100159215337704a6b1e09760f5eccf7526a5d" translate="yes" xml:space="preserve">
          <source>Attributes on extern function parameters follow the same rules and restrictions as &lt;a href=&quot;functions#attributes-on-function-parameters&quot;&gt;regular function parameters&lt;/a&gt;.</source>
          <target state="translated">extern関数パラメーターの属性は、&lt;a href=&quot;functions#attributes-on-function-parameters&quot;&gt;通常の関数パラメーター&lt;/a&gt;と同じ規則と制限に従います。</target>
        </trans-unit>
        <trans-unit id="59c13f89c0293ca7012e37e58c92591846eac3f7" translate="yes" xml:space="preserve">
          <source>Attributes on function parameters</source>
          <target state="translated">関数パラメータの属性</target>
        </trans-unit>
        <trans-unit id="ed27ab14062c4e9a4e3408735f20ce008b94ed1f" translate="yes" xml:space="preserve">
          <source>Attributes on function pointer parameters</source>
          <target state="translated">関数ポインタパラメータの属性</target>
        </trans-unit>
        <trans-unit id="d19964d112392f9f4c6dafbc3caa5ef3b3d5eb10" translate="yes" xml:space="preserve">
          <source>Attributes on function pointer parameters follow the same rules and restrictions as &lt;a href=&quot;../items/functions#attributes-on-function-parameters&quot;&gt;regular function parameters&lt;/a&gt;.</source>
          <target state="translated">関数ポインタパラメータの属性は、&lt;a href=&quot;../items/functions#attributes-on-function-parameters&quot;&gt;通常の関数パラメータ&lt;/a&gt;と同じ規則と制限に従います。</target>
        </trans-unit>
        <trans-unit id="3cccaf98e2daf69778514e782644b524ef8bcdb7" translate="yes" xml:space="preserve">
          <source>Attributes on functions</source>
          <target state="translated">関数の属性</target>
        </trans-unit>
        <trans-unit id="05e9060a13a0e0d138adc8680df67a664480dcc8" translate="yes" xml:space="preserve">
          <source>Attributes on match arms</source>
          <target state="translated">マッチ武器の属性</target>
        </trans-unit>
        <trans-unit id="2af6ac2f621f1343b06367e7a182dd005ff55bf7" translate="yes" xml:space="preserve">
          <source>Attributes on method parameters</source>
          <target state="translated">メソッドパラメータの属性</target>
        </trans-unit>
        <trans-unit id="09d4e80c9597ea7a33de2f4472d2c8f5b6ac76e0" translate="yes" xml:space="preserve">
          <source>Attributes on method parameters follow the same rules and restrictions as &lt;a href=&quot;functions#attributes-on-function-parameters&quot;&gt;regular function parameters&lt;/a&gt;.</source>
          <target state="translated">メソッドパラメータの属性は、&lt;a href=&quot;functions#attributes-on-function-parameters&quot;&gt;通常の関数パラメータ&lt;/a&gt;と同じ規則と制限に従います。</target>
        </trans-unit>
        <trans-unit id="4692270821bce03e7c9c56f2250b4d84c0ed4e73" translate="yes" xml:space="preserve">
          <source>Augments &lt;code&gt;AllocErr&lt;/code&gt; with a CapacityOverflow variant.</source>
          <target state="translated">CapacityOverflowバリアントでAllocErrを &lt;code&gt;AllocErr&lt;/code&gt; します。</target>
        </trans-unit>
        <trans-unit id="18a0388aaf485c373d9fa2601ae76a1e2a8efdf4" translate="yes" xml:space="preserve">
          <source>Austin Group Bugzilla</source>
          <target state="translated">オースティングループのバグジラ</target>
        </trans-unit>
        <trans-unit id="e84cdcfde23e335b70dccbea7484975e25932774" translate="yes" xml:space="preserve">
          <source>Auto Trait Implementations</source>
          <target state="translated">自動形質の実装</target>
        </trans-unit>
        <trans-unit id="3210ce5fd6c71ac203dc3858abcda035931c425a" translate="yes" xml:space="preserve">
          <source>Auto implementors</source>
          <target state="translated">オートインプリメンタ</target>
        </trans-unit>
        <trans-unit id="883a358e80c549bb53d94b1393e3b00efd025f86" translate="yes" xml:space="preserve">
          <source>Auto traits</source>
          <target state="translated">自動形質</target>
        </trans-unit>
        <trans-unit id="907a84f140f8fccdc36e6967fab33354d93f68e0" translate="yes" xml:space="preserve">
          <source>Auto traits can also have negative implementations, shown as &lt;code&gt;impl !AutoTrait for T&lt;/code&gt; in the standard library documentation, that override the automatic implementations. For example &lt;code&gt;*mut T&lt;/code&gt; has a negative implementation of &lt;code&gt;Send&lt;/code&gt;, and so &lt;code&gt;*mut T&lt;/code&gt; is not &lt;code&gt;Send&lt;/code&gt;, even if &lt;code&gt;T&lt;/code&gt; is. There is currently no stable way to specify additional negative implementations; they exist only in the standard library.</source>
          <target state="translated">自動トレイトには、標準のライブラリドキュメントで &lt;code&gt;impl !AutoTrait for T&lt;/code&gt; として示されている、負の実装もあり、自動実装をオーバーライドします。たとえば、 &lt;code&gt;*mut T&lt;/code&gt; には &lt;code&gt;Send&lt;/code&gt; の否定的な実装があるため、 &lt;code&gt;*mut T&lt;/code&gt; はたとえ &lt;code&gt;T&lt;/code&gt; であっても &lt;code&gt;Send&lt;/code&gt; ではありません。現在、追加の否定的な実装を指定する安定した方法はありません。それらは標準ライブラリにのみ存在します。</target>
        </trans-unit>
        <trans-unit id="eed6125b479d147f9973b57bfcd959c6cdf11e7c" translate="yes" xml:space="preserve">
          <source>Auto traits cannot have methods or associated items. For more information see the &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md&quot;&gt;opt-in builtin traits RFC&lt;/a&gt;.</source>
          <target state="translated">自動特性には、メソッドまたは関連アイテムを含めることはできません。詳細については、&lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md&quot;&gt;オプトインの組み込み特性RFCを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="589d3531f6899aa76d5a037b26ecc86cf31af6da" translate="yes" xml:space="preserve">
          <source>Auto traits may be added as an additional bound to any &lt;a href=&quot;types/trait-object&quot;&gt;trait object&lt;/a&gt;, even though normally only one trait is allowed. For instance, &lt;code&gt;Box&amp;lt;dyn Debug + Send + UnwindSafe&amp;gt;&lt;/code&gt; is a valid type.</source>
          <target state="translated">自動トレイトは、通常は1つのトレイトしか許可されていない場合でも、任意の&lt;a href=&quot;types/trait-object&quot;&gt;トレイトオブジェクト&lt;/a&gt;への追加のバインドとして追加できます。たとえば、 &lt;code&gt;Box&amp;lt;dyn Debug + Send + UnwindSafe&amp;gt;&lt;/code&gt; は有効なタイプです。</target>
        </trans-unit>
        <trans-unit id="7ab019d8f27eff675f0469b46eedbbd5bc764f0c" translate="yes" xml:space="preserve">
          <source>Auto traits such as Send and Sync are an exception to this rule: It's possible to have bounds of one non-builtin trait, plus any number of auto traits. For example, the following compiles correctly:</source>
          <target state="translated">Send や Sync などの自動形質はこのルールの例外です:ビルトインされていない形質の範囲を 1 つと、任意の数の自動形質を持つことができます。例えば、以下は正しくコンパイルされています。</target>
        </trans-unit>
        <trans-unit id="291824a57cec52e3b37ba600a0c8891145191849" translate="yes" xml:space="preserve">
          <source>Auto-&lt;code&gt;deref&lt;/code&gt; is undesirable; for example, distinguishing between methods on a smart pointer itself and the pointer's referent</source>
          <target state="translated">自動 &lt;code&gt;deref&lt;/code&gt; は望ましくありません。たとえば、スマートポインター自体のメソッドとポインターのリファレントを区別する</target>
        </trans-unit>
        <trans-unit id="07a06ac20697a76a3d6c77f425115fda11438cdd" translate="yes" xml:space="preserve">
          <source>Automatic Formatting with &lt;code id=&quot;automatic-formatting-with-rustfmt&quot;&gt;rustfmt&lt;/code&gt;</source>
          <target state="translated">&lt;code id=&quot;automatic-formatting-with-rustfmt&quot;&gt;rustfmt&lt;/code&gt; による自動フォーマット</target>
        </trans-unit>
        <trans-unit id="fd22060c7b367de18d29110de1ffaa7a8381ad30" translate="yes" xml:space="preserve">
          <source>Available features</source>
          <target state="translated">利用可能な機能</target>
        </trans-unit>
        <trans-unit id="67ac2af5490a5a8399786f2d57a2cb9f4e9a1f32" translate="yes" xml:space="preserve">
          <source>Await expressions</source>
          <target state="translated">表情を待つ</target>
        </trans-unit>
        <trans-unit id="e627821b85e700b6a817bfb93d0fa75ca6938994" translate="yes" xml:space="preserve">
          <source>Await expressions are legal only within an &lt;a href=&quot;block-expr#async-context&quot;&gt;async context&lt;/a&gt;, like an &lt;a href=&quot;../items/functions#async-functions&quot;&gt;&lt;code&gt;async fn&lt;/code&gt;&lt;/a&gt; or an &lt;a href=&quot;block-expr#async-blocks&quot;&gt;&lt;code&gt;async&lt;/code&gt; block&lt;/a&gt;. They operate on a &lt;a href=&quot;../../std/future/trait.future&quot;&gt;future&lt;/a&gt;. Their effect is to suspend the current computation until the given future is ready to produce a value.</source>
          <target state="translated">待機式は、&lt;a href=&quot;../items/functions#async-functions&quot;&gt; &lt;code&gt;async fn&lt;/code&gt; &lt;/a&gt;や&lt;a href=&quot;block-expr#async-blocks&quot;&gt; &lt;code&gt;async&lt;/code&gt; &lt;/a&gt;ブロックなどの&lt;a href=&quot;block-expr#async-context&quot;&gt;非同期コンテキスト&lt;/a&gt;内でのみ有効です。彼らは&lt;a href=&quot;../../std/future/trait.future&quot;&gt;未来に&lt;/a&gt;作用します。それらの効果は、与えられた未来が値を生成する準備ができるまで、現在の計算を一時停止することです。</target>
        </trans-unit>
        <trans-unit id="25bea30bca4696d831be0e14c1144f604b2efac9" translate="yes" xml:space="preserve">
          <source>Awesome! We now have a simple web server in approximately 40 lines of Rust code that responds to one request with a page of content and responds to all other requests with a 404 response.</source>
          <target state="translated">凄いですね。私たちは今、約40行のRustコードでシンプルなWebサーバーを構築しています。これは、1つのリクエストにはコンテンツのページで応答し、他のすべてのリクエストには404レスポンスで応答します。</target>
        </trans-unit>
        <trans-unit id="799c6a1aafdeb5752f0a6da17b30526204336545" translate="yes" xml:space="preserve">
          <source>Awesome! With one tiny final tweak, we will finish the guessing game. Recall that the program is still printing the secret number. That worked well for testing, but it ruins the game. Let&amp;rsquo;s delete the &lt;code&gt;println!&lt;/code&gt; that outputs the secret number. Listing 2-6 shows the final code.</source>
          <target state="translated">驚くばかり！最後の微調整を1つ加えて、推測ゲームを終了します。プログラムがまだ秘密の番号を出力していることを思い出してください。それはテストにはうまくいきましたが、ゲームを台無しにしました。 &lt;code&gt;println!&lt;/code&gt; 削除しましょう！秘密番号を出力します。リスト2-6は最終的なコードを示しています。</target>
        </trans-unit>
        <trans-unit id="358de401329e3394893b21243300f3a3bf6b4d17" translate="yes" xml:space="preserve">
          <source>B-Trees represent a fundamental compromise between cache-efficiency and actually minimizing the amount of work performed in a search. In theory, a binary search tree (BST) is the optimal choice for a sorted map, as a perfectly balanced BST performs the theoretical minimum amount of comparisons necessary to find an element (log&lt;sub&gt;2&lt;/sub&gt;n). However, in practice the way this is done is &lt;em&gt;very&lt;/em&gt; inefficient for modern computer architectures. In particular, every element is stored in its own individually heap-allocated node. This means that every single insertion triggers a heap-allocation, and every single comparison should be a cache-miss. Since these are both notably expensive things to do in practice, we are forced to at very least reconsider the BST strategy.</source>
          <target state="translated">Bツリーは、キャッシュ効率と検索で実行される作業量を実際に最小化することの間の基本的な妥協点を表しています。理論的には、完全にバランスの取れたBSTが要素（log &lt;sub&gt;2&lt;/sub&gt; n）を見つけるために必要な理論的な最小量の比較を実行するため、ソートされたマップにはバイナリサーチツリー（BST）が最適です。ただし、実際には、これが行われる方法は、現代のコンピュータアーキテクチャでは&lt;em&gt;非常に&lt;/em&gt;非効率的です。特に、すべての要素は、個別にヒープに割り当てられた独自のノードに格納されます。これは、1回の挿入ごとにヒープ割り当てがトリガーされ、すべての比較でキャッシュミスが発生することを意味します。これらはどちらも実際に行うには特に費用のかかるものであるため、少なくともBST戦略を再考する必要があります。</target>
        </trans-unit>
        <trans-unit id="4ce046eb7e16ef9995c1ff852988df751464fa48" translate="yes" xml:space="preserve">
          <source>BIN_DIGIT : [&lt;code&gt;0&lt;/code&gt;-&lt;code&gt;1&lt;/code&gt;]</source>
          <target state="translated">BIN_DIGIT：[ &lt;code&gt;0&lt;/code&gt; - &lt;code&gt;1&lt;/code&gt; ]</target>
        </trans-unit>
        <trans-unit id="93c309eceddcd432100b37d2f21aed97ad5516a1" translate="yes" xml:space="preserve">
          <source>BIN_LITERAL :</source>
          <target state="translated">BIN_LITERAL .</target>
        </trans-unit>
        <trans-unit id="1ce23e42f8a0fadda89f03bff4138edc76257e9f" translate="yes" xml:space="preserve">
          <source>BLOCK_COMMENT</source>
          <target state="translated">BLOCK_COMMENT</target>
        </trans-unit>
        <trans-unit id="54d41dd6d7f607cbfdbd93df26df009dd384ea37" translate="yes" xml:space="preserve">
          <source>BLOCK_COMMENT :</source>
          <target state="translated">BLOCK_COMMENT .</target>
        </trans-unit>
        <trans-unit id="46a2a0792f35fba20ff9af816bd7d67867d91ee5" translate="yes" xml:space="preserve">
          <source>BOOLEAN_LITERAL</source>
          <target state="translated">BOOLEAN_LITERAL</target>
        </trans-unit>
        <trans-unit id="984b539364047c18d12aa2a5107f4ca7034f1745" translate="yes" xml:space="preserve">
          <source>BOOLEAN_LITERAL :</source>
          <target state="translated">BOOLEAN_LITERAL .</target>
        </trans-unit>
        <trans-unit id="25ed99c15ff33b077d8ef4f89cfb12043f799e5c" translate="yes" xml:space="preserve">
          <source>BTreeMap</source>
          <target state="translated">BTreeMap</target>
        </trans-unit>
        <trans-unit id="14b812dd3cb5eae3767a2df53640bea358a44ec3" translate="yes" xml:space="preserve">
          <source>BTreeMap::append</source>
          <target state="translated">BTreeMap::append</target>
        </trans-unit>
        <trans-unit id="4439b2dd76bd007a7ee702af3eca0f027a45eb09" translate="yes" xml:space="preserve">
          <source>BTreeMap::borrow</source>
          <target state="translated">BTreeMap::borrow</target>
        </trans-unit>
        <trans-unit id="a411a7ebcb50db356ed987a9d5f1ea3e6fb40efd" translate="yes" xml:space="preserve">
          <source>BTreeMap::borrow_mut</source>
          <target state="translated">BTreeMap::borrow_mut</target>
        </trans-unit>
        <trans-unit id="0e1837335635833d079465e2a07ece32097ef9ee" translate="yes" xml:space="preserve">
          <source>BTreeMap::clamp</source>
          <target state="translated">BTreeMap::clamp</target>
        </trans-unit>
        <trans-unit id="a5095900a69512f07d67a4318ed72ed754b7ec9a" translate="yes" xml:space="preserve">
          <source>BTreeMap::clear</source>
          <target state="translated">BTreeMap::clear</target>
        </trans-unit>
        <trans-unit id="d9dc0be9a162cd4c9a8d0d87ef461b431cc2996f" translate="yes" xml:space="preserve">
          <source>BTreeMap::clone</source>
          <target state="translated">BTreeMap::clone</target>
        </trans-unit>
        <trans-unit id="b18aa414095cedffcf379ff71fa52f0f3e5a2e30" translate="yes" xml:space="preserve">
          <source>BTreeMap::clone_from</source>
          <target state="translated">BTreeMap::clone_from</target>
        </trans-unit>
        <trans-unit id="94cc1d51e045cecb444cb20cb07a89d16ef1abae" translate="yes" xml:space="preserve">
          <source>BTreeMap::clone_into</source>
          <target state="translated">BTreeMap::clone_into</target>
        </trans-unit>
        <trans-unit id="7fc5895f7f2221a66d3e8ff613cbb9e54a398512" translate="yes" xml:space="preserve">
          <source>BTreeMap::cmp</source>
          <target state="translated">BTreeMap::cmp</target>
        </trans-unit>
        <trans-unit id="10f80450d5f9791627fc6f70e8eea8d607e5abc1" translate="yes" xml:space="preserve">
          <source>BTreeMap::contains_key</source>
          <target state="translated">BTreeMap::contains_key</target>
        </trans-unit>
        <trans-unit id="237ebd61fd35b922ed92337aaeb092096989c551" translate="yes" xml:space="preserve">
          <source>BTreeMap::default</source>
          <target state="translated">BTreeMap::default</target>
        </trans-unit>
        <trans-unit id="67360895fa8faeb3288ff2a48f56ac5fb63f6cfa" translate="yes" xml:space="preserve">
          <source>BTreeMap::drop</source>
          <target state="translated">BTreeMap::drop</target>
        </trans-unit>
        <trans-unit id="e35986d9fdbf3de52b6c707270d8af046337a4b7" translate="yes" xml:space="preserve">
          <source>BTreeMap::entry</source>
          <target state="translated">BTreeMap::entry</target>
        </trans-unit>
        <trans-unit id="1fd856b6f3486469ed5b9716d4c0ef16fd26570a" translate="yes" xml:space="preserve">
          <source>BTreeMap::eq</source>
          <target state="translated">BTreeMap::eq</target>
        </trans-unit>
        <trans-unit id="2eb6b59d7803ce34a4aebcb1a5cebd29ebb2ace1" translate="yes" xml:space="preserve">
          <source>BTreeMap::extend</source>
          <target state="translated">BTreeMap::extend</target>
        </trans-unit>
        <trans-unit id="14a4894c2a33cba6f17b28aab882b15d8fa0507e" translate="yes" xml:space="preserve">
          <source>BTreeMap::fmt</source>
          <target state="translated">BTreeMap::fmt</target>
        </trans-unit>
        <trans-unit id="f8ff830626694a395da9bcdf07413636ef382d2a" translate="yes" xml:space="preserve">
          <source>BTreeMap::from</source>
          <target state="translated">BTreeMap::from</target>
        </trans-unit>
        <trans-unit id="40d5df351e6a78b82beed9049802e2600890cdef" translate="yes" xml:space="preserve">
          <source>BTreeMap::from_iter</source>
          <target state="translated">BTreeMap::from_iter</target>
        </trans-unit>
        <trans-unit id="42bc9380f48558951feaee861f324b3e97cc339c" translate="yes" xml:space="preserve">
          <source>BTreeMap::ge</source>
          <target state="translated">BTreeMap::ge</target>
        </trans-unit>
        <trans-unit id="fdc4bec6666f5d3bd604897331fbae31d76e02c5" translate="yes" xml:space="preserve">
          <source>BTreeMap::get</source>
          <target state="translated">BTreeMap::get</target>
        </trans-unit>
        <trans-unit id="10123fe58d4d51981db653bb17bb2c5bd1739f48" translate="yes" xml:space="preserve">
          <source>BTreeMap::get_key_value</source>
          <target state="translated">BTreeMap::get_key_value</target>
        </trans-unit>
        <trans-unit id="77ed844b0571d2308549c11d94f75218d5fc647d" translate="yes" xml:space="preserve">
          <source>BTreeMap::get_mut</source>
          <target state="translated">BTreeMap::get_mut</target>
        </trans-unit>
        <trans-unit id="5aeca596bd768adcad438b3384e1977cf6475276" translate="yes" xml:space="preserve">
          <source>BTreeMap::gt</source>
          <target state="translated">BTreeMap::gt</target>
        </trans-unit>
        <trans-unit id="aef92c85a8fd215fe067e91d2cc54253d395041e" translate="yes" xml:space="preserve">
          <source>BTreeMap::hash</source>
          <target state="translated">BTreeMap::hash</target>
        </trans-unit>
        <trans-unit id="cf9f5d8139a53420363c542bee60960cfdf4b73f" translate="yes" xml:space="preserve">
          <source>BTreeMap::hash_slice</source>
          <target state="translated">BTreeMap::hash_slice</target>
        </trans-unit>
        <trans-unit id="9d0f58d76739deb0afae24d930afc89e886727c1" translate="yes" xml:space="preserve">
          <source>BTreeMap::index</source>
          <target state="translated">BTreeMap::index</target>
        </trans-unit>
        <trans-unit id="495b083c76694857a7d488aae7997ecc9b65b8fd" translate="yes" xml:space="preserve">
          <source>BTreeMap::insert</source>
          <target state="translated">BTreeMap::insert</target>
        </trans-unit>
        <trans-unit id="df183dd97d9b53936c9da9b18c544dcca3159f96" translate="yes" xml:space="preserve">
          <source>BTreeMap::into</source>
          <target state="translated">BTreeMap::into</target>
        </trans-unit>
        <trans-unit id="fc4dae35af80d2a787e9d9736c90c00c41315ce5" translate="yes" xml:space="preserve">
          <source>BTreeMap::into_iter</source>
          <target state="translated">BTreeMap::into_iter</target>
        </trans-unit>
        <trans-unit id="34464fef785cdf817cc72448c6950077bd889a22" translate="yes" xml:space="preserve">
          <source>BTreeMap::is_empty</source>
          <target state="translated">BTreeMap::is_empty</target>
        </trans-unit>
        <trans-unit id="f0cc7817b62e10040c3cb5b80461b8e39c5f0f79" translate="yes" xml:space="preserve">
          <source>BTreeMap::iter</source>
          <target state="translated">BTreeMap::iter</target>
        </trans-unit>
        <trans-unit id="db8aca8da8288f53fcb308f1bc4fd2b4cacd2358" translate="yes" xml:space="preserve">
          <source>BTreeMap::iter_mut</source>
          <target state="translated">BTreeMap::iter_mut</target>
        </trans-unit>
        <trans-unit id="17e2b2189c6d71bc1225646a44b2dd0dedd8f47e" translate="yes" xml:space="preserve">
          <source>BTreeMap::keys</source>
          <target state="translated">BTreeMap::keys</target>
        </trans-unit>
        <trans-unit id="9d8ea9a92f24bfb8408ae08918cf32d255567986" translate="yes" xml:space="preserve">
          <source>BTreeMap::le</source>
          <target state="translated">BTreeMap::le</target>
        </trans-unit>
        <trans-unit id="69fcce80124f37da2a3264b3eb42f4416e80e515" translate="yes" xml:space="preserve">
          <source>BTreeMap::len</source>
          <target state="translated">BTreeMap::len</target>
        </trans-unit>
        <trans-unit id="9d226dd3e31bc04059d6780da00c779d71a0c07b" translate="yes" xml:space="preserve">
          <source>BTreeMap::lt</source>
          <target state="translated">BTreeMap::lt</target>
        </trans-unit>
        <trans-unit id="28cb2cc6fd2d128843e6d248dab95763d1010e94" translate="yes" xml:space="preserve">
          <source>BTreeMap::max</source>
          <target state="translated">BTreeMap::max</target>
        </trans-unit>
        <trans-unit id="e204c8d42ea76d6a7764ea9e58274fe5c3bb002d" translate="yes" xml:space="preserve">
          <source>BTreeMap::min</source>
          <target state="translated">BTreeMap::min</target>
        </trans-unit>
        <trans-unit id="b1f505e6c5b1bc5d067a0962eaa8081602c15a7a" translate="yes" xml:space="preserve">
          <source>BTreeMap::ne</source>
          <target state="translated">BTreeMap::ne</target>
        </trans-unit>
        <trans-unit id="553eafd890c40ffaf003fe540a734e36e0e18621" translate="yes" xml:space="preserve">
          <source>BTreeMap::new</source>
          <target state="translated">BTreeMap::new</target>
        </trans-unit>
        <trans-unit id="145a5aeffe19ab72f79646e0207cf635764ce346" translate="yes" xml:space="preserve">
          <source>BTreeMap::partial_cmp</source>
          <target state="translated">BTreeMap::partial_cmp</target>
        </trans-unit>
        <trans-unit id="db1a963168ea048f3f16233197ab263e60b2b507" translate="yes" xml:space="preserve">
          <source>BTreeMap::range</source>
          <target state="translated">BTreeMap::range</target>
        </trans-unit>
        <trans-unit id="3fee919f6744bdc9b2c87f1284d03bd737c587e9" translate="yes" xml:space="preserve">
          <source>BTreeMap::range_mut</source>
          <target state="translated">BTreeMap::range_mut</target>
        </trans-unit>
        <trans-unit id="f730581dfe02c1cd76fc7cd5f47e7e1ec7741713" translate="yes" xml:space="preserve">
          <source>BTreeMap::remove</source>
          <target state="translated">BTreeMap::remove</target>
        </trans-unit>
        <trans-unit id="a37cec31f9d8447344a2cb11b02572d5369eaecb" translate="yes" xml:space="preserve">
          <source>BTreeMap::split_off</source>
          <target state="translated">BTreeMap::split_off</target>
        </trans-unit>
        <trans-unit id="dd1d37326d92e085a2131397045e5968a461a29d" translate="yes" xml:space="preserve">
          <source>BTreeMap::to_owned</source>
          <target state="translated">BTreeMap::to_owned</target>
        </trans-unit>
        <trans-unit id="f4b12905aac1d13f63c54fa99e15b6d767c0949a" translate="yes" xml:space="preserve">
          <source>BTreeMap::try_from</source>
          <target state="translated">BTreeMap::try_from</target>
        </trans-unit>
        <trans-unit id="8714974f74a34a38551f441ede21c0f7c7518766" translate="yes" xml:space="preserve">
          <source>BTreeMap::try_into</source>
          <target state="translated">BTreeMap::try_into</target>
        </trans-unit>
        <trans-unit id="a562c087f2e1443045e2342f53c040d13fff0500" translate="yes" xml:space="preserve">
          <source>BTreeMap::type_id</source>
          <target state="translated">BTreeMap::type_id</target>
        </trans-unit>
        <trans-unit id="fef95975d5290dbd397d0e8018f6118b5b3445f8" translate="yes" xml:space="preserve">
          <source>BTreeMap::values</source>
          <target state="translated">BTreeMap::values</target>
        </trans-unit>
        <trans-unit id="b2e013070087a41fefec42e8c8812a309f157c48" translate="yes" xml:space="preserve">
          <source>BTreeMap::values_mut</source>
          <target state="translated">BTreeMap::values_mut</target>
        </trans-unit>
        <trans-unit id="529df1988796f2371c28af38a10631626e30c033" translate="yes" xml:space="preserve">
          <source>BTreeSet</source>
          <target state="translated">BTreeSet</target>
        </trans-unit>
        <trans-unit id="8863be2c232d70a5eeb4560459b4be5b2c0073a8" translate="yes" xml:space="preserve">
          <source>BTreeSet::append</source>
          <target state="translated">BTreeSet::append</target>
        </trans-unit>
        <trans-unit id="208528633622bb579ebc99572c1cd5b23c0ff3fe" translate="yes" xml:space="preserve">
          <source>BTreeSet::bitand</source>
          <target state="translated">BTreeSet::bitand</target>
        </trans-unit>
        <trans-unit id="8c7f6d7d0bd709c67b308f34e3fdea1982987576" translate="yes" xml:space="preserve">
          <source>BTreeSet::bitor</source>
          <target state="translated">BTreeSet::bitor</target>
        </trans-unit>
        <trans-unit id="b50a2f00b4df89c4fc2d8b38a2151e87a882ff0b" translate="yes" xml:space="preserve">
          <source>BTreeSet::bitxor</source>
          <target state="translated">BTreeSet::bitxor</target>
        </trans-unit>
        <trans-unit id="cccc4bace80a38b5837fc997cc5c49754d796ac4" translate="yes" xml:space="preserve">
          <source>BTreeSet::borrow</source>
          <target state="translated">BTreeSet::borrow</target>
        </trans-unit>
        <trans-unit id="c3906f6d078061570593f2fe7b73fa2840328771" translate="yes" xml:space="preserve">
          <source>BTreeSet::borrow_mut</source>
          <target state="translated">BTreeSet::borrow_mut</target>
        </trans-unit>
        <trans-unit id="4aa030ae00992ccd9a53652df9153409be56a2a2" translate="yes" xml:space="preserve">
          <source>BTreeSet::clamp</source>
          <target state="translated">BTreeSet::clamp</target>
        </trans-unit>
        <trans-unit id="7dbd4b9a7ec2f778cf457d4c27e677b1357aa7da" translate="yes" xml:space="preserve">
          <source>BTreeSet::clear</source>
          <target state="translated">BTreeSet::clear</target>
        </trans-unit>
        <trans-unit id="5b30f459964be9100787e5939f482cd8d7073397" translate="yes" xml:space="preserve">
          <source>BTreeSet::clone</source>
          <target state="translated">BTreeSet::clone</target>
        </trans-unit>
        <trans-unit id="050795ce2f3842fb14df3b7b6623ddb813ac2ad6" translate="yes" xml:space="preserve">
          <source>BTreeSet::clone_from</source>
          <target state="translated">BTreeSet::clone_from</target>
        </trans-unit>
        <trans-unit id="53b99dc8a6c6498122bd0b00e8114abe2667c8af" translate="yes" xml:space="preserve">
          <source>BTreeSet::clone_into</source>
          <target state="translated">BTreeSet::clone_into</target>
        </trans-unit>
        <trans-unit id="de2ebfb73a4bfaed7ca14354db78235b93dbbcb9" translate="yes" xml:space="preserve">
          <source>BTreeSet::cmp</source>
          <target state="translated">BTreeSet::cmp</target>
        </trans-unit>
        <trans-unit id="3e582a8879cbba7048152fe7baf6d319ff38bc16" translate="yes" xml:space="preserve">
          <source>BTreeSet::contains</source>
          <target state="translated">BTreeSet::contains</target>
        </trans-unit>
        <trans-unit id="21aa5487bfe6b638ff9a362eaa67cb633fc82867" translate="yes" xml:space="preserve">
          <source>BTreeSet::default</source>
          <target state="translated">BTreeSet::default</target>
        </trans-unit>
        <trans-unit id="d7c44959c458f0838dfab77ed6b6f2add8735a14" translate="yes" xml:space="preserve">
          <source>BTreeSet::difference</source>
          <target state="translated">BTreeSet::difference</target>
        </trans-unit>
        <trans-unit id="16f9dc4e686355d372b64a80e877507f0084b34a" translate="yes" xml:space="preserve">
          <source>BTreeSet::eq</source>
          <target state="translated">BTreeSet::eq</target>
        </trans-unit>
        <trans-unit id="9edee760d67dfee35cacd64d97c0b93bcecc3eb7" translate="yes" xml:space="preserve">
          <source>BTreeSet::extend</source>
          <target state="translated">BTreeSet::extend</target>
        </trans-unit>
        <trans-unit id="afc2d0e53bf4c5f63abce2f83b8f542897205aac" translate="yes" xml:space="preserve">
          <source>BTreeSet::fmt</source>
          <target state="translated">BTreeSet::fmt</target>
        </trans-unit>
        <trans-unit id="50633916fcf03b37e42d17b8960dc21b40ef24a7" translate="yes" xml:space="preserve">
          <source>BTreeSet::from</source>
          <target state="translated">BTreeSet::from</target>
        </trans-unit>
        <trans-unit id="caf6d0db82051ce20ec56dd44cb0a17ec0b98d23" translate="yes" xml:space="preserve">
          <source>BTreeSet::from_iter</source>
          <target state="translated">BTreeSet::from_iter</target>
        </trans-unit>
        <trans-unit id="be2acc08fadae340b24bbbb5601dcd11b43af4ff" translate="yes" xml:space="preserve">
          <source>BTreeSet::ge</source>
          <target state="translated">BTreeSet::ge</target>
        </trans-unit>
        <trans-unit id="eebfcd72f45c81fa6bcc82833412cbba7e8dc9f6" translate="yes" xml:space="preserve">
          <source>BTreeSet::get</source>
          <target state="translated">BTreeSet::get</target>
        </trans-unit>
        <trans-unit id="692fcfa52c7940ed1e980094be254853ea4f2c35" translate="yes" xml:space="preserve">
          <source>BTreeSet::gt</source>
          <target state="translated">BTreeSet::gt</target>
        </trans-unit>
        <trans-unit id="0546ef8f63c560e2610c71f5ad1ae889cfa00795" translate="yes" xml:space="preserve">
          <source>BTreeSet::hash</source>
          <target state="translated">BTreeSet::hash</target>
        </trans-unit>
        <trans-unit id="4f6fe8cde85490c116cbac4ed558e1916281d86a" translate="yes" xml:space="preserve">
          <source>BTreeSet::hash_slice</source>
          <target state="translated">BTreeSet::hash_slice</target>
        </trans-unit>
        <trans-unit id="eda956eff955ffd9727eb53f2bf7e0715817c65d" translate="yes" xml:space="preserve">
          <source>BTreeSet::insert</source>
          <target state="translated">BTreeSet::insert</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
