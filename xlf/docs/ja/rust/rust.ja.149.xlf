<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="772b77fdfc8e9968126bb233f7891ef8441c5352" translate="yes" xml:space="preserve">
          <source>Takes two iterators and creates a new iterator over both in sequence. &lt;a href=&quot;trait.iterator#method.chain&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">2つのイテレーターを取り、両方に対して新しいイテレーターを順番に作成します。&lt;a href=&quot;trait.iterator#method.chain&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e48610b94d0c8b865914c76042a0dd63c8ace3fb" translate="yes" xml:space="preserve">
          <source>Taking a &lt;a href=&quot;trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt; as a parameter:</source>
          <target state="translated">撮影&lt;a href=&quot;trait.fn&quot;&gt; &lt;code&gt;Fn&lt;/code&gt; &lt;/a&gt;パラメータとして：</target>
        </trans-unit>
        <trans-unit id="4f62d9e379567856d558f8df128e53e7eeda59a9" translate="yes" xml:space="preserve">
          <source>Taking a &lt;a href=&quot;trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt; as a parameter:</source>
          <target state="translated">撮影&lt;a href=&quot;trait.fnmut&quot;&gt; &lt;code&gt;FnMut&lt;/code&gt; を&lt;/a&gt;パラメータとして：</target>
        </trans-unit>
        <trans-unit id="acf17a2c9691dbabd08f8be26e62792363680f2f" translate="yes" xml:space="preserve">
          <source>Taking a &lt;a href=&quot;trait.fnonce&quot;&gt;&lt;code&gt;FnOnce&lt;/code&gt;&lt;/a&gt; as a parameter:</source>
          <target state="translated">撮影&lt;a href=&quot;trait.fnonce&quot;&gt; &lt;code&gt;FnOnce&lt;/code&gt; を&lt;/a&gt;パラメータとして：</target>
        </trans-unit>
        <trans-unit id="9b593af3c7f2108f31456b5ab2cb3574e71f3b6e" translate="yes" xml:space="preserve">
          <source>Taking ownership and then returning ownership with every function is a bit tedious. What if we want to let a function use a value but not take ownership? It&amp;rsquo;s quite annoying that anything we pass in also needs to be passed back if we want to use it again, in addition to any data resulting from the body of the function that we might want to return as well.</source>
          <target state="translated">所有権を取得し、すべての機能で所有権を返すのは少し面倒です。関数が値を使用できるようにしたいが、所有権は取得しない場合はどうなりますか？返す必要がある関数の本体から得られたデータに加えて、再度使用する場合は、渡したものもすべて返さなければならないことは非常に面倒です。</target>
        </trans-unit>
        <trans-unit id="4aa5a6c5b61f9a1ca73ba483f7a4a44ead615a2c" translate="yes" xml:space="preserve">
          <source>Targets which do not support switching between linkage of the C runtime will ignore this flag. It's recommended to inspect the resulting binary to ensure that it's linked as you would expect after the compiler succeeds.</source>
          <target state="translated">C ランタイムのリンケージの切り替えをサポートしていないターゲットは、このフラグを無視します。コンパイラが成功した後、結果のバイナリが期待通りにリンクされていることを確認するために検査することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="0eecee1ef4d6e466bffed10ffafec520b9a50288" translate="yes" xml:space="preserve">
          <source>Task context</source>
          <target state="translated">タスクコンテキスト</target>
        </trans-unit>
        <trans-unit id="9ad8024a2c7b1265fb5e22250fc7a31283cdbd36" translate="yes" xml:space="preserve">
          <source>TcpListener</source>
          <target state="translated">TcpListener</target>
        </trans-unit>
        <trans-unit id="ece7cdbc23c076f1d64f752343ef7aec8eec539f" translate="yes" xml:space="preserve">
          <source>TcpListener::accept</source>
          <target state="translated">TcpListener::accept</target>
        </trans-unit>
        <trans-unit id="a2a291bb7ab19718d31f7478d18104e4158a939c" translate="yes" xml:space="preserve">
          <source>TcpListener::as_raw_fd</source>
          <target state="translated">TcpListener::as_raw_fd</target>
        </trans-unit>
        <trans-unit id="49f5fe2427c190a7f8a472e06e6d569a7ff427c4" translate="yes" xml:space="preserve">
          <source>TcpListener::as_raw_socket</source>
          <target state="translated">TcpListener::as_raw_socket</target>
        </trans-unit>
        <trans-unit id="2e2338f796fa51dd367f2f2c91e316fe98afe3a0" translate="yes" xml:space="preserve">
          <source>TcpListener::bind</source>
          <target state="translated">TcpListener::bind</target>
        </trans-unit>
        <trans-unit id="bc75d22ad0ef01f38f6f564c0448b514f01f2b1e" translate="yes" xml:space="preserve">
          <source>TcpListener::borrow</source>
          <target state="translated">TcpListener::borrow</target>
        </trans-unit>
        <trans-unit id="b7bf89d05dc43863ce7b237f1c9339841b44d828" translate="yes" xml:space="preserve">
          <source>TcpListener::borrow_mut</source>
          <target state="translated">TcpListener::borrow_mut</target>
        </trans-unit>
        <trans-unit id="67148bab8cc6c3ad3159fa098deca2df5084c5bc" translate="yes" xml:space="preserve">
          <source>TcpListener::fmt</source>
          <target state="translated">TcpListener::fmt</target>
        </trans-unit>
        <trans-unit id="e2222d5e97ec906a2d58760a4b094c72e792239f" translate="yes" xml:space="preserve">
          <source>TcpListener::from</source>
          <target state="translated">TcpListener::from</target>
        </trans-unit>
        <trans-unit id="965dc7a632243e984a2b9e894788c6c21d7eb5d8" translate="yes" xml:space="preserve">
          <source>TcpListener::from_raw_fd</source>
          <target state="translated">TcpListener::from_raw_fd</target>
        </trans-unit>
        <trans-unit id="482dc849c70cec776e4f8a473271ccf0cb6cf277" translate="yes" xml:space="preserve">
          <source>TcpListener::from_raw_socket</source>
          <target state="translated">TcpListener::from_raw_socket</target>
        </trans-unit>
        <trans-unit id="1934b5e7d2fb2d8224b23b4ad0d2399a5cb3b873" translate="yes" xml:space="preserve">
          <source>TcpListener::incoming</source>
          <target state="translated">TcpListener::incoming</target>
        </trans-unit>
        <trans-unit id="428c642a4eaf5906beb8fe4edf0ac026bb70054c" translate="yes" xml:space="preserve">
          <source>TcpListener::into</source>
          <target state="translated">TcpListener::into</target>
        </trans-unit>
        <trans-unit id="ecf165a93c2c3a51f657446508db4792cbb31eef" translate="yes" xml:space="preserve">
          <source>TcpListener::into_raw_fd</source>
          <target state="translated">TcpListener::into_raw_fd</target>
        </trans-unit>
        <trans-unit id="171dba66a0881e83fbf754117718cae198277962" translate="yes" xml:space="preserve">
          <source>TcpListener::into_raw_socket</source>
          <target state="translated">TcpListener::into_raw_socket</target>
        </trans-unit>
        <trans-unit id="2275a3d2aa672ca4311b697b11d81ca54319cd4f" translate="yes" xml:space="preserve">
          <source>TcpListener::local_addr</source>
          <target state="translated">TcpListener::local_addr</target>
        </trans-unit>
        <trans-unit id="ec11714ec8bf6a942994646bb7ec40f6ec987004" translate="yes" xml:space="preserve">
          <source>TcpListener::only_v6</source>
          <target state="translated">TcpListener::only_v6</target>
        </trans-unit>
        <trans-unit id="8f9762884937dfa70d1e7429478f09a0cb47d310" translate="yes" xml:space="preserve">
          <source>TcpListener::set_nonblocking</source>
          <target state="translated">TcpListener::set_nonblocking</target>
        </trans-unit>
        <trans-unit id="226f648e250e40bcc471fd5a673bff010846e472" translate="yes" xml:space="preserve">
          <source>TcpListener::set_only_v6</source>
          <target state="translated">TcpListener::set_only_v6</target>
        </trans-unit>
        <trans-unit id="4715bf3aa73135001a12ace3fe29f1f7e2fa4701" translate="yes" xml:space="preserve">
          <source>TcpListener::set_ttl</source>
          <target state="translated">TcpListener::set_ttl</target>
        </trans-unit>
        <trans-unit id="52dd134154d36dce171d232dad1f997d4a86ef76" translate="yes" xml:space="preserve">
          <source>TcpListener::take_error</source>
          <target state="translated">TcpListener::take_error</target>
        </trans-unit>
        <trans-unit id="346a3319242ccfb5f2d382bc3687dc41f26c3692" translate="yes" xml:space="preserve">
          <source>TcpListener::try_clone</source>
          <target state="translated">TcpListener::try_clone</target>
        </trans-unit>
        <trans-unit id="8774def23dc815607fb5f6d621a655e6351d76ed" translate="yes" xml:space="preserve">
          <source>TcpListener::try_from</source>
          <target state="translated">TcpListener::try_from</target>
        </trans-unit>
        <trans-unit id="4d964782d52d7cadd1d535988a4c17142f01c956" translate="yes" xml:space="preserve">
          <source>TcpListener::try_into</source>
          <target state="translated">TcpListener::try_into</target>
        </trans-unit>
        <trans-unit id="720c95f141c0826fd5fca57448ce533672b87275" translate="yes" xml:space="preserve">
          <source>TcpListener::ttl</source>
          <target state="translated">TcpListener::ttl</target>
        </trans-unit>
        <trans-unit id="8b5ab82dcc35d3a2cd49204d3a4a7a3449b42f85" translate="yes" xml:space="preserve">
          <source>TcpListener::type_id</source>
          <target state="translated">TcpListener::type_id</target>
        </trans-unit>
        <trans-unit id="35342d32149945519f7e31daff4e30855fbeba49" translate="yes" xml:space="preserve">
          <source>TcpStream</source>
          <target state="translated">TcpStream</target>
        </trans-unit>
        <trans-unit id="9eafc6b129d5efa5c4b0a83e50a95e30344816f3" translate="yes" xml:space="preserve">
          <source>TcpStream::as_raw_fd</source>
          <target state="translated">TcpStream::as_raw_fd</target>
        </trans-unit>
        <trans-unit id="09ec2aef24015b31ab23113ac683d2f8346c1f39" translate="yes" xml:space="preserve">
          <source>TcpStream::as_raw_socket</source>
          <target state="translated">TcpStream::as_raw_socket</target>
        </trans-unit>
        <trans-unit id="12e762e3cfe2aa9d71a2a757abb3507e964d1881" translate="yes" xml:space="preserve">
          <source>TcpStream::borrow</source>
          <target state="translated">TcpStream::borrow</target>
        </trans-unit>
        <trans-unit id="d91a58f6ef21ac04bf7fb8b19bbc87b6dbe9fb4c" translate="yes" xml:space="preserve">
          <source>TcpStream::borrow_mut</source>
          <target state="translated">TcpStream::borrow_mut</target>
        </trans-unit>
        <trans-unit id="11f8dcda0e1ccab974f38cf496de4e39b14b25cb" translate="yes" xml:space="preserve">
          <source>TcpStream::by_ref</source>
          <target state="translated">TcpStream::by_ref</target>
        </trans-unit>
        <trans-unit id="bfbef109c2e4f33f2aedd0c714f14f49404d152c" translate="yes" xml:space="preserve">
          <source>TcpStream::bytes</source>
          <target state="translated">TcpStream::bytes</target>
        </trans-unit>
        <trans-unit id="e1fe899d60189a16135ede51a667e0fdef40fd00" translate="yes" xml:space="preserve">
          <source>TcpStream::chain</source>
          <target state="translated">TcpStream::chain</target>
        </trans-unit>
        <trans-unit id="9b075e5500b6c35efe89a7d4bf0762c653e6221c" translate="yes" xml:space="preserve">
          <source>TcpStream::connect</source>
          <target state="translated">TcpStream::connect</target>
        </trans-unit>
        <trans-unit id="7c9bc4cc7e00f6a9f012c5c2f74296bd08fb3cd9" translate="yes" xml:space="preserve">
          <source>TcpStream::connect_timeout</source>
          <target state="translated">TcpStream::connect_timeout</target>
        </trans-unit>
        <trans-unit id="7e82ba30a964300fd5401b21bdde38ef8892a264" translate="yes" xml:space="preserve">
          <source>TcpStream::flush</source>
          <target state="translated">TcpStream::flush</target>
        </trans-unit>
        <trans-unit id="5e2f83b6ef3a2fd9f5722070fe250aef910cb0f5" translate="yes" xml:space="preserve">
          <source>TcpStream::fmt</source>
          <target state="translated">TcpStream::fmt</target>
        </trans-unit>
        <trans-unit id="3a3304a1471ecd9e54075022592709e4164425d3" translate="yes" xml:space="preserve">
          <source>TcpStream::from</source>
          <target state="translated">TcpStream::from</target>
        </trans-unit>
        <trans-unit id="0c544151d800149c130a2b4e5fa0242d2c6c5fe2" translate="yes" xml:space="preserve">
          <source>TcpStream::from_raw_fd</source>
          <target state="translated">TcpStream::from_raw_fd</target>
        </trans-unit>
        <trans-unit id="f33ab52a5f61c4e532d24e2b9d448a864ab588ef" translate="yes" xml:space="preserve">
          <source>TcpStream::from_raw_socket</source>
          <target state="translated">TcpStream::from_raw_socket</target>
        </trans-unit>
        <trans-unit id="ac8cf31a8273795291384f9b9a189065f0e4ddda" translate="yes" xml:space="preserve">
          <source>TcpStream::initializer</source>
          <target state="translated">TcpStream::initializer</target>
        </trans-unit>
        <trans-unit id="bb02adb8fb5756c502d5d11c517f31b37848f5b3" translate="yes" xml:space="preserve">
          <source>TcpStream::into</source>
          <target state="translated">TcpStream::into</target>
        </trans-unit>
        <trans-unit id="8b62d5f9b1506a6417ce6b1e7abc2fe81f1a512b" translate="yes" xml:space="preserve">
          <source>TcpStream::into_raw_fd</source>
          <target state="translated">TcpStream::into_raw_fd</target>
        </trans-unit>
        <trans-unit id="2d62e49030fac395488f03a44bc65385d791c4a1" translate="yes" xml:space="preserve">
          <source>TcpStream::into_raw_socket</source>
          <target state="translated">TcpStream::into_raw_socket</target>
        </trans-unit>
        <trans-unit id="2f15c295f6cbee27e4704ba77400c3f9cdb74347" translate="yes" xml:space="preserve">
          <source>TcpStream::local_addr</source>
          <target state="translated">TcpStream::local_addr</target>
        </trans-unit>
        <trans-unit id="3e41769cd3c7bc5fe0ffd071decfac8538fce3c8" translate="yes" xml:space="preserve">
          <source>TcpStream::nodelay</source>
          <target state="translated">TcpStream::nodelay</target>
        </trans-unit>
        <trans-unit id="b1c4ef3a856c377290ba0effe22fa456b4c5d618" translate="yes" xml:space="preserve">
          <source>TcpStream::peek</source>
          <target state="translated">TcpStream::peek</target>
        </trans-unit>
        <trans-unit id="02b5be94fe4bd3a77f45294ce309a022defb0142" translate="yes" xml:space="preserve">
          <source>TcpStream::peer_addr</source>
          <target state="translated">TcpStream::peer_addr</target>
        </trans-unit>
        <trans-unit id="168308bcf15754b94b3cd0ff91dc84d727c89085" translate="yes" xml:space="preserve">
          <source>TcpStream::read</source>
          <target state="translated">TcpStream::read</target>
        </trans-unit>
        <trans-unit id="a51f803ec2bc3d6b94f3630947f31e7b2bee3ed5" translate="yes" xml:space="preserve">
          <source>TcpStream::read_exact</source>
          <target state="translated">TcpStream::read_exact</target>
        </trans-unit>
        <trans-unit id="cddced3b85b2ead651c93e97a2f622b9f49035db" translate="yes" xml:space="preserve">
          <source>TcpStream::read_timeout</source>
          <target state="translated">TcpStream::read_timeout</target>
        </trans-unit>
        <trans-unit id="1957796c8b2bd9a577cc9018f30d0a2d1c2fe241" translate="yes" xml:space="preserve">
          <source>TcpStream::read_to_end</source>
          <target state="translated">TcpStream::read_to_end</target>
        </trans-unit>
        <trans-unit id="9f494c5d56be921420520740cf0cbafa75a20b7b" translate="yes" xml:space="preserve">
          <source>TcpStream::read_to_string</source>
          <target state="translated">TcpStream::read_to_string</target>
        </trans-unit>
        <trans-unit id="c6fa288859680339e04670a33f1a14f57af1e652" translate="yes" xml:space="preserve">
          <source>TcpStream::read_vectored</source>
          <target state="translated">TcpStream::read_vectored</target>
        </trans-unit>
        <trans-unit id="e83138e7f219d526516674b5550a795c09cf97fa" translate="yes" xml:space="preserve">
          <source>TcpStream::set_nodelay</source>
          <target state="translated">TcpStream::set_nodelay</target>
        </trans-unit>
        <trans-unit id="6f3db10df76b321eadb9c9c65b440fd1e62d4157" translate="yes" xml:space="preserve">
          <source>TcpStream::set_nonblocking</source>
          <target state="translated">TcpStream::set_nonblocking</target>
        </trans-unit>
        <trans-unit id="0ef1754192987fd2a71c4d09d1363328c40af9e8" translate="yes" xml:space="preserve">
          <source>TcpStream::set_read_timeout</source>
          <target state="translated">TcpStream::set_read_timeout</target>
        </trans-unit>
        <trans-unit id="1c0d37734b35b5aaae88202ef8744780ebadf163" translate="yes" xml:space="preserve">
          <source>TcpStream::set_ttl</source>
          <target state="translated">TcpStream::set_ttl</target>
        </trans-unit>
        <trans-unit id="cf06a99e15825f5af0170343a971d82291a1bb70" translate="yes" xml:space="preserve">
          <source>TcpStream::set_write_timeout</source>
          <target state="translated">TcpStream::set_write_timeout</target>
        </trans-unit>
        <trans-unit id="de9f03e4aaf65b0dacf8a1a510098378140fbad7" translate="yes" xml:space="preserve">
          <source>TcpStream::shutdown</source>
          <target state="translated">TcpStream::shutdown</target>
        </trans-unit>
        <trans-unit id="f729ec43f0af2f4768020c3c186531540aa6fe75" translate="yes" xml:space="preserve">
          <source>TcpStream::take</source>
          <target state="translated">TcpStream::take</target>
        </trans-unit>
        <trans-unit id="07ca37092d4865ff34b3da8842e6f13eb4a33726" translate="yes" xml:space="preserve">
          <source>TcpStream::take_error</source>
          <target state="translated">TcpStream::take_error</target>
        </trans-unit>
        <trans-unit id="3f33672645be4d6e5bd0541f33a42009a106b1ad" translate="yes" xml:space="preserve">
          <source>TcpStream::try_clone</source>
          <target state="translated">TcpStream::try_clone</target>
        </trans-unit>
        <trans-unit id="0e120d19ada990068a0b20ff52db32daba2c74d5" translate="yes" xml:space="preserve">
          <source>TcpStream::try_from</source>
          <target state="translated">TcpStream::try_from</target>
        </trans-unit>
        <trans-unit id="0b039d724a73bfa4d009fb758a03fb779a56b987" translate="yes" xml:space="preserve">
          <source>TcpStream::try_into</source>
          <target state="translated">TcpStream::try_into</target>
        </trans-unit>
        <trans-unit id="833adb6a3443ef8c2bc774bcc30192c98f27094a" translate="yes" xml:space="preserve">
          <source>TcpStream::ttl</source>
          <target state="translated">TcpStream::ttl</target>
        </trans-unit>
        <trans-unit id="ad00f68ee2a21774a182c99f9b2a83cd6f6f89e9" translate="yes" xml:space="preserve">
          <source>TcpStream::type_id</source>
          <target state="translated">TcpStream::type_id</target>
        </trans-unit>
        <trans-unit id="accd5bacb0184a5ab554a0ca248574c5b5ddbbcb" translate="yes" xml:space="preserve">
          <source>TcpStream::write</source>
          <target state="translated">TcpStream::write</target>
        </trans-unit>
        <trans-unit id="0058eeee13c9051b5e0a752af3087b29d7b02d7b" translate="yes" xml:space="preserve">
          <source>TcpStream::write_all</source>
          <target state="translated">TcpStream::write_all</target>
        </trans-unit>
        <trans-unit id="cb06fd9c7d1d55fc4b3f3e15dc0163521ac1465b" translate="yes" xml:space="preserve">
          <source>TcpStream::write_fmt</source>
          <target state="translated">TcpStream::write_fmt</target>
        </trans-unit>
        <trans-unit id="a5e3f17e3264af59b558a0fdcba770ba3c28fa37" translate="yes" xml:space="preserve">
          <source>TcpStream::write_timeout</source>
          <target state="translated">TcpStream::write_timeout</target>
        </trans-unit>
        <trans-unit id="6e74581726f107bfc541797c5b9030282bc56e97" translate="yes" xml:space="preserve">
          <source>TcpStream::write_vectored</source>
          <target state="translated">TcpStream::write_vectored</target>
        </trans-unit>
        <trans-unit id="b6eac90e1928ad9ea4411f97ebcf59a5c7e10ed0" translate="yes" xml:space="preserve">
          <source>Teams of Developers</source>
          <target state="translated">開発者チーム</target>
        </trans-unit>
        <trans-unit id="260e040b381f220359095e13ffb45be2fbc63287" translate="yes" xml:space="preserve">
          <source>Tells LLVM that this point in the code is not reachable, enabling further optimizations.</source>
          <target state="translated">コードのこの点に到達できないことをLLVMに伝え、さらなる最適化を可能にします。</target>
        </trans-unit>
        <trans-unit id="a946abf59c33631dd9c09fe026f5fda52ecefd51" translate="yes" xml:space="preserve">
          <source>Tells this buffer that &lt;code&gt;amt&lt;/code&gt; bytes have been consumed from the buffer, so they should no longer be returned in calls to &lt;code&gt;read&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;amt&lt;/code&gt; バイトがバッファーから消費されたので、 &lt;code&gt;read&lt;/code&gt; の呼び出しで返されないように、このバッファーに通知します。</target>
        </trans-unit>
        <trans-unit id="092a16374b222f88ad28cf25d43d7648234ed176" translate="yes" xml:space="preserve">
          <source>Tells this buffer that &lt;code&gt;amt&lt;/code&gt; bytes have been consumed from the buffer, so they should no longer be returned in calls to &lt;code&gt;read&lt;/code&gt;. &lt;a href=&quot;../io/trait.bufread#tymethod.consume&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;amt&lt;/code&gt; バイトがバッファーから消費されたので、 &lt;code&gt;read&lt;/code&gt; の呼び出しで返されないように、このバッファーに通知します。&lt;a href=&quot;../io/trait.bufread#tymethod.consume&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="027be37242a148e84d0572e0cc986124d9c751bc" translate="yes" xml:space="preserve">
          <source>Tells this buffer that &lt;code&gt;amt&lt;/code&gt; bytes have been consumed from the buffer, so they should no longer be returned in calls to &lt;code&gt;read&lt;/code&gt;. &lt;a href=&quot;io/trait.bufread#tymethod.consume&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;amt&lt;/code&gt; バイトがバッファーから消費されたので、 &lt;code&gt;read&lt;/code&gt; の呼び出しで返されないように、このバッファーに通知します。&lt;a href=&quot;io/trait.bufread#tymethod.consume&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ea3b911565206879ae5d6cb4146bc834dfb6a7f3" translate="yes" xml:space="preserve">
          <source>Tells this buffer that &lt;code&gt;amt&lt;/code&gt; bytes have been consumed from the buffer, so they should no longer be returned in calls to &lt;code&gt;read&lt;/code&gt;. &lt;a href=&quot;trait.bufread#tymethod.consume&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;amt&lt;/code&gt; バイトがバッファーから消費されたので、 &lt;code&gt;read&lt;/code&gt; の呼び出しで返されないように、このバッファーに通知します。&lt;a href=&quot;trait.bufread#tymethod.consume&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="68f4c5ea285ef679416734518ea1144f7f9f2cf1" translate="yes" xml:space="preserve">
          <source>Temporal quantification.</source>
          <target state="translated">時間的な定量化。</target>
        </trans-unit>
        <trans-unit id="be80baca9006a4100bd6b71127149a07eb502503" translate="yes" xml:space="preserve">
          <source>Temporaries</source>
          <target state="translated">Temporaries</target>
        </trans-unit>
        <trans-unit id="b1380bff4b98c3f3b1a409ce860a8bd5d4ce8c7b" translate="yes" xml:space="preserve">
          <source>Temporaries are also created to hold the result of operands to an expression while the other operands are evaluated. The temporaries are associated to the scope of the expression with that operand. Since the temporaries are moved from once the expression is evaluated, dropping them has no effect unless one of the operands to an expression breaks out of the expression, returns, or panics.</source>
          <target state="translated">テンポラリは、他のオペランドが評価されている間、オペランドの結果を式に保持するためにも作成されます。このように、このモデルでは、「モデル・ナビゲーター」と「モデル・ナビゲーター」の両方の要素を使用することができます。このような場合には、「プロパティー」を使用して、「プロパティー」と「プロパティー」の間には、「プロパティー」と「プロパティー」の間の関係はありません。</target>
        </trans-unit>
        <trans-unit id="6121a6beed14a5f45c5406020e211d50eaf732ff" translate="yes" xml:space="preserve">
          <source>Temporaries are not always dropped at the end of the enclosing statement. In simple cases where the &lt;code&gt;&amp;amp;&lt;/code&gt; expression is immediately stored into a variable, the compiler will automatically extend the lifetime of the temporary until the end of the enclosing block. Therefore, an alternative way to fix the original program is to write &lt;code&gt;let tmp = &amp;amp;foo()&lt;/code&gt; and not &lt;code&gt;let tmp = foo()&lt;/code&gt;:</source>
          <target state="translated">一時文は、囲んでいる文の最後で常に削除されるわけではありません。 &lt;code&gt;&amp;amp;&lt;/code&gt; 式がすぐに変数に格納される単純なケースでは、コンパイラーは一時ブロックの存続期間を囲んでいるブロックの終わりまで自動的に延長します。したがって、元のプログラムを修正する別の方法は、 &lt;code&gt;let tmp = &amp;amp;foo()&lt;/code&gt; ではなく &lt;code&gt;let tmp = foo()&lt;/code&gt; と書くことです。</target>
        </trans-unit>
        <trans-unit id="ff4686225d8fb1e953162a00f63d6b94d5a386fd" translate="yes" xml:space="preserve">
          <source>Temporaries that are created in the final expression of a function body are dropped &lt;em&gt;after&lt;/em&gt; any named variables bound in the function body, as there is no smaller enclosing temporary scope.</source>
          <target state="translated">関数本体の最終式で作成された一時スコープは、関数本体にバインドされた名前付き変数の&lt;em&gt;後に&lt;/em&gt;削除されます。これは、閉じている一時スコープが小さいためです。</target>
        </trans-unit>
        <trans-unit id="aae8496ab0d5e20c300ea07a6c87645fbefee013" translate="yes" xml:space="preserve">
          <source>Temporary lifetime extension</source>
          <target state="translated">一時的な寿命延長</target>
        </trans-unit>
        <trans-unit id="a237179150c9f45b00df9097591b1d7f10ef2038" translate="yes" xml:space="preserve">
          <source>Temporary lifetimes</source>
          <target state="translated">一時的な寿命</target>
        </trans-unit>
        <trans-unit id="ace2219c94d381961a79fb4617905c5cfbbacbf7" translate="yes" xml:space="preserve">
          <source>Temporary scopes</source>
          <target state="translated">一時的なスコープ</target>
        </trans-unit>
        <trans-unit id="dfc9ea018278b216d5b6d6db9b73a7c2a6e7a8c8" translate="yes" xml:space="preserve">
          <source>Terminates the current process with the specified exit code.</source>
          <target state="translated">指定された終了コードで現在のプロセスを終了させます。</target>
        </trans-unit>
        <trans-unit id="4abcdd83ee3f3bce743cbed96b2ad9f965bea36e" translate="yes" xml:space="preserve">
          <source>Terminates the process in an abnormal fashion.</source>
          <target state="translated">異常な状態で処理を終了させます。</target>
        </trans-unit>
        <trans-unit id="2ee85218866a19e0d9f6c52c176e4eaf9d0877b2" translate="yes" xml:space="preserve">
          <source>Termination</source>
          <target state="translated">Termination</target>
        </trans-unit>
        <trans-unit id="4d00170cd71cecfb46cdbb7ebdf05a4a02fee721" translate="yes" xml:space="preserve">
          <source>Termination::report</source>
          <target state="translated">Termination::report</target>
        </trans-unit>
        <trans-unit id="00f441aa04210533cf8168c3d0baeda960edac55" translate="yes" xml:space="preserve">
          <source>Terminator for various items and statements, &lt;a href=&quot;types/array&quot;&gt;Array types&lt;/a&gt;</source>
          <target state="translated">さまざまなアイテムとステートメントのターミネーター、&lt;a href=&quot;types/array&quot;&gt;配列タイプ&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="94aaabf5a007f6525e86dbe783c284fccc74a25c" translate="yes" xml:space="preserve">
          <source>Test Organization</source>
          <target state="translated">テスト組織</target>
        </trans-unit>
        <trans-unit id="0820b32b206b7352858e8903a838ed14319acdfd" translate="yes" xml:space="preserve">
          <source>Testing</source>
          <target state="translated">Testing</target>
        </trans-unit>
        <trans-unit id="da7894cbcc38e877e01ccb02e3c5e98f656c5624" translate="yes" xml:space="preserve">
          <source>Testing Equality with the &lt;code id=&quot;testing-equality-with-the-assert_eq-and-assert_ne-macros&quot;&gt;assert_eq!&lt;/code&gt; and &lt;code&gt;assert_ne!&lt;/code&gt; Macros</source>
          <target state="translated">&lt;code id=&quot;testing-equality-with-the-assert_eq-and-assert_ne-macros&quot;&gt;assert_eq!&lt;/code&gt; した同等性のテスト！そして &lt;code&gt;assert_ne!&lt;/code&gt; マクロ</target>
        </trans-unit>
        <trans-unit id="117ea1d14f7b6fbe5fa90955d52644403f513522" translate="yes" xml:space="preserve">
          <source>Testing Private Functions</source>
          <target state="translated">プライベート関数のテスト</target>
        </trans-unit>
        <trans-unit id="932c5d1d0f6f5178e61a3f6e97a669a7ad5fc25b" translate="yes" xml:space="preserve">
          <source>Testing attributes</source>
          <target state="translated">テスト属性</target>
        </trans-unit>
        <trans-unit id="6966e45073f574893b66ceb3ad6d45bb2ced06e0" translate="yes" xml:space="preserve">
          <source>Testing is a complex skill: although we can&amp;rsquo;t cover every detail about how to write good tests in one chapter, we&amp;rsquo;ll discuss the mechanics of Rust&amp;rsquo;s testing facilities. We&amp;rsquo;ll talk about the annotations and macros available to you when writing your tests, the default behavior and options provided for running your tests, and how to organize tests into unit tests and integration tests.</source>
          <target state="translated">テストは複雑なスキルです。1つの章で適切なテストを作成する方法の詳細をカバーすることはできませんが、Rustのテスト機能のメカニズムについて説明します。テストの作成時に使用できる注釈とマクロ、テストの実行に提供されるデフォルトの動作とオプション、およびテストをユニットテストと統合テストに編成する方法について説明します。</target>
        </trans-unit>
        <trans-unit id="f7c988b9b3e507c053615421186791199dc1b08e" translate="yes" xml:space="preserve">
          <source>Testing the First Part</source>
          <target state="translated">第1部のテスト</target>
        </trans-unit>
        <trans-unit id="833858d67cb9edd86a232319e147507d73e766ab" translate="yes" xml:space="preserve">
          <source>Tests are Rust functions that verify that the non-test code is functioning in the expected manner. The bodies of test functions typically perform these three actions:</source>
          <target state="translated">テストは、テスト以外のコードが期待通りに機能しているかどうかを検証する Rust 関数です。テスト関数の本体は、通常、以下の3つのアクションを実行します。</target>
        </trans-unit>
        <trans-unit id="9557b92aa71fea3ff4e10ad5c651a01d327198f2" translate="yes" xml:space="preserve">
          <source>Tests if &lt;code&gt;person&lt;/code&gt; has the &lt;code&gt;car&lt;/code&gt; field filled with something.</source>
          <target state="translated">&lt;code&gt;person&lt;/code&gt; が何かで満たされた &lt;code&gt;car&lt;/code&gt; フィールドを持っているかどうかをテストします。</target>
        </trans-unit>
        <trans-unit id="21b62ab2004ca1232d413d8d665d134b12791482" translate="yes" xml:space="preserve">
          <source>Tests if any element of the iterator matches a predicate.</source>
          <target state="translated">イテレータのいずれかの要素が述語にマッチするかどうかをテストします。</target>
        </trans-unit>
        <trans-unit id="10d2dce236b59fb61d9321a2651527964d17f562" translate="yes" xml:space="preserve">
          <source>Tests if any element of the iterator matches a predicate. &lt;a href=&quot;../../../iter/trait.iterator#method.any&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">イテレータのいずれかの要素が述語と一致するかどうかをテストします。&lt;a href=&quot;../../../iter/trait.iterator#method.any&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="209ac04cb187d92f123ce6700c9444025e5580b3" translate="yes" xml:space="preserve">
          <source>Tests if any element of the iterator matches a predicate. &lt;a href=&quot;../../iter/trait.iterator#method.any&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">イテレータのいずれかの要素が述語と一致するかどうかをテストします。&lt;a href=&quot;../../iter/trait.iterator#method.any&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="80ec10f423a5beaec1ab62efd9e4031e5aaa4a11" translate="yes" xml:space="preserve">
          <source>Tests if any element of the iterator matches a predicate. &lt;a href=&quot;../iter/trait.iterator#method.any&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">イテレータのいずれかの要素が述語と一致するかどうかをテストします。&lt;a href=&quot;../iter/trait.iterator#method.any&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="760ae5105c89912ab7a036138a76c59ddfecc44b" translate="yes" xml:space="preserve">
          <source>Tests if any element of the iterator matches a predicate. &lt;a href=&quot;iter/trait.iterator#method.any&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">イテレータのいずれかの要素が述語と一致するかどうかをテストします。&lt;a href=&quot;iter/trait.iterator#method.any&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="df440409ef320551129c77bcadb79c6c4ba84e37" translate="yes" xml:space="preserve">
          <source>Tests if any element of the iterator matches a predicate. &lt;a href=&quot;trait.iterator#method.any&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">イテレータのいずれかの要素が述語と一致するかどうかをテストします。&lt;a href=&quot;trait.iterator#method.any&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="42f540ef5575b87eda1bc58cc8c893cf2e3e2964" translate="yes" xml:space="preserve">
          <source>Tests if every element of the iterator matches a predicate.</source>
          <target state="translated">イテレータの各要素が述語にマッチするかどうかをテストします。</target>
        </trans-unit>
        <trans-unit id="52e69927724e46dd631e47a69a4f2cdc74a668ca" translate="yes" xml:space="preserve">
          <source>Tests if every element of the iterator matches a predicate. &lt;a href=&quot;../../../iter/trait.iterator#method.all&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">イテレータのすべての要素が述語と一致するかどうかをテストします。&lt;a href=&quot;../../../iter/trait.iterator#method.all&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c572c6f114e3b7b0e63531ab8e78116f0d5ac5de" translate="yes" xml:space="preserve">
          <source>Tests if every element of the iterator matches a predicate. &lt;a href=&quot;../../iter/trait.iterator#method.all&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">イテレータのすべての要素が述語と一致するかどうかをテストします。&lt;a href=&quot;../../iter/trait.iterator#method.all&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a987e1ebbc5dd44d57ed09974bfdcc0f02c47b55" translate="yes" xml:space="preserve">
          <source>Tests if every element of the iterator matches a predicate. &lt;a href=&quot;../iter/trait.iterator#method.all&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">イテレータのすべての要素が述語と一致するかどうかをテストします。&lt;a href=&quot;../iter/trait.iterator#method.all&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="74b456b0054dd24ca1a515d72ae7f4e5367d4633" translate="yes" xml:space="preserve">
          <source>Tests if every element of the iterator matches a predicate. &lt;a href=&quot;iter/trait.iterator#method.all&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">イテレータのすべての要素が述語と一致するかどうかをテストします。&lt;a href=&quot;iter/trait.iterator#method.all&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="92be4e62f1c703e57b0a705c84b8aca1511558d2" translate="yes" xml:space="preserve">
          <source>Tests if every element of the iterator matches a predicate. &lt;a href=&quot;trait.iterator#method.all&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">イテレータのすべての要素が述語と一致するかどうかをテストします。&lt;a href=&quot;trait.iterator#method.all&quot;&gt;続きを読む&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6ebc400fe5bb7d000d0d73f12e63cdedd3140090" translate="yes" xml:space="preserve">
          <source>Tests if the person's &lt;code&gt;age&lt;/code&gt; field is between 13 and 19, and binds its value to the &lt;code&gt;person_age&lt;/code&gt; variable.</source>
          <target state="translated">人物の &lt;code&gt;age&lt;/code&gt; フィールドが13から19の間であるかどうかをテストし、その値を &lt;code&gt;person_age&lt;/code&gt; 変数にバインドします。</target>
        </trans-unit>
        <trans-unit id="13e062493861ff1e884762affb6f292d7aaa95d6" translate="yes" xml:space="preserve">
          <source>Tests that return &lt;code&gt;()&lt;/code&gt; pass as long as they terminate and do not panic. Tests that return a &lt;code&gt;Result&amp;lt;(), E&amp;gt;&lt;/code&gt; pass as long as they return &lt;code&gt;Ok(())&lt;/code&gt;. Tests that do not terminate neither pass nor fail.</source>
          <target state="translated">&lt;code&gt;()&lt;/code&gt; を返すテストは、終了してパニックにならない限り成功します。 &lt;code&gt;Result&amp;lt;(), E&amp;gt;&lt;/code&gt; を返すテストは、 &lt;code&gt;Ok(())&lt;/code&gt; を返す限り成功します。終了も失敗もしないテスト。</target>
        </trans-unit>
        <trans-unit id="240e8d8b35fd6dbae3889295d03396f4179097df" translate="yes" xml:space="preserve">
          <source>Tests that use &lt;code&gt;should_panic&lt;/code&gt; can be imprecise because they only indicate that the code has caused some panic. A &lt;code&gt;should_panic&lt;/code&gt; test would pass even if the test panics for a different reason from the one we were expecting to happen. To make &lt;code&gt;should_panic&lt;/code&gt; tests more precise, we can add an optional &lt;code&gt;expected&lt;/code&gt; parameter to the &lt;code&gt;should_panic&lt;/code&gt; attribute. The test harness will make sure that the failure message contains the provided text. For example, consider the modified code for &lt;code&gt;Guess&lt;/code&gt; in Listing 11-9 where the &lt;code&gt;new&lt;/code&gt; function panics with different messages depending on whether the value is too small or too large.</source>
          <target state="translated">&lt;code&gt;should_panic&lt;/code&gt; を使用するテストは、コードがパニックを引き起こしたことを示すだけなので、不正確になる可能性があります。 &lt;code&gt;should_panic&lt;/code&gt; テストでも、我々が起こることを期待していたものとは異なる理由のためのテスト・パニック場合を渡します。作るために &lt;code&gt;should_panic&lt;/code&gt; テストをより正確に、我々はオプションを追加することができ &lt;code&gt;expected&lt;/code&gt; にパラメータを &lt;code&gt;should_panic&lt;/code&gt; 属性。テストハーネスは、失敗メッセージに提供されたテキストが含まれていることを確認します。たとえば、値が小さすぎるか大きすぎるかに応じて、 &lt;code&gt;new&lt;/code&gt; 関数が異なるメッセージでパニックになるリスト11-9の &lt;code&gt;Guess&lt;/code&gt; の変更されたコードを考えてみます。</target>
        </trans-unit>
        <trans-unit id="6bb384831446531aa67968092446024f5dcdae5e" translate="yes" xml:space="preserve">
          <source>Tests whether this file type represents a directory. The result is mutually exclusive to the results of &lt;a href=&quot;struct.filetype#method.is_file&quot;&gt;&lt;code&gt;is_file&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.filetype#method.is_symlink&quot;&gt;&lt;code&gt;is_symlink&lt;/code&gt;&lt;/a&gt;; only zero or one of these tests may pass.</source>
          <target state="translated">このファイルタイプがディレクトリを表すかどうかをテストします。結果は、&lt;a href=&quot;struct.filetype#method.is_file&quot;&gt; &lt;code&gt;is_file&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;struct.filetype#method.is_symlink&quot;&gt; &lt;code&gt;is_symlink&lt;/code&gt; &lt;/a&gt;の結果と相互に排他的です。これらのテストの0または1つのみが合格する可能性があります。</target>
        </trans-unit>
        <trans-unit id="47c7f108fa56b78dae837cfbc2c1b6e6d82a8892" translate="yes" xml:space="preserve">
          <source>Tests whether this file type represents a regular file. The result is mutually exclusive to the results of &lt;a href=&quot;struct.filetype#method.is_dir&quot;&gt;&lt;code&gt;is_dir&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.filetype#method.is_symlink&quot;&gt;&lt;code&gt;is_symlink&lt;/code&gt;&lt;/a&gt;; only zero or one of these tests may pass.</source>
          <target state="translated">このファイルタイプが通常のファイルを表すかどうかをテストします。結果は、&lt;a href=&quot;struct.filetype#method.is_dir&quot;&gt; &lt;code&gt;is_dir&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;struct.filetype#method.is_symlink&quot;&gt; &lt;code&gt;is_symlink&lt;/code&gt; &lt;/a&gt;の結果と相互に排他的です。これらのテストの0または1つのみが合格する可能性があります。</target>
        </trans-unit>
        <trans-unit id="8e2618283b789dcbc952fac3457682ad9646a29b" translate="yes" xml:space="preserve">
          <source>Tests whether this file type represents a symbolic link. The result is mutually exclusive to the results of &lt;a href=&quot;struct.filetype#method.is_dir&quot;&gt;&lt;code&gt;is_dir&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.filetype#method.is_file&quot;&gt;&lt;code&gt;is_file&lt;/code&gt;&lt;/a&gt;; only zero or one of these tests may pass.</source>
          <target state="translated">このファイルタイプがシンボリックリンクを表すかどうかをテストします。結果は、&lt;a href=&quot;struct.filetype#method.is_dir&quot;&gt; &lt;code&gt;is_dir&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;struct.filetype#method.is_file&quot;&gt; &lt;code&gt;is_file&lt;/code&gt; &lt;/a&gt;の結果と相互に排他的です。これらのテストの0または1つのみが合格する可能性があります。</target>
        </trans-unit>
        <trans-unit id="24e8ed91cce37f2bfddb7d0a6e1b5b5dd3e13c8b" translate="yes" xml:space="preserve">
          <source>Text directionality</source>
          <target state="translated">テキストの方向性</target>
        </trans-unit>
        <trans-unit id="ece7c96ceb6b3c2888b8a50e4cc0084fdd3cc5ad" translate="yes" xml:space="preserve">
          <source>Textual Scope</source>
          <target state="translated">テキストの範囲</target>
        </trans-unit>
        <trans-unit id="f351ed281e01f153c5130339693bdde4a4318e5b" translate="yes" xml:space="preserve">
          <source>Textual representation</source>
          <target state="translated">テキスト表現</target>
        </trans-unit>
        <trans-unit id="50a53707975aa4e011ef0d8fc19d6a0815b5a0af" translate="yes" xml:space="preserve">
          <source>Textual scope is based largely on the order that things appear in source files, and works similarly to the scope of local variables declared with &lt;code&gt;let&lt;/code&gt; except it also applies at the module level. When &lt;code&gt;macro_rules!&lt;/code&gt; is used to define a macro, the macro enters the scope after the definition (note that it can still be used recursively, since names are looked up from the invocation site), up until its surrounding scope, typically a module, is closed. This can enter child modules and even span across multiple files:</source>
          <target state="translated">テキストスコープは、ソースファイルに出現する順序に主に基づいており、モジュールレベルでも適用されることを除いて、 &lt;code&gt;let&lt;/code&gt; で宣言されたローカル変数のスコープと同様に機能します。ときに &lt;code&gt;macro_rules!&lt;/code&gt; マクロを定義するために使用する場合、マクロは定義の後にスコープに入ります（名前は呼び出しサイトから検索されるため、再帰的に使用できることに注意してください）。その周囲のスコープ（通常はモジュール）が閉じられるまで。これは子モジュールに入り、複数のファイルにまたがることができます：</target>
        </trans-unit>
        <trans-unit id="3250cb346f89521461c9526f4b4c9e22ab7dec1d" translate="yes" xml:space="preserve">
          <source>Textual types</source>
          <target state="translated">テキストタイプ</target>
        </trans-unit>
        <trans-unit id="43b22d6c26a5be334da039abbdd3a863691ba7f8" translate="yes" xml:space="preserve">
          <source>Thankfully, you won't need to worry about upholding this property when deriving both &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;Hash&lt;/code&gt; with &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt;.</source>
          <target state="translated">ありがたいことに、あなたは両方の導出時に、このプロパティを擁護心配する必要はありません&lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt;や &lt;code&gt;Hash&lt;/code&gt; して &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d87603b9cd3744161580179aa52163b0ef139449" translate="yes" xml:space="preserve">
          <source>Thanks to static lifetime elision, you usually don't have to explicitly use 'static:</source>
          <target state="translated">static lifetime elision のおかげで、通常は明示的に 'static' を使う必要はありません。</target>
        </trans-unit>
        <trans-unit id="ccd80fa4141d21f8d736b44824bc5d805727e80f" translate="yes" xml:space="preserve">
          <source>Thanks to static lifetime elision, you usually don't have to explicitly use &lt;code&gt;'static&lt;/code&gt;:</source>
          <target state="translated">静的なライフタイムエリジオンのおかげで、通常は明示的に &lt;code&gt;'static&lt;/code&gt; を使用する必要はありません：</target>
        </trans-unit>
        <trans-unit id="9bdae0de8a5a5798d4caf783e96f237ed5528f2b" translate="yes" xml:space="preserve">
          <source>Thanks to this process, you can always check out the next build of Rust and verify for yourself that it&amp;rsquo;s easy to upgrade to: if a beta release doesn&amp;rsquo;t work as expected, you can report it to the team and get it fixed before the next stable release happens! Breakage in a beta release is relatively rare, but &lt;code&gt;rustc&lt;/code&gt; is still a piece of software, and bugs do exist.</source>
          <target state="translated">このプロセスのおかげで、いつでもRustの次のビルドをチェックアウトして、簡単にアップグレードできることを確認できます。ベータリリースが期待どおりに機能しない場合は、チームに報告して修正することができます。次の安定版リリースが起こります！ベータリリースでの破損は比較的まれですが、 &lt;code&gt;rustc&lt;/code&gt; はまだソフトウェアの一部であり、バグが存在します。</target>
        </trans-unit>
        <trans-unit id="93b38f3306b86b6513f0666ee48835c2b21219b2" translate="yes" xml:space="preserve">
          <source>That first part is done by us: when we call &lt;code&gt;String::from&lt;/code&gt;, its implementation requests the memory it needs. This is pretty much universal in programming languages.</source>
          <target state="translated">最初の部分は私たちが実行します &lt;code&gt;String::from&lt;/code&gt; を呼び出すと、その実装は必要なメモリを要求します。これはプログラミング言語ではかなり普遍的です。</target>
        </trans-unit>
        <trans-unit id="1348e5b21c821f227473000afcbce413f66d2f49" translate="yes" xml:space="preserve">
          <source>That is, for each element &lt;code&gt;a&lt;/code&gt; and its following element &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;a &amp;lt;= b&lt;/code&gt; must hold. If the iterator yields exactly zero or one element, &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="translated">つまり、各要素 &lt;code&gt;a&lt;/code&gt; とそれに続く要素 &lt;code&gt;b&lt;/code&gt; について、 &lt;code&gt;a &amp;lt;= b&lt;/code&gt; が成り立つ必要があります。イテレータが正確にゼロまたは1つの要素を生成する場合、 &lt;code&gt;true&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="bf20cf0a5a4308c50df24aa720ae0a415bab9777" translate="yes" xml:space="preserve">
          <source>That is, for each element &lt;code&gt;a&lt;/code&gt; and its following element &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;a &amp;lt;= b&lt;/code&gt; must hold. If the slice yields exactly zero or one element, &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="translated">つまり、各要素 &lt;code&gt;a&lt;/code&gt; とそれに続く要素 &lt;code&gt;b&lt;/code&gt; について、 &lt;code&gt;a &amp;lt;= b&lt;/code&gt; が成り立つ必要があります。スライスが正確にゼロまたは1つの要素を生成する場合、 &lt;code&gt;true&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="6141d9d942518cd742366c4e9a373eaeca5ba99a" translate="yes" xml:space="preserve">
          <source>That number of bytes is always between 1 and 4, inclusive.</source>
          <target state="translated">そのバイト数は、常に1から4の間にあります。</target>
        </trans-unit>
        <trans-unit id="5636ef2e6fa0c7ceabc2956a6a83de732290f283" translate="yes" xml:space="preserve">
          <source>That said, leaking resources such as memory or I/O objects is usually undesirable, so &lt;code&gt;forget&lt;/code&gt; is only recommended for specialized use cases like those shown below.</source>
          <target state="translated">とはいえ、メモリやI / Oオブジェクトなどのリソースのリークは通常望ましくないため、 &lt;code&gt;forget&lt;/code&gt; は以下に示すような特殊なユースケースにのみ推奨されます。</target>
        </trans-unit>
        <trans-unit id="bb0090f499faa8dbbaeb7f14d05f8e092483990d" translate="yes" xml:space="preserve">
          <source>That said, leaking resources such as memory or I/O objects is usually undesirable. The need comes up in some specialized use cases for FFI or unsafe code, but even then, &lt;a href=&quot;struct.manuallydrop&quot;&gt;&lt;code&gt;ManuallyDrop&lt;/code&gt;&lt;/a&gt; is typically preferred.</source>
          <target state="translated">とはいえ、メモリやI / Oオブジェクトなどのリソースのリークは通常望ましくありません。FFIまたは安全でないコードのいくつかの特殊なユースケースで必要が生じますが、それでも、通常は&lt;a href=&quot;struct.manuallydrop&quot;&gt; &lt;code&gt;ManuallyDrop&lt;/code&gt; &lt;/a&gt;が推奨されます。</target>
        </trans-unit>
        <trans-unit id="44e204c683273a7064bf611cb21bf25b6a58ab5e" translate="yes" xml:space="preserve">
          <source>That said, the implementation should provide a correct estimation, because otherwise it would be a violation of the trait's protocol.</source>
          <target state="translated">そうでなければ形質のプロトコルに違反することになるので、実装は正しい推定値を提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="7bf3790580feeb3b9968c1d5ee569f07fe6dc889" translate="yes" xml:space="preserve">
          <source>That said, there is no wrong way to read this book. Read it however you feel helps you best.</source>
          <target state="translated">とはいえ、この本の読み方に間違いはありません。あなたはあなたが最高の助けになると感じても、それを読んでください。</target>
        </trans-unit>
        <trans-unit id="947746e61ef4047bc2347841bf565d094e7bdec0" translate="yes" xml:space="preserve">
          <source>That solves our problem! With only &lt;code&gt;s2&lt;/code&gt; valid, when it goes out of scope, it alone will free the memory, and we&amp;rsquo;re done.</source>
          <target state="translated">これで問題は解決しました！有効な &lt;code&gt;s2&lt;/code&gt; のみで、スコープから外れると、それだけでメモリが解放され、完了です。</target>
        </trans-unit>
        <trans-unit id="9ce801650086879dbc3fc82fa6315949a2552c96" translate="yes" xml:space="preserve">
          <source>That was a bit of a whirlwind tour of unwind safety, but for more information about unwind safety and how it applies to Rust, see an &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1236-stabilize-catch-panic.md&quot;&gt;associated RFC&lt;/a&gt;.</source>
          <target state="translated">これは、巻き戻しの安全性についてのちょっとしたツアーでしたが、巻き戻しの安全性とRustへの適用方法の詳細については、&lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1236-stabilize-catch-panic.md&quot;&gt;関連するRFCを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="92b56514bc3604cf70d965940d81ed28035240b2" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s 18 bytes and is how computers ultimately store this data. If we look at them as Unicode scalar values, which are what Rust&amp;rsquo;s &lt;code&gt;char&lt;/code&gt; type is, those bytes look like this:</source>
          <target state="translated">これは18バイトであり、コンピュータが最終的にこのデータを格納する方法です。Rustの &lt;code&gt;char&lt;/code&gt; 型であるUnicodeスカラー値としてそれらを見ると、これらのバイトは次のようになります。</target>
        </trans-unit>
        <trans-unit id="9fac4c3e9f71b06878dbbb47f3ce2814227f227f" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s a lot of &lt;code&gt;match&lt;/code&gt;! The &lt;code&gt;match&lt;/code&gt; expression is very useful but also very much a primitive. In Chapter 13, you&amp;rsquo;ll learn about closures; the &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; type has many methods that accept a closure and are implemented using &lt;code&gt;match&lt;/code&gt; expressions. Using those methods will make your code more concise. A more seasoned Rustacean might write this code instead of Listing 9-5:</source>
          <target state="translated">それはたくさんの &lt;code&gt;match&lt;/code&gt; です！ &lt;code&gt;match&lt;/code&gt; 式は非常に便利なだけでなく、非常に原始的です。第13章では、クロージャーについて学びます。 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 型が閉鎖を受け入れ、使用して実装されている多くの方法がある &lt;code&gt;match&lt;/code&gt; 式を。これらのメソッドを使用すると、コードがより簡潔になります。より熟練したRustaceanはリスト9-5の代わりにこのコードを書くかもしれません：</target>
        </trans-unit>
        <trans-unit id="ef238338d4e12acdba68729fda27f2648f9a373c" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s a lot of output! The exact output you see might be different depending on your operating system and Rust version. In order to get backtraces with this information, debug symbols must be enabled. Debug symbols are enabled by default when using &lt;code&gt;cargo build&lt;/code&gt; or &lt;code&gt;cargo run&lt;/code&gt; without the &lt;code&gt;--release&lt;/code&gt; flag, as we have here.</source>
          <target state="translated">それは大量の出力です！表示される正確な出力は、オペレーティングシステムとRustのバージョンによって異なる場合があります。この情報でバックトレースを取得するには、デバッグシンボルを有効にする必要があります。ここにあるように、 &lt;code&gt;--release&lt;/code&gt; フラグなしで &lt;code&gt;cargo build&lt;/code&gt; または &lt;code&gt;cargo run&lt;/code&gt; を使用すると、デバッグシンボルはデフォルトで有効になります。</target>
        </trans-unit>
        <trans-unit id="1b9244a451d65d27f90f013b616e273e2c23a8a2" translate="yes" xml:space="preserve">
          <source>That's it! Let's dig into iterators.</source>
          <target state="translated">これだ!イテレータを掘り下げてみましょう。</target>
        </trans-unit>
        <trans-unit id="061168032f743f39ddf71cf9c7a9d9f5d6f181f3" translate="yes" xml:space="preserve">
          <source>The &quot;default&quot; usage of this type as a queue is to use &lt;a href=&quot;#method.push_back&quot;&gt;&lt;code&gt;push_back&lt;/code&gt;&lt;/a&gt; to add to the queue, and &lt;a href=&quot;#method.pop_front&quot;&gt;&lt;code&gt;pop_front&lt;/code&gt;&lt;/a&gt; to remove from the queue. &lt;a href=&quot;#method.extend&quot;&gt;&lt;code&gt;extend&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.append&quot;&gt;&lt;code&gt;append&lt;/code&gt;&lt;/a&gt; push onto the back in this manner, and iterating over &lt;code&gt;VecDeque&lt;/code&gt; goes front to back.</source>
          <target state="translated">キューとしてこのタイプの「デフォルト」の使用は、使用することです&lt;a href=&quot;#method.push_back&quot;&gt; &lt;code&gt;push_back&lt;/code&gt; &lt;/a&gt;キューに追加する、と&lt;a href=&quot;#method.pop_front&quot;&gt; &lt;code&gt;pop_front&lt;/code&gt; を&lt;/a&gt;キューから削除します。&lt;a href=&quot;#method.extend&quot;&gt; &lt;code&gt;extend&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;#method.append&quot;&gt; &lt;code&gt;append&lt;/code&gt; &lt;/a&gt;プッシュをバックに、このように、とを反復 &lt;code&gt;VecDeque&lt;/code&gt; は背面にフロントに行きます。</target>
        </trans-unit>
        <trans-unit id="e1996b7a38e8030e5ba09e25339c72996ff81148" translate="yes" xml:space="preserve">
          <source>The &quot;default&quot; usage of this type as a queue is to use &lt;a href=&quot;../struct.vecdeque#method.push_back&quot;&gt;&lt;code&gt;push_back&lt;/code&gt;&lt;/a&gt; to add to the queue, and &lt;a href=&quot;../struct.vecdeque#method.pop_front&quot;&gt;&lt;code&gt;pop_front&lt;/code&gt;&lt;/a&gt; to remove from the queue. &lt;a href=&quot;../struct.vecdeque#method.extend&quot;&gt;&lt;code&gt;extend&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../struct.vecdeque#method.append&quot;&gt;&lt;code&gt;append&lt;/code&gt;&lt;/a&gt; push onto the back in this manner, and iterating over &lt;code&gt;VecDeque&lt;/code&gt; goes front to back.</source>
          <target state="translated">キューとしてこのタイプの「デフォルト」の使用は、使用することです&lt;a href=&quot;../struct.vecdeque#method.push_back&quot;&gt; &lt;code&gt;push_back&lt;/code&gt; &lt;/a&gt;キューに追加する、と&lt;a href=&quot;../struct.vecdeque#method.pop_front&quot;&gt; &lt;code&gt;pop_front&lt;/code&gt; を&lt;/a&gt;キューから削除します。この方法でプッシュを&lt;a href=&quot;../struct.vecdeque#method.extend&quot;&gt; &lt;code&gt;extend&lt;/code&gt; &lt;/a&gt;して背面に&lt;a href=&quot;../struct.vecdeque#method.append&quot;&gt; &lt;code&gt;append&lt;/code&gt; &lt;/a&gt;すると、 &lt;code&gt;VecDeque&lt;/code&gt; を反復処理して前面から背面に移動します。</target>
        </trans-unit>
        <trans-unit id="6e8660a906a07f3cb76ce3714efc3b35a643f54a" translate="yes" xml:space="preserve">
          <source>The &quot;default&quot; usage of this type as a queue is to use &lt;a href=&quot;struct.vecdeque#method.push_back&quot;&gt;&lt;code&gt;push_back&lt;/code&gt;&lt;/a&gt; to add to the queue, and &lt;a href=&quot;struct.vecdeque#method.pop_front&quot;&gt;&lt;code&gt;pop_front&lt;/code&gt;&lt;/a&gt; to remove from the queue. &lt;a href=&quot;struct.vecdeque#method.extend&quot;&gt;&lt;code&gt;extend&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.vecdeque#method.append&quot;&gt;&lt;code&gt;append&lt;/code&gt;&lt;/a&gt; push onto the back in this manner, and iterating over &lt;code&gt;VecDeque&lt;/code&gt; goes front to back.</source>
          <target state="translated">キューとしてこのタイプの「デフォルト」の使用は、使用することです&lt;a href=&quot;struct.vecdeque#method.push_back&quot;&gt; &lt;code&gt;push_back&lt;/code&gt; &lt;/a&gt;キューに追加する、と&lt;a href=&quot;struct.vecdeque#method.pop_front&quot;&gt; &lt;code&gt;pop_front&lt;/code&gt; を&lt;/a&gt;キューから削除します。この方法でプッシュを&lt;a href=&quot;struct.vecdeque#method.extend&quot;&gt; &lt;code&gt;extend&lt;/code&gt; &lt;/a&gt;して背面に&lt;a href=&quot;struct.vecdeque#method.append&quot;&gt; &lt;code&gt;append&lt;/code&gt; &lt;/a&gt;すると、 &lt;code&gt;VecDeque&lt;/code&gt; を反復処理して前面から背面に移動します。</target>
        </trans-unit>
        <trans-unit id="01cb9e838bce9598fdfd4c3684f101808c1294f8" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;Advanced Lifetimes&amp;rdquo; section in Chapter 19 was removed because compiler improvements have made the constructs in that section even rarer.</source>
          <target state="translated">第19章の「AdvancedLifetimes」セクションは、コンパイラの改善によりそのセクションの構成がさらにまれになったため、削除されました。</target>
        </trans-unit>
        <trans-unit id="36f389fc23a4edc2c2a963efce47f9899bcc8519" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;Advanced Lifetimes&amp;rdquo; section of Chapter 19 was removed because compiler improvements have made the constructs in that section even rarer.</source>
          <target state="translated">第19章の「高度なライフタイム」セクションは、コンパイラの改善によりそのセクションの構成がさらに希薄になったため削除されました。</target>
        </trans-unit>
        <trans-unit id="f99557dc0a8fdf7a63f0792d647f548b4ff6f7ab" translate="yes" xml:space="preserve">
          <source>The 128-bit signed integer type.</source>
          <target state="translated">128ビット符号付き整数型。</target>
        </trans-unit>
        <trans-unit id="2ecb830f3b64176d279185c7c171382698dc346b" translate="yes" xml:space="preserve">
          <source>The 128-bit unsigned integer type.</source>
          <target state="translated">128ビットの符号なし整数型。</target>
        </trans-unit>
        <trans-unit id="024e734140c83218cfd913643692a04c708db5ec" translate="yes" xml:space="preserve">
          <source>The 16-bit signed integer type.</source>
          <target state="translated">16ビット符号付き整数型。</target>
        </trans-unit>
        <trans-unit id="c45d15aa8a84f450baba97f342935672e6fa7c43" translate="yes" xml:space="preserve">
          <source>The 16-bit unsigned integer type.</source>
          <target state="translated">16ビットの符号なし整数型。</target>
        </trans-unit>
        <trans-unit id="fca5433f25a52ee7287767b1930704d918391065" translate="yes" xml:space="preserve">
          <source>The 2015 edition does not allow use declarations to reference the &lt;a href=&quot;extern-crates#extern-prelude&quot;&gt;extern prelude&lt;/a&gt;. Thus &lt;a href=&quot;extern-crates&quot;&gt;&lt;code&gt;extern crate&lt;/code&gt;&lt;/a&gt; declarations are still required in 2015 to reference an external crate in a use declaration. Beginning with the 2018 edition, use declarations can specify an external crate dependency the same way &lt;code&gt;extern crate&lt;/code&gt; can.</source>
          <target state="translated">2015年版では、使用宣言で&lt;a href=&quot;extern-crates#extern-prelude&quot;&gt;externプレリュード&lt;/a&gt;を参照することはできません。したがって、2015年には、use宣言で外部クレートを参照するために&lt;a href=&quot;extern-crates&quot;&gt; &lt;code&gt;extern crate&lt;/code&gt; &lt;/a&gt;宣言が引き続き必要です。2018年版以降、use宣言では、 &lt;code&gt;extern crate&lt;/code&gt; と同じ方法で外部crate依存関係を指定できます。</target>
        </trans-unit>
        <trans-unit id="b6d857578ac6c78bfa58339fa5a83d29b7a47348" translate="yes" xml:space="preserve">
          <source>The 2018 Edition of the Rust language includes a number of improvements that make Rust more ergonomic and easier to learn. This iteration of the book contains a number of changes to reflect those improvements:</source>
          <target state="translated">2018年版のRust言語には、Rustをより人間工学的で学習しやすいものにするための多くの改善が含まれています。この改訂版では、それらの改善を反映させるために多くの変更が加えられています。</target>
        </trans-unit>
        <trans-unit id="26b6de1c048ad3b08c5d50eb1e62ebf661747fc3" translate="yes" xml:space="preserve">
          <source>The 2018 Edition of the Rust language includes a number of improvements that make Rust more ergonomic and easier to learn. This printing of the book contains a number of changes to reflect those improvements:</source>
          <target state="translated">2018年版のRust言語には、Rustをより人間工学的に学びやすくするための多くの改善点が含まれています。この印刷版では、それらの改善点を反映するために多くの変更点が含まれています。</target>
        </trans-unit>
        <trans-unit id="2c35b45536addab0f127b7ef2a73381bf5aab740" translate="yes" xml:space="preserve">
          <source>The 32-bit floating point type.</source>
          <target state="translated">32ビット浮動小数点型です。</target>
        </trans-unit>
        <trans-unit id="ede6acb001e744d94e80e43f20515bed53288286" translate="yes" xml:space="preserve">
          <source>The 32-bit signed integer type.</source>
          <target state="translated">32ビット符号付き整数型。</target>
        </trans-unit>
        <trans-unit id="a9e99a82ec2d26441031e5f8781a5ebb65a83e0e" translate="yes" xml:space="preserve">
          <source>The 32-bit unsigned integer type.</source>
          <target state="translated">32ビット符号なし整数型。</target>
        </trans-unit>
        <trans-unit id="13cb697c6b75c7757e9c51749eb9c614ddc9a70f" translate="yes" xml:space="preserve">
          <source>The 64-bit floating point type.</source>
          <target state="translated">64ビットの浮動小数点型です。</target>
        </trans-unit>
        <trans-unit id="748e7d28f53e7a36937bb25af3f1a76e6a491ad6" translate="yes" xml:space="preserve">
          <source>The 64-bit signed integer type.</source>
          <target state="translated">64ビット符号付き整数型。</target>
        </trans-unit>
        <trans-unit id="25aeddd62dc36790a2166200538648d83779c0d0" translate="yes" xml:space="preserve">
          <source>The 64-bit unsigned integer type.</source>
          <target state="translated">64ビットの符号なし整数型です。</target>
        </trans-unit>
        <trans-unit id="0825a8c90a6add467ca53950b645a26af9033007" translate="yes" xml:space="preserve">
          <source>The 8-bit signed integer type.</source>
          <target state="translated">8ビット符号付き整数型。</target>
        </trans-unit>
        <trans-unit id="6d1f46b751b47e95357a0c40c6e78729c3531e1e" translate="yes" xml:space="preserve">
          <source>The 8-bit unsigned integer type.</source>
          <target state="translated">8ビットの符号なし整数型。</target>
        </trans-unit>
        <trans-unit id="b568b58db2fe5b477d28998d21858de250eecb32" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#method.clone&quot;&gt;&lt;code&gt;Arc::clone(&amp;amp;from)&lt;/code&gt;&lt;/a&gt; syntax is the most idiomatic because it conveys more explicitly the meaning of the code. In the example above, this syntax makes it easier to see that this code is creating a new reference rather than copying the whole content of foo.</source>
          <target state="translated">&lt;a href=&quot;#method.clone&quot;&gt; &lt;code&gt;Arc::clone(&amp;amp;from)&lt;/code&gt; &lt;/a&gt;、それがより明確にコードの意味を伝えるための構文は、最も慣用的です。上記の例では、この構文により、このコードがfooのコンテンツ全体をコピーするのではなく、新しい参照を作成していることが簡単にわかります。</target>
        </trans-unit>
        <trans-unit id="fd0354b8e891bd703f8ef8a8ce8547a17dc2e4cc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#method.connect&quot;&gt;&lt;code&gt;connect&lt;/code&gt;&lt;/a&gt; method will connect the socket to a peer.</source>
          <target state="translated">&lt;a href=&quot;#method.connect&quot;&gt; &lt;code&gt;connect&lt;/code&gt; &lt;/a&gt;方法は、ピアへのソケットを接続します。</target>
        </trans-unit>
        <trans-unit id="de66ae551d77056e5d10cff2c3fd9dbcc9b63e6e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#method.connect&quot;&gt;&lt;code&gt;connect&lt;/code&gt;&lt;/a&gt; method will connect this socket to a remote address. This method will fail if the socket is not connected.</source>
          <target state="translated">&lt;a href=&quot;#method.connect&quot;&gt; &lt;code&gt;connect&lt;/code&gt; &lt;/a&gt;方法は、リモートアドレスにこのソケットを接続します。ソケットが接続されていない場合、このメソッドは失敗します。</target>
        </trans-unit>
        <trans-unit id="3822ea1855bf914e5a814986732fc459619fc61c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#method.drain&quot;&gt;&lt;code&gt;drain&lt;/code&gt;&lt;/a&gt; method can emulate &lt;code&gt;truncate&lt;/code&gt;, but causes the excess elements to be returned instead of dropped.</source>
          <target state="translated">&lt;a href=&quot;#method.drain&quot;&gt; &lt;code&gt;drain&lt;/code&gt; &lt;/a&gt;方法がエミュレートできる &lt;code&gt;truncate&lt;/code&gt; 、しかし返さ代わりに落下する過剰な要素を引き起こします。</target>
        </trans-unit>
        <trans-unit id="a9d6dbd0eeefdb718b7113fea8088d62bd58b0d7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; method has a default implementation, so you usually shouldn't implement it. However, you may be able to provide a more performant implementation than the default, so overriding it in this case makes sense.</source>
          <target state="translated">&lt;a href=&quot;#method.len&quot;&gt; &lt;code&gt;len&lt;/code&gt; &lt;/a&gt;方法は、デフォルトの実装を持っているので、あなたは、通常、それを実装するべきではありません。ただし、デフォルトよりもパフォーマンスの高い実装を提供できる場合があるため、この場合はオーバーライドするのが妥当です。</target>
        </trans-unit>
        <trans-unit id="dade93dc3cf6b97db5474305c3207f7c692d153c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; adapter is very useful, but only when the closure argument produces values. If it produces an iterator instead, there's an extra layer of indirection. &lt;code&gt;flat_map()&lt;/code&gt; will remove this extra layer on its own.</source>
          <target state="translated">&lt;a href=&quot;#method.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt;アダプタは非常に便利ですが、閉鎖引数には、値を生成する場合にのみ。代わりにイテレータを生成する場合は、追加の間接層があります。 &lt;code&gt;flat_map()&lt;/code&gt; は、この余分なレイヤーを単独で削除します。</target>
        </trans-unit>
        <trans-unit id="7a52c1262c15b7898ef7ba52e5c11aa28470cc03" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; method will actually check that the provided &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; does not have 0 bytes in the middle, and return an error if it finds one.</source>
          <target state="translated">&lt;a href=&quot;#method.new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt;方法は、実際に提供したことを確認します &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; 途中で0バイトを持っており、それがものを見つけた場合はエラーを返しません。</target>
        </trans-unit>
        <trans-unit id="156348d96d775ff156fee076f0f98b0084e3469d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; method may be used to send data to the specified address. &lt;a href=&quot;#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.recv_from&quot;&gt;&lt;code&gt;recv_from&lt;/code&gt;&lt;/a&gt; will only receive data from that address.</source>
          <target state="translated">&lt;a href=&quot;#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt;方法は、指定されたアドレスにデータを送信するために使用することができます。&lt;a href=&quot;#method.recv&quot;&gt; &lt;code&gt;recv&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;#method.recv_from&quot;&gt; &lt;code&gt;recv_from&lt;/code&gt; &lt;/a&gt;は、そのアドレスからのみデータを受信します。</target>
        </trans-unit>
        <trans-unit id="1ad11576c65e9334d7573beaf36142b4de74e09c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#primitive-representations&quot;&gt;primitive representations&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#primitive-representations&quot;&gt;原始的な表現&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ed6b3d78fe45feec8a5741e2a3ac93f1ed3a19d8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#tymethod.flush&quot;&gt;&lt;code&gt;flush&lt;/code&gt;&lt;/a&gt; method is useful for adaptors and explicit buffers themselves for ensuring that all buffered data has been pushed out to the 'true sink'.</source>
          <target state="translated">&lt;a href=&quot;#tymethod.flush&quot;&gt; &lt;code&gt;flush&lt;/code&gt; &lt;/a&gt;の方法は、アダプタと、すべてのバッファされたデータは、「真シンク」に押し出されていることを確実にするための明示的なバッファ自身のために有用です。</target>
        </trans-unit>
        <trans-unit id="8a62cb575b08d38c732e1bba9328976a264fdb19" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; method will attempt to write some data into the object, returning how many bytes were successfully written.</source>
          <target state="translated">&lt;a href=&quot;#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;方法は、正常に書き込まれたバイト数を返す、オブジェクトにいくつかのデータを書き込もうとします。</target>
        </trans-unit>
        <trans-unit id="8fcdedc3c9e84c7fa96e2530650c1bc070bc790b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../expressions/block-expr#async-blocks&quot;&gt;&lt;code&gt;async move&lt;/code&gt; block&lt;/a&gt; in the body captures all function parameters, including those that are unused or bound to a &lt;code&gt;_&lt;/code&gt; pattern. This ensures that function parameters are dropped in the same order as they would be if the function were not async, except that the drop occurs when the returned future has been fully awaited.</source>
          <target state="translated">本体の&lt;a href=&quot;../expressions/block-expr#async-blocks&quot;&gt; &lt;code&gt;async move&lt;/code&gt; ブロック&lt;/a&gt;は、未使用または &lt;code&gt;_&lt;/code&gt; パターンにバインドされているものを含むすべての関数パラメーターをキャプチャします。これにより、関数のパラメーターが、関数が非同期でない場合と同じ順序でドロップされるようになります。ただし、返されるfutureが完全に待機されたときにドロップが発生する点が異なります。</target>
        </trans-unit>
        <trans-unit id="c78f52a30365dea52628c4ade488db0345ffa3ac" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../macro.eprint&quot;&gt;&lt;code&gt;eprint!&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../macro.eprintln&quot;&gt;&lt;code&gt;eprintln!&lt;/code&gt;&lt;/a&gt; macros are identical to &lt;a href=&quot;../macro.print&quot;&gt;&lt;code&gt;print!&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../macro.println&quot;&gt;&lt;code&gt;println!&lt;/code&gt;&lt;/a&gt;, respectively, except they emit their output to stderr.</source>
          <target state="translated">&lt;a href=&quot;../macro.eprint&quot;&gt; &lt;code&gt;eprint!&lt;/code&gt; &lt;/a&gt;そして&lt;a href=&quot;../macro.eprintln&quot;&gt; &lt;code&gt;eprintln!&lt;/code&gt; &lt;/a&gt;マクロは&lt;a href=&quot;../macro.print&quot;&gt; &lt;code&gt;print!&lt;/code&gt; &lt;/a&gt;と同じです！そして&lt;a href=&quot;../macro.println&quot;&gt; &lt;code&gt;println!&lt;/code&gt; &lt;/a&gt;それぞれ、出力をstderrに出力する点を除きます。</target>
        </trans-unit>
        <trans-unit id="15b30e899910805c24344f039598ed4f0cfd76f0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../macro.format&quot;&gt;&lt;code&gt;format!&lt;/code&gt;&lt;/a&gt; macro is intended to be familiar to those coming from C's &lt;code&gt;printf&lt;/code&gt;/&lt;code&gt;fprintf&lt;/code&gt; functions or Python's &lt;code&gt;str.format&lt;/code&gt; function.</source>
          <target state="translated">&lt;a href=&quot;../macro.format&quot;&gt; &lt;code&gt;format!&lt;/code&gt; &lt;/a&gt;マクロは、Cの &lt;code&gt;printf&lt;/code&gt; / &lt;code&gt;fprintf&lt;/code&gt; 関数またはPythonの &lt;code&gt;str.format&lt;/code&gt; 関数に由来するものに慣れることを目的としています。</target>
        </trans-unit>
        <trans-unit id="5d076b83cf0704732b7b9eb8c03c4bfbdeaffd03" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../macro.format_args&quot;&gt;&lt;code&gt;format_args!&lt;/code&gt;&lt;/a&gt; macro will safely create an instance of this structure. The macro validates the format string at compile-time so usage of the &lt;a href=&quot;fn.write&quot;&gt;&lt;code&gt;write()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fn.format&quot;&gt;&lt;code&gt;format()&lt;/code&gt;&lt;/a&gt; functions can be safely performed.</source>
          <target state="translated">&lt;a href=&quot;../macro.format_args&quot;&gt; &lt;code&gt;format_args!&lt;/code&gt; &lt;/a&gt;マクロは、この構造のインスタンスを安全に作成します。マクロはコンパイル時にフォーマット文字列を検証するため、&lt;a href=&quot;fn.write&quot;&gt; &lt;code&gt;write()&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;fn.format&quot;&gt; &lt;code&gt;format()&lt;/code&gt; &lt;/a&gt;関数の使用を安全に実行できます。</target>
        </trans-unit>
        <trans-unit id="1da9aedd3913426ccb3cbeae460a449f6f18fc2d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../macro.format_args&quot;&gt;&lt;code&gt;format_args!&lt;/code&gt;&lt;/a&gt; macro will safely create an instance of this structure. The macro validates the format string at compile-time so usage of the &lt;a href=&quot;fn.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fn.format&quot;&gt;&lt;code&gt;format&lt;/code&gt;&lt;/a&gt; functions can be safely performed.</source>
          <target state="translated">&lt;a href=&quot;../macro.format_args&quot;&gt; &lt;code&gt;format_args!&lt;/code&gt; &lt;/a&gt;マクロはこの構造のインスタンスを安全に作成します。マクロはコンパイル時にフォーマット文字列を検証するため、&lt;a href=&quot;fn.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;fn.format&quot;&gt; &lt;code&gt;format&lt;/code&gt; &lt;/a&gt;関数の使用を安全に実行できます。</target>
        </trans-unit>
        <trans-unit id="d6220f58fc37e6b8b0afc01735948c86469d85de" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../macro.vec&quot;&gt;&lt;code&gt;vec!&lt;/code&gt;&lt;/a&gt; macro is provided to make initialization more convenient:</source>
          <target state="translated">&lt;a href=&quot;../macro.vec&quot;&gt; &lt;code&gt;vec!&lt;/code&gt; &lt;/a&gt;初期化をより便利にするためにマクロが提供されています。</target>
        </trans-unit>
        <trans-unit id="d6015eed300b7de406449e79cfdc1aa2f387182e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../macros-by-example#the-macro_use-attribute&quot;&gt;&lt;code&gt;macro_use&lt;/code&gt; attribute&lt;/a&gt; works as usual and import the macro names into the macro-use prelude.</source>
          <target state="translated">&lt;a href=&quot;../macros-by-example#the-macro_use-attribute&quot;&gt; &lt;code&gt;macro_use&lt;/code&gt; の属性は、&lt;/a&gt;いつものように動作し、マクロ使用の前奏曲にマクロ名をインポートします。</target>
        </trans-unit>
        <trans-unit id="3ee79a0bb859db06f06e2ddc850e161230b3ef29" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../marker/trait.send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt; constraint is because the closure will need to be passed &lt;em&gt;by value&lt;/em&gt; from the thread where it is spawned to the new thread. Its return value will need to be passed from the new thread to the thread where it is &lt;code&gt;join&lt;/code&gt;ed. As a reminder, the &lt;a href=&quot;../marker/trait.send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt; marker trait expresses that it is safe to be passed from thread to thread. &lt;a href=&quot;../marker/trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; expresses that it is safe to have a reference be passed from thread to thread.</source>
          <target state="translated">&lt;a href=&quot;../marker/trait.send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt;クロージャを渡す必要がありますので、制約がある&lt;em&gt;値によって&lt;/em&gt;それは新しいスレッドに起動されたスレッドから。その戻り値は、新しいスレッドから &lt;code&gt;join&lt;/code&gt; されるスレッドに渡される必要があります。注意として、&lt;a href=&quot;../marker/trait.send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt;マーカー特性は、スレッドからスレッドに渡しても安全であることを表しています。&lt;a href=&quot;../marker/trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt;は、参照がスレッド間で渡されることが安全であることを表します。</target>
        </trans-unit>
        <trans-unit id="9c69caf5cbc6ae5668ac370ea6aa28c0348ce679" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../paths&quot;&gt;path&lt;/a&gt; to an associated item is any path to the implementing type, followed by the associated item's identifier as the final path component.</source>
          <target state="translated">&lt;a href=&quot;../paths&quot;&gt;パス&lt;/a&gt;関連アイテムには、最終パス成分と関連するアイテムの識別子、続いて実装型のいずれかのパスです。</target>
        </trans-unit>
        <trans-unit id="1dedee4df1c883aa9e7db0132fc24154a02120fc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../pin/struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt; type is used instead to prevent moves through the type system. Pointers &lt;code&gt;P&amp;lt;T&amp;gt;&lt;/code&gt; wrapped in the &lt;a href=&quot;../pin/struct.pin&quot;&gt;&lt;code&gt;Pin&amp;lt;P&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;&lt;/a&gt; wrapper can't be moved out of. See the &lt;a href=&quot;../pin/index&quot;&gt;&lt;code&gt;pin&lt;/code&gt; module&lt;/a&gt; documentation for more information on pinning.</source>
          <target state="translated">&lt;a href=&quot;../pin/struct.pin&quot;&gt; &lt;code&gt;Pin&lt;/code&gt; &lt;/a&gt;型は、型システムを通って移動するのを防止するために代わりに使用されています。&lt;a href=&quot;../pin/struct.pin&quot;&gt; &lt;code&gt;Pin&amp;lt;P&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; &lt;/a&gt;ラッパーでラップされたポインター &lt;code&gt;P&amp;lt;T&amp;gt;&lt;/code&gt; は移動できません。&lt;a href=&quot;../pin/index&quot;&gt; &lt;code&gt;pin&lt;/code&gt; &lt;/a&gt;詳細については、ピンモジュールのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="a4c6d762c492370e5bdcdefde3e4fc5cf31a9b6e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../reference/items/unions&quot;&gt;Rust equivalent of a C-style union&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../reference/items/unions&quot;&gt;Cスタイルのunionと同等&lt;/a&gt;のRust。</target>
        </trans-unit>
        <trans-unit id="86cbe7690d77cc63e21bdfee9a1e9528110648c5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../reference/types/trait-object&quot;&gt;Reference&lt;/a&gt; has more information about trait objects, their limitations and the differences between editions.</source>
          <target state="translated">&lt;a href=&quot;../reference/types/trait-object&quot;&gt;リファレンスは、&lt;/a&gt;形質オブジェクト、それらの限界とエディションの違いについてより多くの情報を持っています。</target>
        </trans-unit>
        <trans-unit id="fb6f479476a4a73b474dd9bb423ce981f3c3f329" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt; variant of this result indicates that the primitive was not poisoned, and the &lt;code&gt;Guard&lt;/code&gt; is contained within. The &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; variant indicates that the primitive was poisoned. Note that the &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; variant &lt;em&gt;also&lt;/em&gt; carries the associated guard, and it can be acquired through the &lt;a href=&quot;struct.poisonerror#method.into_inner&quot;&gt;&lt;code&gt;into_inner&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">この結果の&lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt;バリアントは、プリミティブが毒されておらず、 &lt;code&gt;Guard&lt;/code&gt; が含まれていることを示しています。&lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;バリアントは、プリミティブが毒殺されたことを示しています。そのノート&lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;変異体は&lt;em&gt;また、&lt;/em&gt;関連するガードを運び、それはを通じて取得することができる&lt;a href=&quot;struct.poisonerror#method.into_inner&quot;&gt; &lt;code&gt;into_inner&lt;/code&gt; の&lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="79df059e358a4241ab821f0fe6e918cdbba9f208" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../std/clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; trait is a supertrait of &lt;code&gt;Copy&lt;/code&gt;, so it also needs compiler generated implementations. It is implemented by the compiler for the following types:</source>
          <target state="translated">&lt;a href=&quot;../std/clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt;のsupertraitある特色 &lt;code&gt;Copy&lt;/code&gt; 、ので、それはまた、コンパイラ生成の実装を必要とします。次のタイプのコンパイラーによって実装されます。</target>
        </trans-unit>
        <trans-unit id="90ba5aefe61d573b28b76d88a60eabe0413d5c63" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../std/marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; trait changes the semantics of a type implementing it. Values whose type implements &lt;code&gt;Copy&lt;/code&gt; are copied rather than moved upon assignment.</source>
          <target state="translated">&lt;a href=&quot;../std/marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;特性は、それを実装するタイプのセマンティクスを変更します。タイプがコピーを実装する値は、割り当て時に移動されるのではなく、 &lt;code&gt;Copy&lt;/code&gt; されます。</target>
        </trans-unit>
        <trans-unit id="eeefbcb93aa9d7429fc3ba4a3a1ce956f75d5cfc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../std/marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; trait changes the semantics of a type implementing it. Values whose type implements &lt;code&gt;Copy&lt;/code&gt; are copied rather than moved upon assignment. &lt;code&gt;Copy&lt;/code&gt; cannot be implemented for types which implement &lt;code&gt;Drop&lt;/code&gt;, or which have fields that are not &lt;code&gt;Copy&lt;/code&gt;. &lt;code&gt;Copy&lt;/code&gt; is implemented by the compiler for</source>
          <target state="translated">&lt;a href=&quot;../std/marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;特性は、それを実装するタイプのセマンティクスを変更します。タイプがコピーを実装する値は、割り当て時に移動されるのではなく &lt;code&gt;Copy&lt;/code&gt; されます。 &lt;code&gt;Drop&lt;/code&gt; を実装する型、または &lt;code&gt;Copy&lt;/code&gt; でないフィールドを持つ型には、 &lt;code&gt;Copy&lt;/code&gt; を実装できません。 &lt;code&gt;Copy&lt;/code&gt; は、コンパイラによって実装されます</target>
        </trans-unit>
        <trans-unit id="0e14c3a80117b6ea49358dfdccbdf20f1c51a89c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../std/marker/trait.send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt; trait indicates that a value of this type is safe to send from one thread to another.</source>
          <target state="translated">&lt;a href=&quot;../std/marker/trait.send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt;特性は、この型の値を別のスレッドから送信しても安全であることを示しています。</target>
        </trans-unit>
        <trans-unit id="974ae2ba65e9e772d3c59ca8b9d11adff4f54e38" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../std/marker/trait.send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../std/marker/trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../std/marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../std/panic/trait.unwindsafe&quot;&gt;&lt;code&gt;UnwindSafe&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../std/panic/trait.refunwindsafe&quot;&gt;&lt;code&gt;RefUnwindSafe&lt;/code&gt;&lt;/a&gt; traits are &lt;em&gt;auto traits&lt;/em&gt;. Auto traits have special properties.</source>
          <target state="translated">&lt;a href=&quot;../std/marker/trait.send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../std/marker/trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../std/marker/trait.unpin&quot;&gt; &lt;code&gt;Unpin&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../std/panic/trait.unwindsafe&quot;&gt; &lt;code&gt;UnwindSafe&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;../std/panic/trait.refunwindsafe&quot;&gt; &lt;code&gt;RefUnwindSafe&lt;/code&gt; の&lt;/a&gt;特徴は、&lt;em&gt;自動特徴&lt;/em&gt;。自動特性には特別な特性があります。</target>
        </trans-unit>
        <trans-unit id="7bd79bdd63f1cb15136ac63579db2daa51f56797" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../std/marker/trait.send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../std/marker/trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../std/panic/trait.unwindsafe&quot;&gt;&lt;code&gt;UnwindSafe&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../std/panic/trait.refunwindsafe&quot;&gt;&lt;code&gt;RefUnwindSafe&lt;/code&gt;&lt;/a&gt; traits are &lt;em&gt;auto traits&lt;/em&gt;. Auto traits have special properties.</source>
          <target state="translated">&lt;a href=&quot;../std/marker/trait.send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../std/marker/trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../std/panic/trait.unwindsafe&quot;&gt; &lt;code&gt;UnwindSafe&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../std/panic/trait.refunwindsafe&quot;&gt; &lt;code&gt;RefUnwindSafe&lt;/code&gt; &lt;/a&gt;特徴は、&lt;em&gt;自動特徴&lt;/em&gt;。自動特性には特別なプロパティがあります。</target>
        </trans-unit>
        <trans-unit id="292a56639a943e7a95497bb0cf72fbedd7460764" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../std/marker/trait.sized&quot;&gt;&lt;code&gt;Sized&lt;/code&gt;&lt;/a&gt; trait indicates that the size of this type is known at compile-time; that is, it's not a &lt;a href=&quot;dynamically-sized-types&quot;&gt;dynamically sized type&lt;/a&gt;. &lt;a href=&quot;types/parameters&quot;&gt;Type parameters&lt;/a&gt; are &lt;code&gt;Sized&lt;/code&gt; by default. &lt;code&gt;Sized&lt;/code&gt; is always implemented automatically by the compiler, not by &lt;a href=&quot;items/implementations&quot;&gt;implementation items&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../std/marker/trait.sized&quot;&gt; &lt;code&gt;Sized&lt;/code&gt; &lt;/a&gt;形質は、このタイプの大きさはコンパイル時に知られていることを示しています。つまり、&lt;a href=&quot;dynamically-sized-types&quot;&gt;動的なサイズのタイプで&lt;/a&gt;はありません。&lt;a href=&quot;types/parameters&quot;&gt;タイプパラメータ&lt;/a&gt;はデフォルトで &lt;code&gt;Sized&lt;/code&gt; されます。 &lt;code&gt;Sized&lt;/code&gt; は、&lt;a href=&quot;items/implementations&quot;&gt;実装アイテム&lt;/a&gt;ではなく、常にコンパイラによって自動的に実装されます。</target>
        </trans-unit>
        <trans-unit id="bbed2a3ef9298a62094e0bee99c5f47d5609e39c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../std/marker/trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; trait indicates that a value of this type is safe to share between multiple threads. This trait must be implemented for all types used in immutable &lt;a href=&quot;items/static-items&quot;&gt;&lt;code&gt;static&lt;/code&gt; items&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../std/marker/trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt;形質は、このタイプの値は、複数のスレッド間で共有に安全であることを示しています。このトレイトは、不変の&lt;a href=&quot;items/static-items&quot;&gt; &lt;code&gt;static&lt;/code&gt; アイテムで&lt;/a&gt;使用されるすべてのタイプに実装する必要があります。</target>
        </trans-unit>
        <trans-unit id="0bd4f0026aa17cd077440ff412c90263cb35c5bd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../std/ops/trait.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt; trait provides a &lt;a href=&quot;destructors&quot;&gt;destructor&lt;/a&gt;, to be run whenever a value of this type is to be destroyed.</source>
          <target state="translated">&lt;a href=&quot;../std/ops/trait.drop&quot;&gt; &lt;code&gt;Drop&lt;/code&gt; &lt;/a&gt;提供形質&lt;a href=&quot;destructors&quot;&gt;デストラクタは&lt;/a&gt;、このタイプの値が破棄されるたびに実行されます。</target>
        </trans-unit>
        <trans-unit id="767089bdc12afceff4b8eaec0f0a325f5d336e5b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../std/primitive.str#method.parse&quot;&gt;&lt;code&gt;parse&lt;/code&gt; method on strings&lt;/a&gt; parses a string into some kind of number. Because this method can parse a variety of number types, we need to tell Rust the exact number type we want by using &lt;code&gt;let guess: u32&lt;/code&gt;. The colon (&lt;code&gt;:&lt;/code&gt;) after &lt;code&gt;guess&lt;/code&gt; tells Rust we&amp;rsquo;ll annotate the variable&amp;rsquo;s type. Rust has a few built-in number types; the &lt;code&gt;u32&lt;/code&gt; seen here is an unsigned, 32-bit integer. It&amp;rsquo;s a good default choice for a small positive number. You&amp;rsquo;ll learn about other number types in Chapter 3. Additionally, the &lt;code&gt;u32&lt;/code&gt; annotation in this example program and the comparison with &lt;code&gt;secret_number&lt;/code&gt; means that Rust will infer that &lt;code&gt;secret_number&lt;/code&gt; should be a &lt;code&gt;u32&lt;/code&gt; as well. So now the comparison will be between two values of the same type!</source>
          <target state="translated">&lt;a href=&quot;../std/primitive.str#method.parse&quot;&gt;文字列&lt;/a&gt;の &lt;code&gt;parse&lt;/code&gt; メソッドは、文字列をある種の数値に解析します。このメソッドはさまざまな数値型を解析できるため、 &lt;code&gt;let guess: u32&lt;/code&gt; を使用して、Rustに必要な正確な数値型を通知する必要があります。コロン（ &lt;code&gt;:&lt;/code&gt; ）の後 &lt;code&gt;guess&lt;/code&gt; 私たちが変数の型に注釈を付けます錆を伝えます。 Rustには組み込みの数値型がいくつかあります。ここに表示される &lt;code&gt;u32&lt;/code&gt; は、符号なしの32ビット整数です。これは、小さい正の数に適したデフォルトの選択です。他の数値型については第3章で学習します。さらに、このサンプルプログラムの &lt;code&gt;u32&lt;/code&gt; アノテーションと &lt;code&gt;secret_number&lt;/code&gt; との比較により、Rustは &lt;code&gt;secret_number&lt;/code&gt; が &lt;code&gt;u32&lt;/code&gt; も同様です。したがって、比較は同じタイプの2つの値の間で行われます。</target>
        </trans-unit>
        <trans-unit id="c4baaa152505c4dd10d0a8afc8811ba9994e6d24" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../str/pattern/index&quot;&gt;pattern&lt;/a&gt; can be a &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, a slice of &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s, or a function or closure that determines if a character matches.</source>
          <target state="translated">&lt;a href=&quot;../str/pattern/index&quot;&gt;パターンが&lt;/a&gt;あることができる&lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;のスライス&lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;S、または文字一致するかどうかを判断する機能又はクロージャ。</target>
        </trans-unit>
        <trans-unit id="1a13bea0cade14eaae143cc58b002085ddc4bf19" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../str/pattern/index&quot;&gt;pattern&lt;/a&gt; can be a &lt;code&gt;&amp;amp;str&lt;/code&gt;, &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, a slice of &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s, or a function or closure that determines if a character matches.</source>
          <target state="translated">&lt;a href=&quot;../str/pattern/index&quot;&gt;パターンが&lt;/a&gt;可能 &lt;code&gt;&amp;amp;str&lt;/code&gt; 、&lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;、スライス&lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;文字が一致するかどうかを判断し、S、または関数やクロージャ。</target>
        </trans-unit>
        <trans-unit id="ac19fe7126085cad17eb0b418fa395ae25fa16f2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../str/struct.utf8error&quot;&gt;&lt;code&gt;Utf8Error&lt;/code&gt;&lt;/a&gt; type provided by &lt;a href=&quot;../str/index&quot;&gt;&lt;code&gt;std::str&lt;/code&gt;&lt;/a&gt; represents an error that may occur when converting a slice of &lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;s to a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;. In this sense, it's an analogue to &lt;code&gt;FromUtf8Error&lt;/code&gt;, and you can get one from a &lt;code&gt;FromUtf8Error&lt;/code&gt; through the &lt;a href=&quot;#method.utf8_error&quot;&gt;&lt;code&gt;utf8_error&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;a href=&quot;../str/struct.utf8error&quot;&gt; &lt;code&gt;Utf8Error&lt;/code&gt; の&lt;/a&gt;によって提供されるタイプ&lt;a href=&quot;../str/index&quot;&gt; &lt;code&gt;std::str&lt;/code&gt; &lt;/a&gt;スライス変換するときに発生する可能性のあるエラーを表し&lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt;にSを&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt;。この意味で、それはへのアナログだ &lt;code&gt;FromUtf8Error&lt;/code&gt; 、あなたはから1を得ることができます &lt;code&gt;FromUtf8Error&lt;/code&gt; を通じて&lt;a href=&quot;#method.utf8_error&quot;&gt; &lt;code&gt;utf8_error&lt;/code&gt; の&lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="7fb67cacdd201c958a0c7d558837d2a8082fe699" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../str/struct.utf8error&quot;&gt;&lt;code&gt;Utf8Error&lt;/code&gt;&lt;/a&gt; type provided by &lt;a href=&quot;../str/index&quot;&gt;&lt;code&gt;std::str&lt;/code&gt;&lt;/a&gt; represents an error that may occur when converting a slice of &lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;s to a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;. In this sense, it's an analogue to &lt;code&gt;FromUtf8Error&lt;/code&gt;. See its documentation for more details on using it.</source>
          <target state="translated">&lt;a href=&quot;../str/struct.utf8error&quot;&gt; &lt;code&gt;Utf8Error&lt;/code&gt; の&lt;/a&gt;によって提供されるタイプ&lt;a href=&quot;../str/index&quot;&gt; &lt;code&gt;std::str&lt;/code&gt; &lt;/a&gt;スライス変換するときに発生する可能性のあるエラーを表し&lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt;にSを&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt;。この意味で、これは &lt;code&gt;FromUtf8Error&lt;/code&gt; に類似しています。使用方法の詳細については、そのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="239e6c53cbac59da452aab2dc0d25e7124ea430b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../str/struct.utf8error&quot;&gt;&lt;code&gt;Utf8Error&lt;/code&gt;&lt;/a&gt; type provided by &lt;a href=&quot;https://doc.rust-lang.org/core/str/index.html&quot;&gt;&lt;code&gt;std::str&lt;/code&gt;&lt;/a&gt; represents an error that may occur when converting a slice of &lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;s to a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;. In this sense, it's an analogue to &lt;code&gt;FromUtf8Error&lt;/code&gt;, and you can get one from a &lt;code&gt;FromUtf8Error&lt;/code&gt; through the &lt;a href=&quot;struct.fromutf8error#method.utf8_error&quot;&gt;&lt;code&gt;utf8_error&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;a href=&quot;../str/struct.utf8error&quot;&gt; &lt;code&gt;Utf8Error&lt;/code&gt; の&lt;/a&gt;によって提供されるタイプ&lt;a href=&quot;https://doc.rust-lang.org/core/str/index.html&quot;&gt; &lt;code&gt;std::str&lt;/code&gt; &lt;/a&gt;スライス変換するときに発生する可能性のあるエラーを表し&lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt;にSを&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt;。この意味で、それはへのアナログだ &lt;code&gt;FromUtf8Error&lt;/code&gt; 、あなたはから1を得ることができます &lt;code&gt;FromUtf8Error&lt;/code&gt; を通じて&lt;a href=&quot;struct.fromutf8error#method.utf8_error&quot;&gt; &lt;code&gt;utf8_error&lt;/code&gt; の&lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="4d50f09079feb56741d3701cde3c9928a1a6e9ce" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../str/struct.utf8error&quot;&gt;&lt;code&gt;Utf8Error&lt;/code&gt;&lt;/a&gt; type provided by &lt;a href=&quot;https://doc.rust-lang.org/core/str/index.html&quot;&gt;&lt;code&gt;std::str&lt;/code&gt;&lt;/a&gt; represents an error that may occur when converting a slice of &lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;s to a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;. In this sense, it's an analogue to &lt;code&gt;FromUtf8Error&lt;/code&gt;. See its documentation for more details on using it.</source>
          <target state="translated">&lt;a href=&quot;../str/struct.utf8error&quot;&gt; &lt;code&gt;Utf8Error&lt;/code&gt; の&lt;/a&gt;によって提供されるタイプ&lt;a href=&quot;https://doc.rust-lang.org/core/str/index.html&quot;&gt; &lt;code&gt;std::str&lt;/code&gt; &lt;/a&gt;スライス変換するときに発生する可能性のあるエラーを表し&lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt;にSを&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt;。この意味で、これは &lt;code&gt;FromUtf8Error&lt;/code&gt; に類似しています。使用の詳細については、ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="ddda8120a353c19c1143b9fe623d73b4dcc57ac8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;boxed/struct.box#method.into_raw&quot;&gt;&lt;code&gt;into_raw&lt;/code&gt;&lt;/a&gt; function consumes a box and returns the raw pointer. It doesn't destroy &lt;code&gt;T&lt;/code&gt; or deallocate any memory.</source>
          <target state="translated">&lt;a href=&quot;boxed/struct.box#method.into_raw&quot;&gt; &lt;code&gt;into_raw&lt;/code&gt; &lt;/a&gt;機能は、箱を消費し、生のポインタを返します。 &lt;code&gt;T&lt;/code&gt; を破壊したり、メモリの割り当てを解除したりすることはありません。</target>
        </trans-unit>
        <trans-unit id="7fee19839226d126b119f56ff74d255c1056eb44" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;collections/index&quot;&gt;&lt;code&gt;collections&lt;/code&gt;&lt;/a&gt; module defines maps, sets, linked lists and other typical collection types, including the common &lt;a href=&quot;collections/hash_map/struct.hashmap&quot;&gt;&lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8812873ebf26389aa2891235cb5791e408b7568" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;collections/index&quot;&gt;&lt;code&gt;collections&lt;/code&gt;&lt;/a&gt; module defines maps, sets, linked lists and other typical collection types, including the common &lt;a href=&quot;collections/struct.hashmap&quot;&gt;&lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;collections/index&quot;&gt; &lt;code&gt;collections&lt;/code&gt; &lt;/a&gt;定義マップ、セット、リンクリストと共通含めた他の代表的なコレクション型、モジュール&lt;a href=&quot;collections/struct.hashmap&quot;&gt; &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a000df2416eeaceaee8b63bcc4f4d96683535efe" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;conditional-compilation#the-cfg-attribute&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;conditional-compilation#the-cfg_attr-attribute&quot;&gt;&lt;code&gt;cfg_attr&lt;/code&gt;&lt;/a&gt; attributes are active. The &lt;a href=&quot;attributes/testing#the-test-attribute&quot;&gt;&lt;code&gt;test&lt;/code&gt;&lt;/a&gt; attribute is inert when compiling for tests and active otherwise. &lt;a href=&quot;procedural-macros#attribute-macros&quot;&gt;Attribute macros&lt;/a&gt; are active. All other attributes are inert.</source>
          <target state="translated">&lt;a href=&quot;conditional-compilation#the-cfg-attribute&quot;&gt; &lt;code&gt;cfg&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;conditional-compilation#the-cfg_attr-attribute&quot;&gt; &lt;code&gt;cfg_attr&lt;/code&gt; &lt;/a&gt;属性がアクティブになっています。&lt;a href=&quot;attributes/testing#the-test-attribute&quot;&gt; &lt;code&gt;test&lt;/code&gt; &lt;/a&gt;さもなければテスト、活性のためにコンパイル時に属性が不活性です。&lt;a href=&quot;procedural-macros#attribute-macros&quot;&gt;属性マクロ&lt;/a&gt;がアクティブです。他のすべての属性は不活性です。</target>
        </trans-unit>
        <trans-unit id="6870dee47d3fe5b85f2f338b73c3f7cce4094df6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;dereference operator&lt;/a&gt; except for raw pointers.</source>
          <target state="translated">&lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;間接参照演算子&lt;/a&gt;生のポインタを除きます。</target>
        </trans-unit>
        <trans-unit id="b6a453b12ad8603a837d27104bf0cf09312a2b66" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;dereference operator&lt;/a&gt; for &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; produces a place which can be moved from. This means that the &lt;code&gt;*&lt;/code&gt; operator and the destructor of &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; are built-in to the language.</source>
          <target state="translated">&lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;間接参照演算子&lt;/a&gt;のための &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; から移動することができる場所を作成します。つまり、 &lt;code&gt;*&lt;/code&gt; 演算子と &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; デストラクタが言語に組み込まれています。</target>
        </trans-unit>
        <trans-unit id="69b248ba9e2f044518c42fe197df63cfa4b2abff" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;dereference operator&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;間接参照演算子&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ecbb9300a5b716ea6923d97c4a33bcc05beabca8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fn.current&quot;&gt;&lt;code&gt;thread::current&lt;/code&gt;&lt;/a&gt; function is available even for threads not spawned by the APIs of this module.</source>
          <target state="translated">&lt;a href=&quot;fn.current&quot;&gt; &lt;code&gt;thread::current&lt;/code&gt; &lt;/a&gt;機能も、このモジュールのAPIで生成されたスレッドではなく利用可能です。</target>
        </trans-unit>
        <trans-unit id="83c879af00d7b8c642fb06e560ce31570f391a07" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fn.escape_default&quot;&gt;&lt;code&gt;escape_default&lt;/code&gt;&lt;/a&gt; function provides an iterator over the bytes of an escaped version of the character given.</source>
          <target state="translated">&lt;a href=&quot;fn.escape_default&quot;&gt; &lt;code&gt;escape_default&lt;/code&gt; の&lt;/a&gt;機能は、指定された文字のエスケープバージョンのバイトの反復子を提供します。</target>
        </trans-unit>
        <trans-unit id="04034ef7d1f4bac81675e414f3f0f4340588ab73" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fn.park&quot;&gt;&lt;code&gt;thread::park&lt;/code&gt;&lt;/a&gt; function blocks the current thread unless or until the token is available for its thread handle, at which point it atomically consumes the token. It may also return &lt;em&gt;spuriously&lt;/em&gt;, without consuming the token. &lt;a href=&quot;fn.park_timeout&quot;&gt;&lt;code&gt;thread::park_timeout&lt;/code&gt;&lt;/a&gt; does the same, but allows specifying a maximum time to block the thread for.</source>
          <target state="translated">&lt;a href=&quot;fn.park&quot;&gt; &lt;code&gt;thread::park&lt;/code&gt; &lt;/a&gt;機能ブロック、現在のスレッドない限り、またはトークンが、それはアトミックにトークンを消費し、その時点で、そのスレッドハンドルのために利用可能になるまで。また、トークンを消費せずに、&lt;em&gt;誤って&lt;/em&gt;返す場合もあります。&lt;a href=&quot;fn.park_timeout&quot;&gt; &lt;code&gt;thread::park_timeout&lt;/code&gt; &lt;/a&gt;も同様ですが、スレッドをブロックする最大時間を指定できます。</target>
        </trans-unit>
        <trans-unit id="010183e81cf43fb24dc3ff708d62a66ab46d9a21" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fn.spawn&quot;&gt;&lt;code&gt;thread::spawn&lt;/code&gt;&lt;/a&gt; free function uses a &lt;code&gt;Builder&lt;/code&gt; with default configuration and &lt;a href=&quot;../result/enum.result#method.unwrap&quot;&gt;&lt;code&gt;unwrap&lt;/code&gt;&lt;/a&gt;s its return value.</source>
          <target state="translated">&lt;a href=&quot;fn.spawn&quot;&gt; &lt;code&gt;thread::spawn&lt;/code&gt; &lt;/a&gt;フリー機能は使用しています &lt;code&gt;Builder&lt;/code&gt; をデフォルト設定として&lt;a href=&quot;../result/enum.result#method.unwrap&quot;&gt; &lt;code&gt;unwrap&lt;/code&gt; &lt;/a&gt;の戻り値。</target>
        </trans-unit>
        <trans-unit id="29d01ae14bfbd0d95900d7de260d830e6b2aebdb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;glossary#scrutinee&quot;&gt;scrutinee&lt;/a&gt; of a &lt;code&gt;match&lt;/code&gt; expression is not a temporary scope, so temporaries in the scrutinee can be dropped after the &lt;code&gt;match&lt;/code&gt; expression. For example, the temporary for &lt;code&gt;1&lt;/code&gt; in &lt;code&gt;match 1 { ref mut z =&amp;gt; z };&lt;/code&gt; lives until the end of the statement.</source>
          <target state="translated">&lt;code&gt;match&lt;/code&gt; 式の&lt;a href=&quot;glossary#scrutinee&quot;&gt;scrutinee&lt;/a&gt;は一時的なスコープではないため、scrutinee内の一時的なものは &lt;code&gt;match&lt;/code&gt; 式の後に削除できます。たとえば、 &lt;code&gt;match 1 { ref mut z =&amp;gt; z };&lt;/code&gt; &lt;code&gt;1&lt;/code&gt; の一時{ref mut z =&amp;gt; z}; ステートメントの終わりまで生きます。</target>
        </trans-unit>
        <trans-unit id="0d631316da22e8f49a59e622d46e415aca63cb44" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;glossary#scrutinee&quot;&gt;scrutinee&lt;/a&gt; of an &lt;a href=&quot;expressions/if-expr#if-let-expressions&quot;&gt;&lt;code&gt;if let&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;expressions/match-expr&quot;&gt;&lt;code&gt;match&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;expressions/loop-expr#predicate-pattern-loops&quot;&gt;&lt;code&gt;while let&lt;/code&gt;&lt;/a&gt; expression.</source>
          <target state="translated">&lt;a href=&quot;glossary#scrutinee&quot;&gt;scrutinee&lt;/a&gt;の&lt;a href=&quot;expressions/if-expr#if-let-expressions&quot;&gt; &lt;code&gt;if let&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;expressions/match-expr&quot;&gt; &lt;code&gt;match&lt;/code&gt; &lt;/a&gt;、または&lt;a href=&quot;expressions/loop-expr#predicate-pattern-loops&quot;&gt; &lt;code&gt;while let&lt;/code&gt; &lt;/a&gt;式。</target>
        </trans-unit>
        <trans-unit id="f60d04280a375c73571ef4d8073dd6fd2b866e51" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://doc.rust-lang.org/nomicon/transmutes.html&quot;&gt;nomicon&lt;/a&gt; has additional documentation.</source>
          <target state="translated">&lt;a href=&quot;https://doc.rust-lang.org/nomicon/transmutes.html&quot;&gt;nomiconは、&lt;/a&gt;追加のドキュメントがあります。</target>
        </trans-unit>
        <trans-unit id="234fa73a8f6dcc88ca3eeed24db16797666a2694" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1270-deprecation.md&quot;&gt;RFC&lt;/a&gt; contains motivations and more details.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1270-deprecation.md&quot;&gt;RFCは&lt;/a&gt;動機と詳細が含まれています。</target>
        </trans-unit>
        <trans-unit id="b6a13e231d1887805079fed3345d62d70fa98ffc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;modules#prelude-items&quot;&gt;&lt;code&gt;no_implicit_prelude&lt;/code&gt;&lt;/a&gt; attribute can be used on a module to disable prelude lookups within that module.</source>
          <target state="translated">&lt;a href=&quot;modules#prelude-items&quot;&gt; &lt;code&gt;no_implicit_prelude&lt;/code&gt; &lt;/a&gt;属性は、そのモジュール内の無効プレリュード検索するモジュールで使用することができます。</target>
        </trans-unit>
        <trans-unit id="2d090eed4aa4b11f0c7d0fffa892207e5f74b95a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;option/index&quot;&gt;&lt;code&gt;option&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;result/index&quot;&gt;&lt;code&gt;result&lt;/code&gt;&lt;/a&gt; modules define optional and error-handling types, &lt;a href=&quot;option/enum.option&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;iter/index&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; module defines Rust's iterator trait, &lt;a href=&quot;iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;, which works with the &lt;a href=&quot;../book/ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt; loop to access collections.</source>
          <target state="translated">&lt;a href=&quot;option/index&quot;&gt; &lt;code&gt;option&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;result/index&quot;&gt; &lt;code&gt;result&lt;/code&gt; &lt;/a&gt;のモジュールは、オプションとエラー処理のタイプを定義し、&lt;a href=&quot;option/enum.option&quot;&gt; &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; &lt;/a&gt;。&lt;a href=&quot;iter/index&quot;&gt; &lt;code&gt;iter&lt;/code&gt; &lt;/a&gt;モジュール定義錆の反復子トレイト、&lt;a href=&quot;iter/trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;と連携し、&lt;a href=&quot;../book/ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt; &lt;code&gt;for&lt;/code&gt; &lt;/a&gt;のアクセスコレクションへのループ。</target>
        </trans-unit>
        <trans-unit id="a5d9a354e8b0f07a3115dc9b0844a83e58a8610e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str/pattern/index&quot;&gt;pattern&lt;/a&gt; can be a &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, a slice of &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s, or a function or closure that determines if a character matches.</source>
          <target state="translated">&lt;a href=&quot;str/pattern/index&quot;&gt;パターンが&lt;/a&gt;あることができる&lt;a href=&quot;primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;のスライス&lt;a href=&quot;primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;S、または文字一致するかどうかを判断する機能又はクロージャ。</target>
        </trans-unit>
        <trans-unit id="d0a9260d9d3256bee11715c7bab554254f578e52" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str/pattern/index&quot;&gt;pattern&lt;/a&gt; can be a &lt;code&gt;&amp;amp;str&lt;/code&gt;, &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, a slice of &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s, or a function or closure that determines if a character matches.</source>
          <target state="translated">&lt;a href=&quot;str/pattern/index&quot;&gt;パターンが&lt;/a&gt;可能 &lt;code&gt;&amp;amp;str&lt;/code&gt; 、&lt;a href=&quot;primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;、スライス&lt;a href=&quot;primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;文字が一致するかどうかを判断し、S、または関数やクロージャ。</target>
        </trans-unit>
        <trans-unit id="8bee548c1faeb9c0868a59d1b0359e0916d54967" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.arc#method.downgrade&quot;&gt;&lt;code&gt;downgrade&lt;/code&gt;&lt;/a&gt; method can be used to create a non-owning &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointer. A &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointer can be &lt;a href=&quot;struct.weak#method.upgrade&quot;&gt;&lt;code&gt;upgrade&lt;/code&gt;&lt;/a&gt;d to an &lt;code&gt;Arc&lt;/code&gt;, but this will return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if the value has already been dropped.</source>
          <target state="translated">&lt;a href=&quot;struct.arc#method.downgrade&quot;&gt; &lt;code&gt;downgrade&lt;/code&gt; &lt;/a&gt;方法は、非所有作成するために使用することができる&lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt;ポインタを。&lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt;ポインタが可能&lt;a href=&quot;struct.weak#method.upgrade&quot;&gt; &lt;code&gt;upgrade&lt;/code&gt; &lt;/a&gt;にD &lt;code&gt;Arc&lt;/code&gt; が、これは返されません&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;値が既に削除されています。</target>
        </trans-unit>
        <trans-unit id="74bc0ed50e554fb672c29105c76cd20026688a4b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.arc#method.downgrade&quot;&gt;&lt;code&gt;downgrade&lt;/code&gt;&lt;/a&gt; method can be used to create a non-owning &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointer. A &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointer can be &lt;a href=&quot;struct.weak#method.upgrade&quot;&gt;&lt;code&gt;upgrade&lt;/code&gt;&lt;/a&gt;d to an &lt;code&gt;Arc&lt;/code&gt;, but this will return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if the value stored in the allocation has already been dropped. In other words, &lt;code&gt;Weak&lt;/code&gt; pointers do not keep the value inside the allocation alive; however, they &lt;em&gt;do&lt;/em&gt; keep the allocation (the backing store for the value) alive.</source>
          <target state="translated">&lt;a href=&quot;struct.arc#method.downgrade&quot;&gt; &lt;code&gt;downgrade&lt;/code&gt; &lt;/a&gt;方法は、非所有作成するために使用することができる&lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt;ポインタを。&lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt;ポインタが可能&lt;a href=&quot;struct.weak#method.upgrade&quot;&gt; &lt;code&gt;upgrade&lt;/code&gt; &lt;/a&gt;にD &lt;code&gt;Arc&lt;/code&gt; が、これは返されません&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; を&lt;/a&gt;割り当てに格納された値がすでに削除されています。言い換えると、 &lt;code&gt;Weak&lt;/code&gt; ポインタは割り当て内の値を維持しません。しかし、彼らが&lt;em&gt;行う&lt;/em&gt;（値のバッキングストア）生き割り当てを保持します。</target>
        </trans-unit>
        <trans-unit id="94c3ecdf0be1261908d0f10ca942b75ee9286aef" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.arguments&quot;&gt;&lt;code&gt;Arguments&lt;/code&gt;&lt;/a&gt; instance can be created with the &lt;a href=&quot;../macro.format_args&quot;&gt;&lt;code&gt;format_args!&lt;/code&gt;&lt;/a&gt; macro.</source>
          <target state="translated">&lt;a href=&quot;struct.arguments&quot;&gt; &lt;code&gt;Arguments&lt;/code&gt; &lt;/a&gt;インスタンスを使用して作成することができ&lt;a href=&quot;../macro.format_args&quot;&gt; &lt;code&gt;format_args!&lt;/code&gt; &lt;/a&gt;大きい。</target>
        </trans-unit>
        <trans-unit id="fa75ef55ee98f7d19f2ace1042e87faf9ee8ae65" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.bufwriter&quot;&gt;&lt;code&gt;BufWriter&lt;/code&gt;&lt;/a&gt; struct wraps a writer and buffers its output. But it only does this batched write when it goes out of scope, or when the internal buffer is full. Sometimes, you'd prefer to write each line as it's completed, rather than the entire buffer at once. Enter &lt;code&gt;LineWriter&lt;/code&gt;. It does exactly that.</source>
          <target state="translated">&lt;a href=&quot;struct.bufwriter&quot;&gt; &lt;code&gt;BufWriter&lt;/code&gt; の&lt;/a&gt;構造体は、ライターをラップし、その出力をバッファします。ただし、この一括書き込みは、スコープ外になったとき、または内部バッファーがいっぱいになったときにのみ行われます。時には、一度にバッファ全体ではなく、完了時に各行を書き込む方がよい場合があります。 &lt;code&gt;LineWriter&lt;/code&gt; と入力します。それはまさにそれを行います。</target>
        </trans-unit>
        <trans-unit id="a07405d582facf4ae9638d6c46ccf83d378ca9a4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.builder#method.spawn&quot;&gt;&lt;code&gt;spawn&lt;/code&gt;&lt;/a&gt; method will take ownership of the builder and create an &lt;a href=&quot;../io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt; to the thread handle with the given configuration.</source>
          <target state="translated">&lt;a href=&quot;struct.builder#method.spawn&quot;&gt; &lt;code&gt;spawn&lt;/code&gt; &lt;/a&gt;方法は、ビルダーの所有権を取得して作成する&lt;a href=&quot;../io/type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt;与えられた構成とスレッドハンドルにします。</target>
        </trans-unit>
        <trans-unit id="8461a34249fb23d4197f5b2441105518f99e167b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.command&quot;&gt;&lt;code&gt;Command&lt;/code&gt;&lt;/a&gt; struct is used to configure and spawn processes:</source>
          <target state="translated">&lt;a href=&quot;struct.command&quot;&gt; &lt;code&gt;Command&lt;/code&gt; &lt;/a&gt;構造体は、configureと産卵のプロセスに使用されます。</target>
        </trans-unit>
        <trans-unit id="c0f682c8845fc1182cef69275c8073a32be2d0f3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.command#method.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.command#method.stdin&quot;&gt;&lt;code&gt;stdin&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;struct.command#method.stderr&quot;&gt;&lt;code&gt;stderr&lt;/code&gt;&lt;/a&gt; of a child process can be configured by passing an &lt;a href=&quot;struct.stdio&quot;&gt;&lt;code&gt;Stdio&lt;/code&gt;&lt;/a&gt; to the corresponding method on &lt;a href=&quot;struct.command&quot;&gt;&lt;code&gt;Command&lt;/code&gt;&lt;/a&gt;. Once spawned, they can be accessed from the &lt;a href=&quot;struct.child&quot;&gt;&lt;code&gt;Child&lt;/code&gt;&lt;/a&gt;. For example, piping output from one command into another command can be done like so:</source>
          <target state="translated">子プロセスの&lt;a href=&quot;struct.command#method.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;struct.command#method.stdin&quot;&gt; &lt;code&gt;stdin&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;struct.command#method.stderr&quot;&gt; &lt;code&gt;stderr&lt;/code&gt; &lt;/a&gt;は、&lt;a href=&quot;struct.stdio&quot;&gt; &lt;code&gt;Stdio&lt;/code&gt; &lt;/a&gt;を&lt;a href=&quot;struct.command&quot;&gt; &lt;code&gt;Command&lt;/code&gt; の&lt;/a&gt;対応するメソッドに渡すことで構成できます。スポーンすると、&lt;a href=&quot;struct.child&quot;&gt; &lt;code&gt;Child&lt;/code&gt; &lt;/a&gt;からアクセスできるようになります。たとえば、あるコマンドから別のコマンドへの出力のパイプは、次のように実行できます。</target>
        </trans-unit>
        <trans-unit id="f9ad904c74c4288c252921bb9ae74bd23e865305" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.cstring#method.new&quot;&gt;&lt;code&gt;CString::new&lt;/code&gt;&lt;/a&gt; method will actually check that the provided &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; does not have 0 bytes in the middle, and return an error if it finds one.</source>
          <target state="translated">&lt;a href=&quot;struct.cstring#method.new&quot;&gt; &lt;code&gt;CString::new&lt;/code&gt; &lt;/a&gt;方法は、実際に提供したことを確認します &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; 途中で0バイトを持っており、それがものを見つけた場合はエラーを返しません。</target>
        </trans-unit>
        <trans-unit id="979c5c1602643a6a3cebe7ffbfac71410fb43889" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.joinhandle#method.join&quot;&gt;&lt;code&gt;join&lt;/code&gt;&lt;/a&gt; method returns a &lt;a href=&quot;type.result&quot;&gt;&lt;code&gt;thread::Result&lt;/code&gt;&lt;/a&gt; containing &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt; of the final value produced by the child thread, or &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; of the value given to a call to &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt; if the child panicked.</source>
          <target state="translated">&lt;a href=&quot;struct.joinhandle#method.join&quot;&gt; &lt;code&gt;join&lt;/code&gt; &lt;/a&gt;方法は返す&lt;a href=&quot;type.result&quot;&gt; &lt;code&gt;thread::Result&lt;/code&gt; &lt;/a&gt;含む&lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt;、子スレッドによって製造された最終値の、または&lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;するコールに与えられた値の&lt;a href=&quot;../macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt;子供がパニックになった場合。</target>
        </trans-unit>
        <trans-unit id="d70df5ac1306fbf7451739c8b7b5cbb316412dcd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.localkey#method.with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; method yields a reference to the contained value which cannot be sent across threads or escape the given closure.</source>
          <target state="translated">&lt;a href=&quot;struct.localkey#method.with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt;方法は、スレッド間で送信されるか、または所定の閉鎖を逃れることができない含まれている値への参照を与えます。</target>
        </trans-unit>
        <trans-unit id="4cdf73c1055626ea58f2e6c5956631d7c37626c9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.rc#method.downgrade&quot;&gt;&lt;code&gt;downgrade&lt;/code&gt;&lt;/a&gt; method can be used to create a non-owning &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointer. A &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointer can be &lt;a href=&quot;struct.weak#method.upgrade&quot;&gt;&lt;code&gt;upgrade&lt;/code&gt;&lt;/a&gt;d to an &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt;, but this will return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if the value has already been dropped.</source>
          <target state="translated">&lt;a href=&quot;struct.rc#method.downgrade&quot;&gt; &lt;code&gt;downgrade&lt;/code&gt; &lt;/a&gt;方法は、非所有作成するために使用することができる&lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt;ポインタを。&lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt;ポインタが可能&lt;a href=&quot;struct.weak#method.upgrade&quot;&gt; &lt;code&gt;upgrade&lt;/code&gt; &lt;/a&gt;にD &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; と&lt;/a&gt;、これは返されません&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;値が既に削除されています。</target>
        </trans-unit>
        <trans-unit id="bcfdea4875bc006b185727ffa377cb6c800ff1eb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.rc#method.downgrade&quot;&gt;&lt;code&gt;downgrade&lt;/code&gt;&lt;/a&gt; method can be used to create a non-owning &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointer. A &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointer can be &lt;a href=&quot;struct.weak#method.upgrade&quot;&gt;&lt;code&gt;upgrade&lt;/code&gt;&lt;/a&gt;d to an &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt;, but this will return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if the value stored in the allocation has already been dropped. In other words, &lt;code&gt;Weak&lt;/code&gt; pointers do not keep the value inside the allocation alive; however, they &lt;em&gt;do&lt;/em&gt; keep the allocation (the backing store for the inner value) alive.</source>
          <target state="translated">&lt;a href=&quot;struct.rc#method.downgrade&quot;&gt; &lt;code&gt;downgrade&lt;/code&gt; &lt;/a&gt;方法は、非所有作成するために使用することができる&lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt;ポインタを。&lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt;ポインタが可能&lt;a href=&quot;struct.weak#method.upgrade&quot;&gt; &lt;code&gt;upgrade&lt;/code&gt; &lt;/a&gt;にD &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; と&lt;/a&gt;、これは返されません&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; を&lt;/a&gt;割り当てに格納された値がすでに削除されています。言い換えると、 &lt;code&gt;Weak&lt;/code&gt; ポインタは割り当て内の値を維持しません。しかし、彼らが&lt;em&gt;行う&lt;/em&gt;割り当て（内部値のバッキングストア）キープアライブ。</target>
        </trans-unit>
        <trans-unit id="673675ebe57e0604b8f52dd76cd89f3cf84af682" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.receiver#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt; operation can only fail if the sending half of a &lt;a href=&quot;fn.channel&quot;&gt;&lt;code&gt;channel&lt;/code&gt;&lt;/a&gt; (or &lt;a href=&quot;fn.sync_channel&quot;&gt;&lt;code&gt;sync_channel&lt;/code&gt;&lt;/a&gt;) is disconnected, implying that no further messages will ever be received.</source>
          <target state="translated">&lt;a href=&quot;struct.receiver#method.recv&quot;&gt; &lt;code&gt;recv&lt;/code&gt; &lt;/a&gt;の送信半分場合、操作は失敗する可能性がありますだけ&lt;a href=&quot;fn.channel&quot;&gt; &lt;code&gt;channel&lt;/code&gt; &lt;/a&gt;（または&lt;a href=&quot;fn.sync_channel&quot;&gt; &lt;code&gt;sync_channel&lt;/code&gt; は&lt;/a&gt;）それ以上のメッセージが今まで受信されないことを意味している、切断されています。</target>
        </trans-unit>
        <trans-unit id="2096b737ddfebc05d46f568e296a81f0a3d0197e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.sender&quot;&gt;&lt;code&gt;Sender&lt;/code&gt;&lt;/a&gt; can be cloned to &lt;a href=&quot;struct.sender#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; to the same channel multiple times, but only one &lt;a href=&quot;struct.receiver&quot;&gt;&lt;code&gt;Receiver&lt;/code&gt;&lt;/a&gt; is supported.</source>
          <target state="translated">&lt;a href=&quot;struct.sender&quot;&gt; &lt;code&gt;Sender&lt;/code&gt; &lt;/a&gt;するクローニングすることができる&lt;a href=&quot;struct.sender#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt;同じチャネルに複数回、一つだけ&lt;a href=&quot;struct.receiver&quot;&gt; &lt;code&gt;Receiver&lt;/code&gt; &lt;/a&gt;サポートされています。</target>
        </trans-unit>
        <trans-unit id="d38fd997ec90eab994427a1fbc1ca66e988ed96b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.syncsender&quot;&gt;&lt;code&gt;SyncSender&lt;/code&gt;&lt;/a&gt; can be cloned to &lt;a href=&quot;struct.syncsender#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; to the same channel multiple times, but only one &lt;a href=&quot;struct.receiver&quot;&gt;&lt;code&gt;Receiver&lt;/code&gt;&lt;/a&gt; is supported.</source>
          <target state="translated">&lt;a href=&quot;struct.syncsender&quot;&gt; &lt;code&gt;SyncSender&lt;/code&gt; を&lt;/a&gt;するためにクローン化することができる&lt;a href=&quot;struct.syncsender#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt;同じチャネルに複数回、一つだけ&lt;a href=&quot;struct.receiver&quot;&gt; &lt;code&gt;Receiver&lt;/code&gt; &lt;/a&gt;サポートされています。</target>
        </trans-unit>
        <trans-unit id="7001293def1e95a9d6c40ad63bf180d03eb64fd9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.thread#method.unpark&quot;&gt;&lt;code&gt;unpark&lt;/code&gt;&lt;/a&gt; method on a &lt;a href=&quot;struct.thread&quot;&gt;&lt;code&gt;Thread&lt;/code&gt;&lt;/a&gt; atomically makes the token available if it wasn't already. Because the token is initially absent, &lt;a href=&quot;struct.thread#method.unpark&quot;&gt;&lt;code&gt;unpark&lt;/code&gt;&lt;/a&gt; followed by &lt;a href=&quot;fn.park&quot;&gt;&lt;code&gt;park&lt;/code&gt;&lt;/a&gt; will result in the second call returning immediately.</source>
          <target state="translated">&lt;a href=&quot;struct.thread&quot;&gt; &lt;code&gt;Thread&lt;/code&gt; &lt;/a&gt;の&lt;a href=&quot;struct.thread#method.unpark&quot;&gt; &lt;code&gt;unpark&lt;/code&gt; &lt;/a&gt;メソッドは、トークンがまだない場合、それをアトミックに使用可能にします。トークンは最初は存在しないため、&lt;a href=&quot;fn.park&quot;&gt; &lt;code&gt;park&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;struct.thread#method.unpark&quot;&gt; &lt;code&gt;unpark&lt;/code&gt; &lt;/a&gt;後にパーク解除を実行すると、2番目の呼び出しがすぐに返されます。</target>
        </trans-unit>
        <trans-unit id="3b63b1ad0bef3b06d878599f3be015ecfe5404bc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.unixdatagram#method.connect&quot;&gt;&lt;code&gt;connect&lt;/code&gt;&lt;/a&gt; method will connect the socket to a peer.</source>
          <target state="translated">&lt;a href=&quot;struct.unixdatagram#method.connect&quot;&gt; &lt;code&gt;connect&lt;/code&gt; &lt;/a&gt;方法は、ピアへのソケットを接続します。</target>
        </trans-unit>
        <trans-unit id="1599d30320e03334b98613759c0cb03ef5b8af44" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.unixdatagram#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; method may be used to send data to the specified address. &lt;a href=&quot;struct.unixdatagram#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.unixdatagram#method.recv_from&quot;&gt;&lt;code&gt;recv_from&lt;/code&gt;&lt;/a&gt; will only receive data from that address.</source>
          <target state="translated">&lt;a href=&quot;struct.unixdatagram#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt;方法は、指定されたアドレスにデータを送信するために使用することができます。&lt;a href=&quot;struct.unixdatagram#method.recv&quot;&gt; &lt;code&gt;recv&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;struct.unixdatagram#method.recv_from&quot;&gt; &lt;code&gt;recv_from&lt;/code&gt; &lt;/a&gt;は、そのアドレスからのみデータを受信します。</target>
        </trans-unit>
        <trans-unit id="a53484ac76a42814fdd6d0152dc58d8216dd587e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.vec#method.drain&quot;&gt;&lt;code&gt;drain&lt;/code&gt;&lt;/a&gt; method can emulate &lt;code&gt;truncate&lt;/code&gt;, but causes the excess elements to be returned instead of dropped.</source>
          <target state="translated">&lt;a href=&quot;struct.vec#method.drain&quot;&gt; &lt;code&gt;drain&lt;/code&gt; &lt;/a&gt;方法がエミュレートできる &lt;code&gt;truncate&lt;/code&gt; 、しかし返さ代わりに落下する過剰な要素を引き起こします。</target>
        </trans-unit>
        <trans-unit id="ea6d0b5a4d7abf2551cbce00a21d08c3b9b0ea9b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;thread/index&quot;&gt;&lt;code&gt;thread&lt;/code&gt;&lt;/a&gt; module contains Rust's threading abstractions. &lt;a href=&quot;sync/index&quot;&gt;&lt;code&gt;sync&lt;/code&gt;&lt;/a&gt; contains further primitive shared memory types, including &lt;a href=&quot;sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;sync/mpsc/index&quot;&gt;&lt;code&gt;mpsc&lt;/code&gt;&lt;/a&gt;, which contains the channel types for message passing.</source>
          <target state="translated">&lt;a href=&quot;thread/index&quot;&gt; &lt;code&gt;thread&lt;/code&gt; &lt;/a&gt;モジュールは、錆のスレッド抽象化が含まれています。&lt;a href=&quot;sync/index&quot;&gt; &lt;code&gt;sync&lt;/code&gt; に&lt;/a&gt;は、&lt;a href=&quot;sync/atomic/index&quot;&gt; &lt;code&gt;atomic&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;sync/mpsc/index&quot;&gt; &lt;code&gt;mpsc&lt;/code&gt; &lt;/a&gt;を含む、さらにプリミティブな共有メモリタイプが含まれています。</target>
        </trans-unit>
        <trans-unit id="49a461a4d2bf3262db6f2402e2172259bf56947f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;trait.asciiext&quot;&gt;&lt;code&gt;AsciiExt&lt;/code&gt;&lt;/a&gt; trait provides methods that allow for character operations that only act on the ASCII subset and leave non-ASCII characters alone.</source>
          <target state="translated">&lt;a href=&quot;trait.asciiext&quot;&gt; &lt;code&gt;AsciiExt&lt;/code&gt; の&lt;/a&gt;特性はASCIIのサブセットに作用し、一人で非ASCII文字を残す文字の操作を可能とする方法を提供します。</target>
        </trans-unit>
        <trans-unit id="1a4c8cc0a085c3df1289a22cd8aaec879c0c1b9f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;trait.doubleendediterator&quot;&gt;trait-level&lt;/a&gt; docs contain more details.</source>
          <target state="translated">&lt;a href=&quot;trait.doubleendediterator&quot;&gt;特性レベルの&lt;/a&gt;ドキュメントは、より多くの詳細が含まれています。</target>
        </trans-unit>
        <trans-unit id="a9baa3ad4d7314655f1af4e53b409fbc088f4b8e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;trait.error#method.source&quot;&gt;&lt;code&gt;source&lt;/code&gt;&lt;/a&gt; method is generally used when errors cross &quot;abstraction boundaries&quot;. If one module must report an error that is caused by an error from a lower-level module, it can allow access to that error via the &lt;a href=&quot;trait.error#method.source&quot;&gt;&lt;code&gt;source&lt;/code&gt;&lt;/a&gt; method. This makes it possible for the high-level module to provide its own errors while also revealing some of the implementation for debugging via &lt;a href=&quot;trait.error#method.source&quot;&gt;&lt;code&gt;source&lt;/code&gt;&lt;/a&gt; chains.</source>
          <target state="translated">&lt;a href=&quot;trait.error#method.source&quot;&gt; &lt;code&gt;source&lt;/code&gt; &lt;/a&gt;エラーが「抽象の境界を」横断するときの方法は、一般的に使用されています。 1つのモジュールが下位モジュールからのエラーが原因のエラーを報告する必要がある場合、&lt;a href=&quot;trait.error#method.source&quot;&gt; &lt;code&gt;source&lt;/code&gt; &lt;/a&gt;メソッドを介してそのエラーにアクセスできます。これにより、高レベルモジュールが独自のエラーを提供し、&lt;a href=&quot;trait.error#method.source&quot;&gt; &lt;code&gt;source&lt;/code&gt; &lt;/a&gt;チェーンを介してデバッグするための実装の一部を明らかにすることができます。</target>
        </trans-unit>
        <trans-unit id="3fb97ac2277aef1f78113f1e75546370dbbdba9b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;trait.exactsizeiterator#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; method has a default implementation, so you usually shouldn't implement it. However, you may be able to provide a more performant implementation than the default, so overriding it in this case makes sense.</source>
          <target state="translated">&lt;a href=&quot;trait.exactsizeiterator#method.len&quot;&gt; &lt;code&gt;len&lt;/code&gt; &lt;/a&gt;方法は、デフォルトの実装を持っているので、あなたは、通常、それを実装するべきではありません。ただし、デフォルトよりもパフォーマンスの高い実装を提供できる場合があるため、この場合はオーバーライドするのが理にかなっています。</target>
        </trans-unit>
        <trans-unit id="e8960e05e681fd3c863585eb072cff67079ae758" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;trait.fnonce&quot;&gt;&lt;code&gt;FnOnce&lt;/code&gt;&lt;/a&gt; traits are implemented by types that can be invoked like functions. Note that &lt;a href=&quot;trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt; takes &lt;code&gt;&amp;amp;self&lt;/code&gt;, &lt;a href=&quot;trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt; takes &lt;code&gt;&amp;amp;mut self&lt;/code&gt; and &lt;a href=&quot;trait.fnonce&quot;&gt;&lt;code&gt;FnOnce&lt;/code&gt;&lt;/a&gt; takes &lt;code&gt;self&lt;/code&gt;. These correspond to the three kinds of methods that can be invoked on an instance: call-by-reference, call-by-mutable-reference, and call-by-value. The most common use of these traits is to act as bounds to higher-level functions that take functions or closures as arguments.</source>
          <target state="translated">&lt;a href=&quot;trait.fn&quot;&gt; &lt;code&gt;Fn&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;trait.fnmut&quot;&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;trait.fnonce&quot;&gt; &lt;code&gt;FnOnce&lt;/code&gt; の&lt;/a&gt;形質は関数のように呼び出すことができる種類によって実現されています。注意&lt;a href=&quot;trait.fn&quot;&gt; &lt;code&gt;Fn&lt;/code&gt; が&lt;/a&gt;かかる &lt;code&gt;&amp;amp;self&lt;/code&gt; 、&lt;a href=&quot;trait.fnmut&quot;&gt; &lt;code&gt;FnMut&lt;/code&gt; が&lt;/a&gt;かかる &lt;code&gt;&amp;amp;mut self&lt;/code&gt; と&lt;a href=&quot;trait.fnonce&quot;&gt; &lt;code&gt;FnOnce&lt;/code&gt; は&lt;/a&gt;かかる &lt;code&gt;self&lt;/code&gt; 。これらは、インスタンスで呼び出すことができる3種類のメソッド（参照による呼び出し、可変参照による呼び出し、および値による呼び出し）に対応しています。これらの特性の最も一般的な使用法は、関数またはクロージャーを引数として受け取る高レベル関数への境界として機能することです。</target>
        </trans-unit>
        <trans-unit id="c33bacd306c2aa86080fee643cadd9fa3a5a922c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;trait.iterator#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; adapter is very useful, but only when the closure argument produces values. If it produces an iterator instead, there's an extra layer of indirection. &lt;code&gt;flat_map()&lt;/code&gt; will remove this extra layer on its own.</source>
          <target state="translated">&lt;a href=&quot;trait.iterator#method.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt;アダプタは非常に便利ですが、閉鎖引数には、値を生成する場合にのみ。代わりにイテレータを生成する場合は、間接の余分な層があります。 &lt;code&gt;flat_map()&lt;/code&gt; は、この余分なレイヤーを自動的に削除します。</target>
        </trans-unit>
        <trans-unit id="af84d72464a620d276e568d18222de12da4b2fde" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;trait.iterator#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; iterator implements &lt;a href=&quot;trait.doubleendediterator&quot;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt;, meaning that you can also &lt;a href=&quot;trait.iterator#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; backwards:</source>
          <target state="translated">&lt;a href=&quot;trait.iterator#method.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt;イテレータを実装&lt;a href=&quot;trait.doubleendediterator&quot;&gt; &lt;code&gt;DoubleEndedIterator&lt;/code&gt; を&lt;/a&gt;あなたにもできることを意味し、&lt;a href=&quot;trait.iterator#method.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt;後方：</target>
        </trans-unit>
        <trans-unit id="a0672d71e250ee0ec8fcc8dfa66640aade0f2d7e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;trait.tryfrom&quot;&gt;&lt;code&gt;TryFrom&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.tryinto&quot;&gt;&lt;code&gt;TryInto&lt;/code&gt;&lt;/a&gt; traits behave like &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt;, but should be implemented when the conversion can fail.</source>
          <target state="translated">&lt;a href=&quot;trait.tryfrom&quot;&gt; &lt;code&gt;TryFrom&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;trait.tryinto&quot;&gt; &lt;code&gt;TryInto&lt;/code&gt; &lt;/a&gt;特徴は次のように振る舞う&lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt;、しかし、変換が失敗することができたときに実装する必要があります。</target>
        </trans-unit>
        <trans-unit id="e376c9d77b7276078629a96e3397aaf50b87d100" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;trait.write#tymethod.flush&quot;&gt;&lt;code&gt;flush&lt;/code&gt;&lt;/a&gt; method is useful for adaptors and explicit buffers themselves for ensuring that all buffered data has been pushed out to the 'true sink'.</source>
          <target state="translated">&lt;a href=&quot;trait.write#tymethod.flush&quot;&gt; &lt;code&gt;flush&lt;/code&gt; &lt;/a&gt;の方法は、アダプタと、すべてのバッファされたデータは、「真シンク」に押し出されていることを確実にするための明示的なバッファ自身のために有用です。</target>
        </trans-unit>
        <trans-unit id="aaa424efe4823f7e6a6edaf5a49990756704380f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; method will attempt to write some data into the object, returning how many bytes were successfully written.</source>
          <target state="translated">&lt;a href=&quot;trait.write#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;方法は、正常に書き込まれたバイト数を返す、オブジェクトにいくつかのデータを書き込もうとします。</target>
        </trans-unit>
        <trans-unit id="75436aa22cb5f73032a0aa74018fe133c992dee0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;type-layout#primitive-representations&quot;&gt;primitive representations&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;type-layout#primitive-representations&quot;&gt;原始的な表現&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="76a754ff1ade7a85d17901c16d28f4fc1a0ec281" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;types/inferred&quot;&gt;inferred type&lt;/a&gt; which asks the compiler to determine the type.</source>
          <target state="translated">&lt;a href=&quot;types/inferred&quot;&gt;推論された型の&lt;/a&gt;タイプを決定するようにコンパイラに要求します。</target>
        </trans-unit>
        <trans-unit id="bbc904b6676167d928a315d71b571002efe99186" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;types/never&quot;&gt;never&lt;/a&gt; type.</source>
          <target state="translated">&lt;a href=&quot;types/never&quot;&gt;決して&lt;/a&gt;入力しません。</target>
        </trans-unit>
        <trans-unit id="2be3f45b2596938280efdad2e1e3c487cd3dd502" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the--operator-can-be-used-in-functions-that-return-result&quot;&gt;?&lt;/code&gt; Operator Can Be Used in Functions That Return &lt;code&gt;Result&lt;/code&gt;</source>
          <target state="translated">&lt;code id=&quot;the--operator-can-be-used-in-functions-that-return-result&quot;&gt;?&lt;/code&gt; &lt;code&gt;Result&lt;/code&gt; 返す関数で演算子を使用できます</target>
        </trans-unit>
        <trans-unit id="86dac89caf1fb6bb25d3f0271f01c85dae090eff" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the--operator-can-only-be-used-in-functions-that-return-result&quot;&gt;?&lt;/code&gt; Operator Can Only Be Used in Functions That Return &lt;code&gt;Result&lt;/code&gt;</source>
          <target state="translated">&lt;code id=&quot;the--operator-can-only-be-used-in-functions-that-return-result&quot;&gt;?&lt;/code&gt; 演算子は &lt;code&gt;Result&lt;/code&gt; 返す関数でのみ使用できます</target>
        </trans-unit>
        <trans-unit id="bf416e54f0f3d3a2ee8340cdce3195c04f0662bc" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-_-placeholder&quot;&gt;_&lt;/code&gt; Placeholder</source>
          <target state="translated">&lt;code id=&quot;the-_-placeholder&quot;&gt;_&lt;/code&gt; プレースホルダ</target>
        </trans-unit>
        <trans-unit id="7d36ad4c51a4dc937d643fbbbf54439f451168f2" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-args-function-and-invalid-unicode&quot;&gt;args&lt;/code&gt; Function and Invalid Unicode</source>
          <target state="translated">&lt;code id=&quot;the-args-function-and-invalid-unicode&quot;&gt;args&lt;/code&gt; 関数と無効なユニコード</target>
        </trans-unit>
        <trans-unit id="43afa187f9cf6582feca58fbbf7f12992daae6dc" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-automatically_derived-attribute&quot;&gt;automatically_derived&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code id=&quot;the-automatically_derived-attribute&quot;&gt;automatically_derived&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="1ae32b9d596051c5f8a6c5be151de5b2bd58f3f8" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-c-representation&quot;&gt;C&lt;/code&gt; Representation</source>
          <target state="translated">&lt;code id=&quot;the-c-representation&quot;&gt;C&lt;/code&gt; 表現</target>
        </trans-unit>
        <trans-unit id="bbe7f8f8cbbf771865519c2bb3d21bb5f521d891" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-cfg-attribute&quot;&gt;cfg&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code id=&quot;the-cfg-attribute&quot;&gt;cfg&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="572d131266eef7422234c8cd8f4bf975d532a1c7" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-cfg-macro&quot;&gt;cfg&lt;/code&gt; macro</source>
          <target state="translated">&lt;code id=&quot;the-cfg-macro&quot;&gt;cfg&lt;/code&gt; マクロ</target>
        </trans-unit>
        <trans-unit id="ff73ca7cbd9ceded9b08042dee3a7e44286d5879" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-cfg_attr-attribute&quot;&gt;cfg_attr&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code id=&quot;the-cfg_attr-attribute&quot;&gt;cfg_attr&lt;/code&gt; の属性</target>
        </trans-unit>
        <trans-unit id="8ab454a301e64c91054b75436344fb463ed4e31a" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-cold-attribute&quot;&gt;cold&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code id=&quot;the-cold-attribute&quot;&gt;cold&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="f3918f7c748b8a6de02591e90a158be55e179161" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-crate_name-attribute&quot;&gt;crate_name&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code id=&quot;the-crate_name-attribute&quot;&gt;crate_name&lt;/code&gt; の属性</target>
        </trans-unit>
        <trans-unit id="56779e684809e370ff842b9fd00e8e8533305b15" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-deprecated-attribute&quot;&gt;deprecated&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code id=&quot;the-deprecated-attribute&quot;&gt;deprecated&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="d264c9c886b4e7e93efe14011caf84a4cb0f8edc" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-export_name-attribute&quot;&gt;export_name&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code id=&quot;the-export_name-attribute&quot;&gt;export_name&lt;/code&gt; の属性</target>
        </trans-unit>
        <trans-unit id="64953382ec25ebff3523c686f871b6cac0e50ffe" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-global_allocator-attribute&quot;&gt;global_allocator&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code id=&quot;the-global_allocator-attribute&quot;&gt;global_allocator&lt;/code&gt; の属性</target>
        </trans-unit>
        <trans-unit id="71beea8a8240cee1b864ee8a097da9cb395a0451" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-ignore-attribute&quot;&gt;ignore&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code id=&quot;the-ignore-attribute&quot;&gt;ignore&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="d4e444fdfbdbbdaea724f409a0908c1ddaf47280" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-inline-attribute&quot;&gt;inline&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code id=&quot;the-inline-attribute&quot;&gt;inline&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="46f91b9733dfb285998974fd7a3ed63a6997485d" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-iterator-trait-and-the-next-method&quot;&gt;Iterator&lt;/code&gt; Trait and the &lt;code&gt;next&lt;/code&gt; Method</source>
          <target state="translated">&lt;code id=&quot;the-iterator-trait-and-the-next-method&quot;&gt;Iterator&lt;/code&gt; 形質と &lt;code&gt;next&lt;/code&gt; 方法</target>
        </trans-unit>
        <trans-unit id="289229034807d95c3121d3bcf9cb7e25c1ac9ef2" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-link-attribute&quot;&gt;link&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code id=&quot;the-link-attribute&quot;&gt;link&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="7cf19b8ac8c37c88b76bf5924f5303e2d1b3cbfc" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-link_name-attribute&quot;&gt;link_name&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code id=&quot;the-link_name-attribute&quot;&gt;link_name&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="7fca57741dda84795b52faabc81edaee2bb29077" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-link_section-attribute&quot;&gt;link_section&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code id=&quot;the-link_section-attribute&quot;&gt;link_section&lt;/code&gt; の属性</target>
        </trans-unit>
        <trans-unit id="7b8b70af9354cb75b7660a9b63a471bca4708883" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-macro_use-attribute&quot;&gt;macro_use&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code id=&quot;the-macro_use-attribute&quot;&gt;macro_use&lt;/code&gt; の属性</target>
        </trans-unit>
        <trans-unit id="479b4a692bc6c43f38d4737f51dec06b4e143a16" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-match-control-flow-operator&quot;&gt;match&lt;/code&gt; Control Flow Operator</source>
          <target state="translated">&lt;code id=&quot;the-match-control-flow-operator&quot;&gt;match&lt;/code&gt; 制御フロー演算子</target>
        </trans-unit>
        <trans-unit id="3764cbd865c70d966aece7af300dfa7f637fe423" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-must_use-attribute&quot;&gt;must_use&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code id=&quot;the-must_use-attribute&quot;&gt;must_use&lt;/code&gt; の属性</target>
        </trans-unit>
        <trans-unit id="32f1e16c1f0bc3e100253f9a6db177a6d4101ff1" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-no_builtins-attribute&quot;&gt;no_builtins&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code id=&quot;the-no_builtins-attribute&quot;&gt;no_builtins&lt;/code&gt; の属性</target>
        </trans-unit>
        <trans-unit id="bc45c323650c2f34949e4b642c8e1bc1d4214794" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-no_link-attribute&quot;&gt;no_link&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code id=&quot;the-no_link-attribute&quot;&gt;no_link&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="e12971ae998085805bad575f162d256452bcc1e0" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-no_main-attribute&quot;&gt;no_main&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code id=&quot;the-no_main-attribute&quot;&gt;no_main&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="0f55be277b4754e64848202241f85fe626641b3d" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-no_mangle-attribute&quot;&gt;no_mangle&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code id=&quot;the-no_mangle-attribute&quot;&gt;no_mangle&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="2b05901aeaab894c86cab85581e952e9c5d4125e" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-non_exhaustive-attribute&quot;&gt;non_exhaustive&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code id=&quot;the-non_exhaustive-attribute&quot;&gt;non_exhaustive&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="5417fc07a4925f25ebbeb5f618a1275243378ced" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-option-enum-and-its-advantages-over-null-values&quot;&gt;Option&lt;/code&gt; Enum and Its Advantages Over Null Values</source>
          <target state="translated">&lt;code id=&quot;the-option-enum-and-its-advantages-over-null-values&quot;&gt;Option&lt;/code&gt; EnumとNull値に対するその利点</target>
        </trans-unit>
        <trans-unit id="456d9c623e0db72560e9d4ff7d18d6a3d51bb4a0" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-panic_handler-attribute&quot;&gt;panic_handler&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code id=&quot;the-panic_handler-attribute&quot;&gt;panic_handler&lt;/code&gt; の属性</target>
        </trans-unit>
        <trans-unit id="f6f2fa5a516f880089540c2827decd01d5a6e7d2" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-path-attribute&quot;&gt;path&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code id=&quot;the-path-attribute&quot;&gt;path&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="272c0059788508ea23a5913dedfc781999a4329c" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-proc_macro-crate&quot;&gt;proc_macro&lt;/code&gt; crate</source>
          <target state="translated">&lt;code id=&quot;the-proc_macro-crate&quot;&gt;proc_macro&lt;/code&gt; クレート</target>
        </trans-unit>
        <trans-unit id="b1850ba5995c1ec62eca62cf6b54da74c57b2f08" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-recursion_limit-attribute&quot;&gt;recursion_limit&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code id=&quot;the-recursion_limit-attribute&quot;&gt;recursion_limit&lt;/code&gt; の属性</target>
        </trans-unit>
        <trans-unit id="b7debe8457b97e78697481f2ab2a13b2dce10763" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-should_panic-attribute&quot;&gt;should_panic&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code id=&quot;the-should_panic-attribute&quot;&gt;should_panic&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="93213a38ad3b67a68894b916ca83c68efaaa5823" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-string-type&quot;&gt;String&lt;/code&gt; Type</source>
          <target state="translated">&lt;code id=&quot;the-string-type&quot;&gt;String&lt;/code&gt; タイプ</target>
        </trans-unit>
        <trans-unit id="1fa123d3091c3f529b13b66733146b6cc074b9ee" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-target_feature-attribute&quot;&gt;target_feature&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code id=&quot;the-target_feature-attribute&quot;&gt;target_feature&lt;/code&gt; の属性</target>
        </trans-unit>
        <trans-unit id="8ec1dda37a4f697fee6a707ed0b667ec2bc1a23e" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-test-attribute&quot;&gt;test&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code id=&quot;the-test-attribute&quot;&gt;test&lt;/code&gt; の属性</target>
        </trans-unit>
        <trans-unit id="cf59ceebdbbaa090bce70ec65f673058503cd1c7" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-track_caller-attribute&quot;&gt;track_caller&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code id=&quot;the-track_caller-attribute&quot;&gt;track_caller&lt;/code&gt; の属性</target>
        </trans-unit>
        <trans-unit id="3ad072e3ed2e5bdacb782947af3c6085d2383d5f" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-transparent-representation&quot;&gt;transparent&lt;/code&gt; Representation</source>
          <target state="translated">&lt;code id=&quot;the-transparent-representation&quot;&gt;transparent&lt;/code&gt; 表現</target>
        </trans-unit>
        <trans-unit id="222c253464f70dc2d46508fef9bded38b979180e" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-type_length_limit-attribute&quot;&gt;type_length_limit&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code id=&quot;the-type_length_limit-attribute&quot;&gt;type_length_limit&lt;/code&gt; の属性</target>
        </trans-unit>
        <trans-unit id="b350e27ebb9ddb5535abd7bc5f0b158500f6c7ea" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-used-attribute&quot;&gt;used&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code id=&quot;the-used-attribute&quot;&gt;used&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="d7b55666424bcbda4791627f5d3c1a25c9fd2797" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-windows_subsystem-attribute&quot;&gt;windows_subsystem&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code id=&quot;the-windows_subsystem-attribute&quot;&gt;windows_subsystem&lt;/code&gt; の属性</target>
        </trans-unit>
        <trans-unit id="844971eb58988950f234035bf3b738d18df15983" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;!&lt;/code&gt; type, also called &quot;never&quot;.</source>
          <target state="translated">&lt;code&gt;!&lt;/code&gt; タイプ、「ネバー」とも呼ばれます。</target>
        </trans-unit>
        <trans-unit id="1959101a4f878a742e6d622df58125da3c9ee8ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#![feature]&lt;/code&gt; attribute specified an unknown feature.</source>
          <target state="translated">&lt;code&gt;#![feature]&lt;/code&gt; 属性は、未知の機能を指定しました。</target>
        </trans-unit>
        <trans-unit id="6772d2ae0b060a250746d33cd174746c466f1400" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#[cfg(test)]&lt;/code&gt; annotation on the tests module tells Rust to compile and run the test code only when you run &lt;code&gt;cargo test&lt;/code&gt;, not when you run &lt;code&gt;cargo build&lt;/code&gt;. This saves compile time when you only want to build the library and saves space in the resulting compiled artifact because the tests are not included. You&amp;rsquo;ll see that because integration tests go in a different directory, they don&amp;rsquo;t need the &lt;code&gt;#[cfg(test)]&lt;/code&gt; annotation. However, because unit tests go in the same files as the code, you&amp;rsquo;ll use &lt;code&gt;#[cfg(test)]&lt;/code&gt; to specify that they shouldn&amp;rsquo;t be included in the compiled result.</source>
          <target state="translated">テストモジュールの &lt;code&gt;#[cfg(test)]&lt;/code&gt; アノテーションは、Rustに対して、 &lt;code&gt;cargo build&lt;/code&gt; を実行するときではなく、 &lt;code&gt;cargo test&lt;/code&gt; を実行するときにのみテストコードをコンパイルして実行するように指示します。これにより、ライブラリをビルドするだけの場合のコンパイル時間が節約され、テストが含まれていないため、結果としてコンパイルされるアーティファクトのスペースが節約されます。統合テストは別のディレクトリにあるため、 &lt;code&gt;#[cfg(test)]&lt;/code&gt; アノテーションは必要ないことがわかります。ただし、単体テストはコードと同じファイルに格納されるため、 &lt;code&gt;#[cfg(test)]&lt;/code&gt; を使用して、コンパイル結果に含めないように指定します。</target>
        </trans-unit>
        <trans-unit id="519f31417527ab16777c33990a8b19270d90ed97" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#[global_allocator]&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;#[global_allocator]&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="e73c0e75e8ab048b307c0488b5dbff0af69bd767" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#[global_allocator]&lt;/code&gt; can only be used once in a crate or its recursive dependencies.</source>
          <target state="translated">&lt;code&gt;#[global_allocator]&lt;/code&gt; でのみクレートまたはその再帰的依存関係に一度使用することができます。</target>
        </trans-unit>
        <trans-unit id="672159bbb94aa0ec135859c99523eca0ebc397f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#[macro_export]&lt;/code&gt; annotation indicates that this macro should be made available whenever the crate in which the macro is defined is brought into scope. Without this annotation, the macro can&amp;rsquo;t be brought into scope.</source>
          <target state="translated">&lt;code&gt;#[macro_export]&lt;/code&gt; アノテーションは、マクロが定義されているクレートがスコープになるたびに、このマクロが利用可能にすべきであることを示しています。この注釈がないと、マクロをスコープに入れることができません。</target>
        </trans-unit>
        <trans-unit id="859ec264725730980afa9483dd83d3f313613cc7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#[repr(C)]&lt;/code&gt; attribute can only be placed on structs and enums.</source>
          <target state="translated">&lt;code&gt;#[repr(C)]&lt;/code&gt; 属性は、構造体と列挙型上に配置することができます。</target>
        </trans-unit>
        <trans-unit id="20ce08781d178cc7ecc1d0ee2405f13954a27792" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#[repr(packed)]&lt;/code&gt; and &lt;code&gt;#[repr(simd)]&lt;/code&gt; attributes only work on structs.</source>
          <target state="translated">&lt;code&gt;#[repr(packed)]&lt;/code&gt; と &lt;code&gt;#[repr(simd)]&lt;/code&gt; 構造体の唯一の仕事を属性。</target>
        </trans-unit>
        <trans-unit id="37e64d7cdeff0fe84feb89e7cacb8aa07bcc4dd2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#[repr(u8)]&lt;/code&gt;, &lt;code&gt;#[repr(i16)]&lt;/code&gt;, etc attributes only work on enums.</source>
          <target state="translated">&lt;code&gt;#[repr(u8)]&lt;/code&gt; 、 &lt;code&gt;#[repr(i16)]&lt;/code&gt; 、などが列挙型でのみ作業を属性。</target>
        </trans-unit>
        <trans-unit id="c9b512964c382c5f5d5e0080e7203c876528ceb6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#[rustc_on_unimplemented]&lt;/code&gt; attribute lets you specify a custom error message for when a particular trait isn't implemented on a type placed in a position that needs that trait. For example, when the following code is compiled:</source>
          <target state="translated">&lt;code&gt;#[rustc_on_unimplemented]&lt;/code&gt; 属性を使用すると、特定の形質をその形質を必要とする位置に配置されたタイプでは実装されていないときのためのカスタムエラーメッセージを指定できます。たとえば、次のコードがコンパイルされた場合：</target>
        </trans-unit>
        <trans-unit id="910d7829ddf09eb2fc4a2ff115280a7e351c19be" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#[simd]&lt;/code&gt; attribute can only be applied to non empty tuple structs, because it doesn't make sense to try to use SIMD operations when there are no values to operate on.</source>
          <target state="translated">&lt;code&gt;#[simd]&lt;/code&gt; それは上で動作する値がないとき、SIMD演算を使用しようとすることは意味がありませんので、属性は、非空のタプルの構造体に適用することができます。</target>
        </trans-unit>
        <trans-unit id="20a3879322df478a4cc556128e471d1c66adae12" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#[unwind]&lt;/code&gt; attribute should be used as follows:</source>
          <target state="translated">&lt;code&gt;#[unwind]&lt;/code&gt; 次のように属性を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="98359d44655df527d34cb1e33db3c37a01e294d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;&lt;/code&gt; (shared borrow) and &lt;code&gt;&amp;amp;mut&lt;/code&gt; (mutable borrow) operators are unary prefix operators. When applied to a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place expression&lt;/a&gt;, this expressions produces a reference (pointer) to the location that the value refers to. The memory location is also placed into a borrowed state for the duration of the reference. For a shared borrow (&lt;code&gt;&amp;amp;&lt;/code&gt;), this implies that the place may not be mutated, but it may be read or shared again. For a mutable borrow (&lt;code&gt;&amp;amp;mut&lt;/code&gt;), the place may not be accessed in any way until the borrow expires. &lt;code&gt;&amp;amp;mut&lt;/code&gt; evaluates its operand in a mutable place expression context. If the &lt;code&gt;&amp;amp;&lt;/code&gt; or &lt;code&gt;&amp;amp;mut&lt;/code&gt; operators are applied to a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;value expression&lt;/a&gt;, then a &lt;a href=&quot;../expressions#temporaries&quot;&gt;temporary value&lt;/a&gt; is created.</source>
          <target state="translated">&lt;code&gt;&amp;amp;&lt;/code&gt; （共有ボロー）と &lt;code&gt;&amp;amp;mut&lt;/code&gt; （可変ボロー）演算子は単項演算子です。&lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;場所式に&lt;/a&gt;適用すると、この式は、値が参照する場所への参照（ポインター）を生成します。参照の間、メモリ位置も借用状態になります。共有ボロー（ &lt;code&gt;&amp;amp;&lt;/code&gt; ）の場合、これは、場所が変更されていない可能性があることを意味しますが、読み取りまたは共有されている可能性があります。可変ボロー（ &lt;code&gt;&amp;amp;mut&lt;/code&gt; ）の場合、ボローの有効期限が切れるまで、その場所にアクセスすることはできません。 &lt;code&gt;&amp;amp;mut&lt;/code&gt; は、可変の場所式コンテキストでそのオペランドを評価します。場合 &lt;code&gt;&amp;amp;&lt;/code&gt; または &lt;code&gt;&amp;amp;mut&lt;/code&gt; 演算子はAに適用されます&lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;値式の&lt;/a&gt;場合、&lt;a href=&quot;../expressions#temporaries&quot;&gt;一時的な値&lt;/a&gt;が作成されます。</target>
        </trans-unit>
        <trans-unit id="6e0afa92240bade4867a8d2b0fc7bc387cff228f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;&lt;/code&gt; (shared borrow) and &lt;code&gt;&amp;amp;mut&lt;/code&gt; (mutable borrow) operators are unary prefix operators. When applied to a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place expression&lt;/a&gt;, this expressions produces a reference (pointer) to the location that the value refers to. The memory location is also placed into a borrowed state for the duration of the reference. For a shared borrow (&lt;code&gt;&amp;amp;&lt;/code&gt;), this implies that the place may not be mutated, but it may be read or shared again. For a mutable borrow (&lt;code&gt;&amp;amp;mut&lt;/code&gt;), the place may not be accessed in any way until the borrow expires. &lt;code&gt;&amp;amp;mut&lt;/code&gt; evaluates its operand in a mutable place expression context. If the &lt;code&gt;&amp;amp;&lt;/code&gt; or &lt;code&gt;&amp;amp;mut&lt;/code&gt; operators are applied to a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;value expression&lt;/a&gt;, then a &lt;a href=&quot;../expressions#temporary-lifetimes&quot;&gt;temporary value&lt;/a&gt; is created.</source>
          <target state="translated">&lt;code&gt;&amp;amp;&lt;/code&gt; （共有ボロー）と &lt;code&gt;&amp;amp;mut&lt;/code&gt; （可変ボロー）演算子は単項演算子です。&lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;場所の式に&lt;/a&gt;適用すると、この式は値が参照する場所への参照（ポインタ）を生成します。参照の期間中、メモリロケーションも借用状態になります。共有された借用（ &lt;code&gt;&amp;amp;&lt;/code&gt; ）の場合、これは場所が変更されていない可能性があることを意味しますが、再度読み取られたり共有されたりする可能性があります。変更可能な借用（ &lt;code&gt;&amp;amp;mut&lt;/code&gt; ）の場合、借用の期限が切れるまで、場所にアクセスすることはできません。 &lt;code&gt;&amp;amp;mut&lt;/code&gt; は、変更可能な場所式のコンテキストでそのオペランドを評価します。場合 &lt;code&gt;&amp;amp;&lt;/code&gt; または &lt;code&gt;&amp;amp;mut&lt;/code&gt; 演算子はAに適用されます&lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;値式の&lt;/a&gt;場合、&lt;a href=&quot;../expressions#temporary-lifetimes&quot;&gt;一時的な値&lt;/a&gt;が作成されます。</target>
        </trans-unit>
        <trans-unit id="289f7ac6e65862e6021cefdfd8637885846add32" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;&lt;/code&gt; indicates that this argument is a &lt;em&gt;reference&lt;/em&gt;, which gives you a way to let multiple parts of your code access one piece of data without needing to copy that data into memory multiple times. References are a complex feature, and one of Rust&amp;rsquo;s major advantages is how safe and easy it is to use references. You don&amp;rsquo;t need to know a lot of those details to finish this program. For now, all you need to know is that like variables, references are immutable by default. Hence, you need to write &lt;code&gt;&amp;amp;mut guess&lt;/code&gt; rather than &lt;code&gt;&amp;amp;guess&lt;/code&gt; to make it mutable. (Chapter 4 will explain references more thoroughly.)</source>
          <target state="translated">&lt;code&gt;&amp;amp;&lt;/code&gt; この引数があることを示し&lt;em&gt;、参照&lt;/em&gt;あなたのメモリに複数回そのデータをコピーすることなく、データのあなたのコードアクセスワンピースの複数の部分を聞かせする方法を提供します。参照は複雑な機能であり、Rustの主な利点の1つは、参照を使用するのがいかに安全で簡単かです。このプログラムを完了するために、これらの詳細の多くを知る必要はありません。現時点では、変数と同様に、参照はデフォルトで不変であることを知っておく必要があります。したがって、可変にするためには、 &lt;code&gt;&amp;amp;guess&lt;/code&gt; ではなく &lt;code&gt;&amp;amp;mut guess&lt;/code&gt; と記述する必要があります。（第4章では、リファレンスについて詳しく説明します。）</target>
        </trans-unit>
        <trans-unit id="0ba71ec6a87d61177d25877a820fc83d9405b11e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;s1&lt;/code&gt; syntax lets us create a reference that &lt;em&gt;refers&lt;/em&gt; to the value of &lt;code&gt;s1&lt;/code&gt; but does not own it. Because it does not own it, the value it points to will not be dropped when the reference goes out of scope.</source>
          <target state="translated">&lt;code&gt;&amp;amp;s1&lt;/code&gt; 構文は、私たちが参照作成することができます&lt;em&gt;参照&lt;/em&gt;の値に &lt;code&gt;s1&lt;/code&gt; が、それを所有していませんが。それはそれを所有していないので、参照が範囲外になったときに、それが指す値はドロップされません。</target>
        </trans-unit>
        <trans-unit id="ac2092b7195c0e20492c6630d5e4fa162bb49bf5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;str&lt;/code&gt; type guarantees that its contents are UTF-8, and so we can compare the length it would take if each code point was represented as a &lt;code&gt;char&lt;/code&gt; vs in the &lt;code&gt;&amp;amp;str&lt;/code&gt; itself:</source>
          <target state="translated">&lt;code&gt;&amp;amp;str&lt;/code&gt; その内容は、UTF-8であり、そして我々は長さを比較することができるように、各コードポイントは次のように表現された場合、それが取ることタイプ保証 &lt;code&gt;char&lt;/code&gt; で対 &lt;code&gt;&amp;amp;str&lt;/code&gt; 自体：</target>
        </trans-unit>
        <trans-unit id="9573f9c210e855e348b2b66cefde61b52fa3eea1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;str&lt;/code&gt; type is one of the two main string types, the other being &lt;code&gt;String&lt;/code&gt;. Unlike its &lt;code&gt;String&lt;/code&gt; counterpart, its contents are borrowed.</source>
          <target state="translated">&lt;code&gt;&amp;amp;str&lt;/code&gt; タイプは、主に2つの文字列型の一方、他方はのある &lt;code&gt;String&lt;/code&gt; 。その対応する &lt;code&gt;String&lt;/code&gt; とは異なり、その内容は借用されます。</target>
        </trans-unit>
        <trans-unit id="9dd45416e37868ecd085972d08ce3b564e5e5995" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;gt;&lt;/code&gt; syntax tells the shell to write the contents of standard output to &lt;em&gt;output.txt&lt;/em&gt; instead of the screen. We didn&amp;rsquo;t see the error message we were expecting printed to the screen, so that means it must have ended up in the file. This is what &lt;em&gt;output.txt&lt;/em&gt; contains:</source>
          <target state="translated">&lt;code&gt;&amp;gt;&lt;/code&gt; 構文は、標準出力の内容を書くためにシェルに指示&lt;em&gt;output.txtと&lt;/em&gt;画面の代わりに。画面に出力されるはずのエラーメッセージは表示されなかったので、ファイルに出力されているはずです。これは、&lt;em&gt;output.txtに&lt;/em&gt;含まれているもの&lt;em&gt;です&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="b005addd17171fe396053ec0c62812c2c97cade4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; syntax is a feature of Rust we haven&amp;rsquo;t talked about yet. It&amp;rsquo;s a generic type parameter, and we&amp;rsquo;ll cover generics in more detail in Chapter 10. For now, all you need to know is that &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; means the &lt;code&gt;Some&lt;/code&gt; variant of the &lt;code&gt;Option&lt;/code&gt; enum can hold one piece of data of any type. Here are some examples of using &lt;code&gt;Option&lt;/code&gt; values to hold number types and string types:</source>
          <target state="translated">&lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 構文我々はまだについて話していない錆の機能です。これは、ジェネリック型パラメータだ、と私たちは今、第10章のために、より詳細にジェネリック医薬品をカバーするよ、あなたが知る必要があるすべては、それがある &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; を意味 &lt;code&gt;Some&lt;/code&gt; の変種 &lt;code&gt;Option&lt;/code&gt; 列挙は、あらゆるタイプのデータの一片を保持することができます。 &lt;code&gt;Option&lt;/code&gt; 値を使用して数値型と文字列型を保持するいくつかの例を次に示します。</target>
        </trans-unit>
        <trans-unit id="0e8f2a70b6f25c55e2febf941fcc1166aa49e75b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'static&lt;/code&gt; constraint means that the closure and its return value must have a lifetime of the whole program execution. The reason for this is that threads can &lt;code&gt;detach&lt;/code&gt; and outlive the lifetime they have been created in. Indeed if the thread, and by extension its return value, can outlive their caller, we need to make sure that they will be valid afterwards, and since we &lt;em&gt;can't&lt;/em&gt; know when it will return we need to have them valid as long as possible, that is until the end of the program, hence the &lt;code&gt;'static&lt;/code&gt; lifetime.</source>
          <target state="translated">&lt;code&gt;'static&lt;/code&gt; 制約手段は閉鎖し、その戻り値は、プログラム全体の実行の寿命を持っていなければならないこと。これは、スレッドが切り離されて、作成された存続期間よりも長く存続できる &lt;code&gt;detach&lt;/code&gt; です。実際、スレッドと、その戻り値によって、呼び出し元よりも長く存続できる場合は、後で有効になることを確認する必要があります。我々は&lt;em&gt;できません&lt;/em&gt;、それは、我々はプログラムの終わりまでであること、可能な限り、それらに有効な持っている必要がありますので、返されたときに知っている &lt;code&gt;'static&lt;/code&gt; 寿命を。</target>
        </trans-unit>
        <trans-unit id="d507c32a06112cec989a75204d96602b968865dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;()&lt;/code&gt; type has exactly one value &lt;code&gt;()&lt;/code&gt;, and is used when there is no other meaningful value that could be returned. &lt;code&gt;()&lt;/code&gt; is most commonly seen implicitly: functions without a &lt;code&gt;-&amp;gt; ...&lt;/code&gt; implicitly have return type &lt;code&gt;()&lt;/code&gt;, that is, these are equivalent:</source>
          <target state="translated">&lt;code&gt;()&lt;/code&gt; タイプは、1つの値を有する &lt;code&gt;()&lt;/code&gt; 、および返される可能性が他の意味のある値が存在しないときに使用されます。 &lt;code&gt;()&lt;/code&gt; は暗黙的に最もよく見られます： &lt;code&gt;-&amp;gt; ...&lt;/code&gt; ない関数は暗黙的に戻り値の型 &lt;code&gt;()&lt;/code&gt; を持ちます。つまり、これらは同等です：</target>
        </trans-unit>
        <trans-unit id="e3861dba93432d9d5236ce5338f7751eb3d446a6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;()&lt;/code&gt; type, also called &quot;unit&quot;.</source>
          <target state="translated">&lt;code&gt;()&lt;/code&gt; 型は、また、「部」と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="ad7f39bcbd9c29a0b11698eda466dd66f20fff6f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;()&lt;/code&gt; type, sometimes called &quot;unit&quot; or &quot;nil&quot;.</source>
          <target state="translated">&lt;code&gt;()&lt;/code&gt; 型は、しばしば「単位」または「ゼロ」と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="918cd095e0c314aaf612bef93955c593d22df666" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;(*m)&lt;/code&gt; dereferences the &lt;code&gt;MyBox&amp;lt;String&amp;gt;&lt;/code&gt; into a &lt;code&gt;String&lt;/code&gt;. Then the &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;[..]&lt;/code&gt; take a string slice of the &lt;code&gt;String&lt;/code&gt; that is equal to the whole string to match the signature of &lt;code&gt;hello&lt;/code&gt;. The code without deref coercions is harder to read, write, and understand with all of these symbols involved. Deref coercion allows Rust to handle these conversions for us automatically.</source>
          <target state="translated">&lt;code&gt;(*m)&lt;/code&gt; は逆参照 &lt;code&gt;MyBox&amp;lt;String&amp;gt;&lt;/code&gt; に &lt;code&gt;String&lt;/code&gt; 。次いで &lt;code&gt;&amp;amp;&lt;/code&gt; と &lt;code&gt;[..]&lt;/code&gt; の文字列スライス取る &lt;code&gt;String&lt;/code&gt; の署名と一致する文字列全体に等しい &lt;code&gt;hello&lt;/code&gt; 。 deref強制を使用しないコードは、これらすべてのシンボルが関係しているため、読み取り、書き込み、および理解が困難です。 Deref強制により、Rustはこれらの変換を自動的に処理できます。</target>
        </trans-unit>
        <trans-unit id="dceab58b2710b9293ff102afe19580771458da84" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*&lt;/code&gt; (dereference) operator is also a unary prefix operator. When applied to a &lt;a href=&quot;../types/pointer&quot;&gt;pointer&lt;/a&gt; it denotes the pointed-to location. If the expression is of type &lt;code&gt;&amp;amp;mut T&lt;/code&gt; and &lt;code&gt;*mut T&lt;/code&gt;, and is either a local variable, a (nested) field of a local variable or is a mutable &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place expression&lt;/a&gt;, then the resulting memory location can be assigned to. Dereferencing a raw pointer requires &lt;code&gt;unsafe&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; （間接参照）また、オペレータは単項演算子です。&lt;a href=&quot;../types/pointer&quot;&gt;ポインター&lt;/a&gt;に適用すると、ポイントされた場所を示します。式がタイプ &lt;code&gt;&amp;amp;mut T&lt;/code&gt; および &lt;code&gt;*mut T&lt;/code&gt; であり、ローカル変数、ローカル変数の（ネストされた）フィールド、または変更可能な&lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;場所式の&lt;/a&gt;場合、結果のメモリー位置を割り当てることができます。生のポインタを逆参照するには、 &lt;code&gt;unsafe&lt;/code&gt; はありません。</target>
        </trans-unit>
        <trans-unit id="96c2de9a14471a79061b864ae274566e62ce833a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*&lt;/code&gt; (dereference) operator is also a unary prefix operator. When applied to a &lt;a href=&quot;../types/pointer&quot;&gt;pointer&lt;/a&gt; it denotes the pointed-to location. If the expression is of type &lt;code&gt;&amp;amp;mut T&lt;/code&gt; or &lt;code&gt;*mut T&lt;/code&gt;, and is either a local variable, a (nested) field of a local variable or is a mutable &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place expression&lt;/a&gt;, then the resulting memory location can be assigned to. Dereferencing a raw pointer requires &lt;code&gt;unsafe&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; （間接参照）また、オペレータは単項演算子です。&lt;a href=&quot;../types/pointer&quot;&gt;ポインタ&lt;/a&gt;に適用されると、それはポイントされた場所を示します。式がタイプ &lt;code&gt;&amp;amp;mut T&lt;/code&gt; または &lt;code&gt;*mut T&lt;/code&gt; であり、ローカル変数、ローカル変数の（ネストされた）フィールド、または可変の&lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;場所式の&lt;/a&gt;いずれかである場合、結果のメモリ位置をに割り当てることができます。生のポインタを逆参照するには、 &lt;code&gt;unsafe&lt;/code&gt; 必要があります。</target>
        </trans-unit>
        <trans-unit id="9081a0fc77deca2ae1677facd10e7e74970f88a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+&lt;/code&gt; syntax is also valid with trait bounds on generic types:</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; の構文は、一般的なタイプの特性の境界にも有効です。</target>
        </trans-unit>
        <trans-unit id="afa4c918a009f5cfb91d99e9fea97354edfccd19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+&lt;/code&gt; type operator was used in an ambiguous context.</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; のタイプのオペレータは、あいまいな文脈で使用されました。</target>
        </trans-unit>
        <trans-unit id="cf7d56124b7814800cfa939450d0c6d38a399da8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; operators may be composed with the &lt;code&gt;=&lt;/code&gt; operator. The expression &lt;code&gt;place_exp OP= value&lt;/code&gt; is equivalent to &lt;code&gt;place_expr = place_expr OP val&lt;/code&gt;. For example, &lt;code&gt;x = x + 1&lt;/code&gt; may be written as &lt;code&gt;x += 1&lt;/code&gt;. Any such expression always has the &lt;a href=&quot;../types/tuple&quot;&gt;&lt;code&gt;unit&lt;/code&gt; type&lt;/a&gt;. These operators can all be overloaded using the trait with the same name as for the normal operation followed by 'Assign', for example, &lt;code&gt;std::ops::AddAssign&lt;/code&gt; is used to overload &lt;code&gt;+=&lt;/code&gt;. As with &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;place_expr&lt;/code&gt; must be a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place expression&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; 、 &lt;code&gt;-&lt;/code&gt; 、 &lt;code&gt;*&lt;/code&gt; 、 &lt;code&gt;/&lt;/code&gt; 、 &lt;code&gt;%&lt;/code&gt; 、 &lt;code&gt;&amp;amp;&lt;/code&gt; 、 &lt;code&gt;|&lt;/code&gt; 、 &lt;code&gt;^&lt;/code&gt; 、 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 、および &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 演算子は &lt;code&gt;=&lt;/code&gt; 演算子で構成できます。式 &lt;code&gt;place_exp OP= value&lt;/code&gt; は &lt;code&gt;place_expr = place_expr OP val&lt;/code&gt; と同等です。たとえば、 &lt;code&gt;x = x + 1&lt;/code&gt; は &lt;code&gt;x += 1&lt;/code&gt; と書くことができます。このような式には常に&lt;a href=&quot;../types/tuple&quot;&gt; &lt;code&gt;unit&lt;/code&gt; タイプがあり&lt;/a&gt;ます。これらの演算子はすべて、通常の操作と同じ名前の「割り当て」が続く特性を持つ特性を使用してオーバーロードできます。次に例を示します。 &lt;code&gt;std::ops::AddAssign&lt;/code&gt; は &lt;code&gt;+=&lt;/code&gt; をオーバーロードするために使用されます。 &lt;code&gt;=&lt;/code&gt; と同様に、 &lt;code&gt;place_expr&lt;/code&gt; は&lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;場所式で&lt;/a&gt;なければなりません。</target>
        </trans-unit>
        <trans-unit id="a770a23638a823405304b5862ae9b043051acefe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-3&lt;/code&gt; is no longer there, because it was consumed in order to see if the iteration should stop, but wasn't placed back into the iterator.</source>
          <target state="translated">&lt;code&gt;-3&lt;/code&gt; それが反復を停止すべきかどうかを確認するために消費されたが、イテレータにバックを置いていなかったため、もはやありません。</target>
        </trans-unit>
        <trans-unit id="8565fcc01087bd00c830a709f76c89a8bec0ee11" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;...&lt;/code&gt; syntax allows us to match to an inclusive range of values. In the following code, when a pattern matches any of the values within the range, that arm will execute:</source>
          <target state="translated">&lt;code&gt;...&lt;/code&gt; 構文は、私たちが値を含む範囲に一致させることができます。次のコードでは、パターンが範囲内のいずれかの値に一致すると、そのアームが実行されます。</target>
        </trans-unit>
        <trans-unit id="a4afeb6b704f2eeee4511dc907c8b58744889e53" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;...&lt;/code&gt; syntax is kept for backwards compatibility.</source>
          <target state="translated">&lt;code&gt;...&lt;/code&gt; 構文は後方互換性のために残されています。</target>
        </trans-unit>
        <trans-unit id="e2e1f03ffc70a6a254885658fe3c94afc796ca12" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;..&lt;/code&gt; and &lt;code&gt;..=&lt;/code&gt; operators will construct an object of one of the &lt;code&gt;std::ops::Range&lt;/code&gt; (or &lt;code&gt;core::ops::Range&lt;/code&gt;) variants, according to the following table:</source>
          <target state="translated">&lt;code&gt;..&lt;/code&gt; と &lt;code&gt;..=&lt;/code&gt; 演算子のいずれかのオブジェクト構築します &lt;code&gt;std::ops::Range&lt;/code&gt; （又は &lt;code&gt;core::ops::Range&lt;/code&gt; ）以下の表によれば、変異体：</target>
        </trans-unit>
        <trans-unit id="92e96dedbdbf92f3e2e6464ed4a171437558a608" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;..&lt;/code&gt; syntax is a &lt;code&gt;RangeFull&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;..&lt;/code&gt; .構文は次のとおりです &lt;code&gt;RangeFull&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e498b96e1f982900a97ac68d2121f886fa57f814" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;..=&lt;/code&gt; syntax allows us to match to an inclusive range of values. In the following code, when a pattern matches any of the values within the range, that arm will execute:</source>
          <target state="translated">&lt;code&gt;..=&lt;/code&gt; 構文は、私たちが値を含む範囲に一致させることができます。次のコードでは、パターンが範囲内の値のいずれかに一致すると、そのアームが実行されます。</target>
        </trans-unit>
        <trans-unit id="fc028c330bc0f9500e9f59b98e8ba94a546679b2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;..=end&lt;/code&gt; syntax is a &lt;code&gt;RangeToInclusive&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;..=end&lt;/code&gt; 構文は次のとおりです &lt;code&gt;RangeToInclusive&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="06bff2e76574f65224a2d8263399ed02a85a5a5f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;..end&lt;/code&gt; syntax is a &lt;code&gt;RangeTo&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;..end&lt;/code&gt; の構文は次のとおりです &lt;code&gt;RangeTo&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e2942c55d614162c6590171ee52a6786d9039b19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;0 measured&lt;/code&gt; statistic is for benchmark tests that measure performance. Benchmark tests are, as of this writing, only available in nightly Rust. See &lt;a href=&quot;https://doc.rust-lang.org/unstable-book/library-features/test.html&quot;&gt;the documentation about benchmark tests&lt;/a&gt; to learn more.</source>
          <target state="translated">&lt;code&gt;0 measured&lt;/code&gt; 統計は、そのメジャーのパフォーマンスベンチマークテストのためです。ベンチマークテストは、これを書いている時点では、夜間のRustでのみ利用できます。詳細について&lt;a href=&quot;https://doc.rust-lang.org/unstable-book/library-features/test.html&quot;&gt;は、ベンチマークテストに関するドキュメントを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="79584c510d0bdac6b79741ca275d743c77143fc8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;3&lt;/code&gt; is no longer there, because it was consumed in order to see if the iteration should stop, but wasn't placed back into the iterator.</source>
          <target state="translated">&lt;code&gt;3&lt;/code&gt; それが反復を停止すべきかどうかを確認するために消費されたが、イテレータにバックを置いていなかったため、もはやありません。</target>
        </trans-unit>
        <trans-unit id="e721998eb3ac8ff36164c3da054ad164e33f55c4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;5&lt;/code&gt; in &lt;code&gt;five&lt;/code&gt; is the function&amp;rsquo;s return value, which is why the return type is &lt;code&gt;i32&lt;/code&gt;. Let&amp;rsquo;s examine this in more detail. There are two important bits: first, the line &lt;code&gt;let x = five();&lt;/code&gt; shows that we&amp;rsquo;re using the return value of a function to initialize a variable. Because the function &lt;code&gt;five&lt;/code&gt; returns a &lt;code&gt;5&lt;/code&gt;, that line is the same as the following:</source>
          <target state="translated">&lt;code&gt;5&lt;/code&gt; 中 &lt;code&gt;five&lt;/code&gt; 戻り値の型である理由である関数の戻り値であり、 &lt;code&gt;i32&lt;/code&gt; 。これをさらに詳しく見てみましょう。重要なビットは2つあります。最初に、行 &lt;code&gt;let x = five();&lt;/code&gt; 関数の戻り値を使用して変数を初期化していることを示しています。機能ので &lt;code&gt;five&lt;/code&gt; 戻る &lt;code&gt;5&lt;/code&gt; 、その行は、次のと同じです。</target>
        </trans-unit>
        <trans-unit id="f64d85c43f38ffb1d9f69e7f8ec2961df3c8d6da" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;::&lt;/code&gt; syntax in the &lt;code&gt;::new&lt;/code&gt; line indicates that &lt;code&gt;new&lt;/code&gt; is an &lt;em&gt;associated function&lt;/em&gt; of the &lt;code&gt;String&lt;/code&gt; type. An associated function is implemented on a type, in this case &lt;code&gt;String&lt;/code&gt;, rather than on a particular instance of a &lt;code&gt;String&lt;/code&gt;. Some languages call this a &lt;em&gt;static method&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;::new&lt;/code&gt; 行の &lt;code&gt;::&lt;/code&gt; 構文は、 &lt;code&gt;new&lt;/code&gt; が &lt;code&gt;String&lt;/code&gt; 型の&lt;em&gt;関連関数&lt;/em&gt;であることを示しています。関連する関数は、 &lt;code&gt;String&lt;/code&gt; の特定のインスタンスではなく、型（この場合は &lt;code&gt;String&lt;/code&gt; ）に実装されます。一部の言語では、これを&lt;em&gt;静的メソッド&lt;/em&gt;と呼びます。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6c666ec2c7e67dbab00bbae26838dd52620a7c41" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;::&lt;/code&gt; token is required before the opening &lt;code&gt;&amp;lt;&lt;/code&gt; for generic arguments to avoid ambiguity with the less-than operator. This is colloquially known as &quot;turbofish&quot; syntax.</source>
          <target state="translated">小なり演算子とのあいまいさを回避するために、ジェネリック引数の開始 &lt;code&gt;&amp;lt;&lt;/code&gt; の前に &lt;code&gt;::&lt;/code&gt; トークンが必要です。これは口語的に「ターボフィッシュ」構文として知られています。</target>
        </trans-unit>
        <trans-unit id="973f4c6b5b84dfca6c5a6d4e2198053b9adfe1f2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;?&lt;/code&gt; operator can be used in functions that have a return type of &lt;code&gt;Result&lt;/code&gt;, because it is defined to work in the same way as the &lt;code&gt;match&lt;/code&gt; expression we defined in Listing 9-6. The part of the &lt;code&gt;match&lt;/code&gt; that requires a return type of &lt;code&gt;Result&lt;/code&gt; is &lt;code&gt;return Err(e)&lt;/code&gt;, so the return type of the function can be a &lt;code&gt;Result&lt;/code&gt; to be compatible with this &lt;code&gt;return&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;?&lt;/code&gt; 演算子は、リスト9-6で定義した &lt;code&gt;match&lt;/code&gt; 式と同じように機能するように定義されているため、戻り値の型が &lt;code&gt;Result&lt;/code&gt; である関数で使用できます。部分 &lt;code&gt;match&lt;/code&gt; の戻り型が必要 &lt;code&gt;Result&lt;/code&gt; ある &lt;code&gt;return Err(e)&lt;/code&gt; 関数の戻り型ができるように、 &lt;code&gt;Result&lt;/code&gt; これに適合するように &lt;code&gt;return&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cb5e33293a6c0d4593bfbf22cfb9c472dd444a9f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;?&lt;/code&gt; operator can be used in functions that have a return type of &lt;code&gt;Result&lt;/code&gt;, because it is defined to work in the same way as the &lt;code&gt;match&lt;/code&gt; expression we defined in Listing 9-6. The part of the &lt;code&gt;match&lt;/code&gt; that requires a return type of &lt;code&gt;Result&lt;/code&gt; is &lt;code&gt;return Err(e)&lt;/code&gt;, so the return type of the function has to be a &lt;code&gt;Result&lt;/code&gt; to be compatible with this &lt;code&gt;return&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;?&lt;/code&gt; 演算子は、リスト9-6で定義した &lt;code&gt;match&lt;/code&gt; 式と同じように機能するように定義されているため、戻り値の型が &lt;code&gt;Result&lt;/code&gt; である関数で使用できます。部分 &lt;code&gt;match&lt;/code&gt; の戻り型が必要 &lt;code&gt;Result&lt;/code&gt; ある &lt;code&gt;return Err(e)&lt;/code&gt; 関数の戻り型がなければならないので、 &lt;code&gt;Result&lt;/code&gt; これに適合するように &lt;code&gt;return&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0ec4c0c2491bd5a54898bf44aa756701f4e9b5fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;?&lt;/code&gt; operator can only be used in functions that have a return type of &lt;code&gt;Result&lt;/code&gt;, because it is defined to work in the same way as the &lt;code&gt;match&lt;/code&gt; expression we defined in Listing 9-6. The part of the &lt;code&gt;match&lt;/code&gt; that requires a return type of &lt;code&gt;Result&lt;/code&gt; is &lt;code&gt;return Err(e)&lt;/code&gt;, so the return type of the function must be a &lt;code&gt;Result&lt;/code&gt; to be compatible with this &lt;code&gt;return&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;?&lt;/code&gt; 演算子は、戻り値の型が &lt;code&gt;Result&lt;/code&gt; の関数でのみ使用できます。これは、リスト9-6で定義した &lt;code&gt;match&lt;/code&gt; 式と同じように機能するように定義されているためです。 &lt;code&gt;Result&lt;/code&gt; の戻り値の型を必要とする &lt;code&gt;match&lt;/code&gt; の部分は &lt;code&gt;return Err(e)&lt;/code&gt; であるため、関数の戻り値の型は、この &lt;code&gt;return&lt;/code&gt; と互換性がある &lt;code&gt;Result&lt;/code&gt; でなければなりません。</target>
        </trans-unit>
        <trans-unit id="bd74ffef5a8c90c3fd4d6d76e29ea8086760c062" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;?&lt;/code&gt; operator eliminates a lot of boilerplate and makes this function&amp;rsquo;s implementation simpler. We could even shorten this code further by chaining method calls immediately after the &lt;code&gt;?&lt;/code&gt;, as shown in Listing 9-8.</source>
          <target state="translated">&lt;code&gt;?&lt;/code&gt; オペレーターは多くのボイラープレートを排除し、この関数の実装をより簡単にします。 &lt;code&gt;?&lt;/code&gt; の直後にメソッド呼び出しをチェーンすることで、このコードをさらに短くすることもできます。リスト9-8に示すように。</target>
        </trans-unit>
        <trans-unit id="69d45072228b4f483bc2426682521ed37346faf8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;?&lt;/code&gt; operator was added to replace &lt;code&gt;try!&lt;/code&gt; and should be used instead. Furthermore, &lt;code&gt;try&lt;/code&gt; is a reserved word in Rust 2018, so if you must use it, you will need to use the &lt;a href=&quot;https://doc.rust-lang.org/nightly/rust-by-example/compatibility/raw_identifiers.html&quot;&gt;raw-identifier syntax&lt;/a&gt;: &lt;code&gt;r#try&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;?&lt;/code&gt; &lt;code&gt;try!&lt;/code&gt; を置き換えるために演算子が追加されました！代わりに使用する必要があります。さらに、 &lt;code&gt;try&lt;/code&gt; はRust 2018の予約語であるため、使用する必要がある場合は、&lt;a href=&quot;https://doc.rust-lang.org/nightly/rust-by-example/compatibility/raw_identifiers.html&quot;&gt;raw-identifier構文&lt;/a&gt;を使用する必要があります： &lt;code&gt;r#try&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c02b9d3c4349fb0a9b0da69a54ee8f956959e334" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;?&lt;/code&gt; placed after a &lt;code&gt;Result&lt;/code&gt; value is defined to work in almost the same way as the &lt;code&gt;match&lt;/code&gt; expressions we defined to handle the &lt;code&gt;Result&lt;/code&gt; values in Listing 9-6. If the value of the &lt;code&gt;Result&lt;/code&gt; is an &lt;code&gt;Ok&lt;/code&gt;, the value inside the &lt;code&gt;Ok&lt;/code&gt; will get returned from this expression, and the program will continue. If the value is an &lt;code&gt;Err&lt;/code&gt;, the &lt;code&gt;Err&lt;/code&gt; will be returned from the whole function as if we had used the &lt;code&gt;return&lt;/code&gt; keyword so the error value gets propagated to the calling code.</source>
          <target state="translated">&lt;code&gt;?&lt;/code&gt; リスト9-6の &lt;code&gt;Result&lt;/code&gt; 値を処理するために定義した &lt;code&gt;match&lt;/code&gt; 式とほぼ同じように機能するように &lt;code&gt;Result&lt;/code&gt; 値が定義された後に配置されます。値ならば &lt;code&gt;Result&lt;/code&gt; ある &lt;code&gt;Ok&lt;/code&gt; 、内部の値 &lt;code&gt;Ok&lt;/code&gt; この式から返されます、そしてプログラムが継続されます。値がある場合 &lt;code&gt;Err&lt;/code&gt; 、 &lt;code&gt;Err&lt;/code&gt; 、我々が使用していたかのように全体の関数から返される &lt;code&gt;return&lt;/code&gt; エラー値は、呼び出し元のコードに伝播されますので、キーワードを。</target>
        </trans-unit>
        <trans-unit id="1dcf74da2de6e2e77e988e297d47588fe8eb0ad5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Alloc&lt;/code&gt; trait is an &lt;code&gt;unsafe&lt;/code&gt; trait for a number of reasons, and implementors must ensure that they adhere to these contracts:</source>
          <target state="translated">&lt;code&gt;Alloc&lt;/code&gt; トレイトは、 &lt;code&gt;unsafe&lt;/code&gt; 、いくつかの理由で特性、および実装者は、彼らがこれらの契約に準拠していることを確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="98e48446e54082f0c926a4f9b0d797094660f773" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;AllocErr&lt;/code&gt; error indicates an allocation failure that may be due to resource exhaustion or to something wrong when combining the given input arguments with this allocator.</source>
          <target state="translated">&lt;code&gt;AllocErr&lt;/code&gt; のエラーは、このアロケータで指定された入力引数を組み合わせた場合、リソースの枯渇または何かが間違っに起因し得る割り振りの失敗を示します。</target>
        </trans-unit>
        <trans-unit id="40c7890578f6b7272b5ec64894b3d7a1fbafa432" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;AllocError&lt;/code&gt; error indicates an allocation failure that may be due to resource exhaustion or to something wrong when combining the given input arguments with this allocator.</source>
          <target state="translated">&lt;code&gt;AllocError&lt;/code&gt; のエラーは、このアロケータで指定された入力引数を組み合わせた場合、リソースの枯渇または何かが間違っに起因し得る割り振りの失敗を示します。</target>
        </trans-unit>
        <trans-unit id="b6575ce6e474af9bb9592c2b7505db384dcb3435" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Backtrace::capture&lt;/code&gt; function may not actually capture a backtrace by default. Its behavior is governed by two environment variables:</source>
          <target state="translated">&lt;code&gt;Backtrace::capture&lt;/code&gt; 機能は、実際には、デフォルトでバックトレースをキャプチャしない場合があります。その動作は、次の2つの環境変数によって制御されます。</target>
        </trans-unit>
        <trans-unit id="a15f84d510941143cdca2ea70c5b85337d8cfce7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Binary&lt;/code&gt; trait should format its output as a number in binary.</source>
          <target state="translated">&lt;code&gt;Binary&lt;/code&gt; 特性は、バイナリの数値として、その出力をフォーマットする必要があります。</target>
        </trans-unit>
        <trans-unit id="379b6b1f35d3ee950871663ac9c0d0834cb49cc4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Box&amp;lt;...&amp;gt;&lt;/code&gt; ensures that the result is of known size, and the pin is required to keep it in the same place in memory.</source>
          <target state="translated">&lt;code&gt;Box&amp;lt;...&amp;gt;&lt;/code&gt; 結果は、既知のサイズのものであり、ピンは、メモリ内の同じ場所でそれを維持するために必要であることを保証します。</target>
        </trans-unit>
        <trans-unit id="a6e3077926ddb39580746ea9c9fb509f4ede0db3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; type is a smart pointer because it implements the &lt;code&gt;Deref&lt;/code&gt; trait, which allows &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; values to be treated like references. When a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; value goes out of scope, the heap data that the box is pointing to is cleaned up as well because of the &lt;code&gt;Drop&lt;/code&gt; trait implementation. Let&amp;rsquo;s explore these two traits in more detail. These two traits will be even more important to the functionality provided by the other smart pointer types we&amp;rsquo;ll discuss in the rest of this chapter.</source>
          <target state="translated">&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 型が実装するためのスマートポインタである &lt;code&gt;Deref&lt;/code&gt; 可能形質、 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 参照ように扱われるべき値。とき &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 値がスコープ外になる、ボックスを指しているヒープデータがよくあるためのようにクリーンアップされた &lt;code&gt;Drop&lt;/code&gt; 形質実装。これら2つの特性をさらに詳しく見てみましょう。これらの2つの特性は、この章の残りの部分で説明する他のスマートポインター型によって提供される機能にとってさらに重要になります。</target>
        </trans-unit>
        <trans-unit id="66f94ad31e24eabd73aee0f8f7b4d3256d1ad7c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; type is ultimately defined as a tuple struct with one element, so Listing 15-8 defines a &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; type in the same way. We&amp;rsquo;ll also define a &lt;code&gt;new&lt;/code&gt; function to match the &lt;code&gt;new&lt;/code&gt; function defined on &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 型は、最終的に一つの要素を持つタプル構造体として定義され、リストので15-8定義A &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; 型と同じ方法です。 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 定義された &lt;code&gt;new&lt;/code&gt; 関数と一致する &lt;code&gt;new&lt;/code&gt; 関数も定義します。</target>
        </trans-unit>
        <trans-unit id="bf6505b6927d963f13c67732403dd5931ac1ed9c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Box&amp;lt;dyn Error&amp;gt;&lt;/code&gt; type is called a &lt;em&gt;trait object&lt;/em&gt;, which we&amp;rsquo;ll talk about in the &lt;a href=&quot;ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;&amp;ldquo;Using Trait Objects that Allow for Values of Different Types&amp;rdquo;&lt;/a&gt; section in Chapter 17. For now, you can read &lt;code&gt;Box&amp;lt;dyn Error&amp;gt;&lt;/code&gt; to mean &amp;ldquo;any kind of error.&amp;rdquo; Using &lt;code&gt;?&lt;/code&gt; in a &lt;code&gt;main&lt;/code&gt; function with this return type is allowed.</source>
          <target state="translated">&lt;code&gt;Box&amp;lt;dyn Error&amp;gt;&lt;/code&gt; タイプと呼ばれる&lt;em&gt;形質オブジェクト&lt;/em&gt;我々はについて話すだろう、&lt;a href=&quot;ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;「さまざまな種類の値を許可使用形質オブジェクト」&lt;/a&gt;あなたが読むことができる、今の第17章でセクションを &lt;code&gt;Box&amp;lt;dyn Error&amp;gt;&lt;/code&gt; に「あらゆる種類のエラー」を意味します。使い方 &lt;code&gt;?&lt;/code&gt; で &lt;code&gt;main&lt;/code&gt; この戻り値の型を持つ関数許可されています。</target>
        </trans-unit>
        <trans-unit id="f421012dfbbefb54564368d8001a12741e0df3e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Box&amp;lt;dyn Error&amp;gt;&lt;/code&gt; type is called a trait object, which we&amp;rsquo;ll talk about in the &lt;a href=&quot;ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;&amp;ldquo;Using Trait Objects that Allow for Values of Different Types&amp;rdquo;&lt;/a&gt; section in Chapter 17. For now, you can read &lt;code&gt;Box&amp;lt;dyn Error&amp;gt;&lt;/code&gt; to mean &amp;ldquo;any kind of error.&amp;rdquo; Using &lt;code&gt;?&lt;/code&gt; in a &lt;code&gt;main&lt;/code&gt; function with this return type is allowed.</source>
          <target state="translated">&lt;code&gt;Box&amp;lt;dyn Error&amp;gt;&lt;/code&gt; タイプは、私たちがについて話すよ形質オブジェクトと呼ばれ、&lt;a href=&quot;ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;「さまざまな種類の値を許可使用形質オブジェクト」&lt;/a&gt;あなたが読むことができる、今の第17章でセクションを &lt;code&gt;Box&amp;lt;dyn Error&amp;gt;&lt;/code&gt; に「あらゆる種類のエラー」を意味します。使い方 &lt;code&gt;?&lt;/code&gt; で &lt;code&gt;main&lt;/code&gt; この戻り値の型を持つ関数許可されています。</target>
        </trans-unit>
        <trans-unit id="7da298387c32437955972d3bd8b7791a6a295347" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BufReader&amp;lt;R&amp;gt;&lt;/code&gt; struct adds buffering to any reader.</source>
          <target state="translated">&lt;code&gt;BufReader&amp;lt;R&amp;gt;&lt;/code&gt; 構造体は、任意のリーダーにバッファリング追加します。</target>
        </trans-unit>
        <trans-unit id="1691172593fd486c5eabaf315f65ace8dbf6dcde" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BufReader&lt;/code&gt; struct adds buffering to any reader.</source>
          <target state="translated">&lt;code&gt;BufReader&lt;/code&gt; の構造体は、任意のリーダーにバッファリングを追加します。</target>
        </trans-unit>
        <trans-unit id="258a1854757eccfe175a683df1ba477ca28eb2bf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;C&lt;/code&gt; Representation</source>
          <target state="translated">&lt;code&gt;C&lt;/code&gt; 表現</target>
        </trans-unit>
        <trans-unit id="13bde6b705c6f0c548e0105a8252725ac6ce4d78" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;C&lt;/code&gt; representation for items has a defined layout. With this layout, the size of items is also stable as long as all fields have a stable size.</source>
          <target state="translated">アイテムの &lt;code&gt;C&lt;/code&gt; 表現には、レイアウトが定義されています。このレイアウトでは、すべてのフィールドのサイズが安定している限り、アイテムのサイズも安定しています。</target>
        </trans-unit>
        <trans-unit id="51da5ab6258546c0e07e79893a79989cd376412d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;C&lt;/code&gt; representation is designed for dual purposes. One purpose is for creating types that are interoperable with the C Language. The second purpose is to create types that you can soundly perform operations on that rely on data layout such as reinterpreting values as a different type.</source>
          <target state="translated">&lt;code&gt;C&lt;/code&gt; の表現は二重の目的のために設計されています。1つの目的は、C言語と相互運用可能な型を作成することです。2番目の目的は、値を別の型として再解釈するなど、データレイアウトに依存する操作を適切に実行できる型を作成することです。</target>
        </trans-unit>
        <trans-unit id="d3b29c11032bb6739237ad8f95e6e66861078b0e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Cacher::new&lt;/code&gt; function takes a generic parameter &lt;code&gt;T&lt;/code&gt;, which we&amp;rsquo;ve defined as having the same trait bound as the &lt;code&gt;Cacher&lt;/code&gt; struct. Then &lt;code&gt;Cacher::new&lt;/code&gt; returns a &lt;code&gt;Cacher&lt;/code&gt; instance that holds the closure specified in the &lt;code&gt;calculation&lt;/code&gt; field and a &lt;code&gt;None&lt;/code&gt; value in the &lt;code&gt;value&lt;/code&gt; field, because we haven&amp;rsquo;t executed the closure yet.</source>
          <target state="translated">&lt;code&gt;Cacher::new&lt;/code&gt; 機能は、一般的なパラメータの取り &lt;code&gt;T&lt;/code&gt; 我々はとしてバインド同じ特性持つものとして定義した、 &lt;code&gt;Cacher&lt;/code&gt; 構造体を。次に、 &lt;code&gt;Cacher::new&lt;/code&gt; は、 &lt;code&gt;calculation&lt;/code&gt; フィールドで指定されたクロージャと &lt;code&gt;value&lt;/code&gt; フィールドに &lt;code&gt;None&lt;/code&gt; 値を保持する &lt;code&gt;Cacher&lt;/code&gt; インスタンスを返します。これは、まだクロージャを実行していないためです。</target>
        </trans-unit>
        <trans-unit id="b4813a8ce2e935eef24c8392e81d63c3906c4494" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Cacher&lt;/code&gt; struct has a &lt;code&gt;calculation&lt;/code&gt; field of the generic type &lt;code&gt;T&lt;/code&gt;. The trait bounds on &lt;code&gt;T&lt;/code&gt; specify that it&amp;rsquo;s a closure by using the &lt;code&gt;Fn&lt;/code&gt; trait. Any closure we want to store in the &lt;code&gt;calculation&lt;/code&gt; field must have one &lt;code&gt;u32&lt;/code&gt; parameter (specified within the parentheses after &lt;code&gt;Fn&lt;/code&gt;) and must return a &lt;code&gt;u32&lt;/code&gt; (specified after the &lt;code&gt;-&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;Cacher&lt;/code&gt; 構造体は、持っている &lt;code&gt;calculation&lt;/code&gt; ジェネリック型のフィールド &lt;code&gt;T&lt;/code&gt; を。 &lt;code&gt;T&lt;/code&gt; のトレイト境界は、 &lt;code&gt;Fn&lt;/code&gt; トレイトを使用してクロージャであることを指定します。 &lt;code&gt;calculation&lt;/code&gt; フィールドに格納するクロージャーには、1つの &lt;code&gt;u32&lt;/code&gt; パラメーター（括弧内で &lt;code&gt;Fn&lt;/code&gt; の後に指定）が必要であり、 &lt;code&gt;u32&lt;/code&gt; （ &lt;code&gt;-&amp;gt;&lt;/code&gt; の後に指定）を返す必要があります。</target>
        </trans-unit>
        <trans-unit id="b2611487755ed0f487d8741cbb5ae43a528fa050" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CannotReallocInPlace&lt;/code&gt; error is used when &lt;code&gt;grow_in_place&lt;/code&gt; or &lt;code&gt;shrink_in_place&lt;/code&gt; were unable to reuse the given memory block for a requested layout.</source>
          <target state="translated">&lt;code&gt;CannotReallocInPlace&lt;/code&gt; の際にエラーが使用さ &lt;code&gt;grow_in_place&lt;/code&gt; 又は &lt;code&gt;shrink_in_place&lt;/code&gt; は、要求されたレイアウトの所与のメモリブロックを再利用することができませんでした。</target>
        </trans-unit>
        <trans-unit id="66ff318ae517f73cd3f13be64857852133418c2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Clone&lt;/code&gt; trait allows you to explicitly create a deep copy of a value, and the duplication process might involve running arbitrary code and copying heap data. See the &lt;a href=&quot;ch04-01-what-is-ownership#ways-variables-and-data-interact-clone&quot;&gt;&amp;ldquo;Ways Variables and Data Interact: Clone&amp;rdquo;&lt;/a&gt; section in Chapter 4 for more information on &lt;code&gt;Clone&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Clone&lt;/code&gt; 特性は、明示的に価値のディープコピーを作成することができ、および複製プロセスは、任意のコードを実行し、ヒープデータをコピー伴うかもしれません。参照&lt;a href=&quot;ch04-01-what-is-ownership#ways-variables-and-data-interact-clone&quot;&gt;：「クローン方法の変数とデータのインターアクト」&lt;/a&gt;の詳細については、第4章のセクションを &lt;code&gt;Clone&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ad03569cf96b66590827b19ede2029d2fc0e960d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Clone&lt;/code&gt; trait for types that cannot be 'implicitly copied'.</source>
          <target state="translated">「暗黙的にコピー」できないタイプの &lt;code&gt;Clone&lt;/code&gt; 特性。</target>
        </trans-unit>
        <trans-unit id="18eff9d7482bec9f52eb9a085d95c11254b36933" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CoerceUnsized&lt;/code&gt; trait takes a struct type. Make sure the type you are providing to &lt;code&gt;CoerceUnsized&lt;/code&gt; is a struct with only the last field containing an unsized type.</source>
          <target state="translated">&lt;code&gt;CoerceUnsized&lt;/code&gt; の特性は、構造体の型を取ります。 &lt;code&gt;CoerceUnsized&lt;/code&gt; に提供する型が、サイズのない型を含む最後のフィールドのみを持つ構造体であることを確認してください。</target>
        </trans-unit>
        <trans-unit id="e548ae9701e88686017ab152887ae716380c763e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Config::new&lt;/code&gt; function definition</source>
          <target state="translated">&lt;code&gt;Config::new&lt;/code&gt; 関数定義</target>
        </trans-unit>
        <trans-unit id="501a0b9d21e10f396777e5d2959bafbe25f146ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Cons&lt;/code&gt; variant will need the size of an &lt;code&gt;i32&lt;/code&gt; plus the space to store the box&amp;rsquo;s pointer data. The &lt;code&gt;Nil&lt;/code&gt; variant stores no values, so it needs less space than the &lt;code&gt;Cons&lt;/code&gt; variant. We now know that any &lt;code&gt;List&lt;/code&gt; value will take up the size of an &lt;code&gt;i32&lt;/code&gt; plus the size of a box&amp;rsquo;s pointer data. By using a box, we&amp;rsquo;ve broken the infinite, recursive chain, so the compiler can figure out the size it needs to store a &lt;code&gt;List&lt;/code&gt; value. Figure 15-2 shows what the &lt;code&gt;Cons&lt;/code&gt; variant looks like now.</source>
          <target state="translated">&lt;code&gt;Cons&lt;/code&gt; バリアントは、サイズが必要になります &lt;code&gt;i32&lt;/code&gt; ボックスのポインタデータを保存するために、プラスのスペースを。 &lt;code&gt;Nil&lt;/code&gt; バリアント店がない値は、それはより少ないスペース必要と &lt;code&gt;Cons&lt;/code&gt; バリアントを。 &lt;code&gt;List&lt;/code&gt; の値が &lt;code&gt;i32&lt;/code&gt; のサイズとボックスのポインターデータのサイズを足したものになることがわかった。ボックスを使用することで、無限で再帰的なチェーンが壊れたため、コンパイラーは &lt;code&gt;List&lt;/code&gt; 値を格納するために必要なサイズを把握できます。図15-2は、現在の &lt;code&gt;Cons&lt;/code&gt; バリアントを示しています。</target>
        </trans-unit>
        <trans-unit id="a626d0216123ae4ac45161a1bdf7e2c4de5ee23a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Cons&lt;/code&gt; variants own the data they hold, so when we create the &lt;code&gt;b&lt;/code&gt; list, &lt;code&gt;a&lt;/code&gt; is moved into &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; owns &lt;code&gt;a&lt;/code&gt;. Then, when we try to use &lt;code&gt;a&lt;/code&gt; again when creating &lt;code&gt;c&lt;/code&gt;, we&amp;rsquo;re not allowed to because &lt;code&gt;a&lt;/code&gt; has been moved.</source>
          <target state="translated">&lt;code&gt;Cons&lt;/code&gt; 私たちが作成するときに、彼らが保持自身のデータをバリアント &lt;code&gt;b&lt;/code&gt; リストを、に移動される &lt;code&gt;b&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; 所有しています。次に、 &lt;code&gt;c&lt;/code&gt; を作成するときに &lt;code&gt;a&lt;/code&gt; を再度使用しようとすると、aが移動されているため &lt;code&gt;a&lt;/code&gt; 使用できません。 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0ddcf60586798598b647a102cf947282e0f109f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Context&lt;/code&gt; of an asynchronous task.</source>
          <target state="translated">非同期タスクの &lt;code&gt;Context&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d2f260e119bb2a2221aaead7149c78bb8d75b87a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Copy&lt;/code&gt; trait allows you to duplicate a value by only copying bits stored on the stack; no arbitrary code is necessary. See the &lt;a href=&quot;ch04-01-what-is-ownership#stack-only-data-copy&quot;&gt;&amp;ldquo;Stack-Only Data: Copy&amp;rdquo;&lt;/a&gt; section in Chapter 4 for more information on &lt;code&gt;Copy&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Copy&lt;/code&gt; トレイトはあなただけのスタックに格納されたビットをコピーして値を複製することができます。任意のコードは必要ありません。参照&lt;a href=&quot;ch04-01-what-is-ownership#stack-only-data-copy&quot;&gt;：「コピースタック専用データ」&lt;/a&gt;の詳細については、第4章のセクションを &lt;code&gt;Copy&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6af89e2c9cf5d947b4b736850c9a97076811fab2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Copy&lt;/code&gt; trait doesn&amp;rsquo;t define any methods to prevent programmers from overloading those methods and violating the assumption that no arbitrary code is being run. That way, all programmers can assume that copying a value will be very fast.</source>
          <target state="translated">&lt;code&gt;Copy&lt;/code&gt; トレイトは、それらのメソッドをオーバーロードし、何も任意のコードが実行されていないことを前提に違反するからプログラマを防止するためのメソッドが定義されていません。このようにして、すべてのプログラマーは、値のコピーが非常に高速であると想定できます。</target>
        </trans-unit>
        <trans-unit id="d9a9d9ddc02bc50daec8b0c1f2146daf65e918a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Copy&lt;/code&gt; trait is implemented by default only on primitive types. If your type only contains primitive types, you'll be able to implement &lt;code&gt;Copy&lt;/code&gt; on it. Otherwise, it won't be possible.</source>
          <target state="translated">&lt;code&gt;Copy&lt;/code&gt; 形質は唯一のプリミティブ型ではデフォルトで実装されています。タイプにプリミティブ型のみが含まれている場合は、そのタイプに &lt;code&gt;Copy&lt;/code&gt; を実装できます。そうでなければ、それは不可能です。</target>
        </trans-unit>
        <trans-unit id="8c62b63ef24786f929500cd4f0e354183f51728d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Copy&lt;/code&gt; trait is rarely required; types that implement &lt;code&gt;Copy&lt;/code&gt; have optimizations available, meaning you don&amp;rsquo;t have to call &lt;code&gt;clone&lt;/code&gt;, which makes the code more concise.</source>
          <target state="translated">&lt;code&gt;Copy&lt;/code&gt; 形質はめったに必要ありません。 &lt;code&gt;Copy&lt;/code&gt; を実装する型は最適化を利用できます。つまり、 &lt;code&gt;clone&lt;/code&gt; を呼び出す必要がないため、コードがより簡潔になります。</target>
        </trans-unit>
        <trans-unit id="19e60de5e2cec4f66ffc273d83b18ba133a29961" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Copy&lt;/code&gt; trait was implemented on a type which contains a field that doesn't implement the &lt;code&gt;Copy&lt;/code&gt; trait.</source>
          <target state="translated">&lt;code&gt;Copy&lt;/code&gt; が実装されていないフィールドが含まタイプに実装されました形質の &lt;code&gt;Copy&lt;/code&gt; 形質を。</target>
        </trans-unit>
        <trans-unit id="5bc1853088c8596ec738b63d0b306b0f2a10680d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Copy&lt;/code&gt; trait was implemented on a type which is neither a struct nor an enum.</source>
          <target state="translated">&lt;code&gt;Copy&lt;/code&gt; 形質は構造体でも列挙でもないタイプに実装されました。</target>
        </trans-unit>
        <trans-unit id="23cc8d6ab49e3b2451486ee83ff4fdc2f0dab312" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Copy&lt;/code&gt; trait was implemented on a type with a &lt;code&gt;Drop&lt;/code&gt; implementation.</source>
          <target state="translated">&lt;code&gt;Copy&lt;/code&gt; 形質が付きタイプに実装された &lt;code&gt;Drop&lt;/code&gt; 実装。</target>
        </trans-unit>
        <trans-unit id="7a2c2f0333db2747594fc8c5736d8f8e947ab10e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Counter&lt;/code&gt; struct has one field named &lt;code&gt;count&lt;/code&gt;. This field holds a &lt;code&gt;u32&lt;/code&gt; value that will keep track of where we are in the process of iterating from 1 to 5. The &lt;code&gt;count&lt;/code&gt; field is private because we want the implementation of &lt;code&gt;Counter&lt;/code&gt; to manage its value. The &lt;code&gt;new&lt;/code&gt; function enforces the behavior of always starting new instances with a value of 0 in the &lt;code&gt;count&lt;/code&gt; field.</source>
          <target state="translated">&lt;code&gt;Counter&lt;/code&gt; 構造体は、一つのフィールドを指名した &lt;code&gt;count&lt;/code&gt; 。このフィールドには、保持している &lt;code&gt;u32&lt;/code&gt; 我々は1から5まで反復の過程のどこにいるのを追跡します値 &lt;code&gt;count&lt;/code&gt; 我々は実装したいので、プライベートでフィールドを &lt;code&gt;Counter&lt;/code&gt; 、その値を管理すること。 &lt;code&gt;new&lt;/code&gt; 機能は、常に0の値を持つ新しいインスタンスを開始する行動強制 &lt;code&gt;count&lt;/code&gt; フィールドを。</target>
        </trans-unit>
        <trans-unit id="e402bbce82e84dd539cf1e138daa2856a0613786" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Debug&lt;/code&gt; trait allows you to print instances of a type for debugging purposes, so you and other programmers using your type can inspect an instance at a particular point in a program&amp;rsquo;s execution.</source>
          <target state="translated">&lt;code&gt;Debug&lt;/code&gt; トレイトは、あなたとあなたのタイプを使用して他のプログラマは、プログラムの実行中に特定のポイントでのインスタンスを検査することができますので、あなたは、デバッグ目的型のインスタンスを印刷することができます。</target>
        </trans-unit>
        <trans-unit id="853b42f22ba0be46a6e5cd03ba34756814292e76" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Debug&lt;/code&gt; trait enables debug formatting in format strings, which you indicate by adding &lt;code&gt;:?&lt;/code&gt; within &lt;code&gt;{}&lt;/code&gt; placeholders.</source>
          <target state="translated">&lt;code&gt;Debug&lt;/code&gt; トレイトを使用すると、追加して示すフォーマット文字列で書式設定のデバッグを可能にしますか &lt;code&gt;:?&lt;/code&gt; &lt;code&gt;{}&lt;/code&gt; プレースホルダー内。</target>
        </trans-unit>
        <trans-unit id="6967ae462b0a2a18036d993e8418edd4a969bd40" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Debug&lt;/code&gt; trait is required, for example, in use of the &lt;code&gt;assert_eq!&lt;/code&gt; macro. This macro prints the values of instances given as arguments if the equality assertion fails so programmers can see why the two instances weren&amp;rsquo;t equal.</source>
          <target state="translated">&lt;code&gt;Debug&lt;/code&gt; 形質が使用中で、例えば、必要とされる &lt;code&gt;assert_eq!&lt;/code&gt; 大きい。このマクロは、等しいアサーションが失敗した場合に引数として指定されたインスタンスの値を出力するので、プログラマは2つのインスタンスが等しくなかった理由を確認できます。</target>
        </trans-unit>
        <trans-unit id="aba43f90e22e0dfd98100913cb543e02752ca675" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Default::default&lt;/code&gt; function is commonly used in combination with the struct update syntax discussed in the &lt;a href=&quot;ch05-01-defining-structs#creating-instances-from-other-instances-with-struct-update-syntax&quot;&gt;&amp;ldquo;Creating Instances From Other Instances With Struct Update Syntax&amp;rdquo;&lt;/a&gt; section in Chapter 5. You can customize a few fields of a struct and then set and use a default value for the rest of the fields by using &lt;code&gt;..Default::default()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Default::default&lt;/code&gt; 機能は、一般的に議論したstruct更新構文と組み合わせて使用される&lt;a href=&quot;ch05-01-defining-structs#creating-instances-from-other-instances-with-struct-update-syntax&quot;&gt;「構造体の更新構文を持つ他のインスタンスからのインスタンスの作成」&lt;/a&gt;に設定して使用するA、あなたは構造体のいくつかのフィールドをカスタマイズすることができます第5章でセクションと &lt;code&gt;..Default::default()&lt;/code&gt; を使用して、残りのフィールドのデフォルト値。</target>
        </trans-unit>
        <trans-unit id="4f7be30b5dee7044de3817ca4c87b66ab54682e4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Default&lt;/code&gt; cannot be derived on an enum for the simple reason that the compiler doesn't know which value to pick by default whereas it can for a struct as long as all its fields implement the &lt;code&gt;Default&lt;/code&gt; trait as well.</source>
          <target state="translated">&lt;code&gt;Default&lt;/code&gt; コンパイラはそれができるのに対し、長いすべてのフィールドが実装としてとして構造体のために、デフォルトで選択する値を知っていないという単純な理由のために列挙型に導くことができない &lt;code&gt;Default&lt;/code&gt; にも形質を。</target>
        </trans-unit>
        <trans-unit id="155c03f436324748d5a47629042098342e63a6ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Default&lt;/code&gt; trait allows you to create a default value for a type. Deriving &lt;code&gt;Default&lt;/code&gt; implements the &lt;code&gt;default&lt;/code&gt; function. The derived implementation of the &lt;code&gt;default&lt;/code&gt; function calls the &lt;code&gt;default&lt;/code&gt; function on each part of the type, meaning all fields or values in the type must also implement &lt;code&gt;Default&lt;/code&gt; to derive &lt;code&gt;Default&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Default&lt;/code&gt; 特性を使用して、型のデフォルト値を作成することができます。 &lt;code&gt;Default&lt;/code&gt; 導出すると、 &lt;code&gt;default&lt;/code&gt; 関数が実装されます。派生実装 &lt;code&gt;default&lt;/code&gt; 機能を呼び出し &lt;code&gt;default&lt;/code&gt; も実装しなければならないタイプのすべてのフィールドまたは値を意味し、タイプの各部分の機能を &lt;code&gt;Default&lt;/code&gt; 導出する &lt;code&gt;Default&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="417d240e17ea189069372338520fb02d077b097b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Default&lt;/code&gt; trait for types which may have meaningful default values.</source>
          <target state="translated">意味のあるデフォルト値を持つタイプの &lt;code&gt;Default&lt;/code&gt; 特性。</target>
        </trans-unit>
        <trans-unit id="e9ffe8630d56067e177ef382279c1fa4ad4f3ea3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Default&lt;/code&gt; trait is required when you use the method &lt;code&gt;unwrap_or_default&lt;/code&gt; on &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; instances, for example. If the &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, the method &lt;code&gt;unwrap_or_default&lt;/code&gt; will return the result of &lt;code&gt;Default::default&lt;/code&gt; for the type &lt;code&gt;T&lt;/code&gt; stored in the &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Default&lt;/code&gt; あなたがメソッドの使用時に特性が要求される &lt;code&gt;unwrap_or_default&lt;/code&gt; の &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 例えばインスタンスを、。場合 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; ありません &lt;code&gt;None&lt;/code&gt; 、メソッド &lt;code&gt;unwrap_or_default&lt;/code&gt; は、結果が返されます &lt;code&gt;Default::default&lt;/code&gt; タイプのための &lt;code&gt;T&lt;/code&gt; に保存された &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="faec1eafc86ec050669e657d677254ae1cc5eb09" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Default&lt;/code&gt; trait was derived on an enum.</source>
          <target state="translated">&lt;code&gt;Default&lt;/code&gt; 形質は列挙型に導出しました。</target>
        </trans-unit>
        <trans-unit id="3bac5d0a36fa049d2b9d797796c56dde34fe6945" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DispatchFromDyn&lt;/code&gt; trait currently can only be implemented for builtin pointer types and structs that are newtype wrappers around them &amp;mdash; that is, the struct must have only one field (except for&lt;code&gt;PhantomData&lt;/code&gt;), and that field must itself implement &lt;code&gt;DispatchFromDyn&lt;/code&gt;.</source>
          <target state="translated">現在、 &lt;code&gt;DispatchFromDyn&lt;/code&gt; トレイトは、組み込みのポインター型とその周りのnewtypeラッパーである構造体に対してのみ実装できます。つまり、構造体は1つのフィールド（ &lt;code&gt;PhantomData&lt;/code&gt; を除く）のみを持ち、そのフィールド自体が &lt;code&gt;DispatchFromDyn&lt;/code&gt; を実装する必要があります。</target>
        </trans-unit>
        <trans-unit id="f4511d27b8bd2f5f7b72a8b815a18a15df561075" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DispatchFromDyn&lt;/code&gt; trait was implemented on something which is not a pointer or a newtype wrapper around a pointer.</source>
          <target state="translated">&lt;code&gt;DispatchFromDyn&lt;/code&gt; の形質はポインタやポインタ周りのnewtypeラッパーではない何かに実装されました。</target>
        </trans-unit>
        <trans-unit id="b6986e696b5a0b081bb4012a05eb9e1b65dcc35b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DraftPost&lt;/code&gt; struct has an &lt;code&gt;add_text&lt;/code&gt; method, so we can add text to &lt;code&gt;content&lt;/code&gt; as before, but note that &lt;code&gt;DraftPost&lt;/code&gt; does not have a &lt;code&gt;content&lt;/code&gt; method defined! So now the program ensures all posts start as draft posts, and draft posts don&amp;rsquo;t have their content available for display. Any attempt to get around these constraints will result in a compiler error.</source>
          <target state="translated">&lt;code&gt;DraftPost&lt;/code&gt; の構造体があり &lt;code&gt;add_text&lt;/code&gt; の我々はにテキストを追加することができますので、この方法を &lt;code&gt;content&lt;/code&gt; 以前のように、しかし、そのノート &lt;code&gt;DraftPost&lt;/code&gt; が持っていない &lt;code&gt;content&lt;/code&gt; 方法が定義されました！したがって、プログラムはすべての投稿がドラフト投稿として開始することを保証し、ドラフト投稿はコンテンツを表示することができません。これらの制約を回避しようとすると、コンパイラエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="b1de117663cb2f27f8306ea33629038001aac2df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Drop&lt;/code&gt; trait is included in the prelude, so we don&amp;rsquo;t need to bring it into scope. We implement the &lt;code&gt;Drop&lt;/code&gt; trait on &lt;code&gt;CustomSmartPointer&lt;/code&gt; and provide an implementation for the &lt;code&gt;drop&lt;/code&gt; method that calls &lt;code&gt;println!&lt;/code&gt;. The body of the &lt;code&gt;drop&lt;/code&gt; function is where you would place any logic that you wanted to run when an instance of your type goes out of scope. We&amp;rsquo;re printing some text here to demonstrate when Rust will call &lt;code&gt;drop&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Drop&lt;/code&gt; 我々はスコープにそれを持参する必要はありませんので、形質は、前奏曲に含まれています。 &lt;code&gt;CustomSmartPointer&lt;/code&gt; に &lt;code&gt;Drop&lt;/code&gt; トレイトを実装し、 &lt;code&gt;println!&lt;/code&gt; を呼び出す &lt;code&gt;drop&lt;/code&gt; メソッドの実装を提供します！。 &lt;code&gt;drop&lt;/code&gt; 関数の本体は、タイプのインスタンスがスコープから外れたときに実行したいロジックを配置する場所です。 Rustが &lt;code&gt;drop&lt;/code&gt; を呼び出すタイミングを示すために、ここにテキストをいくつか印刷しています。</target>
        </trans-unit>
        <trans-unit id="a67a7efec93a37792cb31993e146b2f7a5f7bc09" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Eq&lt;/code&gt; trait has no methods. Its purpose is to signal that for every value of the annotated type, the value is equal to itself. The &lt;code&gt;Eq&lt;/code&gt; trait can only be applied to types that also implement &lt;code&gt;PartialEq&lt;/code&gt;, although not all types that implement &lt;code&gt;PartialEq&lt;/code&gt; can implement &lt;code&gt;Eq&lt;/code&gt;. One example of this is floating point number types: the implementation of floating point numbers states that two instances of the not-a-number (&lt;code&gt;NaN&lt;/code&gt;) value are not equal to each other.</source>
          <target state="translated">&lt;code&gt;Eq&lt;/code&gt; トレイトはメソッドを持っていません。その目的は、注釈付きタイプのすべての値について、値がそれ自体と等しいことを通知することです。 &lt;code&gt;Eq&lt;/code&gt; 特性だけでも実装する型に適用することができ &lt;code&gt;PartialEq&lt;/code&gt; を実装するすべてのタイプではないが、 &lt;code&gt;PartialEq&lt;/code&gt; を実装することができ &lt;code&gt;Eq&lt;/code&gt; 。この1つの例は、浮動小数点数型です。浮動小数点数の実装は、非数（ &lt;code&gt;NaN&lt;/code&gt; ）値の2つのインスタンスが互いに等しくないことを示しています。</target>
        </trans-unit>
        <trans-unit id="339e508d8f9f4467a3c3de396b4c7c19141c661f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;F&lt;/code&gt; type parameter also has the trait bound &lt;code&gt;Send&lt;/code&gt; and the lifetime bound &lt;code&gt;'static&lt;/code&gt;, which are useful in our situation: we need &lt;code&gt;Send&lt;/code&gt; to transfer the closure from one thread to another and &lt;code&gt;'static&lt;/code&gt; because we don&amp;rsquo;t know how long the thread will take to execute. Let&amp;rsquo;s create an &lt;code&gt;execute&lt;/code&gt; method on &lt;code&gt;ThreadPool&lt;/code&gt; that will take a generic parameter of type &lt;code&gt;F&lt;/code&gt; with these bounds:</source>
          <target state="translated">&lt;code&gt;F&lt;/code&gt; の型パラメータもトレイト結合した &lt;code&gt;Send&lt;/code&gt; され、結合寿命 &lt;code&gt;'static&lt;/code&gt; 我々の状況において有用である、：我々は必要が &lt;code&gt;Send&lt;/code&gt; 別と1つのスレッドから閉鎖を転送する &lt;code&gt;'static&lt;/code&gt; 我々は知らないので、どのくらいのスレッドがします実行します。これらの境界を持つタイプ &lt;code&gt;F&lt;/code&gt; のジェネリックパラメーターを取る &lt;code&gt;ThreadPool&lt;/code&gt; の &lt;code&gt;execute&lt;/code&gt; メソッドを作成してみましょう。</target>
        </trans-unit>
        <trans-unit id="44f286163600e21778b5e8ddc538f3f66c2c5215" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;F&lt;/code&gt; type parameter is the one we&amp;rsquo;re concerned with here; the &lt;code&gt;T&lt;/code&gt; type parameter is related to the return value, and we&amp;rsquo;re not concerned with that. We can see that &lt;code&gt;spawn&lt;/code&gt; uses &lt;code&gt;FnOnce&lt;/code&gt; as the trait bound on &lt;code&gt;F&lt;/code&gt;. This is probably what we want as well, because we&amp;rsquo;ll eventually pass the argument we get in &lt;code&gt;execute&lt;/code&gt; to &lt;code&gt;spawn&lt;/code&gt;. We can be further confident that &lt;code&gt;FnOnce&lt;/code&gt; is the trait we want to use because the thread for running a request will only execute that request&amp;rsquo;s closure one time, which matches the &lt;code&gt;Once&lt;/code&gt; in &lt;code&gt;FnOnce&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;F&lt;/code&gt; の型パラメータは、私たちがここに関係しているものです。 &lt;code&gt;T&lt;/code&gt; の型パラメータは、戻り値に関連している、と我々はそれに関係していません。 &lt;code&gt;spawn&lt;/code&gt; が &lt;code&gt;F&lt;/code&gt; にバインドされた特性として &lt;code&gt;FnOnce&lt;/code&gt; を使用していることがわかります。これはおそらく私たちが望んでいることでもあります。最終的には、 &lt;code&gt;execute&lt;/code&gt; で取得した引数を &lt;code&gt;spawn&lt;/code&gt; に渡すからです。私たちは、ことをさらに確信することができ &lt;code&gt;FnOnce&lt;/code&gt; は我々が要求を実行するためのスレッドが唯一の一致する要求の閉鎖1時間、実行されますので、使用したい形質である &lt;code&gt;Once&lt;/code&gt; で &lt;code&gt;FnOnce&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="2cc0c55739bb91f91d10f706c9cab70e100723e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Fn&lt;/code&gt; traits are provided by the standard library. All closures implement at least one of the traits: &lt;code&gt;Fn&lt;/code&gt;, &lt;code&gt;FnMut&lt;/code&gt;, or &lt;code&gt;FnOnce&lt;/code&gt;. We&amp;rsquo;ll discuss the difference between these traits in the &lt;a href=&quot;#capturing-the-environment-with-closures&quot;&gt;&amp;ldquo;Capturing the Environment with Closures&amp;rdquo;&lt;/a&gt; section; in this example, we can use the &lt;code&gt;Fn&lt;/code&gt; trait.</source>
          <target state="translated">&lt;code&gt;Fn&lt;/code&gt; 形質は、標準ライブラリで提供されています。すべてのクロージャーは、 &lt;code&gt;Fn&lt;/code&gt; 、 &lt;code&gt;FnMut&lt;/code&gt; 、または &lt;code&gt;FnOnce&lt;/code&gt; の少なくとも1つの特性を実装します。これらの特性の違いについては、&lt;a href=&quot;#capturing-the-environment-with-closures&quot;&gt;「クロージャーで環境をキャプチャする」&lt;/a&gt;セクションで説明します。この例では、 &lt;code&gt;Fn&lt;/code&gt; トレイトを使用できます。</target>
        </trans-unit>
        <trans-unit id="851722264534e1910cdc1ef4f424b4a4414f9688" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;From&lt;/code&gt; is also very useful when performing error handling. When constructing a function that is capable of failing, the return type will generally be of the form &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;. The &lt;code&gt;From&lt;/code&gt; trait simplifies error handling by allowing a function to return a single error type that encapsulate multiple error types. See the &quot;Examples&quot; section and &lt;a href=&quot;../../book/ch09-00-error-handling&quot;&gt;the book&lt;/a&gt; for more details.</source>
          <target state="translated">エラー処理を実行する際にも非常に便利です。失敗する可能性のある関数を作成する場合、戻り値の型は通常、 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 形式になります。機能は、複数のエラータイプをカプセル化する単一のエラー型を返すすることを可能にすることによって、形質簡素化エラー処理。詳細については、「例」セクションと&lt;a href=&quot;../../book/ch09-00-error-handling&quot;&gt;本&lt;/a&gt;を参照してください。 &lt;code&gt;From&lt;/code&gt; &lt;code&gt;From&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="924c96483cec1214b829647e918270a4c12cbe49" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GeneratorState&lt;/code&gt; enum returned from this function indicates what state the generator is in upon returning. If the &lt;code&gt;Yielded&lt;/code&gt; variant is returned then the generator has reached a suspension point and a value has been yielded out. Generators in this state are available for resumption at a later point.</source>
          <target state="translated">&lt;code&gt;GeneratorState&lt;/code&gt; のこの関数から返される列挙型は、発電機が戻る際にある状態かを示します。場合に &lt;code&gt;Yielded&lt;/code&gt; 変異体は、次に返されるジェネレータは、サスペンションポイントに達し、値がアウトもたらしてきました。この状態のジェネレーターは、後で再開できるようになります。</target>
        </trans-unit>
        <trans-unit id="93144a0b07feb0dfc814fce370a7ec1878fc8518" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GlobalAlloc&lt;/code&gt; trait is an &lt;code&gt;unsafe&lt;/code&gt; trait for a number of reasons, and implementors must ensure that they adhere to these contracts:</source>
          <target state="translated">&lt;code&gt;GlobalAlloc&lt;/code&gt; 特色ある &lt;code&gt;unsafe&lt;/code&gt; 多くの理由のために、形質、および実装者は、彼らがこれらの契約に準拠していることを確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="ac746bf118e800d6204d1b9be35a781fccfa8fc0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Hash&lt;/code&gt; trait allows you to take an instance of a type of arbitrary size and map that instance to a value of fixed size using a hash function. Deriving &lt;code&gt;Hash&lt;/code&gt; implements the &lt;code&gt;hash&lt;/code&gt; method. The derived implementation of the &lt;code&gt;hash&lt;/code&gt; method combines the result of calling &lt;code&gt;hash&lt;/code&gt; on each of the parts of the type, meaning all fields or values must also implement &lt;code&gt;Hash&lt;/code&gt; to derive &lt;code&gt;Hash&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Hash&lt;/code&gt; トレイトを使用すると、任意のサイズの型のインスタンスを取得し、ハッシュ関数を使用して、固定サイズの値にそのインスタンスをマッピングすることができます。派生 &lt;code&gt;Hash&lt;/code&gt; は、 &lt;code&gt;hash&lt;/code&gt; 方式を実装します。派生実装 &lt;code&gt;hash&lt;/code&gt; 法は、呼び出しの結果兼ね備えた &lt;code&gt;hash&lt;/code&gt; も実装しなければならないすべてのフィールドまたは値を意味し、タイプの各部分に &lt;code&gt;Hash&lt;/code&gt; 導出する &lt;code&gt;Hash&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc2c322c74118357f702bcbb43acd3519194cb4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Iterator&lt;/code&gt; trait has a number of different methods with default implementations provided by the standard library; you can find out about these methods by looking in the standard library API documentation for the &lt;code&gt;Iterator&lt;/code&gt; trait. Some of these methods call the &lt;code&gt;next&lt;/code&gt; method in their definition, which is why you&amp;rsquo;re required to implement the &lt;code&gt;next&lt;/code&gt; method when implementing the &lt;code&gt;Iterator&lt;/code&gt; trait.</source>
          <target state="translated">&lt;code&gt;Iterator&lt;/code&gt; 標準ライブラリによって提供されるデフォルトの実装を持つ多数の異なる方法を有する形質。これらのメソッドについては、 &lt;code&gt;Iterator&lt;/code&gt; トレイトの標準ライブラリAPIドキュメントをご覧ください。これらのメソッドの一部は、定義内の &lt;code&gt;next&lt;/code&gt; メソッドを呼び出します。そのため、 &lt;code&gt;Iterator&lt;/code&gt; トレイトを実装するときに &lt;code&gt;next&lt;/code&gt; メソッドを実装する必要があります。</target>
        </trans-unit>
        <trans-unit id="d7674b68a4f6af8a05d48508e05e8b51cf5d1646" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Iterator&lt;/code&gt; trait only requires implementors to define one method: the &lt;code&gt;next&lt;/code&gt; method, which returns one item of the iterator at a time wrapped in &lt;code&gt;Some&lt;/code&gt; and, when iteration is over, returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Iterator&lt;/code&gt; 1つのだけの方法を定義するために実装する必要がトレイト &lt;code&gt;next&lt;/code&gt; に包まれた時に、イテレータの一つのアイテムを返すメソッド、 &lt;code&gt;Some&lt;/code&gt; 反復が終わった時に返さないと、 &lt;code&gt;None&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f9025083930c31cf7871ed20937306b52f26761a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LinkedList&lt;/code&gt; allows pushing and popping elements at either end in constant time.</source>
          <target state="translated">&lt;code&gt;LinkedList&lt;/code&gt; のは、一定の時間内にどちらかの端にある要素をプッシュしてポップできます。</target>
        </trans-unit>
        <trans-unit id="4baf38aed9bf1ffe36a931bbfb0cb77e6aa0a43b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LowerExp&lt;/code&gt; trait should format its output in scientific notation with a lower-case &lt;code&gt;e&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LowerExp&lt;/code&gt; の形質は小文字で科学的表記法でその出力をフォーマットする必要があり &lt;code&gt;e&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dc66d9062a365376bc4e9ff4cb202550c7cc32a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LowerHex&lt;/code&gt; trait should format its output as a number in hexadecimal, with &lt;code&gt;a&lt;/code&gt; through &lt;code&gt;f&lt;/code&gt; in lower case.</source>
          <target state="translated">&lt;code&gt;LowerHex&lt;/code&gt; の形質を用いて、16進数としての出力をフォーマットする必要がありスルー &lt;code&gt;f&lt;/code&gt; 小文字。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3b321c2a56af633f328bf4b8ba254ce361d7a954" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Octal&lt;/code&gt; trait should format its output as a number in base-8.</source>
          <target state="translated">&lt;code&gt;Octal&lt;/code&gt; 形質は、ベース8の数値として、その出力をフォーマットしなければなりません。</target>
        </trans-unit>
        <trans-unit id="eb10a578affd8a62e12f3ef265b344e167e3dcf6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; enum is so useful that it&amp;rsquo;s even included in the prelude; you don&amp;rsquo;t need to bring it into scope explicitly. In addition, so are its variants: you can use &lt;code&gt;Some&lt;/code&gt; and &lt;code&gt;None&lt;/code&gt; directly without the &lt;code&gt;Option::&lt;/code&gt; prefix. The &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; enum is still just a regular enum, and &lt;code&gt;Some(T)&lt;/code&gt; and &lt;code&gt;None&lt;/code&gt; are still variants of type &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 列挙型は、それがさえ前奏曲に含まれていることにとても便利です。明示的にスコープに入れる必要はありません。さらに、そのバリアントも同様です &lt;code&gt;Option::&lt;/code&gt; 接頭辞なしで、 &lt;code&gt;Some&lt;/code&gt; および &lt;code&gt;None&lt;/code&gt; を直接使用できます。 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 列挙型はまだ普通の列挙型であり、 &lt;code&gt;Some(T)&lt;/code&gt; と &lt;code&gt;None&lt;/code&gt; まだ型の変異体ではない &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="757a8b38147115f7267a95ffaa6fac00dcad6a55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Option&lt;/code&gt; type. See &lt;a href=&quot;index&quot;&gt;the module level documentation&lt;/a&gt; for more.</source>
          <target state="translated">&lt;code&gt;Option&lt;/code&gt; タイプ。詳細について&lt;a href=&quot;index&quot;&gt;は、モジュールレベルのドキュメント&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="6ec87aec96d36200bb49beb7ba67c5c626bb7aad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Ord&lt;/code&gt; trait allows you to know that for any two values of the annotated type, a valid ordering will exist. The &lt;code&gt;Ord&lt;/code&gt; trait implements the &lt;code&gt;cmp&lt;/code&gt; method, which returns an &lt;code&gt;Ordering&lt;/code&gt; rather than an &lt;code&gt;Option&amp;lt;Ordering&amp;gt;&lt;/code&gt; because a valid ordering will always be possible. You can only apply the &lt;code&gt;Ord&lt;/code&gt; trait to types that also implement &lt;code&gt;PartialOrd&lt;/code&gt; and &lt;code&gt;Eq&lt;/code&gt; (and &lt;code&gt;Eq&lt;/code&gt; requires &lt;code&gt;PartialEq&lt;/code&gt;). When derived on structs and enums, &lt;code&gt;cmp&lt;/code&gt; behaves the same way as the derived implementation for &lt;code&gt;partial_cmp&lt;/code&gt; does with &lt;code&gt;PartialOrd&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Ord&lt;/code&gt; 特性を使用すると、注釈付きのタイプのいずれか2つの値のために、有効な順序が存在することを知ることができます。 &lt;code&gt;Ord&lt;/code&gt; 実装に特色 &lt;code&gt;cmp&lt;/code&gt; 返すメソッド、 &lt;code&gt;Ordering&lt;/code&gt; するのではなく &lt;code&gt;Option&amp;lt;Ordering&amp;gt;&lt;/code&gt; 有効な順序が常に可能になりますので。 &lt;code&gt;Ord&lt;/code&gt; トレイトは、 &lt;code&gt;PartialOrd&lt;/code&gt; と &lt;code&gt;Eq&lt;/code&gt; も実装する型にのみ適用できます（ &lt;code&gt;Eq&lt;/code&gt; には &lt;code&gt;PartialEq&lt;/code&gt; が必要です）。構造体および列挙型で派生した場合、 &lt;code&gt;cmp&lt;/code&gt; は &lt;code&gt;PartialOrd&lt;/code&gt; での &lt;code&gt;partial_cmp&lt;/code&gt; の派生実装と同じように動作します。</target>
        </trans-unit>
        <trans-unit id="711a8eb9ad73721345ff8b7d5d49057eb05ba2c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Orphan Check&lt;/code&gt; states that every trait implementation must meet either of the following conditions:</source>
          <target state="translated">&lt;code&gt;Orphan Check&lt;/code&gt; すべての特性の実装は以下のいずれかの条件を満たさなければならないと述べました：</target>
        </trans-unit>
        <trans-unit id="c00d178bf6b2317cc12ea4871792b476ee2d6ac7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PartialEq&lt;/code&gt; trait allows you to compare instances of a type to check for equality and enables use of the &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; operators.</source>
          <target state="translated">&lt;code&gt;PartialEq&lt;/code&gt; トレイトを使用すると、等価性をチェックするために型のインスタンスを比較することができますし、使用可能 &lt;code&gt;==&lt;/code&gt; と &lt;code&gt;!=&lt;/code&gt; 演算子を。</target>
        </trans-unit>
        <trans-unit id="43e89dc3eb492904f3da074b02b2cf97b105430c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PartialEq&lt;/code&gt; trait is required, for example, with the use of the &lt;code&gt;assert_eq!&lt;/code&gt; macro, which needs to be able to compare two instances of a type for equality.</source>
          <target state="translated">&lt;code&gt;PartialEq&lt;/code&gt; の形質はを使用して、例えば、必要とされる &lt;code&gt;assert_eq!&lt;/code&gt; マクロ。型の2つのインスタンスが等しいかどうかを比較できる必要があります。</target>
        </trans-unit>
        <trans-unit id="a3b5763e3772b503d126748c966660daf7b02e86" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PartialOrd&lt;/code&gt; trait allows you to compare instances of a type for sorting purposes. A type that implements &lt;code&gt;PartialOrd&lt;/code&gt; can be used with the &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, and &lt;code&gt;&amp;gt;=&lt;/code&gt; operators. You can only apply the &lt;code&gt;PartialOrd&lt;/code&gt; trait to types that also implement &lt;code&gt;PartialEq&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;PartialOrd&lt;/code&gt; の特性を使用すると、ソートするために型のインスタンスを比較することができます。 &lt;code&gt;PartialOrd&lt;/code&gt; を実装する型は、 &lt;code&gt;&amp;lt;&lt;/code&gt; 、 &lt;code&gt;&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;=&lt;/code&gt; 、および &lt;code&gt;&amp;gt;=&lt;/code&gt; 演算子で使用できます。あなただけ適用することができます &lt;code&gt;PartialOrd&lt;/code&gt; のも実装する型に形質を &lt;code&gt;PartialEq&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="d44604638bc3e14fe0790aae9645322a35831c38" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PartialOrd&lt;/code&gt; trait is required, for example, for the &lt;code&gt;gen_range&lt;/code&gt; method from the &lt;code&gt;rand&lt;/code&gt; crate that generates a random value in the range specified by a low value and a high value.</source>
          <target state="translated">&lt;code&gt;PartialOrd&lt;/code&gt; の形質がため、例えば、必要とされる &lt;code&gt;gen_range&lt;/code&gt; のから方法 &lt;code&gt;rand&lt;/code&gt; 低い値と高い値で指定された範囲内のランダム値を生成するクレート。</target>
        </trans-unit>
        <trans-unit id="aa9b33d349ddf99a4aba8a405103bf7fb4c6e253" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Pointer&lt;/code&gt; trait should format its output as a memory location. This is commonly presented as hexadecimal.</source>
          <target state="translated">&lt;code&gt;Pointer&lt;/code&gt; 形質はメモリ場所としてその出力をフォーマットしなければなりません。これは通常、16進数として表示されます。</target>
        </trans-unit>
        <trans-unit id="ab8bbad2b08fc48ec0e5ed2730d22da62501a267" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Range&lt;/code&gt;&lt;code&gt;start..end&lt;/code&gt; contains all values with &lt;code&gt;x &amp;gt;= start&lt;/code&gt; and &lt;code&gt;x &amp;lt; end&lt;/code&gt;. It is empty unless &lt;code&gt;start &amp;lt; end&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Range&lt;/code&gt; &lt;code&gt;start..end&lt;/code&gt; を持つすべての値が含まれ &lt;code&gt;x &amp;gt;= start&lt;/code&gt; および &lt;code&gt;x &amp;lt; end&lt;/code&gt; 。 &lt;code&gt;start &amp;lt; end&lt;/code&gt; ない限り、空です。</target>
        </trans-unit>
        <trans-unit id="b2aa0761be84214baf72bdc665e4aaa54d88ab96" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RangeFrom&lt;/code&gt;&lt;code&gt;start..&lt;/code&gt; contains all values with &lt;code&gt;x &amp;gt;= start&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;RangeFrom&lt;/code&gt; は &lt;code&gt;start..&lt;/code&gt; とすべての値が含まれている &lt;code&gt;x &amp;gt;= start&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="73c149dd90366bce823890f694cf867f1bb0a225" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RangeInclusive&lt;/code&gt;&lt;code&gt;start..=end&lt;/code&gt; contains all values with &lt;code&gt;x &amp;gt;= start&lt;/code&gt; and &lt;code&gt;x &amp;lt;= end&lt;/code&gt;. It is empty unless &lt;code&gt;start &amp;lt;= end&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;RangeInclusive&lt;/code&gt; &lt;code&gt;start..=end&lt;/code&gt; 持つすべての値が含まれ &lt;code&gt;x &amp;gt;= start&lt;/code&gt; および &lt;code&gt;x &amp;lt;= end&lt;/code&gt; 。 &lt;code&gt;start &amp;lt;= end&lt;/code&gt; ない限り、空です。</target>
        </trans-unit>
        <trans-unit id="0cec61b7c44a745e689ab10fff029089cd54c5d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RangeTo&lt;/code&gt;&lt;code&gt;..end&lt;/code&gt; contains all values with &lt;code&gt;x &amp;lt; end&lt;/code&gt;. It cannot serve as an &lt;a href=&quot;../iter/trait.intoiterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; because it doesn't have a starting point.</source>
          <target state="translated">&lt;code&gt;RangeTo&lt;/code&gt; の &lt;code&gt;..end&lt;/code&gt; を持つすべての値が含まれ &lt;code&gt;x &amp;lt; end&lt;/code&gt; 。開始点がないため、&lt;a href=&quot;../iter/trait.intoiterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;として機能できません。</target>
        </trans-unit>
        <trans-unit id="0de78a1c773797166ef937a052ccd5e9331c867f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RangeTo&lt;/code&gt;&lt;code&gt;..end&lt;/code&gt; contains all values with &lt;code&gt;x &amp;lt; end&lt;/code&gt;. It cannot serve as an &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; because it doesn't have a starting point.</source>
          <target state="translated">&lt;code&gt;RangeTo&lt;/code&gt; の &lt;code&gt;..end&lt;/code&gt; を持つすべての値が含まれ &lt;code&gt;x &amp;lt; end&lt;/code&gt; 。開始点がないため、&lt;a href=&quot;../iter/trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;として機能することはできません。</target>
        </trans-unit>
        <trans-unit id="8e2d4326e8450b1f620c09e80702de680708776b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RangeToInclusive&lt;/code&gt;&lt;code&gt;..=end&lt;/code&gt; contains all values with &lt;code&gt;x &amp;lt;= end&lt;/code&gt;. It cannot serve as an &lt;a href=&quot;../iter/trait.intoiterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; because it doesn't have a starting point.</source>
          <target state="translated">&lt;code&gt;RangeToInclusive&lt;/code&gt; &lt;code&gt;..=end&lt;/code&gt; 持つすべての値が含まれている &lt;code&gt;x &amp;lt;= end&lt;/code&gt; 。開始点がないため、&lt;a href=&quot;../iter/trait.intoiterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;として機能できません。</target>
        </trans-unit>
        <trans-unit id="0729997e88bb0119e0af233dfbcdefc61396cf4d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RangeToInclusive&lt;/code&gt;&lt;code&gt;..=end&lt;/code&gt; contains all values with &lt;code&gt;x &amp;lt;= end&lt;/code&gt;. It cannot serve as an &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; because it doesn't have a starting point.</source>
          <target state="translated">&lt;code&gt;RangeToInclusive&lt;/code&gt; &lt;code&gt;..=end&lt;/code&gt; 持つすべての値が含まれている &lt;code&gt;x &amp;lt;= end&lt;/code&gt; 。開始点がないため、&lt;a href=&quot;../iter/trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;として機能することはできません。</target>
        </trans-unit>
        <trans-unit id="ebdc80637c460a3fe51040149db057ee546f653a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Rc::clone(&amp;amp;from)&lt;/code&gt; syntax is the most idiomatic because it conveys more explicitly the meaning of the code. In the example above, this syntax makes it easier to see that this code is creating a new reference rather than copying the whole content of foo.</source>
          <target state="translated">&lt;code&gt;Rc::clone(&amp;amp;from)&lt;/code&gt; 、それがより明確にコードの意味を伝えるための構文は、最も慣用的です。上記の例では、この構文により、このコードがfooのコンテンツ全体をコピーするのではなく、新しい参照を作成していることが簡単にわかります。</target>
        </trans-unit>
        <trans-unit id="d18566a4555f118c35b2f7296c41294a80e62f05" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Read&lt;/code&gt; trait allows for reading bytes from a source.</source>
          <target state="translated">&lt;code&gt;Read&lt;/code&gt; トレイトは、ソースからバイトを読み込むすることができます。</target>
        </trans-unit>
        <trans-unit id="167de79249a0cb690644cc2f30f26fd674ac84c4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; keeps track of how many &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt; smart pointers are currently active. Every time we call &lt;code&gt;borrow&lt;/code&gt;, the &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; increases its count of how many immutable borrows are active. When a &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt; value goes out of scope, the count of immutable borrows goes down by one. Just like the compile-time borrowing rules, &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; lets us have many immutable borrows or one mutable borrow at any point in time.</source>
          <target state="translated">&lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; を追跡しますどのように多く &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt; と &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt; スマートポインタが現在アクティブです。 &lt;code&gt;borrow&lt;/code&gt; を呼び出すたびに、 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; は、アクティブな不変のボローの数を増やします。ときに &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt; 値がスコープ外になる、不変借りのカウントが1でダウンしました。コンパイル時の借用ルールと &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 、RefCell &amp;lt;T&amp;gt;を使用すると、いつでも多くの不変な借用または1つの変更可能な借用を行うことができます。</target>
        </trans-unit>
        <trans-unit id="2e6771afd6b14e03fc38f6d16106ee1f97bd4cbd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RefCell&lt;/code&gt; is already immutably borrowed, so this cannot fail.</source>
          <target state="translated">&lt;code&gt;RefCell&lt;/code&gt; はすでにimmutably借りているので、これは失敗することはできません。</target>
        </trans-unit>
        <trans-unit id="c305974ea6149ae71e2c43fcd219e993594dd96e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RefCell&lt;/code&gt; is already mutably borrowed, so this cannot fail.</source>
          <target state="translated">&lt;code&gt;RefCell&lt;/code&gt; はすでにmutably借りているので、これは失敗することはできません。</target>
        </trans-unit>
        <trans-unit id="52b1edfc20b8e3433cc429a2a34dab08626e2ce2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Result&amp;lt;..., Error&amp;gt;&lt;/code&gt; is repeated a lot. As such, &lt;code&gt;std::io&lt;/code&gt; has this type of alias declaration:</source>
          <target state="translated">&lt;code&gt;Result&amp;lt;..., Error&amp;gt;&lt;/code&gt; 多くのことを繰り返しています。そのため、 &lt;code&gt;std::io&lt;/code&gt; は次のタイプのエイリアス宣言があります。</target>
        </trans-unit>
        <trans-unit id="1e71572578c618ddeccc701e84d14574b4552896" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Result&lt;/code&gt; enum is generic over two types, &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;E&lt;/code&gt;, and has two variants: &lt;code&gt;Ok&lt;/code&gt;, which holds a value of type &lt;code&gt;T&lt;/code&gt;, and &lt;code&gt;Err&lt;/code&gt;, which holds a value of type &lt;code&gt;E&lt;/code&gt;. This definition makes it convenient to use the &lt;code&gt;Result&lt;/code&gt; enum anywhere we have an operation that might succeed (return a value of some type &lt;code&gt;T&lt;/code&gt;) or fail (return an error of some type &lt;code&gt;E&lt;/code&gt;). In fact, this is what we used to open a file in Listing 9-3, where &lt;code&gt;T&lt;/code&gt; was filled in with the type &lt;code&gt;std::fs::File&lt;/code&gt; when the file was opened successfully and &lt;code&gt;E&lt;/code&gt; was filled in with the type &lt;code&gt;std::io::Error&lt;/code&gt; when there were problems opening the file.</source>
          <target state="translated">&lt;code&gt;Result&lt;/code&gt; 列挙型の2種類、オーバー総称である &lt;code&gt;T&lt;/code&gt; と &lt;code&gt;E&lt;/code&gt; 、および2つのバリエーションがあります。 &lt;code&gt;Ok&lt;/code&gt; 型の値を保持、 &lt;code&gt;T&lt;/code&gt; 、および &lt;code&gt;Err&lt;/code&gt; 型の値を保持し、 &lt;code&gt;E&lt;/code&gt; を。この定義により、成功（ &lt;code&gt;T&lt;/code&gt; 型の値を返す）または失敗（ &lt;code&gt;E&lt;/code&gt; 型のエラーを返す）できる操作がある場合は、どこでも &lt;code&gt;Result&lt;/code&gt; enum を使用するのが便利になります。実際、これはリスト9-3でファイルを開くために使用したものです。ファイルが正常に開かれたときに &lt;code&gt;T&lt;/code&gt; に &lt;code&gt;std::fs::File&lt;/code&gt; タイプが入力され、 &lt;code&gt;E&lt;/code&gt; タイプ &lt;code&gt;std::io::Error&lt;/code&gt; が入力されましたが、ファイルを開くときに問題が発生しました。</target>
        </trans-unit>
        <trans-unit id="67d17ec2155cc71f4cbd159b4631b04d17855080" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Result&lt;/code&gt; types are &lt;a href=&quot;ch06-00-enums&quot;&gt;&lt;em&gt;enumerations&lt;/em&gt;&lt;/a&gt;, often referred to as &lt;em&gt;enums&lt;/em&gt;. An enumeration is a type that can have a fixed set of values, and those values are called the enum&amp;rsquo;s &lt;em&gt;variants&lt;/em&gt;. Chapter 6 will cover enums in more detail.</source>
          <target state="translated">&lt;code&gt;Result&lt;/code&gt; タイプがあります&lt;a href=&quot;ch06-00-enums&quot;&gt;&lt;em&gt;列挙型&lt;/em&gt;&lt;/a&gt;が多いと呼ばれる、&lt;em&gt;列挙型&lt;/em&gt;。列挙型は、固定された値のセットを持つことができるタイプであり、それらの値は列挙型の&lt;em&gt;バリアント&lt;/em&gt;と呼ばれ&lt;em&gt;ます&lt;/em&gt;。第6章では、列挙型についてさらに詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="64d4c779a9a53da0609d26369514238e751f0a8e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Seek&lt;/code&gt; trait provides a cursor which can be moved within a stream of bytes.</source>
          <target state="translated">&lt;code&gt;Seek&lt;/code&gt; 形質はバイトストリーム内で移動することができるカーソルを提供します。</target>
        </trans-unit>
        <trans-unit id="45132395a8da1a9af17f15db9b29d073d0c74c5d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Self&lt;/code&gt; keyword is an alias for the type we&amp;rsquo;re implementing the traits or methods on. Trait objects must be object safe because once you&amp;rsquo;ve used a trait object, Rust no longer knows the concrete type that&amp;rsquo;s implementing that trait. If a trait method returns the concrete &lt;code&gt;Self&lt;/code&gt; type, but a trait object forgets the exact type that &lt;code&gt;Self&lt;/code&gt; is, there is no way the method can use the original concrete type. The same is true of generic type parameters that are filled in with concrete type parameters when the trait is used: the concrete types become part of the type that implements the trait. When the type is forgotten through the use of a trait object, there is no way to know what types to fill in the generic type parameters with.</source>
          <target state="translated">&lt;code&gt;Self&lt;/code&gt; キーワードは、我々は上の特性やメソッドを実装しているタイプの別名です。いったんトレイトオブジェクトを使用すると、Rustはそのトレイトを実装している具象型を認識できなくなるため、トレイトオブジェクトはオブジェクトセーフである必要があります。トレイトメソッドが具体的な &lt;code&gt;Self&lt;/code&gt; タイプを返すが、トレイトオブジェクトが &lt;code&gt;Self&lt;/code&gt; の正確なタイプを忘れた場合、メソッドが元の具体的なタイプを使用する方法はありません。特性が使用されるときに具象型パラメーターで埋められるジェネリック型パラメーターにも同じことが当てはまります。具象型は、特性を実装する型の一部になります。特性オブジェクトを使用して型を忘れた場合、ジェネリック型パラメーターに入力する型を知る方法はありません。</target>
        </trans-unit>
        <trans-unit id="90a76b71efb75f391d26231783f81feb6c797a7f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Self&lt;/code&gt; keyword represents the current type, which explains why it can only be used inside an impl, trait, or type definition. It gives access to the associated items of a type:</source>
          <target state="translated">&lt;code&gt;Self&lt;/code&gt; キーワードは、それが唯一のimpl、特性、または型定義の内部で使用することができる理由を説明し、現在のタイプを表します。タイプの関連アイテムへのアクセスを提供します。</target>
        </trans-unit>
        <trans-unit id="a02332e854d71300403fa93482ff8605d97eadb6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Self&lt;/code&gt; keyword was used outside an impl, trait, or type definition.</source>
          <target state="translated">&lt;code&gt;Self&lt;/code&gt; キーワードはIMPL、特性、または型定義外で使用されました。</target>
        </trans-unit>
        <trans-unit id="6a3c6ecd1deb9539342b4b667c8f7da5207114d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Self&lt;/code&gt; term can be replaced with the type being implemented.</source>
          <target state="translated">&lt;code&gt;Self&lt;/code&gt; 用語は、型が実装されていると交換することができます。</target>
        </trans-unit>
        <trans-unit id="268068ec98ee8d589f1d0d25a4fa87cb52fefae1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Self&lt;/code&gt; terminal in this grammar denotes a type resolving to the implementing type. This can also include the contextual type alias &lt;code&gt;Self&lt;/code&gt;, other type aliases, or associated type projections resolving to the implementing type.</source>
          <target state="translated">この文法の &lt;code&gt;Self&lt;/code&gt; ターミナルは、実装タイプに解決されるタイプを示します。これには、コンテキストタイプエイリアス &lt;code&gt;Self&lt;/code&gt; 、他のタイプエイリアス、または実装タイプに解決される関連タイププロジェクションを含めることもできます。</target>
        </trans-unit>
        <trans-unit id="5d50619fe26b234beecf764a55ec164440b77b3f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Send&lt;/code&gt; marker trait indicates that ownership of the type implementing &lt;code&gt;Send&lt;/code&gt; can be transferred between threads. Almost every Rust type is &lt;code&gt;Send&lt;/code&gt;, but there are some exceptions, including &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;: this cannot be &lt;code&gt;Send&lt;/code&gt; because if you cloned an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; value and tried to transfer ownership of the clone to another thread, both threads might update the reference count at the same time. For this reason, &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; is implemented for use in single-threaded situations where you don&amp;rsquo;t want to pay the thread-safe performance penalty.</source>
          <target state="translated">&lt;code&gt;Send&lt;/code&gt; タイプ実装の所有権を示し形質マーカー &lt;code&gt;Send&lt;/code&gt; スレッド間で転送することができます。ほぼすべての錆タイプがされて &lt;code&gt;Send&lt;/code&gt; ますが、を含むいくつかの例外がある &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; ：これはできません &lt;code&gt;Send&lt;/code&gt; ますが、クローン化された場合ので、 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 値と別のスレッドへのクローンの転送所有しようとしたが、両方のスレッドが更新かもしれません同時に参照カウント。このため、 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; は、スレッドセーフなパフォーマンスのペナルティを支払う必要がないシングルスレッドの状況で使用するために実装されています。</target>
        </trans-unit>
        <trans-unit id="da7504f8cf4ba12a9f166abe295fe49d0cc29f7f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Sized&lt;/code&gt; trait is a special trait built-in to the compiler for types with a constant size known at compile-time. This trait is automatically implemented for types as needed by the compiler, and it is currently disallowed to explicitly implement it for a type.</source>
          <target state="translated">&lt;code&gt;Sized&lt;/code&gt; 特色は、ビルトインタイプのためのコンパイラにコンパイル時に知られている一定の大きさで、特別な形質です。この特性は、コンパイラによって必要に応じて型に対して自動的に実装されます。現在、型に対して明示的に実装することは許可されていません。</target>
        </trans-unit>
        <trans-unit id="faed9283b4f09789ea3439cf47c62be8b01765b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Sized&lt;/code&gt; trait was implemented explicitly.</source>
          <target state="translated">&lt;code&gt;Sized&lt;/code&gt; 特徴は、明示的に実装されました。</target>
        </trans-unit>
        <trans-unit id="57ed07b6ec3a8248f3dbedbfe819f564dab9a89c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Some(5)&lt;/code&gt; value doesn&amp;rsquo;t match the pattern &lt;code&gt;None&lt;/code&gt;, so we continue to the next arm.</source>
          <target state="translated">&lt;code&gt;Some(5)&lt;/code&gt; 値は、パターンと一致しません &lt;code&gt;None&lt;/code&gt; 、我々は次の腕に続けて、。</target>
        </trans-unit>
        <trans-unit id="5cf7d1bcd1b02d8684f384aeb150bd3c1fada36f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;State&lt;/code&gt; trait defines the behavior shared by different post states, and the &lt;code&gt;Draft&lt;/code&gt;, &lt;code&gt;PendingReview&lt;/code&gt;, and &lt;code&gt;Published&lt;/code&gt; states will all implement the &lt;code&gt;State&lt;/code&gt; trait. For now, the trait doesn&amp;rsquo;t have any methods, and we&amp;rsquo;ll start by defining just the &lt;code&gt;Draft&lt;/code&gt; state because that is the state we want a post to start in.</source>
          <target state="translated">&lt;code&gt;State&lt;/code&gt; 特色は、異なるポスト状態で共有する動作を定義し、 &lt;code&gt;Draft&lt;/code&gt; 、 &lt;code&gt;PendingReview&lt;/code&gt; 、および &lt;code&gt;Published&lt;/code&gt; 状態がすべて実装する &lt;code&gt;State&lt;/code&gt; 形質を。今のところ、トレイトにはメソッドがありません。投稿を開始する状態であるため、 &lt;code&gt;Draft&lt;/code&gt; 状態のみを定義することから始めます。</target>
        </trans-unit>
        <trans-unit id="a99c80ac2ff235e2978574f670cbd4660bb61703" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;String&lt;/code&gt; type implements the &lt;code&gt;Clone&lt;/code&gt; trait, and when we call the &lt;code&gt;clone&lt;/code&gt; method on an instance of &lt;code&gt;String&lt;/code&gt; we get back an instance of &lt;code&gt;String&lt;/code&gt;. Similarly, if we call &lt;code&gt;clone&lt;/code&gt; on an instance of &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, we get back an instance of &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;. The signature of &lt;code&gt;clone&lt;/code&gt; needs to know what type will stand in for &lt;code&gt;Self&lt;/code&gt;, because that&amp;rsquo;s the return type.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 型実装 &lt;code&gt;Clone&lt;/code&gt; 特性、そして私たちが呼ぶ &lt;code&gt;clone&lt;/code&gt; のインスタンス上のメソッド &lt;code&gt;String&lt;/code&gt; 我々はのインスタンス取り戻す &lt;code&gt;String&lt;/code&gt; 。私たちが呼ぶならば同様に、 &lt;code&gt;clone&lt;/code&gt; のインスタンスに &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 、我々はのインスタンス取り戻す &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 。 &lt;code&gt;clone&lt;/code&gt; のシグネチャは、 &lt;code&gt;Self&lt;/code&gt; の代わりになるタイプを知る必要があります。これは、それが戻り値のタイプだからです。</target>
        </trans-unit>
        <trans-unit id="ce3a0f98cdb5c97fe7ff53bab286ef96b0a0614f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;String&lt;/code&gt; type is the most common string type that has ownership over the contents of the string. It has a close relationship with its borrowed counterpart, the primitive &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; タイプは、文字列の内容以上の所有権を持っている最も一般的な文字列型です。これは、借用した対応するプリミティブ&lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt;と密接な関係があります。</target>
        </trans-unit>
        <trans-unit id="75cb7ba1e6deab5f4a0c4ef1dddcb7ea6d8d2520" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;String&lt;/code&gt; type, which is provided by Rust&amp;rsquo;s standard library rather than coded into the core language, is a growable, mutable, owned, UTF-8 encoded string type. When Rustaceans refer to &amp;ldquo;strings&amp;rdquo; in Rust, they usually mean the &lt;code&gt;String&lt;/code&gt; and the string slice &lt;code&gt;&amp;amp;str&lt;/code&gt; types, not just one of those types. Although this section is largely about &lt;code&gt;String&lt;/code&gt;, both types are used heavily in Rust&amp;rsquo;s standard library, and both &lt;code&gt;String&lt;/code&gt; and string slices are UTF-8 encoded.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; コア言語に錆の標準ライブラリによって提供されるよりもむしろ符号化されたタイプは、拡張可能な、変更可能な、所有、UTF-8でエンコードされた文字列型です。RustaceansがRustで「文字列」を参照する場合、それらは通常、 &lt;code&gt;String&lt;/code&gt; と文字列スライスの &lt;code&gt;&amp;amp;str&lt;/code&gt; タイプであり、これらのタイプの1つだけではありません。このセクションでは主に &lt;code&gt;String&lt;/code&gt; について説明していますが、どちらのタイプもRustの標準ライブラリで頻繁に使用されており、 &lt;code&gt;String&lt;/code&gt; とstringスライスの両方がUTF-8でエンコードされています。</target>
        </trans-unit>
        <trans-unit id="e2f29f1c300ba36b21c6a01062d991f47ee83fd6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Sync&lt;/code&gt; and &lt;code&gt;Send&lt;/code&gt; traits, which extend Rust&amp;rsquo;s concurrency guarantees to user-defined types as well as types provided by the standard library</source>
          <target state="translated">&lt;code&gt;Sync&lt;/code&gt; と &lt;code&gt;Send&lt;/code&gt; の標準ライブラリで提供されたユーザー定義型などのタイプに錆の同時実行性の保証を拡張する特性、</target>
        </trans-unit>
        <trans-unit id="546dfd59f5dde2a2d3bad5396a6d76cbe9696aee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Sync&lt;/code&gt; marker trait indicates that it is safe for the type implementing &lt;code&gt;Sync&lt;/code&gt; to be referenced from multiple threads. In other words, any type &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Sync&lt;/code&gt; if &lt;code&gt;&amp;amp;T&lt;/code&gt; (a reference to &lt;code&gt;T&lt;/code&gt;) is &lt;code&gt;Send&lt;/code&gt;, meaning the reference can be sent safely to another thread. Similar to &lt;code&gt;Send&lt;/code&gt;, primitive types are &lt;code&gt;Sync&lt;/code&gt;, and types composed entirely of types that are &lt;code&gt;Sync&lt;/code&gt; are also &lt;code&gt;Sync&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Sync&lt;/code&gt; マーカ特徴は、それが実装タイプのために安全であることを示している &lt;code&gt;Sync&lt;/code&gt; を複数のスレッドから参照されます。つまり、 &lt;code&gt;&amp;amp;T&lt;/code&gt; （ &lt;code&gt;T&lt;/code&gt; への参照）が &lt;code&gt;Send&lt;/code&gt; の場合、タイプ &lt;code&gt;T&lt;/code&gt; はすべて &lt;code&gt;Sync&lt;/code&gt; です。つまり、参照を別のスレッドに安全に送信できます。同様に &lt;code&gt;Send&lt;/code&gt; 、原始的な種類があり &lt;code&gt;Sync&lt;/code&gt; 、および完全にされている種類で構成されるタイプの &lt;code&gt;Sync&lt;/code&gt; またある &lt;code&gt;Sync&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="646e9a46a3198e5aae6cea0647712ac157d7125f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;E&lt;/code&gt; are generic type parameters: we&amp;rsquo;ll discuss generics in more detail in Chapter 10. What you need to know right now is that &lt;code&gt;T&lt;/code&gt; represents the type of the value that will be returned in a success case within the &lt;code&gt;Ok&lt;/code&gt; variant, and &lt;code&gt;E&lt;/code&gt; represents the type of the error that will be returned in a failure case within the &lt;code&gt;Err&lt;/code&gt; variant. Because &lt;code&gt;Result&lt;/code&gt; has these generic type parameters, we can use the &lt;code&gt;Result&lt;/code&gt; type and the functions that the standard library has defined on it in many different situations where the successful value and error value we want to return may differ.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; と &lt;code&gt;E&lt;/code&gt; は、ジェネリック型パラメータです：私たちは、あなたが今知っている必要がありますどのような第10章でより詳細にジェネリックを説明しますということである &lt;code&gt;T&lt;/code&gt; は、内の成功事例に返される値の型を表す &lt;code&gt;Ok&lt;/code&gt; 、バリアントをそして &lt;code&gt;E&lt;/code&gt; は、内故障の場合に返されるエラーの種類を表し &lt;code&gt;Err&lt;/code&gt; バリアント。ので &lt;code&gt;Result&lt;/code&gt; これらのジェネリック型パラメータを持って、我々は使用することができる &lt;code&gt;Result&lt;/code&gt; 標準ライブラリは、我々は返すようにしたい成功した値との誤差値が異なる可能性があり、多くの異なる状況で、それに定義されていることをタイプと機能を。</target>
        </trans-unit>
        <trans-unit id="cb756122c49feafba4692e36792c9ec503818ac1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Thread&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;Thread&lt;/code&gt; タイプ</target>
        </trans-unit>
        <trans-unit id="fadb7c71117e778367444a0d18f0442e8249124b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ThreadPool&lt;/code&gt; will create a channel and hold on to the sending side of the channel.</source>
          <target state="translated">&lt;code&gt;ThreadPool&lt;/code&gt; のは、チャンネルを作成して、チャネルの送信側を保持します。</target>
        </trans-unit>
        <trans-unit id="e48c39ae08cbb88aef00b305b9017512b2fc007b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UnsafeCell&lt;/code&gt; API itself is technically very simple: &lt;a href=&quot;struct.unsafecell#method.get&quot;&gt;&lt;code&gt;.get()&lt;/code&gt;&lt;/a&gt; gives you a raw pointer &lt;code&gt;*mut T&lt;/code&gt; to its contents. It is up to &lt;em&gt;you&lt;/em&gt; as the abstraction designer to use that raw pointer correctly.</source>
          <target state="translated">&lt;code&gt;UnsafeCell&lt;/code&gt; のAPI自体は技術的に非常に単純です：&lt;a href=&quot;struct.unsafecell#method.get&quot;&gt; &lt;code&gt;.get()&lt;/code&gt; &lt;/a&gt;あなたの生のポインタを与える &lt;code&gt;*mut T&lt;/code&gt; その内容に。それは、最大である&lt;em&gt;あなた&lt;/em&gt;が正しくその生のポインタを使用するように抽象化デザイナーとして。</target>
        </trans-unit>
        <trans-unit id="6a5cd0207b32d758dbbf9a6159c66155c77acce0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UnsafeCell&lt;/code&gt; API itself is technically very simple: it gives you a raw pointer &lt;code&gt;*mut T&lt;/code&gt; to its contents. It is up to &lt;em&gt;you&lt;/em&gt; as the abstraction designer to use that raw pointer correctly.</source>
          <target state="translated">&lt;code&gt;UnsafeCell&lt;/code&gt; の API自体は技術的に非常に単純です：それはあなたの生のポインタを与える &lt;code&gt;*mut T&lt;/code&gt; その内容に。生のポインタを正しく使用する&lt;em&gt;かどうか&lt;/em&gt;は、抽象デザイナーの責任です。</target>
        </trans-unit>
        <trans-unit id="0a41c6aadefabb63fa74ac6fccd4136ec47ca08f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UpperExp&lt;/code&gt; trait should format its output in scientific notation with an upper-case &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;UpperExp&lt;/code&gt; の形質は、大文字と科学的表記法でその出力をフォーマットしなければならない &lt;code&gt;E&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c532f0150ba601cb070b0fc006c6b873d809aeda" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UpperHex&lt;/code&gt; trait should format its output as a number in hexadecimal, with &lt;code&gt;A&lt;/code&gt; through &lt;code&gt;F&lt;/code&gt; in upper case.</source>
          <target state="translated">&lt;code&gt;UpperHex&lt;/code&gt; の形質を持つ16進数としての出力、フォーマットする必要があり &lt;code&gt;A&lt;/code&gt; を介して &lt;code&gt;F&lt;/code&gt; を大文字で。</target>
        </trans-unit>
        <trans-unit id="1692dc51a2dd0859a66b3a15d1e8df4859265ffa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Vec&lt;/code&gt; type allows to access values by index, because it implements the &lt;a href=&quot;../ops/trait.index&quot;&gt;&lt;code&gt;Index&lt;/code&gt;&lt;/a&gt; trait. An example will be more explicit:</source>
          <target state="translated">&lt;code&gt;Vec&lt;/code&gt; をする、それが実装しているため種類は、インデックスによるアクセス値にできます&lt;a href=&quot;../ops/trait.index&quot;&gt; &lt;code&gt;Index&lt;/code&gt; &lt;/a&gt;形質を。例はより明確になります：</target>
        </trans-unit>
        <trans-unit id="fdf15f1d79f5be8a81ff6d7d469c446ffbe09215" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;_&lt;/code&gt; pattern will match any value. By putting it after our other arms, the &lt;code&gt;_&lt;/code&gt; will match all the possible cases that aren&amp;rsquo;t specified before it. The &lt;code&gt;()&lt;/code&gt; is just the unit value, so nothing will happen in the &lt;code&gt;_&lt;/code&gt; case. As a result, we can say that we want to do nothing for all the possible values that we don&amp;rsquo;t list before the &lt;code&gt;_&lt;/code&gt; placeholder.</source>
          <target state="translated">&lt;code&gt;_&lt;/code&gt; パターンは任意の値と一致します。他の武器の後に置くことで、 &lt;code&gt;_&lt;/code&gt; はその前に指定されていないすべての可能なケースに一致します。 &lt;code&gt;()&lt;/code&gt; 何もして起こりませんので、ちょうど単位の値である &lt;code&gt;_&lt;/code&gt; ケース。その結果、 &lt;code&gt;_&lt;/code&gt; プレースホルダーの前にリストされていない可能性のあるすべての値に対しては何もしたくないと言えます。</target>
        </trans-unit>
        <trans-unit id="d4f623218e4e907b6db896a6ba8ba2e0737f6051" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;abort&lt;/code&gt; function terminates the process, so the destructor will not get run on the example below:</source>
          <target state="translated">&lt;code&gt;abort&lt;/code&gt; 機能は、処理を終了するので、デストラクタは、以下の例で実行し得ることはありません。</target>
        </trans-unit>
        <trans-unit id="1da31d2d7b88dbadae1ea02224cc02bf279c6b4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;add&lt;/code&gt; method adds the &lt;code&gt;x&lt;/code&gt; values of two &lt;code&gt;Point&lt;/code&gt; instances and the &lt;code&gt;y&lt;/code&gt; values of two &lt;code&gt;Point&lt;/code&gt; instances to create a new &lt;code&gt;Point&lt;/code&gt;. The &lt;code&gt;Add&lt;/code&gt; trait has an associated type named &lt;code&gt;Output&lt;/code&gt; that determines the type returned from the &lt;code&gt;add&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;add&lt;/code&gt; 方法は、追加 &lt;code&gt;x&lt;/code&gt; 2つの値 &lt;code&gt;Point&lt;/code&gt; インスタンスと &lt;code&gt;y&lt;/code&gt; の 2つの値 &lt;code&gt;Point&lt;/code&gt; 新しい作成するために、インスタンスを &lt;code&gt;Point&lt;/code&gt; 。 &lt;code&gt;Add&lt;/code&gt; 形質が名前の関連するタイプがある &lt;code&gt;Output&lt;/code&gt; から返される型を決定する &lt;code&gt;add&lt;/code&gt; 方法を。</target>
        </trans-unit>
        <trans-unit id="6b4f66cfe4d8578da648c05ce2a1d295046eb19d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;add_text&lt;/code&gt; method takes a mutable reference to &lt;code&gt;self&lt;/code&gt;, because we&amp;rsquo;re changing the &lt;code&gt;Post&lt;/code&gt; instance that we&amp;rsquo;re calling &lt;code&gt;add_text&lt;/code&gt; on. We then call &lt;code&gt;push_str&lt;/code&gt; on the &lt;code&gt;String&lt;/code&gt; in &lt;code&gt;content&lt;/code&gt; and pass the &lt;code&gt;text&lt;/code&gt; argument to add to the saved &lt;code&gt;content&lt;/code&gt;. This behavior doesn&amp;rsquo;t depend on the state the post is in, so it&amp;rsquo;s not part of the state pattern. The &lt;code&gt;add_text&lt;/code&gt; method doesn&amp;rsquo;t interact with the &lt;code&gt;state&lt;/code&gt; field at all, but it is part of the behavior we want to support.</source>
          <target state="translated">&lt;code&gt;add_text&lt;/code&gt; の方法は、への変更可能な参照取る &lt;code&gt;self&lt;/code&gt; 我々が変更しているので、 &lt;code&gt;Post&lt;/code&gt; 我々が呼んでいるというインスタンスを &lt;code&gt;add_text&lt;/code&gt; を上。次に、 &lt;code&gt;content&lt;/code&gt; 内の &lt;code&gt;String&lt;/code&gt; &lt;code&gt;push_str&lt;/code&gt; を呼び出し、保存された &lt;code&gt;content&lt;/code&gt; に追加する &lt;code&gt;text&lt;/code&gt; 引数を渡します。この動作は投稿の状態に依存しないため、状態パターンの一部ではありません。 &lt;code&gt;add_text&lt;/code&gt; の方法はと相互作用しない &lt;code&gt;state&lt;/code&gt; すべてのフィールドが、それは我々がサポートしたい行動の一部です。</target>
        </trans-unit>
        <trans-unit id="2c3ad15ad6826ff34548cd3374a6a4eed3efc204" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;align&lt;/code&gt; and &lt;code&gt;packed&lt;/code&gt; modifiers can be used to respectively raise or lower the alignment of &lt;code&gt;struct&lt;/code&gt;s and &lt;code&gt;union&lt;/code&gt;s. &lt;code&gt;packed&lt;/code&gt; may also alter the padding between fields.</source>
          <target state="translated">&lt;code&gt;align&lt;/code&gt; と &lt;code&gt;packed&lt;/code&gt; 改質剤は、アラインメント上げる又は下げるそれぞれに使用することができる &lt;code&gt;struct&lt;/code&gt; Sと &lt;code&gt;union&lt;/code&gt; 秒。 &lt;code&gt;packed&lt;/code&gt; はフィールド間のパディングを変更する場合があります。</target>
        </trans-unit>
        <trans-unit id="0e0634e43790fec0970517f968c2cdaea9942a64" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;align&lt;/code&gt; and &lt;code&gt;packed&lt;/code&gt; modifiers cannot be applied on the same type and a &lt;code&gt;packed&lt;/code&gt; type cannot transitively contain another &lt;code&gt;align&lt;/code&gt;ed type. &lt;code&gt;align&lt;/code&gt; and &lt;code&gt;packed&lt;/code&gt; may only be applied to the &lt;a href=&quot;#the-default-representation&quot;&gt;default&lt;/a&gt; and &lt;a href=&quot;#the-c-representation&quot;&gt;&lt;code&gt;C&lt;/code&gt;&lt;/a&gt; representations.</source>
          <target state="translated">&lt;code&gt;align&lt;/code&gt; と &lt;code&gt;packed&lt;/code&gt; 修飾子は、同じタイプに適用することはできませんし、 &lt;code&gt;packed&lt;/code&gt; タイプが推移別含めることはできません &lt;code&gt;align&lt;/code&gt; EDタイプを。 &lt;code&gt;align&lt;/code&gt; および &lt;code&gt;packed&lt;/code&gt; は、&lt;a href=&quot;#the-default-representation&quot;&gt;デフォルト&lt;/a&gt;および&lt;a href=&quot;#the-c-representation&quot;&gt; &lt;code&gt;C&lt;/code&gt; &lt;/a&gt;表現にのみ適用できます。</target>
        </trans-unit>
        <trans-unit id="ba365c1b081658cee386344e9e2a04962a51bb04" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;align&lt;/code&gt; and &lt;code&gt;packed&lt;/code&gt; modifiers cannot be applied on the same type and a &lt;code&gt;packed&lt;/code&gt; type cannot transitively contain another &lt;code&gt;align&lt;/code&gt;ed type. &lt;code&gt;align&lt;/code&gt; and &lt;code&gt;packed&lt;/code&gt; may only be applied to the &lt;a href=&quot;type-layout#the-default-representation&quot;&gt;default&lt;/a&gt; and &lt;a href=&quot;type-layout#the-c-representation&quot;&gt;&lt;code&gt;C&lt;/code&gt;&lt;/a&gt; representations.</source>
          <target state="translated">&lt;code&gt;align&lt;/code&gt; と &lt;code&gt;packed&lt;/code&gt; 修飾子は、同じタイプに適用することはできませんし、 &lt;code&gt;packed&lt;/code&gt; タイプが推移別含めることはできません &lt;code&gt;align&lt;/code&gt; EDタイプを。 &lt;code&gt;align&lt;/code&gt; と &lt;code&gt;packed&lt;/code&gt; は、&lt;a href=&quot;type-layout#the-default-representation&quot;&gt;デフォルト&lt;/a&gt;と&lt;a href=&quot;type-layout#the-c-representation&quot;&gt; &lt;code&gt;C&lt;/code&gt; の&lt;/a&gt;表現にのみ適用できます。</target>
        </trans-unit>
        <trans-unit id="53e65577e1cfa4684ae0b49bee71e8da03a67fa1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;align&lt;/code&gt; modifier can also be applied on an &lt;code&gt;enum&lt;/code&gt;. When it is, the effect on the &lt;code&gt;enum&lt;/code&gt;'s alignment is the same as if the &lt;code&gt;enum&lt;/code&gt; was wrapped in a newtype &lt;code&gt;struct&lt;/code&gt; with the same &lt;code&gt;align&lt;/code&gt; modifier.</source>
          <target state="translated">&lt;code&gt;align&lt;/code&gt; 調整剤はまた、上に適用することができる &lt;code&gt;enum&lt;/code&gt; 。その場合、 &lt;code&gt;enum&lt;/code&gt; の配置への影響は、 &lt;code&gt;enum&lt;/code&gt; が同じ &lt;code&gt;align&lt;/code&gt; 修飾子でnewtype &lt;code&gt;struct&lt;/code&gt; にラップされた場合と同じです。</target>
        </trans-unit>
        <trans-unit id="6ad8df46a380899eaf26791f29aae33e2b0b76bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;amt&lt;/code&gt; must be &lt;code&gt;&amp;lt;=&lt;/code&gt; the number of bytes in the buffer returned by &lt;a href=&quot;#tymethod.fill_buf&quot;&gt;&lt;code&gt;fill_buf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;amt&lt;/code&gt; である必要があります &lt;code&gt;&amp;lt;=&lt;/code&gt; によって返されるバッファのバイト数&lt;a href=&quot;#tymethod.fill_buf&quot;&gt; &lt;code&gt;fill_buf&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6cdd430203e5d1bc8171135295b8e6a12c3f9ccb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;amt&lt;/code&gt; must be &lt;code&gt;&amp;lt;=&lt;/code&gt; the number of bytes in the buffer returned by &lt;a href=&quot;trait.bufread#tymethod.fill_buf&quot;&gt;&lt;code&gt;fill_buf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;amt&lt;/code&gt; である必要があります &lt;code&gt;&amp;lt;=&lt;/code&gt; によって返されるバッファのバイト数&lt;a href=&quot;trait.bufread#tymethod.fill_buf&quot;&gt; &lt;code&gt;fill_buf&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="45b714d09b6da61ea117e3601d5d1e5fd89a8774" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;approve&lt;/code&gt; method will be similar to the &lt;code&gt;request_review&lt;/code&gt; method: it will set &lt;code&gt;state&lt;/code&gt; to the value that the current state says it should have when that state is approved, as shown in Listing 17-16:</source>
          <target state="translated">&lt;code&gt;approve&lt;/code&gt; 方法は次のようになります &lt;code&gt;request_review&lt;/code&gt; の方法：それが設定されます &lt;code&gt;state&lt;/code&gt; リスト17-16のように現在の状態が、それはその状態が承認されたときに持つべきであると言うことを値に：</target>
        </trans-unit>
        <trans-unit id="0d99e2697c98f4ee00d53c8602d75f85424ebe1a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;area&lt;/code&gt; function accesses the &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; fields of the &lt;code&gt;Rectangle&lt;/code&gt; instance. Our function signature for &lt;code&gt;area&lt;/code&gt; now says exactly what we mean: calculate the area of &lt;code&gt;Rectangle&lt;/code&gt;, using its &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; fields. This conveys that the width and height are related to each other, and it gives descriptive names to the values rather than using the tuple index values of &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt;. This is a win for clarity.</source>
          <target state="translated">&lt;code&gt;area&lt;/code&gt; 機能は、アクセス &lt;code&gt;width&lt;/code&gt; と &lt;code&gt;height&lt;/code&gt; のフィールド &lt;code&gt;Rectangle&lt;/code&gt; インスタンス。 &lt;code&gt;area&lt;/code&gt; の関数シグネチャは、私たちが正確に言っているとおりです。 &lt;code&gt;width&lt;/code&gt; と &lt;code&gt;height&lt;/code&gt; フィールドを使用して、 &lt;code&gt;Rectangle&lt;/code&gt; の面積を計算します。これは、幅と高さが相互に関連していることを示し、タプルインデックス値 &lt;code&gt;0&lt;/code&gt; および &lt;code&gt;1&lt;/code&gt; を使用するのではなく、値にわかりやすい名前を付けます。これは明快さのための勝利です。</target>
        </trans-unit>
        <trans-unit id="f0f4d5c245d843fc107cb0d995f1cc0cbaafe380" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;area&lt;/code&gt; function is supposed to calculate the area of one rectangle, but the function we wrote has two parameters. The parameters are related, but that&amp;rsquo;s not expressed anywhere in our program. It would be more readable and more manageable to group width and height together. We&amp;rsquo;ve already discussed one way we might do that in &lt;a href=&quot;ch03-02-data-types#the-tuple-type&quot;&gt;&amp;ldquo;The Tuple Type&amp;rdquo;&lt;/a&gt; section of Chapter 3: by using tuples.</source>
          <target state="translated">&lt;code&gt;area&lt;/code&gt; 機能は、一つの長方形の面積を算出することになって、私たちが書いた関数は、2つのパラメータがあります。パラメータは関連していますが、プログラムではどこにも表現されていません。幅と高さをグループ化すると、読みやすく、管理しやすくなります。その方法の1つについては、第3章の&lt;a href=&quot;ch03-02-data-types#the-tuple-type&quot;&gt;「タプルタイプ」&lt;/a&gt;セクションでタプルを使用してすでに説明しました。</target>
        </trans-unit>
        <trans-unit id="03663b761515431ad66c10f38033078682c6e595" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;art&lt;/code&gt; crate users can still see and use the internal structure from Listing 14-3 as demonstrated in Listing 14-4, or they can use the more convenient structure in Listing 14-5, as shown in Listing 14-6:</source>
          <target state="translated">&lt;code&gt;art&lt;/code&gt; クレートのユーザーがまだ見て、リスト14-4で示されるように、リスト14-3から内部構造を使用し、または14-6のリストに示すように、彼らは、リスト14-5でより便利な構造を使用することができますすることができます：</target>
        </trans-unit>
        <trans-unit id="e825da57c4a60047ea61533b7c1bd5bca8251591" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;as&lt;/code&gt; keyword can be used to change what the crate is referred to as in your project. If a crate name includes a dash, it is implicitly imported with the dashes replaced by underscores.</source>
          <target state="translated">&lt;code&gt;as&lt;/code&gt; のキーワードは、クレートは、プロジェクト内と呼ばれるものを変更するために使用することができます。クレート名にダッシュが含まれている場合、ダッシュはアンダースコアに置き換えられて暗黙的にインポートされます。</target>
        </trans-unit>
        <trans-unit id="2dd2463e89570fe4f3bb6f6203a6c56b03267f94" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;assert!&lt;/code&gt; macro, provided by the standard library, is useful when you want to ensure that some condition in a test evaluates to &lt;code&gt;true&lt;/code&gt;. We give the &lt;code&gt;assert!&lt;/code&gt; macro an argument that evaluates to a Boolean. If the value is &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;assert!&lt;/code&gt; does nothing and the test passes. If the value is &lt;code&gt;false&lt;/code&gt;, the &lt;code&gt;assert!&lt;/code&gt; macro calls the &lt;code&gt;panic!&lt;/code&gt; macro, which causes the test to fail. Using the &lt;code&gt;assert!&lt;/code&gt; macro helps us check that our code is functioning in the way we intend.</source>
          <target state="translated">&lt;code&gt;assert!&lt;/code&gt; 標準ライブラリによって提供されるマクロは、テスト内のある条件が &lt;code&gt;true&lt;/code&gt; と評価されることを確認したい場合に役立ちます。私たちは与える &lt;code&gt;assert!&lt;/code&gt; マクロはブール値に評価される引数です。値が &lt;code&gt;true&lt;/code&gt; の場合、 &lt;code&gt;assert!&lt;/code&gt; 何もせず、テストに合格します。値が &lt;code&gt;false&lt;/code&gt; の場合、 &lt;code&gt;assert!&lt;/code&gt; マクロは &lt;code&gt;panic!&lt;/code&gt; 呼び出します！テストを失敗させるマクロ。 &lt;code&gt;assert!&lt;/code&gt; を使用して！マクロは、コードが意図したとおりに機能していることを確認するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="95f1355f51c209910ea66191ec2fc57f92344bfc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;assert_ne!&lt;/code&gt; macro will pass if the two values we give it are not equal and fail if they&amp;rsquo;re equal. This macro is most useful for cases when we&amp;rsquo;re not sure what a value &lt;em&gt;will&lt;/em&gt; be, but we know what the value definitely &lt;em&gt;won&amp;rsquo;t&lt;/em&gt; be if our code is functioning as we intend. For example, if we&amp;rsquo;re testing a function that is guaranteed to change its input in some way, but the way in which the input is changed depends on the day of the week that we run our tests, the best thing to assert might be that the output of the function is not equal to the input.</source>
          <target state="translated">&lt;code&gt;assert_ne!&lt;/code&gt; マクロは、指定した2つの値が等しくない場合は通過し、等しい場合は失敗します。このマクロは、値&lt;em&gt;が&lt;/em&gt;どのように&lt;em&gt;なる&lt;/em&gt;かわからない場合に最も役立ちます&lt;em&gt;が&lt;/em&gt;、コードが意図したとおりに機能している場合、値が確実にどうなるかはわかり&lt;em&gt;ません&lt;/em&gt;。たとえば、なんらかの方法で入力が変更されることが保証されている関数をテストしているが、入力が変更される方法がテストを実行する曜日によって異なる場合、アサートするのに最適なものは次のようになります。関数の出力が入力と等しくないこと。</target>
        </trans-unit>
        <trans-unit id="bf35e012d7004404479ddec49cb6abc4ee90bc1a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bind&lt;/code&gt; function in this scenario works like the &lt;code&gt;new&lt;/code&gt; function in that it will return a new &lt;code&gt;TcpListener&lt;/code&gt; instance. The reason the function is called &lt;code&gt;bind&lt;/code&gt; is that in networking, connecting to a port to listen to is known as &amp;ldquo;binding to a port.&amp;rdquo;</source>
          <target state="translated">このシナリオの &lt;code&gt;bind&lt;/code&gt; 関数は、新しい &lt;code&gt;TcpListener&lt;/code&gt; インスタンスを返すという点で、 &lt;code&gt;new&lt;/code&gt; 関数のように機能します。この機能が &lt;code&gt;bind&lt;/code&gt; と呼ばれるのは、ネットワークでは、リッスンするポートに接続することを「ポートへのバインド」といいます。</target>
        </trans-unit>
        <trans-unit id="857a5e6432ea471c67896a45b43648088a7ad85c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bind&lt;/code&gt; function returns a &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;, which indicates that binding might fail. For example, connecting to port 80 requires administrator privileges (nonadministrators can listen only on ports higher than 1023), so if we tried to connect to port 80 without being an administrator, binding wouldn&amp;rsquo;t work. As another example, binding wouldn&amp;rsquo;t work if we ran two instances of our program and so had two programs listening to the same port. Because we&amp;rsquo;re writing a basic server just for learning purposes, we won&amp;rsquo;t worry about handling these kinds of errors; instead, we use &lt;code&gt;unwrap&lt;/code&gt; to stop the program if errors happen.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a9db4154e7cfc914c7af74a70f78787dc149e27" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bind&lt;/code&gt; function returns a &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;, which indicates that binding might fail. For example, connecting to port 80 requires administrator privileges (nonadministrators can listen only on ports higher than 1024), so if we tried to connect to port 80 without being an administrator, binding wouldn&amp;rsquo;t work. As another example, binding wouldn&amp;rsquo;t work if we ran two instances of our program and so had two programs listening to the same port. Because we&amp;rsquo;re writing a basic server just for learning purposes, we won&amp;rsquo;t worry about handling these kinds of errors; instead, we use &lt;code&gt;unwrap&lt;/code&gt; to stop the program if errors happen.</source>
          <target state="translated">&lt;code&gt;bind&lt;/code&gt; 関数が返す &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 、結合が失敗する可能性があることを示しています。たとえば、ポート80に接続するには管理者権限が必要です（非管理者は1024を超えるポートでのみリッスンできます）。したがって、管理者でなくてもポート80に接続しようとした場合、バインドは機能しません。別の例として、プログラムの2つのインスタンスを実行し、2つのプログラムが同じポートをリッスンしている場合、バインディングは機能しません。学習目的で基本的なサーバーを作成しているため、この種のエラーの処理について心配する必要はありません。代わりに、エラーが発生した場合は、 &lt;code&gt;unwrap&lt;/code&gt; を使用してプログラムを停止します。</target>
        </trans-unit>
        <trans-unit id="86e869ec27553a2645d530ee9b57e980ad085326" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bool&lt;/code&gt; represents a value, which could only be either &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. If you cast a &lt;code&gt;bool&lt;/code&gt; into an integer, &lt;code&gt;true&lt;/code&gt; will be 1 and &lt;code&gt;false&lt;/code&gt; will be 0.</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; のみのいずれかである値で表し、 &lt;code&gt;true&lt;/code&gt; または &lt;code&gt;false&lt;/code&gt; 。 &lt;code&gt;bool&lt;/code&gt; を整数にキャストした場合、 &lt;code&gt;true&lt;/code&gt; は1、 &lt;code&gt;false&lt;/code&gt; は0になります。</target>
        </trans-unit>
        <trans-unit id="d4311662fb8a13303491e364af26bcbe8200bef8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bool&lt;/code&gt; type is a datatype which can be either &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. The boolean type uses one byte of memory. It is used in comparisons and bitwise operations like &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, and &lt;code&gt;!&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; 型がいずれかになりますデータ型である &lt;code&gt;true&lt;/code&gt; または &lt;code&gt;false&lt;/code&gt; 。ブール型は1バイトのメモリを使用します。 &lt;code&gt;&amp;amp;&lt;/code&gt; 、 &lt;code&gt;|&lt;/code&gt; などの比較やビット単位の演算で使用されます。、そして &lt;code&gt;!&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="71b45beaeed4f4e8bb8cb42d1eee7255c7dfda23" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;break&lt;/code&gt; statement can take an argument (which will be the value of the loop expression if the &lt;code&gt;break&lt;/code&gt; statement is executed) in &lt;code&gt;loop&lt;/code&gt; loops, but not &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, or &lt;code&gt;while let&lt;/code&gt; loops.</source>
          <target state="translated">&lt;code&gt;break&lt;/code&gt; ステートメントは、（あればループ式の値になります引数取ることができ &lt;code&gt;break&lt;/code&gt; に文が実行される）を &lt;code&gt;loop&lt;/code&gt; ではなく、ループ &lt;code&gt;for&lt;/code&gt; 、 &lt;code&gt;while&lt;/code&gt; 、または &lt;code&gt;while let&lt;/code&gt; ループ。</target>
        </trans-unit>
        <trans-unit id="d4fc4821431bbe2f5d7ca950ef58b031fb001379" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bytes&lt;/code&gt; method returns each raw byte, which might be appropriate for your domain:</source>
          <target state="translated">&lt;code&gt;bytes&lt;/code&gt; の方法は、あなたのドメインに適切であるかもしれないそれぞれの生のバイトを返します：</target>
        </trans-unit>
        <trans-unit id="0c67d48bb9bf16df95a3dc50a92dbdfe313c2a09" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;can_hold&lt;/code&gt; method returns a Boolean, which means it&amp;rsquo;s a perfect use case for the &lt;code&gt;assert!&lt;/code&gt; macro. In Listing 11-6, we write a test that exercises the &lt;code&gt;can_hold&lt;/code&gt; method by creating a &lt;code&gt;Rectangle&lt;/code&gt; instance that has a width of 8 and a height of 7 and asserting that it can hold another &lt;code&gt;Rectangle&lt;/code&gt; instance that has a width of 5 and a height of 1.</source>
          <target state="translated">&lt;code&gt;can_hold&lt;/code&gt; メソッドはブール値を返します。つまり、 &lt;code&gt;assert!&lt;/code&gt; 完全なユースケースです。大きい。リスト11-6において、我々は、行使テスト書き込み &lt;code&gt;can_hold&lt;/code&gt; の作成方法を &lt;code&gt;Rectangle&lt;/code&gt; 8の幅と7の高さを有するインスタンスを、それが別の保持することができると主張 &lt;code&gt;Rectangle&lt;/code&gt; 5の幅と高さを有するインスタンスを1。</target>
        </trans-unit>
        <trans-unit id="5a25b55443c783de850a8f716e7e98dd68745de2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cargo install&lt;/code&gt; command allows you to install and use binary crates locally. This isn&amp;rsquo;t intended to replace system packages; it&amp;rsquo;s meant to be a convenient way for Rust developers to install tools that others have shared on &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt;. Note that you can only install packages that have binary targets. A &lt;em&gt;binary target&lt;/em&gt; is the runnable program that is created if the crate has a &lt;em&gt;src/main.rs&lt;/em&gt; file or another file specified as a binary, as opposed to a library target that isn&amp;rsquo;t runnable on its own but is suitable for including within other programs. Usually, crates have information in the &lt;em&gt;README&lt;/em&gt; file about whether a crate is a library, has a binary target, or both.</source>
          <target state="translated">&lt;code&gt;cargo install&lt;/code&gt; コマンドを使用すると、ローカルバイナリ木箱をインストールして使用することができます。これは、システムパッケージを置き換えることを意図したものではありません。これは、Rust開発者が他の人が&lt;a href=&quot;https://crates.io/&quot;&gt;crates.ioで&lt;/a&gt;共有しているツールをインストールするための便利な方法であることを意図しています。バイナリターゲットを持つパッケージのみをインストールできることに注意してください。&lt;em&gt;バイナリターゲットは&lt;/em&gt;クレートがある場合に作成される実行可能なプログラムであり、&lt;em&gt;SRC / main.rsの&lt;/em&gt;自分自身で実行可能ではありませんが、他の中に含めるために適しているライブラリのターゲットとは反対に、ファイルまたはバイナリとして指定された別のファイルをプログラム。通常、クレートの&lt;em&gt;README&lt;/em&gt;ファイルには、クレートがライブラリであるか、バイナリターゲットであるか、またはその両方に関する情報が含まれています。</target>
        </trans-unit>
        <trans-unit id="2664dcbe5273c6722a5b153d876b9b792f2ada2f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cargo test&lt;/code&gt; command runs all tests in our project, as shown in Listing 11-2.</source>
          <target state="translated">&lt;code&gt;cargo test&lt;/code&gt; リスト11-2に示すように、コマンドは、私たちのプロジェクトのすべてのテストを実行します。</target>
        </trans-unit>
        <trans-unit id="375baaee400dee61b2707b887bd9af56fe2bc128" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;cfg&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="3c6c79dbe0366f164760e8fbd149ca95e0429eec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg&lt;/code&gt; attribute is allowed anywhere attributes are allowed.</source>
          <target state="translated">&lt;code&gt;cfg&lt;/code&gt; 属性は、どこかの属性が許可されている許可されています。</target>
        </trans-unit>
        <trans-unit id="c1be4a466f7709a98c138b8664fae5693d56dd2b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg&lt;/code&gt; attribute supports only three kinds of predicates:</source>
          <target state="translated">&lt;code&gt;cfg&lt;/code&gt; 属性がサポートする述語の唯一の三種類：</target>
        </trans-unit>
        <trans-unit id="28422790bd7081a79bb025fb9d66e378219a525d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg&lt;/code&gt; macro</source>
          <target state="translated">&lt;code&gt;cfg&lt;/code&gt; マクロ</target>
        </trans-unit>
        <trans-unit id="fde18a15c12045ccc5f862ad4d07ffff9bb790a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg&lt;/code&gt;&lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; conditionally includes the thing it is attached to based on a configuration predicate.</source>
          <target state="translated">&lt;code&gt;cfg&lt;/code&gt; &lt;a href=&quot;attributes&quot;&gt;属性は&lt;/a&gt;条件付きでそれが設定述語に基づいに接続されているものを含んでいます。</target>
        </trans-unit>
        <trans-unit id="2223835f7d8034d74bbb5846af6ec97de49a67f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg_attr&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;cfg_attr&lt;/code&gt; の属性</target>
        </trans-unit>
        <trans-unit id="76546526e7489be649c0d74ada78ee80e5e85965" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg_attr&lt;/code&gt; attribute is allowed anywhere attributes are allowed.</source>
          <target state="translated">&lt;code&gt;cfg_attr&lt;/code&gt; の属性は、どこかの属性が許可されている許可されています。</target>
        </trans-unit>
        <trans-unit id="548a83f876de36acae9e81967a808fe451cf7938" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg_attr&lt;/code&gt;&lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; conditionally includes &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt; based on a configuration predicate.</source>
          <target state="translated">&lt;code&gt;cfg_attr&lt;/code&gt; の&lt;a href=&quot;attributes&quot;&gt;属性は、&lt;/a&gt;条件付きで含まれる&lt;a href=&quot;attributes&quot;&gt;属性&lt;/a&gt;の設定述語に基づいています。</target>
        </trans-unit>
        <trans-unit id="85a19bbf37eb56f0525c8c2436505adedd691250" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;char&lt;/code&gt; type represents a single character. More specifically, since 'character' isn't a well-defined concept in Unicode, &lt;code&gt;char&lt;/code&gt; is a '&lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode scalar value&lt;/a&gt;', which is similar to, but not the same as, a '&lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt;Unicode code point&lt;/a&gt;'.</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; 型のタイプは、単一の文字を表します。より具体的には、「文字」はUnicodeで明確に定義された概念ではないため、 &lt;code&gt;char&lt;/code&gt; は「&lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicodeスカラー値&lt;/a&gt;」であり、「&lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt;Unicodeコードポイント&lt;/a&gt;」に似ていますが、同じではありません。</target>
        </trans-unit>
        <trans-unit id="0a74dd59e92ee5c4ca1d05c5860d6f4a16b4bdfe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;char&lt;/code&gt; type represents a single character. More specifically, since 'character' isn't a well-defined concept in Unicode, &lt;code&gt;char&lt;/code&gt; is a '&lt;a href=&quot;https://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode scalar value&lt;/a&gt;', which is similar to, but not the same as, a '&lt;a href=&quot;https://www.unicode.org/glossary/#code_point&quot;&gt;Unicode code point&lt;/a&gt;'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b73bedd4705331ddde92b218ee42ae14fd783b1a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cold&lt;/code&gt; and &lt;code&gt;inline&lt;/code&gt;&lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; give suggestions to generate code in a way that may be faster than what it would do without the hint. The attributes are only hints, and may be ignored.</source>
          <target state="translated">&lt;code&gt;cold&lt;/code&gt; と &lt;code&gt;inline&lt;/code&gt; &lt;a href=&quot;../attributes&quot;&gt;属性は、&lt;/a&gt;より速く、それがヒントなしでどうなるのかよりかもしれ方法でコードを生成するための提案を与えます。属性は単なるヒントであり、無視してもかまいません。</target>
        </trans-unit>
        <trans-unit id="5e443e8933fc7022a9fff52a5391c70d8fc736a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cold&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;cold&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="f187d03d0870d5f7cf8d911158a2ad4bf8bfb1f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;const&lt;/code&gt; keyword is also used in raw pointers in combination with &lt;code&gt;mut&lt;/code&gt;, as seen in &lt;code&gt;*const T&lt;/code&gt; and &lt;code&gt;*mut T&lt;/code&gt;. More about &lt;code&gt;const&lt;/code&gt; as used in raw pointers can be read at the Rust docs for the &lt;a href=&quot;primitive.pointer&quot;&gt;pointer primitive&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; のキーワードはまた、との組み合わせで、生のポインタで使用され &lt;code&gt;mut&lt;/code&gt; に見られるように、 &lt;code&gt;*const T&lt;/code&gt; と &lt;code&gt;*mut T&lt;/code&gt; 。生のポインターで使用される &lt;code&gt;const&lt;/code&gt; の詳細については、&lt;a href=&quot;primitive.pointer&quot;&gt;ポインタープリミティブの&lt;/a&gt;Rustドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="c647cbb39e778e9b3fee3b9f221a846f5e10198a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;const&lt;/code&gt; keyword is also used in raw pointers in combination with &lt;code&gt;mut&lt;/code&gt;, as seen in &lt;code&gt;*const T&lt;/code&gt; and &lt;code&gt;*mut T&lt;/code&gt;. More about that can be read at the &lt;a href=&quot;primitive.pointer&quot;&gt;pointer&lt;/a&gt; primitive part of the Rust docs.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; のキーワードはまた、との組み合わせで、生のポインタで使用され &lt;code&gt;mut&lt;/code&gt; に見られるように、 &lt;code&gt;*const T&lt;/code&gt; と &lt;code&gt;*mut T&lt;/code&gt; 。その詳細については、Rustドキュメントの&lt;a href=&quot;primitive.pointer&quot;&gt;ポインタ&lt;/a&gt;プリミティブ部分を参照してください。</target>
        </trans-unit>
        <trans-unit id="90ef70a34f1bf7aa0febc79627f67bbce0e1d9d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;core&lt;/code&gt; crate is always added to the extern prelude. The &lt;code&gt;std&lt;/code&gt; crate is added as long as the &lt;a href=&quot;../crates-and-source-files#preludes-and-no_std&quot;&gt;&lt;code&gt;no_std&lt;/code&gt;&lt;/a&gt; attribute is not specified in the crate root.</source>
          <target state="translated">&lt;code&gt;core&lt;/code&gt; クレートは、常にはexternプレリュードに追加されます。 &lt;code&gt;std&lt;/code&gt; クレートは限りとして追加され&lt;a href=&quot;../crates-and-source-files#preludes-and-no_std&quot;&gt; &lt;code&gt;no_std&lt;/code&gt; &lt;/a&gt;属性はクレートのルートに指定されていません。</target>
        </trans-unit>
        <trans-unit id="38acae0d6ab176e191a45e1f1b54faccd4c7f448" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crate_name&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;crate_name&lt;/code&gt; の属性</target>
        </trans-unit>
        <trans-unit id="ef2c8badee302cb0baefa21db745a07eb79b3acf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; pointer can be used to store arbitrary data as required by the executor. This could be e.g. a type-erased pointer to an &lt;code&gt;Arc&lt;/code&gt; that is associated with the task. The value of this poiner will get passed to all functions that are part of the &lt;code&gt;vtable&lt;/code&gt; as the first parameter.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; ポインタは、エグゼキュータによって要求される任意のデータを格納するために使用することができます。これは、たとえば、タスクに関連付けられている &lt;code&gt;Arc&lt;/code&gt; への型消去されたポインターである可能性があります。このpoinerの値は、最初のパラメーターとして &lt;code&gt;vtable&lt;/code&gt; の一部であるすべての関数に渡されます。</target>
        </trans-unit>
        <trans-unit id="9e90fa7bb07af3f80ba061dbc0af88db5a79ba76" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; pointer can be used to store arbitrary data as required by the executor. This could be e.g. a type-erased pointer to an &lt;code&gt;Arc&lt;/code&gt; that is associated with the task. The value of this pointer will get passed to all functions that are part of the &lt;code&gt;vtable&lt;/code&gt; as the first parameter.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; ポインタは、エグゼキュータによって要求される任意のデータを格納するために使用することができます。これは、たとえば、タスクに関連付けられている &lt;code&gt;Arc&lt;/code&gt; へのタイプ消去されたポインタである可能性があります。このポインターの値は、最初のパラメーターとして &lt;code&gt;vtable&lt;/code&gt; の一部であるすべての関数に渡されます。</target>
        </trans-unit>
        <trans-unit id="a7af61314557c2255ce30f13387bf574343b8476" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dbg!(..)&lt;/code&gt; macro moves the input:</source>
          <target state="translated">&lt;code&gt;dbg!(..)&lt;/code&gt; マクロ移動入力：</target>
        </trans-unit>
        <trans-unit id="b7a4dd4c094bb75a82ed633489f0ec96c82a6296" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dbg!&lt;/code&gt; macro works exactly the same in release builds. This is useful when debugging issues that only occur in release builds or when debugging in release mode is significantly faster.</source>
          <target state="translated">&lt;code&gt;dbg!&lt;/code&gt; マクロはリリースビルドでもまったく同じように機能します。これは、リリースビルドでのみ発生する問題をデバッグする場合、またはリリースモードでのデバッグが大幅に速い場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="5a03c825d089a243f66f60fd9869adfb4b5c6857" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;deprecated&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="8b0ffc1f78b8eb9694b4e7509ecdd919acc0c0cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute can only be present &lt;strong&gt;once&lt;/strong&gt; on an item.</source>
          <target state="translated">&lt;code&gt;deprecated&lt;/code&gt; 属性が唯一存在することができ&lt;strong&gt;、一度&lt;/strong&gt;アイテムに。</target>
        </trans-unit>
        <trans-unit id="4c348bd3f38f8d7b286030ed2d1f972d4a02706b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute has several forms:</source>
          <target state="translated">&lt;code&gt;deprecated&lt;/code&gt; 属性は、いくつかの形式があります。</target>
        </trans-unit>
        <trans-unit id="44c311ce3d12b2d5a8a0632c6cd020f999b4ee16" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute may be applied to any &lt;a href=&quot;../items&quot;&gt;item&lt;/a&gt;, &lt;a href=&quot;../items/traits&quot;&gt;trait item&lt;/a&gt;, &lt;a href=&quot;../items/enumerations&quot;&gt;enum variant&lt;/a&gt;, &lt;a href=&quot;../items/structs&quot;&gt;struct field&lt;/a&gt;, &lt;a href=&quot;../items/external-blocks&quot;&gt;external block item&lt;/a&gt;, or &lt;a href=&quot;../macros-by-example&quot;&gt;macro definition&lt;/a&gt;. It cannot be applied to &lt;a href=&quot;../items/implementations#trait-implementations&quot;&gt;trait implementation items&lt;/a&gt;. When applied to an item containing other items, such as a &lt;a href=&quot;../items/modules&quot;&gt;module&lt;/a&gt; or &lt;a href=&quot;../items/implementations&quot;&gt;implementation&lt;/a&gt;, all child items inherit the deprecation attribute.</source>
          <target state="translated">&lt;code&gt;deprecated&lt;/code&gt; 属性は、いずれにも適用することができる&lt;a href=&quot;../items&quot;&gt;アイテム&lt;/a&gt;、&lt;a href=&quot;../items/traits&quot;&gt;形質項目&lt;/a&gt;、&lt;a href=&quot;../items/enumerations&quot;&gt;列挙変異体&lt;/a&gt;、&lt;a href=&quot;../items/structs&quot;&gt;構造体フィールド&lt;/a&gt;、&lt;a href=&quot;../items/external-blocks&quot;&gt;外部ブロック・アイテム&lt;/a&gt;、または&lt;a href=&quot;../macros-by-example&quot;&gt;マクロ定義&lt;/a&gt;。&lt;a href=&quot;../items/implementations#trait-implementations&quot;&gt;トレイト実装アイテムには&lt;/a&gt;適用できません。&lt;a href=&quot;../items/modules&quot;&gt;モジュール&lt;/a&gt;や&lt;a href=&quot;../items/implementations&quot;&gt;実装&lt;/a&gt;など、他のアイテムを含むアイテムに適用されると、すべての子アイテムは非推奨属性を継承します。</target>
        </trans-unit>
        <trans-unit id="f1d23eb4050e4bb4bd6008dd3e0216cd81ba2cd1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute may be applied to any &lt;a href=&quot;../items&quot;&gt;item&lt;/a&gt;, &lt;a href=&quot;../items/traits&quot;&gt;trait item&lt;/a&gt;, &lt;a href=&quot;../items/enumerations&quot;&gt;enum variant&lt;/a&gt;, &lt;a href=&quot;../items/structs&quot;&gt;struct field&lt;/a&gt;, or &lt;a href=&quot;../items/external-blocks&quot;&gt;external block item&lt;/a&gt;. It cannot be applied to &lt;a href=&quot;../items/implementations#trait-implementations&quot;&gt;trait implementation items&lt;/a&gt;. When applied to an item containing other items, such as a &lt;a href=&quot;../items/modules&quot;&gt;module&lt;/a&gt; or &lt;a href=&quot;../items/implementations&quot;&gt;implementation&lt;/a&gt;, all child items inherit the deprecation attribute.</source>
          <target state="translated">&lt;code&gt;deprecated&lt;/code&gt; 属性は、いずれにも適用することができる&lt;a href=&quot;../items&quot;&gt;アイテム&lt;/a&gt;、&lt;a href=&quot;../items/traits&quot;&gt;形質項目&lt;/a&gt;、&lt;a href=&quot;../items/enumerations&quot;&gt;列挙変異体&lt;/a&gt;、&lt;a href=&quot;../items/structs&quot;&gt;構造体のフィールド&lt;/a&gt;、または&lt;a href=&quot;../items/external-blocks&quot;&gt;外部ブロック・アイテム&lt;/a&gt;。&lt;a href=&quot;../items/implementations#trait-implementations&quot;&gt;トレイト実装アイテムには&lt;/a&gt;適用できません。&lt;a href=&quot;../items/modules&quot;&gt;モジュール&lt;/a&gt;や&lt;a href=&quot;../items/implementations&quot;&gt;実装&lt;/a&gt;など、他のアイテムを含むアイテムに適用すると、すべての子アイテムは非推奨属性を継承します。</target>
        </trans-unit>
        <trans-unit id="6e7f4030e080734f98683be5c8344d101d0992db" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dev&lt;/code&gt; and &lt;code&gt;release&lt;/code&gt; shown in this build output indicate that the compiler is using different profiles.</source>
          <target state="translated">&lt;code&gt;dev&lt;/code&gt; と &lt;code&gt;release&lt;/code&gt; このビルド出力に示されているが、コンパイラが異なるプロファイルを使用していることを示しています。</target>
        </trans-unit>
        <trans-unit id="2bcbec4aff44a7472a393bc8eca9c7c00034401d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;drop&lt;/code&gt; method is called when &lt;code&gt;_x&lt;/code&gt; goes out of scope, and therefore &lt;code&gt;main&lt;/code&gt; prints &lt;code&gt;Dropping!&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;drop&lt;/code&gt; 時にメソッドが呼び出され &lt;code&gt;_x&lt;/code&gt; がスコープ外に出るので、 &lt;code&gt;main&lt;/code&gt; プリントが &lt;code&gt;Dropping!&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aa3edbdb8ad85c4d37e55b2e809f2f18d6f4e045" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dst&lt;/code&gt; path will be a directory symbolic link pointing to the &lt;code&gt;src&lt;/code&gt; path.</source>
          <target state="translated">&lt;code&gt;dst&lt;/code&gt; パスを指し、ディレクトリのシンボリックリンクとなる &lt;code&gt;src&lt;/code&gt; パス。</target>
        </trans-unit>
        <trans-unit id="f8ab040b8a001ca82f66534b2d20a3b8892fd2dc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dst&lt;/code&gt; path will be a file symbolic link pointing to the &lt;code&gt;src&lt;/code&gt; path.</source>
          <target state="translated">&lt;code&gt;dst&lt;/code&gt; パスを指し、ファイルのシンボリックリンクとなる &lt;code&gt;src&lt;/code&gt; パス。</target>
        </trans-unit>
        <trans-unit id="f0ecd1a2ccd0de8765e1ce7cbb8fab53800f6ce6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dst&lt;/code&gt; path will be a link pointing to the &lt;code&gt;src&lt;/code&gt; path. Note that systems often require these two paths to both be located on the same filesystem.</source>
          <target state="translated">&lt;code&gt;dst&lt;/code&gt; パスはへのリンクになります &lt;code&gt;src&lt;/code&gt; パス。多くの場合、システムではこれらの2つのパスを両方とも同じファイルシステムに配置する必要があります。</target>
        </trans-unit>
        <trans-unit id="b0f3651131fc6e4c0e98108eb60e32485bb1899b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dst&lt;/code&gt; path will be a symbolic link pointing to the &lt;code&gt;src&lt;/code&gt; path.</source>
          <target state="translated">&lt;code&gt;dst&lt;/code&gt; パスを指すシンボリックリンクとなる &lt;code&gt;src&lt;/code&gt; パス。</target>
        </trans-unit>
        <trans-unit id="3c07e52fcb5c94a3c499bbc6e95804ccd5a8bfc6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dst&lt;/code&gt; path will be a symbolic link pointing to the &lt;code&gt;src&lt;/code&gt; path. On Windows, this will be a file symlink, not a directory symlink; for this reason, the platform-specific &lt;a href=&quot;../os/unix/fs/fn.symlink&quot;&gt;&lt;code&gt;std::os::unix::fs::symlink&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../os/windows/fs/fn.symlink_file&quot;&gt;&lt;code&gt;std::os::windows::fs::symlink_file&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../os/windows/fs/fn.symlink_dir&quot;&gt;&lt;code&gt;symlink_dir&lt;/code&gt;&lt;/a&gt; should be used instead to make the intent explicit.</source>
          <target state="translated">&lt;code&gt;dst&lt;/code&gt; パスを指すシンボリックリンクとなる &lt;code&gt;src&lt;/code&gt; パス。Windowsでは、これはディレクトリのシンボリックリンクではなく、ファイルのシンボリックリンクになります。このため、プラットフォーム固有の&lt;a href=&quot;../os/unix/fs/fn.symlink&quot;&gt; &lt;code&gt;std::os::unix::fs::symlink&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;../os/windows/fs/fn.symlink_file&quot;&gt; &lt;code&gt;std::os::windows::fs::symlink_file&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;../os/windows/fs/fn.symlink_dir&quot;&gt; &lt;code&gt;symlink_dir&lt;/code&gt; &lt;/a&gt;を使用して、意図を明示的にする必要があります。</target>
        </trans-unit>
        <trans-unit id="fce5aa6e4c6fe0d2a117a0ec0a2f7f52bfd2748e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dyn&lt;/code&gt; keyword is used to highlight that calls to methods on the associated &lt;code&gt;Trait&lt;/code&gt; are dynamically dispatched. To use the trait this way, it must be 'object safe'.</source>
          <target state="translated">&lt;code&gt;dyn&lt;/code&gt; キーワードは、関連のメソッドをコールすることを強調するために使用される &lt;code&gt;Trait&lt;/code&gt; 、動的に派遣されています。この特性を使用するには、「オブジェクトセーフ」である必要があります。</target>
        </trans-unit>
        <trans-unit id="f31eeeb70d8a71f4b93bd89156c38bf0e5709ff2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;edition&lt;/code&gt; key in &lt;em&gt;Cargo.toml&lt;/em&gt; indicates which edition the compiler should use for your code. If the key doesn&amp;rsquo;t exist, Rust uses &lt;code&gt;2015&lt;/code&gt; as the edition value for backward compatibility reasons.</source>
          <target state="translated">&lt;em&gt;Cargo.toml&lt;/em&gt;の &lt;code&gt;edition&lt;/code&gt; キーは、コンパイラがコードに使用するエディションを示します。キーが存在しない場合、Rustは下位互換性のために &lt;code&gt;2015&lt;/code&gt; をエディション値として使用します。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d4302d0f2edafc20c30c1bca4c608a973532a107" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;else&lt;/code&gt; block of an &lt;code&gt;if&lt;/code&gt; expression.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 式の &lt;code&gt;else&lt;/code&gt; ブロック。</target>
        </trans-unit>
        <trans-unit id="25d57c60dcf697c3f5bb61f1ff343393baeeb72f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;entry&lt;/code&gt; API is intended to provide an efficient mechanism for manipulating the contents of a map conditionally on the presence of a key or not. The primary motivating use case for this is to provide efficient accumulator maps. For instance, if one wishes to maintain a count of the number of times each key has been seen, they will have to perform some conditional logic on whether this is the first time the key has been seen or not. Normally, this would require a &lt;code&gt;find&lt;/code&gt; followed by an &lt;code&gt;insert&lt;/code&gt;, effectively duplicating the search effort on each insertion.</source>
          <target state="translated">&lt;code&gt;entry&lt;/code&gt; APIは、キーやないの存在に条件付きでマップの内容を操作するための効率的なメカニズムを提供することを意図しています。これの動機となる主なユースケースは、効率的なアキュムレータマップを提供することです。たとえば、各キーが表示された回数のカウントを維持したい場合、キーが初めて表示されたかどうかについて、条件付きロジックを実行する必要があります。通常、これには、 &lt;code&gt;find&lt;/code&gt; 後に &lt;code&gt;insert&lt;/code&gt; が必要であり、挿入ごとに検索作業を効果的に複製します。</target>
        </trans-unit>
        <trans-unit id="f625c5b9aa8efa15984a630e2609a8460845d869" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;enum&lt;/code&gt; type is analogous to a &lt;code&gt;data&lt;/code&gt; constructor declaration in ML, or a &lt;em&gt;pick ADT&lt;/em&gt; in Limbo.</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt; タイプに類似して &lt;code&gt;data&lt;/code&gt; MLにおけるコンストラクタ宣言、又は&lt;em&gt;ピックADT&lt;/em&gt;リンボです。</target>
        </trans-unit>
        <trans-unit id="a4c06e2ed2dc5ac68975592625d2fc4a6fa31065" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;env::args&lt;/code&gt; function returns an iterator! Rather than collecting the iterator values into a vector and then passing a slice to &lt;code&gt;Config::new&lt;/code&gt;, now we&amp;rsquo;re passing ownership of the iterator returned from &lt;code&gt;env::args&lt;/code&gt; to &lt;code&gt;Config::new&lt;/code&gt; directly.</source>
          <target state="translated">&lt;code&gt;env::args&lt;/code&gt; 関数は、イテレータを返します！むしろベクターにイテレータ値を収集し、その後にスライスを渡すよりも &lt;code&gt;Config::new&lt;/code&gt; 、今から返されたイテレータの所有権を渡している &lt;code&gt;env::args&lt;/code&gt; に &lt;code&gt;Config::new&lt;/code&gt; 直接。</target>
        </trans-unit>
        <trans-unit id="8c4edba08b3e0cbdebf585d9d18019162245f0c1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;execute&lt;/code&gt; method will send the job it wants to execute down the sending side of the channel.</source>
          <target state="translated">&lt;code&gt;execute&lt;/code&gt; 方法は、それは、チャネルの送信側を下に実行したいジョブを送信します。</target>
        </trans-unit>
        <trans-unit id="f04efaa242b2b0657b1281616eed7892b34b84f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expensive_test&lt;/code&gt; function is listed as &lt;code&gt;ignored&lt;/code&gt;. If we want to run only the ignored tests, we can use &lt;code&gt;cargo test -- --ignored&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;expensive_test&lt;/code&gt; としての機能が一覧表示され &lt;code&gt;ignored&lt;/code&gt; 。無視されたテストのみを実行する場合は、 &lt;code&gt;cargo test -- --ignored&lt;/code&gt; 使用できます。</target>
        </trans-unit>
        <trans-unit id="b3f7670e25e83de589c198657dfe09fdc1e175dc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;export_name&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;export_name&lt;/code&gt; の属性</target>
        </trans-unit>
        <trans-unit id="71ce9eba53db805fddc2d08a297018a65234c4f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extern&lt;/code&gt; function qualifier allows providing function &lt;em&gt;definitions&lt;/em&gt; that can be called with a particular ABI:</source>
          <target state="translated">&lt;code&gt;extern&lt;/code&gt; 関数提供することができます修飾子機能&lt;em&gt;の定義&lt;/em&gt;、特定のABIで呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="40efbff38e084ea29f3140f45238b8f3a1480902" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extern&lt;/code&gt; keyword is used in two places in Rust. One is in conjunction with the &lt;a href=&quot;index&quot;&gt;&lt;code&gt;crate&lt;/code&gt;&lt;/a&gt; keyword to make your Rust code aware of other Rust crates in your project, i.e., &lt;code&gt;extern crate lazy_static;&lt;/code&gt;. The other use is in foreign function interfaces (FFI).</source>
          <target state="translated">&lt;code&gt;extern&lt;/code&gt; キーワードは、ラストで2つの場所で使用されています。 1つは、&lt;a href=&quot;index&quot;&gt; &lt;code&gt;crate&lt;/code&gt; &lt;/a&gt;キーワードと組み合わせて、Rustコードにプロジェクト内の他のRustクレートを認識させること &lt;code&gt;extern crate lazy_static;&lt;/code&gt; つまり、extern crate lazy_static;。もう1つの用途は、外部関数インターフェース（FFI）です。</target>
        </trans-unit>
        <trans-unit id="e4b4130d453476128e8ae98130baa92b7675ca5c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extern&lt;/code&gt; keyword is used in two places in Rust. One is in conjunction with the &lt;a href=&quot;keyword.crate&quot;&gt;&lt;code&gt;crate&lt;/code&gt;&lt;/a&gt; keyword to make your Rust code aware of other Rust crates in your project, i.e., &lt;code&gt;extern crate lazy_static;&lt;/code&gt;. The other use is in foreign function interfaces (FFI).</source>
          <target state="translated">&lt;code&gt;extern&lt;/code&gt; キーワードは、ラストで2つの場所で使用されています。一つは、と連携している&lt;a href=&quot;keyword.crate&quot;&gt; &lt;code&gt;crate&lt;/code&gt; &lt;/a&gt;つまり、プロジェクト内の他の錆の木枠のあなたの錆コードを認識させるためにキーワード &lt;code&gt;extern crate lazy_static;&lt;/code&gt; 。他の用途は、外部関数インターフェース（FFI）です。</target>
        </trans-unit>
        <trans-unit id="80a6e01d93b27f65515594890e0091001ba7b217" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;feature&lt;/code&gt; attribute only accept a &quot;feature flag&quot; and can only be used on nightly. Example:</source>
          <target state="translated">&lt;code&gt;feature&lt;/code&gt; 属性は、「機能フラグ」を受け入れ、唯一、夜間に使用することができます。例：</target>
        </trans-unit>
        <trans-unit id="36584ecca666e59936c11f071bcfcb0da92fd4b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;feature&lt;/code&gt; attribute was badly formed.</source>
          <target state="translated">&lt;code&gt;feature&lt;/code&gt; 属性がひどく形成されました。</target>
        </trans-unit>
        <trans-unit id="424a7adcc55a187f305df277831d5dda5afa7154" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ffi_const&lt;/code&gt; attribute can only be used on foreign function declarations which have no side effects except for their return value:</source>
          <target state="translated">&lt;code&gt;ffi_const&lt;/code&gt; 属性は、その戻り値以外は副作用を持たない外部関数の宣言に使用することができます。</target>
        </trans-unit>
        <trans-unit id="f9fac3c8fa0259e175ffb5e9aab803c7bd9140ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ffi_const&lt;/code&gt; attribute was used on something other than a foreign function declaration.</source>
          <target state="translated">&lt;code&gt;ffi_const&lt;/code&gt; 属性は、外部関数の宣言以外の何かに使用されました。</target>
        </trans-unit>
        <trans-unit id="bfe6d270783e8b73023767bbcd8ed3a773bacf0d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ffi_pure&lt;/code&gt; attribute can only be used on foreign functions which do not have side effects or infinite loops:</source>
          <target state="translated">&lt;code&gt;ffi_pure&lt;/code&gt; の属性は、副作用や無限ループを持っていない外国の機能に使用することができます。</target>
        </trans-unit>
        <trans-unit id="883b8dfd3c5fc179185e1d061b052f5f3e0fb52a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ffi_pure&lt;/code&gt; attribute was used on a non-foreign function.</source>
          <target state="translated">&lt;code&gt;ffi_pure&lt;/code&gt; 属性は、非外部関数で使用されました。</target>
        </trans-unit>
        <trans-unit id="e96870e73ec5eb32cc1bdf8256711d63dccde7e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fix_incorrect_order&lt;/code&gt; function is in the &lt;code&gt;back_of_house&lt;/code&gt; module, so we can use &lt;code&gt;super&lt;/code&gt; to go to the parent module of &lt;code&gt;back_of_house&lt;/code&gt;, which in this case is &lt;code&gt;crate&lt;/code&gt;, the root. From there, we look for &lt;code&gt;serve_order&lt;/code&gt; and find it. Success! We think the &lt;code&gt;back_of_house&lt;/code&gt; module and the &lt;code&gt;serve_order&lt;/code&gt; function are likely to stay in the same relationship to each other and get moved together should we decide to reorganize the crate&amp;rsquo;s module tree. Therefore, we used &lt;code&gt;super&lt;/code&gt; so we&amp;rsquo;ll have fewer places to update code in the future if this code gets moved to a different module.</source>
          <target state="translated">&lt;code&gt;fix_incorrect_order&lt;/code&gt; の機能はである &lt;code&gt;back_of_house&lt;/code&gt; の我々が使用できるように、モジュール &lt;code&gt;super&lt;/code&gt; の親モジュールに行き &lt;code&gt;back_of_house&lt;/code&gt; この場合で、 &lt;code&gt;crate&lt;/code&gt; 、ルート。そこから &lt;code&gt;serve_order&lt;/code&gt; を探して見つけます。成功！クレートのモジュールツリーを再編成すると、 &lt;code&gt;back_of_house&lt;/code&gt; モジュールと &lt;code&gt;serve_order&lt;/code&gt; 関数は互いに同じ関係を保ち、一緒に移動する可能性が高いと考えています。したがって、このコードを別のモジュールに移動した場合にコードを更新する場所が少なくなるように、 &lt;code&gt;super&lt;/code&gt; を使用しました。</target>
        </trans-unit>
        <trans-unit id="8941a23b194692ed51f3b950de07285880e660a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fn&lt;/code&gt; syntax declares a new function, the parentheses, &lt;code&gt;()&lt;/code&gt;, indicate there are no parameters, and the curly bracket, &lt;code&gt;{&lt;/code&gt;, starts the body of the function.</source>
          <target state="translated">&lt;code&gt;fn&lt;/code&gt; 構文は、新しい機能、かっこ、宣言 &lt;code&gt;()&lt;/code&gt; 、パラメータがない示し、中括弧を、 &lt;code&gt;{&lt;/code&gt; 、関数の本体を開始します。</target>
        </trans-unit>
        <trans-unit id="2ec5406eba98b65177f08bb6b301125802a344f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt; keyword is used in many syntactic locations:</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; キーワードは、多くの構文の場所で使用されます。</target>
        </trans-unit>
        <trans-unit id="f09d76fe1ac31bb0c6ea4013cf20271ea27e1d4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt; loop variable is now named &lt;code&gt;_i&lt;/code&gt;, and the warning no longer appears.</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; ループ変数は、現在の名前はありません &lt;code&gt;_i&lt;/code&gt; 、警告が表示されなくなります。</target>
        </trans-unit>
        <trans-unit id="05236db55a3c27bea79ddd94d4c11b4238339e3a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;forbid&lt;/code&gt; lint setting, like &lt;code&gt;deny&lt;/code&gt;, turns the corresponding compiler warning into a hard error. Unlike &lt;code&gt;deny&lt;/code&gt;, &lt;code&gt;forbid&lt;/code&gt; prevents itself from being overridden by inner attributes.</source>
          <target state="translated">&lt;code&gt;forbid&lt;/code&gt; 糸くずの設定、などの &lt;code&gt;deny&lt;/code&gt; 、ハードエラーに対応したコンパイラの警告をオンにします。 &lt;code&gt;deny&lt;/code&gt; とは異なり、 &lt;code&gt;forbid&lt;/code&gt; はそれ自体が内部属性によって上書きされるのを防ぎます。</target>
        </trans-unit>
        <trans-unit id="4235fdb48267c248121e84a51ecfc4901ad84de8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;format&lt;/code&gt; function takes an &lt;a href=&quot;struct.arguments&quot;&gt;&lt;code&gt;Arguments&lt;/code&gt;&lt;/a&gt; struct and returns the resulting formatted string.</source>
          <target state="translated">&lt;code&gt;format&lt;/code&gt; 関数がとる&lt;a href=&quot;struct.arguments&quot;&gt; &lt;code&gt;Arguments&lt;/code&gt; &lt;/a&gt;構造体を、得られたフォーマットされた文字列を返します。</target>
        </trans-unit>
        <trans-unit id="d0e2c1abc11834d5ec0f9413abedb6a8d1f2b1d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;from&lt;/code&gt; file does not exist.</source>
          <target state="translated">&lt;code&gt;from&lt;/code&gt; ファイルが存在しません。</target>
        </trans-unit>
        <trans-unit id="0c95afec6a5645bced705f13162ada21e2af597c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;from&lt;/code&gt; path is not a file.</source>
          <target state="translated">&lt;code&gt;from&lt;/code&gt; パスはファイルではありません。</target>
        </trans-unit>
        <trans-unit id="6acb8d35118f04b02cccbeee4ae943f064bc37b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;global_allocator&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;global_allocator&lt;/code&gt; の属性</target>
        </trans-unit>
        <trans-unit id="ae2c6463795dadd5e649f9eb12f49008495df3a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hash_builder&lt;/code&gt; passed should implement the &lt;a href=&quot;../../hash/trait.buildhasher&quot;&gt;&lt;code&gt;BuildHasher&lt;/code&gt;&lt;/a&gt; trait for the HashMap to be useful, see its documentation for details.</source>
          <target state="translated">&lt;code&gt;hash_builder&lt;/code&gt; 実装する必要が渡さ&lt;a href=&quot;../../hash/trait.buildhasher&quot;&gt; &lt;code&gt;BuildHasher&lt;/code&gt; の&lt;/a&gt;に有用であることがHashMapのための特性は、詳細については、そのマニュアルを参照してください。</target>
        </trans-unit>
        <trans-unit id="5b0ca98b2928cdd13f0ccd74c40e39e4e68ec9cc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hash_builder&lt;/code&gt; passed should implement the &lt;a href=&quot;../hash/trait.buildhasher&quot;&gt;&lt;code&gt;BuildHasher&lt;/code&gt;&lt;/a&gt; trait for the HashMap to be useful, see its documentation for details.</source>
          <target state="translated">&lt;code&gt;hash_builder&lt;/code&gt; 実装する必要が渡さ&lt;a href=&quot;../hash/trait.buildhasher&quot;&gt; &lt;code&gt;BuildHasher&lt;/code&gt; の&lt;/a&gt;に有用であることがHashMapのための特性は、詳細については、そのマニュアルを参照してください。</target>
        </trans-unit>
        <trans-unit id="c35c9498a5a0a48423b3c0138b12569234cd1c61" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hello_macro_derive&lt;/code&gt; function first converts the &lt;code&gt;input&lt;/code&gt; from a &lt;code&gt;TokenStream&lt;/code&gt; to a data structure that we can then interpret and perform operations on. This is where &lt;code&gt;syn&lt;/code&gt; comes into play. The &lt;code&gt;parse&lt;/code&gt; function in &lt;code&gt;syn&lt;/code&gt; takes a &lt;code&gt;TokenStream&lt;/code&gt; and returns a &lt;code&gt;DeriveInput&lt;/code&gt; struct representing the parsed Rust code. Listing 19-32 shows the relevant parts of the &lt;code&gt;DeriveInput&lt;/code&gt; struct we get from parsing the &lt;code&gt;struct Pancakes;&lt;/code&gt; string:</source>
          <target state="translated">&lt;code&gt;hello_macro_derive&lt;/code&gt; 関数最初の変換 &lt;code&gt;input&lt;/code&gt; から &lt;code&gt;TokenStream&lt;/code&gt; 我々はその後の操作を解釈して実行することができるデータ構造に関する。ここで &lt;code&gt;syn&lt;/code&gt; が登場します。 &lt;code&gt;parse&lt;/code&gt; 関数 &lt;code&gt;syn&lt;/code&gt; かかり &lt;code&gt;TokenStream&lt;/code&gt; 戻る &lt;code&gt;DeriveInput&lt;/code&gt; の解析されたさびコードを表す構造体を。リスト19-32は、 &lt;code&gt;struct Pancakes;&lt;/code&gt; を解析して得られる &lt;code&gt;DeriveInput&lt;/code&gt; 構造体の関連部分を示しています。ストリング：</target>
        </trans-unit>
        <trans-unit id="004c835aa77c1c8e124a5716a58b7a6bffdd04f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hello_macro_derive&lt;/code&gt; function will be called when a user of our library specifies &lt;code&gt;#[derive(HelloMacro)]&lt;/code&gt; on a type. This is possible because we&amp;rsquo;ve annotated the &lt;code&gt;hello_macro_derive&lt;/code&gt; function here with &lt;code&gt;proc_macro_derive&lt;/code&gt; and specified the name, &lt;code&gt;HelloMacro&lt;/code&gt;, which matches our trait name; this is the convention most procedural macros follow.</source>
          <target state="translated">&lt;code&gt;hello_macro_derive&lt;/code&gt; 関数が呼び出されますとき、私たちのライブラリを指定のユーザー &lt;code&gt;#[derive(HelloMacro)]&lt;/code&gt; タイプに。我々は注釈を付けてきたので、これは可能です &lt;code&gt;hello_macro_derive&lt;/code&gt; ここで関数を &lt;code&gt;proc_macro_derive&lt;/code&gt; 、名前、指定 &lt;code&gt;HelloMacro&lt;/code&gt; 当社の特色名と一致します; これは、ほとんどの手続き型マクロが従う規則です。</target>
        </trans-unit>
        <trans-unit id="f6187e2c81223b9029c3a44a9c821bc39754afaa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if let&lt;/code&gt; syntax lets you combine &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt; into a less verbose way to handle values that match one pattern while ignoring the rest. Consider the program in Listing 6-6 that matches on an &lt;code&gt;Option&amp;lt;u8&amp;gt;&lt;/code&gt; value but only wants to execute code if the value is 3.</source>
          <target state="translated">&lt;code&gt;if let&lt;/code&gt; 構文はあなたが結合することができます &lt;code&gt;if&lt;/code&gt; と &lt;code&gt;let&lt;/code&gt; 、残りを無視してのマッチ1パターンというハンドル値への道VERBOSE以下に。リスト6-6の &lt;code&gt;Option&amp;lt;u8&amp;gt;&lt;/code&gt; 値に一致するが、値が3の場合にのみコードを実行するプログラムを考えてみます。</target>
        </trans-unit>
        <trans-unit id="4dd0a50c18a24fd3e6c3d1653fdf8d2add1e5c54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; condition evaluates to a value of &lt;code&gt;3&lt;/code&gt; this time, and Rust throws an error:</source>
          <target state="translated">今回は &lt;code&gt;if&lt;/code&gt; 条件が &lt;code&gt;3&lt;/code&gt; の値に評価され、Rustはエラーをスローします。</target>
        </trans-unit>
        <trans-unit id="3b97788abf2717f652bd87cae2841d2689fe301c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; expression checks whether our value is out of range, tells the user about the problem, and calls &lt;code&gt;continue&lt;/code&gt; to start the next iteration of the loop and ask for another guess. After the &lt;code&gt;if&lt;/code&gt; expression, we can proceed with the comparisons between &lt;code&gt;guess&lt;/code&gt; and the secret number knowing that &lt;code&gt;guess&lt;/code&gt; is between 1 and 100.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 私たちの値が範囲外であるかどうかを表現チェックし、問題をユーザーに伝え、通話は &lt;code&gt;continue&lt;/code&gt; ループの次の反復を開始し、別の推測をお願いします。後 &lt;code&gt;if&lt;/code&gt; 表現、我々は間の比較を進めることができます &lt;code&gt;guess&lt;/code&gt; していることを知っている秘密の数 &lt;code&gt;guess&lt;/code&gt; 1と100の間です。</target>
        </trans-unit>
        <trans-unit id="21d4200f741c0e5d495167ba918e66c0fa127463" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; keyword is used in one other place in Rust, namely as a part of pattern matching itself, allowing patterns such as &lt;code&gt;Some(x) if x &amp;gt; 200&lt;/code&gt; to be used.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; キーワードは、次のようなパターンせる、すなわちそれ自体をパターンマッチングの一部として、錆に一つの他の場所で使用される &lt;code&gt;Some(x) if x &amp;gt; 200&lt;/code&gt; 使用します。</target>
        </trans-unit>
        <trans-unit id="60fa964e136b0f0fd7616e520f7abaf2ebfa7111" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ignore&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;ignore&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="1f363aa597e809eee39b1326a49009f8ed22190d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ignore&lt;/code&gt; attribute may optionally be written with the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to specify a reason why the test is ignored.</source>
          <target state="translated">&lt;code&gt;ignore&lt;/code&gt; 属性が任意に書き込むことができ&lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStrの&lt;/em&gt;&lt;/a&gt;テストは無視される理由を指定する構文。</target>
        </trans-unit>
        <trans-unit id="db8fdc6685b8fc701d318f4f3dec52f0b9a4e868" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;impl Trait&lt;/code&gt; return type captures lifetime parameters that do not appear within the &lt;code&gt;impl Trait&lt;/code&gt; itself.</source>
          <target state="translated">&lt;code&gt;impl Trait&lt;/code&gt; 内に表示されていない戻り値の型キャプチャ寿命パラメータ &lt;code&gt;impl Trait&lt;/code&gt; そのもの。</target>
        </trans-unit>
        <trans-unit id="c9150ca2fdc92a2e0f4ccf4f986d692afa5493d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;impl Trait&lt;/code&gt; syntax is convenient and makes for more concise code in simple cases. The trait bound syntax can express more complexity in other cases. For example, we can have two parameters that implement &lt;code&gt;Summary&lt;/code&gt;. Using the &lt;code&gt;impl Trait&lt;/code&gt; syntax looks like this:</source>
          <target state="translated">&lt;code&gt;impl Trait&lt;/code&gt; 構文が便利であり、簡単な例では、より簡潔なコードになります。特性にバインドされた構文は、他のケースではより複雑になる可能性があります。たとえば、 &lt;code&gt;Summary&lt;/code&gt; を実装する2つのパラメーターを持つことができます。 &lt;code&gt;impl Trait&lt;/code&gt; 構文を使用すると、次のようになります。</target>
        </trans-unit>
        <trans-unit id="778ea7a6b81f5bfa7d87e34cfb75fde414639934" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;impl Trait&lt;/code&gt; syntax works for straightforward cases but is actually syntax sugar for a longer form, which is called a &lt;em&gt;trait bound&lt;/em&gt;; it looks like this:</source>
          <target state="translated">&lt;code&gt;impl Trait&lt;/code&gt; 構文は簡単な例のために動作しますが、実際に呼び出される長いフォーム、シンタックスシュガーで&lt;em&gt;拘束さトレイト&lt;/em&gt;。次のようになります。</target>
        </trans-unit>
        <trans-unit id="2ffdcc0f4b373da2777f00eb0b778b9205836471" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;impl&lt;/code&gt; keyword is primarily used to define implementations on types. Inherent implementations are standalone, while trait implementations are used to implement traits for types, or other traits.</source>
          <target state="translated">&lt;code&gt;impl&lt;/code&gt; のキーワードは、主なタイプの実装を定義するために使用されます。固有の実装はスタンドアロンですが、特性の実装は型の特性またはその他の特性を実装するために使用されます。</target>
        </trans-unit>
        <trans-unit id="49b529510ff41b8ce0e4f03d01af2d0795d82946" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;incoming&lt;/code&gt; method on &lt;code&gt;TcpListener&lt;/code&gt; returns an iterator that gives us a sequence of streams (more specifically, streams of type &lt;code&gt;TcpStream&lt;/code&gt;). A single &lt;em&gt;stream&lt;/em&gt; represents an open connection between the client and the server. A &lt;em&gt;connection&lt;/em&gt; is the name for the full request and response process in which a client connects to the server, the server generates a response, and the server closes the connection. As such, &lt;code&gt;TcpStream&lt;/code&gt; will read from itself to see what the client sent and then allow us to write our response to the stream. Overall, this &lt;code&gt;for&lt;/code&gt; loop will process each connection in turn and produce a series of streams for us to handle.</source>
          <target state="translated">&lt;code&gt;TcpListener&lt;/code&gt; の &lt;code&gt;incoming&lt;/code&gt; メソッドは、一連のストリーム（より具体的には、 &lt;code&gt;TcpStream&lt;/code&gt; タイプのストリーム）を提供するイテレータを返します。単一の&lt;em&gt;ストリーム&lt;/em&gt;は、クライアントとサーバー間のオープン接続を表します。&lt;em&gt;接続は、&lt;/em&gt;クライアントがサーバに接続し、サーバーが応答を生成し、サーバーが接続を閉じるには、完全な要求と応答プロセスの名前です。そのため、 &lt;code&gt;TcpStream&lt;/code&gt; はそれ自体から読み取り、クライアントが送信したものを確認してから、ストリームへの応答を書き込むことができます。全体として、この &lt;code&gt;for&lt;/code&gt; ループは各接続を順番に処理し、処理する一連のストリームを生成します。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3ae3f99054fefa43fcfe679af5b3d84ea2c62ac1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inline&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;inline&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="f0d784eef56974f3daef0d597995f18b5e5f8afb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inline&lt;/code&gt; attribute only supports two arguments:</source>
          <target state="translated">&lt;code&gt;inline&lt;/code&gt; 属性は二つの引数をサポートしています。</target>
        </trans-unit>
        <trans-unit id="bc1a141c850728d98b956fd0716ebc10f9ffb6e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inline&lt;/code&gt; attribute was malformed.</source>
          <target state="translated">&lt;code&gt;inline&lt;/code&gt; 属性の形式が正しくありません。</target>
        </trans-unit>
        <trans-unit id="91c34dfeac33c0fc72de6d1c1ac619e7a9084ef1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;instruction_set&lt;/code&gt; attribute only supports two arguments currently:</source>
          <target state="translated">現在、 &lt;code&gt;instruction_set&lt;/code&gt; 属性は2つの引数のみをサポートしています。</target>
        </trans-unit>
        <trans-unit id="65492eab1824c51df92e478cb44c3823042f292f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;instruction_set&lt;/code&gt; attribute was malformed.</source>
          <target state="translated">&lt;code&gt;instruction_set&lt;/code&gt; の属性が不正な形式でした。</target>
        </trans-unit>
        <trans-unit id="4788ad11ac891125e5295255c9d02cd7b36750e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;isize&lt;/code&gt; type is a signed integer type with the same number of bits as the platform's pointer type. The theoretical upper bound on object and array size is the maximum &lt;code&gt;isize&lt;/code&gt; value. This ensures that &lt;code&gt;isize&lt;/code&gt; can be used to calculate differences between pointers into an object or array and can address every byte within an object along with one byte past the end.</source>
          <target state="translated">&lt;code&gt;isize&lt;/code&gt; タイプは、プラットフォームのポインタ型と同じビット数を有する符号付き整数型です。オブジェクトと配列サイズの理論上の上限は、最大 &lt;code&gt;isize&lt;/code&gt; 値です。これにより、 &lt;code&gt;isize&lt;/code&gt; を使用してオブジェクトまたは配列へのポインター間の差を計算し、オブジェクト内のすべてのバイトを最後の1バイトとともに処理できるようになります。</target>
        </trans-unit>
        <trans-unit id="7d599bd6c4aa9e941662680b3c4cf55e952c7777" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;it_works&lt;/code&gt; function now has a return type, &lt;code&gt;Result&amp;lt;(), String&amp;gt;&lt;/code&gt;. In the body of the function, rather than calling the &lt;code&gt;assert_eq!&lt;/code&gt; macro, we return &lt;code&gt;Ok(())&lt;/code&gt; when the test passes and an &lt;code&gt;Err&lt;/code&gt; with a &lt;code&gt;String&lt;/code&gt; inside when the test fails.</source>
          <target state="translated">&lt;code&gt;it_works&lt;/code&gt; は今、戻り値の型を持つ関数、 &lt;code&gt;Result&amp;lt;(), String&amp;gt;&lt;/code&gt; 。関数の本文では、 &lt;code&gt;assert_eq!&lt;/code&gt; マクロは、我々が戻り &lt;code&gt;Ok(())&lt;/code&gt; 試験を通過したとき &lt;code&gt;Err&lt;/code&gt; と &lt;code&gt;String&lt;/code&gt; テストが失敗したときに内部。</target>
        </trans-unit>
        <trans-unit id="d7cf351f8d0a069e43102c73f4dd09e2f7958bd2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;largest&lt;/code&gt; function has a parameter called &lt;code&gt;list&lt;/code&gt;, which represents any concrete slice of &lt;code&gt;i32&lt;/code&gt; values that we might pass into the function. As a result, when we call the function, the code runs on the specific values that we pass in.</source>
          <target state="translated">&lt;code&gt;largest&lt;/code&gt; 機能は、というパラメータがある &lt;code&gt;list&lt;/code&gt; のいずれかの具体的なスライスを表し、 &lt;code&gt;i32&lt;/code&gt; 我々は関数に渡すかもしれないという値を。その結果、関数を呼び出すと、渡した特定の値に対してコードが実行されます。</target>
        </trans-unit>
        <trans-unit id="29c272390da5b69d23c340bb06b514ca355b63f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;largest_i32&lt;/code&gt; function is the one we extracted in Listing 10-3 that finds the largest &lt;code&gt;i32&lt;/code&gt; in a slice. The &lt;code&gt;largest_char&lt;/code&gt; function finds the largest &lt;code&gt;char&lt;/code&gt; in a slice. The function bodies have the same code, so let&amp;rsquo;s eliminate the duplication by introducing a generic type parameter in a single function.</source>
          <target state="translated">&lt;code&gt;largest_i32&lt;/code&gt; の機能は、最大見つけた私たちは、リスト10-3で抽出されたものです &lt;code&gt;i32&lt;/code&gt; スライスして。 &lt;code&gt;largest_char&lt;/code&gt; の機能は、最大見つかっ &lt;code&gt;char&lt;/code&gt; スライス中を。関数本体のコードは同じなので、単一の関数にジェネリック型パラメーターを導入して重複を排除しましょう。</target>
        </trans-unit>
        <trans-unit id="d1c6673a10646101d9e252f3f63c9d87dc9cd482" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;len&lt;/code&gt; argument is the number of &lt;strong&gt;elements&lt;/strong&gt;, not the number of bytes.</source>
          <target state="translated">&lt;code&gt;len&lt;/code&gt; の引数は数ある&lt;strong&gt;要素&lt;/strong&gt;ではなく、バイト数。</target>
        </trans-unit>
        <trans-unit id="eabd24b648d02186aedafa8c6e64a26cd4789b21" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;let y = 6&lt;/code&gt; statement does not return a value, so there isn&amp;rsquo;t anything for &lt;code&gt;x&lt;/code&gt; to bind to. This is different from what happens in other languages, such as C and Ruby, where the assignment returns the value of the assignment. In those languages, you can write &lt;code&gt;x = y = 6&lt;/code&gt; and have both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; have the value &lt;code&gt;6&lt;/code&gt;; that is not the case in Rust.</source>
          <target state="translated">&lt;code&gt;let y = 6&lt;/code&gt; の文は、値を返さないので、何のために存在しない &lt;code&gt;x&lt;/code&gt; がバインドします。これは、割り当てが割り当ての値を返すCやRubyなどの他の言語で行われる処理とは異なります。これらの言語では、 &lt;code&gt;x = y = 6&lt;/code&gt; と記述して、 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; の両方の値を &lt;code&gt;6&lt;/code&gt; にすることができます。Rustではそうではありません。</target>
        </trans-unit>
        <trans-unit id="38e40fe06999fccdbadcd0aed2907afe5c6e93b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lines&lt;/code&gt; method returns an iterator. We&amp;rsquo;ll talk about iterators in depth in &lt;a href=&quot;ch13-02-iterators&quot;&gt;Chapter 13&lt;/a&gt;, but recall that you saw this way of using an iterator in &lt;a href=&quot;ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt;Listing 3-5&lt;/a&gt;, where we used a &lt;code&gt;for&lt;/code&gt; loop with an iterator to run some code on each item in a collection.</source>
          <target state="translated">&lt;code&gt;lines&lt;/code&gt; 方式は、イテレータを返します。イテレータについては&lt;a href=&quot;ch13-02-iterators&quot;&gt;第13章&lt;/a&gt;で詳しく説明しますが、&lt;a href=&quot;ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt;リスト3-5&lt;/a&gt;でイテレータを使用するこの方法を見たことを思い出してください。ここでは、イテレータで &lt;code&gt;for&lt;/code&gt; ループを使用して、コレクション内の各アイテムでコードを実行しました。</target>
        </trans-unit>
        <trans-unit id="eb368f642161e00040244b9fcf42bf09c020466c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lines&lt;/code&gt; method returns an iterator. We&amp;rsquo;ll talk about iterators in depth in [Chapter 13][ch13], but recall that you saw this way of using an iterator in &lt;a href=&quot;ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt;Listing 3-5&lt;/a&gt;, where we used a &lt;code&gt;for&lt;/code&gt; loop with an iterator to run some code on each item in a collection.</source>
          <target state="translated">&lt;code&gt;lines&lt;/code&gt; 方式は、イテレータを返します。[第13章] [ch13]でイテレータについて詳しく説明しますが、イテレータを使用した &lt;code&gt;for&lt;/code&gt; ループを使用して各項目でコードを実行する&lt;a href=&quot;ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt;リスト3-5で&lt;/a&gt;、イテレータを使用するこの方法を見たことを思い出してください。コレクション内。</target>
        </trans-unit>
        <trans-unit id="eb1d841506acd030675c6922085c83e81e995a8f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;link&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;link&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="af29024ed48791d318605b0393c71010ea60d49c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;link&lt;/code&gt; path will be a directory symbolic link pointing to the &lt;code&gt;original&lt;/code&gt; path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cf9ac2925c8b8fb84178289497c1b39bb11bb90" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;link&lt;/code&gt; path will be a file symbolic link pointing to the &lt;code&gt;original&lt;/code&gt; path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb820dbe8f4e45b83309321afde7bf80e0442104" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;link&lt;/code&gt; path will be a link pointing to the &lt;code&gt;original&lt;/code&gt; path. Note that systems often require these two paths to both be located on the same filesystem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="564ab23a645cf02d9458908cfb88d672f6c6b2b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;link&lt;/code&gt; path will be a symbolic link pointing to the &lt;code&gt;original&lt;/code&gt; path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7fa4135f2d931c559fc3f2824836ed87d617ec2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;link&lt;/code&gt; path will be a symbolic link pointing to the &lt;code&gt;original&lt;/code&gt; path. On Windows, this will be a file symlink, not a directory symlink; for this reason, the platform-specific &lt;a href=&quot;../os/unix/fs/fn.symlink&quot;&gt;&lt;code&gt;std::os::unix::fs::symlink&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../os/windows/fs/fn.symlink_file&quot;&gt;&lt;code&gt;std::os::windows::fs::symlink_file&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../os/windows/fs/fn.symlink_dir&quot;&gt;&lt;code&gt;symlink_dir&lt;/code&gt;&lt;/a&gt; should be used instead to make the intent explicit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49ce3813b3cc29f6621eed5040dfcafe494f7af6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;link_name&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;link_name&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="affa85dfaaac9c19595e178102133ab86d473f6f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;link_name&lt;/code&gt; attribute may be specified on declarations inside an &lt;code&gt;extern&lt;/code&gt; block to indicate the symbol to import for the given function or static. It uses the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to specify the name of the symbol.</source>
          <target state="translated">&lt;code&gt;link_name&lt;/code&gt; 属性は、内部の宣言で指定することができる &lt;code&gt;extern&lt;/code&gt; 所与の機能または静的ためインポートする記号を示すためにブロック。&lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt;構文を使用して、シンボルの名前を指定します。</target>
        </trans-unit>
        <trans-unit id="76e0be66315f639652150dfe37a31422ede56b88" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;link_section&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;link_section&lt;/code&gt; の属性</target>
        </trans-unit>
        <trans-unit id="5d3ac97ce0e51b7500958397678a0747500d6a86" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;locality&lt;/code&gt; argument must be a constant integer and is a temporal locality specifier ranging from (0) - no locality, to (3) - extremely local keep in cache</source>
          <target state="translated">&lt;code&gt;locality&lt;/code&gt; 引数は、一定の整数でなければならず、時間的局所指定子は（0）からの範囲である-キャッシュ内極めてローカルキープ- （3）に、無産地</target>
        </trans-unit>
        <trans-unit id="08d3f68a2cf00952341cb92b2cabeabf4f7aad60" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;locality&lt;/code&gt; argument must be a constant integer and is a temporal locality specifier ranging from (0) - no locality, to (3) - extremely local keep in cache.</source>
          <target state="translated">&lt;code&gt;locality&lt;/code&gt; 引数は定数整数でと（0）に至るまで時間的局所指定子である必要があります- （3）にノー地域、 -キャッシュ内極めてローカルキープ。</target>
        </trans-unit>
        <trans-unit id="ef1c91d4a25bd321565ee99def8880c9e7e661ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;loop&lt;/code&gt; keyword creates an infinite loop. We&amp;rsquo;ll add that now to give users more chances at guessing the number:</source>
          <target state="translated">&lt;code&gt;loop&lt;/code&gt; キーワードは、無限ループを作成します。これを追加して、ユーザーが数字を推測できるようにします。</target>
        </trans-unit>
        <trans-unit id="ebe9e1bcc2f0843b5208a2b5109915be71857732" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;loop&lt;/code&gt; keyword tells Rust to execute a block of code over and over again forever or until you explicitly tell it to stop.</source>
          <target state="translated">&lt;code&gt;loop&lt;/code&gt; キーワードは永遠か、明示的に停止するように指示されるまで何度も何度もコードのブロックを実行するために錆を伝えます。</target>
        </trans-unit>
        <trans-unit id="9910971bdcb643aec0b768364519db2f99d5aff4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;macro_use&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;macro_use&lt;/code&gt; の属性</target>
        </trans-unit>
        <trans-unit id="c25fb9655125d01a5a1e9d67f7f0780bc361281a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;main&lt;/code&gt; function here creates an instance of the &lt;code&gt;ImportantExcerpt&lt;/code&gt; struct that holds a reference to the first sentence of the &lt;code&gt;String&lt;/code&gt; owned by the variable &lt;code&gt;novel&lt;/code&gt;. The data in &lt;code&gt;novel&lt;/code&gt; exists before the &lt;code&gt;ImportantExcerpt&lt;/code&gt; instance is created. In addition, &lt;code&gt;novel&lt;/code&gt; doesn&amp;rsquo;t go out of scope until after the &lt;code&gt;ImportantExcerpt&lt;/code&gt; goes out of scope, so the reference in the &lt;code&gt;ImportantExcerpt&lt;/code&gt; instance is valid.</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; 機能は、ここでのインスタンス作成 &lt;code&gt;ImportantExcerpt&lt;/code&gt; 用の最初の文を参照保持構造体 &lt;code&gt;String&lt;/code&gt; 変数が所有 &lt;code&gt;novel&lt;/code&gt; 。 &lt;code&gt;novel&lt;/code&gt; のデータは、 &lt;code&gt;ImportantExcerpt&lt;/code&gt; インスタンスが作成される前に存在します。さらに、 &lt;code&gt;novel&lt;/code&gt; は &lt;code&gt;ImportantExcerpt&lt;/code&gt; がスコープ外になるまでスコープ外に出ないので、 &lt;code&gt;ImportantExcerpt&lt;/code&gt; インスタンスの参照は有効です。</target>
        </trans-unit>
        <trans-unit id="db5fe1609c8c74f709a4f1880a24bb8f27550e1d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;main&lt;/code&gt; function is special, and there are restrictions on what its return type must be. One valid return type for main is &lt;code&gt;()&lt;/code&gt;, and conveniently, another valid return type is &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;, as shown here:</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; 機能は特別であり、その戻り値の型でなければなりません何に制限があります。次に示すように、mainの1つの有効な戻り値の型は &lt;code&gt;()&lt;/code&gt; であり、別の有効な戻り値の型は &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="df8be9695315286ea699a84bc57bf274e0dcbb5a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;main&lt;/code&gt; function prototype should never take arguments. Example:</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; 関数のプロトタイプは引数を取ることはありません。例：</target>
        </trans-unit>
        <trans-unit id="db6afd48cca2e467a026116d5334792843766266" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;main&lt;/code&gt; function was defined with generic parameters.</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; 機能は、一般的なパラメータで定義されました。</target>
        </trans-unit>
        <trans-unit id="b77f7c754f9c38d3041a1e299a31ef7eeecfa144" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;main&lt;/code&gt; function was incorrectly declared.</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; 機能は、間違って宣言されました。</target>
        </trans-unit>
        <trans-unit id="43e2fa6b27c55d262177050d71a4a20b71217bb8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;move&lt;/code&gt; closure is often used alongside &lt;code&gt;thread::spawn&lt;/code&gt; because it allows you to use data from one thread in another thread.</source>
          <target state="translated">&lt;code&gt;move&lt;/code&gt; 閉鎖はしばしば一緒に使用されている &lt;code&gt;thread::spawn&lt;/code&gt; 、それはあなたが別のスレッド内の1つのスレッドからのデータを使用することができますので。</target>
        </trans-unit>
        <trans-unit id="619f2d182d04cd2437b9280f0034a655e725227f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mpsc::channel&lt;/code&gt; function returns a tuple, the first element of which is the sending end and the second element is the receiving end. The abbreviations &lt;code&gt;tx&lt;/code&gt; and &lt;code&gt;rx&lt;/code&gt; are traditionally used in many fields for &lt;em&gt;transmitter&lt;/em&gt; and &lt;em&gt;receiver&lt;/em&gt; respectively, so we name our variables as such to indicate each end. We&amp;rsquo;re using a &lt;code&gt;let&lt;/code&gt; statement with a pattern that destructures the tuples; we&amp;rsquo;ll discuss the use of patterns in &lt;code&gt;let&lt;/code&gt; statements and destructuring in Chapter 18. Using a &lt;code&gt;let&lt;/code&gt; statement this way is a convenient approach to extract the pieces of the tuple returned by &lt;code&gt;mpsc::channel&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mpsc::channel&lt;/code&gt; 機能は、送信端部および第2の要素である最初の要素は、受信端であり、タプルを返します。短縮形の &lt;code&gt;tx&lt;/code&gt; と &lt;code&gt;rx&lt;/code&gt; は、伝統的にそれぞれ&lt;em&gt;送信機&lt;/em&gt;と&lt;em&gt;受信機の&lt;/em&gt;多くのフィールドで使用されているため、それぞれの終わりを示すために変数に名前を付けています。タプルを分解するパターンを持つ &lt;code&gt;let&lt;/code&gt; ステートメントを使用しています。 &lt;code&gt;let&lt;/code&gt; ステートメントでのパターンの使用と構造化については、第18章で説明します。このように &lt;code&gt;let&lt;/code&gt; ステートメントを使用すると、 &lt;code&gt;mpsc::channel&lt;/code&gt; によって返されるタプルの断片を抽出するのに便利です。</target>
        </trans-unit>
        <trans-unit id="0a5adaf35abd6fb52abc875dfd1ff8ace4487057" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;must_use&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;must_use&lt;/code&gt; の属性</target>
        </trans-unit>
        <trans-unit id="4dc21fbdabdadeb25794ca5fcb0a8eb690cc55f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;must_use&lt;/code&gt; attribute may include a message by using the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax such as &lt;code&gt;#[must_use = &quot;example message&quot;]&lt;/code&gt;. The message will be given alongside the warning.</source>
          <target state="translated">&lt;code&gt;must_use&lt;/code&gt; の属性を使用してメッセージを含んでいてもよい&lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt;構文など &lt;code&gt;#[must_use = &quot;example message&quot;]&lt;/code&gt; 。メッセージは警告とともに表示されます。</target>
        </trans-unit>
        <trans-unit id="fa08dd7bde9ed9336c6bf68b835c76ace5a2b281" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name&lt;/code&gt; key must be included if &lt;code&gt;kind&lt;/code&gt; is specified.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 場合はキーが含まれていなければならない &lt;code&gt;kind&lt;/code&gt; 指定されています。</target>
        </trans-unit>
        <trans-unit id="4f5d61c5238b80d1372117cdc9301f7c5a015909" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_builtins&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;no_builtins&lt;/code&gt; の属性</target>
        </trans-unit>
        <trans-unit id="0e25b9ca8aa17342df965438e7d8b3912387ac96" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_link&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;no_link&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="4c0b9a2602cdb8c2f59fe6476a9d0299ede88a3c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_main&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;no_main&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="63ed748c3f1f47aec501358b0494a62e8e33119a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_mangle&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;no_mangle&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="3db3cdb5f8ea826a09ba97c6a8d286d70aec5a65" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;non_exhaustive&lt;/code&gt; attribute uses the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaWord&lt;/em&gt;&lt;/a&gt; syntax and thus does not take any inputs.</source>
          <target state="translated">&lt;code&gt;non_exhaustive&lt;/code&gt; 属性は使用しています&lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaWordの&lt;/em&gt;&lt;/a&gt;構文を、したがって、任意の入力を取ることはありません。</target>
        </trans-unit>
        <trans-unit id="f6746e3c0ec6ce06b907e0392a7e5f26c1647e02" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;not&lt;/code&gt; cfg-predicate was malformed.</source>
          <target state="translated">&lt;code&gt;not&lt;/code&gt; CFG-述語の形式が正しくありません。</target>
        </trans-unit>
        <trans-unit id="522f2fe5c8ca134ded384cd8e598baad904cbb06" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;not&lt;/code&gt; predicate expects one cfg-pattern. Example:</source>
          <target state="translated">&lt;code&gt;not&lt;/code&gt; 述語を期待1つのCFG-パターン。例：</target>
        </trans-unit>
        <trans-unit id="b32d84af66b0734455999894598a8249aed66fbb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;number&lt;/code&gt; variable will be bound to a value based on the outcome of the &lt;code&gt;if&lt;/code&gt; expression. Run this code to see what happens:</source>
          <target state="translated">&lt;code&gt;number&lt;/code&gt; 変数は、の結果に基づいた値にバインドされる &lt;code&gt;if&lt;/code&gt; 表現。このコードを実行して、何が起こるかを確認します。</target>
        </trans-unit>
        <trans-unit id="60fb1fa966c95caff6ec3f67558fb81ff746c1d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;op_string_ref&lt;/code&gt; binding has type &lt;code&gt;&amp;amp;Option&amp;lt;&amp;amp;String&amp;gt;&lt;/code&gt; in both cases.</source>
          <target state="translated">&lt;code&gt;op_string_ref&lt;/code&gt; 結合はタイプがある &lt;code&gt;&amp;amp;Option&amp;lt;&amp;amp;String&amp;gt;&lt;/code&gt; 両方のケースでは。</target>
        </trans-unit>
        <trans-unit id="2d0c9a8f467995322cb26a15b43a2ed10bd928bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;opt-level&lt;/code&gt; setting controls the number of optimizations Rust will apply to your code, with a range of 0 to 3. Applying more optimizations extends compiling time, so if you&amp;rsquo;re in development and compiling your code often, you&amp;rsquo;ll want faster compiling even if the resulting code runs slower. That is the reason the default &lt;code&gt;opt-level&lt;/code&gt; for &lt;code&gt;dev&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;. When you&amp;rsquo;re ready to release your code, it&amp;rsquo;s best to spend more time compiling. You&amp;rsquo;ll only compile in release mode once, but you&amp;rsquo;ll run the compiled program many times, so release mode trades longer compile time for code that runs faster. That is why the default &lt;code&gt;opt-level&lt;/code&gt; for the &lt;code&gt;release&lt;/code&gt; profile is &lt;code&gt;3&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;opt-level&lt;/code&gt; あなたが開発中だと、多くの場合、あなたのコードをコンパイルした場合ので、あなたがより速くたいと思う、錆がより多くの最適化を適用するに0〜3の範囲で、あなたのコードに適用される最適化の数が時間をコンパイルする拡張コントロールを設定します結果のコードの実行速度が遅くてもコンパイルします。これはデフォルトの理由である &lt;code&gt;opt-level&lt;/code&gt; のための &lt;code&gt;dev&lt;/code&gt; ある &lt;code&gt;0&lt;/code&gt; 。コードをリリースする準備ができたら、コンパイルにより多くの時間を費やすのが最善です。リリースモードでコンパイルするのは1回だけですが、コンパイルしたプログラムを何度も実行するため、リリースモードではコンパイル時間が長くなり、コードの実行速度が速くなります。そのため、 &lt;code&gt;release&lt;/code&gt; プロファイルのデフォルトの &lt;code&gt;opt-level&lt;/code&gt; は &lt;code&gt;3&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="6a0e04095b896f42634e32e5783ee8a2f1b36521" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;or_insert&lt;/code&gt; method on &lt;code&gt;Entry&lt;/code&gt; is defined to return a mutable reference to the value for the corresponding &lt;code&gt;Entry&lt;/code&gt; key if that key exists, and if not, inserts the parameter as the new value for this key and returns a mutable reference to the new value. This technique is much cleaner than writing the logic ourselves and, in addition, plays more nicely with the borrow checker.</source>
          <target state="translated">&lt;code&gt;Entry&lt;/code&gt; の &lt;code&gt;or_insert&lt;/code&gt; メソッドは、対応する &lt;code&gt;Entry&lt;/code&gt; キーの値への変更可能な参照を返すように定義されています（存在する場合）。そのキーが存在する場合は、このキーの新しい値としてパラメーターを挿入し、新しい値への変更可能な参照を返します。この手法は、自分でロジックを記述するよりもはるかにクリーンであり、さらに、借用チェッカーでよりうまく機能します。</target>
        </trans-unit>
        <trans-unit id="5765edeaf80c221a9f18bdca89b6a7375ddc1b5d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;original&lt;/code&gt; path is not a file or doesn't exist.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6774c9469b6011fbcb32c16aad7d03e8b6f6c4d5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;panic_handler&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;panic_handler&lt;/code&gt; の属性</target>
        </trans-unit>
        <trans-unit id="a6291890b4261d452b074ebd1ea09861364cf569" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;path&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="eca9cdb5a96c8de323e434d012e339f61d08ae9a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;path&lt;/code&gt; points at a non-directory file.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 非ディレクトリファイルのポイント。</target>
        </trans-unit>
        <trans-unit id="34ed0df01305ce0f75ec5fd43922003af97a525e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;poll&lt;/code&gt; function is not called repeatedly in a tight loop -- instead, it should only be called when the future indicates that it is ready to make progress (by calling &lt;code&gt;wake()&lt;/code&gt;). If you're familiar with the &lt;code&gt;poll(2)&lt;/code&gt; or &lt;code&gt;select(2)&lt;/code&gt; syscalls on Unix it's worth noting that futures typically do &lt;em&gt;not&lt;/em&gt; suffer the same problems of &quot;all wakeups must poll all events&quot;; they are more like &lt;code&gt;epoll(4)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;poll&lt;/code&gt; 機能がタイトループ内で繰り返し呼び出されていない-代わりに、それは唯一と呼ばれるべき将来は進歩を遂げる準備ができていることを示している場合（呼び出すことによって &lt;code&gt;wake()&lt;/code&gt; ）。Unixでの &lt;code&gt;poll(2)&lt;/code&gt; または &lt;code&gt;select(2)&lt;/code&gt; の syscallsに精通している場合、フューチャーは通常、「すべてのウェイクアップですべてのイベントをポーリングする必要がある」という同じ問題に悩まされ&lt;em&gt;ない&lt;/em&gt;ことに注意してください。それらは &lt;code&gt;epoll(4)&lt;/code&gt; に似ています。</target>
        </trans-unit>
        <trans-unit id="a4cdf57409266ff4ceaefa41a5aa6a9d06ca0f60" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;poll&lt;/code&gt; method</source>
          <target state="translated">&lt;code&gt;poll&lt;/code&gt; 方法</target>
        </trans-unit>
        <trans-unit id="f69f8390bb6f3d4deb2545de4fdfa29877369556" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prefetch&lt;/code&gt; intrinsic is a hint to the code generator to insert a prefetch instruction if supported; otherwise, it is a no-op. Prefetches have no effect on the behavior of the program but can change its performance characteristics.</source>
          <target state="translated">&lt;code&gt;prefetch&lt;/code&gt; 真性はサポートされている場合、プリフェッチ命令を挿入するコードジェネレータへのヒントです。それ以外の場合は、何もしません。プリフェッチはプログラムの動作には影響しませんが、パフォーマンス特性を変更する可能性があります。</target>
        </trans-unit>
        <trans-unit id="fa7fa9cd2241a28cad4fa12a2f135f7ef3c12daf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;println!&lt;/code&gt; function is only capable of printing to standard output, so we have to use something else to print to standard error.</source>
          <target state="translated">&lt;code&gt;println!&lt;/code&gt; 関数は標準出力にのみ出力できるため、標準エラーに出力するには別のものを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="f554c0d8cd003f0dac64077248339772aef74465" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;println!&lt;/code&gt; macro can do many kinds of formatting, and by default, the curly brackets tell &lt;code&gt;println!&lt;/code&gt; to use formatting known as &lt;code&gt;Display&lt;/code&gt;: output intended for direct end user consumption. The primitive types we&amp;rsquo;ve seen so far implement &lt;code&gt;Display&lt;/code&gt; by default, because there&amp;rsquo;s only one way you&amp;rsquo;d want to show a &lt;code&gt;1&lt;/code&gt; or any other primitive type to a user. But with structs, the way &lt;code&gt;println!&lt;/code&gt; should format the output is less clear because there are more display possibilities: Do you want commas or not? Do you want to print the curly brackets? Should all the fields be shown? Due to this ambiguity, Rust doesn&amp;rsquo;t try to guess what we want, and structs don&amp;rsquo;t have a provided implementation of &lt;code&gt;Display&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;println!&lt;/code&gt; マクロは多くの種類のフォーマットを行うことができ、デフォルトでは、中括弧は &lt;code&gt;println!&lt;/code&gt; &lt;code&gt;Display&lt;/code&gt; と呼ばれるフォーマットを使用するには、直接エンドユーザーが使用することを目的とした出力。これまで見てきたプリミティブ型は、デフォルトで &lt;code&gt;Display&lt;/code&gt; を実装します。これは、ユーザーに &lt;code&gt;1&lt;/code&gt; またはその他のプリミティブ型を表示する方法が1つしかないためです。しかし、構造体では、方法 &lt;code&gt;println!&lt;/code&gt; より多くの表示の可能性があるため、出力のフォーマットはあまり明確ではないはずです：コンマが必要かどうか？中かっこを印刷しますか？すべてのフィールドを表示する必要がありますか？このあいまいさのため、Rustは私たちが何を望んでいるかを推測しようとせず、構造体には提供された実装がありません &lt;code&gt;Display&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="02931ec361bbc5f61952272ead50c2b1cc721cb3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;println!&lt;/code&gt; macro is only capable of printing to standard output, so we have to use something else to print to standard error.</source>
          <target state="translated">&lt;code&gt;println!&lt;/code&gt; マクロは標準出力にしか印刷できないため、標準エラーに印刷するには別のものを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="df3a7253c874e9c54aed370b97b0410e823ccbd2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;proc_macro&lt;/code&gt; crate</source>
          <target state="translated">&lt;code&gt;proc_macro&lt;/code&gt; クレート</target>
        </trans-unit>
        <trans-unit id="0ebc19fdeafa41e303e045832093f26b01f1011c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pub&lt;/code&gt; keyword was used inside a function.</source>
          <target state="translated">&lt;code&gt;pub&lt;/code&gt; キーワードは、関数の内部で使用されました。</target>
        </trans-unit>
        <trans-unit id="a4aeb159d9e69df04b16b32d0a540b4e48d1c2ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pub&lt;/code&gt; keyword was used inside a function. Erroneous code example:</source>
          <target state="translated">&lt;code&gt;pub&lt;/code&gt; キーワードは、関数の内部で使用されました。誤ったコード例：</target>
        </trans-unit>
        <trans-unit id="b670fe1e664ec6db0ea27f497b8f300d96565afa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pub&lt;/code&gt; keyword was used inside a public enum.</source>
          <target state="translated">&lt;code&gt;pub&lt;/code&gt; キーワードは、パブリック列挙型の内部で使用されました。</target>
        </trans-unit>
        <trans-unit id="d36ebedc5c61f3368fb308364706ea53f77e634b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pub&lt;/code&gt; keyword was used inside a public enum. Erroneous code example:</source>
          <target state="translated">&lt;code&gt;pub&lt;/code&gt; キーワードは、パブリック列挙型の内部で使用されました。誤ったコード例：</target>
        </trans-unit>
        <trans-unit id="89040e996b7c32a3ab2a5577f18946b9e48cbcca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;push&lt;/code&gt; method takes a single character as a parameter and adds it to the &lt;code&gt;String&lt;/code&gt;. Listing 8-17 shows code that adds the letter &quot;l&quot; to a &lt;code&gt;String&lt;/code&gt; using the &lt;code&gt;push&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="855c30613293c5803da1be19530bcff46d089f73" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;push&lt;/code&gt; method takes a single character as a parameter and adds it to the &lt;code&gt;String&lt;/code&gt;. Listing 8-17 shows code that adds the letter &lt;em&gt;l&lt;/em&gt; to a &lt;code&gt;String&lt;/code&gt; using the &lt;code&gt;push&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;push&lt;/code&gt; メソッドは、パラメータとして単一の文字を取り、それを追加します &lt;code&gt;String&lt;/code&gt; 。リスト8-17は、 &lt;code&gt;push&lt;/code&gt; メソッドを使用して文字&lt;em&gt;l&lt;/em&gt;を &lt;code&gt;String&lt;/code&gt; 追加するコードを示しています。</target>
        </trans-unit>
        <trans-unit id="e7c0b086ee3b65e9ef7299c70cf8f6fd0c56999e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;quote!&lt;/code&gt; macro also provides some very cool templating mechanics: we can enter &lt;code&gt;#name&lt;/code&gt;, and &lt;code&gt;quote!&lt;/code&gt; will replace it with the value in the variable &lt;code&gt;name&lt;/code&gt;. You can even do some repetition similar to the way regular macros work. Check out &lt;a href=&quot;https://docs.rs/quote&quot;&gt;the &lt;code&gt;quote&lt;/code&gt; crate&amp;rsquo;s docs&lt;/a&gt; for a thorough introduction.</source>
          <target state="translated">&lt;code&gt;quote!&lt;/code&gt; マクロは、いくつかの非常に優れたテンプレートメカニズムも提供し &lt;code&gt;quote!&lt;/code&gt; &lt;code&gt;#name&lt;/code&gt; を入力して、引用することができます！変数 &lt;code&gt;name&lt;/code&gt; 値に置き換えます。通常のマクロと同じように、繰り返しを行うこともできます。チェックアウト&lt;a href=&quot;https://docs.rs/quote&quot;&gt; &lt;code&gt;quote&lt;/code&gt; &lt;/a&gt;クレートのドキュメントを徹底的に紹介するために。</target>
        </trans-unit>
        <trans-unit id="62ab310a7862369bfdb3998e805adaae0cd4f2e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;quote!&lt;/code&gt; macro lets us define the Rust code that we want to return. The compiler expects something different to the direct result of the &lt;code&gt;quote!&lt;/code&gt; macro&amp;rsquo;s execution, so we need to convert it to a &lt;code&gt;TokenStream&lt;/code&gt;. We do this by calling the &lt;code&gt;into&lt;/code&gt; method, which consumes this intermediate representation and returns a value of the required &lt;code&gt;TokenStream&lt;/code&gt; type.</source>
          <target state="translated">&lt;code&gt;quote!&lt;/code&gt; マクロを使用すると、返すRustコードを定義できます。コンパイラは、 &lt;code&gt;quote!&lt;/code&gt; 直接の結果とは異なるものを期待しています！マクロの実行なので、それを &lt;code&gt;TokenStream&lt;/code&gt; に変換する必要があります。これを行うには、 &lt;code&gt;into&lt;/code&gt; メソッドを呼び出します。これにより、この中間表現が消費され、必要な &lt;code&gt;TokenStream&lt;/code&gt; タイプの値が返されます。</target>
        </trans-unit>
        <trans-unit id="53ae9c1c1e33423bee13e403e332e75689959214" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ready!&lt;/code&gt; call expands to:</source>
          <target state="translated">&lt;code&gt;ready!&lt;/code&gt; 呼び出しは次のように展開されます。</target>
        </trans-unit>
        <trans-unit id="b83941e960f12671a681a1df28d6d59cb442a02e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;recursion_limit&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;recursion_limit&lt;/code&gt; の属性</target>
        </trans-unit>
        <trans-unit id="7fd3ec074e9dd99ae0db784fdf399ea43dd43516" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ref&lt;/code&gt; and/or &lt;code&gt;mut&lt;/code&gt;&lt;em&gt;IDENTIFIER&lt;/em&gt; syntax matches any value and binds it to a variable with the same name as the given field.</source>
          <target state="translated">&lt;code&gt;ref&lt;/code&gt; および/または &lt;code&gt;mut&lt;/code&gt; &lt;em&gt;IDENTIFIERの&lt;/em&gt;構文は、指定されたフィールドと同じ名前の変数に任意の値とバインドそれにマッチします。</target>
        </trans-unit>
        <trans-unit id="a07e646920bfd0169ef8462620bb6bf857e50545" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;repeat()&lt;/code&gt; function repeats a single value over and over again.</source>
          <target state="translated">&lt;code&gt;repeat()&lt;/code&gt; 関数は、何度も何度も単一の値を繰り返します。</target>
        </trans-unit>
        <trans-unit id="ca6b7fab269378f975039696a9d029f43743fe55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;repeat_with()&lt;/code&gt; function calls the repeater over and over again.</source>
          <target state="translated">&lt;code&gt;repeat_with()&lt;/code&gt; 関数は、何度も何度もリピーターを呼び出します。</target>
        </trans-unit>
        <trans-unit id="203b4d4e0f959a4e516770bf1c8acd411f9645d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;request_review&lt;/code&gt; and &lt;code&gt;approve&lt;/code&gt; methods take ownership of &lt;code&gt;self&lt;/code&gt;, thus consuming the &lt;code&gt;DraftPost&lt;/code&gt; and &lt;code&gt;PendingReviewPost&lt;/code&gt; instances and transforming them into a &lt;code&gt;PendingReviewPost&lt;/code&gt; and a published &lt;code&gt;Post&lt;/code&gt;, respectively. This way, we won&amp;rsquo;t have any lingering &lt;code&gt;DraftPost&lt;/code&gt; instances after we&amp;rsquo;ve called &lt;code&gt;request_review&lt;/code&gt; on them, and so forth. The &lt;code&gt;PendingReviewPost&lt;/code&gt; struct doesn&amp;rsquo;t have a &lt;code&gt;content&lt;/code&gt; method defined on it, so attempting to read its content results in a compiler error, as with &lt;code&gt;DraftPost&lt;/code&gt;. Because the only way to get a published &lt;code&gt;Post&lt;/code&gt; instance that does have a &lt;code&gt;content&lt;/code&gt; method defined is to call the &lt;code&gt;approve&lt;/code&gt; method on a &lt;code&gt;PendingReviewPost&lt;/code&gt;, and the only way to get a &lt;code&gt;PendingReviewPost&lt;/code&gt; is to call the &lt;code&gt;request_review&lt;/code&gt; method on a &lt;code&gt;DraftPost&lt;/code&gt;, we&amp;rsquo;ve now encoded the blog post workflow into the type system.</source>
          <target state="translated">&lt;code&gt;request_review&lt;/code&gt; および &lt;code&gt;approve&lt;/code&gt; 方法は、所有権の取る &lt;code&gt;self&lt;/code&gt; このように消費し、 &lt;code&gt;DraftPost&lt;/code&gt; と &lt;code&gt;PendingReviewPost&lt;/code&gt; インスタンスをとにそれらを変換 &lt;code&gt;PendingReviewPost&lt;/code&gt; し、公表 &lt;code&gt;Post&lt;/code&gt; 、それぞれ。このようにして、 &lt;code&gt;request_review&lt;/code&gt; を呼び出した後に、 &lt;code&gt;DraftPost&lt;/code&gt; インスタンスが残っていることはありません。 &lt;code&gt;PendingReviewPost&lt;/code&gt; の構造体は持っていない &lt;code&gt;content&lt;/code&gt; そうと同様に、コンパイラエラーでそのコンテンツの結果を読み取ろうとし、その上で定義されたメソッドを &lt;code&gt;DraftPost&lt;/code&gt; 。公開された &lt;code&gt;Post&lt;/code&gt; を取得する唯一の方法は &lt;code&gt;content&lt;/code&gt; メソッドが定義されているインスタンスは、 &lt;code&gt;PendingReviewPost&lt;/code&gt; で &lt;code&gt;approve&lt;/code&gt; メソッドを呼び出すことであり、 &lt;code&gt;PendingReviewPost&lt;/code&gt; を取得する唯一の方法は、 &lt;code&gt;DraftPost&lt;/code&gt; で &lt;code&gt;request_review&lt;/code&gt; メソッドを呼び出すことです。これで、ブログ投稿ワークフローを型システムにエンコードしました。</target>
        </trans-unit>
        <trans-unit id="14e654a0e6edb832d7ec2e9f01e2cec2e8fc8293" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;request_review&lt;/code&gt; method on &lt;code&gt;Draft&lt;/code&gt; needs to return a new, boxed instance of a new &lt;code&gt;PendingReview&lt;/code&gt; struct, which represents the state when a post is waiting for a review. The &lt;code&gt;PendingReview&lt;/code&gt; struct also implements the &lt;code&gt;request_review&lt;/code&gt; method but doesn&amp;rsquo;t do any transformations. Rather, it returns itself, because when we request a review on a post already in the &lt;code&gt;PendingReview&lt;/code&gt; state, it should stay in the &lt;code&gt;PendingReview&lt;/code&gt; state.</source>
          <target state="translated">&lt;code&gt;Draft&lt;/code&gt; の &lt;code&gt;request_review&lt;/code&gt; メソッドは、新しい &lt;code&gt;PendingReview&lt;/code&gt; 構造体の新しいボックス化されたインスタンスを返す必要があります。これは、投稿がレビューを待っているときの状態を表します。 &lt;code&gt;PendingReview&lt;/code&gt; の構造体はまた、実装 &lt;code&gt;request_review&lt;/code&gt; の方法をが、任意の変換を行いません。我々はすでにポストに審査を要求したときのでむしろ、それは、自分自身を返し &lt;code&gt;PendingReview&lt;/code&gt; の状態、それが中にとどまるべき &lt;code&gt;PendingReview&lt;/code&gt; の状態。</target>
        </trans-unit>
        <trans-unit id="e74e1506742074d3eac6be2b7d8e21235520da47" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;run&lt;/code&gt; command comes in handy when you need to rapidly iterate on a project, as we&amp;rsquo;ll do in this game, quickly testing each iteration before moving on to the next one.</source>
          <target state="translated">&lt;code&gt;run&lt;/code&gt; あなたは、私たちはすぐに次の1に移動する前に各反復をテストし、このゲームでやるように急速、プロジェクトに反復処理する必要がある場合、コマンドは便利です。</target>
        </trans-unit>
        <trans-unit id="46e85b1a08cc19eee77379933feec0b53082268f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;run&lt;/code&gt; function definition</source>
          <target state="translated">&lt;code&gt;run&lt;/code&gt; 関数の定義</target>
        </trans-unit>
        <trans-unit id="5e5f409e03a8829700c6b7a5a46ab61b65379877" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;run&lt;/code&gt; function now contains all the remaining logic from &lt;code&gt;main&lt;/code&gt;, starting from reading the file. The &lt;code&gt;run&lt;/code&gt; function takes the &lt;code&gt;Config&lt;/code&gt; instance as an argument.</source>
          <target state="translated">&lt;code&gt;run&lt;/code&gt; 機能は、今から残りのすべてのロジックが含まれている &lt;code&gt;main&lt;/code&gt; ファイルの読み込みから始め、。 &lt;code&gt;run&lt;/code&gt; 機能は取り &lt;code&gt;Config&lt;/code&gt; 引数としてインスタンスを。</target>
        </trans-unit>
        <trans-unit id="6fc1541b8f6585c0ffe5cd745827dfb79f574e45" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rustfmt&lt;/code&gt; tool reformats your code according to the community code style. Many collaborative projects use &lt;code&gt;rustfmt&lt;/code&gt; to prevent arguments about which style to use when writing Rust: everyone formats their code using the tool.</source>
          <target state="translated">&lt;code&gt;rustfmt&lt;/code&gt; のツールは、コミュニティのコードスタイルに応じて、あなたのコードを再フォーマットします。多くの共同プロジェクトは &lt;code&gt;rustfmt&lt;/code&gt; を使用して、Rustの作成時に使用するスタイルに関する引数を防止しています。誰もがツールを使用してコードをフォーマットしています。</target>
        </trans-unit>
        <trans-unit id="f41fbdae4087d677734daccb36bd68168ac22c54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;same_bucket&lt;/code&gt; function is passed references to two elements from the slice and must determine if the elements compare equal. The elements are passed in opposite order from their order in the slice, so if &lt;code&gt;same_bucket(a, b)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt; is moved at the end of the slice.</source>
          <target state="translated">&lt;code&gt;same_bucket&lt;/code&gt; の機能は、スライスからの二つの要素への参照を渡され、要素が等しい比較するかどうかを決定しなければなりません。要素はスライス内の順序とは逆の順序で渡されるため、 &lt;code&gt;same_bucket(a, b)&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; を返す場合、 &lt;code&gt;a&lt;/code&gt; はスライスの最後に移動します。</target>
        </trans-unit>
        <trans-unit id="51106981f7e1a09193991d8a2ebd9672888c0e0a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;same_bucket&lt;/code&gt; function is passed references to two elements from the vector and must determine if the elements compare equal. The elements are passed in opposite order from their order in the slice, so if &lt;code&gt;same_bucket(a, b)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt; is removed.</source>
          <target state="translated">&lt;code&gt;same_bucket&lt;/code&gt; の機能は、ベクターからの二つの要素への参照を渡され、要素が等しい比較するかどうかを決定しなければなりません。要素はスライス内の順序とは逆の順序で渡されるため、 &lt;code&gt;same_bucket(a, b)&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; を返す場合、 &lt;code&gt;a&lt;/code&gt; は削除されます。</target>
        </trans-unit>
        <trans-unit id="a14ee345d1496dff6fbc5e218ae3b33c17f09dd5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;search_case_insensitive&lt;/code&gt; function, shown in Listing 12-21, will be almost the same as the &lt;code&gt;search&lt;/code&gt; function. The only difference is that we&amp;rsquo;ll lowercase the &lt;code&gt;query&lt;/code&gt; and each &lt;code&gt;line&lt;/code&gt; so whatever the case of the input arguments, they&amp;rsquo;ll be the same case when we check whether the line contains the query.</source>
          <target state="translated">&lt;code&gt;search_case_insensitive&lt;/code&gt; リスト12-21で示される機能は、ほぼ同じになり &lt;code&gt;search&lt;/code&gt; 機能。唯一の違いは、我々は小文字だろうということで &lt;code&gt;query&lt;/code&gt; 、各 &lt;code&gt;line&lt;/code&gt; どんな入力引数の場合ので、我々は行がクエリが含まれているかどうかを確認するとき、彼らは同じケースになるでしょう。</target>
        </trans-unit>
        <trans-unit id="bbcc387564e51cca06178b88f2766991af78a4d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; crate may be imported which creates a binding to the current crate. In this case the &lt;code&gt;as&lt;/code&gt; clause must be used to specify the name to bind it to.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; クレート現在クレートへの結合を作成するインポートすることができます。この場合、 &lt;code&gt;as&lt;/code&gt; 句を使用して、バインド先の名前を指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="5df3512b09c8677b58f509f70a4092543dbb8630" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; import appears more than once in the list.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; インポートは、リスト内の複数回表示されます。</target>
        </trans-unit>
        <trans-unit id="776137337eaf5141c6cf75f1ef731869806d23fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; keyword can only be used inside methods, which are associated functions (functions defined inside of a &lt;code&gt;trait&lt;/code&gt; or &lt;code&gt;impl&lt;/code&gt; block) that have a &lt;code&gt;self&lt;/code&gt; receiver as its first parameter, like &lt;code&gt;self&lt;/code&gt;, &lt;code&gt;&amp;amp;self&lt;/code&gt;, &lt;code&gt;&amp;amp;mut self&lt;/code&gt; or &lt;code&gt;self: &amp;amp;mut Pin&amp;lt;Self&amp;gt;&lt;/code&gt; (this last one is an example of an &lt;a href=&quot;https://github.com/rust-lang/rust/issues/44874&quot;&gt;&quot;abitrary &lt;code&gt;self&lt;/code&gt; type&quot;&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; キーワードのみ機能（の内部定義された関数関連付けられているメソッド、内部で使用することができる &lt;code&gt;trait&lt;/code&gt; または &lt;code&gt;impl&lt;/code&gt; 有するブロック）を &lt;code&gt;self&lt;/code&gt; のように、最初のパラメータとしての受信機を &lt;code&gt;self&lt;/code&gt; 、 &lt;code&gt;&amp;amp;self&lt;/code&gt; 、 &lt;code&gt;&amp;amp;mut self&lt;/code&gt; 又は &lt;code&gt;self: &amp;amp;mut Pin&amp;lt;Self&amp;gt;&lt;/code&gt; （この最後のものは例である&lt;a href=&quot;https://github.com/rust-lang/rust/issues/44874&quot;&gt;「abitrary &lt;code&gt;self&lt;/code&gt; タイプ」&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="31848a0c1be52494be53b5a9553dbe8630cef51b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; keyword can only be used inside methods, which are associated functions (functions defined inside of a &lt;code&gt;trait&lt;/code&gt; or &lt;code&gt;impl&lt;/code&gt; block) that have a &lt;code&gt;self&lt;/code&gt; receiver as its first parameter, like &lt;code&gt;self&lt;/code&gt;, &lt;code&gt;&amp;amp;self&lt;/code&gt;, &lt;code&gt;&amp;amp;mut self&lt;/code&gt; or &lt;code&gt;self: &amp;amp;mut Pin&amp;lt;Self&amp;gt;&lt;/code&gt; (this last one is an example of an &lt;a href=&quot;https://github.com/rust-lang/rust/issues/44874&quot;&gt;&quot;arbitrary &lt;code&gt;self&lt;/code&gt; type&quot;&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; キーワードのみ機能（の内部定義された関数関連付けられているメソッド、内部で使用することができる &lt;code&gt;trait&lt;/code&gt; または &lt;code&gt;impl&lt;/code&gt; 有するブロック）を &lt;code&gt;self&lt;/code&gt; のように、最初のパラメータとしての受信機を &lt;code&gt;self&lt;/code&gt; 、 &lt;code&gt;&amp;amp;self&lt;/code&gt; 、 &lt;code&gt;&amp;amp;mut self&lt;/code&gt; 又は &lt;code&gt;self: &amp;amp;mut Pin&amp;lt;Self&amp;gt;&lt;/code&gt; （この最後のものは&lt;a href=&quot;https://github.com/rust-lang/rust/issues/44874&quot;&gt;「任意の &lt;code&gt;self&lt;/code&gt; タイプ」の&lt;/a&gt;例です）。</target>
        </trans-unit>
        <trans-unit id="ca20974e52a0607307348bb19d0d894eb2389060" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; keyword cannot appear alone as the last segment in a &lt;code&gt;use&lt;/code&gt; declaration.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; キーワードはで最後のセグメントとして単独で表示することはできません &lt;code&gt;use&lt;/code&gt; 宣言。</target>
        </trans-unit>
        <trans-unit id="3baa95a2b4735c8ad9eb06f47e895376f593ffa3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; keyword was used in a static method.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; キーワードは静的メソッドで使用されました。</target>
        </trans-unit>
        <trans-unit id="a9568dcdfe3a23be1dee117543923d717013ab13" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; keyword was used inside of an associated function without a &quot;&lt;code&gt;self&lt;/code&gt; receiver&quot; parameter.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; キーワードは「なし関連する機能の内部を使用した &lt;code&gt;self&lt;/code&gt; 受信機」パラメータ。</target>
        </trans-unit>
        <trans-unit id="f67620c2fbc5330097742f848b2b9886ad0ef4ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; parameter in a method has an invalid &quot;receiver type&quot;.</source>
          <target state="translated">メソッドの &lt;code&gt;self&lt;/code&gt; パラメーターに無効な「レシーバータイプ」があります。</target>
        </trans-unit>
        <trans-unit id="71e55d8484323ba680a4d79f359c6a8e4726809e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sent_messages&lt;/code&gt; field is now of type &lt;code&gt;RefCell&amp;lt;Vec&amp;lt;String&amp;gt;&amp;gt;&lt;/code&gt; instead of &lt;code&gt;Vec&amp;lt;String&amp;gt;&lt;/code&gt;. In the &lt;code&gt;new&lt;/code&gt; function, we create a new &lt;code&gt;RefCell&amp;lt;Vec&amp;lt;String&amp;gt;&amp;gt;&lt;/code&gt; instance around the empty vector.</source>
          <target state="translated">&lt;code&gt;sent_messages&lt;/code&gt; のフィールドは今のタイプである &lt;code&gt;RefCell&amp;lt;Vec&amp;lt;String&amp;gt;&amp;gt;&lt;/code&gt; の代わりに &lt;code&gt;Vec&amp;lt;String&amp;gt;&lt;/code&gt; 。では &lt;code&gt;new&lt;/code&gt; 機能は、我々は新しい作成 &lt;code&gt;RefCell&amp;lt;Vec&amp;lt;String&amp;gt;&amp;gt;&lt;/code&gt; 空のベクターの周りのインスタンスを。</target>
        </trans-unit>
        <trans-unit id="337c62942744e545dcf717c6319edbedc18f313b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shoes_in_my_size&lt;/code&gt; function takes ownership of a vector of shoes and a shoe size as parameters. It returns a vector containing only shoes of the specified size.</source>
          <target state="translated">&lt;code&gt;shoes_in_my_size&lt;/code&gt; の関数は、パラメータとして靴のベクトルと靴のサイズの所有権を取得します。指定されたサイズの靴のみを含むベクトルを返します。</target>
        </trans-unit>
        <trans-unit id="16a60caa064b42a78f27eb4d74ff02e2b3b32b36" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;should_panic&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;should_panic&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="639f1b128b2e8340c54ba2df925fcc505b0aa67b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;should_panic&lt;/code&gt; attribute may optionally take an input string that must appear within the panic message. If the string is not found in the message, then the test will fail. The string may be passed using the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax or the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListNameValueStr&lt;/em&gt;&lt;/a&gt; syntax with an &lt;code&gt;expected&lt;/code&gt; field.</source>
          <target state="translated">&lt;code&gt;should_panic&lt;/code&gt; 属性は、必要に応じてパニックメッセージの中に表示される必要があり、入力文字列がかかる場合があります。メッセージに文字列が見つからない場合、テストは失敗します。文字列は、使用して渡すことができ&lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStrの&lt;/em&gt;&lt;/a&gt;構文や&lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListNameValueStrの&lt;/em&gt;&lt;/a&gt;で構文を &lt;code&gt;expected&lt;/code&gt; 分野。</target>
        </trans-unit>
        <trans-unit id="47db49dacc0e9fe0c5ab4b84de0a525fbcc167ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;simd_shuffle&lt;/code&gt; function needs the length of the array passed as last parameter in its name. Example:</source>
          <target state="translated">&lt;code&gt;simd_shuffle&lt;/code&gt; 機能は、その名の最後のパラメータとして渡された配列の長さを必要とします。例：</target>
        </trans-unit>
        <trans-unit id="1728894948cd279e5a554b1af44ad631d3c73ca8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;spawn&lt;/code&gt; function returns a &lt;code&gt;JoinHandle&amp;lt;T&amp;gt;&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is the type that the closure returns. Let&amp;rsquo;s try using &lt;code&gt;JoinHandle&lt;/code&gt; too and see what happens. In our case, the closures we&amp;rsquo;re passing to the thread pool will handle the connection and not return anything, so &lt;code&gt;T&lt;/code&gt; will be the unit type &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;spawn&lt;/code&gt; 関数リターン &lt;code&gt;JoinHandle&amp;lt;T&amp;gt;&lt;/code&gt; 、 &lt;code&gt;T&lt;/code&gt; は閉鎖戻り、そのタイプです。 &lt;code&gt;JoinHandle&lt;/code&gt; も使用して、何が起こるか見てみましょう。今回の場合、スレッドプールに渡すクロージャーは接続を処理し、何も返さないため、 &lt;code&gt;T&lt;/code&gt; はユニットタイプ &lt;code&gt;()&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="566807adf1a1b2e0676b75e750b724f0403f4cce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;src&lt;/code&gt; path is not a file or doesn't exist.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; パスはファイルではありませんか、存在しません。</target>
        </trans-unit>
        <trans-unit id="8b80b9ca4d5b5301222f74ba4e7cb474c1a9b0c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start..&lt;/code&gt; syntax is a &lt;code&gt;RangeFrom&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;start..&lt;/code&gt; 構文は次のとおりです &lt;code&gt;RangeFrom&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="d29bbe16c04fa990f15f7ad6e1fd231be48fb8e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start..=end&lt;/code&gt; syntax is a &lt;code&gt;RangeInclusive&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;start..=end&lt;/code&gt; 構文は次のとおりです &lt;code&gt;RangeInclusive&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="f551a983bf25bb9ca332d4bf79a3c5ffe5eff531" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start..end&lt;/code&gt; syntax is a &lt;code&gt;Range&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;start..end&lt;/code&gt; の構文は次のとおりです。 &lt;code&gt;Range&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="07635229348f3268d25fca1958c374b441ce892b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start&lt;/code&gt; function was defined with a where clause.</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; 機能は、where句で定義されました。</target>
        </trans-unit>
        <trans-unit id="a73480c4afd7847e00e31fe3aafec20a20c54b25" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;static&lt;/code&gt; keyword, on the other hand, guarantees a fixed location in memory. This does not always mean that the value is constant. For example, a global mutex can be declared &lt;code&gt;static&lt;/code&gt; as well.</source>
          <target state="translated">&lt;code&gt;static&lt;/code&gt; キーワードは、他方で、メモリ内の固定位置を保証します。これは常に値が一定であることを意味しません。たとえば、グローバルmutexも &lt;code&gt;static&lt;/code&gt; として宣言できます。</target>
        </trans-unit>
        <trans-unit id="d33afa111381148e1c91bd2523fbea89118180e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;std::env&lt;/code&gt; module contains many more useful features for dealing with environment variables: check out its documentation to see what is available.</source>
          <target state="translated">&lt;code&gt;std::env&lt;/code&gt; モジュールの環境変数を扱うためのより多くの便利な機能が含まれています。利用可能であるかを確認するために、そのドキュメントをチェックしてください。</target>
        </trans-unit>
        <trans-unit id="bcaf28a16adceb8447193d5235bef5d8bd3335ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;std::io&lt;/code&gt; module contains a number of common things you'll need when doing input and output. The most core part of this module is the &lt;a href=&quot;trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.write&quot;&gt;&lt;code&gt;Write&lt;/code&gt;&lt;/a&gt; traits, which provide the most general interface for reading and writing input and output.</source>
          <target state="translated">&lt;code&gt;std::io&lt;/code&gt; モジュールは、入力および出力を行うときに必要になります一般的なものの数が含まれています。このモジュールの最も中心的な部分は、入出力の&lt;a href=&quot;trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;trait.write&quot;&gt; &lt;code&gt;Write&lt;/code&gt; &lt;/a&gt;ための最も一般的なインターフェイスを提供する読み取りおよび書き込み特性です。</target>
        </trans-unit>
        <trans-unit id="4a54af6bd4d1bf95ed93c13cd61787ff3a49ae58" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;std::mem::drop&lt;/code&gt; function is different from the &lt;code&gt;drop&lt;/code&gt; method in the &lt;code&gt;Drop&lt;/code&gt; trait. We call it by passing the value we want to force to be dropped early as an argument. The function is in the prelude, so we can modify &lt;code&gt;main&lt;/code&gt; in Listing 15-15 to call the &lt;code&gt;drop&lt;/code&gt; function, as shown in Listing 15-16:</source>
          <target state="translated">&lt;code&gt;std::mem::drop&lt;/code&gt; 機能が異なっている &lt;code&gt;drop&lt;/code&gt; のメソッド &lt;code&gt;Drop&lt;/code&gt; 特色。強制的に早期に削除する値を引数として渡すことで、それを呼び出します。この関数はプレリュードにあるため、リスト15-16に示すように、リスト15-15の &lt;code&gt;main&lt;/code&gt; を変更して &lt;code&gt;drop&lt;/code&gt; 関数を呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="964c58feb2d7a0e4b6c63c315388a37636bb2ffa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;steps_between&lt;/code&gt; function provides a way to efficiently compare two &lt;code&gt;Step&lt;/code&gt; objects.</source>
          <target state="translated">&lt;code&gt;steps_between&lt;/code&gt; 機能は、効率的に2つの比較する方法を提供 &lt;code&gt;Step&lt;/code&gt; オブジェクトを。</target>
        </trans-unit>
        <trans-unit id="3d6948e046aa3d769d70c7d7f5831db7b61d283e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;str&lt;/code&gt; type, also called a 'string slice', is the most primitive string type. It is usually seen in its borrowed form, &lt;code&gt;&amp;amp;str&lt;/code&gt;. It is also the type of string literals, &lt;code&gt;&amp;amp;'static str&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; も、「文字列スライス」と呼ばれるタイプは、最も原始的な文字列型です。通常は、借用された形式 &lt;code&gt;&amp;amp;str&lt;/code&gt; で表示されます。また、文字列リテラルのタイプ &lt;code&gt;&amp;amp;'static str&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4ea4c33d08beaf7c17c84c4930138d5a7a1f80fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;stringify!&lt;/code&gt; macro used here is built into Rust. It takes a Rust expression, such as &lt;code&gt;1 + 2&lt;/code&gt;, and at compile time turns the expression into a string literal, such as &lt;code&gt;&quot;1 + 2&quot;&lt;/code&gt;. This is different than &lt;code&gt;format!&lt;/code&gt; or &lt;code&gt;println!&lt;/code&gt;, macros which evaluate the expression and then turn the result into a &lt;code&gt;String&lt;/code&gt;. There is a possibility that the &lt;code&gt;#name&lt;/code&gt; input might be an expression to print literally, so we use &lt;code&gt;stringify!&lt;/code&gt;. Using &lt;code&gt;stringify!&lt;/code&gt; also saves an allocation by converting &lt;code&gt;#name&lt;/code&gt; to a string literal at compile time.</source>
          <target state="translated">&lt;code&gt;stringify!&lt;/code&gt; ここで使用するマクロはRustに組み込まれています。 &lt;code&gt;1 + 2&lt;/code&gt; などのRust式を受け取り、コンパイル時に式を &lt;code&gt;&quot;1 + 2&quot;&lt;/code&gt; などの文字列リテラルに変換します。これは &lt;code&gt;format!&lt;/code&gt; とは異なります！または &lt;code&gt;println!&lt;/code&gt; 、式を評価して結果を &lt;code&gt;String&lt;/code&gt; に変換するマクロ。 &lt;code&gt;#name&lt;/code&gt; 入力が文字通り出力する式である可能性があるため、stringifyを使用します &lt;code&gt;stringify!&lt;/code&gt; 。 &lt;code&gt;stringify!&lt;/code&gt; 使用！また、コンパイル時に &lt;code&gt;#name&lt;/code&gt; を文字列リテラルに変換することで割り当てを保存します。</target>
        </trans-unit>
        <trans-unit id="5e2bbf89c9d53502f02966909193300b8b8e39a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;syn&lt;/code&gt; crate parses Rust code from a string into a data structure that we can perform operations on. The &lt;code&gt;quote&lt;/code&gt; crate turns &lt;code&gt;syn&lt;/code&gt; data structures back into Rust code. These crates make it much simpler to parse any sort of Rust code we might want to handle: writing a full parser for Rust code is no simple task.</source>
          <target state="translated">&lt;code&gt;syn&lt;/code&gt; クレートは、我々が上で操作を実行できるようなデータ構造に文字列から錆コードを解析します。 &lt;code&gt;quote&lt;/code&gt; クレートターン &lt;code&gt;syn&lt;/code&gt; データ構造は錆コードに戻します。これらのクレートを使用すると、処理したいあらゆる種類のRustコードを解析することがはるかに簡単になります。Rustコードの完全なパーサーを作成するのは簡単な作業ではありません。</target>
        </trans-unit>
        <trans-unit id="4c2f6cfbefda1dc3521b2af3bf1923ea6ba12d89" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;take&lt;/code&gt; method is defined in the &lt;code&gt;Iterator&lt;/code&gt; trait and limits the iteration to the first two items at most. The &lt;code&gt;ThreadPool&lt;/code&gt; will go out of scope at the end of &lt;code&gt;main&lt;/code&gt;, and the &lt;code&gt;drop&lt;/code&gt; implementation will run.</source>
          <target state="translated">&lt;code&gt;take&lt;/code&gt; 方法は、で定義されている &lt;code&gt;Iterator&lt;/code&gt; 形質と多くとも最初の2つの項目を反復を制限します。 &lt;code&gt;ThreadPool&lt;/code&gt; のはの終わりでスコープの外に行く &lt;code&gt;main&lt;/code&gt; 、および &lt;code&gt;drop&lt;/code&gt; 実装が実行されます。</target>
        </trans-unit>
        <trans-unit id="f4261b148ae0a22c8791698e09a2d9939e795de1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;target_feature&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;target_feature&lt;/code&gt; の属性</target>
        </trans-unit>
        <trans-unit id="0bfa2ee4e02addd4c71ab19bd1f7c85cc21dadfe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;test&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;test&lt;/code&gt; の属性</target>
        </trans-unit>
        <trans-unit id="c6b28a9d1db605fca4af25fdaf7d2f63f3f4ff7d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;track_caller&lt;/code&gt; attribute may be applied to any function with &lt;a href=&quot;../items/external-blocks#abi&quot;&gt;&lt;code&gt;&quot;Rust&quot;&lt;/code&gt; ABI&lt;/a&gt; with the exception of the entry point &lt;code&gt;fn main&lt;/code&gt;. When applied to functions and methods in trait declarations, the attribute applies to all implementations. If the trait provides a default implementation with the attribute, then the attribute also applies to override implementations.</source>
          <target state="translated">&lt;code&gt;track_caller&lt;/code&gt; の属性を持つ任意の関数に適用することができる&lt;a href=&quot;../items/external-blocks#abi&quot;&gt; &lt;code&gt;&quot;Rust&quot;&lt;/code&gt; ABI&lt;/a&gt;エントリポイントを除いて &lt;code&gt;fn main&lt;/code&gt; 。トレイト宣言の関数とメソッドに適用される場合、属性はすべての実装に適用されます。トレイトが属性を持つデフォルトの実装を提供する場合、属性はオーバーライド実装にも適用されます。</target>
        </trans-unit>
        <trans-unit id="dbbce8f10ed8de46d53a88134091400a4cad8f24" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;transparent&lt;/code&gt; Representation</source>
          <target state="translated">&lt;code&gt;transparent&lt;/code&gt; 表現</target>
        </trans-unit>
        <trans-unit id="16cfac7d668a26094fafdea930dd55dadb7672de" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;transparent&lt;/code&gt; representation can only be used on &lt;code&gt;struct&lt;/code&gt;s that have a single non-zero sized field and any number of zero-sized fields, including &lt;a href=&quot;special-types-and-traits#phantomdatat&quot;&gt;&lt;code&gt;PhantomData&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;transparent&lt;/code&gt; 表現のみで使用することができる &lt;code&gt;struct&lt;/code&gt; 単一の非ゼロサイズフィールドとを含むゼロサイズフィールド、任意の数有するS &lt;a href=&quot;special-types-and-traits#phantomdatat&quot;&gt; &lt;code&gt;PhantomData&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="811b48cd1ea2c8f7773b17e401a6ef4a6664ee6e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;transparent&lt;/code&gt; representation can only be used on a &lt;a href=&quot;items/structs&quot;&gt;&lt;code&gt;struct&lt;/code&gt;&lt;/a&gt; or an &lt;a href=&quot;items/enumerations&quot;&gt;&lt;code&gt;enum&lt;/code&gt;&lt;/a&gt; with a single variant that has:</source>
          <target state="translated">&lt;code&gt;transparent&lt;/code&gt; 表現のみで使用することができる&lt;a href=&quot;items/structs&quot;&gt; &lt;code&gt;struct&lt;/code&gt; &lt;/a&gt;、または&lt;a href=&quot;items/enumerations&quot;&gt; &lt;code&gt;enum&lt;/code&gt; &lt;/a&gt;有する単一変異を有します。</target>
        </trans-unit>
        <trans-unit id="01d7d7afaf943b9e9b10757db03a01818240c2c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;try_recv&lt;/code&gt; method doesn&amp;rsquo;t block, but will instead return a &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; immediately: an &lt;code&gt;Ok&lt;/code&gt; value holding a message if one is available and an &lt;code&gt;Err&lt;/code&gt; value if there aren&amp;rsquo;t any messages this time. Using &lt;code&gt;try_recv&lt;/code&gt; is useful if this thread has other work to do while waiting for messages: we could write a loop that calls &lt;code&gt;try_recv&lt;/code&gt; every so often, handles a message if one is available, and otherwise does other work for a little while until checking again.</source>
          <target state="translated">&lt;code&gt;try_recv&lt;/code&gt; の方法はブロックしませんが、その代わりに戻ります &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; すぐに： &lt;code&gt;Ok&lt;/code&gt; 1が利用可能な場合は、メッセージを保持する値と &lt;code&gt;Err&lt;/code&gt; 値を任意のメッセージがこの時間がない場合。使用 &lt;code&gt;try_recv&lt;/code&gt; は、このスレッドがメッセージを待っている間に行うには他の仕事を持っている場合に便利です：私たちは、呼び出しがそのループを書くことができ &lt;code&gt;try_recv&lt;/code&gt; 1が利用可能な場合、すべてがそう頻繁に、メッセージを処理し、再びチェックまでしながら、それ以外の場合は少しのために他の作業を行います。</target>
        </trans-unit>
        <trans-unit id="1c06a34327e19720b6fdb343c408e7c55dd84e16" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type Target = T;&lt;/code&gt; syntax defines an associated type for the &lt;code&gt;Deref&lt;/code&gt; trait to use. Associated types are a slightly different way of declaring a generic parameter, but you don&amp;rsquo;t need to worry about them for now; we&amp;rsquo;ll cover them in more detail in Chapter 19.</source>
          <target state="translated">&lt;code&gt;type Target = T;&lt;/code&gt; 構文は、使用する &lt;code&gt;Deref&lt;/code&gt; トレイトの関連タイプを定義します。関連付けられた型は、ジェネリックパラメーターを宣言する方法が少し異なりますが、今のところそれらについて心配する必要はありません。これらについては、第19章で詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="ed8f6c9e0893fd91a5e6d611722172ed9ef6f6c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type_length_limit&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;type_length_limit&lt;/code&gt; の属性</target>
        </trans-unit>
        <trans-unit id="88b76f9ce33c0af8e240ed6b37ada9e83ea43da5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;typeof&lt;/code&gt; keyword is currently reserved but unimplemented.</source>
          <target state="translated">&lt;code&gt;typeof&lt;/code&gt; 演算のキーワードは、現在予約が、実装されていません。</target>
        </trans-unit>
        <trans-unit id="7495ddf8e7dd908218ee8fe0115f879a8fb5ec94" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;typeof&lt;/code&gt; keyword is currently reserved but unimplemented. Erroneous code example:</source>
          <target state="translated">&lt;code&gt;typeof&lt;/code&gt; 演算のキーワードは、現在予約が、実装されていません。誤ったコード例：</target>
        </trans-unit>
        <trans-unit id="dd3cfc211f63708e7ec9409ea2198c30928717cb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unsafe&lt;/code&gt; keyword has two uses: to declare the existence of contracts the compiler can't check (&lt;code&gt;unsafe fn&lt;/code&gt; and &lt;code&gt;unsafe trait&lt;/code&gt;), and to declare that a programmer has checked that these contracts have been upheld (&lt;code&gt;unsafe {}&lt;/code&gt; and &lt;code&gt;unsafe impl&lt;/code&gt;, but also &lt;code&gt;unsafe fn&lt;/code&gt; -- see below). They are not mutually exclusive, as can be seen in &lt;code&gt;unsafe fn&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;unsafe&lt;/code&gt; 2つの用途がありますキーワード：コンパイラは（チェックすることができない契約の存在を宣言するために &lt;code&gt;unsafe fn&lt;/code&gt; と &lt;code&gt;unsafe trait&lt;/code&gt; ）、とプログラマはこれらの契約が守られていることを確認したことを宣言するために（ &lt;code&gt;unsafe {}&lt;/code&gt; と &lt;code&gt;unsafe impl&lt;/code&gt; が、また、 &lt;code&gt;unsafe fn&lt;/code&gt; 以下を参照）。 &lt;code&gt;unsafe fn&lt;/code&gt; でないfnに見られるように、これらは相互に排他的ではありません。</target>
        </trans-unit>
        <trans-unit id="b3bcdab50b34b5e5716db8fd4a0ee45ad2abea8d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unsafe&lt;/code&gt; keyword is syntactically allowed to appear before the &lt;code&gt;extern&lt;/code&gt; keyword, but it is rejected at a semantic level. This allows macros to consume the syntax and make use of the &lt;code&gt;unsafe&lt;/code&gt; keyword, before removing it from the token stream.</source>
          <target state="translated">&lt;code&gt;unsafe&lt;/code&gt; キーワードは、構文的に前に表示されるように許可されている &lt;code&gt;extern&lt;/code&gt; キーワード、それは意味的な水準で棄却されます。これにより、マクロは、トークンストリームから削除する前に、構文を消費し、 &lt;code&gt;unsafe&lt;/code&gt; キーワードを利用できます。</target>
        </trans-unit>
        <trans-unit id="205e3b2923533eb22d4e09801e3f784e668f24fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unsafe&lt;/code&gt; keyword is syntactically allowed to appear before the &lt;code&gt;mod&lt;/code&gt; keyword, but it is rejected at a semantic level. This allows macros to consume the syntax and make use of the &lt;code&gt;unsafe&lt;/code&gt; keyword, before removing it from the token stream.</source>
          <target state="translated">&lt;code&gt;unsafe&lt;/code&gt; キーワードは、構文的に前に表示されるように許可されている &lt;code&gt;mod&lt;/code&gt; のキーワード、それは意味的な水準で棄却されます。これにより、マクロは、トークンストリームから削除する前に、構文を消費し、 &lt;code&gt;unsafe&lt;/code&gt; キーワードを利用できます。</target>
        </trans-unit>
        <trans-unit id="a346e1081bfa2911e1aa0fde6117ab4a081928a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unsafe&lt;/code&gt; qualifier indicates that the type's value is an &lt;a href=&quot;../unsafe-functions&quot;&gt;unsafe function&lt;/a&gt;, and the &lt;code&gt;extern&lt;/code&gt; qualifier indicates it is an &lt;a href=&quot;../items/functions#extern-function-qualifier&quot;&gt;extern function&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;unsafe&lt;/code&gt; 修飾子は、型の値があることを示し&lt;a href=&quot;../unsafe-functions&quot;&gt;、安全でない機能&lt;/a&gt;、および &lt;code&gt;extern&lt;/code&gt; 修飾子は、それがあることを示し&lt;a href=&quot;../items/functions#extern-function-qualifier&quot;&gt;EXTERN機能&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="994e471fd3da940319d1417edcfca60d6a3db828" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unsafe&lt;/code&gt; qualifier indicates that the type's value is an &lt;a href=&quot;../unsafe-functions&quot;&gt;unsafe function&lt;/a&gt;, and the &lt;code&gt;extern&lt;/code&gt; qualifier indicates it is an &lt;a href=&quot;../items/functions#extern-functions&quot;&gt;extern function&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;unsafe&lt;/code&gt; 修飾子は、型の値があることを示し&lt;a href=&quot;../unsafe-functions&quot;&gt;、安全でない機能&lt;/a&gt;、および &lt;code&gt;extern&lt;/code&gt; 修飾子は、それがあることを示し&lt;a href=&quot;../items/functions#extern-functions&quot;&gt;EXTERN機能&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="78ba9e0cc65cc7840eaadd16f98f7cca440cd4f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unwind&lt;/code&gt; attribute was malformed.</source>
          <target state="translated">&lt;code&gt;unwind&lt;/code&gt; 属性が不正な形式でした。</target>
        </trans-unit>
        <trans-unit id="a60fd78a94b551f1746c4a391dd52899994edd99" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;used&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;used&lt;/code&gt; 属性</target>
        </trans-unit>
        <trans-unit id="762cbbe7d454d7148fa1b85ecdd6dd222c5646ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;usize&lt;/code&gt; type is an unsigned integer type with the same number of bits as the platform's pointer type. It can represent every memory address in the process.</source>
          <target state="translated">&lt;code&gt;usize&lt;/code&gt; タイプは、プラットフォームのポインタ型と同じビット数を有する符号なし整数型です。プロセス内のすべてのメモリアドレスを表すことができます。</target>
        </trans-unit>
        <trans-unit id="ca7074c2679596c96e2d40f1a9e7060f1f83b71a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;value&lt;/code&gt; field is of type &lt;code&gt;Option&amp;lt;u32&amp;gt;&lt;/code&gt;. Before we execute the closure, &lt;code&gt;value&lt;/code&gt; will be &lt;code&gt;None&lt;/code&gt;. When code using a &lt;code&gt;Cacher&lt;/code&gt; asks for the &lt;em&gt;result&lt;/em&gt; of the closure, the &lt;code&gt;Cacher&lt;/code&gt; will execute the closure at that time and store the result within a &lt;code&gt;Some&lt;/code&gt; variant in the &lt;code&gt;value&lt;/code&gt; field. Then if the code asks for the result of the closure again, instead of executing the closure again, the &lt;code&gt;Cacher&lt;/code&gt; will return the result held in the &lt;code&gt;Some&lt;/code&gt; variant.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; フィールドは、型のある &lt;code&gt;Option&amp;lt;u32&amp;gt;&lt;/code&gt; 。クロージャーを実行する前の &lt;code&gt;value&lt;/code&gt; は &lt;code&gt;None&lt;/code&gt; になります。 &lt;code&gt;Cacher&lt;/code&gt; を使用するコードがクロージャの&lt;em&gt;結果&lt;/em&gt;を要求すると、 &lt;code&gt;Cacher&lt;/code&gt; はその時点でクロージャを実行し、結果を &lt;code&gt;value&lt;/code&gt; フィールドの &lt;code&gt;Some&lt;/code&gt; バリアント内に格納します。次に、コードがクロージャーの結果を再度要求した場合、クロージャーを再度実行する代わりに、 &lt;code&gt;Cacher&lt;/code&gt; は &lt;code&gt;Some&lt;/code&gt; バリアントに保持されている結果を返します。</target>
        </trans-unit>
        <trans-unit id="5defa2a7e24b93d29be444c6bce3655062b73aee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vtable&lt;/code&gt; customizes the behavior of a &lt;code&gt;Waker&lt;/code&gt; which gets created from a &lt;code&gt;RawWaker&lt;/code&gt;. For each operation on the &lt;code&gt;Waker&lt;/code&gt;, the associated function in the &lt;code&gt;vtable&lt;/code&gt; of the underlying &lt;code&gt;RawWaker&lt;/code&gt; will be called.</source>
          <target state="translated">&lt;code&gt;vtable&lt;/code&gt; のはの行動カスタマイズ &lt;code&gt;Waker&lt;/code&gt; から作成されます &lt;code&gt;RawWaker&lt;/code&gt; を。 &lt;code&gt;Waker&lt;/code&gt; の操作ごとに、基になる &lt;code&gt;RawWaker&lt;/code&gt; の &lt;code&gt;vtable&lt;/code&gt; 内の関連する関数が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="58deddf572f1c05716c0aff255109ee68c618f77" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;wasm_import_module&lt;/code&gt; key may be used to specify the &lt;a href=&quot;https://webassembly.github.io/spec/core/syntax/modules.html&quot;&gt;WebAssembly module&lt;/a&gt; name for the items within an &lt;code&gt;extern&lt;/code&gt; block when importing symbols from the host environment. The default module name is &lt;code&gt;env&lt;/code&gt; if &lt;code&gt;wasm_import_module&lt;/code&gt; is not specified.</source>
          <target state="translated">&lt;code&gt;wasm_import_module&lt;/code&gt; のキーを指定するために使用することができる&lt;a href=&quot;https://webassembly.github.io/spec/core/syntax/modules.html&quot;&gt;WebAssemblyモジュール&lt;/a&gt;内のアイテムの名前を &lt;code&gt;extern&lt;/code&gt; ホスト環境からシンボルをインポートするときにブロック。 &lt;code&gt;wasm_import_module&lt;/code&gt; が指定されていない場合、デフォルトのモジュール名は &lt;code&gt;env&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="03b2e1ae71fdcbd9ffac8eca408ab8d4e8472f94" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;width&lt;/code&gt;, &lt;code&gt;height&lt;/code&gt;, and &lt;code&gt;label&lt;/code&gt; fields on &lt;code&gt;Button&lt;/code&gt; will differ from the fields on other components, such as a &lt;code&gt;TextField&lt;/code&gt; type, that might have those fields plus a &lt;code&gt;placeholder&lt;/code&gt; field instead. Each of the types we want to draw on the screen will implement the &lt;code&gt;Draw&lt;/code&gt; trait but will use different code in the &lt;code&gt;draw&lt;/code&gt; method to define how to draw that particular type, as &lt;code&gt;Button&lt;/code&gt; has here (without the actual GUI code, which is beyond the scope of this chapter). The &lt;code&gt;Button&lt;/code&gt; type, for instance, might have an additional &lt;code&gt;impl&lt;/code&gt; block containing methods related to what happens when a user clicks the button. These kinds of methods won&amp;rsquo;t apply to types like &lt;code&gt;TextField&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Button&lt;/code&gt; の &lt;code&gt;width&lt;/code&gt; 、 &lt;code&gt;height&lt;/code&gt; 、および &lt;code&gt;label&lt;/code&gt; フィールドは、 &lt;code&gt;TextField&lt;/code&gt; タイプなどの他のコンポーネントのフィールドとは異なり、これらのフィールドと &lt;code&gt;placeholder&lt;/code&gt; フィールドが代わりにある場合があります。画面に描画する各タイプは、 &lt;code&gt;Draw&lt;/code&gt; トレイトを実装しますが、 &lt;code&gt;draw&lt;/code&gt; メソッドで異なるコードを使用して、特定のタイプを描画する方法を定義します。これは、 &lt;code&gt;Button&lt;/code&gt; のように（実際のGUIコードなしで、スコープを超えています）この章の）。 &lt;code&gt;Button&lt;/code&gt; 種類は、例えば、追加の可能性があります &lt;code&gt;impl&lt;/code&gt; ユーザーがボタンをクリックしたときに何が起こるかに関するメソッドを含むブロック。これらの種類のメソッドは、 &lt;code&gt;TextField&lt;/code&gt; のような型には適用されません。</target>
        </trans-unit>
        <trans-unit id="49fef96b0756f10c5fd5c7fedcccb9ee963b501d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;windows_subsystem&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;windows_subsystem&lt;/code&gt; の属性</target>
        </trans-unit>
        <trans-unit id="fe674a5495eedc22d7ae598194abec96fa238a33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;write&lt;/code&gt; function takes an output stream, and an &lt;code&gt;Arguments&lt;/code&gt; struct that can be precompiled with the &lt;code&gt;format_args!&lt;/code&gt; macro.</source>
          <target state="translated">&lt;code&gt;write&lt;/code&gt; 機能は、出力ストリームをとり、 &lt;code&gt;Arguments&lt;/code&gt; をプリコンパイルすることができ、構造体 &lt;code&gt;format_args!&lt;/code&gt; 大きい。</target>
        </trans-unit>
        <trans-unit id="5644d7245fdec36266e15ee66f56202b01bc587d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;x&lt;/code&gt; part is a pattern! As we did with &lt;code&gt;let&lt;/code&gt;, we could match a tuple in a function&amp;rsquo;s arguments to the pattern. Listing 18-7 splits the values in a tuple as we pass it to a function.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 部分がパターンです！我々が行ったように &lt;code&gt;let&lt;/code&gt; 、我々はパターンに関数の引数にタプルを一致させることができます。リスト18-7は、関数に渡すときにタプルの値を分割します。</target>
        </trans-unit>
        <trans-unit id="90c7cb6860c6df5927660a73f110e2f9166750a3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;x&lt;/code&gt; value is moved into the closure when the closure is defined, because we added the &lt;code&gt;move&lt;/code&gt; keyword. The closure then has ownership of &lt;code&gt;x&lt;/code&gt;, and &lt;code&gt;main&lt;/code&gt; isn&amp;rsquo;t allowed to use &lt;code&gt;x&lt;/code&gt; anymore in the &lt;code&gt;println!&lt;/code&gt; statement. Removing &lt;code&gt;println!&lt;/code&gt; will fix this example.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; クロージャが定義されている場合、我々は追加ため値は、閉鎖に移動する &lt;code&gt;move&lt;/code&gt; キーワード。閉鎖は、その後の所有している &lt;code&gt;x&lt;/code&gt; 、そして &lt;code&gt;main&lt;/code&gt; 使用を許可されていません &lt;code&gt;x&lt;/code&gt; はでもう &lt;code&gt;println!&lt;/code&gt; ステートメント。 &lt;code&gt;println!&lt;/code&gt; 削除しています！この例を修正します。</target>
        </trans-unit>
        <trans-unit id="693d3b957625a8e3df8f4384a832c7be5cfa15d0" translate="yes" xml:space="preserve">
          <source>The &lt;em id=&quot;the-tests-directory&quot;&gt;tests&lt;/em&gt; Directory</source>
          <target state="translated">&lt;em id=&quot;the-tests-directory&quot;&gt;テストの&lt;/em&gt;ディレクトリ</target>
        </trans-unit>
        <trans-unit id="2382217293f35827ef839ef57a6e0636f3faa56f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;automatically_derived&lt;/code&gt; attribute&lt;/em&gt; is automatically added to &lt;a href=&quot;../items/implementations&quot;&gt;implementations&lt;/a&gt; created by the &lt;code&gt;derive&lt;/code&gt; attribute for built-in traits. It has no direct effect, but it may be used by tools and diagnostic lints to detect these automatically generated implementations.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;automatically_derived&lt;/code&gt; 属性が&lt;/em&gt;自動的に追加された&lt;a href=&quot;../items/implementations&quot;&gt;実装&lt;/a&gt;によって作成された &lt;code&gt;derive&lt;/code&gt; ビルトイン形質の属性。直接的な影響はありませんが、ツールや診断リントがこれらの自動生成された実装を検出するために使用する場合があります。</target>
        </trans-unit>
        <trans-unit id="7d372f8b0a676dc2ae354b920b56c31e1ed0230f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;cold&lt;/code&gt; &lt;a href=&quot;../attributes&quot;&gt;attribute&lt;/a&gt;&lt;/em&gt; suggests that the attributed function is unlikely to be called.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;cold&lt;/code&gt; &lt;a href=&quot;../attributes&quot;&gt;属性は、&lt;/a&gt;&lt;/em&gt;帰属関数が呼び出されることはほとんどありませんことを示唆しています。</target>
        </trans-unit>
        <trans-unit id="c8dd94fd6bb692bd54e04ee95744533de367bad8" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;crate_name&lt;/code&gt; &lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt;&lt;/em&gt; may be applied at the crate level to specify the name of the crate with the &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;crate_name&lt;/code&gt; の &lt;a href=&quot;attributes&quot;&gt;属性は&lt;/a&gt;&lt;/em&gt;とクレートの名前を指定するには、クレートレベルで適用することができる&lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStrの&lt;/em&gt;&lt;/a&gt;構文。</target>
        </trans-unit>
        <trans-unit id="2db8e6439808a243c5fa24e648c2e0fab8ef4d83" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;deprecated&lt;/code&gt; attribute&lt;/em&gt; marks an item as deprecated. &lt;code&gt;rustc&lt;/code&gt; will issue warnings on usage of &lt;code&gt;#[deprecated]&lt;/code&gt; items. &lt;code&gt;rustdoc&lt;/code&gt; will show item deprecation, including the &lt;code&gt;since&lt;/code&gt; version and &lt;code&gt;note&lt;/code&gt;, if available.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;deprecated&lt;/code&gt; 属性&lt;/em&gt;マーク非推奨としてアイテム。 &lt;code&gt;rustc&lt;/code&gt; は &lt;code&gt;#[deprecated]&lt;/code&gt; アイテムの使用に関する警告を発行します。 &lt;code&gt;rustdoc&lt;/code&gt; は、利用可能であれば、それ &lt;code&gt;since&lt;/code&gt; バージョンと &lt;code&gt;note&lt;/code&gt; を含む、アイテムの非推奨を表示します。</target>
        </trans-unit>
        <trans-unit id="fa15bab6a083f19d9ae9cd7eaa338e697eaf4832" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;derive&lt;/code&gt; attribute&lt;/em&gt; allows new &lt;a href=&quot;../items&quot;&gt;items&lt;/a&gt; to be automatically generated for data structures. It uses the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListPaths&lt;/em&gt;&lt;/a&gt; syntax to specify a list of traits to implement or paths to &lt;a href=&quot;../procedural-macros#derive-macros&quot;&gt;derive macros&lt;/a&gt; to process.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;derive&lt;/code&gt; 属性は、&lt;/em&gt;新しいことができます&lt;a href=&quot;../items&quot;&gt;アイテムが&lt;/a&gt;自動的にデータ構造のために生成されます。&lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListPaths&lt;/em&gt;&lt;/a&gt;構文を使用して、実装する特性のリストまたは処理&lt;a href=&quot;../procedural-macros#derive-macros&quot;&gt;するマクロ&lt;/a&gt;を派生させるパスを指定します。</target>
        </trans-unit>
        <trans-unit id="a97c3213ab817ab892d8f6e5c3157736e74b3b32" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;export_name&lt;/code&gt; attribute&lt;/em&gt; specifies the name of the symbol that will be exported on a &lt;a href=&quot;items/functions&quot;&gt;function&lt;/a&gt; or &lt;a href=&quot;items/static-items&quot;&gt;static&lt;/a&gt;. It uses the &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to specify the symbol name.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;export_name&lt;/code&gt; の属性は、&lt;/em&gt;上でエクスポートされるシンボルの名前を指定する&lt;a href=&quot;items/functions&quot;&gt;機能&lt;/a&gt;または&lt;a href=&quot;items/static-items&quot;&gt;静的を&lt;/a&gt;。&lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt;構文を使用して、シンボル名を指定します。</target>
        </trans-unit>
        <trans-unit id="9d1fbcf19af41adeefc0b92335ae4b007c4dadfa" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;global_allocator&lt;/code&gt; attribute&lt;/em&gt; is used on a &lt;a href=&quot;items/static-items&quot;&gt;static item&lt;/a&gt; implementing the &lt;a href=&quot;https://doc.rust-lang.org/alloc/alloc/trait.GlobalAlloc.html&quot;&gt;&lt;code&gt;GlobalAlloc&lt;/code&gt;&lt;/a&gt; trait to set the global allocator.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;global_allocator&lt;/code&gt; の属性は&lt;/em&gt;上で使用される&lt;a href=&quot;items/static-items&quot;&gt;静的項目&lt;/a&gt;実装&lt;a href=&quot;https://doc.rust-lang.org/alloc/alloc/trait.GlobalAlloc.html&quot;&gt; &lt;code&gt;GlobalAlloc&lt;/code&gt; &lt;/a&gt;グローバルアロケータを設定する形質を。</target>
        </trans-unit>
        <trans-unit id="eb4af8649334dd85e9ba7979a0a444e3961c900a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;inline&lt;/code&gt; &lt;a href=&quot;../attributes&quot;&gt;attribute&lt;/a&gt;&lt;/em&gt; suggests that a copy of the attributed function should be placed in the caller, rather than generating code to call the function where it is defined.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;inline&lt;/code&gt; &lt;a href=&quot;../attributes&quot;&gt;属性は、&lt;/a&gt;&lt;/em&gt;帰属関数のコピーではなく、それが定義されている関数を呼び出すコードを生成するよりも、呼び出し側に配置されるべきであることを示唆しています。</target>
        </trans-unit>
        <trans-unit id="1d9a7b1456b98dca1d8fed53edde3318db90e4c5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;link&lt;/code&gt; attribute&lt;/em&gt; specifies the name of a native library that the compiler should link with for the items within an &lt;code&gt;extern&lt;/code&gt; block. It uses the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to specify its inputs. The &lt;code&gt;name&lt;/code&gt; key is the name of the native library to link. The &lt;code&gt;kind&lt;/code&gt; key is an optional value which specifies the kind of library with the following possible values:</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;link&lt;/code&gt; 属性は、&lt;/em&gt;コンパイラは、内のアイテムのためにリンクする必要があることネイティブライブラリの名前を指定する &lt;code&gt;extern&lt;/code&gt; ブロックを。&lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListNameValueStr&lt;/em&gt;&lt;/a&gt;構文を使用して、入力を指定します。 &lt;code&gt;name&lt;/code&gt; キーはリンクにネイティブライブラリの名前です。 &lt;code&gt;kind&lt;/code&gt; のキーは、以下の値を持つライブラリの種類を指定するオプション値です。</target>
        </trans-unit>
        <trans-unit id="6603167a8a5aa9df2deb989c68e33b760144ac17" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;link_section&lt;/code&gt; attribute&lt;/em&gt; specifies the section of the object file that a &lt;a href=&quot;items/functions&quot;&gt;function&lt;/a&gt; or &lt;a href=&quot;items/static-items&quot;&gt;static&lt;/a&gt;'s content will be placed into. It uses the &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to specify the section name.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;link_section&lt;/code&gt; の属性は、&lt;/em&gt;そのオブジェクトファイルのセクションを指定する&lt;a href=&quot;items/functions&quot;&gt;機能&lt;/a&gt;または&lt;a href=&quot;items/static-items&quot;&gt;静的&lt;/a&gt;のコンテンツがに置かれますが。&lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt;構文を使用してセクション名を指定します。</target>
        </trans-unit>
        <trans-unit id="806935dfacd2a07be8b57f073dcdf39509c2b1f7" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;macro_use&lt;/code&gt; attribute&lt;/em&gt; has two purposes. First, it can be used to make a module's macro scope not end when the module is closed, by applying it to a module:</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;macro_use&lt;/code&gt; の属性には&lt;/em&gt; 2つの目的があります。まず、モジュールに適用することにより、モジュールが閉じられたときにモジュールのマクロスコープが終了しないようにするために使用できます。</target>
        </trans-unit>
        <trans-unit id="05f0042fe91a37001bd65ea0d74fd9143e55659c" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;must_use&lt;/code&gt; attribute&lt;/em&gt; is used to issue a diagnostic warning when a value is not &quot;used&quot;. It can be applied to user-defined composite types (&lt;a href=&quot;../items/structs&quot;&gt;&lt;code&gt;struct&lt;/code&gt;s&lt;/a&gt;, &lt;a href=&quot;../items/enumerations&quot;&gt;&lt;code&gt;enum&lt;/code&gt;s&lt;/a&gt;, and &lt;a href=&quot;../items/unions&quot;&gt;&lt;code&gt;union&lt;/code&gt;s&lt;/a&gt;), &lt;a href=&quot;../items/functions&quot;&gt;functions&lt;/a&gt;, and &lt;a href=&quot;../items/traits&quot;&gt;traits&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;must_use&lt;/code&gt; の属性は、&lt;/em&gt;値が「使用」されていない場合、診断警告を発行するために使用されます。これは、（ユーザ定義の複合型に適用することができる&lt;a href=&quot;../items/structs&quot;&gt; &lt;code&gt;struct&lt;/code&gt; の&lt;/a&gt;、&lt;a href=&quot;../items/enumerations&quot;&gt; &lt;code&gt;enum&lt;/code&gt; S&lt;/a&gt;、及び&lt;a href=&quot;../items/unions&quot;&gt; &lt;code&gt;union&lt;/code&gt; S&lt;/a&gt;）、&lt;a href=&quot;../items/functions&quot;&gt;関数は&lt;/a&gt;、および&lt;a href=&quot;../items/traits&quot;&gt;形質&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="df0d5b935c63e0d5d09ad34649237d79db006af9" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;no_builtins&lt;/code&gt; &lt;a href=&quot;../attributes&quot;&gt;attribute&lt;/a&gt;&lt;/em&gt; may be applied at the crate level to disable optimizing certain code patterns to invocations of library functions that are assumed to exist.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;no_builtins&lt;/code&gt; の &lt;a href=&quot;../attributes&quot;&gt;属性が&lt;/a&gt;&lt;/em&gt;存在すると仮定されているライブラリ関数の呼び出しに無効に最適化する特定のコードパターンにクレートレベルで適用することができます。</target>
        </trans-unit>
        <trans-unit id="1c5fb5c17e1ae5e93c491f3ff3864f7cf3700a82" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;no_link&lt;/code&gt; attribute&lt;/em&gt; may be specified on an &lt;code&gt;extern crate&lt;/code&gt; item to prevent linking the crate into the output. This is commonly used to load a crate to access only its macros.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;no_link&lt;/code&gt; 属性&lt;/em&gt;で指定することができる &lt;code&gt;extern crate&lt;/code&gt; 出力にクレートを連結防止するアイテム。これは通常、クレートをロードしてそのマクロのみにアクセスするために使用されます。</target>
        </trans-unit>
        <trans-unit id="a894d89850015842793e60fc8f351c2309ee5ef4" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;no_main&lt;/code&gt; &lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt;&lt;/em&gt; may be applied at the crate level to disable emitting the &lt;code&gt;main&lt;/code&gt; symbol for an executable binary. This is useful when some other object being linked to defines &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;no_main&lt;/code&gt; &lt;a href=&quot;attributes&quot;&gt;属性を&lt;/a&gt;&lt;/em&gt;クレートレベルで適用して、実行可能バイナリの &lt;code&gt;main&lt;/code&gt; シンボルの&lt;em&gt;発行&lt;/em&gt;を無効にすることができます。これは、リンクされている他のオブジェクトが &lt;code&gt;main&lt;/code&gt; を定義している場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="f3bcfb88f5c979d523b3f1a38c5f5b56a611b895" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;no_mangle&lt;/code&gt; attribute&lt;/em&gt; may be used on any &lt;a href=&quot;items&quot;&gt;item&lt;/a&gt; to disable standard symbol name mangling. The symbol for the item will be the identifier of the item's name.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;no_mangle&lt;/code&gt; 属性は&lt;/em&gt;いずれにも使用することができる&lt;a href=&quot;items&quot;&gt;項目&lt;/a&gt;を無効標準のシンボルの名前の符号化に。アイテムのシンボルは、アイテムの名前の識別子になります。</target>
        </trans-unit>
        <trans-unit id="0bb656555b55ed7c2f8a3087c34efb6ed0ed4cf4" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;non_exhaustive&lt;/code&gt; attribute&lt;/em&gt; indicates that a type or variant may have more fields or variants added in the future. It can be applied to &lt;a href=&quot;../items/structs&quot;&gt;&lt;code&gt;struct&lt;/code&gt;s&lt;/a&gt;, &lt;a href=&quot;../items/enumerations&quot;&gt;&lt;code&gt;enum&lt;/code&gt;s&lt;/a&gt;, and &lt;code&gt;enum&lt;/code&gt; variants.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;non_exhaustive&lt;/code&gt; 属性は&lt;/em&gt;タイプまたは変異体は、複数のフィールドまたは将来的に追加の変種を有することができることを示しています。これは、&lt;a href=&quot;../items/structs&quot;&gt; &lt;code&gt;struct&lt;/code&gt; s&lt;/a&gt;、&lt;a href=&quot;../items/enumerations&quot;&gt; &lt;code&gt;enum&lt;/code&gt; s&lt;/a&gt;、および &lt;code&gt;enum&lt;/code&gt; バリアントに適用できます。</target>
        </trans-unit>
        <trans-unit id="53a982d72d2f0894ccb0ac1653ff149a9b51224c" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;panic_handler&lt;/code&gt; attribute&lt;/em&gt; can only be applied to a function with signature &lt;code&gt;fn(&amp;amp;PanicInfo) -&amp;gt; !&lt;/code&gt;. The function marked with this &lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; defines the behavior of panics. The &lt;a href=&quot;https://doc.rust-lang.org/core/panic/struct.PanicInfo.html&quot;&gt;&lt;code&gt;PanicInfo&lt;/code&gt;&lt;/a&gt; struct contains information about the location of the panic. There must be a single &lt;code&gt;panic_handler&lt;/code&gt; function in the dependency graph of a binary, dylib or cdylib crate.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;panic_handler&lt;/code&gt; の属性が&lt;/em&gt;唯一の署名で関数に適用することができ &lt;code&gt;fn(&amp;amp;PanicInfo) -&amp;gt; !&lt;/code&gt; 。この&lt;a href=&quot;attributes&quot;&gt;属性で&lt;/a&gt;マークされた関数は、パニックの動作を定義します。&lt;a href=&quot;https://doc.rust-lang.org/core/panic/struct.PanicInfo.html&quot;&gt; &lt;code&gt;PanicInfo&lt;/code&gt; の&lt;/a&gt;構造体は、パニックの場所に関する情報が含まれています。バイナリ、dylib、またはcdylibクレートの依存関係グラフには、単一の &lt;code&gt;panic_handler&lt;/code&gt; 関数が必要です。</target>
        </trans-unit>
        <trans-unit id="12cdf01a779d8c77135d5a609c4b4e6849f40d6f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;recursion_limit&lt;/code&gt; attribute&lt;/em&gt; may be applied at the &lt;a href=&quot;../crates-and-source-files&quot;&gt;crate&lt;/a&gt; level to set the maximum depth for potentially infinitely-recursive compile-time operations like macro expansion or auto-dereference. It uses the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to specify the recursion depth.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;recursion_limit&lt;/code&gt; の属性&lt;/em&gt;に適用することができる&lt;a href=&quot;../crates-and-source-files&quot;&gt;クレート&lt;/a&gt;マクロ展開または自動逆参照様潜在的に無限に再帰コンパイル時の動作のための最大深さを設定するレベル。&lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt;構文を使用して、再帰の深さを指定します。</target>
        </trans-unit>
        <trans-unit id="a7c71f7f4ce5a08ecec5e3cb423add9b9986d9b2" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;target_feature&lt;/code&gt; &lt;a href=&quot;../attributes&quot;&gt;attribute&lt;/a&gt;&lt;/em&gt; may be applied to an &lt;a href=&quot;../unsafe-functions&quot;&gt;unsafe function&lt;/a&gt; to enable code generation of that function for specific platform architecture features. It uses the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListNameValueStr&lt;/em&gt;&lt;/a&gt; syntax with a single key of &lt;code&gt;enable&lt;/code&gt; whose value is a string of comma-separated feature names to enable.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;target_feature&lt;/code&gt; の &lt;a href=&quot;../attributes&quot;&gt;属性は、&lt;/a&gt;&lt;/em&gt;に適用することができる&lt;a href=&quot;../unsafe-functions&quot;&gt;安全でない機能&lt;/a&gt;特定のプラットフォームアーキテクチャの機能のために、その関数のコード生成を有効にします。&lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListNameValueStr&lt;/em&gt;&lt;/a&gt;構文を使用して、 &lt;code&gt;enable&lt;/code&gt; する単一のキーを有効にします。そのキーの値は、有効にするコンマ区切りの機能名の文字列です。</target>
        </trans-unit>
        <trans-unit id="3aa1c2ce8a0a269a928c5414e9b6749a40da4909" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;test&lt;/code&gt; attribute&lt;/em&gt; marks a function to be executed as a test. These functions are only compiled when in test mode. Test functions must be free, monomorphic functions that take no arguments, and the return type must be one of the following:</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;test&lt;/code&gt; 属性&lt;/em&gt;マークテストとして実行する機能。これらの関数は、テストモードでのみコンパイルされます。テスト関数は、引数を取らない無料の単相関数でなければならず、戻り値の型は次のいずれかでなければなりません。</target>
        </trans-unit>
        <trans-unit id="8e32e2a7306abe757340b9bbe77da987dbdce7fd" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;type_length_limit&lt;/code&gt; attribute&lt;/em&gt; limits the maximum number of type substitutions made when constructing a concrete type during monomorphization. It is applied at the &lt;a href=&quot;../crates-and-source-files&quot;&gt;crate&lt;/a&gt; level, and uses the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to set the limit based on the number of type substitutions.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;type_length_limit&lt;/code&gt; の属性は&lt;/em&gt; monomorphization中コンクリートタイプを構築するときに行われるタイプの置換の最大数を制限します。これは&lt;a href=&quot;../crates-and-source-files&quot;&gt;クレート&lt;/a&gt;レベルで適用され、&lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt;構文を使用して、タイプ置換の数に基づいて制限を設定します。</target>
        </trans-unit>
        <trans-unit id="6e74f839ef9f1efad1a8f9c7c9bbeff2f9cc5cae" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;used&lt;/code&gt; attribute&lt;/em&gt; can only be applied to &lt;a href=&quot;items/static-items&quot;&gt;&lt;code&gt;static&lt;/code&gt; items&lt;/a&gt;. This &lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; forces the compiler to keep the variable in the output object file (.o, .rlib, etc. excluding final binaries) even if the variable is not used, or referenced, by any other item in the crate. However, the linker is still free to remove such an item.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;used&lt;/code&gt; 属性が&lt;/em&gt;唯一に適用することができ&lt;a href=&quot;items/static-items&quot;&gt; &lt;code&gt;static&lt;/code&gt; アイテム&lt;/a&gt;。この&lt;a href=&quot;attributes&quot;&gt;属性&lt;/a&gt;は、変数がクレート内の他のアイテムによって使用または参照されていない場合でも、コンパイラーに出力オブジェクトファイル（最終バイナリを除く.o、.rlibなど）に変数を保持するように強制します。ただし、リンカはそのようなアイテムを自由に削除できます。</target>
        </trans-unit>
        <trans-unit id="f9f3929d821839852e44df6684413a39c02b618f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;used&lt;/code&gt; attribute&lt;/em&gt; can only be applied to &lt;a href=&quot;items/static-items&quot;&gt;&lt;code&gt;static&lt;/code&gt; items&lt;/a&gt;. This &lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; forces the compiler to keep the variable in the output object file (.o, .rlib, etc.) even if the variable is not used, or referenced, by any other item in the crate.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;used&lt;/code&gt; 属性が&lt;/em&gt;唯一に適用することができ&lt;a href=&quot;items/static-items&quot;&gt; &lt;code&gt;static&lt;/code&gt; アイテム&lt;/a&gt;。この&lt;a href=&quot;attributes&quot;&gt;属性&lt;/a&gt;は、変数がクレート内の他のアイテムによって使用または参照されていない場合でも、コンパイラーに変数を出力オブジェクトファイル（.o、.rlibなど）に保持することを強制します。</target>
        </trans-unit>
        <trans-unit id="cabd9dd1fe1f065b8657354c25edb014ad53f468" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;windows_subsystem&lt;/code&gt; attribute&lt;/em&gt; may be applied at the crate level to set the &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/fcc1zstk.aspx&quot;&gt;subsystem&lt;/a&gt; when linking on a Windows target. It uses the &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to specify the subsystem with a value of either &lt;code&gt;console&lt;/code&gt; or &lt;code&gt;windows&lt;/code&gt;. This attribute is ignored on non-Windows targets, and for non-&lt;code&gt;bin&lt;/code&gt;&lt;a href=&quot;linkage&quot;&gt;crate types&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;windows_subsystem&lt;/code&gt; の属性が&lt;/em&gt;設定するクレートレベルで適用することができる&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/fcc1zstk.aspx&quot;&gt;サブシステムを&lt;/a&gt;、Windowsのターゲットにリンクするとき。&lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt;構文を使用して、 &lt;code&gt;console&lt;/code&gt; または &lt;code&gt;windows&lt;/code&gt; のいずれかの値でサブシステムを指定します。この属性は、Windows以外のターゲット、および &lt;code&gt;bin&lt;/code&gt; &lt;a href=&quot;linkage&quot;&gt;箱タイプで&lt;/a&gt;は無視されます。</target>
        </trans-unit>
        <trans-unit id="637d9dddc1ad4617a0c58ddffc3922ae87e9baab" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;alignment&lt;/em&gt; of a value specifies what addresses are valid to store the value at. A value of alignment &lt;code&gt;n&lt;/code&gt; must only be stored at an address that is a multiple of n. For example, a value with an alignment of 2 must be stored at an even address, while a value with an alignment of 1 can be stored at any address. Alignment is measured in bytes, and must be at least 1, and always a power of 2. The alignment of a value can be checked with the &lt;a href=&quot;../std/mem/fn.align_of_val&quot;&gt;&lt;code&gt;align_of_val&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">値の&lt;em&gt;配置&lt;/em&gt;は、値を格納するために有効なアドレスを指定します。アライメント &lt;code&gt;n&lt;/code&gt; の値は、nの倍数であるアドレスにのみ格納する必要があります。たとえば、アラインメントが2の値は偶数アドレスに格納する必要がありますが、アラインメントが1の値は任意のアドレスに格納できます。アラインメントはバイト単位で測定され、少なくとも1、常に2の累乗でなければなりません。値のアラインメントは、&lt;a href=&quot;../std/mem/fn.align_of_val&quot;&gt; &lt;code&gt;align_of_val&lt;/code&gt; &lt;/a&gt;関数で確認できます。</target>
        </trans-unit>
        <trans-unit id="caa4287ee2eae29f4b7097731528e2f984499328" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;at&lt;/em&gt; operator (&lt;code&gt;@&lt;/code&gt;) lets us create a variable that holds a value at the same time we&amp;rsquo;re testing that value to see whether it matches a pattern. Listing 18-29 shows an example where we want to test that a &lt;code&gt;Message::Hello&lt;/code&gt;&lt;code&gt;id&lt;/code&gt; field is within the range &lt;code&gt;3...7&lt;/code&gt;. But we also want to bind the value to the variable &lt;code&gt;id_variable&lt;/code&gt; so we can use it in the code associated with the arm. We could name this variable &lt;code&gt;id&lt;/code&gt;, the same as the field, but for this example we&amp;rsquo;ll use a different name.</source>
          <target state="translated">&lt;em&gt;で、&lt;/em&gt;オペレータは、（ &lt;code&gt;@&lt;/code&gt; ）私たちは、それがパターンに一致するかどうかを確認するために、その値をテストしていると同時に、値を保持する変数を作成することができます。リスト18-29は、 &lt;code&gt;Message::Hello&lt;/code&gt; &lt;code&gt;id&lt;/code&gt; フィールドが &lt;code&gt;3...7&lt;/code&gt; 範囲内にあることをテストしたい例を示しています。しかし、値を変数 &lt;code&gt;id_variable&lt;/code&gt; にバインドして、armに関連付けられたコードで使用できるようにする必要もあります。私たちは、この変数名可能性が &lt;code&gt;id&lt;/code&gt; 、フィールドと同じですが、この例のために、私たちは別の名前を使用します。</target>
        </trans-unit>
        <trans-unit id="6fe3095ea3510353b505863afd4ade90995e4e2e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;at&lt;/em&gt; operator (&lt;code&gt;@&lt;/code&gt;) lets us create a variable that holds a value at the same time we&amp;rsquo;re testing that value to see whether it matches a pattern. Listing 18-29 shows an example where we want to test that a &lt;code&gt;Message::Hello&lt;/code&gt;&lt;code&gt;id&lt;/code&gt; field is within the range &lt;code&gt;3..=7&lt;/code&gt;. But we also want to bind the value to the variable &lt;code&gt;id_variable&lt;/code&gt; so we can use it in the code associated with the arm. We could name this variable &lt;code&gt;id&lt;/code&gt;, the same as the field, but for this example we&amp;rsquo;ll use a different name.</source>
          <target state="translated">&lt;em&gt;で、&lt;/em&gt;オペレータは、（ &lt;code&gt;@&lt;/code&gt; ）私たちは、それがパターンに一致するかどうかを確認するために、その値をテストしていると同時に、値を保持する変数を作成することができます。リスト18-29は、 &lt;code&gt;Message::Hello&lt;/code&gt; &lt;code&gt;id&lt;/code&gt; フィールドが &lt;code&gt;3..=7&lt;/code&gt; 範囲内にあることをテストする例を示しています。ただし、値を変数 &lt;code&gt;id_variable&lt;/code&gt; にバインドして、armに関連付けられたコードで使用できるようにする必要もあります。この変数 &lt;code&gt;id&lt;/code&gt; には、フィールドと同じ名前を付けることができますが、この例では別の名前を使用します。</target>
        </trans-unit>
        <trans-unit id="491e011fde2c63e7287e5968a958f99a0e0608ea" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;backslash escape&lt;/em&gt; is the character &lt;code&gt;U+005C&lt;/code&gt; (&lt;code&gt;\&lt;/code&gt;) which must be escaped in order to denote its ASCII encoding &lt;code&gt;0x5C&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;バックスラッシュエスケープは、&lt;/em&gt;文字である &lt;code&gt;U+005C&lt;/code&gt; （ &lt;code&gt;\&lt;/code&gt; そのASCIIエンコード示すためにエスケープする必要があります） &lt;code&gt;0x5C&lt;/code&gt; をします。</target>
        </trans-unit>
        <trans-unit id="e78bebf05e1ce9e264a960c4a634448ed6a163c1" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;backslash escape&lt;/em&gt; is the character &lt;code&gt;U+005C&lt;/code&gt; (&lt;code&gt;\&lt;/code&gt;) which must be escaped in order to denote itself.</source>
          <target state="translated">&lt;em&gt;バックスラッシュエスケープは、&lt;/em&gt;文字である &lt;code&gt;U+005C&lt;/code&gt; （ &lt;code&gt;\&lt;/code&gt; そのものを表すためにエスケープする必要があります）。</target>
        </trans-unit>
        <trans-unit id="863e56925d2ff8675a4dd9c4a460d825a809b69e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;heap&lt;/em&gt; is a general term that describes boxes. The lifetime of an allocation in the heap depends on the lifetime of the box values pointing to it. Since box values may themselves be passed in and out of frames, or stored in the heap, heap allocations may outlive the frame they are allocated within. An allocation in the heap is guaranteed to reside at a single location in the heap for the whole lifetime of the allocation - it will never be relocated as a result of moving a box value.</source>
          <target state="translated">&lt;em&gt;ヒープは&lt;/em&gt;ボックスについて説明し、一般的な用語です。ヒープ内の割り当ての有効期間は、それを指すボックス値の有効期間に依存します。ボックスの値自体がフレームの内外に渡されるか、ヒープに格納されるため、ヒープの割り当ては、それらが割り当てられたフレームよりも長く存続する場合があります。ヒープ内の割り当ては、割り当ての存続期間全体にわたってヒープ内の1つの場所に存在することが保証されています。ボックスの値を移動した結果として、再配置されることはありません。</target>
        </trans-unit>
        <trans-unit id="21ffe4f08baa3ee5d8fcae0ac2b2640039bc170b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;items&lt;/em&gt; of a program are those functions, modules and types that have their value calculated at compile-time and stored uniquely in the memory image of the rust process. Items are neither dynamically allocated nor freed.</source>
          <target state="translated">プログラムの&lt;em&gt;項目&lt;/em&gt;は、コンパイル時に計算され、rustプロセスのメモリイメージに一意に格納される関数、モジュール、およびタイプです。アイテムは動的に割り当てられることも解放されることもありません。</target>
        </trans-unit>
        <trans-unit id="7f297b31862071391a99da1af535c50f23bb4ea5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;items&lt;/em&gt; of a program are those functions, modules, and types that have their value calculated at compile-time and stored uniquely in the memory image of the rust process. Items are neither dynamically allocated nor freed.</source>
          <target state="translated">プログラムの&lt;em&gt;項目&lt;/em&gt;は、コンパイル時に値が計算され、rustプロセスのメモリイメージに一意に格納される関数、モジュール、およびタイプです。アイテムは動的に割り当ても解放もされません。</target>
        </trans-unit>
        <trans-unit id="867bacda5c963969dd78331f878c031b22f73cbb" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;null escape&lt;/em&gt; is the character &lt;code&gt;U+0030&lt;/code&gt; (&lt;code&gt;0&lt;/code&gt;) and denotes the Unicode value &lt;code&gt;U+0000&lt;/code&gt; (NUL).</source>
          <target state="translated">&lt;em&gt;ヌルエスケープは&lt;/em&gt;文字である &lt;code&gt;U+0030&lt;/code&gt; （ &lt;code&gt;0&lt;/code&gt; ）とUnicode値意味 &lt;code&gt;U+0000&lt;/code&gt; （NUL）を。</target>
        </trans-unit>
        <trans-unit id="c0460a3f4832868522908bad2876d5f8fef36d49" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;null escape&lt;/em&gt; is the character &lt;code&gt;U+0030&lt;/code&gt; (&lt;code&gt;0&lt;/code&gt;) and denotes the byte value &lt;code&gt;0x00&lt;/code&gt; (ASCII NUL).</source>
          <target state="translated">&lt;em&gt;ヌルエスケープは&lt;/em&gt;文字である &lt;code&gt;U+0030&lt;/code&gt; （ &lt;code&gt;0&lt;/code&gt; ）とバイト値意味 &lt;code&gt;0x00&lt;/code&gt; （ASCII NUL）を。</target>
        </trans-unit>
        <trans-unit id="b4b356718e399f8a05dc4012731a26a28084f252" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;prelude&lt;/em&gt; is the list of things that Rust automatically imports into every Rust program. It's kept as small as possible, and is focused on things, particularly traits, which are used in almost every single Rust program.</source>
          <target state="translated">&lt;em&gt;前奏曲は&lt;/em&gt;、すべての錆プログラムに錆が自動的に輸入もののリストです。それは可能な限り小さく保たれ、ほとんどすべてのRustプログラムで使用されるもの、特に特性に焦点が当てられています。</target>
        </trans-unit>
        <trans-unit id="c5fc79bf9688aa8e786959c2742e411818e5d89a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;primitive representations&lt;/em&gt; are the representations with the same names as the primitive integer types. That is: &lt;code&gt;u8&lt;/code&gt;, &lt;code&gt;u16&lt;/code&gt;, &lt;code&gt;u32&lt;/code&gt;, &lt;code&gt;u64&lt;/code&gt;, &lt;code&gt;u128&lt;/code&gt;, &lt;code&gt;usize&lt;/code&gt;, &lt;code&gt;i8&lt;/code&gt;, &lt;code&gt;i16&lt;/code&gt;, &lt;code&gt;i32&lt;/code&gt;, &lt;code&gt;i64&lt;/code&gt;, &lt;code&gt;i128&lt;/code&gt;, and &lt;code&gt;isize&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;プリミティブ表現は&lt;/em&gt;、プリミティブ整数型と同じ名前の表現です。つまり、 &lt;code&gt;u8&lt;/code&gt; 、 &lt;code&gt;u16&lt;/code&gt; 、 &lt;code&gt;u32&lt;/code&gt; 、 &lt;code&gt;u64&lt;/code&gt; 、 &lt;code&gt;u128&lt;/code&gt; 、 &lt;code&gt;usize&lt;/code&gt; 、 &lt;code&gt;i8&lt;/code&gt; 、 &lt;code&gt;i16&lt;/code&gt; 、 &lt;code&gt;i32&lt;/code&gt; 、 &lt;code&gt;i64&lt;/code&gt; 、 &lt;code&gt;i128&lt;/code&gt; 、 &lt;code&gt;isize&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="a3ce8f949608b1daede8105623fa327eab5c410b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;rest pattern&lt;/em&gt; (the &lt;code&gt;..&lt;/code&gt; token) acts as a variable-length pattern which matches zero or more elements that haven't been matched already before and after. It may only be used in &lt;a href=&quot;#tuple-patterns&quot;&gt;tuple&lt;/a&gt;, &lt;a href=&quot;#tuple-struct-patterns&quot;&gt;tuple struct&lt;/a&gt;, and &lt;a href=&quot;#slice-patterns&quot;&gt;slice&lt;/a&gt; patterns, and may only appear once as one of the elements in those patterns. It is also allowed in an &lt;a href=&quot;#identifier-patterns&quot;&gt;identifier pattern&lt;/a&gt; for &lt;a href=&quot;#slice-patterns&quot;&gt;slice patterns&lt;/a&gt; only.</source>
          <target state="translated">&lt;em&gt;静止パターン&lt;/em&gt;（ &lt;code&gt;..&lt;/code&gt; トークン）が前後に既に一致していないゼロ個以上の要素と一致する可変長パターンとして機能します。それだけで使用することができる&lt;a href=&quot;#tuple-patterns&quot;&gt;タプル&lt;/a&gt;、&lt;a href=&quot;#tuple-struct-patterns&quot;&gt;タプル構造体&lt;/a&gt;、及び&lt;a href=&quot;#slice-patterns&quot;&gt;スライス&lt;/a&gt;パターン、およびのみパターンの要素の一つとして一度に表示されてもよいです。また、&lt;a href=&quot;#slice-patterns&quot;&gt;スライスパターンの&lt;/a&gt;&lt;a href=&quot;#identifier-patterns&quot;&gt;識別子パターン&lt;/a&gt;でも許可されます。</target>
        </trans-unit>
        <trans-unit id="4971362f3b5f40470a74c81b64c44c61022c0ae5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;size&lt;/em&gt; of a value is the offset in bytes between successive elements in an array with that item type including alignment padding. The size of a value is always a multiple of its alignment. The size of a value can be checked with the &lt;a href=&quot;../std/mem/fn.size_of_val&quot;&gt;&lt;code&gt;size_of_val&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">値の&lt;em&gt;サイズ&lt;/em&gt;は、配列のパディングを含むその項目タイプの配列内の連続する要素間のバイト単位のオフセットです。値のサイズは常にその配置の倍数です。値のサイズは、&lt;a href=&quot;../std/mem/fn.size_of_val&quot;&gt; &lt;code&gt;size_of_val&lt;/code&gt; &lt;/a&gt;関数で確認できます。</target>
        </trans-unit>
        <trans-unit id="608607007d0795edd59e30f51aeabc80ca46b5f6" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;state pattern&lt;/em&gt; is an object-oriented design pattern. The crux of the pattern is that a value has some internal state, which is represented by a set of &lt;em&gt;state objects&lt;/em&gt;, and the value&amp;rsquo;s behavior changes based on the internal state. The state objects share functionality: in Rust, of course, we use structs and traits rather than objects and inheritance. Each state object is responsible for its own behavior and for governing when it should change into another state. The value that holds a state object knows nothing about the different behavior of the states or when to transition between states.</source>
          <target state="translated">&lt;em&gt;状態パターンは、&lt;/em&gt;オブジェクト指向のデザインパターンです。パターンの要点は、値に一連の&lt;em&gt;状態オブジェクト&lt;/em&gt;で表される内部状態があり、値の動作が内部状態に基づいて変化することです。状態オブジェクトは機能を共有します。もちろん、Rustでは、オブジェクトと継承ではなく、構造体と特性を使用します。各状態オブジェクトは、それ自体の動作と、いつ別の状態に変化するかを管理します。状態オブジェクトを保持する値は、状態のさまざまな動作や状態間の遷移のタイミングについて何も知りません。</target>
        </trans-unit>
        <trans-unit id="ec835310b404eed2cb3a60731c66a0fc7069cf96" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;successor&lt;/em&gt; operation moves towards values that compare greater. The &lt;em&gt;predecessor&lt;/em&gt; operation moves towards values that compare lesser.</source>
          <target state="translated">&lt;em&gt;後継&lt;/em&gt;大きい比較値に向かって操作動きます。&lt;em&gt;先行&lt;/em&gt;少ない比較値に向かって操作動きます。</target>
        </trans-unit>
        <trans-unit id="71b31d9fd96bdd059ab3da8b882ee0c455f89891" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;temporary scope&lt;/em&gt; of an expression is the scope that is used for the temporary variable that holds the result of that expression when used in a &lt;a href=&quot;expressions#place-expressions-and-value-expressions&quot;&gt;place context&lt;/a&gt;, unless it is &lt;a href=&quot;destructors#constant-promotion&quot;&gt;promoted&lt;/a&gt;.</source>
          <target state="translated">式の&lt;em&gt;一時スコープ&lt;/em&gt;は、&lt;a href=&quot;destructors#constant-promotion&quot;&gt;プロモート&lt;/a&gt;されていない限り、&lt;a href=&quot;expressions#place-expressions-and-value-expressions&quot;&gt;プレイスコンテキスト&lt;/a&gt;で使用されたときにその式の結果を保持する一時変数に使用されるスコープです。</target>
        </trans-unit>
        <trans-unit id="da892b01ccbdf152bb00bb5fb34ad8db3069d651" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;tuple type&lt;/em&gt; is a structural type&lt;sup&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; for heterogeneous lists of other types. Each entry in the list is an &lt;em&gt;element&lt;/em&gt;&lt;sup&gt;&lt;a href=&quot;#2&quot;&gt;2&lt;/a&gt;&lt;/sup&gt; of the tuple. The position of the element makes it the &lt;em&gt;nth element&lt;/em&gt; using zero (&lt;code&gt;0&lt;/code&gt;) as the initial index.</source>
          <target state="translated">&lt;em&gt;タプルタイプは&lt;/em&gt;構造タイプである&lt;sup&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;、他のタイプの不均一リストの。リストの各エントリは、タプルの&lt;em&gt;要素&lt;/em&gt;&lt;sup&gt;&lt;a href=&quot;#2&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;です。要素の位置は、初期インデックスとしてゼロ（ &lt;code&gt;0&lt;/code&gt; ）を使用する&lt;em&gt;n番目の要素になり&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="50c8131f661492ad3eb04d5338d01ccf9f429562" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;wildcard pattern&lt;/em&gt; (an underscore symbol) matches any value. It is used to ignore values when they don't matter. Inside other patterns it matches a single data field (as opposed to the &lt;code&gt;..&lt;/code&gt; which matches the remaining fields). Unlike identifier patterns, it does not copy, move or borrow the value it matches.</source>
          <target state="translated">&lt;em&gt;ワイルドカードパターン&lt;/em&gt;（下線記号）は、任意の値と一致します。値が重要でない場合に値を無視するために使用されます。他のパターン内では、単一のデータフィールドに一致します（残りのフィールドに一致する &lt;code&gt;..&lt;/code&gt; とは対照的です）。識別子パターンとは異なり、一致する値をコピー、移動、または借用しません。</target>
        </trans-unit>
        <trans-unit id="2c707e6c38639fd82e39cc81120827bce74e177e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;wildcard pattern&lt;/em&gt; matches any value. It is used to ignore values when they don't matter. Inside other patterns it matches a single data field (as opposed to the &lt;code&gt;..&lt;/code&gt; which matches the remaining fields). Unlike identifier patterns, it does not copy, move or borrow the value it matches.</source>
          <target state="translated">&lt;em&gt;ワイルドカードパターンは&lt;/em&gt;任意の値に一致します。値が重要ではない場合に無視するために使用されます。他のパターン内では、単一のデータフィールドに一致します（残りのフィールドに一致する &lt;code&gt;..&lt;/code&gt; とは対照的です）。識別子パターンとは異なり、一致する値をコピー、移動、または借用しません。</target>
        </trans-unit>
        <trans-unit id="75f0595163c83b48141e476739787cd1006a8d33" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;channel&lt;/strong&gt;'s sending half has become disconnected, and there will never be any more data received on it.</source>
          <target state="translated">&lt;strong&gt;チャネル&lt;/strong&gt;の送信の半分が切断になってきた、そしてそれを受け、それ以上のデータがあることはありません。</target>
        </trans-unit>
        <trans-unit id="7d020769b0b6d90680db8e09c6dc6e9b663dc909" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;compiler&lt;/strong&gt; reordering instructions: If the compiler can issue an instruction at an earlier point, it will try to do so. For example, it might hoist memory loads at the top of a code block, so that the CPU can start &lt;a href=&quot;https://en.wikipedia.org/wiki/Cache_prefetching&quot;&gt;prefetching&lt;/a&gt; the values from memory.</source>
          <target state="translated">&lt;strong&gt;コンパイラ&lt;/strong&gt;の指示を並べ替え：コンパイラは、以前の時点で指示を出すことができれば、それはそうしようとします。たとえば、CPUがメモリからの値の&lt;a href=&quot;https://en.wikipedia.org/wiki/Cache_prefetching&quot;&gt;プリフェッチ&lt;/a&gt;を開始できるように、メモリブロックをコードブロックの先頭で引き上げる場合があります。</target>
        </trans-unit>
        <trans-unit id="314b68cd7b660a21edb44d2117cd4a156ae245a5" translate="yes" xml:space="preserve">
          <source>The API documentation that &lt;code&gt;cargo doc&lt;/code&gt; generates for this crate will now list and link re-exports on the front page, as shown in Figure 14-4, making the &lt;code&gt;PrimaryColor&lt;/code&gt; and &lt;code&gt;SecondaryColor&lt;/code&gt; types and the &lt;code&gt;mix&lt;/code&gt; function easier to find.</source>
          <target state="translated">図14-4に示すように、 &lt;code&gt;cargo doc&lt;/code&gt; がこのクレートに対して生成するAPIドキュメントは、フロントページに再エクスポートをリストおよびリンクし、 &lt;code&gt;PrimaryColor&lt;/code&gt; および &lt;code&gt;SecondaryColor&lt;/code&gt; タイプと &lt;code&gt;mix&lt;/code&gt; 関数を見つけやすくします。</target>
        </trans-unit>
        <trans-unit id="fe97d53a4341ff985473c7759453c7f0b6f51809" translate="yes" xml:space="preserve">
          <source>The API is typically used by acquiring a handle to the current thread, placing that handle in a shared data structure so that other threads can find it, and then &lt;code&gt;park&lt;/code&gt;ing in a loop. When some desired condition is met, another thread calls &lt;a href=&quot;struct.thread#method.unpark&quot;&gt;&lt;code&gt;unpark&lt;/code&gt;&lt;/a&gt; on the handle.</source>
          <target state="translated">APIは、典型的には、他のスレッドがそれを見つけることができるように、共有データ構造で、そのハンドルを配置し、現在のスレッドへのハンドルを取得することで使用して、さ &lt;code&gt;park&lt;/code&gt; ループにする。必要な条件が満たされると、別のスレッドがハンドルの&lt;a href=&quot;struct.thread#method.unpark&quot;&gt; &lt;code&gt;unpark&lt;/code&gt; &lt;/a&gt;を呼び出します。</target>
        </trans-unit>
        <trans-unit id="bdef16eb0aad1c8443510daaf0eaf64f22da449f" translate="yes" xml:space="preserve">
          <source>The API of &lt;code id=&quot;the-api-of-mutext&quot;&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code id=&quot;the-api-of-mutext&quot;&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; のAPI</target>
        </trans-unit>
        <trans-unit id="da2fca5419425bb1dfeff3a19e5e6b522b71b9f7" translate="yes" xml:space="preserve">
          <source>The Anatomy of a Test Function</source>
          <target state="translated">テスト機能の解剖学</target>
        </trans-unit>
        <trans-unit id="6ff9dd46af7ebe72f506f56aea2ffd15b7f82cfe" translate="yes" xml:space="preserve">
          <source>The Array Type</source>
          <target state="translated">配列型</target>
        </trans-unit>
        <trans-unit id="4c7fdb8a442bced7fcc6b743d86e4b178b1bc140" translate="yes" xml:space="preserve">
          <source>The Boolean Type</source>
          <target state="translated">ブール型</target>
        </trans-unit>
        <trans-unit id="7a47e0b8b6b1bfa40f74993b9ed02984c335782d" translate="yes" xml:space="preserve">
          <source>The Boolean type, &lt;code&gt;bool&lt;/code&gt;, with values &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">ブール型 &lt;code&gt;bool&lt;/code&gt; で、値は &lt;code&gt;true&lt;/code&gt; と &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="d554fe4c508301c7dd79586706f031038650a679" translate="yes" xml:space="preserve">
          <source>The Borrow Checker</source>
          <target state="translated">借り入れチェッカー</target>
        </trans-unit>
        <trans-unit id="706bc5bdd045092d3c34365727a87c607d4ff3a3" translate="yes" xml:space="preserve">
          <source>The C side must &lt;strong&gt;not&lt;/strong&gt; modify the length of the string (by writing a &lt;code&gt;NULL&lt;/code&gt; somewhere inside the string or removing the final one) before it makes it back into Rust using &lt;a href=&quot;struct.cstring#method.from_raw&quot;&gt;&lt;code&gt;CString::from_raw&lt;/code&gt;&lt;/a&gt;. See the safety section in &lt;a href=&quot;struct.cstring#method.from_raw&quot;&gt;&lt;code&gt;CString::from_raw&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">C側は、&lt;a href=&quot;struct.cstring#method.from_raw&quot;&gt; &lt;code&gt;CString::from_raw&lt;/code&gt; &lt;/a&gt;を使用してRustに戻す前に、文字列の長さを変更してはなりませ&lt;strong&gt;ん&lt;/strong&gt;（文字列内のどこかに &lt;code&gt;NULL&lt;/code&gt; を書き込むか、最後の文字列を削除します）。&lt;a href=&quot;struct.cstring#method.from_raw&quot;&gt; &lt;code&gt;CString::from_raw&lt;/code&gt; &lt;/a&gt;安全セクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="096fc2c3eb95fb5d0ee6aa092c0689c069929e6f" translate="yes" xml:space="preserve">
          <source>The C-main function only supports to return integers as return type. So, every type implementing the &lt;code&gt;Termination&lt;/code&gt; trait has to be converted to an integer.</source>
          <target state="translated">C-main関数は、戻り値の型として整数を返すことのみをサポートしています。したがって、 &lt;code&gt;Termination&lt;/code&gt; 特性を実装するすべてのタイプは整数に変換する必要があります。</target>
        </trans-unit>
        <trans-unit id="da6976366f57ccb20ad430117c89098f7fb1348a" translate="yes" xml:space="preserve">
          <source>The C-variadic type &lt;code&gt;...&lt;/code&gt; has been nested inside another type.</source>
          <target state="translated">C可変個引数型 &lt;code&gt;...&lt;/code&gt; は別の型の中にネストされています。</target>
        </trans-unit>
        <trans-unit id="86641abf85c69d8c4f7c9c71c79144e3a2832005" translate="yes" xml:space="preserve">
          <source>The Character Type</source>
          <target state="translated">文字タイプ</target>
        </trans-unit>
        <trans-unit id="35e39875eebfabcb5b0b8cd30288767fc0b6add8" translate="yes" xml:space="preserve">
          <source>The Clippy tool is a collection of lints to analyze your code so you can catch common mistakes and improve your Rust code.</source>
          <target state="translated">Clippy ツールは、コードを分析するための lints のコレクションで、よくある間違いを見つけて Rust コードを改善することができます。</target>
        </trans-unit>
        <trans-unit id="bb08bad287d0caba2752b58d322b62f2942d38e6" translate="yes" xml:space="preserve">
          <source>The Default Representation</source>
          <target state="translated">デフォルトの表現</target>
        </trans-unit>
        <trans-unit id="f9e1a59444e395f067802b105261ac31a11eac66" translate="yes" xml:space="preserve">
          <source>The Difference Between Macros and Functions</source>
          <target state="translated">マクロと関数の違い</target>
        </trans-unit>
        <trans-unit id="7241096a248faf0667959dae2f7e6a0390d29dce" translate="yes" xml:space="preserve">
          <source>The GID part of the peer credential. This is the effective GID of the process at the domain socket's endpoint.</source>
          <target state="translated">ピアクレデンシャルの GID 部分。これは、ドメインソケットのエンドポイントのプロセスの有効なGIDである。</target>
        </trans-unit>
        <trans-unit id="47f6987535ee435e225cb875fe024ba6f3b75e49" translate="yes" xml:space="preserve">
          <source>The Glob Operator</source>
          <target state="translated">Globオペレータ</target>
        </trans-unit>
        <trans-unit id="a0a1aaf98c3bce57246183f1baadfe83da9b49cd" translate="yes" xml:space="preserve">
          <source>The HTML format is available online at &lt;a href=&quot;https://doc.rust-lang.org/stable/book/index.html&quot;&gt;https://doc.rust-lang.org/stable/book/&lt;/a&gt; and offline with installations of Rust made with &lt;code&gt;rustup&lt;/code&gt;; run &lt;code&gt;rustup docs --book&lt;/code&gt; to open.</source>
          <target state="translated">HTML形式は、&lt;a href=&quot;https://doc.rust-lang.org/stable/book/index.html&quot;&gt;https：&lt;/a&gt; &lt;code&gt;rustup&lt;/code&gt; でオンラインで、rustupで作成されたRustをインストールするとオフラインで利用できます。 &lt;code&gt;rustup docs --book&lt;/code&gt; を実行して開きます。</target>
        </trans-unit>
        <trans-unit id="00df77514c97d921fca4a972435309219a163a06" translate="yes" xml:space="preserve">
          <source>The I/O Prelude</source>
          <target state="translated">I/Oプレリュード</target>
        </trans-unit>
        <trans-unit id="6979c051972c7d2da3658847fabbf6a31d84bdb5" translate="yes" xml:space="preserve">
          <source>The I/O operation's timeout expired, causing it to be canceled.</source>
          <target state="translated">I/O操作のタイムアウトが切れたため、キャンセルされました。</target>
        </trans-unit>
        <trans-unit id="dc9c14a7eb4854c512e7ed69d5ba6a43f9c253aa" translate="yes" xml:space="preserve">
          <source>The IEEE 754-2008 &quot;binary32&quot; and &quot;binary64&quot; floating-point types are &lt;code&gt;f32&lt;/code&gt; and &lt;code&gt;f64&lt;/code&gt;, respectively.</source>
          <target state="translated">IEEE 754-2008の「binary32」と「binary64」の浮動小数点型は、それぞれ &lt;code&gt;f32&lt;/code&gt; と &lt;code&gt;f64&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="a46bc695392f8c742f4e678a79ed2375790074cb" translate="yes" xml:space="preserve">
          <source>The Matcher Invariants</source>
          <target state="translated">マッチャ不変量</target>
        </trans-unit>
        <trans-unit id="5eece4981b24083c68ecabd071b66fe17ba1ce62" translate="yes" xml:space="preserve">
          <source>The Never Type that Never Returns</source>
          <target state="translated">絶対に返ってこないネバータイプ</target>
        </trans-unit>
        <trans-unit id="388566f1f9117600ae22e2ebff51f82d448e95e2" translate="yes" xml:space="preserve">
          <source>The PID part of the peer credential. This field is optional because the PID part of the peer credentials is not supported on every platform. On platforms where the mechanism to discover the PID exists, this field will be populated to the PID of the process at the domain socket's endpoint. Otherwise, it will be set to None.</source>
          <target state="translated">ピア・クレデンシャルの PID 部分。このフィールドは、すべてのプラットフォームでピアクレデンシャルの PID 部分がサポートされているわけではないため、オプションである。PID を検出するメカニズムが存在するプラットフォームでは、このフィールドにはドメインソケットのエンドポイントのプロセスの PID が入力される。それ以外の場合は None に設定される。</target>
        </trans-unit>
        <trans-unit id="41b8e7692f976fe91f0cb8053dcf33a7090a4f8c" translate="yes" xml:space="preserve">
          <source>The Pattern API provides a generic mechanism for using different pattern types when searching through a string.</source>
          <target state="translated">パターンAPIは、文字列を検索する際に異なるパターンタイプを使用するための一般的なメカニズムを提供します。</target>
        </trans-unit>
        <trans-unit id="ba8021c95f458659340856b34b5ce555bddda300" translate="yes" xml:space="preserve">
          <source>The RFC Process and Teams</source>
          <target state="translated">RFCのプロセスとチーム</target>
        </trans-unit>
        <trans-unit id="667bd8e20b1ba8153f27c9ff6c220024562a73c6" translate="yes" xml:space="preserve">
          <source>The Rules of References</source>
          <target state="translated">参考文献のルール</target>
        </trans-unit>
        <trans-unit id="161ef3f14aee5229baf3e48cdbbdab5a784349b3" translate="yes" xml:space="preserve">
          <source>The Rust Language Server powers Integrated Development Environment (IDE) integration for code completion and inline error messages.</source>
          <target state="translated">Rust Language Server は、コード補完とインライン エラー メッセージのための統合開発環境 (IDE)を提供します。</target>
        </trans-unit>
        <trans-unit id="efbadde43b4ea2876af269fef5bbeff660435dad" translate="yes" xml:space="preserve">
          <source>The Rust Prelude</source>
          <target state="translated">サビの前奏曲</target>
        </trans-unit>
        <trans-unit id="1e47c327d13b68cc315d8c0718500294854d4bd4" translate="yes" xml:space="preserve">
          <source>The Rust Prelude.</source>
          <target state="translated">ラストの前奏曲。</target>
        </trans-unit>
        <trans-unit id="64d4853b323b63d9ca56f4771bf913212d9ace7a" translate="yes" xml:space="preserve">
          <source>The Rust Programming Language</source>
          <target state="translated">Rust プログラミング言語</target>
        </trans-unit>
        <trans-unit id="0bb645ae646711df91105c5e5d03daf9c88ee91b" translate="yes" xml:space="preserve">
          <source>The Rust Standard Library</source>
          <target state="translated">ラスト標準ライブラリ</target>
        </trans-unit>
        <trans-unit id="9c789ddc154274d796ddc2e963326017f63c2958" translate="yes" xml:space="preserve">
          <source>The Rust Standard Library is the foundation of portable Rust software, a set of minimal and battle-tested shared abstractions for the &lt;a href=&quot;https://crates.io&quot;&gt;broader Rust ecosystem&lt;/a&gt;. It offers core types, like &lt;a href=&quot;vec/index&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;option/enum.option&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, library-defined &lt;a href=&quot;#primitives&quot;&gt;operations on language primitives&lt;/a&gt;, &lt;a href=&quot;#macros&quot;&gt;standard macros&lt;/a&gt;, &lt;a href=&quot;io/index&quot;&gt;I/O&lt;/a&gt; and &lt;a href=&quot;thread/index&quot;&gt;multithreading&lt;/a&gt;, among &lt;a href=&quot;#what-is-in-the-standard-library-documentation&quot;&gt;many other things&lt;/a&gt;.</source>
          <target state="translated">Rust標準ライブラリは、ポータブルRustソフトウェアの基盤であり、&lt;a href=&quot;https://crates.io&quot;&gt;幅広いRustエコシステム&lt;/a&gt;向けの最小限の、かつテスト済みの共有抽象化のセットです。それは次のように、コアの種類を提供しています&lt;a href=&quot;vec/index&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;option/enum.option&quot;&gt; &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;、ライブラリーに定義された&lt;a href=&quot;#primitives&quot;&gt;言語のプリミティブ上の操作&lt;/a&gt;、&lt;a href=&quot;#macros&quot;&gt;標準マクロ&lt;/a&gt;、&lt;a href=&quot;io/index&quot;&gt;I / O&lt;/a&gt;や&lt;a href=&quot;thread/index&quot;&gt;マルチスレッド&lt;/a&gt;の中で、&lt;a href=&quot;#what-is-in-the-standard-library-documentation&quot;&gt;他の多くのもの&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4d3f2d23ee5d88e5e35ea9e8e79bcbc0fd6e3b11" translate="yes" xml:space="preserve">
          <source>The Rust Standard Library is the foundation of portable Rust software, a set of minimal and battle-tested shared abstractions for the &lt;a href=&quot;https://crates.io&quot;&gt;broader Rust ecosystem&lt;/a&gt;. It offers core types, like &lt;a href=&quot;vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;option/enum.option&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, library-defined &lt;a href=&quot;#primitives&quot;&gt;operations on language primitives&lt;/a&gt;, &lt;a href=&quot;#macros&quot;&gt;standard macros&lt;/a&gt;, &lt;a href=&quot;io/index&quot;&gt;I/O&lt;/a&gt; and &lt;a href=&quot;thread/index&quot;&gt;multithreading&lt;/a&gt;, among &lt;a href=&quot;#what-is-in-the-standard-library-documentation&quot;&gt;many other things&lt;/a&gt;.</source>
          <target state="translated">Rust Standard Libraryは、ポータブルRustソフトウェアの基盤であり、&lt;a href=&quot;https://crates.io&quot;&gt;より広範なRustエコシステム&lt;/a&gt;向けの最小限の戦闘テスト済みの共有抽象化のセットです。それは次のように、コアの種類を提供しています&lt;a href=&quot;vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;option/enum.option&quot;&gt; &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;、ライブラリーに定義された&lt;a href=&quot;#primitives&quot;&gt;言語のプリミティブ上の操作&lt;/a&gt;、&lt;a href=&quot;#macros&quot;&gt;標準マクロ&lt;/a&gt;、&lt;a href=&quot;io/index&quot;&gt;I / O&lt;/a&gt;や&lt;a href=&quot;thread/index&quot;&gt;マルチスレッド&lt;/a&gt;の中で、&lt;a href=&quot;#what-is-in-the-standard-library-documentation&quot;&gt;他の多くのもの&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5c3853d774e4956749b7c91653db336f2eec58d4" translate="yes" xml:space="preserve">
          <source>The Rust compiler does not consider the following behaviors &lt;em&gt;unsafe&lt;/em&gt;, though a programmer may (should) find them undesirable, unexpected, or erroneous.</source>
          <target state="translated">Rustコンパイラーは、以下の動作を&lt;em&gt;安全&lt;/em&gt;でないと見なしませんが、プログラマーはそれらを望ましくない、予期しない、または誤ったものと見なす可能性があります（すべきです）。</target>
        </trans-unit>
        <trans-unit id="21b3dd0203ec587beb1963c1f4feb0c5c3e73b91" translate="yes" xml:space="preserve">
          <source>The Rust compiler has a &lt;em&gt;borrow checker&lt;/em&gt; that compares scopes to determine whether all borrows are valid. Listing 10-18 shows the same code as Listing 10-17 but with annotations showing the lifetimes of the variables.</source>
          <target state="translated">Rustコンパイラには、スコープを比較してすべての借用が有効かどうかを判断する&lt;em&gt;借用チェッカー&lt;/em&gt;があります。リスト10-18はリスト10-17と同じコードを示していますが、変数の寿命を示す注釈が付いています。</target>
        </trans-unit>
        <trans-unit id="bac79421ac7e7f4a69670a43a87279fa1ea360c9" translate="yes" xml:space="preserve">
          <source>The Rust compiler is always invoked with a single source file as input, and always produces a single output crate. The processing of that source file may result in other source files being loaded as modules. Source files have the extension &lt;code&gt;.rs&lt;/code&gt;.</source>
          <target state="translated">Rustコンパイラーは、常に単一のソースファイルを入力として呼び出され、常に単一の出力クレートを生成します。そのソースファイルの処理により、他のソースファイルがモジュールとしてロードされる場合があります。ソースファイルの拡張子は &lt;code&gt;.rs&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="edecdb50208b6b73bf12c25a96c41ebd3a559a66" translate="yes" xml:space="preserve">
          <source>The Rust language and compiler have a six-week release cycle, meaning users get a constant stream of new features. Other programming languages release larger changes less often; Rust releases smaller updates more frequently. After a while, all of these tiny changes add up. But from release to release, it can be difficult to look back and say, &amp;ldquo;Wow, between Rust 1.10 and Rust 1.31, Rust has changed a lot!&amp;rdquo;</source>
          <target state="translated">Rust言語とコンパイラには6週間のリリースサイクルがあります。つまり、ユーザーは常に新しい機能を利用できます。他のプログラミング言語では、大きな変更がリリースされる頻度が低くなっています。 Rustは小さな更新をより頻繁にリリースします。しばらくすると、これらの小さな変更がすべて追加されます。しかし、リリースごとに振り返って「Rust 1.10とRust 1.31の間で、Rustは大幅に変更されました！」と言うのは難しい場合があります。</target>
        </trans-unit>
        <trans-unit id="bb670b9e802863986c803bc2c279a2c3ad127d26" translate="yes" xml:space="preserve">
          <source>The Rust language has a set of &lt;em&gt;keywords&lt;/em&gt; that are reserved for use by the language only, much as in other languages. Keep in mind that you cannot use these words as names of variables or functions. Most of the keywords have special meanings, and you&amp;rsquo;ll be using them to do various tasks in your Rust programs; a few have no current functionality associated with them but have been reserved for functionality that might be added to Rust in the future. You can find a list of the keywords in &lt;a href=&quot;appendix-01-keywords&quot;&gt;Appendix A&lt;/a&gt;.</source>
          <target state="translated">Rust言語には、他の言語と同様に、その言語でのみ使用するために予約されている一連の&lt;em&gt;キーワード&lt;/em&gt;があります。これらの単語を変数または関数の名前として使用することはできないことに注意してください。ほとんどのキーワードには特別な意味があり、Rustプログラムでさまざまなタスクを実行するためにそれらを使用します。現在の機能が関連付けられていないものもありますが、将来Rustに追加される可能性のある機能のために予約されています。キーワードのリストは&lt;a href=&quot;appendix-01-keywords&quot;&gt;付録Aにあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="4db8a730c896d57ac8ae13218ced391891bc4c9e" translate="yes" xml:space="preserve">
          <source>The Rust language has a set of &lt;em&gt;keywords&lt;/em&gt; that are reserved for use by the language only, much as in other languages. Keep in mind that you cannot use these words as names of variables or functions. Most of the keywords have special meanings, and you&amp;rsquo;ll be using them to do various tasks in your Rust programs; a few have no current functionality associated with them but have been reserved for functionality that might be added to Rust in the future. You can find a list of the keywords in Appendix A.</source>
          <target state="translated">Rust言語には、他の言語と同様に、その言語でのみ使用するために予約されている&lt;em&gt;キーワードの&lt;/em&gt;セットがあります。これらの単語を変数または関数の名前として使用することはできません。ほとんどのキーワードには特別な意味があり、Rustプログラムでさまざまなタスクを実行するために使用します。現在の機能に関連付けられていないものもありますが、将来的にRustに追加される可能性のある機能のために予約されているものもあります。付録Aにキーワードのリストがあります。</target>
        </trans-unit>
        <trans-unit id="5c421a36adf32e1316c136776ce05dd83536c6c8" translate="yes" xml:space="preserve">
          <source>The Rust language hopes to support many other users as well; those mentioned here are merely some of the biggest stakeholders. Overall, Rust&amp;rsquo;s greatest ambition is to eliminate the trade-offs that programmers have accepted for decades by providing safety &lt;em&gt;and&lt;/em&gt; productivity, speed &lt;em&gt;and&lt;/em&gt; ergonomics. Give Rust a try and see if its choices work for you.</source>
          <target state="translated">Rust言語は、他の多くのユーザーもサポートしたいと考えています。ここで言及されているものは、最大の利害関係者の一部にすぎません。全体として、Rustの最大の目標は、安全性&lt;em&gt;と&lt;/em&gt;生産性、速度&lt;em&gt;、および&lt;/em&gt;人間工学を提供することにより、プログラマーが数十年にわたって受け入れてきたトレードオフを排除することです。 Rustを試して、その選択がうまくいくかどうかを確認してください。</target>
        </trans-unit>
        <trans-unit id="596e2b7dbc791cd3cfc77236ae00a927665967e2" translate="yes" xml:space="preserve">
          <source>The Rust runtime</source>
          <target state="translated">Rust ランタイム</target>
        </trans-unit>
        <trans-unit id="6be65bd73ad861e62f3888e1cc3672c017c1636b" translate="yes" xml:space="preserve">
          <source>The Rust standard library provides channels for message passing and smart pointer types, such as &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt;, that are safe to use in concurrent contexts. The type system and the borrow checker ensure that the code using these solutions won&amp;rsquo;t end up with data races or invalid references. Once you get your code to compile, you can rest assured that it will happily run on multiple threads without the kinds of hard-to-track-down bugs common in other languages. Concurrent programming is no longer a concept to be afraid of: go forth and make your programs concurrent, fearlessly!</source>
          <target state="translated">Rust標準ライブラリは、同時コンテキストで安全に使用できる、 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; や &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; などのメッセージ受け渡しとスマートポインタ型のチャネルを提供します。型システムと借用チェッカーは、これらのソリューションを使用するコードがデータ競合や無効な参照で終了しないことを保証します。コードをコンパイルしたら、他の言語で一般的な追跡が困難な種類のバグがなく、複数のスレッドで問題なく実行できることを確信できます。並行プログラミングはもはや恐れるべき概念ではありません：恐れずにプログラムを並行にしてください！</target>
        </trans-unit>
        <trans-unit id="ca0e948d58962dbdfe194b991ab15a2f509a074c" translate="yes" xml:space="preserve">
          <source>The Rust type system has some features that we&amp;rsquo;ve mentioned in this book but haven&amp;rsquo;t yet discussed. We&amp;rsquo;ll start by discussing newtypes in general as we examine why newtypes are useful as types. Then we&amp;rsquo;ll move on to type aliases, a feature similar to newtypes but with slightly different semantics. We&amp;rsquo;ll also discuss the &lt;code&gt;!&lt;/code&gt; type and dynamically sized types.</source>
          <target state="translated">Rust型システムには、この本で言及したがまだ説明していない機能がいくつかあります。newtypesが型として有用である理由を調べる際には、まずnewtypesについて説明します。次に、タイプエイリアスに移ります。これは、newtypeに似ていますが、セマンティクスが少し異なります。についても説明し &lt;code&gt;!&lt;/code&gt; タイプと動的サイズのタイプ。</target>
        </trans-unit>
        <trans-unit id="1e24d83679bf4a662ce93151d4c79beb7bc3d976" translate="yes" xml:space="preserve">
          <source>The Slice Type</source>
          <target state="translated">スライスタイプ</target>
        </trans-unit>
        <trans-unit id="b60a9b411326be4b7b78e74a3c2736078d2cb936" translate="yes" xml:space="preserve">
          <source>The Stack and the Heap</source>
          <target state="translated">スタックとヒープ</target>
        </trans-unit>
        <trans-unit id="ea9187c27f13ce2d0fda228c7804b1eacb2a7df4" translate="yes" xml:space="preserve">
          <source>The Static Lifetime</source>
          <target state="translated">静的寿命</target>
        </trans-unit>
        <trans-unit id="dcc1bdcf64d9ba08b8c546b48a03373f9d896f1a" translate="yes" xml:space="preserve">
          <source>The Tests Module and &lt;code id=&quot;the-tests-module-and-cfgtest&quot;&gt;#[cfg(test)]&lt;/code&gt;</source>
          <target state="translated">テストモジュールと &lt;code id=&quot;the-tests-module-and-cfgtest&quot;&gt;#[cfg(test)]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="43d375d205a43568d44e006351aba054a3a6df0e" translate="yes" xml:space="preserve">
          <source>The Trade-Offs of Using &lt;code id=&quot;the-trade-offs-of-using-clone&quot;&gt;clone&lt;/code&gt;</source>
          <target state="translated">&lt;code id=&quot;the-trade-offs-of-using-clone&quot;&gt;clone&lt;/code&gt; 使用のトレードオフ</target>
        </trans-unit>
        <trans-unit id="874f680f597dff734725c0edb8d1cdbdc1c687fb" translate="yes" xml:space="preserve">
          <source>The Transmission Control Protocol is specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc793&quot;&gt;IETF RFC 793&lt;/a&gt;.</source>
          <target state="translated">伝送制御プロトコルは、&lt;a href=&quot;https://tools.ietf.org/html/rfc793&quot;&gt;IETF RFC 793で&lt;/a&gt;指定されています。</target>
        </trans-unit>
        <trans-unit id="6d2bc0207cf3386e89a8ff90f2a45c74d008dd6b" translate="yes" xml:space="preserve">
          <source>The Tuple Type</source>
          <target state="translated">タプル型</target>
        </trans-unit>
        <trans-unit id="a1fe62622ad4944befb6b7cd3fbf5afe74512445" translate="yes" xml:space="preserve">
          <source>The UID part of the peer credential. This is the effective UID of the process at the domain socket's endpoint.</source>
          <target state="translated">ピアクレデンシャルの UID 部分。これは、ドメインソケットのエンドポイントでのプロセスの有効なUIDである。</target>
        </trans-unit>
        <trans-unit id="720acae72ae852d88680bc6199aaf2a3185402bd" translate="yes" xml:space="preserve">
          <source>The Unsize trait should not be implemented directly. All implementations of Unsize are provided automatically by the compiler.</source>
          <target state="translated">Unsizeの特徴は直接実装されるべきではありません。Unsizeのすべての実装はコンパイラによって自動的に提供されます。</target>
        </trans-unit>
        <trans-unit id="9d8c2343fd3b49fd50014f949ed7698cf46aba4f" translate="yes" xml:space="preserve">
          <source>The ability to return a type that is only specified by the trait it implements is especially useful in the context of closures and iterators, which we cover in Chapter 13. Closures and iterators create types that only the compiler knows or types that are very long to specify. The &lt;code&gt;impl Trait&lt;/code&gt; syntax lets you concisely specify that a function returns some type that implements the &lt;code&gt;Iterator&lt;/code&gt; trait without needing to write out a very long type.</source>
          <target state="translated">実装するトレイトによってのみ指定される型を返す機能は、第13章で説明するクロージャとイテレータのコンテキストで特に役立ちます。クロージャとイテレータは、コンパイラだけが知っている型または非常に長い型を作成します指定します。 &lt;code&gt;impl Trait&lt;/code&gt; 構文は簡潔機能は、いくつかのタイプを返すように指定することができますその実装 &lt;code&gt;Iterator&lt;/code&gt; 非常に長いタイプを書き出すために必要とせず、形質。</target>
        </trans-unit>
        <trans-unit id="8344955111fdc074c9729e11010ee2eab0af03c1" translate="yes" xml:space="preserve">
          <source>The above example can be resolved by either reducing the number of lifetime bounds to one or by making the trait object lifetime explicit, like so:</source>
          <target state="translated">上記の例は、ライフタイム境界の数を1つに減らすか、以下のように形質オブジェクトのライフタイムを明示的にすることで解決することができます。</target>
        </trans-unit>
        <trans-unit id="cde40ac9fea8ec2f55d9ca0d422fc89008496087" translate="yes" xml:space="preserve">
          <source>The above indirection is the additional runtime cost of calling a function on a &lt;code&gt;dyn Trait&lt;/code&gt;. Methods called by dynamic dispatch generally cannot be inlined by the compiler.</source>
          <target state="translated">上記の間接参照は、 &lt;code&gt;dyn Trait&lt;/code&gt; 関数を呼び出すための追加の実行時コストです。動的ディスパッチによって呼び出されるメソッドは、通常、コンパイラーによってインライン化できません。</target>
        </trans-unit>
        <trans-unit id="deb20b7d624d1708cb7603af7f7d5931910cd966" translate="yes" xml:space="preserve">
          <source>The above is &lt;em&gt;still&lt;/em&gt; an expression but it will always evaluate to &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">上記は&lt;em&gt;まだ&lt;/em&gt;式ですが、常に &lt;code&gt;()&lt;/code&gt; に評価されます。</target>
        </trans-unit>
        <trans-unit id="ede9c72b891dfc1d92b0b9fffc4f21007f9ae902" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i128::MIN&lt;/code&gt; cannot be represented as an &lt;code&gt;i128&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i128::MIN&lt;/code&gt; without a panic.</source>
          <target state="translated">絶対値 &lt;code&gt;i128::MIN&lt;/code&gt; として表すことができない &lt;code&gt;i128&lt;/code&gt; 、およびそれを計算しようとすると、オーバーフローが発生します。これは、デバッグモードのコードがこの場合にパニックを引き起こし、最適化されたコードがパニックなしで &lt;code&gt;i128::MIN&lt;/code&gt; を返すことを意味します。</target>
        </trans-unit>
        <trans-unit id="e4ff7b2880604f74445f905b71fdee96836fc628" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i128::min_value()&lt;/code&gt; cannot be represented as an &lt;code&gt;i128&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i128::min_value()&lt;/code&gt; without a panic.</source>
          <target state="translated">絶対値 &lt;code&gt;i128::min_value()&lt;/code&gt; のように表すことができない &lt;code&gt;i128&lt;/code&gt; 、及びそれを計算しようとすると、オーバーフローが発生します。つまり、デバッグモードのコードはこの場合パニックをトリガーし、最適化されたコードはパニックなしで &lt;code&gt;i128::min_value()&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="68e6f1c95dcf27a099d3d4e155f55896bf8faf93" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i16::MIN&lt;/code&gt; cannot be represented as an &lt;code&gt;i16&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i16::MIN&lt;/code&gt; without a panic.</source>
          <target state="translated">絶対値 &lt;code&gt;i16::MIN&lt;/code&gt; として表すことができない &lt;code&gt;i16&lt;/code&gt; 、およびそれを計算しようとすると、オーバーフローが発生します。これは、デバッグモードのコードがこの場合にパニックを引き起こし、最適化されたコードがパニックなしで &lt;code&gt;i16::MIN&lt;/code&gt; を返すことを意味します。</target>
        </trans-unit>
        <trans-unit id="c6634b50eb0aa3afe906f4e13b4800cc26454c92" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i16::min_value()&lt;/code&gt; cannot be represented as an &lt;code&gt;i16&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i16::min_value()&lt;/code&gt; without a panic.</source>
          <target state="translated">絶対値 &lt;code&gt;i16::min_value()&lt;/code&gt; のように表すことができない &lt;code&gt;i16&lt;/code&gt; 、及びそれを計算しようとすると、オーバーフローが発生します。つまり、デバッグモードのコードはこの場合パニックをトリガーし、最適化されたコードはパニックなしで &lt;code&gt;i16::min_value()&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="37e2f0833c2e3fce2e0d86c6e578d1435f9c3b8f" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i32::MIN&lt;/code&gt; cannot be represented as an &lt;code&gt;i32&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i32::MIN&lt;/code&gt; without a panic.</source>
          <target state="translated">絶対値 &lt;code&gt;i32::MIN&lt;/code&gt; として表すことができない &lt;code&gt;i32&lt;/code&gt; 、およびそれを計算しようとすると、オーバーフローが発生します。これは、デバッグモードのコードがこの場合にパニックを引き起こし、最適化されたコードがパニックなしで &lt;code&gt;i32::MIN&lt;/code&gt; を返すことを意味します。</target>
        </trans-unit>
        <trans-unit id="91a991a9b7dce7a35eefa5dff81ee4a280a7e4f1" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i32::min_value()&lt;/code&gt; cannot be represented as an &lt;code&gt;i32&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i32::min_value()&lt;/code&gt; without a panic.</source>
          <target state="translated">絶対値 &lt;code&gt;i32::min_value()&lt;/code&gt; のように表すことができない &lt;code&gt;i32&lt;/code&gt; 、及びそれを計算しようとすると、オーバーフローが発生します。つまり、デバッグモードのコードはこの場合パニックをトリガーし、最適化されたコードはパニックなしで &lt;code&gt;i32::min_value()&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="2ddae722d1b9330d37bd61655516374aae130695" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i64::MIN&lt;/code&gt; cannot be represented as an &lt;code&gt;i64&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i64::MIN&lt;/code&gt; without a panic.</source>
          <target state="translated">絶対値 &lt;code&gt;i64::MIN&lt;/code&gt; として表すことができない &lt;code&gt;i64&lt;/code&gt; 、およびそれを計算しようとすると、オーバーフローが発生します。これは、デバッグモードのコードがこの場合にパニックを引き起こし、最適化されたコードがパニックなしで &lt;code&gt;i64::MIN&lt;/code&gt; を返すことを意味します。</target>
        </trans-unit>
        <trans-unit id="4c50c4d71fa72eabc1e0818c0a858ae1903c1c3c" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i64::min_value()&lt;/code&gt; cannot be represented as an &lt;code&gt;i64&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i64::min_value()&lt;/code&gt; without a panic.</source>
          <target state="translated">絶対値 &lt;code&gt;i64::min_value()&lt;/code&gt; のように表すことができない &lt;code&gt;i64&lt;/code&gt; 、及びそれを計算しようとすると、オーバーフローが発生します。つまり、デバッグモードのコードはこの場合パニックをトリガーし、最適化されたコードはパニックなしで &lt;code&gt;i64::min_value()&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="94540f2ba32a8d4e2123f1b683b0ff15f6511fa8" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i8::MIN&lt;/code&gt; cannot be represented as an &lt;code&gt;i8&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i8::MIN&lt;/code&gt; without a panic.</source>
          <target state="translated">絶対値 &lt;code&gt;i8::MIN&lt;/code&gt; として表すことができない &lt;code&gt;i8&lt;/code&gt; 、それを計算しようとすると、オーバーフローが発生します。これは、デバッグモードのコードがこの場合にパニックを引き起こし、最適化されたコードがパニックなしで &lt;code&gt;i8::MIN&lt;/code&gt; を返すことを意味します。</target>
        </trans-unit>
        <trans-unit id="5adbbbaac9cedf98e39759b8920bdb3431d04107" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i8::min_value()&lt;/code&gt; cannot be represented as an &lt;code&gt;i8&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i8::min_value()&lt;/code&gt; without a panic.</source>
          <target state="translated">絶対値 &lt;code&gt;i8::min_value()&lt;/code&gt; のように表すことができない &lt;code&gt;i8&lt;/code&gt; 、及びそれを計算しようとすると、オーバーフローが発生します。つまり、デバッグモードのコードはこの場合パニックをトリガーし、最適化されたコードはパニックなしで &lt;code&gt;i8::min_value()&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="f3616827787c274826d0feb8bc695ca0f90e8398" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;isize::MIN&lt;/code&gt; cannot be represented as an &lt;code&gt;isize&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;isize::MIN&lt;/code&gt; without a panic.</source>
          <target state="translated">絶対値 &lt;code&gt;isize::MIN&lt;/code&gt; として表すことができない &lt;code&gt;isize&lt;/code&gt; 、それを計算しようとすると、オーバーフローが発生します。これは、デバッグモードのコードがこの場合にパニックを引き起こし、最適化されたコードがパニックなしで &lt;code&gt;isize::MIN&lt;/code&gt; を返すことを意味します。</target>
        </trans-unit>
        <trans-unit id="5fa62dd0a50bd4c5554cb57272ae5164c2e1f601" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;isize::min_value()&lt;/code&gt; cannot be represented as an &lt;code&gt;isize&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;isize::min_value()&lt;/code&gt; without a panic.</source>
          <target state="translated">絶対値 &lt;code&gt;isize::min_value()&lt;/code&gt; のように表すことができない &lt;code&gt;isize&lt;/code&gt; 、及びそれを計算しようとすると、オーバーフローが発生します。つまり、デバッグモードのコードはこの場合パニックをトリガーし、最適化されたコードはパニックなしで &lt;code&gt;isize::min_value()&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="409fd764bcabc3595ffe004849ff8f4e30564756" translate="yes" xml:space="preserve">
          <source>The actual desugaring is more complex:</source>
          <target state="translated">実際の脱穀はもっと複雑です。</target>
        </trans-unit>
        <trans-unit id="88133b615f1381b0a02c487a3edbc253bc8ee09f" translate="yes" xml:space="preserve">
          <source>The actual stack size may be greater than this value if the platform specifies a minimal stack size.</source>
          <target state="translated">プラットフォームが最小スタックサイズを指定している場合、実際のスタックサイズはこの値よりも大きくなる可能性があります。</target>
        </trans-unit>
        <trans-unit id="e09eb4195a6425d3d0a7b968cb406d8968af9926" translate="yes" xml:space="preserve">
          <source>The addition assignment operator &lt;code&gt;+=&lt;/code&gt;.</source>
          <target state="translated">加算代入演算子 &lt;code&gt;+=&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="097ca9dd7ade97007d85b522a25e6d04cefa5c67" translate="yes" xml:space="preserve">
          <source>The addition operator &lt;code&gt;+&lt;/code&gt;.</source>
          <target state="translated">加算演算子 &lt;code&gt;+&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="161b60a028315218a44d6ebb4a0a56ea64addb73" translate="yes" xml:space="preserve">
          <source>The address of temporary value was taken.</source>
          <target state="translated">一時値のアドレスが取られていました。</target>
        </trans-unit>
        <trans-unit id="67b3b3b11425c46c946b0ed067dfaec63ac739cb" translate="yes" xml:space="preserve">
          <source>The address type can be any implementor of &lt;a href=&quot;trait.tosocketaddrs&quot;&gt;&lt;code&gt;ToSocketAddrs&lt;/code&gt;&lt;/a&gt; trait. See its documentation for concrete examples.</source>
          <target state="translated">アドレスタイプは、&lt;a href=&quot;trait.tosocketaddrs&quot;&gt; &lt;code&gt;ToSocketAddrs&lt;/code&gt; &lt;/a&gt;トレイトの任意の実装者にすることができます。具体的な例については、そのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="554a0871d5bd274c4e9a4646e480108243a7e12e" translate="yes" xml:space="preserve">
          <source>The advantage of checking the borrowing rules at runtime instead is that certain memory-safe scenarios are then allowed, whereas they are disallowed by the compile-time checks. Static analysis, like the Rust compiler, is inherently conservative. Some properties of code are impossible to detect by analyzing the code: the most famous example is the Halting Problem, which is beyond the scope of this book but is an interesting topic to research.</source>
          <target state="translated">実行時に借用ルールをチェックすることの利点は、コンパイル時のチェックでは禁止されているのに対し、特定のメモリセーフなシナリオが許可されることです。スタティック解析は、Rust コンパイラのように、本質的に保守的です。コードの特性の中には、コードを解析しても検出できないものもあります。最も有名な例としては、ハルティング問題があります。</target>
        </trans-unit>
        <trans-unit id="cf97cfec24f32bdc09751ee8bbb19e7117656381" translate="yes" xml:space="preserve">
          <source>The advantage of using trait objects and Rust&amp;rsquo;s type system to write code similar to code using duck typing is that we never have to check whether a value implements a particular method at runtime or worry about getting errors if a value doesn&amp;rsquo;t implement a method but we call it anyway. Rust won&amp;rsquo;t compile our code if the values don&amp;rsquo;t implement the traits that the trait objects need.</source>
          <target state="translated">特性オブジェクトとRustの型システムを使用して、ダックタイピングを使用するコードと同様のコードを作成する利点は、値が実行時に特定のメソッドを実装するかどうかを確認したり、値がメソッドを実装していない場合にエラーが発生することを心配したりする必要がないことです。とにかくそれを呼び出します。特性オブジェクトが必要とする特性を値が実装していない場合、Rustはコードをコンパイルしません。</target>
        </trans-unit>
        <trans-unit id="1f36aabbacdf9ecb5c08c91a08fabb8510a201b8" translate="yes" xml:space="preserve">
          <source>The advantages of checking the borrowing rules at compile time are that errors will be caught sooner in the development process, and there is no impact on runtime performance because all the analysis is completed beforehand. For those reasons, checking the borrowing rules at compile time is the best choice in the majority of cases, which is why this is Rust&amp;rsquo;s default.</source>
          <target state="translated">コンパイル時に借用ルールを確認することの利点は、開発プロセスでエラーがより早く検出され、すべての分析が事前に完了しているため、実行時のパフォーマンスに影響を与えないことです。これらの理由により、大部分の場合、コンパイル時に借用ルールをチェックするのが最良の選択です。これがRustのデフォルトである理由です。</target>
        </trans-unit>
        <trans-unit id="802cd88adc867c6ed95af7c7632a5b9312da114b" translate="yes" xml:space="preserve">
          <source>The alignment is specified as an integer parameter in the form of &lt;code&gt;#[repr(align(x))]&lt;/code&gt; or &lt;code&gt;#[repr(packed(x))]&lt;/code&gt;. The alignment value must be a power of two from 1 up to 2&lt;sup&gt;29&lt;/sup&gt;. For &lt;code&gt;packed&lt;/code&gt;, if no value is given, as in &lt;code&gt;#[repr(packed)]&lt;/code&gt;, then the value is 1.</source>
          <target state="translated">位置合わせは、 &lt;code&gt;#[repr(align(x))]&lt;/code&gt; または &lt;code&gt;#[repr(packed(x))]&lt;/code&gt; の形式の整数パラメーターとして指定されます。アライメント値は、1から2 &lt;sup&gt;29&lt;/sup&gt;までの2のべき乗でなければなりません。以下のために &lt;code&gt;packed&lt;/code&gt; 、値が指定されていない場合、のよう &lt;code&gt;#[repr(packed)]&lt;/code&gt; 、値は1です。</target>
        </trans-unit>
        <trans-unit id="4210b5f1c3a4d7626a8282b8b0091e3127367f26" translate="yes" xml:space="preserve">
          <source>The alignment may be raised or lowered with the &lt;code&gt;align&lt;/code&gt; and &lt;code&gt;packed&lt;/code&gt; modifiers respectively. They alter the representation specified in the attribute. If no representation is specified, the default one is altered.</source>
          <target state="translated">配置は、 &lt;code&gt;align&lt;/code&gt; 修飾子と &lt;code&gt;packed&lt;/code&gt; 修飾子でそれぞれ上げたり下げたりできます。属性で指定された表現を変更します。表現が指定されていない場合、デフォルトの表現が変更されます。</target>
        </trans-unit>
        <trans-unit id="0bbd4814e74e1731ea096a3e29eb0e49a6112a9b" translate="yes" xml:space="preserve">
          <source>The alignment modifiers</source>
          <target state="translated">アライメント修飾子</target>
        </trans-unit>
        <trans-unit id="9a801ec59d9d78b1342286bf3c47cdf72d8754c9" translate="yes" xml:space="preserve">
          <source>The alignment of a value specifies what addresses values are preferred to start at. Always a power of two. References to a value must be aligned. &lt;a href=&quot;type-layout#size-and-alignment&quot;&gt;More&lt;/a&gt;.</source>
          <target state="translated">値の配置は、どのアドレス値から始めるのが好ましいかを指定します。常に2の累乗です。値への参照は整列させる必要があります。&lt;a href=&quot;type-layout#size-and-alignment&quot;&gt;もっと&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d7d8131883a9466d9495401638572f0f7002cb80" translate="yes" xml:space="preserve">
          <source>The alignment of the struct is the alignment of the most-aligned field in it.</source>
          <target state="translated">構造体のアラインメントは、その構造体の中で最もアラインメントの高いフィールドのアラインメントです。</target>
        </trans-unit>
        <trans-unit id="cb2d786ce814f96269971824a7ca8c85b85a4a91" translate="yes" xml:space="preserve">
          <source>The allocated block of memory may or may not be initialized.</source>
          <target state="translated">メモリの割り当てられたブロックは、初期化されていても、されていなくてもよい。</target>
        </trans-unit>
        <trans-unit id="a853460caf9660ad50bba38269de71834329efaf" translate="yes" xml:space="preserve">
          <source>The allocation error hook is a global resource.</source>
          <target state="translated">割り当てエラーフックはグローバルリソースです。</target>
        </trans-unit>
        <trans-unit id="dd622480c0a0d020ad0c83e155629929c531f8bd" translate="yes" xml:space="preserve">
          <source>The allocation error hook is invoked when an infallible memory allocation fails, before the runtime aborts. The default hook prints a message to standard error, but this behavior can be customized with the &lt;a href=&quot;fn.set_alloc_error_hook&quot;&gt;&lt;code&gt;set_alloc_error_hook&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fn.take_alloc_error_hook&quot;&gt;&lt;code&gt;take_alloc_error_hook&lt;/code&gt;&lt;/a&gt; functions.</source>
          <target state="translated">割り当てエラーフックは、ランタイムが中止される前に、確実なメモリ割り当てが失敗したときに呼び出されます。デフォルトのフックはメッセージを標準エラーに出力しますが、この動作は&lt;a href=&quot;fn.set_alloc_error_hook&quot;&gt; &lt;code&gt;set_alloc_error_hook&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;fn.take_alloc_error_hook&quot;&gt; &lt;code&gt;take_alloc_error_hook&lt;/code&gt; &lt;/a&gt;関数でカスタマイズできます。</target>
        </trans-unit>
        <trans-unit id="460b0be997a504bd93f9a5f2102be17a4fe4f237" translate="yes" xml:space="preserve">
          <source>The alternate flag, &lt;code&gt;#&lt;/code&gt;, adds a &lt;code&gt;0b&lt;/code&gt; in front of the output.</source>
          <target state="translated">代替フラグ &lt;code&gt;#&lt;/code&gt; は、出力の前に &lt;code&gt;0b&lt;/code&gt; を追加します。</target>
        </trans-unit>
        <trans-unit id="b053ed1e6052a16bbf0f4a89d40e16ee9bf6a88d" translate="yes" xml:space="preserve">
          <source>The alternate flag, &lt;code&gt;#&lt;/code&gt;, adds a &lt;code&gt;0o&lt;/code&gt; in front of the output.</source>
          <target state="translated">代替フラグ &lt;code&gt;#&lt;/code&gt; は、出力の前に &lt;code&gt;0o&lt;/code&gt; を追加します。</target>
        </trans-unit>
        <trans-unit id="1a67677d2b4895bdc1fb6847161bf39c61cb99f4" translate="yes" xml:space="preserve">
          <source>The alternate flag, &lt;code&gt;#&lt;/code&gt;, adds a &lt;code&gt;0x&lt;/code&gt; in front of the output.</source>
          <target state="translated">代替フラグ &lt;code&gt;#&lt;/code&gt; は、出力の前に &lt;code&gt;0x&lt;/code&gt; を追加します。</target>
        </trans-unit>
        <trans-unit id="11ba8acfe40883baf3a25418d4023d5eeae6eb43" translate="yes" xml:space="preserve">
          <source>The answer to this problem is the &lt;em&gt;Cargo.lock&lt;/em&gt; file, which was created the first time you ran &lt;code&gt;cargo build&lt;/code&gt; and is now in your &lt;em&gt;guessing_game&lt;/em&gt; directory. When you build a project for the first time, Cargo figures out all the versions of the dependencies that fit the criteria and then writes them to the &lt;em&gt;Cargo.lock&lt;/em&gt; file. When you build your project in the future, Cargo will see that the &lt;em&gt;Cargo.lock&lt;/em&gt; file exists and use the versions specified there rather than doing all the work of figuring out versions again. This lets you have a reproducible build automatically. In other words, your project will remain at &lt;code&gt;0.3.14&lt;/code&gt; until you explicitly upgrade, thanks to the &lt;em&gt;Cargo.lock&lt;/em&gt; file.</source>
          <target state="translated">この問題に対する答えは、&lt;em&gt;Cargo.lock&lt;/em&gt;ファイルです。これは、初めて &lt;code&gt;cargo build&lt;/code&gt; を実行したときに作成され、現在は&lt;em&gt;guessing_game&lt;/em&gt;ディレクトリにあります。プロジェクトを初めてビルドするとき、Cargoは基準に適合する依存関係のすべてのバージョンを&lt;em&gt;計算&lt;/em&gt;し、それらを&lt;em&gt;Cargo.lock&lt;/em&gt;ファイルに書き込みます。将来プロジェクトをビルドするとき、Cargoは&lt;em&gt;Cargo.lock&lt;/em&gt;ファイルが存在することを確認し、バージョンを特定する作業をすべて行うのではなく、そこで指定されたバージョンを使用します。これにより、再現可能なビルドを自動的に作成できます。つまり、&lt;em&gt;Cargo.lockの&lt;/em&gt;おかげで、明示的にアップグレードするまで、プロジェクトは &lt;code&gt;0.3.14&lt;/code&gt; のままになります。&lt;em&gt;&lt;/em&gt; ファイル。</target>
        </trans-unit>
        <trans-unit id="8fb95ccc8cbb2b44a80d4d0a731ecb5bea70e713" translate="yes" xml:space="preserve">
          <source>The answer to this problem is the &lt;em&gt;Cargo.lock&lt;/em&gt; file, which was created the first time you ran &lt;code&gt;cargo build&lt;/code&gt; and is now in your &lt;em&gt;guessing_game&lt;/em&gt; directory. When you build a project for the first time, Cargo figures out all the versions of the dependencies that fit the criteria and then writes them to the &lt;em&gt;Cargo.lock&lt;/em&gt; file. When you build your project in the future, Cargo will see that the &lt;em&gt;Cargo.lock&lt;/em&gt; file exists and use the versions specified there rather than doing all the work of figuring out versions again. This lets you have a reproducible build automatically. In other words, your project will remain at &lt;code&gt;0.5.5&lt;/code&gt; until you explicitly upgrade, thanks to the &lt;em&gt;Cargo.lock&lt;/em&gt; file.</source>
          <target state="translated">この問題への答えは&lt;em&gt;Cargo.lockの&lt;/em&gt;あなたが走った初めて作成されたファイル、 &lt;code&gt;cargo build&lt;/code&gt; し、あなたに今ある&lt;em&gt;guessing_gameの&lt;/em&gt;ディレクトリ。初めてプロジェクトをビルドするとき、Cargoは基準に一致する依存関係のすべてのバージョンを&lt;em&gt;把握&lt;/em&gt;し、それらを&lt;em&gt;Cargo.lock&lt;/em&gt;ファイルに書き込みます。将来プロジェクトをビルドするとき、Cargoは&lt;em&gt;Cargo.lock&lt;/em&gt;ファイルが存在することを確認し、バージョンを再把握するすべての作業を行うのではなく、そこで指定されたバージョンを使用します。これにより、再現可能なビルドを自動的に作成できます。言い換えれば、あなたのプロジェクトがのままになります &lt;code&gt;0.5.5&lt;/code&gt; 、明示的にアップグレードするまでのおかげ&lt;em&gt;Cargo.lockを&lt;/em&gt; ファイル。</target>
        </trans-unit>
        <trans-unit id="c50839f5b75ebf2449202c65bd78e83e2a04633c" translate="yes" xml:space="preserve">
          <source>The argument order should be changed to match the parameter declaration order, as in the following:</source>
          <target state="translated">引数の順番は、以下のようにパラメータの宣言順に合わせて変更する必要があります。</target>
        </trans-unit>
        <trans-unit id="ff3b9111423732cd0796ed3af4340d1aeaddff87" translate="yes" xml:space="preserve">
          <source>The argument to the &lt;code&gt;llvm_asm&lt;/code&gt; macro is not well-formed.</source>
          <target state="translated">&lt;code&gt;llvm_asm&lt;/code&gt; マクロへの引数は整形式ではありません。</target>
        </trans-unit>
        <trans-unit id="0d5e37bb48121061d7a9d1253e50cf299206b8ed" translate="yes" xml:space="preserve">
          <source>The argument, &lt;code&gt;mid&lt;/code&gt;, should be a byte offset from the start of the string. It must also be on the boundary of a UTF-8 code point.</source>
          <target state="translated">引数 &lt;code&gt;mid&lt;/code&gt; は、文字列の先頭からのバイトオフセットでなければなりません。また、UTF-8コードポイントの境界上にある必要があります。</target>
        </trans-unit>
        <trans-unit id="843c167795952476fd4949d773d09e67f37bae5c" translate="yes" xml:space="preserve">
          <source>The arguments will be formatted according to the specified format string into the output stream provided.</source>
          <target state="translated">引数は、指定されたフォーマット文字列に従って、指定された出力ストリームにフォーマットされます。</target>
        </trans-unit>
        <trans-unit id="47d8ae2e6d2ad4b4b9256e9f4136431f5f0ee17f" translate="yes" xml:space="preserve">
          <source>The array index expression can be implemented for types other than arrays and slices by implementing the &lt;a href=&quot;../../std/ops/trait.index&quot;&gt;Index&lt;/a&gt; and &lt;a href=&quot;../../std/ops/trait.indexmut&quot;&gt;IndexMut&lt;/a&gt; traits.</source>
          <target state="translated">配列のインデックス式は、&lt;a href=&quot;../../std/ops/trait.index&quot;&gt;Index&lt;/a&gt;と&lt;a href=&quot;../../std/ops/trait.indexmut&quot;&gt;IndexMut&lt;/a&gt;トレイトを実装することで、配列とスライス以外のタイプに実装できます。</target>
        </trans-unit>
        <trans-unit id="43b42b264d53f00eb4d50d966bdebfe503d9e502" translate="yes" xml:space="preserve">
          <source>The array named &lt;code&gt;a&lt;/code&gt; will contain &lt;code&gt;5&lt;/code&gt; elements that will all be set to the value &lt;code&gt;3&lt;/code&gt; initially. This is the same as writing &lt;code&gt;let a = [3, 3, 3, 3, 3];&lt;/code&gt; but in a more concise way.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; という名前の配列には、最初はすべて値 &lt;code&gt;3&lt;/code&gt; に設定される &lt;code&gt;5&lt;/code&gt; つの要素が含まれます。これは &lt;code&gt;let a = [3, 3, 3, 3, 3];&lt;/code&gt; と同じです。しかし、より簡潔な方法で。</target>
        </trans-unit>
        <trans-unit id="bda6f38466d2f9f90243514e2e1d1d622e872f82" translate="yes" xml:space="preserve">
          <source>The associated error which can be returned from parsing.</source>
          <target state="translated">解析から返される関連するエラー。</target>
        </trans-unit>
        <trans-unit id="264397f1a1d81bc0bfb862d1058ae5d080545332" translate="yes" xml:space="preserve">
          <source>The associated type used was not defined in the trait.</source>
          <target state="translated">使用されている関連する型が形質で定義されていませんでした。</target>
        </trans-unit>
        <trans-unit id="95b071fe52a22a379b9072dba9b8116f1e91d5e0" translate="yes" xml:space="preserve">
          <source>The assumed lifetime of references held by a &lt;a href=&quot;types/trait-object&quot;&gt;trait object&lt;/a&gt; is called its &lt;em&gt;default object lifetime bound&lt;/em&gt;. These were defined in &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0599-default-object-bound.md&quot;&gt;RFC 599&lt;/a&gt; and amended in &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md&quot;&gt;RFC 1156&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;types/trait-object&quot;&gt;特性オブジェクト&lt;/a&gt;によって保持される参照の想定される存続期間は、その&lt;em&gt;デフォルトのオブジェクト存続期間限界&lt;/em&gt;と呼ばれ&lt;em&gt;ます&lt;/em&gt;。これらは&lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0599-default-object-bound.md&quot;&gt;RFC 599で&lt;/a&gt;定義され、&lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md&quot;&gt;RFC 1156で&lt;/a&gt;修正されました。</target>
        </trans-unit>
        <trans-unit id="4a633a670846190d4e317682018f539e771650d4" translate="yes" xml:space="preserve">
          <source>The atomic intrinsics provide common atomic operations on machine words, with multiple possible memory orderings. They obey the same semantics as C++11. See the LLVM documentation on [&lt;a href=&quot;http://llvm.org/docs/Atomics.html&quot;&gt;atomics&lt;/a&gt;].</source>
          <target state="translated">アトミック組み込み関数は、複数の可能なメモリ順序で、マシンワードに対する一般的なアトミック操作を提供します。C ++ 11と同じセマンティクスに従います。[ &lt;a href=&quot;http://llvm.org/docs/Atomics.html&quot;&gt;atomics&lt;/a&gt; ] に関するLLVMのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="fbb3647b73aa531d0036519ea5d455e06c908ef1" translate="yes" xml:space="preserve">
          <source>The atomic intrinsics provide common atomic operations on machine words, with multiple possible memory orderings. They obey the same semantics as C++11. See the LLVM documentation on [&lt;a href=&quot;https://llvm.org/docs/Atomics.html&quot;&gt;atomics&lt;/a&gt;].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eacfc8c255cb1ef132a6a65b58c2019ebea9baf" translate="yes" xml:space="preserve">
          <source>The atomic types in this module may not be available on all platforms. The atomic types here are all widely available, however, and can generally be relied upon existing. Some notable exceptions are:</source>
          <target state="translated">このモジュールの原子型は、すべてのプラットフォームで利用できるわけではありません。しかし、ここで紹介する原子型はすべて広く利用可能であり、一般的には既存のものに頼ることができます。いくつかの顕著な例外があります。</target>
        </trans-unit>
        <trans-unit id="71cc0f45759d249e1ba21744ede7b9ef7445260e" translate="yes" xml:space="preserve">
          <source>The attribute consists of a path to the attribute, followed by an optional delimited token tree whose interpretation is defined by the attribute. Attributes other than macro attributes also allow the input to be an equals sign (&lt;code&gt;=&lt;/code&gt;) followed by a literal expression. See the &lt;a href=&quot;#meta-item-attribute-syntax&quot;&gt;meta item syntax&lt;/a&gt; below for more details.</source>
          <target state="translated">属性は、属性へのパスと、それに続く、属性によって解釈が定義されるオプションの区切られたトークンツリーで構成されます。マクロ属性以外の属性でも、入力を等号（ &lt;code&gt;=&lt;/code&gt; ）の後にリテラル式にすることができます。詳細については、以下の&lt;a href=&quot;#meta-item-attribute-syntax&quot;&gt;メタアイテム構文を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="c5f89ad9ce66636388cf7509f930392e52eeb867" translate="yes" xml:space="preserve">
          <source>The attribute consists of a path to the attribute, followed by an optional delimited token tree whose interpretation is defined by the attribute. Attributes other than macro attributes also allow the input to be an equals sign (&lt;code&gt;=&lt;/code&gt;) followed by a literal expression. See the &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;meta item syntax&lt;/a&gt; below for more details.</source>
          <target state="translated">属性は、属性へのパスと、その後に続く属性で定義されたオプションの区切りトークンツリーで構成されます。マクロ属性以外の属性でも、入力は等号（ &lt;code&gt;=&lt;/code&gt; ）の後にリテラル式を続けることができます。詳細については、以下の&lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;メタアイテムの構文を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="b79be106b3314bbccaaacf6171952db704c5419b" translate="yes" xml:space="preserve">
          <source>The attribute is used on a &lt;code&gt;static&lt;/code&gt; item whose type implements the &lt;a href=&quot;https://doc.rust-lang.org/core/alloc/trait.GlobalAlloc.html&quot;&gt;&lt;code&gt;GlobalAlloc&lt;/code&gt;&lt;/a&gt; trait. This type can be provided by an external library:</source>
          <target state="translated">この属性は、タイプが&lt;a href=&quot;https://doc.rust-lang.org/core/alloc/trait.GlobalAlloc.html&quot;&gt; &lt;code&gt;GlobalAlloc&lt;/code&gt; &lt;/a&gt;特性を実装する &lt;code&gt;static&lt;/code&gt; アイテムで使用されます。このタイプは、外部ライブラリによって提供できます。</target>
        </trans-unit>
        <trans-unit id="638938ad1b96ca367b1ad29ad316e67748e69b45" translate="yes" xml:space="preserve">
          <source>The attribute is used on a &lt;code&gt;static&lt;/code&gt; item whose type implements the &lt;a href=&quot;trait.globalalloc&quot;&gt;&lt;code&gt;GlobalAlloc&lt;/code&gt;&lt;/a&gt; trait. This type can be provided by an external library:</source>
          <target state="translated">この属性は、タイプが&lt;a href=&quot;trait.globalalloc&quot;&gt; &lt;code&gt;GlobalAlloc&lt;/code&gt; &lt;/a&gt;トレイトを実装する &lt;code&gt;static&lt;/code&gt; アイテムで使用されます。このタイプは、外部ライブラリによって提供できます。</target>
        </trans-unit>
        <trans-unit id="07001b94d9ec08710a57474a9ab6a5a7c57ed031" translate="yes" xml:space="preserve">
          <source>The attributes that have meaning on a block expression are &lt;a href=&quot;../conditional-compilation&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;the lint check attributes&lt;/a&gt;.</source>
          <target state="translated">ブロック式で意味を持つ属性は、&lt;a href=&quot;../conditional-compilation&quot;&gt; &lt;code&gt;cfg&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;lintチェック属性です&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="db84623389bc5fe968094b478ac6446a9f7cd32b" translate="yes" xml:space="preserve">
          <source>The attributes that have meaning on a function are &lt;a href=&quot;../conditional-compilation&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt;&lt;code&gt;deprecated&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt;&lt;code&gt;doc&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../abi#the-export_name-attribute&quot;&gt;&lt;code&gt;export_name&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../abi#the-link_section-attribute&quot;&gt;&lt;code&gt;link_section&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../abi#the-no_mangle-attribute&quot;&gt;&lt;code&gt;no_mangle&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;the lint check attributes&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#the-must_use-attribute&quot;&gt;&lt;code&gt;must_use&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../procedural-macros&quot;&gt;the procedural macro attributes&lt;/a&gt;, &lt;a href=&quot;../attributes/testing&quot;&gt;the testing attributes&lt;/a&gt;, and &lt;a href=&quot;../attributes/codegen#optimization-hints&quot;&gt;the optimization hint attributes&lt;/a&gt;. Functions also accept attributes macros.</source>
          <target state="translated">関数で意味を持つ属性は、&lt;a href=&quot;../conditional-compilation&quot;&gt; &lt;code&gt;cfg&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt; &lt;code&gt;deprecated&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt; &lt;code&gt;doc&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../abi#the-export_name-attribute&quot;&gt; &lt;code&gt;export_name&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../abi#the-link_section-attribute&quot;&gt; &lt;code&gt;link_section&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../abi#the-no_mangle-attribute&quot;&gt; &lt;code&gt;no_mangle&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;lintチェック属性&lt;/a&gt;、&lt;a href=&quot;../attributes/diagnostics#the-must_use-attribute&quot;&gt; &lt;code&gt;must_use&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../procedural-macros&quot;&gt;手続き型マクロ属性&lt;/a&gt;、&lt;a href=&quot;../attributes/testing&quot;&gt;テスト属性&lt;/a&gt;、および&lt;a href=&quot;../attributes/codegen#optimization-hints&quot;&gt;最適化ヒント属性です&lt;/a&gt;。関数は属性マクロも受け入れます。</target>
        </trans-unit>
        <trans-unit id="622c3bad6ebce7dda9ab10b347056427bd42a746" translate="yes" xml:space="preserve">
          <source>The attributes that have meaning on a function are &lt;a href=&quot;../conditional-compilation#the-cfg-attribute&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../conditional-compilation#the-cfg_attr-attribute&quot;&gt;&lt;code&gt;cfg_attr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt;&lt;code&gt;deprecated&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt;&lt;code&gt;doc&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../abi#the-export_name-attribute&quot;&gt;&lt;code&gt;export_name&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../abi#the-link_section-attribute&quot;&gt;&lt;code&gt;link_section&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../abi#the-no_mangle-attribute&quot;&gt;&lt;code&gt;no_mangle&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;the lint check attributes&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#the-must_use-attribute&quot;&gt;&lt;code&gt;must_use&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../procedural-macros&quot;&gt;the procedural macro attributes&lt;/a&gt;, &lt;a href=&quot;../attributes/testing&quot;&gt;the testing attributes&lt;/a&gt;, and &lt;a href=&quot;../attributes/codegen#optimization-hints&quot;&gt;the optimization hint attributes&lt;/a&gt;. Functions also accept attributes macros.</source>
          <target state="translated">関数で意味を持つ属性は、&lt;a href=&quot;../conditional-compilation#the-cfg-attribute&quot;&gt; &lt;code&gt;cfg&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../conditional-compilation#the-cfg_attr-attribute&quot;&gt; &lt;code&gt;cfg_attr&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt; &lt;code&gt;deprecated&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt; &lt;code&gt;doc&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../abi#the-export_name-attribute&quot;&gt; &lt;code&gt;export_name&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../abi#the-link_section-attribute&quot;&gt; &lt;code&gt;link_section&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../abi#the-no_mangle-attribute&quot;&gt; &lt;code&gt;no_mangle&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;lint check属性&lt;/a&gt;、&lt;a href=&quot;../attributes/diagnostics#the-must_use-attribute&quot;&gt; &lt;code&gt;must_use&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../procedural-macros&quot;&gt;手続き型マクロ属性&lt;/a&gt;、&lt;a href=&quot;../attributes/testing&quot;&gt;テスト属性&lt;/a&gt;、および&lt;a href=&quot;../attributes/codegen#optimization-hints&quot;&gt;最適化ヒント属性です&lt;/a&gt;。関数は属性マクロも受け入れます。</target>
        </trans-unit>
        <trans-unit id="a9286c2061446f78d1eb0dacb8ad2bed2198b3a3" translate="yes" xml:space="preserve">
          <source>The author of the code in Listing 14-4, which uses the &lt;code&gt;art&lt;/code&gt; crate, had to figure out that &lt;code&gt;PrimaryColor&lt;/code&gt; is in the &lt;code&gt;kinds&lt;/code&gt; module and &lt;code&gt;mix&lt;/code&gt; is in the &lt;code&gt;utils&lt;/code&gt; module. The module structure of the &lt;code&gt;art&lt;/code&gt; crate is more relevant to developers working on the &lt;code&gt;art&lt;/code&gt; crate than to developers using the &lt;code&gt;art&lt;/code&gt; crate. The internal structure that organizes parts of the crate into the &lt;code&gt;kinds&lt;/code&gt; module and the &lt;code&gt;utils&lt;/code&gt; module doesn&amp;rsquo;t contain any useful information for someone trying to understand how to use the &lt;code&gt;art&lt;/code&gt; crate. Instead, the &lt;code&gt;art&lt;/code&gt; crate&amp;rsquo;s module structure causes confusion because developers have to figure out where to look, and the structure is inconvenient because developers must specify the module names in the &lt;code&gt;use&lt;/code&gt; statements.</source>
          <target state="translated">使用して、リスト14-4のコードの作者 &lt;code&gt;art&lt;/code&gt; クレートは、ということを理解しなければならなかった &lt;code&gt;PrimaryColor&lt;/code&gt; である &lt;code&gt;kinds&lt;/code&gt; モジュールと &lt;code&gt;mix&lt;/code&gt; している &lt;code&gt;utils&lt;/code&gt; モジュール。モジュール構造 &lt;code&gt;art&lt;/code&gt; クレートは、に取り組んで開発者により関連性のある &lt;code&gt;art&lt;/code&gt; よりも使用して開発者にクレート &lt;code&gt;art&lt;/code&gt; クレートを。クレートの部分を整理した内部構造 &lt;code&gt;kinds&lt;/code&gt; モジュールと &lt;code&gt;utils&lt;/code&gt; モジュールを使用する方法を理解しようとしている誰かのために有用な情報が含まれていない &lt;code&gt;art&lt;/code&gt; クレートを。代わりに、 &lt;code&gt;art&lt;/code&gt; クレートのモジュール構造は、開発者がどこを見なければならないかを理解する必要があるため混乱を引き起こし、開発者は &lt;code&gt;use&lt;/code&gt; ステートメントでモジュール名を指定する必要があるため、構造が不便です。</target>
        </trans-unit>
        <trans-unit id="d8ebf8e3de6c2376fc1a32c2614c0e8023f7f60e" translate="yes" xml:space="preserve">
          <source>The author of this code probably wants &lt;code&gt;collect()&lt;/code&gt; to return a &lt;code&gt;Result&amp;lt;Vec&amp;lt;bool&amp;gt;, ()&amp;gt;&lt;/code&gt;, but the compiler can't be sure that there isn't another type &lt;code&gt;T&lt;/code&gt; implementing both &lt;code&gt;Try&lt;/code&gt; and &lt;code&gt;FromIterator&amp;lt;Result&amp;lt;bool, ()&amp;gt;&amp;gt;&lt;/code&gt; in scope such that &lt;code&gt;T::Ok == Vec&amp;lt;bool&amp;gt;&lt;/code&gt;. Hence, this code is ambiguous and an error is returned.</source>
          <target state="translated">このコードの作成者は、おそらく &lt;code&gt;collect()&lt;/code&gt; が &lt;code&gt;Result&amp;lt;Vec&amp;lt;bool&amp;gt;, ()&amp;gt;&lt;/code&gt; を返すことを望んでいますが、コンパイラは、 &lt;code&gt;Try&lt;/code&gt; と &lt;code&gt;FromIterator&amp;lt;Result&amp;lt;bool, ()&amp;gt;&amp;gt;&lt;/code&gt; 両方を実装する別の型 &lt;code&gt;T&lt;/code&gt; がないことを確認できません。 （）&amp;gt;&amp;gt;スコープ内の &lt;code&gt;T::Ok == Vec&amp;lt;bool&amp;gt;&lt;/code&gt; 。したがって、このコードがあいまいであり、エラーが返されます。</target>
        </trans-unit>
        <trans-unit id="938569367b830c27a570a475e7cb23644f96b802" translate="yes" xml:space="preserve">
          <source>The author of this code probably wants &lt;code&gt;into()&lt;/code&gt; to return a &lt;code&gt;u64&lt;/code&gt;, but the compiler can't be sure that there isn't another type &lt;code&gt;T&lt;/code&gt; where both &lt;code&gt;u32: Into&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;u64: Add&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">このコードの作成者は、おそらく &lt;code&gt;into()&lt;/code&gt; が &lt;code&gt;u64&lt;/code&gt; を返すことを望んでいますが、コンパイラーは、 &lt;code&gt;u32: Into&amp;lt;T&amp;gt;&lt;/code&gt; と &lt;code&gt;u64: Add&amp;lt;T&amp;gt;&lt;/code&gt; 両方である別のタイプ &lt;code&gt;T&lt;/code&gt; がないことを確認できません。</target>
        </trans-unit>
        <trans-unit id="946c3c8468dffe1ee08b57091aa458b31b356f72" translate="yes" xml:space="preserve">
          <source>The automatically generated &quot;drop glue&quot; which recursively calls the destructors of the all fields of this value.</source>
          <target state="translated">この値の全フィールドのデストラクタを再帰的に呼び出す、自動的に生成された &quot;drop glue&quot;。</target>
        </trans-unit>
        <trans-unit id="442e142fa9a496c6c2ff3a02ee78aa50e228d6e4" translate="yes" xml:space="preserve">
          <source>The bad state is not something that&amp;rsquo;s &lt;em&gt;expected&lt;/em&gt; to happen occasionally.</source>
          <target state="translated">悪い状態は、たまに起こると&lt;em&gt;予想される&lt;/em&gt;ものではありません。</target>
        </trans-unit>
        <trans-unit id="1030d03bed1910f08091eb456180338b656dc0aa" translate="yes" xml:space="preserve">
          <source>The base of a &lt;a href=&quot;expressions/struct-expr#functional-update-syntax&quot;&gt;functional update&lt;/a&gt; struct expression.</source>
          <target state="translated">&lt;a href=&quot;expressions/struct-expr#functional-update-syntax&quot;&gt;機能更新&lt;/a&gt;構造体式のベース。</target>
        </trans-unit>
        <trans-unit id="1da424ed8fd790e722f71cc50f820022f89f696b" translate="yes" xml:space="preserve">
          <source>The behavior of the returned &lt;code&gt;Waker&lt;/code&gt; is undefined if the contract defined in &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt;'s and &lt;a href=&quot;struct.rawwakervtable&quot;&gt;&lt;code&gt;RawWakerVTable&lt;/code&gt;&lt;/a&gt;'s documentation is not upheld. Therefore this method is unsafe.</source>
          <target state="translated">&lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;struct.rawwakervtable&quot;&gt; &lt;code&gt;RawWakerVTable&lt;/code&gt; &lt;/a&gt;のドキュメントで定義されているコントラクトが守られていない場合、返される &lt;code&gt;Waker&lt;/code&gt; の動作は未定義です。したがって、この方法は安全ではありません。</target>
        </trans-unit>
        <trans-unit id="c7f5bfcda53c0f0ccac4fbf04091f03de55bc719" translate="yes" xml:space="preserve">
          <source>The behavior of this method must be independent of the state of the &lt;code&gt;Read&lt;/code&gt;er - the method only takes &lt;code&gt;&amp;amp;self&lt;/code&gt; so that it can be used through trait objects.</source>
          <target state="translated">このメソッドの動作は、 &lt;code&gt;Read&lt;/code&gt; erの状態とは無関係である必要があります。このメソッドは、特性オブジェクトを通じて使用できるように &lt;code&gt;&amp;amp;self&lt;/code&gt; のみを受け取ります。</target>
        </trans-unit>
        <trans-unit id="92a385c5078364ae9300fa907e25a19462c00810" translate="yes" xml:space="preserve">
          <source>The benefit of having this restriction is that Rust can prevent data races at compile time. A &lt;em&gt;data race&lt;/em&gt; is similar to a race condition and happens when these three behaviors occur:</source>
          <target state="translated">この制限があることの利点は、Rustがコンパイル時にデータ競合を防止できることです。&lt;em&gt;データレースは&lt;/em&gt;、レースの条件に似ており、これら三つの行動が発生したときに起こります。</target>
        </trans-unit>
        <trans-unit id="94345eda8bccf9faca124acc23e9dfc7f68245ec" translate="yes" xml:space="preserve">
          <source>The bits that define the access mode are masked out with &lt;code&gt;O_ACCMODE&lt;/code&gt;, to ensure they do not interfere with the access mode set by Rusts options.</source>
          <target state="translated">アクセスモードを定義するビットは &lt;code&gt;O_ACCMODE&lt;/code&gt; でマスクされ、Rustsオプションで設定されたアクセスモードと干渉しないようにします。</target>
        </trans-unit>
        <trans-unit id="eaa8e0a3053148a58d441c5d948ef0afd09016e9" translate="yes" xml:space="preserve">
          <source>The bitwise AND assignment operator &lt;code&gt;&amp;amp;=&lt;/code&gt;.</source>
          <target state="translated">ビットごとのAND代入演算子 &lt;code&gt;&amp;amp;=&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1dd8ef8a8d73fdf98095248d6c0b2047cb203cf0" translate="yes" xml:space="preserve">
          <source>The bitwise AND operator &lt;code&gt;&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">ビットごとのAND演算子 &lt;code&gt;&amp;amp;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2bfdab4f43dd337afc8fc0552897bf0d88f4fb0e" translate="yes" xml:space="preserve">
          <source>The bitwise OR assignment operator &lt;code&gt;|=&lt;/code&gt;.</source>
          <target state="translated">ビットごとのOR代入演算子 &lt;code&gt;|=&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a78ed80e19856e33ead5257328ef19e1b110eb08" translate="yes" xml:space="preserve">
          <source>The bitwise OR operator &lt;code&gt;|&lt;/code&gt;.</source>
          <target state="translated">ビットごとのOR演算子 &lt;code&gt;|&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eafeed4a6ad02f43abd1d07f62b4dea554b3a79c" translate="yes" xml:space="preserve">
          <source>The bitwise XOR assignment operator &lt;code&gt;^=&lt;/code&gt;.</source>
          <target state="translated">ビットごとのXOR代入演算子 &lt;code&gt;^=&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e805a1bbc089611af418b7bd9e638939dac553c5" translate="yes" xml:space="preserve">
          <source>The bitwise XOR operator &lt;code&gt;^&lt;/code&gt;.</source>
          <target state="translated">ビットごとのXOR演算子 &lt;code&gt;^&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c9231fb12ba981aafd28f24ac7946a833b22a70e" translate="yes" xml:space="preserve">
          <source>The block must be allocated with the same alignment as &lt;a href=&quot;struct.layout#method.align&quot;&gt;&lt;code&gt;layout.align()&lt;/code&gt;&lt;/a&gt;, and</source>
          <target state="translated">ブロックは、同じ配向で割り当てなければならない&lt;a href=&quot;struct.layout#method.align&quot;&gt; &lt;code&gt;layout.align()&lt;/code&gt; &lt;/a&gt;、及び</target>
        </trans-unit>
        <trans-unit id="423b8775203e06b0ca354c4f4e97825a7d00a713" translate="yes" xml:space="preserve">
          <source>The block of a function is conceptually wrapped in a block that binds the argument patterns and then &lt;code&gt;return&lt;/code&gt;s the value of the function's block. This means that the tail expression of the block, if evaluated, ends up being returned to the caller. As usual, an explicit return expression within the body of the function will short-cut that implicit return, if reached.</source>
          <target state="translated">関数のブロックは、概念的には引数パターンをバインドし、関数のブロックの値を &lt;code&gt;return&lt;/code&gt; ブロックにラップされています。つまり、ブロックの末尾の式は、評価された場合、最終的に呼び出し元に返されます。いつものように、関数の本体内の明示的なreturn式は、到達した場合、その暗黙の戻りをショートカットします。</target>
        </trans-unit>
        <trans-unit id="761ca0a326eb25085e5f1ebfbcef3b94f323b7c7" translate="yes" xml:space="preserve">
          <source>The block's size must fall in the range &lt;code&gt;[use_min, use_max]&lt;/code&gt;, where:</source>
          <target state="translated">ブロックのサイズは &lt;code&gt;[use_min, use_max]&lt;/code&gt; 範囲内でなければなりません。ここで、</target>
        </trans-unit>
        <trans-unit id="0d55dd5d42feb75840d81a2ee396cf125ff6a36f" translate="yes" xml:space="preserve">
          <source>The block's starting address must be aligned to &lt;code&gt;layout.align()&lt;/code&gt;.</source>
          <target state="translated">ブロックの開始アドレスは、 &lt;code&gt;layout.align()&lt;/code&gt; に揃える必要があります。</target>
        </trans-unit>
        <trans-unit id="6fb5efe10f486c51a18bce4f54350dd31c9d18ad" translate="yes" xml:space="preserve">
          <source>The bodies of the &lt;code&gt;if let&lt;/code&gt; and the &lt;code&gt;unwrap_or_else&lt;/code&gt; functions are the same in both cases: we print the error and exit.</source>
          <target state="translated">&lt;code&gt;if let&lt;/code&gt; 関数と &lt;code&gt;unwrap_or_else&lt;/code&gt; 関数の本体はどちらの場合も同じです。エラーを出力して終了します。</target>
        </trans-unit>
        <trans-unit id="a084bd821dcd5af3bead7d20966da99b85c8d3d6" translate="yes" xml:space="preserve">
          <source>The body of a &lt;a href=&quot;expressions/if-expr#if-expressions&quot;&gt;&lt;code&gt;if&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;expressions/loop-expr#predicate-loops&quot;&gt;&lt;code&gt;while&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;expressions/loop-expr#infinite-loops&quot;&gt;&lt;code&gt;loop&lt;/code&gt;&lt;/a&gt; expression.</source>
          <target state="translated">&lt;a href=&quot;expressions/if-expr#if-expressions&quot;&gt; &lt;code&gt;if&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;expressions/loop-expr#predicate-loops&quot;&gt; &lt;code&gt;while&lt;/code&gt; 、&lt;/a&gt;または&lt;a href=&quot;expressions/loop-expr#infinite-loops&quot;&gt; &lt;code&gt;loop&lt;/code&gt; &lt;/a&gt;式の本体。</target>
        </trans-unit>
        <trans-unit id="8d22837f9a0a24391528e1a0b3b2365c1d2579bc" translate="yes" xml:space="preserve">
          <source>The body of the function starts by calling the &lt;code&gt;File::open&lt;/code&gt; function. Then we handle the &lt;code&gt;Result&lt;/code&gt; value returned with a &lt;code&gt;match&lt;/code&gt; similar to the &lt;code&gt;match&lt;/code&gt; in Listing 9-4, only instead of calling &lt;code&gt;panic!&lt;/code&gt; in the &lt;code&gt;Err&lt;/code&gt; case, we return early from this function and pass the error value from &lt;code&gt;File::open&lt;/code&gt; back to the calling code as this function&amp;rsquo;s error value. If &lt;code&gt;File::open&lt;/code&gt; succeeds, we store the file handle in the variable &lt;code&gt;f&lt;/code&gt; and continue.</source>
          <target state="translated">関数の本体は、 &lt;code&gt;File::open&lt;/code&gt; 関数を呼び出すことから始まります。その後、我々はハンドル &lt;code&gt;Result&lt;/code&gt; で返された値 &lt;code&gt;match&lt;/code&gt; に似た &lt;code&gt;match&lt;/code&gt; のみの代わりに呼び出しのリスト9-4で、 &lt;code&gt;panic!&lt;/code&gt; &lt;code&gt;Err&lt;/code&gt; 場合、我々は早期にこの関数から戻ってからエラー値を渡す &lt;code&gt;File::open&lt;/code&gt; 呼び出し元のコードに戻って、この関数のエラー値として。 &lt;code&gt;File::open&lt;/code&gt; が成功した場合、ファイルハンドルを変数 &lt;code&gt;f&lt;/code&gt; に格納して続行します。</target>
        </trans-unit>
        <trans-unit id="9ba4d0e4523a23a56b57272682f48b03a790c657" translate="yes" xml:space="preserve">
          <source>The body of the method would use &lt;code&gt;self&lt;/code&gt; to get the value that we called the method on. In this example, we&amp;rsquo;ve created a variable &lt;code&gt;m&lt;/code&gt; that has the value &lt;code&gt;Message::Write(String::from(&quot;hello&quot;))&lt;/code&gt;, and that is what &lt;code&gt;self&lt;/code&gt; will be in the body of the &lt;code&gt;call&lt;/code&gt; method when &lt;code&gt;m.call()&lt;/code&gt; runs.</source>
          <target state="translated">メソッドの本体は &lt;code&gt;self&lt;/code&gt; を使用して、メソッドを呼び出した値を取得します。この例では、変数の作成した &lt;code&gt;m&lt;/code&gt; 値の持つ &lt;code&gt;Message::Write(String::from(&quot;hello&quot;))&lt;/code&gt; 、そしてそれは何である &lt;code&gt;self&lt;/code&gt; の身体になります &lt;code&gt;call&lt;/code&gt; たときに方法 &lt;code&gt;m.call()&lt;/code&gt; 実行します。</target>
        </trans-unit>
        <trans-unit id="9c00fd6128e2bdd1cc90bd415df84de85499f4fb" translate="yes" xml:space="preserve">
          <source>The book &lt;em&gt;Design Patterns: Elements of Reusable Object-Oriented Software&lt;/em&gt; by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides (Addison-Wesley Professional, 1994) colloquially referred to as &lt;em&gt;The Gang of Four&lt;/em&gt; book, is a catalog of object-oriented design patterns. It defines OOP this way:</source>
          <target state="translated">本の&lt;em&gt;デザインパターン：再利用可能なオブジェクト指向ソフトウェアの要素（&lt;/em&gt; Erich Gamma、Richard Helm、Ralph Johnson、およびJohn Vlissides（Addison-Wesley Professional、1994））は、通称&lt;em&gt;「ギャングオブフォー&lt;/em&gt;」と呼ばれ、オブジェクト指向のカタログです。デザインパターン。次のようにOOPを定義します。</target>
        </trans-unit>
        <trans-unit id="0ab81c05a8d6cbaec3e9dfb9c8caa2a16dab19bf" translate="yes" xml:space="preserve">
          <source>The boolean type.</source>
          <target state="translated">ブール型です。</target>
        </trans-unit>
        <trans-unit id="06283747a377154700dbba912c9e77d60011a87e" translate="yes" xml:space="preserve">
          <source>The borrow lasts until the returned &lt;code&gt;Ref&lt;/code&gt; exits scope. Multiple immutable borrows can be taken out at the same time.</source>
          <target state="translated">借用は、返された &lt;code&gt;Ref&lt;/code&gt; がスコープを出るまで続きます。複数の不変の借用を同時に取り出すことができます。</target>
        </trans-unit>
        <trans-unit id="45376451530857b96a10ec4a5e20bb51cfc0ed12" translate="yes" xml:space="preserve">
          <source>The borrow lasts until the returned &lt;code&gt;RefMut&lt;/code&gt; or all &lt;code&gt;RefMut&lt;/code&gt;s derived from it exit scope. The value cannot be borrowed while this borrow is active.</source>
          <target state="translated">借用は、返された &lt;code&gt;RefMut&lt;/code&gt; またはそれから派生したすべての &lt;code&gt;RefMut&lt;/code&gt; がスコープを出るまで続きます。この借用がアクティブな間、値を借用することはできません。</target>
        </trans-unit>
        <trans-unit id="f968733bf846dacfb002493e18e27a27864a5d95" translate="yes" xml:space="preserve">
          <source>The buffer is written out before returning the writer.</source>
          <target state="translated">ライターを返す前にバッファを書き出します。</target>
        </trans-unit>
        <trans-unit id="8d2f5c9c4df44bd26200b02c526dd9675a0b62ea" translate="yes" xml:space="preserve">
          <source>The buffer specified was 0 bytes in length.</source>
          <target state="translated">指定されたバッファの長さは0バイトでした。</target>
        </trans-unit>
        <trans-unit id="aac2e47b3535d051db39f7a14fa1dba18fc6a121" translate="yes" xml:space="preserve">
          <source>The built-in &lt;code&gt;cfg&lt;/code&gt; macro takes in a single configuration predicate and evaluates to the &lt;code&gt;true&lt;/code&gt; literal when the predicate is true and the &lt;code&gt;false&lt;/code&gt; literal when it is false.</source>
          <target state="translated">組み込みの &lt;code&gt;cfg&lt;/code&gt; マクロは、単一の構成述語を取り込んで、述語が真の場合は &lt;code&gt;true&lt;/code&gt; リテラルに評価され、 &lt;code&gt;false&lt;/code&gt; の場合は偽のリテラルに評価されます。</target>
        </trans-unit>
        <trans-unit id="87ae881f172e3eab463a1dba119d942ed8deaed7" translate="yes" xml:space="preserve">
          <source>The built-in attributes that have meaning on a function are &lt;a href=&quot;../conditional-compilation&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt;&lt;code&gt;deprecated&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt;&lt;code&gt;doc&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;the lint check attributes&lt;/a&gt;, &lt;code&gt;path&lt;/code&gt;, and &lt;code&gt;no_implicit_prelude&lt;/code&gt;. Modules also accept macro attributes.</source>
          <target state="translated">関数に意味のある組み込み属性は、&lt;a href=&quot;../conditional-compilation&quot;&gt; &lt;code&gt;cfg&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt; &lt;code&gt;deprecated&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt; &lt;code&gt;doc&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;lintチェック属性&lt;/a&gt;、 &lt;code&gt;path&lt;/code&gt; 、および &lt;code&gt;no_implicit_prelude&lt;/code&gt; です。モジュールはマクロ属性も受け入れます。</target>
        </trans-unit>
        <trans-unit id="0658caeac4e6cc6250807a10a1d1127da8f7b8cb" translate="yes" xml:space="preserve">
          <source>The built-in attributes that have meaning on a module are &lt;a href=&quot;../conditional-compilation&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt;&lt;code&gt;deprecated&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt;&lt;code&gt;doc&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;the lint check attributes&lt;/a&gt;, &lt;code&gt;path&lt;/code&gt;, and &lt;code&gt;no_implicit_prelude&lt;/code&gt;. Modules also accept macro attributes.</source>
          <target state="translated">モジュールで意味を持つ組み込み属性は、&lt;a href=&quot;../conditional-compilation&quot;&gt; &lt;code&gt;cfg&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt; &lt;code&gt;deprecated&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt; &lt;code&gt;doc&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;lintチェック属性&lt;/a&gt;、 &lt;code&gt;path&lt;/code&gt; 、および &lt;code&gt;no_implicit_prelude&lt;/code&gt; です。モジュールはマクロ属性も受け入れます。</target>
        </trans-unit>
        <trans-unit id="7917b1e20d5567c345241cec71cc654edebdd434" translate="yes" xml:space="preserve">
          <source>The built-in function traits are generic over a tuple of the function arguments. If one uses angle-bracket notation (&lt;code&gt;Fn&amp;lt;(T,), Output=U&amp;gt;&lt;/code&gt;) instead of parentheses (&lt;code&gt;Fn(T) -&amp;gt; U&lt;/code&gt;) to denote the function trait, the type parameter should be a tuple. Otherwise function call notation cannot be used and the trait will not be implemented by closures.</source>
          <target state="translated">組み込み関数の特性は、関数の引数のタプルよりも一般的です。括弧（ &lt;code&gt;Fn(T) -&amp;gt; U&lt;/code&gt; ）ではなく山括弧表記（ &lt;code&gt;Fn&amp;lt;(T,), Output=U&amp;gt;&lt;/code&gt; ）を使用して関数の特性を示す場合、typeパラメーターはタプルである必要があります。それ以外の場合、関数呼び出し表記は使用できず、トレイトはクロージャーによって実装されません。</target>
        </trans-unit>
        <trans-unit id="a9e1ef14ad9c5016cccb06e0dae0b41ca0441837" translate="yes" xml:space="preserve">
          <source>The c-main function only supports to return integers as return type. So, every type implementing the &lt;code&gt;Termination&lt;/code&gt; trait has to be converted to an integer.</source>
          <target state="translated">c-main関数は、戻り値の型として整数を返すことのみをサポートしています。したがって、 &lt;code&gt;Termination&lt;/code&gt; 特性を実装するすべての型は整数に変換する必要があります。</target>
        </trans-unit>
        <trans-unit id="98a1e057ef0866ad400391fbf23a2daa11b28012" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;lock&lt;/code&gt; would fail if another thread holding the lock panicked. In that case, no one would ever be able to get the lock, so we&amp;rsquo;ve chosen to &lt;code&gt;unwrap&lt;/code&gt; and have this thread panic if we&amp;rsquo;re in that situation.</source>
          <target state="translated">&lt;code&gt;lock&lt;/code&gt; を保持している別のスレッドがパニックした場合、ロックの呼び出しは失敗します。その場合、誰もロックを取得することができないため、その状況にある場合は、 &lt;code&gt;unwrap&lt;/code&gt; してこのスレッドをパニックにすることを選択しました。</target>
        </trans-unit>
        <trans-unit id="a399c55a0729e88865a33bb045bf002d26006429" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;panic!&lt;/code&gt; causes the error message contained in the last two lines. The first line shows our panic message and the place in our source code where the panic occurred: &lt;em&gt;src/main.rs:2:5&lt;/em&gt; indicates that it&amp;rsquo;s the second line, fifth character of our &lt;em&gt;src/main.rs&lt;/em&gt; file.</source>
          <target state="translated">&lt;code&gt;panic!&lt;/code&gt; への呼びかけ！最後の2行に含まれるエラーメッセージが表示されます。1行目は、パニックメッセージと、パニックが発生したソースコード内の場所を示しています&lt;em&gt;。src/ main.rs：2：5&lt;/em&gt;は、2行目、&lt;em&gt;つまりsrc / main.rs&lt;/em&gt;ファイルの5番目の文字であることを示しています。</target>
        </trans-unit>
        <trans-unit id="76991560cfa9d5bcd0a2eea05c7ac9259a741680" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;parse&lt;/code&gt; could easily cause an error. If, for example, the string contained &lt;code&gt;A👍%&lt;/code&gt;, there would be no way to convert that to a number. Because it might fail, the &lt;code&gt;parse&lt;/code&gt; method returns a &lt;code&gt;Result&lt;/code&gt; type, much as the &lt;code&gt;read_line&lt;/code&gt; method does (discussed earlier in &lt;a href=&quot;#handling-potential-failure-with-the-result-type&quot;&gt;&amp;ldquo;Handling Potential Failure with the &lt;code&gt;Result&lt;/code&gt; Type&amp;rdquo;&lt;/a&gt;). We&amp;rsquo;ll treat this &lt;code&gt;Result&lt;/code&gt; the same way by using the &lt;code&gt;expect&lt;/code&gt; method again. If &lt;code&gt;parse&lt;/code&gt; returns an &lt;code&gt;Err&lt;/code&gt;&lt;code&gt;Result&lt;/code&gt; variant because it couldn&amp;rsquo;t create a number from the string, the &lt;code&gt;expect&lt;/code&gt; call will crash the game and print the message we give it. If &lt;code&gt;parse&lt;/code&gt; can successfully convert the string to a number, it will return the &lt;code&gt;Ok&lt;/code&gt; variant of &lt;code&gt;Result&lt;/code&gt;, and &lt;code&gt;expect&lt;/code&gt; will return the number that we want from the &lt;code&gt;Ok&lt;/code&gt; value.</source>
          <target state="translated">&lt;code&gt;parse&lt;/code&gt; を呼び出すと、簡単にエラーが発生する可能性があります。たとえば、文字列に &lt;code&gt;A👍%&lt;/code&gt; が含まれている場合、それを数値に変換する方法はありません。 &lt;code&gt;parse&lt;/code&gt; メソッドは失敗する可能性があるため、 &lt;code&gt;read_line&lt;/code&gt; メソッドと同じように &lt;code&gt;Result&lt;/code&gt; 型を返します（&lt;a href=&quot;#handling-potential-failure-with-the-result-type&quot;&gt;「&lt;/a&gt; &lt;code&gt;Result&lt;/code&gt; 型による潜在的な障害の処理」で前に説明しました）。この &lt;code&gt;Result&lt;/code&gt; は、 &lt;code&gt;expect&lt;/code&gt; メソッドを再度使用することで同じように扱います。文字列から数値を作成できなかったために &lt;code&gt;parse&lt;/code&gt; が &lt;code&gt;Err&lt;/code&gt; &lt;code&gt;Result&lt;/code&gt; バリアントを返す場合、 &lt;code&gt;expect&lt;/code&gt; 呼び出しはゲームをクラッシュさせ、私たちが与えるメッセージを出力します。場合は &lt;code&gt;parse&lt;/code&gt; 成功した文字列を数値に変換することができ、それが返されます &lt;code&gt;Ok&lt;/code&gt; のバリアント &lt;code&gt;Result&lt;/code&gt; 、と &lt;code&gt;expect&lt;/code&gt; から私たちが望むことの数を返します &lt;code&gt;Ok&lt;/code&gt; 値。</target>
        </trans-unit>
        <trans-unit id="7b69e26d39a3f8839842ab3c559f82019ca9b310" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;recv&lt;/code&gt; blocks, so if there is no job yet, the current thread will wait until a job becomes available. The &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; ensures that only one &lt;code&gt;Worker&lt;/code&gt; thread at a time is trying to request a job.</source>
          <target state="translated">&lt;code&gt;recv&lt;/code&gt; の呼び出しはブロックされるため、ジョブがない場合、現在のスレッドはジョブが使用可能になるまで待機します。 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 唯一性を保証 &lt;code&gt;Worker&lt;/code&gt; 時にスレッドが仕事を依頼しようとしています。</target>
        </trans-unit>
        <trans-unit id="8993444f4968db6cec0c3f76e82220cf7def7574" translate="yes" xml:space="preserve">
          <source>The caller has to ensure that no references in the supplied thread closure or its return type can outlive the spawned thread's lifetime. This can be guaranteed in two ways:</source>
          <target state="translated">呼び出し元は、供給されたスレッドクロージャやその戻り値の型の中にある参照が、 スポーンされたスレッドの寿命を超えないようにしなければなりません。これは二つの方法で保証されます。</target>
        </trans-unit>
        <trans-unit id="093036972d7bffcd0b16a57c6e2ba75deeb1dca1" translate="yes" xml:space="preserve">
          <source>The caller must also ensure that the memory the pointer (non-transitively) points to is never written to (except inside an &lt;code&gt;UnsafeCell&lt;/code&gt;) using this pointer or any pointer derived from it. If you need to mutate the contents of the slice, use &lt;a href=&quot;#method.as_mut_ptr&quot;&gt;&lt;code&gt;as_mut_ptr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">呼び出し元は、ポインタ（非推移的）が指すメモリが、このポインタまたはそこから派生したポインタを使用して（ &lt;code&gt;UnsafeCell&lt;/code&gt; 内を除いて）決して書き込まれないようにする必要もあります。スライスの内容を変更する必要がある場合は、&lt;a href=&quot;#method.as_mut_ptr&quot;&gt; &lt;code&gt;as_mut_ptr&lt;/code&gt; を&lt;/a&gt;使用します。</target>
        </trans-unit>
        <trans-unit id="fbd8e378206e5ebe48537e21894c0d0196aa5c37" translate="yes" xml:space="preserve">
          <source>The caller must also ensure that the memory the pointer (non-transitively) points to is never written to (except inside an &lt;code&gt;UnsafeCell&lt;/code&gt;) using this pointer or any pointer derived from it. If you need to mutate the contents of the slice, use &lt;a href=&quot;struct.vec#method.as_mut_ptr&quot;&gt;&lt;code&gt;as_mut_ptr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">呼び出し元は、このポインターまたはそこから派生したポインターを使用して、ポインターが（非推移的に）指すメモリーが（ &lt;code&gt;UnsafeCell&lt;/code&gt; 内を除いて）書き込まれないようにする必要もあります。スライスの内容を変更する必要がある場合は、&lt;a href=&quot;struct.vec#method.as_mut_ptr&quot;&gt; &lt;code&gt;as_mut_ptr&lt;/code&gt; を&lt;/a&gt;使用します。</target>
        </trans-unit>
        <trans-unit id="2daa4ea0adccac77e0ee2e5186b78bccb935a23d" translate="yes" xml:space="preserve">
          <source>The caller must ensure that the content of the slice is valid UTF-8 before the borrow ends and the underlying &lt;code&gt;str&lt;/code&gt; is used.</source>
          <target state="translated">呼び出し元は、借用が終了して基になる &lt;code&gt;str&lt;/code&gt; が使用される前に、スライスのコンテンツが有効なUTF-8であることを確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="ac3ada34e0728cb1a740ac35a9a92bd4109e42c8" translate="yes" xml:space="preserve">
          <source>The caller must ensure that the returned pointer is never written to. If you need to mutate the contents of the string slice, use &lt;a href=&quot;#method.as_mut_ptr&quot;&gt;&lt;code&gt;as_mut_ptr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">呼び出し元は、返されたポインタが決して書き込まれないようにする必要があります。文字列スライスの内容を変更する必要がある場合は、&lt;a href=&quot;#method.as_mut_ptr&quot;&gt; &lt;code&gt;as_mut_ptr&lt;/code&gt; を&lt;/a&gt;使用します。</target>
        </trans-unit>
        <trans-unit id="0c95ecf028004da1510b460935745006e917bea1" translate="yes" xml:space="preserve">
          <source>The caller must ensure that the returned pointer is never written to. If you need to mutate the contents of the string slice, use &lt;a href=&quot;../primitive.str#method.as_mut_ptr&quot;&gt;&lt;code&gt;as_mut_ptr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">呼び出し元は、返されたポインタが決して書き込まれないようにする必要があります。文字列スライスの内容を変更する必要がある場合は、&lt;a href=&quot;../primitive.str#method.as_mut_ptr&quot;&gt; &lt;code&gt;as_mut_ptr&lt;/code&gt; を&lt;/a&gt;使用します。</target>
        </trans-unit>
        <trans-unit id="de2dba4a5088d0450aaa1d7584230c3882b4aa0e" translate="yes" xml:space="preserve">
          <source>The caller must ensure that the returned pointer is never written to. If you need to mutate the contents of the string slice, use &lt;a href=&quot;primitive.str#method.as_mut_ptr&quot;&gt;&lt;code&gt;as_mut_ptr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">呼び出し元は、返されたポインタが決して書き込まれないようにする必要があります。文字列スライスの内容を変更する必要がある場合は、&lt;a href=&quot;primitive.str#method.as_mut_ptr&quot;&gt; &lt;code&gt;as_mut_ptr&lt;/code&gt; を&lt;/a&gt;使用します。</target>
        </trans-unit>
        <trans-unit id="0392a3d2bc79f7cc36923d474ab5bb48f657c119" translate="yes" xml:space="preserve">
          <source>The caller must ensure that the slice outlives the pointer this function returns, or else it will end up pointing to garbage.</source>
          <target state="translated">呼び出し元は、この関数が返すポインタよりもスライスが長持ちするようにしなければなりません。</target>
        </trans-unit>
        <trans-unit id="bf480a8080607d02f4b53d9ea9e935964787c02b" translate="yes" xml:space="preserve">
          <source>The caller must ensure that the vector outlives the pointer this function returns, or else it will end up pointing to garbage. Modifying the vector may cause its buffer to be reallocated, which would also make any pointers to it invalid.</source>
          <target state="translated">呼び出し元はベクトルがこの関数が返すポインタよりも長持ちするようにしなければなりません。ベクトルを変更すると,そのバッファが再割り当てされる可能性があります.</target>
        </trans-unit>
        <trans-unit id="09005f0066a1b73d30e33e09129bf20aee61c736" translate="yes" xml:space="preserve">
          <source>The calling thread will be blocked until there are no more writers which hold the lock. There may be other readers currently inside the lock when this method returns. This method does not provide any guarantees with respect to the ordering of whether contentious readers or writers will acquire the lock first.</source>
          <target state="translated">呼び出したスレッドは、ロックを保持しているライターがなくなるまでブロックされます。このメソッドが戻ってきたときには、現在ロックの中に他のリーダがいるかもしれません。このメソッドは、競合するリーダやライタが最初にロックを取得するかどうかの順序については何ら保証しません。</target>
        </trans-unit>
        <trans-unit id="4c684d1da6df1a86528a2f3d33b0bb20fea3d352" translate="yes" xml:space="preserve">
          <source>The calls to &lt;code&gt;thread::sleep&lt;/code&gt; force a thread to stop its execution for a short duration, allowing a different thread to run. The threads will probably take turns, but that isn&amp;rsquo;t guaranteed: it depends on how your operating system schedules the threads. In this run, the main thread printed first, even though the print statement from the spawned thread appears first in the code. And even though we told the spawned thread to print until &lt;code&gt;i&lt;/code&gt; is 9, it only got to 5 before the main thread shut down.</source>
          <target state="translated">&lt;code&gt;thread::sleep&lt;/code&gt; の呼び出しは、スレッドにその実行を短時間停止させ、別のスレッドの実行を許可します。スレッドは交互に実行される可能性がありますが、保証はありません。オペレーティングシステムがスレッドをスケジュールする方法によって異なります。この実行では、生成されたスレッドの印刷ステートメントがコードの最初に表示されていても、メインスレッドが最初に印刷されました。そして、生成されたスレッドに &lt;code&gt;i&lt;/code&gt; が9になるまで印刷するように指示したにもかかわらず、メインスレッドがシャットダウンする前に5にしか到達しませんでした。</target>
        </trans-unit>
        <trans-unit id="c7560eebffb8ae3cdb259698d7be211bc4620b7e" translate="yes" xml:space="preserve">
          <source>The canonical ExitCode for successful termination on this platform.</source>
          <target state="translated">このプラットフォーム上で正常に終了するための標準的なExitCode。</target>
        </trans-unit>
        <trans-unit id="8f6ef1b9ea50b970966541a96ea6f822d628893b" translate="yes" xml:space="preserve">
          <source>The canonical ExitCode for unsuccessful termination on this platform.</source>
          <target state="translated">このプラットフォーム上で失敗して終了した場合の標準的なExitCode。</target>
        </trans-unit>
        <trans-unit id="edfe5292e463236ad7502b40af63d1dc3846bebd" translate="yes" xml:space="preserve">
          <source>The canonical path is only meaningful within a given crate. There is no global namespace across crates; an item's canonical path merely identifies it within the crate.</source>
          <target state="translated">このような場合には、「このプロジェクトは、このプロジェクトに含まれていない」ということになります。このような場合には、このような情報を使用することはできません。</target>
        </trans-unit>
        <trans-unit id="42b8d1ea1b4247711765802c026fc2d790b1362d" translate="yes" xml:space="preserve">
          <source>The canonical safe use of &lt;code&gt;mem::forget&lt;/code&gt; is to circumvent a value's destructor implemented by the &lt;code&gt;Drop&lt;/code&gt; trait. For example, this will leak a &lt;code&gt;File&lt;/code&gt;, i.e. reclaim the space taken by the variable but never close the underlying system resource:</source>
          <target state="translated">&lt;code&gt;mem::forget&lt;/code&gt; の標準的な安全な使用法は、 &lt;code&gt;Drop&lt;/code&gt; トレイトによって実装された値のデストラクタを回避することです。たとえば、これは &lt;code&gt;File&lt;/code&gt; をリークします。つまり、変数が使用するスペースを再利用しますが、基になるシステムリソースを閉じることはありません。</target>
        </trans-unit>
        <trans-unit id="1aa3ddcbed06fec001e59bb6f3f1f1da2ef18ef6" translate="yes" xml:space="preserve">
          <source>The capacity may be increased by more than &lt;code&gt;additional&lt;/code&gt; bytes if it chooses, to prevent frequent reallocations.</source>
          <target state="translated">容量は、必要に応じて &lt;code&gt;additional&lt;/code&gt; バイトよりも多くして、頻繁な再割り当てを防ぐことができます。</target>
        </trans-unit>
        <trans-unit id="4e527152d8f3ca4ddc869842d5ee9ae2a46a82fb" translate="yes" xml:space="preserve">
          <source>The capacity of a vector is the amount of space allocated for any future elements that will be added onto the vector. This is not to be confused with the &lt;em&gt;length&lt;/em&gt; of a vector, which specifies the number of actual elements within the vector. If a vector's length exceeds its capacity, its capacity will automatically be increased, but its elements will have to be reallocated.</source>
          <target state="translated">ベクターの容量は、ベクターに追加される将来の要素に割り当てられるスペースの量です。これは、ベクトル内の実際の要素の数を指定するベクトルの&lt;em&gt;長さ&lt;/em&gt;と混同しないでください。ベクトルの長さがその容量を超えると、その容量は自動的に増加しますが、その要素を再割り当てする必要があります。</target>
        </trans-unit>
        <trans-unit id="a70fb21498dabd7b592b7614b4af0ad2efc52b05" translate="yes" xml:space="preserve">
          <source>The capacity will remain at least as large as both the length and the supplied value.</source>
          <target state="translated">容量は、少なくとも長さと供給値の両方と同じくらいの大きさを維持します。</target>
        </trans-unit>
        <trans-unit id="f2f4d42ff0e5eed287aac391d229f38ad7615e31" translate="yes" xml:space="preserve">
          <source>The captured values of a &lt;a href=&quot;types/closure&quot;&gt;closure&lt;/a&gt; are dropped in an unspecified order.</source>
          <target state="translated">キャプチャされた&lt;a href=&quot;types/closure&quot;&gt;クロージャの&lt;/a&gt;値は、不特定の順序で削除されます。</target>
        </trans-unit>
        <trans-unit id="138edd42fa740c68b92f8f2886d9a7cfd608a2f8" translate="yes" xml:space="preserve">
          <source>The changes we needed to make to &lt;code&gt;main&lt;/code&gt; to reassign &lt;code&gt;post&lt;/code&gt; mean that this implementation doesn&amp;rsquo;t quite follow the object-oriented state pattern anymore: the transformations between the states are no longer encapsulated entirely within the &lt;code&gt;Post&lt;/code&gt; implementation. However, our gain is that invalid states are now impossible because of the type system and the type checking that happens at compile time! This ensures that certain bugs, such as display of the content of an unpublished post, will be discovered before they make it to production.</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; に &lt;code&gt;post&lt;/code&gt; を再割り当てするために必要な変更は、この実装がオブジェクト指向の状態パターンに完全に従わないことを意味します。状態間の変換は、 &lt;code&gt;Post&lt;/code&gt; 実装内に完全にカプセル化されなくなりました。ただし、型システムと型チェックがコンパイル時に行われるため、無効な状態は不可能になりました。これにより、非公開の投稿のコンテンツの表示など、特定のバグが本番環境に移行する前に確実に発見されます。</target>
        </trans-unit>
        <trans-unit id="7c6978553f5d9c2a253b6007e164ab1e1253e787" translate="yes" xml:space="preserve">
          <source>The character represented by this escape</source>
          <target state="translated">このエスケープで表される文字</target>
        </trans-unit>
        <trans-unit id="444f11cad1e3ea489affb1093e4cfe00aec033b8" translate="yes" xml:space="preserve">
          <source>The character type, &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">文字タイプ &lt;code&gt;char&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a2ab8aadbe1c6203ddb8254dc62679ad2d0d6a50" translate="yes" xml:space="preserve">
          <source>The child inherits from the corresponding parent descriptor.</source>
          <target state="translated">子は対応する親ディスクリプタを継承します。</target>
        </trans-unit>
        <trans-unit id="57f64da60a0aae4c7ca65b39d52634b157698777" translate="yes" xml:space="preserve">
          <source>The chunks are array references and do not overlap. If &lt;code&gt;N&lt;/code&gt; does not divide the length of the slice, then the last up to &lt;code&gt;N-1&lt;/code&gt; elements will be omitted and can be retrieved from the &lt;code&gt;remainder&lt;/code&gt; function of the iterator.</source>
          <target state="translated">チャンクは配列参照であり、重複しません。 &lt;code&gt;N&lt;/code&gt; がスライスの長さを分割しない場合、最後の最大 &lt;code&gt;N-1&lt;/code&gt; 個の要素が省略され、イテレーターの &lt;code&gt;remainder&lt;/code&gt; 関数から取得できます。</target>
        </trans-unit>
        <trans-unit id="15fa38fbe64a63fe95b52b94271d4ba554613043" translate="yes" xml:space="preserve">
          <source>The chunks are mutable array references and do not overlap. If &lt;code&gt;N&lt;/code&gt; does not divide the length of the slice, then the last up to &lt;code&gt;N-1&lt;/code&gt; elements will be omitted and can be retrieved from the &lt;code&gt;into_remainder&lt;/code&gt; function of the iterator.</source>
          <target state="translated">チャンクは可変配列参照であり、重複しません。 &lt;code&gt;N&lt;/code&gt; がスライスの長さを分割しない場合、最後の最大 &lt;code&gt;N-1&lt;/code&gt; 個の要素が省略され、イテレータの &lt;code&gt;into_remainder&lt;/code&gt; 関数から取得できます。</target>
        </trans-unit>
        <trans-unit id="22f36eeee32622c7a505cef344bfce71a990d798" translate="yes" xml:space="preserve">
          <source>The chunks are mutable slices, and do not overlap. If &lt;code&gt;chunk_size&lt;/code&gt; does not divide the length of the slice, then the last chunk will not have length &lt;code&gt;chunk_size&lt;/code&gt;.</source>
          <target state="translated">チャンクは変更可能なスライスであり、重複しません。 &lt;code&gt;chunk_size&lt;/code&gt; がスライスの長さを分割しない場合、最後のチャンクの長さは &lt;code&gt;chunk_size&lt;/code&gt; になりません。</target>
        </trans-unit>
        <trans-unit id="a56cc46096f73dcb9c3581ef24840c1b8a52d3e3" translate="yes" xml:space="preserve">
          <source>The chunks are mutable slices, and do not overlap. If &lt;code&gt;chunk_size&lt;/code&gt; does not divide the length of the slice, then the last up to &lt;code&gt;chunk_size-1&lt;/code&gt; elements will be omitted and can be retrieved from the &lt;code&gt;into_remainder&lt;/code&gt; function of the iterator.</source>
          <target state="translated">チャンクは変更可能なスライスであり、重複しません。 &lt;code&gt;chunk_size&lt;/code&gt; がスライスの長さを分割しない場合、 &lt;code&gt;into_remainder&lt;/code&gt; &lt;code&gt;chunk_size-1&lt;/code&gt; までの最後の要素は省略され、イテレータのinto_remainder関数から取得できます。</target>
        </trans-unit>
        <trans-unit id="b9b82e1f955649f5c987c92e4ad59440a3cb7655" translate="yes" xml:space="preserve">
          <source>The chunks are slices and do not overlap. If &lt;code&gt;chunk_size&lt;/code&gt; does not divide the length of the slice, then the last chunk will not have length &lt;code&gt;chunk_size&lt;/code&gt;.</source>
          <target state="translated">チャンクはスライスであり、重複しません。 &lt;code&gt;chunk_size&lt;/code&gt; がスライスの長さを分割しない場合、最後のチャンクの長さは &lt;code&gt;chunk_size&lt;/code&gt; になりません。</target>
        </trans-unit>
        <trans-unit id="93ee6025794c31565e33ecdc52225cb4e18501bf" translate="yes" xml:space="preserve">
          <source>The chunks are slices and do not overlap. If &lt;code&gt;chunk_size&lt;/code&gt; does not divide the length of the slice, then the last up to &lt;code&gt;chunk_size-1&lt;/code&gt; elements will be omitted and can be retrieved from the &lt;code&gt;remainder&lt;/code&gt; function of the iterator.</source>
          <target state="translated">チャンクはスライスであり、重複しません。 &lt;code&gt;chunk_size&lt;/code&gt; がスライスの長さを分割しない場合、最後の &lt;code&gt;chunk_size-1&lt;/code&gt; までの要素は省略され、反復子の &lt;code&gt;remainder&lt;/code&gt; 関数から取得できます。</target>
        </trans-unit>
        <trans-unit id="5ab8cfd0030cc999866ad155de372dfc9a291653" translate="yes" xml:space="preserve">
          <source>The closure &lt;code&gt;f&lt;/code&gt; is yielded a &lt;a href=&quot;struct.oncestate&quot;&gt;&lt;code&gt;OnceState&lt;/code&gt;&lt;/a&gt; structure which can be used to query the poison status of the &lt;a href=&quot;struct.once&quot;&gt;&lt;code&gt;Once&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">クロージャー &lt;code&gt;f&lt;/code&gt; は、&lt;a href=&quot;struct.once&quot;&gt; &lt;code&gt;Once&lt;/code&gt; の&lt;/a&gt;ポイズンステータスを照会するために使用できる&lt;a href=&quot;struct.oncestate&quot;&gt; &lt;code&gt;OnceState&lt;/code&gt; &lt;/a&gt;構造体を生成します。</target>
        </trans-unit>
        <trans-unit id="8464cb339a91ac7f9edf87e86826287afbdde678" translate="yes" xml:space="preserve">
          <source>The closure &lt;code&gt;f&lt;/code&gt; is yielded a &lt;a href=&quot;struct.oncestate&quot;&gt;&lt;code&gt;OnceState&lt;/code&gt;&lt;/a&gt; structure which can be used to query the poison status of the &lt;code&gt;Once&lt;/code&gt;.</source>
          <target state="translated">クロージャ &lt;code&gt;f&lt;/code&gt; は、 &lt;code&gt;Once&lt;/code&gt; のポイズンステータスのクエリに使用できる&lt;a href=&quot;struct.oncestate&quot;&gt; &lt;code&gt;OnceState&lt;/code&gt; &lt;/a&gt;構造を生成します。</target>
        </trans-unit>
        <trans-unit id="6122336d1e3dc25f0e6a48ca5c6617d72884ddeb" translate="yes" xml:space="preserve">
          <source>The closure &lt;code&gt;f&lt;/code&gt; will only be executed once if this is called concurrently amongst many threads. If that closure panics, however, then it will &lt;em&gt;poison&lt;/em&gt; this &lt;a href=&quot;struct.once&quot;&gt;&lt;code&gt;Once&lt;/code&gt;&lt;/a&gt; instance, causing all future invocations of &lt;code&gt;call_once&lt;/code&gt; to also panic.</source>
          <target state="translated">クロージャー &lt;code&gt;f&lt;/code&gt; は、これが多くのスレッド間で同時に呼び出された場合に1回だけ実行されます。その閉鎖パニックが発生した場合は、しかし、それがされます&lt;em&gt;毒&lt;/em&gt;、この&lt;a href=&quot;struct.once&quot;&gt; &lt;code&gt;Once&lt;/code&gt; &lt;/a&gt;のすべての将来の呼び出し引き起こし、インスタンスを &lt;code&gt;call_once&lt;/code&gt; もパニックに。</target>
        </trans-unit>
        <trans-unit id="1151c6060a40c30d933870c684e8f8c1c9ce7a79" translate="yes" xml:space="preserve">
          <source>The closure &lt;code&gt;f&lt;/code&gt; will only be executed once if this is called concurrently amongst many threads. If that closure panics, however, then it will &lt;em&gt;poison&lt;/em&gt; this &lt;code&gt;Once&lt;/code&gt; instance, causing all future invocations of &lt;code&gt;call_once&lt;/code&gt; to also panic.</source>
          <target state="translated">クロージャー &lt;code&gt;f&lt;/code&gt; は、これが多数のスレッド間で同時に呼び出された場合に1回だけ実行されます。その閉鎖パニックが発生した場合は、しかし、それがされます&lt;em&gt;毒&lt;/em&gt;、この &lt;code&gt;Once&lt;/code&gt; のすべての将来の呼び出し引き起こし、インスタンスを &lt;code&gt;call_once&lt;/code&gt; もパニックに。</target>
        </trans-unit>
        <trans-unit id="9a9ae7f6f31f6430eeec94354c414e42d745c712" translate="yes" xml:space="preserve">
          <source>The closure can use captures and its environment to track state across iterations. Depending on how the iterator is used, this may require specifying the &lt;a href=&quot;../keyword.move&quot;&gt;&lt;code&gt;move&lt;/code&gt;&lt;/a&gt; keyword on the closure.</source>
          <target state="translated">クロージャーは、キャプチャとその環境を使用して、反復全体の状態を追跡できます。イテレータの使用方法によっては、クロージャで&lt;a href=&quot;../keyword.move&quot;&gt; &lt;code&gt;move&lt;/code&gt; &lt;/a&gt;キーワードを指定する必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="cbba645c0f92459c3e584dd2aad4e56b6422ddeb" translate="yes" xml:space="preserve">
          <source>The closure can use captures and its environment to track state across iterations. Depending on how the iterator is used, this may require specifying the &lt;code&gt;move&lt;/code&gt; keyword on the closure.</source>
          <target state="translated">クロージャーは、キャプチャーとその環境を使用して、反復全体の状態を追跡できます。イテレーターの使用方法によっては、クロージャーで &lt;code&gt;move&lt;/code&gt; キーワードを指定する必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="8e57e2087c6fad9eaa8a18bdb745b2ddd95bd84c" translate="yes" xml:space="preserve">
          <source>The closure captures the &lt;code&gt;shoe_size&lt;/code&gt; parameter from the environment and compares the value with each shoe&amp;rsquo;s size, keeping only shoes of the size specified. Finally, calling &lt;code&gt;collect&lt;/code&gt; gathers the values returned by the adapted iterator into a vector that&amp;rsquo;s returned by the function.</source>
          <target state="translated">クロージャーは、環境から &lt;code&gt;shoe_size&lt;/code&gt; パラメーターを取り込み、その値を各靴のサイズと比較して、指定されたサイズの靴のみを保持します。最後に、 &lt;code&gt;collect&lt;/code&gt; を呼び出すと、適応イテレータによって返された値が、関数によって返されるベクトルに収集されます。</target>
        </trans-unit>
        <trans-unit id="0112db2feb7312ad3c6512257c24783293514225" translate="yes" xml:space="preserve">
          <source>The closure definition comes after the &lt;code&gt;=&lt;/code&gt; to assign it to the variable &lt;code&gt;expensive_closure&lt;/code&gt;. To define a closure, we start with a pair of vertical pipes (&lt;code&gt;|&lt;/code&gt;), inside which we specify the parameters to the closure; this syntax was chosen because of its similarity to closure definitions in Smalltalk and Ruby. This closure has one parameter named &lt;code&gt;num&lt;/code&gt;: if we had more than one parameter, we would separate them with commas, like &lt;code&gt;|param1, param2|&lt;/code&gt;.</source>
          <target state="translated">クロージャーの定義は、変数 &lt;code&gt;expensive_closure&lt;/code&gt; クロージャーに割り当てるために &lt;code&gt;=&lt;/code&gt; の後に来ます。クロージャを定義するには、1組の垂直パイプ（ &lt;code&gt;|&lt;/code&gt; ）から始め、その中でクロージャへのパラメータを指定します。この構文が選択されたのは、SmalltalkおよびRubyでのクロージャ定義との類似性のためです。このクロージャには &lt;code&gt;num&lt;/code&gt; という名前のパラメータが1つあります。複数のパラメータがある場合は、 &lt;code&gt;|param1, param2|&lt;/code&gt; ようにコンマで区切ります。。</target>
        </trans-unit>
        <trans-unit id="1b467eb6733245bc29dea650b68390c954774c96" translate="yes" xml:space="preserve">
          <source>The closure is allowed to return an I/O error whose OS error code will be communicated back to the parent and returned as an error from when the spawn was requested.</source>
          <target state="translated">クロージャは、OS のエラーコードが親に通信され、スポーンが要求されたときのエラーとして返される I/O エラーを返すことが許されています。</target>
        </trans-unit>
        <trans-unit id="2d07950c5510607459c97a1e9bf4b42e15a155b7" translate="yes" xml:space="preserve">
          <source>The closure must return &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. &lt;code&gt;filter()&lt;/code&gt; creates an iterator which calls this closure on each element. If the closure returns &lt;code&gt;true&lt;/code&gt;, then the element is returned. If the closure returns &lt;code&gt;false&lt;/code&gt;, it will try again, and call the closure on the next element, seeing if it passes the test.</source>
          <target state="translated">クロージャは &lt;code&gt;true&lt;/code&gt; または &lt;code&gt;false&lt;/code&gt; を返す必要があります。 &lt;code&gt;filter()&lt;/code&gt; は、各要素でこのクロージャを呼び出すイテレータを作成します。クロージャが &lt;code&gt;true&lt;/code&gt; を返す場合、要素が返されます。クロージャが &lt;code&gt;false&lt;/code&gt; を返した場合、再試行して、次の要素でクロージャを呼び出し、テストに合格したかどうかを確認します。</target>
        </trans-unit>
        <trans-unit id="0dfbb8ddc807c0ec7e308a6bcf0502df62203387" translate="yes" xml:space="preserve">
          <source>The closure must return an &lt;a href=&quot;../option/enum.option&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;filter_map&lt;/code&gt; creates an iterator which calls this closure on each element. If the closure returns &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some(element)&lt;/code&gt;&lt;/a&gt;, then that element is returned. If the closure returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, it will try again, and call the closure on the next element, seeing if it will return &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">クロージャは&lt;a href=&quot;../option/enum.option&quot;&gt; &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;返す必要があります。 &lt;code&gt;filter_map&lt;/code&gt; は、各要素でこのクロージャを呼び出すイテレータを作成します。クロージャが&lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some(element)&lt;/code&gt; を&lt;/a&gt;返す場合、その要素が返されます。クロージャが&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; を&lt;/a&gt;返した場合、再試行して次の要素のクロージャを呼び出し、&lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some&lt;/code&gt; &lt;/a&gt;を返すかどうかを確認します。</target>
        </trans-unit>
        <trans-unit id="7a4c6af8980cc5834794f8ba584bb6cebd16567c" translate="yes" xml:space="preserve">
          <source>The closure provided is required to adhere to the &lt;a href=&quot;trait.unwindsafe&quot;&gt;&lt;code&gt;UnwindSafe&lt;/code&gt;&lt;/a&gt; trait to ensure that all captured variables are safe to cross this boundary. The purpose of this bound is to encode the concept of &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1236-stabilize-catch-panic.md&quot;&gt;exception safety&lt;/a&gt; in the type system. Most usage of this function should not need to worry about this bound as programs are naturally unwind safe without &lt;code&gt;unsafe&lt;/code&gt; code. If it becomes a problem the &lt;a href=&quot;struct.assertunwindsafe&quot;&gt;&lt;code&gt;AssertUnwindSafe&lt;/code&gt;&lt;/a&gt; wrapper struct can be used to quickly assert that the usage here is indeed unwind safe.</source>
          <target state="translated">提供されるクロージャは、&lt;a href=&quot;trait.unwindsafe&quot;&gt; &lt;code&gt;UnwindSafe&lt;/code&gt; &lt;/a&gt;トレイトに準拠して、キャプチャされたすべての変数がこの境界を越えても安全であることを保証するために必要です。この境界の目的は、型システムの&lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1236-stabilize-catch-panic.md&quot;&gt;例外安全性&lt;/a&gt;の概念をエンコードすることです。プログラムは安全で &lt;code&gt;unsafe&lt;/code&gt; コードなしで自然に巻き戻されるので、この関数のほとんどの使用法はこの境界について心配する必要はありません。これが問題になる場合、&lt;a href=&quot;struct.assertunwindsafe&quot;&gt; &lt;code&gt;AssertUnwindSafe&lt;/code&gt; &lt;/a&gt;ラッパー構造体を使用して、ここでの使用が本当にアンワインドセーフであることをすばやくアサートできます。</target>
        </trans-unit>
        <trans-unit id="1db2515eb35827d3b48808ed11db89506d167098" translate="yes" xml:space="preserve">
          <source>The closure uses &lt;code&gt;v&lt;/code&gt;, so it will capture &lt;code&gt;v&lt;/code&gt; and make it part of the closure&amp;rsquo;s environment. Because &lt;code&gt;thread::spawn&lt;/code&gt; runs this closure in a new thread, we should be able to access &lt;code&gt;v&lt;/code&gt; inside that new thread. But when we compile this example, we get the following error:</source>
          <target state="translated">閉鎖用途は &lt;code&gt;v&lt;/code&gt; それがキャプチャされますので、 &lt;code&gt;v&lt;/code&gt; その閉鎖の環境の一部にします。 &lt;code&gt;thread::spawn&lt;/code&gt; はこのクロージャーを新しいスレッドで実行するので、その新しいスレッド内の &lt;code&gt;v&lt;/code&gt; にアクセスできるはずです。しかし、この例をコンパイルすると、次のエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="d7aca11a6ac0f9ea5173acf1c9757981e77e687c" translate="yes" xml:space="preserve">
          <source>The code associated with each arm is an expression, and the resulting value of the expression in the matching arm is the value that gets returned for the entire &lt;code&gt;match&lt;/code&gt; expression.</source>
          <target state="translated">各アームに関連付けられたコードは式であり、一致するアームの式の結果の値は、 &lt;code&gt;match&lt;/code&gt; 式全体に対して返される値です。</target>
        </trans-unit>
        <trans-unit id="86ec55efa28e5ccc120a1f5241fba708e750dd58" translate="yes" xml:space="preserve">
          <source>The code in Listing 13-17 doesn&amp;rsquo;t do anything; the closure we&amp;rsquo;ve specified never gets called. The warning reminds us why: iterator adaptors are lazy, and we need to consume the iterator here.</source>
          <target state="translated">リスト13-17のコードは何もしません。指定したクロージャーが呼び出されることはありません。警告は、理由を思い出させます。イテレータアダプタが遅延しているため、ここでイテレータを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="27595e3e42c890c6fdee5b82c7f1d2b1399713f0" translate="yes" xml:space="preserve">
          <source>The code in Listing 13-3 has multiple calls to the slow calculation function. The first &lt;code&gt;if&lt;/code&gt; block calls &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; twice, the &lt;code&gt;if&lt;/code&gt; inside the outer &lt;code&gt;else&lt;/code&gt; doesn&amp;rsquo;t call it at all, and the code inside the second &lt;code&gt;else&lt;/code&gt; case calls it once.</source>
          <target state="translated">リスト13-3のコードは遅い計算関数への複数の呼び出しを持っています。最初の &lt;code&gt;if&lt;/code&gt; ブロックの呼び出しは &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; 二回、 &lt;code&gt;if&lt;/code&gt; 、外側の内側に &lt;code&gt;else&lt;/code&gt; すべてでそれを呼び出すことはありません、第二の内部コード &lt;code&gt;else&lt;/code&gt; 場合は、一度それを呼び出します。</target>
        </trans-unit>
        <trans-unit id="984f7b754ab17440aa0c07b718b002aed1594b7a" translate="yes" xml:space="preserve">
          <source>The code in Listing 16-1 not only stops the spawned thread prematurely most of the time due to the main thread ending, but also can&amp;rsquo;t guarantee that the spawned thread will get to run at all. The reason is that there is no guarantee on the order in which threads run!</source>
          <target state="translated">コードリスト16-1のコードは、メインスレッドの終了が原因でほとんどの場合、発生したスレッドを途中で停止するだけでなく、発生したスレッドがまったく実行されることも保証できません。その理由は、スレッドの実行順序が保証されていないためです。</target>
        </trans-unit>
        <trans-unit id="4d5adfd375cd377b4763e2eeee96a84687acf4e5" translate="yes" xml:space="preserve">
          <source>The code in Listing 16-8 compiled and ran, but it didn&amp;rsquo;t clearly show us that two separate threads were talking to each other over the channel. In Listing 16-10 we&amp;rsquo;ve made some modifications that will prove the code in Listing 16-8 is running concurrently: the spawned thread will now send multiple messages and pause for a second between each message.</source>
          <target state="translated">リスト16-8のコードはコンパイルされて実行されましたが、2つの別々のスレッドがチャネルを介して互いに通信していることを明確に示していませんでした。リスト16-10では、リスト16-8のコードが同時に実行されていることを証明するいくつかの変更を加えました。生成されたスレッドは複数のメッセージを送信し、各メッセージの間で1秒間休止します。</target>
        </trans-unit>
        <trans-unit id="9e7e0566bf3de2c83a460b61c17bb70770c4b1c5" translate="yes" xml:space="preserve">
          <source>The code in Listing 18-1 shows a series of checks for several conditions that decide what the background color should be. For this example, we&amp;rsquo;ve created variables with hardcoded values that a real program might receive from user input.</source>
          <target state="translated">コードリスト18-1のコードは、背景色を決定するいくつかの条件の一連のチェックを示しています。この例では、実際のプログラムがユーザー入力から受け取る可能性のあるハードコードされた値を持つ変数を作成しました。</target>
        </trans-unit>
        <trans-unit id="c12405c78a2c0d83f529e2201871e22f52a8474e" translate="yes" xml:space="preserve">
          <source>The code in Listing 18-3 will print the following:</source>
          <target state="translated">リスト18-3のコードは次のように表示されます。</target>
        </trans-unit>
        <trans-unit id="efe51698d475c0b9864955b57e12d5b79c9bbf35" translate="yes" xml:space="preserve">
          <source>The code in Listing 20-14 will compile but doesn&amp;rsquo;t create any threads yet. We&amp;rsquo;ve changed the definition of &lt;code&gt;ThreadPool&lt;/code&gt; to hold a vector of &lt;code&gt;thread::JoinHandle&amp;lt;()&amp;gt;&lt;/code&gt; instances, initialized the vector with a capacity of &lt;code&gt;size&lt;/code&gt;, set up a &lt;code&gt;for&lt;/code&gt; loop that will run some code to create the threads, and returned a &lt;code&gt;ThreadPool&lt;/code&gt; instance containing them.</source>
          <target state="translated">リスト20-14のコードはコンパイルされますが、まだスレッドを作成しません。 &lt;code&gt;ThreadPool&lt;/code&gt; の定義を変更して、 &lt;code&gt;thread::JoinHandle&amp;lt;()&amp;gt;&lt;/code&gt; インスタンスのベクターを保持し、ベクターを &lt;code&gt;size&lt;/code&gt; の容量で初期化し、スレッドを作成するコードを実行する &lt;code&gt;for&lt;/code&gt; ループを設定して、それらを含む &lt;code&gt;ThreadPool&lt;/code&gt; インスタンス。</target>
        </trans-unit>
        <trans-unit id="d3a6f7dff2487d4bcc7b7e0489bef3c4a5207416" translate="yes" xml:space="preserve">
          <source>The code in Listing 20-20 is responding to requests asynchronously through the use of a thread pool, as we intended. We get some warnings about the &lt;code&gt;workers&lt;/code&gt;, &lt;code&gt;id&lt;/code&gt;, and &lt;code&gt;thread&lt;/code&gt; fields that we&amp;rsquo;re not using in a direct way that reminds us we&amp;rsquo;re not cleaning up anything. When we use the less elegant ctrl-c method to halt the main thread, all other threads are stopped immediately as well, even if they&amp;rsquo;re in the middle of serving a request.</source>
          <target state="translated">リスト20-20のコードは、意図したとおり、スレッドプールを使用して非同期的に要求に応答しています。直接使用していない &lt;code&gt;workers&lt;/code&gt; 、 &lt;code&gt;id&lt;/code&gt; 、および &lt;code&gt;thread&lt;/code&gt; フィールドについていくつかの警告が表示され、何もクリーンアップしていないことを思い出させます。あまり洗練されていないctrl-cメソッドを使用してメインスレッドを停止すると、リクエストを処理している最中であっても、他のすべてのスレッドもすぐに停止します。</target>
        </trans-unit>
        <trans-unit id="d0e7eccf6cfaca32d2f756bfec44902d0a876b0f" translate="yes" xml:space="preserve">
          <source>The code in Listing 20-20 that uses &lt;code&gt;let job = receiver.lock().unwrap().recv().unwrap();&lt;/code&gt; works because with &lt;code&gt;let&lt;/code&gt;, any temporary values used in the expression on the right hand side of the equals sign are immediately dropped when the &lt;code&gt;let&lt;/code&gt; statement ends. However, &lt;code&gt;while let&lt;/code&gt; (and &lt;code&gt;if let&lt;/code&gt; and &lt;code&gt;match&lt;/code&gt;) does not drop temporary values until the end of the associated block. In Listing 20-21, the lock remains held for the duration of the call to &lt;code&gt;job()&lt;/code&gt;, meaning other workers cannot receive jobs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9b3fdc249a44ebef0cd41734527cea5bbbbc841" translate="yes" xml:space="preserve">
          <source>The code in Listing 20-21 is responding to requests asynchronously through the use of a thread pool, as we intended. We get some warnings about the &lt;code&gt;workers&lt;/code&gt;, &lt;code&gt;id&lt;/code&gt;, and &lt;code&gt;thread&lt;/code&gt; fields that we&amp;rsquo;re not using in a direct way that reminds us we&amp;rsquo;re not cleaning up anything. When we use the less elegant ctrl-c method to halt the main thread, all other threads are stopped immediately as well, even if they&amp;rsquo;re in the middle of serving a request.</source>
          <target state="translated">リスト20-21のコードは、意図したとおり、スレッドプールを使用して非同期的にリクエストに応答しています。私たちは何もクリーンアップしていないことを思い出させる直接的な方法で使用していない、 &lt;code&gt;workers&lt;/code&gt; 、 &lt;code&gt;id&lt;/code&gt; 、および &lt;code&gt;thread&lt;/code&gt; フィールドに関するいくつかの警告を受け取ります。あまり洗練されていないctrl-cメソッドを使用してメインスレッドを停止すると、他のすべてのスレッドも、要求を処理している途中であっても、すぐに停止されます。</target>
        </trans-unit>
        <trans-unit id="af00e0657ebb48c72ab0e8023da460e28c0f23c3" translate="yes" xml:space="preserve">
          <source>The code in Listing 5-7 also creates an instance in &lt;code&gt;user2&lt;/code&gt; that has a different value for &lt;code&gt;email&lt;/code&gt; and &lt;code&gt;username&lt;/code&gt; but has the same values for the &lt;code&gt;active&lt;/code&gt; and &lt;code&gt;sign_in_count&lt;/code&gt; fields from &lt;code&gt;user1&lt;/code&gt;.</source>
          <target state="translated">リスト5-7のコードはまた、インスタンスを作成し &lt;code&gt;user2&lt;/code&gt; のために異なる値持ち &lt;code&gt;email&lt;/code&gt; と &lt;code&gt;username&lt;/code&gt; しかし同じ値がある &lt;code&gt;active&lt;/code&gt; と &lt;code&gt;sign_in_count&lt;/code&gt; からフィールド &lt;code&gt;user1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0531b3f098e465468fd76e222f809f69ed8edfae" translate="yes" xml:space="preserve">
          <source>The code in Listing 8-7 might look like it should work: why should a reference to the first element care about what changes at the end of the vector? This error is due to the way vectors work: adding a new element onto the end of the vector might require allocating new memory and copying the old elements to the new space, if there isn&amp;rsquo;t enough room to put all the elements next to each other where the vector currently is. In that case, the reference to the first element would be pointing to deallocated memory. The borrowing rules prevent programs from ending up in that situation.</source>
          <target state="translated">リスト8-7のコードは機能するように見えるかもしれません：なぜ最初の要素への参照はベクターの終わりで何が変わるのかを気にする必要があるのですか？このエラーはベクターの動作によるものです。ベクターの最後に新しい要素を追加するには、すべての要素をそれぞれの隣に配置するための十分なスペースがない場合、新しいメモリを割り当て、古い要素を新しいスペースにコピーする必要がありますベクターが現在あるその他の場所。その場合、最初の要素への参照は、割り当て解除されたメモリを指しています。借入ルールは、プログラムがそのような状況になることを防ぎます。</target>
        </trans-unit>
        <trans-unit id="94cc2f51904c3f9ddd0cfd3520b820c4eb301ad4" translate="yes" xml:space="preserve">
          <source>The code in Listing 9-4 will &lt;code&gt;panic!&lt;/code&gt; no matter why &lt;code&gt;File::open&lt;/code&gt; failed. What we want to do instead is take different actions for different failure reasons: if &lt;code&gt;File::open&lt;/code&gt; failed because the file doesn&amp;rsquo;t exist, we want to create the file and return the handle to the new file. If &lt;code&gt;File::open&lt;/code&gt; failed for any other reason&amp;mdash;for example, because we didn&amp;rsquo;t have permission to open the file&amp;mdash;we still want the code to &lt;code&gt;panic!&lt;/code&gt; in the same way as it did in Listing 9-4. Look at Listing 9-5, which adds an inner &lt;code&gt;match&lt;/code&gt; expression.</source>
          <target state="translated">リスト9-4のコードは &lt;code&gt;panic!&lt;/code&gt; なぜ &lt;code&gt;File::open&lt;/code&gt; 失敗したかは関係ありません。代わりに、さまざまな失敗の理由でさまざまなアクションを実行する必要があります。ファイルが存在しないために &lt;code&gt;File::open&lt;/code&gt; 失敗した場合は、ファイルを作成し、ハンドルを新しいファイルに返します。 &lt;code&gt;File::open&lt;/code&gt; が他の理由で失敗した場合（たとえば、ファイルを開く権限がなかったため）でも、コードに &lt;code&gt;panic!&lt;/code&gt; リスト9-4で行ったのと同じ方法で。内部 &lt;code&gt;match&lt;/code&gt; 式を追加するリスト9-5を見てください。</target>
        </trans-unit>
        <trans-unit id="e95fa13e369d6a99c35a00c2091e07ffadc180a6" translate="yes" xml:space="preserve">
          <source>The code is trying to pass &lt;code&gt;receiver&lt;/code&gt; to multiple &lt;code&gt;Worker&lt;/code&gt; instances. This won&amp;rsquo;t work, as you&amp;rsquo;ll recall from Chapter 16: the channel implementation that Rust provides is multiple &lt;em&gt;producer&lt;/em&gt;, single &lt;em&gt;consumer&lt;/em&gt;. This means we can&amp;rsquo;t just clone the consuming end of the channel to fix this code. Even if we could, that is not the technique we would want to use; instead, we want to distribute the jobs across threads by sharing the single &lt;code&gt;receiver&lt;/code&gt; among all the workers.</source>
          <target state="translated">コードは &lt;code&gt;receiver&lt;/code&gt; を複数の &lt;code&gt;Worker&lt;/code&gt; インスタンスに渡そうとしています。第16章で思い出すように、これは機能しません。Rustが提供するチャネル実装は、複数の&lt;em&gt;プロデューサー&lt;/em&gt;、単一の&lt;em&gt;コンシューマー&lt;/em&gt;です。つまり、このコードを修正するために、チャネルの使用側を複製するだけでは不十分です。たとえできたとしても、それは私たちが使いたいと思う手法ではありません。代わりに、すべてのワーカー間で単一の &lt;code&gt;receiver&lt;/code&gt; 共有することにより、スレッド間でジョブを分散させます。</target>
        </trans-unit>
        <trans-unit id="404cdeaf9f9f5734a0b6eb5da98e14aed6b8934d" translate="yes" xml:space="preserve">
          <source>The code refers to a trait that is not in scope.</source>
          <target state="translated">コードは範囲外の形質を指しています。</target>
        </trans-unit>
        <trans-unit id="f585d5dc0ef34cc30960f293fe10c97e69068fe3" translate="yes" xml:space="preserve">
          <source>The code that calls this code will then handle getting either an &lt;code&gt;Ok&lt;/code&gt; value that contains a username or an &lt;code&gt;Err&lt;/code&gt; value that contains an &lt;code&gt;io::Error&lt;/code&gt;. We don&amp;rsquo;t know what the calling code will do with those values. If the calling code gets an &lt;code&gt;Err&lt;/code&gt; value, it could call &lt;code&gt;panic!&lt;/code&gt; and crash the program, use a default username, or look up the username from somewhere other than a file, for example. We don&amp;rsquo;t have enough information on what the calling code is actually trying to do, so we propagate all the success or error information upward for it to handle appropriately.</source>
          <target state="translated">このコードを呼び出すコードは、ユーザー名を含む &lt;code&gt;Ok&lt;/code&gt; 値または &lt;code&gt;io::Error&lt;/code&gt; を含む &lt;code&gt;Err&lt;/code&gt; 値の取得を処理します。呼び出し元のコードがこれらの値で何を行うかはわかりません。呼び出しコードが &lt;code&gt;Err&lt;/code&gt; 値を取得すると、 &lt;code&gt;panic!&lt;/code&gt; 呼び出す可能性があります。たとえば、プログラムをクラッシュさせたり、デフォルトのユーザー名を使用したり、ファイル以外の場所からユーザー名を検索したりします。呼び出し元のコードが実際に何を実行しようとしているのかに関する十分な情報がないため、成功またはエラー情報をすべて上に伝播して、適切に処理します。</target>
        </trans-unit>
        <trans-unit id="cfac4f190729188f4689af6ae5b0042be7b9afad" translate="yes" xml:space="preserve">
          <source>The collection may reserve more space to avoid frequent reallocations.</source>
          <target state="translated">コレクションは頻繁な再割り当てを避けるために、より多くのスペースを確保することができます。</target>
        </trans-unit>
        <trans-unit id="a921d34f1378e463d6297235d9b237b6a37c1373" translate="yes" xml:space="preserve">
          <source>The comma following &lt;code&gt;$()&lt;/code&gt; indicates that a literal comma separator character could optionally appear after the code that matches the code in &lt;code&gt;$()&lt;/code&gt;. The &lt;code&gt;*&lt;/code&gt; specifies that the pattern matches zero or more of whatever precedes the &lt;code&gt;*&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$()&lt;/code&gt; に続くコンマは、リテラルのコンマ区切り文字が &lt;code&gt;$()&lt;/code&gt; のコードと一致するコードの後に​​オプションで表示される可能性があることを示します。 &lt;code&gt;*&lt;/code&gt; パターンが先行し何のゼロ個以上の一致するように指定します &lt;code&gt;*&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="1bacb24582ff767b21e31f4cc1ad3d6012f25a0b" translate="yes" xml:space="preserve">
          <source>The command downloads a script and starts the installation of the &lt;code&gt;rustup&lt;/code&gt; tool, which installs the latest stable version of Rust. You might be prompted for your password. If the install is successful, the following line will appear:</source>
          <target state="translated">このコマンドはスクリプトをダウンロードし、 &lt;code&gt;rustup&lt;/code&gt; ツールのインストールを開始します。これにより、Rustの最新の安定したバージョンがインストールされます。パスワードの入力を求められる場合があります。インストールが成功すると、次の行が表示されます。</target>
        </trans-unit>
        <trans-unit id="73b43b32097905758197f28a5b18a2fd54ae6279" translate="yes" xml:space="preserve">
          <source>The common part of these two paths is &lt;code&gt;std::io&lt;/code&gt;, and that&amp;rsquo;s the complete first path. To merge these two paths into one &lt;code&gt;use&lt;/code&gt; statement, we can use &lt;code&gt;self&lt;/code&gt; in the nested path, as shown in Listing 7-20.</source>
          <target state="translated">これら2つのパスの共通部分は &lt;code&gt;std::io&lt;/code&gt; であり、これが完全な最初のパスです。これらの2つのパスを1つの &lt;code&gt;use&lt;/code&gt; ステートメントにマージするには、リスト7-20に示すように、ネストされたパスで &lt;code&gt;self&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="3e8778a56f7c16d517be41bfd502f5b861a15290" translate="yes" xml:space="preserve">
          <source>The comparator function must define a total ordering for the elements in the slice. If the ordering is not total, the order of the elements is unspecified. An order is a total order if it is (for all &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;):</source>
          <target state="translated">コンパレーター関数は、スライス内の要素の全体的な順序を定義する必要があります。順序が合計でない場合、要素の順序は指定されていません。注文は、それが（ &lt;code&gt;a&lt;/code&gt; 、 &lt;code&gt;b&lt;/code&gt; 、および &lt;code&gt;c&lt;/code&gt; のすべてに対して）である場合、合計注文です。</target>
        </trans-unit>
        <trans-unit id="aebc23a2aec802159973c4b13320302322bbb426" translate="yes" xml:space="preserve">
          <source>The comparator function must define a total ordering for the elements in the slice. If the ordering is not total, the order of the elements is unspecified. An order is a total order if it is (for all a, b and c):</source>
          <target state="translated">コンパレータ関数は、スライス内の要素の合計順序を定義する必要があります。順序が合計でない場合、要素の順序は指定されません。次数は、(すべてのa,b,cに対して)であれば合計次数です。</target>
        </trans-unit>
        <trans-unit id="25646f45d8bc733d7759e265f95a900ae5f85f26" translate="yes" xml:space="preserve">
          <source>The comparator function should implement an order consistent with the sort order of the underlying &lt;code&gt;VecDeque&lt;/code&gt;, returning an order code that indicates whether its argument is &lt;code&gt;Less&lt;/code&gt;, &lt;code&gt;Equal&lt;/code&gt; or &lt;code&gt;Greater&lt;/code&gt; than the desired target.</source>
          <target state="translated">比較関数は、下のソート順と一致する順序実装する必要 &lt;code&gt;VecDeque&lt;/code&gt; 引数があるかどうかを示すためのコード戻り、 &lt;code&gt;Less&lt;/code&gt; 、 &lt;code&gt;Equal&lt;/code&gt; 又は &lt;code&gt;Greater&lt;/code&gt; 所望の標的よりもあります。</target>
        </trans-unit>
        <trans-unit id="92ccf3fc61c0a63453fa6ca42d0beca2274f875f" translate="yes" xml:space="preserve">
          <source>The comparator function should implement an order consistent with the sort order of the underlying slice, returning an order code that indicates whether its argument is &lt;code&gt;Less&lt;/code&gt;, &lt;code&gt;Equal&lt;/code&gt; or &lt;code&gt;Greater&lt;/code&gt; the desired target.</source>
          <target state="translated">コンパレーター関数は、基になるスライスの並べ替え順序と一致する順序を実装し、その引数が目的のターゲット &lt;code&gt;Less&lt;/code&gt; も &lt;code&gt;Equal&lt;/code&gt; か、等しいか、 &lt;code&gt;Greater&lt;/code&gt; かを示す順序コードを返します。</target>
        </trans-unit>
        <trans-unit id="45e688bbffc9733765a7b6aca03992e2d5e377a5" translate="yes" xml:space="preserve">
          <source>The comparison must satisfy, for all &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;:</source>
          <target state="translated">比較は、すべての &lt;code&gt;a&lt;/code&gt; 、 &lt;code&gt;b&lt;/code&gt; および &lt;code&gt;c&lt;/code&gt; について満たす必要があります。</target>
        </trans-unit>
        <trans-unit id="0c2765074489dd525efeb165a25dbc97454a652e" translate="yes" xml:space="preserve">
          <source>The compilation didn&amp;rsquo;t produce any errors, but the program resulted in a &lt;em&gt;runtime&lt;/em&gt; error and didn&amp;rsquo;t exit successfully. When you attempt to access an element using indexing, Rust will check that the index you&amp;rsquo;ve specified is less than the array length. If the index is greater than or equal to the array length, Rust will panic.</source>
          <target state="translated">コンパイルはエラーを生成しませんでしたが、プログラムは&lt;em&gt;実行時&lt;/em&gt;エラーとなり、正常に終了しませんでした。インデックスを使用して要素にアクセスしようとすると、Rustは指定したインデックスが配列の長さよりも短いことを確認します。インデックスが配列の長さ以上の場合、Rustはパニックになります。</target>
        </trans-unit>
        <trans-unit id="0a0cf1febd61e4c4aeb0165c7c721394953162c8" translate="yes" xml:space="preserve">
          <source>The compilation model centers on artifacts called &lt;em&gt;crates&lt;/em&gt;. Each compilation processes a single crate in source form, and if successful, produces a single crate in binary form: either an executable or some sort of library.&lt;sup&gt;&lt;a href=&quot;#cratesourcefile&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">コンパイルモデルは、&lt;em&gt;クレート&lt;/em&gt;と呼ばれるアーティファクトを中心としています。各コンパイルは、ソース形式の単一のクレートを処理し、成功した場合は、実行可能ファイルまたはある種のライブラリのいずれかのバイナリ形式の単一のクレートを生成します。&lt;sup&gt;&lt;a href=&quot;#cratesourcefile&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="25f0592827e30de97cacdd81a110584696dcea70" translate="yes" xml:space="preserve">
          <source>The compilation model centers on artifacts called &lt;em&gt;crates&lt;/em&gt;. Each compilation processes a single crate in source form, and if successful, produces a single crate in binary form: either an executable or some sort of library.&lt;sup&gt;&lt;a href=&quot;crates-and-source-files#cratesourcefile&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">コンパイルモデルは、&lt;em&gt;クレート&lt;/em&gt;と呼ばれるアーティファクトを中心としています。各コンパイルは、ソース形式の単一のクレートを処理し、成功した場合は、バイナリ形式の単一のクレート（実行可能ファイルまたは何らかのライブラリ）を生成します。&lt;sup&gt;&lt;a href=&quot;crates-and-source-files#cratesourcefile&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="90596055b20c856dc417525ea133e8b1049b15fa" translate="yes" xml:space="preserve">
          <source>The compiler and standard library generally tries to ensure allocations never reach a size where an offset is a concern. For instance, &lt;code&gt;Vec&lt;/code&gt; and &lt;code&gt;Box&lt;/code&gt; ensure they never allocate more than &lt;code&gt;isize::MAX&lt;/code&gt; bytes, so &lt;code&gt;vec.as_ptr().add(vec.len()).sub(vec.len())&lt;/code&gt; is always safe.</source>
          <target state="translated">コンパイラと標準ライブラリは通常、オフセットが問題となるサイズに割り当てが到達しないようにします。たとえば、 &lt;code&gt;Vec&lt;/code&gt; と &lt;code&gt;Box&lt;/code&gt; は &lt;code&gt;isize::MAX&lt;/code&gt; バイトを超えて割り当てないことを保証するため、 &lt;code&gt;vec.as_ptr().add(vec.len()).sub(vec.len())&lt;/code&gt; は常に安全です。</target>
        </trans-unit>
        <trans-unit id="59cbb1cc8a088f98671593c9041c2587a34ab70d" translate="yes" xml:space="preserve">
          <source>The compiler and standard library generally tries to ensure allocations never reach a size where an offset is a concern. For instance, &lt;code&gt;Vec&lt;/code&gt; and &lt;code&gt;Box&lt;/code&gt; ensure they never allocate more than &lt;code&gt;isize::MAX&lt;/code&gt; bytes, so &lt;code&gt;vec.as_ptr().add(vec.len())&lt;/code&gt; is always safe.</source>
          <target state="translated">コンパイラと標準ライブラリは通常、オフセットが問題となるサイズに割り当てが到達しないようにします。たとえば、 &lt;code&gt;Vec&lt;/code&gt; と &lt;code&gt;Box&lt;/code&gt; は &lt;code&gt;isize::MAX&lt;/code&gt; バイトを超えて割り当てないことを保証するため、 &lt;code&gt;vec.as_ptr().add(vec.len())&lt;/code&gt; は常に安全です。</target>
        </trans-unit>
        <trans-unit id="5647f6303a746120d1bc013678162600f20688f8" translate="yes" xml:space="preserve">
          <source>The compiler and standard library generally try to ensure allocations never reach a size where an offset is a concern. For instance, &lt;code&gt;Vec&lt;/code&gt; and &lt;code&gt;Box&lt;/code&gt; ensure they never allocate more than &lt;code&gt;isize::MAX&lt;/code&gt; bytes, so &lt;code&gt;ptr_into_vec.offset_from(vec.as_ptr())&lt;/code&gt; is always safe.</source>
          <target state="translated">コンパイラと標準ライブラリは通常、オフセットが問題となるサイズに割り当てが到達しないようにします。たとえば、 &lt;code&gt;Vec&lt;/code&gt; と &lt;code&gt;Box&lt;/code&gt; は &lt;code&gt;isize::MAX&lt;/code&gt; バイトを超えて割り当てないことを保証するため、 &lt;code&gt;ptr_into_vec.offset_from(vec.as_ptr())&lt;/code&gt; は常に安全です。</target>
        </trans-unit>
        <trans-unit id="d1adc5111740e7a8d58bceec3601a6e3d4ef92d4" translate="yes" xml:space="preserve">
          <source>The compiler could not infer a type and asked for a type annotation.</source>
          <target state="translated">コンパイラは型を推論できず、型アノテーションを要求しました。</target>
        </trans-unit>
        <trans-unit id="030993899960155dfaeaf56819f76523f90d8c36" translate="yes" xml:space="preserve">
          <source>The compiler currently implements no method of hinting what format a library should be linked with. When dynamically linking, the compiler will attempt to maximize dynamic dependencies while still allowing some dependencies to be linked in via an rlib.</source>
          <target state="translated">コンパイラは現在のところ、ライブラリがどの形式でリンクされるべきかを示唆する方法を実装していません。動的にリンクする場合、コンパイラは動的な依存関係を最大化しつつ、いくつかの依存関係を rlib 経由でリンクできるようにします。</target>
        </trans-unit>
        <trans-unit id="fe8298a5d8326c70ef926aa1826e7331454f6a26" translate="yes" xml:space="preserve">
          <source>The compiler doesn't know what method to call because more than one method has the same prototype.</source>
          <target state="translated">複数のメソッドが同じプロトタイプを持っているため、コンパイラはどのメソッドを呼べばよいかわかりません。</target>
        </trans-unit>
        <trans-unit id="1821ca1d85d61b39565f6e9976cc18b3afce261c" translate="yes" xml:space="preserve">
          <source>The compiler doesn't know what method to call because more than one method has the same prototype. Erroneous code example:</source>
          <target state="translated">複数のメソッドが同じプロトタイプを持っているため、コンパイラはどのメソッドを呼び出すべきかわかりません。誤ったコード例です。</target>
        </trans-unit>
        <trans-unit id="1be1361775707ec1fbdcf50e883b1d7b1bdb5f0d" translate="yes" xml:space="preserve">
          <source>The compiler error is as follows:</source>
          <target state="translated">コンパイラのエラーは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="b5655bf28c5aee029b50ebff36ecbfc08852001c" translate="yes" xml:space="preserve">
          <source>The compiler even reminds us that this only works with closures!</source>
          <target state="translated">コンパイラは、これはクロージャでしか動作しないことを思い出させてくれます!</target>
        </trans-unit>
        <trans-unit id="b0cba35bf39af6cdfd6b56d4dbe10dbaf77ed516" translate="yes" xml:space="preserve">
          <source>The compiler found a function whose body contains a &lt;code&gt;return;&lt;/code&gt; statement but whose return type is not &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">コンパイラーは、本体に &lt;code&gt;return;&lt;/code&gt; が含まれている関数を見つけました。ステートメントですが、戻り値の型が &lt;code&gt;()&lt;/code&gt; ではありません。</target>
        </trans-unit>
        <trans-unit id="b08f603159dc0eecd0f21f28c07166cefeb69847" translate="yes" xml:space="preserve">
          <source>The compiler found a function whose body contains a &lt;code&gt;return;&lt;/code&gt; statement but whose return type is not &lt;code&gt;()&lt;/code&gt;. An example of this is:</source>
          <target state="translated">コンパイラーは、本体に &lt;code&gt;return;&lt;/code&gt; が含まれている関数を検出しました。ステートメントですが、戻り値の型は &lt;code&gt;()&lt;/code&gt; ではありません。この例は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="3e4713e81e1fe06044671ee83362a3b9a0f5ad86" translate="yes" xml:space="preserve">
          <source>The compiler gives us this error:</source>
          <target state="translated">コンパイラはこのようなエラーを出します。</target>
        </trans-unit>
        <trans-unit id="b01feef52238a9b5f1daf51373c75b238f421fe8" translate="yes" xml:space="preserve">
          <source>The compiler is allowed to perform any combination of these optimizations, as long as the final optimized code, when executed, produces the same results as the one without optimizations.</source>
          <target state="translated">コンパイラは、最終的に最適化されたコードを実行したときに、最適化されていないコードと同じ結果が得られる限り、これらの最適化を任意に組み合わせて実行することができます。</target>
        </trans-unit>
        <trans-unit id="ec5c1119f8e1ac4ec1c89254831939480c03edd7" translate="yes" xml:space="preserve">
          <source>The compiler may allow attributes for external tools where each tool resides in its own namespace. The first segment of the attribute path is the name of the tool, with one or more additional segments whose interpretation is up to the tool.</source>
          <target state="translated">コンパイラは、各ツールが独自の名前空間に存在する外部ツールの属性を許可することができます。属性パスの最初のセグメントはツールの名前であり、1つ以上のセグメントが追加され、その解釈はツールに任されます。</target>
        </trans-unit>
        <trans-unit id="a7720aa4345b4147bab4d25831f37466e57d1fcc" translate="yes" xml:space="preserve">
          <source>The compiler prefers to capture a closed-over variable by immutable borrow, followed by unique immutable borrow (see below), by mutable borrow, and finally by move. It will pick the first choice of these that allows the closure to compile. The choice is made only with regards to the contents of the closure expression; the compiler does not take into account surrounding code, such as the lifetimes of involved variables.</source>
          <target state="translated">コンパイラは、クローズドオーバー変数をイミュータブル・ロウイング、ユニーク・イミュータブル・ロウイング(後述)、ミューータブル・ロウイング、そして最後にムーブで捕捉することを好みます。コンパイラは、これらの中から最初に選択したものを選択して、クロージャをコンパイルします。この選択はクロージャ式の内容に関してのみ行われ、コンパイラは関与する変数の寿命などの周囲のコードを考慮しません。</target>
        </trans-unit>
        <trans-unit id="5212bd9f30887e16d9c074bb9450838a12a0be2d" translate="yes" xml:space="preserve">
          <source>The compiler shouldn't change the relative order or number of volatile memory operations. However, volatile memory operations on zero-sized types (e.g., if a zero-sized type is passed to &lt;code&gt;read_volatile&lt;/code&gt;) are noops and may be ignored.</source>
          <target state="translated">コンパイラは、揮発性メモリ操作の相対的な順序や数を変更しないでください。ただし、サイズがゼロのタイプの揮発性メモリ操作（たとえば、サイズがゼロのタイプが &lt;code&gt;read_volatile&lt;/code&gt; に渡された場合）は何もしないので無視できます。</target>
        </trans-unit>
        <trans-unit id="955e9c25a8bb7d2a1fb8b16fdbf5d5e19b107461" translate="yes" xml:space="preserve">
          <source>The compiler shouldn't change the relative order or number of volatile memory operations. However, volatile memory operations on zero-sized types (e.g., if a zero-sized type is passed to &lt;code&gt;write_volatile&lt;/code&gt;) are noops and may be ignored.</source>
          <target state="translated">コンパイラは、揮発性メモリ操作の相対的な順序や数を変更しないでください。ただし、サイズがゼロのタイプの揮発性メモリ操作（たとえば、サイズがゼロのタイプが &lt;code&gt;write_volatile&lt;/code&gt; に渡された場合）は何もしないので無視できます。</target>
        </trans-unit>
        <trans-unit id="d348a40c0a7a1bd0e6bae37a48c29f90fc773ea5" translate="yes" xml:space="preserve">
          <source>The compiler supports various methods to link crates together both statically and dynamically. This section will explore the various methods to link crates together, and more information about native libraries can be found in the &lt;a href=&quot;https://doc.rust-lang.org/book/ffi.html&quot;&gt;FFI section of the book&lt;/a&gt;.</source>
          <target state="translated">コンパイラーは、静的と動的の両方でクレートをリンクするさまざまな方法をサポートしています。このセクションでは、クレートをリンクするさまざまな方法について説明します。ネイティブライブラリの詳細について&lt;a href=&quot;https://doc.rust-lang.org/book/ffi.html&quot;&gt;は、本のFFIセクションを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="e6a5c185d40ba65d2c0863bc15ff86b37643834d" translate="yes" xml:space="preserve">
          <source>The compiler then knows to not make any incorrect assumptions or optimizations on this code.</source>
          <target state="translated">コンパイラは、このコードで間違った仮定や最適化を行わないようにします。</target>
        </trans-unit>
        <trans-unit id="4f49b0710fee284944c10fc8dd575c9f675cc65d" translate="yes" xml:space="preserve">
          <source>The compiler uses three rules to figure out what lifetimes references have when there aren&amp;rsquo;t explicit annotations. The first rule applies to input lifetimes, and the second and third rules apply to output lifetimes. If the compiler gets to the end of the three rules and there are still references for which it can&amp;rsquo;t figure out lifetimes, the compiler will stop with an error. These rules apply to &lt;code&gt;fn&lt;/code&gt; definitions as well as &lt;code&gt;impl&lt;/code&gt; blocks.</source>
          <target state="translated">コンパイラは3つのルールを使用して、明示的な注釈がない場合の参照のライフタイムを把握します。最初のルールは入力ライフタイムに適用され、2番目と3番目のルールは出力ライフタイムに適用されます。コンパイラーが3つのルールの終わりに達しても、存続期間を計算できない参照がまだある場合、コンパイラーはエラーで停止します。これらのルールは、 &lt;code&gt;fn&lt;/code&gt; 定義と &lt;code&gt;impl&lt;/code&gt; ブロックに適用されます。</target>
        </trans-unit>
        <trans-unit id="433b36c96c38bd66008e924fa1864ced83fcb794" translate="yes" xml:space="preserve">
          <source>The compiler will complain that it needs lifetime specifiers:</source>
          <target state="translated">コンパイラはライフタイム指定子が必要だと文句を言います。</target>
        </trans-unit>
        <trans-unit id="572859abb18057fb674dd21429d06414b40c8275" translate="yes" xml:space="preserve">
          <source>The compiler will determine which of the &lt;a href=&quot;../types/closure#call-traits-and-coercions&quot;&gt;closure traits&lt;/a&gt; the closure's type will implement by how it acts on its captured variables. The closure will also implement &lt;a href=&quot;../special-types-and-traits#send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt; and/or &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; if all of its captured types do. These traits allow functions to accept closures using generics, even though the exact types can't be named.</source>
          <target state="translated">コンパイラーは、キャプチャーされた変数にどのように作用するかによって、クロージャーのタイプがどの&lt;a href=&quot;../types/closure#call-traits-and-coercions&quot;&gt;クロージャー特性&lt;/a&gt;を実装するかを決定します。クロージャーは、キャプチャーされたすべてのタイプがそうである場合、&lt;a href=&quot;../special-types-and-traits#send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt;および/または&lt;a href=&quot;../special-types-and-traits#sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt;も実装します。これらの特性により、正確な型に名前を付けることができない場合でも、関数はジェネリックを使用してクロージャを受け入れることができます。</target>
        </trans-unit>
        <trans-unit id="948f1a92a83b2e1e3378ae6b818bd73449ba504b" translate="yes" xml:space="preserve">
          <source>The compiler will indicate when you&amp;rsquo;re trying to do something that violates the rules of object safety in regard to trait objects. For example, let&amp;rsquo;s say we tried to implement the &lt;code&gt;Screen&lt;/code&gt; struct in Listing 17-4 to hold types that implement the &lt;code&gt;Clone&lt;/code&gt; trait instead of the &lt;code&gt;Draw&lt;/code&gt; trait, like this:</source>
          <target state="translated">コンパイラーは、トレイトオブジェクトに関してオブジェクトの安全性のルールに違反することを実行しようとしていることを示します。たとえば、次のように、 &lt;code&gt;Draw&lt;/code&gt; トレイトの代わりに &lt;code&gt;Clone&lt;/code&gt; トレイトを実装する型を保持するために、リスト17-4の &lt;code&gt;Screen&lt;/code&gt; 構造体を実装しようとしたとします。</target>
        </trans-unit>
        <trans-unit id="0946476a608603480a8c85b783bae37331306e67" translate="yes" xml:space="preserve">
          <source>The compiler, in general, assumes that a variable is properly initialized according to the requirements of the variable's type. For example, a variable of reference type must be aligned and non-NULL. This is an invariant that must &lt;em&gt;always&lt;/em&gt; be upheld, even in unsafe code. As a consequence, zero-initializing a variable of reference type causes instantaneous &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;undefined behavior&lt;/a&gt;, no matter whether that reference ever gets used to access memory:</source>
          <target state="translated">一般に、コンパイラは、変数の型の要件に従って変数が適切に初期化されることを前提としています。たとえば、参照型の変数は整列され、NULL以外である必要があります。これは不変条件であり、安全でないコードであっても&lt;em&gt;常に&lt;/em&gt;維持する必要&lt;em&gt;が&lt;/em&gt;あります。結果として、参照型の変数をゼロで初期化すると、その参照がメモリへのアクセスに使用されるかどうかに関係なく、瞬時に&lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;未定義の動作&lt;/a&gt;が発生します。</target>
        </trans-unit>
        <trans-unit id="a84c7a7769bfd766452d6377b59bc8d2e574c64c" translate="yes" xml:space="preserve">
          <source>The compiler, in general, assumes that variables are properly initialized at their respective type. For example, a variable of reference type must be aligned and non-NULL. This is an invariant that must &lt;em&gt;always&lt;/em&gt; be upheld, even in unsafe code. As a consequence, zero-initializing a variable of reference type causes instantaneous &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;undefined behavior&lt;/a&gt;, no matter whether that reference ever gets used to access memory:</source>
          <target state="translated">一般に、コンパイラーは、変数がそれぞれの型で適切に初期化されていることを前提としています。たとえば、参照型の変数は整列され、NULL以外である必要があります。これは、安全ではないコードであっても&lt;em&gt;常に&lt;/em&gt;守らなければならない不変条件です。結果として、参照型の変数をゼロ初期化すると、その参照がメモリへのアクセスに使用されるかどうかに関係なく、&lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;定義されていない動作&lt;/a&gt;が瞬時に発生します。</target>
        </trans-unit>
        <trans-unit id="4ed049edf6523bee71aa6c2cc8dac47d3acb83f3" translate="yes" xml:space="preserve">
          <source>The computed offset cannot exceed &lt;code&gt;isize::MAX&lt;/code&gt;&lt;strong&gt;bytes&lt;/strong&gt;.</source>
          <target state="translated">計算されたオフセットは &lt;code&gt;isize::MAX&lt;/code&gt; &lt;strong&gt;バイトを&lt;/strong&gt;超えることはできません。</target>
        </trans-unit>
        <trans-unit id="4f78f76fdf78ce465bd63ef1c725533fd764ba85" translate="yes" xml:space="preserve">
          <source>The computed offset, &lt;strong&gt;in bytes&lt;/strong&gt;, cannot overflow an &lt;code&gt;isize&lt;/code&gt;.</source>
          <target state="translated">計算されたオフセット（&lt;strong&gt;バイト単位&lt;/strong&gt;）は &lt;code&gt;isize&lt;/code&gt; をオーバーフローできません。</target>
        </trans-unit>
        <trans-unit id="63f5ab3561e8fa530abb7afbb885243679cbd27d" translate="yes" xml:space="preserve">
          <source>The concatenation &amp;alpha; &amp;beta; &amp;gamma; &amp;delta; is a parseable Rust program.</source>
          <target state="translated">連結&amp;alpha;&amp;beta;&amp;gamma;&amp;delta;は解析可能なRustプログラムです。</target>
        </trans-unit>
        <trans-unit id="026ad0f5294d67f94938651fe3bfaacf62c15a89" translate="yes" xml:space="preserve">
          <source>The concept of lifetimes is somewhat different from tools in other programming languages, arguably making lifetimes Rust&amp;rsquo;s most distinctive feature. Although we won&amp;rsquo;t cover lifetimes in their entirety in this chapter, we&amp;rsquo;ll discuss common ways you might encounter lifetime syntax so you can become familiar with the concepts.</source>
          <target state="translated">ライフタイムの概念は他のプログラミング言語のツールとは多少異なり、おそらくライフタイムをRustの最も特徴的な機能にしています。この章ではライフタイム全体を取り上げませんが、コンセプトに慣れるために、ライフタイム構文に遭遇する一般的な方法について説明します。</target>
        </trans-unit>
        <trans-unit id="bf8b3cea5648a2c56269d845203de953f7dc58d3" translate="yes" xml:space="preserve">
          <source>The concepts of ownership, borrowing, and slices ensure memory safety in Rust programs at compile time. The Rust language gives you control over your memory usage in the same way as other systems programming languages, but having the owner of data automatically clean up that data when the owner goes out of scope means you don&amp;rsquo;t have to write and debug extra code to get this control.</source>
          <target state="translated">所有権、借用、およびスライスの概念は、コンパイル時にRustプログラムのメモリの安全性を保証します。Rust言語を使用すると、他のシステムプログラミング言語と同じようにメモリ使用量を制御できますが、データの所有者がスコープ外に出たときにデータの所有者が自動的にクリーンアップするため、追加のコードを記述してデバッグする必要がありません。このコントロールを取得します。</target>
        </trans-unit>
        <trans-unit id="5484608e7530a94c46507f1fbbbe29684e230d84" translate="yes" xml:space="preserve">
          <source>The condition can use variables created in the pattern. Listing 18-26 shows a &lt;code&gt;match&lt;/code&gt; where the first arm has the pattern &lt;code&gt;Some(x)&lt;/code&gt; and also has a match guard of &lt;code&gt;if x &amp;lt; 5&lt;/code&gt;.</source>
          <target state="translated">条件には、パターンで作成された変数を使用できます。18-26番組リスト &lt;code&gt;match&lt;/code&gt; 最初アームパターン有する &lt;code&gt;Some(x)&lt;/code&gt; 、またの一致ガード有する &lt;code&gt;if x &amp;lt; 5&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c47359692fd118dbc5a64f61c4a95c135750d6d3" translate="yes" xml:space="preserve">
          <source>The condition expression of an &lt;code&gt;if&lt;/code&gt; or &lt;code&gt;while&lt;/code&gt; expression, or a &lt;code&gt;match&lt;/code&gt; guard.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; または &lt;code&gt;while&lt;/code&gt; 式の条件式、または &lt;code&gt;match&lt;/code&gt; ガード。</target>
        </trans-unit>
        <trans-unit id="095096dc5e2804946ad94bae4f75159f2bd38855" translate="yes" xml:space="preserve">
          <source>The condition in an &lt;a href=&quot;keyword.if&quot;&gt;&lt;code&gt;if&lt;/code&gt;&lt;/a&gt; expression must be of type &lt;code&gt;bool&lt;/code&gt;. Whenever that condition evaluates to &lt;strong&gt;true&lt;/strong&gt;, the &lt;code&gt;if&lt;/code&gt; expression takes on the value of the first block. If however, the condition evaluates to &lt;code&gt;false&lt;/code&gt;, the expression takes on value of the &lt;code&gt;else&lt;/code&gt; block if there is one.</source>
          <target state="translated">&lt;a href=&quot;keyword.if&quot;&gt; &lt;code&gt;if&lt;/code&gt; &lt;/a&gt;式の条件は &lt;code&gt;bool&lt;/code&gt; 型でなければなりません。その条件が&lt;strong&gt;true&lt;/strong&gt;と評価されるときはいつでも、 &lt;code&gt;if&lt;/code&gt; 式は最初のブロックの値を取ります。ただし、条件が &lt;code&gt;false&lt;/code&gt; と評価された場合、式は &lt;code&gt;else&lt;/code&gt; ブロックがあればその値を取ります。</target>
        </trans-unit>
        <trans-unit id="75d37ae80df9e59cac39010c72ed606ee381207c" translate="yes" xml:space="preserve">
          <source>The condition we want to check in the inner match is whether the value returned by &lt;code&gt;error.kind()&lt;/code&gt; is the &lt;code&gt;NotFound&lt;/code&gt; variant of the &lt;code&gt;ErrorKind&lt;/code&gt; enum. If it is, we try to create the file with &lt;code&gt;File::create&lt;/code&gt;. However, because &lt;code&gt;File::create&lt;/code&gt; could also fail, we need a second arm in the inner &lt;code&gt;match&lt;/code&gt; expression. When the file can&amp;rsquo;t be created, a different error message is printed. The second arm of the outer &lt;code&gt;match&lt;/code&gt; stays the same, so the program panics on any error besides the missing file error.</source>
          <target state="translated">私たちは、内側試合にチェックしたい条件がで返される値であるかどうかを &lt;code&gt;error.kind()&lt;/code&gt; である &lt;code&gt;NotFound&lt;/code&gt; のバリアント &lt;code&gt;ErrorKind&lt;/code&gt; を列挙。もしそうなら、 &lt;code&gt;File::create&lt;/code&gt; でファイルを作成しようとします。ただし、 &lt;code&gt;File::create&lt;/code&gt; も失敗する可能性があるため、内側の &lt;code&gt;match&lt;/code&gt; 式に2つ目のアームが必要です。ファイルを作成できない場合は、別のエラーメッセージが出力されます。外側の &lt;code&gt;match&lt;/code&gt; の2番目のアームは同じままなので、プログラムはファイルが見つからないエラー以外のエラーでパニックになります。</target>
        </trans-unit>
        <trans-unit id="6c5b1587da56cf50f7a60ae4167ed8ca12fc4a83" translate="yes" xml:space="preserve">
          <source>The conditions in which you&amp;rsquo;re allowed or not allowed to implement the trait</source>
          <target state="translated">トレイトの実装が許可または禁止されている条件</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
