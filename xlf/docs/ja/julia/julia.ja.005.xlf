<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="julia">
    <body>
      <group id="julia">
        <trans-unit id="e370a7226632723025763723f6dafd8d5d0d959c" translate="yes" xml:space="preserve">
          <source>And With Dot</source>
          <target state="translated">そして、ドットと一緒に</target>
        </trans-unit>
        <trans-unit id="fbef2e39e8fb91e6824e3edcfe418b3f32f423c2" translate="yes" xml:space="preserve">
          <source>And using that testset looks like:</source>
          <target state="translated">そして、そのテストセットを使用すると、次のようになります。</target>
        </trans-unit>
        <trans-unit id="1f5999305ceff8dd17e050846ba5e997ba6e59ae" translate="yes" xml:space="preserve">
          <source>Anger Symbol</source>
          <target state="translated">怒りのシンボル</target>
        </trans-unit>
        <trans-unit id="1fd70473fb3de634b409d4acaf49ffc1f90aae1f" translate="yes" xml:space="preserve">
          <source>Angle</source>
          <target state="translated">Angle</target>
        </trans-unit>
        <trans-unit id="b2a770be59cfda02ac18ae81ca3c69433ca33eac" translate="yes" xml:space="preserve">
          <source>Angle With S Inside</source>
          <target state="translated">内側のSとの角度</target>
        </trans-unit>
        <trans-unit id="2f17bd9fe54b168046c3599d1ee65207477b51c2" translate="yes" xml:space="preserve">
          <source>Angle With Underbar</source>
          <target state="translated">アンダーバーとの角度</target>
        </trans-unit>
        <trans-unit id="235bfce3d68318529750179e362f5eb792952c9e" translate="yes" xml:space="preserve">
          <source>Angry Face</source>
          <target state="translated">怒り顔</target>
        </trans-unit>
        <trans-unit id="5dcf9d8e34d0e0dc6accf2e555a98e501316d5eb" translate="yes" xml:space="preserve">
          <source>Angstrom Sign / Angstrom Unit</source>
          <target state="translated">アングストロームサイン/アングストロームユニット</target>
        </trans-unit>
        <trans-unit id="51cb7e1a070afb2a7be72806c484010b0b12881a" translate="yes" xml:space="preserve">
          <source>Anguished Face</source>
          <target state="translated">苦悩した顔</target>
        </trans-unit>
        <trans-unit id="0a391a1d197db6b3528b4037a38a99b886bf2ca2" translate="yes" xml:space="preserve">
          <source>Annotate a &lt;code&gt;for&lt;/code&gt; loop to allow the compiler to take extra liberties to allow loop re-ordering</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; ループに注釈を付けて、コンパイラーが追加の自由を取り、ループの並べ替えを可能にする</target>
        </trans-unit>
        <trans-unit id="7c44ae2875c05d9e420a1ee94f547ea8d42d5f9f" translate="yes" xml:space="preserve">
          <source>Annotate values taken from untyped locations</source>
          <target state="translated">タイプされていない場所から取得した値をアノテーションする</target>
        </trans-unit>
        <trans-unit id="80abb045be1e210007d2a8998883d6f2947e4f8f" translate="yes" xml:space="preserve">
          <source>Annotates the expression &lt;code&gt;blk&lt;/code&gt; as a bounds checking block, allowing it to be elided by &lt;a href=&quot;#Base.@inbounds&quot;&gt;&lt;code&gt;@inbounds&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">式 &lt;code&gt;blk&lt;/code&gt; に境界チェックブロックとして注釈を付け、&lt;a href=&quot;#Base.@inbounds&quot;&gt; &lt;code&gt;@inbounds&lt;/code&gt; &lt;/a&gt;によってそれを省略できるようにします。</target>
        </trans-unit>
        <trans-unit id="6f497993755de46018a5ff1778be3f6bc999629d" translate="yes" xml:space="preserve">
          <source>Anonymous Functions</source>
          <target state="translated">匿名機能</target>
        </trans-unit>
        <trans-unit id="3f2245e0442788d1d0364df60f4a6e67754d3e89" translate="yes" xml:space="preserve">
          <source>Another common solution is to separate the reader and writer of the pipeline into separate &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;s:</source>
          <target state="translated">別の一般的な解決策は、パイプラインのリーダーとライターを別々の&lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt;に分離することです。</target>
        </trans-unit>
        <trans-unit id="fcd743f506f81055a92cce92b547fdb1e7daceb8" translate="yes" xml:space="preserve">
          <source>Another helper type is currently available for other cases, &lt;code&gt;Random.SamplerTag&lt;/code&gt;, but is considered as internal API, and can break at any time without proper deprecations.</source>
          <target state="translated">別のヘルパータイプは現在、他のケースで使用できる &lt;code&gt;Random.SamplerTag&lt;/code&gt; ですが、内部APIと見なされており、適切に非推奨にすることなくいつでも中断できます。</target>
        </trans-unit>
        <trans-unit id="9b1d07d46031acec2c359f730da8bb2e51e75efb" translate="yes" xml:space="preserve">
          <source>Another non-standard version specification extension allows one to use a trailing &lt;code&gt;+&lt;/code&gt; to express an upper limit on build versions, e.g. &lt;code&gt;VERSION &amp;gt; v&quot;0.2-rc1+&quot;&lt;/code&gt; can be used to mean any version above &lt;code&gt;0.2-rc1&lt;/code&gt; and any of its builds: it will return &lt;code&gt;false&lt;/code&gt; for version &lt;code&gt;v&quot;0.2-rc1+win64&quot;&lt;/code&gt; and &lt;code&gt;true&lt;/code&gt; for &lt;code&gt;v&quot;0.2-rc2&quot;&lt;/code&gt;.</source>
          <target state="translated">もう1つの非標準バージョン仕様拡張により、末尾の &lt;code&gt;+&lt;/code&gt; を使用してビルドバージョンの上限を表すことができます。たとえば、 &lt;code&gt;VERSION &amp;gt; v&quot;0.2-rc1+&quot;&lt;/code&gt; は、 &lt;code&gt;0.2-rc1&lt;/code&gt; を超えるバージョンとそのビルドを意味します。戻ります &lt;code&gt;false&lt;/code&gt; バージョンのための &lt;code&gt;v&quot;0.2-rc1+win64&quot;&lt;/code&gt; と &lt;code&gt;true&lt;/code&gt; のための &lt;code&gt;v&quot;0.2-rc2&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2f1f671807b09bc4fbe1759ebf099879c030bdbf" translate="yes" xml:space="preserve">
          <source>Another operation that applies to some types is &lt;a href=&quot;../../base/base/index#Base.supertype&quot;&gt;&lt;code&gt;supertype&lt;/code&gt;&lt;/a&gt;, which reveals a type's supertype. Only declared types (&lt;code&gt;DataType&lt;/code&gt;) have unambiguous supertypes:</source>
          <target state="translated">いくつかのタイプに適用される別の操作がある&lt;a href=&quot;../../base/base/index#Base.supertype&quot;&gt; &lt;code&gt;supertype&lt;/code&gt; &lt;/a&gt;タイプのスーパータイプを明らかにし、。宣言された型（ &lt;code&gt;DataType&lt;/code&gt; ）のみに明確なスーパータイプがあります。</target>
        </trans-unit>
        <trans-unit id="937a3e6d6c5697202a728546d5a94531a97deb3c" translate="yes" xml:space="preserve">
          <source>Another possibility is the following, which could useful to adapt to cases where the parameter &lt;code&gt;T&lt;/code&gt; would need to be matched more narrowly:</source>
          <target state="translated">別の可能性は次のとおりです。これは、パラメーター &lt;code&gt;T&lt;/code&gt; をより厳密に一致させる必要がある場合に適応するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="934eafc149de740d97fce8516adf5aa645737af2" translate="yes" xml:space="preserve">
          <source>Another useful non-standard string literal is the byte-array string literal: &lt;code&gt;b&quot;...&quot;&lt;/code&gt;. This form lets you use string notation to express read only literal byte arrays &amp;ndash; i.e. arrays of &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt;&lt;code&gt;UInt8&lt;/code&gt;&lt;/a&gt; values. The type of those objects is &lt;code&gt;CodeUnits{UInt8, String}&lt;/code&gt;. The rules for byte array literals are the following:</source>
          <target state="translated">もう1つの便利な非標準の文字列リテラルは、バイト配列文字列リテラル： &lt;code&gt;b&quot;...&quot;&lt;/code&gt; です。この形式では、文字列表記を使用して、読み取り専用のリテラルバイト配列（つまり、&lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt; &lt;code&gt;UInt8&lt;/code&gt; &lt;/a&gt;値の配列）を表現できます。これらのオブジェクトのタイプは &lt;code&gt;CodeUnits{UInt8, String}&lt;/code&gt; です。バイト配列リテラルの規則は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="30b18c65665f6fdbc3c1e0c1e53afe0ef7b0746f" translate="yes" xml:space="preserve">
          <source>Another way to create a sparse array is to convert a dense array into a sparse array using the &lt;a href=&quot;#SparseArrays.sparse&quot;&gt;&lt;code&gt;sparse&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">スパース配列を作成する別の方法は、関数&lt;a href=&quot;#SparseArrays.sparse&quot;&gt; &lt;code&gt;sparse&lt;/code&gt; &lt;/a&gt;を使用して、密配列をスパース配列に変換することです。</target>
        </trans-unit>
        <trans-unit id="d71bbbddbab448cf2f4551f57f136f71cf39aeab" translate="yes" xml:space="preserve">
          <source>Another way to view expressions is with &lt;code&gt;Meta.show_sexpr&lt;/code&gt;, which displays the &lt;a href=&quot;https://en.wikipedia.org/wiki/S-expression&quot;&gt;S-expression&lt;/a&gt; form of a given &lt;code&gt;Expr&lt;/code&gt;, which may look very familiar to users of Lisp. Here's an example illustrating the display on a nested &lt;code&gt;Expr&lt;/code&gt;:</source>
          <target state="translated">式を表示するもう1つの方法は、 &lt;code&gt;Meta.show_sexpr&lt;/code&gt; を使用することです。これは、指定された &lt;code&gt;Expr&lt;/code&gt; の&lt;a href=&quot;https://en.wikipedia.org/wiki/S-expression&quot;&gt;S式&lt;/a&gt;形式を表示します。これは、Lispのユーザーには非常に馴染みがあるようです。ネストされた &lt;code&gt;Expr&lt;/code&gt; での表示を示す例を次に示します。</target>
        </trans-unit>
        <trans-unit id="5468d9df43f9dcdfb8b8b349ce3a001cd05b665d" translate="yes" xml:space="preserve">
          <source>Another way, which used to be the only correct way before the advent of triangular dispatch in Julia v0.6, is:</source>
          <target state="translated">もう一つの方法は、Julia v0.6で三角ディスパッチが登場する前は、これが唯一の正しい方法でした。</target>
        </trans-unit>
        <trans-unit id="02cc2a69720bd8bf1661deb23018e16470c069da" translate="yes" xml:space="preserve">
          <source>Ant</source>
          <target state="translated">Ant</target>
        </trans-unit>
        <trans-unit id="e25592206c84c0ddd18d548ca6206d3d080aef04" translate="yes" xml:space="preserve">
          <source>Antenna With Bars</source>
          <target state="translated">バー付きアンテナ</target>
        </trans-unit>
        <trans-unit id="27823909809855dca3ee48ccda6c67818ef39511" translate="yes" xml:space="preserve">
          <source>Anticlockwise Contour Integral</source>
          <target state="translated">反時計回り等高線積分</target>
        </trans-unit>
        <trans-unit id="777a29798f3d057ac8c6bab9cead4b05d966905b" translate="yes" xml:space="preserve">
          <source>Anticlockwise Downwards And Upwards Open Circle Arrows</source>
          <target state="translated">反時計回りに下向きに、上向きに開いた円の矢印</target>
        </trans-unit>
        <trans-unit id="e5cdf19e981398168cc33d41c80123d3c30a5081" translate="yes" xml:space="preserve">
          <source>Anticlockwise Integration</source>
          <target state="translated">反時計回りの統合</target>
        </trans-unit>
        <trans-unit id="4ffeb49d53fc5643e555514643bbb1df4f049794" translate="yes" xml:space="preserve">
          <source>Anticlockwise Open Circle Arrow</source>
          <target state="translated">反時計回りのオープンサークル矢印</target>
        </trans-unit>
        <trans-unit id="a52271b2a7c6cb5d3c1c456396438c1ddb68a4f9" translate="yes" xml:space="preserve">
          <source>Anticlockwise Top Semicircle Arrow</source>
          <target state="translated">反時計回り上半円矢印</target>
        </trans-unit>
        <trans-unit id="b661ec502ce7eec63576ef6980de816514a82733" translate="yes" xml:space="preserve">
          <source>Any changes you make to the array values (e.g., &lt;code&gt;A[3] = 0&lt;/code&gt;) will also change the values on disk</source>
          <target state="translated">配列の値を変更すると（例： &lt;code&gt;A[3] = 0&lt;/code&gt; ）、ディスクの値も変更されます</target>
        </trans-unit>
        <trans-unit id="3c5cca19d4f5741a5bb3f294473a79e10b7adbb5" translate="yes" xml:space="preserve">
          <source>Any code that is performance critical or being benchmarked should be inside a function.</source>
          <target state="translated">パフォーマンスが重要なコードやベンチマークされているコードは、関数の中に入れてください。</target>
        </trans-unit>
        <trans-unit id="ba5b886162caf15daa7473ff8070c0f84e6be971" translate="yes" xml:space="preserve">
          <source>Any custom array of scalar indices that is a subtype of &lt;code&gt;AbstractArray&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;AbstractArray&lt;/code&gt; のサブタイプであるスカラーインデックスのカスタム配列</target>
        </trans-unit>
        <trans-unit id="2973d806e6f61582719d2e58b280fa916079cead" translate="yes" xml:space="preserve">
          <source>Any custom testset type (subtype of &lt;code&gt;AbstractTestSet&lt;/code&gt;) can be given and it will also be used for any nested &lt;code&gt;@testset&lt;/code&gt; invocations. The given options are only applied to the test set where they are given. The default test set type does not take any options.</source>
          <target state="translated">カスタムテストセットタイプ（ &lt;code&gt;AbstractTestSet&lt;/code&gt; のサブタイプ）を指定でき、ネストされた &lt;code&gt;@testset&lt;/code&gt; 呼び出しにも使用されます。指定されたオプションは、指定されたテストセットにのみ適用されます。デフォルトのテストセットタイプには、オプションはありません。</target>
        </trans-unit>
        <trans-unit id="31544d9a7acaba7c1156850319c97b90ce13cb9b" translate="yes" xml:space="preserve">
          <source>Any error stops &lt;code&gt;pmap&lt;/code&gt; from processing the remainder of the collection. To override this behavior you can specify an error handling function via argument &lt;code&gt;on_error&lt;/code&gt; which takes in a single argument, i.e., the exception. The function can stop the processing by rethrowing the error, or, to continue, return any value which is then returned inline with the results to the caller.</source>
          <target state="translated">エラーが発生すると、 &lt;code&gt;pmap&lt;/code&gt; は残りのコレクションを処理できなくなります。この動作をオーバーライドするには、単一の引数、つまり例外を &lt;code&gt;on_error&lt;/code&gt; 引数on_errorを介してエラー処理関数を指定できます。関数は、エラーを再スローすることで処理を停止するか、続行するには、結果と一緒に呼び出し元にインラインで返される任意の値を返すことができます。</target>
        </trans-unit>
        <trans-unit id="fc28c907456157bf36df33491d1dd60e94bbee1e" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by &lt;code&gt;f&lt;/code&gt; are printed to &lt;a href=&quot;../../base/io-network/index#Base.stderr&quot;&gt;&lt;code&gt;stderr&lt;/code&gt;&lt;/a&gt; on the remote worker.</source>
          <target state="translated">スローされるすべての例外 &lt;code&gt;f&lt;/code&gt; がに印刷され&lt;a href=&quot;../../base/io-network/index#Base.stderr&quot;&gt; &lt;code&gt;stderr&lt;/code&gt; の&lt;/a&gt;リモート作業員に。</target>
        </trans-unit>
        <trans-unit id="74b6431314c500d9367b1ee7e25039a738c25b54" translate="yes" xml:space="preserve">
          <source>Any keyword arguments passed to &lt;code&gt;eigen&lt;/code&gt; are passed through to the lower-level &lt;a href=&quot;#LinearAlgebra.eigen!&quot;&gt;&lt;code&gt;eigen!&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;code&gt;eigen&lt;/code&gt; に渡されるキーワード引数はすべて、下位レベルの&lt;a href=&quot;#LinearAlgebra.eigen!&quot;&gt; &lt;code&gt;eigen!&lt;/code&gt; &lt;/a&gt;渡されます。関数。</target>
        </trans-unit>
        <trans-unit id="409446f789565d016b86ac80357893528260dc10" translate="yes" xml:space="preserve">
          <source>Any number of expressions many be documented together in this way. This syntax can be useful when two functions are related, such as non-mutating and mutating versions &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;f!&lt;/code&gt;.</source>
          <target state="translated">このようにして、任意の数の式をまとめて文書化できます。この構文は、2つの関数が関連している場合（たとえば、非変更バージョンと変更バージョン &lt;code&gt;f&lt;/code&gt; および &lt;code&gt;f!&lt;/code&gt; など）に役立ちます。。</target>
        </trans-unit>
        <trans-unit id="0687dd78d1b30c2783be213375797ef6105a33d2" translate="yes" xml:space="preserve">
          <source>Any object that defines this function is iterable and can be used in the &lt;a href=&quot;../../base/collections/index#lib-collections-iteration&quot;&gt;many functions that rely upon iteration&lt;/a&gt;. It can also be used directly in a &lt;a href=&quot;../../base/base/index#for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt; loop since the syntax:</source>
          <target state="translated">この関数を定義するオブジェクトはすべて反復可能であり&lt;a href=&quot;../../base/collections/index#lib-collections-iteration&quot;&gt;、反復に依存する多くの関数で&lt;/a&gt;使用できます。構文が次のようになっている&lt;a href=&quot;../../base/base/index#for&quot;&gt; &lt;code&gt;for&lt;/code&gt; &lt;/a&gt;、forループで直接使用することもできます。</target>
        </trans-unit>
        <trans-unit id="f23555229abe2136eae4796de9adb4981c0efa50" translate="yes" xml:space="preserve">
          <source>Any object that defines this function is iterable and can be used in the &lt;a href=&quot;../../base/collections/index#lib-collections-iteration-1&quot;&gt;many functions that rely upon iteration&lt;/a&gt;. It can also be used directly in a &lt;a href=&quot;../../base/base/index#for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt; loop since the syntax:</source>
          <target state="translated">この関数を定義するオブジェクトは反復可能であり&lt;a href=&quot;../../base/collections/index#lib-collections-iteration-1&quot;&gt;、反復に依存する多くの関数で&lt;/a&gt;使用できます。次の構文により、&lt;a href=&quot;../../base/base/index#for&quot;&gt; &lt;code&gt;for&lt;/code&gt; &lt;/a&gt;ループで直接使用することもできます。</target>
        </trans-unit>
        <trans-unit id="14a4faaa9263f21666bc118177b8030fb0ebed4a" translate="yes" xml:space="preserve">
          <source>Any object that is not a type is not an instance of &lt;code&gt;Type&lt;/code&gt;:</source>
          <target state="translated">タイプではないオブジェクトは &lt;code&gt;Type&lt;/code&gt; のインスタンスではありません。</target>
        </trans-unit>
        <trans-unit id="5099776907c27052bfc78cf7373b0d68a21ec5f2" translate="yes" xml:space="preserve">
          <source>Any operation that throws an error is probably currently unimplemented and should be posted as a bug so that it can be resolved.</source>
          <target state="translated">エラーを投げる操作は、おそらく現在実装されていないと思われますので、バグとして投稿して解決するようにしてください。</target>
        </trans-unit>
        <trans-unit id="f91c503ff4942107fdfd3a5ddc75b8099dc08779" translate="yes" xml:space="preserve">
          <source>Any process with a reference to a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt; can put and take items from the channel. Data is automatically sent to (or retrieved from) the process a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt; is associated with.</source>
          <target state="translated">&lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; &lt;/a&gt;への参照を持つすべてのプロセスは、チャネルからアイテムを配置および取得できます。データは、&lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; &lt;/a&gt;が関連付けられているプロセスに自動的に送信されます（またはプロセスから取得されます）。</target>
        </trans-unit>
        <trans-unit id="7c010ba08796a2114052ab863fb8a9d226c9dd13" translate="yes" xml:space="preserve">
          <source>Apl Functional Symbol Backslash Bar</source>
          <target state="translated">Apl 機能記号バックスラッシュバー</target>
        </trans-unit>
        <trans-unit id="36d891e0ee22f437cc243dd2e9ea0702d961b80f" translate="yes" xml:space="preserve">
          <source>Apl Functional Symbol Circle Stile</source>
          <target state="translated">Apl 機能シンボルサークル・スティル</target>
        </trans-unit>
        <trans-unit id="39c46b8ef7910ae74868b76b650aa07198ab578c" translate="yes" xml:space="preserve">
          <source>Apl Functional Symbol I-Beam</source>
          <target state="translated">Apl 機能シンボル I-Beam</target>
        </trans-unit>
        <trans-unit id="d0546025dd10b13f2435dc3fcaee9e017037a2e5" translate="yes" xml:space="preserve">
          <source>Apl Functional Symbol Quad Question</source>
          <target state="translated">Apl機能シンボル クワッド問題</target>
        </trans-unit>
        <trans-unit id="4d565c437bb750fa8a1eb8171844a8039a97d351" translate="yes" xml:space="preserve">
          <source>Apl Functional Symbol Quad Up Caret</source>
          <target state="translated">Apl 機能シンボル クワッドアップキャレット</target>
        </trans-unit>
        <trans-unit id="2b164c5aca8328b895ebe3a8c42bb636c6e38b33" translate="yes" xml:space="preserve">
          <source>Apl Functional Symbol Slash Bar</source>
          <target state="translated">Apl 機能記号スラッシュバー</target>
        </trans-unit>
        <trans-unit id="259f6ae1ad06c26f4f50971a4ed64fd704fd9a77" translate="yes" xml:space="preserve">
          <source>Append &lt;code&gt;!&lt;/code&gt; to names of functions that modify their arguments</source>
          <target state="translated">追加 &lt;code&gt;!&lt;/code&gt; 引数を変更する関数の名前に</target>
        </trans-unit>
        <trans-unit id="93f34880658a83722dbec3227ce96d931d512e39" translate="yes" xml:space="preserve">
          <source>Append an item &lt;code&gt;v&lt;/code&gt; to the channel &lt;code&gt;c&lt;/code&gt;. Blocks if the channel is full.</source>
          <target state="translated">アイテムの追加 &lt;code&gt;v&lt;/code&gt; チャネルに &lt;code&gt;c&lt;/code&gt; 。チャネルがいっぱいの場合はブロックします。</target>
        </trans-unit>
        <trans-unit id="b03f369e152e908d0c3e87c0759a78a3bbb83fd8" translate="yes" xml:space="preserve">
          <source>Applied to a function argument name, hints to the compiler that the method should not be specialized for different types of that argument, but instead to use precisely the declared type for each argument. This is only a hint for avoiding excess code generation. Can be applied to an argument within a formal argument list, or in the function body. When applied to an argument, the macro must wrap the entire argument expression. When used in a function body, the macro must occur in statement position and before any code.</source>
          <target state="translated">関数の引数名に適用され、メソッドがその引数の異なる型に特化するのではなく、各引数に対して正確に宣言された型を使用するようにコンパイラにヒントを与えます。これは、過剰なコード生成を避けるためのヒントに過ぎません。正式な引数リスト内、または関数本体内の引数に適用することができます。引数に適用する場合、マクロは引数式全体をラップする必要があります。関数ボディ内で使用する場合は、マクロは文の位置でコードの前に配置する必要があります。</target>
        </trans-unit>
        <trans-unit id="8ab87eebb7a11b086ff8353783cc2be68600a9ff" translate="yes" xml:space="preserve">
          <source>Applied to a function or macro call, it evaluates the arguments to the specified call, and returns a tuple &lt;code&gt;(filename,line)&lt;/code&gt; giving the location for the method that would be called for those arguments. It calls out to the &lt;code&gt;functionloc&lt;/code&gt; function.</source>
          <target state="translated">関数またはマクロ呼び出しに適用されると、指定された呼び出しの引数を評価し、それらの引数に対して呼び出されるメソッドの場所を示すタプル &lt;code&gt;(filename,line)&lt;/code&gt; を返します。 &lt;code&gt;functionloc&lt;/code&gt; 関数を呼び出します。</target>
        </trans-unit>
        <trans-unit id="10b1d88dbbba24ca44bfc0cd98b524dd2c753624" translate="yes" xml:space="preserve">
          <source>Applied to a function or macro call, it evaluates the arguments to the specified call, and returns the &lt;code&gt;Method&lt;/code&gt; object for the method that would be called for those arguments. Applied to a variable, it returns the module in which the variable was bound. It calls out to the &lt;code&gt;which&lt;/code&gt; function.</source>
          <target state="translated">関数またはマクロの呼び出しに適用すると、指定された呼び出しの引数が評価され、それらの引数に対して呼び出される &lt;code&gt;Method&lt;/code&gt; オブジェクトが返されます。変数に適用すると、変数がバインドされたモジュールが返されます。 &lt;code&gt;which&lt;/code&gt; 関数を呼び出します。</target>
        </trans-unit>
        <trans-unit id="bbb092978ae173971f51dbbabbad7be81b9e017d" translate="yes" xml:space="preserve">
          <source>Applies a function to the preceding argument. This allows for easy function chaining.</source>
          <target state="translated">前の引数に関数を適用します。これにより、関数を簡単に連結することができます。</target>
        </trans-unit>
        <trans-unit id="df9997f06ef19d21e85df7f2a8d3fde509d61f00" translate="yes" xml:space="preserve">
          <source>Apply function &lt;code&gt;f&lt;/code&gt; to each element(s) in &lt;code&gt;itrs&lt;/code&gt;, and then reduce the result using the binary function &lt;code&gt;op&lt;/code&gt;. If provided, &lt;code&gt;init&lt;/code&gt; must be a neutral element for &lt;code&gt;op&lt;/code&gt; that will be returned for empty collections. It is unspecified whether &lt;code&gt;init&lt;/code&gt; is used for non-empty collections. In general, it will be necessary to provide &lt;code&gt;init&lt;/code&gt; to work with empty collections.</source>
          <target state="translated">&lt;code&gt;itrs&lt;/code&gt; の各要素に関数 &lt;code&gt;f&lt;/code&gt; を適用し、バイナリ関数 &lt;code&gt;op&lt;/code&gt; を使用して結果を減らします。指定する場合、 &lt;code&gt;init&lt;/code&gt; は、空のコレクションに対して返される &lt;code&gt;op&lt;/code&gt; のニュートラルエレメントである必要があります。空でないコレクションに &lt;code&gt;init&lt;/code&gt; が使用されるかどうかは指定されていません。一般に、空のコレクションを処理するには &lt;code&gt;init&lt;/code&gt; を提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="abde153c82249beeebbf8921343e0e5bfbfeae0c" translate="yes" xml:space="preserve">
          <source>Apply function &lt;code&gt;f&lt;/code&gt; to the git repository &lt;code&gt;repo&lt;/code&gt;, taking a &lt;a href=&quot;#LibGit2.snapshot&quot;&gt;&lt;code&gt;snapshot&lt;/code&gt;&lt;/a&gt; before applying &lt;code&gt;f&lt;/code&gt;. If an error occurs within &lt;code&gt;f&lt;/code&gt;, &lt;code&gt;repo&lt;/code&gt; will be returned to its snapshot state using &lt;a href=&quot;#LibGit2.restore&quot;&gt;&lt;code&gt;restore&lt;/code&gt;&lt;/a&gt;. The error which occurred will be rethrown, but the state of &lt;code&gt;repo&lt;/code&gt; will not be corrupted.</source>
          <target state="translated">関数適用 &lt;code&gt;f&lt;/code&gt; は gitのリポジトリに &lt;code&gt;repo&lt;/code&gt; 取って、&lt;a href=&quot;#LibGit2.snapshot&quot;&gt; &lt;code&gt;snapshot&lt;/code&gt; &lt;/a&gt;適用する前に &lt;code&gt;f&lt;/code&gt; 。 &lt;code&gt;f&lt;/code&gt; 内でエラーが発生した場合、 &lt;code&gt;repo&lt;/code&gt; は&lt;a href=&quot;#LibGit2.restore&quot;&gt; &lt;code&gt;restore&lt;/code&gt; &lt;/a&gt;を使用してスナップショットの状態に戻ります。発生したエラーは再スローされますが、 &lt;code&gt;repo&lt;/code&gt; の状態は破損しません。</target>
        </trans-unit>
        <trans-unit id="f6b68e61d0fe49a5c4e043952feeeef90f5166fd" translate="yes" xml:space="preserve">
          <source>Apply the function &lt;code&gt;f&lt;/code&gt; to each element of array &lt;code&gt;A&lt;/code&gt; and take the mean over dimensions &lt;code&gt;dims&lt;/code&gt;.</source>
          <target state="translated">関数 &lt;code&gt;f&lt;/code&gt; を配列 &lt;code&gt;A&lt;/code&gt; の各要素に適用し、次元 &lt;code&gt;dims&lt;/code&gt; の平均を取ります。</target>
        </trans-unit>
        <trans-unit id="0f3a1ca726a424329c0ade2ec9d0c7202e4993c0" translate="yes" xml:space="preserve">
          <source>Apply the function &lt;code&gt;f&lt;/code&gt; to each element of collection &lt;code&gt;itr&lt;/code&gt; and take the mean.</source>
          <target state="translated">関数適用 &lt;code&gt;f&lt;/code&gt; は、コレクションの各要素に &lt;code&gt;itr&lt;/code&gt; と平均値を取ります。</target>
        </trans-unit>
        <trans-unit id="939711ce79fa9b7db5fc7f83d19a0a73f949253d" translate="yes" xml:space="preserve">
          <source>Apply the function &lt;code&gt;f&lt;/code&gt; to the result of &lt;a href=&quot;#Base.Filesystem.mktemp-Tuple%7BAbstractString%7D&quot;&gt;&lt;code&gt;mktemp(parent)&lt;/code&gt;&lt;/a&gt; and remove the temporary file upon completion.</source>
          <target state="translated">関数 &lt;code&gt;f&lt;/code&gt; を&lt;a href=&quot;#Base.Filesystem.mktemp-Tuple%7BAbstractString%7D&quot;&gt; &lt;code&gt;mktemp(parent)&lt;/code&gt; の&lt;/a&gt;結果に適用し、完了時に一時ファイルを削除します。</target>
        </trans-unit>
        <trans-unit id="3bc364f76459203bdb0d1fe7d66f3331843d77fb" translate="yes" xml:space="preserve">
          <source>Apply the function &lt;code&gt;f&lt;/code&gt; to the result of &lt;a href=&quot;#Base.Filesystem.mktemp-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;mktemp(parent)&lt;/code&gt;&lt;/a&gt; and remove the temporary file upon completion.</source>
          <target state="translated">関数 &lt;code&gt;f&lt;/code&gt; を&lt;a href=&quot;#Base.Filesystem.mktemp-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;mktemp(parent)&lt;/code&gt; の&lt;/a&gt;結果に適用し、完了時に一時ファイルを削除します。</target>
        </trans-unit>
        <trans-unit id="2dbf8268105b7901616a7ac6d30feda3dbda5ed9" translate="yes" xml:space="preserve">
          <source>Apply the function &lt;code&gt;f&lt;/code&gt; to the result of &lt;a href=&quot;#Base.Filesystem.mktempdir-Tuple%7BAbstractString%7D&quot;&gt;&lt;code&gt;mktempdir(parent; prefix)&lt;/code&gt;&lt;/a&gt; and remove the temporary directory all of its contents upon completion.</source>
          <target state="translated">関数 &lt;code&gt;f&lt;/code&gt; を&lt;a href=&quot;#Base.Filesystem.mktempdir-Tuple%7BAbstractString%7D&quot;&gt; &lt;code&gt;mktempdir(parent; prefix)&lt;/code&gt; &lt;/a&gt;の結果に適用し、完了時に一時ディレクトリのすべての内容を削除します。</target>
        </trans-unit>
        <trans-unit id="5d833cb24f42c76580b0926f643d9e169ba73703" translate="yes" xml:space="preserve">
          <source>Apply the function &lt;code&gt;f&lt;/code&gt; to the result of &lt;a href=&quot;#Base.Filesystem.mktempdir-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;mktempdir(parent; prefix)&lt;/code&gt;&lt;/a&gt; and remove the temporary directory all of its contents upon completion.</source>
          <target state="translated">関数 &lt;code&gt;f&lt;/code&gt; を&lt;a href=&quot;#Base.Filesystem.mktempdir-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;mktempdir(parent; prefix)&lt;/code&gt; &lt;/a&gt;の結果に適用し、完了時に一時ディレクトリの内容をすべて削除します。</target>
        </trans-unit>
        <trans-unit id="c30fb3d590d21605851a7bb8d8b8ee272dad26bb" translate="yes" xml:space="preserve">
          <source>Apply the function &lt;code&gt;f&lt;/code&gt; to the result of &lt;code&gt;open(args...; kwargs...)&lt;/code&gt; and close the resulting file descriptor upon completion.</source>
          <target state="translated">関数 &lt;code&gt;f&lt;/code&gt; を &lt;code&gt;open(args...; kwargs...)&lt;/code&gt; の結果に適用し、完了時に結果のファイル記述子を閉じます。</target>
        </trans-unit>
        <trans-unit id="47f0920b156c6fa088e0adafa06695882e8a1ce9" translate="yes" xml:space="preserve">
          <source>Applying it to any other types of arguments will result in a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">それを他のタイプの引数に適用すると、&lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; &lt;/a&gt;が発生します。</target>
        </trans-unit>
        <trans-unit id="7fea34195bef9eda50f65dd470da25827c0b940a" translate="yes" xml:space="preserve">
          <source>Approaches The Limit</source>
          <target state="translated">アプローチ ザ リミット</target>
        </trans-unit>
        <trans-unit id="36af3f4430ffa874f1e260736d3734767175bb17" translate="yes" xml:space="preserve">
          <source>Approximate floating point number &lt;code&gt;x&lt;/code&gt; as a &lt;a href=&quot;../numbers/index#Base.Rational&quot;&gt;&lt;code&gt;Rational&lt;/code&gt;&lt;/a&gt; number with components of the given integer type. The result will differ from &lt;code&gt;x&lt;/code&gt; by no more than &lt;code&gt;tol&lt;/code&gt;.</source>
          <target state="translated">与えられた整数型のコンポーネントを持つ&lt;a href=&quot;../numbers/index#Base.Rational&quot;&gt; &lt;code&gt;Rational&lt;/code&gt; &lt;/a&gt;としての近似浮動小数点数 &lt;code&gt;x&lt;/code&gt; 。結果は &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;tol&lt;/code&gt; 以下の差になります。</target>
        </trans-unit>
        <trans-unit id="86cdef7d39fe1e6ca08d22290dae380c71b22482" translate="yes" xml:space="preserve">
          <source>Approximately But Not Actually Equal To</source>
          <target state="translated">とほぼ同じだが、実際には同じではない</target>
        </trans-unit>
        <trans-unit id="a398789ce28e88dc00a7a33731c788d8238f5ac2" translate="yes" xml:space="preserve">
          <source>Approximately Equal Or Equal To</source>
          <target state="translated">ほぼ同等または同等</target>
        </trans-unit>
        <trans-unit id="110d059e67ed3348bbc8fc7fc9a8a4830c0240e6" translate="yes" xml:space="preserve">
          <source>Approximately Equal To</source>
          <target state="translated">にほぼ等しい</target>
        </trans-unit>
        <trans-unit id="9d91d063fbecc40e31adb06a0bdab3785430bae5" translate="yes" xml:space="preserve">
          <source>Approximately Equal To Or The Image Of</source>
          <target state="translated">ほぼ同等またはそのイメージ</target>
        </trans-unit>
        <trans-unit id="3e026e6d2a8adcf8897cf07eecff80b0380f276d" translate="yes" xml:space="preserve">
          <source>Aquarius</source>
          <target state="translated">Aquarius</target>
        </trans-unit>
        <trans-unit id="d037d2935a703a621340fc357146d1188aae9fef" translate="yes" xml:space="preserve">
          <source>Arbitrary Precision Arithmetic</source>
          <target state="translated">任意精度演算</target>
        </trans-unit>
        <trans-unit id="ec0bee1bcca32dcc4d82f1af9b35b9a4e833d243" translate="yes" xml:space="preserve">
          <source>Arbitrary precision floating point number type.</source>
          <target state="translated">任意精度浮動小数点数型。</target>
        </trans-unit>
        <trans-unit id="f38bd661446c82eb63be7e7f1e9af6fa5a6cfaaa" translate="yes" xml:space="preserve">
          <source>Arbitrary precision integer type.</source>
          <target state="translated">任意の精度の整数型。</target>
        </trans-unit>
        <trans-unit id="853a983f6b8abdb9ecba43da2ceda1641c9d519f" translate="yes" xml:space="preserve">
          <source>Arc</source>
          <target state="translated">Arc</target>
        </trans-unit>
        <trans-unit id="dbf6ae45c2a646ca9f7ecaf4480259128f85d936" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;waitfor&lt;/code&gt; specifies how long to wait for the workers to shut down:</source>
          <target state="translated">引数 &lt;code&gt;waitfor&lt;/code&gt; は、ワーカーがシャットダウンするまで待機する時間を指定します。</target>
        </trans-unit>
        <trans-unit id="0d26bcd474b23ab47569a6a1a0ca62a2c9eb9205" translate="yes" xml:space="preserve">
          <source>Argument Passing Behavior</source>
          <target state="translated">引数通過動作</target>
        </trans-unit>
        <trans-unit id="938cc4ebe6a5288bbfb1485b585ece93ff21a6fc" translate="yes" xml:space="preserve">
          <source>Argument destructuring</source>
          <target state="translated">引数の破壊</target>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="ccfbfffe30467d0556e9822f3a3009bcd6857e77" translate="yes" xml:space="preserve">
          <source>Arguments to be passed to the LLVM backend.</source>
          <target state="translated">LLVMバックエンドに渡す引数。</target>
        </trans-unit>
        <trans-unit id="f480e0686764de02407b1abe1545f3d34ae95935" translate="yes" xml:space="preserve">
          <source>Aries</source>
          <target state="translated">Aries</target>
        </trans-unit>
        <trans-unit id="6104f39ed22a2cd32e98536a3447a01c4b9f4781" translate="yes" xml:space="preserve">
          <source>Arithmetic Operators</source>
          <target state="translated">算術演算子</target>
        </trans-unit>
        <trans-unit id="6ba961184ebd546b1a3177abda88c03934fb089a" translate="yes" xml:space="preserve">
          <source>Arithmetic on the &lt;code&gt;Ptr&lt;/code&gt; type in Julia (e.g. using &lt;code&gt;+&lt;/code&gt;) does not behave the same as C's pointer arithmetic. Adding an integer to a &lt;code&gt;Ptr&lt;/code&gt; in Julia always moves the pointer by some number of &lt;em&gt;bytes&lt;/em&gt;, not elements. This way, the address values obtained from pointer arithmetic do not depend on the element types of pointers.</source>
          <target state="translated">Julia での &lt;code&gt;Ptr&lt;/code&gt; 型の演算（たとえば、 &lt;code&gt;+&lt;/code&gt; の使用）は、Cのポインター演算と同じように動作しません。Juliaで &lt;code&gt;Ptr&lt;/code&gt; に整数を追加すると、要素ではなく常に&lt;em&gt;バイト&lt;/em&gt;数だけポインタが移動します。このようにして、ポインター演算から得られるアドレス値は、ポインターの要素タイプに依存しません。</target>
        </trans-unit>
        <trans-unit id="1595977488274506444762a7d4b561a282b06666" translate="yes" xml:space="preserve">
          <source>Arithmetic operations on sparse matrices also work as they do on dense matrices. Indexing of, assignment into, and concatenation of sparse matrices work in the same way as dense matrices. Indexing operations, especially assignment, are expensive, when carried out one element at a time. In many cases it may be better to convert the sparse matrix into &lt;code&gt;(I,J,V)&lt;/code&gt; format using &lt;a href=&quot;#SparseArrays.findnz&quot;&gt;&lt;code&gt;findnz&lt;/code&gt;&lt;/a&gt;, manipulate the values or the structure in the dense vectors &lt;code&gt;(I,J,V)&lt;/code&gt;, and then reconstruct the sparse matrix.</source>
          <target state="translated">疎行列に対する算術演算も、密行列に対する場合と同様に機能します。疎行列の索引付け、代入、および連結は、密行列と同じように機能します。インデックス作成操作、特に割り当ては、一度に1つの要素を実行するとコストがかかります。多くの場合 &lt;code&gt;(I,J,V)&lt;/code&gt; &lt;a href=&quot;#SparseArrays.findnz&quot;&gt; &lt;code&gt;findnz&lt;/code&gt; &lt;/a&gt;を使用してスパース行列を（I、J、V）形式に変換し、密なベクトル &lt;code&gt;(I,J,V)&lt;/code&gt; の値または構造を操作してから、スパース行列を再構築する方が良い場合があります。</target>
        </trans-unit>
        <trans-unit id="6b6663a1569cf067a646e962adc2c809327f2a1d" translate="yes" xml:space="preserve">
          <source>Array and Vectorized Operators and Functions</source>
          <target state="translated">配列化およびベクトル化された演算子と関数</target>
        </trans-unit>
        <trans-unit id="272896e88f7076a29401b63fcba504c622f100cf" translate="yes" xml:space="preserve">
          <source>Array functions</source>
          <target state="translated">配列関数</target>
        </trans-unit>
        <trans-unit id="051f0d6bd098df06454138ddf1bfe22d07625d2a" translate="yes" xml:space="preserve">
          <source>Array literals</source>
          <target state="translated">配列リテラル</target>
        </trans-unit>
        <trans-unit id="ec6e2a8a6e3331d091fde070355048d6a50fbdb0" translate="yes" xml:space="preserve">
          <source>Array traits</source>
          <target state="translated">配列形質</target>
        </trans-unit>
        <trans-unit id="b90cc9bfd23567a2ff5ba1f00e7c63ca6da8755e" translate="yes" xml:space="preserve">
          <source>Arrays</source>
          <target state="translated">Arrays</target>
        </trans-unit>
        <trans-unit id="a0d486c491afc0a11a53591657e1748ec0e15c70" translate="yes" xml:space="preserve">
          <source>Arrays With Missing Values</source>
          <target state="translated">欠落した値を持つ配列</target>
        </trans-unit>
        <trans-unit id="14eed9a557bdf809c1d72ce7ef06aab3ac832f66" translate="yes" xml:space="preserve">
          <source>Arrays allowing for missing values can be constructed with the standard syntax. Use &lt;code&gt;Array{Union{Missing, T}}(missing, dims)&lt;/code&gt; to create arrays filled with missing values:</source>
          <target state="translated">欠損値を許容する配列は、標準構文で構築できます。使用の &lt;code&gt;Array{Union{Missing, T}}(missing, dims)&lt;/code&gt; 欠損値で充填された配列を作成します。</target>
        </trans-unit>
        <trans-unit id="d5a5bd6d399fb4d5330301010e8df836c12ff36c" translate="yes" xml:space="preserve">
          <source>Arrays are stored contiguously in memory, lending themselves to CPU vectorization and fewer memory accesses due to caching. These are the same reasons that it is recommended to access arrays in column-major order (see above). Irregular access patterns and non-contiguous views can drastically slow down computations on arrays because of non-sequential memory access.</source>
          <target state="translated">配列はメモリ内に連続して格納されているため、CPUのベクトル化やキャッシュによるメモリアクセスが少なくなります。これらの理由は、配列にカラム・メジャー順でアクセスすることが推奨されているのと同じです(上記参照)。不規則なアクセスパターンや不連続なビューは、非連続なメモリアクセスのために、配列の計算を大幅に遅くする可能性があります。</target>
        </trans-unit>
        <trans-unit id="2cd16e2399bb6c0b0c5a0ea05fbdc7c6bf1a6ee2" translate="yes" xml:space="preserve">
          <source>Arrays can also be directly constructed with square braces; the syntax &lt;code&gt;[A, B, C, ...]&lt;/code&gt; creates a one dimensional array (i.e., a vector) containing the comma-separated arguments as its elements. The element type (&lt;a href=&quot;../../base/collections/index#Base.eltype&quot;&gt;&lt;code&gt;eltype&lt;/code&gt;&lt;/a&gt;) of the resulting array is automatically determined by the types of the arguments inside the braces. If all the arguments are the same type, then that is its &lt;code&gt;eltype&lt;/code&gt;. If they all have a common &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion&quot;&gt;promotion type&lt;/a&gt; then they get converted to that type using &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt; and that type is the array's &lt;code&gt;eltype&lt;/code&gt;. Otherwise, a heterogeneous array that can hold anything &amp;mdash; a &lt;code&gt;Vector{Any}&lt;/code&gt; &amp;mdash; is constructed; this includes the literal &lt;code&gt;[]&lt;/code&gt; where no arguments are given.</source>
          <target state="translated">配列は、角括弧を使用して直接構築することもできます。構文 &lt;code&gt;[A, B, C, ...]&lt;/code&gt; は、要素としてコンマ区切りの引数を含む1次元配列（つまり、ベクトル）を作成します。結果の配列の要素タイプ（&lt;a href=&quot;../../base/collections/index#Base.eltype&quot;&gt; &lt;code&gt;eltype&lt;/code&gt; &lt;/a&gt;）は、中括弧内の引数のタイプによって自動的に決定されます。すべての引数が同じ型である場合、それはその &lt;code&gt;eltype&lt;/code&gt; です。それらがすべて共通の&lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion&quot;&gt;プロモーションタイプを&lt;/a&gt;持っている場合、それらは&lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt;を使用してそのタイプに変換され、そのタイプは配列の &lt;code&gt;eltype&lt;/code&gt; です。それ以外の場合は、何でも保持できる異種配列（ &lt;code&gt;Vector{Any}&lt;/code&gt; ）が作成されます。これにはリテラル &lt;code&gt;[]&lt;/code&gt; が含まれます 引数が与えられていないところ。</target>
        </trans-unit>
        <trans-unit id="804cb53914986dde77e394241b65af0a2493a576" translate="yes" xml:space="preserve">
          <source>Arrays can be constructed and also concatenated using the following functions:</source>
          <target state="translated">配列は、以下の関数を使って構築したり、連結したりすることができます。</target>
        </trans-unit>
        <trans-unit id="9a14bfc250b9401c09f27dc8758fb64c6d1849ec" translate="yes" xml:space="preserve">
          <source>Arrays can easily be sorted according to an arbitrary transformation of their values:</source>
          <target state="translated">配列は、その値の任意の変換に従って簡単に並べ替えることができます。</target>
        </trans-unit>
        <trans-unit id="aa747a7d1d6f608a0335baa21f343f3341f91936" translate="yes" xml:space="preserve">
          <source>Arrays containing missing values can be created like other arrays</source>
          <target state="translated">欠損値を含む配列は、他の配列と同様に作成することができます。</target>
        </trans-unit>
        <trans-unit id="ca4d2abddb6904030658a8e61f4450fbbd938fdf" translate="yes" xml:space="preserve">
          <source>Arrays of &lt;code&gt;CartesianIndex{N}&lt;/code&gt; (see below for more details)</source>
          <target state="translated">&lt;code&gt;CartesianIndex{N}&lt;/code&gt; 配列（詳細は以下を参照）</target>
        </trans-unit>
        <trans-unit id="075c9f606a29f390bc16b51c28be22f3d814f931" translate="yes" xml:space="preserve">
          <source>Arrays of &lt;code&gt;CartesianIndex{N}&lt;/code&gt; are also supported. They represent a collection of scalar indices that each span &lt;code&gt;N&lt;/code&gt; dimensions, enabling a form of indexing that is sometimes referred to as pointwise indexing. For example, it enables accessing the diagonal elements from the first &quot;page&quot; of &lt;code&gt;A&lt;/code&gt; from above:</source>
          <target state="translated">&lt;code&gt;CartesianIndex{N}&lt;/code&gt; 配列もサポートされています。これらは、それぞれが &lt;code&gt;N&lt;/code&gt; 次元にわたるスカラーインデックスのコレクションを表し、ポイントワイズインデックスとも呼ばれるインデックスの形式を有効にします。たとえば、上から &lt;code&gt;A&lt;/code&gt; の最初の「ページ」から対角要素にアクセスできるようにします。</target>
        </trans-unit>
        <trans-unit id="3d6407685d9a3a1c2957e4566ba6f78f8b15e030" translate="yes" xml:space="preserve">
          <source>Arrays of booleans, which select elements at their &lt;code&gt;true&lt;/code&gt; indices (see below for more details)</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; インデックスで要素を選択するブール値の配列（詳細は以下を参照）</target>
        </trans-unit>
        <trans-unit id="36fa144c795f904dbf232a8e653525a3d0ba71b7" translate="yes" xml:space="preserve">
          <source>Arrays of parameters can be expressed with &lt;code&gt;NTuple&lt;/code&gt;. For example, the struct in C notation written as</source>
          <target state="translated">パラメータの配列は &lt;code&gt;NTuple&lt;/code&gt; で表すことができます。たとえば、C表記の構造体は次のように記述されます</target>
        </trans-unit>
        <trans-unit id="0969583730964394602b74ac92dacfa507bac99b" translate="yes" xml:space="preserve">
          <source>Arrays of parameters can be expressed with &lt;code&gt;NTuple&lt;/code&gt;:</source>
          <target state="translated">パラメータの配列は &lt;code&gt;NTuple&lt;/code&gt; で表現できます：</target>
        </trans-unit>
        <trans-unit id="7c5854ca021fe589728b87432b4e259d1c8248d3" translate="yes" xml:space="preserve">
          <source>Arrays of plain data types exhibit the same behavior.</source>
          <target state="translated">プレーンデータ型の配列も同じ動作をします。</target>
        </trans-unit>
        <trans-unit id="6f655e915f910f157fee32ed03ecdc2ad3b9d1df" translate="yes" xml:space="preserve">
          <source>Arrays of unknown size (C99-compliant variable length structs specified by &lt;code&gt;[]&lt;/code&gt; or &lt;code&gt;[0]&lt;/code&gt;) are not directly supported. Often the best way to deal with these is to deal with the byte offsets directly. For example, if a C library declared a proper string type and returned a pointer to it:</source>
          <target state="translated">サイズが不明な配列（ &lt;code&gt;[]&lt;/code&gt; または &lt;code&gt;[0]&lt;/code&gt; で指定されたC99準拠の可変長構造体）は直接サポートされていません。多くの場合、これらを処理する最良の方法は、バイトオフセットを直接処理することです。たとえば、Cライブラリが適切な文字列型を宣言し、それへのポインタを返した場合：</target>
        </trans-unit>
        <trans-unit id="0a4fe1e9982ed026b7b75e0b6640d07c49b347a1" translate="yes" xml:space="preserve">
          <source>Arrow Pointing Rightwards Then Curving Downwards</source>
          <target state="translated">矢印は右方向を指し、次に下向きにカーブしています。</target>
        </trans-unit>
        <trans-unit id="d5a8479391be26e8e773c26793b7bf6d542adbb0" translate="yes" xml:space="preserve">
          <source>Arrow Pointing Rightwards Then Curving Upwards</source>
          <target state="translated">矢印は右を指し、その後上向きにカーブします。</target>
        </trans-unit>
        <trans-unit id="56cbb3f16cd1ca93b5689f5cddec6758302ebb86" translate="yes" xml:space="preserve">
          <source>Arthur C. Clarke, &lt;em&gt;Profiles of the Future&lt;/em&gt; (1961): Clarke's Third Law.</source>
          <target state="translated">アーサーC.クラーク、&lt;em&gt;未来のプロファイル&lt;/em&gt;（1961）：クラークの第三法則。</target>
        </trans-unit>
        <trans-unit id="4be4b541c7c3be1117af5726c8607678780b96ca" translate="yes" xml:space="preserve">
          <source>Articulated Lorry</source>
          <target state="translated">多関節ローリー</target>
        </trans-unit>
        <trans-unit id="b1aa57e2147913434d8d33e99a2a302c3d412560" translate="yes" xml:space="preserve">
          <source>Artist Palette</source>
          <target state="translated">アーティストパレット</target>
        </trans-unit>
        <trans-unit id="07d39beaf4ec4f6ab344410b6e2ddcbafeee07b5" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;missing&lt;/code&gt; is a normal Julia object, this propagation rule only works for functions which have opted in to implement this behavior. This can be achieved either via a specific method defined for arguments of type &lt;code&gt;Missing&lt;/code&gt;, or simply by accepting arguments of this type, and passing them to functions which propagate them (like standard math operators). Packages should consider whether it makes sense to propagate missing values when defining new functions, and define methods appropriately if that is the case. Passing a &lt;code&gt;missing&lt;/code&gt; value to a function for which no method accepting arguments of type &lt;code&gt;Missing&lt;/code&gt; is defined throws a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt;, just like for any other type.</source>
          <target state="translated">&lt;code&gt;missing&lt;/code&gt; 、通常のジュリアオブジェクトである、この伝播ルールは、この動作を実装するために選択している機能のために動作します。これは、 &lt;code&gt;Missing&lt;/code&gt; 型の引数に対して定義された特定のメソッドを介して、または単にこの型の引数を受け入れ、それらを伝播する関数（標準の数学演算子など）に渡すことによって実現できます。パッケージは、新しい関数を定義するときに欠落している値を伝播することが理にかなっているかどうかを検討し、その場合はメソッドを適切に定義する必要があります。渡す &lt;code&gt;missing&lt;/code&gt; 型の引数を受け入れて何の方法そのための関数に値を &lt;code&gt;Missing&lt;/code&gt; 定義されているが、スローません&lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; を&lt;/a&gt;ちょうど他のタイプのためのように、。</target>
        </trans-unit>
        <trans-unit id="b2b55172c20f3a3018d935f94f15f420d19dd799" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;missing&lt;/code&gt; is a normal Julia object, this propagation rule only works for functions which have opted in to implement this behavior. This can be achieved either via a specific method defined for arguments of type &lt;code&gt;Missing&lt;/code&gt;, or simply by accepting arguments of this type, and passing them to functions which propagate them (like standard operators). Packages should consider whether it makes sense to propagate missing values when defining new functions, and define methods appropriately if that is the case. Passing a &lt;code&gt;missing&lt;/code&gt; value to a function for which no method accepting arguments of type &lt;code&gt;Missing&lt;/code&gt; is defined throws a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt;, just like for any other type.</source>
          <target state="translated">&lt;code&gt;missing&lt;/code&gt; 、通常のジュリアオブジェクトである、この伝播ルールは、この動作を実装するために選択している機能のために動作します。これは、 &lt;code&gt;Missing&lt;/code&gt; 型の引数に定義された特定のメソッドを介して、または単にこの型の引数を受け入れ、それらを伝播する関数（標準演算子のような）に渡すことによって実現できます。パッケージは、新しい関数を定義するときに欠損値を伝達することが理にかなっているかどうかを検討し、そうである場合はメソッドを適切に定義する必要があります。 &lt;code&gt;Missing&lt;/code&gt; 型の引数を受け入れるメソッドが定義されていない関数に &lt;code&gt;missing&lt;/code&gt; 値を渡すと、他の型と同様に&lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; が&lt;/a&gt;スローされます。</target>
        </trans-unit>
        <trans-unit id="6c7f12d083082a8b358b33648f5e922218bf6328" translate="yes" xml:space="preserve">
          <source>As Julia &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; values are represented according to the ISO 8601 standard, &lt;code&gt;0000-01-01T00:00:00&lt;/code&gt; was chosen as base (or &quot;rounding epoch&quot;) from which to begin the count of days (and milliseconds) used in rounding calculations. (Note that this differs slightly from Julia's internal representation of &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; s using Rata Die notation; but since the ISO 8601 standard is most visible to the end user, &lt;code&gt;0000-01-01T00:00:00&lt;/code&gt; was chosen as the rounding epoch instead of the &lt;code&gt;0000-12-31T00:00:00&lt;/code&gt; used internally to minimize confusion.)</source>
          <target state="translated">Julia &lt;a href=&quot;#Dates.Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; の&lt;/a&gt;値はISO 8601標準に従って表されるため、丸めに使用される日数（およびミリ秒）のカウントを開始する基準（または「丸めエポック」）として &lt;code&gt;0000-01-01T00:00:00&lt;/code&gt; が選択されました計算。（これは、JuliaのRata Die表記を使用した&lt;a href=&quot;#Dates.Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;の内部表現とは少し異なりますが、ISO 8601標準はエンドユーザーに &lt;code&gt;0000-01-01T00:00:00&lt;/code&gt; ため、丸めのエポックとして0000-01-01T00：00：00を選択したのではなく、 &lt;code&gt;0000-12-31T00:00:00&lt;/code&gt; は、混乱を最小限にするために内部的に使用されます。）</target>
        </trans-unit>
        <trans-unit id="018f199ee4bce38a37225bf7cf902f1a94cfebe8" translate="yes" xml:space="preserve">
          <source>As a bonus, all period arithmetic objects work directly with ranges:</source>
          <target state="translated">ボーナスとして、すべてのピリオドの算術オブジェクトは、範囲を直接使用して動作します。</target>
        </trans-unit>
        <trans-unit id="1d37396b19dff556a9f0928d3fb79a1f9a87b4bb" translate="yes" xml:space="preserve">
          <source>As a complete but simple example, the following calls the &lt;code&gt;clock&lt;/code&gt; function from the standard C library on most Unix-derived systems:</source>
          <target state="translated">完全で単純な例として、以下はほとんどのUnix派生システムの標準Cライブラリから &lt;code&gt;clock&lt;/code&gt; 関数を呼び出します。</target>
        </trans-unit>
        <trans-unit id="25d0293122d46f12e2772f00b98fe234a30f7099" translate="yes" xml:space="preserve">
          <source>As a complete but simple example, the following calls the &lt;code&gt;clock&lt;/code&gt; function from the standard C library:</source>
          <target state="translated">完全ではあるが単純な例として、以下は標準Cライブラリから &lt;code&gt;clock&lt;/code&gt; 関数を呼び出します。</target>
        </trans-unit>
        <trans-unit id="539ad19d9070448cc3bfdfe89f4f38e027fe5c6c" translate="yes" xml:space="preserve">
          <source>As a convenience, constructing a &lt;code&gt;CartesianIndices&lt;/code&gt; from an array makes a range of its indices.</source>
          <target state="translated">便宜上、配列から &lt;code&gt;CartesianIndices&lt;/code&gt; を構築すると、その範囲のインデックスが作成されます。</target>
        </trans-unit>
        <trans-unit id="0b5625230c61073f2e6e2ee043f6240a0a3c7016" translate="yes" xml:space="preserve">
          <source>As a general rule, the Base library uses the following order of arguments to functions, as applicable:</source>
          <target state="translated">原則として、Base ライブラリでは、関数への引数の順序は以下のようになっています。</target>
        </trans-unit>
        <trans-unit id="0aeaa033e5a0e531782e60f4be3543a306118072" translate="yes" xml:space="preserve">
          <source>As a heuristic, Julia avoids automatically specializing on argument type parameters in three specific cases: &lt;code&gt;Type&lt;/code&gt;, &lt;code&gt;Function&lt;/code&gt;, and &lt;code&gt;Vararg&lt;/code&gt;. Julia will always specialize when the argument is used within the method, but not if the argument is just passed through to another function. This usually has no performance impact at runtime and &lt;a href=&quot;https://docs.julialang.org/en/v1.5.3/devdocs/functions/#compiler-efficiency-issues&quot;&gt;improves compiler performance&lt;/a&gt;. If you find it does have a performance impact at runtime in your case, you can trigger specialization by adding a type parameter to the method declaration. Here are some examples:</source>
          <target state="translated">ヒューリスティックとして、Juliaは、 &lt;code&gt;Type&lt;/code&gt; 、 &lt;code&gt;Function&lt;/code&gt; 、 &lt;code&gt;Vararg&lt;/code&gt; の3つの特定のケースで、引数の型パラメーターに自動的に特化することを避けています。Juliaは、引数がメソッド内で使用される場合は常に特殊化しますが、引数が別の関数に渡される場合は特殊化しません。これは通常、実行時にパフォーマンスに影響を与えず、&lt;a href=&quot;https://docs.julialang.org/en/v1.5.3/devdocs/functions/#compiler-efficiency-issues&quot;&gt;コンパイラのパフォーマンス&lt;/a&gt;を向上させます。実行時にパフォーマンスに影響があることがわかった場合は、メソッド宣言に型パラメーターを追加することで特殊化をトリガーできます。ここではいくつかの例を示します。</target>
        </trans-unit>
        <trans-unit id="876317f2ed373be8c206ea71cf8b7c051cb11062" translate="yes" xml:space="preserve">
          <source>As a more complicated example, let's define our own toy N-dimensional sparse-like array type built on top of &lt;a href=&quot;../../base/collections/index#Base.Dict&quot;&gt;&lt;code&gt;Dict&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">より複雑な例として、&lt;a href=&quot;../../base/collections/index#Base.Dict&quot;&gt; &lt;code&gt;Dict&lt;/code&gt; の&lt;/a&gt;上に構築された独自のおもちゃのN次元のスパース状配列型を定義してみましょう。</target>
        </trans-unit>
        <trans-unit id="e8594cf6335bb7f066fe658c47ad7b64d5f8a844" translate="yes" xml:space="preserve">
          <source>As a more extended and complex example, consider running the following &quot;kernel&quot; in parallel:</source>
          <target state="translated">より拡張された複雑な例として、以下の「カーネル」を並列に実行することを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="abc7b3fc409ca00052233fccf9f3605c7724641a" translate="yes" xml:space="preserve">
          <source>As a rule of thumb, the single-line &lt;code&gt;show&lt;/code&gt; method should print a valid Julia expression for creating the shown object. When this &lt;code&gt;show&lt;/code&gt; method contains infix operators, such as the multiplication operator (&lt;code&gt;*&lt;/code&gt;) in our single-line &lt;code&gt;show&lt;/code&gt; method for &lt;code&gt;Polar&lt;/code&gt; above, it may not parse correctly when printed as part of another object. To see this, consider the expression object (see &lt;a href=&quot;../metaprogramming/index#Program-representation&quot;&gt;Program representation&lt;/a&gt;) which takes the square of a specific instance of our &lt;code&gt;Polar&lt;/code&gt; type:</source>
          <target state="translated">経験則として、1行の &lt;code&gt;show&lt;/code&gt; メソッドは、表示されたオブジェクトを作成するための有効なJulia式を出力する必要があります。この &lt;code&gt;show&lt;/code&gt; メソッドに上記の &lt;code&gt;Polar&lt;/code&gt; の1行の &lt;code&gt;show&lt;/code&gt; メソッドの乗算演算子（ &lt;code&gt;*&lt;/code&gt; ）などの中置演算子が含まれている場合、別のオブジェクトの一部として出力すると正しく解析されないことがあります。これを確認するには、 &lt;code&gt;Polar&lt;/code&gt; タイプの特定のインスタンスの2乗をとる式オブジェクト（&lt;a href=&quot;../metaprogramming/index#Program-representation&quot;&gt;プログラム&lt;/a&gt;表現を参照）について考えてみます。</target>
        </trans-unit>
        <trans-unit id="2067a667a08ddb9964ef86bab532db4e31b7d596" translate="yes" xml:space="preserve">
          <source>As a rule of thumb, the single-line &lt;code&gt;show&lt;/code&gt; method should print a valid Julia expression for creating the shown object. When this &lt;code&gt;show&lt;/code&gt; method contains infix operators, such as the multiplication operator (&lt;code&gt;*&lt;/code&gt;) in our single-line &lt;code&gt;show&lt;/code&gt; method for &lt;code&gt;Polar&lt;/code&gt; above, it may not parse correctly when printed as part of another object. To see this, consider the expression object (see &lt;a href=&quot;../metaprogramming/index#Program-representation-1&quot;&gt;Program representation&lt;/a&gt;) which takes the square of a specific instance of our &lt;code&gt;Polar&lt;/code&gt; type:</source>
          <target state="translated">経験則として、単一行の &lt;code&gt;show&lt;/code&gt; メソッドは、表示されたオブジェクトを作成するための有効なJulia式を出力する必要があります。この &lt;code&gt;show&lt;/code&gt; メソッドに、上記の &lt;code&gt;Polar&lt;/code&gt; の単一行の &lt;code&gt;show&lt;/code&gt; メソッドの乗算演算子（ &lt;code&gt;*&lt;/code&gt; ）などの挿入演算子が含まれている場合、別のオブジェクトの一部として印刷すると、正しく解析されない場合があります。これを確認するには、 &lt;code&gt;Polar&lt;/code&gt; 型の特定のインスタンスの2乗をとる式オブジェクト（&lt;a href=&quot;../metaprogramming/index#Program-representation-1&quot;&gt;プログラム&lt;/a&gt;表現を参照）を考えます。</target>
        </trans-unit>
        <trans-unit id="37e79152e5cc53d02dd6543f1f031bc76326d65b" translate="yes" xml:space="preserve">
          <source>As a special case, all names defined in &lt;code&gt;Main&lt;/code&gt; are considered &quot;exported&quot;, since it is not idiomatic to explicitly export names from &lt;code&gt;Main&lt;/code&gt;.</source>
          <target state="translated">特殊なケースとして、で定義されたすべての名前 &lt;code&gt;Main&lt;/code&gt; 、明示的に名前をエクスポートする慣用ではないので、「エクスポート」と考えられている &lt;code&gt;Main&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6ead86dd43c44d522a7884aedc1fd88eb5becf75" translate="yes" xml:space="preserve">
          <source>As a special case, functions can only be actually deep-copied if they are anonymous, otherwise they are just copied. The difference is only relevant in the case of closures, i.e. functions which may contain hidden internal references.</source>
          <target state="translated">特殊なケースとして、関数は無名の場合にのみ実際にディープコピーされますが、そうでない場合はただコピーされるだけです。この違いはクロージャの場合、つまり隠された内部参照を含む可能性のある関数の場合にのみ関係します。</target>
        </trans-unit>
        <trans-unit id="d76af4d473b8d2d40c642b61a1fbe0edf6927389" translate="yes" xml:space="preserve">
          <source>As a special case, if &lt;code&gt;x&lt;/code&gt; is an &lt;code&gt;AbstractString&lt;/code&gt; (for textual MIME types) or a &lt;code&gt;Vector{UInt8}&lt;/code&gt; (for binary MIME types), the &lt;code&gt;repr&lt;/code&gt; function assumes that &lt;code&gt;x&lt;/code&gt; is already in the requested &lt;code&gt;mime&lt;/code&gt; format and simply returns &lt;code&gt;x&lt;/code&gt;. This special case does not apply to the &lt;code&gt;&quot;text/plain&quot;&lt;/code&gt; MIME type. This is useful so that raw data can be passed to &lt;code&gt;display(m::MIME, x)&lt;/code&gt;.</source>
          <target state="translated">特殊なケースとして、 &lt;code&gt;x&lt;/code&gt; が &lt;code&gt;AbstractString&lt;/code&gt; （テキストMIMEタイプの場合）または &lt;code&gt;Vector{UInt8}&lt;/code&gt; （バイナリMIMEタイプの場合）の場合、 &lt;code&gt;repr&lt;/code&gt; 関数は &lt;code&gt;x&lt;/code&gt; がすでに要求された &lt;code&gt;mime&lt;/code&gt; 形式であると想定し、単に &lt;code&gt;x&lt;/code&gt; を返します。この特殊なケースは、 &lt;code&gt;&quot;text/plain&quot;&lt;/code&gt; MIMEタイプには適用されません。これは、生データを &lt;code&gt;display(m::MIME, x)&lt;/code&gt; 渡すために役立ちます。</target>
        </trans-unit>
        <trans-unit id="62d11f9f9e158c0b2c2708640ce2ac613943fd82" translate="yes" xml:space="preserve">
          <source>As a special part of this syntax, the &lt;code&gt;end&lt;/code&gt; keyword may be used to represent the last index of each dimension within the indexing brackets, as determined by the size of the innermost array being indexed. Indexing syntax without the &lt;code&gt;end&lt;/code&gt; keyword is equivalent to a call to &lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">この構文の特別な部分として、インデックスが付けられている最も内側の配列のサイズによって決定されるように、 &lt;code&gt;end&lt;/code&gt; キーワードを使用して、インデックスブラケット内の各次元の最後のインデックスを表すことができます。 &lt;code&gt;end&lt;/code&gt; キーワードなしのインデックス構文は、&lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; の&lt;/a&gt;呼び出しと同等です。</target>
        </trans-unit>
        <trans-unit id="bae7191c8b712d7ed7a7918d6d667ad51becb2b6" translate="yes" xml:space="preserve">
          <source>As already elaborated in &lt;a href=&quot;../../stdlib/repl/index#The-Julia-REPL&quot;&gt;The Julia REPL&lt;/a&gt;, Julia's REPL provides rich functionality that facilitates an efficient interactive workflow. Here are some tips that might further enhance your experience at the command line.</source>
          <target state="translated">&lt;a href=&quot;../../stdlib/repl/index#The-Julia-REPL&quot;&gt;Julia REPL&lt;/a&gt;ですでに詳しく説明されているように、JuliaのREPLは、効率的なインタラクティブワークフローを容易にする豊富な機能を提供します。コマンドラインでのエクスペリエンスをさらに向上させる可能性のあるヒントをいくつか紹介します。</target>
        </trans-unit>
        <trans-unit id="5535efde9a5741aaf5f5e686571434213ecef6c2" translate="yes" xml:space="preserve">
          <source>As already elaborated in &lt;a href=&quot;../../stdlib/repl/index#The-Julia-REPL-1&quot;&gt;The Julia REPL&lt;/a&gt;, Julia's REPL provides rich functionality that facilitates an efficient interactive workflow. Here are some tips that might further enhance your experience at the command line.</source>
          <target state="translated">&lt;a href=&quot;../../stdlib/repl/index#The-Julia-REPL-1&quot;&gt;Julia REPL&lt;/a&gt;ですでに詳しく述べたように、JuliaのREPLは、効率的なインタラクティブワークフローを促進する豊富な機能を提供します。コマンドラインでのエクスペリエンスをさらに向上させるヒントをいくつか紹介します。</target>
        </trans-unit>
        <trans-unit id="06e64cdbccd93a2d388ef16dd274049eaf25b515" translate="yes" xml:space="preserve">
          <source>As an alternative for very simple cases, it is possible to just create a global container of type &lt;code&gt;Vector{Any}&lt;/code&gt; and fetch the elements from that when necessary, or even to create one global variable per pointer using</source>
          <target state="translated">非常に単純なケースの代替として、 &lt;code&gt;Vector{Any}&lt;/code&gt; 型のグローバルコンテナーを作成し、必要に応じてそこから要素をフェッチするか、または使用してポインターごとに1つのグローバル変数を作成することもできます。</target>
        </trans-unit>
        <trans-unit id="d6c52d7f67846f1ec223096b1fa72569e5539d74" translate="yes" xml:space="preserve">
          <source>As an assertion to help confirm that your program works the way you expect,</source>
          <target state="translated">あなたのプログラムが期待通りに動作することを確認するためのアサーションとして。</target>
        </trans-unit>
        <trans-unit id="18c9d397fe2fae6bb521c88b045f04eec75021c6" translate="yes" xml:space="preserve">
          <source>As an example let us see how the &lt;code&gt;LocalManager&lt;/code&gt;, the manager responsible for starting workers on the same host, is implemented:</source>
          <target state="translated">例として、同じホストでワーカーを開始する責任があるマネージャーである &lt;code&gt;LocalManager&lt;/code&gt; がどのように実装されているかを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="5ea2f3f22affe5b0503e1b98807df2e143d66e8a" translate="yes" xml:space="preserve">
          <source>As an example of a non-TCP/IP transport, an implementation may choose to use MPI, in which case &lt;code&gt;--worker&lt;/code&gt; must NOT be specified. Instead, newly launched workers should call &lt;code&gt;init_worker(cookie)&lt;/code&gt; before using any of the parallel constructs.</source>
          <target state="translated">非TCP / IPトランスポートの例として、実装はMPIの使用を選択できます。その場合、 &lt;code&gt;--worker&lt;/code&gt; 指定してはなりません。代わりに、新しく起動されたワーカーは、並列構造を使用する前に &lt;code&gt;init_worker(cookie)&lt;/code&gt; を呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="ab91e9f8f6b72a78ebd5768f4d6d25cd797012df" translate="yes" xml:space="preserve">
          <source>As an example, consider</source>
          <target state="translated">例として、次のことを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="f4fdf4e4340eb940fd457afeeed7b812831f6609" translate="yes" xml:space="preserve">
          <source>As an example, consider this call to &lt;a href=&quot;../../base/collections/index#Base.get&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">例として、次を&lt;a href=&quot;../../base/collections/index#Base.get&quot;&gt; &lt;code&gt;get&lt;/code&gt; &lt;/a&gt;するためにこの呼び出しを検討してください：</target>
        </trans-unit>
        <trans-unit id="8d94b4e364183ef3f6a858e77d060fb33ee15b1a" translate="yes" xml:space="preserve">
          <source>As an example, suppose a package directory has the following structure and content:</source>
          <target state="translated">例として、パッケージディレクトリが以下のような構造と内容を持っているとします。</target>
        </trans-unit>
        <trans-unit id="1237948f9e574bfd646187c2b196cb56c33c770b" translate="yes" xml:space="preserve">
          <source>As an example, suppose you wanted to define multiplication on symbols in a module:</source>
          <target state="translated">例として、モジュール内のシンボルに対する乗算を定義したいとします。</target>
        </trans-unit>
        <trans-unit id="59a193ac31c3261e6bf490ce9642a1cb05737a81" translate="yes" xml:space="preserve">
          <source>As an example, the builtin &lt;code&gt;AbstractRange&lt;/code&gt; objects use this machinery to optimize pieces of broadcasted expressions that can be eagerly evaluated purely in terms of the start, step, and length (or stop) instead of computing every single element. Just like all the other machinery, &lt;code&gt;broadcasted&lt;/code&gt; also computes and exposes the combined broadcast style of its arguments, so instead of specializing on &lt;code&gt;broadcasted(f, args...)&lt;/code&gt;, you can specialize on &lt;code&gt;broadcasted(::DestStyle, f, args...)&lt;/code&gt; for any combination of style, function, and arguments.</source>
          <target state="translated">例として、組み込みの &lt;code&gt;AbstractRange&lt;/code&gt; オブジェクトはこのメカニズムを使用して、すべての単一の要素を計算する代わりに、開始、ステップ、および長さ（または停止）の観点から純粋に熱心に評価できるブロードキャスト式の断片を最適化します。他のすべての機構と同様に、 &lt;code&gt;broadcasted&lt;/code&gt; も引数の結合ブロードキャストスタイルを計算して公開するため、 &lt;code&gt;broadcasted(f, args...)&lt;/code&gt; に特化する代わりに、 &lt;code&gt;broadcasted(::DestStyle, f, args...)&lt;/code&gt; スタイル、関数、引数の任意の組み合わせ。</target>
        </trans-unit>
        <trans-unit id="dddf73cd98dcce7c884fe24956533693e61e8e3f" translate="yes" xml:space="preserve">
          <source>As an example:</source>
          <target state="translated">一例として。</target>
        </trans-unit>
        <trans-unit id="87ed434d0000a98d4576d846e0e095b93bb4582f" translate="yes" xml:space="preserve">
          <source>As an extension of this, in cases where the algorithm needs a copy of the input array, &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt; is insufficient as the return value may alias the original input. Combining &lt;a href=&quot;../../base/arrays/index#Base.similar&quot;&gt;&lt;code&gt;similar&lt;/code&gt;&lt;/a&gt; (to make the output array) and &lt;a href=&quot;../../base/c/index#Base.copyto!&quot;&gt;&lt;code&gt;copyto!&lt;/code&gt;&lt;/a&gt; (to fill it with the input data) is a generic way to express the requirement for a mutable copy of the input argument:</source>
          <target state="translated">これの拡張として、アルゴリズムが入力配列のコピーを必要とする場合、戻り値が元の入力をエイリアスする可能性があるため、&lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt;は不十分です。組み合わせると&lt;a href=&quot;../../base/arrays/index#Base.similar&quot;&gt; &lt;code&gt;similar&lt;/code&gt; &lt;/a&gt;（出力配列を作るために）と&lt;a href=&quot;../../base/c/index#Base.copyto!&quot;&gt; &lt;code&gt;copyto!&lt;/code&gt; &lt;/a&gt;（入力データを入力する）は、入力引数の可変コピーの要件を表す一般的な方法です。</target>
        </trans-unit>
        <trans-unit id="f8ea3b19e7de523c7e9925d469ae1f1489b7d884" translate="yes" xml:space="preserve">
          <source>As another example, here is a function that doubles any numeric argument, but leaves expressions alone:</source>
          <target state="translated">別の例として、任意の数値引数を倍にしますが、式だけは残しておく関数を以下に示します。</target>
        </trans-unit>
        <trans-unit id="5a98ec0590a6653411278e5178b7dfd6cf089ca2" translate="yes" xml:space="preserve">
          <source>As calculations on floating-point values can be imprecise, you can perform approximate equality checks using either &lt;code&gt;@test a &amp;asymp; b&lt;/code&gt; (where &lt;code&gt;&amp;asymp;&lt;/code&gt;, typed via tab completion of &lt;code&gt;\approx&lt;/code&gt;, is the &lt;a href=&quot;../../base/math/index#Base.isapprox&quot;&gt;&lt;code&gt;isapprox&lt;/code&gt;&lt;/a&gt; function) or use &lt;a href=&quot;../../base/math/index#Base.isapprox&quot;&gt;&lt;code&gt;isapprox&lt;/code&gt;&lt;/a&gt; directly.</source>
          <target state="translated">浮動小数点値の計算が不正確なことができるように、あなたがいずれかを使用しておおよその等価性チェックを実行することができます &lt;code&gt;@test a &amp;asymp; b&lt;/code&gt; （どこ &lt;code&gt;&amp;asymp;&lt;/code&gt; のタブ補完を経て入力された、 &lt;code&gt;\approx&lt;/code&gt; 、ある&lt;a href=&quot;../../base/math/index#Base.isapprox&quot;&gt; &lt;code&gt;isapprox&lt;/code&gt; の&lt;/a&gt;か、利用機能）&lt;a href=&quot;../../base/math/index#Base.isapprox&quot;&gt; &lt;code&gt;isapprox&lt;/code&gt; &lt;/a&gt;直接。</target>
        </trans-unit>
        <trans-unit id="671cfcc401170439c76fc45750de84c7f63c05ee" translate="yes" xml:space="preserve">
          <source>As can be seen once again, a remote call onto the local node behaves just like a direct invocation. The call modifies local objects passed as arguments. In the remote invocation, it operates on a copy of the arguments.</source>
          <target state="translated">もう一度見てわかるように、ローカル・ノードへのリモート呼び出しは、直接呼び出しと同じように動作します。呼び出しは、引数として渡されたローカルオブジェクトを変更します。リモート呼び出しでは、引数のコピーを操作します。</target>
        </trans-unit>
        <trans-unit id="3cc0d715da9528bac336fc93fd62b1b74187bec5" translate="yes" xml:space="preserve">
          <source>As can be seen, &lt;code&gt;A&lt;/code&gt; is changed to the sorted array &lt;code&gt;[-2.7, 1.3, 3.1, 4.4]&lt;/code&gt;. Note that Julia knows how to convert an array into a &lt;code&gt;Ptr{Cdouble}&lt;/code&gt;, how to compute the size of a type in bytes (identical to C's &lt;code&gt;sizeof&lt;/code&gt; operator), and so on. For fun, try inserting a &lt;code&gt;println(&quot;mycompare($a, $b)&quot;)&lt;/code&gt; line into &lt;code&gt;mycompare&lt;/code&gt;, which will allow you to see the comparisons that &lt;code&gt;qsort&lt;/code&gt; is performing (and to verify that it is really calling the Julia function that you passed to it).</source>
          <target state="translated">見てわかるように、 &lt;code&gt;A&lt;/code&gt; はソートされた配列 &lt;code&gt;[-2.7, 1.3, 3.1, 4.4]&lt;/code&gt; 変更されます。 Juliaは、配列を &lt;code&gt;Ptr{Cdouble}&lt;/code&gt; に変換する方法、型のサイズをバイト単位で計算する方法（Cの &lt;code&gt;sizeof&lt;/code&gt; 演算子と同じ）などを知っていることに注意してください。面白くするには、 &lt;code&gt;println(&quot;mycompare($a, $b)&quot;)&lt;/code&gt; 行を &lt;code&gt;mycompare&lt;/code&gt; に挿入してみてください。これにより、 &lt;code&gt;qsort&lt;/code&gt; が実行している比較を確認できます（渡したJulia関数が本当に呼び出されていることを確認できます）それに）。</target>
        </trans-unit>
        <trans-unit id="4b96915d6aea30f8cc88503d183daf83b43b1570" translate="yes" xml:space="preserve">
          <source>As can be seen, &lt;code&gt;put!&lt;/code&gt; on a locally owned &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt; with the same object &lt;code&gt;v&lt;/code&gt; modifed between calls results in the same single object instance stored. As opposed to copies of &lt;code&gt;v&lt;/code&gt; being created when the node owning &lt;code&gt;rc&lt;/code&gt; is a different node.</source>
          <target state="translated">見てわかるように &lt;code&gt;put!&lt;/code&gt; ローカルで所有されている&lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; &lt;/a&gt;で、同じオブジェクトを &lt;code&gt;v&lt;/code&gt; 呼び出し間で変更すると、同じ単一のオブジェクトインスタンスが格納されます。 &lt;code&gt;rc&lt;/code&gt; を所有するノードが別のノードであるときに作成される &lt;code&gt;v&lt;/code&gt; のコピーとは対照的です。</target>
        </trans-unit>
        <trans-unit id="e253ba428da9355b11a09e17058388a067c23f87" translate="yes" xml:space="preserve">
          <source>As can be seen, global variable &lt;code&gt;A&lt;/code&gt; is defined on worker 2, but &lt;code&gt;B&lt;/code&gt; is captured as a local variable and hence a binding for &lt;code&gt;B&lt;/code&gt; does not exist on worker 2.</source>
          <target state="translated">ご覧のように、グローバル変数 &lt;code&gt;A&lt;/code&gt; はワーカー2で定義されていますが、 &lt;code&gt;B&lt;/code&gt; はローカル変数としてキャプチャされているため、 &lt;code&gt;B&lt;/code&gt; のバインディングはワーカー2に存在しません。</target>
        </trans-unit>
        <trans-unit id="76f93ab509f4540b19db8475dd078bd3d9ad56c4" translate="yes" xml:space="preserve">
          <source>As convenient as date-period arithmetic is, often the kinds of calculations needed on dates take on a &lt;em&gt;calendrical&lt;/em&gt; or &lt;em&gt;temporal&lt;/em&gt; nature rather than a fixed number of periods. Holidays are a perfect example; most follow rules such as &quot;Memorial Day = Last Monday of May&quot;, or &quot;Thanksgiving = 4th Thursday of November&quot;. These kinds of temporal expressions deal with rules relative to the calendar, like first or last of the month, next Tuesday, or the first and third Wednesdays, etc.</source>
          <target state="translated">日付と期間の計算と同じくらい便利ですが、日付に必要な種類の計算は、固定数の期間ではなく、&lt;em&gt;暦&lt;/em&gt;&lt;em&gt;的&lt;/em&gt;または&lt;em&gt;時間的な&lt;/em&gt;性質を帯びます。休日は完璧な例です。ほとんどの場合、「記念日= 5月の最終月曜日」、「感謝祭= 11月の第4木曜日」などのルールに従います。これらの種類の時間表現は、月の最初または最後、次の火曜日、または第1および第3水曜日など、カレンダーに関連するルールを扱います。</target>
        </trans-unit>
        <trans-unit id="a1c026427d4e0f63d2dc15ae37577d2f94eafa8a" translate="yes" xml:space="preserve">
          <source>As expected we saw &quot;Hello World&quot; printed. So, let's actually analyze what happened behind the scenes. When we called &lt;code&gt;connect&lt;/code&gt;, we connect to the server we had just created. Meanwhile, the accept function returns a server-side connection to the newly created socket and prints &quot;Hello World&quot; to indicate that the connection was successful.</source>
          <target state="translated">予想通り、「Hello World」が印刷されました。それでは、舞台裏で何が起こったかを実際に分析してみましょう。 &lt;code&gt;connect&lt;/code&gt; を呼び出すと、作成したサーバーに接続します。一方、accept関数は、新しく作成されたソケットへのサーバー側接続を返し、接続が成功したことを示す「Hello World」を出力します。</target>
        </trans-unit>
        <trans-unit id="a7387cbdd9f992b642e060d8d4bc6f44c8177451" translate="yes" xml:space="preserve">
          <source>As for &lt;a href=&quot;#SparseArrays.SparseMatrixCSC&quot;&gt;&lt;code&gt;SparseMatrixCSC&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;SparseVector&lt;/code&gt; type can also contain explicitly stored zeros. (See &lt;a href=&quot;#man-csc&quot;&gt;Sparse Matrix Storage&lt;/a&gt;.).</source>
          <target state="translated">&lt;a href=&quot;#SparseArrays.SparseMatrixCSC&quot;&gt; &lt;code&gt;SparseMatrixCSC&lt;/code&gt; の&lt;/a&gt;場合と同様に、 &lt;code&gt;SparseVector&lt;/code&gt; 型には明示的に格納されたゼロを含めることもできます。（&lt;a href=&quot;#man-csc&quot;&gt;スパースマトリックスストレージを&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="2bb0a271b40c54ec6b4884cb957952b84f3d4f5b" translate="yes" xml:space="preserve">
          <source>As for &lt;a href=&quot;#SparseArrays.SparseMatrixCSC&quot;&gt;&lt;code&gt;SparseMatrixCSC&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;SparseVector&lt;/code&gt; type can also contain explicitly stored zeros. (See &lt;a href=&quot;#man-csc-1&quot;&gt;Sparse Matrix Storage&lt;/a&gt;.).</source>
          <target state="translated">&lt;a href=&quot;#SparseArrays.SparseMatrixCSC&quot;&gt; &lt;code&gt;SparseMatrixCSC&lt;/code&gt; &lt;/a&gt;、 &lt;code&gt;SparseVector&lt;/code&gt; タイプは、明示的に保存されたゼロを含めることができます。（&lt;a href=&quot;#man-csc-1&quot;&gt;スパースマトリックスストレージを&lt;/a&gt;参照してください）。</target>
        </trans-unit>
        <trans-unit id="fc146c2940c0c078ab8141567616fc6c9d0de40c" translate="yes" xml:space="preserve">
          <source>As for hexadecimal literals, binary and octal literals produce unsigned integer types. The size of the binary data item is the minimal needed size, if the leading digit of the literal is not &lt;code&gt;0&lt;/code&gt;. In the case of leading zeros, the size is determined by the minimal needed size for a literal, which has the same length but leading digit &lt;code&gt;1&lt;/code&gt;. That allows the user to control the size. Values which cannot be stored in &lt;code&gt;UInt128&lt;/code&gt; cannot be written as such literals.</source>
          <target state="translated">16進リテラルと同様に、2進および8進リテラルは符号なし整数型を生成します。リテラルの先頭桁が &lt;code&gt;0&lt;/code&gt; でない場合、バイナリデータ項目のサイズは、必要な最小サイズです。先行ゼロの場合、サイズはリテラルに必要な最小サイズによって決定されます。リテラルは長さが同じですが、先行桁が &lt;code&gt;1&lt;/code&gt; です。これにより、ユーザーはサイズを制御できます。 &lt;code&gt;UInt128&lt;/code&gt; に格納できない値は、そのようなリテラルとして書き込むことはできません。</target>
        </trans-unit>
        <trans-unit id="6db8bde5f510430fc099aa246b7efd8ae6ef4908" translate="yes" xml:space="preserve">
          <source>As for numeric arrays, choosing a non-stable default algorithm for array types for which the notion of a stable sort is meaningless (i.e. when two values comparing equal can not be distinguished) may make sense.</source>
          <target state="translated">数値配列に関しては,安定ソートの概念が無意味な配列型(すなわち,等しい値を比較する2つの値が区別できない場合)に対して,安定しないデフォルトアルゴリズムを選択することは意味があるかもしれません.</target>
        </trans-unit>
        <trans-unit id="5657074766ca713487af1f45c8fe2527e89dae0c" translate="yes" xml:space="preserve">
          <source>As for single values, use &lt;a href=&quot;../../base/base/index#Base.isequal&quot;&gt;&lt;code&gt;isequal&lt;/code&gt;&lt;/a&gt; to treat &lt;code&gt;missing&lt;/code&gt; values as equal to other &lt;code&gt;missing&lt;/code&gt; values but different from non-missing values</source>
          <target state="translated">単一の値については、&lt;a href=&quot;../../base/base/index#Base.isequal&quot;&gt; &lt;code&gt;isequal&lt;/code&gt; &lt;/a&gt;を使用して、 &lt;code&gt;missing&lt;/code&gt; 値を他の &lt;code&gt;missing&lt;/code&gt; 値と同等であるが欠損値以外とは異なるものとして扱います</target>
        </trans-unit>
        <trans-unit id="80909a25deba83e5c549936818feccfa43f85abd" translate="yes" xml:space="preserve">
          <source>As hinted above, one extremely useful feature of Julia is the capability to generate and manipulate Julia code within Julia itself. We have already seen one example of a function returning &lt;a href=&quot;../../base/base/index#Core.Expr&quot;&gt;&lt;code&gt;Expr&lt;/code&gt;&lt;/a&gt; objects: the &lt;a href=&quot;../../base/numbers/index#Base.parse&quot;&gt;&lt;code&gt;parse&lt;/code&gt;&lt;/a&gt; function, which takes a string of Julia code and returns the corresponding &lt;code&gt;Expr&lt;/code&gt;. A function can also take one or more &lt;code&gt;Expr&lt;/code&gt; objects as arguments, and return another &lt;code&gt;Expr&lt;/code&gt;. Here is a simple, motivating example:</source>
          <target state="translated">上記で示唆したように、Juliaの非常に便利な機能の1つは、Julia自体の内部でJuliaコードを生成および操作する機能です。&lt;a href=&quot;../../base/base/index#Core.Expr&quot;&gt; &lt;code&gt;Expr&lt;/code&gt; &lt;/a&gt;オブジェクトを返す関数の1つの例、つまり、Juliaコードの文字列を取り、対応する &lt;code&gt;Expr&lt;/code&gt; を返す&lt;a href=&quot;../../base/numbers/index#Base.parse&quot;&gt; &lt;code&gt;parse&lt;/code&gt; &lt;/a&gt;関数を見てきました。関数は、1つ以上の &lt;code&gt;Expr&lt;/code&gt; オブジェクトを引数として取り、別の &lt;code&gt;Expr&lt;/code&gt; を返すこともできます。シンプルでやる気を起こさせる例を次に示します。</target>
        </trans-unit>
        <trans-unit id="0e3a8b594e44456d63d508da5257e974c3de310d" translate="yes" xml:space="preserve">
          <source>As illustrated in the above example each column of &lt;code&gt;|&lt;/code&gt; characters must be aligned vertically.</source>
          <target state="translated">上記の例に示すように、 &lt;code&gt;|&lt;/code&gt; の各列 文字は垂直方向に配置する必要があります。</target>
        </trans-unit>
        <trans-unit id="51316c0f471c7aa15821993b2904c54c98f59dec" translate="yes" xml:space="preserve">
          <source>As in Java, strings are immutable: the value of an &lt;code&gt;AbstractString&lt;/code&gt; object cannot be changed. To construct a different string value, you construct a new string from parts of other strings.</source>
          <target state="translated">Javaと同様に、文字列は不変です &lt;code&gt;AbstractString&lt;/code&gt; オブジェクトの値は変更できません。別の文字列値を作成するには、他の文字列の一部から新しい文字列を作成します。</target>
        </trans-unit>
        <trans-unit id="10a53b8655071d9e82e3aaf67177dfbc302c86e3" translate="yes" xml:space="preserve">
          <source>As in keyword arguments, identifiers and dot expressions imply names:</source>
          <target state="translated">キーワード引数と同様に、識別子やドット式は名前を意味します。</target>
        </trans-unit>
        <trans-unit id="972bb7e6b4d2b9c22f53c9f2f7dc30a1be414e25" translate="yes" xml:space="preserve">
          <source>As in the example above, we recommend following some simple conventions when writing documentation:</source>
          <target state="translated">上記の例のように、ドキュメントを書く際には、いくつかの簡単な規約に従うことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="a760e2170f972850310e9b6d50d6aa2fdbfb2289" translate="yes" xml:space="preserve">
          <source>As in the previous example, the first assignment to &lt;code&gt;s&lt;/code&gt; at the top of &lt;code&gt;sum_to&lt;/code&gt; causes &lt;code&gt;s&lt;/code&gt; to be a new local variable in the body of the function. The &lt;code&gt;for&lt;/code&gt; loop has its own inner local scope within the function scope. At the point where &lt;code&gt;s = s + i&lt;/code&gt; occurs, &lt;code&gt;s&lt;/code&gt; is already a local variable, so the assignment updates the existing &lt;code&gt;s&lt;/code&gt; instead of creating a new local. We can test this out by calling &lt;code&gt;sum_to&lt;/code&gt; in the REPL:</source>
          <target state="translated">前の例のように、 &lt;code&gt;sum_to&lt;/code&gt; の先頭にある &lt;code&gt;s&lt;/code&gt; への最初の割り当てにより、 &lt;code&gt;s&lt;/code&gt; は関数本体の新しいローカル変数になります。 &lt;code&gt;for&lt;/code&gt; ループは、関数のスコープ内に独自の内部ローカルスコープを持っています。 &lt;code&gt;s = s + i&lt;/code&gt; が発生する時点で、 &lt;code&gt;s&lt;/code&gt; はすでにローカル変数であるため、割り当てにより、新しいローカルを作成する代わりに、既存 &lt;code&gt;s&lt;/code&gt; 更新されます。REPLで &lt;code&gt;sum_to&lt;/code&gt; を呼び出すことで、これをテストできます。</target>
        </trans-unit>
        <trans-unit id="42eaaebd11c27f9b1c1515d18b277f999ad14b89" translate="yes" xml:space="preserve">
          <source>As it was mentioned &lt;code&gt;CodeUnits{UInt8,String}&lt;/code&gt; type behaves like read only array of &lt;code&gt;UInt8&lt;/code&gt; and if you need a standard vector you can convert it using &lt;code&gt;Vector{UInt8}&lt;/code&gt;:</source>
          <target state="translated">言及したように、 &lt;code&gt;CodeUnits{UInt8,String}&lt;/code&gt; 型は &lt;code&gt;UInt8&lt;/code&gt; の読み取り専用配列のように動作し、標準のベクターが必要な場合は、 &lt;code&gt;Vector{UInt8}&lt;/code&gt; を使用して変換できます。</target>
        </trans-unit>
        <trans-unit id="ba1acaea73293bc8197cce97bdfefcad05927f1a" translate="yes" xml:space="preserve">
          <source>As mentioned above, one can also define new display backends. For example, a module that can display PNG images in a window can register this capability with Julia, so that calling &lt;a href=&quot;#Base.Multimedia.display&quot;&gt;&lt;code&gt;display(x)&lt;/code&gt;&lt;/a&gt; on types with PNG representations will automatically display the image using the module's window.</source>
          <target state="translated">上記のように、新しいディスプレイバックエンドを定義することもできます。たとえば、PNG画像をウィンドウに表示できるモジュールは、この機能をJuliaに登録できるため、PNG表現を持つ型で&lt;a href=&quot;#Base.Multimedia.display&quot;&gt; &lt;code&gt;display(x)&lt;/code&gt; &lt;/a&gt;を呼び出すと、モジュールのウィンドウを使用して画像が自動的に表示されます。</target>
        </trans-unit>
        <trans-unit id="9a3464c75addc4046f2d5407323c1df1db4f1784" translate="yes" xml:space="preserve">
          <source>As mentioned briefly in &lt;a href=&quot;../functions/index#man-functions&quot;&gt;Functions&lt;/a&gt;, optional arguments are implemented as syntax for multiple method definitions. For example, this definition:</source>
          <target state="translated">&lt;a href=&quot;../functions/index#man-functions&quot;&gt;関数&lt;/a&gt;で簡単に説明したように、オプションの引数は複数のメソッド定義の構文として実装されます。たとえば、次の定義は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="fb063e502e9f2dd374cf5645d0ea6281db87f213" translate="yes" xml:space="preserve">
          <source>As mentioned briefly in &lt;a href=&quot;../functions/index#man-functions-1&quot;&gt;Functions&lt;/a&gt;, optional arguments are implemented as syntax for multiple method definitions. For example, this definition:</source>
          <target state="translated">&lt;a href=&quot;../functions/index#man-functions-1&quot;&gt;関数&lt;/a&gt;で簡単に説明したように、オプションの引数は複数のメソッド定義の構文として実装されます。たとえば、この定義は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="be2578b9d9f02697184689069f4eff8d3539a32a" translate="yes" xml:space="preserve">
          <source>As of Julia 1.5, functions defined by &lt;code&gt;@deprecate&lt;/code&gt; do not print warning when &lt;code&gt;julia&lt;/code&gt; is run without the &lt;code&gt;--depwarn=yes&lt;/code&gt; flag set, as the default value of &lt;code&gt;--depwarn&lt;/code&gt; option is &lt;code&gt;no&lt;/code&gt;. The warnings are printed from tests run by &lt;code&gt;Pkg.test()&lt;/code&gt;.</source>
          <target state="translated">ジュリア1.5のとおり、によって定義された関数 &lt;code&gt;@deprecate&lt;/code&gt; の際に警告を表示しません &lt;code&gt;julia&lt;/code&gt; なくても実行され &lt;code&gt;--depwarn=yes&lt;/code&gt; のデフォルト値としてフラグが設定され、 &lt;code&gt;--depwarn&lt;/code&gt; オプションはありません &lt;code&gt;no&lt;/code&gt; 。警告は、 &lt;code&gt;Pkg.test()&lt;/code&gt; によって実行されたテストから出力されます。</target>
        </trans-unit>
        <trans-unit id="512c2f7db98f68697b03e7fce5871064de0272a9" translate="yes" xml:space="preserve">
          <source>As of Julia 1.5, this code works without the &lt;code&gt;global&lt;/code&gt; annotation in interactive contexts like the REPL or Jupyter notebooks (just like Julia 0.6) and in files and other non-interactive contexts, it prints this very direct warning:</source>
          <target state="translated">Julia 1.5以降、このコードは、REPLやJupyterノートブック（Julia 0.6と同様）などのインタラクティブコンテキストや、ファイルやその他の非インタラクティブコンテキストでは、 &lt;code&gt;global&lt;/code&gt; アノテーションなしで機能し、次の非常に直接的な警告を出力します。</target>
        </trans-unit>
        <trans-unit id="f48e9ac18414a96f1e01471c6b6626466797c864" translate="yes" xml:space="preserve">
          <source>As of this writing, the valid Unicode code points are &lt;code&gt;U+0000&lt;/code&gt; through &lt;code&gt;U+D7FF&lt;/code&gt; and &lt;code&gt;U+E000&lt;/code&gt; through &lt;code&gt;U+10FFFF&lt;/code&gt;. These have not all been assigned intelligible meanings yet, nor are they necessarily interpretable by applications, but all of these values are considered to be valid Unicode characters.</source>
          <target state="translated">この記事の執筆時点で、有効なUnicodeコードポイントは &lt;code&gt;U+0000&lt;/code&gt; &lt;code&gt;U+D7FF&lt;/code&gt; からU + D7FFおよび &lt;code&gt;U+E000&lt;/code&gt; から &lt;code&gt;U+10FFFF&lt;/code&gt; です。これらのすべてにわかりやすい意味が割り当てられているわけではなく、アプリケーションで必ずしも解釈できるわけでもありませんが、これらの値はすべて有効なUnicode文字と見なされます。</target>
        </trans-unit>
        <trans-unit id="191e5fd5542b028418c413dac2b44eaff01d364f" translate="yes" xml:space="preserve">
          <source>As of this writing, the valid Unicode code points are &lt;code&gt;U+00&lt;/code&gt; through &lt;code&gt;U+d7ff&lt;/code&gt; and &lt;code&gt;U+e000&lt;/code&gt; through &lt;code&gt;U+10ffff&lt;/code&gt;. These have not all been assigned intelligible meanings yet, nor are they necessarily interpretable by applications, but all of these values are considered to be valid Unicode characters.</source>
          <target state="translated">これを書いているように、有効なUnicodeコードポイントは &lt;code&gt;U+00&lt;/code&gt; を介して &lt;code&gt;U+d7ff&lt;/code&gt; と &lt;code&gt;U+e000&lt;/code&gt; を介して &lt;code&gt;U+10ffff&lt;/code&gt; 。これらのすべてにまだわかりやすい意味が割り当てられているわけではなく、必ずしもアプリケーションで解釈できるわけでもありませんが、これらの値はすべて有効なUnicode文字と見なされます。</target>
        </trans-unit>
        <trans-unit id="c64e98d3602dd7e8a13d28a764d202fba2aba952" translate="yes" xml:space="preserve">
          <source>As one can see here, &lt;a href=&quot;../../base/strings/index#Base.occursin&quot;&gt;&lt;code&gt;occursin&lt;/code&gt;&lt;/a&gt; simply returns true or false, indicating whether a match for the given regex occurs in the string. Commonly, however, one wants to know not just whether a string matched, but also &lt;em&gt;how&lt;/em&gt; it matched. To capture this information about a match, use the &lt;a href=&quot;../../base/strings/index#Base.match&quot;&gt;&lt;code&gt;match&lt;/code&gt;&lt;/a&gt; function instead:</source>
          <target state="translated">ここに示されているように、&lt;a href=&quot;../../base/strings/index#Base.occursin&quot;&gt; &lt;code&gt;occursin&lt;/code&gt; &lt;/a&gt;単にtrueまたはfalseを返し、指定された正規表現との一致が文字列で発生するかどうかを示します。ただし、一般的には、文字列が一致したかどうかだけでなく、文字列が&lt;em&gt;どのよう&lt;/em&gt;に一致したかも知りたいと思っています。一致に関するこの情報を取得するには、代わりに&lt;a href=&quot;../../base/strings/index#Base.match&quot;&gt; &lt;code&gt;match&lt;/code&gt; &lt;/a&gt;関数を使用します。</target>
        </trans-unit>
        <trans-unit id="c4a14a67f1bf4cea327a2eb12b0f80f0eef678ff" translate="yes" xml:space="preserve">
          <source>As the error states, an immediate cause of an &lt;code&gt;UndefVarError&lt;/code&gt; on a remote node is that a binding by that name does not exist. Let us explore some of the possible causes.</source>
          <target state="translated">エラーが示す &lt;code&gt;UndefVarError&lt;/code&gt; に、リモートノードでのUndefVarErrorの直接の原因は、その名前によるバインディングが存在しないことです。考えられる原因のいくつかを調べてみましょう。</target>
        </trans-unit>
        <trans-unit id="1eb17e26ef0507943bf96943b437f10fc48bc317" translate="yes" xml:space="preserve">
          <source>As the example implies, the following command-line arguments to &lt;code&gt;julia&lt;/code&gt; are interpreted as command-line arguments to the program &lt;code&gt;script.jl&lt;/code&gt;, passed in the global constant &lt;code&gt;ARGS&lt;/code&gt;. The name of the script itself is passed in as the global &lt;code&gt;PROGRAM_FILE&lt;/code&gt;. Note that &lt;code&gt;ARGS&lt;/code&gt; is also set when a Julia expression is given using the &lt;code&gt;-e&lt;/code&gt; option on the command line (see the &lt;code&gt;julia&lt;/code&gt; help output below) but &lt;code&gt;PROGRAM_FILE&lt;/code&gt; will be empty. For example, to just print the arguments given to a script, you could do this:</source>
          <target state="translated">例が示すように、次のコマンドライン引数 &lt;code&gt;julia&lt;/code&gt; プログラムのコマンドライン引数として解釈され &lt;code&gt;script.jl&lt;/code&gt; グローバル定数が渡され、 &lt;code&gt;ARGS&lt;/code&gt; 。スクリプト自体の名前は、グローバル &lt;code&gt;PROGRAM_FILE&lt;/code&gt; として渡されます。注があること &lt;code&gt;ARGS&lt;/code&gt; ジュリア式を使用して与えられたときにも設定されている &lt;code&gt;-e&lt;/code&gt; コマンドラインでオプションを（参照 &lt;code&gt;julia&lt;/code&gt; 以下のヘルプ出力）が、 &lt;code&gt;PROGRAM_FILE&lt;/code&gt; は空になります。たとえば、スクリプトに与えられた引数を出力するには、次のようにします。</target>
        </trans-unit>
        <trans-unit id="109c1f4fb3ce88e11db771658301b6b14b390770" translate="yes" xml:space="preserve">
          <source>As the example shows, the original Julia array &lt;code&gt;A&lt;/code&gt; has now been sorted: &lt;code&gt;[-2.7, 1.3, 3.1, 4.4]&lt;/code&gt;. Note that Julia &lt;a href=&quot;#automatic-type-conversion&quot;&gt;takes care of converting the array to a &lt;code&gt;Ptr{Cdouble}&lt;/code&gt;&lt;/a&gt;), computing the size of the element type in bytes, and so on.</source>
          <target state="translated">例が示すように、元のJulia配列 &lt;code&gt;A&lt;/code&gt; はソートされています： &lt;code&gt;[-2.7, 1.3, 3.1, 4.4]&lt;/code&gt; 。Julia&lt;a href=&quot;#automatic-type-conversion&quot;&gt;は、配列を &lt;code&gt;Ptr{Cdouble}&lt;/code&gt; &lt;/a&gt;）に変換したり、要素タイプのサイズをバイト単位で計算したりすることに注意してください。</target>
        </trans-unit>
        <trans-unit id="981be6ff2cc90e0e705ac3383fc828a6dbdc7827" translate="yes" xml:space="preserve">
          <source>As this example shows, the element type of such arrays is &lt;code&gt;Union{Missing, T}&lt;/code&gt;, with &lt;code&gt;T&lt;/code&gt; the type of the non-missing values. This simply reflects the fact that array entries can be either of type &lt;code&gt;T&lt;/code&gt; (here, &lt;code&gt;Int64&lt;/code&gt;) or of type &lt;code&gt;Missing&lt;/code&gt;. This kind of array uses an efficient memory storage equivalent to an &lt;code&gt;Array{T}&lt;/code&gt; holding the actual values combined with an &lt;code&gt;Array{UInt8}&lt;/code&gt; indicating the type of the entry (i.e. whether it is &lt;code&gt;Missing&lt;/code&gt; or &lt;code&gt;T&lt;/code&gt;).</source>
          <target state="translated">この例が示すように、そのような配列の要素型は &lt;code&gt;Union{Missing, T}&lt;/code&gt; であり、 &lt;code&gt;T&lt;/code&gt; は非欠損値の型です。これは、配列エントリがタイプ &lt;code&gt;T&lt;/code&gt; （ここでは、 &lt;code&gt;Int64&lt;/code&gt; ）またはタイプ &lt;code&gt;Missing&lt;/code&gt; のいずれかになる可能性があるという事実を単に反映しています。この種類の配列は、実際の値を保持する &lt;code&gt;Array{T}&lt;/code&gt; と同等の効率的なメモリストレージを使用して、エントリのタイプ（つまり、存在し &lt;code&gt;Missing&lt;/code&gt; か &lt;code&gt;T&lt;/code&gt; か）を示す &lt;code&gt;Array{UInt8}&lt;/code&gt; と組み合わせます。</target>
        </trans-unit>
        <trans-unit id="ed6ee60a4bf819b8376da694ce11cd02fe61b3bd" translate="yes" xml:space="preserve">
          <source>As usual, the absolute value (&lt;a href=&quot;../../base/math/index#Base.abs&quot;&gt;&lt;code&gt;abs&lt;/code&gt;&lt;/a&gt;) of a complex number is its distance from zero. &lt;a href=&quot;../../base/math/index#Base.abs2&quot;&gt;&lt;code&gt;abs2&lt;/code&gt;&lt;/a&gt; gives the square of the absolute value, and is of particular use for complex numbers since it avoids taking a square root. &lt;a href=&quot;../../base/math/index#Base.angle&quot;&gt;&lt;code&gt;angle&lt;/code&gt;&lt;/a&gt; returns the phase angle in radians (also known as the &lt;em&gt;argument&lt;/em&gt; or &lt;em&gt;arg&lt;/em&gt; function). The full gamut of other &lt;a href=&quot;../mathematical-operations/index#Elementary-Functions&quot;&gt;Elementary Functions&lt;/a&gt; is also defined for complex numbers:</source>
          <target state="translated">いつものように、複素数の絶対値（&lt;a href=&quot;../../base/math/index#Base.abs&quot;&gt; &lt;code&gt;abs&lt;/code&gt; &lt;/a&gt;）はゼロからの距離です。&lt;a href=&quot;../../base/math/index#Base.abs2&quot;&gt; &lt;code&gt;abs2&lt;/code&gt; &lt;/a&gt;は絶対値の二乗を与え、平方根を取ることを回避するため、複素数に特に役立ちます。&lt;a href=&quot;../../base/math/index#Base.angle&quot;&gt; &lt;code&gt;angle&lt;/code&gt; &lt;/a&gt;は、位相角をラジアンで返します（&lt;em&gt;引数&lt;/em&gt;または&lt;em&gt;arg&lt;/em&gt;関数とも呼ばれます）。他の&lt;a href=&quot;../mathematical-operations/index#Elementary-Functions&quot;&gt;初等関数&lt;/a&gt;の全範囲も複素数に対して定義されています。</target>
        </trans-unit>
        <trans-unit id="c38e97b2426f385efa12439902693dc14bf8618f" translate="yes" xml:space="preserve">
          <source>As usual, the absolute value (&lt;a href=&quot;../../base/math/index#Base.abs&quot;&gt;&lt;code&gt;abs&lt;/code&gt;&lt;/a&gt;) of a complex number is its distance from zero. &lt;a href=&quot;../../base/math/index#Base.abs2&quot;&gt;&lt;code&gt;abs2&lt;/code&gt;&lt;/a&gt; gives the square of the absolute value, and is of particular use for complex numbers since it avoids taking a square root. &lt;a href=&quot;../../base/math/index#Base.angle&quot;&gt;&lt;code&gt;angle&lt;/code&gt;&lt;/a&gt; returns the phase angle in radians (also known as the &lt;em&gt;argument&lt;/em&gt; or &lt;em&gt;arg&lt;/em&gt; function). The full gamut of other &lt;a href=&quot;../mathematical-operations/index#Elementary-Functions-1&quot;&gt;Elementary Functions&lt;/a&gt; is also defined for complex numbers:</source>
          <target state="translated">いつものように、複素数の絶対値（&lt;a href=&quot;../../base/math/index#Base.abs&quot;&gt; &lt;code&gt;abs&lt;/code&gt; &lt;/a&gt;）はゼロからの距離です。&lt;a href=&quot;../../base/math/index#Base.abs2&quot;&gt; &lt;code&gt;abs2&lt;/code&gt; &lt;/a&gt;は絶対値の2乗を与え、平方根をとらないので複素数に特に役立ちます。&lt;a href=&quot;../../base/math/index#Base.angle&quot;&gt; &lt;code&gt;angle&lt;/code&gt; &lt;/a&gt;は、位相角をラジアンで返します（&lt;em&gt;argument&lt;/em&gt;または&lt;em&gt;arg&lt;/em&gt;関数とも呼ばれます）。他の&lt;a href=&quot;../mathematical-operations/index#Elementary-Functions-1&quot;&gt;基本関数&lt;/a&gt;の全範囲も複素数に対して定義されています。</target>
        </trans-unit>
        <trans-unit id="b6a7588d6f9c25c0288fa6f4060bf2933853ea1a" translate="yes" xml:space="preserve">
          <source>As usual, the promotion system makes interactions with other numeric types effortless:</source>
          <target state="translated">いつものように、プロモーションシステムは他の数値型とのやりとりを楽にしてくれます。</target>
        </trans-unit>
        <trans-unit id="0ac972252ac8a4d2677fb97cc60dc48ab7bb4888" translate="yes" xml:space="preserve">
          <source>As usual, this does not bring &lt;code&gt;DummyModule&lt;/code&gt; into scope on any of the process, which requires &lt;code&gt;using&lt;/code&gt; or &lt;code&gt;import&lt;/code&gt;. Moreover, when &lt;code&gt;DummyModule&lt;/code&gt; is brought into scope on one process, it is not on any other:</source>
          <target state="translated">いつものように、これは &lt;code&gt;DummyModule&lt;/code&gt; をどのプロセスのスコープにも持ち込まないので、 &lt;code&gt;using&lt;/code&gt; または &lt;code&gt;import&lt;/code&gt; が必要です。さらに、 &lt;code&gt;DummyModule&lt;/code&gt; が1つのプロセスのスコープに含まれる場合、他のプロセスにはありません。</target>
        </trans-unit>
        <trans-unit id="98525fef666cf45bd35cbb0c018ea8c9988be2ad" translate="yes" xml:space="preserve">
          <source>As we have seen in &lt;a href=&quot;../calling-c-and-fortran-code/index#Calling-C-and-Fortran-Code&quot;&gt;Calling C and Fortran Code&lt;/a&gt;, Julia has a simple and efficient way to call functions written in C. But there are situations where the opposite is needed: calling Julia function from C code. This can be used to integrate Julia code into a larger C/C++ project, without the need to rewrite everything in C/C++. Julia has a C API to make this possible. As almost all programming languages have some way to call C functions, the Julia C API can also be used to build further language bridges (e.g. calling Julia from Python or C#).</source>
          <target state="translated">&lt;a href=&quot;../calling-c-and-fortran-code/index#Calling-C-and-Fortran-Code&quot;&gt;CおよびFortranコードの呼び出しで&lt;/a&gt;見たように、Juliaには、Cで記述された関数を呼び出すための簡単で効率的な方法があります。ただし、逆の場合があります。CコードからJulia関数を呼び出すことです。これを使用すると、C / C ++ですべてを書き直すことなく、Juliaコードをより大きなC / C ++プロジェクトに統合できます。 Juliaには、これを可能にするCAPIがあります。ほとんどすべてのプログラミング言語にはC関数を呼び出す方法があるため、Julia C APIを使用してさらに言語ブリッジを構築することもできます（たとえば、PythonまたはC＃からJuliaを呼び出す）。</target>
        </trans-unit>
        <trans-unit id="f7ffd73a9506b0079b3703beb529178a185c5762" translate="yes" xml:space="preserve">
          <source>As we have seen in &lt;a href=&quot;../calling-c-and-fortran-code/index#Calling-C-and-Fortran-Code-1&quot;&gt;Calling C and Fortran Code&lt;/a&gt;, Julia has a simple and efficient way to call functions written in C. But there are situations where the opposite is needed: calling Julia function from C code. This can be used to integrate Julia code into a larger C/C++ project, without the need to rewrite everything in C/C++. Julia has a C API to make this possible. As almost all programming languages have some way to call C functions, the Julia C API can also be used to build further language bridges (e.g. calling Julia from Python or C#).</source>
          <target state="translated">&lt;a href=&quot;../calling-c-and-fortran-code/index#Calling-C-and-Fortran-Code-1&quot;&gt;Calling C and Fortran Code&lt;/a&gt;で見たように、JuliaはCで記述された関数を呼び出すためのシンプルで効率的な方法を備えています。しかし、CコードからJulia関数を呼び出すという反対の状況が必要な場合もあります。これは、C / C ++ですべてを書き直す必要なしに、Juliaコードをより大きなC / C ++プロジェクトに統合するために使用できます。 Juliaには、これを可能にするC APIがあります。ほとんどすべてのプログラミング言語にはC関数を呼び出す方法があるため、Julia C APIを使用して、さらに言語ブリッジを構築することもできます（たとえば、PythonまたはC＃からJuliaを呼び出す）。</target>
        </trans-unit>
        <trans-unit id="82c0a21a8d879f7a5c7272f023db6b90d1239835" translate="yes" xml:space="preserve">
          <source>As we have seen, Julia objects are represented in C as pointers. This raises the question of who is responsible for freeing these objects.</source>
          <target state="translated">これまで見てきたように、ジュリアのオブジェクトはC言語ではポインタとして表現されます。これは、これらのオブジェクトを解放する責任は誰にあるのかという問題を提起しています。</target>
        </trans-unit>
        <trans-unit id="8632fecc892c2a5175874dd3d5957b71b599c90f" translate="yes" xml:space="preserve">
          <source>As we have seen, a typical parametric type has inner constructors that are called when type parameters are known; e.g. they apply to &lt;code&gt;Point{Int}&lt;/code&gt; but not to &lt;code&gt;Point&lt;/code&gt;. Optionally, outer constructors that determine type parameters automatically can be added, for example constructing a &lt;code&gt;Point{Int}&lt;/code&gt; from the call &lt;code&gt;Point(1,2)&lt;/code&gt;. Outer constructors call inner constructors to actually make instances. However, in some cases one would rather not provide inner constructors, so that specific type parameters cannot be requested manually.</source>
          <target state="translated">これまで見てきたように、典型的なパラメトリック型には、型パラメーターがわかっているときに呼び出される内部コンストラクターがあります。例えば、彼らはに適用する &lt;code&gt;Point{Int}&lt;/code&gt; なくする &lt;code&gt;Point&lt;/code&gt; 。オプションで、タイプパラメータを自動的に決定する外部コンストラクタを追加できます。たとえば、呼び出し &lt;code&gt;Point(1,2)&lt;/code&gt; から &lt;code&gt;Point{Int}&lt;/code&gt; を作成します。外部コンストラクターは内部コンストラクターを呼び出して実際にインスタンスを作成します。ただし、場合によっては、内部コンストラクタを提供せずに、特定の型パラメータを手動で要求できないことがあります。</target>
        </trans-unit>
        <trans-unit id="92ef7f3ff78c47fd1600b930f6d1226b1a4419f4" translate="yes" xml:space="preserve">
          <source>As we have seen, such expressions support interpolation with &lt;code&gt;$&lt;/code&gt;. However, in some situations it is necessary to quote code &lt;em&gt;without&lt;/em&gt; performing interpolation. This kind of quoting does not yet have syntax, but is represented internally as an object of type &lt;code&gt;QuoteNode&lt;/code&gt;. The parser yields &lt;code&gt;QuoteNode&lt;/code&gt;s for simple quoted items like symbols:</source>
          <target state="translated">見てきたように、そのような式は &lt;code&gt;$&lt;/code&gt; による補間をサポートしています。ただし、状況によっては、補間&lt;em&gt;を&lt;/em&gt;実行&lt;em&gt;せずに&lt;/em&gt;コードを引用する必要があります。この種類の引用にはまだ構文はありませんが、内部的には &lt;code&gt;QuoteNode&lt;/code&gt; 型のオブジェクトとして表されます。パーサーは、シンボルのような単純な引用符で囲まれたアイテムの &lt;code&gt;QuoteNode&lt;/code&gt; を生成します。</target>
        </trans-unit>
        <trans-unit id="8358ced5c8aa8043f6548995886cf6fc9b1c22a3" translate="yes" xml:space="preserve">
          <source>As we have seen, such expressions support interpolation with &lt;code&gt;$&lt;/code&gt;. However, in some situations it is necessary to quote code &lt;em&gt;without&lt;/em&gt; performing interpolation. This kind of quoting does not yet have syntax, but is represented internally as an object of type &lt;code&gt;QuoteNode&lt;/code&gt;:</source>
          <target state="translated">これまで見てきたように、このような式は &lt;code&gt;$&lt;/code&gt; による補間をサポートしています。ただし、状況によっては、補間&lt;em&gt;を&lt;/em&gt;実行&lt;em&gt;せずに&lt;/em&gt;コードを引用する必要があります。この種の引用にはまだ構文がありませんが、 &lt;code&gt;QuoteNode&lt;/code&gt; 型のオブジェクトとして内部的に表されます。</target>
        </trans-unit>
        <trans-unit id="cfe3955e5cc39192c40411a547d67109141fbd1c" translate="yes" xml:space="preserve">
          <source>As we will see next, boxing is required to call Julia functions with specific arguments.</source>
          <target state="translated">次に説明するように、特定の引数でJuliaの関数を呼び出すにはBoxingが必要です。</target>
        </trans-unit>
        <trans-unit id="b53a534247af6d63db181fe8ad6536af06cae1ff" translate="yes" xml:space="preserve">
          <source>As well as information about the &lt;a href=&quot;#Dates.TimeType&quot;&gt;&lt;code&gt;TimeType&lt;/code&gt;&lt;/a&gt;'s year and quarter:</source>
          <target state="translated">&lt;a href=&quot;#Dates.TimeType&quot;&gt; &lt;code&gt;TimeType&lt;/code&gt; &lt;/a&gt;の年と四半期に関する情報と同様に：</target>
        </trans-unit>
        <trans-unit id="834e03682d6f73b9df03b1d3810b4934cc9cc3a8" translate="yes" xml:space="preserve">
          <source>As well as other useful operations, such as finding eigenvalues or eigenvectors:</source>
          <target state="translated">固有値や固有ベクトルを求めるなど、他の有用な操作と同様に。</target>
        </trans-unit>
        <trans-unit id="4983ba754d4bcba44195d81235402b223d67bb4c" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;ccall&lt;/code&gt;, the return type and tuple of input types must be literal constants.</source>
          <target state="translated">&lt;code&gt;ccall&lt;/code&gt; と同様に、戻り値の型と入力型のタプルはリテラル定数でなければなりません。</target>
        </trans-unit>
        <trans-unit id="ce2d2a88a78a8f4ae1b7b6c89e850d2a3f2b6a48" translate="yes" xml:space="preserve">
          <source>As with any &lt;code&gt;ccall&lt;/code&gt;, it is essential to get the argument signature exactly correct. Also, note that there is no compatibility layer that ensures the intrinsic makes sense and works on the current target, unlike the equivalent Julia functions exposed by &lt;code&gt;Core.Intrinsics&lt;/code&gt;.</source>
          <target state="translated">他の &lt;code&gt;ccall&lt;/code&gt; と同様に、引数の署名を正確に取得することが不可欠です。また、 &lt;code&gt;Core.Intrinsics&lt;/code&gt; によって公開されている同等のJulia関数とは異なり、組み込み関数が意味をなし、現在のターゲットで機能することを保証する互換性レイヤーがないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="f496eca34c1af36fc9e6f49533f03b24b7584356" translate="yes" xml:space="preserve">
          <source>As with incomplete objects returned from constructors, if &lt;code&gt;complete_me&lt;/code&gt; or any of its callees try to access the &lt;code&gt;data&lt;/code&gt; field of the &lt;code&gt;Lazy&lt;/code&gt; object before it has been initialized, an error will be thrown immediately.</source>
          <target state="translated">コンストラクタから返される不完全なオブジェクトと同様に、 &lt;code&gt;complete_me&lt;/code&gt; またはその呼び出し先のいずれかが、初期化される前に &lt;code&gt;Lazy&lt;/code&gt; オブジェクトの &lt;code&gt;data&lt;/code&gt; フィールドにアクセスしようとすると、すぐにエラーがスローされます。</target>
        </trans-unit>
        <trans-unit id="206e9628ecffc277c3db7c6ada272a26870edc0c" translate="yes" xml:space="preserve">
          <source>As with literals in the previous section, if literal backticks need to be written within double backticks use an even number greater than two. Note that if a single literal backtick needs to be included within $\LaTeX$ markup then two enclosing backticks is sufficient.</source>
          <target state="translated">前節のリテラルの場合と同様に、リテラルバックティックをダブルバックティックの中に書く必要がある場合は、2つ以上の偶数を使用してください。単一のリテラルバックティックが$LaTeX$マークアップの中に含まれる必要がある場合は、2つの囲みバックティックで十分であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="eb071802c875eedf2628f279f3c3aa261b7f9f4a" translate="yes" xml:space="preserve">
          <source>As with other streams, use &lt;a href=&quot;../../base/io-network/index#Base.close&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; to disconnect the socket:</source>
          <target state="translated">他のストリームと同様に、&lt;a href=&quot;../../base/io-network/index#Base.close&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt;を使用してソケットを切断します。</target>
        </trans-unit>
        <trans-unit id="4caebefb85f01f12aff5118bde420090e55936d8" translate="yes" xml:space="preserve">
          <source>As with variables, Unicode can also be used for function names:</source>
          <target state="translated">変数と同様に、関数名にも Unicode を使用することができます。</target>
        </trans-unit>
        <trans-unit id="f11a9dc367827aceb27fae5caffbfb8a44dc892b" translate="yes" xml:space="preserve">
          <source>As you can see in the examples, logging statements make no mention of where log events go or how they are processed. This is a key design feature that makes the system composable and natural for concurrent use. It does this by separating two different concerns:</source>
          <target state="translated">例を見ればわかるように、ロギングステートメントでは、ログイベントがどこに行くのか、どのように処理されるのかについては一切言及されていません。これは、システムをコンポーザブルで自然な形で同時使用できるようにするための重要な設計機能です。これは、2つの異なる懸念事項を分離することで実現しています。</target>
        </trans-unit>
        <trans-unit id="4b2d88632a2082abc54ba7d8928178e89f90f7d3" translate="yes" xml:space="preserve">
          <source>As you can see, for constructor calls with explicit type parameters, the arguments are converted to the implied field types: &lt;code&gt;Point{Int64}(1,2)&lt;/code&gt; works, but &lt;code&gt;Point{Int64}(1.0,2.5)&lt;/code&gt; raises an &lt;a href=&quot;../../base/base/index#Core.InexactError&quot;&gt;&lt;code&gt;InexactError&lt;/code&gt;&lt;/a&gt; when converting &lt;code&gt;2.5&lt;/code&gt; to &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;. When the type is implied by the arguments to the constructor call, as in &lt;code&gt;Point(1,2)&lt;/code&gt;, then the types of the arguments must agree &amp;ndash; otherwise the &lt;code&gt;T&lt;/code&gt; cannot be determined &amp;ndash; but any pair of real arguments with matching type may be given to the generic &lt;code&gt;Point&lt;/code&gt; constructor.</source>
          <target state="translated">ご覧のように、明示的な型パラメーターを持つコンストラクター呼び出しの場合、引数は暗黙のフィールド型に変換されます &lt;code&gt;Point{Int64}(1.0,2.5)&lt;/code&gt; &lt;code&gt;Point{Int64}(1,2)&lt;/code&gt; 機能しますが、Point {Int64}（1.0,2.5）は、 &lt;code&gt;2.5&lt;/code&gt; の変換時に&lt;a href=&quot;../../base/base/index#Core.InexactError&quot;&gt; &lt;code&gt;InexactError&lt;/code&gt; を&lt;/a&gt;発生させます。&lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt;。 &lt;code&gt;Point(1,2)&lt;/code&gt; のように、コンストラクター呼び出しの引数によって型が暗黙指定されている場合、引数の型は一致する必要があります。一致しない場合、 &lt;code&gt;T&lt;/code&gt; を決定できません。ただし、型が一致する実引数のペアを指定できます。ジェネリック &lt;code&gt;Point&lt;/code&gt; コンストラクターに。</target>
        </trans-unit>
        <trans-unit id="5461c0708bdec655ec8f2787ade84a59cba9a62f" translate="yes" xml:space="preserve">
          <source>As you can see, if the wrong number of elements are in the splatted container, then the function call will fail, just as it would if too many arguments were given explicitly.</source>
          <target state="translated">ご覧のように、間違った数の要素がスプラットされたコンテナにある場合、関数呼び出しは失敗します。</target>
        </trans-unit>
        <trans-unit id="e203af061ceae4264896923db832aa0fc04bb217" translate="yes" xml:space="preserve">
          <source>As you can see, in the first line we asked process 2 to construct a 2-by-2 random matrix, and in the second line we asked it to add 1 to it. The result of both calculations is available in the two futures, &lt;code&gt;r&lt;/code&gt; and &lt;code&gt;s&lt;/code&gt;. The &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawnat&quot;&gt;&lt;code&gt;@spawnat&lt;/code&gt;&lt;/a&gt; macro evaluates the expression in the second argument on the process specified by the first argument.</source>
          <target state="translated">ご覧のとおり、最初の行ではプロセス2に2行2列のランダム行列を作成するように依頼し、2番目の行では1を追加するように依頼しました。両方の計算の結果は、2つの先物 &lt;code&gt;r&lt;/code&gt; と &lt;code&gt;s&lt;/code&gt; で利用できます。&lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawnat&quot;&gt; &lt;code&gt;@spawnat&lt;/code&gt; &lt;/a&gt;マクロは、最初の引数で指定されたプロセス上の二番目の引数での発現を評価します。</target>
        </trans-unit>
        <trans-unit id="741e859119d8cfeca907f894902aa3d526d932dd" translate="yes" xml:space="preserve">
          <source>As you can see, the arguments must be precisely of type &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;. Other numeric types, such as integers or 32-bit floating-point values, are not automatically converted to 64-bit floating-point, nor are strings parsed as numbers. Because &lt;code&gt;Float64&lt;/code&gt; is a concrete type and concrete types cannot be subclassed in Julia, such a definition can only be applied to arguments that are exactly of type &lt;code&gt;Float64&lt;/code&gt;. It may often be useful, however, to write more general methods where the declared parameter types are abstract:</source>
          <target state="translated">ご覧のとおり、引数は&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;型でなければなりません。整数や32ビット浮動小数点値などの他の数値型は、64ビット浮動小数点に自動的に変換されず、文字列は数値として解析されません。ので &lt;code&gt;Float64&lt;/code&gt; 、コンクリートの種類とコンクリートの型はジュリアにサブクラス化することはできませんで、このような定義は厳密に型の引数に適用することもできる &lt;code&gt;Float64&lt;/code&gt; 。ただし、宣言されたパラメーターの型が抽象的である、より一般的なメソッドを作成すると便利な場合があります。</target>
        </trans-unit>
        <trans-unit id="359b67713bb818c1f3c296863f7d844ae4bb9a8a" translate="yes" xml:space="preserve">
          <source>As you can see, the second version, where we used an &lt;code&gt;Int&lt;/code&gt; literal, preserved the type of the input argument, while the first didn't. This is because e.g. &lt;code&gt;promote_type(Int, Float64) == Float64&lt;/code&gt;, and promotion happens with the multiplication. Similarly, &lt;a href=&quot;../../base/numbers/index#Base.Rational&quot;&gt;&lt;code&gt;Rational&lt;/code&gt;&lt;/a&gt; literals are less type disruptive than &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; literals, but more disruptive than &lt;code&gt;Int&lt;/code&gt;s:</source>
          <target state="translated">ご覧のとおり、 &lt;code&gt;Int&lt;/code&gt; リテラルを使用した2番目のバージョンでは入力引数の型が保持されましたが、最初のバージョンでは保持されませんでした。これは、たとえば &lt;code&gt;promote_type(Int, Float64) == Float64&lt;/code&gt; であり、乗算でプロモーションが発生するためです。同様に、&lt;a href=&quot;../../base/numbers/index#Base.Rational&quot;&gt; &lt;code&gt;Rational&lt;/code&gt; &lt;/a&gt;リテラルは&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;リテラルよりもタイプの混乱は少ないですが、 &lt;code&gt;Int&lt;/code&gt; よりは混乱が多くなります。</target>
        </trans-unit>
        <trans-unit id="a10e4a732e45e67918d07e124985de66438f996f" translate="yes" xml:space="preserve">
          <source>As you can see, the space in the &lt;code&gt;path&lt;/code&gt; variable is appropriately escaped. But what if you &lt;em&gt;want&lt;/em&gt; to interpolate multiple words? In that case, just use an array (or any other iterable container):</source>
          <target state="translated">ご覧のとおり、 &lt;code&gt;path&lt;/code&gt; 変数のスペースは適切にエスケープされています。しかし、複数の単語を補間し&lt;em&gt;たい&lt;/em&gt;場合はどうでしょ&lt;em&gt;う&lt;/em&gt;か？その場合は、配列（またはその他の反復可能なコンテナー）を使用します。</target>
        </trans-unit>
        <trans-unit id="43e3dc387959de6b7b510dc6136369a6354233c2" translate="yes" xml:space="preserve">
          <source>As you can see, the type of the appended element must match the element type of the vector it is appended to, or else a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt; is raised. In the following example, the method type parameter &lt;code&gt;T&lt;/code&gt; is used as the return value:</source>
          <target state="translated">ご覧のとおり、追加された要素のタイプは、追加先のベクターの要素タイプと一致する必要があります。一致しない場合、&lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; &lt;/a&gt;が発生します。次の例では、メソッドタイプパラメータ &lt;code&gt;T&lt;/code&gt; が戻り値として使用されています。</target>
        </trans-unit>
        <trans-unit id="b29b566be209e38051caa728ad8f87323746dc77" translate="yes" xml:space="preserve">
          <source>As you could see, the reduction operator can be omitted if it is not needed. In that case, the loop executes asynchronously, i.e. it spawns independent tasks on all available workers and returns an array of &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; immediately without waiting for completion. The caller can wait for the &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; completions at a later point by calling &lt;code&gt;fetch&lt;/code&gt; on them, or wait for completion at the end of the loop by prefixing it with &lt;a href=&quot;../../base/parallel/index#Base.@sync&quot;&gt;&lt;code&gt;@sync&lt;/code&gt;&lt;/a&gt;, like &lt;code&gt;@sync @distributed for&lt;/code&gt;.</source>
          <target state="translated">ご覧のとおり、不要な場合はリダクション演算子を省略できます。その場合、ループは非同期で実行されます。つまり、利用可能なすべてのワーカーで独立したタスクが生成され、完了を待たずにすぐに&lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; の&lt;/a&gt;配列が返されます。呼び出し側は、後で &lt;code&gt;fetch&lt;/code&gt; を呼び出して&lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; の&lt;/a&gt;完了を待機するか、 &lt;code&gt;@sync @distributed for&lt;/code&gt; のように@syncを前に付けてループの終わりで完了を待機することが&lt;a href=&quot;../../base/parallel/index#Base.@sync&quot;&gt; &lt;code&gt;@sync&lt;/code&gt; &lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="f1a150349a442b853a138e3c1fe4e3f7948f68a2" translate="yes" xml:space="preserve">
          <source>As you may have realized, while memory associated with globals may be collected when they are reassigned on the master, no such action is taken on the workers as the bindings continue to be valid. &lt;code&gt;clear!&lt;/code&gt; can be used to manually reassign specific globals on remote nodes to &lt;code&gt;nothing&lt;/code&gt; once they are no longer required. This will release any memory associated with them as part of a regular garbage collection cycle.</source>
          <target state="translated">ご存知かもしれませんが、グローバルに関連付けられたメモリはマスターで再割り当てされるときに収集される可能性がありますが、バインディングが引き続き有効であるため、そのようなアクションはワーカーで実行されません。 &lt;code&gt;clear!&lt;/code&gt; 不要になったリモートノードの特定のグローバルを手動で &lt;code&gt;nothing&lt;/code&gt; 割り当てられないようにするために使用できます。これにより、通常のガベージコレクションサイクルの一部として、関連付けられているメモリが解放されます。</target>
        </trans-unit>
        <trans-unit id="dacd35c567b889475ef2a3c6c433ab70c5f4775a" translate="yes" xml:space="preserve">
          <source>Assign &lt;code&gt;x&lt;/code&gt; to a named field in &lt;code&gt;value&lt;/code&gt; of composite type. The &lt;code&gt;value&lt;/code&gt; must be mutable and &lt;code&gt;x&lt;/code&gt; must be a subtype of &lt;code&gt;fieldtype(typeof(value), name)&lt;/code&gt;. See also &lt;a href=&quot;#Base.setproperty!&quot;&gt;&lt;code&gt;setproperty!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">複合型の &lt;code&gt;value&lt;/code&gt; の名前付きフィールドに &lt;code&gt;x&lt;/code&gt; を割り当てます。 &lt;code&gt;value&lt;/code&gt; 変更可能でなければならず、 &lt;code&gt;x&lt;/code&gt; のサブタイプでなければならない &lt;code&gt;fieldtype(typeof(value), name)&lt;/code&gt; 。&lt;a href=&quot;#Base.setproperty!&quot;&gt; &lt;code&gt;setproperty!&lt;/code&gt; &lt;/a&gt;も参照してください！。</target>
        </trans-unit>
        <trans-unit id="31839985af6b213c58cad9bbfe8e7aebd2198424" translate="yes" xml:space="preserve">
          <source>Assign a value to a key in the current task's task-local storage.</source>
          <target state="translated">現在のタスクのタスクローカルストレージのキーに値を割り当てます。</target>
        </trans-unit>
        <trans-unit id="343021dcf6fd7efdb357d926be862e74219ddb49" translate="yes" xml:space="preserve">
          <source>Assigning &lt;code&gt;[]&lt;/code&gt; does not eliminate elements from a collection; instead use &lt;a href=&quot;../collections/index#Base.filter!&quot;&gt;&lt;code&gt;filter!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;[]&lt;/code&gt; を割り当てても、コレクションから要素が削除されるわけではありません。代わりに&lt;a href=&quot;../collections/index#Base.filter!&quot;&gt; &lt;code&gt;filter!&lt;/code&gt; &lt;/a&gt;を使用してください！。</target>
        </trans-unit>
        <trans-unit id="6144b75b7bde706b0577dc11bf2dc87a5f571732" translate="yes" xml:space="preserve">
          <source>Assigning &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;b&lt;/code&gt; does not create a copy of &lt;code&gt;b&lt;/code&gt;; instead use &lt;a href=&quot;#Base.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Base.deepcopy&quot;&gt;&lt;code&gt;deepcopy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">割り当てに &lt;code&gt;b&lt;/code&gt; のコピーを作成しません &lt;code&gt;b&lt;/code&gt; は、代わりに、&lt;a href=&quot;#Base.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;#Base.deepcopy&quot;&gt; &lt;code&gt;deepcopy&lt;/code&gt; を&lt;/a&gt;使用してください。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="07a6f2ac6ae10af3c874613ad299e2e22c70e6b5" translate="yes" xml:space="preserve">
          <source>Assigning numbers into &lt;code&gt;a&lt;/code&gt; will now convert them to &lt;code&gt;Float64&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; will be stored as a contiguous block of 64-bit floating-point values that can be manipulated efficiently.</source>
          <target state="translated">番号を割り当てる今にそれらを変換する &lt;code&gt;Float64&lt;/code&gt; と効率的に操作することができる64ビットの浮動小数点値の連続したブロックとして格納されます。 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="335227cba10c33b5a2154427c17bb8a45448ea75" translate="yes" xml:space="preserve">
          <source>Assigning to a field of an object converts to the declared type of the field.</source>
          <target state="translated">オブジェクトのフィールドに代入すると、そのフィールドの宣言された型に変換されます。</target>
        </trans-unit>
        <trans-unit id="ea3c536f7d8386d0d34fa46bb187211a095b9597" translate="yes" xml:space="preserve">
          <source>Assigning to a variable with a declared type (e.g. &lt;code&gt;local x::T&lt;/code&gt;) converts to that type.</source>
          <target state="translated">宣言された型（たとえば、 &lt;code&gt;local x::T&lt;/code&gt; ）を持つ変数に割り当てると、その型に変換されます。</target>
        </trans-unit>
        <trans-unit id="4352a222d8d135ef7905c51dc5e73ca198e904f1" translate="yes" xml:space="preserve">
          <source>Assigning to an array converts to the array's element type.</source>
          <target state="translated">配列に代入すると、配列の要素型に変換されます。</target>
        </trans-unit>
        <trans-unit id="e55df441e8955746182110c3946288f381520e83" translate="yes" xml:space="preserve">
          <source>Assignment</source>
          <target state="translated">Assignment</target>
        </trans-unit>
        <trans-unit id="caee9fcfeeacb92daf3a9dd06e9024b473eac387" translate="yes" xml:space="preserve">
          <source>Assignment at out-of-bounds indices does not grow a collection. If the collection is a &lt;a href=&quot;../arrays/index#Base.Vector&quot;&gt;&lt;code&gt;Vector&lt;/code&gt;&lt;/a&gt; it can instead be grown with &lt;a href=&quot;../collections/index#Base.push!&quot;&gt;&lt;code&gt;push!&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../collections/index#Base.append!&quot;&gt;&lt;code&gt;append!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">範囲外のインデックスでの割り当ては、コレクションを拡大しません。コレクションが&lt;a href=&quot;../arrays/index#Base.Vector&quot;&gt; &lt;code&gt;Vector&lt;/code&gt; &lt;/a&gt;場合は、代わりに&lt;a href=&quot;../collections/index#Base.push!&quot;&gt; &lt;code&gt;push!&lt;/code&gt; &lt;/a&gt;で拡張できます！または&lt;a href=&quot;../collections/index#Base.append!&quot;&gt; &lt;code&gt;append!&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cca9fba860c54e60aaec525df6854ad412b1850b" translate="yes" xml:space="preserve">
          <source>Assignment can operate on multiple variables in parallel, taking values from an iterable:</source>
          <target state="translated">代入は、複数の変数を並行して操作することができ、イテレータブルから値を取ることができます。</target>
        </trans-unit>
        <trans-unit id="729134453eca052fa22a956f1ac0e88899ca88fa" translate="yes" xml:space="preserve">
          <source>Assignment can operate on multiple variables in series, and will return the value of the right-hand-most expression:</source>
          <target state="translated">代入は複数の変数を直列に操作することができ、右端の式の値を返します。</target>
        </trans-unit>
        <trans-unit id="a4c2fee77618ccc921a63bc548e408d4da3037fb" translate="yes" xml:space="preserve">
          <source>Assignment to &lt;code&gt;s&lt;/code&gt; in soft scope is ambiguous because a global variable by the same name exists: &lt;code&gt;s&lt;/code&gt; will be treated as a new local. Disambiguate by using &lt;code&gt;local s&lt;/code&gt; to suppress this warning or &lt;code&gt;global s&lt;/code&gt; to assign to the existing global variable.</source>
          <target state="translated">割り当て &lt;code&gt;s&lt;/code&gt; 同じ名前のグローバル変数が存在するため、ソフト範囲ではあいまいです： &lt;code&gt;s&lt;/code&gt; が新しいローカルとして扱われます。 &lt;code&gt;local s&lt;/code&gt; を使用してこの警告を抑制したり、 &lt;code&gt;global s&lt;/code&gt; を使用して既存のグローバル変数に割り当てたりして、曖昧さを解消します。</target>
        </trans-unit>
        <trans-unit id="057d58c74d80136578cabbeee1b89206c3250bd4" translate="yes" xml:space="preserve">
          <source>Assignments</source>
          <target state="translated">Assignments</target>
        </trans-unit>
        <trans-unit id="a997f01f100c5327776cf22824dbe2d9bd2208d2" translate="yes" xml:space="preserve">
          <source>Associate the lifetime of &lt;code&gt;chnl&lt;/code&gt; with a task. &lt;code&gt;Channel&lt;/code&gt;&lt;code&gt;chnl&lt;/code&gt; is automatically closed when the task terminates. Any uncaught exception in the task is propagated to all waiters on &lt;code&gt;chnl&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;chnl&lt;/code&gt; の存続期間をタスクに関連付けます。タスクが終了すると、 &lt;code&gt;Channel&lt;/code&gt; &lt;code&gt;chnl&lt;/code&gt; は自動的に閉じられます。タスクでキャッチされなかった例外は、 &lt;code&gt;chnl&lt;/code&gt; のすべてのウェイターに伝達されます。</target>
        </trans-unit>
        <trans-unit id="59f2aa2b1552b74e34281b33bf3cbb05f68d9bae" translate="yes" xml:space="preserve">
          <source>Associative collections (such as &lt;code&gt;Dict&lt;/code&gt; and &lt;code&gt;Set&lt;/code&gt;) need to be re-hashed in &lt;code&gt;__init__&lt;/code&gt;. (In the future, a mechanism may be provided to register an initializer function.)</source>
          <target state="translated">連想コレクション（ &lt;code&gt;Dict&lt;/code&gt; や &lt;code&gt;Set&lt;/code&gt; など）は &lt;code&gt;__init__&lt;/code&gt; で再ハッシュする必要があります。（将来、イニシャライザ関数を登録するメカニズムが提供される可能性があります。）</target>
        </trans-unit>
        <trans-unit id="d20b5a26a1cdf631954b50a5206246dff93d9c8a" translate="yes" xml:space="preserve">
          <source>Associativity</source>
          <target state="translated">Associativity</target>
        </trans-unit>
        <trans-unit id="31eabac4e8c06c32e7c19300707a41f9f210b6ee" translate="yes" xml:space="preserve">
          <source>Assuming no method more specific than the above is found, Julia next internally defines and compiles a method called &lt;code&gt;myplus&lt;/code&gt; specifically for two &lt;code&gt;Int&lt;/code&gt; arguments based on the generic function given above, i.e., it implicitly defines and compiles:</source>
          <target state="translated">上記より具体的なメソッドが見つからない場合、Juliaは次に、上記の汎用関数に基づいて、2つの &lt;code&gt;Int&lt;/code&gt; 引数用に &lt;code&gt;myplus&lt;/code&gt; というメソッドを内部的に定義およびコンパイルします。つまり、暗黙的に定義およびコンパイルします。</target>
        </trans-unit>
        <trans-unit id="2717ba36a09eb99678b64bb90dc485e6b0a0d557" translate="yes" xml:space="preserve">
          <source>Asterisk Operator</source>
          <target state="translated">アスタリスク演算子</target>
        </trans-unit>
        <trans-unit id="07b5380b9f5c5fd84a32bc659548c9dfab4533bb" translate="yes" xml:space="preserve">
          <source>Astonished Face</source>
          <target state="translated">驚いた顔</target>
        </trans-unit>
        <trans-unit id="b66ee82704200b04b4798e66b6593db1b1b13374" translate="yes" xml:space="preserve">
          <source>Asymptotically Equal To</source>
          <target state="translated">に漸近的に等しい</target>
        </trans-unit>
        <trans-unit id="5245f726138014634759729b99de5b3247dde5eb" translate="yes" xml:space="preserve">
          <source>AsyncCondition</source>
          <target state="translated">AsyncCondition</target>
        </trans-unit>
        <trans-unit id="8eaa017d84f0d81a23063919ee4ccb624ecbac15" translate="yes" xml:space="preserve">
          <source>AsyncCondition()</source>
          <target state="translated">AsyncCondition()</target>
        </trans-unit>
        <trans-unit id="1b797bdd1bcf1af4799cd31c8e25a767ad70f14e" translate="yes" xml:space="preserve">
          <source>Asynchronous &quot;tasks&quot;, or coroutines</source>
          <target state="translated">非同期の「タスク」、またはコアーチン</target>
        </trans-unit>
        <trans-unit id="97d88f0cd43a7c5afba791559c54e8c7a9720c83" translate="yes" xml:space="preserve">
          <source>Asynchronous IO and concurrent synchronous writes</source>
          <target state="translated">非同期IOと同時同期書き込み</target>
        </trans-unit>
        <trans-unit id="8148eff566285bcd48743fb742f972c7a1dd962f" translate="yes" xml:space="preserve">
          <source>Asynchronous Programming</source>
          <target state="translated">非同期プログラミング</target>
        </trans-unit>
        <trans-unit id="d61dfe1b51eb0bad1bc9d8b0b12b232b76aa4667" translate="yes" xml:space="preserve">
          <source>At &lt;code&gt;-O3&lt;/code&gt;, the compiler &lt;em&gt;might&lt;/em&gt; automatically vectorize operations on such tuples. For example, the following program, when compiled with &lt;code&gt;julia -O3&lt;/code&gt; generates two SIMD addition instructions (&lt;code&gt;addps&lt;/code&gt;) on x86 systems:</source>
          <target state="translated">で &lt;code&gt;-O3&lt;/code&gt; 、コンパイラが&lt;em&gt;あります&lt;/em&gt;自動的に、そのようなタプルの操作をベクトル化します。たとえば、次のプログラムを &lt;code&gt;julia -O3&lt;/code&gt; でコンパイルすると、x86システムで2つのSIMD追加命令（ &lt;code&gt;addps&lt;/code&gt; ）が生成されます。</target>
        </trans-unit>
        <trans-unit id="eb9e6602f2f530b7763a4fc47a789b6bcda1d592" translate="yes" xml:space="preserve">
          <source>At a high-level, each environment conceptually defines three maps: roots, graph and paths. When resolving the meaning of &lt;code&gt;import X&lt;/code&gt;, the roots and graph maps are used to determine the identity of &lt;code&gt;X&lt;/code&gt;, while the paths map is used to locate the source code of &lt;code&gt;X&lt;/code&gt;. The specific roles of the three maps are:</source>
          <target state="translated">高レベルでは、各環境は3つのマップ（ルート、グラフ、パス）を概念的に定義します。 &lt;code&gt;import X&lt;/code&gt; の意味を解決するとき、ルートマップとグラフマップを使用して &lt;code&gt;X&lt;/code&gt; のIDを決定し、パスマップを使用して &lt;code&gt;X&lt;/code&gt; のソースコードを見つけます。 3つのマップの特定の役割は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="1f9ae804041641dde19215ce7dbf17a3259634a7" translate="yes" xml:space="preserve">
          <source>At first blush, this seems reasonable enough since 9223372036854775807 is much closer to 9223372036854775808 than -9223372036854775808 is and integers are still represented with a fixed size in a natural way that is compatible with C and Fortran. Saturated integer arithmetic, however, is deeply problematic. The first and most obvious issue is that this is not the way machine integer arithmetic works, so implementing saturated operations requires emitting instructions after each machine integer operation to check for underflow or overflow and replace the result with &lt;a href=&quot;../../base/base/index#Base.typemin&quot;&gt;&lt;code&gt;typemin(Int)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../base/base/index#Base.typemax&quot;&gt;&lt;code&gt;typemax(Int)&lt;/code&gt;&lt;/a&gt; as appropriate. This alone expands each integer operation from a single, fast instruction into half a dozen instructions, probably including branches. Ouch. But it gets worse &amp;ndash; saturating integer arithmetic isn't associative. Consider this Matlab computation:</source>
          <target state="translated">9223372036854775807は-9223372036854775808よりも9223372036854775808にはるかに近く、整数は依然としてCおよびFortranと互換性のある自然な方法で固定サイズで表されているため、最初は赤面してこれは十分に妥当と思われます。ただし、飽和整数演算は非常に問題があります。最初の最も明らかな問題は、これがマシン整数演算の方法ではないことです。したがって、飽和演算を実装するには、各マシン整数演算の後に命令を&lt;a href=&quot;../../base/base/index#Base.typemin&quot;&gt; &lt;code&gt;typemin(Int)&lt;/code&gt; &lt;/a&gt;、アンダーフローまたはオーバーフローをチェックし、結果をtypemin（Int）または&lt;a href=&quot;../../base/base/index#Base.typemax&quot;&gt; &lt;code&gt;typemax(Int)&lt;/code&gt; で&lt;/a&gt;置き換える必要があります。適切に。これだけで、各整数演算が単一の高速命令から、おそらく分岐を含む6命令に拡張されます。痛い。しかし、状況はさらに悪化します&amp;ndash;飽和整数演算は連想的ではありません。次のMatlab計算を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="9939b5009359c95078c2105da459f4858711c0ae" translate="yes" xml:space="preserve">
          <source>At least Julia 1.4 is required for specifying a module.</source>
          <target state="translated">モジュールを指定するには最低でもJulia 1.4が必要です。</target>
        </trans-unit>
        <trans-unit id="557269c7906899330df530ce61ccdd6c30d22fca" translate="yes" xml:space="preserve">
          <source>At the base of this functionality is &lt;a href=&quot;../../stdlib/sockets/index#Sockets.getaddrinfo&quot;&gt;&lt;code&gt;getaddrinfo&lt;/code&gt;&lt;/a&gt;, which will do the appropriate address resolution:</source>
          <target state="translated">この機能のベースは&lt;a href=&quot;../../stdlib/sockets/index#Sockets.getaddrinfo&quot;&gt; &lt;code&gt;getaddrinfo&lt;/code&gt; &lt;/a&gt;で、適切なアドレス解決を行います。</target>
        </trans-unit>
        <trans-unit id="dc65621fc57dd780fd2d22a2ad965178ea5de343" translate="yes" xml:space="preserve">
          <source>At the top, the inferred return type of the function is shown as &lt;code&gt;Body::Float64&lt;/code&gt;. The next lines represent the body of &lt;code&gt;f&lt;/code&gt; in Julia's SSA IR form. The numbered boxes are labels and represent targets for jumps (via &lt;code&gt;goto&lt;/code&gt;) in your code. Looking at the body, you can see that the first thing that happens is that &lt;code&gt;pos&lt;/code&gt; is called and the return value has been inferred as the &lt;code&gt;Union&lt;/code&gt; type &lt;code&gt;UNION{FLOAT64, INT64}&lt;/code&gt; shown in uppercase since it is a non-concrete type. This means that we cannot know the exact return type of &lt;code&gt;pos&lt;/code&gt; based on the input types. However, the result of &lt;code&gt;y*x&lt;/code&gt;is a &lt;code&gt;Float64&lt;/code&gt; no matter if &lt;code&gt;y&lt;/code&gt; is a &lt;code&gt;Float64&lt;/code&gt; or &lt;code&gt;Int64&lt;/code&gt; The net result is that &lt;code&gt;f(x::Float64)&lt;/code&gt; will not be type-unstable in its output, even if some of the intermediate computations are type-unstable.</source>
          <target state="translated">上部には、関数の推定戻り値の型が &lt;code&gt;Body::Float64&lt;/code&gt; として示されています。次の行は、ジュリアのSSA IR形式の &lt;code&gt;f&lt;/code&gt; の本体を表しています。番号付きのボックスはラベルであり、コード内の（ &lt;code&gt;goto&lt;/code&gt; を介した）ジャンプのターゲットを表します。本文を見ると、最初に起こるのは &lt;code&gt;pos&lt;/code&gt; が呼び出され、戻り値が非コンクリート型であるため、 &lt;code&gt;Union&lt;/code&gt; 型の &lt;code&gt;UNION{FLOAT64, INT64}&lt;/code&gt; が大文字で示されていると推測されていることがわかります。これは、入力タイプに基づいて &lt;code&gt;pos&lt;/code&gt; の正確な戻りタイプを知ることができないことを意味します。しかし、結果 &lt;code&gt;y*x&lt;/code&gt; されていない &lt;code&gt;Float64&lt;/code&gt; に関係なく、もし &lt;code&gt;y&lt;/code&gt; は &lt;code&gt;Float64&lt;/code&gt; または &lt;code&gt;Int64&lt;/code&gt; です。最終的な結果として、 &lt;code&gt;f(x::Float64)&lt;/code&gt; は、中間計算の一部が型不安定であっても、その出力では型不安定ではありません。</target>
        </trans-unit>
        <trans-unit id="4b8bfb8cb1b051b835dbefff1b5c12822cd90431" translate="yes" xml:space="preserve">
          <source>At this point, the project should build and run.</source>
          <target state="translated">この時点で、プロジェクトをビルドして実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="07f4310d23db89112b431f6fd02d1ccd231d2fd9" translate="yes" xml:space="preserve">
          <source>At this time, most operations in the Julia runtime and standard libraries can be used in a thread-safe manner, if the user code is data-race free. However, in some areas work on stabilizing thread support is ongoing. Multi-threaded programming has many inherent difficulties, and if a program using threads exhibits unusual or undesirable behavior (e.g. crashes or mysterious results), thread interactions should typically be suspected first.</source>
          <target state="translated">現時点では、ユーザコードがデータレースのないものであれば、Juliaランタイムと標準ライブラリのほとんどの操作はスレッドセーフな方法で使用できます。しかし、いくつかの分野では、スレッドのサポートを安定化させるための作業が進行中です。マルチスレッドプログラミングには多くの困難が内在しており、スレッドを使用したプログラムが異常な動作や望ましくない動作(クラッシュや不可解な結果など)を示す場合は、一般的にスレッドの相互作用をまず疑うべきです。</target>
        </trans-unit>
        <trans-unit id="11e4a73a06b9dee6071ddafa6ecf05d8154a9294" translate="yes" xml:space="preserve">
          <source>Athletic Shoe</source>
          <target state="translated">アスレチックシューズ</target>
        </trans-unit>
        <trans-unit id="f3fbd2fd9cc354420ab6c1b9170e0b29144a85e6" translate="yes" xml:space="preserve">
          <source>Atomic Operations</source>
          <target state="translated">原子操作</target>
        </trans-unit>
        <trans-unit id="ad3b6bf5f22249f1093a69cf5b097656cf10a2e0" translate="yes" xml:space="preserve">
          <source>Atomic objects can be accessed using the &lt;code&gt;[]&lt;/code&gt; notation:</source>
          <target state="translated">アトミックオブジェクトは、 &lt;code&gt;[]&lt;/code&gt; 表記を使用してアクセスできます。</target>
        </trans-unit>
        <trans-unit id="fb34ad6782840b3609292d56d50524837de11852" translate="yes" xml:space="preserve">
          <source>Atomic operations</source>
          <target state="translated">原子操作</target>
        </trans-unit>
        <trans-unit id="33b48033c48155a217b1ebf999c90a4b598f3e71" translate="yes" xml:space="preserve">
          <source>Atomic operations use an &lt;code&gt;atomic_&lt;/code&gt; prefix, such as &lt;a href=&quot;#Base.Threads.atomic_add!&quot;&gt;&lt;code&gt;atomic_add!&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#Base.Threads.atomic_xchg!&quot;&gt;&lt;code&gt;atomic_xchg!&lt;/code&gt;&lt;/a&gt;, etc.</source>
          <target state="translated">アトミック操作は、&lt;a href=&quot;#Base.Threads.atomic_add!&quot;&gt; &lt;code&gt;atomic_add!&lt;/code&gt; &lt;/a&gt;などの &lt;code&gt;atomic_&lt;/code&gt; 接頭辞を使用します。、&lt;a href=&quot;#Base.Threads.atomic_xchg!&quot;&gt; &lt;code&gt;atomic_xchg!&lt;/code&gt; &lt;/a&gt;、など</target>
        </trans-unit>
        <trans-unit id="ad6e575d4f77e8328667d22e1296bcc529f4eb15" translate="yes" xml:space="preserve">
          <source>Atomically add &lt;code&gt;val&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">アトミック追加 &lt;code&gt;val&lt;/code&gt; に &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="98b4786f90c42de0fa6575d5c8690c2d57540c23" translate="yes" xml:space="preserve">
          <source>Atomically bitwise-and &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;val&lt;/code&gt;</source>
          <target state="translated">原子的にビットごとに &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;val&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7c59f0d3e8acb12180dbf858879145e09dbd4d31" translate="yes" xml:space="preserve">
          <source>Atomically bitwise-nand (not-and) &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;val&lt;/code&gt;</source>
          <target state="translated">アトミックビット単位-NAND（未と） &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;val&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="49dfbe4ce1039803bba1e66c619d680aaacd0303" translate="yes" xml:space="preserve">
          <source>Atomically bitwise-or &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;val&lt;/code&gt;</source>
          <target state="translated">原子的にビット単位の論理和または &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;val&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="361657c422d3986bfb8673c88d09205f8b549983" translate="yes" xml:space="preserve">
          <source>Atomically bitwise-xor (exclusive-or) &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;val&lt;/code&gt;</source>
          <target state="translated">アトミックビット単位-XOR（排他的論理和） &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;val&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="720563406f6bfeb8b472dd6dd26fe3888437904c" translate="yes" xml:space="preserve">
          <source>Atomically compare-and-set &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">原子的に比較して設定する &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2cea0404569a918b8e5d8c74ca2a23340344009b" translate="yes" xml:space="preserve">
          <source>Atomically compares the value in &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;cmp&lt;/code&gt;. If equal, write &lt;code&gt;newval&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;. Otherwise, leaves &lt;code&gt;x&lt;/code&gt; unmodified. Returns the old value in &lt;code&gt;x&lt;/code&gt;. By comparing the returned value to &lt;code&gt;cmp&lt;/code&gt; (via &lt;code&gt;===&lt;/code&gt;) one knows whether &lt;code&gt;x&lt;/code&gt; was modified and now holds the new value &lt;code&gt;newval&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; の値を &lt;code&gt;cmp&lt;/code&gt; と原子的に比較します。等しい場合、 &lt;code&gt;newval&lt;/code&gt; を &lt;code&gt;x&lt;/code&gt; に書き込みます。それ以外の場合、 &lt;code&gt;x&lt;/code&gt; は変更されません。 &lt;code&gt;x&lt;/code&gt; の古い値を返します。返された値を（ &lt;code&gt;===&lt;/code&gt; を介して） &lt;code&gt;cmp&lt;/code&gt; と比較することで、 &lt;code&gt;x&lt;/code&gt; が変更されたかどうかが &lt;code&gt;newval&lt;/code&gt; 、新しい値newvalが保持されます。</target>
        </trans-unit>
        <trans-unit id="db092cd5c9d8911e3a523593755743a6ba3ff929" translate="yes" xml:space="preserve">
          <source>Atomically exchange the value in &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; の値を原子的に交換する</target>
        </trans-unit>
        <trans-unit id="ede158726902e9e7c885034b5dc7b476eaa3f0cb" translate="yes" xml:space="preserve">
          <source>Atomically exchanges the value in &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;newval&lt;/code&gt;. Returns the &lt;strong&gt;old&lt;/strong&gt; value.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; の値を原子的に &lt;code&gt;newval&lt;/code&gt; と交換します。&lt;strong&gt;古い&lt;/strong&gt;値を返します。</target>
        </trans-unit>
        <trans-unit id="c3d2e4b23d13f6bba7a47950035a93b86bb83a39" translate="yes" xml:space="preserve">
          <source>Atomically store the maximum of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;val&lt;/code&gt; in &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">アトミックの最大格納 &lt;code&gt;x&lt;/code&gt; 及び &lt;code&gt;val&lt;/code&gt; で &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="df88790f08323bff2d950ce1c8f1b209a38e86ef" translate="yes" xml:space="preserve">
          <source>Atomically store the minimum of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;val&lt;/code&gt; in &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">アトミックの最小格納 &lt;code&gt;x&lt;/code&gt; 及び &lt;code&gt;val&lt;/code&gt; で &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="689e84464421ff470b8dc38055180d25d70684c4" translate="yes" xml:space="preserve">
          <source>Atomically subtract &lt;code&gt;val&lt;/code&gt; from &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; から &lt;code&gt;val&lt;/code&gt; を原子的に減算します</target>
        </trans-unit>
        <trans-unit id="9a5910ec96daddf32d8679bdc1681e3d2b896833" translate="yes" xml:space="preserve">
          <source>Attempt an automatic merge rebase of the current branch, from &lt;code&gt;upstream&lt;/code&gt; if provided, or otherwise from the upstream tracking branch. &lt;code&gt;newbase&lt;/code&gt; is the branch to rebase onto. By default this is &lt;code&gt;upstream&lt;/code&gt;.</source>
          <target state="translated">現在のブランチの自動マージリベースを試みる &lt;code&gt;upstream&lt;/code&gt; 、またはそうでなければ、上流側のトラッキングブランチから提供された場合。 &lt;code&gt;newbase&lt;/code&gt; はリベースするブランチです。デフォルトでは &lt;code&gt;upstream&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="67fbdff1fd74a3e2ffeba20e52cb54a817a837a9" translate="yes" xml:space="preserve">
          <source>Aubergine</source>
          <target state="translated">Aubergine</target>
        </trans-unit>
        <trans-unit id="237f5a2b8d61f639bee4e8b48edc5e86ef3821ad" translate="yes" xml:space="preserve">
          <source>Auto-conversion:</source>
          <target state="translated">Auto-conversion:</target>
        </trans-unit>
        <trans-unit id="83f8ababd899b8c0947ef4217c49ed91a00e554d" translate="yes" xml:space="preserve">
          <source>Automated Teller Machine</source>
          <target state="translated">自動テラー機</target>
        </trans-unit>
        <trans-unit id="674ab38ea62e0b4a07e2dda58e235dd6968ef52f" translate="yes" xml:space="preserve">
          <source>Automatic Type Conversion</source>
          <target state="translated">自動タイプ変換</target>
        </trans-unit>
        <trans-unit id="d3ff4de6909c953084efbf3fcf51ba0455525196" translate="yes" xml:space="preserve">
          <source>Automatic generation of efficient, specialized code for different argument types</source>
          <target state="translated">異なる引数タイプに対応した効率的で特殊なコードの自動生成</target>
        </trans-unit>
        <trans-unit id="e3d0413f1114ca7420957b409369ba320c5e643a" translate="yes" xml:space="preserve">
          <source>Automobile</source>
          <target state="translated">Automobile</target>
        </trans-unit>
        <trans-unit id="c2381c9ae6de19786317e42c36cfe48f1d110cd4" translate="yes" xml:space="preserve">
          <source>Available for method extension</source>
          <target state="translated">メソッドの拡張に利用可能</target>
        </trans-unit>
        <trans-unit id="1913fba71b8ad5575c96582256e93730389a751d" translate="yes" xml:space="preserve">
          <source>Avoid changing the type of a variable</source>
          <target state="translated">変数の型を変更しないようにする</target>
        </trans-unit>
        <trans-unit id="491716d25d0cc5eef3fc083042b6cf3fb1c73628" translate="yes" xml:space="preserve">
          <source>Avoid confusion about whether something is an instance or a type</source>
          <target state="translated">インスタンスなのか型なのかの混乱を避ける</target>
        </trans-unit>
        <trans-unit id="f43c7e32c4f8af3884df62b42a58c3f06c2cb00b" translate="yes" xml:space="preserve">
          <source>Avoid containers with abstract type parameters</source>
          <target state="translated">抽象型のパラメータを持つコンテナを避ける</target>
        </trans-unit>
        <trans-unit id="a69832582d8c220962ec16f3f74807795126efb7" translate="yes" xml:space="preserve">
          <source>Avoid elaborate container types</source>
          <target state="translated">凝った容器の種類を避ける</target>
        </trans-unit>
        <trans-unit id="5a42b7935afc0b3ec5008a2229ca382f69673505" translate="yes" xml:space="preserve">
          <source>Avoid fields with abstract containers</source>
          <target state="translated">抽象的なコンテナを持つフィールドを避ける</target>
        </trans-unit>
        <trans-unit id="f619d134c2c6942d7932e906b9ce6c23d632cfef" translate="yes" xml:space="preserve">
          <source>Avoid fields with abstract type</source>
          <target state="translated">抽象型のフィールドを避ける</target>
        </trans-unit>
        <trans-unit id="ea9c797001a229bb0f7e2e5dcae3538ba2a55b2c" translate="yes" xml:space="preserve">
          <source>Avoid global variables</source>
          <target state="translated">グローバル変数を避ける</target>
        </trans-unit>
        <trans-unit id="8c84ddcd06891b88969d0af7db4510b7be8ee56a" translate="yes" xml:space="preserve">
          <source>Avoid running top-level operations, e.g. &lt;code&gt;include&lt;/code&gt;, or &lt;code&gt;eval&lt;/code&gt; of type, method, and module definitions in parallel.</source>
          <target state="translated">最上位の操作を実行することは避けてください。たとえば &lt;code&gt;include&lt;/code&gt; 型、メソッド、およびモジュール定義のinclude、 &lt;code&gt;eval&lt;/code&gt; を並行して実行します。</target>
        </trans-unit>
        <trans-unit id="03b73d63c4cb77f3bf8c6e423749bbf23c01ee5d" translate="yes" xml:space="preserve">
          <source>Avoid strange type &lt;code&gt;Union&lt;/code&gt;s</source>
          <target state="translated">奇妙なタイプ避け &lt;code&gt;Union&lt;/code&gt; 秒</target>
        </trans-unit>
        <trans-unit id="79292115b6e992f614cf724c1dfa9586d06bbe03" translate="yes" xml:space="preserve">
          <source>Avoid string interpolation for I/O</source>
          <target state="translated">I/Oのための文字列補間を避ける</target>
        </trans-unit>
        <trans-unit id="8a11c76e8b2bd9a028ae58c6c15b510f4680d17f" translate="yes" xml:space="preserve">
          <source>Avoid type piracy</source>
          <target state="translated">タイプの海賊版を避ける</target>
        </trans-unit>
        <trans-unit id="bf3ba609a722d28177b4a138e6e131e1148dc2ff" translate="yes" xml:space="preserve">
          <source>Avoid unnecessary arrays. For example, instead of &lt;a href=&quot;../../base/collections/index#Base.sum&quot;&gt;&lt;code&gt;sum([x,y,z])&lt;/code&gt;&lt;/a&gt; use &lt;code&gt;x+y+z&lt;/code&gt;.</source>
          <target state="translated">不要な配列は避けてください。たとえば、&lt;a href=&quot;../../base/collections/index#Base.sum&quot;&gt; &lt;code&gt;sum([x,y,z])&lt;/code&gt; &lt;/a&gt;代わりに &lt;code&gt;x+y+z&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="b9540041dc787b11f982141e4085503960ffd2c7" translate="yes" xml:space="preserve">
          <source>Avoid using floats for numeric literals in generic code when possible</source>
          <target state="translated">一般的なコードでは、可能な限り数値リテラルにフロートを使用しないようにしてください。</target>
        </trans-unit>
        <trans-unit id="4802b2a45694be10a378fb271220844de2096707" translate="yes" xml:space="preserve">
          <source>Avoid using passwords in URLs. Unlike the credential objects, Julia is not able to securely zero or destroy the sensitive data after use and the password may remain in memory; possibly to be exposed by an uninitialized memory.</source>
          <target state="translated">URL でのパスワードの使用は避けてください。クレデンシャルオブジェクトとは異なり、Julia は使用後に機密データを安全にゼロにしたり破棄したりすることができず、パスワードはメモリ内に残る可能性があります;もしかしたら、初期化されていないメモリによって公開される可能性があります。</target>
        </trans-unit>
        <trans-unit id="2371521c12f038f3e299464707c70bda3ff3e6b1" translate="yes" xml:space="preserve">
          <source>Avoid writing overly-specific types</source>
          <target state="translated">特化しすぎたタイプを書かないようにする</target>
        </trans-unit>
        <trans-unit id="5073587ca8bbf875c2d3d248119f4effa8701deb" translate="yes" xml:space="preserve">
          <source>Avoiding Deadlock in Pipelines</source>
          <target state="translated">パイプラインのデッドロックの回避</target>
        </trans-unit>
        <trans-unit id="65b99874e3a064ddb84e4d624ff070c43bf412eb" translate="yes" xml:space="preserve">
          <source>Avoiding changing the value of global variables is considered by many to be a programming best-practice. Changing the value of a global variable can cause &quot;action at a distance&quot;, making the behavior of a program harder to reason about. This is why the scope blocks that introduce local scope require the &lt;code&gt;global&lt;/code&gt; keyword to declare the intent to modify a global variable.</source>
          <target state="translated">グローバル変数の値を変更しないことは、プログラミングのベストプラクティスであると多くの人が考えています。グローバル変数の値を変更すると、「離れた場所でのアクション」が発生し、プログラムの動作を推論することが難しくなります。これが、ローカルスコープを導入するスコープブロックがグローバル変数を変更する意図を宣言するために &lt;code&gt;global&lt;/code&gt; キーワードを必要とする理由です。</target>
        </trans-unit>
        <trans-unit id="5b00714b611fee1b5fd3b2b1cfc1708286a4e472" translate="yes" xml:space="preserve">
          <source>Avoiding globals</source>
          <target state="translated">グローバルの回避</target>
        </trans-unit>
        <trans-unit id="4e9ba62b391f99ca62e6bfebe5faa916e7ed0f96" translate="yes" xml:space="preserve">
          <source>Awad H. Al-Mohy and Nicholas J. Higham, &quot;Improved inverse scaling and squaring algorithms for the matrix logarithm&quot;, SIAM Journal on Scientific Computing, 34(4), 2012, C153-C169. &lt;a href=&quot;https://doi.org/10.1137/110852553&quot;&gt;doi:10.1137/110852553&lt;/a&gt;</source>
          <target state="translated">Awad H. Al-MohyおよびNicholas J. Higham、「行列対数の改善された逆スケーリングおよび二乗アルゴリズム」、SIAM Journal on Scientific Computing、34（4）、2012、C153-C169。&lt;a href=&quot;https://doi.org/10.1137/110852553&quot;&gt;doi：10.1137 / 110852553&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="12401b9104fcd17aca879a9457a3f9b5a0090df6" translate="yes" xml:space="preserve">
          <source>Awad H. Al-Mohy, Nicholas J. Higham and Samuel D. Relton, &quot;Computing the Fr&amp;eacute;chet derivative of the matrix logarithm and estimating the condition number&quot;, SIAM Journal on Scientific Computing, 35(4), 2013, C394-C410. &lt;a href=&quot;https://doi.org/10.1137/120885991&quot;&gt;doi:10.1137/120885991&lt;/a&gt;</source>
          <target state="translated">Awad H. Al-Mohy、Nicholas J. HighamおよびSamuel D. Relton、「行列対数のフレシェ微分の計算と条件数の推定」、SIAM Journal on Scientific Computing、35（4）、2013、C394-C410。&lt;a href=&quot;https://doi.org/10.1137/120885991&quot;&gt;doi：10.1137 / 120885991&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6dad1f19392ce0b096b44b01c81c76a664e7337c" translate="yes" xml:space="preserve">
          <source>B&amp;eacute;zout coefficients are &lt;em&gt;not&lt;/em&gt; uniquely defined. &lt;code&gt;gcdx&lt;/code&gt; returns the minimal B&amp;eacute;zout coefficients that are computed by the extended Euclidean algorithm. (Ref: D. Knuth, TAoCP, 2/e, p. 325, Algorithm X.) For signed integers, these coefficients &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; are minimal in the sense that $|u| &amp;lt; |y/d|$ and $|v| &amp;lt; |x/d|$. Furthermore, the signs of &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; are chosen so that &lt;code&gt;d&lt;/code&gt; is positive. For unsigned integers, the coefficients &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; might be near their &lt;code&gt;typemax&lt;/code&gt;, and the identity then holds only via the unsigned integers' modulo arithmetic.</source>
          <target state="translated">ベズー係数は一意に定義されて&lt;em&gt;いません&lt;/em&gt;。 &lt;code&gt;gcdx&lt;/code&gt; は、拡張ユークリッドアルゴリズムによって計算される最小ベズー係数を返します。 （参照：D. Knuth、TAoCP、2 / e、p。325、アルゴリズムX。）符号付き整数の場合、これらの係数 &lt;code&gt;u&lt;/code&gt; と &lt;code&gt;v&lt;/code&gt; は$ | u |の意味で最小です。 &amp;lt;| y / d | $および$ | v | &amp;lt;| x / d | $。さらに、 &lt;code&gt;u&lt;/code&gt; と &lt;code&gt;v&lt;/code&gt; の符号は、 &lt;code&gt;d&lt;/code&gt; が正になるように選択されます。符号なし整数の場合、係数 &lt;code&gt;u&lt;/code&gt; と &lt;code&gt;v&lt;/code&gt; は &lt;code&gt;typemax&lt;/code&gt; に近い可能性があり、その場合、同一性は符号なし整数のモジュロ演算を介してのみ保持されます。</target>
        </trans-unit>
        <trans-unit id="0f4d56d1e20778bf2e1052ecb3219509238fb660" translate="yes" xml:space="preserve">
          <source>BD</source>
          <target state="translated">BD</target>
        </trans-unit>
        <trans-unit id="2868e5c7bf03fbd81359d6f8be00b333b386ffca" translate="yes" xml:space="preserve">
          <source>BLAS Character Arguments</source>
          <target state="translated">BLAS文字引数</target>
        </trans-unit>
        <trans-unit id="e299ffe232555a867fe66272d999c06385ea8b66" translate="yes" xml:space="preserve">
          <source>BLAS Functions</source>
          <target state="translated">BLAS機能</target>
        </trans-unit>
        <trans-unit id="38726bba2d45fa38b747b2e7e3f161c3f4fb4718" translate="yes" xml:space="preserve">
          <source>BLAS character arguments</source>
          <target state="translated">BLAS文字引数</target>
        </trans-unit>
        <trans-unit id="f10410d90763f9147a245aec96798dc0ea5a38e4" translate="yes" xml:space="preserve">
          <source>BLAS functions</source>
          <target state="translated">BLAS機能</target>
        </trans-unit>
        <trans-unit id="13c3d98d3a2445afc653d610809196ddb501f8c1" translate="yes" xml:space="preserve">
          <source>Baby</source>
          <target state="translated">Baby</target>
        </trans-unit>
        <trans-unit id="404344724dd01c5a65fcea59173146b18cd1b603" translate="yes" xml:space="preserve">
          <source>Baby Angel</source>
          <target state="translated">ベビーエンジェル</target>
        </trans-unit>
        <trans-unit id="8b580757a627745bff29a8f25e39330265bdc27b" translate="yes" xml:space="preserve">
          <source>Baby Bottle</source>
          <target state="translated">ベビーボトル</target>
        </trans-unit>
        <trans-unit id="459882191a5a45ebff1c155b876b56cf4eb8ef5e" translate="yes" xml:space="preserve">
          <source>Baby Chick</source>
          <target state="translated">ベビーチック</target>
        </trans-unit>
        <trans-unit id="1871c181df7f050df811e7ae71f7e0946094c40f" translate="yes" xml:space="preserve">
          <source>Baby Symbol</source>
          <target state="translated">ベビーシンボル</target>
        </trans-unit>
        <trans-unit id="2867999045ac5ccc323dde4dccea9a973b94383f" translate="yes" xml:space="preserve">
          <source>Back With Leftwards Arrow Above</source>
          <target state="translated">左向き矢印の上に戻る</target>
        </trans-unit>
        <trans-unit id="cc1f0103d6d9cbde7e99045cc49ad45fc083e009" translate="yes" xml:space="preserve">
          <source>Background and References</source>
          <target state="translated">背景と参考文献</target>
        </trans-unit>
        <trans-unit id="fc10601fec1e951e91f278b7b703a3337af22c80" translate="yes" xml:space="preserve">
          <source>Backslashes (&lt;code&gt;\&lt;/code&gt;) are escaped with a double-backslash (&lt;code&gt;&quot;\\&quot;&lt;/code&gt;). Non-printable characters are escaped either with their standard C escape codes, &lt;code&gt;&quot;\0&quot;&lt;/code&gt; for NUL (if unambiguous), unicode code point (&lt;code&gt;&quot;\u&quot;&lt;/code&gt; prefix) or hex (&lt;code&gt;&quot;\x&quot;&lt;/code&gt; prefix).</source>
          <target state="translated">バックスラッシュ（ &lt;code&gt;\&lt;/code&gt; ）は、2つのバックスラッシュ（ &lt;code&gt;&quot;\\&quot;&lt;/code&gt; ）でエスケープされます。印刷不可能な文字は、標準のCエスケープコード、NULの &lt;code&gt;&quot;\0&quot;&lt;/code&gt; （あいまいでない場合）、Unicodeコードポイント（ &lt;code&gt;&quot;\u&quot;&lt;/code&gt; プレフィックス）、または16進数（ &lt;code&gt;&quot;\x&quot;&lt;/code&gt; プレフィックス）のいずれかでエスケープされます。</target>
        </trans-unit>
        <trans-unit id="6d4e3b07bbe1ccb3ac5b9922a337b1d4f919bc4f" translate="yes" xml:space="preserve">
          <source>Backspace, &lt;code&gt;^H&lt;/code&gt;</source>
          <target state="translated">バックスペース、 &lt;code&gt;^H&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b6d84b04bcccd220267af9a3b46464c46ba45d26" translate="yes" xml:space="preserve">
          <source>Bactrian Camel</source>
          <target state="translated">バクトリアンキャメル</target>
        </trans-unit>
        <trans-unit id="447082b449cc1df13e5c0addef786ca50488ff0e" translate="yes" xml:space="preserve">
          <source>Baggage Claim</source>
          <target state="translated">バゲージクレーム</target>
        </trans-unit>
        <trans-unit id="ebd009a68817c4cc14d70f9ca5aa28ad5c4de62a" translate="yes" xml:space="preserve">
          <source>Balance the matrix &lt;code&gt;A&lt;/code&gt; before computing its eigensystem or Schur factorization. &lt;code&gt;job&lt;/code&gt; can be one of &lt;code&gt;N&lt;/code&gt; (&lt;code&gt;A&lt;/code&gt; will not be permuted or scaled), &lt;code&gt;P&lt;/code&gt; (&lt;code&gt;A&lt;/code&gt; will only be permuted), &lt;code&gt;S&lt;/code&gt; (&lt;code&gt;A&lt;/code&gt; will only be scaled), or &lt;code&gt;B&lt;/code&gt; (&lt;code&gt;A&lt;/code&gt; will be both permuted and scaled). Modifies &lt;code&gt;A&lt;/code&gt; in-place and returns &lt;code&gt;ilo&lt;/code&gt;, &lt;code&gt;ihi&lt;/code&gt;, and &lt;code&gt;scale&lt;/code&gt;. If permuting was turned on, &lt;code&gt;A[i,j] = 0&lt;/code&gt; if &lt;code&gt;j &amp;gt; i&lt;/code&gt; and &lt;code&gt;1 &amp;lt; j &amp;lt; ilo&lt;/code&gt; or &lt;code&gt;j &amp;gt; ihi&lt;/code&gt;. &lt;code&gt;scale&lt;/code&gt; contains information about the scaling/permutations performed.</source>
          <target state="translated">固有システムまたはSchur分解を計算 &lt;code&gt;A&lt;/code&gt; 前に、行列Aのバランスをとります。 &lt;code&gt;job&lt;/code&gt; は、 &lt;code&gt;N&lt;/code&gt; （ &lt;code&gt;A&lt;/code&gt; は置換またはスケーリングされない）、 &lt;code&gt;P&lt;/code&gt; （ &lt;code&gt;A&lt;/code&gt; は置換のみされる）、 &lt;code&gt;S&lt;/code&gt; （ &lt;code&gt;A&lt;/code&gt; はスケーリングのみされる）、または &lt;code&gt;B&lt;/code&gt; （ &lt;code&gt;A&lt;/code&gt; は置換およびスケーリングされる）のいずれかになります。修正 &lt;code&gt;A&lt;/code&gt; は、インプレースおよびリターンは &lt;code&gt;ilo&lt;/code&gt; 、 &lt;code&gt;ihi&lt;/code&gt; 、および &lt;code&gt;scale&lt;/code&gt; 。置換がオンになっている場合、 &lt;code&gt;j &amp;gt; i&lt;/code&gt; および &lt;code&gt;1 &amp;lt; j &amp;lt; ilo&lt;/code&gt; または &lt;code&gt;j &amp;gt; ihi&lt;/code&gt; 場合、 &lt;code&gt;A[i,j] = 0&lt;/code&gt; です。 &lt;code&gt;scale&lt;/code&gt; には、実行されたスケーリング/置換に関する情報が含まれます。</target>
        </trans-unit>
        <trans-unit id="64f241f5415d400e3d7d028f504e941ebbdb9386" translate="yes" xml:space="preserve">
          <source>Balloon</source>
          <target state="translated">Balloon</target>
        </trans-unit>
        <trans-unit id="a5ae768a2f5127a27b546388e40cac06994c9b36" translate="yes" xml:space="preserve">
          <source>Ballot Box With Check</source>
          <target state="translated">チェック付き投票箱</target>
        </trans-unit>
        <trans-unit id="fc6fae10db2bd0b625077d7c6d1b9a96925fd2b7" translate="yes" xml:space="preserve">
          <source>Banana</source>
          <target state="translated">Banana</target>
        </trans-unit>
        <trans-unit id="9e89988cc3fba2850fb19459e04e7b3325be4f84" translate="yes" xml:space="preserve">
          <source>Bank</source>
          <target state="translated">Bank</target>
        </trans-unit>
        <trans-unit id="ef4f81080d95142c3db9938d48a26e8efe95cd36" translate="yes" xml:space="preserve">
          <source>Banknote With Dollar Sign</source>
          <target state="translated">ドルのサインが付いた紙幣</target>
        </trans-unit>
        <trans-unit id="3177af01daaed29235d1e99ba9255338076b9f27" translate="yes" xml:space="preserve">
          <source>Banknote With Euro Sign</source>
          <target state="translated">ユーロのサインが付いた紙幣</target>
        </trans-unit>
        <trans-unit id="3a6546fb8ecf3af86528410e140549606f1d3249" translate="yes" xml:space="preserve">
          <source>Banknote With Pound Sign</source>
          <target state="translated">ポンドサイン入り紙幣</target>
        </trans-unit>
        <trans-unit id="63a28a516e785c09b112a71c85ad02804c64137a" translate="yes" xml:space="preserve">
          <source>Banknote With Yen Sign</source>
          <target state="translated">円記号入り紙幣</target>
        </trans-unit>
        <trans-unit id="75fe8df5591aba61913518914c1f05bdb42306e6" translate="yes" xml:space="preserve">
          <source>Bar Chart</source>
          <target state="translated">棒グラフ</target>
        </trans-unit>
        <trans-unit id="bddd12f808af35a2e999d9124c970232527e7e1d" translate="yes" xml:space="preserve">
          <source>Barber Pole</source>
          <target state="translated">バーバーポール</target>
        </trans-unit>
        <trans-unit id="077fe9c54ed5ed26fa547f4ded3ef9a9bb066d65" translate="yes" xml:space="preserve">
          <source>Base</source>
          <target state="translated">Base</target>
        </trans-unit>
        <trans-unit id="2aa4376a2de743967992b5357971a1c7721c03e3" translate="yes" xml:space="preserve">
          <source>Base Submodules</source>
          <target state="translated">ベースサブモジュール</target>
        </trans-unit>
        <trans-unit id="13b575497d7efff2ec5b49faf71dbac3532ee190" translate="yes" xml:space="preserve">
          <source>Base collection types require manual locking if used simultaneously by multiple threads where at least one thread modifies the collection (common examples include &lt;code&gt;push!&lt;/code&gt; on arrays, or inserting items into a &lt;code&gt;Dict&lt;/code&gt;).</source>
          <target state="translated">基本コレクションタイプは、少なくとも1つのスレッドがコレクションを変更する複数のスレッドで同時に使用される場合は手動ロックが必要です（一般的な例には、配列の &lt;code&gt;push!&lt;/code&gt; 、または &lt;code&gt;Dict&lt;/code&gt; へのアイテムの挿入が含まれます）。</target>
        </trans-unit>
        <trans-unit id="895c330ff6166a7f13701f8d9b78f313787269c8" translate="yes" xml:space="preserve">
          <source>Base64</source>
          <target state="translated">Base64</target>
        </trans-unit>
        <trans-unit id="ec2d7744c603baf507e66bf82835dfb6204656a8" translate="yes" xml:space="preserve">
          <source>Baseball</source>
          <target state="translated">Baseball</target>
        </trans-unit>
        <trans-unit id="bf046bc3c151c25669b6483d54157a9641394a6d" translate="yes" xml:space="preserve">
          <source>Based on this observation, we can conclude that if one of the operands is &lt;code&gt;true&lt;/code&gt; and the other &lt;code&gt;missing&lt;/code&gt;, we know that the result is &lt;code&gt;true&lt;/code&gt; in spite of the uncertainty about the actual value of one of the operands. If we had been able to observe the actual value of the second operand, it could only be &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;, and in both cases the result would be &lt;code&gt;true&lt;/code&gt;. Therefore, in this particular case, missingness does &lt;em&gt;not&lt;/em&gt; propagate</source>
          <target state="translated">この観察に基づいて、一方のオペランドが &lt;code&gt;true&lt;/code&gt; で他方が &lt;code&gt;missing&lt;/code&gt; している場合、一方のオペランドの実際の値に関する不確実性にもかかわらず、結果が &lt;code&gt;true&lt;/code&gt; であることがわかります。2番目のオペランドの実際の値を観察できた場合、それは &lt;code&gt;true&lt;/code&gt; または &lt;code&gt;false&lt;/code&gt; のいずれかであり、どちらの場合も結果は &lt;code&gt;true&lt;/code&gt; になります。したがって、この特定のケースでは、欠落は伝播しませ&lt;em&gt;ん&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="791f5b6a2aaabca7a2c4cad24b70f6e46c76fdcc" translate="yes" xml:space="preserve">
          <source>Basic &lt;code&gt;Task&lt;/code&gt; operations</source>
          <target state="translated">基本的な &lt;code&gt;Task&lt;/code&gt; 操作</target>
        </trans-unit>
        <trans-unit id="c01a71bb934cc266c2f79a70a4a484bfb32292d0" translate="yes" xml:space="preserve">
          <source>Basic Functions</source>
          <target state="translated">基本機能</target>
        </trans-unit>
        <trans-unit id="aeb63e6ce576503861f1c499cfdf84cff87567db" translate="yes" xml:space="preserve">
          <source>Basic Stream I/O</source>
          <target state="translated">基本ストリームI/O</target>
        </trans-unit>
        <trans-unit id="f9e89ba8027afc2d4c24183a1cbbfbb04137326a" translate="yes" xml:space="preserve">
          <source>Basic Unit Tests</source>
          <target state="translated">基本的なユニットテスト</target>
        </trans-unit>
        <trans-unit id="58c96a6812d6bac9777029dd40fb7e6afd5c8c94" translate="yes" xml:space="preserve">
          <source>Basic functions</source>
          <target state="translated">基本機能</target>
        </trans-unit>
        <trans-unit id="24be2e19e7e4671eaee4ac0a6f5a6a524bab3529" translate="yes" xml:space="preserve">
          <source>Basic tables can be written using the syntax described below. Note that markdown tables have limited features and cannot contain nested toplevel elements unlike other elements discussed above &amp;ndash; only inline elements are allowed. Tables must always contain a header row with column names. Cells cannot span multiple rows or columns of the table.</source>
          <target state="translated">基本的なテーブルは、以下で説明する構文を使用して記述できます。マークダウンテーブルの機能は制限されており、上記の他の要素とは異なり、ネストされたトップレベル要素を含めることはできません。インライン要素のみが許可されます。テーブルには、常に列名を含むヘッダー行が含まれている必要があります。セルは、テーブルの複数の行または列にまたがることはできません。</target>
        </trans-unit>
        <trans-unit id="cb3a8802da5b3164771a468d78ff7995a249f08a" translate="yes" xml:space="preserve">
          <source>Basic usage</source>
          <target state="translated">基本的な使い方</target>
        </trans-unit>
        <trans-unit id="5fcebeefad3cdbbf8733aa928160dec7dc90c1a1" translate="yes" xml:space="preserve">
          <source>Basics</source>
          <target state="translated">Basics</target>
        </trans-unit>
        <trans-unit id="25cdb3adf0a06c600dd49fc47c73f5654e3fddf0" translate="yes" xml:space="preserve">
          <source>Basketball And Hoop</source>
          <target state="translated">バスケットボールとフープ</target>
        </trans-unit>
        <trans-unit id="a687b3ff7f182c39a1247454d3d7927ea0efa80d" translate="yes" xml:space="preserve">
          <source>Bath</source>
          <target state="translated">Bath</target>
        </trans-unit>
        <trans-unit id="24f0469ed67f7f88a5ef12c0cd27feac4f206fb4" translate="yes" xml:space="preserve">
          <source>Bathtub</source>
          <target state="translated">Bathtub</target>
        </trans-unit>
        <trans-unit id="4a9be042afe6257111a01c05b72af9f1f3015176" translate="yes" xml:space="preserve">
          <source>Battery</source>
          <target state="translated">Battery</target>
        </trans-unit>
        <trans-unit id="5efe26975abbced9003edb837133f3af03f436e7" translate="yes" xml:space="preserve">
          <source>Be aware of when Julia avoids specializing</source>
          <target state="translated">ジュリアが特化を避けるときに注意</target>
        </trans-unit>
        <trans-unit id="d363e26ebe520321aa01d471833fdb370bebd1b2" translate="yes" xml:space="preserve">
          <source>Be aware of when a macro could really be a function instead.</source>
          <target state="translated">マクロが本当に関数である可能性がある場合に注意してください。</target>
        </trans-unit>
        <trans-unit id="f0826b18a2138cb79c2b1a66c614cdb664f937ef" translate="yes" xml:space="preserve">
          <source>Be aware that finalizers registered by a library may break if threads are enabled. This may require some transitional work across the ecosystem before threading can be widely adopted with confidence. See the next section for further details.</source>
          <target state="translated">ライブラリに登録されているファイナライザがスレッドを有効にすると壊れてしまう可能性があることに注意してください。スレッド化が自信を持って広く採用されるようになるまでには、エコシステム全体での移行作業が必要になるかもしれません。詳細は次のセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="24c70535563b2fda1a64503b874c826edb8884cf" translate="yes" xml:space="preserve">
          <source>Be aware that this strategy has at least one major disadvantage: in many cases, it is not possible for users to further customize the behavior of &lt;code&gt;f&lt;/code&gt; by defining further specializations of your exported function &lt;code&gt;f&lt;/code&gt;. Instead, they have to define specializations for your internal methods &lt;code&gt;_fA&lt;/code&gt; and &lt;code&gt;_fB&lt;/code&gt;, and this blurs the lines between exported and internal methods.</source>
          <target state="translated">この戦略には少なくとも1つの大きな欠点があることに注意してください。多くの場合、エクスポートされた関数 &lt;code&gt;f&lt;/code&gt; の特殊化をさらに定義することによって、ユーザーが &lt;code&gt;f&lt;/code&gt; の動作をさらにカスタマイズすることは不可能です。代わりに、内部メソッド &lt;code&gt;_fA&lt;/code&gt; および &lt;code&gt;_fB&lt;/code&gt; の特殊化を定義する必要があります。これにより、エクスポートされたメソッドと内部メソッドの間の線がぼやけます。</target>
        </trans-unit>
        <trans-unit id="9beb1443ec7c795007b178f28f0ce7235335f46d" translate="yes" xml:space="preserve">
          <source>Be careful to ensure that a Julia reference to &lt;code&gt;x&lt;/code&gt; exists as long as the result of this function will be used. Accordingly, the argument &lt;code&gt;x&lt;/code&gt; to this function should never be an expression, only a variable name or field reference. For example, &lt;code&gt;x=a.b.c&lt;/code&gt; is acceptable, but &lt;code&gt;x=[a,b,c]&lt;/code&gt; is not.</source>
          <target state="translated">この関数の結果が使用される限り、 &lt;code&gt;x&lt;/code&gt; へのJulia参照が存在するように注意してください。したがって、この関数の引数 &lt;code&gt;x&lt;/code&gt; は式ではなく、変数名またはフィールド参照のみにする必要があります。たとえば、 &lt;code&gt;x=a.b.c&lt;/code&gt; は受け入れられますが、 &lt;code&gt;x=[a,b,c]&lt;/code&gt; は受け入れられません。</target>
        </trans-unit>
        <trans-unit id="fe66257c8592b5cf4fc84f98162f41a3e02473c6" translate="yes" xml:space="preserve">
          <source>Be careful when using &lt;code&gt;invoke&lt;/code&gt; for functions that you don't write. What definition is used for given &lt;code&gt;argtypes&lt;/code&gt; is an implementation detail unless the function is explicitly states that calling with certain &lt;code&gt;argtypes&lt;/code&gt; is a part of public API. For example, the change between &lt;code&gt;f1&lt;/code&gt; and &lt;code&gt;f2&lt;/code&gt; in the example below is usually considered compatible because the change is invisible by the caller with a normal (non-&lt;code&gt;invoke&lt;/code&gt;) call. However, the change is visible if you use &lt;code&gt;invoke&lt;/code&gt;.</source>
          <target state="translated">作成しない関数に &lt;code&gt;invoke&lt;/code&gt; を使用する場合は注意してください。特定の &lt;code&gt;argtypes&lt;/code&gt; での呼び出しがパブリックAPIの一部であると関数が明示的に述べていない限り、特定の &lt;code&gt;argtypes&lt;/code&gt; 使用される定義は実装の詳細です。たとえば、以下の例の &lt;code&gt;f1&lt;/code&gt; と &lt;code&gt;f2&lt;/code&gt; の間の変更は、通常の（非 &lt;code&gt;invoke&lt;/code&gt; ）呼び出しでは呼び出し元に表示されないため、通常は互換性があると見なされます。ただし、 &lt;code&gt;invoke&lt;/code&gt; を使用すると、変更が表示されます。</target>
        </trans-unit>
        <trans-unit id="590d4269627728c65164df59752ab3f2172388df" translate="yes" xml:space="preserve">
          <source>Be careful with non-constant global variables in Julia, especially in tight loops. Since you can write close-to-metal code in Julia (unlike Python), the effect of globals can be drastic (see &lt;a href=&quot;../performance-tips/index#man-performance-tips&quot;&gt;Performance Tips&lt;/a&gt;).</source>
          <target state="translated">特にタイトなループでは、Juliaの非定数グローバル変数に注意してください。（Pythonとは異なり）Juliaで金属に近いコードを記述できるため、グローバルの効果は劇的になる可能性があります（&lt;a href=&quot;../performance-tips/index#man-performance-tips&quot;&gt;パフォーマンスのヒントを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="5cb87858674ab3ef5b1beab58a7148fcb802f60e" translate="yes" xml:space="preserve">
          <source>Be careful with type equality</source>
          <target state="translated">タイプの平等性に注意</target>
        </trans-unit>
        <trans-unit id="8bfb6bdbe4ae64df10562422552d5b22da6f47fc" translate="yes" xml:space="preserve">
          <source>Beamed Eighth Notes / Barred Eighth Notes</source>
          <target state="translated">ビーム付き8分音符/バーレッド付き8分音符</target>
        </trans-unit>
        <trans-unit id="c8d8cb92fc4cef48d0b0c66441f7a0ef79489b94" translate="yes" xml:space="preserve">
          <source>Bear Face</source>
          <target state="translated">ベアフェイス</target>
        </trans-unit>
        <trans-unit id="aa8c1d8ab7be7fc9804d2a597a6630cb0b4cde3e" translate="yes" xml:space="preserve">
          <source>Beating Heart</source>
          <target state="translated">鼓動する心臓</target>
        </trans-unit>
        <trans-unit id="eaebe47425c9f545a41d705608612a34bef824ca" translate="yes" xml:space="preserve">
          <source>Because</source>
          <target state="translated">Because</target>
        </trans-unit>
        <trans-unit id="3b0620b59c6d57d025b388d048ef8892a00c82a2" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;a&lt;/code&gt; is a an array of abstract type &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt;, it must be able to hold any &lt;code&gt;Real&lt;/code&gt; value. Since &lt;code&gt;Real&lt;/code&gt; objects can be of arbitrary size and structure, &lt;code&gt;a&lt;/code&gt; must be represented as an array of pointers to individually allocated &lt;code&gt;Real&lt;/code&gt; objects. However, if we instead only allow numbers of the same type, e.g. &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;, to be stored in &lt;code&gt;a&lt;/code&gt; these can be stored more efficiently:</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; は&lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt;の抽象型の配列であるため、任意の &lt;code&gt;Real&lt;/code&gt; 値を保持できる必要があります。 &lt;code&gt;Real&lt;/code&gt; オブジェクトは任意のサイズと構造を &lt;code&gt;a&lt;/code&gt; ことができるため、aは個別に割り当てられた &lt;code&gt;Real&lt;/code&gt; オブジェクトへのポインタの配列として表す必要があります。ただし、代わりに&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;などの同じタイプの数値のみをに格納できるように &lt;code&gt;a&lt;/code&gt; これらをより効率的に格納できます。</target>
        </trans-unit>
        <trans-unit id="9408c8b817a5e76474fc2023c5d1c8f64eadcc39" translate="yes" xml:space="preserve">
          <source>Because C doesn't support multiple return values, often C functions will take pointers to data that the function will modify. To accomplish this within a &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt;, you need to first encapsulate the value inside a &lt;a href=&quot;../../base/c/index#Core.Ref&quot;&gt;&lt;code&gt;Ref{T}&lt;/code&gt;&lt;/a&gt; of the appropriate type. When you pass this &lt;code&gt;Ref&lt;/code&gt; object as an argument, Julia will automatically pass a C pointer to the encapsulated data:</source>
          <target state="translated">Cは複数の戻り値をサポートしていないため、C関数は多くの場合、関数が変更するデータへのポインターを受け取ります。これを&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt;内で実現するには、まず適切なタイプの&lt;a href=&quot;../../base/c/index#Core.Ref&quot;&gt; &lt;code&gt;Ref{T}&lt;/code&gt; &lt;/a&gt;内に値をカプセル化する必要があります。この &lt;code&gt;Ref&lt;/code&gt; オブジェクトを引数として渡すと、Juliaはカプセル化されたデータにCポインターを自動的に渡します。</target>
        </trans-unit>
        <trans-unit id="d44d25a0390ec817de43e662485f00ec7ef00a32" translate="yes" xml:space="preserve">
          <source>Because Julia's compiler is different from the interpreters used for languages like Python or R, you may find that Julia's performance is unintuitive at first. If you find that something is slow, we highly recommend reading through the &lt;a href=&quot;manual/performance-tips/index#man-performance-tips&quot;&gt;Performance Tips&lt;/a&gt; section before trying anything else. Once you understand how Julia works, it's easy to write code that's nearly as fast as C.</source>
          <target state="translated">Juliaのコンパイラは、PythonやRなどの言語で使用されるインタプリタとは異なるため、Juliaのパフォーマンスは最初は直感的ではないことに気付くかもしれません。何かが遅いことに気付いた場合は、他のことを試す前に、&lt;a href=&quot;manual/performance-tips/index#man-performance-tips&quot;&gt;パフォーマンスのヒントの&lt;/a&gt;セクションを読むことを強くお勧めします。Juliaがどのように機能するかを理解すれば、Cとほぼ同じ速さのコードを簡単に記述できます。</target>
        </trans-unit>
        <trans-unit id="46c2c088cdd51f72db20e5f94b9c484cd07ee1a5" translate="yes" xml:space="preserve">
          <source>Because Julia's compiler is different from the interpreters used for languages like Python or R, you may find that Julia's performance is unintuitive at first. If you find that something is slow, we highly recommend reading through the &lt;a href=&quot;manual/performance-tips/index#man-performance-tips-1&quot;&gt;Performance Tips&lt;/a&gt; section before trying anything else. Once you understand how Julia works, it's easy to write code that's nearly as fast as C.</source>
          <target state="translated">Juliaのコンパイラーは、PythonやRなどの言語で使用されるインタープリターとは異なるため、最初はJuliaのパフォーマンスが直感的でない場合があります。何かが遅いと感じた場合は、何かを試す前に、&lt;a href=&quot;manual/performance-tips/index#man-performance-tips-1&quot;&gt;パフォーマンスのヒントの&lt;/a&gt;セクションを一読することを強くお勧めします。Juliaのしくみを理解したら、Cとほぼ同じ速さのコードを簡単に作成できます。</target>
        </trans-unit>
        <trans-unit id="7d35da8223bf95881284388f273666759cae71cf" translate="yes" xml:space="preserve">
          <source>Because finalizers can interrupt any code, they must be very careful in how they interact with any global state. Unfortunately, the main reason that finalizers are used is to update global state (a pure function is generally rather pointless as a finalizer). This leads us to a bit of a conundrum. There are a few approaches to dealing with this problem:</source>
          <target state="translated">ファイナライザはどのようなコードにも割り込むことができるので、どのようにグローバルな状態と相互作用するかについては非常に注意しなければなりません。残念ながら、ファイナライザが使われる主な理由はグローバル状態を更新するためです(純粋な関数は一般的にファイナライザとしては無意味です)。これはちょっとした難問です。この問題に対処するためのアプローチはいくつかあります。</target>
        </trans-unit>
        <trans-unit id="d57b0f43957e0dd94a3628a775697cb33089c39f" translate="yes" xml:space="preserve">
          <source>Because of these shared properties, these types are internally represented as instances of the same concept, &lt;code&gt;DataType&lt;/code&gt;, which is the type of any of these types:</source>
          <target state="translated">これらの共有プロパティのため、これらの型は内部的に同じ概念 &lt;code&gt;DataType&lt;/code&gt; のインスタンスとして表されます。これは、これらの型のいずれかの型です。</target>
        </trans-unit>
        <trans-unit id="42b7af0f4b58f310d2c30a12b918265991dec35c" translate="yes" xml:space="preserve">
          <source>Because of variable-length encodings, the number of characters in a string (given by &lt;code&gt;length(s)&lt;/code&gt;) is not always the same as the last index. If you iterate through the indices 1 through &lt;a href=&quot;../../base/collections/index#Base.lastindex&quot;&gt;&lt;code&gt;lastindex(s)&lt;/code&gt;&lt;/a&gt; and index into &lt;code&gt;s&lt;/code&gt;, the sequence of characters returned when errors aren't thrown is the sequence of characters comprising the string &lt;code&gt;s&lt;/code&gt;. Thus we have the identity that &lt;code&gt;length(s) &amp;lt;= lastindex(s)&lt;/code&gt;, since each character in a string must have its own index. The following is an inefficient and verbose way to iterate through the characters of &lt;code&gt;s&lt;/code&gt;:</source>
          <target state="translated">可変長エンコーディングのため、文字列の &lt;code&gt;length(s)&lt;/code&gt; によって与えられる）は、最後のインデックスと常に同じであるとは限りません。インデックス1から&lt;a href=&quot;../../base/collections/index#Base.lastindex&quot;&gt; &lt;code&gt;lastindex(s)&lt;/code&gt; &lt;/a&gt;まで繰り返し、インデックスを &lt;code&gt;s&lt;/code&gt; に入れる場合、エラーがスローされないときに返される文字 &lt;code&gt;s&lt;/code&gt; シーケンスは、文字列sを構成する文字のシーケンスです。したがって、文字列内の各文字は独自のインデックスを持つ必要があるため、 &lt;code&gt;length(s) &amp;lt;= lastindex(s)&lt;/code&gt; であるというアイデンティティがあります。以下は、 &lt;code&gt;s&lt;/code&gt; の文字を反復する非効率的で冗長な方法です。</target>
        </trans-unit>
        <trans-unit id="757a38ed122bb8b64391606ad821806f34182e36" translate="yes" xml:space="preserve">
          <source>Because supporting generic programming is deemed more important than potential performance optimizations that can be achieved by other means (e.g., using explicit loops), operators like &lt;code&gt;+=&lt;/code&gt; and &lt;code&gt;*=&lt;/code&gt; work by rebinding new values.</source>
          <target state="translated">一般的なプログラミングのサポートは、他の手段（明示的なループの使用など）によって達成できる潜在的なパフォーマンス最適化よりも重要であると考えられているため、 &lt;code&gt;+=&lt;/code&gt; や &lt;code&gt;*=&lt;/code&gt; などの演算子は新しい値を再バインドすることで機能します。</target>
        </trans-unit>
        <trans-unit id="b50e23d2e501ab3f771dc2f5a71cc510c1b86367" translate="yes" xml:space="preserve">
          <source>Because the &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; types are stored as single &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt; values, date parts or fields can be retrieved through accessor functions. The lowercase accessors return the field as an integer:</source>
          <target state="translated">&lt;a href=&quot;#Dates.Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;型は単一の&lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt;値として格納されるため、日付の部分またはフィールドは、アクセサー関数を介して取得できます。小文字のアクセサーはフィールドを整数として返します。</target>
        </trans-unit>
        <trans-unit id="bc4c89911afb2810477bab2fec0bf376b9a4f915" translate="yes" xml:space="preserve">
          <source>Because the compiler knows that integer addition and multiplication are associative and that multiplication distributes over addition &amp;ndash; neither of which is true of saturating arithmetic &amp;ndash; it can optimize the entire loop down to just a multiply and an add. Saturated arithmetic completely defeats this kind of optimization since associativity and distributivity can fail at each loop iteration, causing different outcomes depending on which iteration the failure occurs in. The compiler can unroll the loop, but it cannot algebraically reduce multiple operations into fewer equivalent operations.</source>
          <target state="translated">コンパイラーは、整数の加算と乗算が結合的であり、乗算が加算に分配されることを知っているため（飽和演算には当てはまりません）、ループ全体を乗算と加算に最適化できます。連想性と分散性はループの反復ごとに失敗し、失敗が発生した反復に応じて異なる結果を引き起こす可能性があるため、飽和演算はこの種の最適化を完全に無効にします。コンパイラはループを展開できますが、代数的に複数の操作を同等の操作に減らすことはできません。</target>
        </trans-unit>
        <trans-unit id="b0fb1c1b010730bc0463b629ac89a10341b04531" translate="yes" xml:space="preserve">
          <source>Because the operator &lt;code&gt;^&lt;/code&gt; has higher precedence than &lt;code&gt;*&lt;/code&gt; (see &lt;a href=&quot;../mathematical-operations/index#Operator-Precedence-and-Associativity&quot;&gt;Operator Precedence and Associativity&lt;/a&gt;), this output does not faithfully represent the expression &lt;code&gt;a ^ 2&lt;/code&gt; which should be equal to &lt;code&gt;(3.0 * exp(4.0im)) ^ 2&lt;/code&gt;. To solve this issue, we must make a custom method for &lt;code&gt;Base.show_unquoted(io::IO, z::Polar, indent::Int, precedence::Int)&lt;/code&gt;, which is called internally by the expression object when printing:</source>
          <target state="translated">演算子 &lt;code&gt;^&lt;/code&gt; は &lt;code&gt;*&lt;/code&gt; よりも優先順位が高いため（&lt;a href=&quot;../mathematical-operations/index#Operator-Precedence-and-Associativity&quot;&gt;演算子の優先順位と&lt;/a&gt;結合性を参照）、この出力は、 &lt;code&gt;(3.0 * exp(4.0im)) ^ 2&lt;/code&gt; 等しいはずの式 &lt;code&gt;a ^ 2&lt;/code&gt; を忠実に表していない。この問題を解決するには、 &lt;code&gt;Base.show_unquoted(io::IO, z::Polar, indent::Int, precedence::Int)&lt;/code&gt; カスタムメソッドを作成する必要があります。これは、印刷時に式オブジェクトによって内部的に呼び出されます。</target>
        </trans-unit>
        <trans-unit id="b3a8e98adc86bd54f822093e18075fecd0592176" translate="yes" xml:space="preserve">
          <source>Because the operator &lt;code&gt;^&lt;/code&gt; has higher precedence than &lt;code&gt;*&lt;/code&gt; (see &lt;a href=&quot;../mathematical-operations/index#Operator-Precedence-and-Associativity-1&quot;&gt;Operator Precedence and Associativity&lt;/a&gt;), this output does not faithfully represent the expression &lt;code&gt;a ^ 2&lt;/code&gt; which should be equal to &lt;code&gt;(3.0 * exp(4.0im)) ^ 2&lt;/code&gt;. To solve this issue, we must make a custom method for &lt;code&gt;Base.show_unquoted(io::IO, z::Polar, indent::Int, precedence::Int)&lt;/code&gt;, which is called internally by the expression object when printing:</source>
          <target state="translated">演算子 &lt;code&gt;^&lt;/code&gt; は &lt;code&gt;*&lt;/code&gt; よりも優先順位が高いので（「&lt;a href=&quot;../mathematical-operations/index#Operator-Precedence-and-Associativity-1&quot;&gt;演算子の優先順位と&lt;/a&gt;結合性」を参照）、この出力は &lt;code&gt;(3.0 * exp(4.0im)) ^ 2&lt;/code&gt; 等しいはずの式 &lt;code&gt;a ^ 2&lt;/code&gt; を忠実に表していません。この問題を解決するには、 &lt;code&gt;Base.show_unquoted(io::IO, z::Polar, indent::Int, precedence::Int)&lt;/code&gt; カスタムメソッドを作成する必要があります。これは、印刷時に式オブジェクトによって内部的に呼び出されます。</target>
        </trans-unit>
        <trans-unit id="f808dfd9f99fca14db2870360d26f322b8ed85e2" translate="yes" xml:space="preserve">
          <source>Because the precise way in which random numbers are generated is considered an implementation detail, bug fixes and speed improvements may change the stream of numbers that are generated after a version change. Relying on a specific seed or generated stream of numbers during unit testing is thus discouraged - consider testing properties of the methods in question instead.</source>
          <target state="translated">乱数が生成される正確な方法は実装の詳細と考えられているため、バグ修正や速度の改善により、バージョン変更後に生成される数値のストリームが変更される可能性があります。そのため、ユニットテスト中に特定のシードや生成された数字のストリームに頼るのはお勧めできません-代わりに、問題のメソッドの特性をテストすることを検討してください。</target>
        </trans-unit>
        <trans-unit id="ae99b1d876ba3cfdc461cae08478806ff8d8ca63" translate="yes" xml:space="preserve">
          <source>Beer Mug</source>
          <target state="translated">ビールジョッキ</target>
        </trans-unit>
        <trans-unit id="5672f13a1da17dc7ad6970da457803cdfb5de94c" translate="yes" xml:space="preserve">
          <source>Before Julia 1.2 this signature was restricted to &lt;code&gt;f::Function&lt;/code&gt;.</source>
          <target state="translated">Julia 1.2以前は、このシグネチャは &lt;code&gt;f::Function&lt;/code&gt; に制限されていました。</target>
        </trans-unit>
        <trans-unit id="ebd25c6fc66535562035f061458e887115328bc8" translate="yes" xml:space="preserve">
          <source>Before running Julia set the environment variable &lt;code&gt;ENABLE_JITPROFILING&lt;/code&gt; to 1.</source>
          <target state="translated">Juliaを実行する前に、環境変数 &lt;code&gt;ENABLE_JITPROFILING&lt;/code&gt; を1に設定します。</target>
        </trans-unit>
        <trans-unit id="0dc928d36409cbb3c824f1591ba22fe5ec9e9dd8" translate="yes" xml:space="preserve">
          <source>Before the execution of the body of a &lt;code&gt;@testset&lt;/code&gt;, there is an implicit call to &lt;code&gt;Random.seed!(seed)&lt;/code&gt; where &lt;code&gt;seed&lt;/code&gt; is the current seed of the global RNG. Moreover, after the execution of the body, the state of the global RNG is restored to what it was before the &lt;code&gt;@testset&lt;/code&gt;. This is meant to ease reproducibility in case of failure, and to allow seamless re-arrangements of &lt;code&gt;@testset&lt;/code&gt;s regardless of their side-effect on the global RNG state.</source>
          <target state="translated">本体の実行前に &lt;code&gt;@testset&lt;/code&gt; 、への暗黙の呼び出しがあり &lt;code&gt;Random.seed!(seed)&lt;/code&gt; &lt;code&gt;seed&lt;/code&gt; グローバルRNGの現在の種子です。さらに、本体の実行後、グローバルRNGの状態は &lt;code&gt;@testset&lt;/code&gt; の前の状態に復元されます。これは、障害が発生した場合の再現性を容易にし、グローバルRNG状態への副作用に関係なく &lt;code&gt;@testset&lt;/code&gt; のシームレスな再配置を可能にすることを目的としています。</target>
        </trans-unit>
        <trans-unit id="e1451b7dd9bc69e125d61828d9b5cab1b14b61ea" translate="yes" xml:space="preserve">
          <source>Before the program terminates, it is strongly recommended to call &lt;code&gt;jl_atexit_hook&lt;/code&gt;. The above example program calls this before returning from &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">プログラムが終了する前に、 &lt;code&gt;jl_atexit_hook&lt;/code&gt; を呼び出すことを強くお勧めします。上記のサンプルプログラムは、 &lt;code&gt;main&lt;/code&gt; から戻る前にこれを呼び出します。</target>
        </trans-unit>
        <trans-unit id="4b47e5d0ff5715fb37f74adf8fc2abb257a9578b" translate="yes" xml:space="preserve">
          <source>Beginners will write this kind of code without the &lt;code&gt;global&lt;/code&gt; and have no idea why their code doesn't work&amp;mdash;the error that they get is that &lt;code&gt;s&lt;/code&gt; is undefined, which does not seem to enlighten anyone who happens to make this mistake.</source>
          <target state="translated">初心者はせずに、この種のコードを書きます &lt;code&gt;global&lt;/code&gt; 、そのコードは仕事エラー彼らが得ることがということですしない理由は考えていない &lt;code&gt;s&lt;/code&gt; 、このミスをしてしまっ人を啓発していないようだこれは、定義されていないが。</target>
        </trans-unit>
        <trans-unit id="0b5e33825f4e17f1ad04b807863fc5ef1363c528" translate="yes" xml:space="preserve">
          <source>Behaves like a &lt;code&gt;Ptr{T}&lt;/code&gt; that can manage its memory via the Julia GC.</source>
          <target state="translated">Julia GCを介してメモリを管理できる &lt;code&gt;Ptr{T}&lt;/code&gt; ように動作します。</target>
        </trans-unit>
        <trans-unit id="e09863e9196cd18ccb74a5a4e0f5e83a34c2821d" translate="yes" xml:space="preserve">
          <source>Behaves like applying &lt;code&gt;n&lt;/code&gt; times &lt;code&gt;nextind&lt;/code&gt; for &lt;code&gt;n==1&lt;/code&gt;. The only difference is that if &lt;code&gt;n&lt;/code&gt; is so large that applying &lt;code&gt;nextind&lt;/code&gt; would reach &lt;code&gt;ncodeunits(str)+1&lt;/code&gt; then each remaining iteration increases the returned value by &lt;code&gt;1&lt;/code&gt;. This means that in this case &lt;code&gt;nextind&lt;/code&gt; can return a value greater than &lt;code&gt;ncodeunits(str)+1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;n==1&lt;/code&gt; に対して &lt;code&gt;nextind&lt;/code&gt; を &lt;code&gt;n&lt;/code&gt; 回適用するように動作します。唯一の違いは、 &lt;code&gt;n&lt;/code&gt; が非常に大きく、 &lt;code&gt;nextind&lt;/code&gt; を適用すると &lt;code&gt;ncodeunits(str)+1&lt;/code&gt; に達する場合、残りの反復ごとに戻り値が &lt;code&gt;1&lt;/code&gt; ずつ増えることです。つまり、この場合、 &lt;code&gt;nextind&lt;/code&gt; は &lt;code&gt;ncodeunits(str)+1&lt;/code&gt; より大きい値を返す可能性があります。</target>
        </trans-unit>
        <trans-unit id="a2b1b1654cc55316ed5e2b35c84126cef980b48d" translate="yes" xml:space="preserve">
          <source>Behaves like applying &lt;code&gt;n&lt;/code&gt; times &lt;code&gt;prevind&lt;/code&gt; for &lt;code&gt;n==1&lt;/code&gt;. The only difference is that if &lt;code&gt;n&lt;/code&gt; is so large that applying &lt;code&gt;prevind&lt;/code&gt; would reach &lt;code&gt;0&lt;/code&gt; then each remaining iteration decreases the returned value by &lt;code&gt;1&lt;/code&gt;. This means that in this case &lt;code&gt;prevind&lt;/code&gt; can return a negative value.</source>
          <target state="translated">&lt;code&gt;n==1&lt;/code&gt; &lt;code&gt;prevind&lt;/code&gt; に &lt;code&gt;n&lt;/code&gt; 回適用するように動作します。唯一の違いは、 &lt;code&gt;n&lt;/code&gt; が大き &lt;code&gt;prevind&lt;/code&gt; を適用すると &lt;code&gt;0&lt;/code&gt; に到達する場合、残りの反復ごとに戻り値が &lt;code&gt;1&lt;/code&gt; ずつ減ることです。つまり、この場合、 &lt;code&gt;prevind&lt;/code&gt; は負の値を返す可能性があります。</target>
        </trans-unit>
        <trans-unit id="d4198662a72fd519a4f968a74051bafac710dc07" translate="yes" xml:space="preserve">
          <source>Bell</source>
          <target state="translated">Bell</target>
        </trans-unit>
        <trans-unit id="bbab278669c1eda7fe0bdb1650c9fd25169b898f" translate="yes" xml:space="preserve">
          <source>Bell With Cancellation Stroke</source>
          <target state="translated">キャンセルストロークを持つベル</target>
        </trans-unit>
        <trans-unit id="94add7afb4e17fd6f1526d2edfd18924f6fd72ab" translate="yes" xml:space="preserve">
          <source>Below is an example where subnormals noticeably impact performance on some hardware:</source>
          <target state="translated">以下に、一部のハードウェアでサブノーマルが顕著にパフォーマンスに影響する例を示します。</target>
        </trans-unit>
        <trans-unit id="58c2a686d8a6b7d42c702706aa646004223a601b" translate="yes" xml:space="preserve">
          <source>Below we discuss particular challenges and some alternative ways to resolve such issues.</source>
          <target state="translated">以下では、特定の課題と、そのような課題を解決するためのいくつかの代替方法について説明します。</target>
        </trans-unit>
        <trans-unit id="e6be4001a8d2924783c806798a0e30c2803a6922" translate="yes" xml:space="preserve">
          <source>Bento Box</source>
          <target state="translated">弁当箱</target>
        </trans-unit>
        <trans-unit id="3f0f29bd74024b1bd9eec443c00d50257286a7db" translate="yes" xml:space="preserve">
          <source>Benzene Ring</source>
          <target state="translated">ベンゼン環</target>
        </trans-unit>
        <trans-unit id="c667600d6a843f35f26780da4256a01e9f67553a" translate="yes" xml:space="preserve">
          <source>Benzene Ring With Circle</source>
          <target state="translated">円が付いているベンゼン環</target>
        </trans-unit>
        <trans-unit id="79faabb26deabd43b3e790cb4753636cfebf2e58" translate="yes" xml:space="preserve">
          <source>Besides being used for the &lt;a href=&quot;../../base/constants/index#Base.VERSION&quot;&gt;&lt;code&gt;VERSION&lt;/code&gt;&lt;/a&gt; constant, &lt;code&gt;VersionNumber&lt;/code&gt; objects are widely used in the &lt;code&gt;Pkg&lt;/code&gt; module, to specify packages versions and their dependencies.</source>
          <target state="translated">&lt;a href=&quot;../../base/constants/index#Base.VERSION&quot;&gt; &lt;code&gt;VERSION&lt;/code&gt; &lt;/a&gt;定数に使用される以外に、 &lt;code&gt;VersionNumber&lt;/code&gt; オブジェクトは &lt;code&gt;Pkg&lt;/code&gt; モジュールで広く使用され、パッケージのバージョンとその依存関係を指定します。</target>
        </trans-unit>
        <trans-unit id="4c077965afc4d3ad848734d7192dc33685665fb8" translate="yes" xml:space="preserve">
          <source>Bet Symbol / Second Transfinite Cardinal</source>
          <target state="translated">ベットシンボル/セカンドトランスフィニットカーディナル</target>
        </trans-unit>
        <trans-unit id="1b22feb0c0c13c69ebe6389111ff7312bd0c946b" translate="yes" xml:space="preserve">
          <source>Between</source>
          <target state="translated">Between</target>
        </trans-unit>
        <trans-unit id="4e83ab72f5680a7927bc2ee1770585b538110359" translate="yes" xml:space="preserve">
          <source>Bicycle</source>
          <target state="translated">Bicycle</target>
        </trans-unit>
        <trans-unit id="af44c67fc560bdac204e3457136721b15282deb9" translate="yes" xml:space="preserve">
          <source>Bicyclist</source>
          <target state="translated">Bicyclist</target>
        </trans-unit>
        <trans-unit id="ca17e7c02d8603afa7449be022da99c068361156" translate="yes" xml:space="preserve">
          <source>Bidiagonal</source>
          <target state="translated">Bidiagonal</target>
        </trans-unit>
        <trans-unit id="f0830adbb847a3826b894a8d2b1be1aa3648828e" translate="yes" xml:space="preserve">
          <source>BigFloats and BigInts</source>
          <target state="translated">ビッグフロートとビッグインッツ</target>
        </trans-unit>
        <trans-unit id="669a7400e7ecdc8abb5def5c2be2775fd1a39afb" translate="yes" xml:space="preserve">
          <source>Bignums are supported, but conversion is not automatic; ordinary integers &lt;a href=&quot;../faq/index#faq-integer-arithmetic&quot;&gt;overflow&lt;/a&gt;.</source>
          <target state="translated">Bignumはサポートされていますが、変換は自動ではありません。通常の整数は&lt;a href=&quot;../faq/index#faq-integer-arithmetic&quot;&gt;オーバーフローし&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="aacc2899433eb85e7a2394fe9113a636959564b2" translate="yes" xml:space="preserve">
          <source>Bikini</source>
          <target state="translated">Bikini</target>
        </trans-unit>
        <trans-unit id="aaaa53539dc3641fca1eac5e64bf0cba011ff6e3" translate="yes" xml:space="preserve">
          <source>Bilaterally permute &lt;code&gt;A&lt;/code&gt;, returning &lt;code&gt;PAQ&lt;/code&gt; (&lt;code&gt;A[p,q]&lt;/code&gt;). Column-permutation &lt;code&gt;q&lt;/code&gt;'s length must match &lt;code&gt;A&lt;/code&gt;'s column count (&lt;code&gt;length(q) == A.n&lt;/code&gt;). Row-permutation &lt;code&gt;p&lt;/code&gt;'s length must match &lt;code&gt;A&lt;/code&gt;'s row count (&lt;code&gt;length(p) == A.m&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; を双方向に並べ替え、 &lt;code&gt;PAQ&lt;/code&gt; を返します（ &lt;code&gt;A[p,q]&lt;/code&gt; ）。列置換 &lt;code&gt;q&lt;/code&gt; の長さは &lt;code&gt;A&lt;/code&gt; の列数と一致する必要があります（ &lt;code&gt;length(q) == A.n&lt;/code&gt; ）。行順列 &lt;code&gt;p&lt;/code&gt; の長さは &lt;code&gt;A&lt;/code&gt; の行数と一致する必要があります（ &lt;code&gt;length(p) == A.m&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="5033e83ebc769b610ff5842eedc3584eb861a747" translate="yes" xml:space="preserve">
          <source>Bilaterally permute &lt;code&gt;A&lt;/code&gt;, returning &lt;code&gt;PAQ&lt;/code&gt; (&lt;code&gt;A[p,q]&lt;/code&gt;). Column-permutation &lt;code&gt;q&lt;/code&gt;'s length must match &lt;code&gt;A&lt;/code&gt;'s column count (&lt;code&gt;length(q) == size(A, 2)&lt;/code&gt;). Row-permutation &lt;code&gt;p&lt;/code&gt;'s length must match &lt;code&gt;A&lt;/code&gt;'s row count (&lt;code&gt;length(p) == size(A, 1)&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; を二国間で並べ替え、 &lt;code&gt;PAQ&lt;/code&gt; （ &lt;code&gt;A[p,q]&lt;/code&gt; ）を返します。列順列 &lt;code&gt;q&lt;/code&gt; の長さは &lt;code&gt;A&lt;/code&gt; の列数と一致する必要があります（ &lt;code&gt;length(q) == size(A, 2)&lt;/code&gt; ）。行順列 &lt;code&gt;p&lt;/code&gt; の長さは &lt;code&gt;A&lt;/code&gt; の行数と一致する必要があります（ &lt;code&gt;length(p) == size(A, 1)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="aa67c0c72b73769483142d524a72dd00b47e7280" translate="yes" xml:space="preserve">
          <source>Bilaterally permute &lt;code&gt;A&lt;/code&gt;, storing result &lt;code&gt;PAQ&lt;/code&gt; (&lt;code&gt;A[p,q]&lt;/code&gt;) in &lt;code&gt;X&lt;/code&gt;. Stores intermediate result &lt;code&gt;(AQ)^T&lt;/code&gt; (&lt;code&gt;transpose(A[:,q])&lt;/code&gt;) in optional argument &lt;code&gt;C&lt;/code&gt; if present. Requires that none of &lt;code&gt;X&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt;, and, if present, &lt;code&gt;C&lt;/code&gt; alias each other; to store result &lt;code&gt;PAQ&lt;/code&gt; back into &lt;code&gt;A&lt;/code&gt;, use the following method lacking &lt;code&gt;X&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; を双方向に置換し、結果 &lt;code&gt;PAQ&lt;/code&gt; （ &lt;code&gt;A[p,q]&lt;/code&gt; ）を &lt;code&gt;X&lt;/code&gt; に格納します。中間結果 &lt;code&gt;(AQ)^T&lt;/code&gt; （ &lt;code&gt;transpose(A[:,q])&lt;/code&gt; ）をオプションの引数 &lt;code&gt;C&lt;/code&gt; に格納します（存在する場合）。 &lt;code&gt;X&lt;/code&gt; 、 &lt;code&gt;A&lt;/code&gt; 、および存在する場合は &lt;code&gt;C&lt;/code&gt; のいずれも互いにエイリアスを設定しないことを要求します。結果の &lt;code&gt;PAQ&lt;/code&gt; を &lt;code&gt;A&lt;/code&gt; に格納するには、 &lt;code&gt;X&lt;/code&gt; がない次のメソッドを使用します。</target>
        </trans-unit>
        <trans-unit id="9c4f1f960deffd3639bacc943d7beee3c049657a" translate="yes" xml:space="preserve">
          <source>Billiards</source>
          <target state="translated">Billiards</target>
        </trans-unit>
        <trans-unit id="c1d93ced1617078468dc67be83745c4934553581" translate="yes" xml:space="preserve">
          <source>Binary (or unary) operators like &lt;code&gt;.+&lt;/code&gt; are handled with the same mechanism: they are equivalent to &lt;code&gt;broadcast&lt;/code&gt; calls and are fused with other nested &quot;dot&quot; calls. &lt;code&gt;X .+= Y&lt;/code&gt; etcetera is equivalent to &lt;code&gt;X .= X .+ Y&lt;/code&gt; and results in a fused in-place assignment; see also &lt;a href=&quot;../mathematical-operations/index#man-dot-operators&quot;&gt;dot operators&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;.+&lt;/code&gt; ようなバイナリ（または単項）演算子は同じメカニズムで処理 &lt;code&gt;broadcast&lt;/code&gt; ます。これらはブロードキャスト呼び出しと同等であり、他のネストされた「ドット」呼び出しと融合されます。 &lt;code&gt;X .+= Y&lt;/code&gt; 等々は、と等価である &lt;code&gt;X .= X .+ Y&lt;/code&gt; 及び融合インプレース割り当てをもたらします。&lt;a href=&quot;../mathematical-operations/index#man-dot-operators&quot;&gt;ドット演算子&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="6a9a9dae508a5a43298d0ecf022071a0f6818999" translate="yes" xml:space="preserve">
          <source>Binary (or unary) operators like &lt;code&gt;.+&lt;/code&gt; are handled with the same mechanism: they are equivalent to &lt;code&gt;broadcast&lt;/code&gt; calls and are fused with other nested &quot;dot&quot; calls. &lt;code&gt;X .+= Y&lt;/code&gt; etcetera is equivalent to &lt;code&gt;X .= X .+ Y&lt;/code&gt; and results in a fused in-place assignment; see also &lt;a href=&quot;../mathematical-operations/index#man-dot-operators-1&quot;&gt;dot operators&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;.+&lt;/code&gt; ようなバイナリ（または単項）演算子は同じメカニズムで処理 &lt;code&gt;broadcast&lt;/code&gt; ます。これらはブロードキャスト呼び出しと同等であり、他のネストされた「ドット」呼び出しと融合されます。 &lt;code&gt;X .+= Y&lt;/code&gt; 等々は、と等価である &lt;code&gt;X .= X .+ Y&lt;/code&gt; 及び融合インプレース割り当てをもたらします。&lt;a href=&quot;../mathematical-operations/index#man-dot-operators-1&quot;&gt;ドット演算子&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="a754b43c5cd6bc6c82c954daabe8d0dd0d9ab2bb" translate="yes" xml:space="preserve">
          <source>Binary and octal literals are also supported:</source>
          <target state="translated">2進リテラルと8進リテラルもサポートされています。</target>
        </trans-unit>
        <trans-unit id="f84a08f5fd91d8b683f66ada3a3f0d37dd8d9416" translate="yes" xml:space="preserve">
          <source>Binary arithmetic &amp;ndash; &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;\&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;</source>
          <target state="translated">バイナリ算術- - &lt;code&gt;-&lt;/code&gt; + 、 &lt;code&gt;+&lt;/code&gt; &lt;code&gt;*&lt;/code&gt; 、 &lt;code&gt;/&lt;/code&gt; 、 &lt;code&gt;\&lt;/code&gt; 、 &lt;code&gt;^&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="96c4e4b4e465473735caeea3bbe55395f833f831" translate="yes" xml:space="preserve">
          <source>Binary format: 1 sign, 11 exponent, 52 fraction bits.</source>
          <target state="translated">バイナリ形式。1 符号、11 指数、52 分数ビット。</target>
        </trans-unit>
        <trans-unit id="81c2dc88cfba0517f9a198be3d135a4aa4ba4c99" translate="yes" xml:space="preserve">
          <source>Binary format: 1 sign, 5 exponent, 10 fraction bits.</source>
          <target state="translated">バイナリ形式。1 符号、5 指数、10 分数ビット。</target>
        </trans-unit>
        <trans-unit id="2e8b640f698cc5a43263f00b745c9489369b4eda" translate="yes" xml:space="preserve">
          <source>Binary format: 1 sign, 8 exponent, 23 fraction bits.</source>
          <target state="translated">バイナリ形式。1 符号、8 指数、23 分数ビット。</target>
        </trans-unit>
        <trans-unit id="08e24dd0237ae9c6c248482e7cdae84d6dd71aee" translate="yes" xml:space="preserve">
          <source>Binary, octal, and hexadecimal literals may be signed by a &lt;code&gt;-&lt;/code&gt; immediately preceding the unsigned literal. They produce an unsigned integer of the same size as the unsigned literal would do, with the two's complement of the value:</source>
          <target state="translated">2進数、8進数、16進数のリテラルは、符号なしリテラルの直前に &lt;code&gt;-&lt;/code&gt; を付けることができます。これらは、値の2の補数で、符号なしリテラルと同じサイズの符号なし整数を生成します。</target>
        </trans-unit>
        <trans-unit id="ccb7426c705bde96fa9acacc232348e6649fb196" translate="yes" xml:space="preserve">
          <source>Bind &lt;code&gt;socket&lt;/code&gt; to the given &lt;code&gt;host:port&lt;/code&gt;. Note that &lt;code&gt;0.0.0.0&lt;/code&gt; will listen on all devices.</source>
          <target state="translated">指定された &lt;code&gt;host:port&lt;/code&gt; に &lt;code&gt;socket&lt;/code&gt; をバインドします。 &lt;code&gt;0.0.0.0&lt;/code&gt; はすべてのデバイスでリッスンすることに注意してください。</target>
        </trans-unit>
        <trans-unit id="fe7e2953e9474b2bd135241c7c997e4972287729" translate="yes" xml:space="preserve">
          <source>Bird</source>
          <target state="translated">Bird</target>
        </trans-unit>
        <trans-unit id="65c2eaa1dcfba5d5f9a0a3584ad5e6d8f7aef198" translate="yes" xml:space="preserve">
          <source>Birthday Cake</source>
          <target state="translated">バースデーケーキ</target>
        </trans-unit>
        <trans-unit id="93ea79c838264d2a1d87b4b0c60302c8a973255c" translate="yes" xml:space="preserve">
          <source>BitArray</source>
          <target state="translated">BitArray</target>
        </trans-unit>
        <trans-unit id="4b9bfa4acc76402f1ab1ef6ccdbff0077343e801" translate="yes" xml:space="preserve">
          <source>BitArray()</source>
          <target state="translated">BitArray()</target>
        </trans-unit>
        <trans-unit id="f8cd7716f7a5997d4efd153b8de6bda8ac575d3b" translate="yes" xml:space="preserve">
          <source>BitSet</source>
          <target state="translated">BitSet</target>
        </trans-unit>
        <trans-unit id="d102341c9ef55fb595a96df06da32dfabaf31707" translate="yes" xml:space="preserve">
          <source>Bits Types</source>
          <target state="translated">ビットタイプ</target>
        </trans-unit>
        <trans-unit id="3d60896c2746f9344a7ec07d0c544abfbd6ac054" translate="yes" xml:space="preserve">
          <source>Bitshifts</source>
          <target state="translated">Bitshifts</target>
        </trans-unit>
        <trans-unit id="f06f824cef5caab026aebdaccc85d665d4b620db" translate="yes" xml:space="preserve">
          <source>Bitwise Operators</source>
          <target state="translated">ビット演算子</target>
        </trans-unit>
        <trans-unit id="003769240202348f8c8c50c01088aea9a66d1338" translate="yes" xml:space="preserve">
          <source>Bitwise and. Implements &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;, returning &lt;a href=&quot;../base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; if one operand is &lt;code&gt;missing&lt;/code&gt; and the other is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">ビットごとと。実装し&lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;、三値論理&lt;/a&gt;、帰国&lt;a href=&quot;../base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; 1つのオペランドがされた場合に &lt;code&gt;missing&lt;/code&gt; と、他のです &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="39242907d8fbb94d63ee93aa69c2eae1e3bdde37" translate="yes" xml:space="preserve">
          <source>Bitwise and. Implements &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;, returning &lt;a href=&quot;../base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; if one operand is &lt;code&gt;missing&lt;/code&gt; and the other is &lt;code&gt;true&lt;/code&gt;. Add parentheses for function application form: &lt;code&gt;(&amp;amp;)(x, y)&lt;/code&gt;.</source>
          <target state="translated">ビット単位および。実装し&lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;、三値論理&lt;/a&gt;、帰国&lt;a href=&quot;../base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt;1つのオペランドがされた場合に &lt;code&gt;missing&lt;/code&gt; と、他のです &lt;code&gt;true&lt;/code&gt; 。関数適用フォームの括弧を追加します： &lt;code&gt;(&amp;amp;)(x, y)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e8386afef0f71e44b527049e051999293a919fac" translate="yes" xml:space="preserve">
          <source>Bitwise exclusive or of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. Implements &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;, returning &lt;a href=&quot;../base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; if one of the arguments is &lt;code&gt;missing&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; のビット単位の排他的論理和。&lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;3つの値のロジックを&lt;/a&gt;実装し、引数の1つが&lt;a href=&quot;../base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt;場合は &lt;code&gt;missing&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="95edcf566466d2b1f53eaf47da115b29e2f2b799" translate="yes" xml:space="preserve">
          <source>Bitwise not.</source>
          <target state="translated">ビットではありません。</target>
        </trans-unit>
        <trans-unit id="55d4c457eca0630bcbc6d9ef2deac549be6e9eb1" translate="yes" xml:space="preserve">
          <source>Bitwise or. Implements &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;, returning &lt;a href=&quot;../base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; if one operand is &lt;code&gt;missing&lt;/code&gt; and the other is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">ビットごとまたは。実装し&lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;、三値論理&lt;/a&gt;、帰国&lt;a href=&quot;../base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; 1つのオペランドがされた場合に &lt;code&gt;missing&lt;/code&gt; と、他のです &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fbd4e8d6d33b0a0cb69eddf98c203dfb76b59494" translate="yes" xml:space="preserve">
          <source>Black Circle</source>
          <target state="translated">ブラックサークル</target>
        </trans-unit>
        <trans-unit id="0548413521ae8836d60c83abbcac0b4ffd5b48c9" translate="yes" xml:space="preserve">
          <source>Black Circle With Two White Dots</source>
          <target state="translated">2つの白い点と黒い円</target>
        </trans-unit>
        <trans-unit id="d7fd466be098000d71600e8371d0c45e2c49fceb" translate="yes" xml:space="preserve">
          <source>Black Circle With White Dot Right</source>
          <target state="translated">ホワイトドット右の黒い円</target>
        </trans-unit>
        <trans-unit id="757cd02902cbeae20fd43d03ee03d7081baecb82" translate="yes" xml:space="preserve">
          <source>Black Club Suit</source>
          <target state="translated">ブラッククラブスーツ</target>
        </trans-unit>
        <trans-unit id="9450d23785e56cc9d47bc85752234baaa5f58935" translate="yes" xml:space="preserve">
          <source>Black Diamond</source>
          <target state="translated">ブラックダイヤモンド</target>
        </trans-unit>
        <trans-unit id="1e863cdb2d578f5fa6a621df1fbd38ab6818ad43" translate="yes" xml:space="preserve">
          <source>Black Diamond Suit</source>
          <target state="translated">ブラックダイヤモンドスーツ</target>
        </trans-unit>
        <trans-unit id="143603a649d02ce401e75e3d4b9853da1d1fab9f" translate="yes" xml:space="preserve">
          <source>Black Down-Pointing Double Triangle</source>
          <target state="translated">ブラックダウンポインティングダブルトライアングル</target>
        </trans-unit>
        <trans-unit id="7131227a767e1555b67aefca3c1775aaf0e8eee4" translate="yes" xml:space="preserve">
          <source>Black Down-Pointing Small Triangle / Black Down Pointing Small Triangle</source>
          <target state="translated">ブラックダウンポインティングスモールトライアングル/ブラックダウンポインティングスモールトライアングル</target>
        </trans-unit>
        <trans-unit id="157034cbc1651891d53bf3735a8280c2c9e17261" translate="yes" xml:space="preserve">
          <source>Black Down-Pointing Triangle / Black Down Pointing Triangle</source>
          <target state="translated">ブラックダウンポインティングトライアングル/ブラックダウンポインティングトライアングル</target>
        </trans-unit>
        <trans-unit id="79bb28413b3c0425fd63303d0da05ee06907711e" translate="yes" xml:space="preserve">
          <source>Black Heart Suit</source>
          <target state="translated">ブラックハートスーツ</target>
        </trans-unit>
        <trans-unit id="84860fcb2778d5994fb2e1ec4ed5e1ff25be0c69" translate="yes" xml:space="preserve">
          <source>Black Hexagon</source>
          <target state="translated">黒の六角形</target>
        </trans-unit>
        <trans-unit id="eb3fe0b35214fe985deafdd4923cb6b5b71ecc00" translate="yes" xml:space="preserve">
          <source>Black Horizontal Ellipse</source>
          <target state="translated">黒の横長楕円</target>
        </trans-unit>
        <trans-unit id="3d24dccec23ef173830493e234a9797701114f4b" translate="yes" xml:space="preserve">
          <source>Black Large Circle</source>
          <target state="translated">ブラックラージサークル</target>
        </trans-unit>
        <trans-unit id="546e54ab988bdc54b4d67a0c87d99ffab31da61d" translate="yes" xml:space="preserve">
          <source>Black Large Square</source>
          <target state="translated">ブラック ラージスクエア</target>
        </trans-unit>
        <trans-unit id="6c8aa0f6c88d86e760e667a1cfc3b50d0980df03" translate="yes" xml:space="preserve">
          <source>Black Left-Pointing Double Triangle</source>
          <target state="translated">黒の左向き二重三角</target>
        </trans-unit>
        <trans-unit id="cc1db57a30b84796696c95aebddd648e97e8d503" translate="yes" xml:space="preserve">
          <source>Black Left-Pointing Pointer / Black Left Pointing Pointer</source>
          <target state="translated">ブラック左ポインティングポインター/ブラック左ポインティングポインター</target>
        </trans-unit>
        <trans-unit id="f5b4fdf2d1f644120341bc595bfdc32acb38d8d9" translate="yes" xml:space="preserve">
          <source>Black Left-Pointing Small Triangle / Black Left Pointing Small Triangle</source>
          <target state="translated">黒の左寄せ小三角形/黒の左寄せ小三角形</target>
        </trans-unit>
        <trans-unit id="394197a1901b539e852cc0120322c6a8cc9c8a83" translate="yes" xml:space="preserve">
          <source>Black Left-Pointing Triangle / Black Left Pointing Triangle</source>
          <target state="translated">黒色の左向き三角形/黒色の左向き三角形</target>
        </trans-unit>
        <trans-unit id="651c14702ebcf7b7b2d5b2b8b2d4c78353cf3dc3" translate="yes" xml:space="preserve">
          <source>Black Lower Left Triangle</source>
          <target state="translated">黒色の左下の三角形</target>
        </trans-unit>
        <trans-unit id="a993e08e4e58513d7c168e38a98af83c1b823e70" translate="yes" xml:space="preserve">
          <source>Black Lower Right Triangle</source>
          <target state="translated">黒色 右下三角形</target>
        </trans-unit>
        <trans-unit id="7784160f9d8de2c5b48e65c73c3ba7c32077d5d3" translate="yes" xml:space="preserve">
          <source>Black Lozenge</source>
          <target state="translated">ブラックロゼ</target>
        </trans-unit>
        <trans-unit id="f51954be7eb46c9d2126809c883eed1d9b6af3da" translate="yes" xml:space="preserve">
          <source>Black Medium Diamond</source>
          <target state="translated">ブラックミディアムダイヤモンド</target>
        </trans-unit>
        <trans-unit id="e638cf3b3eda8a7622b5719c7bc597161ec84dff" translate="yes" xml:space="preserve">
          <source>Black Medium Lozenge</source>
          <target state="translated">ブラックミディアムロゼンジ</target>
        </trans-unit>
        <trans-unit id="7d1eb991c64f2c0aa6c491bf46495204bab8b980" translate="yes" xml:space="preserve">
          <source>Black Medium Small Square</source>
          <target state="translated">ブラック ミディアム スモール スクエア</target>
        </trans-unit>
        <trans-unit id="35e1e8816c4ad0b081b1abc5f0b5e6e68515fdd3" translate="yes" xml:space="preserve">
          <source>Black Medium Square</source>
          <target state="translated">ブラックミディアムスクエア</target>
        </trans-unit>
        <trans-unit id="bd88cc2496f705279f693662165cafc22758e595" translate="yes" xml:space="preserve">
          <source>Black Nib</source>
          <target state="translated">ブラックニブ</target>
        </trans-unit>
        <trans-unit id="17a74c499db585ffc78ad964cf24f74eeab12fbc" translate="yes" xml:space="preserve">
          <source>Black Parallelogram</source>
          <target state="translated">黒の平行四辺形</target>
        </trans-unit>
        <trans-unit id="a5e0106e423905d56ce64cbee75d3dab7ab613a8" translate="yes" xml:space="preserve">
          <source>Black Pentagon</source>
          <target state="translated">ブラックペンタゴン</target>
        </trans-unit>
        <trans-unit id="641e8ed8cc5074283080ad85521696fc93454500" translate="yes" xml:space="preserve">
          <source>Black Question Mark Ornament</source>
          <target state="translated">ブラッククエスチョンマークオーナメント</target>
        </trans-unit>
        <trans-unit id="d17f522d42443e1dee4d94f18ac22410a504bd60" translate="yes" xml:space="preserve">
          <source>Black Rectangle</source>
          <target state="translated">黒の長方形</target>
        </trans-unit>
        <trans-unit id="c7dbb16f8d25cc978eab91325f13bfbb34eb443b" translate="yes" xml:space="preserve">
          <source>Black Right-Pointing Double Triangle</source>
          <target state="translated">黒の直角二重三角</target>
        </trans-unit>
        <trans-unit id="9a22fd5458a747bf2f8b9190b0800a8f327c6da4" translate="yes" xml:space="preserve">
          <source>Black Right-Pointing Pentagon</source>
          <target state="translated">ブラック右翼ペンタゴン</target>
        </trans-unit>
        <trans-unit id="08e8d8d34fe44b6c1da81bad30dfbb3dd0e4dc17" translate="yes" xml:space="preserve">
          <source>Black Right-Pointing Pointer / Black Right Pointing Pointer</source>
          <target state="translated">黒の右ポインティングポインター/黒の右ポインティングポインター</target>
        </trans-unit>
        <trans-unit id="356acd32b10439549774affb8876e75924c2d411" translate="yes" xml:space="preserve">
          <source>Black Right-Pointing Small Triangle / Black Right Pointing Small Triangle</source>
          <target state="translated">黒の直角小三角/黒の直角小三角</target>
        </trans-unit>
        <trans-unit id="91e55728177959f6eb733905e6d5d4b3b30df4c9" translate="yes" xml:space="preserve">
          <source>Black Right-Pointing Triangle / Black Right Pointing Triangle</source>
          <target state="translated">ブラックライトポインティングトライアングル/ブラックライトポインティングトライアングル</target>
        </trans-unit>
        <trans-unit id="7d35d74427ef7783600f70aed6734b005afcf3a5" translate="yes" xml:space="preserve">
          <source>Black Rightwards Arrow / Black Right Arrow</source>
          <target state="translated">黒の右矢印/黒の右矢印</target>
        </trans-unit>
        <trans-unit id="4e1227a3b661c19e11075ce6c898353138a6cae4" translate="yes" xml:space="preserve">
          <source>Black Scissors</source>
          <target state="translated">ブラックシザーズ</target>
        </trans-unit>
        <trans-unit id="3a1f9cf604664d5b2cfd7032309a96005ebcdd85" translate="yes" xml:space="preserve">
          <source>Black Small Diamond</source>
          <target state="translated">ブラック スモールダイヤモンド</target>
        </trans-unit>
        <trans-unit id="560e8f05828a680fa9a4f86877ed9847156b94a9" translate="yes" xml:space="preserve">
          <source>Black Small Lozenge</source>
          <target state="translated">ブラックスモールロゼンジ</target>
        </trans-unit>
        <trans-unit id="2b77f77dfe2cfd17e674571a7ea6fb868ae1d0ef" translate="yes" xml:space="preserve">
          <source>Black Small Square</source>
          <target state="translated">ブラック スモールスクエア</target>
        </trans-unit>
        <trans-unit id="53c256b922dbb0b4f34a326b72cef14e0af86c98" translate="yes" xml:space="preserve">
          <source>Black Small Star</source>
          <target state="translated">ブラックスモールスター</target>
        </trans-unit>
        <trans-unit id="0ae1e3c46db08b1fb9b73728e2d7c428044fafa6" translate="yes" xml:space="preserve">
          <source>Black Smiling Face</source>
          <target state="translated">黒い笑顔</target>
        </trans-unit>
        <trans-unit id="8e05108bb9601bfdc9ba0035253f2d64bdf60694" translate="yes" xml:space="preserve">
          <source>Black Spade Suit</source>
          <target state="translated">ブラックスペードスーツ</target>
        </trans-unit>
        <trans-unit id="a01d4a6e7dbc191a1cae5b3bc838a6150cf238dd" translate="yes" xml:space="preserve">
          <source>Black Square</source>
          <target state="translated">ブラックスクエア</target>
        </trans-unit>
        <trans-unit id="034b512bb5927fe50340904cd99432e1e4d73c3e" translate="yes" xml:space="preserve">
          <source>Black Square Button</source>
          <target state="translated">ブラックスクエアボタン</target>
        </trans-unit>
        <trans-unit id="fc626f5b71fcc01fb3ad79538a1fdd9c2c9068b3" translate="yes" xml:space="preserve">
          <source>Black Star</source>
          <target state="translated">ブラックスター</target>
        </trans-unit>
        <trans-unit id="cb52335be163268292bf2e0b734ba8007620b51b" translate="yes" xml:space="preserve">
          <source>Black Sun With Rays</source>
          <target state="translated">レイズの黒い太陽</target>
        </trans-unit>
        <trans-unit id="337ee67e4218483768c29454b46d3636ae0684a9" translate="yes" xml:space="preserve">
          <source>Black Telephone</source>
          <target state="translated">黒電話</target>
        </trans-unit>
        <trans-unit id="35536366f9217c4ba0ce04cd1f6ccbeed6b48c42" translate="yes" xml:space="preserve">
          <source>Black Universal Recycling Symbol</source>
          <target state="translated">黒色のユニバーサルリサイクルシンボル</target>
        </trans-unit>
        <trans-unit id="b63e9c12f3af70d3503bfb12a43507958e2cc9a3" translate="yes" xml:space="preserve">
          <source>Black Up-Pointing Double Triangle</source>
          <target state="translated">ブラックアップポインティングダブルトライアングル</target>
        </trans-unit>
        <trans-unit id="5f6c177d2a76e96c788cfff6b45ea350fc5d5f85" translate="yes" xml:space="preserve">
          <source>Black Up-Pointing Small Triangle / Black Up Pointing Small Triangle</source>
          <target state="translated">ブラックアップポインティングスモールトライアングル/ブラックアップポインティングスモールトライアングル</target>
        </trans-unit>
        <trans-unit id="b019fe1ecc9d7bb3e20c546241096de99470763e" translate="yes" xml:space="preserve">
          <source>Black Up-Pointing Triangle / Black Up Pointing Triangle</source>
          <target state="translated">ブラックアップポインティングトライアングル/ブラックアップポインティングトライアングル</target>
        </trans-unit>
        <trans-unit id="fd38c797487c28729bfa7084dbd1bc7a8bd9f832" translate="yes" xml:space="preserve">
          <source>Black Upper Left Triangle</source>
          <target state="translated">黒色の左上の三角形</target>
        </trans-unit>
        <trans-unit id="330a4e0eb7ba380f3677a102ba04f4ed4533c835" translate="yes" xml:space="preserve">
          <source>Black Upper Right Triangle</source>
          <target state="translated">黒色の右上の三角形</target>
        </trans-unit>
        <trans-unit id="b5b860326f4e45d10acdc58e96248cded912b473" translate="yes" xml:space="preserve">
          <source>Black Vertical Ellipse</source>
          <target state="translated">黒の縦長楕円</target>
        </trans-unit>
        <trans-unit id="12f762cae12dfd257dbcc1ff1c80f6e21ca05f3a" translate="yes" xml:space="preserve">
          <source>Black Vertical Rectangle</source>
          <target state="translated">黒の縦長長方形</target>
        </trans-unit>
        <trans-unit id="b6c6da3063676ec7403eb5eae23f28a26cc0a5b1" translate="yes" xml:space="preserve">
          <source>Black Very Small Square</source>
          <target state="translated">黒の極小スクエア</target>
        </trans-unit>
        <trans-unit id="f56700596b30b0c05182a7f770b5570cc76ca6d1" translate="yes" xml:space="preserve">
          <source>Black-Letter Capital C / Black-Letter C</source>
          <target state="translated">黒文字の大文字C/黒文字のC</target>
        </trans-unit>
        <trans-unit id="3212f9c9a227cc0ef9fc8c3906dee3d018e41215" translate="yes" xml:space="preserve">
          <source>Black-Letter Capital H / Black-Letter H</source>
          <target state="translated">黒文字の大文字H/黒文字のH</target>
        </trans-unit>
        <trans-unit id="882d2d7aaddec9c72be91b9b04d8760d1ae0ecd3" translate="yes" xml:space="preserve">
          <source>Black-Letter Capital I / Black-Letter I</source>
          <target state="translated">黒文字大文字I/黒文字I</target>
        </trans-unit>
        <trans-unit id="8fc35324b6b0420a0444517c7f25614eb146dba4" translate="yes" xml:space="preserve">
          <source>Black-Letter Capital R / Black-Letter R</source>
          <target state="translated">黒文字の大文字R/黒文字のR</target>
        </trans-unit>
        <trans-unit id="4d139693ac24fa1ff39a927bee456e508f1aa95b" translate="yes" xml:space="preserve">
          <source>Black-Letter Capital Z / Black-Letter Z</source>
          <target state="translated">黒文字の大文字Z/黒文字のZ</target>
        </trans-unit>
        <trans-unit id="b847d9aaffd54e2b50551787d032091550aee835" translate="yes" xml:space="preserve">
          <source>Blank Symbol / Blank</source>
          <target state="translated">空欄記号/空欄</target>
        </trans-unit>
        <trans-unit id="9a1f6bbeb59612c3b0d54abe35a469485c6370c0" translate="yes" xml:space="preserve">
          <source>Block quotes</source>
          <target state="translated">ブロック引用</target>
        </trans-unit>
        <trans-unit id="413fe7b76bad922e0442b15508cafb42d749001b" translate="yes" xml:space="preserve">
          <source>Block the current task for a specified number of seconds. The minimum sleep time is 1 millisecond or input of &lt;code&gt;0.001&lt;/code&gt;.</source>
          <target state="translated">指定された秒数の間、現在のタスクをブロックします。最小スリープ時間は1ミリ秒または &lt;code&gt;0.001&lt;/code&gt; の入力です。</target>
        </trans-unit>
        <trans-unit id="da010911be728132526ebfb6c6611c41bf6de799" translate="yes" xml:space="preserve">
          <source>Block the current task until some event occurs, depending on the type of the argument:</source>
          <target state="translated">引数のタイプに応じて、何らかのイベントが発生するまで現在のタスクをブロックします。</target>
        </trans-unit>
        <trans-unit id="53a69c53a3e2458ff176a179fec2def0b4121cba" translate="yes" xml:space="preserve">
          <source>Blossom</source>
          <target state="translated">Blossom</target>
        </trans-unit>
        <trans-unit id="a6a6cc1c6c34e00f61be8a8c251a0e48237ab0a0" translate="yes" xml:space="preserve">
          <source>Blowfish</source>
          <target state="translated">Blowfish</target>
        </trans-unit>
        <trans-unit id="5963e560ae138684a55eeb248a0ec6a3d3e89c64" translate="yes" xml:space="preserve">
          <source>Blue Book</source>
          <target state="translated">ブルーブック</target>
        </trans-unit>
        <trans-unit id="a660e98a286d13e32848e06494a9c4e64598de77" translate="yes" xml:space="preserve">
          <source>Blue Heart</source>
          <target state="translated">ブルーハート</target>
        </trans-unit>
        <trans-unit id="30efd20f542ce356dcbbbbb0473393dd8189443b" translate="yes" xml:space="preserve">
          <source>Boar</source>
          <target state="translated">Boar</target>
        </trans-unit>
        <trans-unit id="19e07430eed6d97d6d73cb4a2967b1f316520f54" translate="yes" xml:space="preserve">
          <source>Bold</source>
          <target state="translated">Bold</target>
        </trans-unit>
        <trans-unit id="d5bf9d845ab97255cb3ab1100656db4f59731808" translate="yes" xml:space="preserve">
          <source>Bomb</source>
          <target state="translated">Bomb</target>
        </trans-unit>
        <trans-unit id="441da1bf0eb8dcaca895f5d48325eab484ada1e0" translate="yes" xml:space="preserve">
          <source>Bookmark</source>
          <target state="translated">Bookmark</target>
        </trans-unit>
        <trans-unit id="d51cc7068c060eda1ab4c1992e8e7188251dc5d0" translate="yes" xml:space="preserve">
          <source>Bookmark Tabs</source>
          <target state="translated">ブックマークタブ</target>
        </trans-unit>
        <trans-unit id="4a7fdd8c17425252332ea0e89a35722b72d83135" translate="yes" xml:space="preserve">
          <source>Books</source>
          <target state="translated">Books</target>
        </trans-unit>
        <trans-unit id="9110e7395759cef34c9766cb75b920652e0ab037" translate="yes" xml:space="preserve">
          <source>Boolean not. Implements &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;, returning &lt;a href=&quot;../base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;missing&lt;/code&gt;.</source>
          <target state="translated">ブールではありません。&lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;3値論理を&lt;/a&gt;実装し、 &lt;code&gt;x&lt;/code&gt; が &lt;code&gt;missing&lt;/code&gt; &lt;a href=&quot;../base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt;場合は欠落を返します。</target>
        </trans-unit>
        <trans-unit id="29a8f9f9b6a1cad56addb73a669797d31b6ebe67" translate="yes" xml:space="preserve">
          <source>Boolean operations &lt;em&gt;without&lt;/em&gt; short-circuit evaluation can be done with the bitwise boolean operators introduced in &lt;a href=&quot;../mathematical-operations/index#Mathematical-Operations-and-Elementary-Functions&quot;&gt;Mathematical Operations and Elementary Functions&lt;/a&gt;: &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;|&lt;/code&gt;. These are normal functions, which happen to support infix operator syntax, but always evaluate their arguments:</source>
          <target state="translated">ブール演算&lt;em&gt;のない&lt;/em&gt;短絡評価は、ビット単位で導入された論理演算子を使って行うことができ&lt;a href=&quot;../mathematical-operations/index#Mathematical-Operations-and-Elementary-Functions&quot;&gt;数学操作と初等関数&lt;/a&gt;： &lt;code&gt;&amp;amp;&lt;/code&gt; と &lt;code&gt;|&lt;/code&gt; 。これらは通常の関数であり、たまたま中置演算子の構文をサポートしていますが、常に引数を評価します。</target>
        </trans-unit>
        <trans-unit id="f5e74670608867d2d5a7f2c19b7656691fac4def" translate="yes" xml:space="preserve">
          <source>Boolean operations &lt;em&gt;without&lt;/em&gt; short-circuit evaluation can be done with the bitwise boolean operators introduced in &lt;a href=&quot;../mathematical-operations/index#Mathematical-Operations-and-Elementary-Functions-1&quot;&gt;Mathematical Operations and Elementary Functions&lt;/a&gt;: &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;|&lt;/code&gt;. These are normal functions, which happen to support infix operator syntax, but always evaluate their arguments:</source>
          <target state="translated">ブール演算&lt;em&gt;のない&lt;/em&gt;短絡評価は、ビット単位で導入された論理演算子を使って行うことができ&lt;a href=&quot;../mathematical-operations/index#Mathematical-Operations-and-Elementary-Functions-1&quot;&gt;数学操作と初等関数&lt;/a&gt;： &lt;code&gt;&amp;amp;&lt;/code&gt; と &lt;code&gt;|&lt;/code&gt; 。これらは通常、中置演算子構文をサポートする通常の関数ですが、常にそれらの引数を評価します。</target>
        </trans-unit>
        <trans-unit id="6aee8c1403b8f533d1b1cfe7c809aba2942d98a3" translate="yes" xml:space="preserve">
          <source>Boolean type, containing the values &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; および &lt;code&gt;false&lt;/code&gt; の値を含むブール型。</target>
        </trans-unit>
        <trans-unit id="1d3edec84ef05d40009ef42ad79a184127ff2d32" translate="yes" xml:space="preserve">
          <source>Both &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; are basically immutable &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt; wrappers. The single &lt;code&gt;instant&lt;/code&gt; field of either type is actually a &lt;code&gt;UTInstant{P}&lt;/code&gt; type, which represents a continuously increasing machine timeline based on the UT second &lt;a href=&quot;#footnote-1&quot;&gt;[1]&lt;/a&gt;. The &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; type is not aware of time zones (&lt;em&gt;naive&lt;/em&gt;, in Python parlance), analogous to a &lt;em&gt;LocalDateTime&lt;/em&gt; in Java 8. Additional time zone functionality can be added through the &lt;a href=&quot;https://github.com/JuliaTime/TimeZones.jl/&quot;&gt;TimeZones.jl package&lt;/a&gt;, which compiles the &lt;a href=&quot;http://www.iana.org/time-zones&quot;&gt;IANA time zone database&lt;/a&gt;. Both &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; are based on the &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;ISO 8601&lt;/a&gt; standard, which follows the proleptic Gregorian calendar. One note is that the ISO 8601 standard is particular about BC/BCE dates. In general, the last day of the BC/BCE era, 1-12-31 BC/BCE, was followed by 1-1-1 AD/CE, thus no year zero exists. The ISO standard, however, states that 1 BC/BCE is year zero, so &lt;code&gt;0000-12-31&lt;/code&gt; is the day before &lt;code&gt;0001-01-01&lt;/code&gt;, and year &lt;code&gt;-0001&lt;/code&gt; (yes, negative one for the year) is 2 BC/BCE, year &lt;code&gt;-0002&lt;/code&gt; is 3 BC/BCE, etc.</source>
          <target state="translated">&lt;a href=&quot;#Dates.Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;はどちらも基本的に不変の&lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt;ラッパーです。どちらかのタイプの単一の &lt;code&gt;instant&lt;/code&gt; フィールドは、実際には &lt;code&gt;UTInstant{P}&lt;/code&gt; タイプであり、UT秒&lt;a href=&quot;#footnote-1&quot;&gt;[1]に&lt;/a&gt;基づいて継続的に増加するマシンタイムラインを表します。&lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; 型の&lt;/a&gt;タイプは、（時間帯を認識していない&lt;em&gt;ナイーブ&lt;/em&gt;に類似し、Pythonの用語で、）&lt;em&gt;のLocalDateTime&lt;/em&gt;追加のタイムゾーンの機能を介して追加することができるJava 8で&lt;a href=&quot;https://github.com/JuliaTime/TimeZones.jl/&quot;&gt;TimeZones.jlパッケージ&lt;/a&gt;コンパイル、&lt;a href=&quot;http://www.iana.org/time-zones&quot;&gt;IANAタイムゾーンデータベース&lt;/a&gt;。&lt;a href=&quot;#Dates.Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;はどちらも&lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;ISO 8601&lt;/a&gt;規格。これはグレゴリオ暦の前向きな暦に従っています。ISO 8601規格はBC / BCEの日付に特別であることに注意してください。一般に、BC / BCE時代の最終日である1-12-31 BC / BCEの後に1-1-1 AD / CEが続いたため、ゼロ年は存在しません。ISO規格では、しかし、その1つのBC / BCEは年間ゼロであると述べ、 &lt;code&gt;0000-12-31&lt;/code&gt; は前日である &lt;code&gt;0001-01-01&lt;/code&gt; 、年 &lt;code&gt;-0001&lt;/code&gt; （年間はい、マイナス1）は2 BC / BCEであります、年 &lt;code&gt;-0002&lt;/code&gt; は3 BC / BCEなどです。</target>
        </trans-unit>
        <trans-unit id="9bd9372ad6716aa533ad19c4f4344f9f861990d8" translate="yes" xml:space="preserve">
          <source>Both &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; are basically immutable &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt; wrappers. The single &lt;code&gt;instant&lt;/code&gt; field of either type is actually a &lt;code&gt;UTInstant{P}&lt;/code&gt; type, which represents a continuously increasing machine timeline based on the UT second &lt;sup&gt;&lt;a href=&quot;#footnote-1&quot; id=&quot;citeref-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;. The &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; type is not aware of time zones (&lt;em&gt;naive&lt;/em&gt;, in Python parlance), analogous to a &lt;em&gt;LocalDateTime&lt;/em&gt; in Java 8. Additional time zone functionality can be added through the &lt;a href=&quot;https://github.com/JuliaTime/TimeZones.jl/&quot;&gt;TimeZones.jl package&lt;/a&gt;, which compiles the &lt;a href=&quot;http://www.iana.org/time-zones&quot;&gt;IANA time zone database&lt;/a&gt;. Both &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; are based on the &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;ISO 8601&lt;/a&gt; standard, which follows the proleptic Gregorian calendar. One note is that the ISO 8601 standard is particular about BC/BCE dates. In general, the last day of the BC/BCE era, 1-12-31 BC/BCE, was followed by 1-1-1 AD/CE, thus no year zero exists. The ISO standard, however, states that 1 BC/BCE is year zero, so &lt;code&gt;0000-12-31&lt;/code&gt; is the day before &lt;code&gt;0001-01-01&lt;/code&gt;, and year &lt;code&gt;-0001&lt;/code&gt; (yes, negative one for the year) is 2 BC/BCE, year &lt;code&gt;-0002&lt;/code&gt; is 3 BC/BCE, etc.</source>
          <target state="translated">&lt;a href=&quot;#Dates.Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;はどちらも、基本的に不変の&lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt;ラッパーです。いずれかのタイプの単一の &lt;code&gt;instant&lt;/code&gt; フィールドは、実際には &lt;code&gt;UTInstant{P}&lt;/code&gt; タイプであり、UT秒に基づいて継続的に増加するマシンタイムラインを表します&lt;sup&gt;&lt;a href=&quot;#footnote-1&quot; id=&quot;citeref-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;。&lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; 型の&lt;/a&gt;タイプは、（時間帯を認識していない&lt;em&gt;ナイーブ&lt;/em&gt;に類似し、Pythonの用語で、）&lt;em&gt;のLocalDateTime&lt;/em&gt;追加のタイムゾーンの機能を介して追加することができるJava 8で&lt;a href=&quot;https://github.com/JuliaTime/TimeZones.jl/&quot;&gt;TimeZones.jlパッケージ&lt;/a&gt;コンパイル、&lt;a href=&quot;http://www.iana.org/time-zones&quot;&gt;IANAタイムゾーンデータベース&lt;/a&gt;。&lt;a href=&quot;#Dates.Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;はどちらも、&lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;ISO 8601&lt;/a&gt;先発グレゴリオ暦を以下の標準、。 1つの注意点は、ISO8601標準がBC / BCEの日付に特化していることです。一般に、BC / BCE時代の最終日である1-12-31BC / BCEの後に1-1-1AD / CEが続くため、ゼロ年は存在しません。 ISO規格では、しかし、その1つのBC / BCEは年間ゼロであると述べ、 &lt;code&gt;0000-12-31&lt;/code&gt; は前日である &lt;code&gt;0001-01-01&lt;/code&gt; 、年 &lt;code&gt;-0001&lt;/code&gt; （年間はい、マイナス1）は2 BC / BCEであります、- &lt;code&gt;-0002&lt;/code&gt; 年は紀元前3年/紀元前などです。</target>
        </trans-unit>
        <trans-unit id="b9bf1ed5d0b3dee373193977f771d3d28aa04eff" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;fdot&lt;/code&gt; compute the same thing. However, &lt;code&gt;fdot&lt;/code&gt; (defined with the help of the &lt;a href=&quot;../../base/arrays/index#Base.Broadcast.@__dot__&quot;&gt;&lt;code&gt;@.&lt;/code&gt;&lt;/a&gt; macro) is significantly faster when applied to an array:</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; と &lt;code&gt;fdot&lt;/code&gt; はどちらも同じことを計算します。ただし、 &lt;code&gt;fdot&lt;/code&gt; （&lt;a href=&quot;../../base/arrays/index#Base.Broadcast.@__dot__&quot;&gt; &lt;code&gt;@.&lt;/code&gt; &lt;/a&gt;マクロを使用して定義）は、配列に適用すると大幅に高速化されます。</target>
        </trans-unit>
        <trans-unit id="894facd8272490d18ae36dfbd0aea23dbfd8d0be" translate="yes" xml:space="preserve">
          <source>Both abstract and concrete types can be parameterized by other types. They can also be parameterized by symbols, by values of any type for which &lt;a href=&quot;../../base/base/index#Base.isbits&quot;&gt;&lt;code&gt;isbits&lt;/code&gt;&lt;/a&gt; returns true (essentially, things like numbers and bools that are stored like C types or &lt;code&gt;struct&lt;/code&gt;s with no pointers to other objects), and also by tuples thereof. Type parameters may be omitted when they do not need to be referenced or restricted.</source>
          <target state="translated">抽象型と具象型の両方を他の型でパラメーター化できます。これらは、シンボル、&lt;a href=&quot;../../base/base/index#Base.isbits&quot;&gt; &lt;code&gt;isbits&lt;/code&gt; &lt;/a&gt;がtrueを返す任意の型の値（基本的には、C型または他のオブジェクトへのポインターのない &lt;code&gt;struct&lt;/code&gt; sのように格納される数値やブール値など）、およびそのタプルによってパラメーター化することもできます。型パラメーターは、参照または制限する必要がない場合は省略できます。</target>
        </trans-unit>
        <trans-unit id="63dac16e286415a31cf4c5cfa7d67dab90fd4b82" translate="yes" xml:space="preserve">
          <source>Both concatenation and string interpolation call &lt;a href=&quot;../../base/strings/index#Base.string&quot;&gt;&lt;code&gt;string&lt;/code&gt;&lt;/a&gt; to convert objects into string form. However, &lt;code&gt;string&lt;/code&gt; actually just returns the output of &lt;a href=&quot;../../base/io-network/index#Base.print&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt;, so new types should add methods to &lt;a href=&quot;../../base/io-network/index#Base.print&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;show&lt;/code&gt; instead of &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">連結と文字列補間はどちらも&lt;a href=&quot;../../base/strings/index#Base.string&quot;&gt; &lt;code&gt;string&lt;/code&gt; &lt;/a&gt;を呼び出してオブジェクトを文字列形式に変換します。ただし、実際には &lt;code&gt;string&lt;/code&gt; は単に&lt;a href=&quot;../../base/io-network/index#Base.print&quot;&gt; &lt;code&gt;print&lt;/code&gt; &lt;/a&gt;の出力を返すため、新しいタイプでは &lt;code&gt;string&lt;/code&gt; の代わりに&lt;a href=&quot;../../base/io-network/index#Base.print&quot;&gt; &lt;code&gt;print&lt;/code&gt; &lt;/a&gt;または &lt;code&gt;show&lt;/code&gt; のメソッドを追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="007479614c6ddfc352db8c91872c6cdcf690ee04" translate="yes" xml:space="preserve">
          <source>Both expressions are interpreted as function application: any expression that is not a numeric literal, when immediately followed by a parenthetical, is interpreted as a function applied to the values in parentheses (see &lt;a href=&quot;../faq/index#Functions&quot;&gt;Functions&lt;/a&gt; for more about functions). Thus, in both of these cases, an error occurs since the left-hand value is not a function.</source>
          <target state="translated">どちらの式も関数適用として解釈されます。数値リテラルでない式は、直後に括弧が続く場合、括弧内の値に適用される関数として解釈されます（&lt;a href=&quot;../faq/index#Functions&quot;&gt;関数&lt;/a&gt;の詳細については、関数を参照してください）。したがって、どちらの場合も、左側の値は関数ではないため、エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="e92cf62db18ffc6b16befca5871ba839cf28860c" translate="yes" xml:space="preserve">
          <source>Both expressions are interpreted as function application: any expression that is not a numeric literal, when immediately followed by a parenthetical, is interpreted as a function applied to the values in parentheses (see &lt;a href=&quot;../faq/index#Functions-1&quot;&gt;Functions&lt;/a&gt; for more about functions). Thus, in both of these cases, an error occurs since the left-hand value is not a function.</source>
          <target state="translated">どちらの式も関数適用として解釈されます。数値リテラルではない式は、直後に括弧が続く場合、括弧内の値に適用される関数として解釈されます（&lt;a href=&quot;../faq/index#Functions-1&quot;&gt;関数&lt;/a&gt;の詳細については、関数を参照）。したがって、どちらの場合も、左側の値は関数ではないため、エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="fe2f60cb62bba939fc1814f0702994179d2cc9fd" translate="yes" xml:space="preserve">
          <source>Both these implementations, although different, do essentially the same thing: a runtime loop over the dimensions of the array, collecting the offset in each dimension into the final index.</source>
          <target state="translated">これらの実装は異なりますが,基本的には同じことを行います:配列の次元の上でランタイムループを行い,各次元のオフセットを最終的なインデックスに集めます.</target>
        </trans-unit>
        <trans-unit id="9c695a21716f0561a4e4e8d8969c9a67ff3ac14a" translate="yes" xml:space="preserve">
          <source>Bottom Curly Bracket</source>
          <target state="translated">ボトムカーリーブラケット</target>
        </trans-unit>
        <trans-unit id="5c381cbda1ed56fa362cad0521e4ca378f6df12d" translate="yes" xml:space="preserve">
          <source>Bottom Left Corner</source>
          <target state="translated">左下隅</target>
        </trans-unit>
        <trans-unit id="8b91a1776362601aa94f5e511fc42880fb137818" translate="yes" xml:space="preserve">
          <source>Bottom Right Corner</source>
          <target state="translated">右下隅</target>
        </trans-unit>
        <trans-unit id="408cb2c9aacb6c00f4eea9f155e68230edfc13be" translate="yes" xml:space="preserve">
          <source>Bottom Square Bracket</source>
          <target state="translated">ボトムスクエアブラケット</target>
        </trans-unit>
        <trans-unit id="b587f4044bf50468cb606a8c8b879cf7bf3a57b0" translate="yes" xml:space="preserve">
          <source>Bottom Square Bracket Over Top Square Bracket</source>
          <target state="translated">ボトムスクエアブラケットオーバートップスクエアブラケット</target>
        </trans-unit>
        <trans-unit id="be63873217899f3efce2481a86c1d5a6e1aa9ff7" translate="yes" xml:space="preserve">
          <source>Bouquet</source>
          <target state="translated">Bouquet</target>
        </trans-unit>
        <trans-unit id="527e7050bb885ff38897eb7cbe0d818d6e05448e" translate="yes" xml:space="preserve">
          <source>Bowling</source>
          <target state="translated">Bowling</target>
        </trans-unit>
        <trans-unit id="df3f8f8f9dfd1bd2fca6e5c445d1a47fa385ede3" translate="yes" xml:space="preserve">
          <source>Bowtie</source>
          <target state="translated">Bowtie</target>
        </trans-unit>
        <trans-unit id="2365940089f0b35468618bed420a02ff8d78ea80" translate="yes" xml:space="preserve">
          <source>Box Drawings Light Diagonal Upper Left To Lower Right / Forms Light Diagonal Upper Left To Lower Right</source>
          <target state="translated">ボックスドローイング ライトダイアゴナル 左上から右下/フォーム ライトダイアゴナル 左上から右下へ</target>
        </trans-unit>
        <trans-unit id="510ae6748e0c9b114a5f8b83c8badc7f63a16bc0" translate="yes" xml:space="preserve">
          <source>Box Drawings Light Diagonal Upper Right To Lower Left / Forms Light Diagonal Upper Right To Lower Left</source>
          <target state="translated">ボックスドローイング ライト斜め上から左下へ/フォームズ ライト斜め上から左下へ</target>
        </trans-unit>
        <trans-unit id="12f6d098ab5b7193c3d26b08f696b2a980dca3f4" translate="yes" xml:space="preserve">
          <source>Box Drawings Light Triple Dash Vertical / Forms Light Triple Dash Vertical</source>
          <target state="translated">ボックスドローイングライト3連ダッシュ縦型/フォームライト3連ダッシュ縦型</target>
        </trans-unit>
        <trans-unit id="85230437c79e72b707969ab19fa9c93e520c40d0" translate="yes" xml:space="preserve">
          <source>Box Drawings Up Light And Left Heavy / Forms Up Light And Left Heavy</source>
          <target state="translated">ボックスドローイングアップライトとレフトヘビー/フォームアップライトとレフトヘビー</target>
        </trans-unit>
        <trans-unit id="b9dc9d8cb52edb821b0da78df2b6682eb917d791" translate="yes" xml:space="preserve">
          <source>Boy</source>
          <target state="translated">Boy</target>
        </trans-unit>
        <trans-unit id="c61eb5df5d78529f719e752eeef8ece81e0caaa8" translate="yes" xml:space="preserve">
          <source>Bread</source>
          <target state="translated">Bread</target>
        </trans-unit>
        <trans-unit id="67334b607f6cd61759a7703ce073645a7bb380d4" translate="yes" xml:space="preserve">
          <source>Break functions into multiple definitions</source>
          <target state="translated">機能を複数の定義に分ける</target>
        </trans-unit>
        <trans-unit id="8a10e4a625ea22134f5962dee4da949a99868e13" translate="yes" xml:space="preserve">
          <source>Break out of a loop immediately.</source>
          <target state="translated">すぐにループから抜け出す。</target>
        </trans-unit>
        <trans-unit id="392384778265e06187313603c1377439a8615e6f" translate="yes" xml:space="preserve">
          <source>Break the &lt;code&gt;ConfigEntry&lt;/code&gt; up to the following pieces: section, subsection, name, and value.</source>
          <target state="translated">ブレーク &lt;code&gt;ConfigEntry&lt;/code&gt; をセクション、サブセクション、名前、および値：次の作品まで。</target>
        </trans-unit>
        <trans-unit id="7632e2c1e249278468e77e6447234ae7607c5253" translate="yes" xml:space="preserve">
          <source>Breve / Spacing Breve</source>
          <target state="translated">ブリーブ/スペーシング ブリーブ</target>
        </trans-unit>
        <trans-unit id="daaf045cb7109dd158210ed8775987a60503bbb6" translate="yes" xml:space="preserve">
          <source>Bride With Veil</source>
          <target state="translated">ベールの花嫁</target>
        </trans-unit>
        <trans-unit id="4e7371d09f6498019117c2fcbb67ffe9a940c17f" translate="yes" xml:space="preserve">
          <source>Bridge At Night</source>
          <target state="translated">夜の橋</target>
        </trans-unit>
        <trans-unit id="ee60d60ea805fbda38f6f538481a92d3787df0b9" translate="yes" xml:space="preserve">
          <source>Brief description</source>
          <target state="translated">簡単な説明</target>
        </trans-unit>
        <trans-unit id="b11bca2ce38ace33f9cb3a0f0323440cce89dd0f" translate="yes" xml:space="preserve">
          <source>Briefcase</source>
          <target state="translated">Briefcase</target>
        </trans-unit>
        <trans-unit id="77ca3fc6500edac54d325df1bbb7ac8e363c54b5" translate="yes" xml:space="preserve">
          <source>Broadcast</source>
          <target state="translated">Broadcast</target>
        </trans-unit>
        <trans-unit id="5959941fc9ce31c144990539361b6855d239f922" translate="yes" xml:space="preserve">
          <source>Broadcast Styles</source>
          <target state="translated">放送スタイル</target>
        </trans-unit>
        <trans-unit id="cdaa679362eaad18a4a290d4b2177d1c9eddf091" translate="yes" xml:space="preserve">
          <source>Broadcast and vectorization</source>
          <target state="translated">放送とベクトル化</target>
        </trans-unit>
        <trans-unit id="7df7947bfeebee1e64e3a5fe7acfcbaa176cd869" translate="yes" xml:space="preserve">
          <source>Broadcast the function &lt;code&gt;f&lt;/code&gt; over the arrays, tuples, collections, &lt;a href=&quot;../c/index#Core.Ref&quot;&gt;&lt;code&gt;Ref&lt;/code&gt;&lt;/a&gt;s and/or scalars &lt;code&gt;As&lt;/code&gt;.</source>
          <target state="translated">関数 &lt;code&gt;f&lt;/code&gt; を配列、タプル、コレクション、&lt;a href=&quot;../c/index#Core.Ref&quot;&gt; &lt;code&gt;Ref&lt;/code&gt; &lt;/a&gt;、スカラー &lt;code&gt;As&lt;/code&gt; にブロードキャストします。</target>
        </trans-unit>
        <trans-unit id="074efe61b6453184efecedf79f56223cb3b56a06" translate="yes" xml:space="preserve">
          <source>Broadcast.@__dot__</source>
          <target state="translated">Broadcast.@__dot__</target>
        </trans-unit>
        <trans-unit id="d9974c014c3e7a0c286c1e54c44afebb2e5a2605" translate="yes" xml:space="preserve">
          <source>Broadcast.AbstractArrayStyle</source>
          <target state="translated">Broadcast.AbstractArrayStyle</target>
        </trans-unit>
        <trans-unit id="e479e2fec9cd8edd73518e3aa9d740af4ffed128" translate="yes" xml:space="preserve">
          <source>Broadcast.ArrayStyle</source>
          <target state="translated">Broadcast.ArrayStyle</target>
        </trans-unit>
        <trans-unit id="46b115d26f9c6f955c31e3892d4b89859d8782ab" translate="yes" xml:space="preserve">
          <source>Broadcast.BroadcastStyle</source>
          <target state="translated">Broadcast.BroadcastStyle</target>
        </trans-unit>
        <trans-unit id="dfd372b601ba77b3813f2634bb5fb9643c14c102" translate="yes" xml:space="preserve">
          <source>Broadcast.DefaultArrayStyle</source>
          <target state="translated">Broadcast.DefaultArrayStyle</target>
        </trans-unit>
        <trans-unit id="6969d3cd7b2ed2ce0f9a60fb4945dade93d4e117" translate="yes" xml:space="preserve">
          <source>Broadcast.broadcast!()</source>
          <target state="translated">Broadcast.broadcast!()</target>
        </trans-unit>
        <trans-unit id="2d33589d08eead5af3fe72a94a8b53b3373f4645" translate="yes" xml:space="preserve">
          <source>Broadcast.broadcast()</source>
          <target state="translated">Broadcast.broadcast()</target>
        </trans-unit>
        <trans-unit id="d8be6debc5bb7fb35ee9eb11d215775cae452707" translate="yes" xml:space="preserve">
          <source>Broadcast.broadcastable()</source>
          <target state="translated">Broadcast.broadcastable()</target>
        </trans-unit>
        <trans-unit id="48464259628c114acb1957dc941186fb95dc6984" translate="yes" xml:space="preserve">
          <source>Broadcast.combine_axes()</source>
          <target state="translated">Broadcast.combine_axes()</target>
        </trans-unit>
        <trans-unit id="65a7f7386144353a37453858bdd5ecb6ccb1274f" translate="yes" xml:space="preserve">
          <source>Broadcast.combine_styles()</source>
          <target state="translated">Broadcast.combine_styles()</target>
        </trans-unit>
        <trans-unit id="d36a0668f40c2a01499f97eb697585c01ce9b9ab" translate="yes" xml:space="preserve">
          <source>Broadcast.result_style()</source>
          <target state="translated">Broadcast.result_style()</target>
        </trans-unit>
        <trans-unit id="ba459229366746c447e3cdf752eb917433152cfe" translate="yes" xml:space="preserve">
          <source>Broadcasting</source>
          <target state="translated">Broadcasting</target>
        </trans-unit>
        <trans-unit id="0e83693fd8be7602fb86ef05c34ce5d03fd5fce4" translate="yes" xml:space="preserve">
          <source>Broadcasting applies the function &lt;code&gt;f&lt;/code&gt; over the elements of the container arguments and the scalars themselves in &lt;code&gt;As&lt;/code&gt;. Singleton and missing dimensions are expanded to match the extents of the other arguments by virtually repeating the value. By default, only a limited number of types are considered scalars, including &lt;code&gt;Number&lt;/code&gt;s, &lt;code&gt;String&lt;/code&gt;s, &lt;code&gt;Symbol&lt;/code&gt;s, &lt;code&gt;Type&lt;/code&gt;s, &lt;code&gt;Function&lt;/code&gt;s and some common singletons like &lt;a href=&quot;../base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt;. All other arguments are iterated over or indexed into elementwise.</source>
          <target state="translated">ブロードキャストでは、コンテナー引数の要素と &lt;code&gt;As&lt;/code&gt; のスカラー自体に関数 &lt;code&gt;f&lt;/code&gt; が適用されます。シングルトンと不足している次元は、値を仮想的に繰り返すことにより、他の引数の範囲と一致するように拡張されます。デフォルトでは、種類の限られた数を含む、スカラーとみなされる &lt;code&gt;Number&lt;/code&gt; 秒、 &lt;code&gt;String&lt;/code&gt; sの、 &lt;code&gt;Symbol&lt;/code&gt; S、 &lt;code&gt;Type&lt;/code&gt; S、 &lt;code&gt;Function&lt;/code&gt; 秒など、いくつかの一般的なシングルトン&lt;a href=&quot;../base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt;。他のすべての引数は、要素ごとに反復またはインデックス化されます。</target>
        </trans-unit>
        <trans-unit id="7b246945f4825122c3abc36d497da5fe651d872b" translate="yes" xml:space="preserve">
          <source>Broadcasting behavior of &lt;code&gt;SrcType&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;SrcType&lt;/code&gt; のブロードキャスト動作</target>
        </trans-unit>
        <trans-unit id="0e2fa4ca8541a569a98cefd4832f00fffb8a668a" translate="yes" xml:space="preserve">
          <source>Broadcasting of CartesianIndices requires at least Julia 1.1.</source>
          <target state="translated">CartesianIndicesの放送にはJulia 1.1以上が必要です。</target>
        </trans-unit>
        <trans-unit id="de4b71257ec056201227e217cf933d2e092cf0c7" translate="yes" xml:space="preserve">
          <source>Broken Bar / Broken Vertical Bar</source>
          <target state="translated">ブロークンバー/ブロークンバーティカルバー</target>
        </trans-unit>
        <trans-unit id="0d35795616ab98cd5aa59673de45c7c6c73a4a9c" translate="yes" xml:space="preserve">
          <source>Broken Heart</source>
          <target state="translated">ブロークンハート</target>
        </trans-unit>
        <trans-unit id="79b7916b0d6bd1fa29180da64a852f6051cdd3b6" translate="yes" xml:space="preserve">
          <source>Broken Tests</source>
          <target state="translated">壊れたテスト</target>
        </trans-unit>
        <trans-unit id="8cb75fd2f909d7fe2d9ebdd702d582785b35815a" translate="yes" xml:space="preserve">
          <source>Browser-based workflow</source>
          <target state="translated">ブラウザベースのワークフロー</target>
        </trans-unit>
        <trans-unit id="271befc09ec922fba884ac992f346efbaa84c1c6" translate="yes" xml:space="preserve">
          <source>Bug</source>
          <target state="translated">Bug</target>
        </trans-unit>
        <trans-unit id="a0ff1503de64d75563fdaa852cd66a5161072182" translate="yes" xml:space="preserve">
          <source>Build the output matrix as &lt;code&gt;similar(R, dims)&lt;/code&gt;, where &lt;code&gt;dims&lt;/code&gt; are the desired dimensions of the output array.</source>
          <target state="translated">&lt;code&gt;similar(R, dims)&lt;/code&gt; として出力行列を作成します。ここで、 &lt;code&gt;dims&lt;/code&gt; は出力配列の必要な次元です。</target>
        </trans-unit>
        <trans-unit id="9b68712d139bce25a7399715ee37cf5a89ca4787" translate="yes" xml:space="preserve">
          <source>Building a similar type with a different type parameter</source>
          <target state="translated">異なる型パラメータで類似の型を構築する</target>
        </trans-unit>
        <trans-unit id="472631cf7902fb6cb7b3cc2952c6a64c270752fa" translate="yes" xml:space="preserve">
          <source>Building an advanced macro</source>
          <target state="translated">高度なマクロの構築</target>
        </trans-unit>
        <trans-unit id="fe79fc1370416c81e94ca362477853ed355de172" translate="yes" xml:space="preserve">
          <source>Built-in &lt;code&gt;Exception&lt;/code&gt;s</source>
          <target state="translated">内蔵の &lt;code&gt;Exception&lt;/code&gt; S</target>
        </trans-unit>
        <trans-unit id="b98da0ccc81f4f734434572f19ccc66972aae344" translate="yes" xml:space="preserve">
          <source>Bullet</source>
          <target state="translated">Bullet</target>
        </trans-unit>
        <trans-unit id="b2e3c9a189a187c73db37aa7676051a963459c1a" translate="yes" xml:space="preserve">
          <source>Bullet Operator</source>
          <target state="translated">弾丸演算子</target>
        </trans-unit>
        <trans-unit id="ffb3a635db82436b5aade99cffc92370f3f7ed19" translate="yes" xml:space="preserve">
          <source>Bullseye</source>
          <target state="translated">Bullseye</target>
        </trans-unit>
        <trans-unit id="6380df8107fb2d9626efb1aee5cb211de2982cbd" translate="yes" xml:space="preserve">
          <source>Bunch-Kaufman (see &lt;a href=&quot;#LinearAlgebra.bunchkaufman&quot;&gt;&lt;code&gt;bunchkaufman&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">Bunch-Kaufman（&lt;a href=&quot;#LinearAlgebra.bunchkaufman&quot;&gt; &lt;code&gt;bunchkaufman&lt;/code&gt; を&lt;/a&gt;参照）</target>
        </trans-unit>
        <trans-unit id="d42c62a3c53679a83b69d0fce6f99bfd41a308aa" translate="yes" xml:space="preserve">
          <source>Bunch-Kaufman factorization</source>
          <target state="translated">ブンチカウフマン因数分解</target>
        </trans-unit>
        <trans-unit id="56070a568367d5a4e9970cfff19cb97578ce1361" translate="yes" xml:space="preserve">
          <source>Bus</source>
          <target state="translated">Bus</target>
        </trans-unit>
        <trans-unit id="de2d017d398674ca4eafe20ca3761f2f657234b8" translate="yes" xml:space="preserve">
          <source>Bus Stop</source>
          <target state="translated">バス停</target>
        </trans-unit>
        <trans-unit id="97d53e844a4148a55c4152e5e7736932ca111090" translate="yes" xml:space="preserve">
          <source>Bust In Silhouette</source>
          <target state="translated">シルエットのバスト</target>
        </trans-unit>
        <trans-unit id="45f0d298267aa05679aedb20cf6611cfa3d2a5d1" translate="yes" xml:space="preserve">
          <source>Busts In Silhouette</source>
          <target state="translated">シルエットのバスト</target>
        </trans-unit>
        <trans-unit id="e7a7510504bc122560ba5c8208e379522ff06902" translate="yes" xml:space="preserve">
          <source>But here is a thing you should pay attention to: suppose &lt;code&gt;x&lt;/code&gt; is bound to an object of type &lt;code&gt;Array&lt;/code&gt; (or any other &lt;em&gt;mutable&lt;/em&gt; type). From within the function, you cannot &quot;unbind&quot; &lt;code&gt;x&lt;/code&gt; from this Array, but you can change its content. For example:</source>
          <target state="translated">ただし、ここで注意すべき点があります &lt;code&gt;x&lt;/code&gt; が &lt;code&gt;Array&lt;/code&gt; 型（またはその他の&lt;em&gt;変更可能な&lt;/em&gt;型）のオブジェクトにバインドされているとします。関数内から、この配列から &lt;code&gt;x&lt;/code&gt; を「バインド解除」することはできませんが、その内容を変更することはできます。例えば：</target>
        </trans-unit>
        <trans-unit id="0adf28177ba73d224bb6721567052c88af510023" translate="yes" xml:space="preserve">
          <source>But how does one construct the first instance when no instance exists to provide as a valid value for its &lt;code&gt;obj&lt;/code&gt; field? The only solution is to allow creating an incompletely initialized instance of &lt;code&gt;SelfReferential&lt;/code&gt; with an unassigned &lt;code&gt;obj&lt;/code&gt; field, and using that incomplete instance as a valid value for the &lt;code&gt;obj&lt;/code&gt; field of another instance, such as, for example, itself.</source>
          <target state="translated">しかし、 &lt;code&gt;obj&lt;/code&gt; フィールドの有効な値として提供するインスタンスが存在しない場合、どのようにして最初のインスタンスを構築しますか？唯一の解決策は、未割り当ての &lt;code&gt;obj&lt;/code&gt; フィールドを使用して不完全に初期化された &lt;code&gt;SelfReferential&lt;/code&gt; のインスタンスを作成し、その不完全なインスタンスを別のインスタンス（たとえば、それ自体）の &lt;code&gt;obj&lt;/code&gt; フィールドの有効な値として使用できるようにすることです。</target>
        </trans-unit>
        <trans-unit id="64b3ab17aa40196bbbe2b14cd1e8633f165597c6" translate="yes" xml:space="preserve">
          <source>But in general, embedding projects will be more complicated than the above, and so the following allows general makefile support as well &amp;ndash; assuming GNU make because of the use of the &lt;strong&gt;shell&lt;/strong&gt; macro expansions. Additionally, though many times &lt;code&gt;julia-config.jl&lt;/code&gt; may be found in the directory &lt;code&gt;/usr/local&lt;/code&gt;, this is not necessarily the case, but Julia can be used to locate &lt;code&gt;julia-config.jl&lt;/code&gt; too, and the makefile can be used to take advantage of that. The above example is extended to use a Makefile:</source>
          <target state="translated">しかし、一般的に、プロジェクトの埋め込みは上記よりも複雑になるため、以下は一般的なmakefileのサポートも可能にします- &lt;strong&gt;シェル&lt;/strong&gt;マクロ展開の使用によりGNU makeを想定しています。さらに、多くの場合、 &lt;code&gt;julia-config.jl&lt;/code&gt; はディレクトリ &lt;code&gt;/usr/local&lt;/code&gt; にありますが、これは必ずしもそうとは限りませんが、Juliaを使用して &lt;code&gt;julia-config.jl&lt;/code&gt; を見つけることもでき、makefileを使用してその利点。上記の例は、Makefileを使用するように拡張されています。</target>
        </trans-unit>
        <trans-unit id="26a3e909feee0f8ba5a7fedacb473c7c1f12eb3d" translate="yes" xml:space="preserve">
          <source>But now let's say you want to write a function that creates a 3&amp;times;3&amp;times;... array in arbitrary dimensions; you might be tempted to write a function</source>
          <target state="translated">しかし、任意の次元で3&amp;times;3&amp;times;...配列を作成する関数を作成したいとしましょう。関数を作成したくなるかもしれません</target>
        </trans-unit>
        <trans-unit id="7e347dfe55eb3d3f84185c35ba67fdd467b54efe" translate="yes" xml:space="preserve">
          <source>But there's an exception: future calls to &lt;code&gt;newfun&lt;/code&gt;&lt;em&gt;from the REPL&lt;/em&gt; work as expected, being able to both see and call the new definition of &lt;code&gt;newfun&lt;/code&gt;.</source>
          <target state="translated">ただし、例外があります &lt;code&gt;newfun&lt;/code&gt; &lt;em&gt;からの&lt;/em&gt;newfunの今後の呼び出しは期待どおりに機能し、 &lt;code&gt;newfun&lt;/code&gt; の新しい定義を確認して呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="7dcbe9aaf1e0a6755fccfa933b76845ffa848937" translate="yes" xml:space="preserve">
          <source>But we are currently on the master thread. To check, we use the function &lt;a href=&quot;../../base/multi-threading/index#Base.Threads.threadid&quot;&gt;&lt;code&gt;Threads.threadid&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">しかし、現在はマスタースレッドを使用しています。確認するには、関数&lt;a href=&quot;../../base/multi-threading/index#Base.Threads.threadid&quot;&gt; &lt;code&gt;Threads.threadid&lt;/code&gt; &lt;/a&gt;を使用します</target>
        </trans-unit>
        <trans-unit id="c84f932b434e9c92f4f20cc3eb7ea04021d4d339" translate="yes" xml:space="preserve">
          <source>By convention, function names ending with an exclamation point (&lt;code&gt;!&lt;/code&gt;) modify their arguments. Some functions have both modifying (e.g., &lt;code&gt;sort!&lt;/code&gt;) and non-modifying (&lt;code&gt;sort&lt;/code&gt;) versions.</source>
          <target state="translated">慣例として、感嘆符（ &lt;code&gt;!&lt;/code&gt; ）で終わる関数名は引数を変更します。一部の関数には、変更（たとえば、 &lt;code&gt;sort!&lt;/code&gt; ）バージョンと非変更（ &lt;code&gt;sort&lt;/code&gt; ）バージョンの両方があります。</target>
        </trans-unit>
        <trans-unit id="b2d3b6d57737895d1e4453b18b72e5f94ecdeb4e" translate="yes" xml:space="preserve">
          <source>By convention, functions that modify their arguments have a &lt;code&gt;!&lt;/code&gt; at the end of the name, for example &lt;code&gt;push!&lt;/code&gt;.</source>
          <target state="translated">慣例により、引数を変更する関数には &lt;code&gt;!&lt;/code&gt; 名前の最後に、たとえば &lt;code&gt;push!&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ab2ce248423f04c77b0bad395e4714e39c7fb937" translate="yes" xml:space="preserve">
          <source>By default (&lt;code&gt;alpha = beta = 1&lt;/code&gt;), quantiles are computed via linear interpolation between the points &lt;code&gt;((k-1)/(n-1), v[k])&lt;/code&gt;, for &lt;code&gt;k = 1:n&lt;/code&gt; where &lt;code&gt;n = length(itr)&lt;/code&gt;. This corresponds to Definition 7 of Hyndman and Fan (1996), and is the same as the R and NumPy default.</source>
          <target state="translated">デフォルト（ &lt;code&gt;alpha = beta = 1&lt;/code&gt; ）では、分位数は、点 &lt;code&gt;((k-1)/(n-1), v[k])&lt;/code&gt; 間の線形補間によって計算されます &lt;code&gt;k = 1:n&lt;/code&gt; 、 &lt;code&gt;n = length(itr)&lt;/code&gt; 。これは、Hyndman and Fan（1996）の定義7に対応し、RおよびNumPyのデフォルトと同じです。</target>
        </trans-unit>
        <trans-unit id="760f93efed44d4a2ba0963c541f9ed0ec06bfb96" translate="yes" xml:space="preserve">
          <source>By default (&lt;code&gt;alpha = beta = 1&lt;/code&gt;), quantiles are computed via linear interpolation between the points &lt;code&gt;((k-1)/(n-1), v[k])&lt;/code&gt;, for &lt;code&gt;k = 1:n&lt;/code&gt; where &lt;code&gt;n = length(v)&lt;/code&gt;. This corresponds to Definition 7 of Hyndman and Fan (1996), and is the same as the R and NumPy default.</source>
          <target state="translated">デフォルト（ &lt;code&gt;alpha = beta = 1&lt;/code&gt; ）では、分位数は、点 &lt;code&gt;((k-1)/(n-1), v[k])&lt;/code&gt; 間の線形補間によって計算されます &lt;code&gt;k = 1:n&lt;/code&gt; 、 &lt;code&gt;n = length(v)&lt;/code&gt; 。これは、Hyndman and Fan（1996）の定義7に対応し、RおよびNumPyのデフォルトと同じです。</target>
        </trans-unit>
        <trans-unit id="04a501bd6222e05849ace3fea85fb677e79bd185" translate="yes" xml:space="preserve">
          <source>By default a worker will listen on a free port at the address returned by a call to &lt;a href=&quot;../../stdlib/sockets/index#Sockets.getipaddr&quot;&gt;&lt;code&gt;getipaddr()&lt;/code&gt;&lt;/a&gt;. A specific address to listen on may be specified by optional argument &lt;code&gt;--bind-to bind_addr[:port]&lt;/code&gt;. This is useful for multi-homed hosts.</source>
          <target state="translated">デフォルトでは、ワーカーは&lt;a href=&quot;../../stdlib/sockets/index#Sockets.getipaddr&quot;&gt; &lt;code&gt;getipaddr()&lt;/code&gt; の&lt;/a&gt;呼び出しによって返されたアドレスで空きポートをリッスンします。 &lt;code&gt;--bind-to bind_addr[:port]&lt;/code&gt; する特定のアドレスは、オプションの引数--bind-to bind_addr [：port]で指定できます。これは、マルチホームホストに役立ちます。</target>
        </trans-unit>
        <trans-unit id="cb670232f9c9a08075052bf52fba2ffbf6b303ba" translate="yes" xml:space="preserve">
          <source>By default all exceptions are caught to prevent log message generation from crashing the program. This lets users confidently toggle little-used functionality - such as debug logging - in a production system.</source>
          <target state="translated">デフォルトでは、ログメッセージの生成によるプログラムのクラッシュを防ぐために、すべての例外が捕捉されます。これにより、本番環境ではあまり使われていない機能(デバッグログなど)を自信を持って切り替えることができます。</target>
        </trans-unit>
        <trans-unit id="3274665bf281763d801f2b3f0f09acc363497f47" translate="yes" xml:space="preserve">
          <source>By default julia does not wait for the editor to close, running it in the background. However, if the editor is terminal based, you will probably want to set &lt;code&gt;wait=true&lt;/code&gt; and julia will wait for the editor to close before resuming.</source>
          <target state="translated">デフォルトでは、juliaはエディターが閉じるのを待たず、バックグラウンドで実行します。ただし、エディターがターミナルベースの場合は、 &lt;code&gt;wait=true&lt;/code&gt; を設定すると、juliaはエディターが閉じるのを待ってから再開します。</target>
        </trans-unit>
        <trans-unit id="d09501703ac8c23ae9a60cea7e5421daf3cd18b0" translate="yes" xml:space="preserve">
          <source>By default the &lt;code&gt;@testset&lt;/code&gt; macro will return the testset object itself, though this behavior can be customized in other testset types. If a &lt;code&gt;for&lt;/code&gt; loop is used then the macro collects and returns a list of the return values of the &lt;code&gt;finish&lt;/code&gt; method, which by default will return a list of the testset objects used in each iteration.</source>
          <target state="translated">デフォルトでは、 &lt;code&gt;@testset&lt;/code&gt; マクロはtestsetオブジェクト自体を返しますが、この動作は他のタイプのテストセットでカスタマイズできます。場合 &lt;code&gt;for&lt;/code&gt; ループは、マクロ収集を使用し、戻り値のリストを返している &lt;code&gt;finish&lt;/code&gt; デフォルトでTESTSETのリストが返される方法を、各反復で使用されるオブジェクト。</target>
        </trans-unit>
        <trans-unit id="62c321cdf328de0b934c0ed64ba600400a916f6d" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;pmap&lt;/code&gt; distributes the computation over all specified workers. To use only the local process and distribute over tasks, specify &lt;code&gt;distributed=false&lt;/code&gt;. This is equivalent to using &lt;a href=&quot;../../base/parallel/index#Base.asyncmap&quot;&gt;&lt;code&gt;asyncmap&lt;/code&gt;&lt;/a&gt;. For example, &lt;code&gt;pmap(f, c; distributed=false)&lt;/code&gt; is equivalent to &lt;code&gt;asyncmap(f,c; ntasks=()-&amp;gt;nworkers())&lt;/code&gt;</source>
          <target state="translated">デフォルトでは、 &lt;code&gt;pmap&lt;/code&gt; は指定されたすべてのワーカーに計算を分散します。ローカルプロセスのみを使用してタスクに &lt;code&gt;distributed=false&lt;/code&gt; するには、distributed = falseを指定します。これは、&lt;a href=&quot;../../base/parallel/index#Base.asyncmap&quot;&gt; &lt;code&gt;asyncmap&lt;/code&gt; &lt;/a&gt;を使用するのと同じです。たとえば、 &lt;code&gt;pmap(f, c; distributed=false)&lt;/code&gt; は &lt;code&gt;asyncmap(f,c; ntasks=()-&amp;gt;nworkers())&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="869bf1d13613c15994bb6c5a2998c89afa6bc5e7" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;readdir&lt;/code&gt; sorts the list of names it returns. If you want to skip sorting the names and get them in the order that the file system lists them, you can use &lt;code&gt;readir(dir, sort=false)&lt;/code&gt; to opt out of sorting.</source>
          <target state="translated">デフォルトでは、 &lt;code&gt;readdir&lt;/code&gt; は返す名前のリストをソートします。名前の並べ替えをスキップして、ファイルシステムにリストされている順序で名前を取得する場合は、 &lt;code&gt;readir(dir, sort=false)&lt;/code&gt; を使用して並べ替えをオプトアウトできます。</target>
        </trans-unit>
        <trans-unit id="1f89fa8608376528e1d0c826b9825a253fbd041b" translate="yes" xml:space="preserve">
          <source>By default, Fortran compilers &lt;a href=&quot;https://en.wikipedia.org/wiki/Name_mangling#Fortran&quot;&gt;generate mangled names&lt;/a&gt; (for example, converting function names to lowercase or uppercase, often appending an underscore), and so to call a Fortran function via &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; you must pass the mangled identifier corresponding to the rule followed by your Fortran compiler. Also, when calling a Fortran function, all inputs must be passed as pointers to allocated values on the heap or stack. This applies not only to arrays and other mutable objects which are normally heap-allocated, but also to scalar values such as integers and floats which are normally stack-allocated and commonly passed in registers when using C or Julia calling conventions.</source>
          <target state="translated">デフォルトでは、Fortranコンパイラー&lt;a href=&quot;https://en.wikipedia.org/wiki/Name_mangling#Fortran&quot;&gt;はマングル名を生成します&lt;/a&gt;（たとえば、関数名を小文字または大文字に変換し、多くの場合アンダースコアを追加します）。したがって、&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt;を介してFortran関数を呼び出すには、Fortranコンパイラーが従う規則に対応するマングルIDを渡す必要があります。また、Fortran関数を呼び出すときは、すべての入力を、ヒープまたはスタック上の割り当てられた値へのポインターとして渡す必要があります。これは、通常はヒープに割り当てられる配列やその他の可変オブジェクトだけでなく、通常はスタックに割り当てられ、CまたはJuliaの呼び出し規則を使用するときにレジスタに通常渡される整数や浮動小数点などのスカラー値にも適用されます。</target>
        </trans-unit>
        <trans-unit id="7b4db9ff202a42835afe09d8709e3f5d83b19913" translate="yes" xml:space="preserve">
          <source>By default, Julia returns &lt;code&gt;BitArrays&lt;/code&gt; from &lt;a href=&quot;../../manual/arrays/index#Broadcasting&quot;&gt;broadcasting&lt;/a&gt; operations that generate boolean elements (including dotted-comparisons like &lt;code&gt;.==&lt;/code&gt;) as well as from the functions &lt;a href=&quot;#Base.trues&quot;&gt;&lt;code&gt;trues&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Base.falses&quot;&gt;&lt;code&gt;falses&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">デフォルトでは、ジュリアは返し &lt;code&gt;BitArrays&lt;/code&gt; から&lt;a href=&quot;../../manual/arrays/index#Broadcasting&quot;&gt;放送&lt;/a&gt;ブール要素生成動作（のようなドット付き比較を含むが &lt;code&gt;.==&lt;/code&gt; ）ならびに関数から&lt;a href=&quot;#Base.trues&quot;&gt; &lt;code&gt;trues&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;#Base.falses&quot;&gt; &lt;code&gt;falses&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="97954da2a37348f9b604be87e49342f9bb3f535a" translate="yes" xml:space="preserve">
          <source>By default, Julia returns &lt;code&gt;BitArrays&lt;/code&gt; from &lt;a href=&quot;../../manual/arrays/index#Broadcasting-1&quot;&gt;broadcasting&lt;/a&gt; operations that generate boolean elements (including dotted-comparisons like &lt;code&gt;.==&lt;/code&gt;) as well as from the functions &lt;a href=&quot;#Base.trues&quot;&gt;&lt;code&gt;trues&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Base.falses&quot;&gt;&lt;code&gt;falses&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">デフォルトでは、ジュリアは返し &lt;code&gt;BitArrays&lt;/code&gt; から&lt;a href=&quot;../../manual/arrays/index#Broadcasting-1&quot;&gt;放送&lt;/a&gt;ブール要素生成動作（のようなドット付き比較を含むが &lt;code&gt;.==&lt;/code&gt; ）ならびに関数から&lt;a href=&quot;#Base.trues&quot;&gt; &lt;code&gt;trues&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;#Base.falses&quot;&gt; &lt;code&gt;falses&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b61e736cef16f73d649bec40a1cb5e23234e0fb3" translate="yes" xml:space="preserve">
          <source>By default, Julia starts up with a single thread of execution. This can be verified by using the command &lt;a href=&quot;../../base/multi-threading/index#Base.Threads.nthreads&quot;&gt;&lt;code&gt;Threads.nthreads()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">デフォルトでは、Juliaは単一の実行スレッドで起動します。これは、&lt;a href=&quot;../../base/multi-threading/index#Base.Threads.nthreads&quot;&gt; &lt;code&gt;Threads.nthreads()&lt;/code&gt; &lt;/a&gt;コマンドを使用して確認できます。</target>
        </trans-unit>
        <trans-unit id="a32e1e323d14dc3db4577d3f3c64972051fa6f1a" translate="yes" xml:space="preserve">
          <source>By default, the &lt;code&gt;redisplay&lt;/code&gt; functions simply call &lt;a href=&quot;#Base.Multimedia.display&quot;&gt;&lt;code&gt;display&lt;/code&gt;&lt;/a&gt;. However, some display backends may override &lt;code&gt;redisplay&lt;/code&gt; to modify an existing display of &lt;code&gt;x&lt;/code&gt; (if any). Using &lt;code&gt;redisplay&lt;/code&gt; is also a hint to the backend that &lt;code&gt;x&lt;/code&gt; may be redisplayed several times, and the backend may choose to defer the display until (for example) the next interactive prompt.</source>
          <target state="translated">デフォルトでは、 &lt;code&gt;redisplay&lt;/code&gt; 関数は単に&lt;a href=&quot;#Base.Multimedia.display&quot;&gt; &lt;code&gt;display&lt;/code&gt; を&lt;/a&gt;呼び出します。ただし、一部のディスプレイバックエンドは、 &lt;code&gt;x&lt;/code&gt; の既存の表示（存在する場合）を変更するためにredisplayをオーバーライド &lt;code&gt;redisplay&lt;/code&gt; 場合があります。 &lt;code&gt;redisplay&lt;/code&gt; の使用は、 &lt;code&gt;x&lt;/code&gt; が数回再表示される可能性があることをバックエンドに知らせるヒントでもあり、バックエンドは（たとえば）次の対話型プロンプトまで表示を延期することを選択できます。</target>
        </trans-unit>
        <trans-unit id="3a789ab7e78cdd1c9fcc76d1aa6c29cc8860d633" translate="yes" xml:space="preserve">
          <source>By default, the eigenvalues and vectors are sorted lexicographically by &lt;code&gt;(real(&amp;lambda;),imag(&amp;lambda;))&lt;/code&gt;. A different comparison function &lt;code&gt;by(&amp;lambda;)&lt;/code&gt; can be passed to &lt;code&gt;sortby&lt;/code&gt;, or you can pass &lt;code&gt;sortby=nothing&lt;/code&gt; to leave the eigenvalues in an arbitrary order. Some special matrix types (e.g. &lt;a href=&quot;#LinearAlgebra.Diagonal&quot;&gt;&lt;code&gt;Diagonal&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#LinearAlgebra.SymTridiagonal&quot;&gt;&lt;code&gt;SymTridiagonal&lt;/code&gt;&lt;/a&gt;) may implement their own sorting convention and not accept a &lt;code&gt;sortby&lt;/code&gt; keyword.</source>
          <target state="translated">デフォルトでは、固有値とベクトルは辞書式順序で &lt;code&gt;(real(&amp;lambda;),imag(&amp;lambda;))&lt;/code&gt; によってソートされます。別の比較関数 &lt;code&gt;by(&amp;lambda;)&lt;/code&gt; を &lt;code&gt;sortby&lt;/code&gt; に渡すか、 &lt;code&gt;sortby=nothing&lt;/code&gt; を渡して固有値を任意の順序で残すことができます。一部の特殊な行列タイプ（&lt;a href=&quot;#LinearAlgebra.Diagonal&quot;&gt; &lt;code&gt;Diagonal&lt;/code&gt; &lt;/a&gt;や&lt;a href=&quot;#LinearAlgebra.SymTridiagonal&quot;&gt; &lt;code&gt;SymTridiagonal&lt;/code&gt; など&lt;/a&gt;）は、独自の並べ替え規則を実装し、 &lt;code&gt;sortby&lt;/code&gt; キーワードを受け入れない場合があります。</target>
        </trans-unit>
        <trans-unit id="2434a57ba6bd0a71b3ac08a278b454d4192e915f" translate="yes" xml:space="preserve">
          <source>By default, the eigenvalues and vectors are sorted lexicographically by &lt;code&gt;(real(&amp;lambda;),imag(&amp;lambda;))&lt;/code&gt;. A different comparison function &lt;code&gt;by(&amp;lambda;)&lt;/code&gt; can be passed to &lt;code&gt;sortby&lt;/code&gt;, or you can pass &lt;code&gt;sortby=nothing&lt;/code&gt; to leave the eigenvalues in an arbitrary order. Some special matrix types (e.g. &lt;code&gt;Diagonal&lt;/code&gt; or &lt;code&gt;SymTridiagonal&lt;/code&gt;) may implement their own sorting convention and not accept a &lt;code&gt;sortby&lt;/code&gt; keyword.</source>
          <target state="translated">デフォルトでは、固有値とベクトルは &lt;code&gt;(real(&amp;lambda;),imag(&amp;lambda;))&lt;/code&gt; によって辞書式にソートされます。別の比較関数 &lt;code&gt;by(&amp;lambda;)&lt;/code&gt; を &lt;code&gt;sortby&lt;/code&gt; に渡すこと &lt;code&gt;sortby=nothing&lt;/code&gt; 、sortby = nothingを渡して任意の順序で固有値を残すこともできます。一部の特殊なマトリックスタイプ（ &lt;code&gt;Diagonal&lt;/code&gt; や &lt;code&gt;SymTridiagonal&lt;/code&gt; など）は、独自の並べ替え規則を実装して、 &lt;code&gt;sortby&lt;/code&gt; キーワードを受け入れない場合があります。</target>
        </trans-unit>
        <trans-unit id="2a1522d8655f0697d6a68319f9a29fb0897d5118" translate="yes" xml:space="preserve">
          <source>By default, the relative tolerance &lt;code&gt;rtol&lt;/code&gt; is &lt;code&gt;n*ϵ&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the size of the smallest dimension of &lt;code&gt;M&lt;/code&gt;, and &lt;code&gt;ϵ&lt;/code&gt; is the &lt;a href=&quot;../dates/index#Base.eps&quot;&gt;&lt;code&gt;eps&lt;/code&gt;&lt;/a&gt; of the element type of &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">デフォルトでは、相対許容 &lt;code&gt;rtol&lt;/code&gt; ある &lt;code&gt;n*ϵ&lt;/code&gt; 、 &lt;code&gt;n&lt;/code&gt; の最小寸法のサイズである &lt;code&gt;M&lt;/code&gt; 、および &lt;code&gt;ϵ&lt;/code&gt; ある&lt;a href=&quot;../dates/index#Base.eps&quot;&gt; &lt;code&gt;eps&lt;/code&gt; &lt;/a&gt;の要素型の &lt;code&gt;M&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="36562c471751aaedc6db712652b89541573e3bb4" translate="yes" xml:space="preserve">
          <source>By extension any odd number of backticks may be used to enclose a lesser number of backticks.</source>
          <target state="translated">拡張により、任意の奇数のバックティックは、より少ない数のバックティックを囲むために使用することができます。</target>
        </trans-unit>
        <trans-unit id="300c0d12698af77dc8e2c084d058d532e1315b6c" translate="yes" xml:space="preserve">
          <source>By printing the array, one can verify that the elements of &lt;code&gt;x&lt;/code&gt; are now reversed.</source>
          <target state="translated">配列を出力することにより、 &lt;code&gt;x&lt;/code&gt; の要素が逆になっていることを確認できます。</target>
        </trans-unit>
        <trans-unit id="760e88f232085bdc1aa9ba910e6eb19bee1e689b" translate="yes" xml:space="preserve">
          <source>By running &quot;infrequently&quot; there is very little performance overhead; while profiling, your code can run at nearly native speed.</source>
          <target state="translated">infrequently」を実行することで、パフォーマンスのオーバーヘッドはほとんどありません。</target>
        </trans-unit>
        <trans-unit id="95b6f4faddfdd9853ff8e907fd6f47265a9f07a0" translate="yes" xml:space="preserve">
          <source>By using an RNG parameter initialized with a given seed, you can reproduce the same pseudorandom number sequence when running your program multiple times. However, a minor release of Julia (e.g. 1.3 to 1.4) &lt;em&gt;may change&lt;/em&gt; the sequence of pseudorandom numbers generated from a specific seed. (Even if the sequence produced by a low-level function like &lt;a href=&quot;#Base.rand&quot;&gt;&lt;code&gt;rand&lt;/code&gt;&lt;/a&gt; does not change, the output of higher-level functions like &lt;a href=&quot;#Random.randsubseq&quot;&gt;&lt;code&gt;randsubseq&lt;/code&gt;&lt;/a&gt; may change due to algorithm updates.) Rationale: guaranteeing that pseudorandom streams never change prohibits many algorithmic improvements.</source>
          <target state="translated">特定のシードで初期化されたRNGパラメータを使用することにより、プログラムを複数回実行するときに同じ疑似乱数シーケンスを再現できます。ただし、Juliaのマイナーリリース（1.3から1.4など）では、特定のシードから生成される疑似乱数のシーケンス&lt;em&gt;が変更さ&lt;/em&gt;れる&lt;em&gt;場合が&lt;/em&gt;あります。（&lt;a href=&quot;#Base.rand&quot;&gt; &lt;code&gt;rand&lt;/code&gt; の&lt;/a&gt;ような低レベル関数によって生成されたシーケンスが変更されない場合でも、&lt;a href=&quot;#Random.randsubseq&quot;&gt; &lt;code&gt;randsubseq&lt;/code&gt; の&lt;/a&gt;ような高レベル関数の出力は、アルゴリズムの更新により変更される可能性があります。）理論的根拠：疑似ランダムストリームが変更されないことを保証すると、多くのアルゴリズムの改善が禁止されます。</target>
        </trans-unit>
        <trans-unit id="f24780bfad6073c3cb5039801b32f126d34c1cde" translate="yes" xml:space="preserve">
          <source>Byte Array Literals</source>
          <target state="translated">バイト配列リテラル</target>
        </trans-unit>
        <trans-unit id="c950fe9e51a4a280dd4bb58c0d0951450fe7bbf3" translate="yes" xml:space="preserve">
          <source>C &lt;strong&gt;MUST NOT&lt;/strong&gt; modify the memory returned via &lt;code&gt;Ref{T}&lt;/code&gt; if &lt;code&gt;T&lt;/code&gt; is an &lt;code&gt;isbits&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; が &lt;code&gt;isbits&lt;/code&gt; 型の場合、C &lt;strong&gt;は&lt;/strong&gt; &lt;code&gt;Ref{T}&lt;/code&gt; を介して返されるメモリを変更しては&lt;strong&gt;なりません&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a10776e7bb2378d8306c9c38209f9a25bdd03a13" translate="yes" xml:space="preserve">
          <source>C Bischof and C Van Loan, &quot;The WY representation for products of Householder matrices&quot;, SIAM J Sci Stat Comput 8 (1987), s2-s13. &lt;a href=&quot;https://doi.org/10.1137/0908009&quot;&gt;doi:10.1137/0908009&lt;/a&gt;</source>
          <target state="translated">C BischofおよびC Van Loan、「ハウスホルダーマトリックスの製品のWY表現」、SIAM J Sci Stat Comput 8（1987）、s2-s13。&lt;a href=&quot;https://doi.org/10.1137/0908009&quot;&gt;doi：10.1137 / 0908009&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e9a1acddb6f4bd40edd805612e996267e826e064" translate="yes" xml:space="preserve">
          <source>C Interface</source>
          <target state="translated">Cインタフェース</target>
        </trans-unit>
        <trans-unit id="6592ddb6b4a1a593e3571fb32f8e7a37a9f3a350" translate="yes" xml:space="preserve">
          <source>C Standard Library</source>
          <target state="translated">C標準ライブラリ</target>
        </trans-unit>
        <trans-unit id="3a8599236e86a8cb6d00c7c55845e656c7c05673" translate="yes" xml:space="preserve">
          <source>C Wrapper Examples</source>
          <target state="translated">Cラッパーの例</target>
        </trans-unit>
        <trans-unit id="94e127f5f8d00244c8e1c9f0ff88de5ec4ac1783" translate="yes" xml:space="preserve">
          <source>C function pointer for &lt;code&gt;credentials_callback&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;credentials_callback&lt;/code&gt; の C関数ポインター</target>
        </trans-unit>
        <trans-unit id="c33ee7fd9016392ef47ce064a1a8200fb287dc56" translate="yes" xml:space="preserve">
          <source>C function pointer for &lt;code&gt;fetchhead_foreach_callback&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;fetchhead_foreach_callback&lt;/code&gt; の C関数ポインター</target>
        </trans-unit>
        <trans-unit id="bf80fd7e58e3463df2196d9d8b7daa3fb24795de" translate="yes" xml:space="preserve">
          <source>C function pointer for &lt;code&gt;mirror_callback&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;mirror_callback&lt;/code&gt; の C関数ポインター</target>
        </trans-unit>
        <trans-unit id="5cb63f576281637ef8721a44852ed39bd47bda3e" translate="yes" xml:space="preserve">
          <source>C functions that take an argument of the type &lt;code&gt;char**&lt;/code&gt; can be called by using a &lt;code&gt;Ptr{Ptr{UInt8}}&lt;/code&gt; type within Julia. For example, C functions of the form:</source>
          <target state="translated">&lt;code&gt;char**&lt;/code&gt; 型の引数を取るC関数は、Julia内で &lt;code&gt;Ptr{Ptr{UInt8}}&lt;/code&gt; 型を使用して呼び出すことができます。たとえば、次の形式のC関数：</target>
        </trans-unit>
        <trans-unit id="eb931938945d732d0cc3c0bc381f1e2e03fc8a86" translate="yes" xml:space="preserve">
          <source>C functions that take an argument of type &lt;code&gt;char**&lt;/code&gt; can be called by using a &lt;code&gt;Ptr{Ptr{UInt8}}&lt;/code&gt; type within Julia. For example, C functions of the form:</source>
          <target state="translated">&lt;code&gt;char**&lt;/code&gt; 型の引数を取るC関数は、Julia内で &lt;code&gt;Ptr{Ptr{UInt8}}&lt;/code&gt; 型を使用して呼び出すことができます。たとえば、次の形式のC関数：</target>
        </trans-unit>
        <trans-unit id="272eaa6fb30cbc6d678d9c3342e07f66e1c123e0" translate="yes" xml:space="preserve">
          <source>C name</source>
          <target state="translated">C名</target>
        </trans-unit>
        <trans-unit id="315194526a16e46e96fc7a6c9fe2f734e368a015" translate="yes" xml:space="preserve">
          <source>C shell on Linux/macOS, CMD on Windows:</source>
          <target state="translated">Linux/macOSではCシェル、WindowsではCMD。</target>
        </trans-unit>
        <trans-unit id="fc2b4216164cfb01ac45112054b3fedda8b56c86" translate="yes" xml:space="preserve">
          <source>C++</source>
          <target state="translated">C++</target>
        </trans-unit>
        <trans-unit id="7877de4c10096f42fa8b542b38a0c8abfeff2993" translate="yes" xml:space="preserve">
          <source>CFunction</source>
          <target state="translated">CFunction</target>
        </trans-unit>
        <trans-unit id="d6deb7587f97d7c2e002671a4a7ec9c17092aa98" translate="yes" xml:space="preserve">
          <source>CRC32c</source>
          <target state="translated">CRC32c</target>
        </trans-unit>
        <trans-unit id="946e46ea933373d5acfe718ba4c46ff0c631d8da" translate="yes" xml:space="preserve">
          <source>C_NULL</source>
          <target state="translated">C_NULL</target>
        </trans-unit>
        <trans-unit id="062c01810c7f050347900909c2a5c905fb7f6b61" translate="yes" xml:space="preserve">
          <source>Caches credential information for re-use</source>
          <target state="translated">再利用のためのクレデンシャル情報をキャッシュ</target>
        </trans-unit>
        <trans-unit id="9f296c645c05d20e8d397ba3c6535ccc69ae356d" translate="yes" xml:space="preserve">
          <source>Caching of native pointers.</source>
          <target state="translated">ネイティブポインタのキャッシュ。</target>
        </trans-unit>
        <trans-unit id="ffbcb973995142c82bf466dc886625f88d2fbcf8" translate="yes" xml:space="preserve">
          <source>Cactus</source>
          <target state="translated">Cactus</target>
        </trans-unit>
        <trans-unit id="ac32f232b7ff982020ec20b1d05cbfe41644842d" translate="yes" xml:space="preserve">
          <source>Calculate the matrix-matrix product $AB$, overwriting &lt;code&gt;A&lt;/code&gt;, and return the result.</source>
          <target state="translated">行列と行列の積$ AB $を計算し、 &lt;code&gt;A&lt;/code&gt; を上書きして、結果を返します。</target>
        </trans-unit>
        <trans-unit id="129c66daa23d40a052d78c17325451f781f1cd27" translate="yes" xml:space="preserve">
          <source>Calculate the matrix-matrix product $AB$, overwriting &lt;code&gt;A&lt;/code&gt;, and return the result. Here, &lt;code&gt;B&lt;/code&gt; must be of special matrix type, like, e.g., &lt;a href=&quot;#LinearAlgebra.Diagonal&quot;&gt;&lt;code&gt;Diagonal&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#LinearAlgebra.UpperTriangular&quot;&gt;&lt;code&gt;UpperTriangular&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#LinearAlgebra.LowerTriangular&quot;&gt;&lt;code&gt;LowerTriangular&lt;/code&gt;&lt;/a&gt;, or of some orthogonal type, see &lt;a href=&quot;#LinearAlgebra.QR&quot;&gt;&lt;code&gt;QR&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">行列-行列積$ AB $を計算し、 &lt;code&gt;A&lt;/code&gt; を上書きして、結果を返します。ここで、 &lt;code&gt;B&lt;/code&gt; は、例えば、のような、特殊なマトリクス型である必要があります&lt;a href=&quot;#LinearAlgebra.Diagonal&quot;&gt; &lt;code&gt;Diagonal&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#LinearAlgebra.UpperTriangular&quot;&gt; &lt;code&gt;UpperTriangular&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;#LinearAlgebra.LowerTriangular&quot;&gt; &lt;code&gt;LowerTriangular&lt;/code&gt; &lt;/a&gt;、またはいくつかの直交型で、参照&lt;a href=&quot;#LinearAlgebra.QR&quot;&gt; &lt;code&gt;QR&lt;/code&gt; を&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4d41dc1e33975c5f259e3c41e3a555f7d4e2007c" translate="yes" xml:space="preserve">
          <source>Calculate the matrix-matrix product $AB$, overwriting &lt;code&gt;B&lt;/code&gt;, and return the result.</source>
          <target state="translated">行列と行列の積$ AB $を計算し、 &lt;code&gt;B&lt;/code&gt; を上書きして、結果を返します。</target>
        </trans-unit>
        <trans-unit id="f409cbcda5b59decdd240fd1a21ee0be89005565" translate="yes" xml:space="preserve">
          <source>Calculate the matrix-matrix product $AB$, overwriting &lt;code&gt;B&lt;/code&gt;, and return the result. Here, &lt;code&gt;A&lt;/code&gt; must be of special matrix type, like, e.g., &lt;a href=&quot;#LinearAlgebra.Diagonal&quot;&gt;&lt;code&gt;Diagonal&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#LinearAlgebra.UpperTriangular&quot;&gt;&lt;code&gt;UpperTriangular&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#LinearAlgebra.LowerTriangular&quot;&gt;&lt;code&gt;LowerTriangular&lt;/code&gt;&lt;/a&gt;, or of some orthogonal type, see &lt;a href=&quot;#LinearAlgebra.QR&quot;&gt;&lt;code&gt;QR&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">行列-行列積$ AB $を計算し、 &lt;code&gt;B&lt;/code&gt; を上書きして、結果を返します。ここで、 &lt;code&gt;A&lt;/code&gt; は、例えば、のような、特殊なマトリクス型である必要があります&lt;a href=&quot;#LinearAlgebra.Diagonal&quot;&gt; &lt;code&gt;Diagonal&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#LinearAlgebra.UpperTriangular&quot;&gt; &lt;code&gt;UpperTriangular&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;#LinearAlgebra.LowerTriangular&quot;&gt; &lt;code&gt;LowerTriangular&lt;/code&gt; &lt;/a&gt;参照、またはいくつかの直交型の&lt;a href=&quot;#LinearAlgebra.QR&quot;&gt; &lt;code&gt;QR&lt;/code&gt; を&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1c95fa1680ff9d2f9d27d1192e3762d37dafb02b" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;-x&lt;/code&gt;, checking for overflow errors where applicable. For example, standard two's complement signed integers (e.g. &lt;code&gt;Int&lt;/code&gt;) cannot represent &lt;code&gt;-typemin(Int)&lt;/code&gt;, thus leading to an overflow.</source>
          <target state="translated">&lt;code&gt;-x&lt;/code&gt; を計算し、該当する場合はオーバーフローエラーをチェックします。たとえば、標準の2の補数の符号付き整数（ &lt;code&gt;Int&lt;/code&gt; など）は &lt;code&gt;-typemin(Int)&lt;/code&gt; を表すことができないため、オーバーフローが発生します。</target>
        </trans-unit>
        <trans-unit id="6167c036f7bc22425fe096ac27be440fe0ac62c7" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;abs(x)&lt;/code&gt;, checking for overflow errors where applicable. For example, standard two's complement signed integers (e.g. &lt;code&gt;Int&lt;/code&gt;) cannot represent &lt;code&gt;abs(typemin(Int))&lt;/code&gt;, thus leading to an overflow.</source>
          <target state="translated">&lt;code&gt;abs(x)&lt;/code&gt; を計算し、該当する場合はオーバーフローエラーをチェックします。たとえば、標準の2の補数の符号付き整数（ &lt;code&gt;Int&lt;/code&gt; など）は &lt;code&gt;abs(typemin(Int))&lt;/code&gt; を表すことができないため、オーバーフローが発生します。</target>
        </trans-unit>
        <trans-unit id="28790cf90cf177147936302a9d1094b853b086f9" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;cld(x,y)&lt;/code&gt;, checking for overflow errors where applicable.</source>
          <target state="translated">&lt;code&gt;cld(x,y)&lt;/code&gt; 計算し、該当する場合はオーバーフローエラーをチェックします。</target>
        </trans-unit>
        <trans-unit id="4c05dcdfe5d48ed5364bba76a8d88216a7900800" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;div(x,y)&lt;/code&gt;, checking for overflow errors where applicable.</source>
          <target state="translated">&lt;code&gt;div(x,y)&lt;/code&gt; 計算し、該当する場合はオーバーフローエラーをチェックします。</target>
        </trans-unit>
        <trans-unit id="a3d2d9753cdcfd6dd922be36bbcacaaf32453196" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;fld(x,y)&lt;/code&gt;, checking for overflow errors where applicable.</source>
          <target state="translated">&lt;code&gt;fld(x,y)&lt;/code&gt; 計算し、該当する場合はオーバーフローエラーをチェックします。</target>
        </trans-unit>
        <trans-unit id="2c843612cbe327e35009726e8d036ba9b466e318" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;mod(x,y)&lt;/code&gt;, checking for overflow errors where applicable.</source>
          <target state="translated">&lt;code&gt;mod(x,y)&lt;/code&gt; 計算し、該当する場合はオーバーフローエラーをチェックします。</target>
        </trans-unit>
        <trans-unit id="3ff6965bc32424b3a4e9ae967a2b78b31c8687be" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;r = x*y&lt;/code&gt;, with the flag &lt;code&gt;f&lt;/code&gt; indicating whether overflow has occurred.</source>
          <target state="translated">&lt;code&gt;r = x*y&lt;/code&gt; 計算します。フラグ &lt;code&gt;f&lt;/code&gt; は、オーバーフローが発生したかどうかを示します。</target>
        </trans-unit>
        <trans-unit id="31af4e89c705ea1b47696c4b34bfb97a778c9f15" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;r = x+y&lt;/code&gt;, with the flag &lt;code&gt;f&lt;/code&gt; indicating whether overflow has occurred.</source>
          <target state="translated">オーバーフローが発生したかどうかを示すフラグ &lt;code&gt;f&lt;/code&gt; を使用して、 &lt;code&gt;r = x+y&lt;/code&gt; 計算します。</target>
        </trans-unit>
        <trans-unit id="fd998eb3f6f3e0335eab6ff45b9ad97358dd0ca0" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;r = x-y&lt;/code&gt;, with the flag &lt;code&gt;f&lt;/code&gt; indicating whether overflow has occurred.</source>
          <target state="translated">&lt;code&gt;r = x-y&lt;/code&gt; 計算します。フラグ &lt;code&gt;f&lt;/code&gt; は、オーバーフローが発生したかどうかを示します。</target>
        </trans-unit>
        <trans-unit id="efdf3f45f374c38b59fd728eaad712d7890f84ff" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;x%y&lt;/code&gt;, checking for overflow errors where applicable.</source>
          <target state="translated">&lt;code&gt;x%y&lt;/code&gt; を計算し、該当する場合はオーバーフローエラーをチェックします。</target>
        </trans-unit>
        <trans-unit id="08676bba541f171d54d453c583476f048c4309ad" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;x*y&lt;/code&gt;, checking for overflow errors where applicable.</source>
          <target state="translated">&lt;code&gt;x*y&lt;/code&gt; を計算し、該当する場合はオーバーフローエラーをチェックします。</target>
        </trans-unit>
        <trans-unit id="dd10e9d48c83e327a775e0dc3fbaa5b8a6d8c773" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;x+y&lt;/code&gt;, checking for overflow errors where applicable.</source>
          <target state="translated">&lt;code&gt;x+y&lt;/code&gt; を計算し、該当する場合はオーバーフローエラーをチェックします。</target>
        </trans-unit>
        <trans-unit id="7bc22057d7126532dbb6ba4068b470e14e78325a" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;x-y&lt;/code&gt;, checking for overflow errors where applicable.</source>
          <target state="translated">&lt;code&gt;x-y&lt;/code&gt; 計算し、該当する場合はオーバーフローエラーをチェックします。</target>
        </trans-unit>
        <trans-unit id="aba6566e0673d1e53c249760fa025027d921398e" translate="yes" xml:space="preserve">
          <source>Calculates the matrix-matrix or matrix-vector product $AB$ and stores the result in &lt;code&gt;Y&lt;/code&gt;, overwriting the existing value of &lt;code&gt;Y&lt;/code&gt;. Note that &lt;code&gt;Y&lt;/code&gt; must not be aliased with either &lt;code&gt;A&lt;/code&gt; or &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">マトリックスマトリックスまたは行列ベクトル積$ AB $格納結果を算出 &lt;code&gt;Y&lt;/code&gt; の既存の値が上書き、 &lt;code&gt;Y&lt;/code&gt; を。 &lt;code&gt;Y&lt;/code&gt; には &lt;code&gt;A&lt;/code&gt; または &lt;code&gt;B&lt;/code&gt; のエイリアスを設定しないでください。</target>
        </trans-unit>
        <trans-unit id="adab5090ac6a1b7b5420faac7be86c41721ba27c" translate="yes" xml:space="preserve">
          <source>Calendar</source>
          <target state="translated">Calendar</target>
        </trans-unit>
        <trans-unit id="4ba307e0d2e402f172b3a88156165205934537c5" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;calloc&lt;/code&gt; from the C standard library.</source>
          <target state="translated">C標準ライブラリから &lt;code&gt;calloc&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="56834381560a3dd99cb2329bb238ba01df160757" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;free&lt;/code&gt; from the C standard library. Only use this on memory obtained from &lt;a href=&quot;#Base.Libc.malloc&quot;&gt;&lt;code&gt;malloc&lt;/code&gt;&lt;/a&gt;, not on pointers retrieved from other C libraries. &lt;a href=&quot;../c/index#Core.Ptr&quot;&gt;&lt;code&gt;Ptr&lt;/code&gt;&lt;/a&gt; objects obtained from C libraries should be freed by the free functions defined in that library, to avoid assertion failures if multiple &lt;code&gt;libc&lt;/code&gt; libraries exist on the system.</source>
          <target state="translated">C標準ライブラリから &lt;code&gt;free&lt;/code&gt; 呼び出します。これは、他のCライブラリから取得したポインタではなく、&lt;a href=&quot;#Base.Libc.malloc&quot;&gt; &lt;code&gt;malloc&lt;/code&gt; &lt;/a&gt;から取得したメモリでのみ使用してください。システムに複数の &lt;code&gt;libc&lt;/code&gt; ライブラリが存在する場合のアサーションの失敗を回避するために、Cライブラリから取得した&lt;a href=&quot;../c/index#Core.Ptr&quot;&gt; &lt;code&gt;Ptr&lt;/code&gt; &lt;/a&gt;オブジェクトは、そのライブラリで定義されているfree関数によって解放する必要があります。</target>
        </trans-unit>
        <trans-unit id="4bd40525129514b0914afc63feb30f354e65a4d9" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;free&lt;/code&gt; from the C standard library. Only use this on memory obtained from &lt;code&gt;malloc&lt;/code&gt;, not on pointers retrieved from other C libraries. &lt;code&gt;Ptr&lt;/code&gt; objects obtained from C libraries should be freed by the free functions defined in that library, to avoid assertion failures if multiple &lt;code&gt;libc&lt;/code&gt; libraries exist on the system.</source>
          <target state="translated">C標準ライブラリから &lt;code&gt;free&lt;/code&gt; 呼び出します。これを &lt;code&gt;malloc&lt;/code&gt; から取得したメモリでのみ使用し、他のCライブラリから取得したポインターでは使用しないでください。システムに複数の &lt;code&gt;libc&lt;/code&gt; ライブラリが存在する場合にアサーションエラーを回避するために、Cライブラリから取得した &lt;code&gt;Ptr&lt;/code&gt; オブジェクトは、そのライブラリで定義されているフリー関数によって解放する必要があります。</target>
        </trans-unit>
        <trans-unit id="9203b7a42060148350d2e8b3d4cff8d77d5adeaf" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;malloc&lt;/code&gt; from the C standard library.</source>
          <target state="translated">C標準ライブラリから &lt;code&gt;malloc&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="d59c9f90d0e1176d4cad8b98ecd8773005b655fb" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;realloc&lt;/code&gt; from the C standard library.</source>
          <target state="translated">C標準ライブラリから &lt;code&gt;realloc&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="04826291b163107f55d0704047219ec8c7242923" translate="yes" xml:space="preserve">
          <source>Call C functions directly (no wrappers or special APIs needed)</source>
          <target state="translated">C言語の関数を直接呼び出す(ラッパーや特別なAPIは必要ありません</target>
        </trans-unit>
        <trans-unit id="176405e1dde8747bb226b06f36937d8d5df0ebaf" translate="yes" xml:space="preserve">
          <source>Call LLVM IR string in the first argument. Similar to an LLVM function &lt;code&gt;define&lt;/code&gt; block, arguments are available as consecutive unnamed SSA variables (%0, %1, etc.).</source>
          <target state="translated">最初の引数でLLVM IR文字列を呼び出します。LLVM関数 &lt;code&gt;define&lt;/code&gt; ブロックと同様に、引数は、名前のない連続したSSA変数（％0、％1など）として使用できます。</target>
        </trans-unit>
        <trans-unit id="801735440ba4554b8dcf3670b61d4a15d05b05d1" translate="yes" xml:space="preserve">
          <source>Call a function &lt;code&gt;f&lt;/code&gt; asynchronously on the given arguments on the specified process. Return a &lt;a href=&quot;#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt;. Keyword arguments, if any, are passed through to &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">指定されたプロセスの指定された引数で関数 &lt;code&gt;f&lt;/code&gt; を非同期的に呼び出します。&lt;a href=&quot;#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt;返す。キーワード引数があれば、それが &lt;code&gt;f&lt;/code&gt; に渡されます。</target>
        </trans-unit>
        <trans-unit id="e66b49e037c9bfd84faa519573d27e88a8767628" translate="yes" xml:space="preserve">
          <source>Call a function in a C-exported shared library, specified by &lt;code&gt;library.function_name&lt;/code&gt;, where &lt;code&gt;library&lt;/code&gt; is a string constant or literal. The library may be omitted, in which case the &lt;code&gt;function_name&lt;/code&gt; is resolved in the current process. Alternatively, &lt;code&gt;@ccall&lt;/code&gt; may also be used to call a function pointer &lt;code&gt;$function_pointer&lt;/code&gt;, such as one returned by &lt;code&gt;dlsym&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;library.function_name&lt;/code&gt; で指定されたCエクスポート共有ライブラリ内の関数を呼び出します。ここで、 &lt;code&gt;library&lt;/code&gt; は文字列定数またはリテラルです。ライブラリは省略できます。その場合、 &lt;code&gt;function_name&lt;/code&gt; は現在のプロセスで解決されます。あるいは、 &lt;code&gt;@ccall&lt;/code&gt; は、関数ポインタを呼び出すために使用することができる &lt;code&gt;$function_pointer&lt;/code&gt; ようによって返さとして、 &lt;code&gt;dlsym&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="04a025fbe4a998cb1c2319eebb3e04b735a78fa3" translate="yes" xml:space="preserve">
          <source>Call a function in a C-exported shared library, specified by the tuple &lt;code&gt;(function_name, library)&lt;/code&gt;, where each component is either a string or symbol. Instead of specifying a library, one can also use a &lt;code&gt;function_name&lt;/code&gt; symbol or string, which is resolved in the current process. Alternatively, &lt;code&gt;ccall&lt;/code&gt; may also be used to call a function pointer &lt;code&gt;function_pointer&lt;/code&gt;, such as one returned by &lt;code&gt;dlsym&lt;/code&gt;.</source>
          <target state="translated">タプル &lt;code&gt;(function_name, library)&lt;/code&gt; で指定された、Cでエクスポートされた共有ライブラリの関数を呼び出します。ここで、各コンポーネントは文字列またはシンボルです。ライブラリを指定する代わりに、現在のプロセスで解決される &lt;code&gt;function_name&lt;/code&gt; シンボルまたは文字列を使用することもできます。あるいは、 &lt;code&gt;ccall&lt;/code&gt; は、関数ポインタを呼び出すために使用されてもよい &lt;code&gt;function_pointer&lt;/code&gt; のようによって返さとして、 &lt;code&gt;dlsym&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="d59f24dd0afcb729960eb267538b17e7042fcc85" translate="yes" xml:space="preserve">
          <source>Call function &lt;code&gt;f&lt;/code&gt; on each element of iterable &lt;code&gt;c&lt;/code&gt;. For multiple iterable arguments, &lt;code&gt;f&lt;/code&gt; is called elementwise. &lt;code&gt;foreach&lt;/code&gt; should be used instead of &lt;code&gt;map&lt;/code&gt; when the results of &lt;code&gt;f&lt;/code&gt; are not needed, for example in &lt;code&gt;foreach(println, array)&lt;/code&gt;.</source>
          <target state="translated">反復可能 &lt;code&gt;c&lt;/code&gt; の各要素で関数 &lt;code&gt;f&lt;/code&gt; を呼び出します。複数の反復可能な引数の場合、 &lt;code&gt;f&lt;/code&gt; は要素ごとに呼び出されます。 &lt;code&gt;foreach&lt;/code&gt; &lt;code&gt;foreach(println, array)&lt;/code&gt; ように、 &lt;code&gt;f&lt;/code&gt; の結果が必要ない場合は、 &lt;code&gt;map&lt;/code&gt; の代わりにforeachを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="ebb83c3d13bcfdfda803f0b35d77b6d7243cd9fe" translate="yes" xml:space="preserve">
          <source>Call the Win32 &lt;code&gt;GetLastError&lt;/code&gt; function [only available on Windows].</source>
          <target state="translated">Win32 &lt;code&gt;GetLastError&lt;/code&gt; 関数を呼び出します（Windowsでのみ使用可能）。</target>
        </trans-unit>
        <trans-unit id="ce4eab5c7f440edfe5b683c8baa8b023cc553366" translate="yes" xml:space="preserve">
          <source>Call the function &lt;code&gt;body&lt;/code&gt; with a modified task-local storage, in which &lt;code&gt;value&lt;/code&gt; is assigned to &lt;code&gt;key&lt;/code&gt;; the previous value of &lt;code&gt;key&lt;/code&gt;, or lack thereof, is restored afterwards. Useful for emulating dynamic scoping.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; が &lt;code&gt;key&lt;/code&gt; に割り当てられている変更されたタスクローカルストレージで関数 &lt;code&gt;body&lt;/code&gt; を呼び出します。 &lt;code&gt;key&lt;/code&gt; の以前の値またはその欠如は後で復元されます。動的スコープのエミュレートに役立ちます。</target>
        </trans-unit>
        <trans-unit id="eaa0c352f0575f82994206173cabc3866ad95796" translate="yes" xml:space="preserve">
          <source>Call the given function with an I/O stream and the supplied extra arguments. Everything written to this I/O stream is returned as a string. &lt;code&gt;context&lt;/code&gt; can be either an &lt;a href=&quot;#Base.IOContext&quot;&gt;&lt;code&gt;IOContext&lt;/code&gt;&lt;/a&gt; whose properties will be used, or a &lt;code&gt;Pair&lt;/code&gt; specifying a property and its value. &lt;code&gt;sizehint&lt;/code&gt; suggests the capacity of the buffer (in bytes).</source>
          <target state="translated">I / Oストリームと指定された追加の引数を使用して、指定された関数を呼び出します。このI / Oストリームに書き込まれたものはすべて文字列として返されます。 &lt;code&gt;context&lt;/code&gt; は、プロパティが使用される&lt;a href=&quot;#Base.IOContext&quot;&gt; &lt;code&gt;IOContext&lt;/code&gt; &lt;/a&gt;、またはプロパティとその値を指定する &lt;code&gt;Pair&lt;/code&gt; いずれかです。 &lt;code&gt;sizehint&lt;/code&gt; は、バッファの容量（バイト単位）を示します。</target>
        </trans-unit>
        <trans-unit id="2664dee6a3ad5a12623406c5af1cda40ecf12ba0" translate="yes" xml:space="preserve">
          <source>Callback settings. Matches the &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_remote_callbacks&quot;&gt;&lt;code&gt;git_remote_callbacks&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">コールバック設定。&lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_remote_callbacks&quot;&gt; &lt;code&gt;git_remote_callbacks&lt;/code&gt; &lt;/a&gt;構造体と一致します。</target>
        </trans-unit>
        <trans-unit id="c8256faf5b345c67f126415204dbd66a186005c2" translate="yes" xml:space="preserve">
          <source>Called by cluster managers implementing custom transports. It initializes a newly launched process as a worker. Command line argument &lt;code&gt;--worker[=&amp;lt;cookie&amp;gt;]&lt;/code&gt; has the effect of initializing a process as a worker using TCP/IP sockets for transport. &lt;code&gt;cookie&lt;/code&gt; is a &lt;a href=&quot;#Distributed.cluster_cookie-Tuple%7B%7D&quot;&gt;&lt;code&gt;cluster_cookie&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">カスタム転送を実装するクラスターマネージャーによって呼び出されます。新しく起動されたプロセスをワーカーとして初期化します。コマンドライン引数 &lt;code&gt;--worker[=&amp;lt;cookie&amp;gt;]&lt;/code&gt; は、トランスポートにTCP / IPソケットを使用するワーカーとしてプロセスを初期化する効果があります。 &lt;code&gt;cookie&lt;/code&gt; は&lt;a href=&quot;#Distributed.cluster_cookie-Tuple%7B%7D&quot;&gt; &lt;code&gt;cluster_cookie&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="caea39a5ffed5cf53b4f9992aa9aebdfdb841ef9" translate="yes" xml:space="preserve">
          <source>Called by cluster managers using custom transports. It should be called when the custom transport implementation receives the first message from a remote worker. The custom transport must manage a logical connection to the remote worker and provide two &lt;code&gt;IO&lt;/code&gt; objects, one for incoming messages and the other for messages addressed to the remote worker. If &lt;code&gt;incoming&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the remote peer initiated the connection. Whichever of the pair initiates the connection sends the cluster cookie and its Julia version number to perform the authentication handshake.</source>
          <target state="translated">カスタムトランスポートを使用してクラスターマネージャーによって呼び出されます。カスタムトランスポート実装がリモートワーカーから最初のメッセージを受信したときに呼び出されます。カスタムトランスポートは、リモートワーカーへの論理接続を管理し、2つの &lt;code&gt;IO&lt;/code&gt; オブジェクトを提供する必要があります。1 つは受信メッセージ用、もう1つはリモートワーカー宛のメッセージ用です。場合は &lt;code&gt;incoming&lt;/code&gt; ある &lt;code&gt;true&lt;/code&gt; 、リモートピアが接続を開始しました。接続を開始するペアのどちらかが、認証ハンドシェイクを実行するためにクラスターCookieとそのJuliaバージョン番号を送信します。</target>
        </trans-unit>
        <trans-unit id="66dd1be7576a64af07b2ce99b1a2ed2a7c06b791" translate="yes" xml:space="preserve">
          <source>Calling &lt;a href=&quot;#Core.Ref&quot;&gt;&lt;code&gt;Ref(array[, index])&lt;/code&gt;&lt;/a&gt; is generally preferable to this function as it guarantees validity.</source>
          <target state="translated">&lt;a href=&quot;#Core.Ref&quot;&gt; &lt;code&gt;Ref(array[, index])&lt;/code&gt; &lt;/a&gt;呼び出しは、有効性を保証するため、この関数よりも一般的に推奨されます。</target>
        </trans-unit>
        <trans-unit id="0d16198678162c2927c2f17ed3e602251edd7089" translate="yes" xml:space="preserve">
          <source>Calling &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt; inside a macro is a particularly dangerous warning sign; it means the macro will only work when called at the top level. If such a macro is written as a function instead, it will naturally have access to the run-time values it needs.</source>
          <target state="translated">マクロ内で&lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt; &lt;code&gt;eval&lt;/code&gt; &lt;/a&gt;を呼び出すと、特に危険な警告サインになります。これは、マクロがトップレベルで呼び出されたときにのみ機能することを意味します。そのようなマクロが代わりに関数として記述されている場合は、当然、必要なランタイム値にアクセスできます。</target>
        </trans-unit>
        <trans-unit id="b72748e09098c6bd97f55e59c563c3a122bb6331" translate="yes" xml:space="preserve">
          <source>Calling &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt; to cause a side-effect in another module. This will also cause a warning to be emitted when the incremental precompile flag is set.</source>
          <target state="translated">別のモジュールで副作用を引き起こすために&lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt; &lt;code&gt;eval&lt;/code&gt; &lt;/a&gt;を呼び出す。これにより、インクリメンタルプリコンパイルフラグが設定されている場合にも警告が発行されます。</target>
        </trans-unit>
        <trans-unit id="41aa7e1fcfd92670fa5a846085d3341583baabcf" translate="yes" xml:space="preserve">
          <source>Calling &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt;&lt;code&gt;stacktrace()&lt;/code&gt;&lt;/a&gt; returns a vector of &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.StackFrame&quot;&gt;&lt;code&gt;StackTraces.StackFrame&lt;/code&gt;&lt;/a&gt; s. For ease of use, the alias &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.StackTrace&quot;&gt;&lt;code&gt;StackTraces.StackTrace&lt;/code&gt;&lt;/a&gt; can be used in place of &lt;code&gt;Vector{StackFrame}&lt;/code&gt;. (Examples with &lt;code&gt;[...]&lt;/code&gt; indicate that output may vary depending on how the code is run.)</source>
          <target state="translated">&lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt; &lt;code&gt;stacktrace()&lt;/code&gt; を&lt;/a&gt;呼び出すと、&lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.StackFrame&quot;&gt; &lt;code&gt;StackTraces.StackFrame&lt;/code&gt; &lt;/a&gt;のベクトルが返されます。使いやすさのために、エイリアス&lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.StackTrace&quot;&gt; &lt;code&gt;StackTraces.StackTrace&lt;/code&gt; &lt;/a&gt;を &lt;code&gt;Vector{StackFrame}&lt;/code&gt; 代わりに使用できます。（ &lt;code&gt;[...]&lt;/code&gt; の例は、コードの実行方法によって出力が異なる場合があることを示しています。）</target>
        </trans-unit>
        <trans-unit id="4a4f549c9307f9b4d84be21408b77dbb68a1f198" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;rand&lt;/code&gt; and other RNG-related functions should be avoided in doctests since they will not produce consistent outputs during different Julia sessions. If you would like to show some random number generation related functionality, one option is to explicitly construct and seed your own &lt;a href=&quot;../../stdlib/random/index#Random.MersenneTwister&quot;&gt;&lt;code&gt;MersenneTwister&lt;/code&gt;&lt;/a&gt; (or other pseudorandom number generator) and pass it to the functions you are doctesting.</source>
          <target state="translated">&lt;code&gt;rand&lt;/code&gt; やその他のRNG関連の関数は、異なるJuliaセッションで一貫した出力を生成しないため、doctestでの呼び出しは避けてください。乱数生成に関連するいくつかの機能を表示したい場合、1つのオプションは、独自の&lt;a href=&quot;../../stdlib/random/index#Random.MersenneTwister&quot;&gt; &lt;code&gt;MersenneTwister&lt;/code&gt; &lt;/a&gt;（または他の疑似乱数ジェネレーター）を明示的に作成してシードし、それをドキュテストしている関数に渡すことです。</target>
        </trans-unit>
        <trans-unit id="2d7425b9bc6bdd37cfb5d8f6425582078c2424c2" translate="yes" xml:space="preserve">
          <source>Calling C and Fortran Code</source>
          <target state="translated">CとFortranコードの呼び出し</target>
        </trans-unit>
        <trans-unit id="0a72734e5b9d7e776161f32d3bf09af339418e1e" translate="yes" xml:space="preserve">
          <source>Calling Convention</source>
          <target state="translated">呼び出し規約</target>
        </trans-unit>
        <trans-unit id="9abfa6ddb5caaadbeab0376e3006f230505bfdea" translate="yes" xml:space="preserve">
          <source>Calling Julia Functions</source>
          <target state="translated">ジュリア関数の呼び出し</target>
        </trans-unit>
        <trans-unit id="85116a89bb1c5c01cfc46fa63875b231c5d2c577" translate="yes" xml:space="preserve">
          <source>Calling a method of a class in Python (&lt;code&gt;a = MyClass(x), x.func(y)&lt;/code&gt;) corresponds to a function call in Julia, e.g. &lt;code&gt;a = MyStruct(x), func(x::MyStruct, y)&lt;/code&gt;. In general, multiple dispatch is more flexible and powerful than the Python class system.</source>
          <target state="translated">Pythonでクラスのメソッドを呼び出す（ &lt;code&gt;a = MyClass(x), x.func(y)&lt;/code&gt; ）は、Juliaでの関数呼び出しに対応します &lt;code&gt;a = MyStruct(x), func(x::MyStruct, y)&lt;/code&gt; 例：a = MyStruct（x）、func（x :: MyStruct、y））。一般に、多重ディスパッチはPythonクラスシステムよりも柔軟で強力です。</target>
        </trans-unit>
        <trans-unit id="e49d09ca1110825e69afa568f7e07eeec5300e61" translate="yes" xml:space="preserve">
          <source>Calling any function that is defined after the body of the generated function. This condition is relaxed for incrementally-loaded precompiled modules to allow calling any function in the module.</source>
          <target state="translated">生成された関数のボディの後に定義されている任意の関数を呼び出す。この条件は、インクリメンタルにロードされたプリコンパイルされたモジュールでは緩和され、モジュール内の任意の関数を呼び出すことができるようになります。</target>
        </trans-unit>
        <trans-unit id="41d74c50b2c67c3ddc7b0e22937873f076e4b22e" translate="yes" xml:space="preserve">
          <source>Calling this function is the &quot;safe&quot; way to write algorithms that exploit linear indexing.</source>
          <target state="translated">この関数を呼び出すことは、線形インデキシングを利用したアルゴリズムを書くための「安全な」方法です。</target>
        </trans-unit>
        <trans-unit id="0a19b7e26b2ba75ac27255f31f21e98a34d62953" translate="yes" xml:space="preserve">
          <source>Calls</source>
          <target state="translated">Calls</target>
        </trans-unit>
        <trans-unit id="19d45b5117925d478df6d24e3b83936bcd7c78e0" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;f(args...; kwargs...)&lt;/code&gt;, but guarantees that the most recent method of &lt;code&gt;f&lt;/code&gt; will be executed. This is useful in specialized circumstances, e.g. long-running event loops or callback functions that may call obsolete versions of a function &lt;code&gt;f&lt;/code&gt;. (The drawback is that &lt;code&gt;invokelatest&lt;/code&gt; is somewhat slower than calling &lt;code&gt;f&lt;/code&gt; directly, and the type of the result cannot be inferred by the compiler.)</source>
          <target state="translated">コール &lt;code&gt;f(args...; kwargs...)&lt;/code&gt; が、ほとんどの最近の方法ことを保証 &lt;code&gt;f&lt;/code&gt; が実行されます。これは特別な状況で役立ちます。たとえば、長時間実行されるイベントループや、古いバージョンの関数 &lt;code&gt;f&lt;/code&gt; を呼び出す可能性のあるコールバック関数などです。（欠点は、 &lt;code&gt;invokelatest&lt;/code&gt; が &lt;code&gt;f&lt;/code&gt; を直接呼び出すよりもいくらか遅く、結果の型をコンパイラが推測できないことです。）</target>
        </trans-unit>
        <trans-unit id="4da9c9af9631e294961d5a16fdc681ca3d84f508" translate="yes" xml:space="preserve">
          <source>Camera</source>
          <target state="translated">Camera</target>
        </trans-unit>
        <trans-unit id="f01f585ee537bca9460fb6cd89d91523ae410c34" translate="yes" xml:space="preserve">
          <source>Can I use &lt;code&gt;using&lt;/code&gt; or &lt;code&gt;import&lt;/code&gt; inside a function?</source>
          <target state="translated">関数内で &lt;code&gt;using&lt;/code&gt; または &lt;code&gt;import&lt;/code&gt; できますか？</target>
        </trans-unit>
        <trans-unit id="07d6cb97820e052be2b530d0dd83bba8edfc5e64" translate="yes" xml:space="preserve">
          <source>Cancer</source>
          <target state="translated">Cancer</target>
        </trans-unit>
        <trans-unit id="dbffdf1f157a14a19d2c2aeb64068a16056948d8" translate="yes" xml:space="preserve">
          <source>Candy</source>
          <target state="translated">Candy</target>
        </trans-unit>
        <trans-unit id="f20a12fff18e89250e7a4fc78447ee7170895a65" translate="yes" xml:space="preserve">
          <source>Cannot exactly convert &lt;code&gt;val&lt;/code&gt; to type &lt;code&gt;T&lt;/code&gt; in a method of function &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">関数 &lt;code&gt;name&lt;/code&gt; メソッドで &lt;code&gt;val&lt;/code&gt; を &lt;code&gt;T&lt;/code&gt; 型に正確に変換することはできません。</target>
        </trans-unit>
        <trans-unit id="91fe73e52f951e9f466713424d00ece47cdc7524" translate="yes" xml:space="preserve">
          <source>Canonicalize a path by expanding symbolic links and removing &quot;.&quot; and &quot;..&quot; entries. On case-insensitive case-preserving filesystems (typically Mac and Windows), the filesystem's stored case for the path is returned.</source>
          <target state="translated">シンボリックリンクを展開し、&quot;.&quot; と &quot;....&quot; エントリを削除することで、パスを正規化します。大文字小文字を区別しない大文字小文字を保存するファイルシステム (通常は Mac や Windows)では、パスの保存されている大文字小文字が返されます。</target>
        </trans-unit>
        <trans-unit id="90a16c05e849a5af3a6ddd19c2db0fa10e54dd2d" translate="yes" xml:space="preserve">
          <source>Capitalize the first character of each word in &lt;code&gt;s&lt;/code&gt;; if &lt;code&gt;strict&lt;/code&gt; is true, every other character is converted to lowercase, otherwise they are left unchanged. By default, all non-letters are considered as word separators; a predicate can be passed as the &lt;code&gt;wordsep&lt;/code&gt; keyword to determine which characters should be considered as word separators. See also &lt;a href=&quot;#Base.Unicode.uppercasefirst&quot;&gt;&lt;code&gt;uppercasefirst&lt;/code&gt;&lt;/a&gt; to capitalize only the first character in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; の各単語の最初の文字を大文字にします。場合は &lt;code&gt;strict&lt;/code&gt; 真である、他のすべての文字は、そうでない場合はそのまま残され、小文字に変換されます。デフォルトでは、すべての非文字は単語の区切り文字と見なされます。述語を &lt;code&gt;wordsep&lt;/code&gt; キーワードとして渡して、単語区切り文字と見なす必要のある文字を決定できます。 &lt;code&gt;s&lt;/code&gt; の最初の文字のみを&lt;a href=&quot;#Base.Unicode.uppercasefirst&quot;&gt; &lt;code&gt;uppercasefirst&lt;/code&gt; &lt;/a&gt;するには、uppercasefirstも参照してください。</target>
        </trans-unit>
        <trans-unit id="c9bf29452874274eefd7cb3833b9f64b68215e7a" translate="yes" xml:space="preserve">
          <source>Capricorn</source>
          <target state="translated">Capricorn</target>
        </trans-unit>
        <trans-unit id="7a60d3a75036d27b63be0e55a67bb26ec4e25de4" translate="yes" xml:space="preserve">
          <source>Captures can also be accessed by indexing the &lt;code&gt;RegexMatch&lt;/code&gt; object with the number or name of the capture group:</source>
          <target state="translated">キャプチャは、キャプチャグループの番号または名前で &lt;code&gt;RegexMatch&lt;/code&gt; オブジェクトにインデックスを付けることによってもアクセスできます。</target>
        </trans-unit>
        <trans-unit id="88b6c532d029fa2352cf701d32470679db245f1e" translate="yes" xml:space="preserve">
          <source>Captures can be referenced in a substitution string when using &lt;code&gt;replace&lt;/code&gt; by using &lt;code&gt;\n&lt;/code&gt; to refer to the nth capture group and prefixing the substitution string with &lt;code&gt;s&lt;/code&gt;. Capture group 0 refers to the entire match object. Named capture groups can be referenced in the substitution with &lt;code&gt;\g&amp;lt;groupname&amp;gt;&lt;/code&gt;. For example:</source>
          <target state="translated">使用するときキャプチャは、置換文字列で参照することができます &lt;code&gt;replace&lt;/code&gt; 使用して &lt;code&gt;\n&lt;/code&gt; n番目のキャプチャグループを参照するとと置換文字列の接頭辞 &lt;code&gt;s&lt;/code&gt; 。キャプチャグループ0は、一致オブジェクト全体を指します。名前付きキャプチャグループは、 &lt;code&gt;\g&amp;lt;groupname&amp;gt;&lt;/code&gt; での置換で参照できます。例えば：</target>
        </trans-unit>
        <trans-unit id="f2a9f7332f7a09946296f88c18131b92dbb1279f" translate="yes" xml:space="preserve">
          <source>Card Index</source>
          <target state="translated">カードインデックス</target>
        </trans-unit>
        <trans-unit id="0cca55f8e3afeb49c40b1e95517a9c1135c7a560" translate="yes" xml:space="preserve">
          <source>Carousel Horse</source>
          <target state="translated">カルーセルの馬</target>
        </trans-unit>
        <trans-unit id="255e5aac2127bb14392d1d0c859050548a802598" translate="yes" xml:space="preserve">
          <source>Carp Streamer</source>
          <target state="translated">鯉のぼり</target>
        </trans-unit>
        <trans-unit id="722d5852eba2640d07e63d26f677b7d3dce6d40c" translate="yes" xml:space="preserve">
          <source>Cartesian indexing</source>
          <target state="translated">デカルトインデックス</target>
        </trans-unit>
        <trans-unit id="2a2b1fd0558d005d15bb6a090f84de302c0d4517" translate="yes" xml:space="preserve">
          <source>Cartesian indices</source>
          <target state="translated">直交指数</target>
        </trans-unit>
        <trans-unit id="2111431e539d8078cb148dae299ad435bcf94b27" translate="yes" xml:space="preserve">
          <source>Case &lt;code&gt;n &amp;gt; 1&lt;/code&gt;</source>
          <target state="translated">ケース &lt;code&gt;n &amp;gt; 1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e9f1c61da11e76b12eda645d65ffd7fe29682099" translate="yes" xml:space="preserve">
          <source>Case &lt;code&gt;n == 0&lt;/code&gt;</source>
          <target state="translated">ケース &lt;code&gt;n == 0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="29a059f07d864d6895c8f26aada84e3e2ae48daa" translate="yes" xml:space="preserve">
          <source>Case &lt;code&gt;n == 1&lt;/code&gt;</source>
          <target state="translated">ケース &lt;code&gt;n == 1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e5a951eefa4da8021cf83c2a312ac9db2161e292" translate="yes" xml:space="preserve">
          <source>Case Study: Rational</source>
          <target state="translated">ケーススタディ。合理的な</target>
        </trans-unit>
        <trans-unit id="226c8be8625b7e7ff2acf9e7afa1f2c1a67ee20d" translate="yes" xml:space="preserve">
          <source>Case Study: Rational Promotions</source>
          <target state="translated">ケーススタディ 合理的なプロモーション</target>
        </trans-unit>
        <trans-unit id="cebe54c7626cb1cefaca5f7f5ea6c96b4a7a2882" translate="yes" xml:space="preserve">
          <source>Cat</source>
          <target state="translated">Cat</target>
        </trans-unit>
        <trans-unit id="e321d6511fec0b2a4b2f0a4b6c9161ea67d3b862" translate="yes" xml:space="preserve">
          <source>Cat Face</source>
          <target state="translated">猫の顔</target>
        </trans-unit>
        <trans-unit id="0304d8e66e7196a0cbe56d1a1e3f50a5d44586dc" translate="yes" xml:space="preserve">
          <source>Cat Face With Tears Of Joy</source>
          <target state="translated">喜びの涙を持つ猫の顔</target>
        </trans-unit>
        <trans-unit id="8694b8421f68b951f951f9af799f80af5160aedd" translate="yes" xml:space="preserve">
          <source>Cat Face With Wry Smile</source>
          <target state="translated">笑う猫の顔</target>
        </trans-unit>
        <trans-unit id="34dfec8f22dde17704da94df2192063529be5d2d" translate="yes" xml:space="preserve">
          <source>Catalan's constant.</source>
          <target state="translated">カタルーニャの定数。</target>
        </trans-unit>
        <trans-unit id="b8c6b9519d52cad00665d92e155963171c5e725d" translate="yes" xml:space="preserve">
          <source>Catch exceptions during event evaluation</source>
          <target state="translated">イベント評価中に例外をキャッチ</target>
        </trans-unit>
        <trans-unit id="a3c686e711e4720f99b4562bb3dbaae7ab658cf2" translate="yes" xml:space="preserve">
          <source>Category</source>
          <target state="translated">Category</target>
        </trans-unit>
        <trans-unit id="1a80861772b0484c4f5af5303cebead59df45b86" translate="yes" xml:space="preserve">
          <source>Caution Sign</source>
          <target state="translated">注意事項</target>
        </trans-unit>
        <trans-unit id="bcaa33a7ae44bd5042c37a9cdbea7f843b1cf7c8" translate="yes" xml:space="preserve">
          <source>Caveats</source>
          <target state="translated">Caveats</target>
        </trans-unit>
        <trans-unit id="e4c530b1c24d3c230e2d840c8f5a4bd61e8f0170" translate="yes" xml:space="preserve">
          <source>Cchar</source>
          <target state="translated">Cchar</target>
        </trans-unit>
        <trans-unit id="98ea122cbe5434a5105ed227191d1c86da875820" translate="yes" xml:space="preserve">
          <source>Cdouble</source>
          <target state="translated">Cdouble</target>
        </trans-unit>
        <trans-unit id="ef6d3da178771ba00eefbc1133066d5d42ce7c22" translate="yes" xml:space="preserve">
          <source>Certain constructs in the language introduce &lt;em&gt;scope blocks&lt;/em&gt;, which are regions of code that are eligible to be the scope of some set of variables. The scope of a variable cannot be an arbitrary set of source lines; instead, it will always line up with one of these blocks. There are two main types of scopes in Julia, &lt;em&gt;global scope&lt;/em&gt; and &lt;em&gt;local scope&lt;/em&gt;. The latter can be nested. The constructs introducing scope blocks are:</source>
          <target state="translated">言語の特定の構成&lt;em&gt;要素&lt;/em&gt;は&lt;em&gt;スコープブロックを&lt;/em&gt;導入し&lt;em&gt;ます。スコープブロックは&lt;/em&gt;、いくつかの変数セットのスコープになるのに適格なコードの領域です。変数のスコープをソース行の任意のセットにすることはできません。代わりに、常にこれらのブロックのいずれかと整列します。 Juliaには、&lt;em&gt;グローバルスコープ&lt;/em&gt;と&lt;em&gt;ローカル&lt;/em&gt;スコープの2つの主要な種類のスコープがあり&lt;em&gt;ます&lt;/em&gt;。後者はネストできます。スコープブロックを導入する構成は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="79d6412ea668dd527aa9bd5226b88db41d88b00b" translate="yes" xml:space="preserve">
          <source>Certain constructs in the language introduce &lt;em&gt;scope blocks&lt;/em&gt;, which are regions of code that are eligible to be the scope of some set of variables. The scope of a variable cannot be an arbitrary set of source lines; instead, it will always line up with one of these blocks. There are two main types of scopes in Julia, &lt;em&gt;global scope&lt;/em&gt; and &lt;em&gt;local scope&lt;/em&gt;. The latter can be nested. There is also a distinction in Julia between constructs which introduce a &quot;hard scope&quot; and those which only introduce a &quot;soft scope&quot;, which affects whether shadowing a global variable by the same name is allowed or not.</source>
          <target state="translated">言語の特定の構造は、&lt;em&gt;スコープブロックを&lt;/em&gt;導入し&lt;em&gt;ます。スコープブロックは&lt;/em&gt;、変数のセットのスコープになる資格のあるコードの領域です。変数のスコープを任意のソース行のセットにすることはできません。代わりに、常にこれらのブロックの1つと整列します。Juliaには、&lt;em&gt;グローバルスコープ&lt;/em&gt;と&lt;em&gt;ローカル&lt;/em&gt;スコープの2つの主要なタイプのスコープがあり&lt;em&gt;ます&lt;/em&gt;。後者はネストできます。Juliaには、「ハードスコープ」を導入するコンストラクトと「ソフトスコープ」のみを導入するコンストラクトの違いもあります。これは、同じ名前のグローバル変数のシャドウイングが許可されるかどうかに影響します。</target>
        </trans-unit>
        <trans-unit id="a436f524b4f30d26cce25c6fb61307697fefc2aa" translate="yes" xml:space="preserve">
          <source>Certain operations make mathematical sense but result in errors:</source>
          <target state="translated">ある操作は数学的には意味がありますが、結果的にはエラーになります。</target>
        </trans-unit>
        <trans-unit id="b83c053cc3abf67280351793fa40fe0857a1ef12" translate="yes" xml:space="preserve">
          <source>Cfloat</source>
          <target state="translated">Cfloat</target>
        </trans-unit>
        <trans-unit id="1bf8d41c6633f510ee163ba63fad81c499b65c06" translate="yes" xml:space="preserve">
          <source>Chaining comparisons</source>
          <target state="translated">チェーンの比較</target>
        </trans-unit>
        <trans-unit id="e4b02f736800960ffeb31d1ce4d94bc68e9b3522" translate="yes" xml:space="preserve">
          <source>Chaining comparisons is often quite convenient in numerical code. Chained comparisons use the &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operator for scalar comparisons, and the &lt;a href=&quot;../../base/math/index#Base.:&amp;amp;&quot;&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/a&gt; operator for elementwise comparisons, which allows them to work on arrays. For example, &lt;code&gt;0 .&amp;lt; A .&amp;lt; 1&lt;/code&gt; gives a boolean array whose entries are true where the corresponding elements of &lt;code&gt;A&lt;/code&gt; are between 0 and 1.</source>
          <target state="translated">数値コードでは、比較の連鎖は非常に便利です。連鎖比較では、スカラー比較には &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 演算子を使用し、要素ごとの比較には&lt;a href=&quot;../../base/math/index#Base.:&amp;amp;&quot;&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;/a&gt;演算子を使用して、配列での処理を可能にします。たとえば、 &lt;code&gt;0 .&amp;lt; A .&amp;lt; 1&lt;/code&gt; は、 &lt;code&gt;A&lt;/code&gt; の対応する要素が0と1の間であり、エントリがtrueであるブール配列を提供します。</target>
        </trans-unit>
        <trans-unit id="e392d2ea4fb56f31affc92a17a7f093445989a1e" translate="yes" xml:space="preserve">
          <source>Change the &lt;code&gt;T&lt;/code&gt; arithmetic precision (in bits) for the duration of &lt;code&gt;f&lt;/code&gt;. It is logically equivalent to:</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; の継続時間の &lt;code&gt;T&lt;/code&gt; 算術精度（ビット単位）を変更します。論理的には次と同等です。</target>
        </trans-unit>
        <trans-unit id="aa7aae11d28e8bd4a1ac0973becf0187af2f72ff" translate="yes" xml:space="preserve">
          <source>Change the next word to lowercase</source>
          <target state="translated">次の単語を小文字に変更する</target>
        </trans-unit>
        <trans-unit id="a9d00290564b5f132466d2d65a5760e410b77379" translate="yes" xml:space="preserve">
          <source>Change the next word to titlecase</source>
          <target state="translated">次の単語をtitlecaseに変更する</target>
        </trans-unit>
        <trans-unit id="a1848e10eea50d9a7d51e412b6c651b68fe304e4" translate="yes" xml:space="preserve">
          <source>Change the next word to uppercase</source>
          <target state="translated">次の単語を大文字に変更する</target>
        </trans-unit>
        <trans-unit id="52116f45eb7f0166da051d04ad38b63f5e208b1f" translate="yes" xml:space="preserve">
          <source>Change the owner and/or group of &lt;code&gt;path&lt;/code&gt; to &lt;code&gt;owner&lt;/code&gt; and/or &lt;code&gt;group&lt;/code&gt;. If the value entered for &lt;code&gt;owner&lt;/code&gt; or &lt;code&gt;group&lt;/code&gt; is &lt;code&gt;-1&lt;/code&gt; the corresponding ID will not change. Only integer &lt;code&gt;owner&lt;/code&gt;s and &lt;code&gt;group&lt;/code&gt;s are currently supported. Return &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">所有者および/またはグループに変更し &lt;code&gt;path&lt;/code&gt; し &lt;code&gt;owner&lt;/code&gt; および/または &lt;code&gt;group&lt;/code&gt; 。 &lt;code&gt;owner&lt;/code&gt; または &lt;code&gt;group&lt;/code&gt; 入力した値が &lt;code&gt;-1&lt;/code&gt; の場合、対応するIDは変更されません。現在、整数の &lt;code&gt;owner&lt;/code&gt; と &lt;code&gt;group&lt;/code&gt; のみがサポートされています。戻り &lt;code&gt;path&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b4cadce06d0cab691571969b2bd50452957441f5" translate="yes" xml:space="preserve">
          <source>Change the permissions mode of &lt;code&gt;path&lt;/code&gt; to &lt;code&gt;mode&lt;/code&gt;. Only integer &lt;code&gt;mode&lt;/code&gt;s (e.g. &lt;code&gt;0o777&lt;/code&gt;) are currently supported. If &lt;code&gt;recursive=true&lt;/code&gt; and the path is a directory all permissions in that directory will be recursively changed. Return &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; の許可モードをmodeに変更し &lt;code&gt;mode&lt;/code&gt; 。現在サポートされているのは整数 &lt;code&gt;mode&lt;/code&gt; （ &lt;code&gt;0o777&lt;/code&gt; など）のみです。 &lt;code&gt;recursive=true&lt;/code&gt; で、パスがディレクトリの場合、そのディレクトリ内のすべての権限が再帰的に変更されます。戻り &lt;code&gt;path&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="32a989fb98b8f1dbfc4dbfdbda4cfa7a8f5a564e" translate="yes" xml:space="preserve">
          <source>Change the rounding mode of floating point type &lt;code&gt;T&lt;/code&gt; for the duration of &lt;code&gt;f&lt;/code&gt;. It is logically equivalent to:</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; の期間、浮動小数点型 &lt;code&gt;T&lt;/code&gt; の丸めモードを変更します。論理的には次と同等です。</target>
        </trans-unit>
        <trans-unit id="6826b0c27162177562d5dac46bf63880b08e8521" translate="yes" xml:space="preserve">
          <source>Change the type-interpretation of a block of memory. For arrays, this constructs a view of the array with the same binary data as the given array, but with the specified element type. For example, &lt;code&gt;reinterpret(Float32, UInt32(7))&lt;/code&gt; interprets the 4 bytes corresponding to &lt;code&gt;UInt32(7)&lt;/code&gt; as a &lt;a href=&quot;../numbers/index#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">メモリブロックのタイプ解釈を変更します。配列の場合、これは、指定された配列と同じバイナリデータを持つが、指定された要素型を持つ配列のビューを構築します。たとえば、 &lt;code&gt;reinterpret(Float32, UInt32(7))&lt;/code&gt; は、 &lt;code&gt;UInt32(7)&lt;/code&gt; に対応する4バイトを&lt;a href=&quot;../numbers/index#Core.Float32&quot;&gt; &lt;code&gt;Float32&lt;/code&gt; &lt;/a&gt;として解釈します。</target>
        </trans-unit>
        <trans-unit id="d4eec72c597c649417c08cf8310c3fd12582209e" translate="yes" xml:space="preserve">
          <source>Change to the first history entry (of the current session if it is before the current position in history)</source>
          <target state="translated">履歴の最初のエントリ(履歴の現在の位置より前であれば、現在のセッションの)への変更</target>
        </trans-unit>
        <trans-unit id="2d9790ce2e89644c1d5ef1d4178a0e20ffa229c9" translate="yes" xml:space="preserve">
          <source>Change to the last history entry</source>
          <target state="translated">最後の履歴エントリへの変更</target>
        </trans-unit>
        <trans-unit id="f00c73a7c5134c054bca76810185e125c387bc0a" translate="yes" xml:space="preserve">
          <source>Change to the next history entry</source>
          <target state="translated">次の履歴エントリに変更</target>
        </trans-unit>
        <trans-unit id="cfe48d07ba26c0afb2979f42a242b38ee82c88da" translate="yes" xml:space="preserve">
          <source>Change to the previous history entry</source>
          <target state="translated">前の履歴エントリに変更</target>
        </trans-unit>
        <trans-unit id="879f0b1bef59eeebf78cfd3a22f6f8077810cecf" translate="yes" xml:space="preserve">
          <source>Channel</source>
          <target state="translated">Channel</target>
        </trans-unit>
        <trans-unit id="18e03e2a37ba37df713f9665ef752fb8b40fc1e8" translate="yes" xml:space="preserve">
          <source>Channels</source>
          <target state="translated">Channels</target>
        </trans-unit>
        <trans-unit id="5d2585d6b1ebe562ed90e098229697dd1edbced3" translate="yes" xml:space="preserve">
          <source>Channels and RemoteChannels</source>
          <target state="translated">チャンネルとリモートチャンネル</target>
        </trans-unit>
        <trans-unit id="5de527ad4b50c6e5971cd0c9d1c61d30dff8242c" translate="yes" xml:space="preserve">
          <source>Channels are created via the &lt;code&gt;Channel{T}(sz)&lt;/code&gt; constructor. The channel will only hold objects of type &lt;code&gt;T&lt;/code&gt;. If the type is not specified, the channel can hold objects of any type. &lt;code&gt;sz&lt;/code&gt; refers to the maximum number of elements that can be held in the channel at any time. For example, &lt;code&gt;Channel(32)&lt;/code&gt; creates a channel that can hold a maximum of 32 objects of any type. A &lt;code&gt;Channel{MyType}(64)&lt;/code&gt; can hold up to 64 objects of &lt;code&gt;MyType&lt;/code&gt; at any time.</source>
          <target state="translated">チャネルは、 &lt;code&gt;Channel{T}(sz)&lt;/code&gt; コンストラクターを介して作成されます。チャネルはタイプ &lt;code&gt;T&lt;/code&gt; のオブジェクトのみを保持します。タイプが指定されていない場合、チャネルは任意のタイプのオブジェクトを保持できます。 &lt;code&gt;sz&lt;/code&gt; は、いつでもチャネルに保持できる要素の最大数を指します。たとえば、 &lt;code&gt;Channel(32)&lt;/code&gt; は、任意のタイプのオブジェクトを最大32個保持できるチャネルを作成します。 &lt;code&gt;Channel{MyType}(64)&lt;/code&gt; の64個まで保持することができる &lt;code&gt;MyType&lt;/code&gt; 随時。</target>
        </trans-unit>
        <trans-unit id="f0af2b3f98cdd8293e5cd590c14f3ad654402a21" translate="yes" xml:space="preserve">
          <source>Character Tie</source>
          <target state="translated">キャラクタータイ</target>
        </trans-unit>
        <trans-unit id="ed74ee0fd869597bc8b7e61e821510ccb8a627ec" translate="yes" xml:space="preserve">
          <source>Character literals use the same behavior.</source>
          <target state="translated">文字リテラルも同じ動作をします。</target>
        </trans-unit>
        <trans-unit id="af451d4e9c685856e4c14256f0f0685adcf83857" translate="yes" xml:space="preserve">
          <source>Character(s)</source>
          <target state="translated">Character(s)</target>
        </trans-unit>
        <trans-unit id="69803692f05446db28128e4d652fcda3604ec718" translate="yes" xml:space="preserve">
          <source>Characteristics:</source>
          <target state="translated">Characteristics:</target>
        </trans-unit>
        <trans-unit id="b6f59f08fd6d58c6725e21a9ec24e068148ec586" translate="yes" xml:space="preserve">
          <source>Characters</source>
          <target state="translated">Characters</target>
        </trans-unit>
        <trans-unit id="d9a77eec8cc54d9b9059ecff9f7f8b0c3d4a4b0c" translate="yes" xml:space="preserve">
          <source>Characters not listed above are normally treated as delimiters between date and time slots. For example a &lt;code&gt;dt&lt;/code&gt; string of &quot;1996-01-15T00:00:00.0&quot; would have a &lt;code&gt;format&lt;/code&gt; string like &quot;y-m-dTH:M:S.s&quot;. If you need to use a code character as a delimiter you can escape it using backslash. The date &quot;1995y01m&quot; would have the format &quot;y\ym\m&quot;.</source>
          <target state="translated">上記にリストされていない文字は、通常、日付と時間スロット間の区切り文字として扱われます。たとえば、「1996-01-15T00：00：00.0」の &lt;code&gt;dt&lt;/code&gt; 文字列は、「ym-dTH：M：Ss」のような &lt;code&gt;format&lt;/code&gt; 文字列を持ちます。区切り文字としてコード文字を使用する必要がある場合は、バックスラッシュを使用してエスケープできます。日付「1995y01m」の形式は「y \ ym \ m」になります。</target>
        </trans-unit>
        <trans-unit id="ebef4e9d21d309d10e724345b9594679b3cd6e69" translate="yes" xml:space="preserve">
          <source>Chart With Downwards Trend</source>
          <target state="translated">下降トレンドのチャート</target>
        </trans-unit>
        <trans-unit id="fda4f4461a399f03823d93f75ef10112a332c903" translate="yes" xml:space="preserve">
          <source>Chart With Upwards Trend</source>
          <target state="translated">上昇トレンドのあるチャート</target>
        </trans-unit>
        <trans-unit id="a4a446b006052a5af669c7f6d998cf1743a7f6f9" translate="yes" xml:space="preserve">
          <source>Chart With Upwards Trend And Yen Sign</source>
          <target state="translated">上昇トレンドと円サインのチャート</target>
        </trans-unit>
        <trans-unit id="73e89165960f554ff917c3b3ac9d3b096b8d5eaf" translate="yes" xml:space="preserve">
          <source>Check Mark</source>
          <target state="translated">チェックマーク</target>
        </trans-unit>
        <trans-unit id="6af7b65d95d1fd3d3c46eeef377ffa00fb6e86a4" translate="yes" xml:space="preserve">
          <source>Check if &lt;code&gt;ex&lt;/code&gt; is an expression with head &lt;code&gt;head&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; arguments.</source>
          <target state="translated">かどうかをチェック &lt;code&gt;ex&lt;/code&gt; は頭部を持つ式で &lt;code&gt;head&lt;/code&gt; と &lt;code&gt;n&lt;/code&gt; 個の引数。</target>
        </trans-unit>
        <trans-unit id="8cccac008dc853e30120df3e9a70c3898d9b2bee" translate="yes" xml:space="preserve">
          <source>Check if commit &lt;code&gt;id&lt;/code&gt; (which is a &lt;a href=&quot;#LibGit2.GitHash&quot;&gt;&lt;code&gt;GitHash&lt;/code&gt;&lt;/a&gt; in string form) is in the repository.</source>
          <target state="translated">コミット &lt;code&gt;id&lt;/code&gt; （文字列形式の&lt;a href=&quot;#LibGit2.GitHash&quot;&gt; &lt;code&gt;GitHash&lt;/code&gt; &lt;/a&gt;）がリポジトリにあるかどうかを確認します。</target>
        </trans-unit>
        <trans-unit id="36465e7df054d1a8db11c41ceb01463ffd339488" translate="yes" xml:space="preserve">
          <source>Check if the current branch is an &quot;orphan&quot; branch, i.e. has no commits. The first commit to this branch will have no parents.</source>
          <target state="translated">現在のブランチが &quot;孤児&quot; ブランチであるかどうか、つまりコミットがないかどうかをチェックします。このブランチの最初のコミットには親がいません。</target>
        </trans-unit>
        <trans-unit id="b66e0b7684d9561bc0ff2976ce4bdbc130c0a5c9" translate="yes" xml:space="preserve">
          <source>Check if there have been any changes to tracked files in the working tree (if &lt;code&gt;cached=false&lt;/code&gt;) or the index (if &lt;code&gt;cached=true&lt;/code&gt;). &lt;code&gt;pathspecs&lt;/code&gt; are the specifications for options for the diff.</source>
          <target state="translated">作業ツリー（ &lt;code&gt;cached=false&lt;/code&gt; の場合）またはインデックス（ &lt;code&gt;cached=true&lt;/code&gt; の場合）で追跡ファイルに変更があったかどうかを確認します。 &lt;code&gt;pathspecs&lt;/code&gt; は、diffのオプションの仕様です。</target>
        </trans-unit>
        <trans-unit id="10941e2df89576fa668bf1f89fbe0ad9fb195edb" translate="yes" xml:space="preserve">
          <source>Check that a matrix is square, then return its common dimension. For multiple arguments, return a vector.</source>
          <target state="translated">行列が正方であることを確認し、その共通次元を返します。複数の引数の場合は,ベクトルを返します.</target>
        </trans-unit>
        <trans-unit id="6861a1cca611ecd76d506c1580f9dd38e9dfec32" translate="yes" xml:space="preserve">
          <source>Check two array shapes for compatibility, allowing trailing singleton dimensions, and return whichever shape has more dimensions.</source>
          <target state="translated">2つの配列形状の互換性をチェックして、シングルトン次元の後続を許可し、より多くの次元を持つ方の形状を返します。</target>
        </trans-unit>
        <trans-unit id="5847f57e4c8ac4313a08831cbbd9321dc7c8aa94" translate="yes" xml:space="preserve">
          <source>Check whether the &lt;code&gt;lock&lt;/code&gt; is held by any task/thread. This should not be used for synchronization (see instead &lt;a href=&quot;#Base.trylock&quot;&gt;&lt;code&gt;trylock&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;lock&lt;/code&gt; がタスク/スレッドによって保持されているかどうかを確認します。これは同期には使用しないでください（代わりに&lt;a href=&quot;#Base.trylock&quot;&gt; &lt;code&gt;trylock&lt;/code&gt; を&lt;/a&gt;参照してください）。</target>
        </trans-unit>
        <trans-unit id="387def941a675fd43bb90cd2f103bc1835695e36" translate="yes" xml:space="preserve">
          <source>Checked.add_with_overflow()</source>
          <target state="translated">Checked.add_with_overflow()</target>
        </trans-unit>
        <trans-unit id="5861f86d2198b43b150ea6be20eecd4f4ca194fb" translate="yes" xml:space="preserve">
          <source>Checked.checked_abs()</source>
          <target state="translated">Checked.checked_abs()</target>
        </trans-unit>
        <trans-unit id="0e340663d314653dc7f7258455c8c64ec865a402" translate="yes" xml:space="preserve">
          <source>Checked.checked_add()</source>
          <target state="translated">Checked.checked_add()</target>
        </trans-unit>
        <trans-unit id="793b46bf345ea840a66fc3ce7be504df87f6aad8" translate="yes" xml:space="preserve">
          <source>Checked.checked_cld()</source>
          <target state="translated">Checked.checked_cld()</target>
        </trans-unit>
        <trans-unit id="cbb75d95e9a638cb0354f430f1c41528c16d5f1e" translate="yes" xml:space="preserve">
          <source>Checked.checked_div()</source>
          <target state="translated">Checked.checked_div()</target>
        </trans-unit>
        <trans-unit id="10f25d8f5722c731db35c0585785eb14e0947047" translate="yes" xml:space="preserve">
          <source>Checked.checked_fld()</source>
          <target state="translated">Checked.checked_fld()</target>
        </trans-unit>
        <trans-unit id="844d8f377decea211f1aa04e5b41ffd6aa8ec8aa" translate="yes" xml:space="preserve">
          <source>Checked.checked_mod()</source>
          <target state="translated">Checked.checked_mod()</target>
        </trans-unit>
        <trans-unit id="6e287962b9c64e9790cebd017023df56a743a004" translate="yes" xml:space="preserve">
          <source>Checked.checked_mul()</source>
          <target state="translated">Checked.checked_mul()</target>
        </trans-unit>
        <trans-unit id="8cddbe8ee88213cf9e9d56a609fa85a89e086da7" translate="yes" xml:space="preserve">
          <source>Checked.checked_neg()</source>
          <target state="translated">Checked.checked_neg()</target>
        </trans-unit>
        <trans-unit id="e44667638c3a1dc209bda165095e1d1cd133cc75" translate="yes" xml:space="preserve">
          <source>Checked.checked_rem()</source>
          <target state="translated">Checked.checked_rem()</target>
        </trans-unit>
        <trans-unit id="0088d172f06fff6ea323397de23669a32c31474b" translate="yes" xml:space="preserve">
          <source>Checked.checked_sub()</source>
          <target state="translated">Checked.checked_sub()</target>
        </trans-unit>
        <trans-unit id="ab7e607ffaab3ede22444bf0bafb0736dd5575b5" translate="yes" xml:space="preserve">
          <source>Checked.mul_with_overflow()</source>
          <target state="translated">Checked.mul_with_overflow()</target>
        </trans-unit>
        <trans-unit id="44a69fd61235a11b4b6edaa45c7d2594c6702f55" translate="yes" xml:space="preserve">
          <source>Checked.sub_with_overflow()</source>
          <target state="translated">Checked.sub_with_overflow()</target>
        </trans-unit>
        <trans-unit id="f66ee858da2bed315f19a0831545acdc098092b9" translate="yes" xml:space="preserve">
          <source>Checking for equality with a singleton</source>
          <target state="translated">シングルトンでの平等性のチェック</target>
        </trans-unit>
        <trans-unit id="099aaa95277770b044f9e7efabb37f097dce362a" translate="yes" xml:space="preserve">
          <source>Checkout a new git branch in the &lt;code&gt;repo&lt;/code&gt; repository. &lt;code&gt;commit&lt;/code&gt; is the &lt;a href=&quot;#LibGit2.GitHash&quot;&gt;&lt;code&gt;GitHash&lt;/code&gt;&lt;/a&gt;, in string form, which will be the start of the new branch. If &lt;code&gt;commit&lt;/code&gt; is an empty string, the current HEAD will be used.</source>
          <target state="translated">&lt;code&gt;repo&lt;/code&gt; リポジトリの新しいgitブランチをチェックアウトします。 &lt;code&gt;commit&lt;/code&gt; は、新しいブランチの開始点となる文字列形式の&lt;a href=&quot;#LibGit2.GitHash&quot;&gt; &lt;code&gt;GitHash&lt;/code&gt; &lt;/a&gt;です。場合は &lt;code&gt;commit&lt;/code&gt; 空の文字列で、現在のHEADが使用されます。</target>
        </trans-unit>
        <trans-unit id="a01db35293e447e7dfa93e429ed3057a3d6edb4e" translate="yes" xml:space="preserve">
          <source>Checks if there are any differences between the tree specified by &lt;code&gt;treeish&lt;/code&gt; and the tracked files in the working tree (if &lt;code&gt;cached=false&lt;/code&gt;) or the index (if &lt;code&gt;cached=true&lt;/code&gt;). &lt;code&gt;pathspecs&lt;/code&gt; are the specifications for options for the diff.</source>
          <target state="translated">&lt;code&gt;treeish&lt;/code&gt; で指定されたツリーと作業ツリー（cached &lt;code&gt;cached=false&lt;/code&gt; 場合）またはインデックス（cached &lt;code&gt;cached=true&lt;/code&gt; ）の追跡されているファイルの間に違いがあるかどうかを確認します。 &lt;code&gt;pathspecs&lt;/code&gt; は、diffのオプションの仕様です。</target>
        </trans-unit>
        <trans-unit id="80497c05495db1c1e51a0b937bd9ffa77fb142ff" translate="yes" xml:space="preserve">
          <source>Cheering Megaphone</source>
          <target state="translated">応援メガホン</target>
        </trans-unit>
        <trans-unit id="e81bedf047792fbe90c699c0d92561bd6df81796" translate="yes" xml:space="preserve">
          <source>Chequered Flag</source>
          <target state="translated">チェッカーフラッグ</target>
        </trans-unit>
        <trans-unit id="78bc6d7859d13eaa4171edc4973a040f60c5efa2" translate="yes" xml:space="preserve">
          <source>Cherries</source>
          <target state="translated">Cherries</target>
        </trans-unit>
        <trans-unit id="d980b2a4bed67957e89a2bfcbf9122253661d3b9" translate="yes" xml:space="preserve">
          <source>Cherry Blossom</source>
          <target state="translated">桜</target>
        </trans-unit>
        <trans-unit id="c712b8835755410091fbe89cfba2f9989bcdddf1" translate="yes" xml:space="preserve">
          <source>Chestnut</source>
          <target state="translated">Chestnut</target>
        </trans-unit>
        <trans-unit id="baaa18844b8db958c57edddf824f4a8b5cd9e298" translate="yes" xml:space="preserve">
          <source>Chicken</source>
          <target state="translated">Chicken</target>
        </trans-unit>
        <trans-unit id="6684f920ddf587816828d0949794d536f2044d85" translate="yes" xml:space="preserve">
          <source>Children Crossing</source>
          <target state="translated">子供たちの横断</target>
        </trans-unit>
        <trans-unit id="be60ee4f4851b8d244bba0827efe90ca53080f02" translate="yes" xml:space="preserve">
          <source>Chocolate Bar</source>
          <target state="translated">チョコレートバー</target>
        </trans-unit>
        <trans-unit id="36f117bd7dd482a1010ab9584c224f54936b91cc" translate="yes" xml:space="preserve">
          <source>Cholesky (see &lt;a href=&quot;#LinearAlgebra.cholesky&quot;&gt;&lt;code&gt;cholesky&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">コレスキー（参照&lt;a href=&quot;#LinearAlgebra.cholesky&quot;&gt; &lt;code&gt;cholesky&lt;/code&gt; &lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="e3c96b15f464a32f9dbfcd9be5dcfbc00bda9510" translate="yes" xml:space="preserve">
          <source>Cholesky factorization</source>
          <target state="translated">コレスキー因数分解</target>
        </trans-unit>
        <trans-unit id="da141a0edd85453be825d6aa02b625b2d8b12905" translate="yes" xml:space="preserve">
          <source>Christmas Tree</source>
          <target state="translated">クリスマスツリー</target>
        </trans-unit>
        <trans-unit id="e72e88ea6123b50e6208c2e997da2b67631286d6" translate="yes" xml:space="preserve">
          <source>Church</source>
          <target state="translated">Church</target>
        </trans-unit>
        <trans-unit id="f4ea571bfe0617f587935723651430356fc70f4c" translate="yes" xml:space="preserve">
          <source>Cinema</source>
          <target state="translated">Cinema</target>
        </trans-unit>
        <trans-unit id="20638d5f9a181ef513cf00b55dcce4c98adb55f7" translate="yes" xml:space="preserve">
          <source>Cint</source>
          <target state="translated">Cint</target>
        </trans-unit>
        <trans-unit id="810c53332cece6a0ba48a6c0ba3b4f10aa580f90" translate="yes" xml:space="preserve">
          <source>Cintmax_t</source>
          <target state="translated">Cintmax_t</target>
        </trans-unit>
        <trans-unit id="f012b4aef95600337cc3ea8a98c28a295ab93f2f" translate="yes" xml:space="preserve">
          <source>Circle With All But Upper Left Quadrant Black</source>
          <target state="translated">左上四分儀の黒を含むすべての円</target>
        </trans-unit>
        <trans-unit id="e64a2f1f5550310ac4fcf3d82a1eba3eb03373e3" translate="yes" xml:space="preserve">
          <source>Circle With Left Half Black</source>
          <target state="translated">左半分黒の円</target>
        </trans-unit>
        <trans-unit id="4242c36ce736c0ae2d9e13bbac4c03ddccb00e63" translate="yes" xml:space="preserve">
          <source>Circle With Lower Half Black</source>
          <target state="translated">下半分黒の円</target>
        </trans-unit>
        <trans-unit id="9946dda080b1d6f72432e4888afcc095dde79ea8" translate="yes" xml:space="preserve">
          <source>Circle With Right Half Black</source>
          <target state="translated">右半分黒の円</target>
        </trans-unit>
        <trans-unit id="d869eafe06cb16bdb3bb0bc2e1be15db03901859" translate="yes" xml:space="preserve">
          <source>Circle With Upper Half Black</source>
          <target state="translated">上半分黒のサークル</target>
        </trans-unit>
        <trans-unit id="a8f7c61db4ce9bd030f686d3b28ef55edb06c05f" translate="yes" xml:space="preserve">
          <source>Circle With Upper Right Quadrant Black</source>
          <target state="translated">円と右上象限黒</target>
        </trans-unit>
        <trans-unit id="7ac2156e5b2912f2254d2f3ae90f1a8c149be7ab" translate="yes" xml:space="preserve">
          <source>Circle With Vertical Fill</source>
          <target state="translated">垂直方向の塗りつぶしのある円</target>
        </trans-unit>
        <trans-unit id="bdade6bd883a792ea7c7650d2326b104f190c6db" translate="yes" xml:space="preserve">
          <source>Circled Anticlockwise-Rotated Division Sign</source>
          <target state="translated">反時計回りに回転したサークリングされた分割サイン</target>
        </trans-unit>
        <trans-unit id="288b0220ab4dfdbd33067b22c1e4248e5492c4f4" translate="yes" xml:space="preserve">
          <source>Circled Asterisk Operator</source>
          <target state="translated">丸印のアスタリスク演算子</target>
        </trans-unit>
        <trans-unit id="c23f14422e51f91da407f474f9afc3cc0d6b1a61" translate="yes" xml:space="preserve">
          <source>Circled Bullet</source>
          <target state="translated">ぐるりと回った弾丸</target>
        </trans-unit>
        <trans-unit id="317b273eb94a369a8c28e6bf5cd7c75c54af9e35" translate="yes" xml:space="preserve">
          <source>Circled Dash</source>
          <target state="translated">サークルダッシュ</target>
        </trans-unit>
        <trans-unit id="f5d528c73ab76ab5f33f09420750954ff64b51f9" translate="yes" xml:space="preserve">
          <source>Circled Division Sign</source>
          <target state="translated">サークルされたディビジョンサイン</target>
        </trans-unit>
        <trans-unit id="af5e4fc428d95afd21ff1ec53e8506a2bd73fb48" translate="yes" xml:space="preserve">
          <source>Circled Division Slash</source>
          <target state="translated">サークルディビジョンスラッシュ</target>
        </trans-unit>
        <trans-unit id="1540fdfaea096a26f649db63c8e3d97ec047096a" translate="yes" xml:space="preserve">
          <source>Circled Dot Operator</source>
          <target state="translated">巡回ドット演算子</target>
        </trans-unit>
        <trans-unit id="13716b865f5fa5c0c59b298bdb824a0403d1d0a8" translate="yes" xml:space="preserve">
          <source>Circled Equals</source>
          <target state="translated">サークルドイコール</target>
        </trans-unit>
        <trans-unit id="6fb20198e34869ba5357fb1484d789a4a9cf41a3" translate="yes" xml:space="preserve">
          <source>Circled Greater-Than</source>
          <target state="translated">圏外</target>
        </trans-unit>
        <trans-unit id="768c6a3e34cf1fa1fe17c4122cd2eb756b5c8db1" translate="yes" xml:space="preserve">
          <source>Circled Ideograph Accept</source>
          <target state="translated">丸で囲んだイデグラフを受け入れる</target>
        </trans-unit>
        <trans-unit id="cd7d8396b4543ec8eac2c933faab0d381b5eddf4" translate="yes" xml:space="preserve">
          <source>Circled Ideograph Advantage</source>
          <target state="translated">円環状のイデグラフの利点</target>
        </trans-unit>
        <trans-unit id="68de940ba4435005de139e8e8a3c0d351749a305" translate="yes" xml:space="preserve">
          <source>Circled Ideograph Congratulation</source>
          <target state="translated">ぐるりと一周したイデグラフのお祝い</target>
        </trans-unit>
        <trans-unit id="73f2e57c66e79ca73dc25a784afe3bf12db57991" translate="yes" xml:space="preserve">
          <source>Circled Ideograph Secret</source>
          <target state="translated">ぐるりと回ったイデグラフの秘密</target>
        </trans-unit>
        <trans-unit id="a40a39ec3a6682d21b6ef060b4feb0021bb56a91" translate="yes" xml:space="preserve">
          <source>Circled Latin Capital Letter M</source>
          <target state="translated">丸で囲んだラテン文字の大文字M</target>
        </trans-unit>
        <trans-unit id="0737d90c41767eac9bb882a65f60e50a52a763a4" translate="yes" xml:space="preserve">
          <source>Circled Latin Capital Letter S</source>
          <target state="translated">サークルされたラテン文字の大文字S</target>
        </trans-unit>
        <trans-unit id="3921273fcb7324637d2df323be0460e56b6c07e5" translate="yes" xml:space="preserve">
          <source>Circled Less-Than</source>
          <target state="translated">サークルされていない</target>
        </trans-unit>
        <trans-unit id="11ab89c625b1e2be31e3ce88e58467e9d8b591d3" translate="yes" xml:space="preserve">
          <source>Circled Minus</source>
          <target state="translated">サークルドマイナス</target>
        </trans-unit>
        <trans-unit id="49fb7ea6102e3ddbe3f49605b323255242257db1" translate="yes" xml:space="preserve">
          <source>Circled Multiplication Sign With Circumflex Accent</source>
          <target state="translated">サークルド乗算サイン、サーカムフレックスアクセント付き</target>
        </trans-unit>
        <trans-unit id="b54193aa1a494f0d833f0a8740fb732847cecb8a" translate="yes" xml:space="preserve">
          <source>Circled Parallel</source>
          <target state="translated">サークルパラレル</target>
        </trans-unit>
        <trans-unit id="8f99a8867a889f5ea35c2600d3c7f7047a7990e2" translate="yes" xml:space="preserve">
          <source>Circled Plus</source>
          <target state="translated">サークルドプラス</target>
        </trans-unit>
        <trans-unit id="b2f2ab10cbdb08e806c050f7e4c9abf4807d102e" translate="yes" xml:space="preserve">
          <source>Circled Reverse Solidus</source>
          <target state="translated">サークルドリバースソリダス</target>
        </trans-unit>
        <trans-unit id="7a06e50e7385bdb39935cdfabe9072e82b9447d8" translate="yes" xml:space="preserve">
          <source>Circled Ring Operator</source>
          <target state="translated">サークルドリングオペレータ</target>
        </trans-unit>
        <trans-unit id="3118f0f5bf53391e1d64d00f6fd9c8f83519338c" translate="yes" xml:space="preserve">
          <source>Circled Times</source>
          <target state="translated">サークルドタイムス</target>
        </trans-unit>
        <trans-unit id="e0d7ab77f8105b38fa7df093b28a79c9646ca42a" translate="yes" xml:space="preserve">
          <source>Circled White Bullet</source>
          <target state="translated">丸で囲んだ白い弾丸</target>
        </trans-unit>
        <trans-unit id="9d61e5de58e6dee3981e042fcf23eeed9646f7cf" translate="yes" xml:space="preserve">
          <source>Circled White Star</source>
          <target state="translated">白星</target>
        </trans-unit>
        <trans-unit id="7748321d0967d869f81325b4585f9b2588000677" translate="yes" xml:space="preserve">
          <source>Circularly shift, i.e. rotate, the data in &lt;code&gt;src&lt;/code&gt;, storing the result in &lt;code&gt;dest&lt;/code&gt;. &lt;code&gt;shifts&lt;/code&gt; specifies the amount to shift in each dimension.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; のデータを循環シフト、つまり回転し、結果を &lt;code&gt;dest&lt;/code&gt; に格納します。 &lt;code&gt;shifts&lt;/code&gt; は、各次元でシフトする量を指定します。</target>
        </trans-unit>
        <trans-unit id="d8d1450c5aa55fa70cdef969d2aed9b6bea5b253" translate="yes" xml:space="preserve">
          <source>Circularly shift, i.e. rotate, the data in an array. The second argument is a tuple or vector giving the amount to shift in each dimension, or an integer to shift only in the first dimension.</source>
          <target state="translated">配列内のデータを円形にシフトさせます.2 番目の引数は、各次元でシフトする量を指定するタプルまたはベクトル、または 1 次元のみをシフトする整数です。</target>
        </trans-unit>
        <trans-unit id="a48e6cb43386bd05dea50af46a123ad0d776b80b" translate="yes" xml:space="preserve">
          <source>Circulation Function</source>
          <target state="translated">循環機能</target>
        </trans-unit>
        <trans-unit id="37536a1d3cc9b23bf2b06cce0eca23c6a4e7e102" translate="yes" xml:space="preserve">
          <source>Circus Tent</source>
          <target state="translated">サーカステント</target>
        </trans-unit>
        <trans-unit id="2db191558345453d3d04631fffed018826e9442e" translate="yes" xml:space="preserve">
          <source>Cityscape At Dusk</source>
          <target state="translated">夕暮れの街並み</target>
        </trans-unit>
        <trans-unit id="4010aa5c7daa771d33be51467b1f2b3303269a35" translate="yes" xml:space="preserve">
          <source>Clamp &lt;code&gt;x&lt;/code&gt; between &lt;code&gt;typemin(T)&lt;/code&gt; and &lt;code&gt;typemax(T)&lt;/code&gt; and convert the result to type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; を &lt;code&gt;typemin(T)&lt;/code&gt; と &lt;code&gt;typemax(T)&lt;/code&gt; の間にクランプし、結果をタイプ &lt;code&gt;T&lt;/code&gt; に変換します。</target>
        </trans-unit>
        <trans-unit id="11cf0a77f6ee3236fe15d4a64163013e4f57ac86" translate="yes" xml:space="preserve">
          <source>Clapper Board</source>
          <target state="translated">クランパーボード</target>
        </trans-unit>
        <trans-unit id="1a53c684edaeea21a3a7c9865bbc7c7a6b647d98" translate="yes" xml:space="preserve">
          <source>Clapping Hands Sign</source>
          <target state="translated">拍手サイン</target>
        </trans-unit>
        <trans-unit id="516efc45347d5f1d25705370de6f7e8790454c94" translate="yes" xml:space="preserve">
          <source>Clear any existing backtraces from the internal buffer.</source>
          <target state="translated">内部バッファから既存のバックトレースをクリアします。</target>
        </trans-unit>
        <trans-unit id="82280dd39a2e304ec7a95875634d07334aea409a" translate="yes" xml:space="preserve">
          <source>Clear console screen</source>
          <target state="translated">コンソール画面をクリア</target>
        </trans-unit>
        <trans-unit id="fb1b9ef26d7247fef7acad9f0bc4d393aa69d604" translate="yes" xml:space="preserve">
          <source>Clearly, this is far from the way mathematical integers behave, and you might think it less than ideal for a high-level programming language to expose this to the user. For numerical work where efficiency and transparency are at a premium, however, the alternatives are worse.</source>
          <target state="translated">明らかに、これは数学的な整数の振る舞いとは程遠いものであり、高レベルのプログラミング言語がこれをユーザに公開するのは理想的ではないと思うかもしれません。しかし、効率性と透明性を重視した数値計算の作業では、選択肢はもっと悪いものになってしまいます。</target>
        </trans-unit>
        <trans-unit id="ec4842b9335f240ce519c3e7eb35a6d7dd134038" translate="yes" xml:space="preserve">
          <source>Clears any stored memory allocation data when running julia with &lt;code&gt;--track-allocation&lt;/code&gt;. Execute the command(s) you want to test (to force JIT-compilation), then call &lt;a href=&quot;#Profile.clear_malloc_data&quot;&gt;&lt;code&gt;clear_malloc_data&lt;/code&gt;&lt;/a&gt;. Then execute your command(s) again, quit Julia, and examine the resulting &lt;code&gt;*.mem&lt;/code&gt; files.</source>
          <target state="translated">&lt;code&gt;--track-allocation&lt;/code&gt; を指定してjuliaを実行すると、保存されているメモリ割り当てデータをクリアします。テストするコマンドを実行し（JITコンパイルを強制する）、次に&lt;a href=&quot;#Profile.clear_malloc_data&quot;&gt; &lt;code&gt;clear_malloc_data&lt;/code&gt; &lt;/a&gt;を呼び出します。次に、コマンドを再度実行し、Juliaを終了して、結果の &lt;code&gt;*.mem&lt;/code&gt; ファイルを調べます。</target>
        </trans-unit>
        <trans-unit id="f1508fb36867e2dc32f615b5c14b90813384914e" translate="yes" xml:space="preserve">
          <source>Clears global bindings in modules by initializing them to &lt;code&gt;nothing&lt;/code&gt;. &lt;code&gt;syms&lt;/code&gt; should be of type &lt;a href=&quot;../../base/base/index#Core.Symbol&quot;&gt;&lt;code&gt;Symbol&lt;/code&gt;&lt;/a&gt; or a collection of &lt;code&gt;Symbol&lt;/code&gt;s . &lt;code&gt;pids&lt;/code&gt; and &lt;code&gt;mod&lt;/code&gt; identify the processes and the module in which global variables are to be reinitialized. Only those names found to be defined under &lt;code&gt;mod&lt;/code&gt; are cleared.</source>
          <target state="translated">モジュールのグローバルバインディングを、 &lt;code&gt;nothing&lt;/code&gt; 初期化してクリアします。 &lt;code&gt;syms&lt;/code&gt; は、タイプ&lt;a href=&quot;../../base/base/index#Core.Symbol&quot;&gt; &lt;code&gt;Symbol&lt;/code&gt; &lt;/a&gt;または &lt;code&gt;Symbol&lt;/code&gt; のコレクションでなければなりません。 &lt;code&gt;pids&lt;/code&gt; と &lt;code&gt;mod&lt;/code&gt; は、グローバル変数が再初期化されるプロセスとモジュールを識別します。 &lt;code&gt;mod&lt;/code&gt; で定義されていることが判明した名前のみがクリアされます。</target>
        </trans-unit>
        <trans-unit id="4a37999e16f7842ef3bf129008cd89f6cdc6cb0f" translate="yes" xml:space="preserve">
          <source>Clinking Beer Mugs</source>
          <target state="translated">クリンキングビールのマグカップ</target>
        </trans-unit>
        <trans-unit id="5efe0c9323a499a8546aeac42d4b659bd2a4039f" translate="yes" xml:space="preserve">
          <source>Clipboard</source>
          <target state="translated">Clipboard</target>
        </trans-unit>
        <trans-unit id="80b2a110ce7d7c4741fab08718b7b0bad1a6e22a" translate="yes" xml:space="preserve">
          <source>Clock Face Eight Oclock</source>
          <target state="translated">クロックフェイスエイトオクロック</target>
        </trans-unit>
        <trans-unit id="890e9e574fe3a811e9c99a391d98d07a63fc0336" translate="yes" xml:space="preserve">
          <source>Clock Face Eight-Thirty</source>
          <target state="translated">時計の文字盤エイトサーティ</target>
        </trans-unit>
        <trans-unit id="a9b707e0c691e0552e2f8bc3916fe311413cb1c1" translate="yes" xml:space="preserve">
          <source>Clock Face Eleven Oclock</source>
          <target state="translated">クロックフェイス イレブンオクロック</target>
        </trans-unit>
        <trans-unit id="8ae5c10b2e512ab4d1e9f3ac4882a5accd7c7ae1" translate="yes" xml:space="preserve">
          <source>Clock Face Eleven-Thirty</source>
          <target state="translated">時計の文字盤11-30</target>
        </trans-unit>
        <trans-unit id="e22dfa89a765cf1fb21d2f5d1bc38f3ade0afd76" translate="yes" xml:space="preserve">
          <source>Clock Face Five Oclock</source>
          <target state="translated">クロックフェイス ファイブオクロック</target>
        </trans-unit>
        <trans-unit id="3a7136e9fc05d844d8d22ef7e7a4065f750e1bbb" translate="yes" xml:space="preserve">
          <source>Clock Face Five-Thirty</source>
          <target state="translated">時計の文字盤 5-30</target>
        </trans-unit>
        <trans-unit id="6c604425f0ef3b9a4e6a798a11e9cb980c5f5643" translate="yes" xml:space="preserve">
          <source>Clock Face Four Oclock</source>
          <target state="translated">クロックフェイスフォーオクロック</target>
        </trans-unit>
        <trans-unit id="1d7bba61675982358fbf74be54ea171922d5d085" translate="yes" xml:space="preserve">
          <source>Clock Face Four-Thirty</source>
          <target state="translated">時計の文字盤 4-30</target>
        </trans-unit>
        <trans-unit id="8effbf7e8f00a8276bde132d10680427c2d5ec2c" translate="yes" xml:space="preserve">
          <source>Clock Face Nine Oclock</source>
          <target state="translated">クロックフェイス ナインオクロック</target>
        </trans-unit>
        <trans-unit id="b0f219a4f731970988c8def9f6a9220234b63061" translate="yes" xml:space="preserve">
          <source>Clock Face Nine-Thirty</source>
          <target state="translated">時計の文字盤 9-30</target>
        </trans-unit>
        <trans-unit id="2aa0624b2187d35a495fb74b7a70417ce4d8cdc6" translate="yes" xml:space="preserve">
          <source>Clock Face One Oclock</source>
          <target state="translated">クロックフェイスワンオクロック</target>
        </trans-unit>
        <trans-unit id="92624a0e738083d85292206e98f359ce3546ed05" translate="yes" xml:space="preserve">
          <source>Clock Face One-Thirty</source>
          <target state="translated">時計の文字盤 1-30</target>
        </trans-unit>
        <trans-unit id="4ee4d2dec1cb5fcd6697bd397977fe18c3d4992c" translate="yes" xml:space="preserve">
          <source>Clock Face Seven Oclock</source>
          <target state="translated">クロックフェイス セブンオクロック</target>
        </trans-unit>
        <trans-unit id="17aef1804b57cd3ede0fe80570334485de56eaea" translate="yes" xml:space="preserve">
          <source>Clock Face Seven-Thirty</source>
          <target state="translated">時計の文字盤 セブンサーティ</target>
        </trans-unit>
        <trans-unit id="f2ce5a71eefd68ceefa6e2f6811d47032f42f6eb" translate="yes" xml:space="preserve">
          <source>Clock Face Six Oclock</source>
          <target state="translated">クロックフェイス シックスオクロック</target>
        </trans-unit>
        <trans-unit id="78a9100a5f02623dca735f3dacc48fead261c2cd" translate="yes" xml:space="preserve">
          <source>Clock Face Six-Thirty</source>
          <target state="translated">時計の文字盤六時半</target>
        </trans-unit>
        <trans-unit id="29ed028a4b2d7ccf27a87e9aa08dd08fd6ebb1a6" translate="yes" xml:space="preserve">
          <source>Clock Face Ten Oclock</source>
          <target state="translated">クロックフェイステンオクロック</target>
        </trans-unit>
        <trans-unit id="288b3a0678ebc38844da6df6f1e87880c74baafc" translate="yes" xml:space="preserve">
          <source>Clock Face Ten-Thirty</source>
          <target state="translated">テンサーティ</target>
        </trans-unit>
        <trans-unit id="bb465de467c2b010bb6b846eb78c2a1229522242" translate="yes" xml:space="preserve">
          <source>Clock Face Three Oclock</source>
          <target state="translated">時計の文字盤スリーオクロック</target>
        </trans-unit>
        <trans-unit id="cfd958f3c422c51d841c78b6b7f3d9e44fc3ad75" translate="yes" xml:space="preserve">
          <source>Clock Face Three-Thirty</source>
          <target state="translated">時計の文字盤スリーサーティ</target>
        </trans-unit>
        <trans-unit id="7f669cae21a33d00c881936310a0c78e765a67d2" translate="yes" xml:space="preserve">
          <source>Clock Face Twelve Oclock</source>
          <target state="translated">時計の文字盤12オクロック</target>
        </trans-unit>
        <trans-unit id="1ef2e813447d172d893056c5340a57fc6839f314" translate="yes" xml:space="preserve">
          <source>Clock Face Twelve-Thirty</source>
          <target state="translated">時計の文字盤 12-30</target>
        </trans-unit>
        <trans-unit id="4f6902106020e062d23dd43ecf72cd67020b6c3e" translate="yes" xml:space="preserve">
          <source>Clock Face Two Oclock</source>
          <target state="translated">クロックフェイス ツーオクロック</target>
        </trans-unit>
        <trans-unit id="bcda9b95a7f9d026cc96f88e4ef6597b3948c3f5" translate="yes" xml:space="preserve">
          <source>Clock Face Two-Thirty</source>
          <target state="translated">時計の文字盤 2-30</target>
        </trans-unit>
        <trans-unit id="3343394a9f3b65dd62d440bfd227fa40ca3918a2" translate="yes" xml:space="preserve">
          <source>Clockwise Contour Integral</source>
          <target state="translated">時計回り等高線積分</target>
        </trans-unit>
        <trans-unit id="bef25f4fbfeb987aed2d95c207d8122fa87692e3" translate="yes" xml:space="preserve">
          <source>Clockwise Downwards And Upwards Open Circle Arrows</source>
          <target state="translated">時計回りに下向きに、上向きに開いた円の矢印</target>
        </trans-unit>
        <trans-unit id="b8015a573f0320267e05a1e6968f148a65bd38e5" translate="yes" xml:space="preserve">
          <source>Clockwise Integral</source>
          <target state="translated">時計回りの積分</target>
        </trans-unit>
        <trans-unit id="7dcd16fa461353aaddde398802c410edb65684a9" translate="yes" xml:space="preserve">
          <source>Clockwise Open Circle Arrow</source>
          <target state="translated">時計回りに開いた円の矢印</target>
        </trans-unit>
        <trans-unit id="0de2e9fdaa78d1a87383fa303df054177c3eef28" translate="yes" xml:space="preserve">
          <source>Clockwise Rightwards And Leftwards Open Circle Arrows</source>
          <target state="translated">時計回りに右回り、左回りに開円矢印</target>
        </trans-unit>
        <trans-unit id="78f3f16a08531e7f8a413160ff88e095df7562f2" translate="yes" xml:space="preserve">
          <source>Clockwise Rightwards And Leftwards Open Circle Arrows With Circled One Overlay</source>
          <target state="translated">時計回りに右回り、左回りに丸で囲んだ1つのオーバーレイ付きのオープンサークル矢印</target>
        </trans-unit>
        <trans-unit id="5a2532914552dd4a4df03ca6c532a1cda0ad9c3e" translate="yes" xml:space="preserve">
          <source>Clockwise Top Semicircle Arrow</source>
          <target state="translated">時計回り上半円矢印</target>
        </trans-unit>
        <trans-unit id="bd5a088aabea6d4dfe11cc8a8a32a9c1483fc8dd" translate="yes" xml:space="preserve">
          <source>Clone a remote repository located at &lt;code&gt;repo_url&lt;/code&gt; to the local filesystem location &lt;code&gt;repo_path&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;repo_url&lt;/code&gt; にあるリモートリポジトリをローカルファイルシステムの場所 &lt;code&gt;repo_path&lt;/code&gt; に複製します。</target>
        </trans-unit>
        <trans-unit id="c018fd37cc98046cd18021dbc1501935677a8d0b" translate="yes" xml:space="preserve">
          <source>Clone the remote repository at &lt;code&gt;repo_url&lt;/code&gt; (which can be a remote URL or a path on the local filesystem) to &lt;code&gt;repo_path&lt;/code&gt; (which must be a path on the local filesystem). Options for the clone, such as whether to perform a bare clone or not, are set by &lt;a href=&quot;#LibGit2.CloneOptions&quot;&gt;&lt;code&gt;CloneOptions&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">リモートリポジトリのクローンを &lt;code&gt;repo_url&lt;/code&gt; （リモートURLまたはローカルファイルシステム上のパスにすることができます）で &lt;code&gt;repo_path&lt;/code&gt; （ローカルファイルシステム上のパスにする必要があります）に複製します。ベアクローンを実行するかどうかなど、クローンのオプションは&lt;a href=&quot;#LibGit2.CloneOptions&quot;&gt; &lt;code&gt;CloneOptions&lt;/code&gt; &lt;/a&gt;によって設定されます。</target>
        </trans-unit>
        <trans-unit id="03c26d678d2b5f993e8a4888363c7faf8f7499f8" translate="yes" xml:space="preserve">
          <source>Clong</source>
          <target state="translated">Clong</target>
        </trans-unit>
        <trans-unit id="ba9c34e2f3436e5d9b8a5291e72a776889a2ff30" translate="yes" xml:space="preserve">
          <source>Clonglong</source>
          <target state="translated">Clonglong</target>
        </trans-unit>
        <trans-unit id="b5209dad4d3f1bed9db6402ecbcc5727437490f8" translate="yes" xml:space="preserve">
          <source>Close a channel. An exception (optionally given by &lt;code&gt;excp&lt;/code&gt;), is thrown by:</source>
          <target state="translated">チャネルを閉じます。例外（オプションで &lt;code&gt;excp&lt;/code&gt; で指定）は、次の場合にスローされます。</target>
        </trans-unit>
        <trans-unit id="10c5d49bb09afa0ca8e3334711e18326dcf891af" translate="yes" xml:space="preserve">
          <source>Close an I/O stream. Performs a &lt;a href=&quot;#Base.flush&quot;&gt;&lt;code&gt;flush&lt;/code&gt;&lt;/a&gt; first.</source>
          <target state="translated">I / Oストリームを閉じます。最初に&lt;a href=&quot;#Base.flush&quot;&gt; &lt;code&gt;flush&lt;/code&gt; &lt;/a&gt;実行します。</target>
        </trans-unit>
        <trans-unit id="454adf74b3f6704e85f70c7ddf537bda059f03dd" translate="yes" xml:space="preserve">
          <source>Close shared library referenced by handle.</source>
          <target state="translated">ハンドルで参照される共有ライブラリを閉じます。</target>
        </trans-unit>
        <trans-unit id="8170fa95b5dabb39e3ab1424d8d01e1c3b92e425" translate="yes" xml:space="preserve">
          <source>Closed Book</source>
          <target state="translated">クローズドブック</target>
        </trans-unit>
        <trans-unit id="f01ec4341502afd5ff0fd4449550b0f2d821118a" translate="yes" xml:space="preserve">
          <source>Closed Intersection With Serifs</source>
          <target state="translated">セリフ付きのクローズド交差点</target>
        </trans-unit>
        <trans-unit id="f96d5b0a19b4b209a04614ed2d984814137842d3" translate="yes" xml:space="preserve">
          <source>Closed Lock With Key</source>
          <target state="translated">鍵付きクローズドロック</target>
        </trans-unit>
        <trans-unit id="fc6222181031539686fbc1981c6536202f4eebfd" translate="yes" xml:space="preserve">
          <source>Closed Mailbox With Lowered Flag</source>
          <target state="translated">閉鎖された郵便受けと下げられた旗</target>
        </trans-unit>
        <trans-unit id="675cf6fab44f887f9851bda94e48adbe87600a21" translate="yes" xml:space="preserve">
          <source>Closed Mailbox With Raised Flag</source>
          <target state="translated">旗を掲げたクローズドメールボックス</target>
        </trans-unit>
        <trans-unit id="deb82abc2edb75e5d2559fdc5e14496f68ebe0bb" translate="yes" xml:space="preserve">
          <source>Closed Subset</source>
          <target state="translated">閉じた部分集合</target>
        </trans-unit>
        <trans-unit id="27f828ad61dfe0b96ce6597aa9645041a206cb0a" translate="yes" xml:space="preserve">
          <source>Closed Subset Or Equal To</source>
          <target state="translated">閉じたサブセットまたは等しい</target>
        </trans-unit>
        <trans-unit id="9ca1f162310be3f8fde01956aa333063b943a628" translate="yes" xml:space="preserve">
          <source>Closed Superset</source>
          <target state="translated">クローズドスーパーセット</target>
        </trans-unit>
        <trans-unit id="c1a77c6e35a02621888adfea720e18df739c611e" translate="yes" xml:space="preserve">
          <source>Closed Superset Or Equal To</source>
          <target state="translated">クローズドスーパーセットまたはイコールトゥ</target>
        </trans-unit>
        <trans-unit id="1d0ef3df97ab3df50e949a9a1324005eda6b8edb" translate="yes" xml:space="preserve">
          <source>Closed Umbrella</source>
          <target state="translated">クローズドアンブレラ</target>
        </trans-unit>
        <trans-unit id="2509ab5953079af2e5239350a2c4c20c24bf4b87" translate="yes" xml:space="preserve">
          <source>Closed Union With Serifs</source>
          <target state="translated">セリフ付きクローズドユニオン</target>
        </trans-unit>
        <trans-unit id="f8612daffee734ab8fe7ac27e4779293f47bd9f2" translate="yes" xml:space="preserve">
          <source>Closed Union With Serifs And Smash Product</source>
          <target state="translated">セリフとスマッシュ製品のクローズドユニオン</target>
        </trans-unit>
        <trans-unit id="6d5a3633bf3066d6ab42acadf4720d0c57381f8b" translate="yes" xml:space="preserve">
          <source>Closing a Library</source>
          <target state="translated">図書館の閉館</target>
        </trans-unit>
        <trans-unit id="aaaf708c53d56650e9ea07591d01dc353b945138" translate="yes" xml:space="preserve">
          <source>Closure &lt;a href=&quot;../../base/c/index#Base.@cfunction&quot;&gt;&lt;code&gt;@cfunction&lt;/code&gt;&lt;/a&gt; rely on LLVM trampolines, which are not available on all platforms (for example ARM and PowerPC).</source>
          <target state="translated">Closure &lt;a href=&quot;../../base/c/index#Base.@cfunction&quot;&gt; &lt;code&gt;@cfunction&lt;/code&gt; は&lt;/a&gt;、LLVMトランポリンに依存しています。LLVMトランポリンは、すべてのプラットフォーム（ARMやPowerPCなど）で使用できるわけではありません。</target>
        </trans-unit>
        <trans-unit id="08a1d4177a6fdb9b5f67b13428352c7562697b82" translate="yes" xml:space="preserve">
          <source>Closure cfunctions</source>
          <target state="translated">クロージャー機能</target>
        </trans-unit>
        <trans-unit id="b2efeaa1a7d6d2185ea02473cf758203dfcea3fe" translate="yes" xml:space="preserve">
          <source>Cloud</source>
          <target state="translated">Cloud</target>
        </trans-unit>
        <trans-unit id="ac3f2b0304dbad8004f320d418e21b773f559bef" translate="yes" xml:space="preserve">
          <source>Cluster Cookie</source>
          <target state="translated">クラスタクッキー</target>
        </trans-unit>
        <trans-unit id="2719f92d9319470b062026857b1b798355606f18" translate="yes" xml:space="preserve">
          <source>Cluster Manager Interface</source>
          <target state="translated">クラスタマネージャインタフェース</target>
        </trans-unit>
        <trans-unit id="24b40ea7b4c6d2a2754b767ef66941a1b621105f" translate="yes" xml:space="preserve">
          <source>Cluster Managers with Custom Transports</source>
          <target state="translated">カスタムトランスポートを使用したクラスタ管理者</target>
        </trans-unit>
        <trans-unit id="c66ed07e93160ccf42e9560935c19321d18456bf" translate="yes" xml:space="preserve">
          <source>ClusterManagers</source>
          <target state="translated">ClusterManagers</target>
        </trans-unit>
        <trans-unit id="36a5cc40f84a6918339448f7f9c84d698b78ed22" translate="yes" xml:space="preserve">
          <source>Cmd</source>
          <target state="translated">Cmd</target>
        </trans-unit>
        <trans-unit id="598ac4d5aadd51518cf7408c7b09c93d77fd77bc" translate="yes" xml:space="preserve">
          <source>Cocktail Glass</source>
          <target state="translated">カクテルグラス</target>
        </trans-unit>
        <trans-unit id="adac69379a626c2436948a4ef1792c7d719ef929" translate="yes" xml:space="preserve">
          <source>Code</source>
          <target state="translated">Code</target>
        </trans-unit>
        <trans-unit id="a99f20e7919aa57d6d229cdc49d476b887823796" translate="yes" xml:space="preserve">
          <source>Code Availability and Loading Packages</source>
          <target state="translated">コードの利用可能性とローディングパッケージ</target>
        </trans-unit>
        <trans-unit id="d0078b16e6e193ac2fab2fcfbc625d4cc9fdb7f5" translate="yes" xml:space="preserve">
          <source>Code Generation</source>
          <target state="translated">コード生成</target>
        </trans-unit>
        <trans-unit id="f24dc61405e4a6ac1922198818e95b7dcd3db014" translate="yes" xml:space="preserve">
          <source>Code Loading</source>
          <target state="translated">コードの読み込み</target>
        </trans-unit>
        <trans-unit id="b69ba088ce9ad1ce235332dd2372fe802609e0da" translate="yes" xml:space="preserve">
          <source>Code blocks</source>
          <target state="translated">コードブロック</target>
        </trans-unit>
        <trans-unit id="42113fe2d252dc34afb2007f91d2f4059784abe7" translate="yes" xml:space="preserve">
          <source>Code inclusion is quite straightforward and simple: it evaluates the given source file in the context of the caller. Package loading is built on top of code inclusion and serves a &lt;a href=&quot;../modules/index#modules&quot;&gt;different purpose&lt;/a&gt;. The rest of this chapter focuses on the behavior and mechanics of package loading.</source>
          <target state="translated">コードの組み込みは非常に単純で単純です。呼び出し元のコンテキストで指定されたソースファイルを評価します。パッケージのロードは、コードの包含の上に構築されており、&lt;a href=&quot;../modules/index#modules&quot;&gt;異なる目的&lt;/a&gt;を果たします。この章の残りの部分では、パッケージのロードの動作とメカニズムに焦点を当てます。</target>
        </trans-unit>
        <trans-unit id="62a9d7c94aa1ad1ba8632efb3563e42b2453a554" translate="yes" xml:space="preserve">
          <source>Code inclusion is quite straightforward and simple: it evaluates the given source file in the context of the caller. Package loading is built on top of code inclusion and serves a &lt;a href=&quot;../modules/index#modules-1&quot;&gt;different purpose&lt;/a&gt;. The rest of this chapter focuses on the behavior and mechanics of package loading.</source>
          <target state="translated">コードのインクルードは非常に簡単でシンプルです。呼び出し側のコンテキストで指定されたソースファイルを評価します。パッケージの読み込みはコードインクルードの上に構築され、&lt;a href=&quot;../modules/index#modules-1&quot;&gt;別の目的&lt;/a&gt;を果たします。この章の残りの部分では、パッケージのロードの動作とメカニズムに焦点を当てています。</target>
        </trans-unit>
        <trans-unit id="35b9be6a9b072a2d90be1ca50990262602cae797" translate="yes" xml:space="preserve">
          <source>Code point(s)</source>
          <target state="translated">コードポイント</target>
        </trans-unit>
        <trans-unit id="33284c9a71b782e3478512a7869d4dc33c4b362d" translate="yes" xml:space="preserve">
          <source>Code should be as generic as possible. Instead of writing:</source>
          <target state="translated">コードは可能な限り汎用的なものであるべきです。書くのではなく。</target>
        </trans-unit>
        <trans-unit id="aae5cfaaacaac3a30cf57079dd346c86a7f7fc5e" translate="yes" xml:space="preserve">
          <source>Code using immutable objects can be easier to reason about.</source>
          <target state="translated">不変オブジェクトを使ったコードは、推論しやすくなります。</target>
        </trans-unit>
        <trans-unit id="80674c31d4ab113b84f8bfda79f90e7c65f5531a" translate="yes" xml:space="preserve">
          <source>Collect a list of log records generated by &lt;code&gt;expression&lt;/code&gt; using &lt;code&gt;collect_test_logs&lt;/code&gt;, check that they match the sequence &lt;code&gt;log_patterns&lt;/code&gt;, and return the value of &lt;code&gt;expression&lt;/code&gt;. The &lt;code&gt;keywords&lt;/code&gt; provide some simple filtering of log records: the &lt;code&gt;min_level&lt;/code&gt; keyword controls the minimum log level which will be collected for the test, the &lt;code&gt;match_mode&lt;/code&gt; keyword defines how matching will be performed (the default &lt;code&gt;:all&lt;/code&gt; checks that all logs and patterns match pairwise; use &lt;code&gt;:any&lt;/code&gt; to check that the pattern matches at least once somewhere in the sequence.)</source>
          <target state="translated">&lt;code&gt;collect_test_logs&lt;/code&gt; を使用して &lt;code&gt;expression&lt;/code&gt; によって生成されたログレコードのリストを収集し、それらがシーケンス &lt;code&gt;log_patterns&lt;/code&gt; と一致することを確認して、 &lt;code&gt;expression&lt;/code&gt; の値を返します。 &lt;code&gt;keywords&lt;/code&gt; ：ログレコードのいくつかの簡単なフィルタリングを提供 &lt;code&gt;min_level&lt;/code&gt; キーワードコントロール試験のために収集される最小ログレベル、 &lt;code&gt;match_mode&lt;/code&gt; のマッチングが実行される方法をキーワード定義（デフォルト &lt;code&gt;:all&lt;/code&gt; 使用、すべてのログとパターンがペアワイズと一致することをチェックします &lt;code&gt;:any&lt;/code&gt; は、パターンがシーケンスのどこかで少なくとも1回一致することを確認します。）</target>
        </trans-unit>
        <trans-unit id="0a8af36fa1d1619f2da90f35bd9c11b35a37e433" translate="yes" xml:space="preserve">
          <source>Collect information about the status of each file in the git repository &lt;code&gt;repo&lt;/code&gt; (e.g. is the file modified, staged, etc.). &lt;code&gt;status_opts&lt;/code&gt; can be used to set various options, for instance whether or not to look at untracked files or whether to include submodules or not. See &lt;a href=&quot;#LibGit2.StatusOptions&quot;&gt;&lt;code&gt;StatusOptions&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">gitのリポジトリ内の各ファイルのステータスに関する情報収集 &lt;code&gt;repo&lt;/code&gt; （例えば、段階的、等を変更されたファイルです）。 &lt;code&gt;status_opts&lt;/code&gt; を使用して、追跡されていないファイルを調べるかどうか、サブモジュールを含めるかどうかなど、さまざまなオプションを設定できます。詳細については、&lt;a href=&quot;#LibGit2.StatusOptions&quot;&gt; &lt;code&gt;StatusOptions&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="2e2ef8c695440679e7d61620a3e6f58db57bb36f" translate="yes" xml:space="preserve">
          <source>Collections and Data Structures</source>
          <target state="translated">コレクションとデータ構造</target>
        </trans-unit>
        <trans-unit id="b600a07f6e2a178ebfbe565ac70dc1d11d80d058" translate="yes" xml:space="preserve">
          <source>Collections passed to functions are also not copied. Functions can modify (mutate) the contents of the objects their arguments refer to. (The names of functions which do this are conventionally suffixed with '!'.)</source>
          <target state="translated">関数に渡されたコレクションもコピーされません。関数は引数が参照しているオブジェクトの内容を変更(変異)することができます。(これを行う関数の名前には、慣習的に '!' が付いています)。</target>
        </trans-unit>
        <trans-unit id="7a2802907d31a8ef64806a9e6c2120bb1e4caacf" translate="yes" xml:space="preserve">
          <source>Collision Symbol</source>
          <target state="translated">衝突記号</target>
        </trans-unit>
        <trans-unit id="ac30df75efbedb8442edcd22700caca733d79868" translate="yes" xml:space="preserve">
          <source>Colon</source>
          <target state="translated">Colon</target>
        </trans-unit>
        <trans-unit id="0a14c37ba89fcb5b7168d9ef916ce4e00e67937f" translate="yes" xml:space="preserve">
          <source>Colon Equals / Colon Equal</source>
          <target state="translated">コロン・イコール/コロン・イコール</target>
        </trans-unit>
        <trans-unit id="bb11dae2a053933f6bc7422a2373bf8281b97e57" translate="yes" xml:space="preserve">
          <source>Colons (:) are used to signify indexing entire objects or dimensions at once.</source>
          <target state="translated">コロン(:)は、オブジェクト全体またはディメンションを一度にインデックス化することを示すために使用されます。</target>
        </trans-unit>
        <trans-unit id="f95263d15db043d5d52856caad1fadeda6d1c2bc" translate="yes" xml:space="preserve">
          <source>Combinatorics</source>
          <target state="translated">Combinatorics</target>
        </trans-unit>
        <trans-unit id="5350d59289c3e9b699c68a850143c7c2aca47e8e" translate="yes" xml:space="preserve">
          <source>Combined inplace matrix-matrix or matrix-vector multiply-add $A B &amp;alpha; + C &amp;beta;$. The result is stored in &lt;code&gt;C&lt;/code&gt; by overwriting it. Note that &lt;code&gt;C&lt;/code&gt; must not be aliased with either &lt;code&gt;A&lt;/code&gt; or &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">インプレース行列-行列または行列-ベクトルの乗算の組み合わせ-$AB&amp;alpha;+C&amp;beta;$を追加します。結果は上書きして &lt;code&gt;C&lt;/code&gt; に格納されます。 &lt;code&gt;C&lt;/code&gt; は &lt;code&gt;A&lt;/code&gt; または &lt;code&gt;B&lt;/code&gt; のいずれかでエイリアス化してはならないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="173cad0d0654b3f6eb52faa1ce6c93b0376b3f89" translate="yes" xml:space="preserve">
          <source>Combined multiply-add: computes &lt;code&gt;x*y+z&lt;/code&gt;, but allowing the add and multiply to be merged with each other or with surrounding operations for performance. For example, this may be implemented as an &lt;a href=&quot;#Base.fma&quot;&gt;&lt;code&gt;fma&lt;/code&gt;&lt;/a&gt; if the hardware supports it efficiently. The result can be different on different machines and can also be different on the same machine due to constant propagation or other optimizations. See &lt;a href=&quot;#Base.fma&quot;&gt;&lt;code&gt;fma&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">結合乗算-加算： &lt;code&gt;x*y+z&lt;/code&gt; を計算しますが、加算と乗算を相互に、またはパフォーマンスのために周囲の演算とマージできます。たとえば、ハードウェアが効率的にサポートしている場合、これは&lt;a href=&quot;#Base.fma&quot;&gt; &lt;code&gt;fma&lt;/code&gt; &lt;/a&gt;として実装できます。結果はマシンによって異なる可能性があります。また、一定の伝播やその他の最適化のために、同じマシンでも異なる可能性があります。&lt;a href=&quot;#Base.fma&quot;&gt; &lt;code&gt;fma&lt;/code&gt; を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="b4f01a71c42b25ea3da620732f8db11437dd099b" translate="yes" xml:space="preserve">
          <source>Combining Acute Accent / Non-Spacing Acute</source>
          <target state="translated">急激なアクセントの組み合わせ/非スペーシングな急性の組み合わせ</target>
        </trans-unit>
        <trans-unit id="0734b67961e0eb56239f8b7b60c539fb6834880e" translate="yes" xml:space="preserve">
          <source>Combining Annuity Symbol</source>
          <target state="translated">年金シンボルの組み合わせ</target>
        </trans-unit>
        <trans-unit id="95ae63a999d098981e7621ee2008c43b0f6a60c6" translate="yes" xml:space="preserve">
          <source>Combining Asterisk Above</source>
          <target state="translated">上記のアスタリスクの組み合わせ</target>
        </trans-unit>
        <trans-unit id="685cd2e09ad265192e0356f28e46509d84ab4d71" translate="yes" xml:space="preserve">
          <source>Combining Breve / Non-Spacing Breve</source>
          <target state="translated">ブリーヴの組み合わせ/ノンスペーシングブリーヴ</target>
        </trans-unit>
        <trans-unit id="8e2be6c64a88e84a6f429cab4bdb53ba4fe80660" translate="yes" xml:space="preserve">
          <source>Combining Bridge Below / Non-Spacing Bridge Below</source>
          <target state="translated">下にブリッジを組み合わせる/下にノンスペーシングブリッジを組み合わせる</target>
        </trans-unit>
        <trans-unit id="a3f38dbfee0a0277b8fc6dd5b6eb831595bf84a0" translate="yes" xml:space="preserve">
          <source>Combining Candrabindu / Non-Spacing Candrabindu</source>
          <target state="translated">キャンドラビンドゥを組み合わせる/スペーシングしないキャンドラビンドゥ</target>
        </trans-unit>
        <trans-unit id="8aff768b42edc639adecd3dd04d42d7aed791251" translate="yes" xml:space="preserve">
          <source>Combining Caron / Non-Spacing Hacek</source>
          <target state="translated">カロン/ノンスペーシングヘーチェクの組み合わせ</target>
        </trans-unit>
        <trans-unit id="3c4e117dd5db64357d4d73eb9cdd1ba25f04fdb1" translate="yes" xml:space="preserve">
          <source>Combining Cedilla / Non-Spacing Cedilla</source>
          <target state="translated">セディラの組み合わせ/ノンスペーシングセディラ</target>
        </trans-unit>
        <trans-unit id="91f0dba538ac66d644d07a8387e2e7e115f196c5" translate="yes" xml:space="preserve">
          <source>Combining Circumflex Accent / Non-Spacing Circumflex</source>
          <target state="translated">サーカムフレックスアクセント/ノンスペーシングサーカムフレックスの組み合わせ</target>
        </trans-unit>
        <trans-unit id="a43cbdb97b8f699aa2f8714ed59973b90ec0f295" translate="yes" xml:space="preserve">
          <source>Combining Comma Above Right / Non-Spacing Comma Above Right</source>
          <target state="translated">右上のコンマの組み合わせ/右上のノンスペーシングコンマの組み合わせ</target>
        </trans-unit>
        <trans-unit id="a33ec808d6857cd58bedcf6f6f9afde52f57d4fd" translate="yes" xml:space="preserve">
          <source>Combining Diaeresis / Non-Spacing Diaeresis</source>
          <target state="translated">組み合わせディアレシス/ノンスペーシングディアレシス</target>
        </trans-unit>
        <trans-unit id="becaf6a97e81c19ea9f31b976c527ddc1bbea3ee" translate="yes" xml:space="preserve">
          <source>Combining Dot Above / Non-Spacing Dot Above</source>
          <target state="translated">上のドットを組み合わせる/上のドットをスペーシングしない</target>
        </trans-unit>
        <trans-unit id="d95e2893d2008e3fc0c1b9bc24115f37f1791066" translate="yes" xml:space="preserve">
          <source>Combining Double Acute Accent / Non-Spacing Double Acute</source>
          <target state="translated">二重アクセントの組み合わせ/ノンスペーシング二重アクセントの組み合わせ</target>
        </trans-unit>
        <trans-unit id="f08f92ba4b2bb682dc3e2d5e9c8df57b5dedb3f6" translate="yes" xml:space="preserve">
          <source>Combining Enclosing Circle / Enclosing Circle</source>
          <target state="translated">囲い込みサークル/囲い込みサークルの組み合わせ</target>
        </trans-unit>
        <trans-unit id="83f22c6a001242a5a561f3a7895cf7d7aaaebd0b" translate="yes" xml:space="preserve">
          <source>Combining Enclosing Diamond / Enclosing Diamond</source>
          <target state="translated">エンクロージングダイヤモンド/エンクロージングダイヤモンドの組み合わせ</target>
        </trans-unit>
        <trans-unit id="ec76e2f012d98e1337784adeec747df1b78cf15b" translate="yes" xml:space="preserve">
          <source>Combining Enclosing Square / Enclosing Square</source>
          <target state="translated">囲い込みスクエア/囲い込みスクエアの組み合わせ</target>
        </trans-unit>
        <trans-unit id="efc364102d3ca81f092b677aca701ad08ab10de7" translate="yes" xml:space="preserve">
          <source>Combining Enclosing Upward Pointing Triangle</source>
          <target state="translated">密閉型上向きポインティングトライアングルの組み合わせ</target>
        </trans-unit>
        <trans-unit id="22bab50c74edd0eb4d138ac01ac71ba994064528" translate="yes" xml:space="preserve">
          <source>Combining Four Dots Above / Non-Spacing Four Dots Above</source>
          <target state="translated">上の四つの点を組み合わせる/上の四つの点をスペーシングしない</target>
        </trans-unit>
        <trans-unit id="38e73c84dac801257b0f5e15b8402de9de60fd4a" translate="yes" xml:space="preserve">
          <source>Combining Grave Accent / Non-Spacing Grave</source>
          <target state="translated">お墓のアクセントを組み合わせる/間隔を空けないお墓</target>
        </trans-unit>
        <trans-unit id="fb49a0f3994aaa3fea7e9d53f4e24c6dd93638a6" translate="yes" xml:space="preserve">
          <source>Combining Hook Above / Non-Spacing Hook Above</source>
          <target state="translated">上記フックの組み合わせ/非スペーシングフックの組み合わせ</target>
        </trans-unit>
        <trans-unit id="4cb010ffd9ffa4a05013b3488b30c23afb01fdf1" translate="yes" xml:space="preserve">
          <source>Combining Left Angle Above / Non-Spacing Left Angle Above</source>
          <target state="translated">上記左角の組み合わせ/非スペーシング左角の組み合わせ</target>
        </trans-unit>
        <trans-unit id="08e42cf0385a0528419967690402d2f77fea8ecf" translate="yes" xml:space="preserve">
          <source>Combining Left Arrow Above / Non-Spacing Left Arrow Above</source>
          <target state="translated">左矢印の上/非スペーシング左矢印の上の組み合わせ</target>
        </trans-unit>
        <trans-unit id="877d024a8659b4afa7238332933b7ad143528441" translate="yes" xml:space="preserve">
          <source>Combining Left Arrow Below</source>
          <target state="translated">左矢印の下の組み合わせ</target>
        </trans-unit>
        <trans-unit id="8e6257e591a7e8d45ef0764ba2aea89c01420024" translate="yes" xml:space="preserve">
          <source>Combining Left Harpoon Above / Non-Spacing Left Harpoon Above</source>
          <target state="translated">左ハープーンの上の組み合わせ/ノンスペーシング左ハープーンの上の組み合わせ</target>
        </trans-unit>
        <trans-unit id="98b334c8eb46b8b78fdd86ea856a3c01a529a309" translate="yes" xml:space="preserve">
          <source>Combining Left Right Arrow Above / Non-Spacing Left Right Arrow Above</source>
          <target state="translated">左右矢印の上/非スペーシング左右矢印の上の組み合わせ</target>
        </trans-unit>
        <trans-unit id="cedc5fa73afb530ac1a47e52244635331691700e" translate="yes" xml:space="preserve">
          <source>Combining Left Right Arrow Below</source>
          <target state="translated">左右矢印の下の組み合わせ</target>
        </trans-unit>
        <trans-unit id="3ecd111368eb8e38f96414851bb4b26f50509766" translate="yes" xml:space="preserve">
          <source>Combining Leftwards Harpoon With Barb Downwards</source>
          <target state="translated">左向きの銛と下向きのバーブの組み合わせ</target>
        </trans-unit>
        <trans-unit id="0dfea306ba6d2c2199ba2e9e71aebfc34b9abf34" translate="yes" xml:space="preserve">
          <source>Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay</source>
          <target state="translated">ロングソリッドスオーバーレイ/ノンスペーシングロングスラッシュオーバーレイの組み合わせ</target>
        </trans-unit>
        <trans-unit id="9f887140bfcfd6f9e5fb967ba98a3207c8b16bb7" translate="yes" xml:space="preserve">
          <source>Combining Long Stroke Overlay / Non-Spacing Long Bar Overlay</source>
          <target state="translated">ロングストロークオーバーレイ/ノンスペーシングロングバーオーバーレイの組み合わせ</target>
        </trans-unit>
        <trans-unit id="739259d807921f9f328b7781ee790a60e450a0a1" translate="yes" xml:space="preserve">
          <source>Combining Long Vertical Line Overlay / Non-Spacing Long Vertical Bar Overlay</source>
          <target state="translated">縦長ラインオーバーレイ/ノンスペーシング縦長バーオーバーレイの組み合わせ</target>
        </trans-unit>
        <trans-unit id="2fa244bc31952195840fcfc3a299980dbf801f6f" translate="yes" xml:space="preserve">
          <source>Combining Low Line / Non-Spacing Underscore</source>
          <target state="translated">低線/ノンスペーシングアンダースコアの組み合わせ</target>
        </trans-unit>
        <trans-unit id="bf4b2a4b27fa69268427f002d7db69ac9dc2b07c" translate="yes" xml:space="preserve">
          <source>Combining Macron / Non-Spacing Macron</source>
          <target state="translated">マクロン/ノンスペーシング・マクロンの組み合わせ</target>
        </trans-unit>
        <trans-unit id="a27d4c9bf29370f4faabca36676f0b74743a74d7" translate="yes" xml:space="preserve">
          <source>Combining Ogonek / Non-Spacing Ogonek</source>
          <target state="translated">オゴネクの組み合わせ/ノンスペーシングオゴネク</target>
        </trans-unit>
        <trans-unit id="6d0be0f1d7e1edefb9f72a94ba4677970ba978c9" translate="yes" xml:space="preserve">
          <source>Combining Overline / Non-Spacing Overscore</source>
          <target state="translated">オーバーライン/ノンスペーシング・オーバースコアの組み合わせ</target>
        </trans-unit>
        <trans-unit id="7fad7b377dc7ab955143e3c864e92020afd810c8" translate="yes" xml:space="preserve">
          <source>Combining Palatalized Hook Below / Non-Spacing Palatalized Hook Below</source>
          <target state="translated">下の口蓋付きフックの組み合わせ/下の非スペーシング口蓋付きフックの組み合わせ</target>
        </trans-unit>
        <trans-unit id="a8de9e264b7b283c54023c71a0b50c54c5639e6e" translate="yes" xml:space="preserve">
          <source>Combining Retroflex Hook Below / Non-Spacing Retroflex Hook Below</source>
          <target state="translated">下にレトロフレックスフックを組み合わせる/下にノンスペーシングレトロフレックスフックを組み合わせる</target>
        </trans-unit>
        <trans-unit id="2ba0d1fd66790c9bf8dd50de28c5fd6f05110ed4" translate="yes" xml:space="preserve">
          <source>Combining Right Arrow Above / Non-Spacing Right Arrow Above</source>
          <target state="translated">右矢印の上/非スペーシング右矢印の上の組み合わせ</target>
        </trans-unit>
        <trans-unit id="8a30e8c07ae1959f3cd09497d8080f6227316b77" translate="yes" xml:space="preserve">
          <source>Combining Right Arrow Below</source>
          <target state="translated">右矢印の下の組み合わせ</target>
        </trans-unit>
        <trans-unit id="4befcc9e0a743f1dd40b3e9e50041b9252baebcb" translate="yes" xml:space="preserve">
          <source>Combining Right Harpoon Above / Non-Spacing Right Harpoon Above</source>
          <target state="translated">上の右銛を組み合わせる/上の右銛を非スペーシングにする</target>
        </trans-unit>
        <trans-unit id="aeddc0f0eef5dd1ae0bb9d2d0caf8ade2b689afe" translate="yes" xml:space="preserve">
          <source>Combining Rightwards Harpoon With Barb Downwards</source>
          <target state="translated">右向きの銛と下向きのバーブの組み合わせ</target>
        </trans-unit>
        <trans-unit id="59a9a29108a67d4f908b40c8ecffadfd41391c2c" translate="yes" xml:space="preserve">
          <source>Combining Ring Above / Non-Spacing Ring Above</source>
          <target state="translated">上記リングの組み合わせ/非スペーシングリングの組み合わせ</target>
        </trans-unit>
        <trans-unit id="5111c307faa772b3a9538095159cefe4c37acd0e" translate="yes" xml:space="preserve">
          <source>Combining Three Dots Above / Non-Spacing Three Dots Above</source>
          <target state="translated">上の3つのドットを組み合わせる/上の3つのドットを非スペーシングにする</target>
        </trans-unit>
        <trans-unit id="b28cdba8bdbc1c8dbf325c4c84adf50cfa7b9f07" translate="yes" xml:space="preserve">
          <source>Combining Tilde / Non-Spacing Tilde</source>
          <target state="translated">ティルデ/ノンスペーシングティルデの組み合わせ</target>
        </trans-unit>
        <trans-unit id="415941ac9a1882af5b80885af204940e2087908c" translate="yes" xml:space="preserve">
          <source>Combining Tilde Below / Non-Spacing Tilde Below</source>
          <target state="translated">下のティルデを組み合わせる/下の非スペーシングティルデを組み合わせる</target>
        </trans-unit>
        <trans-unit id="890e5eec0caff7a7e81de77d0eefa045a1434041" translate="yes" xml:space="preserve">
          <source>Combining Triple Underdot</source>
          <target state="translated">トリプルアンダードットの組み合わせ</target>
        </trans-unit>
        <trans-unit id="308897e651f5347eeb783d7242b9d33cce1a8f1b" translate="yes" xml:space="preserve">
          <source>Combining Turned Comma Above / Non-Spacing Turned Comma Above</source>
          <target state="translated">上記の折り返しコンマの組み合わせ/非スペーシングの折り返しコンマの組み合わせ</target>
        </trans-unit>
        <trans-unit id="866e577b99c41379b3aa42c4489796f50fe38cc1" translate="yes" xml:space="preserve">
          <source>Combining Wide Bridge Above</source>
          <target state="translated">上のワイドブリッジを組み合わせる</target>
        </trans-unit>
        <trans-unit id="88113a7dbb8d79749cd6e0f0600302ccfd5aa3c0" translate="yes" xml:space="preserve">
          <source>Combining dot operators with numeric literals can be ambiguous. For example, it is not clear whether &lt;code&gt;1.+x&lt;/code&gt; means &lt;code&gt;1. + x&lt;/code&gt; or &lt;code&gt;1 .+ x&lt;/code&gt;. Therefore this syntax is disallowed, and spaces must be used around the operator in such cases.</source>
          <target state="translated">ドット演算子と数値リテラルを組み合わせると、あいまいになる可能性があります。たとえば、 &lt;code&gt;1 .+ x&lt;/code&gt; &lt;code&gt;1. + x&lt;/code&gt; または &lt;code&gt;1.+x&lt;/code&gt; 意味するかどうかは明確ではありません。したがって、この構文は許可されておらず、そのような場合は演算子の前後にスペースを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="153d7a58b3a3e898fcbdd04c462af308414bd09d" translate="yes" xml:space="preserve">
          <source>Comment</source>
          <target state="translated">Comment</target>
        </trans-unit>
        <trans-unit id="8ddf0393cc298edc03dc88f0719f2655cd0574b7" translate="yes" xml:space="preserve">
          <source>Commit all currently buffered writes to the given stream.</source>
          <target state="translated">現在バッファリングされているすべての書き込みを指定されたストリームにコミットします。</target>
        </trans-unit>
        <trans-unit id="a347aae8b8a9fc1e2f6210e5e5378437485857d4" translate="yes" xml:space="preserve">
          <source>Commit the current patch to the rebase &lt;code&gt;rb&lt;/code&gt;, using &lt;code&gt;sig&lt;/code&gt; as the committer. Is silent if the commit has already been applied.</source>
          <target state="translated">&lt;code&gt;sig&lt;/code&gt; をコミッターとして使用して、現在のパッチをリベース &lt;code&gt;rb&lt;/code&gt; にコミットします。コミットがすでに適用されている場合はサイレントです。</target>
        </trans-unit>
        <trans-unit id="2be9168624323737db43ee381ca8992f9a73de9d" translate="yes" xml:space="preserve">
          <source>Common Operations</source>
          <target state="translated">共通操作</target>
        </trans-unit>
        <trans-unit id="a204c5d42b8380165174afefc8c02b676b132a6b" translate="yes" xml:space="preserve">
          <source>Communicating with Channels</source>
          <target state="translated">チャネルとのコミュニケーション</target>
        </trans-unit>
        <trans-unit id="66508cd4da8f90000c3284eb64d70b8945911d14" translate="yes" xml:space="preserve">
          <source>Compact WY form of the QR factorization</source>
          <target state="translated">QR因数分解のコンパクトなWY形式</target>
        </trans-unit>
        <trans-unit id="6bf1e82b56d17bf4bd651ed651f5ad4b9fb92d04" translate="yes" xml:space="preserve">
          <source>Compare how these results differ:</source>
          <target state="translated">これらの結果がどのように異なるかを比較してください。</target>
        </trans-unit>
        <trans-unit id="3937ff70415e32705a844575737929096286a5fd" translate="yes" xml:space="preserve">
          <source>Compare two strings. Return &lt;code&gt;0&lt;/code&gt; if both strings have the same length and the character at each index is the same in both strings. Return &lt;code&gt;-1&lt;/code&gt; if &lt;code&gt;a&lt;/code&gt; is a prefix of &lt;code&gt;b&lt;/code&gt;, or if &lt;code&gt;a&lt;/code&gt; comes before &lt;code&gt;b&lt;/code&gt; in alphabetical order. Return &lt;code&gt;1&lt;/code&gt; if &lt;code&gt;b&lt;/code&gt; is a prefix of &lt;code&gt;a&lt;/code&gt;, or if &lt;code&gt;b&lt;/code&gt; comes before &lt;code&gt;a&lt;/code&gt; in alphabetical order (technically, lexicographical order by Unicode code points).</source>
          <target state="translated">2つの文字列を比較します。両方の文字列が同じ長さで、各インデックスの文字が両方の文字列で同じ場合は、 &lt;code&gt;0&lt;/code&gt; を返します。戻り値 &lt;code&gt;-1&lt;/code&gt; の場合の接頭辞である &lt;code&gt;b&lt;/code&gt; 、または場合の前に来る &lt;code&gt;b&lt;/code&gt; アルファベット順に。戻る &lt;code&gt;1&lt;/code&gt; もし &lt;code&gt;b&lt;/code&gt; がの接頭辞である場合、または &lt;code&gt;b&lt;/code&gt; が前に来るアルファベット順（Unicodeコードポイントによって技術的には、辞書式順序）で。 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="058bad1213f1f21ce991a75b5be44ee324a930b6" translate="yes" xml:space="preserve">
          <source>Compared to using &lt;a href=&quot;../math/index#Base.range&quot;&gt;&lt;code&gt;range&lt;/code&gt;&lt;/a&gt;, directly constructing a &lt;code&gt;LinRange&lt;/code&gt; should have less overhead but won't try to correct for floating point errors:</source>
          <target state="translated">&lt;a href=&quot;../math/index#Base.range&quot;&gt; &lt;code&gt;range&lt;/code&gt; &lt;/a&gt;を使用する場合と比較して、 &lt;code&gt;LinRange&lt;/code&gt; を直接構築するとオーバーヘッドが少なくなりますが、浮動小数点エラーを修正しようとはしません。</target>
        </trans-unit>
        <trans-unit id="3294837eea456d1d9b5c37c0aa8f59ea86b3c495" translate="yes" xml:space="preserve">
          <source>Comparison &amp;ndash; &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt;, &lt;code&gt;&amp;asymp;&lt;/code&gt; (&lt;a href=&quot;../../base/math/index#Base.isapprox&quot;&gt;&lt;code&gt;isapprox&lt;/code&gt;&lt;/a&gt;), &lt;code&gt;≉&lt;/code&gt;</source>
          <target state="translated">比較- &lt;code&gt;==&lt;/code&gt; 、 &lt;code&gt;!=&lt;/code&gt; 、 &lt;code&gt;&amp;asymp;&lt;/code&gt; （&lt;a href=&quot;../../base/math/index#Base.isapprox&quot;&gt; &lt;code&gt;isapprox&lt;/code&gt; &lt;/a&gt;）、 &lt;code&gt;≉&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5bfbdf2ba206862934e1703fb9dabae9ccfe529b" translate="yes" xml:space="preserve">
          <source>Comparison with &lt;a href=&quot;../../base/base/index#Base.backtrace&quot;&gt;&lt;code&gt;backtrace&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../../base/base/index#Base.backtrace&quot;&gt; &lt;code&gt;backtrace&lt;/code&gt; &lt;/a&gt;比較</target>
        </trans-unit>
        <trans-unit id="e46ee00fde40e955c86abe019a61121e06d653c9" translate="yes" xml:space="preserve">
          <source>Comparisons</source>
          <target state="translated">Comparisons</target>
        </trans-unit>
        <trans-unit id="a1f782aa0dd22ca1d8ddd5007091a2531356eecb" translate="yes" xml:space="preserve">
          <source>Compile the given function &lt;code&gt;f&lt;/code&gt; for the argument tuple (of types) &lt;code&gt;args&lt;/code&gt;, but do not execute it.</source>
          <target state="translated">（型の）引数タプル &lt;code&gt;args&lt;/code&gt; の指定された関数 &lt;code&gt;f&lt;/code&gt; をコンパイルしますが、実行しません。</target>
        </trans-unit>
        <trans-unit id="d208cd655bc27c326dbf72e200351336cfc4e60e" translate="yes" xml:space="preserve">
          <source>Complement</source>
          <target state="translated">Complement</target>
        </trans-unit>
        <trans-unit id="05138c0edd56f7bbbd9cae9c6f481c62b93d161a" translate="yes" xml:space="preserve">
          <source>Completion of paths works for strings and julia's shell mode:</source>
          <target state="translated">パスの完成は文字列とjuliaのシェルモードで動作します。</target>
        </trans-unit>
        <trans-unit id="10b26b96b1c573965f14a325ef88109f84be8e3b" translate="yes" xml:space="preserve">
          <source>Complex</source>
          <target state="translated">Complex</target>
        </trans-unit>
        <trans-unit id="ff549706d081e3e60cc13e4b49b48c707d5b0c58" translate="yes" xml:space="preserve">
          <source>Complex Example</source>
          <target state="translated">複雑な例</target>
        </trans-unit>
        <trans-unit id="c73def212afdc811169afd7e77aebfbeecb5facc" translate="yes" xml:space="preserve">
          <source>Complex Numbers</source>
          <target state="translated">複素数</target>
        </trans-unit>
        <trans-unit id="d92056b9511d12d7ca9a02729b4db7f33b444189" translate="yes" xml:space="preserve">
          <source>Complex and Rational Numbers</source>
          <target state="translated">複素数と有理数</target>
        </trans-unit>
        <trans-unit id="4bf180d1d0870c204edb37eb372ac0df5d17b6dd" translate="yes" xml:space="preserve">
          <source>Complex blocks:</source>
          <target state="translated">複雑なブロック。</target>
        </trans-unit>
        <trans-unit id="0a73edd8fc9653ee436727fd08c0b9f3b06b1113" translate="yes" xml:space="preserve">
          <source>Complex method &quot;cascades&quot; with default arguments</source>
          <target state="translated">デフォルトの引数を持つ複雑なメソッド「カスケード</target>
        </trans-unit>
        <trans-unit id="f9ed4ba22fe6a41d861b48b53689d9f5e1620b3b" translate="yes" xml:space="preserve">
          <source>Complex number type with real and imaginary part of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 型の実数部と虚数部を持つ複素数型。</target>
        </trans-unit>
        <trans-unit id="c92c529e0731c57efd7550480196484040b33c3e" translate="yes" xml:space="preserve">
          <source>Component</source>
          <target state="translated">Component</target>
        </trans-unit>
        <trans-unit id="b4dd6b3b31c6eea3e9660b73bc2f3101abdfba71" translate="yes" xml:space="preserve">
          <source>Compose functions: i.e. &lt;code&gt;(f ∘ g)(args...)&lt;/code&gt; means &lt;code&gt;f(g(args...))&lt;/code&gt;. The &lt;code&gt;∘&lt;/code&gt; symbol can be entered in the Julia REPL (and most editors, appropriately configured) by typing &lt;code&gt;\circ&amp;lt;tab&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">関数の作成：すなわち &lt;code&gt;(f ∘ g)(args...)&lt;/code&gt; は &lt;code&gt;f(g(args...))&lt;/code&gt; 意味します。 &lt;code&gt;∘&lt;/code&gt; 記号が入力することにより、（適切に構成されており、ほとんどの編集者）ジュリアREPLで入力することができます &lt;code&gt;\circ&amp;lt;tab&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7bf0ab10fb9860e23b1ca89e4313be7fafb258f7" translate="yes" xml:space="preserve">
          <source>Composite Types</source>
          <target state="translated">コンポジットタイプ</target>
        </trans-unit>
        <trans-unit id="df2490ae2d6c4446ef7afd32a3da2e5ee7b69ac4" translate="yes" xml:space="preserve">
          <source>Composite objects declared with &lt;code&gt;struct&lt;/code&gt; are &lt;em&gt;immutable&lt;/em&gt;; they cannot be modified after construction. This may seem odd at first, but it has several advantages:</source>
          <target state="translated">&lt;code&gt;struct&lt;/code&gt; で宣言された複合オブジェクトは&lt;em&gt;不変&lt;/em&gt;です。作成後に変更することはできません。これは最初は奇妙に思えるかもしれませんが、いくつかの利点があります。</target>
        </trans-unit>
        <trans-unit id="01e0dcd858e537fe0307f2358a312f03c6681c12" translate="yes" xml:space="preserve">
          <source>Composite types are introduced with the &lt;a href=&quot;../../base/base/index#struct&quot;&gt;&lt;code&gt;struct&lt;/code&gt;&lt;/a&gt; keyword followed by a block of field names, optionally annotated with types using the &lt;code&gt;::&lt;/code&gt; operator:</source>
          <target state="translated">複合型は&lt;a href=&quot;../../base/base/index#struct&quot;&gt; &lt;code&gt;struct&lt;/code&gt; &lt;/a&gt;キーワードで導入され、その後にフィールド名のブロックが続きます。オプションで &lt;code&gt;::&lt;/code&gt; 演算子を使用して型で注釈が付けられます。</target>
        </trans-unit>
        <trans-unit id="9189e65c24f2bdb8de9b12a05127190c54ae9a3c" translate="yes" xml:space="preserve">
          <source>Composite types such as &lt;code&gt;struct&lt;/code&gt; in C or &lt;code&gt;TYPE&lt;/code&gt; in Fortran90 (or &lt;code&gt;STRUCTURE&lt;/code&gt; / &lt;code&gt;RECORD&lt;/code&gt; in some variants of F77), can be mirrored in Julia by creating a &lt;code&gt;struct&lt;/code&gt; definition with the same field layout.</source>
          <target state="translated">Cの &lt;code&gt;struct&lt;/code&gt; やFortran90の &lt;code&gt;TYPE&lt;/code&gt; （またはF77の一部のバリアントでは &lt;code&gt;STRUCTURE&lt;/code&gt; / &lt;code&gt;RECORD&lt;/code&gt; ）などの複合型は、同じフィールドレイアウトで &lt;code&gt;struct&lt;/code&gt; 定義を作成することにより、Juliaでミラーリングできます。</target>
        </trans-unit>
        <trans-unit id="5701f0731819052a01bc826ae56db27fca5211d9" translate="yes" xml:space="preserve">
          <source>Composite types, aka &lt;code&gt;struct&lt;/code&gt; in C or &lt;code&gt;TYPE&lt;/code&gt; in Fortran90 (or &lt;code&gt;STRUCTURE&lt;/code&gt; / &lt;code&gt;RECORD&lt;/code&gt; in some variants of F77), can be mirrored in Julia by creating a &lt;code&gt;struct&lt;/code&gt; definition with the same field layout.</source>
          <target state="translated">複合型、別名Cの &lt;code&gt;struct&lt;/code&gt; またはFortran90の &lt;code&gt;TYPE&lt;/code&gt; （またはF77の一部のバリアントでは &lt;code&gt;STRUCTURE&lt;/code&gt; / &lt;code&gt;RECORD&lt;/code&gt; ）は、同じフィールドレイアウトで &lt;code&gt;struct&lt;/code&gt; 定義を作成することによってJuliaでミラー化できます。</target>
        </trans-unit>
        <trans-unit id="7544d508f3b0902a380eab3d1ae0e5d8d3c1b60c" translate="yes" xml:space="preserve">
          <source>CompositeException</source>
          <target state="translated">CompositeException</target>
        </trans-unit>
        <trans-unit id="79e03922c06b260c57343358b29b8c08b337403a" translate="yes" xml:space="preserve">
          <source>Composition of one function ∘(f) requires at least Julia 1.5.</source>
          <target state="translated">つの関数∘(f)の合成には、少なくとも Julia 1.5 が必要です。</target>
        </trans-unit>
        <trans-unit id="b29eeb6459e95f17b9e773f8892492e90000d531" translate="yes" xml:space="preserve">
          <source>Compound Expressions</source>
          <target state="translated">複合表現</target>
        </trans-unit>
        <trans-unit id="3c63c3a24b2a5e684ce3eb80765c227218a808f0" translate="yes" xml:space="preserve">
          <source>Compound methods are provided, as they provide a measure of efficiency if multiple fields are needed at the same time:</source>
          <target state="translated">複数のフィールドが同時に必要な場合の効率化の尺度として、複合法が提供されています。</target>
        </trans-unit>
        <trans-unit id="ed2ff637c10fb1755e29c0eb2376d67d8e5a91b4" translate="yes" xml:space="preserve">
          <source>Comprehensions</source>
          <target state="translated">Comprehensions</target>
        </trans-unit>
        <trans-unit id="c10ef362f781785063bbb997cd5031a5191aade1" translate="yes" xml:space="preserve">
          <source>Comprehensions can also be written without the enclosing square brackets, producing an object known as a generator. This object can be iterated to produce values on demand, instead of allocating an array and storing them in advance (see &lt;a href=&quot;#Iteration&quot;&gt;Iteration&lt;/a&gt;). For example, the following expression sums a series without allocating memory:</source>
          <target state="translated">内包表記は、角かっこを囲まずに記述して、ジェネレーターと呼ばれるオブジェクトを生成することもできます。この目的ではなく、配列を割り当て、（参照、事前にそれらを格納する、要求に応じて値を生成するために繰り返すことができる&lt;a href=&quot;#Iteration&quot;&gt;反復を&lt;/a&gt;）。たとえば、次の式は、メモリを割り当てずに系列を合計します。</target>
        </trans-unit>
        <trans-unit id="8e547d2519645c376aaf30ba92bb6080596e3ef5" translate="yes" xml:space="preserve">
          <source>Comprehensions can also be written without the enclosing square brackets, producing an object known as a generator. This object can be iterated to produce values on demand, instead of allocating an array and storing them in advance (see &lt;a href=&quot;#Iteration-1&quot;&gt;Iteration&lt;/a&gt;). For example, the following expression sums a series without allocating memory:</source>
          <target state="translated">内包は、大括弧で囲むことなく書くことができ、ジェネレーターと呼ばれるオブジェクトを生成します。このオブジェクトは、配列を割り当てて事前に格納するのではなく、反復して値をオンデマンドで生成することができます（&lt;a href=&quot;#Iteration-1&quot;&gt;Iterationを&lt;/a&gt;参照）。たとえば、次の式は、メモリを割り当てずにシリーズを合計します。</target>
        </trans-unit>
        <trans-unit id="908bf8150b71b44066207c270126a10d2c63b84b" translate="yes" xml:space="preserve">
          <source>Comprehensions provide a general and powerful way to construct arrays. Comprehension syntax is similar to set construction notation in mathematics:</source>
          <target state="translated">理解度は,配列を構築するための一般的で強力な方法を提供します.理解度の構文は、数学の集合構築記法に似ています。</target>
        </trans-unit>
        <trans-unit id="41931e1bad3441e4fffdabe12a675d7a10ef5fe7" translate="yes" xml:space="preserve">
          <source>Compressed Sparse Column (CSC) Sparse Matrix Storage</source>
          <target state="translated">圧縮スパースカラム(CSC)スパースマトリクスストレージ</target>
        </trans-unit>
        <trans-unit id="df6e999370e627bd7fb17556cf85a2f9046d57dd" translate="yes" xml:space="preserve">
          <source>Compute $10^x$.</source>
          <target state="translated">10^x$を計算します。</target>
        </trans-unit>
        <trans-unit id="3440d15eee03e7b747a1a78d06bc04de26352e6b" translate="yes" xml:space="preserve">
          <source>Compute $\cos(\pi x) / x - \sin(\pi x) / (\pi x^2)$ if $x \neq 0$, and $0$ if $x = 0$. This is the derivative of &lt;code&gt;sinc(x)&lt;/code&gt;.</source>
          <target state="translated">$ \ cos（\ pi x）/ x-\ sin（\ pi x）/（\ pi x ^ 2）$（$ x \ neq 0 $の場合）、$ 0 $（$ x = 0 $の場合）を計算します。これは &lt;code&gt;sinc(x)&lt;/code&gt; の導関数です。</target>
        </trans-unit>
        <trans-unit id="641b97c82ee25690f10e6e7742dc51e5d15732ca" translate="yes" xml:space="preserve">
          <source>Compute $\cos(\pi x)$ more accurately than &lt;code&gt;cos(pi*x)&lt;/code&gt;, especially for large &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">特に大きな &lt;code&gt;x&lt;/code&gt; の場合、$ \ cos（\ pi x）$を &lt;code&gt;cos(pi*x)&lt;/code&gt; よりも正確に計算します。</target>
        </trans-unit>
        <trans-unit id="1b6e2580104ead79696c9bd035d3ea44c420e327" translate="yes" xml:space="preserve">
          <source>Compute $\sin(\pi x) / (\pi x)$ if $x \neq 0$, and $1$ if $x = 0$.</source>
          <target state="translated">x $x=0$の場合は、$\sin(pi x)/(\pi x)$を計算し、$x=0$の場合は、$1$を計算します。</target>
        </trans-unit>
        <trans-unit id="5609ddf7e7650835bda46710354a43594cc254bb" translate="yes" xml:space="preserve">
          <source>Compute $\sin(\pi x)$ more accurately than &lt;code&gt;sin(pi*x)&lt;/code&gt;, especially for large &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">特に大きな &lt;code&gt;x&lt;/code&gt; の場合、$ \ sin（\ pi x）$を &lt;code&gt;sin(pi*x)&lt;/code&gt; よりも正確に計算します。</target>
        </trans-unit>
        <trans-unit id="929982bef54c338e6e35e28527b86375aafc50c8" translate="yes" xml:space="preserve">
          <source>Compute $x \times 2^n$.</source>
          <target state="translated">$x \times 2^n$を計算する。</target>
        </trans-unit>
        <trans-unit id="64de6f27384f256461bed9916267c818d5e5214a" translate="yes" xml:space="preserve">
          <source>Compute $x^p \pmod m$.</source>
          <target state="translated">x^pを計算します。</target>
        </trans-unit>
        <trans-unit id="19ceaddf89a47393966a49ad36ca860fe7e80321" translate="yes" xml:space="preserve">
          <source>Compute &lt;code&gt;A / B&lt;/code&gt; in-place and overwriting &lt;code&gt;A&lt;/code&gt; to store the result.</source>
          <target state="translated">計算 &lt;code&gt;A / B&lt;/code&gt; インプレースおよび上書き &lt;code&gt;A&lt;/code&gt; を、結果を格納します。</target>
        </trans-unit>
        <trans-unit id="7f0218a9f1bc487c2b5096445bf17474b3168d25" translate="yes" xml:space="preserve">
          <source>Compute &lt;code&gt;A \ B&lt;/code&gt; in-place and overwriting &lt;code&gt;B&lt;/code&gt; to store the result.</source>
          <target state="translated">&lt;code&gt;A \ B&lt;/code&gt; をインプレースで計算し、 &lt;code&gt;B&lt;/code&gt; を上書きして結果を保存します。</target>
        </trans-unit>
        <trans-unit id="fec3a07dc37940dceabb5be53b362461307a4c1d" translate="yes" xml:space="preserve">
          <source>Compute &lt;code&gt;A \ B&lt;/code&gt; in-place and store the result in &lt;code&gt;Y&lt;/code&gt;, returning the result.</source>
          <target state="translated">&lt;code&gt;A \ B&lt;/code&gt; をインプレースで計算し、結果を &lt;code&gt;Y&lt;/code&gt; に格納して、結果を返します。</target>
        </trans-unit>
        <trans-unit id="98e6c5fec537a69040a39ae887c67e4d70213543" translate="yes" xml:space="preserve">
          <source>Compute a convenient factorization of &lt;code&gt;A&lt;/code&gt;, based upon the type of the input matrix. &lt;code&gt;factorize&lt;/code&gt; checks &lt;code&gt;A&lt;/code&gt; to see if it is symmetric/triangular/etc. if &lt;code&gt;A&lt;/code&gt; is passed as a generic matrix. &lt;code&gt;factorize&lt;/code&gt; checks every element of &lt;code&gt;A&lt;/code&gt; to verify/rule out each property. It will short-circuit as soon as it can rule out symmetry/triangular structure. The return value can be reused for efficient solving of multiple systems. For example: &lt;code&gt;A=factorize(A); x=A\b; y=A\C&lt;/code&gt;.</source>
          <target state="translated">入力行列のタイプに基づいて、 &lt;code&gt;A&lt;/code&gt; の便利な因数分解を計算します。 &lt;code&gt;factorize&lt;/code&gt; は、 &lt;code&gt;A&lt;/code&gt; が対称/三角形/その他であるかどうかを確認します。 &lt;code&gt;A&lt;/code&gt; が一般的な行列として渡される場合。 &lt;code&gt;factorize&lt;/code&gt; は &lt;code&gt;A&lt;/code&gt; のすべての要素をチェックして、各プロパティを検証/除外します。対称性/三角形構造が除外されるとすぐに短絡します。戻り値は、複数のシステムを効率的に解くために再利用できます。例： &lt;code&gt;A=factorize(A); x=A\b; y=A\C&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="081b8630c615f09be39d92a0115c25e75916aff0" translate="yes" xml:space="preserve">
          <source>Compute a type that contains the intersection of &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;S&lt;/code&gt;. Usually this will be the smallest such type or one close to it.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; と &lt;code&gt;S&lt;/code&gt; の共通部分を含む型を計算します。通常、これはそのような最小のタイプまたはそれに近いタイプになります。</target>
        </trans-unit>
        <trans-unit id="db62a7195b361bd27a6ab49b26fc5d995d7a85c5" translate="yes" xml:space="preserve">
          <source>Compute an &lt;code&gt;LDLt&lt;/code&gt; factorization of the real symmetric tridiagonal matrix &lt;code&gt;S&lt;/code&gt; such that &lt;code&gt;S = L*Diagonal(d)*L'&lt;/code&gt; where &lt;code&gt;L&lt;/code&gt; is a unit lower triangular matrix and &lt;code&gt;d&lt;/code&gt; is a vector. The main use of an &lt;code&gt;LDLt&lt;/code&gt; factorization &lt;code&gt;F = ldlt(S)&lt;/code&gt; is to solve the linear system of equations &lt;code&gt;Sx = b&lt;/code&gt; with &lt;code&gt;F\b&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;S = L*Diagonal(d)*L'&lt;/code&gt; ように、実対称三重対角行列 &lt;code&gt;S&lt;/code&gt; の &lt;code&gt;LDLt&lt;/code&gt; 分解を計算します。ここで、 &lt;code&gt;L&lt;/code&gt; は単位下三角行列で、 &lt;code&gt;d&lt;/code&gt; はベクトルです。 &lt;code&gt;LDLt&lt;/code&gt; 分解 &lt;code&gt;F = ldlt(S)&lt;/code&gt; の主な用途は、 &lt;code&gt;F\b&lt;/code&gt; して方程式 &lt;code&gt;Sx = b&lt;/code&gt; 線形システムを解くことです。</target>
        </trans-unit>
        <trans-unit id="5c1ac6c08b678223e4887392c381e9189c7ba93b" translate="yes" xml:space="preserve">
          <source>Compute an integer hash code such that &lt;code&gt;isequal(x,y)&lt;/code&gt; implies &lt;code&gt;hash(x)==hash(y)&lt;/code&gt;. The optional second argument &lt;code&gt;h&lt;/code&gt; is a hash code to be mixed with the result.</source>
          <target state="translated">&lt;code&gt;isequal(x,y)&lt;/code&gt; が &lt;code&gt;hash(x)==hash(y)&lt;/code&gt; を暗示するような整数ハッシュコードを計算します。オプションの2番目の引数 &lt;code&gt;h&lt;/code&gt; は、結果と混合されるハッシュコードです。</target>
        </trans-unit>
        <trans-unit id="79e6e6b92700158abe5cbe60e135ba2eff400933" translate="yes" xml:space="preserve">
          <source>Compute both the minimum and maximum element in a single pass, and return them as a 2-tuple.</source>
          <target state="translated">最小要素と最大要素の両方を1回のパスで計算し、2つのタプルとして返します。</target>
        </trans-unit>
        <trans-unit id="55674d923cbe36a00a2dcb12dc90008788433dbf" translate="yes" xml:space="preserve">
          <source>Compute both the minimum and maximum of &lt;code&gt;f&lt;/code&gt; applied to each element in &lt;code&gt;itr&lt;/code&gt; and return them as a 2-tuple. Only one pass is made over &lt;code&gt;itr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;itr&lt;/code&gt; の各要素に適用される &lt;code&gt;f&lt;/code&gt; の最小値と最大値の両方を計算し、2タプルとして返します。 &lt;code&gt;itr&lt;/code&gt; に対して1つのパスのみが作成されます。</target>
        </trans-unit>
        <trans-unit id="9fc034d752a929a676df33e97329f28013afb4ac" translate="yes" xml:space="preserve">
          <source>Compute cosine of &lt;code&gt;x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is in degrees.</source>
          <target state="translated">計算余弦 &lt;code&gt;x&lt;/code&gt; 、 &lt;code&gt;x&lt;/code&gt; 度です。</target>
        </trans-unit>
        <trans-unit id="2812b6470b645598b89e13c27d80693c2571602e" translate="yes" xml:space="preserve">
          <source>Compute cosine of &lt;code&gt;x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is in radians.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; のコサインを計算します。ここで、 &lt;code&gt;x&lt;/code&gt; はラジアンです。</target>
        </trans-unit>
        <trans-unit id="ed29aab024d008c6bdfa953e7bd9ab905379d015" translate="yes" xml:space="preserve">
          <source>Compute hyperbolic cosine of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; の双曲線余弦を計算します。</target>
        </trans-unit>
        <trans-unit id="ec21c723d13f003816fe96579a7df0d489520259" translate="yes" xml:space="preserve">
          <source>Compute hyperbolic sine of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; の双曲線正弦を計算します。</target>
        </trans-unit>
        <trans-unit id="ac3565a823d4a3efc52e74fc685ed86ae6db58a3" translate="yes" xml:space="preserve">
          <source>Compute hyperbolic tangent of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; の双曲線正接を計算します。</target>
        </trans-unit>
        <trans-unit id="c3738eef2209a39b21f53d71ed43b07f931e624c" translate="yes" xml:space="preserve">
          <source>Compute sine of &lt;code&gt;x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is in degrees.</source>
          <target state="translated">計算正弦 &lt;code&gt;x&lt;/code&gt; 、 &lt;code&gt;x&lt;/code&gt; 度です。</target>
        </trans-unit>
        <trans-unit id="6cf01364af065ae849f27852465a3d3bfe52089d" translate="yes" xml:space="preserve">
          <source>Compute sine of &lt;code&gt;x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is in radians.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; のサインを計算します。ここで、 &lt;code&gt;x&lt;/code&gt; はラジアンです。</target>
        </trans-unit>
        <trans-unit id="c2d206b82e6db8e986bbbf98cbf0eb72129c224a" translate="yes" xml:space="preserve">
          <source>Compute tangent of &lt;code&gt;x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is in degrees.</source>
          <target state="translated">計算接線 &lt;code&gt;x&lt;/code&gt; 、 &lt;code&gt;x&lt;/code&gt; 度です。</target>
        </trans-unit>
        <trans-unit id="202a93fa28b48e329210fdf808f2d1b87daa3ed4" translate="yes" xml:space="preserve">
          <source>Compute tangent of &lt;code&gt;x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is in radians.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; の正接を計算します。ここで、 &lt;code&gt;x&lt;/code&gt; はラジアンです。</target>
        </trans-unit>
        <trans-unit id="f664081b059842ba583be8e317e1608e46a53fd3" translate="yes" xml:space="preserve">
          <source>Compute the &lt;a href=&quot;#LinearAlgebra.LQ&quot;&gt;&lt;code&gt;LQ&lt;/code&gt;&lt;/a&gt; factorization of &lt;code&gt;A&lt;/code&gt;, using the input matrix as a workspace. See also &lt;a href=&quot;#LinearAlgebra.lq&quot;&gt;&lt;code&gt;lq&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">入力行列をワークスペースとして使用して、 &lt;code&gt;A&lt;/code&gt; の&lt;a href=&quot;#LinearAlgebra.LQ&quot;&gt; &lt;code&gt;LQ&lt;/code&gt; &lt;/a&gt;因数分解を計算します。&lt;a href=&quot;#LinearAlgebra.lq&quot;&gt; &lt;code&gt;lq&lt;/code&gt; &lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="0dbf493148049741c81504ff6b4e5ee8560f996f" translate="yes" xml:space="preserve">
          <source>Compute the &lt;code&gt;LQ&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A = LQ&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; の &lt;code&gt;LQ&lt;/code&gt; 分解、 &lt;code&gt;A = LQ&lt;/code&gt; 計算します。</target>
        </trans-unit>
        <trans-unit id="17538b08e9c154c3f5dd62072c8fa0ea05f963fc" translate="yes" xml:space="preserve">
          <source>Compute the &lt;code&gt;LQ&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A = LQ&lt;/code&gt;. &lt;code&gt;tau&lt;/code&gt; contains scalars which parameterize the elementary reflectors of the factorization. &lt;code&gt;tau&lt;/code&gt; must have length greater than or equal to the smallest dimension of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; の &lt;code&gt;LQ&lt;/code&gt; 分解、 &lt;code&gt;A = LQ&lt;/code&gt; 計算します。 &lt;code&gt;tau&lt;/code&gt; には、分解の基本反射鏡をパラメーター化するスカラーが含まれています。 &lt;code&gt;tau&lt;/code&gt; の長さは、 &lt;code&gt;A&lt;/code&gt; の最小の次元以上でなければなりません。</target>
        </trans-unit>
        <trans-unit id="6ad780cc4431af9be511082a782160bff6da4c65" translate="yes" xml:space="preserve">
          <source>Compute the &lt;code&gt;QL&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A = QL&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; の &lt;code&gt;QL&lt;/code&gt; 分解、 &lt;code&gt;A = QL&lt;/code&gt; 計算します。</target>
        </trans-unit>
        <trans-unit id="f7a649b9c569a9a9a900055ad2e3e530ad769e9f" translate="yes" xml:space="preserve">
          <source>Compute the &lt;code&gt;QL&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A = QL&lt;/code&gt;. &lt;code&gt;tau&lt;/code&gt; contains scalars which parameterize the elementary reflectors of the factorization. &lt;code&gt;tau&lt;/code&gt; must have length greater than or equal to the smallest dimension of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; の &lt;code&gt;QL&lt;/code&gt; 分解、 &lt;code&gt;A = QL&lt;/code&gt; 計算します。 &lt;code&gt;tau&lt;/code&gt; には、分解の基本反射鏡をパラメーター化するスカラーが含まれています。 &lt;code&gt;tau&lt;/code&gt; の長さは、 &lt;code&gt;A&lt;/code&gt; の最小の次元以上でなければなりません。</target>
        </trans-unit>
        <trans-unit id="73e05a032664ce6a5bb59d6231727896e0d85677" translate="yes" xml:space="preserve">
          <source>Compute the &lt;code&gt;QR&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A = QR&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; の &lt;code&gt;QR&lt;/code&gt; 分解、 &lt;code&gt;A = QR&lt;/code&gt; 計算します。</target>
        </trans-unit>
        <trans-unit id="bd5939dcb4cf796b127a8200b499f432e4d64b40" translate="yes" xml:space="preserve">
          <source>Compute the &lt;code&gt;QR&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A = QR&lt;/code&gt;. &lt;code&gt;tau&lt;/code&gt; contains scalars which parameterize the elementary reflectors of the factorization. &lt;code&gt;tau&lt;/code&gt; must have length greater than or equal to the smallest dimension of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; の &lt;code&gt;QR&lt;/code&gt; 分解、 &lt;code&gt;A = QR&lt;/code&gt; 計算します。 &lt;code&gt;tau&lt;/code&gt; には、分解の基本反射鏡をパラメーター化するスカラーが含まれています。 &lt;code&gt;tau&lt;/code&gt; の長さは、 &lt;code&gt;A&lt;/code&gt; の最小の次元以上でなければなりません。</target>
        </trans-unit>
        <trans-unit id="14220f2b6c0b60f7df0cde02fa4f1c544028c987" translate="yes" xml:space="preserve">
          <source>Compute the &lt;code&gt;RQ&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A = RQ&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; の &lt;code&gt;RQ&lt;/code&gt; 分解、 &lt;code&gt;A = RQ&lt;/code&gt; 計算します。</target>
        </trans-unit>
        <trans-unit id="861e3be13c33c99b622d41916c8e070553b49f73" translate="yes" xml:space="preserve">
          <source>Compute the &lt;code&gt;RQ&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A = RQ&lt;/code&gt;. &lt;code&gt;tau&lt;/code&gt; contains scalars which parameterize the elementary reflectors of the factorization. &lt;code&gt;tau&lt;/code&gt; must have length greater than or equal to the smallest dimension of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; の &lt;code&gt;RQ&lt;/code&gt; 分解、 &lt;code&gt;A = RQ&lt;/code&gt; 計算します。 &lt;code&gt;tau&lt;/code&gt; には、分解の基本反射鏡をパラメーター化するスカラーが含まれています。 &lt;code&gt;tau&lt;/code&gt; の長さは、 &lt;code&gt;A&lt;/code&gt; の最小の次元以上でなければなりません。</target>
        </trans-unit>
        <trans-unit id="1941b58e1c7afe2d3c77d99152574462461df1db" translate="yes" xml:space="preserve">
          <source>Compute the Bunch-Kaufman &lt;a href=&quot;#footnote-Bunch1977&quot;&gt;[Bunch1977]&lt;/a&gt; factorization of a &lt;code&gt;Symmetric&lt;/code&gt; or &lt;code&gt;Hermitian&lt;/code&gt; matrix &lt;code&gt;A&lt;/code&gt; as $P'*U*D*U'*P$ or $P'*L*D*L'*P$, depending on which triangle is stored in &lt;code&gt;A&lt;/code&gt;, and return a &lt;code&gt;BunchKaufman&lt;/code&gt; object. Note that if &lt;code&gt;A&lt;/code&gt; is complex symmetric then &lt;code&gt;U'&lt;/code&gt; and &lt;code&gt;L'&lt;/code&gt; denote the unconjugated transposes, i.e. &lt;code&gt;transpose(U)&lt;/code&gt; and &lt;code&gt;transpose(L)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Symmetric&lt;/code&gt; 行列または &lt;code&gt;Hermitian&lt;/code&gt; 行列 &lt;code&gt;A&lt;/code&gt; のBunch-Kaufman &lt;a href=&quot;#footnote-Bunch1977&quot;&gt;[Bunch1977]&lt;/a&gt;因数分解を$ P '* U * D * U' * P $または$ P '* L * D * L' * P $として計算します。 &lt;code&gt;A&lt;/code&gt; に格納され、 &lt;code&gt;BunchKaufman&lt;/code&gt; オブジェクトを返します。 &lt;code&gt;A&lt;/code&gt; が複素対称の場合、 &lt;code&gt;U'&lt;/code&gt; と &lt;code&gt;L'&lt;/code&gt; は共役していない転置、つまり &lt;code&gt;transpose(U)&lt;/code&gt; と &lt;code&gt;transpose(L)&lt;/code&gt; を表すことに注意してください。</target>
        </trans-unit>
        <trans-unit id="a24a7193e031893d923ed86bc5db45171f4b4182" translate="yes" xml:space="preserve">
          <source>Compute the Bunch-Kaufman &lt;sup&gt;&lt;a href=&quot;#footnote-Bunch1977&quot; id=&quot;citeref-Bunch1977&quot;&gt;[Bunch1977]&lt;/a&gt;&lt;/sup&gt; factorization of a symmetric or Hermitian matrix &lt;code&gt;A&lt;/code&gt; as &lt;code&gt;P'*U*D*U'*P&lt;/code&gt; or &lt;code&gt;P'*L*D*L'*P&lt;/code&gt;, depending on which triangle is stored in &lt;code&gt;A&lt;/code&gt;, and return a &lt;a href=&quot;#LinearAlgebra.BunchKaufman&quot;&gt;&lt;code&gt;BunchKaufman&lt;/code&gt;&lt;/a&gt; object. Note that if &lt;code&gt;A&lt;/code&gt; is complex symmetric then &lt;code&gt;U'&lt;/code&gt; and &lt;code&gt;L'&lt;/code&gt; denote the unconjugated transposes, i.e. &lt;code&gt;transpose(U)&lt;/code&gt; and &lt;code&gt;transpose(L)&lt;/code&gt;.</source>
          <target state="translated">対称行列またはエルミート行列 &lt;code&gt;A&lt;/code&gt; のBunch-Kaufman &lt;sup&gt;&lt;a href=&quot;#footnote-Bunch1977&quot; id=&quot;citeref-Bunch1977&quot;&gt;[Bunch1977]&lt;/a&gt;&lt;/sup&gt;因数分解を、 &lt;code&gt;A&lt;/code&gt; に格納されている三角形に応じて、 &lt;code&gt;P'*U*D*U'*P&lt;/code&gt; または &lt;code&gt;P'*L*D*L'*P&lt;/code&gt; として計算します。そして、&lt;a href=&quot;#LinearAlgebra.BunchKaufman&quot;&gt; &lt;code&gt;BunchKaufman&lt;/code&gt; &lt;/a&gt;オブジェクトを返します。 &lt;code&gt;A&lt;/code&gt; が複素対称の場合、 &lt;code&gt;U'&lt;/code&gt; と &lt;code&gt;L'&lt;/code&gt; は非共役転置、つまり &lt;code&gt;transpose(U)&lt;/code&gt; と &lt;code&gt;transpose(L)&lt;/code&gt; 表すことに注意してください。</target>
        </trans-unit>
        <trans-unit id="8adc6e0822f31506444311768e4f6ded0f9f1c41" translate="yes" xml:space="preserve">
          <source>Compute the CRC-32c checksum of the given &lt;code&gt;data&lt;/code&gt;, which can be an &lt;code&gt;Array{UInt8}&lt;/code&gt;, a contiguous subarray thereof, or a &lt;code&gt;String&lt;/code&gt;. Optionally, you can pass a starting &lt;code&gt;crc&lt;/code&gt; integer to be mixed in with the checksum. The &lt;code&gt;crc&lt;/code&gt; parameter can be used to compute a checksum on data divided into chunks: performing &lt;code&gt;crc32c(data2, crc32c(data1))&lt;/code&gt; is equivalent to the checksum of &lt;code&gt;[data1; data2]&lt;/code&gt;. (Technically, a little-endian checksum is computed.)</source>
          <target state="translated">指定された &lt;code&gt;data&lt;/code&gt; のCRC-32cチェックサムを計算します。これは、 &lt;code&gt;Array{UInt8}&lt;/code&gt; 、その連続したサブアレイ、または &lt;code&gt;String&lt;/code&gt; にすることができます。オプションで、チェックサムと混合される開始 &lt;code&gt;crc&lt;/code&gt; 整数を渡すことができます。 &lt;code&gt;crc&lt;/code&gt; パラメータはチャンクに分割されたデータのチェックサムを計算するために使用することができる。行う &lt;code&gt;crc32c(data2, crc32c(data1))&lt;/code&gt; のチェックサムと等価である &lt;code&gt;[data1; data2]&lt;/code&gt; 。 （技術的には、リトルエンディアンチェックサムが計算されます。）</target>
        </trans-unit>
        <trans-unit id="451fab004d9b252be766b8c8da0ec9401bcb730d" translate="yes" xml:space="preserve">
          <source>Compute the Cholesky factorization of a dense symmetric positive definite matrix &lt;code&gt;A&lt;/code&gt; and return a &lt;a href=&quot;#LinearAlgebra.Cholesky&quot;&gt;&lt;code&gt;Cholesky&lt;/code&gt;&lt;/a&gt; factorization. The matrix &lt;code&gt;A&lt;/code&gt; can either be a &lt;a href=&quot;#LinearAlgebra.Symmetric&quot;&gt;&lt;code&gt;Symmetric&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#LinearAlgebra.Hermitian&quot;&gt;&lt;code&gt;Hermitian&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;../../base/arrays/index#Base.StridedMatrix&quot;&gt;&lt;code&gt;StridedMatrix&lt;/code&gt;&lt;/a&gt; or a &lt;em&gt;perfectly&lt;/em&gt; symmetric or Hermitian &lt;code&gt;StridedMatrix&lt;/code&gt;. The triangular Cholesky factor can be obtained from the factorization &lt;code&gt;F&lt;/code&gt; with: &lt;code&gt;F.L&lt;/code&gt; and &lt;code&gt;F.U&lt;/code&gt;. The following functions are available for &lt;code&gt;Cholesky&lt;/code&gt; objects: &lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt;&lt;code&gt;size&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;\&lt;/code&gt;, &lt;code&gt;inv&lt;/code&gt;, &lt;a href=&quot;#LinearAlgebra.det&quot;&gt;&lt;code&gt;det&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#LinearAlgebra.logdet&quot;&gt;&lt;code&gt;logdet&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#LinearAlgebra.isposdef&quot;&gt;&lt;code&gt;isposdef&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">緻密対称正定値行列のコレスキー分解計算 &lt;code&gt;A&lt;/code&gt; をと戻り&lt;a href=&quot;#LinearAlgebra.Cholesky&quot;&gt; &lt;code&gt;Cholesky&lt;/code&gt; &lt;/a&gt;分解を。行列 &lt;code&gt;A&lt;/code&gt; は、&lt;a href=&quot;#LinearAlgebra.Symmetric&quot;&gt; &lt;code&gt;Symmetric&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;#LinearAlgebra.Hermitian&quot;&gt; &lt;code&gt;Hermitian&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;../../base/arrays/index#Base.StridedMatrix&quot;&gt; &lt;code&gt;StridedMatrix&lt;/code&gt; 、&lt;/a&gt;または&lt;em&gt;完全&lt;/em&gt;対称またはエルミート &lt;code&gt;StridedMatrix&lt;/code&gt; のいずれかです。三角形のコレスキー因子は、 &lt;code&gt;F.L&lt;/code&gt; と &lt;code&gt;F.U&lt;/code&gt; を使用して因数分解 &lt;code&gt;F&lt;/code&gt; から取得できます。 &lt;code&gt;Cholesky&lt;/code&gt; オブジェクトでは、次の関数を使用できます：&lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt; &lt;code&gt;size&lt;/code&gt; &lt;/a&gt;、 &lt;code&gt;\&lt;/code&gt; 、 &lt;code&gt;inv&lt;/code&gt; 、&lt;a href=&quot;#LinearAlgebra.det&quot;&gt; &lt;code&gt;det&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#LinearAlgebra.logdet&quot;&gt; &lt;code&gt;logdet&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;#LinearAlgebra.isposdef&quot;&gt; &lt;code&gt;isposdef&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="633c320407bd275302d618eed24d78f3e652466b" translate="yes" xml:space="preserve">
          <source>Compute the Cholesky factorization of a dense symmetric positive definite matrix &lt;code&gt;A&lt;/code&gt; and return a &lt;code&gt;Cholesky&lt;/code&gt; factorization. The matrix &lt;code&gt;A&lt;/code&gt; can either be a &lt;a href=&quot;#LinearAlgebra.Symmetric&quot;&gt;&lt;code&gt;Symmetric&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#LinearAlgebra.Hermitian&quot;&gt;&lt;code&gt;Hermitian&lt;/code&gt;&lt;/a&gt;&lt;code&gt;StridedMatrix&lt;/code&gt; or a &lt;em&gt;perfectly&lt;/em&gt; symmetric or Hermitian &lt;code&gt;StridedMatrix&lt;/code&gt;. The triangular Cholesky factor can be obtained from the factorization &lt;code&gt;F&lt;/code&gt; with: &lt;code&gt;F.L&lt;/code&gt; and &lt;code&gt;F.U&lt;/code&gt;. The following functions are available for &lt;code&gt;Cholesky&lt;/code&gt; objects: &lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt;&lt;code&gt;size&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;\&lt;/code&gt;, &lt;code&gt;inv&lt;/code&gt;, &lt;a href=&quot;#LinearAlgebra.det&quot;&gt;&lt;code&gt;det&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#LinearAlgebra.logdet&quot;&gt;&lt;code&gt;logdet&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#LinearAlgebra.isposdef&quot;&gt;&lt;code&gt;isposdef&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">緻密対称正定値行列のコレスキー分解計算 &lt;code&gt;A&lt;/code&gt; をと戻り &lt;code&gt;Cholesky&lt;/code&gt; 分解を。行列 &lt;code&gt;A&lt;/code&gt; は、&lt;a href=&quot;#LinearAlgebra.Symmetric&quot;&gt; &lt;code&gt;Symmetric&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;#LinearAlgebra.Hermitian&quot;&gt; &lt;code&gt;Hermitian&lt;/code&gt; &lt;/a&gt; &lt;code&gt;StridedMatrix&lt;/code&gt; 、または&lt;em&gt;完全に&lt;/em&gt;対称またはエルミート &lt;code&gt;StridedMatrix&lt;/code&gt; のいずれかです。三角形のコレスキー因子は、分解 &lt;code&gt;F&lt;/code&gt; から &lt;code&gt;F.L&lt;/code&gt; および &lt;code&gt;F.U&lt;/code&gt; して取得できます。次の関数は、 &lt;code&gt;Cholesky&lt;/code&gt; オブジェクトで使用できます：&lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt; &lt;code&gt;size&lt;/code&gt; &lt;/a&gt;、 &lt;code&gt;\&lt;/code&gt; 、 &lt;code&gt;inv&lt;/code&gt; 、&lt;a href=&quot;#LinearAlgebra.det&quot;&gt; &lt;code&gt;det&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#LinearAlgebra.logdet&quot;&gt; &lt;code&gt;logdet&lt;/code&gt; &lt;/a&gt;そして&lt;a href=&quot;#LinearAlgebra.isposdef&quot;&gt; &lt;code&gt;isposdef&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bb3253df25b3b67c97f210c72aa2a93261e457fb" translate="yes" xml:space="preserve">
          <source>Compute the Hessenberg decomposition of &lt;code&gt;A&lt;/code&gt; and return a &lt;code&gt;Hessenberg&lt;/code&gt; object. If &lt;code&gt;F&lt;/code&gt; is the factorization object, the unitary matrix can be accessed with &lt;code&gt;F.Q&lt;/code&gt; (of type &lt;code&gt;LinearAlgebra.HessenbergQ&lt;/code&gt;) and the Hessenberg matrix with &lt;code&gt;F.H&lt;/code&gt; (of type &lt;a href=&quot;#LinearAlgebra.UpperHessenberg&quot;&gt;&lt;code&gt;UpperHessenberg&lt;/code&gt;&lt;/a&gt;), either of which may be converted to a regular matrix with &lt;code&gt;Matrix(F.H)&lt;/code&gt; or &lt;code&gt;Matrix(F.Q)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; のヘッセンベルグ分解を計算し、ヘッセン &lt;code&gt;Hessenberg&lt;/code&gt; オブジェクトを返します。場合 &lt;code&gt;F&lt;/code&gt; は、分解物である、ユニタリ行列を用いてアクセスすることができる &lt;code&gt;F.Q&lt;/code&gt; （タイプの &lt;code&gt;LinearAlgebra.HessenbergQ&lt;/code&gt; ）でヘッセンベルグ行列 &lt;code&gt;F.H&lt;/code&gt; （タイプの&lt;a href=&quot;#LinearAlgebra.UpperHessenberg&quot;&gt; &lt;code&gt;UpperHessenberg&lt;/code&gt; &lt;/a&gt;）との定期的なマトリックスに変換することができるいずれもの &lt;code&gt;Matrix(F.H)&lt;/code&gt; または &lt;code&gt;Matrix(F.Q)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="37b962efd94ea393def73078100fff01edd4aab9" translate="yes" xml:space="preserve">
          <source>Compute the Hessenberg decomposition of &lt;code&gt;A&lt;/code&gt; and return a &lt;code&gt;Hessenberg&lt;/code&gt; object. If &lt;code&gt;F&lt;/code&gt; is the factorization object, the unitary matrix can be accessed with &lt;code&gt;F.Q&lt;/code&gt; and the Hessenberg matrix with &lt;code&gt;F.H&lt;/code&gt;. When &lt;code&gt;Q&lt;/code&gt; is extracted, the resulting type is the &lt;code&gt;HessenbergQ&lt;/code&gt; object, and may be converted to a regular matrix with &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert(Array, _)&lt;/code&gt;&lt;/a&gt; (or &lt;code&gt;Array(_)&lt;/code&gt; for short).</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; のヘッセンベルク分解を計算し、ヘッセン &lt;code&gt;Hessenberg&lt;/code&gt; オブジェクトを返します。場合 &lt;code&gt;F&lt;/code&gt; は、分解物である、ユニタリ行列を用いてアクセスすることができる &lt;code&gt;F.Q&lt;/code&gt; とを有するヘッセンベルグ行列 &lt;code&gt;F.H&lt;/code&gt; 。場合 &lt;code&gt;Q&lt;/code&gt; が抽出され、結果の型は &lt;code&gt;HessenbergQ&lt;/code&gt; のオブジェクト、およびとの定期的なマトリックスに変換することができる&lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert(Array, _)&lt;/code&gt; &lt;/a&gt;（又は &lt;code&gt;Array(_)&lt;/code&gt; 短いため）。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
