<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="julia">
    <body>
      <group id="julia">
        <trans-unit id="37376ba231ea09d81df1a6ce675e26bfeb779597" translate="yes" xml:space="preserve">
          <source>Then the internal methods &lt;code&gt;_fA&lt;/code&gt; and &lt;code&gt;_fB&lt;/code&gt; can dispatch on &lt;code&gt;y&lt;/code&gt; without concern about ambiguities with each other with respect to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">次に、内部メソッド &lt;code&gt;_fA&lt;/code&gt; および &lt;code&gt;_fB&lt;/code&gt; は、 &lt;code&gt;x&lt;/code&gt; に関する互いのあいまいさを気にすることなく、 &lt;code&gt;y&lt;/code&gt; にディスパッチできます。</target>
        </trans-unit>
        <trans-unit id="8a87872d7de61942177513edb4dd2621b2f6b9fd" translate="yes" xml:space="preserve">
          <source>Then, replace the main() function in the project with this code:</source>
          <target state="translated">そして、プロジェクト内のmain()関数をこのコードに置き換えます。</target>
        </trans-unit>
        <trans-unit id="a59a7debbc5dd22ea37ee07cde6e2c750243ab3c" translate="yes" xml:space="preserve">
          <source>There Does Not Exist</source>
          <target state="translated">存在しない</target>
        </trans-unit>
        <trans-unit id="174782af6882dfdbfbff70b32afe8068951f600e" translate="yes" xml:space="preserve">
          <source>There Exists</source>
          <target state="translated">存在する</target>
        </trans-unit>
        <trans-unit id="f661b9bec6d9caa654535733d72b2847ffe7c84b" translate="yes" xml:space="preserve">
          <source>There also exists a macro &lt;a href=&quot;../../base/base/index#Base.@macroexpand&quot;&gt;&lt;code&gt;@macroexpand&lt;/code&gt;&lt;/a&gt; that is perhaps a bit more convenient than the &lt;code&gt;macroexpand&lt;/code&gt; function:</source>
          <target state="translated">また、おそらく &lt;code&gt;macroexpand&lt;/code&gt; 関数よりも少し便利なマクロ&lt;a href=&quot;../../base/base/index#Base.@macroexpand&quot;&gt; &lt;code&gt;@macroexpand&lt;/code&gt; &lt;/a&gt;マクロ展開が存在します。</target>
        </trans-unit>
        <trans-unit id="3ed131b34b67efd7bcdc68ef678577fe7e39a368" translate="yes" xml:space="preserve">
          <source>There are a few more methods we can extend to give Julia more information about this iterable collection. We know that the elements in a &lt;code&gt;Squares&lt;/code&gt; sequence will always be &lt;code&gt;Int&lt;/code&gt;. By extending the &lt;a href=&quot;../../base/collections/index#Base.eltype&quot;&gt;&lt;code&gt;eltype&lt;/code&gt;&lt;/a&gt; method, we can give that information to Julia and help it make more specialized code in the more complicated methods. We also know the number of elements in our sequence, so we can extend &lt;a href=&quot;../../base/collections/index#Base.length&quot;&gt;&lt;code&gt;length&lt;/code&gt;&lt;/a&gt;, too:</source>
          <target state="translated">Juliaにこの反復可能なコレクションに関する詳細情報を提供するために拡張できるメソッドがいくつかあります。 &lt;code&gt;Squares&lt;/code&gt; シーケンスの要素は常に &lt;code&gt;Int&lt;/code&gt; になることがわかっています。&lt;a href=&quot;../../base/collections/index#Base.eltype&quot;&gt; &lt;code&gt;eltype&lt;/code&gt; &lt;/a&gt;メソッドを拡張することにより、その情報をJuliaに提供し、より複雑なメソッドでより専門的なコードを作成できるようにします。シーケンスの要素数もわかっているので、&lt;a href=&quot;../../base/collections/index#Base.length&quot;&gt; &lt;code&gt;length&lt;/code&gt; &lt;/a&gt;も拡張できます。</target>
        </trans-unit>
        <trans-unit id="e637cf035706fa4551de012038849a438d7502e7" translate="yes" xml:space="preserve">
          <source>There are a few noteworthy high-level features about Julia's strings:</source>
          <target state="translated">ジュリアの弦については、注目すべき高レベルの特徴がいくつかあります。</target>
        </trans-unit>
        <trans-unit id="34b3b70591c85cc9c9daac918201c51d400becd5" translate="yes" xml:space="preserve">
          <source>There are a few specific limitations and warnings to be aware of when using threads in Julia:</source>
          <target state="translated">Julia でスレッドを使用する際に注意すべき制限と警告がいくつかあります。</target>
        </trans-unit>
        <trans-unit id="8f24a9d06c3582bc696ff9d33986f227daf0b74d" translate="yes" xml:space="preserve">
          <source>There are a number useful features unique to interactive work. In addition to showing the result, the REPL also binds the result to the variable &lt;code&gt;ans&lt;/code&gt;. A trailing semicolon on the line can be used as a flag to suppress showing the result.</source>
          <target state="translated">インタラクティブな作業に固有の便利な機能がいくつかあります。REPLは結果を表示するだけでなく、結果を変数 &lt;code&gt;ans&lt;/code&gt; にバインドします。行の末尾のセミコロンは、結果の表示を抑制するフラグとして使用できます。</target>
        </trans-unit>
        <trans-unit id="bd609a022f57cae38b5deceaa4789ea9e71b2150" translate="yes" xml:space="preserve">
          <source>There are also two variants with a &lt;code&gt;mime&lt;/code&gt; argument (a MIME type string, such as &lt;code&gt;&quot;image/png&quot;&lt;/code&gt;), which attempt to display &lt;code&gt;x&lt;/code&gt; using the requested MIME type &lt;em&gt;only&lt;/em&gt;, throwing a &lt;code&gt;MethodError&lt;/code&gt; if this type is not supported by either the display(s) or by &lt;code&gt;x&lt;/code&gt;. With these variants, one can also supply the &quot;raw&quot; data in the requested MIME type by passing &lt;code&gt;x::AbstractString&lt;/code&gt; (for MIME types with text-based storage, such as text/html or application/postscript) or &lt;code&gt;x::Vector{UInt8}&lt;/code&gt; (for binary MIME types).</source>
          <target state="translated">&lt;code&gt;mime&lt;/code&gt; 引数（ &lt;code&gt;&quot;image/png&quot;&lt;/code&gt; などのMIMEタイプの文字列）を持つ2つのバリアントもあります。これらは、要求されたMIMEタイプ&lt;em&gt;のみ&lt;/em&gt;を使用して &lt;code&gt;x&lt;/code&gt; を表示しようとし、このタイプがどちらのディスプレイでもサポートされていない場合に &lt;code&gt;MethodError&lt;/code&gt; をスローします（ s）または &lt;code&gt;x&lt;/code&gt; による。これらのバリアントでは、 &lt;code&gt;x::AbstractString&lt;/code&gt; （text / htmlやapplication / postscriptなどのテキストベースのストレージを持つMIMEタイプの場合）または &lt;code&gt;x::Vector{UInt8}&lt;/code&gt; を渡すことで、要求されたMIMEタイプの「生」データを提供することもできます。UInt8}（バイナリMIMEタイプの場合）。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="da6a42179d7b850f29255071dd5215f3813868d7" translate="yes" xml:space="preserve">
          <source>There are currently four sorting algorithms available in base Julia:</source>
          <target state="translated">現在、Juliaベースでは4つのソートアルゴリズムが利用可能です。</target>
        </trans-unit>
        <trans-unit id="f7b934f4e2dd58131955f021068fd71f3d77a05f" translate="yes" xml:space="preserve">
          <source>There are differences between &lt;code&gt;@macroexpand&lt;/code&gt; and &lt;a href=&quot;#Base.macroexpand&quot;&gt;&lt;code&gt;macroexpand&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;@macroexpand&lt;/code&gt; と&lt;a href=&quot;#Base.macroexpand&quot;&gt; &lt;code&gt;macroexpand&lt;/code&gt; に&lt;/a&gt;は違いがあります。</target>
        </trans-unit>
        <trans-unit id="04c5ce881d71fd5eb88fb1f43a2852a100537a0d" translate="yes" xml:space="preserve">
          <source>There are four general kinds of cases where constructors differ from &lt;code&gt;convert&lt;/code&gt;:</source>
          <target state="translated">コンストラクターが &lt;code&gt;convert&lt;/code&gt; と異なる一般的なケースは4つあります。</target>
        </trans-unit>
        <trans-unit id="28b7763a452b0a0124e162d0088e4f9f3b24f691" translate="yes" xml:space="preserve">
          <source>There are many more interesting things that you can measure about your program, to get a comprehensive list please read the &lt;a href=&quot;http://www.brendangregg.com/perf.html&quot;&gt;Linux perf examples page&lt;/a&gt;.</source>
          <target state="translated">プログラムについて測定できるさらに多くの興味深い事柄があり&lt;a href=&quot;http://www.brendangregg.com/perf.html&quot;&gt;ます&lt;/a&gt;。包括的なリストを取得するには、Linuxのパフォーマンス例のページをご覧ください。</target>
        </trans-unit>
        <trans-unit id="d680424432e24c9faadefbc8f1cb532ede6d65ad" translate="yes" xml:space="preserve">
          <source>There are no classes in Julia. Instead they are structures (mutable or immutable), containing data but no methods.</source>
          <target state="translated">ジュリアにはクラスはありません。その代わりに、構造体 (mutable or immutable)であり、データは含まれていますが、メソッドは含まれていません。</target>
        </trans-unit>
        <trans-unit id="e179a904cbafe3721438ffeb346220f23d78177e" translate="yes" xml:space="preserve">
          <source>There are of course a few exceptions. For example, in &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt;, the type should always come first. In &lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt;&lt;code&gt;setindex!&lt;/code&gt;&lt;/a&gt;, the value comes before the indices so that the indices can be provided as varargs.</source>
          <target state="translated">もちろん、いくつかの例外があります。たとえば、&lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt;では、型が常に最初に来る必要があります。では&lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt; &lt;code&gt;setindex!&lt;/code&gt; &lt;/a&gt;、値がインデックスの前に来るため、インデックスを可変引数として提供できます。</target>
        </trans-unit>
        <trans-unit id="35f0957d73c0fe5b71dd1c5c8bdab57684e38edf" translate="yes" xml:space="preserve">
          <source>There are several different ways to think about this iterator wrapper:</source>
          <target state="translated">このイテレータのラッパーについては、いくつかの異なる考え方があります。</target>
        </trans-unit>
        <trans-unit id="bbb07cbd34fbfc1d048df46439a5fa70e66eefad" translate="yes" xml:space="preserve">
          <source>There are several special types to be aware of, as no other type can be defined to behave the same:</source>
          <target state="translated">同じように振る舞うタイプは他には定義できないので、いくつかの特別なタイプがあるので注意が必要です。</target>
        </trans-unit>
        <trans-unit id="9288c1a0f0901c4cadcdfe9e40efa95dc47fcf27" translate="yes" xml:space="preserve">
          <source>There are situations when you want to construct a string or use string semantics, but the behavior of the standard string construct is not quite what is needed. For these kinds of situations, Julia provides &lt;a href=&quot;#non-standard-string-literals&quot;&gt;non-standard string literals&lt;/a&gt;. A non-standard string literal looks like a regular double-quoted string literal, but is immediately prefixed by an identifier, and doesn't behave quite like a normal string literal. Regular expressions, byte array literals and version number literals, as described below, are some examples of non-standard string literals. Other examples are given in the &lt;a href=&quot;../metaprogramming/index#Metaprogramming&quot;&gt;Metaprogramming&lt;/a&gt; section.</source>
          <target state="translated">文字列を作成したり、文字列セマンティクスを使用したりする場合がありますが、標準の文字列構成の動作は、必要なものとはまったく異なります。このような状況では、Juliaは&lt;a href=&quot;#non-standard-string-literals&quot;&gt;非標準の文字列リテラルを&lt;/a&gt;提供します。非標準の文字列リテラルは、通常の二重引用符で囲まれた文字列リテラルのように見えますが、すぐに識別子が前に付けられ、通常の文字列リテラルのようには動作しません。以下で説明するように、正規表現、バイト配列リテラル、およびバージョン番号リテラルは、非標準の文字列リテラルの例です。他の例は、&lt;a href=&quot;../metaprogramming/index#Metaprogramming&quot;&gt;メタプログラミングの&lt;/a&gt;セクションに記載されています。</target>
        </trans-unit>
        <trans-unit id="89a2008a07be2d9f32034d88c362d6f0eb2082a1" translate="yes" xml:space="preserve">
          <source>There are situations when you want to construct a string or use string semantics, but the behavior of the standard string construct is not quite what is needed. For these kinds of situations, Julia provides &lt;a href=&quot;#non-standard-string-literals-1&quot;&gt;non-standard string literals&lt;/a&gt;. A non-standard string literal looks like a regular double-quoted string literal, but is immediately prefixed by an identifier, and doesn't behave quite like a normal string literal. Regular expressions, byte array literals and version number literals, as described below, are some examples of non-standard string literals. Other examples are given in the &lt;a href=&quot;../metaprogramming/index#Metaprogramming-1&quot;&gt;Metaprogramming&lt;/a&gt; section.</source>
          <target state="translated">文字列を構築したり、文字列のセマンティクスを使用したりする場合がありますが、標準の文字列構造の動作は、まったく必要なものではありません。このような状況のために、Juliaは&lt;a href=&quot;#non-standard-string-literals-1&quot;&gt;非標準の文字列リテラルを&lt;/a&gt;提供しています。非標準の文字列リテラルは、通常の二重引用符付き文字列リテラルのように見えますが、すぐに識別子が前に付けられ、通常の文字列リテラルのようには動作しません。正規表現、バイト配列リテラル、およびバージョン番号リテラルは、以下で説明するように、非標準の文字列リテラルの例です。その他の例は、&lt;a href=&quot;../metaprogramming/index#Metaprogramming-1&quot;&gt;メタプログラミングの&lt;/a&gt;セクションに記載されています。</target>
        </trans-unit>
        <trans-unit id="89cbb0c73360645fdecca6950c82515a07e71685" translate="yes" xml:space="preserve">
          <source>There are situations where it may not make sense for type parameters to range freely over all possible types. In such situations, one can constrain the range of &lt;code&gt;T&lt;/code&gt; like so:</source>
          <target state="translated">型パラメーターがすべての可能な型に自由に及ぶことが意味をなさない場合があります。このような状況では、 &lt;code&gt;T&lt;/code&gt; の範囲を次のように制限できます。</target>
        </trans-unit>
        <trans-unit id="7fd0dbd27001bbf0cf571035d6ca76de3cfc30cb" translate="yes" xml:space="preserve">
          <source>There are some functions to control the GC. In normal use cases, these should not be necessary.</source>
          <target state="translated">GC を制御するための機能がいくつかあります。通常の使用例では、これらは必要ありません。</target>
        </trans-unit>
        <trans-unit id="f09765a26c89d3ba4efc525f188b8d20fe2e6806" translate="yes" xml:space="preserve">
          <source>There are some keys which allow automatically generated log data to be overridden:</source>
          <target state="translated">自動生成されたログデータを上書きできるようにするキーがいくつかあります。</target>
        </trans-unit>
        <trans-unit id="a452182cf4d04b3b872134735654a28996e85391" translate="yes" xml:space="preserve">
          <source>There are three important standard modules:</source>
          <target state="translated">重要な標準モジュールは3つあります。</target>
        </trans-unit>
        <trans-unit id="7aeed63be2ceefd859fdddad806d6d15b8832022" translate="yes" xml:space="preserve">
          <source>There are three logger types provided by the library. &lt;a href=&quot;#Logging.ConsoleLogger&quot;&gt;&lt;code&gt;ConsoleLogger&lt;/code&gt;&lt;/a&gt; is the default logger you see when starting the REPL. It displays events in a readable text format and tries to give simple but user friendly control over formatting and filtering. &lt;a href=&quot;#Base.CoreLogging.NullLogger&quot;&gt;&lt;code&gt;NullLogger&lt;/code&gt;&lt;/a&gt; is a convenient way to drop all messages where necessary; it is the logging equivalent of the &lt;a href=&quot;../../base/base/index#Base.devnull&quot;&gt;&lt;code&gt;devnull&lt;/code&gt;&lt;/a&gt; stream. &lt;a href=&quot;#Base.CoreLogging.SimpleLogger&quot;&gt;&lt;code&gt;SimpleLogger&lt;/code&gt;&lt;/a&gt; is a very simplistic text formatting logger, mainly useful for debugging the logging system itself.</source>
          <target state="translated">ライブラリによって提供される3つのロガータイプがあります。&lt;a href=&quot;#Logging.ConsoleLogger&quot;&gt; &lt;code&gt;ConsoleLogger&lt;/code&gt; &lt;/a&gt;は、REPLの起動時に表示されるデフォルトのロガーです。これは、読みやすいテキスト形式でイベントを表示し、書式設定とフィルタリングを簡単でユーザーフレンドリーな制御を提供しようとします。&lt;a href=&quot;#Base.CoreLogging.NullLogger&quot;&gt; &lt;code&gt;NullLogger&lt;/code&gt; &lt;/a&gt;は、必要に応じてすべてのメッセージをドロップする便利な方法です。これは、&lt;a href=&quot;../../base/base/index#Base.devnull&quot;&gt; &lt;code&gt;devnull&lt;/code&gt; &lt;/a&gt;ストリームと同等のロギングです。&lt;a href=&quot;#Base.CoreLogging.SimpleLogger&quot;&gt; &lt;code&gt;SimpleLogger&lt;/code&gt; &lt;/a&gt;は非常に単純化されたテキストフォーマットロガーで、主にロギングシステム自体のデバッグに役立ちます。</target>
        </trans-unit>
        <trans-unit id="5e690eabf31525aac327d09327076212853ab17f" translate="yes" xml:space="preserve">
          <source>There are three logger types provided by the library. &lt;a href=&quot;#Logging.ConsoleLogger&quot;&gt;&lt;code&gt;ConsoleLogger&lt;/code&gt;&lt;/a&gt; is the default logger you see when starting the REPL. It displays events in a readable text format and tries to give simple but user friendly control over formatting and filtering. &lt;a href=&quot;#Logging.NullLogger&quot;&gt;&lt;code&gt;NullLogger&lt;/code&gt;&lt;/a&gt; is a convenient way to drop all messages where necessary; it is the logging equivalent of the &lt;a href=&quot;../../base/base/index#Base.devnull&quot;&gt;&lt;code&gt;devnull&lt;/code&gt;&lt;/a&gt; stream. &lt;a href=&quot;#Logging.SimpleLogger&quot;&gt;&lt;code&gt;SimpleLogger&lt;/code&gt;&lt;/a&gt; is a very simplistic text formatting logger, mainly useful for debugging the logging system itself.</source>
          <target state="translated">ライブラリによって提供されるロガータイプは3つあります。&lt;a href=&quot;#Logging.ConsoleLogger&quot;&gt; &lt;code&gt;ConsoleLogger&lt;/code&gt; &lt;/a&gt;は、REPLの開始時に表示されるデフォルトのロガーです。イベントを読みやすいテキスト形式で表示し、フォーマットとフィルタリングをシンプルかつユーザーフレンドリーに制御しようとします。&lt;a href=&quot;#Logging.NullLogger&quot;&gt; &lt;code&gt;NullLogger&lt;/code&gt; &lt;/a&gt;は、必要に応じてすべてのメッセージをドロップする便利な方法です。これは、&lt;a href=&quot;../../base/base/index#Base.devnull&quot;&gt; &lt;code&gt;devnull&lt;/code&gt; &lt;/a&gt;ストリームと同等のロギングです。&lt;a href=&quot;#Logging.SimpleLogger&quot;&gt; &lt;code&gt;SimpleLogger&lt;/code&gt; &lt;/a&gt;は、非常に単純なテキストフォーマットロガーであり、主にロギングシステム自体のデバッグに役立ちます。</target>
        </trans-unit>
        <trans-unit id="39bf1c403bd69afc5e26a9a958d5e1ff68b86fdd" translate="yes" xml:space="preserve">
          <source>There are three possible points of return from this function, returning the values of three different expressions, depending on the values of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. The &lt;code&gt;return&lt;/code&gt; on the last line could be omitted since it is the last expression.</source>
          <target state="translated">この関数から返される可能性のあるポイントは3つあり、 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; の値に応じて、3つの異なる式の値を返します。最後の式は最後の式なので、最後の行の &lt;code&gt;return&lt;/code&gt; は省略できます。</target>
        </trans-unit>
        <trans-unit id="18fca925f2f77e2b65c8fdde85952641e1650d33" translate="yes" xml:space="preserve">
          <source>There are three specified standard floating-point values that do not correspond to any point on the real number line:</source>
          <target state="translated">実数線上のどの点にも対応しない浮動小数点の指定標準値が3つあります。</target>
        </trans-unit>
        <trans-unit id="2ce18266eafd4e5743ff642c71c4f327eae5b08a" translate="yes" xml:space="preserve">
          <source>There are two categories: generating values from a type (e.g. &lt;code&gt;rand(Int)&lt;/code&gt;), or from a collection (e.g. &lt;code&gt;rand(1:3)&lt;/code&gt;). The simple cases are explained first, and more advanced usage is presented later. We assume here that the choice of algorithm is independent of the RNG, so we use &lt;code&gt;AbstractRNG&lt;/code&gt; in our signatures.</source>
          <target state="translated">2つのカテゴリがあります。型から値を生成する（例： &lt;code&gt;rand(Int)&lt;/code&gt; ）、またはコレクションから値を生成する（例： &lt;code&gt;rand(1:3)&lt;/code&gt; ）。簡単なケースを最初に説明し、より高度な使用法については後で説明します。ここでは、アルゴリズムの選択はRNGから独立していると想定しているため、シグネチャでは &lt;code&gt;AbstractRNG&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="57f9b987aba6af24cda8e7334000e333dbb62bc6" translate="yes" xml:space="preserve">
          <source>There are two constructs for repeated evaluation of expressions: the &lt;code&gt;while&lt;/code&gt; loop and the &lt;code&gt;for&lt;/code&gt; loop. Here is an example of a &lt;code&gt;while&lt;/code&gt; loop:</source>
          <target state="translated">式の繰り返し評価には、 &lt;code&gt;while&lt;/code&gt; ループと &lt;code&gt;for&lt;/code&gt; ループの2つの構成があります。以下は、 &lt;code&gt;while&lt;/code&gt; ループの例です。</target>
        </trans-unit>
        <trans-unit id="5da5a1ee059f0ac2e0add637de14f3676c7deb7b" translate="yes" xml:space="preserve">
          <source>There are two different packages named &lt;code&gt;Priv&lt;/code&gt; that the application uses. It uses a private package, which is a root dependency, and a public one, which is an indirect dependency through &lt;code&gt;Pub&lt;/code&gt;. These are differentiated by their distinct UUIDs, and they have different deps:</source>
          <target state="translated">アプリケーションが使用する &lt;code&gt;Priv&lt;/code&gt; という名前の2つの異なるパッケージがあります。ルート依存関係であるプライベートパッケージと、 &lt;code&gt;Pub&lt;/code&gt; を介した間接依存関係であるパブリックパッケージを使用します。これらは異なるUUIDによって区別され、異なるdepを持っています。</target>
        </trans-unit>
        <trans-unit id="a80cf781eb3e259c907910355de5e57b87258bfc" translate="yes" xml:space="preserve">
          <source>There are two mostly orthogonal ways to extend &lt;code&gt;Random&lt;/code&gt; functionalities:</source>
          <target state="translated">&lt;code&gt;Random&lt;/code&gt; 機能を拡張するには、主に直交する2つの方法があります。</target>
        </trans-unit>
        <trans-unit id="d2e30fededfc9e0acc9aec32cc305e4b3edfd71f" translate="yes" xml:space="preserve">
          <source>There are two possible shortened forms for the &lt;code&gt;return nothing&lt;/code&gt; expression. On the one hand, the &lt;code&gt;return&lt;/code&gt; keyword implicitly returns &lt;code&gt;nothing&lt;/code&gt;, so it can be used alone. On the other hand, since functions implicitly return their last expression evaluated, &lt;code&gt;nothing&lt;/code&gt; can be used alone when it's the last expression. The preference for the expression &lt;code&gt;return nothing&lt;/code&gt; as opposed to &lt;code&gt;return&lt;/code&gt; or &lt;code&gt;nothing&lt;/code&gt; alone is a matter of coding style.</source>
          <target state="translated">&lt;code&gt;return nothing&lt;/code&gt; 式には、2つの可能な短縮形式があります。一方では、 &lt;code&gt;return&lt;/code&gt; キーワードは暗黙的に &lt;code&gt;nothing&lt;/code&gt; 返さないため、単独で使用できます。一方、関数は評価された最後の式を暗黙的に返すため、最後の式である場合は単独で使用することはでき &lt;code&gt;nothing&lt;/code&gt; 。表現のための好み &lt;code&gt;return nothing&lt;/code&gt; と対照的に &lt;code&gt;return&lt;/code&gt; か、 &lt;code&gt;nothing&lt;/code&gt; 一人では、コーディングスタイルの問題です。</target>
        </trans-unit>
        <trans-unit id="f15f1d9e0b0d6aa79c92366d6d55c444ac8dd9c4" translate="yes" xml:space="preserve">
          <source>There are various ways to run Julia code and provide options, similar to those available for the &lt;code&gt;perl&lt;/code&gt; and &lt;code&gt;ruby&lt;/code&gt; programs:</source>
          <target state="translated">Juliaコードを実行してオプションを提供するには、 &lt;code&gt;perl&lt;/code&gt; および &lt;code&gt;ruby&lt;/code&gt; プログラムで使用できる方法と同様のさまざまな方法があります。</target>
        </trans-unit>
        <trans-unit id="fe7ec7d12394b96c015a1c2e093208538245f475" translate="yes" xml:space="preserve">
          <source>There exists no loop-carried memory dependencies</source>
          <target state="translated">ループキャリーメモリの依存関係は存在しません。</target>
        </trans-unit>
        <trans-unit id="167978b2ab5201a534fdd8a54c05583e0811193a" translate="yes" xml:space="preserve">
          <source>There is a &lt;a href=&quot;../../base/collections/index#Base.Pair&quot;&gt;&lt;code&gt;Pair&lt;/code&gt;&lt;/a&gt; type, but it is not meant to be used as a &lt;code&gt;COMMON-LISP:CONS&lt;/code&gt;. Various iterable collections can be used interchangeably in most parts of the language (eg splatting, tuples, etc). &lt;code&gt;Tuple&lt;/code&gt;s are the closest to Common Lisp lists for &lt;em&gt;short&lt;/em&gt; collections of heterogeneous elements. Use &lt;code&gt;NamedTuple&lt;/code&gt;s in place of alists. For larger collections of homogeneous types, &lt;code&gt;Array&lt;/code&gt;s and &lt;code&gt;Dict&lt;/code&gt;s should be used.</source>
          <target state="translated">&lt;a href=&quot;../../base/collections/index#Base.Pair&quot;&gt; &lt;code&gt;Pair&lt;/code&gt; &lt;/a&gt;タイプがありますが、 &lt;code&gt;COMMON-LISP:CONS&lt;/code&gt; として使用するためのものではありません。さまざまな反復可能なコレクションは、言語のほとんどの部分（たとえば、スプラッティング、タプルなど）で交換可能に使用できます。 &lt;code&gt;Tuple&lt;/code&gt; は、異種要素の&lt;em&gt;短い&lt;/em&gt;コレクションのCommonLispリストに最も近いものです。使用 &lt;code&gt;NamedTuple&lt;/code&gt; は連想リストの代わりにね。同種タイプの大規模なコレクションの場合は、 &lt;code&gt;Array&lt;/code&gt; と &lt;code&gt;Dict&lt;/code&gt; 使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="dbe9d20052debba9991c8dfc120934a6e59ce3f0" translate="yes" xml:space="preserve">
          <source>There is a convenient syntax for naming such types, similar to the short form of function definition syntax:</source>
          <target state="translated">このような型の命名には、関数定義構文の短縮形に似た便利な構文があります。</target>
        </trans-unit>
        <trans-unit id="c4273d4f01461968327256a1b4317f5663291a1c" translate="yes" xml:space="preserve">
          <source>There is a global named &lt;code&gt;s&lt;/code&gt;, so &lt;code&gt;s = t&lt;/code&gt; assigns to it.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; という名前のグローバルがあるので、 &lt;code&gt;s = t&lt;/code&gt; がそれに割り当てます。</target>
        </trans-unit>
        <trans-unit id="e3481a52901e12b38922b7141656dfae7e68cc28" translate="yes" xml:space="preserve">
          <source>There is a second syntactic form of quoting for multiple expressions: blocks of code enclosed in &lt;code&gt;quote ... end&lt;/code&gt;.</source>
          <target state="translated">複数の式を引用する2番目の構文形式があり &lt;code&gt;quote ... end&lt;/code&gt; 囲まれたコードのブロックです。</target>
        </trans-unit>
        <trans-unit id="89fb23b7683ecb8e95311e78406e7a19ca4a906a" translate="yes" xml:space="preserve">
          <source>There is a second, more terse syntax for defining a function in Julia. The traditional function declaration syntax demonstrated above is equivalent to the following compact &quot;assignment form&quot;:</source>
          <target state="translated">Juliaには、関数を定義するための第二の、より簡潔な構文があります。上で示した伝統的な関数宣言構文は、以下のコンパクトな「代入形式」に相当します。</target>
        </trans-unit>
        <trans-unit id="b0f3efad279d61a3ae46bad7c874ec9a27487608" translate="yes" xml:space="preserve">
          <source>There is a special kind of abstract parametric type that must be mentioned here: singleton types. For each type, &lt;code&gt;T&lt;/code&gt;, the &quot;singleton type&quot; &lt;code&gt;Type{T}&lt;/code&gt; is an abstract type whose only instance is the object &lt;code&gt;T&lt;/code&gt;. Since the definition is a little difficult to parse, let's look at some examples:</source>
          <target state="translated">ここで言及しなければならない特別な種類の抽象パラメトリックタイプがあります。シングルトンタイプです。タイプ &lt;code&gt;T&lt;/code&gt; ごとに、「シングルトンタイプ」 &lt;code&gt;Type{T}&lt;/code&gt; は、オブジェクト &lt;code&gt;T&lt;/code&gt; のみがインスタンスである抽象タイプです。定義を解析するのが少し難しいので、いくつかの例を見てみましょう：</target>
        </trans-unit>
        <trans-unit id="4edd8c08b09effa574afae30fbef7845d91eb8b4" translate="yes" xml:space="preserve">
          <source>There is also a &lt;a href=&quot;../../base/numbers/index#Base.oneunit&quot;&gt;&lt;code&gt;oneunit&lt;/code&gt;&lt;/a&gt; function, and a more general &lt;a href=&quot;../../base/base/index#Base.oftype&quot;&gt;&lt;code&gt;oftype(x, y)&lt;/code&gt;&lt;/a&gt; function, which returns &lt;code&gt;y&lt;/code&gt; converted to the type of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">ある&lt;a href=&quot;../../base/numbers/index#Base.oneunit&quot;&gt; &lt;code&gt;oneunit&lt;/code&gt; &lt;/a&gt;機能、より一般的な&lt;a href=&quot;../../base/base/index#Base.oftype&quot;&gt; &lt;code&gt;oftype(x, y)&lt;/code&gt; &lt;/a&gt;返す関数、 &lt;code&gt;y&lt;/code&gt; の型に変換 &lt;code&gt;x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="734126eef49207ddeb0d4f566a4461c7a515e501" translate="yes" xml:space="preserve">
          <source>There is also a concise syntax for nested &lt;code&gt;where&lt;/code&gt; expressions. For example, this:</source>
          <target state="translated">ネストされた &lt;code&gt;where&lt;/code&gt; 式の簡潔な構文もあります。たとえば、これ：</target>
        </trans-unit>
        <trans-unit id="3485de030aea8df4c966053791640ea9fedf8c2e" translate="yes" xml:space="preserve">
          <source>There is also a method &lt;code&gt;crc32c(io, nb, crc)&lt;/code&gt; to checksum &lt;code&gt;nb&lt;/code&gt; bytes from a stream &lt;code&gt;io&lt;/code&gt;, or &lt;code&gt;crc32c(io, crc)&lt;/code&gt; to checksum all the remaining bytes. Hence you can do &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt;&lt;code&gt;open(crc32c, filename)&lt;/code&gt;&lt;/a&gt; to checksum an entire file, or &lt;code&gt;crc32c(seekstart(buf))&lt;/code&gt; to checksum an &lt;a href=&quot;../../base/io-network/index#Base.IOBuffer&quot;&gt;&lt;code&gt;IOBuffer&lt;/code&gt;&lt;/a&gt; without calling &lt;code&gt;take!&lt;/code&gt;.</source>
          <target state="translated">ストリーム &lt;code&gt;io&lt;/code&gt; から &lt;code&gt;nb&lt;/code&gt; バイトをチェックサムするメソッド &lt;code&gt;crc32c(io, nb, crc)&lt;/code&gt; 、または残りのすべてのバイトをチェックサムする &lt;code&gt;crc32c(io, crc)&lt;/code&gt; もあります。したがって&lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt; &lt;code&gt;open(crc32c, filename)&lt;/code&gt; &lt;/a&gt;を実行してファイル全体をチェックサムするか、 &lt;code&gt;crc32c(seekstart(buf))&lt;/code&gt; を実行して&lt;a href=&quot;../../base/io-network/index#Base.IOBuffer&quot;&gt; &lt;code&gt;IOBuffer&lt;/code&gt; &lt;/a&gt;を呼び出さずにIOBufferをチェックサムすることが &lt;code&gt;take!&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="923a006c576c90e740ad341ee467086ea5813910" translate="yes" xml:space="preserve">
          <source>There is much more to say about how instances of composite types are created, but that discussion depends on both &lt;a href=&quot;#Parametric-Types&quot;&gt;Parametric Types&lt;/a&gt; and on &lt;a href=&quot;../methods/index#Methods&quot;&gt;Methods&lt;/a&gt;, and is sufficiently important to be addressed in its own section: &lt;a href=&quot;../constructors/index#man-constructors&quot;&gt;Constructors&lt;/a&gt;.</source>
          <target state="translated">複合型のインスタンスがどのように作成されるかについてはさらに多くのことが言えますが、その議論は&lt;a href=&quot;#Parametric-Types&quot;&gt;パラメトリック型&lt;/a&gt;と&lt;a href=&quot;../methods/index#Methods&quot;&gt;メソッドの&lt;/a&gt;両方に依存し、独自のセクションである&lt;a href=&quot;../constructors/index#man-constructors&quot;&gt;コンストラクター&lt;/a&gt;で説明するのに十分重要です。</target>
        </trans-unit>
        <trans-unit id="5507a1ebe82bf577a426867e01303c626cf9abd7" translate="yes" xml:space="preserve">
          <source>There is much more to say about how instances of composite types are created, but that discussion depends on both &lt;a href=&quot;#Parametric-Types-1&quot;&gt;Parametric Types&lt;/a&gt; and on &lt;a href=&quot;../methods/index#Methods-1&quot;&gt;Methods&lt;/a&gt;, and is sufficiently important to be addressed in its own section: &lt;a href=&quot;../constructors/index#man-constructors-1&quot;&gt;Constructors&lt;/a&gt;.</source>
          <target state="translated">複合型のインスタンスがどのように作成されるかについては、他にも多くの説明がありますが、その説明は、&lt;a href=&quot;#Parametric-Types-1&quot;&gt;パラメトリック型&lt;/a&gt;と&lt;a href=&quot;../methods/index#Methods-1&quot;&gt;メソッドの&lt;/a&gt;両方に依存しており、独自のセクションである&lt;a href=&quot;../constructors/index#man-constructors-1&quot;&gt;コンストラクタ&lt;/a&gt;で説明するのに十分重要です。</target>
        </trans-unit>
        <trans-unit id="0ae09c7d6ba8798034e4671d0b26e5b85ce05ddc" translate="yes" xml:space="preserve">
          <source>There is no division between object and non-object values: all values in Julia are true objects having a type that belongs to a single, fully connected type graph, all nodes of which are equally first-class as types.</source>
          <target state="translated">オブジェクトと非オブジェクトの間には分け隔てがありません:Juliaのすべての値は、完全に接続された単一の型グラフに属する型を持つ真のオブジェクトであり、すべてのノードは型として等しく一級品です。</target>
        </trans-unit>
        <trans-unit id="d4c6baab6e4cf883e88c1aedd0d9bd2aa047689e" translate="yes" xml:space="preserve">
          <source>There is no global named &lt;code&gt;t&lt;/code&gt;, so &lt;code&gt;t = s + i&lt;/code&gt; creates a new &lt;code&gt;t&lt;/code&gt; that is local to the &lt;code&gt;for&lt;/code&gt; loop;</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; という名前のグローバルはないため、 &lt;code&gt;t = s + i&lt;/code&gt; は、 &lt;code&gt;for&lt;/code&gt; ループに対してローカルな新しい &lt;code&gt;t&lt;/code&gt; を作成します。</target>
        </trans-unit>
        <trans-unit id="799561e1d3a80d4e278504aa2e10c84451ac9ffd" translate="yes" xml:space="preserve">
          <source>There is no invalid (NULL) &lt;code&gt;Ref&lt;/code&gt; in Julia, but a &lt;code&gt;C_NULL&lt;/code&gt; instance of &lt;code&gt;Ptr&lt;/code&gt; can be passed to a &lt;code&gt;ccall&lt;/code&gt; Ref argument.</source>
          <target state="translated">そこには無効（NULL）ではありません &lt;code&gt;Ref&lt;/code&gt; ジュリアでは、しかし、 &lt;code&gt;C_NULL&lt;/code&gt; ののインスタンス &lt;code&gt;Ptr&lt;/code&gt; に渡すことができ &lt;code&gt;ccall&lt;/code&gt; のRef引数。</target>
        </trans-unit>
        <trans-unit id="11bffac25c301a4657b1c60789201ca8aff715a3" translate="yes" xml:space="preserve">
          <source>There is no meaningful concept of a &quot;compile-time type&quot;: the only type a value has is its actual type when the program is running. This is called a &quot;run-time type&quot; in object-oriented languages where the combination of static compilation with polymorphism makes this distinction significant.</source>
          <target state="translated">コンパイル時型」という意味のある概念はありません:値が持つ型は、プログラムが実行されているときの実際の型だけです。これはオブジェクト指向言語では「ランタイム型」と呼ばれ、静的コンパイルとポリモーフィズムの組み合わせにより、この区別が重要になります。</target>
        </trans-unit>
        <trans-unit id="e3d48c4d50de4372a5a2ecbc4a1b8db9674c176e" translate="yes" xml:space="preserve">
          <source>There is no more to the implementation of &lt;code&gt;Val&lt;/code&gt; than this. Some functions in Julia's standard library accept &lt;code&gt;Val&lt;/code&gt; instances as arguments, and you can also use it to write your own functions. For example:</source>
          <target state="translated">&lt;code&gt;Val&lt;/code&gt; の実装はこれ以上ありません。Juliaの標準ライブラリの一部の関数は、 &lt;code&gt;Val&lt;/code&gt; インスタンスを引数として受け入れ、それを使用して独自の関数を作成することもできます。例えば：</target>
        </trans-unit>
        <trans-unit id="225dfa7c16e90d2f9982aa1b83dde6be688afb63" translate="yes" xml:space="preserve">
          <source>There is one additional special calling convention &lt;a href=&quot;../../base/c/index#Core.Intrinsics.llvmcall&quot;&gt;&lt;code&gt;llvmcall&lt;/code&gt;&lt;/a&gt;, which allows inserting calls to LLVM intrinsics directly. This can be especially useful when targeting unusual platforms such as GPGPUs. For example, for &lt;a href=&quot;http://llvm.org/docs/NVPTXUsage.html&quot;&gt;CUDA&lt;/a&gt;, we need to be able to read the thread index:</source>
          <target state="translated">LLVM組み込み関数への呼び出しを直接挿入できる、1つの特別な呼び出し規則&lt;a href=&quot;../../base/c/index#Core.Intrinsics.llvmcall&quot;&gt; &lt;code&gt;llvmcall&lt;/code&gt; &lt;/a&gt;があります。これは、GPGPUなどの特殊なプラットフォームを対象とする場合に特に役立ちます。たとえば、&lt;a href=&quot;http://llvm.org/docs/NVPTXUsage.html&quot;&gt;CUDAの&lt;/a&gt;場合、スレッドインデックスを読み取ることができる必要があります。</target>
        </trans-unit>
        <trans-unit id="982d9172cf71b589801a04a1718b7e1140ec78b8" translate="yes" xml:space="preserve">
          <source>There is only one difference, and on the surface (syntax-wise) it may seem very minor. The difference between &lt;code&gt;using&lt;/code&gt; and &lt;code&gt;import&lt;/code&gt; is that with &lt;code&gt;using&lt;/code&gt; you need to say &lt;code&gt;function Foo.bar(..&lt;/code&gt; to extend module Foo's function bar with a new method, but with &lt;code&gt;import Foo.bar&lt;/code&gt;, you only need to say &lt;code&gt;function bar(...&lt;/code&gt; and it automatically extends module Foo's function bar.</source>
          <target state="translated">違いは1つだけであり、表面的には（構文的に）非常にマイナーに見えるかもしれません。違い &lt;code&gt;using&lt;/code&gt; して &lt;code&gt;import&lt;/code&gt; でていることである &lt;code&gt;using&lt;/code&gt; 、あなたが言う必要がある &lt;code&gt;function Foo.bar(..&lt;/code&gt; 新しい方法でモジュールのFooの機能バーを拡張することではなくて &lt;code&gt;import Foo.bar&lt;/code&gt; 、あなただけ言う必要が &lt;code&gt;function bar(...&lt;/code&gt; モジュールFooの機能バーを自動的に拡張します。</target>
        </trans-unit>
        <trans-unit id="40b79a3c7d53b455d5a062d0c3faf4f4007912a3" translate="yes" xml:space="preserve">
          <source>There is some overlap between these rules since the behavior of &lt;code&gt;\x&lt;/code&gt; and octal escapes less than 0x80 (128) are covered by both of the first two rules, but here these rules agree. Together, these rules allow one to easily use ASCII characters, arbitrary byte values, and UTF-8 sequences to produce arrays of bytes. Here is an example using all three:</source>
          <target state="translated">&lt;code&gt;\x&lt;/code&gt; の動作と0x80（128）未満の8進エスケープは最初の2つの規則の両方でカバーされるため、これらの規則にはいくつかの重複がありますが、ここではこれらの規則は一致しています。これらの規則により、ASCII文字、任意のバイト値、およびUTF-8シーケンスを簡単に使用してバイトの配列を生成できます。 3つすべてを使用した例を次に示します。</target>
        </trans-unit>
        <trans-unit id="9a0371b0510547518bd685c0ced89d4cf0d5a48b" translate="yes" xml:space="preserve">
          <source>There is yet another case that the actual &lt;code&gt;@assert&lt;/code&gt; macro handles: what if, in addition to printing &quot;a should equal b,&quot; we wanted to print their values? One might naively try to use string interpolation in the custom message, e.g., &lt;code&gt;@assert a==b &quot;a ($a) should equal b ($b)!&quot;&lt;/code&gt;, but this won't work as expected with the above macro. Can you see why? Recall from &lt;a href=&quot;../strings/index#string-interpolation&quot;&gt;string interpolation&lt;/a&gt; that an interpolated string is rewritten to a call to &lt;a href=&quot;../../base/strings/index#Base.string&quot;&gt;&lt;code&gt;string&lt;/code&gt;&lt;/a&gt;. Compare:</source>
          <target state="translated">実際の &lt;code&gt;@assert&lt;/code&gt; マクロが処理するさらに別のケースがあります。「aはbと等しくなければならない」を出力することに加えて、それらの値を出力したい場合はどうでしょうか。カスタムメッセージで文字列補間を &lt;code&gt;@assert a==b &quot;a ($a) should equal b ($b)!&quot;&lt;/code&gt; に使用しようとする場合があります。たとえば、@ assert a == b &quot;a（$ a）should equal b（$ b）！&quot; 、ただし、これは上記のマクロでは期待どおりに機能しません。理由がわかりますか？&lt;a href=&quot;../strings/index#string-interpolation&quot;&gt;文字列補間&lt;/a&gt;から、補間された文字列が&lt;a href=&quot;../../base/strings/index#Base.string&quot;&gt; &lt;code&gt;string&lt;/code&gt; &lt;/a&gt;呼び出しに書き換えられることを思い出してください。比較：</target>
        </trans-unit>
        <trans-unit id="5a8e36fc8e9774033114f307d267a46fecf4de03" translate="yes" xml:space="preserve">
          <source>There is yet another case that the actual &lt;code&gt;@assert&lt;/code&gt; macro handles: what if, in addition to printing &quot;a should equal b,&quot; we wanted to print their values? One might naively try to use string interpolation in the custom message, e.g., &lt;code&gt;@assert a==b &quot;a ($a) should equal b ($b)!&quot;&lt;/code&gt;, but this won't work as expected with the above macro. Can you see why? Recall from &lt;a href=&quot;../strings/index#string-interpolation-1&quot;&gt;string interpolation&lt;/a&gt; that an interpolated string is rewritten to a call to &lt;a href=&quot;../../base/strings/index#Base.string&quot;&gt;&lt;code&gt;string&lt;/code&gt;&lt;/a&gt;. Compare:</source>
          <target state="translated">実際の &lt;code&gt;@assert&lt;/code&gt; マクロが処理するもう1つのケースがあります。「aはbと等しい」を出力することに加えて、それらの値を出力したいとしたらどうでしょうか。たとえば、 &lt;code&gt;@assert a==b &quot;a ($a) should equal b ($b)!&quot;&lt;/code&gt; 、単純にカスタムメッセージで文字列補間を使用しようとするかもしれません。、しかしこれは上記のマクロでは期待通りに機能しません。理由が分かりますか？&lt;a href=&quot;../strings/index#string-interpolation-1&quot;&gt;文字列補間&lt;/a&gt;から、補間された文字列が&lt;a href=&quot;../../base/strings/index#Base.string&quot;&gt; &lt;code&gt;string&lt;/code&gt; の&lt;/a&gt;呼び出しに書き換えられることを思い出してください。比較：</target>
        </trans-unit>
        <trans-unit id="d3e7d0ac84e899740c4a2f0bb3ee4413427fcc34" translate="yes" xml:space="preserve">
          <source>There's also some key value pairs which have conventional meaning:</source>
          <target state="translated">また、従来の意味を持つキー値のペアもあります。</target>
        </trans-unit>
        <trans-unit id="f6f36ec125f2f895a5ef2bd1d15fb610bf42b808" translate="yes" xml:space="preserve">
          <source>Therefore</source>
          <target state="translated">Therefore</target>
        </trans-unit>
        <trans-unit id="2f243754615f97fed5cd732a70910cb99d584308" translate="yes" xml:space="preserve">
          <source>Therefore, if an &lt;code&gt;Array&lt;/code&gt; contains data in the wrong format, it will have to be explicitly converted using a call such as &lt;code&gt;trunc(Int32, a)&lt;/code&gt;.</source>
          <target state="translated">したがって、 &lt;code&gt;Array&lt;/code&gt; に誤った形式のデータが含まれている場合は、 &lt;code&gt;trunc(Int32, a)&lt;/code&gt; などの呼び出しを使用して明示的に変換する必要があります。</target>
        </trans-unit>
        <trans-unit id="db219bff6d21bdc3e30fad396993a55966a94d9d" translate="yes" xml:space="preserve">
          <source>These are all single-argument functions, with &lt;code&gt;atan&lt;/code&gt; also accepting two arguments corresponding to a traditional &lt;a href=&quot;https://en.wikipedia.org/wiki/Atan2&quot;&gt;&lt;code&gt;atan2&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">これらはすべて単一引数関数であり、 &lt;code&gt;atan&lt;/code&gt; は従来の&lt;a href=&quot;https://en.wikipedia.org/wiki/Atan2&quot;&gt; &lt;code&gt;atan2&lt;/code&gt; &lt;/a&gt;関数に対応する2つの引数も受け入れます。</target>
        </trans-unit>
        <trans-unit id="14803da413b77436b3c2d4357e087f5e0536c055" translate="yes" xml:space="preserve">
          <source>These are some minor points that might help in tight inner loops.</source>
          <target state="translated">これらは、タイトなインナーループに役立ちそうなマイナーなポイントです。</target>
        </trans-unit>
        <trans-unit id="f489d10be7b6a63303842ebf419258e8b767140d" translate="yes" xml:space="preserve">
          <source>These are standard system mutexes for locking critical sections of logic.</source>
          <target state="translated">これらは、ロジックの重要なセクションをロックするための標準的なシステムミューテックスです。</target>
        </trans-unit>
        <trans-unit id="d1641abea44eab3cf0ec515a65636237d8dacb4d" translate="yes" xml:space="preserve">
          <source>These building blocks are used to create the regular synchronization objects.</source>
          <target state="translated">これらのビルディングブロックは、通常の同期オブジェクトを作成するために使用されます。</target>
        </trans-unit>
        <trans-unit id="565962f2637fab496a10fd1e88eadfa7fec7f65c" translate="yes" xml:space="preserve">
          <source>These can be intermixed to create &lt;strong&gt;a stacked environment&lt;/strong&gt;: an ordered set of project environments and package directories, overlaid to make a single composite environment. The precedence and visibility rules then combine to determine which packages are available and where they get loaded from. Julia's load path forms a stacked environment, for example.</source>
          <target state="translated">これらを混合して&lt;strong&gt;、スタック環境&lt;/strong&gt;を作成できます。単一の複合環境を作成するためにオーバーレイされた、プロジェクト環境とパッケージディレクトリの順序付けされたセットです。次に、優先順位と可視性のルールが組み合わされて、利用可能なパッケージとそれらがどこからロードされるかが決定されます。たとえば、Juliaのロードパスはスタック環境を形成します。</target>
        </trans-unit>
        <trans-unit id="ad9e158cfed42f0988f112a79734599400b1a65e" translate="yes" xml:space="preserve">
          <source>These environment each serve a different purpose:</source>
          <target state="translated">これらの環境はそれぞれ異なる目的を持っています。</target>
        </trans-unit>
        <trans-unit id="df0dd5f0a0b3669798f0ca8386e219bbefc17e9d" translate="yes" xml:space="preserve">
          <source>These environment variables only have an effect if Julia was compiled with garbage-collection debugging (that is, if &lt;code&gt;WITH_GC_DEBUG_ENV&lt;/code&gt; is set to &lt;code&gt;1&lt;/code&gt; in the build configuration).</source>
          <target state="translated">これらの環境変数は、Juliaがガベージコレクションデバッグでコンパイルされた場合（つまり、ビルド構成で &lt;code&gt;WITH_GC_DEBUG_ENV&lt;/code&gt; が &lt;code&gt;1&lt;/code&gt; に設定されている場合）にのみ効果があります。</target>
        </trans-unit>
        <trans-unit id="8da007debd6546e5bcd6fdc6a81faf692113b0dd" translate="yes" xml:space="preserve">
          <source>These events are disabled by default.</source>
          <target state="translated">これらのイベントはデフォルトでは無効になっています。</target>
        </trans-unit>
        <trans-unit id="de0986fe52ee36d8b5c27e28a863c7c354ad5a04" translate="yes" xml:space="preserve">
          <source>These examples are hopefully helpful to illustrate how generated functions work, both in the definition end and at the call site; however, &lt;em&gt;don't copy them&lt;/em&gt;, for the following reasons:</source>
          <target state="translated">これらの例は、生成された関数が定義の終わりと呼び出しサイトの両方でどのように機能するかを示すのに役立つと期待されます。ただし、次の理由により、&lt;em&gt;それらをコピーしない&lt;/em&gt;で&lt;em&gt;ください&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="aa722e52b03e87753d276a993e9d5484f0d06210" translate="yes" xml:space="preserve">
          <source>These functions are useful in &lt;a href=&quot;../mathematical-operations/index#Numeric-Comparisons&quot;&gt;Numeric Comparisons&lt;/a&gt; to avoid overhead from unnecessary &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion&quot;&gt;type conversion&lt;/a&gt;.</source>
          <target state="translated">これらの関数は、不要な&lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion&quot;&gt;型変換&lt;/a&gt;によるオーバーヘッドを回避するために&lt;a href=&quot;../mathematical-operations/index#Numeric-Comparisons&quot;&gt;数値比較で&lt;/a&gt;役立ちます。</target>
        </trans-unit>
        <trans-unit id="e22560ff89133b8a8d38ebe85a09966debefcae5" translate="yes" xml:space="preserve">
          <source>These functions are useful in &lt;a href=&quot;../mathematical-operations/index#Numeric-Comparisons-1&quot;&gt;Numeric Comparisons&lt;/a&gt; to avoid overhead from unnecessary &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;type conversion&lt;/a&gt;.</source>
          <target state="translated">これらの関数は、&lt;a href=&quot;../mathematical-operations/index#Numeric-Comparisons-1&quot;&gt;数値比較で&lt;/a&gt;不要な&lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;型変換&lt;/a&gt;によるオーバーヘッドを回避するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="901a72532a01b48c0a0b20d9a2bd0c5a053c7001" translate="yes" xml:space="preserve">
          <source>These method definitions say that in the absence of more specific rules for adding, subtracting, multiplying and dividing pairs of numeric values, promote the values to a common type and then try again. That's all there is to it: nowhere else does one ever need to worry about promotion to a common numeric type for arithmetic operations &amp;ndash; it just happens automatically. There are definitions of catch-all promotion methods for a number of other arithmetic and mathematical functions in &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/promotion.jl&quot;&gt;&lt;code&gt;promotion.jl&lt;/code&gt;&lt;/a&gt;, but beyond that, there are hardly any calls to &lt;code&gt;promote&lt;/code&gt; required in Julia Base. The most common usages of &lt;code&gt;promote&lt;/code&gt; occur in outer constructors methods, provided for convenience, to allow constructor calls with mixed types to delegate to an inner type with fields promoted to an appropriate common type. For example, recall that &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/rational.jl&quot;&gt;&lt;code&gt;rational.jl&lt;/code&gt;&lt;/a&gt; provides the following outer constructor method:</source>
          <target state="translated">これらのメソッドの定義では、数値のペアを加算、減算、乗算、および除算するためのより具体的なルールがない場合、値を共通の型に昇格してから再試行すると述べています。これですべてです。算術演算の一般的な数値型への昇格について心配する必要のある場所は他にありません。それは自動的に行われるだけです。内の他の算術関数と数学関数の数のためのキャッチオールプロモーションのメソッドの定義があり&lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/promotion.jl&quot;&gt; &lt;code&gt;promotion.jl&lt;/code&gt; は&lt;/a&gt;、それを超えて、するほとんどすべての呼び出しがある &lt;code&gt;promote&lt;/code&gt; ジュリアベースで必要が。 &lt;code&gt;promote&lt;/code&gt; の最も一般的な使用法便宜上提供されている外部コンストラクターメソッドで発生し、混合型のコンストラクター呼び出しが、適切な共通型に昇格されたフィールドを持つ内部型に委任できるようにします。たとえば、&lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/rational.jl&quot;&gt; &lt;code&gt;rational.jl&lt;/code&gt; &lt;/a&gt;が次の外部コンストラクタメソッドを提供することを思い出してください。</target>
        </trans-unit>
        <trans-unit id="38c599bfc89604d7c3dd9692be93915fc155443a" translate="yes" xml:space="preserve">
          <source>These questions are answered by searching through the project environments listed in &lt;a href=&quot;../../base/constants/index#Base.LOAD_PATH&quot;&gt;&lt;code&gt;LOAD_PATH&lt;/code&gt;&lt;/a&gt; for project files (&lt;code&gt;Project.toml&lt;/code&gt; or &lt;code&gt;JuliaProject.toml&lt;/code&gt;), manifest files (&lt;code&gt;Manifest.toml&lt;/code&gt; or &lt;code&gt;JuliaManifest.toml&lt;/code&gt;), or folders of source files.</source>
          <target state="translated">これらの質問は、&lt;a href=&quot;../../base/constants/index#Base.LOAD_PATH&quot;&gt; &lt;code&gt;LOAD_PATH&lt;/code&gt; &lt;/a&gt;にリストされているプロジェクト環境を検索して、プロジェクトファイル（ &lt;code&gt;Project.toml&lt;/code&gt; または &lt;code&gt;JuliaProject.toml&lt;/code&gt; ）、マニフェストファイル（ &lt;code&gt;Manifest.toml&lt;/code&gt; または &lt;code&gt;JuliaManifest.toml&lt;/code&gt; ）、またはソースファイルのフォルダーを検索することで回答されます。</target>
        </trans-unit>
        <trans-unit id="9e5166e13cc42aee4b6f34ab71374c703764b19f" translate="yes" xml:space="preserve">
          <source>These rules indicate that the combination of a &lt;code&gt;SparseVecStyle&lt;/code&gt; with 0- or 1-dimensional arrays yields another &lt;code&gt;SparseVecStyle&lt;/code&gt;, that its combination with a 2-dimensional array yields a &lt;code&gt;SparseMatStyle&lt;/code&gt;, and anything of higher dimensionality falls back to the dense arbitrary-dimensional framework. These rules allow broadcasting to keep the sparse representation for operations that result in one or two dimensional outputs, but produce an &lt;code&gt;Array&lt;/code&gt; for any other dimensionality.</source>
          <target state="translated">これらのルールは、 &lt;code&gt;SparseVecStyle&lt;/code&gt; と0または1次元配列の組み合わせが別の &lt;code&gt;SparseVecStyle&lt;/code&gt; を生成すること、2次元配列との &lt;code&gt;SparseMatStyle&lt;/code&gt; 生成すること、およびより高い次元のすべてが密な任意次元フレームワークにフォールバックすることを示します。これらのルールにより、ブロードキャストは、1次元または2次元の出力をもたらす操作のスパース表現を維持しますが、他の次元の &lt;code&gt;Array&lt;/code&gt; を生成します。</target>
        </trans-unit>
        <trans-unit id="ff63dfa77616c617504be7f6834247f76c057dc5" translate="yes" xml:space="preserve">
          <source>These values are &lt;code&gt;2.0^-23&lt;/code&gt; and &lt;code&gt;2.0^-52&lt;/code&gt; as &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; values, respectively. The &lt;a href=&quot;../../stdlib/dates/index#Base.eps&quot;&gt;&lt;code&gt;eps&lt;/code&gt;&lt;/a&gt; function can also take a floating-point value as an argument, and gives the absolute difference between that value and the next representable floating point value. That is, &lt;code&gt;eps(x)&lt;/code&gt; yields a value of the same type as &lt;code&gt;x&lt;/code&gt; such that &lt;code&gt;x + eps(x)&lt;/code&gt; is the next representable floating-point value larger than &lt;code&gt;x&lt;/code&gt;:</source>
          <target state="translated">これらの値は、それぞれ&lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt; &lt;code&gt;Float32&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;値として &lt;code&gt;2.0^-23&lt;/code&gt; および &lt;code&gt;2.0^-52&lt;/code&gt; です。&lt;a href=&quot;../../stdlib/dates/index#Base.eps&quot;&gt; &lt;code&gt;eps&lt;/code&gt; &lt;/a&gt;機能はまた、引数として浮動小数点値をとり、その値と次の表現の浮動小数点値の間の絶対差を与えることができます。すなわち、 &lt;code&gt;eps(x)&lt;/code&gt; 同じタイプの値が得られる &lt;code&gt;x&lt;/code&gt; となるように &lt;code&gt;x + eps(x)&lt;/code&gt; 、次の表現の浮動小数点値よりも大きい場合 &lt;code&gt;x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b3b947ad0ffcb0e9ad54a5598ed57c34a7f7c5d4" translate="yes" xml:space="preserve">
          <source>These will not specialize:</source>
          <target state="translated">これらは特化することはありません。</target>
        </trans-unit>
        <trans-unit id="f33ed7c0575b9d7d40952cddc046e39e47a4df14" translate="yes" xml:space="preserve">
          <source>They are explicitly declared.</source>
          <target state="translated">それらは明示的に宣言されています。</target>
        </trans-unit>
        <trans-unit id="9da6c9effd58ab0ae90e923f7a38a897dca353b9" translate="yes" xml:space="preserve">
          <source>They have explicitly declared supertypes.</source>
          <target state="translated">彼らは明示的にスーパータイプを宣言しています。</target>
        </trans-unit>
        <trans-unit id="6e52fab1fc6f56c83a090442135c118d8a782f83" translate="yes" xml:space="preserve">
          <source>They have names.</source>
          <target state="translated">彼らには名前がある</target>
        </trans-unit>
        <trans-unit id="062847d8bdfc031c0804b383d54688583d1d3428" translate="yes" xml:space="preserve">
          <source>They may have parameters.</source>
          <target state="translated">それらはパラメータを持っているかもしれません。</target>
        </trans-unit>
        <trans-unit id="ce535b7c90d1f3779f26e6dbf670c470fd87540b" translate="yes" xml:space="preserve">
          <source>Thin Space</source>
          <target state="translated">薄い空間</target>
        </trans-unit>
        <trans-unit id="b917e561d5e2ee00e3622e65889d344d78e37e20" translate="yes" xml:space="preserve">
          <source>Think of it as an alternative to using &lt;code&gt;println&lt;/code&gt; directly.</source>
          <target state="translated">&lt;code&gt;println&lt;/code&gt; を直接使用する代わりの方法と考えてください。</target>
        </trans-unit>
        <trans-unit id="794b36899e8ad96433bb7cbe178ed7bf875ad605" translate="yes" xml:space="preserve">
          <source>This &quot;declaration&quot; behavior only occurs in specific contexts:</source>
          <target state="translated">この &quot;宣言 &quot;の動作は、特定のコンテキストでのみ発生します。</target>
        </trans-unit>
        <trans-unit id="41a800e609852a7906e603a30a74797aa896d16f" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;errno&lt;/code&gt; symbol may not be found in a library named &quot;libc&quot;, as this is an implementation detail of your system compiler. Typically standard library symbols should be accessed just by name, allowing the compiler to fill in the correct one. Also, however, the &lt;code&gt;errno&lt;/code&gt; symbol shown in this example is special in most compilers, and so the value seen here is probably not what you expect or want. Compiling the equivalent code in C on any multi-threaded-capable system would typically actually call a different function (via macro preprocessor overloading), and may give a different result than the legacy value printed here.</source>
          <target state="translated">この &lt;code&gt;errno&lt;/code&gt; シンボルは、システムコンパイラの実装の詳細であるため、「libc」という名前のライブラリにない場合があります。通常、標準ライブラリシンボルには名前だけでアクセスして、コンパイラが正しいシンボルを入力できるようにする必要があります。ただし、この例に示されている &lt;code&gt;errno&lt;/code&gt; シンボルはほとんどのコンパイラーで特殊であるため、ここに表示される値は、おそらく期待または希望する値ではありません。マルチスレッド対応システムで同等のコードをCでコンパイルすると、通常、実際には（マクロプリプロセッサのオーバーロードを介して）異なる関数が呼び出され、ここに出力される従来の値とは異なる結果が得られる場合があります。</target>
        </trans-unit>
        <trans-unit id="6e55b956134479b369056b6e59411296357349dc" translate="yes" xml:space="preserve">
          <source>This addresses both issues while preserving the &quot;programming at scale&quot; benefits of the 1.0 behavior: global variables have no spooky effect on the meaning of code that may be far away; in the REPL copy-and-paste debugging works and beginners don't have any issues; any time someone either forgets a &lt;code&gt;global&lt;/code&gt; annotation or accidentally shadows an existing global with a local in a soft scope, which would be confusing anyway, they get a nice clear warning.</source>
          <target state="translated">これは、1.0の動作の「大規模なプログラミング」の利点を維持しながら、両方の問題に対処します。グローバル変数は、遠くにある可能性のあるコードの意味に不気味な影響を与えません。 REPLでは、コピーアンドペーストのデバッグが機能し、初心者には問題はありません。誰かが &lt;code&gt;global&lt;/code&gt; アノテーションを忘れたり、ソフトスコープ内のローカルで既存のグローバルを誤ってシャドウイングしたりすると、とにかく混乱しますが、明確な警告が表示されます。</target>
        </trans-unit>
        <trans-unit id="2d8272048e9f98c6a3a33f1987ea12ed1eecadb9" translate="yes" xml:space="preserve">
          <source>This adds the numbers first, then finds the square root of the result.</source>
          <target state="translated">これは、最初に数字を足して、結果の平方根を見つけます。</target>
        </trans-unit>
        <trans-unit id="7e48b7632d07fb8a10c769f17c80cd8b54e9e2ae" translate="yes" xml:space="preserve">
          <source>This allows &lt;code&gt;a&lt;/code&gt; to be of any type. This can often be useful, but it does have a downside: for objects of type &lt;code&gt;MyAmbiguousType&lt;/code&gt;, the compiler will not be able to generate high-performance code. The reason is that the compiler uses the types of objects, not their values, to determine how to build code. Unfortunately, very little can be inferred about an object of type &lt;code&gt;MyAmbiguousType&lt;/code&gt;:</source>
          <target state="translated">これにより &lt;code&gt;a&lt;/code&gt; を任意のタイプにすることができます。これは多くの場合に役立ちますが、欠点があります &lt;code&gt;MyAmbiguousType&lt;/code&gt; 型のオブジェクトの場合、コンパイラーは高性能のコードを生成できません。その理由は、コンパイラーがコードの作成方法を決定するために、値ではなくオブジェクトのタイプを使用するためです。残念ながら、タイプ &lt;code&gt;MyAmbiguousType&lt;/code&gt; のオブジェクトについて推測できることはほとんどありません。</target>
        </trans-unit>
        <trans-unit id="e2ab1e715cac0200b469eb5f929c0503f3de4aef" translate="yes" xml:space="preserve">
          <source>This allows a type assertion to be attached to any expression in-place.</source>
          <target state="translated">これにより、型アサーションを任意の式にインプレースでアタッチできるようになります。</target>
        </trans-unit>
        <trans-unit id="3f66025a332eaca14516e5e48d7273aad3164c30" translate="yes" xml:space="preserve">
          <source>This allows calls like the following to work:</source>
          <target state="translated">これにより、以下のような呼び出しが動作するようになります。</target>
        </trans-unit>
        <trans-unit id="c0d02575ed936e3b66af9d0af1e8728459d34bc3" translate="yes" xml:space="preserve">
          <source>This allows functions which operate on indices to work in combination with &lt;code&gt;skipmissing&lt;/code&gt;. This is notably the case for search and find functions, which return indices valid for the object returned by &lt;code&gt;skipmissing&lt;/code&gt; which are also the indices of the matching entries &lt;em&gt;in the parent array&lt;/em&gt;</source>
          <target state="translated">これにより、インデックスを操作する関数を &lt;code&gt;skipmissing&lt;/code&gt; と組み合わせて機能させることができます。これは特に&lt;em&gt;、親配列内の&lt;/em&gt;一致するエントリのインデックスでもある &lt;code&gt;skipmissing&lt;/code&gt; によって返されたオブジェクトに対して有効なインデックスを返す検索および検索関数の場合です。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="964d516d9978a231b3ac23253bbb246eab6f09f8" translate="yes" xml:space="preserve">
          <source>This approach works very well: the compiler can figure out that &lt;code&gt;A&lt;/code&gt; is an &lt;code&gt;Array{Float64,2}&lt;/code&gt; because it knows the type of the fill value (&lt;code&gt;5.0::Float64&lt;/code&gt;) and the dimensionality (&lt;code&gt;(3, 3)::NTuple{2,Int}&lt;/code&gt;). This implies that the compiler can generate very efficient code for any future usage of &lt;code&gt;A&lt;/code&gt; in the same function.</source>
          <target state="translated">このアプローチは非常にうまく機能します。フィル値のタイプ（ &lt;code&gt;5.0::Float64&lt;/code&gt; ）と次元数（ &lt;code&gt;(3, 3)::NTuple{2,Int}&lt;/code&gt; わかっているため、コンパイラーは &lt;code&gt;A&lt;/code&gt; が &lt;code&gt;Array{Float64,2}&lt;/code&gt; あることを理解できます。、Int}）。これは、コンパイラが同じ関数で &lt;code&gt;A&lt;/code&gt; を将来使用する場合に非常に効率的なコードを生成できることを意味します。</target>
        </trans-unit>
        <trans-unit id="65ab8a07106b1c3de72359a692edb4ea0bcec610" translate="yes" xml:space="preserve">
          <source>This argument will be evaluated at compile-time, when the containing method is defined.</source>
          <target state="translated">この引数はコンパイル時に評価されます。</target>
        </trans-unit>
        <trans-unit id="88e9b548070741ac9a8e34f0ecf3fa01c0587738" translate="yes" xml:space="preserve">
          <source>This avoids the need to continually check for &lt;code&gt;null&lt;/code&gt; values. However, not all object fields are references. Julia considers some types to be &quot;plain data&quot;, meaning all of their data is self-contained and does not reference other objects. The plain data types consist of primitive types (e.g. &lt;code&gt;Int&lt;/code&gt;) and immutable structs of other plain data types. The initial contents of a plain data type is undefined:</source>
          <target state="translated">これにより、 &lt;code&gt;null&lt;/code&gt; 値を継続的にチェックする必要がなくなります。ただし、すべてのオブジェクトフィールドが参照であるとは限りません。 Juliaは、いくつかのタイプを「プレーンデータ」と見なします。つまり、それらのデータはすべて自己完結型であり、他のオブジェクトを参照しません。プレーンデータ型は、プリミティブ型（ &lt;code&gt;Int&lt;/code&gt; など）と他のプレーンデータ型の不変の構造体で構成されます。プレーンデータタイプの初期コンテンツは未定義です。</target>
        </trans-unit>
        <trans-unit id="ce41dd9c15eebc75ffb2137b16913cc2ba4e006d" translate="yes" xml:space="preserve">
          <source>This behavior is an inconvenient consequence of the requirement for type-stability. In the case of &lt;code&gt;sqrt&lt;/code&gt;, most users want &lt;code&gt;sqrt(2.0)&lt;/code&gt; to give a real number, and would be unhappy if it produced the complex number &lt;code&gt;1.4142135623730951 + 0.0im&lt;/code&gt;. One could write the &lt;code&gt;sqrt&lt;/code&gt; function to switch to a complex-valued output only when passed a negative number (which is what &lt;code&gt;sqrt&lt;/code&gt; does in some other languages), but then the result would not be &lt;a href=&quot;#man-type-stability&quot;&gt;type-stable&lt;/a&gt; and the &lt;code&gt;sqrt&lt;/code&gt; function would have poor performance.</source>
          <target state="translated">この動作は、型の安定性の要件の不便な結果です。 &lt;code&gt;sqrt&lt;/code&gt; の場合、ほとんどのユーザーは &lt;code&gt;sqrt(2.0)&lt;/code&gt; に実数を与えることを望んでおり、複素数 &lt;code&gt;1.4142135623730951 + 0.0im&lt;/code&gt; 生成すると不満になります。負の数が渡された場合にのみ複素数値の出力に切り替えるように &lt;code&gt;sqrt&lt;/code&gt; 関数を記述できますが（これは、他の一部の言語で &lt;code&gt;sqrt&lt;/code&gt; が行うことです）、結果は&lt;a href=&quot;#man-type-stability&quot;&gt;型安定性&lt;/a&gt;がなく、 &lt;code&gt;sqrt&lt;/code&gt; 関数のパフォーマンスが低下します。 。</target>
        </trans-unit>
        <trans-unit id="a32fb96b8a45f2e62ae5fc588473c2b576e96e47" translate="yes" xml:space="preserve">
          <source>This behavior is an inconvenient consequence of the requirement for type-stability. In the case of &lt;code&gt;sqrt&lt;/code&gt;, most users want &lt;code&gt;sqrt(2.0)&lt;/code&gt; to give a real number, and would be unhappy if it produced the complex number &lt;code&gt;1.4142135623730951 + 0.0im&lt;/code&gt;. One could write the &lt;code&gt;sqrt&lt;/code&gt; function to switch to a complex-valued output only when passed a negative number (which is what &lt;code&gt;sqrt&lt;/code&gt; does in some other languages), but then the result would not be &lt;a href=&quot;#man-type-stability-1&quot;&gt;type-stable&lt;/a&gt; and the &lt;code&gt;sqrt&lt;/code&gt; function would have poor performance.</source>
          <target state="translated">この動作は、型の安定性の要件による不便な結果です。 &lt;code&gt;sqrt&lt;/code&gt; の場合、ほとんどのユーザーは &lt;code&gt;sqrt(2.0)&lt;/code&gt; に実数を与えることを望んでおり、複素数 &lt;code&gt;1.4142135623730951 + 0.0im&lt;/code&gt; 生成された場合は不満です。負の数が渡されたときにのみ &lt;code&gt;sqrt&lt;/code&gt; 関数を記述して複素数値の出力に切り替えることができます（これは他の一部の言語では &lt;code&gt;sqrt&lt;/code&gt; が行うことです）。その結果、&lt;a href=&quot;#man-type-stability-1&quot;&gt;型が安定せ&lt;/a&gt;ず、 &lt;code&gt;sqrt&lt;/code&gt; 関数のパフォーマンスが低下します。 。</target>
        </trans-unit>
        <trans-unit id="df974535f8d9fdf5af581b7209a9a7d77c94fbc7" translate="yes" xml:space="preserve">
          <source>This behavior is based on the observation that when one uses unsigned hex literals for integer values, one typically is using them to represent a fixed numeric byte sequence, rather than just an integer value.</source>
          <target state="translated">この動作は、整数値に符号なし16進リテラルを使用する場合、整数値だけではなく、固定の数値バイト列を表すために使用するのが一般的であるという観察に基づいています。</target>
        </trans-unit>
        <trans-unit id="e939e0293859dfba0c56cba20185fcd5c0865911" translate="yes" xml:space="preserve">
          <source>This behavior is frequently used in Julia to form an alternative to very short &lt;code&gt;if&lt;/code&gt; statements. Instead of &lt;code&gt;if &amp;lt;cond&amp;gt; &amp;lt;statement&amp;gt; end&lt;/code&gt;, one can write &lt;code&gt;&amp;lt;cond&amp;gt; &amp;amp;&amp;amp; &amp;lt;statement&amp;gt;&lt;/code&gt; (which could be read as: &amp;lt;cond&amp;gt; &lt;em&gt;and then&lt;/em&gt; &amp;lt;statement&amp;gt;). Similarly, instead of &lt;code&gt;if ! &amp;lt;cond&amp;gt; &amp;lt;statement&amp;gt; end&lt;/code&gt;, one can write &lt;code&gt;&amp;lt;cond&amp;gt; || &amp;lt;statement&amp;gt;&lt;/code&gt; (which could be read as: &amp;lt;cond&amp;gt; &lt;em&gt;or else&lt;/em&gt; &amp;lt;statement&amp;gt;).</source>
          <target state="translated">この動作はJuliaで頻繁に使用され、非常に短い &lt;code&gt;if&lt;/code&gt; ステートメントの代わりに使用されます。 &lt;code&gt;if &amp;lt;cond&amp;gt; &amp;lt;statement&amp;gt; end&lt;/code&gt; の場合の代わりに、&amp;lt;cond&amp;gt; &lt;code&gt;&amp;lt;cond&amp;gt; &amp;amp;&amp;amp; &amp;lt;statement&amp;gt;&lt;/code&gt; 書くことができます（これは、&amp;lt;cond&amp;gt;の&lt;em&gt;次に&lt;/em&gt; &amp;lt;statement&amp;gt; として読み取ることができます）。同様に、 &lt;code&gt;if ! &amp;lt;cond&amp;gt; &amp;lt;statement&amp;gt; end&lt;/code&gt; 代わりに！ &amp;lt;cond&amp;gt; &amp;lt;statement&amp;gt; end、 &lt;code&gt;&amp;lt;cond&amp;gt; || &amp;lt;statement&amp;gt;&lt;/code&gt; 書くことができます&amp;lt;statement&amp;gt;（これは、&amp;lt;cond&amp;gt; &lt;em&gt;または&lt;/em&gt; &amp;lt;statement&amp;gt; として読み取ることができます）。</target>
        </trans-unit>
        <trans-unit id="d466a277725d7aaf417bf4b4dabee60f49d4157d" translate="yes" xml:space="preserve">
          <source>This behavior may seem slightly odd for a normal variable, but allows for named functions &amp;ndash; which are just normal variables holding function objects &amp;ndash; to be used before they are defined. This allows functions to be defined in whatever order is intuitive and convenient, rather than forcing bottom up ordering or requiring forward declarations, as long as they are defined by the time they are actually called. As an example, here is an inefficient, mutually recursive way to test if positive integers are even or odd:</source>
          <target state="translated">この動作は、通常の変数では少し奇妙に見えるかもしれませんが、名前付き関数（関数オブジェクトを保持する通常の変数にすぎません）を、定義する前に使用できます。これにより、関数が実際に呼び出される時点で定義されている限り、ボトムアップの順序付けを強制したり、前方宣言を要求したりするのではなく、直感的で便利な任意の順序で関数を定義できます。例として、正の整数が偶数か奇数かをテストする非効率的な相互再帰的な方法を次に示します。</target>
        </trans-unit>
        <trans-unit id="3e1626f887cd8eeaf56c26ebd7e57a24196949b2" translate="yes" xml:space="preserve">
          <source>This behavior of this function varies slightly across platforms. See &lt;a href=&quot;https://nodejs.org/api/fs.html#fs_caveats&quot;&gt;https://nodejs.org/api/fs.html#fs_caveats&lt;/a&gt; for more detailed information.</source>
          <target state="translated">この関数のこの動作は、プラットフォームによって若干異なります。詳細については、&lt;a href=&quot;https://nodejs.org/api/fs.html#fs_caveats&quot;&gt;https：//nodejs.org/api/fs.html#fs_caveats&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="c6ca83ad215b371ad26283d27822e70d4564ed25" translate="yes" xml:space="preserve">
          <source>This call will appear to do nothing. However, it is possible to check whether an exception was thrown:</source>
          <target state="translated">この呼び出しは何もしていないように見えます。しかし、例外が投げられたかどうかを確認することは可能です。</target>
        </trans-unit>
        <trans-unit id="60083a6ef6ec3da96fc4da91379010508c3c9d6d" translate="yes" xml:space="preserve">
          <source>This calls the C standard library function:</source>
          <target state="translated">これは、C標準のライブラリ関数を呼び出します。</target>
        </trans-unit>
        <trans-unit id="d143c9aa138ee903b0f4b83e6fabab2460ecb668" translate="yes" xml:space="preserve">
          <source>This can be expressed much more simply with &lt;a href=&quot;../functions/index#man-vectorized&quot;&gt;dot broadcasting&lt;/a&gt; and by combining it with a normal integer index (instead of extracting the first &lt;code&gt;page&lt;/code&gt; from &lt;code&gt;A&lt;/code&gt; as a separate step). It can even be combined with a &lt;code&gt;:&lt;/code&gt; to extract both diagonals from the two pages at the same time:</source>
          <target state="translated">これは、&lt;a href=&quot;../functions/index#man-vectorized&quot;&gt;ドットブロードキャスト&lt;/a&gt;を使用し、通常の整数インデックスと組み合わせることで、はるかに簡単に表現できます（ &lt;code&gt;A&lt;/code&gt; から最初の &lt;code&gt;page&lt;/code&gt; を個別のステップとして抽出する代わりに）。 &lt;code&gt;:&lt;/code&gt; と組み合わせて、2つのページから両方の対角線を同時に抽出することもできます。</target>
        </trans-unit>
        <trans-unit id="3faddba8dc5ff630709111fd27507fc4b444f486" translate="yes" xml:space="preserve">
          <source>This can be expressed much more simply with &lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;dot broadcasting&lt;/a&gt; and by combining it with a normal integer index (instead of extracting the first &lt;code&gt;page&lt;/code&gt; from &lt;code&gt;A&lt;/code&gt; as a separate step). It can even be combined with a &lt;code&gt;:&lt;/code&gt; to extract both diagonals from the two pages at the same time:</source>
          <target state="translated">これは、&lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;ドットブロードキャスト&lt;/a&gt;を使用し、通常の整数インデックスと組み合わせると（ &lt;code&gt;A&lt;/code&gt; から最初の &lt;code&gt;page&lt;/code&gt; を個別のステップとして抽出する代わりに）、はるかに簡単に表現できます。 &lt;code&gt;:&lt;/code&gt; と組み合わせて、2つのページから両方の対角線を同時に抽出することもできます。</target>
        </trans-unit>
        <trans-unit id="547aafc7ff388590993edee0cc0798c17880cfea" translate="yes" xml:space="preserve">
          <source>This can be identical to the signature present in the Julia code (like &lt;code&gt;mean(x::AbstractArray)&lt;/code&gt;), or a simplified form. Optional arguments should be represented with their default values (i.e. &lt;code&gt;f(x, y=1)&lt;/code&gt;) when possible, following the actual Julia syntax. Optional arguments which do not have a default value should be put in brackets (i.e. &lt;code&gt;f(x[, y])&lt;/code&gt; and &lt;code&gt;f(x[, y[, z]])&lt;/code&gt;). An alternative solution is to use several lines: one without optional arguments, the other(s) with them. This solution can also be used to document several related methods of a given function. When a function accepts many keyword arguments, only include a &lt;code&gt;&amp;lt;keyword arguments&amp;gt;&lt;/code&gt; placeholder in the signature (i.e. &lt;code&gt;f(x; &amp;lt;keyword arguments&amp;gt;)&lt;/code&gt;), and give the complete list under an &lt;code&gt;# Arguments&lt;/code&gt; section (see point 4 below).</source>
          <target state="translated">これは、Juliaコードに存在するシグニチャー（ &lt;code&gt;mean(x::AbstractArray)&lt;/code&gt; ）と同じにすることも、簡略化した形式にすることもできます。オプションの引数は、実際のJulia構文に従って、可能な場合はデフォルト値（つまり &lt;code&gt;f(x, y=1)&lt;/code&gt; ）で表す必要があります。デフォルト値を持たないオプションの引数は、角括弧で囲む必要があります（つまり、 &lt;code&gt;f(x[, y])&lt;/code&gt; と &lt;code&gt;f(x[, y[, z]])&lt;/code&gt; ）。別の解決策は、いくつかの行を使用することです。1つはオプションの引数なしで、もう1つはそれらを使用します。このソリューションは、特定の関数のいくつかの関連メソッドを文書化するためにも使用できます。関数が多くのキーワード引数を受け入れる場合、シグネチャには &lt;code&gt;&amp;lt;keyword arguments&amp;gt;&lt;/code&gt; プレースホルダーのみを含めます（つまり、 &lt;code&gt;f(x; &amp;lt;keyword arguments&amp;gt;)&lt;/code&gt; ）、および &lt;code&gt;# Arguments&lt;/code&gt; セクションの下に完全なリストを提供します（以下のポイント4を参照）。</target>
        </trans-unit>
        <trans-unit id="48dae0d7f0cfc247d97cdffb950575c2c53131a7" translate="yes" xml:space="preserve">
          <source>This can be remedied by passing the result of &lt;a href=&quot;../../base/base/index#Base.catch_backtrace&quot;&gt;&lt;code&gt;catch_backtrace&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt;&lt;code&gt;stacktrace&lt;/code&gt;&lt;/a&gt;. Instead of returning callstack information for the current context, &lt;a href=&quot;../../base/base/index#Base.catch_backtrace&quot;&gt;&lt;code&gt;catch_backtrace&lt;/code&gt;&lt;/a&gt; returns stack information for the context of the most recent exception:</source>
          <target state="translated">これは、&lt;a href=&quot;../../base/base/index#Base.catch_backtrace&quot;&gt; &lt;code&gt;catch_backtrace&lt;/code&gt; &lt;/a&gt;の結果をstacktraceに&lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt; &lt;code&gt;stacktrace&lt;/code&gt; &lt;/a&gt;ことで修正できます。現在のコンテキストの&lt;a href=&quot;../../base/base/index#Base.catch_backtrace&quot;&gt; &lt;code&gt;catch_backtrace&lt;/code&gt; &lt;/a&gt;スタック情報を返す代わりに、catch_backtraceは最新の例外のコンテキストのスタック情報を返します。</target>
        </trans-unit>
        <trans-unit id="31e05199a1305748953864ea5a4fca890bd60950" translate="yes" xml:space="preserve">
          <source>This can be useful for interoperability with programming languages which have different rules for the construction of valid identifiers. For example, to refer to the &lt;code&gt;R&lt;/code&gt; variable &lt;code&gt;draw.segments&lt;/code&gt;, you can use &lt;code&gt;var&quot;draw.segments&quot;&lt;/code&gt; in your Julia code.</source>
          <target state="translated">これは、有効な識別子を構築するためのさまざまなルールを持つプログラミング言語との相互運用性に役立ちます。たとえば、 &lt;code&gt;R&lt;/code&gt; 変数 &lt;code&gt;draw.segments&lt;/code&gt; を参照するには、Juliaコードで &lt;code&gt;var&quot;draw.segments&quot;&lt;/code&gt; 使用できます。</target>
        </trans-unit>
        <trans-unit id="f23915be66d58b3010247cc477edf10741516449" translate="yes" xml:space="preserve">
          <source>This can be written more concisely and efficiently as:</source>
          <target state="translated">として、より簡潔に効率的に書くことができます。</target>
        </trans-unit>
        <trans-unit id="da228c6572574c6e3edc7a497b323e67243e96a5" translate="yes" xml:space="preserve">
          <source>This can lead to race conditions if another process obtains the same file name and creates the file before you are able to. Using &lt;a href=&quot;#Base.Filesystem.mktemp-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;mktemp()&lt;/code&gt;&lt;/a&gt; is recommended instead.</source>
          <target state="translated">これにより、別のプロセスが同じファイル名を取得し、それが可能になる前にファイルを作成すると、競合状態が発生する可能性があります。代わりに&lt;a href=&quot;#Base.Filesystem.mktemp-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;mktemp()&lt;/code&gt; &lt;/a&gt;を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="705c957d58f550245aaa4f046fe3e92349850b38" translate="yes" xml:space="preserve">
          <source>This can lead to security holes if another process obtains the same file name and creates the file before you are able to. Open the file with &lt;code&gt;JL_O_EXCL&lt;/code&gt; if this is a concern. Using &lt;a href=&quot;#Base.Filesystem.mktemp-Tuple%7BAbstractString%7D&quot;&gt;&lt;code&gt;mktemp()&lt;/code&gt;&lt;/a&gt; is also recommended instead.</source>
          <target state="translated">別のプロセスが同じファイル名を取得し、それができる前にファイルを作成すると、これはセキュリティホールにつながる可能性があります。これが懸念される場合は、 &lt;code&gt;JL_O_EXCL&lt;/code&gt; を使用してファイルを開きます。代わりに&lt;a href=&quot;#Base.Filesystem.mktemp-Tuple%7BAbstractString%7D&quot;&gt; &lt;code&gt;mktemp()&lt;/code&gt; &lt;/a&gt;を使用することもお勧めします。</target>
        </trans-unit>
        <trans-unit id="464b5fa1d6c0b5441a8fbbb213e02432dc783d43" translate="yes" xml:space="preserve">
          <source>This catch-all is less specific than any other possible method definition for a pair of parameter values, so it will only be called on pairs of arguments to which no other method definition applies.</source>
          <target state="translated">このキャッチオールは、パラメータ値のペアに対する他のどの可能性のあるメソッド定義よりも特異性が低いので、他のメソッド定義が適用されない引数のペアに対してのみ呼び出されます。</target>
        </trans-unit>
        <trans-unit id="687032e0ca0291c6f37d903f4b4a585e263d0c23" translate="yes" xml:space="preserve">
          <source>This chapter covers the technical details of package loading. To install packages, use &lt;a href=&quot;../../stdlib/pkg/index#Pkg&quot;&gt;&lt;code&gt;Pkg&lt;/code&gt;&lt;/a&gt;, Julia's built-in package manager, to add packages to your active environment. To use packages already in your active environment, write &lt;code&gt;import X&lt;/code&gt; or &lt;code&gt;using X&lt;/code&gt;, as described in the &lt;a href=&quot;../modules/index#modules&quot;&gt;Modules documentation&lt;/a&gt;.</source>
          <target state="translated">この章では、パッケージのロードの技術的な詳細について説明します。パッケージをインストールするには、Juliaの組み込みパッケージマネージャーである&lt;a href=&quot;../../stdlib/pkg/index#Pkg&quot;&gt; &lt;code&gt;Pkg&lt;/code&gt; を&lt;/a&gt;使用して、アクティブな環境にパッケージを追加します。アクティブな環境、書き込みにすでにパッケージを使用するには &lt;code&gt;import X&lt;/code&gt; または &lt;code&gt;using X&lt;/code&gt; で説明したように、&lt;a href=&quot;../modules/index#modules&quot;&gt;モジュールのドキュメント&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0d32190f9f82717ff7b036e591c82b7be9c20e35" translate="yes" xml:space="preserve">
          <source>This chapter covers the technical details of package loading. To install packages, use &lt;a href=&quot;../../stdlib/pkg/index#Pkg-1&quot;&gt;&lt;code&gt;Pkg&lt;/code&gt;&lt;/a&gt;, Julia's built-in package manager, to add packages to your active environment. To use packages already in your active environment, write &lt;code&gt;import X&lt;/code&gt; or &lt;code&gt;using X&lt;/code&gt;, as described in the &lt;a href=&quot;../modules/index#modules-1&quot;&gt;Modules documentation&lt;/a&gt;.</source>
          <target state="translated">この章では、パッケージのロードの技術的な詳細について説明します。パッケージをインストールするには、Juliaの組み込みパッケージマネージャーである&lt;a href=&quot;../../stdlib/pkg/index#Pkg-1&quot;&gt; &lt;code&gt;Pkg&lt;/code&gt; を&lt;/a&gt;使用して、アクティブな環境にパッケージを追加します。すでにアクティブな環境にあるパッケージを使用するには、&lt;a href=&quot;../modules/index#modules-1&quot;&gt;モジュールのドキュメントで&lt;/a&gt;説明されているように、 &lt;code&gt;import X&lt;/code&gt; または &lt;code&gt;using X&lt;/code&gt; て記述します。</target>
        </trans-unit>
        <trans-unit id="4a06224a21aa063e4c9f046613bebaabd39494a6" translate="yes" xml:space="preserve">
          <source>This check is usually &lt;em&gt;costless&lt;/em&gt;, as the compiler can elide the check for valid concrete types. If the second argument is also computed, it may be advantageous to provide an &lt;a href=&quot;../constructors/index#man-outer-constructor-methods&quot;&gt;outer constructor method&lt;/a&gt; that performs this calculation:</source>
          <target state="translated">コンパイラは有効な具象型のチェックを省略できるため、このチェックは通常&lt;em&gt;コスト&lt;/em&gt;がかかりません。2番目の引数も計算される場合は、この計算を実行する&lt;a href=&quot;../constructors/index#man-outer-constructor-methods&quot;&gt;外部コンストラクターメソッド&lt;/a&gt;を提供すると有利な場合があります。</target>
        </trans-unit>
        <trans-unit id="f560041e9c1b16deb7ab6bd9aff4671ee86058bc" translate="yes" xml:space="preserve">
          <source>This code is an implementation of the algorithm described in: An Improved Algorithm for &lt;code&gt;hypot(a,b)&lt;/code&gt; by Carlos F. Borges The article is available online at ArXiv at the link https://arxiv.org/abs/1904.09481</source>
          <target state="translated">このコードは、Carlos F. Borgesによる &lt;code&gt;hypot(a,b)&lt;/code&gt; の改善されたアルゴリズムで説明されているアルゴリズムの実装です。この記事は、リンクhttps://arxiv.org/abs/1904.09481のArXivでオンラインで入手できます。</target>
        </trans-unit>
        <trans-unit id="5d88d1d0a18f5d7f665080e348536b07fa18d945" translate="yes" xml:space="preserve">
          <source>This code will not initialize all of &lt;code&gt;a&lt;/code&gt;, since each process will have a separate copy of it. Parallel for loops like these must be avoided. Fortunately, &lt;a href=&quot;#man-shared-arrays&quot;&gt;Shared Arrays&lt;/a&gt; can be used to get around this limitation:</source>
          <target state="translated">このコードは、すべての初期化されません各プロセスはそれの別のコピーを持つことになりますから、。このような並列forループは避ける必要があります。幸い、&lt;a href=&quot;#man-shared-arrays&quot;&gt;共有アレイ&lt;/a&gt;を使用して、この制限を回避できます。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4ea11403bb989c686f5968328179e98cbaa9f269" translate="yes" xml:space="preserve">
          <source>This code will not initialize all of &lt;code&gt;a&lt;/code&gt;, since each process will have a separate copy of it. Parallel for loops like these must be avoided. Fortunately, &lt;a href=&quot;#man-shared-arrays-1&quot;&gt;Shared Arrays&lt;/a&gt; can be used to get around this limitation:</source>
          <target state="translated">このコードは、すべての初期化されません各プロセスはそれの別のコピーを持つことになりますから、。このような並列forループは避けなければなりません。さいわい、&lt;a href=&quot;#man-shared-arrays-1&quot;&gt;共有配列&lt;/a&gt;を使用してこの制限を回避できます。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d51d7a463700079744f5ff1d3af6ba57fc16feaf" translate="yes" xml:space="preserve">
          <source>This construct implements the pattern of assigning iterations to multiple processes, and combining them with a specified reduction (in this case &lt;code&gt;(+)&lt;/code&gt;). The result of each iteration is taken as the value of the last expression inside the loop. The whole parallel loop expression itself evaluates to the final answer.</source>
          <target state="translated">この構成は、反復を複数のプロセスに割り当て、それらを指定されたリダクション（この場合は &lt;code&gt;(+)&lt;/code&gt; ）と組み合わせるパターンを実装します。各反復の結果は、ループ内の最後の式の値として使用されます。並列ループ式全体が評価され、最終的な回答になります。</target>
        </trans-unit>
        <trans-unit id="56c993971b23a28c699db5a6937a4a9bfd78df8b" translate="yes" xml:space="preserve">
          <source>This construction avoids the multiplication and addition operations.</source>
          <target state="translated">この構造は、掛け算や足し算の操作を避けることができます。</target>
        </trans-unit>
        <trans-unit id="aa8d7cac7cb360d58676d491242e77dac0c56e52" translate="yes" xml:space="preserve">
          <source>This constructor will be invoked by the syntax &lt;code&gt;SummedArray(a)&lt;/code&gt;. The syntax &lt;code&gt;new{T,S}&lt;/code&gt; allows specifying parameters for the type to be constructed, i.e. this call will return a &lt;code&gt;SummedArray{T,S}&lt;/code&gt;. &lt;code&gt;new{T,S}&lt;/code&gt; can be used in any constructor definition, but for convenience the parameters to &lt;code&gt;new{}&lt;/code&gt; are automatically derived from the type being constructed when possible.</source>
          <target state="translated">このコンストラクターは、構文 &lt;code&gt;SummedArray(a)&lt;/code&gt; によって呼び出されます。構文 &lt;code&gt;new{T,S}&lt;/code&gt; では、構築する型のパラメーターを指定できます。つまり、この呼び出しは &lt;code&gt;SummedArray{T,S}&lt;/code&gt; を返します。 &lt;code&gt;new{T,S}&lt;/code&gt; は、任意のコンストラクター定義で使用できますが、便宜上、 &lt;code&gt;new{}&lt;/code&gt; パラメーターは、可能な場合は構築される型から自動的に派生します。</target>
        </trans-unit>
        <trans-unit id="b7a16492f267624e6cffa44c16d2f3cbbc8fdcef" translate="yes" xml:space="preserve">
          <source>This convenience function returns an iterator which filters out &lt;code&gt;missing&lt;/code&gt; values efficiently. It can therefore be used with any function which supports iterators</source>
          <target state="translated">この便利な関数は、 &lt;code&gt;missing&lt;/code&gt; 値を効率的に除外する反復子を返します。したがって、イテレータをサポートする任意の関数で使用できます</target>
        </trans-unit>
        <trans-unit id="7839ec061c3b0d3cae9d3ceb52f6e6b0eb7552ce" translate="yes" xml:space="preserve">
          <source>This convention for ordering arrays is common in many languages like Fortran, Matlab, and R (to name a few). The alternative to column-major ordering is row-major ordering, which is the convention adopted by C and Python (&lt;code&gt;numpy&lt;/code&gt;) among other languages. Remembering the ordering of arrays can have significant performance effects when looping over arrays. A rule of thumb to keep in mind is that with column-major arrays, the first index changes most rapidly. Essentially this means that looping will be faster if the inner-most loop index is the first to appear in a slice expression.</source>
          <target state="translated">配列の順序付けに関するこの規則は、Fortran、Matlab、Rなどの多くの言語で一般的です（いくつか例を挙げます）。列優先順の代わりに行優先順があり、これは他の言語の中でCおよびPython（ &lt;code&gt;numpy&lt;/code&gt; ）で採用されている規則です。配列の順序を覚えておくと、配列をループするときにパフォーマンスに大きな影響を与える可能性があります。経験則として、列優先の配列では、最初のインデックスが最も急速に変化することを覚えておいてください。基本的に、これは、最も内側のループインデックスがスライス式に最初に現れる場合、ループがより高速になることを意味します。</target>
        </trans-unit>
        <trans-unit id="1645b7896bc037bdea36ccff78d78a2be6b15f8e" translate="yes" xml:space="preserve">
          <source>This convention for ordering arrays is common in many languages like Fortran, Matlab, and R (to name a few). The alternative to column-major ordering is row-major ordering, which is the convention adopted by C and Python (&lt;code&gt;numpy&lt;/code&gt;) among other languages. Remembering the ordering of arrays can have significant performance effects when looping over arrays. A rule of thumb to keep in mind is that with column-major arrays, the first index changes most rapidly. Essentially this means that looping will be faster if the inner-most loop index is the first to appear in a slice expression. Keep in mind that indexing an array with &lt;code&gt;:&lt;/code&gt; is an implicit loop that iteratively accesses all elements within a particular dimension; it can be faster to extract columns than rows, for example.</source>
          <target state="translated">配列を順序付けるためのこの規則は、Fortran、Matlab、Rなどの多くの言語で一般的です（いくつか例を挙げます）。列優先の順序の代わりに、行優先の順序があります。これは、他の言語の中でもCやPython（ &lt;code&gt;numpy&lt;/code&gt; ）で採用されている規則です。配列の順序を覚えておくと、配列をループするときにパフォーマンスに大きな影響を与える可能性があります。覚えておくべき経験則は、列優先配列では、最初のインデックスが最も急速に変化するということです。基本的に、これは、最も内側のループインデックスがスライス式に最初に表示される場合、ループが高速になることを意味します。 &lt;code&gt;:&lt;/code&gt; を使用して配列にインデックスを付けることは、特定の次元内のすべての要素に繰り返しアクセスする暗黙のループであることに注意してください。たとえば、行よりも列を抽出する方が高速な場合があります。</target>
        </trans-unit>
        <trans-unit id="7355c6564b5fcc9846f7acd500769583417df709" translate="yes" xml:space="preserve">
          <source>This creates a 25-by-30000 &lt;code&gt;BitArray&lt;/code&gt;, linked to the file associated with stream &lt;code&gt;io&lt;/code&gt;.</source>
          <target state="translated">これにより、ストリーム &lt;code&gt;io&lt;/code&gt; に関連付けられたファイルにリンクされた25行30000 &lt;code&gt;BitArray&lt;/code&gt; が作成されます。</target>
        </trans-unit>
        <trans-unit id="94e825958b08717e7b2f87e178ba335682000732" translate="yes" xml:space="preserve">
          <source>This creates a function taking one argument &lt;code&gt;x&lt;/code&gt; and returning the value of the polynomial &lt;code&gt;x^2 + 2x - 1&lt;/code&gt; at that value. Notice that the result is a generic function, but with a compiler-generated name based on consecutive numbering.</source>
          <target state="translated">これは、1つの引数 &lt;code&gt;x&lt;/code&gt; を取り、その値で多項式 &lt;code&gt;x^2 + 2x - 1&lt;/code&gt; の値を返す関数を作成します。結果はジェネリック関数ですが、連続した番号付けに基づいてコンパイラが生成した名前であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="c16c73de1b45daf105f01df93653955f2810669b" translate="yes" xml:space="preserve">
          <source>This declaration defines a new parametric type, &lt;code&gt;Point{T}&lt;/code&gt;, holding two &quot;coordinates&quot; of type &lt;code&gt;T&lt;/code&gt;. What, one may ask, is &lt;code&gt;T&lt;/code&gt;? Well, that's precisely the point of parametric types: it can be any type at all (or a value of any bits type, actually, although here it's clearly used as a type). &lt;code&gt;Point{Float64}&lt;/code&gt; is a concrete type equivalent to the type defined by replacing &lt;code&gt;T&lt;/code&gt; in the definition of &lt;code&gt;Point&lt;/code&gt; with &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;. Thus, this single declaration actually declares an unlimited number of types: &lt;code&gt;Point{Float64}&lt;/code&gt;, &lt;code&gt;Point{AbstractString}&lt;/code&gt;, &lt;code&gt;Point{Int64}&lt;/code&gt;, etc. Each of these is now a usable concrete type:</source>
          <target state="translated">この宣言は、タイプ &lt;code&gt;T&lt;/code&gt; の 2つの「座標」を保持する新しいパラメトリックタイプ &lt;code&gt;Point{T}&lt;/code&gt; 定義します。 、一つは、何であるかを求めることができる &lt;code&gt;T&lt;/code&gt; ？まあ、それがまさにパラメトリックタイプのポイントです。これは、すべてのタイプ（または実際には任意のビットタイプの値ですが、ここではタイプとして明確に使用されています）にすることができます。 &lt;code&gt;Point{Float64}&lt;/code&gt; は、 &lt;code&gt;Point&lt;/code&gt; の定義の &lt;code&gt;T&lt;/code&gt; を&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;で置き換えることによって定義される型と同等の具象型です。したがって、この単一の宣言は、実際には無制限の数の型（ &lt;code&gt;Point{Float64}&lt;/code&gt; 、 &lt;code&gt;Point{AbstractString}&lt;/code&gt; 、 &lt;code&gt;Point{Int64}&lt;/code&gt; など）を宣言します。これらのそれぞれが使用可能な具象型になりました：</target>
        </trans-unit>
        <trans-unit id="b01b6974b06d7624ee6c363ea6ebb8266c1f09ca" translate="yes" xml:space="preserve">
          <source>This declaration has the same effect as the earlier definition of the &lt;code&gt;Foo&lt;/code&gt; type without an explicit inner constructor method. The following two types are equivalent &amp;ndash; one with a default constructor, the other with an explicit constructor:</source>
          <target state="translated">この宣言は、明示的な内部コンストラクタメソッドを持たない &lt;code&gt;Foo&lt;/code&gt; 型の以前の定義と同じ効果があります。次の2つのタイプは同等です。1つはデフォルトのコンストラクター、もう1つは明示的なコンストラクターです。</target>
        </trans-unit>
        <trans-unit id="e6768dfeff6ea03f38de8deb6433998fc2233bac" translate="yes" xml:space="preserve">
          <source>This demonstrates some important aspects of scope: in a scope, each variable can only have one meaning, and that meaning is determined regardless of the order of expressions. The presence of the expression &lt;code&gt;s = t&lt;/code&gt; in the loop causes &lt;code&gt;s&lt;/code&gt; to be local to the loop, which means that it is also local when it appears on the right hand side of &lt;code&gt;t = s + i&lt;/code&gt;, even though that expression appears first and is evaluated first. One might imagine that the &lt;code&gt;s&lt;/code&gt; on the first line of the loop could be global while the &lt;code&gt;s&lt;/code&gt; on the second line of the loop is local, but that's not possible since the two lines are in the same scope block and each variable can only mean one thing in a given scope.</source>
          <target state="translated">これは、スコープのいくつかの重要な側面を示しています。スコープでは、各変数は1つの意味しか持つことができず、その意味は式の順序に関係なく決定されます。発現の存在 &lt;code&gt;s = t&lt;/code&gt; ループ原因で &lt;code&gt;s&lt;/code&gt; 、それがの右側に表示されたとき、それは、ローカルであることを意味するループに対してローカルであると &lt;code&gt;t = s + i&lt;/code&gt; 発現が最初に表示されているにもかかわらず、最初に評価されます。一つは、という想像 &lt;code&gt;s&lt;/code&gt; 間、ループの最初の行には、グローバルな可能性 &lt;code&gt;s&lt;/code&gt; ループの2行目にはローカルですが、2行は同じスコープのブロックにあり、各変数は唯一の平均1をすることができるので、それは不可能です特定のスコープ内のもの。</target>
        </trans-unit>
        <trans-unit id="6cae1102db29e2ef980a4d7e4e7854fb0a34c8cd" translate="yes" xml:space="preserve">
          <source>This dependency graph represented as a dictionary, looks like this:</source>
          <target state="translated">この依存関係グラフを辞書で表すと、次のようになります。</target>
        </trans-unit>
        <trans-unit id="b9aaf0a6f68d326c3813770015ef1479f59b61ec" translate="yes" xml:space="preserve">
          <source>This distinction determines which scalar indexing methods the type must define. &lt;code&gt;IndexLinear()&lt;/code&gt; arrays are simple: just define &lt;code&gt;getindex(A::ArrayType, i::Int)&lt;/code&gt;. When the array is subsequently indexed with a multidimensional set of indices, the fallback &lt;code&gt;getindex(A::AbstractArray, I...)()&lt;/code&gt; efficiently converts the indices into one linear index and then calls the above method. &lt;code&gt;IndexCartesian()&lt;/code&gt; arrays, on the other hand, require methods to be defined for each supported dimensionality with &lt;code&gt;ndims(A)&lt;/code&gt;&lt;code&gt;Int&lt;/code&gt; indices. For example, &lt;a href=&quot;../../stdlib/sparsearrays/index#SparseArrays.SparseMatrixCSC&quot;&gt;&lt;code&gt;SparseMatrixCSC&lt;/code&gt;&lt;/a&gt; from the &lt;code&gt;SparseArrays&lt;/code&gt; standard library module, only supports two dimensions, so it just defines &lt;code&gt;getindex(A::SparseMatrixCSC, i::Int, j::Int)&lt;/code&gt;. The same holds for &lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt;&lt;code&gt;setindex!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この違いにより、型で定義する必要があるスカラーインデックス方法が決まります。 &lt;code&gt;IndexLinear()&lt;/code&gt; 配列は単純です &lt;code&gt;getindex(A::ArrayType, i::Int)&lt;/code&gt; 定義するだけです。その後、配列が多次元のインデックスセットでインデックス付けされると、フォールバック &lt;code&gt;getindex(A::AbstractArray, I...)()&lt;/code&gt; はインデックスを効率的に1つの線形インデックスに変換してから、上記のメソッドを呼び出します。一方、 &lt;code&gt;IndexCartesian()&lt;/code&gt; 配列では、 &lt;code&gt;ndims(A)&lt;/code&gt; &lt;code&gt;Int&lt;/code&gt; インデックスを使用して、サポートされている次元ごとにメソッドを定義する必要があります。たとえば、 &lt;code&gt;SparseArrays&lt;/code&gt; 標準ライブラリモジュールの&lt;a href=&quot;../../stdlib/sparsearrays/index#SparseArrays.SparseMatrixCSC&quot;&gt; &lt;code&gt;SparseMatrixCSC&lt;/code&gt; &lt;/a&gt;は、2つの次元のみをサポートしているため、 &lt;code&gt;getindex(A::SparseMatrixCSC, i::Int, j::Int)&lt;/code&gt; 。同じことが&lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt; &lt;code&gt;setindex!&lt;/code&gt; &lt;/a&gt;も当てはまります！。</target>
        </trans-unit>
        <trans-unit id="341c5e7333e9b447849339d0853fcd7d14d2830b" translate="yes" xml:space="preserve">
          <source>This does not apply to &lt;code&gt;function&lt;/code&gt; or &lt;code&gt;struct&lt;/code&gt; declarations. However, anonymous functions bound to global variables are serialized as can be seen below.</source>
          <target state="translated">これは、 &lt;code&gt;function&lt;/code&gt; または &lt;code&gt;struct&lt;/code&gt; 宣言には適用されません。ただし、以下に示すように、グローバル変数にバインドされた無名関数はシリアル化されます。</target>
        </trans-unit>
        <trans-unit id="86f9320eb728977a1d66ab43b8b74b16022a0160" translate="yes" xml:space="preserve">
          <source>This environment variable only has an effect if Julia was compiled with JIT profiling support, using either</source>
          <target state="translated">この環境変数は、Julia が JIT プロファイリングをサポートしてコンパイルされた場合にのみ有効です。</target>
        </trans-unit>
        <trans-unit id="b8ecde1ad84c7fa04736dc884f170c7012ed70ab" translate="yes" xml:space="preserve">
          <source>This environment variable only has an effect if Julia was compiled with garbage-collection debugging (that is, if &lt;code&gt;WITH_GC_DEBUG_ENV&lt;/code&gt; is set to &lt;code&gt;1&lt;/code&gt; in the build configuration).</source>
          <target state="translated">この環境変数は、Juliaがガベージコレクションデバッグでコンパイルされた場合（つまり、ビルド構成で &lt;code&gt;WITH_GC_DEBUG_ENV&lt;/code&gt; が &lt;code&gt;1&lt;/code&gt; に設定されている場合）にのみ効果があります。</target>
        </trans-unit>
        <trans-unit id="9da7aae5652d5d79a524e4cda3f0dfe80c0acd90" translate="yes" xml:space="preserve">
          <source>This error indicates that the conditional was of the wrong type: &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt; rather than the required &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt;&lt;code&gt;Bool&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">このエラーは、条件が間違ったタイプであったことを示しています：必要な&lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt; &lt;code&gt;Bool&lt;/code&gt; &lt;/a&gt;ではなく&lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="041d6d9502e571d35122b54e3f7555ea1dca4d3a" translate="yes" xml:space="preserve">
          <source>This escaping mechanism can be used to &quot;violate&quot; hygiene when necessary, in order to introduce or manipulate user variables. For example, the following macro sets &lt;code&gt;x&lt;/code&gt; to zero in the call environment:</source>
          <target state="translated">このエスケープメカニズムは、ユーザー変数を導入または操作するために、必要に応じて衛生状態を「違反」するために使用できます。たとえば、次のマクロは、呼び出し環境で &lt;code&gt;x&lt;/code&gt; をゼロに設定します。</target>
        </trans-unit>
        <trans-unit id="9c5c328c41b593f3c08a09090fb0468199894a7b" translate="yes" xml:space="preserve">
          <source>This example demonstrates a powerful and often-used parallel programming pattern. Many iterations run independently over several processes, and then their results are combined using some function. The combination process is called a &lt;em&gt;reduction&lt;/em&gt;, since it is generally tensor-rank-reducing: a vector of numbers is reduced to a single number, or a matrix is reduced to a single row or column, etc. In code, this typically looks like the pattern &lt;code&gt;x = f(x,v[i])&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is the accumulator, &lt;code&gt;f&lt;/code&gt; is the reduction function, and the &lt;code&gt;v[i]&lt;/code&gt; are the elements being reduced. It is desirable for &lt;code&gt;f&lt;/code&gt; to be associative, so that it does not matter what order the operations are performed in.</source>
          <target state="translated">この例は、強力で頻繁に使用される並列プログラミングパターンを示しています。多くの反復は複数のプロセスで独立して実行され、その結果はいくつかの関数を使用して結合されます。組み合わせプロセスは、一般にテンソルランク&lt;em&gt;削減&lt;/em&gt;であるため、&lt;em&gt;削減&lt;/em&gt;と呼ばれます。数値のベクトルが単一の数値に削減されるか、行列が単一の行または列に削減されるなどです。コードでは、通常、次のようになります。パターン &lt;code&gt;x = f(x,v[i])&lt;/code&gt; 。ここで、 &lt;code&gt;x&lt;/code&gt; はアキュムレータ、 &lt;code&gt;f&lt;/code&gt; はリダクション関数、 &lt;code&gt;v[i]&lt;/code&gt; はリダクションされる要素です。 &lt;code&gt;f&lt;/code&gt; は連想的であることが望ましいため、演算が実行される順序は関係ありません。</target>
        </trans-unit>
        <trans-unit id="6dfb71272e9303585708d721385dced1cec06a7d" translate="yes" xml:space="preserve">
          <source>This example first allocates an array of bytes, then calls the C library function &lt;code&gt;gethostname&lt;/code&gt; to fill the array in with the hostname, takes a pointer to the hostname buffer, and converts the pointer to a Julia string, assuming that it is a NUL-terminated C string. It is common for C libraries to use this pattern of requiring the caller to allocate memory to be passed to the callee and filled in. Allocation of memory from Julia like this is generally accomplished by creating an uninitialized array and passing a pointer to its data to the C function. This is why we don't use the &lt;code&gt;Cstring&lt;/code&gt; type here: as the array is uninitialized, it could contain NUL bytes. Converting to a &lt;code&gt;Cstring&lt;/code&gt; as part of the &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; checks for contained NUL bytes and could therefore throw a conversion error.</source>
          <target state="translated">この例では、最初にバイトの配列を割り当て、次にCライブラリ関数 &lt;code&gt;gethostname&lt;/code&gt; を呼び出して配列にホスト名を入力し、ホスト名バッファーへのポインターを取得して、そのポインターをJulia文字列に変換します。 C文字列。 Cライブラリでは、このパターンを使用して、呼び出し元が呼び出し先に渡されて埋められるようにメモリを割り当てる必要があります。このようなJuliaからのメモリの割り当ては、初期化されていない配列を作成し、そのデータへのポインタをC関数。これが、ここで &lt;code&gt;Cstring&lt;/code&gt; 型を使用しない理由です。配列は初期化されていないため、NULバイトを含む可能性があります。 &lt;code&gt;Cstring&lt;/code&gt; 一部としての&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt;への変換 含まれているNULバイトをチェックするため、変換エラーをスローする可能性があります。</target>
        </trans-unit>
        <trans-unit id="81f56d42721e023666b42ce5d20872f19e3f3c1b" translate="yes" xml:space="preserve">
          <source>This example first allocates an array of bytes. It then calls the C library function &lt;code&gt;gethostname&lt;/code&gt; to populate the array with the hostname. Finally, it takes a pointer to the hostname buffer, and converts the pointer to a Julia string, assuming that it is a NUL-terminated C string. It is common for C libraries to use this pattern of requiring the caller to allocate memory to be passed to the callee and populated. Allocation of memory from Julia like this is generally accomplished by creating an uninitialized array and passing a pointer to its data to the C function. This is why we don't use the &lt;code&gt;Cstring&lt;/code&gt; type here: as the array is uninitialized, it could contain NUL bytes. Converting to a &lt;code&gt;Cstring&lt;/code&gt; as part of the &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; checks for contained NUL bytes and could therefore throw a conversion error.</source>
          <target state="translated">この例では、最初にバイトの配列を割り当てます。次に、Cライブラリ関数 &lt;code&gt;gethostname&lt;/code&gt; を呼び出して、配列にホスト名を入力します。最後に、ホスト名バッファーへのポインターを受け取り、それがNULで終了するC文字列であると想定して、ポインターをJulia文字列に変換します。 Cライブラリでは、呼び出し元にメモリを割り当てて呼び出し先に渡し、データを入力するように要求するというこのパターンを使用するのが一般的です。このようなJuliaからのメモリの割り当ては、通常、初期化されていない配列を作成し、そのデータへのポインタをC関数に渡すことによって実現されます。ここで &lt;code&gt;Cstring&lt;/code&gt; タイプを使用しないのはこのためです。配列は初期化されていないため、NULバイトが含まれている可能性があります。変換 &lt;code&gt;Cstring&lt;/code&gt; の一環として&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; 含まれているNULバイトをチェックするため、変換エラーがスローされる可能性があります。</target>
        </trans-unit>
        <trans-unit id="0c1ac1e55fd925a7d22f5a60b11f3b3c1b4549bc" translate="yes" xml:space="preserve">
          <source>This example generates many subnormal numbers because the values in &lt;code&gt;a&lt;/code&gt; become an exponentially decreasing curve, which slowly flattens out over time.</source>
          <target state="translated">この例では、 &lt;code&gt;a&lt;/code&gt; の値が指数関数的に減少する曲線になり、時間とともに徐々に平坦になるため、多くの非正規数が生成されます。</target>
        </trans-unit>
        <trans-unit id="9daa7910681479c02c2c50ed435d4f90bf88e739" translate="yes" xml:space="preserve">
          <source>This example highlights the general principle that the adjacent representable floating-point numbers also have adjacent binary integer representations.</source>
          <target state="translated">この例は、隣接する表現可能な浮動小数点数が隣接する2進整数表現も持つという一般的な原理を強調しています。</target>
        </trans-unit>
        <trans-unit id="908e2e897728777e829b7f08db5b9e855ae0cc96" translate="yes" xml:space="preserve">
          <source>This example is similar to the previous one, except there are two stages of consumers, and the stages have different latency so they use a different number of parallel workers, to maintain saturated throughput.</source>
          <target state="translated">この例は前の例と似ていますが、消費者のステージが2つあり、ステージは異なるレイテンシを持っているので、飽和したスループットを維持するために異なる数の並列ワーカーを使用しています。</target>
        </trans-unit>
        <trans-unit id="547c626a1378ed0fe9150c862ad51213777da963" translate="yes" xml:space="preserve">
          <source>This example map includes three different kinds of package locations (the first and third are part of the default load path):</source>
          <target state="translated">この例のマップには、3 種類の異なるパッケージの場所が含まれています (1 番目と 3 番目はデフォルトのロードパスの一部です)。</target>
        </trans-unit>
        <trans-unit id="1a00200535ab1c13ccef86e68b0800e8609303b1" translate="yes" xml:space="preserve">
          <source>This experimental interface supports Julia's multi-threading capabilities. Types and functions described here might (and likely will) change in the future.</source>
          <target state="translated">この実験的なインターフェイスは、Julia のマルチスレッド機能をサポートしています。ここに記述されている型や機能は将来的に変更される可能性があります (そして、変更される可能性もあります)。</target>
        </trans-unit>
        <trans-unit id="57cf6614fe11299d25cdfc84dad18699d2670d90" translate="yes" xml:space="preserve">
          <source>This expression constructs a name using &lt;code&gt;string&lt;/code&gt;, then substitutes this name into a new &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; expression, which is then evaluated. Keep in mind that &lt;code&gt;eval&lt;/code&gt; only operates at the top level, so within this expression local variables will not be available (unless their values are substituted with &lt;code&gt;$&lt;/code&gt;). For this reason, &lt;code&gt;eval&lt;/code&gt; is typically only used to form top-level definitions, for example when wrapping libraries that contain many similar functions. A similar example can be constructed for &lt;a href=&quot;../../base/c/index#Base.@cfunction&quot;&gt;&lt;code&gt;@cfunction&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この式は &lt;code&gt;string&lt;/code&gt; を使用して名前を作成し、次にこの名前を新しい&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt;式に代入して、評価されます。ことを覚えておいてください &lt;code&gt;eval&lt;/code&gt; は（それらの値がで置換されていない限り、ローカル変数が使用できなくなりますので、この式の中で、唯一のトップレベルで動作 &lt;code&gt;$&lt;/code&gt; ）。このため、通常、 &lt;code&gt;eval&lt;/code&gt; はトップレベルの定義を作成する場合にのみ使用されます。たとえば、類似の関数を多く含むライブラリをラップする場合などです。&lt;a href=&quot;../../base/c/index#Base.@cfunction&quot;&gt; &lt;code&gt;@cfunction&lt;/code&gt; &lt;/a&gt;についても同様の例を作成できます。</target>
        </trans-unit>
        <trans-unit id="db9c10f7c39ed65401660ce94eeb87fdf0a1c09b" translate="yes" xml:space="preserve">
          <source>This expression invokes the &lt;code&gt;echo&lt;/code&gt; command with three words as arguments: &lt;code&gt;hello&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, and &lt;code&gt;sort&lt;/code&gt;. The result is that a single line is printed: &lt;code&gt;hello | sort&lt;/code&gt;. How, then, does one construct a pipeline? Instead of using &lt;code&gt;'|'&lt;/code&gt; inside of backticks, one uses &lt;code&gt;pipeline&lt;/code&gt;:</source>
          <target state="translated">この式は、3つの単語を引数として、 &lt;code&gt;echo&lt;/code&gt; コマンドを呼び出します &lt;code&gt;hello&lt;/code&gt; 、 &lt;code&gt;|&lt;/code&gt; 、 &lt;code&gt;sort&lt;/code&gt; 。その結果、1行が出力されます &lt;code&gt;hello | sort&lt;/code&gt; 。では、どのようにしてパイプラインを構築するのでしょうか？ &lt;code&gt;'|'&lt;/code&gt; の代わりに バックティックの内側では、 &lt;code&gt;pipeline&lt;/code&gt; 使用します：</target>
        </trans-unit>
        <trans-unit id="d8eb7a249785528e4f915a12603e4055a737c99e" translate="yes" xml:space="preserve">
          <source>This feature is experimental and could change or disappear in future versions of Julia. Incorrect use of the &lt;code&gt;@simd&lt;/code&gt; macro may cause unexpected results.</source>
          <target state="translated">この機能は実験的なものであり、Juliaの将来のバージョンでは変更または削除される可能性があります。 &lt;code&gt;@simd&lt;/code&gt; マクロを誤って使用すると、予期しない結果が生じる可能性があります。</target>
        </trans-unit>
        <trans-unit id="d5a37ab2e3447a402ef6dae9693a9619588c5031" translate="yes" xml:space="preserve">
          <source>This feature is useful for avoiding performance &quot;gotchas&quot; that could occur if one of the assignments to a variable changed its type unexpectedly.</source>
          <target state="translated">この機能は、変数への代入の1つが予期せず型を変更した場合に発生する可能性のあるパフォーマンスの「ゲッチャン」を回避するのに便利です。</target>
        </trans-unit>
        <trans-unit id="783c0c8452e06904718657237123803cbb8eb1c2" translate="yes" xml:space="preserve">
          <source>This form is often found on method signatures.</source>
          <target state="translated">この形式は、メソッド署名によく見られます。</target>
        </trans-unit>
        <trans-unit id="cc3b7f9edb1c8e585d8a1d71b69faf0b48006d70" translate="yes" xml:space="preserve">
          <source>This format should not to be confused with the older &lt;em&gt;WY&lt;/em&gt; representation &lt;a href=&quot;#footnote-Bischof1987&quot;&gt;[Bischof1987]&lt;/a&gt;.</source>
          <target state="translated">この形式は、古い&lt;em&gt;WY&lt;/em&gt;表現&lt;a href=&quot;#footnote-Bischof1987&quot;&gt;[Bischof1987]&lt;/a&gt;と混同しないでください。</target>
        </trans-unit>
        <trans-unit id="c5430a5df9a2060598aa23b84f7a5871adf25fad" translate="yes" xml:space="preserve">
          <source>This format should not to be confused with the older &lt;em&gt;WY&lt;/em&gt; representation &lt;sup&gt;&lt;a href=&quot;#footnote-Bischof1987&quot; id=&quot;citeref-Bischof1987&quot;&gt;[Bischof1987]&lt;/a&gt;&lt;/sup&gt;.</source>
          <target state="translated">この形式を古い&lt;em&gt;WY&lt;/em&gt;表現&lt;sup&gt;&lt;a href=&quot;#footnote-Bischof1987&quot; id=&quot;citeref-Bischof1987&quot;&gt;[Bischof1987]&lt;/a&gt;&lt;/sup&gt;と混同しないでください。</target>
        </trans-unit>
        <trans-unit id="c12c069ce178f9d50647ca11f433a6b7234b2e36" translate="yes" xml:space="preserve">
          <source>This function accepts two arguments &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; and returns the value of the last expression evaluated, which is &lt;code&gt;x + y&lt;/code&gt;.</source>
          <target state="translated">この関数は、2つの引数 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; を受け入れ、最後に評価された式の値である &lt;code&gt;x + y&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="590cd9bbe677a0c8ce068af3ae23d18c7dfa14a9" translate="yes" xml:space="preserve">
          <source>This function can be used to implement transactional semantics. Before the transaction, one records the value in &lt;code&gt;x&lt;/code&gt;. After the transaction, the new value is stored only if &lt;code&gt;x&lt;/code&gt; has not been modified in the mean time.</source>
          <target state="translated">この関数は、トランザクションセマンティクスを実装するために使用できます。トランザクションの前に、値を &lt;code&gt;x&lt;/code&gt; に記録します。トランザクション後、その間に &lt;code&gt;x&lt;/code&gt; が変更されていない場合にのみ、新しい値が保存されます。</target>
        </trans-unit>
        <trans-unit id="65b3ba291cce49f270b3e77d3c5998270ae43f60" translate="yes" xml:space="preserve">
          <source>This function computes a floating point representation of the modulus after division by numerically exact &lt;code&gt;2&amp;pi;&lt;/code&gt;, and is therefore not exactly the same as &lt;code&gt;mod(x,2&amp;pi;)&lt;/code&gt;, which would compute the modulus of &lt;code&gt;x&lt;/code&gt; relative to division by the floating-point number &lt;code&gt;2&amp;pi;&lt;/code&gt;.</source>
          <target state="translated">この関数は、数値的に正確な &lt;code&gt;2&amp;pi;&lt;/code&gt; による除算後の係数の浮動小数点表現を計算します。したがって、浮動小数点数 &lt;code&gt;2&amp;pi;&lt;/code&gt; による除算に関連して &lt;code&gt;x&lt;/code&gt; の係数を計算する &lt;code&gt;mod(x,2&amp;pi;)&lt;/code&gt; と正確に同じではありません。</target>
        </trans-unit>
        <trans-unit id="a69b876a715ff91aee9ac1dc1a1270f07d74d257" translate="yes" xml:space="preserve">
          <source>This function definition applies only to calls where &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are both values of type &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">この関数定義は、 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; が両方とも&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;型の値である呼び出しにのみ適用されます。</target>
        </trans-unit>
        <trans-unit id="de80929c3e71c9bc153a3794af9f7a9ac61e7bc0" translate="yes" xml:space="preserve">
          <source>This function has moved to &lt;code&gt;Base&lt;/code&gt; with Julia 1.1, consider using &lt;code&gt;copy!(dst, src)&lt;/code&gt; instead. &lt;code&gt;Future.copy!&lt;/code&gt; will be deprecated in the future.</source>
          <target state="translated">この関数はJulia1.1で &lt;code&gt;Base&lt;/code&gt; に移動しました。代わりに &lt;code&gt;copy!(dst, src)&lt;/code&gt; 使用を検討してください。 &lt;code&gt;Future.copy!&lt;/code&gt; 将来的には非推奨になります。</target>
        </trans-unit>
        <trans-unit id="307f9d2672dc49a684aa7fe31c18fec869c44c7b" translate="yes" xml:space="preserve">
          <source>This function is &quot;unsafe&quot;. Be careful to ensure that a Julia reference to &lt;code&gt;array&lt;/code&gt; exists as long as this pointer will be used. The &lt;a href=&quot;../base/index#Base.GC.@preserve&quot;&gt;&lt;code&gt;GC.@preserve&lt;/code&gt;&lt;/a&gt; macro should be used to protect the &lt;code&gt;array&lt;/code&gt; argument from garbage collection within a given block of code.</source>
          <target state="translated">この機能は「安全ではありません」。このポインターが使用される限り、 &lt;code&gt;array&lt;/code&gt; へのJulia参照が存在するように注意してください。&lt;a href=&quot;../base/index#Base.GC.@preserve&quot;&gt; &lt;code&gt;GC.@preserve&lt;/code&gt; &lt;/a&gt;マクロは、保護するために使用されるべき &lt;code&gt;array&lt;/code&gt; コードの所与のブロック内のガベージコレクションから引数。</target>
        </trans-unit>
        <trans-unit id="1048e33a2e1de2e001c3991baed944e77c02b5fe" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;lazy&lt;/em&gt;; that is, it is guaranteed to return in $&amp;Theta;(1)$ time and use $&amp;Theta;(1)$ additional space, and &lt;code&gt;flt&lt;/code&gt; will not be called by an invocation of &lt;code&gt;filter&lt;/code&gt;. Calls to &lt;code&gt;flt&lt;/code&gt; will be made when iterating over the returned iterable object. These calls are not cached and repeated calls will be made when reiterating.</source>
          <target state="translated">この関数は&lt;em&gt;レイジー&lt;/em&gt;です。つまり、$&amp;Theta;（1）$時間で戻り、$&amp;Theta;（1）$の追加スペースを使用することが保証されており、 &lt;code&gt;flt&lt;/code&gt; は &lt;code&gt;filter&lt;/code&gt; の呼び出しによって呼び出されません。 &lt;code&gt;flt&lt;/code&gt; の呼び出しは、返された反復可能オブジェクトを反復するときに行われます。これらの呼び出しはキャッシュされず、繰り返すときに繰り返し呼び出しが行われます。</target>
        </trans-unit>
        <trans-unit id="df83e0cd3a021e2eda678d29363b61d1d821ffd0" translate="yes" xml:space="preserve">
          <source>This function is a backwards-compatibility wrapper around &lt;a href=&quot;#Sockets.getipaddrs&quot;&gt;&lt;code&gt;getipaddrs&lt;/code&gt;&lt;/a&gt;. New applications should use &lt;a href=&quot;#Sockets.getipaddrs&quot;&gt;&lt;code&gt;getipaddrs&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">この関数は、&lt;a href=&quot;#Sockets.getipaddrs&quot;&gt; &lt;code&gt;getipaddrs&lt;/code&gt; の&lt;/a&gt;下位互換性ラッパーです。新しいアプリケーションでは、代わりに&lt;a href=&quot;#Sockets.getipaddrs&quot;&gt; &lt;code&gt;getipaddrs&lt;/code&gt; &lt;/a&gt;を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="f3c598eb72103944814ddd5bff7557e538bb8759" translate="yes" xml:space="preserve">
          <source>This function is available as of Julia 1.2.</source>
          <target state="translated">この機能はJulia 1.2から利用可能です。</target>
        </trans-unit>
        <trans-unit id="da85261a4de72bb648f4ec6ce0ef1d4e3e0d885c" translate="yes" xml:space="preserve">
          <source>This function is available as of Julia 1.4.</source>
          <target state="translated">この機能はJulia 1.4から利用可能です。</target>
        </trans-unit>
        <trans-unit id="c744a1e60d0343bb54950e43c44ab4cd5d6e31b7" translate="yes" xml:space="preserve">
          <source>This function is available as of Julia 1.5.</source>
          <target state="translated">この機能はJulia 1.5から利用可能です。</target>
        </trans-unit>
        <trans-unit id="de757df5fb576721e27ff36bb95b8961e32a7fdd" translate="yes" xml:space="preserve">
          <source>This function is experimental in Julia 1.1 and will likely be renamed in a future release (see https://github.com/JuliaLang/julia/pull/29901).</source>
          <target state="translated">この関数は Julia 1.1 では実験的なもので、将来のリリースで名前が変更される可能性があります (https://github.com/JuliaLang/julia/pull/29901 を参照してください)。</target>
        </trans-unit>
        <trans-unit id="8f852b6c88a2b121cce224d6c4d1adc0aba50b5c" translate="yes" xml:space="preserve">
          <source>This function is exported as of Julia 1.3.</source>
          <target state="translated">この関数はJulia 1.3からエクスポートされています。</target>
        </trans-unit>
        <trans-unit id="40e1bbd78f8e3b5f7d1147a85e5728b547b5d88f" translate="yes" xml:space="preserve">
          <source>This function is labeled &quot;unsafe&quot; because it will crash if &lt;code&gt;p&lt;/code&gt; is not a valid memory address to data of the requested length.</source>
          <target state="translated">この関数は、 &lt;code&gt;p&lt;/code&gt; が要求された長さのデータに対する有効なメモリアドレスでない場合にクラッシュするため、「安全でない」とラベル付けされています。</target>
        </trans-unit>
        <trans-unit id="82038c376053156505a04a6c869bf7122237faf2" translate="yes" xml:space="preserve">
          <source>This function is labeled &quot;unsafe&quot; because it will crash if &lt;code&gt;pointer&lt;/code&gt; is not a valid memory address to data of the requested length.</source>
          <target state="translated">この関数は、 &lt;code&gt;pointer&lt;/code&gt; が要求された長さのデータへの有効なメモリアドレスでない場合にクラッシュするため、「安全でない」とラベル付けされています。</target>
        </trans-unit>
        <trans-unit id="5b892b839448ad3b615e4b9ec54defee6e074b87" translate="yes" xml:space="preserve">
          <source>This function is not thread-safe. It will affect code running on all threads, but its behavior is undefined if called concurrently with computations that use the setting.</source>
          <target state="translated">この関数はスレッドセーフではありません。すべてのスレッドで実行されているコードに影響を与えますが、設定を使用する計算と同時に呼び出された場合の動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="70c3d9d8620860cee722b6a9f452e249efef56c2" translate="yes" xml:space="preserve">
          <source>This function is part of the implementation of &lt;a href=&quot;#using&quot;&gt;&lt;code&gt;using&lt;/code&gt;&lt;/a&gt; / &lt;a href=&quot;#import&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt;, if a module is not already defined in &lt;code&gt;Main&lt;/code&gt;. It can also be called directly to force reloading a module, regardless of whether it has been loaded before (for example, when interactively developing libraries).</source>
          <target state="translated">モジュールが &lt;code&gt;Main&lt;/code&gt; でまだ定義されていない場合、この関数は/ &lt;a href=&quot;#import&quot;&gt; &lt;code&gt;import&lt;/code&gt; &lt;/a&gt;の&lt;a href=&quot;#using&quot;&gt; &lt;code&gt;using&lt;/code&gt; &lt;/a&gt;の実装の一部です。モジュールを直接呼び出して、モジュールが以前にロードされているかどうかに関係なく、強制的に再ロードすることもできます（たとえば、インタラクティブにライブラリを開発する場合など）。</target>
        </trans-unit>
        <trans-unit id="f62aceafe3cafbddb8ce3acbb1dad94e7fdf1815" translate="yes" xml:space="preserve">
          <source>This function may not be called on immutable objects, since they do not have stable memory addresses.</source>
          <target state="translated">不変オブジェクトには安定したメモリアドレスがないため、この関数を呼び出すことはできません。</target>
        </trans-unit>
        <trans-unit id="5de59bd4497cdb331716cc233726a0a8b9678b01" translate="yes" xml:space="preserve">
          <source>This function only affects the current thread.</source>
          <target state="translated">この関数は、現在のスレッドにのみ影響を与えます。</target>
        </trans-unit>
        <trans-unit id="c8d8139504e5c695799999f525f1e4ce111d803d" translate="yes" xml:space="preserve">
          <source>This function raises an error under operating systems that do not support soft symbolic links, such as Windows XP.</source>
          <target state="translated">この関数は、Windows XP などのソフトシンボリックリンクをサポートしていないオペレーティングシステムではエラーとなります。</target>
        </trans-unit>
        <trans-unit id="e2895f8ba02c0856affa3262c2ea2aa12ea82abd" translate="yes" xml:space="preserve">
          <source>This function requires Julia 1.4 or later.</source>
          <target state="translated">この機能を使用するには、Julia 1.4以降が必要です。</target>
        </trans-unit>
        <trans-unit id="f6c4fed1257bdc9c86a6438d7c81f0cba15e713a" translate="yes" xml:space="preserve">
          <source>This function requires Julia 1.5 or later.</source>
          <target state="translated">この機能を使用するには、Julia 1.5以降が必要です。</target>
        </trans-unit>
        <trans-unit id="322c609b6865dc8c717685db96eea7836880f968" translate="yes" xml:space="preserve">
          <source>This function requires at least Julia 1.1.</source>
          <target state="translated">この関数には最低でも Julia 1.1 が必要です。</target>
        </trans-unit>
        <trans-unit id="a78f5bdc6ba25c6757efa254c7a5dcb1069f02e2" translate="yes" xml:space="preserve">
          <source>This function requires at least Julia 1.1. In Julia 1.0 it is available from the standard library &lt;code&gt;InteractiveUtils&lt;/code&gt;.</source>
          <target state="translated">この機能には少なくともJulia 1.1が必要です。Julia 1.0では、標準ライブラリ &lt;code&gt;InteractiveUtils&lt;/code&gt; から利用できます。</target>
        </trans-unit>
        <trans-unit id="5a8778ddbd4ece155922c919b7d3de7c16b4b6b0" translate="yes" xml:space="preserve">
          <source>This function requires at least Julia 1.2.</source>
          <target state="translated">この関数を使用するには、Julia 1.2以上が必要です。</target>
        </trans-unit>
        <trans-unit id="1aebd8ffdb83e4dbea00c26626665df625006081" translate="yes" xml:space="preserve">
          <source>This function requires at least Julia 1.4.</source>
          <target state="translated">この関数を使用するには、Julia 1.4以上が必要です。</target>
        </trans-unit>
        <trans-unit id="2a51a88fd91e95896285adef28ef9c196b5c4360" translate="yes" xml:space="preserve">
          <source>This function requires at least Julia 1.5.</source>
          <target state="translated">この関数には最低でも Julia 1.5 が必要です。</target>
        </trans-unit>
        <trans-unit id="7b7503036b2b1d5c6cdd3e30a18b4569d18e9b3d" translate="yes" xml:space="preserve">
          <source>This function will always return an &lt;code&gt;Int8&lt;/code&gt; regardless of the types of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. See &lt;a href=&quot;../types/index#Type-Declarations&quot;&gt;Type Declarations&lt;/a&gt; for more on return types.</source>
          <target state="translated">この関数は、 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; のタイプに関係なく、常に &lt;code&gt;Int8&lt;/code&gt; を返します。戻り値の型の詳細については、&lt;a href=&quot;../types/index#Type-Declarations&quot;&gt;型宣言&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="f615a9f2e5154689d2348ca6e6e212e19365dd5e" translate="yes" xml:space="preserve">
          <source>This function will always return an &lt;code&gt;Int8&lt;/code&gt; regardless of the types of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. See &lt;a href=&quot;../types/index#Type-Declarations-1&quot;&gt;Type Declarations&lt;/a&gt; for more on return types.</source>
          <target state="translated">この関数は、 &lt;code&gt;x&lt;/code&gt; および &lt;code&gt;y&lt;/code&gt; のタイプに関係なく、常に &lt;code&gt;Int8&lt;/code&gt; を返します。戻り型の詳細については、&lt;a href=&quot;../types/index#Type-Declarations-1&quot;&gt;型宣言&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="1b364264e31d49453fa585f561786364c3d08cfe" translate="yes" xml:space="preserve">
          <source>This functionality exists to allow Julia to bootstrap the standard primitive types that LLVM supports. Once they are defined, there is very little reason to define more.</source>
          <target state="translated">この機能は、LLVMがサポートする標準的なプリミティブ型をJuliaがブートストラップできるようにするために存在します。一度定義してしまえば、それ以上定義する理由はほとんどありません。</target>
        </trans-unit>
        <trans-unit id="208d7b42f568795accbdf6593a0dabeec159feae" translate="yes" xml:space="preserve">
          <source>This functionality requires at least Julia 1.1.</source>
          <target state="translated">この機能には最低でもJulia 1.1が必要です。</target>
        </trans-unit>
        <trans-unit id="d55acd278bb097e8fd9b34b3f2891bb67508ba49" translate="yes" xml:space="preserve">
          <source>This functionality requires at least Julia 1.2.</source>
          <target state="translated">この機能には最低でも Julia 1.2 が必要です。</target>
        </trans-unit>
        <trans-unit id="d794b3922c789d2d5bf428145d7b58218609a4d8" translate="yes" xml:space="preserve">
          <source>This gives an output similar to</source>
          <target state="translated">これにより、次のような出力が得られます。</target>
        </trans-unit>
        <trans-unit id="4351de18141317da8dc4e7b0765ffdf10ccf9585" translate="yes" xml:space="preserve">
          <source>This guide provides a comprehensive overview of how to attach documentation to all Julia syntax constructs for which providing documentation is possible.</source>
          <target state="translated">このガイドでは、ドキュメントの提供が可能なすべての Julia 構文構築物にドキュメントを添付する方法の包括的な概要を説明します。</target>
        </trans-unit>
        <trans-unit id="71d340087c42aeb6323d557dfd0b48fcc9885f45" translate="yes" xml:space="preserve">
          <source>This guide relies on the Pkg REPL to execute Pkg commands. For non-interactive use, we recommend the Pkg API. The Pkg API is fully documented in the &lt;a href=&quot;https://julialang.github.io/Pkg.jl/v1/api/&quot;&gt;API Reference&lt;/a&gt; section of the Pkg documentation.</source>
          <target state="translated">このガイドは、Pkgコマンドを実行するためにPkg REPLに依存しています。非インタラクティブな使用については、Pkg APIをお勧めします。Pkg APIは、Pkgドキュメントの&lt;a href=&quot;https://julialang.github.io/Pkg.jl/v1/api/&quot;&gt;APIリファレンス&lt;/a&gt;セクションに完全に記載されています。</target>
        </trans-unit>
        <trans-unit id="bcc764f3d130244febc5241a24425d0f8955d7ca" translate="yes" xml:space="preserve">
          <source>This guide should help you get started with &lt;code&gt;Pkg&lt;/code&gt;. &lt;code&gt;Pkg&lt;/code&gt; has much more to offer in terms of powerful package management, read the full manual to learn more!</source>
          <target state="translated">このガイドは、 &lt;code&gt;Pkg&lt;/code&gt; を使い始めるのに役立つはずです。 &lt;code&gt;Pkg&lt;/code&gt; には、強力なパッケージ管理の面で提供する多くの機能があります。詳細については、完全なマニュアルを読んでください！</target>
        </trans-unit>
        <trans-unit id="2e07b6f624fccfda8f96076a48a7ed08e8beca2e" translate="yes" xml:space="preserve">
          <source>This has the exact same effect as the previous definition of &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">これは、以前の &lt;code&gt;foo&lt;/code&gt; の定義とまったく同じ効果があります。</target>
        </trans-unit>
        <trans-unit id="f2a3774592faf08d584a328465b32aaef91dad38" translate="yes" xml:space="preserve">
          <source>This illustrates the default &quot;tree&quot; dump; an alternative is the &quot;flat&quot; dump, which accumulates counts independent of their nesting:</source>
          <target state="translated">これはデフォルトの &quot;tree&quot; ダンプを示しています。別の選択肢として &quot;flat&quot; ダンプがあり、これはネスティングに依存せずにカウントを蓄積します。</target>
        </trans-unit>
        <trans-unit id="acc80a0f41503dcb1b7e460050ce274ae0e83048" translate="yes" xml:space="preserve">
          <source>This imports all the symbols from &lt;code&gt;Foo&lt;/code&gt;, but only inside the module &lt;code&gt;Bar&lt;/code&gt;.</source>
          <target state="translated">これは &lt;code&gt;Foo&lt;/code&gt; からすべてのシンボルをインポートしますが、モジュール &lt;code&gt;Bar&lt;/code&gt; 内のみです。</target>
        </trans-unit>
        <trans-unit id="a6c62d5f28832b263b7519c969320ae1bece54d1" translate="yes" xml:space="preserve">
          <source>This interface is experimental and subject to change or removal without notice.</source>
          <target state="translated">このインターフェイスは実験的なものであり、予告なく変更または削除されることがあります。</target>
        </trans-unit>
        <trans-unit id="0e598599b0d95357e3968722563ce2a0da7930f2" translate="yes" xml:space="preserve">
          <source>This interface is experimental and subject to change or removal without notice. To insulate yourself against changes, consider putting any registrations inside an &lt;code&gt;if isdefined(Base.Experimental, :register_error_hint) ... end&lt;/code&gt; block.</source>
          <target state="translated">このインターフェースは実験的なものであり、予告なしに変更または削除される場合があります。変更から身を守るために、 &lt;code&gt;if isdefined(Base.Experimental, :register_error_hint) ... end&lt;/code&gt; ブロック内に登録を配置することを検討してください。</target>
        </trans-unit>
        <trans-unit id="48c905f3e19a8500c9e8e89a5d6b2d48b63e3fd8" translate="yes" xml:space="preserve">
          <source>This interface provides a mechanism to launch and manage Julia workers on different cluster environments. There are two types of managers present in Base: &lt;code&gt;LocalManager&lt;/code&gt;, for launching additional workers on the same host, and &lt;code&gt;SSHManager&lt;/code&gt;, for launching on remote hosts via &lt;code&gt;ssh&lt;/code&gt;. TCP/IP sockets are used to connect and transport messages between processes. It is possible for Cluster Managers to provide a different transport.</source>
          <target state="translated">このインターフェースは、さまざまなクラスター環境でJuliaワーカーを起動および管理するメカニズムを提供します。：そこマネージャの2つのタイプがベースに存在する &lt;code&gt;LocalManager&lt;/code&gt; 同じホスト上に追加の労働者を起動するため、および &lt;code&gt;SSHManager&lt;/code&gt; を介してリモート・ホスト上で起動するため、 &lt;code&gt;ssh&lt;/code&gt; 。TCP / IPソケットは、プロセス間でメッセージを接続および転送するために使用されます。Cluster Managerが別のトランスポートを提供することは可能です。</target>
        </trans-unit>
        <trans-unit id="962b26b87665c4f3df59ad9f2395deca95b45d10" translate="yes" xml:space="preserve">
          <source>This is a &lt;em&gt;convention&lt;/em&gt; in the sense that &lt;code&gt;nothing&lt;/code&gt; is not a Julia keyword but a only singleton object of type &lt;code&gt;Nothing&lt;/code&gt;. Also, you may notice that the &lt;code&gt;printx&lt;/code&gt; function example above is contrived, because &lt;code&gt;println&lt;/code&gt; already returns &lt;code&gt;nothing&lt;/code&gt;, so that the &lt;code&gt;return&lt;/code&gt; line is redundant.</source>
          <target state="translated">これは、&lt;em&gt;規則&lt;/em&gt;という意味で &lt;code&gt;nothing&lt;/code&gt; ジュリアキーワードが、型の唯一のシングルトンオブジェクトではないではありません &lt;code&gt;Nothing&lt;/code&gt; 。また、 &lt;code&gt;println&lt;/code&gt; はすでに &lt;code&gt;nothing&lt;/code&gt; 返さないため、上記の &lt;code&gt;printx&lt;/code&gt; 関数の例が考案されていることに気付くかもしれません。そのため、 &lt;code&gt;return&lt;/code&gt; 行は冗長です。</target>
        </trans-unit>
        <trans-unit id="deff481ef7abfd9c149d6a30d8b9bfb2fec2b9fb" translate="yes" xml:space="preserve">
          <source>This is a Julia wrapper around a pointer to a &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_signature&quot;&gt;&lt;code&gt;git_signature&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">これは、&lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_signature&quot;&gt; &lt;code&gt;git_signature&lt;/code&gt; &lt;/a&gt;オブジェクトへのポインターを囲むJuliaラッパーです。</target>
        </trans-unit>
        <trans-unit id="c422825d888738af38d09b58685510aefce5bd8f" translate="yes" xml:space="preserve">
          <source>This is a better choice than</source>
          <target state="translated">よりもこちらの方が</target>
        </trans-unit>
        <trans-unit id="85e469ae13d4f052567eb5f96057c4c8c1633d8d" translate="yes" xml:space="preserve">
          <source>This is a classic example of a single producer feeding two concurrent consumers: one &lt;code&gt;perl&lt;/code&gt; process generates lines with the numbers 0 through 5 on them, while two parallel processes consume that output, one prefixing lines with the letter &quot;A&quot;, the other with the letter &quot;B&quot;. Which consumer gets the first line is non-deterministic, but once that race has been won, the lines are consumed alternately by one process and then the other. (Setting &lt;code&gt;$|=1&lt;/code&gt; in Perl causes each print statement to flush the &lt;a href=&quot;../../base/io-network/index#Base.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt; handle, which is necessary for this example to work. Otherwise all the output is buffered and printed to the pipe at once, to be read by just one consumer process.)</source>
          <target state="translated">これは、1つのプロデューサーが2つの同時コンシューマーにフィードする典型的な例です。1つの &lt;code&gt;perl&lt;/code&gt; プロセスが0から5までの番号の行を生成し、2つの並列プロセスがその出力を消費します。文字「B」。最初の行を取得するコンシューマーは非決定的ですが、その競争に勝った後、行は1つのプロセスと別のプロセスで交互に消費されます。 （Perlで &lt;code&gt;$|=1&lt;/code&gt; 設定すると、この例が機能するために必要な&lt;a href=&quot;../../base/io-network/index#Base.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt;ハンドルが各印刷ステートメントによってフラッシュされます。それ以外の場合は、すべての出力が一度にバッファーに入れられてパイプに出力され、1つのコンシューマープロセスだけで読み取られます。 ）</target>
        </trans-unit>
        <trans-unit id="cf79f7f6027262a30f115ab7b0f785a426cd7073" translate="yes" xml:space="preserve">
          <source>This is a common pattern seen when converting from a larger class of types to the one specific argument type that is actually supported by the algorithm:</source>
          <target state="translated">これは、より大きなクラスの型から、アルゴリズムが実際にサポートしている1つの特定の引数型に変換するときによく見られるパターンです。</target>
        </trans-unit>
        <trans-unit id="ab1f9c741287d248928e11803550091dd722085d" translate="yes" xml:space="preserve">
          <source>This is a somewhat contrived example since we could produce the same behavior more clearly by negating the condition and placing the &lt;code&gt;println&lt;/code&gt; call inside the &lt;code&gt;if&lt;/code&gt; block. In realistic usage there is more code to be evaluated after the &lt;code&gt;continue&lt;/code&gt;, and often there are multiple points from which one calls &lt;code&gt;continue&lt;/code&gt;.</source>
          <target state="translated">条件を無効にし、 &lt;code&gt;println&lt;/code&gt; 呼び出しを &lt;code&gt;if&lt;/code&gt; ブロック内に配置することで同じ動作をより明確に生成できるため、これはやや不自然な例です。現実的な使用では、 &lt;code&gt;continue&lt;/code&gt; 後に評価されるコードが多くなり、多くの場合、1つの呼び出しが &lt;code&gt;continue&lt;/code&gt; する複数のポイントがあります。</target>
        </trans-unit>
        <trans-unit id="1c9ba627d76c7cc49aeb4d6fdbc49ae25f7076ce" translate="yes" xml:space="preserve">
          <source>This is a verbose version of the &lt;code&gt;@time&lt;/code&gt; macro. It first prints the same information as &lt;code&gt;@time&lt;/code&gt;, then any non-zero memory allocation counters, and then returns the value of the expression.</source>
          <target state="translated">これは、 &lt;code&gt;@time&lt;/code&gt; マクロの詳細バージョンです。最初に &lt;code&gt;@time&lt;/code&gt; と同じ情報を出力し、次にゼロ以外のメモリ割り当てカウンターを出力してから、式の値を返します。</target>
        </trans-unit>
        <trans-unit id="3dde492bc6a0d4212d6f3ce351cddd4c3cc1560e" translate="yes" xml:space="preserve">
          <source>This is a very common pattern throughout Julia Base: a small set of required methods define an informal interface that enable many fancier behaviors. In some cases, types will want to additionally specialize those extra behaviors when they know a more efficient algorithm can be used in their specific case.</source>
          <target state="translated">これは、Julia Base 全体で非常によく見られるパターンです:必要とされる小さなメソッドのセットが非公式なインターフェイスを定義して、多くのファンシーな動作を可能にします。いくつかのケースでは、特定のケースでより効率的なアルゴリズムが使用できることがわかっている場合に、型は追加でこれらの追加の動作を特別化したいと思うでしょう。</target>
        </trans-unit>
        <trans-unit id="967704622307a1b435262f66f63c35ab2df37cdd" translate="yes" xml:space="preserve">
          <source>This is accomplished by the following definition:</source>
          <target state="translated">これは、以下の定義によって達成される。</target>
        </trans-unit>
        <trans-unit id="a064a0d086a44fbda83912ae13c4a94a63595798" translate="yes" xml:space="preserve">
          <source>This is accomplished via the following code in &lt;code&gt;base/boot.jl&lt;/code&gt;:</source>
          <target state="translated">これは、 &lt;code&gt;base/boot.jl&lt;/code&gt; の次のコードを介して行われます。</target>
        </trans-unit>
        <trans-unit id="d3583c3fe581e3e08550a563e55b3f4e249fd47f" translate="yes" xml:space="preserve">
          <source>This is also true for remotecalls on the local node as seen in the following example:</source>
          <target state="translated">これは、次の例のようにローカルノード上のリモートコールにも当てはまります。</target>
        </trans-unit>
        <trans-unit id="57f9c64c4e06a92a8accdfe0153dcfbc237317b8" translate="yes" xml:space="preserve">
          <source>This is best seen in the following example:</source>
          <target state="translated">これは次の例で最もよくわかります。</target>
        </trans-unit>
        <trans-unit id="fa42412894f46475c32ad0f5cf96db8417157008" translate="yes" xml:space="preserve">
          <source>This is better style because &lt;code&gt;foo&lt;/code&gt; does not really accept numbers of all types; it really needs &lt;code&gt;Int&lt;/code&gt; s.</source>
          <target state="translated">&lt;code&gt;foo&lt;/code&gt; は実際にはすべてのタイプの数を受け入れないため、これはより良いスタイルです。 &lt;code&gt;Int&lt;/code&gt; が本当に必要です。</target>
        </trans-unit>
        <trans-unit id="c63a317e555926f5cec6415634c44654066c6532" translate="yes" xml:space="preserve">
          <source>This is effectively a lazy version of &lt;a href=&quot;../arrays/index#Base.accumulate&quot;&gt;&lt;code&gt;Base.accumulate&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">これは事実上、&lt;a href=&quot;../arrays/index#Base.accumulate&quot;&gt; &lt;code&gt;Base.accumulate&lt;/code&gt; の&lt;/a&gt;遅延バージョンです。</target>
        </trans-unit>
        <trans-unit id="ac355916b9abde70111dfabfe3ce99e5f07ae086" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;const Vector = Array{T,1} where T&lt;/code&gt;. Writing &lt;code&gt;Vector{Float64}&lt;/code&gt; is equivalent to writing &lt;code&gt;Array{Float64,1}&lt;/code&gt;, and the umbrella type &lt;code&gt;Vector&lt;/code&gt; has as instances all &lt;code&gt;Array&lt;/code&gt; objects where the second parameter &amp;ndash; the number of array dimensions &amp;ndash; is 1, regardless of what the element type is. In languages where parametric types must always be specified in full, this is not especially helpful, but in Julia, this allows one to write just &lt;code&gt;Vector&lt;/code&gt; for the abstract type including all one-dimensional dense arrays of any element type.</source>
          <target state="translated">これは &lt;code&gt;const Vector = Array{T,1} where T&lt;/code&gt; と同等で、Tです。書き込み &lt;code&gt;Vector{Float64}&lt;/code&gt; 書き込みに相当する &lt;code&gt;Array{Float64,1}&lt;/code&gt; 、および傘型 &lt;code&gt;Vector&lt;/code&gt; インスタンスとして全て有する &lt;code&gt;Array&lt;/code&gt; オブジェクトをここで第二のパラメータ-配列の次元の数は、 -関係なく、要素のタイプが何であるか、1です。パラメトリックタイプを常に完全に指定する必要がある言語では、これは特に役に立ちませんが、Juliaでは、これにより、任意の要素タイプのすべての1次元の密配列を含む抽象タイプの &lt;code&gt;Vector&lt;/code&gt; のみを記述できます。</target>
        </trans-unit>
        <trans-unit id="aaca4a13507268ab605b72c529b012ba239f5cf8" translate="yes" xml:space="preserve">
          <source>This is equivalent to the uglier test &lt;code&gt;@test &amp;asymp;(&amp;pi;, 3.14, atol=0.01)&lt;/code&gt;. It is an error to supply more than one expression unless the first is a call expression and the rest are assignments (&lt;code&gt;k=v&lt;/code&gt;).</source>
          <target state="translated">これは、醜い検定 &lt;code&gt;@test &amp;asymp;(&amp;pi;, 3.14, atol=0.01)&lt;/code&gt; と同等です。最初の式が呼び出し式で、残りが代入（ &lt;code&gt;k=v&lt;/code&gt; ）でない限り、複数の式を指定するとエラーになります。</target>
        </trans-unit>
        <trans-unit id="075cde66f62e612ace972fa5c52ba3c9977edd64" translate="yes" xml:space="preserve">
          <source>This is fine if a named function effecting the transform already exists to pass as the first argument to &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;. Often, however, a ready-to-use, named function does not exist. In these situations, the anonymous function construct allows easy creation of a single-use function object without needing a name:</source>
          <target state="translated">これは、変換に影響を与える名前付き関数がすでに存在し、&lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; の&lt;/a&gt;最初の引数として渡される場合は問題ありません。ただし、すぐに使用できる名前付き関数が存在しないことがよくあります。これらの状況では、無名関数の構成により、名前を必要とせずに使い捨ての関数オブジェクトを簡単に作成できます。</target>
        </trans-unit>
        <trans-unit id="d2c04622602343797c4542bea9af2f8f42f131f2" translate="yes" xml:space="preserve">
          <source>This is happening because, while the &lt;code&gt;write&lt;/code&gt; call is synchronous, the writing of each argument yields to other tasks while waiting for that part of the I/O to complete.</source>
          <target state="translated">これは、 &lt;code&gt;write&lt;/code&gt; 呼び出しが同期している間、各引数の書き込みが、I / Oのその部分が完了するのを待つ間、他のタスクに譲るためです。</target>
        </trans-unit>
        <trans-unit id="c8a50eb2bf3cc3094e347236252e67c0ff90ae38" translate="yes" xml:space="preserve">
          <source>This is intended to be called using &lt;code&gt;do&lt;/code&gt; block syntax</source>
          <target state="translated">これは、 &lt;code&gt;do&lt;/code&gt; ブロック構文を使用して呼び出されることを意図しています</target>
        </trans-unit>
        <trans-unit id="9cdfa85f9233b8624988cb8413bc1b9a6dc03d9c" translate="yes" xml:space="preserve">
          <source>This is intended to be called using &lt;code&gt;do&lt;/code&gt; block syntax:</source>
          <target state="translated">これは、 &lt;code&gt;do&lt;/code&gt; ブロック構文を使用して呼び出すことを目的としています。</target>
        </trans-unit>
        <trans-unit id="dd320fe267c845b089f3801cdc399b59ed6ba172" translate="yes" xml:space="preserve">
          <source>This is likely a very expensive operation. Given that all other atomic operations in Julia already have acquire/release semantics, explicit fences should not be necessary in most cases.</source>
          <target state="translated">これは非常に高価な操作である可能性が高いです。Julia の他のすべてのアトミック操作が既に acquire/release セマンティクスを持っていることを考えると、ほとんどの場合、明示的なフェンスは必要ないはずです。</target>
        </trans-unit>
        <trans-unit id="4c368eefb6926a50691e6a9f9ec7714b2c918956" translate="yes" xml:space="preserve">
          <source>This is more readable and convenient and equivalent to the above string concatenation &amp;ndash; the system rewrites this apparent single string literal into the call &lt;code&gt;string(greet, &quot;, &quot;, whom, &quot;.\n&quot;)&lt;/code&gt;.</source>
          <target state="translated">これは、より読みやすく、便利で、上記の文字列連結と同等です。システムは、この単一の文字列リテラルを呼び出し &lt;code&gt;string(greet, &quot;, &quot;, whom, &quot;.\n&quot;)&lt;/code&gt; 書き換えます。</target>
        </trans-unit>
        <trans-unit id="f04a7b3a9c6223bad051fa21f901be067148fe9d" translate="yes" xml:space="preserve">
          <source>This is not needed on worker threads (&lt;code&gt;Threads.threadid() != 1&lt;/code&gt;) since the &lt;code&gt;InterruptException&lt;/code&gt; will only be delivered to the master thread. External functions that do not call julia code or julia runtime automatically disable sigint during their execution.</source>
          <target state="translated">&lt;code&gt;InterruptException&lt;/code&gt; はマスタースレッドにのみ配信されるため、ワーカースレッド（ &lt;code&gt;Threads.threadid() != 1&lt;/code&gt; ）では必要ありません。juliaコードまたはjuliaランタイムを呼び出さない外部関数は、実行中にsigintを自動的に無効にします。</target>
        </trans-unit>
        <trans-unit id="71e546fccd494df52bebb481be657d852aebe11b" translate="yes" xml:space="preserve">
          <source>This is often the right strategy; however, there are circumstances where following this advice blindly can be counterproductive. In particular, the more methods a generic function has, the more possibilities there are for ambiguities. When your method hierarchies get more complicated than this simple example, it can be worth your while to think carefully about alternative strategies.</source>
          <target state="translated">これは正しい戦略であることが多いのですが、やみくもにこのアドバイスに従うのは逆効果になる場合もあります。特に、一般的な関数が持つメソッドの数が多ければ多いほど、曖昧さの原因となる可能性が高くなります。メソッドの階層がこの単純な例よりも複雑になってきた場合は、別の戦略を慎重に考えてみる価値があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="e2fa8331115c72567b8859c8f4636de4982ac69c" translate="yes" xml:space="preserve">
          <source>This is only needed if your module depends on a file that is not used via &lt;a href=&quot;#Base.include&quot;&gt;&lt;code&gt;include&lt;/code&gt;&lt;/a&gt;. It has no effect outside of compilation.</source>
          <target state="translated">これは、モジュールが&lt;a href=&quot;#Base.include&quot;&gt; &lt;code&gt;include&lt;/code&gt; で&lt;/a&gt;使用されないファイルに依存している場合にのみ必要です。コンパイル以外では効果がありません。</target>
        </trans-unit>
        <trans-unit id="2784b134096220702383ae6c9d7a1302554b1771" translate="yes" xml:space="preserve">
          <source>This is the default comparison used by &lt;a href=&quot;../sort/index#Base.sort&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">これは、&lt;a href=&quot;../sort/index#Base.sort&quot;&gt; &lt;code&gt;sort&lt;/code&gt; で&lt;/a&gt;使用されるデフォルトの比較です。</target>
        </trans-unit>
        <trans-unit id="c85ba23a6506d2939aa5b839a013bcd606af833c" translate="yes" xml:space="preserve">
          <source>This is the list of reserved keywords in Julia: &lt;code&gt;baremodule&lt;/code&gt;, &lt;code&gt;begin&lt;/code&gt;, &lt;code&gt;break&lt;/code&gt;, &lt;code&gt;catch&lt;/code&gt;, &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;continue&lt;/code&gt;, &lt;code&gt;do&lt;/code&gt;, &lt;code&gt;else&lt;/code&gt;, &lt;code&gt;elseif&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;, &lt;code&gt;export&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;finally&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;function&lt;/code&gt;, &lt;code&gt;global&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;import&lt;/code&gt;, &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;local&lt;/code&gt;, &lt;code&gt;macro&lt;/code&gt;, &lt;code&gt;module&lt;/code&gt;, &lt;code&gt;quote&lt;/code&gt;, &lt;code&gt;return&lt;/code&gt;, &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;try&lt;/code&gt;, &lt;code&gt;using&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;. Those keywords are not allowed to be used as variable names.</source>
          <target state="translated">これはJuliaの予約済みキーワードのリストです： &lt;code&gt;baremodule&lt;/code&gt; 、 &lt;code&gt;begin&lt;/code&gt; 、 &lt;code&gt;break&lt;/code&gt; 、 &lt;code&gt;catch&lt;/code&gt; 、 &lt;code&gt;const&lt;/code&gt; 、 &lt;code&gt;continue&lt;/code&gt; 、 &lt;code&gt;do&lt;/code&gt; 、 &lt;code&gt;else&lt;/code&gt; 、 &lt;code&gt;elseif&lt;/code&gt; 、 &lt;code&gt;end&lt;/code&gt; 、 &lt;code&gt;export&lt;/code&gt; 、 &lt;code&gt;false&lt;/code&gt; 、 &lt;code&gt;finally&lt;/code&gt; 、 &lt;code&gt;for&lt;/code&gt; 、 &lt;code&gt;function&lt;/code&gt; 、 &lt;code&gt;global&lt;/code&gt; 、 &lt;code&gt;if&lt;/code&gt; 、 &lt;code&gt;import&lt;/code&gt; 、 &lt;code&gt;let&lt;/code&gt; 、 &lt;code&gt;local&lt;/code&gt; 、 &lt;code&gt;macro&lt;/code&gt; 、 &lt;code&gt;module&lt;/code&gt; 、 &lt;code&gt;quote&lt;/code&gt; 、 &lt;code&gt;return&lt;/code&gt; 、 &lt;code&gt;struct&lt;/code&gt; 、 &lt;code&gt;true&lt;/code&gt; 、 &lt;code&gt;try&lt;/code&gt; 、 &lt;code&gt;using&lt;/code&gt; 、 &lt;code&gt;while&lt;/code&gt; 。これらのキーワードを変数名として使用することはできません。</target>
        </trans-unit>
        <trans-unit id="96c2e84d8dd228822a97cd0751dcb6c1eebd84d2" translate="yes" xml:space="preserve">
          <source>This is the mechanism that is also used in the standard library, e.g. by the default implementation of random array generation (like in &lt;code&gt;rand(1:20, 10)&lt;/code&gt;).</source>
          <target state="translated">これは、標準ライブラリでも使用されているメカニズムです。たとえば、ランダム配列生成のデフォルトの実装（ &lt;code&gt;rand(1:20, 10)&lt;/code&gt; ）によって使用されます。</target>
        </trans-unit>
        <trans-unit id="59c8784ecdd309ab380e1280eddd527fe7e9db81" translate="yes" xml:space="preserve">
          <source>This is useful for preventing the propagation of &lt;code&gt;NaN&lt;/code&gt; values in quantities that are known to be zero. See &lt;a href=&quot;https://arxiv.org/abs/math/9205211&quot;&gt;Knuth (1992)&lt;/a&gt; for motivation.</source>
          <target state="translated">これは、ゼロであることがわかっている量の &lt;code&gt;NaN&lt;/code&gt; 値の伝播を防ぐのに役立ちます。動機については、&lt;a href=&quot;https://arxiv.org/abs/math/9205211&quot;&gt;Knuth（1992）&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="c90facb0407832d3445cbf12e098939b6ab30525" translate="yes" xml:space="preserve">
          <source>This is useful with the do-block syntax for more complex temporal expressions:</source>
          <target state="translated">これは、より複雑なテンポラリ式のためのdo-block構文を使用すると便利です。</target>
        </trans-unit>
        <trans-unit id="1f135ed365e0881687323b4b2b1b547c6be25fa8" translate="yes" xml:space="preserve">
          <source>This is wasteful when dimensions get large, so Julia provides &lt;a href=&quot;../../base/arrays/index#Base.Broadcast.broadcast&quot;&gt;&lt;code&gt;broadcast&lt;/code&gt;&lt;/a&gt;, which expands singleton dimensions in array arguments to match the corresponding dimension in the other array without using extra memory, and applies the given function elementwise:</source>
          <target state="translated">これは、次元が大きくなると無駄になり、ジュリアは&lt;a href=&quot;../../base/arrays/index#Base.Broadcast.broadcast&quot;&gt; &lt;code&gt;broadcast&lt;/code&gt; &lt;/a&gt;提供します。これは、余分なメモリを使用せずに配列引数のシングルトン次元を拡張して、他の配列の対応する次元に一致させ、特定の関数を要素ごとに適用します。</target>
        </trans-unit>
        <trans-unit id="7bd078ba5ec9612bff8795fa65ea85e0e4a4b835" translate="yes" xml:space="preserve">
          <source>This iterator is &quot;lazy&quot; in that it does not make a copy of the collection in order to reverse it; see &lt;code&gt;Base.reverse&lt;/code&gt; for an eager implementation.</source>
          <target state="translated">このイテレータは、コレクションを元に戻すためにコレクションのコピーを作成しないという点で「遅延」です。熱心な実装については、 &lt;code&gt;Base.reverse&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="668dce0079a5c7ecaeda787c6c43c4abed16e82f" translate="yes" xml:space="preserve">
          <source>This keeps things simple, while allowing the compiler to generate optimized code in all cases.</source>
          <target state="translated">これにより、コンパイラがすべてのケースで最適化されたコードを生成できるようにしながら、物事をシンプルに保つことができます。</target>
        </trans-unit>
        <trans-unit id="618a3a65c5497ca323b88a316514b70e984e986d" translate="yes" xml:space="preserve">
          <source>This kind of control flow can make it much easier to solve certain problems. In some problems, the various pieces of required work are not naturally related by function calls; there is no obvious &quot;caller&quot; or &quot;callee&quot; among the jobs that need to be done. An example is the producer-consumer problem, where one complex procedure is generating values and another complex procedure is consuming them. The consumer cannot simply call a producer function to get a value, because the producer may have more values to generate and so might not yet be ready to return. With tasks, the producer and consumer can both run as long as they need to, passing values back and forth as necessary.</source>
          <target state="translated">このような制御フローは、特定の問題をはるかに簡単に解決することができます。いくつかの問題では、必要とされる作業の様々な部分は、当然のことながら関数の呼び出しによって関連づけられていません。例えば、ある複雑なプロシージャが値を生成し、別の複雑なプロシージャが値を消費しているような、生産者と消費者の問題があります。消費者は、単にプロデューサ関数を呼び出して値を取得することはできません。タスクを使えば、プロデューサとコンシューマは必要なだけ実行し、必要に応じて値を前後に渡すことができます。</target>
        </trans-unit>
        <trans-unit id="0a88599aaef0898fffd99491510ed87461ecc31f" translate="yes" xml:space="preserve">
          <source>This kind of definition of function behavior by dispatch is quite common &amp;ndash; idiomatic, even &amp;ndash; in Julia. Method type parameters are not restricted to being used as the types of arguments: they can be used anywhere a value would be in the signature of the function or body of the function. Here's an example where the method type parameter &lt;code&gt;T&lt;/code&gt; is used as the type parameter to the parametric type &lt;code&gt;Vector{T}&lt;/code&gt; in the method signature:</source>
          <target state="translated">このようなディスパッチによる関数の動作の定義は、ジュリアではかなり一般的です。メソッド型パラメーターは、引数の型としての使用に限定されていません。関数のシグニチャーまたは関数の本体で値が使用される場所であればどこでも使用できます。メソッドの型パラメーター &lt;code&gt;T&lt;/code&gt; がメソッドシグネチャのパラメトリックタイプ &lt;code&gt;Vector{T}&lt;/code&gt; の型パラメーターとして使用される例を次に示します。</target>
        </trans-unit>
        <trans-unit id="ec4239bc4b5dc918f448b6994ffeb011eb260c23" translate="yes" xml:space="preserve">
          <source>This kind of manipulation of variables should be used judiciously, but is occasionally quite handy.</source>
          <target state="translated">このような変数の操作は慎重に使うべきですが、たまには便利なこともあります。</target>
        </trans-unit>
        <trans-unit id="5cf1880888ac71427a2a472f83ebc4e3ee3aeac7" translate="yes" xml:space="preserve">
          <source>This last point is &lt;em&gt;very&lt;/em&gt; important: even though &lt;code&gt;Float64 &amp;lt;: Real&lt;/code&gt; we &lt;strong&gt;DO NOT&lt;/strong&gt; have &lt;code&gt;Point{Float64} &amp;lt;: Point{Real}&lt;/code&gt;.</source>
          <target state="translated">この最後のポイントは&lt;em&gt;非常に&lt;/em&gt;重要です &lt;code&gt;Float64 &amp;lt;: Real&lt;/code&gt; には &lt;code&gt;Point{Float64} &amp;lt;: Point{Real}&lt;/code&gt; &lt;strong&gt;ません&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="7542405e58ae981f14134e43a96aca7f30233f49" translate="yes" xml:space="preserve">
          <source>This leverages a fallback implementation of &lt;code&gt;copyto!&lt;/code&gt; that converts the wrapper into a &lt;code&gt;Broadcasted{Nothing}&lt;/code&gt;. Consequently, specializing on &lt;code&gt;DestType&lt;/code&gt; has lower precedence than methods that specialize on &lt;code&gt;DestStyle&lt;/code&gt;.</source>
          <target state="translated">これは、 &lt;code&gt;copyto!&lt;/code&gt; のフォールバック実装を利用しています。ラッパーを &lt;code&gt;Broadcasted{Nothing}&lt;/code&gt; 変換します。したがって、上の専門 &lt;code&gt;DestType&lt;/code&gt; に特化した方法よりも低い優先順位がある &lt;code&gt;DestStyle&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="563a17c90111523e5b2f5d6e8d16952ec180646f" translate="yes" xml:space="preserve">
          <source>This loads the module &lt;code&gt;Foo&lt;/code&gt; and defines a variable &lt;code&gt;Foo&lt;/code&gt; that refers to the module, but does not import any of the other symbols from the module into the current namespace. You refer to the &lt;code&gt;Foo&lt;/code&gt; symbols by their qualified names &lt;code&gt;Foo.bar&lt;/code&gt; etc.</source>
          <target state="translated">これにより、モジュール &lt;code&gt;Foo&lt;/code&gt; が読み込まれ、モジュールを参照する変数 &lt;code&gt;Foo&lt;/code&gt; が定義されますが、モジュールから他のシンボルは現在の名前空間にインポートされません。 &lt;code&gt;Foo&lt;/code&gt; シンボルは、修飾名 &lt;code&gt;Foo.bar&lt;/code&gt; などで参照します。</target>
        </trans-unit>
        <trans-unit id="4612a42efe8a5bdd3c4138ff12dd117c4e94f8e6" translate="yes" xml:space="preserve">
          <source>This macro can be used like this:</source>
          <target state="translated">このマクロはこんな感じで使えます。</target>
        </trans-unit>
        <trans-unit id="d3a5424713c4662a407bbf558841062e07735c84" translate="yes" xml:space="preserve">
          <source>This macro gives a more convenient syntax for declaring &lt;code&gt;NamedTuple&lt;/code&gt; types. It returns a &lt;code&gt;NamedTuple&lt;/code&gt; type with the given keys and types, equivalent to &lt;code&gt;NamedTuple{(:key1, :key2, ...), Tuple{Type1,Type2,...}}&lt;/code&gt;. If the &lt;code&gt;::Type&lt;/code&gt; declaration is omitted, it is taken to be &lt;code&gt;Any&lt;/code&gt;. The &lt;code&gt;begin ... end&lt;/code&gt; form allows the declarations to be split across multiple lines (similar to a &lt;code&gt;struct&lt;/code&gt; declaration), but is otherwise equivalent.</source>
          <target state="translated">このマクロは、 &lt;code&gt;NamedTuple&lt;/code&gt; 型を宣言するためのより便利な構文を提供します。 &lt;code&gt;NamedTuple{(:key1, :key2, ...), Tuple{Type1,Type2,...}}&lt;/code&gt; と同等の、指定されたキーとタイプを持つ &lt;code&gt;NamedTuple&lt;/code&gt; タイプを返します。場合は &lt;code&gt;::Type&lt;/code&gt; 宣言が省略され、あるとみなされる &lt;code&gt;Any&lt;/code&gt; 。 &lt;code&gt;begin ... end&lt;/code&gt; フォームは、宣言が（と同様、複数の行に分割することを可能にする &lt;code&gt;struct&lt;/code&gt; 宣言）、それ以外は同等です。</target>
        </trans-unit>
        <trans-unit id="8d42881c0e50cef46bcd4335722e2d4da406ce4c" translate="yes" xml:space="preserve">
          <source>This macro is available as of Julia 1.3.</source>
          <target state="translated">このマクロはJulia 1.3から利用可能です。</target>
        </trans-unit>
        <trans-unit id="801b86f68b3c0cefd135f8c96330176952188ece" translate="yes" xml:space="preserve">
          <source>This macro is available as of Julia 1.5.</source>
          <target state="translated">このマクロはJulia 1.5から利用可能です。</target>
        </trans-unit>
        <trans-unit id="796fb2fc91375e842873f0f25490416b48076f98" translate="yes" xml:space="preserve">
          <source>This macro takes one argument: &lt;code&gt;name&lt;/code&gt;. When &lt;code&gt;@sayhello&lt;/code&gt; is encountered, the quoted expression is &lt;em&gt;expanded&lt;/em&gt; to interpolate the value of the argument into the final expression:</source>
          <target state="translated">このマクロは1つの引数を取ります： &lt;code&gt;name&lt;/code&gt; 。とき &lt;code&gt;@sayhello&lt;/code&gt; が検出され、引用された表現がされて&lt;em&gt;拡大し&lt;/em&gt;、最終的な式に引数の値を補間します：</target>
        </trans-unit>
        <trans-unit id="fb5cd3420a15fab4676b11324ac55221c551d00f" translate="yes" xml:space="preserve">
          <source>This makes it clearer where docstrings start and end.</source>
          <target state="translated">これにより、docstringsの開始と終了の位置がより明確になります。</target>
        </trans-unit>
        <trans-unit id="99355d54955b26bda6881d3a32f0394ad662278e" translate="yes" xml:space="preserve">
          <source>This makes it easy to use an arbitrary object (here a &lt;code&gt;raw&lt;/code&gt; string) as a docstring.</source>
          <target state="translated">これにより、任意のオブジェクト（ここでは &lt;code&gt;raw&lt;/code&gt; 文字列）をdocstringとして簡単に使用できます。</target>
        </trans-unit>
        <trans-unit id="e352f04f9f33e3e34fa37d2a0e22a677123c5a98" translate="yes" xml:space="preserve">
          <source>This makes it hard to write many basic integer algorithms since a lot of common techniques depend on the fact that machine addition with overflow &lt;em&gt;is&lt;/em&gt; associative. Consider finding the midpoint between integer values &lt;code&gt;lo&lt;/code&gt; and &lt;code&gt;hi&lt;/code&gt; in Julia using the expression &lt;code&gt;(lo + hi) &amp;gt;&amp;gt;&amp;gt; 1&lt;/code&gt;:</source>
          <target state="translated">多くの一般的な手法は、オーバーフロー&lt;em&gt;を&lt;/em&gt;伴うマシンの加算&lt;em&gt;が&lt;/em&gt;結合的であるという事実に依存しているため、これは多くの基本的な整数アルゴリズムを書くことを難しくします。式 &lt;code&gt;(lo + hi) &amp;gt;&amp;gt;&amp;gt; 1&lt;/code&gt; を使用して、ジュリアの整数値 &lt;code&gt;lo&lt;/code&gt; と &lt;code&gt;hi&lt;/code&gt; の間の中点を見つけることを検討してください。</target>
        </trans-unit>
        <trans-unit id="bddf7a0f25a0e5f4299199009d8763508187037e" translate="yes" xml:space="preserve">
          <source>This makes it more clear where docstrings start and end.</source>
          <target state="translated">これにより、docstringsの開始と終了がより明確になります。</target>
        </trans-unit>
        <trans-unit id="f1fb07e562617380cc2e285350641983b6f7d13d" translate="yes" xml:space="preserve">
          <source>This makes it possible to use expressions other than normal string literals (such as the &lt;code&gt;raw&quot;&quot;&lt;/code&gt; string macro) as a docstring.</source>
          <target state="translated">これにより、通常の文字列リテラル以外の式（ &lt;code&gt;raw&quot;&quot;&lt;/code&gt; 文字列マクロなど）をdocstringとして使用できるようになります。</target>
        </trans-unit>
        <trans-unit id="1390ee7b9f8d0f8dd34a701e5fbadb4b8b3c9256" translate="yes" xml:space="preserve">
          <source>This makes stack trace information available programmatically for logging, error handling, and more.</source>
          <target state="translated">これにより、スタックトレース情報がロギングやエラー処理などのためにプログラムで利用できるようになります。</target>
        </trans-unit>
        <trans-unit id="118a450839bcd493b9a3323bf1931949bac102ac" translate="yes" xml:space="preserve">
          <source>This manifest file describes a possible complete dependency graph for the &lt;code&gt;App&lt;/code&gt; project:</source>
          <target state="translated">このマニフェストファイルは、 &lt;code&gt;App&lt;/code&gt; プロジェクトの考えられる完全な依存関係グラフを記述しています。</target>
        </trans-unit>
        <trans-unit id="fa9bdb6f39c12cde4099183225c25db089937837" translate="yes" xml:space="preserve">
          <source>This may sound like a strange restriction, but remember that since C is not a dynamic language like Julia, its functions can only accept argument types with a statically-known, fixed signature.</source>
          <target state="translated">これは奇妙な制限のように聞こえるかもしれませんが、C言語はJuliaのような動的言語ではないので、その関数は静的に知られた固定シグネチャを持つ引数型しか受け付けることができないことを覚えておいてください。</target>
        </trans-unit>
        <trans-unit id="ccbe0f854d08689742c5122439446d8ae7400b8b" translate="yes" xml:space="preserve">
          <source>This means that calling &lt;code&gt;f()&lt;/code&gt; is equivalent to calling &lt;code&gt;f(1,2)&lt;/code&gt;. In this case the result is &lt;code&gt;5&lt;/code&gt;, because &lt;code&gt;f(1,2)&lt;/code&gt; invokes the first method of &lt;code&gt;f&lt;/code&gt; above. However, this need not always be the case. If you define a fourth method that is more specialized for integers:</source>
          <target state="translated">つまり、 &lt;code&gt;f()&lt;/code&gt; の呼び出しは &lt;code&gt;f(1,2)&lt;/code&gt; の呼び出しと同等です。この場合、 &lt;code&gt;f(1,2)&lt;/code&gt; は上記の &lt;code&gt;f&lt;/code&gt; の最初のメソッドを呼び出すため、結果は &lt;code&gt;5&lt;/code&gt; になります。ただし、常にそうである必要はありません。整数に特化した4番目のメソッドを定義する場合：</target>
        </trans-unit>
        <trans-unit id="d91824530ea1dcad07d2ce3b7c87745b23855a91" translate="yes" xml:space="preserve">
          <source>This means that new &lt;code&gt;Number&lt;/code&gt; types only need to define constructors, since this definition will handle &lt;code&gt;convert&lt;/code&gt; for them. An identity conversion is also provided to handle the case where the argument is already of the requested type:</source>
          <target state="translated">つまり、この定義はコンストラクターの &lt;code&gt;convert&lt;/code&gt; を処理するため、新しい &lt;code&gt;Number&lt;/code&gt; 型はコンストラクターを定義するだけで済みます。引数がすでに要求されたタイプである場合を処理するために、ID変換も提供されています。</target>
        </trans-unit>
        <trans-unit id="d95d868bc45acbbf3d653adf2e5564fd580718ec" translate="yes" xml:space="preserve">
          <source>This means that rounding a &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; to an even multiple of seconds, minutes, hours, or years (because the ISO 8601 specification includes a year zero) will result in a &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; with an even value in that field, while rounding a &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; to an even multiple of months will result in the months field having an odd value. Because both months and years may contain an irregular number of days, whether rounding to an even number of days will result in an even value in the days field is uncertain.</source>
          <target state="translated">つまり、&lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;を秒、分、時間、または年の偶数倍に丸めると（ISO 8601仕様にはゼロ年が含まれるため）、&lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;はそのフィールドに偶数の値を持ち、&lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;は偶数に丸められます。月が複数ある場合、月フィールドの値は奇数になります。月と年の両方に不規則な日数が含まれる可能性があるため、日数を偶数に丸めると日フィールドの値が偶数になるかどうかは不確かです。</target>
        </trans-unit>
        <trans-unit id="e022c0c027f7431615a2e6bfce810bd80d7f71b8" translate="yes" xml:space="preserve">
          <source>This means that the &lt;code&gt;pointer&lt;/code&gt; for &lt;code&gt;V&lt;/code&gt; is actually pointing into the middle of &lt;code&gt;A&lt;/code&gt;'s memory block, and it refers to elements both backwards and forwards in memory. See the &lt;a href=&quot;../interfaces/index#man-interface-strided-arrays&quot;&gt;interface guide for strided arrays&lt;/a&gt; for more details on defining your own strided arrays. &lt;a href=&quot;../../base/arrays/index#Base.StridedVector&quot;&gt;&lt;code&gt;StridedVector&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/arrays/index#Base.StridedMatrix&quot;&gt;&lt;code&gt;StridedMatrix&lt;/code&gt;&lt;/a&gt; are convenient aliases for many of the builtin array types that are considered strided arrays, allowing them to dispatch to select specialized implementations that call highly tuned and optimized BLAS and LAPACK functions using just the pointer and strides.</source>
          <target state="translated">ことをこれは意味 &lt;code&gt;pointer&lt;/code&gt; 用 &lt;code&gt;V&lt;/code&gt; は実際の中央に向いている &lt;code&gt;A&lt;/code&gt; さんのメモリブロック、及び、メモリの両方前後の要素を指します。参照してください&lt;a href=&quot;../interfaces/index#man-interface-strided-arrays&quot;&gt;ストライドアレイ用インターフェースガイド&lt;/a&gt;あなた自身のストライドの配列の定義の詳細については、を。&lt;a href=&quot;../../base/arrays/index#Base.StridedVector&quot;&gt; &lt;code&gt;StridedVector&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../../base/arrays/index#Base.StridedMatrix&quot;&gt; &lt;code&gt;StridedMatrix&lt;/code&gt; &lt;/a&gt;は、ストライド配列と見なされる多くの組み込み配列タイプの便利なエイリアスであり、ポインターとストライドだけを使用して、高度に調整および最適化されたBLASおよびLAPACK関数を呼び出す特殊な実装を選択するためにディスパッチできます。</target>
        </trans-unit>
        <trans-unit id="0b1724fb3df29f491e1db30646921be60d52e085" translate="yes" xml:space="preserve">
          <source>This means we must also define a corresponding &lt;code&gt;similar&lt;/code&gt; method:</source>
          <target state="translated">つまり、対応する &lt;code&gt;similar&lt;/code&gt; メソッドも定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="8164014a03b0ed9d2a2a01cfd412eb70f3f6cf4e" translate="yes" xml:space="preserve">
          <source>This mechanism can be implemented easily by custom exception types following the way &lt;a href=&quot;../../base/base/index#Core.UndefVarError&quot;&gt;&lt;code&gt;UndefVarError&lt;/code&gt;&lt;/a&gt; is written:</source>
          <target state="translated">このメカニズムは、&lt;a href=&quot;../../base/base/index#Core.UndefVarError&quot;&gt; &lt;code&gt;UndefVarError&lt;/code&gt; の&lt;/a&gt;記述方法に従って、カスタム例外タイプによって簡単に実装できます。</target>
        </trans-unit>
        <trans-unit id="00b20545036f8cfdf164022ed01300b951b2a39d" translate="yes" xml:space="preserve">
          <source>This mechanism is also the key to how type constructors and closures (inner functions that refer to their surrounding environment) work in Julia.</source>
          <target state="translated">このメカニズムは、型のコンストラクタやクロージャ(周囲の環境を参照する内部関数)がJuliaでどのように動作するかの鍵でもあります。</target>
        </trans-unit>
        <trans-unit id="87a9a57282476dafb9bfcdbc06caa5e75c2590eb" translate="yes" xml:space="preserve">
          <source>This mechanism is of course used by the default implementation of random array generation (like in &lt;code&gt;rand(1:20, 10)&lt;/code&gt;). In order to implement this decoupling for a custom type, a helper type can be used. Going back to our &lt;code&gt;Die&lt;/code&gt; example: &lt;code&gt;rand(::Die)&lt;/code&gt; uses random generation from a range, so there is an opportunity for this optimization:</source>
          <target state="translated">このメカニズムはもちろん、ランダム配列生成のデフォルト実装で使用されます（ &lt;code&gt;rand(1:20, 10)&lt;/code&gt; ）。カスタムタイプにこの分離を実装するには、ヘルパータイプを使用できます。 &lt;code&gt;Die&lt;/code&gt; の例に戻ると、 &lt;code&gt;rand(::Die)&lt;/code&gt; は範囲からのランダム生成を使用しているため、この最適化の機会があります。</target>
        </trans-unit>
        <trans-unit id="f75a278538a1522abc6fa98d70bcb27983fcccb3" translate="yes" xml:space="preserve">
          <source>This method creates a &lt;code&gt;DateFormat&lt;/code&gt; object each time it is called. If you are parsing many date strings of the same format, consider creating a &lt;a href=&quot;#Dates.DateFormat&quot;&gt;&lt;code&gt;DateFormat&lt;/code&gt;&lt;/a&gt; object once and using that as the second argument instead.</source>
          <target state="translated">このメソッドは、呼び出されるたびに &lt;code&gt;DateFormat&lt;/code&gt; オブジェクトを作成します。同じ形式の多くの日付文字列を解析する場合は、&lt;a href=&quot;#Dates.DateFormat&quot;&gt; &lt;code&gt;DateFormat&lt;/code&gt; &lt;/a&gt;オブジェクトを一度作成し、それを2番目の引数として使用することを検討してください。</target>
        </trans-unit>
        <trans-unit id="9d972e8cda3b91e650e6ff3541ce6f8b54cbae93" translate="yes" xml:space="preserve">
          <source>This method creates a &lt;code&gt;DateFormat&lt;/code&gt; object each time it is called. If you are parsing many date time strings of the same format, consider creating a &lt;a href=&quot;#Dates.DateFormat&quot;&gt;&lt;code&gt;DateFormat&lt;/code&gt;&lt;/a&gt; object once and using that as the second argument instead.</source>
          <target state="translated">このメソッドは、呼び出されるたびに &lt;code&gt;DateFormat&lt;/code&gt; オブジェクトを作成します。同じ形式の多数の日時文字列を解析する場合は、&lt;a href=&quot;#Dates.DateFormat&quot;&gt; &lt;code&gt;DateFormat&lt;/code&gt; &lt;/a&gt;オブジェクトを一度作成し、それを2番目の引数として使用することを検討してください。</target>
        </trans-unit>
        <trans-unit id="cb2233a83e18eafded9574a3a241275b67521981" translate="yes" xml:space="preserve">
          <source>This method definition applies to any pair of arguments that are instances of &lt;a href=&quot;../../base/numbers/index#Core.Number&quot;&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/a&gt;. They need not be of the same type, so long as they are each numeric values. The problem of handling disparate numeric types is delegated to the arithmetic operations in the expression &lt;code&gt;2x - y&lt;/code&gt;.</source>
          <target state="translated">このメソッド定義は、&lt;a href=&quot;../../base/numbers/index#Core.Number&quot;&gt; &lt;code&gt;Number&lt;/code&gt; の&lt;/a&gt;インスタンスである引数のペアに適用されます。それらがそれぞれ数値である限り、それらは同じタイプである必要はありません。異なる数値型の処理の問題は、式 &lt;code&gt;2x - y&lt;/code&gt; 算術演算に委任されています。</target>
        </trans-unit>
        <trans-unit id="25be108587097965bc1d457d2798dc697b2b0387" translate="yes" xml:space="preserve">
          <source>This method is available as of Julia 1.1.</source>
          <target state="translated">この方法はJulia 1.1から利用可能です。</target>
        </trans-unit>
        <trans-unit id="7154e71f550aec85c7b6230d9f61b37f4a29ed8a" translate="yes" xml:space="preserve">
          <source>This method requires Julia 1.2 or later.</source>
          <target state="translated">この方法では、Julia 1.2以降が必要です。</target>
        </trans-unit>
        <trans-unit id="899440f2ea2fee6c702b6f89d814399868b760bc" translate="yes" xml:space="preserve">
          <source>This method requires at least Julia 1.1.</source>
          <target state="translated">この方法には少なくともJulia 1.1が必要です。</target>
        </trans-unit>
        <trans-unit id="870b2fd7cad296236db6b2acee5daac8bcbed1f1" translate="yes" xml:space="preserve">
          <source>This method requires at least Julia 1.2.</source>
          <target state="translated">このメソッドには少なくともJulia 1.2が必要です。</target>
        </trans-unit>
        <trans-unit id="a7dd277ce3d58fa80c3ba1f6a270f1433aab79aa" translate="yes" xml:space="preserve">
          <source>This method requires at least Julia 1.3.</source>
          <target state="translated">このメソッドには少なくともJulia 1.3が必要です。</target>
        </trans-unit>
        <trans-unit id="287181424f41545827889fe6d1cd971c13deceb7" translate="yes" xml:space="preserve">
          <source>This method requires at least Julia 1.4.</source>
          <target state="translated">このメソッドには少なくともJulia 1.4が必要です。</target>
        </trans-unit>
        <trans-unit id="df192a99d234108a172dc69e2511778133fdb5c8" translate="yes" xml:space="preserve">
          <source>This method uses the &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt; function to explicitly convert &lt;code&gt;x&lt;/code&gt; to &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; and then delegates construction to the general constructor for the case where both arguments are &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;. With this method definition what was previously a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt; now successfully creates a point of type &lt;code&gt;Point{Float64}&lt;/code&gt;:</source>
          <target state="translated">このメソッドは、&lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt;関数を使用して &lt;code&gt;x&lt;/code&gt; を明示的に&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;に変換し、両方の引数が&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;である場合に備えて、構築を汎用コンストラクターに委任します。このメソッド定義を使用して、以前は&lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; で&lt;/a&gt;あったものが、 &lt;code&gt;Point{Float64}&lt;/code&gt; 型のポイントを正常に作成します。</target>
        </trans-unit>
        <trans-unit id="f6303e3b58af767dd0d1fbddaa5592d4577466dc" translate="yes" xml:space="preserve">
          <source>This might be worthwhile when either of the following are true:</source>
          <target state="translated">これは、以下のどちらかが当てはまる場合には、価値があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="caca6d3dad29a6885489c96c973507436880d558" translate="yes" xml:space="preserve">
          <source>This module defines a type &lt;code&gt;MyType&lt;/code&gt;, and two functions. Function &lt;code&gt;foo&lt;/code&gt; and type &lt;code&gt;MyType&lt;/code&gt; are exported, and so will be available for importing into other modules. Function &lt;code&gt;bar&lt;/code&gt; is private to &lt;code&gt;MyModule&lt;/code&gt;.</source>
          <target state="translated">このモジュールは、タイプ &lt;code&gt;MyType&lt;/code&gt; と2つの関数を定義します。関数 &lt;code&gt;foo&lt;/code&gt; およびタイプ &lt;code&gt;MyType&lt;/code&gt; がエクスポートされるため、他のモジュールへのインポートに使用できます。関数 &lt;code&gt;bar&lt;/code&gt; は &lt;code&gt;MyModule&lt;/code&gt; 専用です。</target>
        </trans-unit>
        <trans-unit id="e361081ac903885d30799d0af09374c26253366e" translate="yes" xml:space="preserve">
          <source>This new compact representation will be used when the passed IO stream is an &lt;code&gt;IOContext&lt;/code&gt; object with the &lt;code&gt;:compact&lt;/code&gt; property set. In particular, this is the case when printing arrays with multiple columns (where horizontal space is limited):</source>
          <target state="translated">この新しいコンパクト表現は、渡されたIOストリームが &lt;code&gt;:compact&lt;/code&gt; プロパティが設定された &lt;code&gt;IOContext&lt;/code&gt; オブジェクトである場合に使用されます。特に、これは複数の列（水平方向のスペースが限られている）の配列を印刷する場合に当てはまります。</target>
        </trans-unit>
        <trans-unit id="c9d9b11cb845e47e607c614fa51676b8589b0e20" translate="yes" xml:space="preserve">
          <source>This normalized form for a ratio of integers is unique, so equality of rational values can be tested by checking for equality of the numerator and denominator. The standardized numerator and denominator of a rational value can be extracted using the &lt;a href=&quot;../../base/math/index#Base.numerator&quot;&gt;&lt;code&gt;numerator&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/math/index#Base.denominator&quot;&gt;&lt;code&gt;denominator&lt;/code&gt;&lt;/a&gt; functions:</source>
          <target state="translated">整数の比率のこの正規化された形式は一意であるため、分子と分母が等しいかどうかをチェックすることにより、有理値の等しいかどうかをテストできます。有理値の標準化された分子と分母は、&lt;a href=&quot;../../base/math/index#Base.numerator&quot;&gt; &lt;code&gt;numerator&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../../base/math/index#Base.denominator&quot;&gt; &lt;code&gt;denominator&lt;/code&gt; &lt;/a&gt;関数を使用して抽出できます。</target>
        </trans-unit>
        <trans-unit id="6ae131da59b641e6a04de571be058c6c357d2762" translate="yes" xml:space="preserve">
          <source>This object is NOT thread-safe. See &lt;a href=&quot;#Base.Threads.Condition&quot;&gt;&lt;code&gt;Threads.Condition&lt;/code&gt;&lt;/a&gt; for a thread-safe version.</source>
          <target state="translated">このオブジェクトはスレッドセーフではありません。スレッドセーフバージョンについては、&lt;a href=&quot;#Base.Threads.Condition&quot;&gt; &lt;code&gt;Threads.Condition&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="dd76756319b3c7370a847bd7b93c70cdd9b67ec0" translate="yes" xml:space="preserve">
          <source>This object is NOT thread-safe. See &lt;a href=&quot;../multi-threading/index#Base.Threads.Condition&quot;&gt;&lt;code&gt;Threads.Condition&lt;/code&gt;&lt;/a&gt; for a thread-safe version.</source>
          <target state="translated">このオブジェクトはスレッドセーフではありません。スレッドセーフバージョンについては、&lt;a href=&quot;../multi-threading/index#Base.Threads.Condition&quot;&gt; &lt;code&gt;Threads.Condition&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="7e4a7f18d5f3325b0b4b506c0553650e84bb55e2" translate="yes" xml:space="preserve">
          <source>This operation is intended for linear algebra usage - for general data manipulation see &lt;a href=&quot;../../base/arrays/index#Base.permutedims&quot;&gt;&lt;code&gt;permutedims&lt;/code&gt;&lt;/a&gt;, which is non-recursive.</source>
          <target state="translated">この操作は、線形代数の使用を目的としています。一般的なデータ操作については、非再帰的な&lt;a href=&quot;../../base/arrays/index#Base.permutedims&quot;&gt; &lt;code&gt;permutedims&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="68fb902f0905ca9a9a84e0916a21520831fc7805" translate="yes" xml:space="preserve">
          <source>This operation is intended for linear algebra usage - for general data manipulation see &lt;a href=&quot;../../base/arrays/index#Base.permutedims&quot;&gt;&lt;code&gt;permutedims&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この操作は、線形代数の使用を目的としています。一般的なデータ操作については、&lt;a href=&quot;../../base/arrays/index#Base.permutedims&quot;&gt; &lt;code&gt;permutedims&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="5890e27550178f3b3f621b391f08592d04b935ac" translate="yes" xml:space="preserve">
          <source>This operator follows IEEE semantics for floating-point numbers: &lt;code&gt;0.0 == -0.0&lt;/code&gt; and &lt;code&gt;NaN != NaN&lt;/code&gt;.</source>
          <target state="translated">この演算子は、浮動小数点数のIEEEセマンティクスに従います： &lt;code&gt;0.0 == -0.0&lt;/code&gt; および &lt;code&gt;NaN != NaN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f45001a85e32a4368ea2b2117472a674fb4b812d" translate="yes" xml:space="preserve">
          <source>This output tells us that &lt;code&gt;f&lt;/code&gt; is a function object with two methods. To find out what the signatures of those methods are, use the &lt;a href=&quot;../../base/base/index#Base.methods&quot;&gt;&lt;code&gt;methods&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">この出力は、 &lt;code&gt;f&lt;/code&gt; が2つのメソッドを持つ関数オブジェクトであることを示しています。これらのメソッドのシグネチャが何であるかを確認するには、&lt;a href=&quot;../../base/base/index#Base.methods&quot;&gt; &lt;code&gt;methods&lt;/code&gt; &lt;/a&gt;関数を使用します。</target>
        </trans-unit>
        <trans-unit id="27399a34acfc119b2b6802fe2da7d02ba2868aed" translate="yes" xml:space="preserve">
          <source>This pattern is implemented by defining a generic function which computes a different singleton value (or type) for each trait-set to which the function arguments may belong to. If this function is pure there is no impact on performance compared to normal dispatch.</source>
          <target state="translated">このパターンは、関数の引数が属する可能性のある形質集合ごとに異なるシングルトン値(または型)を計算する汎用関数を定義することで実装されます。この関数が純粋なものであれば、通常のディスパッチと比較してパフォーマンスに影響はありません。</target>
        </trans-unit>
        <trans-unit id="c8dd670a38453a8c5ac96a2263bb252ef6b9b2f1" translate="yes" xml:space="preserve">
          <source>This pattern is so frequent that a helper type named &lt;code&gt;Random.SamplerSimple&lt;/code&gt; is available, saving us the definition of &lt;code&gt;SamplerDie&lt;/code&gt;: we could have implemented our decoupling with:</source>
          <target state="translated">このパターンは頻繁に使用されるため、 &lt;code&gt;Random.SamplerSimple&lt;/code&gt; という名前のヘルパータイプを使用できるので、 &lt;code&gt;SamplerDie&lt;/code&gt; の定義を節約できます。</target>
        </trans-unit>
        <trans-unit id="788eade9955684aef54020e83665092b3b21d4bd" translate="yes" xml:space="preserve">
          <source>This pattern is used in several places in Julia Base. For example, see &lt;code&gt;vcat&lt;/code&gt; and &lt;code&gt;hcat&lt;/code&gt; in &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/40fe264f4ffaa29b749bcf42239a89abdcbba846/base/abstractarray.jl#L1205-L1206&quot;&gt;&lt;code&gt;abstractarray.jl&lt;/code&gt;&lt;/a&gt;, or the &lt;a href=&quot;../../base/arrays/index#Base.fill!&quot;&gt;&lt;code&gt;fill!&lt;/code&gt;&lt;/a&gt; function, which we could have used instead of writing our own &lt;code&gt;fill_twos!&lt;/code&gt;.</source>
          <target state="translated">このパターンは、ジュリアベースのいくつかの場所で使用されています。たとえば、&lt;a href=&quot;https://github.com/JuliaLang/julia/blob/40fe264f4ffaa29b749bcf42239a89abdcbba846/base/abstractarray.jl#L1205-L1206&quot;&gt; &lt;code&gt;abstractarray.jl&lt;/code&gt; の&lt;/a&gt; &lt;code&gt;vcat&lt;/code&gt; および &lt;code&gt;hcat&lt;/code&gt; 、または&lt;a href=&quot;../../base/arrays/index#Base.fill!&quot;&gt; &lt;code&gt;fill!&lt;/code&gt; を&lt;/a&gt;参照してください。関数、独自の &lt;code&gt;fill_twos!&lt;/code&gt; 代わりに使用できます！。</target>
        </trans-unit>
        <trans-unit id="a07692e105ddc917557be8ec34d26c6d0d0ad87f" translate="yes" xml:space="preserve">
          <source>This pipes the output of the &lt;code&gt;echo&lt;/code&gt; command to the &lt;code&gt;sort&lt;/code&gt; command. Of course, this isn't terribly interesting since there's only one line to sort, but we can certainly do much more interesting things:</source>
          <target state="translated">これは、 &lt;code&gt;echo&lt;/code&gt; コマンドの出力を &lt;code&gt;sort&lt;/code&gt; コマンドにパイプします。もちろん、並べ替える行が1行しかないので、これはそれほど興味深いことではありませんが、もっと興味深いことを実行できます。</target>
        </trans-unit>
        <trans-unit id="28745bdf70806fa587f3e325d2378a4dbc6461d5" translate="yes" xml:space="preserve">
          <source>This prints the highest five user IDs on a UNIX system. The &lt;code&gt;cut&lt;/code&gt;, &lt;code&gt;sort&lt;/code&gt; and &lt;code&gt;tail&lt;/code&gt; commands are all spawned as immediate children of the current &lt;code&gt;julia&lt;/code&gt; process, with no intervening shell process. Julia itself does the work to setup pipes and connect file descriptors that is normally done by the shell. Since Julia does this itself, it retains better control and can do some things that shells cannot.</source>
          <target state="translated">これにより、UNIXシステムで上位5つのユーザーIDが出力されます。 &lt;code&gt;cut&lt;/code&gt; 、 &lt;code&gt;sort&lt;/code&gt; や &lt;code&gt;tail&lt;/code&gt; のコマンドは、現在のすべての直接の子として生まれたされている &lt;code&gt;julia&lt;/code&gt; 介在しないシェルプロセスで、プロセス。Julia自体がパイプをセットアップし、通常シェルによって行われるファイル記述子を接続する作業を行います。ジュリア自身がこれを行うので、より良い制御を保持し、シェルができないいくつかのことを行うことができます。</target>
        </trans-unit>
        <trans-unit id="23fa7f062adc867f3f830f4783d112980678deb3" translate="yes" xml:space="preserve">
          <source>This project file implies the following roots map, if it was represented by a Julia dictionary:</source>
          <target state="translated">このプロジェクトファイルは、Julia辞書で表現されている場合、以下のようなルーツマップを意味しています。</target>
        </trans-unit>
        <trans-unit id="abc51e24a31d52999d77393c1e2d796880b68886" translate="yes" xml:space="preserve">
          <source>This quantity is also known in the literature as the Bauer condition number, relative condition number, or componentwise relative condition number.</source>
          <target state="translated">この量は、文献ではバウアー条件数、相対条件数、または成分的相対条件数としても知られています。</target>
        </trans-unit>
        <trans-unit id="2e42070fb796891f9806f28a3d77516fa4beb07e" translate="yes" xml:space="preserve">
          <source>This regex has the first three flags enabled.</source>
          <target state="translated">この正規表現では、最初の3つのフラグが有効になっています。</target>
        </trans-unit>
        <trans-unit id="ee3fcabcdbbc8234e7f06a55081b08ead3e3a1c5" translate="yes" xml:space="preserve">
          <source>This relationship is also invariant:</source>
          <target state="translated">この関係も不変です。</target>
        </trans-unit>
        <trans-unit id="59fcc1007eeaedfc2adf51cf837dd399f227cb88" translate="yes" xml:space="preserve">
          <source>This returns a &lt;code&gt;5&amp;times;5 Bidiagonal{Float64}&lt;/code&gt;, which can now be passed to other linear algebra functions (e.g. eigensolvers) which will use specialized methods for &lt;code&gt;Bidiagonal&lt;/code&gt; types.</source>
          <target state="translated">これは &lt;code&gt;5&amp;times;5 Bidiagonal{Float64}&lt;/code&gt; 返します。これは、 &lt;code&gt;Bidiagonal&lt;/code&gt; 型に特化したメソッドを使用する他の線形代数関数（たとえば、固有ソルバー）に渡すことができます。</target>
        </trans-unit>
        <trans-unit id="51739dfebbc5e267c6346f6dae65d7a77c8eb77b" translate="yes" xml:space="preserve">
          <source>This section describes Julia's markdown syntax, which is enabled by the Markdown standard library. The following Markdown elements are supported:</source>
          <target state="translated">このセクションでは、Markdown標準ライブラリによって有効になっているJuliaのMarkdown構文について説明します。以下のMarkdown要素がサポートされています。</target>
        </trans-unit>
        <trans-unit id="dfa63ea10e93a9723f06f6e4891ca5c36280959e" translate="yes" xml:space="preserve">
          <source>This seems obvious, because two of each of these periods still divides evenly into the next larger order period. But in the case of two months (which still divides evenly into one year), the answer may be surprising:</source>
          <target state="translated">これは明らかなようで、それぞれの期間のうちの2つはまだ次のより大きな次数の期間に均等に分割されているからです。しかし、2ヶ月(それでも1年に均等に分割されている)の場合は、意外な答えが出てくるかもしれません。</target>
        </trans-unit>
        <trans-unit id="a3589971fa43934068938b8a676f4699efd4cc5b" translate="yes" xml:space="preserve">
          <source>This sets the &lt;a href=&quot;http://llvm.org/docs/LangRef.html#fast-math-flags&quot;&gt;LLVM Fast-Math flags&lt;/a&gt;, and corresponds to the &lt;code&gt;-ffast-math&lt;/code&gt; option in clang. See &lt;a href=&quot;../../manual/performance-tips/index#man-performance-annotations&quot;&gt;the notes on performance annotations&lt;/a&gt; for more details.</source>
          <target state="translated">これは &lt;code&gt;-ffast-math&lt;/code&gt; &lt;a href=&quot;http://llvm.org/docs/LangRef.html#fast-math-flags&quot;&gt;Mathフラグを&lt;/a&gt;設定し、clangの-ffast-mathオプションに対応します。詳細について&lt;a href=&quot;../../manual/performance-tips/index#man-performance-annotations&quot;&gt;は、パフォーマンスアノテーション&lt;/a&gt;に関する注記を参照してください。</target>
        </trans-unit>
        <trans-unit id="90f8183fe3e114c60192daf58de9ecad787e8334" translate="yes" xml:space="preserve">
          <source>This sets the &lt;a href=&quot;http://llvm.org/docs/LangRef.html#fast-math-flags&quot;&gt;LLVM Fast-Math flags&lt;/a&gt;, and corresponds to the &lt;code&gt;-ffast-math&lt;/code&gt; option in clang. See &lt;a href=&quot;../../manual/performance-tips/index#man-performance-annotations-1&quot;&gt;the notes on performance annotations&lt;/a&gt; for more details.</source>
          <target state="translated">これは&lt;a href=&quot;http://llvm.org/docs/LangRef.html#fast-math-flags&quot;&gt;LLVM Fast-Mathフラグを&lt;/a&gt;設定し、clangの &lt;code&gt;-ffast-math&lt;/code&gt; オプションに対応します。詳細について&lt;a href=&quot;../../manual/performance-tips/index#man-performance-annotations-1&quot;&gt;は、パフォーマンスアノテーション&lt;/a&gt;に関する注意をご覧ください。</target>
        </trans-unit>
        <trans-unit id="3f1e8b5b57b03661a32579fb9fe3d14174f160bb" translate="yes" xml:space="preserve">
          <source>This setting will cause &lt;code&gt;eachindex&lt;/code&gt; iteration over a &lt;code&gt;MyArray&lt;/code&gt; to use integers. If you don't specify this trait, the default value &lt;code&gt;IndexCartesian()&lt;/code&gt; is used.</source>
          <target state="translated">この設定は、原因となります &lt;code&gt;eachindex&lt;/code&gt; にわたり反復を &lt;code&gt;MyArray&lt;/code&gt; という使用整数へ。この特性を指定しない場合、デフォルト値 &lt;code&gt;IndexCartesian()&lt;/code&gt; が使用されます。</target>
        </trans-unit>
        <trans-unit id="dd212ee97174c1074845d2f071ed810c2eb44e14" translate="yes" xml:space="preserve">
          <source>This should be written as:</source>
          <target state="translated">と書くべきです。</target>
        </trans-unit>
        <trans-unit id="61e8d88c0f9a32cfa6a86779f848c68e25d1219f" translate="yes" xml:space="preserve">
          <source>This situation can happen only for invalid UTF-8 strings. For valid UTF-8 strings concatenation preserves all characters in strings and additivity of string lengths.</source>
          <target state="translated">こ の状況は、 無効な UTF-8 文字列に対してのみ発生 し ます。有効な UTF-8 文字列の場合、連結は文字列内のすべてのキ ャ ラ ク タ と 文字列長の加算性を保持 し ます。</target>
        </trans-unit>
        <trans-unit id="602515b8cfd836d63ad817e8e5eb0cdf75d4d344" translate="yes" xml:space="preserve">
          <source>This small handful of promotion rules, together with the type's constructors and the default &lt;code&gt;convert&lt;/code&gt; method for numbers, are sufficient to make rational numbers interoperate completely naturally with all of Julia's other numeric types &amp;ndash; integers, floating-point numbers, and complex numbers. By providing appropriate conversion methods and promotion rules in the same manner, any user-defined numeric type can interoperate just as naturally with Julia's predefined numerics.</source>
          <target state="translated">この少数のプロモーションルールは、型のコンストラクターおよび数値のデフォルトの &lt;code&gt;convert&lt;/code&gt; メソッドと共に、有理数をJuliaの他のすべての数値型（整数、浮動小数点数、複素数）と完全に自然に相互運用させるのに十分です。同じ方法で適切な変換方法とプロモーションルールを提供することにより、ユーザー定義の数値型は、Juliaの事前定義された数値と自然に同じように相互運用できます。</target>
        </trans-unit>
        <trans-unit id="62b4befadfb2df7bd237a94a52e5e887dfce736d" translate="yes" xml:space="preserve">
          <source>This sort of in-language code generation, however, using the &lt;code&gt;eval(quote(...))&lt;/code&gt; pattern, is common enough that Julia comes with a macro to abbreviate this pattern:</source>
          <target state="translated">ただし、 &lt;code&gt;eval(quote(...))&lt;/code&gt; パターンを使用したこの種の言語内コード生成は、Juliaがこのパターンを短縮するマクロを提供するのに十分一般的です。</target>
        </trans-unit>
        <trans-unit id="29761b0f52dd794108c079b8401444ddd6c7292e" translate="yes" xml:space="preserve">
          <source>This style of code presents performance challenges for the language. The parser, when translating it into lower-level instructions, substantially reorganizes the above code by extracting the inner function to a separate code block. &quot;Captured&quot; variables such as &lt;code&gt;r&lt;/code&gt; that are shared by inner functions and their enclosing scope are also extracted into a heap-allocated &quot;box&quot; accessible to both inner and outer functions because the language specifies that &lt;code&gt;r&lt;/code&gt; in the inner scope must be identical to &lt;code&gt;r&lt;/code&gt; in the outer scope even after the outer scope (or another inner function) modifies &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">このコードスタイルは、言語のパフォーマンスの課題を提示します。パーサーは、それを下位レベルの命令に変換するときに、内部関数を別のコードブロックに抽出することにより、上記のコードを実質的に再編成します。内部関数の &lt;code&gt;r&lt;/code&gt; は &lt;code&gt;r&lt;/code&gt; と同一でなければならないことを言語が指定しているため、内部関数とそれらを囲むスコープによって共有される &lt;code&gt;r&lt;/code&gt; などの「キャプチャされた」変数も、ヒープに割り当てられた「ボックス」に抽出されます。外部スコープ（または別の内部関数）が &lt;code&gt;r&lt;/code&gt; を変更した後でも、外部スコープ内。</target>
        </trans-unit>
        <trans-unit id="84f5c4c03a8a8eafdd24b33dcdffe8977865737f" translate="yes" xml:space="preserve">
          <source>This style point is especially relevant to function arguments. For example, don't declare an argument to be of type &lt;code&gt;Int&lt;/code&gt; or &lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt;&lt;code&gt;Int32&lt;/code&gt;&lt;/a&gt; if it really could be any integer, expressed with the abstract type &lt;a href=&quot;../../base/numbers/index#Core.Integer&quot;&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/a&gt;. In fact, in many cases you can omit the argument type altogether, unless it is needed to disambiguate from other method definitions, since a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt; will be thrown anyway if a type is passed that does not support any of the requisite operations. (This is known as &lt;a href=&quot;https://en.wikipedia.org/wiki/Duck_typing&quot;&gt;duck typing&lt;/a&gt;.)</source>
          <target state="translated">このスタイルのポイントは、特に関数の引数に関連しています。たとえば、抽象型&lt;a href=&quot;../../base/numbers/index#Core.Integer&quot;&gt; &lt;code&gt;Integer&lt;/code&gt; &lt;/a&gt;で表現された整数である可能性がある場合は、引数を &lt;code&gt;Int&lt;/code&gt; または&lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt; &lt;code&gt;Int32&lt;/code&gt; &lt;/a&gt;型として宣言しないでください。実際、多くの場合、他のメソッド定義から明確にする必要がない限り、引数の型を完全に省略することができます。必要な操作をサポートしない型が渡された場合はとにかく&lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; &lt;/a&gt;がスローされるためです。（これは&lt;a href=&quot;https://en.wikipedia.org/wiki/Duck_typing&quot;&gt;ダックタイピング&lt;/a&gt;として知られています。）</target>
        </trans-unit>
        <trans-unit id="02f73861f45f55f4dfd018f62afadda932fbecbd" translate="yes" xml:space="preserve">
          <source>This syntax is equivalent to &lt;code&gt;if a; b else c end&lt;/code&gt;, but is often used to emphasize the value &lt;code&gt;b&lt;/code&gt;-or-&lt;code&gt;c&lt;/code&gt; which is being used as part of a larger expression, rather than the side effects that evaluating &lt;code&gt;b&lt;/code&gt; or &lt;code&gt;c&lt;/code&gt; may have.</source>
          <target state="translated">この構文は、次の &lt;code&gt;if a; b else c end&lt;/code&gt; と同等です。B他のC末端が、多くの場合、値を強調するために使用される &lt;code&gt;b&lt;/code&gt; -または- &lt;code&gt;c&lt;/code&gt; 評価することは、より大きな式の一部として使用されているのではなく、副作用 &lt;code&gt;b&lt;/code&gt; または &lt;code&gt;c&lt;/code&gt; 有していてもよいし。</target>
        </trans-unit>
        <trans-unit id="4b85e4944b2e592e05f80877bae9cf75b7c4b64c" translate="yes" xml:space="preserve">
          <source>This syntax is paired with the inline syntax for &lt;a href=&quot;#Footnote-references&quot;&gt;Footnote references&lt;/a&gt;. Make sure to read that section as well.</source>
          <target state="translated">この構文は、&lt;a href=&quot;#Footnote-references&quot;&gt;脚注参照の&lt;/a&gt;インライン構文とペアになっています。そのセクションも必ずお読みください。</target>
        </trans-unit>
        <trans-unit id="efb1d086124f576400d48da57453f979b82b1320" translate="yes" xml:space="preserve">
          <source>This syntax is paired with the inline syntax for &lt;a href=&quot;#Footnote-references-1&quot;&gt;Footnote references&lt;/a&gt;. Make sure to read that section as well.</source>
          <target state="translated">この構文は、&lt;a href=&quot;#Footnote-references-1&quot;&gt;脚注参照の&lt;/a&gt;インライン構文と対になっています。そのセクションも必ずお読みください。</target>
        </trans-unit>
        <trans-unit id="c6d5e6bac01082ca8f7d5c92e2fcad7892b0deee" translate="yes" xml:space="preserve">
          <source>This syntax is particularly useful with the terse single-line function definition form introduced in &lt;a href=&quot;../faq/index#Functions-1&quot;&gt;Functions&lt;/a&gt;. Although it is typical, there is no requirement that &lt;code&gt;begin&lt;/code&gt; blocks be multiline or that &lt;code&gt;(;)&lt;/code&gt; chains be single-line:</source>
          <target state="translated">この構文は、&lt;a href=&quot;../faq/index#Functions-1&quot;&gt;関数で&lt;/a&gt;導入された簡潔な単一行関数定義フォームで特に役立ちます。典型的ですが、 &lt;code&gt;begin&lt;/code&gt; ブロックが複数行であったり、 &lt;code&gt;(;)&lt;/code&gt; チェーンが単一行であったりする必要はありません。</target>
        </trans-unit>
        <trans-unit id="83194f70ea7b6512bb44658828e86b5786ad5bb1" translate="yes" xml:space="preserve">
          <source>This syntax is particularly useful with the terse single-line function definition form introduced in &lt;a href=&quot;../functions/index#man-functions&quot;&gt;Functions&lt;/a&gt;. Although it is typical, there is no requirement that &lt;code&gt;begin&lt;/code&gt; blocks be multiline or that &lt;code&gt;;&lt;/code&gt; chains be single-line:</source>
          <target state="translated">この構文は、&lt;a href=&quot;../functions/index#man-functions&quot;&gt;Functionsで&lt;/a&gt;導入された簡潔な1行の関数定義フォームで特に役立ちます。一般的ですが、 &lt;code&gt;begin&lt;/code&gt; ブロックが複数行である必要はありません &lt;code&gt;;&lt;/code&gt; チェーンは単一行である：</target>
        </trans-unit>
        <trans-unit id="f077087d177239939e6f396d6a624b184f2ac650" translate="yes" xml:space="preserve">
          <source>This syntax makes it easier to use functions to effectively extend the language, since calls look like normal code blocks. There are many possible uses quite different from &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;, such as managing system state. For example, there is a version of &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; that runs code ensuring that the opened file is eventually closed:</source>
          <target state="translated">呼び出しは通常のコードブロックのように見えるため、この構文を使用すると、関数を使用して言語を効果的に拡張しやすくなります。システム状態の管理など、&lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt;とはかなり異なる多くの用途が考えられます。たとえば、開いているファイルが最終的に閉じられるようにするコードを実行する&lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt; &lt;code&gt;open&lt;/code&gt; の&lt;/a&gt;バージョンがあります。</target>
        </trans-unit>
        <trans-unit id="f43fea58e0ae0e5d3bca8325c7f2571bc765f36f" translate="yes" xml:space="preserve">
          <source>This syntax requires at least Julia 1.3.</source>
          <target state="translated">この構文には最低でもJulia 1.3が必要です。</target>
        </trans-unit>
        <trans-unit id="1d1ae67ce8368a39428c877f009a37b4f880a256" translate="yes" xml:space="preserve">
          <source>This table may appear to contain missing characters in the second column, or even show characters that are inconsistent with the characters as they are rendered in the Julia REPL. In these cases, users are strongly advised to check their choice of fonts in their browser and REPL environment, as there are known issues with glyphs in many fonts.</source>
          <target state="translated">この表は、第2列に欠落した文字が含まれているように見えたり、Julia REPLでレンダリングされている文字と矛盾した文字が表示されたりすることがあります。このような場合、多くのフォントにグリフの問題があることが知られているので、ユーザはブラウザとREPL環境でフォントの選択を確認することを強くお勧めします。</target>
        </trans-unit>
        <trans-unit id="a5ba3b718070c3a0261004f71106e6c8df784735" translate="yes" xml:space="preserve">
          <source>This task will wait for five seconds, and then print &lt;code&gt;done&lt;/code&gt;. However, it has not started running yet. We can run it whenever we're ready by calling &lt;a href=&quot;../../base/parallel/index#Base.schedule&quot;&gt;&lt;code&gt;schedule&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">このタスクは5秒間待機してから、印刷が &lt;code&gt;done&lt;/code&gt; ます。ただし、まだ実行を開始していません。&lt;a href=&quot;../../base/parallel/index#Base.schedule&quot;&gt; &lt;code&gt;schedule&lt;/code&gt; &lt;/a&gt;を呼び出すことで、準備ができたらいつでも実行できます。</target>
        </trans-unit>
        <trans-unit id="c89bcac53db86417f8d21a8b570dbed4f33b9ba7" translate="yes" xml:space="preserve">
          <source>This trait is generally used to select between algorithms that pre-allocate a specific type of result, and algorithms that pick a result type based on the types of yielded values.</source>
          <target state="translated">この特性は、一般的に、特定のタイプの結果を事前に割り当てるアルゴリズムと、生成された値のタイプに基づいて結果のタイプを選択するアルゴリズムの間で選択するために使用されます。</target>
        </trans-unit>
        <trans-unit id="1f0edb00527596f441fd9eb4ee2e34299adf317c" translate="yes" xml:space="preserve">
          <source>This trait is generally used to select between algorithms that pre-allocate space for their result, and algorithms that resize their result incrementally.</source>
          <target state="translated">この特性は、一般的に、結果のためにスペースを事前に確保するアルゴリズムと、結果のサイズをインクリメンタルに変更するアルゴリズムの間で選択するために使用されます。</target>
        </trans-unit>
        <trans-unit id="2b71013f6265bcf3fbfa85be77bdc79abb70d813" translate="yes" xml:space="preserve">
          <source>This trait-based approach is also present in the &lt;a href=&quot;../../base/base/index#Base.promote&quot;&gt;&lt;code&gt;promote&lt;/code&gt;&lt;/a&gt; mechanism employed by the scalar &lt;code&gt;+&lt;/code&gt;. It uses &lt;a href=&quot;../../base/base/index#Base.promote_type&quot;&gt;&lt;code&gt;promote_type&lt;/code&gt;&lt;/a&gt;, which returns the optimal common type to compute the operation given the two types of the operands. This makes it possible to reduce the problem of implementing every function for every pair of possible type arguments, to the much smaller problem of implementing a conversion operation from each type to a common type, plus a table of preferred pair-wise promotion rules.</source>
          <target state="translated">この特性ベースのアプローチは、スカラー &lt;code&gt;+&lt;/code&gt; によって採用される&lt;a href=&quot;../../base/base/index#Base.promote&quot;&gt; &lt;code&gt;promote&lt;/code&gt; &lt;/a&gt;メカニズムにも存在します。2つのタイプのオペランドが指定されている&lt;a href=&quot;../../base/base/index#Base.promote_type&quot;&gt; &lt;code&gt;promote_type&lt;/code&gt; &lt;/a&gt;、最適な共通タイプを返し、演算を計算するPromote_typeを使用します。これにより、考えられる型引数のすべてのペアに対してすべての関数を実装する問題を軽減し、各型から共通の型への変換操作を実装するというはるかに小さな問題に加えて、優先ペアワイズプロモーションルールの表を作成できます。</target>
        </trans-unit>
        <trans-unit id="c92d7110a049bc7dcfccf1f71e9a16f713393738" translate="yes" xml:space="preserve">
          <source>This type is intended for linear algebra usage - for general data manipulation see &lt;a href=&quot;../../base/arrays/index#Base.permutedims&quot;&gt;&lt;code&gt;permutedims&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">このタイプは、線形代数の使用を目的としています。一般的なデータ操作については、&lt;a href=&quot;../../base/arrays/index#Base.permutedims&quot;&gt; &lt;code&gt;permutedims&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="14576a2d3cb9e572c8640a36656bd2d6880b92e4" translate="yes" xml:space="preserve">
          <source>This type may appear innocuous enough, until one considers how to construct an instance of it. If &lt;code&gt;a&lt;/code&gt; is an instance of &lt;code&gt;SelfReferential&lt;/code&gt;, then a second instance can be created by the call:</source>
          <target state="translated">この型は、そのインスタンスの作成方法を検討するまでは、無害に見えるかもしれません。場合のインスタンスである &lt;code&gt;SelfReferential&lt;/code&gt; 、2番目のインスタンスは、呼び出しによって作成することができます。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="48abfe02204852dcf9f8e73526e2ce7ae985ea01" translate="yes" xml:space="preserve">
          <source>This typically means that types for which a custom &lt;code&gt;==&lt;/code&gt; or &lt;code&gt;isequal&lt;/code&gt; method exists must implement a corresponding &lt;code&gt;hash&lt;/code&gt; method (and vice versa). Collections typically implement &lt;code&gt;isequal&lt;/code&gt; by calling &lt;code&gt;isequal&lt;/code&gt; recursively on all contents.</source>
          <target state="translated">これは通常、カスタム &lt;code&gt;==&lt;/code&gt; または &lt;code&gt;isequal&lt;/code&gt; メソッドが存在する型は、対応する &lt;code&gt;hash&lt;/code&gt; メソッドを実装する必要があることを意味します（逆も同様です）。コレクションは、一般的に実装する &lt;code&gt;isequal&lt;/code&gt; 呼び出すことにより、 &lt;code&gt;isequal&lt;/code&gt; すべての内容を再帰的に。</target>
        </trans-unit>
        <trans-unit id="b28a88f90eb34855ebcb028f2694d128ce6e0f54" translate="yes" xml:space="preserve">
          <source>This version returns &lt;code&gt;s&lt;/code&gt; as before but it also uses the &lt;code&gt;@isdefined&lt;/code&gt; macro to return a boolean indicating whether there is a local variable named &lt;code&gt;t&lt;/code&gt; defined in the function's outermost local scope. As you can see, there is no &lt;code&gt;t&lt;/code&gt; defined outside of the &lt;code&gt;for&lt;/code&gt; loop body. This is because of the hard scope rule again: since the assignment to &lt;code&gt;t&lt;/code&gt; occurs inside of a function, which introduces a hard scope, the assignment causes &lt;code&gt;t&lt;/code&gt; to become a new local variable in the local scope where it appears, i.e. inside of the loop body. Even if there were a global named &lt;code&gt;t&lt;/code&gt;, it would make no difference&amp;mdash;the hard scope rule isn't affected by anything in global scope.</source>
          <target state="translated">このバージョンは以前と同じように &lt;code&gt;s&lt;/code&gt; を返しますが、 &lt;code&gt;@isdefined&lt;/code&gt; マクロを使用して、関数の最も外側のローカルスコープに &lt;code&gt;t&lt;/code&gt; という名前のローカル変数が定義されているかどうかを示すブール値も返します。ご覧のとおり、 &lt;code&gt;for&lt;/code&gt; ループ本体の外側に &lt;code&gt;t&lt;/code&gt; は定義されていません。これもハードスコープルールによるものです &lt;code&gt;t&lt;/code&gt; への割り当ては関数内で発生し、ハードスコープが導入されるため、割り当てにより、 &lt;code&gt;t&lt;/code&gt; は、それが表示されるローカルスコープ内、つまりループ内で新しいローカル変数になります。体。 &lt;code&gt;t&lt;/code&gt; という名前のグローバルがあったとしても、違いはありません。ハードスコープルールは、グローバルスコープ内の何にも影響されません。</target>
        </trans-unit>
        <trans-unit id="732e45fbae13bbb344c9807714543561cca2e0ec" translate="yes" xml:space="preserve">
          <source>This view is similarly selecting every other column from our original &lt;code&gt;A&lt;/code&gt; &amp;mdash; and thus it needs to skip the equivalent of two five-element columns when moving between indices in the second dimension:</source>
          <target state="translated">このビューは、同様に元の &lt;code&gt;A&lt;/code&gt; から1つおきの列を選択しています。したがって、2番目の次元のインデックス間を移動するときは、2つの5要素列に相当するものをスキップする必要があります。</target>
        </trans-unit>
        <trans-unit id="e583420152cbf4b34f9b32d8a694ae8548f399df" translate="yes" xml:space="preserve">
          <source>This will continuing tracking changes for &lt;code&gt;path&lt;/code&gt; in the background until &lt;code&gt;unwatch_folder&lt;/code&gt; is called on the same &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">これは、同じ &lt;code&gt;path&lt;/code&gt; &lt;code&gt;unwatch_folder&lt;/code&gt; が呼び出されるまで、バックグラウンドで &lt;code&gt;path&lt;/code&gt; 変更を追跡し続けます。</target>
        </trans-unit>
        <trans-unit id="f13e78aea1113a7ecb31103654e0f08522f06f04" translate="yes" xml:space="preserve">
          <source>This will create a link in the generated docs to the &lt;a href=&quot;../../base/numbers/index#Base.parse&quot;&gt;&lt;code&gt;parse&lt;/code&gt;&lt;/a&gt; documentation (which has more information about what this function actually does), and to the &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt; documentation. It's good to include cross references to mutating/non-mutating versions of a function, or to highlight a difference between two similar-seeming functions.</source>
          <target state="translated">これにより、生成されたドキュメントに&lt;a href=&quot;../../base/numbers/index#Base.parse&quot;&gt; &lt;code&gt;parse&lt;/code&gt; &lt;/a&gt;ドキュメント（この関数が実際に行うことについての詳細が含まれています）へのリンクと、&lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt;ドキュメントへのリンクが作成されます。関数の変化するバージョンまたは変化しないバージョンへの相互参照を含めるか、2つの類似した関数の違いを強調することは良いことです。</target>
        </trans-unit>
        <trans-unit id="b96927e2f1de092a211a143e54dd74f41007bb3e" translate="yes" xml:space="preserve">
          <source>This will not specialize:</source>
          <target state="translated">これでは特化しません。</target>
        </trans-unit>
        <trans-unit id="c2a99e60f54b8d446ae19455b15a099ea1107a66" translate="yes" xml:space="preserve">
          <source>This will return &lt;code&gt;(-1, 0)&lt;/code&gt;.</source>
          <target state="translated">これは &lt;code&gt;(-1, 0)&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="286660d1556fa7b595f130646ffbfab297bc669e" translate="yes" xml:space="preserve">
          <source>This will run afoul of a method that supplies default padding:</source>
          <target state="translated">これは、デフォルトのパディングを提供するメソッドに違反することになります。</target>
        </trans-unit>
        <trans-unit id="0f5b3315acf48556d7fa62b1bfb954506305c5d1" translate="yes" xml:space="preserve">
          <source>This will typically be the parent directory of &lt;code&gt;gitdir(repo)&lt;/code&gt;, but can be different in some cases: e.g. if either the &lt;code&gt;core.worktree&lt;/code&gt; configuration variable or the &lt;code&gt;GIT_WORK_TREE&lt;/code&gt; environment variable is set.</source>
          <target state="translated">これは通常 &lt;code&gt;gitdir(repo)&lt;/code&gt; の親ディレクトリになりますが、たとえば &lt;code&gt;core.worktree&lt;/code&gt; 構成変数または &lt;code&gt;GIT_WORK_TREE&lt;/code&gt; 環境変数が設定されている場合など、場合によっては異なることがあります。</target>
        </trans-unit>
        <trans-unit id="465cd08242692b4a225db05b65fef6a04fbb4c51" translate="yes" xml:space="preserve">
          <source>This works, but (as you can verify for yourself using &lt;code&gt;@code_warntype array3(5.0, 2)&lt;/code&gt;) the problem is that the output type cannot be inferred: the argument &lt;code&gt;N&lt;/code&gt; is a &lt;em&gt;value&lt;/em&gt; of type &lt;code&gt;Int&lt;/code&gt;, and type-inference does not (and cannot) predict its value in advance. This means that code using the output of this function has to be conservative, checking the type on each access of &lt;code&gt;A&lt;/code&gt;; such code will be very slow.</source>
          <target state="translated">これは機能しますが、（ &lt;code&gt;@code_warntype array3(5.0, 2)&lt;/code&gt; を使用して自分で確認できるように）問題は、出力タイプを推論できないことです：引数 &lt;code&gt;N&lt;/code&gt; はタイプ &lt;code&gt;Int&lt;/code&gt; の&lt;em&gt;値&lt;/em&gt;であり、タイプ推論は（そして事前にその値を予測することはできません。つまり、この関数の出力を使用するコードは保守的でなければならず、 &lt;code&gt;A&lt;/code&gt; の各アクセスで型をチェックします。このようなコードは非常に遅くなります。</target>
        </trans-unit>
        <trans-unit id="91dccd376458eb0eba1948b74924d4cacdf4e65c" translate="yes" xml:space="preserve">
          <source>This would provide custom showing of vectors with a specific new element type. While tempting, this should be avoided. The trouble is that users will expect a well-known type like &lt;code&gt;Vector()&lt;/code&gt; to behave in a certain way, and overly customizing its behavior can make it harder to work with.</source>
          <target state="translated">これにより、特定の新しい要素タイプを持つベクターのカスタム表示が提供されます。魅力的な間、これは避けられるべきです。問題は、 &lt;code&gt;Vector()&lt;/code&gt; のようなよく知られた型が特定の方法で動作することをユーザーが期待することであり、その動作を過度にカスタマイズすると、操作が困難になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="ce93190f2d45e03cc3d832dd1dbdeefa914b4a96" translate="yes" xml:space="preserve">
          <source>Those that are parsed like &lt;code&gt;*&lt;/code&gt; (in terms of precedence) include &lt;code&gt;* / &amp;divide; % &amp;amp; &amp;sdot; ∘ &amp;times; |\\| &amp;cap; &amp;and; &amp;otimes; ⊘ ⊙ ⊚ ⊛ ⊠ ⊡ ⊓ &amp;lowast; ∙ ∤ ⅋ ≀ ⊼ ⋄ ⋆ ⋇ ⋉ ⋊ ⋋ ⋌ ⋏ ⋒ ⟑ ⦸ ⦼ ⦾ ⦿ ⧶ ⧷ ⨇ ⨰ ⨱ ⨲ ⨳ ⨴ ⨵ ⨶ ⨷ ⨸ ⨻ ⨼ ⨽ ⩀ ⩃ ⩄ ⩋ ⩍ ⩎ ⩑ ⩓ ⩕ ⩘ ⩚ ⩜ ⩞ ⩟ ⩠ ⫛ ⊍ ▷ ⨝ ⟕ ⟖ ⟗&lt;/code&gt; and those that are parsed like &lt;code&gt;+&lt;/code&gt; include &lt;code&gt;+ - |\|| &amp;oplus; ⊖ ⊞ ⊟ |++| &amp;cup; &amp;or; ⊔ &amp;plusmn; ∓ ∔ ∸ ≏ ⊎ ⊻ ⊽ ⋎ ⋓ ⧺ ⧻ ⨈ ⨢ ⨣ ⨤ ⨥ ⨦ ⨧ ⨨ ⨩ ⨪ ⨫ ⨬ ⨭ ⨮ ⨹ ⨺ ⩁ ⩂ ⩅ ⩊ ⩌ ⩏ ⩐ ⩒ ⩔ ⩖ ⩗ ⩛ ⩝ ⩡ ⩢ ⩣&lt;/code&gt; There are many others that are related to arrows, comparisons, and powers.</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; （優先順位の観点から）のように解析されるものには、 &lt;code&gt;* / &amp;divide; % &amp;amp; &amp;sdot; ∘ &amp;times; |\\| &amp;cap; &amp;and; &amp;otimes; ⊘ ⊙ ⊚ ⊛ ⊠ ⊡ ⊓ &amp;lowast; ∙ ∤ ⅋ ≀ ⊼ ⋄ ⋆ ⋇ ⋉ ⋊ ⋋ ⋌ ⋏ ⋒ ⟑ ⦸ ⦼ ⦾ ⦿ ⧶ ⧷ ⨇ ⨰ ⨱ ⨲ ⨳ ⨴ ⨵ ⨶ ⨷ ⨸ ⨻ ⨼ ⨽ ⩀ ⩃ ⩄ ⩋ ⩍ ⩎ ⩑ ⩓ ⩕ ⩘ ⩚ ⩜ ⩞ ⩟ ⩠ ⫛ ⊍ ▷ ⨝ ⟕ ⟖ ⟗&lt;/code&gt; および &lt;code&gt;+&lt;/code&gt; のように解析されるものには &lt;code&gt;+ - |\|| &amp;oplus; ⊖ ⊞ ⊟ |++| &amp;cup; &amp;or; ⊔ &amp;plusmn; ∓ ∔ ∸ ≏ ⊎ ⊻ ⊽ ⋎ ⋓ ⧺ ⧻ ⨈ ⨢ ⨣ ⨤ ⨥ ⨦ ⨧ ⨨ ⨩ ⨪ ⨫ ⨬ ⨭ ⨮ ⨹ ⨺ ⩁ ⩂ ⩅ ⩊ ⩌ ⩏ ⩐ ⩒ ⩔ ⩖ ⩗ ⩛ ⩝ ⩡ ⩢ ⩣&lt;/code&gt; ⊎⊻⊽⋎⋓⧺⧻⨈⨢⨣⨤⨥⨦⨧⨨⨩⨪⨫⨬⨭⨮⨹⨺⩁⩂⩅⩊⩌⩏⩐⩒⩔⩖⩗⩛⩝⩡⩢⩣たくさんあります矢印、比較、および力に関連する他のもの。</target>
        </trans-unit>
        <trans-unit id="ad99bad1a037688795be38c39427fa0769348cbe" translate="yes" xml:space="preserve">
          <source>Though most code can be written in Julia, there are many high-quality, mature libraries for numerical computing already written in C and Fortran. To allow easy use of this existing code, Julia makes it simple and efficient to call C and Fortran functions. Julia has a &quot;no boilerplate&quot; philosophy: functions can be called directly from Julia without any &quot;glue&quot; code, code generation, or compilation &amp;ndash; even from the interactive prompt. This is accomplished just by making an appropriate call with &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; syntax, which looks like an ordinary function call.</source>
          <target state="translated">ほとんどのコードはJuliaで記述できますが、CおよびFortranで記述された数値計算用の高品質で成熟したライブラリが多数あります。この既存のコードを簡単に使用できるようにするために、JuliaはCおよびFortran関数の呼び出しを簡単かつ効率的にします。Juliaには「定型文なし」の哲学があります。関数は、「グルー」コード、コード生成、またはコンパイルなしで、Juliaから直接呼び出すことができます-対話型プロンプトからでも。これは、通常の関数呼び出しのように見える、&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt;構文で適切な呼び出しを行うだけで実現できます。</target>
        </trans-unit>
        <trans-unit id="b1098d0533850d709c2eea0b6cccb4d789ad7a33" translate="yes" xml:space="preserve">
          <source>Thought Balloon</source>
          <target state="translated">思考バルーン</target>
        </trans-unit>
        <trans-unit id="e7d883028ca01a1fd0855b14863bfa7121240ec4" translate="yes" xml:space="preserve">
          <source>Thread-safety</source>
          <target state="translated">Thread-safety</target>
        </trans-unit>
        <trans-unit id="bb12e8aaaecc434fd51e448fe7669bced1bdd107" translate="yes" xml:space="preserve">
          <source>Threads</source>
          <target state="translated">Threads</target>
        </trans-unit>
        <trans-unit id="e419e1146ddb88bafc45f8ebac6b8292c4ced05a" translate="yes" xml:space="preserve">
          <source>Threads.@threads</source>
          <target state="translated">Threads.@threads</target>
        </trans-unit>
        <trans-unit id="af0966b4fd9f2b0cc49a7865b215af5194f37f0a" translate="yes" xml:space="preserve">
          <source>Threads.Atomic</source>
          <target state="translated">Threads.Atomic</target>
        </trans-unit>
        <trans-unit id="6d681958311270ce80eaf4515832385236fe2aa7" translate="yes" xml:space="preserve">
          <source>Threads.Condition</source>
          <target state="translated">Threads.Condition</target>
        </trans-unit>
        <trans-unit id="35d529a964d25f4e3aa6ca9d1ca0ce8f4be400d6" translate="yes" xml:space="preserve">
          <source>Threads.Mutex</source>
          <target state="translated">Threads.Mutex</target>
        </trans-unit>
        <trans-unit id="fdec23601f6d79aec8f6567bbffa2c92cd56f7b8" translate="yes" xml:space="preserve">
          <source>Threads.SpinLock</source>
          <target state="translated">Threads.SpinLock</target>
        </trans-unit>
        <trans-unit id="dc252ab69b1ee919bcf5db69994a187e411ca970" translate="yes" xml:space="preserve">
          <source>Threads.atomic_add!()</source>
          <target state="translated">Threads.atomic_add!()</target>
        </trans-unit>
        <trans-unit id="0d6bade715cafd9dcdad87d2c22d90bbfc1e9bc3" translate="yes" xml:space="preserve">
          <source>Threads.atomic_and!()</source>
          <target state="translated">Threads.atomic_and!()</target>
        </trans-unit>
        <trans-unit id="fc348be87bc254a3559139ac661b72946bb39a71" translate="yes" xml:space="preserve">
          <source>Threads.atomic_cas!()</source>
          <target state="translated">Threads.atomic_cas!()</target>
        </trans-unit>
        <trans-unit id="f62c63142218283b0037fda6af5f0f3a02c2975f" translate="yes" xml:space="preserve">
          <source>Threads.atomic_fence()</source>
          <target state="translated">Threads.atomic_fence()</target>
        </trans-unit>
        <trans-unit id="4bb65236b89d5d31da9f4d8820a38668a9dbf21c" translate="yes" xml:space="preserve">
          <source>Threads.atomic_max!()</source>
          <target state="translated">Threads.atomic_max!()</target>
        </trans-unit>
        <trans-unit id="8833f2d74d5a7e5aa857580591ba695e2d6fc9b4" translate="yes" xml:space="preserve">
          <source>Threads.atomic_min!()</source>
          <target state="translated">Threads.atomic_min!()</target>
        </trans-unit>
        <trans-unit id="9d6eae92e1cf6253daf74605c345f63d354fc4f7" translate="yes" xml:space="preserve">
          <source>Threads.atomic_nand!()</source>
          <target state="translated">Threads.atomic_nand!()</target>
        </trans-unit>
        <trans-unit id="560bfbccb3de090b47f2c10c244f66c66c580494" translate="yes" xml:space="preserve">
          <source>Threads.atomic_or!()</source>
          <target state="translated">Threads.atomic_or!()</target>
        </trans-unit>
        <trans-unit id="f3e1cd9ba44ee30e82bb0904faa52cbf59c0038d" translate="yes" xml:space="preserve">
          <source>Threads.atomic_sub!()</source>
          <target state="translated">Threads.atomic_sub!()</target>
        </trans-unit>
        <trans-unit id="13028b27bde6678508d39212264589ec6a15feea" translate="yes" xml:space="preserve">
          <source>Threads.atomic_xchg!()</source>
          <target state="translated">Threads.atomic_xchg!()</target>
        </trans-unit>
        <trans-unit id="733c9373c4a5344eab540082f44fb3d0c9691c39" translate="yes" xml:space="preserve">
          <source>Threads.atomic_xor!()</source>
          <target state="translated">Threads.atomic_xor!()</target>
        </trans-unit>
        <trans-unit id="be840129016948f129890bec761377fa710398c9" translate="yes" xml:space="preserve">
          <source>Threads.nthreads()</source>
          <target state="translated">Threads.nthreads()</target>
        </trans-unit>
        <trans-unit id="a889ac57822379f233ec938a1f7a38f70d5c6296" translate="yes" xml:space="preserve">
          <source>Threads.threadid()</source>
          <target state="translated">Threads.threadid()</target>
        </trans-unit>
        <trans-unit id="0aad1c36c5f4e6d7170e1c4b0293604b8b212cfa" translate="yes" xml:space="preserve">
          <source>Three Consecutive Equals Signs</source>
          <target state="translated">三連続イコールサイン</target>
        </trans-unit>
        <trans-unit id="275c8d26b15f014b3ee22a364da92aa616ab6c12" translate="yes" xml:space="preserve">
          <source>Three Dimensional Angle</source>
          <target state="translated">三次元角度</target>
        </trans-unit>
        <trans-unit id="34c44d666ec4b94d3bbda9f288521e6aef7e833a" translate="yes" xml:space="preserve">
          <source>Three Leftwards Arrows</source>
          <target state="translated">三本の左矢印</target>
        </trans-unit>
        <trans-unit id="6845b5c6dca3f04d0fc4092b2f6f1fa8ad41c493" translate="yes" xml:space="preserve">
          <source>Three Rightwards Arrows</source>
          <target state="translated">三本の右矢印</target>
        </trans-unit>
        <trans-unit id="649300e311dc9e0d97883f25214a816938115a07" translate="yes" xml:space="preserve">
          <source>Throw a &lt;a href=&quot;#Core.TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; unless &lt;code&gt;x isa type&lt;/code&gt;. The syntax &lt;code&gt;x::type&lt;/code&gt; calls this function.</source>
          <target state="translated">&lt;code&gt;x isa type&lt;/code&gt; ない限り、&lt;a href=&quot;#Core.TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; を&lt;/a&gt;スローします。構文 &lt;code&gt;x::type&lt;/code&gt; はこの関数を呼び出します。</target>
        </trans-unit>
        <trans-unit id="714760623b81eda189caf56e00d3dd66b2ad778d" translate="yes" xml:space="preserve">
          <source>Throw an &lt;a href=&quot;#Core.AssertionError&quot;&gt;&lt;code&gt;AssertionError&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;cond&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;. Preferred syntax for writing assertions. Message &lt;code&gt;text&lt;/code&gt; is optionally displayed upon assertion failure.</source>
          <target state="translated">&lt;code&gt;cond&lt;/code&gt; が &lt;code&gt;false&lt;/code&gt; の場合、&lt;a href=&quot;#Core.AssertionError&quot;&gt; &lt;code&gt;AssertionError&lt;/code&gt; を&lt;/a&gt;スローします。アサーションを記述するための推奨構文。メッセージ &lt;code&gt;text&lt;/code&gt; は、アサーションの失敗時にオプションで表示されます。</target>
        </trans-unit>
        <trans-unit id="fde334b7c50e867ec42457ab4cfac34135b82f0a" translate="yes" xml:space="preserve">
          <source>Throw an error if the specified indices &lt;code&gt;I&lt;/code&gt; are not in bounds for the given array &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">指定されたインデックス &lt;code&gt;I&lt;/code&gt; が指定された配列 &lt;code&gt;A&lt;/code&gt; の境界内にない場合、エラーをスローします。</target>
        </trans-unit>
        <trans-unit id="7f0af829c424acf2aaed30a43af670830af1bf4e" translate="yes" xml:space="preserve">
          <source>Throw an object as an exception.</source>
          <target state="translated">例外としてオブジェクトをスローします。</target>
        </trans-unit>
        <trans-unit id="140ef8a807386c342270a60ed53ce02c73c18d34" translate="yes" xml:space="preserve">
          <source>Throw an object without changing the current exception backtrace. The default argument is the current exception (if called within a &lt;code&gt;catch&lt;/code&gt; block).</source>
          <target state="translated">現在の例外バックトレースを変更せずにオブジェクトをスローします。デフォルトの引数は現在の例外です（ &lt;code&gt;catch&lt;/code&gt; ブロック内で呼び出された場合）。</target>
        </trans-unit>
        <trans-unit id="580dadd5162b2d0824b14a53a53520885f69bb7a" translate="yes" xml:space="preserve">
          <source>Throwing Julia Exceptions</source>
          <target state="translated">ジュリアの例外を投げる</target>
        </trans-unit>
        <trans-unit id="b55eb9740df570160a4568c629959c237f6eace8" translate="yes" xml:space="preserve">
          <source>Thumbs Down Sign</source>
          <target state="translated">サムズダウンサイン</target>
        </trans-unit>
        <trans-unit id="605c4f2d25dae572dac0bd7100ede0e91ce19009" translate="yes" xml:space="preserve">
          <source>Thumbs Up Sign</source>
          <target state="translated">サムズアップサイン</target>
        </trans-unit>
        <trans-unit id="760c9c88e6ab4015bdda89ce2b03fc29323c09ed" translate="yes" xml:space="preserve">
          <source>Thus &lt;em&gt;lexical scope&lt;/em&gt; means that the scope of variables can be inferred from the source code alone.</source>
          <target state="translated">したがって、&lt;em&gt;字句スコープ&lt;/em&gt;は、変数のスコープをソースコードだけから推測できることを意味します。</target>
        </trans-unit>
        <trans-unit id="ff70b958cdd14735d439df7f031d3f90247ced00" translate="yes" xml:space="preserve">
          <source>Thus &lt;em&gt;lexical scope&lt;/em&gt; means that what a variable in a particular piece of code refers to can be deduced from the code in which it appears alone and does not depend on how the program executes. A scope nested inside another scope can &quot;see&quot; variables in all the outer scopes in which it is contained. Outer scopes, on the other hand, cannot see variables in inner scopes.</source>
          <target state="translated">したがって、&lt;em&gt;字句スコープ&lt;/em&gt;とは、特定のコード内の変数が参照するものを、それが単独で表示されるコードから推測でき、プログラムの実行方法に依存しないことを意味します。別のスコープ内にネストされたスコープは、それが含まれているすべての外部スコープの変数を「見る」ことができます。一方、外部スコープは内部スコープの変数を見ることができません。</target>
        </trans-unit>
        <trans-unit id="3c1904bf1147b9a9b4718a957b259ff3b20ed4ec" translate="yes" xml:space="preserve">
          <source>Thus global variables are only inherited for reading, not for writing:</source>
          <target state="translated">このように、グローバル変数は読み込み用にのみ継承され、書き込み用には継承されません。</target>
        </trans-unit>
        <trans-unit id="37807420ee61e708d970e7d90819e0a642c8a0c3" translate="yes" xml:space="preserve">
          <source>Thus programs should be careful referencing globals in remote calls. In fact, it is preferable to avoid them altogether if possible. If you must reference globals, consider using &lt;code&gt;let&lt;/code&gt; blocks to localize global variables.</source>
          <target state="translated">したがって、プログラムはリモート呼び出しでグローバルを注意深く参照する必要があります。実際、可能であればそれらを完全に回避することが望ましいです。グローバルを参照する必要がある場合は、 &lt;code&gt;let&lt;/code&gt; ブロックを使用してグローバル変数をローカライズすることを検討してください。</target>
        </trans-unit>
        <trans-unit id="1ec3104629ec61f45eec6025fd4920b5b97b82ff" translate="yes" xml:space="preserve">
          <source>Thus, a minimal cluster manager would need to:</source>
          <target state="translated">したがって、最小限のクラスタマネージャが必要になります。</target>
        </trans-unit>
        <trans-unit id="7b4c9299e93152df59eb2d7a356e597a287f7f91" translate="yes" xml:space="preserve">
          <source>Thus, a task executing a &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; effectively prevents the Julia scheduler from executing any other tasks till the call returns. This is true for all calls into external libraries. Exceptions are calls into custom C code that call back into Julia (which may then yield) or C code that calls &lt;code&gt;jl_yield()&lt;/code&gt; (C equivalent of &lt;a href=&quot;../../base/parallel/index#Base.yield&quot;&gt;&lt;code&gt;yield&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">したがって、&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt;を実行するタスクは、呼び出しが戻るまでJuliaスケジューラーが他のタスクを実行するのを効果的に防ぎます。これは、外部ライブラリへのすべての呼び出しに当てはまります。例外は、JuliaにコールバックするカスタムCコードへの呼び出し（これにより、yieldが発生する可能性があります）または &lt;code&gt;jl_yield()&lt;/code&gt; を呼び出すCコード（Cが&lt;a href=&quot;../../base/parallel/index#Base.yield&quot;&gt; &lt;code&gt;yield&lt;/code&gt; に&lt;/a&gt;相当）です。</target>
        </trans-unit>
        <trans-unit id="12a48793aeeeb710ac9dcc9260ed6b02480a02b9" translate="yes" xml:space="preserve">
          <source>Thus, abstract types allow programmers to write generic functions that can later be used as the default method by many combinations of concrete types. Thanks to multiple dispatch, the programmer has full control over whether the default or more specific method is used.</source>
          <target state="translated">このように、抽象型は、プログラマが後に具体的な型の多くの組み合わせによってデフォルトのメソッドとして使用されることができる汎用的な関数を書くことを可能にします。複数のディスパッチのおかげで、プログラマはデフォルトのメソッドを使用するか、より具体的なメソッドを使用するかを完全に制御することができます。</target>
        </trans-unit>
        <trans-unit id="f601caf538448fdd3302f7c350467ef72143226f" translate="yes" xml:space="preserve">
          <source>Thus, although the &lt;code&gt;⊘&lt;/code&gt; operator usually returns an instance of &lt;code&gt;OurRational&lt;/code&gt;, if either of its arguments are complex integers, it will return an instance of &lt;code&gt;Complex{OurRational}&lt;/code&gt; instead. The interested reader should consider perusing the rest of &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/rational.jl&quot;&gt;&lt;code&gt;rational.jl&lt;/code&gt;&lt;/a&gt;: it is short, self-contained, and implements an entire basic Julia type.</source>
          <target state="translated">けれども従って、 &lt;code&gt;⊘&lt;/code&gt; オペレータは通常のインスタンス戻り &lt;code&gt;OurRational&lt;/code&gt; を引数のいずれかが複素整数である場合、それはのインスタンス返され &lt;code&gt;Complex{OurRational}&lt;/code&gt; 代わりに。興味のある読者は、&lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/rational.jl&quot;&gt; &lt;code&gt;rational.jl&lt;/code&gt; &lt;/a&gt;の残りの部分を熟読することを検討してください。これは短く、自己完結型で、基本的なJuliaタイプ全体を実装しています。</target>
        </trans-unit>
        <trans-unit id="d4a7cf3884ed1ab47ea12e5c77940efcf3a6f460" translate="yes" xml:space="preserve">
          <source>Thus, arithmetic with Julia integers is actually a form of &lt;a href=&quot;https://en.wikipedia.org/wiki/Modular_arithmetic&quot;&gt;modular arithmetic&lt;/a&gt;. This reflects the characteristics of the underlying arithmetic of integers as implemented on modern computers. In applications where overflow is possible, explicit checking for wraparound produced by overflow is essential; otherwise, the &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; type in &lt;a href=&quot;#Arbitrary-Precision-Arithmetic&quot;&gt;Arbitrary Precision Arithmetic&lt;/a&gt; is recommended instead.</source>
          <target state="translated">したがって、ジュリア整数を使用した算術は、実際には&lt;a href=&quot;https://en.wikipedia.org/wiki/Modular_arithmetic&quot;&gt;モジュラー算術の&lt;/a&gt;形式です。これは、最新のコンピューターに実装されている整数の基礎となる算術の特性を反映しています。オーバーフローが発生する可能性のあるアプリケーションでは、オーバーフローによって生成されるラップアラウンドを明示的にチェックすることが不可欠です。それ以外の場合は、代わりに&lt;a href=&quot;#Arbitrary-Precision-Arithmetic&quot;&gt;Arbitrary PrecisionArithmeticの&lt;/a&gt;&lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; &lt;/a&gt;タイプをお勧めします。</target>
        </trans-unit>
        <trans-unit id="626f028f772316f29a1f3bc180af9b3cc6e9feec" translate="yes" xml:space="preserve">
          <source>Thus, arithmetic with Julia integers is actually a form of &lt;a href=&quot;https://en.wikipedia.org/wiki/Modular_arithmetic&quot;&gt;modular arithmetic&lt;/a&gt;. This reflects the characteristics of the underlying arithmetic of integers as implemented on modern computers. In applications where overflow is possible, explicit checking for wraparound produced by overflow is essential; otherwise, the &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; type in &lt;a href=&quot;#Arbitrary-Precision-Arithmetic-1&quot;&gt;Arbitrary Precision Arithmetic&lt;/a&gt; is recommended instead.</source>
          <target state="translated">したがって、ジュリア整数による算術は、実際には&lt;a href=&quot;https://en.wikipedia.org/wiki/Modular_arithmetic&quot;&gt;モジュラー算術の&lt;/a&gt;形式です。これは、現代のコンピューターに実装されている整数の基礎となる算術の特性を反映しています。オーバーフローが発生する可能性があるアプリケーションでは、オーバーフローによって生成されるラップアラウンドの明示的なチェックが不可欠です。それ以外の場合は、代わりに&lt;a href=&quot;#Arbitrary-Precision-Arithmetic-1&quot;&gt;任意精度演算の&lt;/a&gt;&lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; &lt;/a&gt;型をお勧めします。</target>
        </trans-unit>
        <trans-unit id="b2b83f1b321c20d701d32773b7f124c10518c979" translate="yes" xml:space="preserve">
          <source>Thus, the parser does not know that &lt;code&gt;r&lt;/code&gt; has a fixed type (&lt;code&gt;Int&lt;/code&gt;). nor that &lt;code&gt;r&lt;/code&gt; does not change value once the inner function is created (so that the box is unneeded). Therefore, the parser emits code for box that holds an object with an abstract type such as &lt;code&gt;Any&lt;/code&gt;, which requires run-time type dispatch for each occurrence of &lt;code&gt;r&lt;/code&gt;. This can be verified by applying &lt;code&gt;@code_warntype&lt;/code&gt; to the above function. Both the boxing and the run-time type dispatch can cause loss of performance.</source>
          <target state="translated">したがって、パーサーは &lt;code&gt;r&lt;/code&gt; が固定型（ &lt;code&gt;Int&lt;/code&gt; ）であることを認識していません。また、内部関数が作成されると、 &lt;code&gt;r&lt;/code&gt; は値を変更しません（ボックスが不要になるため）。したがって、パーサーは &lt;code&gt;Any&lt;/code&gt; のような抽象型のオブジェクトを保持するボックスのコードを発行します。これには、 &lt;code&gt;r&lt;/code&gt; が出現するたびにランタイム型のディスパッチが必要です。これは、上記の関数に &lt;code&gt;@code_warntype&lt;/code&gt; を適用することで確認できます。ボクシングとランタイムタイプのディスパッチの両方が、パフォーマンスの低下を引き起こす可能性があります。</target>
        </trans-unit>
        <trans-unit id="405f79bc0440035cdbe7cdfa2f5f8191b1e769bd" translate="yes" xml:space="preserve">
          <source>Thus, use &lt;code&gt;Int&lt;/code&gt; literals when possible, with &lt;code&gt;Rational{Int}&lt;/code&gt; for literal non-integer numbers, in order to make it easier to use your code.</source>
          <target state="translated">したがって、コードを使いやすくするために、可能であれば &lt;code&gt;Int&lt;/code&gt; リテラルを使用し、 &lt;code&gt;Rational{Int}&lt;/code&gt; をリテラル非整数の数値に使用します。</target>
        </trans-unit>
        <trans-unit id="7dfa2079791005dea78a84f2b9726b0bdb6de3e2" translate="yes" xml:space="preserve">
          <source>Thus, while the implicit type parameter constructors provided by default in Julia are fairly strict, it is possible to make them behave in a more relaxed but sensible manner quite easily. Moreover, since constructors can leverage all of the power of the type system, methods, and multiple dispatch, defining sophisticated behavior is typically quite simple.</source>
          <target state="translated">このように、Juliaでデフォルトで提供されている暗黙の型パラメータのコンストラクタはかなり厳密ですが、よりリラックスした、しかし賢明な方法で簡単に動作させることができます。さらに、コンストラクタは型システム、メソッド、マルチプルディスパッチのすべての力を活用できるので、洗練された振る舞いを定義するのは一般的に非常に簡単です。</target>
        </trans-unit>
        <trans-unit id="a7677e84b6660292620566337bcfc94144911cc7" translate="yes" xml:space="preserve">
          <source>Ticket</source>
          <target state="translated">Ticket</target>
        </trans-unit>
        <trans-unit id="dd697aa8cce5c810f10070878f9d6f89c5a5937c" translate="yes" xml:space="preserve">
          <source>Tiger</source>
          <target state="translated">Tiger</target>
        </trans-unit>
        <trans-unit id="abee288b1344129c8247490b49084155f62a8492" translate="yes" xml:space="preserve">
          <source>Tiger Face</source>
          <target state="translated">虎面</target>
        </trans-unit>
        <trans-unit id="a213b01ff977ddc2b77a2851775a17888cf936a4" translate="yes" xml:space="preserve">
          <source>Tilde Operator</source>
          <target state="translated">ティルデオペレーター</target>
        </trans-unit>
        <trans-unit id="81f0f8e7286707e1e34046d94807c0c638e949b0" translate="yes" xml:space="preserve">
          <source>Tilde Operator Above Leftwards Arrow</source>
          <target state="translated">左矢印の上のティルデ演算子</target>
        </trans-unit>
        <trans-unit id="248cc81b5c32172ec329e2bbdd1480c988bb3388" translate="yes" xml:space="preserve">
          <source>Tilde Operator With Dot Above</source>
          <target state="translated">上のドットを持つティルデ オペレータ</target>
        </trans-unit>
        <trans-unit id="6835d0448d1238ede880e3906c4de76444a3efae" translate="yes" xml:space="preserve">
          <source>Tilde Operator With Rising Dots</source>
          <target state="translated">ライジングドットのティルデオペレータ</target>
        </trans-unit>
        <trans-unit id="358886c6ac36a9af9f2410bb87185645588db7c9" translate="yes" xml:space="preserve">
          <source>Time in a signature. Matches the &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_time&quot;&gt;&lt;code&gt;git_time&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">署名の時間。&lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_time&quot;&gt; &lt;code&gt;git_time&lt;/code&gt; &lt;/a&gt;構造体に一致します。</target>
        </trans-unit>
        <trans-unit id="a1aef662800be3b19d04a84bdbd802cb869572bc" translate="yes" xml:space="preserve">
          <source>TimeType-Period Arithmetic</source>
          <target state="translated">時間型周期演算</target>
        </trans-unit>
        <trans-unit id="9d9cec22f36fd2bb99d5fe8c4723347bec202ca5" translate="yes" xml:space="preserve">
          <source>Timer</source>
          <target state="translated">Timer</target>
        </trans-unit>
        <trans-unit id="e524304a680bc45ab65762e1df41198ad5434553" translate="yes" xml:space="preserve">
          <source>Timer()</source>
          <target state="translated">Timer()</target>
        </trans-unit>
        <trans-unit id="4e252bb0e117c9cedaeca8da5f4796af646d44a9" translate="yes" xml:space="preserve">
          <source>Timing results:</source>
          <target state="translated">タイミングの結果。</target>
        </trans-unit>
        <trans-unit id="d19ceca501465c339e3bcf2bc0d8ff02bb697d6c" translate="yes" xml:space="preserve">
          <source>Tip</source>
          <target state="translated">Tip</target>
        </trans-unit>
        <trans-unit id="0d5993668385f8eefae208c8f706f8bc977fc760" translate="yes" xml:space="preserve">
          <source>Tired Face</source>
          <target state="translated">疲れた顔</target>
        </trans-unit>
        <trans-unit id="d8411edb15bb7d4ab010f7414d30f893e168d44a" translate="yes" xml:space="preserve">
          <source>To access the raw code units (bytes for UTF-8) of the encoding, you can use the &lt;a href=&quot;../../base/strings/index#Base.codeunit&quot;&gt;&lt;code&gt;codeunit(s,i)&lt;/code&gt;&lt;/a&gt; function, where the index &lt;code&gt;i&lt;/code&gt; runs consecutively from &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;ncodeunits(s)&lt;/code&gt;. The &lt;a href=&quot;../../base/strings/index#Base.codeunits&quot;&gt;&lt;code&gt;codeunits(s)&lt;/code&gt;&lt;/a&gt; function returns an &lt;code&gt;AbstractVector{UInt8}&lt;/code&gt; wrapper that lets you access these raw codeunits (bytes) as an array.</source>
          <target state="translated">エンコーディングの生のコード単位（UTF-8のバイト）にアクセスするには、&lt;a href=&quot;../../base/strings/index#Base.codeunit&quot;&gt; &lt;code&gt;codeunit(s,i)&lt;/code&gt; &lt;/a&gt;関数を使用できます。ここで、インデックス &lt;code&gt;i&lt;/code&gt; は &lt;code&gt;1&lt;/code&gt; から &lt;code&gt;ncodeunits(s)&lt;/code&gt; まで連続して実行されます。&lt;a href=&quot;../../base/strings/index#Base.codeunits&quot;&gt; &lt;code&gt;codeunits(s)&lt;/code&gt; &lt;/a&gt;関数が返す &lt;code&gt;AbstractVector{UInt8}&lt;/code&gt; あなたが配列として、これらの生codeunits（バイト）にアクセスできラッパー。</target>
        </trans-unit>
        <trans-unit id="e95b1141b5118da7c6df142a7dc74b9f038403fe" translate="yes" xml:space="preserve">
          <source>To add a package, use &lt;code&gt;add&lt;/code&gt;:</source>
          <target state="translated">パッケージを追加するには、 &lt;code&gt;add&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="fca3c84bc7bcf6dfd1b3203ec788903367443803" translate="yes" xml:space="preserve">
          <source>To address these scenarios, Julia provides &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;s (also known by several other names, such as symmetric coroutines, lightweight threads, cooperative multitasking, or one-shot continuations). When a piece of computing work (in practice, executing a particular function) is designated as a &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;, it becomes possible to interrupt it by switching to another &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;. The original &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; can later be resumed, at which point it will pick up right where it left off. At first, this may seem similar to a function call. However there are two key differences. First, switching tasks does not use any space, so any number of task switches can occur without consuming the call stack. Second, switching among tasks can occur in any order, unlike function calls, where the called function must finish executing before control returns to the calling function.</source>
          <target state="translated">これらのシナリオに対処するために、Juliaは&lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt;提供します（対称コルーチン、軽量スレッド、協調マルチタスク、またはワンショット継続など、他のいくつかの名前でも知られています）。コンピューティング作業（実際には特定の機能の実行）が&lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt;として指定されている場合、別の&lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt;切り替えることでその作業を中断することが可能になります。元の&lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt;後で再開できます。その時点で、中断したところから再開します。最初は、これは関数呼び出しに似ているように見えるかもしれません。ただし、2つの重要な違いがあります。まず、タスクの切り替えはスペースを使用しないため、コールスタックを消費せずにタスクの切り替えをいくつでも実行できます。第2に、タスク間の切り替えは、制御が呼び出し元の関数に戻る前に呼び出された関数の実行を終了する必要がある関数呼び出しとは異なり、任意の順序で発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="80d353ae44a58cccba974a5708143d72c88b86a0" translate="yes" xml:space="preserve">
          <source>To allow computations with arbitrary-precision integers and floating point numbers, Julia wraps the &lt;a href=&quot;https://gmplib.org&quot;&gt;GNU Multiple Precision Arithmetic Library (GMP)&lt;/a&gt; and the &lt;a href=&quot;https://www.mpfr.org&quot;&gt;GNU MPFR Library&lt;/a&gt;, respectively. The &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/numbers/index#Base.MPFR.BigFloat&quot;&gt;&lt;code&gt;BigFloat&lt;/code&gt;&lt;/a&gt; types are available in Julia for arbitrary precision integer and floating point numbers respectively.</source>
          <target state="translated">Juliaは、任意精度の整数と浮動小数点数を使用した計算を可能にするために、それぞれ&lt;a href=&quot;https://gmplib.org&quot;&gt;GNU多重精度演算ライブラリ（GMP）&lt;/a&gt;と&lt;a href=&quot;https://www.mpfr.org&quot;&gt;GNU MPFRライブラリを&lt;/a&gt;ラップしています。&lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../../base/numbers/index#Base.MPFR.BigFloat&quot;&gt; &lt;code&gt;BigFloat&lt;/code&gt; &lt;/a&gt;タイプは、任意精度の整数それぞれ浮動小数点数のためにジュリアで利用可能です。</target>
        </trans-unit>
        <trans-unit id="f92958b0eb5e7d500f4fc83e966e176ae982e7c8" translate="yes" xml:space="preserve">
          <source>To allow for the creation of incompletely initialized objects, Julia allows the &lt;a href=&quot;../../base/base/index#new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; function to be called with fewer than the number of fields that the type has, returning an object with the unspecified fields uninitialized. The inner constructor method can then use the incomplete object, finishing its initialization before returning it. Here, for example, is another attempt at defining the &lt;code&gt;SelfReferential&lt;/code&gt; type, this time using a zero-argument inner constructor returning instances having &lt;code&gt;obj&lt;/code&gt; fields pointing to themselves:</source>
          <target state="translated">不完全に初期化されたオブジェクトの作成を可能にするために、Juliaは、タイプが持つフィールドの数より少ない数で&lt;a href=&quot;../../base/base/index#new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt;関数を呼び出すことができ、未指定のフィールドが初期化されていないオブジェクトを返します。次に、内部コンストラクターメソッドは不完全なオブジェクトを使用して、それを返す前に初期化を終了します。たとえば、ここでは、 &lt;code&gt;SelfReferential&lt;/code&gt; 型を定義する別の試みがあります。今回は、引数のない内部コンストラクタを使用して、 &lt;code&gt;obj&lt;/code&gt; フィールドが自分自身を指すインスタンスを返します。</target>
        </trans-unit>
        <trans-unit id="647cb570f3aba993aaa46d9c3e91117ed01a95c0" translate="yes" xml:space="preserve">
          <source>To amplify a bit further, consider the following function:</source>
          <target state="translated">もう少し増幅するには、次のような関数を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="7e940b0d75467f1279dc9099ee9a7a7226dd9aa5" translate="yes" xml:space="preserve">
          <source>To avoid even having to define a named function, you can use the &lt;code&gt;do&lt;/code&gt; syntax, which creates an anonymous function on the fly:</source>
          <target state="translated">名前付き関数を定義する必要がないようにするために、その場で無名関数を作成する &lt;code&gt;do&lt;/code&gt; 構文を使用できます。</target>
        </trans-unit>
        <trans-unit id="7511ec9a398ed68674d80480ecea6a9ca91ed0f1" translate="yes" xml:space="preserve">
          <source>To call &lt;a href=&quot;../parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../parallel/index#Base.notify&quot;&gt;&lt;code&gt;notify&lt;/code&gt;&lt;/a&gt; on a &lt;code&gt;Threads.Condition&lt;/code&gt;, you must first call &lt;a href=&quot;../parallel/index#Base.lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt; on it. When &lt;code&gt;wait&lt;/code&gt; is called, the lock is atomically released during blocking, and will be reacquired before &lt;code&gt;wait&lt;/code&gt; returns. Therefore idiomatic use of a &lt;code&gt;Threads.Condition&lt;/code&gt;&lt;code&gt;c&lt;/code&gt; looks like the following:</source>
          <target state="translated">&lt;code&gt;Threads.Condition&lt;/code&gt; で&lt;a href=&quot;../parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;../parallel/index#Base.notify&quot;&gt; &lt;code&gt;notify&lt;/code&gt; &lt;/a&gt;を呼び出すには、最初に&lt;a href=&quot;../parallel/index#Base.lock&quot;&gt; &lt;code&gt;lock&lt;/code&gt; &lt;/a&gt;を呼び出す必要があります。とき &lt;code&gt;wait&lt;/code&gt; と呼ばれ、ロックがアトミックブロック中に放出され、そして前に再取得される &lt;code&gt;wait&lt;/code&gt; 戻ります。したがって、 &lt;code&gt;Threads.Condition&lt;/code&gt; &lt;code&gt;c&lt;/code&gt; の慣用的な使用法は、次のようになります。</target>
        </trans-unit>
        <trans-unit id="50dc537d704eaca673949b4e42b6c53501bae68d" translate="yes" xml:space="preserve">
          <source>To check if a regex matches a string, use &lt;a href=&quot;../../base/strings/index#Base.occursin&quot;&gt;&lt;code&gt;occursin&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">正規表現が文字列と一致するかどうかを確認するには、&lt;a href=&quot;../../base/strings/index#Base.occursin&quot;&gt; &lt;code&gt;occursin&lt;/code&gt; &lt;/a&gt;使用します。</target>
        </trans-unit>
        <trans-unit id="eed84206f52f8f65140a28df43e2ff030f4f3a51" translate="yes" xml:space="preserve">
          <source>To concatenate in the first (&quot;vertical&quot;) dimension use either &lt;a href=&quot;../../base/arrays/index#Base.vcat&quot;&gt;&lt;code&gt;vcat(x,y,z)&lt;/code&gt;&lt;/a&gt; or separate with semicolons (&lt;code&gt;[x; y; z]&lt;/code&gt;).</source>
          <target state="translated">最初の（「垂直」）次元で連結するには、&lt;a href=&quot;../../base/arrays/index#Base.vcat&quot;&gt; &lt;code&gt;vcat(x,y,z)&lt;/code&gt; &lt;/a&gt;またはセミコロン（ &lt;code&gt;[x; y; z]&lt;/code&gt; ）で区切ります。</target>
        </trans-unit>
        <trans-unit id="836f5fac5628ace8eede45159f560aedbc2e431e" translate="yes" xml:space="preserve">
          <source>To concatenate in the second (&quot;horizontal&quot;) dimension use either &lt;a href=&quot;../../base/arrays/index#Base.hcat&quot;&gt;&lt;code&gt;hcat(x,y,z)&lt;/code&gt;&lt;/a&gt; or separate with spaces (&lt;code&gt;[x y z]&lt;/code&gt;).</source>
          <target state="translated">2番目（「水平」）の次元で連結するには、&lt;a href=&quot;../../base/arrays/index#Base.hcat&quot;&gt; &lt;code&gt;hcat(x,y,z)&lt;/code&gt; &lt;/a&gt;またはスペースで区切る（ &lt;code&gt;[x y z]&lt;/code&gt; ）のいずれかを使用します。</target>
        </trans-unit>
        <trans-unit id="c1db2888c6f2a52fec0ea3a56df9e7e662b6768f" translate="yes" xml:space="preserve">
          <source>To construct block matrices (concatenating in the first two dimensions), use either &lt;a href=&quot;../../base/arrays/index#Base.hvcat&quot;&gt;&lt;code&gt;hvcat&lt;/code&gt;&lt;/a&gt; or combine spaces and semicolons (&lt;code&gt;[a b; c d]&lt;/code&gt;).</source>
          <target state="translated">ブロックマトリックス（最初の2次元で連結）を作成するには、&lt;a href=&quot;../../base/arrays/index#Base.hvcat&quot;&gt; &lt;code&gt;hvcat&lt;/code&gt; を&lt;/a&gt;使用するか、スペースとセミコロンを組み合わせます（ &lt;code&gt;[a b; c d]&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="c9dbf08e7476ec37f2720092790ffb3b8fd03ca2" translate="yes" xml:space="preserve">
          <source>To customize how instances of a type are displayed, overload &lt;a href=&quot;#Base.show-Tuple%7BIO,Any%7D&quot;&gt;&lt;code&gt;show&lt;/code&gt;&lt;/a&gt; rather than &lt;code&gt;display&lt;/code&gt;, as explained in the manual section on &lt;a href=&quot;../../manual/types/index#man-custom-pretty-printing&quot;&gt;custom pretty-printing&lt;/a&gt;.</source>
          <target state="translated">型のインスタンスの表示方法をカスタマイズするには、過負荷&lt;a href=&quot;#Base.show-Tuple%7BIO,Any%7D&quot;&gt; &lt;code&gt;show&lt;/code&gt; &lt;/a&gt;ではなく、 &lt;code&gt;display&lt;/code&gt; 上のマニュアルのセクションで説明したように、&lt;a href=&quot;../../manual/types/index#man-custom-pretty-printing&quot;&gt;カスタムプリティプリント&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="99653d877bbee5b290b6ca0e94590ab093ad658f" translate="yes" xml:space="preserve">
          <source>To customize human-readable text output for objects of type &lt;code&gt;T&lt;/code&gt;, define &lt;code&gt;show(io::IO, ::MIME&quot;text/plain&quot;, ::T)&lt;/code&gt; instead. Checking the &lt;code&gt;:compact&lt;/code&gt;&lt;a href=&quot;#Base.IOContext&quot;&gt;&lt;code&gt;IOContext&lt;/code&gt;&lt;/a&gt; property of &lt;code&gt;io&lt;/code&gt; in such methods is recommended, since some containers show their elements by calling this method with &lt;code&gt;:compact =&amp;gt; true&lt;/code&gt;.</source>
          <target state="translated">タイプ &lt;code&gt;T&lt;/code&gt; のオブジェクトの人間が読めるテキスト出力をカスタマイズするに &lt;code&gt;show(io::IO, ::MIME&quot;text/plain&quot;, ::T)&lt;/code&gt; 代わりにshow（io :: IO、:: MIME &quot;text / plain&quot;、:: T）を定義します。一部のコンテナは &lt;code&gt;:compact =&amp;gt; true&lt;/code&gt; このメソッドを呼び出すことで要素を表示するため、このようなメソッドで &lt;code&gt;io&lt;/code&gt; の &lt;code&gt;:compact&lt;/code&gt; &lt;a href=&quot;#Base.IOContext&quot;&gt; &lt;code&gt;IOContext&lt;/code&gt; &lt;/a&gt;プロパティを確認することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="a141c1fb8d334654feff124c660c2fb4df2cb73d" translate="yes" xml:space="preserve">
          <source>To define a function with multiple methods, one simply defines the function multiple times, with different numbers and types of arguments. The first method definition for a function creates the function object, and subsequent method definitions add new methods to the existing function object. The most specific method definition matching the number and types of the arguments will be executed when the function is applied. Thus, the two method definitions above, taken together, define the behavior for &lt;code&gt;f&lt;/code&gt; over all pairs of instances of the abstract type &lt;code&gt;Number&lt;/code&gt; &amp;ndash; but with a different behavior specific to pairs of &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; values. If one of the arguments is a 64-bit float but the other one is not, then the &lt;code&gt;f(Float64,Float64)&lt;/code&gt; method cannot be called and the more general &lt;code&gt;f(Number,Number)&lt;/code&gt; method must be used:</source>
          <target state="translated">複数のメソッドを使用して関数を定義するには、引数の数とタイプを変えて、関数を複数回定義するだけです。関数の最初のメソッド定義は関数オブジェクトを作成し、後続のメソッド定義は既存の関数オブジェクトに新しいメソッドを追加します。引数の数とタイプに一致する最も具体的なメソッド定義は、関数が適用されるときに実行されます。したがって、上記の2つのメソッド定義は、まとめて、抽象型 &lt;code&gt;Number&lt;/code&gt; のインスタンスのすべてのペアに対する &lt;code&gt;f&lt;/code&gt; の動作を定義しますが、&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;値のペアに固有の異なる動作を持ちます。引数の1つが64ビットの浮動小数点数で、もう1つの引数がそうでない場合、 &lt;code&gt;f(Float64,Float64)&lt;/code&gt; メソッドを呼び出すことはできず、より一般的な &lt;code&gt;f(Number,Number)&lt;/code&gt; メソッドを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="021f78e4d9ed5f18a45c45e25c0e08e2b86fc477" translate="yes" xml:space="preserve">
          <source>To define a new &lt;code&gt;rand&lt;/code&gt; method for an hypothetical &lt;code&gt;MyRNG&lt;/code&gt; generator, and a value specification &lt;code&gt;s&lt;/code&gt; (e.g. &lt;code&gt;s == Int&lt;/code&gt;, or &lt;code&gt;s == 1:10&lt;/code&gt;) of type &lt;code&gt;S==typeof(s)&lt;/code&gt; or &lt;code&gt;S==Type{s}&lt;/code&gt; if &lt;code&gt;s&lt;/code&gt; is a type, the same two methods as we saw before must be defined:</source>
          <target state="translated">新しい定義する &lt;code&gt;rand&lt;/code&gt; 仮定のための方法を &lt;code&gt;MyRNG&lt;/code&gt; ジェネレータ、および値の指定 &lt;code&gt;s&lt;/code&gt; （例えば &lt;code&gt;s == Int&lt;/code&gt; 、または &lt;code&gt;s == 1:10&lt;/code&gt; タイプの） &lt;code&gt;S==typeof(s)&lt;/code&gt; 又は &lt;code&gt;S==Type{s}&lt;/code&gt; もし &lt;code&gt;s&lt;/code&gt; は型です。前に見たのと同じ2つのメソッドを定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="3e9f8911771a0e2e2a0a5444620f45dabaeaf75f" translate="yes" xml:space="preserve">
          <source>To demonstrate these issues, let us consider writing a &lt;code&gt;@time&lt;/code&gt; macro that takes an expression as its argument, records the time, evaluates the expression, records the time again, prints the difference between the before and after times, and then has the value of the expression as its final value. The macro might look like this:</source>
          <target state="translated">これらの問題を示すために、私たちが書いて考えてみましょう &lt;code&gt;@time&lt;/code&gt; の、その引数として式を必要な時間を記録し、式を評価し、再び時間を記録し、時間の前と後の違いを出力し、その後の値を持つマクロを最終値としての式。マクロは次のようになります。</target>
        </trans-unit>
        <trans-unit id="1e958f0a47bef2b5712e58abc88f1cd0cfc60a1f" translate="yes" xml:space="preserve">
          <source>To demonstrate, we might rewrite the &lt;code&gt;@time&lt;/code&gt; example above as:</source>
          <target state="translated">例として、上記の &lt;code&gt;@time&lt;/code&gt; の例を次のように書き換えます。</target>
        </trans-unit>
        <trans-unit id="e21d833954293a006de2f75f7b9609e75185bac1" translate="yes" xml:space="preserve">
          <source>To determine when a file was modified, compare &lt;code&gt;current isa StatStruct &amp;amp;&amp;amp; mtime(prev) != mtime(current)&lt;/code&gt; to detect notification of changes. However, using &lt;a href=&quot;#FileWatching.watch_file&quot;&gt;&lt;code&gt;watch_file&lt;/code&gt;&lt;/a&gt; for this operation is preferred, since it is more reliable and efficient, although in some situations it may not be available.</source>
          <target state="translated">ファイルがいつ変更されたかを判断するには、 &lt;code&gt;current isa StatStruct &amp;amp;&amp;amp; mtime(prev) != mtime(current)&lt;/code&gt; を比較して、変更の通知を検出します。ただし、この操作には&lt;a href=&quot;#FileWatching.watch_file&quot;&gt; &lt;code&gt;watch_file&lt;/code&gt; &lt;/a&gt;を使用することをお勧めします。状況によっては使用できない場合もありますが、より信頼性が高く効率的です。</target>
        </trans-unit>
        <trans-unit id="8be4728a2375d8712deda132de2e0a083b597cad" translate="yes" xml:space="preserve">
          <source>To determine whether an item is not in a given collection, see &lt;a href=&quot;#Base.:%E2%88%89&quot;&gt;&lt;code&gt;:&amp;notin;&lt;/code&gt;&lt;/a&gt;. You may also negate the &lt;code&gt;in&lt;/code&gt; by doing &lt;code&gt;!(a in b)&lt;/code&gt; which is logically similar to &quot;not in&quot;.</source>
          <target state="translated">アイテムが特定のコレクションに含まれていないかどうかを確認するには、&lt;a href=&quot;#Base.:%E2%88%89&quot;&gt; &lt;code&gt;:&amp;notin;&lt;/code&gt; を&lt;/a&gt;参照してください。「notin 」と論理的に類似している &lt;code&gt;!(a in b)&lt;/code&gt; を実行して、 &lt;code&gt;in&lt;/code&gt; を無効にすることもできます。</target>
        </trans-unit>
        <trans-unit id="f95f5439d369c4ea0678d04f0efd9b2968e81782" translate="yes" xml:space="preserve">
          <source>To enable convenient vectorization of mathematical and other operations, Julia &lt;a href=&quot;../functions/index#man-vectorized&quot;&gt;provides the dot syntax&lt;/a&gt;&lt;code&gt;f.(args...)&lt;/code&gt;, e.g. &lt;code&gt;sin.(x)&lt;/code&gt; or &lt;code&gt;min.(x,y)&lt;/code&gt;, for elementwise operations over arrays or mixtures of arrays and scalars (a &lt;a href=&quot;#Broadcasting&quot;&gt;Broadcasting&lt;/a&gt; operation); these have the additional advantage of &quot;fusing&quot; into a single loop when combined with other dot calls, e.g. &lt;code&gt;sin.(cos.(x))&lt;/code&gt;.</source>
          <target state="translated">数学演算やその他の演算の便利なベクトル化を可能にするために、Julia&lt;a href=&quot;../functions/index#man-vectorized&quot;&gt;は、&lt;/a&gt;配列または配列とスカラーの混合に対する要素ごとの演算用に、ドット構文 &lt;code&gt;f.(args...)&lt;/code&gt; 、たとえば &lt;code&gt;sin.(x)&lt;/code&gt; または &lt;code&gt;min.(x,y)&lt;/code&gt; を提供します。 （&lt;a href=&quot;#Broadcasting&quot;&gt;放送&lt;/a&gt;操作）; これらには、 &lt;code&gt;sin.(cos.(x))&lt;/code&gt; などの他のドット呼び出しと組み合わせると、単一のループに「融合」するという追加の利点があります。</target>
        </trans-unit>
        <trans-unit id="aeb1602cac2df929c4186b626049a5c2b1947830" translate="yes" xml:space="preserve">
          <source>To enable convenient vectorization of mathematical and other operations, Julia &lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;provides the dot syntax&lt;/a&gt;&lt;code&gt;f.(args...)&lt;/code&gt;, e.g. &lt;code&gt;sin.(x)&lt;/code&gt; or &lt;code&gt;min.(x,y)&lt;/code&gt;, for elementwise operations over arrays or mixtures of arrays and scalars (a &lt;a href=&quot;#Broadcasting-1&quot;&gt;Broadcasting&lt;/a&gt; operation); these have the additional advantage of &quot;fusing&quot; into a single loop when combined with other dot calls, e.g. &lt;code&gt;sin.(cos.(x))&lt;/code&gt;.</source>
          <target state="translated">数学的演算やその他の演算の便利なベクトル化を可能にするために、Julia &lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;は、&lt;/a&gt;配列または配列とスカラーの混合に対する要素ごとの演算のために、ドット構文 &lt;code&gt;f.(args...)&lt;/code&gt; 、たとえば &lt;code&gt;sin.(x)&lt;/code&gt; または &lt;code&gt;min.(x,y)&lt;/code&gt; を提供します（&lt;a href=&quot;#Broadcasting-1&quot;&gt;放送&lt;/a&gt;事業）; これらには、 &lt;code&gt;sin.(cos.(x))&lt;/code&gt; などの他のドット呼び出しと組み合わせると、単一のループに「融合」するという追加の利点があります。</target>
        </trans-unit>
        <trans-unit id="4881f7b56909ffe39aad882ec50ca3bf70065833" translate="yes" xml:space="preserve">
          <source>To end this short exposure to external packages, we can consider &lt;code&gt;MPI.jl&lt;/code&gt;, a Julia wrapper of the MPI protocol. As it would take too long to consider every inner function, it would be better to simply appreciate the approach used to implement the protocol.</source>
          <target state="translated">この外部パッケージへの短い露出を終わらせるために、MPIプロトコルのJuliaラッパーである &lt;code&gt;MPI.jl&lt;/code&gt; を検討できます。すべての内部関数を検討するには時間がかかりすぎるので、プロトコルの実装に使用されるアプローチを単純に評価することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="c43fc002027f4db455fa1bdf710dfb8409261bff" translate="yes" xml:space="preserve">
          <source>To ensure that the file can be opened at the given line, you may need to call &lt;code&gt;define_editor&lt;/code&gt; first.</source>
          <target state="translated">指定された行でファイルを開くことができるようにするには、最初に &lt;code&gt;define_editor&lt;/code&gt; を呼び出す必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="489d97da9ae4b28c1ee31bbdf2fe4066c4d9aee9" translate="yes" xml:space="preserve">
          <source>To evaluate expressions written in a source file &lt;code&gt;file.jl&lt;/code&gt;, write &lt;code&gt;include(&quot;file.jl&quot;)&lt;/code&gt;.</source>
          <target state="translated">ソースファイル &lt;code&gt;file.jl&lt;/code&gt; に記述された式を評価するには、 &lt;code&gt;include(&quot;file.jl&quot;)&lt;/code&gt; と記述します。</target>
        </trans-unit>
        <trans-unit id="962778343f824ab64f6e67f07132dd6412ec3b62" translate="yes" xml:space="preserve">
          <source>To exit the interactive session, type &lt;code&gt;CTRL-D&lt;/code&gt; (press the Control/&lt;code&gt;^&lt;/code&gt; key together with the &lt;code&gt;d&lt;/code&gt; key), or type &lt;code&gt;exit()&lt;/code&gt;. When run in interactive mode, &lt;code&gt;julia&lt;/code&gt; displays a banner and prompts the user for input. Once the user has entered a complete expression, such as &lt;code&gt;1 + 2&lt;/code&gt;, and hits enter, the interactive session evaluates the expression and shows its value. If an expression is entered into an interactive session with a trailing semicolon, its value is not shown. The variable &lt;code&gt;ans&lt;/code&gt; is bound to the value of the last evaluated expression whether it is shown or not. The &lt;code&gt;ans&lt;/code&gt; variable is only bound in interactive sessions, not when Julia code is run in other ways.</source>
          <target state="translated">インタラクティブセッションを終了するには、 &lt;code&gt;CTRL-D&lt;/code&gt; （Control / &lt;code&gt;^&lt;/code&gt; キーと &lt;code&gt;d&lt;/code&gt; キーを同時に押す）を入力するか、 &lt;code&gt;exit()&lt;/code&gt; を入力します。対話モードで実行すると、 &lt;code&gt;julia&lt;/code&gt; はバナーを表示し、ユーザーに入力を求めます。ユーザーが &lt;code&gt;1 + 2&lt;/code&gt; などの完全な式を入力し、Enter キーを押すと、インタラクティブセッションが式を評価し、その値を表示します。後続のセミコロンを使用して式がインタラクティブセッションに入力された場合、その値は表示されません。変数 &lt;code&gt;ans&lt;/code&gt; は、表示されるかどうかに関係なく、最後に評価された式の値にバインドされます。 &lt;code&gt;ans&lt;/code&gt; 変数は、Juliaコードが他の方法で実行されたときではなく、インタラクティブセッションでのみバインドされます。</target>
        </trans-unit>
        <trans-unit id="efa7a75658fed01212612bb6890412e7df41c343" translate="yes" xml:space="preserve">
          <source>To exit the interactive session, type &lt;code&gt;^D&lt;/code&gt; &amp;ndash; the control key together with the &lt;code&gt;d&lt;/code&gt; key on a blank line &amp;ndash; or type &lt;code&gt;exit()&lt;/code&gt; followed by the return or enter key. The REPL greets you with a banner and a &lt;code&gt;julia&amp;gt;&lt;/code&gt; prompt.</source>
          <target state="translated">インタラクティブセッションを終了するには、 &lt;code&gt;^D&lt;/code&gt; &lt;code&gt;exit()&lt;/code&gt; 空行で &lt;code&gt;d&lt;/code&gt; キーと一緒にコントロールキー）を入力するか、exit（）に続けてReturnキーまたはEnterキーを押します。REPLは、バナーと &lt;code&gt;julia&amp;gt;&lt;/code&gt; プロンプトで挨拶します。</target>
        </trans-unit>
        <trans-unit id="112540091595511d77b03fc13bb20dcaf3704da2" translate="yes" xml:space="preserve">
          <source>To extend &lt;code&gt;round&lt;/code&gt; to new numeric types, it is typically sufficient to define &lt;code&gt;Base.round(x::NewType, r::RoundingMode)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;round&lt;/code&gt; を新しい数値型に拡張するには、通常、 &lt;code&gt;Base.round(x::NewType, r::RoundingMode)&lt;/code&gt; を定義するだけで十分です。</target>
        </trans-unit>
        <trans-unit id="195ad355d3d21e9f09e35cca5f9f687ede9688d3" translate="yes" xml:space="preserve">
          <source>To facilitate chaining, the operator associates from right to left.</source>
          <target state="translated">連鎖を容易にするために、オペレータは右から左へと連想します。</target>
        </trans-unit>
        <trans-unit id="0b86b2585faadb1e7b87fb8f83afa86601547bb7" translate="yes" xml:space="preserve">
          <source>To facilitate using many different implementations of the same concept smoothly, functions need not be defined all at once, but can rather be defined piecewise by providing specific behaviors for certain combinations of argument types and counts. A definition of one possible behavior for a function is called a &lt;em&gt;method&lt;/em&gt;. Thus far, we have presented only examples of functions defined with a single method, applicable to all types of arguments. However, the signatures of method definitions can be annotated to indicate the types of arguments in addition to their number, and more than a single method definition may be provided. When a function is applied to a particular tuple of arguments, the most specific method applicable to those arguments is applied. Thus, the overall behavior of a function is a patchwork of the behaviors of its various method definitions. If the patchwork is well designed, even though the implementations of the methods may be quite different, the outward behavior of the function will appear seamless and consistent.</source>
          <target state="translated">同じ概念の多くの異なる実装を円滑に使用するために、関数を一度に定義する必要はありませんが、引数の型とカウントの特定の組み合わせに特定の動作を提供することにより、関数を区分的に定義できます。関数の1つの可能な動作の定義は&lt;em&gt;メソッド&lt;/em&gt;と呼ばれます&lt;em&gt;&lt;/em&gt;。これまで、すべてのタイプの引数に適用できる、単一のメソッドで定義された関数の例のみを示してきました。ただし、メソッド定義のシグネチャに注釈を付けて、引数の数に加えて引数のタイプを示すことができます。また、複数のメソッド定義を提供できます。関数が引数の特定のタプルに適用されると、それらの引数に適用できる最も具体的なメソッドが適用されます。したがって、関数の全体的な動作は、さまざまなメソッド定義の動作のパッチワークです。パッチワークが適切に設計されている場合、メソッドの実装がまったく異なる場合でも、関数の外見上の動作はシームレスで一貫性があるように見えます。</target>
        </trans-unit>
        <trans-unit id="685da3713fd32cec996f6d8bc31bd51d482869ca" translate="yes" xml:space="preserve">
          <source>To get your TTY size,</source>
          <target state="translated">TTYサイズを取得するには</target>
        </trans-unit>
        <trans-unit id="18e5dfa5bee5af4e19ea61c8f359c20a393fe69f" translate="yes" xml:space="preserve">
          <source>To give a real-world example of how all this parametric type machinery can be useful, here is the actual definition of Julia's &lt;a href=&quot;../../base/numbers/index#Base.Rational&quot;&gt;&lt;code&gt;Rational&lt;/code&gt;&lt;/a&gt; immutable type (except that we omit the constructor here for simplicity), representing an exact ratio of integers:</source>
          <target state="translated">このすべてのパラメトリックタイプの仕組みがどのように役立つかを示す実例を示すために、Juliaの&lt;a href=&quot;../../base/numbers/index#Base.Rational&quot;&gt; &lt;code&gt;Rational&lt;/code&gt; &lt;/a&gt;不変タイプの実際の定義を示します（単純にするためにここではコンストラクターを省略しています）。これは整数の正確な比率を表しています。</target>
        </trans-unit>
        <trans-unit id="75c2b4412f89f47fcb218ff2c8fc9993a26854fc" translate="yes" xml:space="preserve">
          <source>To implement this specialization for &lt;code&gt;MyRNG&lt;/code&gt; and for a specification &lt;code&gt;s&lt;/code&gt;, producing elements of type &lt;code&gt;S&lt;/code&gt;, the following method can be defined: &lt;code&gt;rand!(rng::MyRNG, a::AbstractArray{S}, ::SamplerS)&lt;/code&gt;, where &lt;code&gt;SamplerS&lt;/code&gt; is the type of the sampler returned by &lt;code&gt;Sampler(MyRNG, s, Val(Inf))&lt;/code&gt;. Instead of &lt;code&gt;AbstractArray&lt;/code&gt;, it's possible to implement the functionality only for a subtype, e.g. &lt;code&gt;Array{S}&lt;/code&gt;. The non-mutating array method of &lt;code&gt;rand&lt;/code&gt; will automatically call this specialization internally.</source>
          <target state="translated">&lt;code&gt;MyRNG&lt;/code&gt; と仕様 &lt;code&gt;s&lt;/code&gt; にこの特殊化を実装し、タイプ &lt;code&gt;S&lt;/code&gt; の要素を生成するには、次のメソッドを定義できます： &lt;code&gt;rand!(rng::MyRNG, a::AbstractArray{S}, ::SamplerS)&lt;/code&gt; 、ここで &lt;code&gt;SamplerS&lt;/code&gt; は &lt;code&gt;Sampler(MyRNG, s, Val(Inf))&lt;/code&gt; によって返されるサンプラーのタイプ。 &lt;code&gt;AbstractArray&lt;/code&gt; の代わりに、サブタイプ（例： &lt;code&gt;Array{S}&lt;/code&gt; に対してのみ機能を実装することが可能です。 &lt;code&gt;rand&lt;/code&gt; の非変更配列メソッドは、この特殊化を内部で自動的に呼び出します。</target>
        </trans-unit>
        <trans-unit id="5abb5f441f651501d418ed7d715b551afc8ae682" translate="yes" xml:space="preserve">
          <source>To include a backtick character within literal text use three backticks rather than one to enclose the text.</source>
          <target state="translated">リテラルテキスト内にバックティック文字を含めるには、テキストを囲むために1つのバックティックではなく3つのバックティックを使用します。</target>
        </trans-unit>
        <trans-unit id="57aafd915b8744c5b807fb8c566670246a4bbec8" translate="yes" xml:space="preserve">
          <source>To include a literal &lt;code&gt;$&lt;/code&gt; in a string literal, escape it with a backslash:</source>
          <target state="translated">文字列リテラルにリテラル &lt;code&gt;$&lt;/code&gt; を含めるには、バックスラッシュでエスケープします。</target>
        </trans-unit>
        <trans-unit id="911d758b9209b3d7402bd8133b67ca7a1ddf60e0" translate="yes" xml:space="preserve">
          <source>To indicate that the output result is truncated, you may write &lt;code&gt;[...]&lt;/code&gt; at the line where checking should stop. This is useful to hide a stacktrace (which contains non-permanent references to lines of julia code) when the doctest shows that an exception is thrown, for example:</source>
          <target state="translated">出力結果が切り捨てられていることを示すには、チェックを停止する行に &lt;code&gt;[...]&lt;/code&gt; と記述します。これは、doctestが例外がスローされたことを示している場合に、スタックトレース（Juliaコードの行への非永続的な参照を含む）を非表示にするのに役立ちます。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="bc826a295b20ebe4ca4b7027a22bd794fb5707c0" translate="yes" xml:space="preserve">
          <source>To insert &lt;code&gt;replacement&lt;/code&gt; before an index &lt;code&gt;n&lt;/code&gt; without removing any items, use &lt;code&gt;splice!(collection, n:n-1, replacement)&lt;/code&gt;.</source>
          <target state="translated">アイテムを削除せずにインデックス &lt;code&gt;n&lt;/code&gt; の前に &lt;code&gt;replacement&lt;/code&gt; を挿入するには、 &lt;code&gt;splice!(collection, n:n-1, replacement)&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="1254256d236772cc78d0a2e9b923db6bf919f9ea" translate="yes" xml:space="preserve">
          <source>To keep things simple, we start with a 1D array. Creating an array containing Float64 elements of length 10 is done by:</source>
          <target state="translated">物事をシンプルにするために、1 次元の配列から始めます。長さ10のFloat64要素を含む配列を作成するには、次のようにします。</target>
        </trans-unit>
        <trans-unit id="8199f62d4f59aa3fc75b15e0a259ff3e40e0a51d" translate="yes" xml:space="preserve">
          <source>To launch workers without blocking the REPL, or the containing function if launching workers programmatically, execute &lt;code&gt;addprocs&lt;/code&gt; in its own task.</source>
          <target state="translated">REPLをブロックせずにワーカーを起動するには、またはプログラムでワーカーを起動する場合はそれを含む関数を起動するには、独自のタスクで &lt;code&gt;addprocs&lt;/code&gt; を実行します。</target>
        </trans-unit>
        <trans-unit id="00ab4bffe8af922f0b9025c505c1b0b45cd720f2" translate="yes" xml:space="preserve">
          <source>To list all the instances of an enum use &lt;code&gt;instances&lt;/code&gt;, e.g.</source>
          <target state="translated">列挙型のすべてのインスタンスをリストするには、例を使用し &lt;code&gt;instances&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7c1bcc9adb11774306436860ba8fa8832de24b31" translate="yes" xml:space="preserve">
          <source>To load a module, two main keywords can be used: &lt;code&gt;using&lt;/code&gt; and &lt;code&gt;import&lt;/code&gt;. To understand their differences, consider the following example:</source>
          <target state="translated">モジュールをロードするには、 &lt;code&gt;using&lt;/code&gt; と &lt;code&gt;import&lt;/code&gt; の 2つの主要なキーワードを使用できます。それらの違いを理解するために、次の例を検討してください。</target>
        </trans-unit>
        <trans-unit id="1484daa3c86481c79c70bc5444871ebf78a284a7" translate="yes" xml:space="preserve">
          <source>To make common numeric formulae and expressions clearer, Julia allows variables to be immediately preceded by a numeric literal, implying multiplication. This makes writing polynomial expressions much cleaner:</source>
          <target state="translated">一般的な数値式や式をより明確にするために、Juliaでは変数の前に数値リテラルを付けることができ、乗算を暗示しています。これにより、多項式の記述がより簡単になりました。</target>
        </trans-unit>
        <trans-unit id="e9809512202b8f4f9e1d3eed9dff9a39e7fbe9d3" translate="yes" xml:space="preserve">
          <source>To make it easier to write documentation, the parser treats the macro name &lt;code&gt;@doc&lt;/code&gt; specially: if a call to &lt;code&gt;@doc&lt;/code&gt; has one argument, but another expression appears after a single line break, then that additional expression is added as an argument to the macro. Therefore the following syntax is parsed as a 2-argument call to &lt;code&gt;@doc&lt;/code&gt;:</source>
          <target state="translated">ドキュメントを簡単に記述できるように、パーサーはマクロ名 &lt;code&gt;@doc&lt;/code&gt; を特別に扱います。 &lt;code&gt;@doc&lt;/code&gt; への呼び出しに引数が1つあるが、1つの改行の後に別の式が現れる場合、その追加の式が引数としてマクロに追加されます。 。したがって、次の構文は &lt;code&gt;@doc&lt;/code&gt; への2つの引数の呼び出しとして解析されます。</target>
        </trans-unit>
        <trans-unit id="83af23997915ae15ff2f3b65db53b150559fdcfe" translate="yes" xml:space="preserve">
          <source>To make things easier, the symbol &lt;code&gt;:any&lt;/code&gt; can be passed to [&lt;code&gt;@spawnat&lt;/code&gt;], which picks where to do the operation for you:</source>
          <target state="translated">作業を簡単にするために、記号 &lt;code&gt;:any&lt;/code&gt; を[ &lt;code&gt;@spawnat&lt;/code&gt; ]に渡すことができます。これにより、操作を実行する場所が選択されます。</target>
        </trans-unit>
        <trans-unit id="7f47e315ab3527a05dae0afbff5487e713054912" translate="yes" xml:space="preserve">
          <source>To measure allocation line-by-line, start Julia with the &lt;code&gt;--track-allocation=&amp;lt;setting&amp;gt;&lt;/code&gt; command-line option, for which you can choose &lt;code&gt;none&lt;/code&gt; (the default, do not measure allocation), &lt;code&gt;user&lt;/code&gt; (measure memory allocation everywhere except Julia's core code), or &lt;code&gt;all&lt;/code&gt; (measure memory allocation at each line of Julia code). Allocation gets measured for each line of compiled code. When you quit Julia, the cumulative results are written to text files with &lt;code&gt;.mem&lt;/code&gt; appended after the file name, residing in the same directory as the source file. Each line lists the total number of bytes allocated. The &lt;a href=&quot;https://github.com/JuliaCI/Coverage.jl&quot;&gt;&lt;code&gt;Coverage&lt;/code&gt; package&lt;/a&gt; contains some elementary analysis tools, for example to sort the lines in order of number of bytes allocated.</source>
          <target state="translated">行 &lt;code&gt;--track-allocation=&amp;lt;setting&amp;gt;&lt;/code&gt; を測定するには、-track-allocation = &amp;lt;setting&amp;gt;コマンドラインオプションを使用してJuliaを起動します。このオプションでは、 &lt;code&gt;none&lt;/code&gt; （デフォルト、割り当てを測定しない）、 &lt;code&gt;user&lt;/code&gt; （を除くすべての場所でメモリ割り当てを測定できます）ジュリアのコアコード）、または &lt;code&gt;all&lt;/code&gt; （ジュリアコードの各行でメモリ割り当てを測定）。割り当ては、コンパイルされたコードの各行に対して測定されます。 Juliaを終了すると、累積結果は、ソースファイルと同じディレクトリにあるファイル名の後に &lt;code&gt;.mem&lt;/code&gt; が追加されたテキストファイルに書き込まれます。各行には、割り当てられた合計バイト数が表示されます。&lt;a href=&quot;https://github.com/JuliaCI/Coverage.jl&quot;&gt; &lt;code&gt;Coverage&lt;/code&gt; パッケージ&lt;/a&gt; いくつかの基本的な分析ツールが含まれています。たとえば、割り当てられたバイト数の順序で行をソートします。</target>
        </trans-unit>
        <trans-unit id="55a59a811688ae0a09c9c081d6eacd92c8c0ce25" translate="yes" xml:space="preserve">
          <source>To orchestrate more advanced work distribution patterns, &lt;a href=&quot;../../stdlib/sockets/index#Base.bind&quot;&gt;&lt;code&gt;bind&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/parallel/index#Base.schedule&quot;&gt;&lt;code&gt;schedule&lt;/code&gt;&lt;/a&gt; can be used in conjunction with &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; constructors to explicitly link a set of channels with a set of producer/consumer tasks.</source>
          <target state="translated">より高度な作業分散パターンを&lt;a href=&quot;../../base/parallel/index#Base.schedule&quot;&gt; &lt;code&gt;schedule&lt;/code&gt; &lt;/a&gt;するには、&lt;a href=&quot;../../stdlib/sockets/index#Base.bind&quot;&gt; &lt;code&gt;bind&lt;/code&gt; &lt;/a&gt;およびスケジュールを&lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt;コンストラクターと組み合わせて使用​​して、一連のチャネルを一連のプロデューサー/コンシューマータスクに明示的にリンクできます。</target>
        </trans-unit>
        <trans-unit id="88891fe439361664a726897679e596b4ddf0b648" translate="yes" xml:space="preserve">
          <source>To override these defaults, you can define a custom &lt;code&gt;BroadcastStyle&lt;/code&gt; for your object:</source>
          <target state="translated">これらのデフォルトをオーバーライドするには、オブジェクトのカスタム &lt;code&gt;BroadcastStyle&lt;/code&gt; を定義できます。</target>
        </trans-unit>
        <trans-unit id="8e77e7d4476c074003412309908eb0f580d2e357" translate="yes" xml:space="preserve">
          <source>To pass an array &lt;code&gt;A&lt;/code&gt; as a pointer of a different type &lt;em&gt;without&lt;/em&gt; converting the data beforehand (for example, to pass a &lt;code&gt;Float64&lt;/code&gt; array to a function that operates on uninterpreted bytes), you can declare the argument as &lt;code&gt;Ptr{Cvoid}&lt;/code&gt;.</source>
          <target state="translated">事前にデータ&lt;em&gt;を&lt;/em&gt;変換&lt;em&gt;せずに&lt;/em&gt;配列 &lt;code&gt;A&lt;/code&gt; を別の型のポインタとして渡すには（たとえば、 &lt;code&gt;Float64&lt;/code&gt; 配列を未解釈のバイトで動作する関数に渡す）、引数を &lt;code&gt;Ptr{Cvoid}&lt;/code&gt; として宣言できます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="37a6e640cde5e775ecaa007f5b2352c84dabd421" translate="yes" xml:space="preserve">
          <source>To provide extra type information to the compiler, which can then improve performance in some cases</source>
          <target state="translated">コンパイラに余分な型情報を提供することで、場合によってはパフォーマンスを向上させることができます。</target>
        </trans-unit>
        <trans-unit id="0378c13c470b1c82f603ba161f8d44139e199b76" translate="yes" xml:space="preserve">
          <source>To randomly permute an arbitrary vector, see &lt;a href=&quot;#Random.shuffle&quot;&gt;&lt;code&gt;shuffle&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Random.shuffle!&quot;&gt;&lt;code&gt;shuffle!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">任意のベクトルをランダムに並べ替えるには、&lt;a href=&quot;#Random.shuffle&quot;&gt; &lt;code&gt;shuffle&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;#Random.shuffle!&quot;&gt; &lt;code&gt;shuffle!&lt;/code&gt; &lt;/a&gt;参照してください。。</target>
        </trans-unit>
        <trans-unit id="41ee867278b2aedd0d53b55cf8896f331cca7dbe" translate="yes" xml:space="preserve">
          <source>To read every line from &lt;a href=&quot;../../base/io-network/index#Base.stdin&quot;&gt;&lt;code&gt;stdin&lt;/code&gt;&lt;/a&gt; you can use &lt;a href=&quot;../../base/io-network/index#Base.eachline&quot;&gt;&lt;code&gt;eachline&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;../../base/io-network/index#Base.stdin&quot;&gt; &lt;code&gt;stdin&lt;/code&gt; &lt;/a&gt;からすべての行を読み取るには、&lt;a href=&quot;../../base/io-network/index#Base.eachline&quot;&gt; &lt;code&gt;eachline&lt;/code&gt; &lt;/a&gt;を使用できます。</target>
        </trans-unit>
        <trans-unit id="b518f1536e23e8203566d1b1cfa014affb065edc" translate="yes" xml:space="preserve">
          <source>To recap, two essential properties define immutability in Julia:</source>
          <target state="translated">要約すると、ジュリアでは二つの本質的な特性が不変性を定義しています。</target>
        </trans-unit>
        <trans-unit id="3337fde1fe683c82cc86c991764b6058738e2732" translate="yes" xml:space="preserve">
          <source>To remove packages, use &lt;code&gt;rm&lt;/code&gt;:</source>
          <target state="translated">パッケージを削除するには、 &lt;code&gt;rm&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="14bc0723b7cb80976b33a13b7846798f89f200c9" translate="yes" xml:space="preserve">
          <source>To repeat, in general this is not an issue. If the local node is also being used as a compute node, and the arguments used post the call, this behavior needs to be factored in and if required deep copies of arguments must be passed to the call invoked on the local node. Calls on remote nodes will always operate on copies of arguments.</source>
          <target state="translated">繰り返しになりますが、一般的にはこれは問題ではありません。ローカルノードが計算ノードとしても使用されていて、呼び出し後に引数が使用されている場合、この動作を考慮する必要があります。リモートノードへの呼び出しは常に引数のコピーで動作します。</target>
        </trans-unit>
        <trans-unit id="0f95a56d7e12d8a1364b795c70b8b074db4e5914" translate="yes" xml:space="preserve">
          <source>To represent missing data in the statistical sense (&lt;code&gt;NA&lt;/code&gt; in R or &lt;code&gt;NULL&lt;/code&gt; in SQL), use the &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; object. See the &lt;a href=&quot;../missing/index#missing&quot;&gt;&lt;code&gt;Missing Values&lt;/code&gt;&lt;/a&gt; section for more details.</source>
          <target state="translated">欠測データを統計的な意味（Rでは &lt;code&gt;NA&lt;/code&gt; 、SQLでは &lt;code&gt;NULL&lt;/code&gt; ）で表すには、&lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt;オブジェクトを使用します。詳細については、「&lt;a href=&quot;../missing/index#missing&quot;&gt; &lt;code&gt;Missing Values&lt;/code&gt; &lt;/a&gt;セクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="aae4959b7ce22135d2a8a5e52c24ae41734ed81e" translate="yes" xml:space="preserve">
          <source>To represent missing data in the statistical sense (&lt;code&gt;NA&lt;/code&gt; in R or &lt;code&gt;NULL&lt;/code&gt; in SQL), use the &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; object. See the &lt;a href=&quot;../missing/index#missing-1&quot;&gt;&lt;code&gt;Missing Values&lt;/code&gt;&lt;/a&gt; section for more details.</source>
          <target state="translated">欠落しているデータを統計的な意味（Rでは &lt;code&gt;NA&lt;/code&gt; またはSQLでは &lt;code&gt;NULL&lt;/code&gt; ）で表すには、&lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt;オブジェクトを使用します。詳細については、&lt;a href=&quot;../missing/index#missing-1&quot;&gt; &lt;code&gt;Missing Values&lt;/code&gt; &lt;/a&gt;セクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="7a42a57073f63eda82c8f34e187355b8a55592f7" translate="yes" xml:space="preserve">
          <source>To return a new permutation, use &lt;code&gt;v[p]&lt;/code&gt;. Note that this is generally faster than &lt;code&gt;permute!(v,p)&lt;/code&gt; for large vectors.</source>
          <target state="translated">新しい順列を返すには、 &lt;code&gt;v[p]&lt;/code&gt; 使用します。これは通常、大きなベクトルの場合 &lt;code&gt;permute!(v,p)&lt;/code&gt; よりも高速であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="b43086127fab6b61eddd060c4ab1a5c67fe3f40b" translate="yes" xml:space="preserve">
          <source>To run code in a file non-interactively, you can give it as the first argument to the &lt;code&gt;julia&lt;/code&gt; command:</source>
          <target state="translated">ファイル内のコードを非対話的に実行するには、それを &lt;code&gt;julia&lt;/code&gt; コマンドの最初の引数として指定できます。</target>
        </trans-unit>
        <trans-unit id="31db79e8dfaa63f030f5e043edf7eb3288ba9c8b" translate="yes" xml:space="preserve">
          <source>To see the &lt;code&gt;UniformScaling&lt;/code&gt; operator in action:</source>
          <target state="translated">&lt;code&gt;UniformScaling&lt;/code&gt; オペレーターを確認するには：</target>
        </trans-unit>
        <trans-unit id="14eeb4620d461f92f19ad75b427c889e5f871fa2" translate="yes" xml:space="preserve">
          <source>To see the profiling results, there are several graphical browsers. One &quot;family&quot; of visualizers is based on &lt;a href=&quot;https://github.com/timholy/FlameGraphs.jl&quot;&gt;FlameGraphs.jl&lt;/a&gt;, with each family member providing a different user interface:</source>
          <target state="translated">プロファイリングの結果を確認するには、いくつかのグラフィカルブラウザがあります。ビジュアライザーの1つの「ファミリー」は、&lt;a href=&quot;https://github.com/timholy/FlameGraphs.jl&quot;&gt;FlameGraphs.jl&lt;/a&gt;に基づいており、各ファミリーメンバーが異なるユーザーインターフェイスを提供します。</target>
        </trans-unit>
        <trans-unit id="acf8c3f0dc9d9a3a4b278d4d342f1e20d2ccbfc2" translate="yes" xml:space="preserve">
          <source>To see the profiling results, there is a &lt;a href=&quot;https://github.com/timholy/ProfileView.jl&quot;&gt;graphical browser&lt;/a&gt; available, but here we'll use the text-based display that comes with the standard library:</source>
          <target state="translated">プロファイリング結果を確認するには、&lt;a href=&quot;https://github.com/timholy/ProfileView.jl&quot;&gt;グラフィカルブラウザーを&lt;/a&gt;使用できますが、ここでは標準ライブラリに付属しているテキストベースの表示を使用します。</target>
        </trans-unit>
        <trans-unit id="ec3664c20b57cfea56dfe265259865dc89ffd6ee" translate="yes" xml:space="preserve">
          <source>To see the various ways we can pass dimensions to these constructors, consider the following examples:</source>
          <target state="translated">これらのコンストラクタに次元を渡すさまざまな方法を見るために、以下の例を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="b562caf38673e98867f8d24249d28785455823ef" translate="yes" xml:space="preserve">
          <source>To see the various ways we can pass dimensions to these functions, consider the following examples:</source>
          <target state="translated">これらの関数に次元を渡す様々な方法を見るために、以下の例を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="dd84751a56be507d9887116a70caf40018058b32" translate="yes" xml:space="preserve">
          <source>To solve this problem, the language provides syntax for writing normal, non-generated alternative implementations of generated functions. Applied to the &lt;code&gt;sub2ind&lt;/code&gt; example above, it would look like this:</source>
          <target state="translated">この問題を解決するために、この言語は、生成された関数の生成されていない通常の代替実装を記述するための構文を提供します。上記の &lt;code&gt;sub2ind&lt;/code&gt; の例に適用すると、次のようになります。</target>
        </trans-unit>
        <trans-unit id="54282ab58b68c2496b0103219b8718109152a291" translate="yes" xml:space="preserve">
          <source>To sort an array in-place, use the &quot;bang&quot; version of the sort function:</source>
          <target state="translated">配列をその場でソートするには、ソート関数の「bang」バージョンを使用します。</target>
        </trans-unit>
        <trans-unit id="7211b367ac9e62dd165b6cef64e18a2d04d92c28" translate="yes" xml:space="preserve">
          <source>To sort slices of an array, refer to &lt;a href=&quot;#Base.sortslices&quot;&gt;&lt;code&gt;sortslices&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">配列のスライスをソートするには、&lt;a href=&quot;#Base.sortslices&quot;&gt; &lt;code&gt;sortslices&lt;/code&gt; を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="d6eff1f59edaf0f06ebb9ad646cdc71f40b39d99" translate="yes" xml:space="preserve">
          <source>To test whether an array element is defined, use &lt;a href=&quot;../arrays/index#Base.isassigned&quot;&gt;&lt;code&gt;isassigned&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">配列要素が定義されているかどうかをテストするには、代わりに&lt;a href=&quot;../arrays/index#Base.isassigned&quot;&gt; &lt;code&gt;isassigned&lt;/code&gt; &lt;/a&gt;を使用します。</target>
        </trans-unit>
        <trans-unit id="01c8720e122ebab6d2066fc725c6565609e09aa5" translate="yes" xml:space="preserve">
          <source>To those familiar with the Unix socket API, the method names will feel familiar, though their usage is somewhat simpler than the raw Unix socket API. The first call to &lt;code&gt;listen&lt;/code&gt; will create a server waiting for incoming connections on the specified port (2000) in this case. The same function may also be used to create various other kinds of servers:</source>
          <target state="translated">UnixソケットAPIに精通している人にとっては、メソッド名は親しみやすいものになりますが、その使用法は生のUnixソケットAPIよりもいくぶん簡単です。この場合、最初に &lt;code&gt;listen&lt;/code&gt; を呼び出すと、指定されたポート（2000）で着信接続を待機するサーバーが作成されます。同じ関数を使用して、他のさまざまな種類のサーバーを作成することもできます。</target>
        </trans-unit>
        <trans-unit id="86225ac570f468a04ae4083e4730243b1b54f060" translate="yes" xml:space="preserve">
          <source>To turn debug logging on from the REPL, set &lt;code&gt;ENV[&quot;JULIA_DEBUG&quot;]&lt;/code&gt; to the name of the module of interest. Functions defined in the REPL belong to module &lt;code&gt;Main&lt;/code&gt;; logging for them can be enabled like this:</source>
          <target state="translated">REPLからデバッグロギングをオンにするには、 &lt;code&gt;ENV[&quot;JULIA_DEBUG&quot;]&lt;/code&gt; を対象のモジュールの名前に設定します。REPLで定義された関数は、モジュール &lt;code&gt;Main&lt;/code&gt; に属します。それらのロギングは、次のように有効にできます。</target>
        </trans-unit>
        <trans-unit id="37782f88e79a30a638fe1c4b17869179913336be" translate="yes" xml:space="preserve">
          <source>To update all installed packages, use &lt;code&gt;update&lt;/code&gt; without any arguments:</source>
          <target state="translated">インストールされているすべてのパッケージを更新 &lt;code&gt;update&lt;/code&gt; には、引数なしでupdateを使用します。</target>
        </trans-unit>
        <trans-unit id="0f5d769d3a6a2a22d1c9a917d6ffd8d8e3ba2035" translate="yes" xml:space="preserve">
          <source>To use module functions, use &lt;code&gt;import Module&lt;/code&gt; to import the module, and &lt;code&gt;Module.fn(x)&lt;/code&gt; to use the functions.</source>
          <target state="translated">モジュール関数を使用するには、 &lt;code&gt;import Module&lt;/code&gt; を使用してモジュールをインポートし、 &lt;code&gt;Module.fn(x)&lt;/code&gt; を使用して関数を使用します。</target>
        </trans-unit>
        <trans-unit id="c9e2a6c247a0a520e69b509cc364e0a77e00dcc4" translate="yes" xml:space="preserve">
          <source>Together, these two methods generate an infinite recursion with &lt;code&gt;A&lt;/code&gt; constantly growing bigger.</source>
          <target state="translated">これら2つの方法を組み合わせると、 &lt;code&gt;A&lt;/code&gt; が常に大きくなるため、無限の再帰が発生します。</target>
        </trans-unit>
        <trans-unit id="0a527316e82cb18df4aebd0b111b71ab441d9fae" translate="yes" xml:space="preserve">
          <source>Toilet</source>
          <target state="translated">Toilet</target>
        </trans-unit>
        <trans-unit id="3068a31d1f4455b374321b9ea25711d164d193a2" translate="yes" xml:space="preserve">
          <source>Tokyo Tower</source>
          <target state="translated">東京タワー</target>
        </trans-unit>
        <trans-unit id="85cd2366c323520d4f6ca54daa5ce7108263ec82" translate="yes" xml:space="preserve">
          <source>Tomato</source>
          <target state="translated">Tomato</target>
        </trans-unit>
        <trans-unit id="2c0af9c54fe52a8117bb6a8ffd7c31c20e12b7e9" translate="yes" xml:space="preserve">
          <source>Tongue</source>
          <target state="translated">Tongue</target>
        </trans-unit>
        <trans-unit id="4fa8cc860c52b268dc6a3adcde7305e9415db5bb" translate="yes" xml:space="preserve">
          <source>Tools</source>
          <target state="translated">Tools</target>
        </trans-unit>
        <trans-unit id="a47d5ff7493944bba18ff7a622f259b12c79f21f" translate="yes" xml:space="preserve">
          <source>Tools for collecting and manipulating stack traces. Mainly used for building errors.</source>
          <target state="translated">スタックトレースを収集して操作するためのツール。主にエラーの構築に使用します。</target>
        </trans-unit>
        <trans-unit id="3e83cb174ec130f0f93f810a0b44e22e6201ed95" translate="yes" xml:space="preserve">
          <source>Top Curly Bracket</source>
          <target state="translated">トップカーリーブラケット</target>
        </trans-unit>
        <trans-unit id="f2d046811da3fdc34f49d7fc3a74c1883f787a1c" translate="yes" xml:space="preserve">
          <source>Top Hat</source>
          <target state="translated">トップハット</target>
        </trans-unit>
        <trans-unit id="fc078810ae21519f9debbccf082738a4563290fe" translate="yes" xml:space="preserve">
          <source>Top Left Corner</source>
          <target state="translated">左上コーナー</target>
        </trans-unit>
        <trans-unit id="c1653a7564996eb5d9b98bcaeb8e7f6800ad78ed" translate="yes" xml:space="preserve">
          <source>Top Right Corner</source>
          <target state="translated">右上コーナー</target>
        </trans-unit>
        <trans-unit id="0db2fdee55ffa3d8617249d91bb7c7e0a1fd08cd" translate="yes" xml:space="preserve">
          <source>Top Square Bracket</source>
          <target state="translated">トップスクエアブラケット</target>
        </trans-unit>
        <trans-unit id="feae3638873ff76a7d306f4a128884d7a27289e2" translate="yes" xml:space="preserve">
          <source>Top With Upwards Arrow Above</source>
          <target state="translated">上向きの矢印が付いているトップ</target>
        </trans-unit>
        <trans-unit id="7d0d5998569f1576a0f2ba8a5349d65f84435b8c" translate="yes" xml:space="preserve">
          <source>Toplevel elements</source>
          <target state="translated">トップレベル要素</target>
        </trans-unit>
        <trans-unit id="38c33375ac13545f89d5e835135e4a9e0cee1eb3" translate="yes" xml:space="preserve">
          <source>Tractor</source>
          <target state="translated">Tractor</target>
        </trans-unit>
        <trans-unit id="77b5fefa8d9a6d18651c91b1b665b4e10f4d869e" translate="yes" xml:space="preserve">
          <source>Trade Mark Sign / Trademark</source>
          <target state="translated">商標の印/商標</target>
        </trans-unit>
        <trans-unit id="425d15442171bfb5ea100947c75ec0ba9c146e2c" translate="yes" xml:space="preserve">
          <source>Trailing whitespace is left unaltered.</source>
          <target state="translated">後続の空白は変更されないままにしておきます。</target>
        </trans-unit>
        <trans-unit id="3b278ea9e74a042719a58f33d9cbb403be99f4ca" translate="yes" xml:space="preserve">
          <source>Train</source>
          <target state="translated">Train</target>
        </trans-unit>
        <trans-unit id="d912f0acc1b118c025b1345d633ba920615f5571" translate="yes" xml:space="preserve">
          <source>Trait-based dispatch</source>
          <target state="translated">Traitベースの派遣</target>
        </trans-unit>
        <trans-unit id="d5838baf7a0cdd2c01f0b9aad26d4b577472aeb0" translate="yes" xml:space="preserve">
          <source>Tram</source>
          <target state="translated">Tram</target>
        </trans-unit>
        <trans-unit id="fd49baa6a07af107b147f6c54ee8d0e9b28fd8ce" translate="yes" xml:space="preserve">
          <source>Tram Car</source>
          <target state="translated">路面電車</target>
        </trans-unit>
        <trans-unit id="742b78a52f1ec6f46ea0e8ce25d61611232abdad" translate="yes" xml:space="preserve">
          <source>Transform an array to its complex conjugate in-place.</source>
          <target state="translated">配列をその場で複素共役に変換します.</target>
        </trans-unit>
        <trans-unit id="fe67b43b94628556bbf8a1979e5bb4a616c981e5" translate="yes" xml:space="preserve">
          <source>Transform collection &lt;code&gt;c&lt;/code&gt; by applying &lt;code&gt;f&lt;/code&gt; to each element using available workers and tasks.</source>
          <target state="translated">使用可能なワーカーとタスクを使用して各要素に &lt;code&gt;f&lt;/code&gt; を適用することにより、コレクション &lt;code&gt;c&lt;/code&gt; を変換します。</target>
        </trans-unit>
        <trans-unit id="53273d7443cc45adf7bcb374bbb1ed108fc37052" translate="yes" xml:space="preserve">
          <source>Transform collection &lt;code&gt;c&lt;/code&gt; by applying &lt;code&gt;f&lt;/code&gt; to each element. For multiple collection arguments, apply &lt;code&gt;f&lt;/code&gt; elementwise.</source>
          <target state="translated">各要素に &lt;code&gt;f&lt;/code&gt; を適用してコレクション &lt;code&gt;c&lt;/code&gt; を変換します。複数のコレクション引数の場合、 &lt;code&gt;f&lt;/code&gt; を要素ごとに適用します。</target>
        </trans-unit>
        <trans-unit id="9c3a64c4f09f42065e08d17127a4cf1dbd8b1a80" translate="yes" xml:space="preserve">
          <source>Transform the eigenvectors &lt;code&gt;V&lt;/code&gt; of a matrix balanced using &lt;code&gt;gebal!&lt;/code&gt; to the unscaled/unpermuted eigenvectors of the original matrix. Modifies &lt;code&gt;V&lt;/code&gt; in-place. &lt;code&gt;side&lt;/code&gt; can be &lt;code&gt;L&lt;/code&gt; (left eigenvectors are transformed) or &lt;code&gt;R&lt;/code&gt; (right eigenvectors are transformed).</source>
          <target state="translated">&lt;code&gt;gebal!&lt;/code&gt; を使用してバランスの取れた行列の固有ベクトル &lt;code&gt;V&lt;/code&gt; を変換します！元の行列のスケーリングされていない/並べ替えられていない固有ベクトルに。 &lt;code&gt;V&lt;/code&gt; をインプレイスで修正します。 &lt;code&gt;side&lt;/code&gt; は &lt;code&gt;L&lt;/code&gt; （左固有ベクトルが変換される）または &lt;code&gt;R&lt;/code&gt; （右固有ベクトルが変換される）のいずれかです。</target>
        </trans-unit>
        <trans-unit id="589e1ff32866be5e43daf649cc6902633fad511a" translate="yes" xml:space="preserve">
          <source>Transform the given dimensions of array &lt;code&gt;A&lt;/code&gt; using function &lt;code&gt;f&lt;/code&gt;. &lt;code&gt;f&lt;/code&gt; is called on each slice of &lt;code&gt;A&lt;/code&gt; of the form &lt;code&gt;A[...,:,...,:,...]&lt;/code&gt;. &lt;code&gt;dims&lt;/code&gt; is an integer vector specifying where the colons go in this expression. The results are concatenated along the remaining dimensions. For example, if &lt;code&gt;dims&lt;/code&gt; is &lt;code&gt;[1,2]&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; is 4-dimensional, &lt;code&gt;f&lt;/code&gt; is called on &lt;code&gt;A[:,:,i,j]&lt;/code&gt; for all &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt;.</source>
          <target state="translated">関数 &lt;code&gt;f&lt;/code&gt; を使用して、配列 &lt;code&gt;A&lt;/code&gt; の指定された次元を変換します。 &lt;code&gt;f&lt;/code&gt; は各スライスで呼び出される &lt;code&gt;A&lt;/code&gt; 形の &lt;code&gt;A[...,:,...,:,...]&lt;/code&gt; 。 &lt;code&gt;dims&lt;/code&gt; は、この式のどこにコロンを置くかを指定する整数ベクトルです。結果は残りのディメンションに沿って連結されます。たとえば、 &lt;code&gt;dims&lt;/code&gt; が &lt;code&gt;[1,2]&lt;/code&gt; で &lt;code&gt;A&lt;/code&gt; が4次元の場合、 &lt;code&gt;f&lt;/code&gt; はすべての &lt;code&gt;i&lt;/code&gt; および &lt;code&gt;j&lt;/code&gt; に対して &lt;code&gt;A[:,:,i,j]&lt;/code&gt; で呼び出されます。</target>
        </trans-unit>
        <trans-unit id="50cedbb47d15ee34a2d802bd7d89f363094704e1" translate="yes" xml:space="preserve">
          <source>Transforms an indexable container into an Dictionary-view of the same data. Modifying the key-space of the underlying data may invalidate this object.</source>
          <target state="translated">インデックス可能なコンテナを、同じデータの辞書ビューに変換します。基底データのキー空間を変更すると、このオブジェクトが無効になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="66a40eda3c1161ed62ea96e24adba8e71d0ba78c" translate="yes" xml:space="preserve">
          <source>Transforms the upper trapezoidal matrix &lt;code&gt;A&lt;/code&gt; to upper triangular form in-place. Returns &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;tau&lt;/code&gt;, the scalar parameters for the elementary reflectors of the transformation.</source>
          <target state="translated">上台形行列 &lt;code&gt;A&lt;/code&gt; をインプレースの上三角形式に変換します。変換の基本リフレクターのスカラーパラメーターである &lt;code&gt;A&lt;/code&gt; および &lt;code&gt;tau&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="fc4c2841798d8e2d6fab4f58a0bd8b1dde31ae90" translate="yes" xml:space="preserve">
          <source>Transpose array &lt;code&gt;src&lt;/code&gt; and store the result in the preallocated array &lt;code&gt;dest&lt;/code&gt;, which should have a size corresponding to &lt;code&gt;(size(src,2),size(src,1))&lt;/code&gt;. No in-place transposition is supported and unexpected results will happen if &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;dest&lt;/code&gt; have overlapping memory regions.</source>
          <target state="translated">配列 &lt;code&gt;src&lt;/code&gt; を転置し、結果を事前割り当てされた配列 &lt;code&gt;dest&lt;/code&gt; に格納します。これは &lt;code&gt;(size(src,2),size(src,1))&lt;/code&gt; 対応するサイズでなければなりません。インプレース転置はサポートされておらず、 &lt;code&gt;src&lt;/code&gt; と &lt;code&gt;dest&lt;/code&gt; に重複するメモリ領域がある場合、予期しない結果が発生します。</target>
        </trans-unit>
        <trans-unit id="8f90329c80aba7f64de39c4d167572bb26f230b8" translate="yes" xml:space="preserve">
          <source>Transpose current line with line above</source>
          <target state="translated">現在の行を上の行に移す</target>
        </trans-unit>
        <trans-unit id="3687a79c6f0057ebfb38f5f6a37b95eeaa41c961" translate="yes" xml:space="preserve">
          <source>Transpose current line with line below</source>
          <target state="translated">現在の行を下の行に移す</target>
        </trans-unit>
        <trans-unit id="48be66c4f5c89d5b655d081c49787c6dc2120182" translate="yes" xml:space="preserve">
          <source>Transpose the characters about the cursor</source>
          <target state="translated">カーソルに関する文字を転置する</target>
        </trans-unit>
        <trans-unit id="fb403df4dd376fe10346f5998fcc78a8bb44e0b5" translate="yes" xml:space="preserve">
          <source>Transposition Operation</source>
          <target state="translated">転置操作</target>
        </trans-unit>
        <trans-unit id="e59e9a12661e6b012b7d657cf12b62dc5b571082" translate="yes" xml:space="preserve">
          <source>Transposition operation</source>
          <target state="translated">転置操作</target>
        </trans-unit>
        <trans-unit id="ecfd8b1ba3d62f7ad1ee66b9f0fb873cb6da8327" translate="yes" xml:space="preserve">
          <source>Transversal Intersection</source>
          <target state="translated">横断交差点</target>
        </trans-unit>
        <trans-unit id="7cde555988492eea4432149156cbe06f0b076e67" translate="yes" xml:space="preserve">
          <source>Traverse the entries in &lt;code&gt;tree&lt;/code&gt; and its subtrees in post or pre order. Preorder means beginning at the root and then traversing the leftmost subtree (and recursively on down through that subtree's leftmost subtrees) and moving right through the subtrees. Postorder means beginning at the bottom of the leftmost subtree, traversing upwards through it, then traversing the next right subtree (again beginning at the bottom) and finally visiting the tree root last of all.</source>
          <target state="translated">&lt;code&gt;tree&lt;/code&gt; およびそのサブツリーのエントリをポストまたはプレオーダーでトラバースします。プリオーダーとは、ルートから開始し、次に左端のサブツリーを（そしてそのサブツリーの左端のサブツリーを再帰的に下に）トラバースし、サブツリーを右に移動することを意味します。ポストオーダーとは、左端のサブツリーの下部から始まり、上方向にトラバースし、次に次の右側のサブツリーを（下部から開始して）トラバースし、最後にツリーのルートに最後にアクセスすることを意味します。</target>
        </trans-unit>
        <trans-unit id="791e68e780c0f86ed7620277a18ccb7b2f0900e4" translate="yes" xml:space="preserve">
          <source>Treat Subnormal Numbers as Zeros</source>
          <target state="translated">亜正規数をゼロとして扱う</target>
        </trans-unit>
        <trans-unit id="c4fadb4fd45f206006c2e243d850b8c3f0ed9575" translate="yes" xml:space="preserve">
          <source>Treating subnormals as zeros should be used with caution, because doing so breaks some identities, such as &lt;code&gt;x-y == 0&lt;/code&gt; implies &lt;code&gt;x == y&lt;/code&gt;:</source>
          <target state="translated">正規表現をゼロとして扱うことは注意して使用する必要があります。これを行うと、 &lt;code&gt;x-y == 0&lt;/code&gt; などの一部のIDが壊れ、 &lt;code&gt;x == y&lt;/code&gt; 暗黙的に含まれるためです。</target>
        </trans-unit>
        <trans-unit id="9c9ca807bb2ab4244216bbe667dca9d54adffd7f" translate="yes" xml:space="preserve">
          <source>Triangle Referencing</source>
          <target state="translated">三角形の参照</target>
        </trans-unit>
        <trans-unit id="2bb3f66057a0bac3d2fe069941cb9f2a05c4b5bc" translate="yes" xml:space="preserve">
          <source>Triangle With Dot Above</source>
          <target state="translated">ドットの上の三角形</target>
        </trans-unit>
        <trans-unit id="b7c13ac265c6665e49bdb94db0d8083d9f778bcb" translate="yes" xml:space="preserve">
          <source>Triangle With Underbar</source>
          <target state="translated">アンダーバー付きトライアングル</target>
        </trans-unit>
        <trans-unit id="160c26397adf4988e0b7455c4f857604b9fb8d0d" translate="yes" xml:space="preserve">
          <source>Triangle referencing</source>
          <target state="translated">三角形の参照</target>
        </trans-unit>
        <trans-unit id="8fc6199243314b8c0c53ed674ea486fd217ade89" translate="yes" xml:space="preserve">
          <source>Triangular</source>
          <target state="translated">Triangular</target>
        </trans-unit>
        <trans-unit id="6d90e2fedf2c3a69bc762b826e673df767a24a84" translate="yes" xml:space="preserve">
          <source>Triangular Flag On Post</source>
          <target state="translated">ポストに三角旗</target>
        </trans-unit>
        <trans-unit id="35a961685d74e87fb2defd8c3eaff910ff2eb0eb" translate="yes" xml:space="preserve">
          <source>Triangular Ruler</source>
          <target state="translated">三角定規</target>
        </trans-unit>
        <trans-unit id="9e336984f920581ee4ce0df13dfa14b0e2ae3a42" translate="yes" xml:space="preserve">
          <source>Tricky? Perhaps. What is an innocent &lt;code&gt;Dates&lt;/code&gt; user to do? The bottom line is to be aware that explicitly forcing a certain associativity, when dealing with months, may lead to some unexpected results, but otherwise, everything should work as expected. Thankfully, that's pretty much the extent of the odd cases in date-period arithmetic when dealing with time in UT (avoiding the &quot;joys&quot; of dealing with daylight savings, leap seconds, etc.).</source>
          <target state="translated">トリッキー？たぶん。罪のない &lt;code&gt;Dates&lt;/code&gt; ユーザーは何をするのですか？結論として、特定の連想性を明示的に強制すると、月を処理するときに予期しない結果が生じる可能性がありますが、それ以外の場合は、すべてが期待どおりに機能するはずです。ありがたいことに、これは、UTで時間を処理するときの日付期間演算の奇妙なケースの範囲です（夏時間、うるう秒などを処理する「喜び」を避けます）。</target>
        </trans-unit>
        <trans-unit id="98200808753c64066fca0c2f60e6540c2f9304ca" translate="yes" xml:space="preserve">
          <source>Tricolon</source>
          <target state="translated">Tricolon</target>
        </trans-unit>
        <trans-unit id="4b05482034189f500d70df4463d2dbc3fd792fa1" translate="yes" xml:space="preserve">
          <source>Trident Emblem</source>
          <target state="translated">トライデントエンブレム</target>
        </trans-unit>
        <trans-unit id="0f0fe0b102122af9b3e1aa3066e10188316b7e80" translate="yes" xml:space="preserve">
          <source>Tridiagonal</source>
          <target state="translated">Tridiagonal</target>
        </trans-unit>
        <trans-unit id="4f23fdcbf978b1f174f1f0150b4e839f69d24afc" translate="yes" xml:space="preserve">
          <source>Tridiagonal matrix</source>
          <target state="translated">さんかくぎょうれつ</target>
        </trans-unit>
        <trans-unit id="e789c19841ebe0317ebcd28434e36e772dc7a83d" translate="yes" xml:space="preserve">
          <source>Trigonometric and hyperbolic functions</source>
          <target state="translated">三角関数と双曲関数</target>
        </trans-unit>
        <trans-unit id="f20cc8cf4fba3cc7d93846dfbed75994f6215f36" translate="yes" xml:space="preserve">
          <source>Triple Colon Operator</source>
          <target state="translated">トリプルコロンオペレーター</target>
        </trans-unit>
        <trans-unit id="4a03809cfb647189e67fad647f769643426eb524" translate="yes" xml:space="preserve">
          <source>Triple Integral</source>
          <target state="translated">トリプルインテグラル</target>
        </trans-unit>
        <trans-unit id="4c843fa3d064b1637b9a934e39f0951786b86357" translate="yes" xml:space="preserve">
          <source>Triple Nested Greater-Than</source>
          <target state="translated">トリプルネストされたグレータースタン</target>
        </trans-unit>
        <trans-unit id="bc48dc85d97fd346bea02435f83eacf69e6b6aa3" translate="yes" xml:space="preserve">
          <source>Triple Nested Less-Than</source>
          <target state="translated">トリプルネスト</target>
        </trans-unit>
        <trans-unit id="10e187cab7bb4c297ed3b8b0dc8a7e7c1b437b6e" translate="yes" xml:space="preserve">
          <source>Triple Plus</source>
          <target state="translated">トリプルプラス</target>
        </trans-unit>
        <trans-unit id="e4107a129a477eb4305d09a04ff620342e6d5a39" translate="yes" xml:space="preserve">
          <source>Triple Prime</source>
          <target state="translated">トリプルプライム</target>
        </trans-unit>
        <trans-unit id="f91ac0ecf21472d6ccd15f4ba9af28d149dc8f7d" translate="yes" xml:space="preserve">
          <source>Triple Tilde</source>
          <target state="translated">トリプルティルデ</target>
        </trans-unit>
        <trans-unit id="9aad96f795695616a77fd0b86856873ada33c081" translate="yes" xml:space="preserve">
          <source>Triple Vertical Bar Binary Relation</source>
          <target state="translated">トリプル縦棒バイナリ関係</target>
        </trans-unit>
        <trans-unit id="5aa94f488e3751771f1642dc28467e3117351ee0" translate="yes" xml:space="preserve">
          <source>Triple Vertical Bar Delimiter</source>
          <target state="translated">トリプル垂直バーデリミッター</target>
        </trans-unit>
        <trans-unit id="3be66a3b16b2414eeb14c7e1589bb01ace3385b3" translate="yes" xml:space="preserve">
          <source>Triple Vertical Bar Right Turnstile</source>
          <target state="translated">トリプル垂直バー右回転木戸</target>
        </trans-unit>
        <trans-unit id="15fb453f3bd4fb6b3dc4c8fc111b98e0cb966ca8" translate="yes" xml:space="preserve">
          <source>Triple-Quoted String Literals</source>
          <target state="translated">三重引用符付き文字列文字列</target>
        </trans-unit>
        <trans-unit id="2920ab57511d06b8770e0cbbb95a3cbbf0a249d1" translate="yes" xml:space="preserve">
          <source>Triple-quoted regex strings, of the form &lt;code&gt;r&quot;&quot;&quot;...&quot;&quot;&quot;&lt;/code&gt;, are also supported (and may be convenient for regular expressions containing quotation marks or newlines).</source>
          <target state="translated">&lt;code&gt;r&quot;&quot;&quot;...&quot;&quot;&quot;&lt;/code&gt; の形式の、三重引用符で囲まれた正規表現文字列もサポートされています（引用符や改行を含む正規表現に便利な場合があります）。</target>
        </trans-unit>
        <trans-unit id="b54e3c85f204b81397a7c84b48965d41b5754fba" translate="yes" xml:space="preserve">
          <source>Triple-quoted string literals can contain &lt;code&gt;&quot;&lt;/code&gt; characters without escaping.</source>
          <target state="translated">三重引用符で囲まれた文字列リテラルには、エスケープせずに &lt;code&gt;&quot;&lt;/code&gt; 文字を含めることができます。</target>
        </trans-unit>
        <trans-unit id="01aa9c142c3bf18faaea1950666658f968f3131c" translate="yes" xml:space="preserve">
          <source>Triple-quoted string literals can contain &lt;code&gt;&quot;&lt;/code&gt; symbols without escaping.</source>
          <target state="translated">三重引用符で囲まれた文字列リテラルには、エスケープせずに &lt;code&gt;&quot;&lt;/code&gt; 記号を含めることができます。</target>
        </trans-unit>
        <trans-unit id="957886bc006fb19c37ca4b45b5f2e8ebf53008e7" translate="yes" xml:space="preserve">
          <source>Trolleybus</source>
          <target state="translated">Trolleybus</target>
        </trans-unit>
        <trans-unit id="1075c086b703df3b01e8d6013dae65668d6d865d" translate="yes" xml:space="preserve">
          <source>Trophy</source>
          <target state="translated">Trophy</target>
        </trans-unit>
        <trans-unit id="f27ecef221139e5fd432ae45c48c9d80fb89e7df" translate="yes" xml:space="preserve">
          <source>Tropical Drink</source>
          <target state="translated">トロピカルドリンク</target>
        </trans-unit>
        <trans-unit id="2983c072197329832df76d88b69aef1b73478110" translate="yes" xml:space="preserve">
          <source>Tropical Fish</source>
          <target state="translated">熱帯魚</target>
        </trans-unit>
        <trans-unit id="88b33e4e12f75ac8bf792aebde41f1a090f3a612" translate="yes" xml:space="preserve">
          <source>True</source>
          <target state="translated">True</target>
        </trans-unit>
        <trans-unit id="63bc99348fac41157f28181105c7b5ea6bb7afd2" translate="yes" xml:space="preserve">
          <source>True if the code is from C.</source>
          <target state="translated">コードがC言語のものであれば真。</target>
        </trans-unit>
        <trans-unit id="ec75cc300e047be39d0a9fb14737dd15be5276d7" translate="yes" xml:space="preserve">
          <source>True if the code is from an inlined frame.</source>
          <target state="translated">コードがインラインフレームからのものであれば真。</target>
        </trans-unit>
        <trans-unit id="66c3284825be09870b41244ed701aea7191cb82e" translate="yes" xml:space="preserve">
          <source>Trumpet</source>
          <target state="translated">Trumpet</target>
        </trans-unit>
        <trans-unit id="4b46414e1c27f9b8937db64044b2e81c89c3c481" translate="yes" xml:space="preserve">
          <source>Truncates the value of &lt;code&gt;dt&lt;/code&gt; according to the provided &lt;code&gt;Period&lt;/code&gt; type.</source>
          <target state="translated">指定された &lt;code&gt;Period&lt;/code&gt; タイプに従って &lt;code&gt;dt&lt;/code&gt; の値を切り捨てます。</target>
        </trans-unit>
        <trans-unit id="1ab5d704e1ea0cac99a119ecd2665b6a98ac90ba" translate="yes" xml:space="preserve">
          <source>Try to avoid using too many levels of header within a single document. A heavily nested document may be indicative of a need to restructure it or split it into several pages covering separate topics.</source>
          <target state="translated">1つの文書内であまりにも多くのレベルのヘッダーを使用しないようにしてください。重く入れ子になっている文書は、文書を再構築する必要があることを示しているかもしれませんし、別々のトピックをカバーする複数のページに分割する必要があることを示しているかもしれません。</target>
        </trans-unit>
        <trans-unit id="a5782807a1634c799255f28c6609330ea2948623" translate="yes" xml:space="preserve">
          <source>Trying to construct a &lt;a href=&quot;../../base/numbers/index#Base.NaN&quot;&gt;&lt;code&gt;NaN&lt;/code&gt;&lt;/a&gt; rational value, however, is invalid:</source>
          <target state="translated">ただし、&lt;a href=&quot;../../base/numbers/index#Base.NaN&quot;&gt; &lt;code&gt;NaN&lt;/code&gt; &lt;/a&gt;有理数を作成しようとすると無効です。</target>
        </trans-unit>
        <trans-unit id="0a45f936f6d904e3db7eb90ebb14b6146ce40542" translate="yes" xml:space="preserve">
          <source>Tulip</source>
          <target state="translated">Tulip</target>
        </trans-unit>
        <trans-unit id="8f2a5e4b9220f04b1f591d617289494ede815765" translate="yes" xml:space="preserve">
          <source>Tuple Types</source>
          <target state="translated">タプル型</target>
        </trans-unit>
        <trans-unit id="845b33803adcb6fd7b83aa05a48e2e532cdedbb3" translate="yes" xml:space="preserve">
          <source>Tuple and NTuple arguments</source>
          <target state="translated">タプルとNTupleの引数</target>
        </trans-unit>
        <trans-unit id="1d7518da5e57e98af113ed9ca0544eae23ceace9" translate="yes" xml:space="preserve">
          <source>Tuple types are &lt;em&gt;covariant&lt;/em&gt; in their parameters: &lt;code&gt;Tuple{Int}&lt;/code&gt; is a subtype of &lt;code&gt;Tuple{Any}&lt;/code&gt;. Therefore &lt;code&gt;Tuple{Any}&lt;/code&gt; is considered an abstract type, and tuple types are only concrete if their parameters are.</source>
          <target state="translated">タプル型は、パラメーターが&lt;em&gt;共変&lt;/em&gt;です &lt;code&gt;Tuple{Int}&lt;/code&gt; は &lt;code&gt;Tuple{Any}&lt;/code&gt; サブタイプです。したがって、 &lt;code&gt;Tuple{Any}&lt;/code&gt; は抽象型と見なされ、タプル型は、そのパラメーターが具体的な場合にのみ具象になります。</target>
        </trans-unit>
        <trans-unit id="f158b42c8df38fba7edc2516cf30067a6f3c3fd2" translate="yes" xml:space="preserve">
          <source>Tuple types are covariant in their parameters: &lt;code&gt;Tuple{Int}&lt;/code&gt; is a subtype of &lt;code&gt;Tuple{Any}&lt;/code&gt;. Therefore &lt;code&gt;Tuple{Any}&lt;/code&gt; is considered an abstract type, and tuple types are only concrete if their parameters are. Tuples do not have field names; fields are only accessed by index.</source>
          <target state="translated">タプル型は、パラメーターが共変です &lt;code&gt;Tuple{Int}&lt;/code&gt; は &lt;code&gt;Tuple{Any}&lt;/code&gt; サブタイプです。したがって、 &lt;code&gt;Tuple{Any}&lt;/code&gt; は抽象型と見なされ、タプル型は、そのパラメーターが具体的な場合にのみ具象になります。タプルにはフィールド名はありません。フィールドはインデックスによってのみアクセスされます。</target>
        </trans-unit>
        <trans-unit id="c3dd2cf49e1c762ee0d977a8827179a18862e514" translate="yes" xml:space="preserve">
          <source>Tuple types may have any number of parameters.</source>
          <target state="translated">タプル型は任意の数のパラメータを持つことができます。</target>
        </trans-unit>
        <trans-unit id="436cabb920e9afcb6c39fb96f4c8e856c77ac70f" translate="yes" xml:space="preserve">
          <source>Tuple values are written with parentheses and commas. When a tuple is constructed, an appropriate tuple type is generated on demand:</source>
          <target state="translated">タプルの値は括弧とカンマで記述されます。タプルが構築されると、要求に応じて適切なタプル型が生成されます。</target>
        </trans-unit>
        <trans-unit id="538a8ce3fbdcaee00a14353bd57bcf3600c6e0d0" translate="yes" xml:space="preserve">
          <source>Tuples</source>
          <target state="translated">Tuples</target>
        </trans-unit>
        <trans-unit id="2b853ab04d00cf57d1ce546398e1b79f3f051f32" translate="yes" xml:space="preserve">
          <source>Tuples are an abstraction of the arguments of a function &amp;ndash; without the function itself. The salient aspects of a function's arguments are their order and their types. Therefore a tuple type is similar to a parameterized immutable type where each parameter is the type of one field. For example, a 2-element tuple type resembles the following immutable type:</source>
          <target state="translated">タプルは、関数自体のない、関数の引数の抽象化です。関数の引数の特徴は、順序と型です。したがって、タプル型は、各パラメーターが1つのフィールドの型であるパラメーター化された不変型に似ています。たとえば、2要素のタプル型は次の不変型に似ています。</target>
        </trans-unit>
        <trans-unit id="38f517ecb99a7d22ca712e684653b53d2da013e1" translate="yes" xml:space="preserve">
          <source>Tuples are an abstraction of the arguments of a function &amp;ndash; without the function itself. The salient aspects of a function's arguments are their order and their types. Therefore a tuple type is similar to a parameterized immutable type where each parameter is the type of one field. Tuple types may have any number of parameters.</source>
          <target state="translated">タプルは、関数自体のない、関数の引数の抽象化です。関数の引数の特徴は、順序と型です。したがって、タプル型は、各パラメーターが1つのフィールドの型であるパラメーター化された不変型に似ています。タプル型には、任意の数のパラメーターを含めることができます。</target>
        </trans-unit>
        <trans-unit id="10a000d9419f2a05d7ec82307740cfc2f368764c" translate="yes" xml:space="preserve">
          <source>Tuples do not have field names; fields are only accessed by index.</source>
          <target state="translated">タプルにはフィールド名がありません。</target>
        </trans-unit>
        <trans-unit id="d475d0ed8dbda37de3962c553ee1cf6bad5acd73" translate="yes" xml:space="preserve">
          <source>Turned Ampersand</source>
          <target state="translated">ターンアンパサンド</target>
        </trans-unit>
        <trans-unit id="44e7aa783e6e21961447d92fabcb381a889f661a" translate="yes" xml:space="preserve">
          <source>Turned Angle</source>
          <target state="translated">旋回角度</target>
        </trans-unit>
        <trans-unit id="8b3464100be6c8cfd6483bbda164ded5b9f3dda5" translate="yes" xml:space="preserve">
          <source>Turned Capital F / Turned F</source>
          <target state="translated">ターンドキャピタルF/ターンドF</target>
        </trans-unit>
        <trans-unit id="c0d9680d54a56600626a6e13ab971c5a7946bf28" translate="yes" xml:space="preserve">
          <source>Turned Greek Small Letter Iota</source>
          <target state="translated">ギリシャ語の小文字イオタを回した</target>
        </trans-unit>
        <trans-unit id="a0d677f4e8b54c3e427ed668e6e7e5fb71640f1b" translate="yes" xml:space="preserve">
          <source>Turned Not Sign</source>
          <target state="translated">サインをしていません。</target>
        </trans-unit>
        <trans-unit id="65de22879a9e05c48035f0650a2aba5faf638568" translate="yes" xml:space="preserve">
          <source>Turned Sans-Serif Capital G</source>
          <target state="translated">サンセリフ大文字Gを変換</target>
        </trans-unit>
        <trans-unit id="a0b3c92d57fcbd9e284b1f1bc355f9c62a47e627" translate="yes" xml:space="preserve">
          <source>Turned Sans-Serif Capital L</source>
          <target state="translated">サンセリフ・セリフ・キャピタルLに変更</target>
        </trans-unit>
        <trans-unit id="c98f94d5a7cb8446bd8b48114b19424f10405e51" translate="yes" xml:space="preserve">
          <source>Turned Sans-Serif Capital Y</source>
          <target state="translated">サンセリフ・セリフ・キャピタルYの変換</target>
        </trans-unit>
        <trans-unit id="7039da614328dbb74b73091f274ceec249a388f5" translate="yes" xml:space="preserve">
          <source>Turtle</source>
          <target state="translated">Turtle</target>
        </trans-unit>
        <trans-unit id="eaef77aca961ecc2cacd2ed540321a53b86f2c60" translate="yes" xml:space="preserve">
          <source>Tweaks</source>
          <target state="translated">Tweaks</target>
        </trans-unit>
        <trans-unit id="2c47ac9f8b779ed312982f36375e817cfd461a0d" translate="yes" xml:space="preserve">
          <source>Twisted Rightwards Arrows</source>
          <target state="translated">ねじれた右向きの矢印</target>
        </trans-unit>
        <trans-unit id="850aa4e89f36cf847f4d161726e5625623c23118" translate="yes" xml:space="preserve">
          <source>Two Consecutive Equals Signs</source>
          <target state="translated">二連続イコールサイン</target>
        </trans-unit>
        <trans-unit id="d41d4a075c8d174ebb10603c708c639e709f0109" translate="yes" xml:space="preserve">
          <source>Two Hearts</source>
          <target state="translated">ツーハーツ</target>
        </trans-unit>
        <trans-unit id="7a3530233c722f61a2c0d529c3b9d5062536abc0" translate="yes" xml:space="preserve">
          <source>Two Intersecting Logical And</source>
          <target state="translated">2つの交差する論理と</target>
        </trans-unit>
        <trans-unit id="55266f0a48713c6bc0f773b39d521dc70499465f" translate="yes" xml:space="preserve">
          <source>Two Intersecting Logical Or</source>
          <target state="translated">2つの交差する論理的または</target>
        </trans-unit>
        <trans-unit id="66b2f43372d062ff8e38e2e1c1860db370e78e02" translate="yes" xml:space="preserve">
          <source>Two Logical And Operator</source>
          <target state="translated">2つの論理と演算子</target>
        </trans-unit>
        <trans-unit id="12c9295bb902c2fb14793da783a921da3fd8054a" translate="yes" xml:space="preserve">
          <source>Two Logical Or Operator</source>
          <target state="translated">2つの論理または演算子</target>
        </trans-unit>
        <trans-unit id="fd1eb7f02c8f49a97ad1aaa21bd916045738c759" translate="yes" xml:space="preserve">
          <source>Two Men Holding Hands</source>
          <target state="translated">手をつなぐ二人の男</target>
        </trans-unit>
        <trans-unit id="ea9b8150660b031f305860c61406c3d6161a7b06" translate="yes" xml:space="preserve">
          <source>Two Women Holding Hands</source>
          <target state="translated">手をつなぐ二人の女性</target>
        </trans-unit>
        <trans-unit id="14a1f210884121dab1e048ee8ff43a770883c685" translate="yes" xml:space="preserve">
          <source>Two dimensional &lt;a href=&quot;#Base.StridedArray&quot;&gt;&lt;code&gt;StridedArray&lt;/code&gt;&lt;/a&gt; with elements of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 型の要素を持つ2次元&lt;a href=&quot;#Base.StridedArray&quot;&gt; &lt;code&gt;StridedArray&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d8f09c4cf86a87bcead55bcb46b75740b635c442" translate="yes" xml:space="preserve">
          <source>Two other handy string functions are &lt;a href=&quot;../../base/arrays/index#Base.repeat&quot;&gt;&lt;code&gt;repeat&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/strings/index#Base.join&quot;&gt;&lt;code&gt;join&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">他の2つの便利な文字列関数は&lt;a href=&quot;../../base/arrays/index#Base.repeat&quot;&gt; &lt;code&gt;repeat&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../../base/strings/index#Base.join&quot;&gt; &lt;code&gt;join&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="19a22abb2af2528acd0706b6d05a99511e3cad19" translate="yes" xml:space="preserve">
          <source>Two typical uses of &lt;code&gt;__init__&lt;/code&gt; are calling runtime initialization functions of external C libraries and initializing global constants that involve pointers returned by external libraries. For example, suppose that we are calling a C library &lt;code&gt;libfoo&lt;/code&gt; that requires us to call a &lt;code&gt;foo_init()&lt;/code&gt; initialization function at runtime. Suppose that we also want to define a global constant &lt;code&gt;foo_data_ptr&lt;/code&gt; that holds the return value of a &lt;code&gt;void *foo_data()&lt;/code&gt; function defined by &lt;code&gt;libfoo&lt;/code&gt; &amp;ndash; this constant must be initialized at runtime (not at compile time) because the pointer address will change from run to run. You could accomplish this by defining the following &lt;code&gt;__init__&lt;/code&gt; function in your module:</source>
          <target state="translated">&lt;code&gt;__init__&lt;/code&gt; の 2つの一般的な用途は、外部Cライブラリのランタイム初期化関数を呼び出すことと、外部ライブラリから返されるポインタを含むグローバル定数を初期化することです。たとえば、私たちはCライブラリ呼び出していると仮定 &lt;code&gt;libfoo&lt;/code&gt; を呼び出すために私たちを必要と &lt;code&gt;foo_init()&lt;/code&gt; 実行時に初期化関数を。我々はまた、グローバル定数を定義したいと仮定し &lt;code&gt;foo_data_ptr&lt;/code&gt; の戻り値を保持し &lt;code&gt;void *foo_data()&lt;/code&gt; で定義された関数 &lt;code&gt;libfoo&lt;/code&gt; ポインタアドレスがに実行から変更されますので、この定数は、ランタイム（コンパイル時ではなく）で初期化する必要があります-実行します。これを行うには、次の &lt;code&gt;__init__&lt;/code&gt; を定義します。 モジュール内の関数：</target>
        </trans-unit>
        <trans-unit id="34e8818ff6722512c7d2d5bdcca9e688c6d5dbba" translate="yes" xml:space="preserve">
          <source>Two-dimensional &lt;a href=&quot;#Core.DenseArray&quot;&gt;&lt;code&gt;DenseArray&lt;/code&gt;&lt;/a&gt; with elements of type &lt;code&gt;T&lt;/code&gt;. Alias for &lt;code&gt;DenseArray{T,2}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 型の要素を持つ2次元の&lt;a href=&quot;#Core.DenseArray&quot;&gt; &lt;code&gt;DenseArray&lt;/code&gt; &lt;/a&gt;。 &lt;code&gt;DenseArray{T,2}&lt;/code&gt; エイリアス。</target>
        </trans-unit>
        <trans-unit id="520563ee1cb32d20148c405d4ac444576ac80929" translate="yes" xml:space="preserve">
          <source>Two-dimensional dense array with elements of type &lt;code&gt;T&lt;/code&gt;, often used to represent a mathematical matrix. Alias for &lt;a href=&quot;#Core.Array&quot;&gt;&lt;code&gt;Array{T,2}&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 型の要素を持つ2次元の密配列。多くの場合、数学行列を表すために使用されます。&lt;a href=&quot;#Core.Array&quot;&gt; &lt;code&gt;Array{T,2}&lt;/code&gt; &lt;/a&gt;エイリアス。</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="699c321e34c4b272cb0e92dbf84b36d8841e2209" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;T1&lt;/code&gt; defines a 1-dimensional array of 1-dimensional arrays; each of the inner arrays consists of objects of the same type, but this type may vary from one inner array to the next. On the other hand, type &lt;code&gt;T2&lt;/code&gt; defines a 1-dimensional array of 1-dimensional arrays all of whose inner arrays must have the same type. Note that &lt;code&gt;T2&lt;/code&gt; is an abstract type, e.g., &lt;code&gt;Array{Array{Int,1},1} &amp;lt;: T2&lt;/code&gt;, whereas &lt;code&gt;T1&lt;/code&gt; is a concrete type. As a consequence, &lt;code&gt;T1&lt;/code&gt; can be constructed with a zero-argument constructor &lt;code&gt;a=T1()&lt;/code&gt; but &lt;code&gt;T2&lt;/code&gt; cannot.</source>
          <target state="translated">タイプ &lt;code&gt;T1&lt;/code&gt; は、1次元配列の1次元配列を定義します。各内部配列は同じタイプのオブジェクトで構成されていますが、このタイプは内部配列によって異なる場合があります。一方、 &lt;code&gt;T2&lt;/code&gt; 型は、すべての内部配列が同じ型でなければならない1次元配列の1次元配列を定義します。そのノート &lt;code&gt;T2&lt;/code&gt; は抽象型であり、例えば、 &lt;code&gt;Array{Array{Int,1},1} &amp;lt;: T2&lt;/code&gt; 、一方 &lt;code&gt;T1&lt;/code&gt; はコンクリートタイプです。結果として、 &lt;code&gt;T1&lt;/code&gt; は引数なしのコンストラクター &lt;code&gt;a=T1()&lt;/code&gt; で構築できますが、 &lt;code&gt;T2&lt;/code&gt; は構築できません。</target>
        </trans-unit>
        <trans-unit id="9336947ff1fcdc631e771b9b86afd198836eb20c" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;VecElement{T}&lt;/code&gt; is intended for building libraries of SIMD operations. Practical use of it requires using &lt;code&gt;llvmcall&lt;/code&gt;. The type is defined as:</source>
          <target state="translated">タイプ &lt;code&gt;VecElement{T}&lt;/code&gt; は、SIMD操作のライブラリを構築するためのものです。それを実際に使用するには &lt;code&gt;llvmcall&lt;/code&gt; を使用する必要があります。タイプは次のように定義されます。</target>
        </trans-unit>
        <trans-unit id="353ce315d4b89d72fbf39db84d79fda4b261f3b6" translate="yes" xml:space="preserve">
          <source>Type Aliases</source>
          <target state="translated">型別名</target>
        </trans-unit>
        <trans-unit id="1242b5a7bcfba49f41a8936f551747918a7040c3" translate="yes" xml:space="preserve">
          <source>Type Correspondences</source>
          <target state="translated">タイプ対応</target>
        </trans-unit>
        <trans-unit id="e9fa287d5611bc4f8123b770126f1a09136ca477" translate="yes" xml:space="preserve">
          <source>Type Correspondences:</source>
          <target state="translated">タイプ対応。</target>
        </trans-unit>
        <trans-unit id="5ce9a2f030a10c54388849495b66d1858de81a97" translate="yes" xml:space="preserve">
          <source>Type Declarations</source>
          <target state="translated">タイプ宣言</target>
        </trans-unit>
        <trans-unit id="c50d144660c5c67e814a21e78a048bb4d4c2ec30" translate="yes" xml:space="preserve">
          <source>Type Parameters</source>
          <target state="translated">タイプパラメータ</target>
        </trans-unit>
        <trans-unit id="3984fbe729382dd2cebe0b8952bf750232d09730" translate="yes" xml:space="preserve">
          <source>Type Unions</source>
          <target state="translated">タイプ別組合</target>
        </trans-unit>
        <trans-unit id="7ab532ff895c9c41984a98ec53a2137840835c70" translate="yes" xml:space="preserve">
          <source>Type annotation will not enhance (and can actually hinder) performance if the type is constructed at run-time. This is because the compiler cannot use the annotation to specialize the subsequent code, and the type-check itself takes time. For example, in the code:</source>
          <target state="translated">型アノテーションは、実行時に型が構築されている場合、パフォーマンスを向上させることはできません(実際には妨げになる可能性があります)。これは、コンパイラが後続のコードを特殊化するためにアノテーションを使用することができず、型のチェック自体に時間がかかるからです。例えば、コードの中では</target>
        </trans-unit>
        <trans-unit id="315f6367d2e7e25cde681d099ca28e1c2c774de1" translate="yes" xml:space="preserve">
          <source>Type declarations</source>
          <target state="translated">型宣言</target>
        </trans-unit>
        <trans-unit id="d823421474b9921ea903ae47a40988974efcaac1" translate="yes" xml:space="preserve">
          <source>Type parameters are introduced immediately after the type name, surrounded by curly braces:</source>
          <target state="translated">型のパラメータは、型名の直後に中括弧で囲まれて導入されます。</target>
        </trans-unit>
        <trans-unit id="7b5326008bc0cc9fa7f08d020855f5918767c17c" translate="yes" xml:space="preserve">
          <source>Type parameters for parametric composite types can be restricted in the same manner:</source>
          <target state="translated">パラメトリック合成型の型パラメータも同様に制限することができます。</target>
        </trans-unit>
        <trans-unit id="cbabd93da3123882a924672c6250533f840354ef" translate="yes" xml:space="preserve">
          <source>Type relations</source>
          <target state="translated">型の関係</target>
        </trans-unit>
        <trans-unit id="12d64d97cdd4d210c956404867f73d6285cb3aa2" translate="yes" xml:space="preserve">
          <source>Type systems have traditionally fallen into two quite different camps: static type systems, where every program expression must have a type computable before the execution of the program, and dynamic type systems, where nothing is known about types until run time, when the actual values manipulated by the program are available. Object orientation allows some flexibility in statically typed languages by letting code be written without the precise types of values being known at compile time. The ability to write code that can operate on different types is called polymorphism. All code in classic dynamically typed languages is polymorphic: only by explicitly checking types, or when objects fail to support operations at run-time, are the types of any values ever restricted.</source>
          <target state="translated">型システムは伝統的に2つの異なる陣営に分類されてきました。静的型システムでは、プログラムの実行前にすべてのプログラム式が計算可能な型を持たなければならず、動的型システムでは、プログラムによって操作される実際の値が利用可能になる実行時まで型については何も知らされていません。オブジェクト指向は、コンパイル時に値の正確な型を知らなくてもコードを書けるようにすることで、静的型付け言語にある程度の柔軟性を持たせることができます。異なる型で動作するコードを書けることをポリモーフィズムと呼びます。古典的な動的型付け言語では、すべてのコードはポリモーフィズムです。</target>
        </trans-unit>
        <trans-unit id="7972379a3c2cbad083d2ed614182962961c71c72" translate="yes" xml:space="preserve">
          <source>Type used by &lt;a href=&quot;#Distributed.ClusterManager&quot;&gt;&lt;code&gt;ClusterManager&lt;/code&gt;&lt;/a&gt;s to control workers added to their clusters. Some fields are used by all cluster managers to access a host:</source>
          <target state="translated">&lt;a href=&quot;#Distributed.ClusterManager&quot;&gt; &lt;code&gt;ClusterManager&lt;/code&gt; &lt;/a&gt;がクラスターに追加されたワーカーを制御するために使用するタイプ。一部のフィールドは、ホストにアクセスするためにすべてのクラスターマネージャーによって使用されます。</target>
        </trans-unit>
        <trans-unit id="9fbab0c4a9d7c9cb4f0cf6a2eb051a99d0b23d5d" translate="yes" xml:space="preserve">
          <source>Type variables can be restricted with subtype relations. &lt;code&gt;Array{T} where T&amp;lt;:Integer&lt;/code&gt; refers to all arrays whose element type is some kind of &lt;a href=&quot;../../base/numbers/index#Core.Integer&quot;&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/a&gt;. The syntax &lt;code&gt;Array{&amp;lt;:Integer}&lt;/code&gt; is a convenient shorthand for &lt;code&gt;Array{T} where T&amp;lt;:Integer&lt;/code&gt;. Type variables can have both lower and upper bounds. &lt;code&gt;Array{T} where Int&amp;lt;:T&amp;lt;:Number&lt;/code&gt; refers to all arrays of &lt;a href=&quot;../../base/numbers/index#Core.Number&quot;&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/a&gt;s that are able to contain &lt;code&gt;Int&lt;/code&gt;s (since &lt;code&gt;T&lt;/code&gt; must be at least as big as &lt;code&gt;Int&lt;/code&gt;). The syntax &lt;code&gt;where T&amp;gt;:Int&lt;/code&gt; also works to specify only the lower bound of a type variable, and &lt;code&gt;Array{&amp;gt;:Int}&lt;/code&gt; is equivalent to &lt;code&gt;Array{T} where T&amp;gt;:Int&lt;/code&gt;.</source>
          <target state="translated">タイプ変数は、サブタイプ関係で制限できます。 &lt;code&gt;Array{T} where T&amp;lt;:Integer&lt;/code&gt; は、要素タイプがなんらかの&lt;a href=&quot;../../base/numbers/index#Core.Integer&quot;&gt; &lt;code&gt;Integer&lt;/code&gt; &lt;/a&gt;であるすべての配列を指します。構文 &lt;code&gt;Array{&amp;lt;:Integer}&lt;/code&gt; は、 &lt;code&gt;Array{T} where T&amp;lt;:Integer&lt;/code&gt; 便利な省略形であり、T &amp;lt;：Integerです。型変数は、下限と上限の両方を持つことができます。 &lt;code&gt;Array{T} where Int&amp;lt;:T&amp;lt;:Number&lt;/code&gt; は、 &lt;code&gt;Int&lt;/code&gt; を含めることができる&lt;a href=&quot;../../base/numbers/index#Core.Number&quot;&gt; &lt;code&gt;Number&lt;/code&gt; &lt;/a&gt;のすべての配列を指します（ &lt;code&gt;T&lt;/code&gt; は少なくとも &lt;code&gt;Int&lt;/code&gt; と同じ大きさでなければならないため）。 &lt;code&gt;where T&amp;gt;:Int&lt;/code&gt; が型変数の下限のみを指定する構文も機能し、 &lt;code&gt;Array{&amp;gt;:Int}&lt;/code&gt; は次と同等です。 &lt;code&gt;Array{T} where T&amp;gt;:Int&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="55b58c015fd584b426ddd183d3bd379a95d6be97" translate="yes" xml:space="preserve">
          <source>Typed array initializers</source>
          <target state="translated">型付き配列イニシャライザ</target>
        </trans-unit>
        <trans-unit id="cf7a25a9e02171630e17f66a177ae70ee69aaf9a" translate="yes" xml:space="preserve">
          <source>Typed array literals</source>
          <target state="translated">型付けされた配列リテラル</target>
        </trans-unit>
        <trans-unit id="93b9e289e2842469d001eccf7ad5d79f3c302dc9" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Types</target>
        </trans-unit>
        <trans-unit id="fbe557b5793644a7901cb800d76030ed78f31ec9" translate="yes" xml:space="preserve">
          <source>Types can be declared without specifying the types of their fields:</source>
          <target state="translated">型は、フィールドの型を指定せずに宣言することができます。</target>
        </trans-unit>
        <trans-unit id="fdedb89e25bef406c502b07b3fc7f90af76076d3" translate="yes" xml:space="preserve">
          <source>Types in module &lt;code&gt;Main&lt;/code&gt; cannot be redefined.</source>
          <target state="translated">モジュール &lt;code&gt;Main&lt;/code&gt; の型は再定義できません。</target>
        </trans-unit>
        <trans-unit id="650af697d6f97ac31d8e939763f2089920715297" translate="yes" xml:space="preserve">
          <source>Types such as &lt;code&gt;Union{Function,AbstractString}&lt;/code&gt; are often a sign that some design could be cleaner.</source>
          <target state="translated">&lt;code&gt;Union{Function,AbstractString}&lt;/code&gt; などのタイプは、デザインがよりクリーンである可能性があることを示していることがよくあります。</target>
        </trans-unit>
        <trans-unit id="06e7787daf9f1b80047a5404b114c43c5fe951aa" translate="yes" xml:space="preserve">
          <source>Types with values-as-parameters</source>
          <target state="translated">値がパラメータとして設定されている型</target>
        </trans-unit>
        <trans-unit id="3f3f5c7adeb5ad8f6d9e378b2333ccf650b57cd7" translate="yes" xml:space="preserve">
          <source>Types, type declarations, and constructors</source>
          <target state="translated">型、型宣言、コンストラクタ</target>
        </trans-unit>
        <trans-unit id="eaef1931ed9538c659ce53165ed9d4e8ce061afe" translate="yes" xml:space="preserve">
          <source>Typically a large number of tests are used to make sure functions work correctly over a range of inputs. In the event a test fails, the default behavior is to throw an exception immediately. However, it is normally preferable to run the rest of the tests first to get a better picture of how many errors there are in the code being tested.</source>
          <target state="translated">通常、関数がさまざまな入力に対して正しく動作することを確認するために、多数のテストが使用されます。テストが失敗した場合のデフォルトの動作は、すぐに例外を投げることです。しかし、テストされているコードにどれだけのエラーがあるかをよりよく把握するために、最初に残りのテストを実行することが望ましいのが普通です。</target>
        </trans-unit>
        <trans-unit id="bc0c2b73a898cd3376224f049c214a04bf91c4ec" translate="yes" xml:space="preserve">
          <source>Typically, Julia objects are freed by a garbage collector (GC), but the GC does not automatically know that we are holding a reference to a Julia value from C. This means the GC can free objects out from under you, rendering pointers invalid.</source>
          <target state="translated">通常、Julia オブジェクトはガベージコレクタ (GC)によって解放されますが、GC は自動的に C から Julia 値への参照を保持していることを知りません。</target>
        </trans-unit>
        <trans-unit id="7419e2c7a1164809fb8ab4ac690a6e5483811275" translate="yes" xml:space="preserve">
          <source>U+000A1</source>
          <target state="translated">U+000A1</target>
        </trans-unit>
        <trans-unit id="f732db6bfaceaf0fc8ce5731c40779ee88385e6b" translate="yes" xml:space="preserve">
          <source>U+000A3</source>
          <target state="translated">U+000A3</target>
        </trans-unit>
        <trans-unit id="833d790d7abefa68b4017fdb2b0846169ce6efb2" translate="yes" xml:space="preserve">
          <source>U+000A5</source>
          <target state="translated">U+000A5</target>
        </trans-unit>
        <trans-unit id="58a6aa3f7f66e4affa4c092d7c6f847968ea3de9" translate="yes" xml:space="preserve">
          <source>U+000A6</source>
          <target state="translated">U+000A6</target>
        </trans-unit>
        <trans-unit id="211d177d90638c1a066376a7be8af6d0d158c6a4" translate="yes" xml:space="preserve">
          <source>U+000A7</source>
          <target state="translated">U+000A7</target>
        </trans-unit>
        <trans-unit id="d9dc28f2fa7e30eb9c0f439b5750f3838f2cee87" translate="yes" xml:space="preserve">
          <source>U+000A9</source>
          <target state="translated">U+000A9</target>
        </trans-unit>
        <trans-unit id="513de6b2fcc5e7696ac5c1feba0bb18320067443" translate="yes" xml:space="preserve">
          <source>U+000AA</source>
          <target state="translated">U+000AA</target>
        </trans-unit>
        <trans-unit id="d300f7fa4371b181daf488187043f16662716af6" translate="yes" xml:space="preserve">
          <source>U+000AC</source>
          <target state="translated">U+000AC</target>
        </trans-unit>
        <trans-unit id="c7280374ed3343e39969c2ac82c6ddd1f10b831b" translate="yes" xml:space="preserve">
          <source>U+000AE</source>
          <target state="translated">U+000AE</target>
        </trans-unit>
        <trans-unit id="2edb7755d90188c4712771ad592728075ed41e24" translate="yes" xml:space="preserve">
          <source>U+000AF</source>
          <target state="translated">U+000AF</target>
        </trans-unit>
        <trans-unit id="aa7cc7286046f5dd25504a6c0d0a12491fbeda0f" translate="yes" xml:space="preserve">
          <source>U+000B0</source>
          <target state="translated">U+000B0</target>
        </trans-unit>
        <trans-unit id="bc0c6ac2a505a0f8f6872d9acdc254342e989518" translate="yes" xml:space="preserve">
          <source>U+000B1</source>
          <target state="translated">U+000B1</target>
        </trans-unit>
        <trans-unit id="5f6be68884bd3dff697042668c570d5fe480e75c" translate="yes" xml:space="preserve">
          <source>U+000B2</source>
          <target state="translated">U+000B2</target>
        </trans-unit>
        <trans-unit id="e628cf09ed074b1079cb8eb5dd91967d983f7444" translate="yes" xml:space="preserve">
          <source>U+000B3</source>
          <target state="translated">U+000B3</target>
        </trans-unit>
        <trans-unit id="bb8b943f43a734647d4be7fbdf8e9aeb6abe4e97" translate="yes" xml:space="preserve">
          <source>U+000B6</source>
          <target state="translated">U+000B6</target>
        </trans-unit>
        <trans-unit id="6600a279e4eb4336043915244350bcee45219d89" translate="yes" xml:space="preserve">
          <source>U+000B7</source>
          <target state="translated">U+000B7</target>
        </trans-unit>
        <trans-unit id="d0581e625d32999da8ec6ad1c102f7b084fb10d0" translate="yes" xml:space="preserve">
          <source>U+000B9</source>
          <target state="translated">U+000B9</target>
        </trans-unit>
        <trans-unit id="6a0b7c9ae3d95116839c792180becb32a4eb1aa2" translate="yes" xml:space="preserve">
          <source>U+000BA</source>
          <target state="translated">U+000BA</target>
        </trans-unit>
        <trans-unit id="af8d71e515f3816902d8621058dd0a1fffb02d28" translate="yes" xml:space="preserve">
          <source>U+000BC</source>
          <target state="translated">U+000BC</target>
        </trans-unit>
        <trans-unit id="f7929245fb046770d68bd353f0cb56d884faeaf8" translate="yes" xml:space="preserve">
          <source>U+000BD</source>
          <target state="translated">U+000BD</target>
        </trans-unit>
        <trans-unit id="1e389602653ddaef9088ff864e19a57a118668f8" translate="yes" xml:space="preserve">
          <source>U+000BE</source>
          <target state="translated">U+000BE</target>
        </trans-unit>
        <trans-unit id="abf751d4270b495290ba758290cd8cc30e0fc2c2" translate="yes" xml:space="preserve">
          <source>U+000BF</source>
          <target state="translated">U+000BF</target>
        </trans-unit>
        <trans-unit id="1163f1afd4392e3fdc01f33aa911294c9e5579f3" translate="yes" xml:space="preserve">
          <source>U+000C5</source>
          <target state="translated">U+000C5</target>
        </trans-unit>
        <trans-unit id="05b7168d4a3b7e544c07ac7dfac1a23c612ebfa4" translate="yes" xml:space="preserve">
          <source>U+000C6</source>
          <target state="translated">U+000C6</target>
        </trans-unit>
        <trans-unit id="8aefab16dcf0ed235064441308b0156f4f0781b0" translate="yes" xml:space="preserve">
          <source>U+000D0</source>
          <target state="translated">U+000D0</target>
        </trans-unit>
        <trans-unit id="43ca4d9749dbf2b9ba07bbe85b9d3a57230866e2" translate="yes" xml:space="preserve">
          <source>U+000D7</source>
          <target state="translated">U+000D7</target>
        </trans-unit>
        <trans-unit id="b55c75bf336976c87a823de7eaf0c105decaf9ea" translate="yes" xml:space="preserve">
          <source>U+000D8</source>
          <target state="translated">U+000D8</target>
        </trans-unit>
        <trans-unit id="fa31076aac4fc077167ef6b42f2541b7c25f0ff9" translate="yes" xml:space="preserve">
          <source>U+000DE</source>
          <target state="translated">U+000DE</target>
        </trans-unit>
        <trans-unit id="6d8c7be3aae9c7877583cf61703efbfcea6ad185" translate="yes" xml:space="preserve">
          <source>U+000DF</source>
          <target state="translated">U+000DF</target>
        </trans-unit>
        <trans-unit id="2988d0457d6c48a8f06d801f595d2dcef851a96f" translate="yes" xml:space="preserve">
          <source>U+000E5</source>
          <target state="translated">U+000E5</target>
        </trans-unit>
        <trans-unit id="f332510ba8dac469b6d1212966044bf56a7112d6" translate="yes" xml:space="preserve">
          <source>U+000E6</source>
          <target state="translated">U+000E6</target>
        </trans-unit>
        <trans-unit id="12dccbd7c4e0fb222ddd7db261fdf7b54ea85979" translate="yes" xml:space="preserve">
          <source>U+000F0</source>
          <target state="translated">U+000F0</target>
        </trans-unit>
        <trans-unit id="cb2c136f402df9ed86e130e84f1e76ce52a3a8f6" translate="yes" xml:space="preserve">
          <source>U+000F7</source>
          <target state="translated">U+000F7</target>
        </trans-unit>
        <trans-unit id="0de3d46a54055e956c406646c96350c1711258d5" translate="yes" xml:space="preserve">
          <source>U+000F8</source>
          <target state="translated">U+000F8</target>
        </trans-unit>
        <trans-unit id="774a36f37882c565b6e1a8c6da68506e50495f70" translate="yes" xml:space="preserve">
          <source>U+000FE</source>
          <target state="translated">U+000FE</target>
        </trans-unit>
        <trans-unit id="1291de41445c70b8167722b4bad48913e7b5a4a9" translate="yes" xml:space="preserve">
          <source>U+00110</source>
          <target state="translated">U+00110</target>
        </trans-unit>
        <trans-unit id="e389d4dfa1ae96bce106b3994f574f843dc801fb" translate="yes" xml:space="preserve">
          <source>U+00111</source>
          <target state="translated">U+00111</target>
        </trans-unit>
        <trans-unit id="b3a3814c99d325b6730ca42d3cc8cc2b51ceec87" translate="yes" xml:space="preserve">
          <source>U+00127</source>
          <target state="translated">U+00127</target>
        </trans-unit>
        <trans-unit id="4968e90007db7224e93699b7f20b461717d5eb8c" translate="yes" xml:space="preserve">
          <source>U+00131</source>
          <target state="translated">U+00131</target>
        </trans-unit>
        <trans-unit id="88ad15ac149402ea9f1a9bd9fd8ea887293d266a" translate="yes" xml:space="preserve">
          <source>U+00141</source>
          <target state="translated">U+00141</target>
        </trans-unit>
        <trans-unit id="bf6e35a30049db640ab91f1494f1f612637ffe04" translate="yes" xml:space="preserve">
          <source>U+00142</source>
          <target state="translated">U+00142</target>
        </trans-unit>
        <trans-unit id="e7d287bba0dfb9de5eade077b23014aa729f3d6e" translate="yes" xml:space="preserve">
          <source>U+0014A</source>
          <target state="translated">U+0014A</target>
        </trans-unit>
        <trans-unit id="18ae38fd4e2b56f6c821f408380a109cb6acfa94" translate="yes" xml:space="preserve">
          <source>U+0014B</source>
          <target state="translated">U+0014B</target>
        </trans-unit>
        <trans-unit id="39dff18eca38d64db46a57f8de43d0e39f2f1235" translate="yes" xml:space="preserve">
          <source>U+00152</source>
          <target state="translated">U+00152</target>
        </trans-unit>
        <trans-unit id="8651e7b8fce35fd0351a57eb44a27ae9ff54049a" translate="yes" xml:space="preserve">
          <source>U+00153</source>
          <target state="translated">U+00153</target>
        </trans-unit>
        <trans-unit id="2d435468173be8bdfd61aa039618e08e954d15ab" translate="yes" xml:space="preserve">
          <source>U+00195</source>
          <target state="translated">U+00195</target>
        </trans-unit>
        <trans-unit id="a36a973f10dd16c9e619f6603156d35894ce21e0" translate="yes" xml:space="preserve">
          <source>U+0019E</source>
          <target state="translated">U+0019E</target>
        </trans-unit>
        <trans-unit id="d00bad4253303e09a738476636ce66202011ebe4" translate="yes" xml:space="preserve">
          <source>U+001B5</source>
          <target state="translated">U+001B5</target>
        </trans-unit>
        <trans-unit id="3d2010424160248324bda296e63dc5baa5abccc3" translate="yes" xml:space="preserve">
          <source>U+001C2</source>
          <target state="translated">U+001C2</target>
        </trans-unit>
        <trans-unit id="a97e1fa68e72b7a67a42424ce121072cd94ed47f" translate="yes" xml:space="preserve">
          <source>U+00237</source>
          <target state="translated">U+00237</target>
        </trans-unit>
        <trans-unit id="4d69ba9aeef07b7e6aec00ad39a4d321bc1283b1" translate="yes" xml:space="preserve">
          <source>U+00250</source>
          <target state="translated">U+00250</target>
        </trans-unit>
        <trans-unit id="22d1c75b25948d29404ba4763f03160a217f8ce1" translate="yes" xml:space="preserve">
          <source>U+00252</source>
          <target state="translated">U+00252</target>
        </trans-unit>
        <trans-unit id="af8bd3d4ba63fc745ea3e4420a61bdd3a064ee4a" translate="yes" xml:space="preserve">
          <source>U+00254</source>
          <target state="translated">U+00254</target>
        </trans-unit>
        <trans-unit id="e2f72aadbe54071d147f6341efdb29de9ad14e4b" translate="yes" xml:space="preserve">
          <source>U+00256</source>
          <target state="translated">U+00256</target>
        </trans-unit>
        <trans-unit id="3b743298c3105d1e76b2ef99bd922992ca69eb0b" translate="yes" xml:space="preserve">
          <source>U+00259</source>
          <target state="translated">U+00259</target>
        </trans-unit>
        <trans-unit id="f6b5e244fb522c59115f69c715d0354897fe151d" translate="yes" xml:space="preserve">
          <source>U+00263</source>
          <target state="translated">U+00263</target>
        </trans-unit>
        <trans-unit id="84a38ffd2f818a690ebf8ad3c32a0dee3976d3c2" translate="yes" xml:space="preserve">
          <source>U+00264</source>
          <target state="translated">U+00264</target>
        </trans-unit>
        <trans-unit id="ce22b1cc1b063128eb38973ddd4dc12b732b062a" translate="yes" xml:space="preserve">
          <source>U+00265</source>
          <target state="translated">U+00265</target>
        </trans-unit>
        <trans-unit id="3feda74990460ad97bf2af797b4de92ad4e69377" translate="yes" xml:space="preserve">
          <source>U+0026C</source>
          <target state="translated">U+0026C</target>
        </trans-unit>
        <trans-unit id="fb8940a89678648a62ccaeecc567280d198499bf" translate="yes" xml:space="preserve">
          <source>U+0026D</source>
          <target state="translated">U+0026D</target>
        </trans-unit>
        <trans-unit id="30b320089b0ebe1dc924fabdc7959e07f9017558" translate="yes" xml:space="preserve">
          <source>U+0026F</source>
          <target state="translated">U+0026F</target>
        </trans-unit>
        <trans-unit id="7c8f384244ed4d4f3a67d4b88a379a42a62a3450" translate="yes" xml:space="preserve">
          <source>U+00270</source>
          <target state="translated">U+00270</target>
        </trans-unit>
        <trans-unit id="ba23d082c51d02d4d3b0cf3c417e7b0d5b1882fb" translate="yes" xml:space="preserve">
          <source>U+00271</source>
          <target state="translated">U+00271</target>
        </trans-unit>
        <trans-unit id="7636f3f9673f30014a2fdc6478383d9c87614698" translate="yes" xml:space="preserve">
          <source>U+00272</source>
          <target state="translated">U+00272</target>
        </trans-unit>
        <trans-unit id="01dddefc8eae304db1b7e88736a5587a1268359c" translate="yes" xml:space="preserve">
          <source>U+00273</source>
          <target state="translated">U+00273</target>
        </trans-unit>
        <trans-unit id="ce39969ebf02b230d2ba87bed283105fbe1cea59" translate="yes" xml:space="preserve">
          <source>U+00277</source>
          <target state="translated">U+00277</target>
        </trans-unit>
        <trans-unit id="b96d46c699a7e2987266871732af97ce398adc70" translate="yes" xml:space="preserve">
          <source>U+00278</source>
          <target state="translated">U+00278</target>
        </trans-unit>
        <trans-unit id="3d8fcb3eaf7d68d0996ce6a5c5b10bd3f138dc0b" translate="yes" xml:space="preserve">
          <source>U+00279</source>
          <target state="translated">U+00279</target>
        </trans-unit>
        <trans-unit id="295b04b25d0a4364b7d20624bbfd762a1ac2d24d" translate="yes" xml:space="preserve">
          <source>U+0027A</source>
          <target state="translated">U+0027A</target>
        </trans-unit>
        <trans-unit id="428b00c9bfc76f2d3f7e81dbafdef44c81f9383c" translate="yes" xml:space="preserve">
          <source>U+0027B</source>
          <target state="translated">U+0027B</target>
        </trans-unit>
        <trans-unit id="85987a0454fb312e830cb7309532a52d7afc75db" translate="yes" xml:space="preserve">
          <source>U+0027C</source>
          <target state="translated">U+0027C</target>
        </trans-unit>
        <trans-unit id="2558e38e8474acc53ec4982d93e9d13a4bc63041" translate="yes" xml:space="preserve">
          <source>U+0027D</source>
          <target state="translated">U+0027D</target>
        </trans-unit>
        <trans-unit id="42b6e861ffe437b44baf1c237ce68646f708c277" translate="yes" xml:space="preserve">
          <source>U+0027E</source>
          <target state="translated">U+0027E</target>
        </trans-unit>
        <trans-unit id="0e54c84a5b06d72b3c31654eaf05f17a286c77ab" translate="yes" xml:space="preserve">
          <source>U+00282</source>
          <target state="translated">U+00282</target>
        </trans-unit>
        <trans-unit id="9542be08bf2ba79f4ea69b9dce257338ef18751d" translate="yes" xml:space="preserve">
          <source>U+00283</source>
          <target state="translated">U+00283</target>
        </trans-unit>
        <trans-unit id="adab2604f6d1b888adaca2bbfe3af33ea3792f5d" translate="yes" xml:space="preserve">
          <source>U+00287</source>
          <target state="translated">U+00287</target>
        </trans-unit>
        <trans-unit id="b301021720610d1741fdf78006f7bb45c6daee9a" translate="yes" xml:space="preserve">
          <source>U+00288</source>
          <target state="translated">U+00288</target>
        </trans-unit>
        <trans-unit id="57b25fd29c3fe282486ef4b1be0821f6d50446df" translate="yes" xml:space="preserve">
          <source>U+0028A</source>
          <target state="translated">U+0028A</target>
        </trans-unit>
        <trans-unit id="ec9d1ded054e0129d538fb38e06b9d0ce47f8ebf" translate="yes" xml:space="preserve">
          <source>U+0028B</source>
          <target state="translated">U+0028B</target>
        </trans-unit>
        <trans-unit id="801b02166c700cd7542c1d28cc993933d11b5412" translate="yes" xml:space="preserve">
          <source>U+0028C</source>
          <target state="translated">U+0028C</target>
        </trans-unit>
        <trans-unit id="6681e52b2ad820f3911c74349c0ab85b44080f65" translate="yes" xml:space="preserve">
          <source>U+0028D</source>
          <target state="translated">U+0028D</target>
        </trans-unit>
        <trans-unit id="4a3deac43610c6162ac1cb41f886e09400fe08b8" translate="yes" xml:space="preserve">
          <source>U+0028E</source>
          <target state="translated">U+0028E</target>
        </trans-unit>
        <trans-unit id="331e4ea4162519246372acf31bcfccd90b5f2e19" translate="yes" xml:space="preserve">
          <source>U+00290</source>
          <target state="translated">U+00290</target>
        </trans-unit>
        <trans-unit id="73e3b7292e0a22832e3cc4ddc5bb2d2599af142c" translate="yes" xml:space="preserve">
          <source>U+00292</source>
          <target state="translated">U+00292</target>
        </trans-unit>
        <trans-unit id="80d635cdf633fe7e924dbe4468906dbbf7629a1d" translate="yes" xml:space="preserve">
          <source>U+00294</source>
          <target state="translated">U+00294</target>
        </trans-unit>
        <trans-unit id="c16d5472652ef43bd638938bd480a057e0eaacab" translate="yes" xml:space="preserve">
          <source>U+00295</source>
          <target state="translated">U+00295</target>
        </trans-unit>
        <trans-unit id="0e52c441e19ba3e888d10d423e575efde3a6bafa" translate="yes" xml:space="preserve">
          <source>U+00296</source>
          <target state="translated">U+00296</target>
        </trans-unit>
        <trans-unit id="2b16c81e0802bf6f6afb5177341c611f360783b5" translate="yes" xml:space="preserve">
          <source>U+0029E</source>
          <target state="translated">U+0029E</target>
        </trans-unit>
        <trans-unit id="6cb9c239aa546e0dcfb7a419346c4206a2606b50" translate="yes" xml:space="preserve">
          <source>U+002A4</source>
          <target state="translated">U+002A4</target>
        </trans-unit>
        <trans-unit id="097c8d622a507f2de93f19daada70e15265cf1fb" translate="yes" xml:space="preserve">
          <source>U+002A7</source>
          <target state="translated">U+002A7</target>
        </trans-unit>
        <trans-unit id="e877d7918f1b3d8d701dd59cba562a8efd857b1f" translate="yes" xml:space="preserve">
          <source>U+002B0</source>
          <target state="translated">U+002B0</target>
        </trans-unit>
        <trans-unit id="3bf87c668ddfeeee7c2060cef24e5ab77904adaf" translate="yes" xml:space="preserve">
          <source>U+002B2</source>
          <target state="translated">U+002B2</target>
        </trans-unit>
        <trans-unit id="42fd5c55674fbddf51d7de0aefcd3b3fc495919d" translate="yes" xml:space="preserve">
          <source>U+002B3</source>
          <target state="translated">U+002B3</target>
        </trans-unit>
        <trans-unit id="4192c941cf326b515a30c940185e4c0d9c126830" translate="yes" xml:space="preserve">
          <source>U+002B7</source>
          <target state="translated">U+002B7</target>
        </trans-unit>
        <trans-unit id="25b13743aa073ff8722db26721538f49723e0b90" translate="yes" xml:space="preserve">
          <source>U+002B8</source>
          <target state="translated">U+002B8</target>
        </trans-unit>
        <trans-unit id="1d752823fa407500f75196a49ca86514c3c0879d" translate="yes" xml:space="preserve">
          <source>U+002BC</source>
          <target state="translated">U+002BC</target>
        </trans-unit>
        <trans-unit id="03ac95360c12f8887b17b20232d25679453703b0" translate="yes" xml:space="preserve">
          <source>U+002C8</source>
          <target state="translated">U+002C8</target>
        </trans-unit>
        <trans-unit id="a4c78134d2d7d185a40523250f9ee8fd16257a9b" translate="yes" xml:space="preserve">
          <source>U+002CC</source>
          <target state="translated">U+002CC</target>
        </trans-unit>
        <trans-unit id="cccb2ff7d94994055f3a3dc0fc58deb9a341d036" translate="yes" xml:space="preserve">
          <source>U+002D0</source>
          <target state="translated">U+002D0</target>
        </trans-unit>
        <trans-unit id="e29b1c1aafd6ed8fcd9e87c84945aea8b226d734" translate="yes" xml:space="preserve">
          <source>U+002D1</source>
          <target state="translated">U+002D1</target>
        </trans-unit>
        <trans-unit id="6831363163e11e2d59a8ededebfeb95a465ee8fd" translate="yes" xml:space="preserve">
          <source>U+002D2</source>
          <target state="translated">U+002D2</target>
        </trans-unit>
        <trans-unit id="bdda9736ee6f277af7b3ffe1fa983f66286cabef" translate="yes" xml:space="preserve">
          <source>U+002D3</source>
          <target state="translated">U+002D3</target>
        </trans-unit>
        <trans-unit id="25c327b01ba9d5d7d0871dd085d8e57b1c54b413" translate="yes" xml:space="preserve">
          <source>U+002D4</source>
          <target state="translated">U+002D4</target>
        </trans-unit>
        <trans-unit id="ff8fb6fd2ceb7bfc04a2d2559bfa93174d5bae88" translate="yes" xml:space="preserve">
          <source>U+002D5</source>
          <target state="translated">U+002D5</target>
        </trans-unit>
        <trans-unit id="d2c582a407b6e9ccfef06f8f3fde0d05fb039e9e" translate="yes" xml:space="preserve">
          <source>U+002D8</source>
          <target state="translated">U+002D8</target>
        </trans-unit>
        <trans-unit id="129d476bea61b7592a6ca0cf4b20c1135330db3f" translate="yes" xml:space="preserve">
          <source>U+002DC</source>
          <target state="translated">U+002DC</target>
        </trans-unit>
        <trans-unit id="78ecb83484352a8149143cfcb7d53f21893e4267" translate="yes" xml:space="preserve">
          <source>U+002E1</source>
          <target state="translated">U+002E1</target>
        </trans-unit>
        <trans-unit id="4e596f80ec8c828f1336b9e07b3601d2574beafa" translate="yes" xml:space="preserve">
          <source>U+002E2</source>
          <target state="translated">U+002E2</target>
        </trans-unit>
        <trans-unit id="96ca94df5b58f7b819b3d05821fec1d621c2c31b" translate="yes" xml:space="preserve">
          <source>U+002E3</source>
          <target state="translated">U+002E3</target>
        </trans-unit>
        <trans-unit id="5af3e022587eadb32cb8956bc9e0cb23febc482d" translate="yes" xml:space="preserve">
          <source>U+00300</source>
          <target state="translated">U+00300</target>
        </trans-unit>
        <trans-unit id="57384dd962625f4e707ca83219aa4026ba580823" translate="yes" xml:space="preserve">
          <source>U+00301</source>
          <target state="translated">U+00301</target>
        </trans-unit>
        <trans-unit id="25622a25320793f31198afe1e84dd14cdbd7db4e" translate="yes" xml:space="preserve">
          <source>U+00302</source>
          <target state="translated">U+00302</target>
        </trans-unit>
        <trans-unit id="2e2e115497d6c34b4c651551de95cf99f558cf7a" translate="yes" xml:space="preserve">
          <source>U+00303</source>
          <target state="translated">U+00303</target>
        </trans-unit>
        <trans-unit id="b9ad39d07e9c200699b65f3ac1b38bf322374704" translate="yes" xml:space="preserve">
          <source>U+00304</source>
          <target state="translated">U+00304</target>
        </trans-unit>
        <trans-unit id="5fb9f31fe383aad4cb9d7441b9ec3371efa9a4fd" translate="yes" xml:space="preserve">
          <source>U+00305</source>
          <target state="translated">U+00305</target>
        </trans-unit>
        <trans-unit id="186bb579588f3cce4563a9889e2b8107ea903a5d" translate="yes" xml:space="preserve">
          <source>U+00306</source>
          <target state="translated">U+00306</target>
        </trans-unit>
        <trans-unit id="35e6b9edc64633750dd2847c1350f0fa7f18500d" translate="yes" xml:space="preserve">
          <source>U+00307</source>
          <target state="translated">U+00307</target>
        </trans-unit>
        <trans-unit id="df91588955565e56b0ea5b0159eb8b0b6cd086bc" translate="yes" xml:space="preserve">
          <source>U+00308</source>
          <target state="translated">U+00308</target>
        </trans-unit>
        <trans-unit id="3ee774a3cc0cc9fdb1cec91598b3ab8b5a0bea72" translate="yes" xml:space="preserve">
          <source>U+00309</source>
          <target state="translated">U+00309</target>
        </trans-unit>
        <trans-unit id="73c4bfa5fcc98a4fe52861638ccbe57da12866f9" translate="yes" xml:space="preserve">
          <source>U+0030A</source>
          <target state="translated">U+0030A</target>
        </trans-unit>
        <trans-unit id="d80abf6f2f5f7c03b83b0c4bf773a1f3ecf6c879" translate="yes" xml:space="preserve">
          <source>U+0030B</source>
          <target state="translated">U+0030B</target>
        </trans-unit>
        <trans-unit id="cc7bed5251d91f923160d5275b3eeb6ed9309bd4" translate="yes" xml:space="preserve">
          <source>U+0030C</source>
          <target state="translated">U+0030C</target>
        </trans-unit>
        <trans-unit id="464a998232158c39793943141d5b367027d70b0c" translate="yes" xml:space="preserve">
          <source>U+00310</source>
          <target state="translated">U+00310</target>
        </trans-unit>
        <trans-unit id="7b7776208309e402b95172dc44806b4dbde6e413" translate="yes" xml:space="preserve">
          <source>U+00312</source>
          <target state="translated">U+00312</target>
        </trans-unit>
        <trans-unit id="d4b942fd861993b03dab4cdaada7e7c5372e6fcc" translate="yes" xml:space="preserve">
          <source>U+00315</source>
          <target state="translated">U+00315</target>
        </trans-unit>
        <trans-unit id="8ae80e88513cf6d54ed7f44fe46aaa1be02aa584" translate="yes" xml:space="preserve">
          <source>U+0031A</source>
          <target state="translated">U+0031A</target>
        </trans-unit>
        <trans-unit id="c54642fb58a9554774c76d94a3ef8aff97628f55" translate="yes" xml:space="preserve">
          <source>U+00321</source>
          <target state="translated">U+00321</target>
        </trans-unit>
        <trans-unit id="51bca611401ba8b89892496564622660d07ec3bc" translate="yes" xml:space="preserve">
          <source>U+00322</source>
          <target state="translated">U+00322</target>
        </trans-unit>
        <trans-unit id="be27d3066a012f06854ab1f51e9fb893211b8eff" translate="yes" xml:space="preserve">
          <source>U+00327</source>
          <target state="translated">U+00327</target>
        </trans-unit>
        <trans-unit id="3a8260b15bb83ec16781a5d3f77fc9967bd74f0f" translate="yes" xml:space="preserve">
          <source>U+00328</source>
          <target state="translated">U+00328</target>
        </trans-unit>
        <trans-unit id="48692a94d00d38eeb8507caed4505142e3cc14c6" translate="yes" xml:space="preserve">
          <source>U+0032A</source>
          <target state="translated">U+0032A</target>
        </trans-unit>
        <trans-unit id="8fd859998199d54e4fb3893eef33aea9481ac2b6" translate="yes" xml:space="preserve">
          <source>U+00330</source>
          <target state="translated">U+00330</target>
        </trans-unit>
        <trans-unit id="2891e8e914f9f7325c955665fb7eff0a6c27e22d" translate="yes" xml:space="preserve">
          <source>U+00332</source>
          <target state="translated">U+00332</target>
        </trans-unit>
        <trans-unit id="5a7ed7dca2330883f5f7e084a758cf0ca813fb63" translate="yes" xml:space="preserve">
          <source>U+00336</source>
          <target state="translated">U+00336</target>
        </trans-unit>
        <trans-unit id="7a273ba8594fdb20158946bf6a254a0fe61dd80c" translate="yes" xml:space="preserve">
          <source>U+00338</source>
          <target state="translated">U+00338</target>
        </trans-unit>
        <trans-unit id="cd0fb4dc0279677094a443b5ec744ef27bd89968" translate="yes" xml:space="preserve">
          <source>U+0034D</source>
          <target state="translated">U+0034D</target>
        </trans-unit>
        <trans-unit id="7966a98e38de21d2e4a6a2f262d7b3918dcd199c" translate="yes" xml:space="preserve">
          <source>U+00391</source>
          <target state="translated">U+00391</target>
        </trans-unit>
        <trans-unit id="d0b8a82183aad42e701c39ceba7d360218063df9" translate="yes" xml:space="preserve">
          <source>U+00392</source>
          <target state="translated">U+00392</target>
        </trans-unit>
        <trans-unit id="21e769d07a8bac0374b5e1ff35fcdc525c3a0570" translate="yes" xml:space="preserve">
          <source>U+00393</source>
          <target state="translated">U+00393</target>
        </trans-unit>
        <trans-unit id="7f904e2ee1a348881515f7decd9e3f23bf6dc26c" translate="yes" xml:space="preserve">
          <source>U+00394</source>
          <target state="translated">U+00394</target>
        </trans-unit>
        <trans-unit id="874f226781592e1532ed7436b4e42bc8d2623b30" translate="yes" xml:space="preserve">
          <source>U+00395</source>
          <target state="translated">U+00395</target>
        </trans-unit>
        <trans-unit id="cedf61e542d13a336c2a628c1099326c0f63969a" translate="yes" xml:space="preserve">
          <source>U+00396</source>
          <target state="translated">U+00396</target>
        </trans-unit>
        <trans-unit id="3ca968a155717e85467418e67d2610ba368a4d66" translate="yes" xml:space="preserve">
          <source>U+00397</source>
          <target state="translated">U+00397</target>
        </trans-unit>
        <trans-unit id="87ed7c2231196be8910d2431694088b68771153f" translate="yes" xml:space="preserve">
          <source>U+00398</source>
          <target state="translated">U+00398</target>
        </trans-unit>
        <trans-unit id="b51e81c4c9e7a0cd5d61c3962bd3e7e9d53cbad6" translate="yes" xml:space="preserve">
          <source>U+00399</source>
          <target state="translated">U+00399</target>
        </trans-unit>
        <trans-unit id="97851e883fe3fac9942cb0f36a8ececcff49f289" translate="yes" xml:space="preserve">
          <source>U+0039A</source>
          <target state="translated">U+0039A</target>
        </trans-unit>
        <trans-unit id="2d0db6ebb502514c3a6895893038af4b7f8a9fa0" translate="yes" xml:space="preserve">
          <source>U+0039B</source>
          <target state="translated">U+0039B</target>
        </trans-unit>
        <trans-unit id="2af5164dc2a9ba06dbb73864082e76909bdb9cb0" translate="yes" xml:space="preserve">
          <source>U+0039C</source>
          <target state="translated">U+0039C</target>
        </trans-unit>
        <trans-unit id="191917b63fcaf534c3267b3fedac596812b92fa8" translate="yes" xml:space="preserve">
          <source>U+0039D</source>
          <target state="translated">U+0039D</target>
        </trans-unit>
        <trans-unit id="7608890a629a72f35fa9c49e4ddbfc577d3144e8" translate="yes" xml:space="preserve">
          <source>U+0039E</source>
          <target state="translated">U+0039E</target>
        </trans-unit>
        <trans-unit id="8993ed83e6a2420ffd66e48a8e14ff67abfb34a7" translate="yes" xml:space="preserve">
          <source>U+0039F</source>
          <target state="translated">U+0039F</target>
        </trans-unit>
        <trans-unit id="6647e8df9733081f6109aa97088862e0e4abcc2f" translate="yes" xml:space="preserve">
          <source>U+003A0</source>
          <target state="translated">U+003A0</target>
        </trans-unit>
        <trans-unit id="9ade840b2eaccf8824bb01b9a58355de5a4db766" translate="yes" xml:space="preserve">
          <source>U+003A1</source>
          <target state="translated">U+003A1</target>
        </trans-unit>
        <trans-unit id="48c088188b148514e71e0c8cdbaf794530759dde" translate="yes" xml:space="preserve">
          <source>U+003A3</source>
          <target state="translated">U+003A3</target>
        </trans-unit>
        <trans-unit id="251b1650fa3e7210ec229397ee6d7a5700ee5e52" translate="yes" xml:space="preserve">
          <source>U+003A4</source>
          <target state="translated">U+003A4</target>
        </trans-unit>
        <trans-unit id="b76ffee0ec8b7f087677c31f6b2a5f52458a9800" translate="yes" xml:space="preserve">
          <source>U+003A5</source>
          <target state="translated">U+003A5</target>
        </trans-unit>
        <trans-unit id="19ede9f206390ad0ddee6b1fb38a306428305f60" translate="yes" xml:space="preserve">
          <source>U+003A6</source>
          <target state="translated">U+003A6</target>
        </trans-unit>
        <trans-unit id="3ac9debd3d56489ff8cc8f1aceb7a3959cf30586" translate="yes" xml:space="preserve">
          <source>U+003A7</source>
          <target state="translated">U+003A7</target>
        </trans-unit>
        <trans-unit id="f8c95dbd6c98b96c44b7187f2136d2df5b80baa4" translate="yes" xml:space="preserve">
          <source>U+003A8</source>
          <target state="translated">U+003A8</target>
        </trans-unit>
        <trans-unit id="b5b49f6804dd1027a3b1b1149fc05e55ea028657" translate="yes" xml:space="preserve">
          <source>U+003A9</source>
          <target state="translated">U+003A9</target>
        </trans-unit>
        <trans-unit id="7df4c4d8574e0257f7b554e72154b40a4f961e40" translate="yes" xml:space="preserve">
          <source>U+003B1</source>
          <target state="translated">U+003B1</target>
        </trans-unit>
        <trans-unit id="38b05037dfcca16e3bc0aec40a79fe5f3f7a6bae" translate="yes" xml:space="preserve">
          <source>U+003B2</source>
          <target state="translated">U+003B2</target>
        </trans-unit>
        <trans-unit id="2017af14c2418d90536823e9c1cfb41a73a97387" translate="yes" xml:space="preserve">
          <source>U+003B3</source>
          <target state="translated">U+003B3</target>
        </trans-unit>
        <trans-unit id="8489235bd9087a3790bb0c0a99390be264d8d42d" translate="yes" xml:space="preserve">
          <source>U+003B4</source>
          <target state="translated">U+003B4</target>
        </trans-unit>
        <trans-unit id="0ad7e02862c7e6a2b120177c0a5806e81ecd90fa" translate="yes" xml:space="preserve">
          <source>U+003B5</source>
          <target state="translated">U+003B5</target>
        </trans-unit>
        <trans-unit id="f86fb3232412afb5ca7a0568cb934725d5ae2571" translate="yes" xml:space="preserve">
          <source>U+003B6</source>
          <target state="translated">U+003B6</target>
        </trans-unit>
        <trans-unit id="ad44f693fd33cb248ddd8ec41a912b824b27afa8" translate="yes" xml:space="preserve">
          <source>U+003B7</source>
          <target state="translated">U+003B7</target>
        </trans-unit>
        <trans-unit id="1c8798670c5f19f4d4b30e3ea0398df6f3da0e38" translate="yes" xml:space="preserve">
          <source>U+003B8</source>
          <target state="translated">U+003B8</target>
        </trans-unit>
        <trans-unit id="a514df160b479280b550a9dbd13772aa1835ad42" translate="yes" xml:space="preserve">
          <source>U+003B9</source>
          <target state="translated">U+003B9</target>
        </trans-unit>
        <trans-unit id="104b9e81ad12eeb0661deea9dda2b3c4723787b1" translate="yes" xml:space="preserve">
          <source>U+003BA</source>
          <target state="translated">U+003BA</target>
        </trans-unit>
        <trans-unit id="b4a242d16cea0ddfebf1382603d6d19208d8cae8" translate="yes" xml:space="preserve">
          <source>U+003BB</source>
          <target state="translated">U+003BB</target>
        </trans-unit>
        <trans-unit id="50db9f12fc5a232bf3528c5a10d947e05c5f9c2a" translate="yes" xml:space="preserve">
          <source>U+003BC</source>
          <target state="translated">U+003BC</target>
        </trans-unit>
        <trans-unit id="7635ce1de66b2503108277821ff32585538c38f6" translate="yes" xml:space="preserve">
          <source>U+003BD</source>
          <target state="translated">U+003BD</target>
        </trans-unit>
        <trans-unit id="ed86215a643340439e73b43c12ec22cd74a09342" translate="yes" xml:space="preserve">
          <source>U+003BE</source>
          <target state="translated">U+003BE</target>
        </trans-unit>
        <trans-unit id="5b74cb8e40d2b1ed841b6067924c1bb3f3081218" translate="yes" xml:space="preserve">
          <source>U+003BF</source>
          <target state="translated">U+003BF</target>
        </trans-unit>
        <trans-unit id="8cf73e2899a7d36e9f5bbd4b5a425f706ef33084" translate="yes" xml:space="preserve">
          <source>U+003C0</source>
          <target state="translated">U+003C0</target>
        </trans-unit>
        <trans-unit id="ee39537c45109587e3c6142781d56c0bd39af74c" translate="yes" xml:space="preserve">
          <source>U+003C1</source>
          <target state="translated">U+003C1</target>
        </trans-unit>
        <trans-unit id="fc117fba7f15ba9d71216e3c390473eee4d9691d" translate="yes" xml:space="preserve">
          <source>U+003C2</source>
          <target state="translated">U+003C2</target>
        </trans-unit>
        <trans-unit id="eaabe77bc0eacfab586dd67830aa955b7ecb2abb" translate="yes" xml:space="preserve">
          <source>U+003C3</source>
          <target state="translated">U+003C3</target>
        </trans-unit>
        <trans-unit id="886f6e97a866bf8552f82f80b5cd54d69deb6edc" translate="yes" xml:space="preserve">
          <source>U+003C4</source>
          <target state="translated">U+003C4</target>
        </trans-unit>
        <trans-unit id="37f57a526420b1b434ced0d421633312bfacb43a" translate="yes" xml:space="preserve">
          <source>U+003C5</source>
          <target state="translated">U+003C5</target>
        </trans-unit>
        <trans-unit id="47fa09bd231213c6ef064645c7a9a37d01d7a340" translate="yes" xml:space="preserve">
          <source>U+003C6</source>
          <target state="translated">U+003C6</target>
        </trans-unit>
        <trans-unit id="05bd5f84778ecbe4800ec121d5cff09af25879b2" translate="yes" xml:space="preserve">
          <source>U+003C7</source>
          <target state="translated">U+003C7</target>
        </trans-unit>
        <trans-unit id="721198dd581f50ac452dd324cdd78024e3f0ea83" translate="yes" xml:space="preserve">
          <source>U+003C8</source>
          <target state="translated">U+003C8</target>
        </trans-unit>
        <trans-unit id="cb5185c50b8e1cc18ef11fcd725b6f5f34fbd6be" translate="yes" xml:space="preserve">
          <source>U+003C9</source>
          <target state="translated">U+003C9</target>
        </trans-unit>
        <trans-unit id="9f6a8ca363f10b4b3b309c17eaadf1051f19e694" translate="yes" xml:space="preserve">
          <source>U+003D0</source>
          <target state="translated">U+003D0</target>
        </trans-unit>
        <trans-unit id="bc5c825b8dc84bc4cd8b8d4ea4013440a734f35d" translate="yes" xml:space="preserve">
          <source>U+003D1</source>
          <target state="translated">U+003D1</target>
        </trans-unit>
        <trans-unit id="7aea0cab7b710b4d843d21594fbe14aefcfed4b0" translate="yes" xml:space="preserve">
          <source>U+003D5</source>
          <target state="translated">U+003D5</target>
        </trans-unit>
        <trans-unit id="b4f7595d714f72bfe55c1fcb84a3e89af7755a50" translate="yes" xml:space="preserve">
          <source>U+003D6</source>
          <target state="translated">U+003D6</target>
        </trans-unit>
        <trans-unit id="4401a4d25fbd6623fc6012216b21bcd1a2a739e3" translate="yes" xml:space="preserve">
          <source>U+003D8</source>
          <target state="translated">U+003D8</target>
        </trans-unit>
        <trans-unit id="e478f2f51e8d87db9b42731a4f38cfdf153a1ab7" translate="yes" xml:space="preserve">
          <source>U+003D9</source>
          <target state="translated">U+003D9</target>
        </trans-unit>
        <trans-unit id="fd18e42bf717cf4641f290ef53660e47279580ad" translate="yes" xml:space="preserve">
          <source>U+003DA</source>
          <target state="translated">U+003DA</target>
        </trans-unit>
        <trans-unit id="b675867190ca1ec0938e31a984cdf05979ecd3e0" translate="yes" xml:space="preserve">
          <source>U+003DB</source>
          <target state="translated">U+003DB</target>
        </trans-unit>
        <trans-unit id="92b09d13f646288f372d15ca7398b72236d3e04b" translate="yes" xml:space="preserve">
          <source>U+003DC</source>
          <target state="translated">U+003DC</target>
        </trans-unit>
        <trans-unit id="3ade589f9dd6d374474593df9134c7efebec6b94" translate="yes" xml:space="preserve">
          <source>U+003DD</source>
          <target state="translated">U+003DD</target>
        </trans-unit>
        <trans-unit id="0a92af0f627aa4fcc46123b87ceee9c99b396e0e" translate="yes" xml:space="preserve">
          <source>U+003DE</source>
          <target state="translated">U+003DE</target>
        </trans-unit>
        <trans-unit id="59c206717250d5c1b1abee82cd488c369d4eae18" translate="yes" xml:space="preserve">
          <source>U+003DF</source>
          <target state="translated">U+003DF</target>
        </trans-unit>
        <trans-unit id="5b469342b60deb763e4d94f943821445e3cd4910" translate="yes" xml:space="preserve">
          <source>U+003E0</source>
          <target state="translated">U+003E0</target>
        </trans-unit>
        <trans-unit id="0f3e4bc0231981c839c803015c8410b20dfc4bcd" translate="yes" xml:space="preserve">
          <source>U+003E1</source>
          <target state="translated">U+003E1</target>
        </trans-unit>
        <trans-unit id="07fc86395ddc909da4d31f240fb5e1cb0c418d8e" translate="yes" xml:space="preserve">
          <source>U+003F0</source>
          <target state="translated">U+003F0</target>
        </trans-unit>
        <trans-unit id="07cd0547b13165fe26a097f326f44a691e487328" translate="yes" xml:space="preserve">
          <source>U+003F1</source>
          <target state="translated">U+003F1</target>
        </trans-unit>
        <trans-unit id="7b7b6789e29307728ee9f301af1e0d351e536bf5" translate="yes" xml:space="preserve">
          <source>U+003F4</source>
          <target state="translated">U+003F4</target>
        </trans-unit>
        <trans-unit id="4901bc1852316df9e9dc777fdb7aad5592a6a0f7" translate="yes" xml:space="preserve">
          <source>U+003F5</source>
          <target state="translated">U+003F5</target>
        </trans-unit>
        <trans-unit id="92620f957c75e73c58904d8b0538e74afadfb90c" translate="yes" xml:space="preserve">
          <source>U+003F6</source>
          <target state="translated">U+003F6</target>
        </trans-unit>
        <trans-unit id="c5566e46f42aac1f8e11d42dcfc259d87a7a10fb" translate="yes" xml:space="preserve">
          <source>U+01D2C</source>
          <target state="translated">U+01D2C</target>
        </trans-unit>
        <trans-unit id="37b10b6a06b252506911945e6db92b0b9c6d95f4" translate="yes" xml:space="preserve">
          <source>U+01D2E</source>
          <target state="translated">U+01D2E</target>
        </trans-unit>
        <trans-unit id="a00d8269be4c3eb9f91c1b40696ae76cc8589071" translate="yes" xml:space="preserve">
          <source>U+01D30</source>
          <target state="translated">U+01D30</target>
        </trans-unit>
        <trans-unit id="5c29e525faf0a50aecb6fb3a5f9b7e486e1ef1e9" translate="yes" xml:space="preserve">
          <source>U+01D31</source>
          <target state="translated">U+01D31</target>
        </trans-unit>
        <trans-unit id="99eec604971e8c65be4840320e7a69306ad535a6" translate="yes" xml:space="preserve">
          <source>U+01D33</source>
          <target state="translated">U+01D33</target>
        </trans-unit>
        <trans-unit id="440561aa92670ad776b4e75b23fad5219dee516a" translate="yes" xml:space="preserve">
          <source>U+01D34</source>
          <target state="translated">U+01D34</target>
        </trans-unit>
        <trans-unit id="fbb7a3bc03c96572e4387ff20df34fbc05f8fb3f" translate="yes" xml:space="preserve">
          <source>U+01D35</source>
          <target state="translated">U+01D35</target>
        </trans-unit>
        <trans-unit id="eb47bce466c235deca517ea5540e4d147ebe1a9e" translate="yes" xml:space="preserve">
          <source>U+01D36</source>
          <target state="translated">U+01D36</target>
        </trans-unit>
        <trans-unit id="17959ef44c1b0741106ba78930d26a1c07a3caf0" translate="yes" xml:space="preserve">
          <source>U+01D37</source>
          <target state="translated">U+01D37</target>
        </trans-unit>
        <trans-unit id="cb222e37dc1ee67b19e08f29dd06ed5347e1fa23" translate="yes" xml:space="preserve">
          <source>U+01D38</source>
          <target state="translated">U+01D38</target>
        </trans-unit>
        <trans-unit id="f848ac41c0abe672127b3606e9d0c9b2c905c84b" translate="yes" xml:space="preserve">
          <source>U+01D39</source>
          <target state="translated">U+01D39</target>
        </trans-unit>
        <trans-unit id="156f084d069ee73bdf463b033eff3e6fc5d68a08" translate="yes" xml:space="preserve">
          <source>U+01D3A</source>
          <target state="translated">U+01D3A</target>
        </trans-unit>
        <trans-unit id="c6774c926ad79fecccfd4abca40531a24c3b7a55" translate="yes" xml:space="preserve">
          <source>U+01D3C</source>
          <target state="translated">U+01D3C</target>
        </trans-unit>
        <trans-unit id="20d904a6751c57b2859b8c67b0b30073b01cc53b" translate="yes" xml:space="preserve">
          <source>U+01D3E</source>
          <target state="translated">U+01D3E</target>
        </trans-unit>
        <trans-unit id="d053d05169ebb281dedc9ae9dfe2590a6c369c1d" translate="yes" xml:space="preserve">
          <source>U+01D3F</source>
          <target state="translated">U+01D3F</target>
        </trans-unit>
        <trans-unit id="9b2ab1ad7be189b75bfb7de1714d1ad8a985c107" translate="yes" xml:space="preserve">
          <source>U+01D40</source>
          <target state="translated">U+01D40</target>
        </trans-unit>
        <trans-unit id="34aae8c7365b76e9e21ce5f42ad04f1e94b1f3b8" translate="yes" xml:space="preserve">
          <source>U+01D41</source>
          <target state="translated">U+01D41</target>
        </trans-unit>
        <trans-unit id="441ba9dede9005279c903a6e57f96fe78206c8d8" translate="yes" xml:space="preserve">
          <source>U+01D42</source>
          <target state="translated">U+01D42</target>
        </trans-unit>
        <trans-unit id="163b08686ee14dbd18f23a98a52a47fd62d588ee" translate="yes" xml:space="preserve">
          <source>U+01D43</source>
          <target state="translated">U+01D43</target>
        </trans-unit>
        <trans-unit id="30fdf3ad9db991dd0466575db2f89a26a852c7ee" translate="yes" xml:space="preserve">
          <source>U+01D45</source>
          <target state="translated">U+01D45</target>
        </trans-unit>
        <trans-unit id="797e81a34a07bac310482131acefad71a5abef2d" translate="yes" xml:space="preserve">
          <source>U+01D47</source>
          <target state="translated">U+01D47</target>
        </trans-unit>
        <trans-unit id="a411f60238db6f6b63261d8c07617746ca432266" translate="yes" xml:space="preserve">
          <source>U+01D48</source>
          <target state="translated">U+01D48</target>
        </trans-unit>
        <trans-unit id="c9fb343fc16c5b72e32f29927937a89b7af099fb" translate="yes" xml:space="preserve">
          <source>U+01D49</source>
          <target state="translated">U+01D49</target>
        </trans-unit>
        <trans-unit id="27b54333a235194c6ac53a272d181cb739911513" translate="yes" xml:space="preserve">
          <source>U+01D4B</source>
          <target state="translated">U+01D4B</target>
        </trans-unit>
        <trans-unit id="afb04e59e5d5261a7404bb86c49e2dda11e7d50f" translate="yes" xml:space="preserve">
          <source>U+01D4D</source>
          <target state="translated">U+01D4D</target>
        </trans-unit>
        <trans-unit id="0455ff4d12b80da3fab3d52ffb0b623e56441abb" translate="yes" xml:space="preserve">
          <source>U+01D4F</source>
          <target state="translated">U+01D4F</target>
        </trans-unit>
        <trans-unit id="dbee94c172667d77dbb460fe05b105b373ed9eb9" translate="yes" xml:space="preserve">
          <source>U+01D50</source>
          <target state="translated">U+01D50</target>
        </trans-unit>
        <trans-unit id="ca425c53e63ac2819b4b1438353c6f41043d7a41" translate="yes" xml:space="preserve">
          <source>U+01D52</source>
          <target state="translated">U+01D52</target>
        </trans-unit>
        <trans-unit id="1510ed9914e77d0f8fd3e94ad0c76b070ae53d74" translate="yes" xml:space="preserve">
          <source>U+01D56</source>
          <target state="translated">U+01D56</target>
        </trans-unit>
        <trans-unit id="39f62505bed4b421bf0728e1b93111477d77435c" translate="yes" xml:space="preserve">
          <source>U+01D57</source>
          <target state="translated">U+01D57</target>
        </trans-unit>
        <trans-unit id="8b29aea27d0cf669223fb74be47e4710519173e1" translate="yes" xml:space="preserve">
          <source>U+01D58</source>
          <target state="translated">U+01D58</target>
        </trans-unit>
        <trans-unit id="88779dd2e4508d37bd39f537906180eb80a4ba7b" translate="yes" xml:space="preserve">
          <source>U+01D5B</source>
          <target state="translated">U+01D5B</target>
        </trans-unit>
        <trans-unit id="6c05ec71eeb4ed95030bc369513a9c776e552879" translate="yes" xml:space="preserve">
          <source>U+01D5D</source>
          <target state="translated">U+01D5D</target>
        </trans-unit>
        <trans-unit id="435d4825e1c943f064c7a47783bfcbdf7cde0725" translate="yes" xml:space="preserve">
          <source>U+01D5E</source>
          <target state="translated">U+01D5E</target>
        </trans-unit>
        <trans-unit id="0aa39de854d3a50b9b10d2e69c0d4d92bc238432" translate="yes" xml:space="preserve">
          <source>U+01D5F</source>
          <target state="translated">U+01D5F</target>
        </trans-unit>
        <trans-unit id="4a0cee142db79062d3341c0f8505515c14d123fe" translate="yes" xml:space="preserve">
          <source>U+01D60</source>
          <target state="translated">U+01D60</target>
        </trans-unit>
        <trans-unit id="e741d8c3aa7d60204eda169c57106e15f8882d08" translate="yes" xml:space="preserve">
          <source>U+01D61</source>
          <target state="translated">U+01D61</target>
        </trans-unit>
        <trans-unit id="d4bc07109e6ceceb3eaccbb2b8e8939ab0efbd49" translate="yes" xml:space="preserve">
          <source>U+01D62</source>
          <target state="translated">U+01D62</target>
        </trans-unit>
        <trans-unit id="50763e8cb88d2a94fbd6e8bbf258ac2f3d205929" translate="yes" xml:space="preserve">
          <source>U+01D63</source>
          <target state="translated">U+01D63</target>
        </trans-unit>
        <trans-unit id="346d9c11c21d1b7105090de2749717a2d445a941" translate="yes" xml:space="preserve">
          <source>U+01D64</source>
          <target state="translated">U+01D64</target>
        </trans-unit>
        <trans-unit id="da208e5126e0afc89dce4184ae73f645f4278d97" translate="yes" xml:space="preserve">
          <source>U+01D65</source>
          <target state="translated">U+01D65</target>
        </trans-unit>
        <trans-unit id="822153e6da7056909aa3045783b805c02b93fbc4" translate="yes" xml:space="preserve">
          <source>U+01D66</source>
          <target state="translated">U+01D66</target>
        </trans-unit>
        <trans-unit id="38a14ca2e36f22c3c3809fa99933315f23f92ccc" translate="yes" xml:space="preserve">
          <source>U+01D67</source>
          <target state="translated">U+01D67</target>
        </trans-unit>
        <trans-unit id="20f1483de267b860c85f652204cd1f93f696da21" translate="yes" xml:space="preserve">
          <source>U+01D68</source>
          <target state="translated">U+01D68</target>
        </trans-unit>
        <trans-unit id="233d5e218fc2a0060e8c1bc038d1a74beeb754ce" translate="yes" xml:space="preserve">
          <source>U+01D69</source>
          <target state="translated">U+01D69</target>
        </trans-unit>
        <trans-unit id="5ffdf6e6becfd7d7a6907d2806ba362cb32ee7ab" translate="yes" xml:space="preserve">
          <source>U+01D6A</source>
          <target state="translated">U+01D6A</target>
        </trans-unit>
        <trans-unit id="54a5801c603f0530be0e5268e32f06e62414e7cc" translate="yes" xml:space="preserve">
          <source>U+01D9C</source>
          <target state="translated">U+01D9C</target>
        </trans-unit>
        <trans-unit id="e2edeb19ea8e681fefbd9a4bcbfe98ba0e602949" translate="yes" xml:space="preserve">
          <source>U+01DA0</source>
          <target state="translated">U+01DA0</target>
        </trans-unit>
        <trans-unit id="c8b08720266cd22f34f16a43a75856cd70610c2e" translate="yes" xml:space="preserve">
          <source>U+01DA5</source>
          <target state="translated">U+01DA5</target>
        </trans-unit>
        <trans-unit id="c4ee296bbf06e4d45d1ea5ed87a8a04b75e1e207" translate="yes" xml:space="preserve">
          <source>U+01DB2</source>
          <target state="translated">U+01DB2</target>
        </trans-unit>
        <trans-unit id="a44d758f0df9a4bfd941e5517bb24c8174dacfc6" translate="yes" xml:space="preserve">
          <source>U+01DBB</source>
          <target state="translated">U+01DBB</target>
        </trans-unit>
        <trans-unit id="9465fb99cea4715205a1c75bb4fce4ef25e41dcd" translate="yes" xml:space="preserve">
          <source>U+01DBF</source>
          <target state="translated">U+01DBF</target>
        </trans-unit>
        <trans-unit id="3de5f445040ec9f82e5d0f7be1114da98b3824e9" translate="yes" xml:space="preserve">
          <source>U+02002</source>
          <target state="translated">U+02002</target>
        </trans-unit>
        <trans-unit id="7ed4f9267e6ab7118d848989813ef0313baef1c1" translate="yes" xml:space="preserve">
          <source>U+02003</source>
          <target state="translated">U+02003</target>
        </trans-unit>
        <trans-unit id="42f12996d3ec39f6df05c0141c3c1c2960e3b4d3" translate="yes" xml:space="preserve">
          <source>U+02005</source>
          <target state="translated">U+02005</target>
        </trans-unit>
        <trans-unit id="dc54e003671d7d9356c197db1df194b01cdc025f" translate="yes" xml:space="preserve">
          <source>U+02009</source>
          <target state="translated">U+02009</target>
        </trans-unit>
        <trans-unit id="6d199f8b861652f6b03dd0371fdf6cef0a20bb9e" translate="yes" xml:space="preserve">
          <source>U+0200A</source>
          <target state="translated">U+0200A</target>
        </trans-unit>
        <trans-unit id="54b2c267ddbbf1a38b0df143b7feae19c2b3b675" translate="yes" xml:space="preserve">
          <source>U+02013</source>
          <target state="translated">U+02013</target>
        </trans-unit>
        <trans-unit id="91a455cf9bf5641d8dcb36e61a713b743388b2b9" translate="yes" xml:space="preserve">
          <source>U+02014</source>
          <target state="translated">U+02014</target>
        </trans-unit>
        <trans-unit id="871fd5b4639ffc22262b27271eebe1f5a15dfa8b" translate="yes" xml:space="preserve">
          <source>U+02016</source>
          <target state="translated">U+02016</target>
        </trans-unit>
        <trans-unit id="01237e76c48f125ae7368ff228668715b09fd166" translate="yes" xml:space="preserve">
          <source>U+02018</source>
          <target state="translated">U+02018</target>
        </trans-unit>
        <trans-unit id="0eb233c9d60b05a1ebd74cbe88384226b43cdb6d" translate="yes" xml:space="preserve">
          <source>U+02019</source>
          <target state="translated">U+02019</target>
        </trans-unit>
        <trans-unit id="27981c42fbe101279cd9112d5d0e4a5967f72e54" translate="yes" xml:space="preserve">
          <source>U+0201B</source>
          <target state="translated">U+0201B</target>
        </trans-unit>
        <trans-unit id="fec2f513e523c411070eaf46be64b07cf927cbba" translate="yes" xml:space="preserve">
          <source>U+0201C</source>
          <target state="translated">U+0201C</target>
        </trans-unit>
        <trans-unit id="05b273439e23dbd70de0618defd73bd52fafefd8" translate="yes" xml:space="preserve">
          <source>U+0201D</source>
          <target state="translated">U+0201D</target>
        </trans-unit>
        <trans-unit id="d9a8337f65d4bfe3fdd44241cb7c936971b12090" translate="yes" xml:space="preserve">
          <source>U+02020</source>
          <target state="translated">U+02020</target>
        </trans-unit>
        <trans-unit id="51e65c64dccac09993ecb39aba5db77093ced71a" translate="yes" xml:space="preserve">
          <source>U+02021</source>
          <target state="translated">U+02021</target>
        </trans-unit>
        <trans-unit id="6a89805f557530dd85e0f992fd6f2b9ab2119a0f" translate="yes" xml:space="preserve">
          <source>U+02022</source>
          <target state="translated">U+02022</target>
        </trans-unit>
        <trans-unit id="606d247e38e4f88d07ac7af7b3a2988d674ab100" translate="yes" xml:space="preserve">
          <source>U+02026</source>
          <target state="translated">U+02026</target>
        </trans-unit>
        <trans-unit id="7069c8a14244c42d1eb9eeafe2a54d3707e415a2" translate="yes" xml:space="preserve">
          <source>U+02030</source>
          <target state="translated">U+02030</target>
        </trans-unit>
        <trans-unit id="51ee0c647f9e7d54d78c0bca676090c3ed3a58ab" translate="yes" xml:space="preserve">
          <source>U+02031</source>
          <target state="translated">U+02031</target>
        </trans-unit>
        <trans-unit id="d35b0db70efbcf055ebe5d255382dac5a8c513a9" translate="yes" xml:space="preserve">
          <source>U+02032</source>
          <target state="translated">U+02032</target>
        </trans-unit>
        <trans-unit id="aff69f7e2c75a413ebf0ae8e5e2e3274abef57cf" translate="yes" xml:space="preserve">
          <source>U+02033</source>
          <target state="translated">U+02033</target>
        </trans-unit>
        <trans-unit id="5d913be71042ef8f5aaec8feff826a19c6bafa80" translate="yes" xml:space="preserve">
          <source>U+02034</source>
          <target state="translated">U+02034</target>
        </trans-unit>
        <trans-unit id="16c2015f83babb15b41b582ae1ad4b93020c1e8e" translate="yes" xml:space="preserve">
          <source>U+02035</source>
          <target state="translated">U+02035</target>
        </trans-unit>
        <trans-unit id="7e44d236062ccca1c221b6d032404da42950e91e" translate="yes" xml:space="preserve">
          <source>U+02036</source>
          <target state="translated">U+02036</target>
        </trans-unit>
        <trans-unit id="2844451d093078b267408c29d08b80334758c880" translate="yes" xml:space="preserve">
          <source>U+02037</source>
          <target state="translated">U+02037</target>
        </trans-unit>
        <trans-unit id="98711fdfbbcf42c62a5faf024882880528e15cf8" translate="yes" xml:space="preserve">
          <source>U+02039</source>
          <target state="translated">U+02039</target>
        </trans-unit>
        <trans-unit id="41ffd3912c77f96e037ea691fad61cdbf02c8b23" translate="yes" xml:space="preserve">
          <source>U+0203A</source>
          <target state="translated">U+0203A</target>
        </trans-unit>
        <trans-unit id="b8dc2d1d755a5fdfbc9b3bf3479d34e1c241cadf" translate="yes" xml:space="preserve">
          <source>U+0203C</source>
          <target state="translated">U+0203C</target>
        </trans-unit>
        <trans-unit id="09fd53c1a858647b42d511d9c015fee67fb9445c" translate="yes" xml:space="preserve">
          <source>U+02040</source>
          <target state="translated">U+02040</target>
        </trans-unit>
        <trans-unit id="b477796eb380471732cec950b3b8f7940a1e7e45" translate="yes" xml:space="preserve">
          <source>U+02049</source>
          <target state="translated">U+02049</target>
        </trans-unit>
        <trans-unit id="ca926b0118288b830cb51c220e41ee7e352a28a9" translate="yes" xml:space="preserve">
          <source>U+02057</source>
          <target state="translated">U+02057</target>
        </trans-unit>
        <trans-unit id="1bc69948707de37d18ec28f69dd19f065541aae7" translate="yes" xml:space="preserve">
          <source>U+0205D</source>
          <target state="translated">U+0205D</target>
        </trans-unit>
        <trans-unit id="d39d51da22a7906847da6453bde31ff3b754dfa9" translate="yes" xml:space="preserve">
          <source>U+02060</source>
          <target state="translated">U+02060</target>
        </trans-unit>
        <trans-unit id="1efdd22dc573d2edef8ee5ea3382e63d224d137e" translate="yes" xml:space="preserve">
          <source>U+02070</source>
          <target state="translated">U+02070</target>
        </trans-unit>
        <trans-unit id="1dc71366ffb5b8b3e001f3a9aa2f6bb12d28be57" translate="yes" xml:space="preserve">
          <source>U+02071</source>
          <target state="translated">U+02071</target>
        </trans-unit>
        <trans-unit id="4dd066f38efb209c9f79538e5a2ea272214b954d" translate="yes" xml:space="preserve">
          <source>U+02074</source>
          <target state="translated">U+02074</target>
        </trans-unit>
        <trans-unit id="f9ddb001c9f5fd2e27fbae237f25c28b8f5ae871" translate="yes" xml:space="preserve">
          <source>U+02075</source>
          <target state="translated">U+02075</target>
        </trans-unit>
        <trans-unit id="cdd7f27ef18f2611da391c880f368056e0477cc1" translate="yes" xml:space="preserve">
          <source>U+02076</source>
          <target state="translated">U+02076</target>
        </trans-unit>
        <trans-unit id="1aef93443bcba12e0e269ea6437722a5efd9165b" translate="yes" xml:space="preserve">
          <source>U+02077</source>
          <target state="translated">U+02077</target>
        </trans-unit>
        <trans-unit id="9dff77c28d6e4f9f9a7a07a1a99dbfde46ad0e2d" translate="yes" xml:space="preserve">
          <source>U+02078</source>
          <target state="translated">U+02078</target>
        </trans-unit>
        <trans-unit id="ca05f7941a68cd5dbe4ad921bce62a99bc20a13e" translate="yes" xml:space="preserve">
          <source>U+02079</source>
          <target state="translated">U+02079</target>
        </trans-unit>
        <trans-unit id="18a3eef792215619326e47c5780075df279de886" translate="yes" xml:space="preserve">
          <source>U+0207A</source>
          <target state="translated">U+0207A</target>
        </trans-unit>
        <trans-unit id="6859918ed86a97585a8af7827424e777f0012f32" translate="yes" xml:space="preserve">
          <source>U+0207B</source>
          <target state="translated">U+0207B</target>
        </trans-unit>
        <trans-unit id="4f9765389af5519dc7a0d091c472c04d25872e51" translate="yes" xml:space="preserve">
          <source>U+0207C</source>
          <target state="translated">U+0207C</target>
        </trans-unit>
        <trans-unit id="dbd3025a6eeefb504b83034db7784310cd98a7b8" translate="yes" xml:space="preserve">
          <source>U+0207D</source>
          <target state="translated">U+0207D</target>
        </trans-unit>
        <trans-unit id="2a01a9a590ac5e58a83b33d92499326aa532de31" translate="yes" xml:space="preserve">
          <source>U+0207E</source>
          <target state="translated">U+0207E</target>
        </trans-unit>
        <trans-unit id="522f4f2ebb95bd280743693b122524e8e120ca0b" translate="yes" xml:space="preserve">
          <source>U+0207F</source>
          <target state="translated">U+0207F</target>
        </trans-unit>
        <trans-unit id="854460d95686b5484c63e7b1c97dc7aec182f465" translate="yes" xml:space="preserve">
          <source>U+02080</source>
          <target state="translated">U+02080</target>
        </trans-unit>
        <trans-unit id="bb66a953411c5a7aa98e0ccd90b088e7efca0359" translate="yes" xml:space="preserve">
          <source>U+02081</source>
          <target state="translated">U+02081</target>
        </trans-unit>
        <trans-unit id="0c9776b8d8584f3558900c0e35ed1c199b85dc56" translate="yes" xml:space="preserve">
          <source>U+02082</source>
          <target state="translated">U+02082</target>
        </trans-unit>
        <trans-unit id="188629784648ed64f4880102c6ef53e00c48260f" translate="yes" xml:space="preserve">
          <source>U+02083</source>
          <target state="translated">U+02083</target>
        </trans-unit>
        <trans-unit id="ced37ed4c1992fa0c2e4792186605cdbbfe0813b" translate="yes" xml:space="preserve">
          <source>U+02084</source>
          <target state="translated">U+02084</target>
        </trans-unit>
        <trans-unit id="1c6821bf6c9d056467564e078d12132617914b74" translate="yes" xml:space="preserve">
          <source>U+02085</source>
          <target state="translated">U+02085</target>
        </trans-unit>
        <trans-unit id="f2c71c2c5946e5589ab2fbec4497aea575670406" translate="yes" xml:space="preserve">
          <source>U+02086</source>
          <target state="translated">U+02086</target>
        </trans-unit>
        <trans-unit id="f8b7a8d02fe7d8fd1e4e41165a96012f3085e3aa" translate="yes" xml:space="preserve">
          <source>U+02087</source>
          <target state="translated">U+02087</target>
        </trans-unit>
        <trans-unit id="e83c0c08dcd85b6a1d1e03d24eb32bfacef748a3" translate="yes" xml:space="preserve">
          <source>U+02088</source>
          <target state="translated">U+02088</target>
        </trans-unit>
        <trans-unit id="88afb3350de2e79fc09ed34801b089b50c323102" translate="yes" xml:space="preserve">
          <source>U+02089</source>
          <target state="translated">U+02089</target>
        </trans-unit>
        <trans-unit id="477cf57fceee603207b7029bea84e0d917ed01f2" translate="yes" xml:space="preserve">
          <source>U+0208A</source>
          <target state="translated">U+0208A</target>
        </trans-unit>
        <trans-unit id="23ef044b8d9c1cffcbe8f0bcd2bcd3dc5402e505" translate="yes" xml:space="preserve">
          <source>U+0208B</source>
          <target state="translated">U+0208B</target>
        </trans-unit>
        <trans-unit id="c6576c517955cbddf0fd30aec93e93789c487e12" translate="yes" xml:space="preserve">
          <source>U+0208C</source>
          <target state="translated">U+0208C</target>
        </trans-unit>
        <trans-unit id="d8029bd98cc0ac6ce5f6867fe9af4fb3de6a6b00" translate="yes" xml:space="preserve">
          <source>U+0208D</source>
          <target state="translated">U+0208D</target>
        </trans-unit>
        <trans-unit id="26b965df9ca2cbda682041b8cec3843d73d50b3d" translate="yes" xml:space="preserve">
          <source>U+0208E</source>
          <target state="translated">U+0208E</target>
        </trans-unit>
        <trans-unit id="da03f3f8ee238f200d4eddc0c4bd224192f75622" translate="yes" xml:space="preserve">
          <source>U+02090</source>
          <target state="translated">U+02090</target>
        </trans-unit>
        <trans-unit id="e7a5cb7c2c27388b416316e0acd0df63aef6d4f3" translate="yes" xml:space="preserve">
          <source>U+02091</source>
          <target state="translated">U+02091</target>
        </trans-unit>
        <trans-unit id="1a07878c5fdec82f99db1dc83ca11685edb72205" translate="yes" xml:space="preserve">
          <source>U+02092</source>
          <target state="translated">U+02092</target>
        </trans-unit>
        <trans-unit id="d85957c055f87ab66f8bb33e718c3eaf011c2d48" translate="yes" xml:space="preserve">
          <source>U+02093</source>
          <target state="translated">U+02093</target>
        </trans-unit>
        <trans-unit id="fc73e56e067c604fb38ed9d86ccf090e38a9f7c9" translate="yes" xml:space="preserve">
          <source>U+02094</source>
          <target state="translated">U+02094</target>
        </trans-unit>
        <trans-unit id="f890547c349527828a298f56e7fdc0da52c6e83a" translate="yes" xml:space="preserve">
          <source>U+02095</source>
          <target state="translated">U+02095</target>
        </trans-unit>
        <trans-unit id="5fd296e5bda2cce5c69dd8bd57d96e1e0d22b9b2" translate="yes" xml:space="preserve">
          <source>U+02096</source>
          <target state="translated">U+02096</target>
        </trans-unit>
        <trans-unit id="5c1c15f178eb0b654388c5f6475b3ba25b33c6dd" translate="yes" xml:space="preserve">
          <source>U+02097</source>
          <target state="translated">U+02097</target>
        </trans-unit>
        <trans-unit id="9d30a621292caf7bece2e9ce2d8b9581d55c8f2e" translate="yes" xml:space="preserve">
          <source>U+02098</source>
          <target state="translated">U+02098</target>
        </trans-unit>
        <trans-unit id="7e31400a5922fae3a81d4a1c28d6ad22d2bb926a" translate="yes" xml:space="preserve">
          <source>U+02099</source>
          <target state="translated">U+02099</target>
        </trans-unit>
        <trans-unit id="b8e32228d0b21d4afdfb09b9eb01835c4488956d" translate="yes" xml:space="preserve">
          <source>U+0209A</source>
          <target state="translated">U+0209A</target>
        </trans-unit>
        <trans-unit id="4ae8c33eeb20b986b3a68dd5c8f755537da0cc35" translate="yes" xml:space="preserve">
          <source>U+0209B</source>
          <target state="translated">U+0209B</target>
        </trans-unit>
        <trans-unit id="22883db9c2eae90f058a6ec060a0a1d7934fc524" translate="yes" xml:space="preserve">
          <source>U+0209C</source>
          <target state="translated">U+0209C</target>
        </trans-unit>
        <trans-unit id="a770d073d828312a3f412b4d196fcea78f022c6b" translate="yes" xml:space="preserve">
          <source>U+020A7</source>
          <target state="translated">U+020A7</target>
        </trans-unit>
        <trans-unit id="cec998138ab5bb31b2262d17296ad23086f8304d" translate="yes" xml:space="preserve">
          <source>U+020AC</source>
          <target state="translated">U+020AC</target>
        </trans-unit>
        <trans-unit id="be69f61217e1f1748ad03bdc4546176950dda473" translate="yes" xml:space="preserve">
          <source>U+020D0</source>
          <target state="translated">U+020D0</target>
        </trans-unit>
        <trans-unit id="ce511e7f9775929b60852032b4fa5b32681c7cb8" translate="yes" xml:space="preserve">
          <source>U+020D1</source>
          <target state="translated">U+020D1</target>
        </trans-unit>
        <trans-unit id="91b07feaa744c6688774083feb3443b13189fb5f" translate="yes" xml:space="preserve">
          <source>U+020D2</source>
          <target state="translated">U+020D2</target>
        </trans-unit>
        <trans-unit id="af681668f18319aab998e021e28763dd7d0f3f17" translate="yes" xml:space="preserve">
          <source>U+020D6</source>
          <target state="translated">U+020D6</target>
        </trans-unit>
        <trans-unit id="570c4c40f536d880f35d90049a5fc80334ded35b" translate="yes" xml:space="preserve">
          <source>U+020D7</source>
          <target state="translated">U+020D7</target>
        </trans-unit>
        <trans-unit id="f9c8acbccb3bb9e59c23842d6854d6ffe3cda209" translate="yes" xml:space="preserve">
          <source>U+020DB</source>
          <target state="translated">U+020DB</target>
        </trans-unit>
        <trans-unit id="124a18fae2c40bf7ad2fc342bead50ee6a3edb2e" translate="yes" xml:space="preserve">
          <source>U+020DC</source>
          <target state="translated">U+020DC</target>
        </trans-unit>
        <trans-unit id="9fcbf1d8195b405d6c289e7de0d461ccdeb5126d" translate="yes" xml:space="preserve">
          <source>U+020DD</source>
          <target state="translated">U+020DD</target>
        </trans-unit>
        <trans-unit id="12f776f6e3a074855f26553b489117cb5664c07d" translate="yes" xml:space="preserve">
          <source>U+020DE</source>
          <target state="translated">U+020DE</target>
        </trans-unit>
        <trans-unit id="476a6d0d44d7e0ee0c7a1eb7300c6ccb5e8e8819" translate="yes" xml:space="preserve">
          <source>U+020DF</source>
          <target state="translated">U+020DF</target>
        </trans-unit>
        <trans-unit id="36a22cb9ea7baffde06e396cfebdc0661c04e913" translate="yes" xml:space="preserve">
          <source>U+020E1</source>
          <target state="translated">U+020E1</target>
        </trans-unit>
        <trans-unit id="4fd6aa654f40bc0d1fec9761c3b30fa972c4b26e" translate="yes" xml:space="preserve">
          <source>U+020E4</source>
          <target state="translated">U+020E4</target>
        </trans-unit>
        <trans-unit id="e63bdbad9a6fbf0dbf6715d8bec7bcd775432592" translate="yes" xml:space="preserve">
          <source>U+020E7</source>
          <target state="translated">U+020E7</target>
        </trans-unit>
        <trans-unit id="b1a6163cfe2122326bc02c224adf7f8d6e5ffba7" translate="yes" xml:space="preserve">
          <source>U+020E8</source>
          <target state="translated">U+020E8</target>
        </trans-unit>
        <trans-unit id="3850520adad69b9d57a55e0a79e674a7bf6967c2" translate="yes" xml:space="preserve">
          <source>U+020E9</source>
          <target state="translated">U+020E9</target>
        </trans-unit>
        <trans-unit id="e45a7120fdc5d1b21987b099aeed9919e3d159bf" translate="yes" xml:space="preserve">
          <source>U+020EC</source>
          <target state="translated">U+020EC</target>
        </trans-unit>
        <trans-unit id="96a99a0c9bbd7eaa955fe8b3d30fe4dfec582fd9" translate="yes" xml:space="preserve">
          <source>U+020ED</source>
          <target state="translated">U+020ED</target>
        </trans-unit>
        <trans-unit id="3babb4708c5e4b432d55e2eff2f03ed9b62870db" translate="yes" xml:space="preserve">
          <source>U+020EE</source>
          <target state="translated">U+020EE</target>
        </trans-unit>
        <trans-unit id="fc835fa7d02a8c817884cb00384b5e9922183683" translate="yes" xml:space="preserve">
          <source>U+020EF</source>
          <target state="translated">U+020EF</target>
        </trans-unit>
        <trans-unit id="0c6129bb507bb470263fc68a8d02831a53adfac3" translate="yes" xml:space="preserve">
          <source>U+020F0</source>
          <target state="translated">U+020F0</target>
        </trans-unit>
        <trans-unit id="2adc2c6bebe3339c446d7e23907f1dc655e420a2" translate="yes" xml:space="preserve">
          <source>U+02102</source>
          <target state="translated">U+02102</target>
        </trans-unit>
        <trans-unit id="2afc9e72e8df124d80b35edc62c73cb1f19c10d6" translate="yes" xml:space="preserve">
          <source>U+02107</source>
          <target state="translated">U+02107</target>
        </trans-unit>
        <trans-unit id="ebfed4281bd65acfa46591c8ddd1317cfd1b5242" translate="yes" xml:space="preserve">
          <source>U+0210A</source>
          <target state="translated">U+0210A</target>
        </trans-unit>
        <trans-unit id="024787cf22bf2842dba0be7847ca8f38dc5fa7b4" translate="yes" xml:space="preserve">
          <source>U+0210B</source>
          <target state="translated">U+0210B</target>
        </trans-unit>
        <trans-unit id="2feefe2362663ee1ffb0fc6da3896a6df35b143e" translate="yes" xml:space="preserve">
          <source>U+0210C</source>
          <target state="translated">U+0210C</target>
        </trans-unit>
        <trans-unit id="663f2a23d864546260f30cd2d124b343002e3958" translate="yes" xml:space="preserve">
          <source>U+0210D</source>
          <target state="translated">U+0210D</target>
        </trans-unit>
        <trans-unit id="fbc22138cd7a815897649944bd0296b4b1707e29" translate="yes" xml:space="preserve">
          <source>U+0210E</source>
          <target state="translated">U+0210E</target>
        </trans-unit>
        <trans-unit id="8258fdd464e12d5471e5dccf50cccae82495f1a1" translate="yes" xml:space="preserve">
          <source>U+0210F</source>
          <target state="translated">U+0210F</target>
        </trans-unit>
        <trans-unit id="517e7c3cf117e768d82906bdea2b9d73b0d093b9" translate="yes" xml:space="preserve">
          <source>U+02110</source>
          <target state="translated">U+02110</target>
        </trans-unit>
        <trans-unit id="bca7eb892f1a6edce7356fe44b05b07629e09e34" translate="yes" xml:space="preserve">
          <source>U+02111</source>
          <target state="translated">U+02111</target>
        </trans-unit>
        <trans-unit id="bee1d61c619164abe275a3c3556fbb2ac4e97e19" translate="yes" xml:space="preserve">
          <source>U+02112</source>
          <target state="translated">U+02112</target>
        </trans-unit>
        <trans-unit id="342959e0e16070b1247f1f44564ecb3ec9396b91" translate="yes" xml:space="preserve">
          <source>U+02113</source>
          <target state="translated">U+02113</target>
        </trans-unit>
        <trans-unit id="298b156c4985cc6f1df475cf209f863ef4cc4b3a" translate="yes" xml:space="preserve">
          <source>U+02115</source>
          <target state="translated">U+02115</target>
        </trans-unit>
        <trans-unit id="456a13c7b9fab48f48291b017dd4ee50155f5964" translate="yes" xml:space="preserve">
          <source>U+02116</source>
          <target state="translated">U+02116</target>
        </trans-unit>
        <trans-unit id="325b4a2c0faae3a209a87bf5e3a5c83401a0aaff" translate="yes" xml:space="preserve">
          <source>U+02118</source>
          <target state="translated">U+02118</target>
        </trans-unit>
        <trans-unit id="dae9b18d73050b644687a61effdf17b8f841e040" translate="yes" xml:space="preserve">
          <source>U+02119</source>
          <target state="translated">U+02119</target>
        </trans-unit>
        <trans-unit id="8288406fd14e141f15c517704db3a02746c05fba" translate="yes" xml:space="preserve">
          <source>U+0211A</source>
          <target state="translated">U+0211A</target>
        </trans-unit>
        <trans-unit id="a23b5f3fd36ff2842b6c25933ff3f70b6fd66af2" translate="yes" xml:space="preserve">
          <source>U+0211B</source>
          <target state="translated">U+0211B</target>
        </trans-unit>
        <trans-unit id="72a9ec39387b201efc778708d7f6d52069ad7b13" translate="yes" xml:space="preserve">
          <source>U+0211C</source>
          <target state="translated">U+0211C</target>
        </trans-unit>
        <trans-unit id="9dfccf15a23a02ba3b953d1c7d7f6abc05fa682c" translate="yes" xml:space="preserve">
          <source>U+0211D</source>
          <target state="translated">U+0211D</target>
        </trans-unit>
        <trans-unit id="6c51822bf19550c0ee6d5a384cc0cf486b30a8f4" translate="yes" xml:space="preserve">
          <source>U+0211E</source>
          <target state="translated">U+0211E</target>
        </trans-unit>
        <trans-unit id="0a39b4ce2d86e268da567ab2a2a342737157f4f7" translate="yes" xml:space="preserve">
          <source>U+02122</source>
          <target state="translated">U+02122</target>
        </trans-unit>
        <trans-unit id="ff13fb5cd296523bc4b707cf6e46dc6766380430" translate="yes" xml:space="preserve">
          <source>U+02124</source>
          <target state="translated">U+02124</target>
        </trans-unit>
        <trans-unit id="f037e7e6304e03a5f7f4aac86130df6dc576311a" translate="yes" xml:space="preserve">
          <source>U+02126</source>
          <target state="translated">U+02126</target>
        </trans-unit>
        <trans-unit id="7d2655b3517935e484d6b1a4e997ff5843a31e87" translate="yes" xml:space="preserve">
          <source>U+02127</source>
          <target state="translated">U+02127</target>
        </trans-unit>
        <trans-unit id="cb7b969c3501850a4060cfd7e7f59c0da7c3cb7c" translate="yes" xml:space="preserve">
          <source>U+02128</source>
          <target state="translated">U+02128</target>
        </trans-unit>
        <trans-unit id="b79f1ccc58a0757660d0bc91a00ac119559e2338" translate="yes" xml:space="preserve">
          <source>U+02129</source>
          <target state="translated">U+02129</target>
        </trans-unit>
        <trans-unit id="239a3c1c1d9c7ae49e284a49968bcabd8c5b7042" translate="yes" xml:space="preserve">
          <source>U+0212B</source>
          <target state="translated">U+0212B</target>
        </trans-unit>
        <trans-unit id="92faddf2df3101e2ea354ca32e0b3f3543850210" translate="yes" xml:space="preserve">
          <source>U+0212C</source>
          <target state="translated">U+0212C</target>
        </trans-unit>
        <trans-unit id="36e6bb2196feb03f4b43d924bb79e3c8be31b9a9" translate="yes" xml:space="preserve">
          <source>U+0212D</source>
          <target state="translated">U+0212D</target>
        </trans-unit>
        <trans-unit id="16660c15da1843f5c1a0edfd5cb7b5a695e2e521" translate="yes" xml:space="preserve">
          <source>U+0212F</source>
          <target state="translated">U+0212F</target>
        </trans-unit>
        <trans-unit id="aaeb74116b049a77e6ec9ce1d001dfd92cbaf0c5" translate="yes" xml:space="preserve">
          <source>U+02130</source>
          <target state="translated">U+02130</target>
        </trans-unit>
        <trans-unit id="8dd9faccb501c29739c49458d2a93b67ef810716" translate="yes" xml:space="preserve">
          <source>U+02131</source>
          <target state="translated">U+02131</target>
        </trans-unit>
        <trans-unit id="e099608b2d63cb110f6dac82c14749c62295dc74" translate="yes" xml:space="preserve">
          <source>U+02132</source>
          <target state="translated">U+02132</target>
        </trans-unit>
        <trans-unit id="7fce3e99b8d386428a44b9ba9cd77168f4a90b54" translate="yes" xml:space="preserve">
          <source>U+02133</source>
          <target state="translated">U+02133</target>
        </trans-unit>
        <trans-unit id="0fc13fe64d053aa6289ea319c71a4691d5ed6634" translate="yes" xml:space="preserve">
          <source>U+02134</source>
          <target state="translated">U+02134</target>
        </trans-unit>
        <trans-unit id="1563aedef419208c50595e16109be4c42f5a4364" translate="yes" xml:space="preserve">
          <source>U+02135</source>
          <target state="translated">U+02135</target>
        </trans-unit>
        <trans-unit id="3891e0fc176e12065431c43db1f74fc494411f82" translate="yes" xml:space="preserve">
          <source>U+02136</source>
          <target state="translated">U+02136</target>
        </trans-unit>
        <trans-unit id="a593920648b7a0628980af8818432607aee2b26b" translate="yes" xml:space="preserve">
          <source>U+02137</source>
          <target state="translated">U+02137</target>
        </trans-unit>
        <trans-unit id="09c96fc69d62f78396fe578ae0a734946ca45119" translate="yes" xml:space="preserve">
          <source>U+02138</source>
          <target state="translated">U+02138</target>
        </trans-unit>
        <trans-unit id="9fd776e8fb45b0a99d86b77b183c64b5128e4853" translate="yes" xml:space="preserve">
          <source>U+02139</source>
          <target state="translated">U+02139</target>
        </trans-unit>
        <trans-unit id="d0888576b0913d65a8450a31d9441aaccf7e4435" translate="yes" xml:space="preserve">
          <source>U+0213C</source>
          <target state="translated">U+0213C</target>
        </trans-unit>
        <trans-unit id="fb3fbd77e803f3bf4cab253f0bf3f908c7ad718c" translate="yes" xml:space="preserve">
          <source>U+0213D</source>
          <target state="translated">U+0213D</target>
        </trans-unit>
        <trans-unit id="e440bfd991013a84e4602155792d47bba2093ba8" translate="yes" xml:space="preserve">
          <source>U+0213E</source>
          <target state="translated">U+0213E</target>
        </trans-unit>
        <trans-unit id="29227106656a985eab84a0e228e588ed042c2b81" translate="yes" xml:space="preserve">
          <source>U+0213F</source>
          <target state="translated">U+0213F</target>
        </trans-unit>
        <trans-unit id="fb9d15cdeb6082c60f875c40cf5bf8071c89e5a0" translate="yes" xml:space="preserve">
          <source>U+02140</source>
          <target state="translated">U+02140</target>
        </trans-unit>
        <trans-unit id="25c33074d8075a29f499832613c3cbf490c765f4" translate="yes" xml:space="preserve">
          <source>U+02141</source>
          <target state="translated">U+02141</target>
        </trans-unit>
        <trans-unit id="8d593c3ede8a900f775ba49e99e44b2441f0a82a" translate="yes" xml:space="preserve">
          <source>U+02142</source>
          <target state="translated">U+02142</target>
        </trans-unit>
        <trans-unit id="e15e780412bb80d5134e94a8aaf019527b157036" translate="yes" xml:space="preserve">
          <source>U+02143</source>
          <target state="translated">U+02143</target>
        </trans-unit>
        <trans-unit id="0985adfd896a1876bf4859487cc1416a43097be3" translate="yes" xml:space="preserve">
          <source>U+02144</source>
          <target state="translated">U+02144</target>
        </trans-unit>
        <trans-unit id="e5df3ea43ae68e5c9216957b9ac77eebbf312d22" translate="yes" xml:space="preserve">
          <source>U+02145</source>
          <target state="translated">U+02145</target>
        </trans-unit>
        <trans-unit id="aad47338d4f31abfaf8fecb938a8c63fc984db6b" translate="yes" xml:space="preserve">
          <source>U+02146</source>
          <target state="translated">U+02146</target>
        </trans-unit>
        <trans-unit id="4836d6e98db2972df1e4babecc7404f8bc565dec" translate="yes" xml:space="preserve">
          <source>U+02147</source>
          <target state="translated">U+02147</target>
        </trans-unit>
        <trans-unit id="44211683b83cd1eb2cd8bf74acfd897248f656f2" translate="yes" xml:space="preserve">
          <source>U+02148</source>
          <target state="translated">U+02148</target>
        </trans-unit>
        <trans-unit id="dfb201593b6ac1e23bf414f8d22093a663430ce9" translate="yes" xml:space="preserve">
          <source>U+02149</source>
          <target state="translated">U+02149</target>
        </trans-unit>
        <trans-unit id="0d9c341d85541da5c6a240341d4c4e4e55f76198" translate="yes" xml:space="preserve">
          <source>U+0214A</source>
          <target state="translated">U+0214A</target>
        </trans-unit>
        <trans-unit id="7873467b6bc36a6507b4fafecb646c0ca8ffa812" translate="yes" xml:space="preserve">
          <source>U+0214B</source>
          <target state="translated">U+0214B</target>
        </trans-unit>
        <trans-unit id="376ab1c1f47a89fd01e932866b5d73e84c2440c3" translate="yes" xml:space="preserve">
          <source>U+02150</source>
          <target state="translated">U+02150</target>
        </trans-unit>
        <trans-unit id="77b878b5221c6ada93e6b498e2c83435ffd5f286" translate="yes" xml:space="preserve">
          <source>U+02151</source>
          <target state="translated">U+02151</target>
        </trans-unit>
        <trans-unit id="0a7e78b5f11ac79a707d1472e388ac1ff6e6bffd" translate="yes" xml:space="preserve">
          <source>U+02152</source>
          <target state="translated">U+02152</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
