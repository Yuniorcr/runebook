<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="julia">
    <body>
      <group id="julia">
        <trans-unit id="5bf36d0687ba161c1ddd5ae9a710ac6b84c65e73" translate="yes" xml:space="preserve">
          <source>Greater-Than Above Less-Than Above Double-Line Equal</source>
          <target state="translated">大至上 大至下 大至上 ダブルライン イコール</target>
        </trans-unit>
        <trans-unit id="cda9caba673dd1973f8c7d113746b0e633f4f938" translate="yes" xml:space="preserve">
          <source>Greater-Than Above Similar Above Less-Than</source>
          <target state="translated">大規模以上 同等以上 大規模以上 同等以上 大規模以上 同等未満</target>
        </trans-unit>
        <trans-unit id="3a03ecfc7255d8cacd17931a2c17d195720afbd9" translate="yes" xml:space="preserve">
          <source>Greater-Than Above Similar Or Equal</source>
          <target state="translated">類似または同等以上</target>
        </trans-unit>
        <trans-unit id="eed03df20a091917ea38ceacb7e9c2b67e0f9bb2" translate="yes" xml:space="preserve">
          <source>Greater-Than Above Slanted Equal Above Less-Than Above Slanted Equal</source>
          <target state="translated">斜め上の大以上 斜め上の等倍以上 斜め上の等倍未満 斜め上の等倍以上</target>
        </trans-unit>
        <trans-unit id="ec6a31bc7051547d44e2c612da8aa15b61e41be6" translate="yes" xml:space="preserve">
          <source>Greater-Than And Not Approximate</source>
          <target state="translated">大なり小なり</target>
        </trans-unit>
        <trans-unit id="852f9d0047fa29fbc8fb2cb24463f569deef89ef" translate="yes" xml:space="preserve">
          <source>Greater-Than And Single-Line Not Equal To</source>
          <target state="translated">グレーター以上のものと単線のものは同じではありません。</target>
        </trans-unit>
        <trans-unit id="52afc7afef44a974f7bc9b05b1e17bf964f408a0" translate="yes" xml:space="preserve">
          <source>Greater-Than Beside Less-Than</source>
          <target state="translated">大なり小なり</target>
        </trans-unit>
        <trans-unit id="8002394d4a4c3c62e2b6ebf6a841410b987f3fe3" translate="yes" xml:space="preserve">
          <source>Greater-Than But Not Equal To / Greater Than But Not Equal To</source>
          <target state="translated">Greater-Than But Not Equal To/Greater Than But Not Equal To</target>
        </trans-unit>
        <trans-unit id="9f51323c1f1f2bd6fed8b0133087b13833db9603" translate="yes" xml:space="preserve">
          <source>Greater-Than But Not Equal To / Greater Than But Not Equal To + Variation Selector-1</source>
          <target state="translated">より大きいが等しくない/より大きいが等しくない+変形セレクタ-1</target>
        </trans-unit>
        <trans-unit id="a9e5efe496a2b31f56957d4e597885897f8e0eb9" translate="yes" xml:space="preserve">
          <source>Greater-Than But Not Equivalent To / Greater Than But Not Equivalent To</source>
          <target state="translated">グレーター・ザン・バット・ノット・イコール・ツー/グレーター・ザン・バット・ノット・イコール・ツー</target>
        </trans-unit>
        <trans-unit id="98eff7a1e60f594f0f81d4c3e83cbf5209423bb1" translate="yes" xml:space="preserve">
          <source>Greater-Than Closed By Curve</source>
          <target state="translated">曲線で閉じられたグレーター・ハン</target>
        </trans-unit>
        <trans-unit id="099b37f93e6b34dbfa7c526c5fa3f13b59c30374" translate="yes" xml:space="preserve">
          <source>Greater-Than Closed By Curve Above Slanted Equal</source>
          <target state="translated">傾斜したイコール上の曲線によって閉じられた大-中</target>
        </trans-unit>
        <trans-unit id="bb2d6f56b2861cf6b4d17b1cfddecb19b41dd882" translate="yes" xml:space="preserve">
          <source>Greater-Than Equal To Or Less-Than / Greater Than Equal To Or Less Than</source>
          <target state="translated">等しくても以下であっても、同等以上であっても以下であっても、同等以上であっても以下であっても、同等以上であっても以下であっても、同等以上であっても以下であっても、同等以上であっても以下であっても、同等以上であっても以下であっても、同等以上であっても以下であっても、同等以上であっても以下であっても、同等以上であっても以下であっても、同等以上であっても以下であっても、同等以上であっても以下であっても、同等以上であっても以下であっても、同等以上であっても以下であっても、同等以上であっても以下であっても</target>
        </trans-unit>
        <trans-unit id="1f9f324edcdf276db2fba93d474c1d37dd1409bf" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Approximate</source>
          <target state="translated">大なり小なり</target>
        </trans-unit>
        <trans-unit id="816b73122f7826a76fc5a27a59be585ac1c20c8e" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Equal To / Greater Than Or Equal To</source>
          <target state="translated">グレーター・ザン・イコール・トゥ/グレーター・ザン・イコール・トゥ</target>
        </trans-unit>
        <trans-unit id="22f6cd5ba77c22771ae0dcb6dec580b58470b15f" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Equivalent To / Greater Than Or Equivalent To</source>
          <target state="translated">大規模以上または同等のもの/大規模以上または同等のもの</target>
        </trans-unit>
        <trans-unit id="da7070ff7fe0d357657567e892ae9e792dd0711c" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Less-Than / Greater Than Or Less Than</source>
          <target state="translated">大なり小なり/大なり小なり</target>
        </trans-unit>
        <trans-unit id="fc2308a37940cf5145837f4b055616cdf8ed8663" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Slanted Equal To</source>
          <target state="translated">大至上または斜行に等しい</target>
        </trans-unit>
        <trans-unit id="fc0db4bdca25b60daf5c07123869e9c3373f86d1" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Slanted Equal To + Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay</source>
          <target state="translated">長尺スラッシュオーバーレイ/非スペーシング長尺スラッシュオーバーレイを組み合わせて、長尺ソリダスオーバーレイと同等以上の大きさまたは斜めにします。</target>
        </trans-unit>
        <trans-unit id="3d2877fe16bd8c1aff6ca20742e54d7c40adcfb5" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Slanted Equal To With Dot Above</source>
          <target state="translated">上のドットを持つことに等しい Greater-Than または斜めに</target>
        </trans-unit>
        <trans-unit id="5b85b82c5dfec29b3e76371a3c759b7b564d0dcc" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Slanted Equal To With Dot Above Left</source>
          <target state="translated">左の上のドットを持つことに等しい Greater-Than または斜めの</target>
        </trans-unit>
        <trans-unit id="324053698d665835c3c8543b9475493cada464ce" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Slanted Equal To With Dot Inside</source>
          <target state="translated">ドットの内側にあるものと同等以上の大きさまたは傾斜</target>
        </trans-unit>
        <trans-unit id="eaf2aeee67af979dcb4bf973f1c28801c9b3c428" translate="yes" xml:space="preserve">
          <source>Greater-Than Over Equal To / Greater Than Over Equal To</source>
          <target state="translated">等価以上/等価以上の大いなるもの</target>
        </trans-unit>
        <trans-unit id="88e04ffb7bbd7b8b561e5e62dab6aaf4e8ec7d4c" translate="yes" xml:space="preserve">
          <source>Greater-Than Overlapping Less-Than</source>
          <target state="translated">大至上 重複 小至上</target>
        </trans-unit>
        <trans-unit id="7eb5603be44b831a023cfdcd22f839b5f6f5bded" translate="yes" xml:space="preserve">
          <source>Greater-Than With Circle Inside</source>
          <target state="translated">内側に円を入れたグレーター・ハン</target>
        </trans-unit>
        <trans-unit id="f158072571829726fe84a7ad0ce7a50ef1ab0879" translate="yes" xml:space="preserve">
          <source>Greater-Than With Dot / Greater Than With Dot</source>
          <target state="translated">グレーター・タン・ウィズ・ドット/グレーター・タン・ウィズ・ドット</target>
        </trans-unit>
        <trans-unit id="209f35de5184bc36aa0d1b903151a9fc65c6ba61" translate="yes" xml:space="preserve">
          <source>Greater-Than With Question Mark Above</source>
          <target state="translated">上記のクエスチョンマークが付いているグレーター・ハン</target>
        </trans-unit>
        <trans-unit id="1bd3d8bbe04802c889994d907ddead65a92d7cca" translate="yes" xml:space="preserve">
          <source>Greater-than comparison operator. Falls back to &lt;code&gt;y &amp;lt; x&lt;/code&gt;.</source>
          <target state="translated">大なり比較演算子。 &lt;code&gt;y &amp;lt; x&lt;/code&gt; フォールバックします。</target>
        </trans-unit>
        <trans-unit id="ed9b75dd8da9fbc05fe433d4046e50ff253af5b8" translate="yes" xml:space="preserve">
          <source>Greater-than-or-equals comparison operator. Falls back to &lt;code&gt;y &amp;lt;= x&lt;/code&gt;.</source>
          <target state="translated">より大きいか等しい比較演算子。 &lt;code&gt;y &amp;lt;= x&lt;/code&gt; フォールバックします。</target>
        </trans-unit>
        <trans-unit id="c889dfd5914acacbd51c9ee1f6424d7475f18ba9" translate="yes" xml:space="preserve">
          <source>Greatest common (positive) divisor (or zero if &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are both zero).</source>
          <target state="translated">最大公約数（正）の除数（ &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; が両方ともゼロの場合はゼロ）。</target>
        </trans-unit>
        <trans-unit id="b3c118d12ee713605454a73fa83e73fd62da99f2" translate="yes" xml:space="preserve">
          <source>Greatest common (positive) divisor (or zero if &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are both zero). The arguments may be integer and rational numbers.</source>
          <target state="translated">最大公約数（正の）除数（または &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; が両方ともゼロの場合はゼロ）。引数は整数と有理数です。</target>
        </trans-unit>
        <trans-unit id="3c137f18236c59d67effecc9926b91bc4e6c388c" translate="yes" xml:space="preserve">
          <source>Greek Beta Symbol / Greek Small Letter Curled Beta</source>
          <target state="translated">ギリシャ語のベータ記号/ギリシャ語の小さな文字は、ベータをカールさせた</target>
        </trans-unit>
        <trans-unit id="c90a544a84e41b0027e35535de12e9412929c3b9" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Alpha</source>
          <target state="translated">ギリシャ文字アルファ</target>
        </trans-unit>
        <trans-unit id="034c000ae09a7efb7dcd09b84c993f24a59b651a" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Beta</source>
          <target state="translated">ギリシャ資本の手紙ベータ</target>
        </trans-unit>
        <trans-unit id="d91481b132bdcebe4f898c637891a19c7e0d2807" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Chi</source>
          <target state="translated">ギリシアの大文字カイ</target>
        </trans-unit>
        <trans-unit id="3e715476cf54a47fc160c1f17257b6e0b611dcf0" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Delta</source>
          <target state="translated">ギリシャ資本の手紙デルタ</target>
        </trans-unit>
        <trans-unit id="e7b36e8f2dc5d428f4c0fbae5314c79d701290b8" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Epsilon</source>
          <target state="translated">ギリシャの大文字イプシロン</target>
        </trans-unit>
        <trans-unit id="9632923c81e91309b0197e9f6256e5ddc583b3f1" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Eta</source>
          <target state="translated">ギリシャ語の大文字イータ</target>
        </trans-unit>
        <trans-unit id="b63912e4ec51d609e069730c367de176e6e9799e" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Gamma</source>
          <target state="translated">ギリシャ資本の手紙ガンマ</target>
        </trans-unit>
        <trans-unit id="003ecb167b62284b9bb24641dd3e450774ffb206" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Iota</source>
          <target state="translated">ギリシャ文字イオタ</target>
        </trans-unit>
        <trans-unit id="97e0c3c41b2cd617ba1f3aefc97784af90e81883" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Kappa</source>
          <target state="translated">ギリシャ文字のカッパ</target>
        </trans-unit>
        <trans-unit id="8766675df925b8c25168f5080a3ffb3054a6bbf7" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Lamda / Greek Capital Letter Lambda</source>
          <target state="translated">ギリシャ語の大文字ラムダ/ギリシャ語の大文字ラムダ</target>
        </trans-unit>
        <trans-unit id="93f0db4c50dab02a7cf643e0e6463e461b78350b" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Mu</source>
          <target state="translated">ギリシア語の大文字ミュー</target>
        </trans-unit>
        <trans-unit id="c5ff86b57695b2194281052f49d3a518561ee43b" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Nu</source>
          <target state="translated">ギリシア文字ヌ</target>
        </trans-unit>
        <trans-unit id="8d3af0cfd66c1c551b9d25df70d96ca3b3e41655" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Omega</source>
          <target state="translated">ギリシャ文字オメガ</target>
        </trans-unit>
        <trans-unit id="60cb22c8a7263835043a1bf3e2390a30ccb009da" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Omicron</source>
          <target state="translated">ギリシア文字オミクロン</target>
        </trans-unit>
        <trans-unit id="9ef46dcc225d47def0f7ae271f6bce8a9447782c" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Phi</source>
          <target state="translated">ギリシャ文字のファイ</target>
        </trans-unit>
        <trans-unit id="bdfd940817a68024f4561b28e37abe5c6aa8ae33" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Pi</source>
          <target state="translated">ギリシア文字パイ</target>
        </trans-unit>
        <trans-unit id="9eb135fdc0eb8f41676f0233eced63bfb63b8d29" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Psi</source>
          <target state="translated">ギリシアの大文字プシ</target>
        </trans-unit>
        <trans-unit id="42581daba465402bb427e86f725e50cbf13c5589" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Rho</source>
          <target state="translated">ギリシャ語の大文字ロー</target>
        </trans-unit>
        <trans-unit id="9ba5f4b3b8d0114e4ebb66c0c247b421553311c0" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Sigma</source>
          <target state="translated">ギリシャ語の大文字シグマ</target>
        </trans-unit>
        <trans-unit id="ce15c49fc86bc080b59dcc6c6f912a5f65fcea89" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Tau</source>
          <target state="translated">ギリシャ語の大文字タウ</target>
        </trans-unit>
        <trans-unit id="c53695a8df7adbb8087dbbf3f92d38bad6c54a97" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Theta</source>
          <target state="translated">ギリシャ語の大文字シータ</target>
        </trans-unit>
        <trans-unit id="e5671b238dc9a21dfba521fd40bfb114bae616b4" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Upsilon</source>
          <target state="translated">ギリシャの大文字アップシロン</target>
        </trans-unit>
        <trans-unit id="7ee18055cc5ff646350aabb8125c5079d084ebc7" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Xi</source>
          <target state="translated">ギリシャの首都の文字Xi</target>
        </trans-unit>
        <trans-unit id="ff11a198311aac30e2248ebcb8edaa9900afa1c4" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Zeta</source>
          <target state="translated">ギリシャ語の大文字ゼータ</target>
        </trans-unit>
        <trans-unit id="75f6796d9ad54779470705290e7c7602d7a845bd" translate="yes" xml:space="preserve">
          <source>Greek Capital Theta Symbol</source>
          <target state="translated">ギリシャ資本シータのシンボル</target>
        </trans-unit>
        <trans-unit id="533978fb12373ffa98e45e16bb2525fdaa4ff4dc" translate="yes" xml:space="preserve">
          <source>Greek Kappa Symbol / Greek Small Letter Script Kappa</source>
          <target state="translated">ギリシャ語のカッパのシンボル/ギリシャ語の小文字スクリプトカッパ</target>
        </trans-unit>
        <trans-unit id="098ec4a81c9f38263e62700b20a2a6894858fb2e" translate="yes" xml:space="preserve">
          <source>Greek Letter Archaic Koppa</source>
          <target state="translated">ギリシャ文字のアルカイックコッパ</target>
        </trans-unit>
        <trans-unit id="c2ec8b8cfe62422b5013f3acdd510642f682d268" translate="yes" xml:space="preserve">
          <source>Greek Letter Digamma / Greek Capital Letter Digamma</source>
          <target state="translated">ギリシャ文字Digamma/ギリシャ文字Digamma</target>
        </trans-unit>
        <trans-unit id="ced5a29435b2a381da90865a6dc27f1b51bd0151" translate="yes" xml:space="preserve">
          <source>Greek Letter Koppa / Greek Capital Letter Koppa</source>
          <target state="translated">ギリシャ語の手紙コッパ/ギリシャ語の大文字コッパ</target>
        </trans-unit>
        <trans-unit id="b1fd4e84b1e13403c9fa5cc0de48f63d1cf94bc6" translate="yes" xml:space="preserve">
          <source>Greek Letter Sampi / Greek Capital Letter Sampi</source>
          <target state="translated">ギリシャ文字のサンピ/ギリシャ文字のサンピ</target>
        </trans-unit>
        <trans-unit id="6736119dd29a2f705206a98b22de530d1dcccd83" translate="yes" xml:space="preserve">
          <source>Greek Letter Stigma / Greek Capital Letter Stigma</source>
          <target state="translated">ギリシャ文字のスティグマ/ギリシャ文字のスティグマ</target>
        </trans-unit>
        <trans-unit id="ea7aa3ec425217aedfab9d34ef40b0b566351176" translate="yes" xml:space="preserve">
          <source>Greek Lunate Epsilon Symbol</source>
          <target state="translated">ギリシャのルナートイプシロンのシンボル</target>
        </trans-unit>
        <trans-unit id="dfaadea9364a20060c114ea92b3c24b30e9e1221" translate="yes" xml:space="preserve">
          <source>Greek Phi Symbol / Greek Small Letter Script Phi</source>
          <target state="translated">ギリシャ語のファイのシンボル/ギリシャ語の小さな文字スクリプトファイ</target>
        </trans-unit>
        <trans-unit id="0ae051b71680a4d39d72cb02f855a3c712e5bd2c" translate="yes" xml:space="preserve">
          <source>Greek Pi Symbol / Greek Small Letter Omega Pi</source>
          <target state="translated">ギリシャ語の円周率記号/ギリシャ語の小さな文字オメガパイ</target>
        </trans-unit>
        <trans-unit id="f50bb1d13ed32ec906d7d6aaaaee29e7aa027d22" translate="yes" xml:space="preserve">
          <source>Greek Reversed Lunate Epsilon Symbol</source>
          <target state="translated">ギリシア語逆月星ε記号</target>
        </trans-unit>
        <trans-unit id="ac07b5056a85d49adcf70f2b544a74ea6ecf6dce" translate="yes" xml:space="preserve">
          <source>Greek Rho Symbol / Greek Small Letter Tailed Rho</source>
          <target state="translated">ギリシャ語のRhoシンボル/ギリシャ語の小文字の尾のRho</target>
        </trans-unit>
        <trans-unit id="448dc00d610b9b19fb08a7c7e6eb0a55f13d0a5d" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Alpha</source>
          <target state="translated">ギリシャ語の小文字アルファ</target>
        </trans-unit>
        <trans-unit id="71d9bba39729f37db08ecc6cfd07622c292a3bcb" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Archaic Koppa</source>
          <target state="translated">ギリシャ語小文字アルカイックコッパ</target>
        </trans-unit>
        <trans-unit id="c2455c0fc133c1c49b746a40bf7fe8a2f613a4de" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Beta</source>
          <target state="translated">ギリシャ語の小文字ベータ</target>
        </trans-unit>
        <trans-unit id="5f8706d38c341d4055ab40dfb27748f213e0fc49" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Chi</source>
          <target state="translated">ギリシャ語の小文字カイ</target>
        </trans-unit>
        <trans-unit id="4dcd438cdc63b711ea794ef765006ad5a6535bd8" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Delta</source>
          <target state="translated">ギリシャ語の小文字デルタ</target>
        </trans-unit>
        <trans-unit id="970eba5f1fd0ce763d594cfcc46caddd4212150e" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Digamma</source>
          <target state="translated">ギリシャ語の小文字ディガンマ</target>
        </trans-unit>
        <trans-unit id="37cc4f8ed3f230c47dc11c83e4de12cf526a1b20" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Epsilon</source>
          <target state="translated">ギリシャ語の小さな文字イプシロン</target>
        </trans-unit>
        <trans-unit id="7ccbcb67c9381630a226a3b3c4b28371605f0d5a" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Eta</source>
          <target state="translated">ギリシャ語の小文字イータ</target>
        </trans-unit>
        <trans-unit id="c074819760ca3f5bfb2e80f9147ad5e5b56ba096" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Final Sigma</source>
          <target state="translated">グリークスモールレター ファイナルシグマ</target>
        </trans-unit>
        <trans-unit id="46c3a6f8bc0a7d2d96bb1cd2543a7109d5b60cf2" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Gamma</source>
          <target state="translated">ギリシャの小さな文字ガンマ</target>
        </trans-unit>
        <trans-unit id="4643eab845743a762892a109cabf22bfe96da620" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Iota</source>
          <target state="translated">ギリシャ語の小文字イオタ</target>
        </trans-unit>
        <trans-unit id="3e9ea92015aac67d0b73db674b1ba4dee8fe5484" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Kappa</source>
          <target state="translated">ギリシアの小文字カッパ</target>
        </trans-unit>
        <trans-unit id="c67601530cb0f970279b136a8b536cfe4717bcd6" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Koppa</source>
          <target state="translated">ギリシャ語の小文字コッパ</target>
        </trans-unit>
        <trans-unit id="8c54eb8dc3ac289b41335f3dc67e6533bf270a57" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Lamda / Greek Small Letter Lambda</source>
          <target state="translated">ギリシャ語の小さな文字ラムダ/ギリシャ語の小さな文字ラムダ</target>
        </trans-unit>
        <trans-unit id="7149178e5cd2592e10a36e0a107bc1c794d4f411" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Mu</source>
          <target state="translated">ギリシア語の小文字ミュー</target>
        </trans-unit>
        <trans-unit id="e9b48a4ac754761a9dfd350adeabe5d343e5cb8f" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Nu</source>
          <target state="translated">ギリシャ語の小さな文字ヌ</target>
        </trans-unit>
        <trans-unit id="be2da964640e6e3a6c6130c2c98b0cae86bc9a01" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Omega</source>
          <target state="translated">ギリシャ語の小さな文字 オメガ</target>
        </trans-unit>
        <trans-unit id="039c14215303437a5f755bf47c77fbf3d49255e3" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Omicron</source>
          <target state="translated">ギリシャ語の小文字オミクロン</target>
        </trans-unit>
        <trans-unit id="b844f337c63e69f41e1119e2ae91153b90ab2b4d" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Phi</source>
          <target state="translated">ギリシャ語の小さな文字ファイ</target>
        </trans-unit>
        <trans-unit id="95d050ef9ff90d9125fe852cf7d1543f2ce7e841" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Pi</source>
          <target state="translated">ギリシア語の小文字パイ</target>
        </trans-unit>
        <trans-unit id="55e311ff6199f4bde7e5d73ace711e07be007a2f" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Psi</source>
          <target state="translated">ギリシャ語の小さな文字のプシ</target>
        </trans-unit>
        <trans-unit id="5af5bfd009ec9591a9cb29dfcc2932dec54d6ca8" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Rho</source>
          <target state="translated">ギリシャ語の小さな文字Rho</target>
        </trans-unit>
        <trans-unit id="85d8bb7b244cafeb1ab811a9df619d45d2234ea6" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Sampi</source>
          <target state="translated">ギリシャの小さな手紙サンピ</target>
        </trans-unit>
        <trans-unit id="3ec2ed80a66bc81ead34ee55592a6ea7debfff4e" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Sigma</source>
          <target state="translated">ギリシャの小さな文字シグマ</target>
        </trans-unit>
        <trans-unit id="cc430dcce9d526f42ad9a59b54895c602c6380d3" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Stigma</source>
          <target state="translated">ギリシア語の小文字のスティグマ</target>
        </trans-unit>
        <trans-unit id="7c2c0c82fe6e748bf9ed49a1f4249b9e89ebb0b8" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Tau</source>
          <target state="translated">ギリシャ語の小さな文字タウ</target>
        </trans-unit>
        <trans-unit id="b13a88433f3cb99d5c62955aca5de95fbd232103" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Theta</source>
          <target state="translated">ギリシャ語の小さな文字シータ</target>
        </trans-unit>
        <trans-unit id="cad5938bde69f48a48d99f9b129d82f0acd5468b" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Upsilon</source>
          <target state="translated">ギリシャ語の小さな文字アップシロン</target>
        </trans-unit>
        <trans-unit id="0761f90b7168a502798811085d1367b5eca5af17" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Xi</source>
          <target state="translated">ギリシャ語の小さな文字Xi</target>
        </trans-unit>
        <trans-unit id="40428b11afaf575da445431ab7ceb811220b9167" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Zeta</source>
          <target state="translated">ギリシャ語の小さな文字ゼータ</target>
        </trans-unit>
        <trans-unit id="e32107e3b0620ecf09ddae3fe8f4666208d97040" translate="yes" xml:space="preserve">
          <source>Greek Subscript Small Letter Beta</source>
          <target state="translated">ギリシャ語の添え字小文字ベータ</target>
        </trans-unit>
        <trans-unit id="90a01f237c5981615d18499c4360233abc532e89" translate="yes" xml:space="preserve">
          <source>Greek Subscript Small Letter Chi</source>
          <target state="translated">ギリシャ語の添え字小字カイ</target>
        </trans-unit>
        <trans-unit id="e6642d28d8aeb11d500775a8447736e31c6678cc" translate="yes" xml:space="preserve">
          <source>Greek Subscript Small Letter Gamma</source>
          <target state="translated">ギリシャ語の下付き小文字ガンマ</target>
        </trans-unit>
        <trans-unit id="8b5afd737dfb2072bb758ab79fe8cc816442c922" translate="yes" xml:space="preserve">
          <source>Greek Subscript Small Letter Phi</source>
          <target state="translated">ギリシャ語の添え字小文字ファイ</target>
        </trans-unit>
        <trans-unit id="655a658031f914446d83820f4d7947b16f05e79e" translate="yes" xml:space="preserve">
          <source>Greek Subscript Small Letter Rho</source>
          <target state="translated">ギリシャ語の添え字小文字Rho</target>
        </trans-unit>
        <trans-unit id="be9f5ea4e76fd688fd62b7dd791af4a7ebcdb5c7" translate="yes" xml:space="preserve">
          <source>Greek Theta Symbol / Greek Small Letter Script Theta</source>
          <target state="translated">ギリシャ語のシータ記号/ギリシャ語の小さな文字スクリプトシータ</target>
        </trans-unit>
        <trans-unit id="0dc9b81e7212e0baffe967cdd9d850d4352c89f1" translate="yes" xml:space="preserve">
          <source>Green Apple</source>
          <target state="translated">グリーンアップル</target>
        </trans-unit>
        <trans-unit id="6c0c3305620db430350f7c25edbf10ced1e1274b" translate="yes" xml:space="preserve">
          <source>Green Book</source>
          <target state="translated">グリーンブック</target>
        </trans-unit>
        <trans-unit id="6c50119d5c6855e408d9ec2a52bd79546e4c4107" translate="yes" xml:space="preserve">
          <source>Green Heart</source>
          <target state="translated">グリーンハート</target>
        </trans-unit>
        <trans-unit id="91feac528389c2b95c6eef06c801f2624c19116d" translate="yes" xml:space="preserve">
          <source>Grimacing Face</source>
          <target state="translated">グリムフェイス</target>
        </trans-unit>
        <trans-unit id="3f363dede90226435cbc0dd5d44650f61adbd5cf" translate="yes" xml:space="preserve">
          <source>Grinning Cat Face With Smiling Eyes</source>
          <target state="translated">笑顔の目でニヤニヤ猫の顔</target>
        </trans-unit>
        <trans-unit id="c001d488999b87437147a6834a4b4dff1427af59" translate="yes" xml:space="preserve">
          <source>Grinning Face</source>
          <target state="translated">ニヤニヤ顔</target>
        </trans-unit>
        <trans-unit id="5f9c06d040ed5ced638db3bf446959a48d2a6ba5" translate="yes" xml:space="preserve">
          <source>Grinning Face With Smiling Eyes</source>
          <target state="translated">笑顔の目でニヤニヤ顔</target>
        </trans-unit>
        <trans-unit id="7005b30f708630da7d596e53a5163b84350bd829" translate="yes" xml:space="preserve">
          <source>Grisu.print_shortest()</source>
          <target state="translated">Grisu.print_shortest()</target>
        </trans-unit>
        <trans-unit id="d511874702f7c7ad5ec3b4943a9badded191c85c" translate="yes" xml:space="preserve">
          <source>Growing Heart</source>
          <target state="translated">成長する心</target>
        </trans-unit>
        <trans-unit id="0fa148c7a4ec811ec41fa2cc8e9473dfc48a9226" translate="yes" xml:space="preserve">
          <source>Guardsman</source>
          <target state="translated">Guardsman</target>
        </trans-unit>
        <trans-unit id="94af6c4088103e96d349b87fe76774686b86faa5" translate="yes" xml:space="preserve">
          <source>Guitar</source>
          <target state="translated">Guitar</target>
        </trans-unit>
        <trans-unit id="f089f13a04cfc6546c94da2f6580d6c4eed769fc" translate="yes" xml:space="preserve">
          <source>HE</source>
          <target state="translated">HE</target>
        </trans-unit>
        <trans-unit id="9018ffc109466fc760171905d2397039bc111ebf" translate="yes" xml:space="preserve">
          <source>Had we tried to do the addition without the atomic tag, we might have gotten the wrong answer due to a race condition. An example of what would happen if we didn't avoid the race:</source>
          <target state="translated">原子タグを使わずに足し算をしようとしていたら、競合条件のために間違った答えが出ていたかもしれません。競合を回避しなかった場合の例。</target>
        </trans-unit>
        <trans-unit id="de960a40df3284e207ad1c9fee37b3f036f0b2a2" translate="yes" xml:space="preserve">
          <source>Hair Space</source>
          <target state="translated">ヘアスペース</target>
        </trans-unit>
        <trans-unit id="2c7a078f496901b9f8903cc399fa79c1c3ab6b95" translate="yes" xml:space="preserve">
          <source>Haircut</source>
          <target state="translated">Haircut</target>
        </trans-unit>
        <trans-unit id="4a11632b50147a0502c9dc634f5c6e0c06ffab6b" translate="yes" xml:space="preserve">
          <source>Half-precision floating-point numbers are also supported (&lt;a href=&quot;../../base/numbers/index#Core.Float16&quot;&gt;&lt;code&gt;Float16&lt;/code&gt;&lt;/a&gt;), but they are implemented in software and use &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt; for calculations.</source>
          <target state="translated">半精度浮動小数点数もサポートされていますが（&lt;a href=&quot;../../base/numbers/index#Core.Float16&quot;&gt; &lt;code&gt;Float16&lt;/code&gt; &lt;/a&gt;）、ソフトウェアで実装され、計算に&lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt; &lt;code&gt;Float32&lt;/code&gt; &lt;/a&gt;を使用します。</target>
        </trans-unit>
        <trans-unit id="94c92dceffd55b3ed538a942cce80806cce37fe1" translate="yes" xml:space="preserve">
          <source>Hamburger</source>
          <target state="translated">Hamburger</target>
        </trans-unit>
        <trans-unit id="ab7b8ea47eadf93146c012e72a5ea673322853aa" translate="yes" xml:space="preserve">
          <source>Hammer</source>
          <target state="translated">Hammer</target>
        </trans-unit>
        <trans-unit id="3bff32cf99bd14d58869cbb0d7d31e1bec45d891" translate="yes" xml:space="preserve">
          <source>Hamster Face</source>
          <target state="translated">ハムスターの顔</target>
        </trans-unit>
        <trans-unit id="3d3f4dc94e3e321e028a018fa9cae5ff030ce957" translate="yes" xml:space="preserve">
          <source>Handbag</source>
          <target state="translated">Handbag</target>
        </trans-unit>
        <trans-unit id="fffe7d81b4e3e0d9952aa6caa3fd530df68b775c" translate="yes" xml:space="preserve">
          <source>Handle a log event</source>
          <target state="translated">ログイベントの処理</target>
        </trans-unit>
        <trans-unit id="e30eba0eb24c7a8fac8f9c3ba83240b293b51b33" translate="yes" xml:space="preserve">
          <source>Handle excess argument diversity in the caller</source>
          <target state="translated">呼び出し元での過剰な引数の多様性の処理</target>
        </trans-unit>
        <trans-unit id="10a3cb0df00f1fa97a3cb63486616c5cf79959d9" translate="yes" xml:space="preserve">
          <source>Handling Operating System Variation</source>
          <target state="translated">オペレーティングシステムの変化への対応</target>
        </trans-unit>
        <trans-unit id="67509204a791b926a290df40bb29deed545a4fe9" translate="yes" xml:space="preserve">
          <source>Happy Person Raising One Hand</source>
          <target state="translated">幸せな人が片手を上げる</target>
        </trans-unit>
        <trans-unit id="31f205e87d98bf7472c8354a4586dfc7173d7021" translate="yes" xml:space="preserve">
          <source>Hatching Chick</source>
          <target state="translated">ひよこの孵化</target>
        </trans-unit>
        <trans-unit id="520de7443d00d6ff4dc3ababbbf6cfbe0b74f4ec" translate="yes" xml:space="preserve">
          <source>Headers</source>
          <target state="translated">Headers</target>
        </trans-unit>
        <trans-unit id="6ef295c2897db61289ad0eb0b8171326ec851011" translate="yes" xml:space="preserve">
          <source>Headphone</source>
          <target state="translated">Headphone</target>
        </trans-unit>
        <trans-unit id="83fbe44a9f704c02d2d76ee1fa5c115010ff9d8c" translate="yes" xml:space="preserve">
          <source>Hear-No-Evil Monkey</source>
          <target state="translated">ヒア・ノー・エビル・モンキー</target>
        </trans-unit>
        <trans-unit id="2edafb06cf3a183a503a1615f5b8c4da86990553" translate="yes" xml:space="preserve">
          <source>Heart Decoration</source>
          <target state="translated">ハートのデコレーション</target>
        </trans-unit>
        <trans-unit id="53648eedc9bfa102fd53ca957c856f7e0d9a2a2f" translate="yes" xml:space="preserve">
          <source>Heart With Arrow</source>
          <target state="translated">アローのあるハート</target>
        </trans-unit>
        <trans-unit id="5461f091ddf4a776ade53602bfcdef544a0feb57" translate="yes" xml:space="preserve">
          <source>Heart With Ribbon</source>
          <target state="translated">リボン付きハート</target>
        </trans-unit>
        <trans-unit id="fde3248d8454a04a4138dae1e5a31ab1432bdb78" translate="yes" xml:space="preserve">
          <source>Heavy Black Heart</source>
          <target state="translated">ヘビーブラックハート</target>
        </trans-unit>
        <trans-unit id="662b2b0a5e62dab41b3f6deba4867bbd60a35b8f" translate="yes" xml:space="preserve">
          <source>Heavy Check Mark</source>
          <target state="translated">ヘビーチェックマーク</target>
        </trans-unit>
        <trans-unit id="9ae6c1b9f7bdda7ce9eec6a4c6ee5efca7c871a5" translate="yes" xml:space="preserve">
          <source>Heavy Division Sign</source>
          <target state="translated">ヘビーディビジョンサイン</target>
        </trans-unit>
        <trans-unit id="7706e6c735cc207b9267e0979a8dbeb69e5229a0" translate="yes" xml:space="preserve">
          <source>Heavy Dollar Sign</source>
          <target state="translated">ヘビーダラーサイン</target>
        </trans-unit>
        <trans-unit id="93e9c9786874a2de0cddf3ee5e7766e4ea031dca" translate="yes" xml:space="preserve">
          <source>Heavy Exclamation Mark Symbol</source>
          <target state="translated">ヘビーエクスクラメーションマーク記号</target>
        </trans-unit>
        <trans-unit id="78800e7776274c794a8d095ff4c2c73221dbbbae" translate="yes" xml:space="preserve">
          <source>Heavy Large Circle</source>
          <target state="translated">ヘビーラージサークル</target>
        </trans-unit>
        <trans-unit id="980c6d0d2733f3166210e842cefb858e063c0d91" translate="yes" xml:space="preserve">
          <source>Heavy Minus Sign</source>
          <target state="translated">ヘビーマイナス記号</target>
        </trans-unit>
        <trans-unit id="778bd00186fa7e144e55b7635e11bf1326888ddd" translate="yes" xml:space="preserve">
          <source>Heavy Multiplication X</source>
          <target state="translated">重い掛け算X</target>
        </trans-unit>
        <trans-unit id="f686b15ee80bdb7a610f665e9bb567ee7025d65c" translate="yes" xml:space="preserve">
          <source>Heavy Plus Sign</source>
          <target state="translated">ヘビープラスサイン</target>
        </trans-unit>
        <trans-unit id="75c1e5a632008728c5938fd7cc30c147bf32b6b5" translate="yes" xml:space="preserve">
          <source>Heavy Teardrop-Spoked Asterisk</source>
          <target state="translated">ヘビーティアドロップスモークアスタリスク</target>
        </trans-unit>
        <trans-unit id="fda201fd52a223f4da8ab6d74bf72a21faeaf60b" translate="yes" xml:space="preserve">
          <source>Helicopter</source>
          <target state="translated">Helicopter</target>
        </trans-unit>
        <trans-unit id="ae573d0f71ca2ef898057a3a11aeabc86f4048c4" translate="yes" xml:space="preserve">
          <source>Help mode</source>
          <target state="translated">ヘルプモード</target>
        </trans-unit>
        <trans-unit id="5941c1bf985d2850f77798f46b591f5bf1a7198a" translate="yes" xml:space="preserve">
          <source>Help mode can be exited by pressing backspace at the beginning of the line.</source>
          <target state="translated">ヘルプモードは、行頭のバックスペースを押すことで解除することができます。</target>
        </trans-unit>
        <trans-unit id="8882ebfc5a29fddc8a80eb230261926f56fd8d5e" translate="yes" xml:space="preserve">
          <source>Herb</source>
          <target state="translated">Herb</target>
        </trans-unit>
        <trans-unit id="bb934b9ceeaa4e54809a9838dfa1ed2cabf6522e" translate="yes" xml:space="preserve">
          <source>Here &quot;inline&quot; refers to elements that can be found within blocks of text, i.e. paragraphs. These include the following elements.</source>
          <target state="translated">ここで、「インライン」とは、テキストのブロック内、すなわち段落内に存在する要素を指す。これには、以下の要素が含まれます。</target>
        </trans-unit>
        <trans-unit id="0aaf5b43ce3bf447f656063f8ac61c46b777eefc" translate="yes" xml:space="preserve">
          <source>Here Enter was pressed again so that Julia would read the newline. Now, as you can see from this example, &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; takes the data to write as its second argument, while &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; takes the type of the data to be read as the second argument.</source>
          <target state="translated">ここでEnterキーがもう一度押されたため、ジュリアは改行を読みました。この例から見ることができるように今、&lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;一方で、2番目の引数としての書き込みにデータを取り&lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; 2番目の引数として読み込まれるデータの型を取ります。</target>
        </trans-unit>
        <trans-unit id="77b8367f53858f5da92aefb29bb20f4abb25843a" translate="yes" xml:space="preserve">
          <source>Here are some examples to demonstrate which type of arrays are strided and which are not:</source>
          <target state="translated">ここでは、どのタイプの配列がストライドされていて、どのタイプの配列がストライドされていないかを示す例を示します。</target>
        </trans-unit>
        <trans-unit id="3b3a2127d824649ba6d32ad8be94f9ae3c5dba0e" translate="yes" xml:space="preserve">
          <source>Here are some examples with bitwise operators:</source>
          <target state="translated">ビット演算子を使った例を紹介します。</target>
        </trans-unit>
        <trans-unit id="c2d9b5adfe6cd0f32ce45f61d872c609d6e0a4ff" translate="yes" xml:space="preserve">
          <source>Here are some simple examples using arithmetic operators:</source>
          <target state="translated">算術演算子を使った簡単な例をご紹介します。</target>
        </trans-unit>
        <trans-unit id="f5ba1cb3713902ae4550268fb70da7530b34b57c" translate="yes" xml:space="preserve">
          <source>Here are some simple examples:</source>
          <target state="translated">簡単な例をご紹介します。</target>
        </trans-unit>
        <trans-unit id="d3d30b41b93723417b3a0eda16323a2baedc0a7c" translate="yes" xml:space="preserve">
          <source>Here are some tips for working with Julia efficiently.</source>
          <target state="translated">ジュリアと効率よく仕事をするためのコツをご紹介します。</target>
        </trans-unit>
        <trans-unit id="4b9dc1697c31ccdd9965aa0170dd226712f2cb14" translate="yes" xml:space="preserve">
          <source>Here each iteration applies &lt;code&gt;f&lt;/code&gt; to a randomly-chosen sample from a vector &lt;code&gt;a&lt;/code&gt; shared by all processes.</source>
          <target state="translated">ここで、各反復は、すべてのプロセスで共有されるベクトル &lt;code&gt;a&lt;/code&gt; からランダムに選択されたサンプルに &lt;code&gt;f&lt;/code&gt; を適用します。</target>
        </trans-unit>
        <trans-unit id="a76feb46cab9b567bf7483afc7491ed744f3c054" translate="yes" xml:space="preserve">
          <source>Here is a corresponding roots structure, represented as a dictionary:</source>
          <target state="translated">ここでは、対応する根の構造を辞書で表しています。</target>
        </trans-unit>
        <trans-unit id="86a5b746f6fe4ea8f489a225c69f586c3ee94b4f" translate="yes" xml:space="preserve">
          <source>Here is a more complex example, still using Markdown:</source>
          <target state="translated">ここでは、Markdownを使用した、より複雑な例を示します。</target>
        </trans-unit>
        <trans-unit id="32a32a63972b7e15e6bc1e1399ca59536eaf91cf" translate="yes" xml:space="preserve">
          <source>Here is a related case in which the expected behaviour is not necessarily obvious: What happens when we round to the nearest &lt;code&gt;P(2)&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a &lt;a href=&quot;#Dates.Period&quot;&gt;&lt;code&gt;Period&lt;/code&gt;&lt;/a&gt; type? In some cases (specifically, when &lt;code&gt;P &amp;lt;: Dates.TimePeriod&lt;/code&gt;) the answer is clear:</source>
          <target state="translated">予想される動作が必ずしも明白ではない、関連するケースを次に示します。最も近い &lt;code&gt;P(2)&lt;/code&gt; に丸めるとどうなりますか。ここで、 &lt;code&gt;P&lt;/code&gt; は&lt;a href=&quot;#Dates.Period&quot;&gt; &lt;code&gt;Period&lt;/code&gt; &lt;/a&gt;タイプです。場合によっては（具体的には、 &lt;code&gt;P &amp;lt;: Dates.TimePeriod&lt;/code&gt; ）、答えは明確です。</target>
        </trans-unit>
        <trans-unit id="cbc1a6d954403affcd824e28b3f149fcba6203f0" translate="yes" xml:space="preserve">
          <source>Here is a representation of a possible paths map for our example &lt;code&gt;App&lt;/code&gt; project environment, as provided in the Manifest given above for the dependency graph, after searching the local file system:</source>
          <target state="translated">ローカルファイルシステムを検索した後の、依存関係グラフの上記のマニフェストで提供されている、 &lt;code&gt;App&lt;/code&gt; プロジェクト環境の例の可能なパスマップを次に示します。</target>
        </trans-unit>
        <trans-unit id="62b973b3d8599e23c2d9da9c0813b08faed1d7f5" translate="yes" xml:space="preserve">
          <source>Here is a second example wrapping the corresponding destructor:</source>
          <target state="translated">ここでは、対応するデストラクタをラップする2つ目の例を示します。</target>
        </trans-unit>
        <trans-unit id="383164a53efb4be492fb1a747035c59b715f139a" translate="yes" xml:space="preserve">
          <source>Here is a simple example of a C wrapper that returns a &lt;code&gt;Ptr&lt;/code&gt; type:</source>
          <target state="translated">以下は、 &lt;code&gt;Ptr&lt;/code&gt; 型を返すCラッパーの簡単な例です。</target>
        </trans-unit>
        <trans-unit id="fd4023e74c6b03e666e958ff6141359ac199b811" translate="yes" xml:space="preserve">
          <source>Here is a simplified definition of Julia's &lt;a href=&quot;../../base/base/index#Base.@assert&quot;&gt;&lt;code&gt;@assert&lt;/code&gt;&lt;/a&gt; macro:</source>
          <target state="translated">Juliaの&lt;a href=&quot;../../base/base/index#Base.@assert&quot;&gt; &lt;code&gt;@assert&lt;/code&gt; &lt;/a&gt;マクロの簡単な定義を次に示します。</target>
        </trans-unit>
        <trans-unit id="ac903f23df192b2cec33704052829cedd04df512" translate="yes" xml:space="preserve">
          <source>Here is a slightly more complex example that discovers the local machine's hostname. In this example, the networking library code is assumed to be in a shared library named &quot;libc&quot;. In practice, this function is usually part of the C standard library, and so the &quot;libc&quot; portion should be omitted, but we wish to show here the usage of this syntax.</source>
          <target state="translated">ここでは、ローカルマシンのホスト名を検出する少し複雑な例を示します。この例では、ネットワーキング・ライブラリのコードは、&quot;libc &quot;という名前の共有ライブラリにあると仮定しています。実際には、この関数は通常 C 標準ライブラリの一部であるため、&quot;libc&quot; の部分は省略されるべきですが、ここではこの構文の使い方を示したいと思います。</target>
        </trans-unit>
        <trans-unit id="e40b5507bd00f53ac4347d820f9aea2085f1e997" translate="yes" xml:space="preserve">
          <source>Here is a slightly more complex example that discovers the local machine's hostname:</source>
          <target state="translated">ここでは、ローカルマシンのホスト名を検出する、もう少し複雑な例を示します。</target>
        </trans-unit>
        <trans-unit id="c20460c3bed82c94ed3787e3dfe27ae7c3b31699" translate="yes" xml:space="preserve">
          <source>Here is a third example passing Julia arrays:</source>
          <target state="translated">ここでは、Julia の配列を渡す 3 番目の例を示します。</target>
        </trans-unit>
        <trans-unit id="d610a40401dd7269ef98b9bc1fb559f31c643ca5" translate="yes" xml:space="preserve">
          <source>Here is an even more complex multi-stage producer-consumer example:</source>
          <target state="translated">ここでは、さらに複雑な多段式の生産者と消費者の例を紹介します。</target>
        </trans-unit>
        <trans-unit id="166759fbb289c37473d7a6b4b102bc98c71ab976" translate="yes" xml:space="preserve">
          <source>Here is an example of a &quot;compound function&quot; that should really be written as multiple definitions:</source>
          <target state="translated">ここでは、本当は複数の定義として記述すべき「複合関数」の例を示します。</target>
        </trans-unit>
        <trans-unit id="dff5c26dbc80f0776c11c28a5633445af4d9d175" translate="yes" xml:space="preserve">
          <source>Here is an example with all three kinds of markup. This program first calculates the finite difference of a one-dimensional array, and then evaluates the L2-norm of the result:</source>
          <target state="translated">ここでは,3種類のマークアップを用いた例を示します.このプログラムは,まず1次元配列の有限差分を計算し,その結果のL2ノルムを評価します.</target>
        </trans-unit>
        <trans-unit id="f97cb2973176feb8f941a5117a88dd7fad7d8ec1" translate="yes" xml:space="preserve">
          <source>Here is an example with both &lt;code&gt;@inbounds&lt;/code&gt; and &lt;code&gt;@simd&lt;/code&gt; markup (we here use &lt;code&gt;@noinline&lt;/code&gt; to prevent the optimizer from trying to be too clever and defeat our benchmark):</source>
          <target state="translated">&lt;code&gt;@inbounds&lt;/code&gt; と &lt;code&gt;@simd&lt;/code&gt; の両方のマークアップの例を次に示します（ここでは、 &lt;code&gt;@noinline&lt;/code&gt; を使用して、オプティマイザが賢すぎてベンチマークを無効にしようとしないようにしています）。</target>
        </trans-unit>
        <trans-unit id="87f18e8d7ee1b76e68d3166f552e8d656c81958f" translate="yes" xml:space="preserve">
          <source>Here is an extraordinarily simple macro:</source>
          <target state="translated">非常にシンプルなマクロです。</target>
        </trans-unit>
        <trans-unit id="7afc02096736fcb4c01a0c6afaea2e90973eb75e" translate="yes" xml:space="preserve">
          <source>Here is the correct code template for returning the element-type &lt;code&gt;T&lt;/code&gt; of any arbitrary subtype of &lt;code&gt;AbstractArray&lt;/code&gt;:</source>
          <target state="translated">以下は、 &lt;code&gt;AbstractArray&lt;/code&gt; の任意のサブタイプの要素タイプ &lt;code&gt;T&lt;/code&gt; を返すための正しいコードテンプレートです。</target>
        </trans-unit>
        <trans-unit id="5f4fdb43158ce32a870e863c53f180f3aa098a57" translate="yes" xml:space="preserve">
          <source>Here is the corresponding graph structure, represented as a dictionary:</source>
          <target state="translated">ここでは、対応するグラフ構造を辞書で表しています。</target>
        </trans-unit>
        <trans-unit id="f9b6eba975c84af5ac0af3798604d9ad36108359" translate="yes" xml:space="preserve">
          <source>Here module &lt;code&gt;Parent&lt;/code&gt; contains a submodule &lt;code&gt;Utils&lt;/code&gt;, and code in &lt;code&gt;Parent&lt;/code&gt; wants the contents of &lt;code&gt;Utils&lt;/code&gt; to be visible. This is done by starting the &lt;code&gt;using&lt;/code&gt; path with a period. Adding more leading periods moves up additional levels in the module hierarchy. For example &lt;code&gt;using ..Utils&lt;/code&gt; would look for &lt;code&gt;Utils&lt;/code&gt; in &lt;code&gt;Parent&lt;/code&gt;'s enclosing module rather than in &lt;code&gt;Parent&lt;/code&gt; itself.</source>
          <target state="translated">ここでは、モジュール &lt;code&gt;Parent&lt;/code&gt; サブモジュールが含ま &lt;code&gt;Utils&lt;/code&gt; のを、とのコード &lt;code&gt;Parent&lt;/code&gt; 内容望ん &lt;code&gt;Utils&lt;/code&gt; のが見えるようにします。これは、 &lt;code&gt;using&lt;/code&gt; パスをピリオドで開始することによって行われます。先行期間を追加すると、モジュール階層のレベルが上がります。たとえば &lt;code&gt;using ..Utils&lt;/code&gt; 探します &lt;code&gt;Utils&lt;/code&gt; の中で &lt;code&gt;Parent&lt;/code&gt; 「というよりも、モジュールを囲むよ &lt;code&gt;Parent&lt;/code&gt; そのもの。</target>
        </trans-unit>
        <trans-unit id="cf5b1250aa2128de01974785ca5a0cd9b855ebd1" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;1:5&lt;/code&gt; is a range object, representing the sequence of numbers 1, 2, 3, 4, 5. The &lt;code&gt;for&lt;/code&gt; loop iterates through these values, assigning each one in turn to the variable &lt;code&gt;i&lt;/code&gt;. One rather important distinction between the previous &lt;code&gt;while&lt;/code&gt; loop form and the &lt;code&gt;for&lt;/code&gt; loop form is the scope during which the variable is visible. If the variable &lt;code&gt;i&lt;/code&gt; has not been introduced in another scope, in the &lt;code&gt;for&lt;/code&gt; loop form, it is visible only inside of the &lt;code&gt;for&lt;/code&gt; loop, and not outside/afterwards. You'll either need a new interactive session instance or a different variable name to test this:</source>
          <target state="translated">ここで &lt;code&gt;1:5&lt;/code&gt; には、番号1の配列を示し、範囲オブジェクトで2、3、4、5 &lt;code&gt;for&lt;/code&gt; 変数に順番にそれぞれを割り当て、これらの値をループ反復 &lt;code&gt;i&lt;/code&gt; 。以前の &lt;code&gt;while&lt;/code&gt; ループ形式と &lt;code&gt;for&lt;/code&gt; ループ形式のかなり重要な違いの1つは、変数が表示されるスコープです。変数 &lt;code&gt;i&lt;/code&gt; が別のスコープで導入されていない場合、 &lt;code&gt;for&lt;/code&gt; ループ形式では、 &lt;code&gt;for&lt;/code&gt; ループの内部でのみ表示され、外部/以降では表示されません。これをテストするには、新しいインタラクティブセッションインスタンスまたは別の変数名が必要です。</target>
        </trans-unit>
        <trans-unit id="052893fe9e50a40443ea78d54cd3b33cb280eb4e" translate="yes" xml:space="preserve">
          <source>Here the call &lt;code&gt;g(2.0, 3.0)&lt;/code&gt; could be handled by either the &lt;code&gt;g(Float64, Any)&lt;/code&gt; or the &lt;code&gt;g(Any, Float64)&lt;/code&gt; method, and neither is more specific than the other. In such cases, Julia raises a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt; rather than arbitrarily picking a method. You can avoid method ambiguities by specifying an appropriate method for the intersection case:</source>
          <target state="translated">ここで、 &lt;code&gt;g(2.0, 3.0)&lt;/code&gt; の呼び出しは、 &lt;code&gt;g(Float64, Any)&lt;/code&gt; &lt;code&gt;g(Any, Float64)&lt;/code&gt; メソッドまたはg（Any、Float64）メソッドのいずれかで処理でき、どちらも特定のものではありません。このような場合、Juliaは任意にメソッドを選択するのではなく、&lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; &lt;/a&gt;を発生させます。交差のケースに適切なメソッドを指定することで、メソッドのあいまいさを回避できます。</target>
        </trans-unit>
        <trans-unit id="373c14d6a8445cd3c00b580baccefb5fd3f3d12c" translate="yes" xml:space="preserve">
          <source>Here the first number is printed after a delay of two seconds, then the following numbers are printed quickly.</source>
          <target state="translated">ここでは、最初の番号が2秒の遅延の後に印刷され、その後、次の番号が素早く印刷されます。</target>
        </trans-unit>
        <trans-unit id="f3418902a4f242b518d4d5f42412b650db9149b7" translate="yes" xml:space="preserve">
          <source>Here the user expression &lt;code&gt;ex&lt;/code&gt; is a call to &lt;code&gt;time&lt;/code&gt;, but not the same &lt;code&gt;time&lt;/code&gt; function that the macro uses. It clearly refers to &lt;code&gt;MyModule.time&lt;/code&gt;. Therefore we must arrange for the code in &lt;code&gt;ex&lt;/code&gt; to be resolved in the macro call environment. This is done by &quot;escaping&quot; the expression with &lt;a href=&quot;../../base/base/index#Base.esc&quot;&gt;&lt;code&gt;esc&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">ここで、ユーザー式 &lt;code&gt;ex&lt;/code&gt; は &lt;code&gt;time&lt;/code&gt; の呼び出しですが、マクロが使用するのと同じ &lt;code&gt;time&lt;/code&gt; 関数ではありません。 &lt;code&gt;MyModule.time&lt;/code&gt; を明確に参照しています。したがって、マクロ呼び出し環境で &lt;code&gt;ex&lt;/code&gt; のコードが解決されるように調整する必要があります。これは、&lt;a href=&quot;../../base/base/index#Base.esc&quot;&gt; &lt;code&gt;esc&lt;/code&gt; を使用し&lt;/a&gt;て式を「エスケープ」することによって行われます。</target>
        </trans-unit>
        <trans-unit id="319de09db8b0ceed706c2722ad8c4f12c486b513" translate="yes" xml:space="preserve">
          <source>Here the zero-argument constructor method calls the single-argument constructor method, which in turn calls the automatically provided two-argument constructor method. For reasons that will become clear very shortly, additional constructor methods declared as normal methods like this are called &lt;em&gt;outer&lt;/em&gt; constructor methods. Outer constructor methods can only ever create a new instance by calling another constructor method, such as the automatically provided default ones.</source>
          <target state="translated">ここでは、引数のないコンストラクターメソッドが単一引数のコンストラクターメソッドを呼び出し、次に、引数が自動的に提供される2つの引数のコンストラクターメソッドを呼び出します。すぐに明らかになる理由により、このような通常のメソッドとして宣言された追加のコンストラクターメソッドは、&lt;em&gt;外部&lt;/em&gt;コンストラクターメソッドと呼ばれます。外部コンストラクタメソッドは、自動的に提供されるデフォルトのメソッドなど、別のコンストラクタメソッドを呼び出すことによってのみ新しいインスタンスを作成できます。</target>
        </trans-unit>
        <trans-unit id="754489125a9dd659e2690c5c486d5c6350ca9a2b" translate="yes" xml:space="preserve">
          <source>Here we create and store two closures that return variable &lt;code&gt;i&lt;/code&gt;. However, it is always the same variable &lt;code&gt;i&lt;/code&gt;, so the two closures behave identically. We can use &lt;code&gt;let&lt;/code&gt; to create a new binding for &lt;code&gt;i&lt;/code&gt;:</source>
          <target state="translated">ここでは、変数 &lt;code&gt;i&lt;/code&gt; を返す2つのクロージャーを作成して保存します。ただし、これは常に同じ変数 &lt;code&gt;i&lt;/code&gt; であるため、2つのクロージャは同じように動作します。 &lt;code&gt;let&lt;/code&gt; を使用して、 &lt;code&gt;i&lt;/code&gt; の新しいバインディングを作成できます。</target>
        </trans-unit>
        <trans-unit id="f311d723a18a177fef2791eca3f472638877d565" translate="yes" xml:space="preserve">
          <source>Here we created a function &lt;code&gt;change_array!&lt;/code&gt;, that assigns &lt;code&gt;5&lt;/code&gt; to the first element of the passed array (bound to &lt;code&gt;x&lt;/code&gt; at the call site, and bound to &lt;code&gt;A&lt;/code&gt; within the function). Notice that, after the function call, &lt;code&gt;x&lt;/code&gt; is still bound to the same array, but the content of that array changed: the variables &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; were distinct bindings referring to the same mutable &lt;code&gt;Array&lt;/code&gt; object.</source>
          <target state="translated">ここでは、関数 &lt;code&gt;change_array!&lt;/code&gt; を作成しました。、渡された配列の最初の要素に &lt;code&gt;5&lt;/code&gt; を割り当てます（呼び出しサイトで &lt;code&gt;x&lt;/code&gt; にバインドされ、関数内で &lt;code&gt;A&lt;/code&gt; にバインドされます）。関数呼び出しの後も、 &lt;code&gt;x&lt;/code&gt; は同じ配列にバインドされていますが、その配列の内容は変更されています。変数 &lt;code&gt;A&lt;/code&gt; と &lt;code&gt;x&lt;/code&gt; は、同じ可変の &lt;code&gt;Array&lt;/code&gt; オブジェクトを参照する別個のバインディングでした。</target>
        </trans-unit>
        <trans-unit id="36a8f92884e992830034696fb443df46cbb7f016" translate="yes" xml:space="preserve">
          <source>Here we define a sampler for a collection. If no pre-computed data is required, it can be implemented with a &lt;code&gt;SamplerTrivial&lt;/code&gt; sampler, which is in fact the &lt;em&gt;default fallback for values&lt;/em&gt;.</source>
          <target state="translated">ここでは、コレクションのサンプラーを定義します。事前に計算されたデータが必要ない場合は、 &lt;code&gt;SamplerTrivial&lt;/code&gt; サンプラーを使用して実装でき&lt;em&gt;ます&lt;/em&gt;。これは実際には&lt;em&gt;値のデフォルトのフォールバックです&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="97836fe829ccf3f620529d58616382e12cd6d98d" translate="yes" xml:space="preserve">
          <source>Here we have created a type &lt;code&gt;BitVector&lt;/code&gt; which has no parameters, but where the element-type is still fully specified, with &lt;code&gt;T&lt;/code&gt; equal to &lt;code&gt;Bool&lt;/code&gt;!</source>
          <target state="translated">ここでは、パラメーターを持たないタイプ &lt;code&gt;BitVector&lt;/code&gt; を作成しましたが、要素タイプはまだ完全に指定されており、 &lt;code&gt;T&lt;/code&gt; は &lt;code&gt;Bool&lt;/code&gt; に等しくなっています。</target>
        </trans-unit>
        <trans-unit id="5afb8d5acf60ecdcd4dfe5d3e5a47e7bac7660ac" translate="yes" xml:space="preserve">
          <source>Here we use &lt;a href=&quot;../../base/base/index#Base.include_string&quot;&gt;&lt;code&gt;include_string&lt;/code&gt;&lt;/a&gt;, to evaluate &lt;code&gt;code&lt;/code&gt; as though it were the contents of a file. We could also save &lt;code&gt;code&lt;/code&gt; to a file and then call &lt;code&gt;include&lt;/code&gt; on that file&amp;mdash;the result would be the same. As you can see, this behaves quite different from evaluating the same code in the REPL. Let's break down what's happening here:</source>
          <target state="translated">ここでは、&lt;a href=&quot;../../base/base/index#Base.include_string&quot;&gt; &lt;code&gt;include_string&lt;/code&gt; &lt;/a&gt;を使用して、ファイルの内容であるかのように &lt;code&gt;code&lt;/code&gt; を評価します。 &lt;code&gt;code&lt;/code&gt; をファイルに保存してから、そのファイルで &lt;code&gt;include&lt;/code&gt; を呼び出すこともできます。結果は同じです。ご覧のとおり、これはREPLで同じコードを評価する場合とはまったく異なる動作をします。ここで何が起こっているのかを分析してみましょう。</target>
        </trans-unit>
        <trans-unit id="2b9af6aad35623f9ee689638f54770ed7633fd26" translate="yes" xml:space="preserve">
          <source>Here's a brief example:</source>
          <target state="translated">簡単な例を挙げてみましょう。</target>
        </trans-unit>
        <trans-unit id="e0b11719421310c6cc4a896b044019316b57f70b" translate="yes" xml:space="preserve">
          <source>Here's a simple example of running an external program:</source>
          <target state="translated">ここでは、外部プログラムを実行する簡単な例を紹介します。</target>
        </trans-unit>
        <trans-unit id="1cdb1c514a8c4179306e34bfddd814358210098d" translate="yes" xml:space="preserve">
          <source>Here, &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; first opens the file for writing and then passes the resulting output stream to the anonymous function you defined in the &lt;code&gt;do ... end&lt;/code&gt; block. After your function exits, &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; will make sure that the stream is properly closed, regardless of whether your function exited normally or threw an exception. (The &lt;code&gt;try/finally&lt;/code&gt; construct will be described in &lt;a href=&quot;../control-flow/index#Control-Flow&quot;&gt;Control Flow&lt;/a&gt;.)</source>
          <target state="translated">ここで、&lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt; &lt;code&gt;open&lt;/code&gt; は&lt;/a&gt;最初に書き込み用にファイルを開き、次に結果の出力ストリームを &lt;code&gt;do ... end&lt;/code&gt; ブロックで定義した無名関数に渡します。関数が終了した後、&lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt;は、関数が正常に終了したか例外をスローしたかに関係なく、ストリームが適切に閉じられていることを確認します。（ &lt;code&gt;try/finally&lt;/code&gt; コンストラクトについては&lt;a href=&quot;../control-flow/index#Control-Flow&quot;&gt;制御フロー&lt;/a&gt;で説明します。）</target>
        </trans-unit>
        <trans-unit id="20a6acaa904201f8599df8ef13450aeef27c5681" translate="yes" xml:space="preserve">
          <source>Here, &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; first opens the file for writing and then passes the resulting output stream to the anonymous function you defined in the &lt;code&gt;do ... end&lt;/code&gt; block. After your function exits, &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; will make sure that the stream is properly closed, regardless of whether your function exited normally or threw an exception. (The &lt;code&gt;try/finally&lt;/code&gt; construct will be described in &lt;a href=&quot;../control-flow/index#Control-Flow-1&quot;&gt;Control Flow&lt;/a&gt;.)</source>
          <target state="translated">ここで、&lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt; &lt;code&gt;open&lt;/code&gt; は&lt;/a&gt;最初に書き込み用にファイルを開き、次に結果の出力ストリームを &lt;code&gt;do ... end&lt;/code&gt; ブロックで定義した無名関数に渡します。関数が終了した後、&lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt;は、関数が正常に終了したか、例外をスローしたかに関係なく、ストリームが適切に閉じられていることを確認します。（ &lt;code&gt;try/finally&lt;/code&gt; コンストラクトについては、&lt;a href=&quot;../control-flow/index#Control-Flow-1&quot;&gt;制御フロー&lt;/a&gt;で説明します。）</target>
        </trans-unit>
        <trans-unit id="b6b3a9234aa3e202da30078d8340c4a596ef7790" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;(2, 3)&lt;/code&gt; is a &lt;a href=&quot;../../base/base/index#Core.Tuple&quot;&gt;&lt;code&gt;Tuple&lt;/code&gt;&lt;/a&gt; and the first argument &amp;mdash; the element type &amp;mdash; is optional, defaulting to &lt;code&gt;Float64&lt;/code&gt;.</source>
          <target state="translated">ここで、 &lt;code&gt;(2, 3)&lt;/code&gt; は&lt;a href=&quot;../../base/base/index#Core.Tuple&quot;&gt; &lt;code&gt;Tuple&lt;/code&gt; &lt;/a&gt;あり、最初の引数（要素タイプ）はオプションであり、デフォルトは &lt;code&gt;Float64&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="7a90ca3f6b58f2547fca94266c1813296e387071" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;(2, 3)&lt;/code&gt; is a &lt;a href=&quot;../../base/base/index#Core.Tuple&quot;&gt;&lt;code&gt;Tuple&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ここで、 &lt;code&gt;(2, 3)&lt;/code&gt; は&lt;a href=&quot;../../base/base/index#Core.Tuple&quot;&gt; &lt;code&gt;Tuple&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="5216371c7d0926d72d95ff987a3d80e32321d1dd" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;count&lt;/code&gt; finds the number of commits along the walk with a certain &lt;code&gt;GitHash&lt;/code&gt;. Since the &lt;code&gt;GitHash&lt;/code&gt; is unique to a commit, &lt;code&gt;cnt&lt;/code&gt; will be &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">ここで、 &lt;code&gt;count&lt;/code&gt; は、特定の &lt;code&gt;GitHash&lt;/code&gt; でのウォークに沿ったコミットの数を見つけます。以来 &lt;code&gt;GitHash&lt;/code&gt; がコミットに一意である、 &lt;code&gt;cnt&lt;/code&gt; なります &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2161ca87d055525464e4a5b1fd21109ca2813404" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;map&lt;/code&gt; visits each commit using the &lt;code&gt;GitRevWalker&lt;/code&gt; and finds its &lt;code&gt;GitHash&lt;/code&gt;.</source>
          <target state="translated">ここでは、 &lt;code&gt;map&lt;/code&gt; 訪問は、それぞれ使用してコミット &lt;code&gt;GitRevWalker&lt;/code&gt; をし、その見つけ &lt;code&gt;GitHash&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="290a784ce45faad752be9227fb340601f3f76ead" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;sp.data&lt;/code&gt; refers to the second parameter in the call to the &lt;code&gt;SamplerSimple&lt;/code&gt; constructor (in this case equal to &lt;code&gt;Sampler(rng, 1:die.nsides, r)&lt;/code&gt;), while the &lt;code&gt;Die&lt;/code&gt; object can be accessed via &lt;code&gt;sp[]&lt;/code&gt;.</source>
          <target state="translated">ここで、 &lt;code&gt;sp.data&lt;/code&gt; は &lt;code&gt;SamplerSimple&lt;/code&gt; コンストラクターへの呼び出しの2番目のパラメーター（この場合は &lt;code&gt;Sampler(rng, 1:die.nsides, r)&lt;/code&gt; 参照していますが、 &lt;code&gt;Die&lt;/code&gt; オブジェクトは &lt;code&gt;sp[]&lt;/code&gt; 介してアクセスできます。</target>
        </trans-unit>
        <trans-unit id="e6537ead3e178965ea266058307a50f1c2fbf640" translate="yes" xml:space="preserve">
          <source>Here, Julia was able to detect that &lt;code&gt;B&lt;/code&gt; is in fact symmetric, and used a more appropriate factorization. Often it's possible to write more efficient code for a matrix that is known to have certain properties e.g. it is symmetric, or tridiagonal. Julia provides some special types so that you can &quot;tag&quot; matrices as having these properties. For instance:</source>
          <target state="translated">ここで、ジュリアは &lt;code&gt;B&lt;/code&gt; が実際に対称であることを検出でき、より適切な因数分解を使用しました。多くの場合、特定のプロパティを持っていることが知られているマトリックスに対して、より効率的なコードを書くことが可能です。Juliaはいくつかの特別なタイプを提供するので、これらのプロパティを持つように行列に「タグを付ける」ことができます。例えば：</target>
        </trans-unit>
        <trans-unit id="c40867232cf6016f6f8e42d642627bb64b253d86" translate="yes" xml:space="preserve">
          <source>Here, the evaluation of an expression object causes a value to be assigned to the global variable &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">ここでは、式オブジェクトの評価により、グローバル変数 &lt;code&gt;x&lt;/code&gt; に値が割り当てられます。</target>
        </trans-unit>
        <trans-unit id="6153340adbaa08a931cc654aec620e3452eb7b03" translate="yes" xml:space="preserve">
          <source>Here, the input &lt;code&gt;p&lt;/code&gt; is declared to be of type &lt;code&gt;Ref{gsl_permutation}&lt;/code&gt;, meaning that the memory that &lt;code&gt;p&lt;/code&gt; points to may be managed by Julia or by C. A pointer to memory allocated by C should be of type &lt;code&gt;Ptr{gsl_permutation}&lt;/code&gt;, but it is convertible using &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt;&lt;code&gt;Base.cconvert&lt;/code&gt;&lt;/a&gt; and therefore</source>
          <target state="translated">ここで、入力 &lt;code&gt;p&lt;/code&gt; は &lt;code&gt;Ref{gsl_permutation}&lt;/code&gt; 型であると宣言されています。つまり、 &lt;code&gt;p&lt;/code&gt; が指すメモリはJuliaまたはCによって管理できます。Cによって割り当てられたメモリへのポインタは &lt;code&gt;Ptr{gsl_permutation}&lt;/code&gt; 型である必要がありますが、&lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt; &lt;code&gt;Base.cconvert&lt;/code&gt; &lt;/a&gt;を使用して変換可能であるため、</target>
        </trans-unit>
        <trans-unit id="c4e6a3f428f565fb6b0000baaea7b4aa785dbcfc" translate="yes" xml:space="preserve">
          <source>Here, the input &lt;code&gt;p&lt;/code&gt; is declared to be of type &lt;code&gt;Ref{gsl_permutation}&lt;/code&gt;, meaning that the memory that &lt;code&gt;p&lt;/code&gt; points to may be managed by Julia or by C. A pointer to memory allocated by C should be of type &lt;code&gt;Ptr{gsl_permutation}&lt;/code&gt;, but it is convertible using &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt;&lt;code&gt;Base.cconvert&lt;/code&gt;&lt;/a&gt; and therefore can be used in the same (covariant) context of the input argument to a &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt;. A pointer to memory allocated by Julia must be of type &lt;code&gt;Ref{gsl_permutation}&lt;/code&gt;, to ensure that the memory address pointed to is valid and that Julia's garbage collector manages the chunk of memory pointed to correctly. Therefore, the &lt;code&gt;Ref{gsl_permutation}&lt;/code&gt; declaration allows pointers managed by C or Julia to be used.</source>
          <target state="translated">ここで、入力 &lt;code&gt;p&lt;/code&gt; は &lt;code&gt;Ref{gsl_permutation}&lt;/code&gt; 型であると宣言されています。これは、 &lt;code&gt;p&lt;/code&gt; が指すメモリがJuliaまたはCによって管理される可能性があることを意味します。Cによって割り当てられたメモリへのポインタは、 &lt;code&gt;Ptr{gsl_permutation}&lt;/code&gt; 型である必要がありますが、&lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt; &lt;code&gt;Base.cconvert&lt;/code&gt; &lt;/a&gt;を使用して変換できるため、&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt;への入力引数と同じ（共変）コンテキストで使用できます。Juliaによって割り当てられたメモリへのポインタは &lt;code&gt;Ref{gsl_permutation}&lt;/code&gt; 型である必要があります。これは、ポイントされたメモリアドレスが有効であり、Juliaのガベージコレクタがポイントされたメモリのチャンクを正しく管理していることを確認します。したがって、 &lt;code&gt;Ref{gsl_permutation}&lt;/code&gt; 宣言により、CまたはJuliaによって管理されるポインターを使用できます。</target>
        </trans-unit>
        <trans-unit id="1ab09345f1dd2caf08c8b3f5ca36d5682164ea59" translate="yes" xml:space="preserve">
          <source>Here, the option &lt;code&gt;--math-mode=ieee&lt;/code&gt; disables the &lt;code&gt;@fastmath&lt;/code&gt; macro, so that we can compare results.</source>
          <target state="translated">ここで、オプション &lt;code&gt;--math-mode=ieee&lt;/code&gt; は &lt;code&gt;@fastmath&lt;/code&gt; マクロを無効にし、結果を比較できるようにします。</target>
        </trans-unit>
        <trans-unit id="6cbc6c9a872faab52c966ca377e3e05b9b758b19" translate="yes" xml:space="preserve">
          <source>Here, the total produced by &lt;code&gt;sum&lt;/code&gt; is passed to the &lt;code&gt;sqrt&lt;/code&gt; function. The equivalent composition would be:</source>
          <target state="translated">ここでは、合計によって生成された &lt;code&gt;sum&lt;/code&gt; が関数 &lt;code&gt;sqrt&lt;/code&gt; に渡されます。同等の構成は次のようになります。</target>
        </trans-unit>
        <trans-unit id="4e8ac284e43281c0f4a614327786f479a4ecc8c6" translate="yes" xml:space="preserve">
          <source>Here, though, we'll use the text-based display that comes with the standard library:</source>
          <target state="translated">しかし、ここでは標準ライブラリに付属のテキストベースの表示を使用します。</target>
        </trans-unit>
        <trans-unit id="eab8445a2aa7f75fce1fbdd298d4317a2e164c25" translate="yes" xml:space="preserve">
          <source>Here, we happened to know that the first element of &lt;code&gt;a&lt;/code&gt; would be an &lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt;&lt;code&gt;Int32&lt;/code&gt;&lt;/a&gt;. Making an annotation like this has the added benefit that it will raise a run-time error if the value is not of the expected type, potentially catching certain bugs earlier.</source>
          <target state="translated">ここで、&lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt; &lt;code&gt;Int32&lt;/code&gt; &lt;/a&gt;も &lt;code&gt;a&lt;/code&gt; の最初の要素がInt32であることがわかりました。このようなアノテーションを作成すると、値が予期したタイプではない場合に実行時エラーが発生し、特定のバグを早期に検出できるという追加の利点があります。</target>
        </trans-unit>
        <trans-unit id="3b5f47a75f954e4b2fddf51e62aa2e1f9d263c7c" translate="yes" xml:space="preserve">
          <source>Here, we want &lt;code&gt;t0&lt;/code&gt;, &lt;code&gt;t1&lt;/code&gt;, and &lt;code&gt;val&lt;/code&gt; to be private temporary variables, and we want &lt;code&gt;time&lt;/code&gt; to refer to the &lt;code&gt;time&lt;/code&gt; function in Julia Base, not to any &lt;code&gt;time&lt;/code&gt; variable the user might have (the same applies to &lt;code&gt;println&lt;/code&gt;). Imagine the problems that could occur if the user expression &lt;code&gt;ex&lt;/code&gt; also contained assignments to a variable called &lt;code&gt;t0&lt;/code&gt;, or defined its own &lt;code&gt;time&lt;/code&gt; variable. We might get errors, or mysteriously incorrect behavior.</source>
          <target state="translated">ここでは、 &lt;code&gt;t0&lt;/code&gt; 、 &lt;code&gt;t1&lt;/code&gt; 、および &lt;code&gt;val&lt;/code&gt; をプライベートな一時変数にし、ユーザーが持つ可能性のある &lt;code&gt;time&lt;/code&gt; 変数ではなく、Julia Baseの &lt;code&gt;time&lt;/code&gt; 関数を参照する &lt;code&gt;time&lt;/code&gt; を求めます（ &lt;code&gt;println&lt;/code&gt; にも同じことが当てはまります）。ユーザー式 &lt;code&gt;ex&lt;/code&gt; に &lt;code&gt;t0&lt;/code&gt; と呼ばれる変数への割り当てが含まれているか、独自の &lt;code&gt;time&lt;/code&gt; 変数が定義されている場合に発生する可能性がある問題を想像してください。エラーや不思議な不正確な動作が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="9694586c6d84150f32d012165fb51d66a0071dfd" translate="yes" xml:space="preserve">
          <source>Here, we've added a custom constructor function so that it can take arguments of different &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt; types and promote them to a common type (see &lt;a href=&quot;../constructors/index#man-constructors&quot;&gt;Constructors&lt;/a&gt; and &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion&quot;&gt;Conversion and Promotion&lt;/a&gt;). (Of course, we would have to define lots of other methods, too, to make it act like a &lt;a href=&quot;../../base/numbers/index#Core.Number&quot;&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/a&gt;, e.g. &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;one&lt;/code&gt;, &lt;code&gt;zero&lt;/code&gt;, promotion rules and so on.) By default, instances of this type display rather simply, with information about the type name and the field values, as e.g. &lt;code&gt;Polar{Float64}(3.0,4.0)&lt;/code&gt;.</source>
          <target state="translated">ここでは、カスタムコンストラクター関数を追加して、さまざまな&lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt;タイプの引数を受け取り、それらを共通のタイプにプロモートできるようにしました（&lt;a href=&quot;../constructors/index#man-constructors&quot;&gt;コンストラクター&lt;/a&gt;と&lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion&quot;&gt;変換とプロモーションを&lt;/a&gt;参照）。 （もちろん、我々はそれがのように動作させるために、あまりにも、他の方法の多くを定義する必要があります&lt;a href=&quot;../../base/numbers/index#Core.Number&quot;&gt; &lt;code&gt;Number&lt;/code&gt; &lt;/a&gt;例えば、 &lt;code&gt;+&lt;/code&gt; 、 &lt;code&gt;*&lt;/code&gt; 、 &lt;code&gt;one&lt;/code&gt; 、 &lt;code&gt;zero&lt;/code&gt; 、プロモーションルールなどがあります。）デフォルトでは、このタイプのディスプレイのインスタンスではなく、単に、タイプ名とフィールド値に関する情報 &lt;code&gt;Polar{Float64}(3.0,4.0)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="94fb6a6428243b8c36b29add8e81342285442dea" translate="yes" xml:space="preserve">
          <source>Here, we've added a custom constructor function so that it can take arguments of different &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt; types and promote them to a common type (see &lt;a href=&quot;../constructors/index#man-constructors-1&quot;&gt;Constructors&lt;/a&gt; and &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;Conversion and Promotion&lt;/a&gt;). (Of course, we would have to define lots of other methods, too, to make it act like a &lt;a href=&quot;../../base/numbers/index#Core.Number&quot;&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/a&gt;, e.g. &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;one&lt;/code&gt;, &lt;code&gt;zero&lt;/code&gt;, promotion rules and so on.) By default, instances of this type display rather simply, with information about the type name and the field values, as e.g. &lt;code&gt;Polar{Float64}(3.0,4.0)&lt;/code&gt;.</source>
          <target state="translated">ここでは、異なる&lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt;型の引数を取り、それらを共通の型に昇格できるように、カスタムコンストラクター関数を追加しました（&lt;a href=&quot;../constructors/index#man-constructors-1&quot;&gt;コンストラクター&lt;/a&gt;と&lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;変換および昇格を&lt;/a&gt;参照）。 （もちろん、他の多くのメソッドも定義して、 &lt;code&gt;+&lt;/code&gt; 、 &lt;code&gt;*&lt;/code&gt; 、 &lt;code&gt;one&lt;/code&gt; 、 &lt;code&gt;zero&lt;/code&gt; 、プロモーションルールなどの&lt;a href=&quot;../../base/numbers/index#Core.Number&quot;&gt; &lt;code&gt;Number&lt;/code&gt; の&lt;/a&gt;ように動作させる必要があります。）デフォルトでは、このタイプのインスタンスはかなり単純に表示されます。 、たとえば、 &lt;code&gt;Polar{Float64}(3.0,4.0)&lt;/code&gt; 、タイプ名とフィールド値に関する情報を含みます。</target>
        </trans-unit>
        <trans-unit id="7a8c4e9914a1889e98efb20fcf34b5a7f7c01253" translate="yes" xml:space="preserve">
          <source>Here, you've created the same problem all over again: the compiler can't guess what &lt;code&gt;n&lt;/code&gt; is, so it doesn't know the &lt;em&gt;type&lt;/em&gt; of &lt;code&gt;Val(n)&lt;/code&gt;. Attempting to use &lt;code&gt;Val&lt;/code&gt;, but doing so incorrectly, can easily make performance &lt;em&gt;worse&lt;/em&gt; in many situations. (Only in situations where you're effectively combining &lt;code&gt;Val&lt;/code&gt; with the function-barrier trick, to make the kernel function more efficient, should code like the above be used.)</source>
          <target state="translated">ここでは、同じ問題を繰り返し作成しました。コンパイラーは &lt;code&gt;n&lt;/code&gt; が何であるかを推測できないため、 &lt;code&gt;Val(n)&lt;/code&gt; の&lt;em&gt;タイプ&lt;/em&gt;がわかりません。 &lt;code&gt;Val&lt;/code&gt; を使用しようとすると、誤って使用すると、多くの状況でパフォーマンスが&lt;em&gt;低下&lt;/em&gt;する可能性があります。（ &lt;code&gt;Val&lt;/code&gt; と関数バリアトリックを効果的に組み合わせる状況でのみ、カーネル関数をより効率的にするために、上記のようなコードを使用する必要があります。）&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c7628673517938376c201f828128315e60314655" translate="yes" xml:space="preserve">
          <source>Hermitian Conjugate Matrix</source>
          <target state="translated">エルミトス共役行列</target>
        </trans-unit>
        <trans-unit id="7426047f57253430c62cd4ed4e8350b30626acf7" translate="yes" xml:space="preserve">
          <source>Hermitian matrix</source>
          <target state="translated">仙人行列</target>
        </trans-unit>
        <trans-unit id="10678e1b00011a887c8ed10343c313db680c592e" translate="yes" xml:space="preserve">
          <source>Hessenberg decomposition</source>
          <target state="translated">ヘッセンベルク分解</target>
        </trans-unit>
        <trans-unit id="18dcd84b08d39e78997dcf4fc69cbfdf65766429" translate="yes" xml:space="preserve">
          <source>Hex bytes (&lt;code&gt;\x&lt;/code&gt; with 1-2 trailing hex digits)</source>
          <target state="translated">16進バイト（1から2桁の16進数が続く &lt;code&gt;\x&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="5829ae1ed6f556d7c22293c127a375905a4cde38" translate="yes" xml:space="preserve">
          <source>Hexadecimal floating-point literals are also valid, but only as &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; values, with &lt;code&gt;p&lt;/code&gt; preceding the base-2 exponent:</source>
          <target state="translated">16進浮動小数点リテラルも有効ですが、&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;値としてのみ、 &lt;code&gt;p&lt;/code&gt; が 2を底とする指数の前にあります。</target>
        </trans-unit>
        <trans-unit id="566a781a74cd1186e4a86a913b9dfbcd8a9760f5" translate="yes" xml:space="preserve">
          <source>Hibiscus</source>
          <target state="translated">Hibiscus</target>
        </trans-unit>
        <trans-unit id="590d79aff0a27abac1599349b9f60e654406e4f9" translate="yes" xml:space="preserve">
          <source>High Brightness Symbol</source>
          <target state="translated">高輝度シンボル</target>
        </trans-unit>
        <trans-unit id="5c42b554d600e8a00d6d46015f5546b8d19934a3" translate="yes" xml:space="preserve">
          <source>High Voltage Sign</source>
          <target state="translated">高電圧記号</target>
        </trans-unit>
        <trans-unit id="ab1b93cb46a149db7c34f14c047358adef0d1f47" translate="yes" xml:space="preserve">
          <source>High-Heeled Shoe</source>
          <target state="translated">ハイヒールの靴</target>
        </trans-unit>
        <trans-unit id="22cda4a90e394a1d9c3ad940b9369d0797179dd6" translate="yes" xml:space="preserve">
          <source>High-Level Embedding</source>
          <target state="translated">ハイレベルエンベッディング</target>
        </trans-unit>
        <trans-unit id="772ba23e35e2b9a933b76e30398f7eb414430f46" translate="yes" xml:space="preserve">
          <source>High-Level Embedding on Windows with Visual Studio</source>
          <target state="translated">Visual Studioを使ったWindowsでの高レベルエンベッディング</target>
        </trans-unit>
        <trans-unit id="9f567cb6bf549d8f1f72a7aad5d5c25bc17a082a" translate="yes" xml:space="preserve">
          <source>High-Speed Train</source>
          <target state="translated">高速列車</target>
        </trans-unit>
        <trans-unit id="00e1cd5d9c96d48229c7017e30357cb8a8d1334d" translate="yes" xml:space="preserve">
          <source>High-Speed Train With Bullet Nose</source>
          <target state="translated">弾丸の鼻が付いている高速列車</target>
        </trans-unit>
        <trans-unit id="1b2be27c3b5a49f7125a227298d591cb7aea55af" translate="yes" xml:space="preserve">
          <source>High-level libraries like &lt;a href=&quot;https://github.com/JuliaComputing/ArrayFire.jl&quot;&gt;ArrayFire.jl&lt;/a&gt; and &lt;a href=&quot;https://github.com/JuliaGPU/GPUArrays.jl&quot;&gt;GPUArrays.jl&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/JuliaComputing/ArrayFire.jl&quot;&gt;ArrayFire.jl&lt;/a&gt;や&lt;a href=&quot;https://github.com/JuliaGPU/GPUArrays.jl&quot;&gt;GPUArrays.jl&lt;/a&gt;などの高レベルライブラリ</target>
        </trans-unit>
        <trans-unit id="7e0b3549b5782921269587cd589e55b82058b718" translate="yes" xml:space="preserve">
          <source>High-level vendor-specific abstractions like &lt;a href=&quot;https://github.com/JuliaGPU/CuArrays.jl&quot;&gt;CuArrays.jl&lt;/a&gt; and &lt;a href=&quot;https://github.com/JuliaGPU/CLArrays.jl&quot;&gt;CLArrays.jl&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/JuliaGPU/CuArrays.jl&quot;&gt;CuArrays.jl&lt;/a&gt;や&lt;a href=&quot;https://github.com/JuliaGPU/CLArrays.jl&quot;&gt;CLArrays.jl&lt;/a&gt;などのベンダー固有の高レベルの抽象化</target>
        </trans-unit>
        <trans-unit id="cef2d62c8136407d7a5910b738c2a4954d1ff380" translate="yes" xml:space="preserve">
          <source>Hocho</source>
          <target state="translated">Hocho</target>
        </trans-unit>
        <trans-unit id="1183df425fd69adfff4afc7c4b9f794b3027f62e" translate="yes" xml:space="preserve">
          <source>Hold up: why macros?</source>
          <target state="translated">待ってください:なぜマクロなのですか?</target>
        </trans-unit>
        <trans-unit id="a19d1b5e13bc5eadd5512a5657629c48486fc2aa" translate="yes" xml:space="preserve">
          <source>Holds a reference to an object of type &lt;code&gt;T&lt;/code&gt;, ensuring that it is only accessed atomically, i.e. in a thread-safe manner.</source>
          <target state="translated">タイプ &lt;code&gt;T&lt;/code&gt; のオブジェクトへの参照を保持し、それがアトミックに、つまりスレッドセーフな方法でのみアクセスされることを保証します。</target>
        </trans-unit>
        <trans-unit id="6d4b2c4793516d9999da8f3caabfcc7a3164599f" translate="yes" xml:space="preserve">
          <source>Home, &lt;code&gt;^A&lt;/code&gt;</source>
          <target state="translated">ホーム、 &lt;code&gt;^A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="85d163149ee6c8d4bb4972a8d9d62f2349badb11" translate="yes" xml:space="preserve">
          <source>Homothetic</source>
          <target state="translated">Homothetic</target>
        </trans-unit>
        <trans-unit id="642aac9525060b37b0f7470d6f6c49db706b03d9" translate="yes" xml:space="preserve">
          <source>Honey Pot</source>
          <target state="translated">ハニーポット</target>
        </trans-unit>
        <trans-unit id="a643db335a306154edebc33a5e2763a380d1411b" translate="yes" xml:space="preserve">
          <source>Honeybee</source>
          <target state="translated">Honeybee</target>
        </trans-unit>
        <trans-unit id="79734fdcfe66d25a072a5769ba821cd7967d89f5" translate="yes" xml:space="preserve">
          <source>Hooking into the &lt;code&gt;Random&lt;/code&gt; API</source>
          <target state="translated">&lt;code&gt;Random&lt;/code&gt; API へのフック</target>
        </trans-unit>
        <trans-unit id="a938072797969a150ccb7384d30e3585d81c5ec0" translate="yes" xml:space="preserve">
          <source>Horizontal Black Hexagon</source>
          <target state="translated">横型黒六角</target>
        </trans-unit>
        <trans-unit id="9d0c97d942673d5e711ab71b642cc25b6f24a2b9" translate="yes" xml:space="preserve">
          <source>Horizontal Ellipsis</source>
          <target state="translated">水平方向のエリプシス</target>
        </trans-unit>
        <trans-unit id="3627a44f223e474759956cf47448b20612b0d19a" translate="yes" xml:space="preserve">
          <source>Horizontal Traffic Light</source>
          <target state="translated">水平方向の信号機</target>
        </trans-unit>
        <trans-unit id="b7e611daf03b332b5f4ec9209097868ee372b256" translate="yes" xml:space="preserve">
          <source>Horizontal and vertical concatenation in one call. This function is called for block matrix syntax. The first argument specifies the number of arguments to concatenate in each block row.</source>
          <target state="translated">1回の呼び出しで水平と垂直の連結を行います。この関数はブロック行列構文のために呼び出されます。第1引数には、各ブロック行で連結する引数の数を指定します。</target>
        </trans-unit>
        <trans-unit id="f26372d5f0aca43e155e7d006ab50ec72ec57fe2" translate="yes" xml:space="preserve">
          <source>Horizontal rules</source>
          <target state="translated">水平方向のルール</target>
        </trans-unit>
        <trans-unit id="26dfe8116b93ced6cfca858f375d23f1489d3207" translate="yes" xml:space="preserve">
          <source>Horse</source>
          <target state="translated">Horse</target>
        </trans-unit>
        <trans-unit id="4a166dcec39a913a939b3a42f695d1c218fcaebb" translate="yes" xml:space="preserve">
          <source>Horse Face</source>
          <target state="translated">馬の顔</target>
        </trans-unit>
        <trans-unit id="8f21624d2501467ee4a054c705bd995e4b73ebab" translate="yes" xml:space="preserve">
          <source>Horse Racing</source>
          <target state="translated">競馬</target>
        </trans-unit>
        <trans-unit id="dbb927867e102f755c1433b1f25539bafdd7268b" translate="yes" xml:space="preserve">
          <source>Hospital</source>
          <target state="translated">Hospital</target>
        </trans-unit>
        <trans-unit id="ef97c144078e1020e0c1fdf8b383ff06d12e8270" translate="yes" xml:space="preserve">
          <source>Hot Beverage</source>
          <target state="translated">ホット飲料</target>
        </trans-unit>
        <trans-unit id="cb506dd41a005a6fcc0d4c18104ce66e01d7afa8" translate="yes" xml:space="preserve">
          <source>Hot Springs</source>
          <target state="translated">温泉</target>
        </trans-unit>
        <trans-unit id="9c4ba7d047eb56093b34e5dc3e51e5fcc74603f4" translate="yes" xml:space="preserve">
          <source>Hotel</source>
          <target state="translated">Hotel</target>
        </trans-unit>
        <trans-unit id="c29e8e28d3952318903de2fb6079804d2ed9d9e6" translate="yes" xml:space="preserve">
          <source>Hour (24-hour clock) with a minimum width</source>
          <target state="translated">時間(24時間時計)の最小幅</target>
        </trans-unit>
        <trans-unit id="fcc1b57017e3ac9f33e4e51068baf64a23795adf" translate="yes" xml:space="preserve">
          <source>Hourglass</source>
          <target state="translated">Hourglass</target>
        </trans-unit>
        <trans-unit id="bf7a0304247679d7272f0a79f9d388f130597fd4" translate="yes" xml:space="preserve">
          <source>Hourglass With Flowing Sand</source>
          <target state="translated">流れる砂と砂時計</target>
        </trans-unit>
        <trans-unit id="dc8745ba30beefa5d028f85ba9b11599a2ac8d7e" translate="yes" xml:space="preserve">
          <source>House</source>
          <target state="translated">House</target>
        </trans-unit>
        <trans-unit id="b6ac911209d87615e6f295e017b36c332cd3b878" translate="yes" xml:space="preserve">
          <source>House Building</source>
          <target state="translated">家づくり</target>
        </trans-unit>
        <trans-unit id="b07df507eb5fd0e4b6c36328d58c64ebcc7b5d32" translate="yes" xml:space="preserve">
          <source>House With Garden</source>
          <target state="translated">庭のある家</target>
        </trans-unit>
        <trans-unit id="75af347bffc8062b7ea5afa0a699184af65b1a37" translate="yes" xml:space="preserve">
          <source>How can I constrain or compute type parameters?</source>
          <target state="translated">型のパラメータを制約したり、計算したりするにはどうすればいいですか?</target>
        </trans-unit>
        <trans-unit id="eefa8d28bdac822ea112d7e5259409579ba61c80" translate="yes" xml:space="preserve">
          <source>How can I modify the declaration of a type in my session?</source>
          <target state="translated">セッションで型の宣言を修正するにはどうすればいいですか?</target>
        </trans-unit>
        <trans-unit id="515d85b9b31cb430ad4b0705dfed0fd34c859e1a" translate="yes" xml:space="preserve">
          <source>How did the file name get quoted? Julia knows that &lt;code&gt;file&lt;/code&gt; is meant to be interpolated as a single argument, so it quotes the word for you. Actually, that is not quite accurate: the value of &lt;code&gt;file&lt;/code&gt; is never interpreted by a shell, so there's no need for actual quoting; the quotes are inserted only for presentation to the user. This will even work if you interpolate a value as part of a shell word:</source>
          <target state="translated">ファイル名はどのように引用されましたか？ジュリアは、 &lt;code&gt;file&lt;/code&gt; が単一の引数として補間されることを意図していることを知っているので、単語を引用します。値：実際に、それは非常に正確ではない &lt;code&gt;file&lt;/code&gt; 、シェルによって解釈されることはありませんので、実際の引用のための必要はありません。引用符は、ユーザーに提示するためにのみ挿入されます。これは、シェルワードの一部として値を補間する場合でも機能します。</target>
        </trans-unit>
        <trans-unit id="7554712c2d173a82ff8ff4725649f94b899a6cab" translate="yes" xml:space="preserve">
          <source>How do I catch CTRL-C in a script?</source>
          <target state="translated">スクリプトでCTRL-Cをキャッチするには?</target>
        </trans-unit>
        <trans-unit id="2a65d886539b09798da7278037976d95b79a6f2f" translate="yes" xml:space="preserve">
          <source>How do I check if the current file is being run as the main script?</source>
          <target state="translated">現在のファイルがメインスクリプトとして実行されているかどうかを確認するには?</target>
        </trans-unit>
        <trans-unit id="07f058f4bf96d455fe968f2d1e89bd25936e7928" translate="yes" xml:space="preserve">
          <source>How do I delete an object in memory?</source>
          <target state="translated">メモリ内のオブジェクトを削除するには?</target>
        </trans-unit>
        <trans-unit id="07788c6091915f1a67274d44211a41dbc53e6935" translate="yes" xml:space="preserve">
          <source>How do I manage precompilation caches in distributed file systems?</source>
          <target state="translated">分散ファイルシステムでプリコンパイルキャッシュを管理するには?</target>
        </trans-unit>
        <trans-unit id="b215618760cff9b8483504445b91edb71bee5871" translate="yes" xml:space="preserve">
          <source>How do I pass options to &lt;code&gt;julia&lt;/code&gt; using &lt;code&gt;#!/usr/bin/env&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;#!/usr/bin/env&lt;/code&gt; を使用して &lt;code&gt;julia&lt;/code&gt; にオプションを渡すにはどうすればよいですか？</target>
        </trans-unit>
        <trans-unit id="eb9157ff1fb18352038c8a12eae2a15bbdb246dd" translate="yes" xml:space="preserve">
          <source>How does &quot;null&quot;, &quot;nothingness&quot; or &quot;missingness&quot; work in Julia?</source>
          <target state="translated">ジュリアの中で「ヌル」「無」「欠落」はどのように働くのでしょうか?</target>
        </trans-unit>
        <trans-unit id="b5188f1df50966f544cd1288a28b80d8b68a2b7f" translate="yes" xml:space="preserve">
          <source>How does one construct a &lt;code&gt;Point&lt;/code&gt; object? It is possible to define custom constructors for composite types, which will be discussed in detail in &lt;a href=&quot;../constructors/index#man-constructors&quot;&gt;Constructors&lt;/a&gt;, but in the absence of any special constructor declarations, there are two default ways of creating new composite objects, one in which the type parameters are explicitly given and the other in which they are implied by the arguments to the object constructor.</source>
          <target state="translated">&lt;code&gt;Point&lt;/code&gt; オブジェクトをどのように構築しますか？複合型のカスタムコンストラクターを定義することは可能です。これについては&lt;a href=&quot;../constructors/index#man-constructors&quot;&gt;コンストラクター&lt;/a&gt;で詳しく説明しますが、特別なコンストラクター宣言がない場合、新しい複合オブジェクトを作成するデフォルトの方法は2つあり、1つは型パラメーターが明示的に指定されます。もう1つは、オブジェクトコンストラクターへの引数によって暗示されます。</target>
        </trans-unit>
        <trans-unit id="fd885280d6cbd9f996932c72e9d360397c1bf016" translate="yes" xml:space="preserve">
          <source>How does one construct a &lt;code&gt;Point&lt;/code&gt; object? It is possible to define custom constructors for composite types, which will be discussed in detail in &lt;a href=&quot;../constructors/index#man-constructors-1&quot;&gt;Constructors&lt;/a&gt;, but in the absence of any special constructor declarations, there are two default ways of creating new composite objects, one in which the type parameters are explicitly given and the other in which they are implied by the arguments to the object constructor.</source>
          <target state="translated">どのようにして &lt;code&gt;Point&lt;/code&gt; オブジェクトを構築しますか？複合型のカスタムコンストラクターを定義することは可能です。これについては、&lt;a href=&quot;../constructors/index#man-constructors-1&quot;&gt;コンストラクター&lt;/a&gt;で詳しく説明しますが、特別なコンストラクター宣言がない場合、新しい複合オブジェクトを作成するデフォルトの方法が2つあり、1つは型パラメーターが明示的に指定されます。もう1つは、オブジェクトコンストラクターへの引数によって暗黙指定されます。</target>
        </trans-unit>
        <trans-unit id="06e308a7a0638232b6f09929d443c3620a3b020e" translate="yes" xml:space="preserve">
          <source>How these arguments are initialized depends on the &quot;outer&quot; function; here, &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; will sequentially set &lt;code&gt;x&lt;/code&gt; to &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt;, calling the anonymous function on each, just as would happen in the syntax &lt;code&gt;map(func, [A, B, C])&lt;/code&gt;.</source>
          <target state="translated">これらの引数の初期化方法は、「外部」関数によって異なります。ここで、&lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt;は、構文 &lt;code&gt;map(func, [A, B, C])&lt;/code&gt; と同じように、 &lt;code&gt;x&lt;/code&gt; を順次 &lt;code&gt;A&lt;/code&gt; 、 &lt;code&gt;B&lt;/code&gt; 、 &lt;code&gt;C&lt;/code&gt; に設定し、それぞれの無名関数を呼び出します。</target>
        </trans-unit>
        <trans-unit id="eaf97b67896b3cc13483847a79f98eac92d8c7ad" translate="yes" xml:space="preserve">
          <source>How you use this information is up to you. Obviously, it would be far and away best to fix &lt;code&gt;pos&lt;/code&gt; to be type-stable: if you did so, all of the variables in &lt;code&gt;f&lt;/code&gt; would be concrete, and its performance would be optimal. However, there are circumstances where this kind of &lt;em&gt;ephemeral&lt;/em&gt; type instability might not matter too much: for example, if &lt;code&gt;pos&lt;/code&gt; is never used in isolation, the fact that &lt;code&gt;f&lt;/code&gt;'s output is type-stable (for &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; inputs) will shield later code from the propagating effects of type instability. This is particularly relevant in cases where fixing the type instability is difficult or impossible. In such cases, the tips above (e.g., adding type annotations and/or breaking up functions) are your best tools to contain the &quot;damage&quot; from type instability. Also, note that even Julia Base has functions that are type unstable. For example, the function &lt;code&gt;findfirst&lt;/code&gt; returns the index into an array where a key is found, or &lt;code&gt;nothing&lt;/code&gt; if it is not found, a clear type instability. In order to make it easier to find the type instabilities that are likely to be important, &lt;code&gt;Union&lt;/code&gt;s containing either &lt;code&gt;missing&lt;/code&gt; or &lt;code&gt;nothing&lt;/code&gt; are color highlighted in yellow, instead of red.</source>
          <target state="translated">この情報の使い方はあなた次第です。明らかに、 &lt;code&gt;pos&lt;/code&gt; を型安定であるように修正するのがはるかに最善です。そうすると、 &lt;code&gt;f&lt;/code&gt; のすべての変数が具体的で、そのパフォーマンスが最適になります。ただし、この種の&lt;em&gt;一時的な&lt;/em&gt;型の不安定性があまり問題にならない状況もあります。たとえば、 &lt;code&gt;pos&lt;/code&gt; が単独で使用されない場合、 &lt;code&gt;f&lt;/code&gt; の出力は型が安定しているという事実（&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; の場合)&lt;/a&gt;入力）は、タイプの不安定性の伝播する影響から後のコードを保護します。これは、型の不安定性を修正することが困難または不可能である場合に特に関係があります。このような場合、上記のヒント（たとえば、型注釈の追加や関数の分割）は、型の不安定性による「損傷」を抑えるための最良のツールです。また、Julia Baseにも不安定型の関数があることに注意してください。たとえば、関数 &lt;code&gt;findfirst&lt;/code&gt; は、キーが見つかった配列のインデックスを返すか、キーが見つから &lt;code&gt;nothing&lt;/code&gt; 場合は何もない、明確な型の不安定性を返します。重要である可能性が高い型の不安定性を見つけやすくするために、 &lt;code&gt;Union&lt;/code&gt; には &lt;code&gt;missing&lt;/code&gt; か、 &lt;code&gt;nothing&lt;/code&gt; 含まれていない 赤ではなく黄色でハイライトされた色です。</target>
        </trans-unit>
        <trans-unit id="042ec23eb15357af1265112d56deb61892b131f1" translate="yes" xml:space="preserve">
          <source>However one should keep in mind, that macro dispatch is based on the types of AST that are handed to the macro, not the types that the AST evaluates to at runtime:</source>
          <target state="translated">しかし、マクロのディスパッチは、実行時にASTが評価する型ではなく、マクロに渡されるASTの型に基づいていることを覚えておく必要があります。</target>
        </trans-unit>
        <trans-unit id="ec8145ef611e8eb6adb7aa2875037ca9cf5cb809" translate="yes" xml:space="preserve">
          <source>However, all the information we need for the loop is embedded in the type information of the arguments. Thus, we can utilize generated functions to move the iteration to compile-time; in compiler parlance, we use generated functions to manually unroll the loop. The body becomes almost identical, but instead of calculating the linear index, we build up an &lt;em&gt;expression&lt;/em&gt; that calculates the index:</source>
          <target state="translated">ただし、ループに必要なすべての情報は、引数の型情報に埋め込まれています。したがって、生成された関数を利用して、反復をコンパイル時に移動できます。コンパイラ用語では、ループを手動で展開するために生成された関数を使用します。本体はほぼ同じになりますが、線形インデックスを計算する代わりに、インデックスを計算する&lt;em&gt;式&lt;/em&gt;を作成します。</target>
        </trans-unit>
        <trans-unit id="42e7ab564618248599a98b48397f91d9696cc5fd" translate="yes" xml:space="preserve">
          <source>However, doing this will also be very slow and leak memory, so you should usually avoid this and instead keep reading. The next section discusses how to use indirect calls to efficiently accomplish a similar effect.</source>
          <target state="translated">しかし、これを行うと非常に遅くなり、メモリをリークすることになるので、通常はこれを避けて読み続けるべきです。次のセクションでは、同様の効果を効率的に得るために間接的な呼び出しを使用する方法について説明します。</target>
        </trans-unit>
        <trans-unit id="d98a9aa4753704d7124f1d48bec32b6c3a7df644" translate="yes" xml:space="preserve">
          <source>However, doing this will also be very slow and leak memory, so you should usually avoid this and instead keep reading. The next section discusses how to use indirect calls to efficiently achieve a similar effect.</source>
          <target state="translated">しかし、これを行うと非常に遅くなり、メモリをリークすることになるので、通常はこれを避け、代わりに読み続けるべきです。次のセクションでは、間接的な呼び出しを使って効率的に同様の効果を得る方法について説明します。</target>
        </trans-unit>
        <trans-unit id="1f4c1ec1ac04c3b7530d92971ca6fe0a67c59d9d" translate="yes" xml:space="preserve">
          <source>However, for mutable objects the warning is printed as expected:</source>
          <target state="translated">しかし、変異可能なオブジェクトの場合は、期待通りに警告が表示されます。</target>
        </trans-unit>
        <trans-unit id="2b94a9c2374adeaf4e451f1d8f8dbbec3cf93bf0" translate="yes" xml:space="preserve">
          <source>However, future calls to &lt;code&gt;tryeval&lt;/code&gt; will continue to see the definition of &lt;code&gt;newfun&lt;/code&gt; as it was &lt;em&gt;at the previous statement at the REPL&lt;/em&gt;, and thus before that call to &lt;code&gt;tryeval&lt;/code&gt;.</source>
          <target state="translated">ただし、今後の &lt;code&gt;tryeval&lt;/code&gt; の呼び出し&lt;em&gt;では、REPLの前のステートメント&lt;/em&gt;と &lt;code&gt;tryeval&lt;/code&gt; ように、つまり、tryevalの呼び出しの前に &lt;code&gt;newfun&lt;/code&gt; の定義が引き続き表示さ&lt;em&gt;れ&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="d2749cf17a2b4294f113fe7c480d466ff1081a71" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;x&lt;/code&gt; is bound to an object of type &lt;code&gt;Array&lt;/code&gt; (or any other &lt;em&gt;mutable&lt;/em&gt; type). From within the function, you cannot &quot;unbind&quot; &lt;code&gt;x&lt;/code&gt; from this Array, but you &lt;em&gt;can&lt;/em&gt; change its content. For example:</source>
          <target state="translated">ただし、 &lt;code&gt;x&lt;/code&gt; が &lt;code&gt;Array&lt;/code&gt; 型（またはその他の&lt;em&gt;可変&lt;/em&gt;型）のオブジェクトにバインドされている場合。関数内から、この配列から &lt;code&gt;x&lt;/code&gt; を「バインド解除」することはできません&lt;em&gt;が&lt;/em&gt;、その内容&lt;em&gt;を&lt;/em&gt;変更する&lt;em&gt;ことはでき&lt;/em&gt;ます。例えば：</target>
        </trans-unit>
        <trans-unit id="96a28d68e1fc2327784959f0995bfa65f1bc559d" translate="yes" xml:space="preserve">
          <source>However, if needed you can specialize on any or all of these arguments. The final argument &lt;code&gt;bc&lt;/code&gt; is a lazy representation of a (potentially fused) broadcast operation, a &lt;code&gt;Broadcasted&lt;/code&gt; object. For these purposes, the most important fields of the wrapper are &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;args&lt;/code&gt;, describing the function and argument list, respectively. Note that the argument list can &amp;mdash; and often does &amp;mdash; include other nested &lt;code&gt;Broadcasted&lt;/code&gt; wrappers.</source>
          <target state="translated">ただし、必要に応じて、これらの引数の一部またはすべてに特化できます。最後の引数 &lt;code&gt;bc&lt;/code&gt; は、（潜在的に融合された）ブロードキャスト操作である &lt;code&gt;Broadcasted&lt;/code&gt; オブジェクトの遅延表現です。これらの目的のために、ラッパーの最も重要なフィールドは &lt;code&gt;f&lt;/code&gt; と &lt;code&gt;args&lt;/code&gt; であり、それぞれ関数と引数リストを記述します。引数リストには、他のネストされた &lt;code&gt;Broadcasted&lt;/code&gt; ラッパーを含めることができます（多くの場合、含めます）。</target>
        </trans-unit>
        <trans-unit id="a1a03264a4e905ebd619a9b03ec0d4363bf201f9" translate="yes" xml:space="preserve">
          <source>However, if you try to redefine a built-in constant or function already in use, Julia will give you an error:</source>
          <target state="translated">しかし、組み込みの定数や既に使用されている関数を再定義しようとすると、Juliaはエラーを出します。</target>
        </trans-unit>
        <trans-unit id="b612aa5b83e1e5e4f183ec87a4a8051d812c4982" translate="yes" xml:space="preserve">
          <source>However, it is not hard to construct cases where this will fail:</source>
          <target state="translated">しかし、これで失敗するケースを構築することは難しくありません。</target>
        </trans-unit>
        <trans-unit id="f588e867dce1639bbbc3e181485bd13a34f96de5" translate="yes" xml:space="preserve">
          <source>However, it is occasionally useful to reuse an existing local variable as the iteration variable. This can be done conveniently by adding the keyword &lt;code&gt;outer&lt;/code&gt;:</source>
          <target state="translated">ただし、既存のローカル変数を反復変数として再利用すると便利な場合があります。これは、キーワード &lt;code&gt;outer&lt;/code&gt; を追加することで簡単に実行できます。</target>
        </trans-unit>
        <trans-unit id="b3fc16da92345edab485c9b8587412c5e7cbbb69" translate="yes" xml:space="preserve">
          <source>However, it's still possible, for instance, to send a &lt;code&gt;MyType&lt;/code&gt; to a process which has loaded &lt;code&gt;DummyModule&lt;/code&gt; even if it's not in scope:</source>
          <target state="translated">ただし、たとえば、スコープ内にない場合でも、 &lt;code&gt;DummyModule&lt;/code&gt; をロードしたプロセスに &lt;code&gt;MyType&lt;/code&gt; を送信することは可能です。</target>
        </trans-unit>
        <trans-unit id="0206b7f024c599046b1522c22d104a0f2b4ea5b8" translate="yes" xml:space="preserve">
          <source>However, making use of such techniques can be surprisingly subtle. For example, it would be of no help if you called &lt;code&gt;array3&lt;/code&gt; from a function like this:</source>
          <target state="translated">しかし、そのような技術を利用することは驚くほど微妙な場合があります。たとえば、次のような関数から &lt;code&gt;array3&lt;/code&gt; を呼び出しても役に立たないでしょう。</target>
        </trans-unit>
        <trans-unit id="1ad09b70c7675ac7974cd81421e0b196fa34837e" translate="yes" xml:space="preserve">
          <source>However, other similar calls still don't work:</source>
          <target state="translated">しかし、他の似たような通話はまだうまくいきません。</target>
        </trans-unit>
        <trans-unit id="d6c01a830ee4c6c4b08c6d0fd04973c57ba502a5" translate="yes" xml:space="preserve">
          <source>However, since the automatic vectorization cannot be relied upon, future use will mostly be via libraries that use &lt;code&gt;llvmcall&lt;/code&gt;.</source>
          <target state="translated">ただし、自動ベクトル化は信頼できないため、今後の使用は主に &lt;code&gt;llvmcall&lt;/code&gt; を使用するライブラリを介して行われます。</target>
        </trans-unit>
        <trans-unit id="0a9c9e751e43cb6eaac4e5372d46543dc59ec370" translate="yes" xml:space="preserve">
          <source>However, since this is slightly cumbersome, there are several convenience methods provided. For example, we could have written the above as:</source>
          <target state="translated">しかし、これは少し面倒なので、いくつかの便利な方法が用意されています。例えば、上記のように書くことができました。</target>
        </trans-unit>
        <trans-unit id="4963644e11f9a07fc917ac8319ecfbd548bbe63b" translate="yes" xml:space="preserve">
          <source>However, some modules contain submodules, which means you sometimes need to access a non-top-level module. There are two ways to do this. The first is to use an absolute path, for example &lt;code&gt;using Base.Sort&lt;/code&gt;. The second is to use a relative path, which makes it easier to import submodules of the current module or any of its enclosing modules:</source>
          <target state="translated">ただし、一部のモジュールにはサブモジュールが含まれているため、最上位以外のモジュールにアクセスする必要がある場合があります。これを行うには2つの方法があります。1つ目は、 &lt;code&gt;using Base.Sort&lt;/code&gt; などの絶対パスを使用することです。2つ目は、相対パスを使用することです。これにより、現在のモジュールのサブモジュールまたはその囲んでいるモジュールのインポートが容易になります。</target>
        </trans-unit>
        <trans-unit id="5f8e9c86265d52a44715f5ea3dcba697bb6fdada" translate="yes" xml:space="preserve">
          <source>However, sometimes it makes sense to keep the uppercase first letter, for instance if an argument to a function is a capital letter:</source>
          <target state="translated">しかし、関数の引数が大文字の場合など、大文字の最初の文字を維持することが理にかなっている場合もあります。</target>
        </trans-unit>
        <trans-unit id="788054e244adc6c2716171e1c63990c4810a9000" translate="yes" xml:space="preserve">
          <source>However, sometimes it makes sense to keep the uppercase first letter, for instance if an argument to a function is a capital letter: &lt;code&gt;size(A,1) == size(B,2) || throw(DimensionMismatch(&quot;A has first dimension...&quot;))&lt;/code&gt;.</source>
          <target state="translated">ただし、関数の引数が大文字の場合など、最初の文字を大文字にしておくと意味がある場合があります。size &lt;code&gt;size(A,1) == size(B,2) || throw(DimensionMismatch(&quot;A has first dimension...&quot;))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="734c2f5135f1e869aae040511570811afbc769c7" translate="yes" xml:space="preserve">
          <source>However, the outer &lt;code&gt;quote&lt;/code&gt; expression is able to interpolate values inside the &lt;code&gt;$&lt;/code&gt; in the inner quote. This is done with multiple &lt;code&gt;$&lt;/code&gt;s:</source>
          <target state="translated">ただし、外側の &lt;code&gt;quote&lt;/code&gt; 式は、内側の引用の &lt;code&gt;$&lt;/code&gt; 内の値を補間できます。これは複数の &lt;code&gt;$&lt;/code&gt; で行われます：</target>
        </trans-unit>
        <trans-unit id="a78965b80768b2188b4d959fddb093f72b6aa627" translate="yes" xml:space="preserve">
          <source>However, there are cases where you may need to declare different versions of the outer function for different element types or types of the &lt;code&gt;AbstractVector&lt;/code&gt; of the field &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;MySimpleContainer&lt;/code&gt;. You could do it like this:</source>
          <target state="translated">しかし、あなたは別の要素タイプまたはタイプのために外側の関数の異なるバージョンを宣言する必要があるかもしれない場合がある &lt;code&gt;AbstractVector&lt;/code&gt; フィールドの &lt;code&gt;a&lt;/code&gt; で &lt;code&gt;MySimpleContainer&lt;/code&gt; は。あなたはこのようにすることができます：</target>
        </trans-unit>
        <trans-unit id="3975391f531616484a0e31ee77d8e0e00f61fa9e" translate="yes" xml:space="preserve">
          <source>However, there are three key differences:</source>
          <target state="translated">しかし、主に3つの違いがあります。</target>
        </trans-unit>
        <trans-unit id="f5c45c8616fbe8c99fd70a67651ffd25fb8f16b8" translate="yes" xml:space="preserve">
          <source>However, this is &lt;em&gt;not&lt;/em&gt; recommended. Instead, use the more efficient &lt;code&gt;complex&lt;/code&gt; function to construct a complex value directly from its real and imaginary parts:</source>
          <target state="translated">ただし、これはお勧め&lt;em&gt;できません&lt;/em&gt;。代わりに、より効率的 &lt;code&gt;complex&lt;/code&gt; 関数を使用して、実数部と虚数部から複素数を直接作成します。</target>
        </trans-unit>
        <trans-unit id="a2261e024bded1ce38fa0b00996da87c5f69ba9d" translate="yes" xml:space="preserve">
          <source>However, type promotion between the primitive types above and &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;../../base/numbers/index#Base.MPFR.BigFloat&quot;&gt;&lt;code&gt;BigFloat&lt;/code&gt;&lt;/a&gt; is not automatic and must be explicitly stated.</source>
          <target state="translated">しかし、プリミティブ型以上との間のタイプのプロモーション&lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;../../base/numbers/index#Base.MPFR.BigFloat&quot;&gt; &lt;code&gt;BigFloat&lt;/code&gt; &lt;/a&gt;自動ではなく、明示的に指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="a17c41ad2e8a1887210e57ce0ca80b0a2e7e175c" translate="yes" xml:space="preserve">
          <source>However, we don't do this for a good reason: wrapping the &lt;code&gt;expr&lt;/code&gt; in a new scope block (the anonymous function) also slightly changes the meaning of the expression (the scope of any variables in it), while we want &lt;code&gt;@time&lt;/code&gt; to be usable with minimum impact on the wrapped code.</source>
          <target state="translated">しかし、我々は正当な理由のためにこれをしない：ラップ &lt;code&gt;expr&lt;/code&gt; 私たちが望む一方で、新たなスコープブロック（匿名関数）にも多少、表現（その中の任意の変数のスコープ）の意味を変更 &lt;code&gt;@time&lt;/code&gt; へラップされたコードへの影響を最小限に抑えて使用できます。</target>
        </trans-unit>
        <trans-unit id="0b0f70feaa3a28d45e6f3a13fc1f48acf2f37d7c" translate="yes" xml:space="preserve">
          <source>However, while the type layout must be known statically to compute the intended C ABI, the static parameters of the function are considered to be part of this static environment. The static parameters of the function may be used as type parameters in the call signature, as long as they don't affect the layout of the type. For example, &lt;code&gt;f(x::T) where {T} = ccall(:valid, Ptr{T}, (Ptr{T},), x)&lt;/code&gt; is valid, since &lt;code&gt;Ptr&lt;/code&gt; is always a word-size primitive type. But, &lt;code&gt;g(x::T) where {T} = ccall(:notvalid, T, (T,), x)&lt;/code&gt; is not valid, since the type layout of &lt;code&gt;T&lt;/code&gt; is not known statically.</source>
          <target state="translated">ただし、目的のC ABIを計算するには、型のレイアウトが静的に認識されている必要がありますが、関数の静的パラメーターはこの静的環境の一部と見なされます。関数の静的パラメーターは、型のレイアウトに影響を与えない限り、呼び出し署名の型パラメーターとして使用できます。たとえば、 &lt;code&gt;Ptr&lt;/code&gt; は常にワードサイズのプリミティブ型であるため &lt;code&gt;f(x::T) where {T} = ccall(:valid, Ptr{T}, (Ptr{T},), x)&lt;/code&gt; であるf（x :: T）は有効です。しかし、 &lt;code&gt;g(x::T) where {T} = ccall(:notvalid, T, (T,), x)&lt;/code&gt; の種類レイアウトので、有効でない &lt;code&gt;T&lt;/code&gt; が静的に知られていません。</target>
        </trans-unit>
        <trans-unit id="08e25fd1d8072dc28d6c1dfa6f07c1fbd4ffc288" translate="yes" xml:space="preserve">
          <source>However, you can get access to &lt;code&gt;PowerShell&lt;/code&gt; like this:</source>
          <target state="translated">ただし、次のように &lt;code&gt;PowerShell&lt;/code&gt; にアクセスできます。</target>
        </trans-unit>
        <trans-unit id="50d668f1d842d230950802dd8f5eb4d3254c4568" translate="yes" xml:space="preserve">
          <source>Hundred Points Symbol</source>
          <target state="translated">百点シンボル</target>
        </trans-unit>
        <trans-unit id="fdd59db74c581af271b7941aa03e44ed5fe0b191" translate="yes" xml:space="preserve">
          <source>Hushed Face</source>
          <target state="translated">ハッシュドフェイス</target>
        </trans-unit>
        <trans-unit id="37906f8372f8c377be7b1e328309d3c4f609ea59" translate="yes" xml:space="preserve">
          <source>Hygiene</source>
          <target state="translated">Hygiene</target>
        </trans-unit>
        <trans-unit id="9dfda2b4e8d2ebd709351cb5956b33e0e4ffe363" translate="yes" xml:space="preserve">
          <source>Hyndman, R.J and Fan, Y. (1996) &quot;Sample Quantiles in Statistical Packages&quot;, &lt;em&gt;The American Statistician&lt;/em&gt;, Vol. 50, No. 4, pp. 361-365</source>
          <target state="translated">Hyndman、RJ and Fan、Y.（1996） &quot;Sample Quantles in Statistical Packages&quot;、&lt;em&gt;The American Statistician&lt;/em&gt;、Vol。50、No. 4、pp。361-365</target>
        </trans-unit>
        <trans-unit id="cde96ad42b76d0bdd741afbb558f7a3b372bce7e" translate="yes" xml:space="preserve">
          <source>I (interval)</source>
          <target state="translated">i</target>
        </trans-unit>
        <trans-unit id="1f1b2f73366cab7e556f4c5764548bfeee9e55d4" translate="yes" xml:space="preserve">
          <source>I passed an argument &lt;code&gt;x&lt;/code&gt; to a function, modified it inside that function, but on the outside, the variable &lt;code&gt;x&lt;/code&gt; is still unchanged. Why?</source>
          <target state="translated">引数 &lt;code&gt;x&lt;/code&gt; を関数に渡し、関数内で変更しましたが、外側では、変数 &lt;code&gt;x&lt;/code&gt; はまだ変更されていません。どうして？</target>
        </trans-unit>
        <trans-unit id="f6d15c9cfe8c2c69adbb304be5e27663dff93f96" translate="yes" xml:space="preserve">
          <source>I.e. the value returned by &lt;code&gt;codeunit(s, i)&lt;/code&gt; is of the type returned by &lt;code&gt;codeunit(s)&lt;/code&gt;.</source>
          <target state="translated">すなわちによって返される値 &lt;code&gt;codeunit(s, i)&lt;/code&gt; によって返されたタイプのものである &lt;code&gt;codeunit(s)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7cf18e3da9119216f8e328e30538193a84b6a06e" translate="yes" xml:space="preserve">
          <source>I/O and Network</source>
          <target state="translated">I/Oとネットワーク</target>
        </trans-unit>
        <trans-unit id="f202b270f0bf2c3423308846f107faa93c51a606" translate="yes" xml:space="preserve">
          <source>ID of the device that contains the file</source>
          <target state="translated">ファイルを格納しているデバイスのID</target>
        </trans-unit>
        <trans-unit id="f9c4d94c8313e5f3e388b78d066d32450a104438" translate="yes" xml:space="preserve">
          <source>IO Output Contextual Properties</source>
          <target state="translated">IO出力コンテキストプロパティ</target>
        </trans-unit>
        <trans-unit id="197f5eacc88f8f1df449bfc2c0077d2d00ba82c7" translate="yes" xml:space="preserve">
          <source>IO redirection can be accomplished by passing keyword arguments &lt;code&gt;stdin&lt;/code&gt;, &lt;code&gt;stdout&lt;/code&gt;, and &lt;code&gt;stderr&lt;/code&gt; to the &lt;code&gt;pipeline&lt;/code&gt; function:</source>
          <target state="translated">IOリダイレクトは、キーワード引数 &lt;code&gt;stdin&lt;/code&gt; 、 &lt;code&gt;stdout&lt;/code&gt; 、および &lt;code&gt;stderr&lt;/code&gt; を &lt;code&gt;pipeline&lt;/code&gt; 関数に渡すことで実現できます。</target>
        </trans-unit>
        <trans-unit id="01d2fc4baf23050afed6538bf5b3afda200aec20" translate="yes" xml:space="preserve">
          <source>IOBuffer</source>
          <target state="translated">IOBuffer</target>
        </trans-unit>
        <trans-unit id="1e240958856813e40093848d027d47dc30e4009a" translate="yes" xml:space="preserve">
          <source>IOContext</source>
          <target state="translated">IOContext</target>
        </trans-unit>
        <trans-unit id="29093ff8b21b1b330d3e6699a2ad82a180dd947e" translate="yes" xml:space="preserve">
          <source>IOContext()</source>
          <target state="translated">IOContext()</target>
        </trans-unit>
        <trans-unit id="3afa239559b1455a86cd4aafab53cb6dd69792c0" translate="yes" xml:space="preserve">
          <source>IOStream</source>
          <target state="translated">IOStream</target>
        </trans-unit>
        <trans-unit id="8d31d2211f88e51d4dac04058ee63fd1f5837600" translate="yes" xml:space="preserve">
          <source>Ice Cream</source>
          <target state="translated">アイスクリーム</target>
        </trans-unit>
        <trans-unit id="2b3a1ae210dbbbf1609a9fd75685f6380218b075" translate="yes" xml:space="preserve">
          <source>IdDict</source>
          <target state="translated">IdDict</target>
        </trans-unit>
        <trans-unit id="898cecd14809e1e6d2d6a1ad03f40fe8f8898ff9" translate="yes" xml:space="preserve">
          <source>Identical To</source>
          <target state="translated">同一の</target>
        </trans-unit>
        <trans-unit id="c539ce4823e892243cf1d72e5cda29852ab1bb48" translate="yes" xml:space="preserve">
          <source>Identical To And Slanted Parallel</source>
          <target state="translated">同一のものと斜めの平行</target>
        </trans-unit>
        <trans-unit id="44763ae8a5457dbe6219995560f8ceac0b654107" translate="yes" xml:space="preserve">
          <source>Identical With Dot Above</source>
          <target state="translated">上のドットと同一</target>
        </trans-unit>
        <trans-unit id="49f0f00de3919e6aa513f490a486fcbae4d4df50" translate="yes" xml:space="preserve">
          <source>If $n$ is negative, then it is defined in terms of the identity</source>
          <target state="translated">n$ が負の場合、それは同一人物である</target>
        </trans-unit>
        <trans-unit id="4ed2889e692f7a726f27cb34a6abbc329da52fe8" translate="yes" xml:space="preserve">
          <source>If $n$ is non-negative, then it is the number of ways to choose &lt;code&gt;k&lt;/code&gt; out of &lt;code&gt;n&lt;/code&gt; items:</source>
          <target state="translated">$ n $が負でない場合は、 &lt;code&gt;n&lt;/code&gt; 個のアイテムから &lt;code&gt;k&lt;/code&gt; 個を選択する方法の数です。</target>
        </trans-unit>
        <trans-unit id="21a045b4d60526617fd3c07b9d46739e69a41cdd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; has no negative real eigenvalue, compute the principal matrix logarithm of &lt;code&gt;A&lt;/code&gt;, i.e. the unique matrix $X$ such that $e^X = A$ and $-\pi &amp;lt; Im(\lambda) &amp;lt; \pi$ for all the eigenvalues $\lambda$ of $X$. If &lt;code&gt;A&lt;/code&gt; has nonpositive eigenvalues, a nonprincipal matrix function is returned whenever possible.</source>
          <target state="translated">場合 &lt;code&gt;A&lt;/code&gt; は何の負の実固有値を持っていない、の主要な行列対数計算 &lt;code&gt;A&lt;/code&gt; を、すなわちユニークな行列$ X $ように$電子^ X = A $と$ - \パイ&amp;lt;イム（\ラムダ）すべてについて&amp;lt;\パイ$ $ X $の固有値$ \ lambda $。 &lt;code&gt;A&lt;/code&gt; に非正の固有値がある場合、可能な限り非主行列関数が返されます。</target>
        </trans-unit>
        <trans-unit id="7259d98627a04b894a1123257649b9b0e506f9f0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; has no negative real eigenvalues, compute the principal matrix square root of &lt;code&gt;A&lt;/code&gt;, that is the unique matrix $X$ with eigenvalues having positive real part such that $X^2 = A$. Otherwise, a nonprincipal square root is returned.</source>
          <target state="translated">場合 &lt;code&gt;A&lt;/code&gt; は負の実固有値を有していない、の主行列平方根計算 &lt;code&gt;A&lt;/code&gt; の固有値は、$ X ^ 2 = A $その正の実数部分を有するユニークな行列$ X $です。それ以外の場合は、非主平方根が返されます。</target>
        </trans-unit>
        <trans-unit id="390ecc8380adb6dd4fff37f515d8dc55040ad6a7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is &lt;a href=&quot;#LinearAlgebra.Hermitian&quot;&gt;&lt;code&gt;Hermitian&lt;/code&gt;&lt;/a&gt; or real-&lt;a href=&quot;#LinearAlgebra.Symmetric&quot;&gt;&lt;code&gt;Symmetric&lt;/code&gt;&lt;/a&gt;, then the Hessenberg decomposition produces a real-symmetric tridiagonal matrix and &lt;code&gt;F.H&lt;/code&gt; is of type &lt;a href=&quot;#LinearAlgebra.SymTridiagonal&quot;&gt;&lt;code&gt;SymTridiagonal&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">場合 &lt;code&gt;A&lt;/code&gt; がある&lt;a href=&quot;#LinearAlgebra.Hermitian&quot;&gt; &lt;code&gt;Hermitian&lt;/code&gt; &lt;/a&gt;または実&lt;a href=&quot;#LinearAlgebra.Symmetric&quot;&gt; &lt;code&gt;Symmetric&lt;/code&gt; &lt;/a&gt;、次いでヘッセン分解は実対称3重対角行列を生成し、 &lt;code&gt;F.H&lt;/code&gt; 型である&lt;a href=&quot;#LinearAlgebra.SymTridiagonal&quot;&gt; &lt;code&gt;SymTridiagonal&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5e08a2a0f6796f08007ab9fdda2c45c43480624f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is a &lt;code&gt;StridedArray&lt;/code&gt;, then its elements are stored in memory with offsets, which may vary between dimensions but are constant within a dimension. For example, &lt;code&gt;A&lt;/code&gt; could have stride 2 in dimension 1, and stride 3 in dimension 2. Incrementing &lt;code&gt;A&lt;/code&gt; along dimension &lt;code&gt;d&lt;/code&gt; jumps in memory by [&lt;code&gt;strides(A, d)&lt;/code&gt;] slots. Strided arrays are particularly important and useful because they can sometimes be passed directly as pointers to foreign language libraries like BLAS.</source>
          <target state="translated">場合 &lt;code&gt;A&lt;/code&gt; がある &lt;code&gt;StridedArray&lt;/code&gt; 、その要素は、大きさの間で変化しなく寸法内で一定であることができるオフセットとメモリに格納されています。たとえば、 &lt;code&gt;A&lt;/code&gt; は次元1にストライド2、次元2にストライド3を持つことができます。次元 &lt;code&gt;d&lt;/code&gt; に沿って &lt;code&gt;A&lt;/code&gt; をインクリメントすると、[ &lt;code&gt;strides(A, d)&lt;/code&gt; ]スロットによってメモリ内でジャンプします。ストライド配列は、BLASなどの外国語ライブラリへのポインタとして直接渡されることがあるため、特に重要で便利です。</target>
        </trans-unit>
        <trans-unit id="d9d3df34d4b0d8669771d98ccd80e4361eb22b17" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is real-symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the square root. For such matrices, eigenvalues &amp;lambda; that appear to be slightly negative due to roundoff errors are treated as if they were zero More precisely, matrices with all eigenvalues &lt;code&gt;&amp;ge; -rtol*(max |&amp;lambda;|)&lt;/code&gt; are treated as semidefinite (yielding a Hermitian square root), with negative eigenvalues taken to be zero. &lt;code&gt;rtol&lt;/code&gt; is a keyword argument to &lt;code&gt;sqrt&lt;/code&gt; (in the Hermitian/real-symmetric case only) that defaults to machine precision scaled by &lt;code&gt;size(A,1)&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;A&lt;/code&gt; は実対称またはエルミートであり、その固有値分解（&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt;）平方根を計算するために使用されます。このような行列の場合、丸め誤差のためにわずかに負に見える固有値&amp;lambda;はゼロであるかのように扱われます。より正確には、すべての固有値 &lt;code&gt;&amp;ge; -rtol*(max |&amp;lambda;|)&lt;/code&gt; を持つ行列は半定値として扱われます（エルミート平方根を生成します）。 ）、負の固有値はゼロと見なされます。 &lt;code&gt;rtol&lt;/code&gt; は、 &lt;code&gt;sqrt&lt;/code&gt; のキーワード引数（エルミート/実対称の場合のみ）であり、デフォルトでは &lt;code&gt;size(A,1)&lt;/code&gt; スケーリングされたマシン精度になります。</target>
        </trans-unit>
        <trans-unit id="19b01775b8b82ce68d3f6a6f522f474a638dda03" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the cosine. Otherwise, the cosine is determined by calling &lt;code&gt;exp&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; が対称またはエルミートの場合、その&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt;分解（eigen ）を使用して余弦が計算されます。それ以外の場合、余弦は &lt;code&gt;exp&lt;/code&gt; を呼び出すことによって決定されます。</target>
        </trans-unit>
        <trans-unit id="acf6a44af56176e5053aa08ad7d4eea1a7727bea" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the inverse cosine. Otherwise, the inverse cosine is determined by using &lt;code&gt;log&lt;/code&gt; and &lt;code&gt;sqrt&lt;/code&gt;. For the theory and logarithmic formulas used to compute this function, see &lt;a href=&quot;#footnote-AH16_1&quot;&gt;[AH16_1]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; が対称またはエルミートの場合、その&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt;分解（eigen ）を使用して逆余弦が計算されます。それ以外の場合、逆余弦は &lt;code&gt;log&lt;/code&gt; および &lt;code&gt;sqrt&lt;/code&gt; を使用して決定されます。この関数を計算するために使用される理論と対数公式については、&lt;a href=&quot;#footnote-AH16_1&quot;&gt;[AH16_1]を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="656a2e02dd9901a5d5d038f1484c6e9a0c0da179" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the inverse cosine. Otherwise, the inverse cosine is determined by using &lt;code&gt;log&lt;/code&gt; and &lt;code&gt;sqrt&lt;/code&gt;. For the theory and logarithmic formulas used to compute this function, see &lt;sup&gt;&lt;a href=&quot;#footnote-AH16_1&quot; id=&quot;citeref-AH16_1&quot;&gt;[AH16_1]&lt;/a&gt;&lt;/sup&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; が対称またはエルミートの場合、その&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt;分解（eigen ）を使用して逆余弦が計算されます。それ以外の場合、逆余弦は &lt;code&gt;log&lt;/code&gt; と &lt;code&gt;sqrt&lt;/code&gt; を使用して決定されます。この関数の計算に使用される理論と対数の公式については、&lt;sup&gt;&lt;a href=&quot;#footnote-AH16_1&quot; id=&quot;citeref-AH16_1&quot;&gt;[AH16_1]を&lt;/a&gt;&lt;/sup&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="bbfce79aa807e6b2cb49ddfffb2847f191045922" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the inverse sine. Otherwise, the inverse sine is determined by using &lt;code&gt;log&lt;/code&gt; and &lt;code&gt;sqrt&lt;/code&gt;. For the theory and logarithmic formulas used to compute this function, see &lt;a href=&quot;#footnote-AH16_2&quot;&gt;[AH16_2]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; が対称またはエルミートの場合、その&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt;分解（eigen ）を使用して逆正弦が計算されます。それ以外の場合、逆正弦は &lt;code&gt;log&lt;/code&gt; と &lt;code&gt;sqrt&lt;/code&gt; を使用して決定されます。この関数の計算に使用される理論と対数公式については、&lt;a href=&quot;#footnote-AH16_2&quot;&gt;[AH16_2]を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="c57d54383c6569d422099f76dc516cae4a4a6b7c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the inverse sine. Otherwise, the inverse sine is determined by using &lt;code&gt;log&lt;/code&gt; and &lt;code&gt;sqrt&lt;/code&gt;. For the theory and logarithmic formulas used to compute this function, see &lt;sup&gt;&lt;a href=&quot;#footnote-AH16_2&quot; id=&quot;citeref-AH16_2&quot;&gt;[AH16_2]&lt;/a&gt;&lt;/sup&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; が対称またはエルミートの場合、その&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt;分解（eigen ）を使用して逆正弦が計算されます。それ以外の場合、逆正弦は &lt;code&gt;log&lt;/code&gt; と &lt;code&gt;sqrt&lt;/code&gt; を使用して決定されます。この関数の計算に使用される理論と対数の公式については、&lt;sup&gt;&lt;a href=&quot;#footnote-AH16_2&quot; id=&quot;citeref-AH16_2&quot;&gt;[AH16_2]を&lt;/a&gt;&lt;/sup&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="2646487106f321c98004368d4fc3670f47b0a86e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the inverse tangent. Otherwise, the inverse tangent is determined by using &lt;code&gt;log&lt;/code&gt;. For the theory and logarithmic formulas used to compute this function, see &lt;a href=&quot;#footnote-AH16_3&quot;&gt;[AH16_3]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; が対称またはエルミートの場合、その&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt;分解（eigen ）を使用して逆正接が計算されます。それ以外の場合、逆正接は &lt;code&gt;log&lt;/code&gt; を使用して決定されます。この関数の計算に使用される理論と対数公式については、&lt;a href=&quot;#footnote-AH16_3&quot;&gt;[AH16_3]を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="88a24bd15ac5a68c08c00b78778d22ccaac3c21f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the inverse tangent. Otherwise, the inverse tangent is determined by using &lt;code&gt;log&lt;/code&gt;. For the theory and logarithmic formulas used to compute this function, see &lt;sup&gt;&lt;a href=&quot;#footnote-AH16_3&quot; id=&quot;citeref-AH16_3&quot;&gt;[AH16_3]&lt;/a&gt;&lt;/sup&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; が対称またはエルミートの場合、その&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt;分解（eigen ）を使用して逆正接が計算されます。それ以外の場合、逆正接は &lt;code&gt;log&lt;/code&gt; を使用して決定されます。この関数の計算に使用される理論と対数の公式については、&lt;sup&gt;&lt;a href=&quot;#footnote-AH16_3&quot; id=&quot;citeref-AH16_3&quot;&gt;[AH16_3]を&lt;/a&gt;&lt;/sup&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="317ce8e704df5d75a6762d7ee94cb8590a0eeb84" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the sine. Otherwise, the sine is determined by calling &lt;code&gt;exp&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; が対称またはエルミートの場合、その&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt;分解（eigen ）を使用して正弦を計算します。それ以外の場合、正弦は &lt;code&gt;exp&lt;/code&gt; を呼び出すことによって決定されます。</target>
        </trans-unit>
        <trans-unit id="8f03ca25824d588274952404db5eb47ba9feeba8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the square root. Otherwise, the square root is determined by means of the Bj&amp;ouml;rck-Hammarling method &lt;a href=&quot;#footnote-BH83&quot;&gt;[BH83]&lt;/a&gt;, which computes the complex Schur form (&lt;a href=&quot;#LinearAlgebra.schur&quot;&gt;&lt;code&gt;schur&lt;/code&gt;&lt;/a&gt;) and then the complex square root of the triangular factor.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; が対称またはエルミートの場合、その&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt;分解（eigen ）を使用して平方根が計算されます。それ以外の場合、平方根は、Bj&amp;ouml;rck-Hammarling法&lt;a href=&quot;#footnote-BH83&quot;&gt;[BH83]を&lt;/a&gt;使用して決定されます。これは、複素Schur形式（&lt;a href=&quot;#LinearAlgebra.schur&quot;&gt; &lt;code&gt;schur&lt;/code&gt; &lt;/a&gt;）を計算してから、三角因子の複素平方根を計算します。</target>
        </trans-unit>
        <trans-unit id="da6d9fe794edc15bdf1db668291afd8d8cb893d7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the tangent. Otherwise, the tangent is determined by calling &lt;code&gt;exp&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; が対称またはエルミートの場合、その&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt;分解（eigen ）を使用してタンジェントが計算されます。それ以外の場合、接線は &lt;code&gt;exp&lt;/code&gt; を呼び出すことによって決定されます。</target>
        </trans-unit>
        <trans-unit id="e82ebcef54c304de01d1461f11b56325e46b2234" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used, if &lt;code&gt;A&lt;/code&gt; is triangular an improved version of the inverse scaling and squaring method is employed (see &lt;a href=&quot;#footnote-AH12&quot;&gt;[AH12]&lt;/a&gt; and &lt;a href=&quot;#footnote-AHR13&quot;&gt;[AHR13]&lt;/a&gt;). For general matrices, the complex Schur form (&lt;a href=&quot;#LinearAlgebra.schur&quot;&gt;&lt;code&gt;schur&lt;/code&gt;&lt;/a&gt;) is computed and the triangular algorithm is used on the triangular factor.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; が対称またはエルミートの場合、その&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt;分解（eigen ）が使用されます &lt;code&gt;A&lt;/code&gt; が三角形の場合、逆スケーリングと二乗法の改良版が採用されます（&lt;a href=&quot;#footnote-AH12&quot;&gt;[AH12]&lt;/a&gt;と&lt;a href=&quot;#footnote-AHR13&quot;&gt;[AHR13]を&lt;/a&gt;参照）。一般的な行列の場合、複素Schur形式（&lt;a href=&quot;#LinearAlgebra.schur&quot;&gt; &lt;code&gt;schur&lt;/code&gt; &lt;/a&gt;）が計算され、三角係数に三角アルゴリズムが使用されます。</target>
        </trans-unit>
        <trans-unit id="7cd81f11c1d70424b51ccffe350316108e01c22e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used, if &lt;code&gt;A&lt;/code&gt; is triangular an improved version of the inverse scaling and squaring method is employed (see &lt;sup&gt;&lt;a href=&quot;#footnote-AH12&quot; id=&quot;citeref-AH12&quot;&gt;[AH12]&lt;/a&gt;&lt;/sup&gt; and &lt;sup&gt;&lt;a href=&quot;#footnote-AHR13&quot; id=&quot;citeref-AHR13&quot;&gt;[AHR13]&lt;/a&gt;&lt;/sup&gt;). For general matrices, the complex Schur form (&lt;a href=&quot;#LinearAlgebra.schur&quot;&gt;&lt;code&gt;schur&lt;/code&gt;&lt;/a&gt;) is computed and the triangular algorithm is used on the triangular factor.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; が対称またはエルミートの場合、その&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt;分解（eigen ）が使用され、 &lt;code&gt;A&lt;/code&gt; が三角形の場合、逆スケーリングおよび二乗法の改良版が使用されます（&lt;sup&gt;&lt;a href=&quot;#footnote-AH12&quot; id=&quot;citeref-AH12&quot;&gt;[AH12]&lt;/a&gt;&lt;/sup&gt;および&lt;sup&gt;&lt;a href=&quot;#footnote-AHR13&quot; id=&quot;citeref-AHR13&quot;&gt;[AHR13]を&lt;/a&gt;&lt;/sup&gt;参照）。一般的な行列の場合、複素シュール形式（&lt;a href=&quot;#LinearAlgebra.schur&quot;&gt; &lt;code&gt;schur&lt;/code&gt; &lt;/a&gt;）が計算され、三角アルゴリズムが三角因子に使用されます。</target>
        </trans-unit>
        <trans-unit id="31effe06eb8010b919cfa614d0573384a4c26bdc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;DataType&lt;/code&gt;&lt;code&gt;T&lt;/code&gt; does not have a specific size, an error is thrown.</source>
          <target state="translated">&lt;code&gt;DataType&lt;/code&gt; &lt;code&gt;T&lt;/code&gt; に特定のサイズがない場合、エラーがスローされます。</target>
        </trans-unit>
        <trans-unit id="65a78265c4f32be6b8f80e6ff2b5005fabff1e58" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;F::Eigen&lt;/code&gt; is the factorization object, the eigenvalues can be obtained via &lt;code&gt;F.values&lt;/code&gt; and the eigenvectors as the columns of the matrix &lt;code&gt;F.vectors&lt;/code&gt;. (The &lt;code&gt;k&lt;/code&gt;th eigenvector can be obtained from the slice &lt;code&gt;F.vectors[:, k]&lt;/code&gt;.)</source>
          <target state="translated">場合 &lt;code&gt;F::Eigen&lt;/code&gt; 分解物である、固有値を介して得ることができる &lt;code&gt;F.values&lt;/code&gt; およびマトリックスの列として固有ベクトル &lt;code&gt;F.vectors&lt;/code&gt; 。（ &lt;code&gt;k&lt;/code&gt; 番目の固有ベクトルはスライス &lt;code&gt;F.vectors[:, k]&lt;/code&gt; から取得できます。）</target>
        </trans-unit>
        <trans-unit id="15c71436c7107833fddd5b4b5c6ae6ac2cda922a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;F::GeneralizedEigen&lt;/code&gt; is the factorization object, the eigenvalues can be obtained via &lt;code&gt;F.values&lt;/code&gt; and the eigenvectors as the columns of the matrix &lt;code&gt;F.vectors&lt;/code&gt;. (The &lt;code&gt;k&lt;/code&gt;th eigenvector can be obtained from the slice &lt;code&gt;F.vectors[:, k]&lt;/code&gt;.)</source>
          <target state="translated">場合 &lt;code&gt;F::GeneralizedEigen&lt;/code&gt; 分解物である、固有値を介して得ることができる &lt;code&gt;F.values&lt;/code&gt; およびマトリックスの列として固有ベクトル &lt;code&gt;F.vectors&lt;/code&gt; 。（ &lt;code&gt;k&lt;/code&gt; 番目の固有ベクトルはスライス &lt;code&gt;F.vectors[:, k]&lt;/code&gt; から取得できます。）</target>
        </trans-unit>
        <trans-unit id="f01e4881f70ca748aeb84922a14f5f7db186c9f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;F::GeneralizedSchur&lt;/code&gt; is the factorization object, the (quasi) triangular Schur factors can be obtained via &lt;code&gt;F.S&lt;/code&gt; and &lt;code&gt;F.T&lt;/code&gt;, the left unitary/orthogonal Schur vectors via &lt;code&gt;F.left&lt;/code&gt; or &lt;code&gt;F.Q&lt;/code&gt;, and the right unitary/orthogonal Schur vectors can be obtained with &lt;code&gt;F.right&lt;/code&gt; or &lt;code&gt;F.Z&lt;/code&gt; such that &lt;code&gt;A=F.left*F.S*F.right'&lt;/code&gt; and &lt;code&gt;B=F.left*F.T*F.right'&lt;/code&gt;. The generalized eigenvalues of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; can be obtained with &lt;code&gt;F.&amp;alpha;./F.&amp;beta;&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;F::GeneralizedSchur&lt;/code&gt; シューア因子はによって得ることができる三角分解物、（準）は &lt;code&gt;F.S&lt;/code&gt; 及び &lt;code&gt;F.T&lt;/code&gt; 左ユニタリ/直交介しシューアベクトル、 &lt;code&gt;F.left&lt;/code&gt; または &lt;code&gt;F.Q&lt;/code&gt; 、および右/直交シューアベクトルを得ることができる単一の &lt;code&gt;A=F.left*F.S*F.right'&lt;/code&gt; および &lt;code&gt;B=F.left*F.T*F.right'&lt;/code&gt; となる &lt;code&gt;F.right&lt;/code&gt; または &lt;code&gt;F.Z&lt;/code&gt; 使用します。 &lt;code&gt;A&lt;/code&gt; と &lt;code&gt;B&lt;/code&gt; の一般化された固有値は、 &lt;code&gt;F.&amp;alpha;./F.&amp;beta;&lt;/code&gt; 。/F.&amp;beta;で取得できます。</target>
        </trans-unit>
        <trans-unit id="ab48030073624eeb674b91b0955f920e2a071342" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;F::Hessenberg&lt;/code&gt; is the factorization object, the unitary matrix can be accessed with &lt;code&gt;F.Q&lt;/code&gt; and the Hessenberg matrix with &lt;code&gt;F.H&lt;/code&gt;. When &lt;code&gt;Q&lt;/code&gt; is extracted, the resulting type is the &lt;code&gt;HessenbergQ&lt;/code&gt; object, and may be converted to a regular matrix with &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert(Array, _)&lt;/code&gt;&lt;/a&gt; (or &lt;code&gt;Array(_)&lt;/code&gt; for short).</source>
          <target state="translated">場合 &lt;code&gt;F::Hessenberg&lt;/code&gt; 分解物である、ユニタリ行列を用いてアクセスすることができる &lt;code&gt;F.Q&lt;/code&gt; とを有するヘッセンベルグ行列 &lt;code&gt;F.H&lt;/code&gt; 。場合 &lt;code&gt;Q&lt;/code&gt; が抽出され、結果の型は &lt;code&gt;HessenbergQ&lt;/code&gt; のオブジェクト、およびとの定期的なマトリックスに変換することができる&lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert(Array, _)&lt;/code&gt; &lt;/a&gt;（又は &lt;code&gt;Array(_)&lt;/code&gt; 短いため）。</target>
        </trans-unit>
        <trans-unit id="7b4e73df12d848cb37ff07b3e198fc0482a106ba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;F::SVD&lt;/code&gt; is the factorization object, &lt;code&gt;U&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt;, &lt;code&gt;V&lt;/code&gt; and &lt;code&gt;Vt&lt;/code&gt; can be obtained via &lt;code&gt;F.U&lt;/code&gt;, &lt;code&gt;F.S&lt;/code&gt;, &lt;code&gt;F.V&lt;/code&gt; and &lt;code&gt;F.Vt&lt;/code&gt;, such that &lt;code&gt;A = U * Diagonal(S) * Vt&lt;/code&gt;. The singular values in &lt;code&gt;S&lt;/code&gt; are sorted in descending order.</source>
          <target state="translated">場合 &lt;code&gt;F::SVD&lt;/code&gt; 分解物である、 &lt;code&gt;U&lt;/code&gt; 、 &lt;code&gt;S&lt;/code&gt; 、 &lt;code&gt;V&lt;/code&gt; 及び &lt;code&gt;Vt&lt;/code&gt; を介して得ることができる &lt;code&gt;F.U&lt;/code&gt; 、 &lt;code&gt;F.S&lt;/code&gt; 、 &lt;code&gt;F.V&lt;/code&gt; 及び &lt;code&gt;F.Vt&lt;/code&gt; 、その結果、 &lt;code&gt;A = U * Diagonal(S) * Vt&lt;/code&gt; 。 &lt;code&gt;S&lt;/code&gt; の特異値は、降順でソートされます。</target>
        </trans-unit>
        <trans-unit id="c2f171f3d3fce677fec26e12b57715e21774c193" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;F::Schur&lt;/code&gt; is the factorization object, the (quasi) triangular Schur factor can be obtained via either &lt;code&gt;F.Schur&lt;/code&gt; or &lt;code&gt;F.T&lt;/code&gt; and the orthogonal/unitary Schur vectors via &lt;code&gt;F.vectors&lt;/code&gt; or &lt;code&gt;F.Z&lt;/code&gt; such that &lt;code&gt;A = F.vectors * F.Schur * F.vectors'&lt;/code&gt;. The eigenvalues of &lt;code&gt;A&lt;/code&gt; can be obtained with &lt;code&gt;F.values&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;F::Schur&lt;/code&gt; 分解物である、（準）三角シューア因子のいずれかを介して取得することができる &lt;code&gt;F.Schur&lt;/code&gt; または &lt;code&gt;F.T&lt;/code&gt; とを介して直交/ユニタリシューアベクトル &lt;code&gt;F.vectors&lt;/code&gt; または &lt;code&gt;F.Z&lt;/code&gt; ように &lt;code&gt;A = F.vectors * F.Schur * F.vectors'&lt;/code&gt; 。 &lt;code&gt;A&lt;/code&gt; の固有値は、 &lt;code&gt;F.values&lt;/code&gt; を使用して取得できます。</target>
        </trans-unit>
        <trans-unit id="70ac2f54db074364d37a4067713ee52ebafa3e4c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;I_1&lt;/code&gt; is changed to a two-dimensional matrix, then &lt;code&gt;X&lt;/code&gt; becomes an &lt;code&gt;n+1&lt;/code&gt;-dimensional array of shape &lt;code&gt;(size(I_1, 1), size(I_1, 2), length(I_2), ..., length(I_n))&lt;/code&gt;. The matrix adds a dimension.</source>
          <target state="translated">場合 &lt;code&gt;I_1&lt;/code&gt; が 2次元マトリクス状に変更され、その後、 &lt;code&gt;X&lt;/code&gt; は、となる &lt;code&gt;n+1&lt;/code&gt; の形状の次元アレイ &lt;code&gt;(size(I_1, 1), size(I_1, 2), length(I_2), ..., length(I_n))&lt;/code&gt; 。マトリックスは次元を追加します。</target>
        </trans-unit>
        <trans-unit id="2337775037e3e4a6505e42024632bd3eb4bbd6dc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;S::BunchKaufman&lt;/code&gt; is the factorization object, the components can be obtained via &lt;code&gt;S.D&lt;/code&gt;, &lt;code&gt;S.U&lt;/code&gt; or &lt;code&gt;S.L&lt;/code&gt; as appropriate given &lt;code&gt;S.uplo&lt;/code&gt;, and &lt;code&gt;S.p&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;S::BunchKaufman&lt;/code&gt; 分解物である、構成要素は、を介して得られる &lt;code&gt;S.D&lt;/code&gt; 、 &lt;code&gt;S.U&lt;/code&gt; または &lt;code&gt;S.L&lt;/code&gt; 所与適宜 &lt;code&gt;S.uplo&lt;/code&gt; 、および &lt;code&gt;S.p&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c942e11644bfa14cfe833c922c7cc44bc3db5861" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;S::LQ&lt;/code&gt; is the factorization object, the lower triangular component can be obtained via &lt;code&gt;S.L&lt;/code&gt;, and the orthogonal/unitary component via &lt;code&gt;S.Q&lt;/code&gt;, such that &lt;code&gt;A &amp;asymp; S.L*S.Q&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;S::LQ&lt;/code&gt; 分解物である、下三角成分を介して得ることができる &lt;code&gt;S.L&lt;/code&gt; 、ビア直交/ユニタリ成分 &lt;code&gt;S.Q&lt;/code&gt; 、その結果、 &lt;code&gt;A &amp;asymp; S.L*S.Q&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="20d018b41d67fa72dfd3dd7eab414a34042d26fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Any&lt;/code&gt;, then the memory is assumed to contain a reference to a Julia object (a &lt;code&gt;jl_value_t*&lt;/code&gt;), the result will be a reference to this object, and the object will not be copied. You must be careful in this case to ensure that the object was always visible to the garbage collector (pointers do not count, but the new reference does) to ensure the memory is not prematurely freed. Note that if the object was not originally allocated by Julia, the new object will never be finalized by Julia's garbage collector. If the &lt;code&gt;Ptr&lt;/code&gt; itself is actually a &lt;code&gt;jl_value_t*&lt;/code&gt;, it can be converted back to a Julia object reference by &lt;a href=&quot;../../base/c/index#Base.unsafe_pointer_to_objref&quot;&gt;&lt;code&gt;unsafe_pointer_to_objref(ptr)&lt;/code&gt;&lt;/a&gt;. (Julia values &lt;code&gt;v&lt;/code&gt; can be converted to &lt;code&gt;jl_value_t*&lt;/code&gt; pointers, as &lt;code&gt;Ptr{Cvoid}&lt;/code&gt;, by calling &lt;a href=&quot;../../base/c/index#Base.pointer_from_objref&quot;&gt;&lt;code&gt;pointer_from_objref(v)&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; が &lt;code&gt;Any&lt;/code&gt; の場合、メモリにはJuliaオブジェクトへの参照（ &lt;code&gt;jl_value_t*&lt;/code&gt; ）が含まれていると見なされ、結果はこのオブジェクトへの参照となり、オブジェクトはコピーされません。この場合、メモリが早期に解放されないように、オブジェクトがガベージコレクターに常に表示されるように注意する必要があります（ポインターはカウントされませんが、新しい参照はカウントされます）。オブジェクトがJuliaによって最初に割り当てられなかった場合、新しいオブジェクトはJuliaのガベージコレクターによってファイナライズされないことに注意してください。場合 &lt;code&gt;Ptr&lt;/code&gt; 自体は実際には &lt;code&gt;jl_value_t*&lt;/code&gt; 、それによってジュリアオブジェクト参照に変換バックすることができる&lt;a href=&quot;../../base/c/index#Base.unsafe_pointer_to_objref&quot;&gt; &lt;code&gt;unsafe_pointer_to_objref(ptr)&lt;/code&gt; &lt;/a&gt;。 （ジュリア値 &lt;code&gt;v&lt;/code&gt; &lt;a href=&quot;../../base/c/index#Base.pointer_from_objref&quot;&gt; &lt;code&gt;pointer_from_objref(v)&lt;/code&gt; を&lt;/a&gt;呼び出すことにより、 &lt;code&gt;Ptr{Cvoid}&lt;/code&gt; として &lt;code&gt;jl_value_t*&lt;/code&gt; ポインターに変換できます。</target>
        </trans-unit>
        <trans-unit id="51788d4fcfdfd4d39c958952b0bc0324310a6a5f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a &lt;a href=&quot;../numbers/index#Core.AbstractFloat&quot;&gt;&lt;code&gt;AbstractFloat&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../numbers/index#Base.Rational&quot;&gt;&lt;code&gt;Rational&lt;/code&gt;&lt;/a&gt; type, then it will return the closest value to &lt;code&gt;x&lt;/code&gt; representable by &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; がある&lt;a href=&quot;../numbers/index#Core.AbstractFloat&quot;&gt; &lt;code&gt;AbstractFloat&lt;/code&gt; &lt;/a&gt;又は&lt;a href=&quot;../numbers/index#Base.Rational&quot;&gt; &lt;code&gt;Rational&lt;/code&gt; &lt;/a&gt;タイプ、それは最も近い値を返す &lt;code&gt;x&lt;/code&gt; によって表現 &lt;code&gt;T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dedc994cd3fc0835ff4382a890fe92f16cb71d37" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a collection type and &lt;code&gt;x&lt;/code&gt; a collection, the result of &lt;code&gt;convert(T, x)&lt;/code&gt; may alias all or part of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; は、コレクション型であり、 &lt;code&gt;x&lt;/code&gt; は、コレクションの結果 &lt;code&gt;convert(T, x)&lt;/code&gt; 得る全てのエイリアスまたは一部 &lt;code&gt;x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ca5b35227b72b028ed45253536f1af95a0b6efba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a floating-point type, the result is the nearest representable value, which could be positive or negative infinity.</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; は、浮動小数点型であり、結果は正または負の無限大とすることができる最も近い表現可能な値です。</target>
        </trans-unit>
        <trans-unit id="4201a0a82cce066dea7c824bdf90b57c195e9972" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a numeric type, the result is an array of that type, with any non-numeric elements as &lt;code&gt;NaN&lt;/code&gt; for floating-point types, or zero. Other useful values of &lt;code&gt;T&lt;/code&gt; include &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;AbstractString&lt;/code&gt;, and &lt;code&gt;Any&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; が数値型で、結果は、のような任意の非数値要素とその型の配列であり、 &lt;code&gt;NaN&lt;/code&gt; の浮動小数点型のために、またはゼロ。 &lt;code&gt;T&lt;/code&gt; の他の有用な値には、 &lt;code&gt;String&lt;/code&gt; 、 &lt;code&gt;AbstractString&lt;/code&gt; 、 &lt;code&gt;Any&lt;/code&gt; があります。</target>
        </trans-unit>
        <trans-unit id="5708e9143fa5c221a25e2fd582d17441adb4aff2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a union of types containing &lt;code&gt;Missing&lt;/code&gt;, return a new type with &lt;code&gt;Missing&lt;/code&gt; removed.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; が &lt;code&gt;Missing&lt;/code&gt; を含む型の共用体である場合、 &lt;code&gt;Missing&lt;/code&gt; が削除された新しい型を返します。</target>
        </trans-unit>
        <trans-unit id="69fee994b4c0ef137b6453b3ceac4a68a22fb0fc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an &lt;a href=&quot;../numbers/index#Core.Integer&quot;&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/a&gt; type, an &lt;a href=&quot;#Core.InexactError&quot;&gt;&lt;code&gt;InexactError&lt;/code&gt;&lt;/a&gt; will be raised if &lt;code&gt;x&lt;/code&gt; is not representable by &lt;code&gt;T&lt;/code&gt;, for example if &lt;code&gt;x&lt;/code&gt; is not integer-valued, or is outside the range supported by &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; は、ある&lt;a href=&quot;../numbers/index#Core.Integer&quot;&gt; &lt;code&gt;Integer&lt;/code&gt; &lt;/a&gt;型、&lt;a href=&quot;#Core.InexactError&quot;&gt; &lt;code&gt;InexactError&lt;/code&gt; の&lt;/a&gt;場合に発生する &lt;code&gt;x&lt;/code&gt; で表現ない &lt;code&gt;T&lt;/code&gt; 場合、例えば、 &lt;code&gt;x&lt;/code&gt; 整数値でないか、によってサポートされる範囲外である &lt;code&gt;T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c36ac776e4be839ff56e17825105904e00568128" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an integer type, an &lt;code&gt;InexactError&lt;/code&gt; is raised if &lt;code&gt;x&lt;/code&gt; is not representable by &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; は整数型であり、 &lt;code&gt;InexactError&lt;/code&gt; があれば上昇し &lt;code&gt;x&lt;/code&gt; によって表現ない &lt;code&gt;T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c7762b87399cdbea094b67bb56bb79bce4032130" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;X/Project.toml&lt;/code&gt; exists and but does &lt;em&gt;not&lt;/em&gt; have a top-level UUID entry, &lt;code&gt;uuid&lt;/code&gt; is a dummy UUID generated by hashing the canonical (real) path to &lt;code&gt;X/Project.toml&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;X/Project.toml&lt;/code&gt; が存在し、最上位のUUIDエントリが&lt;em&gt;ない&lt;/em&gt;場合、 &lt;code&gt;uuid&lt;/code&gt; は &lt;code&gt;X/Project.toml&lt;/code&gt; への正規の（実際の）パスをハッシュすることによって生成されるダミーのUUID です。</target>
        </trans-unit>
        <trans-unit id="57feda5962ebeb025a02c2fc5115db7f5ee74658" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;X/Project.toml&lt;/code&gt; exists and has a &lt;code&gt;uuid&lt;/code&gt; entry, then &lt;code&gt;uuid&lt;/code&gt; is that value.</source>
          <target state="translated">場合 &lt;code&gt;X/Project.toml&lt;/code&gt; が存在し、持っている &lt;code&gt;uuid&lt;/code&gt; エントリを、次いで、 &lt;code&gt;uuid&lt;/code&gt; 、その値です。</target>
        </trans-unit>
        <trans-unit id="b0ad6875ad056062a02a932f0ca014f6680202e9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;alg = DivideAndConquer()&lt;/code&gt; a divide-and-conquer algorithm is used to calculate the SVD. Another (typically slower but more accurate) option is &lt;code&gt;alg = QRIteration()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;alg = DivideAndConquer()&lt;/code&gt; 場合、分割統治アルゴリズムを使用してSVDを計算します。もう1つの（通常は低速ですがより正確な）オプションは &lt;code&gt;alg = QRIteration()&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="6feb00535e98202cbe0e255e2cd1a8e59544d667" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;all&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; (the default), this function will block repeatedly trying to read all requested bytes, until an error or end-of-file occurs. If &lt;code&gt;all&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, at most one &lt;code&gt;read&lt;/code&gt; call is performed, and the amount of data returned is device-dependent. Note that not all stream types support the &lt;code&gt;all&lt;/code&gt; option.</source>
          <target state="translated">場合は &lt;code&gt;all&lt;/code&gt; ある &lt;code&gt;true&lt;/code&gt; （デフォルト）エラーまたはファイルの終わりが発生するまで、この関数は、要求されたすべてのバイトを読み取ろうと繰り返しブロックします。場合は &lt;code&gt;all&lt;/code&gt; ある &lt;code&gt;false&lt;/code&gt; 、最大で1つ &lt;code&gt;read&lt;/code&gt; 呼び出しが行われ、返されるデータの量は、デバイスに依存しています。すべてのストリームタイプが &lt;code&gt;all&lt;/code&gt; オプションをサポートしているわけではないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="7b3a53d050caeb89134ca9bb80d1091ff36a0cf4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;b&lt;/code&gt; is a power of 2 or 10, &lt;a href=&quot;#Base.log2&quot;&gt;&lt;code&gt;log2&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Base.log10&quot;&gt;&lt;code&gt;log10&lt;/code&gt;&lt;/a&gt; should be used, as these will typically be faster and more accurate. For example,</source>
          <target state="translated">&lt;code&gt;b&lt;/code&gt; が2または10の累乗である場合、&lt;a href=&quot;#Base.log2&quot;&gt; &lt;code&gt;log2&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;#Base.log10&quot;&gt; &lt;code&gt;log10&lt;/code&gt; &lt;/a&gt;を使用する必要があります。これらは通常、より高速で正確です。例えば、</target>
        </trans-unit>
        <trans-unit id="89b9fac160344d84b2e97547e3cbb9b2dd975a11" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;batch_size&lt;/code&gt; is specified, the collection is processed in batch mode. &lt;code&gt;f&lt;/code&gt; must then be a function that must accept a &lt;code&gt;Vector&lt;/code&gt; of argument tuples and must return a vector of results. The input vector will have a length of &lt;code&gt;batch_size&lt;/code&gt; or less.</source>
          <target state="translated">場合 &lt;code&gt;batch_size&lt;/code&gt; 指定され、コレクションは、バッチモードで処理されます。次に、 &lt;code&gt;f&lt;/code&gt; は、引数タプルの &lt;code&gt;Vector&lt;/code&gt; を受け入れ、結果のベクターを返す関数でなければなりません。入力ベクトルの長さは、 &lt;code&gt;batch_size&lt;/code&gt; 以下になります。</target>
        </trans-unit>
        <trans-unit id="9a514f5181b462b5cf60570457a733a924782944" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;collection&lt;/code&gt; is ordered, use &lt;a href=&quot;#Base.append!&quot;&gt;&lt;code&gt;append!&lt;/code&gt;&lt;/a&gt; to add all the elements of another collection to it. The result of the preceding example is equivalent to &lt;code&gt;append!([1, 2, 3], [4, 5, 6])&lt;/code&gt;. For &lt;code&gt;AbstractSet&lt;/code&gt; objects, &lt;a href=&quot;#Base.union!&quot;&gt;&lt;code&gt;union!&lt;/code&gt;&lt;/a&gt; can be used instead.</source>
          <target state="translated">&lt;code&gt;collection&lt;/code&gt; を注文する場合は、&lt;a href=&quot;#Base.append!&quot;&gt; &lt;code&gt;append!&lt;/code&gt; を&lt;/a&gt;使用してください。別のコレクションのすべての要素をそれに追加します。前の例の結果は、 &lt;code&gt;append!([1, 2, 3], [4, 5, 6])&lt;/code&gt; と同等です。以下のための &lt;code&gt;AbstractSet&lt;/code&gt; のオブジェクト、&lt;a href=&quot;#Base.union!&quot;&gt; &lt;code&gt;union!&lt;/code&gt; &lt;/a&gt;代わりに使用できます。</target>
        </trans-unit>
        <trans-unit id="f2467dc77e236fb9b24d515beabeb30ab9b34314" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dims&lt;/code&gt; is a tuple, the order of the dimensions in &lt;code&gt;dims&lt;/code&gt; is relevant and specifies the linear order of the slices. E.g., if &lt;code&gt;A&lt;/code&gt; is three dimensional and &lt;code&gt;dims&lt;/code&gt; is &lt;code&gt;(1, 2)&lt;/code&gt;, the orderings of the first two dimensions are re-arranged such such that the slices (of the remaining third dimension) are sorted. If &lt;code&gt;dims&lt;/code&gt; is &lt;code&gt;(2, 1)&lt;/code&gt; instead, the same slices will be taken, but the result order will be row-major instead.</source>
          <target state="translated">場合は &lt;code&gt;dims&lt;/code&gt; タプルで、内寸法の順序 &lt;code&gt;dims&lt;/code&gt; 関連性があるとスライスの線形順序を指定します。たとえば、 &lt;code&gt;A&lt;/code&gt; が3次元で、 &lt;code&gt;dims&lt;/code&gt; が &lt;code&gt;(1, 2)&lt;/code&gt; 場合、最初の2次元の順序は、（残りの3次元の）スライスがソートされるように再配置されます。代わりに &lt;code&gt;dims&lt;/code&gt; が &lt;code&gt;(2, 1)&lt;/code&gt; 2、1）の場合、同じスライスが取得されますが、結果の順序は行優先になります。</target>
        </trans-unit>
        <trans-unit id="74fad15bfd2101b3b16f9ea74a15c93af724d1dd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dlm&lt;/code&gt; is omitted, it defaults to &lt;a href=&quot;#Base.Unicode.isspace&quot;&gt;&lt;code&gt;isspace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">場合 &lt;code&gt;dlm&lt;/code&gt; に省略され、それがデフォルト&lt;a href=&quot;#Base.Unicode.isspace&quot;&gt; &lt;code&gt;isspace&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7d7429e0d71b847a07568d302028712dbaf31f03" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;factorize&lt;/code&gt; is called on a Hermitian positive-definite matrix, for instance, then &lt;code&gt;factorize&lt;/code&gt; will return a Cholesky factorization.</source>
          <target state="translated">場合は &lt;code&gt;factorize&lt;/code&gt; エルミート正定値行列で呼び出され、例えば、その後、 &lt;code&gt;factorize&lt;/code&gt; コレスキー分解を返します。</target>
        </trans-unit>
        <trans-unit id="b7c73e768a4a1fc2665ff51aa066980c89d3ec1f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;follow_symlinks=false&lt;/code&gt;, and &lt;code&gt;src&lt;/code&gt; is a symbolic link, &lt;code&gt;dst&lt;/code&gt; will be created as a symbolic link. If &lt;code&gt;follow_symlinks=true&lt;/code&gt; and &lt;code&gt;src&lt;/code&gt; is a symbolic link, &lt;code&gt;dst&lt;/code&gt; will be a copy of the file or directory &lt;code&gt;src&lt;/code&gt; refers to. Return &lt;code&gt;dst&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;follow_symlinks=false&lt;/code&gt; 、および &lt;code&gt;src&lt;/code&gt; がシンボリックリンクで、 &lt;code&gt;dst&lt;/code&gt; シンボリックリンクとして作成されます。場合 &lt;code&gt;follow_symlinks=true&lt;/code&gt; と &lt;code&gt;src&lt;/code&gt; がシンボリックリンクで、 &lt;code&gt;dst&lt;/code&gt; ファイルやディレクトリのコピーとなります &lt;code&gt;src&lt;/code&gt; はを指します。 &lt;code&gt;dst&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="0fefe7c70552bb288eba8725570e0711eb9913bd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;full = false&lt;/code&gt; (default), a &quot;thin&quot; SVD is returned. For a $M \times N$ matrix &lt;code&gt;A&lt;/code&gt;, in the full factorization &lt;code&gt;U&lt;/code&gt; is &lt;code&gt;M \times M&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is &lt;code&gt;N \times N&lt;/code&gt;, while in the thin factorization &lt;code&gt;U&lt;/code&gt; is &lt;code&gt;M \times K&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is &lt;code&gt;N \times K&lt;/code&gt;, where &lt;code&gt;K = \min(M,N)&lt;/code&gt; is the number of singular values.</source>
          <target state="translated">場合は &lt;code&gt;full = false&lt;/code&gt; （デフォルト）、「薄い」SVDが返されます。$ M \ times N $行列 &lt;code&gt;A&lt;/code&gt; の場合、完全分解では &lt;code&gt;U&lt;/code&gt; は &lt;code&gt;M \times M&lt;/code&gt; あり、 &lt;code&gt;V&lt;/code&gt; は &lt;code&gt;N \times N&lt;/code&gt; ですが、薄い分解では &lt;code&gt;U&lt;/code&gt; は &lt;code&gt;M \times K&lt;/code&gt; あり、 &lt;code&gt;V&lt;/code&gt; は &lt;code&gt;N \times K&lt;/code&gt; 。ここで、 &lt;code&gt;K = \min(M,N)&lt;/code&gt; は特異値の数です。</target>
        </trans-unit>
        <trans-unit id="e7087620ad88bc806c680dac427ffd57a67879dd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fussy_sqrt&lt;/code&gt; is called with a negative value from another function, instead of trying to continue execution of the calling function, it returns immediately, displaying the error message in the interactive session:</source>
          <target state="translated">&lt;code&gt;fussy_sqrt&lt;/code&gt; が別の関数から負の値で呼び出された場合、呼び出し側の関数の実行を続行しようとせずに、すぐに戻り、対話型セッションでエラーメッセージを表示します。</target>
        </trans-unit>
        <trans-unit id="c19e0b85728fe9481b7abf51cbb032dc0e45287a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;generated&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, the returned &lt;code&gt;CodeInfo&lt;/code&gt; instances will correspond to fallback implementations. An error is thrown if no fallback implementation exists. If &lt;code&gt;generated&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, these &lt;code&gt;CodeInfo&lt;/code&gt; instances will correspond to the method bodies yielded by expanding the generators.</source>
          <target state="translated">場合は &lt;code&gt;generated&lt;/code&gt; ある &lt;code&gt;false&lt;/code&gt; 、返さ &lt;code&gt;CodeInfo&lt;/code&gt; のインスタンスは、実装をフォールバックに対応します。フォールバック実装が存在しない場合、エラーがスローされます。場合に &lt;code&gt;generated&lt;/code&gt; ある &lt;code&gt;true&lt;/code&gt; 、これら &lt;code&gt;CodeInfo&lt;/code&gt; のインスタンスは、発電機を拡張することによって得られたメソッド本体に対応することになります。</target>
        </trans-unit>
        <trans-unit id="3b5b7e505ab23a5d0aa601628f61af1433ebc0f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;header&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the first row of data will be read as header and the tuple &lt;code&gt;(data_cells, header_cells)&lt;/code&gt; is returned instead of only &lt;code&gt;data_cells&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;header&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; の場合、データの最初の行がヘッダーとして読み取られ &lt;code&gt;(data_cells, header_cells)&lt;/code&gt; &lt;code&gt;data_cells&lt;/code&gt; だけではなく、タプル（data_cells、header_cells）が返されます。</target>
        </trans-unit>
        <trans-unit id="c950181a2a1658a2e38c89bd49475efe3e66e317" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;i&lt;/code&gt; is in bounds in &lt;code&gt;s&lt;/code&gt; return the index of the start of the character whose encoding code unit &lt;code&gt;i&lt;/code&gt; is part of. In other words, if &lt;code&gt;i&lt;/code&gt; is the start of a character, return &lt;code&gt;i&lt;/code&gt;; if &lt;code&gt;i&lt;/code&gt; is not the start of a character, rewind until the start of a character and return that index. If &lt;code&gt;i&lt;/code&gt; is equal to 0 or &lt;code&gt;ncodeunits(s)+1&lt;/code&gt; return &lt;code&gt;i&lt;/code&gt;. In all other cases throw &lt;code&gt;BoundsError&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;i&lt;/code&gt; が &lt;code&gt;s&lt;/code&gt; の境界内にある場合、エンコードコードユニット &lt;code&gt;i&lt;/code&gt; が含まれる文字の開始のインデックスを返します。言い換えれば、 &lt;code&gt;i&lt;/code&gt; キャラクタのスタートで、返す &lt;code&gt;i&lt;/code&gt; 。 &lt;code&gt;i&lt;/code&gt; が文字の先頭でない場合は、文字の先頭まで巻き戻し、そのインデックスを返します。場合 &lt;code&gt;i&lt;/code&gt; は 0又はに等しい &lt;code&gt;ncodeunits(s)+1&lt;/code&gt; リターン &lt;code&gt;i&lt;/code&gt; 。その他の場合はすべて &lt;code&gt;BoundsError&lt;/code&gt; をスローします。</target>
        </trans-unit>
        <trans-unit id="ed8634de2b332fe1583659d48b66208896196beb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;i&lt;/code&gt; is in bounds in &lt;code&gt;s&lt;/code&gt; return the index of the start of the character whose encoding starts after index &lt;code&gt;i&lt;/code&gt;. In other words, if &lt;code&gt;i&lt;/code&gt; is the start of a character, return the start of the next character; if &lt;code&gt;i&lt;/code&gt; is not the start of a character, move forward until the start of a character and return that index. If &lt;code&gt;i&lt;/code&gt; is equal to &lt;code&gt;0&lt;/code&gt; return &lt;code&gt;1&lt;/code&gt;. If &lt;code&gt;i&lt;/code&gt; is in bounds but greater or equal to &lt;code&gt;lastindex(str)&lt;/code&gt; return &lt;code&gt;ncodeunits(str)+1&lt;/code&gt;. Otherwise throw &lt;code&gt;BoundsError&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;i&lt;/code&gt; が &lt;code&gt;s&lt;/code&gt; の境界内にある場合、インデックス &lt;code&gt;i&lt;/code&gt; の後にエンコーディングが始まる文字の開始のインデックスを返します。つまり、 &lt;code&gt;i&lt;/code&gt; が文字の先頭の場合、次の文字の先頭を返します。 &lt;code&gt;i&lt;/code&gt; が文字の先頭でない場合は、文字の先頭まで進み、そのインデックスを返します。 &lt;code&gt;i&lt;/code&gt; が &lt;code&gt;0&lt;/code&gt; の場合は &lt;code&gt;1&lt;/code&gt; を返します。もし &lt;code&gt;i&lt;/code&gt; が境界内にあるが、大きいかまたは等しい &lt;code&gt;lastindex(str)&lt;/code&gt; リターン &lt;code&gt;ncodeunits(str)+1&lt;/code&gt; 。それ以外の場合は &lt;code&gt;BoundsError&lt;/code&gt; をスローします。</target>
        </trans-unit>
        <trans-unit id="5bcc465fac95b41229c6fb79ecf0d3dab69e75e9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;i&lt;/code&gt; is in bounds in &lt;code&gt;s&lt;/code&gt; return the index of the start of the character whose encoding starts before index &lt;code&gt;i&lt;/code&gt;. In other words, if &lt;code&gt;i&lt;/code&gt; is the start of a character, return the start of the previous character; if &lt;code&gt;i&lt;/code&gt; is not the start of a character, rewind until the start of a character and return that index. If &lt;code&gt;i&lt;/code&gt; is equal to &lt;code&gt;1&lt;/code&gt; return &lt;code&gt;0&lt;/code&gt;. If &lt;code&gt;i&lt;/code&gt; is equal to &lt;code&gt;ncodeunits(str)+1&lt;/code&gt; return &lt;code&gt;lastindex(str)&lt;/code&gt;. Otherwise throw &lt;code&gt;BoundsError&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;i&lt;/code&gt; が &lt;code&gt;s&lt;/code&gt; の境界内にある場合、インデックス &lt;code&gt;i&lt;/code&gt; の前にエンコードが始まる文字の開始のインデックスを返します。つまり、 &lt;code&gt;i&lt;/code&gt; が文字の先頭の場合、前の文字の先頭を返します。 &lt;code&gt;i&lt;/code&gt; が文字の先頭でない場合は、文字の先頭まで巻き戻し、そのインデックスを返します。 &lt;code&gt;i&lt;/code&gt; が &lt;code&gt;1&lt;/code&gt; の場合は &lt;code&gt;0&lt;/code&gt; を返します。場合は &lt;code&gt;i&lt;/code&gt; に等しい &lt;code&gt;ncodeunits(str)+1&lt;/code&gt; リターン &lt;code&gt;lastindex(str)&lt;/code&gt; 。それ以外の場合は &lt;code&gt;BoundsError&lt;/code&gt; をスローします。</target>
        </trans-unit>
        <trans-unit id="9ebe5e40c213fd1e7b9dc945437a4e812c30e543" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;initialized&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; (the default), then &lt;code&gt;ix&lt;/code&gt; is initialized to contain the indices of &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">場合は &lt;code&gt;initialized&lt;/code&gt; ある &lt;code&gt;false&lt;/code&gt; （デフォルト）、その後、 &lt;code&gt;ix&lt;/code&gt; の指標含むように初期化され &lt;code&gt;v&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9fcfeccc007b268d4af436c2f9443a9d036bba79" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;initialized&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, but &lt;code&gt;ix&lt;/code&gt; does not contain (a permutation of) the indices of &lt;code&gt;v&lt;/code&gt;, the behavior of &lt;code&gt;partialsortperm!&lt;/code&gt; is undefined.</source>
          <target state="translated">場合は &lt;code&gt;initialized&lt;/code&gt; され &lt;code&gt;true&lt;/code&gt; が、 &lt;code&gt;ix&lt;/code&gt; （の順列）のインデックスが含まれていない &lt;code&gt;v&lt;/code&gt; の動作 &lt;code&gt;partialsortperm!&lt;/code&gt; は未定義です。</target>
        </trans-unit>
        <trans-unit id="3cfff02ba2ab7ab8f47553333086d7d3b017d4eb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;io&lt;/code&gt; is not specified, &lt;code&gt;host&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt; are used to connect.</source>
          <target state="translated">&lt;code&gt;io&lt;/code&gt; が指定されていない場合、 &lt;code&gt;host&lt;/code&gt; と &lt;code&gt;port&lt;/code&gt; が接続に使用されます。</target>
        </trans-unit>
        <trans-unit id="675d2f45d06133423691ac8939a36ff3793bfbd0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;io&lt;/code&gt; is specified, it is used to read host/port information. A Julia worker prints out its bind address and port at startup. This allows Julia workers to listen on any free port available instead of requiring worker ports to be configured manually.</source>
          <target state="translated">場合は &lt;code&gt;io&lt;/code&gt; 指定され、ホスト/ポート情報を読み取るために使用されます。Juliaワーカーは、起動時にバインドアドレスとポートを出力します。これにより、Juliaワーカーは、ワーカーポートを手動で構成する必要がなく、使用可能な空きポートをリッスンできます。</target>
        </trans-unit>
        <trans-unit id="23c03ff245d9cf669803a913ec063d9d852e916b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;irange&lt;/code&gt; is not &lt;code&gt;1:n&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the dimension of &lt;code&gt;A&lt;/code&gt;, then the returned factorization will be a &lt;em&gt;truncated&lt;/em&gt; factorization.</source>
          <target state="translated">&lt;code&gt;irange&lt;/code&gt; が &lt;code&gt;1:n&lt;/code&gt; ではない場合（ &lt;code&gt;n&lt;/code&gt; は &lt;code&gt;A&lt;/code&gt; の次元）、返される因数分解は&lt;em&gt;切り捨てられた&lt;/em&gt;因数分解になります。</target>
        </trans-unit>
        <trans-unit id="33bb6515a9488e11cd97387cfe2fdf0354f00b17" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;isless(x, y)&lt;/code&gt; is defined, then so is &lt;code&gt;isless(y, x)&lt;/code&gt; and &lt;code&gt;isequal(x, y)&lt;/code&gt;, and exactly one of those three yields &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;isless(x, y)&lt;/code&gt; 定義され、そのようになる &lt;code&gt;isless(y, x)&lt;/code&gt; と &lt;code&gt;isequal(x, y)&lt;/code&gt; 、及びこれら3つの収率の正確に一つの &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="27bcd4132639e391333ba702df2bbfcfeb96c942" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;itr&lt;/code&gt; contains &lt;code&gt;NaN&lt;/code&gt; or &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, the result is also &lt;code&gt;NaN&lt;/code&gt; or &lt;code&gt;missing&lt;/code&gt; (&lt;code&gt;missing&lt;/code&gt; takes precedence if &lt;code&gt;itr&lt;/code&gt; contains both). Use the &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt;&lt;code&gt;skipmissing&lt;/code&gt;&lt;/a&gt; function to omit &lt;code&gt;missing&lt;/code&gt; entries and compute the median of non-missing values.</source>
          <target state="translated">場合 &lt;code&gt;itr&lt;/code&gt; 含まれている &lt;code&gt;NaN&lt;/code&gt; または&lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt;値を、結果もある &lt;code&gt;NaN&lt;/code&gt; または &lt;code&gt;missing&lt;/code&gt; （ &lt;code&gt;missing&lt;/code&gt; 場合は優先されます &lt;code&gt;itr&lt;/code&gt; 両方が含まれています）。&lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt; &lt;code&gt;skipmissing&lt;/code&gt; &lt;/a&gt;関数を使用して、 &lt;code&gt;missing&lt;/code&gt; エントリを省略し、欠落していない値の中央値を計算します。</target>
        </trans-unit>
        <trans-unit id="c3e083f5fc9364992337e03964ee084acea5fae6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;itr&lt;/code&gt; contains &lt;code&gt;NaN&lt;/code&gt; or &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, the result is also &lt;code&gt;NaN&lt;/code&gt; or &lt;code&gt;missing&lt;/code&gt; (&lt;code&gt;missing&lt;/code&gt; takes precedence if array contains both). Use the &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt;&lt;code&gt;skipmissing&lt;/code&gt;&lt;/a&gt; function to omit &lt;code&gt;missing&lt;/code&gt; entries and compute the mean of non-missing values.</source>
          <target state="translated">場合 &lt;code&gt;itr&lt;/code&gt; 含ま &lt;code&gt;NaN&lt;/code&gt; または&lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt;た値を、結果でもある &lt;code&gt;NaN&lt;/code&gt; または &lt;code&gt;missing&lt;/code&gt; （ &lt;code&gt;missing&lt;/code&gt; 配列の両方が含まれている場合に優先）。&lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt; &lt;code&gt;skipmissing&lt;/code&gt; &lt;/a&gt;関数を使用して、 &lt;code&gt;missing&lt;/code&gt; エントリを省略し、欠落していない値の平均を計算します。</target>
        </trans-unit>
        <trans-unit id="6474b35658d7c26eeead842892ada1aea0d886f7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;itr&lt;/code&gt; is an &lt;code&gt;AbstractArray&lt;/code&gt;, &lt;code&gt;dims&lt;/code&gt; can be provided to compute the standard deviation over dimensions, and &lt;code&gt;m&lt;/code&gt; may contain means for each dimension of &lt;code&gt;itr&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;itr&lt;/code&gt; ある &lt;code&gt;AbstractArray&lt;/code&gt; 、 &lt;code&gt;dims&lt;/code&gt; 寸法上の標準偏差を計算するために設けることができ、 &lt;code&gt;m&lt;/code&gt; は、各ディメンションの手段を含んでいてもよい &lt;code&gt;itr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="51822a7fae2f9177cdbe8acba291b2ecbdaf5a84" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;itr&lt;/code&gt; is an &lt;code&gt;AbstractArray&lt;/code&gt;, &lt;code&gt;dims&lt;/code&gt; can be provided to compute the standard deviation over dimensions, and &lt;code&gt;means&lt;/code&gt; may contain means for each dimension of &lt;code&gt;itr&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;itr&lt;/code&gt; ある &lt;code&gt;AbstractArray&lt;/code&gt; 、 &lt;code&gt;dims&lt;/code&gt; 寸法上の標準偏差を計算するために提供することができ、及び &lt;code&gt;means&lt;/code&gt; 、各ディメンションの手段を含んでいてもよい &lt;code&gt;itr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a062a8f0de1a26806b03ecc36f3c075df17d6625" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;itr&lt;/code&gt; is an &lt;code&gt;AbstractArray&lt;/code&gt;, &lt;code&gt;dims&lt;/code&gt; can be provided to compute the standard deviation over dimensions. In that case, &lt;code&gt;mean&lt;/code&gt; must be an array with the same shape as &lt;code&gt;mean(itr, dims=dims)&lt;/code&gt; (additional trailing singleton dimensions are allowed).</source>
          <target state="translated">場合 &lt;code&gt;itr&lt;/code&gt; ある &lt;code&gt;AbstractArray&lt;/code&gt; 、 &lt;code&gt;dims&lt;/code&gt; 寸法上の標準偏差を計算するために設けることができます。その場合、 &lt;code&gt;mean&lt;/code&gt; は &lt;code&gt;mean(itr, dims=dims)&lt;/code&gt; と同じ形状の配列である必要があります（追加の末尾のシングルトン次元が許可されます）。</target>
        </trans-unit>
        <trans-unit id="faf5ec759432f757b892cc486fe0509d46288036" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;itr&lt;/code&gt; is an &lt;code&gt;AbstractArray&lt;/code&gt;, &lt;code&gt;dims&lt;/code&gt; can be provided to compute the variance over dimensions, and &lt;code&gt;m&lt;/code&gt; may contain means for each dimension of &lt;code&gt;itr&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;itr&lt;/code&gt; ある &lt;code&gt;AbstractArray&lt;/code&gt; 、 &lt;code&gt;dims&lt;/code&gt; 寸法上の分散を計算するために設けることができ、 &lt;code&gt;m&lt;/code&gt; は、各ディメンションの手段を含んでいてもよい &lt;code&gt;itr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="37d953297aa88c0f3bc07a3115b3b34627aebd03" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;itr&lt;/code&gt; is an &lt;code&gt;AbstractArray&lt;/code&gt;, &lt;code&gt;dims&lt;/code&gt; can be provided to compute the variance over dimensions, and &lt;code&gt;mean&lt;/code&gt; may contain means for each dimension of &lt;code&gt;itr&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;itr&lt;/code&gt; ある &lt;code&gt;AbstractArray&lt;/code&gt; 、 &lt;code&gt;dims&lt;/code&gt; 寸法上の分散を計算するために設けることができ、 &lt;code&gt;mean&lt;/code&gt; 、各次元のための手段を含んでいてもよい &lt;code&gt;itr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="990c04cdd5ec49c07722688547969ed041fe0726" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;itr&lt;/code&gt; is an &lt;code&gt;AbstractArray&lt;/code&gt;, &lt;code&gt;dims&lt;/code&gt; can be provided to compute the variance over dimensions.</source>
          <target state="translated">場合 &lt;code&gt;itr&lt;/code&gt; ある &lt;code&gt;AbstractArray&lt;/code&gt; 、 &lt;code&gt;dims&lt;/code&gt; 寸法上の分散を計算するために設けることができます。</target>
        </trans-unit>
        <trans-unit id="56c42d84f4d44608418a9c06e641987a8cc6e81e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;itr&lt;/code&gt; is an &lt;code&gt;AbstractArray&lt;/code&gt;, &lt;code&gt;dims&lt;/code&gt; can be provided to compute the variance over dimensions. In that case, &lt;code&gt;mean&lt;/code&gt; must be an array with the same shape as &lt;code&gt;mean(itr, dims=dims)&lt;/code&gt; (additional trailing singleton dimensions are allowed).</source>
          <target state="translated">場合 &lt;code&gt;itr&lt;/code&gt; ある &lt;code&gt;AbstractArray&lt;/code&gt; 、 &lt;code&gt;dims&lt;/code&gt; 寸法上の分散を計算するために設けることができます。その場合、 &lt;code&gt;mean&lt;/code&gt; は &lt;code&gt;mean(itr, dims=dims)&lt;/code&gt; と同じ形状の配列である必要があります（追加の末尾のシングルトン次元が許可されます）。</target>
        </trans-unit>
        <trans-unit id="8c5a74c045541a90c529fb0859ca2583588298de" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;length&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; are provided and &lt;code&gt;step&lt;/code&gt; is not, the step size will be computed automatically such that there are &lt;code&gt;length&lt;/code&gt; linearly spaced elements in the range (a &lt;a href=&quot;../collections/index#Base.LinRange&quot;&gt;&lt;code&gt;LinRange&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">場合 &lt;code&gt;length&lt;/code&gt; と &lt;code&gt;stop&lt;/code&gt; 設けられている &lt;code&gt;step&lt;/code&gt; ない、ステップサイズがあることを自動的にように計算される &lt;code&gt;length&lt;/code&gt; 直線範囲（に離間要素&lt;a href=&quot;../collections/index#Base.LinRange&quot;&gt; &lt;code&gt;LinRange&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="a704a76b38109c4ddf6a00329dc6ebcf8c7f4fac" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;length&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; are provided and &lt;code&gt;step&lt;/code&gt; is not, the step size will be computed automatically such that there are &lt;code&gt;length&lt;/code&gt; linearly spaced elements in the range.</source>
          <target state="translated">場合 &lt;code&gt;length&lt;/code&gt; と &lt;code&gt;stop&lt;/code&gt; 設けられている &lt;code&gt;step&lt;/code&gt; ない、ステップサイズがあることを自動的にように計算される &lt;code&gt;length&lt;/code&gt; 直線範囲の離間要素。</target>
        </trans-unit>
        <trans-unit id="51d6d1b8a88beec41cb040befac543132aff1625" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;overlap=true&lt;/code&gt;, the matching sequences are allowed to overlap indices in the original string, otherwise they must be from disjoint character ranges.</source>
          <target state="translated">場合 &lt;code&gt;overlap=true&lt;/code&gt; 、整合配列は、さもなければそれらがばらばら文字範囲からのものでなければならない、元の文字列に重複インデックスに許可されています。</target>
        </trans-unit>
        <trans-unit id="0677161ec30784ce49b4b8aeda531d688c559665" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pids&lt;/code&gt; is left unspecified, the shared array will be mapped across all processes on the current host, including the master. But, &lt;code&gt;localindices&lt;/code&gt; and &lt;code&gt;indexpids&lt;/code&gt; will only refer to worker processes. This facilitates work distribution code to use workers for actual computation with the master process acting as a driver.</source>
          <target state="translated">場合 &lt;code&gt;pids&lt;/code&gt; 指定されていないままにする、共有配列は、マスターを含む、現在のホスト上のすべてのプロセス間でマッピングされます。ただし、 &lt;code&gt;localindices&lt;/code&gt; と &lt;code&gt;indexpids&lt;/code&gt; はワーカープロセスのみを参照します。これにより、作業分散コードは、マスタープロセスがドライバーとして機能する実際の計算にワーカーを使用するのを容易にします。</target>
        </trans-unit>
        <trans-unit id="39265b02d633cf948cee760fccd02e8e4c595e22" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;quotes&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, columns enclosed within double-quote (&quot;) characters are allowed to contain new lines and column delimiters. Double-quote characters within a quoted field must be escaped with another double-quote. Specifying &lt;code&gt;dims&lt;/code&gt; as a tuple of the expected rows and columns (including header, if any) may speed up reading of large files. If &lt;code&gt;comments&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, lines beginning with &lt;code&gt;comment_char&lt;/code&gt; and text following &lt;code&gt;comment_char&lt;/code&gt; in any line are ignored.</source>
          <target state="translated">場合は &lt;code&gt;quotes&lt;/code&gt; ある &lt;code&gt;true&lt;/code&gt; 、列は二重引用符で囲まれた（ &quot;）文字は、新しい行と列の区切り文字を含むように許可されている。二重引用符を引用し、フィールド内の別の二重引用符でエスケープする必要があります。指定 &lt;code&gt;dims&lt;/code&gt; 予想されるのタプルとして（ヘッダを含め、もしあれば）の行と列は、大きなファイルの読み込みスピードアップすることがあります。場合 &lt;code&gt;comments&lt;/code&gt; あり &lt;code&gt;true&lt;/code&gt; で始まる行、 &lt;code&gt;comment_char&lt;/code&gt; およびテキスト次 &lt;code&gt;comment_char&lt;/code&gt; 任意の行では無視されます。</target>
        </trans-unit>
        <trans-unit id="072d5e68fa14ef444211e0638bdf60961c940d9d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;reuseaddr=true&lt;/code&gt;, multiple threads or processes can bind to the same address without error if they all set &lt;code&gt;reuseaddr=true&lt;/code&gt;, but only the last to bind will receive any traffic.</source>
          <target state="translated">場合 &lt;code&gt;reuseaddr=true&lt;/code&gt; 彼らはすべて設定されている場合は、複数のスレッドやプロセスがエラーなしで同じアドレスにバインドすることができ &lt;code&gt;reuseaddr=true&lt;/code&gt; が、バインドにのみ、最後には、すべてのトラフィックを受信します。</target>
        </trans-unit>
        <trans-unit id="88b9f6afde6b8b83ebdb2719c69ddd36ee622e38" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rng&lt;/code&gt; is not specified, it defaults to seeding the state of the shared thread-local generator.</source>
          <target state="translated">&lt;code&gt;rng&lt;/code&gt; が指定されていない場合、デフォルトで共有スレッドローカルジェネレーターの状態がシードされます。</target>
        </trans-unit>
        <trans-unit id="5dd9d0433c4fe181d962946c85904ec68a57d1fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rook&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, rook pivoting is used. If &lt;code&gt;rook&lt;/code&gt; is false, rook pivoting is not used.</source>
          <target state="translated">場合は &lt;code&gt;rook&lt;/code&gt; ある &lt;code&gt;true&lt;/code&gt; 、ルークのピボットが使用されています。 &lt;code&gt;rook&lt;/code&gt; がfalseの場合、rookピボットは使用されません。</target>
        </trans-unit>
        <trans-unit id="3686d47af71436aa8068aa094e6acfdb577abbc8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skipblanks&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, blank lines in the input will be ignored.</source>
          <target state="translated">&lt;code&gt;skipblanks&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; の場合、入力の空白行は無視されます。</target>
        </trans-unit>
        <trans-unit id="01862aa97c770501d33a4692799d52e5b5e3dee6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;spawn = true&lt;/code&gt;, the Task created for &lt;code&gt;func&lt;/code&gt; may be scheduled on another thread in parallel, equivalent to creating a task via &lt;a href=&quot;../multi-threading/index#Base.Threads.@spawn&quot;&gt;&lt;code&gt;Threads.@spawn&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">場合 &lt;code&gt;spawn = true&lt;/code&gt; 、タスクのために作成 &lt;code&gt;func&lt;/code&gt; を経由して、タスクを作成することと同じ並行して別のスレッド、上でスケジュールすることができる&lt;a href=&quot;../multi-threading/index#Base.Threads.@spawn&quot;&gt; &lt;code&gt;Threads.@spawn&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a5a873983f34f90f6f3366d1e91c3b5438a1e6c7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;step&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; are provided and &lt;code&gt;length&lt;/code&gt; is not, the overall range length will be computed automatically such that the elements are &lt;code&gt;step&lt;/code&gt; spaced (a &lt;a href=&quot;../collections/index#Base.StepRange&quot;&gt;&lt;code&gt;StepRange&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">場合 &lt;code&gt;step&lt;/code&gt; と &lt;code&gt;stop&lt;/code&gt; 設けられている &lt;code&gt;length&lt;/code&gt; ではなく、全体的な範囲の長さは要素があることを自動的にように計算する &lt;code&gt;step&lt;/code&gt; 離間（&lt;a href=&quot;../collections/index#Base.StepRange&quot;&gt; &lt;code&gt;StepRange&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="a062e99e636224da62916657b0080cc837347ab0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;step&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; are provided and &lt;code&gt;length&lt;/code&gt; is not, the overall range length will be computed automatically such that the elements are &lt;code&gt;step&lt;/code&gt; spaced.</source>
          <target state="translated">場合 &lt;code&gt;step&lt;/code&gt; と &lt;code&gt;stop&lt;/code&gt; 設けられている &lt;code&gt;length&lt;/code&gt; ではなく、全体的な範囲の長さは要素があることを自動的にように計算する &lt;code&gt;step&lt;/code&gt; 離間します。</target>
        </trans-unit>
        <trans-unit id="4a505616ea56a3e3c587fbb37c2a52b74909df91" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;InterruptException&lt;/code&gt; is not thrown by Ctrl-C. Running code upon such event requires &lt;a href=&quot;../base/index#Base.atexit&quot;&gt;&lt;code&gt;atexit&lt;/code&gt;&lt;/a&gt;. This is the default behavior in Julia script run without &lt;code&gt;-i&lt;/code&gt; option.</source>
          <target state="translated">場合は &lt;code&gt;true&lt;/code&gt; 、 &lt;code&gt;InterruptException&lt;/code&gt; は、 Ctrlキーを押しながらCによってスローされていません。このようなイベントでコードを実行するには、&lt;a href=&quot;../base/index#Base.atexit&quot;&gt; &lt;code&gt;atexit&lt;/code&gt; &lt;/a&gt;が必要です。これは、 &lt;code&gt;-i&lt;/code&gt; オプションなしで実行されるJuliaスクリプトのデフォルトの動作です。</target>
        </trans-unit>
        <trans-unit id="c1a52fdda97e9a9edb8d40a32fdbba7468a954c1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;types&lt;/code&gt; is an abstract type, then the method that would be called by &lt;code&gt;invoke&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;types&lt;/code&gt; が抽象タイプの場合、 &lt;code&gt;invoke&lt;/code&gt; によって呼び出されるメソッドが返されます。</target>
        </trans-unit>
        <trans-unit id="99dfe42909a3f5fda34b5da4dc246c9c5fb25583" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;types&lt;/code&gt; is specified, return an array of methods whose types match. If &lt;code&gt;module&lt;/code&gt; is specified, return an array of methods defined in that module. A list of modules can also be specified as an array.</source>
          <target state="translated">&lt;code&gt;types&lt;/code&gt; が指定されている場合、タイプが一致するメソッドの配列を返します。 &lt;code&gt;module&lt;/code&gt; が指定されている場合は、そのモジュールで定義されているメソッドの配列を返します。モジュールのリストを配列として指定することもできます。</target>
        </trans-unit>
        <trans-unit id="f58b04b4e4485017440ce0c5de7416ee07070fe9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;types&lt;/code&gt; is specified, returns an array of methods whose types match.</source>
          <target state="translated">&lt;code&gt;types&lt;/code&gt; が指定されている場合、タイプが一致するメソッドの配列を返します。</target>
        </trans-unit>
        <trans-unit id="b3892fb415986ed95819205d489e6d5bbab6470a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;use_mmap&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the file specified by &lt;code&gt;source&lt;/code&gt; is memory mapped for potential speedups. Default is &lt;code&gt;true&lt;/code&gt; except on Windows. On Windows, you may want to specify &lt;code&gt;true&lt;/code&gt; if the file is large, and is only read once and not written to.</source>
          <target state="translated">場合 &lt;code&gt;use_mmap&lt;/code&gt; がある &lt;code&gt;true&lt;/code&gt; 、で指定されたファイル &lt;code&gt;source&lt;/code&gt; 潜在的なスピードアップのためにマップされたメモリです。Windowsを除き、デフォルトは &lt;code&gt;true&lt;/code&gt; です。Windowsでは、ファイルが大きく、一度だけ読み取られ、書き込まれない場合は、 &lt;code&gt;true&lt;/code&gt; を指定できます。</target>
        </trans-unit>
        <trans-unit id="5645668108ab9880ec8d6ff07db8800e64be268c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;wait&lt;/code&gt; is false, the process runs asynchronously. You can later wait for it and check its exit status by calling &lt;code&gt;success&lt;/code&gt; on the returned process object.</source>
          <target state="translated">場合は &lt;code&gt;wait&lt;/code&gt; 偽で、プロセスが非同期的に実行されます。後でそれを待って、返されたプロセスオブジェクトで &lt;code&gt;success&lt;/code&gt; を呼び出すことにより、その終了ステータスを確認できます。</target>
        </trans-unit>
        <trans-unit id="4328d82bb88eefa0e600962ab951d3053ce804f5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a number, this is essentially the same as &lt;code&gt;one(x)/x&lt;/code&gt;, but for some types &lt;code&gt;inv(x)&lt;/code&gt; may be slightly more efficient.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; が数値の場合、これは基本的に &lt;code&gt;one(x)/x&lt;/code&gt; と同じですが、一部のタイプでは &lt;code&gt;inv(x)&lt;/code&gt; の方がわずかに効率的です。</target>
        </trans-unit>
        <trans-unit id="5d6e97018433ee560ec26ad905f78e6763128a42" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a type, return a &quot;larger&quot; type, defined so that arithmetic operations &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;-&lt;/code&gt; are guaranteed not to overflow nor lose precision for any combination of values that type &lt;code&gt;x&lt;/code&gt; can hold.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; がタイプの場合、算術演算 &lt;code&gt;+&lt;/code&gt; および &lt;code&gt;-&lt;/code&gt; がオーバーフローしたり、タイプ &lt;code&gt;x&lt;/code&gt; が保持できる値の組み合わせの精度が失われないことが保証されるように定義された「より大きい」タイプを返します。</target>
        </trans-unit>
        <trans-unit id="88ba7ee31764ff507d81e94f6a3b385c0be71e42" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a value, it is converted to &lt;code&gt;widen(typeof(x))&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;x&lt;/code&gt; 値であり、ために変換される &lt;code&gt;widen(typeof(x))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a828e6b72bb380836af54de218be15aa9ebea9db" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is an object reference, all elements will refer to the same object. &lt;code&gt;fill(Foo(), dims)&lt;/code&gt; will return an array filled with the result of evaluating &lt;code&gt;Foo()&lt;/code&gt; once.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; がオブジェクト参照の場合、すべての要素は同じオブジェクトを参照します。 &lt;code&gt;fill(Foo(), dims)&lt;/code&gt; は、 &lt;code&gt;Foo()&lt;/code&gt; を 1回評価した結果で満たされた配列を返します。</target>
        </trans-unit>
        <trans-unit id="c793973e3f101c15348a8c798bb0a96d340155d9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is an object reference, all elements will refer to the same object:</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; がオブジェクト参照の場合、すべての要素は同じオブジェクトを参照します。</target>
        </trans-unit>
        <trans-unit id="db317e66581e31b148fb1c68097906f9ec9dcecb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is not an &lt;code&gt;AbstractArray&lt;/code&gt; but it supports &lt;code&gt;axes&lt;/code&gt;, indexing, and its type supports &lt;code&gt;ndims&lt;/code&gt;, then &lt;code&gt;broadcastable(::typeof(x))&lt;/code&gt; may be implemented to just return itself. Further, if &lt;code&gt;x&lt;/code&gt; defines its own &lt;a href=&quot;#Base.Broadcast.BroadcastStyle&quot;&gt;&lt;code&gt;BroadcastStyle&lt;/code&gt;&lt;/a&gt;, then it must define its &lt;code&gt;broadcastable&lt;/code&gt; method to return itself for the custom style to have any effect.</source>
          <target state="translated">場合は &lt;code&gt;x&lt;/code&gt; ない &lt;code&gt;AbstractArray&lt;/code&gt; が、それはサポート &lt;code&gt;axes&lt;/code&gt; 、インデックス、およびそのタイプのサポートの &lt;code&gt;ndims&lt;/code&gt; を、そして &lt;code&gt;broadcastable(::typeof(x))&lt;/code&gt; 、単に自分自身を返すように実装することができます。さらに、 &lt;code&gt;x&lt;/code&gt; が独自の&lt;a href=&quot;#Base.Broadcast.BroadcastStyle&quot;&gt; &lt;code&gt;BroadcastStyle&lt;/code&gt; を&lt;/a&gt;定義している場合、カスタムスタイルが効果を発揮するには、xが &lt;code&gt;broadcastable&lt;/code&gt; メソッドを定義して自分自身を返す必要があります。</target>
        </trans-unit>
        <trans-unit id="ead093ec45b992f54a438f256340d7b0a0ef7df6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; supports iteration, the returned value should have the same &lt;code&gt;axes&lt;/code&gt; and indexing behaviors as &lt;code&gt;collect(x)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; が反復をサポートしている場合、戻り値は &lt;code&gt;collect(x)&lt;/code&gt; と同じ &lt;code&gt;axes&lt;/code&gt; とインデックスの動作を持つ必要があります。</target>
        </trans-unit>
        <trans-unit id="9eb6d4efdb2a84932dc930c8197ad4f7fad62394" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is an &lt;code&gt;Int&lt;/code&gt; literal (e.g. &lt;code&gt;2&lt;/code&gt; in &lt;code&gt;x^2&lt;/code&gt; or &lt;code&gt;-3&lt;/code&gt; in &lt;code&gt;x^-3&lt;/code&gt;), the Julia code &lt;code&gt;x^y&lt;/code&gt; is transformed by the compiler to &lt;code&gt;Base.literal_pow(^, x, Val(y))&lt;/code&gt;, to enable compile-time specialization on the value of the exponent. (As a default fallback we have &lt;code&gt;Base.literal_pow(^, x, Val(y)) = ^(x,y)&lt;/code&gt;, where usually &lt;code&gt;^ == Base.^&lt;/code&gt; unless &lt;code&gt;^&lt;/code&gt; has been defined in the calling namespace.)</source>
          <target state="translated">場合 &lt;code&gt;y&lt;/code&gt; がある &lt;code&gt;Int&lt;/code&gt; リテラル（例えば &lt;code&gt;2&lt;/code&gt; で &lt;code&gt;x^2&lt;/code&gt; 又は &lt;code&gt;-3&lt;/code&gt; で &lt;code&gt;x^-3&lt;/code&gt; ）、ジュリア・コード &lt;code&gt;x^y&lt;/code&gt; にコンパイラによって変換さ &lt;code&gt;Base.literal_pow(^, x, Val(y))&lt;/code&gt; に指数の値でコンパイル時の特殊化を有効にします。 （デフォルトはフォールバックとして、我々が持っている &lt;code&gt;Base.literal_pow(^, x, Val(y)) = ^(x,y)&lt;/code&gt; 、どこ通常 &lt;code&gt;^ == Base.^&lt;/code&gt; ない限り、 &lt;code&gt;^&lt;/code&gt; が呼び出す名前空間で定義されています。）</target>
        </trans-unit>
        <trans-unit id="4030642b9b0fac77c474cfa27dc2012de7dca7c4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;yes&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, subsequent floating-point operations follow rules for IEEE arithmetic on subnormal values (&quot;denormals&quot;). Otherwise, floating-point operations are permitted (but not required) to convert subnormal inputs or outputs to zero. Returns &lt;code&gt;true&lt;/code&gt; unless &lt;code&gt;yes==true&lt;/code&gt; but the hardware does not support zeroing of subnormal numbers.</source>
          <target state="translated">&lt;code&gt;yes&lt;/code&gt; が &lt;code&gt;false&lt;/code&gt; の場合、後続の浮動小数点演算は、非正規値（「非正規」）に対するIEEE演算の規則に従います。それ以外の場合、非正規入力または非正規入力をゼロに変換するために浮動小数点演算が許可されます（必須ではありません）。 &lt;code&gt;yes==true&lt;/code&gt; &lt;code&gt;true&lt;/code&gt; でない限りtrueを返しますが、ハードウェアは非正規数のゼロ化をサポートしていません。</target>
        </trans-unit>
        <trans-unit id="4fe82c65bb97ee33e80659528026f81237a00185" translate="yes" xml:space="preserve">
          <source>If Julia were a language that made more liberal use of ASCII characters, the slurping operator might have been written as &lt;code&gt;&amp;lt;-...&lt;/code&gt; instead of &lt;code&gt;...&lt;/code&gt;.</source>
          <target state="translated">JuliaがASCII文字をより自由に使用する言語である場合、丸呑み演算子は &lt;code&gt;&amp;lt;-...&lt;/code&gt; ではなく&amp;lt;-...と記述されている可能性があり &lt;code&gt;...&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1c31aabb66505776aad35d90bd36db4dbf2d1b9d" translate="yes" xml:space="preserve">
          <source>If Julia were a language that made more liberal use of ASCII characters, the splatting operator might have been written as &lt;code&gt;...-&amp;gt;&lt;/code&gt; instead of &lt;code&gt;...&lt;/code&gt;.</source>
          <target state="translated">JuliaがASCII文字をより自由に使用する言語であった場合、スプラッティング演算子は &lt;code&gt;...&lt;/code&gt; ではなく &lt;code&gt;...-&amp;gt;&lt;/code&gt; と記述されている可能性があります。</target>
        </trans-unit>
        <trans-unit id="60a92e91dcf7c91c0849e69c5ad346e21b345fcf" translate="yes" xml:space="preserve">
          <source>If [&lt;code&gt;vl&lt;/code&gt;, &lt;code&gt;vu&lt;/code&gt;] does not contain all eigenvalues of &lt;code&gt;A&lt;/code&gt;, then the returned factorization will be a &lt;em&gt;truncated&lt;/em&gt; factorization.</source>
          <target state="translated">[ &lt;code&gt;vl&lt;/code&gt; 、 &lt;code&gt;vu&lt;/code&gt; ]に &lt;code&gt;A&lt;/code&gt; のすべての固有値が含まれていない場合、返される因数分解は&lt;em&gt;切り捨て&lt;/em&gt;因数分解になります。</target>
        </trans-unit>
        <trans-unit id="730dc1af168d94eefd1482151f83529bc44df580" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; is empty, readers (on a &lt;code&gt;take!&lt;/code&gt; call) will block until data is available.</source>
          <target state="translated">&lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt;が空の場合、（ &lt;code&gt;take!&lt;/code&gt; コールで）リーダーはデータが利用可能になるまでブロックします。</target>
        </trans-unit>
        <trans-unit id="84662f0c325b992dd59906d92d27342a4c4aeef8" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; is full, writers (on a &lt;code&gt;put!&lt;/code&gt; call) will block until space becomes available.</source>
          <target state="translated">場合は&lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt;いっぱいある、（上の作家 &lt;code&gt;put!&lt;/code&gt; スペースが利用可能になるまでコール）がブロックされます。</target>
        </trans-unit>
        <trans-unit id="800a9b7d396fd78b7b6ed22445dc02985ff5d965" translate="yes" xml:space="preserve">
          <source>If a C/C++ routine has an argument or return value that is a native SIMD type, the corresponding Julia type is a homogeneous tuple of &lt;code&gt;VecElement&lt;/code&gt; that naturally maps to the SIMD type. Specifically:</source>
          <target state="translated">C / C ++ルーチンに引数または戻り値がネイティブSIMDタイプである場合、対応するJuliaタイプは、SIMDタイプに自然にマップされる &lt;code&gt;VecElement&lt;/code&gt; の同種のタプルです。具体的には：</target>
        </trans-unit>
        <trans-unit id="c33b9c9ad9c6bea2ac47b4bed7df57b3ce4b628b" translate="yes" xml:space="preserve">
          <source>If a Julia function returns an array, the return value of &lt;code&gt;jl_eval_string&lt;/code&gt; and &lt;code&gt;jl_call&lt;/code&gt; can be cast to a &lt;code&gt;jl_array_t*&lt;/code&gt;:</source>
          <target state="translated">Julia関数が配列を返す場合、 &lt;code&gt;jl_eval_string&lt;/code&gt; および &lt;code&gt;jl_call&lt;/code&gt; の戻り値は &lt;code&gt;jl_array_t*&lt;/code&gt; キャストできます。</target>
        </trans-unit>
        <trans-unit id="da26aec502d267a61bc582bb3d104bf1101787e9" translate="yes" xml:space="preserve">
          <source>If a composite type is declared with &lt;code&gt;mutable struct&lt;/code&gt; instead of &lt;code&gt;struct&lt;/code&gt;, then instances of it can be modified:</source>
          <target state="translated">複合型を用いて宣言された場合に &lt;code&gt;mutable struct&lt;/code&gt; の代わりに &lt;code&gt;struct&lt;/code&gt; 、それのその後のインスタンスを修正することができます。</target>
        </trans-unit>
        <trans-unit id="4c7983e304a903c4c76a6412696125933d637b1a" translate="yes" xml:space="preserve">
          <source>If a function name requires multiple words, consider whether it might represent more than one concept and might be better split into pieces.</source>
          <target state="translated">関数名に複数の単語が必要な場合は、それが複数の概念を表すかどうかを検討し、分割した方が良いかどうかを検討してください。</target>
        </trans-unit>
        <trans-unit id="38936f146450cf1d3ca2236e47484dcaa49c5476" translate="yes" xml:space="preserve">
          <source>If a keyword argument is not assigned a default value in the method definition, then it is &lt;em&gt;required&lt;/em&gt;: an &lt;a href=&quot;../../base/base/index#Core.UndefKeywordError&quot;&gt;&lt;code&gt;UndefKeywordError&lt;/code&gt;&lt;/a&gt; exception will be thrown if the caller does not assign it a value:</source>
          <target state="translated">キーワード引数にメソッド定義でデフォルト値が割り当てられていない場合、それは&lt;em&gt;必須です&lt;/em&gt;。呼び出し元が値を割り当てない場合、&lt;a href=&quot;../../base/base/index#Core.UndefKeywordError&quot;&gt; &lt;code&gt;UndefKeywordError&lt;/code&gt; &lt;/a&gt;例外がスローされます。</target>
        </trans-unit>
        <trans-unit id="605fe15674b1485baef4edc3c0b585f43273c96f" translate="yes" xml:space="preserve">
          <source>If a name is qualified (e.g. &lt;code&gt;Base.sin&lt;/code&gt;), then it can be accessed even if it is not exported. This is often useful when debugging. It can also have methods added to it by using the qualified name as the function name. However, due to syntactic ambiguities that arise, if you wish to add methods to a function in a different module whose name contains only symbols, such as an operator, &lt;code&gt;Base.+&lt;/code&gt; for example, you must use &lt;code&gt;Base.:+&lt;/code&gt; to refer to it. If the operator is more than one character in length you must surround it in brackets, such as: &lt;code&gt;Base.:(==)&lt;/code&gt;.</source>
          <target state="translated">名前が修飾されている場合（ &lt;code&gt;Base.sin&lt;/code&gt; など）、エクスポートされていなくてもアクセスできます。これは多くの場合、デバッグ時に役立ちます。関数名として修飾名を使用して、メソッドを追加することもできます。ただし、発生する構文のあいまいさのために、たとえば &lt;code&gt;Base.+&lt;/code&gt; ように、名前にシンボルのみが含まれる別のモジュールの関数にメソッドを追加する場合は、Base。：+を使用して &lt;code&gt;Base.:+&lt;/code&gt; を参照する必要があります。。演算子の長さが複数の場合は、 &lt;code&gt;Base.:(==)&lt;/code&gt; . :( ==）のように、演算子を角かっこで囲む必要があります。</target>
        </trans-unit>
        <trans-unit id="906babc709733bae3d983752e96904e9364b6d02" translate="yes" xml:space="preserve">
          <source>If a number doesn't have an exact floating-point representation, it must be rounded to an appropriate representable value. However, the manner in which this rounding is done can be changed if required according to the rounding modes presented in the &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-2008&quot;&gt;IEEE 754 standard&lt;/a&gt;.</source>
          <target state="translated">数値が正確な浮動小数点表現を持たない場合は、適切な表現可能な値に丸める必要があります。ただし、この丸めが行われる方法は、&lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-2008&quot;&gt;IEEE 754標準で&lt;/a&gt;提示されている丸めモードに従って、必要に応じて変更できます。</target>
        </trans-unit>
        <trans-unit id="b6c6ec423ec9e7ccad324608060715dc6c4297ac" translate="yes" xml:space="preserve">
          <source>If a package subdirectory has a project file, then the graph entry for its UUID is the &lt;code&gt;[deps]&lt;/code&gt; map of the project file, which is considered to be empty if the section is absent.</source>
          <target state="translated">パッケージサブディレクトリにプロジェクトファイルがある場合、そのUUIDのグラフエントリはプロジェクトファイルの &lt;code&gt;[deps]&lt;/code&gt; マップであり、セクションがない場合は空であると見なされます。</target>
        </trans-unit>
        <trans-unit id="b858ef46784b4025474ecb1ef203d57b534b42bf" translate="yes" xml:space="preserve">
          <source>If a package subdirectory has no project file, then it is omitted from graph and import statements in its code are treated as top-level, the same as the main project and REPL.</source>
          <target state="translated">パッケージのサブディレクトリにプロジェクトファイルがない場合は、グラフから省略され、そのコード内のインポート文は、メインプロジェクトやREPLと同じトップレベルとして扱われます。</target>
        </trans-unit>
        <trans-unit id="2f45dbf01a0d76d1b423a11e7134b517f4cc2734" translate="yes" xml:space="preserve">
          <source>If a regular expression does match, the value returned by &lt;a href=&quot;../../base/strings/index#Base.match&quot;&gt;&lt;code&gt;match&lt;/code&gt;&lt;/a&gt; is a &lt;code&gt;RegexMatch&lt;/code&gt; object. These objects record how the expression matches, including the substring that the pattern matches and any captured substrings, if there are any. This example only captures the portion of the substring that matches, but perhaps we want to capture any non-blank text after the comment character. We could do the following:</source>
          <target state="translated">正規表現が一致する場合、によって返される値&lt;a href=&quot;../../base/strings/index#Base.match&quot;&gt; &lt;code&gt;match&lt;/code&gt; &lt;/a&gt;ある &lt;code&gt;RegexMatch&lt;/code&gt; オブジェクト。これらのオブジェクトは、パターンが一致する部分文字列、およびキャプチャされた部分文字列（ある場合）を含め、式がどのように一致するかを記録します。この例では、一致する部分文字列の部分のみをキャプチャしますが、コメント文字の後の空白以外のテキストをキャプチャしたい場合があります。次のことができます。</target>
        </trans-unit>
        <trans-unit id="5e6085fa6af3d4081b0dc16abe2813cbe1633ab2" translate="yes" xml:space="preserve">
          <source>If a second argument &lt;code&gt;val&lt;/code&gt; is provided, it will be passed to the task (via the return value of &lt;a href=&quot;#Base.yieldto&quot;&gt;&lt;code&gt;yieldto&lt;/code&gt;&lt;/a&gt;) when it runs again. If &lt;code&gt;error&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the value is raised as an exception in the woken task.</source>
          <target state="translated">2番目の引数 &lt;code&gt;val&lt;/code&gt; が指定されている場合、再度実行すると、タスクに（&lt;a href=&quot;#Base.yieldto&quot;&gt; &lt;code&gt;yieldto&lt;/code&gt; &lt;/a&gt;の戻り値を介して）渡されます。場合は &lt;code&gt;error&lt;/code&gt; ある &lt;code&gt;true&lt;/code&gt; 、値が起こされたタスクで例外として発生します。</target>
        </trans-unit>
        <trans-unit id="731b72f6b2ff317794a532fdec183702202f0468" translate="yes" xml:space="preserve">
          <source>If a subtype is used to represent values that may occasionally be rational (e.g. a square-root type that represents &lt;code&gt;&amp;radic;n&lt;/code&gt; for integers &lt;code&gt;n&lt;/code&gt; will give a rational result when &lt;code&gt;n&lt;/code&gt; is a perfect square), then it should also implement &lt;code&gt;isinteger&lt;/code&gt;, &lt;code&gt;iszero&lt;/code&gt;, &lt;code&gt;isone&lt;/code&gt;, and &lt;code&gt;==&lt;/code&gt; with &lt;code&gt;Real&lt;/code&gt; values (since all of these default to &lt;code&gt;false&lt;/code&gt; for &lt;code&gt;AbstractIrrational&lt;/code&gt; types), as well as defining &lt;a href=&quot;../base/index#Base.hash&quot;&gt;&lt;code&gt;hash&lt;/code&gt;&lt;/a&gt; to equal that of the corresponding &lt;code&gt;Rational&lt;/code&gt;.</source>
          <target state="translated">サブタイプを使用して、有理数になることがある値を表す場合（たとえば、整数 &lt;code&gt;n&lt;/code&gt; の &lt;code&gt;&amp;radic;n&lt;/code&gt; を表す平方根型は、 &lt;code&gt;n&lt;/code&gt; が完全な二乗の場合に有理数の結果をもたらします）、 &lt;code&gt;isinteger&lt;/code&gt; 、 &lt;code&gt;iszero&lt;/code&gt; 、isoneも実装する必要が &lt;code&gt;isone&lt;/code&gt; 、および &lt;code&gt;==&lt;/code&gt; と &lt;code&gt;Real&lt;/code&gt; 値（これらのデフォルトの全てので &lt;code&gt;false&lt;/code&gt; 用 &lt;code&gt;AbstractIrrational&lt;/code&gt; タイプ）、ならびに規定&lt;a href=&quot;../base/index#Base.hash&quot;&gt; &lt;code&gt;hash&lt;/code&gt; &lt;/a&gt;対応のものと等しくなるように &lt;code&gt;Rational&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bad86ee27c201caed09e850508017b392f709911" translate="yes" xml:space="preserve">
          <source>If a test fails consistently it can be changed to use the &lt;code&gt;@test_broken&lt;/code&gt; macro. This will denote the test as &lt;code&gt;Broken&lt;/code&gt; if the test continues to fail and alerts the user via an &lt;code&gt;Error&lt;/code&gt; if the test succeeds.</source>
          <target state="translated">テストが一貫して失敗する場合は、 &lt;code&gt;@test_broken&lt;/code&gt; マクロを使用するように変更できます。これは、テストが失敗し続ける場合はテストが &lt;code&gt;Broken&lt;/code&gt; ことを示し、テストが成功した場合は &lt;code&gt;Error&lt;/code&gt; を介してユーザーに警告します。</target>
        </trans-unit>
        <trans-unit id="f4acf383897e60ec242acf14416a5081e1af3573" translate="yes" xml:space="preserve">
          <source>If a tuple of keyword argument names &lt;code&gt;kwnames&lt;/code&gt; is provided, this also checks whether the method of &lt;code&gt;f&lt;/code&gt; matching &lt;code&gt;t&lt;/code&gt; has the given keyword argument names. If the matching method accepts a variable number of keyword arguments, e.g. with &lt;code&gt;kwargs...&lt;/code&gt;, any names given in &lt;code&gt;kwnames&lt;/code&gt; are considered valid. Otherwise the provided names must be a subset of the method's keyword arguments.</source>
          <target state="translated">キーワード引数名 &lt;code&gt;kwnames&lt;/code&gt; のタプルが指定されている場合、これは、 &lt;code&gt;t&lt;/code&gt; に一致する &lt;code&gt;f&lt;/code&gt; のメソッドに指定されたキーワード引数名​​があるかどうかもチェックします。一致するメソッドが可変数のキーワード引数を受け入れる場合（例： &lt;code&gt;kwargs...&lt;/code&gt; 、 &lt;code&gt;kwnames&lt;/code&gt; で指定された名前はすべて有効と見なされます。それ以外の場合、提供される名前はメソッドのキーワード引数のサブセットでなければなりません。</target>
        </trans-unit>
        <trans-unit id="abfdad8cad5f7ab5488ad45c94b34a153640fd97" translate="yes" xml:space="preserve">
          <source>If a type is defined as a subtype of &lt;code&gt;AbstractArray&lt;/code&gt;, it inherits a very large set of rich behaviors including iteration and multidimensional indexing built on top of single-element access. See the &lt;a href=&quot;../arrays/index#man-multi-dim-arrays&quot;&gt;arrays manual page&lt;/a&gt; and the &lt;a href=&quot;../../base/arrays/index#lib-arrays&quot;&gt;Julia Base section&lt;/a&gt; for more supported methods.</source>
          <target state="translated">タイプが &lt;code&gt;AbstractArray&lt;/code&gt; のサブタイプとして定義されている場合、単一要素アクセスの上に構築された反復や多次元インデックスなど、非常に多くの豊富な動作のセットを継承します。サポートされているその他の方法については、&lt;a href=&quot;../arrays/index#man-multi-dim-arrays&quot;&gt;アレイのマニュアルページ&lt;/a&gt;と&lt;a href=&quot;../../base/arrays/index#lib-arrays&quot;&gt;JuliaBaseのセクション&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="3df6568badc4d30be904f3a616a563af8fd77a0a" translate="yes" xml:space="preserve">
          <source>If a type is defined as a subtype of &lt;code&gt;AbstractArray&lt;/code&gt;, it inherits a very large set of rich behaviors including iteration and multidimensional indexing built on top of single-element access. See the &lt;a href=&quot;../arrays/index#man-multi-dim-arrays-1&quot;&gt;arrays manual page&lt;/a&gt; and the &lt;a href=&quot;../../base/arrays/index#lib-arrays-1&quot;&gt;Julia Base section&lt;/a&gt; for more supported methods.</source>
          <target state="translated">タイプが &lt;code&gt;AbstractArray&lt;/code&gt; のサブタイプとして定義されている場合、そのタイプは、単一要素のアクセスに基づいて構築された反復や多次元インデックス作成など、非常に多くの豊富な動作のセットを継承します。サポートされているメソッドの詳細については、&lt;a href=&quot;../arrays/index#man-multi-dim-arrays-1&quot;&gt;アレイのマニュアルページ&lt;/a&gt;と&lt;a href=&quot;../../base/arrays/index#lib-arrays-1&quot;&gt;Julia Baseセクション&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="72a8103071abaea7ac2a617ea71042865eddd171" translate="yes" xml:space="preserve">
          <source>If a type is effectively an enumeration, it should be defined as a single (ideally immutable struct or primitive) type, with the enumeration values being instances of it. Constructors and conversions can check whether values are valid. This design is preferred over making the enumeration an abstract type, with the &quot;values&quot; as subtypes.</source>
          <target state="translated">型が事実上の列挙である場合,それは単一の(理想的には不変な構造体またはプリミティブ)型として定義され,列挙値はそのインスタンスとなります。コンストラクタや変換は,値が有効かどうかをチェックすることができます。この設計は、列挙を抽象型とし、「値」をサブ型とするよりも優先されます。</target>
        </trans-unit>
        <trans-unit id="22206d1a9cff4ea1aad87ee3f387a4a25003f12d" translate="yes" xml:space="preserve">
          <source>If a user is presented with a credential prompt they can abort the prompt by typing &lt;code&gt;^D&lt;/code&gt; (pressing the control key together with the &lt;code&gt;d&lt;/code&gt; key).</source>
          <target state="translated">ユーザーに資格情報プロンプトが表示された場合、 &lt;code&gt;^D&lt;/code&gt; 入力して（Ctrlキーを押しながら &lt;code&gt;d&lt;/code&gt; キーを押す）、プロンプトを中止できます。</target>
        </trans-unit>
        <trans-unit id="ebb7b0aa6b2c808bffa6df77883dc4cf4f4f7ece" translate="yes" xml:space="preserve">
          <source>If a worker pool is not specified, all available workers, i.e., the default worker pool is used.</source>
          <target state="translated">ワーカープールが指定されていない場合、利用可能なすべてのワーカー、すなわちデフォルトのワーカープールが使用されます。</target>
        </trans-unit>
        <trans-unit id="ec5bfd99caef655cee76ea6c587f7690d264c4bb" translate="yes" xml:space="preserve">
          <source>If all data is numeric, the result will be a numeric array. If some elements cannot be parsed as numbers, a heterogeneous array of numbers and strings is returned.</source>
          <target state="translated">すべてのデータが数値の場合、結果は数値配列となります。いくつかの要素が数値として解析できない場合は、数値と文字列の異種配列が返されます。</target>
        </trans-unit>
        <trans-unit id="9ac5a121e4737af42e151921b98260446a6d1fe7" translate="yes" xml:space="preserve">
          <source>If all indices &lt;code&gt;I_k&lt;/code&gt; are integers, then the value in location &lt;code&gt;I_1, I_2, ..., I_n&lt;/code&gt; of &lt;code&gt;A&lt;/code&gt; is overwritten with the value of &lt;code&gt;X&lt;/code&gt;, &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt;ing to the &lt;a href=&quot;../../base/collections/index#Base.eltype&quot;&gt;&lt;code&gt;eltype&lt;/code&gt;&lt;/a&gt; of &lt;code&gt;A&lt;/code&gt; if necessary.</source>
          <target state="translated">すべてのインデックス場合 &lt;code&gt;I_k&lt;/code&gt; 整数であり、その後、位置の値 &lt;code&gt;I_1, I_2, ..., I_n&lt;/code&gt; の &lt;code&gt;A&lt;/code&gt; は、の値で上書きされた &lt;code&gt;X&lt;/code&gt; 、&lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt;にINGの&lt;a href=&quot;../../base/collections/index#Base.eltype&quot;&gt; &lt;code&gt;eltype&lt;/code&gt; &lt;/a&gt;の &lt;code&gt;A&lt;/code&gt; 必要に応じ。</target>
        </trans-unit>
        <trans-unit id="16c375c96eb496fe31b2274a71fede0f6283f232" translate="yes" xml:space="preserve">
          <source>If all indices &lt;code&gt;I_k&lt;/code&gt; are vectors, for example, then the shape of &lt;code&gt;X&lt;/code&gt; would be &lt;code&gt;(length(I_1), length(I_2), ..., length(I_n))&lt;/code&gt;, with location &lt;code&gt;i_1, i_2, ..., i_n&lt;/code&gt; of &lt;code&gt;X&lt;/code&gt; containing the value &lt;code&gt;A[I_1[i_1], I_2[i_2], ..., I_n[i_n]]&lt;/code&gt;.</source>
          <target state="translated">すべてのインデックス場合 &lt;code&gt;I_k&lt;/code&gt; ベクトルであり、例えば、その後の形状 &lt;code&gt;X&lt;/code&gt; はであろう &lt;code&gt;(length(I_1), length(I_2), ..., length(I_n))&lt;/code&gt; 位置と、 &lt;code&gt;i_1, i_2, ..., i_n&lt;/code&gt; の &lt;code&gt;X&lt;/code&gt; 値を含む &lt;code&gt;A[I_1[i_1], I_2[i_2], ..., I_n[i_n]]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d7329bd9dbc66827b90f349500e9813dc3f4dd6b" translate="yes" xml:space="preserve">
          <source>If all the arguments are scalars or zero-dimensional arrays, it returns an unwrapped scalar.</source>
          <target state="translated">すべての引数がスカラまたは0次元配列の場合、ラップされていないスカラを返します。</target>
        </trans-unit>
        <trans-unit id="947c4d2702167c0b010760802f3c8902ac7ef2b7" translate="yes" xml:space="preserve">
          <source>If all the indices are scalars, then the result &lt;code&gt;X&lt;/code&gt; is a single element from the array &lt;code&gt;A&lt;/code&gt;. Otherwise, &lt;code&gt;X&lt;/code&gt; is an array with the same number of dimensions as the sum of the dimensionalities of all the indices.</source>
          <target state="translated">すべてのインデックスがスカラーの場合、結果の &lt;code&gt;X&lt;/code&gt; は配列 &lt;code&gt;A&lt;/code&gt; の単一の要素になります。それ以外の場合、 &lt;code&gt;X&lt;/code&gt; は、すべてのインデックスの次元の合計と同じ次元数の配列です。</target>
        </trans-unit>
        <trans-unit id="3044600e4ff9e45b323c2058f952d5b48a41642d" translate="yes" xml:space="preserve">
          <source>If all these checks pass, the message and key&amp;ndash;value pairs are evaluated in full and passed to the current logger via the &lt;a href=&quot;#Base.CoreLogging.handle_message&quot;&gt;&lt;code&gt;Logging.handle_message&lt;/code&gt;&lt;/a&gt; function. &lt;code&gt;handle_message()&lt;/code&gt; may perform additional filtering as required and display the event to the screen, save it to a file, etc.</source>
          <target state="translated">これらすべてのチェックに合格すると、メッセージとキーと値のペアが完全に評価され、&lt;a href=&quot;#Base.CoreLogging.handle_message&quot;&gt; &lt;code&gt;Logging.handle_message&lt;/code&gt; &lt;/a&gt;関数を介して現在のロガーに渡されます。 &lt;code&gt;handle_message()&lt;/code&gt; は、必要に応じて追加のフィルタリングを実行し、イベントを画面に表示したり、ファイルに保存したりできます。</target>
        </trans-unit>
        <trans-unit id="80169baf9571e6bf174d6f8272d7aa9246651030" translate="yes" xml:space="preserve">
          <source>If all these checks pass, the message and key&amp;ndash;value pairs are evaluated in full and passed to the current logger via the &lt;a href=&quot;#Logging.handle_message&quot;&gt;&lt;code&gt;Logging.handle_message&lt;/code&gt;&lt;/a&gt; function. &lt;code&gt;handle_message()&lt;/code&gt; may perform additional filtering as required and display the event to the screen, save it to a file, etc.</source>
          <target state="translated">これらすべてのチェックに合格すると、メッセージとキーと値のペアが完全に評価され、&lt;a href=&quot;#Logging.handle_message&quot;&gt; &lt;code&gt;Logging.handle_message&lt;/code&gt; &lt;/a&gt;関数を介して現在のロガーに渡されます。 &lt;code&gt;handle_message()&lt;/code&gt; は、必要に応じて追加のフィルタリングを実行し、イベントを画面に表示したり、ファイルに保存したりする場合があります。</target>
        </trans-unit>
        <trans-unit id="bec4431d05d00195da3b5ef4209465d15c43707c" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;init&lt;/code&gt; function of the type &lt;code&gt;initfn(S::SharedArray)&lt;/code&gt; is specified, it is called on all the participating workers.</source>
          <target state="translated">場合 &lt;code&gt;init&lt;/code&gt; タイプの機能 &lt;code&gt;initfn(S::SharedArray)&lt;/code&gt; 指定され、それがすべての参加労働者と呼ばれています。</target>
        </trans-unit>
        <trans-unit id="3b65b9c692ce6d8deffe1b518910973b66bdfe66" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;init&lt;/code&gt; function, of signature &lt;code&gt;initfn(S::SharedArray)&lt;/code&gt;, is specified, it is called on all the participating workers. You can specify that each worker runs the &lt;code&gt;init&lt;/code&gt; function on a distinct portion of the array, thereby parallelizing initialization.</source>
          <target state="translated">場合 &lt;code&gt;init&lt;/code&gt; 署名の機能、 &lt;code&gt;initfn(S::SharedArray)&lt;/code&gt; 、指定され、それがすべての参加労働者と呼ばれています。各ワーカーが配列の異なる部分で &lt;code&gt;init&lt;/code&gt; 関数を実行するように指定して、初期化を並列化できます。</target>
        </trans-unit>
        <trans-unit id="dcd6328c4dd12bc549abfb594d444224ffd4160c" translate="yes" xml:space="preserve">
          <source>If an array of eltype &lt;code&gt;Ptr{T}&lt;/code&gt; is passed as a &lt;code&gt;Ptr{Ptr{T}}&lt;/code&gt; argument, &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt;&lt;code&gt;Base.cconvert&lt;/code&gt;&lt;/a&gt; will attempt to first make a null-terminated copy of the array with each element replaced by its &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt;&lt;code&gt;Base.cconvert&lt;/code&gt;&lt;/a&gt; version. This allows, for example, passing an &lt;code&gt;argv&lt;/code&gt; pointer array of type &lt;code&gt;Vector{String}&lt;/code&gt; to an argument of type &lt;code&gt;Ptr{Ptr{Cchar}}&lt;/code&gt;.</source>
          <target state="translated">eltypeのアレイ場合 &lt;code&gt;Ptr{T}&lt;/code&gt; ように渡される &lt;code&gt;Ptr{Ptr{T}}&lt;/code&gt; 引数、&lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt; &lt;code&gt;Base.cconvert&lt;/code&gt; は&lt;/a&gt;そのによって置き換え各要素と最初にするために、アレイのヌル終了コピーを試みる&lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt; &lt;code&gt;Base.cconvert&lt;/code&gt; の&lt;/a&gt;バージョン。これにより、たとえば、 &lt;code&gt;Vector{String}&lt;/code&gt; 型の &lt;code&gt;argv&lt;/code&gt; ポインター配列を &lt;code&gt;Ptr{Ptr{Cchar}}&lt;/code&gt; 型の引数に渡すことができます。</target>
        </trans-unit>
        <trans-unit id="8aa768f627a40c9d0913fe21e857ab82ce9b4abc" translate="yes" xml:space="preserve">
          <source>If any conflicts arise which cannot be automatically resolved, the rebase will abort, leaving the repository and working tree in its original state, and the function will throw a &lt;code&gt;GitError&lt;/code&gt;. This is roughly equivalent to the following command line statement:</source>
          <target state="translated">自動的に解決できない競合が発生した場合、リベースは中止され、リポジトリと作業ツリーは元の状態のままになり、関数は &lt;code&gt;GitError&lt;/code&gt; をスローします。これは、次のコマンドラインステートメントとほぼ同じです。</target>
        </trans-unit>
        <trans-unit id="cb2726b6f11cf6d744cc2e0de08cc88e0caae92f" translate="yes" xml:space="preserve">
          <source>If any index &lt;code&gt;I_k&lt;/code&gt; selects more than one location, then the right hand side &lt;code&gt;X&lt;/code&gt; must be an array with the same shape as the result of indexing &lt;code&gt;A[I_1, I_2, ..., I_n]&lt;/code&gt; or a vector with the same number of elements. The value in location &lt;code&gt;I_1[i_1], I_2[i_2], ..., I_n[i_n]&lt;/code&gt; of &lt;code&gt;A&lt;/code&gt; is overwritten with the value &lt;code&gt;X[I_1, I_2, ..., I_n]&lt;/code&gt;, converting if necessary. The element-wise assignment operator &lt;code&gt;.=&lt;/code&gt; may be used to &lt;a href=&quot;#Broadcasting&quot;&gt;broadcast&lt;/a&gt;&lt;code&gt;X&lt;/code&gt; across the selected locations:</source>
          <target state="translated">インデックス &lt;code&gt;I_k&lt;/code&gt; が複数の場所を選択する場合、右側の &lt;code&gt;X&lt;/code&gt; は、インデックス &lt;code&gt;A[I_1, I_2, ..., I_n]&lt;/code&gt; の結果と同じ形状の配列、または同じ数の要素を持つベクトルである必要があります。 。位置の値 &lt;code&gt;I_1[i_1], I_2[i_2], ..., I_n[i_n]&lt;/code&gt; の &lt;code&gt;A&lt;/code&gt; は、値で上書きされる &lt;code&gt;X[I_1, I_2, ..., I_n]&lt;/code&gt; 、必要に応じて変換します。要素ごとの代入演算子 &lt;code&gt;.=&lt;/code&gt; を使用して、選択した場所に &lt;code&gt;X&lt;/code&gt; を&lt;a href=&quot;#Broadcasting&quot;&gt;ブロードキャスト&lt;/a&gt;できます。</target>
        </trans-unit>
        <trans-unit id="d387af77f5db6a955f974f865de51228d37bd15f" translate="yes" xml:space="preserve">
          <source>If any index &lt;code&gt;I_k&lt;/code&gt; selects more than one location, then the right hand side &lt;code&gt;X&lt;/code&gt; must be an array with the same shape as the result of indexing &lt;code&gt;A[I_1, I_2, ..., I_n]&lt;/code&gt; or a vector with the same number of elements. The value in location &lt;code&gt;I_1[i_1], I_2[i_2], ..., I_n[i_n]&lt;/code&gt; of &lt;code&gt;A&lt;/code&gt; is overwritten with the value &lt;code&gt;X[I_1, I_2, ..., I_n]&lt;/code&gt;, converting if necessary. The element-wise assignment operator &lt;code&gt;.=&lt;/code&gt; may be used to &lt;a href=&quot;#Broadcasting-1&quot;&gt;broadcast&lt;/a&gt;&lt;code&gt;X&lt;/code&gt; across the selected locations:</source>
          <target state="translated">インデックス &lt;code&gt;I_k&lt;/code&gt; が複数の場所を選択する場合、右側の &lt;code&gt;X&lt;/code&gt; は、 &lt;code&gt;A[I_1, I_2, ..., I_n]&lt;/code&gt; のインデックス付けの結果と同じ形状の配列、または同じ数の要素を持つベクトルでなければなりません。。位置の値 &lt;code&gt;I_1[i_1], I_2[i_2], ..., I_n[i_n]&lt;/code&gt; の &lt;code&gt;A&lt;/code&gt; は、値で上書きされる &lt;code&gt;X[I_1, I_2, ..., I_n]&lt;/code&gt; 、必要に応じて変換します。要素ごとの代入演算子 &lt;code&gt;.=&lt;/code&gt; を使用して、選択した場所全体に &lt;code&gt;X&lt;/code&gt; を&lt;a href=&quot;#Broadcasting-1&quot;&gt;ブロードキャスト&lt;/a&gt;できます。</target>
        </trans-unit>
        <trans-unit id="a2dae61ea17ea95a5a6582831ba526a24537cb67" translate="yes" xml:space="preserve">
          <source>If any inner constructor method is defined, no default constructor method is provided: it is presumed that you have supplied yourself with all the inner constructors you need. The default constructor is equivalent to writing your own inner constructor method that takes all of the object's fields as parameters (constrained to be of the correct type, if the corresponding field has a type), and passes them to &lt;code&gt;new&lt;/code&gt;, returning the resulting object:</source>
          <target state="translated">内部コンストラクターメソッドが定義されている場合、デフォルトのコンストラクターメソッドは提供されません。必要な内部コンストラクターがすべて提供されていると想定されます。デフォルトのコンストラクターは、オブジェクトのすべてのフィールドをパラメーターとして受け取り（対応するフィールドに型がある場合は、正しい型になるように制約されています）、独自の内部コンストラクターメソッドを作成してそれらを &lt;code&gt;new&lt;/code&gt; に渡し、結果のオブジェクトを返すのと同じです。</target>
        </trans-unit>
        <trans-unit id="e9dbb4d7bac298e185fc7fe07e57c374bc123283" translate="yes" xml:space="preserve">
          <source>If any of these result in success, the path to the source code entry point will be either that result, the relative path from that result plus &lt;code&gt;src/X.jl&lt;/code&gt;; otherwise, there is no path mapping for &lt;code&gt;uuid&lt;/code&gt;. When loading &lt;code&gt;X&lt;/code&gt;, if no source code path is found, the lookup will fail, and the user may be prompted to install the appropriate package version or to take other corrective action (e.g. declaring &lt;code&gt;X&lt;/code&gt; as a dependency).</source>
          <target state="translated">これらのいずれかが成功した場合、ソースコードエントリポイントへのパスは、その結果、その結果からの相対パス、および &lt;code&gt;src/X.jl&lt;/code&gt; のいずれかになります。それ以外の場合、 &lt;code&gt;uuid&lt;/code&gt; のパスマッピングはありません。 &lt;code&gt;X&lt;/code&gt; をロードするときに、ソースコードパスが見つからない場合、検索は失敗し、適切なパッケージバージョンをインストールするか、他の修正アクション（ &lt;code&gt;X&lt;/code&gt; を依存関係として宣言するなど）を実行するように求められる場合があります。</target>
        </trans-unit>
        <trans-unit id="4ddf1789b0cb07d74b04fcfdb8b7aef3cf09d72f" translate="yes" xml:space="preserve">
          <source>If array contains &lt;code&gt;NaN&lt;/code&gt; or &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, the result is also &lt;code&gt;NaN&lt;/code&gt; or &lt;code&gt;missing&lt;/code&gt; (&lt;code&gt;missing&lt;/code&gt; takes precedence if array contains both). Use the &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt;&lt;code&gt;skipmissing&lt;/code&gt;&lt;/a&gt; function to omit &lt;code&gt;missing&lt;/code&gt; entries and compute the standard deviation of non-missing values.</source>
          <target state="translated">アレイが含まれている場合 &lt;code&gt;NaN&lt;/code&gt; または&lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt;た値を、結果でもある &lt;code&gt;NaN&lt;/code&gt; または &lt;code&gt;missing&lt;/code&gt; （ &lt;code&gt;missing&lt;/code&gt; 配列の両方が含まれている場合に優先）。&lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt; &lt;code&gt;skipmissing&lt;/code&gt; &lt;/a&gt;関数を使用して、 &lt;code&gt;missing&lt;/code&gt; エントリを省略し、欠落していない値の標準偏差を計算します。</target>
        </trans-unit>
        <trans-unit id="3a6293b5e98855a8ee42f2bca1bebc73fa339517" translate="yes" xml:space="preserve">
          <source>If array contains &lt;code&gt;NaN&lt;/code&gt; or &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, the result is also &lt;code&gt;NaN&lt;/code&gt; or &lt;code&gt;missing&lt;/code&gt; (&lt;code&gt;missing&lt;/code&gt; takes precedence if array contains both). Use the &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt;&lt;code&gt;skipmissing&lt;/code&gt;&lt;/a&gt; function to omit &lt;code&gt;missing&lt;/code&gt; entries and compute the variance of non-missing values.</source>
          <target state="translated">アレイが含まれている場合 &lt;code&gt;NaN&lt;/code&gt; または&lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt;た値を、結果でもある &lt;code&gt;NaN&lt;/code&gt; または &lt;code&gt;missing&lt;/code&gt; （ &lt;code&gt;missing&lt;/code&gt; 配列の両方が含まれている場合に優先）。&lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt; &lt;code&gt;skipmissing&lt;/code&gt; &lt;/a&gt;関数を使用して、 &lt;code&gt;missing&lt;/code&gt; エントリを省略し、欠落していない値の分散を計算します。</target>
        </trans-unit>
        <trans-unit id="38e45e26639753f801787edbbd58523b34871d79" translate="yes" xml:space="preserve">
          <source>If at least one argument is a tuple and all others are scalars or zero-dimensional arrays, it returns a tuple.</source>
          <target state="translated">少なくとも1つの引数がタプルで、他のすべての引数がスカラか0次元配列である場合、タプルを返します。</target>
        </trans-unit>
        <trans-unit id="186a2528019c2b28f2ac036bd36737c001f4c334" translate="yes" xml:space="preserve">
          <source>If called with the optional &lt;code&gt;stream&lt;/code&gt; argument, then returns &lt;code&gt;stream&lt;/code&gt; itself.</source>
          <target state="translated">オプションの &lt;code&gt;stream&lt;/code&gt; 引数を指定して呼び出された場合、 &lt;code&gt;stream&lt;/code&gt; 自体を返します。</target>
        </trans-unit>
        <trans-unit id="c2dc6a2dba2346f86620a63b3cfed83cd90e27f4" translate="yes" xml:space="preserve">
          <source>If captured variables are used in a performance-critical section of the code, then the following tips help ensure that their use is performant. First, if it is known that a captured variable does not change its type, then this can be declared explicitly with a type annotation (on the variable, not the right-hand side):</source>
          <target state="translated">キャプチャされた変数がコードのパフォーマンスが重要な部分で使用される場合、以下のヒントは、その使用がパフォーマンスの高いものであることを保証するのに役立ちます。まず、キャプチャされた変数がその型を変更しないことがわかっている場合、型アノテーションを使って明示的に宣言することができます(右辺ではなく変数の上で)。</target>
        </trans-unit>
        <trans-unit id="1a5d4d133718a06af974dc91ca305c022dd4e098" translate="yes" xml:space="preserve">
          <source>If field types are specified, the arguments are converted. Otherwise the types of the arguments are used directly.</source>
          <target state="translated">フィールド型が指定されている場合、引数は変換されます。それ以外の場合は、引数の型が直接使用されます。</target>
        </trans-unit>
        <trans-unit id="8f773999b3dbcf00b06936dfadd297798081b077" translate="yes" xml:space="preserve">
          <source>If instead you want to specialize on the destination type &lt;code&gt;DestType&lt;/code&gt; without specializing on &lt;code&gt;DestStyle&lt;/code&gt;, then you should define a method with the following signature:</source>
          <target state="translated">あなたが先の型に特化したい場合は代わりに &lt;code&gt;DestType&lt;/code&gt; に特化せず &lt;code&gt;DestStyle&lt;/code&gt; 、その後、次のシグネチャを持つメソッドを定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="861e841404a73546cfbc58b3413de786fc3740a2" translate="yes" xml:space="preserve">
          <source>If it does not have a project file, it can import any top-level package&amp;mdash;i.e. the same packages that can be loaded in &lt;code&gt;Main&lt;/code&gt; or the REPL.</source>
          <target state="translated">プロジェクトファイルがない場合は、トップレベルのパッケージ、つまり &lt;code&gt;Main&lt;/code&gt; またはREPLにロードできる同じパッケージをインポートできます。</target>
        </trans-unit>
        <trans-unit id="4cdc37b95e5e03c0daf7e3854e30ae2e06ab2fbd" translate="yes" xml:space="preserve">
          <source>If it has a &lt;code&gt;git-tree-sha1&lt;/code&gt; entry, compute a deterministic hash function of &lt;code&gt;uuid&lt;/code&gt; and &lt;code&gt;git-tree-sha1&lt;/code&gt;&amp;mdash;call it &lt;code&gt;slug&lt;/code&gt;&amp;mdash;and look for a directory named &lt;code&gt;packages/X/$slug&lt;/code&gt; in each directory in the Julia &lt;code&gt;DEPOT_PATH&lt;/code&gt; global array. Use the first such directory that exists.</source>
          <target state="translated">&lt;code&gt;git-tree-sha1&lt;/code&gt; エントリがある場合は、 &lt;code&gt;uuid&lt;/code&gt; と &lt;code&gt;git-tree-sha1&lt;/code&gt; の確定的ハッシュ関数を計算し（ &lt;code&gt;slug&lt;/code&gt; と呼び &lt;code&gt;packages/X/$slug&lt;/code&gt; 、Julia &lt;code&gt;DEPOT_PATH&lt;/code&gt; グローバル配列の各ディレクトリでpackages / X / $ slugという名前のディレクトリを探します。。存在する最初のそのようなディレクトリを使用します。</target>
        </trans-unit>
        <trans-unit id="cd1241924f2c661cd879945fa2b395e0b0c5bf1c" translate="yes" xml:space="preserve">
          <source>If it has a &lt;code&gt;path&lt;/code&gt; entry, use that path (relative to the directory containing the manifest file).</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; エントリがある場合は、そのパスを使用します（マニフェストファイルを含むディレクトリからの相対パス）。</target>
        </trans-unit>
        <trans-unit id="ecfbca60e91ee74286b0eaf619c2ce8c59e2470c" translate="yes" xml:space="preserve">
          <source>If it has a project file, it can only import those packages which are identified in the &lt;code&gt;[deps]&lt;/code&gt; section of the project file.</source>
          <target state="translated">プロジェクトファイルがある場合は、プロジェクトファイルの &lt;code&gt;[deps]&lt;/code&gt; セクションで識別されるパッケージのみをインポートできます。</target>
        </trans-unit>
        <trans-unit id="d73050aa6cb9e92d8510b86ef26b845581d55552" translate="yes" xml:space="preserve">
          <source>If it is required to hold the pointer to a variable between functions (or block scopes), then it is not possible to use &lt;code&gt;JL_GC_PUSH*&lt;/code&gt;. In this case, it is necessary to create and keep a reference to the variable in the Julia global scope. One simple way to accomplish this is to use a global &lt;code&gt;IdDict&lt;/code&gt; that will hold the references, avoiding deallocation by the GC. However, this method will only work properly with mutable types.</source>
          <target state="translated">関数（またはブロックスコープ）間で変数へのポインターを保持する必要がある場合、 &lt;code&gt;JL_GC_PUSH*&lt;/code&gt; を使用することはできません。この場合、Juliaグローバルスコープで変数への参照を作成して保持する必要があります。これを行う簡単な方法の1つは、GCによる割り当て解除を回避し、参照を保持するグローバル &lt;code&gt;IdDict&lt;/code&gt; を使用することです。ただし、このメソッドは変更可能な型でのみ正しく機能します。</target>
        </trans-unit>
        <trans-unit id="473e682023e21d67484bab11333a56f6e24d4e3e" translate="yes" xml:space="preserve">
          <source>If it's the &lt;code&gt;n&lt;/code&gt;th time that &lt;code&gt;jl_gc_collect()&lt;/code&gt; has been called, and &lt;code&gt;n&lt;/code&gt; belongs to the arithmetic sequence represented by &lt;code&gt;$JULIA_GC_ALLOC_PRINT&lt;/code&gt;, then counts for the number of calls to &lt;code&gt;jl_gc_pool_alloc()&lt;/code&gt; and &lt;code&gt;maybe_collect()&lt;/code&gt; are printed.</source>
          <target state="translated">&lt;code&gt;jl_gc_collect()&lt;/code&gt; が呼び出されたのが &lt;code&gt;n&lt;/code&gt; 回目であり、 &lt;code&gt;n&lt;/code&gt; が &lt;code&gt;$JULIA_GC_ALLOC_PRINT&lt;/code&gt; で表される算術シーケンスに属している場合、 &lt;code&gt;jl_gc_pool_alloc()&lt;/code&gt; および &lt;code&gt;maybe_collect()&lt;/code&gt; の呼び出し回数のカウントが出力されます。</target>
        </trans-unit>
        <trans-unit id="130d982e40fa648e81bf69006602371d8efc3765" translate="yes" xml:space="preserve">
          <source>If it's the &lt;code&gt;n&lt;/code&gt;th time that &lt;code&gt;jl_gc_pool_alloc()&lt;/code&gt; has been called, and &lt;code&gt;n&lt;/code&gt; belongs to the arithmetic sequence represented by &lt;code&gt;$JULIA_GC_ALLOC_POOL&lt;/code&gt;, then garbage collection is forced.</source>
          <target state="translated">それはだ場合 &lt;code&gt;n&lt;/code&gt; という回目 &lt;code&gt;jl_gc_pool_alloc()&lt;/code&gt; と呼ばれる、とされている &lt;code&gt;n&lt;/code&gt; によって表される数列に属し &lt;code&gt;$JULIA_GC_ALLOC_POOL&lt;/code&gt; 、その後、ガベージコレクションを強制されます。</target>
        </trans-unit>
        <trans-unit id="40d1d12e4aea313c12b9b3da68ad08e9a0d521e5" translate="yes" xml:space="preserve">
          <source>If it's the &lt;code&gt;n&lt;/code&gt;th time that &lt;code&gt;maybe_collect()&lt;/code&gt; has been called, and &lt;code&gt;n&lt;/code&gt; belongs to the arithmetic sequence represented by &lt;code&gt;$JULIA_GC_ALLOC_OTHER&lt;/code&gt;, then garbage collection is forced.</source>
          <target state="translated">&lt;code&gt;maybe_collect()&lt;/code&gt; が呼び出されたのが &lt;code&gt;n&lt;/code&gt; 回目であり、 &lt;code&gt;n&lt;/code&gt; が &lt;code&gt;$JULIA_GC_ALLOC_OTHER&lt;/code&gt; で表される算術シーケンスに属している場合、ガベージコレクションが強制されます。</target>
        </trans-unit>
        <trans-unit id="74f9655f12c7f5e7ed84cb6e935e104ba2688d1a" translate="yes" xml:space="preserve">
          <source>If keyword &lt;code&gt;supertypes&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, also return arguments with a parent type of &lt;code&gt;typ&lt;/code&gt;, excluding type &lt;code&gt;Any&lt;/code&gt;.</source>
          <target state="translated">キーワード &lt;code&gt;supertypes&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; の場合、タイプ &lt;code&gt;Any&lt;/code&gt; を除く、親タイプ &lt;code&gt;typ&lt;/code&gt; の引数も返します。</target>
        </trans-unit>
        <trans-unit id="bc696527340f0e0e085e98638a1e2d12825b4024" translate="yes" xml:space="preserve">
          <source>If memory usage is your concern, you can always replace objects with ones that consume less memory. For example, if &lt;code&gt;A&lt;/code&gt; is a gigabyte-sized array that you no longer need, you can free the memory with &lt;code&gt;A = nothing&lt;/code&gt;. The memory will be released the next time the garbage collector runs; you can force this to happen with &lt;a href=&quot;../../base/base/index#Base.GC.gc&quot;&gt;&lt;code&gt;gc()&lt;/code&gt;&lt;/a&gt;. Moreover, an attempt to use &lt;code&gt;A&lt;/code&gt; will likely result in an error, because most methods are not defined on type &lt;code&gt;Nothing&lt;/code&gt;.</source>
          <target state="translated">メモリ使用量が気になる場合は、いつでもオブジェクトをより少ないメモリを消費するオブジェクトに置き換えることができます。たとえば、 &lt;code&gt;A&lt;/code&gt; が不要になったギガバイトサイズの配列である場合、 &lt;code&gt;A = nothing&lt;/code&gt; メモリを解放できます。メモリは、次にガベージコレクタが実行されるときに解放されます。これを&lt;a href=&quot;../../base/base/index#Base.GC.gc&quot;&gt; &lt;code&gt;gc()&lt;/code&gt; &lt;/a&gt;で強制的に実行できます。さらに、ほとんどのメソッドはタイプ &lt;code&gt;Nothing&lt;/code&gt; で定義されていないため、 &lt;code&gt;A&lt;/code&gt; を使用しようとするとエラーが発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="5d311a5ead70c39f70d69a25fb13adf9b0a2959d" translate="yes" xml:space="preserve">
          <source>If much of your run time is spent executing a particular line of code, this line will show up frequently in the set of all backtraces. In other words, the &quot;cost&quot; of a given line&amp;ndash;or really, the cost of the sequence of function calls up to and including this line&amp;ndash;is proportional to how often it appears in the set of all backtraces.</source>
          <target state="translated">ランタイムの多くが特定のコード行の実行に費やされている場合、この行はすべてのバックトレースのセットで頻繁に表示されます。つまり、特定の行の「コスト」、または実際には、この行までの一連の関数呼び出しのコストは、すべてのバックトレースのセットに出現する頻度に比例します。</target>
        </trans-unit>
        <trans-unit id="99791a8f1a9660eaeaa9f5b9e831b943f3ed9006" translate="yes" xml:space="preserve">
          <source>If needed, the sorting algorithm can be chosen:</source>
          <target state="translated">必要に応じて、ソートアルゴリズムを選択することができます。</target>
        </trans-unit>
        <trans-unit id="4223679e9c9b3c609f6bfb56a1e1db206adba7ec" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;type&lt;/code&gt; argument is specified, the default is &lt;code&gt;Vector{UInt8}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; 引数が指定されていない場合、デフォルトは &lt;code&gt;Vector{UInt8}&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="dfa8e1861fd13b4e706313c90dcab6ea83fe0c35" translate="yes" xml:space="preserve">
          <source>If no argument is passed, the task blocks for an undefined period. A task can only be restarted by an explicit call to &lt;a href=&quot;#Base.schedule&quot;&gt;&lt;code&gt;schedule&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Base.yieldto&quot;&gt;&lt;code&gt;yieldto&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">引数が渡されない場合、タスクは未定義の期間ブロックします。タスクは、&lt;a href=&quot;#Base.schedule&quot;&gt; &lt;code&gt;schedule&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;#Base.yieldto&quot;&gt; &lt;code&gt;yieldto&lt;/code&gt; の&lt;/a&gt;明示的な呼び出しによってのみ再開できます。</target>
        </trans-unit>
        <trans-unit id="aa0a9f892d2c7e314c83b4254ca8ced8f31ecd25" translate="yes" xml:space="preserve">
          <source>If no custom testset type is given it defaults to creating a &lt;code&gt;DefaultTestSet&lt;/code&gt;. &lt;code&gt;DefaultTestSet&lt;/code&gt; records all the results and, if there are any &lt;code&gt;Fail&lt;/code&gt;s or &lt;code&gt;Error&lt;/code&gt;s, throws an exception at the end of the top-level (non-nested) test set, along with a summary of the test results.</source>
          <target state="translated">カスタムテストセットタイプが指定されていない場合、デフォルトで &lt;code&gt;DefaultTestSet&lt;/code&gt; が作成されます。 &lt;code&gt;DefaultTestSet&lt;/code&gt; はすべての結果を記録し、 &lt;code&gt;Fail&lt;/code&gt; または &lt;code&gt;Error&lt;/code&gt; がある場合は、テスト結果の概要とともに、トップレベル（ネストされていない）テストセットの最後に例外をスローします。</target>
        </trans-unit>
        <trans-unit id="9b7b804c01f85b077652b971d063a65bcf5b1f8e" translate="yes" xml:space="preserve">
          <source>If one of the editor environment variables is set, but no editor entry matches it, the default editor entry is invoked:</source>
          <target state="translated">エディタ環境変数が設定されていて、それにマッチするエディタエントリがない場合、デフォルトのエディタエントリが起動されます。</target>
        </trans-unit>
        <trans-unit id="1e0f744d0d8245436d7c2b792319d69a40debe40" translate="yes" xml:space="preserve">
          <source>If possible, &lt;code&gt;one(x)&lt;/code&gt; returns a value of the same type as &lt;code&gt;x&lt;/code&gt;, and &lt;code&gt;one(T)&lt;/code&gt; returns a value of type &lt;code&gt;T&lt;/code&gt;. However, this may not be the case for types representing dimensionful quantities (e.g. time in days), since the multiplicative identity must be dimensionless. In that case, &lt;code&gt;one(x)&lt;/code&gt; should return an identity value of the same precision (and shape, for matrices) as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">可能な場合、 &lt;code&gt;one(x)&lt;/code&gt; 同じタイプの値を返し &lt;code&gt;x&lt;/code&gt; 、及び &lt;code&gt;one(T)&lt;/code&gt; 式の値を返し &lt;code&gt;T&lt;/code&gt; を。ただし、乗法的恒等式は無次元でなければならないため、これは、次元のある量（日数などの時間）を表す型には当てはまらない場合があります。その場合、 &lt;code&gt;one(x)&lt;/code&gt; として（マトリクスおよび形状）アイデンティティ同じ精度の値を返す必要があり &lt;code&gt;x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fe767ad4883ee037996d5cf486b48b4286df5e71" translate="yes" xml:space="preserve">
          <source>If set to a string that starts with the case-insensitive substring &lt;code&gt;&quot;infinite&quot;&lt;/code&gt;, then spinning threads never sleep. Otherwise, &lt;code&gt;$JULIA_THREAD_SLEEP_THRESHOLD&lt;/code&gt; is interpreted as an unsigned 64-bit integer (&lt;code&gt;uint64_t&lt;/code&gt;) and gives, in nanoseconds, the amount of time after which spinning threads should sleep.</source>
          <target state="translated">大文字と小文字を区別しない部分文字列 &lt;code&gt;&quot;infinite&quot;&lt;/code&gt; で始まる文字列に設定すると、回転しているスレッドがスリープ状態になることはありません。それ以外の場合、 &lt;code&gt;$JULIA_THREAD_SLEEP_THRESHOLD&lt;/code&gt; は符号なし64ビット整数（ &lt;code&gt;uint64_t&lt;/code&gt; ）として解釈され、スピンするスレッドがスリープするまでの時間をナノ秒単位で示します。</target>
        </trans-unit>
        <trans-unit id="20e80c59100f13ca7e73369cbf1cacf7e59c1aa3" translate="yes" xml:space="preserve">
          <source>If set to anything besides &lt;code&gt;0&lt;/code&gt;, then Julia's thread policy is consistent with running on a dedicated machine: the master thread is on proc 0, and threads are affinitized. Otherwise, Julia lets the operating system handle thread policy.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; 以外の値に設定すると、Juliaのスレッドポリシーは専用マシンでの実行と一致します。マスタースレッドはproc 0にあり、スレッドはアフィニティ化されます。それ以外の場合、Juliaはオペレーティングシステムにスレッドポリシーを処理させます。</target>
        </trans-unit>
        <trans-unit id="f40c9b9b4bbc428bc99a8f3b50c7542418d6c605" translate="yes" xml:space="preserve">
          <source>If set to anything besides &lt;code&gt;0&lt;/code&gt;, then the Julia garbage collector never performs &quot;quick sweeps&quot; of memory.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; 以外に設定すると、Juliaガベージコレクターはメモリの「クイックスイープ」を実行しません。</target>
        </trans-unit>
        <trans-unit id="eb0219b86b58bf1246d63c4e45daa90f20eb81c3" translate="yes" xml:space="preserve">
          <source>If set to anything besides &lt;code&gt;0&lt;/code&gt;, then the Julia garbage collector will wait for a debugger to attach instead of aborting whenever there's a critical error.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; 以外の値に設定すると、Juliaガベージコレクターは、重大なエラーが発生するたびに中止するのではなく、デバッガーの接続を待機します。</target>
        </trans-unit>
        <trans-unit id="1ba30fe7de8eb6c5eb6e36c3ca16b929b1d23810" translate="yes" xml:space="preserve">
          <source>If set to anything besides &lt;code&gt;0&lt;/code&gt;, then the compiler will create and register an event listener for just-in-time (JIT) profiling.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; 以外の値に設定すると、コンパイラーはジャストインタイム（JIT）プロファイリング用のイベントリスナーを作成して登録します。</target>
        </trans-unit>
        <trans-unit id="3b0cd4807865348218a8157872f2d19ba8cef0a0" translate="yes" xml:space="preserve">
          <source>If set, then Julia prints detailed information about the cache in the loading process of &lt;a href=&quot;../../base/base/index#Base.require&quot;&gt;&lt;code&gt;Base.require&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">設定されている場合、Juliaは&lt;a href=&quot;../../base/base/index#Base.require&quot;&gt; &lt;code&gt;Base.require&lt;/code&gt; の&lt;/a&gt;ロードプロセスでキャッシュに関する詳細情報を出力します。</target>
        </trans-unit>
        <trans-unit id="31ed13caeaa2adf17adcff6b38e069bb43cc30cf" translate="yes" xml:space="preserve">
          <source>If set, these environment variables take strings that optionally start with the character &lt;code&gt;'r'&lt;/code&gt;, followed by a string interpolation of a colon-separated list of three signed 64-bit integers (&lt;code&gt;int64_t&lt;/code&gt;). This triple of integers &lt;code&gt;a:b:c&lt;/code&gt; represents the arithmetic sequence &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;a + b&lt;/code&gt;, &lt;code&gt;a + 2*b&lt;/code&gt;, ... &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">設定されている場合、これらの環境変数は、オプションで文字 &lt;code&gt;'r'&lt;/code&gt; で始まり、その後にコロンで区切られた3つの符号付き64ビット整数のリストの文字列補間（ &lt;code&gt;int64_t&lt;/code&gt; ）が続く文字列を取ります。この整数の3つ &lt;code&gt;a:b:c&lt;/code&gt; は、算術シーケンス &lt;code&gt;a&lt;/code&gt; 、 &lt;code&gt;a + b&lt;/code&gt; 、 &lt;code&gt;a + 2*b&lt;/code&gt; 、... &lt;code&gt;c&lt;/code&gt; を表します。</target>
        </trans-unit>
        <trans-unit id="24ec6755ec5d15a629cdab4809712a90cbd8c460" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; environment variable is already set, its old value will be prepended with &lt;code&gt;/foo/bar&lt;/code&gt;. On the other hand, if &lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; is not set, then it will be set to &lt;code&gt;/foo/bar:&lt;/code&gt; which will have the effect of prepending &lt;code&gt;/foo/bar&lt;/code&gt; to the default depot path. If &lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; is set to the empty string, it expands to an empty &lt;code&gt;DEPOT_PATH&lt;/code&gt; array. In other words, the empty string is interpreted as a zero-element array, not a one-element array of the empty string. This behavior was chosen so that it would be possible to set an empty depot path via the environment variable. If you want the default depot path, either unset the environment variable or if it must have a value, set it to the string &lt;code&gt;:&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; の環境変数がすでに設定され、その古い値が前に付加されます &lt;code&gt;/foo/bar&lt;/code&gt; 。一方、 &lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; が設定されていない場合は、 &lt;code&gt;/foo/bar:&lt;/code&gt; に設定されます。これにより、 &lt;code&gt;/foo/bar&lt;/code&gt; がデフォルトのデポパスの前に追加されます。 &lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; が空の文字列に設定されている場合、空の &lt;code&gt;DEPOT_PATH&lt;/code&gt; に展開されますアレイ。つまり、空の文字列は、空の文字列の1要素の配列ではなく、0要素の配列として解釈されます。この動作は、環境変数を介して空のデポパスを設定できるようにするために選択されました。デフォルトデポのパスをしたい場合は、環境変数の設定を解除するか、値を持たなければならないのいずれかの場合、文字列に設定 &lt;code&gt;:&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="951a284bb764079dcd311388a60d7dc6fdec988b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JULIA_DIR&lt;/code&gt; environment variable hasn't been setup, add it using the System panel before starting Visual Studio. The &lt;code&gt;bin&lt;/code&gt; folder under JULIA_DIR should be on the system PATH.</source>
          <target state="translated">&lt;code&gt;JULIA_DIR&lt;/code&gt; 環境変数が設定されていない場合は、Visual Studioを起動する前に、システムパネルを使用して追加してください。JULIA_DIRの下の &lt;code&gt;bin&lt;/code&gt; フォルダーは、システムPATH上にある必要があります。</target>
        </trans-unit>
        <trans-unit id="17b0935fee49a1bcd1eec16c0060a0a58dff07ff" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; environment variable is already set, its old value will be prepended with &lt;code&gt;/foo/bar&lt;/code&gt;. On the other hand, if &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; is not set, then it will be set to &lt;code&gt;/foo/bar:&lt;/code&gt; which will expand to a &lt;code&gt;LOAD_PATH&lt;/code&gt; value of &lt;code&gt;[&quot;/foo/bar&quot;, &quot;@&quot;, &quot;@v#.#&quot;, &quot;@stdlib&quot;]&lt;/code&gt;. If &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; is set to the empty string, it expands to an empty &lt;code&gt;LOAD_PATH&lt;/code&gt; array. In other words, the empty string is interpreted as a zero-element array, not a one-element array of the empty string. This behavior was chosen so that it would be possible to set an empty load path via the environment variable. If you want the default load path, either unset the environment variable or if it must have a value, set it to the string &lt;code&gt;:&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; の環境変数がすでに設定され、その古い値が前に付加されます &lt;code&gt;/foo/bar&lt;/code&gt; 。一方、 &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; が設定されていない場合は、 &lt;code&gt;/foo/bar:&lt;/code&gt; に設定され、 &lt;code&gt;[&quot;/foo/bar&quot;, &quot;@&quot;, &quot;@v#.#&quot;, &quot;@stdlib&quot;]&lt;/code&gt; &lt;code&gt;LOAD_PATH&lt;/code&gt; 値に展開されます。 &quot;@stdlib&quot;]。 &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; が空の文字列に設定されている場合、空の &lt;code&gt;LOAD_PATH&lt;/code&gt; に展開されますアレイ。つまり、空の文字列は、空の文字列の1要素の配列ではなく、0要素の配列として解釈されます。この動作は、環境変数を介して空のロードパスを設定できるように選択されています。デフォルトロードパスをしたい、どちらかそれは価値を持たなければならない場合は、環境変数の設定を解除または場合は、文字列に設定 &lt;code&gt;:&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c31f515fa1981bd1d01e28ffd032994e4003fc1e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;digits&lt;/code&gt; keyword argument is provided, it rounds to the specified number of digits after the decimal place (or before if negative), in base &lt;code&gt;base&lt;/code&gt;.</source>
          <target state="translated">場合は &lt;code&gt;digits&lt;/code&gt; キーワード引数が提供され、それがベースで、小数点以下の位の後（または負の場合は前）に指定した桁数に丸め &lt;code&gt;base&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f504c38da450ab2719c1e9cd12d8dd34afd33e92" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;optimize&lt;/code&gt; keyword is unset, the code will be shown before LLVM optimizations. All metadata and dbg.* calls are removed from the printed bitcode. For the full IR, set the &lt;code&gt;raw&lt;/code&gt; keyword to true. To dump the entire module that encapsulates the function (with declarations), set the &lt;code&gt;dump_module&lt;/code&gt; keyword to true. Keyword argument &lt;code&gt;debuginfo&lt;/code&gt; may be one of source (default) or none, to specify the verbosity of code comments.</source>
          <target state="translated">&lt;code&gt;optimize&lt;/code&gt; キーワードが設定されていない場合、コードはLLVM最適化の前に表示されます。すべてのメタデータとdbg。*呼び出しは、出力されたビットコードから削除されます。完全なIRの場合、 &lt;code&gt;raw&lt;/code&gt; キーワードをtrueに設定します。関数（宣言付き）をカプセル化するモジュール全体をダンプするには、 &lt;code&gt;dump_module&lt;/code&gt; キーワードをtrueに設定します。キーワード引数 &lt;code&gt;debuginfo&lt;/code&gt; は、ソース（デフォルト）またはnoneのいずれかで、コードコメントの詳細度を指定します。</target>
        </trans-unit>
        <trans-unit id="383ecf21766e01ab864dfe9bc7ce841c588d3356" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;sigdigits&lt;/code&gt; keyword argument is provided, it rounds to the specified number of significant digits, in base &lt;code&gt;base&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;sigdigits&lt;/code&gt; キーワード引数が提供され、それがベースで、指定した有効桁数に丸め &lt;code&gt;base&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cee1b7494eb88d56f5f87336c27b832a3eac177f" translate="yes" xml:space="preserve">
          <source>If the C wrapper never expects the user to pass pointers to memory managed by Julia, then using &lt;code&gt;p::Ptr{gsl_permutation}&lt;/code&gt; for the method signature of the wrapper and similarly in the &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; is also acceptable.</source>
          <target state="translated">CラッパーがJuliaが管理するメモリーへのポインターをユーザーに渡すことを決して期待しない場合は、ラッパーのメソッドシグニチャーに &lt;code&gt;p::Ptr{gsl_permutation}&lt;/code&gt; を使用し、同様に&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt;でも使用できます。</target>
        </trans-unit>
        <trans-unit id="e69c1bb25c07d7be2be84b2aa57348cae51e4053" translate="yes" xml:space="preserve">
          <source>If the above example source is saved in the file &lt;code&gt;embed_example.c&lt;/code&gt;, then the following command will compile it into a running program on Linux and Windows (MSYS2 environment), or if on OS/X, then substitute &lt;code&gt;clang&lt;/code&gt; for &lt;code&gt;gcc&lt;/code&gt;.:</source>
          <target state="translated">上記のサンプルソースがファイル &lt;code&gt;embed_example.c&lt;/code&gt; に保存されている場合、次のコマンドはLinuxおよびWindows（MSYS2環境）で実行中のプログラムにコンパイルするか、OS / Xの場合は &lt;code&gt;gcc&lt;/code&gt; を &lt;code&gt;clang&lt;/code&gt; に置き換えます。</target>
        </trans-unit>
        <trans-unit id="9e156941127d94f84d815e5639eaa0e64bcbc457" translate="yes" xml:space="preserve">
          <source>If the above is not the case and the project file has a corresponding manifest file and the manifest contains a stanza matching &lt;code&gt;uuid&lt;/code&gt; then:</source>
          <target state="translated">上記が該当せず、プロジェクトファイルに対応するマニフェストファイルがあり、マニフェストに &lt;code&gt;uuid&lt;/code&gt; に一致するスタンザが含まれている場合：</target>
        </trans-unit>
        <trans-unit id="9f8fd643e0107bc4fc2c8bed2be168d68373f53a" translate="yes" xml:space="preserve">
          <source>If the alias is documented and not the real definition then the docsystem (&lt;code&gt;?&lt;/code&gt; mode) will not return the docstring attached to the alias when the real definition is searched for.</source>
          <target state="translated">実際の定義ではなくエイリアスがドキュメント化されている場合、docsystem（ &lt;code&gt;?&lt;/code&gt; モード）は、実際の定義が検索されたときにエイリアスにアタッチされたdocstringを返しません。</target>
        </trans-unit>
        <trans-unit id="f3fd8dba5118a65c9f036f4528fd62b5f0cc2628" translate="yes" xml:space="preserve">
          <source>If the argument &lt;code&gt;Future&lt;/code&gt; is owned by a different node, this call will block to wait for the answer. It is recommended to wait for &lt;code&gt;rr&lt;/code&gt; in a separate task instead or to use a local &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; as a proxy:</source>
          <target state="translated">引数 &lt;code&gt;Future&lt;/code&gt; が別のノードによって所有されている場合、この呼び出しはブロックされて応答を待ちます。代わりに別のタスクで &lt;code&gt;rr&lt;/code&gt; を待つか、ローカル&lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt;をプロキシとして使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="a730ef6e1a231827c433cc4447592ea8e3ba9efc" translate="yes" xml:space="preserve">
          <source>If the arguments inside the square brackets are separated by semicolons (&lt;code&gt;;&lt;/code&gt;) or newlines instead of commas, then their contents are &lt;em&gt;vertically concatenated&lt;/em&gt; together instead of the arguments being used as elements themselves.</source>
          <target state="translated">角括弧内の引数がコンマではなくセミコロン（ &lt;code&gt;;&lt;/code&gt; ）または改行で区切られている場合、引数自体が要素として使用されるのではなく、それらの内容が&lt;em&gt;垂直方向に連結&lt;/em&gt;されます。</target>
        </trans-unit>
        <trans-unit id="5145bb0b73803c7679be17ccbd9728f2cf20e73d" translate="yes" xml:space="preserve">
          <source>If the condition could not be evaluated because an exception was thrown, which occurs in this case because &lt;code&gt;length&lt;/code&gt; is not defined for symbols, an &lt;code&gt;Error&lt;/code&gt; object is returned and an exception is thrown:</source>
          <target state="translated">例外がスローされたために条件を評価できなかった場合（この場合、シンボルに &lt;code&gt;length&lt;/code&gt; が定義されていないために発生します）、 &lt;code&gt;Error&lt;/code&gt; オブジェクトが返され、例外がスローされます。</target>
        </trans-unit>
        <trans-unit id="e94faa3d332e304494043498c5a9abf524bed6e4" translate="yes" xml:space="preserve">
          <source>If the condition expression &lt;code&gt;x &amp;lt; y&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then the corresponding block is evaluated; otherwise the condition expression &lt;code&gt;x &amp;gt; y&lt;/code&gt; is evaluated, and if it is &lt;code&gt;true&lt;/code&gt;, the corresponding block is evaluated; if neither expression is true, the &lt;code&gt;else&lt;/code&gt; block is evaluated. Here it is in action:</source>
          <target state="translated">条件式 &lt;code&gt;x &amp;lt; y&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; の場合、対応するブロックが評価されます。そうでない場合、条件式 &lt;code&gt;x &amp;gt; y&lt;/code&gt; が評価され、それが &lt;code&gt;true&lt;/code&gt; の場合、対応するブロックが評価されます。どちらの式もtrueでない場合、 &lt;code&gt;else&lt;/code&gt; ブロックが評価されます。ここでそれは動作しています：</target>
        </trans-unit>
        <trans-unit id="e00b24f52421478ecff61089fe0cac3ea509a829" translate="yes" xml:space="preserve">
          <source>If the condition expression &lt;code&gt;x &amp;lt; y&lt;/code&gt; is true, then the corresponding block is evaluated; otherwise the condition expression &lt;code&gt;x &amp;gt; y&lt;/code&gt; is evaluated, and if it is true, the corresponding block is evaluated; if neither expression is true, the &lt;code&gt;else&lt;/code&gt; block is evaluated. The &lt;code&gt;elseif&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; blocks are optional, and as many &lt;code&gt;elseif&lt;/code&gt; blocks as desired can be used.</source>
          <target state="translated">条件式 &lt;code&gt;x &amp;lt; y&lt;/code&gt; がtrueの場合、対応するブロックが評価されます。それ以外の場合、条件式 &lt;code&gt;x &amp;gt; y&lt;/code&gt; が評価され、trueの場合、対応するブロックが評価されます。どちらの式もtrueでない場合、 &lt;code&gt;else&lt;/code&gt; ブロックが評価されます。 &lt;code&gt;elseif&lt;/code&gt; と &lt;code&gt;else&lt;/code&gt; のブロックは、オプション、および多くのようです &lt;code&gt;elseif&lt;/code&gt; を必要に応じてブロックを使用することができます。</target>
        </trans-unit>
        <trans-unit id="03e22d8ef38f6c3785531b2aa7d1787777d83c8c" translate="yes" xml:space="preserve">
          <source>If the condition is false, then a &lt;code&gt;Fail&lt;/code&gt; is returned and an exception is thrown:</source>
          <target state="translated">条件がfalseの場合、 &lt;code&gt;Fail&lt;/code&gt; が返され、例外がスローされます。</target>
        </trans-unit>
        <trans-unit id="6b3bbdbb81ff4f33d7f44d969bf8034d1606bc1e" translate="yes" xml:space="preserve">
          <source>If the condition is true, a &lt;code&gt;Pass&lt;/code&gt; is returned:</source>
          <target state="translated">条件が真の場合、 &lt;code&gt;Pass&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="cc2105b7ae7cdead96d8521e45a1f5d3d101c4e9" translate="yes" xml:space="preserve">
          <source>If the expression &lt;code&gt;x &amp;lt; y&lt;/code&gt; is true, the entire ternary operator expression evaluates to the string &lt;code&gt;&quot;less than&quot;&lt;/code&gt; and otherwise it evaluates to the string &lt;code&gt;&quot;not less than&quot;&lt;/code&gt;. The original three-way example requires chaining multiple uses of the ternary operator together:</source>
          <target state="translated">式があれば &lt;code&gt;x &amp;lt; y&lt;/code&gt; 真であり、文字列に全体の三オペレータ発現評価する &lt;code&gt;&quot;less than&quot;&lt;/code&gt; と、それ以外の場合は文字列に評価 &lt;code&gt;&quot;not less than&quot;&lt;/code&gt; 。元の3方向の例では、3項演算子の複数の使用を一緒にチェーンする必要があります。</target>
        </trans-unit>
        <trans-unit id="07cadc79598faa1c956be711a85436f8d736e63e" translate="yes" xml:space="preserve">
          <source>If the file does not exist a new file is created.</source>
          <target state="translated">ファイルが存在しない場合は、新しいファイルが作成されます。</target>
        </trans-unit>
        <trans-unit id="c1992d697b66c6b6347599acbdb8e5fdb9a6621c" translate="yes" xml:space="preserve">
          <source>If the first argument is a single integer &lt;code&gt;n&lt;/code&gt;, then all block rows are assumed to have &lt;code&gt;n&lt;/code&gt; block columns.</source>
          <target state="translated">最初の引数が単一の整数 &lt;code&gt;n&lt;/code&gt; の場合、すべてのブロック行は &lt;code&gt;n&lt;/code&gt; 個のブロック列を持っていると見なされます。</target>
        </trans-unit>
        <trans-unit id="87ae95240cbc769b0a9964dbc95f1267c9ef783f" translate="yes" xml:space="preserve">
          <source>If the index vector &lt;code&gt;ix&lt;/code&gt; is initialized with the indices of &lt;code&gt;v&lt;/code&gt; (or a permutation thereof), &lt;code&gt;initialized&lt;/code&gt; should be set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">インデックスベクトル &lt;code&gt;ix&lt;/code&gt; が &lt;code&gt;v&lt;/code&gt; のインデックス（またはその順列）で &lt;code&gt;initialized&lt;/code&gt; される &lt;code&gt;true&lt;/code&gt; 、initializedはtrueに設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="39c79a9397806971d24321842119edaddb016dad" translate="yes" xml:space="preserve">
          <source>If the input contains &lt;a href=&quot;../base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, return &lt;code&gt;missing&lt;/code&gt; if all non-missing values are &lt;code&gt;false&lt;/code&gt; (or equivalently, if the input contains no &lt;code&gt;true&lt;/code&gt; value), following &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;.</source>
          <target state="translated">入力に&lt;a href=&quot;../base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt;値が含まれている場合、欠損値以外の値がすべて &lt;code&gt;false&lt;/code&gt; の場合（または、入力に &lt;code&gt;true&lt;/code&gt; 値が含まれていない場合）は、&lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;3つの値のロジック&lt;/a&gt;に従って、 &lt;code&gt;missing&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="5db00182f423a4757b1d59390942e088eaf24587" translate="yes" xml:space="preserve">
          <source>If the input contains &lt;a href=&quot;../base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, return &lt;code&gt;missing&lt;/code&gt; if all non-missing values are &lt;code&gt;true&lt;/code&gt; (or equivalently, if the input contains no &lt;code&gt;false&lt;/code&gt; value), following &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;.</source>
          <target state="translated">入力が含まれている場合は&lt;a href=&quot;../base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt;値を返し &lt;code&gt;missing&lt;/code&gt; すべての非欠損値がある場合は &lt;code&gt;true&lt;/code&gt; （または同等の入力は一切含まれていない場合、 &lt;code&gt;false&lt;/code&gt; 値）以下、&lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;3値論理&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8eeb9c03396e664e28a99fc47d48774045eb6d62" translate="yes" xml:space="preserve">
          <source>If the input contains &lt;a href=&quot;base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, return &lt;code&gt;missing&lt;/code&gt; if all non-missing values are &lt;code&gt;false&lt;/code&gt; (or equivalently, if the input contains no &lt;code&gt;true&lt;/code&gt; value), following &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;.</source>
          <target state="translated">入力に&lt;a href=&quot;base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt;値が含まれている場合、欠損値以外の値がすべて &lt;code&gt;false&lt;/code&gt; の場合（または、入力に &lt;code&gt;true&lt;/code&gt; 値が含まれていない場合）は、&lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;3つの値のロジック&lt;/a&gt;に従って、 &lt;code&gt;missing&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="2728419995e95b64eb82cdbd209797e56617a7a2" translate="yes" xml:space="preserve">
          <source>If the input contains &lt;a href=&quot;base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, return &lt;code&gt;missing&lt;/code&gt; if all non-missing values are &lt;code&gt;true&lt;/code&gt; (or equivalently, if the input contains no &lt;code&gt;false&lt;/code&gt; value), following &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;.</source>
          <target state="translated">入力が含まれている場合は&lt;a href=&quot;base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt;値を返し &lt;code&gt;missing&lt;/code&gt; すべての非欠損値がある場合は &lt;code&gt;true&lt;/code&gt; （または同等の入力は一切含まれていない場合、 &lt;code&gt;false&lt;/code&gt; 値）以下、&lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;3値論理&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="43376b031124803be76025ed520e15accd07f21d" translate="yes" xml:space="preserve">
          <source>If the julia program needs to access symbols from the main executable, it may be necessary to add &lt;code&gt;-Wl,--export-dynamic&lt;/code&gt; linker flag at compile time on Linux in addition to the ones generated by &lt;code&gt;julia-config.jl&lt;/code&gt; described below. This is not necessary when compiling a shared library.</source>
          <target state="translated">juliaプログラムがメインの実行可能ファイルからシンボルにアクセスする必要がある場合は、以下で説明する &lt;code&gt;julia-config.jl&lt;/code&gt; によって生成されるものに加えて、Linuxでのコンパイル時に &lt;code&gt;-Wl,--export-dynamic&lt;/code&gt; リンカーフラグを追加する必要がある場合があります。共有ライブラリをコンパイルする場合、これは必要ありません。</target>
        </trans-unit>
        <trans-unit id="a36bc8b8e7c85e66ed4f1f189a3aca52b1c00920" translate="yes" xml:space="preserve">
          <source>If the keyword argument &lt;code&gt;parallel&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;peakflops&lt;/code&gt; is run in parallel on all the worker processors. The flop rate of the entire parallel computer is returned. When running in parallel, only 1 BLAS thread is used. The argument &lt;code&gt;n&lt;/code&gt; still refers to the size of the problem that is solved on each processor.</source>
          <target state="translated">キーワード引数 &lt;code&gt;parallel&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; に設定されている場合、 &lt;code&gt;peakflops&lt;/code&gt; はすべてのワーカープロセッサーで並列に実行されます。並列コンピュータ全体のフロップレートが返されます。並行して実行する場合、1つのBLASスレッドのみが使用されます。引数 &lt;code&gt;n&lt;/code&gt; は、各プロセッサで解決される問題のサイズを引き続き参照します。</target>
        </trans-unit>
        <trans-unit id="8e60aaeb2ffed3f0c824ded63844d08244a81e67" translate="yes" xml:space="preserve">
          <source>If the last component of a path contains a dot, split the path into everything before the dot and everything including and after the dot. Otherwise, return a tuple of the argument unmodified and the empty string.</source>
          <target state="translated">パスの最後の構成要素にドットが含まれている場合、パスをドットの前の全てとドットを含む全てとドットの後の全てに分割します。そうでない場合は、引数の変更されていないタプルと空の文字列を返します。</target>
        </trans-unit>
        <trans-unit id="474f41b19a8b8b1c73bfdf0eee429dd261cef652" translate="yes" xml:space="preserve">
          <source>If the library cannot be found, this method throws an error, unless the keyword argument &lt;code&gt;throw_error&lt;/code&gt; is set to &lt;code&gt;false&lt;/code&gt;, in which case this method returns &lt;code&gt;nothing&lt;/code&gt;.</source>
          <target state="translated">ライブラリが見つからない場合、キーワード引数 &lt;code&gt;throw_error&lt;/code&gt; が &lt;code&gt;false&lt;/code&gt; に設定されていない限り、このメソッドはエラーをスローします。この場合、このメソッドは &lt;code&gt;nothing&lt;/code&gt; 返しません。</target>
        </trans-unit>
        <trans-unit id="87fd4485b83cceeff36ce0886165792add3d72c0" translate="yes" xml:space="preserve">
          <source>If the master process fails to establish a connection with a newly launched worker within 60.0 seconds, the worker treats it as a fatal situation and terminates. This timeout can be controlled via environment variable &lt;code&gt;JULIA_WORKER_TIMEOUT&lt;/code&gt;. The value of &lt;code&gt;JULIA_WORKER_TIMEOUT&lt;/code&gt; on the master process specifies the number of seconds a newly launched worker waits for connection establishment.</source>
          <target state="translated">マスタープロセスが60.0秒以内に新しく起動したワーカーとの接続を確立できない場合、ワーカーはそれを致命的な状況として扱い、終了します。このタイムアウトは、環境変数 &lt;code&gt;JULIA_WORKER_TIMEOUT&lt;/code&gt; を介して制御できます。マスタープロセスの &lt;code&gt;JULIA_WORKER_TIMEOUT&lt;/code&gt; の値は、新しく起動されたワーカーが接続の確立を待機する秒数を指定します。</target>
        </trans-unit>
        <trans-unit id="1862e9ef97d71a1468775f4ed8202c8fd632c055" translate="yes" xml:space="preserve">
          <source>If the memory is already owned by Julia, or is an &lt;code&gt;isbits&lt;/code&gt; type, and is known to be non-null:</source>
          <target state="translated">メモリがJuliaによってすでに所有されているか、 &lt;code&gt;isbits&lt;/code&gt; タイプであり、nullでないことがわかっている場合：</target>
        </trans-unit>
        <trans-unit id="da0b487002a4f8f988224bf9329d865f41bc0778" translate="yes" xml:space="preserve">
          <source>If the memory is owned by C:</source>
          <target state="translated">メモリがCのものであれば</target>
        </trans-unit>
        <trans-unit id="f1a7911f936ea8810a1eaa7a8869f8e6799d2d65" translate="yes" xml:space="preserve">
          <source>If the numerator and denominator of a rational have common factors, they are reduced to lowest terms such that the denominator is non-negative:</source>
          <target state="translated">有理数の分子と分母が共通因子を持つ場合、分母が非負になるように最低項に還元されます。</target>
        </trans-unit>
        <trans-unit id="0a769d477ab736aacb751c850c5686d3d0e58a61" translate="yes" xml:space="preserve">
          <source>If the optional vector of eigenvalues &lt;code&gt;eigvals&lt;/code&gt; is specified, &lt;code&gt;eigvecs&lt;/code&gt; returns the specific corresponding eigenvectors.</source>
          <target state="translated">固有値 &lt;code&gt;eigvals&lt;/code&gt; のオプションのベクトルが指定されている場合、 &lt;code&gt;eigvecs&lt;/code&gt; は特定の対応する固有ベクトルを返します。</target>
        </trans-unit>
        <trans-unit id="0f4dba4502da69dc32bb858b6da003d9801f45e4" translate="yes" xml:space="preserve">
          <source>If the pointer of interest is a plain-data array (primitive type or immutable struct), the function &lt;code&gt;unsafe_wrap(Array, ptr,dims, own = false)&lt;/code&gt; may be more useful. The final parameter should be true if Julia should &quot;take ownership&quot; of the underlying buffer and call &lt;code&gt;free(ptr)&lt;/code&gt; when the returned &lt;code&gt;Array&lt;/code&gt; object is finalized. If the &lt;code&gt;own&lt;/code&gt; parameter is omitted or false, the caller must ensure the buffer remains in existence until all access is complete.</source>
          <target state="translated">対象のポインターがプレーンデータ配列（プリミティブ型または不変の構造体）である場合、関数 &lt;code&gt;unsafe_wrap(Array, ptr,dims, own = false)&lt;/code&gt; 方が便利な場合があります。Juliaが基になるバッファーの「所有権を取得」し、返された &lt;code&gt;Array&lt;/code&gt; オブジェクトがファイナライズされるときに &lt;code&gt;free(ptr)&lt;/code&gt; を呼び出す必要がある場合、最後のパラメーターはtrueである必要があります。場合は &lt;code&gt;own&lt;/code&gt; パラメータを省略またはfalseているすべてのアクセスが完了するまで、呼び出し側が存在し、バッファの遺骨を確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="0a512e781dfe335955a62e8e7a271098861da5ec" translate="yes" xml:space="preserve">
          <source>If the project file in the directory matches &lt;code&gt;uuid&lt;/code&gt; and name &lt;code&gt;X&lt;/code&gt;, then either:</source>
          <target state="translated">ディレクトリ内のプロジェクトファイルが &lt;code&gt;uuid&lt;/code&gt; および名前 &lt;code&gt;X&lt;/code&gt; と一致する場合、次のいずれかです。</target>
        </trans-unit>
        <trans-unit id="bf4eb78a003bcabdcd8e4f19b55a5c4f0ed307f6" translate="yes" xml:space="preserve">
          <source>If the regular expression does not match the given string, &lt;a href=&quot;../../base/strings/index#Base.match&quot;&gt;&lt;code&gt;match&lt;/code&gt;&lt;/a&gt; returns &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt; &amp;ndash; a special value that does not print anything at the interactive prompt. Other than not printing, it is a completely normal value and you can test for it programmatically:</source>
          <target state="translated">正規表現が指定された文字列と&lt;a href=&quot;../../base/strings/index#Base.match&quot;&gt; &lt;code&gt;match&lt;/code&gt; &lt;/a&gt;しない場合、matchは&lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt;返しません &amp;ndash;インタラクティブなプロンプトで何も出力しない特別な値。印刷しないことを除いて、これは完全に通常の値であり、プログラムでテストできます。</target>
        </trans-unit>
        <trans-unit id="ee4c72df00bad1d261a873768e4600ba229c34af" translate="yes" xml:space="preserve">
          <source>If the type were declared &lt;code&gt;mutable&lt;/code&gt;, you could reach in and directly change the field values to violate this invariant. Of course, messing around with an object's internals uninvited is bad practice. You (or someone else) can also provide additional outer constructor methods at any later point, but once a type is declared, there is no way to add more inner constructor methods. Since outer constructor methods can only create objects by calling other constructor methods, ultimately, some inner constructor must be called to create an object. This guarantees that all objects of the declared type must come into existence by a call to one of the inner constructor methods provided with the type, thereby giving some degree of enforcement of a type's invariants.</source>
          <target state="translated">型が &lt;code&gt;mutable&lt;/code&gt; と宣言されている場合は、フィールド値にアクセスして直接変更し、この不変条件に違反する可能性があります。もちろん、招待されていないオブジェクトの内部をいじるのは悪い習慣です。あなた（または他の誰か）は後から追加の外部コンストラクターメソッドを提供することもできますが、型が宣言されると、内部コンストラクターメソッドを追加する方法はありません。外部コンストラクターメソッドは他のコンストラクターメソッドを呼び出すことによってのみオブジェクトを作成できるため、最終的には、オブジェクトを作成するためにいくつかの内部コンストラクターを呼び出す必要があります。これにより、宣言された型のすべてのオブジェクトが、その型で提供される内部コンストラクターメソッドの1つを呼び出すことによって必ず存在するようになるため、型の不変条件がある程度適用されます。</target>
        </trans-unit>
        <trans-unit id="01f0d92fa173f69330393a510ea1e6b5d8ca8533" translate="yes" xml:space="preserve">
          <source>If the value of the environment variable begins with the character &lt;code&gt;'r'&lt;/code&gt;, then the interval between garbage collection events is randomized.</source>
          <target state="translated">環境変数の値が文字 &lt;code&gt;'r'&lt;/code&gt; で始まる場合、ガベージコレクションイベントの間隔はランダム化されます。</target>
        </trans-unit>
        <trans-unit id="820aaeab0441978d6dfdcb42b5456e2d42286bc7" translate="yes" xml:space="preserve">
          <source>If the variable is immutable, then it needs to be wrapped in an equivalent mutable container or, preferably, in a &lt;code&gt;RefValue{Any}&lt;/code&gt; before it is pushed to &lt;code&gt;IdDict&lt;/code&gt;. In this approach, the container has to be created or filled in via C code using, for example, the function &lt;code&gt;jl_new_struct&lt;/code&gt;. If the container is created by &lt;code&gt;jl_call*&lt;/code&gt;, then you will need to reload the pointer to be used in C code.</source>
          <target state="translated">変数が不変の場合、それを &lt;code&gt;IdDict&lt;/code&gt; にプッシュする前に、同等の可変コンテナー、またはできれ &lt;code&gt;RefValue{Any}&lt;/code&gt; にラップする必要があります。このアプローチでは、コンテナーは、例えば関数 &lt;code&gt;jl_new_struct&lt;/code&gt; を使用して、Cコードを介して作成または入力する必要があります。コンテナーが &lt;code&gt;jl_call*&lt;/code&gt; によって作成された場合、Cコードで使用されるポインターを再ロードする必要があります。</target>
        </trans-unit>
        <trans-unit id="fdaae9a23c5ac63bef99dbd5a31ebb51593f593b" translate="yes" xml:space="preserve">
          <source>If these default definitions are not wanted, modules can be defined using the keyword &lt;a href=&quot;../../base/base/index#baremodule&quot;&gt;&lt;code&gt;baremodule&lt;/code&gt;&lt;/a&gt; instead (note: &lt;code&gt;Core&lt;/code&gt; is still imported, as per above). In terms of &lt;code&gt;baremodule&lt;/code&gt;, a standard &lt;code&gt;module&lt;/code&gt; looks like this:</source>
          <target state="translated">これらのデフォルト定義が必要ない場合は、代わりにキーワード&lt;a href=&quot;../../base/base/index#baremodule&quot;&gt; &lt;code&gt;baremodule&lt;/code&gt; &lt;/a&gt;を使用してモジュールを定義できます（注：上記のように、 &lt;code&gt;Core&lt;/code&gt; は引き続きインポートされます）。 &lt;code&gt;baremodule&lt;/code&gt; に関しては、標準 &lt;code&gt;module&lt;/code&gt; は次のようになります。</target>
        </trans-unit>
        <trans-unit id="c97bc8058490cb5b35c86c1a7b0a8b4a5dcbea0d" translate="yes" xml:space="preserve">
          <source>If this example were rewritten to use a &lt;code&gt;for&lt;/code&gt; keyword for each variable, then the output would be different: the second and fourth values would contain &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">この例が各変数に &lt;code&gt;for&lt;/code&gt; キーワードを使用するように書き直された場合、出力は異なります。2番目と4番目の値には &lt;code&gt;0&lt;/code&gt; が含まれます。</target>
        </trans-unit>
        <trans-unit id="38daf5829da47e0525cef7ca98a723264df0b06d" translate="yes" xml:space="preserve">
          <source>If this file refers to a device, the ID of the device it refers to</source>
          <target state="translated">このファイルがデバイスを参照している場合は、参照しているデバイスのID</target>
        </trans-unit>
        <trans-unit id="0d9cafaaf4c7067eb590c8bf606a63edc65e8a80" translate="yes" xml:space="preserve">
          <source>If this is a recursive lock which has been acquired before, decrement an internal counter and return immediately.</source>
          <target state="translated">これが以前に取得した再帰的なロックであれば、内部カウンタをデクリメントしてすぐに戻ります。</target>
        </trans-unit>
        <trans-unit id="63b7f441c98451c302d3c2456a6e97efda6509d1" translate="yes" xml:space="preserve">
          <source>If this is all extremely confusing, try reading &lt;a href=&quot;https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/&quot;&gt;&quot;The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets&quot;&lt;/a&gt;. It's an excellent introduction to Unicode and UTF-8, and may help alleviate some confusion regarding the matter.</source>
          <target state="translated">これがすべて非常に混乱する場合は、&lt;a href=&quot;https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/&quot;&gt;「すべてのソフトウェア開発者の絶対最小&lt;/a&gt;値は絶対に、確実にUnicodeと文字セットについて知っておく必要がある」を読んでみてください。これは、UnicodeとUTF-8の優れた入門書であり、問​​題に関するいくつかの混乱を軽減するのに役立つ場合があります。</target>
        </trans-unit>
        <trans-unit id="3b40c130d40171e44a3b89ef397dcc6ac5ad60b6" translate="yes" xml:space="preserve">
          <source>If unspecified, &lt;code&gt;rmprocs&lt;/code&gt; will wait until all requested &lt;code&gt;pids&lt;/code&gt; are removed.</source>
          <target state="translated">指定されていない場合、 &lt;code&gt;rmprocs&lt;/code&gt; は要求されたすべての &lt;code&gt;pids&lt;/code&gt; が削除されるまで待機します。</target>
        </trans-unit>
        <trans-unit id="7a6ee4e75683acdd450d6763b02459999f504699" translate="yes" xml:space="preserve">
          <source>If we also wanted to test the debug messages, these need to be enabled with the &lt;code&gt;min_level&lt;/code&gt; keyword:</source>
          <target state="translated">デバッグメッセージもテストする場合は、 &lt;code&gt;min_level&lt;/code&gt; キーワードを使用してこれらを有効にする必要があります。</target>
        </trans-unit>
        <trans-unit id="61986d68f0f6799ea1176f1c31636a4efe0c3579" translate="yes" xml:space="preserve">
          <source>If we create &lt;code&gt;SharedArray&lt;/code&gt;s and time these functions, we get the following results (with &lt;code&gt;julia -p 4&lt;/code&gt;):</source>
          <target state="translated">&lt;code&gt;SharedArray&lt;/code&gt; を作成してこれらの関数の時間を計測すると、次の結果が得られます（ &lt;code&gt;julia -p 4&lt;/code&gt; を使用）。</target>
        </trans-unit>
        <trans-unit id="a1227c57ad13fa72c3a7892e71df86ffd4baf6f1" translate="yes" xml:space="preserve">
          <source>If we expect that evaluating an expression &lt;em&gt;should&lt;/em&gt; throw an exception, then we can use &lt;code&gt;@test_throws&lt;/code&gt; to check that this occurs:</source>
          <target state="translated">式を評価すると例外&lt;em&gt;が&lt;/em&gt;スローされると予想される場合は、 &lt;code&gt;@test_throws&lt;/code&gt; を使用して、これが発生することを確認できます。</target>
        </trans-unit>
        <trans-unit id="0245cafc71ed8d5f923ae289b03588ae96f1d3b5" translate="yes" xml:space="preserve">
          <source>If we instead pass &lt;code&gt;x&lt;/code&gt; as an argument to the function it no longer allocates memory (the allocation reported below is due to running the &lt;code&gt;@time&lt;/code&gt; macro in global scope) and is significantly faster after the first call:</source>
          <target state="translated">代わりに &lt;code&gt;x&lt;/code&gt; を引数として関数に渡すと、メモリは割り当てられなくなり（以下に報告されている割り当ては、グローバルスコープで &lt;code&gt;@time&lt;/code&gt; マクロを実行したことが原因です）、最初の呼び出し後の速度が大幅に向上します。</target>
        </trans-unit>
        <trans-unit id="f2aae1a0bcfd34dce76c0f68b8969fc76cde279d" translate="yes" xml:space="preserve">
          <source>If we want it to display instead as &lt;code&gt;3.0 * exp(4.0im)&lt;/code&gt;, we would define the following method to print the object to a given output object &lt;code&gt;io&lt;/code&gt; (representing a file, terminal, buffer, etcetera; see &lt;a href=&quot;../networking-and-streams/index#Networking-and-Streams&quot;&gt;Networking and Streams&lt;/a&gt;):</source>
          <target state="translated">代わりに &lt;code&gt;3.0 * exp(4.0im)&lt;/code&gt; として表示する場合は、次のメソッドを定義して、オブジェクトを特定の出力オブジェクト &lt;code&gt;io&lt;/code&gt; （ファイル、ターミナル、バッファーなどを表します。&lt;a href=&quot;../networking-and-streams/index#Networking-and-Streams&quot;&gt;ネットワークとストリームを&lt;/a&gt;参照）に出力します。</target>
        </trans-unit>
        <trans-unit id="ad5a88256f096da52ec6c3ef7cb82d3f97728f34" translate="yes" xml:space="preserve">
          <source>If we want it to display instead as &lt;code&gt;3.0 * exp(4.0im)&lt;/code&gt;, we would define the following method to print the object to a given output object &lt;code&gt;io&lt;/code&gt; (representing a file, terminal, buffer, etcetera; see &lt;a href=&quot;../networking-and-streams/index#Networking-and-Streams-1&quot;&gt;Networking and Streams&lt;/a&gt;):</source>
          <target state="translated">代わりに &lt;code&gt;3.0 * exp(4.0im)&lt;/code&gt; として表示する場合は、次のメソッドを定義して、オブジェクトを特定の出力オブジェクト &lt;code&gt;io&lt;/code&gt; （ファイル、端末、バッファーなどを表す）に出力します。&lt;a href=&quot;../networking-and-streams/index#Networking-and-Streams-1&quot;&gt;ネットワーキングとストリームを&lt;/a&gt;参照してください）。</target>
        </trans-unit>
        <trans-unit id="a3d5a08a0cd3e04540689d3b049bf572b10229ab" translate="yes" xml:space="preserve">
          <source>If you apply &lt;a href=&quot;../../base/base/index#Base.supertype&quot;&gt;&lt;code&gt;supertype&lt;/code&gt;&lt;/a&gt; to other type objects (or non-type objects), a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt; is raised:</source>
          <target state="translated">あなたが適用された場合は&lt;a href=&quot;../../base/base/index#Base.supertype&quot;&gt; &lt;code&gt;supertype&lt;/code&gt; &lt;/a&gt;他のタイプのオブジェクト（または非型オブジェクト）に、&lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; が&lt;/a&gt;提起されています。</target>
        </trans-unit>
        <trans-unit id="a311e1352bca4f5ac56973ae4e9111089c7fd93d" translate="yes" xml:space="preserve">
          <source>If you are defining a method &quot;cascade&quot; that supplies defaults, be careful about dropping any arguments that correspond to potential defaults. For example, suppose you're writing a digital filtering algorithm and you have a method that handles the edges of the signal by applying padding:</source>
          <target state="translated">デフォルトを提供するメソッド「カスケード」を定義している場合、潜在的なデフォルトに対応する引数を削除することに注意してください。例えば、デジタルフィルタリングアルゴリズムを書いていて、パディングを適用して信号のエッジを処理するメソッドがあるとします。</target>
        </trans-unit>
        <trans-unit id="1ec45be5f3cad18e0598bb550f7ab8781aa51939" translate="yes" xml:space="preserve">
          <source>If you are defining an array type that allows non-traditional indexing (indices that start at something other than 1), you should specialize &lt;code&gt;axes&lt;/code&gt;. You should also specialize &lt;a href=&quot;../../base/arrays/index#Base.similar&quot;&gt;&lt;code&gt;similar&lt;/code&gt;&lt;/a&gt; so that the &lt;code&gt;dims&lt;/code&gt; argument (ordinarily a &lt;code&gt;Dims&lt;/code&gt; size-tuple) can accept &lt;code&gt;AbstractUnitRange&lt;/code&gt; objects, perhaps range-types &lt;code&gt;Ind&lt;/code&gt; of your own design. For more information, see &lt;a href=&quot;https://docs.julialang.org/en/v1.2.0/devdocs/offset-arrays/#man-custom-indices-1&quot;&gt;Arrays with custom indices&lt;/a&gt;.</source>
          <target state="translated">従来とは異なるインデックス付け（1以外のインデックスで始まるインデックス）を許可する配列型を定義している場合は、 &lt;code&gt;axes&lt;/code&gt; を特殊化する必要があります。 &lt;code&gt;dims&lt;/code&gt; 引数（通常は &lt;code&gt;Dims&lt;/code&gt; のサイズタプル）が &lt;code&gt;AbstractUnitRange&lt;/code&gt; オブジェクト（おそらく、独自の設計の範囲型 &lt;code&gt;Ind&lt;/code&gt; ）を受け入れることができるように、&lt;a href=&quot;../../base/arrays/index#Base.similar&quot;&gt; &lt;code&gt;similar&lt;/code&gt; &lt;/a&gt;も特化する必要があります。詳細については、「&lt;a href=&quot;https://docs.julialang.org/en/v1.2.0/devdocs/offset-arrays/#man-custom-indices-1&quot;&gt;カスタムインデックスを持つ配列」を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="24ace472fa970e0efc7d5e99433a90005d823df2" translate="yes" xml:space="preserve">
          <source>If you are defining an array type that allows non-traditional indexing (indices that start at something other than 1), you should specialize &lt;code&gt;axes&lt;/code&gt;. You should also specialize &lt;a href=&quot;../../base/arrays/index#Base.similar&quot;&gt;&lt;code&gt;similar&lt;/code&gt;&lt;/a&gt; so that the &lt;code&gt;dims&lt;/code&gt; argument (ordinarily a &lt;code&gt;Dims&lt;/code&gt; size-tuple) can accept &lt;code&gt;AbstractUnitRange&lt;/code&gt; objects, perhaps range-types &lt;code&gt;Ind&lt;/code&gt; of your own design. For more information, see &lt;a href=&quot;https://docs.julialang.org/en/v1.5.3/devdocs/offset-arrays/#man-custom-indices&quot;&gt;Arrays with custom indices&lt;/a&gt;.</source>
          <target state="translated">従来とは異なるインデックス付け（1以外で始まるインデックス）を許可する配列型を定義している場合は、 &lt;code&gt;axes&lt;/code&gt; を特殊化する必要があります。また、 &lt;code&gt;dims&lt;/code&gt; 引数（通常は &lt;code&gt;Dims&lt;/code&gt; サイズタプル）が &lt;code&gt;AbstractUnitRange&lt;/code&gt; オブジェクト（おそらく独自の設計の範囲タイプ &lt;code&gt;Ind&lt;/code&gt; ）を受け入れることができるように、&lt;a href=&quot;../../base/arrays/index#Base.similar&quot;&gt; &lt;code&gt;similar&lt;/code&gt; &lt;/a&gt;特化する必要があります。詳細については&lt;a href=&quot;https://docs.julialang.org/en/v1.5.3/devdocs/offset-arrays/#man-custom-indices&quot;&gt;、カスタムインデックス&lt;/a&gt;を使用した配列を参照してください。</target>
        </trans-unit>
        <trans-unit id="e74f29b3463d83a18c14379e83918c00f3cf63aa" translate="yes" xml:space="preserve">
          <source>If you are ever stuck, you can ask &lt;code&gt;Pkg&lt;/code&gt; for help:</source>
          <target state="translated">行き詰まっている場合は、 &lt;code&gt;Pkg&lt;/code&gt; に助けを求めることができます。</target>
        </trans-unit>
        <trans-unit id="8735c4e810f6e4e3ffda27e1b3f1ab39f60104c6" translate="yes" xml:space="preserve">
          <source>If you are using the Julia C API from a language that supports exceptions (e.g. Python, C#, C++), it makes sense to wrap each call into &lt;code&gt;libjulia&lt;/code&gt; with a function that checks whether an exception was thrown, and then rethrows the exception in the host language.</source>
          <target state="translated">例外をサポートする言語（Python、C＃、C ++など）からJulia C APIを使用している場合は、各呼び出しを &lt;code&gt;libjulia&lt;/code&gt; にラップして、例外がスローされたかどうかをチェックし、例外をホスト言語。</target>
        </trans-unit>
        <trans-unit id="9d33189460471265e09a2493a0c7846b4727b27d" translate="yes" xml:space="preserve">
          <source>If you call it in an interactive session without assigning the return value anywhere, you will see the tuple returned:</source>
          <target state="translated">戻り値をどこにも代入せずに対話型セッションで呼び出すと、返されたタプルが表示されます。</target>
        </trans-unit>
        <trans-unit id="757e93c7d7c03576f2e8bdb2961d5a609265324d" translate="yes" xml:space="preserve">
          <source>If you define both styles of indexing for your &lt;code&gt;AbstractArray&lt;/code&gt;, this trait can be used to select the most performant indexing style. Some methods check this trait on their inputs, and dispatch to different algorithms depending on the most efficient access pattern. In particular, &lt;a href=&quot;#Base.eachindex&quot;&gt;&lt;code&gt;eachindex&lt;/code&gt;&lt;/a&gt; creates an iterator whose type depends on the setting of this trait.</source>
          <target state="translated">&lt;code&gt;AbstractArray&lt;/code&gt; に両方のインデックススタイルを定義すると、このトレイトを使用して、最もパフォーマンスの高いインデックススタイルを選択できます。一部のメソッドは、入力でこの特性をチェックし、最も効率的なアクセスパターンに応じて異なるアルゴリズムにディスパッチします。特に、&lt;a href=&quot;#Base.eachindex&quot;&gt; &lt;code&gt;eachindex&lt;/code&gt; &lt;/a&gt;は、この特性の設定に依存するタイプのイテレータを作成します。</target>
        </trans-unit>
        <trans-unit id="9ff95da549c7d7e30f1529ab4e07584cdcd87231" translate="yes" xml:space="preserve">
          <source>If you define custom exception types, your &lt;code&gt;showerror&lt;/code&gt; method can support hints by calling &lt;a href=&quot;#Base.Experimental.show_error_hints&quot;&gt;&lt;code&gt;Experimental.show_error_hints&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">カスタム例外タイプを定義する場合、 &lt;code&gt;showerror&lt;/code&gt; メソッドは&lt;a href=&quot;#Base.Experimental.show_error_hints&quot;&gt; &lt;code&gt;Experimental.show_error_hints&lt;/code&gt; &lt;/a&gt;を呼び出すことでヒントをサポートできます。</target>
        </trans-unit>
        <trans-unit id="0561f634340ef3ef5927debe41e5dcc4c8cce30a" translate="yes" xml:space="preserve">
          <source>If you examine the contents of &lt;code&gt;hello.txt&lt;/code&gt; at this point, you will notice that it is empty; nothing has actually been written to disk yet. This is because the &lt;code&gt;IOStream&lt;/code&gt; must be closed before the write is actually flushed to disk:</source>
          <target state="translated">この時点で &lt;code&gt;hello.txt&lt;/code&gt; の内容を確認すると、内容が空であることがわかります。実際にはまだ何もディスクに書き込まれていません。これは、書き込みが実際にディスクにフラッシュされる前に &lt;code&gt;IOStream&lt;/code&gt; を閉じる必要があるためです。</target>
        </trans-unit>
        <trans-unit id="61d643164ec2351bd9d6fcf481fa957527066f53" translate="yes" xml:space="preserve">
          <source>If you have a matrix &lt;code&gt;A&lt;/code&gt; that is slightly non-Hermitian due to roundoff errors in its construction, wrap it in &lt;code&gt;Hermitian(A)&lt;/code&gt; before passing it to &lt;code&gt;cholesky&lt;/code&gt; in order to treat it as perfectly Hermitian.</source>
          <target state="translated">構築の丸め誤差のためにわずかに非エルミートである行列 &lt;code&gt;A&lt;/code&gt; がある場合は、完全にエルミートとして扱うために、 &lt;code&gt;cholesky&lt;/code&gt; に渡す前に &lt;code&gt;Hermitian(A)&lt;/code&gt; でラップします。</target>
        </trans-unit>
        <trans-unit id="4eaa143836add2b691eb62610bcaeb5c4d609829" translate="yes" xml:space="preserve">
          <source>If you have a type that uses a native pointer:</source>
          <target state="translated">ネイティブポインタを使用する型を持っている場合。</target>
        </trans-unit>
        <trans-unit id="aaf9e1541b4bdb0c52c8f375b573b49db90dd938" translate="yes" xml:space="preserve">
          <source>If you have code that you want executed whenever Julia is run, you can put it in &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt;:</source>
          <target state="translated">Juliaを実行するたびに実行するコードがある場合は、それを &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; 配置できます。</target>
        </trans-unit>
        <trans-unit id="c6993e56b8a3ed1437873eaf20d58be9dd8dc4fb" translate="yes" xml:space="preserve">
          <source>If you have data in CSC format from a different application or library, and wish to import it in Julia, make sure that you use 1-based indexing. The row indices in every column need to be sorted. If your &lt;code&gt;SparseMatrixCSC&lt;/code&gt; object contains unsorted row indices, one quick way to sort them is by doing a double transpose.</source>
          <target state="translated">別のアプリケーションまたはライブラリからCSC形式のデータがあり、それをJuliaにインポートする場合は、1から始まるインデックスを使用してください。すべての列の行インデックスをソートする必要があります。 &lt;code&gt;SparseMatrixCSC&lt;/code&gt; オブジェクトに並べ替えられていない行インデックスが含まれている場合、それらを並べ替える1つの簡単な方法は、二重転置を行うことです。</target>
        </trans-unit>
        <trans-unit id="be1012643129d3902e3bcc736a2f09368b135cc7" translate="yes" xml:space="preserve">
          <source>If you interpolate an array as part of a shell word, Julia emulates the shell's &lt;code&gt;{a,b,c}&lt;/code&gt; argument generation:</source>
          <target state="translated">シェルワードの一部として配列を補間する場合、ジュリアはシェルの &lt;code&gt;{a,b,c}&lt;/code&gt; 引数生成をエミュレートします。</target>
        </trans-unit>
        <trans-unit id="66c0ea7806057d283c6cb2263bc03f2b5f51cca2" translate="yes" xml:space="preserve">
          <source>If you know that a module is &lt;em&gt;not&lt;/em&gt; safe to precompile your module (for example, for one of the reasons described below), you should put &lt;code&gt;__precompile__(false)&lt;/code&gt; in the module file (typically placed at the top). This will cause &lt;code&gt;Base.compilecache&lt;/code&gt; to throw an error, and will cause &lt;code&gt;using&lt;/code&gt; / &lt;code&gt;import&lt;/code&gt; to load it directly into the current process and skip the precompile and caching. This also thereby prevents the module from being imported by any other precompiled module.</source>
          <target state="translated">モジュールがモジュールをプリコンパイルするのに安全で&lt;em&gt;ない&lt;/em&gt;ことがわかっている場合（たとえば、以下に説明する理由の1つが原因 &lt;code&gt;__precompile__(false)&lt;/code&gt; 、モジュールファイル（通常は上部に配置）に__precompile __（false）を配置する必要があります。これにより、 &lt;code&gt;Base.compilecache&lt;/code&gt; がエラーをスローし、/ &lt;code&gt;import&lt;/code&gt; を &lt;code&gt;using&lt;/code&gt; して現在のプロセスに直接ロードし、プリコンパイルとキャッシュをスキップします。これにより、モジュールが他のプリコンパイル済みモジュールによってインポートされることも防止されます。</target>
        </trans-unit>
        <trans-unit id="8e09fd6adcf3b546269be2b7ff41cc7243507fad" translate="yes" xml:space="preserve">
          <source>If you need a reference to the created task, pass a &lt;code&gt;Ref{Task}&lt;/code&gt; object via the keyword argument &lt;code&gt;taskref&lt;/code&gt;.</source>
          <target state="translated">作成されたタスクへの参照が必要な場合は、キーワード引数 &lt;code&gt;taskref&lt;/code&gt; を介して &lt;code&gt;Ref{Task}&lt;/code&gt; オブジェクトを渡します。</target>
        </trans-unit>
        <trans-unit id="9119dc7e0716f5e2cbcc069fcd20399d5871b899" translate="yes" xml:space="preserve">
          <source>If you need to dispatch on multiple arguments, and there are many fallbacks with too many combinations to make it practical to define all possible variants, then consider introducing a &quot;name cascade&quot; where (for example) you dispatch on the first argument and then call an internal method:</source>
          <target state="translated">複数の引数でディスパッチする必要があり、可能なすべてのバリエーションを定義するのが実用的ではないほど多くの組み合わせのフォールバックがある場合は、(例えば)最初の引数でディスパッチしてから内部メソッドを呼び出す &quot;名前のカスケード &quot;の導入を検討してみてください。</target>
        </trans-unit>
        <trans-unit id="5c6a0fa6b882b862c349ff5b92d17fa1f5f4c109" translate="yes" xml:space="preserve">
          <source>If you need to guarantee exact reproducibility of random data, it is advisable to simply &lt;em&gt;save the data&lt;/em&gt; (e.g. as a supplementary attachment in a scientific publication). (You can also, of course, specify a particular Julia version and package manifest, especially if you require bit reproducibility.)</source>
          <target state="translated">ランダムデータの正確な再現性を保証する必要がある場合は、単に&lt;em&gt;データを保存する&lt;/em&gt;ことをお勧めし&lt;em&gt;ます&lt;/em&gt;（たとえば、科学出版物の補足添付ファイルとして）。（もちろん、特にビットの再現性が必要な場合は、特定のJuliaバージョンとパッケージマニフェストを指定することもできます。）</target>
        </trans-unit>
        <trans-unit id="76f3bebbfec4cfb424affa402369c33eff6a7949" translate="yes" xml:space="preserve">
          <source>If you need to obtain valid indices for a string, you can use the &lt;a href=&quot;../../base/strings/index#Base.nextind&quot;&gt;&lt;code&gt;nextind&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/strings/index#Base.prevind&quot;&gt;&lt;code&gt;prevind&lt;/code&gt;&lt;/a&gt; functions to increment/decrement to the next/previous valid index, as mentioned above. You can also use the &lt;a href=&quot;../../base/arrays/index#Base.eachindex&quot;&gt;&lt;code&gt;eachindex&lt;/code&gt;&lt;/a&gt; function to iterate over the valid character indices:</source>
          <target state="translated">文字列の有効なインデックスを取得する必要がある場合は、&lt;a href=&quot;../../base/strings/index#Base.nextind&quot;&gt; &lt;code&gt;nextind&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../base/strings/index#Base.prevind&quot;&gt; &lt;code&gt;prevind&lt;/code&gt; &lt;/a&gt;関数とprevind関数を使用して、次の/前の有効なインデックスに増分または減分できます。&lt;a href=&quot;../../base/arrays/index#Base.eachindex&quot;&gt; &lt;code&gt;eachindex&lt;/code&gt; &lt;/a&gt;関数を使用して、有効な文字インデックスを反復処理することもできます。</target>
        </trans-unit>
        <trans-unit id="ffe59bec712e7149856d034145a9690621f691b0" translate="yes" xml:space="preserve">
          <source>If you need to solve many systems of the form &lt;code&gt;(A+&amp;mu;I)x = b&lt;/code&gt; for the same &lt;code&gt;A&lt;/code&gt; and different &lt;code&gt;&amp;mu;&lt;/code&gt;, it might be beneficial to first compute the Hessenberg factorization &lt;code&gt;F&lt;/code&gt; of &lt;code&gt;A&lt;/code&gt; via the &lt;a href=&quot;#LinearAlgebra.hessenberg&quot;&gt;&lt;code&gt;hessenberg&lt;/code&gt;&lt;/a&gt; function. Given &lt;code&gt;F&lt;/code&gt;, Julia employs an efficient algorithm for &lt;code&gt;(F+&amp;mu;*I) \ b&lt;/code&gt; (equivalent to &lt;code&gt;(A+&amp;mu;*I)x \ b&lt;/code&gt;) and related operations like determinants.</source>
          <target state="translated">フォームの多くのシステム解決する必要がある場合は &lt;code&gt;(A+&amp;mu;I)x = b&lt;/code&gt; 同じのための &lt;code&gt;A&lt;/code&gt; と異なる &lt;code&gt;&amp;mu;&lt;/code&gt; を、それが最初に計算ヘッセンベルグ分解に有益であるかもしれない &lt;code&gt;F&lt;/code&gt; の &lt;code&gt;A&lt;/code&gt; を経由して&lt;a href=&quot;#LinearAlgebra.hessenberg&quot;&gt; &lt;code&gt;hessenberg&lt;/code&gt; &lt;/a&gt;機能。 &lt;code&gt;F&lt;/code&gt; が与えられると、ジュリアは &lt;code&gt;(F+&amp;mu;*I) \ b&lt;/code&gt; （ &lt;code&gt;(A+&amp;mu;*I)x \ b&lt;/code&gt; と同等）および行列式などの関連する演算に効率的なアルゴリズムを採用します。</target>
        </trans-unit>
        <trans-unit id="37c200e4c125ec6f24cad360d6dae92d524d5333" translate="yes" xml:space="preserve">
          <source>If you prefer to use the environment variable you can set it as follows in Bash (Linux/macOS):</source>
          <target state="translated">環境変数を使いたい場合は、Bash(Linux/macOS)で以下のように設定します。</target>
        </trans-unit>
        <trans-unit id="3e449fc3b5ae85ea55ddb2c14a81e3b450b101b1" translate="yes" xml:space="preserve">
          <source>If you specify &lt;code&gt;multiplex=true&lt;/code&gt; as an option to &lt;code&gt;addprocs&lt;/code&gt;, SSH multiplexing is used to create a tunnel between the master and workers. If you have configured SSH multiplexing on your own and the connection has already been established, SSH multiplexing is used regardless of &lt;code&gt;multiplex&lt;/code&gt; option. If multiplexing is enabled, forwarding is set by using the existing connection (&lt;code&gt;-O forward&lt;/code&gt; option in ssh). This is beneficial if your servers require password authentication; you can avoid authentication in Julia by logging in to the server ahead of &lt;code&gt;addprocs&lt;/code&gt;. The control socket will be located at &lt;code&gt;~/.ssh/julia-%r@%h:%p&lt;/code&gt; during the session unless the existing multiplexing connection is used. Note that bandwidth may be limited if you create multiple processes on a node and enable multiplexing, because in that case processes share a single multiplexing TCP connection.</source>
          <target state="translated">&lt;code&gt;addprocs&lt;/code&gt; のオプションとして &lt;code&gt;multiplex=true&lt;/code&gt; を指定すると、SSH多重化を使用してマスターとワーカーの間にトンネルが作成されます。 SSH多重化を独自に構成し、接続がすでに確立されている場合は、 &lt;code&gt;multiplex&lt;/code&gt; オプションに関係なくSSH多重化が使用されます。多重化が有効になっている場合、転送は既存の接続を使用して設定されます（sshの &lt;code&gt;-O forward&lt;/code&gt; オプション）。これは、サーバーでパスワード認証が必要な場合に役立ちます。 &lt;code&gt;addprocs&lt;/code&gt; の前にサーバーにログインすることで、Juliaでの認証を回避できます。制御ソケットは &lt;code&gt;~/.ssh/julia-%r@%h:%p&lt;/code&gt; 既存の多重化接続が使用されていない限り、セッション中。ノード上に複数のプロセスを作成して多重化を有効にすると、プロセスが単一の多重化TCP接続を共有するため、帯域幅が制限される場合があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="801f3bd6c180fb1f8c8c459f54a17ac585429686" translate="yes" xml:space="preserve">
          <source>If you specify a &lt;code&gt;branch&lt;/code&gt;, this must be done in reference format, since the string will be turned into a &lt;code&gt;GitReference&lt;/code&gt;. For example, if you wanted to merge branch &lt;code&gt;branch_a&lt;/code&gt;, you would call &lt;code&gt;merge!(repo, branch=&quot;refs/heads/branch_a&quot;)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;branch&lt;/code&gt; を指定する場合、文字列は &lt;code&gt;GitReference&lt;/code&gt; に変換されるため、これは参照形式で行う必要があります。たとえば、ブランチ &lt;code&gt;branch_a&lt;/code&gt; をマージする場合は、 &lt;code&gt;merge!(repo, branch=&quot;refs/heads/branch_a&quot;)&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="12b4daadf4d05ca4bd1781bb32cf57f260bb2750" translate="yes" xml:space="preserve">
          <source>If you supply more than one &lt;code&gt;AbstractArray&lt;/code&gt; argument, &lt;code&gt;eachindex&lt;/code&gt; will create an iterable object that is fast for all arguments (a &lt;a href=&quot;../collections/index#Base.UnitRange&quot;&gt;&lt;code&gt;UnitRange&lt;/code&gt;&lt;/a&gt; if all inputs have fast linear indexing, a &lt;a href=&quot;#Base.IteratorsMD.CartesianIndices&quot;&gt;&lt;code&gt;CartesianIndices&lt;/code&gt;&lt;/a&gt; otherwise). If the arrays have different sizes and/or dimensionalities, &lt;code&gt;eachindex&lt;/code&gt; will return an iterable that spans the largest range along each dimension.</source>
          <target state="translated">複数の &lt;code&gt;AbstractArray&lt;/code&gt; 引数を指定した場合、 &lt;code&gt;eachindex&lt;/code&gt; はすべての引数に対して高速な反復可能オブジェクトを作成します（すべての入力が高速線形インデックスの場合は&lt;a href=&quot;../collections/index#Base.UnitRange&quot;&gt; &lt;code&gt;UnitRange&lt;/code&gt; &lt;/a&gt;、それ以外の場合は&lt;a href=&quot;#Base.IteratorsMD.CartesianIndices&quot;&gt; &lt;code&gt;CartesianIndices&lt;/code&gt; &lt;/a&gt;）。配列のサイズや次元が異なる場合、 &lt;code&gt;eachindex&lt;/code&gt; は各次元に沿った最大範囲にわたる反復可能オブジェクトを返します。</target>
        </trans-unit>
        <trans-unit id="f56a6f95645242ddef63028fd0be36ad60f0ec75" translate="yes" xml:space="preserve">
          <source>If you supply more than one &lt;code&gt;AbstractArray&lt;/code&gt; argument, &lt;code&gt;eachindex&lt;/code&gt; will create an iterable object that is fast for all arguments (a &lt;a href=&quot;../collections/index#Base.UnitRange&quot;&gt;&lt;code&gt;UnitRange&lt;/code&gt;&lt;/a&gt; if all inputs have fast linear indexing, a &lt;a href=&quot;#Base.IteratorsMD.CartesianIndices&quot;&gt;&lt;code&gt;CartesianIndices&lt;/code&gt;&lt;/a&gt; otherwise). If the arrays have different sizes and/or dimensionalities, a DimensionMismatch exception will be thrown.</source>
          <target state="translated">複数の &lt;code&gt;AbstractArray&lt;/code&gt; 引数を指定すると、 &lt;code&gt;eachindex&lt;/code&gt; は、すべての引数に対して高速な反復可能オブジェクトを作成します（すべての入力に高速線形インデックスがある場合は&lt;a href=&quot;../collections/index#Base.UnitRange&quot;&gt; &lt;code&gt;UnitRange&lt;/code&gt; &lt;/a&gt;、それ以外の場合は&lt;a href=&quot;#Base.IteratorsMD.CartesianIndices&quot;&gt; &lt;code&gt;CartesianIndices&lt;/code&gt; &lt;/a&gt;）。配列のサイズや次元が異なる場合、DimensionMismatch例外がスローされます。</target>
        </trans-unit>
        <trans-unit id="ad751359c9250bca5bb370e9aaa6dde27fda5aad" translate="yes" xml:space="preserve">
          <source>If you try this in the REPL, you will see that &lt;code&gt;schedule&lt;/code&gt; returns immediately. That is because it simply adds &lt;code&gt;t&lt;/code&gt; to an internal queue of tasks to run. Then, the REPL will print the next prompt and wait for more input. Waiting for keyboard input provides an opportunity for other tasks to run, so at that point &lt;code&gt;t&lt;/code&gt; will start. &lt;code&gt;t&lt;/code&gt; calls &lt;a href=&quot;../../base/parallel/index#Base.sleep&quot;&gt;&lt;code&gt;sleep&lt;/code&gt;&lt;/a&gt;, which sets a timer and stops execution. If other tasks have been scheduled, they could run then. After five seconds, the timer fires and restarts &lt;code&gt;t&lt;/code&gt;, and you will see &lt;code&gt;done&lt;/code&gt; printed. &lt;code&gt;t&lt;/code&gt; is then finished.</source>
          <target state="translated">REPLでこれを試すと、 &lt;code&gt;schedule&lt;/code&gt; がすぐに戻ることがわかります。これは、実行するタスクの内部キューに &lt;code&gt;t&lt;/code&gt; を追加するだけだからです。次に、REPLは次のプロンプトを出力し、さらに入力を待ちます。キーボード入力を待つと、他のタスクを実行する機会が得られるため、その時点で &lt;code&gt;t&lt;/code&gt; が開始されます。 &lt;code&gt;t&lt;/code&gt; は&lt;a href=&quot;../../base/parallel/index#Base.sleep&quot;&gt; &lt;code&gt;sleep&lt;/code&gt; を&lt;/a&gt;呼び出します。これはタイマーを設定し、実行を停止します。他のタスクがスケジュールされている場合は、それらを実行できます。 5秒後、タイマーが起動して &lt;code&gt;t&lt;/code&gt; を再起動すると、 &lt;code&gt;done&lt;/code&gt; 印刷されたことがわかります。その後、 &lt;code&gt;t&lt;/code&gt; は終了します。</target>
        </trans-unit>
        <trans-unit id="0bf64552bec6648b4a2dbc60f5636537b6e39be4" translate="yes" xml:space="preserve">
          <source>If you want a quantity that is of the same type as &lt;code&gt;x&lt;/code&gt;, or of type &lt;code&gt;T&lt;/code&gt;, even if &lt;code&gt;x&lt;/code&gt; is dimensionful, use &lt;a href=&quot;#Base.oneunit&quot;&gt;&lt;code&gt;oneunit&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; と同じタイプ、またはタイプ &lt;code&gt;T&lt;/code&gt; の数量が必要な場合、 &lt;code&gt;x&lt;/code&gt; が次元数であっても、代わりに&lt;a href=&quot;#Base.oneunit&quot;&gt; &lt;code&gt;oneunit&lt;/code&gt; を&lt;/a&gt;使用します。</target>
        </trans-unit>
        <trans-unit id="0d6bdd166c95ac54bc84be65e3c70b26b5a5d3fc" translate="yes" xml:space="preserve">
          <source>If you want to &lt;em&gt;avoid&lt;/em&gt; adding dots for selected function calls in &lt;code&gt;expr&lt;/code&gt;, splice those function calls in with &lt;code&gt;$&lt;/code&gt;. For example, &lt;code&gt;@. sqrt(abs($sort(x)))&lt;/code&gt; is equivalent to &lt;code&gt;sqrt.(abs.(sort(x)))&lt;/code&gt; (no dot for &lt;code&gt;sort&lt;/code&gt;).</source>
          <target state="translated">あなたがしたい場合は&lt;em&gt;避ける&lt;/em&gt;における選択された関数呼び出しのためのドットを追加 &lt;code&gt;expr&lt;/code&gt; の、とスプライスこれらの関数呼び出し &lt;code&gt;$&lt;/code&gt; を。たとえば、 &lt;code&gt;@. sqrt(abs($sort(x)))&lt;/code&gt; と等価である &lt;code&gt;sqrt.(abs.(sort(x)))&lt;/code&gt; 無ドットのための &lt;code&gt;sort&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="683a65524138ed99d613028444b793379d0ca4fd" translate="yes" xml:space="preserve">
          <source>If you want to extract a character from a string, you index into it:</source>
          <target state="translated">文字列から文字を抽出したい場合は、その文字列にインデックスを付けます。</target>
        </trans-unit>
        <trans-unit id="af6bdcdecfb445706192e5de8fd952192d9e2d0e" translate="yes" xml:space="preserve">
          <source>If you want to read the output of the external command, &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; can be used instead:</source>
          <target state="translated">外部コマンドの出力を読みたい場合は、代わりに&lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt;を使用できます。</target>
        </trans-unit>
        <trans-unit id="9ee9527d2c41ad82a10f035e6e19f07b44c36b95" translate="yes" xml:space="preserve">
          <source>If you want to test that some particular messages are generated while ignoring the rest, you can set the keyword &lt;code&gt;match_mode=:any&lt;/code&gt;:</source>
          <target state="translated">残りを無視して特定のメッセージが生成されることをテストする場合は、キーワード &lt;code&gt;match_mode=:any&lt;/code&gt; ：を設定できます。</target>
        </trans-unit>
        <trans-unit id="66677df9764417ef6a9289f8e4f6bf8274c36caa" translate="yes" xml:space="preserve">
          <source>If you want to use logging as an audit trail you should disable this for your logger type.</source>
          <target state="translated">監査証跡としてロギングを使用したい場合は、ロガー タイプでこれを無効にする必要があります。</target>
        </trans-unit>
        <trans-unit id="e7c7d63501e2b9d2d6b42831c4f6216f8a461efd" translate="yes" xml:space="preserve">
          <source>If you want to write to a file, you can open it with the write (&lt;code&gt;&quot;w&quot;&lt;/code&gt;) flag:</source>
          <target state="translated">ファイルに書き込みたい場合は、書き込み（ &lt;code&gt;&quot;w&quot;&lt;/code&gt; ）フラグを使用してファイルを開くことができます。</target>
        </trans-unit>
        <trans-unit id="c3b03f51e5a4a15df40aa0cdfd2977b041193157" translate="yes" xml:space="preserve">
          <source>If you were to profile &lt;code&gt;dumbsum3&lt;/code&gt;, and a backtrace was taken while it was executing &lt;code&gt;dumbsum(1)&lt;/code&gt;, the backtrace would look like this:</source>
          <target state="translated">&lt;code&gt;dumbsum3&lt;/code&gt; のプロファイルを作成し、 &lt;code&gt;dumbsum(1)&lt;/code&gt; の実行中にバックトレースが取得された場合、バックトレースは次のようになります。</target>
        </trans-unit>
        <trans-unit id="0bc4f596ffa41c5fb93ede00ad1673e3a89c26be" translate="yes" xml:space="preserve">
          <source>If you wish to specialize on a particular style &lt;code&gt;DestStyle&lt;/code&gt;, define a method for</source>
          <target state="translated">特定のスタイル &lt;code&gt;DestStyle&lt;/code&gt; に特化したい場合は、</target>
        </trans-unit>
        <trans-unit id="9416eec2408335a70a9403f87954e9d92bc5beb6" translate="yes" xml:space="preserve">
          <source>If you would like to define your own block, for example a &lt;code&gt;terminology&lt;/code&gt; block used like so:</source>
          <target state="translated">独自のブロックを定義したい場合、たとえば、次のように使用される &lt;code&gt;terminology&lt;/code&gt; ブロック：</target>
        </trans-unit>
        <trans-unit id="f81fa178f278896f499b8c79cc33cce8975b52ac" translate="yes" xml:space="preserve">
          <source>If you write a custom &lt;a href=&quot;../../base/arrays/index#Core.AbstractArray&quot;&gt;&lt;code&gt;AbstractArray&lt;/code&gt;&lt;/a&gt; type, you can specify that it has fast linear indexing using</source>
          <target state="translated">カスタムの&lt;a href=&quot;../../base/arrays/index#Core.AbstractArray&quot;&gt; &lt;code&gt;AbstractArray&lt;/code&gt; &lt;/a&gt;型を作成する場合、次のコマンドを使用して、高速な線形インデックスを指定できます</target>
        </trans-unit>
        <trans-unit id="731e84cb8afd8370c60140146ac6c2a5c345b233" translate="yes" xml:space="preserve">
          <source>If you write generic code which handles numbers, and which can be expected to run with many different numeric type arguments, try using literals of a numeric type that will affect the arguments as little as possible through promotion.</source>
          <target state="translated">数値を扱う汎用的なコードを書く場合で、多くの異なる数値型の引数での実行が予想される場合は、プロモーションによって引数にできるだけ影響を与えないような数値型のリテラルを使ってみてください。</target>
        </trans-unit>
        <trans-unit id="dcea13c507e05364e2e2a422c4d4bb092770bc50" translate="yes" xml:space="preserve">
          <source>If your array type does have fixed dimensionality requirements, then you should subtype &lt;code&gt;AbstractArrayStyle&lt;/code&gt;. For example, the sparse array code has the following definitions:</source>
          <target state="translated">配列型に固定次元要件がある場合、サブタイプ &lt;code&gt;AbstractArrayStyle&lt;/code&gt; をサブタイプする必要があります。たとえば、スパース配列コードには次の定義があります。</target>
        </trans-unit>
        <trans-unit id="86e175e64e8da6c7e916078c1c6ea2b5a935db82" translate="yes" xml:space="preserve">
          <source>If your code has recursion, one potentially-confusing point is that a line in a &quot;child&quot; function can accumulate more counts than there are total backtraces. Consider the following function definitions:</source>
          <target state="translated">コードに再帰性がある場合、「子」関数の行は、バックトレースの総数よりも多くのカウントを蓄積することができるという点で、混乱を招く可能性があります。以下の関数定義を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="aa3f9be2eca1806a6c02bd56dca6f747bcc2726c" translate="yes" xml:space="preserve">
          <source>If your function returns an &lt;code&gt;Array&lt;/code&gt; or some other complex type, it may have to allocate memory. Unfortunately, oftentimes allocation and its converse, garbage collection, are substantial bottlenecks.</source>
          <target state="translated">関数が &lt;code&gt;Array&lt;/code&gt; またはその他の複合型を返す場合、メモリを割り当てる必要がある場合があります。残念ながら、多くの場合、割り当てとその逆のガベージコレクションは、かなりのボトルネックになります。</target>
        </trans-unit>
        <trans-unit id="203770fc43c2ec3f449524fb36ddffdf662a89aa" translate="yes" xml:space="preserve">
          <source>If, on the other hand, Julia was loading the &lt;em&gt;other&lt;/em&gt;&lt;code&gt;Priv&lt;/code&gt; package&amp;mdash;the one with UUID &lt;code&gt;2d15fe94-a1f7-436c-a4d8-07a9a496e01c&lt;/code&gt;&amp;mdash;it finds its stanza in the manifest, see that it does &lt;em&gt;not&lt;/em&gt; have a &lt;code&gt;path&lt;/code&gt; entry, but that it does have a &lt;code&gt;git-tree-sha1&lt;/code&gt; entry. It then computes the &lt;code&gt;slug&lt;/code&gt; for this UUID/SHA-1 pair, which is &lt;code&gt;HDkrT&lt;/code&gt; (the exact details of this computation aren't important, but it is consistent and deterministic). This means that the path to this &lt;code&gt;Priv&lt;/code&gt; package will be &lt;code&gt;packages/Priv/HDkrT/src/Priv.jl&lt;/code&gt; in one of the package depots. Suppose the contents of &lt;code&gt;DEPOT_PATH&lt;/code&gt; is &lt;code&gt;[&quot;/home/me/.julia&quot;, &quot;/usr/local/julia&quot;]&lt;/code&gt;, then Julia will look at the following paths to see if they exist:</source>
          <target state="translated">一方、Juliaが&lt;em&gt;他の&lt;/em&gt; &lt;code&gt;Priv&lt;/code&gt; パッケージ（UUID &lt;code&gt;2d15fe94-a1f7-436c-a4d8-07a9a496e01c&lt;/code&gt; を含むもの)をロードしていた&lt;em&gt;場合&lt;/em&gt;、マニフェストにそのスタンザが見つかった&lt;em&gt;場合&lt;/em&gt;は、 &lt;code&gt;path&lt;/code&gt; エントリが&lt;em&gt;ない&lt;/em&gt;ことを確認してください。 &lt;code&gt;git-tree-sha1&lt;/code&gt; エントリはありません。次に、このUUID / SHA-1ペアの &lt;code&gt;slug&lt;/code&gt; を計算します。これは &lt;code&gt;HDkrT&lt;/code&gt; です（この計算の正確な詳細は重要ではありませんが、一貫していて確定的です）。つまり、この &lt;code&gt;Priv&lt;/code&gt; パッケージへのパスは、パッケージデポの1つにある &lt;code&gt;packages/Priv/HDkrT/src/Priv.jl&lt;/code&gt; になります。 &lt;code&gt;DEPOT_PATH&lt;/code&gt; の内容が &lt;code&gt;[&quot;/home/me/.julia&quot;, &quot;/usr/local/julia&quot;]&lt;/code&gt; 場合、Juliaは次のパスを調べて、それらが存在するかどうかを確認します。</target>
        </trans-unit>
        <trans-unit id="08884ba6d9fbd224895a7cbdeceeec1f4c59bf40" translate="yes" xml:space="preserve">
          <source>Image Of</source>
          <target state="translated">イメージ</target>
        </trans-unit>
        <trans-unit id="6ea4ebbef3751656124627e822bd05d7b6569f88" translate="yes" xml:space="preserve">
          <source>Image Of Or Approximately Equal To</source>
          <target state="translated">のイメージまたはそれにほぼ等しい</target>
        </trans-unit>
        <trans-unit id="09e871c98fef3b901a775def173e4126aaf73b42" translate="yes" xml:space="preserve">
          <source>Images</source>
          <target state="translated">Images</target>
        </trans-unit>
        <trans-unit id="a1dd283e60c10a07da0fde84cdded35b0d62bc7f" translate="yes" xml:space="preserve">
          <source>Immediately run finalizers registered for object &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">オブジェクト &lt;code&gt;x&lt;/code&gt; に登録されているファイナライザをすぐに実行します。</target>
        </trans-unit>
        <trans-unit id="3f8a84e660062cc9351aa99e4736b44741ec8c96" translate="yes" xml:space="preserve">
          <source>Immutable composite types with no fields are singletons; there can be only one instance of such types:</source>
          <target state="translated">フィールドを持たない不変複合型はシングルトンです。</target>
        </trans-unit>
        <trans-unit id="546c2aff0baec3bbc325a5abd6340afd6a503d6d" translate="yes" xml:space="preserve">
          <source>ImmutableDict</source>
          <target state="translated">ImmutableDict</target>
        </trans-unit>
        <trans-unit id="4d5fca35f85700fe41f680f762e716a68cf32a0c" translate="yes" xml:space="preserve">
          <source>ImmutableDict is a Dictionary implemented as an immutable linked list, which is optimal for small dictionaries that are constructed over many individual insertions Note that it is not possible to remove a value, although it can be partially overridden and hidden by inserting a new value with the same key</source>
          <target state="translated">ImmutableDict は、不変リンクリストとして実装された辞書で、多数の個別の挿入で構成された小さな辞書に最適です。</target>
        </trans-unit>
        <trans-unit id="5a205de46742b724da4bcd47864315bbfb29bffa" translate="yes" xml:space="preserve">
          <source>Imp</source>
          <target state="translated">Imp</target>
        </trans-unit>
        <trans-unit id="8781d615fd77be9578225c40ac67b9471394cced" translate="yes" xml:space="preserve">
          <source>Implementation</source>
          <target state="translated">Implementation</target>
        </trans-unit>
        <trans-unit id="91db407238f7692c5a1c288977c0c95bb564522e" translate="yes" xml:space="preserve">
          <source>Implemented by cluster managers using custom transports. It should establish a logical connection to worker with id &lt;code&gt;pid&lt;/code&gt;, specified by &lt;code&gt;config&lt;/code&gt; and return a pair of &lt;code&gt;IO&lt;/code&gt; objects. Messages from &lt;code&gt;pid&lt;/code&gt; to current process will be read off &lt;code&gt;instrm&lt;/code&gt;, while messages to be sent to &lt;code&gt;pid&lt;/code&gt; will be written to &lt;code&gt;outstrm&lt;/code&gt;. The custom transport implementation must ensure that messages are delivered and received completely and in order. &lt;code&gt;connect(manager::ClusterManager.....)&lt;/code&gt; sets up TCP/IP socket connections in-between workers.</source>
          <target state="translated">カスタムトランスポートを使用してクラスターマネージャーによって実装されます。 &lt;code&gt;config&lt;/code&gt; で指定されたID &lt;code&gt;pid&lt;/code&gt; のワーカーへの論理接続を確立し、 &lt;code&gt;IO&lt;/code&gt; オブジェクトのペアを返す必要があります。 &lt;code&gt;pid&lt;/code&gt; から現在のプロセスへのメッセージは &lt;code&gt;instrm&lt;/code&gt; から読み取られ、 &lt;code&gt;pid&lt;/code&gt; に送信されるメッセージは &lt;code&gt;outstrm&lt;/code&gt; に書き込まれます。カスタム転送の実装では、メッセージが完全かつ順序どおりに送受信されるようにする必要があります。 &lt;code&gt;connect(manager::ClusterManager.....)&lt;/code&gt; は、ワーカー間のTCP / IPソケット接続をセットアップします。</target>
        </trans-unit>
        <trans-unit id="08979f61f84f8ad3b659b0b75ccddbf1892ea3a4" translate="yes" xml:space="preserve">
          <source>Implemented by cluster managers. For every Julia worker launched by this function, it should append a &lt;code&gt;WorkerConfig&lt;/code&gt; entry to &lt;code&gt;launched&lt;/code&gt; and notify &lt;code&gt;launch_ntfy&lt;/code&gt;. The function MUST exit once all workers, requested by &lt;code&gt;manager&lt;/code&gt; have been launched. &lt;code&gt;params&lt;/code&gt; is a dictionary of all keyword arguments &lt;a href=&quot;#Distributed.addprocs&quot;&gt;&lt;code&gt;addprocs&lt;/code&gt;&lt;/a&gt; was called with.</source>
          <target state="translated">クラスターマネージャーによって実装されます。この関数によって起動されたすべてのJuliaワーカーでは、 &lt;code&gt;WorkerConfig&lt;/code&gt; エントリを &lt;code&gt;launched&lt;/code&gt; 追加して、launch_ntfyに通知する &lt;code&gt;launch_ntfy&lt;/code&gt; ます。この関数は、 &lt;code&gt;manager&lt;/code&gt; から要求されたすべてのワーカーが起動されたら終了する必要があります。 &lt;code&gt;params&lt;/code&gt; は、&lt;a href=&quot;#Distributed.addprocs&quot;&gt; &lt;code&gt;addprocs&lt;/code&gt; &lt;/a&gt;が呼び出されたすべてのキーワード引数の辞書です。</target>
        </trans-unit>
        <trans-unit id="b5a68dbaa7e53b1fdc013e1b1b627c788dfd10b1" translate="yes" xml:space="preserve">
          <source>Implemented by cluster managers. It is called on the master process, by &lt;a href=&quot;#Distributed.rmprocs&quot;&gt;&lt;code&gt;rmprocs&lt;/code&gt;&lt;/a&gt;. It should cause the remote worker specified by &lt;code&gt;pid&lt;/code&gt; to exit. &lt;code&gt;kill(manager::ClusterManager.....)&lt;/code&gt; executes a remote &lt;code&gt;exit()&lt;/code&gt; on &lt;code&gt;pid&lt;/code&gt;.</source>
          <target state="translated">クラスターマネージャーによって実装されます。&lt;a href=&quot;#Distributed.rmprocs&quot;&gt; &lt;code&gt;rmprocs&lt;/code&gt; &lt;/a&gt;によってマスタープロセスで呼び出されます。 &lt;code&gt;pid&lt;/code&gt; で指定されたリモートワーカーが終了するはずです。 &lt;code&gt;kill(manager::ClusterManager.....)&lt;/code&gt; は、 &lt;code&gt;pid&lt;/code&gt; でリモート &lt;code&gt;exit()&lt;/code&gt; を実行します。</target>
        </trans-unit>
        <trans-unit id="dba266234257c3d4b0aca4b478ddab2be6ca2905" translate="yes" xml:space="preserve">
          <source>Implemented by cluster managers. It is called on the master process, during a worker's lifetime, with appropriate &lt;code&gt;op&lt;/code&gt; values:</source>
          <target state="translated">クラスターマネージャーによって実装されます。これは、適切な &lt;code&gt;op&lt;/code&gt; 値を使用して、ワーカーのライフタイム中にマスタープロセスで呼び出されます。</target>
        </trans-unit>
        <trans-unit id="2d46cc8d098f423748bfcc369918df042e230bb1" translate="yes" xml:space="preserve">
          <source>Implicit names from identifiers and dot expressions are available as of Julia 1.5.</source>
          <target state="translated">Julia 1.5では、識別子とドット式からの暗黙の名前が利用可能になりました。</target>
        </trans-unit>
        <trans-unit id="a6456a3318802fc28959139bf29a9bdf8b9e1954" translate="yes" xml:space="preserve">
          <source>Import Command</source>
          <target state="translated">インポートコマンド</target>
        </trans-unit>
        <trans-unit id="a4489b5a6e6e45ce5f1172241f2ce59438e83997" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;MyModule&lt;/code&gt; above we wanted to add a method to the standard &lt;code&gt;show&lt;/code&gt; function, so we had to write &lt;code&gt;import Base.show&lt;/code&gt;. Functions whose names are only visible via &lt;code&gt;using&lt;/code&gt; cannot be extended.</source>
          <target state="translated">で &lt;code&gt;MyModule&lt;/code&gt; という上記の我々は、標準的にメソッドを追加したい &lt;code&gt;show&lt;/code&gt; 我々が書かなければならなかったので、機能 &lt;code&gt;import Base.show&lt;/code&gt; 。名前を &lt;code&gt;using&lt;/code&gt; てのみ表示される関数は拡張できません。</target>
        </trans-unit>
        <trans-unit id="035c9cab15fd9dc0120582c57dc7ae1a95ac181b" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;very rare&lt;/em&gt; cases it might make sense for the constructor &lt;code&gt;T(x)&lt;/code&gt; to return an object not of type &lt;code&gt;T&lt;/code&gt;. This could happen if a wrapper type is its own inverse (e.g. &lt;code&gt;Flip(Flip(x)) === x&lt;/code&gt;), or to support an old calling syntax for backwards compatibility when a library is restructured. But &lt;code&gt;convert(T, x)&lt;/code&gt; should always return a value of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;非常にまれな&lt;/em&gt;ケースには、コンストラクタの意味になるかもしれない &lt;code&gt;T(x)&lt;/code&gt; タイプのオブジェクトを返すことはない &lt;code&gt;T&lt;/code&gt; 。これは、ラッパータイプが独自の逆の場合（ &lt;code&gt;Flip(Flip(x)) === x&lt;/code&gt; ）、またはライブラリの再構築時に下位互換性のために古い呼び出し構文をサポートする場合に発生する可能性があります。ただし、 &lt;code&gt;convert(T, x)&lt;/code&gt; は常にタイプ &lt;code&gt;T&lt;/code&gt; の値を返す必要があります。</target>
        </trans-unit>
        <trans-unit id="d6ddd3549cd522fa313ced4025d3d58df8994646" translate="yes" xml:space="preserve">
          <source>In C++ or Java, for example, in a method call like &lt;code&gt;obj.meth(arg1,arg2)&lt;/code&gt;, the object obj &quot;receives&quot; the method call and is implicitly passed to the method via the &lt;code&gt;this&lt;/code&gt; keyword, rather than as an explicit method argument. When the current &lt;code&gt;this&lt;/code&gt; object is the receiver of a method call, it can be omitted altogether, writing just &lt;code&gt;meth(arg1,arg2)&lt;/code&gt;, with &lt;code&gt;this&lt;/code&gt; implied as the receiving object.</source>
          <target state="translated">C ++またはJavaでは、たとえば、 &lt;code&gt;obj.meth(arg1,arg2)&lt;/code&gt; ようなメソッド呼び出しでは、オブジェクトobjはメソッド呼び出しを「受け取り」、明示的なメソッド引数としてではなく、 &lt;code&gt;this&lt;/code&gt; キーワードを介して暗黙的にメソッドに渡されます。 。現在の場合 &lt;code&gt;this&lt;/code&gt; オブジェクトは、メソッド呼び出しの受信機であり、それだけで書き込み、完全に省略することができる &lt;code&gt;meth(arg1,arg2)&lt;/code&gt; 用いて、 &lt;code&gt;this&lt;/code&gt; 受信対象として暗示します。</target>
        </trans-unit>
        <trans-unit id="0b44231782a66524e37b6a261f0e356297afae45" translate="yes" xml:space="preserve">
          <source>In C++, by default, you have static dispatch, i.e. you need to annotate a function as virtual, in order to have dynamic dispatch. On the other hand, in Julia every method is &quot;virtual&quot; (although it's more general than that since methods are dispatched on every argument type, not only &lt;code&gt;this&lt;/code&gt;, using the most-specific-declaration rule).</source>
          <target state="translated">C ++では、デフォルトで静的ディスパッチがあります。つまり、動的ディスパッチを行うには、関数に仮想アノテーションを付ける必要があります。一方、Juliaでは、すべてのメソッドが「仮想」です（メソッドは、 &lt;code&gt;this&lt;/code&gt; だけでなく、最も限定的な宣言ルールを使用して、すべての引数の型でディスパッチされるため、それよりも一般的です）。</target>
        </trans-unit>
        <trans-unit id="848c2eb8261286f9fd639a07ac24e094cd08249a" translate="yes" xml:space="preserve">
          <source>In Julia &amp;le; 0.6, all global scopes did work like the current REPL: when &lt;code&gt;x = &amp;lt;value&amp;gt;&lt;/code&gt; occurred in a loop (or &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt;, or &lt;code&gt;struct&lt;/code&gt; body) but outside of a function body (or &lt;code&gt;let&lt;/code&gt; block or comprehension), it was decided based on whether a global named &lt;code&gt;x&lt;/code&gt; was defined or not whether &lt;code&gt;x&lt;/code&gt; should be local to the loop. This behavior has the advantage of being intuitive and convenient since it approximates the behavior inside of a function body as closely as possible. In particular, it makes it easy to move code back and forth between a function body and the REPL when trying to debug the behavior of a function. However, it has some downsides. First, it's quite a complex behavior: many people over the years were confused about this behavior and complained that it was complicated and hard both to explain and understand. Fair point. Second, and arguably worse, is that it's bad for programming &quot;at scale.&quot; When you see a small piece of code in one place like this, it's quite clear what's going on:</source>
          <target state="translated">Julia&amp;le;0.6では、すべてのグローバルスコープは現在のREPLのように機能しました &lt;code&gt;x = &amp;lt;value&amp;gt;&lt;/code&gt; がループ内で発生した（または &lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; 、または &lt;code&gt;struct&lt;/code&gt; body）が、関数本体の外側（または &lt;code&gt;let&lt;/code&gt; blockまたはcomprehension）の場合、グローバルという名前かどうかに基づいて決定された &lt;code&gt;x&lt;/code&gt; が定義されていないかどうかして &lt;code&gt;x&lt;/code&gt; ループに対してローカルである必要があります。この動作には、関数本体内の動作を可能な限り近似するため、直感的で便利であるという利点があります。特に、関数の動作をデバッグしようとするときに、関数本体とREPLの間でコードを簡単に移動できます。ただし、いくつかの欠点があります。まず、これは非常に複雑な動作です。何年にもわたって多くの人がこの動作について混乱し、説明も理解も複雑で難しいと不満を漏らしていました。フェアポイント。第二に、そして間違いなくもっと悪いことに、それは「大規模な」プログラミングには悪いということです。このような1つの場所に小さなコードが表示されると、何が起こっているのかがはっきりとわかります。</target>
        </trans-unit>
        <trans-unit id="a64f4137e1f00234d12e399e1c5435c90a8e6c63" translate="yes" xml:space="preserve">
          <source>In Julia (as in much of scientific computation), dense linear-algebra operations are based on the &lt;a href=&quot;http://www.netlib.org/lapack/&quot;&gt;LAPACK library&lt;/a&gt;, which in turn is built on top of basic linear-algebra building-blocks known as the &lt;a href=&quot;http://www.netlib.org/blas/&quot;&gt;BLAS&lt;/a&gt;. There are highly optimized implementations of BLAS available for every computer architecture, and sometimes in high-performance linear algebra routines it is useful to call the BLAS functions directly.</source>
          <target state="translated">ジュリアでは、科学計算の多くと同様に、密な線形代数演算は&lt;a href=&quot;http://www.netlib.org/lapack/&quot;&gt;LAPACKライ​​ブラリに&lt;/a&gt;基づいており、LAPACKライ​​ブラリは&lt;a href=&quot;http://www.netlib.org/blas/&quot;&gt;BLASと&lt;/a&gt;呼ばれる基本的な線形代数ビルディングブロックの上に構築されています。すべてのコンピュータアーキテクチャで利用できる高度に最適化されたBLASの実装があり、高性能の線形代数ルーチンでは、BLAS関数を直接呼び出すと便利な場合があります。</target>
        </trans-unit>
        <trans-unit id="247a76ccd2e14a487830d09d4cedad7b8f5df0c1" translate="yes" xml:space="preserve">
          <source>In Julia 1.0 this method only supported a square destination matrix. Julia 1.1. added support for a rectangular matrix.</source>
          <target state="translated">Julia 1.0 では、このメソッドは正方行列のみをサポートしていました。Julia 1.1.では、長方形の行列をサポートするようになりました。</target>
        </trans-unit>
        <trans-unit id="7eb90fb66dbd8787a2bcb4484cc97817d278a46b" translate="yes" xml:space="preserve">
          <source>In Julia 1.0, the default &lt;code&gt;--project=@.&lt;/code&gt; option did not search up from the root directory of a Git repository for the &lt;code&gt;Project.toml&lt;/code&gt; file. From Julia 1.1 forward, it does.</source>
          <target state="translated">Julia 1.0では、デフォルトは &lt;code&gt;--project=@.&lt;/code&gt; オプションはGitリポジトリのルートディレクトリから &lt;code&gt;Project.toml&lt;/code&gt; ファイルを検索しませんでした。Julia 1.1以降では、そうなります。</target>
        </trans-unit>
        <trans-unit id="0050127afe87c7fac6e12932d051462ec8c65b3e" translate="yes" xml:space="preserve">
          <source>In Julia 1.1 &lt;code&gt;randcycle&lt;/code&gt; returns a vector &lt;code&gt;v&lt;/code&gt; with &lt;code&gt;eltype(v) == typeof(n)&lt;/code&gt; while in Julia 1.0 &lt;code&gt;eltype(v) == Int&lt;/code&gt;.</source>
          <target state="translated">Julia 1.1では、 &lt;code&gt;randcycle&lt;/code&gt; は &lt;code&gt;eltype(v) == typeof(n)&lt;/code&gt; ベクトル &lt;code&gt;v&lt;/code&gt; を返しますが、Julia 1.0 &lt;code&gt;eltype(v) == Int&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="d8b5eb0c54cc4aad9911d4c5d77bfea05f710df6" translate="yes" xml:space="preserve">
          <source>In Julia 1.1 &lt;code&gt;randperm&lt;/code&gt; returns a vector &lt;code&gt;v&lt;/code&gt; with &lt;code&gt;eltype(v) == typeof(n)&lt;/code&gt; while in Julia 1.0 &lt;code&gt;eltype(v) == Int&lt;/code&gt;.</source>
          <target state="translated">Julia 1.1では、 &lt;code&gt;randperm&lt;/code&gt; は &lt;code&gt;eltype(v) == typeof(n)&lt;/code&gt; ベクトル &lt;code&gt;v&lt;/code&gt; を返しますが、Julia 1.0 &lt;code&gt;eltype(v) == Int&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="f25573f2ef6b2638e0373e20cdd6eceb2e703331" translate="yes" xml:space="preserve">
          <source>In Julia 1.5 and above the number of threads can also be specified on startup using the &lt;code&gt;-t&lt;/code&gt;/&lt;code&gt;--threads&lt;/code&gt; command line argument.</source>
          <target state="translated">Julia 1.5以降では、起動時に &lt;code&gt;-t&lt;/code&gt; / &lt;code&gt;--threads&lt;/code&gt; コマンドライン引数を使用してスレッド数を指定することもできます。</target>
        </trans-unit>
        <trans-unit id="d630cc94b63c31ac28921da908c57f1454c54e15" translate="yes" xml:space="preserve">
          <source>In Julia &lt;code&gt;%&lt;/code&gt; is the remainder operator, whereas in Python it is the modulus.</source>
          <target state="translated">ジュリアでは &lt;code&gt;%&lt;/code&gt; は剰余演算子ですが、Pythonではモジュラスです。</target>
        </trans-unit>
        <trans-unit id="cbc49b243ca968548d5e6046855ea243ea0a10fe" translate="yes" xml:space="preserve">
          <source>In Julia code wrapping calls to external C routines, ordinary (non-pointer) data should be declared to be of type &lt;code&gt;T&lt;/code&gt; inside the &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt;, as they are passed by value. For C code accepting pointers, &lt;a href=&quot;../../base/c/index#Core.Ref&quot;&gt;&lt;code&gt;Ref{T}&lt;/code&gt;&lt;/a&gt; should generally be used for the types of input arguments, allowing the use of pointers to memory managed by either Julia or C through the implicit call to &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt;&lt;code&gt;Base.cconvert&lt;/code&gt;&lt;/a&gt;. In contrast, pointers returned by the C function called should be declared to be of output type &lt;a href=&quot;../../base/c/index#Core.Ptr&quot;&gt;&lt;code&gt;Ptr{T}&lt;/code&gt;&lt;/a&gt;, reflecting that the memory pointed to is managed by C only. Pointers contained in C structs should be represented as fields of type &lt;code&gt;Ptr{T}&lt;/code&gt; within the corresponding Julia struct types designed to mimic the internal structure of corresponding C structs.</source>
          <target state="translated">外部Cルーチンへの呼び出しをラップするJuliaコードでは、通常の（非ポインター）データは値によって渡されるため、&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt;内で &lt;code&gt;T&lt;/code&gt; 型として宣言する必要があります。ポインターを受け入れるCコードの場合、通常、入力引数のタイプには&lt;a href=&quot;../../base/c/index#Core.Ref&quot;&gt; &lt;code&gt;Ref{T}&lt;/code&gt; &lt;/a&gt;を使用する必要があります。これにより、&lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt; &lt;code&gt;Base.cconvert&lt;/code&gt; &lt;/a&gt;への暗黙的な呼び出しを通じてJuliaまたはCによって管理されるメモリへのポインターを使用できるようになります。対照的に、呼び出されたC関数によって返されたポインターは、出力タイプ&lt;a href=&quot;../../base/c/index#Core.Ptr&quot;&gt; &lt;code&gt;Ptr{T}&lt;/code&gt; &lt;/a&gt;であると宣言する必要があります。これは、ポイントされたメモリがCによってのみ管理されることを反映しています。 C構造体に含まれるポインターは、タイプ &lt;code&gt;Ptr{T}&lt;/code&gt; フィールドとして表す必要があります 対応するC構造体の内部構造を模倣するように設計された、対応するJulia構造体タイプ内。</target>
        </trans-unit>
        <trans-unit id="1fa4d6ec34fe20b0509960e834e463ea1a6b4cc7" translate="yes" xml:space="preserve">
          <source>In Julia code wrapping calls to external Fortran routines, all input arguments should be declared as of type &lt;code&gt;Ref{T}&lt;/code&gt;, as Fortran passes all variables by pointers to memory locations. The return type should either be &lt;code&gt;Cvoid&lt;/code&gt; for Fortran subroutines, or a &lt;code&gt;T&lt;/code&gt; for Fortran functions returning the type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">外部のFortranルーチンへの呼び出しをラップするJuliaコードでは、Fortranはすべての変数をポインターによってメモリ位置に渡すため、すべての入力引数は &lt;code&gt;Ref{T}&lt;/code&gt; 型として宣言する必要があります。戻り値の型は、Fortranサブルーチンの場合は &lt;code&gt;Cvoid&lt;/code&gt; であるか、型 &lt;code&gt;T&lt;/code&gt; を返すFortran関数の場合は &lt;code&gt;T&lt;/code&gt; である必要があります。</target>
        </trans-unit>
        <trans-unit id="34f3cdb66f13e42ca43c63a9c817a8c4007728b9" translate="yes" xml:space="preserve">
          <source>In Julia each module has its own global scope/namespace, whereas in MATLAB there is just one global scope.</source>
          <target state="translated">Juliaでは各モジュールは独自のグローバルスコープ/名前空間を持っていますが、MATLABではグローバルスコープは1つだけです。</target>
        </trans-unit>
        <trans-unit id="a3d6aa810b7eb985858c7d4e38c552636ecace4b" translate="yes" xml:space="preserve">
          <source>In Julia loops are fast, there is no need to write &quot;vectorized&quot; code for performance reasons.</source>
          <target state="translated">Juliaではループが高速なので、パフォーマンスのために &quot;ベクトル化 &quot;されたコードを書く必要はありません。</target>
        </trans-unit>
        <trans-unit id="d9649a4e1eb5caa62495053957d722a3d4bba674" translate="yes" xml:space="preserve">
          <source>In Julia mode, the REPL supports something called &lt;em&gt;prompt pasting&lt;/em&gt;. This activates when pasting text that starts with &lt;code&gt;julia&amp;gt;&lt;/code&gt; into the REPL. In that case, only expressions starting with &lt;code&gt;julia&amp;gt;&lt;/code&gt; are parsed, others are removed. This makes it is possible to paste a chunk of code that has been copied from a REPL session without having to scrub away prompts and outputs. This feature is enabled by default but can be disabled or enabled at will with &lt;code&gt;REPL.enable_promptpaste(::Bool)&lt;/code&gt;. If it is enabled, you can try it out by pasting the code block above this paragraph straight into the REPL. This feature does not work on the standard Windows command prompt due to its limitation at detecting when a paste occurs.</source>
          <target state="translated">Juliaモードでは、REPLは&lt;em&gt;プロンプト貼り付け&lt;/em&gt;と呼ばれるものをサポートし&lt;em&gt;ます&lt;/em&gt;。これは、 &lt;code&gt;julia&amp;gt;&lt;/code&gt; で始まるテキストをREPL に貼り付けるとアクティブになります。その場合、 &lt;code&gt;julia&amp;gt;&lt;/code&gt; で始まる式のみが解析され、その他は削除されます。これにより、プロンプトや出力を消し去ることなく、REPLセッションからコピーされたコードのチャンクを貼り付けることができます。この機能はデフォルトで有効になっていますが、 &lt;code&gt;REPL.enable_promptpaste(::Bool)&lt;/code&gt; で自由に無効または有効にできます。有効になっている場合は、この段落の上のコードブロックをREPLに直接貼り付けることで試してみることができます。この機能は、貼り付けの発生を検出する際の制限により、標準のWindowsコマンドプロンプトでは機能しません。</target>
        </trans-unit>
        <trans-unit id="7129a6b15edfb73c2cd4cd30d7a70ed28691edca" translate="yes" xml:space="preserve">
          <source>In Julia the &lt;code&gt;@&lt;/code&gt; symbol refers to a macro, whereas in Python it refers to a decorator.</source>
          <target state="translated">Juliaでは &lt;code&gt;@&lt;/code&gt; 記号はマクロを指しますが、Pythonではデコレータを指します。</target>
        </trans-unit>
        <trans-unit id="57d6ea2617d808e81c678587852ffabe403f81cb" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;&amp;lt;-&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;-&lt;/code&gt; and &lt;code&gt;-&amp;gt;&lt;/code&gt; are not assignment operators.</source>
          <target state="translated">ジュリアでは、 &lt;code&gt;&amp;lt;-&lt;/code&gt; 、 &lt;code&gt;&amp;lt;&amp;lt;-&lt;/code&gt; 、 &lt;code&gt;-&amp;gt;&lt;/code&gt; は代入演算子ではありません。</target>
        </trans-unit>
        <trans-unit id="601692d3aba8995fb01afb976c7c7f5a8aab46fc" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;...&lt;/code&gt; is not used to continue lines of code. Instead, incomplete expressions automatically continue onto the next line.</source>
          <target state="translated">ジュリアでは、 &lt;code&gt;...&lt;/code&gt; はコードの行を続けるために使用されません。代わりに、不完全な式は自動的に次の行に続きます。</target>
        </trans-unit>
        <trans-unit id="5bdd69cd27046bb2e3189abcdf750e49518e8509" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;Ref&lt;/code&gt; objects are dereferenced (loaded or stored) with &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">Juliaでは、 &lt;code&gt;Ref&lt;/code&gt; オブジェクトは &lt;code&gt;[]&lt;/code&gt; で逆参照（ロードまたは保存）されます。</target>
        </trans-unit>
        <trans-unit id="bbe698f34efa48506b3a034b90fcbacaa3b44d79" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;[1, 2, 3, 4][[true, false, true, false]]&lt;/code&gt; produces &lt;code&gt;[1, 3]&lt;/code&gt;.</source>
          <target state="translated">ジュリアでは、 &lt;code&gt;[1, 2, 3, 4][[true, false, true, false]]&lt;/code&gt; は &lt;code&gt;[1, 3]&lt;/code&gt; 生成します。</target>
        </trans-unit>
        <trans-unit id="41c6478a96484907c7a62d3fc652aeb5cc697413" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;[1, 2, 3, 4][[true, false]]&lt;/code&gt; throws a &lt;a href=&quot;../../base/base/index#Core.BoundsError&quot;&gt;&lt;code&gt;BoundsError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ジュリアでは、 &lt;code&gt;[1, 2, 3, 4][[true, false]]&lt;/code&gt; が&lt;a href=&quot;../../base/base/index#Core.BoundsError&quot;&gt; &lt;code&gt;BoundsError&lt;/code&gt; を&lt;/a&gt;スローします。</target>
        </trans-unit>
        <trans-unit id="0974da83f18cbcaffe16bb6459e3edda104c9151" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;[x,y,z]&lt;/code&gt; will always construct a 3-element array containing &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt; and &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">ジュリアでは、 &lt;code&gt;[x,y,z]&lt;/code&gt; は常に &lt;code&gt;x&lt;/code&gt; 、 &lt;code&gt;y&lt;/code&gt; 、 &lt;code&gt;z&lt;/code&gt; を含む3要素の配列を作成します。</target>
        </trans-unit>
        <trans-unit id="1d138a3241eb075445bbb09d48ceedbc03b1d34e" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;a:b&lt;/code&gt; and &lt;code&gt;a:b:c&lt;/code&gt; construct &lt;code&gt;AbstractRange&lt;/code&gt; objects. To construct a full vector like in MATLAB, use &lt;code&gt;collect(a:b)&lt;/code&gt;. Generally, there is no need to call &lt;code&gt;collect&lt;/code&gt; though. An &lt;code&gt;AbstractRange&lt;/code&gt; object will act like a normal array in most cases but is more efficient because it lazily computes its values. This pattern of creating specialized objects instead of full arrays is used frequently, and is also seen in functions such as &lt;a href=&quot;../../base/math/index#Base.range&quot;&gt;&lt;code&gt;range&lt;/code&gt;&lt;/a&gt;, or with iterators such as &lt;code&gt;enumerate&lt;/code&gt;, and &lt;code&gt;zip&lt;/code&gt;. The special objects can mostly be used as if they were normal arrays.</source>
          <target state="translated">Juliaでは、 &lt;code&gt;a:b&lt;/code&gt; および &lt;code&gt;a:b:c&lt;/code&gt; が &lt;code&gt;AbstractRange&lt;/code&gt; オブジェクトを構築します。MATLABのように完全なベクトルを作成するには、 &lt;code&gt;collect(a:b)&lt;/code&gt; を使用します。ただし、通常は、 &lt;code&gt;collect&lt;/code&gt; を呼び出す必要はありません。 &lt;code&gt;AbstractRange&lt;/code&gt; のオブジェクトは、ほとんどの場合、通常の配列のように作用するが、それはいい加減にその値を計算しているため、より効率的であるだろう。完全な配列の代わりに特殊なオブジェクトを作成するこのパターンは頻繁に使用され、&lt;a href=&quot;../../base/math/index#Base.range&quot;&gt; &lt;code&gt;range&lt;/code&gt; &lt;/a&gt;などの関数、または &lt;code&gt;enumerate&lt;/code&gt; や &lt;code&gt;zip&lt;/code&gt; などのイテレータでも見られます。特別なオブジェクトは、通常の配列のように使用できます。</target>
        </trans-unit>
        <trans-unit id="5622f51f1798995f4e2f17cefbf558acb8bdcceb" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;return&lt;/code&gt; does not require parentheses.</source>
          <target state="translated">ジュリアでは、 &lt;code&gt;return&lt;/code&gt; 括弧は必要ありません。</target>
        </trans-unit>
        <trans-unit id="c5612272a8f825cb7424d2a9deb9bd304a01ce42" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;x += y&lt;/code&gt; gets replaced during parsing by &lt;code&gt;x = x + y&lt;/code&gt;. For arrays, this has the consequence that, rather than storing the result in the same location in memory as &lt;code&gt;x&lt;/code&gt;, it allocates a new array to store the result.</source>
          <target state="translated">Juliaでは、 &lt;code&gt;x += y&lt;/code&gt; は解析中に &lt;code&gt;x = x + y&lt;/code&gt; 置き換えられます。配列の場合、これは結果をメモリ内の &lt;code&gt;x&lt;/code&gt; と同じ場所に格納するのではなく、結果を格納するために新しい配列を割り当てるという結果になります。</target>
        </trans-unit>
        <trans-unit id="40831d3e8b132da3257b046df4af0d9dab5df46c" translate="yes" xml:space="preserve">
          <source>In Julia, a function is an object that maps a tuple of argument values to a return value. Julia functions are not pure mathematical functions, because they can alter and be affected by the global state of the program. The basic syntax for defining functions in Julia is:</source>
          <target state="translated">Julia では、関数は引数の値のタプルを戻り値にマッピングするオブジェクトです。Julia の関数は純粋な数学関数ではありません。Julia で関数を定義するための基本的な構文は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="58b1700c001aef7c6e8210d638550d343b095441" translate="yes" xml:space="preserve">
          <source>In Julia, a function is an object that maps a tuple of argument values to a return value. Julia functions are not pure mathematical functions, in the sense that functions can alter and be affected by the global state of the program. The basic syntax for defining functions in Julia is:</source>
          <target state="translated">Julia では、関数は引数の値のタプルを戻り値にマッピングするオブジェクトです。Julia の関数は純粋な数学関数ではなく、プログラムのグローバルな状態を変更したり影響を受けたりすることができるという意味で、純粋な数学関数です。Julia で関数を定義するための基本的な構文は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="1c8982a95e255a5e2cc9c0e2345b6061fd0be88f" translate="yes" xml:space="preserve">
          <source>In Julia, a function may contain multiple concrete implementations (called &lt;em&gt;Methods&lt;/em&gt;), selected via multiple dispatch, whereas functions in Python have a single implementation (no polymorphism).</source>
          <target state="translated">Juliaでは、関数には複数のディスパッチを介して選択された複数の具体的な実装（&lt;em&gt;メソッド&lt;/em&gt;と呼ばれる）が含まれる場合がありますが、Pythonの関数には単一の実装（ポリモーフィズムなし）があります。</target>
        </trans-unit>
        <trans-unit id="2f670eb9f52ba71aa8ad7654d94717d406c50aa0" translate="yes" xml:space="preserve">
          <source>In Julia, a new local scope is introduced by most code blocks, including loops and &lt;code&gt;try&lt;/code&gt; &amp;mdash; &lt;code&gt;catch&lt;/code&gt; &amp;mdash; &lt;code&gt;finally&lt;/code&gt;. Note that comprehensions (list, generator, etc.) introduce a new local scope both in Python and Julia, whereas &lt;code&gt;if&lt;/code&gt; blocks do not introduce a new local scope in both languages.</source>
          <target state="translated">ジュリアでは、新しいローカルスコープは、ループを含むほとんどのコードブロックによって導入された &lt;code&gt;try&lt;/code&gt; - &lt;code&gt;catch&lt;/code&gt; - &lt;code&gt;finally&lt;/code&gt; 。内包表記（リスト、ジェネレーターなど）は、PythonとJuliaの両方で新しいローカルスコープを導入しますが &lt;code&gt;if&lt;/code&gt; ブロックが両方の言語で新しいローカルスコープを導入しない場合は注意してください。</target>
        </trans-unit>
        <trans-unit id="4f9d45e10bb7e036a0e05a4d8d4376715db6b481" translate="yes" xml:space="preserve">
          <source>In Julia, a range like &lt;code&gt;a:b&lt;/code&gt; is not shorthand for a vector like in R, but is a specialized &lt;code&gt;AbstractRange&lt;/code&gt; object that is used for iteration without high memory overhead. To convert a range into a vector, use &lt;code&gt;collect(a:b)&lt;/code&gt;.</source>
          <target state="translated">Juliaでは、 &lt;code&gt;a:b&lt;/code&gt; のような範囲はRのようなベクトルの省略表現ではありませんが、高いメモリオーバーヘッドなしで反復に使用される特殊な &lt;code&gt;AbstractRange&lt;/code&gt; オブジェクトです。範囲をベクトルに変換するには、 &lt;code&gt;collect(a:b)&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="40f5223023ecdb73df06f3b1a01d3f068c335d77" translate="yes" xml:space="preserve">
          <source>In Julia, all arguments to functions are &lt;a href=&quot;https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing&quot;&gt;passed by sharing&lt;/a&gt; (i.e. by pointers). Some technical computing languages pass arrays by value, and while this prevents accidental modification by callees of a value in the caller, it makes avoiding unwanted copying of arrays difficult. By convention, a function name ending with a &lt;code&gt;!&lt;/code&gt; indicates that it will mutate or destroy the value of one or more of its arguments (compare, for example, &lt;a href=&quot;../../base/sort/index#Base.sort&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/sort/index#Base.sort!&quot;&gt;&lt;code&gt;sort!&lt;/code&gt;&lt;/a&gt;). Callees must make explicit copies to ensure that they don't modify inputs that they don't intend to change. Many non- mutating functions are implemented by calling a function of the same name with an added &lt;code&gt;!&lt;/code&gt; at the end on an explicit copy of the input, and returning that copy.</source>
          <target state="translated">Juliaでは、関数へのすべての引数は&lt;a href=&quot;https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing&quot;&gt;共有&lt;/a&gt;（つまり、ポインター）によって渡されます。一部のテクニカルコンピューティング言語は配列を値で渡します。これにより、呼び出し元の値が呼び出し側で誤って変更されるのを防ぎますが、配列の不要なコピーを回避することが難しくなります。慣例により、 &lt;code&gt;!&lt;/code&gt; で終わる関数名 1つ以上の引数の値を変更または破棄することを示します（たとえば、&lt;a href=&quot;../../base/sort/index#Base.sort&quot;&gt; &lt;code&gt;sort&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../../base/sort/index#Base.sort!&quot;&gt; &lt;code&gt;sort!&lt;/code&gt; を&lt;/a&gt;比較してください）。呼び出し先は明示的なコピーを作成して、変更するつもりのない入力を変更しないようにする必要があります。多くの非変更関数は、同じ名前の関数を &lt;code&gt;!&lt;/code&gt; 入力の明示的なコピーの最後で、そのコピーを返します。</target>
        </trans-unit>
        <trans-unit id="9c3127614001f5fb915dc8fbc84746b3f3f27566" translate="yes" xml:space="preserve">
          <source>In Julia, an array &quot;slice&quot; expression like &lt;code&gt;array[1:5, :]&lt;/code&gt; creates a copy of that data (except on the left-hand side of an assignment, where &lt;code&gt;array[1:5, :] = ...&lt;/code&gt; assigns in-place to that portion of &lt;code&gt;array&lt;/code&gt;). If you are doing many operations on the slice, this can be good for performance because it is more efficient to work with a smaller contiguous copy than it would be to index into the original array. On the other hand, if you are just doing a few simple operations on the slice, the cost of the allocation and copy operations can be substantial.</source>
          <target state="translated">Juliaでは、array &lt;code&gt;array[1:5, :]&lt;/code&gt; 、：]のような配列の「スライス」式は、そのデータのコピーを作成します（ &lt;code&gt;array[1:5, :] = ...&lt;/code&gt; 、：] = ...割り当ての左側の割り当てを除きます） &lt;code&gt;array&lt;/code&gt; その部分にインプレース）。スライスで多くの操作を実行している場合、元の配列にインデックスを付けるよりも小さな連続したコピーで作業する方が効率的であるため、これはパフォーマンスにとって良い場合があります。一方、スライスでいくつかの単純な操作を実行しているだけの場合、割り当てとコピーの操作のコストはかなり高くなる可能性があります。</target>
        </trans-unit>
        <trans-unit id="3012ec15c747cb5e8c8ab3cbb7a1be0e9f5c2879" translate="yes" xml:space="preserve">
          <source>In Julia, exceeding the maximum representable value of a given type results in a wraparound behavior:</source>
          <target state="translated">Julia では、指定された型の表現可能な最大値を超えると、ラップアラウンド動作が発生します。</target>
        </trans-unit>
        <trans-unit id="64ca87b8c062eb3ffaa0f39bec7e937ad18a966d" translate="yes" xml:space="preserve">
          <source>In Julia, if &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are arrays, logical comparison operations like &lt;code&gt;A == B&lt;/code&gt; do not return an array of booleans. Instead, use &lt;code&gt;A .== B&lt;/code&gt;, and similarly for the other boolean operators like &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Juliaでは、 &lt;code&gt;A&lt;/code&gt; と &lt;code&gt;B&lt;/code&gt; が配列の場合、 &lt;code&gt;A == B&lt;/code&gt; ような論理比較演算はブール値の配列を返しません。代わりに、 &lt;code&gt;A .== B&lt;/code&gt; 使用し、 &lt;code&gt;&amp;lt;&lt;/code&gt; 、 &lt;code&gt;&amp;gt;&lt;/code&gt; などの他のブール演算子についても同様に使用します。</target>
        </trans-unit>
        <trans-unit id="8d1570d580f73be0193694bd4c3eb228fc48008c" translate="yes" xml:space="preserve">
          <source>In Julia, indexing a matrix with arrays like &lt;code&gt;X[[1,2], [1,3]]&lt;/code&gt; refers to a sub-matrix that contains the intersections of the first and second rows with the first and third columns. In Python, &lt;code&gt;X[[1,2], [1,3]]&lt;/code&gt; refers to a vector that contains the values of cell &lt;code&gt;[1,1]&lt;/code&gt; and &lt;code&gt;[2,3]&lt;/code&gt; in the matrix. &lt;code&gt;X[[1,2], [1,3]]&lt;/code&gt; in Julia is equivalent with &lt;code&gt;X[np.ix_([0,1],[0,2])]&lt;/code&gt; in Python. &lt;code&gt;X[[0,1], [0,2]]&lt;/code&gt; in Python is equivalent with &lt;code&gt;X[[CartesianIndex(1,1), CartesianIndex(2,3)]]&lt;/code&gt; in Julia.</source>
          <target state="translated">Juliaでは、 &lt;code&gt;X[[1,2], [1,3]]&lt;/code&gt; ような配列で行列にインデックスを付けることは、1行目と2行目と1列目と3列目の交点を含む部分行列を指します。 Pythonでは、 &lt;code&gt;X[[1,2], [1,3]]&lt;/code&gt; は、行列内のセル &lt;code&gt;[1,1]&lt;/code&gt; と &lt;code&gt;[2,3]&lt;/code&gt; の値を含むベクトルを指します。Juliaの &lt;code&gt;X[[1,2], [1,3]]&lt;/code&gt; は、Pythonの &lt;code&gt;X[np.ix_([0,1],[0,2])]&lt;/code&gt; と同等です。Pythonの &lt;code&gt;X[[0,1], [0,2]]&lt;/code&gt; は、Juliaの &lt;code&gt;X[[CartesianIndex(1,1), CartesianIndex(2,3)]]&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="d922f5b73911084e1798e1fbea58a0f20f71a33c" translate="yes" xml:space="preserve">
          <source>In Julia, indexing of arrays, strings, etc. is 1-based not 0-based.</source>
          <target state="translated">Juliaでは、配列や文字列などのインデックスは0ベースではなく1ベースになります。</target>
        </trans-unit>
        <trans-unit id="06df6596eaa7007459b69a3e35309023ab071dc0" translate="yes" xml:space="preserve">
          <source>In Julia, like Python but unlike R, strings can be created with triple quotes &lt;code&gt;&quot;&quot;&quot; ... &quot;&quot;&quot;&lt;/code&gt;. This syntax is convenient for constructing strings that contain line breaks.</source>
          <target state="translated">Juliaでは、PythonのようですがRとは異なり、文字列は三重引用符 &lt;code&gt;&quot;&quot;&quot; ... &quot;&quot;&quot;&lt;/code&gt; で作成できます。この構文は、改行を含む文字列を作成するのに便利です。</target>
        </trans-unit>
        <trans-unit id="6ff09f4efca3c4661d730a90a1c75212c7df44ad" translate="yes" xml:space="preserve">
          <source>In Julia, literal numbers without a decimal point (such as &lt;code&gt;42&lt;/code&gt;) create integers instead of floating point numbers. As a result, some operations can throw a domain error if they expect a float; for example, &lt;code&gt;julia&amp;gt; a = -1; 2^a&lt;/code&gt; throws a domain error, as the result is not an integer (see &lt;a href=&quot;../faq/index#faq-domain-errors&quot;&gt;the FAQ entry on domain errors&lt;/a&gt; for details).</source>
          <target state="translated">Juliaでは、小数点のないリテラル数（ &lt;code&gt;42&lt;/code&gt; など）は、浮動小数点数の代わりに整数を作成します。その結果、一部の操作では、フロートが必要な場合にドメインエラーがスローされる可能性があります。たとえば、 &lt;code&gt;julia&amp;gt; a = -1; 2^a&lt;/code&gt; は、結果が整数ではないため、ドメインエラーをスローします（詳細について&lt;a href=&quot;../faq/index#faq-domain-errors&quot;&gt;は、ドメインエラーに関するFAQエントリ&lt;/a&gt;を参照してください）。</target>
        </trans-unit>
        <trans-unit id="c8b7771804f2b70605beeefa21f23d88e1f845ae" translate="yes" xml:space="preserve">
          <source>In Julia, literal numbers without a decimal point (such as &lt;code&gt;42&lt;/code&gt;) create integers instead of floating point numbers. As a result, some operations can throw a domain error if they expect a float; for example, &lt;code&gt;julia&amp;gt; a = -1; 2^a&lt;/code&gt; throws a domain error, as the result is not an integer (see &lt;a href=&quot;../faq/index#faq-domain-errors-1&quot;&gt;the FAQ entry on domain errors&lt;/a&gt; for details).</source>
          <target state="translated">Juliaでは、小数点のないリテラル数（ &lt;code&gt;42&lt;/code&gt; など）は、浮動小数点数ではなく整数を作成します。その結果、一部の操作では、浮動小数点数が必要な場合にドメインエラーがスローされる可能性があります。たとえば、 &lt;code&gt;julia&amp;gt; a = -1; 2^a&lt;/code&gt; は、結果が整数ではないため、ドメインエラーをスローします（詳細について&lt;a href=&quot;../faq/index#faq-domain-errors-1&quot;&gt;は、ドメインエラーに関するFAQエントリ&lt;/a&gt;を参照してください）。</target>
        </trans-unit>
        <trans-unit id="abe9d8d534555f871e47223b8068b11086c34b86" translate="yes" xml:space="preserve">
          <source>In Julia, literal numbers without a decimal point (such as &lt;code&gt;42&lt;/code&gt;) create signed integers, of type &lt;code&gt;Int&lt;/code&gt;, but literals too large to fit in the machine word size will automatically be promoted to a larger size type, such as &lt;code&gt;Int64&lt;/code&gt; (if &lt;code&gt;Int&lt;/code&gt; is &lt;code&gt;Int32&lt;/code&gt;), &lt;code&gt;Int128&lt;/code&gt;, or the arbitrarily large &lt;code&gt;BigInt&lt;/code&gt; type. There are no numeric literal suffixes, such as &lt;code&gt;L&lt;/code&gt;, &lt;code&gt;LL&lt;/code&gt;, &lt;code&gt;U&lt;/code&gt;, &lt;code&gt;UL&lt;/code&gt;, &lt;code&gt;ULL&lt;/code&gt; to indicate unsigned and/or signed vs. unsigned. Decimal literals are always signed, and hexadecimal literals (which start with &lt;code&gt;0x&lt;/code&gt; like C/C++), are unsigned. Hexadecimal literals also, unlike C/C++/Java and unlike decimal literals in Julia, have a type based on the &lt;em&gt;length&lt;/em&gt; of the literal, including leading 0s. For example, &lt;code&gt;0x0&lt;/code&gt; and &lt;code&gt;0x00&lt;/code&gt; have type &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt;&lt;code&gt;UInt8&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;0x000&lt;/code&gt; and &lt;code&gt;0x0000&lt;/code&gt; have type &lt;a href=&quot;../../base/numbers/index#Core.UInt16&quot;&gt;&lt;code&gt;UInt16&lt;/code&gt;&lt;/a&gt;, then literals with 5 to 8 hex digits have type &lt;code&gt;UInt32&lt;/code&gt;, 9 to 16 hex digits type &lt;code&gt;UInt64&lt;/code&gt; and 17 to 32 hex digits type &lt;code&gt;UInt128&lt;/code&gt;. This needs to be taken into account when defining hexadecimal masks, for example &lt;code&gt;~0xf == 0xf0&lt;/code&gt; is very different from &lt;code&gt;~0x000f == 0xfff0&lt;/code&gt;. 64 bit &lt;code&gt;Float64&lt;/code&gt; and 32 bit &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt; bit literals are expressed as &lt;code&gt;1.0&lt;/code&gt; and &lt;code&gt;1.0f0&lt;/code&gt; respectively. Floating point literals are rounded (and not promoted to the &lt;code&gt;BigFloat&lt;/code&gt; type) if they can not be exactly represented. Floating point literals are closer in behavior to C/C++. Octal (prefixed with &lt;code&gt;0o&lt;/code&gt;) and binary (prefixed with &lt;code&gt;0b&lt;/code&gt;) literals are also treated as unsigned.</source>
          <target state="translated">Juliaでは、小数点のないリテラル数（ &lt;code&gt;42&lt;/code&gt; など）は、 &lt;code&gt;Int&lt;/code&gt; 型の符号付き整数を作成しますが、リテラルが大きすぎてマシンワードサイズに収まらない場合は、 &lt;code&gt;Int64&lt;/code&gt; などのより大きなサイズの型に自動的に昇格されます（ &lt;code&gt;Int&lt;/code&gt; が &lt;code&gt;Int32&lt;/code&gt; ）、 &lt;code&gt;Int128&lt;/code&gt; 、または任意の大きさ &lt;code&gt;BigInt&lt;/code&gt; 種類。 &lt;code&gt;L&lt;/code&gt; 、 &lt;code&gt;LL&lt;/code&gt; 、 &lt;code&gt;U&lt;/code&gt; 、 &lt;code&gt;UL&lt;/code&gt; 、 &lt;code&gt;ULL&lt;/code&gt; などの数値リテラルサフィックスはありません。 10進リテラルは常に署名され、16進リテラル（ &lt;code&gt;0x&lt;/code&gt; で始まる）C / C ++のように）、署名されていません。 16進リテラルも、C / C ++ / Javaとは異なり、Juliaの10進リテラルとは異なり、先行する0を含め、リテラルの&lt;em&gt;長さ&lt;/em&gt;に基づいた型を持っています。例えば、 &lt;code&gt;0x0&lt;/code&gt; と &lt;code&gt;0x00&lt;/code&gt; のタイプ有する&lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt; &lt;code&gt;UInt8&lt;/code&gt; &lt;/a&gt;、 &lt;code&gt;0x000&lt;/code&gt; および &lt;code&gt;0x0000&lt;/code&gt; 入力した&lt;a href=&quot;../../base/numbers/index#Core.UInt16&quot;&gt; &lt;code&gt;UInt16&lt;/code&gt; 型を&lt;/a&gt;、次いで5~8六角桁リテラルが入力持っ &lt;code&gt;UInt32&lt;/code&gt; 型を、9〜16進数字が入力 &lt;code&gt;UInt64&lt;/code&gt; 型を 17〜32進数字が入力 &lt;code&gt;UInt128&lt;/code&gt; を。これは、例えば、進マスクを定義する際に考慮される必要がある &lt;code&gt;~0xf == 0xf0&lt;/code&gt; 非常に異なっている &lt;code&gt;~0x000f == 0xfff0&lt;/code&gt; 。 64ビット &lt;code&gt;Float64&lt;/code&gt; および32ビット&lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt; &lt;code&gt;Float32&lt;/code&gt; &lt;/a&gt;ビットリテラルは、それぞれ &lt;code&gt;1.0&lt;/code&gt; および &lt;code&gt;1.0f0&lt;/code&gt; として表されます。浮動小数点リテラルは、正確に表すことができない場合は丸められます（ &lt;code&gt;BigFloat&lt;/code&gt; 型に昇格されません）。浮動小数点リテラルの動作は、C / C ++に近いです。 8 進数（接頭辞 &lt;code&gt;0o&lt;/code&gt; ）および2進（接頭辞 &lt;code&gt;0b&lt;/code&gt; ）リテラルも、符号なしとして扱われます。</target>
        </trans-unit>
        <trans-unit id="bdfe6baa0b2a1067c27d35abb55f2ee6ec449a3c" translate="yes" xml:space="preserve">
          <source>In Julia, missing values are represented by the &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; object rather than by &lt;code&gt;NA&lt;/code&gt;. Use &lt;a href=&quot;../../base/base/index#Base.ismissing&quot;&gt;&lt;code&gt;ismissing(x)&lt;/code&gt;&lt;/a&gt; (or &lt;code&gt;ismissing.(x)&lt;/code&gt; for element-wise operation on vectors) instead of &lt;code&gt;is.na(x)&lt;/code&gt;. The &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt;&lt;code&gt;skipmissing&lt;/code&gt;&lt;/a&gt; function is generally used instead of &lt;code&gt;na.rm=TRUE&lt;/code&gt; (though in some particular cases functions take a &lt;code&gt;skipmissing&lt;/code&gt; argument).</source>
          <target state="translated">Juliaでは、欠損値は &lt;code&gt;NA&lt;/code&gt; ではなく&lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt;オブジェクトで表されます。使用&lt;a href=&quot;../../base/base/index#Base.ismissing&quot;&gt; &lt;code&gt;ismissing(x)&lt;/code&gt; &lt;/a&gt;（又は &lt;code&gt;ismissing.(x)&lt;/code&gt; の代わりに、要素ごとの操作のためのベクターに） &lt;code&gt;is.na(x)&lt;/code&gt; 。&lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt; &lt;code&gt;skipmissing&lt;/code&gt; の&lt;/a&gt;機能は、一般の代わりに使用され &lt;code&gt;na.rm=TRUE&lt;/code&gt; （いくつかの特定のケースで機能を取るのに &lt;code&gt;skipmissing&lt;/code&gt; の引数）。</target>
        </trans-unit>
        <trans-unit id="c2883abece45992fb07a9eafea704ad64c7847f2" translate="yes" xml:space="preserve">
          <source>In Julia, modulus is &lt;code&gt;mod(a, b)&lt;/code&gt;, not &lt;code&gt;a %% b&lt;/code&gt;. &lt;code&gt;%&lt;/code&gt; in Julia is the remainder operator.</source>
          <target state="translated">Juliaでは、係数は &lt;code&gt;mod(a, b)&lt;/code&gt; であり &lt;code&gt;a %% b&lt;/code&gt; ではありません。ジュリアの &lt;code&gt;%&lt;/code&gt; は剰余演算子です。</target>
        </trans-unit>
        <trans-unit id="d79893a1ef0fe5a790c5d1bb686e33bb258470f4" translate="yes" xml:space="preserve">
          <source>In Julia, most operators are just functions with support for special syntax. (The exceptions are operators with special evaluation semantics like &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt;. These operators cannot be functions since &lt;a href=&quot;../control-flow/index#Short-Circuit-Evaluation&quot;&gt;Short-Circuit Evaluation&lt;/a&gt; requires that their operands are not evaluated before evaluation of the operator.) Accordingly, you can also apply them using parenthesized argument lists, just as you would any other function:</source>
          <target state="translated">Juliaでは、ほとんどの演算子は特別な構文をサポートする単なる関数です。（例外は、 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; や &lt;code&gt;||&lt;/code&gt; などの特別な評価セマンティクスを持つ演算子です。Short &lt;a href=&quot;../control-flow/index#Short-Circuit-Evaluation&quot;&gt;-CircuitEvaluation&lt;/a&gt;では、演算子の評価前にオペランドを評価しない必要があるため、これらの演算子を関数にすることはできません。）したがって、括弧で囲まれた引数リストを使用して適用することもできます。 、他の関数と同じように：</target>
        </trans-unit>
        <trans-unit id="2e2622d04790dce54d4881a8ca271df72d322df7" translate="yes" xml:space="preserve">
          <source>In Julia, most operators are just functions with support for special syntax. (The exceptions are operators with special evaluation semantics like &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt;. These operators cannot be functions since &lt;a href=&quot;../control-flow/index#Short-Circuit-Evaluation-1&quot;&gt;Short-Circuit Evaluation&lt;/a&gt; requires that their operands are not evaluated before evaluation of the operator.) Accordingly, you can also apply them using parenthesized argument lists, just as you would any other function:</source>
          <target state="translated">Juliaでは、ほとんどの演算子は特別な構文をサポートする関数にすぎません。 （例外は &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; や &lt;code&gt;||&lt;/code&gt; のような特別な評価セマンティクスを持つ演算子です。&lt;a href=&quot;../control-flow/index#Short-Circuit-Evaluation-1&quot;&gt;短絡&lt;/a&gt;評価では、演算子の評価前にオペランドを評価しない必要があるため、これらの演算子を関数にすることはできません。）したがって、括弧で囲まれた引数リストを使用して演算子を適用することもできます。 、他の関数と同じように：</target>
        </trans-unit>
        <trans-unit id="cec708186271fab31b28911da66c39fb5ef32d0d" translate="yes" xml:space="preserve">
          <source>In Julia, multiple values are returned and assigned as tuples, e.g. &lt;code&gt;(a, b) = (1, 2)&lt;/code&gt; or &lt;code&gt;a, b = 1, 2&lt;/code&gt;. MATLAB's &lt;code&gt;nargout&lt;/code&gt;, which is often used in MATLAB to do optional work based on the number of returned values, does not exist in Julia. Instead, users can use optional and keyword arguments to achieve similar capabilities.</source>
          <target state="translated">Juliaでは、複数の値が返され、タプルとして割り当てられます（例： &lt;code&gt;(a, b) = (1, 2)&lt;/code&gt; または &lt;code&gt;a, b = 1, 2&lt;/code&gt; 。戻り値の数に基づいてオプションの作業を行うためにMATLABでよく使用されるMATLABの &lt;code&gt;nargout&lt;/code&gt; は、Juliaには存在しません。代わりに、ユーザーはオプションの引数とキーワード引数を使用して、同様の機能を実現できます。</target>
        </trans-unit>
        <trans-unit id="4f6861a8c923af27ce752544647b06d9e6a0a07e" translate="yes" xml:space="preserve">
          <source>In Julia, not all data structures support logical indexing. Furthermore, logical indexing in Julia is supported only with vectors of length equal to the object being indexed. For example:</source>
          <target state="translated">Julia では、すべてのデータ構造が論理インデックスをサポートしているわけではありません。さらに、ジュリアでの論理インデキシングは、インデキシングされているオブジェクトと等しい長さのベクトルでのみサポートされています。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="451c3e5bbe0419b361a11d608a26c62bcc892288" translate="yes" xml:space="preserve">
          <source>In Julia, one returns a tuple of values to simulate returning multiple values. However, tuples can be created and destructured without needing parentheses, thereby providing an illusion that multiple values are being returned, rather than a single tuple value. For example, the following function returns a pair of values:</source>
          <target state="translated">Julia では、複数の値を返すことをシミュレートするために、値のタプルを返します。しかし、タプルは括弧を必要とせずに作成したり破壊したりすることができるので、単一のタプル値ではなく複数の値が返されているかのような錯覚を与えます。例えば、以下の関数は値のペアを返します。</target>
        </trans-unit>
        <trans-unit id="d1f236e7a8645aa4ffbd134429aa159fdbc206da" translate="yes" xml:space="preserve">
          <source>In Julia, parentheses must be used to call a function with zero arguments, like in &lt;a href=&quot;../../stdlib/random/index#Base.rand&quot;&gt;&lt;code&gt;rand()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Juliaでは、&lt;a href=&quot;../../stdlib/random/index#Base.rand&quot;&gt; &lt;code&gt;rand()&lt;/code&gt; の&lt;/a&gt;ように、引数をゼロにして関数を呼び出すには括弧を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="b62993ba8b73165f19053f9f6eaf87bfbe97454f" translate="yes" xml:space="preserve">
          <source>In Julia, reductions such as &lt;a href=&quot;../../base/collections/index#Base.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/collections/index#Base.prod&quot;&gt;&lt;code&gt;prod&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../base/math/index#Base.max&quot;&gt;&lt;code&gt;max&lt;/code&gt;&lt;/a&gt; are performed over every element of an array when called with a single argument, as in &lt;code&gt;sum(A)&lt;/code&gt;, even if &lt;code&gt;A&lt;/code&gt; has more than one dimension.</source>
          <target state="translated">ジュリアでは、などの還元&lt;a href=&quot;../../base/collections/index#Base.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../base/collections/index#Base.prod&quot;&gt; &lt;code&gt;prod&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;../../base/math/index#Base.max&quot;&gt; &lt;code&gt;max&lt;/code&gt; は&lt;/a&gt;、単一の引数で呼び出されたときのように、配列の各要素にわたって行われる &lt;code&gt;sum(A)&lt;/code&gt; としても、 &lt;code&gt;A&lt;/code&gt; が複数の寸法を有します。</target>
        </trans-unit>
        <trans-unit id="6b1973243505286be855fb241367233be8bd84fa" translate="yes" xml:space="preserve">
          <source>In Julia, sparse matrices are stored in the &lt;a href=&quot;https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_column_.28CSC_or_CCS.29&quot;&gt;Compressed Sparse Column (CSC) format&lt;/a&gt;. Julia sparse matrices have the type &lt;a href=&quot;#SparseArrays.SparseMatrixCSC&quot;&gt;&lt;code&gt;SparseMatrixCSC{Tv,Ti}&lt;/code&gt;&lt;/a&gt;, where &lt;code&gt;Tv&lt;/code&gt; is the type of the stored values, and &lt;code&gt;Ti&lt;/code&gt; is the integer type for storing column pointers and row indices. The internal representation of &lt;code&gt;SparseMatrixCSC&lt;/code&gt; is as follows:</source>
          <target state="translated">Juliaでは、スパース行列は&lt;a href=&quot;https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_column_.28CSC_or_CCS.29&quot;&gt;圧縮スパース列（CSC）形式で&lt;/a&gt;格納されます。ジュリアスパース行列は、タイプ有する&lt;a href=&quot;#SparseArrays.SparseMatrixCSC&quot;&gt; &lt;code&gt;SparseMatrixCSC{Tv,Ti}&lt;/code&gt; &lt;/a&gt;、 &lt;code&gt;Tv&lt;/code&gt; が格納された値のタイプであり、および &lt;code&gt;Ti&lt;/code&gt; はカラムポインタと行インデックスを格納する整数型です。 &lt;code&gt;SparseMatrixCSC&lt;/code&gt; の内部表現は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="a5c3c759720c16030d42ce9ed7346415b8cda62d" translate="yes" xml:space="preserve">
          <source>In Julia, the &lt;code&gt;adjoint&lt;/code&gt; function performs conjugate transposition; in MATLAB, &lt;code&gt;adjoint&lt;/code&gt; provides the &quot;adjugate&quot; or classical adjoint, which is the transpose of the matrix of cofactors.</source>
          <target state="translated">ジュリアでは、 &lt;code&gt;adjoint&lt;/code&gt; 関数が共役転置を実行します。MATLABでは、 &lt;code&gt;adjoint&lt;/code&gt; は「余因子」または古典的な随伴を提供します。これは、補因子の行列の転置です。</target>
        </trans-unit>
        <trans-unit id="1e8bc1ec2e65356b67489d496d41c529e84e8334" translate="yes" xml:space="preserve">
          <source>In Julia, the binding of a variable &lt;code&gt;x&lt;/code&gt; cannot be changed by passing &lt;code&gt;x&lt;/code&gt; as an argument to a function. When calling &lt;code&gt;change_value!(x)&lt;/code&gt; in the above example, &lt;code&gt;y&lt;/code&gt; is a newly created variable, bound initially to the value of &lt;code&gt;x&lt;/code&gt;, i.e. &lt;code&gt;10&lt;/code&gt;; then &lt;code&gt;y&lt;/code&gt; is rebound to the constant &lt;code&gt;17&lt;/code&gt;, while the variable &lt;code&gt;x&lt;/code&gt; of the outer scope is left untouched.</source>
          <target state="translated">Juliaでは、変数 &lt;code&gt;x&lt;/code&gt; のバインディングは、 &lt;code&gt;x&lt;/code&gt; を引数として関数に渡しても変更できません。上記の例で &lt;code&gt;change_value!(x)&lt;/code&gt; を呼び出す場合、 &lt;code&gt;y&lt;/code&gt; は新しく作成された変数であり、最初に &lt;code&gt;x&lt;/code&gt; の値、つまり &lt;code&gt;10&lt;/code&gt; にバインドされます。次に、 &lt;code&gt;y&lt;/code&gt; は定数 &lt;code&gt;17&lt;/code&gt; にリバインドされますが、外側のスコープの変数 &lt;code&gt;x&lt;/code&gt; は変更されません。</target>
        </trans-unit>
        <trans-unit id="e2d42d83a28f2989051e64390c6b07102af77a3d" translate="yes" xml:space="preserve">
          <source>In Julia, the commonly used &lt;code&gt;Int&lt;/code&gt; type corresponds to the machine integer type (&lt;code&gt;Int32&lt;/code&gt; or &lt;code&gt;Int64&lt;/code&gt;), unlike in Python, where &lt;code&gt;int&lt;/code&gt; is an arbitrary length integer. This means in Julia the &lt;code&gt;Int&lt;/code&gt; type will overflow, such that &lt;code&gt;2^64 == 0&lt;/code&gt;. If you need larger values use another appropriate type, such as &lt;code&gt;Int128&lt;/code&gt;, &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; or a floating point type like &lt;code&gt;Float64&lt;/code&gt;.</source>
          <target state="translated">Juliaでは、 &lt;code&gt;int&lt;/code&gt; が任意の長さの整数であるPythonとは異なり、一般的に使用される &lt;code&gt;Int&lt;/code&gt; 型はマシン整数型（ &lt;code&gt;Int32&lt;/code&gt; または &lt;code&gt;Int64&lt;/code&gt; ）に対応します。これは、ジュリアでは &lt;code&gt;Int&lt;/code&gt; 型がオーバーフローし、 &lt;code&gt;2^64 == 0&lt;/code&gt; なることを意味します。あなたは、より大きな値が必要な場合など、他の適切な種類、使用 &lt;code&gt;Int128&lt;/code&gt; 、&lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; 型&lt;/a&gt;など浮動小数点型 &lt;code&gt;Float64&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7ad2abcec621eb10f8cdb25e242afd4f9efd6dd1" translate="yes" xml:space="preserve">
          <source>In Julia, the elements of a collection can be passed as arguments to a function using the splat operator &lt;code&gt;...&lt;/code&gt;, as in &lt;code&gt;xs=[1,2]; f(xs...)&lt;/code&gt;.</source>
          <target state="translated">Juliaでは、 &lt;code&gt;xs=[1,2]; f(xs...)&lt;/code&gt; ように、スプラット演算子 &lt;code&gt;...&lt;/code&gt; を使用して、コレクションの要素を引数として関数に渡すことができます。f（xs ...）。</target>
        </trans-unit>
        <trans-unit id="d494edc49792467615a5bbbdd57215d8dd338e99" translate="yes" xml:space="preserve">
          <source>In Julia, the exponentiation operator is &lt;code&gt;^&lt;/code&gt;, not &lt;code&gt;**&lt;/code&gt; as in Python.</source>
          <target state="translated">Juliaでは、べき乗演算子は &lt;code&gt;^&lt;/code&gt; であり、Pythonのように &lt;code&gt;**&lt;/code&gt; ではありません。</target>
        </trans-unit>
        <trans-unit id="93d049ffcb952000d0f8ebc0a66e0ee55d575d87" translate="yes" xml:space="preserve">
          <source>In Julia, the operator &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt;&lt;code&gt;⊻&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt;&lt;code&gt;xor&lt;/code&gt;&lt;/a&gt;) performs the bitwise XOR operation, i.e. &lt;code&gt;^&lt;/code&gt; in C/C++. Also, the bitwise operators do not have the same precedence as C/++, so parenthesis may be required.</source>
          <target state="translated">Juliaでは、演算子&lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt; &lt;code&gt;⊻&lt;/code&gt; &lt;/a&gt;（&lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt; &lt;code&gt;xor&lt;/code&gt; &lt;/a&gt;）はビット単位のXOR演算を実行します（C / C ++では &lt;code&gt;^&lt;/code&gt; )。また、ビットごとの演算子の優先順位はC / ++と同じではないため、括弧が必要になる場合があります。</target>
        </trans-unit>
        <trans-unit id="8490fa684242627635a34751122775551824f7e6" translate="yes" xml:space="preserve">
          <source>In Julia, the operators &lt;a href=&quot;../../base/math/index#Base.:&amp;amp;&quot;&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;|&lt;/code&gt;, and &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt;&lt;code&gt;⊻&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt;&lt;code&gt;xor&lt;/code&gt;&lt;/a&gt;) perform the bitwise operations equivalent to &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt;, and &lt;code&gt;xor&lt;/code&gt; respectively in MATLAB, and have precedence similar to Python's bitwise operators (unlike C). They can operate on scalars or element-wise across arrays and can be used to combine logical arrays, but note the difference in order of operations: parentheses may be required (e.g., to select elements of &lt;code&gt;A&lt;/code&gt; equal to 1 or 2 use &lt;code&gt;(A .== 1) .| (A .== 2)&lt;/code&gt;).</source>
          <target state="translated">ジュリアでは、演算子&lt;a href=&quot;../../base/math/index#Base.:&amp;amp;&quot;&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;/a&gt;、 &lt;code&gt;|&lt;/code&gt; 、および&lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt; &lt;code&gt;⊻&lt;/code&gt; &lt;/a&gt;（&lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt; &lt;code&gt;xor&lt;/code&gt; &lt;/a&gt;）は、MATLABでそれぞれ &lt;code&gt;and&lt;/code&gt; 、 &lt;code&gt;or&lt;/code&gt; 、および &lt;code&gt;xor&lt;/code&gt; と同等のビット単位演算を実行し、Pythonのビット単位演算子（Cとは異なります）と同様の優先順位を持っています。これらはスカラーまたは配列全体の要素単位で操作でき、論理配列を組み合わせるために使用できますが、操作の順序の違いに注意してください：括弧が必要な場合があります（たとえば、 &lt;code&gt;A&lt;/code&gt; の要素を1または2に選択するために使用する &lt;code&gt;(A .== 1) .| (A .== 2)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="1e2a4d55a36175a20161ae921b2cf660cd6f7ede" translate="yes" xml:space="preserve">
          <source>In Julia, the standard operators over a matrix type are matrix operations, whereas, in Python, the standard operators are element-wise operations. When both &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are matrices, &lt;code&gt;A * B&lt;/code&gt; in Julia performs matrix multiplication, not element-wise multiplication as in Python. &lt;code&gt;A * B&lt;/code&gt; in Julia is equivalent with &lt;code&gt;A @ B&lt;/code&gt; in Python, whereas &lt;code&gt;A * B&lt;/code&gt; in Python is equivalent with &lt;code&gt;A .* B&lt;/code&gt; in Julia.</source>
          <target state="translated">Juliaでは、行列型の標準演算子は行列演算ですが、Pythonでは、標準演算子は要素単位の演算です。 &lt;code&gt;A&lt;/code&gt; と &lt;code&gt;B&lt;/code&gt; の両方が行列の場合、Juliaの &lt;code&gt;A * B&lt;/code&gt; は、Pythonのように要素ごとの乗算ではなく、行列の乗算を実行します。Juliaの &lt;code&gt;A * B&lt;/code&gt; はPythonの &lt;code&gt;A @ B&lt;/code&gt; と同等ですが、Pythonの &lt;code&gt;A .* B&lt;/code&gt; はJuliaの &lt;code&gt;A * B&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="c924b695c23524838be4cdefba6d4ecf3f12bd7f" translate="yes" xml:space="preserve">
          <source>In Julia, values are not copied when assigned or passed to a function. If a function modifies an array, the changes will be visible in the caller. This is very different from R and allows new functions to operate on large data structures much more efficiently.</source>
          <target state="translated">Juliaでは、関数に代入されたり渡されたりしても、値はコピーされません。関数が配列を変更した場合、その変更は呼び出し元に表示されます。これはRとは大きく異なり、新しい関数が大きなデータ構造をより効率的に操作できるようになります。</target>
        </trans-unit>
        <trans-unit id="4125f91a0372e71681729284bfb74b1b5f121b87" translate="yes" xml:space="preserve">
          <source>In Julia, varargs are specified using the splat operator &lt;code&gt;...&lt;/code&gt;, which always follows the name of a specific variable, unlike R, for which &lt;code&gt;...&lt;/code&gt; can occur in isolation.</source>
          <target state="translated">Juliaでは、可変引数は、splat演算子 &lt;code&gt;...&lt;/code&gt; を使用して指定されます。これは、Rとは異なり、 &lt;code&gt;...&lt;/code&gt; が単独で発生する場合があるため、特定の変数の名前の後に常に続きます。</target>
        </trans-unit>
        <trans-unit id="61706e2cf7e3e0b63c2023adcea629882d9748dd" translate="yes" xml:space="preserve">
          <source>In Julia, vectors and matrices are concatenated using &lt;a href=&quot;../../base/arrays/index#Base.hcat&quot;&gt;&lt;code&gt;hcat&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/arrays/index#Base.vcat&quot;&gt;&lt;code&gt;vcat&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/arrays/index#Base.hvcat&quot;&gt;&lt;code&gt;hvcat&lt;/code&gt;&lt;/a&gt;, not &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;rbind&lt;/code&gt; and &lt;code&gt;cbind&lt;/code&gt; like in R.</source>
          <target state="translated">ジュリアでは、ベクトルと行列を用いて連結され&lt;a href=&quot;../../base/arrays/index#Base.hcat&quot;&gt; &lt;code&gt;hcat&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../base/arrays/index#Base.vcat&quot;&gt; &lt;code&gt;vcat&lt;/code&gt; &lt;/a&gt;及び&lt;a href=&quot;../../base/arrays/index#Base.hvcat&quot;&gt; &lt;code&gt;hvcat&lt;/code&gt; &lt;/a&gt;なく、 &lt;code&gt;c&lt;/code&gt; 、 &lt;code&gt;rbind&lt;/code&gt; と &lt;code&gt;cbind&lt;/code&gt; R.のよう</target>
        </trans-unit>
        <trans-unit id="c15bdde6dec6d1761a5dc60f223d32d1ac186e83" translate="yes" xml:space="preserve">
          <source>In Julia, we can access the parts independently to make a copy of that string:</source>
          <target state="translated">Juliaでは、パーツを独立してアクセスして、その文字列のコピーを作成することができます。</target>
        </trans-unit>
        <trans-unit id="8bbe2d9f25b242e167641a97cc1e17c904778314" translate="yes" xml:space="preserve">
          <source>In Julia, whitespace is significant, unlike C/C++, so care must be taken when adding/removing whitespace from a Julia program.</source>
          <target state="translated">Julia では C/C++とは異なり、空白は重要な意味を持つので、Julia プログラムに空白を追加したり削除したりする際には注意が必要です。</target>
        </trans-unit>
        <trans-unit id="dfd2a6192ce5ab720952e7ded70bfe43e1c2837a" translate="yes" xml:space="preserve">
          <source>In Julia, you can't dispatch on a &lt;em&gt;value&lt;/em&gt; such as &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. However, you can dispatch on parametric types, and Julia allows you to include &quot;plain bits&quot; values (Types, Symbols, Integers, floating-point numbers, tuples, etc.) as type parameters. A common example is the dimensionality parameter in &lt;code&gt;Array{T,N}&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is a type (e.g., &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;) but &lt;code&gt;N&lt;/code&gt; is just an &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">Juliaでは、 &lt;code&gt;true&lt;/code&gt; や &lt;code&gt;false&lt;/code&gt; などの&lt;em&gt;値で&lt;/em&gt;ディスパッチすることはできません。ただし、パラメトリックタイプでディスパッチでき、Juliaでは「プレーンビット」値（タイプ、シンボル、整数、浮動小数点数、タプルなど）をタイプパラメータとして含めることができます。一般的な例は、 &lt;code&gt;Array{T,N}&lt;/code&gt; の次元パラメーターです。ここで、 &lt;code&gt;T&lt;/code&gt; は型（&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; など&lt;/a&gt;）ですが、 &lt;code&gt;N&lt;/code&gt; は単なる &lt;code&gt;Int&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="0987332b373dba2f6dccb678d104e0da95c47a9e" translate="yes" xml:space="preserve">
          <source>In MATLAB, an idiomatic way to remove unwanted values is to use logical indexing, like in the expression &lt;code&gt;x(x&amp;gt;3)&lt;/code&gt; or in the statement &lt;code&gt;x(x&amp;gt;3) = []&lt;/code&gt; to modify &lt;code&gt;x&lt;/code&gt; in-place. In contrast, Julia provides the higher order functions &lt;a href=&quot;../../base/collections/index#Base.filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt;&lt;code&gt;filter!&lt;/code&gt;&lt;/a&gt;, allowing users to write &lt;code&gt;filter(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; and &lt;code&gt;filter!(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; as alternatives to the corresponding transliterations &lt;code&gt;x[x.&amp;gt;3]&lt;/code&gt; and &lt;code&gt;x = x[x.&amp;gt;3]&lt;/code&gt;. Using &lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt;&lt;code&gt;filter!&lt;/code&gt;&lt;/a&gt; reduces the use of temporary arrays.</source>
          <target state="translated">MATLABでは、不要な値を削除する慣用的な方法は、式 &lt;code&gt;x(x&amp;gt;3)&lt;/code&gt; またはステートメント &lt;code&gt;x(x&amp;gt;3) = []&lt;/code&gt; ように論理インデックスを使用して、 &lt;code&gt;x&lt;/code&gt; をインプレースで変更することです。対照的に、ジュリアはより高次の関数&lt;a href=&quot;../../base/collections/index#Base.filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt; &lt;code&gt;filter!&lt;/code&gt; &lt;/a&gt;提供します！、対応する音訳 &lt;code&gt;x[x.&amp;gt;3]&lt;/code&gt; および &lt;code&gt;x = x[x.&amp;gt;3]&lt;/code&gt; 代わりに &lt;code&gt;filter(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; および &lt;code&gt;filter!(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; をユーザーが記述できるようにします。 3]。&lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt; &lt;code&gt;filter!&lt;/code&gt; &lt;/a&gt;使用！一時配列の使用を減らします。</target>
        </trans-unit>
        <trans-unit id="af1c31248c4802059b749cc923a13d7acffd80c9" translate="yes" xml:space="preserve">
          <source>In Python, the majority of values can be used in logical contexts (e.g. &lt;code&gt;if &quot;a&quot;:&lt;/code&gt; means the following block is executed, and &lt;code&gt;if &quot;&quot;:&lt;/code&gt; means it is not). In Julia, you need explicit conversion to &lt;code&gt;Bool&lt;/code&gt; (e.g. &lt;code&gt;if &quot;a&quot;&lt;/code&gt; throws an exception). If you want to test for a non-empty string in Julia, you would explicitly write &lt;code&gt;if !isempty(&quot;&quot;)&lt;/code&gt;.</source>
          <target state="translated">Pythonでは、値の大部分は、論理的文脈において使用することができる（例えば、 &lt;code&gt;if &quot;a&quot;:&lt;/code&gt; 次のブロックが実行されることを意味し、 &lt;code&gt;if &quot;&quot;:&lt;/code&gt; それはないことを意味）。Juliaでは、 &lt;code&gt;Bool&lt;/code&gt; への明示的な変換が必要です（たとえば &lt;code&gt;if &quot;a&quot;&lt;/code&gt; が例外をスローした場合）。Juliaで空でない文字列をテストする &lt;code&gt;if !isempty(&quot;&quot;)&lt;/code&gt; 明示的に記述します。</target>
        </trans-unit>
        <trans-unit id="6e02ea871ca138515cbf18e7481d0fb87b2d5244" translate="yes" xml:space="preserve">
          <source>In R, &lt;code&gt;c(1, 2, 3, 4)[c(TRUE, FALSE)]&lt;/code&gt; is equivalent to &lt;code&gt;c(1, 3)&lt;/code&gt;.</source>
          <target state="translated">Rでは、 &lt;code&gt;c(1, 2, 3, 4)[c(TRUE, FALSE)]&lt;/code&gt; は &lt;code&gt;c(1, 3)&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="616e3b4685be805ef30bd44974ee4d2b22ae8fea" translate="yes" xml:space="preserve">
          <source>In R, &lt;code&gt;c(1, 2, 3, 4)[c(TRUE, FALSE, TRUE, FALSE)]&lt;/code&gt; is equivalent to &lt;code&gt;c(1, 3)&lt;/code&gt;.</source>
          <target state="translated">Rでは、 &lt;code&gt;c(1, 2, 3, 4)[c(TRUE, FALSE, TRUE, FALSE)]&lt;/code&gt; は &lt;code&gt;c(1, 3)&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="ce0a60c169bc6c80688de200a5cb77dbd4fa3448" translate="yes" xml:space="preserve">
          <source>In R, an idiomatic way to remove unwanted values is to use logical indexing, like in the expression &lt;code&gt;x[x&amp;gt;3]&lt;/code&gt; or in the statement &lt;code&gt;x = x[x&amp;gt;3]&lt;/code&gt; to modify &lt;code&gt;x&lt;/code&gt; in-place. In contrast, Julia provides the higher order functions &lt;a href=&quot;../../base/collections/index#Base.filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt;&lt;code&gt;filter!&lt;/code&gt;&lt;/a&gt;, allowing users to write &lt;code&gt;filter(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; and &lt;code&gt;filter!(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; as alternatives to the corresponding transliterations &lt;code&gt;x[x.&amp;gt;3]&lt;/code&gt; and &lt;code&gt;x = x[x.&amp;gt;3]&lt;/code&gt;. Using &lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt;&lt;code&gt;filter!&lt;/code&gt;&lt;/a&gt; reduces the use of temporary arrays.</source>
          <target state="translated">Rでは、不要な値を削除する慣用的な方法は、式 &lt;code&gt;x[x&amp;gt;3]&lt;/code&gt; またはステートメント &lt;code&gt;x = x[x&amp;gt;3]&lt;/code&gt; ように論理インデックスを使用して、 &lt;code&gt;x&lt;/code&gt; をインプレースで変更することです。対照的に、ジュリアはより高次の関数&lt;a href=&quot;../../base/collections/index#Base.filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt; &lt;code&gt;filter!&lt;/code&gt; &lt;/a&gt;提供します！、対応する音訳 &lt;code&gt;x[x.&amp;gt;3]&lt;/code&gt; および &lt;code&gt;x = x[x.&amp;gt;3]&lt;/code&gt; 代わりに &lt;code&gt;filter(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; および &lt;code&gt;filter!(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; をユーザーが記述できるようにします。 3]。&lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt; &lt;code&gt;filter!&lt;/code&gt; &lt;/a&gt;使用！一時配列の使用を減らします。</target>
        </trans-unit>
        <trans-unit id="f6752ab2f8e0e7630531a6d7a1987e0bbb17b890" translate="yes" xml:space="preserve">
          <source>In R, performance requires vectorization. In Julia, almost the opposite is true: the best performing code is often achieved by using devectorized loops.</source>
          <target state="translated">Rでは、パフォーマンスにはベクトル化が必要です。Juliaでは、ほとんど逆のことが言えます:最高のパフォーマンスを発揮するコードは、多くの場合、デバイス化されたループを使用することで達成されます。</target>
        </trans-unit>
        <trans-unit id="01878b8d1b390512d629c49ff65589c19ca63ad8" translate="yes" xml:space="preserve">
          <source>In a linear-algebra context, this means that even though operations like &lt;code&gt;vector + vector&lt;/code&gt; and &lt;code&gt;vector * scalar&lt;/code&gt; are defined, it can be advantageous to instead use &lt;code&gt;vector .+ vector&lt;/code&gt; and &lt;code&gt;vector .* scalar&lt;/code&gt; because the resulting loops can be fused with surrounding computations. For example, consider the two functions:</source>
          <target state="translated">線形代数のコンテキストでは、これは、 &lt;code&gt;vector + vector&lt;/code&gt; および &lt;code&gt;vector * scalar&lt;/code&gt; ような演算が定義されている場合でも、結果のループが周囲の計算と融合できるため、代わりに &lt;code&gt;vector .+ vector&lt;/code&gt; および &lt;code&gt;vector .* scalar&lt;/code&gt; 使用することが有利な場合があることを意味します。たとえば、次の2つの関数について考えます。</target>
        </trans-unit>
        <trans-unit id="9e1d6d725f550ad6f9da6bf98cc247f18f2108d6" translate="yes" xml:space="preserve">
          <source>In a local scope, all variables are inherited from its parent global scope block unless:</source>
          <target state="translated">ローカルスコープでは、すべての変数は親グローバルスコープブロックから継承されます。</target>
        </trans-unit>
        <trans-unit id="8fb94127a63695dc8bd7c2b91c9aa1704119e38b" translate="yes" xml:space="preserve">
          <source>In a module, declare that the file specified by &lt;code&gt;path&lt;/code&gt; (relative or absolute) is a dependency for precompilation; that is, the module will need to be recompiled if this file changes.</source>
          <target state="translated">モジュールで、 &lt;code&gt;path&lt;/code&gt; （相対または絶対）で指定されたファイルがプリコンパイルの依存関係であることを宣言します。つまり、このファイルが変更された場合、モジュールを再コンパイルする必要があります。</target>
        </trans-unit>
        <trans-unit id="ba39320cdec145895823bcc997669a25a6af7855" translate="yes" xml:space="preserve">
          <source>In a sense, Julia falls into the &quot;no automatic promotion&quot; category: mathematical operators are just functions with special syntax, and the arguments of functions are never automatically converted. However, one may observe that applying mathematical operations to a wide variety of mixed argument types is just an extreme case of polymorphic multiple dispatch &amp;ndash; something which Julia's dispatch and type systems are particularly well-suited to handle. &quot;Automatic&quot; promotion of mathematical operands simply emerges as a special application: Julia comes with pre-defined catch-all dispatch rules for mathematical operators, invoked when no specific implementation exists for some combination of operand types. These catch-all rules first promote all operands to a common type using user-definable promotion rules, and then invoke a specialized implementation of the operator in question for the resulting values, now of the same type. User-defined types can easily participate in this promotion system by defining methods for conversion to and from other types, and providing a handful of promotion rules defining what types they should promote to when mixed with other types.</source>
          <target state="translated">ある意味では、ジュリアは「自動昇格なし」のカテゴリに分類されます。数学演算子は特別な構文を持つ関数であり、関数の引数が自動的に変換されることはありません。ただし、多種多様な混合引数型に数学演算を適用することは、ポリモーフィックな複数のディスパッチの極端なケースにすぎないことに気づくかもしれません。これは、ジュリアのディスパッチおよび型システムの処理に特に適しています。数学的オペランドの「自動」プロモーションは、単に特別なアプリケーションとして出現します。Juliaには、オペランドタイプの特定の組み合わせの特定の実装が存在しない場合に呼び出される、数学的演算子の定義済みキャッチオールディスパッチルールが付属しています。これらのキャッチオールルールは、まずユーザー定義可能なプロモーションルールを使用して、すべてのオペランドを共通の型にプロモートします。次に、結果として同じ値の結果の値に対して、問題の演算子の特殊な実装を呼び出します。ユーザー定義タイプは、他のタイプとの間の変換方法を定義し、他のタイプと混合したときにどのタイプにプロモートするかを定義する少数のプロモーションルールを提供することにより、このプロモーションシステムに簡単に参加できます。</target>
        </trans-unit>
        <trans-unit id="c6a6dfe6183c6c2d1bbad1fc9762d95e2e3097dd" translate="yes" xml:space="preserve">
          <source>In a similar fashion as to how one can define keyword arguments programmatically, a named tuple can be created by giving a pair &lt;code&gt;name::Symbol =&amp;gt; value&lt;/code&gt; or splatting an iterator yielding such pairs after a semicolon inside a tuple literal:</source>
          <target state="translated">プログラムでキーワード引数を定義する方法と同様に、名前付きタプルは、ペア &lt;code&gt;name::Symbol =&amp;gt; value&lt;/code&gt; か、タプルリテラル内のセミコロンの後にそのようなペアを生成するイテレータをスプラッティングすることで作成できます。</target>
        </trans-unit>
        <trans-unit id="18e44910a826a7be9fd86ad6a5c3ed3f73d517fa" translate="yes" xml:space="preserve">
          <source>In addition to (and as part of) its support for multi-dimensional arrays, Julia provides native implementations of many common and useful linear algebra operations which can be loaded with &lt;code&gt;using LinearAlgebra&lt;/code&gt;. Basic operations, such as &lt;a href=&quot;#LinearAlgebra.tr&quot;&gt;&lt;code&gt;tr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#LinearAlgebra.det&quot;&gt;&lt;code&gt;det&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;inv&lt;/code&gt; are all supported:</source>
          <target state="translated">Juliaは、多次元配列のサポートに加えて（およびその一部として）、 &lt;code&gt;using LinearAlgebra&lt;/code&gt; を使用してロードできる多くの一般的で有用な線形代数演算のネイティブ実装を提供します。&lt;a href=&quot;#LinearAlgebra.tr&quot;&gt; &lt;code&gt;tr&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#LinearAlgebra.det&quot;&gt; &lt;code&gt;det&lt;/code&gt; &lt;/a&gt;、 &lt;code&gt;inv&lt;/code&gt; などの基本的な操作はすべてサポートされています。</target>
        </trans-unit>
        <trans-unit id="f10487aa88c806dfd44fdee05bfc7281d910b478" translate="yes" xml:space="preserve">
          <source>In addition to &lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt;&lt;code&gt;yieldto&lt;/code&gt;&lt;/a&gt;, a few other basic functions are needed to use tasks effectively.</source>
          <target state="translated">&lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt; &lt;code&gt;yieldto&lt;/code&gt; &lt;/a&gt;に加えて、タスクを効果的に使用するためにいくつかの他の基本的な関数が必要です。</target>
        </trans-unit>
        <trans-unit id="f2ab7ee40bd53e11319399c116d8d2cc2c48169d" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;using Base&lt;/code&gt;, modules also automatically contain definitions of the &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/base/index#Base.MainInclude.include&quot;&gt;&lt;code&gt;include&lt;/code&gt;&lt;/a&gt; functions, which evaluate expressions/files within the global scope of that module.</source>
          <target state="translated">&lt;code&gt;using Base&lt;/code&gt; 加えて、モジュールには&lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt; &lt;code&gt;eval&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;../../base/base/index#Base.MainInclude.include&quot;&gt; &lt;code&gt;include&lt;/code&gt; &lt;/a&gt;関数の定義が自動的に含まれ、そのモジュールのグローバルスコープ内で式/ファイルを評価します。</target>
        </trans-unit>
        <trans-unit id="10d21e803c8a9917ec9f0f6ebe5595e193060fc6" translate="yes" xml:space="preserve">
          <source>In addition to all the iterable and indexable methods from above, these types can also interact with each other and use most of the methods defined in Julia Base for &lt;code&gt;AbstractArrays&lt;/code&gt;:</source>
          <target state="translated">上記のすべての反復可能でインデックス可能なメソッドに加えて、これらのタイプは互いに相互作用し、Julia Base for &lt;code&gt;AbstractArrays&lt;/code&gt; で定義されているほとんどのメソッドを使用できます。</target>
        </trans-unit>
        <trans-unit id="e406211c0c63c531f5fd9ccb75f3528a5be0658c" translate="yes" xml:space="preserve">
          <source>In addition to linear indexing, an &lt;code&gt;N&lt;/code&gt;-dimensional array may be indexed with fewer or more than &lt;code&gt;N&lt;/code&gt; indices in certain situations.</source>
          <target state="translated">線形インデックス付けに加えて、特定の状況では、 &lt;code&gt;N&lt;/code&gt; 次元配列に &lt;code&gt;N&lt;/code&gt; インデックスより少ないまたは多いインデックスを付けることができます。</target>
        </trans-unit>
        <trans-unit id="98e86e056613a088089dad092fe39f17f798108b" translate="yes" xml:space="preserve">
          <source>In addition to tasks Julia forwards natively supports multi-threading. Note that this section is experimental and the interfaces may change in the future.</source>
          <target state="translated">タスクに加えて、Julia forwards はマルチスレッドをネイティブにサポートしています。このセクションは実験的なものであり、将来的にインターフェースが変更される可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="ec666f0e17f38401053d73ee95bfc69ad9a82cc3" translate="yes" xml:space="preserve">
          <source>In addition to the given argument list, every macro is passed extra arguments named &lt;code&gt;__source__&lt;/code&gt; and &lt;code&gt;__module__&lt;/code&gt;.</source>
          <target state="translated">指定された引数リストに加えて、すべてのマクロには &lt;code&gt;__source__&lt;/code&gt; および &lt;code&gt;__module__&lt;/code&gt; という名前の追加の引数が渡されます。</target>
        </trans-unit>
        <trans-unit id="f681189a6c7a87dd61774b09673a55a0c0fa70a2" translate="yes" xml:space="preserve">
          <source>In addition, Julia provides many &lt;a href=&quot;#man-linalg-factorizations&quot;&gt;factorizations&lt;/a&gt; which can be used to speed up problems such as linear solve or matrix exponentiation by pre-factorizing a matrix into a form more amenable (for performance or memory reasons) to the problem. See the documentation on &lt;a href=&quot;#LinearAlgebra.factorize&quot;&gt;&lt;code&gt;factorize&lt;/code&gt;&lt;/a&gt; for more information. As an example:</source>
          <target state="translated">さらに、Juliaは、行列を（パフォーマンスまたはメモリの理由で）問題に適した形式に事前因数分解することにより、線形解法や行列指数関数などの問題を高速化するために使用できる多くの&lt;a href=&quot;#man-linalg-factorizations&quot;&gt;因数分解&lt;/a&gt;を提供します。詳細については、&lt;a href=&quot;#LinearAlgebra.factorize&quot;&gt; &lt;code&gt;factorize&lt;/code&gt; &lt;/a&gt;に関するドキュメントを参照してください。例として：</target>
        </trans-unit>
        <trans-unit id="24215bb3919d42188faab69329d0bd6705349ee5" translate="yes" xml:space="preserve">
          <source>In addition, Julia provides many &lt;a href=&quot;#man-linalg-factorizations-1&quot;&gt;factorizations&lt;/a&gt; which can be used to speed up problems such as linear solve or matrix exponentiation by pre-factorizing a matrix into a form more amenable (for performance or memory reasons) to the problem. See the documentation on &lt;a href=&quot;#LinearAlgebra.factorize&quot;&gt;&lt;code&gt;factorize&lt;/code&gt;&lt;/a&gt; for more information. As an example:</source>
          <target state="translated">さらに、Juliaは多くの&lt;a href=&quot;#man-linalg-factorizations-1&quot;&gt;因数分解&lt;/a&gt;を提供します。これを使用して、行列を問題に対して（パフォーマンスまたはメモリ上の理由から）より扱いやすい形式に事前因数分解することにより、線形解や行列の指数化などの問題を高速化できます。詳細については、&lt;a href=&quot;#LinearAlgebra.factorize&quot;&gt; &lt;code&gt;factorize&lt;/code&gt; &lt;/a&gt;のドキュメントを参照してください。例として：</target>
        </trans-unit>
        <trans-unit id="655d29ad2536f5920e2f78273e9aa1a0a062ab22" translate="yes" xml:space="preserve">
          <source>In all cases the ambiguity is resolved in favor of interpretation as numeric literals:</source>
          <target state="translated">いずれの場合も、曖昧さは数値リテラルとして解釈することに有利に解決される。</target>
        </trans-unit>
        <trans-unit id="73ededace2cf23e632ef0400ebd52a78d322cb00" translate="yes" xml:space="preserve">
          <source>In all of the above modes, the executed lines get saved to a history file, which can be searched. To initiate an incremental search through the previous history, type &lt;code&gt;^R&lt;/code&gt; &amp;ndash; the control key together with the &lt;code&gt;r&lt;/code&gt; key. The prompt will change to &lt;code&gt;(reverse-i-search)`':&lt;/code&gt;, and as you type the search query will appear in the quotes. The most recent result that matches the query will dynamically update to the right of the colon as more is typed. To find an older result using the same query, simply type &lt;code&gt;^R&lt;/code&gt; again.</source>
          <target state="translated">上記のすべてのモードで、実行された行は履歴ファイルに保存され、検索できます。以前の履歴からインクリメンタル検索を開始するには、 &lt;code&gt;^R&lt;/code&gt; &amp;ndash; &lt;code&gt;r&lt;/code&gt; キーと一緒にコントロールキーを入力します。プロンプトが &lt;code&gt;(reverse-i-search)`':&lt;/code&gt; に変わり、入力すると検索クエリが引用符で囲まれて表示されます。クエリに一致する最新の結果は、さらに入力するとコロンの右側に動的に更新されます。同じクエリを使用して古い結果を見つけるには、もう一度 &lt;code&gt;^R&lt;/code&gt; と入力します。</target>
        </trans-unit>
        <trans-unit id="486b6c3b28f75c69ec1138bc26e8cd5e151040ee" translate="yes" xml:space="preserve">
          <source>In all of these cases, &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; ultimately operates on a &lt;a href=&quot;../../base/parallel/index#Base.Condition&quot;&gt;&lt;code&gt;Condition&lt;/code&gt;&lt;/a&gt; object, which is in charge of queueing and restarting tasks. When a task calls &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; on a &lt;a href=&quot;../../base/parallel/index#Base.Condition&quot;&gt;&lt;code&gt;Condition&lt;/code&gt;&lt;/a&gt;, the task is marked as non-runnable, added to the condition's queue, and switches to the scheduler. The scheduler will then pick another task to run, or block waiting for external events. If all goes well, eventually an event handler will call &lt;a href=&quot;../../base/parallel/index#Base.notify&quot;&gt;&lt;code&gt;notify&lt;/code&gt;&lt;/a&gt; on the condition, which causes tasks waiting for that condition to become runnable again.</source>
          <target state="translated">これらすべてのケースで、&lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;最終的にタスクのキューイングと再起動を担当する&lt;a href=&quot;../../base/parallel/index#Base.Condition&quot;&gt; &lt;code&gt;Condition&lt;/code&gt; &lt;/a&gt;オブジェクトで動作します。タスクコールが&lt;a href=&quot;../../base/parallel/index#Base.Condition&quot;&gt; &lt;code&gt;Condition&lt;/code&gt; &lt;/a&gt;で&lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;する場合、タスクは実行不可としてマークされ、条件のキューに追加され、スケジューラに切り替わります。スケジューラーは、実行する別のタスクを選択するか、外部イベントの待機をブロックします。すべてが順調に進んだ場合、最終的にイベントハンドラーが条件に対して&lt;a href=&quot;../../base/parallel/index#Base.notify&quot;&gt; &lt;code&gt;notify&lt;/code&gt; &lt;/a&gt;を呼び出します。これにより、その条件を待機しているタスクが再び実行可能になります。</target>
        </trans-unit>
        <trans-unit id="a3a06ca6a5caa39934e953da1e9f4336d389c6e0" translate="yes" xml:space="preserve">
          <source>In all these cases, &lt;code&gt;x&lt;/code&gt; is bound to a tuple of the trailing values passed to &lt;code&gt;bar&lt;/code&gt;.</source>
          <target state="translated">これらすべての場合で、 &lt;code&gt;x&lt;/code&gt; は &lt;code&gt;bar&lt;/code&gt; に渡される後続の値のタプルにバインドされます。</target>
        </trans-unit>
        <trans-unit id="b99ce256d318c1c2f2354f48619a6804a821c4e0" translate="yes" xml:space="preserve">
          <source>In an all-to-all topology (the default), all workers connect to each other via plain TCP sockets. The security policy on the cluster nodes must thus ensure free connectivity between workers for the ephemeral port range (varies by OS).</source>
          <target state="translated">all-to-all トポロジ(デフォルト)では、すべてのワーカーはプレーンTCPソケットを介して相互に接続します。このため、クラスタノードのセキュリティポリシーは、(OSによって異なりますが)エフェメラルポート範囲のワーカー間の自由な接続性を確保する必要があります。</target>
        </trans-unit>
        <trans-unit id="3c8cda3e1e2865b38c43f81658a24d808d5fe92a" translate="yes" xml:space="preserve">
          <source>In both Julia and MATLAB, the variable &lt;code&gt;ans&lt;/code&gt; is set to the value of the last expression issued in an interactive session. In Julia, unlike MATLAB, &lt;code&gt;ans&lt;/code&gt; is not set when Julia code is run in non-interactive mode.</source>
          <target state="translated">JuliaとMATLABの両方で、変数 &lt;code&gt;ans&lt;/code&gt; はインタラクティブセッションで発行された最後の式の値に設定されます。 Juliaでは、MATLABとは異なり、Juliaコードが非インタラクティブモードで実行されている場合、 &lt;code&gt;ans&lt;/code&gt; は設定されません。</target>
        </trans-unit>
        <trans-unit id="b8e4ada1bafffe80f21502163f1a66167c6265bb" translate="yes" xml:space="preserve">
          <source>In both the Julian and help modes of the REPL, one can enter the first few characters of a function or type and then press the tab key to get a list all matches:</source>
          <target state="translated">REPLのジュリアンとヘルプモードの両方で、1つは、関数またはタイプの最初の数文字を入力してから、すべての一致するリストを取得するためにタブキーを押すことができます。</target>
        </trans-unit>
        <trans-unit id="661336deabc49d6bd089fab9e0056b342efe5561" translate="yes" xml:space="preserve">
          <source>In case of remote references, the size of the local reference object is quite small, while the value stored on the remote node may be quite large. Since the local object may not be collected immediately, it is a good practice to explicitly call &lt;a href=&quot;../../base/base/index#Base.finalize&quot;&gt;&lt;code&gt;finalize&lt;/code&gt;&lt;/a&gt; on local instances of a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt;, or on unfetched &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt;s. Since calling &lt;code&gt;fetch&lt;/code&gt; on a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; also removes its reference from the remote store, this is not required on fetched &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt;s. Explicitly calling &lt;a href=&quot;../../base/base/index#Base.finalize&quot;&gt;&lt;code&gt;finalize&lt;/code&gt;&lt;/a&gt; results in an immediate message sent to the remote node to go ahead and remove its reference to the value.</source>
          <target state="translated">リモート参照の場合、ローカル参照オブジェクトのサイズは非常に小さく、リモートノードに格納されている値は非常に大きい場合があります。ローカルオブジェクトはすぐに収集されない可能性があるため、&lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; の&lt;/a&gt;ローカルインスタンスまたはフェッチされていない&lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt;で&lt;a href=&quot;../../base/base/index#Base.finalize&quot;&gt; &lt;code&gt;finalize&lt;/code&gt; &lt;/a&gt;を明示的に呼び出すことをお勧めします。呼び出し以来 &lt;code&gt;fetch&lt;/code&gt; に&lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt;、リモートストアからその参照を削除し、これはフェッチに必要とされていない&lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt;の。&lt;a href=&quot;../../base/base/index#Base.finalize&quot;&gt; &lt;code&gt;finalize&lt;/code&gt; &lt;/a&gt;を明示的に呼び出すと、リモートノードに即時メッセージが送信され、値への参照が削除されます。</target>
        </trans-unit>
        <trans-unit id="bf07799a9aab60dca9abdd6af2de0083f4fd55f9" translate="yes" xml:space="preserve">
          <source>In cases where &lt;a href=&quot;../base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt; would need to take a Julia object and turn it into a &lt;code&gt;Ptr&lt;/code&gt;, this function should be used to define and perform that conversion.</source>
          <target state="translated">&lt;a href=&quot;../base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt; Juliaオブジェクトを取得して &lt;code&gt;Ptr&lt;/code&gt; に変換する必要がある場合は、この関数を使用して変換を定義および実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="62d2a9fdaaf73a0db81376306b368d8784225fa7" translate="yes" xml:space="preserve">
          <source>In cases where &lt;code&gt;x&lt;/code&gt; cannot be safely converted to &lt;code&gt;T&lt;/code&gt;, unlike &lt;a href=&quot;../base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;cconvert&lt;/code&gt; may return an object of a type different from &lt;code&gt;T&lt;/code&gt;, which however is suitable for &lt;a href=&quot;#Base.unsafe_convert&quot;&gt;&lt;code&gt;unsafe_convert&lt;/code&gt;&lt;/a&gt; to handle. The result of this function should be kept valid (for the GC) until the result of &lt;a href=&quot;#Base.unsafe_convert&quot;&gt;&lt;code&gt;unsafe_convert&lt;/code&gt;&lt;/a&gt; is not needed anymore. This can be used to allocate memory that will be accessed by the &lt;code&gt;ccall&lt;/code&gt;. If multiple objects need to be allocated, a tuple of the objects can be used as return value.</source>
          <target state="translated">ケースでは &lt;code&gt;x&lt;/code&gt; 安全に変換できない &lt;code&gt;T&lt;/code&gt; とは異なり&lt;a href=&quot;../base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt;、 &lt;code&gt;cconvert&lt;/code&gt; はからタイプ別のオブジェクトを返すことができる &lt;code&gt;T&lt;/code&gt; が適している、&lt;a href=&quot;#Base.unsafe_convert&quot;&gt; &lt;code&gt;unsafe_convert&lt;/code&gt; &lt;/a&gt;ハンドルを。この関数の結果は、&lt;a href=&quot;#Base.unsafe_convert&quot;&gt; &lt;code&gt;unsafe_convert&lt;/code&gt; &lt;/a&gt;の結果が不要になるまで（GCに対して）有効なままにしておく必要があります。これは、 &lt;code&gt;ccall&lt;/code&gt; がアクセスするメモリを割り当てるために使用できます。複数のオブジェクトを割り当てる必要がある場合は、オブジェクトのタプルを戻り値として使用できます。</target>
        </trans-unit>
        <trans-unit id="20a6a008693353a3bba07852d46b5ac7a61ffe13" translate="yes" xml:space="preserve">
          <source>In cases where you want to be able to mix multiple &lt;code&gt;AbstractArrayStyle&lt;/code&gt;s and keep track of dimensionality, your style needs to support a &lt;a href=&quot;../base/index#Base.Val&quot;&gt;&lt;code&gt;Val&lt;/code&gt;&lt;/a&gt; constructor:</source>
          <target state="translated">複数の &lt;code&gt;AbstractArrayStyle&lt;/code&gt; を混合して次元を追跡できるようにする場合は、スタイルで&lt;a href=&quot;../base/index#Base.Val&quot;&gt; &lt;code&gt;Val&lt;/code&gt; &lt;/a&gt;コンストラクタをサポートする必要があります。</target>
        </trans-unit>
        <trans-unit id="371183813ad83fb61979b332a5033cb1b76e325b" translate="yes" xml:space="preserve">
          <source>In code that performs state changes or uses resources like files, there is typically clean-up work (such as closing files) that needs to be done when the code is finished. Exceptions potentially complicate this task, since they can cause a block of code to exit before reaching its normal end. The &lt;code&gt;finally&lt;/code&gt; keyword provides a way to run some code when a given block of code exits, regardless of how it exits.</source>
          <target state="translated">状態の変更を実行するコードや、ファイルなどのリソースを使用するコードでは、通常、コードの終了時に実行する必要があるクリーンアップ作業（ファイルを閉じるなど）があります。例外は、コードブロックが正常終了する前に終了する可能性があるため、このタスクを複雑にする可能性があります。 &lt;code&gt;finally&lt;/code&gt; 、キーワードのコード出口の与えられたブロックにかかわらず、それが出てどのように、いくつかのコードを実行する方法を提供します。</target>
        </trans-unit>
        <trans-unit id="439d8b30359bbc8d6b7d18a09ea082d188e37311" translate="yes" xml:space="preserve">
          <source>In contrast to the use of the &lt;code&gt;...&lt;/code&gt; operator to denote slurping many different arguments into one argument when defining a function, the &lt;code&gt;...&lt;/code&gt; operator is also used to cause a single function argument to be split apart into many different arguments when used in the context of a function call. This use of &lt;code&gt;...&lt;/code&gt; is called splatting:</source>
          <target state="translated">関数を定義するときに &lt;code&gt;...&lt;/code&gt; 演算子を使用して多くの異なる引数を1つの引数に丸めることを示すのとは対照的に、 &lt;code&gt;...&lt;/code&gt; 演算子は、単一の関数引数を使用時に複数の異なる引数に分割するためにも使用されます関数呼び出しのコンテキスト。この &lt;code&gt;...&lt;/code&gt; の使用はスプラッティングと呼ばれます。</target>
        </trans-unit>
        <trans-unit id="9c8f753b1f6a1a771efd3464599b303870131486" translate="yes" xml:space="preserve">
          <source>In contrast with &lt;code&gt;for i = 1:length(A)&lt;/code&gt;, iterating with &lt;a href=&quot;../../base/arrays/index#Base.eachindex&quot;&gt;&lt;code&gt;eachindex&lt;/code&gt;&lt;/a&gt; provides an efficient way to iterate over any array type.</source>
          <target state="translated">&lt;code&gt;for i = 1:length(A)&lt;/code&gt; とは対照的に、&lt;a href=&quot;../../base/arrays/index#Base.eachindex&quot;&gt; &lt;code&gt;eachindex&lt;/code&gt; &lt;/a&gt;での反復は、あらゆる配列型を反復する効率的な方法を提供します。</target>
        </trans-unit>
        <trans-unit id="7142e8f2e408ab35102cc379780cf0e33b4e8234" translate="yes" xml:space="preserve">
          <source>In contrast, once &lt;code&gt;m&lt;/code&gt; is constructed, the type of &lt;code&gt;m.a&lt;/code&gt; cannot change:</source>
          <target state="translated">対照的に、 &lt;code&gt;m&lt;/code&gt; が構築されると、 &lt;code&gt;m.a&lt;/code&gt; のタイプは変更できません。</target>
        </trans-unit>
        <trans-unit id="0d5137a043d33963d37d01766416ca959609cfd8" translate="yes" xml:space="preserve">
          <source>In general you can place a &lt;code&gt;return&lt;/code&gt; statement anywhere within a function body, including within deeply nested loops or conditionals, but be careful with &lt;code&gt;do&lt;/code&gt; blocks. For example:</source>
          <target state="translated">一般に、深くネストされたループや条件文など、関数本体内の任意の場所に &lt;code&gt;return&lt;/code&gt; ステートメントを配置できますが、 &lt;code&gt;do&lt;/code&gt; ブロックには注意してください。例えば：</target>
        </trans-unit>
        <trans-unit id="c2d6d0431d403e66982fc3bf0664898813b75b58" translate="yes" xml:space="preserve">
          <source>In general, a broadcast operation is represented by a lazy &lt;code&gt;Broadcasted&lt;/code&gt; container that holds onto the function to be applied alongside its arguments. Those arguments may themselves be more nested &lt;code&gt;Broadcasted&lt;/code&gt; containers, forming a large expression tree to be evaluated. A nested tree of &lt;code&gt;Broadcasted&lt;/code&gt; containers is directly constructed by the implicit dot syntax; &lt;code&gt;5 .+ 2.*x&lt;/code&gt; is transiently represented by &lt;code&gt;Broadcasted(+, 5, Broadcasted(*, 2, x))&lt;/code&gt;, for example. This is invisible to users as it is immediately realized through a call to &lt;code&gt;copy&lt;/code&gt;, but it is this container that provides the basis for broadcast's extensibility for authors of custom types. The built-in broadcast machinery will then determine the result type and size based upon the arguments, allocate it, and then finally copy the realization of the &lt;code&gt;Broadcasted&lt;/code&gt; object into it with a default &lt;code&gt;copyto!(::AbstractArray, ::Broadcasted)&lt;/code&gt; method. The built-in fallback &lt;code&gt;broadcast&lt;/code&gt; and &lt;code&gt;broadcast!&lt;/code&gt; methods similarly construct a transient &lt;code&gt;Broadcasted&lt;/code&gt; representation of the operation so they can follow the same codepath. This allows custom array implementations to provide their own &lt;code&gt;copyto!&lt;/code&gt; specialization to customize and optimize broadcasting. This is again determined by the computed broadcast style. This is such an important part of the operation that it is stored as the first type parameter of the &lt;code&gt;Broadcasted&lt;/code&gt; type, allowing for dispatch and specialization.</source>
          <target state="translated">一般に、ブロードキャスト操作は、引数とともに適用される関数を保持する遅延 &lt;code&gt;Broadcasted&lt;/code&gt; コンテナで表されます。これらの引数自体は、ネストされた &lt;code&gt;Broadcasted&lt;/code&gt; コンテナであり、評価される大きな式ツリーを形成します。 &lt;code&gt;Broadcasted&lt;/code&gt; コンテナのネストされたツリーは、暗黙のドット構文によって直接構築されます。 &lt;code&gt;5 .+ 2.*x&lt;/code&gt; は、たとえば &lt;code&gt;Broadcasted(+, 5, Broadcasted(*, 2, x))&lt;/code&gt; によって一時的に表されます。これは、 &lt;code&gt;copy&lt;/code&gt; の呼び出しを通じてすぐに実現されるため、ユーザーには見えません。ですが、カスタムタイプの作成者にブロードキャストの拡張性の基礎を提供するのはこのコンテナです。組み込みのブロードキャスト機構は、引数に基づいて結果のタイプとサイズを決定し、それを割り当て、最後に、デフォルトの &lt;code&gt;copyto!(::AbstractArray, ::Broadcasted)&lt;/code&gt; メソッドを使用して &lt;code&gt;Broadcasted&lt;/code&gt; オブジェクトの実現をそれにコピーします。内蔵のフォールバック &lt;code&gt;broadcast&lt;/code&gt; と &lt;code&gt;broadcast!&lt;/code&gt; メソッドも同様に、操作の一時的な &lt;code&gt;Broadcasted&lt;/code&gt; 表現を構築するため、同じコードパスをたどることができます。これにより、カスタム配列実装が独自の &lt;code&gt;copyto!&lt;/code&gt; を提供できるようになります。放送をカスタマイズおよび最適化する専門分野。これも、計算されたブロードキャストスタイルによって決まります。これは、 &lt;code&gt;Broadcasted&lt;/code&gt; 型の最初の型パラメーターとして格納される操作の重要な部分であり、ディスパッチと特殊化を可能にします。</target>
        </trans-unit>
        <trans-unit id="8d1babd281f2e672316bf23dea36c5ab29827a0a" translate="yes" xml:space="preserve">
          <source>In general, if you have &lt;code&gt;N&lt;/code&gt; samples collected at a line, you can expect an uncertainty on the order of &lt;code&gt;sqrt(N)&lt;/code&gt; (barring other sources of noise, like how busy the computer is with other tasks). The major exception to this rule is garbage collection, which runs infrequently but tends to be quite expensive. (Since Julia's garbage collector is written in C, such events can be detected using the &lt;code&gt;C=true&lt;/code&gt; output mode described below, or by using &lt;a href=&quot;https://github.com/timholy/ProfileView.jl&quot;&gt;ProfileView.jl&lt;/a&gt;.)</source>
          <target state="translated">一般に、ラインで &lt;code&gt;N&lt;/code&gt; 個のサンプルを収集した場合、 &lt;code&gt;sqrt(N)&lt;/code&gt; の次数に不確実性が生じることが予想されます（コンピューターが他のタスクでビジー状態であることなど、他のノイズソースを除く）。このルールの主な例外はガベージコレクションです。ガベージコレクションは実行頻度は低いですが、かなり高価になる傾向があります。 （JuliaのガベージコレクターはCで記述されているため、このようなイベントは、以下で説明する &lt;code&gt;C=true&lt;/code&gt; 出力モードを使用するか、&lt;a href=&quot;https://github.com/timholy/ProfileView.jl&quot;&gt;ProfileView.jl&lt;/a&gt;を使用して検出できます。）</target>
        </trans-unit>
        <trans-unit id="efbd7c168e8e9417f99b66ae892e749285151330" translate="yes" xml:space="preserve">
          <source>In general, the &lt;code&gt;for&lt;/code&gt; loop construct can iterate over any container. In these cases, the alternative (but fully equivalent) keyword &lt;code&gt;in&lt;/code&gt; or &lt;code&gt;&amp;isin;&lt;/code&gt; is typically used instead of &lt;code&gt;=&lt;/code&gt;, since it makes the code read more clearly:</source>
          <target state="translated">一般に、 &lt;code&gt;for&lt;/code&gt; ループ構造は任意のコンテナーに対して反復できます。これらのケースでは、代替的な（しかし、完全に等価）はキーワード &lt;code&gt;in&lt;/code&gt; 又は &lt;code&gt;&amp;isin;&lt;/code&gt; 典型的に使用される代わりの &lt;code&gt;=&lt;/code&gt; は、コードがより明確に読み取ることができるので、：</target>
        </trans-unit>
        <trans-unit id="e63801e02d1bdf10fcfad068986ce15007cba3d8" translate="yes" xml:space="preserve">
          <source>In general, the Julia backtick syntax is carefully designed so that you can just cut-and-paste shell commands as is into backticks and they will work: the escaping, quoting, and interpolation behaviors are the same as the shell's. The only difference is that the interpolation is integrated and aware of Julia's notion of what is a single string value, and what is a container for multiple values. Let's try the above two examples in Julia:</source>
          <target state="translated">一般的に、Julia のバックティック構文は注意深く設計されており、シェルコマンドをそのままバックティックにカットアンドペーストするだけで動作します:エスケープ、クォート、補間の動作はシェルのものと同じです。唯一の違いは、補間が統合されており、何が単一の文字列の値で、何が複数の値のためのコンテナであるかというジュリアの概念を認識していることです。上記2つの例をJuliaで試してみましょう。</target>
        </trans-unit>
        <trans-unit id="e9d0a19dc1691ca7e9543783f1a58a636105f54f" translate="yes" xml:space="preserve">
          <source>In general, unlike many other technical computing languages, Julia does not expect programs to be written in a vectorized style for performance. Julia's compiler uses type inference and generates optimized code for scalar array indexing, allowing programs to be written in a style that is convenient and readable, without sacrificing performance, and using less memory at times.</source>
          <target state="translated">一般的に、他の多くの技術的な計算言語とは異なり、Juliaは性能を犠牲にすることなく、プログラムがベクトル化されたスタイルで書かれることを期待していません。Julia のコンパイラは型推論を使用し、スカラ配列のインデキシングのために最適化されたコードを生成するので、プログラムを便利で読みやすいスタイルで書くことができ、性能を犠牲にすることなく、時には少ないメモリ使用量でプログラムを書くことができます。</target>
        </trans-unit>
        <trans-unit id="0aca2d8ec448ee15667ecd2efa9a783d316a76f6" translate="yes" xml:space="preserve">
          <source>In general, you cannot assume that &lt;code&gt;display&lt;/code&gt; output goes to &lt;code&gt;stdout&lt;/code&gt; (unlike &lt;a href=&quot;#Base.print&quot;&gt;&lt;code&gt;print(x)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;show(x)&lt;/code&gt;&lt;/a&gt;). For example, &lt;code&gt;display(x)&lt;/code&gt; may open up a separate window with an image. &lt;code&gt;display(x)&lt;/code&gt; means &quot;show &lt;code&gt;x&lt;/code&gt; in the best way you can for the current output device(s).&quot; If you want REPL-like text output that is guaranteed to go to &lt;code&gt;stdout&lt;/code&gt;, use &lt;a href=&quot;#Base.show-Tuple%7BAny,Any,Any%7D&quot;&gt;&lt;code&gt;show(stdout, &quot;text/plain&quot;, x)&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">一般に、（&lt;a href=&quot;#Base.print&quot;&gt; &lt;code&gt;print(x)&lt;/code&gt; &lt;/a&gt;や&lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;show(x)&lt;/code&gt; &lt;/a&gt;とは異なり） &lt;code&gt;display&lt;/code&gt; 出力が &lt;code&gt;stdout&lt;/code&gt; に送られるとは想定できません。たとえば、 &lt;code&gt;display(x)&lt;/code&gt; は画像を含む別のウィンドウを開く場合があります。 &lt;code&gt;display(x)&lt;/code&gt; は、「 &lt;code&gt;x&lt;/code&gt; を現在の出力デバイスに対して可能な限り最良の方法で表示する」ことを意味します。あなたがしたい場合はREPLのように移動することが保証されてテキスト出力 &lt;code&gt;stdout&lt;/code&gt; 、使用&lt;a href=&quot;#Base.show-Tuple%7BAny,Any,Any%7D&quot;&gt; &lt;code&gt;show(stdout, &quot;text/plain&quot;, x)&lt;/code&gt; &lt;/a&gt;代わりに。</target>
        </trans-unit>
        <trans-unit id="7ec09f4dcceb1c007da785592e4c12f3a7b2638d" translate="yes" xml:space="preserve">
          <source>In general, you cannot assume that &lt;code&gt;display&lt;/code&gt; output goes to &lt;code&gt;stdout&lt;/code&gt; (unlike &lt;a href=&quot;#Base.print&quot;&gt;&lt;code&gt;print(x)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Base.show-Tuple%7BIO,Any%7D&quot;&gt;&lt;code&gt;show(x)&lt;/code&gt;&lt;/a&gt;). For example, &lt;code&gt;display(x)&lt;/code&gt; may open up a separate window with an image. &lt;code&gt;display(x)&lt;/code&gt; means &quot;show &lt;code&gt;x&lt;/code&gt; in the best way you can for the current output device(s).&quot; If you want REPL-like text output that is guaranteed to go to &lt;code&gt;stdout&lt;/code&gt;, use &lt;a href=&quot;#Base.show-Tuple%7BIO,Any%7D&quot;&gt;&lt;code&gt;show(stdout, &quot;text/plain&quot;, x)&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">一般に、 &lt;code&gt;display&lt;/code&gt; 出力が &lt;code&gt;stdout&lt;/code&gt; に送られると想定することはできません（&lt;a href=&quot;#Base.print&quot;&gt; &lt;code&gt;print(x)&lt;/code&gt; &lt;/a&gt;や&lt;a href=&quot;#Base.show-Tuple%7BIO,Any%7D&quot;&gt; &lt;code&gt;show(x)&lt;/code&gt; &lt;/a&gt;とは異なります）。たとえば、 &lt;code&gt;display(x)&lt;/code&gt; は、画像を含む別のウィンドウを開く場合があります。 &lt;code&gt;display(x)&lt;/code&gt; 手段「のショーは、 &lt;code&gt;x&lt;/code&gt; は現在の出力デバイス（複数可）のためにあなたができる最善の方法で。」あなたがしたい場合はREPLのように移動することが保証されてテキスト出力 &lt;code&gt;stdout&lt;/code&gt; 、使用&lt;a href=&quot;#Base.show-Tuple%7BIO,Any%7D&quot;&gt; &lt;code&gt;show(stdout, &quot;text/plain&quot;, x)&lt;/code&gt; &lt;/a&gt;代わりに。</target>
        </trans-unit>
        <trans-unit id="421d35772a37767957f94e34c887a2a8d79cd54e" translate="yes" xml:space="preserve">
          <source>In interpreting the results, there are a few important details. Under the &lt;code&gt;user&lt;/code&gt; setting, the first line of any function directly called from the REPL will exhibit allocation due to events that happen in the REPL code itself. More significantly, JIT-compilation also adds to allocation counts, because much of Julia's compiler is written in Julia (and compilation usually requires memory allocation). The recommended procedure is to force compilation by executing all the commands you want to analyze, then call &lt;a href=&quot;../../stdlib/profile/index#Profile.clear_malloc_data&quot;&gt;&lt;code&gt;Profile.clear_malloc_data()&lt;/code&gt;&lt;/a&gt; to reset all allocation counters. Finally, execute the desired commands and quit Julia to trigger the generation of the &lt;code&gt;.mem&lt;/code&gt; files.</source>
          <target state="translated">結果の解釈には、いくつかの重要な詳細があります。下では &lt;code&gt;user&lt;/code&gt; 設定、直接REPLから呼び出される任意の関数の最初の行が原因REPLコード自体に発生するイベントへの割り当てを示すであろう。さらに重要なことに、Juliaのコンパイラの多くはJuliaで記述されているため（通常、コンパイルにはメモリの割り当てが必要です）、JITコンパイルによって割り当て数も増えます。推奨される手順は、分析するすべてのコマンドを実行してコンパイルを強制し、&lt;a href=&quot;../../stdlib/profile/index#Profile.clear_malloc_data&quot;&gt; &lt;code&gt;Profile.clear_malloc_data()&lt;/code&gt; &lt;/a&gt;を呼び出してすべての割り当てカウンターをリセットすることです。最後に、必要なコマンドを実行してJuliaを終了し、 &lt;code&gt;.mem&lt;/code&gt; ファイルの生成をトリガーします。</target>
        </trans-unit>
        <trans-unit id="dfcc306e80c7cf321f53ff98ff95ac030d502bfd" translate="yes" xml:space="preserve">
          <source>In loops and &lt;a href=&quot;../arrays/index#man-comprehensions&quot;&gt;comprehensions&lt;/a&gt;, new variables introduced in their body scopes are freshly allocated for each loop iteration, as if the loop body were surrounded by a &lt;code&gt;let&lt;/code&gt; block, as demonstrated by this example:</source>
          <target state="translated">ループと&lt;a href=&quot;../arrays/index#man-comprehensions&quot;&gt;内包表記では&lt;/a&gt;、次の例に示すように、本体スコープに導入された新しい変数が、ループ本体が &lt;code&gt;let&lt;/code&gt; ブロックで囲まれているかのように、ループの反復ごとに新たに割り当てられます。</target>
        </trans-unit>
        <trans-unit id="1b38f63219b850b33b9abc3b16ad8edd611a5f30" translate="yes" xml:space="preserve">
          <source>In mainstream object oriented languages, such as C++, Java, Python and Ruby, composite types also have named functions associated with them, and the combination is called an &quot;object&quot;. In purer object-oriented languages, such as Ruby or Smalltalk, all values are objects whether they are composites or not. In less pure object oriented languages, including C++ and Java, some values, such as integers and floating-point values, are not objects, while instances of user-defined composite types are true objects with associated methods. In Julia, all values are objects, but functions are not bundled with the objects they operate on. This is necessary since Julia chooses which method of a function to use by multiple dispatch, meaning that the types of &lt;em&gt;all&lt;/em&gt; of a function's arguments are considered when selecting a method, rather than just the first one (see &lt;a href=&quot;../methods/index#Methods&quot;&gt;Methods&lt;/a&gt; for more information on methods and dispatch). Thus, it would be inappropriate for functions to &quot;belong&quot; to only their first argument. Organizing methods into function objects rather than having named bags of methods &quot;inside&quot; each object ends up being a highly beneficial aspect of the language design.</source>
          <target state="translated">C ++、Java、Python、Rubyなどの主流のオブジェクト指向言語では、複合型にも名前付き関数が関連付けられており、その組み合わせは「オブジェクト」と呼ばれます。 RubyやSmalltalkなどのより純粋なオブジェクト指向言語では、複合値であるかどうかに関係なく、すべての値はオブジェクトです。 C ++やJavaなど、純粋性の低いオブジェクト指向言語では、整数や浮動小数点値などの一部の値はオブジェクトではありませんが、ユーザー定義の複合型のインスタンスは、メソッドが関連付けられた真のオブジェクトです。 Juliaでは、すべての値はオブジェクトですが、関数は操作対象のオブジェクトにバンドルされていません。ジュリアは多重ディスパッチで使用する関数のメソッドを選択するため、これが必要です。つまり、&lt;em&gt;すべて&lt;/em&gt;のタイプが&lt;em&gt;&lt;/em&gt;メソッドを選択するときは、最初の引数だけでなく、関数の引数の数が考慮されます（メソッドとディスパッチの詳細については、「&lt;a href=&quot;../methods/index#Methods&quot;&gt;メソッド」&lt;/a&gt;を参照してください）。したがって、関数が最初の引数だけに「属する」ことは不適切です。メソッドのバッグに各オブジェクトの「内部」に名前を付けるのではなく、メソッドを関数オブジェクトに編成することは、言語設計の非常に有益な側面になります。</target>
        </trans-unit>
        <trans-unit id="76e2766644f11aec36d4590582770e2731974fc5" translate="yes" xml:space="preserve">
          <source>In mainstream object oriented languages, such as C++, Java, Python and Ruby, composite types also have named functions associated with them, and the combination is called an &quot;object&quot;. In purer object-oriented languages, such as Ruby or Smalltalk, all values are objects whether they are composites or not. In less pure object oriented languages, including C++ and Java, some values, such as integers and floating-point values, are not objects, while instances of user-defined composite types are true objects with associated methods. In Julia, all values are objects, but functions are not bundled with the objects they operate on. This is necessary since Julia chooses which method of a function to use by multiple dispatch, meaning that the types of &lt;em&gt;all&lt;/em&gt; of a function's arguments are considered when selecting a method, rather than just the first one (see &lt;a href=&quot;../methods/index#Methods-1&quot;&gt;Methods&lt;/a&gt; for more information on methods and dispatch). Thus, it would be inappropriate for functions to &quot;belong&quot; to only their first argument. Organizing methods into function objects rather than having named bags of methods &quot;inside&quot; each object ends up being a highly beneficial aspect of the language design.</source>
          <target state="translated">C ++、Java、Python、Rubyなどの主流のオブジェクト指向言語では、複合型にも名前付きの関数が関連付けられており、その組み合わせは「オブジェクト」と呼ばれます。 RubyやSmalltalkなどの純粋なオブジェクト指向言語では、すべての値は、コンポジットであるかどうかに関係なくオブジェクトです。 C ++やJavaなどのそれほど純粋ではないオブジェクト指向言語では、整数や浮動小数点値などの一部の値はオブジェクトではありませんが、ユーザー定義の複合型のインスタンスは、関連するメソッドを持つ真のオブジェクトです。 Juliaでは、すべての値はオブジェクトですが、関数は、それらが操作するオブジェクトにバンドルされていません。これはつまり、どの複数派遣して、使用する機能の方法ジュリア選択しますので、必要があるのタイプ&lt;em&gt;すべて&lt;/em&gt;関数を選択するときは、最初の引数ではなく、関数の引数の1つが考慮されます（メソッドとディスパッチの詳細については、&lt;a href=&quot;../methods/index#Methods-1&quot;&gt;メソッド&lt;/a&gt;を参照してください）。したがって、関数が最初の引数だけに「属する」ことは不適切です。メソッドの名前付きバッグを各オブジェクトの「内部」に置くのではなく、メソッドを関数オブジェクトに編成すると、言語設計の非常に有益な側面になります。</target>
        </trans-unit>
        <trans-unit id="eae8b05ff1c12682f8c0f5b0dacd56bde327dcb6" translate="yes" xml:space="preserve">
          <source>In many cases there are in-place versions of matrix operations that allow you to supply a pre-allocated output vector or matrix. This is useful when optimizing critical code in order to avoid the overhead of repeated allocations. These in-place operations are suffixed with &lt;code&gt;!&lt;/code&gt; below (e.g. &lt;code&gt;mul!&lt;/code&gt;) according to the usual Julia convention.</source>
          <target state="translated">多くの場合、事前に割り当てられた出力ベクトルまたは行列を提供できる行列演算のインプレースバージョンがあります。これは、繰り返し割り当てのオーバーヘッドを回避するために重要なコードを最適化するときに役立ちます。これらのインプレース操作には、末尾に &lt;code&gt;!&lt;/code&gt; 通常のJuliaの慣例に従って、以下（例 &lt;code&gt;mul!&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="1ed441529eec7f43ad66971217220df4ecd80a6e" translate="yes" xml:space="preserve">
          <source>In many cases, Julia is able to automatically vectorize inner for loops without the use of &lt;code&gt;@simd&lt;/code&gt;. Using &lt;code&gt;@simd&lt;/code&gt; gives the compiler a little extra leeway to make it possible in more situations. In either case, your inner loop should have the following properties to allow vectorization:</source>
          <target state="translated">多くの場合、Juliaは &lt;code&gt;@simd&lt;/code&gt; を使用せずに内部forループを自動的にベクトル化できます。 &lt;code&gt;@simd&lt;/code&gt; を使用すると、より多くの状況でそれを可能にするためにコンパイラに少し余分な余裕が与えられます。どちらの場合でも、ベクトル化を可能にするために、内部ループには次のプロパティが必要です。</target>
        </trans-unit>
        <trans-unit id="36269174e578550d7d7f0601c4aea1c6ce0438f9" translate="yes" xml:space="preserve">
          <source>In many cases, function arguments have sensible default values and therefore might not need to be passed explicitly in every call. For example, the function &lt;a href=&quot;../../stdlib/dates/index#Dates.Date&quot;&gt;&lt;code&gt;Date(y, [m, d])&lt;/code&gt;&lt;/a&gt; from &lt;code&gt;Dates&lt;/code&gt; module constructs a &lt;code&gt;Date&lt;/code&gt; type for a given year &lt;code&gt;y&lt;/code&gt;, month &lt;code&gt;m&lt;/code&gt; and day &lt;code&gt;d&lt;/code&gt;. However, &lt;code&gt;m&lt;/code&gt; and &lt;code&gt;d&lt;/code&gt; arguments are optional and their default value is &lt;code&gt;1&lt;/code&gt;. This behavior can be expressed concisely as:</source>
          <target state="translated">多くの場合、関数の引数には適切なデフォルト値があるため、すべての呼び出しで明示的に渡す必要がない場合があります。たとえば、 &lt;code&gt;Dates&lt;/code&gt; モジュールの関数&lt;a href=&quot;../../stdlib/dates/index#Dates.Date&quot;&gt; &lt;code&gt;Date(y, [m, d])&lt;/code&gt; &lt;/a&gt;は、指定された年 &lt;code&gt;y&lt;/code&gt; 、月 &lt;code&gt;m&lt;/code&gt; 、日 &lt;code&gt;d&lt;/code&gt; の &lt;code&gt;Date&lt;/code&gt; 型を作成します。ただし、 &lt;code&gt;m&lt;/code&gt; および &lt;code&gt;d&lt;/code&gt; 引数はオプションであり、それらのデフォルト値は &lt;code&gt;1&lt;/code&gt; です。この動作は、次のように簡潔に表現できます。</target>
        </trans-unit>
        <trans-unit id="1dd343721288798b24ab9ba3f9547e7ac41c164d" translate="yes" xml:space="preserve">
          <source>In many cases, it is redundant to provide the type of &lt;code&gt;Point&lt;/code&gt; object one wants to construct, since the types of arguments to the constructor call already implicitly provide type information. For that reason, you can also apply &lt;code&gt;Point&lt;/code&gt; itself as a constructor, provided that the implied value of the parameter type &lt;code&gt;T&lt;/code&gt; is unambiguous:</source>
          <target state="translated">多くの場合、コンストラクタ呼び出しへの引数の型はすでに暗黙的に型情報を提供しているため、構築したい &lt;code&gt;Point&lt;/code&gt; オブジェクトの型を提供することは冗長です。そのため、パラメーター型 &lt;code&gt;T&lt;/code&gt; の暗黙の値が明確であれば、 &lt;code&gt;Point&lt;/code&gt; 自体をコンストラクターとして適用することもできます。</target>
        </trans-unit>
        <trans-unit id="269254287f284598e6e04a282963713d5ef0932c" translate="yes" xml:space="preserve">
          <source>In many cases, the resolution specified for rounding (e.g., &lt;code&gt;Dates.Second(30)&lt;/code&gt;) divides evenly into the next largest period (in this case, &lt;code&gt;Dates.Minute(1)&lt;/code&gt;). But rounding behaviour in cases in which this is not true may lead to confusion. What is the expected result of rounding a &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; to the nearest 10 hours?</source>
          <target state="translated">多くの場合、丸めに指定された解像度（たとえば、 &lt;code&gt;Dates.Second(30)&lt;/code&gt; ）は、次に大きい期間（この場合は、 &lt;code&gt;Dates.Minute(1)&lt;/code&gt; ）に均等に分割されます。しかし、これが当てはまらない場合の丸め動作は、混乱を招く可能性があります。&lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;を最も近い10時間に丸めた場合の予想される結果は何ですか？</target>
        </trans-unit>
        <trans-unit id="619846970e9e167e4db1b981435711d687bd4ed9" translate="yes" xml:space="preserve">
          <source>In many languages with optional type declarations, adding declarations is the principal way to make code run faster. This is &lt;em&gt;not&lt;/em&gt; the case in Julia. In Julia, the compiler generally knows the types of all function arguments, local variables, and expressions. However, there are a few specific instances where declarations are helpful.</source>
          <target state="translated">オプションの型宣言を持つ多くの言語では、宣言を追加することがコードをより速く実行するための主要な方法です。これはジュリアには当てはまり&lt;em&gt;ません&lt;/em&gt;。 Juliaでは、コンパイラーは通常、すべての関数引数、ローカル変数、および式のタイプを認識しています。ただし、宣言が役立つ特定のインスタンスがいくつかあります。</target>
        </trans-unit>
        <trans-unit id="9450b748dbcdb8ba9fd42add95485312cab4012f" translate="yes" xml:space="preserve">
          <source>In mathematics, &lt;code&gt;+&lt;/code&gt; usually denotes a &lt;em&gt;commutative&lt;/em&gt; operation, where the order of the operands does not matter. An example of this is matrix addition, where &lt;code&gt;A + B == B + A&lt;/code&gt; for any matrices &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; that have the same shape. In contrast, &lt;code&gt;*&lt;/code&gt; typically denotes a &lt;em&gt;noncommutative&lt;/em&gt; operation, where the order of the operands &lt;em&gt;does&lt;/em&gt; matter. An example of this is matrix multiplication, where in general &lt;code&gt;A * B != B * A&lt;/code&gt;. As with matrix multiplication, string concatenation is noncommutative: &lt;code&gt;greet * whom != whom * greet&lt;/code&gt;. As such, &lt;code&gt;*&lt;/code&gt; is a more natural choice for an infix string concatenation operator, consistent with common mathematical use.</source>
          <target state="translated">数学では、 &lt;code&gt;+&lt;/code&gt; は通常、&lt;em&gt;可換&lt;/em&gt;演算を示し、オペランドの順序は重要ではありません。この例は、行列の加算です。ここで、 &lt;code&gt;A + B == B + A&lt;/code&gt; は、同じ形状を持つすべての行列 &lt;code&gt;A&lt;/code&gt; と &lt;code&gt;B&lt;/code&gt; に対応します。対照的に、 &lt;code&gt;*&lt;/code&gt; は通常、&lt;em&gt;非可換&lt;/em&gt;演算を示し、オペランドの順序&lt;em&gt;が&lt;/em&gt;重要になります。これの例は、一般的に &lt;code&gt;A * B != B * A&lt;/code&gt; である行列乗算です。行列の乗算と同様に、文字列の連結は非可換です： &lt;code&gt;greet * whom != whom * greet&lt;/code&gt; 。そのため、 &lt;code&gt;*&lt;/code&gt; 中置文字列連結演算子のより自然な選択であり、一般的な数学の使用と一致しています。</target>
        </trans-unit>
        <trans-unit id="d668367cdfd665ad4130e8623549b132951b0865" translate="yes" xml:space="preserve">
          <source>In more complex cases, resolving method ambiguities involves a certain element of design; this topic is explored further &lt;a href=&quot;#man-method-design-ambiguities&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">より複雑なケースでは、メソッドのあいまいさを解決するには、設計の特定の要素が必要です。このトピックについては、&lt;a href=&quot;#man-method-design-ambiguities&quot;&gt;以下で&lt;/a&gt;詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="ab8bd1f7589c990d976c1051b69449b020a43727" translate="yes" xml:space="preserve">
          <source>In more complex cases, resolving method ambiguities involves a certain element of design; this topic is explored further &lt;a href=&quot;#man-method-design-ambiguities-1&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">より複雑なケースでは、メソッドのあいまいさの解決には、設計の特定の要素が含まれます。このトピックについては、&lt;a href=&quot;#man-method-design-ambiguities-1&quot;&gt;以下で&lt;/a&gt;詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="79e9987996de7a2336075063e303687b6133cecc" translate="yes" xml:space="preserve">
          <source>In most cases, if &lt;code&gt;A&lt;/code&gt; is a subtype &lt;code&gt;S&lt;/code&gt; of &lt;code&gt;AbstractMatrix{T}&lt;/code&gt; with an element type &lt;code&gt;T&lt;/code&gt; supporting &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt;, the return type is &lt;code&gt;LU{T,S{T}}&lt;/code&gt;. If pivoting is chosen (default) the element type should also support &lt;a href=&quot;../../base/math/index#Base.abs&quot;&gt;&lt;code&gt;abs&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;&amp;lt;&lt;/code&gt;.</source>
          <target state="translated">ほとんどの場合、 &lt;code&gt;A&lt;/code&gt; が &lt;code&gt;AbstractMatrix{T}&lt;/code&gt; サブタイプ &lt;code&gt;S&lt;/code&gt; であり、要素タイプ &lt;code&gt;T&lt;/code&gt; が &lt;code&gt;+&lt;/code&gt; 、 &lt;code&gt;-&lt;/code&gt; 、 &lt;code&gt;*&lt;/code&gt; 、および &lt;code&gt;/&lt;/code&gt; をサポートしている場合、戻り値の型は &lt;code&gt;LU{T,S{T}}&lt;/code&gt; です。ピボットが選択されている場合（デフォルト）、要素タイプは&lt;a href=&quot;../../base/math/index#Base.abs&quot;&gt; &lt;code&gt;abs&lt;/code&gt; &lt;/a&gt;および &lt;code&gt;&amp;lt;&lt;/code&gt; もサポートする必要があります。</target>
        </trans-unit>
        <trans-unit id="be4d8bd032078d1d618f689c7b9a8339132970a1" translate="yes" xml:space="preserve">
          <source>In most cases, if &lt;code&gt;A&lt;/code&gt; is a subtype &lt;code&gt;S&lt;/code&gt; of &lt;code&gt;AbstractMatrix{T}&lt;/code&gt; with an element type &lt;code&gt;T&lt;/code&gt; supporting &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt;, the return type is &lt;code&gt;LU{T,S{T}}&lt;/code&gt;. If pivoting is chosen (default) the element type should also support &lt;code&gt;abs&lt;/code&gt; and &lt;code&gt;&amp;lt;&lt;/code&gt;.</source>
          <target state="translated">ほとんどの場合、 &lt;code&gt;A&lt;/code&gt; が &lt;code&gt;AbstractMatrix{T}&lt;/code&gt; サブタイプ &lt;code&gt;S&lt;/code&gt; であり、要素タイプ &lt;code&gt;T&lt;/code&gt; が &lt;code&gt;+&lt;/code&gt; 、 &lt;code&gt;-&lt;/code&gt; 、 &lt;code&gt;*&lt;/code&gt; および &lt;code&gt;/&lt;/code&gt; をサポートしている場合、戻りタイプは &lt;code&gt;LU{T,S{T}}&lt;/code&gt; です。ピボットが選択されている場合（デフォルト）、要素タイプは &lt;code&gt;abs&lt;/code&gt; および &lt;code&gt;&amp;lt;&lt;/code&gt; もサポートする必要があります。</target>
        </trans-unit>
        <trans-unit id="7b67b5f42c4b6dbeb6aa0f0d5f6894ea2c19994e" translate="yes" xml:space="preserve">
          <source>In order to &lt;a href=&quot;#catch-ctrl-c&quot;&gt;catch CTRL-C&lt;/a&gt; in the script you can use</source>
          <target state="translated">スクリプトで&lt;a href=&quot;#catch-ctrl-c&quot;&gt;CTRL-C&lt;/a&gt;をキャッチするには、次を使用できます。</target>
        </trans-unit>
        <trans-unit id="c01897c1c5dfe56ff403bf92da50402dc901b089" translate="yes" xml:space="preserve">
          <source>In order to access the data of x, we can use &lt;code&gt;jl_array_data&lt;/code&gt;:</source>
          <target state="translated">xのデータにアクセスするには、 &lt;code&gt;jl_array_data&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="1c8c964572487783a93c9f805bd24c6191a24c97" translate="yes" xml:space="preserve">
          <source>In order to build this program you have to put the path to the Julia header into the include path and link against &lt;code&gt;libjulia&lt;/code&gt;. For instance, when Julia is installed to &lt;code&gt;$JULIA_DIR&lt;/code&gt;, one can compile the above test program &lt;code&gt;test.c&lt;/code&gt; with &lt;code&gt;gcc&lt;/code&gt; using:</source>
          <target state="translated">このプログラムをビルドするには、Juliaヘッダーへのパスをインクルードパスに入れ、 &lt;code&gt;libjulia&lt;/code&gt; にリンクする必要があります。たとえば、Juliaが &lt;code&gt;$JULIA_DIR&lt;/code&gt; にインストールされている場合、次のコマンドを使用して、上記のテストプログラム &lt;code&gt;test.c&lt;/code&gt; を &lt;code&gt;gcc&lt;/code&gt; でコンパイルできます。</target>
        </trans-unit>
        <trans-unit id="f634f39fd97c0fd5eaef9dfae9571e089a9c4f67" translate="yes" xml:space="preserve">
          <source>In order to check whether &lt;code&gt;ret&lt;/code&gt; is of a specific Julia type, we can use the &lt;code&gt;jl_isa&lt;/code&gt;, &lt;code&gt;jl_typeis&lt;/code&gt;, or &lt;code&gt;jl_is_...&lt;/code&gt; functions. By typing &lt;code&gt;typeof(sqrt(2.0))&lt;/code&gt; into the Julia shell we can see that the return type is &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;double&lt;/code&gt; in C). To convert the boxed Julia value into a C double the &lt;code&gt;jl_unbox_float64&lt;/code&gt; function is used in the above code snippet.</source>
          <target state="translated">&lt;code&gt;ret&lt;/code&gt; が特定のJuliaタイプであるかどうかを確認するには、 &lt;code&gt;jl_isa&lt;/code&gt; 、 &lt;code&gt;jl_typeis&lt;/code&gt; 、または &lt;code&gt;jl_is_...&lt;/code&gt; 関数を使用できます。Juliaシェルに &lt;code&gt;typeof(sqrt(2.0))&lt;/code&gt; と入力すると、戻り値の型が&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;（Cでは &lt;code&gt;double&lt;/code&gt; )であることがわかります。ボックス化されたジュリア値をCに変換するには、上記のコードスニペットで &lt;code&gt;jl_unbox_float64&lt;/code&gt; 関数を使用します。</target>
        </trans-unit>
        <trans-unit id="c26dfd25e758364e0dcd1c617a188ec51d32baad" translate="yes" xml:space="preserve">
          <source>In order to compute trigonometric functions with degrees instead of radians, suffix the function with &lt;code&gt;d&lt;/code&gt;. For example, &lt;a href=&quot;../../base/math/index#Base.Math.sind&quot;&gt;&lt;code&gt;sind(x)&lt;/code&gt;&lt;/a&gt; computes the sine of &lt;code&gt;x&lt;/code&gt; where &lt;code&gt;x&lt;/code&gt; is specified in degrees. The complete list of trigonometric functions with degree variants is:</source>
          <target state="translated">ラジアンの代わりに次数をもつ三角関数を計算するには、関数の後に &lt;code&gt;d&lt;/code&gt; を付けます。たとえば、&lt;a href=&quot;../../base/math/index#Base.Math.sind&quot;&gt; &lt;code&gt;sind(x)&lt;/code&gt; &lt;/a&gt;は &lt;code&gt;x&lt;/code&gt; の正弦を計算します。ここで、 &lt;code&gt;x&lt;/code&gt; は度数で指定されます。次数バリアントを含む三角関数の完全なリストは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="f65b6a7038eae90009481c5aaae33e0c39a02ac4" translate="yes" xml:space="preserve">
          <source>In order to define a new display backend, one should first create a subtype &lt;code&gt;D&lt;/code&gt; of the abstract class &lt;a href=&quot;#Base.Multimedia.AbstractDisplay&quot;&gt;&lt;code&gt;AbstractDisplay&lt;/code&gt;&lt;/a&gt;. Then, for each MIME type (&lt;code&gt;mime&lt;/code&gt; string) that can be displayed on &lt;code&gt;D&lt;/code&gt;, one should define a function &lt;code&gt;display(d::D, ::MIME&quot;mime&quot;, x) = ...&lt;/code&gt; that displays &lt;code&gt;x&lt;/code&gt; as that MIME type, usually by calling &lt;a href=&quot;#Base.show-Tuple%7BAny,Any,Any%7D&quot;&gt;&lt;code&gt;show(io, mime, x)&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;repr(io, mime, x)&lt;/code&gt;. A &lt;a href=&quot;../base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt; should be thrown if &lt;code&gt;x&lt;/code&gt; cannot be displayed as that MIME type; this is automatic if one calls &lt;code&gt;show&lt;/code&gt; or &lt;code&gt;repr&lt;/code&gt;. Finally, one should define a function &lt;code&gt;display(d::D, x)&lt;/code&gt; that queries &lt;a href=&quot;#Base.Multimedia.showable&quot;&gt;&lt;code&gt;showable(mime, x)&lt;/code&gt;&lt;/a&gt; for the &lt;code&gt;mime&lt;/code&gt; types supported by &lt;code&gt;D&lt;/code&gt; and displays the &quot;best&quot; one; a &lt;code&gt;MethodError&lt;/code&gt; should be thrown if no supported MIME types are found for &lt;code&gt;x&lt;/code&gt;. Similarly, some subtypes may wish to override &lt;a href=&quot;#Base.Multimedia.redisplay&quot;&gt;&lt;code&gt;redisplay(d::D, ...)&lt;/code&gt;&lt;/a&gt;. (Again, one should &lt;code&gt;import Base.display&lt;/code&gt; to add new methods to &lt;code&gt;display&lt;/code&gt;.) The return values of these functions are up to the implementation (since in some cases it may be useful to return a display &quot;handle&quot; of some type). The display functions for &lt;code&gt;D&lt;/code&gt; can then be called directly, but they can also be invoked automatically from &lt;a href=&quot;#Base.Multimedia.display&quot;&gt;&lt;code&gt;display(x)&lt;/code&gt;&lt;/a&gt; simply by pushing a new display onto the display-backend stack with:</source>
          <target state="translated">新しい表示バックエンドを定義するには、まず抽象クラス&lt;a href=&quot;#Base.Multimedia.AbstractDisplay&quot;&gt; &lt;code&gt;AbstractDisplay&lt;/code&gt; の&lt;/a&gt;サブタイプ &lt;code&gt;D&lt;/code&gt; を作成する必要があります。次に、 &lt;code&gt;D&lt;/code&gt; に表示できる各MIMEタイプ（ &lt;code&gt;mime&lt;/code&gt; 文字列）に対して &lt;code&gt;display(d::D, ::MIME&quot;mime&quot;, x) = ...&lt;/code&gt; &lt;code&gt;x&lt;/code&gt; をそのMIMEタイプとして表示する関数display（d :: D、:: MIME &quot;mime&quot;、x）= ...を定義する必要があります。通常は、&lt;a href=&quot;#Base.show-Tuple%7BAny,Any,Any%7D&quot;&gt; &lt;code&gt;show(io, mime, x)&lt;/code&gt; &lt;/a&gt;または &lt;code&gt;repr(io, mime, x)&lt;/code&gt; 呼び出します。 A &lt;a href=&quot;../base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; は&lt;/a&gt;場合にスローされるべきで &lt;code&gt;x&lt;/code&gt; そのMIMEタイプとして表示することはできません。 &lt;code&gt;show&lt;/code&gt; または &lt;code&gt;repr&lt;/code&gt; を呼び出すと、これは自動的に行われます。最後に、関数 &lt;code&gt;display(d::D, x)&lt;/code&gt; を定義する必要があります &lt;code&gt;D&lt;/code&gt; でサポートされている &lt;code&gt;mime&lt;/code&gt; タイプについて&lt;a href=&quot;#Base.Multimedia.showable&quot;&gt; &lt;code&gt;showable(mime, x)&lt;/code&gt; &lt;/a&gt;を照会し、「最高」のものを表示します。 &lt;code&gt;x&lt;/code&gt; でサポートされているMIMEタイプが見つからない場合は、 &lt;code&gt;MethodError&lt;/code&gt; がスローされます。同様に、一部のサブタイプは&lt;a href=&quot;#Base.Multimedia.redisplay&quot;&gt; &lt;code&gt;redisplay(d::D, ...)&lt;/code&gt; &lt;/a&gt;をオーバーライドしたい場合があります。 （ここでも、 &lt;code&gt;display&lt;/code&gt; する新しいメソッドを追加するには &lt;code&gt;import Base.display&lt;/code&gt; をインポートする必要があります。）これらの関数の戻り値は実装次第です（場合によっては、あるタイプのディスプレイ「ハンドル」を返すことが役立つ場合があるため）。その後、 &lt;code&gt;D&lt;/code&gt; の表示関数を直接呼び出すことができますが、&lt;a href=&quot;#Base.Multimedia.display&quot;&gt; &lt;code&gt;display(x)&lt;/code&gt; &lt;/a&gt;から自動的に呼び出すこともできます。 新しいディスプレイをディスプレイバックエンドスタックにプッシュするだけです。</target>
        </trans-unit>
        <trans-unit id="704ebdff29ebf61fba245cec0a90e4a3393b7079" translate="yes" xml:space="preserve">
          <source>In order to define a new display backend, one should first create a subtype &lt;code&gt;D&lt;/code&gt; of the abstract class &lt;a href=&quot;#Base.Multimedia.AbstractDisplay&quot;&gt;&lt;code&gt;AbstractDisplay&lt;/code&gt;&lt;/a&gt;. Then, for each MIME type (&lt;code&gt;mime&lt;/code&gt; string) that can be displayed on &lt;code&gt;D&lt;/code&gt;, one should define a function &lt;code&gt;display(d::D, ::MIME&quot;mime&quot;, x) = ...&lt;/code&gt; that displays &lt;code&gt;x&lt;/code&gt; as that MIME type, usually by calling &lt;a href=&quot;#Base.show-Tuple%7BIO,Any%7D&quot;&gt;&lt;code&gt;show(io, mime, x)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Base.repr-Tuple%7BMIME,Any%7D&quot;&gt;&lt;code&gt;repr(io, mime, x)&lt;/code&gt;&lt;/a&gt;. A &lt;a href=&quot;../base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt; should be thrown if &lt;code&gt;x&lt;/code&gt; cannot be displayed as that MIME type; this is automatic if one calls &lt;code&gt;show&lt;/code&gt; or &lt;code&gt;repr&lt;/code&gt;. Finally, one should define a function &lt;code&gt;display(d::D, x)&lt;/code&gt; that queries &lt;a href=&quot;#Base.Multimedia.showable&quot;&gt;&lt;code&gt;showable(mime, x)&lt;/code&gt;&lt;/a&gt; for the &lt;code&gt;mime&lt;/code&gt; types supported by &lt;code&gt;D&lt;/code&gt; and displays the &quot;best&quot; one; a &lt;code&gt;MethodError&lt;/code&gt; should be thrown if no supported MIME types are found for &lt;code&gt;x&lt;/code&gt;. Similarly, some subtypes may wish to override &lt;a href=&quot;#Base.Multimedia.redisplay&quot;&gt;&lt;code&gt;redisplay(d::D, ...)&lt;/code&gt;&lt;/a&gt;. (Again, one should &lt;code&gt;import Base.display&lt;/code&gt; to add new methods to &lt;code&gt;display&lt;/code&gt;.) The return values of these functions are up to the implementation (since in some cases it may be useful to return a display &quot;handle&quot; of some type). The display functions for &lt;code&gt;D&lt;/code&gt; can then be called directly, but they can also be invoked automatically from &lt;a href=&quot;#Base.Multimedia.display&quot;&gt;&lt;code&gt;display(x)&lt;/code&gt;&lt;/a&gt; simply by pushing a new display onto the display-backend stack with:</source>
          <target state="translated">新しい表示バックエンドを定義するには、最初に抽象クラス&lt;a href=&quot;#Base.Multimedia.AbstractDisplay&quot;&gt; &lt;code&gt;AbstractDisplay&lt;/code&gt; の&lt;/a&gt;サブタイプ &lt;code&gt;D&lt;/code&gt; を作成する必要があります。次に、 &lt;code&gt;D&lt;/code&gt; に表示できるMIMEタイプ（ &lt;code&gt;mime&lt;/code&gt; 文字列）ごとに、 &lt;code&gt;x&lt;/code&gt; をそのMIMEタイプとして &lt;code&gt;display(d::D, ::MIME&quot;mime&quot;, x) = ...&lt;/code&gt; する関数display（d :: D、:: MIME &quot;mime&quot;、x）= ...を定義する必要があります。通常、&lt;a href=&quot;#Base.show-Tuple%7BIO,Any%7D&quot;&gt; &lt;code&gt;show(io, mime, x)&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;#Base.repr-Tuple%7BMIME,Any%7D&quot;&gt; &lt;code&gt;repr(io, mime, x)&lt;/code&gt; &lt;/a&gt;呼び出します。 A &lt;a href=&quot;../base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; は&lt;/a&gt;場合にスローされるべきで &lt;code&gt;x&lt;/code&gt; そのMIMEタイプとして表示することはできません。これは、 &lt;code&gt;show&lt;/code&gt; または &lt;code&gt;repr&lt;/code&gt; を呼び出すと自動的に行われます。最後に、関数 &lt;code&gt;display(d::D, x)&lt;/code&gt; を定義する必要があります &lt;code&gt;D&lt;/code&gt; でサポートされている &lt;code&gt;mime&lt;/code&gt; タイプの&lt;a href=&quot;#Base.Multimedia.showable&quot;&gt; &lt;code&gt;showable(mime, x)&lt;/code&gt; &lt;/a&gt;を照会し、「最良の」タイプを表示します。 &lt;code&gt;x&lt;/code&gt; に対してサポートされているMIMEタイプが見つからない場合は、 &lt;code&gt;MethodError&lt;/code&gt; をスローする必要があります。同様に、一部のサブタイプは&lt;a href=&quot;#Base.Multimedia.redisplay&quot;&gt; &lt;code&gt;redisplay(d::D, ...)&lt;/code&gt; &lt;/a&gt;をオーバーライドしたい場合があります。 （ここでも、 &lt;code&gt;import Base.display&lt;/code&gt; をインポートして、 &lt;code&gt;display&lt;/code&gt; する新しいメソッドを追加する必要があります。）これらの関数の戻り値は実装次第です（場合によっては、あるタイプの表示「ハンドル」を返すことが役立つ場合があるため）。 &lt;code&gt;D&lt;/code&gt; の表示関数は直接呼び出すことができますが、&lt;a href=&quot;#Base.Multimedia.display&quot;&gt; &lt;code&gt;display(x)&lt;/code&gt; &lt;/a&gt;から自動的に呼び出すこともできます。 次の方法で、新しいディスプレイをディスプレイバックエンドスタックにプッシュするだけです。</target>
        </trans-unit>
        <trans-unit id="fc544618a386ab5d58649ad21c68fc6a33673b83" translate="yes" xml:space="preserve">
          <source>In order to define automatically the values of this dictionary at startup time, one can use the &lt;a href=&quot;#Base.atreplinit&quot;&gt;&lt;code&gt;atreplinit&lt;/code&gt;&lt;/a&gt; function in the &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; file, for example:</source>
          <target state="translated">起動時にこのディクショナリの値を自動的に定義するために、 &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; ファイルの&lt;a href=&quot;#Base.atreplinit&quot;&gt; &lt;code&gt;atreplinit&lt;/code&gt; &lt;/a&gt;関数を使用できます。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="78c036b6a91aa7223777701c5e046f12ec492ccc" translate="yes" xml:space="preserve">
          <source>In order to define random generation out of objects of type &lt;code&gt;S&lt;/code&gt;, the following method should be defined: &lt;code&gt;rand(rng::AbstractRNG, sp::Random.SamplerTrivial{S})&lt;/code&gt;. Here, &lt;code&gt;sp&lt;/code&gt; simply wraps an object of type &lt;code&gt;S&lt;/code&gt;, which can be accessed via &lt;code&gt;sp[]&lt;/code&gt;. Continuing the &lt;code&gt;Die&lt;/code&gt; example, we want now to define &lt;code&gt;rand(d::Die)&lt;/code&gt; to produce an &lt;code&gt;Int&lt;/code&gt; corresponding to one of &lt;code&gt;d&lt;/code&gt;'s sides:</source>
          <target state="translated">タイプ &lt;code&gt;S&lt;/code&gt; のオブジェクトからランダム生成を定義するには、次のメソッドを定義する必要があります： &lt;code&gt;rand(rng::AbstractRNG, sp::Random.SamplerTrivial{S})&lt;/code&gt; 。ここで、 &lt;code&gt;sp&lt;/code&gt; は、sp &lt;code&gt;sp[]&lt;/code&gt; 介してアクセスできるタイプ &lt;code&gt;S&lt;/code&gt; のオブジェクトを単純にラップします。 &lt;code&gt;Die&lt;/code&gt; の例を続けて、 &lt;code&gt;rand(d::Die)&lt;/code&gt; を定義して、 &lt;code&gt;d&lt;/code&gt; の辺の1つに対応する &lt;code&gt;Int&lt;/code&gt; を生成します。</target>
        </trans-unit>
        <trans-unit id="e0fa42e97ec0c0f5639428f8bc25c0313c261f3b" translate="yes" xml:space="preserve">
          <source>In order to dispatch a multi-level parametric argument list, often it is best to separate each level of dispatch into distinct functions. This may sound similar in approach to single-dispatch, but as we shall see below, it is still more flexible.</source>
          <target state="translated">マルチレベルのパラメトリック引数リストをディスパッチするためには、多くの場合、各レベルのディスパッチを別々の関数に分離するのがベストです。これはシングルディスパッチと似たようなアプローチに聞こえるかもしれませんが、後述するように、この方がより柔軟性があります。</target>
        </trans-unit>
        <trans-unit id="c64f4c986b251a9a23920c12ed0e829f663e97f9" translate="yes" xml:space="preserve">
          <source>In order to implement such a &lt;code&gt;copy&lt;/code&gt; or &lt;code&gt;copyto!&lt;/code&gt;, method, of course, you must work with the &lt;code&gt;Broadcasted&lt;/code&gt; wrapper to compute each element. There are two main ways of doing so:</source>
          <target state="translated">そのような &lt;code&gt;copy&lt;/code&gt; または &lt;code&gt;copyto!&lt;/code&gt; を実装するために！、メソッド、もちろん、 &lt;code&gt;Broadcasted&lt;/code&gt; ラッパーを使用して各要素を計算する必要があります。これには主に2つの方法があります。</target>
        </trans-unit>
        <trans-unit id="7c65ae2a5b36599056aee26d3163a0e9101f727b" translate="yes" xml:space="preserve">
          <source>In order to losslessly represent arbitrary byte streams stored in a &lt;code&gt;String&lt;/code&gt;, a &lt;code&gt;Char&lt;/code&gt; value may store information that cannot be converted to a Unicode codepoint &amp;mdash; converting such a &lt;code&gt;Char&lt;/code&gt; to &lt;code&gt;UInt32&lt;/code&gt; will throw an error. The &lt;a href=&quot;#Base.isvalid-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;isvalid(c::Char)&lt;/code&gt;&lt;/a&gt; function can be used to query whether &lt;code&gt;c&lt;/code&gt; represents a valid Unicode character.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; に格納された任意のバイトストリームを無損失で表すために、 &lt;code&gt;Char&lt;/code&gt; 値はUnicodeコードポイントに変換できない情報を格納する場合があります。このような &lt;code&gt;Char&lt;/code&gt; を &lt;code&gt;UInt32&lt;/code&gt; に変換するとエラーがスローされます。&lt;a href=&quot;#Base.isvalid-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;isvalid(c::Char)&lt;/code&gt; &lt;/a&gt;関数は、かどうかを照会するために使用することができます &lt;code&gt;c&lt;/code&gt; が有効なUnicode文字を表します。</target>
        </trans-unit>
        <trans-unit id="fab91460cbe612949b4b9d95753296ca7abe3d3b" translate="yes" xml:space="preserve">
          <source>In order to pass this function to C, we obtain its address using the macro &lt;code&gt;@cfunction&lt;/code&gt;:</source>
          <target state="translated">この関数をCに渡すために、マクロ &lt;code&gt;@cfunction&lt;/code&gt; を使用してそのアドレスを取得します。</target>
        </trans-unit>
        <trans-unit id="cd5618b4a563dff2d7a927d5353ef78a361df290" translate="yes" xml:space="preserve">
          <source>In order to refer to &lt;code&gt;MyType&lt;/code&gt; across all processes, &lt;code&gt;DummyModule.jl&lt;/code&gt; needs to be loaded on every process. Calling &lt;code&gt;include(&quot;DummyModule.jl&quot;)&lt;/code&gt; loads it only on a single process. To load it on every process, use the &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@everywhere&quot;&gt;&lt;code&gt;@everywhere&lt;/code&gt;&lt;/a&gt; macro (starting Julia with &lt;code&gt;julia -p 2&lt;/code&gt;):</source>
          <target state="translated">参照するためには &lt;code&gt;MyType&lt;/code&gt; すべてのプロセス間で、 &lt;code&gt;DummyModule.jl&lt;/code&gt; は、すべてのプロセスにロードする必要があります。 &lt;code&gt;include(&quot;DummyModule.jl&quot;)&lt;/code&gt; を呼び出すと、単一のプロセスでのみロードされます。すべてのプロセスにロードするには、&lt;a href=&quot;../../stdlib/distributed/index#Distributed.@everywhere&quot;&gt; &lt;code&gt;@everywhere&lt;/code&gt; &lt;/a&gt;マクロを使用します（juliaをjulia &lt;code&gt;julia -p 2&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="47f30e462ec98fcc58c9494bb836f85ec8257aff" translate="yes" xml:space="preserve">
          <source>In order to support mutation, such objects are generally allocated on the heap, and have stable memory addresses. A mutable object is like a little container that might hold different values over time, and so can only be reliably identified with its address. In contrast, an instance of an immutable type is associated with specific field values &amp;ndash;- the field values alone tell you everything about the object. In deciding whether to make a type mutable, ask whether two instances with the same field values would be considered identical, or if they might need to change independently over time. If they would be considered identical, the type should probably be immutable.</source>
          <target state="translated">変更をサポートするために、このようなオブジェクトは通常ヒープに割り当てられ、安定したメモリアドレスを持っています。変更可能なオブジェクトは、時間の経過とともに異なる値を保持する可能性のある小さなコンテナのようなものであり、そのアドレスでのみ確実に識別できます。対照的に、不変タイプのインスタンスは特定のフィールド値に関連付けられています。フィールド値だけでオブジェクトに関するすべてを知ることができます。型を変更可能にするかどうかを決定する際には、同じフィールド値を持つ2つのインスタンスが同一であると見なされるか、または時間の経過とともに独立して変更する必要があるかどうかを尋ねます。それらが同一であると見なされる場合、タイプはおそらく不変でなければなりません。</target>
        </trans-unit>
        <trans-unit id="2f2293a5b64eabd8ff88bd22ea606404b9b1e108" translate="yes" xml:space="preserve">
          <source>In other circumstances, it is handy to be able to stop an iteration and move on to the next one immediately. The &lt;code&gt;continue&lt;/code&gt; keyword accomplishes this:</source>
          <target state="translated">他の状況では、イテレーションを停止してすぐに次のイテレーションに進むことができると便利です。 &lt;code&gt;continue&lt;/code&gt; キーワードは、これを達成します：</target>
        </trans-unit>
        <trans-unit id="c004c636d1b0703eca9cda2590edfd6579e7129c" translate="yes" xml:space="preserve">
          <source>In other words, &lt;a href=&quot;../../base/base/index#Core.isa&quot;&gt;&lt;code&gt;isa(A,Type{B})&lt;/code&gt;&lt;/a&gt; is true if and only if &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are the same object and that object is a type. Without the parameter, &lt;code&gt;Type&lt;/code&gt; is simply an abstract type which has all type objects as its instances, including, of course, singleton types:</source>
          <target state="translated">つまり、&lt;a href=&quot;../../base/base/index#Core.isa&quot;&gt; &lt;code&gt;isa(A,Type{B})&lt;/code&gt; &lt;/a&gt;は、 &lt;code&gt;A&lt;/code&gt; と &lt;code&gt;B&lt;/code&gt; が同じオブジェクトであり、そのオブジェクトが型である場合にのみtrueになります。パラメーターがない場合、 &lt;code&gt;Type&lt;/code&gt; は、単純な型を含む、すべての型オブジェクトをインスタンスとして持つ抽象型です。</target>
        </trans-unit>
        <trans-unit id="fb4e1a8fb772b24b6039451c201b81e5c718d91a" translate="yes" xml:space="preserve">
          <source>In other words, in the parlance of type theory, Julia's type parameters are &lt;em&gt;invariant&lt;/em&gt;, rather than being &lt;a href=&quot;https://en.wikipedia.org/wiki/Covariance_and_contravariance_%28computer_science%29&quot;&gt;covariant (or even contravariant)&lt;/a&gt;. This is for practical reasons: while any instance of &lt;code&gt;Point{Float64}&lt;/code&gt; may conceptually be like an instance of &lt;code&gt;Point{Real}&lt;/code&gt; as well, the two types have different representations in memory:</source>
          <target state="translated">言い換えると、型理論の用語では、ジュリアの型パラメーターは&lt;a href=&quot;https://en.wikipedia.org/wiki/Covariance_and_contravariance_%28computer_science%29&quot;&gt;共変（または反変）&lt;/a&gt;ではなく&lt;em&gt;不変&lt;/em&gt;です。これは実際的な理由によるものです &lt;code&gt;Point{Float64}&lt;/code&gt; のインスタンスは概念的には &lt;code&gt;Point{Real}&lt;/code&gt; インスタンスのようでもありますが、2つのタイプのメモリ内の表現は異なります。</target>
        </trans-unit>
        <trans-unit id="2489400c16a870eb77390027298b5bae2afac7fd" translate="yes" xml:space="preserve">
          <source>In particular this means that overlong and too-high code unit sequences and prefixes thereof are treated as a single invalid character rather than multiple invalid characters. This rule may be best explained with an example:</source>
          <target state="translated">特に、これは、長すぎて高すぎるコードユニットシーケンス及びその接頭辞は、複数の無効な文字ではなく、1つの無効な文字として扱われることを意味する。この規則は、例を挙げて説明するのが最も良いかもしれません。</target>
        </trans-unit>
        <trans-unit id="86e6d7b557572810776afd763390d8c87a4b9b3f" translate="yes" xml:space="preserve">
          <source>In particular, &lt;code&gt;repr(&quot;text/plain&quot;, x)&lt;/code&gt; is typically a &quot;pretty-printed&quot; version of &lt;code&gt;x&lt;/code&gt; designed for human consumption. See also &lt;code&gt;repr(x)&lt;/code&gt; to instead return a string corresponding to &lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;show(x)&lt;/code&gt;&lt;/a&gt; that may be closer to how the value of &lt;code&gt;x&lt;/code&gt; would be entered in Julia.</source>
          <target state="translated">特に、 &lt;code&gt;repr(&quot;text/plain&quot;, x)&lt;/code&gt; は、通常、人間が使用するために設計された &lt;code&gt;x&lt;/code&gt; の「かなり印刷された」バージョンです。Julia での &lt;code&gt;x&lt;/code&gt; の値の入力方法に近い可能性がある&lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;show(x)&lt;/code&gt; に&lt;/a&gt;対応する文字列を返すには、 &lt;code&gt;repr(x)&lt;/code&gt; も参照してください。</target>
        </trans-unit>
        <trans-unit id="44f2256825b7ba89fb1041db2fbe0f7cb5785da9" translate="yes" xml:space="preserve">
          <source>In particular, &lt;code&gt;repr(&quot;text/plain&quot;, x)&lt;/code&gt; is typically a &quot;pretty-printed&quot; version of &lt;code&gt;x&lt;/code&gt; designed for human consumption. See also &lt;code&gt;repr(x)&lt;/code&gt; to instead return a string corresponding to &lt;a href=&quot;#Base.show-Tuple%7BIO,Any%7D&quot;&gt;&lt;code&gt;show(x)&lt;/code&gt;&lt;/a&gt; that may be closer to how the value of &lt;code&gt;x&lt;/code&gt; would be entered in Julia.</source>
          <target state="translated">特に、 &lt;code&gt;repr(&quot;text/plain&quot;, x)&lt;/code&gt; は通常、人間が消費するために設計された &lt;code&gt;x&lt;/code&gt; の「きれいに印刷された」バージョンです。代わりに、 &lt;code&gt;repr(x)&lt;/code&gt; を参照して、 &lt;code&gt;x&lt;/code&gt; の値がJuliaに入力される方法に近い可能性のある&lt;a href=&quot;#Base.show-Tuple%7BIO,Any%7D&quot;&gt; &lt;code&gt;show(x)&lt;/code&gt; に&lt;/a&gt;対応する文字列を返します。</target>
        </trans-unit>
        <trans-unit id="a352a9e712137ef0293428d01a95dc381f03f45f" translate="yes" xml:space="preserve">
          <source>In particular, if you define a &lt;code&gt;function __init__()&lt;/code&gt; in a module, then Julia will call &lt;code&gt;__init__()&lt;/code&gt; immediately &lt;em&gt;after&lt;/em&gt; the module is loaded (e.g., by &lt;code&gt;import&lt;/code&gt;, &lt;code&gt;using&lt;/code&gt;, or &lt;code&gt;require&lt;/code&gt;) at runtime for the &lt;em&gt;first&lt;/em&gt; time (i.e., &lt;code&gt;__init__&lt;/code&gt; is only called once, and only after all statements in the module have been executed). Because it is called after the module is fully imported, any submodules or other imported modules have their &lt;code&gt;__init__&lt;/code&gt; functions called &lt;em&gt;before&lt;/em&gt; the &lt;code&gt;__init__&lt;/code&gt; of the enclosing module.</source>
          <target state="translated">具体的には、ユーザーが定義した場合 &lt;code&gt;function __init__()&lt;/code&gt; モジュールでは、その後、ジュリアが呼び出されます &lt;code&gt;__init__()&lt;/code&gt; すぐ&lt;em&gt;後に&lt;/em&gt;モジュールが（で、例えばロードされている &lt;code&gt;import&lt;/code&gt; 、 &lt;code&gt;using&lt;/code&gt; 、または &lt;code&gt;require&lt;/code&gt; ）実行時のための&lt;em&gt;最初&lt;/em&gt;の時間（すなわち、 &lt;code&gt;__init__&lt;/code&gt; があります1回だけ呼び出され、モジュール内のすべてのステートメントが実行された後にのみ呼び出されます）。モジュールが完全にインポートされた後に呼び出されるため、サブモジュールまたは他のインポートされたモジュールは、それらを囲んでいるモジュールの &lt;code&gt;__init__&lt;/code&gt; の&lt;em&gt;前&lt;/em&gt;に呼び出される &lt;code&gt;__init__&lt;/code&gt; 関数を持っています。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7f00fe64f586624c25d908def02434ca5a5747cc" translate="yes" xml:space="preserve">
          <source>In particular, note that &lt;code&gt;LibGit2.free&lt;/code&gt; should be called afterward on the &lt;code&gt;Ref&lt;/code&gt; object.</source>
          <target state="translated">特に、 &lt;code&gt;LibGit2.free&lt;/code&gt; は &lt;code&gt;Ref&lt;/code&gt; オブジェクトで後で呼び出す必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="1b992ee319e3397f73ab42aa368ea422a279c258" translate="yes" xml:space="preserve">
          <source>In particular, note that &lt;code&gt;missing == missing&lt;/code&gt; returns &lt;code&gt;missing&lt;/code&gt;, so &lt;code&gt;==&lt;/code&gt; cannot be used to test whether a value is missing. To test whether &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;missing&lt;/code&gt;, use &lt;a href=&quot;../../base/base/index#Base.ismissing&quot;&gt;&lt;code&gt;ismissing(x)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">具体的には、なお、 &lt;code&gt;missing == missing&lt;/code&gt; 戻る &lt;code&gt;missing&lt;/code&gt; ので &lt;code&gt;==&lt;/code&gt; 値が欠落しているかどうかをテストするために使用することができません。 &lt;code&gt;x&lt;/code&gt; が &lt;code&gt;missing&lt;/code&gt; かどうかをテストするには、&lt;a href=&quot;../../base/base/index#Base.ismissing&quot;&gt; &lt;code&gt;ismissing(x)&lt;/code&gt; を&lt;/a&gt;使用します。</target>
        </trans-unit>
        <trans-unit id="10aa2526d9c8eb28f8fc8b12b251cb66391f9afe" translate="yes" xml:space="preserve">
          <source>In particular, this means that small enough immutable values like integers and floats are typically passed to functions in registers (or stack allocated).</source>
          <target state="translated">特に、これは、整数や浮動小数点数のような十分に小さい不変値が、一般的にレジスタ内の関数に渡されることを意味します(または、スタックが割り当てられている)。</target>
        </trans-unit>
        <trans-unit id="bd271b290661f2d2dcd371ac877e792e11b0ae4c" translate="yes" xml:space="preserve">
          <source>In place of the written syntax, the macro call is expanded at parse time to its returned result. This is equivalent to writing:</source>
          <target state="translated">書かれた構文の代わりに、マクロ呼び出しは解析時に展開され、その結果が返されます。これは書き込みと同等です。</target>
        </trans-unit>
        <trans-unit id="f1faf89b83d5028304b1044be098d4330cb094e6" translate="yes" xml:space="preserve">
          <source>In practice, especially when providing reusable functionality, one generally wraps &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; uses in Julia functions that set up arguments and then check for errors in whatever manner the C or Fortran function indicates them, propagating to the Julia caller as exceptions. This is especially important since C and Fortran APIs are notoriously inconsistent about how they indicate error conditions. For example, the &lt;code&gt;getenv&lt;/code&gt; C library function is wrapped in the following Julia function, which is a simplified version of the actual definition from &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/env.jl&quot;&gt;&lt;code&gt;env.jl&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">実際には、特に再利用可能な機能を提供する場合は、通常、&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt;がJulia関数でラップして引数を設定し、CまたはFortran関数がそれらを示す方法でエラーをチェックし、Julia呼び出し元に例外として伝播します。CとFortranのAPIは、エラー状態を示す方法について一貫性がないことで悪名高いため、これは特に重要です。たとえば、 &lt;code&gt;getenv&lt;/code&gt; Cライブラリ関数は、次のJulia関数にラップされます。これは、&lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/env.jl&quot;&gt; &lt;code&gt;env.jl&lt;/code&gt; &lt;/a&gt;からの実際の定義を簡略化したバージョンです。</target>
        </trans-unit>
        <trans-unit id="4ee03fd7f1bb01022cf62529b6c1e2c9383e98c5" translate="yes" xml:space="preserve">
          <source>In practice, especially when providing reusable functionality, one generally wraps &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; uses in Julia functions that set up arguments and then check for errors in whatever manner the C or Fortran function specifies. And if an error occurs it is thrown as a normal Julia exception. This is especially important since C and Fortran APIs are notoriously inconsistent about how they indicate error conditions. For example, the &lt;code&gt;getenv&lt;/code&gt; C library function is wrapped in the following Julia function, which is a simplified version of the actual definition from &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/env.jl&quot;&gt;&lt;code&gt;env.jl&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">実際には、特に再利用可能な機能を提供する場合、通常、引数を設定するJulia関数で&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; の&lt;/a&gt;使用をラップし、CまたはFortran関数が指定する方法でエラーをチェックします。また、エラーが発生した場合は、通常のJulia例外としてスローされます。CおよびFortranAPIは、エラー状態を示す方法について一貫性がないことで悪名高いため、これは特に重要です。たとえば、 &lt;code&gt;getenv&lt;/code&gt; Cライブラリ関数は次のJulia関数でラップされています。これは、&lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/env.jl&quot;&gt; &lt;code&gt;env.jl&lt;/code&gt; &lt;/a&gt;からの実際の定義の簡略版です。</target>
        </trans-unit>
        <trans-unit id="804d748c80f6e79bb9e342f1f2304330f7eae29d" translate="yes" xml:space="preserve">
          <source>In principle, the Markdown parser itself can also be arbitrarily extended by packages, or an entirely custom flavour of Markdown can be used, but this should generally be unnecessary.</source>
          <target state="translated">原則として、Markdownパーサー自体はパッケージによって任意に拡張することができ、またはMarkdownの完全なカスタムフレーバーを使用することができますが、これは一般的には不要です。</target>
        </trans-unit>
        <trans-unit id="f1e4e6ce2511929e6de42c91eafd73bc415389d8" translate="yes" xml:space="preserve">
          <source>In short, it is an immutable dictionary that is a subclass of &lt;code&gt;IO&lt;/code&gt;. It supports standard dictionary operations such as &lt;a href=&quot;../collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt;, and can also be used as an I/O stream.</source>
          <target state="translated">つまり、 &lt;code&gt;IO&lt;/code&gt; のサブクラスである不変の辞書です。&lt;a href=&quot;../collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; &lt;/a&gt;などの標準の辞書操作をサポートし、I / Oストリームとしても使用できます。</target>
        </trans-unit>
        <trans-unit id="638b74bbfc0d77182896b29b38f7e41990e9ec77" translate="yes" xml:space="preserve">
          <source>In some applications, an alternative to zeroing subnormal numbers is to inject a tiny bit of noise. For example, instead of initializing &lt;code&gt;a&lt;/code&gt; with zeros, initialize it with:</source>
          <target state="translated">一部のアプリケーションでは、非正規数をゼロにする代わりに、ほんの少しのノイズを注入する方法があります。たとえば、 &lt;code&gt;a&lt;/code&gt; をゼロで初期化する代わりに、次のように初期化します。</target>
        </trans-unit>
        <trans-unit id="c0f7478a3f0be2e5b9c7e0905c13888f63fbab1a" translate="yes" xml:space="preserve">
          <source>In some applications, it is convenient to store explicit zero values in a &lt;code&gt;SparseMatrixCSC&lt;/code&gt;. These &lt;em&gt;are&lt;/em&gt; accepted by functions in &lt;code&gt;Base&lt;/code&gt; (but there is no guarantee that they will be preserved in mutating operations). Such explicitly stored zeros are treated as structural nonzeros by many routines. The &lt;a href=&quot;#SparseArrays.nnz&quot;&gt;&lt;code&gt;nnz&lt;/code&gt;&lt;/a&gt; function returns the number of elements explicitly stored in the sparse data structure, including structural nonzeros. In order to count the exact number of numerical nonzeros, use &lt;a href=&quot;../../base/collections/index#Base.count&quot;&gt;&lt;code&gt;count(!iszero, x)&lt;/code&gt;&lt;/a&gt;, which inspects every stored element of a sparse matrix. &lt;a href=&quot;#SparseArrays.dropzeros&quot;&gt;&lt;code&gt;dropzeros&lt;/code&gt;&lt;/a&gt;, and the in-place &lt;a href=&quot;#SparseArrays.dropzeros!&quot;&gt;&lt;code&gt;dropzeros!&lt;/code&gt;&lt;/a&gt;, can be used to remove stored zeros from the sparse matrix.</source>
          <target state="translated">一部のアプリケーションでは、明示的なゼロ値を &lt;code&gt;SparseMatrixCSC&lt;/code&gt; に格納すると便利です。これら&lt;em&gt;は&lt;/em&gt; &lt;code&gt;Base&lt;/code&gt; の関数で受け入れられます（ただし、変更操作で保持される保証はありません）。このような明示的に格納されたゼロは、多くのルーチンで構造的非ゼロとして扱われます。&lt;a href=&quot;#SparseArrays.nnz&quot;&gt; &lt;code&gt;nnz&lt;/code&gt; &lt;/a&gt;関数は、構造の非ゼロ要素を含む、明示的にスパースなデータ構造に格納された要素の数を返します。非ゼロの数値の正確な数をカウントするには、&lt;a href=&quot;../../base/collections/index#Base.count&quot;&gt; &lt;code&gt;count(!iszero, x)&lt;/code&gt; &lt;/a&gt;使用します。これは、スパース行列のすべての格納されている要素を検査します。&lt;a href=&quot;#SparseArrays.dropzeros&quot;&gt; &lt;code&gt;dropzeros&lt;/code&gt; &lt;/a&gt;とインプレースの&lt;a href=&quot;#SparseArrays.dropzeros!&quot;&gt; &lt;code&gt;dropzeros!&lt;/code&gt; &lt;/a&gt;、スパース行列から格納されたゼロを削除するために使用できます。</target>
        </trans-unit>
        <trans-unit id="7200ec90f922f3162b688616528f07bbd46b3f3f" translate="yes" xml:space="preserve">
          <source>In some cases changing the value of a &lt;code&gt;const&lt;/code&gt; variable gives a warning instead of an error. However, this can produce unpredictable behavior or corrupt the state of your program, and so should be avoided. This feature is intended only for convenience during interactive use.</source>
          <target state="translated">場合によっては、 &lt;code&gt;const&lt;/code&gt; 変数の値を変更すると、エラーではなく警告が表示されます。ただし、これにより予測できない動作が発生したり、プログラムの状態が破損したりする可能性があるため、回避する必要があります。この機能は、インタラクティブな使用中の便宜のためにのみ意図されています。</target>
        </trans-unit>
        <trans-unit id="0bca4b7af7b2c3f590b22d6bdc9c439dda8d86d1" translate="yes" xml:space="preserve">
          <source>In some cases it might be convenient not to have to define &lt;code&gt;MyStyle&lt;/code&gt;, in which case you can leverage one of the general broadcast wrappers:</source>
          <target state="translated">&lt;code&gt;MyStyle&lt;/code&gt; を定義する必要がない方が便利な場合もあります。その場合は、一般的なブロードキャストラッパーの1つを利用できます。</target>
        </trans-unit>
        <trans-unit id="6f5f29a98f7076181fba48634a540b92f8996002" translate="yes" xml:space="preserve">
          <source>In some cases no reduction operator is needed, and we merely wish to apply a function to all integers in some range (or, more generally, to all elements in some collection). This is another useful operation called &lt;em&gt;parallel map&lt;/em&gt;, implemented in Julia as the &lt;a href=&quot;../../stdlib/distributed/index#Distributed.pmap&quot;&gt;&lt;code&gt;pmap&lt;/code&gt;&lt;/a&gt; function. For example, we could compute the singular values of several large random matrices in parallel as follows:</source>
          <target state="translated">場合によっては、縮約演算子が不要で、ある範囲のすべての整数（または、より一般的には、いくつかのコレクションのすべての要素）に関数を適用したいだけです。これは、Juliaで&lt;a href=&quot;../../stdlib/distributed/index#Distributed.pmap&quot;&gt; &lt;code&gt;pmap&lt;/code&gt; &lt;/a&gt;関数として実装された、&lt;em&gt;並列マップ&lt;/em&gt;と呼ばれるもう1つの便利な操作です。たとえば、次のように、いくつかの大きなランダム行列の特異値を並列に計算できます。</target>
        </trans-unit>
        <trans-unit id="6de51e42bc98441adfec5061cc53937870969a7a" translate="yes" xml:space="preserve">
          <source>In some cases, for a given RNG type, generating an array of random values can be more efficient with a specialized method than by merely using the decoupling technique explained before. This is for example the case for &lt;code&gt;MersenneTwister&lt;/code&gt;, which natively writes random values in an array.</source>
          <target state="translated">場合によっては、特定のRNGタイプについて、ランダム値の配列を生成する方が、前に説明したデカップリングテクニックを単に使用するよりも、特殊な方法を使用する方が効率的です。これは、たとえば、ネイティブで配列にランダムな値を書き込む &lt;code&gt;MersenneTwister&lt;/code&gt; の場合です。</target>
        </trans-unit>
        <trans-unit id="f953f89be50274569ebdd1d16dd1091ac2cf9f4a" translate="yes" xml:space="preserve">
          <source>In some cases, it is useful to adjust the behavior of &lt;code&gt;show&lt;/code&gt; methods depending on the context. This can be achieved via the &lt;a href=&quot;../../base/io-network/index#Base.IOContext&quot;&gt;&lt;code&gt;IOContext&lt;/code&gt;&lt;/a&gt; type, which allows passing contextual properties together with a wrapped IO stream. For example, we can build a shorter representation in our &lt;code&gt;show&lt;/code&gt; method when the &lt;code&gt;:compact&lt;/code&gt; property is set to &lt;code&gt;true&lt;/code&gt;, falling back to the long representation if the property is &lt;code&gt;false&lt;/code&gt; or absent:</source>
          <target state="translated">場合によっては、コンテキストに応じて &lt;code&gt;show&lt;/code&gt; メソッドの動作を調整すると便利です。これは、ラップされたIOストリームと一緒にコンテキストプロパティを渡すことができる&lt;a href=&quot;../../base/io-network/index#Base.IOContext&quot;&gt; &lt;code&gt;IOContext&lt;/code&gt; &lt;/a&gt;タイプを介して実現できます。たとえば、 &lt;code&gt;:compact&lt;/code&gt; プロパティが &lt;code&gt;true&lt;/code&gt; に設定されている場合は、 &lt;code&gt;show&lt;/code&gt; メソッドで短い表現を作成し、プロパティが &lt;code&gt;false&lt;/code&gt; または存在しない場合は長い表現にフォールバックできます。</target>
        </trans-unit>
        <trans-unit id="ef681cb1496bc3731bd754661d5504701ec7c4ad" translate="yes" xml:space="preserve">
          <source>In some cases, whether one wants to generate only a handful of values or a large number of values will have an impact on the choice of algorithm. This is handled with the third parameter of the &lt;code&gt;Sampler&lt;/code&gt; constructor. Let's assume we defined two helper types for &lt;code&gt;Die&lt;/code&gt;, say &lt;code&gt;SamplerDie1&lt;/code&gt; which should be used to generate only few random values, and &lt;code&gt;SamplerDieMany&lt;/code&gt; for many values. We can use those types as follows:</source>
          <target state="translated">場合によっては、少数の値のみを生成するか、多数の値を生成するかが、アルゴリズムの選択に影響を与えます。これは、 &lt;code&gt;Sampler&lt;/code&gt; コンストラクターの3番目のパラメーターで処理されます。我々はのための2つのヘルパー種類定義されてと仮定しましょう &lt;code&gt;Die&lt;/code&gt; 、言う &lt;code&gt;SamplerDie1&lt;/code&gt; のみいくつかのランダムな値を生成するために使用されなければならない、と &lt;code&gt;SamplerDieMany&lt;/code&gt; を多くの値について。これらのタイプは次のように使用できます。</target>
        </trans-unit>
        <trans-unit id="a8e2e50c5e5c4d32f74208fde4cbb36b4d6312f3" translate="yes" xml:space="preserve">
          <source>In some languages, the empty tuple (&lt;code&gt;()&lt;/code&gt;) is considered the canonical form of nothingness. However, in julia it is best thought of as just a regular tuple that happens to contain zero values.</source>
          <target state="translated">一部の言語では、空のタプル（ &lt;code&gt;()&lt;/code&gt; ）は無の正規形と見なされます。ただし、ジュリアでは、たまたまゼロ値を含む通常のタプルとして考えるのが最適です。</target>
        </trans-unit>
        <trans-unit id="eb5807b7c193c64d46f5bc3d42f551af1a206e90" translate="yes" xml:space="preserve">
          <source>In some problems, the various pieces of required work are not naturally related by function calls; there is no obvious &quot;caller&quot; or &quot;callee&quot; among the jobs that need to be done. An example is the producer-consumer problem, where one complex procedure is generating values and another complex procedure is consuming them. The consumer cannot simply call a producer function to get a value, because the producer may have more values to generate and so might not yet be ready to return. With tasks, the producer and consumer can both run as long as they need to, passing values back and forth as necessary.</source>
          <target state="translated">いくつかの問題では、必要とされる作業の様々な部分は、当然のことながら関数の呼び出しによって関連づけられていません。例えば、ある複雑なプロシージャが値を生成し、別の複雑なプロシージャが値を消費しているような、生産者と消費者の問題があります。消費者は、単にプロデューサ関数を呼び出して値を取得することはできません。タスクを使えば、プロデューサとコンシューマは必要なだけ実行し、必要に応じて値を前後に渡すことができます。</target>
        </trans-unit>
        <trans-unit id="46bc7cae3ed284ebaa58a72dfb5ca4f122d19b91" translate="yes" xml:space="preserve">
          <source>In some situations, your function may need to allocate memory as part of its operation, and this can complicate the simple picture above. In such cases, consider using one of the &lt;a href=&quot;#tools&quot;&gt;tools&lt;/a&gt; below to diagnose problems, or write a version of your function that separates allocation from its algorithmic aspects (see &lt;a href=&quot;#Pre-allocating-outputs&quot;&gt;Pre-allocating outputs&lt;/a&gt;).</source>
          <target state="translated">状況によっては、関数がその操作の一部としてメモリを割り当てる必要がある場合があり、これにより上記の単純な図が複雑になる可能性があります。このような場合は、以下の&lt;a href=&quot;#tools&quot;&gt;ツールの&lt;/a&gt;いずれかを使用して問題を診断するか、割り当てをアルゴリズムの側面から分離する関数のバージョンを作成することを検討してください（&lt;a href=&quot;#Pre-allocating-outputs&quot;&gt;出力の事前割り当てを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="793adcc5e6d1a8b0006e672f0871fab8bd1ee12e" translate="yes" xml:space="preserve">
          <source>In some situations, your function may need to allocate memory as part of its operation, and this can complicate the simple picture above. In such cases, consider using one of the &lt;a href=&quot;#tools-1&quot;&gt;tools&lt;/a&gt; below to diagnose problems, or write a version of your function that separates allocation from its algorithmic aspects (see &lt;a href=&quot;#Pre-allocating-outputs-1&quot;&gt;Pre-allocating outputs&lt;/a&gt;).</source>
          <target state="translated">一部の状況では、関数がその操作の一部としてメモリを割り当てる必要があり、これにより上記の簡単な図が複雑になる場合があります。そのような場合は、以下の&lt;a href=&quot;#tools-1&quot;&gt;ツールの&lt;/a&gt;いずれかを使用して問題を診断するか、割り当てをアルゴリズムの側面から分離する関数のバージョンを作成することを検討してください（&lt;a href=&quot;#Pre-allocating-outputs-1&quot;&gt;出力の事前割り当てを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="2a0f5f99ad11403dc52acb366ff631558f32f389" translate="yes" xml:space="preserve">
          <source>In step 2 below, edit &lt;code&gt;MyPkg/src/MyPkg.jl&lt;/code&gt; to change the source code, and &lt;code&gt;MyPkg/test/runtests.jl&lt;/code&gt; for the tests.</source>
          <target state="translated">以下のステップ2で、 &lt;code&gt;MyPkg/src/MyPkg.jl&lt;/code&gt; を編集してソースコードを変更し、 &lt;code&gt;MyPkg/test/runtests.jl&lt;/code&gt; をテスト用に変更します。</target>
        </trans-unit>
        <trans-unit id="18fa22072854af164b60f3647ea657dba3a66a38" translate="yes" xml:space="preserve">
          <source>In step 2 below, edit &lt;code&gt;MyPkg/src/MyPkg.jl&lt;/code&gt; to change the source code, and create any test file of your choosing.</source>
          <target state="translated">以下のステップ2で、 &lt;code&gt;MyPkg/src/MyPkg.jl&lt;/code&gt; を編集してソースコードを変更し、任意のテストファイルを作成します。</target>
        </trans-unit>
        <trans-unit id="4a0eaae9f72d9710fb65a9583dfc845568e81d5f" translate="yes" xml:space="preserve">
          <source>In such cases one should redesign the code to avoid the possibility of a race condition or use &lt;a href=&quot;https://docs.julialang.org/en/latest/base/multi-threading/#Synchronization-Primitives-1&quot;&gt;synchronization primitives&lt;/a&gt;.</source>
          <target state="translated">このような場合、競合状態の可能性を回避するか、&lt;a href=&quot;https://docs.julialang.org/en/latest/base/multi-threading/#Synchronization-Primitives-1&quot;&gt;同期プリミティブを&lt;/a&gt;使用するようにコードを再設計する必要があります。</target>
        </trans-unit>
        <trans-unit id="2e9e71bba5509813057399a4f8d90c9c53704d76" translate="yes" xml:space="preserve">
          <source>In such cases, the result is always 1-d.</source>
          <target state="translated">このような場合、結果は必ず1-dとなります。</target>
        </trans-unit>
        <trans-unit id="de5de110f5af15ec4cd1a61e4b555c94b532b3cc" translate="yes" xml:space="preserve">
          <source>In technical-computing languages, it is common to have &quot;vectorized&quot; versions of functions, which simply apply a given function &lt;code&gt;f(x)&lt;/code&gt; to each element of an array &lt;code&gt;A&lt;/code&gt; to yield a new array via &lt;code&gt;f(A)&lt;/code&gt;. This kind of syntax is convenient for data processing, but in other languages vectorization is also often required for performance: if loops are slow, the &quot;vectorized&quot; version of a function can call fast library code written in a low-level language. In Julia, vectorized functions are &lt;em&gt;not&lt;/em&gt; required for performance, and indeed it is often beneficial to write your own loops (see &lt;a href=&quot;../performance-tips/index#man-performance-tips&quot;&gt;Performance Tips&lt;/a&gt;), but they can still be convenient. Therefore, &lt;em&gt;any&lt;/em&gt; Julia function &lt;code&gt;f&lt;/code&gt; can be applied elementwise to any array (or other collection) with the syntax &lt;code&gt;f.(A)&lt;/code&gt;. For example, &lt;code&gt;sin&lt;/code&gt; can be applied to all elements in the vector &lt;code&gt;A&lt;/code&gt; like so:</source>
          <target state="translated">テクニカルコンピューティング言語では、関数の「ベクトル化」バージョンを使用するのが一般的です。これは、配列 &lt;code&gt;A&lt;/code&gt; の各要素に特定の関数 &lt;code&gt;f(x)&lt;/code&gt; を適用するだけで、 &lt;code&gt;f(A)&lt;/code&gt; を介して新しい配列を生成します。この種の構文はデータ処理に便利ですが、他の言語ではパフォーマンスのためにベクトル化も必要になることがよくあります。ループが遅い場合、関数の「ベクトル化」バージョンは低レベル言語で記述された高速ライブラリコードを呼び出すことができます。 Juliaでは、パフォーマンスにベクトル化された関数は必要あり&lt;em&gt;ません。&lt;/em&gt;実際、独自のループを作成すると便利なことがよくありますが（&lt;a href=&quot;../performance-tips/index#man-performance-tips&quot;&gt;パフォーマンスのヒントを&lt;/a&gt;参照）、それでも便利です。したがって、&lt;em&gt;任意の&lt;/em&gt;ユリウス関数 &lt;code&gt;f&lt;/code&gt; &lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;構文 &lt;code&gt;f.(A)&lt;/code&gt; して、任意の配列（または他のコレクション）に要素ごとに適用できます。たとえば、 &lt;code&gt;sin&lt;/code&gt; は、次 &lt;code&gt;A&lt;/code&gt; ようにベクトルAのすべての要素に適用できます。</target>
        </trans-unit>
        <trans-unit id="c795388eedec3a869fe287bc8b5bbacb71a43dbd" translate="yes" xml:space="preserve">
          <source>In technical-computing languages, it is common to have &quot;vectorized&quot; versions of functions, which simply apply a given function &lt;code&gt;f(x)&lt;/code&gt; to each element of an array &lt;code&gt;A&lt;/code&gt; to yield a new array via &lt;code&gt;f(A)&lt;/code&gt;. This kind of syntax is convenient for data processing, but in other languages vectorization is also often required for performance: if loops are slow, the &quot;vectorized&quot; version of a function can call fast library code written in a low-level language. In Julia, vectorized functions are &lt;em&gt;not&lt;/em&gt; required for performance, and indeed it is often beneficial to write your own loops (see &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;Performance Tips&lt;/a&gt;), but they can still be convenient. Therefore, &lt;em&gt;any&lt;/em&gt; Julia function &lt;code&gt;f&lt;/code&gt; can be applied elementwise to any array (or other collection) with the syntax &lt;code&gt;f.(A)&lt;/code&gt;. For example, &lt;code&gt;sin&lt;/code&gt; can be applied to all elements in the vector &lt;code&gt;A&lt;/code&gt; like so:</source>
          <target state="translated">テクニカルコンピューティング言語では、「ベクトル化」バージョンの関数を使用するのが一般的です。これは、与えられた関数 &lt;code&gt;f(x)&lt;/code&gt; を配列 &lt;code&gt;A&lt;/code&gt; の各要素に適用するだけで、 &lt;code&gt;f(A)&lt;/code&gt; を介して新しい配列を生成します。この種の構文はデータ処理に便利ですが、他の言語ではパフォーマンスのためにベクトル化もしばしば必要です。ループが遅い場合、「ベクトル化」バージョンの関数は低レベル言語で記述された高速ライブラリコードを呼び出すことができます。 Juliaでは、ベクトル化された関数はパフォーマンスに必要あり&lt;em&gt;ません。&lt;/em&gt;実際に、独自のループを作成することはしばしば有益です（&lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;パフォーマンスのヒントを&lt;/a&gt;参照）。しかし、それらは依然として便利です。したがって、&lt;em&gt;任意の&lt;/em&gt;ジュリア関数 &lt;code&gt;f&lt;/code&gt; 構文 &lt;code&gt;f.(A)&lt;/code&gt; して、任意の配列（または他のコレクション）に要素ごとに適用できます。たとえば、 &lt;code&gt;sin&lt;/code&gt; はベクトル &lt;code&gt;A&lt;/code&gt; のすべての要素に次のように適用できます。</target>
        </trans-unit>
        <trans-unit id="1295513c71d65c30e7efa46afbaa35e5c9e76740" translate="yes" xml:space="preserve">
          <source>In terms of UNIX plumbing, what's happening here is that a single UNIX pipe object is created and written to by both &lt;code&gt;echo&lt;/code&gt; processes, and the other end of the pipe is read from by the &lt;code&gt;sort&lt;/code&gt; command.</source>
          <target state="translated">UNIXの配管に関しては、単一のUNIXパイプオブジェクトが作成され、両方の &lt;code&gt;echo&lt;/code&gt; プロセスによって書き込まれ、パイプのもう一方の端は &lt;code&gt;sort&lt;/code&gt; コマンドによって読み取られます。</target>
        </trans-unit>
        <trans-unit id="bc29b396f06d90d9310efc41817564ce48560df4" translate="yes" xml:space="preserve">
          <source>In the Julia REPL and several other Julia editing environments, you can type many Unicode math symbols by typing the backslashed LaTeX symbol name followed by tab. For example, the variable name &lt;code&gt;&amp;delta;&lt;/code&gt; can be entered by typing &lt;code&gt;\delta&lt;/code&gt;-&lt;em&gt;tab&lt;/em&gt;, or even &lt;code&gt;&amp;alpha;̂₂&lt;/code&gt; by &lt;code&gt;\alpha&lt;/code&gt;-&lt;em&gt;tab&lt;/em&gt;-&lt;code&gt;\hat&lt;/code&gt;- &lt;em&gt;tab&lt;/em&gt;-&lt;code&gt;\_2&lt;/code&gt;-&lt;em&gt;tab&lt;/em&gt;. (If you find a symbol somewhere, e.g. in someone else's code, that you don't know how to type, the REPL help will tell you: just type &lt;code&gt;?&lt;/code&gt; and then paste the symbol.)</source>
          <target state="translated">Julia REPLおよび他のいくつかのJulia編集環境では、バックスラッシュ付きのLaTeXシンボル名に続けてタブを入力することにより、多くのUnicode数学シンボルを入力できます。たとえば、変数名 &lt;code&gt;&amp;delta;&lt;/code&gt; は、タイピングで入力することができます &lt;code&gt;\delta&lt;/code&gt; - &lt;em&gt;タブ&lt;/em&gt;、あるいは &lt;code&gt;&amp;alpha;̂₂&lt;/code&gt; で &lt;code&gt;\alpha&lt;/code&gt; - &lt;em&gt;タブ&lt;/em&gt; - &lt;code&gt;\hat&lt;/code&gt; - &lt;em&gt;タブ&lt;/em&gt; - &lt;code&gt;\_2&lt;/code&gt; - &lt;em&gt;タブ&lt;/em&gt;。 （どこか他の人のコードなどで、タイプする方法がわからないシンボルを見つけた場合、REPLヘルプが教えてくれます： &lt;code&gt;?&lt;/code&gt; とタイプして、シンボルを貼り付けるだけです。）</target>
        </trans-unit>
        <trans-unit id="7569c827c9a13b3faf85c9b20e363a3375ada161" translate="yes" xml:space="preserve">
          <source>In the above example, &lt;code&gt;@everywhere module Foo&lt;/code&gt; defined &lt;code&gt;Foo&lt;/code&gt; on all nodes. However the call to &lt;code&gt;Foo.foo()&lt;/code&gt; created a new global binding &lt;code&gt;gvar&lt;/code&gt; on the local node, but this was not found on node 2 resulting in an &lt;code&gt;UndefVarError&lt;/code&gt; error.</source>
          <target state="translated">上記の例では、 &lt;code&gt;@everywhere module Foo&lt;/code&gt; &lt;code&gt;Foo&lt;/code&gt; がすべてのノードでFooを定義しました。ただし、 &lt;code&gt;Foo.foo()&lt;/code&gt; の呼び出しにより、ローカルノードに新しいグローバルバインディング &lt;code&gt;gvar&lt;/code&gt; が作成されましたが、ノード2でこれが見つからなかったため、 &lt;code&gt;UndefVarError&lt;/code&gt; エラーが発生しました。</target>
        </trans-unit>
        <trans-unit id="4befd8beabfc58d36d63a701ccb0fcbe3c3991f4" translate="yes" xml:space="preserve">
          <source>In the absence of a type declaration with &lt;code&gt;::&lt;/code&gt;, the type of a method parameter is &lt;code&gt;Any&lt;/code&gt; by default, meaning that it is unconstrained since all values in Julia are instances of the abstract type &lt;code&gt;Any&lt;/code&gt;. Thus, we can define a catch-all method for &lt;code&gt;f&lt;/code&gt; like so:</source>
          <target state="translated">&lt;code&gt;::&lt;/code&gt; を使用した型宣言がない場合、メソッドパラメーターの型はデフォルトで &lt;code&gt;Any&lt;/code&gt; になります。つまり、Juliaのすべての値は抽象型 &lt;code&gt;Any&lt;/code&gt; のインスタンスであるため、制約されません。したがって、 &lt;code&gt;f&lt;/code&gt; のキャッチオールメソッドを次のように定義できます。</target>
        </trans-unit>
        <trans-unit id="804c2e460ca33d08a52c531b866706df762bfe07" translate="yes" xml:space="preserve">
          <source>In the assignment form, the body of the function must be a single expression, although it can be a compound expression (see &lt;a href=&quot;../control-flow/index#man-compound-expressions&quot;&gt;Compound Expressions&lt;/a&gt;). Short, simple function definitions are common in Julia. The short function syntax is accordingly quite idiomatic, considerably reducing both typing and visual noise.</source>
          <target state="translated">割り当てフォームでは、関数の本体は単一の式である必要がありますが、複合式にすることもできます（&lt;a href=&quot;../control-flow/index#man-compound-expressions&quot;&gt;複合式を&lt;/a&gt;参照）。Juliaでは、短くて単純な関数定義が一般的です。したがって、短い関数構文は非常に慣用的であり、タイピングと視覚的なノイズの両方を大幅に削減します。</target>
        </trans-unit>
        <trans-unit id="14e6eb62fa9a3db0a4d3297fcd4c7b6e7504f490" translate="yes" xml:space="preserve">
          <source>In the assignment form, the body of the function must be a single expression, although it can be a compound expression (see &lt;a href=&quot;../control-flow/index#man-compound-expressions-1&quot;&gt;Compound Expressions&lt;/a&gt;). Short, simple function definitions are common in Julia. The short function syntax is accordingly quite idiomatic, considerably reducing both typing and visual noise.</source>
          <target state="translated">代入式では、関数の本体は単一の式でなければなりませんが、複合式にすることもできます（&lt;a href=&quot;../control-flow/index#man-compound-expressions-1&quot;&gt;複合式を&lt;/a&gt;参照）。Juliaでは、短く単純な関数定義が一般的です。したがって、短い関数構文は非常に慣用的であり、タイピングと視覚ノイズの両方を大幅に削減します。</target>
        </trans-unit>
        <trans-unit id="8b4a822ba35b7b2a2b87214b87f56abe71bd6a7e" translate="yes" xml:space="preserve">
          <source>In the body of the generated function you only have access to the &lt;em&gt;types&lt;/em&gt; of the arguments &amp;ndash; not their values &amp;ndash; and any function that was defined &lt;em&gt;before&lt;/em&gt; the definition of the generated function.</source>
          <target state="translated">生成された関数の本体では、引数の&lt;em&gt;タイプ&lt;/em&gt;（値ではなく）と、生成された関数の定義&lt;em&gt;前&lt;/em&gt;に定義された関数にのみアクセスできます。</target>
        </trans-unit>
        <trans-unit id="50c2c4d1cb9a5c5c26d9acf8cbb1ac2672dac8d1" translate="yes" xml:space="preserve">
          <source>In the body of the generated function you only have access to the &lt;em&gt;types&lt;/em&gt; of the arguments &amp;ndash; not their values.</source>
          <target state="translated">生成された関数の本体では、引数の&lt;em&gt;タイプ&lt;/em&gt;にのみアクセスでき、値にはアクセスできません。</target>
        </trans-unit>
        <trans-unit id="d4f8a53fe3cbe9ccdbd0383d96fd01b1b384f1cc" translate="yes" xml:space="preserve">
          <source>In the case of &lt;code&gt;Point&lt;/code&gt;, the type of &lt;code&gt;T&lt;/code&gt; is unambiguously implied if and only if the two arguments to &lt;code&gt;Point&lt;/code&gt; have the same type. When this isn't the case, the constructor will fail with a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;Point&lt;/code&gt; の場合、 &lt;code&gt;T&lt;/code&gt; の型は、 &lt;code&gt;Point&lt;/code&gt; への2つの引数が同じ型である場合に限り、明確に暗示されます。そうでない場合、コンストラクタは&lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; で&lt;/a&gt;失敗します。</target>
        </trans-unit>
        <trans-unit id="8083b5b25cdad6fa0ec0e103815341575e54f6a2" translate="yes" xml:space="preserve">
          <source>In the case that the type of &lt;code&gt;a[1]&lt;/code&gt; is not known precisely, &lt;code&gt;x&lt;/code&gt; can be declared via &lt;code&gt;x = convert(Int32, a[1])::Int32&lt;/code&gt;. The use of the &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt; function allows &lt;code&gt;a[1]&lt;/code&gt; to be any object convertible to an &lt;code&gt;Int32&lt;/code&gt; (such as &lt;code&gt;UInt8&lt;/code&gt;), thus increasing the genericity of the code by loosening the type requirement. Notice that &lt;code&gt;convert&lt;/code&gt; itself needs a type annotation in this context in order to achieve type stability. This is because the compiler cannot deduce the type of the return value of a function, even &lt;code&gt;convert&lt;/code&gt;, unless the types of all the function's arguments are known.</source>
          <target state="translated">&lt;code&gt;a[1]&lt;/code&gt; 型が正確にわからない場合、 &lt;code&gt;x&lt;/code&gt; は &lt;code&gt;x = convert(Int32, a[1])::Int32&lt;/code&gt; 介して宣言できます。使用&lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt;機能を可能にする &lt;code&gt;a[1]&lt;/code&gt; に変換する任意のオブジェクトであること &lt;code&gt;Int32&lt;/code&gt; （例えば、 &lt;code&gt;UInt8&lt;/code&gt; こうして型要件を緩めることにより、コードの汎用性を増加させます）。型の安定性を実現するために、このコンテキストでは &lt;code&gt;convert&lt;/code&gt; 自体が型注釈を必要とすることに注意してください。これは、関数のすべての引数の型が既知でない限り、コンパイラは関数の戻り値の型を推測することも、たとえ &lt;code&gt;convert&lt;/code&gt; を行うこともできないためです。</target>
        </trans-unit>
        <trans-unit id="7c1119f311ce545842278fe205e3f9855f274299" translate="yes" xml:space="preserve">
          <source>In the context of an expression, symbols are used to indicate access to variables; when an expression is evaluated, a symbol is replaced with the value bound to that symbol in the appropriate &lt;a href=&quot;../variables-and-scoping/index#scope-of-variables&quot;&gt;scope&lt;/a&gt;.</source>
          <target state="translated">式のコンテキストでは、変数へのアクセスを示すために記号が使用されます。式が評価されると、シンボルは適切な&lt;a href=&quot;../variables-and-scoping/index#scope-of-variables&quot;&gt;スコープ内の&lt;/a&gt;そのシンボルにバインドされた値に置き換えられます。</target>
        </trans-unit>
        <trans-unit id="831b049ac64422357fdc2a1f1e12b98990a72d96" translate="yes" xml:space="preserve">
          <source>In the context of an expression, symbols are used to indicate access to variables; when an expression is evaluated, a symbol is replaced with the value bound to that symbol in the appropriate &lt;a href=&quot;../variables-and-scoping/index#scope-of-variables-1&quot;&gt;scope&lt;/a&gt;.</source>
          <target state="translated">式のコンテキストでは、変数へのアクセスを示すために記号が使用されます。式が評価されると、シンボルは適切な&lt;a href=&quot;../variables-and-scoping/index#scope-of-variables-1&quot;&gt;スコープ&lt;/a&gt;でそのシンボルにバインドされた値に置き換えられます。</target>
        </trans-unit>
        <trans-unit id="bb0ccf20285ac1f5e0c9e737c0f406f1f62a6d45" translate="yes" xml:space="preserve">
          <source>In the context of function definitions, the &lt;code&gt;...&lt;/code&gt; operator is used to combine many different arguments into a single argument. This use of &lt;code&gt;...&lt;/code&gt; for combining many different arguments into a single argument is called slurping:</source>
          <target state="translated">関数定義のコンテキストでは、 &lt;code&gt;...&lt;/code&gt; 演算子を使用して、さまざまな引数を1つの引数に結合します。多くの異なる引数を単一の引数に組み合わせるための &lt;code&gt;...&lt;/code&gt; のこの使用は、丸呑みと呼ばれます。</target>
        </trans-unit>
        <trans-unit id="93652cdf53268e5b525c9968aae662e21595f44e" translate="yes" xml:space="preserve">
          <source>In the end we will present Julia's approach to distributed and parallel computing. With scientific computing in mind, Julia natively implements interfaces to distribute a process across multiple cores or machines. Also we will mention useful external packages for distributed programming like &lt;code&gt;MPI.jl&lt;/code&gt; and &lt;code&gt;DistributedArrays.jl&lt;/code&gt;.</source>
          <target state="translated">最後に、分散および並列コンピューティングに対するJuliaのアプローチを紹介します。科学計算を念頭に置いて、ジュリアはネイティブにインターフェースを実装して、複数のコアまたはマシンにプロセスを分散します。また、 &lt;code&gt;MPI.jl&lt;/code&gt; や &lt;code&gt;DistributedArrays.jl&lt;/code&gt; などの分散プログラミングに役立つ外部パッケージについても説明します。</target>
        </trans-unit>
        <trans-unit id="d323acfd53199deb66ce97dad2e67a0a4f124fda" translate="yes" xml:space="preserve">
          <source>In the event that a nested test set has no failures, as happened here, it will be hidden in the summary. If we do have a test failure, only the details for the failed test sets will be shown:</source>
          <target state="translated">ここで起こったように、入れ子になっているテストセットに失敗がなかった場合は、要約の中で非表示になります。テストに失敗した場合、失敗したテストセットの詳細のみが表示されます。</target>
        </trans-unit>
        <trans-unit id="381773d3ab62fd2b5a03a4a6a4af80e1db7c0e67" translate="yes" xml:space="preserve">
          <source>In the event that two modules provide non-standard string or command literals with the same name, it is possible to qualify the string or command literal with a module name. For instance, if both &lt;code&gt;Foo&lt;/code&gt; and &lt;code&gt;Bar&lt;/code&gt; provide non-standard string literal &lt;code&gt;@x_str&lt;/code&gt;, then one can write &lt;code&gt;Foo.x&quot;literal&quot;&lt;/code&gt; or &lt;code&gt;Bar.x&quot;literal&quot;&lt;/code&gt; to disambiguate between the two.</source>
          <target state="translated">2つのモジュールが同じ名前の非標準の文字列またはコマンドリテラルを提供する場合、モジュール名で文字列またはコマンドリテラルを修飾することが可能です。たとえば、 &lt;code&gt;Foo&lt;/code&gt; と &lt;code&gt;Bar&lt;/code&gt; の両方が非標準の文字列リテラル &lt;code&gt;@x_str&lt;/code&gt; を提供する場合、 &lt;code&gt;Foo.x&quot;literal&quot;&lt;/code&gt; または &lt;code&gt;Bar.x&quot;literal&quot;&lt;/code&gt; を記述して、2つを区別できます。</target>
        </trans-unit>
        <trans-unit id="9a888754236863b7dc502d80ea92bd70226cbd16" translate="yes" xml:space="preserve">
          <source>In the example above, the code between &lt;code&gt;#=&lt;/code&gt; and &lt;code&gt;=#&lt;/code&gt; is run as a &lt;code&gt;bash&lt;/code&gt; script. Julia ignores this part since it is a multi-line comment for Julia. The Julia code after &lt;code&gt;=#&lt;/code&gt; is ignored by &lt;code&gt;bash&lt;/code&gt; since it stops parsing the file once it reaches to the &lt;code&gt;exec&lt;/code&gt; statement.</source>
          <target state="translated">上記の例では、 &lt;code&gt;#=&lt;/code&gt; と &lt;code&gt;=#&lt;/code&gt; の間のコードは &lt;code&gt;bash&lt;/code&gt; スクリプトとして実行されます。Juliaは複数行のコメントであるため、Juliaはこの部分を無視します。 &lt;code&gt;=#&lt;/code&gt; の後のJuliaコードは、 &lt;code&gt;exec&lt;/code&gt; ステートメントに到達するとファイルの解析を停止するため、 &lt;code&gt;bash&lt;/code&gt; によって無視されます。</target>
        </trans-unit>
        <trans-unit id="7fab8ccf3e309196934d3171621e67c5c348c19f" translate="yes" xml:space="preserve">
          <source>In the example below the in-range check for referencing element &lt;code&gt;i&lt;/code&gt; of array &lt;code&gt;A&lt;/code&gt; is skipped to improve performance.</source>
          <target state="translated">以下の例では、パフォーマンスを向上させるために、配列 &lt;code&gt;A&lt;/code&gt; の要素 &lt;code&gt;i&lt;/code&gt; を参照するための範囲内チェックはスキップされます。</target>
        </trans-unit>
        <trans-unit id="93579590b1d00912366971a9f1eaa55dfd5a9050" translate="yes" xml:space="preserve">
          <source>In the example manifest file above, to find the path of the first &lt;code&gt;Priv&lt;/code&gt; package&amp;mdash;the one with UUID &lt;code&gt;ba13f791-ae1d-465a-978b-69c3ad90f72b&lt;/code&gt;&amp;mdash;Julia looks for its stanza in the manifest file, sees that it has a &lt;code&gt;path&lt;/code&gt; entry, looks at &lt;code&gt;deps/Priv&lt;/code&gt; relative to the &lt;code&gt;App&lt;/code&gt; project directory&amp;mdash;let's suppose the &lt;code&gt;App&lt;/code&gt; code lives in &lt;code&gt;/home/me/projects/App&lt;/code&gt;&amp;mdash;sees that &lt;code&gt;/home/me/projects/App/deps/Priv&lt;/code&gt; exists and therefore loads &lt;code&gt;Priv&lt;/code&gt; from there.</source>
          <target state="translated">上記のマニフェストファイルの例では、最初の &lt;code&gt;Priv&lt;/code&gt; パッケージ（UUIDが &lt;code&gt;ba13f791-ae1d-465a-978b-69c3ad90f72b&lt;/code&gt; のパッケージ）のパスを見つけるために、Juliaはマニフェストファイルでスタンザを探し、 &lt;code&gt;path&lt;/code&gt; エントリがあることを確認します。で &lt;code&gt;deps/Priv&lt;/code&gt; に比べて &lt;code&gt;App&lt;/code&gt; プロジェクトディレクトリ-LETのは、仮定 &lt;code&gt;App&lt;/code&gt; でコード命を &lt;code&gt;/home/me/projects/App&lt;/code&gt; その-sees &lt;code&gt;/home/me/projects/App/deps/Priv&lt;/code&gt; 存在するため、ロード &lt;code&gt;Priv&lt;/code&gt; そこから。</target>
        </trans-unit>
        <trans-unit id="d5f7b0ad7d3e9a880bbfbe0e4c7c117bb4c01b0c" translate="yes" xml:space="preserve">
          <source>In the expression &lt;code&gt;A[I_1, I_2, ..., I_n]&lt;/code&gt;, each &lt;code&gt;I_k&lt;/code&gt; may be a scalar index, an array of scalar indices, or an object that represents an array of scalar indices and can be converted to such by &lt;a href=&quot;../../base/arrays/index#Base.to_indices&quot;&gt;&lt;code&gt;to_indices&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">式 &lt;code&gt;A[I_1, I_2, ..., I_n]&lt;/code&gt; では、各 &lt;code&gt;I_k&lt;/code&gt; はスカラーインデックス、スカラーインデックスの配列、またはスカラーインデックスの配列を表すオブジェクトであり、&lt;a href=&quot;../../base/arrays/index#Base.to_indices&quot;&gt; &lt;code&gt;to_indices&lt;/code&gt; &lt;/a&gt;によってそれに変換できます。</target>
        </trans-unit>
        <trans-unit id="fa27a03548fec1bfca9a5a7f95888f72d9a7ae58" translate="yes" xml:space="preserve">
          <source>In the expression &lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt;, the subexpression &lt;code&gt;b&lt;/code&gt; is only evaluated if &lt;code&gt;a&lt;/code&gt; evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">式では &lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt; 、部分式 &lt;code&gt;b&lt;/code&gt; 場合にのみ評価され評価さに &lt;code&gt;true&lt;/code&gt; 。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bac07dea1e6da71dd93fed592d9cea2988762e4a" translate="yes" xml:space="preserve">
          <source>In the expression &lt;code&gt;a || b&lt;/code&gt;, the subexpression &lt;code&gt;b&lt;/code&gt; is only evaluated if &lt;code&gt;a&lt;/code&gt; evaluates to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">式 &lt;code&gt;a || b&lt;/code&gt; 、部分式 &lt;code&gt;b&lt;/code&gt; 場合にのみ評価され評価さに &lt;code&gt;false&lt;/code&gt; 。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="96db94e2ee75dc648cf0225c95d894886287a60b" translate="yes" xml:space="preserve">
          <source>In the first example, the return breaks out of &lt;code&gt;test1&lt;/code&gt; as soon as it hits an even number, so &lt;code&gt;test1([5,6,7])&lt;/code&gt; returns &lt;code&gt;12&lt;/code&gt;.</source>
          <target state="translated">最初の例では、戻り値が偶数に &lt;code&gt;test1([5,6,7])&lt;/code&gt; とすぐに &lt;code&gt;test1&lt;/code&gt; から抜け出すため、test1（[5,6,7]）は &lt;code&gt;12&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="3b8c088e43cc4d9778c3e9bd051248b7beb86cd4" translate="yes" xml:space="preserve">
          <source>In the first step, a handle to the Julia function &lt;code&gt;sqrt&lt;/code&gt; is retrieved by calling &lt;code&gt;jl_get_function&lt;/code&gt;. The first argument passed to &lt;code&gt;jl_get_function&lt;/code&gt; is a pointer to the &lt;code&gt;Base&lt;/code&gt; module in which &lt;code&gt;sqrt&lt;/code&gt; is defined. Then, the double value is boxed using &lt;code&gt;jl_box_float64&lt;/code&gt;. Finally, in the last step, the function is called using &lt;code&gt;jl_call1&lt;/code&gt;. &lt;code&gt;jl_call0&lt;/code&gt;, &lt;code&gt;jl_call2&lt;/code&gt;, and &lt;code&gt;jl_call3&lt;/code&gt; functions also exist, to conveniently handle different numbers of arguments. To pass more arguments, use &lt;code&gt;jl_call&lt;/code&gt;:</source>
          <target state="translated">最初のステップでは、 &lt;code&gt;jl_get_function&lt;/code&gt; を呼び出して、Julia関数 &lt;code&gt;sqrt&lt;/code&gt; のハンドルを取得します。 &lt;code&gt;jl_get_function&lt;/code&gt; に渡される最初の引数は、 &lt;code&gt;sqrt&lt;/code&gt; が定義されている &lt;code&gt;Base&lt;/code&gt; モジュールへのポインターです。次に、double値が &lt;code&gt;jl_box_float64&lt;/code&gt; を使用してボックス化されます。最後に、最後のステップで、関数は &lt;code&gt;jl_call1&lt;/code&gt; を使用して呼び出されます。 &lt;code&gt;jl_call0&lt;/code&gt; 、 &lt;code&gt;jl_call2&lt;/code&gt; 、および &lt;code&gt;jl_call3&lt;/code&gt; 関数も存在し、さまざまな数の引数を簡単に処理できます。さらに引数を渡すには、 &lt;code&gt;jl_call&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="7b958da57c917010bf3ef94ad88b96d1969aed7b" translate="yes" xml:space="preserve">
          <source>In the following REPL session:</source>
          <target state="translated">次のREPLセッションでは</target>
        </trans-unit>
        <trans-unit id="c8932c25606bd0610c3cdf0d60756b479ad881b6" translate="yes" xml:space="preserve">
          <source>In the following example we will use both &lt;code&gt;DistributedArrays.jl&lt;/code&gt; and &lt;code&gt;CuArrays.jl&lt;/code&gt; to distribute an array across multiple processes and call a generic function on it.</source>
          <target state="translated">次の例では、 &lt;code&gt;DistributedArrays.jl&lt;/code&gt; と &lt;code&gt;CuArrays.jl&lt;/code&gt; の両方を使用して、配列を複数のプロセスに分散し、その上でジェネリック関数を呼び出します。</target>
        </trans-unit>
        <trans-unit id="7ef78cc2f03187abe5d3245512be5e3c871b1647" translate="yes" xml:space="preserve">
          <source>In the following example we will use both &lt;code&gt;DistributedArrays.jl&lt;/code&gt; and &lt;code&gt;CuArrays.jl&lt;/code&gt; to distribute an array across multiple processes by first casting it through &lt;code&gt;distribute()&lt;/code&gt; and &lt;code&gt;CuArray()&lt;/code&gt;.</source>
          <target state="translated">次の例では、 &lt;code&gt;DistributedArrays.jl&lt;/code&gt; と &lt;code&gt;CuArrays.jl&lt;/code&gt; の両方を使用して、最初に &lt;code&gt;distribute()&lt;/code&gt; および &lt;code&gt;CuArray()&lt;/code&gt; でキャストすることにより、複数のプロセスに配列を分散します。</target>
        </trans-unit>
        <trans-unit id="eddb2dbc7e71b5027d64a28a0762a40add354815" translate="yes" xml:space="preserve">
          <source>In the following examples &lt;code&gt;&quot;...&quot;&lt;/code&gt; is used to illustrate an arbitrary docstring.</source>
          <target state="translated">次の例では、 &lt;code&gt;&quot;...&quot;&lt;/code&gt; を使用して任意のdocstringを示しています。</target>
        </trans-unit>
        <trans-unit id="89782f85382fa4913d7651a1e194d5e19db89926" translate="yes" xml:space="preserve">
          <source>In the following sections, we briefly go through a few techniques that can help make your Julia code run as fast as possible.</source>
          <target state="translated">以下のセクションでは、Juliaのコードをできるだけ高速に動作させるためのいくつかのテクニックを簡単に説明します。</target>
        </trans-unit>
        <trans-unit id="04625a717e704769cefecb369eb2164fdede25ee" translate="yes" xml:space="preserve">
          <source>In the former case, the integers are widened to system word size and therefore the result is 128. In the latter case, no such widening happens and integer overflow results in -128.</source>
          <target state="translated">前者の場合、整数はシステムのワードサイズに拡張されているため、結果は 128 となります。後者の場合は、そのような拡張は行われず、整数のオーバーフローの結果は-128となります。</target>
        </trans-unit>
        <trans-unit id="96b938fab6579b9bca905e7cf7ff960b0076051e" translate="yes" xml:space="preserve">
          <source>In the former case, the integers are widened to system word size and therefore the result is &lt;code&gt;Int64[100, 128]&lt;/code&gt;. In the latter case, no such widening happens and integer overflow results in &lt;code&gt;Int8[100, -128]&lt;/code&gt;.</source>
          <target state="translated">前者の場合、整数はシステムワードサイズに拡張されるため、結果は &lt;code&gt;Int64[100, 128]&lt;/code&gt; ます。後者の場合、そのような拡大は発生せず、整数オーバーフローは &lt;code&gt;Int8[100, -128]&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="459cd312cf19872b6f89a3fcbc8f7c42d8e4d02e" translate="yes" xml:space="preserve">
          <source>In the last example, a &lt;code&gt;Vector{Any}&lt;/code&gt; is produced; the reason is that &lt;code&gt;eltype(Die) == Any&lt;/code&gt;. The remedy is to define &lt;code&gt;Base.eltype(::Type{Die}) = Int&lt;/code&gt;.</source>
          <target state="translated">最後の例では、 &lt;code&gt;Vector{Any}&lt;/code&gt; が生成されます。その理由は、 &lt;code&gt;eltype(Die) == Any&lt;/code&gt; あるためです。解決策は、 &lt;code&gt;Base.eltype(::Type{Die}) = Int&lt;/code&gt; を定義することです。</target>
        </trans-unit>
        <trans-unit id="1cbf68db8681a41c42664645e9482a6f5917d216" translate="yes" xml:space="preserve">
          <source>In the latter case, the result type is &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; since &lt;code&gt;BigInt&lt;/code&gt; is the only type large enough to hold integers for arbitrary-precision integer arithmetic. Also note that one does not need to define both &lt;code&gt;promote_rule(::Type{A}, ::Type{B})&lt;/code&gt; and &lt;code&gt;promote_rule(::Type{B}, ::Type{A})&lt;/code&gt; &amp;ndash; the symmetry is implied by the way &lt;code&gt;promote_rule&lt;/code&gt; is used in the promotion process.</source>
          <target state="translated">後者の場合、結果の型は&lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; に&lt;/a&gt;なります &lt;code&gt;BigInt&lt;/code&gt; は、任意精度の整数演算用の整数を保持するのに十分な大きさを持つ唯一の型だからです。また、 &lt;code&gt;promote_rule(::Type{A}, ::Type{B})&lt;/code&gt; と &lt;code&gt;promote_rule(::Type{B}, ::Type{A})&lt;/code&gt; 両方を定義する必要がないことに注意してください。対称性は、道の &lt;code&gt;promote_rule&lt;/code&gt; は、昇格プロセスで使用されています。</target>
        </trans-unit>
        <trans-unit id="53f7c1a582426e8808f0c1bf813e62ee2f97e7c7" translate="yes" xml:space="preserve">
          <source>In the meantime, overflow-safe integer operations can be achieved through the use of external libraries such as &lt;a href=&quot;https://github.com/JeffreySarnoff/SaferIntegers.jl&quot;&gt;SaferIntegers.jl&lt;/a&gt;. Note that, as stated previously, the use of these libraries significantly increases the execution time of code using the checked integer types. However, for limited usage, this is far less of an issue than if it were used for all integer operations. You can follow the status of the discussion &lt;a href=&quot;https://github.com/JuliaLang/julia/issues/855&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">それまでの間、&lt;a href=&quot;https://github.com/JeffreySarnoff/SaferIntegers.jl&quot;&gt;SaferIntegers.jl&lt;/a&gt;などの外部ライブラリを使用することで、オーバーフローセーフな整数演算を実現できます。前述のように、これらのライブラリを使用すると、チェックされた整数型を使用するコードの実行時間が大幅に増加することに注意してください。ただし、使用が制限されている場合、これはすべての整数演算に使用された場合よりもはるかに問題が少なくなります。&lt;a href=&quot;https://github.com/JuliaLang/julia/issues/855&quot;&gt;ここで&lt;/a&gt;ディスカッションのステータスを確認できます。</target>
        </trans-unit>
        <trans-unit id="898e17acc6c8cf82e0dc07003deafaedea5b3686" translate="yes" xml:space="preserve">
          <source>In these and other cases, you can get the result you want by choosing an &lt;em&gt;input type&lt;/em&gt; that conveys your willingness to accept an &lt;em&gt;output type&lt;/em&gt; in which the result can be represented:</source>
          <target state="translated">これらのケースやその他のケースでは、結果を表すことができる&lt;em&gt;出力タイプ&lt;/em&gt;を受け入れる意欲を伝える&lt;em&gt;入力タイプ&lt;/em&gt;を選択することで、必要な結果を得ることができます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0181a5895aa6ed6a57ecf3e1abb5400987bdae76" translate="yes" xml:space="preserve">
          <source>In these examples, &lt;code&gt;a&lt;/code&gt; is a &lt;a href=&quot;../numbers/index#Base.Rational&quot;&gt;&lt;code&gt;Rational&lt;/code&gt;&lt;/a&gt;, which has two fields. &lt;code&gt;b&lt;/code&gt; is an &lt;code&gt;Int&lt;/code&gt;, which is a primitive bitstype with no fields at all. &lt;code&gt;ex&lt;/code&gt; is an &lt;a href=&quot;#Core.ErrorException&quot;&gt;&lt;code&gt;ErrorException&lt;/code&gt;&lt;/a&gt;, which has one field.</source>
          <target state="translated">これらの例では、 &lt;code&gt;a&lt;/code&gt; は2つのフィールドを持つ&lt;a href=&quot;../numbers/index#Base.Rational&quot;&gt; &lt;code&gt;Rational&lt;/code&gt; &lt;/a&gt;です。 &lt;code&gt;b&lt;/code&gt; は &lt;code&gt;Int&lt;/code&gt; であり、フィールドのないプリミティブビットタイプです。 &lt;code&gt;ex&lt;/code&gt; は1つのフィールドを持つ&lt;a href=&quot;#Core.ErrorException&quot;&gt; &lt;code&gt;ErrorException&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="e95b83474ed0f82b1495ebdd8823b0e63d6666c2" translate="yes" xml:space="preserve">
          <source>In this and all following examples it is assumed that their top-level is a global scope with a clean workspace, for instance a newly started REPL.</source>
          <target state="translated">この例とそれに続くすべての例では、それらのトップレベルがクリーンなワークスペースを持つグローバル・スコープ、例えば新しく起動された REPL であると仮定しています。</target>
        </trans-unit>
        <trans-unit id="ffae775fe01ba274356f2a5f0bbbfa16bf832464" translate="yes" xml:space="preserve">
          <source>In this case &lt;a href=&quot;../../base/collections/index#Base.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt; MUST be defined in the remote process. Note that &lt;code&gt;A&lt;/code&gt; is a global variable defined in the local workspace. Worker 2 does not have a variable called &lt;code&gt;A&lt;/code&gt; under &lt;code&gt;Main&lt;/code&gt;. The act of shipping the closure &lt;code&gt;()-&amp;gt;sum(A)&lt;/code&gt; to worker 2 results in &lt;code&gt;Main.A&lt;/code&gt; being defined on 2. &lt;code&gt;Main.A&lt;/code&gt; continues to exist on worker 2 even after the call &lt;code&gt;remotecall_fetch&lt;/code&gt; returns. Remote calls with embedded global references (under &lt;code&gt;Main&lt;/code&gt; module only) manage globals as follows:</source>
          <target state="translated">この場合、リモートプロセスで&lt;a href=&quot;../../base/collections/index#Base.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; を&lt;/a&gt;定義する必要があります。 &lt;code&gt;A&lt;/code&gt; はローカルワークスペースで定義されたグローバル変数であることに注意してください。ワーカー2には、 &lt;code&gt;Main&lt;/code&gt; &lt;code&gt;A&lt;/code&gt; 下にAという変数がありません。クロージャを出荷する行為は、 &lt;code&gt;()-&amp;gt;sum(A)&lt;/code&gt; で作業者に2つの結果 &lt;code&gt;Main.A&lt;/code&gt; は 2に定義され &lt;code&gt;Main.A&lt;/code&gt; にも通話後ワーカー2上に存在し続けて &lt;code&gt;remotecall_fetch&lt;/code&gt; に戻ります。グローバルリファレンスが埋め込まれたリモートコール（ &lt;code&gt;Main&lt;/code&gt; モジュールのみ）は、次のようにグローバルを管理します。</target>
        </trans-unit>
        <trans-unit id="0560676ee24f0b0b03f58f97d95e6f878eed22df" translate="yes" xml:space="preserve">
          <source>In this case &lt;code&gt;Vector{Any}(undef, n)&lt;/code&gt; is better. It is also more helpful to the compiler to annotate specific uses (e.g. &lt;code&gt;a[i]::Int&lt;/code&gt;) than to try to pack many alternatives into one type.</source>
          <target state="translated">この場合、 &lt;code&gt;Vector{Any}(undef, n)&lt;/code&gt; 方が適しています。また、多くの選択肢を1つの型に &lt;code&gt;a[i]::Int&lt;/code&gt; うとするよりも、コンパイラーが特定の用途（例：a [i] :: Int）に注釈を付ける方が便利です。</target>
        </trans-unit>
        <trans-unit id="e89af6907bd5ca30fed3e340c7ce252f260cfa01" translate="yes" xml:space="preserve">
          <source>In this case a tuple of values is spliced into a varargs call precisely where the variable number of arguments go. This need not be the case, however:</source>
          <target state="translated">この場合、値のタプルは可変数の引数がどこに行くのかを正確にvarargs呼び出しに接続されています。しかし、これはそうである必要はありません。</target>
        </trans-unit>
        <trans-unit id="567cd07e5f348036853e90930a72f1f415e7cf4a" translate="yes" xml:space="preserve">
          <source>In this case the final (empty) line before the closing &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; sets the indentation level.</source>
          <target state="translated">この場合、 &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; 閉じる前の最後の（空の）行がインデントレベルを設定します。</target>
        </trans-unit>
        <trans-unit id="192b075c1bd1fea405ec3cb3c290131367b6aebf" translate="yes" xml:space="preserve">
          <source>In this case, if we try to split up the work using a one-dimensional index, we are likely to run into trouble: if &lt;code&gt;q[i,j,t]&lt;/code&gt; is near the end of the block assigned to one worker and &lt;code&gt;q[i,j,t+1]&lt;/code&gt; is near the beginning of the block assigned to another, it's very likely that &lt;code&gt;q[i,j,t]&lt;/code&gt; will not be ready at the time it's needed for computing &lt;code&gt;q[i,j,t+1]&lt;/code&gt;. In such cases, one is better off chunking the array manually. Let's split along the second dimension. Define a function that returns the &lt;code&gt;(irange, jrange)&lt;/code&gt; indices assigned to this worker:</source>
          <target state="translated">この場合、1次元のインデックスを使用して作業を分割しようとすると、問題が発生する可能性があります &lt;code&gt;q[i,j,t]&lt;/code&gt; が1つのワーカーに割り当てられたブロックの終わり近くにあり、 &lt;code&gt;q[i,j,t+1]&lt;/code&gt; は、別のブロックに割り当てられたブロックの先頭近くにあります &lt;code&gt;q[i,j,t]&lt;/code&gt; は &lt;code&gt;q[i,j,t+1]&lt;/code&gt; 計算に必要なときに準備ができていない可能性が高いです。1]。このような場合は、手動でアレイをチャンクする方が適切です。 2番目の次元に沿って分割しましょう。このワーカーに割り当てられた &lt;code&gt;(irange, jrange)&lt;/code&gt; インデックスを返す関数を定義します。</target>
        </trans-unit>
        <trans-unit id="b26744f8a00507231770f287451074d8e90f3846" translate="yes" xml:space="preserve">
          <source>In this case, the character &lt;code&gt;&amp;forall;&lt;/code&gt; is a three-byte character, so the indices 2 and 3 are invalid and the next character's index is 4; this next valid index can be computed by &lt;a href=&quot;../../base/strings/index#Base.nextind&quot;&gt;&lt;code&gt;nextind(s,1)&lt;/code&gt;&lt;/a&gt;, and the next index after that by &lt;code&gt;nextind(s,4)&lt;/code&gt; and so on.</source>
          <target state="translated">この場合、文字 &lt;code&gt;&amp;forall;&lt;/code&gt; は3バイト文字であるため、インデックス2および3は無効であり、次の文字のインデックスは4です。この次の有効なインデックスは&lt;a href=&quot;../../base/strings/index#Base.nextind&quot;&gt; &lt;code&gt;nextind(s,1)&lt;/code&gt; &lt;/a&gt;で計算でき、その後の次のインデックスは &lt;code&gt;nextind(s,4)&lt;/code&gt; で計算できます。</target>
        </trans-unit>
        <trans-unit id="e5db3b629f524d1fec7f4ffc91f2ae6bde25d1db" translate="yes" xml:space="preserve">
          <source>In this case, the speedup due to &lt;code&gt;@fastmath&lt;/code&gt; is a factor of about 3.7. This is unusually large &amp;ndash; in general, the speedup will be smaller. (In this particular example, the working set of the benchmark is small enough to fit into the L1 cache of the processor, so that memory access latency does not play a role, and computing time is dominated by CPU usage. In many real world programs this is not the case.) Also, in this case this optimization does not change the result &amp;ndash; in general, the result will be slightly different. In some cases, especially for numerically unstable algorithms, the result can be very different.</source>
          <target state="translated">この場合、 &lt;code&gt;@fastmath&lt;/code&gt; によるスピードアップは約3.7倍です。これは異常に大きい&amp;ndash;一般に、スピードアップは小さくなります。 （この特定の例では、ベンチマークのワーキングセットはプロセッサのL1キャッシュに収まるほど小さいので、メモリアクセスのレイテンシは役割を果たさず、計算時間はCPU使用率によって支配されます。多くの実際のプログラムではこれは当てはまりません。）また、この場合、この最適化によって結果が変わることはありません。通常、結果は少し異なります。場合によっては、特に数値的に不安定なアルゴリズムの場合、結果が大きく異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="6188940203c290544c44a0f6a7e7493e9e0ab89b" translate="yes" xml:space="preserve">
          <source>In this context, MPI refers to the MPI-1 standard. Beginning with MPI-2, the MPI standards committee introduced a new set of communication mechanisms, collectively referred to as Remote Memory Access (RMA). The motivation for adding rma to the MPI standard was to facilitate one-sided communication patterns. For additional information on the latest MPI standard, see &lt;a href=&quot;https://mpi-forum.org/docs&quot;&gt;https://mpi-forum.org/docs&lt;/a&gt;.</source>
          <target state="translated">この文脈では、MPIはMPI-1標準を指します。 MPI-2から、MPI標準委員会は、リモートメモリアクセス（RMA）と総称される一連の新しい通信メカニズムを導入しました。 rmaをMPI標準に追加する動機は、片側通信パターンを容易にすることでした。最新のMPI標準の詳細については、&lt;a href=&quot;https://mpi-forum.org/docs&quot;&gt;https：//mpi-forum.org/docsを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="92a7a3f559dc2f0e3123bf1d2da5d1162f830e7c" translate="yes" xml:space="preserve">
          <source>In this example it is accomplished by defining &lt;code&gt;Base.similar{T}(A::SparseArray, ::Type{T}, dims::Dims)&lt;/code&gt; to create the appropriate wrapped array. (Note that while &lt;code&gt;similar&lt;/code&gt; supports 1- and 2-argument forms, in most case you only need to specialize the 3-argument form.) For this to work it's important that &lt;code&gt;SparseArray&lt;/code&gt; is mutable (supports &lt;code&gt;setindex!&lt;/code&gt;). Defining &lt;code&gt;similar&lt;/code&gt;, &lt;code&gt;getindex&lt;/code&gt; and &lt;code&gt;setindex!&lt;/code&gt; for &lt;code&gt;SparseArray&lt;/code&gt; also makes it possible to &lt;a href=&quot;../../base/base/index#Base.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; the array:</source>
          <target state="translated">この例では、適切なラップされた配列を作成するために &lt;code&gt;Base.similar{T}(A::SparseArray, ::Type{T}, dims::Dims)&lt;/code&gt; を定義することで実現されます。 （ &lt;code&gt;similar&lt;/code&gt; したものは1引数フォームと2引数フォームをサポートしますが、ほとんどの場合、3引数フォームを特殊化するだけでよいことに注意してください。）これを機能させるには、 &lt;code&gt;SparseArray&lt;/code&gt; が変更可能であることが重要です（ &lt;code&gt;setindex!&lt;/code&gt; をサポートしています）。 &lt;code&gt;similar&lt;/code&gt; 、 &lt;code&gt;getindex&lt;/code&gt; およびsetindexの定義 &lt;code&gt;setindex!&lt;/code&gt; 以下のため &lt;code&gt;SparseArray&lt;/code&gt; もすることが可能となり&lt;a href=&quot;../../base/base/index#Base.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt;の配列を：</target>
        </trans-unit>
        <trans-unit id="05a24eb92f7d5686dff145712d9c9981f290a66e" translate="yes" xml:space="preserve">
          <source>In this example the root cause exception (A) is first on the stack, with a further exception (B) following it. After exiting both catch blocks normally (i.e., without throwing a further exception) all exceptions are removed from the stack and are no longer accessible.</source>
          <target state="translated">この例では、根本原因の例外 (A)が最初にスタック上に置かれ、それに続いてさらに例外 (B)が置かれます。両方のキャッチブロックを正常に終了した後 (つまり、さらなる例外を投げずに)、すべての例外はスタックから削除され、アクセスできなくなります。</target>
        </trans-unit>
        <trans-unit id="4336cae1e8edd1087fd9411fb166bd6a222c2c06" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;A&lt;/code&gt; is a mutable container that contains one element, which can be set by &lt;code&gt;A[] = 1.0&lt;/code&gt; and retrieved with &lt;code&gt;A[]&lt;/code&gt;. All zero-dimensional arrays have the same size (&lt;code&gt;size(A) == ()&lt;/code&gt;), and length (&lt;code&gt;length(A) == 1&lt;/code&gt;). In particular, zero-dimensional arrays are not empty. If you find this unintuitive, here are some ideas that might help to understand Julia's definition.</source>
          <target state="translated">この例では、 &lt;code&gt;A&lt;/code&gt; は、で設定することができる一つの要素、含有変更可能な容器である &lt;code&gt;A[] = 1.0&lt;/code&gt; として検索された &lt;code&gt;A[]&lt;/code&gt; 。すべてのゼロ次元配列は同じサイズ（ &lt;code&gt;size(A) == ()&lt;/code&gt; ）、および長さ（ &lt;code&gt;length(A) == 1&lt;/code&gt; ）を持っています。特に、ゼロ次元配列は空ではありません。これが直感に反する場合は、ジュリアの定義を理解するのに役立ついくつかのアイデアを次に示します。</target>
        </trans-unit>
        <trans-unit id="6a0bf2dc540c812cb1923adeb5876321d55dbf26" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;N&lt;/code&gt; is passed as a parameter, so its &quot;value&quot; is known to the compiler. Essentially, &lt;code&gt;Val(T)&lt;/code&gt; works only when &lt;code&gt;T&lt;/code&gt; is either hard-coded/literal (&lt;code&gt;Val(3)&lt;/code&gt;) or already specified in the type-domain.</source>
          <target state="translated">この例では、 &lt;code&gt;N&lt;/code&gt; がパラメーターとして渡されるため、その「値」はコンパイラーに認識されます。基本的に、 &lt;code&gt;Val(T)&lt;/code&gt; は、 &lt;code&gt;T&lt;/code&gt; がハードコード/リテラル​​（ &lt;code&gt;Val(3)&lt;/code&gt; ）であるか、type-domainですでに指定されている場合にのみ機能します。</target>
        </trans-unit>
        <trans-unit id="92f4b81b4c3f20308317f94d5766f434fb02e58c" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;b&lt;/code&gt; is a runnable &lt;code&gt;Task&lt;/code&gt; that hasn't started yet.</source>
          <target state="translated">この例では、 &lt;code&gt;b&lt;/code&gt; はまだ開始されていない実行可能な &lt;code&gt;Task&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="9f7bc1ef4d38fd2e360681f2040c8ad0f73774eb" translate="yes" xml:space="preserve">
          <source>In this example, observe that the new definition for &lt;code&gt;newfun&lt;/code&gt; has been created, but can't be immediately called. The new global is immediately visible to the &lt;code&gt;tryeval&lt;/code&gt; function, so you could write &lt;code&gt;return newfun&lt;/code&gt; (without parentheses). But neither you, nor any of your callers, nor the functions they call, or etc. can call this new method definition!</source>
          <target state="translated">この例では、 &lt;code&gt;newfun&lt;/code&gt; の新しい定義が作成されていますが、すぐに呼び出すことはできません。新しいグローバルはすぐに &lt;code&gt;tryeval&lt;/code&gt; 関数に表示されるため、 &lt;code&gt;return newfun&lt;/code&gt; （括弧なし）を記述できます。しかし、あなたもあなたの呼び出し元も、彼らが呼び出す関数なども、この新しいメソッド定義を呼び出すことはできません！</target>
        </trans-unit>
        <trans-unit id="f0f0d16b1aed858c0d51da9625d8755a2c35d48e" translate="yes" xml:space="preserve">
          <source>In this example, the remote which is being fetched from &lt;em&gt;does&lt;/em&gt; have a file called &lt;code&gt;our_file&lt;/code&gt; in its index, which is why we must reset.</source>
          <target state="translated">この例では、からフェッチされている遠隔は&lt;em&gt;ない&lt;/em&gt;というファイル持って &lt;code&gt;our_file&lt;/code&gt; 我々はリセットしなければならない理由でそのインデックスには、。</target>
        </trans-unit>
        <trans-unit id="a138591f083f547736d80bd3d40dd03ced901f2b" translate="yes" xml:space="preserve">
          <source>In this example, the task ran on pid 2, called from pid 1.</source>
          <target state="translated">この例では、タスクは pid 2 で実行され、pid 1 から呼び出されました。</target>
        </trans-unit>
        <trans-unit id="f39c0221e85d683a6f4024da4ca9271cf6b8c812" translate="yes" xml:space="preserve">
          <source>In this example, the tuple &lt;code&gt;(1,2,3)&lt;/code&gt; is interpolated as an expression into a conditional test:</source>
          <target state="translated">この例では、タプル &lt;code&gt;(1,2,3)&lt;/code&gt; が式として条件テストに挿入されます。</target>
        </trans-unit>
        <trans-unit id="a8e780cf12ef36b63b08a74c8c07d0b380150440" translate="yes" xml:space="preserve">
          <source>In this example, the value of variable &lt;code&gt;a&lt;/code&gt; is interpolated:</source>
          <target state="translated">この例では、変数 &lt;code&gt;a&lt;/code&gt; の値が補間されます。</target>
        </trans-unit>
        <trans-unit id="d77924d6298476fc4b219142016e1167310fe63c" translate="yes" xml:space="preserve">
          <source>In this example, we can see that the top level function called is in the file &lt;code&gt;event.jl&lt;/code&gt;. This is the function that runs the REPL when you launch Julia. If you examine line 97 of &lt;code&gt;REPL.jl&lt;/code&gt;, you'll see this is where the function &lt;code&gt;eval_user_input()&lt;/code&gt; is called. This is the function that evaluates what you type at the REPL, and since we're working interactively these functions were invoked when we entered &lt;code&gt;@profile myfunc()&lt;/code&gt;. The next line reflects actions taken in the &lt;a href=&quot;../../stdlib/profile/index#Profile.@profile&quot;&gt;&lt;code&gt;@profile&lt;/code&gt;&lt;/a&gt; macro.</source>
          <target state="translated">この例では、呼び出されたトップレベル関数が &lt;code&gt;event.jl&lt;/code&gt; ファイルにあることがわかります。これは、Juliaを起動したときにREPLを実行する関数です。 &lt;code&gt;REPL.jl&lt;/code&gt; の 97行目を調べると、ここで関数 &lt;code&gt;eval_user_input()&lt;/code&gt; が呼び出されています。これは、REPLでの入力内容を評価する関数です。インタラクティブに作業しているため、これらの関数は &lt;code&gt;@profile myfunc()&lt;/code&gt; に入ったときに呼び出されました。次の行は、&lt;a href=&quot;../../stdlib/profile/index#Profile.@profile&quot;&gt; &lt;code&gt;@profile&lt;/code&gt; &lt;/a&gt;マクロで実行されたアクションを反映しています。</target>
        </trans-unit>
        <trans-unit id="4c91076ff3785f6e6c7acf1c7077368cdbb7151f" translate="yes" xml:space="preserve">
          <source>In this manner, Julia acts as its own &lt;a href=&quot;https://en.wikipedia.org/wiki/Preprocessor&quot;&gt;preprocessor&lt;/a&gt;, and allows code generation from inside the language. The above code could be written slightly more tersely using the &lt;code&gt;:&lt;/code&gt; prefix quoting form:</source>
          <target state="translated">このようにして、Juliaは独自の&lt;a href=&quot;https://en.wikipedia.org/wiki/Preprocessor&quot;&gt;プリプロセッサ&lt;/a&gt;として機能し、言語内からコードを生成できます。上記のコードは、 &lt;code&gt;:&lt;/code&gt; 接頭辞の引用形式を使用して少し簡潔に書くことができます：</target>
        </trans-unit>
        <trans-unit id="7bd6fc4b177020a8a663dcee2fb9c4c397754164" translate="yes" xml:space="preserve">
          <source>In this module we export the &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; functions (with the keyword &lt;code&gt;export&lt;/code&gt;), and also have the non-exported function &lt;code&gt;p&lt;/code&gt;. There are several different ways to load the Module and its inner functions into the current workspace:</source>
          <target state="translated">このモジュールでは、 &lt;code&gt;x&lt;/code&gt; および &lt;code&gt;y&lt;/code&gt; 関数をエクスポートし（キーワード &lt;code&gt;export&lt;/code&gt; を使用）、エクスポートされない関数 &lt;code&gt;p&lt;/code&gt; も使用します。モジュールとその内部関数を現在のワークスペースにロードするには、いくつかの方法があります。</target>
        </trans-unit>
        <trans-unit id="dcdbf4c0d317d8b968227eee1bb592e9cd8a0e88" translate="yes" xml:space="preserve">
          <source>In this particular case, the number of elements skipped &lt;em&gt;in memory&lt;/em&gt; matches the number of &lt;em&gt;linear indices&lt;/em&gt; skipped. This is only the case for contiguous arrays like &lt;code&gt;Array&lt;/code&gt; (and other &lt;code&gt;DenseArray&lt;/code&gt; subtypes) and is not true in general. Views with range indices are a good example of &lt;em&gt;non-contiguous&lt;/em&gt; strided arrays; consider &lt;code&gt;V = @view A[1:3:4, 2:2:6, 2:-1:1]&lt;/code&gt;. This view &lt;code&gt;V&lt;/code&gt; refers to the same memory as &lt;code&gt;A&lt;/code&gt; but is skipping and re-arranging some of its elements. The stride of the first dimension of &lt;code&gt;V&lt;/code&gt; is &lt;code&gt;3&lt;/code&gt; because we're only selecting every third row from our original array:</source>
          <target state="translated">この特定のケースでは&lt;em&gt;、メモリ内で&lt;/em&gt;スキップさ&lt;em&gt;れる&lt;/em&gt;要素の数は、スキップさ&lt;em&gt;れる&lt;/em&gt;&lt;em&gt;線形インデックスの&lt;/em&gt;数と一致します。これは、 &lt;code&gt;Array&lt;/code&gt; （および他の &lt;code&gt;DenseArray&lt;/code&gt; サブタイプ）のような連続した配列の場合にのみ当てはまり、一般的には当てはまりません。範囲インデックスのあるビューは、&lt;em&gt;連続していない&lt;/em&gt;ストライド配列の良い例です。 &lt;code&gt;V = @view A[1:3:4, 2:2:6, 2:-1:1]&lt;/code&gt; 検討してください。このビュー &lt;code&gt;V&lt;/code&gt; は、 &lt;code&gt;A&lt;/code&gt; と同じメモリを参照しますが、その要素の一部をスキップして再配置しています。元の配列から3行ごとにのみ選択しているため、 &lt;code&gt;V&lt;/code&gt; の最初の次元のストライドは &lt;code&gt;3&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="81fa363c46c4da719440f0a895d038cea7c0f22d" translate="yes" xml:space="preserve">
          <source>In this situation, use the &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt;&lt;code&gt;skipmissing&lt;/code&gt;&lt;/a&gt; function to skip missing values</source>
          <target state="translated">この状況では、&lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt; &lt;code&gt;skipmissing&lt;/code&gt; &lt;/a&gt;関数を使用して欠損値をスキップします</target>
        </trans-unit>
        <trans-unit id="9db9e9e3387eacd52cbab3963439723e71f36736" translate="yes" xml:space="preserve">
          <source>In this style of definition, the code generation feature is essentially an optional optimization. The compiler will use it if convenient, but otherwise may choose to use the normal implementation instead. This style is preferred, since it allows the compiler to make more decisions and compile programs in more ways, and since normal code is more readable than code-generating code. However, which implementation is used depends on compiler implementation details, so it is essential for the two implementations to behave identically.</source>
          <target state="translated">このスタイルの定義では、コード生成機能は基本的にオプションの最適化です。コンパイラは便利な場合はこれを使用しますが、そうでない場合は通常の実装を使用することを選択することができます。このスタイルが好ましいのは、コンパイラがより多くの判断を下し、より多くの方法でプログラムをコンパイルできるようになることと、通常のコードの方がコード生成コードよりも読みやすいからです。しかし、どちらの実装を使用するかはコンパイラの実装の詳細に依存するので、2つの実装が同じように動作することが不可欠です。</target>
        </trans-unit>
        <trans-unit id="2472bd128ff5a0c2f02732fc91d35900b7540e31" translate="yes" xml:space="preserve">
          <source>In this toy example, the two methods are easy to distinguish and choose from. However, in a real program designing data movement might require more thought and likely some measurement. For example, if the first process needs matrix &lt;code&gt;A&lt;/code&gt; then the first method might be better. Or, if computing &lt;code&gt;A&lt;/code&gt; is expensive and only the current process has it, then moving it to another process might be unavoidable. Or, if the current process has very little to do between the &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt;&lt;code&gt;@spawn&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;fetch(Bref)&lt;/code&gt;, it might be better to eliminate the parallelism altogether. Or imagine &lt;code&gt;rand(1000,1000)&lt;/code&gt; is replaced with a more expensive operation. Then it might make sense to add another &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt;&lt;code&gt;@spawn&lt;/code&gt;&lt;/a&gt; statement just for this step.</source>
          <target state="translated">このおもちゃの例では、2つの方法を簡単に区別して選択できます。ただし、実際のプログラムでは、データの移動を設計するために、より多くの検討が必要で、測定が必要になる可能性があります。たとえば、最初のプロセスが行列 &lt;code&gt;A&lt;/code&gt; を必要とする場合、最初の方法の方が良いかもしれません。あるいは、 &lt;code&gt;A&lt;/code&gt; の計算にコストがかかり、現在のプロセスだけがそれを持っている場合、それを別のプロセスに移動することは避けられないかもしれません。または、現在のプロセスで&lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt; &lt;code&gt;@spawn&lt;/code&gt; &lt;/a&gt;と &lt;code&gt;fetch(Bref)&lt;/code&gt; Bref）の間の処理がほとんどない場合は、並列処理を完全に排除することをお勧めします。または、 &lt;code&gt;rand(1000,1000)&lt;/code&gt; がより高価な演算に置き換えられることを想像してください。次に、このステップのためだけに別の&lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt; &lt;code&gt;@spawn&lt;/code&gt; &lt;/a&gt;ステートメントを追加することは意味があります。</target>
        </trans-unit>
        <trans-unit id="4f15c62fbcd9523fb3f2a21376c6d6f2fb45889e" translate="yes" xml:space="preserve">
          <source>In this toy example, the two methods are easy to distinguish and choose from. However, in a real program designing data movement might require more thought and likely some measurement. For example, if the first process needs matrix &lt;code&gt;A&lt;/code&gt; then the first method might be better. Or, if computing &lt;code&gt;A&lt;/code&gt; is expensive and only the current process has it, then moving it to another process might be unavoidable. Or, if the current process has very little to do between the &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawnat&quot;&gt;&lt;code&gt;@spawnat&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;fetch(Bref)&lt;/code&gt;, it might be better to eliminate the parallelism altogether. Or imagine &lt;code&gt;rand(1000,1000)&lt;/code&gt; is replaced with a more expensive operation. Then it might make sense to add another &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawnat&quot;&gt;&lt;code&gt;@spawnat&lt;/code&gt;&lt;/a&gt; statement just for this step.</source>
          <target state="translated">このおもちゃの例では、2つの方法を簡単に区別して選択できます。ただし、実際のプログラムでは、データの移動を設計するために、より多くの検討が必要になる場合があります。たとえば、最初のプロセスに行列 &lt;code&gt;A&lt;/code&gt; が必要な場合は、最初の方法の方が適している可能性があります。または、 &lt;code&gt;A&lt;/code&gt; の計算にコストがかかり、現在のプロセスだけがそれを持っている場合は、別のプロセスに移動することが避けられない可能性があります。または、現在のプロセスが&lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawnat&quot;&gt; &lt;code&gt;@spawnat&lt;/code&gt; &lt;/a&gt;と &lt;code&gt;fetch(Bref)&lt;/code&gt; Bref）の間でほとんど関係がない場合は、並列処理を完全に排除する方がよい場合があります。または、 &lt;code&gt;rand(1000,1000)&lt;/code&gt; がより高価な操作に置き換えられたと想像してください。次に、別の&lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawnat&quot;&gt; &lt;code&gt;@spawnat&lt;/code&gt; &lt;/a&gt;を追加するのが理にかなっているかもしれません このステップのためだけのステートメント。</target>
        </trans-unit>
        <trans-unit id="cf538f8e56ca0f93d90636a083c95bfe08cc9992" translate="yes" xml:space="preserve">
          <source>In this way a mesh network is established, wherein every worker is directly connected with every other worker.</source>
          <target state="translated">このようにして、すべてのワーカーが他のすべてのワーカーと直接接続されるメッシュネットワークが確立されます。</target>
        </trans-unit>
        <trans-unit id="77e752e41de1e6877a1adbe41bf7b76e4f16d104" translate="yes" xml:space="preserve">
          <source>In-memory representation of a file entry in the index. Matches the &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_index_entry&quot;&gt;&lt;code&gt;git_index_entry&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">インデックス内のファイルエントリのメモリ内表現。&lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_index_entry&quot;&gt; &lt;code&gt;git_index_entry&lt;/code&gt; &lt;/a&gt;構造体と一致します。</target>
        </trans-unit>
        <trans-unit id="06c7aeba98a0f145bac3596871ee20c6209a6fe5" translate="yes" xml:space="preserve">
          <source>In-place broadcasting can be supported by defining the appropriate &lt;code&gt;copyto!(dest, bc::Broadcasted)&lt;/code&gt; method. Because you might want to specialize either on &lt;code&gt;dest&lt;/code&gt; or the specific subtype of &lt;code&gt;bc&lt;/code&gt;, to avoid ambiguities between packages we recommend the following convention.</source>
          <target state="translated">インプレースブロードキャストは、適切な &lt;code&gt;copyto!(dest, bc::Broadcasted)&lt;/code&gt; メソッドを定義することでサポートできます。 &lt;code&gt;dest&lt;/code&gt; または &lt;code&gt;bc&lt;/code&gt; の特定のサブタイプのいずれかに特化したい場合があるため、パッケージ間のあいまいさを回避するために、次の規則をお勧めします。</target>
        </trans-unit>
        <trans-unit id="9b8eaa806ba1cb1b5e2ab868bf0bb847fbaf77f5" translate="yes" xml:space="preserve">
          <source>In-place version of &lt;a href=&quot;#Base.reverse-Tuple%7BAbstractArray%7BT,1%7D%20where%20T%7D&quot;&gt;&lt;code&gt;reverse&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Base.reverse-Tuple%7BAbstractArray%7BT,1%7D%20where%20T%7D&quot;&gt; &lt;code&gt;reverse&lt;/code&gt; &lt;/a&gt;インプレースバージョン。</target>
        </trans-unit>
        <trans-unit id="bc665a97127feb38e6b15a0be58c4193afb4afe7" translate="yes" xml:space="preserve">
          <source>In-place version of &lt;a href=&quot;#Random.shuffle&quot;&gt;&lt;code&gt;shuffle&lt;/code&gt;&lt;/a&gt;: randomly permute &lt;code&gt;v&lt;/code&gt; in-place, optionally supplying the random-number generator &lt;code&gt;rng&lt;/code&gt;.</source>
          <target state="translated">インプレースバージョンの&lt;a href=&quot;#Random.shuffle&quot;&gt; &lt;code&gt;shuffle&lt;/code&gt; &lt;/a&gt;：ランダムに &lt;code&gt;v&lt;/code&gt; インプレースで並べ替え、オプションで乱数ジェネレーター &lt;code&gt;rng&lt;/code&gt; を提供します。</target>
        </trans-unit>
        <trans-unit id="ceae787569f3577706adf60b6b428b09067c76dc" translate="yes" xml:space="preserve">
          <source>In-place version of &lt;code&gt;reverse&lt;/code&gt;.</source>
          <target state="translated">インプレースバージョンの &lt;code&gt;reverse&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d77496985aa0ae694adc6f64d73e36e7d090fe55" translate="yes" xml:space="preserve">
          <source>Inbox Tray</source>
          <target state="translated">受信トレイ</target>
        </trans-unit>
        <trans-unit id="973cab0f46e932b28084ce2f784990fa4e35559b" translate="yes" xml:space="preserve">
          <source>Include a single one-line sentence describing what the function does or what the object represents after the simplified signature block. If needed, provide more details in a second paragraph, after a blank line.</source>
          <target state="translated">簡略化された署名ブロックの後に、関数が何をするのか、またはオブジェクトが何を表すのかを1行で記述してください。必要に応じて、空行の後の2段落目に詳細を記述してください。</target>
        </trans-unit>
        <trans-unit id="7962fdf356cdba272a5b5a5a58199f8e50948161" translate="yes" xml:space="preserve">
          <source>Include any code examples in an &lt;code&gt;# Examples&lt;/code&gt; section.</source>
          <target state="translated">&lt;code&gt;# Examples&lt;/code&gt; サンプルセクションにコード例を含めます。</target>
        </trans-unit>
        <trans-unit id="66cb3917171f2315e55b05172cef1568516a6218" translate="yes" xml:space="preserve">
          <source>Including the same code in different modules provides mixin-like behavior. One could use this to run the same code with different base definitions, for example testing code by running it with &quot;safe&quot; versions of some operators:</source>
          <target state="translated">異なるモジュールに同じコードを含めることで、ミックスインのような動作が可能になります。これを利用して、同じコードを異なるベース定義で実行することができます。例えば、いくつかの演算子の &quot;安全な &quot;バージョンで実行してコードをテストすることができます。</target>
        </trans-unit>
        <trans-unit id="3677c6602caed5b57fccc20b31958c9939eb0f57" translate="yes" xml:space="preserve">
          <source>Incoming Envelope</source>
          <target state="translated">着信用封筒</target>
        </trans-unit>
        <trans-unit id="1cebd71683222b1c7af41849d615c19b10f8b1ef" translate="yes" xml:space="preserve">
          <source>Incomplete Initialization</source>
          <target state="translated">不完全な初期化</target>
        </trans-unit>
        <trans-unit id="700503508878aea14fc71ea0dd89adddb349e058" translate="yes" xml:space="preserve">
          <source>Increases As</source>
          <target state="translated">として増加します。</target>
        </trans-unit>
        <trans-unit id="d12f1fabbb58a9af82666365bdf1d6e784f1a197" translate="yes" xml:space="preserve">
          <source>Increment</source>
          <target state="translated">Increment</target>
        </trans-unit>
        <trans-unit id="81769cec07065990cf97fe9de01e67d1dff5a01a" translate="yes" xml:space="preserve">
          <source>Incremental history search, described above</source>
          <target state="translated">前述のインクリメンタル履歴検索</target>
        </trans-unit>
        <trans-unit id="7777e9a1cc822589b38fa2cf3b16ff5bb4405461" translate="yes" xml:space="preserve">
          <source>IndexCartesian</source>
          <target state="translated">IndexCartesian</target>
        </trans-unit>
        <trans-unit id="0ad6144c812efd669c1e0522b10d3e8d01b0818e" translate="yes" xml:space="preserve">
          <source>IndexLinear</source>
          <target state="translated">IndexLinear</target>
        </trans-unit>
        <trans-unit id="5c7d3a57514b6cbb8c7494df1aa031252a9240c0" translate="yes" xml:space="preserve">
          <source>IndexStyle</source>
          <target state="translated">IndexStyle</target>
        </trans-unit>
        <trans-unit id="8b48578d3b12e1d393eb06b8ea5bee4e6f0ec92a" translate="yes" xml:space="preserve">
          <source>Indexable Collections</source>
          <target state="translated">インデックス可能なコレクション</target>
        </trans-unit>
        <trans-unit id="04f77b5a53e8914ea949c0d3dbe59ff927176c3a" translate="yes" xml:space="preserve">
          <source>Indexed Assignment</source>
          <target state="translated">インデックス化された課題</target>
        </trans-unit>
        <trans-unit id="9951861c21df18489a5872209655d6f9039b5e2a" translate="yes" xml:space="preserve">
          <source>Indexing</source>
          <target state="translated">Indexing</target>
        </trans-unit>
        <trans-unit id="0795ddb093e3d5dd1a985acb78a5e1baf2eef779" translate="yes" xml:space="preserve">
          <source>Indexing and assignment</source>
          <target state="translated">インデックスの作成と割り当て</target>
        </trans-unit>
        <trans-unit id="4274ea6199202594d8373033384d6bdb729f3196" translate="yes" xml:space="preserve">
          <source>Indicate that a sorting function should use the insertion sort algorithm. Insertion sort traverses the collection one element at a time, inserting each element into its correct, sorted position in the output list.</source>
          <target state="translated">ソート関数が挿入ソートアルゴリズムを使用することを示します。挿入ソートは、コレクションを一度に1つの要素ずつ走査し、各要素を出力リストの正しいソートされた位置に挿入します。</target>
        </trans-unit>
        <trans-unit id="1a127225335e9d3a07a6be83a0e208ad31b15ede" translate="yes" xml:space="preserve">
          <source>Indicate that a sorting function should use the merge sort algorithm. Merge sort divides the collection into subcollections and repeatedly merges them, sorting each subcollection at each step, until the entire collection has been recombined in sorted form.</source>
          <target state="translated">ソート関数がマージソートアルゴリズムを使用することを示します。マージソートは、コレクションをサブコレクションに分割し、各ステップで各サブコレクションをソートしながら、コレクション全体がソートされた形で再結合されるまで、それらを繰り返しマージします。</target>
        </trans-unit>
        <trans-unit id="f0d9438aae14ca6f51f78f417b7df01df9f079a5" translate="yes" xml:space="preserve">
          <source>Indicate that a sorting function should use the partial quick sort algorithm. Partial quick sort returns the smallest &lt;code&gt;k&lt;/code&gt; elements sorted from smallest to largest, finding them and sorting them using &lt;a href=&quot;#Base.Sort.QuickSort&quot;&gt;&lt;code&gt;QuickSort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ソート関数が部分クイックソートアルゴリズムを使用することを示します。部分的なクイックソートは、最小から最大にソートされた最小の &lt;code&gt;k&lt;/code&gt; 要素を返し、それらを見つけて&lt;a href=&quot;#Base.Sort.QuickSort&quot;&gt; &lt;code&gt;QuickSort&lt;/code&gt; &lt;/a&gt;を使用してソートします。</target>
        </trans-unit>
        <trans-unit id="d5c75327b4e50aced7a786e9b2e8496c590cde6e" translate="yes" xml:space="preserve">
          <source>Indicate that a sorting function should use the quick sort algorithm, which is &lt;em&gt;not&lt;/em&gt; stable.</source>
          <target state="translated">ソート関数が&lt;em&gt;、&lt;/em&gt;安定して&lt;em&gt;いない&lt;/em&gt;クイックソートアルゴリズムを使用する必要があることを示します。</target>
        </trans-unit>
        <trans-unit id="a54eb733590aa2b40370b6fb359ea865b8d99e9b" translate="yes" xml:space="preserve">
          <source>Indicate whether &lt;code&gt;x&lt;/code&gt; is &lt;a href=&quot;#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; が&lt;a href=&quot;#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt;いるかどうかを示します。</target>
        </trans-unit>
        <trans-unit id="efe98c42fb3d546aaef0cbe63f84a3ed426eef2d" translate="yes" xml:space="preserve">
          <source>Indicates a test that should pass but currently consistently fails. Tests that the expression &lt;code&gt;ex&lt;/code&gt; evaluates to &lt;code&gt;false&lt;/code&gt; or causes an exception. Returns a &lt;code&gt;Broken&lt;/code&gt;&lt;code&gt;Result&lt;/code&gt; if it does, or an &lt;code&gt;Error&lt;/code&gt;&lt;code&gt;Result&lt;/code&gt; if the expression evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">合格する必要があるが、現在は一貫して失敗するテストを示します。式 &lt;code&gt;ex&lt;/code&gt; が &lt;code&gt;false&lt;/code&gt; と評価されるか、例外が発生することをテストします。そうである場合は &lt;code&gt;Broken&lt;/code&gt; &lt;code&gt;Result&lt;/code&gt; 返し、式が &lt;code&gt;true&lt;/code&gt; と評価された場合は &lt;code&gt;Error&lt;/code&gt; &lt;code&gt;Result&lt;/code&gt; 返します。</target>
        </trans-unit>
        <trans-unit id="f58aeaea39a890601871a48e22cb88bfcd1c627a" translate="yes" xml:space="preserve">
          <source>Indicates problematic exit status of a process. When running commands or pipelines, this is thrown to indicate a nonzero exit code was returned (i.e. that the invoked process failed).</source>
          <target state="translated">プロセスの終了状態に問題があることを示します。コマンドやパイプラインを実行している場合、これはゼロではない終了コードが返されたことを示すためにスローされます (つまり、呼び出されたプロセスが失敗したことを示しています)。</target>
        </trans-unit>
        <trans-unit id="ff3a5eaf7321b1b596df1bcd003dbd2f9fcf89b1" translate="yes" xml:space="preserve">
          <source>Indices are of the same type as those returned by &lt;a href=&quot;../collections/index#Base.keys&quot;&gt;&lt;code&gt;keys(A)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../collections/index#Base.pairs&quot;&gt;&lt;code&gt;pairs(A)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">インデックスは、&lt;a href=&quot;../collections/index#Base.keys&quot;&gt; &lt;code&gt;keys(A)&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;../collections/index#Base.pairs&quot;&gt; &lt;code&gt;pairs(A)&lt;/code&gt; &lt;/a&gt;によって返されるものと同じタイプです。</target>
        </trans-unit>
        <trans-unit id="f9e9b57819d8a4759652850ab76b4d97192200f0" translate="yes" xml:space="preserve">
          <source>Indices may be omitted if the trailing dimensions that are not indexed into are all length one. In other words, trailing indices can be omitted only if there is only one possible value that those omitted indices could be for an in-bounds indexing expression. For example, a four-dimensional array with size &lt;code&gt;(3, 4, 2, 1)&lt;/code&gt; may be indexed with only three indices as the dimension that gets skipped (the fourth dimension) has length one. Note that linear indexing takes precedence over this rule.</source>
          <target state="translated">インデックスが付けられていない後続ディメンションがすべて長さ1である場合、インデックスは省略できます。言い換えると、後続のインデックスは、インバウンドインデックス式で省略可能なインデックスが可能な値が1つしかない場合にのみ省略できます。たとえば、サイズが &lt;code&gt;(3, 4, 2, 1)&lt;/code&gt; 3、4、2、1 ）の4次元配列は、スキップされる次元（4番目の次元）の長さが1であるため、3つのインデックスのみでインデックスを作成できます。線形インデックスはこのルールよりも優先されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="a9eddea567bcc33c91213abd188cec156d2bbedc" translate="yes" xml:space="preserve">
          <source>Indices or keys are of the same type as those returned by &lt;a href=&quot;../collections/index#Base.keys&quot;&gt;&lt;code&gt;keys(A)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../collections/index#Base.pairs&quot;&gt;&lt;code&gt;pairs(A)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">インデックスまたはキーは、&lt;a href=&quot;../collections/index#Base.keys&quot;&gt; &lt;code&gt;keys(A)&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;../collections/index#Base.pairs&quot;&gt; &lt;code&gt;pairs(A)&lt;/code&gt; &lt;/a&gt;によって返されるものと同じタイプです。</target>
        </trans-unit>
        <trans-unit id="3e37e52d9d94ec6a75ede0c2186d1f73dd06e01f" translate="yes" xml:space="preserve">
          <source>Indirect Calls</source>
          <target state="translated">間接電話</target>
        </trans-unit>
        <trans-unit id="8b89285e1320e669387b56f7e30bddb1aefce498" translate="yes" xml:space="preserve">
          <source>Individual pointers returned by &lt;a href=&quot;../../base/base/index#Base.backtrace&quot;&gt;&lt;code&gt;backtrace&lt;/code&gt;&lt;/a&gt; can be translated into &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.StackFrame&quot;&gt;&lt;code&gt;StackTraces.StackFrame&lt;/code&gt;&lt;/a&gt; s by passing them into &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.lookup&quot;&gt;&lt;code&gt;StackTraces.lookup&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;../../base/base/index#Base.backtrace&quot;&gt; &lt;code&gt;backtrace&lt;/code&gt; &lt;/a&gt;によって返された個々のポインターは、それらを&lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.lookup&quot;&gt; &lt;code&gt;StackTraces.lookup&lt;/code&gt; に&lt;/a&gt;渡すことによって&lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.StackFrame&quot;&gt; &lt;code&gt;StackTraces.StackFrame&lt;/code&gt; &lt;/a&gt;に変換できます。</target>
        </trans-unit>
        <trans-unit id="f462554871703067824392ec24cc8ae7c200c6ce" translate="yes" xml:space="preserve">
          <source>Inevitably, one wants to write commands that aren't quite so simple, and it becomes necessary to use quotes. Here's a simple example of a Perl one-liner at a shell prompt:</source>
          <target state="translated">必然的に、それほど単純ではないコマンドを書きたくなり、引用符を使う必要が出てきます。ここでは、シェルプロンプトでのPerlのワンライナーの簡単な例を示します。</target>
        </trans-unit>
        <trans-unit id="b24e30d8c474981541dc914b04b492ae2c3460dd" translate="yes" xml:space="preserve">
          <source>Inexact equality comparison: &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;norm(x-y) &amp;lt;= max(atol, rtol*max(norm(x), norm(y)))&lt;/code&gt;. The default &lt;code&gt;atol&lt;/code&gt; is zero and the default &lt;code&gt;rtol&lt;/code&gt; depends on the types of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. The keyword argument &lt;code&gt;nans&lt;/code&gt; determines whether or not NaN values are considered equal (defaults to false).</source>
          <target state="translated">不正確な等値比較： &lt;code&gt;norm(x-y) &amp;lt;= max(atol, rtol*max(norm(x), norm(y)))&lt;/code&gt; 場合は &lt;code&gt;true&lt;/code&gt; 。デフォルトの &lt;code&gt;atol&lt;/code&gt; はゼロで、デフォルトの &lt;code&gt;rtol&lt;/code&gt; は &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; のタイプに依存します。キーワード引数 &lt;code&gt;nans&lt;/code&gt; は、NaN値が等しいと見なされるかどうかを決定します（デフォルトはfalse）。</target>
        </trans-unit>
        <trans-unit id="a1d71ca242908209d7ea479076e7d5102e909486" translate="yes" xml:space="preserve">
          <source>Inf</source>
          <target state="translated">Inf</target>
        </trans-unit>
        <trans-unit id="3b4f77ed6217d60a7fd4f6a9b544f27db8d0b2a2" translate="yes" xml:space="preserve">
          <source>Inf16</source>
          <target state="translated">Inf16</target>
        </trans-unit>
        <trans-unit id="f32fd60229b61d38504c1b80cfc905d76eb231a4" translate="yes" xml:space="preserve">
          <source>Inf32</source>
          <target state="translated">Inf32</target>
        </trans-unit>
        <trans-unit id="13b9b86c9d296608a20ee6add58865dfa6405d7b" translate="yes" xml:space="preserve">
          <source>Inference on the generated function may be run at &lt;em&gt;any&lt;/em&gt; time, including while your code is attempting to observe or mutate this state.</source>
          <target state="translated">生成された関数の推論は、コードがこの状態を観察または変更しようとしている間を含め、&lt;em&gt;いつでも&lt;/em&gt;実行&lt;em&gt;でき&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="0219fd54bd5841008b18c414a5b2dea331bad1c5" translate="yes" xml:space="preserve">
          <source>Infinity</source>
          <target state="translated">Infinity</target>
        </trans-unit>
        <trans-unit id="c7144cf7afebc5115a987ddb86ab81776ccb312f" translate="yes" xml:space="preserve">
          <source>Information Desk Person</source>
          <target state="translated">インフォメーションデスク担当者</target>
        </trans-unit>
        <trans-unit id="ee1bf915e3a7b6dbf22c44b17ef750f99d415033" translate="yes" xml:space="preserve">
          <source>Information Source</source>
          <target state="translated">情報源</target>
        </trans-unit>
        <trans-unit id="1bcf6aaebaf6b2210eb3e22e29d6b1d78dde678a" translate="yes" xml:space="preserve">
          <source>Information about the datatype</source>
          <target state="translated">データ型に関する情報</target>
        </trans-unit>
        <trans-unit id="bc0f7289c05621e36794cb837d6af7d6579a4164" translate="yes" xml:space="preserve">
          <source>Information about the sizes of the array</source>
          <target state="translated">配列のサイズに関する情報</target>
        </trans-unit>
        <trans-unit id="2e1d962528e312390b3433d954b1b586fbe1d39c" translate="yes" xml:space="preserve">
          <source>Initialize &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;x = 1.0&lt;/code&gt;</source>
          <target state="translated">初期化は、 &lt;code&gt;x&lt;/code&gt; はと &lt;code&gt;x = 1.0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5d24f12b12b26a182fb25787fca39632feae214b" translate="yes" xml:space="preserve">
          <source>Initialize with the first loop iteration, to &lt;code&gt;x = 1 / rand()&lt;/code&gt;, then loop &lt;code&gt;for i = 2:10&lt;/code&gt;</source>
          <target state="translated">最初のループ反復で初期化し、 &lt;code&gt;x = 1 / rand()&lt;/code&gt; にしてから &lt;code&gt;for i = 2:10&lt;/code&gt; ループする</target>
        </trans-unit>
        <trans-unit id="e1daf596559638b5a2545966e4511677e06d2d3d" translate="yes" xml:space="preserve">
          <source>Initially &lt;code&gt;f(x)&lt;/code&gt; has one definition</source>
          <target state="translated">最初は &lt;code&gt;f(x)&lt;/code&gt; には1つの定義があります</target>
        </trans-unit>
        <trans-unit id="65a228b7147b9d8893c482dc6a5436ee38235915" translate="yes" xml:space="preserve">
          <source>Inline elements</source>
          <target state="translated">インライン要素</target>
        </trans-unit>
        <trans-unit id="45667ade36979348043d403d58a921b295a413f5" translate="yes" xml:space="preserve">
          <source>Inner Constructor Methods</source>
          <target state="translated">インナーコンストラクタメソッド</target>
        </trans-unit>
        <trans-unit id="5b1b953a0d0fba8d5b16a917eed0d32fa9a3dd01" translate="yes" xml:space="preserve">
          <source>Inner local scopes can, however, update variables in their parent scopes:</source>
          <target state="translated">しかし、内部のローカルスコープでは、親スコープの変数を更新することができます。</target>
        </trans-unit>
        <trans-unit id="8da1f19e44e7c32bb595b50d82bbd6ceb59679ad" translate="yes" xml:space="preserve">
          <source>Input Symbol For Latin Capital Letters</source>
          <target state="translated">ラテン大文字の入力記号</target>
        </trans-unit>
        <trans-unit id="c3dacb4d5649dfd7003c41b511f2d5e28217bcec" translate="yes" xml:space="preserve">
          <source>Input Symbol For Latin Letters</source>
          <target state="translated">ラテン文字の入力記号</target>
        </trans-unit>
        <trans-unit id="c56fdb4bd109b10836666b2146d13e58e8c262da" translate="yes" xml:space="preserve">
          <source>Input Symbol For Latin Small Letters</source>
          <target state="translated">ラテン小文字の入力記号</target>
        </trans-unit>
        <trans-unit id="daa856648c7327c1e747ce6132f831c138ebed2c" translate="yes" xml:space="preserve">
          <source>Input Symbol For Numbers</source>
          <target state="translated">数字の入力記号</target>
        </trans-unit>
        <trans-unit id="393164c17095f31b175cd1b93cce56c3dedbfb1e" translate="yes" xml:space="preserve">
          <source>Input Symbol For Symbols</source>
          <target state="translated">シンボルの入力シンボル</target>
        </trans-unit>
        <trans-unit id="6ac623d9f5d1fbc2e0f23f9accfd989544cd258f" translate="yes" xml:space="preserve">
          <source>Insert a sequential-consistency memory fence</source>
          <target state="translated">シーケンシャル一貫性のあるメモリフェンスを挿入する</target>
        </trans-unit>
        <trans-unit id="811acf3875523c22a2281d416b5b4f8370319cc7" translate="yes" xml:space="preserve">
          <source>Insert an &lt;code&gt;item&lt;/code&gt; into &lt;code&gt;a&lt;/code&gt; at the given &lt;code&gt;index&lt;/code&gt;. &lt;code&gt;index&lt;/code&gt; is the index of &lt;code&gt;item&lt;/code&gt; in the resulting &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">挿入し &lt;code&gt;item&lt;/code&gt; に与えられた時 &lt;code&gt;index&lt;/code&gt; 。 &lt;code&gt;index&lt;/code&gt; は、結果の &lt;code&gt;a&lt;/code&gt; 内の &lt;code&gt;item&lt;/code&gt; のインデックスです。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="559e8d8937fda6b9aa5389a26a8c99a01c1659f4" translate="yes" xml:space="preserve">
          <source>Insert new line without executing it</source>
          <target state="translated">実行せずに改行を挿入</target>
        </trans-unit>
        <trans-unit id="db69c06d74ad468e37833a8eff3cd0b19f6c2cae" translate="yes" xml:space="preserve">
          <source>Insert one or more &lt;code&gt;items&lt;/code&gt; at the beginning of &lt;code&gt;collection&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;collection&lt;/code&gt; の先頭に1つ以上の &lt;code&gt;items&lt;/code&gt; を挿入します。</target>
        </trans-unit>
        <trans-unit id="e38ad6a771799a9a8891ef79be267ec402e8ceac" translate="yes" xml:space="preserve">
          <source>Insert one or more &lt;code&gt;items&lt;/code&gt; at the end of &lt;code&gt;collection&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;collection&lt;/code&gt; の最後に1つ以上の &lt;code&gt;items&lt;/code&gt; を挿入します。</target>
        </trans-unit>
        <trans-unit id="6f3f950f8d7377ccffdca0b939ba6ac7684b1f51" translate="yes" xml:space="preserve">
          <source>Insert one or more &lt;code&gt;items&lt;/code&gt; in &lt;code&gt;collection&lt;/code&gt;. If &lt;code&gt;collection&lt;/code&gt; is an ordered container, the items are inserted at the end (in the given order).</source>
          <target state="translated">&lt;code&gt;collection&lt;/code&gt; 1つ以上の &lt;code&gt;items&lt;/code&gt; 挿入します。場合 &lt;code&gt;collection&lt;/code&gt; 順序付け容器である、項目が（所定の順序で）最後に挿入されています。</target>
        </trans-unit>
        <trans-unit id="af1912a8c6dfd808836326783d91aa44bc473362" translate="yes" xml:space="preserve">
          <source>Insert the elements of &lt;code&gt;items&lt;/code&gt; to the beginning of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">要素を挿入 &lt;code&gt;items&lt;/code&gt; の先頭に。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eec80463f132fabaec00763dec1737d74a5ca8f8" translate="yes" xml:space="preserve">
          <source>Inserts a memory fence with sequentially-consistent ordering semantics. There are algorithms where this is needed, i.e. where an acquire/release ordering is insufficient.</source>
          <target state="translated">逐次的に整合性のある順序のセマンティクスを持つメモリフェンスを挿入する。これが必要とされるアルゴリズムがあります。</target>
        </trans-unit>
        <trans-unit id="8a79f039f9c26eb844e9abd4767d0e8224e23795" translate="yes" xml:space="preserve">
          <source>Inserts a point in the program where garbage collection may run. This can be useful in rare cases in multi-threaded programs where some threads are allocating memory (and hence may need to run GC) but other threads are doing only simple operations (no allocation, task switches, or I/O). Calling this function periodically in non-allocating threads allows garbage collection to run.</source>
          <target state="translated">ガベージコレクションが実行される可能性のあるプログラムのポイントを挿入します。これは、一部のスレッドがメモリを割り当てている(したがって GC を実行する必要があるかもしれない)が、他のスレッドは単純な操作(割り当て、タスクスイッチ、または I/O を行わない)のみを行っているマルチスレッドプログラムのまれなケースで有用である可能性があります。割り当てを行っていないスレッドで定期的にこの関数を呼び出すことで、ガベージコレクションを実行することができます。</target>
        </trans-unit>
        <trans-unit id="3ea0f92c3d70dd355408c14ed7bbf0a9be4aeff9" translate="yes" xml:space="preserve">
          <source>Inside &lt;code&gt;f&lt;/code&gt;, &lt;code&gt;kwargs&lt;/code&gt; will be a key-value iterator over a named tuple. Named tuples (as well as dictionaries with keys of &lt;code&gt;Symbol&lt;/code&gt;) can be passed as keyword arguments using a semicolon in a call, e.g. &lt;code&gt;f(x, z=1; kwargs...)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; の内部では、 &lt;code&gt;kwargs&lt;/code&gt; は名前付きタプルのキー値イテレーターになります。名前付きタプル（および &lt;code&gt;Symbol&lt;/code&gt; のキーを持つディクショナリ）は、呼び出しでセミコロンを使用してキーワード引数として渡すことができます &lt;code&gt;f(x, z=1; kwargs...)&lt;/code&gt; 例：f（x、z = 1; kwargs ...））。</target>
        </trans-unit>
        <trans-unit id="d505904dee884402cee2bfc93d1e5e6eac91aed0" translate="yes" xml:space="preserve">
          <source>Inside a function call, &lt;code&gt;f(a=b)&lt;/code&gt; passes &lt;code&gt;b&lt;/code&gt; as the value of keyword argument &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">関数呼び出し内では、 &lt;code&gt;f(a=b)&lt;/code&gt; は &lt;code&gt;b&lt;/code&gt; をキーワード引数 &lt;code&gt;a&lt;/code&gt; の値として渡します。</target>
        </trans-unit>
        <trans-unit id="5c0628bcc3fe3dc7f18266ed4703a4ef8a1c7fc8" translate="yes" xml:space="preserve">
          <source>Inside a local scope a global variable can be assigned to by using the keyword &lt;a href=&quot;../../base/base/index#global&quot;&gt;&lt;code&gt;global&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">ローカルスコープ内では、キーワード&lt;a href=&quot;../../base/base/index#global&quot;&gt; &lt;code&gt;global&lt;/code&gt; &lt;/a&gt;を使用してグローバル変数を割り当てることができます。</target>
        </trans-unit>
        <trans-unit id="582d7159a5b73cf78ab92b918e0b2d46bdf1e604" translate="yes" xml:space="preserve">
          <source>Inside a local scope a variable can be forced to be a new local variable using the &lt;a href=&quot;../../base/base/index#local&quot;&gt;&lt;code&gt;local&lt;/code&gt;&lt;/a&gt; keyword:</source>
          <target state="translated">ローカルスコープ内では、&lt;a href=&quot;../../base/base/index#local&quot;&gt; &lt;code&gt;local&lt;/code&gt; &lt;/a&gt;キーワードを使用して変数を強制的に新しいローカル変数にすることができます。</target>
        </trans-unit>
        <trans-unit id="2d117997a7534c274cbe92ad615675971d22bedb" translate="yes" xml:space="preserve">
          <source>Inside of the &lt;code&gt;greet&lt;/code&gt; function, the assignment &lt;code&gt;x = &quot;hello&quot;&lt;/code&gt; causes &lt;code&gt;x&lt;/code&gt; to be a new local variable in the function's scope. There are two relevant facts: the assignment occurs in local scope and there is no existing local &lt;code&gt;x&lt;/code&gt; variable. Since &lt;code&gt;x&lt;/code&gt; is local, it doesn't matter if there is a global named &lt;code&gt;x&lt;/code&gt; or not. Here for example we define &lt;code&gt;x = 123&lt;/code&gt; before defining and calling &lt;code&gt;greet&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;greet&lt;/code&gt; 関数内で、割り当て &lt;code&gt;x = &quot;hello&quot;&lt;/code&gt; を指定すると、 &lt;code&gt;x&lt;/code&gt; は関数のスコープ内の新しいローカル変数になります。関連する2つの事実があります。割り当てはローカルスコープで発生し、既存のローカル &lt;code&gt;x&lt;/code&gt; 変数はありません。以来 &lt;code&gt;x&lt;/code&gt; ローカルでグローバルの名前があれば、それは問題ではない &lt;code&gt;x&lt;/code&gt; またはないが。ここでは、たとえば、 &lt;code&gt;greet&lt;/code&gt; を定義して呼び出す前に &lt;code&gt;x = 123&lt;/code&gt; を定義します。</target>
        </trans-unit>
        <trans-unit id="49fad0a2de99eca8b6794c525262e6ccd85a1c70" translate="yes" xml:space="preserve">
          <source>Inside parentheses with commas, &lt;code&gt;(a=1,)&lt;/code&gt; constructs a &lt;a href=&quot;#Core.NamedTuple&quot;&gt;&lt;code&gt;NamedTuple&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">括弧の中にコンマを入れて &lt;code&gt;(a=1,)&lt;/code&gt; は&lt;a href=&quot;#Core.NamedTuple&quot;&gt; &lt;code&gt;NamedTuple&lt;/code&gt; を作成し&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="456c6fe8fc3a9803d2d238636df3fddf2e8ebda8" translate="yes" xml:space="preserve">
          <source>Inspects the given UUID and returns its version (see &lt;a href=&quot;https://www.ietf.org/rfc/rfc4122&quot;&gt;RFC 4122&lt;/a&gt;).</source>
          <target state="translated">指定されたUUIDを検査し、そのバージョンを返します（&lt;a href=&quot;https://www.ietf.org/rfc/rfc4122&quot;&gt;RFC 4122を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="4ff8674778688251123ee296e21a5f29ce889b67" translate="yes" xml:space="preserve">
          <source>Instances can be constructed from strings via &lt;a href=&quot;#Base.parse&quot;&gt;&lt;code&gt;parse&lt;/code&gt;&lt;/a&gt;, or using the &lt;code&gt;big&lt;/code&gt; string literal.</source>
          <target state="translated">インスタンスは、&lt;a href=&quot;#Base.parse&quot;&gt; &lt;code&gt;parse&lt;/code&gt; &lt;/a&gt;を介して、または &lt;code&gt;big&lt;/code&gt; 文字列リテラルを使用して、文字列から構築できます。</target>
        </trans-unit>
        <trans-unit id="e2cd4547e98e69f493a2391724e35284eddfcf3f" translate="yes" xml:space="preserve">
          <source>Instead of calculating something or performing some action, you return a &lt;em&gt;quoted expression&lt;/em&gt; which, when evaluated, does what you want.</source>
          <target state="translated">何かを計算したり、何らかのアクションを実行したりする代わりに、評価されたときに必要なことを行う&lt;em&gt;引用された式&lt;/em&gt;を返します。</target>
        </trans-unit>
        <trans-unit id="e11074b6a3ddd4db91a1d67bb7c4e17f5cc3596e" translate="yes" xml:space="preserve">
          <source>Instead of directly sorting an array, you can compute a permutation of the array's indices that puts the array into sorted order:</source>
          <target state="translated">配列を直接ソートするのではなく,配列のインデックスの並べ替えを計算して,配列をソートされた順番に並べ替えることができます.</target>
        </trans-unit>
        <trans-unit id="d807ed905e686ec4c6c31127918a04393e4003ae" translate="yes" xml:space="preserve">
          <source>Instead of immediately running the command, backticks create a &lt;a href=&quot;../../base/base/index#Base.Cmd&quot;&gt;&lt;code&gt;Cmd&lt;/code&gt;&lt;/a&gt; object to represent the command. You can use this object to connect the command to others via pipes, &lt;a href=&quot;../../base/base/index#Base.run&quot;&gt;&lt;code&gt;run&lt;/code&gt;&lt;/a&gt; it, and &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; to it.</source>
          <target state="translated">コマンドをすぐに実行する代わりに、バッククォートはコマンドを表す&lt;a href=&quot;../../base/base/index#Base.Cmd&quot;&gt; &lt;code&gt;Cmd&lt;/code&gt; &lt;/a&gt;オブジェクトを作成します。このオブジェクトを使用して、コマンドをパイプを介して他のユーザーに接続し、&lt;a href=&quot;../../base/base/index#Base.run&quot;&gt; &lt;code&gt;run&lt;/code&gt; &lt;/a&gt;て、&lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;を行うことができます。</target>
        </trans-unit>
        <trans-unit id="78863694892c2019c43a79b283ebb340da799f84" translate="yes" xml:space="preserve">
          <source>Instead of loading a registered version of &lt;code&gt;Example&lt;/code&gt;, Julia will load the source code contained in &lt;code&gt;tutorial/dev/Example&lt;/code&gt;.</source>
          <target state="translated">Juliaは &lt;code&gt;Example&lt;/code&gt; の登録済みバージョンをロードする代わりに、 &lt;code&gt;tutorial/dev/Example&lt;/code&gt; に含まれているソースコードをロードします。</target>
        </trans-unit>
        <trans-unit id="80cddaa6c38b52b1b6910a5df7e62d1058e97067" translate="yes" xml:space="preserve">
          <source>Instead of performing some calculation or action, a generated function declaration returns a quoted expression which then forms the body for the method corresponding to the types of the arguments. When a generated function is called, the expression it returns is compiled and then run. To make this efficient, the result is usually cached. And to make this inferable, only a limited subset of the language is usable. Thus, generated functions provide a flexible way to move work from run time to compile time, at the expense of greater restrictions on allowed constructs.</source>
          <target state="translated">生成された関数宣言は、何らかの計算やアクションを実行する代わりに、引用符で囲まれた式を返し、それが引数の型に対応するメソッドのボディを形成します。生成された関数が呼び出されると、それが返す式がコンパイルされて実行されます。これを効率的にするために、結果は通常キャッシュされます。そして、これを推論可能にするために、言語の限られたサブセットのみが使用可能です。このように、生成された関数は、許可されたコンストラクタに対する制限が大きくなることを犠牲にしても、作業を実行時からコンパイル時に移動させる柔軟な方法を提供します。</target>
        </trans-unit>
        <trans-unit id="c042f3d9b71b32db250543be269d410c99d13527" translate="yes" xml:space="preserve">
          <source>Instead of:</source>
          <target state="translated">代わりに</target>
        </trans-unit>
        <trans-unit id="a3a52a1be0f1de968cc5d8921a39676d67c34867" translate="yes" xml:space="preserve">
          <source>Instead, use a semicolon or insert a line break after &lt;code&gt;catch&lt;/code&gt;:</source>
          <target state="translated">代わりに、セミコロンを使用するか、 &lt;code&gt;catch&lt;/code&gt; の後に改行を挿入します。</target>
        </trans-unit>
        <trans-unit id="3f6b46a05cf7ae83de7f241a566b6dcab9f9f12b" translate="yes" xml:space="preserve">
          <source>Integer division (the &lt;code&gt;div&lt;/code&gt; function) has two exceptional cases: dividing by zero, and dividing the lowest negative number (&lt;a href=&quot;../../base/base/index#Base.typemin&quot;&gt;&lt;code&gt;typemin&lt;/code&gt;&lt;/a&gt;) by -1. Both of these cases throw a &lt;a href=&quot;../../base/base/index#Core.DivideError&quot;&gt;&lt;code&gt;DivideError&lt;/code&gt;&lt;/a&gt;. The remainder and modulus functions (&lt;code&gt;rem&lt;/code&gt; and &lt;code&gt;mod&lt;/code&gt;) throw a &lt;a href=&quot;../../base/base/index#Core.DivideError&quot;&gt;&lt;code&gt;DivideError&lt;/code&gt;&lt;/a&gt; when their second argument is zero.</source>
          <target state="translated">整数除算（ &lt;code&gt;div&lt;/code&gt; 関数）には、2つの例外的なケースがあります。ゼロで除算する場合と、最小の負の数（&lt;a href=&quot;../../base/base/index#Base.typemin&quot;&gt; &lt;code&gt;typemin&lt;/code&gt; &lt;/a&gt;）を-1で除算する場合です。これらのケースはどちらも&lt;a href=&quot;../../base/base/index#Core.DivideError&quot;&gt; &lt;code&gt;DivideError&lt;/code&gt; を&lt;/a&gt;スローします。剰余関数とモジュラス関数（ &lt;code&gt;rem&lt;/code&gt; および &lt;code&gt;mod&lt;/code&gt; ）は、2番目の引数がゼロの場合に&lt;a href=&quot;../../base/base/index#Core.DivideError&quot;&gt; &lt;code&gt;DivideError&lt;/code&gt; を&lt;/a&gt;スローします。</target>
        </trans-unit>
        <trans-unit id="27477953a7f5629b70d1f8667b4ce5a95bd7d163" translate="yes" xml:space="preserve">
          <source>Integer division was attempted with a denominator value of 0.</source>
          <target state="translated">分母の値が 0 の整数除算が試みられました。</target>
        </trans-unit>
        <trans-unit id="44e36daccd6ac7a9f894c249dbe1f367783e4537" translate="yes" xml:space="preserve">
          <source>Integer square root: the largest integer &lt;code&gt;m&lt;/code&gt; such that &lt;code&gt;m*m &amp;lt;= n&lt;/code&gt;.</source>
          <target state="translated">平方根整数：最大整数 &lt;code&gt;m&lt;/code&gt; ように &lt;code&gt;m*m &amp;lt;= n&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d0f622cf48cf7d80bd106d7df1f3da91566c330d" translate="yes" xml:space="preserve">
          <source>Integer value N launches N additional local worker processes; &lt;code&gt;auto&lt;/code&gt; launches as many workers as the number of local CPU threads (logical cores)</source>
          <target state="translated">整数値Nは、N個の追加のローカルワーカープロセスを起動します。ローカルCPUスレッド（論理コア）の数と同じ数のワーカーを &lt;code&gt;auto&lt;/code&gt; 起動します</target>
        </trans-unit>
        <trans-unit id="724b5422dc05c791b8cf0befd732972c0409722e" translate="yes" xml:space="preserve">
          <source>Integers</source>
          <target state="translated">Integers</target>
        </trans-unit>
        <trans-unit id="0be1ec1ce9bd8f5a453ecb566c11ab0a7c7144d0" translate="yes" xml:space="preserve">
          <source>Integers and Floating-Point Numbers</source>
          <target state="translated">整数と浮動小数点数</target>
        </trans-unit>
        <trans-unit id="cdcba026c96bc24c46aaded28b7a473dd9b651d8" translate="yes" xml:space="preserve">
          <source>Integers and floating-point values are the basic building blocks of arithmetic and computation. Built-in representations of such values are called numeric primitives, while representations of integers and floating-point numbers as immediate values in code are known as numeric literals. For example, &lt;code&gt;1&lt;/code&gt; is an integer literal, while &lt;code&gt;1.0&lt;/code&gt; is a floating-point literal; their binary in-memory representations as objects are numeric primitives.</source>
          <target state="translated">整数と浮動小数点値は、算術と計算の基本的な構成要素です。このような値の組み込み表現は数値プリミティブと呼ばれ、整数と浮動小数点数のコード内の即値としての表現は数値リテラルと呼ばれます。たとえば、 &lt;code&gt;1&lt;/code&gt; は整数リテラルですが、 &lt;code&gt;1.0&lt;/code&gt; は浮動小数点リテラルです。オブジェクトとしてのバイナリのインメモリ表現は数値プリミティブです。</target>
        </trans-unit>
        <trans-unit id="be404ce277aac9d3b9b27f0140b709ff517b7820" translate="yes" xml:space="preserve">
          <source>Integers are compared in the standard manner &amp;ndash; by comparison of bits. Floating-point numbers are compared according to the &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-2008&quot;&gt;IEEE 754 standard&lt;/a&gt;:</source>
          <target state="translated">整数は、ビットの比較によって、標準的な方法で比較されます。浮動小数点数は、&lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-2008&quot;&gt;IEEE 754標準&lt;/a&gt;に従って比較されます。</target>
        </trans-unit>
        <trans-unit id="e3b59c9f1c26e320e172cac39695e68589e740a0" translate="yes" xml:space="preserve">
          <source>Integral</source>
          <target state="translated">Integral</target>
        </trans-unit>
        <trans-unit id="70680c64952b0114adcda3eb14a614e1841cd0c6" translate="yes" xml:space="preserve">
          <source>Integral Around A Point Operator</source>
          <target state="translated">点演算子周辺積分</target>
        </trans-unit>
        <trans-unit id="425335bd88e128f008b3f48181d1c27b517bcc72" translate="yes" xml:space="preserve">
          <source>Integral Average With Slash</source>
          <target state="translated">スラッシュ付き積分平均</target>
        </trans-unit>
        <trans-unit id="c6bac88caff6c11517b441d63dd4587857621bab" translate="yes" xml:space="preserve">
          <source>Integral With Double Stroke</source>
          <target state="translated">ダブルストロークのインテグラル</target>
        </trans-unit>
        <trans-unit id="18238ecc8130fd86a404d903215b4901fbd6604e" translate="yes" xml:space="preserve">
          <source>Integral With Intersection</source>
          <target state="translated">交差点との積分</target>
        </trans-unit>
        <trans-unit id="8a62b59c92abaaa075d87faf375d4d0d5e2fdc39" translate="yes" xml:space="preserve">
          <source>Integral With Overbar</source>
          <target state="translated">オーバーバーとの一体型</target>
        </trans-unit>
        <trans-unit id="08588fc154d2b615a7916934fe8e56ebda68acf8" translate="yes" xml:space="preserve">
          <source>Integral With Times Sign</source>
          <target state="translated">タイムズサインとの統合</target>
        </trans-unit>
        <trans-unit id="31ecf2a75d24fa7ec2a5569e3665d7f415d4db51" translate="yes" xml:space="preserve">
          <source>Integral With Underbar</source>
          <target state="translated">アンダーバーとの一体型</target>
        </trans-unit>
        <trans-unit id="23eafe62fdaca340d651a852cff8f87d44076b09" translate="yes" xml:space="preserve">
          <source>Integral With Union</source>
          <target state="translated">ユニオンとの統合</target>
        </trans-unit>
        <trans-unit id="2885cb42f64585560c85104eeedf86ba7e0ed77e" translate="yes" xml:space="preserve">
          <source>Intel's &lt;a href=&quot;https://software.intel.com/en-us/vtune&quot;&gt;VTune&amp;trade; Amplifier&lt;/a&gt; (&lt;code&gt;USE_INTEL_JITEVENTS&lt;/code&gt; set to &lt;code&gt;1&lt;/code&gt; in the build configuration), or</source>
          <target state="translated">Intelの&lt;a href=&quot;https://software.intel.com/en-us/vtune&quot;&gt;VTune&amp;trade;アンプ&lt;/a&gt;（ビルド構成で &lt;code&gt;USE_INTEL_JITEVENTS&lt;/code&gt; を &lt;code&gt;1&lt;/code&gt; に設定）、または</target>
        </trans-unit>
        <trans-unit id="207cb56e67212ece90d1329dc4b01521c8f13014" translate="yes" xml:space="preserve">
          <source>Interacting with the contents or methods of &lt;code&gt;Core.Compiler&lt;/code&gt; in any way.</source>
          <target state="translated">&lt;code&gt;Core.Compiler&lt;/code&gt; のコンテンツまたはメソッドとのやり取り。</target>
        </trans-unit>
        <trans-unit id="d4f66ae8b3da23aee8b514d4076de7a8e09b0b4e" translate="yes" xml:space="preserve">
          <source>Interactive Utilities</source>
          <target state="translated">インタラクティブなユーティリティ</target>
        </trans-unit>
        <trans-unit id="71fefc1d52a78f40748037e8a91fc8ea4f8e2578" translate="yes" xml:space="preserve">
          <source>Interactive mode; REPL runs and &lt;code&gt;isinteractive()&lt;/code&gt; is true</source>
          <target state="translated">インタラクティブモード。REPLが実行され、 &lt;code&gt;isinteractive()&lt;/code&gt; がtrueである</target>
        </trans-unit>
        <trans-unit id="0270e20982d6093d44ba136572cbf822d6290a5d" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.@code_llvm</source>
          <target state="translated">InteractiveUtils.@code_llvm</target>
        </trans-unit>
        <trans-unit id="0309be470088530490561ff83d97b95071df357e" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.@code_lowered</source>
          <target state="translated">InteractiveUtils.@code_lowered</target>
        </trans-unit>
        <trans-unit id="00a7a46c62638c2b2d4deb9dc4bd43a8d3c3582c" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.@code_native</source>
          <target state="translated">InteractiveUtils.@code_native</target>
        </trans-unit>
        <trans-unit id="4fa27864c86ced13027d392baeedb020be6c560a" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.@code_typed</source>
          <target state="translated">InteractiveUtils.@code_typed</target>
        </trans-unit>
        <trans-unit id="1e45473f814223dcb1c417d561e1870e1450bf83" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.@code_warntype</source>
          <target state="translated">InteractiveUtils.@code_warntype</target>
        </trans-unit>
        <trans-unit id="eedef913d7842aa079f915bdbbb5f5e90c47c7f6" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.@edit</source>
          <target state="translated">InteractiveUtils.@edit</target>
        </trans-unit>
        <trans-unit id="a6df5f45ac03e2c658d92e8736e88cafa5b98995" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.@functionloc</source>
          <target state="translated">InteractiveUtils.@functionloc</target>
        </trans-unit>
        <trans-unit id="49e359f4c318b876f99ccb7d37f63e69deb2003d" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.@less</source>
          <target state="translated">InteractiveUtils.@less</target>
        </trans-unit>
        <trans-unit id="6e359d1c5b33d4212df3c4f8c3762813890df9ae" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.@which</source>
          <target state="translated">InteractiveUtils.@which</target>
        </trans-unit>
        <trans-unit id="2d50f6ed31622302ae5f5a5feebfb95f2c420a04" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.clipboard()</source>
          <target state="translated">InteractiveUtils.clipboard()</target>
        </trans-unit>
        <trans-unit id="c1ad553095bd7ae0c9db5b342934998a5be27479" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.code_llvm()</source>
          <target state="translated">InteractiveUtils.code_llvm()</target>
        </trans-unit>
        <trans-unit id="a70df8f6770abff941be7ee8196e397ae5bbd4b8" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.code_native()</source>
          <target state="translated">InteractiveUtils.code_native()</target>
        </trans-unit>
        <trans-unit id="f009b2e3c7cb61122f070c557fb9f4dcd1edf6db" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.code_warntype()</source>
          <target state="translated">InteractiveUtils.code_warntype()</target>
        </trans-unit>
        <trans-unit id="d4c1c9ee2ecb7996d780a0e5d5ccea921a53d56a" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.edit()</source>
          <target state="translated">InteractiveUtils.edit()</target>
        </trans-unit>
        <trans-unit id="424927890145616c60279ce930588fd54c4ac90e" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.less()</source>
          <target state="translated">InteractiveUtils.less()</target>
        </trans-unit>
        <trans-unit id="49eeeef411d4549f28b217525726cf46e51440cb" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.methodswith()</source>
          <target state="translated">InteractiveUtils.methodswith()</target>
        </trans-unit>
        <trans-unit id="59973fd047bc66e11de11bff485ff30fc8072b48" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.subtypes()</source>
          <target state="translated">InteractiveUtils.subtypes()</target>
        </trans-unit>
        <trans-unit id="8cc40b484c66058018a0b8c42f2ab741a2014154" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.varinfo()</source>
          <target state="translated">InteractiveUtils.varinfo()</target>
        </trans-unit>
        <trans-unit id="391d124220b1a9c25f8d3323e7bb133c849aadc9" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.versioninfo()</source>
          <target state="translated">InteractiveUtils.versioninfo()</target>
        </trans-unit>
        <trans-unit id="068a8966386d6f477f70dcc54b094caba48a03f4" translate="yes" xml:space="preserve">
          <source>Intercalate</source>
          <target state="translated">Intercalate</target>
        </trans-unit>
        <trans-unit id="a791af570ec4e5730c5e110c39b173c357ea4d3a" translate="yes" xml:space="preserve">
          <source>Interconverts between dense and sparse formats.</source>
          <target state="translated">密なフォーマットと疎なフォーマットを相互変換します。</target>
        </trans-unit>
        <trans-unit id="c3229f4e0f20d697072608271bc7f20c5b6d789f" translate="yes" xml:space="preserve">
          <source>Interface to BLAS subroutines.</source>
          <target state="translated">BLASのサブルーチンへのインターフェースです。</target>
        </trans-unit>
        <trans-unit id="bcdb1ff794ae28041f3196a504b6115b3dea810a" translate="yes" xml:space="preserve">
          <source>Interface to libc, the C standard library.</source>
          <target state="translated">C 標準ライブラリである libc へのインターフェイスです。</target>
        </trans-unit>
        <trans-unit id="b356313f979923fc829adb909098ed26a5a01aff" translate="yes" xml:space="preserve">
          <source>Interfaces</source>
          <target state="translated">Interfaces</target>
        </trans-unit>
        <trans-unit id="c2b213458be4f2f6fdec41d29483b814cba730b1" translate="yes" xml:space="preserve">
          <source>Interfaces to LAPACK subroutines.</source>
          <target state="translated">LAPACKサブルーチンへのインターフェースです。</target>
        </trans-unit>
        <trans-unit id="a514e8807ceddceeb9d1c2be8e83634758fea386" translate="yes" xml:space="preserve">
          <source>Interior Product</source>
          <target state="translated">インテリア製品</target>
        </trans-unit>
        <trans-unit id="0c4a9d0a55deb37d51d5b2b7f615f0874ed971d8" translate="yes" xml:space="preserve">
          <source>Internally, &lt;code&gt;promote_type&lt;/code&gt; is used inside of &lt;code&gt;promote&lt;/code&gt; to determine what type argument values should be converted to for promotion. It can, however, be useful in its own right. The curious reader can read the code in &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/promotion.jl&quot;&gt;&lt;code&gt;promotion.jl&lt;/code&gt;&lt;/a&gt;, which defines the complete promotion mechanism in about 35 lines.</source>
          <target state="translated">内部的に、 &lt;code&gt;promote_type&lt;/code&gt; は &lt;code&gt;promote&lt;/code&gt; 内部で使用され、プロモート用に変換する必要がある型引数値を決定します。ただし、それ自体は有用です。好奇心のリーダーはでコード読み取ることができる&lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/promotion.jl&quot;&gt; &lt;code&gt;promotion.jl&lt;/code&gt; &lt;/a&gt;約35行で完全促進メカニズムを定義し、。</target>
        </trans-unit>
        <trans-unit id="818408de3c95448c6a4c8c7cc57f8a8c85a4002d" translate="yes" xml:space="preserve">
          <source>Internally, an &lt;code&gt;AbstractChar&lt;/code&gt; type may use a variety of encodings. Conversion via &lt;code&gt;codepoint(char)&lt;/code&gt; will not reveal this encoding because it always returns the Unicode value of the character. &lt;code&gt;print(io, c)&lt;/code&gt; of any &lt;code&gt;c::AbstractChar&lt;/code&gt; produces an encoding determined by &lt;code&gt;io&lt;/code&gt; (UTF-8 for all built-in &lt;code&gt;IO&lt;/code&gt; types), via conversion to &lt;code&gt;Char&lt;/code&gt; if necessary.</source>
          <target state="translated">内部的には、 &lt;code&gt;AbstractChar&lt;/code&gt; 型はさまざまなエンコーディングを使用できます。 &lt;code&gt;codepoint(char)&lt;/code&gt; による変換では、常に文字のUnicode値が返されるため、このエンコーディングは明らかになりません。 &lt;code&gt;c::AbstractChar&lt;/code&gt; &lt;code&gt;print(io, c)&lt;/code&gt; は、必要に応じて &lt;code&gt;Char&lt;/code&gt; への変換を介して、 &lt;code&gt;io&lt;/code&gt; （すべての組み込み &lt;code&gt;IO&lt;/code&gt; タイプの場合はUTF-8）によって決定されるエンコーディングを生成します。</target>
        </trans-unit>
        <trans-unit id="4952806e1eda6ad8d06e741bd80f1e6d3a2efafd" translate="yes" xml:space="preserve">
          <source>Internally, this code creates two implementations of the function: a generated one where the first block in &lt;code&gt;if @generated&lt;/code&gt; is used, and a normal one where the &lt;code&gt;else&lt;/code&gt; block is used. Inside the &lt;code&gt;then&lt;/code&gt; part of the &lt;code&gt;if @generated&lt;/code&gt; block, code has the same semantics as other generated functions: argument names refer to types, and the code should return an expression. Multiple &lt;code&gt;if @generated&lt;/code&gt; blocks may occur, in which case the generated implementation uses all of the &lt;code&gt;then&lt;/code&gt; blocks and the alternate implementation uses all of the &lt;code&gt;else&lt;/code&gt; blocks.</source>
          <target state="translated">内部的には、このコードは関数の2つの実装を作成します &lt;code&gt;if @generated&lt;/code&gt; 最初のブロックが使用される生成されたものと、 &lt;code&gt;else&lt;/code&gt; ブロックが使用される通常の実装です。 &lt;code&gt;if @generated&lt;/code&gt; ブロックの &lt;code&gt;then&lt;/code&gt; 部分内では、コードは他の生成された関数と同じセマンティクスを持っています。引数名は型を参照し、コードは式を返す必要があります。複数の &lt;code&gt;if @generated&lt;/code&gt; ブロックが発生する場合があります。その場合、生成された実装はすべての &lt;code&gt;then&lt;/code&gt; ブロックを使用し、代替の実装はすべての &lt;code&gt;else&lt;/code&gt; ブロックを使用します。</target>
        </trans-unit>
        <trans-unit id="653edb0bfdb6bd20dfe7affb5776bc7d271237c7" translate="yes" xml:space="preserve">
          <source>Internals</source>
          <target state="translated">Internals</target>
        </trans-unit>
        <trans-unit id="48012c80f49c5c1a3bff1ed20d31a89b4f215742" translate="yes" xml:space="preserve">
          <source>Interpolating into an unquoted expression is not supported and will cause a compile-time error:</source>
          <target state="translated">引用符で囲まれていない式への補間はサポートされておらず、コンパイル時にエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="213daae9f453b89afd1148247dfa9083fa51630b" translate="yes" xml:space="preserve">
          <source>Interpolating values via &lt;code&gt;$&lt;/code&gt; is available as of Julia 1.4.</source>
          <target state="translated">&lt;code&gt;$&lt;/code&gt; を介した値の補間は、Julia1.4以降で使用できます。</target>
        </trans-unit>
        <trans-unit id="6a9858c9bf3149456595f98943cf88e41039822e" translate="yes" xml:space="preserve">
          <source>Interpolation</source>
          <target state="translated">Interpolation</target>
        </trans-unit>
        <trans-unit id="d67b7c5f52f05b37b77a64fd823fc76a0fce5a66" translate="yes" xml:space="preserve">
          <source>Interpret an iterable of key-value pairs as a named tuple, and perform a merge.</source>
          <target state="translated">キーと値のペアのイテレートブルを名前付きタプルとして解釈し、マージを実行します。</target>
        </trans-unit>
        <trans-unit id="cc53b2acfc42c6cf13c71d4c67ea40578eaaf1f7" translate="yes" xml:space="preserve">
          <source>Interpretation: accessing elements of poorly-typed arrays</source>
          <target state="translated">解釈:型付けの悪い配列の要素へのアクセス</target>
        </trans-unit>
        <trans-unit id="7894bb109218bbe3ea53cb08c360e18b2453f383" translate="yes" xml:space="preserve">
          <source>Interpretation: call to a type-unstable function &lt;code&gt;g&lt;/code&gt;.</source>
          <target state="translated">解釈：型が不安定な関数 &lt;code&gt;g&lt;/code&gt; の呼び出し。</target>
        </trans-unit>
        <trans-unit id="7784e3d882b6a7b4c22ed3b7f03fb99cea250d48" translate="yes" xml:space="preserve">
          <source>Interpretation: function with unstable return type</source>
          <target state="translated">解釈:不安定な戻り値の型を持つ関数</target>
        </trans-unit>
        <trans-unit id="9f71e4dd30d3efc21956f72596ba4278f8921c99" translate="yes" xml:space="preserve">
          <source>Interpretation: getting a field that is of non-leaf type. In this case, &lt;code&gt;ArrayContainer&lt;/code&gt; had a field &lt;code&gt;data::Array{T}&lt;/code&gt;. But &lt;code&gt;Array&lt;/code&gt; needs the dimension &lt;code&gt;N&lt;/code&gt;, too, to be a concrete type.</source>
          <target state="translated">解釈：非リーフタイプのフィールドを取得する。この場合、 &lt;code&gt;ArrayContainer&lt;/code&gt; にはフィールド &lt;code&gt;data::Array{T}&lt;/code&gt; 。しかし、 &lt;code&gt;Array&lt;/code&gt; も具象型であるためには次元 &lt;code&gt;N&lt;/code&gt; が必要です。</target>
        </trans-unit>
        <trans-unit id="f71c83c811d3e87825b69245ec2c0dff4c1686bd" translate="yes" xml:space="preserve">
          <source>Interpreting the output of &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_warntype&quot;&gt;&lt;code&gt;@code_warntype&lt;/code&gt;&lt;/a&gt;, like that of its cousins &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_lowered&quot;&gt;&lt;code&gt;@code_lowered&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_typed&quot;&gt;&lt;code&gt;@code_typed&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_llvm&quot;&gt;&lt;code&gt;@code_llvm&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_native&quot;&gt;&lt;code&gt;@code_native&lt;/code&gt;&lt;/a&gt;, takes a little practice. Your code is being presented in form that has been heavily digested on its way to generating compiled machine code. Most of the expressions are annotated by a type, indicated by the &lt;code&gt;::T&lt;/code&gt; (where &lt;code&gt;T&lt;/code&gt; might be &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;, for example). The most important characteristic of &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_warntype&quot;&gt;&lt;code&gt;@code_warntype&lt;/code&gt;&lt;/a&gt; is that non-concrete types are displayed in red; in the above example, such output is shown in uppercase.</source>
          <target state="translated">&lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_warntype&quot;&gt; &lt;code&gt;@code_warntype&lt;/code&gt; &lt;/a&gt;の出力を、その従兄弟である&lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_lowered&quot;&gt; &lt;code&gt;@code_lowered&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_typed&quot;&gt; &lt;code&gt;@code_typed&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_llvm&quot;&gt; &lt;code&gt;@code_llvm&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_native&quot;&gt; &lt;code&gt;@code_native&lt;/code&gt; のように解釈する&lt;/a&gt;には、少し練習が必要です。あなたのコードは、コンパイルされた機械語コードを生成する途中で、かなり分解された形で提示されています。ほとんどの式は、 &lt;code&gt;::T&lt;/code&gt; （ &lt;code&gt;T&lt;/code&gt; は&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;など）で示されるタイプによって注釈が付けられます。&lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_warntype&quot;&gt; &lt;code&gt;@code_warntype&lt;/code&gt; &lt;/a&gt;の最も重要な特性は、非コンクリート型が赤で表示されることです。上記の例では、そのような出力は大文字で示されています。</target>
        </trans-unit>
        <trans-unit id="b25ba536a0a42dea499d4fc2b8979e5924399239" translate="yes" xml:space="preserve">
          <source>Interpreting the output of &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_warntype&quot;&gt;&lt;code&gt;@code_warntype&lt;/code&gt;&lt;/a&gt;, like that of its cousins &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_lowered&quot;&gt;&lt;code&gt;@code_lowered&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_typed&quot;&gt;&lt;code&gt;@code_typed&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_llvm&quot;&gt;&lt;code&gt;@code_llvm&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_native&quot;&gt;&lt;code&gt;@code_native&lt;/code&gt;&lt;/a&gt;, takes a little practice. Your code is being presented in form that has been heavily digested on its way to generating compiled machine code. Most of the expressions are annotated by a type, indicated by the &lt;code&gt;::T&lt;/code&gt; (where &lt;code&gt;T&lt;/code&gt; might be &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;, for example). The most important characteristic of &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_warntype&quot;&gt;&lt;code&gt;@code_warntype&lt;/code&gt;&lt;/a&gt; is that non-concrete types are displayed in red; since this document is written in Markdown, which has no color, in this document, red text is denoted by uppercase.</source>
          <target state="translated">&lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_warntype&quot;&gt; &lt;code&gt;@code_warntype&lt;/code&gt; &lt;/a&gt;の出力を、そのいとこである&lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_lowered&quot;&gt; &lt;code&gt;@code_lowered&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_typed&quot;&gt; &lt;code&gt;@code_typed&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_llvm&quot;&gt; &lt;code&gt;@code_llvm&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_native&quot;&gt; &lt;code&gt;@code_native&lt;/code&gt; &lt;/a&gt;の出力のように解釈するには、少し練習が必要です。あなたのコードは、コンパイルされたマシンコードを生成する途中でかなり消化された形式で提示されています。ほとんどの式は、 &lt;code&gt;::T&lt;/code&gt; で示される型によって注釈が付けられます（たとえば、 &lt;code&gt;T&lt;/code&gt; は&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; の&lt;/a&gt;場合があります）。&lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_warntype&quot;&gt; &lt;code&gt;@code_warntype&lt;/code&gt; &lt;/a&gt;の最も重要な特徴は、非具象型が赤で表示されることです。このドキュメントは色のないMarkdownで書かれているため、このドキュメントでは赤いテキストは大文字で示されています。</target>
        </trans-unit>
        <trans-unit id="cc939bea48b5a28296b21d2be9495aa8bccd0b19" translate="yes" xml:space="preserve">
          <source>Interrupt or cancel</source>
          <target state="translated">割り込みまたはキャンセル</target>
        </trans-unit>
        <trans-unit id="23165f09bcddd0acc011e45e34282dbbd91bd4cd" translate="yes" xml:space="preserve">
          <source>Interrupt the current executing task on the specified workers. This is equivalent to pressing Ctrl-C on the local machine. If no arguments are given, all workers are interrupted.</source>
          <target state="translated">指定されたワーカーで現在実行中のタスクを中断します。これは、ローカルマシンで Ctrl-C を押すのと同じです。引数が与えられない場合、すべてのワーカーが中断されます。</target>
        </trans-unit>
        <trans-unit id="658cc9a8a17acd75a5bc21930b12d446eea71552" translate="yes" xml:space="preserve">
          <source>Intersect all passed in sets and overwrite &lt;code&gt;s&lt;/code&gt; with the result. Maintain order with arrays.</source>
          <target state="translated">渡されたすべてのセットを交差させ、結果で &lt;code&gt;s&lt;/code&gt; を上書きします。配列で順序を維持します。</target>
        </trans-unit>
        <trans-unit id="d0f596ba112a353008597117b57b10b067fc620b" translate="yes" xml:space="preserve">
          <source>Intersection</source>
          <target state="translated">Intersection</target>
        </trans-unit>
        <trans-unit id="7d65fe6f634dc82a5910e500d111d1c2553d45ad" translate="yes" xml:space="preserve">
          <source>Intersection Beside And Joined With Intersection</source>
          <target state="translated">交差点の横にある交差点と交差点との接合部</target>
        </trans-unit>
        <trans-unit id="f70ced5527bc06ac0250ff3ce0c6433b4fc007ad" translate="yes" xml:space="preserve">
          <source>Intersection With Dot</source>
          <target state="translated">ドットとの交差点</target>
        </trans-unit>
        <trans-unit id="fea160380c26aea0a6f5cf6d33e5059a2528bb99" translate="yes" xml:space="preserve">
          <source>Intersection With Logical And</source>
          <target state="translated">論理的なものとの交差点</target>
        </trans-unit>
        <trans-unit id="8a447498c8a13bd62bc28a71db064abbbd2ce851" translate="yes" xml:space="preserve">
          <source>Intersection With Overbar</source>
          <target state="translated">オーバーバーとの交差点</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="95010e236dbeb1d0c89e9d5b6ed0ea0da0ed9572" translate="yes" xml:space="preserve">
          <source>Intuitively, this corresponds to the type of a function's arguments being a subtype of the function's signature (when the signature matches).</source>
          <target state="translated">直感的には、これは関数の引数の型が関数のシグネチャのサブタイプであることに対応します(シグネチャがマッチする場合)。</target>
        </trans-unit>
        <trans-unit id="f4bc4f6c3fe38fa1ef542295504817c8e94651bb" translate="yes" xml:space="preserve">
          <source>Inverse Bullet</source>
          <target state="translated">逆弾</target>
        </trans-unit>
        <trans-unit id="a2b80ae8599265e5e4df3c9c6eae5101a072d85a" translate="yes" xml:space="preserve">
          <source>Inverse White Circle</source>
          <target state="translated">インバースホワイトサークル</target>
        </trans-unit>
        <trans-unit id="f5c93f67585d1f2ce3d07fe77774efdd8e1c494a" translate="yes" xml:space="preserve">
          <source>Inverted Exclamation Mark</source>
          <target state="translated">逆さエクスクラメーションマーク</target>
        </trans-unit>
        <trans-unit id="8ed370a70ad4ba84f93ff72e14bb89b2e795837a" translate="yes" xml:space="preserve">
          <source>Inverted Lazy S</source>
          <target state="translated">反転レイジーS</target>
        </trans-unit>
        <trans-unit id="7e3bf2655c3d6132b1040ffc28240e0e2706a489" translate="yes" xml:space="preserve">
          <source>Inverted Ohm Sign / Mho</source>
          <target state="translated">反転したオーム記号/Mho</target>
        </trans-unit>
        <trans-unit id="77352625457aa55d3c246bb35487f40a40f194e5" translate="yes" xml:space="preserve">
          <source>Inverted Question Mark</source>
          <target state="translated">反転したクエスチョンマーク</target>
        </trans-unit>
        <trans-unit id="1dc2af95223d452f5604dae81acef5fd3a117e33" translate="yes" xml:space="preserve">
          <source>Invoke a method for the given generic function &lt;code&gt;f&lt;/code&gt; matching the specified types &lt;code&gt;argtypes&lt;/code&gt; on the specified arguments &lt;code&gt;args&lt;/code&gt; and passing the keyword arguments &lt;code&gt;kwargs&lt;/code&gt;. The arguments &lt;code&gt;args&lt;/code&gt; must conform with the specified types in &lt;code&gt;argtypes&lt;/code&gt;, i.e. conversion is not automatically performed. This method allows invoking a method other than the most specific matching method, which is useful when the behavior of a more general definition is explicitly needed (often as part of the implementation of a more specific method of the same function).</source>
          <target state="translated">指定された引数 &lt;code&gt;args&lt;/code&gt; の指定された型 &lt;code&gt;argtypes&lt;/code&gt; に一致し、キーワード引数 &lt;code&gt;kwargs&lt;/code&gt; を渡して、指定されたジェネリック関数 &lt;code&gt;f&lt;/code&gt; のメソッドを呼び出します。引数 &lt;code&gt;args&lt;/code&gt; は、 &lt;code&gt;argtypes&lt;/code&gt; で指定された型に準拠している必要があります。つまり、変換は自動的には実行されません。このメソッドを使用すると、最も具体的なマッチングメソッド以外のメソッドを呼び出すことができます。これは、より一般的な定義の動作が明示的に必要な場合に役立ちます（多くの場合、同じ関数のより具体的なメソッドの実装の一部として）。</target>
        </trans-unit>
        <trans-unit id="f0c54c7c50c82bf234e4ed64cb3ce50f2fd86de8" translate="yes" xml:space="preserve">
          <source>Invoke all handlers from &lt;a href=&quot;#Base.Experimental.register_error_hint&quot;&gt;&lt;code&gt;Experimental.register_error_hint&lt;/code&gt;&lt;/a&gt; for the particular exception type &lt;code&gt;typeof(ex)&lt;/code&gt;. &lt;code&gt;args&lt;/code&gt; must contain any other arguments expected by the handler for that type.</source>
          <target state="translated">特定の例外タイプ &lt;code&gt;typeof(ex)&lt;/code&gt; に対して、&lt;a href=&quot;#Base.Experimental.register_error_hint&quot;&gt; &lt;code&gt;Experimental.register_error_hint&lt;/code&gt; &lt;/a&gt;からすべてのハンドラーを呼び出します。 &lt;code&gt;args&lt;/code&gt; には、そのタイプのハンドラーが期待するその他の引数が含まれている必要があります。</target>
        </trans-unit>
        <trans-unit id="0fe30ecc758896527e5047bf5e1ab5207bc281f3" translate="yes" xml:space="preserve">
          <source>Irrational</source>
          <target state="translated">Irrational</target>
        </trans-unit>
        <trans-unit id="474a6d17a6faabac287216094db27839ef426282" translate="yes" xml:space="preserve">
          <source>Is Julia named after someone or something?</source>
          <target state="translated">ジュリアの名前は誰かの名前か何か?</target>
        </trans-unit>
        <trans-unit id="f21fa8512b05ce15e621a0c6aca735529c300b50" translate="yes" xml:space="preserve">
          <source>Issue 8859, &quot;Fix least squares&quot;, https://github.com/JuliaLang/julia/pull/8859</source>
          <target state="translated">問題8859、「最小二乗の修正」、https://github.com/JuliaLang/julia/pull/8859</target>
        </trans-unit>
        <trans-unit id="beadd95d62ed185b3348f8f407f354b8cc251415" translate="yes" xml:space="preserve">
          <source>It also makes writing exponential functions more elegant:</source>
          <target state="translated">指数関数の書き方もエレガントになります。</target>
        </trans-unit>
        <trans-unit id="f6ba82c6b32228a1dcbba192584fb70b95766cb3" translate="yes" xml:space="preserve">
          <source>It can be more efficient. Some structs can be packed efficiently into arrays, and in some cases the compiler is able to avoid allocating immutable objects entirely.</source>
          <target state="translated">より効率的にすることができます。構造体の中には、効率的に配列に詰め込むことができるものもあり、コンパイラによっては、不変オブジェクトの割り当てを完全に回避できる場合もあります。</target>
        </trans-unit>
        <trans-unit id="2138e5233860592eb48b0938be0063487a8c3bbe" translate="yes" xml:space="preserve">
          <source>It can happen that &lt;code&gt;Sampler(rng::AbstractRNG, ::S, ::Repetition)&lt;/code&gt; is already defined in the &lt;code&gt;Random&lt;/code&gt; module. It would then be possible to skip step 1) in practice (if one wants to specialize generation for this particular RNG type), but the corresponding &lt;code&gt;SamplerS&lt;/code&gt; type is considered as internal detail, and may be changed without warning.</source>
          <target state="translated">ことが起こる可能 &lt;code&gt;Sampler(rng::AbstractRNG, ::S, ::Repetition)&lt;/code&gt; 既に定義されている &lt;code&gt;Random&lt;/code&gt; モジュール。その後、実際には（この特定のRNGタイプの生成を特化したい場合）ステップ1）をスキップすることが可能ですが、対応する &lt;code&gt;SamplerS&lt;/code&gt; タイプは内部詳細と見なされ、警告なしに変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="b7db5f9d834448c3fd65f59044d31e02c3be0663" translate="yes" xml:space="preserve">
          <source>It can profile into Julia's core code and even (optionally) into C and Fortran libraries.</source>
          <target state="translated">ジュリアのコアコードにプロファイリングしたり、(オプションで)CやFortranライブラリにプロファイリングしたりすることができます。</target>
        </trans-unit>
        <trans-unit id="c491763305aba9f2c8a952732183092d445bd3cb" translate="yes" xml:space="preserve">
          <source>It decomposes &lt;code&gt;[A; B]&lt;/code&gt; into &lt;code&gt;[UC; VS]H&lt;/code&gt;, where &lt;code&gt;[UC; VS]&lt;/code&gt; is a natural orthogonal basis for the column space of &lt;code&gt;[A; B]&lt;/code&gt;, and &lt;code&gt;H = RQ'&lt;/code&gt; is a natural non-orthogonal basis for the rowspace of &lt;code&gt;[A;B]&lt;/code&gt;, where the top rows are most closely attributed to the &lt;code&gt;A&lt;/code&gt; matrix, and the bottom to the &lt;code&gt;B&lt;/code&gt; matrix. The multi-cosine/sine matrices &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;S&lt;/code&gt; provide a multi-measure of how much &lt;code&gt;A&lt;/code&gt; vs how much &lt;code&gt;B&lt;/code&gt;, and &lt;code&gt;U&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; provide directions in which these are measured.</source>
          <target state="translated">分解します &lt;code&gt;[A; B]&lt;/code&gt; を &lt;code&gt;[UC; VS]H&lt;/code&gt; 、ここで &lt;code&gt;[UC; VS]&lt;/code&gt; は、 &lt;code&gt;[A; B]&lt;/code&gt; 列空間の自然な直交基底です。 B]、および &lt;code&gt;H = RQ'&lt;/code&gt; は、 &lt;code&gt;[A;B]&lt;/code&gt; の行空間の自然な非直交基底であり、上の行は &lt;code&gt;A&lt;/code&gt; 行列に最も密接に起因し、下の行は &lt;code&gt;B&lt;/code&gt; 行列に最も密接に起因します。マルチ余弦/正弦行列 &lt;code&gt;C&lt;/code&gt; 及び &lt;code&gt;S&lt;/code&gt; は、どのくらいの多尺度提供 &lt;code&gt;A&lt;/code&gt; 対どのくらい &lt;code&gt;B&lt;/code&gt; 、及び &lt;code&gt;U&lt;/code&gt; 及び &lt;code&gt;V&lt;/code&gt; は、これらの測定された方向を提供します。</target>
        </trans-unit>
        <trans-unit id="c10e801b8b0e3436ff2d170e31afdf3876bf67ea" translate="yes" xml:space="preserve">
          <source>It does not return.</source>
          <target state="translated">戻りません。</target>
        </trans-unit>
        <trans-unit id="62d668cd36ba8709a3dd4638a2eee6fedce824d7" translate="yes" xml:space="preserve">
          <source>It has a special compilation rule: a homogeneous tuple of &lt;code&gt;VecElement{T}&lt;/code&gt; maps to an LLVM &lt;code&gt;vector&lt;/code&gt; type when &lt;code&gt;T&lt;/code&gt; is a primitive bits type and the tuple length is in the set {2-6,8-10,16}.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; がプリミティブビットタイプであり、タプルの長さがセット{2-6,8-10,16}にある場合、 &lt;code&gt;VecElement{T}&lt;/code&gt; 同種のタプルはLLVM &lt;code&gt;vector&lt;/code&gt; タイプにマップされます。</target>
        </trans-unit>
        <trans-unit id="60e06d084730278b0af0749e7022e6e9535b9603" translate="yes" xml:space="preserve">
          <source>It has a special compilation rule: a homogeneous tuple of &lt;code&gt;VecElement{T}&lt;/code&gt; maps to an LLVM &lt;code&gt;vector&lt;/code&gt; type when &lt;code&gt;T&lt;/code&gt; is a primitive bits type.</source>
          <target state="translated">特別なコンパイルルールがあります &lt;code&gt;T&lt;/code&gt; がプリミティブビットタイプの場合、 &lt;code&gt;VecElement{T}&lt;/code&gt; 同種タプルはLLVM &lt;code&gt;vector&lt;/code&gt; タイプにマップされます。</target>
        </trans-unit>
        <trans-unit id="35f1e7a71c8a1cc6e09f468c80045e4456b3f7b6" translate="yes" xml:space="preserve">
          <source>It has a toplevel &lt;code&gt;path&lt;/code&gt; entry, then &lt;code&gt;uuid&lt;/code&gt; will be mapped to that path, interpreted relative to the directory containing the project file.</source>
          <target state="translated">これにはトップレベルの &lt;code&gt;path&lt;/code&gt; エントリがあり、 &lt;code&gt;uuid&lt;/code&gt; はそのパスにマップされ、プロジェクトファイルを含むディレクトリに関連して解釈されます。</target>
        </trans-unit>
        <trans-unit id="5302402dcc63d9a0a8348f68814a706354ef52ba" translate="yes" xml:space="preserve">
          <source>It has access to a special locally existent function called &lt;a href=&quot;../../base/base/index#new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; that creates objects of the block's type.</source>
          <target state="translated">ブロックのタイプのオブジェクトを作成する、&lt;a href=&quot;../../base/base/index#new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt;と呼ばれるローカルに存在する特別な関数にアクセスできます。</target>
        </trans-unit>
        <trans-unit id="e219a846f311411f285e81a3aae4c1e7bf0947a9" translate="yes" xml:space="preserve">
          <source>It is almost always preferable to wrap an existing primitive type in a new composite type than to define your own primitive type.</source>
          <target state="translated">独自のプリミティブ型を定義するよりも、既存のプリミティブ型を新しい複合型でラップする方が、ほとんどの場合好ましいです。</target>
        </trans-unit>
        <trans-unit id="3fbc8a317cac4fe1eddafff9a3cee6a2e600d5c8" translate="yes" xml:space="preserve">
          <source>It is also important to see how &lt;code&gt;@generated&lt;/code&gt; functions interact with method redefinition. Following the principle that a correct &lt;code&gt;@generated&lt;/code&gt; function must not observe any mutable state or cause any mutation of global state, we see the following behavior. Observe that the generated function &lt;em&gt;cannot&lt;/em&gt; call any method that was not defined prior to the &lt;em&gt;definition&lt;/em&gt; of the generated function itself.</source>
          <target state="translated">&lt;code&gt;@generated&lt;/code&gt; 関数がメソッドの再定義とどのように相互作用するかを確認することも重要です。正しい &lt;code&gt;@generated&lt;/code&gt; 関数が変更可能な状態を観察したり、グローバルな状態の変更を引き起こしたりしてはならないという原則に従って、次の動作が見られます。生成された関数は、生成された関数自体の定義の前に定義されていなかったメソッドを呼び出す&lt;em&gt;ことができないことに&lt;/em&gt;注意して&lt;em&gt;ください&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="acbe3463a0ccc2ec8908f82ece54174f7671b1ae" translate="yes" xml:space="preserve">
          <source>It is also important to understand the differences to ordinary scalars. Scalars are not mutable containers (even though they are iterable and define things like &lt;code&gt;length&lt;/code&gt;, &lt;code&gt;getindex&lt;/code&gt;, &lt;em&gt;e.g.&lt;/em&gt;&lt;code&gt;1[] == 1&lt;/code&gt;). In particular, if &lt;code&gt;x = 0.0&lt;/code&gt; is defined as a scalar, it is an error to attempt to change its value via &lt;code&gt;x[] = 1.0&lt;/code&gt;. A scalar &lt;code&gt;x&lt;/code&gt; can be converted into a zero-dimensional array containing it via &lt;code&gt;fill(x)&lt;/code&gt;, and conversely, a zero-dimensional array &lt;code&gt;a&lt;/code&gt; can be converted to the contained scalar via &lt;code&gt;a[]&lt;/code&gt;. Another difference is that a scalar can participate in linear algebra operations such as &lt;code&gt;2 * rand(2,2)&lt;/code&gt;, but the analogous operation with a zero-dimensional array &lt;code&gt;fill(2) * rand(2,2)&lt;/code&gt; is an error.</source>
          <target state="translated">通常のスカラーとの違いを理解することも重要です。スカラーは変更可能なコンテナーではありません（反復可能であり、 &lt;code&gt;length&lt;/code&gt; 、 &lt;code&gt;getindex&lt;/code&gt; などの定義があります（&lt;em&gt;例：&lt;/em&gt; &lt;code&gt;1[] == 1&lt;/code&gt; ））。特に、 &lt;code&gt;x = 0.0&lt;/code&gt; がスカラーとして定義されている場合、 &lt;code&gt;x[] = 1.0&lt;/code&gt; 介してその値を変更しようとするとエラーになります。スカラー &lt;code&gt;x&lt;/code&gt; は、 &lt;code&gt;fill(x)&lt;/code&gt; を介してそれを含むゼロ次元配列に変換でき、逆に、ゼロ次元配列 &lt;code&gt;a&lt;/code&gt; は &lt;code&gt;a[]&lt;/code&gt; 介して含まれるスカラーに変換できます。もう1つの違いは、スカラーが &lt;code&gt;2 * rand(2,2)&lt;/code&gt; などの線形代数演算に参加できることです。ただし、ゼロ次元配列 &lt;code&gt;fill(2) * rand(2,2)&lt;/code&gt; した類似の操作はエラーです。</target>
        </trans-unit>
        <trans-unit id="a6aa34f5f096577fc826b15725104feebe319049" translate="yes" xml:space="preserve">
          <source>It is also often useful to allow iteration over a collection in &lt;em&gt;reverse order&lt;/em&gt; by iterating over &lt;a href=&quot;../../base/iterators/index#Base.Iterators.reverse&quot;&gt;&lt;code&gt;Iterators.reverse(iterator)&lt;/code&gt;&lt;/a&gt;. To actually support reverse-order iteration, however, an iterator type &lt;code&gt;T&lt;/code&gt; needs to implement &lt;code&gt;iterate&lt;/code&gt; for &lt;code&gt;Iterators.Reverse{T}&lt;/code&gt;. (Given &lt;code&gt;r::Iterators.Reverse{T}&lt;/code&gt;, the underling iterator of type &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;r.itr&lt;/code&gt;.) In our &lt;code&gt;Squares&lt;/code&gt; example, we would implement &lt;code&gt;Iterators.Reverse{Squares}&lt;/code&gt; methods:</source>
          <target state="translated">&lt;a href=&quot;../../base/iterators/index#Base.Iterators.reverse&quot;&gt; &lt;code&gt;Iterators.reverse(iterator)&lt;/code&gt; を&lt;/a&gt;反復することにより、&lt;em&gt;逆の順序で&lt;/em&gt;コレクションを反復できるようにすることもしばしば役立ちます。実際には、逆の順序の反復をサポートするために、しかし、イテレータタイプ &lt;code&gt;T&lt;/code&gt; は、実装する必要が &lt;code&gt;iterate&lt;/code&gt; するため &lt;code&gt;Iterators.Reverse{T}&lt;/code&gt; 。（ &lt;code&gt;r::Iterators.Reverse{T}&lt;/code&gt; 場合、 &lt;code&gt;T&lt;/code&gt; 型の &lt;code&gt;r.itr&lt;/code&gt; イテレータはr.itrです。）この &lt;code&gt;Squares&lt;/code&gt; の例では、 &lt;code&gt;Iterators.Reverse{Squares}&lt;/code&gt; メソッドを実装します。</target>
        </trans-unit>
        <trans-unit id="3e1077394826061ef79c129bd16ea289c7d0ba39" translate="yes" xml:space="preserve">
          <source>It is also possible to apply boldface formatting by using &lt;code&gt;Base.text_colors[:bold]&lt;/code&gt; as a color. For instance, to print answers in boldface font, one can use the following as a &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Base.text_colors[:bold]&lt;/code&gt; を色として使用して、太字の書式を適用することもできます。たとえば、太字フォントで回答を印刷するには、以下を &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; として使用できます。</target>
        </trans-unit>
        <trans-unit id="b553bb959838778f24d5092568f001b6908e4f87" translate="yes" xml:space="preserve">
          <source>It is also possible to interact with a Julia REPL in the browser via &lt;a href=&quot;https://github.com/JuliaLang/IJulia.jl&quot;&gt;IJulia&lt;/a&gt;. See the package home for details.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/JuliaLang/IJulia.jl&quot;&gt;IJulia&lt;/a&gt;を介してブラウザーでJulia REPLと対話することもできます。詳細については、パッケージのホームを参照してください。</target>
        </trans-unit>
        <trans-unit id="107b61cbdd6b182357e4837cba9afce4360112e7" translate="yes" xml:space="preserve">
          <source>It is also used to &lt;code&gt;show&lt;/code&gt; julia source code which has gone through macro hygiene or otherwise contains variable names which can't be parsed normally.</source>
          <target state="translated">また、マクロ衛生を通過した、または通常は解析できない変数名を含むjuliaソースコードを &lt;code&gt;show&lt;/code&gt; するためにも使用されます。</target>
        </trans-unit>
        <trans-unit id="77f0d3358e54fed68167ad7e2f2668925a7d33bb" translate="yes" xml:space="preserve">
          <source>It is also worth emphasizing that functions should take arguments, instead of operating directly on global variables (aside from constants like &lt;a href=&quot;../../base/numbers/index#Base.MathConstants.pi&quot;&gt;&lt;code&gt;pi&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">また、グローバル変数（&lt;a href=&quot;../../base/numbers/index#Base.MathConstants.pi&quot;&gt; &lt;code&gt;pi&lt;/code&gt; &lt;/a&gt;などの定数を除く）を直接操作するのではなく、関数が引数を取る必要があることも強調しておく必要があります。</target>
        </trans-unit>
        <trans-unit id="af4f80c2a3eb6b9cc2e18a2eac5ff00feaaaca4a" translate="yes" xml:space="preserve">
          <source>It is better to avoid errors than to rely on catching them.</source>
          <target state="translated">キャッチボールに頼るよりも、ミスをしない方がいい。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
